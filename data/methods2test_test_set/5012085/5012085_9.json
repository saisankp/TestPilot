{"test_class": {"identifier": "PathValueEventFilterTest", "superclass": "", "interfaces": "", "fields": [], "file": "netflix-infix/src/test/java/com/netflix/infix/PathValueEventFilterTest.java"}, "test_case": {"identifier": "testPositiveSelection", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testPositiveSelection() {\n\t\tMockRequestTrace requestTrace = Mockito.mock(MockRequestTrace.class);\n\t\t\n\t\twhen(requestTrace.getClientInfoHostName()).thenReturn(\"localhost\");\n\t\t\n\t\tMap<String, Object> clientInfoMap = Maps.newHashMap();\n\t\tclientInfoMap.put(\"clientName\", \"client\");\n\t\tclientInfoMap.put(\"clientId\", (long) 10);\n\t\twhen(requestTrace.getClientInfoMap()).thenReturn(clientInfoMap);\n\t\t\n\t\t// Test numerical values can be filtered\n\t\tPredicate<Object> filter = new PathValueEventFilter(\"//clientInfoMap/clientId\", new NumericValuePredicate(5, \">\"));\n\t\tassertTrue(\"Filter should return true as the client ID is 10, greater than 5\", filter.apply(requestTrace));\n\t\t\n\t\t// Test string value can be filtered\n\t\tfilter = new PathValueEventFilter(\"//clientInfoMap/clientName\", new StringValuePredicate(\"client\"));\n\t\tassertTrue(\"Filter should return true as client name is 'client'\", filter.apply(requestTrace));\n\t\t\n\t\t// Test attribute is supported\n\t\tfilter = new PathValueEventFilter(\"//@clientInfoHostName\", new StringValuePredicate(\"localhost\"));\n\t\tassertTrue(\"Filter should return tre as clientInfoHostName is localhost\", filter.apply(requestTrace));\n\t}", "signature": "void testPositiveSelection()", "full_signature": "@Test public void testPositiveSelection()", "class_method_signature": "PathValueEventFilterTest.testPositiveSelection()", "testcase": true, "constructor": false, "invocations": ["mock", "thenReturn", "when", "getClientInfoHostName", "newHashMap", "put", "put", "thenReturn", "when", "getClientInfoMap", "assertTrue", "apply", "assertTrue", "apply", "assertTrue", "apply"]}, "focal_class": {"identifier": "PathValueEventFilter", "superclass": "", "interfaces": "implements Predicate<T>", "fields": [{"original_string": "private String xpath;", "modifier": "private", "type": "String", "declarator": "xpath", "var_name": "xpath"}, {"original_string": "private ValuePredicate<T> predicate;", "modifier": "private", "type": "ValuePredicate<T>", "declarator": "predicate", "var_name": "predicate"}], "methods": [{"identifier": "PathValueEventFilter", "parameters": "(String path, ValuePredicate<T> predicate)", "modifiers": "public", "return": "", "signature": " PathValueEventFilter(String path, ValuePredicate<T> predicate)", "full_signature": "public  PathValueEventFilter(String path, ValuePredicate<T> predicate)", "class_method_signature": "PathValueEventFilter.PathValueEventFilter(String path, ValuePredicate<T> predicate)", "testcase": false, "constructor": true}, {"identifier": "apply", "parameters": "(Object input)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean apply(Object input)", "full_signature": "@Override public boolean apply(Object input)", "class_method_signature": "PathValueEventFilter.apply(Object input)", "testcase": false, "constructor": false}, {"identifier": "getXpath", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getXpath()", "full_signature": "public String getXpath()", "class_method_signature": "PathValueEventFilter.getXpath()", "testcase": false, "constructor": false}, {"identifier": "getPredicate", "parameters": "()", "modifiers": "public", "return": "ValuePredicate<?>", "signature": "ValuePredicate<?> getPredicate()", "full_signature": "public ValuePredicate<?> getPredicate()", "class_method_signature": "PathValueEventFilter.getPredicate()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "PathValueEventFilter.toString()", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "PathValueEventFilter.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "PathValueEventFilter.equals(Object obj)", "testcase": false, "constructor": false}], "file": "netflix-infix/src/main/java/com/netflix/infix/PathValueEventFilter.java"}, "focal_method": {"identifier": "apply", "parameters": "(Object input)", "modifiers": "@Override public", "return": "boolean", "body": "@Override\n    public boolean apply(Object input) {\n        JXPathContext jxpath = JXPathContext.newContext(input);\n        // We should allow non-existing path, and let predicate handle it. \n        jxpath.setLenient(true);\n        \n        @SuppressWarnings(\"unchecked\")\n        T value = (T)jxpath.getValue(xpath);\n       \n        return predicate.apply(value);\n    }", "signature": "boolean apply(Object input)", "full_signature": "@Override public boolean apply(Object input)", "class_method_signature": "PathValueEventFilter.apply(Object input)", "testcase": false, "constructor": false, "invocations": ["newContext", "setLenient", "getValue", "apply"]}, "repository": {"repo_id": 5012085, "url": "https://github.com/Netflix/netflix-commons", "language": "Java", "is_fork": false, "fork_count": 74, "stargazer_count": 145, "size": 404, "license": "licensed"}}