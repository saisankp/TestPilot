{"test_class": {"identifier": "KafkaStreamsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@ClassRule\n    public static final EmbeddedSingleNodeKafkaCluster CLUSTER = new EmbeddedSingleNodeKafkaCluster();", "modifier": "@ClassRule\n    public static final", "type": "EmbeddedSingleNodeKafkaCluster", "declarator": "CLUSTER = new EmbeddedSingleNodeKafkaCluster()", "var_name": "CLUSTER"}], "file": "streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java"}, "test_case": {"identifier": "testCleanupIsolation", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCleanupIsolation() throws Exception {\n        final KStreamBuilder builder = new KStreamBuilder();\n\n        final String appId1 = \"testIsolation-1\";\n        final String appId2 = \"testIsolation-2\";\n        final String stateDir = TestUtils.tempDirectory(\"kafka-test\").getPath();\n        final File stateDirApp1 = new File(stateDir + File.separator + appId1);\n        final File stateDirApp2 = new File(stateDir + File.separator + appId2);\n\n        final Properties props = new Properties();\n        props.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, CLUSTER.bootstrapServers());\n        props.put(StreamsConfig.STATE_DIR_CONFIG, stateDir);\n\n        assertFalse(stateDirApp1.exists());\n        assertFalse(stateDirApp2.exists());\n\n        props.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, appId1);\n        final KafkaStreams streams1 = new KafkaStreams(builder, props);\n        props.setProperty(StreamsConfig.APPLICATION_ID_CONFIG, appId2);\n        final KafkaStreams streams2 = new KafkaStreams(builder, props);\n\n        assertTrue(stateDirApp1.exists());\n        assertTrue(stateDirApp2.exists());\n\n        streams1.cleanUp();\n        assertFalse(stateDirApp1.exists());\n        assertTrue(stateDirApp2.exists());\n\n        streams2.cleanUp();\n        assertFalse(stateDirApp1.exists());\n        assertFalse(stateDirApp2.exists());\n    }", "signature": "void testCleanupIsolation()", "full_signature": "@Test public void testCleanupIsolation()", "class_method_signature": "KafkaStreamsTest.testCleanupIsolation()", "testcase": true, "constructor": false, "invocations": ["getPath", "tempDirectory", "setProperty", "bootstrapServers", "put", "assertFalse", "exists", "assertFalse", "exists", "setProperty", "setProperty", "assertTrue", "exists", "assertTrue", "exists", "cleanUp", "assertFalse", "exists", "assertTrue", "exists", "cleanUp", "assertFalse", "exists", "assertFalse", "exists"]}, "focal_class": {"identifier": "KafkaStreams", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(KafkaStreams.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(KafkaStreams.class)", "var_name": "log"}, {"original_string": "private static final AtomicInteger STREAM_CLIENT_ID_SEQUENCE = new AtomicInteger(1);", "modifier": "private static final", "type": "AtomicInteger", "declarator": "STREAM_CLIENT_ID_SEQUENCE = new AtomicInteger(1)", "var_name": "STREAM_CLIENT_ID_SEQUENCE"}, {"original_string": "private static final String JMX_PREFIX = \"kafka.streams\";", "modifier": "private static final", "type": "String", "declarator": "JMX_PREFIX = \"kafka.streams\"", "var_name": "JMX_PREFIX"}, {"original_string": "private static final int CREATED = 0;", "modifier": "private static final", "type": "int", "declarator": "CREATED = 0", "var_name": "CREATED"}, {"original_string": "private static final int RUNNING = 1;", "modifier": "private static final", "type": "int", "declarator": "RUNNING = 1", "var_name": "RUNNING"}, {"original_string": "private static final int STOPPED = 2;", "modifier": "private static final", "type": "int", "declarator": "STOPPED = 2", "var_name": "STOPPED"}, {"original_string": "private int state = CREATED;", "modifier": "private", "type": "int", "declarator": "state = CREATED", "var_name": "state"}, {"original_string": "private final StreamThread[] threads;", "modifier": "private final", "type": "StreamThread[]", "declarator": "threads", "var_name": "threads"}, {"original_string": "private final Metrics metrics;", "modifier": "private final", "type": "Metrics", "declarator": "metrics", "var_name": "metrics"}, {"original_string": "private final UUID processId;", "modifier": "private final", "type": "UUID", "declarator": "processId", "var_name": "processId"}, {"original_string": "private final StreamsConfig config;", "modifier": "private final", "type": "StreamsConfig", "declarator": "config", "var_name": "config"}], "methods": [{"identifier": "KafkaStreams", "parameters": "(final TopologyBuilder builder, final Properties props)", "modifiers": "public", "return": "", "signature": " KafkaStreams(final TopologyBuilder builder, final Properties props)", "full_signature": "public  KafkaStreams(final TopologyBuilder builder, final Properties props)", "class_method_signature": "KafkaStreams.KafkaStreams(final TopologyBuilder builder, final Properties props)", "testcase": false, "constructor": true}, {"identifier": "KafkaStreams", "parameters": "(final TopologyBuilder builder, final StreamsConfig config)", "modifiers": "public", "return": "", "signature": " KafkaStreams(final TopologyBuilder builder, final StreamsConfig config)", "full_signature": "public  KafkaStreams(final TopologyBuilder builder, final StreamsConfig config)", "class_method_signature": "KafkaStreams.KafkaStreams(final TopologyBuilder builder, final StreamsConfig config)", "testcase": false, "constructor": true}, {"identifier": "KafkaStreams", "parameters": "(final TopologyBuilder builder, final StreamsConfig config, final KafkaClientSupplier clientSupplier)", "modifiers": "public", "return": "", "signature": " KafkaStreams(final TopologyBuilder builder, final StreamsConfig config, final KafkaClientSupplier clientSupplier)", "full_signature": "public  KafkaStreams(final TopologyBuilder builder, final StreamsConfig config, final KafkaClientSupplier clientSupplier)", "class_method_signature": "KafkaStreams.KafkaStreams(final TopologyBuilder builder, final StreamsConfig config, final KafkaClientSupplier clientSupplier)", "testcase": false, "constructor": true}, {"identifier": "start", "parameters": "()", "modifiers": "public synchronized", "return": "void", "signature": "void start()", "full_signature": "public synchronized void start()", "class_method_signature": "KafkaStreams.start()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public synchronized", "return": "void", "signature": "void close()", "full_signature": "public synchronized void close()", "class_method_signature": "KafkaStreams.close()", "testcase": false, "constructor": false}, {"identifier": "cleanUp", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void cleanUp()", "full_signature": "public void cleanUp()", "class_method_signature": "KafkaStreams.cleanUp()", "testcase": false, "constructor": false}, {"identifier": "setUncaughtExceptionHandler", "parameters": "(final Thread.UncaughtExceptionHandler eh)", "modifiers": "public", "return": "void", "signature": "void setUncaughtExceptionHandler(final Thread.UncaughtExceptionHandler eh)", "full_signature": "public void setUncaughtExceptionHandler(final Thread.UncaughtExceptionHandler eh)", "class_method_signature": "KafkaStreams.setUncaughtExceptionHandler(final Thread.UncaughtExceptionHandler eh)", "testcase": false, "constructor": false}], "file": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java"}, "focal_method": {"identifier": "cleanUp", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void cleanUp() {\n        if (this.state == RUNNING) {\n            throw new IllegalStateException(\"Cannot clean up while running.\");\n        }\n\n        final String localApplicationDir = this.config.getString(StreamsConfig.STATE_DIR_CONFIG)\n            + File.separator\n            + this.config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n\n        log.debug(\"Clean up local Kafka Streams data in {}\", localApplicationDir);\n        log.debug(\"Removing local Kafka Streams application data in {} for application {}\",\n            localApplicationDir,\n            this.config.getString(StreamsConfig.APPLICATION_ID_CONFIG));\n        Utils.delete(new File(localApplicationDir));\n    }", "signature": "void cleanUp()", "full_signature": "public void cleanUp()", "class_method_signature": "KafkaStreams.cleanUp()", "testcase": false, "constructor": false, "invocations": ["getString", "getString", "debug", "debug", "getString", "delete"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}