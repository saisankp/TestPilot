{"test_class": {"identifier": "SmileCorrectionAlgorithmTest", "superclass": "", "interfaces": "", "fields": [], "file": "s3tbx-meris-radiometry/src/test/java/org/esa/s3tbx/meris/radiometry/smilecorr/SmileCorrectionAlgorithmTest.java"}, "test_case": {"identifier": "testCalculateSmile", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCalculateSmile() throws Exception {\n        SmileCorrectionAuxdata auxdata = SmileCorrectionAuxdata.loadAuxdata(\"MER_F\");\n        SmileCorrectionAlgorithm algorithm = new SmileCorrectionAlgorithm(auxdata);\n        double correct = algorithm.correct(0, 1, new double[]{412.691, 412.891}, true);\n        assertEquals(412.691988282132,correct,1e-8);\n    }", "signature": "void testCalculateSmile()", "full_signature": "@Test public void testCalculateSmile()", "class_method_signature": "SmileCorrectionAlgorithmTest.testCalculateSmile()", "testcase": true, "constructor": false, "invocations": ["loadAuxdata", "correct", "assertEquals"]}, "focal_class": {"identifier": "SmileCorrectionAlgorithm", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final SmileCorrectionAuxdata auxdata;", "modifier": "private final", "type": "SmileCorrectionAuxdata", "declarator": "auxdata", "var_name": "auxdata"}], "methods": [{"identifier": "SmileCorrectionAlgorithm", "parameters": "(SmileCorrectionAuxdata auxdata)", "modifiers": "public", "return": "", "signature": " SmileCorrectionAlgorithm(SmileCorrectionAuxdata auxdata)", "full_signature": "public  SmileCorrectionAlgorithm(SmileCorrectionAuxdata auxdata)", "class_method_signature": "SmileCorrectionAlgorithm.SmileCorrectionAlgorithm(SmileCorrectionAuxdata auxdata)", "testcase": false, "constructor": true}, {"identifier": "correct", "parameters": "(int bandIndex, int detectorIndex, double[] radianceSamples, boolean isLand)", "modifiers": "public", "return": "double", "signature": "double correct(int bandIndex, int detectorIndex, double[] radianceSamples, boolean isLand)", "full_signature": "public double correct(int bandIndex, int detectorIndex, double[] radianceSamples, boolean isLand)", "class_method_signature": "SmileCorrectionAlgorithm.correct(int bandIndex, int detectorIndex, double[] radianceSamples, boolean isLand)", "testcase": false, "constructor": false}], "file": "s3tbx-meris-radiometry/src/main/java/org/esa/s3tbx/meris/radiometry/smilecorr/SmileCorrectionAlgorithm.java"}, "focal_method": {"identifier": "correct", "parameters": "(int bandIndex, int detectorIndex, double[] radianceSamples, boolean isLand)", "modifiers": "public", "return": "double", "body": "public double correct(int bandIndex, int detectorIndex, double[] radianceSamples, boolean isLand) {\n        double originalValue = radianceSamples[bandIndex];\n        if (detectorIndex < 0 || detectorIndex >= auxdata.getDetectorWavelengths().length) {\n            return originalValue;\n        }\n\n        boolean[] shouldCorrect;\n        int[] lowerIndexes;\n        int[] upperIndexes;\n        if (isLand) {\n            shouldCorrect = auxdata.getRadCorrFlagsLand();\n            lowerIndexes = auxdata.getLowerBandIndexesLand();\n            upperIndexes = auxdata.getUpperBandIndexesLand();\n        } else {\n            shouldCorrect = auxdata.getRadCorrFlagsWater();\n            lowerIndexes = auxdata.getLowerBandIndexesWater();\n            upperIndexes = auxdata.getUpperBandIndexesWater();\n        }\n        double[] detectorE0s = auxdata.getDetectorSunSpectralFluxes()[detectorIndex];\n        double[] detectorWLs = auxdata.getDetectorWavelengths()[detectorIndex];\n        double[] theoretWLs = auxdata.getTheoreticalWavelengths();\n        double[] theoretE0s = auxdata.getTheoreticalSunSpectralFluxes();\n\n        // perform irradiance correction\n        double r0 = originalValue / detectorE0s[bandIndex];\n        double rc = r0 * theoretE0s[bandIndex];\n        if (shouldCorrect[bandIndex]) {\n            // perform reflectance correction\n            int lowerIndex = lowerIndexes[bandIndex];\n            int upperIndex = upperIndexes[bandIndex];\n            double r1 = radianceSamples[lowerIndex] / detectorE0s[lowerIndex];\n            double r2 = radianceSamples[upperIndex] / detectorE0s[upperIndex];\n            double dl = (theoretWLs[bandIndex] - detectorWLs[bandIndex]) / (detectorWLs[upperIndex] - detectorWLs[lowerIndex]);\n            double dr = (r2 - r1) * dl * theoretE0s[bandIndex];\n            rc += dr;\n        }\n        return rc;\n    }", "signature": "double correct(int bandIndex, int detectorIndex, double[] radianceSamples, boolean isLand)", "full_signature": "public double correct(int bandIndex, int detectorIndex, double[] radianceSamples, boolean isLand)", "class_method_signature": "SmileCorrectionAlgorithm.correct(int bandIndex, int detectorIndex, double[] radianceSamples, boolean isLand)", "testcase": false, "constructor": false, "invocations": ["getDetectorWavelengths", "getRadCorrFlagsLand", "getLowerBandIndexesLand", "getUpperBandIndexesLand", "getRadCorrFlagsWater", "getLowerBandIndexesWater", "getUpperBandIndexesWater", "getDetectorSunSpectralFluxes", "getDetectorWavelengths", "getTheoreticalWavelengths", "getTheoreticalSunSpectralFluxes"]}, "repository": {"repo_id": 22256861, "url": "https://github.com/senbox-org/s3tbx", "stars": 22, "created": "7/25/2014 12:57:22 PM +00:00", "updates": "2020-01-27T10:23:46+00:00", "fork": "False", "license": "licensed"}}