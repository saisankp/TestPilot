{"test_class": {"identifier": "TestMergeStreamDataConsistency", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Logger LOG = Logger.getLogger(\n\t\t\tTestMergeStreamDataConsistency.class);", "modifier": "private static", "type": "Logger", "declarator": "LOG = Logger.getLogger(\n\t\t\tTestMergeStreamDataConsistency.class)", "var_name": "LOG"}, {"original_string": "private static String className = TestMergeStreamDataConsistency.class\n\t\t\t.getSimpleName();", "modifier": "private static", "type": "String", "declarator": "className = TestMergeStreamDataConsistency.class\n\t\t\t.getSimpleName()", "var_name": "className"}, {"original_string": "FileSystem fs;", "modifier": "", "type": "FileSystem", "declarator": "fs", "var_name": "fs"}, {"original_string": "String mergedStreamUrl = \"file:///tmp/test/\" + className + \"/1/\" ;", "modifier": "", "type": "String", "declarator": "mergedStreamUrl = \"file:///tmp/test/\" + className + \"/1/\"", "var_name": "mergedStreamUrl"}, {"original_string": "String localStreamUrl = (\"file:///tmp/test/\" + className + \"/2/,\" +\n\t\t\t\"file:///tmp/test/\" + className +\"/3/\");", "modifier": "", "type": "String", "declarator": "localStreamUrl = (\"file:///tmp/test/\" + className + \"/2/,\" +\n\t\t\t\"file:///tmp/test/\" + className +\"/3/\")", "var_name": "localStreamUrl"}, {"original_string": "String [] localStreamUrls = localStreamUrl.split(\",\");", "modifier": "", "type": "String []", "declarator": "localStreamUrls = localStreamUrl.split(\",\")", "var_name": "localStreamUrls"}, {"original_string": "List<String> emptyStreamName = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "emptyStreamName = new ArrayList<String>()", "var_name": "emptyStreamName"}, {"original_string": "List<String> missedFilesStreamName = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "missedFilesStreamName = new ArrayList<String>()", "var_name": "missedFilesStreamName"}, {"original_string": "List<String> emptyDirStreamName = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "emptyDirStreamName = new ArrayList<String>()", "var_name": "emptyDirStreamName"}, {"original_string": "List<String> consistentDataStreamName = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "consistentDataStreamName = new ArrayList<String>()", "var_name": "consistentDataStreamName"}, {"original_string": "List<String> dataReplayFilesStreamName = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "dataReplayFilesStreamName = new ArrayList<String>()", "var_name": "dataReplayFilesStreamName"}, {"original_string": "List<String> extrafilesStreamName = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "extrafilesStreamName = new ArrayList<String>()", "var_name": "extrafilesStreamName"}, {"original_string": "List<String> singleFileStreamName = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "singleFileStreamName = new ArrayList<String>()", "var_name": "singleFileStreamName"}, {"original_string": "List<String> missingSingleFileStreamName = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "missingSingleFileStreamName = new ArrayList<String>()", "var_name": "missingSingleFileStreamName"}, {"original_string": "List<String> inconsistencyAtEndOfStream = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "inconsistencyAtEndOfStream = new ArrayList<String>()", "var_name": "inconsistencyAtEndOfStream"}, {"original_string": "List<String> purgedPathStreaName = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "purgedPathStreaName = new ArrayList<String>()", "var_name": "purgedPathStreaName"}, {"original_string": "List<String> purgedOnLocalStream = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "purgedOnLocalStream = new ArrayList<String>()", "var_name": "purgedOnLocalStream"}, {"original_string": "List<String> duplicateFileStream = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "duplicateFileStream = new ArrayList<String>()", "var_name": "duplicateFileStream"}, {"original_string": "List<String> allStreamNames = new ArrayList<String>();", "modifier": "", "type": "List<String>", "declarator": "allStreamNames = new ArrayList<String>()", "var_name": "allStreamNames"}, {"original_string": "List<Path> emptyPaths = new ArrayList<Path>();", "modifier": "", "type": "List<Path>", "declarator": "emptyPaths = new ArrayList<Path>()", "var_name": "emptyPaths"}, {"original_string": "List<Path> emptyDirsPaths = new ArrayList<Path>();", "modifier": "", "type": "List<Path>", "declarator": "emptyDirsPaths = new ArrayList<Path>()", "var_name": "emptyDirsPaths"}, {"original_string": "List<Path> missedFilePaths = new ArrayList<Path>();", "modifier": "", "type": "List<Path>", "declarator": "missedFilePaths = new ArrayList<Path>()", "var_name": "missedFilePaths"}, {"original_string": "List<Path> dataReplayFilePaths = new ArrayList<Path>();", "modifier": "", "type": "List<Path>", "declarator": "dataReplayFilePaths = new ArrayList<Path>()", "var_name": "dataReplayFilePaths"}, {"original_string": "List<Path> extraFilePaths = new ArrayList<Path>();", "modifier": "", "type": "List<Path>", "declarator": "extraFilePaths = new ArrayList<Path>()", "var_name": "extraFilePaths"}, {"original_string": "List<Path> missingSingleFilePath =  new ArrayList<Path>();", "modifier": "", "type": "List<Path>", "declarator": "missingSingleFilePath =  new ArrayList<Path>()", "var_name": "missingSingleFilePath"}, {"original_string": "List<Path> inconsistencyEndPaths = new ArrayList<Path>();", "modifier": "", "type": "List<Path>", "declarator": "inconsistencyEndPaths = new ArrayList<Path>()", "var_name": "inconsistencyEndPaths"}, {"original_string": "List<Path> purgedPaths = new ArrayList<Path>();", "modifier": "", "type": "List<Path>", "declarator": "purgedPaths = new ArrayList<Path>()", "var_name": "purgedPaths"}, {"original_string": "List<Path> purgedLocalPaths = new ArrayList<Path>();", "modifier": "", "type": "List<Path>", "declarator": "purgedLocalPaths = new ArrayList<Path>()", "var_name": "purgedLocalPaths"}, {"original_string": "List<Path> duplicateFilePaths = new ArrayList<Path>();", "modifier": "", "type": "List<Path>", "declarator": "duplicateFilePaths = new ArrayList<Path>()", "var_name": "duplicateFilePaths"}, {"original_string": "boolean missing = false;", "modifier": "", "type": "boolean", "declarator": "missing = false", "var_name": "missing"}, {"original_string": "boolean missingAtEnd = false;", "modifier": "", "type": "boolean", "declarator": "missingAtEnd = false", "var_name": "missingAtEnd"}, {"original_string": "boolean purgedFlag = false;", "modifier": "", "type": "boolean", "declarator": "purgedFlag = false", "var_name": "purgedFlag"}, {"original_string": "boolean purgedLocalFlag = false;", "modifier": "", "type": "boolean", "declarator": "purgedLocalFlag = false", "var_name": "purgedLocalFlag"}, {"original_string": "long temptime = System.currentTimeMillis();", "modifier": "", "type": "long", "declarator": "temptime = System.currentTimeMillis()", "var_name": "temptime"}], "file": "conduit-worker/src/test/java/com/inmobi/conduit/utils/TestMergeStreamDataConsistency.java"}, "test_case": {"identifier": "testMergeStream", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testMergeStream() throws Exception {\n\t\tMergeStreamDataConsistency obj = new MergeStreamDataConsistency();\n\t\ttestLocalMergeStreams(emptyStreamName, emptyPaths, obj);\n\t\ttestLocalMergeStreams(emptyDirStreamName, emptyDirsPaths, obj);\n\t\ttestLocalMergeStreams(missedFilesStreamName, missedFilePaths, obj);\n\t\ttestLocalMergeStreams(consistentDataStreamName, emptyPaths, obj);\n\t\ttestLocalMergeStreams(dataReplayFilesStreamName, dataReplayFilePaths, obj);\n\t\ttestLocalMergeStreams(extrafilesStreamName, extraFilePaths, obj);\n\t\ttestLocalMergeStreams(singleFileStreamName, emptyPaths, obj);\n\t\ttestLocalMergeStreams(missingSingleFileStreamName, missingSingleFilePath, obj);\n\t\ttestLocalMergeStreams(inconsistencyAtEndOfStream, inconsistencyEndPaths, obj);\n\t\ttestLocalMergeStreams(purgedPathStreaName, purgedPaths, obj);\n    testLocalMergeStreams(purgedOnLocalStream, purgedLocalPaths, obj);\n    testLocalMergeStreams(duplicateFileStream, duplicateFilePaths, obj);\n\t\t\n\t\tLOG.info(\"all streams together\");\n\t\tList<Path> allStreamPaths = new ArrayList<Path>();\n\t\tallStreamPaths.addAll(emptyPaths);\n\t\tallStreamPaths.addAll(emptyDirsPaths);\n\t\tallStreamPaths.addAll(missedFilePaths);\n\t\tallStreamPaths.addAll(dataReplayFilePaths);\n\t\tallStreamPaths.addAll(extraFilePaths);\n\t\tallStreamPaths.addAll(missingSingleFilePath);\n\t\tallStreamPaths.addAll(inconsistencyEndPaths);\n\t\tallStreamPaths.addAll(purgedPaths);\n    allStreamPaths.addAll(purgedLocalPaths);\n    allStreamPaths.addAll(duplicateFilePaths);\n\n\t\ttestLocalMergeStreams(allStreamNames, allStreamPaths, obj);\n\t\t// testing run method\n\t\tList<Path> inconsistentdata = new ArrayList<Path>();\n\t\tString[] args = { (\"file:///tmp/test/\" + className + \"/2/,file:///tmp/test/\"\n\t\t\t\t+ className +\"/3/\"), \"file:///tmp/test/\" + className + \"/1/\"};\n\t\tLOG.info(\"testing run method\");\n\t\tinconsistentdata = obj.run(args);\n\t\tAssert.assertEquals(inconsistentdata.size(), allStreamPaths.size());\n\t\tAssert.assertTrue(inconsistentdata.containsAll(allStreamPaths));\n\t}", "signature": "void testMergeStream()", "full_signature": "@Test public void testMergeStream()", "class_method_signature": "TestMergeStreamDataConsistency.testMergeStream()", "testcase": true, "constructor": false, "invocations": ["testLocalMergeStreams", "testLocalMergeStreams", "testLocalMergeStreams", "testLocalMergeStreams", "testLocalMergeStreams", "testLocalMergeStreams", "testLocalMergeStreams", "testLocalMergeStreams", "testLocalMergeStreams", "testLocalMergeStreams", "testLocalMergeStreams", "testLocalMergeStreams", "info", "addAll", "addAll", "addAll", "addAll", "addAll", "addAll", "addAll", "addAll", "addAll", "addAll", "testLocalMergeStreams", "info", "run", "assertEquals", "size", "size", "assertTrue", "containsAll"]}, "focal_class": {"identifier": "MergeStreamDataConsistency", "superclass": "extends CompareDataConsistency", "interfaces": "", "fields": [{"original_string": "private static final Log LOG = LogFactory.getLog(\n      MergeStreamDataConsistency.class);", "modifier": "private static final", "type": "Log", "declarator": "LOG = LogFactory.getLog(\n      MergeStreamDataConsistency.class)", "var_name": "LOG"}], "methods": [{"identifier": "listingValidation", "parameters": "(String mergedStreamRoorDir, String[] \n      localStreamrootDirs, List<String> streamNames)", "modifiers": "public", "return": "List<Path>", "signature": "List<Path> listingValidation(String mergedStreamRoorDir, String[] \n      localStreamrootDirs, List<String> streamNames)", "full_signature": "public List<Path> listingValidation(String mergedStreamRoorDir, String[] \n      localStreamrootDirs, List<String> streamNames)", "class_method_signature": "MergeStreamDataConsistency.listingValidation(String mergedStreamRoorDir, String[] \n      localStreamrootDirs, List<String> streamNames)", "testcase": false, "constructor": false}, {"identifier": "doRecursiveListing", "parameters": "(Path streamDir, \n      TreeMap<String, Path> listOfFiles, FileSystem fs, List<Path> inconsistency)", "modifiers": "public", "return": "void", "signature": "void doRecursiveListing(Path streamDir, \n      TreeMap<String, Path> listOfFiles, FileSystem fs, List<Path> inconsistency)", "full_signature": "public void doRecursiveListing(Path streamDir, \n      TreeMap<String, Path> listOfFiles, FileSystem fs, List<Path> inconsistency)", "class_method_signature": "MergeStreamDataConsistency.doRecursiveListing(Path streamDir, \n      TreeMap<String, Path> listOfFiles, FileSystem fs, List<Path> inconsistency)", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "(String [] args)", "modifiers": "public", "return": "List<Path>", "signature": "List<Path> run(String [] args)", "full_signature": "public List<Path> run(String [] args)", "class_method_signature": "MergeStreamDataConsistency.run(String [] args)", "testcase": false, "constructor": false}, {"identifier": "main", "parameters": "(String [] args)", "modifiers": "public static", "return": "void", "signature": "void main(String [] args)", "full_signature": "public static void main(String [] args)", "class_method_signature": "MergeStreamDataConsistency.main(String [] args)", "testcase": false, "constructor": false}], "file": "conduit-worker/src/main/java/com/inmobi/conduit/utils/MergeStreamDataConsistency.java"}, "focal_method": {"identifier": "run", "parameters": "(String [] args)", "modifiers": "public", "return": "List<Path>", "body": "public List<Path> run(String [] args) throws Exception {\n    List<Path> inconsistencydata = new ArrayList<Path>();\n    String [] localStreamrootDirs = args[0].split(\",\");\n    String mergedStreamRoorDir = args[1];\t\n    List<String> streamNames = new ArrayList<String>();\n    if (args.length == 2) {\n      FileSystem fs = new Path(mergedStreamRoorDir, \"streams\").getFileSystem(\n          new Configuration());\n      FileStatus[] fileStatuses;\n      try {\n        fileStatuses = fs.listStatus(new Path(mergedStreamRoorDir,\n          \"streams\"));\n      } catch (FileNotFoundException fe) {\n        fileStatuses = null;\n      }\n      if (fileStatuses != null && fileStatuses.length != 0) {\n        for (FileStatus file : fileStatuses) {  \n          streamNames.add(file.getPath().getName());\n        } \n      } else {\n        System.out.println(\"There are no stream names in the stream\");\n      }\n    } else if (args.length == 3) {\n      for (String streamname : args[2].split(\",\")) {\n        streamNames.add(streamname);\n      }\n    } \n    inconsistencydata = this.listingValidation(mergedStreamRoorDir, \n        localStreamrootDirs, streamNames);\n    if (inconsistencydata.isEmpty()) {\n      System.out.println(\"there is no inconsistency data\");\n    }\n    return inconsistencydata;\n  }", "signature": "List<Path> run(String [] args)", "full_signature": "public List<Path> run(String [] args)", "class_method_signature": "MergeStreamDataConsistency.run(String [] args)", "testcase": false, "constructor": false, "invocations": ["split", "getFileSystem", "listStatus", "add", "getName", "getPath", "println", "split", "add", "listingValidation", "isEmpty", "println"]}, "repository": {"repo_id": 7218024, "url": "https://github.com/InMobi/conduit", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 9, "size": 49400, "license": "licensed"}}