{"test_class": {"identifier": "SemanticPropUtilTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final TypeInformation<?> threeIntTupleType = new TupleTypeInfo<Tuple3<Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "threeIntTupleType = new TupleTypeInfo<Tuple3<Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)", "var_name": "threeIntTupleType"}, {"original_string": "private final TypeInformation<?> fourIntTupleType = new TupleTypeInfo<Tuple4<Integer, Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "fourIntTupleType = new TupleTypeInfo<Tuple4<Integer, Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)", "var_name": "fourIntTupleType"}, {"original_string": "private final TypeInformation<?> fiveIntTupleType = new TupleTypeInfo<Tuple5<Integer, Integer, Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "fiveIntTupleType = new TupleTypeInfo<Tuple5<Integer, Integer, Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)", "var_name": "fiveIntTupleType"}, {"original_string": "private final TypeInformation<?> threeMixedTupleType = new TupleTypeInfo<Tuple3<Integer, Long, String>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "threeMixedTupleType = new TupleTypeInfo<Tuple3<Integer, Long, String>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)", "var_name": "threeMixedTupleType"}, {"original_string": "private final TypeInformation<?> nestedTupleType = new TupleTypeInfo<Tuple3<Tuple3<Integer, Integer, Integer>, Integer, Integer>>(threeIntTupleType,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "nestedTupleType = new TupleTypeInfo<Tuple3<Tuple3<Integer, Integer, Integer>, Integer, Integer>>(threeIntTupleType,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)", "var_name": "nestedTupleType"}, {"original_string": "private final TypeInformation<?> deepNestedTupleType = new TupleTypeInfo<Tuple3<Integer, Tuple3<Tuple3<Integer, Integer, Integer>, Integer, Integer>, Integer>>(\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, nestedTupleType, BasicTypeInfo.INT_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "deepNestedTupleType = new TupleTypeInfo<Tuple3<Integer, Tuple3<Tuple3<Integer, Integer, Integer>, Integer, Integer>, Integer>>(\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, nestedTupleType, BasicTypeInfo.INT_TYPE_INFO)", "var_name": "deepNestedTupleType"}, {"original_string": "private final TypeInformation<?> pojoType = TypeExtractor.getForClass(TestPojo.class);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "pojoType = TypeExtractor.getForClass(TestPojo.class)", "var_name": "pojoType"}, {"original_string": "private final TypeInformation<?> pojo2Type = TypeExtractor.getForClass(TestPojo2.class);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "pojo2Type = TypeExtractor.getForClass(TestPojo2.class)", "var_name": "pojo2Type"}, {"original_string": "private final TypeInformation<?> nestedPojoType = TypeExtractor.getForClass(NestedTestPojo.class);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "nestedPojoType = TypeExtractor.getForClass(NestedTestPojo.class)", "var_name": "nestedPojoType"}, {"original_string": "private final TypeInformation<?> pojoInTupleType = new TupleTypeInfo<Tuple3<Integer, Integer, TestPojo>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, pojoType);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "pojoInTupleType = new TupleTypeInfo<Tuple3<Integer, Integer, TestPojo>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, pojoType)", "var_name": "pojoInTupleType"}, {"original_string": "private final TypeInformation<?> intType = BasicTypeInfo.INT_TYPE_INFO;", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "intType = BasicTypeInfo.INT_TYPE_INFO", "var_name": "intType"}], "file": "flink-java/src/test/java/org/apache/flink/api/java/functions/SemanticPropUtilTest.java"}, "test_case": {"identifier": "testDualProjectionProperties", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testDualProjectionProperties() {\n\n\t\tint[] pMap = new int[]{4,2,0,1,3,4};\n\t\tboolean[] iMap = new boolean[]{true, true, false, true, false, false};\n\t\tDualInputSemanticProperties sp = SemanticPropUtil.createProjectionPropertiesDual(pMap, iMap,\n\t\t\t\tfiveIntTupleType, fiveIntTupleType);\n\t\tassertTrue(sp.getForwardingTargetFields(0, 4).contains(0));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 2).contains(1));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 0).contains(2));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 1).contains(3));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 3).contains(4));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 4).contains(5));\n\n\t\tpMap = new int[]{4,2,0,4,0,1};\n\t\tiMap = new boolean[]{true, true, false, true, false, false};\n\t\tsp = SemanticPropUtil.createProjectionPropertiesDual(pMap, iMap, fiveIntTupleType, fiveIntTupleType);\n\t\tassertTrue(sp.getForwardingTargetFields(0, 4).size() == 2);\n\t\tassertTrue(sp.getForwardingTargetFields(1, 0).size() == 2);\n\t\tassertTrue(sp.getForwardingTargetFields(0, 4).contains(0));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 2).contains(1));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 0).contains(2));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 4).contains(3));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 0).contains(4));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 1).contains(5));\n\n\t\tpMap = new int[]{2,1,0,1};\n\t\tiMap = new boolean[]{false, false, true, true};\n\t\tsp = SemanticPropUtil.createProjectionPropertiesDual(pMap, iMap, nestedTupleType, threeIntTupleType);\n\t\tassertTrue(sp.getForwardingTargetFields(1, 2).contains(0));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 1).contains(1));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 0).contains(2));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 1).contains(3));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 2).contains(4));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 3).contains(5));\n\n\t\tpMap = new int[]{1,0,0};\n\t\tiMap = new boolean[]{false, false, true};\n\t\tsp = SemanticPropUtil.createProjectionPropertiesDual(pMap, iMap, nestedTupleType, deepNestedTupleType);\n\t\tassertTrue(sp.getForwardingTargetFields(1, 1).contains(0));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 2).contains(1));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 3).contains(2));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 4).contains(3));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 5).contains(4));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 0).contains(5));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 0).contains(6));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 1).contains(7));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 2).contains(8));\n\n\t\tpMap = new int[]{4,2,1,0};\n\t\tiMap = new boolean[]{true, false, true, false};\n\t\tsp = SemanticPropUtil.createProjectionPropertiesDual(pMap, iMap, fiveIntTupleType, pojoInTupleType);\n\t\tassertTrue(sp.getForwardingTargetFields(0, 4).contains(0));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 2).contains(1));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 3).contains(2));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 4).contains(3));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 5).contains(4));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 1).contains(5));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 0).contains(6));\n\n\t\tpMap = new int[]{2,3,-1,0};\n\t\tiMap = new boolean[]{true, true, false, true};\n\t\tsp = SemanticPropUtil.createProjectionPropertiesDual(pMap, iMap, fiveIntTupleType, intType);\n\t\tassertTrue(sp.getForwardingTargetFields(0, 2).contains(0));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 3).contains(1));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 0).contains(2));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 0).contains(3));\n\n\t\tpMap = new int[]{-1,-1};\n\t\tiMap = new boolean[]{false, true};\n\t\tsp = SemanticPropUtil.createProjectionPropertiesDual(pMap, iMap, intType, nestedPojoType);\n\t\tassertTrue(sp.getForwardingTargetFields(1, 0).contains(0));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 1).contains(1));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 2).contains(2));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 3).contains(3));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 4).contains(4));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 5).contains(5));\n\t\tassertTrue(sp.getForwardingTargetFields(0, 0).contains(6));\n\n\t\tpMap = new int[]{-1,-1};\n\t\tiMap = new boolean[]{true, false};\n\t\tsp = SemanticPropUtil.createProjectionPropertiesDual(pMap, iMap, intType, nestedPojoType);\n\t\tassertTrue(sp.getForwardingTargetFields(0, 0).contains(0));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 0).contains(1));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 1).contains(2));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 2).contains(3));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 3).contains(4));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 4).contains(5));\n\t\tassertTrue(sp.getForwardingTargetFields(1, 5).contains(6));\n\n\t}", "signature": "void testDualProjectionProperties()", "full_signature": "@Test public void testDualProjectionProperties()", "class_method_signature": "SemanticPropUtilTest.testDualProjectionProperties()", "testcase": true, "constructor": false, "invocations": ["createProjectionPropertiesDual", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "createProjectionPropertiesDual", "assertTrue", "size", "getForwardingTargetFields", "assertTrue", "size", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "createProjectionPropertiesDual", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "createProjectionPropertiesDual", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "createProjectionPropertiesDual", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "createProjectionPropertiesDual", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "createProjectionPropertiesDual", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "createProjectionPropertiesDual", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields", "assertTrue", "contains", "getForwardingTargetFields"]}, "focal_class": {"identifier": "SemanticPropUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final static String REGEX_WILDCARD = \"[\\\\\"+ Keys.ExpressionKeys.SELECT_ALL_CHAR+\"\\\\\"+ Keys.ExpressionKeys.SELECT_ALL_CHAR_SCALA+\"]\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_WILDCARD = \"[\\\\\"+ Keys.ExpressionKeys.SELECT_ALL_CHAR+\"\\\\\"+ Keys.ExpressionKeys.SELECT_ALL_CHAR_SCALA+\"]\"", "var_name": "REGEX_WILDCARD"}, {"original_string": "private final static String REGEX_SINGLE_FIELD = \"[\\\\p{L}\\\\p{Digit}_\\\\$]+\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_SINGLE_FIELD = \"[\\\\p{L}\\\\p{Digit}_\\\\$]+\"", "var_name": "REGEX_SINGLE_FIELD"}, {"original_string": "private final static String REGEX_NESTED_FIELDS = \"((\" + REGEX_SINGLE_FIELD + \"\\\\.)*\" + REGEX_SINGLE_FIELD + \")(\\\\.\"+ REGEX_WILDCARD +\")?\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_NESTED_FIELDS = \"((\" + REGEX_SINGLE_FIELD + \"\\\\.)*\" + REGEX_SINGLE_FIELD + \")(\\\\.\"+ REGEX_WILDCARD +\")?\"", "var_name": "REGEX_NESTED_FIELDS"}, {"original_string": "private final static String REGEX_LIST = \"((\" + REGEX_NESTED_FIELDS + \";)*(\" + REGEX_NESTED_FIELDS + \");?)\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_LIST = \"((\" + REGEX_NESTED_FIELDS + \";)*(\" + REGEX_NESTED_FIELDS + \");?)\"", "var_name": "REGEX_LIST"}, {"original_string": "private final static String REGEX_FORWARD = \"((\"+ REGEX_NESTED_FIELDS +\"|\"+ REGEX_WILDCARD +\")->(\" + REGEX_NESTED_FIELDS + \"|\"+ REGEX_WILDCARD +\"))\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_FORWARD = \"((\"+ REGEX_NESTED_FIELDS +\"|\"+ REGEX_WILDCARD +\")->(\" + REGEX_NESTED_FIELDS + \"|\"+ REGEX_WILDCARD +\"))\"", "var_name": "REGEX_FORWARD"}, {"original_string": "private final static String REGEX_FIELD_OR_FORWARD = \"(\" + REGEX_NESTED_FIELDS + \"|\" + REGEX_FORWARD + \")\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_FIELD_OR_FORWARD = \"(\" + REGEX_NESTED_FIELDS + \"|\" + REGEX_FORWARD + \")\"", "var_name": "REGEX_FIELD_OR_FORWARD"}, {"original_string": "private final static String REGEX_ANNOTATION = \"((\" + REGEX_FIELD_OR_FORWARD + \";)*(\" + REGEX_FIELD_OR_FORWARD + \");?)\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_ANNOTATION = \"((\" + REGEX_FIELD_OR_FORWARD + \";)*(\" + REGEX_FIELD_OR_FORWARD + \");?)\"", "var_name": "REGEX_ANNOTATION"}, {"original_string": "private static final Pattern PATTERN_WILDCARD = Pattern.compile(REGEX_WILDCARD);", "modifier": "private static final", "type": "Pattern", "declarator": "PATTERN_WILDCARD = Pattern.compile(REGEX_WILDCARD)", "var_name": "PATTERN_WILDCARD"}, {"original_string": "private static final Pattern PATTERN_FORWARD = Pattern.compile(REGEX_FORWARD);", "modifier": "private static final", "type": "Pattern", "declarator": "PATTERN_FORWARD = Pattern.compile(REGEX_FORWARD)", "var_name": "PATTERN_FORWARD"}, {"original_string": "private static final Pattern PATTERN_ANNOTATION = Pattern.compile(REGEX_ANNOTATION);", "modifier": "private static final", "type": "Pattern", "declarator": "PATTERN_ANNOTATION = Pattern.compile(REGEX_ANNOTATION)", "var_name": "PATTERN_ANNOTATION"}, {"original_string": "private static final Pattern PATTERN_LIST = Pattern.compile(REGEX_LIST);", "modifier": "private static final", "type": "Pattern", "declarator": "PATTERN_LIST = Pattern.compile(REGEX_LIST)", "var_name": "PATTERN_LIST"}, {"original_string": "private static final Pattern PATTERN_FIELD = Pattern.compile(REGEX_NESTED_FIELDS);", "modifier": "private static final", "type": "Pattern", "declarator": "PATTERN_FIELD = Pattern.compile(REGEX_NESTED_FIELDS)", "var_name": "PATTERN_FIELD"}], "methods": [{"identifier": "createProjectionPropertiesSingle", "parameters": "(int[] fields, CompositeType<?> inType)", "modifiers": "public static", "return": "SingleInputSemanticProperties", "signature": "SingleInputSemanticProperties createProjectionPropertiesSingle(int[] fields, CompositeType<?> inType)", "full_signature": "public static SingleInputSemanticProperties createProjectionPropertiesSingle(int[] fields, CompositeType<?> inType)", "class_method_signature": "SemanticPropUtil.createProjectionPropertiesSingle(int[] fields, CompositeType<?> inType)", "testcase": false, "constructor": false}, {"identifier": "createProjectionPropertiesDual", "parameters": "(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "modifiers": "public static", "return": "DualInputSemanticProperties", "signature": "DualInputSemanticProperties createProjectionPropertiesDual(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "full_signature": "public static DualInputSemanticProperties createProjectionPropertiesDual(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "class_method_signature": "SemanticPropUtil.createProjectionPropertiesDual(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "testcase": false, "constructor": false}, {"identifier": "addSourceFieldOffset", "parameters": "(SingleInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields, int offset)", "modifiers": "public static", "return": "SingleInputSemanticProperties", "signature": "SingleInputSemanticProperties addSourceFieldOffset(SingleInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields, int offset)", "full_signature": "public static SingleInputSemanticProperties addSourceFieldOffset(SingleInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields, int offset)", "class_method_signature": "SemanticPropUtil.addSourceFieldOffset(SingleInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields, int offset)", "testcase": false, "constructor": false}, {"identifier": "addSourceFieldOffsets", "parameters": "(DualInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields1, int numInputFields2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint offset1, int offset2)", "modifiers": "public static", "return": "DualInputSemanticProperties", "signature": "DualInputSemanticProperties addSourceFieldOffsets(DualInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields1, int numInputFields2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint offset1, int offset2)", "full_signature": "public static DualInputSemanticProperties addSourceFieldOffsets(DualInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields1, int numInputFields2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint offset1, int offset2)", "class_method_signature": "SemanticPropUtil.addSourceFieldOffsets(DualInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields1, int numInputFields2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint offset1, int offset2)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsSingle", "parameters": "(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType, TypeInformation<?> outType)", "modifiers": "public static", "return": "SingleInputSemanticProperties", "signature": "SingleInputSemanticProperties getSemanticPropsSingle(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType, TypeInformation<?> outType)", "full_signature": "public static SingleInputSemanticProperties getSemanticPropsSingle(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType, TypeInformation<?> outType)", "class_method_signature": "SemanticPropUtil.getSemanticPropsSingle(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType, TypeInformation<?> outType)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsDual", "parameters": "(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "modifiers": "public static", "return": "DualInputSemanticProperties", "signature": "DualInputSemanticProperties getSemanticPropsDual(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "full_signature": "public static DualInputSemanticProperties getSemanticPropsDual(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "class_method_signature": "SemanticPropUtil.getSemanticPropsDual(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsSingleFromString", "parameters": "(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "modifiers": "public static", "return": "void", "signature": "void getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "full_signature": "public static void getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "class_method_signature": "SemanticPropUtil.getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsSingleFromString", "parameters": "(SingleInputSemanticProperties result,\n\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "modifiers": "public static", "return": "void", "signature": "void getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "full_signature": "public static void getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "class_method_signature": "SemanticPropUtil.getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsDualFromString", "parameters": "(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "modifiers": "public static", "return": "void", "signature": "void getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "full_signature": "public static void getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "class_method_signature": "SemanticPropUtil.getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsDualFromString", "parameters": "(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "modifiers": "public static", "return": "void", "signature": "void getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "full_signature": "public static void getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "class_method_signature": "SemanticPropUtil.getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "testcase": false, "constructor": false}, {"identifier": "parseForwardedFields", "parameters": "(SemanticProperties sp, String[] forwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "modifiers": "private static", "return": "void", "signature": "void parseForwardedFields(SemanticProperties sp, String[] forwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "full_signature": "private static void parseForwardedFields(SemanticProperties sp, String[] forwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "class_method_signature": "SemanticPropUtil.parseForwardedFields(SemanticProperties sp, String[] forwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "testcase": false, "constructor": false}, {"identifier": "parseNonForwardedFields", "parameters": "(SemanticProperties sp, String[] nonForwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "modifiers": "private static", "return": "void", "signature": "void parseNonForwardedFields(SemanticProperties sp, String[] nonForwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "full_signature": "private static void parseNonForwardedFields(SemanticProperties sp, String[] nonForwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "class_method_signature": "SemanticPropUtil.parseNonForwardedFields(SemanticProperties sp, String[] nonForwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "testcase": false, "constructor": false}, {"identifier": "parseReadFields", "parameters": "(SemanticProperties sp, String[] readFieldStrings, TypeInformation<?> inType, int input)", "modifiers": "private static", "return": "void", "signature": "void parseReadFields(SemanticProperties sp, String[] readFieldStrings, TypeInformation<?> inType, int input)", "full_signature": "private static void parseReadFields(SemanticProperties sp, String[] readFieldStrings, TypeInformation<?> inType, int input)", "class_method_signature": "SemanticPropUtil.parseReadFields(SemanticProperties sp, String[] readFieldStrings, TypeInformation<?> inType, int input)", "testcase": false, "constructor": false}, {"identifier": "areFieldsCompatible", "parameters": "(String sourceField, TypeInformation<?> inType, String targetField,\n\t\t\tTypeInformation<?> outType, boolean throwException)", "modifiers": "private static", "return": "boolean", "signature": "boolean areFieldsCompatible(String sourceField, TypeInformation<?> inType, String targetField,\n\t\t\tTypeInformation<?> outType, boolean throwException)", "full_signature": "private static boolean areFieldsCompatible(String sourceField, TypeInformation<?> inType, String targetField,\n\t\t\tTypeInformation<?> outType, boolean throwException)", "class_method_signature": "SemanticPropUtil.areFieldsCompatible(String sourceField, TypeInformation<?> inType, String targetField,\n\t\t\tTypeInformation<?> outType, boolean throwException)", "testcase": false, "constructor": false}, {"identifier": "getExpressionTypeInformation", "parameters": "(String fieldStr, TypeInformation<?> typeInfo)", "modifiers": "private static", "return": "TypeInformation<?>", "signature": "TypeInformation<?> getExpressionTypeInformation(String fieldStr, TypeInformation<?> typeInfo)", "full_signature": "private static TypeInformation<?> getExpressionTypeInformation(String fieldStr, TypeInformation<?> typeInfo)", "class_method_signature": "SemanticPropUtil.getExpressionTypeInformation(String fieldStr, TypeInformation<?> typeInfo)", "testcase": false, "constructor": false}, {"identifier": "getFlatFields", "parameters": "(String fieldStr, TypeInformation<?> typeInfo)", "modifiers": "private static", "return": "List<FlatFieldDescriptor>", "signature": "List<FlatFieldDescriptor> getFlatFields(String fieldStr, TypeInformation<?> typeInfo)", "full_signature": "private static List<FlatFieldDescriptor> getFlatFields(String fieldStr, TypeInformation<?> typeInfo)", "class_method_signature": "SemanticPropUtil.getFlatFields(String fieldStr, TypeInformation<?> typeInfo)", "testcase": false, "constructor": false}, {"identifier": "SemanticPropUtil", "parameters": "()", "modifiers": "private", "return": "", "signature": " SemanticPropUtil()", "full_signature": "private  SemanticPropUtil()", "class_method_signature": "SemanticPropUtil.SemanticPropUtil()", "testcase": false, "constructor": true}], "file": "flink-java/src/main/java/org/apache/flink/api/java/functions/SemanticPropUtil.java"}, "focal_method": {"identifier": "createProjectionPropertiesDual", "parameters": "(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "modifiers": "public static", "return": "DualInputSemanticProperties", "body": "public static DualInputSemanticProperties createProjectionPropertiesDual(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)\n\t{\n\t\tDualInputSemanticProperties dsp = new DualInputSemanticProperties();\n\n\t\tint[] sourceOffsets1;\n\t\tif(inType1 instanceof TupleTypeInfo<?>) {\n\t\t\tsourceOffsets1 = new int[inType1.getArity()];\n\t\t\tsourceOffsets1[0] = 0;\n\t\t\tfor(int i=1; i<inType1.getArity(); i++) {\n\t\t\t\tsourceOffsets1[i] = ((TupleTypeInfo<?>)inType1).getTypeAt(i-1).getTotalFields() + sourceOffsets1[i-1];\n\t\t\t}\n\t\t} else {\n\t\t\tsourceOffsets1 = new int[] {0};\n\t\t}\n\n\t\tint[] sourceOffsets2;\n\t\tif(inType2 instanceof TupleTypeInfo<?>) {\n\t\t\tsourceOffsets2 = new int[inType2.getArity()];\n\t\t\tsourceOffsets2[0] = 0;\n\t\t\tfor(int i=1; i<inType2.getArity(); i++) {\n\t\t\t\tsourceOffsets2[i] = ((TupleTypeInfo<?>)inType2).getTypeAt(i-1).getTotalFields() + sourceOffsets2[i-1];\n\t\t\t}\n\t\t} else {\n\t\t\tsourceOffsets2 = new int[] {0};\n\t\t}\n\n\t\tint targetOffset = 0;\n\t\tfor(int i=0; i<fields.length; i++) {\n\t\t\tint sourceOffset;\n\t\t\tint numFieldsToCopy;\n\t\t\tint input;\n\t\t\tif(isFromFirst[i]) {\n\t\t\t\tinput = 0;\n\t\t\t\tif (fields[i] == -1) {\n\t\t\t\t\tsourceOffset = 0;\n\t\t\t\t\tnumFieldsToCopy = inType1.getTotalFields();\n\t\t\t\t} else {\n\t\t\t\t\tsourceOffset = sourceOffsets1[fields[i]];\n\t\t\t\t\tnumFieldsToCopy = ((TupleTypeInfo<?>)inType1).getTypeAt(fields[i]).getTotalFields();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tinput = 1;\n\t\t\t\tif (fields[i] == -1) {\n\t\t\t\t\tsourceOffset = 0;\n\t\t\t\t\tnumFieldsToCopy = inType2.getTotalFields();\n\t\t\t\t} else {\n\t\t\t\t\tsourceOffset = sourceOffsets2[fields[i]];\n\t\t\t\t\tnumFieldsToCopy = ((TupleTypeInfo<?>)inType2).getTypeAt(fields[i]).getTotalFields();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int j=0; j<numFieldsToCopy; j++) {\n\t\t\t\tdsp.addForwardedField(input, sourceOffset+j, targetOffset+j);\n\t\t\t}\n\t\t\ttargetOffset += numFieldsToCopy;\n\t\t}\n\n\t\treturn dsp;\n\t}", "signature": "DualInputSemanticProperties createProjectionPropertiesDual(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "full_signature": "public static DualInputSemanticProperties createProjectionPropertiesDual(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "class_method_signature": "SemanticPropUtil.createProjectionPropertiesDual(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "testcase": false, "constructor": false, "invocations": ["getArity", "getArity", "getTotalFields", "getTypeAt", "getArity", "getArity", "getTotalFields", "getTypeAt", "getTotalFields", "getTotalFields", "getTypeAt", "getTotalFields", "getTotalFields", "getTypeAt", "addForwardedField"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}