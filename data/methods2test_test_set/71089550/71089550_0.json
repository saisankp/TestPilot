{"test_class": {"identifier": "TheorySolverTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final long SEED = 1000L;", "modifier": "private static final", "type": "long", "declarator": "SEED = 1000L", "var_name": "SEED"}], "file": "sjsc/src/test/java/com/samsung/sjs/theorysolver/TheorySolverTest.java"}, "test_case": {"identifier": "testBasics", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testBasics() {\n\n        List<Object> all = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\");\n\n        for (int i = 0; i < 100; ++i) {\n            Random r = new Random(SEED + i);\n\n            Collection<Object> truthy = all.stream()\n                    .filter(x -> r.nextBoolean())\n                    .collect(Collectors.toSet());\n\n            Theory<Object, Void> theory = positive -> {\n                Collection<Object> bad = positive.stream()\n                        .filter(x -> !truthy.contains(x))\n                        .collect(Collectors.toSet());\n                if (bad.size() > 0) {\n                    // Construct a random, nonempty unsat core.\n                    Collection<Object> unsat = new HashSet<>();\n                    unsat.add(bad.iterator().next());\n                    bad.stream().filter(x -> r.nextBoolean()).forEach(unsat::add);\n                    return Either.right(unsat);\n                } else {\n                    return Either.left(null);\n                }\n            };\n\n            Pair<Void, Collection<Object>> result = TheorySolver.solve(\n                theory, new SatFixingSetFinder<>(new Sat4J()),\n                Collections.emptyList(), all);\n\n            Assert.assertEquals(all.size() - truthy.size(), result.getRight().size());\n            Assert.assertEquals(truthy, all.stream().filter(x -> !result.getRight().contains(x)).collect(Collectors.toSet()));\n        }\n\n    }", "signature": "void testBasics()", "full_signature": "@Test public void testBasics()", "class_method_signature": "TheorySolverTest.testBasics()", "testcase": true, "constructor": false, "invocations": ["asList", "collect", "filter", "stream", "nextBoolean", "toSet", "collect", "filter", "stream", "contains", "toSet", "size", "add", "next", "iterator", "forEach", "filter", "stream", "nextBoolean", "right", "left", "solve", "emptyList", "assertEquals", "size", "size", "size", "getRight", "assertEquals", "collect", "filter", "stream", "contains", "getRight", "toSet"]}, "focal_class": {"identifier": "TheorySolver", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final boolean SHUFFLE = false;", "modifier": "private static final", "type": "boolean", "declarator": "SHUFFLE = false", "var_name": "SHUFFLE"}, {"original_string": "private static final boolean NOISY = true;", "modifier": "private static final", "type": "boolean", "declarator": "NOISY = true", "var_name": "NOISY"}], "methods": [{"identifier": "timed", "parameters": "(Supplier<T> f, String msg)", "modifiers": "private static", "return": "T", "signature": "T timed(Supplier<T> f, String msg)", "full_signature": "private static T timed(Supplier<T> f, String msg)", "class_method_signature": "TheorySolver.timed(Supplier<T> f, String msg)", "testcase": false, "constructor": false}, {"identifier": "extendClause", "parameters": "(int[] clause, int i)", "modifiers": "static", "return": "int[]", "signature": "int[] extendClause(int[] clause, int i)", "full_signature": "static int[] extendClause(int[] clause, int i)", "class_method_signature": "TheorySolver.extendClause(int[] clause, int i)", "testcase": false, "constructor": false}, {"identifier": "enumerateFixingSets", "parameters": "(\n            FixingSetFinder<Constraint> fixingSetFinder,\n            Theory<Constraint, Model> theorySolver,\n            Collection<Constraint> hardConstraints,\n            Collection<Constraint> softConstraints,\n            FixingSetListener<Constraint, Model> listener)", "modifiers": "public static", "return": "void", "signature": "void enumerateFixingSets(\n            FixingSetFinder<Constraint> fixingSetFinder,\n            Theory<Constraint, Model> theorySolver,\n            Collection<Constraint> hardConstraints,\n            Collection<Constraint> softConstraints,\n            FixingSetListener<Constraint, Model> listener)", "full_signature": "public static void enumerateFixingSets(\n            FixingSetFinder<Constraint> fixingSetFinder,\n            Theory<Constraint, Model> theorySolver,\n            Collection<Constraint> hardConstraints,\n            Collection<Constraint> softConstraints,\n            FixingSetListener<Constraint, Model> listener)", "class_method_signature": "TheorySolver.enumerateFixingSets(\n            FixingSetFinder<Constraint> fixingSetFinder,\n            Theory<Constraint, Model> theorySolver,\n            Collection<Constraint> hardConstraints,\n            Collection<Constraint> softConstraints,\n            FixingSetListener<Constraint, Model> listener)", "testcase": false, "constructor": false}, {"identifier": "solve", "parameters": "(\n            Theory<Constraint, Model> theorySolver,\n            FixingSetFinder<Constraint> fixingSetFinder,\n            List<Constraint> hardConstraints,\n            List<Constraint> softConstraints)", "modifiers": "public static", "return": "Pair<Model, Collection<Constraint>>", "signature": "Pair<Model, Collection<Constraint>> solve(\n            Theory<Constraint, Model> theorySolver,\n            FixingSetFinder<Constraint> fixingSetFinder,\n            List<Constraint> hardConstraints,\n            List<Constraint> softConstraints)", "full_signature": "public static Pair<Model, Collection<Constraint>> solve(\n            Theory<Constraint, Model> theorySolver,\n            FixingSetFinder<Constraint> fixingSetFinder,\n            List<Constraint> hardConstraints,\n            List<Constraint> softConstraints)", "class_method_signature": "TheorySolver.solve(\n            Theory<Constraint, Model> theorySolver,\n            FixingSetFinder<Constraint> fixingSetFinder,\n            List<Constraint> hardConstraints,\n            List<Constraint> softConstraints)", "testcase": false, "constructor": false}, {"identifier": "without", "parameters": "(Collection<T> collection, T element)", "modifiers": "private static", "return": "Collection<T>", "signature": "Collection<T> without(Collection<T> collection, T element)", "full_signature": "private static Collection<T> without(Collection<T> collection, T element)", "class_method_signature": "TheorySolver.without(Collection<T> collection, T element)", "testcase": false, "constructor": false}, {"identifier": "minimizeFixingSet", "parameters": "(\n        Theory<Constraint, Model> theorySolver,\n        List<Constraint> hardConstraints,\n        List<Constraint> softConstraints,\n        Model model,\n        Collection<Constraint> fixingSet)", "modifiers": "public static", "return": "Pair<Model, Collection<Constraint>>", "signature": "Pair<Model, Collection<Constraint>> minimizeFixingSet(\n        Theory<Constraint, Model> theorySolver,\n        List<Constraint> hardConstraints,\n        List<Constraint> softConstraints,\n        Model model,\n        Collection<Constraint> fixingSet)", "full_signature": "public static Pair<Model, Collection<Constraint>> minimizeFixingSet(\n        Theory<Constraint, Model> theorySolver,\n        List<Constraint> hardConstraints,\n        List<Constraint> softConstraints,\n        Model model,\n        Collection<Constraint> fixingSet)", "class_method_signature": "TheorySolver.minimizeFixingSet(\n        Theory<Constraint, Model> theorySolver,\n        List<Constraint> hardConstraints,\n        List<Constraint> softConstraints,\n        Model model,\n        Collection<Constraint> fixingSet)", "testcase": false, "constructor": false}, {"identifier": "loggingListener", "parameters": "()", "modifiers": "private static", "return": "FixingSetListener<Constraint, Model>", "signature": "FixingSetListener<Constraint, Model> loggingListener()", "full_signature": "private static FixingSetListener<Constraint, Model> loggingListener()", "class_method_signature": "TheorySolver.loggingListener()", "testcase": false, "constructor": false}], "file": "sjsc/src/main/java/com/samsung/sjs/theorysolver/TheorySolver.java"}, "focal_method": {"identifier": "solve", "parameters": "(\n            Theory<Constraint, Model> theorySolver,\n            FixingSetFinder<Constraint> fixingSetFinder,\n            List<Constraint> hardConstraints,\n            List<Constraint> softConstraints)", "modifiers": "public static", "return": "Pair<Model, Collection<Constraint>>", "body": "public static <Constraint, Model> Pair<Model, Collection<Constraint>> solve(\n            Theory<Constraint, Model> theorySolver,\n            FixingSetFinder<Constraint> fixingSetFinder,\n            List<Constraint> hardConstraints,\n            List<Constraint> softConstraints) {\n\n        FixingSetListener<Constraint, Model> listener = NOISY ?\n            loggingListener() :\n            FixingSetListener.dummyListener();\n\n        fixingSetFinder.setup(softConstraints);\n\n        // These two are complements of each other:\n        //    - fixingSet is the constraints we are going to remove\n        //    - positive  is the constraints we are going to keep\n        //      (i.e. all those not in the fixing set)\n        Collection<Constraint> fixingSet = new ArrayList<>();\n        Collection<Constraint> positive = new LinkedHashSet<>();\n        for (;;) {\n\n            // Be polite---interruptions mean that someone else wants\n            // this thread to stop what it's doing.\n            if (Thread.currentThread().isInterrupted()) {\n                throw new RuntimeException(\"thread was interrupted\");\n            }\n\n            positive.addAll(hardConstraints);\n            positive.addAll(softConstraints);\n            positive.removeAll(fixingSet);\n\n            // Check the proposed fixing set against the theory.\n            Either<Model, Collection<Constraint>> result =\n                timed(() -> theorySolver.check(positive), \"CHECKING THEORY\");\n\n            if (result.right == null) {\n                // The proposed fixing set works! We are done!\n                if (NOISY) System.out.println(\"VALID MODEL\");\n                listener.onFixingSet(result.left, fixingSet);\n                return Pair.of(result.left, fixingSet);\n            } else {\n                // The proposed fixing set didn't work. We will use the core\n                // to adjust what fixing set gets returned next.\n\n                // Inform the listener\n                listener.onCore(result.right);\n\n                // The fixing set finder shouldn't care about hard constraints\n                Collection<Constraint> softCore = result.right.stream()\n                    .filter(c -> !hardConstraints.contains(c))\n                    .collect(Collectors.toList());\n\n                if (softCore.isEmpty()) {\n                    throw new IllegalStateException(\"Hard clauses are unsat!\");\n                }\n\n                // Push the core to the fixing set finder\n                fixingSet.clear();\n                fixingSetFinder.addCore(softCore);\n                timed(() -> fixingSetFinder.currentFixingSet(fixingSet, listener),\n                    \"FINDING FIXING SET\");\n                System.out.println(\"  --> PROPOSAL SIZE = \" + fixingSet.size());\n            }\n\n        }\n\n    }", "signature": "Pair<Model, Collection<Constraint>> solve(\n            Theory<Constraint, Model> theorySolver,\n            FixingSetFinder<Constraint> fixingSetFinder,\n            List<Constraint> hardConstraints,\n            List<Constraint> softConstraints)", "full_signature": "public static Pair<Model, Collection<Constraint>> solve(\n            Theory<Constraint, Model> theorySolver,\n            FixingSetFinder<Constraint> fixingSetFinder,\n            List<Constraint> hardConstraints,\n            List<Constraint> softConstraints)", "class_method_signature": "TheorySolver.solve(\n            Theory<Constraint, Model> theorySolver,\n            FixingSetFinder<Constraint> fixingSetFinder,\n            List<Constraint> hardConstraints,\n            List<Constraint> softConstraints)", "testcase": false, "constructor": false, "invocations": ["loggingListener", "dummyListener", "setup", "isInterrupted", "currentThread", "addAll", "addAll", "removeAll", "timed", "check", "println", "onFixingSet", "of", "onCore", "collect", "filter", "stream", "contains", "toList", "isEmpty", "clear", "addCore", "timed", "currentFixingSet", "println", "size"]}, "repository": {"repo_id": 71089550, "url": "https://github.com/Samsung/SJS", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 26, "size": 5742, "license": "licensed"}}