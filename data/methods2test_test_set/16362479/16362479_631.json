{"test_class": {"identifier": "CDSShardAccessImplTest", "superclass": "extends AbstractActorTest", "interfaces": "", "fields": [{"original_string": "private static final DOMDataTreeIdentifier TEST_ID =\n            new DOMDataTreeIdentifier(LogicalDatastoreType.CONFIGURATION, TestModel.TEST_PATH);", "modifier": "private static final", "type": "DOMDataTreeIdentifier", "declarator": "TEST_ID =\n            new DOMDataTreeIdentifier(LogicalDatastoreType.CONFIGURATION, TestModel.TEST_PATH)", "var_name": "TEST_ID"}, {"original_string": "private CDSShardAccessImpl shardAccess;", "modifier": "private", "type": "CDSShardAccessImpl", "declarator": "shardAccess", "var_name": "shardAccess"}, {"original_string": "private ActorUtils context;", "modifier": "private", "type": "ActorUtils", "declarator": "context", "var_name": "context"}], "file": "opendaylight/md-sal/sal-distributed-datastore/src/test/java/org/opendaylight/controller/cluster/sharding/CDSShardAccessImplTest.java"}, "test_case": {"identifier": "testMakeLeaderLocal", "parameters": "()", "modifiers": "@Test @SuppressWarnings(\"checkstyle:IllegalCatch\") public", "return": "void", "body": "@Test\n    @SuppressWarnings(\"checkstyle:IllegalCatch\")\n    public void testMakeLeaderLocal() throws Exception {\n        final FiniteDuration timeout = new FiniteDuration(5, TimeUnit.SECONDS);\n        final ActorRef localShardRef = mock(ActorRef.class);\n        final Future<ActorRef> localShardRefFuture = Futures.successful(localShardRef);\n        doReturn(localShardRefFuture).when(context).findLocalShardAsync(any());\n\n        // MakeLeaderLocal will reply with success\n        doReturn(Futures.successful(null)).when(context).executeOperationAsync((ActorRef) any(), any(), any());\n        doReturn(getSystem().dispatcher()).when(context).getClientDispatcher();\n        assertEquals(waitOnAsyncTask(shardAccess.makeLeaderLocal(), timeout), null);\n\n        // MakeLeaderLocal will reply with failure\n        doReturn(Futures.failed(new LeadershipTransferFailedException(\"Failure\")))\n                .when(context).executeOperationAsync((ActorRef) any(), any(), any());\n\n        try {\n            waitOnAsyncTask(shardAccess.makeLeaderLocal(), timeout);\n            fail(\"makeLeaderLocal operation should not be successful\");\n        } catch (final Exception e) {\n            assertTrue(e instanceof LeadershipTransferFailedException);\n        }\n\n        // we don't even find local shard\n        doReturn(Futures.failed(new LocalShardNotFoundException(\"Local shard not found\")))\n                .when(context).findLocalShardAsync(any());\n\n        try {\n            waitOnAsyncTask(shardAccess.makeLeaderLocal(), timeout);\n            fail(\"makeLeaderLocal operation should not be successful\");\n        } catch (final Exception e) {\n            assertTrue(e instanceof LeadershipTransferFailedException);\n            assertTrue(e.getCause() instanceof LocalShardNotFoundException);\n        }\n\n        // closed shard access should throw IllegalStateEx\n        shardAccess.close();\n        try {\n            shardAccess.makeLeaderLocal();\n            fail(\"Should have thrown IllegalStateEx. ShardAccess is closed\");\n        } catch (final Exception e) {\n            assertTrue(e instanceof IllegalStateException);\n        }\n    }", "signature": "void testMakeLeaderLocal()", "full_signature": "@Test @SuppressWarnings(\"checkstyle:IllegalCatch\") public void testMakeLeaderLocal()", "class_method_signature": "CDSShardAccessImplTest.testMakeLeaderLocal()", "testcase": true, "constructor": false, "invocations": ["mock", "successful", "findLocalShardAsync", "when", "doReturn", "any", "executeOperationAsync", "when", "doReturn", "successful", "any", "any", "any", "getClientDispatcher", "when", "doReturn", "dispatcher", "getSystem", "assertEquals", "waitOnAsyncTask", "makeLeaderLocal", "executeOperationAsync", "when", "doReturn", "failed", "any", "any", "any", "waitOnAsyncTask", "makeLeaderLocal", "fail", "assertTrue", "findLocalShardAsync", "when", "doReturn", "failed", "any", "waitOnAsyncTask", "makeLeaderLocal", "fail", "assertTrue", "assertTrue", "getCause", "close", "makeLeaderLocal", "fail", "assertTrue"]}, "focal_class": {"identifier": "CDSShardAccessImpl", "superclass": "", "interfaces": "implements CDSShardAccess, LeaderLocationListener, AutoCloseable", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(CDSShardAccessImpl.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(CDSShardAccessImpl.class)", "var_name": "LOG"}, {"original_string": "private final Collection<LeaderLocationListener> listeners = ConcurrentHashMap.newKeySet();", "modifier": "private final", "type": "Collection<LeaderLocationListener>", "declarator": "listeners = ConcurrentHashMap.newKeySet()", "var_name": "listeners"}, {"original_string": "private final DOMDataTreeIdentifier prefix;", "modifier": "private final", "type": "DOMDataTreeIdentifier", "declarator": "prefix", "var_name": "prefix"}, {"original_string": "private final ActorUtils actorUtils;", "modifier": "private final", "type": "ActorUtils", "declarator": "actorUtils", "var_name": "actorUtils"}, {"original_string": "private final Timeout makeLeaderLocalTimeout;", "modifier": "private final", "type": "Timeout", "declarator": "makeLeaderLocalTimeout", "var_name": "makeLeaderLocalTimeout"}, {"original_string": "private ActorRef roleChangeListenerActor;", "modifier": "private", "type": "ActorRef", "declarator": "roleChangeListenerActor", "var_name": "roleChangeListenerActor"}, {"original_string": "private volatile LeaderLocation currentLeader = LeaderLocation.UNKNOWN;", "modifier": "private volatile", "type": "LeaderLocation", "declarator": "currentLeader = LeaderLocation.UNKNOWN", "var_name": "currentLeader"}, {"original_string": "private volatile boolean closed = false;", "modifier": "private volatile", "type": "boolean", "declarator": "closed = false", "var_name": "closed"}], "methods": [{"identifier": "CDSShardAccessImpl", "parameters": "(final DOMDataTreeIdentifier prefix, final ActorUtils actorUtils)", "modifiers": "", "return": "", "signature": " CDSShardAccessImpl(final DOMDataTreeIdentifier prefix, final ActorUtils actorUtils)", "full_signature": "  CDSShardAccessImpl(final DOMDataTreeIdentifier prefix, final ActorUtils actorUtils)", "class_method_signature": "CDSShardAccessImpl.CDSShardAccessImpl(final DOMDataTreeIdentifier prefix, final ActorUtils actorUtils)", "testcase": false, "constructor": true}, {"identifier": "checkNotClosed", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void checkNotClosed()", "full_signature": "private void checkNotClosed()", "class_method_signature": "CDSShardAccessImpl.checkNotClosed()", "testcase": false, "constructor": false}, {"identifier": "getShardIdentifier", "parameters": "()", "modifiers": "@Override public", "return": "DOMDataTreeIdentifier", "signature": "DOMDataTreeIdentifier getShardIdentifier()", "full_signature": "@Override public DOMDataTreeIdentifier getShardIdentifier()", "class_method_signature": "CDSShardAccessImpl.getShardIdentifier()", "testcase": false, "constructor": false}, {"identifier": "getLeaderLocation", "parameters": "()", "modifiers": "@Override public", "return": "LeaderLocation", "signature": "LeaderLocation getLeaderLocation()", "full_signature": "@Override public LeaderLocation getLeaderLocation()", "class_method_signature": "CDSShardAccessImpl.getLeaderLocation()", "testcase": false, "constructor": false}, {"identifier": "makeLeaderLocal", "parameters": "()", "modifiers": "@Override public", "return": "CompletionStage<Void>", "signature": "CompletionStage<Void> makeLeaderLocal()", "full_signature": "@Override public CompletionStage<Void> makeLeaderLocal()", "class_method_signature": "CDSShardAccessImpl.makeLeaderLocal()", "testcase": false, "constructor": false}, {"identifier": "registerLeaderLocationListener", "parameters": "(final L listener)", "modifiers": "@Override public", "return": "LeaderLocationListenerRegistration<L>", "signature": "LeaderLocationListenerRegistration<L> registerLeaderLocationListener(final L listener)", "full_signature": "@Override public LeaderLocationListenerRegistration<L> registerLeaderLocationListener(final L listener)", "class_method_signature": "CDSShardAccessImpl.registerLeaderLocationListener(final L listener)", "testcase": false, "constructor": false}, {"identifier": "onLeaderLocationChanged", "parameters": "(final LeaderLocation location)", "modifiers": "@Override @SuppressWarnings(\"checkstyle:IllegalCatch\") public", "return": "void", "signature": "void onLeaderLocationChanged(final LeaderLocation location)", "full_signature": "@Override @SuppressWarnings(\"checkstyle:IllegalCatch\") public void onLeaderLocationChanged(final LeaderLocation location)", "class_method_signature": "CDSShardAccessImpl.onLeaderLocationChanged(final LeaderLocation location)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "CDSShardAccessImpl.close()", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-distributed-datastore/src/main/java/org/opendaylight/controller/cluster/sharding/CDSShardAccessImpl.java"}, "focal_method": {"identifier": "makeLeaderLocal", "parameters": "()", "modifiers": "@Override public", "return": "CompletionStage<Void>", "body": "@Override\n    public CompletionStage<Void> makeLeaderLocal() {\n        // TODO when we have running make leader local operation\n        // we should just return the same completion stage\n        checkNotClosed();\n\n        // TODO can we cache local shard actorRef?\n        final Future<ActorRef> localShardReply =\n                actorUtils.findLocalShardAsync(ClusterUtils.getCleanShardName(prefix.getRootIdentifier()));\n\n        // we have to tell local shard to make leader local\n        final scala.concurrent.Promise<Object> makeLeaderLocalAsk = Futures.promise();\n        localShardReply.onComplete(new OnComplete<ActorRef>() {\n            @Override\n            public void onComplete(final Throwable failure, final ActorRef actorRef) {\n                if (failure instanceof LocalShardNotFoundException) {\n                    LOG.debug(\"No local shard found for {} - Cannot request leadership transfer to local shard.\",\n                            getShardIdentifier(), failure);\n                    makeLeaderLocalAsk.failure(failure);\n                } else if (failure != null) {\n                    // TODO should this be WARN?\n                    LOG.debug(\"Failed to find local shard for {} - Cannot request leadership transfer to local shard.\",\n                            getShardIdentifier(), failure);\n                    makeLeaderLocalAsk.failure(failure);\n                } else {\n                    makeLeaderLocalAsk\n                            .completeWith(actorUtils\n                                    .executeOperationAsync(actorRef, MakeLeaderLocal.INSTANCE, makeLeaderLocalTimeout));\n                }\n            }\n        }, actorUtils.getClientDispatcher());\n\n        // we have to transform make leader local request result\n        Future<Void> makeLeaderLocalFuture = makeLeaderLocalAsk.future()\n                .transform(new Mapper<Object, Void>() {\n                    @Override\n                    public Void apply(final Object parameter) {\n                        return null;\n                    }\n                }, new Mapper<Throwable, Throwable>() {\n                    @Override\n                    public Throwable apply(final Throwable parameter) {\n                        if (parameter instanceof LeadershipTransferFailedException) {\n                            // do nothing with exception and just pass it as it is\n                            return parameter;\n                        }\n                        // wrap exception in LeadershipTransferFailedEx\n                        return new LeadershipTransferFailedException(\"Leadership transfer failed\", parameter);\n                    }\n                }, actorUtils.getClientDispatcher());\n\n        return FutureConverters.toJava(makeLeaderLocalFuture);\n    }", "signature": "CompletionStage<Void> makeLeaderLocal()", "full_signature": "@Override public CompletionStage<Void> makeLeaderLocal()", "class_method_signature": "CDSShardAccessImpl.makeLeaderLocal()", "testcase": false, "constructor": false, "invocations": ["checkNotClosed", "findLocalShardAsync", "getCleanShardName", "getRootIdentifier", "promise", "onComplete", "debug", "getShardIdentifier", "failure", "debug", "getShardIdentifier", "failure", "completeWith", "executeOperationAsync", "getClientDispatcher", "transform", "future", "getClientDispatcher", "toJava"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}