{"test_class": {"identifier": "SyncStatusTrackerTest", "superclass": "extends AbstractActorTest", "interfaces": "", "fields": [{"original_string": "protected final TestActorFactory actorFactory = new TestActorFactory(getSystem());", "modifier": "protected final", "type": "TestActorFactory", "declarator": "actorFactory = new TestActorFactory(getSystem())", "var_name": "actorFactory"}, {"original_string": "private final ActorRef listener = actorFactory.createActor(\n            MessageCollectorActor.props(), actorFactory.generateActorId(\"listener\"));", "modifier": "private final", "type": "ActorRef", "declarator": "listener = actorFactory.createActor(\n            MessageCollectorActor.props(), actorFactory.generateActorId(\"listener\"))", "var_name": "listener"}], "file": "opendaylight/md-sal/sal-akka-raft/src/test/java/org/opendaylight/controller/cluster/raft/behaviors/SyncStatusTrackerTest.java"}, "test_case": {"identifier": "testUpdate", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testUpdate() {\n        SyncStatusTracker tracker = new SyncStatusTracker(listener, \"commit-tracker\", 10);\n\n        // When leader-1 sends the first update message the listener should receive a syncStatus notification\n        // with status set to false\n        tracker.update(\"leader-1\", 100, 99);\n        FollowerInitialSyncUpStatus status =\n                MessageCollectorActor.getFirstMatching(listener, FollowerInitialSyncUpStatus.class);\n\n        assertEquals(false, status.isInitialSyncDone());\n        MessageCollectorActor.clearMessages(listener);\n\n        // At a minimum the follower should have the commit index that the new leader sent it in the first message\n        // Also the commit index must be below the syncThreshold. If both conditions are met a new sync status\n        // message with status = true should be expected\n        tracker.update(\"leader-1\", 105, 101);\n\n        status = MessageCollectorActor.getFirstMatching(listener, FollowerInitialSyncUpStatus.class);\n\n        assertEquals(true, status.isInitialSyncDone());\n        MessageCollectorActor.clearMessages(listener);\n\n        // If a subsequent message is received and if the difference between the followers commit index and\n        // the leaders commit index is below the syncThreshold then no status notification must be issues\n        tracker.update(\"leader-1\", 108, 101);\n\n        status = MessageCollectorActor.getFirstMatching(listener, FollowerInitialSyncUpStatus.class);\n\n        assertNull(\"No status message should be received\", status);\n\n        // If the follower falls behind the leader by more than the syncThreshold then the listener should\n        // receive a syncStatus notification with status = false\n        tracker.update(\"leader-1\", 150, 101);\n\n        status = MessageCollectorActor.getFirstMatching(listener, FollowerInitialSyncUpStatus.class);\n\n        assertNotNull(\"No sync status message was received\", status);\n\n        assertEquals(false, status.isInitialSyncDone());\n        MessageCollectorActor.clearMessages(listener);\n\n        // If the follower is not caught up yet it should not receive any further notification\n        tracker.update(\"leader-1\", 150, 125);\n\n        status = MessageCollectorActor.getFirstMatching(listener, FollowerInitialSyncUpStatus.class);\n\n        assertNull(\"No status message should be received\", status);\n\n        // Once the syncThreshold is met a new syncStatus notification should be issued\n        tracker.update(\"leader-1\", 160, 155);\n\n        status = MessageCollectorActor.getFirstMatching(listener, FollowerInitialSyncUpStatus.class);\n\n        assertEquals(true, status.isInitialSyncDone());\n        MessageCollectorActor.clearMessages(listener);\n\n        // When a new leader starts sending update messages a new syncStatus notification should be immediately\n        // triggered with status = false\n        tracker.update(\"leader-2\", 160, 155);\n\n        status = MessageCollectorActor.getFirstMatching(listener, FollowerInitialSyncUpStatus.class);\n\n        assertEquals(false, status.isInitialSyncDone());\n        MessageCollectorActor.clearMessages(listener);\n\n        // If an update is received from a new leader which is still below the minimum expected index then\n        // syncStatus should not be changed\n        tracker.update(\"leader-2\", 160, 159);\n\n        status = MessageCollectorActor.getFirstMatching(listener, FollowerInitialSyncUpStatus.class);\n\n        assertNull(\"No status message should be received\", status);\n\n    }", "signature": "void testUpdate()", "full_signature": "@Test public void testUpdate()", "class_method_signature": "SyncStatusTrackerTest.testUpdate()", "testcase": true, "constructor": false, "invocations": ["update", "getFirstMatching", "assertEquals", "isInitialSyncDone", "clearMessages", "update", "getFirstMatching", "assertEquals", "isInitialSyncDone", "clearMessages", "update", "getFirstMatching", "assertNull", "update", "getFirstMatching", "assertNotNull", "assertEquals", "isInitialSyncDone", "clearMessages", "update", "getFirstMatching", "assertNull", "update", "getFirstMatching", "assertEquals", "isInitialSyncDone", "clearMessages", "update", "getFirstMatching", "assertEquals", "isInitialSyncDone", "clearMessages", "update", "getFirstMatching", "assertNull"]}, "focal_class": {"identifier": "SyncStatusTracker", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(SyncStatusTracker.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(SyncStatusTracker.class)", "var_name": "LOG"}, {"original_string": "private static final boolean IN_SYNC = true;", "modifier": "private static final", "type": "boolean", "declarator": "IN_SYNC = true", "var_name": "IN_SYNC"}, {"original_string": "private static final boolean NOT_IN_SYNC = false;", "modifier": "private static final", "type": "boolean", "declarator": "NOT_IN_SYNC = false", "var_name": "NOT_IN_SYNC"}, {"original_string": "private final long syncThreshold;", "modifier": "private final", "type": "long", "declarator": "syncThreshold", "var_name": "syncThreshold"}, {"original_string": "private final ActorRef actor;", "modifier": "private final", "type": "ActorRef", "declarator": "actor", "var_name": "actor"}, {"original_string": "private final String id;", "modifier": "private final", "type": "String", "declarator": "id", "var_name": "id"}, {"original_string": "private LeaderInfo syncTarget;", "modifier": "private", "type": "LeaderInfo", "declarator": "syncTarget", "var_name": "syncTarget"}, {"original_string": "private boolean syncStatus;", "modifier": "private", "type": "boolean", "declarator": "syncStatus", "var_name": "syncStatus"}], "methods": [{"identifier": "SyncStatusTracker", "parameters": "(final ActorRef actor, final String id, final long syncThreshold)", "modifiers": "public", "return": "", "signature": " SyncStatusTracker(final ActorRef actor, final String id, final long syncThreshold)", "full_signature": "public  SyncStatusTracker(final ActorRef actor, final String id, final long syncThreshold)", "class_method_signature": "SyncStatusTracker.SyncStatusTracker(final ActorRef actor, final String id, final long syncThreshold)", "testcase": false, "constructor": true}, {"identifier": "update", "parameters": "(final String leaderId, final long leaderCommit, final long commitIndex)", "modifiers": "public", "return": "void", "signature": "void update(final String leaderId, final long leaderCommit, final long commitIndex)", "full_signature": "public void update(final String leaderId, final long leaderCommit, final long commitIndex)", "class_method_signature": "SyncStatusTracker.update(final String leaderId, final long leaderCommit, final long commitIndex)", "testcase": false, "constructor": false}, {"identifier": "changeSyncStatus", "parameters": "(final boolean newSyncStatus, final boolean forceStatusChange)", "modifiers": "private", "return": "void", "signature": "void changeSyncStatus(final boolean newSyncStatus, final boolean forceStatusChange)", "full_signature": "private void changeSyncStatus(final boolean newSyncStatus, final boolean forceStatusChange)", "class_method_signature": "SyncStatusTracker.changeSyncStatus(final boolean newSyncStatus, final boolean forceStatusChange)", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-akka-raft/src/main/java/org/opendaylight/controller/cluster/raft/behaviors/SyncStatusTracker.java"}, "focal_method": {"identifier": "update", "parameters": "(final String leaderId, final long leaderCommit, final long commitIndex)", "modifiers": "public", "return": "void", "body": "public void update(final String leaderId, final long leaderCommit, final long commitIndex) {\n        requireNonNull(leaderId, \"leaderId should not be null\");\n\n        if (syncTarget == null || !leaderId.equals(syncTarget.leaderId)) {\n            LOG.debug(\"{}: Last sync leader does not match current leader {}, need to catch up to {}\", id,\n                leaderId, leaderCommit);\n            changeSyncStatus(NOT_IN_SYNC, true);\n            syncTarget = new LeaderInfo(leaderId, leaderCommit);\n            return;\n        }\n\n        final long lag = leaderCommit - commitIndex;\n        if (lag > syncThreshold) {\n            LOG.debug(\"{}: Lagging {} entries behind leader {}\", id, lag, leaderId);\n            changeSyncStatus(NOT_IN_SYNC, false);\n        } else if (commitIndex >= syncTarget.minimumCommitIndex) {\n            LOG.debug(\"{}: Lagging {} entries behind leader {} and reached {} (of expected {})\", id, lag, leaderId,\n                commitIndex, syncTarget.minimumCommitIndex);\n            changeSyncStatus(IN_SYNC, false);\n        }\n    }", "signature": "void update(final String leaderId, final long leaderCommit, final long commitIndex)", "full_signature": "public void update(final String leaderId, final long leaderCommit, final long commitIndex)", "class_method_signature": "SyncStatusTracker.update(final String leaderId, final long leaderCommit, final long commitIndex)", "testcase": false, "constructor": false, "invocations": ["requireNonNull", "equals", "debug", "changeSyncStatus", "debug", "changeSyncStatus", "debug", "changeSyncStatus"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}