{"test_class": {"identifier": "ConsumerFetcherThreadTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory\n      .getLogger(ConsumerFetcherThreadTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory\n      .getLogger(ConsumerFetcherThreadTest.class)", "var_name": "LOGGER"}, {"original_string": "private KafkaServerStartable kafka;", "modifier": "private", "type": "KafkaServerStartable", "declarator": "kafka", "var_name": "kafka"}, {"original_string": "private final int clusterPort = 19092;", "modifier": "private final", "type": "int", "declarator": "clusterPort = 19092", "var_name": "clusterPort"}, {"original_string": "private final String bootstrapServer = \"localhost:\" + clusterPort;", "modifier": "private final", "type": "String", "declarator": "bootstrapServer = \"localhost:\" + clusterPort", "var_name": "bootstrapServer"}, {"original_string": "private final String clusterZk = ZkStarter.DEFAULT_ZK_STR + \"/\" + clusterPort;", "modifier": "private final", "type": "String", "declarator": "clusterZk = ZkStarter.DEFAULT_ZK_STR + \"/\" + clusterPort", "var_name": "clusterZk"}, {"original_string": "private final String testTopic1 = \"CompactConsumerFetcherThreadTest1\";", "modifier": "private final", "type": "String", "declarator": "testTopic1 = \"CompactConsumerFetcherThreadTest1\"", "var_name": "testTopic1"}, {"original_string": "private final String testTopic2 = \"CompactConsumerFetcherThreadTest2\";", "modifier": "private final", "type": "String", "declarator": "testTopic2 = \"CompactConsumerFetcherThreadTest2\"", "var_name": "testTopic2"}], "file": "uReplicator-Worker-3.0/src/test/java/com/uber/stream/ureplicator/worker/ConsumerFetcherThreadTest.java"}, "test_case": {"identifier": "testConsumerFetcherThread", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testConsumerFetcherThread() throws InterruptedException, IOException {\n    String threadName = \"testCompactConsumerFetcherThread\";\n    ConcurrentHashMap<TopicAndPartition, PartitionOffsetInfo> partitionInfoMap = new ConcurrentHashMap<>();\n    KafkaStarterUtils.createTopic(testTopic1, clusterZk);\n    KafkaStarterUtils.createTopic(testTopic2, clusterZk);\n\n    BlockingQueue<FetchedDataChunk> queue = new LinkedBlockingQueue<>(3);\n    CustomizedConsumerConfig properties = new CustomizedConsumerConfig(Utils.loadProps(\"src/test/resources/consumer.properties\"));\n    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServer);\n    properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);\n    properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n\n\n    ConsumerFetcherThread fetcherThread = new ConsumerFetcherThread(threadName,\n        properties, null, queue);\n    fetcherThread.start();\n\n    TestUtils.produceMessages(bootstrapServer, testTopic1, 10);\n    TestUtils.produceMessages(bootstrapServer, testTopic2, 10);\n\n    Map<TopicPartition, PartitionOffsetInfo> addPartitions = new HashMap<>();\n    TopicPartition tp1 = new TopicPartition(testTopic1, 0);\n    PartitionOffsetInfo pi1 = new PartitionOffsetInfo(tp1,0L, null);\n    addPartitions.put(tp1, pi1);\n    TopicPartition tp2 = new TopicPartition(testTopic2, 0);\n    PartitionOffsetInfo pi2 = new PartitionOffsetInfo(tp2,5L, null);\n    addPartitions.put(tp2, pi2);\n\n    fetcherThread.addPartitions(addPartitions);\n    Thread.sleep(1000);\n    Assert.assertEquals(1, queue.remainingCapacity());\n    FetchedDataChunk record1 = queue.take();\n    FetchedDataChunk record2 = queue.take();\n    Assert.assertEquals(15, record1.messageSize() + record2.messageSize());\n\n    addPartitions.remove(tp1);\n    fetcherThread.addPartitions(addPartitions);\n    Thread.sleep(1000);\n\n    Assert.assertEquals(3, queue.remainingCapacity());\n\n    // make sure testtopic1 still in fetcher thread\n    com.uber.stream.ureplicator.worker.TestUtils.produceMessages(bootstrapServer, testTopic1, 10);\n    Thread.sleep(1000);\n\n    Assert.assertEquals(2, queue.remainingCapacity());\n    FetchedDataChunk records = queue.take();\n    Assert.assertEquals(10, records.messageSize());\n\n    LOGGER.info(\"removePartitions/addPartitions to test specify same start offset again\");\n    Set<TopicPartition> removePartitions = new HashSet<>();\n    removePartitions.add(tp2);\n    fetcherThread.removePartitions(removePartitions);\n    Thread.sleep(1000);\n\n    fetcherThread.addPartitions(addPartitions);\n    Thread.sleep(1000);\n\n    Assert.assertEquals(2, queue.remainingCapacity());\n    records = queue.take();\n    Assert.assertEquals(5, records.messageSize());\n\n    LOGGER.info(\"removePartitions/addPartitions to test out of range\");\n    PartitionOffsetInfo pi3 = new PartitionOffsetInfo(tp2, 15L, null);\n    addPartitions.remove(tp1);\n    addPartitions.put(tp2, pi3);\n\n    fetcherThread.removePartitions(removePartitions);\n    //fetcherThread.doWork();\n    Thread.sleep(1000);\n\n    fetcherThread.addPartitions(addPartitions);\n    //fetcherThread.doWork();\n    Thread.sleep(1000);\n\n    Assert.assertEquals(2, queue.remainingCapacity());\n    records = queue.take();\n    Assert.assertEquals(10, records.messageSize());\n\n    // make sure testtopic1 still in fetcher thread\n    com.uber.stream.ureplicator.worker.TestUtils.produceMessages(bootstrapServer, testTopic1, 10);\n    //fetcherThread.doWork();\n    Thread.sleep(1000);\n\n    Assert.assertEquals(2, queue.remainingCapacity());\n    records = queue.take();\n    Assert.assertEquals(10, records.messageSize());\n    fetcherThread.shutdown();\n  }", "signature": "void testConsumerFetcherThread()", "full_signature": "@Test public void testConsumerFetcherThread()", "class_method_signature": "ConsumerFetcherThreadTest.testConsumerFetcherThread()", "testcase": true, "constructor": false, "invocations": ["createTopic", "createTopic", "loadProps", "put", "put", "put", "start", "produceMessages", "produceMessages", "put", "put", "addPartitions", "sleep", "assertEquals", "remainingCapacity", "take", "take", "assertEquals", "messageSize", "messageSize", "remove", "addPartitions", "sleep", "assertEquals", "remainingCapacity", "produceMessages", "sleep", "assertEquals", "remainingCapacity", "take", "assertEquals", "messageSize", "info", "add", "removePartitions", "sleep", "addPartitions", "sleep", "assertEquals", "remainingCapacity", "take", "assertEquals", "messageSize", "info", "remove", "put", "removePartitions", "sleep", "addPartitions", "sleep", "assertEquals", "remainingCapacity", "take", "assertEquals", "messageSize", "produceMessages", "sleep", "assertEquals", "remainingCapacity", "take", "assertEquals", "messageSize", "shutdown"]}, "focal_class": {"identifier": "ConsumerFetcherThread", "superclass": "extends ShutdownableThread", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ConsumerFetcherThread.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ConsumerFetcherThread.class)", "var_name": "LOGGER"}, {"original_string": "private final Object updateMapLock = new Object();", "modifier": "private final", "type": "Object", "declarator": "updateMapLock = new Object()", "var_name": "updateMapLock"}, {"original_string": "@GuardedBy(\"partitionMapLock\")\n  private final Map<TopicPartition, PartitionOffsetInfo> partitionMap = new ConcurrentHashMap<>();", "modifier": "@GuardedBy(\"partitionMapLock\")\n  private final", "type": "Map<TopicPartition, PartitionOffsetInfo>", "declarator": "partitionMap = new ConcurrentHashMap<>()", "var_name": "partitionMap"}, {"original_string": "private final Object partitionMapLock = new Object();", "modifier": "private final", "type": "Object", "declarator": "partitionMapLock = new Object()", "var_name": "partitionMapLock"}, {"original_string": "@GuardedBy(\"updateMapLock\")\n  private final Map<TopicPartition, PartitionOffsetInfo> partitionAddMap = new ConcurrentHashMap<>();", "modifier": "@GuardedBy(\"updateMapLock\")\n  private final", "type": "Map<TopicPartition, PartitionOffsetInfo>", "declarator": "partitionAddMap = new ConcurrentHashMap<>()", "var_name": "partitionAddMap"}, {"original_string": "@GuardedBy(\"updateMapLock\")\n  private final Map<TopicPartition, Boolean> partitionDeleteMap = new ConcurrentHashMap<>();", "modifier": "@GuardedBy(\"updateMapLock\")\n  private final", "type": "Map<TopicPartition, Boolean>", "declarator": "partitionDeleteMap = new ConcurrentHashMap<>()", "var_name": "partitionDeleteMap"}, {"original_string": "@GuardedBy(\"updateMapLock\")\n  private final Map<TopicPartition, Long> partitionResetOffsetMap = new ConcurrentHashMap<>();", "modifier": "@GuardedBy(\"updateMapLock\")\n  private final", "type": "Map<TopicPartition, Long>", "declarator": "partitionResetOffsetMap = new ConcurrentHashMap<>()", "var_name": "partitionResetOffsetMap"}, {"original_string": "private final KafkaConsumer kafkaConsumer;", "modifier": "private final", "type": "KafkaConsumer", "declarator": "kafkaConsumer", "var_name": "kafkaConsumer"}, {"original_string": "private long lastDumpTime = 0L;", "modifier": "private", "type": "long", "declarator": "lastDumpTime = 0L", "var_name": "lastDumpTime"}, {"original_string": "private final int offsetMonitorMs;", "modifier": "private final", "type": "int", "declarator": "offsetMonitorMs", "var_name": "offsetMonitorMs"}, {"original_string": "private final int fetchBackOffMs;", "modifier": "private final", "type": "int", "declarator": "fetchBackOffMs", "var_name": "fetchBackOffMs"}, {"original_string": "private final int pollTimeoutMs;", "modifier": "private final", "type": "int", "declarator": "pollTimeoutMs", "var_name": "pollTimeoutMs"}, {"original_string": "private final RateLimiter rateLimiter;", "modifier": "private final", "type": "RateLimiter", "declarator": "rateLimiter", "var_name": "rateLimiter"}, {"original_string": "private final BlockingQueue<FetchedDataChunk> chunkQueue;", "modifier": "private final", "type": "BlockingQueue<FetchedDataChunk>", "declarator": "chunkQueue", "var_name": "chunkQueue"}], "methods": [{"identifier": "ConsumerFetcherThread", "parameters": "(String threadName, CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "modifiers": "public", "return": "", "signature": " ConsumerFetcherThread(String threadName, CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "full_signature": "public  ConsumerFetcherThread(String threadName, CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "class_method_signature": "ConsumerFetcherThread.ConsumerFetcherThread(String threadName, CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "testcase": false, "constructor": true}, {"identifier": "doWork", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void doWork()", "full_signature": "@Override public void doWork()", "class_method_signature": "ConsumerFetcherThread.doWork()", "testcase": false, "constructor": false}, {"identifier": "processFetchedData", "parameters": "(ConsumerRecords consumerRecords)", "modifiers": "private", "return": "void", "signature": "void processFetchedData(ConsumerRecords consumerRecords)", "full_signature": "private void processFetchedData(ConsumerRecords consumerRecords)", "class_method_signature": "ConsumerFetcherThread.processFetchedData(ConsumerRecords consumerRecords)", "testcase": false, "constructor": false}, {"identifier": "logTopicPartitionInfo", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void logTopicPartitionInfo()", "full_signature": "private void logTopicPartitionInfo()", "class_method_signature": "ConsumerFetcherThread.logTopicPartitionInfo()", "testcase": false, "constructor": false}, {"identifier": "refreshPartitionMap", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean refreshPartitionMap()", "full_signature": "private boolean refreshPartitionMap()", "class_method_signature": "ConsumerFetcherThread.refreshPartitionMap()", "testcase": false, "constructor": false}, {"identifier": "addPartitions", "parameters": "(Map<TopicPartition, PartitionOffsetInfo> partitionAndOffsets)", "modifiers": "public", "return": "void", "signature": "void addPartitions(Map<TopicPartition, PartitionOffsetInfo> partitionAndOffsets)", "full_signature": "public void addPartitions(Map<TopicPartition, PartitionOffsetInfo> partitionAndOffsets)", "class_method_signature": "ConsumerFetcherThread.addPartitions(Map<TopicPartition, PartitionOffsetInfo> partitionAndOffsets)", "testcase": false, "constructor": false}, {"identifier": "removePartitions", "parameters": "(Set<TopicPartition> topicAndPartitions)", "modifiers": "public", "return": "void", "signature": "void removePartitions(Set<TopicPartition> topicAndPartitions)", "full_signature": "public void removePartitions(Set<TopicPartition> topicAndPartitions)", "class_method_signature": "ConsumerFetcherThread.removePartitions(Set<TopicPartition> topicAndPartitions)", "testcase": false, "constructor": false}, {"identifier": "getTopicPartitions", "parameters": "()", "modifiers": "public", "return": "Set<TopicPartition>", "signature": "Set<TopicPartition> getTopicPartitions()", "full_signature": "public Set<TopicPartition> getTopicPartitions()", "class_method_signature": "ConsumerFetcherThread.getTopicPartitions()", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "ConsumerFetcherThread.shutdown()", "testcase": false, "constructor": false}, {"identifier": "awaitShutdown", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void awaitShutdown()", "full_signature": "@Override public void awaitShutdown()", "class_method_signature": "ConsumerFetcherThread.awaitShutdown()", "testcase": false, "constructor": false}], "file": "uReplicator-Worker-3.0/src/main/java/com/uber/stream/ureplicator/worker/ConsumerFetcherThread.java"}, "focal_method": {"identifier": "ConsumerFetcherThread", "parameters": "(String threadName, CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "modifiers": "public", "return": "", "body": "public ConsumerFetcherThread(String threadName, CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue) {\n    super(threadName, true);\n    this.fetchBackOffMs = properties.getFetcherThreadBackoffMs();\n    this.offsetMonitorMs = properties.getOffsetMonitorInterval();\n    this.pollTimeoutMs = properties.getPollTimeoutMs();\n    this.kafkaConsumer = new KafkaConsumer(properties);\n    KafkaUReplicatorMetricsReporter.get()\n        .registerKafkaMetrics(\"consumer.\" + threadName, kafkaConsumer.metrics());\n    this.rateLimiter = rateLimiter;\n    this.chunkQueue = chunkQueue;\n  }", "signature": " ConsumerFetcherThread(String threadName, CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "full_signature": "public  ConsumerFetcherThread(String threadName, CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "class_method_signature": "ConsumerFetcherThread.ConsumerFetcherThread(String threadName, CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 60201162, "url": "https://github.com/uber/uReplicator", "language": "Java", "is_fork": false, "fork_count": 148, "stargazer_count": 652, "size": 2223, "license": "licensed"}}