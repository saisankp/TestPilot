{"test_class": {"identifier": "VFSubStateTest", "superclass": "", "interfaces": "", "fields": [], "file": "base/isomorphism/src/test/java/org/openscience/cdk/isomorphism/VFSubStateTest.java"}, "test_case": {"identifier": "infeasibleAtoms", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void infeasibleAtoms() throws Exception {\n        AtomMatcher mock = mock(AtomMatcher.class);\n        when(mock.matches(any(IAtom.class), any(IAtom.class))).thenReturn(false);\n        VFSubState state = createBenzeneToNaphthalene(mock, mock(BondMatcher.class));\n        for (int i = 0; i < state.nMax(); i++) {\n            for (int j = 0; j < state.mMax(); j++) {\n                assertFalse(state.feasible(i, j));\n            }\n        }\n    }", "signature": "void infeasibleAtoms()", "full_signature": "@Test public void infeasibleAtoms()", "class_method_signature": "VFSubStateTest.infeasibleAtoms()", "testcase": true, "constructor": false, "invocations": ["mock", "thenReturn", "when", "matches", "any", "any", "createBenzeneToNaphthalene", "mock", "nMax", "mMax", "assertFalse", "feasible"]}, "focal_class": {"identifier": "VFSubState", "superclass": "extends AbstractVFState", "interfaces": "", "fields": [{"original_string": "private final IAtomContainer container1, container2;", "modifier": "private final", "type": "IAtomContainer", "declarator": "container1", "var_name": "container1"}, {"original_string": "private final EdgeToBondMap  bonds1, bonds2;", "modifier": "private final", "type": "EdgeToBondMap", "declarator": "bonds1", "var_name": "bonds1"}, {"original_string": "private final AtomMatcher    atomMatcher;", "modifier": "private final", "type": "AtomMatcher", "declarator": "atomMatcher", "var_name": "atomMatcher"}, {"original_string": "private final BondMatcher    bondMatcher;", "modifier": "private final", "type": "BondMatcher", "declarator": "bondMatcher", "var_name": "bondMatcher"}], "methods": [{"identifier": "VFSubState", "parameters": "(IAtomContainer container1, IAtomContainer container2, int[][] g1, int[][] g2, EdgeToBondMap bonds1,\n            EdgeToBondMap bonds2, AtomMatcher atomMatcher, BondMatcher bondMatcher)", "modifiers": "", "return": "", "signature": " VFSubState(IAtomContainer container1, IAtomContainer container2, int[][] g1, int[][] g2, EdgeToBondMap bonds1,\n            EdgeToBondMap bonds2, AtomMatcher atomMatcher, BondMatcher bondMatcher)", "full_signature": "  VFSubState(IAtomContainer container1, IAtomContainer container2, int[][] g1, int[][] g2, EdgeToBondMap bonds1,\n            EdgeToBondMap bonds2, AtomMatcher atomMatcher, BondMatcher bondMatcher)", "class_method_signature": "VFSubState.VFSubState(IAtomContainer container1, IAtomContainer container2, int[][] g1, int[][] g2, EdgeToBondMap bonds1,\n            EdgeToBondMap bonds2, AtomMatcher atomMatcher, BondMatcher bondMatcher)", "testcase": false, "constructor": true}, {"identifier": "feasible", "parameters": "(int n, int m)", "modifiers": "@Override", "return": "boolean", "signature": "boolean feasible(int n, int m)", "full_signature": "@Override boolean feasible(int n, int m)", "class_method_signature": "VFSubState.feasible(int n, int m)", "testcase": false, "constructor": false}], "file": "base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/VFSubState.java"}, "focal_method": {"identifier": "feasible", "parameters": "(int n, int m)", "modifiers": "@Override", "return": "boolean", "body": "@Override\n    boolean feasible(int n, int m) {\n\n        // verify atom semantic feasibility\n        if (!atomMatcher.matches(container1.getAtom(n), container2.getAtom(m))) return false;\n\n        // unmapped terminal vertices n and m are adjacent to\n        int nTerminal1 = 0, nTerminal2 = 0;\n        // unmapped non-terminal (remaining) vertices n and m are adjacent to\n        int nRemain1 = 0, nRemain2 = 0;\n\n        // 0-look-ahead: check each adjacent edge for being mapped, and count\n        // terminal or remaining\n        for (int n_prime : g1[n]) {\n            int m_prime = m1[n_prime];\n\n            // v is already mapped, there should be an edge {m, w} in g2.\n            if (m_prime != UNMAPPED) {\n                IBond bond2 = bonds2.get(m, m_prime);\n                if (bond2 == null) // the bond is not present in the target\n                    return false;\n                // verify bond semantic feasibility\n                if (!bondMatcher.matches(bonds1.get(n, n_prime), bond2)) return false;\n            } else {\n                if (t1[n_prime] > 0)\n                    nTerminal1++;\n                else\n                    nRemain1++;\n            }\n        }\n\n        // monomorphism: each mapped edge in g2 doesn't need to be in g1 so\n        // only the terminal and remaining edges are counted\n        for (int m_prime : g2[m]) {\n            if (m2[m_prime] == UNMAPPED) {\n                if (t2[m_prime] > 0)\n                    nTerminal2++;\n                else\n                    nRemain2++;\n            }\n        }\n\n        // 1-look-ahead : the mapping {n, m} is feasible iff the number of\n        // terminal vertices (t1) adjacent to n is less than or equal to the\n        // number of terminal vertices (t2) adjacent to m.\n        //\n        // 2-look-ahead: the mapping {n, m} is feasible iff the number of\n        // vertices adjacent to n that are neither in m1 or t1 is less than or\n        // equal to the number of the number of vertices adjacent to m that\n        // are neither in m2 or t2. To allow mapping of monomorphisms we add the\n        // number of adjacent terminal vertices.\n        return nTerminal1 <= nTerminal2 && (nRemain1 + nTerminal1) <= (nRemain2 + nTerminal2);\n    }", "signature": "boolean feasible(int n, int m)", "full_signature": "@Override boolean feasible(int n, int m)", "class_method_signature": "VFSubState.feasible(int n, int m)", "testcase": false, "constructor": false, "invocations": ["matches", "getAtom", "getAtom", "get", "matches", "get"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}