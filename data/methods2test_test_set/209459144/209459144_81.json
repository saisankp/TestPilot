{"test_class": {"identifier": "ClusterRestApiTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static ClusterServer mockClusterServer;", "modifier": "private static", "type": "ClusterServer", "declarator": "mockClusterServer", "var_name": "mockClusterServer"}, {"original_string": "private static ClusterRestApi clusterRestApi;", "modifier": "private static", "type": "ClusterRestApi", "declarator": "clusterRestApi", "var_name": "clusterRestApi"}, {"original_string": "private static final GsonBuilder gsonBuilder = new GsonBuilder();", "modifier": "private static final", "type": "GsonBuilder", "declarator": "gsonBuilder = new GsonBuilder()", "var_name": "gsonBuilder"}, {"original_string": "private static Gson gson = gsonBuilder.setDateFormat(\"yyyy-MM-dd HH:mm:ss\").create();", "modifier": "private static", "type": "Gson", "declarator": "gson = gsonBuilder.setDateFormat(\"yyyy-MM-dd HH:mm:ss\").create()", "var_name": "gson"}, {"original_string": "private static HashMap<String, HashMap<String, Object>> clusterMetas = new HashMap<>();", "modifier": "private static", "type": "HashMap<String, HashMap<String, Object>>", "declarator": "clusterMetas = new HashMap<>()", "var_name": "clusterMetas"}, {"original_string": "private static HashMap<String, Object> meta1 = new HashMap<>();", "modifier": "private static", "type": "HashMap<String, Object>", "declarator": "meta1 = new HashMap<>()", "var_name": "meta1"}, {"original_string": "private static HashMap<String, Object> meta2 = new HashMap<>();", "modifier": "private static", "type": "HashMap<String, Object>", "declarator": "meta2 = new HashMap<>()", "var_name": "meta2"}, {"original_string": "private static String nodeName1 = \"dummy\";", "modifier": "private static", "type": "String", "declarator": "nodeName1 = \"dummy\"", "var_name": "nodeName1"}, {"original_string": "private static LocalDateTime SERVER_START_TIME1 = LocalDateTime.now();", "modifier": "private static", "type": "LocalDateTime", "declarator": "SERVER_START_TIME1 = LocalDateTime.now()", "var_name": "SERVER_START_TIME1"}, {"original_string": "private static LocalDateTime INTP_START_TIME = LocalDateTime.now();", "modifier": "private static", "type": "LocalDateTime", "declarator": "INTP_START_TIME = LocalDateTime.now()", "var_name": "INTP_START_TIME"}, {"original_string": "private static LocalDateTime LATEST_HEARTBEAT = LocalDateTime.now();", "modifier": "private static", "type": "LocalDateTime", "declarator": "LATEST_HEARTBEAT = LocalDateTime.now()", "var_name": "LATEST_HEARTBEAT"}, {"original_string": "private static long cpuUsed1 = 20;", "modifier": "private static", "type": "long", "declarator": "cpuUsed1 = 20", "var_name": "cpuUsed1"}, {"original_string": "private static long cpuCapacity1 = 40;", "modifier": "private static", "type": "long", "declarator": "cpuCapacity1 = 40", "var_name": "cpuCapacity1"}, {"original_string": "private static long memoryUsed1 = 536870912;", "modifier": "private static", "type": "long", "declarator": "memoryUsed1 = 536870912", "var_name": "memoryUsed1"}, {"original_string": "private static long memoryCapacity1 = 1073741824;", "modifier": "private static", "type": "long", "declarator": "memoryCapacity1 = 1073741824", "var_name": "memoryCapacity1"}, {"original_string": "private static LocalDateTime SERVER_START_TIME2 = LocalDateTime.now();", "modifier": "private static", "type": "LocalDateTime", "declarator": "SERVER_START_TIME2 = LocalDateTime.now()", "var_name": "SERVER_START_TIME2"}, {"original_string": "private static long cpuUsed2 = 25;", "modifier": "private static", "type": "long", "declarator": "cpuUsed2 = 25", "var_name": "cpuUsed2"}, {"original_string": "private static long cpuCapacity2 = 40;", "modifier": "private static", "type": "long", "declarator": "cpuCapacity2 = 40", "var_name": "cpuCapacity2"}, {"original_string": "private static long memoryUsed2 = 268435456;", "modifier": "private static", "type": "long", "declarator": "memoryUsed2 = 268435456", "var_name": "memoryUsed2"}, {"original_string": "private static long memoryCapacity2 = 1073741824;", "modifier": "private static", "type": "long", "declarator": "memoryCapacity2 = 1073741824", "var_name": "memoryCapacity2"}, {"original_string": "private static String nodeName2 = \"dummydummy\";", "modifier": "private static", "type": "String", "declarator": "nodeName2 = \"dummydummy\"", "var_name": "nodeName2"}], "file": "submarine-server/server-core/src/test/java/org/apache/submarine/server/rest/ClusterRestApiTest.java"}, "test_case": {"identifier": "testGetClusterNodes", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testGetClusterNodes() {\n    when(mockClusterServer.getClusterMeta(ClusterMetaType.SERVER_META, \"\")).thenReturn(clusterMetas);\n    Response response = clusterRestApi.getClusterNodes();\n    ArrayList<HashMap<String, Object>> result = getResultListFromResponse(response);\n    Map<String, Object> properties1 = (LinkedTreeMap) result.get(0).get(ClusterMeta.PROPERTIES);\n    Map<String, Object> properties2 = (LinkedTreeMap) result.get(1).get(ClusterMeta.PROPERTIES);\n\n    assertEquals(nodeName1, result.get(0).get(ClusterMeta.NODE_NAME));\n    assertEquals(\"ONLINE\", properties1.get(\"STATUS\"));\n    assertEquals(\"0.50GB / 1.00GB = 50.00%\", properties1.get(\"MEMORY_USED / MEMORY_CAPACITY\"));\n    assertEquals(\"0.20 / 0.40 = 50.00%\", properties1.get(\"CPU_USED / CPU_CAPACITY\"));\n\n    assertEquals(nodeName2, result.get(1).get(ClusterMeta.NODE_NAME));\n    assertEquals(\"OFFLINE\", properties2.get(\"STATUS\"));\n    assertEquals(\"0.25GB / 1.00GB = 25.00%\", properties2.get(\"MEMORY_USED / MEMORY_CAPACITY\"));\n    assertEquals(\"0.25 / 0.40 = 62.50%\", properties2.get(\"CPU_USED / CPU_CAPACITY\"));\n  }", "signature": "void testGetClusterNodes()", "full_signature": "@Test public void testGetClusterNodes()", "class_method_signature": "ClusterRestApiTest.testGetClusterNodes()", "testcase": true, "constructor": false, "invocations": ["thenReturn", "when", "getClusterMeta", "getClusterNodes", "getResultListFromResponse", "get", "get", "get", "get", "assertEquals", "get", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "ClusterRestApi", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(ClusterRestApi.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(ClusterRestApi.class)", "var_name": "LOG"}, {"original_string": "Gson gson = new Gson();", "modifier": "", "type": "Gson", "declarator": "gson = new Gson()", "var_name": "gson"}, {"original_string": "private ClusterServer clusterServer = ClusterServer.getInstance();", "modifier": "private", "type": "ClusterServer", "declarator": "clusterServer = ClusterServer.getInstance()", "var_name": "clusterServer"}], "methods": [{"identifier": "setClusterServer", "parameters": "(ClusterServer clusterServer)", "modifiers": "@VisibleForTesting public", "return": "void", "signature": "void setClusterServer(ClusterServer clusterServer)", "full_signature": "@VisibleForTesting public void setClusterServer(ClusterServer clusterServer)", "class_method_signature": "ClusterRestApi.setClusterServer(ClusterServer clusterServer)", "testcase": false, "constructor": false}, {"identifier": "getClusterAddress", "parameters": "()", "modifiers": "@GET @Path(\"/\" + RestConstants.ADDRESS) @SubmarineApi public", "return": "Response", "signature": "Response getClusterAddress()", "full_signature": "@GET @Path(\"/\" + RestConstants.ADDRESS) @SubmarineApi public Response getClusterAddress()", "class_method_signature": "ClusterRestApi.getClusterAddress()", "testcase": false, "constructor": false}, {"identifier": "getClusterNodes", "parameters": "()", "modifiers": "@GET @Path(\"/\" + RestConstants.NODES) @SubmarineApi public", "return": "Response", "signature": "Response getClusterNodes()", "full_signature": "@GET @Path(\"/\" + RestConstants.NODES) @SubmarineApi public Response getClusterNodes()", "class_method_signature": "ClusterRestApi.getClusterNodes()", "testcase": false, "constructor": false}, {"identifier": "getClusterNode", "parameters": "(@PathParam(\"nodeName\") String nodeName,\n                                 @PathParam(\"intpName\") String intpName)", "modifiers": "@GET @Path(\"/\" + RestConstants.NODE + \"/{nodeName}/{intpName}\") @SubmarineApi public", "return": "Response", "signature": "Response getClusterNode(@PathParam(\"nodeName\") String nodeName,\n                                 @PathParam(\"intpName\") String intpName)", "full_signature": "@GET @Path(\"/\" + RestConstants.NODE + \"/{nodeName}/{intpName}\") @SubmarineApi public Response getClusterNode(@PathParam(\"nodeName\") String nodeName,\n                                 @PathParam(\"intpName\") String intpName)", "class_method_signature": "ClusterRestApi.getClusterNode(@PathParam(\"nodeName\") String nodeName,\n                                 @PathParam(\"intpName\") String intpName)", "testcase": false, "constructor": false}, {"identifier": "formatLocalDateTime", "parameters": "(LocalDateTime localDateTime)", "modifiers": "private", "return": "String", "signature": "String formatLocalDateTime(LocalDateTime localDateTime)", "full_signature": "private String formatLocalDateTime(LocalDateTime localDateTime)", "class_method_signature": "ClusterRestApi.formatLocalDateTime(LocalDateTime localDateTime)", "testcase": false, "constructor": false}], "file": "submarine-server/server-core/src/main/java/org/apache/submarine/server/rest/ClusterRestApi.java"}, "focal_method": {"identifier": "getClusterNodes", "parameters": "()", "modifiers": "@GET @Path(\"/\" + RestConstants.NODES) @SubmarineApi public", "return": "Response", "body": "@GET\n  @Path(\"/\" + RestConstants.NODES)\n  @SubmarineApi\n  public Response getClusterNodes(){\n    ArrayList<HashMap<String, Object>> nodes = new ArrayList<>();\n\n    Map<String, HashMap<String, Object>> clusterMeta = null;\n    Map<String, HashMap<String, Object>> intpMeta = null;\n    clusterMeta = clusterServer.getClusterMeta(ClusterMetaType.SERVER_META, \"\");\n    intpMeta = clusterServer.getClusterMeta(ClusterMetaType.INTP_PROCESS_META, \"\");\n\n    // Number of interpreter processes\n    for (Map.Entry<String, HashMap<String, Object>> serverMetaEntity : clusterMeta.entrySet()) {\n      if (!serverMetaEntity.getValue().containsKey(ClusterMeta.NODE_NAME)) {\n        continue;\n      }\n      String serverNodeName = (String) serverMetaEntity.getValue().get(ClusterMeta.NODE_NAME);\n\n      ArrayList<String> arrIntpProcess = new ArrayList<>();\n      int intpProcCount = 0;\n      for (Map.Entry<String, HashMap<String, Object>> intpMetaEntity : intpMeta.entrySet()) {\n        if (!intpMetaEntity.getValue().containsKey(ClusterMeta.NODE_NAME)\n            && !intpMetaEntity.getValue().containsKey(ClusterMeta.INTP_PROCESS_NAME)) {\n          continue;\n        }\n        String intpNodeName = (String) intpMetaEntity.getValue().get(ClusterMeta.NODE_NAME);\n\n        if (serverNodeName.equals(intpNodeName)) {\n          intpProcCount++;\n          String intpName = (String) intpMetaEntity.getValue().get(ClusterMeta.INTP_PROCESS_NAME);\n          arrIntpProcess.add(intpName);\n        }\n      }\n      serverMetaEntity.getValue().put(ClusterMeta.INTP_PROCESS_COUNT, intpProcCount);\n      serverMetaEntity.getValue().put(ClusterMeta.INTP_PROCESS_LIST, arrIntpProcess);\n    }\n\n    for (Map.Entry<String, HashMap<String, Object>> entry : clusterMeta.entrySet()) {\n      String nodeName = entry.getKey();\n      Map<String, Object> properties = entry.getValue();\n\n      Map<String, Object> sortProperties = new HashMap<>();\n\n      if (properties.containsKey(ClusterMeta.CPU_USED)\n          && properties.containsKey(ClusterMeta.CPU_CAPACITY)) {\n        float cpuUsed = (long) properties.get(ClusterMeta.CPU_USED) / (float) 100.0;\n        float cpuCapacity = (long) properties.get(ClusterMeta.CPU_CAPACITY) / (float) 100.0;\n        float cpuRate = cpuUsed / cpuCapacity * 100;\n\n        String cpuInfo = String.format(\"%.2f / %.2f = %.2f\", cpuUsed, cpuCapacity, cpuRate);\n        sortProperties.put(ClusterMeta.CPU_USED + \" / \" + ClusterMeta.CPU_CAPACITY, cpuInfo + \"%\");\n      }\n\n      if (properties.containsKey(ClusterMeta.MEMORY_USED)\n          && properties.containsKey(ClusterMeta.MEMORY_CAPACITY)) {\n        float memoryUsed = (long) properties.get(ClusterMeta.MEMORY_USED) / (float) (1024 * 1024 * 1024);\n        float memoryCapacity\n            = (long) properties.get(ClusterMeta.MEMORY_CAPACITY) / (float) (1024 * 1024 * 1024);\n        float memoryRate = memoryUsed / memoryCapacity * 100;\n\n        String memoryInfo = String.format(\"%.2fGB / %.2fGB = %.2f\",\n            memoryUsed, memoryCapacity, memoryRate);\n        sortProperties.put(ClusterMeta.MEMORY_USED + \" / \" + ClusterMeta.MEMORY_CAPACITY, memoryInfo + \"%\");\n      }\n\n      if (properties.containsKey(ClusterMeta.SERVER_START_TIME)) {\n        // format LocalDateTime\n        Object serverStartTime = properties.get(ClusterMeta.SERVER_START_TIME);\n        if (serverStartTime instanceof LocalDateTime) {\n          LocalDateTime localDateTime = (LocalDateTime) serverStartTime;\n          String dateTime = formatLocalDateTime(localDateTime);\n          sortProperties.put(ClusterMeta.SERVER_START_TIME, dateTime);\n        } else {\n          sortProperties.put(ClusterMeta.SERVER_START_TIME, \"Wrong time type!\");\n        }\n      }\n      if (properties.containsKey(ClusterMeta.STATUS)) {\n        sortProperties.put(ClusterMeta.STATUS, properties.get(ClusterMeta.STATUS));\n      }\n      if (properties.containsKey(ClusterMeta.LATEST_HEARTBEAT)) {\n        // format LocalDateTime\n        Object latestHeartbeat = properties.get(ClusterMeta.LATEST_HEARTBEAT);\n        if (latestHeartbeat instanceof LocalDateTime) {\n          LocalDateTime localDateTime = (LocalDateTime) latestHeartbeat;\n          String dateTime = formatLocalDateTime(localDateTime);\n          sortProperties.put(ClusterMeta.LATEST_HEARTBEAT, dateTime);\n        } else {\n          sortProperties.put(ClusterMeta.LATEST_HEARTBEAT, \"Wrong time type!\");\n        }\n      }\n      if (properties.containsKey(ClusterMeta.INTP_PROCESS_LIST)) {\n        sortProperties.put(ClusterMeta.INTP_PROCESS_LIST, properties.get(ClusterMeta.INTP_PROCESS_LIST));\n      }\n\n      HashMap<String, Object> node = new HashMap<>();\n      node.put(ClusterMeta.NODE_NAME, nodeName);\n      node.put(ClusterMeta.PROPERTIES, sortProperties);\n\n      nodes.add(node);\n    }\n\n    return new JsonResponse.Builder<ArrayList<HashMap<String, Object>>>(Response.Status.OK)\n        .success(true).result(nodes).build();\n  }", "signature": "Response getClusterNodes()", "full_signature": "@GET @Path(\"/\" + RestConstants.NODES) @SubmarineApi public Response getClusterNodes()", "class_method_signature": "ClusterRestApi.getClusterNodes()", "testcase": false, "constructor": false, "invocations": ["getClusterMeta", "getClusterMeta", "entrySet", "containsKey", "getValue", "get", "getValue", "entrySet", "containsKey", "getValue", "containsKey", "getValue", "get", "getValue", "equals", "get", "getValue", "add", "put", "getValue", "put", "getValue", "entrySet", "getKey", "getValue", "containsKey", "containsKey", "get", "get", "format", "put", "containsKey", "containsKey", "get", "get", "format", "put", "containsKey", "get", "formatLocalDateTime", "put", "put", "containsKey", "put", "get", "containsKey", "get", "formatLocalDateTime", "put", "put", "containsKey", "put", "get", "put", "put", "add", "build", "result", "success"]}, "repository": {"repo_id": 209459144, "url": "https://github.com/apache/submarine", "stars": 185, "created": "9/19/2019 4:00:17 AM +00:00", "updates": "2020-01-27T15:27:05+00:00", "fork": "False", "license": "licensed"}}