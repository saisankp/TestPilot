{"test_class": {"identifier": "PipeTest", "superclass": "", "interfaces": "", "fields": [], "file": "dexter-core/src/test/java/it/cnr/isti/hpc/dexter/spot/cleanpipe/PipeTest.java"}, "test_case": {"identifier": "pipe2", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void pipe2() {\n\t\tPipe<String> pipe = new Pipe<String>(new AppendOne());\n\t\tpipe = new Pipe<String>(pipe, new AppendTwo());\n\t\tList<String> result = pipe.process(\"\");\n\t\tassertEquals(\"12\",result.get(0));\n\t\t\n\t}", "signature": "void pipe2()", "full_signature": "@Test public void pipe2()", "class_method_signature": "PipeTest.pipe2()", "testcase": true, "constructor": false, "invocations": ["process", "assertEquals", "get"]}, "focal_class": {"identifier": "Pipe", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Pipe<T> next;", "modifier": "private", "type": "Pipe<T>", "declarator": "next", "var_name": "next"}, {"original_string": "public ArrayList<T> output;", "modifier": "public", "type": "ArrayList<T>", "declarator": "output", "var_name": "output"}, {"original_string": "private Function<T> fun;", "modifier": "private", "type": "Function<T>", "declarator": "fun", "var_name": "fun"}, {"original_string": "private Pipe<T> head = null;", "modifier": "private", "type": "Pipe<T>", "declarator": "head = null", "var_name": "head"}, {"original_string": "private static final Logger logger = LoggerFactory.getLogger(Pipe.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(Pipe.class)", "var_name": "logger"}, {"original_string": "private OutputCollector collector;", "modifier": "private", "type": "OutputCollector", "declarator": "collector", "var_name": "collector"}], "methods": [{"identifier": "Pipe", "parameters": "(Function<T> fun)", "modifiers": "public", "return": "", "signature": " Pipe(Function<T> fun)", "full_signature": "public  Pipe(Function<T> fun)", "class_method_signature": "Pipe.Pipe(Function<T> fun)", "testcase": false, "constructor": true}, {"identifier": "Pipe", "parameters": "(Pipe<T> previous, Function<T> fun)", "modifiers": "public", "return": "", "signature": " Pipe(Pipe<T> previous, Function<T> fun)", "full_signature": "public  Pipe(Pipe<T> previous, Function<T> fun)", "class_method_signature": "Pipe.Pipe(Pipe<T> previous, Function<T> fun)", "testcase": false, "constructor": true}, {"identifier": "getHead", "parameters": "()", "modifiers": "private", "return": "Pipe<T>", "signature": "Pipe<T> getHead()", "full_signature": "private Pipe<T> getHead()", "class_method_signature": "Pipe.getHead()", "testcase": false, "constructor": false}, {"identifier": "getNext", "parameters": "()", "modifiers": "private", "return": "Pipe<T>", "signature": "Pipe<T> getNext()", "full_signature": "private Pipe<T> getNext()", "class_method_signature": "Pipe.getNext()", "testcase": false, "constructor": false}, {"identifier": "getOutput", "parameters": "()", "modifiers": "private", "return": "Iterator<T>", "signature": "Iterator<T> getOutput()", "full_signature": "private Iterator<T> getOutput()", "class_method_signature": "Pipe.getOutput()", "testcase": false, "constructor": false}, {"identifier": "clearOutput", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void clearOutput()", "full_signature": "private void clearOutput()", "class_method_signature": "Pipe.clearOutput()", "testcase": false, "constructor": false}, {"identifier": "getResults", "parameters": "()", "modifiers": "protected", "return": "List<T>", "signature": "List<T> getResults()", "full_signature": "protected List<T> getResults()", "class_method_signature": "Pipe.getResults()", "testcase": false, "constructor": false}, {"identifier": "process", "parameters": "(T elem)", "modifiers": "public", "return": "List<T>", "signature": "List<T> process(T elem)", "full_signature": "public List<T> process(T elem)", "class_method_signature": "Pipe.process(T elem)", "testcase": false, "constructor": false}, {"identifier": "pushResult", "parameters": "(T elem)", "modifiers": "protected", "return": "void", "signature": "void pushResult(T elem)", "full_signature": "protected void pushResult(T elem)", "class_method_signature": "Pipe.pushResult(T elem)", "testcase": false, "constructor": false}], "file": "dexter-core/src/main/java/it/cnr/isti/hpc/dexter/spot/cleanpipe/Pipe.java"}, "focal_method": {"identifier": "process", "parameters": "(T elem)", "modifiers": "public", "return": "List<T>", "body": "public List<T> process(T elem) {\n\t\tPipe<T> p = head;\n\t\tList<T> elems = new ArrayList<T>();\n\t\tp.fun.eval(elem, p.collector);\n\t\twhile (p.getNext() != null) {\n\t\t\t// logger.info(\"pipe {}\",p.fun.getClass());\n\t\t\tIterator<T> iter = p.getOutput();\n\t\t\tif (iter == null) {\n\t\t\t\tlogger.warn(\"iter is null\");\n\t\t\t}\n\t\t\telems.clear();\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tT obj = iter.next();\n\t\t\t\tif (obj == null) {\n\t\t\t\t\t// FIXME understand why sometimes this is null, concurrency?\n\t\t\t\t\tlogger.warn(\"iter returned null object\");\n\t\t\t\t}\n\t\t\t\tif (obj != null) {\n\t\t\t\t\telems.add(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// logger.info(\"output -> {}\",elems);\n\t\t\tp.clearOutput();\n\n\t\t\tp = p.getNext();\n\t\t\tfor (T t : elems) {\n\t\t\t\tp.fun.eval(t, p.collector);\n\n\t\t\t}\n\t\t}\n\t\t// logger.info(\"pipe {}\",p.fun.getClass());\n\t\t// logger.info(\"f output -> {}\",output);\n\n\t\treturn getResults();\n\t}", "signature": "List<T> process(T elem)", "full_signature": "public List<T> process(T elem)", "class_method_signature": "Pipe.process(T elem)", "testcase": false, "constructor": false, "invocations": ["eval", "getNext", "getOutput", "warn", "clear", "hasNext", "next", "warn", "add", "clearOutput", "getNext", "eval", "getResults"]}, "repository": {"repo_id": 8091481, "url": "https://github.com/dexter/dexter", "language": "Java", "is_fork": false, "fork_count": 52, "stargazer_count": 196, "size": 17631, "license": "licensed"}}