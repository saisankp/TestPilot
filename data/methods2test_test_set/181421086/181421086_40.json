{"test_class": {"identifier": "IPv4Test", "superclass": "", "interfaces": "", "fields": [{"original_string": "byte[] pktSerialized = \n            new byte[] { 0x45, 0x00,\n                         0x00, 0x2e, 0x41, (byte) 0xbe, 0x40, 0x00, 0x40, 0x06,\n                         (byte) 0xd4, (byte) 0xf0, (byte) 0xc0, (byte) 0xa8, \n                         0x02, (byte) 0xdb, (byte) 0xd0, 0x55,\n                         (byte) 0x90, 0x42, (byte) 0xd5, 0x48, 0x01, (byte) \n                         0xbb, (byte) 0xe3, 0x50,\n                         (byte) 0xb2, 0x2f, (byte) 0xfc, (byte) 0xf8, \n                         (byte) 0xa8, 0x2c, 0x50, 0x18,\n                         (byte) 0xff, (byte) 0xff, 0x24, 0x3c, 0x00, \n                         0x00, 0x14, 0x03,\n                         0x01, 0x00, 0x01, 0x01\n    };", "modifier": "", "type": "byte[]", "declarator": "pktSerialized = \n            new byte[] { 0x45, 0x00,\n                         0x00, 0x2e, 0x41, (byte) 0xbe, 0x40, 0x00, 0x40, 0x06,\n                         (byte) 0xd4, (byte) 0xf0, (byte) 0xc0, (byte) 0xa8, \n                         0x02, (byte) 0xdb, (byte) 0xd0, 0x55,\n                         (byte) 0x90, 0x42, (byte) 0xd5, 0x48, 0x01, (byte) \n                         0xbb, (byte) 0xe3, 0x50,\n                         (byte) 0xb2, 0x2f, (byte) 0xfc, (byte) 0xf8, \n                         (byte) 0xa8, 0x2c, 0x50, 0x18,\n                         (byte) 0xff, (byte) 0xff, 0x24, 0x3c, 0x00, \n                         0x00, 0x14, 0x03,\n                         0x01, 0x00, 0x01, 0x01\n    }", "var_name": "pktSerialized"}], "file": "src/agents/apps/floodlight/floodlight-1.0/src/test/java/net/floodlightcontroller/packet/IPv4Test.java"}, "test_case": {"identifier": "testToIPv4Address", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testToIPv4Address() {\n        int intIp = 0xc0a80001;\n        String stringIp = \"192.168.0.1\";\n        byte[] byteIp = new byte[] {(byte)192, (byte)168, (byte)0, (byte)1};\n        assertEquals(intIp, IPv4.toIPv4Address(stringIp));\n        assertEquals(intIp, IPv4.toIPv4Address(byteIp));\n        assertTrue(Arrays.equals(byteIp, IPv4.toIPv4AddressBytes(intIp)));\n        assertTrue(Arrays.equals(byteIp, IPv4.toIPv4AddressBytes(stringIp)));\n    }", "signature": "void testToIPv4Address()", "full_signature": "@Test public void testToIPv4Address()", "class_method_signature": "IPv4Test.testToIPv4Address()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "toIPv4Address", "assertEquals", "toIPv4Address", "assertTrue", "equals", "toIPv4AddressBytes", "assertTrue", "equals", "toIPv4AddressBytes"]}, "focal_class": {"identifier": "IPv4", "superclass": "extends BasePacket", "interfaces": "", "fields": [{"original_string": "public static Map<IpProtocol, Class<? extends IPacket>> protocolClassMap;", "modifier": "public static", "type": "Map<IpProtocol, Class<? extends IPacket>>", "declarator": "protocolClassMap", "var_name": "protocolClassMap"}, {"original_string": "public static final byte IPV4_FLAGS_MOREFRAG = 0x1;", "modifier": "public static final", "type": "byte", "declarator": "IPV4_FLAGS_MOREFRAG = 0x1", "var_name": "IPV4_FLAGS_MOREFRAG"}, {"original_string": "public static final byte IPV4_FLAGS_DONTFRAG = 0x2;", "modifier": "public static final", "type": "byte", "declarator": "IPV4_FLAGS_DONTFRAG = 0x2", "var_name": "IPV4_FLAGS_DONTFRAG"}, {"original_string": "public static final byte IPV4_FLAGS_MASK = 0x7;", "modifier": "public static final", "type": "byte", "declarator": "IPV4_FLAGS_MASK = 0x7", "var_name": "IPV4_FLAGS_MASK"}, {"original_string": "public static final byte IPV4_FLAGS_SHIFT = 13;", "modifier": "public static final", "type": "byte", "declarator": "IPV4_FLAGS_SHIFT = 13", "var_name": "IPV4_FLAGS_SHIFT"}, {"original_string": "public static final short IPV4_OFFSET_MASK = (1 << IPV4_FLAGS_SHIFT) - 1;", "modifier": "public static final", "type": "short", "declarator": "IPV4_OFFSET_MASK = (1 << IPV4_FLAGS_SHIFT) - 1", "var_name": "IPV4_OFFSET_MASK"}, {"original_string": "protected byte version;", "modifier": "protected", "type": "byte", "declarator": "version", "var_name": "version"}, {"original_string": "protected byte headerLength;", "modifier": "protected", "type": "byte", "declarator": "headerLength", "var_name": "headerLength"}, {"original_string": "protected byte diffServ;", "modifier": "protected", "type": "byte", "declarator": "diffServ", "var_name": "diffServ"}, {"original_string": "protected short totalLength;", "modifier": "protected", "type": "short", "declarator": "totalLength", "var_name": "totalLength"}, {"original_string": "protected short identification;", "modifier": "protected", "type": "short", "declarator": "identification", "var_name": "identification"}, {"original_string": "protected byte flags;", "modifier": "protected", "type": "byte", "declarator": "flags", "var_name": "flags"}, {"original_string": "protected short fragmentOffset;", "modifier": "protected", "type": "short", "declarator": "fragmentOffset", "var_name": "fragmentOffset"}, {"original_string": "protected byte ttl;", "modifier": "protected", "type": "byte", "declarator": "ttl", "var_name": "ttl"}, {"original_string": "protected IpProtocol protocol;", "modifier": "protected", "type": "IpProtocol", "declarator": "protocol", "var_name": "protocol"}, {"original_string": "protected short checksum;", "modifier": "protected", "type": "short", "declarator": "checksum", "var_name": "checksum"}, {"original_string": "protected IPv4Address sourceAddress;", "modifier": "protected", "type": "IPv4Address", "declarator": "sourceAddress", "var_name": "sourceAddress"}, {"original_string": "protected IPv4Address destinationAddress;", "modifier": "protected", "type": "IPv4Address", "declarator": "destinationAddress", "var_name": "destinationAddress"}, {"original_string": "protected byte[] options;", "modifier": "protected", "type": "byte[]", "declarator": "options", "var_name": "options"}, {"original_string": "protected boolean isTruncated;", "modifier": "protected", "type": "boolean", "declarator": "isTruncated", "var_name": "isTruncated"}, {"original_string": "protected boolean isFragment;", "modifier": "protected", "type": "boolean", "declarator": "isFragment", "var_name": "isFragment"}], "methods": [{"identifier": "IPv4", "parameters": "()", "modifiers": "public", "return": "", "signature": " IPv4()", "full_signature": "public  IPv4()", "class_method_signature": "IPv4.IPv4()", "testcase": false, "constructor": true}, {"identifier": "getVersion", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getVersion()", "full_signature": "public byte getVersion()", "class_method_signature": "IPv4.getVersion()", "testcase": false, "constructor": false}, {"identifier": "setVersion", "parameters": "(byte version)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setVersion(byte version)", "full_signature": "public IPv4 setVersion(byte version)", "class_method_signature": "IPv4.setVersion(byte version)", "testcase": false, "constructor": false}, {"identifier": "getHeaderLength", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getHeaderLength()", "full_signature": "public byte getHeaderLength()", "class_method_signature": "IPv4.getHeaderLength()", "testcase": false, "constructor": false}, {"identifier": "getDiffServ", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getDiffServ()", "full_signature": "public byte getDiffServ()", "class_method_signature": "IPv4.getDiffServ()", "testcase": false, "constructor": false}, {"identifier": "setDiffServ", "parameters": "(byte diffServ)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDiffServ(byte diffServ)", "full_signature": "public IPv4 setDiffServ(byte diffServ)", "class_method_signature": "IPv4.setDiffServ(byte diffServ)", "testcase": false, "constructor": false}, {"identifier": "getTotalLength", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getTotalLength()", "full_signature": "public short getTotalLength()", "class_method_signature": "IPv4.getTotalLength()", "testcase": false, "constructor": false}, {"identifier": "getIdentification", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getIdentification()", "full_signature": "public short getIdentification()", "class_method_signature": "IPv4.getIdentification()", "testcase": false, "constructor": false}, {"identifier": "isTruncated", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isTruncated()", "full_signature": "public boolean isTruncated()", "class_method_signature": "IPv4.isTruncated()", "testcase": false, "constructor": false}, {"identifier": "setTruncated", "parameters": "(boolean isTruncated)", "modifiers": "public", "return": "void", "signature": "void setTruncated(boolean isTruncated)", "full_signature": "public void setTruncated(boolean isTruncated)", "class_method_signature": "IPv4.setTruncated(boolean isTruncated)", "testcase": false, "constructor": false}, {"identifier": "isFragment", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isFragment()", "full_signature": "public boolean isFragment()", "class_method_signature": "IPv4.isFragment()", "testcase": false, "constructor": false}, {"identifier": "setFragment", "parameters": "(boolean isFrag)", "modifiers": "public", "return": "void", "signature": "void setFragment(boolean isFrag)", "full_signature": "public void setFragment(boolean isFrag)", "class_method_signature": "IPv4.setFragment(boolean isFrag)", "testcase": false, "constructor": false}, {"identifier": "setIdentification", "parameters": "(short identification)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setIdentification(short identification)", "full_signature": "public IPv4 setIdentification(short identification)", "class_method_signature": "IPv4.setIdentification(short identification)", "testcase": false, "constructor": false}, {"identifier": "getFlags", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getFlags()", "full_signature": "public byte getFlags()", "class_method_signature": "IPv4.getFlags()", "testcase": false, "constructor": false}, {"identifier": "setFlags", "parameters": "(byte flags)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setFlags(byte flags)", "full_signature": "public IPv4 setFlags(byte flags)", "class_method_signature": "IPv4.setFlags(byte flags)", "testcase": false, "constructor": false}, {"identifier": "getFragmentOffset", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getFragmentOffset()", "full_signature": "public short getFragmentOffset()", "class_method_signature": "IPv4.getFragmentOffset()", "testcase": false, "constructor": false}, {"identifier": "setFragmentOffset", "parameters": "(short fragmentOffset)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setFragmentOffset(short fragmentOffset)", "full_signature": "public IPv4 setFragmentOffset(short fragmentOffset)", "class_method_signature": "IPv4.setFragmentOffset(short fragmentOffset)", "testcase": false, "constructor": false}, {"identifier": "getTtl", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getTtl()", "full_signature": "public byte getTtl()", "class_method_signature": "IPv4.getTtl()", "testcase": false, "constructor": false}, {"identifier": "setTtl", "parameters": "(byte ttl)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setTtl(byte ttl)", "full_signature": "public IPv4 setTtl(byte ttl)", "class_method_signature": "IPv4.setTtl(byte ttl)", "testcase": false, "constructor": false}, {"identifier": "getProtocol", "parameters": "()", "modifiers": "public", "return": "IpProtocol", "signature": "IpProtocol getProtocol()", "full_signature": "public IpProtocol getProtocol()", "class_method_signature": "IPv4.getProtocol()", "testcase": false, "constructor": false}, {"identifier": "setProtocol", "parameters": "(IpProtocol protocol)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setProtocol(IpProtocol protocol)", "full_signature": "public IPv4 setProtocol(IpProtocol protocol)", "class_method_signature": "IPv4.setProtocol(IpProtocol protocol)", "testcase": false, "constructor": false}, {"identifier": "getChecksum", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getChecksum()", "full_signature": "public short getChecksum()", "class_method_signature": "IPv4.getChecksum()", "testcase": false, "constructor": false}, {"identifier": "setChecksum", "parameters": "(short checksum)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setChecksum(short checksum)", "full_signature": "public IPv4 setChecksum(short checksum)", "class_method_signature": "IPv4.setChecksum(short checksum)", "testcase": false, "constructor": false}, {"identifier": "resetChecksum", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void resetChecksum()", "full_signature": "@Override public void resetChecksum()", "class_method_signature": "IPv4.resetChecksum()", "testcase": false, "constructor": false}, {"identifier": "getSourceAddress", "parameters": "()", "modifiers": "public", "return": "IPv4Address", "signature": "IPv4Address getSourceAddress()", "full_signature": "public IPv4Address getSourceAddress()", "class_method_signature": "IPv4.getSourceAddress()", "testcase": false, "constructor": false}, {"identifier": "setSourceAddress", "parameters": "(IPv4Address sourceAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setSourceAddress(IPv4Address sourceAddress)", "full_signature": "public IPv4 setSourceAddress(IPv4Address sourceAddress)", "class_method_signature": "IPv4.setSourceAddress(IPv4Address sourceAddress)", "testcase": false, "constructor": false}, {"identifier": "setSourceAddress", "parameters": "(int sourceAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setSourceAddress(int sourceAddress)", "full_signature": "public IPv4 setSourceAddress(int sourceAddress)", "class_method_signature": "IPv4.setSourceAddress(int sourceAddress)", "testcase": false, "constructor": false}, {"identifier": "setSourceAddress", "parameters": "(String sourceAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setSourceAddress(String sourceAddress)", "full_signature": "public IPv4 setSourceAddress(String sourceAddress)", "class_method_signature": "IPv4.setSourceAddress(String sourceAddress)", "testcase": false, "constructor": false}, {"identifier": "getDestinationAddress", "parameters": "()", "modifiers": "public", "return": "IPv4Address", "signature": "IPv4Address getDestinationAddress()", "full_signature": "public IPv4Address getDestinationAddress()", "class_method_signature": "IPv4.getDestinationAddress()", "testcase": false, "constructor": false}, {"identifier": "setDestinationAddress", "parameters": "(IPv4Address destinationAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDestinationAddress(IPv4Address destinationAddress)", "full_signature": "public IPv4 setDestinationAddress(IPv4Address destinationAddress)", "class_method_signature": "IPv4.setDestinationAddress(IPv4Address destinationAddress)", "testcase": false, "constructor": false}, {"identifier": "setDestinationAddress", "parameters": "(int destinationAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDestinationAddress(int destinationAddress)", "full_signature": "public IPv4 setDestinationAddress(int destinationAddress)", "class_method_signature": "IPv4.setDestinationAddress(int destinationAddress)", "testcase": false, "constructor": false}, {"identifier": "setDestinationAddress", "parameters": "(String destinationAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDestinationAddress(String destinationAddress)", "full_signature": "public IPv4 setDestinationAddress(String destinationAddress)", "class_method_signature": "IPv4.setDestinationAddress(String destinationAddress)", "testcase": false, "constructor": false}, {"identifier": "getOptions", "parameters": "()", "modifiers": "public", "return": "byte[]", "signature": "byte[] getOptions()", "full_signature": "public byte[] getOptions()", "class_method_signature": "IPv4.getOptions()", "testcase": false, "constructor": false}, {"identifier": "setOptions", "parameters": "(byte[] options)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setOptions(byte[] options)", "full_signature": "public IPv4 setOptions(byte[] options)", "class_method_signature": "IPv4.setOptions(byte[] options)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "()", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] serialize()", "full_signature": "@Override public byte[] serialize()", "class_method_signature": "IPv4.serialize()", "testcase": false, "constructor": false}, {"identifier": "deserialize", "parameters": "(byte[] data, int offset, int length)", "modifiers": "@Override public", "return": "IPacket", "signature": "IPacket deserialize(byte[] data, int offset, int length)", "full_signature": "@Override public IPacket deserialize(byte[] data, int offset, int length)", "class_method_signature": "IPv4.deserialize(byte[] data, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "toIPv4Address", "parameters": "(String ipAddress)", "modifiers": "public static", "return": "int", "signature": "int toIPv4Address(String ipAddress)", "full_signature": "public static int toIPv4Address(String ipAddress)", "class_method_signature": "IPv4.toIPv4Address(String ipAddress)", "testcase": false, "constructor": false}, {"identifier": "toIPv4Address", "parameters": "(byte[] ipAddress)", "modifiers": "public static", "return": "int", "signature": "int toIPv4Address(byte[] ipAddress)", "full_signature": "public static int toIPv4Address(byte[] ipAddress)", "class_method_signature": "IPv4.toIPv4Address(byte[] ipAddress)", "testcase": false, "constructor": false}, {"identifier": "fromIPv4Address", "parameters": "(int ipAddress)", "modifiers": "public static", "return": "String", "signature": "String fromIPv4Address(int ipAddress)", "full_signature": "public static String fromIPv4Address(int ipAddress)", "class_method_signature": "IPv4.fromIPv4Address(int ipAddress)", "testcase": false, "constructor": false}, {"identifier": "fromIPv4AddressCollection", "parameters": "(Collection<Integer> ipAddresses)", "modifiers": "public static", "return": "String", "signature": "String fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "full_signature": "public static String fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "class_method_signature": "IPv4.fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "testcase": false, "constructor": false}, {"identifier": "toIPv4AddressBytes", "parameters": "(String ipAddress)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] toIPv4AddressBytes(String ipAddress)", "full_signature": "public static byte[] toIPv4AddressBytes(String ipAddress)", "class_method_signature": "IPv4.toIPv4AddressBytes(String ipAddress)", "testcase": false, "constructor": false}, {"identifier": "toIPv4AddressBytes", "parameters": "(int ipAddress)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] toIPv4AddressBytes(int ipAddress)", "full_signature": "public static byte[] toIPv4AddressBytes(int ipAddress)", "class_method_signature": "IPv4.toIPv4AddressBytes(int ipAddress)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "IPv4.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "IPv4.equals(Object obj)", "testcase": false, "constructor": false}], "file": "src/agents/apps/floodlight/floodlight-1.0/src/main/java/net/floodlightcontroller/packet/IPv4.java"}, "focal_method": {"identifier": "toIPv4Address", "parameters": "(String ipAddress)", "modifiers": "public static", "return": "int", "body": "public static int toIPv4Address(String ipAddress) {\n        if (ipAddress == null)\n            throw new IllegalArgumentException(\"Specified IPv4 address must\" +\n                \"contain 4 sets of numerical digits separated by periods\");\n        String[] octets = ipAddress.split(\"\\\\.\");\n        if (octets.length != 4)\n            throw new IllegalArgumentException(\"Specified IPv4 address must\" +\n                \"contain 4 sets of numerical digits separated by periods\");\n\n        int result = 0;\n        for (int i = 0; i < 4; ++i) {\n            int oct = Integer.valueOf(octets[i]);\n            if (oct > 255 || oct < 0)\n                throw new IllegalArgumentException(\"Octet values in specified\" +\n                        \" IPv4 address must be 0 <= value <= 255\");\n            result |=  oct << ((3-i)*8);\n        }\n        return result;\n    }", "signature": "int toIPv4Address(String ipAddress)", "full_signature": "public static int toIPv4Address(String ipAddress)", "class_method_signature": "IPv4.toIPv4Address(String ipAddress)", "testcase": false, "constructor": false, "invocations": ["split", "valueOf"]}, "repository": {"repo_id": 181421086, "url": "https://github.com/seungsoo-lee/DELTA", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 35, "size": 99244, "license": "licensed"}}