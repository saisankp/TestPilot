{"test_class": {"identifier": "TestStaticELSpecificationProvider", "superclass": "", "interfaces": "", "fields": [{"original_string": "private AgentService agentService;", "modifier": "private", "type": "AgentService", "declarator": "agentService", "var_name": "agentService"}, {"original_string": "private ELSpecificationProvider specificationProvider;", "modifier": "private", "type": "ELSpecificationProvider", "declarator": "specificationProvider", "var_name": "specificationProvider"}], "file": "efm/efm-c2-protocol/efm-c2-protocol-framework/src/test/java/com/cloudera/cem/efm/service/agent/TestStaticELSpecificationProvider.java"}, "test_case": {"identifier": "testGetCppELSpecificationExactVersionExists", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGetCppELSpecificationExactVersionExists() {\n        final String agentClass = \"default\";\n        final AgentManifest defaultManifest = createAgentManifest(\"0.5.0\", \"cpp\");\n\n        when(agentService.getAgentManifests(agentClass)).thenReturn(Collections.singletonList(defaultManifest));\n\n        final Optional<ELSpecification> specification = specificationProvider.getELSpecification(agentClass);\n        assertTrue(specification.isPresent());\n        assertEquals(\"minifi-cpp-0.5.0\", specification.get().getSpecificationKey());\n\n        final Map<String, ELOperation> operations = specification.get().getOperations();\n        assertNotNull(operations);\n        assertEquals(1, operations.size());\n\n        final ELOperation operation = operations.get(\"isNull\");\n        assertNotNull(operation);\n        assertEquals(\"isNull\", operation.getName());\n    }", "signature": "void testGetCppELSpecificationExactVersionExists()", "full_signature": "@Test public void testGetCppELSpecificationExactVersionExists()", "class_method_signature": "TestStaticELSpecificationProvider.testGetCppELSpecificationExactVersionExists()", "testcase": true, "constructor": false, "invocations": ["createAgentManifest", "thenReturn", "when", "getAgentManifests", "singletonList", "getELSpecification", "assertTrue", "isPresent", "assertEquals", "getSpecificationKey", "get", "getOperations", "get", "assertNotNull", "assertEquals", "size", "get", "assertNotNull", "assertEquals", "getName"]}, "focal_class": {"identifier": "StaticELSpecificationProvider", "superclass": "", "interfaces": "implements ELSpecificationProvider", "fields": [{"original_string": "static final Logger LOGGER = LoggerFactory.getLogger(StaticELSpecificationProvider.class);", "modifier": "static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(StaticELSpecificationProvider.class)", "var_name": "LOGGER"}, {"original_string": "static final String MINIFI_CPP_TYPE = \"minifi-cpp\";", "modifier": "static final", "type": "String", "declarator": "MINIFI_CPP_TYPE = \"minifi-cpp\"", "var_name": "MINIFI_CPP_TYPE"}, {"original_string": "static final String MINIFI_JAVA_TYPE = \"minifi-java\";", "modifier": "static final", "type": "String", "declarator": "MINIFI_JAVA_TYPE = \"minifi-java\"", "var_name": "MINIFI_JAVA_TYPE"}, {"original_string": "static final Pattern SPEC_FILENAME_PATTERN = Pattern.compile(\"el-(\" + MINIFI_CPP_TYPE + \"|\" + MINIFI_JAVA_TYPE + \")-(.+)\\\\.json\");", "modifier": "static final", "type": "Pattern", "declarator": "SPEC_FILENAME_PATTERN = Pattern.compile(\"el-(\" + MINIFI_CPP_TYPE + \"|\" + MINIFI_JAVA_TYPE + \")-(.+)\\\\.json\")", "var_name": "SPEC_FILENAME_PATTERN"}, {"original_string": "static final String MINIFI_CPP_EL_BUNDLE_ARTIFACT = \"minifi-expression-language-extensions\";", "modifier": "static final", "type": "String", "declarator": "MINIFI_CPP_EL_BUNDLE_ARTIFACT = \"minifi-expression-language-extensions\"", "var_name": "MINIFI_CPP_EL_BUNDLE_ARTIFACT"}, {"original_string": "private final String specificationsDir;", "modifier": "private final", "type": "String", "declarator": "specificationsDir", "var_name": "specificationsDir"}, {"original_string": "private final AgentService agentService;", "modifier": "private final", "type": "AgentService", "declarator": "agentService", "var_name": "agentService"}, {"original_string": "private final ObjectMapper objectMapper;", "modifier": "private final", "type": "ObjectMapper", "declarator": "objectMapper", "var_name": "objectMapper"}, {"original_string": "private final SortedSet<String> specificationKeys = new TreeSet<>();", "modifier": "private final", "type": "SortedSet<String>", "declarator": "specificationKeys = new TreeSet<>()", "var_name": "specificationKeys"}, {"original_string": "private final Map<String, ELSpecification> specifications = new HashMap<>();", "modifier": "private final", "type": "Map<String, ELSpecification>", "declarator": "specifications = new HashMap<>()", "var_name": "specifications"}], "methods": [{"identifier": "StaticELSpecificationProvider", "parameters": "(final ELSpecificationProperties properties, final AgentService agentService, final ObjectMapper objectMapper)", "modifiers": "@Autowired public", "return": "", "signature": " StaticELSpecificationProvider(final ELSpecificationProperties properties, final AgentService agentService, final ObjectMapper objectMapper)", "full_signature": "@Autowired public  StaticELSpecificationProvider(final ELSpecificationProperties properties, final AgentService agentService, final ObjectMapper objectMapper)", "class_method_signature": "StaticELSpecificationProvider.StaticELSpecificationProvider(final ELSpecificationProperties properties, final AgentService agentService, final ObjectMapper objectMapper)", "testcase": false, "constructor": true}, {"identifier": "loadSpecifications", "parameters": "()", "modifiers": "@PostConstruct public", "return": "void", "signature": "void loadSpecifications()", "full_signature": "@PostConstruct public void loadSpecifications()", "class_method_signature": "StaticELSpecificationProvider.loadSpecifications()", "testcase": false, "constructor": false}, {"identifier": "printWarning", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void printWarning()", "full_signature": "private void printWarning()", "class_method_signature": "StaticELSpecificationProvider.printWarning()", "testcase": false, "constructor": false}, {"identifier": "getELSpecification", "parameters": "(final String agentClass)", "modifiers": "@Override public", "return": "Optional<ELSpecification>", "signature": "Optional<ELSpecification> getELSpecification(final String agentClass)", "full_signature": "@Override public Optional<ELSpecification> getELSpecification(final String agentClass)", "class_method_signature": "StaticELSpecificationProvider.getELSpecification(final String agentClass)", "testcase": false, "constructor": false}, {"identifier": "getCompatibleELSpecification", "parameters": "(final String mappedType)", "modifiers": "private", "return": "Optional<ELSpecification>", "signature": "Optional<ELSpecification> getCompatibleELSpecification(final String mappedType)", "full_signature": "private Optional<ELSpecification> getCompatibleELSpecification(final String mappedType)", "class_method_signature": "StaticELSpecificationProvider.getCompatibleELSpecification(final String mappedType)", "testcase": false, "constructor": false}, {"identifier": "getKey", "parameters": "(String agentType, String version)", "modifiers": "private", "return": "String", "signature": "String getKey(String agentType, String version)", "full_signature": "private String getKey(String agentType, String version)", "class_method_signature": "StaticELSpecificationProvider.getKey(String agentType, String version)", "testcase": false, "constructor": false}], "file": "efm/efm-c2-protocol/efm-c2-protocol-framework/src/main/java/com/cloudera/cem/efm/service/agent/StaticELSpecificationProvider.java"}, "focal_method": {"identifier": "getELSpecification", "parameters": "(final String agentClass)", "modifiers": "@Override public", "return": "Optional<ELSpecification>", "body": "@Override\n    public Optional<ELSpecification> getELSpecification(final String agentClass) {\n        if (StringUtils.isBlank(agentClass)) {\n            throw new IllegalArgumentException(\"AgentClass is required to obtain the EL specification\");\n        }\n\n        final List<AgentManifest> agentManifests = agentService.getAgentManifests(agentClass);\n        if (agentManifests.isEmpty()) {\n            throw new IllegalArgumentException(\"No manifests exists for the given agent class\");\n        }\n\n        final AgentManifest agentManifest = agentManifests.get(0);\n        if (agentManifest.getAgentType() == null) {\n            throw new IllegalArgumentException(\"AgentManifest AgentType is required to obtain the EL specification\");\n        }\n\n        // determine the agent type for the key...\n        String mappedType;\n        final String agentType = agentManifest.getAgentType();\n        if (agentType.equals(MINIFI_JAVA_TYPE) || agentType.equals(\"java\")) {\n            mappedType = MINIFI_JAVA_TYPE;\n        } else if (agentType.equals(MINIFI_CPP_TYPE) || agentType.equals(\"cpp\")) {\n            mappedType = MINIFI_CPP_TYPE;\n        } else {\n            throw new IllegalArgumentException(\"Unexpected agent type '\" + agentType + \"'\");\n        }\n\n\n        // determine the version for the key...\n        String version = null;\n        final BuildInfo buildInfo = agentManifest.getBuildInfo();\n        if (buildInfo != null && buildInfo.getVersion() != null) {\n            final String buildInfoVersion = buildInfo.getVersion();\n            final int snapshotIndex = buildInfoVersion.indexOf(\"-SNAPSHOT\");\n            if (snapshotIndex > 0) {\n                version = buildInfoVersion.substring(0, snapshotIndex);\n            } else {\n                version = buildInfoVersion;\n            }\n        }\n\n        // if the type is CPP, check if the EL bundle is included, and if not then return an empty spec\n        if (mappedType.equals(MINIFI_CPP_TYPE)) {\n            boolean hasELBundle = false;\n            if (agentManifest.getBundles() != null) {\n                for (final Bundle bundle : agentManifest.getBundles()) {\n                    if (MINIFI_CPP_EL_BUNDLE_ARTIFACT.equals(bundle.getArtifact())) {\n                        hasELBundle = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!hasELBundle) {\n                final ELSpecification emptySpec = new ELSpecification();\n                emptySpec.setSpecificationKey(\"missing-el-bundle\");\n                emptySpec.setOperations(Collections.emptyMap());\n                return Optional.of(emptySpec);\n            }\n        }\n\n        // if version is null then we'll attempt to take the first EL spec using just the type, otherwise look for exact version\n        if (version == null) {\n            return getCompatibleELSpecification(mappedType);\n        } else {\n            final String key = getKey(mappedType, version);\n            final ELSpecification exactSpecification = specifications.get(key);\n            if (exactSpecification == null) {\n                LOGGER.warn(\"No EL specification was found for {}, attempting to find compatible specification\", new Object[]{key});\n                return getCompatibleELSpecification(mappedType);\n            } else {\n                return Optional.of(exactSpecification);\n            }\n        }\n    }", "signature": "Optional<ELSpecification> getELSpecification(final String agentClass)", "full_signature": "@Override public Optional<ELSpecification> getELSpecification(final String agentClass)", "class_method_signature": "StaticELSpecificationProvider.getELSpecification(final String agentClass)", "testcase": false, "constructor": false, "invocations": ["isBlank", "getAgentManifests", "isEmpty", "get", "getAgentType", "getAgentType", "equals", "equals", "equals", "equals", "getBuildInfo", "getVersion", "getVersion", "indexOf", "substring", "equals", "getBundles", "getBundles", "equals", "getArtifact", "setSpecificationKey", "setOperations", "emptyMap", "of", "getCompatibleELSpecification", "getKey", "get", "warn", "getCompatibleELSpecification", "of"]}, "repository": {"repo_id": 181071001, "url": "https://github.com/hortonworks/efm", "language": "Java", "is_fork": false, "fork_count": 5, "stargazer_count": 7, "size": 2003, "license": "licensed"}}