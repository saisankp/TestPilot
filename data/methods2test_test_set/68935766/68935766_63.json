{"test_class": {"identifier": "BindParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "Environment environment = spy(new Environment(mock(Messager.class), null, null, null));", "modifier": "", "type": "Environment", "declarator": "environment = spy(new Environment(mock(Messager.class), null, null, null))", "var_name": "environment"}, {"original_string": "BindParser parser = spy(new BindParser(environment, new CommandLexer(new ArgumentLexer(), new LiteralLexer()), mock(Resolver.class), mock(Resolver.class)));", "modifier": "", "type": "BindParser", "declarator": "parser = spy(new BindParser(environment, new CommandLexer(new ArgumentLexer(), new LiteralLexer()), mock(Resolver.class), mock(Resolver.class)))", "var_name": "parser"}, {"original_string": "TypeElement type = mock(TypeElement.class);", "modifier": "", "type": "TypeElement", "declarator": "type = mock(TypeElement.class)", "var_name": "type"}, {"original_string": "ExecutableElement method = when(mock(ExecutableElement.class).accept(any(), any())).thenReturn(type).getMock();", "modifier": "", "type": "ExecutableElement", "declarator": "method = when(mock(ExecutableElement.class).accept(any(), any())).thenReturn(type).getMock()", "var_name": "method"}, {"original_string": "VariableElement variable = mock(VariableElement.class);", "modifier": "", "type": "VariableElement", "declarator": "variable = mock(VariableElement.class)", "var_name": "variable"}, {"original_string": "Identifier token = Identifier.literal(mock(Element.class), \"token\", \"token\", Set.of());", "modifier": "", "type": "Identifier", "declarator": "token = Identifier.literal(mock(Element.class), \"token\", \"token\", Set.of())", "var_name": "token"}, {"original_string": "Identifier child = Identifier.literal(mock(Element.class), \"child\", \"child\", Set.of());", "modifier": "", "type": "Identifier", "declarator": "child = Identifier.literal(mock(Element.class), \"child\", \"child\", Set.of())", "var_name": "child"}, {"original_string": "Identifier grandchild = Identifier.literal(mock(Element.class), \"grandchild\", \"grandchild\", Set.of());", "modifier": "", "type": "Identifier", "declarator": "grandchild = Identifier.literal(mock(Element.class), \"grandchild\", \"grandchild\", Set.of())", "var_name": "grandchild"}, {"original_string": "Identifier bindingChild = Identifier.literal(mock(Element.class), \"child\", \"child\", Set.of());", "modifier": "", "type": "Identifier", "declarator": "bindingChild = Identifier.literal(mock(Element.class), \"child\", \"child\", Set.of())", "var_name": "bindingChild"}, {"original_string": "Identifier bindingGrandchild = Identifier.literal(mock(Element.class), \"grandchild\", \"grandchild\", Set.of());", "modifier": "", "type": "Identifier", "declarator": "bindingGrandchild = Identifier.literal(mock(Element.class), \"grandchild\", \"grandchild\", Set.of())", "var_name": "bindingGrandchild"}], "file": "commons/src/test/java/com/karuslabs/commons/command/aot/parsers/BindParserTest.java"}, "test_case": {"identifier": "match", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n    void match() {\n        doNothing().when(parser).resolve(any(), any());\n        \n        token.add(environment, child).add(environment, grandchild);\n        \n        parser.match(List.of(bindingChild, bindingGrandchild), token);\n        \n        verify(parser).resolve(bindingGrandchild.location, grandchild);\n    }", "signature": "void match()", "full_signature": "@Test void match()", "class_method_signature": "BindParserTest.match()", "testcase": true, "constructor": false, "invocations": ["resolve", "when", "doNothing", "any", "any", "add", "add", "match", "of", "resolve", "verify"]}, "focal_class": {"identifier": "BindParser", "superclass": "extends Parser", "interfaces": "", "fields": [{"original_string": "private final Binder binder;", "modifier": "private final", "type": "Binder", "declarator": "binder", "var_name": "binder"}], "methods": [{"identifier": "BindParser", "parameters": "(Binder binder, Logger logger, Lexer lexer)", "modifiers": "public", "return": "", "signature": " BindParser(Binder binder, Logger logger, Lexer lexer)", "full_signature": "public  BindParser(Binder binder, Logger logger, Lexer lexer)", "class_method_signature": "BindParser.BindParser(Binder binder, Logger logger, Lexer lexer)", "testcase": false, "constructor": true}, {"identifier": "process", "parameters": "(Element element, Map<Identifier, Command> namespace)", "modifiers": "@Override protected", "return": "void", "signature": "void process(Element element, Map<Identifier, Command> namespace)", "full_signature": "@Override protected void process(Element element, Map<Identifier, Command> namespace)", "class_method_signature": "BindParser.process(Element element, Map<Identifier, Command> namespace)", "testcase": false, "constructor": false}, {"identifier": "match", "parameters": "(Member member, Map<Identifier, Command> namespace)", "modifiers": "", "return": "boolean", "signature": "boolean match(Member member, Map<Identifier, Command> namespace)", "full_signature": " boolean match(Member member, Map<Identifier, Command> namespace)", "class_method_signature": "BindParser.match(Member member, Map<Identifier, Command> namespace)", "testcase": false, "constructor": false}, {"identifier": "find", "parameters": "(List<Token> tokens, Member member, Map<Identifier, Command> namespace)", "modifiers": "", "return": "void", "signature": "void find(List<Token> tokens, Member member, Map<Identifier, Command> namespace)", "full_signature": " void find(List<Token> tokens, Member member, Map<Identifier, Command> namespace)", "class_method_signature": "BindParser.find(List<Token> tokens, Member member, Map<Identifier, Command> namespace)", "testcase": false, "constructor": false}], "file": "commons/src/main/java/com/karuslabs/commons/command/aot/parsers/BindParser.java"}, "focal_method": {"identifier": "match", "parameters": "(Member member, Map<Identifier, Command> namespace)", "modifiers": "", "return": "boolean", "body": "boolean match(Member member, Map<Identifier, Command> namespace) {\n        var match = false;\n        for (var entry : namespace.entrySet()) {\n            match(member, entry.getValue().children);\n            if (member.identifier.equals(entry.getKey())) {\n                entry.getValue().members.put(member.site, member);\n                match = true;\n            }\n        }\n        \n        return match;\n    }", "signature": "boolean match(Member member, Map<Identifier, Command> namespace)", "full_signature": " boolean match(Member member, Map<Identifier, Command> namespace)", "class_method_signature": "BindParser.match(Member member, Map<Identifier, Command> namespace)", "testcase": false, "constructor": false, "invocations": ["entrySet", "match", "getValue", "equals", "getKey", "put", "getValue"]}, "repository": {"repo_id": 68935766, "url": "https://github.com/Pante/Chimera", "stars": 13, "created": "9/22/2016 3:36:39 PM +00:00", "updates": "2020-01-27T21:22:29+00:00", "fork": "False", "license": "licensed"}}