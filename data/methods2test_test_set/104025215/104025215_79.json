{"test_class": {"identifier": "ComputableLiveDataTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private TaskExecutor mTaskExecutor;", "modifier": "private", "type": "TaskExecutor", "declarator": "mTaskExecutor", "var_name": "mTaskExecutor"}, {"original_string": "private TestLifecycleOwner mLifecycleOwner;", "modifier": "private", "type": "TestLifecycleOwner", "declarator": "mLifecycleOwner", "var_name": "mLifecycleOwner"}], "file": "lifecycle/extensions/src/test/java/android/arch/lifecycle/ComputableLiveDataTest.java"}, "test_case": {"identifier": "addingObserverShouldTriggerAComputation", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void addingObserverShouldTriggerAComputation() {\n        TestComputable computable = new TestComputable(1);\n        mLifecycleOwner.handleEvent(Lifecycle.Event.ON_CREATE);\n        final AtomicInteger mValue = new AtomicInteger(-1);\n        computable.getLiveData().observe(mLifecycleOwner, new Observer<Integer>() {\n            @Override\n            public void onChanged(@Nullable Integer integer) {\n                //noinspection ConstantConditions\n                mValue.set(integer);\n            }\n        });\n        verify(mTaskExecutor, never()).executeOnDiskIO(any(Runnable.class));\n        assertThat(mValue.get(), is(-1));\n        mLifecycleOwner.handleEvent(Lifecycle.Event.ON_START);\n        verify(mTaskExecutor).executeOnDiskIO(computable.mRefreshRunnable);\n        assertThat(mValue.get(), is(1));\n    }", "signature": "void addingObserverShouldTriggerAComputation()", "full_signature": "@Test public void addingObserverShouldTriggerAComputation()", "class_method_signature": "ComputableLiveDataTest.addingObserverShouldTriggerAComputation()", "testcase": true, "constructor": false, "invocations": ["handleEvent", "observe", "getLiveData", "set", "executeOnDiskIO", "verify", "never", "any", "assertThat", "get", "is", "handleEvent", "executeOnDiskIO", "verify", "assertThat", "get", "is"]}, "focal_class": {"identifier": "ComputableLiveData", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final LiveData<T> mLiveData;", "modifier": "private final", "type": "LiveData<T>", "declarator": "mLiveData", "var_name": "mLiveData"}, {"original_string": "private AtomicBoolean mInvalid = new AtomicBoolean(true);", "modifier": "private", "type": "AtomicBoolean", "declarator": "mInvalid = new AtomicBoolean(true)", "var_name": "mInvalid"}, {"original_string": "private AtomicBoolean mComputing = new AtomicBoolean(false);", "modifier": "private", "type": "AtomicBoolean", "declarator": "mComputing = new AtomicBoolean(false)", "var_name": "mComputing"}, {"original_string": "@VisibleForTesting\n    final Runnable mRefreshRunnable = new Runnable() {\n        @WorkerThread\n        @Override\n        public void run() {\n            boolean computed;\n            do {\n                computed = false;\n                // compute can happen only in 1 thread but no reason to lock others.\n                if (mComputing.compareAndSet(false, true)) {\n                    // as long as it is invalid, keep computing.\n                    try {\n                        T value = null;\n                        while (mInvalid.compareAndSet(true, false)) {\n                            computed = true;\n                            value = compute();\n                        }\n                        if (computed) {\n                            mLiveData.postValue(value);\n                        }\n                    } finally {\n                        // release compute lock\n                        mComputing.set(false);\n                    }\n                }\n                // check invalid after releasing compute lock to avoid the following scenario.\n                // Thread A runs compute()\n                // Thread A checks invalid, it is false\n                // Main thread sets invalid to true\n                // Thread B runs, fails to acquire compute lock and skips\n                // Thread A releases compute lock\n                // We've left invalid in set state. The check below recovers.\n            } while (computed && mInvalid.get());\n        }\n    };", "modifier": "@VisibleForTesting\n    final", "type": "Runnable", "declarator": "mRefreshRunnable = new Runnable() {\n        @WorkerThread\n        @Override\n        public void run() {\n            boolean computed;\n            do {\n                computed = false;\n                // compute can happen only in 1 thread but no reason to lock others.\n                if (mComputing.compareAndSet(false, true)) {\n                    // as long as it is invalid, keep computing.\n                    try {\n                        T value = null;\n                        while (mInvalid.compareAndSet(true, false)) {\n                            computed = true;\n                            value = compute();\n                        }\n                        if (computed) {\n                            mLiveData.postValue(value);\n                        }\n                    } finally {\n                        // release compute lock\n                        mComputing.set(false);\n                    }\n                }\n                // check invalid after releasing compute lock to avoid the following scenario.\n                // Thread A runs compute()\n                // Thread A checks invalid, it is false\n                // Main thread sets invalid to true\n                // Thread B runs, fails to acquire compute lock and skips\n                // Thread A releases compute lock\n                // We've left invalid in set state. The check below recovers.\n            } while (computed && mInvalid.get());\n        }\n    }", "var_name": "mRefreshRunnable"}, {"original_string": "@VisibleForTesting\n    final Runnable mInvalidationRunnable = new Runnable() {\n        @MainThread\n        @Override\n        public void run() {\n            boolean isActive = mLiveData.hasActiveObservers();\n            if (mInvalid.compareAndSet(false, true)) {\n                if (isActive) {\n                    // TODO if we make this class public, we should accept an executor.\n                    AppToolkitTaskExecutor.getInstance().executeOnDiskIO(mRefreshRunnable);\n                }\n            }\n        }\n    };", "modifier": "@VisibleForTesting\n    final", "type": "Runnable", "declarator": "mInvalidationRunnable = new Runnable() {\n        @MainThread\n        @Override\n        public void run() {\n            boolean isActive = mLiveData.hasActiveObservers();\n            if (mInvalid.compareAndSet(false, true)) {\n                if (isActive) {\n                    // TODO if we make this class public, we should accept an executor.\n                    AppToolkitTaskExecutor.getInstance().executeOnDiskIO(mRefreshRunnable);\n                }\n            }\n        }\n    }", "var_name": "mInvalidationRunnable"}], "methods": [{"identifier": "ComputableLiveData", "parameters": "()", "modifiers": "@SuppressWarnings(\"WeakerAccess\") public", "return": "", "signature": " ComputableLiveData()", "full_signature": "@SuppressWarnings(\"WeakerAccess\") public  ComputableLiveData()", "class_method_signature": "ComputableLiveData.ComputableLiveData()", "testcase": false, "constructor": true}, {"identifier": "getLiveData", "parameters": "()", "modifiers": "@SuppressWarnings(\"WeakerAccess\") @NonNull public", "return": "LiveData<T>", "signature": "LiveData<T> getLiveData()", "full_signature": "@SuppressWarnings(\"WeakerAccess\") @NonNull public LiveData<T> getLiveData()", "class_method_signature": "ComputableLiveData.getLiveData()", "testcase": false, "constructor": false}, {"identifier": "invalidate", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void invalidate()", "full_signature": "public void invalidate()", "class_method_signature": "ComputableLiveData.invalidate()", "testcase": false, "constructor": false}, {"identifier": "compute", "parameters": "()", "modifiers": "@SuppressWarnings(\"WeakerAccess\") @WorkerThread protected abstract", "return": "T", "signature": "T compute()", "full_signature": "@SuppressWarnings(\"WeakerAccess\") @WorkerThread protected abstract T compute()", "class_method_signature": "ComputableLiveData.compute()", "testcase": false, "constructor": false}], "file": "lifecycle/extensions/src/main/java/android/arch/lifecycle/ComputableLiveData.java"}, "focal_method": {"identifier": "getLiveData", "parameters": "()", "modifiers": "@SuppressWarnings(\"WeakerAccess\") @NonNull public", "return": "LiveData<T>", "body": "@SuppressWarnings(\"WeakerAccess\")\n    @NonNull\n    public LiveData<T> getLiveData() {\n        return mLiveData;\n    }", "signature": "LiveData<T> getLiveData()", "full_signature": "@SuppressWarnings(\"WeakerAccess\") @NonNull public LiveData<T> getLiveData()", "class_method_signature": "ComputableLiveData.getLiveData()", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 104025215, "url": "https://github.com/Rayduh/support", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 8, "size": 253405, "license": "licensed"}}