{"test_class": {"identifier": "RangeTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static byte[] arrayB;", "modifier": "private static", "type": "byte[]", "declarator": "arrayB", "var_name": "arrayB"}, {"original_string": "private static short[] arrayUS;", "modifier": "private static", "type": "short[]", "declarator": "arrayUS", "var_name": "arrayUS"}, {"original_string": "private static short[] arrayS;", "modifier": "private static", "type": "short[]", "declarator": "arrayS", "var_name": "arrayS"}, {"original_string": "private static int[] arrayI;", "modifier": "private static", "type": "int[]", "declarator": "arrayI", "var_name": "arrayI"}, {"original_string": "private static float[] arrayF;", "modifier": "private static", "type": "float[]", "declarator": "arrayF", "var_name": "arrayF"}, {"original_string": "private static double[] arrayD;", "modifier": "private static", "type": "double[]", "declarator": "arrayD", "var_name": "arrayD"}, {"original_string": "private static long[] arrayL;", "modifier": "private static", "type": "long[]", "declarator": "arrayL", "var_name": "arrayL"}, {"original_string": "private static Byte[] arrayBtest;", "modifier": "private static", "type": "Byte[]", "declarator": "arrayBtest", "var_name": "arrayBtest"}, {"original_string": "private static Short[] arrayStest;", "modifier": "private static", "type": "Short[]", "declarator": "arrayStest", "var_name": "arrayStest"}, {"original_string": "private static Integer[] arrayItest;", "modifier": "private static", "type": "Integer[]", "declarator": "arrayItest", "var_name": "arrayItest"}, {"original_string": "private static Float[] arrayFtest;", "modifier": "private static", "type": "Float[]", "declarator": "arrayFtest", "var_name": "arrayFtest"}, {"original_string": "private static Double[] arrayDtest;", "modifier": "private static", "type": "Double[]", "declarator": "arrayDtest", "var_name": "arrayDtest"}, {"original_string": "private static Range rangeB2bounds;", "modifier": "private static", "type": "Range", "declarator": "rangeB2bounds", "var_name": "rangeB2bounds"}, {"original_string": "private static Range rangeBpoint;", "modifier": "private static", "type": "Range", "declarator": "rangeBpoint", "var_name": "rangeBpoint"}, {"original_string": "private static Range rangeU2bounds;", "modifier": "private static", "type": "Range", "declarator": "rangeU2bounds", "var_name": "rangeU2bounds"}, {"original_string": "private static Range rangeUpoint;", "modifier": "private static", "type": "Range", "declarator": "rangeUpoint", "var_name": "rangeUpoint"}, {"original_string": "private static Range rangeS2bounds;", "modifier": "private static", "type": "Range", "declarator": "rangeS2bounds", "var_name": "rangeS2bounds"}, {"original_string": "private static Range rangeSpoint;", "modifier": "private static", "type": "Range", "declarator": "rangeSpoint", "var_name": "rangeSpoint"}, {"original_string": "private static Range rangeI2bounds;", "modifier": "private static", "type": "Range", "declarator": "rangeI2bounds", "var_name": "rangeI2bounds"}, {"original_string": "private static Range rangeIpoint;", "modifier": "private static", "type": "Range", "declarator": "rangeIpoint", "var_name": "rangeIpoint"}, {"original_string": "private static Range rangeF2bounds;", "modifier": "private static", "type": "Range", "declarator": "rangeF2bounds", "var_name": "rangeF2bounds"}, {"original_string": "private static Range rangeFpoint;", "modifier": "private static", "type": "Range", "declarator": "rangeFpoint", "var_name": "rangeFpoint"}, {"original_string": "private static Range rangeD2bounds;", "modifier": "private static", "type": "Range", "declarator": "rangeD2bounds", "var_name": "rangeD2bounds"}, {"original_string": "private static Range rangeDpoint;", "modifier": "private static", "type": "Range", "declarator": "rangeDpoint", "var_name": "rangeDpoint"}, {"original_string": "private static Range rangeL2bounds;", "modifier": "private static", "type": "Range", "declarator": "rangeL2bounds", "var_name": "rangeL2bounds"}, {"original_string": "private static Range rangeLpoint;", "modifier": "private static", "type": "Range", "declarator": "rangeLpoint", "var_name": "rangeLpoint"}], "file": "modules/unsupported/process-raster/src/test/java/org/geotools/processing/jai/nodata/RangeTest.java"}, "test_case": {"identifier": "testRange", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRange() {\n        for (int i = 0; i < arrayB.length; i++) {\n            boolean check2pointByte = rangeB2bounds.contains(arrayB[i]);\n            boolean check1pointByte = rangeBpoint.contains(arrayB[i]);\n            boolean check2pointUshort = rangeU2bounds.contains(arrayUS[i]);\n            boolean check1pointUshort = rangeUpoint.contains(arrayUS[i]);\n            boolean check2pointShort = rangeS2bounds.contains(arrayS[i]);\n            boolean check1pointShort = rangeSpoint.contains(arrayS[i]);\n            boolean check2pointInt = rangeI2bounds.contains(arrayI[i]);\n            boolean check1pointInt = rangeIpoint.contains(arrayI[i]);\n            boolean check2pointFloat = rangeF2bounds.contains(arrayF[i]);\n            boolean check1pointFloat = rangeFpoint.contains(arrayF[i]);\n            boolean check2pointDouble = rangeD2bounds.contains(arrayD[i]);\n            boolean check1pointDouble = rangeDpoint.contains(arrayD[i]);\n            boolean check2pointLong = rangeL2bounds.contains(arrayL[i]);\n            boolean check1pointLong = rangeLpoint.contains(arrayL[i]);\n\n            if (i == 2) {\n                assertTrue(check1pointByte);\n                assertTrue(check2pointByte);\n                assertTrue(check1pointUshort);\n                assertTrue(check2pointUshort);\n                assertTrue(check1pointShort);\n                assertTrue(check2pointShort);\n                assertTrue(check1pointInt);\n                assertTrue(check2pointInt);\n                assertTrue(check1pointFloat);\n                assertTrue(check2pointFloat);\n                assertTrue(check1pointDouble);\n                assertTrue(check2pointDouble);\n                assertTrue(check1pointLong);\n                assertTrue(check2pointLong);\n            } else if (i == 3) {\n                assertFalse(check1pointByte);\n                assertTrue(check2pointByte);\n                assertFalse(check1pointUshort);\n                assertTrue(check2pointUshort);\n                assertFalse(check1pointShort);\n                assertTrue(check2pointShort);\n                assertFalse(check1pointInt);\n                assertTrue(check2pointInt);\n                assertFalse(check1pointFloat);\n                assertTrue(check2pointFloat);\n                assertFalse(check1pointDouble);\n                assertTrue(check2pointDouble);\n                assertFalse(check1pointLong);\n                assertTrue(check2pointLong);\n            } else {\n                assertFalse(check1pointByte);\n                assertFalse(check2pointByte);\n                assertFalse(check1pointUshort);\n                assertFalse(check2pointUshort);\n                assertFalse(check1pointShort);\n                assertFalse(check2pointShort);\n                assertFalse(check1pointInt);\n                assertFalse(check2pointInt);\n                assertFalse(check1pointFloat);\n                assertFalse(check2pointFloat);\n                assertFalse(check1pointDouble);\n                assertFalse(check2pointDouble);\n                assertFalse(check1pointLong);\n                assertFalse(check2pointLong);\n            }\n        }\n    }", "signature": "void testRange()", "full_signature": "@Test public void testRange()", "class_method_signature": "RangeTest.testRange()", "testcase": true, "constructor": false, "invocations": ["contains", "contains", "contains", "contains", "contains", "contains", "contains", "contains", "contains", "contains", "contains", "contains", "contains", "contains", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertFalse", "assertTrue", "assertFalse", "assertTrue", "assertFalse", "assertTrue", "assertFalse", "assertTrue", "assertFalse", "assertTrue", "assertFalse", "assertTrue", "assertFalse", "assertTrue", "assertFalse", "assertFalse", "assertFalse", "assertFalse", "assertFalse", "assertFalse", "assertFalse", "assertFalse", "assertFalse", "assertFalse", "assertFalse", "assertFalse", "assertFalse", "assertFalse"]}, "focal_class": {"identifier": "Range", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "contains", "parameters": "(byte value)", "modifiers": "public", "return": "boolean", "signature": "boolean contains(byte value)", "full_signature": "public boolean contains(byte value)", "class_method_signature": "Range.contains(byte value)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(short value)", "modifiers": "public", "return": "boolean", "signature": "boolean contains(short value)", "full_signature": "public boolean contains(short value)", "class_method_signature": "Range.contains(short value)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(int value)", "modifiers": "public", "return": "boolean", "signature": "boolean contains(int value)", "full_signature": "public boolean contains(int value)", "class_method_signature": "Range.contains(int value)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(float value)", "modifiers": "public", "return": "boolean", "signature": "boolean contains(float value)", "full_signature": "public boolean contains(float value)", "class_method_signature": "Range.contains(float value)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(double value)", "modifiers": "public", "return": "boolean", "signature": "boolean contains(double value)", "full_signature": "public boolean contains(double value)", "class_method_signature": "Range.contains(double value)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(long value)", "modifiers": "public", "return": "boolean", "signature": "boolean contains(long value)", "full_signature": "public boolean contains(long value)", "class_method_signature": "Range.contains(long value)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(T value)", "modifiers": "public", "return": "boolean", "signature": "boolean contains(T value)", "full_signature": "public boolean contains(T value)", "class_method_signature": "Range.contains(T value)", "testcase": false, "constructor": false}, {"identifier": "getDataType", "parameters": "()", "modifiers": "public abstract", "return": "DataType", "signature": "DataType getDataType()", "full_signature": "public abstract DataType getDataType()", "class_method_signature": "Range.getDataType()", "testcase": false, "constructor": false}, {"identifier": "isPoint", "parameters": "()", "modifiers": "public abstract", "return": "boolean", "signature": "boolean isPoint()", "full_signature": "public abstract boolean isPoint()", "class_method_signature": "Range.isPoint()", "testcase": false, "constructor": false}, {"identifier": "getMax", "parameters": "()", "modifiers": "public abstract", "return": "Number", "signature": "Number getMax()", "full_signature": "public abstract Number getMax()", "class_method_signature": "Range.getMax()", "testcase": false, "constructor": false}, {"identifier": "getMin", "parameters": "()", "modifiers": "public abstract", "return": "Number", "signature": "Number getMin()", "full_signature": "public abstract Number getMin()", "class_method_signature": "Range.getMin()", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-raster/src/main/java/org/geotools/processing/jai/nodata/Range.java"}, "focal_method": {"identifier": "contains", "parameters": "(byte value)", "modifiers": "public", "return": "boolean", "body": "public boolean contains(byte value) {\n        throw new UnsupportedOperationException(\"Wrong data type\");\n    }", "signature": "boolean contains(byte value)", "full_signature": "public boolean contains(byte value)", "class_method_signature": "Range.contains(byte value)", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}