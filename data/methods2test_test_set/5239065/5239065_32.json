{"test_class": {"identifier": "ConcurrentTreeTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Pattern delimiter = Pattern.compile(\"/\");", "modifier": "private final", "type": "Pattern", "declarator": "delimiter = Pattern.compile(\"/\")", "var_name": "delimiter"}], "file": "exposure-engine/common/src/test/java/com/alu/e3/common/util/ConcurrentTreeTest.java"}, "test_case": {"identifier": "testRemove", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testRemove() {\n\t\tConcurrentTree<String, String> tree = setupTree();\n\t\t\n\t\tassertEquals(tree.remove(delimiter.split(\"a/b\")), \"a/b\");\n\t\tassertNull(tree.get(delimiter.split(\"a/b\")));\n\t\tassertNotNull(tree.get(delimiter.split(\"a/b/c/d/e/f\")));\n\t\tassertNotNull(tree.get(delimiter.split(\"a/a\")));\n\t\t\n\t\tassertEquals(tree.remove(delimiter.split(\"a/b/c/d/e/f\")), \"a/b/c/d/e/f\");\n\t\tassertNull(tree.remove(delimiter.split(\"a/b/c/d/e/f\")));\n\t\tassertNull(tree.remove(delimiter.split(\"a/b/c/d/e\")));\n\t\tassertNotNull(tree.get(delimiter.split(\"a/b/c/d\")));\n\t\t\n\t\tassertNull(tree.remove(delimiter.split(\"/b/b/c/d/e/f\")));\n\t\tassertNull(tree.remove(delimiter.split(\"b/b/c//d/e/f\")));\n\t\tassertNull(tree.remove(delimiter.split(\"b/b/c/d/e/f/ \")));\n\t\tassertNotNull(tree.get(delimiter.split(\"b/b/c/d/e/f\")));\n\t\t\n\t\tassertNull(tree.remove(delimiter.split(\"b/b/c/d/e\")));\n\t\tassertNotNull(tree.get(delimiter.split(\"b/b/c/d/e/f\")));\n\t\tassertNotNull(tree.get(delimiter.split(\"b/b/c/d\")));\n\t}", "signature": "void testRemove()", "full_signature": "@Test public void testRemove()", "class_method_signature": "ConcurrentTreeTest.testRemove()", "testcase": true, "constructor": false, "invocations": ["setupTree", "assertEquals", "remove", "split", "assertNull", "get", "split", "assertNotNull", "get", "split", "assertNotNull", "get", "split", "assertEquals", "remove", "split", "assertNull", "remove", "split", "assertNull", "remove", "split", "assertNotNull", "get", "split", "assertNull", "remove", "split", "assertNull", "remove", "split", "assertNull", "remove", "split", "assertNotNull", "get", "split", "assertNull", "remove", "split", "assertNotNull", "get", "split", "assertNotNull", "get", "split"]}, "focal_class": {"identifier": "ConcurrentTree", "superclass": "extends ConcurrentTreeNode<K, V>", "interfaces": "", "fields": [], "methods": [{"identifier": "add", "parameters": "(final K[] path, final V value)", "modifiers": "public synchronized", "return": "void", "signature": "void add(final K[] path, final V value)", "full_signature": "public synchronized void add(final K[] path, final V value)", "class_method_signature": "ConcurrentTree.add(final K[] path, final V value)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(final K[] path)", "modifiers": "public synchronized", "return": "V", "signature": "V remove(final K[] path)", "full_signature": "public synchronized V remove(final K[] path)", "class_method_signature": "ConcurrentTree.remove(final K[] path)", "testcase": false, "constructor": false}, {"identifier": "getNode", "parameters": "(final K[] path)", "modifiers": "protected", "return": "ConcurrentTreeNode<K, V>", "signature": "ConcurrentTreeNode<K, V> getNode(final K[] path)", "full_signature": "protected ConcurrentTreeNode<K, V> getNode(final K[] path)", "class_method_signature": "ConcurrentTree.getNode(final K[] path)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(final K[] path)", "modifiers": "public", "return": "V", "signature": "V get(final K[] path)", "full_signature": "public V get(final K[] path)", "class_method_signature": "ConcurrentTree.get(final K[] path)", "testcase": false, "constructor": false}, {"identifier": "getMatches", "parameters": "(final K[] path)", "modifiers": "public", "return": "List<V>", "signature": "List<V> getMatches(final K[] path)", "full_signature": "public List<V> getMatches(final K[] path)", "class_method_signature": "ConcurrentTree.getMatches(final K[] path)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "ConcurrentTree.toString()", "testcase": false, "constructor": false}], "file": "exposure-engine/common/src/main/java/com/alu/e3/common/util/ConcurrentTree.java"}, "focal_method": {"identifier": "remove", "parameters": "(final K[] path)", "modifiers": "public synchronized", "return": "V", "body": "public synchronized V remove(final K[] path) {\n\t\tConcurrentTreeNode<K, V> node = getNode(path);\n\t\tif (node == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal V value = node.getValue();\n\t\tnode.setValue(null);\n\n\t\t// Remove the nodes as long as they contain nor sub-nodes neither\n\t\t// value, and they have parent\n\t\tConcurrentTreeNode<K, V> parent;\n\t\twhile (node.getChildren().isEmpty() && (node.getValue() == null)\n\t\t\t\t&& ((parent = node.getParent()) != null)) {\n\t\t\tparent.removeChild(node.getKey());\n\t\t\tnode = parent;\n\t\t}\n\n\t\treturn value;\n\t}", "signature": "V remove(final K[] path)", "full_signature": "public synchronized V remove(final K[] path)", "class_method_signature": "ConcurrentTree.remove(final K[] path)", "testcase": false, "constructor": false, "invocations": ["getNode", "getValue", "setValue", "isEmpty", "getChildren", "getValue", "getParent", "removeChild", "getKey"]}, "repository": {"repo_id": 5239065, "url": "https://github.com/apigrove/apigrove", "language": "Java", "is_fork": false, "fork_count": 33, "stargazer_count": 118, "size": 215144, "license": "licensed"}}