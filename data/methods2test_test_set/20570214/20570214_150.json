{"test_class": {"identifier": "KeysDownloaderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final long INITIAL_CURRENT_TIME_IN_MILLIS = 1000;", "modifier": "private static final", "type": "long", "declarator": "INITIAL_CURRENT_TIME_IN_MILLIS = 1000", "var_name": "INITIAL_CURRENT_TIME_IN_MILLIS"}, {"original_string": "private CountDownLatch backgroundFetchFinishedLatch;", "modifier": "private", "type": "CountDownLatch", "declarator": "backgroundFetchFinishedLatch", "var_name": "backgroundFetchFinishedLatch"}, {"original_string": "private CountDownLatch delayHttpResponseLatch;", "modifier": "private", "type": "CountDownLatch", "declarator": "delayHttpResponseLatch", "var_name": "delayHttpResponseLatch"}, {"original_string": "private ExecutorService executor;", "modifier": "private", "type": "ExecutorService", "declarator": "executor", "var_name": "executor"}, {"original_string": "private HttpResponseBuilder httpResponseBuilder;", "modifier": "private", "type": "HttpResponseBuilder", "declarator": "httpResponseBuilder", "var_name": "httpResponseBuilder"}, {"original_string": "private AtomicInteger backgroundFetchStartedCount;", "modifier": "private", "type": "AtomicInteger", "declarator": "backgroundFetchStartedCount", "var_name": "backgroundFetchStartedCount"}, {"original_string": "private AtomicInteger httpTransportGetCount;", "modifier": "private", "type": "AtomicInteger", "declarator": "httpTransportGetCount", "var_name": "httpTransportGetCount"}, {"original_string": "private boolean executorIsAcceptingRunnables;", "modifier": "private", "type": "boolean", "declarator": "executorIsAcceptingRunnables", "var_name": "executorIsAcceptingRunnables"}, {"original_string": "private long currentTimeInMillis;", "modifier": "private", "type": "long", "declarator": "currentTimeInMillis", "var_name": "currentTimeInMillis"}], "file": "java_src/src/test/java/com/google/crypto/tink/util/KeysDownloaderTest.java"}, "test_case": {"identifier": "shouldFetchOnlyOnceWhenMultipleThreadsTryToGetKeys", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void shouldFetchOnlyOnceWhenMultipleThreadsTryToGetKeys() throws Exception {\n    final KeysDownloader instance = newInstanceForTests();\n    httpResponseBuilder = new HttpResponseBuilder().setContent(\"keys\");\n    List<FutureTask<String>> tasks = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      tasks.add(\n          new FutureTask<String>(\n              new Callable<String>() {\n                @Override\n                public String call() throws Exception {\n                  return instance.download();\n                }\n              }));\n    }\n\n    // Force the HTTP responses to be delayed until the latch goes down to 0.\n    delayHttpResponseLatch = new CountDownLatch(1);\n    // Execute the all fetches in parallel.\n    for (FutureTask<String> task : tasks) {\n      executor.execute(task);\n    }\n    // Releasing the response.\n    delayHttpResponseLatch.countDown();\n\n    for (FutureTask<String> task : tasks) {\n      assertEquals(\"keys\", task.get(5, TimeUnit.SECONDS));\n    }\n    // Should only have hit the network once.\n    assertEquals(1, httpTransportGetCount.get());\n  }", "signature": "void shouldFetchOnlyOnceWhenMultipleThreadsTryToGetKeys()", "full_signature": "@Test public void shouldFetchOnlyOnceWhenMultipleThreadsTryToGetKeys()", "class_method_signature": "KeysDownloaderTest.shouldFetchOnlyOnceWhenMultipleThreadsTryToGetKeys()", "testcase": true, "constructor": false, "invocations": ["newInstanceForTests", "setContent", "add", "download", "execute", "countDown", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "KeysDownloader", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Charset UTF_8 = Charset.forName(\"UTF-8\");", "modifier": "private static final", "type": "Charset", "declarator": "UTF_8 = Charset.forName(\"UTF-8\")", "var_name": "UTF_8"}, {"original_string": "private static final NetHttpTransport DEFAULT_HTTP_TRANSPORT =\n      new NetHttpTransport.Builder().build();", "modifier": "private static final", "type": "NetHttpTransport", "declarator": "DEFAULT_HTTP_TRANSPORT =\n      new NetHttpTransport.Builder().build()", "var_name": "DEFAULT_HTTP_TRANSPORT"}, {"original_string": "private static final Executor DEFAULT_BACKGROUND_EXECUTOR = Executors.newCachedThreadPool();", "modifier": "private static final", "type": "Executor", "declarator": "DEFAULT_BACKGROUND_EXECUTOR = Executors.newCachedThreadPool()", "var_name": "DEFAULT_BACKGROUND_EXECUTOR"}, {"original_string": "private static final Pattern MAX_AGE_PATTERN = Pattern.compile(\"\\\\s*max-age\\\\s*=\\\\s*(\\\\d+)\\\\s*\");", "modifier": "private static final", "type": "Pattern", "declarator": "MAX_AGE_PATTERN = Pattern.compile(\"\\\\s*max-age\\\\s*=\\\\s*(\\\\d+)\\\\s*\")", "var_name": "MAX_AGE_PATTERN"}, {"original_string": "private final Executor backgroundExecutor;", "modifier": "private final", "type": "Executor", "declarator": "backgroundExecutor", "var_name": "backgroundExecutor"}, {"original_string": "private final HttpTransport httpTransport;", "modifier": "private final", "type": "HttpTransport", "declarator": "httpTransport", "var_name": "httpTransport"}, {"original_string": "private final Object fetchDataLock;", "modifier": "private final", "type": "Object", "declarator": "fetchDataLock", "var_name": "fetchDataLock"}, {"original_string": "private final Object instanceStateLock;", "modifier": "private final", "type": "Object", "declarator": "instanceStateLock", "var_name": "instanceStateLock"}, {"original_string": "private final String url;", "modifier": "private final", "type": "String", "declarator": "url", "var_name": "url"}, {"original_string": "@GuardedBy(\"instanceStateLock\")\n  private Runnable pendingRefreshRunnable;", "modifier": "@GuardedBy(\"instanceStateLock\")\n  private", "type": "Runnable", "declarator": "pendingRefreshRunnable", "var_name": "pendingRefreshRunnable"}, {"original_string": "@GuardedBy(\"instanceStateLock\")\n  private String cachedData;", "modifier": "@GuardedBy(\"instanceStateLock\")\n  private", "type": "String", "declarator": "cachedData", "var_name": "cachedData"}, {"original_string": "@GuardedBy(\"instanceStateLock\")\n  private long cachedTimeInMillis;", "modifier": "@GuardedBy(\"instanceStateLock\")\n  private", "type": "long", "declarator": "cachedTimeInMillis", "var_name": "cachedTimeInMillis"}, {"original_string": "@GuardedBy(\"instanceStateLock\")\n  private long cacheExpirationDurationInMillis;", "modifier": "@GuardedBy(\"instanceStateLock\")\n  private", "type": "long", "declarator": "cacheExpirationDurationInMillis", "var_name": "cacheExpirationDurationInMillis"}], "methods": [{"identifier": "KeysDownloader", "parameters": "(Executor backgroundExecutor, HttpTransport httpTransport, String url)", "modifiers": "public", "return": "", "signature": " KeysDownloader(Executor backgroundExecutor, HttpTransport httpTransport, String url)", "full_signature": "public  KeysDownloader(Executor backgroundExecutor, HttpTransport httpTransport, String url)", "class_method_signature": "KeysDownloader.KeysDownloader(Executor backgroundExecutor, HttpTransport httpTransport, String url)", "testcase": false, "constructor": true}, {"identifier": "download", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String download()", "full_signature": "public String download()", "class_method_signature": "KeysDownloader.download()", "testcase": false, "constructor": false}, {"identifier": "getHttpTransport", "parameters": "()", "modifiers": "public", "return": "HttpTransport", "signature": "HttpTransport getHttpTransport()", "full_signature": "public HttpTransport getHttpTransport()", "class_method_signature": "KeysDownloader.getHttpTransport()", "testcase": false, "constructor": false}, {"identifier": "getUrl", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getUrl()", "full_signature": "public String getUrl()", "class_method_signature": "KeysDownloader.getUrl()", "testcase": false, "constructor": false}, {"identifier": "hasNonExpiredDataCached", "parameters": "()", "modifiers": "@GuardedBy(\"instanceStateLock\") private", "return": "boolean", "signature": "boolean hasNonExpiredDataCached()", "full_signature": "@GuardedBy(\"instanceStateLock\") private boolean hasNonExpiredDataCached()", "class_method_signature": "KeysDownloader.hasNonExpiredDataCached()", "testcase": false, "constructor": false}, {"identifier": "shouldProactivelyRefreshDataInBackground", "parameters": "()", "modifiers": "@GuardedBy(\"instanceStateLock\") private", "return": "boolean", "signature": "boolean shouldProactivelyRefreshDataInBackground()", "full_signature": "@GuardedBy(\"instanceStateLock\") private boolean shouldProactivelyRefreshDataInBackground()", "class_method_signature": "KeysDownloader.shouldProactivelyRefreshDataInBackground()", "testcase": false, "constructor": false}, {"identifier": "getCurrentTimeInMillis", "parameters": "()", "modifiers": "", "return": "long", "signature": "long getCurrentTimeInMillis()", "full_signature": " long getCurrentTimeInMillis()", "class_method_signature": "KeysDownloader.getCurrentTimeInMillis()", "testcase": false, "constructor": false}, {"identifier": "fetchAndCacheData", "parameters": "()", "modifiers": "@GuardedBy(\"fetchDataLock\") private", "return": "String", "signature": "String fetchAndCacheData()", "full_signature": "@GuardedBy(\"fetchDataLock\") private String fetchAndCacheData()", "class_method_signature": "KeysDownloader.fetchAndCacheData()", "testcase": false, "constructor": false}, {"identifier": "readerToString", "parameters": "(Reader reader)", "modifiers": "private static", "return": "String", "signature": "String readerToString(Reader reader)", "full_signature": "private static String readerToString(Reader reader)", "class_method_signature": "KeysDownloader.readerToString(Reader reader)", "testcase": false, "constructor": false}, {"identifier": "getExpirationDurationInSeconds", "parameters": "(HttpHeaders httpHeaders)", "modifiers": "", "return": "long", "signature": "long getExpirationDurationInSeconds(HttpHeaders httpHeaders)", "full_signature": " long getExpirationDurationInSeconds(HttpHeaders httpHeaders)", "class_method_signature": "KeysDownloader.getExpirationDurationInSeconds(HttpHeaders httpHeaders)", "testcase": false, "constructor": false}, {"identifier": "refreshInBackground", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void refreshInBackground()", "full_signature": "public void refreshInBackground()", "class_method_signature": "KeysDownloader.refreshInBackground()", "testcase": false, "constructor": false}, {"identifier": "newRefreshRunnable", "parameters": "()", "modifiers": "private", "return": "Runnable", "signature": "Runnable newRefreshRunnable()", "full_signature": "private Runnable newRefreshRunnable()", "class_method_signature": "KeysDownloader.newRefreshRunnable()", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(String url)", "modifiers": "private static", "return": "void", "signature": "void validate(String url)", "full_signature": "private static void validate(String url)", "class_method_signature": "KeysDownloader.validate(String url)", "testcase": false, "constructor": false}], "file": "java_src/src/main/java/com/google/crypto/tink/util/KeysDownloader.java"}, "focal_method": {"identifier": "download", "parameters": "()", "modifiers": "public", "return": "String", "body": "public String download() throws IOException {\n    synchronized (instanceStateLock) {\n      // Checking and using the cache if required.\n      if (hasNonExpiredDataCached()) {\n        // Proactively triggering a refresh if we are close to the cache expiration.\n        if (shouldProactivelyRefreshDataInBackground()) {\n          refreshInBackground();\n        }\n        return cachedData;\n      }\n    }\n\n    // Acquiring the fetch lock so we don't have multiple threads trying to fetch from the\n    // server at the same time.\n    synchronized (fetchDataLock) {\n      // It is possible that some other thread performed the fetch already and we don't need\n      // to fetch anymore, so double checking a fetch is still required.\n      synchronized (instanceStateLock) {\n        if (hasNonExpiredDataCached()) {\n          return cachedData;\n        }\n      }\n      // No other thread fetched, so it is up to this thread to fetch.\n      return fetchAndCacheData();\n    }\n  }", "signature": "String download()", "full_signature": "public String download()", "class_method_signature": "KeysDownloader.download()", "testcase": false, "constructor": false, "invocations": ["hasNonExpiredDataCached", "shouldProactivelyRefreshDataInBackground", "refreshInBackground", "hasNonExpiredDataCached", "fetchAndCacheData"]}, "repository": {"repo_id": 20570214, "url": "https://github.com/google/tink", "stars": 8884, "created": "6/6/2014 4:21:09 PM +00:00", "updates": "2020-01-27T11:52:16+00:00", "fork": "False", "license": "licensed"}}