{"test_class": {"identifier": "ImageRotationStageTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int SOURCE_WIDTH = 640;", "modifier": "public static final", "type": "int", "declarator": "SOURCE_WIDTH = 640", "var_name": "SOURCE_WIDTH"}, {"original_string": "public static final int SOURCE_ROW_SIZE = SOURCE_WIDTH * 3;", "modifier": "public static final", "type": "int", "declarator": "SOURCE_ROW_SIZE = SOURCE_WIDTH * 3", "var_name": "SOURCE_ROW_SIZE"}, {"original_string": "public static final int SOURCE_HEIGHT = 480;", "modifier": "public static final", "type": "int", "declarator": "SOURCE_HEIGHT = 480", "var_name": "SOURCE_HEIGHT"}, {"original_string": "public static final int ROTATION_WIDTH = 320;", "modifier": "public static final", "type": "int", "declarator": "ROTATION_WIDTH = 320", "var_name": "ROTATION_WIDTH"}, {"original_string": "public static final int ROTATION_ROW_SIZE = ROTATION_WIDTH * 3;", "modifier": "public static final", "type": "int", "declarator": "ROTATION_ROW_SIZE = ROTATION_WIDTH * 3", "var_name": "ROTATION_ROW_SIZE"}, {"original_string": "public static final int ROTATION_HEIGHT = 240;", "modifier": "public static final", "type": "int", "declarator": "ROTATION_HEIGHT = 240", "var_name": "ROTATION_HEIGHT"}, {"original_string": "public static final long[] ROTATION_ANGLE = {180, 1};", "modifier": "public static final", "type": "long[]", "declarator": "ROTATION_ANGLE = {180, 1}", "var_name": "ROTATION_ANGLE"}, {"original_string": "public GraphManager gm;", "modifier": "public", "type": "GraphManager", "declarator": "gm", "var_name": "gm"}, {"original_string": "public Pipe<ImageSchema> imageInputPipe;", "modifier": "public", "type": "Pipe<ImageSchema>", "declarator": "imageInputPipe", "var_name": "imageInputPipe"}, {"original_string": "public Pipe<ImageRotationSchema> imageRotationInputPipe;", "modifier": "public", "type": "Pipe<ImageRotationSchema>", "declarator": "imageRotationInputPipe", "var_name": "imageRotationInputPipe"}, {"original_string": "public Pipe<ImageSchema> rotationOutputPipe;", "modifier": "public", "type": "Pipe<ImageSchema>", "declarator": "rotationOutputPipe", "var_name": "rotationOutputPipe"}, {"original_string": "public RotationPipeReaderState rotationPipeReaderState;", "modifier": "public", "type": "RotationPipeReaderState", "declarator": "rotationPipeReaderState", "var_name": "rotationPipeReaderState"}], "file": "foglight/src/test/java/com/ociweb/pronghorn/image/ImageRotationStageTest.java"}, "test_case": {"identifier": "shouldDownscaleImagesTest", "parameters": "()", "modifiers": "@Test @Ignore public", "return": "void", "body": "@Test\n    @Ignore\n    public void shouldDownscaleImagesTest() {\n\n        int iterations = 5;\n        int j = iterations;\n        while (--j>=0) {\n\n            setup();\n\n            // Create test scheduler.\n            NonThreadScheduler scheduler = new NonThreadScheduler(gm);\n            scheduler.startup();\n\n            // Put a rotation request on the pipe.\n            if (PipeWriter.tryWriteFragment(imageRotationInputPipe, ImageRotationSchema.MSG_ROTATIONREQUEST_1)) {\n                PipeWriter.writeLong(imageRotationInputPipe, ImageRotationSchema.MSG_ROTATIONREQUEST_1_FIELD_NUMERATOR_101, ROTATION_ANGLE[0]);\n                PipeWriter.writeLong(imageRotationInputPipe, ImageRotationSchema.MSG_ROTATIONREQUEST_1_FIELD_DENOMINATOR_201, ROTATION_ANGLE[1]);\n                PipeWriter.writeLong(imageRotationInputPipe, ImageRotationSchema.MSG_ROTATIONREQUEST_1_FIELD_TIMESTAMP_301,Long.MAX_VALUE);\n                PipeWriter.publishWrites(imageRotationInputPipe);\n            }\n\n            // Run until we write a frame.\n            while (rotationPipeReaderState.framesProcessed <= 0) {\n\n                // Run scheduler pipe.\n                scheduler.run();\n\n                // Read from pipe.\n                readFromRotationPipe(rotationOutputPipe, rotationPipeReaderState, LinuxImageCaptureStage.OUTPUT_ENCODING);\n            }\n\n            // Verify the frame is valid.\n            try {\n                Path filePath = Paths.get(\"src\", \"test\", \"images\", \"cat1-320-240.rotated\");\n                byte[] fileBytes = Files.readAllBytes(filePath);\n                Assert.assertTrue(Arrays.equals(fileBytes, rotationPipeReaderState.currentFrame));\n            } catch (IOException e) {\n                Assert.fail(e.getMessage());\n            }\n        }\n    }", "signature": "void shouldDownscaleImagesTest()", "full_signature": "@Test @Ignore public void shouldDownscaleImagesTest()", "class_method_signature": "ImageRotationStageTest.shouldDownscaleImagesTest()", "testcase": true, "constructor": false, "invocations": ["setup", "startup", "tryWriteFragment", "writeLong", "writeLong", "writeLong", "publishWrites", "run", "readFromRotationPipe", "get", "readAllBytes", "assertTrue", "equals", "fail", "getMessage"]}, "focal_class": {"identifier": "ImageRotationStage", "superclass": "extends PronghornStage", "interfaces": "", "fields": [{"original_string": "private static final int NONE = -1;", "modifier": "private static final", "type": "int", "declarator": "NONE = -1", "var_name": "NONE"}, {"original_string": "private static final int FRAME_BUFFERED = -2;", "modifier": "private static final", "type": "int", "declarator": "FRAME_BUFFERED = -2", "var_name": "FRAME_BUFFERED"}, {"original_string": "private final Pipe<ImageSchema> imagePipeIn;", "modifier": "private final", "type": "Pipe<ImageSchema>", "declarator": "imagePipeIn", "var_name": "imagePipeIn"}, {"original_string": "private final Pipe<ImageRotationSchema> imageRotationPipeIn;", "modifier": "private final", "type": "Pipe<ImageRotationSchema>", "declarator": "imageRotationPipeIn", "var_name": "imageRotationPipeIn"}, {"original_string": "private final Pipe<ImageSchema> imagePipeOut;", "modifier": "private final", "type": "Pipe<ImageSchema>", "declarator": "imagePipeOut", "var_name": "imagePipeOut"}, {"original_string": "private final int cropWidth;", "modifier": "private final", "type": "int", "declarator": "cropWidth", "var_name": "cropWidth"}, {"original_string": "private final int cropHeight;", "modifier": "private final", "type": "int", "declarator": "cropHeight", "var_name": "cropHeight"}, {"original_string": "private long nextInputFrameTimestamp = NONE;", "modifier": "private", "type": "long", "declarator": "nextInputFrameTimestamp = NONE", "var_name": "nextInputFrameTimestamp"}, {"original_string": "private int nextInputFrameWidth;", "modifier": "private", "type": "int", "declarator": "nextInputFrameWidth", "var_name": "nextInputFrameWidth"}, {"original_string": "private int nextInputFrameHeight;", "modifier": "private", "type": "int", "declarator": "nextInputFrameHeight", "var_name": "nextInputFrameHeight"}, {"original_string": "private int nextInputFrameSize;", "modifier": "private", "type": "int", "declarator": "nextInputFrameSize", "var_name": "nextInputFrameSize"}, {"original_string": "private long inputFrameTimestamp = NONE;", "modifier": "private", "type": "long", "declarator": "inputFrameTimestamp = NONE", "var_name": "inputFrameTimestamp"}, {"original_string": "private int inputFrameWidth;", "modifier": "private", "type": "int", "declarator": "inputFrameWidth", "var_name": "inputFrameWidth"}, {"original_string": "private int inputFrameHeight;", "modifier": "private", "type": "int", "declarator": "inputFrameHeight", "var_name": "inputFrameHeight"}, {"original_string": "private byte[] inputFrame;", "modifier": "private", "type": "byte[]", "declarator": "inputFrame", "var_name": "inputFrame"}, {"original_string": "private int inputFrameHead = NONE;", "modifier": "private", "type": "int", "declarator": "inputFrameHead = NONE", "var_name": "inputFrameHead"}, {"original_string": "private long rotationRequestTimestamp = NONE;", "modifier": "private", "type": "long", "declarator": "rotationRequestTimestamp = NONE", "var_name": "rotationRequestTimestamp"}, {"original_string": "private double rotationAlpha, rotationBeta;", "modifier": "private", "type": "double", "declarator": "rotationAlpha", "var_name": "rotationAlpha"}, {"original_string": "private final byte[] outputFrame;", "modifier": "private final", "type": "byte[]", "declarator": "outputFrame", "var_name": "outputFrame"}, {"original_string": "private final int outputFrameRowSize;", "modifier": "private final", "type": "int", "declarator": "outputFrameRowSize", "var_name": "outputFrameRowSize"}, {"original_string": "private int outputFrameHead = NONE;", "modifier": "private", "type": "int", "declarator": "outputFrameHead = NONE", "var_name": "outputFrameHead"}, {"original_string": "public static final int DEFAULT_CROP_WIDTH = LinuxImageCaptureStage.DEFAULT_FRAME_WIDTH;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_CROP_WIDTH = LinuxImageCaptureStage.DEFAULT_FRAME_WIDTH", "var_name": "DEFAULT_CROP_WIDTH"}, {"original_string": "public static final int DEFAULT_CROP_HEIGHT = LinuxImageCaptureStage.DEFAULT_FRAME_HEIGHT;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_CROP_HEIGHT = LinuxImageCaptureStage.DEFAULT_FRAME_HEIGHT", "var_name": "DEFAULT_CROP_HEIGHT"}], "methods": [{"identifier": "cartesianToRgb24Index", "parameters": "(int x, int y, int width)", "modifiers": "private static", "return": "int", "signature": "int cartesianToRgb24Index(int x, int y, int width)", "full_signature": "private static int cartesianToRgb24Index(int x, int y, int width)", "class_method_signature": "ImageRotationStage.cartesianToRgb24Index(int x, int y, int width)", "testcase": false, "constructor": false}, {"identifier": "shearRotateFrame", "parameters": "(double alpha, double beta,\n                                         byte[] source, int width, int height,\n                                         byte[] destination, int destinationWidth, int destinationHeight)", "modifiers": "private static", "return": "void", "signature": "void shearRotateFrame(double alpha, double beta,\n                                         byte[] source, int width, int height,\n                                         byte[] destination, int destinationWidth, int destinationHeight)", "full_signature": "private static void shearRotateFrame(double alpha, double beta,\n                                         byte[] source, int width, int height,\n                                         byte[] destination, int destinationWidth, int destinationHeight)", "class_method_signature": "ImageRotationStage.shearRotateFrame(double alpha, double beta,\n                                         byte[] source, int width, int height,\n                                         byte[] destination, int destinationWidth, int destinationHeight)", "testcase": false, "constructor": false}, {"identifier": "ImageRotationStage", "parameters": "(GraphManager gm,\n                              Pipe<ImageSchema> imagePipeIn,\n                              Pipe<ImageRotationSchema> imageRotationPipeIn,\n                              Pipe<ImageSchema> imagePipeOut)", "modifiers": "public", "return": "", "signature": " ImageRotationStage(GraphManager gm,\n                              Pipe<ImageSchema> imagePipeIn,\n                              Pipe<ImageRotationSchema> imageRotationPipeIn,\n                              Pipe<ImageSchema> imagePipeOut)", "full_signature": "public  ImageRotationStage(GraphManager gm,\n                              Pipe<ImageSchema> imagePipeIn,\n                              Pipe<ImageRotationSchema> imageRotationPipeIn,\n                              Pipe<ImageSchema> imagePipeOut)", "class_method_signature": "ImageRotationStage.ImageRotationStage(GraphManager gm,\n                              Pipe<ImageSchema> imagePipeIn,\n                              Pipe<ImageRotationSchema> imageRotationPipeIn,\n                              Pipe<ImageSchema> imagePipeOut)", "testcase": false, "constructor": true}, {"identifier": "ImageRotationStage", "parameters": "(GraphManager gm,\n                              Pipe<ImageSchema> imagePipeIn,\n                              Pipe<ImageRotationSchema> imageRotationPipeIn,\n                              Pipe<ImageSchema> imagePipeOut,\n                              int cropWidth, int cropHeight)", "modifiers": "public", "return": "", "signature": " ImageRotationStage(GraphManager gm,\n                              Pipe<ImageSchema> imagePipeIn,\n                              Pipe<ImageRotationSchema> imageRotationPipeIn,\n                              Pipe<ImageSchema> imagePipeOut,\n                              int cropWidth, int cropHeight)", "full_signature": "public  ImageRotationStage(GraphManager gm,\n                              Pipe<ImageSchema> imagePipeIn,\n                              Pipe<ImageRotationSchema> imageRotationPipeIn,\n                              Pipe<ImageSchema> imagePipeOut,\n                              int cropWidth, int cropHeight)", "class_method_signature": "ImageRotationStage.ImageRotationStage(GraphManager gm,\n                              Pipe<ImageSchema> imagePipeIn,\n                              Pipe<ImageRotationSchema> imageRotationPipeIn,\n                              Pipe<ImageSchema> imagePipeOut,\n                              int cropWidth, int cropHeight)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "ImageRotationStage.run()", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void shutdown()", "full_signature": "@Override public void shutdown()", "class_method_signature": "ImageRotationStage.shutdown()", "testcase": false, "constructor": false}], "file": "foglight/src/main/java/com/ociweb/pronghorn/image/ImageRotationStage.java"}, "focal_method": {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void run() {\n\n        // Read in a next frame if we do not have one.\n        if (nextInputFrameTimestamp == NONE && PipeReader.tryReadFragment(imagePipeIn)) {\n            assert PipeReader.getMsgIdx(imagePipeIn) == ImageSchema.MSG_FRAMESTART_1;\n            nextInputFrameWidth = PipeReader.readInt(imagePipeIn, ImageSchema.MSG_FRAMESTART_1_FIELD_WIDTH_101);\n            nextInputFrameHeight = PipeReader.readInt(imagePipeIn, ImageSchema.MSG_FRAMESTART_1_FIELD_HEIGHT_201);\n            nextInputFrameTimestamp = PipeReader.readLong(imagePipeIn, ImageSchema.MSG_FRAMESTART_1_FIELD_TIMESTAMP_301);\n            nextInputFrameSize = PipeReader.readInt(imagePipeIn, ImageSchema.MSG_FRAMESTART_1_FIELD_FRAMEBYTES_401);\n            assert inputFrameHead == NONE || inputFrameHead == FRAME_BUFFERED;\n            inputFrameHead = 0;\n\n            PipeReader.releaseReadLock(imagePipeIn);\n        }\n\n        // Read in a cropping request if we do not have one.\n        if (rotationRequestTimestamp == NONE && PipeReader.tryReadFragment(imageRotationPipeIn)) {\n            assert PipeReader.getMsgIdx(imageRotationPipeIn) == ImageRotationSchema.MSG_ROTATIONREQUEST_1;\n\n            // Read in rotation data.\n            long rotationRequestNumerator = PipeReader.readLong(imageRotationPipeIn, ImageRotationSchema.MSG_ROTATIONREQUEST_1_FIELD_NUMERATOR_101);\n            long rotationRequestDenominator = PipeReader.readLong(imageRotationPipeIn, ImageRotationSchema.MSG_ROTATIONREQUEST_1_FIELD_DENOMINATOR_201);\n            rotationRequestTimestamp = PipeReader.readLong(imageRotationPipeIn, ImageRotationSchema.MSG_ROTATIONREQUEST_1_FIELD_TIMESTAMP_301);\n\n            // Calculate theta degrees from rotation data.\n            double theta = rotationRequestNumerator / rotationRequestDenominator;\n\n            // Calculate alpha, beta, and gamma for rotation data.\n            rotationAlpha = -1 * Math.tan(theta / 2);\n            rotationBeta = Math.sin(theta);\n\n            PipeReader.releaseReadLock(imageRotationPipeIn);\n        }\n\n        // Read in the next frame if the next frame's timestamp is older than the rotation request.\n        if (nextInputFrameTimestamp != NONE && nextInputFrameTimestamp < rotationRequestTimestamp) {\n\n            // Ensure image frame buffer is correctly sized.\n            if (inputFrame == null || inputFrame.length != nextInputFrameSize) {\n                inputFrame = new byte[nextInputFrameSize];\n            }\n\n            // Fill frame arrays.\n            while (PipeReader.tryReadFragment(imagePipeIn)) {\n                assert PipeReader.getMsgIdx(imagePipeIn) == ImageSchema.MSG_FRAMECHUNK_2;\n\n                // Read data.\n                inputFrameHead += PipeReader.readBytes(imagePipeIn, ImageSchema.MSG_FRAMECHUNK_2_FIELD_ROWBYTES_102, inputFrame, inputFrameHead);\n\n                // If frame is full, we're done!\n                if (inputFrameHead >= inputFrame.length) {\n                    inputFrameTimestamp = nextInputFrameTimestamp;\n                    inputFrameWidth = nextInputFrameWidth;\n                    inputFrameHeight = nextInputFrameHeight;\n                    inputFrameHead = FRAME_BUFFERED;\n                    nextInputFrameTimestamp = NONE;\n                    break;\n                }\n\n                PipeReader.releaseReadLock(imagePipeIn);\n            }\n        }\n\n        // If we have an input frame buffered, have an active rotation request,\n        // and the input frame predates the rotation request, write out a rotation.\n        if (outputFrameHead != NONE ||\n            (inputFrameHead == FRAME_BUFFERED && rotationRequestTimestamp != NONE && inputFrameTimestamp < rotationRequestTimestamp)) {\n\n            // Frame start.\n            if (outputFrameHead == NONE && PipeWriter.tryWriteFragment(imagePipeOut, ImageSchema.MSG_FRAMESTART_1)) {\n\n                // Write start data to the pipe.\n                PipeWriter.writeInt(imagePipeOut, ImageSchema.MSG_FRAMESTART_1_FIELD_WIDTH_101, cropWidth);\n                PipeWriter.writeInt(imagePipeOut, ImageSchema.MSG_FRAMESTART_1_FIELD_HEIGHT_201, cropHeight);\n                PipeWriter.writeLong(imagePipeOut, ImageSchema.MSG_FRAMESTART_1_FIELD_TIMESTAMP_301, System.currentTimeMillis());\n                PipeWriter.writeInt(imagePipeOut, ImageSchema.MSG_FRAMESTART_1_FIELD_FRAMEBYTES_401, outputFrame.length);\n                PipeWriter.writeInt(imagePipeOut, ImageSchema.MSG_FRAMESTART_1_FIELD_BITSPERPIXEL_501, 24);\n                PipeWriter.writeBytes(imagePipeOut, ImageSchema.MSG_FRAMESTART_1_FIELD_ENCODING_601, LinuxImageCaptureStage.OUTPUT_ENCODING);\n                PipeWriter.publishWrites(imagePipeOut);\n                outputFrameHead = 0;\n\n                // Reset the output frame.\n                // This must be done because some positions in the frame may not be written to,\n                // and thus should appear empty (black).\n                Arrays.fill(outputFrame, (byte) 0x00);\n\n                // Skew the input frame into our output frame.\n                shearRotateFrame(rotationAlpha, rotationBeta, inputFrame, inputFrameWidth, inputFrameHeight, outputFrame, cropWidth, cropHeight);\n            }\n\n            // Write output frame data.\n            if (outputFrameHead >= 0 && PipeWriter.tryWriteFragment(imagePipeOut, ImageSchema.MSG_FRAMECHUNK_2)) {\n\n                // Write bytes.\n                PipeWriter.writeBytes(imagePipeOut, ImageSchema.MSG_FRAMECHUNK_2_FIELD_ROWBYTES_102, outputFrame, outputFrameHead, outputFrameRowSize);\n                PipeWriter.publishWrites(imagePipeOut);\n\n                // Progress head.\n                outputFrameHead += outputFrameRowSize;\n\n                // If the head exceeds the size of the frame bytes, we're done writing.\n                if (outputFrameHead >= outputFrame.length) {\n                    outputFrameHead = NONE;\n                }\n            }\n        }\n    }", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "ImageRotationStage.run()", "testcase": false, "constructor": false, "invocations": ["tryReadFragment", "getMsgIdx", "readInt", "readInt", "readLong", "readInt", "releaseReadLock", "tryReadFragment", "getMsgIdx", "readLong", "readLong", "readLong", "tan", "sin", "releaseReadLock", "tryReadFragment", "getMsgIdx", "readBytes", "releaseReadLock", "tryWriteFragment", "writeInt", "writeInt", "writeLong", "currentTimeMillis", "writeInt", "writeInt", "writeBytes", "publishWrites", "fill", "shearRotateFrame", "tryWriteFragment", "writeBytes", "publishWrites"]}, "repository": {"repo_id": 44977869, "url": "https://github.com/oci-pronghorn/FogLight", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 12, "size": 124921, "license": "licensed"}}