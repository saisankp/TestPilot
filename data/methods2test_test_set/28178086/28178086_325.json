{"test_class": {"identifier": "SymmetricMullerNewtonSolverTest", "superclass": "", "interfaces": "", "fields": [], "file": "jtstoolkit/src/test/java/ec/tstoolkit/maths/polynomials/SymmetricMullerNewtonSolverTest.java"}, "test_case": {"identifier": "test2", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void test2() {\n        BackFilter f1=BackFilter.of(new double[]{1, -.7, .1});\n        BackFilter f2=BackFilter.of(new double[]{1, .6, .5});\n        BackFilter f=f1.times(f2);\n        SymmetricFilter sf=SymmetricFilter.createFromFilter(f);\n        SymmetricMullerNewtonSolver solver=new SymmetricMullerNewtonSolver();\n        Polynomial P = Polynomial.copyOf(sf.getWeights());\n        Complex[] roots = P.roots(solver);\n//        for (int i=0; i<roots.length; ++i){\n//            System.out.println(roots[i]);\n//        }\n    }", "signature": "void test2()", "full_signature": "@Test public void test2()", "class_method_signature": "SymmetricMullerNewtonSolverTest.test2()", "testcase": true, "constructor": false, "invocations": ["of", "of", "times", "createFromFilter", "copyOf", "getWeights", "roots"]}, "focal_class": {"identifier": "SymmetricMullerNewtonSolver", "superclass": "", "interfaces": "implements IRootsSolver", "fields": [{"original_string": "private double[] m_p;", "modifier": "private", "type": "double[]", "declarator": "m_p", "var_name": "m_p"}, {"original_string": "private double[] m_pred;", "modifier": "private", "type": "double[]", "declarator": "m_pred", "var_name": "m_pred"}, {"original_string": "private Complex[] m_roots;", "modifier": "private", "type": "Complex[]", "declarator": "m_roots", "var_name": "m_roots"}, {"original_string": "private Polynomial m_remainder;", "modifier": "private", "type": "Polynomial", "declarator": "m_remainder", "var_name": "m_remainder"}, {"original_string": "private int m_idx, m_degree;", "modifier": "private", "type": "int", "declarator": "m_idx", "var_name": "m_idx"}, {"original_string": "private double m_maxerr;", "modifier": "private", "type": "double", "declarator": "m_maxerr", "var_name": "m_maxerr"}, {"original_string": "private final static int MITERMAX = 150;", "modifier": "private final static", "type": "int", "declarator": "MITERMAX = 150", "var_name": "MITERMAX"}, {"original_string": "private final static int MCONVERGENCE = 100;", "modifier": "private final static", "type": "int", "declarator": "MCONVERGENCE = 100", "var_name": "MCONVERGENCE"}, {"original_string": "private final static double MMAXDIST = 1e3;", "modifier": "private final static", "type": "double", "declarator": "MMAXDIST = 1e3", "var_name": "MMAXDIST"}, {"original_string": "private final static double MFACTOR = 1e5;", "modifier": "private final static", "type": "double", "declarator": "MFACTOR = 1e5", "var_name": "MFACTOR"}, {"original_string": "private final static double MKITERMAX = 1e3;", "modifier": "private final static", "type": "double", "declarator": "MKITERMAX = 1e3", "var_name": "MKITERMAX"}, {"original_string": "private final static double MFVALUE = 1e36;", "modifier": "private final static", "type": "double", "declarator": "MFVALUE = 1e36", "var_name": "MFVALUE"}, {"original_string": "private final static double MBOUND1 = 1.01;", "modifier": "private final static", "type": "double", "declarator": "MBOUND1 = 1.01", "var_name": "MBOUND1"}, {"original_string": "private final static double MBOUND2 = 0.99;", "modifier": "private final static", "type": "double", "declarator": "MBOUND2 = 0.99", "var_name": "MBOUND2"}, {"original_string": "private final static double MBOUND3 = 0.01;", "modifier": "private final static", "type": "double", "declarator": "MBOUND3 = 0.01", "var_name": "MBOUND3"}, {"original_string": "private final double MBOUND4;", "modifier": "private final", "type": "double", "declarator": "MBOUND4", "var_name": "MBOUND4"}, {"original_string": "private final double MBOUND6;", "modifier": "private final", "type": "double", "declarator": "MBOUND6", "var_name": "MBOUND6"}, {"original_string": "private final static double MBOUND7 = 1e-5;", "modifier": "private final static", "type": "double", "declarator": "MBOUND7 = 1e-5", "var_name": "MBOUND7"}, {"original_string": "private final double MNOISESTART;", "modifier": "private final", "type": "double", "declarator": "MNOISESTART", "var_name": "MNOISESTART"}, {"original_string": "private final static double MNOISEMAX = 5;", "modifier": "private final static", "type": "double", "declarator": "MNOISEMAX = 5", "var_name": "MNOISEMAX"}, {"original_string": "private final static int NITERMAX = 20;", "modifier": "private final static", "type": "int", "declarator": "NITERMAX = 20", "var_name": "NITERMAX"}, {"original_string": "private final static double NFACTOR = 5;", "modifier": "private final static", "type": "double", "declarator": "NFACTOR = 5", "var_name": "NFACTOR"}, {"original_string": "private final static double NFVALUE = 1e36;", "modifier": "private final static", "type": "double", "declarator": "NFVALUE = 1e36", "var_name": "NFVALUE"}, {"original_string": "private static final double ISQRT2 = 1.0 / Math.sqrt(2.0);", "modifier": "private static final", "type": "double", "declarator": "ISQRT2 = 1.0 / Math.sqrt(2.0)", "var_name": "ISQRT2"}, {"original_string": "private final double NBOUND;", "modifier": "private final", "type": "double", "declarator": "NBOUND", "var_name": "NBOUND"}, {"original_string": "private final static int NNOISEMAX = 5;", "modifier": "private final static", "type": "int", "declarator": "NNOISEMAX = 5", "var_name": "NNOISEMAX"}, {"original_string": "private final static double DBL_EPSILON = 2.2204460492503131e-016;", "modifier": "private final static", "type": "double", "declarator": "DBL_EPSILON = 2.2204460492503131e-016", "var_name": "DBL_EPSILON"}, {"original_string": "Complex x0, x1, x2;", "modifier": "", "type": "Complex", "declarator": "x0", "var_name": "x0"}, {"original_string": "Complex h1, h2;", "modifier": "", "type": "Complex", "declarator": "h1", "var_name": "h1"}, {"original_string": "Complex q2;", "modifier": "", "type": "Complex", "declarator": "q2", "var_name": "q2"}, {"original_string": "final Ref<Complex> f0, f1, f2;", "modifier": "final", "type": "Ref<Complex>", "declarator": "f0", "var_name": "f0"}, {"original_string": "int iter;", "modifier": "", "type": "int", "declarator": "iter", "var_name": "iter"}, {"original_string": "private boolean lqdiv = true;", "modifier": "private", "type": "boolean", "declarator": "lqdiv = true", "var_name": "lqdiv"}, {"original_string": "private static final Complex[] COMPLEX_FOR_ITER = initComplexForIter(MITERMAX);", "modifier": "private static final", "type": "Complex[]", "declarator": "COMPLEX_FOR_ITER = initComplexForIter(MITERMAX)", "var_name": "COMPLEX_FOR_ITER"}, {"original_string": "private static double B_EPS = .1;", "modifier": "private static", "type": "double", "declarator": "B_EPS = .1", "var_name": "B_EPS"}, {"original_string": "static final double OPT_MIN = 1e-5;", "modifier": "static final", "type": "double", "declarator": "OPT_MIN = 1e-5", "var_name": "OPT_MIN"}], "methods": [{"identifier": "fdvalue", "parameters": "(final double[] p, final int i0,\n            final Ref<Complex> f, final Complex x)", "modifiers": "private static", "return": "void", "signature": "void fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Complex x)", "full_signature": "private static void fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Complex x)", "class_method_signature": "SymmetricMullerNewtonSolver.fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Complex x)", "testcase": false, "constructor": false}, {"identifier": "fdvalue", "parameters": "(final double[] p, final int i0,\n            final Ref<Complex> f, final Ref<Complex> df, final Complex x)", "modifiers": "private static", "return": "void", "signature": "void fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Ref<Complex> df, final Complex x)", "full_signature": "private static void fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Ref<Complex> df, final Complex x)", "class_method_signature": "SymmetricMullerNewtonSolver.fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Ref<Complex> df, final Complex x)", "testcase": false, "constructor": false}, {"identifier": "SymmetricMullerNewtonSolver", "parameters": "()", "modifiers": "public", "return": "", "signature": " SymmetricMullerNewtonSolver()", "full_signature": "public  SymmetricMullerNewtonSolver()", "class_method_signature": "SymmetricMullerNewtonSolver.SymmetricMullerNewtonSolver()", "testcase": false, "constructor": true}, {"identifier": "check_x_value", "parameters": "(final Ref<Complex> xb,\n            final DoubleRef f2absqb, final BooleanRef rootd,\n            final double f1absq, final double f2absq, final double epsilon,\n            final IntRef noise)", "modifiers": "private", "return": "void", "signature": "void check_x_value(final Ref<Complex> xb,\n            final DoubleRef f2absqb, final BooleanRef rootd,\n            final double f1absq, final double f2absq, final double epsilon,\n            final IntRef noise)", "full_signature": "private void check_x_value(final Ref<Complex> xb,\n            final DoubleRef f2absqb, final BooleanRef rootd,\n            final double f1absq, final double f2absq, final double epsilon,\n            final IntRef noise)", "class_method_signature": "SymmetricMullerNewtonSolver.check_x_value(final Ref<Complex> xb,\n            final DoubleRef f2absqb, final BooleanRef rootd,\n            final double f1absq, final double f2absq, final double epsilon,\n            final IntRef noise)", "testcase": false, "constructor": false}, {"identifier": "clear", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void clear()", "full_signature": "@Override public void clear()", "class_method_signature": "SymmetricMullerNewtonSolver.clear()", "testcase": false, "constructor": false}, {"identifier": "exemplar", "parameters": "()", "modifiers": "@Override public", "return": "SymmetricMullerNewtonSolver", "signature": "SymmetricMullerNewtonSolver exemplar()", "full_signature": "@Override public SymmetricMullerNewtonSolver exemplar()", "class_method_signature": "SymmetricMullerNewtonSolver.exemplar()", "testcase": false, "constructor": false}, {"identifier": "compute_function", "parameters": "(final double f1absq,\n            final DoubleRef f2absq, final double epsilon)", "modifiers": "private", "return": "void", "signature": "void compute_function(final double f1absq,\n            final DoubleRef f2absq, final double epsilon)", "full_signature": "private void compute_function(final double f1absq,\n            final DoubleRef f2absq, final double epsilon)", "class_method_signature": "SymmetricMullerNewtonSolver.compute_function(final double f1absq,\n            final DoubleRef f2absq, final double epsilon)", "testcase": false, "constructor": false}, {"identifier": "convergence_check", "parameters": "(final IntRef overflow,\n            final double f1absq, final double f2absq, final double epsilon)", "modifiers": "private", "return": "void", "signature": "void convergence_check(final IntRef overflow,\n            final double f1absq, final double f2absq, final double epsilon)", "full_signature": "private void convergence_check(final IntRef overflow,\n            final double f1absq, final double f2absq, final double epsilon)", "class_method_signature": "SymmetricMullerNewtonSolver.convergence_check(final IntRef overflow,\n            final double f1absq, final double f2absq, final double epsilon)", "testcase": false, "constructor": false}, {"identifier": "factorize", "parameters": "(final Polynomial p)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean factorize(final Polynomial p)", "full_signature": "@Override public boolean factorize(final Polynomial p)", "class_method_signature": "SymmetricMullerNewtonSolver.factorize(final Polynomial p)", "testcase": false, "constructor": false}, {"identifier": "initialize", "parameters": "(final Ref<Complex> xb, final DoubleRef epsilon)", "modifiers": "private", "return": "void", "signature": "void initialize(final Ref<Complex> xb, final DoubleRef epsilon)", "full_signature": "private void initialize(final Ref<Complex> xb, final DoubleRef epsilon)", "class_method_signature": "SymmetricMullerNewtonSolver.initialize(final Ref<Complex> xb, final DoubleRef epsilon)", "testcase": false, "constructor": false}, {"identifier": "iteration_equation", "parameters": "(final DoubleRef h2abs)", "modifiers": "private", "return": "void", "signature": "void iteration_equation(final DoubleRef h2abs)", "full_signature": "private void iteration_equation(final DoubleRef h2abs)", "class_method_signature": "SymmetricMullerNewtonSolver.iteration_equation(final DoubleRef h2abs)", "testcase": false, "constructor": false}, {"identifier": "monic", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void monic()", "full_signature": "private void monic()", "class_method_signature": "SymmetricMullerNewtonSolver.monic()", "testcase": false, "constructor": false}, {"identifier": "muller", "parameters": "()", "modifiers": "private", "return": "Complex", "signature": "Complex muller()", "full_signature": "private Complex muller()", "class_method_signature": "SymmetricMullerNewtonSolver.muller()", "testcase": false, "constructor": false}, {"identifier": "newton", "parameters": "(final Complex ns, final DoubleRef dxabs)", "modifiers": "private", "return": "Complex", "signature": "Complex newton(final Complex ns, final DoubleRef dxabs)", "full_signature": "private Complex newton(final Complex ns, final DoubleRef dxabs)", "class_method_signature": "SymmetricMullerNewtonSolver.newton(final Complex ns, final DoubleRef dxabs)", "testcase": false, "constructor": false}, {"identifier": "newtonnull", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean newtonnull()", "full_signature": "private boolean newtonnull()", "class_method_signature": "SymmetricMullerNewtonSolver.newtonnull()", "testcase": false, "constructor": false}, {"identifier": "quadratic", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean quadratic()", "full_signature": "private boolean quadratic()", "class_method_signature": "SymmetricMullerNewtonSolver.quadratic()", "testcase": false, "constructor": false}, {"identifier": "remainder", "parameters": "()", "modifiers": "@Override public", "return": "Polynomial", "signature": "Polynomial remainder()", "full_signature": "@Override public Polynomial remainder()", "class_method_signature": "SymmetricMullerNewtonSolver.remainder()", "testcase": false, "constructor": false}, {"identifier": "root_check", "parameters": "(final double f2absqb,\n            final IntRef seconditer, final BooleanRef rootd,\n            final IntRef noise, final Complex xb)", "modifiers": "private", "return": "void", "signature": "void root_check(final double f2absqb,\n            final IntRef seconditer, final BooleanRef rootd,\n            final IntRef noise, final Complex xb)", "full_signature": "private void root_check(final double f2absqb,\n            final IntRef seconditer, final BooleanRef rootd,\n            final IntRef noise, final Complex xb)", "class_method_signature": "SymmetricMullerNewtonSolver.root_check(final double f2absqb,\n            final IntRef seconditer, final BooleanRef rootd,\n            final IntRef noise, final Complex xb)", "testcase": false, "constructor": false}, {"identifier": "root_of_parabola", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void root_of_parabola()", "full_signature": "private void root_of_parabola()", "class_method_signature": "SymmetricMullerNewtonSolver.root_of_parabola()", "testcase": false, "constructor": false}, {"identifier": "computeA2", "parameters": "(Complex q2, Complex f2, Complex f0, Complex f1)", "modifiers": "@VisibleForTesting static", "return": "Complex", "signature": "Complex computeA2(Complex q2, Complex f2, Complex f0, Complex f1)", "full_signature": "@VisibleForTesting static Complex computeA2(Complex q2, Complex f2, Complex f0, Complex f1)", "class_method_signature": "SymmetricMullerNewtonSolver.computeA2(Complex q2, Complex f2, Complex f0, Complex f1)", "testcase": false, "constructor": false}, {"identifier": "computeB2", "parameters": "(Complex f2, Complex f1, Complex q2, Complex f0)", "modifiers": "@VisibleForTesting static", "return": "Complex", "signature": "Complex computeB2(Complex f2, Complex f1, Complex q2, Complex f0)", "full_signature": "@VisibleForTesting static Complex computeB2(Complex f2, Complex f1, Complex q2, Complex f0)", "class_method_signature": "SymmetricMullerNewtonSolver.computeB2(Complex f2, Complex f1, Complex q2, Complex f0)", "testcase": false, "constructor": false}, {"identifier": "computeC2", "parameters": "(Complex q2, Complex f2)", "modifiers": "@VisibleForTesting static", "return": "Complex", "signature": "Complex computeC2(Complex q2, Complex f2)", "full_signature": "@VisibleForTesting static Complex computeC2(Complex q2, Complex f2)", "class_method_signature": "SymmetricMullerNewtonSolver.computeC2(Complex q2, Complex f2)", "testcase": false, "constructor": false}, {"identifier": "computeDiscr", "parameters": "(Complex B2, Complex A2, Complex C2)", "modifiers": "@VisibleForTesting static", "return": "Complex", "signature": "Complex computeDiscr(Complex B2, Complex A2, Complex C2)", "full_signature": "@VisibleForTesting static Complex computeDiscr(Complex B2, Complex A2, Complex C2)", "class_method_signature": "SymmetricMullerNewtonSolver.computeDiscr(Complex B2, Complex A2, Complex C2)", "testcase": false, "constructor": false}, {"identifier": "roots", "parameters": "()", "modifiers": "@Override public", "return": "Complex[]", "signature": "Complex[] roots()", "full_signature": "@Override public Complex[] roots()", "class_method_signature": "SymmetricMullerNewtonSolver.roots()", "testcase": false, "constructor": false}, {"identifier": "getStableRoots", "parameters": "()", "modifiers": "public", "return": "Complex[]", "signature": "Complex[] getStableRoots()", "full_signature": "public Complex[] getStableRoots()", "class_method_signature": "SymmetricMullerNewtonSolver.getStableRoots()", "testcase": false, "constructor": false}, {"identifier": "roots_at_zero", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void roots_at_zero()", "full_signature": "private void roots_at_zero()", "class_method_signature": "SymmetricMullerNewtonSolver.roots_at_zero()", "testcase": false, "constructor": false}, {"identifier": "suppress_overflow", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void suppress_overflow()", "full_signature": "private void suppress_overflow()", "class_method_signature": "SymmetricMullerNewtonSolver.suppress_overflow()", "testcase": false, "constructor": false}, {"identifier": "too_big_functionvalues", "parameters": "(final DoubleRef f2absq)", "modifiers": "private", "return": "void", "signature": "void too_big_functionvalues(final DoubleRef f2absq)", "full_signature": "private void too_big_functionvalues(final DoubleRef f2absq)", "class_method_signature": "SymmetricMullerNewtonSolver.too_big_functionvalues(final DoubleRef f2absq)", "testcase": false, "constructor": false}, {"identifier": "isLeastSquaresDivision", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isLeastSquaresDivision()", "full_signature": "public boolean isLeastSquaresDivision()", "class_method_signature": "SymmetricMullerNewtonSolver.isLeastSquaresDivision()", "testcase": false, "constructor": false}, {"identifier": "setLeastSquaresDivision", "parameters": "(boolean lq)", "modifiers": "public", "return": "void", "signature": "void setLeastSquaresDivision(boolean lq)", "full_signature": "public void setLeastSquaresDivision(boolean lq)", "class_method_signature": "SymmetricMullerNewtonSolver.setLeastSquaresDivision(boolean lq)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(final Complex r0)", "modifiers": "private", "return": "boolean", "signature": "boolean update(final Complex r0)", "full_signature": "private boolean update(final Complex r0)", "class_method_signature": "SymmetricMullerNewtonSolver.update(final Complex r0)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(final double r0)", "modifiers": "private", "return": "boolean", "signature": "boolean update(final double r0)", "full_signature": "private boolean update(final double r0)", "class_method_signature": "SymmetricMullerNewtonSolver.update(final double r0)", "testcase": false, "constructor": false}, {"identifier": "reinforceSymmetry", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void reinforceSymmetry()", "full_signature": "private void reinforceSymmetry()", "class_method_signature": "SymmetricMullerNewtonSolver.reinforceSymmetry()", "testcase": false, "constructor": false}, {"identifier": "getComplexForIterationCounter", "parameters": "(int iter)", "modifiers": "private static", "return": "Complex", "signature": "Complex getComplexForIterationCounter(int iter)", "full_signature": "private static Complex getComplexForIterationCounter(int iter)", "class_method_signature": "SymmetricMullerNewtonSolver.getComplexForIterationCounter(int iter)", "testcase": false, "constructor": false}, {"identifier": "newComplexForIterationCounter", "parameters": "(int iter)", "modifiers": "private static", "return": "Complex", "signature": "Complex newComplexForIterationCounter(int iter)", "full_signature": "private static Complex newComplexForIterationCounter(int iter)", "class_method_signature": "SymmetricMullerNewtonSolver.newComplexForIterationCounter(int iter)", "testcase": false, "constructor": false}, {"identifier": "initComplexForIter", "parameters": "(int maxIter)", "modifiers": "private static", "return": "Complex[]", "signature": "Complex[] initComplexForIter(int maxIter)", "full_signature": "private static Complex[] initComplexForIter(int maxIter)", "class_method_signature": "SymmetricMullerNewtonSolver.initComplexForIter(int maxIter)", "testcase": false, "constructor": false}, {"identifier": "optimize", "parameters": "(Complex r0)", "modifiers": "private", "return": "boolean", "signature": "boolean optimize(Complex r0)", "full_signature": "private boolean optimize(Complex r0)", "class_method_signature": "SymmetricMullerNewtonSolver.optimize(Complex r0)", "testcase": false, "constructor": false}], "file": "jtstoolkit/src/main/java/ec/tstoolkit/maths/polynomials/SymmetricMullerNewtonSolver.java"}, "focal_method": {"identifier": "roots", "parameters": "()", "modifiers": "@Override public", "return": "Complex[]", "body": "@Override\n    public Complex[] roots() {\n        Complex[] r = new Complex[m_roots.length * 2];\n        for (int i = 0; i < m_roots.length; ++i) {\n            r[2 * i] = m_roots[i];\n            r[2 * i + 1] = m_roots[i].inv();\n        }\n        return r;\n    }", "signature": "Complex[] roots()", "full_signature": "@Override public Complex[] roots()", "class_method_signature": "SymmetricMullerNewtonSolver.roots()", "testcase": false, "constructor": false, "invocations": ["inv"]}, "repository": {"repo_id": 28178086, "url": "https://github.com/jdemetra/jdemetra-core", "stars": 24, "created": "12/18/2014 10:00:58 AM +00:00", "updates": "2020-01-17T15:50:24+00:00", "fork": "False", "license": "licensed"}}