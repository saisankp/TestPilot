{"test_class": {"identifier": "StandbyTaskTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final TaskId taskId = new TaskId(0, 1);", "modifier": "private final", "type": "TaskId", "declarator": "taskId = new TaskId(0, 1)", "var_name": "taskId"}, {"original_string": "private final Serializer<Integer> intSerializer = new IntegerSerializer();", "modifier": "private final", "type": "Serializer<Integer>", "declarator": "intSerializer = new IntegerSerializer()", "var_name": "intSerializer"}, {"original_string": "private final String applicationId = \"test-application\";", "modifier": "private final", "type": "String", "declarator": "applicationId = \"test-application\"", "var_name": "applicationId"}, {"original_string": "private final String storeName1 = \"store1\";", "modifier": "private final", "type": "String", "declarator": "storeName1 = \"store1\"", "var_name": "storeName1"}, {"original_string": "private final String storeName2 = \"store2\";", "modifier": "private final", "type": "String", "declarator": "storeName2 = \"store2\"", "var_name": "storeName2"}, {"original_string": "private final String storeChangelogTopicName1 = ProcessorStateManager.storeChangelogTopic(applicationId, storeName1);", "modifier": "private final", "type": "String", "declarator": "storeChangelogTopicName1 = ProcessorStateManager.storeChangelogTopic(applicationId, storeName1)", "var_name": "storeChangelogTopicName1"}, {"original_string": "private final String storeChangelogTopicName2 = ProcessorStateManager.storeChangelogTopic(applicationId, storeName2);", "modifier": "private final", "type": "String", "declarator": "storeChangelogTopicName2 = ProcessorStateManager.storeChangelogTopic(applicationId, storeName2)", "var_name": "storeChangelogTopicName2"}, {"original_string": "private final TopicPartition partition1 = new TopicPartition(storeChangelogTopicName1, 1);", "modifier": "private final", "type": "TopicPartition", "declarator": "partition1 = new TopicPartition(storeChangelogTopicName1, 1)", "var_name": "partition1"}, {"original_string": "private final TopicPartition partition2 = new TopicPartition(storeChangelogTopicName2, 1);", "modifier": "private final", "type": "TopicPartition", "declarator": "partition2 = new TopicPartition(storeChangelogTopicName2, 1)", "var_name": "partition2"}, {"original_string": "private final Set<TopicPartition> topicPartitions = Collections.emptySet();", "modifier": "private final", "type": "Set<TopicPartition>", "declarator": "topicPartitions = Collections.emptySet()", "var_name": "topicPartitions"}, {"original_string": "private final ProcessorTopology topology = new ProcessorTopology(\n            Collections.<ProcessorNode>emptyList(),\n            Collections.<String, SourceNode>emptyMap(),\n            Utils.<StateStoreSupplier>mkList(\n                    new MockStateStoreSupplier(storeName1, false),\n                    new MockStateStoreSupplier(storeName2, true)\n            )\n    );", "modifier": "private final", "type": "ProcessorTopology", "declarator": "topology = new ProcessorTopology(\n            Collections.<ProcessorNode>emptyList(),\n            Collections.<String, SourceNode>emptyMap(),\n            Utils.<StateStoreSupplier>mkList(\n                    new MockStateStoreSupplier(storeName1, false),\n                    new MockStateStoreSupplier(storeName2, true)\n            )\n    )", "var_name": "topology"}, {"original_string": "private final TopicPartition ktable = new TopicPartition(\"ktable1\", 0);", "modifier": "private final", "type": "TopicPartition", "declarator": "ktable = new TopicPartition(\"ktable1\", 0)", "var_name": "ktable"}, {"original_string": "private final Set<TopicPartition> ktablePartitions = Utils.mkSet(ktable);", "modifier": "private final", "type": "Set<TopicPartition>", "declarator": "ktablePartitions = Utils.mkSet(ktable)", "var_name": "ktablePartitions"}, {"original_string": "private final ProcessorTopology ktableTopology = new ProcessorTopology(\n            Collections.<ProcessorNode>emptyList(),\n            Collections.<String, SourceNode>emptyMap(),\n            Utils.<StateStoreSupplier>mkList(\n                    new MockStateStoreSupplier(ktable.topic(), true, false)\n            )\n    );", "modifier": "private final", "type": "ProcessorTopology", "declarator": "ktableTopology = new ProcessorTopology(\n            Collections.<ProcessorNode>emptyList(),\n            Collections.<String, SourceNode>emptyMap(),\n            Utils.<StateStoreSupplier>mkList(\n                    new MockStateStoreSupplier(ktable.topic(), true, false)\n            )\n    )", "var_name": "ktableTopology"}, {"original_string": "private final MockConsumer<byte[], byte[]> consumer = new MockConsumer<>(OffsetResetStrategy.EARLIEST);", "modifier": "private final", "type": "MockConsumer<byte[], byte[]>", "declarator": "consumer = new MockConsumer<>(OffsetResetStrategy.EARLIEST)", "var_name": "consumer"}, {"original_string": "private final ProcessorStateManagerTest.MockRestoreConsumer restoreStateConsumer = new ProcessorStateManagerTest.MockRestoreConsumer();", "modifier": "private final", "type": "ProcessorStateManagerTest.MockRestoreConsumer", "declarator": "restoreStateConsumer = new ProcessorStateManagerTest.MockRestoreConsumer()", "var_name": "restoreStateConsumer"}, {"original_string": "private final byte[] recordValue = intSerializer.serialize(null, 10);", "modifier": "private final", "type": "byte[]", "declarator": "recordValue = intSerializer.serialize(null, 10)", "var_name": "recordValue"}, {"original_string": "private final byte[] recordKey = intSerializer.serialize(null, 1);", "modifier": "private final", "type": "byte[]", "declarator": "recordKey = intSerializer.serialize(null, 1)", "var_name": "recordKey"}], "file": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StandbyTaskTest.java"}, "test_case": {"identifier": "testUpdate", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") @Test public", "return": "void", "body": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testUpdate() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n            StreamsConfig config = createConfig(baseDir);\n            StandbyTask task = new StandbyTask(taskId, applicationId, topicPartitions, topology, consumer, restoreStateConsumer, config, null);\n\n            restoreStateConsumer.assign(new ArrayList<>(task.changeLogPartitions()));\n\n            for (ConsumerRecord<Integer, Integer> record : Arrays.asList(\n                    new ConsumerRecord<>(partition2.topic(), partition2.partition(), 10, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, 1, 100),\n                    new ConsumerRecord<>(partition2.topic(), partition2.partition(), 20, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, 2, 100),\n                    new ConsumerRecord<>(partition2.topic(), partition2.partition(), 30, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, 3, 100))) {\n                restoreStateConsumer.bufferRecord(record);\n            }\n\n            for (Map.Entry<TopicPartition, Long> entry : task.checkpointedOffsets().entrySet()) {\n                TopicPartition partition = entry.getKey();\n                long offset = entry.getValue();\n                if (offset >= 0) {\n                    restoreStateConsumer.seek(partition, offset);\n                } else {\n                    restoreStateConsumer.seekToBeginning(singleton(partition));\n                }\n            }\n\n            task.update(partition2, restoreStateConsumer.poll(100).records(partition2));\n\n            StandbyContextImpl context = (StandbyContextImpl) task.context();\n            MockStateStoreSupplier.MockStateStore store1 =\n                    (MockStateStoreSupplier.MockStateStore) context.getStateMgr().getStore(storeName1);\n            MockStateStoreSupplier.MockStateStore store2 =\n                    (MockStateStoreSupplier.MockStateStore) context.getStateMgr().getStore(storeName2);\n\n            assertEquals(Collections.emptyList(), store1.keys);\n            assertEquals(Utils.mkList(1, 2, 3), store2.keys);\n\n            task.close();\n\n            File taskDir = new File(StreamThread.makeStateDir(applicationId, baseDir.getCanonicalPath()), taskId.toString());\n            OffsetCheckpoint checkpoint = new OffsetCheckpoint(new File(taskDir, ProcessorStateManager.CHECKPOINT_FILE_NAME));\n            Map<TopicPartition, Long> offsets = checkpoint.read();\n\n            assertEquals(1, offsets.size());\n            assertEquals(new Long(30L + 1L), offsets.get(partition2));\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }", "signature": "void testUpdate()", "full_signature": "@SuppressWarnings(\"unchecked\") @Test public void testUpdate()", "class_method_signature": "StandbyTaskTest.testUpdate()", "testcase": true, "constructor": false, "invocations": ["toFile", "createTempDirectory", "createConfig", "assign", "changeLogPartitions", "asList", "topic", "partition", "topic", "partition", "topic", "partition", "bufferRecord", "entrySet", "checkpointedOffsets", "getKey", "getValue", "seek", "seekToBeginning", "singleton", "update", "records", "poll", "context", "getStore", "getStateMgr", "getStore", "getStateMgr", "assertEquals", "emptyList", "assertEquals", "mkList", "close", "makeStateDir", "getCanonicalPath", "toString", "read", "assertEquals", "size", "assertEquals", "get", "delete"]}, "focal_class": {"identifier": "StandbyTask", "superclass": "extends AbstractTask", "interfaces": "", "fields": [{"original_string": "private final Map<TopicPartition, Long> checkpointedOffsets;", "modifier": "private final", "type": "Map<TopicPartition, Long>", "declarator": "checkpointedOffsets", "var_name": "checkpointedOffsets"}], "methods": [{"identifier": "StandbyTask", "parameters": "(TaskId id,\n                       String applicationId,\n                       Collection<TopicPartition> partitions,\n                       ProcessorTopology topology,\n                       Consumer<byte[], byte[]> consumer,\n                       Consumer<byte[], byte[]> restoreConsumer,\n                       StreamsConfig config,\n                       StreamsMetrics metrics)", "modifiers": "public", "return": "", "signature": " StandbyTask(TaskId id,\n                       String applicationId,\n                       Collection<TopicPartition> partitions,\n                       ProcessorTopology topology,\n                       Consumer<byte[], byte[]> consumer,\n                       Consumer<byte[], byte[]> restoreConsumer,\n                       StreamsConfig config,\n                       StreamsMetrics metrics)", "full_signature": "public  StandbyTask(TaskId id,\n                       String applicationId,\n                       Collection<TopicPartition> partitions,\n                       ProcessorTopology topology,\n                       Consumer<byte[], byte[]> consumer,\n                       Consumer<byte[], byte[]> restoreConsumer,\n                       StreamsConfig config,\n                       StreamsMetrics metrics)", "class_method_signature": "StandbyTask.StandbyTask(TaskId id,\n                       String applicationId,\n                       Collection<TopicPartition> partitions,\n                       ProcessorTopology topology,\n                       Consumer<byte[], byte[]> consumer,\n                       Consumer<byte[], byte[]> restoreConsumer,\n                       StreamsConfig config,\n                       StreamsMetrics metrics)", "testcase": false, "constructor": true}, {"identifier": "checkpointedOffsets", "parameters": "()", "modifiers": "public", "return": "Map<TopicPartition, Long>", "signature": "Map<TopicPartition, Long> checkpointedOffsets()", "full_signature": "public Map<TopicPartition, Long> checkpointedOffsets()", "class_method_signature": "StandbyTask.checkpointedOffsets()", "testcase": false, "constructor": false}, {"identifier": "changeLogPartitions", "parameters": "()", "modifiers": "public", "return": "Collection<TopicPartition>", "signature": "Collection<TopicPartition> changeLogPartitions()", "full_signature": "public Collection<TopicPartition> changeLogPartitions()", "class_method_signature": "StandbyTask.changeLogPartitions()", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(TopicPartition partition, List<ConsumerRecord<byte[], byte[]>> records)", "modifiers": "public", "return": "List<ConsumerRecord<byte[], byte[]>>", "signature": "List<ConsumerRecord<byte[], byte[]>> update(TopicPartition partition, List<ConsumerRecord<byte[], byte[]>> records)", "full_signature": "public List<ConsumerRecord<byte[], byte[]>> update(TopicPartition partition, List<ConsumerRecord<byte[], byte[]>> records)", "class_method_signature": "StandbyTask.update(TopicPartition partition, List<ConsumerRecord<byte[], byte[]>> records)", "testcase": false, "constructor": false}, {"identifier": "commit", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void commit()", "full_signature": "public void commit()", "class_method_signature": "StandbyTask.commit()", "testcase": false, "constructor": false}], "file": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java"}, "focal_method": {"identifier": "update", "parameters": "(TopicPartition partition, List<ConsumerRecord<byte[], byte[]>> records)", "modifiers": "public", "return": "List<ConsumerRecord<byte[], byte[]>>", "body": "public List<ConsumerRecord<byte[], byte[]>> update(TopicPartition partition, List<ConsumerRecord<byte[], byte[]>> records) {\n        return stateMgr.updateStandbyStates(partition, records);\n    }", "signature": "List<ConsumerRecord<byte[], byte[]>> update(TopicPartition partition, List<ConsumerRecord<byte[], byte[]>> records)", "full_signature": "public List<ConsumerRecord<byte[], byte[]>> update(TopicPartition partition, List<ConsumerRecord<byte[], byte[]>> records)", "class_method_signature": "StandbyTask.update(TopicPartition partition, List<ConsumerRecord<byte[], byte[]>> records)", "testcase": false, "constructor": false, "invocations": ["updateStandbyStates"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}