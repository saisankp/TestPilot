{"test_class": {"identifier": "DijkstraTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static HierarchyMapGraph test3;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "test3", "var_name": "test3"}, {"original_string": "private static HierarchyMapGraph test5;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "test5", "var_name": "test5"}, {"original_string": "private static HierarchyMapGraph test8;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "test8", "var_name": "test8"}, {"original_string": "private static HierarchyMapGraph testGraph1;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph1", "var_name": "testGraph1"}, {"original_string": "private static HierarchyMapGraph testGraph2;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph2", "var_name": "testGraph2"}, {"original_string": "private static HierarchyMapGraph testGraph3;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph3", "var_name": "testGraph3"}, {"original_string": "private static HierarchyMapGraph testGraph4;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph4", "var_name": "testGraph4"}, {"original_string": "private static boolean fastBackup;", "modifier": "private static", "type": "boolean", "declarator": "fastBackup", "var_name": "fastBackup"}], "file": "SoftwarePraktikum/src/algorithmen/DijkstraTest.java"}, "test_case": {"identifier": "testNeighbourhoodFast", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testNeighbourhoodFast() throws Exception {\n\t\tlong test = 0;\n\t\tboolean fehler;\n\t\tConfig.fastestPathMode = true;\n\t\t\n\t\t/*\n\t\t * Test 1 - Nullpointer als Graph - erwarte Fehler/Exception\n\t\t */\n\t\t/*\n\t\tDijkstra.H = 2;\n\t\tfehler = false;\n\t\ttry {\n\t\t\ttest = Dijkstra.neighbourhood(null, 1, true);\n\t\t} catch (Exception e) {\n\t\t\tfehler =true;\n\t\t}\n\t\t\n\t\tif (fehler == false)\n\t\t\tfail(\"Test 1: Einen Nullpointer zu uebergeben hat keine Exception geworfen\");\n\t\t*/\n\t\t\n\t\t/*\n\t\t * Test 2 - illegale Node-ID - nutze dazu test3\n\t\t */\n\t\t\n\t\tfehler = false;\n\t\ttry{\n\t\t\ttest = Dijkstra.neighbourhood(test3, 55,(byte)0, true);\n\t\t}catch(Exception e) {\n\t\t\tfehler = true;\n\t\t}\n\t\tif (fehler == false){\n\t\t\tfail(\"Test 2: Bei Eingabe einer ungueltigen Node-ID wurde keine Exception geworfen\");\n\t\t}\n\t\t\n\t\t/*\n\t\t * Test 3 - nutze test3 - erwarte fuer Startknoten 2 Ausgabe -1\n\t\t */\n\t\t\n\t\ttest = Dijkstra.neighbourhood(test3, 2, (byte)0,true);\n\t\tif (test != -1)\n\t\t\tfail(\"Test 3: Die vorwaerts-scuhe auf einem isolierten Knoten liefert nicht -1 sondern: \"+test);\n\t\t\n\t\t/*\n\t\t * Test 4 - nutze test3 - erwarte fuer Startknoten 2 Ausgabe -1\n\t\t */\n\t\t\n\t\ttest = Dijkstra.neighbourhood(test3, 2,(byte)0, false);\n\t\tif (test != -1)\n\t\t\tfail(\"Test 4: Die ruekwaerts-scuhe auf einem isolierten Knoten liefert nicht -1 sondern: \"+test);\n\t\t\n\t\t/*\n\t\t * Test 5 - nutze test5 - es existieren Kanten, aber wieder soll -1 ausgegben werden\n\t\t */\n\t\t\n\t\ttest = Dijkstra.neighbourhood(test5, 5, (byte)0,true);\n\t\tif (test != -1)\n\t\t\tfail(\"Test 5: Die vorwaerts-scuhe auf einem isolierten Knoten bzql. ausgehender Knoten liefert nicht -1 sondern: \"+test);\n\t\t\n\t\t\n\t\t/*\n\t\t * Test 6 - nutze test5 - es existieren Kanten, aber wieder soll -1 ausgegben werden\n\t\t */\n\t\t\n\t\ttest = Dijkstra.neighbourhood(test5, 2, (byte)0,false);\n\t\tif (test != -1)\n\t\t\tfail(\"Test 6: Die rueck.-scuhe auf einem isolierten Knoten bzql. eingehender Knoten liefert nicht -1 sondern: \"+test);\n\t\t\n\t\t\n\t\t/*\n\t\t * Test 7 - uebergebe einen leeren Graphen - erwarte auch hier -1\n\t\t */\n\t\tfehler = false;\n\t\t\n\t\ttry{\n\t\t\ttest = Dijkstra.neighbourhood(new HierarchyMapGraph(), 5, (byte)0,true);\n\t\t}catch(Exception e){\n\t\t\tfehler = true;\n\t\t}\n\t\tif (fehler == false)\n\t\t\tfail(\"Test 7: Der leere Graph liefert nicht -1 sondern: \"+test);\n\t\t\n\t\t\n\t\t/*\n\t\t * Test 8 - nutze test8 - es existiert ein Zykel - evtl. bringt dieser den Algo durcheinander - erwarte 10\n\t\t */\n\t\t\t/*\n\t\tDijkstra.H = 2;\t\t\n\t\ttest = Dijkstra.neighbourhood(test8, 1, true);\n\t\tif (test != 10)\n\t\t\tfail(\"Test 8: Der Graph mit trivialem Zykel liefert nicht 10 sondern: \"+test);\n\t\t\t*/\n\t\t\n\t\t/*\n\t\t * testGraph1 - teste korrekte Werte\n\t\t */\n\t\tConfig.H = 2;\n\t\ttest = Dijkstra.neighbourhood(testGraph1, 1,(byte)0, true);\n\t\tif (test!= 1*Config.getSpeedFactor(StreetType.MOTORWAY))\n\t\t\tfail(\"TestGraph1: Der Algo liefert nicht \"+1*Config.getSpeedFactor(StreetType.MOTORWAY)*10000+\" sondern: \"+test);\n\t\t\n\t\t\n\t\t/*\n\t\t * testGraph2 - teste korrekte Werte\n\t\t */\n\t\tConfig.H = 2;\n\t\ttest = Dijkstra.neighbourhood(testGraph2, 1,(byte)0, true);\n\t\tif (test!= 2*Config.getSpeedFactor(StreetType.MOTORWAY))\n\t\t\tfail(\"TestGraph2: Der Algo liefert nicht \"+2*Config.getSpeedFactor(StreetType.MOTORWAY)*10000+\" sondern: \"+test);\n\t\t\n\t\tConfig.H = 4;\n\t\ttest = Dijkstra.neighbourhood(testGraph2, 1, (byte)0,true);\n\t\tif (test!= 3*Config.getSpeedFactor(StreetType.MOTORWAY))\n\t\t\tfail(\"TestGraph2: Der Algo liefert nicht \"+3*Config.getSpeedFactor(StreetType.MOTORWAY)*10000+\" sondern: \"+test);\n\t\t\n\t\tConfig.H = 5;\n\t\ttest = Dijkstra.neighbourhood(testGraph2, 1,(byte)0, true);\n\t\tif (test!= 10*Config.getSpeedFactor(StreetType.MOTORWAY))\n\t\t\tfail(\"TestGraph2: Der Algo liefert nicht \"+10*Config.getSpeedFactor(StreetType.MOTORWAY)*10000+\" sondern: \"+test);\n\t\t\n\t\t\n\t\tConfig.H = 6;\n\t\ttest = Dijkstra.neighbourhood(testGraph2, 1, (byte)0,true);\n\t\tif (test != -1)\n\t\t\tfail(\"TestGraph2: Der Algo liefert nicht -1 sondern: \"+test);\n\t\t\n\t\t\n\t\t/*\n\t\t * testGraph3 - teste korrekte Werte\n\t\t */\n\t\tConfig.H = 3;\n\t\ttest = Dijkstra.neighbourhood(testGraph3, 1, (byte)0,true);\n\t\tif (test!= 1000*Config.getSpeedFactor(StreetType.MOTORWAY))\n\t\t\tfail(\"TestGraph3: Der Algo liefert nicht \"+1000*Config.getSpeedFactor(StreetType.MOTORWAY)*10000+\" sondern: \"+test);\n\t\t\n\t\tConfig.H = 4;\n\t\ttest = Dijkstra.neighbourhood(testGraph3, 1, (byte)0,true);\n\t\tif (test != -1)\n\t\t\tfail(\"TestGraph3: Der Algo liefert nicht -1 sondern: \"+test);\n\t\t\n\t\t\n\t\t/*\n\t\t * testGraph4 - teste korrekte Werte (nciht-trivialer Zykel, keine Dreiecksungleichung)\n\t\t */\n\t\t\n\t\tConfig.H = 2;\n\t\ttest = Dijkstra.neighbourhood(testGraph4, 1,(byte)0, true);\n\t\tif (test!= 2*Config.getSpeedFactor(StreetType.MOTORWAY))\n\t\t\tfail(\"TestGraph4: Der Algo liefert nicht \"+2*Config.getSpeedFactor(StreetType.MOTORWAY)*10000+\" sondern: \"+test);\n\t\t\n\t\tConfig.H = 3;\n\t\ttest = Dijkstra.neighbourhood(testGraph4, 1,(byte)0, true);\n\t\tif (test!= 3*Config.getSpeedFactor(StreetType.MOTORWAY))\n\t\t\tfail(\"TestGraph4: Der Algo liefert nicht \"+3*Config.getSpeedFactor(StreetType.MOTORWAY)*10000+\" sondern: \"+test);\n\t\t\n\t\tConfig.H = 4;\n\t\ttest = Dijkstra.neighbourhood(testGraph4, 1, (byte)0,true);\n\t\tif (test != -1)\n\t\t\tfail(\"TestGraph4: Der Algo liefert nicht -1 sondern: \"+test+\" evtl. Knoten doppelt begangen?\");\n\t\t\n\t\t\n\t\t/*\n\t\t * testGraph4 - teste korrekte Werte (nciht-trivialer Zykel, keine Dreiecksungleichung) fuer rueckwaerts\n\t\t */\n\n\t\t\n\t\tConfig.H = 2;\n\t\ttest = Dijkstra.neighbourhood(testGraph4, 2, (byte)0,false);\n\n\t\tif (test!= 1*Config.getSpeedFactor(StreetType.MOTORWAY))\n\t\t\tfail(\"TestGraph4: Der Algo(false) liefert nicht 1 sondern: \"+test);\n\n\t\t\n\t\tConfig.H = 3;\n\t\ttest = Dijkstra.neighbourhood(testGraph4, 2,(byte)0, false);\n\n\t\tif (test != -1)\n\t\t\tfail(\"TestGraph4: Der Algo(false) liefert nicht -1 sondern: \"+test);\n\n\t\t\n\t\tConfig.H = 4;\n\t\ttest = Dijkstra.neighbourhood(testGraph4, 2,(byte)0, false);\n\t\tif (test != -1)\n\t\t\tfail(\"TestGraph4: Der Algo(false) liefert nicht -1 sondern: \"+test+\" evtl. Knoten doppelt begangen?\");\n\t}", "signature": "void testNeighbourhoodFast()", "full_signature": "@Test public void testNeighbourhoodFast()", "class_method_signature": "DijkstraTest.testNeighbourhoodFast()", "testcase": true, "constructor": false, "invocations": ["neighbourhood", "fail", "neighbourhood", "fail", "neighbourhood", "fail", "neighbourhood", "fail", "neighbourhood", "fail", "neighbourhood", "fail", "neighbourhood", "getSpeedFactor", "fail", "getSpeedFactor", "neighbourhood", "getSpeedFactor", "fail", "getSpeedFactor", "neighbourhood", "getSpeedFactor", "fail", "getSpeedFactor", "neighbourhood", "getSpeedFactor", "fail", "getSpeedFactor", "neighbourhood", "fail", "neighbourhood", "getSpeedFactor", "fail", "getSpeedFactor", "neighbourhood", "fail", "neighbourhood", "getSpeedFactor", "fail", "getSpeedFactor", "neighbourhood", "getSpeedFactor", "fail", "getSpeedFactor", "neighbourhood", "fail", "neighbourhood", "getSpeedFactor", "fail", "neighbourhood", "fail", "neighbourhood", "fail"]}, "focal_class": {"identifier": "Dijkstra", "superclass": "", "interfaces": "", "fields": [{"original_string": "static boolean debug = false;", "modifier": "static", "type": "boolean", "declarator": "debug = false", "var_name": "debug"}, {"original_string": "private static Logger logger = Logger.getInstance();", "modifier": "private static", "type": "Logger", "declarator": "logger = Logger.getInstance()", "var_name": "logger"}], "methods": [{"identifier": "updateNeighbours", "parameters": "(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "modifiers": "private static", "return": "void", "signature": "void updateNeighbours(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "full_signature": "private static void updateNeighbours(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "class_method_signature": "Dijkstra.updateNeighbours(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "testcase": false, "constructor": false}, {"identifier": "neighbourhood", "parameters": "(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "modifiers": "public static", "return": "long", "signature": "long neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "full_signature": "public static long neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "class_method_signature": "Dijkstra.neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "testcase": false, "constructor": false}, {"identifier": "handleQueues", "parameters": "(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "modifiers": "private static", "return": "boolean", "signature": "boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "full_signature": "private static boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "class_method_signature": "Dijkstra.handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "testcase": false, "constructor": false}, {"identifier": "bidirectional", "parameters": "(MapGraph graph, int startnode, int endnode)", "modifiers": "public static", "return": "ArrayList<MapNode>", "signature": "ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode)", "full_signature": "public static ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode)", "class_method_signature": "Dijkstra.bidirectional(MapGraph graph, int startnode, int endnode)", "testcase": false, "constructor": false}, {"identifier": "handleQueues", "parameters": "(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "modifiers": "private static", "return": "boolean", "signature": "boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "full_signature": "private static boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "class_method_signature": "Dijkstra.handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "testcase": false, "constructor": false}, {"identifier": "bidirectional", "parameters": "(HierarchyMapGraph graph, int startnode, int endnode)", "modifiers": "public static", "return": "Path", "signature": "Path bidirectional(HierarchyMapGraph graph, int startnode, int endnode)", "full_signature": "public static Path bidirectional(HierarchyMapGraph graph, int startnode, int endnode)", "class_method_signature": "Dijkstra.bidirectional(HierarchyMapGraph graph, int startnode, int endnode)", "testcase": false, "constructor": false}], "file": "SoftwarePraktikum/src/algorithmen/Dijkstra.java"}, "focal_method": {"identifier": "neighbourhood", "parameters": "(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "modifiers": "public static", "return": "long", "body": "public static long neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward) throws Exception{\n\t\t\n\t\tif (graph == null) throw new EmptyInputException(\"Leerer Graph uebergeben\");\n\t\tif (graph.getNode(startnode) == null) throw new InvalidInputException(\"Ungueltige ID uebergeben\");\n\t\t\n\t\tint found = -1; //erster Knoten, der gefunden wird, ist der Startknoten, dieser wird nicht mitgezaehlt bei der Anzahl der Nachbarschaftsknoten\n\t\tfinal HashMap<Integer,Vertex> nodes = new HashMap<Integer,Vertex>(); //Liste in der alle besuchten Knoten gespeichert werden.\n\t\tfinal PrQueue queue = new PrQueue(); //Priority Queue, die alle erreichbaren Knoten enthaelt\n\t\t\n\t\tfinal Vertex start = new Vertex(graph.getNode(startnode),0); //Vertex ist die Hilfsklasse, in der zusaetzliche Infos ueber Knoten gespeichert werden.\n\t\tnodes.put(startnode, start);\n\t\t\n\t\tqueue.insert(start);\n\t\t\n\t\twhile (queue.getSize() != 0){\n\t\t\tfinal Vertex node = queue.extractMin();\n\t\t\tfinal HierarchyMapNode realNode = (HierarchyMapNode) node.node;\n\n\t\t\tfound++;\n\t\t\tif (found == Config.H) return node.getDist(); //Abbruchbedingung erfuellt\n\t\t\t\n\t\t\tIterator <HierarchyMapEdge> edges = null;\n\n\t\t\tif (forward){\n\t\t\t\tedges = realNode.getOutgoingEdgesByHierarchy(level).iterator();\n\t\t\t}else{\n\t\t\t\tedges = realNode.getIncomingEdgesByHierarchy(level).iterator();\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\twhile (edges.hasNext()){ //ueberpruefe alle benachbarten Knoten\n\t\t\t\tfinal HierarchyMapEdge newEdge = edges.next();\n\t\t\t\tupdateNeighbours(nodes, queue, newEdge, node, forward);\n\n\t\t\t}\n\t\t} return -1; //wenn man bis hier kommt, gibt es keine H erreichbaren Knoten\n\t}", "signature": "long neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "full_signature": "public static long neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "class_method_signature": "Dijkstra.neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "testcase": false, "constructor": false, "invocations": ["getNode", "getNode", "put", "insert", "getSize", "extractMin", "getDist", "iterator", "getOutgoingEdgesByHierarchy", "iterator", "getIncomingEdgesByHierarchy", "hasNext", "next", "updateNeighbours"]}, "repository": {"repo_id": 3716960, "url": "https://github.com/auxua/SWP-Routenplaner", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 5, "size": 13806, "license": "licensed"}}