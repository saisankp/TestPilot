{"test_class": {"identifier": "GrantHitchinsSolverTest", "superclass": "", "interfaces": "", "fields": [], "file": "jtstoolkit/src/test/java/ec/tstoolkit/maths/polynomials/GrantHitchinsSolverTest.java"}, "test_case": {"identifier": "testUnitRootd", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testUnitRootd() {\n        int N=12;\n        double[] c=new double[N+1];\n        c[0]=1;\n        c[N]=-1;\n        GrantHitchinsSolver solver=new GrantHitchinsSolver();\n        assertTrue(solver.factorize(Polynomial.of(c)));\n    }", "signature": "void testUnitRootd()", "full_signature": "@Test public void testUnitRootd()", "class_method_signature": "GrantHitchinsSolverTest.testUnitRootd()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "factorize", "of"]}, "focal_class": {"identifier": "GrantHitchinsSolver", "superclass": "", "interfaces": "implements IRootsSolver", "fields": [{"original_string": "private static final double ONE = 1.0, TWO = 2.0, ZERO = 0.0, TEN = 10.0,\n\t    P8 = 0.8, A8 = 8.0, A1P5 = 1.5, P4Z1 = 0.00001, P5 = 0.5,\n\t    P2Z1 = 0.001, P1 = 0.1, P3Z2 = 0.0002, FOUR = 4.0;", "modifier": "private static final", "type": "double", "declarator": "ONE = 1.0", "var_name": "ONE"}, {"original_string": "private static final int g_max = 100;", "modifier": "private static final", "type": "int", "declarator": "g_max = 100", "var_name": "g_max"}, {"original_string": "private double m_x, m_y, m_r, m_j, m_rx, m_jx;", "modifier": "private", "type": "double", "declarator": "m_x", "var_name": "m_x"}, {"original_string": "private double m_tol;", "modifier": "private", "type": "double", "declarator": "m_tol", "var_name": "m_tol"}, {"original_string": "private double[] m_b, m_c;", "modifier": "private", "type": "double[]", "declarator": "m_b", "var_name": "m_b"}, {"original_string": "private double m_fac;", "modifier": "private", "type": "double", "declarator": "m_fac", "var_name": "m_fac"}, {"original_string": "private static final double g_eps = Constants.getEpsilon(), g_small = 1e-15,\n\t    g_cmax = Math.sqrt(Double.MAX_VALUE);", "modifier": "private static final", "type": "double", "declarator": "g_eps = Constants.getEpsilon()", "var_name": "g_eps"}, {"original_string": "private static final double g_eps2 = g_eps * 1e4;", "modifier": "private static final", "type": "double", "declarator": "g_eps2 = g_eps * 1e4", "var_name": "g_eps2"}, {"original_string": "private Polynomial m_remainder;", "modifier": "private", "type": "Polynomial", "declarator": "m_remainder", "var_name": "m_remainder"}, {"original_string": "private ec.tstoolkit.maths.Complex[] m_roots;", "modifier": "private", "type": "ec.tstoolkit.maths.Complex[]", "declarator": "m_roots", "var_name": "m_roots"}], "methods": [{"identifier": "GrantHitchinsSolver", "parameters": "()", "modifiers": "public", "return": "", "signature": " GrantHitchinsSolver()", "full_signature": "public  GrantHitchinsSolver()", "class_method_signature": "GrantHitchinsSolver.GrantHitchinsSolver()", "testcase": false, "constructor": true}, {"identifier": "evaluate", "parameters": "(double[] a, int n, double tol)", "modifiers": "private", "return": "boolean", "signature": "boolean evaluate(double[] a, int n, double tol)", "full_signature": "private boolean evaluate(double[] a, int n, double tol)", "class_method_signature": "GrantHitchinsSolver.evaluate(double[] a, int n, double tol)", "testcase": false, "constructor": false}, {"identifier": "clear", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void clear()", "full_signature": "@Override public void clear()", "class_method_signature": "GrantHitchinsSolver.clear()", "testcase": false, "constructor": false}, {"identifier": "compositedeflation", "parameters": "(double[] a, int n, double[] rez,\n\t    double[] imz)", "modifiers": "private", "return": "void", "signature": "void compositedeflation(double[] a, int n, double[] rez,\n\t    double[] imz)", "full_signature": "private void compositedeflation(double[] a, int n, double[] rez,\n\t    double[] imz)", "class_method_signature": "GrantHitchinsSolver.compositedeflation(double[] a, int n, double[] rez,\n\t    double[] imz)", "testcase": false, "constructor": false}, {"identifier": "deflate", "parameters": "(double[] a, int n, double[] rez, double[] imz,\n\t    double eps)", "modifiers": "private", "return": "int", "signature": "int deflate(double[] a, int n, double[] rez, double[] imz,\n\t    double eps)", "full_signature": "private int deflate(double[] a, int n, double[] rez, double[] imz,\n\t    double eps)", "class_method_signature": "GrantHitchinsSolver.deflate(double[] a, int n, double[] rez, double[] imz,\n\t    double eps)", "testcase": false, "constructor": false}, {"identifier": "deflatecomplexroot", "parameters": "(double[] a, int n, double[] rez, double[] imz)", "modifiers": "private", "return": "int", "signature": "int deflatecomplexroot(double[] a, int n, double[] rez, double[] imz)", "full_signature": "private int deflatecomplexroot(double[] a, int n, double[] rez, double[] imz)", "class_method_signature": "GrantHitchinsSolver.deflatecomplexroot(double[] a, int n, double[] rez, double[] imz)", "testcase": false, "constructor": false}, {"identifier": "deflaterealroot", "parameters": "(double[] a, int n, double[] rez, double[] imz)", "modifiers": "private", "return": "int", "signature": "int deflaterealroot(double[] a, int n, double[] rez, double[] imz)", "full_signature": "private int deflaterealroot(double[] a, int n, double[] rez, double[] imz)", "class_method_signature": "GrantHitchinsSolver.deflaterealroot(double[] a, int n, double[] rez, double[] imz)", "testcase": false, "constructor": false}, {"identifier": "factorize", "parameters": "(Polynomial p)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean factorize(Polynomial p)", "full_signature": "@Override public boolean factorize(Polynomial p)", "class_method_signature": "GrantHitchinsSolver.factorize(Polynomial p)", "testcase": false, "constructor": false}, {"identifier": "getTol", "parameters": "()", "modifiers": "public", "return": "double", "signature": "double getTol()", "full_signature": "public double getTol()", "class_method_signature": "GrantHitchinsSolver.getTol()", "testcase": false, "constructor": false}, {"identifier": "isrealroot", "parameters": "(double[] a, int n, double tol)", "modifiers": "private", "return": "boolean", "signature": "boolean isrealroot(double[] a, int n, double tol)", "full_signature": "private boolean isrealroot(double[] a, int n, double tol)", "class_method_signature": "GrantHitchinsSolver.isrealroot(double[] a, int n, double tol)", "testcase": false, "constructor": false}, {"identifier": "remainder", "parameters": "()", "modifiers": "@Override public", "return": "Polynomial", "signature": "Polynomial remainder()", "full_signature": "@Override public Polynomial remainder()", "class_method_signature": "GrantHitchinsSolver.remainder()", "testcase": false, "constructor": false}, {"identifier": "exemplar", "parameters": "()", "modifiers": "@Override public", "return": "GrantHitchinsSolver", "signature": "GrantHitchinsSolver exemplar()", "full_signature": "@Override public GrantHitchinsSolver exemplar()", "class_method_signature": "GrantHitchinsSolver.exemplar()", "testcase": false, "constructor": false}, {"identifier": "rescale_a", "parameters": "(double[] a, int n)", "modifiers": "private", "return": "void", "signature": "void rescale_a(double[] a, int n)", "full_signature": "private void rescale_a(double[] a, int n)", "class_method_signature": "GrantHitchinsSolver.rescale_a(double[] a, int n)", "testcase": false, "constructor": false}, {"identifier": "roots", "parameters": "()", "modifiers": "@Override public", "return": "Complex[]", "signature": "Complex[] roots()", "full_signature": "@Override public Complex[] roots()", "class_method_signature": "GrantHitchinsSolver.roots()", "testcase": false, "constructor": false}, {"identifier": "scale_a", "parameters": "(double[] a, int n)", "modifiers": "private", "return": "void", "signature": "void scale_a(double[] a, int n)", "full_signature": "private void scale_a(double[] a, int n)", "class_method_signature": "GrantHitchinsSolver.scale_a(double[] a, int n)", "testcase": false, "constructor": false}, {"identifier": "search", "parameters": "(double[] a, int n, double tol)", "modifiers": "private", "return": "boolean", "signature": "boolean search(double[] a, int n, double tol)", "full_signature": "private boolean search(double[] a, int n, double tol)", "class_method_signature": "GrantHitchinsSolver.search(double[] a, int n, double tol)", "testcase": false, "constructor": false}, {"identifier": "setTol", "parameters": "(double tol)", "modifiers": "public", "return": "void", "signature": "void setTol(double tol)", "full_signature": "public void setTol(double tol)", "class_method_signature": "GrantHitchinsSolver.setTol(double tol)", "testcase": false, "constructor": false}, {"identifier": "solve", "parameters": "(double[] a, int n, double[] rez, double[] imz)", "modifiers": "private", "return": "boolean", "signature": "boolean solve(double[] a, int n, double[] rez, double[] imz)", "full_signature": "private boolean solve(double[] a, int n, double[] rez, double[] imz)", "class_method_signature": "GrantHitchinsSolver.solve(double[] a, int n, double[] rez, double[] imz)", "testcase": false, "constructor": false}, {"identifier": "solve", "parameters": "(double[] a, int n, double[] rez, double[] imz,\n\t    boolean reentry, double eps)", "modifiers": "private", "return": "int", "signature": "int solve(double[] a, int n, double[] rez, double[] imz,\n\t    boolean reentry, double eps)", "full_signature": "private int solve(double[] a, int n, double[] rez, double[] imz,\n\t    boolean reentry, double eps)", "class_method_signature": "GrantHitchinsSolver.solve(double[] a, int n, double[] rez, double[] imz,\n\t    boolean reentry, double eps)", "testcase": false, "constructor": false}, {"identifier": "solve1", "parameters": "(double[] a, double[] rez, double[] imz)", "modifiers": "private", "return": "void", "signature": "void solve1(double[] a, double[] rez, double[] imz)", "full_signature": "private void solve1(double[] a, double[] rez, double[] imz)", "class_method_signature": "GrantHitchinsSolver.solve1(double[] a, double[] rez, double[] imz)", "testcase": false, "constructor": false}, {"identifier": "solve2", "parameters": "(double[] a, double[] rez, double[] imz)", "modifiers": "private", "return": "void", "signature": "void solve2(double[] a, double[] rez, double[] imz)", "full_signature": "private void solve2(double[] a, double[] rez, double[] imz)", "class_method_signature": "GrantHitchinsSolver.solve2(double[] a, double[] rez, double[] imz)", "testcase": false, "constructor": false}, {"identifier": "solven", "parameters": "(double[] a, int n, double[] rez, double[] imz,\n\t    boolean reentry, double eps)", "modifiers": "private", "return": "int", "signature": "int solven(double[] a, int n, double[] rez, double[] imz,\n\t    boolean reentry, double eps)", "full_signature": "private int solven(double[] a, int n, double[] rez, double[] imz,\n\t    boolean reentry, double eps)", "class_method_signature": "GrantHitchinsSolver.solven(double[] a, int n, double[] rez, double[] imz,\n\t    boolean reentry, double eps)", "testcase": false, "constructor": false}, {"identifier": "step1", "parameters": "(double[] a, int n)", "modifiers": "private", "return": "void", "signature": "void step1(double[] a, int n)", "full_signature": "private void step1(double[] a, int n)", "class_method_signature": "GrantHitchinsSolver.step1(double[] a, int n)", "testcase": false, "constructor": false}], "file": "jtstoolkit/src/main/java/ec/tstoolkit/maths/polynomials/GrantHitchinsSolver.java"}, "focal_method": {"identifier": "factorize", "parameters": "(Polynomial p)", "modifiers": "@Override public", "return": "boolean", "body": "@Override\n    public boolean factorize(Polynomial p) {\n\tint degree = p.getDegree();\n\twhile ((degree > 0) && (p.get(degree) == 0))\n\t    --degree;\n\tif (degree == 0)\n\t    return false;\n\tdouble[] a = new double[degree + 1];\n\tfor (int i = 0; i <= degree; ++i)\n\t    a[i] = p.get(degree - i);\n\tdouble[] rez = new double[degree];\n\tdouble[] imz = new double[degree];\n\ttry {\n\t    if (this.solve(a, a.length, rez, imz)) {\n\t\t// create roots...\n\t\tm_roots = new ec.tstoolkit.maths.Complex[degree];\n\t\tfor (int i = 0; i < degree; ++i)\n\t\t    m_roots[i] = ec.tstoolkit.maths.Complex\n\t\t\t    .cart(rez[i], imz[i]);\n\t\tm_remainder = Polynomial.valueOf(p.get(p.getDegree()));\n\t\treturn true;\n\t    } else\n\t\treturn false;\n\t} catch (PolynomialException ex) {\n\t    return false;\n\t}\n    }", "signature": "boolean factorize(Polynomial p)", "full_signature": "@Override public boolean factorize(Polynomial p)", "class_method_signature": "GrantHitchinsSolver.factorize(Polynomial p)", "testcase": false, "constructor": false, "invocations": ["getDegree", "get", "get", "solve", "cart", "valueOf", "get", "getDegree"]}, "repository": {"repo_id": 28178086, "url": "https://github.com/jdemetra/jdemetra-core", "stars": 24, "created": "12/18/2014 10:00:58 AM +00:00", "updates": "2020-01-17T15:50:24+00:00", "fork": "False", "license": "licensed"}}