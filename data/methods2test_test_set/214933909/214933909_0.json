{"test_class": {"identifier": "AdvancedModStrategyTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static int MOD = 10;", "modifier": "private static", "type": "int", "declarator": "MOD = 10", "var_name": "MOD"}, {"original_string": "private static String logicDbName = \"db\";", "modifier": "private static", "type": "String", "declarator": "logicDbName = \"db\"", "var_name": "logicDbName"}, {"original_string": "private static String tableName = \"table\";", "modifier": "private static", "type": "String", "declarator": "tableName = \"table\"", "var_name": "tableName"}, {"original_string": "private static String columnName = \"CountryID\";", "modifier": "private static", "type": "String", "declarator": "columnName = \"CountryID\"", "var_name": "columnName"}, {"original_string": "private static String xolumnName = \"XountryID\";", "modifier": "private static", "type": "String", "declarator": "xolumnName = \"XountryID\"", "var_name": "xolumnName"}, {"original_string": "private AdvancedModStrategy strategy;", "modifier": "private", "type": "AdvancedModStrategy", "declarator": "strategy", "var_name": "strategy"}, {"original_string": "public static Object[][] ireleventColumnExpression = new Object[][]{\n        {all(), xop(EQUAL, 0)},\n        {all(), xop(EQUAL, 1)},\n        {all(), xop(EQUAL, MOD + 1)},\n        {all(), xop(EQUAL, MOD - 1)},\n        {all(), not(xop(EQUAL, 0))},\n        {all(), not(not(xop(EQUAL, 0)))},\n        \n        {all(), xop(NOT_EQUAL, 0)},\n        {all(), not(xop(NOT_EQUAL, 0))},\n        {all(), not(not(xop(NOT_EQUAL, 0)))},\n\n        {all(), xop(GREATER_THAN, 0)},\n        {all(), not(xop(GREATER_THAN, 0))},\n        {all(), not(not(xop(GREATER_THAN, 0)))},\n\n        {all(), xop(LESS_THAN, 0)},\n        {all(), not(xop(LESS_THAN, 0))},\n        {all(), not(not(xop(LESS_THAN, 0)))},\n\n        {all(), xop(GREATER_THAN_OR_EQUAL, 0)},\n        {all(), not(xop(GREATER_THAN_OR_EQUAL, 0))},\n        {all(), not(not(xop(GREATER_THAN_OR_EQUAL, 0)))},\n\n        {all(), xop(LESS_THAN_OR_EQUAL, 0)},\n        {all(), not(xop(LESS_THAN_OR_EQUAL, 0))},\n        {all(), not(not(xop(LESS_THAN_OR_EQUAL, 0)))},\n\n        {all(), xbetween(0, 1)},\n        {all(), not(xbetween(0, 1))},\n        {all(), not(not(xbetween(0, 1)))},\n\n        {all(), xop(IN, Arrays.asList(0, 1, 2, 3))},\n        {all(), not(xop(IN, Arrays.asList(0, 1, 2, 3)))},\n        {all(), not(not(xop(IN, Arrays.asList(0, 1, 2, 3))))},\n\n        {all(), xop(NOT_IN, Arrays.asList(0, 1, 2, 3))},\n        {all(), not(xop(NOT_IN, Arrays.asList(0, 1, 2, 3)))},\n        {all(), not(not(xop(NOT_IN, Arrays.asList(0, 1, 2, 3))))},\n\n        {all(), xop(LIKE, \"%1\")},\n        {all(), not(xop(LIKE, \"%1\"))},\n        {all(), not(not(xop(LIKE, \"%1\")))},\n\n        {all(), xop(NOT_LIKE, \"%1\")},\n        {all(), not(xop(NOT_LIKE, \"%1\"))},\n        {all(), not(not(xop(NOT_LIKE, \"%1\")))},\n\n        {all(), xop(IS_NULL, null)},\n        {all(), not(xop(IS_NULL, null))},\n        {all(), not(not(xop(IS_NULL, null)))},\n\n        {all(), xop(IS_NOT_NULL, null)},\n        {all(), not(xop(IS_NOT_NULL, null))},\n        {all(), not(not(xop(IS_NOT_NULL, null)))},\n    };", "modifier": "public static", "type": "Object[][]", "declarator": "ireleventColumnExpression = new Object[][]{\n        {all(), xop(EQUAL, 0)},\n        {all(), xop(EQUAL, 1)},\n        {all(), xop(EQUAL, MOD + 1)},\n        {all(), xop(EQUAL, MOD - 1)},\n        {all(), not(xop(EQUAL, 0))},\n        {all(), not(not(xop(EQUAL, 0)))},\n        \n        {all(), xop(NOT_EQUAL, 0)},\n        {all(), not(xop(NOT_EQUAL, 0))},\n        {all(), not(not(xop(NOT_EQUAL, 0)))},\n\n        {all(), xop(GREATER_THAN, 0)},\n        {all(), not(xop(GREATER_THAN, 0))},\n        {all(), not(not(xop(GREATER_THAN, 0)))},\n\n        {all(), xop(LESS_THAN, 0)},\n        {all(), not(xop(LESS_THAN, 0))},\n        {all(), not(not(xop(LESS_THAN, 0)))},\n\n        {all(), xop(GREATER_THAN_OR_EQUAL, 0)},\n        {all(), not(xop(GREATER_THAN_OR_EQUAL, 0))},\n        {all(), not(not(xop(GREATER_THAN_OR_EQUAL, 0)))},\n\n        {all(), xop(LESS_THAN_OR_EQUAL, 0)},\n        {all(), not(xop(LESS_THAN_OR_EQUAL, 0))},\n        {all(), not(not(xop(LESS_THAN_OR_EQUAL, 0)))},\n\n        {all(), xbetween(0, 1)},\n        {all(), not(xbetween(0, 1))},\n        {all(), not(not(xbetween(0, 1)))},\n\n        {all(), xop(IN, Arrays.asList(0, 1, 2, 3))},\n        {all(), not(xop(IN, Arrays.asList(0, 1, 2, 3)))},\n        {all(), not(not(xop(IN, Arrays.asList(0, 1, 2, 3))))},\n\n        {all(), xop(NOT_IN, Arrays.asList(0, 1, 2, 3))},\n        {all(), not(xop(NOT_IN, Arrays.asList(0, 1, 2, 3)))},\n        {all(), not(not(xop(NOT_IN, Arrays.asList(0, 1, 2, 3))))},\n\n        {all(), xop(LIKE, \"%1\")},\n        {all(), not(xop(LIKE, \"%1\"))},\n        {all(), not(not(xop(LIKE, \"%1\")))},\n\n        {all(), xop(NOT_LIKE, \"%1\")},\n        {all(), not(xop(NOT_LIKE, \"%1\"))},\n        {all(), not(not(xop(NOT_LIKE, \"%1\")))},\n\n        {all(), xop(IS_NULL, null)},\n        {all(), not(xop(IS_NULL, null))},\n        {all(), not(not(xop(IS_NULL, null)))},\n\n        {all(), xop(IS_NOT_NULL, null)},\n        {all(), not(xop(IS_NOT_NULL, null))},\n        {all(), not(not(xop(IS_NOT_NULL, null)))},\n    }", "var_name": "ireleventColumnExpression"}, {"original_string": "public static Object[][] equalExpression = new Object[][]{\n            {set(0), op(EQUAL, 0)},\n            {set(0), op(EQUAL, MOD)},\n            {set(0), op(EQUAL, MOD * 2)},\n            {set(1), op(EQUAL, 1)},\n            {set(1), op(EQUAL, 1 + MOD)},\n            {set(1), op(EQUAL, 1 + MOD * 2)},\n            {set(MOD - 1), op(EQUAL, MOD -1)},\n            {set(MOD - 1), op(EQUAL, MOD * 2 -1)},\n    };", "modifier": "public static", "type": "Object[][]", "declarator": "equalExpression = new Object[][]{\n            {set(0), op(EQUAL, 0)},\n            {set(0), op(EQUAL, MOD)},\n            {set(0), op(EQUAL, MOD * 2)},\n            {set(1), op(EQUAL, 1)},\n            {set(1), op(EQUAL, 1 + MOD)},\n            {set(1), op(EQUAL, 1 + MOD * 2)},\n            {set(MOD - 1), op(EQUAL, MOD -1)},\n            {set(MOD - 1), op(EQUAL, MOD * 2 -1)},\n    }", "var_name": "equalExpression"}, {"original_string": "public static Object[][] notSupportedExpression = new Object[][]{\n            {all(), op(GREATER_THAN, 1)},\n            {all(), op(GREATER_THAN_OR_EQUAL, 1)},\n            {all(), op(LESS_THAN, 1)},\n            {all(), op(LESS_THAN_OR_EQUAL, 1)},\n            {all(), op(LIKE, \"%1\")},\n            {all(), op(NOT_LIKE, \"%1\")},\n            {all(), op(IS_NULL, null)},\n            {all(), op(IS_NOT_NULL, null)},\n\n            {all(), not(op(GREATER_THAN, 1))},\n            {all(), not(op(GREATER_THAN_OR_EQUAL, 1))},\n            {all(), not(op(LESS_THAN, 1))},\n            {all(), not(op(LESS_THAN_OR_EQUAL, 1))},\n            {all(), not(op(LIKE, \"%1\"))},\n            {all(), not(op(NOT_LIKE, \"%1\"))},\n            {all(), not(op(IS_NULL, null))},\n            {all(), not(op(IS_NOT_NULL, null))},\n\n            {all(), not(not(op(GREATER_THAN, 1)))},\n            {all(), not(not(op(GREATER_THAN_OR_EQUAL, 1)))},\n            {all(), not(not(op(LESS_THAN, 1)))},\n            {all(), not(not(op(LESS_THAN_OR_EQUAL, 1)))},\n            {all(), not(not(op(LIKE, \"%1\")))},\n            {all(), not(not(op(NOT_LIKE, \"%1\")))},\n            {all(), not(not(op(IS_NULL, null)))},\n            {all(), not(not(op(IS_NOT_NULL, null)))},\n    };", "modifier": "public static", "type": "Object[][]", "declarator": "notSupportedExpression = new Object[][]{\n            {all(), op(GREATER_THAN, 1)},\n            {all(), op(GREATER_THAN_OR_EQUAL, 1)},\n            {all(), op(LESS_THAN, 1)},\n            {all(), op(LESS_THAN_OR_EQUAL, 1)},\n            {all(), op(LIKE, \"%1\")},\n            {all(), op(NOT_LIKE, \"%1\")},\n            {all(), op(IS_NULL, null)},\n            {all(), op(IS_NOT_NULL, null)},\n\n            {all(), not(op(GREATER_THAN, 1))},\n            {all(), not(op(GREATER_THAN_OR_EQUAL, 1))},\n            {all(), not(op(LESS_THAN, 1))},\n            {all(), not(op(LESS_THAN_OR_EQUAL, 1))},\n            {all(), not(op(LIKE, \"%1\"))},\n            {all(), not(op(NOT_LIKE, \"%1\"))},\n            {all(), not(op(IS_NULL, null))},\n            {all(), not(op(IS_NOT_NULL, null))},\n\n            {all(), not(not(op(GREATER_THAN, 1)))},\n            {all(), not(not(op(GREATER_THAN_OR_EQUAL, 1)))},\n            {all(), not(not(op(LESS_THAN, 1)))},\n            {all(), not(not(op(LESS_THAN_OR_EQUAL, 1)))},\n            {all(), not(not(op(LIKE, \"%1\")))},\n            {all(), not(not(op(NOT_LIKE, \"%1\")))},\n            {all(), not(not(op(IS_NULL, null)))},\n            {all(), not(not(op(IS_NOT_NULL, null)))},\n    }", "var_name": "notSupportedExpression"}, {"original_string": "public static Object[][] betweenExpression = new Object[][]{\n            {set(1, 2, 3), between(1, 3)},\n            {set(1, 2, 3), between(MOD + 1, MOD + 3)},\n            {set(1, 2, 3), between(MOD * 2 + 1, MOD * 2 + 3)},\n            {set(0, 1, 2, 3, 8, 9), between(8,  13)},\n            {set(0, 1, 2, 3, 8, 9), between(MOD + 8,  MOD + 13)},\n            {set(0, 1, 2, 3, 8, 9), between(MOD * 2 + 8,  MOD * 2 + 13)},\n            \n            {all(), notBetween(1, 3)},\n            {all(), notBetween(MOD + 1, MOD + 3)},\n            {all(), not(between(MOD * 2 + 1, MOD * 2 + 3))},\n            {all(), not(not(notBetween(1, 3)))},\n            {set(1, 2, 3), not(not(between(1, 3)))},\n            {set(1, 2, 3), not(not(between(MOD + 1, MOD + 3)))},\n            {set(1, 2, 3), not(notBetween(MOD * 2 + 1, MOD * 2 + 3))},            \n    };", "modifier": "public static", "type": "Object[][]", "declarator": "betweenExpression = new Object[][]{\n            {set(1, 2, 3), between(1, 3)},\n            {set(1, 2, 3), between(MOD + 1, MOD + 3)},\n            {set(1, 2, 3), between(MOD * 2 + 1, MOD * 2 + 3)},\n            {set(0, 1, 2, 3, 8, 9), between(8,  13)},\n            {set(0, 1, 2, 3, 8, 9), between(MOD + 8,  MOD + 13)},\n            {set(0, 1, 2, 3, 8, 9), between(MOD * 2 + 8,  MOD * 2 + 13)},\n            \n            {all(), notBetween(1, 3)},\n            {all(), notBetween(MOD + 1, MOD + 3)},\n            {all(), not(between(MOD * 2 + 1, MOD * 2 + 3))},\n            {all(), not(not(notBetween(1, 3)))},\n            {set(1, 2, 3), not(not(between(1, 3)))},\n            {set(1, 2, 3), not(not(between(MOD + 1, MOD + 3)))},\n            {set(1, 2, 3), not(notBetween(MOD * 2 + 1, MOD * 2 + 3))},            \n    }", "var_name": "betweenExpression"}, {"original_string": "public static Object[][] inExpression = new Object[][]{            \n            {set(1, 2, 3), in(1, 2, 3)},\n            {set(1, 2, 3), in(MOD + 1, MOD + 2, MOD + 3)},\n\n            {all(), notIn(1, 2, 3)},\n            {all(), not(in(1, 2, 3))},\n            {all(), not(not(not(in(1, 2, 3))))},\n            {all(), not(not(notIn(1, 2, 3)))},\n            {set(1, 2, 3), not(not(in(1, 2, 3)))},\n            {set(1, 2, 3), not(notIn(MOD + 1, MOD + 2, MOD + 3))},\n    };", "modifier": "public static", "type": "Object[][]", "declarator": "inExpression = new Object[][]{            \n            {set(1, 2, 3), in(1, 2, 3)},\n            {set(1, 2, 3), in(MOD + 1, MOD + 2, MOD + 3)},\n\n            {all(), notIn(1, 2, 3)},\n            {all(), not(in(1, 2, 3))},\n            {all(), not(not(not(in(1, 2, 3))))},\n            {all(), not(not(notIn(1, 2, 3)))},\n            {set(1, 2, 3), not(not(in(1, 2, 3)))},\n            {set(1, 2, 3), not(notIn(MOD + 1, MOD + 2, MOD + 3))},\n    }", "var_name": "inExpression"}, {"original_string": "public static Object[][] equalCombine = new Object[][]{\n            //Test for combination EQUAL\n            {set(0, 1), or(op(EQUAL, 0), op(EQUAL, 1))},\n            {set(0, 1), or(op(EQUAL, MOD), op(EQUAL, MOD + 1))},\n            {set(0, 1), or(op(EQUAL, MOD * 2), op(EQUAL, MOD * 2 + 1))},\n            \n            {set(0, 1, 2), or(op(EQUAL, 0), op(EQUAL, 1), op(EQUAL, 2))},\n            {set(0, 1, 2), or(op(EQUAL, MOD), op(EQUAL, MOD + 1), op(EQUAL, MOD + 2))},\n            {set(0, 1, 2), or(op(EQUAL, MOD * 2), op(EQUAL, MOD * 2 + 1), op(EQUAL, MOD * 2 + 2))},\n\n            {non(), and(op(EQUAL, 0), op(EQUAL, 1))},\n            {non(), and(op(EQUAL, MOD), op(EQUAL, MOD + 1))},\n            {non(), and(op(EQUAL, MOD * 2), op(EQUAL, MOD * 2 + 1))},\n            \n            {non(), and(op(EQUAL, 0), op(EQUAL, 1), op(EQUAL, 2))},\n            {non(), and(op(EQUAL, MOD), op(EQUAL, MOD + 1), op(EQUAL, MOD + 2))},\n            {non(), and(op(EQUAL, MOD * 2), op(EQUAL, MOD * 2 + 1), op(EQUAL, MOD * 2 + 2))},\n            \n            {all(), or(op(EQUAL, 0), op(NOT_EQUAL, 1))},\n            {all(), or(op(EQUAL, 0), op(GREATER_THAN, 1))},\n            {all(), or(op(EQUAL, 0), op(GREATER_THAN_OR_EQUAL, 1))},\n            {all(), or(op(EQUAL, 0), op(LESS_THAN, 1))},\n            {all(), or(op(EQUAL, 0), op(LESS_THAN_OR_EQUAL, 1))},\n            {all(), or(op(EQUAL, 0), notBetween(0, 2))},\n            {all(), or(op(EQUAL, 0), notIn(0, 2))},\n\n            {set(0), and(op(EQUAL, 0), op(NOT_EQUAL, 1))},\n            {set(0), and(op(EQUAL, 0), op(GREATER_THAN, 1))},\n            {set(0), and(op(EQUAL, 0), op(GREATER_THAN_OR_EQUAL, 1))},\n            {set(0), and(op(EQUAL, 0), op(LESS_THAN, 1))},\n            {set(0), and(op(EQUAL, 0), op(LESS_THAN_OR_EQUAL, 1))},\n            {set(0), and(op(EQUAL, 0), notBetween(0, 2))},\n            {set(0), and(op(EQUAL, 0), notIn(0, 2))},\n    };", "modifier": "public static", "type": "Object[][]", "declarator": "equalCombine = new Object[][]{\n            //Test for combination EQUAL\n            {set(0, 1), or(op(EQUAL, 0), op(EQUAL, 1))},\n            {set(0, 1), or(op(EQUAL, MOD), op(EQUAL, MOD + 1))},\n            {set(0, 1), or(op(EQUAL, MOD * 2), op(EQUAL, MOD * 2 + 1))},\n            \n            {set(0, 1, 2), or(op(EQUAL, 0), op(EQUAL, 1), op(EQUAL, 2))},\n            {set(0, 1, 2), or(op(EQUAL, MOD), op(EQUAL, MOD + 1), op(EQUAL, MOD + 2))},\n            {set(0, 1, 2), or(op(EQUAL, MOD * 2), op(EQUAL, MOD * 2 + 1), op(EQUAL, MOD * 2 + 2))},\n\n            {non(), and(op(EQUAL, 0), op(EQUAL, 1))},\n            {non(), and(op(EQUAL, MOD), op(EQUAL, MOD + 1))},\n            {non(), and(op(EQUAL, MOD * 2), op(EQUAL, MOD * 2 + 1))},\n            \n            {non(), and(op(EQUAL, 0), op(EQUAL, 1), op(EQUAL, 2))},\n            {non(), and(op(EQUAL, MOD), op(EQUAL, MOD + 1), op(EQUAL, MOD + 2))},\n            {non(), and(op(EQUAL, MOD * 2), op(EQUAL, MOD * 2 + 1), op(EQUAL, MOD * 2 + 2))},\n            \n            {all(), or(op(EQUAL, 0), op(NOT_EQUAL, 1))},\n            {all(), or(op(EQUAL, 0), op(GREATER_THAN, 1))},\n            {all(), or(op(EQUAL, 0), op(GREATER_THAN_OR_EQUAL, 1))},\n            {all(), or(op(EQUAL, 0), op(LESS_THAN, 1))},\n            {all(), or(op(EQUAL, 0), op(LESS_THAN_OR_EQUAL, 1))},\n            {all(), or(op(EQUAL, 0), notBetween(0, 2))},\n            {all(), or(op(EQUAL, 0), notIn(0, 2))},\n\n            {set(0), and(op(EQUAL, 0), op(NOT_EQUAL, 1))},\n            {set(0), and(op(EQUAL, 0), op(GREATER_THAN, 1))},\n            {set(0), and(op(EQUAL, 0), op(GREATER_THAN_OR_EQUAL, 1))},\n            {set(0), and(op(EQUAL, 0), op(LESS_THAN, 1))},\n            {set(0), and(op(EQUAL, 0), op(LESS_THAN_OR_EQUAL, 1))},\n            {set(0), and(op(EQUAL, 0), notBetween(0, 2))},\n            {set(0), and(op(EQUAL, 0), notIn(0, 2))},\n    }", "var_name": "equalCombine"}, {"original_string": "public static Object[][] betweenCombine = new Object[][]{\n            //Test for combination BETWEEN\n            {set(0, 1, 2), or(between(1, 2), op(EQUAL, 0))},\n            \n            {all(), or(between(0, 2), op(NOT_EQUAL, 1))},\n            {all(), or(between(0, 2), op(GREATER_THAN, 1))},\n            {all(), or(between(0, 2), op(GREATER_THAN_OR_EQUAL, 1))},\n            {all(), or(between(0, 2), op(LESS_THAN, 1))},\n            {all(), or(between(0, 2), op(LESS_THAN_OR_EQUAL, 1))},\n            {all(), or(between(0, 2), notBetween(0, 2))},\n            {all(), or(between(0, 2), notIn(0, 2))},\n\n            {set(1), and(between(0, 2), op(EQUAL, 1))},\n            {non(), and(between(0, 2), op(EQUAL, 3))},\n            \n            {set(0, 1, 2), and(between(0, 2), op(NOT_EQUAL, 1))},\n            {set(0, 1, 2), and(between(0, 2), op(GREATER_THAN, 1))},\n            {set(0, 1, 2), and(between(0, 2), op(GREATER_THAN_OR_EQUAL, 1))},\n            {set(0, 1, 2), and(between(0, 2), op(LESS_THAN, 1))},\n            {set(0, 1, 2), and(between(0, 2), op(LESS_THAN_OR_EQUAL, 1))},\n            {set(0, 1, 2), and(between(0, 2), between(0, 2))},\n            {set(0, 1, 2), and(between(0, 2), between(0, 20))},\n            {set(0, 1, 2), and(between(0, 2), notBetween(0, 2))},\n    };", "modifier": "public static", "type": "Object[][]", "declarator": "betweenCombine = new Object[][]{\n            //Test for combination BETWEEN\n            {set(0, 1, 2), or(between(1, 2), op(EQUAL, 0))},\n            \n            {all(), or(between(0, 2), op(NOT_EQUAL, 1))},\n            {all(), or(between(0, 2), op(GREATER_THAN, 1))},\n            {all(), or(between(0, 2), op(GREATER_THAN_OR_EQUAL, 1))},\n            {all(), or(between(0, 2), op(LESS_THAN, 1))},\n            {all(), or(between(0, 2), op(LESS_THAN_OR_EQUAL, 1))},\n            {all(), or(between(0, 2), notBetween(0, 2))},\n            {all(), or(between(0, 2), notIn(0, 2))},\n\n            {set(1), and(between(0, 2), op(EQUAL, 1))},\n            {non(), and(between(0, 2), op(EQUAL, 3))},\n            \n            {set(0, 1, 2), and(between(0, 2), op(NOT_EQUAL, 1))},\n            {set(0, 1, 2), and(between(0, 2), op(GREATER_THAN, 1))},\n            {set(0, 1, 2), and(between(0, 2), op(GREATER_THAN_OR_EQUAL, 1))},\n            {set(0, 1, 2), and(between(0, 2), op(LESS_THAN, 1))},\n            {set(0, 1, 2), and(between(0, 2), op(LESS_THAN_OR_EQUAL, 1))},\n            {set(0, 1, 2), and(between(0, 2), between(0, 2))},\n            {set(0, 1, 2), and(between(0, 2), between(0, 20))},\n            {set(0, 1, 2), and(between(0, 2), notBetween(0, 2))},\n    }", "var_name": "betweenCombine"}, {"original_string": "public static Object[][] inCombine = new Object[][]{\n            //Test for combination IN\n            {set(0, 1, 2), or(in(1, 2), op(EQUAL, 0))},\n            \n            {all(), or(in(0, 2), op(NOT_EQUAL, 1))},\n            {all(), or(in(0, 2), op(GREATER_THAN, 1))},\n            {all(), or(in(0, 2), op(GREATER_THAN_OR_EQUAL, 1))},\n            {all(), or(in(0, 2), op(LESS_THAN, 1))},\n            {all(), or(in(0, 2), op(LESS_THAN_OR_EQUAL, 1))},\n            {all(), or(in(0, 2), notBetween(0, 2))},\n            {all(), or(in(0, 2), notIn(0, 2))},\n\n            {set(1), and(in(0, 1, 2), op(EQUAL, 1))},\n            {non(), and(in(0, 2), op(EQUAL, 3))},\n            \n            {set(0, 2), and(in(0, 2), op(NOT_EQUAL, 1))},\n            {set(0, 2), and(in(0, 2), op(GREATER_THAN, 1))},\n            {set(0, 2), and(in(0, 2), op(GREATER_THAN_OR_EQUAL, 1))},\n            {set(0, 2), and(in(0, 2), op(LESS_THAN, 1))},\n            {set(0, 2), and(in(0, 2), op(LESS_THAN_OR_EQUAL, 1))},\n            {set(0, 2), and(in(0, 2), between(0, 2))},\n            {set(0, 2), and(in(0, 2), between(0, 20))},\n            {set(0, 2), and(in(0, 2), notBetween(0, 2))},\n    };", "modifier": "public static", "type": "Object[][]", "declarator": "inCombine = new Object[][]{\n            //Test for combination IN\n            {set(0, 1, 2), or(in(1, 2), op(EQUAL, 0))},\n            \n            {all(), or(in(0, 2), op(NOT_EQUAL, 1))},\n            {all(), or(in(0, 2), op(GREATER_THAN, 1))},\n            {all(), or(in(0, 2), op(GREATER_THAN_OR_EQUAL, 1))},\n            {all(), or(in(0, 2), op(LESS_THAN, 1))},\n            {all(), or(in(0, 2), op(LESS_THAN_OR_EQUAL, 1))},\n            {all(), or(in(0, 2), notBetween(0, 2))},\n            {all(), or(in(0, 2), notIn(0, 2))},\n\n            {set(1), and(in(0, 1, 2), op(EQUAL, 1))},\n            {non(), and(in(0, 2), op(EQUAL, 3))},\n            \n            {set(0, 2), and(in(0, 2), op(NOT_EQUAL, 1))},\n            {set(0, 2), and(in(0, 2), op(GREATER_THAN, 1))},\n            {set(0, 2), and(in(0, 2), op(GREATER_THAN_OR_EQUAL, 1))},\n            {set(0, 2), and(in(0, 2), op(LESS_THAN, 1))},\n            {set(0, 2), and(in(0, 2), op(LESS_THAN_OR_EQUAL, 1))},\n            {set(0, 2), and(in(0, 2), between(0, 2))},\n            {set(0, 2), and(in(0, 2), between(0, 20))},\n            {set(0, 2), and(in(0, 2), notBetween(0, 2))},\n    }", "var_name": "inCombine"}], "file": "das-client/src/test/java/com/ppdai/das/strategy/AdvancedModStrategyTest.java"}, "test_case": {"identifier": "testWrongDbConfig", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testWrongDbConfig() throws Exception {\n        strategy = new AdvancedModStrategy();\n        Map<String, String> settings = new HashMap<>();\n        \n        settings.put(AdvancedModStrategy.COLUMNS, columnName);\n\n        try {\n            strategy.initialize(settings);\n            fail();\n        } catch (Exception e) {\n            assertEquals(e.getClass(), IllegalArgumentException.class);\n        }\n    }", "signature": "void testWrongDbConfig()", "full_signature": "@Test public void testWrongDbConfig()", "class_method_signature": "AdvancedModStrategyTest.testWrongDbConfig()", "testcase": true, "constructor": false, "invocations": ["put", "initialize", "fail", "assertEquals", "getClass"]}, "focal_class": {"identifier": "AdvancedModStrategy", "superclass": "extends AbstractConditionStrategy", "interfaces": "", "fields": [{"original_string": "public static final String TYPE = \"type\";", "modifier": "public static final", "type": "String", "declarator": "TYPE = \"type\"", "var_name": "TYPE"}, {"original_string": "public static final String MOD = \"mod\";", "modifier": "public static final", "type": "String", "declarator": "MOD = \"mod\"", "var_name": "MOD"}, {"original_string": "public static final String TABLE_MOD = \"tableMod\";", "modifier": "public static final", "type": "String", "declarator": "TABLE_MOD = \"tableMod\"", "var_name": "TABLE_MOD"}, {"original_string": "private static final String TABLE_ZERO_PADDING = \"tableZeroPadding\";", "modifier": "private static final", "type": "String", "declarator": "TABLE_ZERO_PADDING = \"tableZeroPadding\"", "var_name": "TABLE_ZERO_PADDING"}, {"original_string": "private static final String ZERO_PADDING = \"zeroPadding\";", "modifier": "private static final", "type": "String", "declarator": "ZERO_PADDING = \"zeroPadding\"", "var_name": "ZERO_PADDING"}, {"original_string": "private ModShardLocator<ConditionContext> dbLoactor;", "modifier": "private", "type": "ModShardLocator<ConditionContext>", "declarator": "dbLoactor", "var_name": "dbLoactor"}, {"original_string": "private ModShardLocator<TableConditionContext> tableLoactor;", "modifier": "private", "type": "ModShardLocator<TableConditionContext>", "declarator": "tableLoactor", "var_name": "tableLoactor"}], "methods": [{"identifier": "initialize", "parameters": "(Map<String, String> settings)", "modifiers": "@Override public", "return": "void", "signature": "void initialize(Map<String, String> settings)", "full_signature": "@Override public void initialize(Map<String, String> settings)", "class_method_signature": "AdvancedModStrategy.initialize(Map<String, String> settings)", "testcase": false, "constructor": false}, {"identifier": "createLocator", "parameters": "(String type, int mod, String zeroPaddingFormat)", "modifiers": "protected", "return": "ModShardLocator<T>", "signature": "ModShardLocator<T> createLocator(String type, int mod, String zeroPaddingFormat)", "full_signature": "protected ModShardLocator<T> createLocator(String type, int mod, String zeroPaddingFormat)", "class_method_signature": "AdvancedModStrategy.createLocator(String type, int mod, String zeroPaddingFormat)", "testcase": false, "constructor": false}, {"identifier": "locateDbShardsByValue", "parameters": "(ShardingContext ctx, Object shardValue)", "modifiers": "@Override public", "return": "Set<String>", "signature": "Set<String> locateDbShardsByValue(ShardingContext ctx, Object shardValue)", "full_signature": "@Override public Set<String> locateDbShardsByValue(ShardingContext ctx, Object shardValue)", "class_method_signature": "AdvancedModStrategy.locateDbShardsByValue(ShardingContext ctx, Object shardValue)", "testcase": false, "constructor": false}, {"identifier": "locateDbShards", "parameters": "(ConditionContext ctx)", "modifiers": "@Override public", "return": "Set<String>", "signature": "Set<String> locateDbShards(ConditionContext ctx)", "full_signature": "@Override public Set<String> locateDbShards(ConditionContext ctx)", "class_method_signature": "AdvancedModStrategy.locateDbShards(ConditionContext ctx)", "testcase": false, "constructor": false}, {"identifier": "locateTableShardsByValue", "parameters": "(TableShardingContext ctx, Object tableShardValue)", "modifiers": "@Override public", "return": "Set<String>", "signature": "Set<String> locateTableShardsByValue(TableShardingContext ctx, Object tableShardValue)", "full_signature": "@Override public Set<String> locateTableShardsByValue(TableShardingContext ctx, Object tableShardValue)", "class_method_signature": "AdvancedModStrategy.locateTableShardsByValue(TableShardingContext ctx, Object tableShardValue)", "testcase": false, "constructor": false}, {"identifier": "locateTableShards", "parameters": "(TableConditionContext ctx)", "modifiers": "@Override public", "return": "Set<String>", "signature": "Set<String> locateTableShards(TableConditionContext ctx)", "full_signature": "@Override public Set<String> locateTableShards(TableConditionContext ctx)", "class_method_signature": "AdvancedModStrategy.locateTableShards(TableConditionContext ctx)", "testcase": false, "constructor": false}], "file": "das-client/src/main/java/com/ppdai/das/strategy/AdvancedModStrategy.java"}, "focal_method": {"identifier": "initialize", "parameters": "(Map<String, String> settings)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void initialize(Map<String, String> settings) {\n        super.initialize(settings);\n\n        String type = settings.get(TYPE);\n        if(isShardByDb()) {\n            if(!settings.containsKey(MOD)) {\n                throw new IllegalArgumentException(\"Property \" + MOD + \" is required for shard by database\");\n            }\n\n            String zeroPaddingFormat = \"%01d\";\n            if(settings.containsKey(ZERO_PADDING)) {\n                zeroPaddingFormat = \"%0\" + Integer.parseInt(settings.get(ZERO_PADDING)) + \"d\";\n            }\n\n            dbLoactor = createLocator(type, Integer.parseInt(settings.get(MOD)), zeroPaddingFormat);\n        }\n        \n        if(isShardByTable()) {\n            if(!settings.containsKey(TABLE_MOD)) {\n                throw new IllegalArgumentException(\"Property \" + TABLE_MOD + \" is required for shard by table\");\n            }\n\n            String tableZeroPaddingFormat = \"%01d\";\n            if(settings.containsKey(TABLE_ZERO_PADDING)) {\n                tableZeroPaddingFormat = \"%0\" + Integer.parseInt(settings.get(TABLE_ZERO_PADDING)) + \"d\";\n            }\n\n            Integer mod = Integer.parseInt(settings.get(TABLE_MOD));\n            tableLoactor = createLocator(type, mod, tableZeroPaddingFormat);\n            \n            Set<String> allShards = new HashSet<>();\n            for(int i = 0; i < mod; i++) {\n                allShards.add(String.format(tableZeroPaddingFormat, i));\n            }\n            \n            setAllTableShards(allShards);\n        }\n    }", "signature": "void initialize(Map<String, String> settings)", "full_signature": "@Override public void initialize(Map<String, String> settings)", "class_method_signature": "AdvancedModStrategy.initialize(Map<String, String> settings)", "testcase": false, "constructor": false, "invocations": ["initialize", "get", "isShardByDb", "containsKey", "containsKey", "parseInt", "get", "createLocator", "parseInt", "get", "isShardByTable", "containsKey", "containsKey", "parseInt", "get", "parseInt", "get", "createLocator", "add", "format", "setAllTableShards"]}, "repository": {"repo_id": 214933909, "url": "https://github.com/ppdaicorp/das", "stars": 55, "created": "10/14/2019 2:49:17 AM +00:00", "updates": "2020-01-20T09:24:23+00:00", "fork": "False", "license": "licensed"}}