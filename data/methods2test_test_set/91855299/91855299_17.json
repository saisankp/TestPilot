{"test_class": {"identifier": "CsvConverterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String EMPTY_HEADER = \"Timestamp,Event,Event Description,Event Severity\";", "modifier": "private static final", "type": "String", "declarator": "EMPTY_HEADER = \"Timestamp,Event,Event Description,Event Severity\"", "var_name": "EMPTY_HEADER"}, {"original_string": "private CsvConverter converter;", "modifier": "private", "type": "CsvConverter", "declarator": "converter", "var_name": "converter"}, {"original_string": "private Recording recording;", "modifier": "private", "type": "Recording", "declarator": "recording", "var_name": "recording"}], "file": "app/src/test/java/edu/wpi/first/shuffleboard/app/sources/recording/CsvConverterTest.java"}, "test_case": {"identifier": "testMultipleMarkersInSameWindow", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testMultipleMarkersInSameWindow() {\n    // First two markers are in the same time window\n    // The second marker should be skipped, but the first and third should still be present\n    recording.addMarker(new Marker(\"First\", \"\", MarkerImportance.LOW, 0L));\n    recording.addMarker(new Marker(\"Second\", \"\", MarkerImportance.CRITICAL, 0L));\n    recording.addMarker(new Marker(\"Third\", \"\", MarkerImportance.NORMAL, 255));\n\n    String csv = converter.convertToCsv(recording);\n    var lines = csv.lines().collect(Collectors.toList());\n\n    assertAll(\n        () -> assertEquals(EMPTY_HEADER, lines.get(0), \"First line should be the header\"),\n        () -> assertEquals(\"0,First,,LOW\", lines.get(1), \"Second line should be the first marker\"),\n        () -> assertEquals(\"255,Third,,NORMAL\", lines.get(2), \"Third line should be the third marker\")\n    );\n  }", "signature": "void testMultipleMarkersInSameWindow()", "full_signature": "@Test public void testMultipleMarkersInSameWindow()", "class_method_signature": "CsvConverterTest.testMultipleMarkersInSameWindow()", "testcase": true, "constructor": false, "invocations": ["addMarker", "addMarker", "addMarker", "convertToCsv", "collect", "lines", "toList", "assertAll", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "CsvConverter", "superclass": "", "interfaces": "implements Converter", "fields": [{"original_string": "public static final CsvConverter Instance = new CsvConverter(Preferences.userNodeForPackage(CsvConverter.class));", "modifier": "public static final", "type": "CsvConverter", "declarator": "Instance = new CsvConverter(Preferences.userNodeForPackage(CsvConverter.class))", "var_name": "Instance"}, {"original_string": "private static final Logger log = Logger.getLogger(CsvConverter.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "log = Logger.getLogger(CsvConverter.class.getName())", "var_name": "log"}, {"original_string": "private static final String invariantViolatedMessageFormat =\n      \"Invariant violated: multiple event markers for same timestamp (found: %s at entry %d of %d), for timestamp %d\";", "modifier": "private static final", "type": "String", "declarator": "invariantViolatedMessageFormat =\n      \"Invariant violated: multiple event markers for same timestamp (found: %s at entry %d of %d), for timestamp %d\"", "var_name": "invariantViolatedMessageFormat"}, {"original_string": "private final BooleanProperty includeMetadata = new SimpleBooleanProperty(false);", "modifier": "private final", "type": "BooleanProperty", "declarator": "includeMetadata = new SimpleBooleanProperty(false)", "var_name": "includeMetadata"}, {"original_string": "private final BooleanProperty fillEmpty = new SimpleBooleanProperty(false);", "modifier": "private final", "type": "BooleanProperty", "declarator": "fillEmpty = new SimpleBooleanProperty(false)", "var_name": "fillEmpty"}, {"original_string": "private final IntegerProperty windowSize = new SimpleIntegerProperty(7);", "modifier": "private final", "type": "IntegerProperty", "declarator": "windowSize = new SimpleIntegerProperty(7)", "var_name": "windowSize"}], "methods": [{"identifier": "CsvConverter", "parameters": "(Preferences prefs)", "modifiers": "@VisibleForTesting", "return": "", "signature": " CsvConverter(Preferences prefs)", "full_signature": "@VisibleForTesting  CsvConverter(Preferences prefs)", "class_method_signature": "CsvConverter.CsvConverter(Preferences prefs)", "testcase": false, "constructor": true}, {"identifier": "formatName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String formatName()", "full_signature": "@Override public String formatName()", "class_method_signature": "CsvConverter.formatName()", "testcase": false, "constructor": false}, {"identifier": "fileExtension", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String fileExtension()", "full_signature": "@Override public String fileExtension()", "class_method_signature": "CsvConverter.fileExtension()", "testcase": false, "constructor": false}, {"identifier": "export", "parameters": "(Recording recording, Path destination)", "modifiers": "@Override public", "return": "void", "signature": "void export(Recording recording, Path destination)", "full_signature": "@Override public void export(Recording recording, Path destination)", "class_method_signature": "CsvConverter.export(Recording recording, Path destination)", "testcase": false, "constructor": false}, {"identifier": "getSettings", "parameters": "()", "modifiers": "@Override public", "return": "List<Group>", "signature": "List<Group> getSettings()", "full_signature": "@Override public List<Group> getSettings()", "class_method_signature": "CsvConverter.getSettings()", "testcase": false, "constructor": false}, {"identifier": "convertToCsv", "parameters": "(Recording recording)", "modifiers": "@SuppressFBWarnings(value = \"UC_USELESS_OBJECT\", justification = \"False positive with List.forEach\") public", "return": "String", "signature": "String convertToCsv(Recording recording)", "full_signature": "@SuppressFBWarnings(value = \"UC_USELESS_OBJECT\", justification = \"False positive with List.forEach\") public String convertToCsv(Recording recording)", "class_method_signature": "CsvConverter.convertToCsv(Recording recording)", "testcase": false, "constructor": false}, {"identifier": "fillEmptyCells", "parameters": "(List<Object[]> rows)", "modifiers": "@VisibleForTesting static", "return": "void", "signature": "void fillEmptyCells(List<Object[]> rows)", "full_signature": "@VisibleForTesting static void fillEmptyCells(List<Object[]> rows)", "class_method_signature": "CsvConverter.fillEmptyCells(List<Object[]> rows)", "testcase": false, "constructor": false}, {"identifier": "toRow", "parameters": "(List<String> header, int headerSize, Map.Entry<Long, List<RecordingEntry>> entry)", "modifiers": "private", "return": "Object[]", "signature": "Object[] toRow(List<String> header, int headerSize, Map.Entry<Long, List<RecordingEntry>> entry)", "full_signature": "private Object[] toRow(List<String> header, int headerSize, Map.Entry<Long, List<RecordingEntry>> entry)", "class_method_signature": "CsvConverter.toRow(List<String> header, int headerSize, Map.Entry<Long, List<RecordingEntry>> entry)", "testcase": false, "constructor": false}, {"identifier": "makeHeader", "parameters": "(Recording recording)", "modifiers": "private", "return": "List<String>", "signature": "List<String> makeHeader(Recording recording)", "full_signature": "private List<String> makeHeader(Recording recording)", "class_method_signature": "CsvConverter.makeHeader(Recording recording)", "testcase": false, "constructor": false}], "file": "app/src/main/java/edu/wpi/first/shuffleboard/app/sources/recording/CsvConverter.java"}, "focal_method": {"identifier": "convertToCsv", "parameters": "(Recording recording)", "modifiers": "@SuppressFBWarnings(value = \"UC_USELESS_OBJECT\", justification = \"False positive with List.forEach\") public", "return": "String", "body": "@SuppressFBWarnings(value = \"UC_USELESS_OBJECT\", justification = \"False positive with List.forEach\")\n  public String convertToCsv(Recording recording) {\n    List<String> header = makeHeader(recording);\n    int headerSize = header.size();\n    CSVFormat csvFormat = CSVFormat.DEFAULT.withHeader(header.toArray(new String[headerSize]));\n\n    try (var writer = new StringWriter();\n         var csvPrinter = new CSVPrinter(writer, csvFormat)) {\n      var flattenedData = Converter.flatten(recording, not(Converter::isMetadata), windowSize.get());\n\n      var rows = flattenedData.entrySet()\n          .stream()\n          .sorted(Comparator.comparingLong(Map.Entry::getKey))\n          .map(e -> toRow(header, headerSize, e))\n          .filter(Objects::nonNull)\n          .collect(Collectors.toList());\n\n      if (fillEmpty.get()) {\n        fillEmptyCells(rows);\n      }\n\n      for (Object[] row : rows) {\n        csvPrinter.printRecord(row);\n      }\n\n      return writer.toString();\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Could not convert recording to CSV\", e);\n    }\n  }", "signature": "String convertToCsv(Recording recording)", "full_signature": "@SuppressFBWarnings(value = \"UC_USELESS_OBJECT\", justification = \"False positive with List.forEach\") public String convertToCsv(Recording recording)", "class_method_signature": "CsvConverter.convertToCsv(Recording recording)", "testcase": false, "constructor": false, "invocations": ["makeHeader", "size", "withHeader", "toArray", "flatten", "not", "get", "collect", "filter", "map", "sorted", "stream", "entrySet", "comparingLong", "toRow", "toList", "get", "fillEmptyCells", "printRecord", "toString"]}, "repository": {"repo_id": 91855299, "url": "https://github.com/wpilibsuite/shuffleboard", "stars": 52, "created": "5/20/2017 12:38:25 AM +00:00", "updates": "2020-01-23T20:11:35+00:00", "fork": "False", "license": "licensed"}}