{"test_class": {"identifier": "DlmsPushNotificationDecoderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int EQUIPMENT_IDENTIFIER_LENGTH = 17;", "modifier": "private static final", "type": "int", "declarator": "EQUIPMENT_IDENTIFIER_LENGTH = 17", "var_name": "EQUIPMENT_IDENTIFIER_LENGTH"}, {"original_string": "private static final int LOGICAL_NAME_LENGTH = 6;", "modifier": "private static final", "type": "int", "declarator": "LOGICAL_NAME_LENGTH = 6", "var_name": "LOGICAL_NAME_LENGTH"}, {"original_string": "private static final int COMMA_LENGTH = 1;", "modifier": "private static final", "type": "int", "declarator": "COMMA_LENGTH = 1", "var_name": "COMMA_LENGTH"}, {"original_string": "private static final int SMR5_NUMBER_OF_BYTES_FOR_ADDRESSING = 8;", "modifier": "private static final", "type": "int", "declarator": "SMR5_NUMBER_OF_BYTES_FOR_ADDRESSING = 8", "var_name": "SMR5_NUMBER_OF_BYTES_FOR_ADDRESSING"}, {"original_string": "private static final int SMR5_NUMBER_OF_BYTES_FOR_INVOKE_ID = 4;", "modifier": "private static final", "type": "int", "declarator": "SMR5_NUMBER_OF_BYTES_FOR_INVOKE_ID = 4", "var_name": "SMR5_NUMBER_OF_BYTES_FOR_INVOKE_ID"}, {"original_string": "private static final int SMR5_NUMBER_OF_BYTES_FOR_DATETIME = 7;", "modifier": "private static final", "type": "int", "declarator": "SMR5_NUMBER_OF_BYTES_FOR_DATETIME = 7", "var_name": "SMR5_NUMBER_OF_BYTES_FOR_DATETIME"}, {"original_string": "private static final String PUSH_SCHEDULER_TRIGGER = \"Push scheduler\";", "modifier": "private static final", "type": "String", "declarator": "PUSH_SCHEDULER_TRIGGER = \"Push scheduler\"", "var_name": "PUSH_SCHEDULER_TRIGGER"}, {"original_string": "private static final String PUSH_CSD_TRIGGER = \"Push csd wakeup\";", "modifier": "private static final", "type": "String", "declarator": "PUSH_CSD_TRIGGER = \"Push csd wakeup\"", "var_name": "PUSH_CSD_TRIGGER"}, {"original_string": "private static final String PUSH_SMS_TRIGGER = \"Push sms wakeup\";", "modifier": "private static final", "type": "String", "declarator": "PUSH_SMS_TRIGGER = \"Push sms wakeup\"", "var_name": "PUSH_SMS_TRIGGER"}, {"original_string": "private static final String PUSH_ALARM_TRIGGER = \"Push alarm monitor\";", "modifier": "private static final", "type": "String", "declarator": "PUSH_ALARM_TRIGGER = \"Push alarm monitor\"", "var_name": "PUSH_ALARM_TRIGGER"}, {"original_string": "private static final byte[] SCHEDULER_OBISCODE_BYTES = new byte[] { 0x00, 0x00, 0x0F, 0x00, 0x04, (byte) 0xFF };", "modifier": "private static final", "type": "byte[]", "declarator": "SCHEDULER_OBISCODE_BYTES = new byte[] { 0x00, 0x00, 0x0F, 0x00, 0x04, (byte) 0xFF }", "var_name": "SCHEDULER_OBISCODE_BYTES"}, {"original_string": "private static final byte[] SCHEDULER_SETUP_OBISCODE_BYTES = new byte[] { 0x00, 0x00, 0x19, 0x09, 0x00,\n            (byte) 0xFF };", "modifier": "private static final", "type": "byte[]", "declarator": "SCHEDULER_SETUP_OBISCODE_BYTES = new byte[] { 0x00, 0x00, 0x19, 0x09, 0x00,\n            (byte) 0xFF }", "var_name": "SCHEDULER_SETUP_OBISCODE_BYTES"}, {"original_string": "private static final byte[] CSD_OBISCODE_BYTES = new byte[] { 0x00, 0x00, 0x02, 0x02, 0x00, (byte) 0xFF };", "modifier": "private static final", "type": "byte[]", "declarator": "CSD_OBISCODE_BYTES = new byte[] { 0x00, 0x00, 0x02, 0x02, 0x00, (byte) 0xFF }", "var_name": "CSD_OBISCODE_BYTES"}, {"original_string": "private static final byte[] SMS_OBISCODE_BYTES = new byte[] { 0x00, 0x00, 0x02, 0x03, 0x00, (byte) 0xFF };", "modifier": "private static final", "type": "byte[]", "declarator": "SMS_OBISCODE_BYTES = new byte[] { 0x00, 0x00, 0x02, 0x03, 0x00, (byte) 0xFF }", "var_name": "SMS_OBISCODE_BYTES"}, {"original_string": "private static final byte[] ALARM_OBISCODE_BYTES = new byte[] { 0x00, 0x01, 0x19, 0x09, 0x00, (byte) 0xFF };", "modifier": "private static final", "type": "byte[]", "declarator": "ALARM_OBISCODE_BYTES = new byte[] { 0x00, 0x01, 0x19, 0x09, 0x00, (byte) 0xFF }", "var_name": "ALARM_OBISCODE_BYTES"}, {"original_string": "private static final byte[] SMR5_EXTERNAL_TRIGGER_OBISCODE_BYTES = new byte[] { 0x00, 0x00, 0x02, 0x02, 0x00,\n            (byte) 0xFF };", "modifier": "private static final", "type": "byte[]", "declarator": "SMR5_EXTERNAL_TRIGGER_OBISCODE_BYTES = new byte[] { 0x00, 0x00, 0x02, 0x02, 0x00,\n            (byte) 0xFF }", "var_name": "SMR5_EXTERNAL_TRIGGER_OBISCODE_BYTES"}, {"original_string": "private static final String IDENTIFIER = \"EXXXX123456789012\";", "modifier": "private static final", "type": "String", "declarator": "IDENTIFIER = \"EXXXX123456789012\"", "var_name": "IDENTIFIER"}, {"original_string": "private static final byte COMMA = 0x2C;", "modifier": "private static final", "type": "byte", "declarator": "COMMA = 0x2C", "var_name": "COMMA"}, {"original_string": "private static final int STRUCTURE = 0x02;", "modifier": "private static final", "type": "int", "declarator": "STRUCTURE = 0x02", "var_name": "STRUCTURE"}, {"original_string": "private static final int OCTET_STRING = 0x09;", "modifier": "private static final", "type": "int", "declarator": "OCTET_STRING = 0x09", "var_name": "OCTET_STRING"}, {"original_string": "private static final int DOUBLE_LONG_UNSIGNED = 0x06;", "modifier": "private static final", "type": "int", "declarator": "DOUBLE_LONG_UNSIGNED = 0x06", "var_name": "DOUBLE_LONG_UNSIGNED"}, {"original_string": "private DlmsPushNotificationDecoder decoder;", "modifier": "private", "type": "DlmsPushNotificationDecoder", "declarator": "decoder", "var_name": "decoder"}, {"original_string": "@Mock\n    private ChannelHandlerContext ctx;", "modifier": "@Mock\n    private", "type": "ChannelHandlerContext", "declarator": "ctx", "var_name": "ctx"}, {"original_string": "@Mock\n    private Channel channel;", "modifier": "@Mock\n    private", "type": "Channel", "declarator": "channel", "var_name": "channel"}], "file": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/test/java/org/opensmartgridplatform/adapter/protocol/dlms/infra/networking/DlmsPushNotificationDecoderTest.java"}, "test_case": {"identifier": "decodeDsmr4AlarmsWithAlarmRegister", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void decodeDsmr4AlarmsWithAlarmRegister() throws UnrecognizedMessageDataException {\n\n        // SETUP\n\n        this.decoder = new DlmsPushNotificationDecoder();\n        final ByteBuf buffer = mock(ByteBuf.class);\n\n        // Create alarm register with 3 alarms: replace battery and 2 mbus\n        // alarms\n        final byte[] alarmRegister = new byte[] { 0x00, 0x18, 0x00, 0x02 };\n\n        final byte[] bytes = this.setupDsmr4Buffer(buffer, IDENTIFIER, alarmRegister);\n\n        // CALL\n\n        final List<Object> out = new ArrayList<>();\n        this.decoder.decode(this.ctx, buffer, out);\n        final Object pushNotificationObject = out.get(0);\n\n        // VERIFY\n\n        assertThat(pushNotificationObject instanceof DlmsPushNotification).isTrue();\n        final DlmsPushNotification dlmsPushNotification = (DlmsPushNotification) pushNotificationObject;\n        assertThat(dlmsPushNotification.getEquipmentIdentifier()).isEqualTo(IDENTIFIER);\n        assertThat(dlmsPushNotification.getTriggerType()).isEqualTo(PUSH_ALARM_TRIGGER);\n        assertThat(dlmsPushNotification.toByteArray()).isEqualTo(bytes);\n\n        final Set<AlarmTypeDto> alarms = dlmsPushNotification.getAlarms();\n        assertThat(alarms.size()).isEqualTo(3);\n        assertThat(alarms.contains(REPLACE_BATTERY)).isTrue();\n        assertThat(alarms.contains(COMMUNICATION_ERROR_M_BUS_CHANNEL_4)).isTrue();\n        assertThat(alarms.contains(FRAUD_ATTEMPT_M_BUS_CHANNEL_1)).isTrue();\n\n        this.verifyDsmr4BufferCalls(buffer, alarmRegister);\n    }", "signature": "void decodeDsmr4AlarmsWithAlarmRegister()", "full_signature": "@Test public void decodeDsmr4AlarmsWithAlarmRegister()", "class_method_signature": "DlmsPushNotificationDecoderTest.decodeDsmr4AlarmsWithAlarmRegister()", "testcase": true, "constructor": false, "invocations": ["mock", "setupDsmr4Buffer", "decode", "get", "isTrue", "assertThat", "isEqualTo", "assertThat", "getEquipmentIdentifier", "isEqualTo", "assertThat", "getTriggerType", "isEqualTo", "assertThat", "toByteArray", "getAlarms", "isEqualTo", "assertThat", "size", "isTrue", "assertThat", "contains", "isTrue", "assertThat", "contains", "isTrue", "assertThat", "contains", "verifyDsmr4BufferCalls"]}, "focal_class": {"identifier": "DlmsPushNotificationDecoder", "superclass": "extends ReplayingDecoder<DlmsPushNotificationDecoder.DecodingState>", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(DlmsPushNotificationDecoder.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(DlmsPushNotificationDecoder.class)", "var_name": "LOGGER"}], "methods": [{"identifier": "DlmsPushNotificationDecoder", "parameters": "()", "modifiers": "public", "return": "", "signature": " DlmsPushNotificationDecoder()", "full_signature": "public  DlmsPushNotificationDecoder()", "class_method_signature": "DlmsPushNotificationDecoder.DlmsPushNotificationDecoder()", "testcase": false, "constructor": true}, {"identifier": "decode", "parameters": "(final ChannelHandlerContext ctx, final ByteBuf in, final List<Object> out)", "modifiers": "@Override protected", "return": "void", "signature": "void decode(final ChannelHandlerContext ctx, final ByteBuf in, final List<Object> out)", "full_signature": "@Override protected void decode(final ChannelHandlerContext ctx, final ByteBuf in, final List<Object> out)", "class_method_signature": "DlmsPushNotificationDecoder.decode(final ChannelHandlerContext ctx, final ByteBuf in, final List<Object> out)", "testcase": false, "constructor": false}], "file": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/infra/networking/DlmsPushNotificationDecoder.java"}, "focal_method": {"identifier": "decode", "parameters": "(final ChannelHandlerContext ctx, final ByteBuf in, final List<Object> out)", "modifiers": "@Override protected", "return": "void", "body": "@Override\n    protected void decode(final ChannelHandlerContext ctx, final ByteBuf in, final List<Object> out)\n            throws UnrecognizedMessageDataException {\n        /**\n         * DSMR4 alarm examples (in HEX bytes):\n         *\n         * 45 58 58 58 58 31 32 33 34 35 36 37 38 39 30 31 32 // Equipment id\n         * EXXXX123456789012 2C // Comma 00 00 0F 00 04 FF // Logical name\n         * 0.0.15.0.4.255\n         *\n         * 45 58 58 58 58 31 32 33 34 35 36 37 38 39 30 31 32 // Equipment id\n         * EXXXX123456789012 2C // Comma 00 00 00 02 // Alarm register, with\n         * Replace battery set\n         *\n         * SMR5 alarm examples (in HEX bytes):\n         *\n         * 0F // Data-notification 00 00 00 01 // Long-invoke-id-and-priority\n         * (can be ignored) 00 // Date-time (empty) 02 02 // Structure with 2\n         * elements 09 11 45 58 58 58 58 31 32 33 34 35 36 37 38 39 30 31 32 //\n         * Equipment id EXXXX123456789012 09 06 00 00 19 09 00 FF // Logical\n         * name: Push setup schedule\n         *\n         * 0F // Data-notification 00 00 00 01 // Long-invoke-id-and-priority\n         * (can be ignored) 00 // Date-time (empty) 02 03 // Structure with 3\n         * elements 09 11 45 58 58 58 58 31 32 33 34 35 36 37 38 39 30 31 32 //\n         * Equipment id EXXXX123456789012 09 06 00 01 19 09 00 FF // Logical\n         * name: Push setup alarms 06 00 00 00 02 // Alarm register, with\n         * Replace battery set\n         *\n         * Notes: - For SMR5 alarms, we get 8 additional addressing bytes in\n         * front of the alarm. These bytes can be ignored here. - To check if\n         * the alarm is in DSMR4 or SMR5 format, check the 9th byte (at index\n         * 8). If it is 0F, then it is SMR5, otherwise it is DSMR4, because the\n         * 9th byte in DSMR4 is in the identifier and this should be a number or\n         * a character, so it can't be ASCII code 0F.\n         */\n\n        DlmsPushNotification pushNotification;\n\n        // Determine whether the alarm is in DSMR4 or SMR5 format.\n        final boolean smr5alarm = in.getByte(8) == 0x0F;\n\n        LOGGER.info(\"Decoding state: {}, SMR5 alarm: {}\", this.state(), smr5alarm);\n\n        if (smr5alarm) {\n            final Smr5AlarmDecoder alarmDecoder = new Smr5AlarmDecoder();\n            pushNotification = alarmDecoder.decodeSmr5alarm(in);\n        } else {\n            final Dsmr4AlarmDecoder alarmDecoder = new Dsmr4AlarmDecoder();\n            pushNotification = alarmDecoder.decodeDsmr4alarm(in);\n        }\n\n        LOGGER.info(\"Decoded push notification: {}\", pushNotification);\n        out.add(pushNotification);\n    }", "signature": "void decode(final ChannelHandlerContext ctx, final ByteBuf in, final List<Object> out)", "full_signature": "@Override protected void decode(final ChannelHandlerContext ctx, final ByteBuf in, final List<Object> out)", "class_method_signature": "DlmsPushNotificationDecoder.decode(final ChannelHandlerContext ctx, final ByteBuf in, final List<Object> out)", "testcase": false, "constructor": false, "invocations": ["getByte", "info", "state", "decodeSmr5alarm", "decodeDsmr4alarm", "info", "add"]}, "repository": {"repo_id": 154302277, "url": "https://github.com/OSGP/open-smart-grid-platform", "stars": 30, "created": "10/23/2018 9:41:12 AM +00:00", "updates": "2020-01-26T20:15:09+00:00", "fork": "False", "license": "licensed"}}