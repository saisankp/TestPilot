{"test_class": {"identifier": "CollectPartitionKeysByBatchTaskTest", "superclass": "extends CollectPartitionInfoAbstractTest", "interfaces": "", "fields": [], "file": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/checker/tasks/CollectPartitionKeysByBatchTaskTest.java"}, "test_case": {"identifier": "testShouldReturnKeysByBatches", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testShouldReturnKeysByBatches() throws Exception {\n        IgniteEx node = startGrids(3);\n\n        node.cluster().active(true);\n\n        AffinityTopologyVersion ver = lastTopologyVersion(node);\n\n        IgniteCache<Object, Object> cache = node.cache(DEFAULT_CACHE_NAME);\n        List<Integer> keys = new ArrayList<>();\n\n        int elements = 0;\n        for (int i = 0; i < 100_000; i++) {\n            if (node.affinity(DEFAULT_CACHE_NAME).partition(i) == FIRST_PARTITION) {\n                cache.put(i, i);\n                keys.add(i);\n\n                elements++;\n            }\n        }\n\n        for (Integer key : keys) {\n            corruptDataEntry(\n                node.cachex(DEFAULT_CACHE_NAME).context(),\n                key\n            );\n        }\n\n        Collection<ClusterNode> nodes = node.affinity(DEFAULT_CACHE_NAME)\n            .mapPartitionToPrimaryAndBackups(FIRST_PARTITION);\n\n        int batchSize = (elements + 1) / 2; // two batch for all rows\n\n        Set<KeyCacheObject> fetched = new HashSet<>();\n\n        T2<KeyCacheObject, Map<KeyCacheObject, Map<UUID, GridCacheVersion>>> firstBatch = node.compute(group(node, nodes)).execute(\n            CollectPartitionKeysByBatchTask.class,\n            new PartitionBatchRequest(ReconciliationExecutionContext.IGNORE_JOB_PERMITS_SESSION_ID, UUID.randomUUID(),\n                DEFAULT_CACHE_NAME, FIRST_PARTITION, batchSize, null, ver)\n        ).result();\n\n        fetched.addAll(firstBatch.get2().keySet());\n\n        KeyCacheObject firstMaxKey = firstBatch.get1();\n\n        T2<KeyCacheObject, Map<KeyCacheObject, Map<UUID, GridCacheVersion>>> secondBatch = node.compute(group(node, nodes)).execute(\n            CollectPartitionKeysByBatchTask.class,\n            new PartitionBatchRequest(ReconciliationExecutionContext.IGNORE_JOB_PERMITS_SESSION_ID, UUID.randomUUID(),\n                DEFAULT_CACHE_NAME, FIRST_PARTITION, batchSize, firstMaxKey, ver)\n        ).result();\n\n        KeyCacheObject secondMaxKey = secondBatch.get1();\n\n        fetched.addAll(secondBatch.get2().keySet());\n\n        T2<KeyCacheObject, Map<KeyCacheObject, Map<UUID, GridCacheVersion>>> thirdBatch = node.compute(group(node, nodes)).execute(\n            CollectPartitionKeysByBatchTask.class,\n            new PartitionBatchRequest(ReconciliationExecutionContext.IGNORE_JOB_PERMITS_SESSION_ID, UUID.randomUUID(),\n                DEFAULT_CACHE_NAME, FIRST_PARTITION, batchSize, secondMaxKey, ver)\n        ).result();\n\n        assertNull(thirdBatch.get1());\n        assertEquals(0, thirdBatch.get2().size());\n\n        assertEquals(elements, fetched.size());\n    }", "signature": "void testShouldReturnKeysByBatches()", "full_signature": "@Test public void testShouldReturnKeysByBatches()", "class_method_signature": "CollectPartitionKeysByBatchTaskTest.testShouldReturnKeysByBatches()", "testcase": true, "constructor": false, "invocations": ["startGrids", "active", "cluster", "lastTopologyVersion", "cache", "partition", "affinity", "put", "add", "corruptDataEntry", "context", "cachex", "mapPartitionToPrimaryAndBackups", "affinity", "result", "execute", "compute", "group", "randomUUID", "addAll", "keySet", "get2", "get1", "result", "execute", "compute", "group", "randomUUID", "get1", "addAll", "keySet", "get2", "result", "execute", "compute", "group", "randomUUID", "assertNull", "get1", "assertEquals", "size", "get2", "assertEquals", "size"]}, "focal_class": {"identifier": "CollectPartitionKeysByBatchTask", "superclass": "extends ComputeTaskAdapter<PartitionBatchRequest, ExecutionResult<T2<KeyCacheObject, Map<KeyCacheObject, Map<UUID, GridCacheVersion>>>>>", "interfaces": "", "fields": [{"original_string": "private static final long serialVersionUID = 0L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 0L", "var_name": "serialVersionUID"}, {"original_string": "private static final KeyComparator KEY_COMPARATOR = new KeyComparator();", "modifier": "private static final", "type": "KeyComparator", "declarator": "KEY_COMPARATOR = new KeyComparator()", "var_name": "KEY_COMPARATOR"}, {"original_string": "@LoggerResource\n    private IgniteLogger log;", "modifier": "@LoggerResource\n    private", "type": "IgniteLogger", "declarator": "log", "var_name": "log"}, {"original_string": "@IgniteInstanceResource\n    private IgniteEx ignite;", "modifier": "@IgniteInstanceResource\n    private", "type": "IgniteEx", "declarator": "ignite", "var_name": "ignite"}, {"original_string": "private volatile PartitionBatchRequest partBatch;", "modifier": "private volatile", "type": "PartitionBatchRequest", "declarator": "partBatch", "var_name": "partBatch"}], "methods": [{"identifier": "map", "parameters": "(List<ClusterNode> subgrid,\n        PartitionBatchRequest partBatch)", "modifiers": "@NotNull @Override public", "return": "Map<? extends ComputeJob, ClusterNode>", "signature": "Map<? extends ComputeJob, ClusterNode> map(List<ClusterNode> subgrid,\n        PartitionBatchRequest partBatch)", "full_signature": "@NotNull @Override public Map<? extends ComputeJob, ClusterNode> map(List<ClusterNode> subgrid,\n        PartitionBatchRequest partBatch)", "class_method_signature": "CollectPartitionKeysByBatchTask.map(List<ClusterNode> subgrid,\n        PartitionBatchRequest partBatch)", "testcase": false, "constructor": false}, {"identifier": "result", "parameters": "(ComputeJobResult res, List<ComputeJobResult> rcvd)", "modifiers": "@Override public", "return": "ComputeJobResultPolicy", "signature": "ComputeJobResultPolicy result(ComputeJobResult res, List<ComputeJobResult> rcvd)", "full_signature": "@Override public ComputeJobResultPolicy result(ComputeJobResult res, List<ComputeJobResult> rcvd)", "class_method_signature": "CollectPartitionKeysByBatchTask.result(ComputeJobResult res, List<ComputeJobResult> rcvd)", "testcase": false, "constructor": false}, {"identifier": "reduce", "parameters": "(\n        List<ComputeJobResult> results)", "modifiers": "@Override public @Nullable", "return": "ExecutionResult<T2<KeyCacheObject, Map<KeyCacheObject, Map<UUID, GridCacheVersion>>>>", "signature": "ExecutionResult<T2<KeyCacheObject, Map<KeyCacheObject, Map<UUID, GridCacheVersion>>>> reduce(\n        List<ComputeJobResult> results)", "full_signature": "@Override public @Nullable ExecutionResult<T2<KeyCacheObject, Map<KeyCacheObject, Map<UUID, GridCacheVersion>>>> reduce(\n        List<ComputeJobResult> results)", "class_method_signature": "CollectPartitionKeysByBatchTask.reduce(\n        List<ComputeJobResult> results)", "testcase": false, "constructor": false}, {"identifier": "hasConflict", "parameters": "(Collection<GridCacheVersion> keyVersions)", "modifiers": "private", "return": "boolean", "signature": "boolean hasConflict(Collection<GridCacheVersion> keyVersions)", "full_signature": "private boolean hasConflict(Collection<GridCacheVersion> keyVersions)", "class_method_signature": "CollectPartitionKeysByBatchTask.hasConflict(Collection<GridCacheVersion> keyVersions)", "testcase": false, "constructor": false}], "file": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/checker/tasks/CollectPartitionKeysByBatchTask.java"}, "focal_method": {"identifier": "result", "parameters": "(ComputeJobResult res, List<ComputeJobResult> rcvd)", "modifiers": "@Override public", "return": "ComputeJobResultPolicy", "body": "@Override public ComputeJobResultPolicy result(ComputeJobResult res, List<ComputeJobResult> rcvd) {\n        ComputeJobResultPolicy superRes = super.result(res, rcvd);\n\n        // Deny failover.\n        if (superRes == ComputeJobResultPolicy.FAILOVER) {\n            superRes = ComputeJobResultPolicy.WAIT;\n\n            log.warning(\"CollectPartitionEntryHashesJob failed on node \" +\n                \"[consistentId=\" + res.getNode().consistentId() + \"]\", res.getException());\n        }\n\n        return superRes;\n    }", "signature": "ComputeJobResultPolicy result(ComputeJobResult res, List<ComputeJobResult> rcvd)", "full_signature": "@Override public ComputeJobResultPolicy result(ComputeJobResult res, List<ComputeJobResult> rcvd)", "class_method_signature": "CollectPartitionKeysByBatchTask.result(ComputeJobResult res, List<ComputeJobResult> rcvd)", "testcase": false, "constructor": false, "invocations": ["result", "warning", "consistentId", "getNode", "getException"]}, "repository": {"repo_id": 170496871, "url": "https://github.com/gridgain/gridgain", "stars": 46, "created": "2/13/2019 11:31:35 AM +00:00", "updates": "2020-01-27T16:02:24+00:00", "fork": "False", "license": "licensed"}}