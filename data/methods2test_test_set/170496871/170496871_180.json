{"test_class": {"identifier": "LUDecompositionTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Matrix testL;", "modifier": "private", "type": "Matrix", "declarator": "testL", "var_name": "testL"}, {"original_string": "private Matrix testU;", "modifier": "private", "type": "Matrix", "declarator": "testU", "var_name": "testU"}, {"original_string": "private Matrix testP;", "modifier": "private", "type": "Matrix", "declarator": "testP", "var_name": "testP"}, {"original_string": "private Matrix testMatrix;", "modifier": "private", "type": "Matrix", "declarator": "testMatrix", "var_name": "testMatrix"}, {"original_string": "private int[] rawPivot;", "modifier": "private", "type": "int[]", "declarator": "rawPivot", "var_name": "rawPivot"}], "file": "modules/ml/src/test/java/org/apache/ignite/ml/math/primitives/matrix/LUDecompositionTest.java"}, "test_case": {"identifier": "solveMtx", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void solveMtx() throws Exception {\n        Matrix sol = new LUDecomposition(testMatrix)\n            .solve(new DenseMatrix(testMatrix.rowSize(), testMatrix.rowSize()));\n\n        assertEquals(\"Wrong solution matrix row size.\", testMatrix.rowSize(), sol.rowSize());\n\n        assertEquals(\"Wrong solution matrix column size.\", testMatrix.rowSize(), sol.columnSize());\n\n        for (int row = 0; row < sol.rowSize(); row++)\n            for (int col = 0; col < sol.columnSize(); col++)\n                assertEquals(\"Unexpected P value at (\" + row + \",\" + col + \").\",\n                    0d, sol.getX(row, col), 0.0000001d);\n    }", "signature": "void solveMtx()", "full_signature": "@Test public void solveMtx()", "class_method_signature": "LUDecompositionTest.solveMtx()", "testcase": true, "constructor": false, "invocations": ["solve", "rowSize", "rowSize", "assertEquals", "rowSize", "rowSize", "assertEquals", "rowSize", "columnSize", "rowSize", "columnSize", "assertEquals", "getX"]}, "focal_class": {"identifier": "LUDecomposition", "superclass": "", "interfaces": "implements AutoCloseable", "fields": [{"original_string": "private static final double DEFAULT_TOO_SMALL = 1e-11;", "modifier": "private static final", "type": "double", "declarator": "DEFAULT_TOO_SMALL = 1e-11", "var_name": "DEFAULT_TOO_SMALL"}, {"original_string": "private final Vector pivot;", "modifier": "private final", "type": "Vector", "declarator": "pivot", "var_name": "pivot"}, {"original_string": "private boolean even;", "modifier": "private", "type": "boolean", "declarator": "even", "var_name": "even"}, {"original_string": "private boolean singular;", "modifier": "private", "type": "boolean", "declarator": "singular", "var_name": "singular"}, {"original_string": "private Matrix cachedL;", "modifier": "private", "type": "Matrix", "declarator": "cachedL", "var_name": "cachedL"}, {"original_string": "private Matrix cachedU;", "modifier": "private", "type": "Matrix", "declarator": "cachedU", "var_name": "cachedU"}, {"original_string": "private Matrix cachedP;", "modifier": "private", "type": "Matrix", "declarator": "cachedP", "var_name": "cachedP"}, {"original_string": "private Matrix matrix;", "modifier": "private", "type": "Matrix", "declarator": "matrix", "var_name": "matrix"}, {"original_string": "private Matrix lu;", "modifier": "private", "type": "Matrix", "declarator": "lu", "var_name": "lu"}], "methods": [{"identifier": "LUDecomposition", "parameters": "(Matrix matrix)", "modifiers": "public", "return": "", "signature": " LUDecomposition(Matrix matrix)", "full_signature": "public  LUDecomposition(Matrix matrix)", "class_method_signature": "LUDecomposition.LUDecomposition(Matrix matrix)", "testcase": false, "constructor": true}, {"identifier": "LUDecomposition", "parameters": "(Matrix matrix, double singularityThreshold)", "modifiers": "public", "return": "", "signature": " LUDecomposition(Matrix matrix, double singularityThreshold)", "full_signature": "public  LUDecomposition(Matrix matrix, double singularityThreshold)", "class_method_signature": "LUDecomposition.LUDecomposition(Matrix matrix, double singularityThreshold)", "testcase": false, "constructor": true}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "LUDecomposition.close()", "testcase": false, "constructor": false}, {"identifier": "getL", "parameters": "()", "modifiers": "public", "return": "Matrix", "signature": "Matrix getL()", "full_signature": "public Matrix getL()", "class_method_signature": "LUDecomposition.getL()", "testcase": false, "constructor": false}, {"identifier": "getU", "parameters": "()", "modifiers": "public", "return": "Matrix", "signature": "Matrix getU()", "full_signature": "public Matrix getU()", "class_method_signature": "LUDecomposition.getU()", "testcase": false, "constructor": false}, {"identifier": "getP", "parameters": "()", "modifiers": "public", "return": "Matrix", "signature": "Matrix getP()", "full_signature": "public Matrix getP()", "class_method_signature": "LUDecomposition.getP()", "testcase": false, "constructor": false}, {"identifier": "getPivot", "parameters": "()", "modifiers": "public", "return": "Vector", "signature": "Vector getPivot()", "full_signature": "public Vector getPivot()", "class_method_signature": "LUDecomposition.getPivot()", "testcase": false, "constructor": false}, {"identifier": "determinant", "parameters": "()", "modifiers": "public", "return": "double", "signature": "double determinant()", "full_signature": "public double determinant()", "class_method_signature": "LUDecomposition.determinant()", "testcase": false, "constructor": false}, {"identifier": "solve", "parameters": "(Vector b)", "modifiers": "public", "return": "Vector", "signature": "Vector solve(Vector b)", "full_signature": "public Vector solve(Vector b)", "class_method_signature": "LUDecomposition.solve(Vector b)", "testcase": false, "constructor": false}, {"identifier": "solve", "parameters": "(Matrix b)", "modifiers": "public", "return": "Matrix", "signature": "Matrix solve(Matrix b)", "full_signature": "public Matrix solve(Matrix b)", "class_method_signature": "LUDecomposition.solve(Matrix b)", "testcase": false, "constructor": false}], "file": "modules/ml/src/main/java/org/apache/ignite/ml/math/primitives/matrix/LUDecomposition.java"}, "focal_method": {"identifier": "solve", "parameters": "(Vector b)", "modifiers": "public", "return": "Vector", "body": "public Vector solve(Vector b) {\n        final int m = pivot.size();\n\n        if (b.size() != m)\n            throw new CardinalityException(b.size(), m);\n\n        if (singular)\n            throw new SingularMatrixException();\n\n        final double[] bp = new double[m];\n\n        // Apply permutations to b\n        for (int row = 0; row < m; row++)\n            bp[row] = b.get((int)pivot.get(row));\n\n        // Solve LY = b\n        for (int col = 0; col < m; col++) {\n            final double bpCol = bp[col];\n\n            for (int i = col + 1; i < m; i++)\n                bp[i] -= bpCol * lu.get(i, col);\n        }\n\n        // Solve UX = Y\n        for (int col = m - 1; col >= 0; col--) {\n            bp[col] /= lu.get(col, col);\n            final double bpCol = bp[col];\n\n            for (int i = 0; i < col; i++)\n                bp[i] -= bpCol * lu.get(i, col);\n        }\n\n        return b.like(m).assign(bp);\n    }", "signature": "Vector solve(Vector b)", "full_signature": "public Vector solve(Vector b)", "class_method_signature": "LUDecomposition.solve(Vector b)", "testcase": false, "constructor": false, "invocations": ["size", "size", "size", "get", "get", "get", "get", "get", "assign", "like"]}, "repository": {"repo_id": 170496871, "url": "https://github.com/gridgain/gridgain", "stars": 46, "created": "2/13/2019 11:31:35 AM +00:00", "updates": "2020-01-27T16:02:24+00:00", "fork": "False", "license": "licensed"}}