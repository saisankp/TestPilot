{"test_class": {"identifier": "TestALU", "superclass": "", "interfaces": "", "fields": [{"original_string": "ALU ALU = new ALU();", "modifier": "", "type": "ALU", "declarator": "ALU = new ALU()", "var_name": "ALU"}], "file": "Computer Organization and System Architecture/ALUSimulator/src/TestALU.java"}, "test_case": {"identifier": "testFloatRepresentation4", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testFloatRepresentation4(){\n\t\tassertEquals(\"00000100000000\",ALU.floatRepresentation(\"0.0078125\", 4, 9));\n\t}", "signature": "void testFloatRepresentation4()", "full_signature": "@Test public void testFloatRepresentation4()", "class_method_signature": "TestALU.testFloatRepresentation4()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "floatRepresentation"]}, "focal_class": {"identifier": "ALU", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final BinaryOperator<Boolean> booleanAnd = (x,y)->x&&y;", "modifier": "public static final", "type": "BinaryOperator<Boolean>", "declarator": "booleanAnd = (x,y)->x&&y", "var_name": "booleanAnd"}, {"original_string": "public static final BinaryOperator<Boolean> booleanOr = (x,y)->x||y;", "modifier": "public static final", "type": "BinaryOperator<Boolean>", "declarator": "booleanOr = (x,y)->x||y", "var_name": "booleanOr"}, {"original_string": "public static final BinaryOperator<Boolean> booleanXOR = (x,y)->xor(x, y);", "modifier": "public static final", "type": "BinaryOperator<Boolean>", "declarator": "booleanXOR = (x,y)->xor(x, y)", "var_name": "booleanXOR"}], "methods": [{"identifier": "main", "parameters": "(String[] args)", "modifiers": "public static", "return": "void", "signature": "void main(String[] args)", "full_signature": "public static void main(String[] args)", "class_method_signature": "ALU.main(String[] args)", "testcase": false, "constructor": false}, {"identifier": "floatIsInfinity", "parameters": "(String input, int eLength, int sLength)", "modifiers": "public static final", "return": "boolean", "signature": "boolean floatIsInfinity(String input, int eLength, int sLength)", "full_signature": "public static final boolean floatIsInfinity(String input, int eLength, int sLength)", "class_method_signature": "ALU.floatIsInfinity(String input, int eLength, int sLength)", "testcase": false, "constructor": false}, {"identifier": "complementLength", "parameters": "(String binary, int length)", "modifiers": "public static final", "return": "String", "signature": "String complementLength(String binary, int length)", "full_signature": "public static final String complementLength(String binary, int length)", "class_method_signature": "ALU.complementLength(String binary, int length)", "testcase": false, "constructor": false}, {"identifier": "repeatedString", "parameters": "(String str, int times)", "modifiers": "public static final", "return": "String", "signature": "String repeatedString(String str, int times)", "full_signature": "public static final String repeatedString(String str, int times)", "class_method_signature": "ALU.repeatedString(String str, int times)", "testcase": false, "constructor": false}, {"identifier": "bitOp", "parameters": "(String oneBitOperand1, String oneBitOperand2, BinaryOperator<Boolean> op)", "modifiers": "public static final", "return": "String", "signature": "String bitOp(String oneBitOperand1, String oneBitOperand2, BinaryOperator<Boolean> op)", "full_signature": "public static final String bitOp(String oneBitOperand1, String oneBitOperand2, BinaryOperator<Boolean> op)", "class_method_signature": "ALU.bitOp(String oneBitOperand1, String oneBitOperand2, BinaryOperator<Boolean> op)", "testcase": false, "constructor": false}, {"identifier": "isSignTheSame", "parameters": "(String binary1, String binary2)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isSignTheSame(String binary1, String binary2)", "full_signature": "public static final boolean isSignTheSame(String binary1, String binary2)", "class_method_signature": "ALU.isSignTheSame(String binary1, String binary2)", "testcase": false, "constructor": false}, {"identifier": "movePoint", "parameters": "(String operand, int offset)", "modifiers": "public static", "return": "String", "signature": "String movePoint(String operand, int offset)", "full_signature": "public static String movePoint(String operand, int offset)", "class_method_signature": "ALU.movePoint(String operand, int offset)", "testcase": false, "constructor": false}, {"identifier": "charOp", "parameters": "(BinaryOperator<Boolean> op, Character... bits)", "modifiers": "public static final", "return": "char", "signature": "char charOp(BinaryOperator<Boolean> op, Character... bits)", "full_signature": "public static final char charOp(BinaryOperator<Boolean> op, Character... bits)", "class_method_signature": "ALU.charOp(BinaryOperator<Boolean> op, Character... bits)", "testcase": false, "constructor": false}, {"identifier": "stringOp", "parameters": "(String operand1, String operand2, BinaryOperator<Boolean> op)", "modifiers": "public static final", "return": "String", "signature": "String stringOp(String operand1, String operand2, BinaryOperator<Boolean> op)", "full_signature": "public static final String stringOp(String operand1, String operand2, BinaryOperator<Boolean> op)", "class_method_signature": "ALU.stringOp(String operand1, String operand2, BinaryOperator<Boolean> op)", "testcase": false, "constructor": false}, {"identifier": "xor", "parameters": "(boolean operand1, boolean operand2)", "modifiers": "public static final", "return": "boolean", "signature": "boolean xor(boolean operand1, boolean operand2)", "full_signature": "public static final boolean xor(boolean operand1, boolean operand2)", "class_method_signature": "ALU.xor(boolean operand1, boolean operand2)", "testcase": false, "constructor": false}, {"identifier": "minBinaryLong", "parameters": "(int number)", "modifiers": "public static", "return": "int", "signature": "int minBinaryLong(int number)", "full_signature": "public static int minBinaryLong(int number)", "class_method_signature": "ALU.minBinaryLong(int number)", "testcase": false, "constructor": false}, {"identifier": "integerBinRepresentationInMinLength", "parameters": "(String decimalNumber)", "modifiers": "public static", "return": "String", "signature": "String integerBinRepresentationInMinLength(String decimalNumber)", "full_signature": "public static String integerBinRepresentationInMinLength(String decimalNumber)", "class_method_signature": "ALU.integerBinRepresentationInMinLength(String decimalNumber)", "testcase": false, "constructor": false}, {"identifier": "get2sComplement", "parameters": "(String binaryNumber, boolean isNegative)", "modifiers": "public static", "return": "String", "signature": "String get2sComplement(String binaryNumber, boolean isNegative)", "full_signature": "public static String get2sComplement(String binaryNumber, boolean isNegative)", "class_method_signature": "ALU.get2sComplement(String binaryNumber, boolean isNegative)", "testcase": false, "constructor": false}, {"identifier": "integerRepresentation", "parameters": "(String number, int length)", "modifiers": "public", "return": "String", "signature": "String integerRepresentation(String number, int length)", "full_signature": "public String integerRepresentation(String number, int length)", "class_method_signature": "ALU.integerRepresentation(String number, int length)", "testcase": false, "constructor": false}, {"identifier": "floatRepresentation", "parameters": "(String number, int eLength, int sLength)", "modifiers": "public", "return": "String", "signature": "String floatRepresentation(String number, int eLength, int sLength)", "full_signature": "public String floatRepresentation(String number, int eLength, int sLength)", "class_method_signature": "ALU.floatRepresentation(String number, int eLength, int sLength)", "testcase": false, "constructor": false}, {"identifier": "ieee754", "parameters": "(String number, int length)", "modifiers": "public", "return": "String", "signature": "String ieee754(String number, int length)", "full_signature": "public String ieee754(String number, int length)", "class_method_signature": "ALU.ieee754(String number, int length)", "testcase": false, "constructor": false}, {"identifier": "integerTrueValue", "parameters": "(String operand)", "modifiers": "public", "return": "String", "signature": "String integerTrueValue(String operand)", "full_signature": "public String integerTrueValue(String operand)", "class_method_signature": "ALU.integerTrueValue(String operand)", "testcase": false, "constructor": false}, {"identifier": "floatTrueValue", "parameters": "(String operand, int eLength, int sLength)", "modifiers": "public", "return": "String", "signature": "String floatTrueValue(String operand, int eLength, int sLength)", "full_signature": "public String floatTrueValue(String operand, int eLength, int sLength)", "class_method_signature": "ALU.floatTrueValue(String operand, int eLength, int sLength)", "testcase": false, "constructor": false}, {"identifier": "negation", "parameters": "(String operand)", "modifiers": "public", "return": "String", "signature": "String negation(String operand)", "full_signature": "public String negation(String operand)", "class_method_signature": "ALU.negation(String operand)", "testcase": false, "constructor": false}, {"identifier": "leftShift", "parameters": "(String operand, int n)", "modifiers": "public", "return": "String", "signature": "String leftShift(String operand, int n)", "full_signature": "public String leftShift(String operand, int n)", "class_method_signature": "ALU.leftShift(String operand, int n)", "testcase": false, "constructor": false}, {"identifier": "logRightShift", "parameters": "(String operand, int n)", "modifiers": "public", "return": "String", "signature": "String logRightShift(String operand, int n)", "full_signature": "public String logRightShift(String operand, int n)", "class_method_signature": "ALU.logRightShift(String operand, int n)", "testcase": false, "constructor": false}, {"identifier": "ariRightShift", "parameters": "(String operand, int n)", "modifiers": "public", "return": "String", "signature": "String ariRightShift(String operand, int n)", "full_signature": "public String ariRightShift(String operand, int n)", "class_method_signature": "ALU.ariRightShift(String operand, int n)", "testcase": false, "constructor": false}, {"identifier": "fullAdder", "parameters": "(char x, char y, char c)", "modifiers": "public", "return": "String", "signature": "String fullAdder(char x, char y, char c)", "full_signature": "public String fullAdder(char x, char y, char c)", "class_method_signature": "ALU.fullAdder(char x, char y, char c)", "testcase": false, "constructor": false}, {"identifier": "claAdder", "parameters": "(String operand1, String operand2, char c)", "modifiers": "public", "return": "String", "signature": "String claAdder(String operand1, String operand2, char c)", "full_signature": "public String claAdder(String operand1, String operand2, char c)", "class_method_signature": "ALU.claAdder(String operand1, String operand2, char c)", "testcase": false, "constructor": false}, {"identifier": "oneAdder", "parameters": "(String operand)", "modifiers": "public", "return": "String", "signature": "String oneAdder(String operand)", "full_signature": "public String oneAdder(String operand)", "class_method_signature": "ALU.oneAdder(String operand)", "testcase": false, "constructor": false}, {"identifier": "adder", "parameters": "(String operand1, String operand2, char c, int length)", "modifiers": "public", "return": "String", "signature": "String adder(String operand1, String operand2, char c, int length)", "full_signature": "public String adder(String operand1, String operand2, char c, int length)", "class_method_signature": "ALU.adder(String operand1, String operand2, char c, int length)", "testcase": false, "constructor": false}, {"identifier": "integerAddition", "parameters": "(String operand1, String operand2, int length)", "modifiers": "public", "return": "String", "signature": "String integerAddition(String operand1, String operand2, int length)", "full_signature": "public String integerAddition(String operand1, String operand2, int length)", "class_method_signature": "ALU.integerAddition(String operand1, String operand2, int length)", "testcase": false, "constructor": false}, {"identifier": "integerSubtraction", "parameters": "(String operand1, String operand2, int length)", "modifiers": "public", "return": "String", "signature": "String integerSubtraction(String operand1, String operand2, int length)", "full_signature": "public String integerSubtraction(String operand1, String operand2, int length)", "class_method_signature": "ALU.integerSubtraction(String operand1, String operand2, int length)", "testcase": false, "constructor": false}, {"identifier": "integerMultiplication", "parameters": "(String operand1, String operand2, int length)", "modifiers": "public", "return": "String", "signature": "String integerMultiplication(String operand1, String operand2, int length)", "full_signature": "public String integerMultiplication(String operand1, String operand2, int length)", "class_method_signature": "ALU.integerMultiplication(String operand1, String operand2, int length)", "testcase": false, "constructor": false}, {"identifier": "integerDivision", "parameters": "(String operand1, String operand2, int length)", "modifiers": "public", "return": "String", "signature": "String integerDivision(String operand1, String operand2, int length)", "full_signature": "public String integerDivision(String operand1, String operand2, int length)", "class_method_signature": "ALU.integerDivision(String operand1, String operand2, int length)", "testcase": false, "constructor": false}, {"identifier": "signedAddition", "parameters": "(String operand1, String operand2, int length)", "modifiers": "public", "return": "String", "signature": "String signedAddition(String operand1, String operand2, int length)", "full_signature": "public String signedAddition(String operand1, String operand2, int length)", "class_method_signature": "ALU.signedAddition(String operand1, String operand2, int length)", "testcase": false, "constructor": false}, {"identifier": "floatAddition", "parameters": "(String operand1, String operand2, int eLength, int sLength, int gLength)", "modifiers": "public", "return": "String", "signature": "String floatAddition(String operand1, String operand2, int eLength, int sLength, int gLength)", "full_signature": "public String floatAddition(String operand1, String operand2, int eLength, int sLength, int gLength)", "class_method_signature": "ALU.floatAddition(String operand1, String operand2, int eLength, int sLength, int gLength)", "testcase": false, "constructor": false}, {"identifier": "floatSubtraction", "parameters": "(String operand1, String operand2, int eLength, int sLength, int gLength)", "modifiers": "public", "return": "String", "signature": "String floatSubtraction(String operand1, String operand2, int eLength, int sLength, int gLength)", "full_signature": "public String floatSubtraction(String operand1, String operand2, int eLength, int sLength, int gLength)", "class_method_signature": "ALU.floatSubtraction(String operand1, String operand2, int eLength, int sLength, int gLength)", "testcase": false, "constructor": false}, {"identifier": "floatMultiplication", "parameters": "(String operand1, String operand2, int eLength, int sLength)", "modifiers": "public", "return": "String", "signature": "String floatMultiplication(String operand1, String operand2, int eLength, int sLength)", "full_signature": "public String floatMultiplication(String operand1, String operand2, int eLength, int sLength)", "class_method_signature": "ALU.floatMultiplication(String operand1, String operand2, int eLength, int sLength)", "testcase": false, "constructor": false}, {"identifier": "floatDivision", "parameters": "(String operand1, String operand2, int eLength, int sLength)", "modifiers": "public", "return": "String", "signature": "String floatDivision(String operand1, String operand2, int eLength, int sLength)", "full_signature": "public String floatDivision(String operand1, String operand2, int eLength, int sLength)", "class_method_signature": "ALU.floatDivision(String operand1, String operand2, int eLength, int sLength)", "testcase": false, "constructor": false}, {"identifier": "trueFormDivision", "parameters": "(String operand1, String operand2, int length)", "modifiers": "public", "return": "String", "signature": "String trueFormDivision(String operand1, String operand2, int length)", "full_signature": "public String trueFormDivision(String operand1, String operand2, int length)", "class_method_signature": "ALU.trueFormDivision(String operand1, String operand2, int length)", "testcase": false, "constructor": false}], "file": "Computer Organization and System Architecture/ALUSimulator/src/ALU.java"}, "focal_method": {"identifier": "floatRepresentation", "parameters": "(String number, int eLength, int sLength)", "modifiers": "public", "return": "String", "body": "public String floatRepresentation (String number, int eLength, int sLength) {\n\t\tlong upperBound = (long) (Math.pow(2,Math.pow(2, eLength-1)) - Math.pow(2, Math.pow(2, eLength-1)-sLength-1));\n\n\n\n\t\tdouble lowerBound = Math.pow(2, -Math.pow(2, eLength)-2-sLength); \n\n\t\tlong shift = (long)(Math.pow(2, eLength-1)-1);\n\t\t\n\t\tboolean isNegative = number.startsWith(\"-\");\n\t\tString firstBit = isNegative ? \"1\" : \"0\";\n\t\t\n\t\tdouble trueValue;\n\t\tif(number.contains(\"Inf\")){\n\t\t\treturn firstBit+ALU.repeatedString(\"1\", eLength)+ALU.repeatedString(\"0\", sLength);\n\t\t}\n\t\ttry{\n\t\t\ttrueValue = Double.parseDouble(number);\n\t\t\tif (Double.isNaN(trueValue)){\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\n\t\t}\n\t\tcatch(NumberFormatException e){\n\t\t\treturn firstBit+repeatedString(\"1\", eLength)+repeatedString(\"0\", sLength-1)+\"1\";\n\t\t}\n\t\t\n\t\t//Returns 0 if trueValue is 0\n\t\tif (Math.abs(trueValue)<=lowerBound){\n\t\t\treturn firstBit+repeatedString(\"0\", eLength+sLength);\n\t\t}\n\t\t\n\t\t//Returns +Inf if trueValue is greater than the upper bound\n\t\tif (trueValue>=upperBound){\n\t\t\treturn \"0\"+repeatedString(\"1\", eLength)+repeatedString(\"0\", sLength);\n\t\t}\n\t\t\n\t\t//Returns -Inf if trueValue is less than the lower bound\n\t\tif (trueValue<=-upperBound){\n\t\t\treturn \"1\"+repeatedString(\"1\", eLength)+repeatedString(\"0\", sLength);\n\t\t}\n\t\t\n\t\ttrueValue = Math.abs(trueValue);\n\t\t\n\t\t//denormalized\n\t\tif (trueValue<Math.pow(2, -Math.pow(2, eLength-2))){\n\t\t\tStringBuilder result = new StringBuilder(isNegative ?\"1\" : \"0\");\n\t\t\tresult.append(repeatedString(\"0\", eLength));\n\t\t\ttrueValue*=Math.pow(2,shift-1);\n\t\t\twhile (result.length()!=1+eLength+sLength){\n\t\t\t\ttrueValue *=2;\n\t\t\t\tif ((int)trueValue==1) {\n\t\t\t\t\tresult.append(\"1\");\n\t\t\t\t\ttrueValue--;\n\t\t\t\t}else{\n\t\t\t\t\tresult.append(\"0\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.toString();\n\t\t}\n\t\t\n\n\t\tStringBuilder result = new StringBuilder(firstBit);\n\t\t\n\t\t//convert float to binary sequence\n\t\tStringBuilder binary = new StringBuilder();\n\n\t\t\n\t\tString integerPart = integerBinRepresentationInMinLength(String.valueOf((int)trueValue));\n\t\tbinary.append(integerPart).append(\".\");\n\t\t\n\t\tdouble decFloatPart = trueValue - (int)trueValue;\n\t\t\n\t\twhile(binary.length()<=sLength+3){ //sLength+2 preserves the required number length. sLength with 0 and dot\n\t\t\tdecFloatPart *=2;\n\t\t\tif ((int)decFloatPart==1){\n\t\t\t\tbinary.append(\"1\");\n\t\t\t\tdecFloatPart--;\n\t\t\t}else{\n\t\t\t\tbinary.append(\"0\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tint firstOneIndex = binary.indexOf(\"1\");\n\n\t\t//if no 1 exists, indicates the value can be 0\n\t\tif (firstOneIndex==-1){\n\t\t\treturn result.append(repeatedString(\"0\", sLength+eLength)).toString();\n\t\t}\n\t\t\n\t\t//gets the index of dot. Appends if not exist.\n\t\tint dotIndex = binary.indexOf(\".\");\n\t\tif (dotIndex==-1){\n\t\t\tbinary.append(\".\");\n\t\t\tdotIndex = binary.length()-1;\n\t\t}\n\n\t\tlong exponent =shift;\n\t\tif (dotIndex>firstOneIndex){//1001.111, firstOneIndex=0, dotIndex=5, should be 4\n\t\t\texponent += dotIndex-firstOneIndex-1; \n\t\t}else{ //0.000101, firstOneIndex=5, dotIndex=1, should be -4\n\t\t\texponent += dotIndex-firstOneIndex;\n\t\t}\n\t\tString exponentPart = integerRepresentation(String.valueOf(exponent), eLength);\n\t\tresult.append(exponentPart);\n\n\t\tStringBuilder mantissa = new StringBuilder(binary.substring(firstOneIndex+1).replace(\".\",\"\"));\n\t\tmantissa.append(repeatedString(\"0\", sLength-mantissa.length()));\n\t\tresult.append(mantissa);\n\n\t\tresult.setLength(1+eLength+sLength); //preserves length\n\n\t\treturn result.toString();\n\t}", "signature": "String floatRepresentation(String number, int eLength, int sLength)", "full_signature": "public String floatRepresentation(String number, int eLength, int sLength)", "class_method_signature": "ALU.floatRepresentation(String number, int eLength, int sLength)", "testcase": false, "constructor": false, "invocations": ["pow", "pow", "pow", "pow", "pow", "pow", "pow", "startsWith", "contains", "repeatedString", "repeatedString", "parseDouble", "isNaN", "repeatedString", "repeatedString", "abs", "repeatedString", "repeatedString", "repeatedString", "repeatedString", "repeatedString", "abs", "pow", "pow", "append", "repeatedString", "pow", "length", "append", "append", "toString", "integerBinRepresentationInMinLength", "valueOf", "append", "append", "length", "append", "append", "indexOf", "toString", "append", "repeatedString", "indexOf", "append", "length", "integerRepresentation", "valueOf", "append", "replace", "substring", "append", "repeatedString", "length", "append", "setLength", "toString"]}, "repository": {"repo_id": 71779309, "url": "https://github.com/ddadaal/Homework", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 8, "size": 28192, "license": "licensed"}}