{"test_class": {"identifier": "TemplateParserTest", "superclass": "", "interfaces": "", "fields": [], "file": "httl/src/test/java/httl/spi/parsers/TemplateParserTest.java"}, "test_case": {"identifier": "testSplitDefine", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testSplitDefine() throws Exception {\n\t\t// without type\n\t\tList<String> list = TemplateParser.splitDefine(\"book\");\n\t\tAssert.assertEquals(1, list.size());\n\t\tAssert.assertEquals(\"book\", list.get(0));\n\n\t\tlist = TemplateParser.splitDefine(\"book1, book2\");\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(\"book1\", list.get(0));\n\t\tAssert.assertEquals(\" book2\", list.get(1));\n\n\t\tlist = TemplateParser.splitDefine(\"book1, book2, book3\");\n\t\tAssert.assertEquals(3, list.size());\n\t\tAssert.assertEquals(\"book1\", list.get(0));\n\t\tAssert.assertEquals(\" book2\", list.get(1));\n\t\tAssert.assertEquals(\" book3\", list.get(2));\n\n\t\t// with simple type\n\t\tlist = TemplateParser.splitDefine(\"Book book\");\n\t\tAssert.assertEquals(1, list.size());\n\t\tAssert.assertEquals(\"Book book\", list.get(0));\n\n\t\tlist = TemplateParser.splitDefine(\"Book book1, Book book2\");\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(\"Book book1\", list.get(0));\n\t\tAssert.assertEquals(\" Book book2\", list.get(1));\n\n\t\tlist = TemplateParser.splitDefine(\"Book book1, Book book2, Book book3\");\n\t\tAssert.assertEquals(3, list.size());\n\t\tAssert.assertEquals(\"Book book1\", list.get(0));\n\t\tAssert.assertEquals(\" Book book2\", list.get(1));\n\t\tAssert.assertEquals(\" Book book3\", list.get(2));\n\n\t\t// with generic type\n\t\tlist = TemplateParser.splitDefine(\"Map<String, Book> books\");\n\t\tAssert.assertEquals(1, list.size());\n\t\tAssert.assertEquals(\"Map<String, Book> books\", list.get(0));\n\n\t\tlist = TemplateParser.splitDefine(\"Map<String, Book> bookMap, Map<String, Book> bookMap2\");\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(\"Map<String, Book> bookMap\", list.get(0));\n\t\tAssert.assertEquals(\" Map<String, Book> bookMap2\", list.get(1));\n\n\t\tlist = TemplateParser.splitDefine(\"Map<String, Book> bookMap, Map<String, Book> bookMap2, Map<String, Book> bookMap3\");\n\t\tAssert.assertEquals(3, list.size());\n\t\tAssert.assertEquals(\"Map<String, Book> bookMap\", list.get(0));\n\t\tAssert.assertEquals(\" Map<String, Book> bookMap2\", list.get(1));\n\t\tAssert.assertEquals(\" Map<String, Book> bookMap3\", list.get(2));\n\n\t\t// with multi type\n\t\tlist = TemplateParser.splitDefine(\"Book book1, book2\");\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(\"Book book1\", list.get(0));\n\t\tAssert.assertEquals(\" book2\", list.get(1));\n\n\t\tlist = TemplateParser.splitDefine(\"Map<String, Book> bookMap, book\");\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(\"Map<String, Book> bookMap\", list.get(0));\n\t\tAssert.assertEquals(\" book\", list.get(1));\n\n\t\tlist = TemplateParser.splitDefine(\"Map<String, Book> bookMap, Book book\");\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(\"Map<String, Book> bookMap\", list.get(0));\n\t\tAssert.assertEquals(\" Book book\", list.get(1));\n\n\t\tlist = TemplateParser.splitDefine(\"Map<String, Book> bookMap, Book book1, book2\");\n\t\tAssert.assertEquals(3, list.size());\n\t\tAssert.assertEquals(\"Map<String, Book> bookMap\", list.get(0));\n\t\tAssert.assertEquals(\" Book book1\", list.get(1));\n\t\tAssert.assertEquals(\" book2\", list.get(2));\n\t\t\n\t\tlist = TemplateParser.splitDefine(\"book1, Book book2\");\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(\"book1\", list.get(0));\n\t\tAssert.assertEquals(\" Book book2\", list.get(1));\n\n\t\tlist = TemplateParser.splitDefine(\"book, Map<String, Book> bookMap\");\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(\"book\", list.get(0));\n\t\tAssert.assertEquals(\" Map<String, Book> bookMap\", list.get(1));\n\n\t\tlist = TemplateParser.splitDefine(\"Book book, Map<String, Book> bookMap\");\n\t\tAssert.assertEquals(2, list.size());\n\t\tAssert.assertEquals(\"Book book\", list.get(0));\n\t\tAssert.assertEquals(\" Map<String, Book> bookMap\", list.get(1));\n\n\t\tlist = TemplateParser.splitDefine(\"book1, Book book2, Map<String, Book> bookMap\");\n\t\tAssert.assertEquals(3, list.size());\n\t\tAssert.assertEquals(\"book1\", list.get(0));\n\t\tAssert.assertEquals(\" Book book2\", list.get(1));\n\t\tAssert.assertEquals(\" Map<String, Book> bookMap\", list.get(2));\n\t}", "signature": "void testSplitDefine()", "full_signature": "@Test public void testSplitDefine()", "class_method_signature": "TemplateParserTest.testSplitDefine()", "testcase": true, "constructor": false, "invocations": ["splitDefine", "assertEquals", "size", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "splitDefine", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "TemplateParser", "superclass": "", "interfaces": "implements Parser", "fields": [{"original_string": "private static final int E = DfaScanner.BREAK;", "modifier": "private static final", "type": "int", "declarator": "E = DfaScanner.BREAK", "var_name": "E"}, {"original_string": "private static final int B = DfaScanner.BREAK - 1;", "modifier": "private static final", "type": "int", "declarator": "B = DfaScanner.BREAK - 1", "var_name": "B"}, {"original_string": "private static final int S = DfaScanner.BACKSPACE - 1;", "modifier": "private static final", "type": "int", "declarator": "S = DfaScanner.BACKSPACE - 1", "var_name": "S"}, {"original_string": "private static final int P = DfaScanner.PUSH - 4;", "modifier": "private static final", "type": "int", "declarator": "P = DfaScanner.PUSH - 4", "var_name": "P"}, {"original_string": "private static final int O = DfaScanner.POP - 4;", "modifier": "private static final", "type": "int", "declarator": "O = DfaScanner.POP - 4", "var_name": "O"}, {"original_string": "private static final int P2 = DfaScanner.PUSH - 7;", "modifier": "private static final", "type": "int", "declarator": "P2 = DfaScanner.PUSH - 7", "var_name": "P2"}, {"original_string": "private static final int O2 = DfaScanner.POP - 7;", "modifier": "private static final", "type": "int", "declarator": "O2 = DfaScanner.POP - 7", "var_name": "O2"}, {"original_string": "static final int states[][] = {\n            // 0.\\s, 1.a-z, 2.#, 3.$, 4.!, 5.*, 6.(, 7.), 8.[, 9.], 10.{, 11.}, 12.\", 13.', 14.`, 15.\\, 16.\\r\\n, 17.\u5176\u5b83\n        /* 0.\u8d77\u59cb */ {1, 1, 2, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1,}, // \u521d\u59cb\u72b6\u6001\u6216\u4e0a\u4e00\u7247\u65ad\u521a\u63a5\u6536\u5b8c\u6210\u72b6\u6001\n        /* 1.\u6587\u672c */ {1, 1, B, B, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1,}, // \u975e\u6307\u4ee4\u6587\u672c\u5185\u5bb9\n\n\t\t/* 2.\u6307\u4ee4 */ {1, 3, 9, B, 6, 10, 1, 1, 12, 1, P2, 1, 1, 1, 1, 1, 1, 1,}, // \u6307\u4ee4\u63d0\u793a\u7b26\n        /* 3.\u6307\u540d */ {26, 3, B, B, B, B, P, B, B, B, B, B, B, B, B, B, B, B,}, // \u6307\u4ee4\u540d\n        /* 4.\u6307\u53c2 */ {4, 4, 4, 4, 4, 4, P, O, 4, 4, 4, 4, 14, 16, 18, 4, 4, 4,}, // \u6307\u4ee4\u53c2\u6570\n\n\t\t/* 5.\u63d2\u503c */ {1, 1, B, B, 6, 1, 1, 1, 1, 1, P2, 1, 1, 1, 1, 1, 1, 1,}, // \u63d2\u503c\u63d0\u793a\u7b26\n        /* 6.\u975e\u6ee4 */ {1, 1, B, B, 1, 1, 1, 1, 1, 1, P2, 1, 1, 1, 1, 1, 1, 1,}, // \u975e\u8fc7\u6ee4\u63d2\u503c\n\t\t/* 7.\u63d2\u53c2 */ {7, 7, 7, 7, 7, 7, 7, 7, 7, 7, P2, O2, 20, 22, 24, 7, 7, 7,}, // \u63d2\u503c\u53c2\u6570\n\t\t\n\t\t/* 8.\u8f6c\u4e49 */ {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,}, // \u4e95\u53f7\u7f8e\u5143\u53f7\u8f6c\u4e49\n\t\t/* 9.\u884c\u6ce8 */ {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, B, 9,}, // \u53cc\u4e95\u53f7\u884c\u6ce8\u91ca\n\t\t/* 10.\u5757\u6ce8 */ {10, 10, 10, 10, 10, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,}, // \u4e95\u661f\u53f7\u5757\u6ce8\u91ca\n\t\t/* 11.\u7ed3\u5757 */ {10, 10, E, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,}, // \u4e95\u661f\u53f7\u5757\u6ce8\u91ca\u7ed3\u675f\n\t\t/* 12.\u5b57\u9762 */ {12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12,}, // \u4e95\u65b9\u53f7\u5757\u5b57\u9762\u4e0d\u89e3\u6790\u5757\n\t\t/* 13.\u7ed3\u5b57 */ {12, 12, E, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,}, // \u4e95\u65b9\u53f7\u5757\u5b57\u9762\u4e0d\u89e3\u6790\u5757\u7ed3\u675f\n\t\t\n\t\t/* 14.\u5b57\u4e32 */ {14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 4, 14, 14, 15, 14, 14,}, // \u6307\u4ee4\u53c2\u6570\u53cc\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 15.\u8f6c\u5b57 */ {14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,}, // \u6307\u4ee4\u53c2\u6570\u53cc\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t/* 16.\u5b57\u4e32 */ {16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 16, 17, 16, 16,}, // \u6307\u4ee4\u53c2\u6570\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 17.\u8f6c\u5b57 */ {16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,}, // \u6307\u4ee4\u53c2\u6570\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t/* 18.\u5b57\u4e32 */ {18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 4, 19, 18, 18,}, // \u6307\u4ee4\u53c2\u6570\u53cd\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 19.\u8f6c\u5b57 */ {18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,}, // \u6307\u4ee4\u53c2\u6570\u53cd\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t\n\t\t/* 20.\u5b57\u4e32 */ {20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 7, 20, 20, 21, 20, 20,}, // \u63d2\u503c\u53c2\u6570\u53cc\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 21.\u8f6c\u5b57 */ {20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,}, // \u63d2\u503c\u53c2\u6570\u53cc\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t/* 22.\u5b57\u4e32 */ {22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 7, 22, 23, 22, 22,}, // \u63d2\u503c\u53c2\u6570\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 23.\u8f6c\u5b57 */ {22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,}, // \u63d2\u503c\u53c2\u6570\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t/* 24.\u5b57\u4e32 */ {24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 7, 25, 24, 24,}, // \u63d2\u503c\u53c2\u6570\u53cd\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 25.\u8f6c\u5b57 */ {24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,}, // \u63d2\u503c\u53c2\u6570\u53cd\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t\n\t\t/* 26.\u6307\u95f4\u7a7a\u767d */ {26, S, S, S, S, S, P, S, S, S, S, S, S, S, S, S, S, S,}, // \u6307\u4ee4\u540d\u548c\u62ec\u53f7\u95f4\u7684\u7a7a\u767d\n    };", "modifier": "static final", "type": "int", "declarator": "states[][] = {\n            // 0.\\s, 1.a-z, 2.#, 3.$, 4.!, 5.*, 6.(, 7.), 8.[, 9.], 10.{, 11.}, 12.\", 13.', 14.`, 15.\\, 16.\\r\\n, 17.\u5176\u5b83\n        /* 0.\u8d77\u59cb */ {1, 1, 2, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1,}, // \u521d\u59cb\u72b6\u6001\u6216\u4e0a\u4e00\u7247\u65ad\u521a\u63a5\u6536\u5b8c\u6210\u72b6\u6001\n        /* 1.\u6587\u672c */ {1, 1, B, B, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1,}, // \u975e\u6307\u4ee4\u6587\u672c\u5185\u5bb9\n\n\t\t/* 2.\u6307\u4ee4 */ {1, 3, 9, B, 6, 10, 1, 1, 12, 1, P2, 1, 1, 1, 1, 1, 1, 1,}, // \u6307\u4ee4\u63d0\u793a\u7b26\n        /* 3.\u6307\u540d */ {26, 3, B, B, B, B, P, B, B, B, B, B, B, B, B, B, B, B,}, // \u6307\u4ee4\u540d\n        /* 4.\u6307\u53c2 */ {4, 4, 4, 4, 4, 4, P, O, 4, 4, 4, 4, 14, 16, 18, 4, 4, 4,}, // \u6307\u4ee4\u53c2\u6570\n\n\t\t/* 5.\u63d2\u503c */ {1, 1, B, B, 6, 1, 1, 1, 1, 1, P2, 1, 1, 1, 1, 1, 1, 1,}, // \u63d2\u503c\u63d0\u793a\u7b26\n        /* 6.\u975e\u6ee4 */ {1, 1, B, B, 1, 1, 1, 1, 1, 1, P2, 1, 1, 1, 1, 1, 1, 1,}, // \u975e\u8fc7\u6ee4\u63d2\u503c\n\t\t/* 7.\u63d2\u53c2 */ {7, 7, 7, 7, 7, 7, 7, 7, 7, 7, P2, O2, 20, 22, 24, 7, 7, 7,}, // \u63d2\u503c\u53c2\u6570\n\t\t\n\t\t/* 8.\u8f6c\u4e49 */ {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,}, // \u4e95\u53f7\u7f8e\u5143\u53f7\u8f6c\u4e49\n\t\t/* 9.\u884c\u6ce8 */ {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, B, 9,}, // \u53cc\u4e95\u53f7\u884c\u6ce8\u91ca\n\t\t/* 10.\u5757\u6ce8 */ {10, 10, 10, 10, 10, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,}, // \u4e95\u661f\u53f7\u5757\u6ce8\u91ca\n\t\t/* 11.\u7ed3\u5757 */ {10, 10, E, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,}, // \u4e95\u661f\u53f7\u5757\u6ce8\u91ca\u7ed3\u675f\n\t\t/* 12.\u5b57\u9762 */ {12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12,}, // \u4e95\u65b9\u53f7\u5757\u5b57\u9762\u4e0d\u89e3\u6790\u5757\n\t\t/* 13.\u7ed3\u5b57 */ {12, 12, E, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,}, // \u4e95\u65b9\u53f7\u5757\u5b57\u9762\u4e0d\u89e3\u6790\u5757\u7ed3\u675f\n\t\t\n\t\t/* 14.\u5b57\u4e32 */ {14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 4, 14, 14, 15, 14, 14,}, // \u6307\u4ee4\u53c2\u6570\u53cc\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 15.\u8f6c\u5b57 */ {14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,}, // \u6307\u4ee4\u53c2\u6570\u53cc\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t/* 16.\u5b57\u4e32 */ {16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 16, 17, 16, 16,}, // \u6307\u4ee4\u53c2\u6570\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 17.\u8f6c\u5b57 */ {16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,}, // \u6307\u4ee4\u53c2\u6570\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t/* 18.\u5b57\u4e32 */ {18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 4, 19, 18, 18,}, // \u6307\u4ee4\u53c2\u6570\u53cd\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 19.\u8f6c\u5b57 */ {18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,}, // \u6307\u4ee4\u53c2\u6570\u53cd\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t\n\t\t/* 20.\u5b57\u4e32 */ {20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 7, 20, 20, 21, 20, 20,}, // \u63d2\u503c\u53c2\u6570\u53cc\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 21.\u8f6c\u5b57 */ {20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,}, // \u63d2\u503c\u53c2\u6570\u53cc\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t/* 22.\u5b57\u4e32 */ {22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 7, 22, 23, 22, 22,}, // \u63d2\u503c\u53c2\u6570\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 23.\u8f6c\u5b57 */ {22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,}, // \u63d2\u503c\u53c2\u6570\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t/* 24.\u5b57\u4e32 */ {24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 7, 25, 24, 24,}, // \u63d2\u503c\u53c2\u6570\u53cd\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\n\t\t/* 25.\u8f6c\u5b57 */ {24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,}, // \u63d2\u503c\u53c2\u6570\u53cd\u5355\u5f15\u53f7\u5b57\u7b26\u4e32\u8f6c\u4e49\n\t\t\n\t\t/* 26.\u6307\u95f4\u7a7a\u767d */ {26, S, S, S, S, S, P, S, S, S, S, S, S, S, S, S, S, S,}, // \u6307\u4ee4\u540d\u548c\u62ec\u53f7\u95f4\u7684\u7a7a\u767d\n    }", "var_name": "states"}, {"original_string": "private static final Pattern ESCAPE_PATTERN = Pattern.compile(\"\\\\\\\\+[#$]\");", "modifier": "private static final", "type": "Pattern", "declarator": "ESCAPE_PATTERN = Pattern.compile(\"\\\\\\\\+[#$]\")", "var_name": "ESCAPE_PATTERN"}, {"original_string": "private static final Pattern DEFINE_PATTERN = Pattern.compile(\"([\\\\w>\\\\]]\\\\s+\\\\w+)\\\\s*[,]?\");", "modifier": "private static final", "type": "Pattern", "declarator": "DEFINE_PATTERN = Pattern.compile(\"([\\\\w>\\\\]]\\\\s+\\\\w+)\\\\s*[,]?\")", "var_name": "DEFINE_PATTERN"}, {"original_string": "private static final Pattern IMPORT_PATTERN = Pattern.compile(\"[,;]+\");", "modifier": "private static final", "type": "Pattern", "declarator": "IMPORT_PATTERN = Pattern.compile(\"[,;]+\")", "var_name": "IMPORT_PATTERN"}, {"original_string": "private static DfaScanner scanner = new DfaScanner() {\n        @Override\n        public int next(int state, char ch) {\n            return states[state][getCharType(ch)];\n        }\n    };", "modifier": "private static", "type": "DfaScanner", "declarator": "scanner = new DfaScanner() {\n        @Override\n        public int next(int state, char ch) {\n            return states[state][getCharType(ch)];\n        }\n    }", "var_name": "scanner"}, {"original_string": "private final Map<String, Template> importMacroTemplates = new ConcurrentHashMap<String, Template>();", "modifier": "private final", "type": "Map<String, Template>", "declarator": "importMacroTemplates = new ConcurrentHashMap<String, Template>()", "var_name": "importMacroTemplates"}, {"original_string": "private final Map<Class<?>, Object> functions = new ConcurrentHashMap<Class<?>, Object>();", "modifier": "private final", "type": "Map<Class<?>, Object>", "declarator": "functions = new ConcurrentHashMap<Class<?>, Object>()", "var_name": "functions"}, {"original_string": "private String[] setDirective = new String[]{\"set\"};", "modifier": "private", "type": "String[]", "declarator": "setDirective = new String[]{\"set\"}", "var_name": "setDirective"}, {"original_string": "private String[] ifDirective = new String[]{\"if\"};", "modifier": "private", "type": "String[]", "declarator": "ifDirective = new String[]{\"if\"}", "var_name": "ifDirective"}, {"original_string": "private String[] elseDirective = new String[]{\"else\"};", "modifier": "private", "type": "String[]", "declarator": "elseDirective = new String[]{\"else\"}", "var_name": "elseDirective"}, {"original_string": "private String[] forDirective = new String[]{\"for\"};", "modifier": "private", "type": "String[]", "declarator": "forDirective = new String[]{\"for\"}", "var_name": "forDirective"}, {"original_string": "private String[] breakDirective = new String[]{\"break\"};", "modifier": "private", "type": "String[]", "declarator": "breakDirective = new String[]{\"break\"}", "var_name": "breakDirective"}, {"original_string": "private String[] macroDirective = new String[]{\"macro\"};", "modifier": "private", "type": "String[]", "declarator": "macroDirective = new String[]{\"macro\"}", "var_name": "macroDirective"}, {"original_string": "private String[] endDirective = new String[]{\"end\"};", "modifier": "private", "type": "String[]", "declarator": "endDirective = new String[]{\"end\"}", "var_name": "endDirective"}, {"original_string": "private String[] importDirective = new String[]{\"import\"};", "modifier": "private", "type": "String[]", "declarator": "importDirective = new String[]{\"import\"}", "var_name": "importDirective"}, {"original_string": "private Engine engine;", "modifier": "private", "type": "Engine", "declarator": "engine", "var_name": "engine"}, {"original_string": "private Parser expressionParser;", "modifier": "private", "type": "Parser", "declarator": "expressionParser", "var_name": "expressionParser"}, {"original_string": "private String[] importMacros;", "modifier": "private", "type": "String[]", "declarator": "importMacros", "var_name": "importMacros"}, {"original_string": "private String[] importPackages;", "modifier": "private", "type": "String[]", "declarator": "importPackages", "var_name": "importPackages"}, {"original_string": "private String[] importVariables;", "modifier": "private", "type": "String[]", "declarator": "importVariables", "var_name": "importVariables"}, {"original_string": "private Map<String, Class<?>> importTypes;", "modifier": "private", "type": "Map<String, Class<?>>", "declarator": "importTypes", "var_name": "importTypes"}, {"original_string": "private Class<?> defaultVariableType;", "modifier": "private", "type": "Class<?>", "declarator": "defaultVariableType", "var_name": "defaultVariableType"}, {"original_string": "private boolean removeDirectiveBlankLine = true;", "modifier": "private", "type": "boolean", "declarator": "removeDirectiveBlankLine = true", "var_name": "removeDirectiveBlankLine"}], "methods": [{"identifier": "getCharType", "parameters": "(char ch)", "modifiers": "static", "return": "int", "signature": "int getCharType(char ch)", "full_signature": "static int getCharType(char ch)", "class_method_signature": "TemplateParser.getCharType(char ch)", "testcase": false, "constructor": false}, {"identifier": "isEndString", "parameters": "(String value)", "modifiers": "private static", "return": "boolean", "signature": "boolean isEndString(String value)", "full_signature": "private static boolean isEndString(String value)", "class_method_signature": "TemplateParser.isEndString(String value)", "testcase": false, "constructor": false}, {"identifier": "splitAssign", "parameters": "(String value)", "modifiers": "static", "return": "List<String>", "signature": "List<String> splitAssign(String value)", "full_signature": "static List<String> splitAssign(String value)", "class_method_signature": "TemplateParser.splitAssign(String value)", "testcase": false, "constructor": false}, {"identifier": "splitDefine", "parameters": "(String value)", "modifiers": "static", "return": "List<String>", "signature": "List<String> splitDefine(String value)", "full_signature": "static List<String> splitDefine(String value)", "class_method_signature": "TemplateParser.splitDefine(String value)", "testcase": false, "constructor": false}, {"identifier": "isDirective", "parameters": "(String message)", "modifiers": "private", "return": "boolean", "signature": "boolean isDirective(String message)", "full_signature": "private boolean isDirective(String message)", "class_method_signature": "TemplateParser.isDirective(String message)", "testcase": false, "constructor": false}, {"identifier": "isDirectiveName", "parameters": "(String name)", "modifiers": "private", "return": "boolean", "signature": "boolean isDirectiveName(String name)", "full_signature": "private boolean isDirectiveName(String name)", "class_method_signature": "TemplateParser.isDirectiveName(String name)", "testcase": false, "constructor": false}, {"identifier": "defineVariableTypes", "parameters": "(String value, int offset, List<Statement> directives)", "modifiers": "private", "return": "void", "signature": "void defineVariableTypes(String value, int offset, List<Statement> directives)", "full_signature": "private void defineVariableTypes(String value, int offset, List<Statement> directives)", "class_method_signature": "TemplateParser.defineVariableTypes(String value, int offset, List<Statement> directives)", "testcase": false, "constructor": false}, {"identifier": "isNoLiteralText", "parameters": "(Statement node)", "modifiers": "private", "return": "boolean", "signature": "boolean isNoLiteralText(Statement node)", "full_signature": "private boolean isNoLiteralText(Statement node)", "class_method_signature": "TemplateParser.isNoLiteralText(Statement node)", "testcase": false, "constructor": false}, {"identifier": "clean", "parameters": "(List<Statement> nodes)", "modifiers": "private", "return": "List<Statement>", "signature": "List<Statement> clean(List<Statement> nodes)", "full_signature": "private List<Statement> clean(List<Statement> nodes)", "class_method_signature": "TemplateParser.clean(List<Statement> nodes)", "testcase": false, "constructor": false}, {"identifier": "scan", "parameters": "(String source, int sourceOffset)", "modifiers": "private", "return": "List<Statement>", "signature": "List<Statement> scan(String source, int sourceOffset)", "full_signature": "private List<Statement> scan(String source, int sourceOffset)", "class_method_signature": "TemplateParser.scan(String source, int sourceOffset)", "testcase": false, "constructor": false}, {"identifier": "reduce", "parameters": "(List<Statement> directives)", "modifiers": "private", "return": "BlockDirective", "signature": "BlockDirective reduce(List<Statement> directives)", "full_signature": "private BlockDirective reduce(List<Statement> directives)", "class_method_signature": "TemplateParser.reduce(List<Statement> directives)", "testcase": false, "constructor": false}, {"identifier": "setRemoveDirectiveBlankLine", "parameters": "(boolean removeDirectiveBlankLine)", "modifiers": "public", "return": "void", "signature": "void setRemoveDirectiveBlankLine(boolean removeDirectiveBlankLine)", "full_signature": "public void setRemoveDirectiveBlankLine(boolean removeDirectiveBlankLine)", "class_method_signature": "TemplateParser.setRemoveDirectiveBlankLine(boolean removeDirectiveBlankLine)", "testcase": false, "constructor": false}, {"identifier": "setSetDirective", "parameters": "(String[] setDirective)", "modifiers": "public", "return": "void", "signature": "void setSetDirective(String[] setDirective)", "full_signature": "public void setSetDirective(String[] setDirective)", "class_method_signature": "TemplateParser.setSetDirective(String[] setDirective)", "testcase": false, "constructor": false}, {"identifier": "setIfDirective", "parameters": "(String[] ifDirective)", "modifiers": "public", "return": "void", "signature": "void setIfDirective(String[] ifDirective)", "full_signature": "public void setIfDirective(String[] ifDirective)", "class_method_signature": "TemplateParser.setIfDirective(String[] ifDirective)", "testcase": false, "constructor": false}, {"identifier": "setElseDirective", "parameters": "(String[] elseDirective)", "modifiers": "public", "return": "void", "signature": "void setElseDirective(String[] elseDirective)", "full_signature": "public void setElseDirective(String[] elseDirective)", "class_method_signature": "TemplateParser.setElseDirective(String[] elseDirective)", "testcase": false, "constructor": false}, {"identifier": "setForDirective", "parameters": "(String[] forDirective)", "modifiers": "public", "return": "void", "signature": "void setForDirective(String[] forDirective)", "full_signature": "public void setForDirective(String[] forDirective)", "class_method_signature": "TemplateParser.setForDirective(String[] forDirective)", "testcase": false, "constructor": false}, {"identifier": "setBreakDirective", "parameters": "(String[] breakDirective)", "modifiers": "public", "return": "void", "signature": "void setBreakDirective(String[] breakDirective)", "full_signature": "public void setBreakDirective(String[] breakDirective)", "class_method_signature": "TemplateParser.setBreakDirective(String[] breakDirective)", "testcase": false, "constructor": false}, {"identifier": "setMacroDirective", "parameters": "(String[] macroDirective)", "modifiers": "public", "return": "void", "signature": "void setMacroDirective(String[] macroDirective)", "full_signature": "public void setMacroDirective(String[] macroDirective)", "class_method_signature": "TemplateParser.setMacroDirective(String[] macroDirective)", "testcase": false, "constructor": false}, {"identifier": "setEndDirective", "parameters": "(String[] endDirective)", "modifiers": "public", "return": "void", "signature": "void setEndDirective(String[] endDirective)", "full_signature": "public void setEndDirective(String[] endDirective)", "class_method_signature": "TemplateParser.setEndDirective(String[] endDirective)", "testcase": false, "constructor": false}, {"identifier": "setDefaultVariableType", "parameters": "(String defaultVariableType)", "modifiers": "public", "return": "void", "signature": "void setDefaultVariableType(String defaultVariableType)", "full_signature": "public void setDefaultVariableType(String defaultVariableType)", "class_method_signature": "TemplateParser.setDefaultVariableType(String defaultVariableType)", "testcase": false, "constructor": false}, {"identifier": "setImportMacros", "parameters": "(String[] importMacros)", "modifiers": "public", "return": "void", "signature": "void setImportMacros(String[] importMacros)", "full_signature": "public void setImportMacros(String[] importMacros)", "class_method_signature": "TemplateParser.setImportMacros(String[] importMacros)", "testcase": false, "constructor": false}, {"identifier": "setEngine", "parameters": "(Engine engine)", "modifiers": "public", "return": "void", "signature": "void setEngine(Engine engine)", "full_signature": "public void setEngine(Engine engine)", "class_method_signature": "TemplateParser.setEngine(Engine engine)", "testcase": false, "constructor": false}, {"identifier": "setExpressionParser", "parameters": "(Parser expressionParser)", "modifiers": "public", "return": "void", "signature": "void setExpressionParser(Parser expressionParser)", "full_signature": "public void setExpressionParser(Parser expressionParser)", "class_method_signature": "TemplateParser.setExpressionParser(Parser expressionParser)", "testcase": false, "constructor": false}, {"identifier": "setImportPackages", "parameters": "(String[] importPackages)", "modifiers": "public", "return": "void", "signature": "void setImportPackages(String[] importPackages)", "full_signature": "public void setImportPackages(String[] importPackages)", "class_method_signature": "TemplateParser.setImportPackages(String[] importPackages)", "testcase": false, "constructor": false}, {"identifier": "setImportVariables", "parameters": "(String[] importVariables)", "modifiers": "public", "return": "void", "signature": "void setImportVariables(String[] importVariables)", "full_signature": "public void setImportVariables(String[] importVariables)", "class_method_signature": "TemplateParser.setImportVariables(String[] importVariables)", "testcase": false, "constructor": false}, {"identifier": "setImportMethods", "parameters": "(Object[] importMethods)", "modifiers": "public", "return": "void", "signature": "void setImportMethods(Object[] importMethods)", "full_signature": "public void setImportMethods(Object[] importMethods)", "class_method_signature": "TemplateParser.setImportMethods(Object[] importMethods)", "testcase": false, "constructor": false}, {"identifier": "getImportDirective", "parameters": "()", "modifiers": "public", "return": "String[]", "signature": "String[] getImportDirective()", "full_signature": "public String[] getImportDirective()", "class_method_signature": "TemplateParser.getImportDirective()", "testcase": false, "constructor": false}, {"identifier": "init", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void init()", "full_signature": "public void init()", "class_method_signature": "TemplateParser.init()", "testcase": false, "constructor": false}, {"identifier": "inited", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void inited()", "full_signature": "public void inited()", "class_method_signature": "TemplateParser.inited()", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "(String source, int offset)", "modifiers": "public", "return": "Node", "signature": "Node parse(String source, int offset)", "full_signature": "public Node parse(String source, int offset)", "class_method_signature": "TemplateParser.parse(String source, int offset)", "testcase": false, "constructor": false}, {"identifier": "trim", "parameters": "(List<Statement> nodes)", "modifiers": "private", "return": "List<Statement>", "signature": "List<Statement> trim(List<Statement> nodes)", "full_signature": "private List<Statement> trim(List<Statement> nodes)", "class_method_signature": "TemplateParser.trim(List<Statement> nodes)", "testcase": false, "constructor": false}, {"identifier": "isTrimableDirective", "parameters": "(Statement node)", "modifiers": "private", "return": "boolean", "signature": "boolean isTrimableDirective(Statement node)", "full_signature": "private boolean isTrimableDirective(Statement node)", "class_method_signature": "TemplateParser.isTrimableDirective(Statement node)", "testcase": false, "constructor": false}, {"identifier": "filterEscape", "parameters": "(String source)", "modifiers": "private", "return": "String", "signature": "String filterEscape(String source)", "full_signature": "private String filterEscape(String source)", "class_method_signature": "TemplateParser.filterEscape(String source)", "testcase": false, "constructor": false}, {"identifier": "parseGenericType", "parameters": "(String type, int offset, List<Statement> directives)", "modifiers": "private", "return": "Type", "signature": "Type parseGenericType(String type, int offset, List<Statement> directives)", "full_signature": "private Type parseGenericType(String type, int offset, List<Statement> directives)", "class_method_signature": "TemplateParser.parseGenericType(String type, int offset, List<Statement> directives)", "testcase": false, "constructor": false}, {"identifier": "parseGenericTypeString", "parameters": "(String type, int offset, List<String> types, List<Integer> offsets)", "modifiers": "private", "return": "void", "signature": "void parseGenericTypeString(String type, int offset, List<String> types, List<Integer> offsets)", "full_signature": "private void parseGenericTypeString(String type, int offset, List<String> types, List<Integer> offsets)", "class_method_signature": "TemplateParser.parseGenericTypeString(String type, int offset, List<String> types, List<Integer> offsets)", "testcase": false, "constructor": false}], "file": "httl/src/main/java/httl/spi/parsers/TemplateParser.java"}, "focal_method": {"identifier": "splitDefine", "parameters": "(String value)", "modifiers": "static", "return": "List<String>", "body": "static List<String> splitDefine(String value) {\n        List<String> vs = new ArrayList<String>();\n        Matcher matcher = DEFINE_PATTERN.matcher(value);\n        while (matcher.find()) {\n            StringBuffer rep = new StringBuffer();\n            matcher.appendReplacement(rep, \"$1\");\n            String v = rep.toString();\n            if (v.contains(\",\")) {\n                if (!v.contains(\"<\")) {\n                    vs.addAll(Arrays.asList(v.split(\",\")));\n                } else if (v.indexOf(',') < v.indexOf('<')) {\n                    int j = v.indexOf('<');\n                    int i = v.substring(0, j).lastIndexOf(',');\n                    vs.addAll(Arrays.asList(v.substring(0, i).split(\",\")));\n                    vs.add(v.substring(i + 1));\n                } else {\n                    vs.add(v);\n                }\n            } else {\n                vs.add(v);\n            }\n        }\n        if (vs.size() == 0) {\n            vs = Arrays.asList(value.split(\",\"));\n        } else {\n            StringBuffer tail = new StringBuffer();\n            matcher.appendTail(tail);\n            if (tail.toString().trim().length() > 0) {\n                vs.add(tail.toString());\n            }\n        }\n        return vs;\n    }", "signature": "List<String> splitDefine(String value)", "full_signature": "static List<String> splitDefine(String value)", "class_method_signature": "TemplateParser.splitDefine(String value)", "testcase": false, "constructor": false, "invocations": ["matcher", "find", "appendReplacement", "toString", "contains", "contains", "addAll", "asList", "split", "indexOf", "indexOf", "indexOf", "lastIndexOf", "substring", "addAll", "asList", "split", "substring", "add", "substring", "add", "add", "size", "asList", "split", "appendTail", "length", "trim", "toString", "add", "toString"]}, "repository": {"repo_id": 6354623, "url": "https://github.com/httl/httl", "language": "Java", "is_fork": false, "fork_count": 149, "stargazer_count": 337, "size": 2812, "license": "licensed"}}