{"test_class": {"identifier": "CpuThreadStateDataSeriesTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final FakeTimer myTimer = new FakeTimer();", "modifier": "private final", "type": "FakeTimer", "declarator": "myTimer = new FakeTimer()", "var_name": "myTimer"}, {"original_string": "private final FakeIdeProfilerServices myIdeProfilerServices = new FakeIdeProfilerServices();", "modifier": "private final", "type": "FakeIdeProfilerServices", "declarator": "myIdeProfilerServices = new FakeIdeProfilerServices()", "var_name": "myIdeProfilerServices"}, {"original_string": "private final FakeCpuService myService = new FakeCpuService();", "modifier": "private final", "type": "FakeCpuService", "declarator": "myService = new FakeCpuService()", "var_name": "myService"}, {"original_string": "private final FakeTransportService myTransportService = new FakeTransportService(myTimer);", "modifier": "private final", "type": "FakeTransportService", "declarator": "myTransportService = new FakeTransportService(myTimer)", "var_name": "myTransportService"}, {"original_string": "private CpuProfilerStage myProfilerStage;", "modifier": "private", "type": "CpuProfilerStage", "declarator": "myProfilerStage", "var_name": "myProfilerStage"}, {"original_string": "private boolean myIsUnifiedPipeline;", "modifier": "private", "type": "boolean", "declarator": "myIsUnifiedPipeline", "var_name": "myIsUnifiedPipeline"}, {"original_string": "@Rule\n  public FakeGrpcChannel myGrpcChannel =\n    new FakeGrpcChannel(\"CpuProfilerStageTestChannel\", myService, myTransportService, new FakeProfilerService(myTimer),\n                        new FakeMemoryService(), new FakeEventService(), FakeNetworkService.newBuilder().build());", "modifier": "@Rule\n  public", "type": "FakeGrpcChannel", "declarator": "myGrpcChannel =\n    new FakeGrpcChannel(\"CpuProfilerStageTestChannel\", myService, myTransportService, new FakeProfilerService(myTimer),\n                        new FakeMemoryService(), new FakeEventService(), FakeNetworkService.newBuilder().build())", "var_name": "myGrpcChannel"}], "file": "profilers/testSrc/com/android/tools/profilers/cpu/CpuThreadStateDataSeriesTest.java"}, "test_case": {"identifier": "captureBeforeFirstActivity", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void captureBeforeFirstActivity() throws Exception {\n    // CPU recording is not supported in new pipeline yet.\n    Assume.assumeFalse(myIsUnifiedPipeline);\n\n    // Generate and select a capture in the stage\n    CpuProfilerTestUtils.captureSuccessfully(myProfilerStage, myService, myTransportService, CpuProfilerTestUtils.readValidTrace());\n    CpuCapture capture = myProfilerStage.getCapture();\n    assertNotNull(capture);\n    int tid = capture.getMainThreadId();\n\n    // Create a series with trace file's main thread tid and the capture range\n    DataSeries<CpuProfilerStage.ThreadState> series = createThreadSeries(tid);\n\n    // Create the thread activities to be 1 second after the capture\n    myService.addThreads(tid, \"main\", Arrays.asList(\n      CpuProfiler.GetThreadsResponse.ThreadActivity.newBuilder()\n        .setTimestamp(TimeUnit.MICROSECONDS.toNanos((long)capture.getRange().getMin()) + TimeUnit.SECONDS.toNanos(1))\n        .setNewState(Cpu.CpuThreadData.State.RUNNING).build(),\n      CpuProfiler.GetThreadsResponse.ThreadActivity.newBuilder()\n        .setTimestamp(TimeUnit.MICROSECONDS.toNanos((long)capture.getRange().getMin()) + TimeUnit.SECONDS.toNanos(2))\n        .setNewState(Cpu.CpuThreadData.State.SLEEPING).build()));\n\n    List<SeriesData<CpuProfilerStage.ThreadState>> dataSeries = series.getDataForRange(new Range(Long.MIN_VALUE, Long.MAX_VALUE));\n    assertNotNull(dataSeries);\n\n    // We expect the portions of the thread activities that are within the capture range to be duplicated with a \"_CAPTURED\" suffix.\n    // The first activity happens inside the capture, therefore it has only the \"_CAPTURED\" state.\n    assertEquals(3, dataSeries.size());\n    assertEquals(CpuProfilerStage.ThreadState.RUNNING_CAPTURED, dataSeries.get(0).value);\n    assertEquals(CpuProfilerStage.ThreadState.SLEEPING_CAPTURED, dataSeries.get(1).value);\n    assertEquals(CpuProfilerStage.ThreadState.SLEEPING, dataSeries.get(2).value);\n  }", "signature": "void captureBeforeFirstActivity()", "full_signature": "@Test public void captureBeforeFirstActivity()", "class_method_signature": "CpuThreadStateDataSeriesTest.captureBeforeFirstActivity()", "testcase": true, "constructor": false, "invocations": ["assumeFalse", "captureSuccessfully", "readValidTrace", "getCapture", "assertNotNull", "getMainThreadId", "createThreadSeries", "addThreads", "asList", "build", "setNewState", "setTimestamp", "newBuilder", "toNanos", "getMin", "getRange", "toNanos", "build", "setNewState", "setTimestamp", "newBuilder", "toNanos", "getMin", "getRange", "toNanos", "getDataForRange", "assertNotNull", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "CpuThreadStateDataSeries", "superclass": "", "interfaces": "implements DataSeries<CpuProfilerStage.ThreadState>", "fields": [{"original_string": "@NotNull private final TransportServiceGrpc.TransportServiceBlockingStub myClient;", "modifier": "@NotNull private final", "type": "TransportServiceGrpc.TransportServiceBlockingStub", "declarator": "myClient", "var_name": "myClient"}, {"original_string": "private final long myStreamId;", "modifier": "private final", "type": "long", "declarator": "myStreamId", "var_name": "myStreamId"}, {"original_string": "private final int myPid;", "modifier": "private final", "type": "int", "declarator": "myPid", "var_name": "myPid"}, {"original_string": "private final int myThreadId;", "modifier": "private final", "type": "int", "declarator": "myThreadId", "var_name": "myThreadId"}, {"original_string": "@Nullable private final CpuCapture mySelectedCapture;", "modifier": "@Nullable private final", "type": "CpuCapture", "declarator": "mySelectedCapture", "var_name": "mySelectedCapture"}], "methods": [{"identifier": "CpuThreadStateDataSeries", "parameters": "(@NotNull TransportServiceGrpc.TransportServiceBlockingStub client,\n                                  long streamId,\n                                  int pid,\n                                  int threadId,\n                                  @Nullable CpuCapture selectedCapture)", "modifiers": "public", "return": "", "signature": " CpuThreadStateDataSeries(@NotNull TransportServiceGrpc.TransportServiceBlockingStub client,\n                                  long streamId,\n                                  int pid,\n                                  int threadId,\n                                  @Nullable CpuCapture selectedCapture)", "full_signature": "public  CpuThreadStateDataSeries(@NotNull TransportServiceGrpc.TransportServiceBlockingStub client,\n                                  long streamId,\n                                  int pid,\n                                  int threadId,\n                                  @Nullable CpuCapture selectedCapture)", "class_method_signature": "CpuThreadStateDataSeries.CpuThreadStateDataSeries(@NotNull TransportServiceGrpc.TransportServiceBlockingStub client,\n                                  long streamId,\n                                  int pid,\n                                  int threadId,\n                                  @Nullable CpuCapture selectedCapture)", "testcase": false, "constructor": true}, {"identifier": "getDataForRange", "parameters": "(Range rangeUs)", "modifiers": "@Override public", "return": "List<SeriesData<CpuProfilerStage.ThreadState>>", "signature": "List<SeriesData<CpuProfilerStage.ThreadState>> getDataForRange(Range rangeUs)", "full_signature": "@Override public List<SeriesData<CpuProfilerStage.ThreadState>> getDataForRange(Range rangeUs)", "class_method_signature": "CpuThreadStateDataSeries.getDataForRange(Range rangeUs)", "testcase": false, "constructor": false}], "file": "profilers/src/com/android/tools/profilers/cpu/CpuThreadStateDataSeries.java"}, "focal_method": {"identifier": "getDataForRange", "parameters": "(Range rangeUs)", "modifiers": "@Override public", "return": "List<SeriesData<CpuProfilerStage.ThreadState>>", "body": "@Override\n  public List<SeriesData<CpuProfilerStage.ThreadState>> getDataForRange(Range rangeUs) {\n    List<SeriesData<CpuProfilerStage.ThreadState>> series = new ArrayList<>();\n    long minNs = TimeUnit.MICROSECONDS.toNanos((long)rangeUs.getMin());\n    long maxNs = TimeUnit.MICROSECONDS.toNanos((long)rangeUs.getMax());\n    GetEventGroupsResponse response = myClient.getEventGroups(\n      GetEventGroupsRequest.newBuilder()\n        .setStreamId(myStreamId)\n        .setPid(myPid)\n        .setKind(Common.Event.Kind.CPU_THREAD)\n        .setGroupId(myThreadId)\n        .setFromTimestamp(minNs)\n        .setToTimestamp(maxNs)\n        .build());\n    // We don't expect more than one data group for the given group ID.\n    assert response.getGroupsCount() <= 1;\n    if (response.getGroupsCount() == 1) {\n      // Merges information from traces and samples:\n      ArrayList<Double> captureTimes = new ArrayList<>(2);\n      if (mySelectedCapture != null && mySelectedCapture.getThreads().stream().anyMatch(t -> t.getId() == myThreadId)) {\n        captureTimes.add(mySelectedCapture.getRange().getMin());\n        captureTimes.add(mySelectedCapture.getRange().getMax());\n      }\n\n      int i = 0;\n      int j = 0;\n      boolean inCapture = false;\n      Cpu.CpuThreadData.State state = Cpu.CpuThreadData.State.UNSPECIFIED;\n      List<Common.Event> events = response.getGroups(0).getEventsList();\n      while (i < events.size()) {\n        Common.Event event = events.get(i);\n        long timestamp = TimeUnit.NANOSECONDS.toMicros(event.getTimestamp());\n        long captureTime = j < captureTimes.size() ? captureTimes.get(j).longValue() : Long.MAX_VALUE;\n\n        long time;\n        if (captureTime < timestamp) {\n          inCapture = !inCapture;\n          time = captureTime;\n          j++;\n        }\n        else {\n          state = event.getCpuThread().getState();\n          time = timestamp;\n          i++;\n        }\n        // We shouldn't add an activity if capture has started before the first activity for the current thread.\n        if (state != Cpu.CpuThreadData.State.UNSPECIFIED) {\n          series.add(new SeriesData<>(time, CpuThreadsModel.getState(state, inCapture)));\n        }\n      }\n      while (j < captureTimes.size()) {\n        inCapture = !inCapture;\n        series.add(new SeriesData<>(captureTimes.get(j).longValue(), CpuThreadsModel.getState(state, inCapture)));\n        j++;\n      }\n    }\n\n    return series;\n  }", "signature": "List<SeriesData<CpuProfilerStage.ThreadState>> getDataForRange(Range rangeUs)", "full_signature": "@Override public List<SeriesData<CpuProfilerStage.ThreadState>> getDataForRange(Range rangeUs)", "class_method_signature": "CpuThreadStateDataSeries.getDataForRange(Range rangeUs)", "testcase": false, "constructor": false, "invocations": ["toNanos", "getMin", "toNanos", "getMax", "getEventGroups", "build", "setToTimestamp", "setFromTimestamp", "setGroupId", "setKind", "setPid", "setStreamId", "newBuilder", "getGroupsCount", "getGroupsCount", "anyMatch", "stream", "getThreads", "getId", "add", "getMin", "getRange", "add", "getMax", "getRange", "getEventsList", "getGroups", "size", "get", "toMicros", "getTimestamp", "size", "longValue", "get", "getState", "getCpuThread", "add", "getState", "size", "add", "longValue", "get", "getState"]}, "repository": {"repo_id": 60701247, "url": "https://github.com/JetBrains/android", "stars": 486, "created": "6/8/2016 1:46:48 PM +00:00", "updates": "2020-01-27T16:45:40+00:00", "fork": "False", "license": "licensed"}}