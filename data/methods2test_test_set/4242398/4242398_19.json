{"test_class": {"identifier": "SpaceReceiveAdapterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "SpaceConfiguration configuration;", "modifier": "", "type": "SpaceConfiguration", "declarator": "configuration", "var_name": "configuration"}, {"original_string": "OffHeapJSpace heapJSpace;", "modifier": "", "type": "OffHeapJSpace", "declarator": "heapJSpace", "var_name": "heapJSpace"}, {"original_string": "SpaceReceiveAdapter receiveAdapter;", "modifier": "", "type": "SpaceReceiveAdapter", "declarator": "receiveAdapter", "var_name": "receiveAdapter"}, {"original_string": "Address address;", "modifier": "", "type": "Address", "declarator": "address", "var_name": "address"}, {"original_string": "ObjectBuffer objectBuffer;", "modifier": "", "type": "ObjectBuffer", "declarator": "objectBuffer", "var_name": "objectBuffer"}, {"original_string": "MethodCall response;", "modifier": "", "type": "MethodCall", "declarator": "response", "var_name": "response"}], "file": "core/src/test/java/com/turbospaces/spaces/SpaceReceiveAdapterTest.java"}, "test_case": {"identifier": "canBeginRollback", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void canBeginRollback() {\n        BeginTransactionMethodCall methodCall = new BeginTransactionMethodCall();\n        methodCall.setTransactionTimeout( TimeUnit.SECONDS.toMillis( 1 ) );\n\n        Message message = new Message();\n        message.setSrc( address );\n        message.setBuffer( objectBuffer.writeClassAndObject( methodCall ) );\n\n        receiveAdapter.receive( message );\n        Long transactionID = objectBuffer.readObjectData( response.getResponseBody(), long.class );\n\n        CommitRollbackMethodCall commitRollbackMethodCall = new CommitRollbackMethodCall( false );\n        commitRollbackMethodCall.setTransactionId( transactionID );\n        message.setBuffer( objectBuffer.writeClassAndObject( commitRollbackMethodCall ) );\n        receiveAdapter.receive( message );\n\n        String exceptionAsString = response.getExceptionAsString();\n        assertThat( exceptionAsString, is( nullValue() ) );\n    }", "signature": "void canBeginRollback()", "full_signature": "@Test public void canBeginRollback()", "class_method_signature": "SpaceReceiveAdapterTest.canBeginRollback()", "testcase": true, "constructor": false, "invocations": ["setTransactionTimeout", "toMillis", "setSrc", "setBuffer", "writeClassAndObject", "receive", "readObjectData", "getResponseBody", "setTransactionId", "setBuffer", "writeClassAndObject", "receive", "getExceptionAsString", "assertThat", "is", "nullValue"]}, "focal_class": {"identifier": "SpaceReceiveAdapter", "superclass": "extends ReceiverAdapter", "interfaces": "implements InitializingBean, DisposableBean", "fields": [{"original_string": "private final Logger logger = LoggerFactory.getLogger( getClass() );", "modifier": "private final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger( getClass() )", "var_name": "logger"}, {"original_string": "private final ConcurrentHashMap<Address, Cache<Long, SpaceTransactionHolder>> durableTransactions;", "modifier": "private final", "type": "ConcurrentHashMap<Address, Cache<Long, SpaceTransactionHolder>>", "declarator": "durableTransactions", "var_name": "durableTransactions"}, {"original_string": "private final AbstractJSpace jSpace;", "modifier": "private final", "type": "AbstractJSpace", "declarator": "jSpace", "var_name": "jSpace"}, {"original_string": "private ScheduledFuture<?> cleaupFuture;", "modifier": "private", "type": "ScheduledFuture<?>", "declarator": "cleaupFuture", "var_name": "cleaupFuture"}, {"original_string": "private volatile Address[] clientConnectors;", "modifier": "private volatile", "type": "Address[]", "declarator": "clientConnectors", "var_name": "clientConnectors"}], "methods": [{"identifier": "SpaceReceiveAdapter", "parameters": "(final AbstractJSpace jSpace)", "modifiers": "", "return": "", "signature": " SpaceReceiveAdapter(final AbstractJSpace jSpace)", "full_signature": "  SpaceReceiveAdapter(final AbstractJSpace jSpace)", "class_method_signature": "SpaceReceiveAdapter.SpaceReceiveAdapter(final AbstractJSpace jSpace)", "testcase": false, "constructor": true}, {"identifier": "afterPropertiesSet", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void afterPropertiesSet()", "full_signature": "@Override public void afterPropertiesSet()", "class_method_signature": "SpaceReceiveAdapter.afterPropertiesSet()", "testcase": false, "constructor": false}, {"identifier": "destroy", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void destroy()", "full_signature": "@Override public void destroy()", "class_method_signature": "SpaceReceiveAdapter.destroy()", "testcase": false, "constructor": false}, {"identifier": "receive", "parameters": "(final Message msg)", "modifiers": "@Override public", "return": "void", "signature": "void receive(final Message msg)", "full_signature": "@Override public void receive(final Message msg)", "class_method_signature": "SpaceReceiveAdapter.receive(final Message msg)", "testcase": false, "constructor": false}, {"identifier": "sendResponseBackAfterExecution", "parameters": "(final MethodCall methodCall,\n                                                final Runnable task,\n                                                final Address address,\n                                                final ObjectBuffer objectBuffer)", "modifiers": "private", "return": "void", "signature": "void sendResponseBackAfterExecution(final MethodCall methodCall,\n                                                final Runnable task,\n                                                final Address address,\n                                                final ObjectBuffer objectBuffer)", "full_signature": "private void sendResponseBackAfterExecution(final MethodCall methodCall,\n                                                final Runnable task,\n                                                final Address address,\n                                                final ObjectBuffer objectBuffer)", "class_method_signature": "SpaceReceiveAdapter.sendResponseBackAfterExecution(final MethodCall methodCall,\n                                                final Runnable task,\n                                                final Address address,\n                                                final ObjectBuffer objectBuffer)", "testcase": false, "constructor": false}, {"identifier": "suspect", "parameters": "(final Address mbr)", "modifiers": "@Override public", "return": "void", "signature": "void suspect(final Address mbr)", "full_signature": "@Override public void suspect(final Address mbr)", "class_method_signature": "SpaceReceiveAdapter.suspect(final Address mbr)", "testcase": false, "constructor": false}, {"identifier": "viewAccepted", "parameters": "(final View view)", "modifiers": "@Override public", "return": "void", "signature": "void viewAccepted(final View view)", "full_signature": "@Override public void viewAccepted(final View view)", "class_method_signature": "SpaceReceiveAdapter.viewAccepted(final View view)", "testcase": false, "constructor": false}, {"identifier": "modificationContextFor", "parameters": "(final Address address)", "modifiers": "@VisibleForTesting", "return": "Cache<Long, SpaceTransactionHolder>", "signature": "Cache<Long, SpaceTransactionHolder> modificationContextFor(final Address address)", "full_signature": "@VisibleForTesting Cache<Long, SpaceTransactionHolder> modificationContextFor(final Address address)", "class_method_signature": "SpaceReceiveAdapter.modificationContextFor(final Address address)", "testcase": false, "constructor": false}, {"identifier": "applyExpireAfterWriteSettings", "parameters": "(final CacheBuilder<Object, Object> builder)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void applyExpireAfterWriteSettings(final CacheBuilder<Object, Object> builder)", "full_signature": "@VisibleForTesting void applyExpireAfterWriteSettings(final CacheBuilder<Object, Object> builder)", "class_method_signature": "SpaceReceiveAdapter.applyExpireAfterWriteSettings(final CacheBuilder<Object, Object> builder)", "testcase": false, "constructor": false}, {"identifier": "getClientConnections", "parameters": "(@SuppressWarnings(\"unused\") final View view)", "modifiers": "@VisibleForTesting", "return": "Address[]", "signature": "Address[] getClientConnections(@SuppressWarnings(\"unused\") final View view)", "full_signature": "@VisibleForTesting Address[] getClientConnections(@SuppressWarnings(\"unused\") final View view)", "class_method_signature": "SpaceReceiveAdapter.getClientConnections(@SuppressWarnings(\"unused\") final View view)", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/turbospaces/spaces/SpaceReceiveAdapter.java"}, "focal_method": {"identifier": "receive", "parameters": "(final Message msg)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void receive(final Message msg) {\n        final byte[] data = msg.getBuffer();\n        final ObjectBuffer objectBuffer = new ObjectBuffer( jSpace.getSpaceConfiguration().getKryo() );\n        final Address nodeRaised = msg.getSrc();\n\n        final MethodCall methodCall = (MethodCall) objectBuffer.readClassAndObject( data );\n        final short id = methodCall.getMethodId();\n\n        logger.debug( \"received {} from {}\", methodCall, nodeRaised );\n\n        if ( id == SpaceMethodsMapping.BEGIN_TRANSACTION.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    /**\n                     * 1. read transaction timeout\n                     * 2. create local durable transaction for remote client and assign id\n                     * 3. propagate remote transaction timeout and apply to local transaction\n                     * 4. send transaction id back to client\n                     */\n                    BeginTransactionMethodCall beginTransactionMethodCall = (BeginTransactionMethodCall) methodCall;\n                    long transactionTimeout = beginTransactionMethodCall.getTransactionTimeout();\n                    SpaceTransactionHolder spaceTransactionHolder = new SpaceTransactionHolder();\n                    spaceTransactionHolder.setSynchronizedWithTransaction( true );\n                    spaceTransactionHolder.setTimeoutInMillis( transactionTimeout );\n                    TransactionModificationContext mc = new TransactionModificationContext();\n                    mc.setProxyMode( true );\n                    spaceTransactionHolder.setModificationContext( mc );\n                    modificationContextFor( nodeRaised ).put( mc.getTransactionId(), spaceTransactionHolder );\n                    methodCall.setResponseBody( objectBuffer.writeObjectData( mc.getTransactionId() ) );\n                }\n            }, nodeRaised, objectBuffer );\n        else if ( id == SpaceMethodsMapping.COMMIT_TRANSACTION.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    CommitRollbackMethodCall commitMethodCall = (CommitRollbackMethodCall) methodCall;\n                    try {\n                        SpaceTransactionHolder th = modificationContextFor( nodeRaised ).getIfPresent( commitMethodCall.getTransactionId() );\n                        Preconditions.checkState(\n                                th != null,\n                                \"unable to find transaction with id = %s for commit\",\n                                commitMethodCall.getTransactionId() );\n                        jSpace.syncTx( th.getModificationContext(), true );\n                    }\n                    finally {\n                        durableTransactions.remove( commitMethodCall.getTransactionId() );\n                    }\n                }\n            },\n                    nodeRaised,\n                    objectBuffer );\n        else if ( id == SpaceMethodsMapping.ROLLBACK_TRANSACTION.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    CommitRollbackMethodCall commitMethodCall = (CommitRollbackMethodCall) methodCall;\n                    try {\n                        SpaceTransactionHolder th = modificationContextFor( nodeRaised ).getIfPresent( commitMethodCall.getTransactionId() );\n                        Preconditions.checkState(\n                                th != null,\n                                \"unable to find transaction with id = %s for rollback\",\n                                commitMethodCall.getTransactionId() );\n                        jSpace.syncTx( th.getModificationContext(), false );\n                    }\n                    finally {\n                        durableTransactions.remove( commitMethodCall.getTransactionId() );\n                    }\n                }\n            },\n                    nodeRaised,\n                    objectBuffer );\n        else if ( id == SpaceMethodsMapping.WRITE.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    WriteMethodCall writeMethodCall = (WriteMethodCall) methodCall;\n                    byte[] entityAndClassData = writeMethodCall.getEntity();\n                    ByteBuffer byteBuffer = ByteBuffer.wrap( entityAndClassData );\n\n                    int modifiers = writeMethodCall.getModifiers();\n                    int timeout = writeMethodCall.getTimeout();\n                    int timeToLive = writeMethodCall.getTimeToLive();\n\n                    /**\n                     * 1. read registered class (without actual data)\n                     * 2. get the actual type of the remote entry\n                     * 3. copy serialized entry state from the byte buffer, omit redundant serialization later\n                     * 4. find appropriate transaction modification context if any\n                     * 5. call write method itself\n                     */\n                    RegisteredClass entryClass = jSpace.getSpaceConfiguration().getKryo().readClass( byteBuffer );\n                    Class<?> entryType = entryClass.getType();\n                    byte[] entityData = Arrays.copyOfRange( byteBuffer.array(), byteBuffer.position(), byteBuffer.capacity() );\n                    Object entry = jSpace.getSpaceConfiguration().getKryo().readObjectData( byteBuffer, entryType );\n\n                    SpaceTransactionHolder holder = null;\n                    if ( writeMethodCall.getTransactionId() != 0 )\n                        holder = modificationContextFor( nodeRaised ).getIfPresent( writeMethodCall.getTransactionId() );\n\n                    jSpace.write( holder, entry, entityData, timeToLive, timeout, modifiers );\n                    writeMethodCall.reset();\n                }\n            }, nodeRaised, objectBuffer );\n        else if ( id == SpaceMethodsMapping.FETCH.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    FetchMethodCall fetchMethodCall = (FetchMethodCall) methodCall;\n                    byte[] entityData = fetchMethodCall.getEntity();\n\n                    int originalModifiers = fetchMethodCall.getModifiers();\n                    int timeout = fetchMethodCall.getTimeout();\n                    int maxResults = fetchMethodCall.getMaxResults();\n                    Object template = objectBuffer.readClassAndObject( entityData );\n                    int modifiers = originalModifiers | JSpace.RETURN_AS_BYTES;\n\n                    SpaceTransactionHolder holder = null;\n                    if ( fetchMethodCall.getTransactionId() != 0 )\n                        holder = modificationContextFor( nodeRaised ).getIfPresent( fetchMethodCall.getTransactionId() );\n\n                    ByteBuffer[] buffers = (ByteBuffer[]) jSpace.fetch( holder, template, timeout, maxResults, modifiers );\n                    if ( buffers != null ) {\n                        byte[][] response = new byte[buffers.length][];\n                        for ( int i = 0; i < buffers.length; i++ ) {\n                            ByteBuffer buffer = buffers[i];\n                            response[i] = buffer.array();\n                        }\n                        fetchMethodCall.setResponseBody( objectBuffer.writeObjectData( response ) );\n                    }\n                    fetchMethodCall.reset();\n                }\n            }, nodeRaised, objectBuffer );\n        else if ( id == SpaceMethodsMapping.NOTIFY.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    NotifyListenerMethodCall registerMethodCall = (NotifyListenerMethodCall) methodCall;\n                    byte[] entityData = registerMethodCall.getEntity();\n\n                    int originalModifiers = registerMethodCall.getModifiers();\n                    Object template = objectBuffer.readClassAndObject( entityData );\n                    int modifiers = originalModifiers | JSpace.RETURN_AS_BYTES;\n                    jSpace.notify( template, new SpaceNotificationListener() {\n\n                        @Override\n                        public void handleNotification(final Object entity,\n                                                       final SpaceOperation operation) {\n                            ObjectBuffer innerObjectBuffer = new ObjectBuffer( jSpace.getSpaceConfiguration().getKryo() );\n                            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                                @Override\n                                public void run() {\n                                    NotifyListenerMethodCall methodCall = new NotifyListenerMethodCall();\n                                    methodCall.setEntity( ( (ByteBuffer) entity ).array() );\n                                    methodCall.setOperation( operation );\n                                }\n                            }, nodeRaised, innerObjectBuffer );\n                        }\n                    }, modifiers );\n                }\n            }, nodeRaised, objectBuffer );\n        else if ( id == SpaceMethodsMapping.SIZE.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    methodCall.setResponseBody( objectBuffer.writeObjectData( jSpace.size() ) );\n                }\n            }, nodeRaised, objectBuffer );\n        else if ( id == SpaceMethodsMapping.MB_USED.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    methodCall.setResponseBody( objectBuffer.writeObjectData( jSpace.mbUsed() ) );\n                }\n            }, nodeRaised, objectBuffer );\n        else if ( id == SpaceMethodsMapping.EVICT_ELEMENTS.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    EvictElementsMethodCall evictElementsMethodCall = (EvictElementsMethodCall) methodCall;\n                    methodCall.setResponseBody( objectBuffer.writeObjectData( jSpace.evictElements( evictElementsMethodCall.getElements() ) ) );\n                }\n            }, nodeRaised, objectBuffer );\n        else if ( id == SpaceMethodsMapping.EVICT_PERCENTAGE.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    EvictPercentageMethodCall evictPercentageMethodCall = (EvictPercentageMethodCall) methodCall;\n                    methodCall.setResponseBody( objectBuffer.writeObjectData( jSpace.evictPercentage( evictPercentageMethodCall.getPercentage() ) ) );\n                }\n            },\n                    nodeRaised,\n                    objectBuffer );\n        else if ( id == SpaceMethodsMapping.EVICT_ALL.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    methodCall.setResponseBody( objectBuffer.writeObjectData( jSpace.evictAll() ) );\n                }\n            }, nodeRaised, objectBuffer );\n        else if ( id == SpaceMethodsMapping.SPACE_TOPOLOGY.ordinal() )\n            sendResponseBackAfterExecution( methodCall, new Runnable() {\n                @Override\n                public void run() {\n                    methodCall.setResponseBody( objectBuffer.writeObjectData( jSpace.getSpaceConfiguration().getTopology() ) );\n                }\n            }, nodeRaised, objectBuffer );\n    }", "signature": "void receive(final Message msg)", "full_signature": "@Override public void receive(final Message msg)", "class_method_signature": "SpaceReceiveAdapter.receive(final Message msg)", "testcase": false, "constructor": false, "invocations": ["getBuffer", "getKryo", "getSpaceConfiguration", "getSrc", "readClassAndObject", "getMethodId", "debug", "ordinal", "sendResponseBackAfterExecution", "getTransactionTimeout", "setSynchronizedWithTransaction", "setTimeoutInMillis", "setProxyMode", "setModificationContext", "put", "modificationContextFor", "getTransactionId", "setResponseBody", "writeObjectData", "getTransactionId", "ordinal", "sendResponseBackAfterExecution", "getIfPresent", "modificationContextFor", "getTransactionId", "checkState", "getTransactionId", "syncTx", "getModificationContext", "remove", "getTransactionId", "ordinal", "sendResponseBackAfterExecution", "getIfPresent", "modificationContextFor", "getTransactionId", "checkState", "getTransactionId", "syncTx", "getModificationContext", "remove", "getTransactionId", "ordinal", "sendResponseBackAfterExecution", "getEntity", "wrap", "getModifiers", "getTimeout", "getTimeToLive", "readClass", "getKryo", "getSpaceConfiguration", "getType", "copyOfRange", "array", "position", "capacity", "readObjectData", "getKryo", "getSpaceConfiguration", "getTransactionId", "getIfPresent", "modificationContextFor", "getTransactionId", "write", "reset", "ordinal", "sendResponseBackAfterExecution", "getEntity", "getModifiers", "getTimeout", "getMaxResults", "readClassAndObject", "getTransactionId", "getIfPresent", "modificationContextFor", "getTransactionId", "fetch", "array", "setResponseBody", "writeObjectData", "reset", "ordinal", "sendResponseBackAfterExecution", "getEntity", "getModifiers", "readClassAndObject", "notify", "getKryo", "getSpaceConfiguration", "sendResponseBackAfterExecution", "setEntity", "array", "setOperation", "ordinal", "sendResponseBackAfterExecution", "setResponseBody", "writeObjectData", "size", "ordinal", "sendResponseBackAfterExecution", "setResponseBody", "writeObjectData", "mbUsed", "ordinal", "sendResponseBackAfterExecution", "setResponseBody", "writeObjectData", "evictElements", "getElements", "ordinal", "sendResponseBackAfterExecution", "setResponseBody", "writeObjectData", "evictPercentage", "getPercentage", "ordinal", "sendResponseBackAfterExecution", "setResponseBody", "writeObjectData", "evictAll", "ordinal", "sendResponseBackAfterExecution", "setResponseBody", "writeObjectData", "getTopology", "getSpaceConfiguration"]}, "repository": {"repo_id": 4242398, "url": "https://github.com/turbospaces/turbospaces", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 10, "size": 915, "license": "licensed"}}