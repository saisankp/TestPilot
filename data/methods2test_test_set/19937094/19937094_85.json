{"test_class": {"identifier": "AcceptorIoHandlerTest", "superclass": "", "interfaces": "", "fields": [], "file": "quickfixj-core/src/test/java/quickfix/mina/acceptor/AcceptorIoHandlerTest.java"}, "test_case": {"identifier": "testMessageBeforeLogon", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMessageBeforeLogon() throws Exception {\n        IoSession mockIoSession = mock(IoSession.class);\n        stub(mockIoSession.getAttribute(\"QF_SESSION\")).toReturn(null);\n\n        EventHandlingStrategy mockEventHandlingStrategy = mock(EventHandlingStrategy.class);\n\n        HashMap<SessionID, Session> acceptorSessions = new HashMap<>();\n\n        AcceptorIoHandler handler = new AcceptorIoHandler(createSessionProvider(acceptorSessions),\n                new NetworkingOptions(new Properties()), mockEventHandlingStrategy);\n\n        handler.processMessage(mockIoSession, new Logout());\n\n        verify(mockIoSession).getAttribute(\"QF_SESSION\");\n        verifyNoMoreInteractions(mockEventHandlingStrategy);\n    }", "signature": "void testMessageBeforeLogon()", "full_signature": "@Test public void testMessageBeforeLogon()", "class_method_signature": "AcceptorIoHandlerTest.testMessageBeforeLogon()", "testcase": true, "constructor": false, "invocations": ["mock", "toReturn", "stub", "getAttribute", "mock", "createSessionProvider", "processMessage", "getAttribute", "verify", "verifyNoMoreInteractions"]}, "focal_class": {"identifier": "AcceptorIoHandler", "superclass": "extends AbstractIoHandler", "interfaces": "", "fields": [{"original_string": "private final EventHandlingStrategy eventHandlingStrategy;", "modifier": "private final", "type": "EventHandlingStrategy", "declarator": "eventHandlingStrategy", "var_name": "eventHandlingStrategy"}, {"original_string": "private final AcceptorSessionProvider sessionProvider;", "modifier": "private final", "type": "AcceptorSessionProvider", "declarator": "sessionProvider", "var_name": "sessionProvider"}], "methods": [{"identifier": "AcceptorIoHandler", "parameters": "(AcceptorSessionProvider sessionProvider,\n            NetworkingOptions networkingOptions, EventHandlingStrategy eventHandlingStrategy)", "modifiers": "public", "return": "", "signature": " AcceptorIoHandler(AcceptorSessionProvider sessionProvider,\n            NetworkingOptions networkingOptions, EventHandlingStrategy eventHandlingStrategy)", "full_signature": "public  AcceptorIoHandler(AcceptorSessionProvider sessionProvider,\n            NetworkingOptions networkingOptions, EventHandlingStrategy eventHandlingStrategy)", "class_method_signature": "AcceptorIoHandler.AcceptorIoHandler(AcceptorSessionProvider sessionProvider,\n            NetworkingOptions networkingOptions, EventHandlingStrategy eventHandlingStrategy)", "testcase": false, "constructor": true}, {"identifier": "sessionCreated", "parameters": "(IoSession session)", "modifiers": "@Override public", "return": "void", "signature": "void sessionCreated(IoSession session)", "full_signature": "@Override public void sessionCreated(IoSession session)", "class_method_signature": "AcceptorIoHandler.sessionCreated(IoSession session)", "testcase": false, "constructor": false}, {"identifier": "processMessage", "parameters": "(IoSession protocolSession, Message message)", "modifiers": "@Override protected", "return": "void", "signature": "void processMessage(IoSession protocolSession, Message message)", "full_signature": "@Override protected void processMessage(IoSession protocolSession, Message message)", "class_method_signature": "AcceptorIoHandler.processMessage(IoSession protocolSession, Message message)", "testcase": false, "constructor": false}, {"identifier": "findQFSession", "parameters": "(IoSession protocolSession, SessionID sessionID)", "modifiers": "@Override protected", "return": "Session", "signature": "Session findQFSession(IoSession protocolSession, SessionID sessionID)", "full_signature": "@Override protected Session findQFSession(IoSession protocolSession, SessionID sessionID)", "class_method_signature": "AcceptorIoHandler.findQFSession(IoSession protocolSession, SessionID sessionID)", "testcase": false, "constructor": false}], "file": "quickfixj-core/src/main/java/quickfix/mina/acceptor/AcceptorIoHandler.java"}, "focal_method": {"identifier": "processMessage", "parameters": "(IoSession protocolSession, Message message)", "modifiers": "@Override protected", "return": "void", "body": "@Override\n    protected void processMessage(IoSession protocolSession, Message message) throws Exception {\n        Session qfSession = (Session) protocolSession.getAttribute(SessionConnector.QF_SESSION);\n        if (qfSession == null) {\n            final Optional<String> msgTypeField = message.getHeader().getOptionalString(MsgType.FIELD);\n            if (msgTypeField.isPresent() && msgTypeField.get().equals(MsgType.LOGON)) {\n                final SessionID sessionID = MessageUtils.getReverseSessionID(message);\n                qfSession = sessionProvider.getSession(sessionID, eventHandlingStrategy.getSessionConnector());\n                if (qfSession != null) {\n                    final Log sessionLog = qfSession.getLog();\n                    Responder responder = qfSession.getResponder();\n                    if (responder != null) {\n                        // Session is already bound to another connection\n                        sessionLog.onErrorEvent(\"Multiple logons/connections for this session are not allowed.\"\n                                + \" Closing connection from \" + protocolSession.getRemoteAddress()\n                                + \" since session is already established from \" + responder.getRemoteAddress());\n                        protocolSession.closeNow();\n                        return;\n                    }\n                    sessionLog.onEvent(\"Accepting session \" + qfSession.getSessionID() + \" from \"\n                            + protocolSession.getRemoteAddress());\n                    final int heartbeatInterval = message.isSetField(HeartBtInt.FIELD) ? message.getInt(HeartBtInt.FIELD) : 0;\n                    qfSession.setHeartBeatInterval(heartbeatInterval);\n                    sessionLog.onEvent(\"Acceptor heartbeat set to \" + heartbeatInterval\n                            + \" seconds\");\n                    protocolSession.setAttribute(SessionConnector.QF_SESSION, qfSession);\n                    final NetworkingOptions networkingOptions = getNetworkingOptions();\n                    qfSession.setResponder(new IoSessionResponder(protocolSession,\n                            networkingOptions.getSynchronousWrites(), networkingOptions\n                                    .getSynchronousWriteTimeout(), qfSession.getMaxScheduledWriteRequests()));\n                    if (sessionID.isFIXT()) { // QFJ-592\n                        if (message.isSetField(DefaultApplVerID.FIELD)) {\n                            final ApplVerID applVerID = new ApplVerID(\n                                    message.getString(DefaultApplVerID.FIELD));\n                            qfSession.setTargetDefaultApplicationVersionID(applVerID);\n                            sessionLog.onEvent(\"Setting DefaultApplVerID (\" + DefaultApplVerID.FIELD + \"=\"\n                                    + applVerID.getValue() + \") from Logon\");\n                        }\n                    }\n                } else {\n                    log.error(\"Unknown session ID during logon: {} cannot be found in session list {} (connecting from {} to {})\",\n                            sessionID,\n                            eventHandlingStrategy.getSessionConnector().getSessions(),\n                            protocolSession.getRemoteAddress(),\n                            protocolSession.getLocalAddress());\n                    return;\n                }\n            } else {\n                log.warn(\"Ignoring non-logon message before session establishment: {}\", message);\n                protocolSession.closeNow();\n                return;\n            }\n        }\n\n        eventHandlingStrategy.onMessage(qfSession, message);\n    }", "signature": "void processMessage(IoSession protocolSession, Message message)", "full_signature": "@Override protected void processMessage(IoSession protocolSession, Message message)", "class_method_signature": "AcceptorIoHandler.processMessage(IoSession protocolSession, Message message)", "testcase": false, "constructor": false, "invocations": ["getAttribute", "getOptionalString", "getHeader", "isPresent", "equals", "get", "getReverseSessionID", "getSession", "getSessionConnector", "getLog", "getResponder", "onErrorEvent", "getRemoteAddress", "getRemoteAddress", "closeNow", "onEvent", "getSessionID", "getRemoteAddress", "isSetField", "getInt", "setHeartBeatInterval", "onEvent", "setAttribute", "getNetworkingOptions", "setResponder", "getSynchronousWrites", "getSynchronousWriteTimeout", "getMaxScheduledWriteRequests", "isFIXT", "isSetField", "getString", "setTargetDefaultApplicationVersionID", "onEvent", "getValue", "error", "getSessions", "getSessionConnector", "getRemoteAddress", "getLocalAddress", "warn", "closeNow", "onMessage"]}, "repository": {"repo_id": 19937094, "url": "https://github.com/quickfix-j/quickfixj", "stars": 538, "created": "5/19/2014 10:04:08 AM +00:00", "updates": "2020-01-26T01:21:15+00:00", "fork": "False", "license": "licensed"}}