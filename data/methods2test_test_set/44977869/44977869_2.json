{"test_class": {"identifier": "ImageGraphBuilderTest", "superclass": "", "interfaces": "", "fields": [], "file": "foglight/src/test/java/com/ociweb/pronghorn/image/ImageGraphBuilderTest.java"}, "test_case": {"identifier": "buildGraphTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void buildGraphTest() {\n\t\t\n\t\t\n\t\t//ScriptedNonThreadScheduler.debugStageOrder = System.out;\n\t\t//ScriptedNonThreadScheduler.globalStartupLockCheck = true;\n\t\t\n\t\tGraphManager gm = new GraphManager();\n\t\t\n\t\tString loadFilePath = null;\n\t\tString saveFilePath = HardwareImpl.generateFilePath(\"savedLocation\",\".dat\");\n\t\t\n\t\tPipe<ImageSchema>             imagePipe = ImageSchema.instance.newPipe(2000, 4000);\n\t\timagePipe.initBuffers();\n\t\t\n\t\tPipe<LocationModeSchema>      modeSelectionPipe = LocationModeSchema.instance.newPipe(10, 0) ;\n\t\tmodeSelectionPipe.initBuffers();\n\t\t\n\t\tLocationModeSchema.publishCycleLearningStart(modeSelectionPipe, 10000, 1000);\n\t\t\n\t\t\n\t\t\n\t\tfinal int fieldWidth = 6400;\n\t\tfinal int fieldHeight = 3600;\n\t\tlong fieldTimestamp = System.currentTimeMillis();\n\t\tint fieldFrameBytes =  30000;\n\t\tint fieldBitsPerPixel = 24;\n\t\tbyte[] fieldEncodingBacking = \"RGB24\".getBytes();\n\t\tint fieldEncodingPosition = 0;\n\t\tint fieldEncodingLength = fieldEncodingBacking.length;\n\t\t\n\t\tImageSchema.publishFrameStart(imagePipe, fieldWidth, fieldHeight, fieldTimestamp, \n\t\t\t\t                      fieldFrameBytes, fieldBitsPerPixel, fieldEncodingBacking, fieldEncodingPosition, fieldEncodingLength);\n\t\t\n\t\tPipeNoOp.newInstance(gm, imagePipe);\n\t\tPipeNoOp.newInstance(gm, modeSelectionPipe);\n\t\t\n\t\tint i = 1000;\n\t\twhile (--i>=0) {\n\t\t\t\n\t\t\tbyte[] fieldRowBytesBacking= new byte[3*fieldWidth];\n\t\t\tint fieldRowBytesPosition = 0;\n\t\t\tint fieldRowBytesLength = fieldRowBytesBacking.length;\n\t\t\t\n\t\t\tImageSchema.publishFrameChunk(imagePipe, fieldRowBytesBacking, fieldRowBytesPosition, fieldRowBytesLength);\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tPipe<ProbabilitySchema>       probLocation = ProbabilitySchema.instance.newPipe(100, 2000);\n\t\tPipe<CalibrationStatusSchema> calibrationDone = CalibrationStatusSchema.instance.newPipe(10, 0);\n\n\t\tPipeCleanerStage.newInstance(gm, probLocation);\n\t\tPipeCleanerStage.newInstance(gm, calibrationDone);\n\t\t\n\t\tImageGraphBuilder.buildLocationDetectionGraph(gm, \n\t\t\t\t\t\t\t\t\t\t\t\t\tloadFilePath, saveFilePath, imagePipe, \n\t\t\t\t\t\t\t\t\t\t\t\t\tmodeSelectionPipe, probLocation, calibrationDone);\n\t\t\n\t\tgm.enableTelemetry(8098);\n\t\tStageScheduler scheduler = StageScheduler.defaultScheduler(gm);\n\t\t\n\t\t\n\t\tscheduler.startup();\n\t\t\n\t\t\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\tThread.sleep(1_000);\t\t\t\n\t\t} catch (InterruptedException e) {\t\t\t\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\t\n\t\tscheduler.shutdown();\n\t\t\n\t\t\n\t\t\n\t}", "signature": "void buildGraphTest()", "full_signature": "@Test public void buildGraphTest()", "class_method_signature": "ImageGraphBuilderTest.buildGraphTest()", "testcase": true, "constructor": false, "invocations": ["generateFilePath", "newPipe", "initBuffers", "newPipe", "initBuffers", "publishCycleLearningStart", "currentTimeMillis", "getBytes", "publishFrameStart", "newInstance", "newInstance", "publishFrameChunk", "newPipe", "newPipe", "newInstance", "newInstance", "buildLocationDetectionGraph", "enableTelemetry", "defaultScheduler", "startup", "sleep", "printStackTrace", "shutdown"]}, "focal_class": {"identifier": "ImageGraphBuilder", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int DOWNSCALE_WIDTH = 320;", "modifier": "public static final", "type": "int", "declarator": "DOWNSCALE_WIDTH = 320", "var_name": "DOWNSCALE_WIDTH"}, {"original_string": "public static final int DOWNSCALE_HEIGHT = 240;", "modifier": "public static final", "type": "int", "declarator": "DOWNSCALE_HEIGHT = 240", "var_name": "DOWNSCALE_HEIGHT"}], "methods": [{"identifier": "buildLocationDetectionGraph", "parameters": "(GraphManager gm, \n\t\t\tString loadFilePath, String saveFilePath,\n\t\t\tPipe<ImageSchema> imagePipe, //input pipe for the raw image data\n\t\t\tPipe<LocationModeSchema> modeSelectionPipe, //input pipe to turn on learning mode or cancel learning mode.\n\t\t\tPipe<ProbabilitySchema> probLocation, //output pipe sending probable locations\n\t\t\tPipe<CalibrationStatusSchema> calibrationDone //output pipe sending training is complete\n\t\t\t)", "modifiers": "public static", "return": "void", "signature": "void buildLocationDetectionGraph(GraphManager gm, \n\t\t\tString loadFilePath, String saveFilePath,\n\t\t\tPipe<ImageSchema> imagePipe, //input pipe for the raw image data\n\t\t\tPipe<LocationModeSchema> modeSelectionPipe, //input pipe to turn on learning mode or cancel learning mode.\n\t\t\tPipe<ProbabilitySchema> probLocation, //output pipe sending probable locations\n\t\t\tPipe<CalibrationStatusSchema> calibrationDone //output pipe sending training is complete\n\t\t\t)", "full_signature": "public static void buildLocationDetectionGraph(GraphManager gm, \n\t\t\tString loadFilePath, String saveFilePath,\n\t\t\tPipe<ImageSchema> imagePipe, //input pipe for the raw image data\n\t\t\tPipe<LocationModeSchema> modeSelectionPipe, //input pipe to turn on learning mode or cancel learning mode.\n\t\t\tPipe<ProbabilitySchema> probLocation, //output pipe sending probable locations\n\t\t\tPipe<CalibrationStatusSchema> calibrationDone //output pipe sending training is complete\n\t\t\t)", "class_method_signature": "ImageGraphBuilder.buildLocationDetectionGraph(GraphManager gm, \n\t\t\tString loadFilePath, String saveFilePath,\n\t\t\tPipe<ImageSchema> imagePipe, //input pipe for the raw image data\n\t\t\tPipe<LocationModeSchema> modeSelectionPipe, //input pipe to turn on learning mode or cancel learning mode.\n\t\t\tPipe<ProbabilitySchema> probLocation, //output pipe sending probable locations\n\t\t\tPipe<CalibrationStatusSchema> calibrationDone //output pipe sending training is complete\n\t\t\t)", "testcase": false, "constructor": false}], "file": "foglight/src/main/java/com/ociweb/pronghorn/image/ImageGraphBuilder.java"}, "focal_method": {"identifier": "buildLocationDetectionGraph", "parameters": "(GraphManager gm, \n\t\t\tString loadFilePath, String saveFilePath,\n\t\t\tPipe<ImageSchema> imagePipe, //input pipe for the raw image data\n\t\t\tPipe<LocationModeSchema> modeSelectionPipe, //input pipe to turn on learning mode or cancel learning mode.\n\t\t\tPipe<ProbabilitySchema> probLocation, //output pipe sending probable locations\n\t\t\tPipe<CalibrationStatusSchema> calibrationDone //output pipe sending training is complete\n\t\t\t)", "modifiers": "public static", "return": "void", "body": "public static void buildLocationDetectionGraph(GraphManager gm, \n\t\t\tString loadFilePath, String saveFilePath,\n\t\t\tPipe<ImageSchema> imagePipe, //input pipe for the raw image data\n\t\t\tPipe<LocationModeSchema> modeSelectionPipe, //input pipe to turn on learning mode or cancel learning mode.\n\t\t\tPipe<ProbabilitySchema> probLocation, //output pipe sending probable locations\n\t\t\tPipe<CalibrationStatusSchema> calibrationDone //output pipe sending training is complete\n\t\t\t) {\n\n\t\tif (null == calibrationDone) {\n\t\t\tcalibrationDone = CalibrationStatusSchema.instance.newPipe(8, 0);\n\t\t\tPipeCleanerStage.newInstance(gm, calibrationDone);\n\t\t}\n\t\t\n\t\tif (null == probLocation) {\t\t\t\t\t\n\t\t\tprobLocation = ProbabilitySchema.instance.newPipe(8, 50);\n\t\t\tPipeCleanerStage.newInstance(gm, probLocation);\n\t\t}\n\t\t\n\t\t//////////////////////////////////\n\t\t//Pipe definitions\n\t\t/////////////////////////////////\n\t\t\n\t\tPipe<RawDataSchema> loadDataRaw   = RawDataSchema.instance.newPipe(4, 1<<10);\n\t\tPipe<RawDataSchema> loadDataRed   = RawDataSchema.instance.newPipe(4, 1<<10);\n\t\tPipe<RawDataSchema> loadDataGreen = RawDataSchema.instance.newPipe(4, 1<<10);\n\t\tPipe<RawDataSchema> loadDataBlue  = RawDataSchema.instance.newPipe(4, 1<<10);\n\t\tPipe<RawDataSchema> loadDataMono  = RawDataSchema.instance.newPipe(4, 1<<10);\n\t\t\n\t\n\t\tPipe<RawDataSchema> saveDataRaw   = RawDataSchema.instance.newPipe(4, 1<<10);\n\t\tPipe<RawDataSchema> saveDataRed   = RawDataSchema.instance.newPipe(4, 1<<10);\n\t\tPipe<RawDataSchema> saveDataGreen = RawDataSchema.instance.newPipe(4, 1<<10);\n\t\tPipe<RawDataSchema> saveDataBlue  = RawDataSchema.instance.newPipe(4, 1<<10);\n\t\tPipe<RawDataSchema> saveDataMono  = RawDataSchema.instance.newPipe(4, 1<<10);\n\n\t\t//these are longer to hold the data while the thread is away.\n\t\tPipe<ImageSchema> imageR = ImageSchema.instance.newPipe(3*(DOWNSCALE_HEIGHT+1), DOWNSCALE_WIDTH); \n\t\tPipe<ImageSchema> imageG = ImageSchema.instance.newPipe(3*(DOWNSCALE_HEIGHT+1), DOWNSCALE_WIDTH);\n\t\tPipe<ImageSchema> imageB = ImageSchema.instance.newPipe(3*(DOWNSCALE_HEIGHT+1), DOWNSCALE_WIDTH);\n\t\tPipe<ImageSchema> imageM = ImageSchema.instance.newPipe(3*(DOWNSCALE_HEIGHT+1), DOWNSCALE_WIDTH);\n\n\t\tint maxUnits = 10_000;\n\t\tint maxHistogramLen = ChannelReader.PACKED_LONG_SIZE * maxUnits;\n\t\t\n\t\tPipe<HistogramSchema> histR = HistogramSchema.instance.newPipe(4, maxHistogramLen);\n\t\tPipe<HistogramSchema> histG = HistogramSchema.instance.newPipe(4, maxHistogramLen);\n\t\tPipe<HistogramSchema> histB = HistogramSchema.instance.newPipe(4, maxHistogramLen);\n\t\tPipe<HistogramSchema> histM = HistogramSchema.instance.newPipe(4, maxHistogramLen);\n\t\t\n\t\tPipe<HistogramSchema> histSum = HistogramSchema.instance.newPipe(4, maxHistogramLen);\t\t\n\n\t\t\n\t\tPipe<CalibrationStatusSchema> calibrationDoneRoot = PipeConfig.pipe(calibrationDone.config().shrink2x());\t\t\t\n\t\t\n\t\tPipe<CalibrationStatusSchema> calibrationDoneAckR = PipeConfig.pipe(calibrationDone.config());\n\t\tPipe<CalibrationStatusSchema> calibrationDoneAckG = PipeConfig.pipe(calibrationDone.config());\n\t\tPipe<CalibrationStatusSchema> calibrationDoneAckB = PipeConfig.pipe(calibrationDone.config());\n\t\tPipe<CalibrationStatusSchema> calibrationDoneAckM = PipeConfig.pipe(calibrationDone.config());\n\t\t\n\t\t\n\t\t//build an empty selector if one is not provided\n\t\tif (null == modeSelectionPipe) {\n\t\t\tmodeSelectionPipe = LocationModeSchema.instance.newPipe(6,0);\n\t\t\tPipeNoOp.newInstance(gm, modeSelectionPipe);\n\t\t}\n\t\t\n\t\tPipeConfig<LocationModeSchema> msConfig = modeSelectionPipe.config().grow2x();\t\t\n\t\tPipe<LocationModeSchema> modeSelectionR = PipeConfig.pipe(msConfig);\n\t\tPipe<LocationModeSchema> modeSelectionG = PipeConfig.pipe(msConfig);\n\t\tPipe<LocationModeSchema> modeSelectionB = PipeConfig.pipe(msConfig);\n\t\tPipe<LocationModeSchema> modeSelectionM = PipeConfig.pipe(msConfig);\t\t\n\t    \n\t    Pipe<CalibrationStatusSchema> calibrationDoneR = CalibrationStatusSchema.instance.newPipe(6, 0);\n\t    Pipe<CalibrationStatusSchema> calibrationDoneG = CalibrationStatusSchema.instance.newPipe(6, 0); \n\t    Pipe<CalibrationStatusSchema> calibrationDoneB = CalibrationStatusSchema.instance.newPipe(6, 0);\n\t    Pipe<CalibrationStatusSchema> calibrationDoneM = CalibrationStatusSchema.instance.newPipe(6, 0); \n\t\t////////////////////////////////////////\n\t\t//Stage definitions\n\t\t////////////////////////////////////////\n\t\t\n\t\t\n\t\tImageDownscaleStage.newInstance(gm, imagePipe, new Pipe[] {imageR, imageG, imageB, imageM}, DOWNSCALE_WIDTH, DOWNSCALE_HEIGHT) ;\n\t    \n\t\t//data is only read once on startup\n\t\tFileBlobReadStage.newInstance(gm, loadDataRaw, loadFilePath, false);\t\t\n\t\t\n\t\tRawDataSplitterStage.newInstance(gm, loadDataRaw,\n\t\t\t\t                    loadDataRed, loadDataGreen, loadDataBlue, loadDataMono);\n\n\t\t\n\t\tReplicatorStage.newInstance(gm, modeSelectionPipe, modeSelectionR, modeSelectionG, modeSelectionB, modeSelectionM);\n\t\t\t\t\n\t\t\n\t\tReplicatorStage.newInstance(gm, calibrationDoneRoot, calibrationDone, calibrationDoneAckR, calibrationDoneAckG, calibrationDoneAckB, calibrationDoneAckM );\n\t\t\n\t    \n\t    CalibrationCyclicBarierStage.newInstance(gm, \n\t    \t\t\t\t\tcalibrationDoneRoot,\n\t    \t\t            calibrationDoneR, calibrationDoneG, calibrationDoneB, calibrationDoneM);\n\t    \n\t    //modeSelectionPipe\n\t\tMapImageStage.newInstance(gm, imageR, modeSelectionR, histR, calibrationDoneAckR, calibrationDoneR, loadDataRed,   saveDataRed, \"Red\");\n\t\tMapImageStage.newInstance(gm, imageG, modeSelectionG, histG, calibrationDoneAckG, calibrationDoneG, loadDataGreen, saveDataGreen, \"Green\");\n\t\tMapImageStage.newInstance(gm, imageB, modeSelectionB, histB, calibrationDoneAckB, calibrationDoneB, loadDataBlue,  saveDataBlue, \"Blue\");\n\t\tMapImageStage.newInstance(gm, imageM, modeSelectionM, histM, calibrationDoneAckM, calibrationDoneM, loadDataMono,  saveDataMono, \"Mono\");\n\t\t\n\t\t\n\t\tHistogramSumStage.newInstance(gm, histSum, histR, histG, histB, histM);\n\t\tHistogramSelectPeakStage.newInstance(gm, histSum, probLocation );\n\n\t\tRawDataJoinerStage.newInstance(gm, saveDataRaw, \n\t\t\t\t          saveDataRed, saveDataGreen, saveDataBlue, saveDataMono);\n\n\t\tFileBlobWriteStage.newInstance(gm, saveDataRaw, saveFilePath);\n\n\t}", "signature": "void buildLocationDetectionGraph(GraphManager gm, \n\t\t\tString loadFilePath, String saveFilePath,\n\t\t\tPipe<ImageSchema> imagePipe, //input pipe for the raw image data\n\t\t\tPipe<LocationModeSchema> modeSelectionPipe, //input pipe to turn on learning mode or cancel learning mode.\n\t\t\tPipe<ProbabilitySchema> probLocation, //output pipe sending probable locations\n\t\t\tPipe<CalibrationStatusSchema> calibrationDone //output pipe sending training is complete\n\t\t\t)", "full_signature": "public static void buildLocationDetectionGraph(GraphManager gm, \n\t\t\tString loadFilePath, String saveFilePath,\n\t\t\tPipe<ImageSchema> imagePipe, //input pipe for the raw image data\n\t\t\tPipe<LocationModeSchema> modeSelectionPipe, //input pipe to turn on learning mode or cancel learning mode.\n\t\t\tPipe<ProbabilitySchema> probLocation, //output pipe sending probable locations\n\t\t\tPipe<CalibrationStatusSchema> calibrationDone //output pipe sending training is complete\n\t\t\t)", "class_method_signature": "ImageGraphBuilder.buildLocationDetectionGraph(GraphManager gm, \n\t\t\tString loadFilePath, String saveFilePath,\n\t\t\tPipe<ImageSchema> imagePipe, //input pipe for the raw image data\n\t\t\tPipe<LocationModeSchema> modeSelectionPipe, //input pipe to turn on learning mode or cancel learning mode.\n\t\t\tPipe<ProbabilitySchema> probLocation, //output pipe sending probable locations\n\t\t\tPipe<CalibrationStatusSchema> calibrationDone //output pipe sending training is complete\n\t\t\t)", "testcase": false, "constructor": false, "invocations": ["newPipe", "newInstance", "newPipe", "newInstance", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "newPipe", "pipe", "shrink2x", "config", "pipe", "config", "pipe", "config", "pipe", "config", "pipe", "config", "newPipe", "newInstance", "grow2x", "config", "pipe", "pipe", "pipe", "pipe", "newPipe", "newPipe", "newPipe", "newPipe", "newInstance", "newInstance", "newInstance", "newInstance", "newInstance", "newInstance", "newInstance", "newInstance", "newInstance", "newInstance", "newInstance", "newInstance", "newInstance", "newInstance"]}, "repository": {"repo_id": 44977869, "url": "https://github.com/oci-pronghorn/FogLight", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 12, "size": 124921, "license": "licensed"}}