{"test_class": {"identifier": "InvalidationTrackerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private InvalidationTracker mTracker;", "modifier": "private", "type": "InvalidationTracker", "declarator": "mTracker", "var_name": "mTracker"}, {"original_string": "private RoomDatabase mRoomDatabase;", "modifier": "private", "type": "RoomDatabase", "declarator": "mRoomDatabase", "var_name": "mRoomDatabase"}, {"original_string": "private SupportSQLiteOpenHelper mOpenHelper;", "modifier": "private", "type": "SupportSQLiteOpenHelper", "declarator": "mOpenHelper", "var_name": "mOpenHelper"}, {"original_string": "@Rule\n    public JunitTaskExecutorRule mTaskExecutorRule = new JunitTaskExecutorRule(1, true);", "modifier": "@Rule\n    public", "type": "JunitTaskExecutorRule", "declarator": "mTaskExecutorRule = new JunitTaskExecutorRule(1, true)", "var_name": "mTaskExecutorRule"}], "file": "room/runtime/src/test/java/android/arch/persistence/room/InvalidationTrackerTest.java"}, "test_case": {"identifier": "observe2Tables", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void observe2Tables() throws Exception {\n        LatchObserver observer = new LatchObserver(1, \"A\", \"B\");\n        mTracker.addObserver(observer);\n        setVersions(1, 0, 2, 1);\n        refreshSync();\n        assertThat(observer.await(), is(true));\n        assertThat(observer.getInvalidatedTables().size(), is(2));\n        assertThat(observer.getInvalidatedTables(), hasItems(\"A\", \"B\"));\n\n        setVersions(3, 1);\n        observer.reset(1);\n        refreshSync();\n        assertThat(observer.await(), is(true));\n        assertThat(observer.getInvalidatedTables().size(), is(1));\n        assertThat(observer.getInvalidatedTables(), hasItem(\"B\"));\n\n        setVersions(4, 0);\n        observer.reset(1);\n        refreshSync();\n        assertThat(observer.await(), is(true));\n        assertThat(observer.getInvalidatedTables().size(), is(1));\n        assertThat(observer.getInvalidatedTables(), hasItem(\"A\"));\n\n        observer.reset(1);\n        refreshSync();\n        assertThat(observer.await(), is(false));\n    }", "signature": "void observe2Tables()", "full_signature": "@Test public void observe2Tables()", "class_method_signature": "InvalidationTrackerTest.observe2Tables()", "testcase": true, "constructor": false, "invocations": ["addObserver", "setVersions", "refreshSync", "assertThat", "await", "is", "assertThat", "size", "getInvalidatedTables", "is", "assertThat", "getInvalidatedTables", "hasItems", "setVersions", "reset", "refreshSync", "assertThat", "await", "is", "assertThat", "size", "getInvalidatedTables", "is", "assertThat", "getInvalidatedTables", "hasItem", "setVersions", "reset", "refreshSync", "assertThat", "await", "is", "assertThat", "size", "getInvalidatedTables", "is", "assertThat", "getInvalidatedTables", "hasItem", "reset", "refreshSync", "assertThat", "await", "is"]}, "focal_class": {"identifier": "InvalidationTracker", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String[] TRIGGERS = new String[]{\"UPDATE\", \"DELETE\", \"INSERT\"};", "modifier": "private static final", "type": "String[]", "declarator": "TRIGGERS = new String[]{\"UPDATE\", \"DELETE\", \"INSERT\"}", "var_name": "TRIGGERS"}, {"original_string": "private static final String UPDATE_TABLE_NAME = \"room_table_modification_log\";", "modifier": "private static final", "type": "String", "declarator": "UPDATE_TABLE_NAME = \"room_table_modification_log\"", "var_name": "UPDATE_TABLE_NAME"}, {"original_string": "private static final String VERSION_COLUMN_NAME = \"version\";", "modifier": "private static final", "type": "String", "declarator": "VERSION_COLUMN_NAME = \"version\"", "var_name": "VERSION_COLUMN_NAME"}, {"original_string": "private static final String TABLE_ID_COLUMN_NAME = \"table_id\";", "modifier": "private static final", "type": "String", "declarator": "TABLE_ID_COLUMN_NAME = \"table_id\"", "var_name": "TABLE_ID_COLUMN_NAME"}, {"original_string": "private static final String CREATE_VERSION_TABLE_SQL = \"CREATE TEMP TABLE \" + UPDATE_TABLE_NAME\n            + \"(\" + VERSION_COLUMN_NAME\n            + \" INTEGER PRIMARY KEY AUTOINCREMENT, \"\n            + TABLE_ID_COLUMN_NAME\n            + \" INTEGER)\";", "modifier": "private static final", "type": "String", "declarator": "CREATE_VERSION_TABLE_SQL = \"CREATE TEMP TABLE \" + UPDATE_TABLE_NAME\n            + \"(\" + VERSION_COLUMN_NAME\n            + \" INTEGER PRIMARY KEY AUTOINCREMENT, \"\n            + TABLE_ID_COLUMN_NAME\n            + \" INTEGER)\"", "var_name": "CREATE_VERSION_TABLE_SQL"}, {"original_string": "@VisibleForTesting\n    static final String CLEANUP_SQL = \"DELETE FROM \" + UPDATE_TABLE_NAME\n            + \" WHERE \" + VERSION_COLUMN_NAME + \" NOT IN( SELECT MAX(\"\n            + VERSION_COLUMN_NAME + \") FROM \" + UPDATE_TABLE_NAME\n            + \" GROUP BY \" + TABLE_ID_COLUMN_NAME + \")\";", "modifier": "@VisibleForTesting\n    static final", "type": "String", "declarator": "CLEANUP_SQL = \"DELETE FROM \" + UPDATE_TABLE_NAME\n            + \" WHERE \" + VERSION_COLUMN_NAME + \" NOT IN( SELECT MAX(\"\n            + VERSION_COLUMN_NAME + \") FROM \" + UPDATE_TABLE_NAME\n            + \" GROUP BY \" + TABLE_ID_COLUMN_NAME + \")\"", "var_name": "CLEANUP_SQL"}, {"original_string": "@VisibleForTesting\n    // We always clean before selecting so it is unlikely to have the same row twice and if we\n    // do, it is not a big deal, just more data in the cursor.\n    static final String SELECT_UPDATED_TABLES_SQL = \"SELECT * FROM \" + UPDATE_TABLE_NAME\n            + \" WHERE \" + VERSION_COLUMN_NAME\n            + \"  > ? ORDER BY \" + VERSION_COLUMN_NAME + \" ASC;\";", "modifier": "@VisibleForTesting\n    // We always clean before selecting so it is unlikely to have the same row twice and if we\n    // do, it is not a big deal, just more data in the cursor.\n    static final", "type": "String", "declarator": "SELECT_UPDATED_TABLES_SQL = \"SELECT * FROM \" + UPDATE_TABLE_NAME\n            + \" WHERE \" + VERSION_COLUMN_NAME\n            + \"  > ? ORDER BY \" + VERSION_COLUMN_NAME + \" ASC;\"", "var_name": "SELECT_UPDATED_TABLES_SQL"}, {"original_string": "@NonNull\n    @VisibleForTesting\n    ArrayMap<String, Integer> mTableIdLookup;", "modifier": "@NonNull\n    @VisibleForTesting", "type": "ArrayMap<String, Integer>", "declarator": "mTableIdLookup", "var_name": "mTableIdLookup"}, {"original_string": "private String[] mTableNames;", "modifier": "private", "type": "String[]", "declarator": "mTableNames", "var_name": "mTableNames"}, {"original_string": "@NonNull\n    @VisibleForTesting\n    long[] mTableVersions;", "modifier": "@NonNull\n    @VisibleForTesting", "type": "long[]", "declarator": "mTableVersions", "var_name": "mTableVersions"}, {"original_string": "private Object[] mQueryArgs = new Object[1];", "modifier": "private", "type": "Object[]", "declarator": "mQueryArgs = new Object[1]", "var_name": "mQueryArgs"}, {"original_string": "private long mMaxVersion = -1;", "modifier": "private", "type": "long", "declarator": "mMaxVersion = -1", "var_name": "mMaxVersion"}, {"original_string": "private final RoomDatabase mDatabase;", "modifier": "private final", "type": "RoomDatabase", "declarator": "mDatabase", "var_name": "mDatabase"}, {"original_string": "AtomicBoolean mPendingRefresh = new AtomicBoolean(false);", "modifier": "", "type": "AtomicBoolean", "declarator": "mPendingRefresh = new AtomicBoolean(false)", "var_name": "mPendingRefresh"}, {"original_string": "private volatile boolean mInitialized = false;", "modifier": "private volatile", "type": "boolean", "declarator": "mInitialized = false", "var_name": "mInitialized"}, {"original_string": "private volatile SupportSQLiteStatement mCleanupStatement;", "modifier": "private volatile", "type": "SupportSQLiteStatement", "declarator": "mCleanupStatement", "var_name": "mCleanupStatement"}, {"original_string": "private ObservedTableTracker mObservedTableTracker;", "modifier": "private", "type": "ObservedTableTracker", "declarator": "mObservedTableTracker", "var_name": "mObservedTableTracker"}, {"original_string": "@VisibleForTesting\n    final SafeIterableMap<Observer, ObserverWrapper> mObserverMap = new SafeIterableMap<>();", "modifier": "@VisibleForTesting\n    final", "type": "SafeIterableMap<Observer, ObserverWrapper>", "declarator": "mObserverMap = new SafeIterableMap<>()", "var_name": "mObserverMap"}, {"original_string": "private Runnable mSyncTriggers = new Runnable() {\n        @Override\n        public void run() {\n            if (mDatabase.inTransaction()) {\n                // we won't run this inside another transaction.\n                return;\n            }\n            if (!ensureInitialization()) {\n                return;\n            }\n            try {\n                // This method runs in a while loop because while changes are synced to db, another\n                // runnable may be skipped. If we cause it to skip, we need to do its work.\n                while (true) {\n                    // there is a potential race condition where another mSyncTriggers runnable\n                    // can start running right after we get the tables list to sync.\n                    final int[] tablesToSync = mObservedTableTracker.getTablesToSync();\n                    if (tablesToSync == null) {\n                        return;\n                    }\n                    final int limit = tablesToSync.length;\n                    final SupportSQLiteDatabase writableDatabase = mDatabase.getOpenHelper()\n                            .getWritableDatabase();\n                    try {\n                        writableDatabase.beginTransaction();\n                        for (int tableId = 0; tableId < limit; tableId++) {\n                            switch (tablesToSync[tableId]) {\n                                case ObservedTableTracker.ADD:\n                                    startTrackingTable(writableDatabase, tableId);\n                                    break;\n                                case ObservedTableTracker.REMOVE:\n                                    stopTrackingTable(writableDatabase, tableId);\n                                    break;\n                            }\n                        }\n                        writableDatabase.setTransactionSuccessful();\n                    } finally {\n                        writableDatabase.endTransaction();\n                    }\n                    mObservedTableTracker.onSyncCompleted();\n                }\n            } catch (IllegalStateException | SQLiteException exception) {\n                // may happen if db is closed. just log.\n                Log.e(Room.LOG_TAG, \"Cannot run invalidation tracker. Is the db closed?\",\n                        exception);\n            }\n        }\n    };", "modifier": "private", "type": "Runnable", "declarator": "mSyncTriggers = new Runnable() {\n        @Override\n        public void run() {\n            if (mDatabase.inTransaction()) {\n                // we won't run this inside another transaction.\n                return;\n            }\n            if (!ensureInitialization()) {\n                return;\n            }\n            try {\n                // This method runs in a while loop because while changes are synced to db, another\n                // runnable may be skipped. If we cause it to skip, we need to do its work.\n                while (true) {\n                    // there is a potential race condition where another mSyncTriggers runnable\n                    // can start running right after we get the tables list to sync.\n                    final int[] tablesToSync = mObservedTableTracker.getTablesToSync();\n                    if (tablesToSync == null) {\n                        return;\n                    }\n                    final int limit = tablesToSync.length;\n                    final SupportSQLiteDatabase writableDatabase = mDatabase.getOpenHelper()\n                            .getWritableDatabase();\n                    try {\n                        writableDatabase.beginTransaction();\n                        for (int tableId = 0; tableId < limit; tableId++) {\n                            switch (tablesToSync[tableId]) {\n                                case ObservedTableTracker.ADD:\n                                    startTrackingTable(writableDatabase, tableId);\n                                    break;\n                                case ObservedTableTracker.REMOVE:\n                                    stopTrackingTable(writableDatabase, tableId);\n                                    break;\n                            }\n                        }\n                        writableDatabase.setTransactionSuccessful();\n                    } finally {\n                        writableDatabase.endTransaction();\n                    }\n                    mObservedTableTracker.onSyncCompleted();\n                }\n            } catch (IllegalStateException | SQLiteException exception) {\n                // may happen if db is closed. just log.\n                Log.e(Room.LOG_TAG, \"Cannot run invalidation tracker. Is the db closed?\",\n                        exception);\n            }\n        }\n    }", "var_name": "mSyncTriggers"}, {"original_string": "@VisibleForTesting\n    Runnable mRefreshRunnable = new Runnable() {\n        @Override\n        public void run() {\n            final Lock closeLock = mDatabase.getCloseLock();\n            boolean hasUpdatedTable = false;\n            try {\n                closeLock.lock();\n\n                if (!ensureInitialization()) {\n                    return;\n                }\n\n                if (mDatabase.inTransaction()\n                        || !mPendingRefresh.compareAndSet(true, false)) {\n                    // no pending refresh\n                    return;\n                }\n                mCleanupStatement.executeUpdateDelete();\n                mQueryArgs[0] = mMaxVersion;\n                Cursor cursor = mDatabase.query(SELECT_UPDATED_TABLES_SQL, mQueryArgs);\n                //noinspection TryFinallyCanBeTryWithResources\n                try {\n                    while (cursor.moveToNext()) {\n                        final long version = cursor.getLong(0);\n                        final int tableId = cursor.getInt(1);\n\n                        mTableVersions[tableId] = version;\n                        hasUpdatedTable = true;\n                        // result is ordered so we can safely do this assignment\n                        mMaxVersion = version;\n                    }\n                } finally {\n                    cursor.close();\n                }\n            } catch (IllegalStateException | SQLiteException exception) {\n                // may happen if db is closed. just log.\n                Log.e(Room.LOG_TAG, \"Cannot run invalidation tracker. Is the db closed?\",\n                        exception);\n            } finally {\n                closeLock.unlock();\n            }\n            if (hasUpdatedTable) {\n                synchronized (mObserverMap) {\n                    for (Map.Entry<Observer, ObserverWrapper> entry : mObserverMap) {\n                        entry.getValue().checkForInvalidation(mTableVersions);\n                    }\n                }\n            }\n        }\n    };", "modifier": "@VisibleForTesting", "type": "Runnable", "declarator": "mRefreshRunnable = new Runnable() {\n        @Override\n        public void run() {\n            final Lock closeLock = mDatabase.getCloseLock();\n            boolean hasUpdatedTable = false;\n            try {\n                closeLock.lock();\n\n                if (!ensureInitialization()) {\n                    return;\n                }\n\n                if (mDatabase.inTransaction()\n                        || !mPendingRefresh.compareAndSet(true, false)) {\n                    // no pending refresh\n                    return;\n                }\n                mCleanupStatement.executeUpdateDelete();\n                mQueryArgs[0] = mMaxVersion;\n                Cursor cursor = mDatabase.query(SELECT_UPDATED_TABLES_SQL, mQueryArgs);\n                //noinspection TryFinallyCanBeTryWithResources\n                try {\n                    while (cursor.moveToNext()) {\n                        final long version = cursor.getLong(0);\n                        final int tableId = cursor.getInt(1);\n\n                        mTableVersions[tableId] = version;\n                        hasUpdatedTable = true;\n                        // result is ordered so we can safely do this assignment\n                        mMaxVersion = version;\n                    }\n                } finally {\n                    cursor.close();\n                }\n            } catch (IllegalStateException | SQLiteException exception) {\n                // may happen if db is closed. just log.\n                Log.e(Room.LOG_TAG, \"Cannot run invalidation tracker. Is the db closed?\",\n                        exception);\n            } finally {\n                closeLock.unlock();\n            }\n            if (hasUpdatedTable) {\n                synchronized (mObserverMap) {\n                    for (Map.Entry<Observer, ObserverWrapper> entry : mObserverMap) {\n                        entry.getValue().checkForInvalidation(mTableVersions);\n                    }\n                }\n            }\n        }\n    }", "var_name": "mRefreshRunnable"}], "methods": [{"identifier": "InvalidationTracker", "parameters": "(RoomDatabase database, String... tableNames)", "modifiers": "@SuppressWarnings(\"WeakerAccess\") @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public", "return": "", "signature": " InvalidationTracker(RoomDatabase database, String... tableNames)", "full_signature": "@SuppressWarnings(\"WeakerAccess\") @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public  InvalidationTracker(RoomDatabase database, String... tableNames)", "class_method_signature": "InvalidationTracker.InvalidationTracker(RoomDatabase database, String... tableNames)", "testcase": false, "constructor": true}, {"identifier": "internalInit", "parameters": "(SupportSQLiteDatabase database)", "modifiers": "", "return": "void", "signature": "void internalInit(SupportSQLiteDatabase database)", "full_signature": " void internalInit(SupportSQLiteDatabase database)", "class_method_signature": "InvalidationTracker.internalInit(SupportSQLiteDatabase database)", "testcase": false, "constructor": false}, {"identifier": "appendTriggerName", "parameters": "(StringBuilder builder, String tableName,\n            String triggerType)", "modifiers": "private static", "return": "void", "signature": "void appendTriggerName(StringBuilder builder, String tableName,\n            String triggerType)", "full_signature": "private static void appendTriggerName(StringBuilder builder, String tableName,\n            String triggerType)", "class_method_signature": "InvalidationTracker.appendTriggerName(StringBuilder builder, String tableName,\n            String triggerType)", "testcase": false, "constructor": false}, {"identifier": "stopTrackingTable", "parameters": "(SupportSQLiteDatabase writableDb, int tableId)", "modifiers": "private", "return": "void", "signature": "void stopTrackingTable(SupportSQLiteDatabase writableDb, int tableId)", "full_signature": "private void stopTrackingTable(SupportSQLiteDatabase writableDb, int tableId)", "class_method_signature": "InvalidationTracker.stopTrackingTable(SupportSQLiteDatabase writableDb, int tableId)", "testcase": false, "constructor": false}, {"identifier": "startTrackingTable", "parameters": "(SupportSQLiteDatabase writableDb, int tableId)", "modifiers": "private", "return": "void", "signature": "void startTrackingTable(SupportSQLiteDatabase writableDb, int tableId)", "full_signature": "private void startTrackingTable(SupportSQLiteDatabase writableDb, int tableId)", "class_method_signature": "InvalidationTracker.startTrackingTable(SupportSQLiteDatabase writableDb, int tableId)", "testcase": false, "constructor": false}, {"identifier": "addObserver", "parameters": "(Observer observer)", "modifiers": "public", "return": "void", "signature": "void addObserver(Observer observer)", "full_signature": "public void addObserver(Observer observer)", "class_method_signature": "InvalidationTracker.addObserver(Observer observer)", "testcase": false, "constructor": false}, {"identifier": "addWeakObserver", "parameters": "(Observer observer)", "modifiers": "@SuppressWarnings(\"unused\") @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public", "return": "void", "signature": "void addWeakObserver(Observer observer)", "full_signature": "@SuppressWarnings(\"unused\") @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public void addWeakObserver(Observer observer)", "class_method_signature": "InvalidationTracker.addWeakObserver(Observer observer)", "testcase": false, "constructor": false}, {"identifier": "removeObserver", "parameters": "(final Observer observer)", "modifiers": "@SuppressWarnings(\"WeakerAccess\") public", "return": "void", "signature": "void removeObserver(final Observer observer)", "full_signature": "@SuppressWarnings(\"WeakerAccess\") public void removeObserver(final Observer observer)", "class_method_signature": "InvalidationTracker.removeObserver(final Observer observer)", "testcase": false, "constructor": false}, {"identifier": "ensureInitialization", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean ensureInitialization()", "full_signature": "private boolean ensureInitialization()", "class_method_signature": "InvalidationTracker.ensureInitialization()", "testcase": false, "constructor": false}, {"identifier": "refreshVersionsAsync", "parameters": "()", "modifiers": "@SuppressWarnings(\"WeakerAccess\") public", "return": "void", "signature": "void refreshVersionsAsync()", "full_signature": "@SuppressWarnings(\"WeakerAccess\") public void refreshVersionsAsync()", "class_method_signature": "InvalidationTracker.refreshVersionsAsync()", "testcase": false, "constructor": false}, {"identifier": "refreshVersionsSync", "parameters": "()", "modifiers": "@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) @WorkerThread public", "return": "void", "signature": "void refreshVersionsSync()", "full_signature": "@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) @WorkerThread public void refreshVersionsSync()", "class_method_signature": "InvalidationTracker.refreshVersionsSync()", "testcase": false, "constructor": false}, {"identifier": "syncTriggers", "parameters": "()", "modifiers": "", "return": "void", "signature": "void syncTriggers()", "full_signature": " void syncTriggers()", "class_method_signature": "InvalidationTracker.syncTriggers()", "testcase": false, "constructor": false}], "file": "room/runtime/src/main/java/android/arch/persistence/room/InvalidationTracker.java"}, "focal_method": {"identifier": "addObserver", "parameters": "(Observer observer)", "modifiers": "public", "return": "void", "body": "public void addObserver(Observer observer) {\n        final String[] tableNames = observer.mTables;\n        int[] tableIds = new int[tableNames.length];\n        final int size = tableNames.length;\n        long[] versions = new long[tableNames.length];\n\n        // TODO sync versions ?\n        for (int i = 0; i < size; i++) {\n            Integer tableId = mTableIdLookup.get(tableNames[i].toLowerCase(Locale.US));\n            if (tableId == null) {\n                throw new IllegalArgumentException(\"There is no table with name \" + tableNames[i]);\n            }\n            tableIds[i] = tableId;\n            versions[i] = mMaxVersion;\n        }\n        ObserverWrapper wrapper = new ObserverWrapper(observer, tableIds, tableNames, versions);\n        ObserverWrapper currentObserver;\n        synchronized (mObserverMap) {\n            currentObserver = mObserverMap.putIfAbsent(observer, wrapper);\n        }\n        if (currentObserver == null && mObservedTableTracker.onAdded(tableIds)) {\n            AppToolkitTaskExecutor.getInstance().executeOnDiskIO(mSyncTriggers);\n        }\n    }", "signature": "void addObserver(Observer observer)", "full_signature": "public void addObserver(Observer observer)", "class_method_signature": "InvalidationTracker.addObserver(Observer observer)", "testcase": false, "constructor": false, "invocations": ["get", "toLowerCase", "putIfAbsent", "onAdded", "executeOnDiskIO", "getInstance"]}, "repository": {"repo_id": 104025215, "url": "https://github.com/Rayduh/support", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 8, "size": 253405, "license": "licensed"}}