{"test_class": {"identifier": "AbstractVFStateTest", "superclass": "", "interfaces": "", "fields": [], "file": "base/isomorphism/src/test/java/org/openscience/cdk/isomorphism/AbstractVFStateTest.java"}, "test_case": {"identifier": "add", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void add() {\n        int[][] g1 = new int[][]{{1}, {0, 2}, {1, 3}, {2}};\n        int[][] g2 = new int[][]{{1}, {0, 2}, {1, 3}, {2, 4}, {3, 5}, {4}};\n        AbstractVFState state = create(g1, g2);\n        assertTrue(state.add(0, 1));\n        assertThat(state.size, is(1));\n        assertThat(state.m1, is(new int[]{1, UNMAPPED, UNMAPPED, UNMAPPED}));\n        assertThat(state.m2, is(new int[]{UNMAPPED, 0, UNMAPPED, UNMAPPED, UNMAPPED, UNMAPPED}));\n        assertThat(state.t1, is(new int[]{0, 1, 0, 0}));\n        assertThat(state.t2, is(new int[]{1, 0, 1, 0, 0, 0}));\n        assertTrue(state.add(1, 2));\n        assertThat(state.size, is(2));\n        assertThat(state.m1, is(new int[]{1, 2, UNMAPPED, UNMAPPED}));\n        assertThat(state.m2, is(new int[]{UNMAPPED, 0, 1, UNMAPPED, UNMAPPED, UNMAPPED}));\n        assertThat(state.t1, is(new int[]{2, 1, 2, 0}));\n        assertThat(state.t2, is(new int[]{1, 2, 1, 2, 0, 0}));\n    }", "signature": "void add()", "full_signature": "@Test public void add()", "class_method_signature": "AbstractVFStateTest.add()", "testcase": true, "constructor": false, "invocations": ["create", "assertTrue", "add", "assertThat", "is", "assertThat", "is", "assertThat", "is", "assertThat", "is", "assertThat", "is", "assertTrue", "add", "assertThat", "is", "assertThat", "is", "assertThat", "is", "assertThat", "is", "assertThat", "is"]}, "focal_class": {"identifier": "AbstractVFState", "superclass": "extends State", "interfaces": "", "fields": [{"original_string": "protected static final int UNMAPPED = -1;", "modifier": "protected static final", "type": "int", "declarator": "UNMAPPED = -1", "var_name": "UNMAPPED"}, {"original_string": "protected final int[][]    g1, g2;", "modifier": "protected final", "type": "int[][]", "declarator": "g1", "var_name": "g1"}, {"original_string": "protected final int[]      m1, m2;", "modifier": "protected final", "type": "int[]", "declarator": "m1", "var_name": "m1"}, {"original_string": "protected final int[]      t1, t2;", "modifier": "protected final", "type": "int[]", "declarator": "t1", "var_name": "t1"}, {"original_string": "protected int              size;", "modifier": "protected", "type": "int", "declarator": "size", "var_name": "size"}], "methods": [{"identifier": "AbstractVFState", "parameters": "(final int[][] g1, final int[][] g2)", "modifiers": "public", "return": "", "signature": " AbstractVFState(final int[][] g1, final int[][] g2)", "full_signature": "public  AbstractVFState(final int[][] g1, final int[][] g2)", "class_method_signature": "AbstractVFState.AbstractVFState(final int[][] g1, final int[][] g2)", "testcase": false, "constructor": true}, {"identifier": "nextN", "parameters": "(int n)", "modifiers": "@Override final", "return": "int", "signature": "int nextN(int n)", "full_signature": "@Override final int nextN(int n)", "class_method_signature": "AbstractVFState.nextN(int n)", "testcase": false, "constructor": false}, {"identifier": "nextM", "parameters": "(int n, int m)", "modifiers": "@Override final", "return": "int", "signature": "int nextM(int n, int m)", "full_signature": "@Override final int nextM(int n, int m)", "class_method_signature": "AbstractVFState.nextM(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "nMax", "parameters": "()", "modifiers": "@Override final", "return": "int", "signature": "int nMax()", "full_signature": "@Override final int nMax()", "class_method_signature": "AbstractVFState.nMax()", "testcase": false, "constructor": false}, {"identifier": "mMax", "parameters": "()", "modifiers": "@Override final", "return": "int", "signature": "int mMax()", "full_signature": "@Override final int mMax()", "class_method_signature": "AbstractVFState.mMax()", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(int n, int m)", "modifiers": "@Override final", "return": "boolean", "signature": "boolean add(int n, int m)", "full_signature": "@Override final boolean add(int n, int m)", "class_method_signature": "AbstractVFState.add(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(int n, int m)", "modifiers": "@Override final", "return": "void", "signature": "void remove(int n, int m)", "full_signature": "@Override final void remove(int n, int m)", "class_method_signature": "AbstractVFState.remove(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "feasible", "parameters": "(int n, int m)", "modifiers": "abstract", "return": "boolean", "signature": "boolean feasible(int n, int m)", "full_signature": "abstract boolean feasible(int n, int m)", "class_method_signature": "AbstractVFState.feasible(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "mapping", "parameters": "()", "modifiers": "@Override", "return": "int[]", "signature": "int[] mapping()", "full_signature": "@Override int[] mapping()", "class_method_signature": "AbstractVFState.mapping()", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "@Override", "return": "int", "signature": "int size()", "full_signature": "@Override int size()", "class_method_signature": "AbstractVFState.size()", "testcase": false, "constructor": false}], "file": "base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/AbstractVFState.java"}, "focal_method": {"identifier": "add", "parameters": "(int n, int m)", "modifiers": "@Override final", "return": "boolean", "body": "@Override\n    final boolean add(int n, int m) {\n        if (!feasible(n, m)) return false;\n        m1[n] = m;\n        m2[m] = n;\n        size = size + 1;\n        for (int w : g1[n])\n            if (t1[w] == 0) t1[w] = size;\n        for (int w : g2[m])\n            if (t2[w] == 0) t2[w] = size;\n        return true;\n    }", "signature": "boolean add(int n, int m)", "full_signature": "@Override final boolean add(int n, int m)", "class_method_signature": "AbstractVFState.add(int n, int m)", "testcase": false, "constructor": false, "invocations": ["feasible"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}