{"test_class": {"identifier": "BinaryClassificationMetricsTest", "superclass": "", "interfaces": "", "fields": [], "file": "modules/ml/src/test/java/org/apache/ignite/ml/selection/scoring/metric/classification/BinaryClassificationMetricsTest.java"}, "test_case": {"identifier": "testDefaultBehaviourForScoreAll", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDefaultBehaviourForScoreAll() {\n        BinaryClassificationMetrics scoreCalculator = new BinaryClassificationMetrics();\n\n        LabelPairCursor<Double> cursor = new TestLabelPairCursor<>(\n            Arrays.asList(1.0, 1.0, 1.0, 1.0),\n            Arrays.asList(1.0, 1.0, 0.0, 1.0)\n        );\n\n        BinaryClassificationMetricValues metricValues = scoreCalculator.scoreAll(cursor.iterator());\n\n        assertEquals(0.75, metricValues.accuracy(), 1e-12);\n    }", "signature": "void testDefaultBehaviourForScoreAll()", "full_signature": "@Test public void testDefaultBehaviourForScoreAll()", "class_method_signature": "BinaryClassificationMetricsTest.testDefaultBehaviourForScoreAll()", "testcase": true, "constructor": false, "invocations": ["asList", "asList", "scoreAll", "iterator", "assertEquals", "accuracy"]}, "focal_class": {"identifier": "BinaryClassificationMetrics", "superclass": "extends AbstractMetrics<BinaryClassificationMetricValues>", "interfaces": "", "fields": [{"original_string": "private double positiveClsLb = 1.0;", "modifier": "private", "type": "double", "declarator": "positiveClsLb = 1.0", "var_name": "positiveClsLb"}, {"original_string": "private double negativeClsLb;", "modifier": "private", "type": "double", "declarator": "negativeClsLb", "var_name": "negativeClsLb"}, {"original_string": "private boolean enableROCAUC;", "modifier": "private", "type": "boolean", "declarator": "enableROCAUC", "var_name": "enableROCAUC"}], "methods": [{"identifier": "scoreAll", "parameters": "(Iterator<LabelPair<Double>> iter)", "modifiers": "@Override public", "return": "BinaryClassificationMetricValues", "signature": "BinaryClassificationMetricValues scoreAll(Iterator<LabelPair<Double>> iter)", "full_signature": "@Override public BinaryClassificationMetricValues scoreAll(Iterator<LabelPair<Double>> iter)", "class_method_signature": "BinaryClassificationMetrics.scoreAll(Iterator<LabelPair<Double>> iter)", "testcase": false, "constructor": false}, {"identifier": "positiveClsLb", "parameters": "()", "modifiers": "public", "return": "double", "signature": "double positiveClsLb()", "full_signature": "public double positiveClsLb()", "class_method_signature": "BinaryClassificationMetrics.positiveClsLb()", "testcase": false, "constructor": false}, {"identifier": "withPositiveClsLb", "parameters": "(double positiveClsLb)", "modifiers": "public", "return": "BinaryClassificationMetrics", "signature": "BinaryClassificationMetrics withPositiveClsLb(double positiveClsLb)", "full_signature": "public BinaryClassificationMetrics withPositiveClsLb(double positiveClsLb)", "class_method_signature": "BinaryClassificationMetrics.withPositiveClsLb(double positiveClsLb)", "testcase": false, "constructor": false}, {"identifier": "negativeClsLb", "parameters": "()", "modifiers": "public", "return": "double", "signature": "double negativeClsLb()", "full_signature": "public double negativeClsLb()", "class_method_signature": "BinaryClassificationMetrics.negativeClsLb()", "testcase": false, "constructor": false}, {"identifier": "withNegativeClsLb", "parameters": "(double negativeClsLb)", "modifiers": "public", "return": "BinaryClassificationMetrics", "signature": "BinaryClassificationMetrics withNegativeClsLb(double negativeClsLb)", "full_signature": "public BinaryClassificationMetrics withNegativeClsLb(double negativeClsLb)", "class_method_signature": "BinaryClassificationMetrics.withNegativeClsLb(double negativeClsLb)", "testcase": false, "constructor": false}, {"identifier": "withEnablingROCAUC", "parameters": "(boolean enableROCAUC)", "modifiers": "public", "return": "BinaryClassificationMetrics", "signature": "BinaryClassificationMetrics withEnablingROCAUC(boolean enableROCAUC)", "full_signature": "public BinaryClassificationMetrics withEnablingROCAUC(boolean enableROCAUC)", "class_method_signature": "BinaryClassificationMetrics.withEnablingROCAUC(boolean enableROCAUC)", "testcase": false, "constructor": false}, {"identifier": "isROCAUCenabled", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isROCAUCenabled()", "full_signature": "public boolean isROCAUCenabled()", "class_method_signature": "BinaryClassificationMetrics.isROCAUCenabled()", "testcase": false, "constructor": false}, {"identifier": "name", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String name()", "full_signature": "@Override public String name()", "class_method_signature": "BinaryClassificationMetrics.name()", "testcase": false, "constructor": false}], "file": "modules/ml/src/main/java/org/apache/ignite/ml/selection/scoring/metric/classification/BinaryClassificationMetrics.java"}, "focal_method": {"identifier": "scoreAll", "parameters": "(Iterator<LabelPair<Double>> iter)", "modifiers": "@Override public", "return": "BinaryClassificationMetricValues", "body": "@Override public BinaryClassificationMetricValues scoreAll(Iterator<LabelPair<Double>> iter) {\n        long tp = 0;\n        long tn = 0;\n        long fp = 0;\n        long fn = 0;\n        double rocauc = Double.NaN;\n\n        // for ROC AUC calculation\n        long pos = 0;\n        long neg = 0;\n        PriorityQueue<Pair<Double, Double>> queue = new PriorityQueue<>(Comparator.comparingDouble(Pair::getKey));\n\n        while (iter.hasNext()) {\n            LabelPair<Double> e = iter.next();\n\n            double prediction = e.getPrediction();\n            double truth = e.getTruth();\n\n            if (prediction != negativeClsLb && prediction != positiveClsLb)\n                throw new UnknownClassLabelException(prediction, positiveClsLb, negativeClsLb);\n            if (truth != negativeClsLb && truth != positiveClsLb)\n                throw new UnknownClassLabelException(truth, positiveClsLb, negativeClsLb);\n\n            if (truth == positiveClsLb && prediction == positiveClsLb) tp++;\n            else if (truth == positiveClsLb && prediction == negativeClsLb) fn++;\n            else if (truth == negativeClsLb && prediction == negativeClsLb) tn++;\n            else if (truth == negativeClsLb && prediction == positiveClsLb) fp++;\n\n            if (enableROCAUC) {\n                queue.add(new Pair<>(prediction, truth));\n\n                if (truth == positiveClsLb)\n                    pos++;\n                else if (truth == negativeClsLb)\n                    neg++;\n                else\n                    throw new UnknownClassLabelException(truth, positiveClsLb, negativeClsLb);\n            }\n\n        }\n\n        if (enableROCAUC)\n            rocauc = ROCAUC.calculateROCAUC(queue, pos, neg, positiveClsLb);\n\n        return new BinaryClassificationMetricValues(tp, tn, fp, fn, rocauc);\n    }", "signature": "BinaryClassificationMetricValues scoreAll(Iterator<LabelPair<Double>> iter)", "full_signature": "@Override public BinaryClassificationMetricValues scoreAll(Iterator<LabelPair<Double>> iter)", "class_method_signature": "BinaryClassificationMetrics.scoreAll(Iterator<LabelPair<Double>> iter)", "testcase": false, "constructor": false, "invocations": ["comparingDouble", "hasNext", "next", "getPrediction", "getTruth", "add", "calculateROCAUC"]}, "repository": {"repo_id": 170496871, "url": "https://github.com/gridgain/gridgain", "stars": 46, "created": "2/13/2019 11:31:35 AM +00:00", "updates": "2020-01-27T16:02:24+00:00", "fork": "False", "license": "licensed"}}