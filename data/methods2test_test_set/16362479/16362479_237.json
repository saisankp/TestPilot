{"test_class": {"identifier": "CandidateTest", "superclass": "extends AbstractRaftActorBehaviorTest<Candidate>", "interfaces": "", "fields": [{"original_string": "static final Logger LOG = LoggerFactory.getLogger(CandidateTest.class);", "modifier": "static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(CandidateTest.class)", "var_name": "LOG"}, {"original_string": "private final TestActorRef<MessageCollectorActor> candidateActor = actorFactory.createTestActor(\n            MessageCollectorActor.props().withDispatcher(Dispatchers.DefaultDispatcherId()),\n            actorFactory.generateActorId(\"candidate\"));", "modifier": "private final", "type": "TestActorRef<MessageCollectorActor>", "declarator": "candidateActor = actorFactory.createTestActor(\n            MessageCollectorActor.props().withDispatcher(Dispatchers.DefaultDispatcherId()),\n            actorFactory.generateActorId(\"candidate\"))", "var_name": "candidateActor"}, {"original_string": "private ActorRef[] peerActors;", "modifier": "private", "type": "ActorRef[]", "declarator": "peerActors", "var_name": "peerActors"}, {"original_string": "private RaftActorBehavior candidate;", "modifier": "private", "type": "RaftActorBehavior", "declarator": "candidate", "var_name": "candidate"}], "file": "opendaylight/md-sal/sal-akka-raft/src/test/java/org/opendaylight/controller/cluster/raft/behaviors/CandidateTest.java"}, "test_case": {"identifier": "testBecomeLeaderOnReceivingMajorityVotesWithNonVotingPeers", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testBecomeLeaderOnReceivingMajorityVotesWithNonVotingPeers() {\n        ElectionTerm mockElectionTerm = Mockito.mock(ElectionTerm.class);\n        Mockito.doReturn(1L).when(mockElectionTerm).getCurrentTerm();\n        RaftActorContext raftActorContext = new RaftActorContextImpl(candidateActor, candidateActor.actorContext(),\n                \"candidate\", mockElectionTerm, -1, -1, setupPeers(4), new DefaultConfigParamsImpl(),\n                new NonPersistentDataProvider(Runnable::run), applyState -> { }, LOG,  MoreExecutors.directExecutor());\n        raftActorContext.setReplicatedLog(new MockRaftActorContext.MockReplicatedLogBuilder().build());\n        raftActorContext.getPeerInfo(\"peer1\").setVotingState(VotingState.NON_VOTING);\n        raftActorContext.getPeerInfo(\"peer4\").setVotingState(VotingState.NON_VOTING);\n        candidate = new Candidate(raftActorContext);\n\n        MessageCollectorActor.expectFirstMatching(peerActors[1], RequestVote.class);\n        MessageCollectorActor.expectFirstMatching(peerActors[2], RequestVote.class);\n        MessageCollectorActor.assertNoneMatching(peerActors[0], RequestVote.class, 300);\n        MessageCollectorActor.assertNoneMatching(peerActors[3], RequestVote.class, 100);\n\n        candidate = candidate.handleMessage(peerActors[1], new RequestVoteReply(1, false));\n\n        assertEquals(\"Behavior\", RaftState.Candidate, candidate.state());\n\n        candidate = candidate.handleMessage(peerActors[2], new RequestVoteReply(1, true));\n\n        assertEquals(\"Behavior\", RaftState.Leader, candidate.state());\n    }", "signature": "void testBecomeLeaderOnReceivingMajorityVotesWithNonVotingPeers()", "full_signature": "@Test public void testBecomeLeaderOnReceivingMajorityVotesWithNonVotingPeers()", "class_method_signature": "CandidateTest.testBecomeLeaderOnReceivingMajorityVotesWithNonVotingPeers()", "testcase": true, "constructor": false, "invocations": ["mock", "getCurrentTerm", "when", "doReturn", "actorContext", "setupPeers", "directExecutor", "setReplicatedLog", "build", "setVotingState", "getPeerInfo", "setVotingState", "getPeerInfo", "expectFirstMatching", "expectFirstMatching", "assertNoneMatching", "assertNoneMatching", "handleMessage", "assertEquals", "state", "handleMessage", "assertEquals", "state"]}, "focal_class": {"identifier": "Candidate", "superclass": "extends AbstractRaftActorBehavior", "interfaces": "", "fields": [{"original_string": "private int voteCount;", "modifier": "private", "type": "int", "declarator": "voteCount", "var_name": "voteCount"}, {"original_string": "private final int votesRequired;", "modifier": "private final", "type": "int", "declarator": "votesRequired", "var_name": "votesRequired"}, {"original_string": "private final Collection<String> votingPeers = new ArrayList<>();", "modifier": "private final", "type": "Collection<String>", "declarator": "votingPeers = new ArrayList<>()", "var_name": "votingPeers"}], "methods": [{"identifier": "Candidate", "parameters": "(final RaftActorContext context)", "modifiers": "public", "return": "", "signature": " Candidate(final RaftActorContext context)", "full_signature": "public  Candidate(final RaftActorContext context)", "class_method_signature": "Candidate.Candidate(final RaftActorContext context)", "testcase": false, "constructor": true}, {"identifier": "getLeaderId", "parameters": "()", "modifiers": "@Override public final", "return": "String", "signature": "String getLeaderId()", "full_signature": "@Override public final String getLeaderId()", "class_method_signature": "Candidate.getLeaderId()", "testcase": false, "constructor": false}, {"identifier": "getLeaderPayloadVersion", "parameters": "()", "modifiers": "@Override public final", "return": "short", "signature": "short getLeaderPayloadVersion()", "full_signature": "@Override public final short getLeaderPayloadVersion()", "class_method_signature": "Candidate.getLeaderPayloadVersion()", "testcase": false, "constructor": false}, {"identifier": "handleAppendEntries", "parameters": "(final ActorRef sender, final AppendEntries appendEntries)", "modifiers": "@Override protected", "return": "RaftActorBehavior", "signature": "RaftActorBehavior handleAppendEntries(final ActorRef sender, final AppendEntries appendEntries)", "full_signature": "@Override protected RaftActorBehavior handleAppendEntries(final ActorRef sender, final AppendEntries appendEntries)", "class_method_signature": "Candidate.handleAppendEntries(final ActorRef sender, final AppendEntries appendEntries)", "testcase": false, "constructor": false}, {"identifier": "handleAppendEntriesReply", "parameters": "(final ActorRef sender,\n            final AppendEntriesReply appendEntriesReply)", "modifiers": "@Override protected", "return": "RaftActorBehavior", "signature": "RaftActorBehavior handleAppendEntriesReply(final ActorRef sender,\n            final AppendEntriesReply appendEntriesReply)", "full_signature": "@Override protected RaftActorBehavior handleAppendEntriesReply(final ActorRef sender,\n            final AppendEntriesReply appendEntriesReply)", "class_method_signature": "Candidate.handleAppendEntriesReply(final ActorRef sender,\n            final AppendEntriesReply appendEntriesReply)", "testcase": false, "constructor": false}, {"identifier": "handleRequestVoteReply", "parameters": "(final ActorRef sender, final RequestVoteReply requestVoteReply)", "modifiers": "@Override protected", "return": "RaftActorBehavior", "signature": "RaftActorBehavior handleRequestVoteReply(final ActorRef sender, final RequestVoteReply requestVoteReply)", "full_signature": "@Override protected RaftActorBehavior handleRequestVoteReply(final ActorRef sender, final RequestVoteReply requestVoteReply)", "class_method_signature": "Candidate.handleRequestVoteReply(final ActorRef sender, final RequestVoteReply requestVoteReply)", "testcase": false, "constructor": false}, {"identifier": "electionDuration", "parameters": "()", "modifiers": "@Override protected", "return": "FiniteDuration", "signature": "FiniteDuration electionDuration()", "full_signature": "@Override protected FiniteDuration electionDuration()", "class_method_signature": "Candidate.electionDuration()", "testcase": false, "constructor": false}, {"identifier": "getApplyStateFor", "parameters": "(final ReplicatedLogEntry entry)", "modifiers": "@Override final", "return": "ApplyState", "signature": "ApplyState getApplyStateFor(final ReplicatedLogEntry entry)", "full_signature": "@Override final ApplyState getApplyStateFor(final ReplicatedLogEntry entry)", "class_method_signature": "Candidate.getApplyStateFor(final ReplicatedLogEntry entry)", "testcase": false, "constructor": false}, {"identifier": "handleMessage", "parameters": "(final ActorRef sender, final Object message)", "modifiers": "@Override public", "return": "RaftActorBehavior", "signature": "RaftActorBehavior handleMessage(final ActorRef sender, final Object message)", "full_signature": "@Override public RaftActorBehavior handleMessage(final ActorRef sender, final Object message)", "class_method_signature": "Candidate.handleMessage(final ActorRef sender, final Object message)", "testcase": false, "constructor": false}, {"identifier": "startNewTerm", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void startNewTerm()", "full_signature": "private void startNewTerm()", "class_method_signature": "Candidate.startNewTerm()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "Candidate.close()", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-akka-raft/src/main/java/org/opendaylight/controller/cluster/raft/behaviors/Candidate.java"}, "focal_method": {"identifier": "handleMessage", "parameters": "(final ActorRef sender, final Object message)", "modifiers": "@Override public", "return": "RaftActorBehavior", "body": "@Override\n    public RaftActorBehavior handleMessage(final ActorRef sender, final Object message) {\n        if (message instanceof ElectionTimeout) {\n            log.debug(\"{}: Received ElectionTimeout\", logName());\n\n            if (votesRequired == 0) {\n                // If there are no peers then we should be a Leader\n                // We wait for the election timeout to occur before declare\n                // ourselves the leader. This gives enough time for a leader\n                // who we do not know about (as a peer)\n                // to send a message to the candidate\n\n                return internalSwitchBehavior(RaftState.Leader);\n            }\n\n            startNewTerm();\n            scheduleElection(electionDuration());\n            return this;\n        }\n\n        if (message instanceof RaftRPC) {\n\n            RaftRPC rpc = (RaftRPC) message;\n\n            log.debug(\"{}: RaftRPC message received {}, my term is {}\", logName(), rpc,\n                        context.getTermInformation().getCurrentTerm());\n\n            // If RPC request or response contains term T > currentTerm:\n            // set currentTerm = T, convert to follower (\u00a75.1)\n            // This applies to all RPC messages and responses\n            if (rpc.getTerm() > context.getTermInformation().getCurrentTerm()) {\n                log.info(\"{}: Term {} in \\\"{}\\\" message is greater than Candidate's term {} - switching to Follower\",\n                        logName(), rpc.getTerm(), rpc, context.getTermInformation().getCurrentTerm());\n\n                context.getTermInformation().updateAndPersist(rpc.getTerm(), null);\n\n                // The raft paper does not say whether or not a Candidate can/should process a RequestVote in\n                // this case but doing so gains quicker convergence when the sender's log is more up-to-date.\n                if (message instanceof RequestVote) {\n                    super.handleMessage(sender, message);\n                }\n\n                return internalSwitchBehavior(RaftState.Follower);\n            }\n        }\n\n        return super.handleMessage(sender, message);\n    }", "signature": "RaftActorBehavior handleMessage(final ActorRef sender, final Object message)", "full_signature": "@Override public RaftActorBehavior handleMessage(final ActorRef sender, final Object message)", "class_method_signature": "Candidate.handleMessage(final ActorRef sender, final Object message)", "testcase": false, "constructor": false, "invocations": ["debug", "logName", "internalSwitchBehavior", "startNewTerm", "scheduleElection", "electionDuration", "debug", "logName", "getCurrentTerm", "getTermInformation", "getTerm", "getCurrentTerm", "getTermInformation", "info", "logName", "getTerm", "getCurrentTerm", "getTermInformation", "updateAndPersist", "getTermInformation", "getTerm", "handleMessage", "internalSwitchBehavior", "handleMessage"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}