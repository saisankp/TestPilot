{"test_class": {"identifier": "TestJMSCore", "superclass": "extends TestJMSBase", "interfaces": "", "fields": [{"original_string": "NoSendJMSCore core;", "modifier": "", "type": "NoSendJMSCore", "declarator": "core", "var_name": "core"}, {"original_string": "String sourceName;", "modifier": "", "type": "String", "declarator": "sourceName", "var_name": "sourceName"}, {"original_string": "String authToken;", "modifier": "", "type": "String", "declarator": "authToken", "var_name": "authToken"}, {"original_string": "String targetVantiqServer;", "modifier": "", "type": "String", "declarator": "targetVantiqServer", "var_name": "targetVantiqServer"}, {"original_string": "JMS jms;", "modifier": "", "type": "JMS", "declarator": "jms", "var_name": "jms"}], "file": "jmsSource/src/test/java/io/vantiq/extsrc/jmsSource/TestJMSCore.java"}, "test_case": {"identifier": "testIncorectPublishRequests", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testIncorectPublishRequests() {        \n        Map<String, Object> request;\n        ExtensionServiceMessage msg = new ExtensionServiceMessage(\"\");\n        Map<String, String> header = new LinkedHashMap<>();\n        header.put(ExtensionServiceMessage.ORIGIN_ADDRESS_HEADER, \"queryAddress\");\n        msg.messageHeaders = header;\n        \n        // Sending an empty publish request\n        request = new LinkedHashMap<>();\n        msg.object = request;\n        core.sendJMSMessage(msg);\n        assertFalse(\"Core should not be closed\", core.isClosed());\n        \n        // Sending jibberish as publish request\n        request = new LinkedHashMap<>();\n        request.put(\"publish\", \"jibberish\");\n        msg.object = request;\n        core.sendJMSMessage(msg);\n        assertFalse(\"Core should not be closed\", core.isClosed());\n    }", "signature": "void testIncorectPublishRequests()", "full_signature": "@Test public void testIncorectPublishRequests()", "class_method_signature": "TestJMSCore.testIncorectPublishRequests()", "testcase": true, "constructor": false, "invocations": ["put", "sendJMSMessage", "assertFalse", "isClosed", "put", "sendJMSMessage", "assertFalse", "isClosed"]}, "focal_class": {"identifier": "JMSCore", "superclass": "", "interfaces": "", "fields": [{"original_string": "String initialContextCheck = null;", "modifier": "", "type": "String", "declarator": "initialContextCheck = null", "var_name": "initialContextCheck"}, {"original_string": "String sourceName;", "modifier": "", "type": "String", "declarator": "sourceName", "var_name": "sourceName"}, {"original_string": "String authToken;", "modifier": "", "type": "String", "declarator": "authToken", "var_name": "authToken"}, {"original_string": "String targetVantiqServer;", "modifier": "", "type": "String", "declarator": "targetVantiqServer", "var_name": "targetVantiqServer"}, {"original_string": "JMSHandleConfiguration jmsConfigHandler;", "modifier": "", "type": "JMSHandleConfiguration", "declarator": "jmsConfigHandler", "var_name": "jmsConfigHandler"}, {"original_string": "ExtensionWebSocketClient client = null;", "modifier": "", "type": "ExtensionWebSocketClient", "declarator": "client = null", "var_name": "client"}, {"original_string": "JMS jms = null;", "modifier": "", "type": "JMS", "declarator": "jms = null", "var_name": "jms"}, {"original_string": "final Logger log;", "modifier": "final", "type": "Logger", "declarator": "log", "var_name": "log"}, {"original_string": "final static int RECONNECT_INTERVAL = 5000;", "modifier": "final static", "type": "int", "declarator": "RECONNECT_INTERVAL = 5000", "var_name": "RECONNECT_INTERVAL"}, {"original_string": "final static int CONNECTION_TIMEOUT = 10;", "modifier": "final static", "type": "int", "declarator": "CONNECTION_TIMEOUT = 10", "var_name": "CONNECTION_TIMEOUT"}, {"original_string": "private static final String SYNCH_LOCK = \"synchLock\";", "modifier": "private static final", "type": "String", "declarator": "SYNCH_LOCK = \"synchLock\"", "var_name": "SYNCH_LOCK"}, {"original_string": "public final Handler<ExtensionServiceMessage> reconnectHandler = new Handler<ExtensionServiceMessage>() {\n        @Override\n        public void handleMessage(ExtensionServiceMessage message) {\n            log.trace(\"Reconnect message received. Reinitializing configuration\");\n\n            jmsConfigHandler.configComplete = false;\n\n            CompletableFuture<Boolean> success = client.connectToSource();\n\n            try {\n                if ( !success.get(CONNECTION_TIMEOUT, TimeUnit.SECONDS) ) {\n                    if (!client.isOpen()) {\n                        log.error(\"Failed to connect to server url '\" + targetVantiqServer + \"'.\");\n                    } else if (!client.isAuthed()) {\n                        log.error(\"Failed to authenticate within 10 seconds using the given authentication data.\");\n                    } else {\n                        log.error(\"Failed to connect within 10 seconds\");\n                    }\n                    close();\n                }\n            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                log.error(\"Could not reconnect to source within 10 seconds: \", e);\n                close();\n            }\n        }\n    };", "modifier": "public final", "type": "Handler<ExtensionServiceMessage>", "declarator": "reconnectHandler = new Handler<ExtensionServiceMessage>() {\n        @Override\n        public void handleMessage(ExtensionServiceMessage message) {\n            log.trace(\"Reconnect message received. Reinitializing configuration\");\n\n            jmsConfigHandler.configComplete = false;\n\n            CompletableFuture<Boolean> success = client.connectToSource();\n\n            try {\n                if ( !success.get(CONNECTION_TIMEOUT, TimeUnit.SECONDS) ) {\n                    if (!client.isOpen()) {\n                        log.error(\"Failed to connect to server url '\" + targetVantiqServer + \"'.\");\n                    } else if (!client.isAuthed()) {\n                        log.error(\"Failed to authenticate within 10 seconds using the given authentication data.\");\n                    } else {\n                        log.error(\"Failed to connect within 10 seconds\");\n                    }\n                    close();\n                }\n            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                log.error(\"Could not reconnect to source within 10 seconds: \", e);\n                close();\n            }\n        }\n    }", "var_name": "reconnectHandler"}, {"original_string": "public final Handler<ExtensionWebSocketClient> closeHandler = new Handler<ExtensionWebSocketClient>() {\n        @Override\n        public void handleMessage(ExtensionWebSocketClient message) {\n            log.trace(\"WebSocket closed unexpectedly. Attempting to reconnect\");\n\n            jmsConfigHandler.configComplete = false;\n\n            boolean sourcesSucceeded = false;\n            while (!sourcesSucceeded) {\n                client.initiateFullConnection(targetVantiqServer, authToken);\n                sourcesSucceeded = exitIfConnectionFails(client, CONNECTION_TIMEOUT);\n                if (!sourcesSucceeded) {\n                    try {\n                        Thread.sleep(RECONNECT_INTERVAL);\n                    } catch (InterruptedException e) {\n                        log.error(\"An error occurred when trying to sleep the current thread. Error Message: \", e);\n                    }\n                }\n            }\n        }\n    };", "modifier": "public final", "type": "Handler<ExtensionWebSocketClient>", "declarator": "closeHandler = new Handler<ExtensionWebSocketClient>() {\n        @Override\n        public void handleMessage(ExtensionWebSocketClient message) {\n            log.trace(\"WebSocket closed unexpectedly. Attempting to reconnect\");\n\n            jmsConfigHandler.configComplete = false;\n\n            boolean sourcesSucceeded = false;\n            while (!sourcesSucceeded) {\n                client.initiateFullConnection(targetVantiqServer, authToken);\n                sourcesSucceeded = exitIfConnectionFails(client, CONNECTION_TIMEOUT);\n                if (!sourcesSucceeded) {\n                    try {\n                        Thread.sleep(RECONNECT_INTERVAL);\n                    } catch (InterruptedException e) {\n                        log.error(\"An error occurred when trying to sleep the current thread. Error Message: \", e);\n                    }\n                }\n            }\n        }\n    }", "var_name": "closeHandler"}], "methods": [{"identifier": "JMSCore", "parameters": "(String sourceName, String authToken, String targetVantiqServer)", "modifiers": "public", "return": "", "signature": " JMSCore(String sourceName, String authToken, String targetVantiqServer)", "full_signature": "public  JMSCore(String sourceName, String authToken, String targetVantiqServer)", "class_method_signature": "JMSCore.JMSCore(String sourceName, String authToken, String targetVantiqServer)", "testcase": false, "constructor": true}, {"identifier": "getSourceName", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getSourceName()", "full_signature": "public String getSourceName()", "class_method_signature": "JMSCore.getSourceName()", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "(int timeout)", "modifiers": "public", "return": "boolean", "signature": "boolean start(int timeout)", "full_signature": "public boolean start(int timeout)", "class_method_signature": "JMSCore.start(int timeout)", "testcase": false, "constructor": false}, {"identifier": "sendJMSMessage", "parameters": "(ExtensionServiceMessage message)", "modifiers": "public", "return": "void", "signature": "void sendJMSMessage(ExtensionServiceMessage message)", "full_signature": "public void sendJMSMessage(ExtensionServiceMessage message)", "class_method_signature": "JMSCore.sendJMSMessage(ExtensionServiceMessage message)", "testcase": false, "constructor": false}, {"identifier": "readQueueMessage", "parameters": "(ExtensionServiceMessage message)", "modifiers": "public", "return": "void", "signature": "void readQueueMessage(ExtensionServiceMessage message)", "full_signature": "public void readQueueMessage(ExtensionServiceMessage message)", "class_method_signature": "JMSCore.readQueueMessage(ExtensionServiceMessage message)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "JMSCore.close()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void stop()", "full_signature": "public void stop()", "class_method_signature": "JMSCore.stop()", "testcase": false, "constructor": false}, {"identifier": "exitIfConnectionFails", "parameters": "(ExtensionWebSocketClient client, int timeout)", "modifiers": "public", "return": "boolean", "signature": "boolean exitIfConnectionFails(ExtensionWebSocketClient client, int timeout)", "full_signature": "public boolean exitIfConnectionFails(ExtensionWebSocketClient client, int timeout)", "class_method_signature": "JMSCore.exitIfConnectionFails(ExtensionWebSocketClient client, int timeout)", "testcase": false, "constructor": false}], "file": "jmsSource/src/main/java/io/vantiq/extsrc/jmsSource/JMSCore.java"}, "focal_method": {"identifier": "sendJMSMessage", "parameters": "(ExtensionServiceMessage message)", "modifiers": "public", "return": "void", "body": "public void sendJMSMessage(ExtensionServiceMessage message) {\n        Map<String, ?> request = (Map<String, ?>) message.getObject();\n        Map<String, Object> messageMap = new LinkedHashMap<String, Object>();\n        \n        // Get local copy of JMS\n        JMS localJMS;\n        synchronized (SYNCH_LOCK) {\n            localJMS = jms;\n        }\n        \n        // Make sure JMS is safe to use (has not been closed)\n        if (localJMS == null) {\n            log.error(\"JMS connection closed before operation could complete\");\n        } else {\n            Map headers = null;\n            Map properties = null;\n            Object msg = null;\n            String dest;\n            boolean isQueue;\n            \n            // Getting the contents of the message if specified, or defaulting to an empty string\n            if (request.get(\"message\") instanceof String) {\n                msg = (String) request.get(\"message\");\n            } else if (request.get(\"message\") instanceof Map) {\n                msg = (Map) request.get(\"message\");\n            } else {\n                log.debug(\"No message was specified in the publish request, or the message was not a String/Map. \"\n                        + \"The message was set to its default value, null.\");\n            }\n                \n            // Getting the destination of the message\n            if (request.get(\"queue\") instanceof String) {\n                dest = (String) request.get(\"queue\");\n                isQueue = true;\n            } else if (request.get(\"topic\") instanceof String) {\n                dest = (String) request.get(\"topic\");\n                isQueue = false;\n            } else {\n                log.error(\"No destination was specified, or destination was not a String. Either a topic \"\n                        + \"or a queue must be included as a String in the publish request.\");\n                return;\n            }\n                        \n            // Getting the message headers if specified\n            if (request.get(\"headers\") instanceof Map) {\n                headers = (Map) request.get(\"headers\");\n            }\n            \n            // Getting the message properties if specified\n            if (request.get(\"properties\") instanceof Map) {\n                properties = (Map) request.get(\"properties\");\n            }\n            \n            messageMap.put(\"message\", msg);\n            messageMap.put(\"headers\", headers);\n            messageMap.put(\"properties\", properties);\n            \n            // Sending the message to the appropriate destination\n            try {\n                localJMS.produceMessage(messageMap, dest, isQueue);\n            } catch (JMSException e) {\n                log.error(\"An error occured when attempting to send the given message.\", e);\n            } catch (DestinationNotConfiguredException e) {\n                log.error(\"An error occured when attempting to send the given message. The source was not configured \"\n                        + \"to send messages to the following destination: \" + dest + \".\", e);\n            } catch(UnsupportedJMSMessageTypeException e) {\n                log.error(\"An error occured when attempting to send the given message. The provided JMS Message Type: \"\n                        + e.getMessage() + \" is either invalid or not currently supported.\");\n            } catch (Exception e) {\n                log.error(\"An unexpected error occured when attempting to send the given message.\", e);\n            }\n        }\n    }", "signature": "void sendJMSMessage(ExtensionServiceMessage message)", "full_signature": "public void sendJMSMessage(ExtensionServiceMessage message)", "class_method_signature": "JMSCore.sendJMSMessage(ExtensionServiceMessage message)", "testcase": false, "constructor": false, "invocations": ["getObject", "error", "get", "get", "get", "get", "debug", "get", "get", "get", "get", "error", "get", "get", "get", "get", "put", "put", "put", "produceMessage", "error", "error", "error", "getMessage", "error"]}, "repository": {"repo_id": 141492069, "url": "https://github.com/Vantiq/vantiq-extension-sources", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 9, "size": 16261, "license": "licensed"}}