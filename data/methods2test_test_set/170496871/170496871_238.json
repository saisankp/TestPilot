{"test_class": {"identifier": "ImputerTrainerTest", "superclass": "extends TrainerTest", "interfaces": "", "fields": [], "file": "modules/ml/src/test/java/org/apache/ignite/ml/preprocessing/imputing/ImputerTrainerTest.java"}, "test_case": {"identifier": "testFit", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testFit() {\n        Map<Integer, Vector> data = new HashMap<>();\n        data.put(1, VectorUtils.of(1, 2, Double.NaN));\n        data.put(2, VectorUtils.of(1, Double.NaN, 22));\n        data.put(3, VectorUtils.of(Double.NaN, 10, 100));\n        data.put(4, VectorUtils.of(0, 2, 100));\n\n        DatasetBuilder<Integer, Vector> datasetBuilder = new LocalDatasetBuilder<>(data, parts);\n\n        final Vectorizer<Integer, Vector, Integer, Double> vectorizer = new DummyVectorizer<>(0, 1, 2);\n\n        ImputerTrainer<Integer, Vector> imputerTrainer = new ImputerTrainer<Integer, Vector>()\n            .withImputingStrategy(ImputingStrategy.MOST_FREQUENT);\n\n        ImputerPreprocessor<Integer, Vector> preprocessor = imputerTrainer.fit(\n            TestUtils.testEnvBuilder(),\n            datasetBuilder,\n            vectorizer\n        );\n\n        assertArrayEquals(new double[] {1, 0, 100}, preprocessor.apply(5, VectorUtils.of(Double.NaN, 0, Double.NaN)).features().asArray(), 1e-8);\n    }", "signature": "void testFit()", "full_signature": "@Test public void testFit()", "class_method_signature": "ImputerTrainerTest.testFit()", "testcase": true, "constructor": false, "invocations": ["put", "of", "put", "of", "put", "of", "put", "of", "withImputingStrategy", "fit", "testEnvBuilder", "assertArrayEquals", "asArray", "features", "apply", "of"]}, "focal_class": {"identifier": "ImputerTrainer", "superclass": "", "interfaces": "implements PreprocessingTrainer<K, V>", "fields": [{"original_string": "private ImputingStrategy imputingStgy = ImputingStrategy.MEAN;", "modifier": "private", "type": "ImputingStrategy", "declarator": "imputingStgy = ImputingStrategy.MEAN", "var_name": "imputingStgy"}], "methods": [{"identifier": "fit", "parameters": "(LearningEnvironmentBuilder envBuilder, DatasetBuilder<K, V> datasetBuilder,\n                                                   Preprocessor<K, V> basePreprocessor)", "modifiers": "@Override public", "return": "ImputerPreprocessor<K, V>", "signature": "ImputerPreprocessor<K, V> fit(LearningEnvironmentBuilder envBuilder, DatasetBuilder<K, V> datasetBuilder,\n                                                   Preprocessor<K, V> basePreprocessor)", "full_signature": "@Override public ImputerPreprocessor<K, V> fit(LearningEnvironmentBuilder envBuilder, DatasetBuilder<K, V> datasetBuilder,\n                                                   Preprocessor<K, V> basePreprocessor)", "class_method_signature": "ImputerTrainer.fit(LearningEnvironmentBuilder envBuilder, DatasetBuilder<K, V> datasetBuilder,\n                                                   Preprocessor<K, V> basePreprocessor)", "testcase": false, "constructor": false}, {"identifier": "calculateImputingValuesByFrequencies", "parameters": "(\n        Dataset<EmptyContext, ImputerPartitionData> dataset)", "modifiers": "private", "return": "double[]", "signature": "double[] calculateImputingValuesByFrequencies(\n        Dataset<EmptyContext, ImputerPartitionData> dataset)", "full_signature": "private double[] calculateImputingValuesByFrequencies(\n        Dataset<EmptyContext, ImputerPartitionData> dataset)", "class_method_signature": "ImputerTrainer.calculateImputingValuesByFrequencies(\n        Dataset<EmptyContext, ImputerPartitionData> dataset)", "testcase": false, "constructor": false}, {"identifier": "calculateImputingValuesBySumsAndCounts", "parameters": "(Dataset<EmptyContext, ImputerPartitionData> dataset)", "modifiers": "private", "return": "double[]", "signature": "double[] calculateImputingValuesBySumsAndCounts(Dataset<EmptyContext, ImputerPartitionData> dataset)", "full_signature": "private double[] calculateImputingValuesBySumsAndCounts(Dataset<EmptyContext, ImputerPartitionData> dataset)", "class_method_signature": "ImputerTrainer.calculateImputingValuesBySumsAndCounts(Dataset<EmptyContext, ImputerPartitionData> dataset)", "testcase": false, "constructor": false}, {"identifier": "calculateFrequencies", "parameters": "(LabeledVector row, Map<Double, Integer>[] valuesByFreq)", "modifiers": "private", "return": "Map<Double, Integer>[]", "signature": "Map<Double, Integer>[] calculateFrequencies(LabeledVector row, Map<Double, Integer>[] valuesByFreq)", "full_signature": "private Map<Double, Integer>[] calculateFrequencies(LabeledVector row, Map<Double, Integer>[] valuesByFreq)", "class_method_signature": "ImputerTrainer.calculateFrequencies(LabeledVector row, Map<Double, Integer>[] valuesByFreq)", "testcase": false, "constructor": false}, {"identifier": "calculateTheSums", "parameters": "(LabeledVector row, double[] sums)", "modifiers": "private", "return": "double[]", "signature": "double[] calculateTheSums(LabeledVector row, double[] sums)", "full_signature": "private double[] calculateTheSums(LabeledVector row, double[] sums)", "class_method_signature": "ImputerTrainer.calculateTheSums(LabeledVector row, double[] sums)", "testcase": false, "constructor": false}, {"identifier": "calculateTheCounts", "parameters": "(LabeledVector row, int[] counts)", "modifiers": "private", "return": "int[]", "signature": "int[] calculateTheCounts(LabeledVector row, int[] counts)", "full_signature": "private int[] calculateTheCounts(LabeledVector row, int[] counts)", "class_method_signature": "ImputerTrainer.calculateTheCounts(LabeledVector row, int[] counts)", "testcase": false, "constructor": false}, {"identifier": "withImputingStrategy", "parameters": "(ImputingStrategy imputingStgy)", "modifiers": "public", "return": "ImputerTrainer<K, V>", "signature": "ImputerTrainer<K, V> withImputingStrategy(ImputingStrategy imputingStgy)", "full_signature": "public ImputerTrainer<K, V> withImputingStrategy(ImputingStrategy imputingStgy)", "class_method_signature": "ImputerTrainer.withImputingStrategy(ImputingStrategy imputingStgy)", "testcase": false, "constructor": false}], "file": "modules/ml/src/main/java/org/apache/ignite/ml/preprocessing/imputing/ImputerTrainer.java"}, "focal_method": {"identifier": "fit", "parameters": "(LearningEnvironmentBuilder envBuilder, DatasetBuilder<K, V> datasetBuilder,\n                                                   Preprocessor<K, V> basePreprocessor)", "modifiers": "@Override public", "return": "ImputerPreprocessor<K, V>", "body": "@Override public ImputerPreprocessor<K, V> fit(LearningEnvironmentBuilder envBuilder, DatasetBuilder<K, V> datasetBuilder,\n                                                   Preprocessor<K, V> basePreprocessor) {\n        PartitionContextBuilder<K, V, EmptyContext> builder = (env, upstream, upstreamSize) -> new EmptyContext();\n        try (Dataset<EmptyContext, ImputerPartitionData> dataset = datasetBuilder.build(\n            envBuilder,\n            builder,\n            (env, upstream, upstreamSize, ctx) -> {\n                double[] sums = null;\n                int[] counts = null;\n                Map<Double, Integer>[] valuesByFreq = null;\n\n                while (upstream.hasNext()) {\n                    UpstreamEntry<K, V> entity = upstream.next();\n                    LabeledVector row = basePreprocessor.apply(entity.getKey(), entity.getValue());\n\n                    switch (imputingStgy) {\n                        case MEAN:\n                            sums = calculateTheSums(row, sums);\n                            counts = calculateTheCounts(row, counts);\n                            break;\n                        case MOST_FREQUENT:\n                            valuesByFreq = calculateFrequencies(row, valuesByFreq);\n                            break;\n                        default: throw new UnsupportedOperationException(\"The chosen strategy is not supported\");\n                    }\n                }\n\n                ImputerPartitionData partData;\n\n                switch (imputingStgy) {\n                    case MEAN:\n                        partData = new ImputerPartitionData().withSums(sums).withCounts(counts);\n                        break;\n                    case MOST_FREQUENT:\n                        partData = new ImputerPartitionData().withValuesByFrequency(valuesByFreq);\n                        break;\n                    default: throw new UnsupportedOperationException(\"The chosen strategy is not supported\");\n                }\n                return partData;\n            }, learningEnvironment(basePreprocessor)\n        )) {\n\n            Vector imputingValues;\n\n            switch (imputingStgy) {\n                case MEAN:\n                    imputingValues = VectorUtils.of(calculateImputingValuesBySumsAndCounts(dataset));\n                    break;\n                case MOST_FREQUENT:\n                    imputingValues = VectorUtils.of(calculateImputingValuesByFrequencies(dataset));\n                    break;\n                default: throw new UnsupportedOperationException(\"The chosen strategy is not supported\");\n            }\n\n            return new ImputerPreprocessor<>(imputingValues, basePreprocessor);\n\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "signature": "ImputerPreprocessor<K, V> fit(LearningEnvironmentBuilder envBuilder, DatasetBuilder<K, V> datasetBuilder,\n                                                   Preprocessor<K, V> basePreprocessor)", "full_signature": "@Override public ImputerPreprocessor<K, V> fit(LearningEnvironmentBuilder envBuilder, DatasetBuilder<K, V> datasetBuilder,\n                                                   Preprocessor<K, V> basePreprocessor)", "class_method_signature": "ImputerTrainer.fit(LearningEnvironmentBuilder envBuilder, DatasetBuilder<K, V> datasetBuilder,\n                                                   Preprocessor<K, V> basePreprocessor)", "testcase": false, "constructor": false, "invocations": ["build", "hasNext", "next", "apply", "getKey", "getValue", "calculateTheSums", "calculateTheCounts", "calculateFrequencies", "withCounts", "withSums", "withValuesByFrequency", "learningEnvironment", "of", "calculateImputingValuesBySumsAndCounts", "of", "calculateImputingValuesByFrequencies"]}, "repository": {"repo_id": 170496871, "url": "https://github.com/gridgain/gridgain", "stars": 46, "created": "2/13/2019 11:31:35 AM +00:00", "updates": "2020-01-27T16:02:24+00:00", "fork": "False", "license": "licensed"}}