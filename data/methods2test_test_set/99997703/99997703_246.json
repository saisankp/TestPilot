{"test_class": {"identifier": "ImmutableMapFactoryTest", "superclass": "", "interfaces": "", "fields": [], "file": "OcavaCore/src/test/java/com/ocadotechnology/utils/ImmutableMapFactoryTest.java"}, "test_case": {"identifier": "zipThrowsForDifferentSizesLists", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n    void zipThrowsForDifferentSizesLists() {\n        ImmutableList<String> tooManyKeys = ImmutableList.of(\"a\", \"b\", \"c\");\n        ImmutableList<Integer> notEnoughValues = ImmutableList.of(1, 2);\n\n        Assertions.assertThrows(\n                IllegalArgumentException.class,\n                () -> ImmutableMapFactory.zip(tooManyKeys, notEnoughValues));\n    }", "signature": "void zipThrowsForDifferentSizesLists()", "full_signature": "@Test void zipThrowsForDifferentSizesLists()", "class_method_signature": "ImmutableMapFactoryTest.zipThrowsForDifferentSizesLists()", "testcase": true, "constructor": false, "invocations": ["of", "of", "assertThrows", "zip"]}, "focal_class": {"identifier": "ImmutableMapFactory", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "create", "parameters": "(\n            Map<K, V> baseMap,\n            BiFunction<? super K, ? super V, ? extends L> keyCreator,\n            BiFunction<? super K, ? super V, ? extends W> valueCreator)", "modifiers": "public static", "return": "ImmutableMap<L, W>", "signature": "ImmutableMap<L, W> create(\n            Map<K, V> baseMap,\n            BiFunction<? super K, ? super V, ? extends L> keyCreator,\n            BiFunction<? super K, ? super V, ? extends W> valueCreator)", "full_signature": "public static ImmutableMap<L, W> create(\n            Map<K, V> baseMap,\n            BiFunction<? super K, ? super V, ? extends L> keyCreator,\n            BiFunction<? super K, ? super V, ? extends W> valueCreator)", "class_method_signature": "ImmutableMapFactory.create(\n            Map<K, V> baseMap,\n            BiFunction<? super K, ? super V, ? extends L> keyCreator,\n            BiFunction<? super K, ? super V, ? extends W> valueCreator)", "testcase": false, "constructor": false}, {"identifier": "create", "parameters": "(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper,\n            Function<? super V, ? extends W> valueMapper)", "modifiers": "public static", "return": "ImmutableMap<L, W>", "signature": "ImmutableMap<L, W> create(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper,\n            Function<? super V, ? extends W> valueMapper)", "full_signature": "public static ImmutableMap<L, W> create(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper,\n            Function<? super V, ? extends W> valueMapper)", "class_method_signature": "ImmutableMapFactory.create(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper,\n            Function<? super V, ? extends W> valueMapper)", "testcase": false, "constructor": false}, {"identifier": "createAndReduceCollisions", "parameters": "(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper,\n            Function<? super V, ? extends W> valueMapper,\n            W valueIdentity,\n            BinaryOperator<W> collidingKeysAccumulator)", "modifiers": "public static", "return": "ImmutableMap<L, W>", "signature": "ImmutableMap<L, W> createAndReduceCollisions(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper,\n            Function<? super V, ? extends W> valueMapper,\n            W valueIdentity,\n            BinaryOperator<W> collidingKeysAccumulator)", "full_signature": "public static ImmutableMap<L, W> createAndReduceCollisions(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper,\n            Function<? super V, ? extends W> valueMapper,\n            W valueIdentity,\n            BinaryOperator<W> collidingKeysAccumulator)", "class_method_signature": "ImmutableMapFactory.createAndReduceCollisions(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper,\n            Function<? super V, ? extends W> valueMapper,\n            W valueIdentity,\n            BinaryOperator<W> collidingKeysAccumulator)", "testcase": false, "constructor": false}, {"identifier": "createWithNewKeys", "parameters": "(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper)", "modifiers": "public static", "return": "ImmutableMap<L, V>", "signature": "ImmutableMap<L, V> createWithNewKeys(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper)", "full_signature": "public static ImmutableMap<L, V> createWithNewKeys(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper)", "class_method_signature": "ImmutableMapFactory.createWithNewKeys(\n            Map<K, V> baseMap,\n            Function<? super K, ? extends L> keyMapper)", "testcase": false, "constructor": false}, {"identifier": "createWithNewValues", "parameters": "(\n            Map<K, V> baseMap,\n            Function<? super V, ? extends W> valueMapper)", "modifiers": "public static", "return": "ImmutableMap<K, W>", "signature": "ImmutableMap<K, W> createWithNewValues(\n            Map<K, V> baseMap,\n            Function<? super V, ? extends W> valueMapper)", "full_signature": "public static ImmutableMap<K, W> createWithNewValues(\n            Map<K, V> baseMap,\n            Function<? super V, ? extends W> valueMapper)", "class_method_signature": "ImmutableMapFactory.createWithNewValues(\n            Map<K, V> baseMap,\n            Function<? super V, ? extends W> valueMapper)", "testcase": false, "constructor": false}, {"identifier": "createWithNewValues", "parameters": "(\n            Map<K, V> baseMap,\n            BiFunction<? super K, ? super V, ? extends W> valueMapper)", "modifiers": "public static", "return": "ImmutableMap<K, W>", "signature": "ImmutableMap<K, W> createWithNewValues(\n            Map<K, V> baseMap,\n            BiFunction<? super K, ? super V, ? extends W> valueMapper)", "full_signature": "public static ImmutableMap<K, W> createWithNewValues(\n            Map<K, V> baseMap,\n            BiFunction<? super K, ? super V, ? extends W> valueMapper)", "class_method_signature": "ImmutableMapFactory.createWithNewValues(\n            Map<K, V> baseMap,\n            BiFunction<? super K, ? super V, ? extends W> valueMapper)", "testcase": false, "constructor": false}, {"identifier": "createFromKeys", "parameters": "(\n            Collection<K> keys,\n            Supplier<V> valueSupplier)", "modifiers": "public static", "return": "ImmutableMap<K, V>", "signature": "ImmutableMap<K, V> createFromKeys(\n            Collection<K> keys,\n            Supplier<V> valueSupplier)", "full_signature": "public static ImmutableMap<K, V> createFromKeys(\n            Collection<K> keys,\n            Supplier<V> valueSupplier)", "class_method_signature": "ImmutableMapFactory.createFromKeys(\n            Collection<K> keys,\n            Supplier<V> valueSupplier)", "testcase": false, "constructor": false}, {"identifier": "createFromKeys", "parameters": "(\n            Collection<K> keys,\n            Function<K, V> valueCreator)", "modifiers": "public static", "return": "ImmutableMap<K, V>", "signature": "ImmutableMap<K, V> createFromKeys(\n            Collection<K> keys,\n            Function<K, V> valueCreator)", "full_signature": "public static ImmutableMap<K, V> createFromKeys(\n            Collection<K> keys,\n            Function<K, V> valueCreator)", "class_method_signature": "ImmutableMapFactory.createFromKeys(\n            Collection<K> keys,\n            Function<K, V> valueCreator)", "testcase": false, "constructor": false}, {"identifier": "zip", "parameters": "(\n            List<K> keys,\n            List<V> values)", "modifiers": "public static", "return": "ImmutableMap<K, V>", "signature": "ImmutableMap<K, V> zip(\n            List<K> keys,\n            List<V> values)", "full_signature": "public static ImmutableMap<K, V> zip(\n            List<K> keys,\n            List<V> values)", "class_method_signature": "ImmutableMapFactory.zip(\n            List<K> keys,\n            List<V> values)", "testcase": false, "constructor": false}, {"identifier": "filter", "parameters": "(\n            Map<K, V> baseMap,\n            BiPredicate<K, V> filter)", "modifiers": "public static", "return": "ImmutableMap<K, V>", "signature": "ImmutableMap<K, V> filter(\n            Map<K, V> baseMap,\n            BiPredicate<K, V> filter)", "full_signature": "public static ImmutableMap<K, V> filter(\n            Map<K, V> baseMap,\n            BiPredicate<K, V> filter)", "class_method_signature": "ImmutableMapFactory.filter(\n            Map<K, V> baseMap,\n            BiPredicate<K, V> filter)", "testcase": false, "constructor": false}, {"identifier": "filterByKeys", "parameters": "(\n            Map<K, V> baseMap,\n            Predicate<K> keyFilter)", "modifiers": "public static", "return": "ImmutableMap<K, V>", "signature": "ImmutableMap<K, V> filterByKeys(\n            Map<K, V> baseMap,\n            Predicate<K> keyFilter)", "full_signature": "public static ImmutableMap<K, V> filterByKeys(\n            Map<K, V> baseMap,\n            Predicate<K> keyFilter)", "class_method_signature": "ImmutableMapFactory.filterByKeys(\n            Map<K, V> baseMap,\n            Predicate<K> keyFilter)", "testcase": false, "constructor": false}, {"identifier": "filterByValues", "parameters": "(\n            Map<K, V> baseMap,\n            Predicate<V> valueFilter)", "modifiers": "public static", "return": "ImmutableMap<K, V>", "signature": "ImmutableMap<K, V> filterByValues(\n            Map<K, V> baseMap,\n            Predicate<V> valueFilter)", "full_signature": "public static ImmutableMap<K, V> filterByValues(\n            Map<K, V> baseMap,\n            Predicate<V> valueFilter)", "class_method_signature": "ImmutableMapFactory.filterByValues(\n            Map<K, V> baseMap,\n            Predicate<V> valueFilter)", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "(\n            String s,\n            Function<String, K> keyParser,\n            Function<String, V> valueParser)", "modifiers": "public static", "return": "ImmutableMap<K, V>", "signature": "ImmutableMap<K, V> parse(\n            String s,\n            Function<String, K> keyParser,\n            Function<String, V> valueParser)", "full_signature": "public static ImmutableMap<K, V> parse(\n            String s,\n            Function<String, K> keyParser,\n            Function<String, V> valueParser)", "class_method_signature": "ImmutableMapFactory.parse(\n            String s,\n            Function<String, K> keyParser,\n            Function<String, V> valueParser)", "testcase": false, "constructor": false}, {"identifier": "parseAndFilter", "parameters": "(\n            String s,\n            Function<String, K> keyParser,\n            Function<String, V> valueParser,\n            BiPredicate<K, V> filter)", "modifiers": "public static", "return": "ImmutableMap<K, V>", "signature": "ImmutableMap<K, V> parseAndFilter(\n            String s,\n            Function<String, K> keyParser,\n            Function<String, V> valueParser,\n            BiPredicate<K, V> filter)", "full_signature": "public static ImmutableMap<K, V> parseAndFilter(\n            String s,\n            Function<String, K> keyParser,\n            Function<String, V> valueParser,\n            BiPredicate<K, V> filter)", "class_method_signature": "ImmutableMapFactory.parseAndFilter(\n            String s,\n            Function<String, K> keyParser,\n            Function<String, V> valueParser,\n            BiPredicate<K, V> filter)", "testcase": false, "constructor": false}], "file": "OcavaCore/src/main/java/com/ocadotechnology/utils/ImmutableMapFactory.java"}, "focal_method": {"identifier": "zip", "parameters": "(\n            List<K> keys,\n            List<V> values)", "modifiers": "public static", "return": "ImmutableMap<K, V>", "body": "public static <K, V> ImmutableMap<K, V> zip(\n            List<K> keys,\n            List<V> values) {\n        Preconditions.checkArgument(\n                keys.size() == values.size(),\n                \"Size of keys and values should match\");\n        return ImmutableMapFactory.createFromKeys(keys, values.iterator()::next);\n    }", "signature": "ImmutableMap<K, V> zip(\n            List<K> keys,\n            List<V> values)", "full_signature": "public static ImmutableMap<K, V> zip(\n            List<K> keys,\n            List<V> values)", "class_method_signature": "ImmutableMapFactory.zip(\n            List<K> keys,\n            List<V> values)", "testcase": false, "constructor": false, "invocations": ["checkArgument", "size", "size", "createFromKeys", "iterator"]}, "repository": {"repo_id": 99997703, "url": "https://github.com/ocadotechnology/Ocava", "language": "Java", "is_fork": false, "fork_count": 4, "stargazer_count": 16, "size": 1137, "license": "licensed"}}