{"test_class": {"identifier": "UtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "httpdlog/httpdlog-parser/src/test/java/nl/basjes/parse/httpdlog/UtilsTest.java"}, "test_case": {"identifier": "testUrlDecoder", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testUrlDecoder() {\n        // Normal cases\n        assertEquals(\"  \", resilientUrlDecode(\"  \"));\n        assertEquals(\"  \", resilientUrlDecode(\" %20\"));\n        assertEquals(\"  \", resilientUrlDecode(\"%20 \"));\n        assertEquals(\"  \", resilientUrlDecode(\"%20%20\"));\n        assertEquals(\"  \", resilientUrlDecode(\"%u0020%u0020\"));\n        assertEquals(\"  \", resilientUrlDecode(\"%20%u0020\"));\n        assertEquals(\"  \", resilientUrlDecode(\"%u0020%20\"));\n\n        // Deformed characters at the end of the line (desired is they are discarded)\n        assertEquals(\"x \", resilientUrlDecode(\"x %2\"));\n        assertEquals(\"x \", resilientUrlDecode(\"x%20%2\"));\n        assertEquals(\"x 2\", resilientUrlDecode(\"x%u202\"));\n        assertEquals(\"x \", resilientUrlDecode(\"x%u20\"));\n        assertEquals(\"x\", resilientUrlDecode(\"x%u2\"));\n        assertEquals(\"x\", resilientUrlDecode(\"x%u\"));\n        assertEquals(\"x\", resilientUrlDecode(\"x%\"));\n\n        // Combined test case (7 spaces and a chopped one)\n        assertEquals(\"       \", resilientUrlDecode(\"%20 %20%u0020%20 %20%2\"));\n    }", "signature": "void testUrlDecoder()", "full_signature": "@Test public void testUrlDecoder()", "class_method_signature": "UtilsTest.testUrlDecoder()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode", "assertEquals", "resilientUrlDecode"]}, "focal_class": {"identifier": "Utils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Pattern CHOPPED_STANDARD       = Pattern.compile(\"%[0-9A-Fa-f]?$\");", "modifier": "private static final", "type": "Pattern", "declarator": "CHOPPED_STANDARD       = Pattern.compile(\"%[0-9A-Fa-f]?$\")", "var_name": "CHOPPED_STANDARD"}, {"original_string": "private static final Pattern VALID_NON_STANDARD     = Pattern.compile(\"%u([0-9A-Fa-f][0-9A-Fa-f])+\");", "modifier": "private static final", "type": "Pattern", "declarator": "VALID_NON_STANDARD     = Pattern.compile(\"%u([0-9A-Fa-f][0-9A-Fa-f])+\")", "var_name": "VALID_NON_STANDARD"}, {"original_string": "private static final Pattern CHOPPED_NON_STANDARD   = Pattern.compile(\"%u[0-9A-Fa-f]{0,3}$\");", "modifier": "private static final", "type": "Pattern", "declarator": "CHOPPED_NON_STANDARD   = Pattern.compile(\"%u[0-9A-Fa-f]{0,3}$\")", "var_name": "CHOPPED_NON_STANDARD"}, {"original_string": "private static final Map<String, String> HTML_ENTITY_REPLACE_MAP;", "modifier": "private static final", "type": "Map<String, String>", "declarator": "HTML_ENTITY_REPLACE_MAP", "var_name": "HTML_ENTITY_REPLACE_MAP"}], "methods": [{"identifier": "Utils", "parameters": "()", "modifiers": "private", "return": "", "signature": " Utils()", "full_signature": "private  Utils()", "class_method_signature": "Utils.Utils()", "testcase": false, "constructor": true}, {"identifier": "resilientUrlDecode", "parameters": "(String input)", "modifiers": "public static", "return": "String", "signature": "String resilientUrlDecode(String input)", "full_signature": "public static String resilientUrlDecode(String input)", "class_method_signature": "Utils.resilientUrlDecode(String input)", "testcase": false, "constructor": false}, {"identifier": "hexCharsToByte", "parameters": "(String twoHexDigits)", "modifiers": "public static", "return": "byte", "signature": "byte hexCharsToByte(String twoHexDigits)", "full_signature": "public static byte hexCharsToByte(String twoHexDigits)", "class_method_signature": "Utils.hexCharsToByte(String twoHexDigits)", "testcase": false, "constructor": false}, {"identifier": "hexCharsToByte", "parameters": "(char c1, char c2)", "modifiers": "public static", "return": "byte", "signature": "byte hexCharsToByte(char c1, char c2)", "full_signature": "public static byte hexCharsToByte(char c1, char c2)", "class_method_signature": "Utils.hexCharsToByte(char c1, char c2)", "testcase": false, "constructor": false}, {"identifier": "decodeApacheHTTPDLogValue", "parameters": "(String input)", "modifiers": "public static", "return": "String", "signature": "String decodeApacheHTTPDLogValue(String input)", "full_signature": "public static String decodeApacheHTTPDLogValue(String input)", "class_method_signature": "Utils.decodeApacheHTTPDLogValue(String input)", "testcase": false, "constructor": false}, {"identifier": "htmlEntityToURLEncoded", "parameters": "(String entity)", "modifiers": "private static", "return": "String", "signature": "String htmlEntityToURLEncoded(String entity)", "full_signature": "private static String htmlEntityToURLEncoded(String entity)", "class_method_signature": "Utils.htmlEntityToURLEncoded(String entity)", "testcase": false, "constructor": false}, {"identifier": "makeHTMLEncodedInert", "parameters": "(String uriString)", "modifiers": "public static", "return": "String", "signature": "String makeHTMLEncodedInert(String uriString)", "full_signature": "public static String makeHTMLEncodedInert(String uriString)", "class_method_signature": "Utils.makeHTMLEncodedInert(String uriString)", "testcase": false, "constructor": false}, {"identifier": "replaceString", "parameters": "(\n        final String input,\n        final String searchFor,\n        final String replaceWith\n    )", "modifiers": "public static", "return": "String", "signature": "String replaceString(\n        final String input,\n        final String searchFor,\n        final String replaceWith\n    )", "full_signature": "public static String replaceString(\n        final String input,\n        final String searchFor,\n        final String replaceWith\n    )", "class_method_signature": "Utils.replaceString(\n        final String input,\n        final String searchFor,\n        final String replaceWith\n    )", "testcase": false, "constructor": false}], "file": "httpdlog/httpdlog-parser/src/main/java/nl/basjes/parse/httpdlog/Utils.java"}, "focal_method": {"identifier": "resilientUrlDecode", "parameters": "(String input)", "modifiers": "public static", "return": "String", "body": "public static String resilientUrlDecode(String input) {\n        String cookedInput = input;\n\n        if (cookedInput.indexOf('%') > -1) {\n            // Discard chopped encoded char at the end of the line (there is no way to know what it was)\n            cookedInput = CHOPPED_STANDARD.matcher(cookedInput).replaceAll(\"\");\n\n            // Handle non standard (rejected by W3C) encoding that is used anyway by some\n            // See: https://stackoverflow.com/a/5408655/114196\n            if (cookedInput.contains(\"%u\")) {\n                cookedInput = replaceString(cookedInput, \"%u00\", \"%u\");\n\n                // Transform all existing non standard into UTF-8 standard.\n                cookedInput = VALID_NON_STANDARD.matcher(cookedInput).replaceAll(\"%$1\");\n\n                // Discard chopped encoded char at the end of the line\n                cookedInput = CHOPPED_NON_STANDARD.matcher(cookedInput).replaceAll(\"\");\n            }\n        }\n\n        try {\n            return URLDecoder.decode(cookedInput, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            // Will never happen because the encoding is hardcoded\n            return null;\n        }\n    }", "signature": "String resilientUrlDecode(String input)", "full_signature": "public static String resilientUrlDecode(String input)", "class_method_signature": "Utils.resilientUrlDecode(String input)", "testcase": false, "constructor": false, "invocations": ["indexOf", "replaceAll", "matcher", "contains", "replaceString", "replaceAll", "matcher", "replaceAll", "matcher", "decode"]}, "repository": {"repo_id": 12652963, "url": "https://github.com/nielsbasjes/logparser", "language": "Java", "is_fork": false, "fork_count": 29, "stargazer_count": 94, "size": 2121, "license": "licensed"}}