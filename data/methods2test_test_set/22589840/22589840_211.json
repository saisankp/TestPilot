{"test_class": {"identifier": "UserActivityLoggerImplTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ActivityLoggingDao activityLoggingDaoMock;", "modifier": "private", "type": "ActivityLoggingDao", "declarator": "activityLoggingDaoMock", "var_name": "activityLoggingDaoMock"}, {"original_string": "private UserSession userSessionMock;", "modifier": "private", "type": "UserSession", "declarator": "userSessionMock", "var_name": "userSessionMock"}, {"original_string": "private ILoggingAction defaultLoggingActionMock;", "modifier": "private", "type": "ILoggingAction", "declarator": "defaultLoggingActionMock", "var_name": "defaultLoggingActionMock"}, {"original_string": "private Set<String> userProperties;", "modifier": "private", "type": "Set<String>", "declarator": "userProperties", "var_name": "userProperties"}, {"original_string": "private I18nManager i18nManagerMock;", "modifier": "private", "type": "I18nManager", "declarator": "i18nManagerMock", "var_name": "i18nManagerMock"}, {"original_string": "private String LocaleKey = \"de\";", "modifier": "private", "type": "String", "declarator": "LocaleKey = \"de\"", "var_name": "LocaleKey"}, {"original_string": "private String testUserName = \"test-user\";", "modifier": "private", "type": "String", "declarator": "testUserName = \"test-user\"", "var_name": "testUserName"}], "file": "olat7.8/src/test/java/org/olat/lms/activitylogging/UserActivityLoggerImplTest.java"}, "test_case": {"identifier": "testLog_NoAnonymousLoggingForActionTypeAdmin", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testLog_NoAnonymousLoggingForActionTypeAdmin() {\n        IUserActivityLogger userActivityLogger = createUserActivityLogger(userSessionMock, true);\n        ILoggingAction loginAction = createLoggingActionMock(ActionType.admin);\n        when(loginAction.getActionObject()).thenReturn(\"test\");\n\n        ReturnValue<LoggingObject> returnValue = userActivityLogger.log(loginAction, this.getClass(), null);\n        verify(activityLoggingDaoMock).saveLogObject(returnValue.getValue());\n        assertNotNull(\"Missing logging, no log-object created\", returnValue.getValue());\n        assertEquals(\"Logging must have username '\" + testUserName + \"' because it is anonymus but ActionType=admin\", testUserName, returnValue.getValue().getUserName());\n    }", "signature": "void testLog_NoAnonymousLoggingForActionTypeAdmin()", "full_signature": "@Test public void testLog_NoAnonymousLoggingForActionTypeAdmin()", "class_method_signature": "UserActivityLoggerImplTest.testLog_NoAnonymousLoggingForActionTypeAdmin()", "testcase": true, "constructor": false, "invocations": ["createUserActivityLogger", "createLoggingActionMock", "thenReturn", "when", "getActionObject", "log", "getClass", "saveLogObject", "verify", "getValue", "assertNotNull", "getValue", "assertEquals", "getUserName", "getValue"]}, "focal_class": {"identifier": "UserActivityLoggerImpl", "superclass": "", "interfaces": "implements IUserActivityLogger", "fields": [{"original_string": "private static final Logger log = LoggerHelper.getLogger();", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerHelper.getLogger()", "var_name": "log"}, {"original_string": "public static final String USESS_KEY_USER_ACTIVITY_LOGGING_LAST_LOG = \"USER_ACTIVITY_LOGGING_LAST_LOG\";", "modifier": "public static final", "type": "String", "declarator": "USESS_KEY_USER_ACTIVITY_LOGGING_LAST_LOG = \"USER_ACTIVITY_LOGGING_LAST_LOG\"", "var_name": "USESS_KEY_USER_ACTIVITY_LOGGING_LAST_LOG"}, {"original_string": "private UserSession session_;", "modifier": "private", "type": "UserSession", "declarator": "session_", "var_name": "session_"}, {"original_string": "private boolean isLogAnonymous_ = LogModule.isLogAnonymous();", "modifier": "private", "type": "boolean", "declarator": "isLogAnonymous_ = LogModule.isLogAnonymous()", "var_name": "isLogAnonymous_"}, {"original_string": "private ActionType stickyActionType_ = null;", "modifier": "private", "type": "ActionType", "declarator": "stickyActionType_ = null", "var_name": "stickyActionType_"}, {"original_string": "private Set<String> userProperties_ = LogModule.getUserProperties();", "modifier": "private", "type": "Set<String>", "declarator": "userProperties_ = LogModule.getUserProperties()", "var_name": "userProperties_"}, {"original_string": "private Identity identity_;", "modifier": "private", "type": "Identity", "declarator": "identity_", "var_name": "identity_"}, {"original_string": "private List<ILoggingResourceable> resourceableList_ = null;", "modifier": "private", "type": "List<ILoggingResourceable>", "declarator": "resourceableList_ = null", "var_name": "resourceableList_"}, {"original_string": "private String businessPath_;", "modifier": "private", "type": "String", "declarator": "businessPath_", "var_name": "businessPath_"}, {"original_string": "private List<ContextEntry> bcContextEntries_;", "modifier": "private", "type": "List<ContextEntry>", "declarator": "bcContextEntries_", "var_name": "bcContextEntries_"}, {"original_string": "private final boolean propageToThreadLocal_;", "modifier": "private final", "type": "boolean", "declarator": "propageToThreadLocal_", "var_name": "propageToThreadLocal_"}, {"original_string": "private UserActivityLoggerImpl runtimeParent_;", "modifier": "private", "type": "UserActivityLoggerImpl", "declarator": "runtimeParent_", "var_name": "runtimeParent_"}, {"original_string": "private ActivityLoggingDao activityLoggingDao;", "modifier": "private", "type": "ActivityLoggingDao", "declarator": "activityLoggingDao", "var_name": "activityLoggingDao"}, {"original_string": "private I18nManager i18nManager = I18nManager.getInstance();", "modifier": "private", "type": "I18nManager", "declarator": "i18nManager = I18nManager.getInstance()", "var_name": "i18nManager"}], "methods": [{"identifier": "UserActivityLoggerImpl", "parameters": "(HttpServletRequest hReq)", "modifiers": "", "return": "", "signature": " UserActivityLoggerImpl(HttpServletRequest hReq)", "full_signature": "  UserActivityLoggerImpl(HttpServletRequest hReq)", "class_method_signature": "UserActivityLoggerImpl.UserActivityLoggerImpl(HttpServletRequest hReq)", "testcase": false, "constructor": true}, {"identifier": "UserActivityLoggerImpl", "parameters": "()", "modifiers": "", "return": "", "signature": " UserActivityLoggerImpl()", "full_signature": "  UserActivityLoggerImpl()", "class_method_signature": "UserActivityLoggerImpl.UserActivityLoggerImpl()", "testcase": false, "constructor": true}, {"identifier": "UserActivityLoggerImpl", "parameters": "(UserSession userSession, ActivityLoggingDao activityLoggingDao, boolean isLogAnonymous, Set<String> userProperties, I18nManager i18nManager)", "modifiers": "", "return": "", "signature": " UserActivityLoggerImpl(UserSession userSession, ActivityLoggingDao activityLoggingDao, boolean isLogAnonymous, Set<String> userProperties, I18nManager i18nManager)", "full_signature": "  UserActivityLoggerImpl(UserSession userSession, ActivityLoggingDao activityLoggingDao, boolean isLogAnonymous, Set<String> userProperties, I18nManager i18nManager)", "class_method_signature": "UserActivityLoggerImpl.UserActivityLoggerImpl(UserSession userSession, ActivityLoggingDao activityLoggingDao, boolean isLogAnonymous, Set<String> userProperties, I18nManager i18nManager)", "testcase": false, "constructor": true}, {"identifier": "initWithRequest", "parameters": "(HttpServletRequest hReq)", "modifiers": "private", "return": "void", "signature": "void initWithRequest(HttpServletRequest hReq)", "full_signature": "private void initWithRequest(HttpServletRequest hReq)", "class_method_signature": "UserActivityLoggerImpl.initWithRequest(HttpServletRequest hReq)", "testcase": false, "constructor": false}, {"identifier": "UserActivityLoggerImpl", "parameters": "(IUserActivityLogger userActivityLogger, WindowControl wControl, boolean propageToThreadLocal)", "modifiers": "private", "return": "", "signature": " UserActivityLoggerImpl(IUserActivityLogger userActivityLogger, WindowControl wControl, boolean propageToThreadLocal)", "full_signature": "private  UserActivityLoggerImpl(IUserActivityLogger userActivityLogger, WindowControl wControl, boolean propageToThreadLocal)", "class_method_signature": "UserActivityLoggerImpl.UserActivityLoggerImpl(IUserActivityLogger userActivityLogger, WindowControl wControl, boolean propageToThreadLocal)", "testcase": false, "constructor": true}, {"identifier": "setupLoggerForController", "parameters": "(WindowControl wControl)", "modifiers": "public static", "return": "UserActivityLoggerImpl", "signature": "UserActivityLoggerImpl setupLoggerForController(WindowControl wControl)", "full_signature": "public static UserActivityLoggerImpl setupLoggerForController(WindowControl wControl)", "class_method_signature": "UserActivityLoggerImpl.setupLoggerForController(WindowControl wControl)", "testcase": false, "constructor": false}, {"identifier": "copyLoggerForRuntime", "parameters": "(IUserActivityLogger userActivityLogger)", "modifiers": "static", "return": "UserActivityLoggerImpl", "signature": "UserActivityLoggerImpl copyLoggerForRuntime(IUserActivityLogger userActivityLogger)", "full_signature": "static UserActivityLoggerImpl copyLoggerForRuntime(IUserActivityLogger userActivityLogger)", "class_method_signature": "UserActivityLoggerImpl.copyLoggerForRuntime(IUserActivityLogger userActivityLogger)", "testcase": false, "constructor": false}, {"identifier": "newLoggerForValueUnbound", "parameters": "(UserSession session)", "modifiers": "public static", "return": "IUserActivityLogger", "signature": "IUserActivityLogger newLoggerForValueUnbound(UserSession session)", "full_signature": "public static IUserActivityLogger newLoggerForValueUnbound(UserSession session)", "class_method_signature": "UserActivityLoggerImpl.newLoggerForValueUnbound(UserSession session)", "testcase": false, "constructor": false}, {"identifier": "newLoggerForEventBus", "parameters": "(GenericEventListener listener)", "modifiers": "public static", "return": "UserActivityLoggerImpl", "signature": "UserActivityLoggerImpl newLoggerForEventBus(GenericEventListener listener)", "full_signature": "public static UserActivityLoggerImpl newLoggerForEventBus(GenericEventListener listener)", "class_method_signature": "UserActivityLoggerImpl.newLoggerForEventBus(GenericEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "frameworkSetSession", "parameters": "(UserSession session)", "modifiers": "@Override public", "return": "void", "signature": "void frameworkSetSession(UserSession session)", "full_signature": "@Override public void frameworkSetSession(UserSession session)", "class_method_signature": "UserActivityLoggerImpl.frameworkSetSession(UserSession session)", "testcase": false, "constructor": false}, {"identifier": "getLoggingResourceableList", "parameters": "()", "modifiers": "private", "return": "List<ILoggingResourceable>", "signature": "List<ILoggingResourceable> getLoggingResourceableList()", "full_signature": "private List<ILoggingResourceable> getLoggingResourceableList()", "class_method_signature": "UserActivityLoggerImpl.getLoggingResourceableList()", "testcase": false, "constructor": false}, {"identifier": "addLoggingResourceInfo", "parameters": "(ILoggingResourceable loggingResourceable)", "modifiers": "@Override public", "return": "void", "signature": "void addLoggingResourceInfo(ILoggingResourceable loggingResourceable)", "full_signature": "@Override public void addLoggingResourceInfo(ILoggingResourceable loggingResourceable)", "class_method_signature": "UserActivityLoggerImpl.addLoggingResourceInfo(ILoggingResourceable loggingResourceable)", "testcase": false, "constructor": false}, {"identifier": "frameworkSetBusinessPath", "parameters": "(String businessPath)", "modifiers": "@Override public", "return": "void", "signature": "void frameworkSetBusinessPath(String businessPath)", "full_signature": "@Override public void frameworkSetBusinessPath(String businessPath)", "class_method_signature": "UserActivityLoggerImpl.frameworkSetBusinessPath(String businessPath)", "testcase": false, "constructor": false}, {"identifier": "frameworkSetBCContextEntries", "parameters": "(List<ContextEntry> bcEntries)", "modifiers": "@Override public", "return": "void", "signature": "void frameworkSetBCContextEntries(List<ContextEntry> bcEntries)", "full_signature": "@Override public void frameworkSetBCContextEntries(List<ContextEntry> bcEntries)", "class_method_signature": "UserActivityLoggerImpl.frameworkSetBCContextEntries(List<ContextEntry> bcEntries)", "testcase": false, "constructor": false}, {"identifier": "frameworkSetBusinessPathFromWindowControl", "parameters": "(WindowControl wControl)", "modifiers": "@Override public", "return": "void", "signature": "void frameworkSetBusinessPathFromWindowControl(WindowControl wControl)", "full_signature": "@Override public void frameworkSetBusinessPathFromWindowControl(WindowControl wControl)", "class_method_signature": "UserActivityLoggerImpl.frameworkSetBusinessPathFromWindowControl(WindowControl wControl)", "testcase": false, "constructor": false}, {"identifier": "getCombinedOrderedLoggingResourceables", "parameters": "(ILoggingResourceable... additionalLoggingResourceables)", "modifiers": "private", "return": "List<ILoggingResourceable>", "signature": "List<ILoggingResourceable> getCombinedOrderedLoggingResourceables(ILoggingResourceable... additionalLoggingResourceables)", "full_signature": "private List<ILoggingResourceable> getCombinedOrderedLoggingResourceables(ILoggingResourceable... additionalLoggingResourceables)", "class_method_signature": "UserActivityLoggerImpl.getCombinedOrderedLoggingResourceables(ILoggingResourceable... additionalLoggingResourceables)", "testcase": false, "constructor": false}, {"identifier": "setStickyActionType", "parameters": "(ActionType actionType)", "modifiers": "@Override public", "return": "void", "signature": "void setStickyActionType(ActionType actionType)", "full_signature": "@Override public void setStickyActionType(ActionType actionType)", "class_method_signature": "UserActivityLoggerImpl.setStickyActionType(ActionType actionType)", "testcase": false, "constructor": false}, {"identifier": "getStickyActionType", "parameters": "()", "modifiers": "@Override public", "return": "ActionType", "signature": "ActionType getStickyActionType()", "full_signature": "@Override public ActionType getStickyActionType()", "class_method_signature": "UserActivityLoggerImpl.getStickyActionType()", "testcase": false, "constructor": false}, {"identifier": "log", "parameters": "(ILoggingAction loggingAction, Class<?> callingClass, ILoggingResourceable... lriOrNull)", "modifiers": "@Override public", "return": "ReturnValue<LoggingObject>", "signature": "ReturnValue<LoggingObject> log(ILoggingAction loggingAction, Class<?> callingClass, ILoggingResourceable... lriOrNull)", "full_signature": "@Override public ReturnValue<LoggingObject> log(ILoggingAction loggingAction, Class<?> callingClass, ILoggingResourceable... lriOrNull)", "class_method_signature": "UserActivityLoggerImpl.log(ILoggingAction loggingAction, Class<?> callingClass, ILoggingResourceable... lriOrNull)", "testcase": false, "constructor": false}, {"identifier": "getUserService", "parameters": "()", "modifiers": "private", "return": "UserService", "signature": "UserService getUserService()", "full_signature": "private UserService getUserService()", "class_method_signature": "UserActivityLoggerImpl.getUserService()", "testcase": false, "constructor": false}, {"identifier": "getActivityLoggingDao", "parameters": "()", "modifiers": "private", "return": "ActivityLoggingDao", "signature": "ActivityLoggingDao getActivityLoggingDao()", "full_signature": "private ActivityLoggingDao getActivityLoggingDao()", "class_method_signature": "UserActivityLoggerImpl.getActivityLoggingDao()", "testcase": false, "constructor": false}, {"identifier": "convertLoggingResourceableListToString", "parameters": "(List<ILoggingResourceable> resourceInfos)", "modifiers": "private", "return": "String", "signature": "String convertLoggingResourceableListToString(List<ILoggingResourceable> resourceInfos)", "full_signature": "private String convertLoggingResourceableListToString(List<ILoggingResourceable> resourceInfos)", "class_method_signature": "UserActivityLoggerImpl.convertLoggingResourceableListToString(List<ILoggingResourceable> resourceInfos)", "testcase": false, "constructor": false}], "file": "olat7.8/src/main/java/org/olat/lms/activitylogging/UserActivityLoggerImpl.java"}, "focal_method": {"identifier": "log", "parameters": "(ILoggingAction loggingAction, Class<?> callingClass, ILoggingResourceable... lriOrNull)", "modifiers": "@Override public", "return": "ReturnValue<LoggingObject>", "body": "@Override\n    public ReturnValue<LoggingObject> log(ILoggingAction loggingAction, Class<?> callingClass, ILoggingResourceable... lriOrNull) {\n        final ActionType actionType = stickyActionType_ != null ? stickyActionType_ : loggingAction.getResourceActionType();\n\n        // don't log entries with loggingAction type 'tracking'\n        if (isLogAnonymous_ && actionType.equals(ActionType.tracking)) {\n            return ReturnValue.EMPTY;\n        }\n\n        // fetch some of the loggingAction fields - used for error logging below\n        final CrudAction crudAction = loggingAction.getCrudAction();\n        final ActionVerb actionVerb = loggingAction.getActionVerb();\n        final String actionObject = loggingAction.getActionObject();\n\n        // calculate the combined and ordered list of LoggingResourceables which should go\n        // to the database below right away\n        List<ILoggingResourceable> resourceInfos = getCombinedOrderedLoggingResourceables(lriOrNull);\n\n        if (loggingAction.getTypeListDefinition() == null) {\n            // this is a foul!\n            log.warn(\"LoggingAction has no ResourceableTypeList defined: action=\" + loggingAction + \", fieldId=\" + loggingAction.getJavaFieldIdForDebug());\n        } else {\n            // good boy\n            String errorMsg = loggingAction.getTypeListDefinition().executeCheckAndGetErrorMessage(resourceInfos);\n            if (errorMsg != null) {\n                // we found an inconsistency\n                // lets make this a warn\n                // removed throwable from warn logging due to overflow of the log files with stack traces - probably relate to OLAT-4653\n                log.warn(\"LoggingAction reported an inconsistency: \" + loggingAction.getActionVerb() + \" \" + loggingAction.getActionObject() + \", action=\"\n                        + loggingAction + \", fieldId=\" + loggingAction.getJavaFieldIdForDebug() + \", expected: \" + loggingAction.getTypeListDefinition().toString()\n                        + \", actual: \" + convertLoggingResourceableListToString(resourceInfos));\n            }\n        }\n\n        if (session_ == null) {\n            // then I can't log - log information without session/user information isn't of much use\n            // issue a log warn with a stacktrace for this\n            // removed throwable from error logging due to overflow of the log files with stack traces\n            log.error(\"No session available to UserActivityLogger. Cannot write log entry: \" + crudAction.name() + \":\" + actionVerb.name() + \", \" + actionObject + \", \"\n                    + convertLoggingResourceableListToString(resourceInfos));\n            return ReturnValue.EMPTY;\n        }\n\n        if (session_.getSessionInfo() == null || session_.getSessionInfo().getSession() == null || session_.getSessionInfo().getSession().getId() == null\n                || session_.getSessionInfo().getSession().getId().length() == 0) {\n            // no session Id available - odd\n            // removed throwable from error logging due to overflow of the log files with stack traces\n            log.error(\"No session information available to UserActivityLogger. Cannot write log entry: \" + crudAction.name() + \":\" + actionVerb.name() + \", \"\n                    + actionObject + \", \" + convertLoggingResourceableListToString(resourceInfos));\n            return ReturnValue.EMPTY;\n        }\n        final String sessionId = session_.getSessionInfo().getSession().getId();\n\n        Identity identity = session_.getIdentity();\n        if (identity == null) {\n            // no identity available - odd\n            // removed throwable from error logging due to overflow of the log files with stack traces\n            log.error(\"No identity available to UserActivityLogger. Cannot write log entry: \" + crudAction.name() + \":\" + actionVerb.name() + \", \" + actionObject + \", \"\n                    + convertLoggingResourceableListToString(resourceInfos));\n            return ReturnValue.EMPTY;\n        }\n        Long identityKey = identity.getKey();\n\n        if (actionType != ActionType.admin) {\n            final String identityKeyStr = String.valueOf(identityKey);\n            for (Iterator it = resourceInfos.iterator(); it.hasNext();) {\n                ILoggingResourceable lr = (ILoggingResourceable) it.next();\n                if (lr.getResourceableType() == StringResourceableType.targetIdentity) {\n                    if (log.isDebugEnabled() && !lr.getId().equals(identityKeyStr)) {\n                        // complain\n                        final Writer strackTraceAsStringWriter = new StringWriter();\n                        final PrintWriter printWriter = new PrintWriter(strackTraceAsStringWriter);\n                        (new Exception(\"OLAT-4955 debug stacktrac\")).printStackTrace(printWriter);\n                        log.debug(\"OLAT-4955: Not storing targetIdentity for non-admin logging actions. A non-admin logging action wanted to store a user other than the one from the session: action=\"\n                                + loggingAction + \", fieldId=\" + loggingAction.getJavaFieldIdForDebug() + strackTraceAsStringWriter.toString());\n                    }\n                    // OLAT-4955: remove targetIdentity\n                    it.remove();\n                }\n            }\n        }\n\n        String identityName;\n        if (isLogAnonymous_ && (actionType != ActionType.admin)) {\n            identityName = \"\";\n        } else {\n            identityName = identity.getName();\n        }\n\n        // start creating the LoggingObject\n        final LoggingObject logObj = new LoggingObject(sessionId, identityKey, identityName, crudAction.name().substring(0, 1), actionVerb.name(), actionObject,\n                LogModule.isLogAnonymous());\n\n        // do simpleDuration calculation & storing\n        LoggingObject lastLogObj = (LoggingObject) session_.getEntry(USESS_KEY_USER_ACTIVITY_LOGGING_LAST_LOG);\n        if (lastLogObj != null) {\n            // lastLogObj = (LoggingObject) DBFactory.getInstance().loadObject(lastLogObj);\n            // DBFactory.getInstance().updateObject(lastLogObj);\n            // Implementation Note:\n            // we used to do loadObject(), updateObject() here - which is the preferred best practice hibernate way\n            // for changing an existing object in the database.\n            // in the setup @UZH we'll use BLACKHOLE as the storage engine for the o_loggingtable (this is to have\n            // minimal work load on the Main OLAT DB and not have duplicate data on the Main OLAT DB and the Logging DB).\n            // Using BLACKHOLE results in the 'lastLogObj' here, not to exist in the database anymore.\n            // Hence we can't do a loadObject() nor an updateObject(). The latter does not work due to the fact\n            // that Hibernate checks the number of updated rows and expect that to equal 1 - which is not the case\n            // when using BLACKHOLE.\n\n            // Workaround: - also compare with LoggingObject.hbm.xml docu\n            //\n            // We use the sql-update's feature check=\"none\", which disables the above mentioned check.\n            // Using this in combination with manual SQL code below seems to be the only feasible way\n            // to have Hibernate not do any row-number-checks.\n\n            // Implications of the workaround:\n            //\n            // * Manual SQL: It shouldn't be a big deal to have this manual SQL code as it is very standard.\n            // * CANT USE updateObject(LoggingObject) EVER:\n            // @TODO We might have to add a check which verifies that no one calls updateObject(LoggingObject)\n            // if that would be called it would simply fail in the BLACKHOLE@UZH setup\n\n            // calculate the duration - take the simple diff of the two creationDate fields\n            Date currentTime = logObj.getCreationDate();\n            Date lastTime = lastLogObj.getCreationDate();\n            long duration;\n            if (lastTime == null) {\n                duration = -1;\n            } else if (currentTime == null) {\n                duration = System.currentTimeMillis() - lastTime.getTime();\n            } else {\n                duration = currentTime.getTime() - lastTime.getTime();\n            }\n\n            // ticket I-130413-0018 reported a red screen caused by a NPE since lastLogObj.getKey() was null\n            // this can happen if the lastLogObj had not been saved to database\n            // a solution should be found to ensure a correct sequential storage to db ...\n            // for the time being we just dont't update the duration in this case\n            if (lastLogObj.getKey() != null) {\n                getActivityLoggingDao().updateDuration(lastLogObj, duration);\n            } else {\n                log.error(\"Trying to update duration of LoggingObject before it had been saved to database [\" + lastLogObj + \"]\");\n            }\n        }\n\n        // store the current logging object in the session - for duration calculation at next log\n        session_.putEntry(USESS_KEY_USER_ACTIVITY_LOGGING_LAST_LOG, logObj);\n\n        if (resourceInfos != null && resourceInfos.size() != 0) {\n            // this should be the normal case - we do have LoggingResourceables which we can log\n            // alongside the log message\n\n            // check if we have more than 4 - if we do, issue a log and remove the middle ones\n            if (resourceInfos.size() > 4) {\n                log.warn(\"More than 4 resource infos set on a user activity log. Can only have 4. Having: \" + resourceInfos.size());\n                int diff = resourceInfos.size() - 4;\n                for (int i = 0; i < diff; i++) {\n                    resourceInfos.remove(3);\n                }\n            }\n\n            // get the target resourceable\n            ILoggingResourceable ri = resourceInfos.get(resourceInfos.size() - 1);\n            logObj.setTargetResourceInfo(ri.getType(), ri.getId(), ri.getName());\n\n            // now set parent - if applicable\n            if (resourceInfos.size() > 1) {\n                ri = resourceInfos.get(resourceInfos.size() - 2);\n                logObj.setParentResourceInfo(ri.getType(), ri.getId(), ri.getName());\n            }\n\n            // and set the grand parent - if applicable\n            if (resourceInfos.size() > 2) {\n                ri = resourceInfos.get(resourceInfos.size() - 3);\n                logObj.setGrandParentResourceInfo(ri.getType(), ri.getId(), ri.getName());\n            }\n\n            // and set the great grand parent - if applicable\n            if (resourceInfos.size() > 3) {\n                ri = resourceInfos.get(resourceInfos.size() - 4);\n                logObj.setGreatGrandParentResourceInfo(ri.getType(), ri.getId(), ri.getName());\n            }\n        }\n\n        // fill the remaining fields\n        logObj.setBusinessPath(businessPath_);\n        logObj.setSourceClass(callingClass.getCanonicalName());\n        logObj.setSimpleDuration(-1);\n        logObj.setResourceAdminAction(actionType.equals(ActionType.admin) ? true : false);\n        Locale locale = i18nManager.getLocaleOrDefault(identity.getUser().getPreferences().getLanguage());\n        // prepate the user properties, set them at once\n        List<String> tmpUserProperties = new ArrayList<String>(12);\n        for (Iterator<String> iterator = userProperties_.iterator(); iterator.hasNext();) {\n            String userPropString = getUserService().getPropertyOrIdentityEnvAttribute(identity.getUser(), iterator.next(), locale);\n            boolean shorten = false;\n            try {\n                if (userPropString != null && userPropString.getBytes(\"UTF-8\").length > 254) {\n                    shorten = true;\n                }\n            } catch (UnsupportedEncodingException uee) {\n                log.error(\"error while calculating real string length: unsupported encoding: \", uee);\n                shorten = true;\n            }\n            if (shorten) {\n                log.error(\"Userproperty was too long for logging-table (shortened automatically). check that nothing valueable is lost! value before cut: \"\n                        + userPropString);\n                userPropString = userPropString.substring(0, 255);\n            }\n            tmpUserProperties.add(userPropString);\n        }\n        logObj.setUserProperties(tmpUserProperties);\n        getActivityLoggingDao().saveLogObject(logObj);\n        return new ReturnValue(logObj);\n    }", "signature": "ReturnValue<LoggingObject> log(ILoggingAction loggingAction, Class<?> callingClass, ILoggingResourceable... lriOrNull)", "full_signature": "@Override public ReturnValue<LoggingObject> log(ILoggingAction loggingAction, Class<?> callingClass, ILoggingResourceable... lriOrNull)", "class_method_signature": "UserActivityLoggerImpl.log(ILoggingAction loggingAction, Class<?> callingClass, ILoggingResourceable... lriOrNull)", "testcase": false, "constructor": false, "invocations": ["getResourceActionType", "equals", "getCrudAction", "getActionVerb", "getActionObject", "getCombinedOrderedLoggingResourceables", "getTypeListDefinition", "warn", "getJavaFieldIdForDebug", "executeCheckAndGetErrorMessage", "getTypeListDefinition", "warn", "getActionVerb", "getActionObject", "getJavaFieldIdForDebug", "toString", "getTypeListDefinition", "convertLoggingResourceableListToString", "error", "name", "name", "convertLoggingResourceableListToString", "getSessionInfo", "getSession", "getSessionInfo", "getId", "getSession", "getSessionInfo", "length", "getId", "getSession", "getSessionInfo", "error", "name", "name", "convertLoggingResourceableListToString", "getId", "getSession", "getSessionInfo", "getIdentity", "error", "name", "name", "convertLoggingResourceableListToString", "getKey", "valueOf", "iterator", "hasNext", "next", "getResourceableType", "isDebugEnabled", "equals", "getId", "printStackTrace", "debug", "getJavaFieldIdForDebug", "toString", "remove", "getName", "substring", "name", "name", "isLogAnonymous", "getEntry", "getCreationDate", "getCreationDate", "currentTimeMillis", "getTime", "getTime", "getTime", "getKey", "updateDuration", "getActivityLoggingDao", "error", "putEntry", "size", "size", "warn", "size", "size", "remove", "get", "size", "setTargetResourceInfo", "getType", "getId", "getName", "size", "get", "size", "setParentResourceInfo", "getType", "getId", "getName", "size", "get", "size", "setGrandParentResourceInfo", "getType", "getId", "getName", "size", "get", "size", "setGreatGrandParentResourceInfo", "getType", "getId", "getName", "setBusinessPath", "setSourceClass", "getCanonicalName", "setSimpleDuration", "setResourceAdminAction", "equals", "getLocaleOrDefault", "getLanguage", "getPreferences", "getUser", "iterator", "hasNext", "getPropertyOrIdentityEnvAttribute", "getUserService", "getUser", "next", "getBytes", "error", "error", "substring", "add", "setUserProperties", "saveLogObject", "getActivityLoggingDao"]}, "repository": {"repo_id": 22589840, "url": "https://github.com/huihoo/olat", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 10, "size": 69738, "license": "licensed"}}