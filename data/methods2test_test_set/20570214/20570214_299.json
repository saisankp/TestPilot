{"test_class": {"identifier": "AesEaxJceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int KEY_SIZE = 16;", "modifier": "private static final", "type": "int", "declarator": "KEY_SIZE = 16", "var_name": "KEY_SIZE"}, {"original_string": "private static final int IV_SIZE = 16;", "modifier": "private static final", "type": "int", "declarator": "IV_SIZE = 16", "var_name": "IV_SIZE"}, {"original_string": "private Integer[] keySizeInBytes;", "modifier": "private", "type": "Integer[]", "declarator": "keySizeInBytes", "var_name": "keySizeInBytes"}, {"original_string": "private Integer[] ivSizeInBytes;", "modifier": "private", "type": "Integer[]", "declarator": "ivSizeInBytes", "var_name": "ivSizeInBytes"}], "file": "java_src/src/test/java/com/google/crypto/tink/subtle/AesEaxJceTest.java"}, "test_case": {"identifier": "testWycheproofVectors", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testWycheproofVectors() throws Exception {\n    JSONObject json =\n        WycheproofTestUtil.readJson(\"../wycheproof/testvectors/aes_eax_test.json\");\n    int errors = 0;\n    int cntSkippedTests = 0;\n    JSONArray testGroups = json.getJSONArray(\"testGroups\");\n    for (int i = 0; i < testGroups.length(); i++) {\n      JSONObject group = testGroups.getJSONObject(i);\n      int keySize = group.getInt(\"keySize\");\n      int ivSize = group.getInt(\"ivSize\");\n      JSONArray tests = group.getJSONArray(\"tests\");\n      if (!Arrays.asList(keySizeInBytes).contains(keySize / 8)\n          || !Arrays.asList(ivSizeInBytes).contains(ivSize / 8)) {\n        cntSkippedTests += tests.length();\n        continue;\n      }\n      for (int j = 0; j < tests.length(); j++) {\n        JSONObject testcase = tests.getJSONObject(j);\n        String tcId =\n            String.format(\n                \"testcase %d (%s)\", testcase.getInt(\"tcId\"), testcase.getString(\"comment\"));\n        byte[] iv = Hex.decode(testcase.getString(\"iv\"));\n        byte[] key = Hex.decode(testcase.getString(\"key\"));\n        byte[] msg = Hex.decode(testcase.getString(\"msg\"));\n        byte[] aad = Hex.decode(testcase.getString(\"aad\"));\n        byte[] ct = Hex.decode(testcase.getString(\"ct\"));\n        byte[] tag = Hex.decode(testcase.getString(\"tag\"));\n        byte[] ciphertext = Bytes.concat(iv, ct, tag);\n        String result = testcase.getString(\"result\");\n        try {\n          AesEaxJce eax = new AesEaxJce(key, iv.length);\n          byte[] decrypted = eax.decrypt(ciphertext, aad);\n          boolean eq = TestUtil.arrayEquals(decrypted, msg);\n          if (result.equals(\"invalid\")) {\n            System.out.printf(\n                \"FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n\",\n                tcId, Hex.encode(msg), Hex.encode(decrypted));\n            errors++;\n          } else {\n            if (!eq) {\n              System.out.printf(\n                  \"FAIL %s: incorrect decryption, result: %s, expected: %s%n\",\n                  tcId, Hex.encode(decrypted), Hex.encode(msg));\n              errors++;\n            }\n          }\n        } catch (GeneralSecurityException ex) {\n          if (result.equals(\"valid\")) {\n            System.out.printf(\"FAIL %s: cannot decrypt, exception %s%n\", tcId, ex);\n            errors++;\n          }\n        }\n      }\n    }\n    System.out.printf(\"Number of tests skipped: %d\", cntSkippedTests);\n    assertEquals(0, errors);\n  }", "signature": "void testWycheproofVectors()", "full_signature": "@Test public void testWycheproofVectors()", "class_method_signature": "AesEaxJceTest.testWycheproofVectors()", "testcase": true, "constructor": false, "invocations": ["readJson", "getJSONArray", "length", "getJSONObject", "getInt", "getInt", "getJSONArray", "contains", "asList", "contains", "asList", "length", "length", "getJSONObject", "format", "getInt", "getString", "decode", "getString", "decode", "getString", "decode", "getString", "decode", "getString", "decode", "getString", "decode", "getString", "concat", "getString", "decrypt", "arrayEquals", "equals", "printf", "encode", "encode", "printf", "encode", "encode", "equals", "printf", "printf", "assertEquals"]}, "focal_class": {"identifier": "AesEaxJce", "superclass": "", "interfaces": "implements Aead", "fields": [{"original_string": "private static final ThreadLocal<Cipher> localEcbCipher =\n      new ThreadLocal<Cipher>() {\n        @Override\n        protected Cipher initialValue() {\n          try {\n            return EngineFactory.CIPHER.getInstance(\"AES/ECB/NOPADDING\");\n          } catch (GeneralSecurityException ex) {\n            throw new IllegalStateException(ex);\n          }\n        }\n      };", "modifier": "private static final", "type": "ThreadLocal<Cipher>", "declarator": "localEcbCipher =\n      new ThreadLocal<Cipher>() {\n        @Override\n        protected Cipher initialValue() {\n          try {\n            return EngineFactory.CIPHER.getInstance(\"AES/ECB/NOPADDING\");\n          } catch (GeneralSecurityException ex) {\n            throw new IllegalStateException(ex);\n          }\n        }\n      }", "var_name": "localEcbCipher"}, {"original_string": "private static final ThreadLocal<Cipher> localCtrCipher =\n      new ThreadLocal<Cipher>() {\n        @Override\n        protected Cipher initialValue() {\n          try {\n            return EngineFactory.CIPHER.getInstance(\"AES/CTR/NOPADDING\");\n          } catch (GeneralSecurityException ex) {\n            throw new IllegalStateException(ex);\n          }\n        }\n      };", "modifier": "private static final", "type": "ThreadLocal<Cipher>", "declarator": "localCtrCipher =\n      new ThreadLocal<Cipher>() {\n        @Override\n        protected Cipher initialValue() {\n          try {\n            return EngineFactory.CIPHER.getInstance(\"AES/CTR/NOPADDING\");\n          } catch (GeneralSecurityException ex) {\n            throw new IllegalStateException(ex);\n          }\n        }\n      }", "var_name": "localCtrCipher"}, {"original_string": "static final int BLOCK_SIZE_IN_BYTES = 16;", "modifier": "static final", "type": "int", "declarator": "BLOCK_SIZE_IN_BYTES = 16", "var_name": "BLOCK_SIZE_IN_BYTES"}, {"original_string": "static final int TAG_SIZE_IN_BYTES = 16;", "modifier": "static final", "type": "int", "declarator": "TAG_SIZE_IN_BYTES = 16", "var_name": "TAG_SIZE_IN_BYTES"}, {"original_string": "private final byte[] b;", "modifier": "private final", "type": "byte[]", "declarator": "b", "var_name": "b"}, {"original_string": "private final byte[] p;", "modifier": "private final", "type": "byte[]", "declarator": "p", "var_name": "p"}, {"original_string": "private final SecretKeySpec keySpec;", "modifier": "private final", "type": "SecretKeySpec", "declarator": "keySpec", "var_name": "keySpec"}, {"original_string": "private final int ivSizeInBytes;", "modifier": "private final", "type": "int", "declarator": "ivSizeInBytes", "var_name": "ivSizeInBytes"}], "methods": [{"identifier": "AesEaxJce", "parameters": "(final byte[] key, int ivSizeInBytes)", "modifiers": "@SuppressWarnings(\"InsecureCryptoUsage\") public", "return": "", "signature": " AesEaxJce(final byte[] key, int ivSizeInBytes)", "full_signature": "@SuppressWarnings(\"InsecureCryptoUsage\") public  AesEaxJce(final byte[] key, int ivSizeInBytes)", "class_method_signature": "AesEaxJce.AesEaxJce(final byte[] key, int ivSizeInBytes)", "testcase": false, "constructor": true}, {"identifier": "xor", "parameters": "(final byte[] x, final byte[] y)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] xor(final byte[] x, final byte[] y)", "full_signature": "private static byte[] xor(final byte[] x, final byte[] y)", "class_method_signature": "AesEaxJce.xor(final byte[] x, final byte[] y)", "testcase": false, "constructor": false}, {"identifier": "multiplyByX", "parameters": "(final byte[] block)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] multiplyByX(final byte[] block)", "full_signature": "private static byte[] multiplyByX(final byte[] block)", "class_method_signature": "AesEaxJce.multiplyByX(final byte[] block)", "testcase": false, "constructor": false}, {"identifier": "pad", "parameters": "(final byte[] data)", "modifiers": "private", "return": "byte[]", "signature": "byte[] pad(final byte[] data)", "full_signature": "private byte[] pad(final byte[] data)", "class_method_signature": "AesEaxJce.pad(final byte[] data)", "testcase": false, "constructor": false}, {"identifier": "omac", "parameters": "(Cipher ecb, int tag, final byte[] data, int offset, int length)", "modifiers": "private", "return": "byte[]", "signature": "byte[] omac(Cipher ecb, int tag, final byte[] data, int offset, int length)", "full_signature": "private byte[] omac(Cipher ecb, int tag, final byte[] data, int offset, int length)", "class_method_signature": "AesEaxJce.omac(Cipher ecb, int tag, final byte[] data, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "encrypt", "parameters": "(final byte[] plaintext, final byte[] associatedData)", "modifiers": "@SuppressWarnings(\"InsecureCryptoUsage\") @Override public", "return": "byte[]", "signature": "byte[] encrypt(final byte[] plaintext, final byte[] associatedData)", "full_signature": "@SuppressWarnings(\"InsecureCryptoUsage\") @Override public byte[] encrypt(final byte[] plaintext, final byte[] associatedData)", "class_method_signature": "AesEaxJce.encrypt(final byte[] plaintext, final byte[] associatedData)", "testcase": false, "constructor": false}, {"identifier": "decrypt", "parameters": "(final byte[] ciphertext, final byte[] associatedData)", "modifiers": "@SuppressWarnings(\"InsecureCryptoUsage\") @Override public", "return": "byte[]", "signature": "byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)", "full_signature": "@SuppressWarnings(\"InsecureCryptoUsage\") @Override public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)", "class_method_signature": "AesEaxJce.decrypt(final byte[] ciphertext, final byte[] associatedData)", "testcase": false, "constructor": false}], "file": "java_src/src/main/java/com/google/crypto/tink/subtle/AesEaxJce.java"}, "focal_method": {"identifier": "decrypt", "parameters": "(final byte[] ciphertext, final byte[] associatedData)", "modifiers": "@SuppressWarnings(\"InsecureCryptoUsage\") @Override public", "return": "byte[]", "body": "@SuppressWarnings(\"InsecureCryptoUsage\")\n  @Override\n  public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)\n      throws GeneralSecurityException {\n    int plaintextLength = ciphertext.length - ivSizeInBytes - TAG_SIZE_IN_BYTES;\n    if (plaintextLength < 0) {\n      throw new GeneralSecurityException(\"ciphertext too short\");\n    }\n    Cipher ecb = localEcbCipher.get();\n    ecb.init(Cipher.ENCRYPT_MODE, keySpec);\n    byte[] n = omac(ecb, 0, ciphertext, 0, ivSizeInBytes);\n    byte[] aad = associatedData;\n    if (aad == null) {\n      aad = new byte[0];\n    }\n    byte[] h = omac(ecb, 1, aad, 0, aad.length);\n    byte[] t = omac(ecb, 2, ciphertext, ivSizeInBytes, plaintextLength);\n    byte res = 0;\n    int offset = ciphertext.length - TAG_SIZE_IN_BYTES;\n    for (int i = 0; i < TAG_SIZE_IN_BYTES; i++) {\n      res = (byte) (res | (ciphertext[offset + i] ^ h[i] ^ n[i] ^ t[i]));\n    }\n    if (res != 0) {\n      throw new AEADBadTagException(\"tag mismatch\");\n    }\n    Cipher ctr = localCtrCipher.get();\n    ctr.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(n));\n    return ctr.doFinal(ciphertext, ivSizeInBytes, plaintextLength);\n  }", "signature": "byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)", "full_signature": "@SuppressWarnings(\"InsecureCryptoUsage\") @Override public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)", "class_method_signature": "AesEaxJce.decrypt(final byte[] ciphertext, final byte[] associatedData)", "testcase": false, "constructor": false, "invocations": ["get", "init", "omac", "omac", "omac", "get", "init", "doFinal"]}, "repository": {"repo_id": 20570214, "url": "https://github.com/google/tink", "stars": 8884, "created": "6/6/2014 4:21:09 PM +00:00", "updates": "2020-01-27T11:52:16+00:00", "fork": "False", "license": "licensed"}}