{"test_class": {"identifier": "DateTimeUtilsTest", "superclass": "extends AbstractBaseTest", "interfaces": "", "fields": [{"original_string": "private static final long MINUTE_IN_MILLISECONDS = 60 * 1000L;", "modifier": "private static final", "type": "long", "declarator": "MINUTE_IN_MILLISECONDS = 60 * 1000L", "var_name": "MINUTE_IN_MILLISECONDS"}, {"original_string": "private static final long FIFTY_NINE_SECONDS_IN_MILLISECONDS = 59 * 1000L;", "modifier": "private static final", "type": "long", "declarator": "FIFTY_NINE_SECONDS_IN_MILLISECONDS = 59 * 1000L", "var_name": "FIFTY_NINE_SECONDS_IN_MILLISECONDS"}, {"original_string": "private static final long HOUR_IN_MILLISECONDS = 60 * 60 * 1000L;", "modifier": "private static final", "type": "long", "declarator": "HOUR_IN_MILLISECONDS = 60 * 60 * 1000L", "var_name": "HOUR_IN_MILLISECONDS"}], "file": "jbpm-flow/src/test/java/org/jbpm/process/core/timer/DateTimeUtilsTest.java"}, "test_case": {"identifier": "testParseRepeatablePeriodPnYnMnWnDOnly", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testParseRepeatablePeriodPnYnMnWnDOnly() {\n        OffsetDateTime now = OffsetDateTime.now();\n        long expectedMillis = Duration\n                .between(now, now.plus(10, ChronoUnit.YEARS).plus(10, ChronoUnit.MONTHS).plus(10, ChronoUnit.WEEKS).plus(10, ChronoUnit.DAYS)).toMillis();\n        String isoString = \"R/P10Y10M10W10D\"; // ISO-8601 PnYnMnWnD\n\n        long[] parsedRepeatable = DateTimeUtils.parseRepeatableDateTime(isoString);\n\n        assertEquals(-1L, parsedRepeatable[0]);\n\n        assertTrue(\"Parsed delay is bigger than \" + expectedMillis, parsedRepeatable[1] <= expectedMillis);\n        assertTrue(\n                \"Parsed delay is too low! Expected value is between \" + expectedMillis + \" and \" + (expectedMillis - 1000) + \" but is \" + parsedRepeatable[1],\n                parsedRepeatable[1] > expectedMillis - 1000);\n        assertEquals(\"Parsed period should be 10 years, 10 months, 10 weeks and 10 days in milliseconds but is \" + parsedRepeatable[2], expectedMillis, parsedRepeatable[2]);\n    }", "signature": "void testParseRepeatablePeriodPnYnMnWnDOnly()", "full_signature": "@Test public void testParseRepeatablePeriodPnYnMnWnDOnly()", "class_method_signature": "DateTimeUtilsTest.testParseRepeatablePeriodPnYnMnWnDOnly()", "testcase": true, "constructor": false, "invocations": ["now", "toMillis", "between", "plus", "plus", "plus", "plus", "parseRepeatableDateTime", "assertEquals", "assertTrue", "assertTrue", "assertEquals"]}, "focal_class": {"identifier": "DateTimeUtils", "superclass": "extends TimeUtils", "interfaces": "", "fields": [], "methods": [{"identifier": "isRepeatable", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "boolean", "signature": "boolean isRepeatable(String dateTimeStr)", "full_signature": "public static boolean isRepeatable(String dateTimeStr)", "class_method_signature": "DateTimeUtils.isRepeatable(String dateTimeStr)", "testcase": false, "constructor": false}, {"identifier": "isPeriod", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "boolean", "signature": "boolean isPeriod(String dateTimeStr)", "full_signature": "public static boolean isPeriod(String dateTimeStr)", "class_method_signature": "DateTimeUtils.isPeriod(String dateTimeStr)", "testcase": false, "constructor": false}, {"identifier": "isNumeric", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "boolean", "signature": "boolean isNumeric(String dateTimeStr)", "full_signature": "public static boolean isNumeric(String dateTimeStr)", "class_method_signature": "DateTimeUtils.isNumeric(String dateTimeStr)", "testcase": false, "constructor": false}, {"identifier": "parseDateTime", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "long", "signature": "long parseDateTime(String dateTimeStr)", "full_signature": "public static long parseDateTime(String dateTimeStr)", "class_method_signature": "DateTimeUtils.parseDateTime(String dateTimeStr)", "testcase": false, "constructor": false}, {"identifier": "getMillis", "parameters": "(String durationStr)", "modifiers": "public static", "return": "long", "signature": "long getMillis(String durationStr)", "full_signature": "public static long getMillis(String durationStr)", "class_method_signature": "DateTimeUtils.getMillis(String durationStr)", "testcase": false, "constructor": false}, {"identifier": "parseDuration", "parameters": "(String durationStr)", "modifiers": "public static", "return": "long", "signature": "long parseDuration(String durationStr)", "full_signature": "public static long parseDuration(String durationStr)", "class_method_signature": "DateTimeUtils.parseDuration(String durationStr)", "testcase": false, "constructor": false}, {"identifier": "parseDateAsDuration", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "long", "signature": "long parseDateAsDuration(String dateTimeStr)", "full_signature": "public static long parseDateAsDuration(String dateTimeStr)", "class_method_signature": "DateTimeUtils.parseDateAsDuration(String dateTimeStr)", "testcase": false, "constructor": false}, {"identifier": "parseISORepeatable", "parameters": "(String isoString)", "modifiers": "public static", "return": "String[]", "signature": "String[] parseISORepeatable(String isoString)", "full_signature": "public static String[] parseISORepeatable(String isoString)", "class_method_signature": "DateTimeUtils.parseISORepeatable(String isoString)", "testcase": false, "constructor": false}, {"identifier": "parseRepeatableDateTime", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "long[]", "signature": "long[] parseRepeatableDateTime(String dateTimeStr)", "full_signature": "public static long[] parseRepeatableDateTime(String dateTimeStr)", "class_method_signature": "DateTimeUtils.parseRepeatableDateTime(String dateTimeStr)", "testcase": false, "constructor": false}], "file": "jbpm-flow/src/main/java/org/jbpm/process/core/timer/DateTimeUtils.java"}, "focal_method": {"identifier": "parseRepeatableDateTime", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "long[]", "body": "public static long[] parseRepeatableDateTime(String dateTimeStr) {\n        long[] result = new long[3];\n        if (isRepeatable(Objects.requireNonNull(dateTimeStr, \"Date-time string cannot be a null value!\"))) {\n\n            String[] parsed = parseISORepeatable(dateTimeStr);\n            String repeats = parsed[0];\n            String delayIn = parsed[1];\n            String periodIn = parsed[2];\n\n            Duration startAtDelayDur = null;\n            Duration period = null;\n\n            if (DateTimeUtils.isPeriod(delayIn)) {\n                // If delay is specified as duration then period variable carry end time information\n                OffsetDateTime endTime = OffsetDateTime.parse(periodIn, DateTimeFormatter.ISO_DATE_TIME);\n                period = Duration.of(getMillis(delayIn), ChronoUnit.MILLIS);\n                startAtDelayDur = Duration.between(OffsetDateTime.now(), endTime.minus(period));\n            } else if (DateTimeUtils.isPeriod(periodIn)) {\n                // If period is specified as duration then delay variable carry start time information\n                OffsetDateTime startTime = OffsetDateTime.parse(delayIn, DateTimeFormatter.ISO_DATE_TIME);\n                period = Duration.of(getMillis(periodIn), ChronoUnit.MILLIS);\n                startAtDelayDur = Duration.between(OffsetDateTime.now(), startTime);\n            } else {\n                // Both delay and period are specified as start and end times\n                OffsetDateTime startTime = OffsetDateTime.parse(delayIn, DateTimeFormatter.ISO_DATE_TIME);\n                OffsetDateTime endTime = OffsetDateTime.parse(periodIn, DateTimeFormatter.ISO_DATE_TIME);\n                startAtDelayDur = Duration.between(OffsetDateTime.now(), startTime);\n                period = Duration.between(startTime, endTime);\n            }\n\n            if (startAtDelayDur.isNegative() || startAtDelayDur.isZero()) {\n                // need to introduce delay to allow all initialization\n                startAtDelayDur = Duration.of(1, ChronoUnit.SECONDS);\n            }\n\n            result[0] = Long.parseLong(repeats.length() == 0 ? \"-1\" : repeats);\n            result[1] = startAtDelayDur.toMillis();\n            result[2] = period.toMillis();\n\n            return result;\n        } else {\n\n            int index = dateTimeStr.indexOf(\"###\");\n            if (index != -1) {\n                String period = dateTimeStr.substring(index + 3);\n                String delay = dateTimeStr.substring(0, index);\n                result = new long[]{TimeUtils.parseTimeString(delay), TimeUtils.parseTimeString(period)};\n\n                return result;\n            }\n            result = new long[]{TimeUtils.parseTimeString(dateTimeStr)};\n            return result;\n        }\n    }", "signature": "long[] parseRepeatableDateTime(String dateTimeStr)", "full_signature": "public static long[] parseRepeatableDateTime(String dateTimeStr)", "class_method_signature": "DateTimeUtils.parseRepeatableDateTime(String dateTimeStr)", "testcase": false, "constructor": false, "invocations": ["isRepeatable", "requireNonNull", "parseISORepeatable", "isPeriod", "parse", "of", "getMillis", "between", "now", "minus", "isPeriod", "parse", "of", "getMillis", "between", "now", "parse", "parse", "between", "now", "between", "isNegative", "isZero", "of", "parseLong", "length", "toMillis", "toMillis", "indexOf", "substring", "substring", "parseTimeString", "parseTimeString", "parseTimeString"]}, "repository": {"repo_id": 930571, "url": "https://github.com/kiegroup/jbpm", "stars": 1035, "created": "9/22/2010 1:19:52 PM +00:00", "updates": "2020-01-22T03:39:57+00:00", "fork": "False", "license": "licensed"}}