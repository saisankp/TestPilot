{"test_class": {"identifier": "RoundRobinConnectionStrategyTest", "superclass": "", "interfaces": "", "fields": [], "file": "core/src/test/java/org/ldaptive/RoundRobinConnectionStrategyTest.java"}, "test_case": {"identifier": "firstUrlInactive", "parameters": "()", "modifiers": "@Test(groups = \"conn\") public", "return": "void", "body": "@Test(groups = \"conn\")\n  public void firstUrlInactive()\n    throws Exception\n  {\n    final RoundRobinConnectionStrategy strategy = new RoundRobinConnectionStrategy();\n    final ConnectionConfig cc = new ConnectionConfig();\n    cc.setLdapUrl(\"ldap://directory-1.ldaptive.org ldap://directory-2.ldaptive.org ldap://directory-3.ldaptive.org\");\n    cc.setConnectionStrategy(strategy);\n    final MockConnection conn = new MockConnection(cc);\n    conn.setOpenPredicate(ldapURL -> !ldapURL.getHostname().contains(\"-1\"));\n    conn.setTestPredicate(ldapURL -> true);\n    Assert.assertEquals(strategy.ldapURLSet.getActiveUrls().size(), 3);\n    Assert.assertEquals(\n      strategy.ldapURLSet.getActiveUrls(),\n      Arrays.asList(\n        new LdapURL(\"ldap://directory-1.ldaptive.org\"),\n        new LdapURL(\"ldap://directory-2.ldaptive.org\"),\n        new LdapURL(\"ldap://directory-3.ldaptive.org\")));\n    Assert.assertEquals(strategy.ldapURLSet.getInactiveUrls().size(), 0);\n\n    // first entry should fail, list should reorder with that entry last\n    conn.open();\n    Assert.assertEquals(strategy.ldapURLSet.getActiveUrls().size(), 2);\n    Assert.assertEquals(\n      strategy.ldapURLSet.getActiveUrls(),\n      Arrays.asList(\n        new LdapURL(\"ldap://directory-2.ldaptive.org\"),\n        new LdapURL(\"ldap://directory-3.ldaptive.org\")));\n    Assert.assertEquals(strategy.ldapURLSet.getInactiveUrls().size(), 1);\n    Assert.assertEquals(\n      strategy.ldapURLSet.getInactiveUrls().iterator().next(),\n      new LdapURL(\"ldap://directory-1.ldaptive.org\"));\n\n    // confirm the inactive entry stays at the end\n    Assert.assertEquals(\n      StreamSupport.stream(strategy.spliterator(), false).collect(Collectors.toList()),\n      Arrays.asList(\n        new LdapURL(\"ldap://directory-3.ldaptive.org\"),\n        new LdapURL(\"ldap://directory-2.ldaptive.org\"),\n        new LdapURL(\"ldap://directory-1.ldaptive.org\")));\n    Assert.assertEquals(strategy.ldapURLSet.getActiveUrls().size(), 2);\n    Assert.assertEquals(\n      strategy.ldapURLSet.getActiveUrls(),\n      Arrays.asList(\n        new LdapURL(\"ldap://directory-2.ldaptive.org\"),\n        new LdapURL(\"ldap://directory-3.ldaptive.org\")));\n    Assert.assertEquals(strategy.ldapURLSet.getInactiveUrls().size(), 1);\n    Assert.assertEquals(\n      strategy.ldapURLSet.getInactiveUrls().iterator().next(),\n      new LdapURL(\"ldap://directory-1.ldaptive.org\"));\n\n    // mark first entry as active, list should reorder with that entry last\n    strategy.success(strategy.ldapURLSet.getInactiveUrls().iterator().next());\n    Assert.assertEquals(\n      StreamSupport.stream(strategy.spliterator(), false).collect(Collectors.toList()),\n      Arrays.asList(\n        new LdapURL(\"ldap://directory-3.ldaptive.org\"),\n        new LdapURL(\"ldap://directory-1.ldaptive.org\"),\n        new LdapURL(\"ldap://directory-2.ldaptive.org\")));\n    Assert.assertEquals(strategy.ldapURLSet.getActiveUrls().size(), 3);\n    Assert.assertEquals(\n      strategy.ldapURLSet.getActiveUrls(),\n      Arrays.asList(\n        new LdapURL(\"ldap://directory-1.ldaptive.org\"),\n        new LdapURL(\"ldap://directory-2.ldaptive.org\"),\n        new LdapURL(\"ldap://directory-3.ldaptive.org\")));\n    Assert.assertEquals(strategy.ldapURLSet.getInactiveUrls().size(), 0);\n  }", "signature": "void firstUrlInactive()", "full_signature": "@Test(groups = \"conn\") public void firstUrlInactive()", "class_method_signature": "RoundRobinConnectionStrategyTest.firstUrlInactive()", "testcase": true, "constructor": false, "invocations": ["setLdapUrl", "setConnectionStrategy", "setOpenPredicate", "contains", "getHostname", "setTestPredicate", "assertEquals", "size", "getActiveUrls", "assertEquals", "getActiveUrls", "asList", "assertEquals", "size", "getInactiveUrls", "open", "assertEquals", "size", "getActiveUrls", "assertEquals", "getActiveUrls", "asList", "assertEquals", "size", "getInactiveUrls", "assertEquals", "next", "iterator", "getInactiveUrls", "assertEquals", "collect", "stream", "spliterator", "toList", "asList", "assertEquals", "size", "getActiveUrls", "assertEquals", "getActiveUrls", "asList", "assertEquals", "size", "getInactiveUrls", "assertEquals", "next", "iterator", "getInactiveUrls", "success", "next", "iterator", "getInactiveUrls", "assertEquals", "collect", "stream", "spliterator", "toList", "asList", "assertEquals", "size", "getActiveUrls", "assertEquals", "getActiveUrls", "asList", "assertEquals", "size", "getInactiveUrls"]}, "focal_class": {"identifier": "RoundRobinConnectionStrategy", "superclass": "extends AbstractConnectionStrategy", "interfaces": "", "fields": [{"original_string": "private final AtomicInteger counter = new AtomicInteger();", "modifier": "private final", "type": "AtomicInteger", "declarator": "counter = new AtomicInteger()", "var_name": "counter"}, {"original_string": "private final Function<List<LdapURL>, Iterator<LdapURL>> iterFunction;", "modifier": "private final", "type": "Function<List<LdapURL>, Iterator<LdapURL>>", "declarator": "iterFunction", "var_name": "iterFunction"}], "methods": [{"identifier": "RoundRobinConnectionStrategy", "parameters": "()", "modifiers": "public", "return": "", "signature": " RoundRobinConnectionStrategy()", "full_signature": "public  RoundRobinConnectionStrategy()", "class_method_signature": "RoundRobinConnectionStrategy.RoundRobinConnectionStrategy()", "testcase": false, "constructor": true}, {"identifier": "RoundRobinConnectionStrategy", "parameters": "(final Function<List<LdapURL>, Iterator<LdapURL>> function)", "modifiers": "public", "return": "", "signature": " RoundRobinConnectionStrategy(final Function<List<LdapURL>, Iterator<LdapURL>> function)", "full_signature": "public  RoundRobinConnectionStrategy(final Function<List<LdapURL>, Iterator<LdapURL>> function)", "class_method_signature": "RoundRobinConnectionStrategy.RoundRobinConnectionStrategy(final Function<List<LdapURL>, Iterator<LdapURL>> function)", "testcase": false, "constructor": true}, {"identifier": "iterator", "parameters": "()", "modifiers": "@Override public synchronized", "return": "Iterator<LdapURL>", "signature": "Iterator<LdapURL> iterator()", "full_signature": "@Override public synchronized Iterator<LdapURL> iterator()", "class_method_signature": "RoundRobinConnectionStrategy.iterator()", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/ldaptive/RoundRobinConnectionStrategy.java"}, "focal_method": {"identifier": "iterator", "parameters": "()", "modifiers": "@Override public synchronized", "return": "Iterator<LdapURL>", "body": "@Override\n  public synchronized Iterator<LdapURL> iterator()\n  {\n    if (!isInitialized()) {\n      throw new IllegalStateException(\"Strategy is not initialized\");\n    }\n    final List<LdapURL> urls = new ArrayList<>(ldapURLSet.getActiveUrls());\n    if (urls.size() > 1) {\n      for (int i = 0; i < counter.get(); i++) {\n        urls.add(urls.remove(0));\n      }\n    }\n    urls.addAll(ldapURLSet.getInactiveUrls());\n    counter.incrementAndGet();\n    if (iterFunction != null) {\n      return iterFunction.apply(ldapURLSet.getUrls());\n    }\n    return new DefaultLdapURLIterator(urls);\n  }", "signature": "Iterator<LdapURL> iterator()", "full_signature": "@Override public synchronized Iterator<LdapURL> iterator()", "class_method_signature": "RoundRobinConnectionStrategy.iterator()", "testcase": false, "constructor": false, "invocations": ["isInitialized", "getActiveUrls", "size", "get", "add", "remove", "addAll", "getInactiveUrls", "incrementAndGet", "apply", "getUrls"]}, "repository": {"repo_id": 25927306, "url": "https://github.com/vt-middleware/ldaptive", "stars": 32, "created": "10/29/2014 3:27:31 PM +00:00", "updates": "2020-01-14T22:18:12+00:00", "fork": "False", "license": "licensed"}}