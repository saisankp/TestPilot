{"test_class": {"identifier": "StandaloneHerderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String CONNECTOR_NAME = \"test\";", "modifier": "private static final", "type": "String", "declarator": "CONNECTOR_NAME = \"test\"", "var_name": "CONNECTOR_NAME"}, {"original_string": "private static final List<String> TOPICS_LIST = Arrays.asList(\"topic1\", \"topic2\");", "modifier": "private static final", "type": "List<String>", "declarator": "TOPICS_LIST = Arrays.asList(\"topic1\", \"topic2\")", "var_name": "TOPICS_LIST"}, {"original_string": "private static final String TOPICS_LIST_STR = \"topic1,topic2\";", "modifier": "private static final", "type": "String", "declarator": "TOPICS_LIST_STR = \"topic1,topic2\"", "var_name": "TOPICS_LIST_STR"}, {"original_string": "private static final int DEFAULT_MAX_TASKS = 1;", "modifier": "private static final", "type": "int", "declarator": "DEFAULT_MAX_TASKS = 1", "var_name": "DEFAULT_MAX_TASKS"}, {"original_string": "private static final String WORKER_ID = \"localhost:8083\";", "modifier": "private static final", "type": "String", "declarator": "WORKER_ID = \"localhost:8083\"", "var_name": "WORKER_ID"}, {"original_string": "private StandaloneHerder herder;", "modifier": "private", "type": "StandaloneHerder", "declarator": "herder", "var_name": "herder"}, {"original_string": "private Connector connector;", "modifier": "private", "type": "Connector", "declarator": "connector", "var_name": "connector"}, {"original_string": "@Mock protected Worker worker;", "modifier": "@Mock protected", "type": "Worker", "declarator": "worker", "var_name": "worker"}, {"original_string": "@Mock protected Callback<Herder.Created<ConnectorInfo>> createCallback;", "modifier": "@Mock protected", "type": "Callback<Herder.Created<ConnectorInfo>>", "declarator": "createCallback", "var_name": "createCallback"}, {"original_string": "@Mock protected StatusBackingStore statusBackingStore;", "modifier": "@Mock protected", "type": "StatusBackingStore", "declarator": "statusBackingStore", "var_name": "statusBackingStore"}], "file": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/standalone/StandaloneHerderTest.java"}, "test_case": {"identifier": "testPutConnectorConfig", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testPutConnectorConfig() throws Exception {\n        Map<String, String> connConfig = connectorConfig(CONNECTOR_NAME, BogusSourceConnector.class, false);\n        Map<String, String> newConnConfig = new HashMap<>(connConfig);\n        newConnConfig.put(\"foo\", \"bar\");\n\n        Callback<Map<String, String>> connectorConfigCb = PowerMock.createMock(Callback.class);\n        Callback<Herder.Created<ConnectorInfo>> putConnectorConfigCb = PowerMock.createMock(Callback.class);\n\n        // Create\n        connector = PowerMock.createMock(BogusSourceConnector.class);\n        expectAdd(CONNECTOR_NAME, BogusSourceConnector.class, BogusSourceTask.class, false);\n        // Should get first config\n        connectorConfigCb.onCompletion(null, connConfig);\n        EasyMock.expectLastCall();\n        // Update config, which requires stopping and restarting\n        worker.stopConnector(CONNECTOR_NAME);\n        EasyMock.expectLastCall();\n        Capture<ConnectorConfig> capturedConfig = EasyMock.newCapture();\n        worker.startConnector(EasyMock.capture(capturedConfig), EasyMock.<ConnectorContext>anyObject(),\n                EasyMock.eq(herder), EasyMock.eq(TargetState.STARTED));\n        EasyMock.expectLastCall();\n        EasyMock.expect(worker.isRunning(CONNECTOR_NAME)).andReturn(true);\n        // Generate same task config, which should result in no additional action to restart tasks\n        EasyMock.expect(worker.connectorTaskConfigs(CONNECTOR_NAME, DEFAULT_MAX_TASKS, null))\n                .andReturn(Collections.singletonList(taskConfig(BogusSourceTask.class, false)));\n        worker.isSinkConnector(CONNECTOR_NAME);\n        EasyMock.expectLastCall().andReturn(false);\n        ConnectorInfo newConnInfo = new ConnectorInfo(CONNECTOR_NAME, newConnConfig, Arrays.asList(new ConnectorTaskId(CONNECTOR_NAME, 0)));\n        putConnectorConfigCb.onCompletion(null, new Herder.Created<>(false, newConnInfo));\n        EasyMock.expectLastCall();\n        // Should get new config\n        connectorConfigCb.onCompletion(null, newConnConfig);\n        EasyMock.expectLastCall();\n\n        PowerMock.replayAll();\n\n        herder.putConnectorConfig(CONNECTOR_NAME, connConfig, false, createCallback);\n        herder.connectorConfig(CONNECTOR_NAME, connectorConfigCb);\n        herder.putConnectorConfig(CONNECTOR_NAME, newConnConfig, true, putConnectorConfigCb);\n        assertEquals(\"bar\", capturedConfig.getValue().originals().get(\"foo\"));\n        herder.connectorConfig(CONNECTOR_NAME, connectorConfigCb);\n\n        PowerMock.verifyAll();\n\n    }", "signature": "void testPutConnectorConfig()", "full_signature": "@Test public void testPutConnectorConfig()", "class_method_signature": "StandaloneHerderTest.testPutConnectorConfig()", "testcase": true, "constructor": false, "invocations": ["connectorConfig", "put", "createMock", "createMock", "createMock", "expectAdd", "onCompletion", "expectLastCall", "stopConnector", "expectLastCall", "newCapture", "startConnector", "capture", "anyObject", "eq", "eq", "expectLastCall", "andReturn", "expect", "isRunning", "andReturn", "expect", "connectorTaskConfigs", "singletonList", "taskConfig", "isSinkConnector", "andReturn", "expectLastCall", "asList", "onCompletion", "expectLastCall", "onCompletion", "expectLastCall", "replayAll", "putConnectorConfig", "connectorConfig", "putConnectorConfig", "assertEquals", "get", "originals", "getValue", "connectorConfig", "verifyAll"]}, "focal_class": {"identifier": "StandaloneHerder", "superclass": "extends AbstractHerder", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(StandaloneHerder.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(StandaloneHerder.class)", "var_name": "log"}, {"original_string": "private ClusterConfigState configState;", "modifier": "private", "type": "ClusterConfigState", "declarator": "configState", "var_name": "configState"}], "methods": [{"identifier": "StandaloneHerder", "parameters": "(Worker worker)", "modifiers": "public", "return": "", "signature": " StandaloneHerder(Worker worker)", "full_signature": "public  StandaloneHerder(Worker worker)", "class_method_signature": "StandaloneHerder.StandaloneHerder(Worker worker)", "testcase": false, "constructor": true}, {"identifier": "StandaloneHerder", "parameters": "(Worker worker,\n                     String workerId,\n                     StatusBackingStore statusBackingStore,\n                     MemoryConfigBackingStore configBackingStore)", "modifiers": "", "return": "", "signature": " StandaloneHerder(Worker worker,\n                     String workerId,\n                     StatusBackingStore statusBackingStore,\n                     MemoryConfigBackingStore configBackingStore)", "full_signature": "  StandaloneHerder(Worker worker,\n                     String workerId,\n                     StatusBackingStore statusBackingStore,\n                     MemoryConfigBackingStore configBackingStore)", "class_method_signature": "StandaloneHerder.StandaloneHerder(Worker worker,\n                     String workerId,\n                     StatusBackingStore statusBackingStore,\n                     MemoryConfigBackingStore configBackingStore)", "testcase": false, "constructor": true}, {"identifier": "start", "parameters": "()", "modifiers": "public synchronized", "return": "void", "signature": "void start()", "full_signature": "public synchronized void start()", "class_method_signature": "StandaloneHerder.start()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "public synchronized", "return": "void", "signature": "void stop()", "full_signature": "public synchronized void stop()", "class_method_signature": "StandaloneHerder.stop()", "testcase": false, "constructor": false}, {"identifier": "generation", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int generation()", "full_signature": "@Override public int generation()", "class_method_signature": "StandaloneHerder.generation()", "testcase": false, "constructor": false}, {"identifier": "connectors", "parameters": "(Callback<Collection<String>> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void connectors(Callback<Collection<String>> callback)", "full_signature": "@Override public synchronized void connectors(Callback<Collection<String>> callback)", "class_method_signature": "StandaloneHerder.connectors(Callback<Collection<String>> callback)", "testcase": false, "constructor": false}, {"identifier": "connectorInfo", "parameters": "(String connName, Callback<ConnectorInfo> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void connectorInfo(String connName, Callback<ConnectorInfo> callback)", "full_signature": "@Override public synchronized void connectorInfo(String connName, Callback<ConnectorInfo> callback)", "class_method_signature": "StandaloneHerder.connectorInfo(String connName, Callback<ConnectorInfo> callback)", "testcase": false, "constructor": false}, {"identifier": "createConnectorInfo", "parameters": "(String connector)", "modifiers": "private", "return": "ConnectorInfo", "signature": "ConnectorInfo createConnectorInfo(String connector)", "full_signature": "private ConnectorInfo createConnectorInfo(String connector)", "class_method_signature": "StandaloneHerder.createConnectorInfo(String connector)", "testcase": false, "constructor": false}, {"identifier": "connectorConfig", "parameters": "(String connName, final Callback<Map<String, String>> callback)", "modifiers": "@Override public", "return": "void", "signature": "void connectorConfig(String connName, final Callback<Map<String, String>> callback)", "full_signature": "@Override public void connectorConfig(String connName, final Callback<Map<String, String>> callback)", "class_method_signature": "StandaloneHerder.connectorConfig(String connName, final Callback<Map<String, String>> callback)", "testcase": false, "constructor": false}, {"identifier": "putConnectorConfig", "parameters": "(String connName,\n                                                final Map<String, String> config,\n                                                boolean allowReplace,\n                                                final Callback<Created<ConnectorInfo>> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void putConnectorConfig(String connName,\n                                                final Map<String, String> config,\n                                                boolean allowReplace,\n                                                final Callback<Created<ConnectorInfo>> callback)", "full_signature": "@Override public synchronized void putConnectorConfig(String connName,\n                                                final Map<String, String> config,\n                                                boolean allowReplace,\n                                                final Callback<Created<ConnectorInfo>> callback)", "class_method_signature": "StandaloneHerder.putConnectorConfig(String connName,\n                                                final Map<String, String> config,\n                                                boolean allowReplace,\n                                                final Callback<Created<ConnectorInfo>> callback)", "testcase": false, "constructor": false}, {"identifier": "requestTaskReconfiguration", "parameters": "(String connName)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void requestTaskReconfiguration(String connName)", "full_signature": "@Override public synchronized void requestTaskReconfiguration(String connName)", "class_method_signature": "StandaloneHerder.requestTaskReconfiguration(String connName)", "testcase": false, "constructor": false}, {"identifier": "taskConfigs", "parameters": "(String connName, Callback<List<TaskInfo>> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void taskConfigs(String connName, Callback<List<TaskInfo>> callback)", "full_signature": "@Override public synchronized void taskConfigs(String connName, Callback<List<TaskInfo>> callback)", "class_method_signature": "StandaloneHerder.taskConfigs(String connName, Callback<List<TaskInfo>> callback)", "testcase": false, "constructor": false}, {"identifier": "putTaskConfigs", "parameters": "(String connName, List<Map<String, String>> configs, Callback<Void> callback)", "modifiers": "@Override public", "return": "void", "signature": "void putTaskConfigs(String connName, List<Map<String, String>> configs, Callback<Void> callback)", "full_signature": "@Override public void putTaskConfigs(String connName, List<Map<String, String>> configs, Callback<Void> callback)", "class_method_signature": "StandaloneHerder.putTaskConfigs(String connName, List<Map<String, String>> configs, Callback<Void> callback)", "testcase": false, "constructor": false}, {"identifier": "restartTask", "parameters": "(ConnectorTaskId taskId, Callback<Void> cb)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void restartTask(ConnectorTaskId taskId, Callback<Void> cb)", "full_signature": "@Override public synchronized void restartTask(ConnectorTaskId taskId, Callback<Void> cb)", "class_method_signature": "StandaloneHerder.restartTask(ConnectorTaskId taskId, Callback<Void> cb)", "testcase": false, "constructor": false}, {"identifier": "restartConnector", "parameters": "(String connName, Callback<Void> cb)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void restartConnector(String connName, Callback<Void> cb)", "full_signature": "@Override public synchronized void restartConnector(String connName, Callback<Void> cb)", "class_method_signature": "StandaloneHerder.restartConnector(String connName, Callback<Void> cb)", "testcase": false, "constructor": false}, {"identifier": "startConnector", "parameters": "(Map<String, String> connectorProps)", "modifiers": "private", "return": "String", "signature": "String startConnector(Map<String, String> connectorProps)", "full_signature": "private String startConnector(Map<String, String> connectorProps)", "class_method_signature": "StandaloneHerder.startConnector(Map<String, String> connectorProps)", "testcase": false, "constructor": false}, {"identifier": "recomputeTaskConfigs", "parameters": "(String connName)", "modifiers": "private", "return": "List<Map<String, String>>", "signature": "List<Map<String, String>> recomputeTaskConfigs(String connName)", "full_signature": "private List<Map<String, String>> recomputeTaskConfigs(String connName)", "class_method_signature": "StandaloneHerder.recomputeTaskConfigs(String connName)", "testcase": false, "constructor": false}, {"identifier": "createConnectorTasks", "parameters": "(String connName, TargetState initialState)", "modifiers": "private", "return": "void", "signature": "void createConnectorTasks(String connName, TargetState initialState)", "full_signature": "private void createConnectorTasks(String connName, TargetState initialState)", "class_method_signature": "StandaloneHerder.createConnectorTasks(String connName, TargetState initialState)", "testcase": false, "constructor": false}, {"identifier": "removeConnectorTasks", "parameters": "(String connName)", "modifiers": "private", "return": "void", "signature": "void removeConnectorTasks(String connName)", "full_signature": "private void removeConnectorTasks(String connName)", "class_method_signature": "StandaloneHerder.removeConnectorTasks(String connName)", "testcase": false, "constructor": false}, {"identifier": "updateConnectorTasks", "parameters": "(String connName)", "modifiers": "private", "return": "void", "signature": "void updateConnectorTasks(String connName)", "full_signature": "private void updateConnectorTasks(String connName)", "class_method_signature": "StandaloneHerder.updateConnectorTasks(String connName)", "testcase": false, "constructor": false}], "file": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/standalone/StandaloneHerder.java"}, "focal_method": {"identifier": "putConnectorConfig", "parameters": "(String connName,\n                                                final Map<String, String> config,\n                                                boolean allowReplace,\n                                                final Callback<Created<ConnectorInfo>> callback)", "modifiers": "@Override public synchronized", "return": "void", "body": "@Override\n    public synchronized void putConnectorConfig(String connName,\n                                                final Map<String, String> config,\n                                                boolean allowReplace,\n                                                final Callback<Created<ConnectorInfo>> callback) {\n        try {\n            boolean created = false;\n            if (configState.contains(connName)) {\n                if (!allowReplace) {\n                    callback.onCompletion(new AlreadyExistsException(\"Connector \" + connName + \" already exists\"), null);\n                    return;\n                }\n                if (config == null) // Deletion, kill tasks as well\n                    removeConnectorTasks(connName);\n                worker.stopConnector(connName);\n                if (config == null) {\n                    configBackingStore.removeConnectorConfig(connName);\n                    onDeletion(connName);\n                }\n            } else {\n                if (config == null) {\n                    // Deletion, must already exist\n                    callback.onCompletion(new NotFoundException(\"Connector \" + connName + \" not found\", null), null);\n                    return;\n                }\n                created = true;\n            }\n            if (config != null) {\n                startConnector(config);\n                updateConnectorTasks(connName);\n            }\n            if (config != null)\n                callback.onCompletion(null, new Created<>(created, createConnectorInfo(connName)));\n            else\n                callback.onCompletion(null, new Created<ConnectorInfo>(false, null));\n        } catch (ConnectException e) {\n            callback.onCompletion(e, null);\n        }\n\n    }", "signature": "void putConnectorConfig(String connName,\n                                                final Map<String, String> config,\n                                                boolean allowReplace,\n                                                final Callback<Created<ConnectorInfo>> callback)", "full_signature": "@Override public synchronized void putConnectorConfig(String connName,\n                                                final Map<String, String> config,\n                                                boolean allowReplace,\n                                                final Callback<Created<ConnectorInfo>> callback)", "class_method_signature": "StandaloneHerder.putConnectorConfig(String connName,\n                                                final Map<String, String> config,\n                                                boolean allowReplace,\n                                                final Callback<Created<ConnectorInfo>> callback)", "testcase": false, "constructor": false, "invocations": ["contains", "onCompletion", "removeConnectorTasks", "stopConnector", "removeConnectorConfig", "onDeletion", "onCompletion", "startConnector", "updateConnectorTasks", "onCompletion", "createConnectorInfo", "onCompletion", "onCompletion"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}