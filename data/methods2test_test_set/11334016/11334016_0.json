{"test_class": {"identifier": "CommandInterpreterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private CommandInterpreter commandInterpreter = new CommandInterpreter();", "modifier": "private", "type": "CommandInterpreter", "declarator": "commandInterpreter = new CommandInterpreter()", "var_name": "commandInterpreter"}], "file": "runtime/src/test/java/com/flipkart/phantom/runtime/impl/server/netty/handler/command/CommandInterpreterTest.java"}, "test_case": {"identifier": "testInterpretCommand", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testInterpretCommand() {\n\n        CommandInterpreter.ProxyCommand command;\n\n        // just command\n        command = getCommand(\"testCommand\\n\");\n        assertTrue(\"Command parsing failed\",command != null && command.getReadFailure() == null);\n        assertTrue(\"Parsed command mismatch: \"+command.getCommand(), \"testCommand\".equals(command.getCommand()));\n        assertTrue(\"Command parameters not empty\", command.getCommandParams().isEmpty());\n        assertTrue(\"Command data not empty\", command.getCommandData() == null);\n\n        // command + params\n        command = getCommand(\"testCommand p1=v1 p2=v2\\n\");\n        assertTrue(\"Command parsing failed\",command != null && command.getReadFailure() == null);\n        assertTrue(\"Parsed command mismatch: \"+command.getCommand(), \"testCommand\".equals(command.getCommand()));\n        assertTrue(\"Command parameters mismatch: \"+command.getCommandParams().size(), command.getCommandParams().size() == 2);\n        assertTrue(\"Command data not empty\", command.getCommandData() == null);\n\n        // command + params + different delim\n        command = getCommand(\"#testCommand#p1=v1#p2=v2\\n\");\n        assertTrue(\"Command parsing failed\",command != null && command.getReadFailure() == null);\n        assertTrue(\"Parsed command mismatch: \"+command.getCommand(), \"testCommand\".equals(command.getCommand()));\n        assertTrue(\"Command parameters mismatch: \"+command.getCommandParams().size(), command.getCommandParams().size() == 2);\n        assertTrue(\"Command data not empty\", command.getCommandData() == null);\n\n        // command + params + data\n        command = getCommand(\"testCommand p1=v1 p2=v2 8\\ntestData\");\n        assertTrue(\"Command parsing failed\",command != null && command.getReadFailure() == null);\n        assertTrue(\"Parsed command mismatch: \"+command.getCommand(), \"testCommand\".equals(command.getCommand()));\n        assertTrue(\"Command parameters mismatch: \"+command.getCommandParams().size(), command.getCommandParams().size() == 2);\n        assertTrue(\"Command data mismatch: \"+command.getCommandData(), \"testData\".equals(new String(command.getCommandData())));\n\n        // incorrect command - no newline\n        command = getCommand(\"testCommand p1=v1 p2=v2\");\n        assertTrue(\"Command parsing passed (which should not)\", command != null && command.getReadFailure() != null);\n\n        // incorrect command - data size mismatch\n        command = getCommand(\"testCommand p1=v1 p2=v2 10\\ntestData\");\n        assertTrue(\"Command parsing passed (which should not)\", command != null && command.getReadFailure() != null);\n\n    }", "signature": "void testInterpretCommand()", "full_signature": "@Test public void testInterpretCommand()", "class_method_signature": "CommandInterpreterTest.testInterpretCommand()", "testcase": true, "constructor": false, "invocations": ["getCommand", "assertTrue", "getReadFailure", "assertTrue", "getCommand", "equals", "getCommand", "assertTrue", "isEmpty", "getCommandParams", "assertTrue", "getCommandData", "getCommand", "assertTrue", "getReadFailure", "assertTrue", "getCommand", "equals", "getCommand", "assertTrue", "size", "getCommandParams", "size", "getCommandParams", "assertTrue", "getCommandData", "getCommand", "assertTrue", "getReadFailure", "assertTrue", "getCommand", "equals", "getCommand", "assertTrue", "size", "getCommandParams", "size", "getCommandParams", "assertTrue", "getCommandData", "getCommand", "assertTrue", "getReadFailure", "assertTrue", "getCommand", "equals", "getCommand", "assertTrue", "size", "getCommandParams", "size", "getCommandParams", "assertTrue", "getCommandData", "equals", "getCommandData", "getCommand", "assertTrue", "getReadFailure", "getCommand", "assertTrue", "getReadFailure"]}, "focal_class": {"identifier": "CommandInterpreter", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int MAX_COMMAND_INPUT = 20480;", "modifier": "public static final", "type": "int", "declarator": "MAX_COMMAND_INPUT = 20480", "var_name": "MAX_COMMAND_INPUT"}, {"original_string": "public static final char LINE_FEED = '\\n';", "modifier": "public static final", "type": "char", "declarator": "LINE_FEED = '\\n'", "var_name": "LINE_FEED"}, {"original_string": "private static final char CARRIAGE_RETURN = '\\r';", "modifier": "private static final", "type": "char", "declarator": "CARRIAGE_RETURN = '\\r'", "var_name": "CARRIAGE_RETURN"}, {"original_string": "private static final char DEFAULT_DELIM = ' ';", "modifier": "private static final", "type": "char", "declarator": "DEFAULT_DELIM = ' '", "var_name": "DEFAULT_DELIM"}, {"original_string": "private static final char PARAM_VALUE_SEP = '=';", "modifier": "private static final", "type": "char", "declarator": "PARAM_VALUE_SEP = '='", "var_name": "PARAM_VALUE_SEP"}, {"original_string": "private static final char[] ASCII_LOW = {'a','z'};", "modifier": "private static final", "type": "char[]", "declarator": "ASCII_LOW = {'a','z'}", "var_name": "ASCII_LOW"}, {"original_string": "private static final char[] ASCII_HIGH = {'A','Z'};", "modifier": "private static final", "type": "char[]", "declarator": "ASCII_HIGH = {'A','Z'}", "var_name": "ASCII_HIGH"}, {"original_string": "private static final String SUCCESS = \"SUCCESS\";", "modifier": "private static final", "type": "String", "declarator": "SUCCESS = \"SUCCESS\"", "var_name": "SUCCESS"}, {"original_string": "private static final String ERROR = \"ERROR\";", "modifier": "private static final", "type": "String", "declarator": "ERROR = \"ERROR\"", "var_name": "ERROR"}, {"original_string": "private static final String NULL_STRING = \"\";", "modifier": "private static final", "type": "String", "declarator": "NULL_STRING = \"\"", "var_name": "NULL_STRING"}, {"original_string": "private static final String DEFAULT_PARAM_VALUE = \"true\";", "modifier": "private static final", "type": "String", "declarator": "DEFAULT_PARAM_VALUE = \"true\"", "var_name": "DEFAULT_PARAM_VALUE"}, {"original_string": "private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();", "modifier": "private static final", "type": "ObjectMapper", "declarator": "OBJECT_MAPPER = new ObjectMapper()", "var_name": "OBJECT_MAPPER"}], "methods": [{"identifier": "readCommand", "parameters": "(InputStream inputStream)", "modifiers": "public", "return": "ProxyCommand", "signature": "ProxyCommand readCommand(InputStream inputStream)", "full_signature": "public ProxyCommand readCommand(InputStream inputStream)", "class_method_signature": "CommandInterpreter.readCommand(InputStream inputStream)", "testcase": false, "constructor": false}, {"identifier": "readCommand", "parameters": "(MessageEvent event)", "modifiers": "public", "return": "ProxyCommand", "signature": "ProxyCommand readCommand(MessageEvent event)", "full_signature": "public ProxyCommand readCommand(MessageEvent event)", "class_method_signature": "CommandInterpreter.readCommand(MessageEvent event)", "testcase": false, "constructor": false}, {"identifier": "interpretCommand", "parameters": "(ChannelBuffer buffer)", "modifiers": "public", "return": "ProxyCommand", "signature": "ProxyCommand interpretCommand(ChannelBuffer buffer)", "full_signature": "public ProxyCommand interpretCommand(ChannelBuffer buffer)", "class_method_signature": "CommandInterpreter.interpretCommand(ChannelBuffer buffer)", "testcase": false, "constructor": false}, {"identifier": "writeCommandExecutionResponse", "parameters": "(ChannelHandlerContext ctx, ChannelEvent event, TaskResult result)", "modifiers": "public", "return": "void", "signature": "void writeCommandExecutionResponse(ChannelHandlerContext ctx, ChannelEvent event, TaskResult result)", "full_signature": "public void writeCommandExecutionResponse(ChannelHandlerContext ctx, ChannelEvent event, TaskResult result)", "class_method_signature": "CommandInterpreter.writeCommandExecutionResponse(ChannelHandlerContext ctx, ChannelEvent event, TaskResult result)", "testcase": false, "constructor": false}, {"identifier": "writeCommandExecutionResponse", "parameters": "(OutputStream outputStream, TaskResult result)", "modifiers": "public", "return": "void", "signature": "void writeCommandExecutionResponse(OutputStream outputStream, TaskResult result)", "full_signature": "public void writeCommandExecutionResponse(OutputStream outputStream, TaskResult result)", "class_method_signature": "CommandInterpreter.writeCommandExecutionResponse(OutputStream outputStream, TaskResult result)", "testcase": false, "constructor": false}, {"identifier": "interpretCommand", "parameters": "(InputStream inputStream, boolean isFramedTransport)", "modifiers": "private", "return": "ProxyCommand", "signature": "ProxyCommand interpretCommand(InputStream inputStream, boolean isFramedTransport)", "full_signature": "private ProxyCommand interpretCommand(InputStream inputStream, boolean isFramedTransport)", "class_method_signature": "CommandInterpreter.interpretCommand(InputStream inputStream, boolean isFramedTransport)", "testcase": false, "constructor": false}, {"identifier": "getNextCommandFragmentPosition", "parameters": "(byte[] arr, int fragmentStart, int lastPos, byte delim)", "modifiers": "private", "return": "int", "signature": "int getNextCommandFragmentPosition(byte[] arr, int fragmentStart, int lastPos, byte delim)", "full_signature": "private int getNextCommandFragmentPosition(byte[] arr, int fragmentStart, int lastPos, byte delim)", "class_method_signature": "CommandInterpreter.getNextCommandFragmentPosition(byte[] arr, int fragmentStart, int lastPos, byte delim)", "testcase": false, "constructor": false}], "file": "runtime/src/main/java/com/flipkart/phantom/runtime/impl/server/netty/handler/command/CommandInterpreter.java"}, "focal_method": {"identifier": "interpretCommand", "parameters": "(ChannelBuffer buffer)", "modifiers": "public", "return": "ProxyCommand", "body": "public ProxyCommand interpretCommand(ChannelBuffer buffer) throws Exception {\n\t\treturn this.interpretCommand(new ChannelBufferInputStream(buffer), false);\n\t}", "signature": "ProxyCommand interpretCommand(ChannelBuffer buffer)", "full_signature": "public ProxyCommand interpretCommand(ChannelBuffer buffer)", "class_method_signature": "CommandInterpreter.interpretCommand(ChannelBuffer buffer)", "testcase": false, "constructor": false, "invocations": ["interpretCommand"]}, "repository": {"repo_id": 11334016, "url": "https://github.com/Flipkart/phantom", "language": "Java", "is_fork": false, "fork_count": 15, "stargazer_count": 41, "size": 3635, "license": "licensed"}}