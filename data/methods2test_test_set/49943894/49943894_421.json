{"test_class": {"identifier": "ApiServletTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Mock\n    ApiServer apiServer;", "modifier": "@Mock", "type": "ApiServer", "declarator": "apiServer", "var_name": "apiServer"}, {"original_string": "@Mock\n    HttpServletRequest request;", "modifier": "@Mock", "type": "HttpServletRequest", "declarator": "request", "var_name": "request"}, {"original_string": "@Mock\n    HttpServletResponse response;", "modifier": "@Mock", "type": "HttpServletResponse", "declarator": "response", "var_name": "response"}, {"original_string": "@Mock\n    AccountService accountService;", "modifier": "@Mock", "type": "AccountService", "declarator": "accountService", "var_name": "accountService"}, {"original_string": "@Mock\n    APIAuthenticationManager authManager;", "modifier": "@Mock", "type": "APIAuthenticationManager", "declarator": "authManager", "var_name": "authManager"}, {"original_string": "@Mock\n    APIAuthenticator authenticator;", "modifier": "@Mock", "type": "APIAuthenticator", "declarator": "authenticator", "var_name": "authenticator"}, {"original_string": "@Mock\n    User user;", "modifier": "@Mock", "type": "User", "declarator": "user", "var_name": "user"}, {"original_string": "@Mock\n    Account account;", "modifier": "@Mock", "type": "Account", "declarator": "account", "var_name": "account"}, {"original_string": "@Mock\n    HttpSession session;", "modifier": "@Mock", "type": "HttpSession", "declarator": "session", "var_name": "session"}, {"original_string": "@Mock\n    ManagementServer managementServer;", "modifier": "@Mock", "type": "ManagementServer", "declarator": "managementServer", "var_name": "managementServer"}, {"original_string": "StringWriter responseWriter;", "modifier": "", "type": "StringWriter", "declarator": "responseWriter", "var_name": "responseWriter"}, {"original_string": "ApiServlet servlet;", "modifier": "", "type": "ApiServlet", "declarator": "servlet", "var_name": "servlet"}], "file": "server/src/test/java/com/cloud/api/ApiServletTest.java"}, "test_case": {"identifier": "processRequestInContextLogout", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") @Test public", "return": "void", "body": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void processRequestInContextLogout() throws UnknownHostException {\n        Mockito.when(request.getMethod()).thenReturn(\"GET\");\n        Mockito.when(request.getSession(Mockito.anyBoolean())).thenReturn(\n                session);\n        Mockito.when(session.getAttribute(\"userid\")).thenReturn(1l);\n        Mockito.when(session.getAttribute(\"accountobj\")).thenReturn(account);\n        HashMap<String, String[]> params = new HashMap<String, String[]>();\n        params.put(ApiConstants.COMMAND, new String[] { \"logout\" });\n        Mockito.when(request.getParameterMap()).thenReturn(params);\n\n        Mockito.when(authenticator.getAPIType()).thenReturn(APIAuthenticationType.LOGOUT_API);\n\n        servlet.processRequestInContext(request, response);\n\n\n        Mockito.verify(authManager).getAPIAuthenticator(\"logout\");\n        Mockito.verify(authenticator).authenticate(Mockito.anyString(), Mockito.anyMap(), Mockito.isA(HttpSession.class),\n                Mockito.eq(InetAddress.getByName(\"127.0.0.1\")), Mockito.anyString(), Mockito.isA(StringBuilder.class), Mockito.isA(HttpServletRequest.class), Mockito.isA(HttpServletResponse.class));\n        Mockito.verify(session).invalidate();\n    }", "signature": "void processRequestInContextLogout()", "full_signature": "@SuppressWarnings(\"unchecked\") @Test public void processRequestInContextLogout()", "class_method_signature": "ApiServletTest.processRequestInContextLogout()", "testcase": true, "constructor": false, "invocations": ["thenReturn", "when", "getMethod", "thenReturn", "when", "getSession", "anyBoolean", "thenReturn", "when", "getAttribute", "thenReturn", "when", "getAttribute", "put", "thenReturn", "when", "getParameterMap", "thenReturn", "when", "getAPIType", "processRequestInContext", "getAPIAuthenticator", "verify", "authenticate", "verify", "anyString", "anyMap", "isA", "eq", "getByName", "anyString", "isA", "isA", "isA", "invalidate", "verify"]}, "focal_class": {"identifier": "ApiServlet", "superclass": "extends HttpServlet", "interfaces": "", "fields": [{"original_string": "public static final Logger s_logger = LoggerFactory.getLogger(ApiServlet.class.getName());", "modifier": "public static final", "type": "Logger", "declarator": "s_logger = LoggerFactory.getLogger(ApiServlet.class.getName())", "var_name": "s_logger"}, {"original_string": "private static final Logger s_accessLogger = LoggerFactory.getLogger(\"apiserver.\" + ApiServer.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "s_accessLogger = LoggerFactory.getLogger(\"apiserver.\" + ApiServer.class.getName())", "var_name": "s_accessLogger"}, {"original_string": "private final static List<String> s_clientAddressHeaders = Collections\n            .unmodifiableList(Arrays.asList(\"X-Forwarded-For\",\n                    \"HTTP_CLIENT_IP\", \"HTTP_X_FORWARDED_FOR\", \"Remote_Addr\"));", "modifier": "private final static", "type": "List<String>", "declarator": "s_clientAddressHeaders = Collections\n            .unmodifiableList(Arrays.asList(\"X-Forwarded-For\",\n                    \"HTTP_CLIENT_IP\", \"HTTP_X_FORWARDED_FOR\", \"Remote_Addr\"))", "var_name": "s_clientAddressHeaders"}, {"original_string": "@Inject\n    ApiServerService _apiServer;", "modifier": "@Inject", "type": "ApiServerService", "declarator": "_apiServer", "var_name": "_apiServer"}, {"original_string": "@Inject\n    AccountService _accountMgr;", "modifier": "@Inject", "type": "AccountService", "declarator": "_accountMgr", "var_name": "_accountMgr"}, {"original_string": "@Inject\n    EntityManager _entityMgr;", "modifier": "@Inject", "type": "EntityManager", "declarator": "_entityMgr", "var_name": "_entityMgr"}, {"original_string": "@Inject\n    ManagedContext _managedContext;", "modifier": "@Inject", "type": "ManagedContext", "declarator": "_managedContext", "var_name": "_managedContext"}, {"original_string": "@Inject\n    APIAuthenticationManager _authManager;", "modifier": "@Inject", "type": "APIAuthenticationManager", "declarator": "_authManager", "var_name": "_authManager"}], "methods": [{"identifier": "ApiServlet", "parameters": "()", "modifiers": "public", "return": "", "signature": " ApiServlet()", "full_signature": "public  ApiServlet()", "class_method_signature": "ApiServlet.ApiServlet()", "testcase": false, "constructor": true}, {"identifier": "init", "parameters": "(final ServletConfig config)", "modifiers": "@Override public", "return": "void", "signature": "void init(final ServletConfig config)", "full_signature": "@Override public void init(final ServletConfig config)", "class_method_signature": "ApiServlet.init(final ServletConfig config)", "testcase": false, "constructor": false}, {"identifier": "doGet", "parameters": "(final HttpServletRequest req, final HttpServletResponse resp)", "modifiers": "@Override protected", "return": "void", "signature": "void doGet(final HttpServletRequest req, final HttpServletResponse resp)", "full_signature": "@Override protected void doGet(final HttpServletRequest req, final HttpServletResponse resp)", "class_method_signature": "ApiServlet.doGet(final HttpServletRequest req, final HttpServletResponse resp)", "testcase": false, "constructor": false}, {"identifier": "doPost", "parameters": "(final HttpServletRequest req, final HttpServletResponse resp)", "modifiers": "@Override protected", "return": "void", "signature": "void doPost(final HttpServletRequest req, final HttpServletResponse resp)", "full_signature": "@Override protected void doPost(final HttpServletRequest req, final HttpServletResponse resp)", "class_method_signature": "ApiServlet.doPost(final HttpServletRequest req, final HttpServletResponse resp)", "testcase": false, "constructor": false}, {"identifier": "utf8Fixup", "parameters": "(final HttpServletRequest req, final Map<String, Object[]> params)", "modifiers": "", "return": "void", "signature": "void utf8Fixup(final HttpServletRequest req, final Map<String, Object[]> params)", "full_signature": " void utf8Fixup(final HttpServletRequest req, final Map<String, Object[]> params)", "class_method_signature": "ApiServlet.utf8Fixup(final HttpServletRequest req, final Map<String, Object[]> params)", "testcase": false, "constructor": false}, {"identifier": "decodeUtf8", "parameters": "(final String value)", "modifiers": "private", "return": "String", "signature": "String decodeUtf8(final String value)", "full_signature": "private String decodeUtf8(final String value)", "class_method_signature": "ApiServlet.decodeUtf8(final String value)", "testcase": false, "constructor": false}, {"identifier": "processRequest", "parameters": "(final HttpServletRequest req, final HttpServletResponse resp)", "modifiers": "private", "return": "void", "signature": "void processRequest(final HttpServletRequest req, final HttpServletResponse resp)", "full_signature": "private void processRequest(final HttpServletRequest req, final HttpServletResponse resp)", "class_method_signature": "ApiServlet.processRequest(final HttpServletRequest req, final HttpServletResponse resp)", "testcase": false, "constructor": false}, {"identifier": "processRequestInContext", "parameters": "(final HttpServletRequest req, final HttpServletResponse resp)", "modifiers": "", "return": "void", "signature": "void processRequestInContext(final HttpServletRequest req, final HttpServletResponse resp)", "full_signature": " void processRequestInContext(final HttpServletRequest req, final HttpServletResponse resp)", "class_method_signature": "ApiServlet.processRequestInContext(final HttpServletRequest req, final HttpServletResponse resp)", "testcase": false, "constructor": false}, {"identifier": "getClientAddress", "parameters": "(final HttpServletRequest request)", "modifiers": "static", "return": "String", "signature": "String getClientAddress(final HttpServletRequest request)", "full_signature": "static String getClientAddress(final HttpServletRequest request)", "class_method_signature": "ApiServlet.getClientAddress(final HttpServletRequest request)", "testcase": false, "constructor": false}, {"identifier": "getCorrectIPAddress", "parameters": "(String ip)", "modifiers": "private static", "return": "String", "signature": "String getCorrectIPAddress(String ip)", "full_signature": "private static String getCorrectIPAddress(String ip)", "class_method_signature": "ApiServlet.getCorrectIPAddress(String ip)", "testcase": false, "constructor": false}], "file": "server/src/main/java/com/cloud/api/ApiServlet.java"}, "focal_method": {"identifier": "processRequestInContext", "parameters": "(final HttpServletRequest req, final HttpServletResponse resp)", "modifiers": "", "return": "void", "body": "void processRequestInContext(final HttpServletRequest req, final HttpServletResponse resp) {\n        final String remoteAddress = getClientAddress(req);\n        final StringBuilder auditTrailSb = new StringBuilder(128);\n        auditTrailSb.append(\" \").append(remoteAddress);\n        auditTrailSb.append(\" -- \").append(req.getMethod()).append(' ');\n        // get the response format since we'll need it in a couple of places\n        String responseType = HttpUtils.RESPONSE_TYPE_XML;\n        final Map<String, Object[]> params = new HashMap<String, Object[]>();\n        params.putAll(req.getParameterMap());\n\n        // For HTTP GET requests, it seems that HttpServletRequest.getParameterMap() actually tries\n        // to unwrap URL encoded content from ISO-9959-1.\n        // After failed in using setCharacterEncoding() to control it, end up with following hacking:\n        // for all GET requests, we will override it with our-own way of UTF-8 based URL decoding.\n        utf8Fixup(req, params);\n\n        // logging the request start and end in management log for easy debugging\n        String reqStr = \"\";\n        String cleanQueryString = StringUtils.cleanString(req.getQueryString());\n        if (s_logger.isDebugEnabled()) {\n            reqStr = auditTrailSb.toString() + \" \" + cleanQueryString;\n            s_logger.debug(\"===START=== \" + reqStr);\n        }\n\n        try {\n\n            if (HttpUtils.RESPONSE_TYPE_JSON.equalsIgnoreCase(responseType)) {\n                resp.setContentType(ApiServer.getJSONContentType());\n            } else if (HttpUtils.RESPONSE_TYPE_XML.equalsIgnoreCase(responseType)){\n                resp.setContentType(HttpUtils.XML_CONTENT_TYPE);\n            }\n\n            HttpSession session = req.getSession(false);\n            final Object[] responseTypeParam = params.get(ApiConstants.RESPONSE);\n            if (responseTypeParam != null) {\n                responseType = (String)responseTypeParam[0];\n            }\n\n            final Object[] commandObj = params.get(ApiConstants.COMMAND);\n            if (commandObj != null) {\n                final String command = (String) commandObj[0];\n\n                APIAuthenticator apiAuthenticator = _authManager.getAPIAuthenticator(command);\n                if (apiAuthenticator != null) {\n                    auditTrailSb.append(\"command=\");\n                    auditTrailSb.append(command);\n\n                    int httpResponseCode = HttpServletResponse.SC_OK;\n                    String responseString = null;\n\n                    if (apiAuthenticator.getAPIType() == APIAuthenticationType.LOGIN_API) {\n                        if (session != null) {\n                            try {\n                                session.invalidate();\n                            } catch (final IllegalStateException ise) {\n                            }\n                        }\n                        session = req.getSession(true);\n                        if (ApiServer.isSecureSessionCookieEnabled()) {\n                            resp.setHeader(\"SET-COOKIE\", String.format(\"JSESSIONID=%s;Secure;HttpOnly;Path=/client\", session.getId()));\n                            if (s_logger.isDebugEnabled()) {\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(\"Session cookie is marked secure!\");\n                                }\n                            }\n                        }\n                    }\n\n                    try {\n                        responseString = apiAuthenticator.authenticate(command, params, session, InetAddress.getByName(remoteAddress), responseType, auditTrailSb, req, resp);\n                        if (session != null && session.getAttribute(ApiConstants.SESSIONKEY) != null) {\n                            resp.addHeader(\"SET-COOKIE\", String.format(\"%s=%s;HttpOnly\", ApiConstants.SESSIONKEY, session.getAttribute(ApiConstants.SESSIONKEY)));\n                        }\n                    } catch (ServerApiException e) {\n                        httpResponseCode = e.getErrorCode().getHttpCode();\n                        responseString = e.getMessage();\n                        s_logger.debug(\"Authentication failure: \" + e.getMessage());\n                    }\n\n                    if (apiAuthenticator.getAPIType() == APIAuthenticationType.LOGOUT_API) {\n                        if (session != null) {\n                            final Long userId = (Long) session.getAttribute(\"userid\");\n                            final Account account = (Account) session.getAttribute(\"accountobj\");\n                            Long accountId = null;\n                            if (account != null) {\n                                accountId = account.getId();\n                            }\n                            auditTrailSb.insert(0, \"(userId=\" + userId + \" accountId=\" + accountId + \" sessionId=\" + session.getId() + \")\");\n                            if (userId != null) {\n                                _apiServer.logoutUser(userId);\n                            }\n                            try {\n                                session.invalidate();\n                            } catch (final IllegalStateException ignored) {\n                            }\n                        }\n                        Cookie sessionKeyCookie = new Cookie(ApiConstants.SESSIONKEY, \"\");\n                        sessionKeyCookie.setMaxAge(0);\n                        resp.addCookie(sessionKeyCookie);\n                    }\n                    HttpUtils.writeHttpResponse(resp, responseString, httpResponseCode, responseType, ApiServer.getJSONContentType());\n                    return;\n                }\n            }\n\n            auditTrailSb.append(cleanQueryString);\n            final boolean isNew = ((session == null) ? true : session.isNew());\n\n            // Initialize an empty context and we will update it after we have verified the request below,\n            // we no longer rely on web-session here, verifyRequest will populate user/account information\n            // if a API key exists\n            Long userId = null;\n\n            if (!isNew) {\n                userId = (Long)session.getAttribute(\"userid\");\n                final String account = (String) session.getAttribute(\"account\");\n                final Object accountObj = session.getAttribute(\"accountobj\");\n                if (!HttpUtils.validateSessionKey(session, params, req.getCookies(), ApiConstants.SESSIONKEY)) {\n                    try {\n                        session.invalidate();\n                    } catch (final IllegalStateException ise) {\n                    }\n                    auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"unable to verify user credentials\");\n                    final String serializedResponse =\n                        _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials\", params, responseType);\n                    HttpUtils.writeHttpResponse(resp, serializedResponse, HttpServletResponse.SC_UNAUTHORIZED, responseType, ApiServer.getJSONContentType());\n                    return;\n                }\n\n                // Do a sanity check here to make sure the user hasn't already been deleted\n                if ((userId != null) && (account != null) && (accountObj != null) && _apiServer.verifyUser(userId)) {\n                    final String[] command = (String[])params.get(ApiConstants.COMMAND);\n                    if (command == null) {\n                        s_logger.info(\"missing command, ignoring request...\");\n                        auditTrailSb.append(\" \" + HttpServletResponse.SC_BAD_REQUEST + \" \" + \"no command specified\");\n                        final String serializedResponse = _apiServer.getSerializedApiError(HttpServletResponse.SC_BAD_REQUEST, \"no command specified\", params, responseType);\n                        HttpUtils.writeHttpResponse(resp, serializedResponse, HttpServletResponse.SC_BAD_REQUEST, responseType, ApiServer.getJSONContentType());\n                        return;\n                    }\n                    final User user = _entityMgr.findById(User.class, userId);\n                    CallContext.register(user, (Account)accountObj);\n                } else {\n                    // Invalidate the session to ensure we won't allow a request across management server\n                    // restarts if the userId was serialized to the stored session\n                    try {\n                        session.invalidate();\n                    } catch (final IllegalStateException ise) {\n                    }\n\n                    auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"unable to verify user credentials\");\n                    final String serializedResponse =\n                        _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials\", params, responseType);\n                    HttpUtils.writeHttpResponse(resp, serializedResponse, HttpServletResponse.SC_UNAUTHORIZED, responseType, ApiServer.getJSONContentType());\n                    return;\n                }\n            } else {\n                CallContext.register(_accountMgr.getSystemUser(), _accountMgr.getSystemAccount());\n            }\n\n            if (_apiServer.verifyRequest(params, userId)) {\n                auditTrailSb.insert(0, \"(userId=\" + CallContext.current().getCallingUserId() + \" accountId=\" + CallContext.current().getCallingAccount().getId() +\n                    \" sessionId=\" + (session != null ? session.getId() : null) + \")\");\n\n                // Add the HTTP method (GET/POST/PUT/DELETE) as well into the params map.\n                params.put(\"httpmethod\", new String[] {req.getMethod()});\n                final String response = _apiServer.handleRequest(params, responseType, auditTrailSb);\n                HttpUtils.writeHttpResponse(resp, response != null ? response : \"\", HttpServletResponse.SC_OK, responseType, ApiServer.getJSONContentType());\n            } else {\n                if (session != null) {\n                    try {\n                        session.invalidate();\n                    } catch (final IllegalStateException ise) {\n                    }\n                }\n\n                auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"unable to verify user credentials and/or request signature\");\n                final String serializedResponse =\n                    _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials and/or request signature\", params,\n                        responseType);\n                HttpUtils.writeHttpResponse(resp, serializedResponse, HttpServletResponse.SC_UNAUTHORIZED, responseType, ApiServer.getJSONContentType());\n\n            }\n        } catch (final ServerApiException se) {\n            final String serializedResponseText = _apiServer.getSerializedApiError(se, params, responseType);\n            resp.setHeader(\"X-Description\", se.getDescription());\n            HttpUtils.writeHttpResponse(resp, serializedResponseText, se.getErrorCode().getHttpCode(), responseType, ApiServer.getJSONContentType());\n            auditTrailSb.append(\" \" + se.getErrorCode() + \" \" + se.getDescription());\n        } catch (final Exception ex) {\n            s_logger.error(\"unknown exception writing api response\", ex);\n            auditTrailSb.append(\" unknown exception writing api response\");\n        } finally {\n            s_accessLogger.info(auditTrailSb.toString());\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"===END=== \" + reqStr);\n            }\n            // cleanup user context to prevent from being peeked in other request context\n            CallContext.unregister();\n        }\n    }", "signature": "void processRequestInContext(final HttpServletRequest req, final HttpServletResponse resp)", "full_signature": " void processRequestInContext(final HttpServletRequest req, final HttpServletResponse resp)", "class_method_signature": "ApiServlet.processRequestInContext(final HttpServletRequest req, final HttpServletResponse resp)", "testcase": false, "constructor": false, "invocations": ["getClientAddress", "append", "append", "append", "append", "append", "getMethod", "putAll", "getParameterMap", "utf8Fixup", "cleanString", "getQueryString", "isDebugEnabled", "toString", "debug", "equalsIgnoreCase", "setContentType", "getJSONContentType", "equalsIgnoreCase", "setContentType", "getSession", "get", "get", "getAPIAuthenticator", "append", "append", "getAPIType", "invalidate", "getSession", "isSecureSessionCookieEnabled", "setHeader", "format", "getId", "isDebugEnabled", "isDebugEnabled", "debug", "authenticate", "getByName", "getAttribute", "addHeader", "format", "getAttribute", "getHttpCode", "getErrorCode", "getMessage", "debug", "getMessage", "getAPIType", "getAttribute", "getAttribute", "getId", "insert", "getId", "logoutUser", "invalidate", "setMaxAge", "addCookie", "writeHttpResponse", "getJSONContentType", "append", "isNew", "getAttribute", "getAttribute", "getAttribute", "validateSessionKey", "getCookies", "invalidate", "append", "getSerializedApiError", "writeHttpResponse", "getJSONContentType", "verifyUser", "get", "info", "append", "getSerializedApiError", "writeHttpResponse", "getJSONContentType", "findById", "register", "invalidate", "append", "getSerializedApiError", "writeHttpResponse", "getJSONContentType", "register", "getSystemUser", "getSystemAccount", "verifyRequest", "insert", "getCallingUserId", "current", "getId", "getCallingAccount", "current", "getId", "put", "getMethod", "handleRequest", "writeHttpResponse", "getJSONContentType", "invalidate", "append", "getSerializedApiError", "writeHttpResponse", "getJSONContentType", "getSerializedApiError", "setHeader", "getDescription", "writeHttpResponse", "getHttpCode", "getErrorCode", "getJSONContentType", "append", "getErrorCode", "getDescription", "error", "append", "info", "toString", "isDebugEnabled", "debug", "unregister"]}, "repository": {"repo_id": 49943894, "url": "https://github.com/MissionCriticalCloudOldRepos/cosmic-core", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 9, "size": 18165, "license": "licensed"}}