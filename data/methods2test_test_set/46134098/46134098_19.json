{"test_class": {"identifier": "JsonResourceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final File INPUT_FILE = new File(\"src/test/resource/resfilter/json/input.json\");", "modifier": "private static final", "type": "File", "declarator": "INPUT_FILE = new File(\"src/test/resource/resfilter/json/input.json\")", "var_name": "INPUT_FILE"}, {"original_string": "private static final File OUTPUT_FILE = new File(\"src/test/resource/resfilter/json/output.json\");", "modifier": "private static final", "type": "File", "declarator": "OUTPUT_FILE = new File(\"src/test/resource/resfilter/json/output.json\")", "var_name": "OUTPUT_FILE"}, {"original_string": "private static final File INPUT_FILE2 = new File(\"src/test/resource/resfilter/json/other-input.json\");", "modifier": "private static final", "type": "File", "declarator": "INPUT_FILE2 = new File(\"src/test/resource/resfilter/json/other-input.json\")", "var_name": "INPUT_FILE2"}, {"original_string": "private static final File SPLITKEYS = new File(\"src/test/resource/resfilter/json/testSplitKeys.json\");", "modifier": "private static final", "type": "File", "declarator": "SPLITKEYS = new File(\"src/test/resource/resfilter/json/testSplitKeys.json\")", "var_name": "SPLITKEYS"}, {"original_string": "private static final File EXPECTED_WRITE_FILE = new File(\"src/test/resource/resfilter/json/write-output.json\");", "modifier": "private static final", "type": "File", "declarator": "EXPECTED_WRITE_FILE = new File(\"src/test/resource/resfilter/json/write-output.json\")", "var_name": "EXPECTED_WRITE_FILE"}, {"original_string": "private static final Collection<ResourceString> EXPECTED_INPUT_RES_LIST;", "modifier": "private static final", "type": "Collection<ResourceString>", "declarator": "EXPECTED_INPUT_RES_LIST", "var_name": "EXPECTED_INPUT_RES_LIST"}, {"original_string": "private static LanguageBundle WRITE_BUNDLE;", "modifier": "private static", "type": "LanguageBundle", "declarator": "WRITE_BUNDLE", "var_name": "WRITE_BUNDLE"}, {"original_string": "private static final JsonResource res = new JsonResource();", "modifier": "private static final", "type": "JsonResource", "declarator": "res = new JsonResource()", "var_name": "res"}], "file": "gp-res-filter/src/test/java/com/ibm/g11n/pipeline/resfilter/impl/JsonResourceTest.java"}, "test_case": {"identifier": "testWrite", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testWrite() throws IOException, ResourceFilterException {\n        File tempFile = File.createTempFile(this.getClass().getSimpleName(), \".json\");\n        tempFile.deleteOnExit();\n\n        try (OutputStream os = new FileOutputStream(tempFile)) {\n            res.write(os, WRITE_BUNDLE, null);\n            os.flush();\n            ResourceTestUtil.compareFilesJson(EXPECTED_WRITE_FILE, tempFile);\n        }\n    }", "signature": "void testWrite()", "full_signature": "@Test public void testWrite()", "class_method_signature": "JsonResourceTest.testWrite()", "testcase": true, "constructor": false, "invocations": ["createTempFile", "getSimpleName", "getClass", "deleteOnExit", "write", "flush", "compareFilesJson"]}, "focal_class": {"identifier": "JsonResource", "superclass": "extends ResourceFilter", "interfaces": "", "fields": [{"original_string": "private static final String JSONPATH_ROOT = \"$\";", "modifier": "private static final", "type": "String", "declarator": "JSONPATH_ROOT = \"$\"", "var_name": "JSONPATH_ROOT"}, {"original_string": "private static final Pattern USE_JSONPATH_PATTERN = Pattern.compile(\"^\\\\$[.\\\\[].*\");", "modifier": "private static final", "type": "Pattern", "declarator": "USE_JSONPATH_PATTERN = Pattern.compile(\"^\\\\$[.\\\\[].*\")", "var_name": "USE_JSONPATH_PATTERN"}, {"original_string": "private static final Pattern USE_BRACKET_PATTERN = Pattern.compile(\"[.'\\\\[\\\\]]\");", "modifier": "private static final", "type": "Pattern", "declarator": "USE_BRACKET_PATTERN = Pattern.compile(\"[.'\\\\[\\\\]]\")", "var_name": "USE_BRACKET_PATTERN"}], "methods": [{"identifier": "parse", "parameters": "(InputStream inStream, FilterOptions options)", "modifiers": "@Override public", "return": "LanguageBundle", "signature": "LanguageBundle parse(InputStream inStream, FilterOptions options)", "full_signature": "@Override public LanguageBundle parse(InputStream inStream, FilterOptions options)", "class_method_signature": "JsonResource.parse(InputStream inStream, FilterOptions options)", "testcase": false, "constructor": false}, {"identifier": "addBundleStrings", "parameters": "(JsonObject obj, String keyPrefix, LanguageBundleBuilder bb, int sequenceNum)", "modifiers": "protected", "return": "int", "signature": "int addBundleStrings(JsonObject obj, String keyPrefix, LanguageBundleBuilder bb, int sequenceNum)", "full_signature": "protected int addBundleStrings(JsonObject obj, String keyPrefix, LanguageBundleBuilder bb, int sequenceNum)", "class_method_signature": "JsonResource.addBundleStrings(JsonObject obj, String keyPrefix, LanguageBundleBuilder bb, int sequenceNum)", "testcase": false, "constructor": false}, {"identifier": "encodeResourceKey", "parameters": "(String parent, String key, boolean isLeaf)", "modifiers": "protected", "return": "String", "signature": "String encodeResourceKey(String parent, String key, boolean isLeaf)", "full_signature": "protected String encodeResourceKey(String parent, String key, boolean isLeaf)", "class_method_signature": "JsonResource.encodeResourceKey(String parent, String key, boolean isLeaf)", "testcase": false, "constructor": false}, {"identifier": "write", "parameters": "(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "modifiers": "@Override public", "return": "void", "signature": "void write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "full_signature": "@Override public void write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "class_method_signature": "JsonResource.write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "testcase": false, "constructor": false}, {"identifier": "splitKeyPieces", "parameters": "(String key)", "modifiers": "static", "return": "List<KeyPiece>", "signature": "List<KeyPiece> splitKeyPieces(String key)", "full_signature": "static List<KeyPiece> splitKeyPieces(String key)", "class_method_signature": "JsonResource.splitKeyPieces(String key)", "testcase": false, "constructor": false}, {"identifier": "addToken", "parameters": "(List<KeyPiece> result, String s, boolean inSubscript)", "modifiers": "static", "return": "void", "signature": "void addToken(List<KeyPiece> result, String s, boolean inSubscript)", "full_signature": "static void addToken(List<KeyPiece> result, String s, boolean inSubscript)", "class_method_signature": "JsonResource.addToken(List<KeyPiece> result, String s, boolean inSubscript)", "testcase": false, "constructor": false}], "file": "gp-res-filter/src/main/java/com/ibm/g11n/pipeline/resfilter/impl/JsonResource.java"}, "focal_method": {"identifier": "write", "parameters": "(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options) throws IOException, ResourceFilterException {\n        // extracts key value pairs in original sequence order\n        List<ResourceString> resStrings = languageBundle.getSortedResourceStrings();\n\n        JsonObject output = new JsonObject();\n        JsonObject top_level;\n\n        if (this instanceof GlobalizeJsResource) {\n            String resLanguageCode = languageBundle.getEmbeddedLanguageCode();\n            if (resLanguageCode == null || resLanguageCode.isEmpty()) {\n                throw new ResourceFilterException(\"Missing resource language code in the specified language bundle.\");\n            }\n            top_level = new JsonObject();\n            top_level.add(resLanguageCode, output);\n        } else {\n            top_level = output;\n        }\n\n        for (ResourceString res : resStrings) {\n            String key = res.getKey();\n            List<KeyPiece> keyPieces = splitKeyPieces(key);\n            JsonElement current = output;\n            for (int i = 0; i < keyPieces.size(); i++) {\n                if (i + 1 < keyPieces.size()) { // There is structure under this\n                                                // key piece\n                    if (current.isJsonObject()) {\n                        JsonObject currentObject = current.getAsJsonObject();\n                        if (!currentObject.has(keyPieces.get(i).keyValue)) {\n                            if (keyPieces.get(i + 1).keyType == JsonToken.BEGIN_ARRAY) {\n                                currentObject.add(keyPieces.get(i).keyValue, new JsonArray());\n                            } else {\n                                currentObject.add(keyPieces.get(i).keyValue, new JsonObject());\n                            }\n                        }\n                        current = currentObject.get(keyPieces.get(i).keyValue);\n                    } else {\n                        JsonArray currentArray = current.getAsJsonArray();\n                        Integer idx = Integer.valueOf(keyPieces.get(i).keyValue);\n                        for (int arrayIndex = currentArray.size(); arrayIndex <= idx; arrayIndex++) {\n                            currentArray.add(JsonNull.INSTANCE);\n                        }\n                        if (currentArray.get(idx).isJsonNull()) {\n                            if (keyPieces.get(i + 1).keyType == JsonToken.BEGIN_ARRAY) {\n                                currentArray.set(idx, new JsonArray());\n                            } else {\n                                currentArray.set(idx, new JsonObject());\n                            }\n                        }\n                        current = currentArray.get(idx);\n                    }\n                } else { // This is the leaf node\n                    if (keyPieces.get(i).keyType == JsonToken.BEGIN_ARRAY) {\n                        JsonArray currentArray = current.getAsJsonArray();\n                        Integer idx = Integer.valueOf(keyPieces.get(i).keyValue);\n                        JsonPrimitive e = new JsonPrimitive(res.getValue());\n                        for (int arrayIndex = currentArray.size(); arrayIndex <= idx; arrayIndex++) {\n                            currentArray.add(JsonNull.INSTANCE);\n                        }\n                        current.getAsJsonArray().set(idx, e);\n                    } else {\n                        current.getAsJsonObject().addProperty(keyPieces.get(i).keyValue, res.getValue());\n                    }\n                }\n            }\n        }\n        try (OutputStreamWriter writer = new OutputStreamWriter(new BufferedOutputStream(outStream),\n                StandardCharsets.UTF_8)) {\n            new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create().toJson(top_level, writer);\n        }\n    }", "signature": "void write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "full_signature": "@Override public void write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "class_method_signature": "JsonResource.write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "testcase": false, "constructor": false, "invocations": ["getSortedResourceStrings", "getEmbeddedLanguageCode", "isEmpty", "add", "getKey", "splitKeyPieces", "size", "size", "isJsonObject", "getAsJsonObject", "has", "get", "get", "add", "get", "add", "get", "get", "get", "getAsJsonArray", "valueOf", "get", "size", "add", "isJsonNull", "get", "get", "set", "set", "get", "get", "getAsJsonArray", "valueOf", "get", "getValue", "size", "add", "set", "getAsJsonArray", "addProperty", "getAsJsonObject", "get", "getValue", "toJson", "create", "disableHtmlEscaping", "setPrettyPrinting"]}, "repository": {"repo_id": 46134098, "url": "https://github.com/IBM-Cloud/gp-java-tools", "language": "Java", "is_fork": false, "fork_count": 16, "stargazer_count": 9, "size": 6216, "license": "licensed"}}