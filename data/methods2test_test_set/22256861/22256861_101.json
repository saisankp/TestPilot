{"test_class": {"identifier": "SlstrPduStitcherTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private File targetDirectory;", "modifier": "private", "type": "File", "declarator": "targetDirectory", "var_name": "targetDirectory"}], "file": "s3tbx-slstr-pdu-stitching/src/test/java/org/esa/s3tbx/slstr/pdu/stitching/SlstrPduStitcherTest.java"}, "test_case": {"identifier": "testStitchPDUs_NotEmpty", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testStitchPDUs_NotEmpty() {\n        try {\n            SlstrPduStitcher.createStitchedSlstrL1BFile(targetDirectory, new File[0], null, ProgressMonitor.NULL);\n            fail(\"Exception expected\");\n        } catch (Exception e) {\n            assertEquals(\"No product files provided\", e.getMessage());\n        }\n    }", "signature": "void testStitchPDUs_NotEmpty()", "full_signature": "@Test public void testStitchPDUs_NotEmpty()", "class_method_signature": "SlstrPduStitcherTest.testStitchPDUs_NotEmpty()", "testcase": true, "constructor": false, "invocations": ["createStitchedSlstrL1BFile", "fail", "assertEquals", "getMessage"]}, "focal_class": {"identifier": "SlstrPduStitcher", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final DateFormatConverter SLSTR_DATE_FORMAT_CONVERTER =\n            new DateFormatConverter(new SimpleDateFormat(\"yyyyMMdd'T'HHmmss\"));", "modifier": "private static final", "type": "DateFormatConverter", "declarator": "SLSTR_DATE_FORMAT_CONVERTER =\n            new DateFormatConverter(new SimpleDateFormat(\"yyyyMMdd'T'HHmmss\"))", "var_name": "SLSTR_DATE_FORMAT_CONVERTER"}, {"original_string": "private static final ImageSize NULL_IMAGE_SIZE = new ImageSize(\"null\", 0, 0, 0, 0);", "modifier": "private static final", "type": "ImageSize", "declarator": "NULL_IMAGE_SIZE = new ImageSize(\"null\", 0, 0, 0, 0)", "var_name": "NULL_IMAGE_SIZE"}], "methods": [{"identifier": "createStitchedSlstrL1BFile", "parameters": "(File targetDirectory, File[] slstrProductFiles, String productName,\n                                                  ProgressMonitor pm)", "modifiers": "public static", "return": "File", "signature": "File createStitchedSlstrL1BFile(File targetDirectory, File[] slstrProductFiles, String productName,\n                                                  ProgressMonitor pm)", "full_signature": "public static File createStitchedSlstrL1BFile(File targetDirectory, File[] slstrProductFiles, String productName,\n                                                  ProgressMonitor pm)", "class_method_signature": "SlstrPduStitcher.createStitchedSlstrL1BFile(File targetDirectory, File[] slstrProductFiles, String productName,\n                                                  ProgressMonitor pm)", "testcase": false, "constructor": false}, {"identifier": "createManifestFile", "parameters": "(File[] manifestFiles, File stitchedParentDirectory, Date now, long productSize)", "modifiers": "private static", "return": "File", "signature": "File createManifestFile(File[] manifestFiles, File stitchedParentDirectory, Date now, long productSize)", "full_signature": "private static File createManifestFile(File[] manifestFiles, File stitchedParentDirectory, Date now, long productSize)", "class_method_signature": "SlstrPduStitcher.createManifestFile(File[] manifestFiles, File stitchedParentDirectory, Date now, long productSize)", "testcase": false, "constructor": false}, {"identifier": "collectFiles", "parameters": "(List<String> ncFileNames, Document manifestDocument)", "modifiers": "static", "return": "void", "signature": "void collectFiles(List<String> ncFileNames, Document manifestDocument)", "full_signature": "static void collectFiles(List<String> ncFileNames, Document manifestDocument)", "class_method_signature": "SlstrPduStitcher.collectFiles(List<String> ncFileNames, Document manifestDocument)", "testcase": false, "constructor": false}, {"identifier": "createXmlDocument", "parameters": "(InputStream inputStream)", "modifiers": "static", "return": "Document", "signature": "Document createXmlDocument(InputStream inputStream)", "full_signature": "static Document createXmlDocument(InputStream inputStream)", "class_method_signature": "SlstrPduStitcher.createXmlDocument(InputStream inputStream)", "testcase": false, "constructor": false}, {"identifier": "createParentDirectoryNameOfStitchedFile", "parameters": "(SlstrNameDecomposition[] slstrNameDecompositions, Date now)", "modifiers": "static", "return": "String", "signature": "String createParentDirectoryNameOfStitchedFile(SlstrNameDecomposition[] slstrNameDecompositions, Date now)", "full_signature": "static String createParentDirectoryNameOfStitchedFile(SlstrNameDecomposition[] slstrNameDecompositions, Date now)", "class_method_signature": "SlstrPduStitcher.createParentDirectoryNameOfStitchedFile(SlstrNameDecomposition[] slstrNameDecompositions, Date now)", "testcase": false, "constructor": false}, {"identifier": "extractStartTime", "parameters": "(SlstrNameDecomposition[] slstrNameDecompositions)", "modifiers": "private static", "return": "Date", "signature": "Date extractStartTime(SlstrNameDecomposition[] slstrNameDecompositions)", "full_signature": "private static Date extractStartTime(SlstrNameDecomposition[] slstrNameDecompositions)", "class_method_signature": "SlstrPduStitcher.extractStartTime(SlstrNameDecomposition[] slstrNameDecompositions)", "testcase": false, "constructor": false}, {"identifier": "extractStopTime", "parameters": "(SlstrNameDecomposition[] slstrNameDecompositions)", "modifiers": "private static", "return": "Date", "signature": "Date extractStopTime(SlstrNameDecomposition[] slstrNameDecompositions)", "full_signature": "private static Date extractStopTime(SlstrNameDecomposition[] slstrNameDecompositions)", "class_method_signature": "SlstrPduStitcher.extractStopTime(SlstrNameDecomposition[] slstrNameDecompositions)", "testcase": false, "constructor": false}, {"identifier": "decomposeSlstrName", "parameters": "(String slstrName)", "modifiers": "static", "return": "SlstrNameDecomposition", "signature": "SlstrNameDecomposition decomposeSlstrName(String slstrName)", "full_signature": "static SlstrNameDecomposition decomposeSlstrName(String slstrName)", "class_method_signature": "SlstrPduStitcher.decomposeSlstrName(String slstrName)", "testcase": false, "constructor": false}], "file": "s3tbx-slstr-pdu-stitching/src/main/java/org/esa/s3tbx/slstr/pdu/stitching/SlstrPduStitcher.java"}, "focal_method": {"identifier": "createStitchedSlstrL1BFile", "parameters": "(File targetDirectory, File[] slstrProductFiles, String productName,\n                                                  ProgressMonitor pm)", "modifiers": "public static", "return": "File", "body": "public static File createStitchedSlstrL1BFile(File targetDirectory, File[] slstrProductFiles, String productName,\n                                                  ProgressMonitor pm)\n            throws IllegalArgumentException, IOException, PDUStitchingException,\n            ParserConfigurationException,  TransformerException {\n        Assert.notNull(slstrProductFiles);\n        final Logger logger = EngineConfig.instance().logger();\n        Validator.validateSlstrProductFiles(slstrProductFiles);\n\n        final Date now = Calendar.getInstance().getTime();\n        if (slstrProductFiles.length == 1) {\n            final File originalParentDirectory = slstrProductFiles[0].getParentFile();\n            final String parentDirectoryName = originalParentDirectory.getName();\n            File stitchedParentDirectory;\n            if (productName == null) {\n                stitchedParentDirectory = new File(targetDirectory, parentDirectoryName);\n            } else {\n                stitchedParentDirectory = new File(targetDirectory, productName);\n            }\n            if (stitchedParentDirectory.exists()) {\n                throw new PDUStitchingException(\"Target file directory already exists\");\n            }\n            Files.copy(originalParentDirectory.getParentFile().toPath(), stitchedParentDirectory.toPath());\n            final File[] files = originalParentDirectory.listFiles();\n            long productSize = 0;\n            if (files != null) {\n                for (File originalFile : files) {\n                    final File newFile = new File(stitchedParentDirectory, originalFile.getName());\n                    Files.copy(originalFile.toPath(), newFile.toPath());\n                    productSize += newFile.length();\n                }\n            }\n            return createManifestFile(slstrProductFiles, stitchedParentDirectory, now, productSize);\n        }\n        SlstrNameDecomposition[] slstrNameDecompositions = new SlstrNameDecomposition[slstrProductFiles.length];\n        Document[] manifestDocuments = new Document[slstrProductFiles.length];\n        List<String> ncFileNames = new ArrayList<>();\n        Map<String, ImageSize[]> idToImageSizes = new HashMap<>();\n        for (int i = 0; i < slstrProductFiles.length; i++) {\n            slstrNameDecompositions[i] = decomposeSlstrName(slstrProductFiles[i].getParentFile().getName());\n            manifestDocuments[i] = createXmlDocument(new FileInputStream(slstrProductFiles[i]));\n            final ImageSize[] imageSizes = ImageSizeHandler.extractImageSizes(manifestDocuments[i]);\n            for (ImageSize imageSize : imageSizes) {\n                if (idToImageSizes.containsKey(imageSize.getIdentifier())) {\n                    idToImageSizes.get(imageSize.getIdentifier())[i] = imageSize;\n                } else {\n                    final ImageSize[] mapImageSizes = new ImageSize[slstrProductFiles.length];\n                    mapImageSizes[i] = imageSize;\n                    idToImageSizes.put(imageSize.getIdentifier(), mapImageSizes);\n                }\n            }\n            collectFiles(ncFileNames, manifestDocuments[i]);\n        }\n        Validator.validateOrbitReference(manifestDocuments);\n        Validator.validateAdjacency(manifestDocuments);\n        String stitchedProductFileName = productName;\n        if (stitchedProductFileName == null) {\n            stitchedProductFileName = createParentDirectoryNameOfStitchedFile(slstrNameDecompositions, now);\n        }\n        File stitchedProductFileParentDirectory = new File(targetDirectory, stitchedProductFileName);\n        if (stitchedProductFileParentDirectory.exists()) {\n            throw new PDUStitchingException(\"Target file directory already exists\");\n        }\n        if (!stitchedProductFileParentDirectory.mkdirs()) {\n            throw new PDUStitchingException(\"Could not create product directory\");\n        }\n        Map<String, ImageSize> idToTargetImageSize = new HashMap<>();\n        for (String id : idToImageSizes.keySet()) {\n            idToTargetImageSize.put(id, ImageSizeHandler.createTargetImageSize(idToImageSizes.get(id)));\n        }\n        long productSize = 0;\n        File manifestFile;\n        pm.beginTask(\"Stitching SLSTR L1B Product Dissemination Units\", ncFileNames.size() + 1);\n        try {\n            for (int i = 0; i < ncFileNames.size(); i++) {\n                final String ncFileName = ncFileNames.get(i);\n                String[] splitFileName = ncFileName.split(\"/\");\n                final String displayFileName = splitFileName[splitFileName.length - 1];\n                pm.setSubTaskName(MessageFormat.format(\"Stitching ''{0}''\", displayFileName));\n                List<File> ncFiles = new ArrayList<>();\n                List<ImageSize> imageSizeList = new ArrayList<>();\n                String id = ncFileName.substring(ncFileName.length() - 5, ncFileName.length() - 3);\n                if (id.equals(\"tx\")) {\n                    id = \"tn\";\n                }\n                ImageSize targetImageSize = idToTargetImageSize.get(id);\n                if (targetImageSize == null) {\n                    targetImageSize = NULL_IMAGE_SIZE;\n                }\n                ImageSize[] imageSizes = idToImageSizes.get(id);\n                if (imageSizes == null) {\n                    imageSizes = new ImageSize[ncFileNames.size()];\n                    Arrays.fill(imageSizes, NULL_IMAGE_SIZE);\n                }\n                for (int j = 0; j < slstrProductFiles.length; j++) {\n                    File slstrProductFile = slstrProductFiles[j];\n                    File ncFile = new File(slstrProductFile.getParentFile(), ncFileName);\n                    if (ncFile.exists()) {\n                        ncFiles.add(ncFile);\n                        imageSizeList.add(imageSizes[j]);\n                    }\n                }\n                if (ncFiles.size() > 0) {\n                    final File[] ncFilesArray = ncFiles.toArray(new File[ncFiles.size()]);\n                    final ImageSize[] imageSizeArray = imageSizeList.toArray(new ImageSize[imageSizeList.size()]);\n                    logger.log(Level.INFO, \"Stitch \" + displayFileName);\n                    NcFileStitcher.stitchNcFiles(ncFileName, stitchedProductFileParentDirectory, now,\n                            ncFilesArray, targetImageSize, imageSizeArray);\n                    productSize += new File(stitchedProductFileParentDirectory, ncFileName).length();\n                }\n                if (pm.isCanceled()) {\n                    return null;\n                }\n                pm.worked(1);\n            }\n            pm.setSubTaskName(\"Stitching manifest\");\n            logger.log(Level.INFO, \"Stitch manifest\");\n            manifestFile = createManifestFile(slstrProductFiles, stitchedProductFileParentDirectory, now, productSize);\n            pm.worked(1);\n        } finally {\n            pm.done();\n        }\n        return manifestFile;\n    }", "signature": "File createStitchedSlstrL1BFile(File targetDirectory, File[] slstrProductFiles, String productName,\n                                                  ProgressMonitor pm)", "full_signature": "public static File createStitchedSlstrL1BFile(File targetDirectory, File[] slstrProductFiles, String productName,\n                                                  ProgressMonitor pm)", "class_method_signature": "SlstrPduStitcher.createStitchedSlstrL1BFile(File targetDirectory, File[] slstrProductFiles, String productName,\n                                                  ProgressMonitor pm)", "testcase": false, "constructor": false, "invocations": ["notNull", "logger", "instance", "validateSlstrProductFiles", "getTime", "getInstance", "getParentFile", "getName", "exists", "copy", "toPath", "getParentFile", "toPath", "listFiles", "getName", "copy", "toPath", "toPath", "length", "createManifestFile", "decomposeSlstrName", "getName", "getParentFile", "createXmlDocument", "extractImageSizes", "containsKey", "getIdentifier", "get", "getIdentifier", "put", "getIdentifier", "collectFiles", "validateOrbitReference", "validateAdjacency", "createParentDirectoryNameOfStitchedFile", "exists", "mkdirs", "keySet", "put", "createTargetImageSize", "get", "beginTask", "size", "size", "get", "split", "setSubTaskName", "format", "substring", "length", "length", "equals", "get", "get", "size", "fill", "getParentFile", "exists", "add", "add", "size", "toArray", "size", "toArray", "size", "log", "stitchNcFiles", "length", "isCanceled", "worked", "setSubTaskName", "log", "createManifestFile", "worked", "done"]}, "repository": {"repo_id": 22256861, "url": "https://github.com/senbox-org/s3tbx", "stars": 22, "created": "7/25/2014 12:57:22 PM +00:00", "updates": "2020-01-27T10:23:46+00:00", "fork": "False", "license": "licensed"}}