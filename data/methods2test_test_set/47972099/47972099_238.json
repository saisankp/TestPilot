{"test_class": {"identifier": "SemanticPropUtilTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final TypeInformation<?> threeIntTupleType = new TupleTypeInfo<Tuple3<Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "threeIntTupleType = new TupleTypeInfo<Tuple3<Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)", "var_name": "threeIntTupleType"}, {"original_string": "private final TypeInformation<?> fourIntTupleType = new TupleTypeInfo<Tuple4<Integer, Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "fourIntTupleType = new TupleTypeInfo<Tuple4<Integer, Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)", "var_name": "fourIntTupleType"}, {"original_string": "private final TypeInformation<?> fiveIntTupleType = new TupleTypeInfo<Tuple5<Integer, Integer, Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "fiveIntTupleType = new TupleTypeInfo<Tuple5<Integer, Integer, Integer, Integer, Integer>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)", "var_name": "fiveIntTupleType"}, {"original_string": "private final TypeInformation<?> threeMixedTupleType = new TupleTypeInfo<Tuple3<Integer, Long, String>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "threeMixedTupleType = new TupleTypeInfo<Tuple3<Integer, Long, String>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)", "var_name": "threeMixedTupleType"}, {"original_string": "private final TypeInformation<?> nestedTupleType = new TupleTypeInfo<Tuple3<Tuple3<Integer, Integer, Integer>, Integer, Integer>>(threeIntTupleType,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "nestedTupleType = new TupleTypeInfo<Tuple3<Tuple3<Integer, Integer, Integer>, Integer, Integer>>(threeIntTupleType,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)", "var_name": "nestedTupleType"}, {"original_string": "private final TypeInformation<?> deepNestedTupleType = new TupleTypeInfo<Tuple3<Integer, Tuple3<Tuple3<Integer, Integer, Integer>, Integer, Integer>, Integer>>(\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, nestedTupleType, BasicTypeInfo.INT_TYPE_INFO);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "deepNestedTupleType = new TupleTypeInfo<Tuple3<Integer, Tuple3<Tuple3<Integer, Integer, Integer>, Integer, Integer>, Integer>>(\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, nestedTupleType, BasicTypeInfo.INT_TYPE_INFO)", "var_name": "deepNestedTupleType"}, {"original_string": "private final TypeInformation<?> pojoType = TypeExtractor.getForClass(TestPojo.class);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "pojoType = TypeExtractor.getForClass(TestPojo.class)", "var_name": "pojoType"}, {"original_string": "private final TypeInformation<?> pojo2Type = TypeExtractor.getForClass(TestPojo2.class);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "pojo2Type = TypeExtractor.getForClass(TestPojo2.class)", "var_name": "pojo2Type"}, {"original_string": "private final TypeInformation<?> nestedPojoType = TypeExtractor.getForClass(NestedTestPojo.class);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "nestedPojoType = TypeExtractor.getForClass(NestedTestPojo.class)", "var_name": "nestedPojoType"}, {"original_string": "private final TypeInformation<?> pojoInTupleType = new TupleTypeInfo<Tuple3<Integer, Integer, TestPojo>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, pojoType);", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "pojoInTupleType = new TupleTypeInfo<Tuple3<Integer, Integer, TestPojo>>(BasicTypeInfo.INT_TYPE_INFO,\n\t\t\tBasicTypeInfo.INT_TYPE_INFO, pojoType)", "var_name": "pojoInTupleType"}, {"original_string": "private final TypeInformation<?> intType = BasicTypeInfo.INT_TYPE_INFO;", "modifier": "private final", "type": "TypeInformation<?>", "declarator": "intType = BasicTypeInfo.INT_TYPE_INFO", "var_name": "intType"}], "file": "flink-java/src/test/java/org/apache/flink/api/java/functions/SemanticPropUtilTest.java"}, "test_case": {"identifier": "testReadFieldsIndividualStrings", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testReadFieldsIndividualStrings() {\n\t\tString[] readFields = { \"f1\", \"f2\" };\n\t\tSingleInputSemanticProperties sp = new SingleInputSemanticProperties();\n\t\tSemanticPropUtil.getSemanticPropsSingleFromString(sp, null, null, readFields, threeIntTupleType, threeIntTupleType);\n\n\t\tFieldSet fs = sp.getReadFields(0);\n\t\tassertTrue(fs.size() == 2);\n\t\tassertTrue(fs.contains(2));\n\t\tassertTrue(fs.contains(1));\n\t}", "signature": "void testReadFieldsIndividualStrings()", "full_signature": "@Test public void testReadFieldsIndividualStrings()", "class_method_signature": "SemanticPropUtilTest.testReadFieldsIndividualStrings()", "testcase": true, "constructor": false, "invocations": ["getSemanticPropsSingleFromString", "getReadFields", "assertTrue", "size", "assertTrue", "contains", "assertTrue", "contains"]}, "focal_class": {"identifier": "SemanticPropUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final static String REGEX_WILDCARD = \"[\\\\\"+ Keys.ExpressionKeys.SELECT_ALL_CHAR+\"\\\\\"+ Keys.ExpressionKeys.SELECT_ALL_CHAR_SCALA+\"]\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_WILDCARD = \"[\\\\\"+ Keys.ExpressionKeys.SELECT_ALL_CHAR+\"\\\\\"+ Keys.ExpressionKeys.SELECT_ALL_CHAR_SCALA+\"]\"", "var_name": "REGEX_WILDCARD"}, {"original_string": "private final static String REGEX_SINGLE_FIELD = \"[\\\\p{L}\\\\p{Digit}_\\\\$]+\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_SINGLE_FIELD = \"[\\\\p{L}\\\\p{Digit}_\\\\$]+\"", "var_name": "REGEX_SINGLE_FIELD"}, {"original_string": "private final static String REGEX_NESTED_FIELDS = \"((\" + REGEX_SINGLE_FIELD + \"\\\\.)*\" + REGEX_SINGLE_FIELD + \")(\\\\.\"+ REGEX_WILDCARD +\")?\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_NESTED_FIELDS = \"((\" + REGEX_SINGLE_FIELD + \"\\\\.)*\" + REGEX_SINGLE_FIELD + \")(\\\\.\"+ REGEX_WILDCARD +\")?\"", "var_name": "REGEX_NESTED_FIELDS"}, {"original_string": "private final static String REGEX_LIST = \"((\" + REGEX_NESTED_FIELDS + \";)*(\" + REGEX_NESTED_FIELDS + \");?)\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_LIST = \"((\" + REGEX_NESTED_FIELDS + \";)*(\" + REGEX_NESTED_FIELDS + \");?)\"", "var_name": "REGEX_LIST"}, {"original_string": "private final static String REGEX_FORWARD = \"((\"+ REGEX_NESTED_FIELDS +\"|\"+ REGEX_WILDCARD +\")->(\" + REGEX_NESTED_FIELDS + \"|\"+ REGEX_WILDCARD +\"))\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_FORWARD = \"((\"+ REGEX_NESTED_FIELDS +\"|\"+ REGEX_WILDCARD +\")->(\" + REGEX_NESTED_FIELDS + \"|\"+ REGEX_WILDCARD +\"))\"", "var_name": "REGEX_FORWARD"}, {"original_string": "private final static String REGEX_FIELD_OR_FORWARD = \"(\" + REGEX_NESTED_FIELDS + \"|\" + REGEX_FORWARD + \")\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_FIELD_OR_FORWARD = \"(\" + REGEX_NESTED_FIELDS + \"|\" + REGEX_FORWARD + \")\"", "var_name": "REGEX_FIELD_OR_FORWARD"}, {"original_string": "private final static String REGEX_ANNOTATION = \"((\" + REGEX_FIELD_OR_FORWARD + \";)*(\" + REGEX_FIELD_OR_FORWARD + \");?)\";", "modifier": "private final static", "type": "String", "declarator": "REGEX_ANNOTATION = \"((\" + REGEX_FIELD_OR_FORWARD + \";)*(\" + REGEX_FIELD_OR_FORWARD + \");?)\"", "var_name": "REGEX_ANNOTATION"}, {"original_string": "private static final Pattern PATTERN_WILDCARD = Pattern.compile(REGEX_WILDCARD);", "modifier": "private static final", "type": "Pattern", "declarator": "PATTERN_WILDCARD = Pattern.compile(REGEX_WILDCARD)", "var_name": "PATTERN_WILDCARD"}, {"original_string": "private static final Pattern PATTERN_FORWARD = Pattern.compile(REGEX_FORWARD);", "modifier": "private static final", "type": "Pattern", "declarator": "PATTERN_FORWARD = Pattern.compile(REGEX_FORWARD)", "var_name": "PATTERN_FORWARD"}, {"original_string": "private static final Pattern PATTERN_ANNOTATION = Pattern.compile(REGEX_ANNOTATION);", "modifier": "private static final", "type": "Pattern", "declarator": "PATTERN_ANNOTATION = Pattern.compile(REGEX_ANNOTATION)", "var_name": "PATTERN_ANNOTATION"}, {"original_string": "private static final Pattern PATTERN_LIST = Pattern.compile(REGEX_LIST);", "modifier": "private static final", "type": "Pattern", "declarator": "PATTERN_LIST = Pattern.compile(REGEX_LIST)", "var_name": "PATTERN_LIST"}, {"original_string": "private static final Pattern PATTERN_FIELD = Pattern.compile(REGEX_NESTED_FIELDS);", "modifier": "private static final", "type": "Pattern", "declarator": "PATTERN_FIELD = Pattern.compile(REGEX_NESTED_FIELDS)", "var_name": "PATTERN_FIELD"}], "methods": [{"identifier": "createProjectionPropertiesSingle", "parameters": "(int[] fields, CompositeType<?> inType)", "modifiers": "public static", "return": "SingleInputSemanticProperties", "signature": "SingleInputSemanticProperties createProjectionPropertiesSingle(int[] fields, CompositeType<?> inType)", "full_signature": "public static SingleInputSemanticProperties createProjectionPropertiesSingle(int[] fields, CompositeType<?> inType)", "class_method_signature": "SemanticPropUtil.createProjectionPropertiesSingle(int[] fields, CompositeType<?> inType)", "testcase": false, "constructor": false}, {"identifier": "createProjectionPropertiesDual", "parameters": "(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "modifiers": "public static", "return": "DualInputSemanticProperties", "signature": "DualInputSemanticProperties createProjectionPropertiesDual(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "full_signature": "public static DualInputSemanticProperties createProjectionPropertiesDual(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "class_method_signature": "SemanticPropUtil.createProjectionPropertiesDual(\n\t\t\tint[] fields, boolean[] isFromFirst, TypeInformation<?> inType1, TypeInformation<?> inType2)", "testcase": false, "constructor": false}, {"identifier": "addSourceFieldOffset", "parameters": "(SingleInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields, int offset)", "modifiers": "public static", "return": "SingleInputSemanticProperties", "signature": "SingleInputSemanticProperties addSourceFieldOffset(SingleInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields, int offset)", "full_signature": "public static SingleInputSemanticProperties addSourceFieldOffset(SingleInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields, int offset)", "class_method_signature": "SemanticPropUtil.addSourceFieldOffset(SingleInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields, int offset)", "testcase": false, "constructor": false}, {"identifier": "addSourceFieldOffsets", "parameters": "(DualInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields1, int numInputFields2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint offset1, int offset2)", "modifiers": "public static", "return": "DualInputSemanticProperties", "signature": "DualInputSemanticProperties addSourceFieldOffsets(DualInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields1, int numInputFields2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint offset1, int offset2)", "full_signature": "public static DualInputSemanticProperties addSourceFieldOffsets(DualInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields1, int numInputFields2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint offset1, int offset2)", "class_method_signature": "SemanticPropUtil.addSourceFieldOffsets(DualInputSemanticProperties props,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint numInputFields1, int numInputFields2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint offset1, int offset2)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsSingle", "parameters": "(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType, TypeInformation<?> outType)", "modifiers": "public static", "return": "SingleInputSemanticProperties", "signature": "SingleInputSemanticProperties getSemanticPropsSingle(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType, TypeInformation<?> outType)", "full_signature": "public static SingleInputSemanticProperties getSemanticPropsSingle(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType, TypeInformation<?> outType)", "class_method_signature": "SemanticPropUtil.getSemanticPropsSingle(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType, TypeInformation<?> outType)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsDual", "parameters": "(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "modifiers": "public static", "return": "DualInputSemanticProperties", "signature": "DualInputSemanticProperties getSemanticPropsDual(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "full_signature": "public static DualInputSemanticProperties getSemanticPropsDual(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "class_method_signature": "SemanticPropUtil.getSemanticPropsDual(\n\t\t\tSet<Annotation> set, TypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsSingleFromString", "parameters": "(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "modifiers": "public static", "return": "void", "signature": "void getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "full_signature": "public static void getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "class_method_signature": "SemanticPropUtil.getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsSingleFromString", "parameters": "(SingleInputSemanticProperties result,\n\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "modifiers": "public static", "return": "void", "signature": "void getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "full_signature": "public static void getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "class_method_signature": "SemanticPropUtil.getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsDualFromString", "parameters": "(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "modifiers": "public static", "return": "void", "signature": "void getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "full_signature": "public static void getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "class_method_signature": "SemanticPropUtil.getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType)", "testcase": false, "constructor": false}, {"identifier": "getSemanticPropsDualFromString", "parameters": "(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "modifiers": "public static", "return": "void", "signature": "void getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "full_signature": "public static void getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "class_method_signature": "SemanticPropUtil.getSemanticPropsDualFromString(DualInputSemanticProperties result,\n\t\t\tString[] forwardedFirst, String[] forwardedSecond,\n\t\t\tString[] nonForwardedFirst, String[] nonForwardedSecond, String[]\n\t\t\treadFieldsFirst, String[] readFieldsSecond,\n\t\t\tTypeInformation<?> inType1, TypeInformation<?> inType2, TypeInformation<?> outType,\n\t\t\tboolean skipIncompatibleTypes)", "testcase": false, "constructor": false}, {"identifier": "parseForwardedFields", "parameters": "(SemanticProperties sp, String[] forwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "modifiers": "private static", "return": "void", "signature": "void parseForwardedFields(SemanticProperties sp, String[] forwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "full_signature": "private static void parseForwardedFields(SemanticProperties sp, String[] forwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "class_method_signature": "SemanticPropUtil.parseForwardedFields(SemanticProperties sp, String[] forwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "testcase": false, "constructor": false}, {"identifier": "parseNonForwardedFields", "parameters": "(SemanticProperties sp, String[] nonForwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "modifiers": "private static", "return": "void", "signature": "void parseNonForwardedFields(SemanticProperties sp, String[] nonForwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "full_signature": "private static void parseNonForwardedFields(SemanticProperties sp, String[] nonForwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "class_method_signature": "SemanticPropUtil.parseNonForwardedFields(SemanticProperties sp, String[] nonForwardedStr,\n\t\t\tTypeInformation<?> inType, TypeInformation<?> outType, int input, boolean skipIncompatibleTypes)", "testcase": false, "constructor": false}, {"identifier": "parseReadFields", "parameters": "(SemanticProperties sp, String[] readFieldStrings, TypeInformation<?> inType, int input)", "modifiers": "private static", "return": "void", "signature": "void parseReadFields(SemanticProperties sp, String[] readFieldStrings, TypeInformation<?> inType, int input)", "full_signature": "private static void parseReadFields(SemanticProperties sp, String[] readFieldStrings, TypeInformation<?> inType, int input)", "class_method_signature": "SemanticPropUtil.parseReadFields(SemanticProperties sp, String[] readFieldStrings, TypeInformation<?> inType, int input)", "testcase": false, "constructor": false}, {"identifier": "areFieldsCompatible", "parameters": "(String sourceField, TypeInformation<?> inType, String targetField,\n\t\t\tTypeInformation<?> outType, boolean throwException)", "modifiers": "private static", "return": "boolean", "signature": "boolean areFieldsCompatible(String sourceField, TypeInformation<?> inType, String targetField,\n\t\t\tTypeInformation<?> outType, boolean throwException)", "full_signature": "private static boolean areFieldsCompatible(String sourceField, TypeInformation<?> inType, String targetField,\n\t\t\tTypeInformation<?> outType, boolean throwException)", "class_method_signature": "SemanticPropUtil.areFieldsCompatible(String sourceField, TypeInformation<?> inType, String targetField,\n\t\t\tTypeInformation<?> outType, boolean throwException)", "testcase": false, "constructor": false}, {"identifier": "getExpressionTypeInformation", "parameters": "(String fieldStr, TypeInformation<?> typeInfo)", "modifiers": "private static", "return": "TypeInformation<?>", "signature": "TypeInformation<?> getExpressionTypeInformation(String fieldStr, TypeInformation<?> typeInfo)", "full_signature": "private static TypeInformation<?> getExpressionTypeInformation(String fieldStr, TypeInformation<?> typeInfo)", "class_method_signature": "SemanticPropUtil.getExpressionTypeInformation(String fieldStr, TypeInformation<?> typeInfo)", "testcase": false, "constructor": false}, {"identifier": "getFlatFields", "parameters": "(String fieldStr, TypeInformation<?> typeInfo)", "modifiers": "private static", "return": "List<FlatFieldDescriptor>", "signature": "List<FlatFieldDescriptor> getFlatFields(String fieldStr, TypeInformation<?> typeInfo)", "full_signature": "private static List<FlatFieldDescriptor> getFlatFields(String fieldStr, TypeInformation<?> typeInfo)", "class_method_signature": "SemanticPropUtil.getFlatFields(String fieldStr, TypeInformation<?> typeInfo)", "testcase": false, "constructor": false}, {"identifier": "SemanticPropUtil", "parameters": "()", "modifiers": "private", "return": "", "signature": " SemanticPropUtil()", "full_signature": "private  SemanticPropUtil()", "class_method_signature": "SemanticPropUtil.SemanticPropUtil()", "testcase": false, "constructor": true}], "file": "flink-java/src/main/java/org/apache/flink/api/java/functions/SemanticPropUtil.java"}, "focal_method": {"identifier": "getSemanticPropsSingleFromString", "parameters": "(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "modifiers": "public static", "return": "void", "body": "public static void getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType) {\n\t\tgetSemanticPropsSingleFromString(result, forwarded, nonForwarded, readSet, inType, outType, false);\n\t}", "signature": "void getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "full_signature": "public static void getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "class_method_signature": "SemanticPropUtil.getSemanticPropsSingleFromString(SingleInputSemanticProperties result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString[] forwarded, String[] nonForwarded, String[] readSet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<?> inType, TypeInformation<?> outType)", "testcase": false, "constructor": false, "invocations": ["getSemanticPropsSingleFromString"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}