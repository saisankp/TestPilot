{"test_class": {"identifier": "SimpleCapacityGuaranteeStrategyTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final CapacityManagementConfiguration configuration = BeanCapacityManagementConfiguration.newBuilder()\n            .withCriticalTierBuffer(0.1)\n            .withFlexTierBuffer(0.1)\n            .build();", "modifier": "private static final", "type": "CapacityManagementConfiguration", "declarator": "configuration = BeanCapacityManagementConfiguration.newBuilder()\n            .withCriticalTierBuffer(0.1)\n            .withFlexTierBuffer(0.1)\n            .build()", "var_name": "configuration"}, {"original_string": "private final AgentManagementService agentManagementService = mock(AgentManagementService.class);", "modifier": "private final", "type": "AgentManagementService", "declarator": "agentManagementService = mock(AgentManagementService.class)", "var_name": "agentManagementService"}, {"original_string": "private final CapacityGuaranteeStrategy strategy = new SimpleCapacityGuaranteeStrategy(\n            configuration,\n            agentManagementService,\n            ServerInfoResolvers.fromAwsInstanceTypes()\n    );", "modifier": "private final", "type": "CapacityGuaranteeStrategy", "declarator": "strategy = new SimpleCapacityGuaranteeStrategy(\n            configuration,\n            agentManagementService,\n            ServerInfoResolvers.fromAwsInstanceTypes()\n    )", "var_name": "strategy"}], "file": "titus-server-master/src/test/java/com/netflix/titus/master/service/management/internal/SimpleCapacityGuaranteeStrategyTest.java"}, "test_case": {"identifier": "testOnlyFenzoPartitionIsIncluded", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testOnlyFenzoPartitionIsIncluded() {\n        List<AgentInstanceGroup> instanceGroups = asList(\n                getInstanceGroup(Tier.Critical, R4_8XLARGE_ID, 0, 1).toBuilder().withId(\"fenzo\").build(),\n                getInstanceGroup(Tier.Critical, R4_8XLARGE_ID, 0, 1).toBuilder().withId(\"kubeScheduler\").build()\n        );\n        when(agentManagementService.getInstanceGroups()).thenReturn(instanceGroups);\n        when(agentManagementService.isOwnedByFenzo(any(AgentInstanceGroup.class))).thenAnswer(invocation -> {\n            AgentInstanceGroup instanceGroup = invocation.getArgument(0);\n            return instanceGroup.getId().equals(\"fenzo\");\n        });\n\n        ApplicationSLA bigSLA = ApplicationSlaSample.CriticalLarge.builder().withInstanceCount(100).build();\n        CapacityRequirements requirements = new CapacityRequirements(singletonMap(Tier.Critical, singletonList(bigSLA)));\n        CapacityAllocations allocations = strategy.compute(requirements);\n\n        assertThat(allocations.getInstanceGroups()).hasSize(1);\n        assertThat(CollectionsExt.first(allocations.getInstanceGroups()).getId()).isEqualTo(\"fenzo\");\n    }", "signature": "void testOnlyFenzoPartitionIsIncluded()", "full_signature": "@Test public void testOnlyFenzoPartitionIsIncluded()", "class_method_signature": "SimpleCapacityGuaranteeStrategyTest.testOnlyFenzoPartitionIsIncluded()", "testcase": true, "constructor": false, "invocations": ["asList", "build", "withId", "toBuilder", "getInstanceGroup", "build", "withId", "toBuilder", "getInstanceGroup", "thenReturn", "when", "getInstanceGroups", "thenAnswer", "when", "isOwnedByFenzo", "any", "getArgument", "equals", "getId", "build", "withInstanceCount", "builder", "singletonMap", "singletonList", "compute", "hasSize", "assertThat", "getInstanceGroups", "isEqualTo", "assertThat", "getId", "first", "getInstanceGroups"]}, "focal_class": {"identifier": "SimpleCapacityGuaranteeStrategy", "superclass": "", "interfaces": "implements CapacityGuaranteeStrategy", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(SimpleCapacityGuaranteeStrategy.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(SimpleCapacityGuaranteeStrategy.class)", "var_name": "logger"}, {"original_string": "private final CapacityManagementConfiguration configuration;", "modifier": "private final", "type": "CapacityManagementConfiguration", "declarator": "configuration", "var_name": "configuration"}, {"original_string": "private final AgentManagementService agentManagementService;", "modifier": "private final", "type": "AgentManagementService", "declarator": "agentManagementService", "var_name": "agentManagementService"}, {"original_string": "private final ServerInfoResolver serverInfoResolver;", "modifier": "private final", "type": "ServerInfoResolver", "declarator": "serverInfoResolver", "var_name": "serverInfoResolver"}], "methods": [{"identifier": "SimpleCapacityGuaranteeStrategy", "parameters": "(CapacityManagementConfiguration configuration,\n                                           AgentManagementService agentManagementService,\n                                           ServerInfoResolver serverInfoResolver)", "modifiers": "@Inject public", "return": "", "signature": " SimpleCapacityGuaranteeStrategy(CapacityManagementConfiguration configuration,\n                                           AgentManagementService agentManagementService,\n                                           ServerInfoResolver serverInfoResolver)", "full_signature": "@Inject public  SimpleCapacityGuaranteeStrategy(CapacityManagementConfiguration configuration,\n                                           AgentManagementService agentManagementService,\n                                           ServerInfoResolver serverInfoResolver)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.SimpleCapacityGuaranteeStrategy(CapacityManagementConfiguration configuration,\n                                           AgentManagementService agentManagementService,\n                                           ServerInfoResolver serverInfoResolver)", "testcase": false, "constructor": true}, {"identifier": "compute", "parameters": "(CapacityRequirements capacityRequirements)", "modifiers": "@Override public", "return": "CapacityAllocations", "signature": "CapacityAllocations compute(CapacityRequirements capacityRequirements)", "full_signature": "@Override public CapacityAllocations compute(CapacityRequirements capacityRequirements)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.compute(CapacityRequirements capacityRequirements)", "testcase": false, "constructor": false}, {"identifier": "allocate", "parameters": "(Tier tier,\n                                                 CapacityRequirements capacityRequirements,\n                                                 Map<AgentInstanceGroup, Integer> instanceAllocations)", "modifiers": "private", "return": "Optional<ResourceDimension>", "signature": "Optional<ResourceDimension> allocate(Tier tier,\n                                                 CapacityRequirements capacityRequirements,\n                                                 Map<AgentInstanceGroup, Integer> instanceAllocations)", "full_signature": "private Optional<ResourceDimension> allocate(Tier tier,\n                                                 CapacityRequirements capacityRequirements,\n                                                 Map<AgentInstanceGroup, Integer> instanceAllocations)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.allocate(Tier tier,\n                                                 CapacityRequirements capacityRequirements,\n                                                 Map<AgentInstanceGroup, Integer> instanceAllocations)", "testcase": false, "constructor": false}, {"identifier": "computeTierResourceDimension", "parameters": "(Tier tier, CapacityRequirements capacityRequirements)", "modifiers": "private", "return": "ResourceDimension", "signature": "ResourceDimension computeTierResourceDimension(Tier tier, CapacityRequirements capacityRequirements)", "full_signature": "private ResourceDimension computeTierResourceDimension(Tier tier, CapacityRequirements capacityRequirements)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.computeTierResourceDimension(Tier tier, CapacityRequirements capacityRequirements)", "testcase": false, "constructor": false}, {"identifier": "getInstancesUsed", "parameters": "(Map<AgentInstanceGroup, Integer> instanceAllocations, AgentInstanceGroup instanceGroup)", "modifiers": "private", "return": "int", "signature": "int getInstancesUsed(Map<AgentInstanceGroup, Integer> instanceAllocations, AgentInstanceGroup instanceGroup)", "full_signature": "private int getInstancesUsed(Map<AgentInstanceGroup, Integer> instanceAllocations, AgentInstanceGroup instanceGroup)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.getInstancesUsed(Map<AgentInstanceGroup, Integer> instanceAllocations, AgentInstanceGroup instanceGroup)", "testcase": false, "constructor": false}], "file": "titus-server-master/src/main/java/com/netflix/titus/master/service/management/internal/SimpleCapacityGuaranteeStrategy.java"}, "focal_method": {"identifier": "compute", "parameters": "(CapacityRequirements capacityRequirements)", "modifiers": "@Override public", "return": "CapacityAllocations", "body": "@Override\n    public CapacityAllocations compute(CapacityRequirements capacityRequirements) {\n        Map<AgentInstanceGroup, Integer> instanceAllocations = new HashMap<>();\n        Map<Tier, ResourceDimension> resourceShortage = new HashMap<>();\n        for (Tier tier : capacityRequirements.getTiers()) {\n            // In Flex tier we have always 'DEFAULT' app, and if it is the only one, we should not scale the cluster\n            // For other tiers we stop scaling, if there are no application SLAs configured\n            boolean hasEnoughApps = (tier == Tier.Flex && capacityRequirements.getTierRequirements(tier).size() > 1)\n                    || (tier != Tier.Flex && capacityRequirements.getTierRequirements(tier).size() > 0);\n            if (hasEnoughApps) {\n                Optional<ResourceDimension> left = allocate(tier, capacityRequirements, instanceAllocations);\n                left.ifPresent(resourceDimension -> resourceShortage.put(tier, resourceDimension));\n            }\n        }\n        return new CapacityAllocations(instanceAllocations, resourceShortage);\n    }", "signature": "CapacityAllocations compute(CapacityRequirements capacityRequirements)", "full_signature": "@Override public CapacityAllocations compute(CapacityRequirements capacityRequirements)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.compute(CapacityRequirements capacityRequirements)", "testcase": false, "constructor": false, "invocations": ["getTiers", "size", "getTierRequirements", "size", "getTierRequirements", "allocate", "ifPresent", "put"]}, "repository": {"repo_id": 107330274, "url": "https://github.com/Netflix/titus-control-plane", "stars": 241, "created": "10/17/2017 10:20:55 PM +00:00", "updates": "2020-01-25T13:01:05+00:00", "fork": "False", "license": "licensed"}}