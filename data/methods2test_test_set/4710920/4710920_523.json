{"test_class": {"identifier": "NetUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "dubbo-common/src/test/java/org/apache/dubbo/common/utils/NetUtilsTest.java"}, "test_case": {"identifier": "testMatchIpRangeMatchWhenIpv4", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMatchIpRangeMatchWhenIpv4() throws UnknownHostException {\n        assertTrue(NetUtils.matchIpRange(\"*.*.*.*\", \"192.168.1.63\", 90));\n        assertTrue(NetUtils.matchIpRange(\"192.168.1.*\", \"192.168.1.63\", 90));\n        assertTrue(NetUtils.matchIpRange(\"192.168.1.63\", \"192.168.1.63\", 90));\n        assertTrue(NetUtils.matchIpRange(\"192.168.1.1-65\", \"192.168.1.63\", 90));\n        assertFalse(NetUtils.matchIpRange(\"192.168.1.1-61\", \"192.168.1.63\", 90));\n        assertFalse(NetUtils.matchIpRange(\"192.168.1.62\", \"192.168.1.63\", 90));\n    }", "signature": "void testMatchIpRangeMatchWhenIpv4()", "full_signature": "@Test public void testMatchIpRangeMatchWhenIpv4()", "class_method_signature": "NetUtilsTest.testMatchIpRangeMatchWhenIpv4()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "matchIpRange", "assertTrue", "matchIpRange", "assertTrue", "matchIpRange", "assertTrue", "matchIpRange", "assertFalse", "matchIpRange", "assertFalse", "matchIpRange"]}, "focal_class": {"identifier": "NetUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Logger logger;", "modifier": "private static", "type": "Logger", "declarator": "logger", "var_name": "logger"}, {"original_string": "private static final int RND_PORT_START = 30000;", "modifier": "private static final", "type": "int", "declarator": "RND_PORT_START = 30000", "var_name": "RND_PORT_START"}, {"original_string": "private static final int RND_PORT_RANGE = 10000;", "modifier": "private static final", "type": "int", "declarator": "RND_PORT_RANGE = 10000", "var_name": "RND_PORT_RANGE"}, {"original_string": "private static final int MIN_PORT = 0;", "modifier": "private static final", "type": "int", "declarator": "MIN_PORT = 0", "var_name": "MIN_PORT"}, {"original_string": "private static final int MAX_PORT = 65535;", "modifier": "private static final", "type": "int", "declarator": "MAX_PORT = 65535", "var_name": "MAX_PORT"}, {"original_string": "private static final Pattern ADDRESS_PATTERN = Pattern.compile(\"^\\\\d{1,3}(\\\\.\\\\d{1,3}){3}\\\\:\\\\d{1,5}$\");", "modifier": "private static final", "type": "Pattern", "declarator": "ADDRESS_PATTERN = Pattern.compile(\"^\\\\d{1,3}(\\\\.\\\\d{1,3}){3}\\\\:\\\\d{1,5}$\")", "var_name": "ADDRESS_PATTERN"}, {"original_string": "private static final Pattern LOCAL_IP_PATTERN = Pattern.compile(\"127(\\\\.\\\\d{1,3}){3}$\");", "modifier": "private static final", "type": "Pattern", "declarator": "LOCAL_IP_PATTERN = Pattern.compile(\"127(\\\\.\\\\d{1,3}){3}$\")", "var_name": "LOCAL_IP_PATTERN"}, {"original_string": "private static final Pattern IP_PATTERN = Pattern.compile(\"\\\\d{1,3}(\\\\.\\\\d{1,3}){3,5}$\");", "modifier": "private static final", "type": "Pattern", "declarator": "IP_PATTERN = Pattern.compile(\"\\\\d{1,3}(\\\\.\\\\d{1,3}){3,5}$\")", "var_name": "IP_PATTERN"}, {"original_string": "private static final Map<String, String> HOST_NAME_CACHE = new LRUCache<>(1000);", "modifier": "private static final", "type": "Map<String, String>", "declarator": "HOST_NAME_CACHE = new LRUCache<>(1000)", "var_name": "HOST_NAME_CACHE"}, {"original_string": "private static volatile InetAddress LOCAL_ADDRESS = null;", "modifier": "private static volatile", "type": "InetAddress", "declarator": "LOCAL_ADDRESS = null", "var_name": "LOCAL_ADDRESS"}, {"original_string": "private static final String SPLIT_IPV4_CHARACTER = \"\\\\.\";", "modifier": "private static final", "type": "String", "declarator": "SPLIT_IPV4_CHARACTER = \"\\\\.\"", "var_name": "SPLIT_IPV4_CHARACTER"}, {"original_string": "private static final String SPLIT_IPV6_CHARACTER = \":\";", "modifier": "private static final", "type": "String", "declarator": "SPLIT_IPV6_CHARACTER = \":\"", "var_name": "SPLIT_IPV6_CHARACTER"}, {"original_string": "private static volatile String HOST_ADDRESS;", "modifier": "private static volatile", "type": "String", "declarator": "HOST_ADDRESS", "var_name": "HOST_ADDRESS"}], "methods": [{"identifier": "getRandomPort", "parameters": "()", "modifiers": "public static", "return": "int", "signature": "int getRandomPort()", "full_signature": "public static int getRandomPort()", "class_method_signature": "NetUtils.getRandomPort()", "testcase": false, "constructor": false}, {"identifier": "getAvailablePort", "parameters": "()", "modifiers": "public static", "return": "int", "signature": "int getAvailablePort()", "full_signature": "public static int getAvailablePort()", "class_method_signature": "NetUtils.getAvailablePort()", "testcase": false, "constructor": false}, {"identifier": "getAvailablePort", "parameters": "(int port)", "modifiers": "public static", "return": "int", "signature": "int getAvailablePort(int port)", "full_signature": "public static int getAvailablePort(int port)", "class_method_signature": "NetUtils.getAvailablePort(int port)", "testcase": false, "constructor": false}, {"identifier": "isInvalidPort", "parameters": "(int port)", "modifiers": "public static", "return": "boolean", "signature": "boolean isInvalidPort(int port)", "full_signature": "public static boolean isInvalidPort(int port)", "class_method_signature": "NetUtils.isInvalidPort(int port)", "testcase": false, "constructor": false}, {"identifier": "isValidAddress", "parameters": "(String address)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidAddress(String address)", "full_signature": "public static boolean isValidAddress(String address)", "class_method_signature": "NetUtils.isValidAddress(String address)", "testcase": false, "constructor": false}, {"identifier": "isLocalHost", "parameters": "(String host)", "modifiers": "public static", "return": "boolean", "signature": "boolean isLocalHost(String host)", "full_signature": "public static boolean isLocalHost(String host)", "class_method_signature": "NetUtils.isLocalHost(String host)", "testcase": false, "constructor": false}, {"identifier": "isAnyHost", "parameters": "(String host)", "modifiers": "public static", "return": "boolean", "signature": "boolean isAnyHost(String host)", "full_signature": "public static boolean isAnyHost(String host)", "class_method_signature": "NetUtils.isAnyHost(String host)", "testcase": false, "constructor": false}, {"identifier": "isInvalidLocalHost", "parameters": "(String host)", "modifiers": "public static", "return": "boolean", "signature": "boolean isInvalidLocalHost(String host)", "full_signature": "public static boolean isInvalidLocalHost(String host)", "class_method_signature": "NetUtils.isInvalidLocalHost(String host)", "testcase": false, "constructor": false}, {"identifier": "isValidLocalHost", "parameters": "(String host)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidLocalHost(String host)", "full_signature": "public static boolean isValidLocalHost(String host)", "class_method_signature": "NetUtils.isValidLocalHost(String host)", "testcase": false, "constructor": false}, {"identifier": "getLocalSocketAddress", "parameters": "(String host, int port)", "modifiers": "public static", "return": "InetSocketAddress", "signature": "InetSocketAddress getLocalSocketAddress(String host, int port)", "full_signature": "public static InetSocketAddress getLocalSocketAddress(String host, int port)", "class_method_signature": "NetUtils.getLocalSocketAddress(String host, int port)", "testcase": false, "constructor": false}, {"identifier": "isValidV4Address", "parameters": "(InetAddress address)", "modifiers": "static", "return": "boolean", "signature": "boolean isValidV4Address(InetAddress address)", "full_signature": "static boolean isValidV4Address(InetAddress address)", "class_method_signature": "NetUtils.isValidV4Address(InetAddress address)", "testcase": false, "constructor": false}, {"identifier": "isPreferIPV6Address", "parameters": "()", "modifiers": "static", "return": "boolean", "signature": "boolean isPreferIPV6Address()", "full_signature": "static boolean isPreferIPV6Address()", "class_method_signature": "NetUtils.isPreferIPV6Address()", "testcase": false, "constructor": false}, {"identifier": "normalizeV6Address", "parameters": "(Inet6Address address)", "modifiers": "static", "return": "InetAddress", "signature": "InetAddress normalizeV6Address(Inet6Address address)", "full_signature": "static InetAddress normalizeV6Address(Inet6Address address)", "class_method_signature": "NetUtils.normalizeV6Address(Inet6Address address)", "testcase": false, "constructor": false}, {"identifier": "getLocalHost", "parameters": "()", "modifiers": "public static", "return": "String", "signature": "String getLocalHost()", "full_signature": "public static String getLocalHost()", "class_method_signature": "NetUtils.getLocalHost()", "testcase": false, "constructor": false}, {"identifier": "filterLocalHost", "parameters": "(String host)", "modifiers": "public static", "return": "String", "signature": "String filterLocalHost(String host)", "full_signature": "public static String filterLocalHost(String host)", "class_method_signature": "NetUtils.filterLocalHost(String host)", "testcase": false, "constructor": false}, {"identifier": "getIpByConfig", "parameters": "()", "modifiers": "public static", "return": "String", "signature": "String getIpByConfig()", "full_signature": "public static String getIpByConfig()", "class_method_signature": "NetUtils.getIpByConfig()", "testcase": false, "constructor": false}, {"identifier": "getLocalAddress", "parameters": "()", "modifiers": "public static", "return": "InetAddress", "signature": "InetAddress getLocalAddress()", "full_signature": "public static InetAddress getLocalAddress()", "class_method_signature": "NetUtils.getLocalAddress()", "testcase": false, "constructor": false}, {"identifier": "toValidAddress", "parameters": "(InetAddress address)", "modifiers": "private static", "return": "Optional<InetAddress>", "signature": "Optional<InetAddress> toValidAddress(InetAddress address)", "full_signature": "private static Optional<InetAddress> toValidAddress(InetAddress address)", "class_method_signature": "NetUtils.toValidAddress(InetAddress address)", "testcase": false, "constructor": false}, {"identifier": "getLocalAddress0", "parameters": "()", "modifiers": "private static", "return": "InetAddress", "signature": "InetAddress getLocalAddress0()", "full_signature": "private static InetAddress getLocalAddress0()", "class_method_signature": "NetUtils.getLocalAddress0()", "testcase": false, "constructor": false}, {"identifier": "ignoreNetworkInterface", "parameters": "(NetworkInterface networkInterface)", "modifiers": "private static", "return": "boolean", "signature": "boolean ignoreNetworkInterface(NetworkInterface networkInterface)", "full_signature": "private static boolean ignoreNetworkInterface(NetworkInterface networkInterface)", "class_method_signature": "NetUtils.ignoreNetworkInterface(NetworkInterface networkInterface)", "testcase": false, "constructor": false}, {"identifier": "getValidNetworkInterfaces", "parameters": "()", "modifiers": "private static", "return": "List<NetworkInterface>", "signature": "List<NetworkInterface> getValidNetworkInterfaces()", "full_signature": "private static List<NetworkInterface> getValidNetworkInterfaces()", "class_method_signature": "NetUtils.getValidNetworkInterfaces()", "testcase": false, "constructor": false}, {"identifier": "isPreferredNetworkInterface", "parameters": "(NetworkInterface networkInterface)", "modifiers": "public static", "return": "boolean", "signature": "boolean isPreferredNetworkInterface(NetworkInterface networkInterface)", "full_signature": "public static boolean isPreferredNetworkInterface(NetworkInterface networkInterface)", "class_method_signature": "NetUtils.isPreferredNetworkInterface(NetworkInterface networkInterface)", "testcase": false, "constructor": false}, {"identifier": "findNetworkInterface", "parameters": "()", "modifiers": "public static", "return": "NetworkInterface", "signature": "NetworkInterface findNetworkInterface()", "full_signature": "public static NetworkInterface findNetworkInterface()", "class_method_signature": "NetUtils.findNetworkInterface()", "testcase": false, "constructor": false}, {"identifier": "getHostName", "parameters": "(String address)", "modifiers": "public static", "return": "String", "signature": "String getHostName(String address)", "full_signature": "public static String getHostName(String address)", "class_method_signature": "NetUtils.getHostName(String address)", "testcase": false, "constructor": false}, {"identifier": "getIpByHost", "parameters": "(String hostName)", "modifiers": "public static", "return": "String", "signature": "String getIpByHost(String hostName)", "full_signature": "public static String getIpByHost(String hostName)", "class_method_signature": "NetUtils.getIpByHost(String hostName)", "testcase": false, "constructor": false}, {"identifier": "toAddressString", "parameters": "(InetSocketAddress address)", "modifiers": "public static", "return": "String", "signature": "String toAddressString(InetSocketAddress address)", "full_signature": "public static String toAddressString(InetSocketAddress address)", "class_method_signature": "NetUtils.toAddressString(InetSocketAddress address)", "testcase": false, "constructor": false}, {"identifier": "toAddress", "parameters": "(String address)", "modifiers": "public static", "return": "InetSocketAddress", "signature": "InetSocketAddress toAddress(String address)", "full_signature": "public static InetSocketAddress toAddress(String address)", "class_method_signature": "NetUtils.toAddress(String address)", "testcase": false, "constructor": false}, {"identifier": "toURL", "parameters": "(String protocol, String host, int port, String path)", "modifiers": "public static", "return": "String", "signature": "String toURL(String protocol, String host, int port, String path)", "full_signature": "public static String toURL(String protocol, String host, int port, String path)", "class_method_signature": "NetUtils.toURL(String protocol, String host, int port, String path)", "testcase": false, "constructor": false}, {"identifier": "joinMulticastGroup", "parameters": "(MulticastSocket multicastSocket, InetAddress multicastAddress)", "modifiers": "public static", "return": "void", "signature": "void joinMulticastGroup(MulticastSocket multicastSocket, InetAddress multicastAddress)", "full_signature": "public static void joinMulticastGroup(MulticastSocket multicastSocket, InetAddress multicastAddress)", "class_method_signature": "NetUtils.joinMulticastGroup(MulticastSocket multicastSocket, InetAddress multicastAddress)", "testcase": false, "constructor": false}, {"identifier": "setInterface", "parameters": "(MulticastSocket multicastSocket, boolean preferIpv6)", "modifiers": "public static", "return": "void", "signature": "void setInterface(MulticastSocket multicastSocket, boolean preferIpv6)", "full_signature": "public static void setInterface(MulticastSocket multicastSocket, boolean preferIpv6)", "class_method_signature": "NetUtils.setInterface(MulticastSocket multicastSocket, boolean preferIpv6)", "testcase": false, "constructor": false}, {"identifier": "matchIpExpression", "parameters": "(String pattern, String host, int port)", "modifiers": "public static", "return": "boolean", "signature": "boolean matchIpExpression(String pattern, String host, int port)", "full_signature": "public static boolean matchIpExpression(String pattern, String host, int port)", "class_method_signature": "NetUtils.matchIpExpression(String pattern, String host, int port)", "testcase": false, "constructor": false}, {"identifier": "matchIpRange", "parameters": "(String pattern, String host, int port)", "modifiers": "public static", "return": "boolean", "signature": "boolean matchIpRange(String pattern, String host, int port)", "full_signature": "public static boolean matchIpRange(String pattern, String host, int port)", "class_method_signature": "NetUtils.matchIpRange(String pattern, String host, int port)", "testcase": false, "constructor": false}, {"identifier": "isMulticastAddress", "parameters": "(String host)", "modifiers": "public static", "return": "boolean", "signature": "boolean isMulticastAddress(String host)", "full_signature": "public static boolean isMulticastAddress(String host)", "class_method_signature": "NetUtils.isMulticastAddress(String host)", "testcase": false, "constructor": false}, {"identifier": "ipPatternContainExpression", "parameters": "(String pattern)", "modifiers": "private static", "return": "boolean", "signature": "boolean ipPatternContainExpression(String pattern)", "full_signature": "private static boolean ipPatternContainExpression(String pattern)", "class_method_signature": "NetUtils.ipPatternContainExpression(String pattern)", "testcase": false, "constructor": false}, {"identifier": "checkHostPattern", "parameters": "(String pattern, String[] mask, boolean isIpv4)", "modifiers": "private static", "return": "void", "signature": "void checkHostPattern(String pattern, String[] mask, boolean isIpv4)", "full_signature": "private static void checkHostPattern(String pattern, String[] mask, boolean isIpv4)", "class_method_signature": "NetUtils.checkHostPattern(String pattern, String[] mask, boolean isIpv4)", "testcase": false, "constructor": false}, {"identifier": "getPatternHostAndPort", "parameters": "(String pattern, boolean isIpv4)", "modifiers": "private static", "return": "String[]", "signature": "String[] getPatternHostAndPort(String pattern, boolean isIpv4)", "full_signature": "private static String[] getPatternHostAndPort(String pattern, boolean isIpv4)", "class_method_signature": "NetUtils.getPatternHostAndPort(String pattern, boolean isIpv4)", "testcase": false, "constructor": false}, {"identifier": "getNumOfIpSegment", "parameters": "(String ipSegment, boolean isIpv4)", "modifiers": "private static", "return": "Integer", "signature": "Integer getNumOfIpSegment(String ipSegment, boolean isIpv4)", "full_signature": "private static Integer getNumOfIpSegment(String ipSegment, boolean isIpv4)", "class_method_signature": "NetUtils.getNumOfIpSegment(String ipSegment, boolean isIpv4)", "testcase": false, "constructor": false}], "file": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java"}, "focal_method": {"identifier": "matchIpRange", "parameters": "(String pattern, String host, int port)", "modifiers": "public static", "return": "boolean", "body": "public static boolean matchIpRange(String pattern, String host, int port) throws UnknownHostException {\n        if (pattern == null || host == null) {\n            throw new IllegalArgumentException(\"Illegal Argument pattern or hostName. Pattern:\" + pattern + \", Host:\" + host);\n        }\n        pattern = pattern.trim();\n        if (\"*.*.*.*\".equals(pattern) || \"*\".equals(pattern)) {\n            return true;\n        }\n\n        InetAddress inetAddress = InetAddress.getByName(host);\n        boolean isIpv4 = isValidV4Address(inetAddress);\n        String[] hostAndPort = getPatternHostAndPort(pattern, isIpv4);\n        if (hostAndPort[1] != null && !hostAndPort[1].equals(String.valueOf(port))) {\n            return false;\n        }\n        pattern = hostAndPort[0];\n\n        String splitCharacter = SPLIT_IPV4_CHARACTER;\n        if (!isIpv4) {\n            splitCharacter = SPLIT_IPV6_CHARACTER;\n        }\n        String[] mask = pattern.split(splitCharacter);\n        //check format of pattern\n        checkHostPattern(pattern, mask, isIpv4);\n\n        host = inetAddress.getHostAddress();\n        if (pattern.equals(host)) {\n            return true;\n        }\n\n        // short name condition\n        if (!ipPatternContainExpression(pattern)) {\n            InetAddress patternAddress = InetAddress.getByName(pattern);\n            return patternAddress.getHostAddress().equals(host);\n            }\n\n        String[] ipAddress = host.split(splitCharacter);\n        for (int i = 0; i < mask.length; i++) {\n            if (\"*\".equals(mask[i]) || mask[i].equals(ipAddress[i])) {\n                continue;\n            } else if (mask[i].contains(\"-\")) {\n                String[] rangeNumStrs = StringUtils.split(mask[i], '-');\n                if (rangeNumStrs.length != 2) {\n                    throw new IllegalArgumentException(\"There is wrong format of ip Address: \" + mask[i]);\n                }\n                Integer min = getNumOfIpSegment(rangeNumStrs[0], isIpv4);\n                Integer max = getNumOfIpSegment(rangeNumStrs[1], isIpv4);\n                Integer ip = getNumOfIpSegment(ipAddress[i], isIpv4);\n                if (ip < min || ip > max) {\n                    return false;\n                }\n            } else if (\"0\".equals(ipAddress[i]) && (\"0\".equals(mask[i]) || \"00\".equals(mask[i]) || \"000\".equals(mask[i]) || \"0000\".equals(mask[i]))) {\n                continue;\n            } else if (!mask[i].equals(ipAddress[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "signature": "boolean matchIpRange(String pattern, String host, int port)", "full_signature": "public static boolean matchIpRange(String pattern, String host, int port)", "class_method_signature": "NetUtils.matchIpRange(String pattern, String host, int port)", "testcase": false, "constructor": false, "invocations": ["trim", "equals", "equals", "getByName", "isValidV4Address", "getPatternHostAndPort", "equals", "valueOf", "split", "checkHostPattern", "getHostAddress", "equals", "ipPatternContainExpression", "getByName", "equals", "getHostAddress", "split", "equals", "equals", "contains", "split", "getNumOfIpSegment", "getNumOfIpSegment", "getNumOfIpSegment", "equals", "equals", "equals", "equals", "equals", "equals"]}, "repository": {"repo_id": 4710920, "url": "https://github.com/apache/dubbo", "stars": 30960, "created": "6/19/2012 7:56:02 AM +00:00", "updates": "2020-01-27T14:21:03+00:00", "fork": "False", "license": "licensed"}}