{"test_class": {"identifier": "ShapeUpdaterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Player player;", "modifier": "private", "type": "Player", "declarator": "player", "var_name": "player"}, {"original_string": "private CoordinateSystem coords;", "modifier": "private", "type": "CoordinateSystem", "declarator": "coords", "var_name": "coords"}, {"original_string": "private ShapeUpdater updater;", "modifier": "private", "type": "ShapeUpdater", "declarator": "updater", "var_name": "updater"}, {"original_string": "private ShapeTable table;", "modifier": "private", "type": "ShapeTable", "declarator": "table", "var_name": "table"}], "file": "src/edu/lclark/orego/mcts/ShapeUpdaterTest.java"}, "test_case": {"identifier": "testUpdateTree", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testUpdateTree() {\n\t\tMcRunnable runnable = player.getMcRunnable(0);\n\t\tBoard board = runnable.getBoard();\n\t\trunnable.acceptMove(coords.at(\"a1\"));\n\t\trunnable.acceptMove(coords.at(\"b1\"));\n\t\tlong hash = PatternFinder.getHash(board, coords.at(\"c1\"), 3,\n\t\t\t\tcoords.at(\"b1\"));\n\t\tdouble before = table.getWinRate(hash);\n\t\trunnable.acceptMove(coords.at(\"c1\"));\n\t\tupdater.updateTree(BLACK, runnable);\n\t\trunnable.copyDataFrom(player.getBoard());\n\t\trunnable.acceptMove(coords.at(\"a1\"));\n\t\trunnable.acceptMove(coords.at(\"b1\"));\n\t\thash = PatternFinder\n\t\t\t\t.getHash(board, coords.at(\"c1\"), 3, coords.at(\"b1\"));\n\t\tdouble after = table.getWinRate(hash);\n\t\tassertTrue(after > before);\n\t}", "signature": "void testUpdateTree()", "full_signature": "@Test public void testUpdateTree()", "class_method_signature": "ShapeUpdaterTest.testUpdateTree()", "testcase": true, "constructor": false, "invocations": ["getMcRunnable", "getBoard", "acceptMove", "at", "acceptMove", "at", "getHash", "at", "at", "getWinRate", "acceptMove", "at", "updateTree", "copyDataFrom", "getBoard", "acceptMove", "at", "acceptMove", "at", "getHash", "at", "at", "getWinRate", "assertTrue"]}, "focal_class": {"identifier": "ShapeUpdater", "superclass": "", "interfaces": "implements TreeUpdater", "fields": [{"original_string": "private final TreeUpdater updater;", "modifier": "private final", "type": "TreeUpdater", "declarator": "updater", "var_name": "updater"}, {"original_string": "private final ShapeTable shapeTable;", "modifier": "private final", "type": "ShapeTable", "declarator": "shapeTable", "var_name": "shapeTable"}], "methods": [{"identifier": "ShapeUpdater", "parameters": "(TreeUpdater updater, ShapeTable shapeTable)", "modifiers": "public", "return": "", "signature": " ShapeUpdater(TreeUpdater updater, ShapeTable shapeTable)", "full_signature": "public  ShapeUpdater(TreeUpdater updater, ShapeTable shapeTable)", "class_method_signature": "ShapeUpdater.ShapeUpdater(TreeUpdater updater, ShapeTable shapeTable)", "testcase": false, "constructor": true}, {"identifier": "clear", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void clear()", "full_signature": "@Override public void clear()", "class_method_signature": "ShapeUpdater.clear()", "testcase": false, "constructor": false}, {"identifier": "getGestation", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getGestation()", "full_signature": "@Override public int getGestation()", "class_method_signature": "ShapeUpdater.getGestation()", "testcase": false, "constructor": false}, {"identifier": "getRoot", "parameters": "()", "modifiers": "@Override public", "return": "SearchNode", "signature": "SearchNode getRoot()", "full_signature": "@Override public SearchNode getRoot()", "class_method_signature": "ShapeUpdater.getRoot()", "testcase": false, "constructor": false}, {"identifier": "updateForAcceptMove", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void updateForAcceptMove()", "full_signature": "@Override public void updateForAcceptMove()", "class_method_signature": "ShapeUpdater.updateForAcceptMove()", "testcase": false, "constructor": false}, {"identifier": "updateTree", "parameters": "(Color winner, McRunnable runnable)", "modifiers": "@Override public", "return": "void", "signature": "void updateTree(Color winner, McRunnable runnable)", "full_signature": "@Override public void updateTree(Color winner, McRunnable runnable)", "class_method_signature": "ShapeUpdater.updateTree(Color winner, McRunnable runnable)", "testcase": false, "constructor": false}, {"identifier": "getTable", "parameters": "()", "modifiers": "public", "return": "ShapeTable", "signature": "ShapeTable getTable()", "full_signature": "public ShapeTable getTable()", "class_method_signature": "ShapeUpdater.getTable()", "testcase": false, "constructor": false}], "file": "src/edu/lclark/orego/mcts/ShapeUpdater.java"}, "focal_method": {"identifier": "updateTree", "parameters": "(Color winner, McRunnable runnable)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void updateTree(Color winner, McRunnable runnable) {\n\t\tupdater.updateTree(winner, runnable);\n\t\tif (winner != VACANT) {\n\t\t\tBoard playerBoard = runnable.getPlayer().getBoard();\n//\t\t\tHistoryObserver history = new HistoryObserver(playerBoard.getCoordinateSystem());\n\t\t\tboolean win = winner == playerBoard.getColorToPlay();\n\t\t\tint turn = runnable.getTurn();\n\t\t\tBoard board = runnable.getBoard();\n\t\t\tHistoryObserver history = new HistoryObserver(board.getCoordinateSystem());\n\t\t\thistory.copyDataFrom(runnable.getHistoryObserver());\n\t\t\tboard.copyDataFrom(playerBoard);\n\t\t\tint k = 0; // Don't gather data beyond a certain depth\n\t\t\tfor (int t = playerBoard.getTurn(); t < turn; t++) {\n\t\t\t\tif (k == 20) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk++;\n\t\t\t\tshort p = history.get(t);\n\t\t\t\t// TODO Get rid of magic number 3\n\t\t\t\tlong hash = PatternFinder.getHash(board, p, 3,\n\t\t\t\t\t\thistory.get(t - 1));\n\t\t\t\t// TODO Make win a double or float, so we can incorporate\n\t\t\t\t// ties (winner == VACANT above).\n\t\t\t\tshapeTable.update(hash, win);\n\t\t\t\t// System.out.println(\"Playing \" +\n\t\t\t\t// board.getCoordinateSystem().toString(p));\n\t\t\t\tboard.play(p);\n\t\t\t\twin = !win;\n\t\t\t}\n\t\t}\n\t}", "signature": "void updateTree(Color winner, McRunnable runnable)", "full_signature": "@Override public void updateTree(Color winner, McRunnable runnable)", "class_method_signature": "ShapeUpdater.updateTree(Color winner, McRunnable runnable)", "testcase": false, "constructor": false, "invocations": ["updateTree", "getBoard", "getPlayer", "getColorToPlay", "getTurn", "getBoard", "getCoordinateSystem", "copyDataFrom", "getHistoryObserver", "copyDataFrom", "getTurn", "get", "getHash", "get", "update", "play"]}, "repository": {"repo_id": 7859424, "url": "https://github.com/Orego/Orego", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 35, "size": 1341444, "license": "licensed"}}