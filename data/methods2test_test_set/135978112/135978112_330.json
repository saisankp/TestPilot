{"test_class": {"identifier": "StreamTaskTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Serializer<Integer> intSerializer = new IntegerSerializer();", "modifier": "private final", "type": "Serializer<Integer>", "declarator": "intSerializer = new IntegerSerializer()", "var_name": "intSerializer"}, {"original_string": "private final Deserializer<Integer> intDeserializer = new IntegerDeserializer();", "modifier": "private final", "type": "Deserializer<Integer>", "declarator": "intDeserializer = new IntegerDeserializer()", "var_name": "intDeserializer"}, {"original_string": "private final Serializer<byte[]> bytesSerializer = new ByteArraySerializer();", "modifier": "private final", "type": "Serializer<byte[]>", "declarator": "bytesSerializer = new ByteArraySerializer()", "var_name": "bytesSerializer"}, {"original_string": "private final TopicPartition partition1 = new TopicPartition(\"topic1\", 1);", "modifier": "private final", "type": "TopicPartition", "declarator": "partition1 = new TopicPartition(\"topic1\", 1)", "var_name": "partition1"}, {"original_string": "private final TopicPartition partition2 = new TopicPartition(\"topic2\", 1);", "modifier": "private final", "type": "TopicPartition", "declarator": "partition2 = new TopicPartition(\"topic2\", 1)", "var_name": "partition2"}, {"original_string": "private final Set<TopicPartition> partitions = Utils.mkSet(partition1, partition2);", "modifier": "private final", "type": "Set<TopicPartition>", "declarator": "partitions = Utils.mkSet(partition1, partition2)", "var_name": "partitions"}, {"original_string": "private final MockSourceNode<Integer, Integer> source1 = new MockSourceNode<>(intDeserializer, intDeserializer);", "modifier": "private final", "type": "MockSourceNode<Integer, Integer>", "declarator": "source1 = new MockSourceNode<>(intDeserializer, intDeserializer)", "var_name": "source1"}, {"original_string": "private final MockSourceNode<Integer, Integer> source2 = new MockSourceNode<>(intDeserializer, intDeserializer);", "modifier": "private final", "type": "MockSourceNode<Integer, Integer>", "declarator": "source2 = new MockSourceNode<>(intDeserializer, intDeserializer)", "var_name": "source2"}, {"original_string": "private final MockProcessorNode<Integer, Integer>  processor = new MockProcessorNode<>(10L);", "modifier": "private final", "type": "MockProcessorNode<Integer, Integer>", "declarator": "processor = new MockProcessorNode<>(10L)", "var_name": "processor"}, {"original_string": "private final ProcessorTopology topology = new ProcessorTopology(\n            Arrays.asList((ProcessorNode) source1, (ProcessorNode) source2, (ProcessorNode) processor),\n            new HashMap<String, SourceNode>() {\n                {\n                    put(\"topic1\", source1);\n                    put(\"topic2\", source2);\n                }\n            },\n            Collections.<StateStoreSupplier>emptyList()\n    );", "modifier": "private final", "type": "ProcessorTopology", "declarator": "topology = new ProcessorTopology(\n            Arrays.asList((ProcessorNode) source1, (ProcessorNode) source2, (ProcessorNode) processor),\n            new HashMap<String, SourceNode>() {\n                {\n                    put(\"topic1\", source1);\n                    put(\"topic2\", source2);\n                }\n            },\n            Collections.<StateStoreSupplier>emptyList()\n    )", "var_name": "topology"}, {"original_string": "private final MockConsumer<byte[], byte[]> consumer = new MockConsumer<>(OffsetResetStrategy.EARLIEST);", "modifier": "private final", "type": "MockConsumer<byte[], byte[]>", "declarator": "consumer = new MockConsumer<>(OffsetResetStrategy.EARLIEST)", "var_name": "consumer"}, {"original_string": "private final MockProducer<byte[], byte[]> producer = new MockProducer<>(false, bytesSerializer, bytesSerializer);", "modifier": "private final", "type": "MockProducer<byte[], byte[]>", "declarator": "producer = new MockProducer<>(false, bytesSerializer, bytesSerializer)", "var_name": "producer"}, {"original_string": "private final MockConsumer<byte[], byte[]> restoreStateConsumer = new MockConsumer<>(OffsetResetStrategy.EARLIEST);", "modifier": "private final", "type": "MockConsumer<byte[], byte[]>", "declarator": "restoreStateConsumer = new MockConsumer<>(OffsetResetStrategy.EARLIEST)", "var_name": "restoreStateConsumer"}, {"original_string": "private final byte[] recordValue = intSerializer.serialize(null, 10);", "modifier": "private final", "type": "byte[]", "declarator": "recordValue = intSerializer.serialize(null, 10)", "var_name": "recordValue"}, {"original_string": "private final byte[] recordKey = intSerializer.serialize(null, 1);", "modifier": "private final", "type": "byte[]", "declarator": "recordKey = intSerializer.serialize(null, 1)", "var_name": "recordKey"}], "file": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java"}, "test_case": {"identifier": "testMaybePunctuate", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") @Test public", "return": "void", "body": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testMaybePunctuate() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n            StreamsConfig config = createConfig(baseDir);\n            StreamTask task = new StreamTask(new TaskId(0, 0), \"applicationId\", partitions, topology, consumer, producer, restoreStateConsumer, config, null);\n\n            task.addRecords(partition1, records(\n                    new ConsumerRecord<>(partition1.topic(), partition1.partition(), 20, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n                    new ConsumerRecord<>(partition1.topic(), partition1.partition(), 30, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n                    new ConsumerRecord<>(partition1.topic(), partition1.partition(), 40, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue)\n            ));\n\n            task.addRecords(partition2, records(\n                    new ConsumerRecord<>(partition2.topic(), partition2.partition(), 25, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n                    new ConsumerRecord<>(partition2.topic(), partition2.partition(), 35, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),\n                    new ConsumerRecord<>(partition2.topic(), partition2.partition(), 45, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue)\n            ));\n\n            assertTrue(task.maybePunctuate());\n\n            assertEquals(5, task.process());\n            assertEquals(1, source1.numReceived);\n            assertEquals(0, source2.numReceived);\n\n            assertFalse(task.maybePunctuate());\n\n            assertEquals(4, task.process());\n            assertEquals(1, source1.numReceived);\n            assertEquals(1, source2.numReceived);\n\n            assertTrue(task.maybePunctuate());\n\n            assertEquals(3, task.process());\n            assertEquals(2, source1.numReceived);\n            assertEquals(1, source2.numReceived);\n\n            assertFalse(task.maybePunctuate());\n\n            assertEquals(2, task.process());\n            assertEquals(2, source1.numReceived);\n            assertEquals(2, source2.numReceived);\n\n            assertTrue(task.maybePunctuate());\n\n            assertEquals(1, task.process());\n            assertEquals(3, source1.numReceived);\n            assertEquals(2, source2.numReceived);\n\n            assertFalse(task.maybePunctuate());\n\n            assertEquals(0, task.process());\n            assertEquals(3, source1.numReceived);\n            assertEquals(3, source2.numReceived);\n\n            assertFalse(task.maybePunctuate());\n\n            processor.supplier.checkAndClearPunctuateResult(20L, 30L, 40L);\n\n            task.close();\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }", "signature": "void testMaybePunctuate()", "full_signature": "@SuppressWarnings(\"unchecked\") @Test public void testMaybePunctuate()", "class_method_signature": "StreamTaskTest.testMaybePunctuate()", "testcase": true, "constructor": false, "invocations": ["toFile", "createTempDirectory", "createConfig", "addRecords", "records", "topic", "partition", "topic", "partition", "topic", "partition", "addRecords", "records", "topic", "partition", "topic", "partition", "topic", "partition", "assertTrue", "maybePunctuate", "assertEquals", "process", "assertEquals", "assertEquals", "assertFalse", "maybePunctuate", "assertEquals", "process", "assertEquals", "assertEquals", "assertTrue", "maybePunctuate", "assertEquals", "process", "assertEquals", "assertEquals", "assertFalse", "maybePunctuate", "assertEquals", "process", "assertEquals", "assertEquals", "assertTrue", "maybePunctuate", "assertEquals", "process", "assertEquals", "assertEquals", "assertFalse", "maybePunctuate", "assertEquals", "process", "assertEquals", "assertEquals", "assertFalse", "maybePunctuate", "checkAndClearPunctuateResult", "close", "delete"]}, "focal_class": {"identifier": "StreamTask", "superclass": "extends AbstractTask", "interfaces": "implements Punctuator", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(StreamTask.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(StreamTask.class)", "var_name": "log"}, {"original_string": "private static final ConsumerRecord<Object, Object> DUMMY_RECORD = new ConsumerRecord<>(ProcessorContextImpl.NONEXIST_TOPIC, -1, -1L, null, null);", "modifier": "private static final", "type": "ConsumerRecord<Object, Object>", "declarator": "DUMMY_RECORD = new ConsumerRecord<>(ProcessorContextImpl.NONEXIST_TOPIC, -1, -1L, null, null)", "var_name": "DUMMY_RECORD"}, {"original_string": "private final int maxBufferedSize;", "modifier": "private final", "type": "int", "declarator": "maxBufferedSize", "var_name": "maxBufferedSize"}, {"original_string": "private final PartitionGroup partitionGroup;", "modifier": "private final", "type": "PartitionGroup", "declarator": "partitionGroup", "var_name": "partitionGroup"}, {"original_string": "private final PartitionGroup.RecordInfo recordInfo = new PartitionGroup.RecordInfo();", "modifier": "private final", "type": "PartitionGroup.RecordInfo", "declarator": "recordInfo = new PartitionGroup.RecordInfo()", "var_name": "recordInfo"}, {"original_string": "private final PunctuationQueue punctuationQueue;", "modifier": "private final", "type": "PunctuationQueue", "declarator": "punctuationQueue", "var_name": "punctuationQueue"}, {"original_string": "private final Map<TopicPartition, Long> consumedOffsets;", "modifier": "private final", "type": "Map<TopicPartition, Long>", "declarator": "consumedOffsets", "var_name": "consumedOffsets"}, {"original_string": "private final RecordCollector recordCollector;", "modifier": "private final", "type": "RecordCollector", "declarator": "recordCollector", "var_name": "recordCollector"}, {"original_string": "private boolean commitRequested = false;", "modifier": "private", "type": "boolean", "declarator": "commitRequested = false", "var_name": "commitRequested"}, {"original_string": "private boolean commitOffsetNeeded = false;", "modifier": "private", "type": "boolean", "declarator": "commitOffsetNeeded = false", "var_name": "commitOffsetNeeded"}, {"original_string": "private StampedRecord currRecord = null;", "modifier": "private", "type": "StampedRecord", "declarator": "currRecord = null", "var_name": "currRecord"}, {"original_string": "private ProcessorNode currNode = null;", "modifier": "private", "type": "ProcessorNode", "declarator": "currNode = null", "var_name": "currNode"}, {"original_string": "private boolean requiresPoll = true;", "modifier": "private", "type": "boolean", "declarator": "requiresPoll = true", "var_name": "requiresPoll"}], "methods": [{"identifier": "StreamTask", "parameters": "(TaskId id,\n                      String applicationId,\n                      Collection<TopicPartition> partitions,\n                      ProcessorTopology topology,\n                      Consumer<byte[], byte[]> consumer,\n                      Producer<byte[], byte[]> producer,\n                      Consumer<byte[], byte[]> restoreConsumer,\n                      StreamsConfig config,\n                      StreamsMetrics metrics)", "modifiers": "public", "return": "", "signature": " StreamTask(TaskId id,\n                      String applicationId,\n                      Collection<TopicPartition> partitions,\n                      ProcessorTopology topology,\n                      Consumer<byte[], byte[]> consumer,\n                      Producer<byte[], byte[]> producer,\n                      Consumer<byte[], byte[]> restoreConsumer,\n                      StreamsConfig config,\n                      StreamsMetrics metrics)", "full_signature": "public  StreamTask(TaskId id,\n                      String applicationId,\n                      Collection<TopicPartition> partitions,\n                      ProcessorTopology topology,\n                      Consumer<byte[], byte[]> consumer,\n                      Producer<byte[], byte[]> producer,\n                      Consumer<byte[], byte[]> restoreConsumer,\n                      StreamsConfig config,\n                      StreamsMetrics metrics)", "class_method_signature": "StreamTask.StreamTask(TaskId id,\n                      String applicationId,\n                      Collection<TopicPartition> partitions,\n                      ProcessorTopology topology,\n                      Consumer<byte[], byte[]> consumer,\n                      Producer<byte[], byte[]> producer,\n                      Consumer<byte[], byte[]> restoreConsumer,\n                      StreamsConfig config,\n                      StreamsMetrics metrics)", "testcase": false, "constructor": true}, {"identifier": "addRecords", "parameters": "(TopicPartition partition, Iterable<ConsumerRecord<byte[], byte[]>> records)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "void", "signature": "void addRecords(TopicPartition partition, Iterable<ConsumerRecord<byte[], byte[]>> records)", "full_signature": "@SuppressWarnings(\"unchecked\") public void addRecords(TopicPartition partition, Iterable<ConsumerRecord<byte[], byte[]>> records)", "class_method_signature": "StreamTask.addRecords(TopicPartition partition, Iterable<ConsumerRecord<byte[], byte[]>> records)", "testcase": false, "constructor": false}, {"identifier": "process", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "int", "signature": "int process()", "full_signature": "@SuppressWarnings(\"unchecked\") public int process()", "class_method_signature": "StreamTask.process()", "testcase": false, "constructor": false}, {"identifier": "requiresPoll", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean requiresPoll()", "full_signature": "public boolean requiresPoll()", "class_method_signature": "StreamTask.requiresPoll()", "testcase": false, "constructor": false}, {"identifier": "maybePunctuate", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean maybePunctuate()", "full_signature": "public boolean maybePunctuate()", "class_method_signature": "StreamTask.maybePunctuate()", "testcase": false, "constructor": false}, {"identifier": "punctuate", "parameters": "(ProcessorNode node, long timestamp)", "modifiers": "@Override public", "return": "void", "signature": "void punctuate(ProcessorNode node, long timestamp)", "full_signature": "@Override public void punctuate(ProcessorNode node, long timestamp)", "class_method_signature": "StreamTask.punctuate(ProcessorNode node, long timestamp)", "testcase": false, "constructor": false}, {"identifier": "record", "parameters": "()", "modifiers": "public", "return": "StampedRecord", "signature": "StampedRecord record()", "full_signature": "public StampedRecord record()", "class_method_signature": "StreamTask.record()", "testcase": false, "constructor": false}, {"identifier": "node", "parameters": "()", "modifiers": "public", "return": "ProcessorNode", "signature": "ProcessorNode node()", "full_signature": "public ProcessorNode node()", "class_method_signature": "StreamTask.node()", "testcase": false, "constructor": false}, {"identifier": "commit", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void commit()", "full_signature": "public void commit()", "class_method_signature": "StreamTask.commit()", "testcase": false, "constructor": false}, {"identifier": "commitNeeded", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean commitNeeded()", "full_signature": "public boolean commitNeeded()", "class_method_signature": "StreamTask.commitNeeded()", "testcase": false, "constructor": false}, {"identifier": "needCommit", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void needCommit()", "full_signature": "public void needCommit()", "class_method_signature": "StreamTask.needCommit()", "testcase": false, "constructor": false}, {"identifier": "schedule", "parameters": "(long interval)", "modifiers": "public", "return": "void", "signature": "void schedule(long interval)", "full_signature": "public void schedule(long interval)", "class_method_signature": "StreamTask.schedule(long interval)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "StreamTask.close()", "testcase": false, "constructor": false}, {"identifier": "recordCollectorOffsets", "parameters": "()", "modifiers": "@Override protected", "return": "Map<TopicPartition, Long>", "signature": "Map<TopicPartition, Long> recordCollectorOffsets()", "full_signature": "@Override protected Map<TopicPartition, Long> recordCollectorOffsets()", "class_method_signature": "StreamTask.recordCollectorOffsets()", "testcase": false, "constructor": false}, {"identifier": "createRecordQueue", "parameters": "(TopicPartition partition, SourceNode source)", "modifiers": "private", "return": "RecordQueue", "signature": "RecordQueue createRecordQueue(TopicPartition partition, SourceNode source)", "full_signature": "private RecordQueue createRecordQueue(TopicPartition partition, SourceNode source)", "class_method_signature": "StreamTask.createRecordQueue(TopicPartition partition, SourceNode source)", "testcase": false, "constructor": false}, {"identifier": "forward", "parameters": "(K key, V value)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "void", "signature": "void forward(K key, V value)", "full_signature": "@SuppressWarnings(\"unchecked\") public void forward(K key, V value)", "class_method_signature": "StreamTask.forward(K key, V value)", "testcase": false, "constructor": false}, {"identifier": "forward", "parameters": "(K key, V value, int childIndex)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "void", "signature": "void forward(K key, V value, int childIndex)", "full_signature": "@SuppressWarnings(\"unchecked\") public void forward(K key, V value, int childIndex)", "class_method_signature": "StreamTask.forward(K key, V value, int childIndex)", "testcase": false, "constructor": false}, {"identifier": "forward", "parameters": "(K key, V value, String childName)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "void", "signature": "void forward(K key, V value, String childName)", "full_signature": "@SuppressWarnings(\"unchecked\") public void forward(K key, V value, String childName)", "class_method_signature": "StreamTask.forward(K key, V value, String childName)", "testcase": false, "constructor": false}], "file": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java"}, "focal_method": {"identifier": "maybePunctuate", "parameters": "()", "modifiers": "public", "return": "boolean", "body": "public boolean maybePunctuate() {\n        long timestamp = partitionGroup.timestamp();\n\n        // if the timestamp is not known yet, meaning there is not enough data accumulated\n        // to reason stream partition time, then skip.\n        if (timestamp == TimestampTracker.NOT_KNOWN)\n            return false;\n        else\n            return punctuationQueue.mayPunctuate(timestamp, this);\n    }", "signature": "boolean maybePunctuate()", "full_signature": "public boolean maybePunctuate()", "class_method_signature": "StreamTask.maybePunctuate()", "testcase": false, "constructor": false, "invocations": ["timestamp", "mayPunctuate"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}