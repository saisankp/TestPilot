{"test_class": {"identifier": "TestTextPatternParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n    public ExpectedException thrown = ExpectedException.none();", "modifier": "@Rule\n    public", "type": "ExpectedException", "declarator": "thrown = ExpectedException.none()", "var_name": "thrown"}, {"original_string": "private Class<TextPatternParser.TextPatternParsingException> ParsingException = TextPatternParser.TextPatternParsingException.class;", "modifier": "private", "type": "Class<TextPatternParser.TextPatternParsingException>", "declarator": "ParsingException = TextPatternParser.TextPatternParsingException.class", "var_name": "ParsingException"}, {"original_string": "private final String EXAMPLE_TEXT_SEGMENT = \"\\\"Hello world!\\\"\";", "modifier": "private final", "type": "String", "declarator": "EXAMPLE_TEXT_SEGMENT = \"\\\"Hello world!\\\"\"", "var_name": "EXAMPLE_TEXT_SEGMENT"}, {"original_string": "private final String EXAMPLE_TEXT_SEGMENT_WITH_ESCAPED_QUOTES = \"\\\"This is an \\\\\\\"escaped\\\\\\\" text\\\"\";", "modifier": "private final", "type": "String", "declarator": "EXAMPLE_TEXT_SEGMENT_WITH_ESCAPED_QUOTES = \"\\\"This is an \\\\\\\"escaped\\\\\\\" text\\\"\"", "var_name": "EXAMPLE_TEXT_SEGMENT_WITH_ESCAPED_QUOTES"}, {"original_string": "private final String EXAMPLE_SEQUENTIAL_SEGMENT = \"SEQUENTIAL(#)\";", "modifier": "private final", "type": "String", "declarator": "EXAMPLE_SEQUENTIAL_SEGMENT = \"SEQUENTIAL(#)\"", "var_name": "EXAMPLE_SEQUENTIAL_SEGMENT"}, {"original_string": "private final String EXAMPLE_RANDOM_SEGMENT = \"RANDOM(#Xx*)\";", "modifier": "private final", "type": "String", "declarator": "EXAMPLE_RANDOM_SEGMENT = \"RANDOM(#Xx*)\"", "var_name": "EXAMPLE_RANDOM_SEGMENT"}], "file": "dhis-2/dhis-services/dhis-service-core/src/test/java/org/hisp/dhis/textpattern/TestTextPatternParser.java"}, "test_case": {"identifier": "testParseEmptyExpressionThrowsException", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testParseEmptyExpressionThrowsException()\n        throws TextPatternParser.TextPatternParsingException\n    {\n        thrown.expect( ParsingException );\n        TextPatternParser.parse( \"\" );\n    }", "signature": "void testParseEmptyExpressionThrowsException()", "full_signature": "@Test public void testParseEmptyExpressionThrowsException()", "class_method_signature": "TestTextPatternParser.testParseEmptyExpressionThrowsException()", "testcase": true, "constructor": false, "invocations": ["expect", "parse"]}, "focal_class": {"identifier": "TextPatternParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String METHOD_REGEX = \"(?<MethodName>[A-Z_]+?)\\\\(.*?\\\\)\";", "modifier": "private static final", "type": "String", "declarator": "METHOD_REGEX = \"(?<MethodName>[A-Z_]+?)\\\\(.*?\\\\)\"", "var_name": "METHOD_REGEX"}, {"original_string": "private static final String JOIN_REGEX = \"(?<Join>[\\\\s]*(?<JoinValue>\\\\+)[\\\\s]*)\";", "modifier": "private static final", "type": "String", "declarator": "JOIN_REGEX = \"(?<Join>[\\\\s]*(?<JoinValue>\\\\+)[\\\\s]*)\"", "var_name": "JOIN_REGEX"}, {"original_string": "private static final String TEXT_REGEX = \"\\\"[^\\\"\\\\\\\\]*(?:\\\\\\\\.[^\\\"\\\\\\\\]*)*\\\"\";", "modifier": "private static final", "type": "String", "declarator": "TEXT_REGEX = \"\\\"[^\\\"\\\\\\\\]*(?:\\\\\\\\.[^\\\"\\\\\\\\]*)*\\\"\"", "var_name": "TEXT_REGEX"}, {"original_string": "private static final Pattern EXPRESSION_REGEX = Pattern.compile(\n        String.format( \"[\\\\s]*(?<Segment>(?<Method>%s|%s)|%s)+?[\\\\s]*\", TEXT_REGEX, METHOD_REGEX, JOIN_REGEX )\n    );", "modifier": "private static final", "type": "Pattern", "declarator": "EXPRESSION_REGEX = Pattern.compile(\n        String.format( \"[\\\\s]*(?<Segment>(?<Method>%s|%s)|%s)+?[\\\\s]*\", TEXT_REGEX, METHOD_REGEX, JOIN_REGEX )\n    )", "var_name": "EXPRESSION_REGEX"}], "methods": [{"identifier": "parse", "parameters": "( String pattern )", "modifiers": "public static", "return": "TextPattern", "signature": "TextPattern parse( String pattern )", "full_signature": "public static TextPattern parse( String pattern )", "class_method_signature": "TextPatternParser.parse( String pattern )", "testcase": false, "constructor": false}], "file": "dhis-2/dhis-services/dhis-service-core/src/main/java/org/hisp/dhis/textpattern/TextPatternParser.java"}, "focal_method": {"identifier": "parse", "parameters": "( String pattern )", "modifiers": "public static", "return": "TextPattern", "body": "public static TextPattern parse( String pattern )\n        throws TextPatternParsingException\n    {\n        List<TextPatternSegment> segments = new ArrayList<>();\n\n        // True if we just parsed a Segment, False if we parsed a join or haven't parsed anything.\n        boolean segment = false;\n\n        boolean invalidExpression = true;\n\n        Matcher m;\n\n        if ( pattern != null && !pattern.isEmpty() )\n        {\n            m = EXPRESSION_REGEX.matcher( pattern );\n        }\n        else\n        {\n            throw new TextPatternParsingException( \"Supplied expression was null or empty.\", -1 );\n        }\n\n        /*\n         * We go trough all matches. Matches can be one of the following:\n         * \n         * <ul>\n         *   <li>a TEXT method (\"..\")</li>\n         *   <li>any TextPatternMethod (Excluding TEXT) (method(param))</li>\n         *   <li>a join ( + )</li>\n         * </ul>\n         *\n         * Matches that are invalid includes methods with unknown method names\n         */\n        while ( m.find() )\n        {\n            invalidExpression = false;\n\n            // This returns the entire method syntax, including params\n            String method = m.group( \"Method\" );\n\n            // This means we found a match for method syntax\n            if ( method != null )\n            {\n\n                // This returns only the name of the method (see TextPatternMethod for valid names)\n                String methodName = m.group( \"MethodName\" );\n\n                // This means we encountered the syntax for TEXT method\n                if ( methodName == null ) // Text\n                {\n\n                    // Only add if valid syntax, else it will throw exception after if-else.\n                    if ( TextPatternMethod.TEXT.getType().validatePattern( method ) )\n                    {\n                        segment = true;\n                        segments.add( new TextPatternSegment( TextPatternMethod.TEXT, method ) );\n                        continue;\n                    }\n\n                }\n\n                // Catch all other methods\n                else\n                {\n                    // Attempt to find a matching method name in TextPatternMethod\n                    try\n                    {\n                        TextPatternMethod textPatternMethod = TextPatternMethod.valueOf( methodName );\n\n                        // Only add if valid syntax, else it will throw exception after if-else.\n                        if ( textPatternMethod.getType().validatePattern( method ) )\n                        {\n                            segment = true;\n                            segments.add( new TextPatternSegment( textPatternMethod, method ) );\n                            continue;\n                        }\n                    }\n                    catch ( Exception e )\n                    {\n                        // Ignore, throw exception after if-else if we get here.\n                    }\n                }\n\n                // If we are here, that means we found no matching methods, so throw an exception\n                throw new TextPatternParsingException( \"Failed to parse the following method: '\" + method + \"'\", m.start( \"Method\" ) );\n            }\n\n            // Handle Join\n            else if ( m.group( \"Join\" ) != null )\n            {\n                // Join should only be after a Segment\n                if ( !segment )\n                {\n                    throw new TextPatternParsingException( \"Unexpected '+'\", m.start( \"JoinValue\" ) );\n                }\n                else\n                {\n                    segment = false;\n                }\n            }\n        }\n\n        // If the matcher had no matches\n        if ( invalidExpression )\n        {\n            throw new TextPatternParsingException( \"The expression is invalid\", -1 );\n        }\n\n        // An expression should not end on a Join\n        if ( !segment )\n        {\n            throw new TextPatternParsingException( \"Unexpected '+' at the end of the expression\", -1 );\n        }\n\n        return new TextPattern( segments );\n    }", "signature": "TextPattern parse( String pattern )", "full_signature": "public static TextPattern parse( String pattern )", "class_method_signature": "TextPatternParser.parse( String pattern )", "testcase": false, "constructor": false, "invocations": ["isEmpty", "matcher", "find", "group", "group", "validatePattern", "getType", "add", "valueOf", "validatePattern", "getType", "add", "start", "group", "start"]}, "repository": {"repo_id": 66940520, "url": "https://github.com/dhis2/dhis2-core", "stars": 151, "created": "8/30/2016 12:57:05 PM +00:00", "updates": "2020-01-24T18:06:36+00:00", "fork": "False", "license": "licensed"}}