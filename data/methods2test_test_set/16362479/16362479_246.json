{"test_class": {"identifier": "SnapshotTrackerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(SnapshotTrackerTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(SnapshotTrackerTest.class)", "var_name": "LOG"}, {"original_string": "@Mock\n    private RaftActorContext mockContext;", "modifier": "@Mock\n    private", "type": "RaftActorContext", "declarator": "mockContext", "var_name": "mockContext"}, {"original_string": "private FileBackedOutputStream fbos;", "modifier": "private", "type": "FileBackedOutputStream", "declarator": "fbos", "var_name": "fbos"}, {"original_string": "private Map<String, String> data;", "modifier": "private", "type": "Map<String, String>", "declarator": "data", "var_name": "data"}, {"original_string": "private ByteString byteString;", "modifier": "private", "type": "ByteString", "declarator": "byteString", "var_name": "byteString"}, {"original_string": "private byte[] chunk1;", "modifier": "private", "type": "byte[]", "declarator": "chunk1", "var_name": "chunk1"}, {"original_string": "private byte[] chunk2;", "modifier": "private", "type": "byte[]", "declarator": "chunk2", "var_name": "chunk2"}, {"original_string": "private byte[] chunk3;", "modifier": "private", "type": "byte[]", "declarator": "chunk3", "var_name": "chunk3"}], "file": "opendaylight/md-sal/sal-akka-raft/src/test/java/org/opendaylight/controller/cluster/raft/behaviors/SnapshotTrackerTest.java"}, "test_case": {"identifier": "testInvalidFirstChunkIndex", "parameters": "()", "modifiers": "@Test(expected = SnapshotTracker.InvalidChunkException.class) public", "return": "void", "body": "@Test(expected = SnapshotTracker.InvalidChunkException.class)\n    public void testInvalidFirstChunkIndex() throws IOException {\n        try (SnapshotTracker tracker = new SnapshotTracker(LOG, 2, \"leader\", mockContext)) {\n            tracker.addChunk(LeaderInstallSnapshotState.FIRST_CHUNK_INDEX - 1, chunk1, OptionalInt.empty());\n        }\n    }", "signature": "void testInvalidFirstChunkIndex()", "full_signature": "@Test(expected = SnapshotTracker.InvalidChunkException.class) public void testInvalidFirstChunkIndex()", "class_method_signature": "SnapshotTrackerTest.testInvalidFirstChunkIndex()", "testcase": true, "constructor": false, "invocations": ["addChunk", "empty"]}, "focal_class": {"identifier": "SnapshotTracker", "superclass": "", "interfaces": "implements AutoCloseable", "fields": [{"original_string": "private final Logger log;", "modifier": "private final", "type": "Logger", "declarator": "log", "var_name": "log"}, {"original_string": "private final int totalChunks;", "modifier": "private final", "type": "int", "declarator": "totalChunks", "var_name": "totalChunks"}, {"original_string": "private final String leaderId;", "modifier": "private final", "type": "String", "declarator": "leaderId", "var_name": "leaderId"}, {"original_string": "private final BufferedOutputStream bufferedStream;", "modifier": "private final", "type": "BufferedOutputStream", "declarator": "bufferedStream", "var_name": "bufferedStream"}, {"original_string": "private final FileBackedOutputStream fileBackedStream;", "modifier": "private final", "type": "FileBackedOutputStream", "declarator": "fileBackedStream", "var_name": "fileBackedStream"}, {"original_string": "private int lastChunkIndex = LeaderInstallSnapshotState.FIRST_CHUNK_INDEX - 1;", "modifier": "private", "type": "int", "declarator": "lastChunkIndex = LeaderInstallSnapshotState.FIRST_CHUNK_INDEX - 1", "var_name": "lastChunkIndex"}, {"original_string": "private boolean sealed = false;", "modifier": "private", "type": "boolean", "declarator": "sealed = false", "var_name": "sealed"}, {"original_string": "private int lastChunkHashCode = LeaderInstallSnapshotState.INITIAL_LAST_CHUNK_HASH_CODE;", "modifier": "private", "type": "int", "declarator": "lastChunkHashCode = LeaderInstallSnapshotState.INITIAL_LAST_CHUNK_HASH_CODE", "var_name": "lastChunkHashCode"}, {"original_string": "private long count;", "modifier": "private", "type": "long", "declarator": "count", "var_name": "count"}], "methods": [{"identifier": "SnapshotTracker", "parameters": "(final Logger log, final int totalChunks, final String leaderId, final RaftActorContext context)", "modifiers": "", "return": "", "signature": " SnapshotTracker(final Logger log, final int totalChunks, final String leaderId, final RaftActorContext context)", "full_signature": "  SnapshotTracker(final Logger log, final int totalChunks, final String leaderId, final RaftActorContext context)", "class_method_signature": "SnapshotTracker.SnapshotTracker(final Logger log, final int totalChunks, final String leaderId, final RaftActorContext context)", "testcase": false, "constructor": true}, {"identifier": "addChunk", "parameters": "(final int chunkIndex, final byte[] chunk, final OptionalInt maybeLastChunkHashCode)", "modifiers": "", "return": "boolean", "signature": "boolean addChunk(final int chunkIndex, final byte[] chunk, final OptionalInt maybeLastChunkHashCode)", "full_signature": " boolean addChunk(final int chunkIndex, final byte[] chunk, final OptionalInt maybeLastChunkHashCode)", "class_method_signature": "SnapshotTracker.addChunk(final int chunkIndex, final byte[] chunk, final OptionalInt maybeLastChunkHashCode)", "testcase": false, "constructor": false}, {"identifier": "getSnapshotBytes", "parameters": "()", "modifiers": "", "return": "ByteSource", "signature": "ByteSource getSnapshotBytes()", "full_signature": " ByteSource getSnapshotBytes()", "class_method_signature": "SnapshotTracker.getSnapshotBytes()", "testcase": false, "constructor": false}, {"identifier": "getLeaderId", "parameters": "()", "modifiers": "", "return": "String", "signature": "String getLeaderId()", "full_signature": " String getLeaderId()", "class_method_signature": "SnapshotTracker.getLeaderId()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "SnapshotTracker.close()", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-akka-raft/src/main/java/org/opendaylight/controller/cluster/raft/behaviors/SnapshotTracker.java"}, "focal_method": {"identifier": "addChunk", "parameters": "(final int chunkIndex, final byte[] chunk, final OptionalInt maybeLastChunkHashCode)", "modifiers": "", "return": "boolean", "body": "boolean addChunk(final int chunkIndex, final byte[] chunk, final OptionalInt maybeLastChunkHashCode)\n            throws InvalidChunkException, IOException {\n        log.debug(\"addChunk: chunkIndex={}, lastChunkIndex={}, collectedChunks.size={}, lastChunkHashCode={}\",\n                chunkIndex, lastChunkIndex, count, this.lastChunkHashCode);\n\n        if (sealed) {\n            throw new InvalidChunkException(\"Invalid chunk received with chunkIndex \" + chunkIndex\n                    + \" all chunks already received\");\n        }\n\n        if (lastChunkIndex + 1 != chunkIndex) {\n            throw new InvalidChunkException(\"Expected chunkIndex \" + (lastChunkIndex + 1) + \" got \" + chunkIndex);\n        }\n\n        if (maybeLastChunkHashCode.isPresent() && maybeLastChunkHashCode.getAsInt() != this.lastChunkHashCode) {\n            throw new InvalidChunkException(\"The hash code of the recorded last chunk does not match \"\n                    + \"the senders hash code, expected \" + this.lastChunkHashCode + \" was \"\n                    + maybeLastChunkHashCode.getAsInt());\n        }\n\n        bufferedStream.write(chunk);\n\n        count += chunk.length;\n        sealed = chunkIndex == totalChunks;\n        lastChunkIndex = chunkIndex;\n        this.lastChunkHashCode = Arrays.hashCode(chunk);\n        return sealed;\n    }", "signature": "boolean addChunk(final int chunkIndex, final byte[] chunk, final OptionalInt maybeLastChunkHashCode)", "full_signature": " boolean addChunk(final int chunkIndex, final byte[] chunk, final OptionalInt maybeLastChunkHashCode)", "class_method_signature": "SnapshotTracker.addChunk(final int chunkIndex, final byte[] chunk, final OptionalInt maybeLastChunkHashCode)", "testcase": false, "constructor": false, "invocations": ["debug", "isPresent", "getAsInt", "getAsInt", "write", "hashCode"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}