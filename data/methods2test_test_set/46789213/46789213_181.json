{"test_class": {"identifier": "TestAesCtrDrbg", "superclass": "", "interfaces": "", "fields": [], "file": "core/src/test/java/dk/alexandra/fresco/framework/util/TestAesCtrDrbg.java"}, "test_case": {"identifier": "testNextBytesEqualSeed", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testNextBytesEqualSeed() {\n    Random rand = new Random(42);\n    final byte[] seed = new byte[32];\n    rand.nextBytes(seed);\n    AesCtrDrbg drbg1 = new AesCtrDrbg(seed);\n    AesCtrDrbg drbg2 = new AesCtrDrbg(seed);\n    final int arraySize = 1500;\n    byte[] bytes1 = new byte[arraySize];\n    byte[] bytes2 = new byte[arraySize];\n    drbg1.nextBytes(bytes1);\n    drbg2.nextBytes(bytes2);\n    assertArrayEquals(bytes1, bytes2); // Bytes should be equal when seed is equal\n    assertFalse(Arrays.equals(bytes1, new byte[arraySize])); // The zero-array is very unlikely\n    drbg1.nextBytes(bytes1);\n    assertFalse(Arrays.equals(bytes1, bytes2)); // Each call gives new bytes\n    drbg2.nextBytes(bytes2);\n    assertArrayEquals(bytes1, bytes2); // The arays should now be back in sync\n    assertFalse(Arrays.equals(bytes1, new byte[arraySize])); // Still the zero-array is unlikely\n  }", "signature": "void testNextBytesEqualSeed()", "full_signature": "@Test public void testNextBytesEqualSeed()", "class_method_signature": "TestAesCtrDrbg.testNextBytesEqualSeed()", "testcase": true, "constructor": false, "invocations": ["nextBytes", "nextBytes", "nextBytes", "assertArrayEquals", "assertFalse", "equals", "nextBytes", "assertFalse", "equals", "nextBytes", "assertArrayEquals", "assertFalse", "equals"]}, "focal_class": {"identifier": "AesCtrDrbg", "superclass": "", "interfaces": "implements Drbg", "fields": [{"original_string": "public static final int SEED_LENGTH = 32;", "modifier": "public static final", "type": "int", "declarator": "SEED_LENGTH = 32", "var_name": "SEED_LENGTH"}, {"original_string": "private static final int IV_LENGTH = 16;", "modifier": "private static final", "type": "int", "declarator": "IV_LENGTH = 16", "var_name": "IV_LENGTH"}, {"original_string": "private static final int KEY_LENGTH = 16;", "modifier": "private static final", "type": "int", "declarator": "KEY_LENGTH = 16", "var_name": "KEY_LENGTH"}, {"original_string": "private static final long RESEED_LIMIT = 1L << 48;", "modifier": "private static final", "type": "long", "declarator": "RESEED_LIMIT = 1L << 48", "var_name": "RESEED_LIMIT"}, {"original_string": "private static final int UPDATE_LIMIT = 1 << 16;", "modifier": "private static final", "type": "int", "declarator": "UPDATE_LIMIT = 1 << 16", "var_name": "UPDATE_LIMIT"}, {"original_string": "private Cipher cipher;", "modifier": "private", "type": "Cipher", "declarator": "cipher", "var_name": "cipher"}, {"original_string": "private int generatedBytes;", "modifier": "private", "type": "int", "declarator": "generatedBytes", "var_name": "generatedBytes"}, {"original_string": "private int reseedCounter;", "modifier": "private", "type": "int", "declarator": "reseedCounter", "var_name": "reseedCounter"}], "methods": [{"identifier": "AesCtrDrbg", "parameters": "()", "modifiers": "public", "return": "", "signature": " AesCtrDrbg()", "full_signature": "public  AesCtrDrbg()", "class_method_signature": "AesCtrDrbg.AesCtrDrbg()", "testcase": false, "constructor": true}, {"identifier": "AesCtrDrbg", "parameters": "(byte[] seed)", "modifiers": "public", "return": "", "signature": " AesCtrDrbg(byte[] seed)", "full_signature": "public  AesCtrDrbg(byte[] seed)", "class_method_signature": "AesCtrDrbg.AesCtrDrbg(byte[] seed)", "testcase": false, "constructor": true}, {"identifier": "nextBytes", "parameters": "(byte[] bytes)", "modifiers": "@Override public", "return": "void", "signature": "void nextBytes(byte[] bytes)", "full_signature": "@Override public void nextBytes(byte[] bytes)", "class_method_signature": "AesCtrDrbg.nextBytes(byte[] bytes)", "testcase": false, "constructor": false}, {"identifier": "nextBytesBounded", "parameters": "(byte[] zeroes, byte[] output)", "modifiers": "", "return": "void", "signature": "void nextBytesBounded(byte[] zeroes, byte[] output)", "full_signature": " void nextBytesBounded(byte[] zeroes, byte[] output)", "class_method_signature": "AesCtrDrbg.nextBytesBounded(byte[] zeroes, byte[] output)", "testcase": false, "constructor": false}, {"identifier": "initCipher", "parameters": "(byte[] key, byte[] iv)", "modifiers": "", "return": "void", "signature": "void initCipher(byte[] key, byte[] iv)", "full_signature": " void initCipher(byte[] key, byte[] iv)", "class_method_signature": "AesCtrDrbg.initCipher(byte[] key, byte[] iv)", "testcase": false, "constructor": false}, {"identifier": "incrementReseedCounter", "parameters": "(long increment)", "modifiers": "", "return": "void", "signature": "void incrementReseedCounter(long increment)", "full_signature": " void incrementReseedCounter(long increment)", "class_method_signature": "AesCtrDrbg.incrementReseedCounter(long increment)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void update()", "full_signature": "private void update()", "class_method_signature": "AesCtrDrbg.update()", "testcase": false, "constructor": false}, {"identifier": "generateSeed", "parameters": "()", "modifiers": "private static", "return": "byte[]", "signature": "byte[] generateSeed()", "full_signature": "private static byte[] generateSeed()", "class_method_signature": "AesCtrDrbg.generateSeed()", "testcase": false, "constructor": false}], "file": "core/src/main/java/dk/alexandra/fresco/framework/util/AesCtrDrbg.java"}, "focal_method": {"identifier": "nextBytes", "parameters": "(byte[] bytes)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void nextBytes(byte[] bytes) {\n    if (bytes.length <= UPDATE_LIMIT) {\n      nextBytesBounded(new byte[bytes.length], bytes);\n    } else {\n      int offset = 0;\n      byte[] temp = new byte[UPDATE_LIMIT];\n      byte[] zeroes = new byte[temp.length];\n      while (bytes.length - offset > UPDATE_LIMIT) {\n        nextBytesBounded(zeroes, temp);\n        System.arraycopy(temp, 0, bytes, offset, temp.length);\n        offset += UPDATE_LIMIT;\n      }\n      temp = new byte[bytes.length - offset];\n      zeroes = new byte[bytes.length - offset];\n      nextBytesBounded(zeroes, temp);\n      System.arraycopy(temp, 0, bytes, offset, temp.length);\n    }\n  }", "signature": "void nextBytes(byte[] bytes)", "full_signature": "@Override public void nextBytes(byte[] bytes)", "class_method_signature": "AesCtrDrbg.nextBytes(byte[] bytes)", "testcase": false, "constructor": false, "invocations": ["nextBytesBounded", "nextBytesBounded", "arraycopy", "nextBytesBounded", "arraycopy"]}, "repository": {"repo_id": 46789213, "url": "https://github.com/aicis/fresco", "language": "Java", "is_fork": false, "fork_count": 35, "stargazer_count": 72, "size": 17923, "license": "licensed"}}