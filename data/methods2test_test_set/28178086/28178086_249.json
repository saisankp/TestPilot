{"test_class": {"identifier": "WienerKolmogorovEstimatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double EPS = 1e-5;", "modifier": "private static final", "type": "double", "declarator": "EPS = 1e-5", "var_name": "EPS"}], "file": "jtstoolkit/src/test/java/ec/satoolkit/seats/WienerKolmogorovEstimatorTest.java"}, "test_case": {"identifier": "testAirline", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testAirline() {\n        DefaultModelDecomposer decomposer = new DefaultModelDecomposer(false);\n        DescriptiveStatistics tstats = new DescriptiveStatistics(Data.X);\n        double range = tstats.getMax() - tstats.getMin();\n        for (int i = 1; i <= 19; i+=2) {\n            for (int j = 1; j <= 19; j+=2) {\n                SarimaModel arima = new SarimaModelBuilder().createAirlineModel(12, i * .1 - 1, j * .1 - 1);\n                SeatsModel seats = new SeatsModel(Data.X, arima, false);\n                UcarimaModel ucm = decomposer.decompose(seats, null, null);\n                //System.out.println(arima);\n                if (ucm != null) {\n                    WienerKolmogorovEstimator wk = new WienerKolmogorovEstimator(-1);\n                    DefaultSeriesDecomposition sa1 = wk.decompose(seats, ucm, null, null);\n                    KalmanEstimator kl = new KalmanEstimator(-1);\n                    DefaultSeriesDecomposition sa2 = kl.decompose(seats, ucm, null, null);\n                    TsData t1 = sa1.getSeries(ComponentType.Trend, ComponentInformation.Value);\n                    TsData t2 = sa2.getSeries(ComponentType.Trend, ComponentInformation.Value);\n                    double d = t1.distance(t2) / range;\n//                    System.out.println(d);\n//                    System.out.print(i);\n//                    System.out.print('\\t');\n//                    System.out.print(j);\n//                    System.out.print('\\t');\n//                    System.out.print(d);\n                    assertTrue(d < EPS);\n                    t1 = sa1.getSeries(ComponentType.Seasonal, ComponentInformation.Value);\n                    t2 = sa2.getSeries(ComponentType.Seasonal, ComponentInformation.Value);\n                    d = t1.distance(t2) / range;\n                    //                   System.out.println(d);\n//                    System.out.print('\\t');\n//                    System.out.print(d);\n                    assertTrue(d < EPS);\n                    seats.setMeanCorrection(true);\n                    sa1 = wk.decompose(seats, ucm, null, null);\n                    sa2 = kl.decompose(seats, ucm, null, null);\n                    t1 = sa1.getSeries(ComponentType.Trend, ComponentInformation.Value);\n                    t2 = sa2.getSeries(ComponentType.Trend, ComponentInformation.Value);\n                    d = t1.distance(t2) / range;\n                    //                   System.out.println(d);\n//                    System.out.print('\\t');\n//                    System.out.print(d);\n                    assertTrue(d < EPS);\n                    t1 = sa1.getSeries(ComponentType.Seasonal, ComponentInformation.Value);\n                    t2 = sa2.getSeries(ComponentType.Seasonal, ComponentInformation.Value);\n                    d = t1.distance(t2) / range;\n                    //                  System.out.println(d);\n//                    System.out.print('\\t');\n//                    System.out.println(d);\n                    assertTrue(d < EPS);\n                }\n            }\n        }\n    }", "signature": "void testAirline()", "full_signature": "@Test public void testAirline()", "class_method_signature": "WienerKolmogorovEstimatorTest.testAirline()", "testcase": true, "constructor": false, "invocations": ["getMax", "getMin", "createAirlineModel", "decompose", "decompose", "decompose", "getSeries", "getSeries", "distance", "assertTrue", "getSeries", "getSeries", "distance", "assertTrue", "setMeanCorrection", "decompose", "decompose", "getSeries", "getSeries", "distance", "assertTrue", "getSeries", "getSeries", "distance", "assertTrue"]}, "focal_class": {"identifier": "WienerKolmogorovEstimator", "superclass": "", "interfaces": "implements IComponentsEstimator", "fields": [{"original_string": "private final int npred;", "modifier": "private final", "type": "int", "declarator": "npred", "var_name": "npred"}], "methods": [{"identifier": "nf", "parameters": "(TsFrequency freq)", "modifiers": "private", "return": "int", "signature": "int nf(TsFrequency freq)", "full_signature": "private int nf(TsFrequency freq)", "class_method_signature": "WienerKolmogorovEstimator.nf(TsFrequency freq)", "testcase": false, "constructor": false}, {"identifier": "WienerKolmogorovEstimator", "parameters": "(int npred)", "modifiers": "public", "return": "", "signature": " WienerKolmogorovEstimator(int npred)", "full_signature": "public  WienerKolmogorovEstimator(int npred)", "class_method_signature": "WienerKolmogorovEstimator.WienerKolmogorovEstimator(int npred)", "testcase": false, "constructor": true}, {"identifier": "decompose", "parameters": "(SeatsModel model, UcarimaModel ucm,\n            InformationSet info, SeatsContext context)", "modifiers": "@Override public", "return": "DefaultSeriesDecomposition", "signature": "DefaultSeriesDecomposition decompose(SeatsModel model, UcarimaModel ucm,\n            InformationSet info, SeatsContext context)", "full_signature": "@Override public DefaultSeriesDecomposition decompose(SeatsModel model, UcarimaModel ucm,\n            InformationSet info, SeatsContext context)", "class_method_signature": "WienerKolmogorovEstimator.decompose(SeatsModel model, UcarimaModel ucm,\n            InformationSet info, SeatsContext context)", "testcase": false, "constructor": false}, {"identifier": "checkModel", "parameters": "(UcarimaModel ucm)", "modifiers": "private", "return": "UcarimaModel", "signature": "UcarimaModel checkModel(UcarimaModel ucm)", "full_signature": "private UcarimaModel checkModel(UcarimaModel ucm)", "class_method_signature": "WienerKolmogorovEstimator.checkModel(UcarimaModel ucm)", "testcase": false, "constructor": false}], "file": "jtstoolkit/src/main/java/ec/satoolkit/seats/WienerKolmogorovEstimator.java"}, "focal_method": {"identifier": "decompose", "parameters": "(SeatsModel model, UcarimaModel ucm,\n            InformationSet info, SeatsContext context)", "modifiers": "@Override public", "return": "DefaultSeriesDecomposition", "body": "@Override\n    public DefaultSeriesDecomposition decompose(SeatsModel model, UcarimaModel ucm,\n            InformationSet info, SeatsContext context) {\n        DefaultSeriesDecomposition decomposition = new DefaultSeriesDecomposition(\n                DecompositionMode.Additive);\n        BurmanEstimatesC burman = new BurmanEstimatesC();\n//\tBurmanEstimates burman = new BurmanEstimates();\n        UcarimaModel ucmc = ucm.clone();\n        ucmc.compact(2, 2);\n\n        TsData s = model.getSeries();\n        int nf = nf(s.getFrequency());\n        TsDomain fdomain = new TsDomain(s.getEnd(), nf);\n        burman.setForecastsCount(nf);\n\n        // check the ucarima model. \n        // ucm=checkModel(ucm);\n        if (model.isMeanCorrection()) {\n            burman.setUcarimaModelWithMean(ucmc);\n        } else {\n            burman.setUcarimaModel(ucmc);\n        }\n        burman.setData(s);\n        burman.setSer(model.getSer());\n        int ncmps = ucmc.getComponentsCount();\n\n        TsData[] cmps = new TsData[ncmps];\n        TsData[] fcmps = new TsData[ncmps];\n        TsData[] ecmps = new TsData[ncmps];\n        TsData[] efcmps = new TsData[ncmps];\n\n        for (int i = 0; i < ncmps; ++i) {\n            if (i == 0 || !ucmc.getComponent(i).isNull()) {\n                double[] tmp = burman.estimates(i, true);\n                cmps[i] = new TsData(s.getStart(), tmp, false);\n                ecmps[i] = new TsData(s.getStart(), burman.stdevEstimates(i), false);\n                tmp = burman.forecasts(i, true);\n                if (tmp != null) {\n                    fcmps[i] = new TsData(s.getEnd(), tmp, false);\n                }\n                tmp = burman.stdevForecasts(i, true);\n                if (tmp != null) {\n                    efcmps[i] = new TsData(s.getEnd(), tmp, false);\n                }\n            }\n        }\n\n        TsData fs = new TsData(s.getEnd(), burman.getSeriesForecasts(), false);\n        TsData efs = null, efsa = null;\n        for (int i = 0; i < efcmps.length; ++i) {\n            if (efcmps[i] != null) {\n                TsData var = efcmps[i].times(efcmps[i]);\n                efs = TsData.add(efs, var);\n                if (i != 1) {\n                    efsa = TsData.add(efsa, var);\n                }\n\n            }\n        }\n\n        decomposition.add(s, ComponentType.Series);\n        decomposition.add(fs.fittoDomain(fdomain), ComponentType.Series, ComponentInformation.Forecast);\n        if (efs != null) {\n            decomposition.add(efs.fittoDomain(fdomain).sqrt(), ComponentType.Series, ComponentInformation.StdevForecast);\n        }\n        if (cmps[0] != null) {\n            decomposition.add(cmps[0], ComponentType.Trend);\n        }\n        if (cmps[1] != null) {\n            decomposition.add(cmps[1], ComponentType.Seasonal);\n        }\n\n        if (fcmps[0] != null) {\n            decomposition.add(fcmps[0].fittoDomain(fdomain), ComponentType.Trend, ComponentInformation.Forecast);\n        }\n        if (fcmps[1] != null) {\n            decomposition.add(fcmps[1].fittoDomain(fdomain), ComponentType.Seasonal, ComponentInformation.Forecast);\n        }\n        decomposition.add(TsData.subtract(fs, fcmps[1]),\n                ComponentType.SeasonallyAdjusted, ComponentInformation.Forecast);\n        if (ecmps[0] != null) {\n            decomposition.add(ecmps[0], ComponentType.Trend, ComponentInformation.Stdev);\n        }\n        if (efcmps[0] != null) {\n            decomposition.add(efcmps[0], ComponentType.Trend, ComponentInformation.StdevForecast);\n        }\n        decomposition.add(TsData.subtract(s, cmps[1]),\n                ComponentType.SeasonallyAdjusted);\n        if (ecmps[1] != null) {\n            decomposition.add(ecmps[1], ComponentType.Seasonal, ComponentInformation.Stdev);\n            decomposition.add(ecmps[1], ComponentType.SeasonallyAdjusted, ComponentInformation.Stdev);\n            decomposition.add(efsa.sqrt(), ComponentType.SeasonallyAdjusted, ComponentInformation.StdevForecast);\n        }\n        if (efcmps[1] != null) {\n            decomposition.add(efcmps[1], ComponentType.Seasonal, ComponentInformation.StdevForecast);\n        }\n        decomposition.add(cmps[2], ComponentType.Irregular);\n        if (fcmps[2] != null) {\n            decomposition.add(fcmps[2], ComponentType.Irregular, ComponentInformation.Forecast);\n        }\n        if (ecmps[2] != null) {\n            decomposition.add(ecmps[2], ComponentType.Irregular, ComponentInformation.Stdev);\n        }\n        if (efcmps[2] != null) {\n            decomposition.add(efcmps[2], ComponentType.Irregular, ComponentInformation.StdevForecast);\n        }\n\n        return decomposition;\n    }", "signature": "DefaultSeriesDecomposition decompose(SeatsModel model, UcarimaModel ucm,\n            InformationSet info, SeatsContext context)", "full_signature": "@Override public DefaultSeriesDecomposition decompose(SeatsModel model, UcarimaModel ucm,\n            InformationSet info, SeatsContext context)", "class_method_signature": "WienerKolmogorovEstimator.decompose(SeatsModel model, UcarimaModel ucm,\n            InformationSet info, SeatsContext context)", "testcase": false, "constructor": false, "invocations": ["clone", "compact", "getSeries", "nf", "getFrequency", "getEnd", "setForecastsCount", "isMeanCorrection", "setUcarimaModelWithMean", "setUcarimaModel", "setData", "setSer", "getSer", "getComponentsCount", "isNull", "getComponent", "estimates", "getStart", "getStart", "stdevEstimates", "forecasts", "getEnd", "stdevForecasts", "getEnd", "getEnd", "getSeriesForecasts", "times", "add", "add", "add", "add", "fittoDomain", "add", "sqrt", "fittoDomain", "add", "add", "add", "fittoDomain", "add", "fittoDomain", "add", "subtract", "add", "add", "add", "subtract", "add", "add", "add", "sqrt", "add", "add", "add", "add", "add"]}, "repository": {"repo_id": 28178086, "url": "https://github.com/jdemetra/jdemetra-core", "stars": 24, "created": "12/18/2014 10:00:58 AM +00:00", "updates": "2020-01-17T15:50:24+00:00", "fork": "False", "license": "licensed"}}