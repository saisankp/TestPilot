{"test_class": {"identifier": "TestBootstrapSCNProcessor", "superclass": "", "interfaces": "", "fields": [], "file": "databus-bootstrap-server/databus-bootstrap-server-impl/src/test/java/com/linkedin/databus/bootstrap/server/TestBootstrapSCNProcessor.java"}, "test_case": {"identifier": "testShouldBypassSnapshot", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testShouldBypassSnapshot()\n  throws SQLException, BootstrapProcessingException, NoSuchFieldException, IllegalAccessException,\n         NoSuchMethodException\n  {\n    BootstrapSCNProcessor bsp = new BootstrapSCNProcessor();\n\n    Long defaultRowsThresholdForSnapshotBypass = Long.MAX_VALUE;\n    Map<String, Long> rowsThresholdForSnapshotBypass = new HashMap<String, Long>();\n    Map<String, Boolean> disableSnapshotBypass = new HashMap<String, Boolean>();\n    boolean predicatePushDown = false;\n    Map<String, Boolean> predicatePushDownBypass = new HashMap<String, Boolean>();\n    int queryTimeoutInSec = 10;\n    BootstrapReadOnlyConfig db = null;\n    boolean enableMinScnCheck=false;\n    final long longestDbTxnTimeMins = 240L;\n\n    BootstrapServerStaticConfig bssc = new BootstrapServerStaticConfig(defaultRowsThresholdForSnapshotBypass,\n                                                                       rowsThresholdForSnapshotBypass,\n                                                                       disableSnapshotBypass,\n                                                                       predicatePushDown,\n                                                                       predicatePushDownBypass,\n                                                                       queryTimeoutInSec,\n                                                                       enableMinScnCheck,\n                                                                       db,\n                                                                       longestDbTxnTimeMins);\n\n    Field field = bsp.getClass().getDeclaredField(\"_config\");\n    field.setAccessible(true);\n    field.set(bsp, bssc);\n    int srcId = 101;\n    long sinceScn = 5;\n    long startScn = 10;\n\n    BootstrapDBMetaDataDAO bmdd = EasyMock.createMock(BootstrapDBMetaDataDAO.class);\n    EasyMock.expect(bmdd.getLogIdToCatchup(srcId, startScn)).andReturn(0).anyTimes();\n    EasyMock.expect(bmdd.getLogIdToCatchup(srcId, sinceScn)).andReturn(0).anyTimes();\n    EasyMock.replay(bmdd);\n\n    Field dbDaoField = bsp.getClass().getDeclaredField(\"_dbDao\");\n    dbDaoField.setAccessible(true);\n    dbDaoField.set(bsp, bmdd);\n\n    List<SourceStatusInfo> srcList = new ArrayList<SourceStatusInfo>();\n    String name = \"foo\";\n    SourceStatusInfo ssi = new SourceStatusInfo(name, srcId, 4);\n    srcList.add(ssi);\n\n    // case 1. Single source, defaultRowsThresholdForSnapshotBypass set to Long.MAX_VALUE,\n    // individual overrides not set\n    boolean sbs = bsp.shouldBypassSnapshot(sinceScn, startScn, srcList);\n    Assert.assertEquals(true, sbs);\n\n    // case 2. Single source, defaultRowsThresholdForSnapshotBypass set to finite value,\n    // individual overrides set for the source\n    rowsThresholdForSnapshotBypass.put(name, Long.MAX_VALUE);\n    BootstrapServerStaticConfig bssc2 = new BootstrapServerStaticConfig(defaultRowsThresholdForSnapshotBypass,\n                                                                        rowsThresholdForSnapshotBypass,\n                                                                        disableSnapshotBypass,\n                                                                        predicatePushDown,\n                                                                        predicatePushDownBypass,\n                                                                        queryTimeoutInSec,\n                                                                        enableMinScnCheck,\n                                                                        db,\n                                                                        longestDbTxnTimeMins);\n    field.set(bsp, bssc2);\n    sbs = bsp.shouldBypassSnapshot(sinceScn, startScn, srcList);\n    Assert.assertEquals(true, sbs);\n\n    // Case 3:  Detect case when the log is not available on log tables ( so it should NOT bypass snapshot )\n    BootstrapDBMetaDataDAO bmdd2 = EasyMock.createMock(BootstrapDBMetaDataDAO.class);\n    EasyMock.expect(bmdd2.getLogIdToCatchup(srcId, startScn)).andReturn(2).anyTimes();\n    EasyMock.expect(bmdd2.getLogIdToCatchup(srcId, sinceScn)).andThrow(new BootstrapProcessingException(\"\"));\n    EasyMock.replay(bmdd2);\n\n    Field dbDaoField2 = bsp.getClass().getDeclaredField(\"_dbDao\");\n    dbDaoField2.setAccessible(true);\n    dbDaoField2.set(bsp, bmdd2);\n    sbs = bsp.shouldBypassSnapshot(sinceScn, startScn, srcList);\n    Assert.assertEquals(false, sbs);\n  }", "signature": "void testShouldBypassSnapshot()", "full_signature": "@Test public void testShouldBypassSnapshot()", "class_method_signature": "TestBootstrapSCNProcessor.testShouldBypassSnapshot()", "testcase": true, "constructor": false, "invocations": ["getDeclaredField", "getClass", "setAccessible", "set", "createMock", "anyTimes", "andReturn", "expect", "getLogIdToCatchup", "anyTimes", "andReturn", "expect", "getLogIdToCatchup", "replay", "getDeclaredField", "getClass", "setAccessible", "set", "add", "shouldBypassSnapshot", "assertEquals", "put", "set", "shouldBypassSnapshot", "assertEquals", "createMock", "anyTimes", "andReturn", "expect", "getLogIdToCatchup", "andThrow", "expect", "getLogIdToCatchup", "replay", "getDeclaredField", "getClass", "setAccessible", "set", "shouldBypassSnapshot", "assertEquals"]}, "focal_class": {"identifier": "BootstrapSCNProcessor", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String            MODULE               = BootstrapSCNProcessor.class.getName();", "modifier": "public static final", "type": "String", "declarator": "MODULE               = BootstrapSCNProcessor.class.getName()", "var_name": "MODULE"}, {"original_string": "public static final Logger            LOG                  = Logger.getLogger(MODULE);", "modifier": "public static final", "type": "Logger", "declarator": "LOG                  = Logger.getLogger(MODULE)", "var_name": "LOG"}, {"original_string": "public final static long START_SCN_QUERY_WAIT_TIME = 60000;", "modifier": "public final static", "type": "long", "declarator": "START_SCN_QUERY_WAIT_TIME = 60000", "var_name": "START_SCN_QUERY_WAIT_TIME"}, {"original_string": "public final static long QUERY_WAIT_TIME_SLICE = 100;", "modifier": "public final static", "type": "long", "declarator": "QUERY_WAIT_TIME_SLICE = 100", "var_name": "QUERY_WAIT_TIME_SLICE"}, {"original_string": "private BootstrapDBMetaDataDAO                 _dbDao;", "modifier": "private", "type": "BootstrapDBMetaDataDAO", "declarator": "_dbDao", "var_name": "_dbDao"}, {"original_string": "private BootstrapServerStaticConfig   _config;", "modifier": "private", "type": "BootstrapServerStaticConfig", "declarator": "_config", "var_name": "_config"}, {"original_string": "public final static String START_SCN_STMT_SQL_PREFIX\n\t  \t\t\t\t\t\t= \"SELECT min(windowscn) from bootstrap_applier_state where srcid IN (\";", "modifier": "public final static", "type": "String", "declarator": "START_SCN_STMT_SQL_PREFIX\n\t  \t\t\t\t\t\t= \"SELECT min(windowscn) from bootstrap_applier_state where srcid IN (\"", "var_name": "START_SCN_STMT_SQL_PREFIX"}, {"original_string": "public final static String START_SCN_STMT_SQL_SUFFIX = \")\";", "modifier": "public final static", "type": "String", "declarator": "START_SCN_STMT_SQL_SUFFIX = \")\"", "var_name": "START_SCN_STMT_SQL_SUFFIX"}, {"original_string": "public final static String PRODUCER_SCN_STMT_SQL_PREFIX\n\t  \t\t\t\t\t\t= \"SELECT max(windowscn) from bootstrap_producer_state where srcid IN (\";", "modifier": "public final static", "type": "String", "declarator": "PRODUCER_SCN_STMT_SQL_PREFIX\n\t  \t\t\t\t\t\t= \"SELECT max(windowscn) from bootstrap_producer_state where srcid IN (\"", "var_name": "PRODUCER_SCN_STMT_SQL_PREFIX"}, {"original_string": "public final static String PRODUCER_SCN_STMT_SQL_SUFFIX = \")\";", "modifier": "public final static", "type": "String", "declarator": "PRODUCER_SCN_STMT_SQL_SUFFIX = \")\"", "var_name": "PRODUCER_SCN_STMT_SQL_SUFFIX"}], "methods": [{"identifier": "BootstrapSCNProcessor", "parameters": "(BootstrapServerStaticConfig config,\n              DbusEventsStatisticsCollector curStatsCollector)", "modifiers": "public", "return": "", "signature": " BootstrapSCNProcessor(BootstrapServerStaticConfig config,\n              DbusEventsStatisticsCollector curStatsCollector)", "full_signature": "public  BootstrapSCNProcessor(BootstrapServerStaticConfig config,\n              DbusEventsStatisticsCollector curStatsCollector)", "class_method_signature": "BootstrapSCNProcessor.BootstrapSCNProcessor(BootstrapServerStaticConfig config,\n              DbusEventsStatisticsCollector curStatsCollector)", "testcase": false, "constructor": true}, {"identifier": "BootstrapSCNProcessor", "parameters": "()", "modifiers": "protected", "return": "", "signature": " BootstrapSCNProcessor()", "full_signature": "protected  BootstrapSCNProcessor()", "class_method_signature": "BootstrapSCNProcessor.BootstrapSCNProcessor()", "testcase": false, "constructor": true}, {"identifier": "shouldBypassSnapshot", "parameters": "(long sinceScn, long startScn, List<SourceStatusInfo> srcList)", "modifiers": "public", "return": "boolean", "signature": "boolean shouldBypassSnapshot(long sinceScn, long startScn, List<SourceStatusInfo> srcList)", "full_signature": "public boolean shouldBypassSnapshot(long sinceScn, long startScn, List<SourceStatusInfo> srcList)", "class_method_signature": "BootstrapSCNProcessor.shouldBypassSnapshot(long sinceScn, long startScn, List<SourceStatusInfo> srcList)", "testcase": false, "constructor": false}, {"identifier": "validateIfCanCatchupFromLog", "parameters": "(long sinceScn, long startScn, int srcid)", "modifiers": "protected", "return": "boolean", "signature": "boolean validateIfCanCatchupFromLog(long sinceScn, long startScn, int srcid)", "full_signature": "protected boolean validateIfCanCatchupFromLog(long sinceScn, long startScn, int srcid)", "class_method_signature": "BootstrapSCNProcessor.validateIfCanCatchupFromLog(long sinceScn, long startScn, int srcid)", "testcase": false, "constructor": false}, {"identifier": "getRowDiff", "parameters": "(long sinceScn, long startScn, int srcid)", "modifiers": "private", "return": "long", "signature": "long getRowDiff(long sinceScn, long startScn, int srcid)", "full_signature": "private long getRowDiff(long sinceScn, long startScn, int srcid)", "class_method_signature": "BootstrapSCNProcessor.getRowDiff(long sinceScn, long startScn, int srcid)", "testcase": false, "constructor": false}, {"identifier": "getMinApplierWindowScn", "parameters": "(long sinceScn, List<SourceStatusInfo> sourceList)", "modifiers": "public", "return": "long", "signature": "long getMinApplierWindowScn(long sinceScn, List<SourceStatusInfo> sourceList)", "full_signature": "public long getMinApplierWindowScn(long sinceScn, List<SourceStatusInfo> sourceList)", "class_method_signature": "BootstrapSCNProcessor.getMinApplierWindowScn(long sinceScn, List<SourceStatusInfo> sourceList)", "testcase": false, "constructor": false}, {"identifier": "getSourceTargetScn", "parameters": "(int srcId)", "modifiers": "public", "return": "long", "signature": "long getSourceTargetScn(int srcId)", "full_signature": "public long getSourceTargetScn(int srcId)", "class_method_signature": "BootstrapSCNProcessor.getSourceTargetScn(int srcId)", "testcase": false, "constructor": false}, {"identifier": "getTargetScnStmt", "parameters": "()", "modifiers": "private", "return": "PreparedStatement", "signature": "PreparedStatement getTargetScnStmt()", "full_signature": "private PreparedStatement getTargetScnStmt()", "class_method_signature": "BootstrapSCNProcessor.getTargetScnStmt()", "testcase": false, "constructor": false}, {"identifier": "getBootstrapMetaDataDAO", "parameters": "()", "modifiers": "public", "return": "BootstrapDBMetaDataDAO", "signature": "BootstrapDBMetaDataDAO getBootstrapMetaDataDAO()", "full_signature": "public BootstrapDBMetaDataDAO getBootstrapMetaDataDAO()", "class_method_signature": "BootstrapSCNProcessor.getBootstrapMetaDataDAO()", "testcase": false, "constructor": false}, {"identifier": "getSourceIdAndStatusFromName", "parameters": "(List<String> sourceList)", "modifiers": "public", "return": "List<SourceStatusInfo>", "signature": "List<SourceStatusInfo> getSourceIdAndStatusFromName(List<String> sourceList)", "full_signature": "public List<SourceStatusInfo> getSourceIdAndStatusFromName(List<String> sourceList)", "class_method_signature": "BootstrapSCNProcessor.getSourceIdAndStatusFromName(List<String> sourceList)", "testcase": false, "constructor": false}, {"identifier": "getSrcIdStatusFromDB", "parameters": "(String source, boolean activeCheck)", "modifiers": "public", "return": "SourceStatusInfo", "signature": "SourceStatusInfo getSrcIdStatusFromDB(String source, boolean activeCheck)", "full_signature": "public SourceStatusInfo getSrcIdStatusFromDB(String source, boolean activeCheck)", "class_method_signature": "BootstrapSCNProcessor.getSrcIdStatusFromDB(String source, boolean activeCheck)", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "BootstrapSCNProcessor.shutdown()", "testcase": false, "constructor": false}], "file": "databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapSCNProcessor.java"}, "focal_method": {"identifier": "shouldBypassSnapshot", "parameters": "(long sinceScn, long startScn, List<SourceStatusInfo> srcList)", "modifiers": "public", "return": "boolean", "body": "public boolean shouldBypassSnapshot(long sinceScn, long startScn, List<SourceStatusInfo> srcList)\n    throws SQLException, BootstrapProcessingException\n    {\n      if ((srcList == null) || (srcList.isEmpty()))\n        return false;\n\n      if ( sinceScn <= 0 )\n      {\n        // client is requesting full bootstrap. Cannot guarantee with just log tables.\n        LOG.info(\"Client requesting from SCN (\" + sinceScn + \"). Bootstrap Snapshot will not be bypassed !!\");\n        return false;\n      }\n\n      for (SourceStatusInfo pair: srcList)\n      {\n        boolean disableSnapshotBypass = _config.isBypassSnapshotDisabled(pair.getSrcName());\n\n        if ( disableSnapshotBypass)\n          return false;\n\n        boolean canCatchupFromLog = validateIfCanCatchupFromLog(sinceScn, startScn, pair.getSrcId());\n        if (! canCatchupFromLog)\n          return false;\n\n\n        long threshold = _config.getRowsThresholdForSnapshotBypass(pair.getSrcName());\n\n        if ( threshold == Long.MAX_VALUE)\n        {\n          // If the threshold for snapshot bypass is infinity, then we should bypass snapshot\n          // for this source i.e., fetch from log table. Hence do not bother to get number of rows affected\n          // for this source, as it could potentially be an expensive query\n          continue;\n        }\n\n        long currRows = getRowDiff(sinceScn, startScn, pair.getSrcId());\n\n        if (currRows > threshold)\n        {\n          LOG.info(\"Threshold check failed for source (\" + pair.getSrcName() + \") Threshold:\" + threshold + \",Approx Rows:\" + currRows );\n          return false;\n        }\n      }\n\n      return true;\n}", "signature": "boolean shouldBypassSnapshot(long sinceScn, long startScn, List<SourceStatusInfo> srcList)", "full_signature": "public boolean shouldBypassSnapshot(long sinceScn, long startScn, List<SourceStatusInfo> srcList)", "class_method_signature": "BootstrapSCNProcessor.shouldBypassSnapshot(long sinceScn, long startScn, List<SourceStatusInfo> srcList)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "info", "isBypassSnapshotDisabled", "getSrcName", "validateIfCanCatchupFromLog", "getSrcId", "getRowsThresholdForSnapshotBypass", "getSrcName", "getRowDiff", "getSrcId", "info", "getSrcName"]}, "repository": {"repo_id": 7209229, "url": "https://github.com/linkedin/databus", "language": "Java", "is_fork": false, "fork_count": 653, "stargazer_count": 2899, "size": 51191, "license": "licensed"}}