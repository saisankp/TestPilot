{"test_class": {"identifier": "CoverageUtilitiesTest", "superclass": "extends Assert", "interfaces": "", "fields": [], "file": "modules/library/coverage/src/test/java/org/geotools/resources/coverage/CoverageUtilitiesTest.java"}, "test_case": {"identifier": "testNodata", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testNodata() {\n\n    \t// test coverage no data property\n    \tfinal HashMap properties= new HashMap();\n    \tproperties.put(\"GC_NODATA\", Double.valueOf(-9999.0));\n    \tfinal GridGeometry2D gg2D = new GridGeometry2D(\n    \t\t\tnew Rectangle(0,0,800,600),\n    \t\t\tnew Rectangle(-180,90,360,180));\n    \t\n    \tGridCoverage2D gc= CoverageFactoryFinder.getGridCoverageFactory(null).\n    \tcreate(\n    \t\t\t\"test\", \n    \t\t\tImageFunctionDescriptor.create(new MyImageFunction(), Integer.valueOf(800), Integer.valueOf(600), Float.valueOf(1.0f),  Float.valueOf(1.0f),  Float.valueOf(0.0f),  Float.valueOf(0.0f), null), \n    \t\t\tgg2D, \n    \t\t\tnull, \n    \t\t\tnull, \n    \t\t\tproperties);\n    \t\n    \tdouble[] bkg=CoverageUtilities.getBackgroundValues(gc);\n    \tassertEquals(1, bkg.length);\n    \tassertEquals(Double.valueOf(-9999.0), bkg[0]);\n    \t\n    \t// test grid sampledimension no data property\n    \tfinal Category noDataCategory= new Category(CoverageUtilities.NODATA,new Color[]{Color.black},NumberRange.create(Double.valueOf(-9999.0),Double.valueOf(-9999.0)),NumberRange.create(Double.valueOf(-9999.0),Double.valueOf(-9999.0)));\n    \tfinal GridSampleDimension gsd = new GridSampleDimension(\"test\", new Category[]{noDataCategory},Unit.ONE);\n    \tgc= CoverageFactoryFinder.getGridCoverageFactory(null).\n    \tcreate(\n    \t\t\t\"test\", \n    \t\t\tImageFunctionDescriptor.create(new MyImageFunction(), Integer.valueOf(800), Integer.valueOf(600), Float.valueOf(1.0f),  Float.valueOf(1.0f),  Float.valueOf(0.0f),  Float.valueOf(0.0f), null), \n    \t\t\tgg2D, \n    \t\t\tnew GridSampleDimension[]{gsd}, \n    \t\t\tnull, \n    \t\t\tnull);\n    \t\n    \tbkg=CoverageUtilities.getBackgroundValues(gc);\n    \tassertEquals(1, bkg.length);\n    \tassertEquals(Double.valueOf(-9999.0), bkg[0]);\n    \t\n    \t// test getting NaN in case we do not have any no data\n    \tgc= CoverageFactoryFinder.getGridCoverageFactory(null).\n    \tcreate(\n    \t\t\t\"test\", \n    \t\t\tImageFunctionDescriptor.create(new MyImageFunction(), Integer.valueOf(800), Integer.valueOf(600), Float.valueOf(1.0f),  Float.valueOf(1.0f),  Float.valueOf(0.0f),  Float.valueOf(0.0f), null), \n    \t\t\tgg2D, \n    \t\t\tnull, \n    \t\t\tnull, \n    \t\t\tnull);\n    \t\n    \tbkg=CoverageUtilities.getBackgroundValues(gc);\n    \tassertEquals(1, bkg.length);\n    \tassertTrue(Double.isNaN(bkg[0]));\n    \t\n    }", "signature": "void testNodata()", "full_signature": "@Test public void testNodata()", "class_method_signature": "CoverageUtilitiesTest.testNodata()", "testcase": true, "constructor": false, "invocations": ["put", "valueOf", "create", "getGridCoverageFactory", "create", "valueOf", "valueOf", "valueOf", "valueOf", "valueOf", "valueOf", "getBackgroundValues", "assertEquals", "assertEquals", "valueOf", "create", "valueOf", "valueOf", "create", "valueOf", "valueOf", "create", "getGridCoverageFactory", "create", "valueOf", "valueOf", "valueOf", "valueOf", "valueOf", "valueOf", "getBackgroundValues", "assertEquals", "assertEquals", "valueOf", "create", "getGridCoverageFactory", "create", "valueOf", "valueOf", "valueOf", "valueOf", "valueOf", "valueOf", "getBackgroundValues", "assertEquals", "assertTrue", "isNaN"]}, "focal_class": {"identifier": "CoverageUtilities", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final InternationalString NODATA=Vocabulary.formatInternational(VocabularyKeys.NODATA);", "modifier": "public static final", "type": "InternationalString", "declarator": "NODATA=Vocabulary.formatInternational(VocabularyKeys.NODATA)", "var_name": "NODATA"}, {"original_string": "public static final AffineTransform AXES_SWAP= new AffineTransform2D(0,1,1,0,0,0);", "modifier": "public static final", "type": "AffineTransform", "declarator": "AXES_SWAP= new AffineTransform2D(0,1,1,0,0,0)", "var_name": "AXES_SWAP"}, {"original_string": "public static final AffineTransform IDENTITY_TRANSFORM = new AffineTransform2D(AffineTransform.getRotateInstance(0));", "modifier": "public static final", "type": "AffineTransform", "declarator": "IDENTITY_TRANSFORM = new AffineTransform2D(AffineTransform.getRotateInstance(0))", "var_name": "IDENTITY_TRANSFORM"}, {"original_string": "public final static AffineTransform CENTER_TO_CORNER = AffineTransform\n    \t\t.getTranslateInstance(PixelTranslation\n    \t\t\t\t.getPixelTranslation(PixelInCell.CELL_CORNER),\n    \t\t\t\tPixelTranslation\n    \t\t\t\t\t\t.getPixelTranslation(PixelInCell.CELL_CORNER));", "modifier": "public final static", "type": "AffineTransform", "declarator": "CENTER_TO_CORNER = AffineTransform\n    \t\t.getTranslateInstance(PixelTranslation\n    \t\t\t\t.getPixelTranslation(PixelInCell.CELL_CORNER),\n    \t\t\t\tPixelTranslation\n    \t\t\t\t\t\t.getPixelTranslation(PixelInCell.CELL_CORNER))", "var_name": "CENTER_TO_CORNER"}, {"original_string": "public final static AffineTransform CORNER_TO_CENTER = AffineTransform\n    \t\t.getTranslateInstance(-PixelTranslation\n    \t\t\t\t.getPixelTranslation(PixelInCell.CELL_CORNER),\n    \t\t\t\t-PixelTranslation\n    \t\t\t\t\t\t.getPixelTranslation(PixelInCell.CELL_CORNER));", "modifier": "public final static", "type": "AffineTransform", "declarator": "CORNER_TO_CENTER = AffineTransform\n    \t\t.getTranslateInstance(-PixelTranslation\n    \t\t\t\t.getPixelTranslation(PixelInCell.CELL_CORNER),\n    \t\t\t\t-PixelTranslation\n    \t\t\t\t\t\t.getPixelTranslation(PixelInCell.CELL_CORNER))", "var_name": "CORNER_TO_CENTER"}], "methods": [{"identifier": "CoverageUtilities", "parameters": "()", "modifiers": "private", "return": "", "signature": " CoverageUtilities()", "full_signature": "private  CoverageUtilities()", "class_method_signature": "CoverageUtilities.CoverageUtilities()", "testcase": false, "constructor": true}, {"identifier": "getCRS2D", "parameters": "(final Coverage coverage)", "modifiers": "public static", "return": "CoordinateReferenceSystem", "signature": "CoordinateReferenceSystem getCRS2D(final Coverage coverage)", "full_signature": "public static CoordinateReferenceSystem getCRS2D(final Coverage coverage)", "class_method_signature": "CoverageUtilities.getCRS2D(final Coverage coverage)", "testcase": false, "constructor": false}, {"identifier": "getHorizontalCRS", "parameters": "(final Coverage coverage)", "modifiers": "public static", "return": "CoordinateReferenceSystem", "signature": "CoordinateReferenceSystem getHorizontalCRS(final Coverage coverage)", "full_signature": "public static CoordinateReferenceSystem getHorizontalCRS(final Coverage coverage)", "class_method_signature": "CoverageUtilities.getHorizontalCRS(final Coverage coverage)", "testcase": false, "constructor": false}, {"identifier": "getEnvelope2D", "parameters": "(final Coverage coverage)", "modifiers": "public static", "return": "Envelope2D", "signature": "Envelope2D getEnvelope2D(final Coverage coverage)", "full_signature": "public static Envelope2D getEnvelope2D(final Coverage coverage)", "class_method_signature": "CoverageUtilities.getEnvelope2D(final Coverage coverage)", "testcase": false, "constructor": false}, {"identifier": "getBackgroundValues", "parameters": "(GridCoverage2D coverage)", "modifiers": "public static", "return": "double[]", "signature": "double[] getBackgroundValues(GridCoverage2D coverage)", "full_signature": "public static double[] getBackgroundValues(GridCoverage2D coverage)", "class_method_signature": "CoverageUtilities.getBackgroundValues(GridCoverage2D coverage)", "testcase": false, "constructor": false}, {"identifier": "hasRenderingCategories", "parameters": "(final GridCoverage gridCoverage)", "modifiers": "public static", "return": "boolean", "signature": "boolean hasRenderingCategories(final GridCoverage gridCoverage)", "full_signature": "public static boolean hasRenderingCategories(final GridCoverage gridCoverage)", "class_method_signature": "CoverageUtilities.hasRenderingCategories(final GridCoverage gridCoverage)", "testcase": false, "constructor": false}, {"identifier": "hasTransform", "parameters": "(final SampleDimension[] sampleDimensions)", "modifiers": "public static", "return": "boolean", "signature": "boolean hasTransform(final SampleDimension[] sampleDimensions)", "full_signature": "public static boolean hasTransform(final SampleDimension[] sampleDimensions)", "class_method_signature": "CoverageUtilities.hasTransform(final SampleDimension[] sampleDimensions)", "testcase": false, "constructor": false}, {"identifier": "uses", "parameters": "(final GridCoverage coverage, final RenderedImage image)", "modifiers": "public static", "return": "boolean", "signature": "boolean uses(final GridCoverage coverage, final RenderedImage image)", "full_signature": "public static boolean uses(final GridCoverage coverage, final RenderedImage image)", "class_method_signature": "CoverageUtilities.uses(final GridCoverage coverage, final RenderedImage image)", "testcase": false, "constructor": false}, {"identifier": "getVisibleBand", "parameters": "(final Object image)", "modifiers": "public static", "return": "int", "signature": "int getVisibleBand(final Object image)", "full_signature": "public static int getVisibleBand(final Object image)", "class_method_signature": "CoverageUtilities.getVisibleBand(final Object image)", "testcase": false, "constructor": false}, {"identifier": "preferredViewForOperation", "parameters": "(final GridCoverage2D coverage,\n            final Interpolation interpolation, final boolean hasFilter, final RenderingHints hints)", "modifiers": "public static", "return": "ViewType", "signature": "ViewType preferredViewForOperation(final GridCoverage2D coverage,\n            final Interpolation interpolation, final boolean hasFilter, final RenderingHints hints)", "full_signature": "public static ViewType preferredViewForOperation(final GridCoverage2D coverage,\n            final Interpolation interpolation, final boolean hasFilter, final RenderingHints hints)", "class_method_signature": "CoverageUtilities.preferredViewForOperation(final GridCoverage2D coverage,\n            final Interpolation interpolation, final boolean hasFilter, final RenderingHints hints)", "testcase": false, "constructor": false}, {"identifier": "preferredViewAfterOperation", "parameters": "(final GridCoverage2D coverage)", "modifiers": "public static", "return": "ViewType", "signature": "ViewType preferredViewAfterOperation(final GridCoverage2D coverage)", "full_signature": "public static ViewType preferredViewAfterOperation(final GridCoverage2D coverage)", "class_method_signature": "CoverageUtilities.preferredViewAfterOperation(final GridCoverage2D coverage)", "testcase": false, "constructor": false}, {"identifier": "isScaleTranslate", "parameters": "(final MathTransform transform, final double EPS)", "modifiers": "public static", "return": "boolean", "signature": "boolean isScaleTranslate(final MathTransform transform, final double EPS)", "full_signature": "public static boolean isScaleTranslate(final MathTransform transform, final double EPS)", "class_method_signature": "CoverageUtilities.isScaleTranslate(final MathTransform transform, final double EPS)", "testcase": false, "constructor": false}, {"identifier": "getResolution", "parameters": "(final AffineTransform gridToCRS)", "modifiers": "public static", "return": "double[]", "signature": "double[] getResolution(final AffineTransform gridToCRS)", "full_signature": "public static double[] getResolution(final AffineTransform gridToCRS)", "class_method_signature": "CoverageUtilities.getResolution(final AffineTransform gridToCRS)", "testcase": false, "constructor": false}, {"identifier": "isSimpleGridToWorldTransform", "parameters": "(final AffineTransform gridToCRS, double EPS)", "modifiers": "public static", "return": "boolean", "signature": "boolean isSimpleGridToWorldTransform(final AffineTransform gridToCRS, double EPS)", "full_signature": "public static boolean isSimpleGridToWorldTransform(final AffineTransform gridToCRS, double EPS)", "class_method_signature": "CoverageUtilities.isSimpleGridToWorldTransform(final AffineTransform gridToCRS, double EPS)", "testcase": false, "constructor": false}, {"identifier": "checkEmptySourceRegion", "parameters": "(final ImageReadParam readParameters, \n            final Rectangle dimensions)", "modifiers": "public static", "return": "boolean", "signature": "boolean checkEmptySourceRegion(final ImageReadParam readParameters, \n            final Rectangle dimensions)", "full_signature": "public static boolean checkEmptySourceRegion(final ImageReadParam readParameters, \n            final Rectangle dimensions)", "class_method_signature": "CoverageUtilities.checkEmptySourceRegion(final ImageReadParam readParameters, \n            final Rectangle dimensions)", "testcase": false, "constructor": false}, {"identifier": "getMosaicThreshold", "parameters": "(int dataType)", "modifiers": "public static", "return": "double", "signature": "double getMosaicThreshold(int dataType)", "full_signature": "public static double getMosaicThreshold(int dataType)", "class_method_signature": "CoverageUtilities.getMosaicThreshold(int dataType)", "testcase": false, "constructor": false}, {"identifier": "suggestNoDataValue", "parameters": "(int dataType)", "modifiers": "public static", "return": "Number", "signature": "Number suggestNoDataValue(int dataType)", "full_signature": "public static Number suggestNoDataValue(int dataType)", "class_method_signature": "CoverageUtilities.suggestNoDataValue(int dataType)", "testcase": false, "constructor": false}], "file": "modules/library/coverage/src/main/java/org/geotools/resources/coverage/CoverageUtilities.java"}, "focal_method": {"identifier": "getBackgroundValues", "parameters": "(GridCoverage2D coverage)", "modifiers": "public static", "return": "double[]", "body": "public static double[] getBackgroundValues(GridCoverage2D coverage) {\n\t\t\n\t\t//minimal checks\n\t\tif(coverage==null){\n\t\t\tthrow new NullPointerException(Errors.format(ErrorKeys.NULL_PARAMETER_$2, \"coverage\",\"GridCoverage2D\"));\n\t\t}\n\t\t\n\t\t// try to get the GC_NODATA double value from the coverage property\n\t\tfinal Object noData=coverage.getProperty(\"GC_NODATA\");\n\t\tif(noData!=null&& noData instanceof Number){\n\t\t\treturn new double[]{((Double)noData).doubleValue()};\n\t\t}\n\t\t\n        ////\n\t\t//\n\t\t// Try to gather no data values from the sample dimensions\n\t\t// and, if not available, we try to suggest them from the sample\n\t\t// dimension type\n\t\t//\n\t\t////\n        final GridSampleDimension[] sampleDimensions = coverage.getSampleDimensions();\n        final double[] background = new double[sampleDimensions.length];\n        \n        boolean found=false;\n        final int dataType = coverage.getRenderedImage().getSampleModel().getDataType();\n        for (int i=0; i<background.length; i++) {\n        \t// try to use the no data category if preset\n        \tfinal List<Category> categories = sampleDimensions[i].getCategories();\n        \tif(categories!=null&&categories.size()>0){\n        \t\tfor(Category category:categories){\n        \t\t\tif(category.getName().equals(NODATA)){\n        \t\t\t\tbackground[i]=category.geophysics(true).getRange().getMinimum();\n        \t\t\t\tfound=true;\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t}\n        \t\n        \tif(!found){\n        \t\t// we don't have a proper no data value, let's try to suggest something \n        \t\t// meaningful fro mthe data type for this coverage\n            \tbackground[i]=suggestNoDataValue(dataType).doubleValue();\n        \t}\n        \t\n//          SG 25112012, removed this automagic behavior        \t\n//            final NumberRange<?> range = sampleDimensions[i].getBackground().getRange();\n//            final double min = range.getMinimum();\n//            final double max = range.getMaximum();\n//            if (range.isMinIncluded()) {\n//                background[i] = min;\n//            } else if (range.isMaxIncluded()) {\n//                background[i] = max;\n//            } else {\n//                background[i] = 0.5 * (min + max);\n//            }\n        }\n        return background;\n    }", "signature": "double[] getBackgroundValues(GridCoverage2D coverage)", "full_signature": "public static double[] getBackgroundValues(GridCoverage2D coverage)", "class_method_signature": "CoverageUtilities.getBackgroundValues(GridCoverage2D coverage)", "testcase": false, "constructor": false, "invocations": ["format", "getProperty", "doubleValue", "getSampleDimensions", "getDataType", "getSampleModel", "getRenderedImage", "getCategories", "size", "equals", "getName", "getMinimum", "getRange", "geophysics", "doubleValue", "suggestNoDataValue"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}