{"test_class": {"identifier": "InChINumbersToolsTest", "superclass": "extends CDKTestCase", "interfaces": "", "fields": [], "file": "storage/inchi/src/test/java/org/openscience/cdk/graph/invariant/InChINumbersToolsTest.java"}, "test_case": {"identifier": "parseFixedH", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void parseFixedH() throws Exception {\n        // N1C=NC=C1\n        assertThat(InChINumbersTools.parseUSmilesNumbers(\n                \"AuxInfo=1/1/N:4,5,2,3,1/E:(1,2)(4,5)/F:5,4,2,1,3/rA:5NCNCC/rB:s1;d2;s3;s1d4;/rC:;;;;;\", mock(5)),\n                is(new long[]{4, 3, 5, 2, 1}));\n    }", "signature": "void parseFixedH()", "full_signature": "@Test public void parseFixedH()", "class_method_signature": "InChINumbersToolsTest.parseFixedH()", "testcase": true, "constructor": false, "invocations": ["assertThat", "parseUSmilesNumbers", "mock", "is"]}, "focal_class": {"identifier": "InChINumbersTools", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "getNumbers", "parameters": "(IAtomContainer atomContainer)", "modifiers": "public static", "return": "long[]", "signature": "long[] getNumbers(IAtomContainer atomContainer)", "full_signature": "public static long[] getNumbers(IAtomContainer atomContainer)", "class_method_signature": "InChINumbersTools.getNumbers(IAtomContainer atomContainer)", "testcase": false, "constructor": false}, {"identifier": "parseAuxInfo", "parameters": "(String aux, long[] numbers)", "modifiers": "public static", "return": "void", "signature": "void parseAuxInfo(String aux, long[] numbers)", "full_signature": "public static void parseAuxInfo(String aux, long[] numbers)", "class_method_signature": "InChINumbersTools.parseAuxInfo(String aux, long[] numbers)", "testcase": false, "constructor": false}, {"identifier": "getUSmilesNumbers", "parameters": "(IAtomContainer container)", "modifiers": "public static", "return": "long[]", "signature": "long[] getUSmilesNumbers(IAtomContainer container)", "full_signature": "public static long[] getUSmilesNumbers(IAtomContainer container)", "class_method_signature": "InChINumbersTools.getUSmilesNumbers(IAtomContainer container)", "testcase": false, "constructor": false}, {"identifier": "parseUSmilesNumbers", "parameters": "(String aux, IAtomContainer container)", "modifiers": "static", "return": "long[]", "signature": "long[] parseUSmilesNumbers(String aux, IAtomContainer container)", "full_signature": "static long[] parseUSmilesNumbers(String aux, IAtomContainer container)", "class_method_signature": "InChINumbersTools.parseUSmilesNumbers(String aux, IAtomContainer container)", "testcase": false, "constructor": false}, {"identifier": "exch", "parameters": "(long[] values, int i, int j)", "modifiers": "private static", "return": "void", "signature": "void exch(long[] values, int i, int j)", "full_signature": "private static void exch(long[] values, int i, int j)", "class_method_signature": "InChINumbersTools.exch(long[] values, int i, int j)", "testcase": false, "constructor": false}, {"identifier": "findPiBondedOxygen", "parameters": "(IAtomContainer container, IAtom atom)", "modifiers": "private static", "return": "IAtom", "signature": "IAtom findPiBondedOxygen(IAtomContainer container, IAtom atom)", "full_signature": "private static IAtom findPiBondedOxygen(IAtomContainer container, IAtom atom)", "class_method_signature": "InChINumbersTools.findPiBondedOxygen(IAtomContainer container, IAtom atom)", "testcase": false, "constructor": false}, {"identifier": "auxInfo", "parameters": "(IAtomContainer container, INCHI_OPTION... options)", "modifiers": "static", "return": "String", "signature": "String auxInfo(IAtomContainer container, INCHI_OPTION... options)", "full_signature": "static String auxInfo(IAtomContainer container, INCHI_OPTION... options)", "class_method_signature": "InChINumbersTools.auxInfo(IAtomContainer container, INCHI_OPTION... options)", "testcase": false, "constructor": false}], "file": "storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java"}, "focal_method": {"identifier": "parseUSmilesNumbers", "parameters": "(String aux, IAtomContainer container)", "modifiers": "static", "return": "long[]", "body": "static long[] parseUSmilesNumbers(String aux, IAtomContainer container) {\n\n        int index;\n        long[] numbers = new long[container.getAtomCount()];\n        int[] first = null;\n        int label = 1;\n\n        if ((index = aux.indexOf(\"/R:\")) >= 0) { // reconnected metal numbers\n            int endIndex = aux.indexOf('/', index + 8);\n            if (endIndex<0)\n                endIndex = aux.length();\n            String[] baseNumbers = aux.substring(index + 8, endIndex).split(\";\");\n            first = new int[baseNumbers.length];\n            Arrays.fill(first, -1);\n            for (int i = 0; i < baseNumbers.length; i++) {\n                String[] numbering = baseNumbers[i].split(\",\");\n                first[i] = Integer.parseInt(numbering[0]) - 1;\n                for (String number : numbering) {\n                    numbers[Integer.parseInt(number) - 1] = label++;\n                }\n            }\n        } else if ((index = aux.indexOf(\"/N:\")) >= 0) { // standard numbers\n\n            // read the standard numbers first (need to reference back for some structures)\n            String[] baseNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split(\";\");\n            first = new int[baseNumbers.length];\n            Arrays.fill(first, -1);\n\n            if ((index = aux.indexOf(\"/F:\")) >= 0) {\n                String[] fixedHNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split(\";\");\n                for (int i = 0; i < fixedHNumbers.length; i++) {\n                    String component = fixedHNumbers[i];\n\n                    // m, 2m, 3m ... need to lookup number in the base numbering\n                    if (component.charAt(component.length() - 1) == 'm') {\n                        int n = component.length() > 1 ? Integer\n                                .parseInt(component.substring(0, component.length() - 1)) : 1;\n                        for (int j = 0; j < n; j++) {\n                            String[] numbering = baseNumbers[i + j].split(\",\");\n                            first[i + j] = Integer.parseInt(numbering[0]) - 1;\n                            for (String number : numbering)\n                                numbers[Integer.parseInt(number) - 1] = label++;\n                        }\n                    } else {\n                        String[] numbering = component.split(\",\");\n                        for (String number : numbering)\n                            numbers[Integer.parseInt(number)-1] = label++;\n                    }\n                }\n            } else {\n                for (int i = 0; i < baseNumbers.length; i++) {\n                    String[] numbering = baseNumbers[i].split(\",\");\n                    first[i] = Integer.parseInt(numbering[0]) - 1;\n                    for (String number : numbering)\n                        numbers[Integer.parseInt(number) - 1] = label++;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"AuxInfo did not contain extractable base numbers (/N: or /R:).\");\n        }\n\n        // Rule E: swap any oxygen anion for a double bonded oxygen (InChI sees\n        // them as equivalent)\n        for (int v : first) {\n            if (v >= 0) {\n                IAtom atom = container.getAtom(v);\n                if (atom.getFormalCharge() == null) continue;\n                if (atom.getAtomicNumber() == 8 && atom.getFormalCharge() == -1) {\n                    List<IAtom> neighbors = container.getConnectedAtomsList(atom);\n                    if (neighbors.size() == 1) {\n                        IAtom correctedStart = findPiBondedOxygen(container, neighbors.get(0));\n                        if (correctedStart != null) exch(numbers, v, container.indexOf(correctedStart));\n                    }\n                }\n            }\n        }\n\n        // assign unlabelled atoms\n        for (int i = 0; i < numbers.length; i++)\n            if (numbers[i] == 0) numbers[i] = label++;\n\n        return numbers;\n    }", "signature": "long[] parseUSmilesNumbers(String aux, IAtomContainer container)", "full_signature": "static long[] parseUSmilesNumbers(String aux, IAtomContainer container)", "class_method_signature": "InChINumbersTools.parseUSmilesNumbers(String aux, IAtomContainer container)", "testcase": false, "constructor": false, "invocations": ["getAtomCount", "indexOf", "indexOf", "length", "split", "substring", "fill", "split", "parseInt", "parseInt", "indexOf", "split", "substring", "indexOf", "fill", "indexOf", "split", "substring", "indexOf", "charAt", "length", "length", "parseInt", "substring", "length", "split", "parseInt", "parseInt", "split", "parseInt", "split", "parseInt", "parseInt", "getAtom", "getFormalCharge", "getAtomicNumber", "getFormalCharge", "getConnectedAtomsList", "size", "findPiBondedOxygen", "get", "exch", "indexOf"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}