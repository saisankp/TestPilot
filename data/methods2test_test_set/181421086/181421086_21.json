{"test_class": {"identifier": "LoadBalancerTest", "superclass": "extends FloodlightTestCase", "interfaces": "", "fields": [{"original_string": "protected LoadBalancer lb;", "modifier": "protected", "type": "LoadBalancer", "declarator": "lb", "var_name": "lb"}, {"original_string": "protected FloodlightContext cntx;", "modifier": "protected", "type": "FloodlightContext", "declarator": "cntx", "var_name": "cntx"}, {"original_string": "protected FloodlightModuleContext fmc;", "modifier": "protected", "type": "FloodlightModuleContext", "declarator": "fmc", "var_name": "fmc"}, {"original_string": "protected MockDeviceManager deviceManager;", "modifier": "protected", "type": "MockDeviceManager", "declarator": "deviceManager", "var_name": "deviceManager"}, {"original_string": "protected MockThreadPoolService tps;", "modifier": "protected", "type": "MockThreadPoolService", "declarator": "tps", "var_name": "tps"}, {"original_string": "protected DefaultEntityClassifier entityClassifier;", "modifier": "protected", "type": "DefaultEntityClassifier", "declarator": "entityClassifier", "var_name": "entityClassifier"}, {"original_string": "protected IRoutingService routingEngine;", "modifier": "protected", "type": "IRoutingService", "declarator": "routingEngine", "var_name": "routingEngine"}, {"original_string": "protected ITopologyService topology;", "modifier": "protected", "type": "ITopologyService", "declarator": "topology", "var_name": "topology"}, {"original_string": "protected StaticFlowEntryPusher sfp;", "modifier": "protected", "type": "StaticFlowEntryPusher", "declarator": "sfp", "var_name": "sfp"}, {"original_string": "protected MemoryStorageSource storage;", "modifier": "protected", "type": "MemoryStorageSource", "declarator": "storage", "var_name": "storage"}, {"original_string": "protected RestApiServer restApi;", "modifier": "protected", "type": "RestApiServer", "declarator": "restApi", "var_name": "restApi"}, {"original_string": "protected VipsResource vipsResource;", "modifier": "protected", "type": "VipsResource", "declarator": "vipsResource", "var_name": "vipsResource"}, {"original_string": "protected PoolsResource poolsResource;", "modifier": "protected", "type": "PoolsResource", "declarator": "poolsResource", "var_name": "poolsResource"}, {"original_string": "protected MembersResource membersResource;", "modifier": "protected", "type": "MembersResource", "declarator": "membersResource", "var_name": "membersResource"}, {"original_string": "private MockSyncService mockSyncService;", "modifier": "private", "type": "MockSyncService", "declarator": "mockSyncService", "var_name": "mockSyncService"}, {"original_string": "protected IDebugCounterService debugCounterService;", "modifier": "protected", "type": "IDebugCounterService", "declarator": "debugCounterService", "var_name": "debugCounterService"}, {"original_string": "protected IDebugEventService debugEventService;", "modifier": "protected", "type": "IDebugEventService", "declarator": "debugEventService", "var_name": "debugEventService"}, {"original_string": "protected LBVip vip1, vip2;", "modifier": "protected", "type": "LBVip", "declarator": "vip1", "var_name": "vip1"}, {"original_string": "protected LBPool pool1, pool2, pool3;", "modifier": "protected", "type": "LBPool", "declarator": "pool1", "var_name": "pool1"}, {"original_string": "protected LBMember member1, member2, member3, member4;", "modifier": "protected", "type": "LBMember", "declarator": "member1", "var_name": "member1"}, {"original_string": "private OFFactory factory;", "modifier": "private", "type": "OFFactory", "declarator": "factory", "var_name": "factory"}], "file": "src/agents/apps/floodlight/floodlight-1.0/src/test/java/net/floodlightcontroller/loadbalancer/LoadBalancerTest.java"}, "test_case": {"identifier": "testTwoSubsequentIcmpRequests", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testTwoSubsequentIcmpRequests() throws Exception {\n\t\ttestCreateVip();\n\t\ttestCreatePool();\n\t\ttestCreateMember();\n\n\t\tIOFSwitch sw1;\n\n\t\tIPacket arpRequest1, arpReply1, icmpPacket1, icmpPacket2;\n\n\t\tbyte[] arpRequest1Serialized;\n\t\tbyte[] arpReply1Serialized;\n\t\tbyte[] icmpPacket1Serialized, icmpPacket2Serialized;\n\n\t\tOFPacketIn arpRequestPacketIn1;\n\t\tOFPacketIn icmpPacketIn1, icmpPacketIn2;\n\n\t\tOFPacketOut arpReplyPacketOut1;\n\n\t\tCapture<OFMessage> wc1 = new Capture<OFMessage>(CaptureType.ALL);\n\n\t\tsw1 = EasyMock.createNiceMock(IOFSwitch.class);\n\t\texpect(sw1.getId()).andReturn(DatapathId.of(1L)).anyTimes();\n\t\texpect(sw1.hasAttribute(IOFSwitch.PROP_SUPPORTS_OFPP_TABLE)).andReturn(true).anyTimes();\n\t\texpect(sw1.getOFFactory()).andReturn(factory).anyTimes();\n\t\tsw1.write(capture(wc1));\n\t\texpectLastCall().anyTimes();\n\t\tsw1.flush();\n\t\texpectLastCall().anyTimes();\n\t\t\n\t\treplay(sw1);\n\t\tsfp.switchAdded(DatapathId.of(1L));\n\t\t\n\t\tverify(sw1);\n\n\t\t/* Test plan:\n\t\t * - two clients and two servers on sw1 port 1, 2, 3, 4\n\t\t * - mock arp request received towards vip1 from (1L, 1)\n\t\t * - proxy arp got pushed out to (1L, 1)- check sw1 getting the packetout\n\t\t * - mock icmp request received towards vip1 from (1L, 1)\n\t\t * - device manager list of devices queried to identify source and dest devices\n\t\t * - routing engine queried to get inbound and outbound routes\n\t\t * - check getRoute calls and responses\n\t\t * - sfp called to install flows\n\t\t * - check sfp calls\n\t\t */\n\n\t\t// Build topology\n\t\treset(topology);\n\t\texpect(topology.isIncomingBroadcastAllowed(DatapathId.of(anyLong()), OFPort.of(anyShort()))).andReturn(true).anyTimes();\n\t\texpect(topology.getL2DomainId(DatapathId.of(1L))).andReturn(DatapathId.of(1L)).anyTimes();\n\t\texpect(topology.isAttachmentPointPort(DatapathId.of(1L), OFPort.of(1))).andReturn(true).anyTimes();\n\t\texpect(topology.isAttachmentPointPort(DatapathId.of(1L), OFPort.of(2))).andReturn(true).anyTimes();\n\t\texpect(topology.isAttachmentPointPort(DatapathId.of(1L), OFPort.of(3))).andReturn(true).anyTimes();\n\t\texpect(topology.isAttachmentPointPort(DatapathId.of(1L), OFPort.of(4))).andReturn(true).anyTimes();\n\t\treplay(topology);\n\n\t\t// Build arp packets\n\t\tarpRequest1 = new Ethernet()\n\t\t.setSourceMACAddress(\"00:00:00:00:00:01\")\n\t\t.setDestinationMACAddress(\"ff:ff:ff:ff:ff:ff\")\n\t\t.setEtherType(Ethernet.TYPE_ARP)\n\t\t.setVlanID((short) 0)\n\t\t.setPriorityCode((byte) 0)\n\t\t.setPayload(\n\t\t\t\tnew ARP()\n\t\t\t\t.setHardwareType(ARP.HW_TYPE_ETHERNET)\n\t\t\t\t.setProtocolType(ARP.PROTO_TYPE_IP)\n\t\t\t\t.setHardwareAddressLength((byte) 6)\n\t\t\t\t.setProtocolAddressLength((byte) 4)\n\t\t\t\t.setOpCode(ARP.OP_REQUEST)\n\t\t\t\t.setSenderHardwareAddress(HexString.fromHexString(\"00:00:00:00:00:01\"))\n\t\t\t\t.setSenderProtocolAddress(IPv4.toIPv4AddressBytes(\"10.0.0.1\"))\n\t\t\t\t.setTargetHardwareAddress(HexString.fromHexString(\"00:00:00:00:00:00\"))\n\t\t\t\t.setTargetProtocolAddress(IPv4.toIPv4AddressBytes(\"10.0.0.100\")));\n\n\t\tarpRequest1Serialized = arpRequest1.serialize();\n\n\t\tarpRequestPacketIn1 = factory.buildPacketIn()\n\t\t\t\t.setMatch(factory.buildMatch().setExact(MatchField.IN_PORT, OFPort.of(1)).build())\n\t\t\t\t.setBufferId(OFBufferId.NO_BUFFER)\n\t\t\t\t.setData(arpRequest1Serialized)\n\t\t\t\t.setReason(OFPacketInReason.NO_MATCH)\n\t\t\t\t.build();\n\n\t\tIFloodlightProviderService.bcStore.put(cntx,\n\t\t\t\tIFloodlightProviderService.CONTEXT_PI_PAYLOAD,\n\t\t\t\t(Ethernet) arpRequest1);\n\n\t\t// Mock proxy arp packet-out\n\t\tarpReply1 = new Ethernet()\n\t\t.setSourceMACAddress(LBVip.LB_PROXY_MAC)\n\t\t.setDestinationMACAddress(HexString.fromHexString(\"00:00:00:00:00:01\"))\n\t\t.setEtherType(Ethernet.TYPE_ARP)\n\t\t.setVlanID((short) 0)\n\t\t.setPriorityCode((byte) 0)\n\t\t.setPayload(\n\t\t\t\tnew ARP()\n\t\t\t\t.setHardwareType(ARP.HW_TYPE_ETHERNET)\n\t\t\t\t.setProtocolType(ARP.PROTO_TYPE_IP)\n\t\t\t\t.setHardwareAddressLength((byte) 6)\n\t\t\t\t.setProtocolAddressLength((byte) 4)\n\t\t\t\t.setOpCode(ARP.OP_REPLY)\n\t\t\t\t.setSenderHardwareAddress(HexString.fromHexString(LBVip.LB_PROXY_MAC))\n\t\t\t\t.setSenderProtocolAddress(IPv4.toIPv4AddressBytes(\"10.0.0.100\"))\n\t\t\t\t.setTargetHardwareAddress(HexString.fromHexString(\"00:00:00:00:00:01\"))\n\t\t\t\t.setTargetProtocolAddress(IPv4.toIPv4AddressBytes(\"10.0.0.1\")));\n\n\t\tarpReply1Serialized = arpReply1.serialize();\n\n\t\tList<OFAction> poactions = new ArrayList<OFAction>();\n\t\tpoactions.add(factory.actions().output(arpRequestPacketIn1.getMatch().get(MatchField.IN_PORT), Integer.MAX_VALUE));\n\t\tarpReplyPacketOut1 = factory.buildPacketOut()\n\t\t\t\t.setBufferId(OFBufferId.NO_BUFFER)\n\t\t\t\t.setInPort(OFPort.ANY)\n\t\t\t\t.setActions(poactions)\n\t\t\t\t.setData(arpReply1Serialized)\n\t\t\t\t.setXid(22)\n\t\t\t\t.build();\n\t\tsw1.write(arpReplyPacketOut1);\n\t\t\n\t\tlb.receive(sw1, arpRequestPacketIn1, cntx);\n\t\tverify(sw1, topology);\n\n\t\tassertTrue(wc1.hasCaptured());  // wc1 should get packetout\n\n\t\tList<OFMessage> msglist1 = wc1.getValues();\n\n\t\tfor (OFMessage m: msglist1) {\n\t\t\tif (m instanceof OFPacketOut)\n\t\t\t\tassertTrue(OFMessageUtils.equalsIgnoreXid(arpReplyPacketOut1, m));\n\t\t\telse\n\t\t\t\tassertTrue(false); // unexpected message\n\t\t}\n\n\t\t//\n\t\t// Skip arpRequest2 test - in reality this will happen, but for unit test the same logic\n\t\t// is already validated with arpRequest1 test above\n\t\t//\n\t\t\n\t\t// Keep the StaticFlowEntryPusher happy with a switch in the switch service\n\t\tMap<DatapathId, IOFSwitch> switches = new HashMap<DatapathId, IOFSwitch>(1);\n\t\tswitches.put(DatapathId.of(1), sw1);\n\t\tgetMockSwitchService().setSwitches(switches);\n\n\n\t\t// Build icmp packets\n\t\ticmpPacket1 = new Ethernet()\n\t\t.setSourceMACAddress(\"00:00:00:00:00:01\")\n\t\t.setDestinationMACAddress(LBVip.LB_PROXY_MAC)\n\t\t.setEtherType(Ethernet.TYPE_IPv4)\n\t\t.setVlanID((short) 0)\n\t\t.setPriorityCode((byte) 0)\n\t\t.setPayload(\n\t\t\t\tnew IPv4()\n\t\t\t\t.setSourceAddress(\"10.0.0.1\")\n\t\t\t\t.setDestinationAddress(\"10.0.0.100\")\n\t\t\t\t.setProtocol(IpProtocol.ICMP)\n\t\t\t\t.setPayload(new ICMP()\n\t\t\t\t.setIcmpCode((byte) 0)\n\t\t\t\t.setIcmpType((byte) 0)));\n\n\t\ticmpPacket1Serialized = icmpPacket1.serialize();\n\n\t\ticmpPacketIn1 = OFFactories.getFactory(OFVersion.OF_13).buildPacketIn()\n\t\t\t\t.setBufferId(OFBufferId.NO_BUFFER)\n\t\t\t\t.setMatch(OFFactories.getFactory(OFVersion.OF_13).buildMatch().setExact(MatchField.IN_PORT, OFPort.of(1)).build())\n\t\t\t\t.setData(icmpPacket1Serialized)\n\t\t\t\t.setReason(OFPacketInReason.NO_MATCH)\n\t\t\t\t.build();\n\t\ticmpPacket2 = new Ethernet()\n\t\t.setSourceMACAddress(\"00:00:00:00:00:02\")\n\t\t.setDestinationMACAddress(LBVip.LB_PROXY_MAC)\n\t\t.setEtherType(Ethernet.TYPE_IPv4)\n\t\t.setVlanID((short) 0)\n\t\t.setPriorityCode((byte) 0)\n\t\t.setPayload(\n\t\t\t\tnew IPv4()\n\t\t\t\t.setSourceAddress(\"10.0.0.2\")\n\t\t\t\t.setDestinationAddress(\"10.0.0.100\")\n\t\t\t\t.setProtocol(IpProtocol.ICMP)\n\t\t\t\t.setPayload(new ICMP()\n\t\t\t\t.setIcmpCode((byte) 0)\n\t\t\t\t.setIcmpType((byte) 0)));\n\n\t\ticmpPacket2Serialized = icmpPacket2.serialize();\n\n\t\ticmpPacketIn2 = OFFactories.getFactory(OFVersion.OF_13).buildPacketIn()\n\t\t\t\t.setBufferId(OFBufferId.NO_BUFFER)\n\t\t\t\t.setMatch(OFFactories.getFactory(OFVersion.OF_13).buildMatch().setExact(MatchField.IN_PORT, OFPort.of(2)).build())\n\t\t\t\t.setData(icmpPacket2Serialized)\n\t\t\t\t.setReason(OFPacketInReason.NO_MATCH)\n\t\t\t\t.build();\n\t\tMacAddress dataLayerSource1 = ((Ethernet)icmpPacket1).getSourceMACAddress();\n\t\tIPv4Address networkSource1 = ((IPv4)((Ethernet)icmpPacket1).getPayload()).getSourceAddress();\n\t\tMacAddress dataLayerDest1 = MacAddress.of(\"00:00:00:00:00:03\");\n\t\tIPv4Address networkDest1 = IPv4Address.of(\"10.0.0.3\");\n\t\tMacAddress dataLayerSource2 = ((Ethernet)icmpPacket2).getSourceMACAddress();\n\t\tIPv4Address networkSource2 = ((IPv4)((Ethernet)icmpPacket2).getPayload()).getSourceAddress();\n\t\tMacAddress dataLayerDest2 = MacAddress.of(\"00:00:00:00:00:04\");\n\t\tIPv4Address networkDest2 = IPv4Address.of(\"10.0.0.4\");\n\n\t\tdeviceManager.learnEntity(dataLayerSource1.getLong(),\n\t\t\t\tnull, networkSource1.getInt(),\n\t\t\t\t1L, 1);\n\t\tdeviceManager.learnEntity(dataLayerSource2.getLong(),\n\t\t\t\tnull, networkSource2.getInt(),\n\t\t\t\t1L, 2);\n\t\tdeviceManager.learnEntity(dataLayerDest1.getLong(),\n\t\t\t\tnull, networkDest1.getInt(),\n\t\t\t\t1L, 3);\n\t\tdeviceManager.learnEntity(dataLayerDest2.getLong(),\n\t\t\t\tnull, networkDest2.getInt(),\n\t\t\t\t1L, 4);\n\n\t\t// in bound #1\n\t\tRoute route1 = new Route(DatapathId.of(1L), DatapathId.of(1L));\n\t\tList<NodePortTuple> nptList1 = new ArrayList<NodePortTuple>();\n\t\tnptList1.add(new NodePortTuple(DatapathId.of(1L), OFPort.of(1)));\n\t\tnptList1.add(new NodePortTuple(DatapathId.of(1L), OFPort.of(3)));\n\t\troute1.setPath(nptList1);\n\t\texpect(routingEngine.getRoute(DatapathId.of(1L), OFPort.of(1), DatapathId.of(1L), OFPort.of(3), U64.of(0))).andReturn(route1).atLeastOnce();\n\n\t\t// outbound #1\n\t\tRoute route2 = new Route(DatapathId.of(1L), DatapathId.of(1L));\n\t\tList<NodePortTuple> nptList2 = new ArrayList<NodePortTuple>();\n\t\tnptList2.add(new NodePortTuple(DatapathId.of(1L), OFPort.of(3)));\n\t\tnptList2.add(new NodePortTuple(DatapathId.of(1L), OFPort.of(1)));\n\t\troute2.setPath(nptList2);\n\t\texpect(routingEngine.getRoute(DatapathId.of(1L), OFPort.of(3), DatapathId.of(1L), OFPort.of(1), U64.of(0))).andReturn(route2).atLeastOnce();\n\n\t\t// inbound #2\n\t\tRoute route3 = new Route(DatapathId.of(1L), DatapathId.of(1L));\n\t\tList<NodePortTuple> nptList3 = new ArrayList<NodePortTuple>();\n\t\tnptList3.add(new NodePortTuple(DatapathId.of(1L), OFPort.of(2)));\n\t\tnptList3.add(new NodePortTuple(DatapathId.of(1L), OFPort.of(4)));\n\t\troute3.setPath(nptList3);\n\t\texpect(routingEngine.getRoute(DatapathId.of(1L), OFPort.of(2), DatapathId.of(1L), OFPort.of(4), U64.of(0))).andReturn(route3).atLeastOnce();\n\n\t\t// outbound #2\n\t\tRoute route4 = new Route(DatapathId.of(1L), DatapathId.of(1L));\n\t\tList<NodePortTuple> nptList4 = new ArrayList<NodePortTuple>();\n\t\tnptList4.add(new NodePortTuple(DatapathId.of(1L), OFPort.of(4)));\n\t\tnptList4.add(new NodePortTuple(DatapathId.of(1L), OFPort.of(2)));\n\t\troute4.setPath(nptList3);\n\t\texpect(routingEngine.getRoute(DatapathId.of(1L), OFPort.of(4), DatapathId.of(1L), OFPort.of(2), U64.of(0))).andReturn(route4).atLeastOnce();\n\n\t\treplay(routingEngine);\n\n\t\twc1.reset();\n\n\t\tIFloodlightProviderService.bcStore.put(cntx,\n\t\t\t\tIFloodlightProviderService.CONTEXT_PI_PAYLOAD,\n\t\t\t\t(Ethernet) icmpPacket1);\n\t\tlb.receive(sw1, icmpPacketIn1, cntx);\n\n\t\tIFloodlightProviderService.bcStore.put(cntx,\n\t\t\t\tIFloodlightProviderService.CONTEXT_PI_PAYLOAD,\n\t\t\t\t(Ethernet) icmpPacket2);\n\t\tlb.receive(sw1, icmpPacketIn2, cntx);\n\n\t\tassertTrue(wc1.hasCaptured());  // wc1 should get packetout\n\n\t\tList<OFMessage> msglist2 = wc1.getValues();\n\n\t\tassertTrue(msglist2.size()==2); // has inbound and outbound packetouts\n\t\t// TODO: not seeing flowmods yet ...\n\n\t\tMap<String, OFFlowMod> map = sfp.getFlows(DatapathId.of(1L));\n\n\t\tassertTrue(map.size()==4);\n\t}", "signature": "void testTwoSubsequentIcmpRequests()", "full_signature": "@Test public void testTwoSubsequentIcmpRequests()", "class_method_signature": "LoadBalancerTest.testTwoSubsequentIcmpRequests()", "testcase": true, "constructor": false, "invocations": ["testCreateVip", "testCreatePool", "testCreateMember", "createNiceMock", "anyTimes", "andReturn", "expect", "getId", "of", "anyTimes", "andReturn", "expect", "hasAttribute", "anyTimes", "andReturn", "expect", "getOFFactory", "write", "capture", "anyTimes", "expectLastCall", "flush", "anyTimes", "expectLastCall", "replay", "switchAdded", "of", "verify", "reset", "anyTimes", "andReturn", "expect", "isIncomingBroadcastAllowed", "of", "anyLong", "of", "anyShort", "anyTimes", "andReturn", "expect", "getL2DomainId", "of", "of", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "of", "of", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "of", "of", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "of", "of", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "of", "of", "replay", "setPayload", "setPriorityCode", "setVlanID", "setEtherType", "setDestinationMACAddress", "setSourceMACAddress", "setTargetProtocolAddress", "setTargetHardwareAddress", "setSenderProtocolAddress", "setSenderHardwareAddress", "setOpCode", "setProtocolAddressLength", "setHardwareAddressLength", "setProtocolType", "setHardwareType", "fromHexString", "toIPv4AddressBytes", "fromHexString", "toIPv4AddressBytes", "serialize", "build", "setReason", "setData", "setBufferId", "setMatch", "buildPacketIn", "build", "setExact", "buildMatch", "of", "put", "setPayload", "setPriorityCode", "setVlanID", "setEtherType", "setDestinationMACAddress", "setSourceMACAddress", "fromHexString", "setTargetProtocolAddress", "setTargetHardwareAddress", "setSenderProtocolAddress", "setSenderHardwareAddress", "setOpCode", "setProtocolAddressLength", "setHardwareAddressLength", "setProtocolType", "setHardwareType", "fromHexString", "toIPv4AddressBytes", "fromHexString", "toIPv4AddressBytes", "serialize", "add", "output", "actions", "get", "getMatch", "build", "setXid", "setData", "setActions", "setInPort", "setBufferId", "buildPacketOut", "write", "receive", "verify", "assertTrue", "hasCaptured", "getValues", "assertTrue", "equalsIgnoreXid", "assertTrue", "put", "of", "setSwitches", "getMockSwitchService", "setPayload", "setPriorityCode", "setVlanID", "setEtherType", "setDestinationMACAddress", "setSourceMACAddress", "setPayload", "setProtocol", "setDestinationAddress", "setSourceAddress", "setIcmpType", "setIcmpCode", "serialize", "build", "setReason", "setData", "setMatch", "setBufferId", "buildPacketIn", "getFactory", "build", "setExact", "buildMatch", "getFactory", "of", "setPayload", "setPriorityCode", "setVlanID", "setEtherType", "setDestinationMACAddress", "setSourceMACAddress", "setPayload", "setProtocol", "setDestinationAddress", "setSourceAddress", "setIcmpType", "setIcmpCode", "serialize", "build", "setReason", "setData", "setMatch", "setBufferId", "buildPacketIn", "getFactory", "build", "setExact", "buildMatch", "getFactory", "of", "getSourceMACAddress", "getSourceAddress", "getPayload", "of", "of", "getSourceMACAddress", "getSourceAddress", "getPayload", "of", "of", "learnEntity", "getLong", "getInt", "learnEntity", "getLong", "getInt", "learnEntity", "getLong", "getInt", "learnEntity", "getLong", "getInt", "of", "of", "add", "of", "of", "add", "of", "of", "setPath", "atLeastOnce", "andReturn", "expect", "getRoute", "of", "of", "of", "of", "of", "of", "of", "add", "of", "of", "add", "of", "of", "setPath", "atLeastOnce", "andReturn", "expect", "getRoute", "of", "of", "of", "of", "of", "of", "of", "add", "of", "of", "add", "of", "of", "setPath", "atLeastOnce", "andReturn", "expect", "getRoute", "of", "of", "of", "of", "of", "of", "of", "add", "of", "of", "add", "of", "of", "setPath", "atLeastOnce", "andReturn", "expect", "getRoute", "of", "of", "of", "of", "of", "replay", "reset", "put", "receive", "put", "receive", "assertTrue", "hasCaptured", "getValues", "assertTrue", "size", "getFlows", "of", "assertTrue", "size"]}, "focal_class": {"identifier": "LoadBalancer", "superclass": "", "interfaces": "implements IFloodlightModule,\n    ILoadBalancerService, IOFMessageListener", "fields": [{"original_string": "protected static Logger log = LoggerFactory.getLogger(LoadBalancer.class);", "modifier": "protected static", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(LoadBalancer.class)", "var_name": "log"}, {"original_string": "protected IFloodlightProviderService floodlightProviderService;", "modifier": "protected", "type": "IFloodlightProviderService", "declarator": "floodlightProviderService", "var_name": "floodlightProviderService"}, {"original_string": "protected IRestApiService restApiService;", "modifier": "protected", "type": "IRestApiService", "declarator": "restApiService", "var_name": "restApiService"}, {"original_string": "protected IDebugCounterService debugCounterService;", "modifier": "protected", "type": "IDebugCounterService", "declarator": "debugCounterService", "var_name": "debugCounterService"}, {"original_string": "private IDebugCounter counterPacketOut;", "modifier": "private", "type": "IDebugCounter", "declarator": "counterPacketOut", "var_name": "counterPacketOut"}, {"original_string": "protected IDeviceService deviceManagerService;", "modifier": "protected", "type": "IDeviceService", "declarator": "deviceManagerService", "var_name": "deviceManagerService"}, {"original_string": "protected IRoutingService routingEngineService;", "modifier": "protected", "type": "IRoutingService", "declarator": "routingEngineService", "var_name": "routingEngineService"}, {"original_string": "protected ITopologyService topologyService;", "modifier": "protected", "type": "ITopologyService", "declarator": "topologyService", "var_name": "topologyService"}, {"original_string": "protected IStaticFlowEntryPusherService sfpService;", "modifier": "protected", "type": "IStaticFlowEntryPusherService", "declarator": "sfpService", "var_name": "sfpService"}, {"original_string": "protected IOFSwitchService switchService;", "modifier": "protected", "type": "IOFSwitchService", "declarator": "switchService", "var_name": "switchService"}, {"original_string": "protected HashMap<String, LBVip> vips;", "modifier": "protected", "type": "HashMap<String, LBVip>", "declarator": "vips", "var_name": "vips"}, {"original_string": "protected HashMap<String, LBPool> pools;", "modifier": "protected", "type": "HashMap<String, LBPool>", "declarator": "pools", "var_name": "pools"}, {"original_string": "protected HashMap<String, LBMember> members;", "modifier": "protected", "type": "HashMap<String, LBMember>", "declarator": "members", "var_name": "members"}, {"original_string": "protected HashMap<Integer, String> vipIpToId;", "modifier": "protected", "type": "HashMap<Integer, String>", "declarator": "vipIpToId", "var_name": "vipIpToId"}, {"original_string": "protected HashMap<Integer, MacAddress> vipIpToMac;", "modifier": "protected", "type": "HashMap<Integer, MacAddress>", "declarator": "vipIpToMac", "var_name": "vipIpToMac"}, {"original_string": "protected HashMap<Integer, String> memberIpToId;", "modifier": "protected", "type": "HashMap<Integer, String>", "declarator": "memberIpToId", "var_name": "memberIpToId"}, {"original_string": "protected HashMap<IPClient, LBMember> clientToMember;", "modifier": "protected", "type": "HashMap<IPClient, LBMember>", "declarator": "clientToMember", "var_name": "clientToMember"}, {"original_string": "protected static int OFMESSAGE_DAMPER_CAPACITY = 10000;", "modifier": "protected static", "type": "int", "declarator": "OFMESSAGE_DAMPER_CAPACITY = 10000", "var_name": "OFMESSAGE_DAMPER_CAPACITY"}, {"original_string": "protected static int OFMESSAGE_DAMPER_TIMEOUT = 250;", "modifier": "protected static", "type": "int", "declarator": "OFMESSAGE_DAMPER_TIMEOUT = 250", "var_name": "OFMESSAGE_DAMPER_TIMEOUT"}, {"original_string": "protected static String LB_ETHER_TYPE = \"0x800\";", "modifier": "protected static", "type": "String", "declarator": "LB_ETHER_TYPE = \"0x800\"", "var_name": "LB_ETHER_TYPE"}, {"original_string": "protected static int LB_PRIORITY = 32768;", "modifier": "protected static", "type": "int", "declarator": "LB_PRIORITY = 32768", "var_name": "LB_PRIORITY"}, {"original_string": "public Comparator<SwitchPort> clusterIdComparator =\n            new Comparator<SwitchPort>() {\n                @Override\n                public int compare(SwitchPort d1, SwitchPort d2) {\n                    DatapathId d1ClusterId = topologyService.getL2DomainId(d1.getSwitchDPID());\n                    DatapathId d2ClusterId = topologyService.getL2DomainId(d2.getSwitchDPID());\n                    return d1ClusterId.compareTo(d2ClusterId);\n                }\n            };", "modifier": "public", "type": "Comparator<SwitchPort>", "declarator": "clusterIdComparator =\n            new Comparator<SwitchPort>() {\n                @Override\n                public int compare(SwitchPort d1, SwitchPort d2) {\n                    DatapathId d1ClusterId = topologyService.getL2DomainId(d1.getSwitchDPID());\n                    DatapathId d2ClusterId = topologyService.getL2DomainId(d2.getSwitchDPID());\n                    return d1ClusterId.compareTo(d2ClusterId);\n                }\n            }", "var_name": "clusterIdComparator"}], "methods": [{"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getName()", "full_signature": "@Override public String getName()", "class_method_signature": "LoadBalancer.getName()", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPrereq", "parameters": "(OFType type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPrereq(OFType type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPrereq(OFType type, String name)", "class_method_signature": "LoadBalancer.isCallbackOrderingPrereq(OFType type, String name)", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPostreq", "parameters": "(OFType type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPostreq(OFType type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPostreq(OFType type, String name)", "class_method_signature": "LoadBalancer.isCallbackOrderingPostreq(OFType type, String name)", "testcase": false, "constructor": false}, {"identifier": "receive", "parameters": "(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "modifiers": "@Override public", "return": "net.floodlightcontroller.core.IListener.Command", "signature": "net.floodlightcontroller.core.IListener.Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "full_signature": "@Override public net.floodlightcontroller.core.IListener.Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "class_method_signature": "LoadBalancer.receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "testcase": false, "constructor": false}, {"identifier": "processPacketIn", "parameters": "(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "modifiers": "private", "return": "net.floodlightcontroller.core.IListener.Command", "signature": "net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "full_signature": "private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "class_method_signature": "LoadBalancer.processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "testcase": false, "constructor": false}, {"identifier": "vipProxyArpReply", "parameters": "(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx, String vipId)", "modifiers": "protected", "return": "void", "signature": "void vipProxyArpReply(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx, String vipId)", "full_signature": "protected void vipProxyArpReply(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx, String vipId)", "class_method_signature": "LoadBalancer.vipProxyArpReply(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx, String vipId)", "testcase": false, "constructor": false}, {"identifier": "pushPacket", "parameters": "(IPacket packet, \n                           IOFSwitch sw,\n                           OFBufferId bufferId,\n                           OFPort inPort,\n                           OFPort outPort, \n                           FloodlightContext cntx,\n                           boolean flush)", "modifiers": "public", "return": "void", "signature": "void pushPacket(IPacket packet, \n                           IOFSwitch sw,\n                           OFBufferId bufferId,\n                           OFPort inPort,\n                           OFPort outPort, \n                           FloodlightContext cntx,\n                           boolean flush)", "full_signature": "public void pushPacket(IPacket packet, \n                           IOFSwitch sw,\n                           OFBufferId bufferId,\n                           OFPort inPort,\n                           OFPort outPort, \n                           FloodlightContext cntx,\n                           boolean flush)", "class_method_signature": "LoadBalancer.pushPacket(IPacket packet, \n                           IOFSwitch sw,\n                           OFBufferId bufferId,\n                           OFPort inPort,\n                           OFPort outPort, \n                           FloodlightContext cntx,\n                           boolean flush)", "testcase": false, "constructor": false}, {"identifier": "pushBidirectionalVipRoutes", "parameters": "(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx, IPClient client, LBMember member)", "modifiers": "protected", "return": "void", "signature": "void pushBidirectionalVipRoutes(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx, IPClient client, LBMember member)", "full_signature": "protected void pushBidirectionalVipRoutes(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx, IPClient client, LBMember member)", "class_method_signature": "LoadBalancer.pushBidirectionalVipRoutes(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx, IPClient client, LBMember member)", "testcase": false, "constructor": false}, {"identifier": "pushStaticVipRoute", "parameters": "(boolean inBound, Route route, IPClient client, LBMember member, IOFSwitch pinSwitch)", "modifiers": "public", "return": "void", "signature": "void pushStaticVipRoute(boolean inBound, Route route, IPClient client, LBMember member, IOFSwitch pinSwitch)", "full_signature": "public void pushStaticVipRoute(boolean inBound, Route route, IPClient client, LBMember member, IOFSwitch pinSwitch)", "class_method_signature": "LoadBalancer.pushStaticVipRoute(boolean inBound, Route route, IPClient client, LBMember member, IOFSwitch pinSwitch)", "testcase": false, "constructor": false}, {"identifier": "listVips", "parameters": "()", "modifiers": "@Override public", "return": "Collection<LBVip>", "signature": "Collection<LBVip> listVips()", "full_signature": "@Override public Collection<LBVip> listVips()", "class_method_signature": "LoadBalancer.listVips()", "testcase": false, "constructor": false}, {"identifier": "listVip", "parameters": "(String vipId)", "modifiers": "@Override public", "return": "Collection<LBVip>", "signature": "Collection<LBVip> listVip(String vipId)", "full_signature": "@Override public Collection<LBVip> listVip(String vipId)", "class_method_signature": "LoadBalancer.listVip(String vipId)", "testcase": false, "constructor": false}, {"identifier": "createVip", "parameters": "(LBVip vip)", "modifiers": "@Override public", "return": "LBVip", "signature": "LBVip createVip(LBVip vip)", "full_signature": "@Override public LBVip createVip(LBVip vip)", "class_method_signature": "LoadBalancer.createVip(LBVip vip)", "testcase": false, "constructor": false}, {"identifier": "updateVip", "parameters": "(LBVip vip)", "modifiers": "@Override public", "return": "LBVip", "signature": "LBVip updateVip(LBVip vip)", "full_signature": "@Override public LBVip updateVip(LBVip vip)", "class_method_signature": "LoadBalancer.updateVip(LBVip vip)", "testcase": false, "constructor": false}, {"identifier": "removeVip", "parameters": "(String vipId)", "modifiers": "@Override public", "return": "int", "signature": "int removeVip(String vipId)", "full_signature": "@Override public int removeVip(String vipId)", "class_method_signature": "LoadBalancer.removeVip(String vipId)", "testcase": false, "constructor": false}, {"identifier": "listPools", "parameters": "()", "modifiers": "@Override public", "return": "Collection<LBPool>", "signature": "Collection<LBPool> listPools()", "full_signature": "@Override public Collection<LBPool> listPools()", "class_method_signature": "LoadBalancer.listPools()", "testcase": false, "constructor": false}, {"identifier": "listPool", "parameters": "(String poolId)", "modifiers": "@Override public", "return": "Collection<LBPool>", "signature": "Collection<LBPool> listPool(String poolId)", "full_signature": "@Override public Collection<LBPool> listPool(String poolId)", "class_method_signature": "LoadBalancer.listPool(String poolId)", "testcase": false, "constructor": false}, {"identifier": "createPool", "parameters": "(LBPool pool)", "modifiers": "@Override public", "return": "LBPool", "signature": "LBPool createPool(LBPool pool)", "full_signature": "@Override public LBPool createPool(LBPool pool)", "class_method_signature": "LoadBalancer.createPool(LBPool pool)", "testcase": false, "constructor": false}, {"identifier": "updatePool", "parameters": "(LBPool pool)", "modifiers": "@Override public", "return": "LBPool", "signature": "LBPool updatePool(LBPool pool)", "full_signature": "@Override public LBPool updatePool(LBPool pool)", "class_method_signature": "LoadBalancer.updatePool(LBPool pool)", "testcase": false, "constructor": false}, {"identifier": "removePool", "parameters": "(String poolId)", "modifiers": "@Override public", "return": "int", "signature": "int removePool(String poolId)", "full_signature": "@Override public int removePool(String poolId)", "class_method_signature": "LoadBalancer.removePool(String poolId)", "testcase": false, "constructor": false}, {"identifier": "listMembers", "parameters": "()", "modifiers": "@Override public", "return": "Collection<LBMember>", "signature": "Collection<LBMember> listMembers()", "full_signature": "@Override public Collection<LBMember> listMembers()", "class_method_signature": "LoadBalancer.listMembers()", "testcase": false, "constructor": false}, {"identifier": "listMember", "parameters": "(String memberId)", "modifiers": "@Override public", "return": "Collection<LBMember>", "signature": "Collection<LBMember> listMember(String memberId)", "full_signature": "@Override public Collection<LBMember> listMember(String memberId)", "class_method_signature": "LoadBalancer.listMember(String memberId)", "testcase": false, "constructor": false}, {"identifier": "listMembersByPool", "parameters": "(String poolId)", "modifiers": "@Override public", "return": "Collection<LBMember>", "signature": "Collection<LBMember> listMembersByPool(String poolId)", "full_signature": "@Override public Collection<LBMember> listMembersByPool(String poolId)", "class_method_signature": "LoadBalancer.listMembersByPool(String poolId)", "testcase": false, "constructor": false}, {"identifier": "createMember", "parameters": "(LBMember member)", "modifiers": "@Override public", "return": "LBMember", "signature": "LBMember createMember(LBMember member)", "full_signature": "@Override public LBMember createMember(LBMember member)", "class_method_signature": "LoadBalancer.createMember(LBMember member)", "testcase": false, "constructor": false}, {"identifier": "updateMember", "parameters": "(LBMember member)", "modifiers": "@Override public", "return": "LBMember", "signature": "LBMember updateMember(LBMember member)", "full_signature": "@Override public LBMember updateMember(LBMember member)", "class_method_signature": "LoadBalancer.updateMember(LBMember member)", "testcase": false, "constructor": false}, {"identifier": "removeMember", "parameters": "(String memberId)", "modifiers": "@Override public", "return": "int", "signature": "int removeMember(String memberId)", "full_signature": "@Override public int removeMember(String memberId)", "class_method_signature": "LoadBalancer.removeMember(String memberId)", "testcase": false, "constructor": false}, {"identifier": "listMonitors", "parameters": "()", "modifiers": "@Override public", "return": "Collection<LBMonitor>", "signature": "Collection<LBMonitor> listMonitors()", "full_signature": "@Override public Collection<LBMonitor> listMonitors()", "class_method_signature": "LoadBalancer.listMonitors()", "testcase": false, "constructor": false}, {"identifier": "listMonitor", "parameters": "(String monitorId)", "modifiers": "@Override public", "return": "Collection<LBMonitor>", "signature": "Collection<LBMonitor> listMonitor(String monitorId)", "full_signature": "@Override public Collection<LBMonitor> listMonitor(String monitorId)", "class_method_signature": "LoadBalancer.listMonitor(String monitorId)", "testcase": false, "constructor": false}, {"identifier": "createMonitor", "parameters": "(LBMonitor monitor)", "modifiers": "@Override public", "return": "LBMonitor", "signature": "LBMonitor createMonitor(LBMonitor monitor)", "full_signature": "@Override public LBMonitor createMonitor(LBMonitor monitor)", "class_method_signature": "LoadBalancer.createMonitor(LBMonitor monitor)", "testcase": false, "constructor": false}, {"identifier": "updateMonitor", "parameters": "(LBMonitor monitor)", "modifiers": "@Override public", "return": "LBMonitor", "signature": "LBMonitor updateMonitor(LBMonitor monitor)", "full_signature": "@Override public LBMonitor updateMonitor(LBMonitor monitor)", "class_method_signature": "LoadBalancer.updateMonitor(LBMonitor monitor)", "testcase": false, "constructor": false}, {"identifier": "removeMonitor", "parameters": "(String monitorId)", "modifiers": "@Override public", "return": "int", "signature": "int removeMonitor(String monitorId)", "full_signature": "@Override public int removeMonitor(String monitorId)", "class_method_signature": "LoadBalancer.removeMonitor(String monitorId)", "testcase": false, "constructor": false}, {"identifier": "getModuleServices", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleServices()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleServices()", "class_method_signature": "LoadBalancer.getModuleServices()", "testcase": false, "constructor": false}, {"identifier": "getServiceImpls", "parameters": "()", "modifiers": "@Override public", "return": "Map<Class<? extends IFloodlightService>, IFloodlightService>", "signature": "Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "full_signature": "@Override public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "class_method_signature": "LoadBalancer.getServiceImpls()", "testcase": false, "constructor": false}, {"identifier": "getModuleDependencies", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "class_method_signature": "LoadBalancer.getModuleDependencies()", "testcase": false, "constructor": false}, {"identifier": "init", "parameters": "(FloodlightModuleContext context)", "modifiers": "@Override public", "return": "void", "signature": "void init(FloodlightModuleContext context)", "full_signature": "@Override public void init(FloodlightModuleContext context)", "class_method_signature": "LoadBalancer.init(FloodlightModuleContext context)", "testcase": false, "constructor": false}, {"identifier": "startUp", "parameters": "(FloodlightModuleContext context)", "modifiers": "@Override public", "return": "void", "signature": "void startUp(FloodlightModuleContext context)", "full_signature": "@Override public void startUp(FloodlightModuleContext context)", "class_method_signature": "LoadBalancer.startUp(FloodlightModuleContext context)", "testcase": false, "constructor": false}], "file": "src/agents/apps/floodlight/floodlight-1.0/src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"}, "focal_method": {"identifier": "receive", "parameters": "(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "modifiers": "@Override public", "return": "net.floodlightcontroller.core.IListener.Command", "body": "@Override\n    public net.floodlightcontroller.core.IListener.Command\n            receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {\n        switch (msg.getType()) {\n            case PACKET_IN:\n                return processPacketIn(sw, (OFPacketIn)msg, cntx);\n            default:\n                break;\n        }\n        log.warn(\"Received unexpected message {}\", msg);\n        return Command.CONTINUE;\n    }", "signature": "net.floodlightcontroller.core.IListener.Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "full_signature": "@Override public net.floodlightcontroller.core.IListener.Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "class_method_signature": "LoadBalancer.receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "testcase": false, "constructor": false, "invocations": ["getType", "processPacketIn", "warn"]}, "repository": {"repo_id": 181421086, "url": "https://github.com/seungsoo-lee/DELTA", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 35, "size": 99244, "license": "licensed"}}