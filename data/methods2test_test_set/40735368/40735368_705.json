{"test_class": {"identifier": "WindBarbsFactoryTest", "superclass": "extends Assert", "interfaces": "", "fields": [{"original_string": "private static final WKTWriter WKT_WRITER = new WKTWriter(2);", "modifier": "private static final", "type": "WKTWriter", "declarator": "WKT_WRITER = new WKTWriter(2)", "var_name": "WKT_WRITER"}, {"original_string": "private WindBarbsFactory wbf = new WindBarbsFactory();", "modifier": "private", "type": "WindBarbsFactory", "declarator": "wbf = new WindBarbsFactory()", "var_name": "wbf"}, {"original_string": "private SimpleFeature feature;", "modifier": "private", "type": "SimpleFeature", "declarator": "feature", "var_name": "feature"}, {"original_string": "private Expression exp;", "modifier": "private", "type": "Expression", "declarator": "exp", "var_name": "exp"}, {"original_string": "private FilterFactory ff;", "modifier": "private", "type": "FilterFactory", "declarator": "ff", "var_name": "ff"}], "file": "modules/library/render/src/test/java/org/geotools/renderer/windbarbs/WindBarbsFactoryTest.java"}, "test_case": {"identifier": "testDefaultValid", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDefaultValid() {\n        // no module --> x--------\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(NaN)[kts]\");\n        Shape shp = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shp);\n        assertTrue(shp instanceof Path2D);\n        assertEquals(WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shp)).toString(),\n                \"MULTILINESTRING ((0 -0, 0 40), (5 45, -5 35), (-5 45, 5 35))\");\n\n        // 1 KNOTS --> calm\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(1)[kts]\");\n        shp = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shp);\n        assertTrue(shp instanceof Ellipse2D);\n        assertEquals(((Ellipse2D) shp).getHeight(), ((Ellipse2D) shp).getWidth(), 1E-6); // circle\n\n        // 2.99999999 KNOTS --> calm\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(2.999999999999)[kts]\");\n        shp = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shp);\n        assertTrue(shp instanceof Ellipse2D);\n        assertEquals(((Ellipse2D) shp).getHeight(), ((Ellipse2D) shp).getWidth(), 1E-6); // circle\n\n        // 3 KNOTS --> short barb\n        // NORTH\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(3)[kts]\");\n        shp = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shp);\n        assertTrue(shp instanceof Path2D);\n        String shpString = WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shp)).toString();\n        assertEquals(WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shp)).toString(),\n                \"MULTILINESTRING ((0 -0, 0 40), (0 35, 10 36.25))\");\n        // SOUTH make sure the same shp is flipped on y axis\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(3)[kts]?emisphere=S\");\n        Shape shpS = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shpS);\n        assertTrue(shpS instanceof Path2D);\n        shpS = WindBarbsFactory.SOUTHERN_EMISPHERE_FLIP.createTransformedShape(shpS); // flip and check\n        assertEquals(WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shpS)).toString(),\n                shpString);\n\n        // 5 KNOTS --> short barb\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(5)[kts]\");\n        shp = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shp);\n        assertTrue(shp instanceof Path2D);\n        shpString = WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shp)).toString();\n        assertEquals(shpString, \"MULTILINESTRING ((0 -0, 0 40), (0 35, 10 36.25))\");\n\n        // SOUTH make sure the same shp is flipped on y axis\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(5)[kts]?hemisphere=S\");\n        shpS = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shpS);\n        assertTrue(shpS instanceof Path2D);\n        shpS = WindBarbsFactory.SOUTHERN_EMISPHERE_FLIP.createTransformedShape(shpS); // flip and check\n        assertEquals(WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shpS)).toString(),\n                shpString);\n\n        // 100 KNOTS --> square\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(100)[kts]\");\n        shp = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shp);\n        assertTrue(shp instanceof Path2D);\n        shpString = WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shp)).toString();\n        assertEquals(shpString, \"MULTILINESTRING ((0 -0, 0 40), (0 40, 10 40, 10 30, 0 30, 0 40))\");\n        // SOUTH make sure the same shp is flipped on y axis\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(100)[kts]?hemisphere=s\");\n        shpS = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shpS);\n        assertTrue(shpS instanceof Path2D);\n        shpS = WindBarbsFactory.SOUTHERN_EMISPHERE_FLIP.createTransformedShape(shpS); // flip and check\n        assertEquals(WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shpS)).toString(),\n                shpString);\n\n        // 15 KNOTS --> square\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(15)[kts]\");\n        shp = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shp);\n        assertTrue(shp instanceof Path2D);\n        assertEquals(WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shp)).toString(),\n                \"MULTILINESTRING ((0 -0, 0 40), (0 40, 20 42.5), (0 35, 10 36.25))\");\n\n        // 20 KNOTS --> square\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(20)[kts]\");\n        shp = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shp);\n        assertTrue(shp instanceof Path2D);\n        assertEquals(WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shp)).toString(),\n                \"MULTILINESTRING ((0 -0, 0 40), (0 40, 20 42.5), (0 35, 20 37.5))\");\n\n        // 25 KNOTS --> square\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(25)[kts]\");\n        shp = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shp);\n        assertTrue(shp instanceof Path2D);\n        assertEquals(WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shp)).toString(),\n                \"MULTILINESTRING ((0 -0, 0 40), (0 40, 20 42.5), (0 35, 20 37.5), (0 30, 10 31.25))\");\n\n        // 50 KNOTS --> pennat\n        this.exp = ff.literal(WindBarbsFactory.WINDBARBS_PREFIX + \"default(50)[kts]\");\n        shp = (Shape) wbf.getShape(null, this.exp, this.feature);\n        assertNotNull(shp);\n        assertTrue(shp instanceof Path2D);\n        assertEquals(WindBarbsFactoryTest.WKT_WRITER.write(JTS.toGeometry(shp)).toString(),\n                \"MULTILINESTRING ((0 -0, 0 40), (0 40, 20 37, 0 34, 0 40))\");\n\n    }", "signature": "void testDefaultValid()", "full_signature": "@Test public void testDefaultValid()", "class_method_signature": "WindBarbsFactoryTest.testDefaultValid()", "testcase": true, "constructor": false, "invocations": ["literal", "getShape", "assertNotNull", "assertTrue", "assertEquals", "toString", "write", "toGeometry", "literal", "getShape", "assertNotNull", "assertTrue", "assertEquals", "getHeight", "getWidth", "literal", "getShape", "assertNotNull", "assertTrue", "assertEquals", "getHeight", "getWidth", "literal", "getShape", "assertNotNull", "assertTrue", "toString", "write", "toGeometry", "assertEquals", "toString", "write", "toGeometry", "literal", "getShape", "assertNotNull", "assertTrue", "createTransformedShape", "assertEquals", "toString", "write", "toGeometry", "literal", "getShape", "assertNotNull", "assertTrue", "toString", "write", "toGeometry", "assertEquals", "literal", "getShape", "assertNotNull", "assertTrue", "createTransformedShape", "assertEquals", "toString", "write", "toGeometry", "literal", "getShape", "assertNotNull", "assertTrue", "toString", "write", "toGeometry", "assertEquals", "literal", "getShape", "assertNotNull", "assertTrue", "createTransformedShape", "assertEquals", "toString", "write", "toGeometry", "literal", "getShape", "assertNotNull", "assertTrue", "assertEquals", "toString", "write", "toGeometry", "literal", "getShape", "assertNotNull", "assertTrue", "assertEquals", "toString", "write", "toGeometry", "literal", "getShape", "assertNotNull", "assertTrue", "assertEquals", "toString", "write", "toGeometry", "literal", "getShape", "assertNotNull", "assertTrue", "assertEquals", "toString", "write", "toGeometry"]}, "focal_class": {"identifier": "WindBarbsFactory", "superclass": "", "interfaces": "implements MarkFactory", "fields": [{"original_string": "private static final String WINDBARB_DEFINITION = \"windbarbs://.*\\\\(.{1,}\\\\)\\\\[.{1,5}\\\\]\\\\??.*\";", "modifier": "private static final", "type": "String", "declarator": "WINDBARB_DEFINITION = \"windbarbs://.*\\\\(.{1,}\\\\)\\\\[.{1,5}\\\\]\\\\??.*\"", "var_name": "WINDBARB_DEFINITION"}, {"original_string": "public static final AffineTransform SOUTHERN_EMISPHERE_FLIP = new AffineTransform2D(\n            AffineTransform.getScaleInstance(-1, 1));", "modifier": "public static final", "type": "AffineTransform", "declarator": "SOUTHERN_EMISPHERE_FLIP = new AffineTransform2D(\n            AffineTransform.getScaleInstance(-1, 1))", "var_name": "SOUTHERN_EMISPHERE_FLIP"}, {"original_string": "private static final Logger LOGGER = org.geotools.util.logging.Logging\n            .getLogger(WindBarbsFactory.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = org.geotools.util.logging.Logging\n            .getLogger(WindBarbsFactory.class)", "var_name": "LOGGER"}, {"original_string": "public static final String WINDBARBS_PREFIX = \"windbarbs://\";", "modifier": "public static final", "type": "String", "declarator": "WINDBARBS_PREFIX = \"windbarbs://\"", "var_name": "WINDBARBS_PREFIX"}, {"original_string": "private static final String DEFAULT_NAME = \"default\";", "modifier": "private static final", "type": "String", "declarator": "DEFAULT_NAME = \"default\"", "var_name": "DEFAULT_NAME"}, {"original_string": "private static Pattern SPEED_PATTERN = Pattern.compile(\"(.*?)\\\\((.{1,})\\\\)(.*)\");", "modifier": "private static", "type": "Pattern", "declarator": "SPEED_PATTERN = Pattern.compile(\"(.*?)\\\\((.{1,})\\\\)(.*)\")", "var_name": "SPEED_PATTERN"}, {"original_string": "private static Pattern WINDBARB_SET_PATTERN = Pattern.compile(\"(.*?)://(.*)\\\\((.*)\");", "modifier": "private static", "type": "Pattern", "declarator": "WINDBARB_SET_PATTERN = Pattern.compile(\"(.*?)://(.*)\\\\((.*)\")", "var_name": "WINDBARB_SET_PATTERN"}, {"original_string": "private static Pattern UNIT_PATTERN = Pattern.compile(\"(.*?)\\\\[(.*)\\\\](.*)\");", "modifier": "private static", "type": "Pattern", "declarator": "UNIT_PATTERN = Pattern.compile(\"(.*?)\\\\[(.*)\\\\](.*)\")", "var_name": "UNIT_PATTERN"}, {"original_string": "private static final SoftValueHashMap<WindBarbDefinition, Map<Integer, Shape>> CACHE;", "modifier": "private static final", "type": "SoftValueHashMap<WindBarbDefinition, Map<Integer, Shape>>", "declarator": "CACHE", "var_name": "CACHE"}], "methods": [{"identifier": "getShape", "parameters": "(Graphics2D graphics, Expression symbolUrl, Feature feature)", "modifiers": "public", "return": "Shape", "signature": "Shape getShape(Graphics2D graphics, Expression symbolUrl, Feature feature)", "full_signature": "public Shape getShape(Graphics2D graphics, Expression symbolUrl, Feature feature)", "class_method_signature": "WindBarbsFactory.getShape(Graphics2D graphics, Expression symbolUrl, Feature feature)", "testcase": false, "constructor": false}, {"identifier": "getWindBarb", "parameters": "(String windBarbName, double speed, String units,\n            Map<String, String> params)", "modifiers": "private", "return": "Shape", "signature": "Shape getWindBarb(String windBarbName, double speed, String units,\n            Map<String, String> params)", "full_signature": "private Shape getWindBarb(String windBarbName, double speed, String units,\n            Map<String, String> params)", "class_method_signature": "WindBarbsFactory.getWindBarb(String windBarbName, double speed, String units,\n            Map<String, String> params)", "testcase": false, "constructor": false}, {"identifier": "getWindBarb", "parameters": "(final String windBarbName, final double speed, final String units)", "modifiers": "private", "return": "Shape", "signature": "Shape getWindBarb(final String windBarbName, final double speed, final String units)", "full_signature": "private Shape getWindBarb(final String windBarbName, final double speed, final String units)", "class_method_signature": "WindBarbsFactory.getWindBarb(final String windBarbName, final double speed, final String units)", "testcase": false, "constructor": false}, {"identifier": "getWindBarbForKnots", "parameters": "(final String windBarbName, final double knots,\n            Map<String, String> params)", "modifiers": "private", "return": "Shape", "signature": "Shape getWindBarbForKnots(final String windBarbName, final double knots,\n            Map<String, String> params)", "full_signature": "private Shape getWindBarbForKnots(final String windBarbName, final double knots,\n            Map<String, String> params)", "class_method_signature": "WindBarbsFactory.getWindBarbForKnots(final String windBarbName, final double knots,\n            Map<String, String> params)", "testcase": false, "constructor": false}, {"identifier": "parseWindBarbsDefinition", "parameters": "(Map<String, String> params)", "modifiers": "private", "return": "WindBarbDefinition", "signature": "WindBarbDefinition parseWindBarbsDefinition(Map<String, String> params)", "full_signature": "private WindBarbDefinition parseWindBarbsDefinition(Map<String, String> params)", "class_method_signature": "WindBarbsFactory.parseWindBarbsDefinition(Map<String, String> params)", "testcase": false, "constructor": false}], "file": "modules/library/render/src/main/java/org/geotools/renderer/windbarbs/WindBarbsFactory.java"}, "focal_method": {"identifier": "getShape", "parameters": "(Graphics2D graphics, Expression symbolUrl, Feature feature)", "modifiers": "public", "return": "Shape", "body": "public Shape getShape(Graphics2D graphics, Expression symbolUrl, Feature feature) {\n\n        // CHECKS\n        // cannot handle a null url\n        if (symbolUrl == null) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(\"Provided null symbol to the WindBarbs Factory\");\n            }\n            return null;\n        }\n        // cannot handle a null feature\n        if (feature == null) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(\"Provided null feature to the WindBarbs Factory\");\n            }\n            return null;\n        }\n\n        //\n        // START PARSING CODE\n        //\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(\"Trying to resolve symbol:\" + symbolUrl.toString());\n        }\n\n        // evaluate string from feature to extract all values\n        final String wellKnownName = symbolUrl.evaluate(feature, String.class);\n        if (wellKnownName == null || wellKnownName.length() <= 0) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(\"Unable to resolve symbol provided to WindBarbs Factory\");\n            }\n            return null;\n        }\n\n        // //\n        //\n        // Basic Syntax\n        //\n        // //\n        if (!wellKnownName.matches(WindBarbsFactory.WINDBARB_DEFINITION)) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(\"Unable to resolve symbol: \" + wellKnownName);\n            }\n            return null;\n        }\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(\"Resolved symbol \" + wellKnownName);\n        }\n\n        // ok from now on we should have a real windbarb, let's lower the log level\n\n        // //\n        //\n        // WindBarbs set\n        //\n        // //\n        String windBarbName = null;\n        Matcher matcher = WINDBARB_SET_PATTERN.matcher(wellKnownName);\n        if (matcher.matches()) {\n            try {\n                windBarbName = matcher.group(2);\n            } catch (Exception e) {\n                if (LOGGER.isLoggable(Level.INFO)) {\n                    LOGGER.log(Level.INFO, \"Unable to parse windbarb set from string: \"\n                            + wellKnownName, e);\n                }\n\n                return null;\n            }\n        }\n        if (windBarbName == null || windBarbName.length() <= 0) {\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.fine(\"Unable to parse windBarbName from string: \" + wellKnownName);\n            }\n            return null;\n        }\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(\"Resolved windBarbName \" + windBarbName);\n        }\n\n        // //\n        //\n        // Looking for speed\n        //\n        // //\n        matcher = SPEED_PATTERN.matcher(wellKnownName);\n        double speed = Double.NaN;\n        if (matcher.matches()) {\n            String speedString = \"\";\n            try {\n                speedString = matcher.group(2);\n                speed = Double.parseDouble(speedString);\n            } catch (Exception e) {\n                if (LOGGER.isLoggable(Level.INFO)) {\n                    LOGGER.log(Level.INFO, \"Unable to parse speed from string: \" + speedString, e);\n                }\n                return null;\n            }\n        } else {\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.fine(\"Unable to parse speed from string: \" + wellKnownName);\n            }\n            return null;\n        }\n\n        // //\n        //\n        // Looking for unit value\n        //\n        // //\n        String uom = null;// no default\n        matcher = UNIT_PATTERN.matcher(wellKnownName);\n        if (matcher.matches()) {\n            uom = matcher.group(2);\n        }\n        if (uom == null || uom.length() <= 0) {\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(\"Unable to parse UoM from \" + wellKnownName);\n            }\n            return null;\n        }\n\n        // so far so good\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(\"WindBarbs name \" + windBarbName + \"with Speed \" + speed + \"[\" + uom + \"]\");\n        }\n\n        // //\n        //\n        // Params\n        //\n        // //\n        int index = wellKnownName.indexOf('?');\n        if (index > 0) {\n            final Map<String, String> params = new HashMap<String, String>();\n            final String kvp = wellKnownName.substring(index + 1);\n            String[] pairs = kvp.split(\"&\");\n            if (pairs != null && pairs.length > 0) {\n                for (String pair : pairs) {\n                    // split\n                    String[] splitPair = pair.split(\"=\");\n                    if (splitPair != null && splitPair.length > 0) {\n                        params.put(splitPair[0].toLowerCase(), splitPair[1]);\n                    } else {\n                        if (LOGGER.isLoggable(Level.FINE)) {\n                            LOGGER.fine(\"Skipping pair \" + pair);\n                        }\n                    }\n                }\n\n                // checks\n                if (!params.isEmpty()) {\n                    return getWindBarb(windBarbName, speed, uom, params);\n                }\n            }\n        } else {\n            // make sure we close with ] and nothing else after\n            if (!wellKnownName.endsWith(\"]\")) {\n                if (LOGGER.isLoggable(Level.INFO)) {\n                    LOGGER.info(\"The provided symbol may be missing a ? before the KVP part.\");\n                }\n                return null;\n            }\n        }\n\n        // //\n        //\n        // Get shape if possible\n        //\n        // //\n        return getWindBarb(windBarbName, speed, uom);\n\n    }", "signature": "Shape getShape(Graphics2D graphics, Expression symbolUrl, Feature feature)", "full_signature": "public Shape getShape(Graphics2D graphics, Expression symbolUrl, Feature feature)", "class_method_signature": "WindBarbsFactory.getShape(Graphics2D graphics, Expression symbolUrl, Feature feature)", "testcase": false, "constructor": false, "invocations": ["isLoggable", "fine", "isLoggable", "fine", "isLoggable", "fine", "toString", "evaluate", "length", "isLoggable", "fine", "matches", "isLoggable", "fine", "isLoggable", "fine", "matcher", "matches", "group", "isLoggable", "log", "length", "isLoggable", "fine", "isLoggable", "fine", "matcher", "matches", "group", "parseDouble", "isLoggable", "log", "isLoggable", "fine", "matcher", "matches", "group", "length", "isLoggable", "info", "isLoggable", "fine", "indexOf", "substring", "split", "split", "put", "toLowerCase", "isLoggable", "fine", "isEmpty", "getWindBarb", "endsWith", "isLoggable", "info", "getWindBarb"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}