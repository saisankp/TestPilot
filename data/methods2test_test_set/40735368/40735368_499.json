{"test_class": {"identifier": "GeometryFunctionsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static WKTReader wktRdr = new WKTReader();", "modifier": "static", "type": "WKTReader", "declarator": "wktRdr = new WKTReader()", "var_name": "wktRdr"}], "file": "modules/unsupported/process-geometry/src/test/java/org/geotools/process/geometry/GeometryFunctionsTest.java"}, "test_case": {"identifier": "testPolygonize", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testPolygonize() throws Exception {\n        Geometry lines = wktRdr.read(\"MULTILINESTRING ((100 100, 200 100), (200 100, 300 100), (100 100, 100 200, 200 200), (200 100, 200 200), (200 200, 300 200, 300 100))\");\n        Geometry output = GeometryFunctions.polygonize(lines);\n        Geometry expectedOutput = wktRdr.read(\"GEOMETRYCOLLECTION (POLYGON ((200 100, 100 100, 100 200, 200 200, 200 100)), POLYGON ((200 100, 200 200, 300 200, 300 100, 200 100)))\");\n        assertTrue(output.norm().equalsExact(expectedOutput.norm()));\n    }", "signature": "void testPolygonize()", "full_signature": "@Test public void testPolygonize()", "class_method_signature": "GeometryFunctionsTest.testPolygonize()", "testcase": true, "constructor": false, "invocations": ["read", "polygonize", "read", "assertTrue", "equalsExact", "norm", "norm"]}, "focal_class": {"identifier": "GeometryFunctions", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "contains", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry, tested to be contained in first geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Contains Test\", description = \"Tests if no points of the second geometry lie in the exterior of the first geometry and at least one point of the interior of second geometry lies in the interior of first geometry.\") @DescribeResult(description = \"True if the first input contains the second input\") static public", "return": "boolean", "signature": "boolean contains(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry, tested to be contained in first geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Contains Test\", description = \"Tests if no points of the second geometry lie in the exterior of the first geometry and at least one point of the interior of second geometry lies in the interior of first geometry.\") @DescribeResult(description = \"True if the first input contains the second input\") static public boolean contains(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry, tested to be contained in first geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.contains(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry, tested to be contained in first geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "isEmpty", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Empty Test\", description = \"Tests if a geometry contains no vertices.\") @DescribeResult(description = \"True if the input is empty\") static public", "return": "boolean", "signature": "boolean isEmpty(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Empty Test\", description = \"Tests if a geometry contains no vertices.\") @DescribeResult(description = \"True if the input is empty\") static public boolean isEmpty(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.isEmpty(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "length", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Length\", description = \"Returns the total length of all line segments in a geometry. Measurement is given in the source units, so geographic coordinates are not recommended.\") @DescribeResult(description = \"Total perimeter of the geometry\") static public", "return": "double", "signature": "double length(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Length\", description = \"Returns the total length of all line segments in a geometry. Measurement is given in the source units, so geographic coordinates are not recommended.\") @DescribeResult(description = \"Total perimeter of the geometry\") static public double length(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.length(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "intersects", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Intersects Test\", description = \"Tests if two geometries intersect.\") @DescribeResult(description = \"True if the inputs intersect\") static public", "return": "boolean", "signature": "boolean intersects(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Intersects Test\", description = \"Tests if two geometries intersect.\") @DescribeResult(description = \"True if the inputs intersect\") static public boolean intersects(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.intersects(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "isValid", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Valid Test\", description = \"Tests if a geometry is topologically valid.\") @DescribeResult(description = \"True if the input is valid\") static public", "return": "boolean", "signature": "boolean isValid(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Valid Test\", description = \"Tests if a geometry is topologically valid.\") @DescribeResult(description = \"True if the input is valid\") static public boolean isValid(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.isValid(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "geometryType", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Geometry Type\", description = \"Returns the name of a geometry's type. Values are one of POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION.\") @DescribeResult(description = \"The name of the geometry type\") static public", "return": "String", "signature": "String geometryType(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Geometry Type\", description = \"Returns the name of a geometry's type. Values are one of POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION.\") @DescribeResult(description = \"The name of the geometry type\") static public String geometryType(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.geometryType(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "numPoints", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Number of Points\", description = \"Returns the number of vertices in a given geometry.\") @DescribeResult(description = \"Total number of vertices\") static public", "return": "int", "signature": "int numPoints(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Number of Points\", description = \"Returns the number of vertices in a given geometry.\") @DescribeResult(description = \"Total number of vertices\") static public int numPoints(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.numPoints(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "isSimple", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Simple Test\", description = \"Tests if a geometry is topologically simple. Points, polygons, closed line strings, and linear rings are always simple. Other geometries are considered simple if no two points are identical.\") @DescribeResult(description = \"True if the input is simple\") static public", "return": "boolean", "signature": "boolean isSimple(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Simple Test\", description = \"Tests if a geometry is topologically simple. Points, polygons, closed line strings, and linear rings are always simple. Other geometries are considered simple if no two points are identical.\") @DescribeResult(description = \"True if the input is simple\") static public boolean isSimple(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.isSimple(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "distance", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Distance\", description = \"Returns the minimum distance between two geometries. Measurement is given in the input units, so geographic coordinates are not recommended.\") @DescribeResult(description = \"Distance between the two input geometries\") static public", "return": "double", "signature": "double distance(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Distance\", description = \"Returns the minimum distance between two geometries. Measurement is given in the input units, so geographic coordinates are not recommended.\") @DescribeResult(description = \"Distance between the two input geometries\") static public double distance(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.distance(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "isWithinDistance", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b,\n            @DescribeParameter(name = \"distance\", description = \"Distance tolerance, in units of the input geometry\") double distance)", "modifiers": "@DescribeProcess(title = \"Within Distance Test\", description = \"Tests if the minimum distance between two geometries is less than a tolerance value.\") @DescribeResult(description = \"True if the inputs are within the specified distance\") static public", "return": "boolean", "signature": "boolean isWithinDistance(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b,\n            @DescribeParameter(name = \"distance\", description = \"Distance tolerance, in units of the input geometry\") double distance)", "full_signature": "@DescribeProcess(title = \"Within Distance Test\", description = \"Tests if the minimum distance between two geometries is less than a tolerance value.\") @DescribeResult(description = \"True if the inputs are within the specified distance\") static public boolean isWithinDistance(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b,\n            @DescribeParameter(name = \"distance\", description = \"Distance tolerance, in units of the input geometry\") double distance)", "class_method_signature": "GeometryFunctions.isWithinDistance(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b,\n            @DescribeParameter(name = \"distance\", description = \"Distance tolerance, in units of the input geometry\") double distance)", "testcase": false, "constructor": false}, {"identifier": "area", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Area\", description = \"Returns the area of a geometry, in the units of the geometry. Assumes a Cartesian plane, so this process is only recommended for non-geographic CRSes.\") @DescribeResult(description = \"Area of the input geometry\") static public", "return": "double", "signature": "double area(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Area\", description = \"Returns the area of a geometry, in the units of the geometry. Assumes a Cartesian plane, so this process is only recommended for non-geographic CRSes.\") @DescribeResult(description = \"Area of the input geometry\") static public double area(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.area(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "centroid", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Centroid\", description = \"Returns the geometric centroid of a geometry. Output is a single point. The centroid point may be located outside the geometry.\") @DescribeResult(description = \"Centroid of the input geometry\") static public", "return": "Geometry", "signature": "Geometry centroid(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Centroid\", description = \"Returns the geometric centroid of a geometry. Output is a single point. The centroid point may be located outside the geometry.\") @DescribeResult(description = \"Centroid of the input geometry\") static public Geometry centroid(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.centroid(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "interiorPoint", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Interior Point\", description = \"Returns a point that lies inside a geometry if possible, or that lies on its boundary.\") @DescribeResult(description = \"Interior point\") static public", "return": "Geometry", "signature": "Geometry interiorPoint(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Interior Point\", description = \"Returns a point that lies inside a geometry if possible, or that lies on its boundary.\") @DescribeResult(description = \"Interior point\") static public Geometry interiorPoint(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.interiorPoint(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "dimension", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Dimension\", description = \"Returns the largest dimension of a geometry or geometry collection: 0 for point, 1 for line, 2 for polygon.\") @DescribeResult(description = \"Dimension of the input geometry\") static public", "return": "int", "signature": "int dimension(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Dimension\", description = \"Returns the largest dimension of a geometry or geometry collection: 0 for point, 1 for line, 2 for polygon.\") @DescribeResult(description = \"Dimension of the input geometry\") static public int dimension(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.dimension(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "boundary", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Boundary\", description = \"Returns a geometry boundary. For polygons, returns a linear ring or multi-linestring equal to the boundary of the polygon(s). For linestrings, returns a multipoint equal to the endpoints of the linestring. For points, returns an empty geometry collection.\") @DescribeResult(description = \"Boundary of the input geometry\") static public", "return": "Geometry", "signature": "Geometry boundary(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Boundary\", description = \"Returns a geometry boundary. For polygons, returns a linear ring or multi-linestring equal to the boundary of the polygon(s). For linestrings, returns a multipoint equal to the endpoints of the linestring. For points, returns an empty geometry collection.\") @DescribeResult(description = \"Boundary of the input geometry\") static public Geometry boundary(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.boundary(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "envelope", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Envelope\", description = \"Returns the smallest bounding box polygon that contains a geometry. For a point geometry, returns the same point.\") @DescribeResult(description = \"Envelope of the input geometry\") static public", "return": "Geometry", "signature": "Geometry envelope(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Envelope\", description = \"Returns the smallest bounding box polygon that contains a geometry. For a point geometry, returns the same point.\") @DescribeResult(description = \"Envelope of the input geometry\") static public Geometry envelope(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.envelope(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "disjoint", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Disjoint Test\", description = \"Tests if two geometries do not have any points in common.\") @DescribeResult(description = \"True if the inputs are disjoint\") static public", "return": "boolean", "signature": "boolean disjoint(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Disjoint Test\", description = \"Tests if two geometries do not have any points in common.\") @DescribeResult(description = \"True if the inputs are disjoint\") static public boolean disjoint(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.disjoint(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "touches", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Touches Test\", description = \"Tests if two geometries have at least one boundary point in common, but share no interior points.\") @DescribeResult(description = \"True if the inputs touch\") static public", "return": "boolean", "signature": "boolean touches(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Touches Test\", description = \"Tests if two geometries have at least one boundary point in common, but share no interior points.\") @DescribeResult(description = \"True if the inputs touch\") static public boolean touches(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.touches(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "crosses", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Crosses Test\", description = \"Tests if two geometries have some, but not all, interior points in common.\") @DescribeResult(description = \"True if the inputs cross\") static public", "return": "boolean", "signature": "boolean crosses(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Crosses Test\", description = \"Tests if two geometries have some, but not all, interior points in common.\") @DescribeResult(description = \"True if the inputs cross\") static public boolean crosses(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.crosses(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "within", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Within Test\", description = \"Tests if the first geometry is contained in the second geometry.\") @DescribeResult(description = \"True if the first input is within the second input\") static public", "return": "boolean", "signature": "boolean within(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Within Test\", description = \"Tests if the first geometry is contained in the second geometry.\") @DescribeResult(description = \"True if the first input is within the second input\") static public boolean within(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.within(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "overlaps", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Overlaps Test\", description = \"Tests if two geometries share some but not all interior points. Points or lines will always return False.\") @DescribeResult(description = \"True if the inputs overlap\") static public", "return": "boolean", "signature": "boolean overlaps(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Overlaps Test\", description = \"Tests if two geometries share some but not all interior points. Points or lines will always return False.\") @DescribeResult(description = \"True if the inputs overlap\") static public boolean overlaps(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.overlaps(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "relatePattern", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"First input geometry\") Geometry b,\n            @DescribeParameter(name = \"Relate pattern\", description = \"Intersection matrix pattern\") String pattern)", "modifiers": "@DescribeProcess(title = \"Relate Test\", description = \"Tests if the spatial relationship between two geometries matches the given DE-9IM intersection matrix pattern. The pattern is given in the form [II][IB][IE][BI][BB][BE][EI][EB][EE] where I=interior, B=boundary, and E=exterior. Pattern symbols can be 2, 1, 0, F or *.\") @DescribeResult(description = \"True if the inputs have the given relationship\") static public", "return": "boolean", "signature": "boolean relatePattern(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"First input geometry\") Geometry b,\n            @DescribeParameter(name = \"Relate pattern\", description = \"Intersection matrix pattern\") String pattern)", "full_signature": "@DescribeProcess(title = \"Relate Test\", description = \"Tests if the spatial relationship between two geometries matches the given DE-9IM intersection matrix pattern. The pattern is given in the form [II][IB][IE][BI][BB][BE][EI][EB][EE] where I=interior, B=boundary, and E=exterior. Pattern symbols can be 2, 1, 0, F or *.\") @DescribeResult(description = \"True if the inputs have the given relationship\") static public boolean relatePattern(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"First input geometry\") Geometry b,\n            @DescribeParameter(name = \"Relate pattern\", description = \"Intersection matrix pattern\") String pattern)", "class_method_signature": "GeometryFunctions.relatePattern(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"First input geometry\") Geometry b,\n            @DescribeParameter(name = \"Relate pattern\", description = \"Intersection matrix pattern\") String pattern)", "testcase": false, "constructor": false}, {"identifier": "relate", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Relate Matrix String\", description = \"Returns the DE-9IM intersection matrix string for the spatial relationship between the input geometries. The matrix string is in the form [II][IB][IE][BI][BB][BE][EI][EB][EE] where I=interior, B=boundary, and E=exterior. Matrix symbols are 2, 1, 0 or F.\") @DescribeResult(description = \"Intersection matrix string\") static public", "return": "String", "signature": "String relate(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Relate Matrix String\", description = \"Returns the DE-9IM intersection matrix string for the spatial relationship between the input geometries. The matrix string is in the form [II][IB][IE][BI][BB][BE][EI][EB][EE] where I=interior, B=boundary, and E=exterior. Matrix symbols are 2, 1, 0 or F.\") @DescribeResult(description = \"Intersection matrix string\") static public String relate(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.relate(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "buffer", "parameters": "(\n            @DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description = \"Distance to buffer the input geometry, in the units of the geometry\") double distance,\n            @DescribeParameter(name = \"quadrantSegments\", description = \"Number determining the style and smoothness of buffer corners. Positive numbers create round corners with that number of segments per quarter-circle, 0 creates flat corners.\", min = 0) Integer quadrantSegments,\n            @DescribeParameter(name = \"capStyle\", description = \"Style for the buffer end caps. Values are: Round - rounded ends (default), Flat - flat ends; Square - square ends.\", min = 0) BufferCapStyle capStyle)", "modifiers": "@DescribeProcess(title = \"Buffer\", description = \"Returns a polygonal geometry representing the input geometry enlarged by a given distance around its exterior.\") @DescribeResult(description = \"Buffered geometry\") static public", "return": "Geometry", "signature": "Geometry buffer(\n            @DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description = \"Distance to buffer the input geometry, in the units of the geometry\") double distance,\n            @DescribeParameter(name = \"quadrantSegments\", description = \"Number determining the style and smoothness of buffer corners. Positive numbers create round corners with that number of segments per quarter-circle, 0 creates flat corners.\", min = 0) Integer quadrantSegments,\n            @DescribeParameter(name = \"capStyle\", description = \"Style for the buffer end caps. Values are: Round - rounded ends (default), Flat - flat ends; Square - square ends.\", min = 0) BufferCapStyle capStyle)", "full_signature": "@DescribeProcess(title = \"Buffer\", description = \"Returns a polygonal geometry representing the input geometry enlarged by a given distance around its exterior.\") @DescribeResult(description = \"Buffered geometry\") static public Geometry buffer(\n            @DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description = \"Distance to buffer the input geometry, in the units of the geometry\") double distance,\n            @DescribeParameter(name = \"quadrantSegments\", description = \"Number determining the style and smoothness of buffer corners. Positive numbers create round corners with that number of segments per quarter-circle, 0 creates flat corners.\", min = 0) Integer quadrantSegments,\n            @DescribeParameter(name = \"capStyle\", description = \"Style for the buffer end caps. Values are: Round - rounded ends (default), Flat - flat ends; Square - square ends.\", min = 0) BufferCapStyle capStyle)", "class_method_signature": "GeometryFunctions.buffer(\n            @DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description = \"Distance to buffer the input geometry, in the units of the geometry\") double distance,\n            @DescribeParameter(name = \"quadrantSegments\", description = \"Number determining the style and smoothness of buffer corners. Positive numbers create round corners with that number of segments per quarter-circle, 0 creates flat corners.\", min = 0) Integer quadrantSegments,\n            @DescribeParameter(name = \"capStyle\", description = \"Style for the buffer end caps. Values are: Round - rounded ends (default), Flat - flat ends; Square - square ends.\", min = 0) BufferCapStyle capStyle)", "testcase": false, "constructor": false}, {"identifier": "convexHull", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Convex Hull\", description = \"Returns the smallest convex polygon that contains the entire input geometry.\") @DescribeResult(description = \"Convex hull of input geometry\") static public", "return": "Geometry", "signature": "Geometry convexHull(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Convex Hull\", description = \"Returns the smallest convex polygon that contains the entire input geometry.\") @DescribeResult(description = \"Convex hull of input geometry\") static public Geometry convexHull(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "class_method_signature": "GeometryFunctions.convexHull(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "intersection", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Intersection\", description = \"Returns a geometry representing the points that two geometries have in common. The result may be a heterogeneous geometry collection. If no intersection, returns an empty geometry.\") @DescribeResult(description = \"Intersection of geometries\") static public", "return": "Geometry", "signature": "Geometry intersection(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Intersection\", description = \"Returns a geometry representing the points that two geometries have in common. The result may be a heterogeneous geometry collection. If no intersection, returns an empty geometry.\") @DescribeResult(description = \"Intersection of geometries\") static public Geometry intersection(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.intersection(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "union", "parameters": "(\n            @DescribeParameter(name = \"geom\", description = \"Input geometries (minimum 2)\", min = 2) Geometry... geoms)", "modifiers": "@DescribeProcess(title = \"Union\", description = \"Returns a geometry representing all points contained in any of the geometries in a geometry collection.\") @DescribeResult(description = \"Union of input geometries\") static public", "return": "Geometry", "signature": "Geometry union(\n            @DescribeParameter(name = \"geom\", description = \"Input geometries (minimum 2)\", min = 2) Geometry... geoms)", "full_signature": "@DescribeProcess(title = \"Union\", description = \"Returns a geometry representing all points contained in any of the geometries in a geometry collection.\") @DescribeResult(description = \"Union of input geometries\") static public Geometry union(\n            @DescribeParameter(name = \"geom\", description = \"Input geometries (minimum 2)\", min = 2) Geometry... geoms)", "class_method_signature": "GeometryFunctions.union(\n            @DescribeParameter(name = \"geom\", description = \"Input geometries (minimum 2)\", min = 2) Geometry... geoms)", "testcase": false, "constructor": false}, {"identifier": "difference", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Difference\", description = \"Returns a geometry representing the points that are contained in a geometry but not contained in a second geometry. The result may be a heterogeneous geometry collection.\") @DescribeResult(description = \"Geometry representing the difference of the input geometries\") static public", "return": "Geometry", "signature": "Geometry difference(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Difference\", description = \"Returns a geometry representing the points that are contained in a geometry but not contained in a second geometry. The result may be a heterogeneous geometry collection.\") @DescribeResult(description = \"Geometry representing the difference of the input geometries\") static public Geometry difference(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.difference(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "symDifference", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Symmetric Difference\", description = \"Returns a geometry representing the points contained in either one of two geometries but not in both. The result may be a heterogeneous geometry collection.\") @DescribeResult(description = \"Symmetric difference of the two geometries\") static public", "return": "Geometry", "signature": "Geometry symDifference(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Symmetric Difference\", description = \"Returns a geometry representing the points contained in either one of two geometries but not in both. The result may be a heterogeneous geometry collection.\") @DescribeResult(description = \"Symmetric difference of the two geometries\") static public Geometry symDifference(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.symDifference(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "equalsExactTolerance", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b, @DescribeParameter(name = \"tolerance\", description = \"Tolerance distance for vertex equality test\") double tolerance)", "modifiers": "@DescribeProcess(title = \"Exactly Equal Test with Tolerance\", description = \"Tests if two geometries are identical on a vertex-by-vertex basis, up to a vertex distance tolerance.\") @DescribeResult(description = \"True if the geometries are vertex-identical within tolerance\") static public", "return": "boolean", "signature": "boolean equalsExactTolerance(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b, @DescribeParameter(name = \"tolerance\", description = \"Tolerance distance for vertex equality test\") double tolerance)", "full_signature": "@DescribeProcess(title = \"Exactly Equal Test with Tolerance\", description = \"Tests if two geometries are identical on a vertex-by-vertex basis, up to a vertex distance tolerance.\") @DescribeResult(description = \"True if the geometries are vertex-identical within tolerance\") static public boolean equalsExactTolerance(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b, @DescribeParameter(name = \"tolerance\", description = \"Tolerance distance for vertex equality test\") double tolerance)", "class_method_signature": "GeometryFunctions.equalsExactTolerance(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b, @DescribeParameter(name = \"tolerance\", description = \"Tolerance distance for vertex equality test\") double tolerance)", "testcase": false, "constructor": false}, {"identifier": "equalsExact", "parameters": "(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "modifiers": "@DescribeProcess(title = \"Exactly Equal Test\", description = \"Tests if two geometries are identical on a vertex-by-vertex basis.\") @DescribeResult(description = \"True if the geometries are vertex-identical\") static public", "return": "boolean", "signature": "boolean equalsExact(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "full_signature": "@DescribeProcess(title = \"Exactly Equal Test\", description = \"Tests if two geometries are identical on a vertex-by-vertex basis.\") @DescribeResult(description = \"True if the geometries are vertex-identical\") static public boolean equalsExact(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "class_method_signature": "GeometryFunctions.equalsExact(@DescribeParameter(name = \"a\", description = \"First input geometry\") Geometry a,\n            @DescribeParameter(name = \"b\", description = \"Second input geometry\") Geometry b)", "testcase": false, "constructor": false}, {"identifier": "numGeometries", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry collection)", "modifiers": "@DescribeProcess(title = \"Geometry Count\", description = \"Returns the total number of elements in a geometry collection. If not a geometry collection, returns 1. If empty, returns 0.\") @DescribeResult(description = \"Total number of geometries\") static public", "return": "int", "signature": "int numGeometries(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry collection)", "full_signature": "@DescribeProcess(title = \"Geometry Count\", description = \"Returns the total number of elements in a geometry collection. If not a geometry collection, returns 1. If empty, returns 0.\") @DescribeResult(description = \"Total number of geometries\") static public int numGeometries(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry collection)", "class_method_signature": "GeometryFunctions.numGeometries(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry collection)", "testcase": false, "constructor": false}, {"identifier": "getGeometryN", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") GeometryCollection collection, @DescribeParameter(name = \"index\", description = \"Index of geometry element (0 is first)\") int index)", "modifiers": "@DescribeProcess(title = \"Nth Geometry\", description = \"Returns the geometry element at a given index in a geometry collection. Indexing starts at 0.\") @DescribeResult(description = \"Geometry element from the geometry collection\") static public", "return": "Geometry", "signature": "Geometry getGeometryN(@DescribeParameter(name = \"geom\", description = \"Input geometry\") GeometryCollection collection, @DescribeParameter(name = \"index\", description = \"Index of geometry element (0 is first)\") int index)", "full_signature": "@DescribeProcess(title = \"Nth Geometry\", description = \"Returns the geometry element at a given index in a geometry collection. Indexing starts at 0.\") @DescribeResult(description = \"Geometry element from the geometry collection\") static public Geometry getGeometryN(@DescribeParameter(name = \"geom\", description = \"Input geometry\") GeometryCollection collection, @DescribeParameter(name = \"index\", description = \"Index of geometry element (0 is first)\") int index)", "class_method_signature": "GeometryFunctions.getGeometryN(@DescribeParameter(name = \"geom\", description = \"Input geometry\") GeometryCollection collection, @DescribeParameter(name = \"index\", description = \"Index of geometry element (0 is first)\") int index)", "testcase": false, "constructor": false}, {"identifier": "getX", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input point\") Point point)", "modifiers": "@DescribeProcess(title = \"Get X Ordinate\", description = \"Returns the X value (first ordinate) for point geometries. For other geometry types returns the X value of the centroid.\") @DescribeResult(description = \"X value of point\") static public", "return": "double", "signature": "double getX(@DescribeParameter(name = \"geom\", description = \"Input point\") Point point)", "full_signature": "@DescribeProcess(title = \"Get X Ordinate\", description = \"Returns the X value (first ordinate) for point geometries. For other geometry types returns the X value of the centroid.\") @DescribeResult(description = \"X value of point\") static public double getX(@DescribeParameter(name = \"geom\", description = \"Input point\") Point point)", "class_method_signature": "GeometryFunctions.getX(@DescribeParameter(name = \"geom\", description = \"Input point\") Point point)", "testcase": false, "constructor": false}, {"identifier": "getY", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input point\") Point point)", "modifiers": "@DescribeProcess(title = \"Get Y Ordinate\", description = \"Returns the Y value (second ordinate) for point geometries. For other geometry types returns the Y value of the centroid.\") @DescribeResult(description = \"Y value of point\") static public", "return": "double", "signature": "double getY(@DescribeParameter(name = \"geom\", description = \"Input point\") Point point)", "full_signature": "@DescribeProcess(title = \"Get Y Ordinate\", description = \"Returns the Y value (second ordinate) for point geometries. For other geometry types returns the Y value of the centroid.\") @DescribeResult(description = \"Y value of point\") static public double getY(@DescribeParameter(name = \"geom\", description = \"Input point\") Point point)", "class_method_signature": "GeometryFunctions.getY(@DescribeParameter(name = \"geom\", description = \"Input point\") Point point)", "testcase": false, "constructor": false}, {"identifier": "isClosed", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line)", "modifiers": "@DescribeProcess(title = \"Closed Test\", description = \"Tests if the initial vertex equals the final vertex in a linear geometry. Points and polygons always return True.\") @DescribeResult(description = \"True if the input is closed\") static public", "return": "boolean", "signature": "boolean isClosed(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line)", "full_signature": "@DescribeProcess(title = \"Closed Test\", description = \"Tests if the initial vertex equals the final vertex in a linear geometry. Points and polygons always return True.\") @DescribeResult(description = \"True if the input is closed\") static public boolean isClosed(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line)", "class_method_signature": "GeometryFunctions.isClosed(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line)", "testcase": false, "constructor": false}, {"identifier": "pointN", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line, @DescribeParameter(name = \"index\", description = \"Index of vertex (0 is first)\") int index)", "modifiers": "@DescribeProcess(title = \"Nth Point\", description = \"Returns a point geometry equal to the Nth vertex in a geometry as determined by a given index. First vertex has index 0.\") @DescribeResult(description = \"Vertex as point geometry\") static public", "return": "Point", "signature": "Point pointN(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line, @DescribeParameter(name = \"index\", description = \"Index of vertex (0 is first)\") int index)", "full_signature": "@DescribeProcess(title = \"Nth Point\", description = \"Returns a point geometry equal to the Nth vertex in a geometry as determined by a given index. First vertex has index 0.\") @DescribeResult(description = \"Vertex as point geometry\") static public Point pointN(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line, @DescribeParameter(name = \"index\", description = \"Index of vertex (0 is first)\") int index)", "class_method_signature": "GeometryFunctions.pointN(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line, @DescribeParameter(name = \"index\", description = \"Index of vertex (0 is first)\") int index)", "testcase": false, "constructor": false}, {"identifier": "startPoint", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input line\") LineString line)", "modifiers": "@DescribeProcess(title = \"Start Point\", description = \"Returns a point geometry equal to the first vertex of a LineString.\") @DescribeResult(description = \"First vertex as point geometry\") static public", "return": "Point", "signature": "Point startPoint(@DescribeParameter(name = \"geom\", description = \"Input line\") LineString line)", "full_signature": "@DescribeProcess(title = \"Start Point\", description = \"Returns a point geometry equal to the first vertex of a LineString.\") @DescribeResult(description = \"First vertex as point geometry\") static public Point startPoint(@DescribeParameter(name = \"geom\", description = \"Input line\") LineString line)", "class_method_signature": "GeometryFunctions.startPoint(@DescribeParameter(name = \"geom\", description = \"Input line\") LineString line)", "testcase": false, "constructor": false}, {"identifier": "endPoint", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input line\") LineString line)", "modifiers": "@DescribeProcess(title = \"End Point\", description = \"Returns a point geometry equal to the final vertex of a LineString.\") @DescribeResult(description = \"Final vertex as point geometry\") static public", "return": "Point", "signature": "Point endPoint(@DescribeParameter(name = \"geom\", description = \"Input line\") LineString line)", "full_signature": "@DescribeProcess(title = \"End Point\", description = \"Returns a point geometry equal to the final vertex of a LineString.\") @DescribeResult(description = \"Final vertex as point geometry\") static public Point endPoint(@DescribeParameter(name = \"geom\", description = \"Input line\") LineString line)", "class_method_signature": "GeometryFunctions.endPoint(@DescribeParameter(name = \"geom\", description = \"Input line\") LineString line)", "testcase": false, "constructor": false}, {"identifier": "isRing", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line)", "modifiers": "@DescribeProcess(title = \"Ring Test\", description = \"Tests if a geometry is both closed and simple.\") @DescribeResult(description = \"True if the input is a ring\") static public", "return": "boolean", "signature": "boolean isRing(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line)", "full_signature": "@DescribeProcess(title = \"Ring Test\", description = \"Tests if a geometry is both closed and simple.\") @DescribeResult(description = \"True if the input is a ring\") static public boolean isRing(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line)", "class_method_signature": "GeometryFunctions.isRing(@DescribeParameter(name = \"geom\", description = \"Input geometry\") LineString line)", "testcase": false, "constructor": false}, {"identifier": "exteriorRing", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Polygon polygon)", "modifiers": "@DescribeProcess(title = \"Exterior Ring\", description = \"Returns the exterior ring of a polygonal geometry.\") @DescribeResult(description = \"Exterior ring of geometry\") static public", "return": "Geometry", "signature": "Geometry exteriorRing(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Polygon polygon)", "full_signature": "@DescribeProcess(title = \"Exterior Ring\", description = \"Returns the exterior ring of a polygonal geometry.\") @DescribeResult(description = \"Exterior ring of geometry\") static public Geometry exteriorRing(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Polygon polygon)", "class_method_signature": "GeometryFunctions.exteriorRing(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Polygon polygon)", "testcase": false, "constructor": false}, {"identifier": "numInteriorRing", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Polygon polygon)", "modifiers": "@DescribeProcess(title = \"Interior Ring Count\", description = \"Returns the total number of interior rings in a polygonal geometry. Points and lines return 0.\") @DescribeResult(description = \"Total number of interior rings\") static public", "return": "int", "signature": "int numInteriorRing(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Polygon polygon)", "full_signature": "@DescribeProcess(title = \"Interior Ring Count\", description = \"Returns the total number of interior rings in a polygonal geometry. Points and lines return 0.\") @DescribeResult(description = \"Total number of interior rings\") static public int numInteriorRing(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Polygon polygon)", "class_method_signature": "GeometryFunctions.numInteriorRing(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Polygon polygon)", "testcase": false, "constructor": false}, {"identifier": "interiorRingN", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input polygon with interior ring\") Polygon polygon, @DescribeParameter(name = \"index\", description = \"Index of interior ring (0 is first)\") int index)", "modifiers": "@DescribeProcess(title = \"Nth Interior Ring\", description = \"Returns a linear ring from a polygon containing interior rings (holes) determined by a given index. First interior ring has index 0. If no interior rings, returns null.\") @DescribeResult(description = \"Interior ring as a linear ring\") static public", "return": "Geometry", "signature": "Geometry interiorRingN(@DescribeParameter(name = \"geom\", description = \"Input polygon with interior ring\") Polygon polygon, @DescribeParameter(name = \"index\", description = \"Index of interior ring (0 is first)\") int index)", "full_signature": "@DescribeProcess(title = \"Nth Interior Ring\", description = \"Returns a linear ring from a polygon containing interior rings (holes) determined by a given index. First interior ring has index 0. If no interior rings, returns null.\") @DescribeResult(description = \"Interior ring as a linear ring\") static public Geometry interiorRingN(@DescribeParameter(name = \"geom\", description = \"Input polygon with interior ring\") Polygon polygon, @DescribeParameter(name = \"index\", description = \"Index of interior ring (0 is first)\") int index)", "class_method_signature": "GeometryFunctions.interiorRingN(@DescribeParameter(name = \"geom\", description = \"Input polygon with interior ring\") Polygon polygon, @DescribeParameter(name = \"index\", description = \"Index of interior ring (0 is first)\") int index)", "testcase": false, "constructor": false}, {"identifier": "simplify", "parameters": "(@DescribeParameter(name = \"geom\", description=\"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description=\"Simplification distance tolerance, in units of the input geometry\") double distance)", "modifiers": "@DescribeProcess(title = \"Simplify\", description = \"Returns a geometry that has been simplified (reduced in vertices) according to the Douglas-Peucker algorithm.\") @DescribeResult(description = \"Simplified geometry\") static public", "return": "Geometry", "signature": "Geometry simplify(@DescribeParameter(name = \"geom\", description=\"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description=\"Simplification distance tolerance, in units of the input geometry\") double distance)", "full_signature": "@DescribeProcess(title = \"Simplify\", description = \"Returns a geometry that has been simplified (reduced in vertices) according to the Douglas-Peucker algorithm.\") @DescribeResult(description = \"Simplified geometry\") static public Geometry simplify(@DescribeParameter(name = \"geom\", description=\"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description=\"Simplification distance tolerance, in units of the input geometry\") double distance)", "class_method_signature": "GeometryFunctions.simplify(@DescribeParameter(name = \"geom\", description=\"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description=\"Simplification distance tolerance, in units of the input geometry\") double distance)", "testcase": false, "constructor": false}, {"identifier": "densify", "parameters": "(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description = \"The maximum segment length in the result, in the units of the geometry\") double distance)", "modifiers": "@DescribeProcess(title = \"Densify\", description = \"Returns a spatially equivalent geometry with vertices added to ensure line segments are no longer than a given distance.\") @DescribeResult(description = \"Densified geometry\") static public", "return": "Geometry", "signature": "Geometry densify(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description = \"The maximum segment length in the result, in the units of the geometry\") double distance)", "full_signature": "@DescribeProcess(title = \"Densify\", description = \"Returns a spatially equivalent geometry with vertices added to ensure line segments are no longer than a given distance.\") @DescribeResult(description = \"Densified geometry\") static public Geometry densify(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description = \"The maximum segment length in the result, in the units of the geometry\") double distance)", "class_method_signature": "GeometryFunctions.densify(@DescribeParameter(name = \"geom\", description = \"Input geometry\") Geometry geom,\n            @DescribeParameter(name = \"distance\", description = \"The maximum segment length in the result, in the units of the geometry\") double distance)", "testcase": false, "constructor": false}, {"identifier": "polygonize", "parameters": "(\n            @DescribeParameter(name = \"geom\", description = \"Linework to polygonize\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Polygonize\", description = \"Creates a set of polygons from linestrings delineating them. The linestrings must be corrctly noded (i.e. touch only at endpoints).\") @DescribeResult(description = \"The collection of created polygons\") static public", "return": "Geometry", "signature": "Geometry polygonize(\n            @DescribeParameter(name = \"geom\", description = \"Linework to polygonize\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Polygonize\", description = \"Creates a set of polygons from linestrings delineating them. The linestrings must be corrctly noded (i.e. touch only at endpoints).\") @DescribeResult(description = \"The collection of created polygons\") static public Geometry polygonize(\n            @DescribeParameter(name = \"geom\", description = \"Linework to polygonize\") Geometry geom)", "class_method_signature": "GeometryFunctions.polygonize(\n            @DescribeParameter(name = \"geom\", description = \"Linework to polygonize\") Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "splitPolygon", "parameters": "(\n            @DescribeParameter(name = \"polygon\", description = \"Polygon to split\") Geometry polygon,\n            @DescribeParameter(name = \"line\", description = \"Linestring to split by\") LineString line)", "modifiers": "@DescribeProcess(title = \"Split Polygon\", description = \"Splits a polygon by a linestring\") @DescribeResult(description = \"The collection of split polygons\") static public", "return": "Geometry", "signature": "Geometry splitPolygon(\n            @DescribeParameter(name = \"polygon\", description = \"Polygon to split\") Geometry polygon,\n            @DescribeParameter(name = \"line\", description = \"Linestring to split by\") LineString line)", "full_signature": "@DescribeProcess(title = \"Split Polygon\", description = \"Splits a polygon by a linestring\") @DescribeResult(description = \"The collection of split polygons\") static public Geometry splitPolygon(\n            @DescribeParameter(name = \"polygon\", description = \"Polygon to split\") Geometry polygon,\n            @DescribeParameter(name = \"line\", description = \"Linestring to split by\") LineString line)", "class_method_signature": "GeometryFunctions.splitPolygon(\n            @DescribeParameter(name = \"polygon\", description = \"Polygon to split\") Geometry polygon,\n            @DescribeParameter(name = \"line\", description = \"Linestring to split by\") LineString line)", "testcase": false, "constructor": false}, {"identifier": "reproject", "parameters": "(\n        @DescribeParameter(name = \"geometry\", description = \"Input geometry\") Geometry geometry,\n        @DescribeParameter(name = \"sourceCRS\", min = 0, description = \"Coordinate reference system of input geometry\") CoordinateReferenceSystem sourceCRS,\n        @DescribeParameter(name = \"targetCRS\", min = 0, description = \"Target coordinate reference system to use for reprojection\") CoordinateReferenceSystem targetCRS)", "modifiers": "@DescribeProcess(title = \"Reproject Geometry\", description = \"Reprojects a given geometry into a supplied coordinate reference system.\") @DescribeResult(name = \"result\", description = \"Reprojected geometry\") static public", "return": "Geometry", "signature": "Geometry reproject(\n        @DescribeParameter(name = \"geometry\", description = \"Input geometry\") Geometry geometry,\n        @DescribeParameter(name = \"sourceCRS\", min = 0, description = \"Coordinate reference system of input geometry\") CoordinateReferenceSystem sourceCRS,\n        @DescribeParameter(name = \"targetCRS\", min = 0, description = \"Target coordinate reference system to use for reprojection\") CoordinateReferenceSystem targetCRS)", "full_signature": "@DescribeProcess(title = \"Reproject Geometry\", description = \"Reprojects a given geometry into a supplied coordinate reference system.\") @DescribeResult(name = \"result\", description = \"Reprojected geometry\") static public Geometry reproject(\n        @DescribeParameter(name = \"geometry\", description = \"Input geometry\") Geometry geometry,\n        @DescribeParameter(name = \"sourceCRS\", min = 0, description = \"Coordinate reference system of input geometry\") CoordinateReferenceSystem sourceCRS,\n        @DescribeParameter(name = \"targetCRS\", min = 0, description = \"Target coordinate reference system to use for reprojection\") CoordinateReferenceSystem targetCRS)", "class_method_signature": "GeometryFunctions.reproject(\n        @DescribeParameter(name = \"geometry\", description = \"Input geometry\") Geometry geometry,\n        @DescribeParameter(name = \"sourceCRS\", min = 0, description = \"Coordinate reference system of input geometry\") CoordinateReferenceSystem sourceCRS,\n        @DescribeParameter(name = \"targetCRS\", min = 0, description = \"Target coordinate reference system to use for reprojection\") CoordinateReferenceSystem targetCRS)", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-geometry/src/main/java/org/geotools/process/geometry/GeometryFunctions.java"}, "focal_method": {"identifier": "polygonize", "parameters": "(\n            @DescribeParameter(name = \"geom\", description = \"Linework to polygonize\") Geometry geom)", "modifiers": "@DescribeProcess(title = \"Polygonize\", description = \"Creates a set of polygons from linestrings delineating them. The linestrings must be corrctly noded (i.e. touch only at endpoints).\") @DescribeResult(description = \"The collection of created polygons\") static public", "return": "Geometry", "body": "@DescribeProcess(title = \"Polygonize\", description = \"Creates a set of polygons from linestrings delineating them.  The linestrings must be corrctly noded (i.e. touch only at endpoints).\")\n    @DescribeResult(description = \"The collection of created polygons\")\n    static public Geometry polygonize(\n            @DescribeParameter(name = \"geom\", description = \"Linework to polygonize\") Geometry geom) {\n        @SuppressWarnings(\"rawtypes\")\n        List lines = LineStringExtracter.getLines(geom);\n        Polygonizer polygonizer = new Polygonizer();\n        polygonizer.add(lines);\n        @SuppressWarnings(\"rawtypes\")\n        Collection polys = polygonizer.getPolygons();\n        Polygon[] polyArray = GeometryFactory.toPolygonArray(polys);\n        return geom.getFactory().createGeometryCollection(polyArray);\n    }", "signature": "Geometry polygonize(\n            @DescribeParameter(name = \"geom\", description = \"Linework to polygonize\") Geometry geom)", "full_signature": "@DescribeProcess(title = \"Polygonize\", description = \"Creates a set of polygons from linestrings delineating them. The linestrings must be corrctly noded (i.e. touch only at endpoints).\") @DescribeResult(description = \"The collection of created polygons\") static public Geometry polygonize(\n            @DescribeParameter(name = \"geom\", description = \"Linework to polygonize\") Geometry geom)", "class_method_signature": "GeometryFunctions.polygonize(\n            @DescribeParameter(name = \"geom\", description = \"Linework to polygonize\") Geometry geom)", "testcase": false, "constructor": false, "invocations": ["getLines", "add", "getPolygons", "toPolygonArray", "createGeometryCollection", "getFactory"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}