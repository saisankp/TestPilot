{"test_class": {"identifier": "TestRelayPullThread", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final Logger LOG = Logger.getLogger(\"TestRelayPullThread\");", "modifier": "public static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(\"TestRelayPullThread\")", "var_name": "LOG"}, {"original_string": "public static final org.apache.avro.Schema SCHEMA$ = org.apache.avro.Schema.parse(\"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"LiarJobRelay\\\",\\\"namespace\\\":\\\"com.linkedin.events.liar.jobrelay\\\",\\\"fields\\\":[{\\\"name\\\":\\\"txn\\\",\\\"type\\\":[\\\"int\\\",\\\"null\\\"],\\\"meta\\\":\\\"dbFieldName=TXN;dbFieldPosition=0;\\\"},{\\\"name\\\":\\\"key\\\",\\\"type\\\":[\\\"int\\\",\\\"null\\\"],\\\"meta\\\":\\\"dbFieldName=KEY;dbFieldPosition=1;\\\"},{\\\"name\\\":\\\"eventId\\\",\\\"type\\\":[\\\"int\\\",\\\"null\\\"],\\\"meta\\\":\\\"dbFieldName=EVENT_ID;dbFieldPosition=2;\\\"},{\\\"name\\\":\\\"isDelete\\\",\\\"type\\\":[\\\"string\\\",\\\"null\\\"],\\\"meta\\\":\\\"dbFieldName=IS_DELETE;dbFieldPosition=3;\\\"},{\\\"name\\\":\\\"state\\\",\\\"type\\\":[\\\"string\\\",\\\"null\\\"],\\\"meta\\\":\\\"dbFieldName=STATE;dbFieldPosition=4;\\\"}],\\\"meta\\\":\\\"dbFieldName=SY$LIAR_JOB_RELAY_1;\\\"}\");", "modifier": "public static final", "type": "org.apache.avro.Schema", "declarator": "SCHEMA$ = org.apache.avro.Schema.parse(\"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"LiarJobRelay\\\",\\\"namespace\\\":\\\"com.linkedin.events.liar.jobrelay\\\",\\\"fields\\\":[{\\\"name\\\":\\\"txn\\\",\\\"type\\\":[\\\"int\\\",\\\"null\\\"],\\\"meta\\\":\\\"dbFieldName=TXN;dbFieldPosition=0;\\\"},{\\\"name\\\":\\\"key\\\",\\\"type\\\":[\\\"int\\\",\\\"null\\\"],\\\"meta\\\":\\\"dbFieldName=KEY;dbFieldPosition=1;\\\"},{\\\"name\\\":\\\"eventId\\\",\\\"type\\\":[\\\"int\\\",\\\"null\\\"],\\\"meta\\\":\\\"dbFieldName=EVENT_ID;dbFieldPosition=2;\\\"},{\\\"name\\\":\\\"isDelete\\\",\\\"type\\\":[\\\"string\\\",\\\"null\\\"],\\\"meta\\\":\\\"dbFieldName=IS_DELETE;dbFieldPosition=3;\\\"},{\\\"name\\\":\\\"state\\\",\\\"type\\\":[\\\"string\\\",\\\"null\\\"],\\\"meta\\\":\\\"dbFieldName=STATE;dbFieldPosition=4;\\\"}],\\\"meta\\\":\\\"dbFieldName=SY$LIAR_JOB_RELAY_1;\\\"}\")", "var_name": "SCHEMA"}, {"original_string": "public static final String _HOSTNAME = \"localhost\";", "modifier": "public static final", "type": "String", "declarator": "_HOSTNAME = \"localhost\"", "var_name": "_HOSTNAME"}, {"original_string": "public static final String _SVCNAME = \"UnitTestService\";", "modifier": "public static final", "type": "String", "declarator": "_SVCNAME = \"UnitTestService\"", "var_name": "_SVCNAME"}], "file": "databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestRelayPullThread.java"}, "test_case": {"identifier": "testShutdownRace", "parameters": "()", "modifiers": "@Test /** * DDSDBUS-1904: test a race condition between shutting down a connection and a reconnect to the * relay which may cause a Netty connection to be left open after the RelayPuller shutdown. * The idea is to trigger a shutdown exactly while we are trying to connect to a relay. We achieve * that by rigging MockRelayConnection to call RelayPuller.shutdown() right before responding * to requestSources(); * */ public", "return": "void", "body": "@Test\n  /**\n   * DDSDBUS-1904: test a race condition between shutting down a connection and a reconnect to the\n   * relay which may cause a Netty connection to be left open after the RelayPuller shutdown.\n   * The idea is to trigger a shutdown exactly while we are trying to connect to a relay. We achieve\n   * that by rigging MockRelayConnection to call RelayPuller.shutdown() right before responding\n   * to requestSources();\n   *  */\n  public void testShutdownRace() throws Exception\n  {\n    final Logger log = Logger.getLogger(\"TestRelayPullThread.testShutdownRace\");\n    log.setLevel(Level.INFO);\n    log.info(\"start\");\n\n    //elaborate test setup\n    List<String> sources = Arrays.asList(\"source1\");\n\n    Properties clientProps = new Properties();\n    clientProps.setProperty(\"client.container.httpPort\", \"0\");\n    clientProps.setProperty(\"client.runtime.bootstrap.enabled\", \"false\");\n    clientProps.setProperty(\"client.runtime.relay(1).name\", \"relay1\");\n    clientProps.setProperty(\"client.runtime.relay(1).port\", \"10001\");\n    clientProps.setProperty(\"client.runtime.relay(1).sources\", \"source1\");\n    clientProps.setProperty(\"client.connectionDefaults.eventBuffer.maxSize\", \"100000\");\n    clientProps.setProperty(\"client.connectionDefaults.pullerRetries.maxRetryNum\", \"9\");\n    clientProps.setProperty(\"client.connectionDefaults.pullerRetries.sleepIncFactor\", \"1.0\");\n    clientProps.setProperty(\"client.connectionDefaults.pullerRetries.sleepIncDelta\", \"1\");\n    clientProps.setProperty(\"client.connectionDefaults.pullerRetries.initSleep\", \"1\");\n\n\n    DatabusHttpClientImpl client = new DatabusHttpClientImpl(\"client.\", clientProps);\n    Assert.assertNotNull(client, \"client instantiation ok\");\n\n    final DatabusHttpClientImpl.StaticConfig clientConf = client.getClientStaticConfig();\n    final DatabusSourcesConnection.StaticConfig srcConnConf = clientConf.getConnectionDefaults();\n\n    DatabusHttpClientImpl.RuntimeConfig clientRtConf = clientConf.getRuntime().build();\n    DbusEventBuffer.StaticConfig bufferConf = clientConf.getConnectionDefaults().getEventBuffer();\n\n    DbusEventBuffer relayBuffer = new DbusEventBuffer(bufferConf);\n    DbusEventBuffer bootstrapBuffer = new DbusEventBuffer(bufferConf);\n\n    //we keep the index of the next server we expect to see\n    AtomicInteger serverIdx = new AtomicInteger(-1);\n\n    Set<ServerInfo> relays = clientRtConf.getRelaysSet();\n\n    //generate the order in which we should see the servers\n    List<ServerInfo> relayOrder = new ArrayList<ServerInfo>(relays);\n    if (LOG.isInfoEnabled())\n    {\n      StringBuilder sb = new StringBuilder();\n      for (ServerInfo serverInfo: relayOrder)\n      {\n        sb.append(serverInfo.getName());\n        sb.append(\" \");\n      }\n      LOG.info(\"Relay order:\" + sb.toString());\n    }\n\n    List<IdNamePair> sourcesResponse = new ArrayList<IdNamePair>();\n    sourcesResponse.add(new IdNamePair(1L, \"source1\"));\n\n    RegisterResponseEntry rre1 = new RegisterResponseEntry(1L, (short)1, SCHEMA$.toString());\n    final HashMap<Long, List<RegisterResponseEntry>> registerResponse =\n        new HashMap<Long, List<RegisterResponseEntry>>();\n    registerResponse.put(1L, Arrays.asList(rre1));\n\n    //This guy succeeds on both /sources and /register\n    final MockRelayConnection relayConn1 =\n        new MockRelayConnection(sourcesResponse,\n                                registerResponse,\n                                null,\n                                serverIdx);\n    //This guy will succeed on /sources but will force a shutdown so that\n    //the success message is ignored\n    final MockRelayConnection relayConn2 =\n        new MockRelayConnectionForTestShutdownRace(sourcesResponse,\n                                                   null,\n                                                   null,\n                                                   serverIdx,\n                                                   log);\n\n\n    DatabusRelayConnectionFactory mockConnFactory =\n        EasyMock.createMock(\"mockRelayFactory\", DatabusRelayConnectionFactory.class);\n\n    // expected scenario:  create relayConn1 -> /sources success -> /register success ->\n    // /stream error -> create relayConn2 -> call /sources -> shut down puller -> return\n    // success for /sources\n    EasyMock.expect(mockConnFactory.createRelayConnection(\n        serverNameMatcher(serverIdx, relayOrder),\n        EasyMock.<ActorMessageQueue>notNull(),\n        EasyMock.<RemoteExceptionHandler>notNull())).andReturn(relayConn1);\n    EasyMock.expect(mockConnFactory.createRelayConnection(\n        serverNameMatcher(serverIdx, relayOrder),\n        EasyMock.<ActorMessageQueue>notNull(),\n        EasyMock.<RemoteExceptionHandler>notNull())).andReturn(relayConn2);\n\n    EasyMock.replay(mockConnFactory);\n\n    List<DatabusSubscription> sourcesSubList = DatabusSubscription.createSubscriptionList(sources);\n    //Dummy connection object as expected by the puller thread\n    // Note that in this case, it is ok to pass Set<relays> as all the relays serve the same source \"source1\"\n    ConnectionStateFactory connStateFactory = new ConnectionStateFactory(sources);\n    DatabusSourcesConnection sourcesConn = new DatabusSourcesConnection(\n        srcConnConf, sourcesSubList, relays, null, null, null, relayBuffer, bootstrapBuffer,\n        Executors.newCachedThreadPool(), null, null, null, null, null, null, null, mockConnFactory, null,\n        null, null, null, new DbusEventV1Factory(), connStateFactory);\n\n    final RelayPullThread relayPuller =\n        new RelayPullThread(\"RelayPuller\", sourcesConn, relayBuffer, connStateFactory, relays,\n                            new ArrayList<DbusKeyCompositeFilterConfig>(),\n                            !clientConf.getRuntime().getBootstrap().isEnabled(),\n                            clientConf.isReadLatestScnOnErrorEnabled(),\n                            clientConf.getPullerBufferUtilizationPct(),\n                            Integer.MAX_VALUE,\n                            ManagementFactory.getPlatformMBeanServer(),\n                            new DbusEventV1Factory(),\n                            null);\n    //relayPuller.getLog().setLevel(Level.INFO);\n    RemoteExceptionHandler mockRemoteExceptionHandler =\n        new MockRemoteExceptionHandler(sourcesConn, relayBuffer, relayPuller);\n\n    Field field = relayPuller.getClass().getDeclaredField(\"_remoteExceptionHandler\");\n    field.setAccessible(true);\n    field.set(relayPuller, mockRemoteExceptionHandler);\n\n    relayConn1.setCallback(relayPuller);\n    relayConn2.setCallback(relayPuller);\n\n    //Let the show begin\n    final Thread relayPullerThread = new Thread(relayPuller, \"testShutdownRace.RelayPuller\");\n    relayPullerThread.setDaemon(true);\n    relayPullerThread.start();\n\n    relayPuller.enqueueMessage(LifecycleMessage.createStartMessage());\n\n    //wait for the puller to go the STREAM_REQUEST_SUCCESS state\n    TestUtil.assertWithBackoff(new ConditionCheck()\n    {\n      @Override\n      public boolean check()\n      {\n        return null != relayConn1.getLastStateMsg();\n      }\n    }, \"wait for call from the puller to the relay connection\", 500, log);\n\n    //wait for puller thread to shutdown\n    TestUtil.assertWithBackoff(new ConditionCheck()\n    {\n      @Override\n      public boolean check()\n      {\n        log.debug(relayPuller.getMessageHistoryLog());\n        return !relayPullerThread.isAlive();\n      }\n    }, \"wait for puller to shutdown\", 1000, log);\n\n    EasyMock.verify(mockConnFactory);\n    Assert.assertEquals(relayPuller.getLastOpenConnection(), null);\n\n    log.info(\"done\");\n  }", "signature": "void testShutdownRace()", "full_signature": "@Test /** * DDSDBUS-1904: test a race condition between shutting down a connection and a reconnect to the * relay which may cause a Netty connection to be left open after the RelayPuller shutdown. * The idea is to trigger a shutdown exactly while we are trying to connect to a relay. We achieve * that by rigging MockRelayConnection to call RelayPuller.shutdown() right before responding * to requestSources(); * */ public void testShutdownRace()", "class_method_signature": "TestRelayPullThread.testShutdownRace()", "testcase": true, "constructor": false, "invocations": ["getLogger", "setLevel", "info", "asList", "setProperty", "setProperty", "setProperty", "setProperty", "setProperty", "setProperty", "setProperty", "setProperty", "setProperty", "setProperty", "assertNotNull", "getClientStaticConfig", "getConnectionDefaults", "build", "getRuntime", "getEventBuffer", "getConnectionDefaults", "getRelaysSet", "isInfoEnabled", "append", "getName", "append", "info", "toString", "add", "toString", "put", "asList", "createMock", "andReturn", "expect", "createRelayConnection", "serverNameMatcher", "notNull", "notNull", "andReturn", "expect", "createRelayConnection", "serverNameMatcher", "notNull", "notNull", "replay", "createSubscriptionList", "newCachedThreadPool", "isEnabled", "getBootstrap", "getRuntime", "isReadLatestScnOnErrorEnabled", "getPullerBufferUtilizationPct", "getPlatformMBeanServer", "getDeclaredField", "getClass", "setAccessible", "set", "setCallback", "setCallback", "setDaemon", "start", "enqueueMessage", "createStartMessage", "assertWithBackoff", "getLastStateMsg", "assertWithBackoff", "debug", "getMessageHistoryLog", "isAlive", "verify", "assertEquals", "getLastOpenConnection", "info"]}, "focal_class": {"identifier": "RelayPullThread", "superclass": "extends BasePullThread", "interfaces": "", "fields": [{"original_string": "private final static int RELAY_CALLS_MERGE_FREQ = 10;", "modifier": "private final static", "type": "int", "declarator": "RELAY_CALLS_MERGE_FREQ = 10", "var_name": "RELAY_CALLS_MERGE_FREQ"}, {"original_string": "private static final ArrayList<RegisterResponseEntry> EMPTY_REGISTER_LIST =\n      new ArrayList<RegisterResponseEntry>();", "modifier": "private static final", "type": "ArrayList<RegisterResponseEntry>", "declarator": "EMPTY_REGISTER_LIST =\n      new ArrayList<RegisterResponseEntry>()", "var_name": "EMPTY_REGISTER_LIST"}, {"original_string": "private static final ArrayList<Integer> EMPTY_STREAM_LIST =\n      new ArrayList<Integer>();", "modifier": "private static final", "type": "ArrayList<Integer>", "declarator": "EMPTY_STREAM_LIST =\n      new ArrayList<Integer>()", "var_name": "EMPTY_STREAM_LIST"}, {"original_string": "private final boolean _isConsumeCurrent ;", "modifier": "private final", "type": "boolean", "declarator": "_isConsumeCurrent", "var_name": "_isConsumeCurrent"}, {"original_string": "private final HttpStatisticsCollector _relayCallsStats;", "modifier": "private final", "type": "HttpStatisticsCollector", "declarator": "_relayCallsStats", "var_name": "_relayCallsStats"}, {"original_string": "private DatabusRelayConnection _lastOpenConnection;", "modifier": "private", "type": "DatabusRelayConnection", "declarator": "_lastOpenConnection", "var_name": "_lastOpenConnection"}, {"original_string": "private DbusKeyCompositeFilter _relayFilter;", "modifier": "private", "type": "DbusKeyCompositeFilter", "declarator": "_relayFilter", "var_name": "_relayFilter"}, {"original_string": "private final List<DbusKeyCompositeFilterConfig> _relayFilterConfigs;", "modifier": "private final", "type": "List<DbusKeyCompositeFilterConfig>", "declarator": "_relayFilterConfigs", "var_name": "_relayFilterConfigs"}, {"original_string": "private int _unmergedHttpCallsStats = 0;", "modifier": "private", "type": "int", "declarator": "_unmergedHttpCallsStats = 0", "var_name": "_unmergedHttpCallsStats"}, {"original_string": "private long _streamCallStartMs = 0;", "modifier": "private", "type": "long", "declarator": "_streamCallStartMs = 0", "var_name": "_streamCallStartMs"}, {"original_string": "private long _noEventsConnectionResetTimeSec;", "modifier": "private", "type": "long", "declarator": "_noEventsConnectionResetTimeSec", "var_name": "_noEventsConnectionResetTimeSec"}, {"original_string": "private long _timeSinceEventsSec = System.currentTimeMillis();", "modifier": "private", "type": "long", "declarator": "_timeSinceEventsSec = System.currentTimeMillis()", "var_name": "_timeSinceEventsSec"}, {"original_string": "private final BackoffTimer _retriesOnFallOff;", "modifier": "private final", "type": "BackoffTimer", "declarator": "_retriesOnFallOff", "var_name": "_retriesOnFallOff"}, {"original_string": "final private RemoteExceptionHandler _remoteExceptionHandler;", "modifier": "final private", "type": "RemoteExceptionHandler", "declarator": "_remoteExceptionHandler", "var_name": "_remoteExceptionHandler"}, {"original_string": "private final boolean _isReadLatestScnOnErrorEnabled;", "modifier": "private final", "type": "boolean", "declarator": "_isReadLatestScnOnErrorEnabled", "var_name": "_isReadLatestScnOnErrorEnabled"}, {"original_string": "private final double _pullerBufferUtilizationPct ;", "modifier": "private final", "type": "double", "declarator": "_pullerBufferUtilizationPct", "var_name": "_pullerBufferUtilizationPct"}], "methods": [{"identifier": "RelayPullThread", "parameters": "(String name,\n                         DatabusSourcesConnection sourcesConn,\n                         DbusEventBuffer dbusEventBuffer,\n                         ConnectionStateFactory connStateFactory,\n                         Set<ServerInfo> relays,\n                         List<DbusKeyCompositeFilterConfig> relayFilterConfigs,\n                         boolean isConsumeCurrent,\n                         boolean isReadLatestScnOnErrorEnabled,\n                         double pullerBufferUtilPct,\n                         int noEventsConnectionResetTimeSec,\n                         MBeanServer mbeanServer,\n                         DbusEventFactory eventFactory,\n                         Logger log)", "modifiers": "public", "return": "", "signature": " RelayPullThread(String name,\n                         DatabusSourcesConnection sourcesConn,\n                         DbusEventBuffer dbusEventBuffer,\n                         ConnectionStateFactory connStateFactory,\n                         Set<ServerInfo> relays,\n                         List<DbusKeyCompositeFilterConfig> relayFilterConfigs,\n                         boolean isConsumeCurrent,\n                         boolean isReadLatestScnOnErrorEnabled,\n                         double pullerBufferUtilPct,\n                         int noEventsConnectionResetTimeSec,\n                         MBeanServer mbeanServer,\n                         DbusEventFactory eventFactory,\n                         Logger log)", "full_signature": "public  RelayPullThread(String name,\n                         DatabusSourcesConnection sourcesConn,\n                         DbusEventBuffer dbusEventBuffer,\n                         ConnectionStateFactory connStateFactory,\n                         Set<ServerInfo> relays,\n                         List<DbusKeyCompositeFilterConfig> relayFilterConfigs,\n                         boolean isConsumeCurrent,\n                         boolean isReadLatestScnOnErrorEnabled,\n                         double pullerBufferUtilPct,\n                         int noEventsConnectionResetTimeSec,\n                         MBeanServer mbeanServer,\n                         DbusEventFactory eventFactory,\n                         Logger log)", "class_method_signature": "RelayPullThread.RelayPullThread(String name,\n                         DatabusSourcesConnection sourcesConn,\n                         DbusEventBuffer dbusEventBuffer,\n                         ConnectionStateFactory connStateFactory,\n                         Set<ServerInfo> relays,\n                         List<DbusKeyCompositeFilterConfig> relayFilterConfigs,\n                         boolean isConsumeCurrent,\n                         boolean isReadLatestScnOnErrorEnabled,\n                         double pullerBufferUtilPct,\n                         int noEventsConnectionResetTimeSec,\n                         MBeanServer mbeanServer,\n                         DbusEventFactory eventFactory,\n                         Logger log)", "testcase": false, "constructor": true}, {"identifier": "onResume", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void onResume()", "full_signature": "@Override protected void onResume()", "class_method_signature": "RelayPullThread.onResume()", "testcase": false, "constructor": false}, {"identifier": "onShutdown", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void onShutdown()", "full_signature": "@Override protected void onShutdown()", "class_method_signature": "RelayPullThread.onShutdown()", "testcase": false, "constructor": false}, {"identifier": "doSuspendOnError", "parameters": "(LifecycleMessage lcMessage)", "modifiers": "@Override protected", "return": "void", "signature": "void doSuspendOnError(LifecycleMessage lcMessage)", "full_signature": "@Override protected void doSuspendOnError(LifecycleMessage lcMessage)", "class_method_signature": "RelayPullThread.doSuspendOnError(LifecycleMessage lcMessage)", "testcase": false, "constructor": false}, {"identifier": "shouldDelayTearConnection", "parameters": "(StateId stateId)", "modifiers": "@Override protected", "return": "boolean", "signature": "boolean shouldDelayTearConnection(StateId stateId)", "full_signature": "@Override protected boolean shouldDelayTearConnection(StateId stateId)", "class_method_signature": "RelayPullThread.shouldDelayTearConnection(StateId stateId)", "testcase": false, "constructor": false}, {"identifier": "executeAndChangeState", "parameters": "(Object message)", "modifiers": "@Override protected", "return": "boolean", "signature": "boolean executeAndChangeState(Object message)", "full_signature": "@Override protected boolean executeAndChangeState(Object message)", "class_method_signature": "RelayPullThread.executeAndChangeState(Object message)", "testcase": false, "constructor": false}, {"identifier": "doBootstrapFailed", "parameters": "(BootstrapResultMessage bootstrapResultMessage)", "modifiers": "private", "return": "void", "signature": "void doBootstrapFailed(BootstrapResultMessage bootstrapResultMessage)", "full_signature": "private void doBootstrapFailed(BootstrapResultMessage bootstrapResultMessage)", "class_method_signature": "RelayPullThread.doBootstrapFailed(BootstrapResultMessage bootstrapResultMessage)", "testcase": false, "constructor": false}, {"identifier": "doBootstrapComplete", "parameters": "(BootstrapResultMessage bootstrapResultMessage)", "modifiers": "private", "return": "void", "signature": "void doBootstrapComplete(BootstrapResultMessage bootstrapResultMessage)", "full_signature": "private void doBootstrapComplete(BootstrapResultMessage bootstrapResultMessage)", "class_method_signature": "RelayPullThread.doBootstrapComplete(BootstrapResultMessage bootstrapResultMessage)", "testcase": false, "constructor": false}, {"identifier": "doStart", "parameters": "(LifecycleMessage lcMessage)", "modifiers": "@Override protected", "return": "void", "signature": "void doStart(LifecycleMessage lcMessage)", "full_signature": "@Override protected void doStart(LifecycleMessage lcMessage)", "class_method_signature": "RelayPullThread.doStart(LifecycleMessage lcMessage)", "testcase": false, "constructor": false}, {"identifier": "doPickRelay", "parameters": "(ConnectionState curState)", "modifiers": "protected", "return": "void", "signature": "void doPickRelay(ConnectionState curState)", "full_signature": "protected void doPickRelay(ConnectionState curState)", "class_method_signature": "RelayPullThread.doPickRelay(ConnectionState curState)", "testcase": false, "constructor": false}, {"identifier": "doRequestSources", "parameters": "(final ConnectionState curState)", "modifiers": "protected", "return": "void", "signature": "void doRequestSources(final ConnectionState curState)", "full_signature": "protected void doRequestSources(final ConnectionState curState)", "class_method_signature": "RelayPullThread.doRequestSources(final ConnectionState curState)", "testcase": false, "constructor": false}, {"identifier": "buildSubsList", "parameters": "(List<DatabusSubscription> subs, Map<String, IdNamePair> sourceNameMap)", "modifiers": "private", "return": "String", "signature": "String buildSubsList(List<DatabusSubscription> subs, Map<String, IdNamePair> sourceNameMap)", "full_signature": "private String buildSubsList(List<DatabusSubscription> subs, Map<String, IdNamePair> sourceNameMap)", "class_method_signature": "RelayPullThread.buildSubsList(List<DatabusSubscription> subs, Map<String, IdNamePair> sourceNameMap)", "testcase": false, "constructor": false}, {"identifier": "doSourcesResponseSuccess", "parameters": "(ConnectionState curState)", "modifiers": "protected", "return": "void", "signature": "void doSourcesResponseSuccess(ConnectionState curState)", "full_signature": "protected void doSourcesResponseSuccess(ConnectionState curState)", "class_method_signature": "RelayPullThread.doSourcesResponseSuccess(ConnectionState curState)", "testcase": false, "constructor": false}, {"identifier": "doRequestRegister", "parameters": "(ConnectionState curState)", "modifiers": "protected", "return": "void", "signature": "void doRequestRegister(ConnectionState curState)", "full_signature": "protected void doRequestRegister(ConnectionState curState)", "class_method_signature": "RelayPullThread.doRequestRegister(ConnectionState curState)", "testcase": false, "constructor": false}, {"identifier": "doRegisterResponseSuccess", "parameters": "(ConnectionState curState)", "modifiers": "protected", "return": "void", "signature": "void doRegisterResponseSuccess(ConnectionState curState)", "full_signature": "protected void doRegisterResponseSuccess(ConnectionState curState)", "class_method_signature": "RelayPullThread.doRegisterResponseSuccess(ConnectionState curState)", "testcase": false, "constructor": false}, {"identifier": "doRequestStream", "parameters": "(ConnectionState curState)", "modifiers": "protected", "return": "void", "signature": "void doRequestStream(ConnectionState curState)", "full_signature": "protected void doRequestStream(ConnectionState curState)", "class_method_signature": "RelayPullThread.doRequestStream(ConnectionState curState)", "testcase": false, "constructor": false}, {"identifier": "doReadDataEvents", "parameters": "(ConnectionState curState)", "modifiers": "protected", "return": "void", "signature": "void doReadDataEvents(ConnectionState curState)", "full_signature": "protected void doReadDataEvents(ConnectionState curState)", "class_method_signature": "RelayPullThread.doReadDataEvents(ConnectionState curState)", "testcase": false, "constructor": false}, {"identifier": "doStreamResponseDone", "parameters": "(ConnectionState curState)", "modifiers": "protected", "return": "void", "signature": "void doStreamResponseDone(ConnectionState curState)", "full_signature": "protected void doStreamResponseDone(ConnectionState curState)", "class_method_signature": "RelayPullThread.doStreamResponseDone(ConnectionState curState)", "testcase": false, "constructor": false}, {"identifier": "doBootstrap", "parameters": "(ConnectionState curState)", "modifiers": "protected", "return": "void", "signature": "void doBootstrap(ConnectionState curState)", "full_signature": "protected void doBootstrap(ConnectionState curState)", "class_method_signature": "RelayPullThread.doBootstrap(ConnectionState curState)", "testcase": false, "constructor": false}, {"identifier": "mergeRelayCallsStats", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void mergeRelayCallsStats()", "full_signature": "private void mergeRelayCallsStats()", "class_method_signature": "RelayPullThread.mergeRelayCallsStats()", "testcase": false, "constructor": false}, {"identifier": "processSourcesRequestError", "parameters": "(ConnectionState state)", "modifiers": "private", "return": "void", "signature": "void processSourcesRequestError(ConnectionState state)", "full_signature": "private void processSourcesRequestError(ConnectionState state)", "class_method_signature": "RelayPullThread.processSourcesRequestError(ConnectionState state)", "testcase": false, "constructor": false}, {"identifier": "processSourcesResponseError", "parameters": "(ConnectionState state)", "modifiers": "private", "return": "void", "signature": "void processSourcesResponseError(ConnectionState state)", "full_signature": "private void processSourcesResponseError(ConnectionState state)", "class_method_signature": "RelayPullThread.processSourcesResponseError(ConnectionState state)", "testcase": false, "constructor": false}, {"identifier": "processRegisterRequestError", "parameters": "(ConnectionState state)", "modifiers": "private", "return": "void", "signature": "void processRegisterRequestError(ConnectionState state)", "full_signature": "private void processRegisterRequestError(ConnectionState state)", "class_method_signature": "RelayPullThread.processRegisterRequestError(ConnectionState state)", "testcase": false, "constructor": false}, {"identifier": "processRegisterResponseError", "parameters": "(ConnectionState state)", "modifiers": "private", "return": "void", "signature": "void processRegisterResponseError(ConnectionState state)", "full_signature": "private void processRegisterResponseError(ConnectionState state)", "class_method_signature": "RelayPullThread.processRegisterResponseError(ConnectionState state)", "testcase": false, "constructor": false}, {"identifier": "processStreamRequestError", "parameters": "(ConnectionState state)", "modifiers": "private", "return": "void", "signature": "void processStreamRequestError(ConnectionState state)", "full_signature": "private void processStreamRequestError(ConnectionState state)", "class_method_signature": "RelayPullThread.processStreamRequestError(ConnectionState state)", "testcase": false, "constructor": false}, {"identifier": "processStreamResponseError", "parameters": "(ConnectionState state)", "modifiers": "private", "return": "void", "signature": "void processStreamResponseError(ConnectionState state)", "full_signature": "private void processStreamResponseError(ConnectionState state)", "class_method_signature": "RelayPullThread.processStreamResponseError(ConnectionState state)", "testcase": false, "constructor": false}, {"identifier": "resetConnection", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void resetConnection()", "full_signature": "@Override protected void resetConnection()", "class_method_signature": "RelayPullThread.resetConnection()", "testcase": false, "constructor": false}, {"identifier": "onRelayFellOff", "parameters": "(ConnectionState curState, Checkpoint cp, Throwable knownRemoteError)", "modifiers": "private", "return": "boolean", "signature": "boolean onRelayFellOff(ConnectionState curState, Checkpoint cp, Throwable knownRemoteError)", "full_signature": "private boolean onRelayFellOff(ConnectionState curState, Checkpoint cp, Throwable knownRemoteError)", "class_method_signature": "RelayPullThread.onRelayFellOff(ConnectionState curState, Checkpoint cp, Throwable knownRemoteError)", "testcase": false, "constructor": false}, {"identifier": "tearConnection", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void tearConnection()", "full_signature": "@Override protected void tearConnection()", "class_method_signature": "RelayPullThread.tearConnection()", "testcase": false, "constructor": false}, {"identifier": "setNoEventsConnectionResetTimeSec", "parameters": "(long noEventsConnectionResetTimeSec)", "modifiers": "public", "return": "void", "signature": "void setNoEventsConnectionResetTimeSec(long noEventsConnectionResetTimeSec)", "full_signature": "public void setNoEventsConnectionResetTimeSec(long noEventsConnectionResetTimeSec)", "class_method_signature": "RelayPullThread.setNoEventsConnectionResetTimeSec(long noEventsConnectionResetTimeSec)", "testcase": false, "constructor": false}, {"identifier": "getRetryonFallOff", "parameters": "()", "modifiers": "protected", "return": "BackoffTimer", "signature": "BackoffTimer getRetryonFallOff()", "full_signature": "protected BackoffTimer getRetryonFallOff()", "class_method_signature": "RelayPullThread.getRetryonFallOff()", "testcase": false, "constructor": false}, {"identifier": "writeEventToRelayDispatcher", "parameters": "(ConnectionState curState, DbusEvent event, String message)", "modifiers": "private", "return": "void", "signature": "void writeEventToRelayDispatcher(ConnectionState curState, DbusEvent event, String message)", "full_signature": "private void writeEventToRelayDispatcher(ConnectionState curState, DbusEvent event, String message)", "class_method_signature": "RelayPullThread.writeEventToRelayDispatcher(ConnectionState curState, DbusEvent event, String message)", "testcase": false, "constructor": false}, {"identifier": "getLastOpenConnection", "parameters": "()", "modifiers": "public", "return": "DatabusRelayConnection", "signature": "DatabusRelayConnection getLastOpenConnection()", "full_signature": "public DatabusRelayConnection getLastOpenConnection()", "class_method_signature": "RelayPullThread.getLastOpenConnection()", "testcase": false, "constructor": false}], "file": "databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/RelayPullThread.java"}, "focal_method": {"identifier": "getLastOpenConnection", "parameters": "()", "modifiers": "public", "return": "DatabusRelayConnection", "body": "public DatabusRelayConnection getLastOpenConnection()\n  {\n    return _lastOpenConnection;\n  }", "signature": "DatabusRelayConnection getLastOpenConnection()", "full_signature": "public DatabusRelayConnection getLastOpenConnection()", "class_method_signature": "RelayPullThread.getLastOpenConnection()", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 7209229, "url": "https://github.com/linkedin/databus", "language": "Java", "is_fork": false, "fork_count": 653, "stargazer_count": 2899, "size": 51191, "license": "licensed"}}