{"test_class": {"identifier": "ConstantTimeBackoffTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "final static private Log LOG = LogFactory.getLog(ConstantTimeBackoffTest.class);", "modifier": "final static private", "type": "Log", "declarator": "LOG = LogFactory.getLog(ConstantTimeBackoffTest.class)", "var_name": "LOG"}], "file": "utils/src/test/java/com/cloud/utils/backoff/impl/ConstantTimeBackoffTest.java"}, "test_case": {"identifier": "waitBeforeRetry", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void waitBeforeRetry() throws InterruptedException {\n        final ConstantTimeBackoff backoff = new ConstantTimeBackoff();\n        // let's not wait too much in a test\n        backoff.setTimeToWait(0);\n        // check if the list of waiters is empty\n        Assert.assertTrue(backoff.getWaiters().isEmpty());\n        // call the waitBeforeRetry which will wait 0 ms and return\n        backoff.waitBeforeRetry();\n        // on normal exit the list of waiters should be cleared\n        Assert.assertTrue(backoff.getWaiters().isEmpty());\n    }", "signature": "void waitBeforeRetry()", "full_signature": "@Test public void waitBeforeRetry()", "class_method_signature": "ConstantTimeBackoffTest.waitBeforeRetry()", "testcase": true, "constructor": false, "invocations": ["setTimeToWait", "assertTrue", "isEmpty", "getWaiters", "waitBeforeRetry", "assertTrue", "isEmpty", "getWaiters"]}, "focal_class": {"identifier": "ConstantTimeBackoff", "superclass": "extends AdapterBase", "interfaces": "implements BackoffAlgorithm, ConstantTimeBackoffMBean", "fields": [{"original_string": "long _time;", "modifier": "", "type": "long", "declarator": "_time", "var_name": "_time"}, {"original_string": "private final Map<String, Thread> _asleep = new ConcurrentHashMap<String, Thread>();", "modifier": "private final", "type": "Map<String, Thread>", "declarator": "_asleep = new ConcurrentHashMap<String, Thread>()", "var_name": "_asleep"}, {"original_string": "private final static Log LOG = LogFactory.getLog(ConstantTimeBackoff.class);", "modifier": "private final static", "type": "Log", "declarator": "LOG = LogFactory.getLog(ConstantTimeBackoff.class)", "var_name": "LOG"}], "methods": [{"identifier": "waitBeforeRetry", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void waitBeforeRetry()", "full_signature": "@Override public void waitBeforeRetry()", "class_method_signature": "ConstantTimeBackoff.waitBeforeRetry()", "testcase": false, "constructor": false}, {"identifier": "reset", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void reset()", "full_signature": "@Override public void reset()", "class_method_signature": "ConstantTimeBackoff.reset()", "testcase": false, "constructor": false}, {"identifier": "configure", "parameters": "(String name, Map<String, Object> params)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean configure(String name, Map<String, Object> params)", "full_signature": "@Override public boolean configure(String name, Map<String, Object> params)", "class_method_signature": "ConstantTimeBackoff.configure(String name, Map<String, Object> params)", "testcase": false, "constructor": false}, {"identifier": "getWaiters", "parameters": "()", "modifiers": "@Override public", "return": "Collection<String>", "signature": "Collection<String> getWaiters()", "full_signature": "@Override public Collection<String> getWaiters()", "class_method_signature": "ConstantTimeBackoff.getWaiters()", "testcase": false, "constructor": false}, {"identifier": "wakeup", "parameters": "(String threadName)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean wakeup(String threadName)", "full_signature": "@Override public boolean wakeup(String threadName)", "class_method_signature": "ConstantTimeBackoff.wakeup(String threadName)", "testcase": false, "constructor": false}, {"identifier": "getTimeToWait", "parameters": "()", "modifiers": "@Override public", "return": "long", "signature": "long getTimeToWait()", "full_signature": "@Override public long getTimeToWait()", "class_method_signature": "ConstantTimeBackoff.getTimeToWait()", "testcase": false, "constructor": false}, {"identifier": "setTimeToWait", "parameters": "(long seconds)", "modifiers": "@Override public", "return": "void", "signature": "void setTimeToWait(long seconds)", "full_signature": "@Override public void setTimeToWait(long seconds)", "class_method_signature": "ConstantTimeBackoff.setTimeToWait(long seconds)", "testcase": false, "constructor": false}], "file": "utils/src/main/java/com/cloud/utils/backoff/impl/ConstantTimeBackoff.java"}, "focal_method": {"identifier": "waitBeforeRetry", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void waitBeforeRetry() {\n        Thread current = Thread.currentThread();\n        try {\n            _asleep.put(current.getName(), current);\n            Thread.sleep(_time);\n        } catch (InterruptedException e) {\n            // JMX or other threads may interrupt this thread, but let's log it\n            // anyway, no exception to log as this is not an error\n            LOG.info(\"Thread \" + current.getName() + \" interrupted while waiting for retry\");\n        } finally {\n            _asleep.remove(current.getName());\n        }\n        return;\n    }", "signature": "void waitBeforeRetry()", "full_signature": "@Override public void waitBeforeRetry()", "class_method_signature": "ConstantTimeBackoff.waitBeforeRetry()", "testcase": false, "constructor": false, "invocations": ["currentThread", "put", "getName", "sleep", "info", "getName", "remove", "getName"]}, "repository": {"repo_id": 49943894, "url": "https://github.com/MissionCriticalCloudOldRepos/cosmic-core", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 9, "size": 18165, "license": "licensed"}}