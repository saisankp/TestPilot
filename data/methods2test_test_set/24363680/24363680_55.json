{"test_class": {"identifier": "PeerGroupTest", "superclass": "extends TestWithPeerGroup", "interfaces": "", "fields": [{"original_string": "static final NetworkParameters params = UnitTestParams.get();", "modifier": "static final", "type": "NetworkParameters", "declarator": "params = UnitTestParams.get()", "var_name": "params"}, {"original_string": "private BlockingQueue<Peer> connectedPeers;", "modifier": "private", "type": "BlockingQueue<Peer>", "declarator": "connectedPeers", "var_name": "connectedPeers"}, {"original_string": "private BlockingQueue<Peer> disconnectedPeers;", "modifier": "private", "type": "BlockingQueue<Peer>", "declarator": "disconnectedPeers", "var_name": "disconnectedPeers"}, {"original_string": "private PeerEventListener listener;", "modifier": "private", "type": "PeerEventListener", "declarator": "listener", "var_name": "listener"}, {"original_string": "private Map<Peer, AtomicInteger> peerToMessageCount;", "modifier": "private", "type": "Map<Peer, AtomicInteger>", "declarator": "peerToMessageCount", "var_name": "peerToMessageCount"}], "file": "core/src/test/java/com/google/bitcoin/core/PeerGroupTest.java"}, "test_case": {"identifier": "testBloomOnP2Pubkey", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testBloomOnP2Pubkey() throws Exception {\n        // Cover bug 513. When a relevant transaction with a p2pubkey output is found, the Bloom filter should be\n        // recalculated to include that transaction hash but not re-broadcast as the remote nodes should have followed\n        // the same procedure. However a new node that's connected should get the fresh filter.\n        peerGroup.startAndWait();\n        final ECKey key = wallet.getKeys().get(0);\n        // Create a couple of peers.\n        InboundMessageQueuer p1 = connectPeer(1);\n        InboundMessageQueuer p2 = connectPeer(2);\n        // Create a pay to pubkey tx.\n        Transaction tx = TestUtils.createFakeTx(params, Utils.COIN, key);\n        Transaction tx2 = new Transaction(params);\n        tx2.addInput(tx.getOutput(0));\n        TransactionOutPoint outpoint = tx2.getInput(0).getOutpoint();\n        assertTrue(p1.lastReceivedFilter.contains(key.getPubKey()));\n        assertFalse(p1.lastReceivedFilter.contains(tx.getHash().getBytes()));\n        inbound(p1, tx);\n        // p1 requests dep resolution, p2 is quiet.\n        assertTrue(outbound(p1) instanceof GetDataMessage);\n        final Sha256Hash dephash = tx.getInput(0).getOutpoint().getHash();\n        final InventoryItem inv = new InventoryItem(InventoryItem.Type.Transaction, dephash);\n        inbound(p1, new NotFoundMessage(params, ImmutableList.of(inv)));\n        assertNull(outbound(p1));\n        assertNull(outbound(p2));\n        peerGroup.waitForJobQueue();\n        // Now we connect p3 and there is a new bloom filter sent, that DOES match the relevant outpoint.\n        InboundMessageQueuer p3 = connectPeer(3);\n        assertTrue(p3.lastReceivedFilter.contains(key.getPubKey()));\n        assertTrue(p3.lastReceivedFilter.contains(outpoint.bitcoinSerialize()));\n    }", "signature": "void testBloomOnP2Pubkey()", "full_signature": "@Test public void testBloomOnP2Pubkey()", "class_method_signature": "PeerGroupTest.testBloomOnP2Pubkey()", "testcase": true, "constructor": false, "invocations": ["startAndWait", "get", "getKeys", "connectPeer", "connectPeer", "createFakeTx", "addInput", "getOutput", "getOutpoint", "getInput", "assertTrue", "contains", "getPubKey", "assertFalse", "contains", "getBytes", "getHash", "inbound", "assertTrue", "outbound", "getHash", "getOutpoint", "getInput", "inbound", "of", "assertNull", "outbound", "assertNull", "outbound", "waitForJobQueue", "connectPeer", "assertTrue", "contains", "getPubKey", "assertTrue", "contains", "bitcoinSerialize"]}, "focal_class": {"identifier": "PeerGroup", "superclass": "extends AbstractExecutionThreadService", "interfaces": "implements TransactionBroadcaster", "fields": [{"original_string": "private static final int DEFAULT_CONNECTIONS = 4;", "modifier": "private static final", "type": "int", "declarator": "DEFAULT_CONNECTIONS = 4", "var_name": "DEFAULT_CONNECTIONS"}, {"original_string": "private static final Logger log = LoggerFactory.getLogger(PeerGroup.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(PeerGroup.class)", "var_name": "log"}, {"original_string": "protected final ReentrantLock lock = Threading.lock(\"peergroup\");", "modifier": "protected final", "type": "ReentrantLock", "declarator": "lock = Threading.lock(\"peergroup\")", "var_name": "lock"}, {"original_string": "@GuardedBy(\"lock\") private final PriorityQueue<PeerAddress> inactives;", "modifier": "@GuardedBy(\"lock\") private final", "type": "PriorityQueue<PeerAddress>", "declarator": "inactives", "var_name": "inactives"}, {"original_string": "@GuardedBy(\"lock\") private final Map<PeerAddress, ExponentialBackoff> backoffMap;", "modifier": "@GuardedBy(\"lock\") private final", "type": "Map<PeerAddress, ExponentialBackoff>", "declarator": "backoffMap", "var_name": "backoffMap"}, {"original_string": "private final CopyOnWriteArrayList<Peer> peers;", "modifier": "private final", "type": "CopyOnWriteArrayList<Peer>", "declarator": "peers", "var_name": "peers"}, {"original_string": "private final CopyOnWriteArrayList<Peer> pendingPeers;", "modifier": "private final", "type": "CopyOnWriteArrayList<Peer>", "declarator": "pendingPeers", "var_name": "pendingPeers"}, {"original_string": "private final ClientConnectionManager channels;", "modifier": "private final", "type": "ClientConnectionManager", "declarator": "channels", "var_name": "channels"}, {"original_string": "@GuardedBy(\"lock\") private Peer downloadPeer;", "modifier": "@GuardedBy(\"lock\") private", "type": "Peer", "declarator": "downloadPeer", "var_name": "downloadPeer"}, {"original_string": "@Nullable @GuardedBy(\"lock\") private PeerEventListener downloadListener;", "modifier": "@Nullable @GuardedBy(\"lock\") private", "type": "PeerEventListener", "declarator": "downloadListener", "var_name": "downloadListener"}, {"original_string": "private final CopyOnWriteArrayList<ListenerRegistration<PeerEventListener>> peerEventListeners;", "modifier": "private final", "type": "CopyOnWriteArrayList<ListenerRegistration<PeerEventListener>>", "declarator": "peerEventListeners", "var_name": "peerEventListeners"}, {"original_string": "private final CopyOnWriteArraySet<PeerDiscovery> peerDiscoverers;", "modifier": "private final", "type": "CopyOnWriteArraySet<PeerDiscovery>", "declarator": "peerDiscoverers", "var_name": "peerDiscoverers"}, {"original_string": "@GuardedBy(\"lock\") private VersionMessage versionMessage;", "modifier": "@GuardedBy(\"lock\") private", "type": "VersionMessage", "declarator": "versionMessage", "var_name": "versionMessage"}, {"original_string": "private final MemoryPool memoryPool;", "modifier": "private final", "type": "MemoryPool", "declarator": "memoryPool", "var_name": "memoryPool"}, {"original_string": "@GuardedBy(\"lock\") private int maxConnections;", "modifier": "@GuardedBy(\"lock\") private", "type": "int", "declarator": "maxConnections", "var_name": "maxConnections"}, {"original_string": "private volatile int vMinRequiredProtocolVersion = CoinDefinition.MIN_PROTOCOL_VERSION;", "modifier": "private volatile", "type": "int", "declarator": "vMinRequiredProtocolVersion = CoinDefinition.MIN_PROTOCOL_VERSION", "var_name": "vMinRequiredProtocolVersion"}, {"original_string": "private volatile Timer vPingTimer;", "modifier": "private volatile", "type": "Timer", "declarator": "vPingTimer", "var_name": "vPingTimer"}, {"original_string": "public static final long DEFAULT_PING_INTERVAL_MSEC = 2000;", "modifier": "public static final", "type": "long", "declarator": "DEFAULT_PING_INTERVAL_MSEC = 2000", "var_name": "DEFAULT_PING_INTERVAL_MSEC"}, {"original_string": "private long pingIntervalMsec = DEFAULT_PING_INTERVAL_MSEC;", "modifier": "private", "type": "long", "declarator": "pingIntervalMsec = DEFAULT_PING_INTERVAL_MSEC", "var_name": "pingIntervalMsec"}, {"original_string": "private final NetworkParameters params;", "modifier": "private final", "type": "NetworkParameters", "declarator": "params", "var_name": "params"}, {"original_string": "private final AbstractBlockChain chain;", "modifier": "private final", "type": "AbstractBlockChain", "declarator": "chain", "var_name": "chain"}, {"original_string": "@GuardedBy(\"lock\") private long fastCatchupTimeSecs;", "modifier": "@GuardedBy(\"lock\") private", "type": "long", "declarator": "fastCatchupTimeSecs", "var_name": "fastCatchupTimeSecs"}, {"original_string": "private final CopyOnWriteArrayList<Wallet> wallets;", "modifier": "private final", "type": "CopyOnWriteArrayList<Wallet>", "declarator": "wallets", "var_name": "wallets"}, {"original_string": "private final CopyOnWriteArrayList<PeerFilterProvider> peerFilterProviders;", "modifier": "private final", "type": "CopyOnWriteArrayList<PeerFilterProvider>", "declarator": "peerFilterProviders", "var_name": "peerFilterProviders"}, {"original_string": "private final AbstractPeerEventListener peerListener = new AbstractPeerEventListener() {\n        @Override\n        public List<Message> getData(Peer peer, GetDataMessage m) {\n            return handleGetData(m);\n        }\n\n        @Override\n        public void onBlocksDownloaded(Peer peer, Block block, int blocksLeft) {\n            double rate = checkNotNull(chain).getFalsePositiveRate();\n            if (rate > bloomFilterFPRate * MAX_FP_RATE_INCREASE) {\n                log.info(\"Force update Bloom filter due to high false positive rate\");\n                recalculateFastCatchupAndFilter(FilterRecalculateMode.FORCE_SEND);\n            }\n        }\n    };", "modifier": "private final", "type": "AbstractPeerEventListener", "declarator": "peerListener = new AbstractPeerEventListener() {\n        @Override\n        public List<Message> getData(Peer peer, GetDataMessage m) {\n            return handleGetData(m);\n        }\n\n        @Override\n        public void onBlocksDownloaded(Peer peer, Block block, int blocksLeft) {\n            double rate = checkNotNull(chain).getFalsePositiveRate();\n            if (rate > bloomFilterFPRate * MAX_FP_RATE_INCREASE) {\n                log.info(\"Force update Bloom filter due to high false positive rate\");\n                recalculateFastCatchupAndFilter(FilterRecalculateMode.FORCE_SEND);\n            }\n        }\n    }", "var_name": "peerListener"}, {"original_string": "private int minBroadcastConnections = CoinDefinition.minBroadcastConnections;", "modifier": "private", "type": "int", "declarator": "minBroadcastConnections = CoinDefinition.minBroadcastConnections", "var_name": "minBroadcastConnections"}, {"original_string": "private Runnable bloomSendIfChanged = new Runnable() {\n        @Override public void run() {\n            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);\n        }\n    };", "modifier": "private", "type": "Runnable", "declarator": "bloomSendIfChanged = new Runnable() {\n        @Override public void run() {\n            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);\n        }\n    }", "var_name": "bloomSendIfChanged"}, {"original_string": "private Runnable bloomDontSend = new Runnable() {\n        @Override public void run() {\n            recalculateFastCatchupAndFilter(FilterRecalculateMode.DONT_SEND);\n        }\n    };", "modifier": "private", "type": "Runnable", "declarator": "bloomDontSend = new Runnable() {\n        @Override public void run() {\n            recalculateFastCatchupAndFilter(FilterRecalculateMode.DONT_SEND);\n        }\n    }", "var_name": "bloomDontSend"}, {"original_string": "private AbstractWalletEventListener walletEventListener = new AbstractWalletEventListener() {\n        private void queueRecalc(boolean andTransmit) {\n            if (andTransmit) {\n                log.info(\"Queuing recalc of the Bloom filter due to new keys or scripts becoming available\");\n                Uninterruptibles.putUninterruptibly(jobQueue, bloomSendIfChanged);\n            } else {\n                log.info(\"Queuing recalc of the Bloom filter due to observing a pay to pubkey output on a relevant tx\");\n                Uninterruptibles.putUninterruptibly(jobQueue, bloomDontSend);\n            }\n        }\n\n        @Override public void onScriptsAdded(Wallet wallet, List<Script> scripts) {\n            queueRecalc(true);\n        }\n\n        @Override public void onKeysAdded(Wallet wallet, List<ECKey> keys) {\n            queueRecalc(true);\n        }\n\n        @Override\n        public void onCoinsReceived(Wallet wallet, Transaction tx, BigInteger prevBalance, BigInteger newBalance) {\n            // We received a relevant transaction. We MAY need to recalculate and resend the Bloom filter, but only\n            // if we have received a transaction that includes a relevant pay-to-pubkey output.\n            //\n            // The reason is that pay-to-pubkey outputs, when spent, will not repeat any data we can predict in their\n            // inputs. So a remote peer will update the Bloom filter for us when such an output is seen matching the\n            // existing filter, so that it includes the tx hash in which the pay-to-pubkey output was observed. Thus\n            // the spending transaction will always match (due to the outpoint structure).\n            //\n            // Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.\n            //\n            // (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,\n            // for example in a coinbase transaction, then the node that's serving us the chain will update its filter\n            // but the rest will not. If another transaction then spends it, the other nodes won't match/relay it.\n            //\n            // (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see\n            // it and update their filter themselves, but any newly connected nodes will receive the last filter we\n            // calculated, which would not include this transaction.\n            //\n            // For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc\n            // and possibly retransmit if so. The recalculation process will end up including the tx hash into the\n            // filter. In case (1), we need to retransmit the filter to the connected peers. In case (2), we don't\n            // and shouldn't, we should just recalculate and cache the new filter for next time.\n            for (TransactionOutput output : tx.getOutputs()) {\n                if (output.getScriptPubKey().isSentToRawPubKey() && output.isMine(wallet)) {\n                    if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)\n                        queueRecalc(true);\n                    else\n                        queueRecalc(false);\n                    return;\n                }\n            }\n        }\n    };", "modifier": "private", "type": "AbstractWalletEventListener", "declarator": "walletEventListener = new AbstractWalletEventListener() {\n        private void queueRecalc(boolean andTransmit) {\n            if (andTransmit) {\n                log.info(\"Queuing recalc of the Bloom filter due to new keys or scripts becoming available\");\n                Uninterruptibles.putUninterruptibly(jobQueue, bloomSendIfChanged);\n            } else {\n                log.info(\"Queuing recalc of the Bloom filter due to observing a pay to pubkey output on a relevant tx\");\n                Uninterruptibles.putUninterruptibly(jobQueue, bloomDontSend);\n            }\n        }\n\n        @Override public void onScriptsAdded(Wallet wallet, List<Script> scripts) {\n            queueRecalc(true);\n        }\n\n        @Override public void onKeysAdded(Wallet wallet, List<ECKey> keys) {\n            queueRecalc(true);\n        }\n\n        @Override\n        public void onCoinsReceived(Wallet wallet, Transaction tx, BigInteger prevBalance, BigInteger newBalance) {\n            // We received a relevant transaction. We MAY need to recalculate and resend the Bloom filter, but only\n            // if we have received a transaction that includes a relevant pay-to-pubkey output.\n            //\n            // The reason is that pay-to-pubkey outputs, when spent, will not repeat any data we can predict in their\n            // inputs. So a remote peer will update the Bloom filter for us when such an output is seen matching the\n            // existing filter, so that it includes the tx hash in which the pay-to-pubkey output was observed. Thus\n            // the spending transaction will always match (due to the outpoint structure).\n            //\n            // Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.\n            //\n            // (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,\n            // for example in a coinbase transaction, then the node that's serving us the chain will update its filter\n            // but the rest will not. If another transaction then spends it, the other nodes won't match/relay it.\n            //\n            // (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see\n            // it and update their filter themselves, but any newly connected nodes will receive the last filter we\n            // calculated, which would not include this transaction.\n            //\n            // For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc\n            // and possibly retransmit if so. The recalculation process will end up including the tx hash into the\n            // filter. In case (1), we need to retransmit the filter to the connected peers. In case (2), we don't\n            // and shouldn't, we should just recalculate and cache the new filter for next time.\n            for (TransactionOutput output : tx.getOutputs()) {\n                if (output.getScriptPubKey().isSentToRawPubKey() && output.isMine(wallet)) {\n                    if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)\n                        queueRecalc(true);\n                    else\n                        queueRecalc(false);\n                    return;\n                }\n            }\n        }\n    }", "var_name": "walletEventListener"}, {"original_string": "private ExponentialBackoff.Params peerBackoffParams = new ExponentialBackoff.Params(1000, 1.5f, 10 * 60 * 1000);", "modifier": "private", "type": "ExponentialBackoff.Params", "declarator": "peerBackoffParams = new ExponentialBackoff.Params(1000, 1.5f, 10 * 60 * 1000)", "var_name": "peerBackoffParams"}, {"original_string": "private ExponentialBackoff groupBackoff = new ExponentialBackoff(new ExponentialBackoff.Params(100, 1.1f, 30 * 1000));", "modifier": "private", "type": "ExponentialBackoff", "declarator": "groupBackoff = new ExponentialBackoff(new ExponentialBackoff.Params(100, 1.1f, 30 * 1000))", "var_name": "groupBackoff"}, {"original_string": "private LinkedBlockingQueue<Runnable> jobQueue = new LinkedBlockingQueue<Runnable>();", "modifier": "private", "type": "LinkedBlockingQueue<Runnable>", "declarator": "jobQueue = new LinkedBlockingQueue<Runnable>()", "var_name": "jobQueue"}, {"original_string": "private final Set<TransactionBroadcast> runningBroadcasts;", "modifier": "private final", "type": "Set<TransactionBroadcast>", "declarator": "runningBroadcasts", "var_name": "runningBroadcasts"}, {"original_string": "PeerEventListener startupListener = new PeerStartupListener();", "modifier": "", "type": "PeerEventListener", "declarator": "startupListener = new PeerStartupListener()", "var_name": "startupListener"}, {"original_string": "private BloomFilter bloomFilter;", "modifier": "private", "type": "BloomFilter", "declarator": "bloomFilter", "var_name": "bloomFilter"}, {"original_string": "public static final double DEFAULT_BLOOM_FILTER_FP_RATE = 0.0005;", "modifier": "public static final", "type": "double", "declarator": "DEFAULT_BLOOM_FILTER_FP_RATE = 0.0005", "var_name": "DEFAULT_BLOOM_FILTER_FP_RATE"}, {"original_string": "public static final double MAX_FP_RATE_INCREASE = 2.0f;", "modifier": "public static final", "type": "double", "declarator": "MAX_FP_RATE_INCREASE = 2.0f", "var_name": "MAX_FP_RATE_INCREASE"}, {"original_string": "private double bloomFilterFPRate = DEFAULT_BLOOM_FILTER_FP_RATE;", "modifier": "private", "type": "double", "declarator": "bloomFilterFPRate = DEFAULT_BLOOM_FILTER_FP_RATE", "var_name": "bloomFilterFPRate"}, {"original_string": "private final long bloomFilterTweak = (long) (Math.random() * Long.MAX_VALUE);", "modifier": "private final", "type": "long", "declarator": "bloomFilterTweak = (long) (Math.random() * Long.MAX_VALUE)", "var_name": "bloomFilterTweak"}, {"original_string": "private int lastBloomFilterElementCount;", "modifier": "private", "type": "int", "declarator": "lastBloomFilterElementCount", "var_name": "lastBloomFilterElementCount"}, {"original_string": "public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000", "var_name": "DEFAULT_CONNECT_TIMEOUT_MILLIS"}, {"original_string": "private volatile int vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS;", "modifier": "private volatile", "type": "int", "declarator": "vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS", "var_name": "vConnectTimeoutMillis"}, {"original_string": "private Runnable triggerConnectionsJob = new Runnable() {\n        @Override\n        public void run() {\n            // We have to test the condition at the end, because during startup we need to run this at least once\n            // when isRunning() can return false.\n            do {\n                try {\n                    connectToAnyPeer();\n                } catch(PeerDiscoveryException e) {\n                    groupBackoff.trackFailure();\n                }\n            } while (isRunning() && countConnectedAndPendingPeers() < getMaxConnections());\n        }\n    };", "modifier": "private", "type": "Runnable", "declarator": "triggerConnectionsJob = new Runnable() {\n        @Override\n        public void run() {\n            // We have to test the condition at the end, because during startup we need to run this at least once\n            // when isRunning() can return false.\n            do {\n                try {\n                    connectToAnyPeer();\n                } catch(PeerDiscoveryException e) {\n                    groupBackoff.trackFailure();\n                }\n            } while (isRunning() && countConnectedAndPendingPeers() < getMaxConnections());\n        }\n    }", "var_name": "triggerConnectionsJob"}], "methods": [{"identifier": "PeerGroup", "parameters": "(NetworkParameters params)", "modifiers": "public", "return": "", "signature": " PeerGroup(NetworkParameters params)", "full_signature": "public  PeerGroup(NetworkParameters params)", "class_method_signature": "PeerGroup.PeerGroup(NetworkParameters params)", "testcase": false, "constructor": true}, {"identifier": "PeerGroup", "parameters": "(NetworkParameters params, @Nullable AbstractBlockChain chain)", "modifiers": "public", "return": "", "signature": " PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain)", "full_signature": "public  PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain)", "class_method_signature": "PeerGroup.PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain)", "testcase": false, "constructor": true}, {"identifier": "PeerGroup", "parameters": "(NetworkParameters params, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "modifiers": "public", "return": "", "signature": " PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "full_signature": "public  PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "class_method_signature": "PeerGroup.PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "testcase": false, "constructor": true}, {"identifier": "setMaxConnections", "parameters": "(int maxConnections)", "modifiers": "public", "return": "void", "signature": "void setMaxConnections(int maxConnections)", "full_signature": "public void setMaxConnections(int maxConnections)", "class_method_signature": "PeerGroup.setMaxConnections(int maxConnections)", "testcase": false, "constructor": false}, {"identifier": "triggerConnections", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void triggerConnections()", "full_signature": "private void triggerConnections()", "class_method_signature": "PeerGroup.triggerConnections()", "testcase": false, "constructor": false}, {"identifier": "getMaxConnections", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMaxConnections()", "full_signature": "public int getMaxConnections()", "class_method_signature": "PeerGroup.getMaxConnections()", "testcase": false, "constructor": false}, {"identifier": "handleGetData", "parameters": "(GetDataMessage m)", "modifiers": "private", "return": "List<Message>", "signature": "List<Message> handleGetData(GetDataMessage m)", "full_signature": "private List<Message> handleGetData(GetDataMessage m)", "class_method_signature": "PeerGroup.handleGetData(GetDataMessage m)", "testcase": false, "constructor": false}, {"identifier": "setVersionMessage", "parameters": "(VersionMessage ver)", "modifiers": "public", "return": "void", "signature": "void setVersionMessage(VersionMessage ver)", "full_signature": "public void setVersionMessage(VersionMessage ver)", "class_method_signature": "PeerGroup.setVersionMessage(VersionMessage ver)", "testcase": false, "constructor": false}, {"identifier": "getVersionMessage", "parameters": "()", "modifiers": "public", "return": "VersionMessage", "signature": "VersionMessage getVersionMessage()", "full_signature": "public VersionMessage getVersionMessage()", "class_method_signature": "PeerGroup.getVersionMessage()", "testcase": false, "constructor": false}, {"identifier": "setUserAgent", "parameters": "(String name, String version, @Nullable String comments)", "modifiers": "public", "return": "void", "signature": "void setUserAgent(String name, String version, @Nullable String comments)", "full_signature": "public void setUserAgent(String name, String version, @Nullable String comments)", "class_method_signature": "PeerGroup.setUserAgent(String name, String version, @Nullable String comments)", "testcase": false, "constructor": false}, {"identifier": "updateVersionMessageRelayTxesBeforeFilter", "parameters": "(VersionMessage ver)", "modifiers": "private", "return": "void", "signature": "void updateVersionMessageRelayTxesBeforeFilter(VersionMessage ver)", "full_signature": "private void updateVersionMessageRelayTxesBeforeFilter(VersionMessage ver)", "class_method_signature": "PeerGroup.updateVersionMessageRelayTxesBeforeFilter(VersionMessage ver)", "testcase": false, "constructor": false}, {"identifier": "setUserAgent", "parameters": "(String name, String version)", "modifiers": "public", "return": "void", "signature": "void setUserAgent(String name, String version)", "full_signature": "public void setUserAgent(String name, String version)", "class_method_signature": "PeerGroup.setUserAgent(String name, String version)", "testcase": false, "constructor": false}, {"identifier": "addEventListener", "parameters": "(PeerEventListener listener, Executor executor)", "modifiers": "public", "return": "void", "signature": "void addEventListener(PeerEventListener listener, Executor executor)", "full_signature": "public void addEventListener(PeerEventListener listener, Executor executor)", "class_method_signature": "PeerGroup.addEventListener(PeerEventListener listener, Executor executor)", "testcase": false, "constructor": false}, {"identifier": "addEventListener", "parameters": "(PeerEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addEventListener(PeerEventListener listener)", "full_signature": "public void addEventListener(PeerEventListener listener)", "class_method_signature": "PeerGroup.addEventListener(PeerEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeEventListener", "parameters": "(PeerEventListener listener)", "modifiers": "public", "return": "boolean", "signature": "boolean removeEventListener(PeerEventListener listener)", "full_signature": "public boolean removeEventListener(PeerEventListener listener)", "class_method_signature": "PeerGroup.removeEventListener(PeerEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "clearEventListeners", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void clearEventListeners()", "full_signature": "public void clearEventListeners()", "class_method_signature": "PeerGroup.clearEventListeners()", "testcase": false, "constructor": false}, {"identifier": "getConnectedPeers", "parameters": "()", "modifiers": "public", "return": "List<Peer>", "signature": "List<Peer> getConnectedPeers()", "full_signature": "public List<Peer> getConnectedPeers()", "class_method_signature": "PeerGroup.getConnectedPeers()", "testcase": false, "constructor": false}, {"identifier": "getPendingPeers", "parameters": "()", "modifiers": "public", "return": "List<Peer>", "signature": "List<Peer> getPendingPeers()", "full_signature": "public List<Peer> getPendingPeers()", "class_method_signature": "PeerGroup.getPendingPeers()", "testcase": false, "constructor": false}, {"identifier": "addAddress", "parameters": "(PeerAddress peerAddress)", "modifiers": "public", "return": "void", "signature": "void addAddress(PeerAddress peerAddress)", "full_signature": "public void addAddress(PeerAddress peerAddress)", "class_method_signature": "PeerGroup.addAddress(PeerAddress peerAddress)", "testcase": false, "constructor": false}, {"identifier": "addInactive", "parameters": "(PeerAddress peerAddress)", "modifiers": "private", "return": "void", "signature": "void addInactive(PeerAddress peerAddress)", "full_signature": "private void addInactive(PeerAddress peerAddress)", "class_method_signature": "PeerGroup.addInactive(PeerAddress peerAddress)", "testcase": false, "constructor": false}, {"identifier": "addAddress", "parameters": "(InetAddress address)", "modifiers": "public", "return": "void", "signature": "void addAddress(InetAddress address)", "full_signature": "public void addAddress(InetAddress address)", "class_method_signature": "PeerGroup.addAddress(InetAddress address)", "testcase": false, "constructor": false}, {"identifier": "addPeerDiscovery", "parameters": "(PeerDiscovery peerDiscovery)", "modifiers": "public", "return": "void", "signature": "void addPeerDiscovery(PeerDiscovery peerDiscovery)", "full_signature": "public void addPeerDiscovery(PeerDiscovery peerDiscovery)", "class_method_signature": "PeerGroup.addPeerDiscovery(PeerDiscovery peerDiscovery)", "testcase": false, "constructor": false}, {"identifier": "discoverPeers", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void discoverPeers()", "full_signature": "protected void discoverPeers()", "class_method_signature": "PeerGroup.discoverPeers()", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void run()", "full_signature": "@Override protected void run()", "class_method_signature": "PeerGroup.run()", "testcase": false, "constructor": false}, {"identifier": "waitForJobQueue", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void waitForJobQueue()", "full_signature": "@VisibleForTesting void waitForJobQueue()", "class_method_signature": "PeerGroup.waitForJobQueue()", "testcase": false, "constructor": false}, {"identifier": "countConnectedAndPendingPeers", "parameters": "()", "modifiers": "private", "return": "int", "signature": "int countConnectedAndPendingPeers()", "full_signature": "private int countConnectedAndPendingPeers()", "class_method_signature": "PeerGroup.countConnectedAndPendingPeers()", "testcase": false, "constructor": false}, {"identifier": "connectToAnyPeer", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void connectToAnyPeer()", "full_signature": "protected void connectToAnyPeer()", "class_method_signature": "PeerGroup.connectToAnyPeer()", "testcase": false, "constructor": false}, {"identifier": "haveReadyInactivePeer", "parameters": "(long nowMillis)", "modifiers": "private", "return": "boolean", "signature": "boolean haveReadyInactivePeer(long nowMillis)", "full_signature": "private boolean haveReadyInactivePeer(long nowMillis)", "class_method_signature": "PeerGroup.haveReadyInactivePeer(long nowMillis)", "testcase": false, "constructor": false}, {"identifier": "startUp", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void startUp()", "full_signature": "@Override protected void startUp()", "class_method_signature": "PeerGroup.startUp()", "testcase": false, "constructor": false}, {"identifier": "shutDown", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void shutDown()", "full_signature": "@Override protected void shutDown()", "class_method_signature": "PeerGroup.shutDown()", "testcase": false, "constructor": false}, {"identifier": "triggerShutdown", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void triggerShutdown()", "full_signature": "@Override protected void triggerShutdown()", "class_method_signature": "PeerGroup.triggerShutdown()", "testcase": false, "constructor": false}, {"identifier": "addWallet", "parameters": "(Wallet wallet)", "modifiers": "public", "return": "void", "signature": "void addWallet(Wallet wallet)", "full_signature": "public void addWallet(Wallet wallet)", "class_method_signature": "PeerGroup.addWallet(Wallet wallet)", "testcase": false, "constructor": false}, {"identifier": "addPeerFilterProvider", "parameters": "(PeerFilterProvider provider)", "modifiers": "public", "return": "void", "signature": "void addPeerFilterProvider(PeerFilterProvider provider)", "full_signature": "public void addPeerFilterProvider(PeerFilterProvider provider)", "class_method_signature": "PeerGroup.addPeerFilterProvider(PeerFilterProvider provider)", "testcase": false, "constructor": false}, {"identifier": "removeWallet", "parameters": "(Wallet wallet)", "modifiers": "public", "return": "void", "signature": "void removeWallet(Wallet wallet)", "full_signature": "public void removeWallet(Wallet wallet)", "class_method_signature": "PeerGroup.removeWallet(Wallet wallet)", "testcase": false, "constructor": false}, {"identifier": "recalculateFastCatchupAndFilter", "parameters": "(FilterRecalculateMode mode)", "modifiers": "public", "return": "void", "signature": "void recalculateFastCatchupAndFilter(FilterRecalculateMode mode)", "full_signature": "public void recalculateFastCatchupAndFilter(FilterRecalculateMode mode)", "class_method_signature": "PeerGroup.recalculateFastCatchupAndFilter(FilterRecalculateMode mode)", "testcase": false, "constructor": false}, {"identifier": "setBloomFilterFalsePositiveRate", "parameters": "(double bloomFilterFPRate)", "modifiers": "public", "return": "void", "signature": "void setBloomFilterFalsePositiveRate(double bloomFilterFPRate)", "full_signature": "public void setBloomFilterFalsePositiveRate(double bloomFilterFPRate)", "class_method_signature": "PeerGroup.setBloomFilterFalsePositiveRate(double bloomFilterFPRate)", "testcase": false, "constructor": false}, {"identifier": "numConnectedPeers", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int numConnectedPeers()", "full_signature": "public int numConnectedPeers()", "class_method_signature": "PeerGroup.numConnectedPeers()", "testcase": false, "constructor": false}, {"identifier": "connectTo", "parameters": "(InetSocketAddress address)", "modifiers": "@Nullable public", "return": "Peer", "signature": "Peer connectTo(InetSocketAddress address)", "full_signature": "@Nullable public Peer connectTo(InetSocketAddress address)", "class_method_signature": "PeerGroup.connectTo(InetSocketAddress address)", "testcase": false, "constructor": false}, {"identifier": "connectTo", "parameters": "(PeerAddress address, boolean incrementMaxConnections)", "modifiers": "@Nullable protected", "return": "Peer", "signature": "Peer connectTo(PeerAddress address, boolean incrementMaxConnections)", "full_signature": "@Nullable protected Peer connectTo(PeerAddress address, boolean incrementMaxConnections)", "class_method_signature": "PeerGroup.connectTo(PeerAddress address, boolean incrementMaxConnections)", "testcase": false, "constructor": false}, {"identifier": "setConnectTimeoutMillis", "parameters": "(int connectTimeoutMillis)", "modifiers": "public", "return": "void", "signature": "void setConnectTimeoutMillis(int connectTimeoutMillis)", "full_signature": "public void setConnectTimeoutMillis(int connectTimeoutMillis)", "class_method_signature": "PeerGroup.setConnectTimeoutMillis(int connectTimeoutMillis)", "testcase": false, "constructor": false}, {"identifier": "startBlockChainDownload", "parameters": "(PeerEventListener listener)", "modifiers": "public", "return": "void", "signature": "void startBlockChainDownload(PeerEventListener listener)", "full_signature": "public void startBlockChainDownload(PeerEventListener listener)", "class_method_signature": "PeerGroup.startBlockChainDownload(PeerEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "downloadBlockChain", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void downloadBlockChain()", "full_signature": "public void downloadBlockChain()", "class_method_signature": "PeerGroup.downloadBlockChain()", "testcase": false, "constructor": false}, {"identifier": "handleNewPeer", "parameters": "(final Peer peer)", "modifiers": "protected", "return": "void", "signature": "void handleNewPeer(final Peer peer)", "full_signature": "protected void handleNewPeer(final Peer peer)", "class_method_signature": "PeerGroup.handleNewPeer(final Peer peer)", "testcase": false, "constructor": false}, {"identifier": "setupPingingForNewPeer", "parameters": "(final Peer peer)", "modifiers": "private", "return": "void", "signature": "void setupPingingForNewPeer(final Peer peer)", "full_signature": "private void setupPingingForNewPeer(final Peer peer)", "class_method_signature": "PeerGroup.setupPingingForNewPeer(final Peer peer)", "testcase": false, "constructor": false}, {"identifier": "setDownloadPeer", "parameters": "(@Nullable Peer peer)", "modifiers": "private", "return": "void", "signature": "void setDownloadPeer(@Nullable Peer peer)", "full_signature": "private void setDownloadPeer(@Nullable Peer peer)", "class_method_signature": "PeerGroup.setDownloadPeer(@Nullable Peer peer)", "testcase": false, "constructor": false}, {"identifier": "getMemoryPool", "parameters": "()", "modifiers": "public", "return": "MemoryPool", "signature": "MemoryPool getMemoryPool()", "full_signature": "public MemoryPool getMemoryPool()", "class_method_signature": "PeerGroup.getMemoryPool()", "testcase": false, "constructor": false}, {"identifier": "setFastCatchupTimeSecs", "parameters": "(long secondsSinceEpoch)", "modifiers": "public", "return": "void", "signature": "void setFastCatchupTimeSecs(long secondsSinceEpoch)", "full_signature": "public void setFastCatchupTimeSecs(long secondsSinceEpoch)", "class_method_signature": "PeerGroup.setFastCatchupTimeSecs(long secondsSinceEpoch)", "testcase": false, "constructor": false}, {"identifier": "getFastCatchupTimeSecs", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getFastCatchupTimeSecs()", "full_signature": "public long getFastCatchupTimeSecs()", "class_method_signature": "PeerGroup.getFastCatchupTimeSecs()", "testcase": false, "constructor": false}, {"identifier": "handlePeerDeath", "parameters": "(final Peer peer)", "modifiers": "protected", "return": "void", "signature": "void handlePeerDeath(final Peer peer)", "full_signature": "protected void handlePeerDeath(final Peer peer)", "class_method_signature": "PeerGroup.handlePeerDeath(final Peer peer)", "testcase": false, "constructor": false}, {"identifier": "startBlockChainDownloadFromPeer", "parameters": "(Peer peer)", "modifiers": "private", "return": "void", "signature": "void startBlockChainDownloadFromPeer(Peer peer)", "full_signature": "private void startBlockChainDownloadFromPeer(Peer peer)", "class_method_signature": "PeerGroup.startBlockChainDownloadFromPeer(Peer peer)", "testcase": false, "constructor": false}, {"identifier": "waitForPeers", "parameters": "(final int numPeers)", "modifiers": "public", "return": "ListenableFuture<PeerGroup>", "signature": "ListenableFuture<PeerGroup> waitForPeers(final int numPeers)", "full_signature": "public ListenableFuture<PeerGroup> waitForPeers(final int numPeers)", "class_method_signature": "PeerGroup.waitForPeers(final int numPeers)", "testcase": false, "constructor": false}, {"identifier": "getMinBroadcastConnections", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMinBroadcastConnections()", "full_signature": "public int getMinBroadcastConnections()", "class_method_signature": "PeerGroup.getMinBroadcastConnections()", "testcase": false, "constructor": false}, {"identifier": "setMinBroadcastConnections", "parameters": "(int value)", "modifiers": "public", "return": "void", "signature": "void setMinBroadcastConnections(int value)", "full_signature": "public void setMinBroadcastConnections(int value)", "class_method_signature": "PeerGroup.setMinBroadcastConnections(int value)", "testcase": false, "constructor": false}, {"identifier": "broadcastTransaction", "parameters": "(final Transaction tx)", "modifiers": "public", "return": "ListenableFuture<Transaction>", "signature": "ListenableFuture<Transaction> broadcastTransaction(final Transaction tx)", "full_signature": "public ListenableFuture<Transaction> broadcastTransaction(final Transaction tx)", "class_method_signature": "PeerGroup.broadcastTransaction(final Transaction tx)", "testcase": false, "constructor": false}, {"identifier": "broadcastTransaction", "parameters": "(final Transaction tx, final int minConnections)", "modifiers": "public", "return": "ListenableFuture<Transaction>", "signature": "ListenableFuture<Transaction> broadcastTransaction(final Transaction tx, final int minConnections)", "full_signature": "public ListenableFuture<Transaction> broadcastTransaction(final Transaction tx, final int minConnections)", "class_method_signature": "PeerGroup.broadcastTransaction(final Transaction tx, final int minConnections)", "testcase": false, "constructor": false}, {"identifier": "getPingIntervalMsec", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getPingIntervalMsec()", "full_signature": "public long getPingIntervalMsec()", "class_method_signature": "PeerGroup.getPingIntervalMsec()", "testcase": false, "constructor": false}, {"identifier": "setPingIntervalMsec", "parameters": "(long pingIntervalMsec)", "modifiers": "public", "return": "void", "signature": "void setPingIntervalMsec(long pingIntervalMsec)", "full_signature": "public void setPingIntervalMsec(long pingIntervalMsec)", "class_method_signature": "PeerGroup.setPingIntervalMsec(long pingIntervalMsec)", "testcase": false, "constructor": false}, {"identifier": "setMinRequiredProtocolVersion", "parameters": "(int minRequiredProtocolVersion)", "modifiers": "public", "return": "void", "signature": "void setMinRequiredProtocolVersion(int minRequiredProtocolVersion)", "full_signature": "public void setMinRequiredProtocolVersion(int minRequiredProtocolVersion)", "class_method_signature": "PeerGroup.setMinRequiredProtocolVersion(int minRequiredProtocolVersion)", "testcase": false, "constructor": false}, {"identifier": "getMinRequiredProtocolVersion", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMinRequiredProtocolVersion()", "full_signature": "public int getMinRequiredProtocolVersion()", "class_method_signature": "PeerGroup.getMinRequiredProtocolVersion()", "testcase": false, "constructor": false}, {"identifier": "getMostCommonChainHeight", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMostCommonChainHeight()", "full_signature": "public int getMostCommonChainHeight()", "class_method_signature": "PeerGroup.getMostCommonChainHeight()", "testcase": false, "constructor": false}, {"identifier": "getMostCommonChainHeight", "parameters": "(final List<Peer> peers)", "modifiers": "public static", "return": "int", "signature": "int getMostCommonChainHeight(final List<Peer> peers)", "full_signature": "public static int getMostCommonChainHeight(final List<Peer> peers)", "class_method_signature": "PeerGroup.getMostCommonChainHeight(final List<Peer> peers)", "testcase": false, "constructor": false}, {"identifier": "selectDownloadPeer", "parameters": "(List<Peer> peers)", "modifiers": "@Nullable protected", "return": "Peer", "signature": "Peer selectDownloadPeer(List<Peer> peers)", "full_signature": "@Nullable protected Peer selectDownloadPeer(List<Peer> peers)", "class_method_signature": "PeerGroup.selectDownloadPeer(List<Peer> peers)", "testcase": false, "constructor": false}, {"identifier": "getDownloadPeer", "parameters": "()", "modifiers": "public", "return": "Peer", "signature": "Peer getDownloadPeer()", "full_signature": "public Peer getDownloadPeer()", "class_method_signature": "PeerGroup.getDownloadPeer()", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/google/bitcoin/core/PeerGroup.java"}, "focal_method": {"identifier": "waitForJobQueue", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "void", "body": "@VisibleForTesting\n    void waitForJobQueue() {\n        final CountDownLatch latch = new CountDownLatch(1);\n        Uninterruptibles.putUninterruptibly(jobQueue, new Runnable() {\n            @Override\n            public void run() {\n                latch.countDown();\n            }\n        });\n        Uninterruptibles.awaitUninterruptibly(latch);\n    }", "signature": "void waitForJobQueue()", "full_signature": "@VisibleForTesting void waitForJobQueue()", "class_method_signature": "PeerGroup.waitForJobQueue()", "testcase": false, "constructor": false, "invocations": ["putUninterruptibly", "countDown", "awaitUninterruptibly"]}, "repository": {"repo_id": 24363680, "url": "https://github.com/cannabiscoindev/cannabiscoinj", "language": "Java", "is_fork": false, "fork_count": 9, "stargazer_count": 5, "size": 10126, "license": "licensed"}}