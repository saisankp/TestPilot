{"test_class": {"identifier": "TestParentQueue", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Log LOG = LogFactory.getLog(TestParentQueue.class);", "modifier": "private static final", "type": "Log", "declarator": "LOG = LogFactory.getLog(TestParentQueue.class)", "var_name": "LOG"}, {"original_string": "RMContext rmContext;", "modifier": "", "type": "RMContext", "declarator": "rmContext", "var_name": "rmContext"}, {"original_string": "YarnConfiguration conf;", "modifier": "", "type": "YarnConfiguration", "declarator": "conf", "var_name": "conf"}, {"original_string": "CapacitySchedulerConfiguration csConf;", "modifier": "", "type": "CapacitySchedulerConfiguration", "declarator": "csConf", "var_name": "csConf"}, {"original_string": "CapacitySchedulerContext csContext;", "modifier": "", "type": "CapacitySchedulerContext", "declarator": "csContext", "var_name": "csContext"}, {"original_string": "final static int GB = 1024;", "modifier": "final static", "type": "int", "declarator": "GB = 1024", "var_name": "GB"}, {"original_string": "final static String DEFAULT_RACK = \"/default\";", "modifier": "final static", "type": "String", "declarator": "DEFAULT_RACK = \"/default\"", "var_name": "DEFAULT_RACK"}, {"original_string": "private final ResourceCalculator resourceComparator =\n      new DefaultResourceCalculator();", "modifier": "private final", "type": "ResourceCalculator", "declarator": "resourceComparator =\n      new DefaultResourceCalculator()", "var_name": "resourceComparator"}, {"original_string": "private static final String A = \"a\";", "modifier": "private static final", "type": "String", "declarator": "A = \"a\"", "var_name": "A"}, {"original_string": "private static final String B = \"b\";", "modifier": "private static final", "type": "String", "declarator": "B = \"b\"", "var_name": "B"}, {"original_string": "final static float DELTA = 0.0001f;", "modifier": "final static", "type": "float", "declarator": "DELTA = 0.0001f", "var_name": "DELTA"}, {"original_string": "private static final String C = \"c\";", "modifier": "private static final", "type": "String", "declarator": "C = \"c\"", "var_name": "C"}, {"original_string": "private static final String C1 = \"c1\";", "modifier": "private static final", "type": "String", "declarator": "C1 = \"c1\"", "var_name": "C1"}, {"original_string": "private static final String C11 = \"c11\";", "modifier": "private static final", "type": "String", "declarator": "C11 = \"c11\"", "var_name": "C11"}, {"original_string": "private static final String C111 = \"c111\";", "modifier": "private static final", "type": "String", "declarator": "C111 = \"c111\"", "var_name": "C111"}, {"original_string": "private static final String C1111 = \"c1111\";", "modifier": "private static final", "type": "String", "declarator": "C1111 = \"c1111\"", "var_name": "C1111"}, {"original_string": "private static final String D = \"d\";", "modifier": "private static final", "type": "String", "declarator": "D = \"d\"", "var_name": "D"}, {"original_string": "private static final String A1 = \"a1\";", "modifier": "private static final", "type": "String", "declarator": "A1 = \"a1\"", "var_name": "A1"}, {"original_string": "private static final String A2 = \"a2\";", "modifier": "private static final", "type": "String", "declarator": "A2 = \"a2\"", "var_name": "A2"}, {"original_string": "private static final String B1 = \"b1\";", "modifier": "private static final", "type": "String", "declarator": "B1 = \"b1\"", "var_name": "B1"}, {"original_string": "private static final String B2 = \"b2\";", "modifier": "private static final", "type": "String", "declarator": "B2 = \"b2\"", "var_name": "B2"}, {"original_string": "private static final String B3 = \"b3\";", "modifier": "private static final", "type": "String", "declarator": "B3 = \"b3\"", "var_name": "B3"}], "file": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/test/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/TestParentQueue.java"}, "test_case": {"identifier": "testMultiLevelQueues", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testMultiLevelQueues() throws Exception {\n    /*\n     * Structure of queue:\n     *            Root\n     *           ____________\n     *          /    |   \\   \\\n     *         A     B    C   D\n     *       / |   / | \\   \\\n     *      A1 A2 B1 B2 B3  C1\n     *                        \\\n     *                         C11\n     *                           \\\n     *                           C111\n     *                             \\\n     *                              C1111\n     */\n    \n    // Setup queue configs\n    setupMultiLevelQueues(csConf);\n    \n    Map<String, CSQueue> queues = new HashMap<String, CSQueue>();\n    CSQueue root = \n        CapacityScheduler.parseQueue(csContext, csConf, null, \n            CapacitySchedulerConfiguration.ROOT, queues, queues, \n            TestUtils.spyHook);\n    \n    // Setup some nodes\n    final int memoryPerNode = 10;\n    final int coresPerNode = 16;\n    final int numNodes = 3;\n    \n    FiCaSchedulerNode node_0 = \n        TestUtils.getMockNode(\"host_0\", DEFAULT_RACK, 0, memoryPerNode*GB);\n    FiCaSchedulerNode node_1 = \n        TestUtils.getMockNode(\"host_1\", DEFAULT_RACK, 0, memoryPerNode*GB);\n    FiCaSchedulerNode node_2 = \n        TestUtils.getMockNode(\"host_2\", DEFAULT_RACK, 0, memoryPerNode*GB);\n    \n    final Resource clusterResource = \n        Resources.createResource(numNodes * (memoryPerNode*GB), \n            numNodes * coresPerNode);\n    when(csContext.getNumClusterNodes()).thenReturn(numNodes);\n\n    // Start testing\n    CSQueue a = queues.get(A);\n    CSQueue b = queues.get(B);\n    CSQueue c = queues.get(C);\n    CSQueue d = queues.get(D);\n\n    CSQueue a1 = queues.get(A1);\n    CSQueue a2 = queues.get(A2);\n\n    CSQueue b1 = queues.get(B1);\n    CSQueue b2 = queues.get(B2);\n    CSQueue b3 = queues.get(B3);\n\n    // Simulate C returning a container on node_0\n    stubQueueAllocation(a, clusterResource, node_0, 0*GB);\n    stubQueueAllocation(b, clusterResource, node_0, 0*GB);\n    stubQueueAllocation(c, clusterResource, node_0, 1*GB);\n    stubQueueAllocation(d, clusterResource, node_0, 0*GB);\n    root.assignContainers(clusterResource, node_0, \n        new ResourceLimits(clusterResource));\n    verifyQueueMetrics(a, 0*GB, clusterResource);\n    verifyQueueMetrics(b, 0*GB, clusterResource);\n    verifyQueueMetrics(c, 1*GB, clusterResource);\n    verifyQueueMetrics(d, 0*GB, clusterResource);\n    reset(a); reset(b); reset(c);\n\n    // Now get B2 to allocate\n    // A = 0/3, B = 0/15, C = 1/6, D=0/6\n    stubQueueAllocation(a, clusterResource, node_1, 0*GB);\n    stubQueueAllocation(b2, clusterResource, node_1, 4*GB);\n    stubQueueAllocation(c, clusterResource, node_1, 0*GB);\n    root.assignContainers(clusterResource, node_1, \n        new ResourceLimits(clusterResource));\n    verifyQueueMetrics(a, 0*GB, clusterResource);\n    verifyQueueMetrics(b, 4*GB, clusterResource);\n    verifyQueueMetrics(c, 1*GB, clusterResource);\n    reset(a); reset(b); reset(c);\n    \n    // Now get both A1, C & B3 to allocate in right order\n    // A = 0/3, B = 4/15, C = 1/6, D=0/6\n    stubQueueAllocation(a1, clusterResource, node_0, 1*GB);\n    stubQueueAllocation(b3, clusterResource, node_0, 2*GB);\n    stubQueueAllocation(c, clusterResource, node_0, 2*GB);\n    root.assignContainers(clusterResource, node_0, \n        new ResourceLimits(clusterResource));\n    InOrder allocationOrder = inOrder(a, c, b);\n    allocationOrder.verify(a).assignContainers(eq(clusterResource), \n        any(FiCaSchedulerNode.class), anyResourceLimits());\n    allocationOrder.verify(c).assignContainers(eq(clusterResource), \n        any(FiCaSchedulerNode.class), anyResourceLimits());\n    allocationOrder.verify(b).assignContainers(eq(clusterResource), \n        any(FiCaSchedulerNode.class), anyResourceLimits());\n    verifyQueueMetrics(a, 1*GB, clusterResource);\n    verifyQueueMetrics(b, 6*GB, clusterResource);\n    verifyQueueMetrics(c, 3*GB, clusterResource);\n    reset(a); reset(b); reset(c);\n    \n    // Now verify max-capacity\n    // A = 1/3, B = 6/15, C = 3/6, D=0/6\n    // Ensure a1 won't alloc above max-cap although it should get \n    // scheduling opportunity now, right after a2\n    LOG.info(\"here\");\n    ((ParentQueue)a).setMaxCapacity(.1f);  // a should be capped at 3/30\n    stubQueueAllocation(a1, clusterResource, node_2, 1*GB); // shouldn't be \n                                                            // allocated due \n                                                            // to max-cap\n    stubQueueAllocation(a2, clusterResource, node_2, 2*GB);\n    stubQueueAllocation(b3, clusterResource, node_2, 1*GB);\n    stubQueueAllocation(b1, clusterResource, node_2, 1*GB);\n    stubQueueAllocation(c, clusterResource, node_2, 1*GB);\n    root.assignContainers(clusterResource, node_2, \n        new ResourceLimits(clusterResource));\n    allocationOrder = inOrder(a, a2, a1, b, c);\n    allocationOrder.verify(a).assignContainers(eq(clusterResource), \n        any(FiCaSchedulerNode.class), anyResourceLimits());\n    allocationOrder.verify(a2).assignContainers(eq(clusterResource), \n        any(FiCaSchedulerNode.class), anyResourceLimits());\n    allocationOrder.verify(b).assignContainers(eq(clusterResource), \n        any(FiCaSchedulerNode.class), anyResourceLimits());\n    allocationOrder.verify(c).assignContainers(eq(clusterResource), \n        any(FiCaSchedulerNode.class), anyResourceLimits());\n    verifyQueueMetrics(a, 3*GB, clusterResource);\n    verifyQueueMetrics(b, 8*GB, clusterResource);\n    verifyQueueMetrics(c, 4*GB, clusterResource);\n    reset(a); reset(b); reset(c);\n  }", "signature": "void testMultiLevelQueues()", "full_signature": "@Test public void testMultiLevelQueues()", "class_method_signature": "TestParentQueue.testMultiLevelQueues()", "testcase": true, "constructor": false, "invocations": ["setupMultiLevelQueues", "parseQueue", "getMockNode", "getMockNode", "getMockNode", "createResource", "thenReturn", "when", "getNumClusterNodes", "get", "get", "get", "get", "get", "get", "get", "get", "get", "stubQueueAllocation", "stubQueueAllocation", "stubQueueAllocation", "stubQueueAllocation", "assignContainers", "verifyQueueMetrics", "verifyQueueMetrics", "verifyQueueMetrics", "verifyQueueMetrics", "reset", "reset", "reset", "stubQueueAllocation", "stubQueueAllocation", "stubQueueAllocation", "assignContainers", "verifyQueueMetrics", "verifyQueueMetrics", "verifyQueueMetrics", "reset", "reset", "reset", "stubQueueAllocation", "stubQueueAllocation", "stubQueueAllocation", "assignContainers", "inOrder", "assignContainers", "verify", "eq", "any", "anyResourceLimits", "assignContainers", "verify", "eq", "any", "anyResourceLimits", "assignContainers", "verify", "eq", "any", "anyResourceLimits", "verifyQueueMetrics", "verifyQueueMetrics", "verifyQueueMetrics", "reset", "reset", "reset", "info", "setMaxCapacity", "stubQueueAllocation", "stubQueueAllocation", "stubQueueAllocation", "stubQueueAllocation", "stubQueueAllocation", "assignContainers", "inOrder", "assignContainers", "verify", "eq", "any", "anyResourceLimits", "assignContainers", "verify", "eq", "any", "anyResourceLimits", "assignContainers", "verify", "eq", "any", "anyResourceLimits", "assignContainers", "verify", "eq", "any", "anyResourceLimits", "verifyQueueMetrics", "verifyQueueMetrics", "verifyQueueMetrics", "reset", "reset", "reset"]}, "focal_class": {"identifier": "ParentQueue", "superclass": "extends AbstractCSQueue", "interfaces": "", "fields": [{"original_string": "private static final Log LOG = LogFactory.getLog(ParentQueue.class);", "modifier": "private static final", "type": "Log", "declarator": "LOG = LogFactory.getLog(ParentQueue.class)", "var_name": "LOG"}, {"original_string": "protected final Set<CSQueue> childQueues;", "modifier": "protected final", "type": "Set<CSQueue>", "declarator": "childQueues", "var_name": "childQueues"}, {"original_string": "private final boolean rootQueue;", "modifier": "private final", "type": "boolean", "declarator": "rootQueue", "var_name": "rootQueue"}, {"original_string": "final Comparator<CSQueue> queueComparator;", "modifier": "final", "type": "Comparator<CSQueue>", "declarator": "queueComparator", "var_name": "queueComparator"}, {"original_string": "volatile int numApplications;", "modifier": "volatile", "type": "int", "declarator": "numApplications", "var_name": "numApplications"}, {"original_string": "private final CapacitySchedulerContext scheduler;", "modifier": "private final", "type": "CapacitySchedulerContext", "declarator": "scheduler", "var_name": "scheduler"}, {"original_string": "private final RecordFactory recordFactory = \n    RecordFactoryProvider.getRecordFactory(null);", "modifier": "private final", "type": "RecordFactory", "declarator": "recordFactory = \n    RecordFactoryProvider.getRecordFactory(null)", "var_name": "recordFactory"}, {"original_string": "private static float PRECISION = 0.0005f;", "modifier": "private static", "type": "float", "declarator": "PRECISION = 0.0005f", "var_name": "PRECISION"}], "methods": [{"identifier": "ParentQueue", "parameters": "(CapacitySchedulerContext cs, \n      String queueName, CSQueue parent, CSQueue old)", "modifiers": "public", "return": "", "signature": " ParentQueue(CapacitySchedulerContext cs, \n      String queueName, CSQueue parent, CSQueue old)", "full_signature": "public  ParentQueue(CapacitySchedulerContext cs, \n      String queueName, CSQueue parent, CSQueue old)", "class_method_signature": "ParentQueue.ParentQueue(CapacitySchedulerContext cs, \n      String queueName, CSQueue parent, CSQueue old)", "testcase": false, "constructor": true}, {"identifier": "setupQueueConfigs", "parameters": "(Resource clusterResource)", "modifiers": "synchronized", "return": "void", "signature": "void setupQueueConfigs(Resource clusterResource)", "full_signature": "synchronized void setupQueueConfigs(Resource clusterResource)", "class_method_signature": "ParentQueue.setupQueueConfigs(Resource clusterResource)", "testcase": false, "constructor": false}, {"identifier": "setChildQueues", "parameters": "(Collection<CSQueue> childQueues)", "modifiers": "synchronized", "return": "void", "signature": "void setChildQueues(Collection<CSQueue> childQueues)", "full_signature": "synchronized void setChildQueues(Collection<CSQueue> childQueues)", "class_method_signature": "ParentQueue.setChildQueues(Collection<CSQueue> childQueues)", "testcase": false, "constructor": false}, {"identifier": "getQueuePath", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getQueuePath()", "full_signature": "@Override public String getQueuePath()", "class_method_signature": "ParentQueue.getQueuePath()", "testcase": false, "constructor": false}, {"identifier": "getQueueInfo", "parameters": "( \n      boolean includeChildQueues, boolean recursive)", "modifiers": "@Override public synchronized", "return": "QueueInfo", "signature": "QueueInfo getQueueInfo( \n      boolean includeChildQueues, boolean recursive)", "full_signature": "@Override public synchronized QueueInfo getQueueInfo( \n      boolean includeChildQueues, boolean recursive)", "class_method_signature": "ParentQueue.getQueueInfo( \n      boolean includeChildQueues, boolean recursive)", "testcase": false, "constructor": false}, {"identifier": "getUserAclInfo", "parameters": "(\n      UserGroupInformation user)", "modifiers": "private synchronized", "return": "QueueUserACLInfo", "signature": "QueueUserACLInfo getUserAclInfo(\n      UserGroupInformation user)", "full_signature": "private synchronized QueueUserACLInfo getUserAclInfo(\n      UserGroupInformation user)", "class_method_signature": "ParentQueue.getUserAclInfo(\n      UserGroupInformation user)", "testcase": false, "constructor": false}, {"identifier": "getQueueUserAclInfo", "parameters": "(\n      UserGroupInformation user)", "modifiers": "@Override public synchronized", "return": "List<QueueUserACLInfo>", "signature": "List<QueueUserACLInfo> getQueueUserAclInfo(\n      UserGroupInformation user)", "full_signature": "@Override public synchronized List<QueueUserACLInfo> getQueueUserAclInfo(\n      UserGroupInformation user)", "class_method_signature": "ParentQueue.getQueueUserAclInfo(\n      UserGroupInformation user)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String toString()", "full_signature": "public String toString()", "class_method_signature": "ParentQueue.toString()", "testcase": false, "constructor": false}, {"identifier": "reinitialize", "parameters": "(CSQueue newlyParsedQueue,\n      Resource clusterResource)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource)", "full_signature": "@Override public synchronized void reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource)", "class_method_signature": "ParentQueue.reinitialize(CSQueue newlyParsedQueue,\n      Resource clusterResource)", "testcase": false, "constructor": false}, {"identifier": "getQueues", "parameters": "(Set<CSQueue> queues)", "modifiers": "", "return": "Map<String, CSQueue>", "signature": "Map<String, CSQueue> getQueues(Set<CSQueue> queues)", "full_signature": " Map<String, CSQueue> getQueues(Set<CSQueue> queues)", "class_method_signature": "ParentQueue.getQueues(Set<CSQueue> queues)", "testcase": false, "constructor": false}, {"identifier": "submitApplication", "parameters": "(ApplicationId applicationId, String user,\n      String queue)", "modifiers": "@Override public", "return": "void", "signature": "void submitApplication(ApplicationId applicationId, String user,\n      String queue)", "full_signature": "@Override public void submitApplication(ApplicationId applicationId, String user,\n      String queue)", "class_method_signature": "ParentQueue.submitApplication(ApplicationId applicationId, String user,\n      String queue)", "testcase": false, "constructor": false}, {"identifier": "submitApplicationAttempt", "parameters": "(FiCaSchedulerApp application,\n      String userName)", "modifiers": "@Override public", "return": "void", "signature": "void submitApplicationAttempt(FiCaSchedulerApp application,\n      String userName)", "full_signature": "@Override public void submitApplicationAttempt(FiCaSchedulerApp application,\n      String userName)", "class_method_signature": "ParentQueue.submitApplicationAttempt(FiCaSchedulerApp application,\n      String userName)", "testcase": false, "constructor": false}, {"identifier": "finishApplicationAttempt", "parameters": "(FiCaSchedulerApp application,\n      String queue)", "modifiers": "@Override public", "return": "void", "signature": "void finishApplicationAttempt(FiCaSchedulerApp application,\n      String queue)", "full_signature": "@Override public void finishApplicationAttempt(FiCaSchedulerApp application,\n      String queue)", "class_method_signature": "ParentQueue.finishApplicationAttempt(FiCaSchedulerApp application,\n      String queue)", "testcase": false, "constructor": false}, {"identifier": "addApplication", "parameters": "(ApplicationId applicationId,\n      String user)", "modifiers": "private synchronized", "return": "void", "signature": "void addApplication(ApplicationId applicationId,\n      String user)", "full_signature": "private synchronized void addApplication(ApplicationId applicationId,\n      String user)", "class_method_signature": "ParentQueue.addApplication(ApplicationId applicationId,\n      String user)", "testcase": false, "constructor": false}, {"identifier": "finishApplication", "parameters": "(ApplicationId application, String user)", "modifiers": "@Override public", "return": "void", "signature": "void finishApplication(ApplicationId application, String user)", "full_signature": "@Override public void finishApplication(ApplicationId application, String user)", "class_method_signature": "ParentQueue.finishApplication(ApplicationId application, String user)", "testcase": false, "constructor": false}, {"identifier": "removeApplication", "parameters": "(ApplicationId applicationId, \n      String user)", "modifiers": "private synchronized", "return": "void", "signature": "void removeApplication(ApplicationId applicationId, \n      String user)", "full_signature": "private synchronized void removeApplication(ApplicationId applicationId, \n      String user)", "class_method_signature": "ParentQueue.removeApplication(ApplicationId applicationId, \n      String user)", "testcase": false, "constructor": false}, {"identifier": "assignContainers", "parameters": "(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits)", "modifiers": "@Override public synchronized", "return": "CSAssignment", "signature": "CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits)", "full_signature": "@Override public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits)", "class_method_signature": "ParentQueue.assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits)", "testcase": false, "constructor": false}, {"identifier": "canAssign", "parameters": "(Resource clusterResource, FiCaSchedulerNode node)", "modifiers": "private", "return": "boolean", "signature": "boolean canAssign(Resource clusterResource, FiCaSchedulerNode node)", "full_signature": "private boolean canAssign(Resource clusterResource, FiCaSchedulerNode node)", "class_method_signature": "ParentQueue.canAssign(Resource clusterResource, FiCaSchedulerNode node)", "testcase": false, "constructor": false}, {"identifier": "getResourceLimitsOfChild", "parameters": "(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits)", "modifiers": "private", "return": "ResourceLimits", "signature": "ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits)", "full_signature": "private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits)", "class_method_signature": "ParentQueue.getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits)", "testcase": false, "constructor": false}, {"identifier": "assignContainersToChildQueues", "parameters": "(\n      Resource cluster, FiCaSchedulerNode node, ResourceLimits limits)", "modifiers": "private synchronized", "return": "CSAssignment", "signature": "CSAssignment assignContainersToChildQueues(\n      Resource cluster, FiCaSchedulerNode node, ResourceLimits limits)", "full_signature": "private synchronized CSAssignment assignContainersToChildQueues(\n      Resource cluster, FiCaSchedulerNode node, ResourceLimits limits)", "class_method_signature": "ParentQueue.assignContainersToChildQueues(\n      Resource cluster, FiCaSchedulerNode node, ResourceLimits limits)", "testcase": false, "constructor": false}, {"identifier": "getChildQueuesToPrint", "parameters": "()", "modifiers": "", "return": "String", "signature": "String getChildQueuesToPrint()", "full_signature": " String getChildQueuesToPrint()", "class_method_signature": "ParentQueue.getChildQueuesToPrint()", "testcase": false, "constructor": false}, {"identifier": "printChildQueues", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void printChildQueues()", "full_signature": "private void printChildQueues()", "class_method_signature": "ParentQueue.printChildQueues()", "testcase": false, "constructor": false}, {"identifier": "completedContainer", "parameters": "(Resource clusterResource,\n      FiCaSchedulerApp application, FiCaSchedulerNode node, \n      RMContainer rmContainer, ContainerStatus containerStatus, \n      RMContainerEventType event, CSQueue completedChildQueue,\n      boolean sortQueues)", "modifiers": "@Override public", "return": "void", "signature": "void completedContainer(Resource clusterResource,\n      FiCaSchedulerApp application, FiCaSchedulerNode node, \n      RMContainer rmContainer, ContainerStatus containerStatus, \n      RMContainerEventType event, CSQueue completedChildQueue,\n      boolean sortQueues)", "full_signature": "@Override public void completedContainer(Resource clusterResource,\n      FiCaSchedulerApp application, FiCaSchedulerNode node, \n      RMContainer rmContainer, ContainerStatus containerStatus, \n      RMContainerEventType event, CSQueue completedChildQueue,\n      boolean sortQueues)", "class_method_signature": "ParentQueue.completedContainer(Resource clusterResource,\n      FiCaSchedulerApp application, FiCaSchedulerNode node, \n      RMContainer rmContainer, ContainerStatus containerStatus, \n      RMContainerEventType event, CSQueue completedChildQueue,\n      boolean sortQueues)", "testcase": false, "constructor": false}, {"identifier": "updateClusterResource", "parameters": "(Resource clusterResource,\n      ResourceLimits resourceLimits)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void updateClusterResource(Resource clusterResource,\n      ResourceLimits resourceLimits)", "full_signature": "@Override public synchronized void updateClusterResource(Resource clusterResource,\n      ResourceLimits resourceLimits)", "class_method_signature": "ParentQueue.updateClusterResource(Resource clusterResource,\n      ResourceLimits resourceLimits)", "testcase": false, "constructor": false}, {"identifier": "getChildQueues", "parameters": "()", "modifiers": "@Override public synchronized", "return": "List<CSQueue>", "signature": "List<CSQueue> getChildQueues()", "full_signature": "@Override public synchronized List<CSQueue> getChildQueues()", "class_method_signature": "ParentQueue.getChildQueues()", "testcase": false, "constructor": false}, {"identifier": "recoverContainer", "parameters": "(Resource clusterResource,\n      SchedulerApplicationAttempt attempt, RMContainer rmContainer)", "modifiers": "@Override public", "return": "void", "signature": "void recoverContainer(Resource clusterResource,\n      SchedulerApplicationAttempt attempt, RMContainer rmContainer)", "full_signature": "@Override public void recoverContainer(Resource clusterResource,\n      SchedulerApplicationAttempt attempt, RMContainer rmContainer)", "class_method_signature": "ParentQueue.recoverContainer(Resource clusterResource,\n      SchedulerApplicationAttempt attempt, RMContainer rmContainer)", "testcase": false, "constructor": false}, {"identifier": "getActiveUsersManager", "parameters": "()", "modifiers": "@Override public", "return": "ActiveUsersManager", "signature": "ActiveUsersManager getActiveUsersManager()", "full_signature": "@Override public ActiveUsersManager getActiveUsersManager()", "class_method_signature": "ParentQueue.getActiveUsersManager()", "testcase": false, "constructor": false}, {"identifier": "collectSchedulerApplications", "parameters": "(\n      Collection<ApplicationAttemptId> apps)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void collectSchedulerApplications(\n      Collection<ApplicationAttemptId> apps)", "full_signature": "@Override public synchronized void collectSchedulerApplications(\n      Collection<ApplicationAttemptId> apps)", "class_method_signature": "ParentQueue.collectSchedulerApplications(\n      Collection<ApplicationAttemptId> apps)", "testcase": false, "constructor": false}, {"identifier": "attachContainer", "parameters": "(Resource clusterResource,\n      FiCaSchedulerApp application, RMContainer rmContainer)", "modifiers": "@Override public", "return": "void", "signature": "void attachContainer(Resource clusterResource,\n      FiCaSchedulerApp application, RMContainer rmContainer)", "full_signature": "@Override public void attachContainer(Resource clusterResource,\n      FiCaSchedulerApp application, RMContainer rmContainer)", "class_method_signature": "ParentQueue.attachContainer(Resource clusterResource,\n      FiCaSchedulerApp application, RMContainer rmContainer)", "testcase": false, "constructor": false}, {"identifier": "detachContainer", "parameters": "(Resource clusterResource,\n      FiCaSchedulerApp application, RMContainer rmContainer)", "modifiers": "@Override public", "return": "void", "signature": "void detachContainer(Resource clusterResource,\n      FiCaSchedulerApp application, RMContainer rmContainer)", "full_signature": "@Override public void detachContainer(Resource clusterResource,\n      FiCaSchedulerApp application, RMContainer rmContainer)", "class_method_signature": "ParentQueue.detachContainer(Resource clusterResource,\n      FiCaSchedulerApp application, RMContainer rmContainer)", "testcase": false, "constructor": false}, {"identifier": "getNumApplications", "parameters": "()", "modifiers": "public synchronized", "return": "int", "signature": "int getNumApplications()", "full_signature": "public synchronized int getNumApplications()", "class_method_signature": "ParentQueue.getNumApplications()", "testcase": false, "constructor": false}], "file": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java"}, "focal_method": {"identifier": "assignContainers", "parameters": "(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits)", "modifiers": "@Override public synchronized", "return": "CSAssignment", "body": "@Override\n  public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits) {\n    CSAssignment assignment = \n        new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);\n    Set<String> nodeLabels = node.getLabels();\n    \n    // if our queue cannot access this node, just return\n    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels, nodeLabels)) {\n      return assignment;\n    }\n    \n    while (canAssign(clusterResource, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Trying to assign containers to child-queue of \"\n          + getQueueName());\n      }\n      \n      // Are we over maximum-capacity for this queue?\n      // This will also consider parent's limits and also continuous reservation\n      // looking\n      if (!super.canAssignToThisQueue(clusterResource, nodeLabels, resourceLimits,\n          minimumAllocation, Resources.createResource(getMetrics()\n              .getReservedMB(), getMetrics().getReservedVirtualCores()))) {\n        break;\n      }\n      \n      // Schedule\n      CSAssignment assignedToChild = \n          assignContainersToChildQueues(clusterResource, node, resourceLimits);\n      assignment.setType(assignedToChild.getType());\n      \n      // Done if no child-queue assigned anything\n      if (Resources.greaterThan(\n              resourceCalculator, clusterResource, \n              assignedToChild.getResource(), Resources.none())) {\n        // Track resource utilization for the parent-queue\n        super.allocateResource(clusterResource, assignedToChild.getResource(),\n            nodeLabels);\n        \n        // Track resource utilization in this pass of the scheduler\n        Resources.addTo(assignment.getResource(), assignedToChild.getResource());\n        \n        LOG.info(\"assignedContainer\" +\n            \" queue=\" + getQueueName() + \n            \" usedCapacity=\" + getUsedCapacity() +\n            \" absoluteUsedCapacity=\" + getAbsoluteUsedCapacity() +\n            \" used=\" + queueUsage.getUsed() + \n            \" cluster=\" + clusterResource);\n\n      } else {\n        break;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ParentQ=\" + getQueueName()\n          + \" assignedSoFarInThisIteration=\" + assignment.getResource()\n          + \" usedCapacity=\" + getUsedCapacity()\n          + \" absoluteUsedCapacity=\" + getAbsoluteUsedCapacity());\n      }\n\n      // Do not assign more than one container if this isn't the root queue\n      // or if we've already assigned an off-switch container\n      if (!rootQueue || assignment.getType() == NodeType.OFF_SWITCH) {\n        if (LOG.isDebugEnabled()) {\n          if (rootQueue && assignment.getType() == NodeType.OFF_SWITCH) {\n            LOG.debug(\"Not assigning more than one off-switch container,\" +\n                \" assignments so far: \" + assignment);\n          }\n        }\n        break;\n      }\n    } \n    \n    return assignment;\n  }", "signature": "CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits)", "full_signature": "@Override public synchronized CSAssignment assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits)", "class_method_signature": "ParentQueue.assignContainers(Resource clusterResource,\n      FiCaSchedulerNode node, ResourceLimits resourceLimits)", "testcase": false, "constructor": false, "invocations": ["createResource", "getLabels", "checkQueueAccessToNode", "canAssign", "isDebugEnabled", "debug", "getQueueName", "canAssignToThisQueue", "createResource", "getReservedMB", "getMetrics", "getReservedVirtualCores", "getMetrics", "assignContainersToChildQueues", "setType", "getType", "greaterThan", "getResource", "none", "allocateResource", "getResource", "addTo", "getResource", "getResource", "info", "getQueueName", "getUsedCapacity", "getAbsoluteUsedCapacity", "getUsed", "isDebugEnabled", "debug", "getQueueName", "getResource", "getUsedCapacity", "getAbsoluteUsedCapacity", "getType", "isDebugEnabled", "getType", "debug"]}, "repository": {"repo_id": 195808004, "url": "https://github.com/mouzwang/hadoop-2.7.2", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 5, "size": 24927, "license": "licensed"}}