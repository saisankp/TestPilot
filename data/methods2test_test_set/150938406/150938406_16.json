{"test_class": {"identifier": "WeightSampleBatchOpTest", "superclass": "", "interfaces": "", "fields": [], "file": "core/src/test/java/com/alibaba/alink/operator/batch/dataproc/WeightSampleBatchOpTest.java"}, "test_case": {"identifier": "testWithoutReplacement", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testWithoutReplacement() throws Exception {\n        Row[] testArray =\n            new Row[] {\n                Row.of(\"a\", 1.3, 1.1),\n                Row.of(\"b\", 2.5, 0.9),\n                Row.of(\"c\", 100., -0.01),\n                Row.of(\"d\", 100., 100.9),\n                Row.of(\"e\", 1.4, 1.1),\n                Row.of(\"f\", 2.2, 0.9),\n                Row.of(\"g\", 100.1, -0.01),\n                Row.of(\"j\", 100., 100.9)\n            };\n        String[] colnames = new String[] {\"id\", \"weight\", \"col0\"};\n        MemSourceBatchOp inOp = new MemSourceBatchOp(Arrays.asList(testArray), colnames);\n        WeightSampleBatchOp sampleBatchOp = new WeightSampleBatchOp()\n            .setWeightCol(\"weight\")\n            .setRatio(0.3)\n            .linkFrom(inOp);\n\n        Assert.assertEquals(sampleBatchOp.count(), 2);\n    }", "signature": "void testWithoutReplacement()", "full_signature": "@Test public void testWithoutReplacement()", "class_method_signature": "WeightSampleBatchOpTest.testWithoutReplacement()", "testcase": true, "constructor": false, "invocations": ["of", "of", "of", "of", "of", "of", "of", "of", "asList", "linkFrom", "setRatio", "setWeightCol", "assertEquals", "count"]}, "focal_class": {"identifier": "WeightSampleBatchOp", "superclass": "extends BatchOperator<WeightSampleBatchOp>", "interfaces": "implements WeightSampleParams<WeightSampleBatchOp>", "fields": [{"original_string": "private static final long serialVersionUID = 8815784097940967758L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 8815784097940967758L", "var_name": "serialVersionUID"}, {"original_string": "private static String COUNT = \"count\";", "modifier": "private static", "type": "String", "declarator": "COUNT = \"count\"", "var_name": "COUNT"}, {"original_string": "private static String BOUNDS = \"bounds\";", "modifier": "private static", "type": "String", "declarator": "BOUNDS = \"bounds\"", "var_name": "BOUNDS"}], "methods": [{"identifier": "WeightSampleBatchOp", "parameters": "()", "modifiers": "public", "return": "", "signature": " WeightSampleBatchOp()", "full_signature": "public  WeightSampleBatchOp()", "class_method_signature": "WeightSampleBatchOp.WeightSampleBatchOp()", "testcase": false, "constructor": true}, {"identifier": "WeightSampleBatchOp", "parameters": "(Params params)", "modifiers": "public", "return": "", "signature": " WeightSampleBatchOp(Params params)", "full_signature": "public  WeightSampleBatchOp(Params params)", "class_method_signature": "WeightSampleBatchOp.WeightSampleBatchOp(Params params)", "testcase": false, "constructor": true}, {"identifier": "linkFrom", "parameters": "(BatchOperator<?>... inputs)", "modifiers": "@Override public", "return": "WeightSampleBatchOp", "signature": "WeightSampleBatchOp linkFrom(BatchOperator<?>... inputs)", "full_signature": "@Override public WeightSampleBatchOp linkFrom(BatchOperator<?>... inputs)", "class_method_signature": "WeightSampleBatchOp.linkFrom(BatchOperator<?>... inputs)", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/alibaba/alink/operator/batch/dataproc/WeightSampleBatchOp.java"}, "focal_method": {"identifier": "linkFrom", "parameters": "(BatchOperator<?>... inputs)", "modifiers": "@Override public", "return": "WeightSampleBatchOp", "body": "@Override\n    public WeightSampleBatchOp linkFrom(BatchOperator<?>... inputs) {\n        BatchOperator in = checkAndGetFirst(inputs);\n        DataSet<Row> data = in.getDataSet();\n\n        int weightIdx = TableUtil.findColIndexWithAssertAndHint(in.getColNames(), getWeightCol());\n        double ratio = getRatio();\n\n        if(getWithReplacement()) {\n            //TaskId, count, weightSum\n            DataSet<Tuple3<Integer, Integer, Double>> weight = data.mapPartition(\n                new RichMapPartitionFunction<Row, Tuple3<Integer, Integer, Double>>() {\n                    @Override\n                    public void mapPartition(Iterable<Row> values, Collector<Tuple3<Integer, Integer, Double>> out)\n                        throws Exception {\n                        int cnt = 0;\n                        double sum = 0.;\n                        int taskId = getRuntimeContext().getIndexOfThisSubtask();\n                        for (Row row : values) {\n                            double weight = ((Number)row.getField(weightIdx)).doubleValue();\n                            Preconditions.checkArgument(weight > 0 && !Double.isNaN(weight) && Double.isFinite(weight),\n                                \"Weight must be positive!\");\n                            cnt++;\n                            sum += weight;\n                        }\n                        out.collect(Tuple3.of(taskId, cnt, sum));\n                    }\n                });\n\n            DataSet<Tuple2<Integer, double[]>> bounds = weight.reduceGroup(\n                new GroupReduceFunction<Tuple3<Integer, Integer, Double>, Tuple2<Integer, double[]>>() {\n                    @Override\n                    public void reduce(Iterable<Tuple3<Integer, Integer, Double>> values, Collector<Tuple2<Integer, double[]>> out)\n                        throws Exception {\n                        List<Tuple3<Integer, Integer, Double>> list = new ArrayList<>();\n                        values.forEach(list::add);\n                        list.sort(Comparator.comparingDouble(t -> t.f0));\n                        double[] bounds = new double[list.size() + 1];\n                        int cnt = 0;\n                        for(int i = 0; i < list.size(); i++){\n                            bounds[i + 1] = bounds[i] + list.get(i).f2;\n                            cnt += list.get(i).f1;\n                        }\n                        out.collect(Tuple2.of(cnt, bounds));\n                    }\n                });\n\n            final Random random = new Random(0);\n            DataSet<Row> res = data\n                .mapPartition(new RandomSelect(random, ratio, weightIdx))\n                .withBroadcastSet(bounds, BOUNDS);\n\n            this.setOutput(res, in.getSchema());\n        }else {\n            DataSet<Tuple2<Double, Row>> weight = data.mapPartition(\n                new RichMapPartitionFunction<Row, Tuple2<Double, Row>>() {\n                    @Override\n                    public void mapPartition(Iterable<Row> values, Collector<Tuple2<Double, Row>> out)\n                        throws Exception {\n                        Random random = new Random(getRuntimeContext().getIndexOfThisSubtask());\n                        for (Row row : values) {\n                            double weight = ((Number)row.getField(weightIdx)).doubleValue();\n                            Preconditions.checkArgument(weight > 0 && !Double.isNaN(weight) && Double.isFinite(weight),\n                                \"Weight must be positive!\");\n                            double rp = random.nextDouble();\n                            while (rp <= 1e-30) {\n                                rp = random.nextDouble();\n                            }\n                            out.collect(Tuple2.of(Math.log(rp) / weight, row));\n                        }\n                    }\n                }).partitionByRange(0);\n\n            //taskId, count, minValue\n            DataSet<Tuple3<Integer, Integer, Double>> taskCnts = weight.mapPartition(\n                new RichMapPartitionFunction<Tuple2<Double, Row>, Tuple3<Integer, Integer, Double>>() {\n                    @Override\n                    public void mapPartition(Iterable<Tuple2<Double, Row>> values,\n                                             Collector<Tuple3<Integer, Integer, Double>> out) throws Exception {\n                        int taskId = getRuntimeContext().getIndexOfThisSubtask();\n                        int cnt = 0;\n                        double min = Double.MAX_VALUE;\n                        for (Tuple2<Double, Row> t : values) {\n                            min = Math.min(t.f0, min);\n                            cnt++;\n                        }\n                        out.collect(Tuple3.of(taskId, cnt, min));\n                    }\n                });\n\n            DataSet<Row> res = weight.mapPartition(new TopNSelect(ratio))\n                .withBroadcastSet(taskCnts, COUNT);\n\n            this.setOutput(res, in.getSchema());\n        }\n        return this;\n    }", "signature": "WeightSampleBatchOp linkFrom(BatchOperator<?>... inputs)", "full_signature": "@Override public WeightSampleBatchOp linkFrom(BatchOperator<?>... inputs)", "class_method_signature": "WeightSampleBatchOp.linkFrom(BatchOperator<?>... inputs)", "testcase": false, "constructor": false, "invocations": ["checkAndGetFirst", "getDataSet", "findColIndexWithAssertAndHint", "getColNames", "getWeightCol", "getRatio", "getWithReplacement", "mapPartition", "getIndexOfThisSubtask", "getRuntimeContext", "doubleValue", "getField", "checkArgument", "isNaN", "isFinite", "collect", "of", "reduceGroup", "forEach", "sort", "comparingDouble", "size", "size", "get", "get", "collect", "of", "withBroadcastSet", "mapPartition", "setOutput", "getSchema", "partitionByRange", "mapPartition", "getIndexOfThisSubtask", "getRuntimeContext", "doubleValue", "getField", "checkArgument", "isNaN", "isFinite", "nextDouble", "nextDouble", "collect", "of", "log", "mapPartition", "getIndexOfThisSubtask", "getRuntimeContext", "min", "collect", "of", "withBroadcastSet", "mapPartition", "setOutput", "getSchema"]}, "repository": {"repo_id": 150938406, "url": "https://github.com/alibaba/Alink", "stars": 1923, "created": "9/30/2018 6:36:11 AM +00:00", "updates": "2020-01-27T10:24:34+00:00", "fork": "False", "license": "licensed"}}