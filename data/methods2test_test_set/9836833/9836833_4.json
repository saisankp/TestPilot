{"test_class": {"identifier": "TypeHelperTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final String stringedType;", "modifier": "private final", "type": "String", "declarator": "stringedType", "var_name": "stringedType"}, {"original_string": "private final String expectedTypeExpression;", "modifier": "private final", "type": "String", "declarator": "expectedTypeExpression", "var_name": "expectedTypeExpression"}, {"original_string": "private final String expectedTypeDescription;", "modifier": "private final", "type": "String", "declarator": "expectedTypeDescription", "var_name": "expectedTypeDescription"}], "file": "restx-core-annotation-processor/src/test/java/restx/annotations/processor/TypeHelperTest.java"}, "test_case": {"identifier": "should_produce_type_expression", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void should_produce_type_expression() throws Exception {\n        assertThat(TypeHelper.getTypeExpressionFor(this.stringedType)).isEqualTo(this.expectedTypeExpression);\n    }", "signature": "void should_produce_type_expression()", "full_signature": "@Test public void should_produce_type_expression()", "class_method_signature": "TypeHelperTest.should_produce_type_expression()", "testcase": true, "constructor": false, "invocations": ["isEqualTo", "assertThat", "getTypeExpressionFor"]}, "focal_class": {"identifier": "TypeHelper", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static ImmutableList<String> PARSED_TYPES_DELIMITERS = ImmutableList.of(\",\", \"<\", \">\");", "modifier": "private static", "type": "ImmutableList<String>", "declarator": "PARSED_TYPES_DELIMITERS = ImmutableList.of(\",\", \"<\", \">\")", "var_name": "PARSED_TYPES_DELIMITERS"}, {"original_string": "private static ImmutableMap<String, String> TYPE_DESCRIPTION_ALIASES = ImmutableMap.of(\n            Integer.class.getCanonicalName(), \"int\",\n            Iterable.class.getCanonicalName(), \"LIST\",\n            List.class.getCanonicalName(), \"LIST\",\n            Map.class.getCanonicalName(), \"MAP\");", "modifier": "private static", "type": "ImmutableMap<String, String>", "declarator": "TYPE_DESCRIPTION_ALIASES = ImmutableMap.of(\n            Integer.class.getCanonicalName(), \"int\",\n            Iterable.class.getCanonicalName(), \"LIST\",\n            List.class.getCanonicalName(), \"LIST\",\n            Map.class.getCanonicalName(), \"MAP\")", "var_name": "TYPE_DESCRIPTION_ALIASES"}, {"original_string": "private static Pattern guavaOptionalPattern = Pattern.compile(\"\\\\Q\" + Optional.class.getName() + \"<\\\\E(.+)>\");", "modifier": "private static", "type": "Pattern", "declarator": "guavaOptionalPattern = Pattern.compile(\"\\\\Q\" + Optional.class.getName() + \"<\\\\E(.+)>\")", "var_name": "guavaOptionalPattern"}, {"original_string": "private static Pattern java8OptionalPattern = Pattern.compile(\"\\\\Qjava.util.Optional<\\\\E(.+)>\");", "modifier": "private static", "type": "Pattern", "declarator": "java8OptionalPattern = Pattern.compile(\"\\\\Qjava.util.Optional<\\\\E(.+)>\")", "var_name": "java8OptionalPattern"}, {"original_string": "private static Set<String> RAW_TYPES_STR = Sets.newHashSet(\"byte\", \"short\", \"int\", \"long\", \"float\", \"double\", \"boolean\", \"char\");", "modifier": "private static", "type": "Set<String>", "declarator": "RAW_TYPES_STR = Sets.newHashSet(\"byte\", \"short\", \"int\", \"long\", \"float\", \"double\", \"boolean\", \"char\")", "var_name": "RAW_TYPES_STR"}], "methods": [{"identifier": "getTypeExpressionFor", "parameters": "(ParsedType currentParsedType)", "modifiers": "static", "return": "String", "signature": "String getTypeExpressionFor(ParsedType currentParsedType)", "full_signature": "static String getTypeExpressionFor(ParsedType currentParsedType)", "class_method_signature": "TypeHelper.getTypeExpressionFor(ParsedType currentParsedType)", "testcase": false, "constructor": false}, {"identifier": "toTypeDescription", "parameters": "(ParsedType parsedType)", "modifiers": "static", "return": "String", "signature": "String toTypeDescription(ParsedType parsedType)", "full_signature": "static String toTypeDescription(ParsedType parsedType)", "class_method_signature": "TypeHelper.toTypeDescription(ParsedType parsedType)", "testcase": false, "constructor": false}, {"identifier": "parseParameterizedType", "parameters": "(String parameterizedType)", "modifiers": "static", "return": "ParsedType", "signature": "ParsedType parseParameterizedType(String parameterizedType)", "full_signature": "static ParsedType parseParameterizedType(String parameterizedType)", "class_method_signature": "TypeHelper.parseParameterizedType(String parameterizedType)", "testcase": false, "constructor": false}, {"identifier": "toTypeDescription", "parameters": "(String type)", "modifiers": "static", "return": "String", "signature": "String toTypeDescription(String type)", "full_signature": "static String toTypeDescription(String type)", "class_method_signature": "TypeHelper.toTypeDescription(String type)", "testcase": false, "constructor": false}, {"identifier": "getTypeExpressionFor", "parameters": "(String type)", "modifiers": "static", "return": "String", "signature": "String getTypeExpressionFor(String type)", "full_signature": "static String getTypeExpressionFor(String type)", "class_method_signature": "TypeHelper.getTypeExpressionFor(String type)", "testcase": false, "constructor": false}, {"identifier": "isParameterizedType", "parameters": "(String type)", "modifiers": "static", "return": "boolean", "signature": "boolean isParameterizedType(String type)", "full_signature": "static boolean isParameterizedType(String type)", "class_method_signature": "TypeHelper.isParameterizedType(String type)", "testcase": false, "constructor": false}, {"identifier": "rawTypeFrom", "parameters": "(String type)", "modifiers": "static", "return": "String", "signature": "String rawTypeFrom(String type)", "full_signature": "static String rawTypeFrom(String type)", "class_method_signature": "TypeHelper.rawTypeFrom(String type)", "testcase": false, "constructor": false}, {"identifier": "getTypeReferenceExpressionFor", "parameters": "(String type)", "modifiers": "static", "return": "String", "signature": "String getTypeReferenceExpressionFor(String type)", "full_signature": "static String getTypeReferenceExpressionFor(String type)", "class_method_signature": "TypeHelper.getTypeReferenceExpressionFor(String type)", "testcase": false, "constructor": false}, {"identifier": "optionalMatchingTypeOf", "parameters": "(String type)", "modifiers": "public static", "return": "OptionalMatchingType", "signature": "OptionalMatchingType optionalMatchingTypeOf(String type)", "full_signature": "public static OptionalMatchingType optionalMatchingTypeOf(String type)", "class_method_signature": "TypeHelper.optionalMatchingTypeOf(String type)", "testcase": false, "constructor": false}], "file": "restx-core-annotation-processor/src/main/java/restx/annotations/processor/TypeHelper.java"}, "focal_method": {"identifier": "getTypeExpressionFor", "parameters": "(ParsedType currentParsedType)", "modifiers": "static", "return": "String", "body": "static String getTypeExpressionFor(ParsedType currentParsedType) {\n        if(currentParsedType.parameters.isEmpty()) { // We're on a raw type\n            return String.format(\"%s.class\", currentParsedType.className);\n        } else { // We're on a parameterized type\n            return String.format(\"Types.newParameterizedType(%s.class, %s)\",\n                    currentParsedType.className,\n                    FluentIterable.from(currentParsedType.parameters)\n                        .transform(new Function<ParsedType, String>() {\n                            @Override\n                            public String apply(ParsedType param) {\n                                return getTypeExpressionFor(param);\n                            }\n                        }).join(Joiner.on(\", \"))\n                    );\n        }\n    }", "signature": "String getTypeExpressionFor(ParsedType currentParsedType)", "full_signature": "static String getTypeExpressionFor(ParsedType currentParsedType)", "class_method_signature": "TypeHelper.getTypeExpressionFor(ParsedType currentParsedType)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "format", "format", "join", "transform", "from", "getTypeExpressionFor", "on"]}, "repository": {"repo_id": 9836833, "url": "https://github.com/restx/restx", "language": "Java", "is_fork": false, "fork_count": 78, "stargazer_count": 433, "size": 7896, "license": "licensed"}}