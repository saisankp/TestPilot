{"test_class": {"identifier": "RepairRunServiceTest", "superclass": "", "interfaces": "", "fields": [], "file": "src/server/src/test/java/io/cassandrareaper/service/RepairRunServiceTest.java"}, "test_case": {"identifier": "filterSegmentsByNodesTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void filterSegmentsByNodesTest() throws ReaperException {\n    Map<List<String>, List<String>> rangeToEndpoint = Maps.newHashMap();\n    rangeToEndpoint.put(Arrays.asList(\"1\", \"2\"), Arrays.asList(\"node1\", \"node2\", \"node3\"));\n    rangeToEndpoint.put(Arrays.asList(\"2\", \"4\"), Arrays.asList(\"node1\", \"node2\", \"node3\"));\n    rangeToEndpoint.put(Arrays.asList(\"4\", \"6\"), Arrays.asList(\"node1\"));\n    rangeToEndpoint.put(Arrays.asList(\"6\", \"8\"), Arrays.asList(\"node1\", \"node2\"));\n\n    List<Segment> segments = Arrays.asList(\n            Segment.builder().withTokenRange(new RingRange(\"1\", \"2\")).build(),\n            Segment.builder().withTokenRange(new RingRange(\"2\", \"3\")).build(),\n            Segment.builder().withTokenRange(new RingRange(\"3\", \"4\")).build(),\n            Segment.builder().withTokenRange(new RingRange(\"4\", \"5\")).build(),\n            Segment.builder().withTokenRange(new RingRange(\"5\", \"6\")).build(),\n            Segment.builder().withTokenRange(new RingRange(\"6\", \"8\")).build());\n\n    final RepairUnit repairUnit1 = mock(RepairUnit.class);\n    when(repairUnit1.getNodes()).thenReturn(new HashSet<String>(Arrays.asList(\"node3\", \"node2\")));\n\n    final RepairUnit repairUnit2 = mock(RepairUnit.class);\n    when(repairUnit2.getNodes()).thenReturn(new HashSet<String>(Arrays.asList(\"node1\")));\n\n    final RepairUnit repairUnit3 = mock(RepairUnit.class);\n    when(repairUnit3.getNodes()).thenReturn(new HashSet<String>(Arrays.asList(\"node3\")));\n\n    List<Segment> filtered = RepairRunService.filterSegmentsByNodes(\n            segments, repairUnit1, RepairRunService.buildEndpointToRangeMap(rangeToEndpoint));\n\n    assertEquals(filtered.size(), 4);\n\n    filtered = RepairRunService.filterSegmentsByNodes(segments, repairUnit2,\n        RepairRunService.buildEndpointToRangeMap(rangeToEndpoint));\n    assertEquals(filtered.size(), 6);\n\n    filtered = RepairRunService.filterSegmentsByNodes(segments, repairUnit3,\n        RepairRunService.buildEndpointToRangeMap(rangeToEndpoint));\n    assertEquals(filtered.size(), 3);\n\n    final RepairUnit repairUnitWithNoNodes = mock(RepairUnit.class);\n    when(repairUnitWithNoNodes.getNodes()).thenReturn(new HashSet<String>());\n\n    filtered = RepairRunService.filterSegmentsByNodes(segments, repairUnitWithNoNodes,\n        RepairRunService.buildEndpointToRangeMap(rangeToEndpoint));\n    assertEquals(filtered.size(), 6);\n\n  }", "signature": "void filterSegmentsByNodesTest()", "full_signature": "@Test public void filterSegmentsByNodesTest()", "class_method_signature": "RepairRunServiceTest.filterSegmentsByNodesTest()", "testcase": true, "constructor": false, "invocations": ["newHashMap", "put", "asList", "asList", "put", "asList", "asList", "put", "asList", "asList", "put", "asList", "asList", "asList", "build", "withTokenRange", "builder", "build", "withTokenRange", "builder", "build", "withTokenRange", "builder", "build", "withTokenRange", "builder", "build", "withTokenRange", "builder", "build", "withTokenRange", "builder", "mock", "thenReturn", "when", "getNodes", "asList", "mock", "thenReturn", "when", "getNodes", "asList", "mock", "thenReturn", "when", "getNodes", "asList", "filterSegmentsByNodes", "buildEndpointToRangeMap", "assertEquals", "size", "filterSegmentsByNodes", "buildEndpointToRangeMap", "assertEquals", "size", "filterSegmentsByNodes", "buildEndpointToRangeMap", "assertEquals", "size", "mock", "thenReturn", "when", "getNodes", "filterSegmentsByNodes", "buildEndpointToRangeMap", "assertEquals", "size"]}, "focal_class": {"identifier": "RepairRunService", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final Splitter COMMA_SEPARATED_LIST_SPLITTER\n      = Splitter.on(',').trimResults(CharMatcher.anyOf(\" ()[]\\\"'\")).omitEmptyStrings();", "modifier": "public static final", "type": "Splitter", "declarator": "COMMA_SEPARATED_LIST_SPLITTER\n      = Splitter.on(',').trimResults(CharMatcher.anyOf(\" ()[]\\\"'\")).omitEmptyStrings()", "var_name": "COMMA_SEPARATED_LIST_SPLITTER"}, {"original_string": "public static final int DEFAULT_SEGMENT_COUNT_PER_NODE = 16;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_SEGMENT_COUNT_PER_NODE = 16", "var_name": "DEFAULT_SEGMENT_COUNT_PER_NODE"}, {"original_string": "private static final Logger LOG = LoggerFactory.getLogger(RepairRunService.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(RepairRunService.class)", "var_name": "LOG"}, {"original_string": "private final AppContext context;", "modifier": "private final", "type": "AppContext", "declarator": "context", "var_name": "context"}, {"original_string": "private final RepairUnitService repairUnitService;", "modifier": "private final", "type": "RepairUnitService", "declarator": "repairUnitService", "var_name": "repairUnitService"}], "methods": [{"identifier": "RepairRunService", "parameters": "(AppContext context)", "modifiers": "private", "return": "", "signature": " RepairRunService(AppContext context)", "full_signature": "private  RepairRunService(AppContext context)", "class_method_signature": "RepairRunService.RepairRunService(AppContext context)", "testcase": false, "constructor": true}, {"identifier": "create", "parameters": "(AppContext context)", "modifiers": "public static", "return": "RepairRunService", "signature": "RepairRunService create(AppContext context)", "full_signature": "public static RepairRunService create(AppContext context)", "class_method_signature": "RepairRunService.create(AppContext context)", "testcase": false, "constructor": false}, {"identifier": "registerRepairRun", "parameters": "(\n      Cluster cluster,\n      RepairUnit repairUnit,\n      Optional<String> cause,\n      String owner,\n      int segments,\n      int segmentsPerNode,\n      RepairParallelism repairParallelism,\n      Double intensity)", "modifiers": "public", "return": "RepairRun", "signature": "RepairRun registerRepairRun(\n      Cluster cluster,\n      RepairUnit repairUnit,\n      Optional<String> cause,\n      String owner,\n      int segments,\n      int segmentsPerNode,\n      RepairParallelism repairParallelism,\n      Double intensity)", "full_signature": "public RepairRun registerRepairRun(\n      Cluster cluster,\n      RepairUnit repairUnit,\n      Optional<String> cause,\n      String owner,\n      int segments,\n      int segmentsPerNode,\n      RepairParallelism repairParallelism,\n      Double intensity)", "class_method_signature": "RepairRunService.registerRepairRun(\n      Cluster cluster,\n      RepairUnit repairUnit,\n      Optional<String> cause,\n      String owner,\n      int segments,\n      int segmentsPerNode,\n      RepairParallelism repairParallelism,\n      Double intensity)", "testcase": false, "constructor": false}, {"identifier": "generateSegments", "parameters": "(\n      Cluster targetCluster, int segmentCount, int segmentCountPerNode, RepairUnit repairUnit)", "modifiers": "private", "return": "List<Segment>", "signature": "List<Segment> generateSegments(\n      Cluster targetCluster, int segmentCount, int segmentCountPerNode, RepairUnit repairUnit)", "full_signature": "private List<Segment> generateSegments(\n      Cluster targetCluster, int segmentCount, int segmentCountPerNode, RepairUnit repairUnit)", "class_method_signature": "RepairRunService.generateSegments(\n      Cluster targetCluster, int segmentCount, int segmentCountPerNode, RepairUnit repairUnit)", "testcase": false, "constructor": false}, {"identifier": "computeGlobalSegmentCount", "parameters": "(\n      int segmentCountPerNode,\n      Map<String, List<RingRange>> endpointToRange)", "modifiers": "static", "return": "int", "signature": "int computeGlobalSegmentCount(\n      int segmentCountPerNode,\n      Map<String, List<RingRange>> endpointToRange)", "full_signature": "static int computeGlobalSegmentCount(\n      int segmentCountPerNode,\n      Map<String, List<RingRange>> endpointToRange)", "class_method_signature": "RepairRunService.computeGlobalSegmentCount(\n      int segmentCountPerNode,\n      Map<String, List<RingRange>> endpointToRange)", "testcase": false, "constructor": false}, {"identifier": "filterSegmentsByNodes", "parameters": "(\n      List<Segment> segments,\n      RepairUnit repairUnit,\n      Map<String, List<RingRange>> endpointToRange)", "modifiers": "static", "return": "List<Segment>", "signature": "List<Segment> filterSegmentsByNodes(\n      List<Segment> segments,\n      RepairUnit repairUnit,\n      Map<String, List<RingRange>> endpointToRange)", "full_signature": "static List<Segment> filterSegmentsByNodes(\n      List<Segment> segments,\n      RepairUnit repairUnit,\n      Map<String, List<RingRange>> endpointToRange)", "class_method_signature": "RepairRunService.filterSegmentsByNodes(\n      List<Segment> segments,\n      RepairUnit repairUnit,\n      Map<String, List<RingRange>> endpointToRange)", "testcase": false, "constructor": false}, {"identifier": "buildEndpointToRangeMap", "parameters": "(Map<List<String>, List<String>> rangeToEndpoint)", "modifiers": "@VisibleForTesting static", "return": "Map<String, List<RingRange>>", "signature": "Map<String, List<RingRange>> buildEndpointToRangeMap(Map<List<String>, List<String>> rangeToEndpoint)", "full_signature": "@VisibleForTesting static Map<String, List<RingRange>> buildEndpointToRangeMap(Map<List<String>, List<String>> rangeToEndpoint)", "class_method_signature": "RepairRunService.buildEndpointToRangeMap(Map<List<String>, List<String>> rangeToEndpoint)", "testcase": false, "constructor": false}, {"identifier": "buildReplicasToRangeMap", "parameters": "(\n      Map<List<String>, List<String>> rangeToEndpoint)", "modifiers": "@VisibleForTesting static", "return": "Map<List<String>, List<RingRange>>", "signature": "Map<List<String>, List<RingRange>> buildReplicasToRangeMap(\n      Map<List<String>, List<String>> rangeToEndpoint)", "full_signature": "@VisibleForTesting static Map<List<String>, List<RingRange>> buildReplicasToRangeMap(\n      Map<List<String>, List<String>> rangeToEndpoint)", "class_method_signature": "RepairRunService.buildReplicasToRangeMap(\n      Map<List<String>, List<String>> rangeToEndpoint)", "testcase": false, "constructor": false}, {"identifier": "createRepairSegments", "parameters": "(\n      List<Segment> tokenSegments,\n      RepairUnit repairUnit)", "modifiers": "private static", "return": "List<RepairSegment.Builder>", "signature": "List<RepairSegment.Builder> createRepairSegments(\n      List<Segment> tokenSegments,\n      RepairUnit repairUnit)", "full_signature": "private static List<RepairSegment.Builder> createRepairSegments(\n      List<Segment> tokenSegments,\n      RepairUnit repairUnit)", "class_method_signature": "RepairRunService.createRepairSegments(\n      List<Segment> tokenSegments,\n      RepairUnit repairUnit)", "testcase": false, "constructor": false}, {"identifier": "createRepairSegmentsForIncrementalRepair", "parameters": "(\n      Map<String, RingRange> nodes,\n      RepairUnit repairUnit)", "modifiers": "private static", "return": "List<RepairSegment.Builder>", "signature": "List<RepairSegment.Builder> createRepairSegmentsForIncrementalRepair(\n      Map<String, RingRange> nodes,\n      RepairUnit repairUnit)", "full_signature": "private static List<RepairSegment.Builder> createRepairSegmentsForIncrementalRepair(\n      Map<String, RingRange> nodes,\n      RepairUnit repairUnit)", "class_method_signature": "RepairRunService.createRepairSegmentsForIncrementalRepair(\n      Map<String, RingRange> nodes,\n      RepairUnit repairUnit)", "testcase": false, "constructor": false}, {"identifier": "getClusterNodes", "parameters": "(Cluster targetCluster, RepairUnit repairUnit)", "modifiers": "private", "return": "Map<String,RingRange>", "signature": "Map<String,RingRange> getClusterNodes(Cluster targetCluster, RepairUnit repairUnit)", "full_signature": "private Map<String,RingRange> getClusterNodes(Cluster targetCluster, RepairUnit repairUnit)", "class_method_signature": "RepairRunService.getClusterNodes(Cluster targetCluster, RepairUnit repairUnit)", "testcase": false, "constructor": false}, {"identifier": "getTableNamesBasedOnParam", "parameters": "(\n      Cluster cluster,\n      String keyspace,\n      Optional<String> tableNamesParam)", "modifiers": "public", "return": "Set<String>", "signature": "Set<String> getTableNamesBasedOnParam(\n      Cluster cluster,\n      String keyspace,\n      Optional<String> tableNamesParam)", "full_signature": "public Set<String> getTableNamesBasedOnParam(\n      Cluster cluster,\n      String keyspace,\n      Optional<String> tableNamesParam)", "class_method_signature": "RepairRunService.getTableNamesBasedOnParam(\n      Cluster cluster,\n      String keyspace,\n      Optional<String> tableNamesParam)", "testcase": false, "constructor": false}, {"identifier": "getNodesToRepairBasedOnParam", "parameters": "(\n      Cluster cluster,\n      Optional<String> nodesToRepairParam)", "modifiers": "public", "return": "Set<String>", "signature": "Set<String> getNodesToRepairBasedOnParam(\n      Cluster cluster,\n      Optional<String> nodesToRepairParam)", "full_signature": "public Set<String> getNodesToRepairBasedOnParam(\n      Cluster cluster,\n      Optional<String> nodesToRepairParam)", "class_method_signature": "RepairRunService.getNodesToRepairBasedOnParam(\n      Cluster cluster,\n      Optional<String> nodesToRepairParam)", "testcase": false, "constructor": false}, {"identifier": "getDatacentersToRepairBasedOnParam", "parameters": "(Cluster cluster, Optional<String> datacenters)", "modifiers": "public static", "return": "Set<String>", "signature": "Set<String> getDatacentersToRepairBasedOnParam(Cluster cluster, Optional<String> datacenters)", "full_signature": "public static Set<String> getDatacentersToRepairBasedOnParam(Cluster cluster, Optional<String> datacenters)", "class_method_signature": "RepairRunService.getDatacentersToRepairBasedOnParam(Cluster cluster, Optional<String> datacenters)", "testcase": false, "constructor": false}], "file": "src/server/src/main/java/io/cassandrareaper/service/RepairRunService.java"}, "focal_method": {"identifier": "filterSegmentsByNodes", "parameters": "(\n      List<Segment> segments,\n      RepairUnit repairUnit,\n      Map<String, List<RingRange>> endpointToRange)", "modifiers": "static", "return": "List<Segment>", "body": "static List<Segment> filterSegmentsByNodes(\n      List<Segment> segments,\n      RepairUnit repairUnit,\n      Map<String, List<RingRange>> endpointToRange) {\n\n    if (repairUnit.getNodes().isEmpty()) {\n      return segments;\n    } else {\n      return segments\n          .stream()\n          .filter(\n              segment -> {\n                RingRange firstRange = segment.getBaseRange();\n                for (Entry<String, List<RingRange>> entry : endpointToRange.entrySet()) {\n                  if (repairUnit.getNodes().contains(entry.getKey())) {\n                    for (RingRange range : entry.getValue()) {\n                      if (range.encloses(firstRange)) {\n                        return true;\n                      }\n                    }\n                  }\n                }\n                return false;\n              })\n          .collect(Collectors.toList());\n    }\n  }", "signature": "List<Segment> filterSegmentsByNodes(\n      List<Segment> segments,\n      RepairUnit repairUnit,\n      Map<String, List<RingRange>> endpointToRange)", "full_signature": "static List<Segment> filterSegmentsByNodes(\n      List<Segment> segments,\n      RepairUnit repairUnit,\n      Map<String, List<RingRange>> endpointToRange)", "class_method_signature": "RepairRunService.filterSegmentsByNodes(\n      List<Segment> segments,\n      RepairUnit repairUnit,\n      Map<String, List<RingRange>> endpointToRange)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "getNodes", "collect", "filter", "stream", "getBaseRange", "entrySet", "contains", "getNodes", "getKey", "getValue", "encloses", "toList"]}, "repository": {"repo_id": 70856121, "url": "https://github.com/thelastpickle/cassandra-reaper", "language": "Java", "is_fork": false, "fork_count": 156, "stargazer_count": 353, "size": 43662, "license": "licensed"}}