{"test_class": {"identifier": "ImmutableItemCacheTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final ImmutableItemManager<Id, Item> ITEM_READER =\n        new ImmutableItemManager<Id, Item>()\n        {\n            public Item getItemForCache(Id id)\n            {\n                return new Item(id);\n            }\n\n            @Override\n            public void cleanupItemEvictedFromCache(Item item) throws IOException, InterruptedException\n            {\n            }\n        };", "modifier": "private static final", "type": "ImmutableItemManager<Id, Item>", "declarator": "ITEM_READER =\n        new ImmutableItemManager<Id, Item>()\n        {\n            public Item getItemForCache(Id id)\n            {\n                return new Item(id);\n            }\n\n            @Override\n            public void cleanupItemEvictedFromCache(Item item) throws IOException, InterruptedException\n            {\n            }\n        }", "var_name": "ITEM_READER"}], "file": "zava/src/test/java/com/github/geophile/erdo/immutableitemcache/ImmutableItemCacheTest.java"}, "test_case": {"identifier": "testUnableToEvict", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testUnableToEvict() throws InterruptedException, IOException\n    {\n        final int CACHE_SIZE = 10;\n        ImmutableItemCache<Id, Item> cache = new ImmutableItemCache<>(CACHE_SIZE);\n        // Load cache and mark everything non-evictable\n        int id = 0;\n        while (id < CACHE_SIZE) {\n            Item item = cache.find(id(id), ITEM_READER);\n            item.okToEvict(false);\n            id++;\n        }\n        try {\n            cache.find(id(CACHE_SIZE), ITEM_READER);\n            fail();\n        } catch (ImmutableItemCacheError e) {\n        }\n    }", "signature": "void testUnableToEvict()", "full_signature": "@Test public void testUnableToEvict()", "class_method_signature": "ImmutableItemCacheTest.testUnableToEvict()", "testcase": true, "constructor": false, "invocations": ["find", "id", "okToEvict", "find", "id", "fail"]}, "focal_class": {"identifier": "ImmutableItemCache", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final int cacheCapacity;", "modifier": "private final", "type": "int", "declarator": "cacheCapacity", "var_name": "cacheCapacity"}, {"original_string": "private final Map<ID, CacheEntry<ID, ITEM>> cache;", "modifier": "private final", "type": "Map<ID, CacheEntry<ID, ITEM>>", "declarator": "cache", "var_name": "cache"}, {"original_string": "private volatile int cacheSize = 0;", "modifier": "private volatile", "type": "int", "declarator": "cacheSize = 0", "var_name": "cacheSize"}, {"original_string": "private final CacheEntryList<ID, ITEM> clock;", "modifier": "private final", "type": "CacheEntryList<ID, ITEM>", "declarator": "clock", "var_name": "clock"}], "methods": [{"identifier": "find", "parameters": "(ID id, ImmutableItemManager<ID, ITEM> itemManager)", "modifiers": "public", "return": "ITEM", "signature": "ITEM find(ID id, ImmutableItemManager<ID, ITEM> itemManager)", "full_signature": "public ITEM find(ID id, ImmutableItemManager<ID, ITEM> itemManager)", "class_method_signature": "ImmutableItemCache.find(ID id, ImmutableItemManager<ID, ITEM> itemManager)", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int size()", "full_signature": "public int size()", "class_method_signature": "ImmutableItemCache.size()", "testcase": false, "constructor": false}, {"identifier": "ImmutableItemCache", "parameters": "(int cacheCapacity)", "modifiers": "public", "return": "", "signature": " ImmutableItemCache(int cacheCapacity)", "full_signature": "public  ImmutableItemCache(int cacheCapacity)", "class_method_signature": "ImmutableItemCache.ImmutableItemCache(int cacheCapacity)", "testcase": false, "constructor": true}, {"identifier": "ImmutableItemCache", "parameters": "(int cacheCapacity, CacheEntryList.Observer<ID, ITEM> observer)", "modifiers": "public", "return": "", "signature": " ImmutableItemCache(int cacheCapacity, CacheEntryList.Observer<ID, ITEM> observer)", "full_signature": "public  ImmutableItemCache(int cacheCapacity, CacheEntryList.Observer<ID, ITEM> observer)", "class_method_signature": "ImmutableItemCache.ImmutableItemCache(int cacheCapacity, CacheEntryList.Observer<ID, ITEM> observer)", "testcase": false, "constructor": true}, {"identifier": "cacheContents", "parameters": "()", "modifiers": "", "return": "Map<ID, CacheEntry<ID, ITEM>>", "signature": "Map<ID, CacheEntry<ID, ITEM>> cacheContents()", "full_signature": " Map<ID, CacheEntry<ID, ITEM>> cacheContents()", "class_method_signature": "ImmutableItemCache.cacheContents()", "testcase": false, "constructor": false}, {"identifier": "clear", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void clear()", "full_signature": "public void clear()", "class_method_signature": "ImmutableItemCache.clear()", "testcase": false, "constructor": false}], "file": "zava/src/main/java/com/github/geophile/erdo/immutableitemcache/ImmutableItemCache.java"}, "focal_method": {"identifier": "find", "parameters": "(ID id, ImmutableItemManager<ID, ITEM> itemManager)", "modifiers": "public", "return": "ITEM", "body": "public ITEM find(ID id, ImmutableItemManager<ID, ITEM> itemManager) throws InterruptedException, IOException\n    {\n        ITEM item;\n        boolean cleanupPlaceholder = false;\n        CacheEntry<ID, ITEM> entry = cache.get(id);\n        if (entry != null && !entry.placeholder()) {\n            entry.recentAccess(true);\n            item = entry.item();\n        } else {\n            try {\n                synchronized (this) {\n                    while ((entry = cache.get(id)) != null && entry.placeholder()) {\n                        wait();\n                    }\n                    if (entry == null) {\n                        assert cacheSize <= cacheCapacity;\n                        if (cacheSize == cacheCapacity) {\n                            // Cache is full. Evict something.\n                            ITEM victim = clock.takeItemToEvict();\n                            assert victim != null;\n                            CacheEntry<ID, ITEM> removed = cache.remove(victim.id());\n                            assert removed == victim : String.format(\"replaced: %s, entry: %s\", removed, entry);\n                            itemManager.cleanupItemEvictedFromCache(victim);\n                            cacheSize--;\n                        }\n                        assert cacheSize < cacheCapacity;\n                        entry = ItemPlaceholder.<ID, ITEM>forCurrentThread();\n                        CacheEntry<ID, ITEM> replaced = cache.put(id, entry);\n                        assert replaced == null;\n                        cacheSize++;\n                    } else {\n                        assert !entry.placeholder();\n                        assert entry.id().equals(id);\n                        entry.recentAccess(true);\n                    }\n                }\n                if (entry.placeholder()) {\n                    // This thread wrote a placeholder. Read the cache item outside the lock, since this\n                    // is probably slow.\n                    assert entry.owner() == Thread.currentThread();\n                    item = itemManager.getItemForCache(id);\n                    // Inside the lock, replace the placeholder with the item, and notify waiters.\n                    synchronized (this) {\n                        CacheEntry<ID, ITEM> replaced = cache.put(id, item);\n                        assert replaced == entry : String.format(\"replaced: %s, entry: %s\", replaced, entry);\n                        clock.addItem(item);\n                        item.recentAccess(true);\n                        notifyAll();\n                    }\n                } else {\n                    entry.recentAccess(true);\n                    item = entry.item();\n                }\n            } catch (RuntimeException | Error e) {\n                cleanupPlaceholder = true;\n                throw e;\n            } finally {\n                if (cleanupPlaceholder) {\n                    synchronized (this) {\n                        entry = cache.get(id);\n                        if (entry != null && entry.placeholder()) {\n                            cache.remove(id);\n                        }\n                    }\n                }\n            }\n        }\n        assert item.id().equals(id);\n        return item;\n    }", "signature": "ITEM find(ID id, ImmutableItemManager<ID, ITEM> itemManager)", "full_signature": "public ITEM find(ID id, ImmutableItemManager<ID, ITEM> itemManager)", "class_method_signature": "ImmutableItemCache.find(ID id, ImmutableItemManager<ID, ITEM> itemManager)", "testcase": false, "constructor": false, "invocations": ["get", "placeholder", "recentAccess", "item", "get", "placeholder", "wait", "takeItemToEvict", "remove", "id", "format", "cleanupItemEvictedFromCache", "forCurrentThread", "put", "placeholder", "equals", "id", "recentAccess", "placeholder", "owner", "currentThread", "getItemForCache", "put", "format", "addItem", "recentAccess", "notifyAll", "recentAccess", "item", "get", "placeholder", "remove", "equals", "id"]}, "repository": {"repo_id": 33645537, "url": "https://github.com/zqhxuyuan/tutorials", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 5, "size": 35273, "license": "licensed"}}