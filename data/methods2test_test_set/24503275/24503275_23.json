{"test_class": {"identifier": "RLPTest", "superclass": "", "interfaces": "", "fields": [], "file": "ethereumj-core/src/test/java/org/ethereum/util/RLPTest.java"}, "test_case": {"identifier": "testRlpEncode", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testRlpEncode() {\n\t\n\t\tassertEquals(result01, Hex.toHexString(RLP.encode(test01)));\n\t\tassertEquals(result02, Hex.toHexString(RLP.encode(test02)));\n\t\tassertEquals(result03, Hex.toHexString(RLP.encode(test03)));\n\t\tassertEquals(result04, Hex.toHexString(RLP.encode(test04)));\n\t\tassertEquals(result05, Hex.toHexString(RLP.encode(test05)));\n\t\tassertEquals(result06, Hex.toHexString(RLP.encode(test06)));\n\t\tassertEquals(result07, Hex.toHexString(RLP.encode(test07)));\n\t\tassertEquals(result08, Hex.toHexString(RLP.encode(test08)));\n\t\tassertEquals(result09, Hex.toHexString(RLP.encode(test09)));\n\t\tassertEquals(result10, Hex.toHexString(RLP.encode(test10)));\n\t\tassertEquals(result11, Hex.toHexString(RLP.encode(test11)));\n\t\tassertEquals(result12, Hex.toHexString(RLP.encode(test12)));\n\t\tassertEquals(result13, Hex.toHexString(RLP.encode(test13)));\n\t\tassertEquals(result14, Hex.toHexString(RLP.encode(test14)));\n\t\tassertEquals(result15, Hex.toHexString(RLP.encode(test15)));\n\t\tassertEquals(result16, Hex.toHexString(RLP.encode(test16)));\n\t}", "signature": "void testRlpEncode()", "full_signature": "@Test public void testRlpEncode()", "class_method_signature": "RLPTest.testRlpEncode()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode", "assertEquals", "toHexString", "encode"]}, "focal_class": {"identifier": "RLP", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static double MAX_ITEM_LENGTH = Math.pow(256, 8);", "modifier": "private static", "type": "double", "declarator": "MAX_ITEM_LENGTH = Math.pow(256, 8)", "var_name": "MAX_ITEM_LENGTH"}, {"original_string": "private static int SIZE_THRESHOLD = 56;", "modifier": "private static", "type": "int", "declarator": "SIZE_THRESHOLD = 56", "var_name": "SIZE_THRESHOLD"}, {"original_string": "private static int OFFSET_SHORT_ITEM = 0x80;", "modifier": "private static", "type": "int", "declarator": "OFFSET_SHORT_ITEM = 0x80", "var_name": "OFFSET_SHORT_ITEM"}, {"original_string": "private static int OFFSET_LONG_ITEM = 0xb7;", "modifier": "private static", "type": "int", "declarator": "OFFSET_LONG_ITEM = 0xb7", "var_name": "OFFSET_LONG_ITEM"}, {"original_string": "private static int OFFSET_SHORT_LIST = 0xc0;", "modifier": "private static", "type": "int", "declarator": "OFFSET_SHORT_LIST = 0xc0", "var_name": "OFFSET_SHORT_LIST"}, {"original_string": "private static int OFFSET_LONG_LIST = 0xf7;", "modifier": "private static", "type": "int", "declarator": "OFFSET_LONG_LIST = 0xf7", "var_name": "OFFSET_LONG_LIST"}], "methods": [{"identifier": "decodeOneByteItem", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "byte", "signature": "byte decodeOneByteItem(byte[] data, int index)", "full_signature": "private static byte decodeOneByteItem(byte[] data, int index)", "class_method_signature": "RLP.decodeOneByteItem(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeInt", "parameters": "(byte[] data, int index)", "modifiers": "public static", "return": "int", "signature": "int decodeInt(byte[] data, int index)", "full_signature": "public static int decodeInt(byte[] data, int index)", "class_method_signature": "RLP.decodeInt(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeShort", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "short", "signature": "short decodeShort(byte[] data, int index)", "full_signature": "private static short decodeShort(byte[] data, int index)", "class_method_signature": "RLP.decodeShort(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeLong", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "long", "signature": "long decodeLong(byte[] data, int index)", "full_signature": "private static long decodeLong(byte[] data, int index)", "class_method_signature": "RLP.decodeLong(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeStringItem", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "String", "signature": "String decodeStringItem(byte[] data, int index)", "full_signature": "private static String decodeStringItem(byte[] data, int index)", "class_method_signature": "RLP.decodeStringItem(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeItemBytes", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] decodeItemBytes(byte[] data, int index)", "full_signature": "private static byte[] decodeItemBytes(byte[] data, int index)", "class_method_signature": "RLP.decodeItemBytes(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeBigInteger", "parameters": "(byte[] data, int index)", "modifiers": "public static", "return": "BigInteger", "signature": "BigInteger decodeBigInteger(byte[] data, int index)", "full_signature": "public static BigInteger decodeBigInteger(byte[] data, int index)", "class_method_signature": "RLP.decodeBigInteger(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeByteArray", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] decodeByteArray(byte[] data, int index)", "full_signature": "private static byte[] decodeByteArray(byte[] data, int index)", "class_method_signature": "RLP.decodeByteArray(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "nextItemLength", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "int", "signature": "int nextItemLength(byte[] data, int index)", "full_signature": "private static int nextItemLength(byte[] data, int index)", "class_method_signature": "RLP.nextItemLength(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeIP4Bytes", "parameters": "(byte[] data, int index)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] decodeIP4Bytes(byte[] data, int index)", "full_signature": "public static byte[] decodeIP4Bytes(byte[] data, int index)", "class_method_signature": "RLP.decodeIP4Bytes(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "getFirstListElement", "parameters": "(byte[] payload, int pos)", "modifiers": "public static", "return": "int", "signature": "int getFirstListElement(byte[] payload, int pos)", "full_signature": "public static int getFirstListElement(byte[] payload, int pos)", "class_method_signature": "RLP.getFirstListElement(byte[] payload, int pos)", "testcase": false, "constructor": false}, {"identifier": "getNextElementIndex", "parameters": "(byte[] payload, int pos)", "modifiers": "public static", "return": "int", "signature": "int getNextElementIndex(byte[] payload, int pos)", "full_signature": "public static int getNextElementIndex(byte[] payload, int pos)", "class_method_signature": "RLP.getNextElementIndex(byte[] payload, int pos)", "testcase": false, "constructor": false}, {"identifier": "fullTraverse", "parameters": "(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "modifiers": "public static", "return": "void", "signature": "void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "full_signature": "public static void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "class_method_signature": "RLP.fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "testcase": false, "constructor": false}, {"identifier": "calcLength", "parameters": "(int lengthOfLength, byte[] msgData, int pos)", "modifiers": "private static", "return": "int", "signature": "int calcLength(int lengthOfLength, byte[] msgData, int pos)", "full_signature": "private static int calcLength(int lengthOfLength, byte[] msgData, int pos)", "class_method_signature": "RLP.calcLength(int lengthOfLength, byte[] msgData, int pos)", "testcase": false, "constructor": false}, {"identifier": "calcLengthRaw", "parameters": "(int lengthOfLength, byte[] msgData, int index)", "modifiers": "private static", "return": "int", "signature": "int calcLengthRaw(int lengthOfLength, byte[] msgData, int index)", "full_signature": "private static int calcLengthRaw(int lengthOfLength, byte[] msgData, int index)", "class_method_signature": "RLP.calcLengthRaw(int lengthOfLength, byte[] msgData, int index)", "testcase": false, "constructor": false}, {"identifier": "getCommandCode", "parameters": "(byte[] data)", "modifiers": "public static", "return": "byte", "signature": "byte getCommandCode(byte[] data)", "full_signature": "public static byte getCommandCode(byte[] data)", "class_method_signature": "RLP.getCommandCode(byte[] data)", "testcase": false, "constructor": false}, {"identifier": "decode2", "parameters": "(byte[] msgData)", "modifiers": "public static", "return": "RLPList", "signature": "RLPList decode2(byte[] msgData)", "full_signature": "public static RLPList decode2(byte[] msgData)", "class_method_signature": "RLP.decode2(byte[] msgData)", "testcase": false, "constructor": false}, {"identifier": "fullTraverse", "parameters": "(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "modifiers": "private static", "return": "void", "signature": "void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "full_signature": "private static void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "class_method_signature": "RLP.fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(byte[] data, int pos)", "modifiers": "public static", "return": "DecodeResult", "signature": "DecodeResult decode(byte[] data, int pos)", "full_signature": "public static DecodeResult decode(byte[] data, int pos)", "class_method_signature": "RLP.decode(byte[] data, int pos)", "testcase": false, "constructor": false}, {"identifier": "decodeList", "parameters": "(byte[] data, int pos, int prevPos, int len)", "modifiers": "private static", "return": "DecodeResult", "signature": "DecodeResult decodeList(byte[] data, int pos, int prevPos, int len)", "full_signature": "private static DecodeResult decodeList(byte[] data, int pos, int prevPos, int len)", "class_method_signature": "RLP.decodeList(byte[] data, int pos, int prevPos, int len)", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(Object input)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encode(Object input)", "full_signature": "public static byte[] encode(Object input)", "class_method_signature": "RLP.encode(Object input)", "testcase": false, "constructor": false}, {"identifier": "encodeLength", "parameters": "(int length, int offset)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeLength(int length, int offset)", "full_signature": "public static byte[] encodeLength(int length, int offset)", "class_method_signature": "RLP.encodeLength(int length, int offset)", "testcase": false, "constructor": false}, {"identifier": "encodeByte", "parameters": "(byte singleByte)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeByte(byte singleByte)", "full_signature": "public static byte[] encodeByte(byte singleByte)", "class_method_signature": "RLP.encodeByte(byte singleByte)", "testcase": false, "constructor": false}, {"identifier": "encodeShort", "parameters": "(short singleShort)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeShort(short singleShort)", "full_signature": "public static byte[] encodeShort(short singleShort)", "class_method_signature": "RLP.encodeShort(short singleShort)", "testcase": false, "constructor": false}, {"identifier": "encodeInt", "parameters": "(int singleInt)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeInt(int singleInt)", "full_signature": "public static byte[] encodeInt(int singleInt)", "class_method_signature": "RLP.encodeInt(int singleInt)", "testcase": false, "constructor": false}, {"identifier": "encodeString", "parameters": "(String srcString)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeString(String srcString)", "full_signature": "public static byte[] encodeString(String srcString)", "class_method_signature": "RLP.encodeString(String srcString)", "testcase": false, "constructor": false}, {"identifier": "encodeBigInteger", "parameters": "(BigInteger srcBigInteger)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeBigInteger(BigInteger srcBigInteger)", "full_signature": "public static byte[] encodeBigInteger(BigInteger srcBigInteger)", "class_method_signature": "RLP.encodeBigInteger(BigInteger srcBigInteger)", "testcase": false, "constructor": false}, {"identifier": "encodeElement", "parameters": "(byte[] srcData)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeElement(byte[] srcData)", "full_signature": "public static byte[] encodeElement(byte[] srcData)", "class_method_signature": "RLP.encodeElement(byte[] srcData)", "testcase": false, "constructor": false}, {"identifier": "encodeList", "parameters": "(byte[]... elements)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeList(byte[]... elements)", "full_signature": "public static byte[] encodeList(byte[]... elements)", "class_method_signature": "RLP.encodeList(byte[]... elements)", "testcase": false, "constructor": false}, {"identifier": "toBytes", "parameters": "(Object input)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] toBytes(Object input)", "full_signature": "private static byte[] toBytes(Object input)", "class_method_signature": "RLP.toBytes(Object input)", "testcase": false, "constructor": false}], "file": "ethereumj-core/src/main/java/org/ethereum/util/RLP.java"}, "focal_method": {"identifier": "encode", "parameters": "(Object input)", "modifiers": "public static", "return": "byte[]", "body": "public static byte[] encode(Object input) {\n\t\tValue val = new Value(input);\n\t\tif (val.isList()) {\n\t\t\tList<Object> inputArray = val.asList();\n\t\t\tif (inputArray.size() == 0) {\n\t\t\t\treturn encodeLength(inputArray.size(), OFFSET_SHORT_LIST);\n\t\t\t}\n\t\t\tbyte[] output = ByteUtil.EMPTY_BYTE_ARRAY;\n\t\t\tfor (Object object : inputArray) {\n\t\t\t\toutput = concatenate(output, encode(object));\n\t\t\t}\n\t\t\tbyte[] prefix = encodeLength(output.length, OFFSET_SHORT_LIST);\n            return concatenate(prefix, output);\n\t\t} else {\n\t\t\tbyte[] inputAsBytes = toBytes(input); \n\t\t\tif (inputAsBytes.length == 1) {\n\t\t\t\treturn inputAsBytes;\n\t\t\t} else {\n\t\t\t\tbyte[] firstByte = encodeLength(inputAsBytes.length, OFFSET_SHORT_ITEM);\t\t\t\t\n\t\t\t\treturn concatenate(firstByte, inputAsBytes);\n\t\t\t}\n\t\t} \n\t}", "signature": "byte[] encode(Object input)", "full_signature": "public static byte[] encode(Object input)", "class_method_signature": "RLP.encode(Object input)", "testcase": false, "constructor": false, "invocations": ["isList", "asList", "size", "encodeLength", "size", "concatenate", "encode", "encodeLength", "concatenate", "toBytes", "encodeLength", "concatenate"]}, "repository": {"repo_id": 24503275, "url": "https://github.com/ethereumj/ethereumj", "language": "Java", "is_fork": false, "fork_count": 22, "stargazer_count": 27, "size": 13884, "license": "licensed"}}