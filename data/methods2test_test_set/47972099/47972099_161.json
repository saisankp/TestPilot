{"test_class": {"identifier": "CsvInputFormatTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Path PATH = new Path(\"an/ignored/file/\");", "modifier": "private static final", "type": "Path", "declarator": "PATH = new Path(\"an/ignored/file/\")", "var_name": "PATH"}, {"original_string": "private static final String FIRST_PART = \"That is the first part\";", "modifier": "private static final", "type": "String", "declarator": "FIRST_PART = \"That is the first part\"", "var_name": "FIRST_PART"}, {"original_string": "private static final String SECOND_PART = \"That is the second part\";", "modifier": "private static final", "type": "String", "declarator": "SECOND_PART = \"That is the second part\"", "var_name": "SECOND_PART"}], "file": "flink-java/src/test/java/org/apache/flink/api/java/io/CsvInputFormatTest.java"}, "test_case": {"identifier": "testPojoTypeWithInvalidFieldMapping", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testPojoTypeWithInvalidFieldMapping() throws Exception {\n\t\tFile tempFile = File.createTempFile(\"CsvReaderPojoType\", \"tmp\");\n\t\ttempFile.deleteOnExit();\n\t\ttempFile.setWritable(true);\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tPojoTypeInfo<PojoItem> typeInfo = (PojoTypeInfo<PojoItem>) TypeExtractor.createTypeInfo(PojoItem.class);\n\n\t\ttry {\n\t\t\tnew PojoCsvInputFormat<PojoItem>(new Path(tempFile.toURI().toString()), typeInfo, new String[]{\"field1\", \"field2\"});\n\t\t\tfail(\"The number of POJO fields cannot be same as that of selected CSV fields\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t\t// success\n\t\t}\n\n\t\ttry {\n\t\t\tnew PojoCsvInputFormat<PojoItem>(new Path(tempFile.toURI().toString()), typeInfo, new String[]{\"field1\", \"field2\", null, \"field4\"});\n\t\t\tfail(\"Fields mapping cannot contain null.\");\n\t\t} catch (NullPointerException e) {\n\t\t\t// success\n\t\t}\n\n\t\ttry {\n\t\t\tnew PojoCsvInputFormat<PojoItem>(new Path(tempFile.toURI().toString()), typeInfo, new String[]{\"field1\", \"field2\", \"field3\", \"field5\"});\n\t\t\tfail(\"Invalid field name\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t\t// success\n\t\t}\n\t}", "signature": "void testPojoTypeWithInvalidFieldMapping()", "full_signature": "@Test public void testPojoTypeWithInvalidFieldMapping()", "class_method_signature": "CsvInputFormatTest.testPojoTypeWithInvalidFieldMapping()", "testcase": true, "constructor": false, "invocations": ["createTempFile", "deleteOnExit", "setWritable", "createTypeInfo", "toString", "toURI", "fail", "toString", "toURI", "fail", "toString", "toURI", "fail"]}, "focal_class": {"identifier": "CsvInputFormat", "superclass": "extends GenericCsvInputFormat<OUT>", "interfaces": "", "fields": [{"original_string": "private static final long serialVersionUID = 1L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 1L", "var_name": "serialVersionUID"}, {"original_string": "public static final String DEFAULT_LINE_DELIMITER = \"\\n\";", "modifier": "public static final", "type": "String", "declarator": "DEFAULT_LINE_DELIMITER = \"\\n\"", "var_name": "DEFAULT_LINE_DELIMITER"}, {"original_string": "public static final String DEFAULT_FIELD_DELIMITER = \",\";", "modifier": "public static final", "type": "String", "declarator": "DEFAULT_FIELD_DELIMITER = \",\"", "var_name": "DEFAULT_FIELD_DELIMITER"}, {"original_string": "protected transient Object[] parsedValues;", "modifier": "protected transient", "type": "Object[]", "declarator": "parsedValues", "var_name": "parsedValues"}], "methods": [{"identifier": "CsvInputFormat", "parameters": "(Path filePath)", "modifiers": "protected", "return": "", "signature": " CsvInputFormat(Path filePath)", "full_signature": "protected  CsvInputFormat(Path filePath)", "class_method_signature": "CsvInputFormat.CsvInputFormat(Path filePath)", "testcase": false, "constructor": true}, {"identifier": "open", "parameters": "(FileInputSplit split)", "modifiers": "@Override public", "return": "void", "signature": "void open(FileInputSplit split)", "full_signature": "@Override public void open(FileInputSplit split)", "class_method_signature": "CsvInputFormat.open(FileInputSplit split)", "testcase": false, "constructor": false}, {"identifier": "nextRecord", "parameters": "(OUT record)", "modifiers": "@Override public", "return": "OUT", "signature": "OUT nextRecord(OUT record)", "full_signature": "@Override public OUT nextRecord(OUT record)", "class_method_signature": "CsvInputFormat.nextRecord(OUT record)", "testcase": false, "constructor": false}, {"identifier": "readRecord", "parameters": "(OUT reuse, byte[] bytes, int offset, int numBytes)", "modifiers": "@Override public", "return": "OUT", "signature": "OUT readRecord(OUT reuse, byte[] bytes, int offset, int numBytes)", "full_signature": "@Override public OUT readRecord(OUT reuse, byte[] bytes, int offset, int numBytes)", "class_method_signature": "CsvInputFormat.readRecord(OUT reuse, byte[] bytes, int offset, int numBytes)", "testcase": false, "constructor": false}, {"identifier": "fillRecord", "parameters": "(OUT reuse, Object[] parsedValues)", "modifiers": "protected abstract", "return": "OUT", "signature": "OUT fillRecord(OUT reuse, Object[] parsedValues)", "full_signature": "protected abstract OUT fillRecord(OUT reuse, Object[] parsedValues)", "class_method_signature": "CsvInputFormat.fillRecord(OUT reuse, Object[] parsedValues)", "testcase": false, "constructor": false}, {"identifier": "getFieldTypes", "parameters": "()", "modifiers": "public", "return": "Class<?>[]", "signature": "Class<?>[] getFieldTypes()", "full_signature": "public Class<?>[] getFieldTypes()", "class_method_signature": "CsvInputFormat.getFieldTypes()", "testcase": false, "constructor": false}, {"identifier": "createDefaultMask", "parameters": "(int size)", "modifiers": "protected static", "return": "boolean[]", "signature": "boolean[] createDefaultMask(int size)", "full_signature": "protected static boolean[] createDefaultMask(int size)", "class_method_signature": "CsvInputFormat.createDefaultMask(int size)", "testcase": false, "constructor": false}, {"identifier": "toBooleanMask", "parameters": "(int[] sourceFieldIndices)", "modifiers": "protected static", "return": "boolean[]", "signature": "boolean[] toBooleanMask(int[] sourceFieldIndices)", "full_signature": "protected static boolean[] toBooleanMask(int[] sourceFieldIndices)", "class_method_signature": "CsvInputFormat.toBooleanMask(int[] sourceFieldIndices)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "CsvInputFormat.toString()", "testcase": false, "constructor": false}], "file": "flink-java/src/main/java/org/apache/flink/api/java/io/CsvInputFormat.java"}, "focal_method": {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "body": "@Override\n\tpublic String toString() {\n\t\treturn \"CSV Input (\" + StringUtils.showControlCharacters(String.valueOf(getFieldDelimiter())) + \") \" + getFilePath();\n\t}", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "CsvInputFormat.toString()", "testcase": false, "constructor": false, "invocations": ["showControlCharacters", "valueOf", "getFieldDelimiter", "getFilePath"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}