{"test_class": {"identifier": "DynamicTimeWarpingTest", "superclass": "", "interfaces": "", "fields": [], "file": "JAICore/jaicore-basic/src/test/java/ai/libs/jaicore/basic/metric/DynamicTimeWarpingTest.java"}, "test_case": {"identifier": "testCorrectnessForDistanceCalculation2", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testCorrectnessForDistanceCalculation2() {\n\t\t// Input.\n\t\tdouble[] timeSeries1 = { 0.50, 0.87, 0.90, 0.82, 0.70 };\n\t\tdouble[] timeSeries2 = { 0.10, 0.10, 0.10, 0.10, 0.10 };\n\t\t// Expectation.\n\t\tdouble expectation = 3.29;\n\n\t\tDynamicTimeWarping dtw = new DynamicTimeWarping();\n\t\tdouble distance = dtw.distance(timeSeries1, timeSeries2);\n\n\t\tassertEquals(expectation, distance, 1.0E-5);\n\t}", "signature": "void testCorrectnessForDistanceCalculation2()", "full_signature": "@Test public void testCorrectnessForDistanceCalculation2()", "class_method_signature": "DynamicTimeWarpingTest.testCorrectnessForDistanceCalculation2()", "testcase": true, "constructor": false, "invocations": ["distance", "assertEquals"]}, "focal_class": {"identifier": "DynamicTimeWarping", "superclass": "", "interfaces": "implements IDistanceMetric", "fields": [{"original_string": "private IScalarDistance delta;", "modifier": "private", "type": "IScalarDistance", "declarator": "delta", "var_name": "delta"}], "methods": [{"identifier": "DynamicTimeWarping", "parameters": "()", "modifiers": "public", "return": "", "signature": " DynamicTimeWarping()", "full_signature": "public  DynamicTimeWarping()", "class_method_signature": "DynamicTimeWarping.DynamicTimeWarping()", "testcase": false, "constructor": true}, {"identifier": "DynamicTimeWarping", "parameters": "(final IScalarDistance delta)", "modifiers": "public", "return": "", "signature": " DynamicTimeWarping(final IScalarDistance delta)", "full_signature": "public  DynamicTimeWarping(final IScalarDistance delta)", "class_method_signature": "DynamicTimeWarping.DynamicTimeWarping(final IScalarDistance delta)", "testcase": false, "constructor": true}, {"identifier": "distance", "parameters": "(final double[] a, final double[] b)", "modifiers": "@Override public", "return": "double", "signature": "double distance(final double[] a, final double[] b)", "full_signature": "@Override public double distance(final double[] a, final double[] b)", "class_method_signature": "DynamicTimeWarping.distance(final double[] a, final double[] b)", "testcase": false, "constructor": false}, {"identifier": "distanceWithWindow", "parameters": "(final double[] a, final double[] b, int w)", "modifiers": "public", "return": "double", "signature": "double distanceWithWindow(final double[] a, final double[] b, int w)", "full_signature": "public double distanceWithWindow(final double[] a, final double[] b, int w)", "class_method_signature": "DynamicTimeWarping.distanceWithWindow(final double[] a, final double[] b, int w)", "testcase": false, "constructor": false}], "file": "JAICore/jaicore-basic/src/main/java/ai/libs/jaicore/basic/metric/DynamicTimeWarping.java"}, "focal_method": {"identifier": "distance", "parameters": "(final double[] a, final double[] b)", "modifiers": "@Override public", "return": "double", "body": "@Override\n\tpublic double distance(final double[] a, final double[] b) {\n\t\t// Care in the most algorithm descriptions, the time series are 1-indexed.\n\n\t\tint n = a.length;\n\t\tint m = b.length;\n\t\tdouble[][] matrix = new double[n + 1][m + 1]; // from 0 to n+1 incl. and 0 to m+1 incl.\n\n\t\t// Initialize first row and column to infinity (except [0][0]).\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tmatrix[i][0] = Double.MAX_VALUE;\n\t\t}\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tmatrix[0][j] = Double.MAX_VALUE;\n\t\t}\n\t\t// Initialize [0][0] with 0.\n\t\tmatrix[0][0] = 0d;\n\n\t\t// Dynamic programming.\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tdouble cost = this.delta.distance(a[i - 1], b[j - 1]); // 1 indexed in algo.\n\t\t\t\tdouble mini = Math.min(matrix[i - 1][j], Math.min(matrix[i][j - 1], matrix[i - 1][j - 1]));\n\t\t\t\tmatrix[i][j] = cost + mini;\n\t\t\t}\n\t\t}\n\n\t\treturn matrix[n][m];\n\t}", "signature": "double distance(final double[] a, final double[] b)", "full_signature": "@Override public double distance(final double[] a, final double[] b)", "class_method_signature": "DynamicTimeWarping.distance(final double[] a, final double[] b)", "testcase": false, "constructor": false, "invocations": ["distance", "min", "min"]}, "repository": {"repo_id": 95635499, "url": "https://github.com/fmohr/AILibs", "language": "Java", "is_fork": false, "fork_count": 26, "stargazer_count": 25, "size": 155873, "license": "licensed"}}