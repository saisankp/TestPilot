{"test_class": {"identifier": "ICMPTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private byte[] pktSerialized = new byte[] {\n            // (byte) 0xc8, 0x2a, 0x14, 0x2d, 0x35, (byte) 0xf1,\n            // 0x00, 0x0c, 0x29, 0x3b, (byte) 0x95, (byte) 0xf2, 0x08, 0x0,\n            0x45, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x40, 0x00, 0x40, 0x01,\n            (byte) 0xa3, (byte) 0xcb,\n            (byte) 0xc0, (byte) 0xa8, (byte) 0x0a, (byte) 0xe7,\n            (byte) 0xc0, (byte) 0xa8, (byte) 0x0a, (byte) 0xdb,\n            0x08, 0x00, 0x7f, 0x0a, 0x76, (byte) 0xf2, 0x00, 0x02,\n            0x01, 0x01, 0x01 };", "modifier": "private", "type": "byte[]", "declarator": "pktSerialized = new byte[] {\n            // (byte) 0xc8, 0x2a, 0x14, 0x2d, 0x35, (byte) 0xf1,\n            // 0x00, 0x0c, 0x29, 0x3b, (byte) 0x95, (byte) 0xf2, 0x08, 0x0,\n            0x45, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x40, 0x00, 0x40, 0x01,\n            (byte) 0xa3, (byte) 0xcb,\n            (byte) 0xc0, (byte) 0xa8, (byte) 0x0a, (byte) 0xe7,\n            (byte) 0xc0, (byte) 0xa8, (byte) 0x0a, (byte) 0xdb,\n            0x08, 0x00, 0x7f, 0x0a, 0x76, (byte) 0xf2, 0x00, 0x02,\n            0x01, 0x01, 0x01 }", "var_name": "pktSerialized"}], "file": "src/agents/apps/floodlight/floodlight-1.0/src/test/java/net/floodlightcontroller/packet/ICMPTest.java"}, "test_case": {"identifier": "testSerialize", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSerialize() {\n        IPacket packet = new IPv4()\n            .setIdentification((short) 0)\n            .setFlags((byte) 0x02)\n            .setTtl((byte) 64)\n            .setSourceAddress(\"192.168.10.231\")\n            .setDestinationAddress(\"192.168.10.219\")\n            .setPayload(new ICMP()\n                            .setIcmpType((byte) 8)\n                            .setIcmpCode((byte) 0)\n                            .setPayload(new Data(new byte[]\n                                        {0x76, (byte) 0xf2, 0x0, 0x2, 0x1, 0x1, 0x1}))\n                       );\n        byte[] actual = packet.serialize();\n        assertTrue(Arrays.equals(pktSerialized, actual));\n    }", "signature": "void testSerialize()", "full_signature": "@Test public void testSerialize()", "class_method_signature": "ICMPTest.testSerialize()", "testcase": true, "constructor": false, "invocations": ["setPayload", "setDestinationAddress", "setSourceAddress", "setTtl", "setFlags", "setIdentification", "setPayload", "setIcmpCode", "setIcmpType", "serialize", "assertTrue", "equals"]}, "focal_class": {"identifier": "ICMP", "superclass": "extends BasePacket", "interfaces": "", "fields": [{"original_string": "protected byte icmpType;", "modifier": "protected", "type": "byte", "declarator": "icmpType", "var_name": "icmpType"}, {"original_string": "protected byte icmpCode;", "modifier": "protected", "type": "byte", "declarator": "icmpCode", "var_name": "icmpCode"}, {"original_string": "protected short checksum;", "modifier": "protected", "type": "short", "declarator": "checksum", "var_name": "checksum"}, {"original_string": "public static final Map<Byte, Short> paddingMap;", "modifier": "public static final", "type": "Map<Byte, Short>", "declarator": "paddingMap", "var_name": "paddingMap"}, {"original_string": "public static final byte ECHO_REPLY = 0x0;", "modifier": "public static final", "type": "byte", "declarator": "ECHO_REPLY = 0x0", "var_name": "ECHO_REPLY"}, {"original_string": "public static final byte ECHO_REQUEST = 0x8;", "modifier": "public static final", "type": "byte", "declarator": "ECHO_REQUEST = 0x8", "var_name": "ECHO_REQUEST"}, {"original_string": "public static final byte TIME_EXCEEDED = 0xB;", "modifier": "public static final", "type": "byte", "declarator": "TIME_EXCEEDED = 0xB", "var_name": "TIME_EXCEEDED"}, {"original_string": "public static final byte DESTINATION_UNREACHABLE = 0x3;", "modifier": "public static final", "type": "byte", "declarator": "DESTINATION_UNREACHABLE = 0x3", "var_name": "DESTINATION_UNREACHABLE"}, {"original_string": "public static final byte CODE_PORT_UNREACHABLE = 0x3;", "modifier": "public static final", "type": "byte", "declarator": "CODE_PORT_UNREACHABLE = 0x3", "var_name": "CODE_PORT_UNREACHABLE"}], "methods": [{"identifier": "getIcmpType", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getIcmpType()", "full_signature": "public byte getIcmpType()", "class_method_signature": "ICMP.getIcmpType()", "testcase": false, "constructor": false}, {"identifier": "setIcmpType", "parameters": "(byte icmpType)", "modifiers": "public", "return": "ICMP", "signature": "ICMP setIcmpType(byte icmpType)", "full_signature": "public ICMP setIcmpType(byte icmpType)", "class_method_signature": "ICMP.setIcmpType(byte icmpType)", "testcase": false, "constructor": false}, {"identifier": "getIcmpCode", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getIcmpCode()", "full_signature": "public byte getIcmpCode()", "class_method_signature": "ICMP.getIcmpCode()", "testcase": false, "constructor": false}, {"identifier": "setIcmpCode", "parameters": "(byte icmpCode)", "modifiers": "public", "return": "ICMP", "signature": "ICMP setIcmpCode(byte icmpCode)", "full_signature": "public ICMP setIcmpCode(byte icmpCode)", "class_method_signature": "ICMP.setIcmpCode(byte icmpCode)", "testcase": false, "constructor": false}, {"identifier": "getChecksum", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getChecksum()", "full_signature": "public short getChecksum()", "class_method_signature": "ICMP.getChecksum()", "testcase": false, "constructor": false}, {"identifier": "setChecksum", "parameters": "(short checksum)", "modifiers": "public", "return": "ICMP", "signature": "ICMP setChecksum(short checksum)", "full_signature": "public ICMP setChecksum(short checksum)", "class_method_signature": "ICMP.setChecksum(short checksum)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "()", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] serialize()", "full_signature": "@Override public byte[] serialize()", "class_method_signature": "ICMP.serialize()", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "ICMP.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "ICMP.equals(Object obj)", "testcase": false, "constructor": false}, {"identifier": "deserialize", "parameters": "(byte[] data, int offset, int length)", "modifiers": "@Override public", "return": "IPacket", "signature": "IPacket deserialize(byte[] data, int offset, int length)", "full_signature": "@Override public IPacket deserialize(byte[] data, int offset, int length)", "class_method_signature": "ICMP.deserialize(byte[] data, int offset, int length)", "testcase": false, "constructor": false}], "file": "src/agents/apps/floodlight/floodlight-1.0/src/main/java/net/floodlightcontroller/packet/ICMP.java"}, "focal_method": {"identifier": "serialize", "parameters": "()", "modifiers": "@Override public", "return": "byte[]", "body": "@Override\n    public byte[] serialize() {\n        short padding = 0;\n        if (paddingMap.containsKey(this.icmpType))\n            padding = paddingMap.get(this.icmpType);\n\n        int length = 4 + padding;\n        byte[] payloadData = null;\n        if (payload != null) {\n            payload.setParent(this);\n            payloadData = payload.serialize();\n            length += payloadData.length;\n        }\n\n        byte[] data = new byte[length];\n        ByteBuffer bb = ByteBuffer.wrap(data);\n\n        bb.put(this.icmpType);\n        bb.put(this.icmpCode);\n        bb.putShort(this.checksum);\n        for (int i = 0; i < padding; i++)\n            bb.put((byte) 0);\n\n        if (payloadData != null)\n            bb.put(payloadData);\n\n        if (this.parent != null && this.parent instanceof IPv4)\n            ((IPv4)this.parent).setProtocol(IpProtocol.ICMP);\n\n        // compute checksum if needed\n        if (this.checksum == 0) {\n            bb.rewind();\n            int accumulation = 0;\n\n            for (int i = 0; i < length / 2; ++i) {\n                accumulation += 0xffff & bb.getShort();\n            }\n            // pad to an even number of shorts\n            if (length % 2 > 0) {\n                accumulation += (bb.get() & 0xff) << 8;\n            }\n\n            accumulation = ((accumulation >> 16) & 0xffff)\n                    + (accumulation & 0xffff);\n            this.checksum = (short) (~accumulation & 0xffff);\n            bb.putShort(2, this.checksum);\n        }\n        return data;\n    }", "signature": "byte[] serialize()", "full_signature": "@Override public byte[] serialize()", "class_method_signature": "ICMP.serialize()", "testcase": false, "constructor": false, "invocations": ["containsKey", "get", "setParent", "serialize", "wrap", "put", "put", "putShort", "put", "put", "setProtocol", "rewind", "getShort", "get", "putShort"]}, "repository": {"repo_id": 181421086, "url": "https://github.com/seungsoo-lee/DELTA", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 35, "size": 99244, "license": "licensed"}}