{"test_class": {"identifier": "BranchContainerImplTest", "superclass": "extends PipelineBaseTest", "interfaces": "", "fields": [{"original_string": "@Rule\n    public GitSampleRepoRule sampleRepo = new GitSampleRepoRule();", "modifier": "@Rule\n    public", "type": "GitSampleRepoRule", "declarator": "sampleRepo = new GitSampleRepoRule()", "var_name": "sampleRepo"}], "file": "blueocean-pipeline-api-impl/src/test/java/io/jenkins/blueocean/rest/impl/pipeline/BranchContainerImplTest.java"}, "test_case": {"identifier": "testBranchOrdering", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testBranchOrdering() throws Exception {\n        j.jenkins.setSecurityRealm(j.createDummySecurityRealm());\n        hudson.model.User user = User.get(\"alice\");\n        user.setFullName(\"Alice Cooper\");\n        WorkflowMultiBranchProject mp = j.jenkins.createProject(WorkflowMultiBranchProject.class, \"p\");\n        mp.getSourcesList().add(new BranchSource(new GitSCMSource(null, sampleRepo.toString(), \"\", \"*\", \"\", false),\n            new DefaultBranchPropertyStrategy(new BranchProperty[0])));\n        for (SCMSource source : mp.getSCMSources()) {\n            assertEquals(mp, source.getOwner());\n        }\n\n        WorkflowJob p = scheduleAndFindBranchProject(mp, \"master\");\n        j.waitUntilNoActivity();\n\n        String token = getJwtToken(j.jenkins, \"alice\", \"alice\");\n\n        new RequestBuilder(baseUrl)\n            .put(\"/organizations/jenkins/pipelines/p/branches/feature2/favorite\")\n            .jwtToken(token)\n            .data(ImmutableMap.of(\"favorite\", true))\n            .build(Map.class);\n\n        new RequestBuilder(baseUrl)\n            .put(\"/organizations/jenkins/pipelines/p/branches/feature4/favorite\")\n            .jwtToken(token)\n            .data(ImmutableMap.of(\"favorite\", true))\n            .build(Map.class);\n\n        List l = request().get(\"/organizations/jenkins/pipelines/p/branches/\")\n            .jwtToken(token)\n            .build(List.class);\n\n        Assert.assertEquals(4,l.size());\n        Map o = (Map)l.get(1);\n        Map o2 = (Map)l.get(0);\n\n        WorkflowJob j1 = findBranchProject(mp, (String)o.get(\"name\"));\n        j.waitForCompletion(j1.getLastBuild());\n        j.waitForCompletion(j1.scheduleBuild2(0).waitForStart());\n\n        WorkflowJob j2 = findBranchProject(mp, (String)o2.get(\"name\"));\n        j.waitForCompletion(j2.getLastBuild());\n\n        List l2 = request().get(\"/organizations/jenkins/pipelines/p/branches/\")\n            .jwtToken(token)\n            .build(List.class);\n\n        Assert.assertEquals(4,l.size());\n        Map o1 = (Map)l2.get(0);\n        Map o3 = (Map)l2.get(1);\n\n        Assert.assertEquals(o2.get(\"name\"), o1.get(\"name\"));\n    }", "signature": "void testBranchOrdering()", "full_signature": "@Test public void testBranchOrdering()", "class_method_signature": "BranchContainerImplTest.testBranchOrdering()", "testcase": true, "constructor": false, "invocations": ["setSecurityRealm", "createDummySecurityRealm", "get", "setFullName", "createProject", "add", "getSourcesList", "toString", "getSCMSources", "assertEquals", "getOwner", "scheduleAndFindBranchProject", "waitUntilNoActivity", "getJwtToken", "build", "data", "jwtToken", "put", "of", "build", "data", "jwtToken", "put", "of", "build", "jwtToken", "get", "request", "assertEquals", "size", "get", "get", "findBranchProject", "get", "waitForCompletion", "getLastBuild", "waitForCompletion", "waitForStart", "scheduleBuild2", "findBranchProject", "get", "waitForCompletion", "getLastBuild", "build", "jwtToken", "get", "request", "assertEquals", "size", "get", "get", "assertEquals", "get", "get"]}, "focal_class": {"identifier": "BranchContainerImpl", "superclass": "extends BluePipelineContainer", "interfaces": "", "fields": [{"original_string": "private static final Comparator<BluePipeline> BRANCH_COMPARATOR = new Comparator<BluePipeline>() {\n        @Override\n        public int compare(BluePipeline _pipeline1, BluePipeline _pipeline2) {\n            BranchImpl pipeline1 = (BranchImpl)_pipeline1;\n            BranchImpl pipeline2 = (BranchImpl)_pipeline2;\n\n            BranchImpl.Branch branch1 = pipeline1.getBranch();\n            if (branch1 == null) {\n                return -1;\n            }\n\n            BranchImpl.Branch branch2 = pipeline2.getBranch();\n            if (branch2 == null) {\n                return 1;\n            }\n\n            // If one pipeline isnt the primary there is no need to go further\n            if(branch1.isPrimary() && !branch2.isPrimary()) {\n                return -1;\n            }\n\n            if(!branch1.isPrimary() && branch2.isPrimary()) {\n                return 1;\n            }\n\n            // If One pipeline isnt a favorite there is no need to go further.\n            if(pipeline1.isFavorite() && !pipeline2.isFavorite()) {\n                return -1;\n            }\n\n            if(!pipeline1.isFavorite() && pipeline2.isFavorite()) {\n                return 1;\n            }\n\n            BlueRun latestRun1 = pipeline1.getLatestRun();\n            BlueRun latestRun2 = pipeline2.getLatestRun();\n\n            // If a pipeline doesn't have a run yet, no need to go further.\n            if(latestRun1 != null && latestRun2 == null) {\n                return -1;\n            }\n\n            if(latestRun1 == null && latestRun2 != null) {\n                return 1;\n            }\n\n            //If neither have runs, lets just order by name.\n            if(latestRun1 == null) {\n                return pipeline1.getName().compareTo(pipeline2.getName());\n            }\n\n            // If one run hasnt finished yet, then lets order by that.\n            Date endTime1 = latestRun1.getEndTime() ;\n            Date endTime2 = latestRun2.getEndTime();\n            if(endTime1 != null && endTime2 == null) {\n                return 1;\n            }\n\n            if(endTime1 == null && endTime2 != null) {\n                return -1;\n            }\n\n            // If both jobs have ended, lets order by the one that ended last.\n            if(endTime1 != null) {\n                if(endTime1.getTime() > endTime2.getTime()) {\n                    return -1;\n                }\n\n                if(endTime1.getTime() < endTime2.getTime()) {\n                    return 1;\n                }\n\n                return pipeline1.getName().compareTo(pipeline2.getName());\n            }\n\n            //If both jobs have not ended yet, we need to order by start time.\n            Date startTime1 = latestRun1.getStartTime();\n            Date startTime2 = latestRun2.getStartTime();\n            if(startTime1 != null && startTime2 == null) {\n                return 1;\n            }\n\n            if(startTime1 == null && startTime2 != null) {\n                return -1;\n            }\n\n            if(startTime1 != null && startTime2 != null) {\n                if(startTime1.getTime() > startTime2.getTime()) {\n                    return -1;\n                }\n\n                if(startTime1.getTime() < startTime2.getTime()) {\n                    return 1;\n                }\n\n                return pipeline1.getName().compareTo(pipeline2.getName());\n            }\n\n            return pipeline1.getName().compareTo(pipeline2.getName());\n        }\n    };", "modifier": "private static final", "type": "Comparator<BluePipeline>", "declarator": "BRANCH_COMPARATOR = new Comparator<BluePipeline>() {\n        @Override\n        public int compare(BluePipeline _pipeline1, BluePipeline _pipeline2) {\n            BranchImpl pipeline1 = (BranchImpl)_pipeline1;\n            BranchImpl pipeline2 = (BranchImpl)_pipeline2;\n\n            BranchImpl.Branch branch1 = pipeline1.getBranch();\n            if (branch1 == null) {\n                return -1;\n            }\n\n            BranchImpl.Branch branch2 = pipeline2.getBranch();\n            if (branch2 == null) {\n                return 1;\n            }\n\n            // If one pipeline isnt the primary there is no need to go further\n            if(branch1.isPrimary() && !branch2.isPrimary()) {\n                return -1;\n            }\n\n            if(!branch1.isPrimary() && branch2.isPrimary()) {\n                return 1;\n            }\n\n            // If One pipeline isnt a favorite there is no need to go further.\n            if(pipeline1.isFavorite() && !pipeline2.isFavorite()) {\n                return -1;\n            }\n\n            if(!pipeline1.isFavorite() && pipeline2.isFavorite()) {\n                return 1;\n            }\n\n            BlueRun latestRun1 = pipeline1.getLatestRun();\n            BlueRun latestRun2 = pipeline2.getLatestRun();\n\n            // If a pipeline doesn't have a run yet, no need to go further.\n            if(latestRun1 != null && latestRun2 == null) {\n                return -1;\n            }\n\n            if(latestRun1 == null && latestRun2 != null) {\n                return 1;\n            }\n\n            //If neither have runs, lets just order by name.\n            if(latestRun1 == null) {\n                return pipeline1.getName().compareTo(pipeline2.getName());\n            }\n\n            // If one run hasnt finished yet, then lets order by that.\n            Date endTime1 = latestRun1.getEndTime() ;\n            Date endTime2 = latestRun2.getEndTime();\n            if(endTime1 != null && endTime2 == null) {\n                return 1;\n            }\n\n            if(endTime1 == null && endTime2 != null) {\n                return -1;\n            }\n\n            // If both jobs have ended, lets order by the one that ended last.\n            if(endTime1 != null) {\n                if(endTime1.getTime() > endTime2.getTime()) {\n                    return -1;\n                }\n\n                if(endTime1.getTime() < endTime2.getTime()) {\n                    return 1;\n                }\n\n                return pipeline1.getName().compareTo(pipeline2.getName());\n            }\n\n            //If both jobs have not ended yet, we need to order by start time.\n            Date startTime1 = latestRun1.getStartTime();\n            Date startTime2 = latestRun2.getStartTime();\n            if(startTime1 != null && startTime2 == null) {\n                return 1;\n            }\n\n            if(startTime1 == null && startTime2 != null) {\n                return -1;\n            }\n\n            if(startTime1 != null && startTime2 != null) {\n                if(startTime1.getTime() > startTime2.getTime()) {\n                    return -1;\n                }\n\n                if(startTime1.getTime() < startTime2.getTime()) {\n                    return 1;\n                }\n\n                return pipeline1.getName().compareTo(pipeline2.getName());\n            }\n\n            return pipeline1.getName().compareTo(pipeline2.getName());\n        }\n    }", "var_name": "BRANCH_COMPARATOR"}, {"original_string": "private final MultiBranchPipelineImpl pipeline;", "modifier": "private final", "type": "MultiBranchPipelineImpl", "declarator": "pipeline", "var_name": "pipeline"}, {"original_string": "private final Link self;", "modifier": "private final", "type": "Link", "declarator": "self", "var_name": "self"}], "methods": [{"identifier": "BranchContainerImpl", "parameters": "(MultiBranchPipelineImpl pipeline, Link self)", "modifiers": "public", "return": "", "signature": " BranchContainerImpl(MultiBranchPipelineImpl pipeline, Link self)", "full_signature": "public  BranchContainerImpl(MultiBranchPipelineImpl pipeline, Link self)", "class_method_signature": "BranchContainerImpl.BranchContainerImpl(MultiBranchPipelineImpl pipeline, Link self)", "testcase": false, "constructor": true}, {"identifier": "get", "parameters": "(String name)", "modifiers": "@Override public", "return": "BluePipeline", "signature": "BluePipeline get(String name)", "full_signature": "@Override public BluePipeline get(String name)", "class_method_signature": "BranchContainerImpl.get(String name)", "testcase": false, "constructor": false}, {"identifier": "iterator", "parameters": "()", "modifiers": "@Override public", "return": "Iterator<BluePipeline>", "signature": "Iterator<BluePipeline> iterator()", "full_signature": "@Override public Iterator<BluePipeline> iterator()", "class_method_signature": "BranchContainerImpl.iterator()", "testcase": false, "constructor": false}, {"identifier": "iterator", "parameters": "(int start, int limit)", "modifiers": "@Override @SuppressWarnings(\"unchecked\") public", "return": "Iterator<BluePipeline>", "signature": "Iterator<BluePipeline> iterator(int start, int limit)", "full_signature": "@Override @SuppressWarnings(\"unchecked\") public Iterator<BluePipeline> iterator(int start, int limit)", "class_method_signature": "BranchContainerImpl.iterator(int start, int limit)", "testcase": false, "constructor": false}, {"identifier": "getLink", "parameters": "()", "modifiers": "@Override public", "return": "Link", "signature": "Link getLink()", "full_signature": "@Override public Link getLink()", "class_method_signature": "BranchContainerImpl.getLink()", "testcase": false, "constructor": false}], "file": "blueocean-pipeline-api-impl/src/main/java/io/jenkins/blueocean/rest/impl/pipeline/BranchContainerImpl.java"}, "focal_method": {"identifier": "get", "parameters": "(String name)", "modifiers": "@Override public", "return": "BluePipeline", "body": "@Override\n    public BluePipeline get(String name) {\n        Job job = pipeline.mbp.getItem(name);\n        if (job == null) {\n            return null;\n        }\n        BlueOrganization organization = OrganizationFactory.getInstance().getContainingOrg(job);\n        if (organization == null) {\n            return null;\n        }\n        return new BranchImpl(organization, job, getLink());\n    }", "signature": "BluePipeline get(String name)", "full_signature": "@Override public BluePipeline get(String name)", "class_method_signature": "BranchContainerImpl.get(String name)", "testcase": false, "constructor": false, "invocations": ["getItem", "getContainingOrg", "getInstance", "getLink"]}, "repository": {"repo_id": 50250915, "url": "https://github.com/jenkinsci/blueocean-plugin", "stars": 2605, "created": "1/23/2016 6:02:45 PM +00:00", "updates": "2020-01-25T17:58:46+00:00", "fork": "False", "license": "licensed"}}