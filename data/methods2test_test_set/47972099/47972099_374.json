{"test_class": {"identifier": "ConnectionUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "flink-runtime/src/test/java/org/apache/flink/runtime/net/ConnectionUtilsTest.java"}, "test_case": {"identifier": "testReturnLocalHostAddressUsingHeuristics", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testReturnLocalHostAddressUsingHeuristics() {\n\t\tint unusedPort;\n\t\ttry {\n\t\t\tunusedPort = org.apache.flink.util.NetUtils.getAvailablePort();\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t// if this system cannot find an available port,\n\t\t\t// skip this test\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\t// create an unreachable target address\n\t\t\tInetSocketAddress unreachable = new InetSocketAddress(\"localhost\", unusedPort);\n\n\t\t\tfinal long start = System.currentTimeMillis();\n\t\t\tInetAddress add = ConnectionUtils.findConnectingAddress(unreachable, 2000, 400);\n\n\t\t\t// check that it did not take forever\n\t\t\tassertTrue(System.currentTimeMillis() - start < (OperatingSystem.isWindows() ? 30000 : 8000));\n\n\t\t\t// we should have found a heuristic address\n\t\t\tassertNotNull(add);\n\n\t\t\t// make sure that we returned the InetAddress.getLocalHost as a heuristic\n\t\t\tassertEquals(InetAddress.getLocalHost(), add);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}", "signature": "void testReturnLocalHostAddressUsingHeuristics()", "full_signature": "@Test public void testReturnLocalHostAddressUsingHeuristics()", "class_method_signature": "ConnectionUtilsTest.testReturnLocalHostAddressUsingHeuristics()", "testcase": true, "constructor": false, "invocations": ["getAvailablePort", "currentTimeMillis", "findConnectingAddress", "assertTrue", "currentTimeMillis", "isWindows", "assertNotNull", "assertEquals", "getLocalHost", "printStackTrace", "fail", "getMessage"]}, "focal_class": {"identifier": "ConnectionUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(ConnectionUtils.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(ConnectionUtils.class)", "var_name": "LOG"}, {"original_string": "private static final long MIN_SLEEP_TIME = 50;", "modifier": "private static final", "type": "long", "declarator": "MIN_SLEEP_TIME = 50", "var_name": "MIN_SLEEP_TIME"}, {"original_string": "private static final long MAX_SLEEP_TIME = 20000;", "modifier": "private static final", "type": "long", "declarator": "MAX_SLEEP_TIME = 20000", "var_name": "MAX_SLEEP_TIME"}], "methods": [{"identifier": "findConnectingAddress", "parameters": "(InetSocketAddress targetAddress,\n\t\t\t\t\t\t\tlong maxWaitMillis, long startLoggingAfter)", "modifiers": "public static", "return": "InetAddress", "signature": "InetAddress findConnectingAddress(InetSocketAddress targetAddress,\n\t\t\t\t\t\t\tlong maxWaitMillis, long startLoggingAfter)", "full_signature": "public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,\n\t\t\t\t\t\t\tlong maxWaitMillis, long startLoggingAfter)", "class_method_signature": "ConnectionUtils.findConnectingAddress(InetSocketAddress targetAddress,\n\t\t\t\t\t\t\tlong maxWaitMillis, long startLoggingAfter)", "testcase": false, "constructor": false}, {"identifier": "tryLocalHostBeforeReturning", "parameters": "(\n\t\t\t\tInetAddress preliminaryResult, SocketAddress targetAddress, boolean logging)", "modifiers": "private static", "return": "InetAddress", "signature": "InetAddress tryLocalHostBeforeReturning(\n\t\t\t\tInetAddress preliminaryResult, SocketAddress targetAddress, boolean logging)", "full_signature": "private static InetAddress tryLocalHostBeforeReturning(\n\t\t\t\tInetAddress preliminaryResult, SocketAddress targetAddress, boolean logging)", "class_method_signature": "ConnectionUtils.tryLocalHostBeforeReturning(\n\t\t\t\tInetAddress preliminaryResult, SocketAddress targetAddress, boolean logging)", "testcase": false, "constructor": false}, {"identifier": "findAddressUsingStrategy", "parameters": "(AddressDetectionState strategy,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInetSocketAddress targetAddress,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tboolean logging)", "modifiers": "private static", "return": "InetAddress", "signature": "InetAddress findAddressUsingStrategy(AddressDetectionState strategy,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInetSocketAddress targetAddress,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tboolean logging)", "full_signature": "private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInetSocketAddress targetAddress,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tboolean logging)", "class_method_signature": "ConnectionUtils.findAddressUsingStrategy(AddressDetectionState strategy,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInetSocketAddress targetAddress,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tboolean logging)", "testcase": false, "constructor": false}, {"identifier": "hasCommonPrefix", "parameters": "(byte[] address, byte[] address2)", "modifiers": "private static", "return": "boolean", "signature": "boolean hasCommonPrefix(byte[] address, byte[] address2)", "full_signature": "private static boolean hasCommonPrefix(byte[] address, byte[] address2)", "class_method_signature": "ConnectionUtils.hasCommonPrefix(byte[] address, byte[] address2)", "testcase": false, "constructor": false}, {"identifier": "tryToConnect", "parameters": "(InetAddress fromAddress, SocketAddress toSocket,\n\t\t\t\t\t\t\t\t\t\tint timeout, boolean logFailed)", "modifiers": "private static", "return": "boolean", "signature": "boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket,\n\t\t\t\t\t\t\t\t\t\tint timeout, boolean logFailed)", "full_signature": "private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket,\n\t\t\t\t\t\t\t\t\t\tint timeout, boolean logFailed)", "class_method_signature": "ConnectionUtils.tryToConnect(InetAddress fromAddress, SocketAddress toSocket,\n\t\t\t\t\t\t\t\t\t\tint timeout, boolean logFailed)", "testcase": false, "constructor": false}], "file": "flink-runtime/src/main/java/org/apache/flink/runtime/net/ConnectionUtils.java"}, "focal_method": {"identifier": "findConnectingAddress", "parameters": "(InetSocketAddress targetAddress,\n\t\t\t\t\t\t\tlong maxWaitMillis, long startLoggingAfter)", "modifiers": "public static", "return": "InetAddress", "body": "public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,\n\t\t\t\t\t\t\tlong maxWaitMillis, long startLoggingAfter) throws IOException\n\t{\n\t\tif (targetAddress == null) {\n\t\t\tthrow new NullPointerException(\"targetAddress must not be null\");\n\t\t}\n\t\tif (maxWaitMillis <= 0) {\n\t\t\tthrow new IllegalArgumentException(\"Max wait time must be positive\");\n\t\t}\n\n\t\tfinal long startTime = System.currentTimeMillis();\n\n\t\tlong currentSleepTime = MIN_SLEEP_TIME;\n\t\tlong elapsedTime = 0;\n\n\t\t// loop while there is time left\n\t\twhile (elapsedTime < maxWaitMillis) {\n\t\t\tAddressDetectionState strategy = AddressDetectionState.LOCAL_HOST;\n\n\t\t\tboolean logging = elapsedTime >= startLoggingAfter;\n\t\t\tif (logging) {\n\t\t\t\tLOG.info(\"Trying to connect to \" + targetAddress);\n\t\t\t}\n\t\t\t// go over the strategies ADDRESS - FAST_CONNECT - SLOW_CONNECT\n\t\t\tdo {\n\t\t\t\tInetAddress address = findAddressUsingStrategy(strategy, targetAddress, logging);\n\t\t\t\tif (address != null) {\n\t\t\t\t\treturn address;\n\t\t\t\t}\n\n\t\t\t\t// pick the next strategy\n\t\t\t\tswitch (strategy) {\n\t\t\t\t\tcase LOCAL_HOST:\n\t\t\t\t\t\tstrategy = AddressDetectionState.ADDRESS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ADDRESS:\n\t\t\t\t\t\tstrategy = AddressDetectionState.FAST_CONNECT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FAST_CONNECT:\n\t\t\t\t\t\tstrategy = AddressDetectionState.SLOW_CONNECT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SLOW_CONNECT:\n\t\t\t\t\t\tstrategy = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException(\"Unsupported strategy: \" + strategy);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (strategy != null);\n\n\t\t\t// we have made a pass with all strategies over all interfaces\n\t\t\t// sleep for a while before we make the next pass\n\t\t\telapsedTime = System.currentTimeMillis() - startTime;\n\n\t\t\tlong toWait = Math.min(maxWaitMillis - elapsedTime, currentSleepTime);\n\t\t\tif (toWait > 0) {\n\t\t\t\tif (logging) {\n\t\t\t\t\tLOG.info(\"Could not connect. Waiting for {} msecs before next attempt\", toWait);\n\t\t\t\t} else {\n\t\t\t\t\tLOG.debug(\"Could not connect. Waiting for {} msecs before next attempt\", toWait);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(toWait);\n\t\t\t\t}\n\t\t\t\tcatch (InterruptedException e) {\n\t\t\t\t\tthrow new IOException(\"Connection attempts have been interrupted.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// increase the exponential backoff timer\n\t\t\tcurrentSleepTime = Math.min(2 * currentSleepTime, MAX_SLEEP_TIME);\n\t\t}\n\n\t\t// our attempts timed out. use the heuristic fallback\n\t\tLOG.warn(\"Could not connect to {}. Selecting a local address using heuristics.\", targetAddress);\n\t\tInetAddress heuristic = findAddressUsingStrategy(AddressDetectionState.HEURISTIC, targetAddress, true);\n\t\tif (heuristic != null) {\n\t\t\treturn heuristic;\n\t\t}\n\t\telse {\n\t\t\tLOG.warn(\"Could not find any IPv4 address that is not loopback or link-local. Using localhost address.\");\n\t\t\treturn InetAddress.getLocalHost();\n\t\t}\n\t}", "signature": "InetAddress findConnectingAddress(InetSocketAddress targetAddress,\n\t\t\t\t\t\t\tlong maxWaitMillis, long startLoggingAfter)", "full_signature": "public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,\n\t\t\t\t\t\t\tlong maxWaitMillis, long startLoggingAfter)", "class_method_signature": "ConnectionUtils.findConnectingAddress(InetSocketAddress targetAddress,\n\t\t\t\t\t\t\tlong maxWaitMillis, long startLoggingAfter)", "testcase": false, "constructor": false, "invocations": ["currentTimeMillis", "info", "findAddressUsingStrategy", "currentTimeMillis", "min", "info", "debug", "sleep", "min", "warn", "findAddressUsingStrategy", "warn", "getLocalHost"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}