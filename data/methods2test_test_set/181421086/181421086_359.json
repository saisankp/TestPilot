{"test_class": {"identifier": "ACLTest", "superclass": "extends FloodlightTestCase", "interfaces": "", "fields": [{"original_string": "protected FloodlightContext cntx;", "modifier": "protected", "type": "FloodlightContext", "declarator": "cntx", "var_name": "cntx"}, {"original_string": "protected IOFSwitch sw;", "modifier": "protected", "type": "IOFSwitch", "declarator": "sw", "var_name": "sw"}, {"original_string": "private MockDebugEventService debugEventService;", "modifier": "private", "type": "MockDebugEventService", "declarator": "debugEventService", "var_name": "debugEventService"}, {"original_string": "private DefaultEntityClassifier entityClassifier;", "modifier": "private", "type": "DefaultEntityClassifier", "declarator": "entityClassifier", "var_name": "entityClassifier"}, {"original_string": "private MockThreadPoolService tps;", "modifier": "private", "type": "MockThreadPoolService", "declarator": "tps", "var_name": "tps"}, {"original_string": "private ITopologyService topology;", "modifier": "private", "type": "ITopologyService", "declarator": "topology", "var_name": "topology"}, {"original_string": "private MockDeviceManager deviceManager;", "modifier": "private", "type": "MockDeviceManager", "declarator": "deviceManager", "var_name": "deviceManager"}, {"original_string": "private MockDebugCounterService debugCounterService;", "modifier": "private", "type": "MockDebugCounterService", "declarator": "debugCounterService", "var_name": "debugCounterService"}, {"original_string": "private MemoryStorageSource storageService;", "modifier": "private", "type": "MemoryStorageSource", "declarator": "storageService", "var_name": "storageService"}, {"original_string": "private RestApiServer restApi;", "modifier": "private", "type": "RestApiServer", "declarator": "restApi", "var_name": "restApi"}, {"original_string": "private ACL acl;", "modifier": "private", "type": "ACL", "declarator": "acl", "var_name": "acl"}, {"original_string": "public static String TestSwitch1DPID = \"00:00:00:00:00:00:00:01\";", "modifier": "public static", "type": "String", "declarator": "TestSwitch1DPID = \"00:00:00:00:00:00:00:01\"", "var_name": "TestSwitch1DPID"}], "file": "src/agents/apps/floodlight/floodlight-1.1/src/test/java/net/floodlightcontroller/accesscontrollist/ACLTest.java"}, "test_case": {"identifier": "testAddRule", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testAddRule() {\n\t\t\n\t\treset(topology);\n//\t\texpect(topology.isIncomingBroadcastAllowed(DatapathId.of(anyLong()), OFPort.of(anyShort()))).andReturn(true).anyTimes();\n//\t\texpect(topology.getL2DomainId(DatapathId.of(1L))).andReturn(DatapathId.of(1L)).anyTimes();\n\t\texpect(topology.isAttachmentPointPort(DatapathId.of(1L), OFPort.of(1))).andReturn(true).anyTimes();\n\t\texpect(topology.isAttachmentPointPort(DatapathId.of(2L), OFPort.of(1))).andReturn(true).anyTimes();\n\t\treplay(topology);\n\n\t\tint[] cidr = new int[2];\n\t\tACLRule rule1, rule2, rule3, rule4;\n\t\tIResultSet resultSet;\n\t\tIterator<IResultSet> it;\n\t\tMap<String, Object> row;\n\n\t\t// a new AP[dpid:00:00:00:00:00:00:00:01 port:1 ip:10.0.0.1] appears\n\t\tdeviceManager.learnEntity(\n\t\t\t\tEthernet.toLong(Ethernet.toMACAddress(\"00:00:00:00:00:01\")),\n\t\t\t\tnull, IPv4.toIPv4Address(\"10.0.0.1\"), 1L, 1);\n\t\t\n\t\t// a new AP[dpid:00:00:00:00:00:00:00:02 port:1 ip:10.0.0.3] appears\n\t\tdeviceManager.learnEntity(\n\t\t\t\tEthernet.toLong(Ethernet.toMACAddress(\"00:00:00:00:00:03\")),\n\t\t\t\tnull, IPv4.toIPv4Address(\"10.0.0.3\"), 2L, 1);\n\t\t\n\t\t// rule1 indicates host(10.0.0.0/28) can not access TCP port 80 in host(10.0.0.254/32)\n\t\trule1 = new ACLRule();\n\t\trule1.setNw_src(\"10.0.0.0/28\");\n\t\tcidr = IPAddressUtil.parseCIDR(\"10.0.0.0/28\");\n\t\trule1.setNw_src_prefix(cidr[0]);\n\t\trule1.setNw_src_maskbits(cidr[1]);\n\t\trule1.setNw_dst(\"10.0.0.254/32\");\n\t\tcidr = IPAddressUtil.parseCIDR(\"10.0.0.254/32\");\n\t\trule1.setNw_dst_prefix(cidr[0]);\n\t\trule1.setNw_dst_maskbits(cidr[1]);\n\t\trule1.setNw_proto(6);\n\t\trule1.setTp_dst(80);\n\t\trule1.setAction(Action.DENY);\n\n\t\tassertEquals(acl.addRule(rule1), true);\n\t\tassertEquals(acl.getRules().size(), 1);\n\n\t\tresultSet = storageService.getRow(\n\t\t\t\tStaticFlowEntryPusher.TABLE_NAME, \"ACLRule_1_00:00:00:00:00:00:00:01\");\n\t\tit = resultSet.iterator();\n\t\twhile(it.hasNext()){\n\t\t\trow = it.next().getRow();\n\t\t\tassertEquals(row.get(\"switch\").toString(),\"00:00:00:00:00:00:00:01\");\n\t\t\tassertEquals(row.get(\"priority\").toString(),\"30000\");\n\t\t\tassertEquals(row.get(\"eth_type\").toString(),\"2048\");\n\t\t\tassertEquals(row.get(\"ipv4_src\").toString(),\"10.0.0.0/28\");\n\t\t\tassertEquals(row.get(\"ipv4_dst\").toString(),\"10.0.0.254/32\");\n\t\t\tassertEquals(row.get(\"ip_proto\").toString(),\"6\");\n\t\t\tassertEquals(row.get(\"tp_dst\").toString(),\"80\");\n\t\t\tassertEquals(row.get(\"actions\"), null);\n\t\t}\n\t\t\n\t\tresultSet = storageService.getRow(\n\t\t\t\tStaticFlowEntryPusher.TABLE_NAME, \"ACLRule_1_00:00:00:00:00:00:00:02\");\n\t\tit = resultSet.iterator();\n\t\twhile(it.hasNext()){\n\t\t\trow = it.next().getRow();\n\t\t\tassertEquals(row.get(\"switch\").toString(),\"00:00:00:00:00:00:00:02\");\n\t\t\tassertEquals(row.get(\"priority\").toString(),\"30000\");\n\t\t\tassertEquals(row.get(\"eth_type\").toString(),\"2048\");\n\t\t\tassertEquals(row.get(\"ipv4_src\").toString(),\"10.0.0.0/28\");\n\t\t\tassertEquals(row.get(\"ipv4_dst\").toString(),\"10.0.0.254/32\");\n\t\t\tassertEquals(row.get(\"ip_proto\").toString(),\"6\");\n\t\t\tassertEquals(row.get(\"tp_dst\").toString(),\"80\");\n\t\t\tassertEquals(row.get(\"actions\"), null);\n\t\t}\n\t\t\n\t\t// rule2 matches rule1\n\t\trule2 = new ACLRule();\n\t\trule2.setNw_src(\"10.0.0.1/32\");\n\t\tcidr = IPAddressUtil.parseCIDR(\"10.0.0.1/32\");\n\t\trule2.setNw_src_prefix(cidr[0]);\n\t\trule2.setNw_src_maskbits(cidr[1]);\n\t\trule2.setNw_dst(\"10.0.0.254/32\");\n\t\tcidr = IPAddressUtil.parseCIDR(\"10.0.0.254/32\");\n\t\trule2.setNw_dst_prefix(cidr[0]);\n\t\trule2.setNw_dst_maskbits(cidr[1]);\n\t\trule2.setNw_proto(6);\n\t\trule2.setTp_dst(80);\n\t\trule2.setAction(Action.DENY);\n\n\t\t// there will be no extra flow entry\n\t\tassertEquals(acl.addRule(rule1), false);\n\t\tassertEquals(acl.getRules().size(), 1);\n\t\t\n\t\t// rule3 indicates that no ICMP packets can reach host[10.0.0.3/32]\n\t\trule3 = new ACLRule();\n\t\trule3.setNw_dst(\"10.0.0.3/32\");\n\t\tcidr = IPAddressUtil.parseCIDR(\"10.0.0.3/32\");\n\t\trule3.setNw_dst_prefix(cidr[0]);\n\t\trule3.setNw_dst_maskbits(cidr[1]);\n\t\trule3.setNw_proto(1);\n\t\trule3.setAction(Action.DENY);\n\n\t\tassertEquals(acl.addRule(rule3), true);\n\t\tassertEquals(acl.getRules().size(), 2);\n\t\t\n\t\tresultSet = storageService.getRow(\n\t\t\t\tStaticFlowEntryPusher.TABLE_NAME, \"ACLRule_2_00:00:00:00:00:00:00:02\");\n\t\tit = resultSet.iterator();\n\t\twhile(it.hasNext()){\n\t\t\trow = it.next().getRow();\n\t\t\tassertEquals(row.get(\"switch\").toString(),\"00:00:00:00:00:00:00:02\");\n\t\t\tassertEquals(row.get(\"priority\").toString(),\"29999\");\n\t\t\tassertEquals(row.get(\"eth_type\").toString(),\"2048\");\n\t\t\tassertEquals(row.get(\"ipv4_src\"), null);\n\t\t\tassertEquals(row.get(\"ipv4_dst\").toString(),\"10.0.0.3/32\");\n\t\t\tassertEquals(row.get(\"ip_proto\").toString(),\"1\");\n\t\t\tassertEquals(row.get(\"tp_dst\"), null);\n\t\t\tassertEquals(row.get(\"actions\"), null);\n\t\t}\n\t\t\n\t\t// rule4 indicates that host(10.0.0.1/32) can access host(10.0.0.3/32)\n\t\trule4 = new ACLRule();\n\t\trule4.setNw_src(\"10.0.0.1/32\");\n\t\tcidr = IPAddressUtil.parseCIDR(\"10.0.0.1/32\");\n\t\trule4.setNw_src_prefix(cidr[0]);\n\t\trule4.setNw_src_maskbits(cidr[1]);\n\t\trule4.setNw_dst(\"10.0.0.3/32\");\n\t\tcidr = IPAddressUtil.parseCIDR(\"10.0.0.3/32\");\n\t\trule4.setNw_dst_prefix(cidr[0]);\n\t\trule4.setNw_dst_maskbits(cidr[1]);\n\t\trule4.setAction(Action.ALLOW);\n\n\t\tassertEquals(acl.addRule(rule4), true);\n\t\tassertEquals(acl.getRules().size(), 3);\n\t\t\n\t\tresultSet = storageService.getRow(\n\t\t\t\tStaticFlowEntryPusher.TABLE_NAME, \"ACLRule_3_00:00:00:00:00:00:00:01\");\n\t\tit = resultSet.iterator();\n\t\twhile(it.hasNext()){\n\t\t\trow = it.next().getRow();\n\t\t\tassertEquals(row.get(\"switch\").toString(),\"00:00:00:00:00:00:00:01\");\n\t\t\tassertEquals(row.get(\"priority\").toString(),\"29999\");\n\t\t\tassertEquals(row.get(\"eth_type\").toString(),\"2048\");\n\t\t\tassertEquals(row.get(\"ipv4_src\").toString(), \"10.0.0.1/32\");\n\t\t\tassertEquals(row.get(\"ipv4_dst\").toString(), \"10.0.0.3/32\");\n\t\t\tassertEquals(row.get(\"ip_proto\"), null);\n\t\t\tassertEquals(row.get(\"tp_dst\"), null);\n\t\t\tassertEquals(row.get(\"actions\"), \"output=controller\");\n\t\t}\n\t\t\n\t}", "signature": "void testAddRule()", "full_signature": "@Test public void testAddRule()", "class_method_signature": "ACLTest.testAddRule()", "testcase": true, "constructor": false, "invocations": ["reset", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "of", "of", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "of", "of", "replay", "learnEntity", "toLong", "toMACAddress", "toIPv4Address", "learnEntity", "toLong", "toMACAddress", "toIPv4Address", "setNw_src", "parseCIDR", "setNw_src_prefix", "setNw_src_maskbits", "setNw_dst", "parseCIDR", "setNw_dst_prefix", "setNw_dst_maskbits", "setNw_proto", "setTp_dst", "setAction", "assertEquals", "addRule", "assertEquals", "size", "getRules", "getRow", "iterator", "hasNext", "getRow", "next", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "get", "getRow", "iterator", "hasNext", "getRow", "next", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "get", "setNw_src", "parseCIDR", "setNw_src_prefix", "setNw_src_maskbits", "setNw_dst", "parseCIDR", "setNw_dst_prefix", "setNw_dst_maskbits", "setNw_proto", "setTp_dst", "setAction", "assertEquals", "addRule", "assertEquals", "size", "getRules", "setNw_dst", "parseCIDR", "setNw_dst_prefix", "setNw_dst_maskbits", "setNw_proto", "setAction", "assertEquals", "addRule", "assertEquals", "size", "getRules", "getRow", "iterator", "hasNext", "getRow", "next", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "get", "assertEquals", "get", "setNw_src", "parseCIDR", "setNw_src_prefix", "setNw_src_maskbits", "setNw_dst", "parseCIDR", "setNw_dst_prefix", "setNw_dst_maskbits", "setAction", "assertEquals", "addRule", "assertEquals", "size", "getRules", "getRow", "iterator", "hasNext", "getRow", "next", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "ACL", "superclass": "", "interfaces": "implements IACLService, IFloodlightModule, IDeviceListener", "fields": [{"original_string": "protected IRestApiService restApi;", "modifier": "protected", "type": "IRestApiService", "declarator": "restApi", "var_name": "restApi"}, {"original_string": "protected IDeviceService deviceManager;", "modifier": "protected", "type": "IDeviceService", "declarator": "deviceManager", "var_name": "deviceManager"}, {"original_string": "protected IStorageSourceService storageSource;", "modifier": "protected", "type": "IStorageSourceService", "declarator": "storageSource", "var_name": "storageSource"}, {"original_string": "protected static Logger logger;", "modifier": "protected static", "type": "Logger", "declarator": "logger", "var_name": "logger"}, {"original_string": "private APManager apManager;", "modifier": "private", "type": "APManager", "declarator": "apManager", "var_name": "apManager"}, {"original_string": "private int lastRuleId = 1;", "modifier": "private", "type": "int", "declarator": "lastRuleId = 1", "var_name": "lastRuleId"}, {"original_string": "private List<ACLRule> ruleSet;", "modifier": "private", "type": "List<ACLRule>", "declarator": "ruleSet", "var_name": "ruleSet"}, {"original_string": "private Map<String, Integer> dpid2FlowPriority;", "modifier": "private", "type": "Map<String, Integer>", "declarator": "dpid2FlowPriority", "var_name": "dpid2FlowPriority"}, {"original_string": "private Map<Integer, Set<String>> ruleId2Dpid;", "modifier": "private", "type": "Map<Integer, Set<String>>", "declarator": "ruleId2Dpid", "var_name": "ruleId2Dpid"}, {"original_string": "private Map<Integer, Set<String>> ruleId2FlowName;", "modifier": "private", "type": "Map<Integer, Set<String>>", "declarator": "ruleId2FlowName", "var_name": "ruleId2FlowName"}], "methods": [{"identifier": "getRules", "parameters": "()", "modifiers": "@Override public", "return": "List<ACLRule>", "signature": "List<ACLRule> getRules()", "full_signature": "@Override public List<ACLRule> getRules()", "class_method_signature": "ACL.getRules()", "testcase": false, "constructor": false}, {"identifier": "checkRuleMatch", "parameters": "(ACLRule newRule)", "modifiers": "private", "return": "boolean", "signature": "boolean checkRuleMatch(ACLRule newRule)", "full_signature": "private boolean checkRuleMatch(ACLRule newRule)", "class_method_signature": "ACL.checkRuleMatch(ACLRule newRule)", "testcase": false, "constructor": false}, {"identifier": "addRule", "parameters": "(ACLRule rule)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean addRule(ACLRule rule)", "full_signature": "@Override public boolean addRule(ACLRule rule)", "class_method_signature": "ACL.addRule(ACLRule rule)", "testcase": false, "constructor": false}, {"identifier": "removeRule", "parameters": "(int ruleid)", "modifiers": "@Override public", "return": "void", "signature": "void removeRule(int ruleid)", "full_signature": "@Override public void removeRule(int ruleid)", "class_method_signature": "ACL.removeRule(int ruleid)", "testcase": false, "constructor": false}, {"identifier": "removeAllRules", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void removeAllRules()", "full_signature": "@Override public void removeAllRules()", "class_method_signature": "ACL.removeAllRules()", "testcase": false, "constructor": false}, {"identifier": "enforceAddedRule", "parameters": "(ACLRule rule)", "modifiers": "private", "return": "void", "signature": "void enforceAddedRule(ACLRule rule)", "full_signature": "private void enforceAddedRule(ACLRule rule)", "class_method_signature": "ACL.enforceAddedRule(ACLRule rule)", "testcase": false, "constructor": false}, {"identifier": "enforceRemovedRule", "parameters": "(int ruleId)", "modifiers": "private", "return": "void", "signature": "void enforceRemovedRule(int ruleId)", "full_signature": "private void enforceRemovedRule(int ruleId)", "class_method_signature": "ACL.enforceRemovedRule(int ruleId)", "testcase": false, "constructor": false}, {"identifier": "generateFlow", "parameters": "(ACLRule rule, String dpid, String flowName)", "modifiers": "private", "return": "void", "signature": "void generateFlow(ACLRule rule, String dpid, String flowName)", "full_signature": "private void generateFlow(ACLRule rule, String dpid, String flowName)", "class_method_signature": "ACL.generateFlow(ACLRule rule, String dpid, String flowName)", "testcase": false, "constructor": false}, {"identifier": "removeFlow", "parameters": "(String name)", "modifiers": "private", "return": "void", "signature": "void removeFlow(String name)", "full_signature": "private void removeFlow(String name)", "class_method_signature": "ACL.removeFlow(String name)", "testcase": false, "constructor": false}, {"identifier": "getModuleServices", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleServices()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleServices()", "class_method_signature": "ACL.getModuleServices()", "testcase": false, "constructor": false}, {"identifier": "getServiceImpls", "parameters": "()", "modifiers": "@Override public", "return": "Map<Class<? extends IFloodlightService>, IFloodlightService>", "signature": "Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "full_signature": "@Override public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "class_method_signature": "ACL.getServiceImpls()", "testcase": false, "constructor": false}, {"identifier": "getModuleDependencies", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "class_method_signature": "ACL.getModuleDependencies()", "testcase": false, "constructor": false}, {"identifier": "init", "parameters": "(FloodlightModuleContext context)", "modifiers": "@Override public", "return": "void", "signature": "void init(FloodlightModuleContext context)", "full_signature": "@Override public void init(FloodlightModuleContext context)", "class_method_signature": "ACL.init(FloodlightModuleContext context)", "testcase": false, "constructor": false}, {"identifier": "startUp", "parameters": "(FloodlightModuleContext context)", "modifiers": "@Override public", "return": "void", "signature": "void startUp(FloodlightModuleContext context)", "full_signature": "@Override public void startUp(FloodlightModuleContext context)", "class_method_signature": "ACL.startUp(FloodlightModuleContext context)", "testcase": false, "constructor": false}, {"identifier": "deviceAdded", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "signature": "void deviceAdded(IDevice device)", "full_signature": "@Override public void deviceAdded(IDevice device)", "class_method_signature": "ACL.deviceAdded(IDevice device)", "testcase": false, "constructor": false}, {"identifier": "processAPAdded", "parameters": "(AP ap)", "modifiers": "private", "return": "void", "signature": "void processAPAdded(AP ap)", "full_signature": "private void processAPAdded(AP ap)", "class_method_signature": "ACL.processAPAdded(AP ap)", "testcase": false, "constructor": false}, {"identifier": "deviceRemoved", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "signature": "void deviceRemoved(IDevice device)", "full_signature": "@Override public void deviceRemoved(IDevice device)", "class_method_signature": "ACL.deviceRemoved(IDevice device)", "testcase": false, "constructor": false}, {"identifier": "deviceMoved", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "signature": "void deviceMoved(IDevice device)", "full_signature": "@Override public void deviceMoved(IDevice device)", "class_method_signature": "ACL.deviceMoved(IDevice device)", "testcase": false, "constructor": false}, {"identifier": "deviceIPV4AddrChanged", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "signature": "void deviceIPV4AddrChanged(IDevice device)", "full_signature": "@Override public void deviceIPV4AddrChanged(IDevice device)", "class_method_signature": "ACL.deviceIPV4AddrChanged(IDevice device)", "testcase": false, "constructor": false}, {"identifier": "deviceVlanChanged", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "signature": "void deviceVlanChanged(IDevice device)", "full_signature": "@Override public void deviceVlanChanged(IDevice device)", "class_method_signature": "ACL.deviceVlanChanged(IDevice device)", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getName()", "full_signature": "@Override public String getName()", "class_method_signature": "ACL.getName()", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPrereq", "parameters": "(String type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPrereq(String type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPrereq(String type, String name)", "class_method_signature": "ACL.isCallbackOrderingPrereq(String type, String name)", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPostreq", "parameters": "(String type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPostreq(String type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPostreq(String type, String name)", "class_method_signature": "ACL.isCallbackOrderingPostreq(String type, String name)", "testcase": false, "constructor": false}], "file": "src/agents/apps/floodlight/floodlight-1.1/src/main/java/net/floodlightcontroller/accesscontrollist/ACL.java"}, "focal_method": {"identifier": "addRule", "parameters": "(ACLRule rule)", "modifiers": "@Override public", "return": "boolean", "body": "@Override\n\tpublic boolean addRule(ACLRule rule) {\n\n\t\tif(checkRuleMatch(rule)){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\trule.setId(lastRuleId++);\n\t\tthis.ruleSet.add(rule);\n\t\tlogger.info(\"No.{} ACL rule added.\", rule.getId());\n\t\tenforceAddedRule(rule);\n\t\treturn true;\n\t}", "signature": "boolean addRule(ACLRule rule)", "full_signature": "@Override public boolean addRule(ACLRule rule)", "class_method_signature": "ACL.addRule(ACLRule rule)", "testcase": false, "constructor": false, "invocations": ["checkRuleMatch", "setId", "add", "info", "getId", "enforceAddedRule"]}, "repository": {"repo_id": 181421086, "url": "https://github.com/seungsoo-lee/DELTA", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 35, "size": 99244, "license": "licensed"}}