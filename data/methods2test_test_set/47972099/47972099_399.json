{"test_class": {"identifier": "SavepointCoordinatorTest", "superclass": "", "interfaces": "", "fields": [], "file": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/SavepointCoordinatorTest.java"}, "test_case": {"identifier": "testRollbackSetsCheckpointID", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testRollbackSetsCheckpointID() throws Exception {\n\t\tCompletedCheckpoint savepoint = mock(CompletedCheckpoint.class);\n\t\twhen(savepoint.getStates()).thenReturn(Collections.<StateForTask>emptyList());\n\t\twhen(savepoint.getCheckpointID()).thenReturn(12312312L);\n\n\t\tCheckpointIDCounter checkpointIdCounter = mock(CheckpointIDCounter.class);\n\n\t\tStateStore<CompletedCheckpoint> savepointStore = mock(StateStore.class);\n\t\twhen(savepointStore.getState(anyString())).thenReturn(savepoint);\n\n\t\tSavepointCoordinator coordinator = createSavepointCoordinator(\n\t\t\t\tnew JobID(),\n\t\t\t\t60 * 1000,\n\t\t\t\tnew ExecutionVertex[] {},\n\t\t\t\tnew ExecutionVertex[] {},\n\t\t\t\tnew ExecutionVertex[] {},\n\t\t\t\tcheckpointIdCounter,\n\t\t\t\tsavepointStore);\n\n\t\tcoordinator.restoreSavepoint(createExecutionJobVertexMap(), \"any\");\n\n\t\tverify(checkpointIdCounter).setCount(eq(12312312L + 1));\n\n\t\tcoordinator.shutdown();\n\t}", "signature": "void testRollbackSetsCheckpointID()", "full_signature": "@Test public void testRollbackSetsCheckpointID()", "class_method_signature": "SavepointCoordinatorTest.testRollbackSetsCheckpointID()", "testcase": true, "constructor": false, "invocations": ["mock", "thenReturn", "when", "getStates", "emptyList", "thenReturn", "when", "getCheckpointID", "mock", "mock", "thenReturn", "when", "getState", "anyString", "createSavepointCoordinator", "restoreSavepoint", "createExecutionJobVertexMap", "setCount", "verify", "eq", "shutdown"]}, "focal_class": {"identifier": "SavepointCoordinator", "superclass": "extends CheckpointCoordinator", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(SavepointCoordinator.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(SavepointCoordinator.class)", "var_name": "LOG"}, {"original_string": "private StateStore<CompletedCheckpoint> savepointStore;", "modifier": "private", "type": "StateStore<CompletedCheckpoint>", "declarator": "savepointStore", "var_name": "savepointStore"}, {"original_string": "private final Map<Long, Promise<String>> savepointPromises;", "modifier": "private final", "type": "Map<Long, Promise<String>>", "declarator": "savepointPromises", "var_name": "savepointPromises"}, {"original_string": "private volatile String savepointRestorePath;", "modifier": "private volatile", "type": "String", "declarator": "savepointRestorePath", "var_name": "savepointRestorePath"}], "methods": [{"identifier": "SavepointCoordinator", "parameters": "(\n\t\t\tJobID jobId,\n\t\t\tlong baseInterval,\n\t\t\tlong checkpointTimeout,\n\t\t\tExecutionVertex[] tasksToTrigger,\n\t\t\tExecutionVertex[] tasksToWaitFor,\n\t\t\tExecutionVertex[] tasksToCommitTo,\n\t\t\tClassLoader userClassLoader,\n\t\t\tCheckpointIDCounter checkpointIDCounter,\n\t\t\tStateStore<CompletedCheckpoint> savepointStore,\n\t\t\tCheckpointStatsTracker statsTracker)", "modifiers": "public", "return": "", "signature": " SavepointCoordinator(\n\t\t\tJobID jobId,\n\t\t\tlong baseInterval,\n\t\t\tlong checkpointTimeout,\n\t\t\tExecutionVertex[] tasksToTrigger,\n\t\t\tExecutionVertex[] tasksToWaitFor,\n\t\t\tExecutionVertex[] tasksToCommitTo,\n\t\t\tClassLoader userClassLoader,\n\t\t\tCheckpointIDCounter checkpointIDCounter,\n\t\t\tStateStore<CompletedCheckpoint> savepointStore,\n\t\t\tCheckpointStatsTracker statsTracker)", "full_signature": "public  SavepointCoordinator(\n\t\t\tJobID jobId,\n\t\t\tlong baseInterval,\n\t\t\tlong checkpointTimeout,\n\t\t\tExecutionVertex[] tasksToTrigger,\n\t\t\tExecutionVertex[] tasksToWaitFor,\n\t\t\tExecutionVertex[] tasksToCommitTo,\n\t\t\tClassLoader userClassLoader,\n\t\t\tCheckpointIDCounter checkpointIDCounter,\n\t\t\tStateStore<CompletedCheckpoint> savepointStore,\n\t\t\tCheckpointStatsTracker statsTracker)", "class_method_signature": "SavepointCoordinator.SavepointCoordinator(\n\t\t\tJobID jobId,\n\t\t\tlong baseInterval,\n\t\t\tlong checkpointTimeout,\n\t\t\tExecutionVertex[] tasksToTrigger,\n\t\t\tExecutionVertex[] tasksToWaitFor,\n\t\t\tExecutionVertex[] tasksToCommitTo,\n\t\t\tClassLoader userClassLoader,\n\t\t\tCheckpointIDCounter checkpointIDCounter,\n\t\t\tStateStore<CompletedCheckpoint> savepointStore,\n\t\t\tCheckpointStatsTracker statsTracker)", "testcase": false, "constructor": true}, {"identifier": "getSavepointRestorePath", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getSavepointRestorePath()", "full_signature": "public String getSavepointRestorePath()", "class_method_signature": "SavepointCoordinator.getSavepointRestorePath()", "testcase": false, "constructor": false}, {"identifier": "triggerSavepoint", "parameters": "(long timestamp)", "modifiers": "public", "return": "Future<String>", "signature": "Future<String> triggerSavepoint(long timestamp)", "full_signature": "public Future<String> triggerSavepoint(long timestamp)", "class_method_signature": "SavepointCoordinator.triggerSavepoint(long timestamp)", "testcase": false, "constructor": false}, {"identifier": "restoreSavepoint", "parameters": "(\n\t\t\tMap<JobVertexID, ExecutionJobVertex> tasks,\n\t\t\tString savepointPath)", "modifiers": "public", "return": "void", "signature": "void restoreSavepoint(\n\t\t\tMap<JobVertexID, ExecutionJobVertex> tasks,\n\t\t\tString savepointPath)", "full_signature": "public void restoreSavepoint(\n\t\t\tMap<JobVertexID, ExecutionJobVertex> tasks,\n\t\t\tString savepointPath)", "class_method_signature": "SavepointCoordinator.restoreSavepoint(\n\t\t\tMap<JobVertexID, ExecutionJobVertex> tasks,\n\t\t\tString savepointPath)", "testcase": false, "constructor": false}, {"identifier": "onShutdown", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void onShutdown()", "full_signature": "@Override protected void onShutdown()", "class_method_signature": "SavepointCoordinator.onShutdown()", "testcase": false, "constructor": false}, {"identifier": "onCancelCheckpoint", "parameters": "(long canceledCheckpointId)", "modifiers": "@Override protected", "return": "void", "signature": "void onCancelCheckpoint(long canceledCheckpointId)", "full_signature": "@Override protected void onCancelCheckpoint(long canceledCheckpointId)", "class_method_signature": "SavepointCoordinator.onCancelCheckpoint(long canceledCheckpointId)", "testcase": false, "constructor": false}, {"identifier": "onFullyAcknowledgedCheckpoint", "parameters": "(CompletedCheckpoint checkpoint)", "modifiers": "@Override protected", "return": "void", "signature": "void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint)", "full_signature": "@Override protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint)", "class_method_signature": "SavepointCoordinator.onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint)", "testcase": false, "constructor": false}, {"identifier": "createActivatorDeactivator", "parameters": "(\n\t\t\tActorSystem actorSystem,\n\t\t\tUUID leaderSessionID)", "modifiers": "@Override public", "return": "ActorGateway", "signature": "ActorGateway createActivatorDeactivator(\n\t\t\tActorSystem actorSystem,\n\t\t\tUUID leaderSessionID)", "full_signature": "@Override public ActorGateway createActivatorDeactivator(\n\t\t\tActorSystem actorSystem,\n\t\t\tUUID leaderSessionID)", "class_method_signature": "SavepointCoordinator.createActivatorDeactivator(\n\t\t\tActorSystem actorSystem,\n\t\t\tUUID leaderSessionID)", "testcase": false, "constructor": false}], "file": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java"}, "focal_method": {"identifier": "restoreSavepoint", "parameters": "(\n\t\t\tMap<JobVertexID, ExecutionJobVertex> tasks,\n\t\t\tString savepointPath)", "modifiers": "public", "return": "void", "body": "public void restoreSavepoint(\n\t\t\tMap<JobVertexID, ExecutionJobVertex> tasks,\n\t\t\tString savepointPath) throws Exception {\n\n\t\tcheckNotNull(savepointPath, \"Savepoint path\");\n\n\t\tsynchronized (lock) {\n\t\t\tif (isShutdown()) {\n\t\t\t\tthrow new IllegalStateException(\"CheckpointCoordinator is shut down\");\n\t\t\t}\n\n\t\t\tlong recoveryTimestamp = System.currentTimeMillis();\n\n\t\t\tLOG.info(\"Rolling back to savepoint '{}'.\", savepointPath);\n\n\t\t\tCompletedCheckpoint checkpoint = savepointStore.getState(savepointPath);\n\n\t\t\tLOG.info(\"Savepoint: {}@{}\", checkpoint.getCheckpointID(), checkpoint.getTimestamp());\n\n\t\t\t// Set the initial state of all tasks\n\t\t\tLOG.debug(\"Rolling back individual operators.\");\n\t\t\tfor (StateForTask state : checkpoint.getStates()) {\n\t\t\t\tLOG.debug(\"Rolling back subtask {} of operator {}.\",\n\t\t\t\t\t\tstate.getSubtask(), state.getOperatorId());\n\n\t\t\t\tExecutionJobVertex vertex = tasks.get(state.getOperatorId());\n\n\t\t\t\tif (vertex == null) {\n\t\t\t\t\tString msg = String.format(\"Failed to rollback to savepoint %s. \" +\n\t\t\t\t\t\t\t\"Cannot map old state for task %s to the new program. \" +\n\t\t\t\t\t\t\t\"This indicates that the program has been changed in a \" +\n\t\t\t\t\t\t\t\"non-compatible way  after the savepoint.\", checkpoint,\n\t\t\t\t\t\t\tstate.getOperatorId());\n\t\t\t\t\tthrow new IllegalStateException(msg);\n\t\t\t\t}\n\n\t\t\t\tif (state.getSubtask() >= vertex.getParallelism()) {\n\t\t\t\t\tString msg = String.format(\"Failed to rollback to savepoint %s. \" +\n\t\t\t\t\t\t\t\"Parallelism mismatch between savepoint state and new program. \" +\n\t\t\t\t\t\t\t\"Cannot map subtask %d of operator %s to new program with \" +\n\t\t\t\t\t\t\t\"parallelism %d. This indicates that the program has been changed \" +\n\t\t\t\t\t\t\t\"in a non-compatible way after the savepoint.\", checkpoint,\n\t\t\t\t\t\t\tstate.getSubtask(), state.getOperatorId(), vertex.getParallelism());\n\t\t\t\t\tthrow new IllegalStateException(msg);\n\t\t\t\t}\n\n\t\t\t\tExecution exec = vertex.getTaskVertices()[state.getSubtask()]\n\t\t\t\t\t\t.getCurrentExecutionAttempt();\n\n\t\t\t\texec.setInitialState(state.getState(), recoveryTimestamp);\n\t\t\t}\n\n\t\t\t// Reset the checkpoint ID counter\n\t\t\tlong nextCheckpointId = checkpoint.getCheckpointID();\n\t\t\tcheckpointIdCounter.start();\n\t\t\tcheckpointIdCounter.setCount(nextCheckpointId + 1);\n\t\t\tLOG.info(\"Reset the checkpoint ID to {}\", nextCheckpointId);\n\n\t\t\tif (savepointRestorePath == null) {\n\t\t\t\tsavepointRestorePath = savepointPath;\n\t\t\t}\n\t\t}\n\t}", "signature": "void restoreSavepoint(\n\t\t\tMap<JobVertexID, ExecutionJobVertex> tasks,\n\t\t\tString savepointPath)", "full_signature": "public void restoreSavepoint(\n\t\t\tMap<JobVertexID, ExecutionJobVertex> tasks,\n\t\t\tString savepointPath)", "class_method_signature": "SavepointCoordinator.restoreSavepoint(\n\t\t\tMap<JobVertexID, ExecutionJobVertex> tasks,\n\t\t\tString savepointPath)", "testcase": false, "constructor": false, "invocations": ["checkNotNull", "isShutdown", "currentTimeMillis", "info", "getState", "info", "getCheckpointID", "getTimestamp", "debug", "getStates", "debug", "getSubtask", "getOperatorId", "get", "getOperatorId", "format", "getOperatorId", "getSubtask", "getParallelism", "format", "getSubtask", "getOperatorId", "getParallelism", "getCurrentExecutionAttempt", "getTaskVertices", "getSubtask", "setInitialState", "getState", "getCheckpointID", "start", "setCount", "info"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}