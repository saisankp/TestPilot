{"test_class": {"identifier": "XlsImExporterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n  public TemporaryFolder tmpFolder= new TemporaryFolder();", "modifier": "@Rule\n  public", "type": "TemporaryFolder", "declarator": "tmpFolder= new TemporaryFolder()", "var_name": "tmpFolder"}], "file": "kilt-core/src/test/java/de/poiu/kilt/importexport/XlsImExporterTest.java"}, "test_case": {"identifier": "testImportXls_AddedLanguageColumn", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testImportXls_AddedLanguageColumn() throws IOException, URISyntaxException {\n\n    // - preparation\n\n    final Path propertiesRootDirectory= this.tmpFolder.newFolder().toPath();\n\n    final FileMatcher fileMatcher= new FileMatcher(propertiesRootDirectory, new String[]{\"**/*.properties\"}, new String[]{\"\"});\n\n    final File xlsFile= new File(Resources.getResource(\"i18n_added_fr.xlsx\").toURI());\n\n    // - test\n\n    XlsImExporter.importXls(fileMatcher, xlsFile, UTF_8, MissingKeyAction.NOTHING);\n\n    // - verification\n\n    final Path[] writtenResourceBundleFiles = Files.list(propertiesRootDirectory.resolve(\"i18n\")).toArray(Path[]::new);\n    assertThat(writtenResourceBundleFiles).containsOnly(\n      propertiesRootDirectory.resolve(\"i18n/messages.properties\"),\n      propertiesRootDirectory.resolve(\"i18n/messages_de.properties\"),\n      propertiesRootDirectory.resolve(\"i18n/messages_fr.properties\")\n    );\n    assertThat(propertiesRootDirectory.resolve(\"i18n\").resolve(\"messages.properties\").toFile())\n      .hasSameContentAs(propertiesRootDirectory.resolve(\"i18n\").resolve(\"messages.properties\").toFile());\n    assertThat(propertiesRootDirectory.resolve(\"i18n\").resolve(\"messages_de.properties\").toFile())\n      .hasSameContentAs(propertiesRootDirectory.resolve(\"i18n\").resolve(\"messages_de.properties\").toFile());\n    assertThat(propertiesRootDirectory.resolve(\"i18n\").resolve(\"messages_fr.properties\").toFile())\n      .hasContent(\"yes = Oui\\nno = Non\\n\");\n  }", "signature": "void testImportXls_AddedLanguageColumn()", "full_signature": "@Test public void testImportXls_AddedLanguageColumn()", "class_method_signature": "XlsImExporterTest.testImportXls_AddedLanguageColumn()", "testcase": true, "constructor": false, "invocations": ["toPath", "newFolder", "toURI", "getResource", "importXls", "toArray", "list", "resolve", "containsOnly", "assertThat", "resolve", "resolve", "resolve", "hasSameContentAs", "assertThat", "toFile", "resolve", "resolve", "toFile", "resolve", "resolve", "hasSameContentAs", "assertThat", "toFile", "resolve", "resolve", "toFile", "resolve", "resolve", "hasContent", "assertThat", "toFile", "resolve", "resolve"]}, "focal_class": {"identifier": "XlsImExporter", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER= LogManager.getLogger();", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER= LogManager.getLogger()", "var_name": "LOGGER"}], "methods": [{"identifier": "importXls", "parameters": "(final FileMatcher fileMatcher,\n                               final File xlsFile,\n                               final Charset propertyFileEncoding,\n                               final MissingKeyAction missingKeyAction)", "modifiers": "public static", "return": "void", "signature": "void importXls(final FileMatcher fileMatcher,\n                               final File xlsFile,\n                               final Charset propertyFileEncoding,\n                               final MissingKeyAction missingKeyAction)", "full_signature": "public static void importXls(final FileMatcher fileMatcher,\n                               final File xlsFile,\n                               final Charset propertyFileEncoding,\n                               final MissingKeyAction missingKeyAction)", "class_method_signature": "XlsImExporter.importXls(final FileMatcher fileMatcher,\n                               final File xlsFile,\n                               final Charset propertyFileEncoding,\n                               final MissingKeyAction missingKeyAction)", "testcase": false, "constructor": false}, {"identifier": "exportXls", "parameters": "(final FileMatcher fileMatcher,\n                               final Charset propertyFileEncoding,\n                               final File xlsFile)", "modifiers": "public static", "return": "void", "signature": "void exportXls(final FileMatcher fileMatcher,\n                               final Charset propertyFileEncoding,\n                               final File xlsFile)", "full_signature": "public static void exportXls(final FileMatcher fileMatcher,\n                               final Charset propertyFileEncoding,\n                               final File xlsFile)", "class_method_signature": "XlsImExporter.exportXls(final FileMatcher fileMatcher,\n                               final Charset propertyFileEncoding,\n                               final File xlsFile)", "testcase": false, "constructor": false}, {"identifier": "getFileForBundle", "parameters": "(final File propertiesRootDirectory, final String bundleBasename, final Language language)", "modifiers": "private static", "return": "File", "signature": "File getFileForBundle(final File propertiesRootDirectory, final String bundleBasename, final Language language)", "full_signature": "private static File getFileForBundle(final File propertiesRootDirectory, final String bundleBasename, final Language language)", "class_method_signature": "XlsImExporter.getFileForBundle(final File propertiesRootDirectory, final String bundleBasename, final Language language)", "testcase": false, "constructor": false}], "file": "kilt-core/src/main/java/de/poiu/kilt/importexport/XlsImExporter.java"}, "focal_method": {"identifier": "importXls", "parameters": "(final FileMatcher fileMatcher,\n                               final File xlsFile,\n                               final Charset propertyFileEncoding,\n                               final MissingKeyAction missingKeyAction)", "modifiers": "public static", "return": "void", "body": "public static void importXls(final FileMatcher fileMatcher,\n                               final File xlsFile,\n                               final Charset propertyFileEncoding,\n                               final MissingKeyAction missingKeyAction) {\n    Require.nonNull(fileMatcher);\n    Require.nonNull(xlsFile);\n\n    final ApronOptions apronOptions= ApronOptions.create()\n      .with(propertyFileEncoding != null ? propertyFileEncoding : UTF_8)\n      .with(missingKeyAction);\n\n    // read XLS file\n    final XlsFile xlsFileObject= new XlsFile(xlsFile);\n    final Map<I18nBundleKey, Collection<Translation>> content= xlsFileObject.getContent();\n\n    // stores the mapping of resource bundle basenames and languages to the corresponding property files\n    final Map<String, Map<Language, RememberingPropertyFile>> bundleFileMapping= new LinkedHashMap<>();\n\n    // FIXME: Sort by bundleBasename and language? In that case we only have to have 1 property file open at a time\n    content.entrySet().forEach((entry) -> {\n      final I18nBundleKey bundleKey= entry.getKey();\n      final String bundleBasename= bundleKey.getBundleBaseName();\n      final String propertyKey= bundleKey.getKey();\n      final Collection<Translation> translations= entry.getValue();\n\n      // for each bundle\u2026\n      for (final Translation translation : translations) {\n        if (!bundleFileMapping.containsKey(bundleBasename)) {\n          bundleFileMapping.put(bundleBasename, new LinkedHashMap<>());\n        }\n\n        if (!bundleFileMapping.get(bundleBasename).containsKey(translation.getLang())) {\n          final File fileForBundle= getFileForBundle(fileMatcher.getRoot().toFile(), bundleBasename, translation.getLang());\n\n          if (!fileMatcher.matches(fileForBundle.toPath())) {\n            LOGGER.log(Level.DEBUG, \"Skipping import to file {} since it does not match inclusion pattern\", fileForBundle);\n            continue;\n          }\n\n          final PropertyFile propertyFile= new PropertyFile();\n          bundleFileMapping.get(bundleBasename).put(translation.getLang(), new RememberingPropertyFile(fileForBundle, propertyFile));\n        }\n\n        final RememberingPropertyFile rpf= bundleFileMapping.get(bundleBasename).get(translation.getLang());\n        // only write empty values if the key already exists in in the PropertyFile\n        if ((translation.getValue() != null && !translation.getValue().isEmpty())\n          || rpf.propertyFile.containsKey(propertyKey)) {\n          rpf.propertyFile.setValue(propertyKey, translation.getValue());\n        }\n      }\n    });\n\n    //now write the property files back to disk\n    bundleFileMapping.values().forEach((Map<Language, RememberingPropertyFile> langPropMap) -> {\n      langPropMap.values().forEach((RememberingPropertyFile rpf) -> {\n        // only write files if they have some content (avoid creating unwanted empty files for unsupported locales)\n        if (rpf.propertyFile.propertiesSize()> 0) {\n          rpf.propertyFile.saveTo(rpf.actualFile, apronOptions);\n        }\n      });\n    });\n  }", "signature": "void importXls(final FileMatcher fileMatcher,\n                               final File xlsFile,\n                               final Charset propertyFileEncoding,\n                               final MissingKeyAction missingKeyAction)", "full_signature": "public static void importXls(final FileMatcher fileMatcher,\n                               final File xlsFile,\n                               final Charset propertyFileEncoding,\n                               final MissingKeyAction missingKeyAction)", "class_method_signature": "XlsImExporter.importXls(final FileMatcher fileMatcher,\n                               final File xlsFile,\n                               final Charset propertyFileEncoding,\n                               final MissingKeyAction missingKeyAction)", "testcase": false, "constructor": false, "invocations": ["nonNull", "nonNull", "with", "with", "create", "getContent", "forEach", "entrySet", "getKey", "getBundleBaseName", "getKey", "getValue", "containsKey", "put", "containsKey", "get", "getLang", "getFileForBundle", "toFile", "getRoot", "getLang", "matches", "toPath", "log", "put", "get", "getLang", "get", "get", "getLang", "getValue", "isEmpty", "getValue", "containsKey", "setValue", "getValue", "forEach", "values", "forEach", "values", "propertiesSize", "saveTo"]}, "repository": {"repo_id": 145957544, "url": "https://github.com/hupfdule/kilt", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 31, "size": 782, "license": "licensed"}}