{"test_class": {"identifier": "OffHeapByteBufferStoreTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "Random random;", "modifier": "", "type": "Random", "declarator": "random", "var_name": "random"}, {"original_string": "@Mock\n  Pointer pointer;", "modifier": "@Mock", "type": "Pointer", "declarator": "pointer", "var_name": "pointer"}, {"original_string": "@Mock\n  BlockingQueue<Integer> queue;", "modifier": "@Mock", "type": "BlockingQueue<Integer>", "declarator": "queue", "var_name": "queue"}, {"original_string": "@Mock\n  OffHeapByteBuffer buffer;", "modifier": "@Mock", "type": "OffHeapByteBuffer", "declarator": "buffer", "var_name": "buffer"}, {"original_string": "@Spy\n  OffHeapByteBufferStore bufferStore = new OffHeapByteBufferStore(1000, 1);", "modifier": "@Spy", "type": "OffHeapByteBufferStore", "declarator": "bufferStore = new OffHeapByteBufferStore(1000, 1)", "var_name": "bufferStore"}], "file": "imcache-offheap/src/test/java/com/cetsoft/imcache/offheap/bytebuffer/OffHeapByteBufferStoreTest.java"}, "test_case": {"identifier": "update", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void update() {\n    int size = 100;\n    final long expiry = System.currentTimeMillis();\n    byte[] bytes = new byte[size];\n    random.nextBytes(bytes);\n    Pointer pointer = bufferStore.store(bytes, expiry);\n    byte[] expectedBytes = new byte[size];\n    random.nextBytes(expectedBytes);\n    pointer = bufferStore.update(pointer, expectedBytes, expiry);\n    byte[] actualBytes = bufferStore.retrieve(pointer);\n    assertArrayEquals(expectedBytes, actualBytes);\n  }", "signature": "void update()", "full_signature": "@Test public void update()", "class_method_signature": "OffHeapByteBufferStoreTest.update()", "testcase": true, "constructor": false, "invocations": ["currentTimeMillis", "nextBytes", "store", "nextBytes", "update", "retrieve", "assertArrayEquals"]}, "focal_class": {"identifier": "OffHeapByteBufferStore", "superclass": "", "interfaces": "implements OffHeapStore", "fields": [{"original_string": "protected OffHeapByteBuffer[] buffers;", "modifier": "protected", "type": "OffHeapByteBuffer[]", "declarator": "buffers", "var_name": "buffers"}, {"original_string": "protected BlockingQueue<Integer> availableBuffers;", "modifier": "protected", "type": "BlockingQueue<Integer>", "declarator": "availableBuffers", "var_name": "availableBuffers"}, {"original_string": "private volatile int bufferSize;", "modifier": "private volatile", "type": "int", "declarator": "bufferSize", "var_name": "bufferSize"}, {"original_string": "private AtomicInteger currentBuffer = new AtomicInteger(0);", "modifier": "private", "type": "AtomicInteger", "declarator": "currentBuffer = new AtomicInteger(0)", "var_name": "currentBuffer"}, {"original_string": "private Lock bufferChangeLock = new ReentrantLock();", "modifier": "private", "type": "Lock", "declarator": "bufferChangeLock = new ReentrantLock()", "var_name": "bufferChangeLock"}], "methods": [{"identifier": "OffHeapByteBufferStore", "parameters": "(int capacity, int bufferSize)", "modifiers": "public", "return": "", "signature": " OffHeapByteBufferStore(int capacity, int bufferSize)", "full_signature": "public  OffHeapByteBufferStore(int capacity, int bufferSize)", "class_method_signature": "OffHeapByteBufferStore.OffHeapByteBufferStore(int capacity, int bufferSize)", "testcase": false, "constructor": true}, {"identifier": "OffHeapByteBufferStore", "parameters": "(int capacity, int bufferSize, int concurrencyLevel)", "modifiers": "public", "return": "", "signature": " OffHeapByteBufferStore(int capacity, int bufferSize, int concurrencyLevel)", "full_signature": "public  OffHeapByteBufferStore(int capacity, int bufferSize, int concurrencyLevel)", "class_method_signature": "OffHeapByteBufferStore.OffHeapByteBufferStore(int capacity, int bufferSize, int concurrencyLevel)", "testcase": false, "constructor": true}, {"identifier": "retrieve", "parameters": "(Pointer pointer)", "modifiers": "public", "return": "byte[]", "signature": "byte[] retrieve(Pointer pointer)", "full_signature": "public byte[] retrieve(Pointer pointer)", "class_method_signature": "OffHeapByteBufferStore.retrieve(Pointer pointer)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(Pointer pointer)", "modifiers": "public", "return": "byte[]", "signature": "byte[] remove(Pointer pointer)", "full_signature": "public byte[] remove(Pointer pointer)", "class_method_signature": "OffHeapByteBufferStore.remove(Pointer pointer)", "testcase": false, "constructor": false}, {"identifier": "store", "parameters": "(byte[] payload, long expiry)", "modifiers": "public", "return": "Pointer", "signature": "Pointer store(byte[] payload, long expiry)", "full_signature": "public Pointer store(byte[] payload, long expiry)", "class_method_signature": "OffHeapByteBufferStore.store(byte[] payload, long expiry)", "testcase": false, "constructor": false}, {"identifier": "nextBuffer", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void nextBuffer()", "full_signature": "protected void nextBuffer()", "class_method_signature": "OffHeapByteBufferStore.nextBuffer()", "testcase": false, "constructor": false}, {"identifier": "store", "parameters": "(final byte[] payload, final OffHeapByteBuffer buffer, final long expiry)", "modifiers": "protected", "return": "Pointer", "signature": "Pointer store(final byte[] payload, final OffHeapByteBuffer buffer, final long expiry)", "full_signature": "protected Pointer store(final byte[] payload, final OffHeapByteBuffer buffer, final long expiry)", "class_method_signature": "OffHeapByteBufferStore.store(final byte[] payload, final OffHeapByteBuffer buffer, final long expiry)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(final Pointer pointer, final byte[] payload, final long expiry)", "modifiers": "public", "return": "Pointer", "signature": "Pointer update(final Pointer pointer, final byte[] payload, final long expiry)", "full_signature": "public Pointer update(final Pointer pointer, final byte[] payload, final long expiry)", "class_method_signature": "OffHeapByteBufferStore.update(final Pointer pointer, final byte[] payload, final long expiry)", "testcase": false, "constructor": false}, {"identifier": "dirtyMemory", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long dirtyMemory()", "full_signature": "public long dirtyMemory()", "class_method_signature": "OffHeapByteBufferStore.dirtyMemory()", "testcase": false, "constructor": false}, {"identifier": "usedMemory", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long usedMemory()", "full_signature": "public long usedMemory()", "class_method_signature": "OffHeapByteBufferStore.usedMemory()", "testcase": false, "constructor": false}, {"identifier": "freeMemory", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long freeMemory()", "full_signature": "public long freeMemory()", "class_method_signature": "OffHeapByteBufferStore.freeMemory()", "testcase": false, "constructor": false}, {"identifier": "free", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void free()", "full_signature": "public void free()", "class_method_signature": "OffHeapByteBufferStore.free()", "testcase": false, "constructor": false}, {"identifier": "free", "parameters": "(int bufferIndex)", "modifiers": "public", "return": "void", "signature": "void free(int bufferIndex)", "full_signature": "public void free(int bufferIndex)", "class_method_signature": "OffHeapByteBufferStore.free(int bufferIndex)", "testcase": false, "constructor": false}, {"identifier": "currentBuffer", "parameters": "()", "modifiers": "protected", "return": "OffHeapByteBuffer", "signature": "OffHeapByteBuffer currentBuffer()", "full_signature": "protected OffHeapByteBuffer currentBuffer()", "class_method_signature": "OffHeapByteBufferStore.currentBuffer()", "testcase": false, "constructor": false}], "file": "imcache-offheap/src/main/java/com/cetsoft/imcache/offheap/bytebuffer/OffHeapByteBufferStore.java"}, "focal_method": {"identifier": "update", "parameters": "(final Pointer pointer, final byte[] payload, final long expiry)", "modifiers": "public", "return": "Pointer", "body": "public Pointer update(final Pointer pointer, final byte[] payload, final long expiry) {\n    try {\n      return pointer.getOffHeapByteBuffer().update(pointer, payload, expiry);\n    } catch (final BufferOverflowException exception) {\n      return store(payload, expiry);\n    }\n  }", "signature": "Pointer update(final Pointer pointer, final byte[] payload, final long expiry)", "full_signature": "public Pointer update(final Pointer pointer, final byte[] payload, final long expiry)", "class_method_signature": "OffHeapByteBufferStore.update(final Pointer pointer, final byte[] payload, final long expiry)", "testcase": false, "constructor": false, "invocations": ["update", "getOffHeapByteBuffer", "store"]}, "repository": {"repo_id": 12849994, "url": "https://github.com/Cetsoft/imcache", "language": "Java", "is_fork": false, "fork_count": 38, "stargazer_count": 121, "size": 1599, "license": "licensed"}}