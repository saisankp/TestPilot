{"test_class": {"identifier": "JobControllerServiceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "JobRepository jobRepository;", "modifier": "", "type": "JobRepository", "declarator": "jobRepository", "var_name": "jobRepository"}, {"original_string": "@Mock CoreServiceGrpc.CoreServiceBlockingStub specService;", "modifier": "@Mock", "type": "CoreServiceGrpc.CoreServiceBlockingStub", "declarator": "specService", "var_name": "specService"}, {"original_string": "private FeastProperties feastProperties;", "modifier": "private", "type": "FeastProperties", "declarator": "feastProperties", "var_name": "feastProperties"}, {"original_string": "private JobControllerService controllerWithConsolidation;", "modifier": "private", "type": "JobControllerService", "declarator": "controllerWithConsolidation", "var_name": "controllerWithConsolidation"}, {"original_string": "private JobControllerService controllerWithJobPerStore;", "modifier": "private", "type": "JobControllerService", "declarator": "controllerWithJobPerStore", "var_name": "controllerWithJobPerStore"}], "file": "job-controller/src/test/java/feast/jobcontroller/service/JobControllerServiceTest.java"}, "test_case": {"identifier": "shouldCloneRunningJobOnUpgrade", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void shouldCloneRunningJobOnUpgrade() throws InvalidProtocolBufferException {\n    Store store1 =\n        DataGenerator.createStore(\n            \"test-1\", Store.StoreType.REDIS, ImmutableList.of(Triple.of(\"*\", \"*\", false)));\n    Store store2 =\n        DataGenerator.createStore(\n            \"test-2\", Store.StoreType.REDIS, ImmutableList.of(Triple.of(\"*\", \"*\", false)));\n\n    Source source = DataGenerator.createSource(\"servers:9092\", \"topic\");\n\n    Job existingJob =\n        Job.builder()\n            .setId(\"some-id\")\n            .setSource(source)\n            .setStores(ImmutableMap.of(store1.getName(), store1))\n            .build();\n\n    existingJob.setExtId(\"extId\");\n    existingJob.setStatus(JobStatus.RUNNING);\n\n    jobRepository.add(existingJob);\n\n    List<JobTask> jobTasks =\n        controllerWithConsolidation.makeJobUpdateTasks(\n            ImmutableList.of(Pair.of(source, ImmutableSet.of(store1, store2))));\n\n    assertThat(jobTasks, hasSize(1));\n    assertThat(jobTasks, hasItem(isA(CreateJobTask.class)));\n  }", "signature": "void shouldCloneRunningJobOnUpgrade()", "full_signature": "@Test public void shouldCloneRunningJobOnUpgrade()", "class_method_signature": "JobControllerServiceTest.shouldCloneRunningJobOnUpgrade()", "testcase": true, "constructor": false, "invocations": ["createStore", "of", "of", "createStore", "of", "of", "createSource", "build", "setStores", "setSource", "setId", "builder", "of", "getName", "setExtId", "setStatus", "add", "makeJobUpdateTasks", "of", "of", "of", "assertThat", "hasSize", "assertThat", "hasItem", "isA"]}, "focal_class": {"identifier": "JobControllerService", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final int SPEC_PUBLISHING_TIMEOUT_SECONDS = 5;", "modifier": "private final", "type": "int", "declarator": "SPEC_PUBLISHING_TIMEOUT_SECONDS = 5", "var_name": "SPEC_PUBLISHING_TIMEOUT_SECONDS"}, {"original_string": "public static final String VERSION_LABEL = \"feast_version\";", "modifier": "public static final", "type": "String", "declarator": "VERSION_LABEL = \"feast_version\"", "var_name": "VERSION_LABEL"}, {"original_string": "private final JobRepository jobRepository;", "modifier": "private final", "type": "JobRepository", "declarator": "jobRepository", "var_name": "jobRepository"}, {"original_string": "private final CoreServiceGrpc.CoreServiceBlockingStub specService;", "modifier": "private final", "type": "CoreServiceGrpc.CoreServiceBlockingStub", "declarator": "specService", "var_name": "specService"}, {"original_string": "private final JobManager jobManager;", "modifier": "private final", "type": "JobManager", "declarator": "jobManager", "var_name": "jobManager"}, {"original_string": "private final JobProperties jobProperties;", "modifier": "private final", "type": "JobProperties", "declarator": "jobProperties", "var_name": "jobProperties"}, {"original_string": "private final JobGroupingStrategy groupingStrategy;", "modifier": "private final", "type": "JobGroupingStrategy", "declarator": "groupingStrategy", "var_name": "groupingStrategy"}, {"original_string": "private final KafkaTemplate<String, FeatureSetSpec> specPublisher;", "modifier": "private final", "type": "KafkaTemplate<String, FeatureSetSpec>", "declarator": "specPublisher", "var_name": "specPublisher"}, {"original_string": "private final List<Store.Subscription> featureSetSubscriptions;", "modifier": "private final", "type": "List<Store.Subscription>", "declarator": "featureSetSubscriptions", "var_name": "featureSetSubscriptions"}, {"original_string": "private final List<String> whitelistedStores;", "modifier": "private final", "type": "List<String>", "declarator": "whitelistedStores", "var_name": "whitelistedStores"}, {"original_string": "private final Map<String, String> jobLabels;", "modifier": "private final", "type": "Map<String, String>", "declarator": "jobLabels", "var_name": "jobLabels"}, {"original_string": "private final String currentVersion;", "modifier": "private final", "type": "String", "declarator": "currentVersion", "var_name": "currentVersion"}], "methods": [{"identifier": "JobControllerService", "parameters": "(\n      JobRepository jobRepository,\n      CoreServiceGrpc.CoreServiceBlockingStub specService,\n      JobManager jobManager,\n      FeastProperties feastProperties,\n      JobGroupingStrategy groupingStrategy,\n      KafkaTemplate<String, FeatureSetSpec> specPublisher)", "modifiers": "@Autowired public", "return": "", "signature": " JobControllerService(\n      JobRepository jobRepository,\n      CoreServiceGrpc.CoreServiceBlockingStub specService,\n      JobManager jobManager,\n      FeastProperties feastProperties,\n      JobGroupingStrategy groupingStrategy,\n      KafkaTemplate<String, FeatureSetSpec> specPublisher)", "full_signature": "@Autowired public  JobControllerService(\n      JobRepository jobRepository,\n      CoreServiceGrpc.CoreServiceBlockingStub specService,\n      JobManager jobManager,\n      FeastProperties feastProperties,\n      JobGroupingStrategy groupingStrategy,\n      KafkaTemplate<String, FeatureSetSpec> specPublisher)", "class_method_signature": "JobControllerService.JobControllerService(\n      JobRepository jobRepository,\n      CoreServiceGrpc.CoreServiceBlockingStub specService,\n      JobManager jobManager,\n      FeastProperties feastProperties,\n      JobGroupingStrategy groupingStrategy,\n      KafkaTemplate<String, FeatureSetSpec> specPublisher)", "testcase": false, "constructor": true}, {"identifier": "getVersionLabel", "parameters": "()", "modifiers": "private", "return": "String", "signature": "String getVersionLabel()", "full_signature": "private String getVersionLabel()", "class_method_signature": "JobControllerService.getVersionLabel()", "testcase": false, "constructor": false}, {"identifier": "Poll", "parameters": "()", "modifiers": "@Scheduled(fixedDelayString = \"${feast.jobs.polling_interval_milliseconds}\") public", "return": "void", "signature": "void Poll()", "full_signature": "@Scheduled(fixedDelayString = \"${feast.jobs.polling_interval_milliseconds}\") public void Poll()", "class_method_signature": "JobControllerService.Poll()", "testcase": false, "constructor": false}, {"identifier": "startOrUpdateJobs", "parameters": "(List<JobTask> tasks)", "modifiers": "", "return": "void", "signature": "void startOrUpdateJobs(List<JobTask> tasks)", "full_signature": " void startOrUpdateJobs(List<JobTask> tasks)", "class_method_signature": "JobControllerService.startOrUpdateJobs(List<JobTask> tasks)", "testcase": false, "constructor": false}, {"identifier": "makeJobUpdateTasks", "parameters": "(Iterable<Pair<Source, Set<Store>>> sourceToStores)", "modifiers": "", "return": "List<JobTask>", "signature": "List<JobTask> makeJobUpdateTasks(Iterable<Pair<Source, Set<Store>>> sourceToStores)", "full_signature": " List<JobTask> makeJobUpdateTasks(Iterable<Pair<Source, Set<Store>>> sourceToStores)", "class_method_signature": "JobControllerService.makeJobUpdateTasks(Iterable<Pair<Source, Set<Store>>> sourceToStores)", "testcase": false, "constructor": false}, {"identifier": "jobRequiresUpgrade", "parameters": "(Job job, Set<Store> stores)", "modifiers": "private", "return": "boolean", "signature": "boolean jobRequiresUpgrade(Job job, Set<Store> stores)", "full_signature": "private boolean jobRequiresUpgrade(Job job, Set<Store> stores)", "class_method_signature": "JobControllerService.jobRequiresUpgrade(Job job, Set<Store> stores)", "testcase": false, "constructor": false}, {"identifier": "allocateFeatureSetToJobs", "parameters": "(FeatureSet featureSet)", "modifiers": "", "return": "FeatureSet", "signature": "FeatureSet allocateFeatureSetToJobs(FeatureSet featureSet)", "full_signature": " FeatureSet allocateFeatureSetToJobs(FeatureSet featureSet)", "class_method_signature": "JobControllerService.allocateFeatureSetToJobs(FeatureSet featureSet)", "testcase": false, "constructor": false}, {"identifier": "getExtraJobs", "parameters": "(List<Job> keepJobs)", "modifiers": "private", "return": "Collection<Job>", "signature": "Collection<Job> getExtraJobs(List<Job> keepJobs)", "full_signature": "private Collection<Job> getExtraJobs(List<Job> keepJobs)", "class_method_signature": "JobControllerService.getExtraJobs(List<Job> keepJobs)", "testcase": false, "constructor": false}, {"identifier": "getAllStores", "parameters": "()", "modifiers": "private", "return": "List<Store>", "signature": "List<Store> getAllStores()", "full_signature": "private List<Store> getAllStores()", "class_method_signature": "JobControllerService.getAllStores()", "testcase": false, "constructor": false}, {"identifier": "getSourceToStoreMappings", "parameters": "()", "modifiers": "", "return": "Iterable<Pair<Source, Set<Store>>>", "signature": "Iterable<Pair<Source, Set<Store>>> getSourceToStoreMappings()", "full_signature": " Iterable<Pair<Source, Set<Store>>> getSourceToStoreMappings()", "class_method_signature": "JobControllerService.getSourceToStoreMappings()", "testcase": false, "constructor": false}, {"identifier": "getFeatureSetsForStore", "parameters": "(Store store)", "modifiers": "", "return": "List<FeatureSet>", "signature": "List<FeatureSet> getFeatureSetsForStore(Store store)", "full_signature": " List<FeatureSet> getFeatureSetsForStore(Store store)", "class_method_signature": "JobControllerService.getFeatureSetsForStore(Store store)", "testcase": false, "constructor": false}, {"identifier": "notifyJobsWhenFeatureSetUpdated", "parameters": "()", "modifiers": "@Scheduled(fixedDelayString = \"${feast.stream.specsOptions.notifyIntervalMilliseconds}\") public", "return": "void", "signature": "void notifyJobsWhenFeatureSetUpdated()", "full_signature": "@Scheduled(fixedDelayString = \"${feast.stream.specsOptions.notifyIntervalMilliseconds}\") public void notifyJobsWhenFeatureSetUpdated()", "class_method_signature": "JobControllerService.notifyJobsWhenFeatureSetUpdated()", "testcase": false, "constructor": false}, {"identifier": "listenAckFromJobs", "parameters": "(\n      ConsumerRecord<String, IngestionJobProto.FeatureSetSpecAck> record)", "modifiers": "@KafkaListener( topics = {\"${feast.stream.specsOptions.specsAckTopic}\"}, containerFactory = \"kafkaAckListenerContainerFactory\") public", "return": "void", "signature": "void listenAckFromJobs(\n      ConsumerRecord<String, IngestionJobProto.FeatureSetSpecAck> record)", "full_signature": "@KafkaListener( topics = {\"${feast.stream.specsOptions.specsAckTopic}\"}, containerFactory = \"kafkaAckListenerContainerFactory\") public void listenAckFromJobs(\n      ConsumerRecord<String, IngestionJobProto.FeatureSetSpecAck> record)", "class_method_signature": "JobControllerService.listenAckFromJobs(\n      ConsumerRecord<String, IngestionJobProto.FeatureSetSpecAck> record)", "testcase": false, "constructor": false}], "file": "job-controller/src/main/java/feast/jobcontroller/service/JobControllerService.java"}, "focal_method": {"identifier": "makeJobUpdateTasks", "parameters": "(Iterable<Pair<Source, Set<Store>>> sourceToStores)", "modifiers": "", "return": "List<JobTask>", "body": "List<JobTask> makeJobUpdateTasks(Iterable<Pair<Source, Set<Store>>> sourceToStores) {\n    List<JobTask> jobTasks = new LinkedList<>();\n    // Ensure a running job for each source to store mapping\n    List<Job> activeJobs = new LinkedList<>();\n    boolean isSafeToStopJobs = true;\n\n    for (Pair<Source, Set<Store>> mapping : sourceToStores) {\n      Source source = mapping.getKey();\n      Set<Store> stores = mapping.getValue();\n\n      Job job = groupingStrategy.getOrCreateJob(source, stores, this.jobLabels);\n\n      if (job.isDeployed()) {\n        if (!job.isRunning()) {\n          jobTasks.add(new UpdateJobStatusTask(job, jobManager));\n\n          // Mark that it is not safe to stop jobs without disrupting ingestion\n          isSafeToStopJobs = false;\n          continue;\n        }\n\n        if (jobRequiresUpgrade(job, stores) && job.isRunning()) {\n          // Since we want to upgrade job without downtime\n          // it would make sense to spawn clone of current job\n          // and terminate old version on the next Poll.\n          // Both jobs should be in the same consumer group and not conflict with each other\n          job = job.cloneWithIdAndLabels(groupingStrategy.createJobId(job), this.jobLabels);\n          job.addAllStores(stores);\n\n          isSafeToStopJobs = false;\n\n          jobTasks.add(new CreateJobTask(job, jobManager));\n        } else {\n          jobTasks.add(new UpdateJobStatusTask(job, jobManager));\n        }\n      } else {\n        job.addAllFeatureSets(\n            stores.stream()\n                .flatMap(s -> getFeatureSetsForStore(s).stream())\n                .filter(fs -> fs.getSpec().getSource().equals(source))\n                .collect(Collectors.toSet()));\n\n        jobTasks.add(new CreateJobTask(job, jobManager));\n      }\n\n      // Record the job as required to safeguard it from getting stopped\n      activeJobs.add(job);\n    }\n    // Stop extra jobs that are not required to maintain ingestion when safe\n    if (isSafeToStopJobs) {\n      getExtraJobs(activeJobs)\n          .forEach(\n              extraJob -> {\n                jobTasks.add(new TerminateJobTask(extraJob, jobManager));\n              });\n    }\n\n    return jobTasks;\n  }", "signature": "List<JobTask> makeJobUpdateTasks(Iterable<Pair<Source, Set<Store>>> sourceToStores)", "full_signature": " List<JobTask> makeJobUpdateTasks(Iterable<Pair<Source, Set<Store>>> sourceToStores)", "class_method_signature": "JobControllerService.makeJobUpdateTasks(Iterable<Pair<Source, Set<Store>>> sourceToStores)", "testcase": false, "constructor": false, "invocations": ["getKey", "getValue", "getOrCreateJob", "isDeployed", "isRunning", "add", "jobRequiresUpgrade", "isRunning", "cloneWithIdAndLabels", "createJobId", "addAllStores", "add", "add", "addAllFeatureSets", "collect", "filter", "flatMap", "stream", "stream", "getFeatureSetsForStore", "equals", "getSource", "getSpec", "toSet", "add", "add", "forEach", "getExtraJobs", "add"]}, "repository": {"repo_id": 161133770, "url": "https://github.com/gojek/feast", "stars": 633, "created": "12/10/2018 7:20:15 AM +00:00", "updates": "2020-01-27T12:39:33+00:00", "fork": "False", "license": "licensed"}}