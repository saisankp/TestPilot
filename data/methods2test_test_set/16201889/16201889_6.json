{"test_class": {"identifier": "NameFormatterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "ParsedName pn;", "modifier": "", "type": "ParsedName", "declarator": "pn", "var_name": "pn"}], "file": "name-parser-api/src/test/java/org/gbif/nameparser/util/NameFormatterTest.java"}, "test_case": {"identifier": "testBuildName", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testBuildName() throws Exception {\n    pn.setUninomial(\"Pseudomonas\");\n    assertName(\"Pseudomonas\");\n    assertHtml(\"<i>Pseudomonas</i>\");\n    \n    pn.setUninomial(null);\n    pn.setGenus(\"Pseudomonas\");\n    pn.setSpecificEpithet(\"syringae\");\n    assertName(\"Pseudomonas syringae\");\n    assertHtml(\"<i>Pseudomonas</i> <i>syringae</i>\");\n\n    pn.setCombinationAuthorship(Authorship.authors(\"Van Hall\"));\n    assertName(\"Pseudomonas syringae\", \"Pseudomonas syringae Van Hall\");\n    assertHtml(\"<i>Pseudomonas</i> <i>syringae</i> Van Hall\");\n    \n    pn.getCombinationAuthorship().setYear(\"1904\");\n    assertName(\"Pseudomonas syringae\", \"Pseudomonas syringae Van Hall, 1904\");\n    assertHtml(\"<i>Pseudomonas</i> <i>syringae</i> Van Hall, 1904\");\n\n    pn.setBasionymAuthorship(Authorship.authors(\"Carl.\"));\n    assertName(\"Pseudomonas syringae\", \"Pseudomonas syringae (Carl.) Van Hall, 1904\");\n    assertHtml(\"<i>Pseudomonas</i> <i>syringae</i> (Carl.) Van Hall, 1904\");\n    \n    pn.setRank(Rank.PATHOVAR);\n    pn.setInfraspecificEpithet(\"aceris\");\n    pn.getBasionymAuthorship().getAuthors().clear();\n    assertName(\"Pseudomonas syringae aceris\", \"Pseudomonas syringae pv. aceris Van Hall, 1904\");\n    assertHtml(\"<i>Pseudomonas</i> <i>syringae</i> pv. <i>aceris</i> Van Hall, 1904\");\n    \n    pn.setStrain(\"CFBP 2339\");\n    assertName(\"Pseudomonas syringae aceris\", \"Pseudomonas syringae pv. aceris Van Hall, 1904 CFBP 2339\");\n    assertHtml(\"<i>Pseudomonas</i> <i>syringae</i> pv. <i>aceris</i> Van Hall, 1904 CFBP 2339\");\n    \n    pn.getCombinationAuthorship().setYear(null);\n    pn.getCombinationAuthorship().getAuthors().clear();\n    assertName(\"Pseudomonas syringae aceris\", \"Pseudomonas syringae pv. aceris CFBP 2339\");\n    \n    pn.setTaxonomicNote(\"tax note\");\n    assertHtml(\"<i>Pseudomonas</i> <i>syringae</i> pv. <i>aceris</i> CFBP 2339 tax note\");\n    \n    pn = new ParsedName();\n    pn.setGenus(\"Abax\");\n    pn.setSpecificEpithet(\"carinatus\");\n    pn.setInfraspecificEpithet(\"carinatus\");\n    pn.setBasionymAuthorship(Authorship.yearAuthors(\"1812\", \"Duftschmid\"));\n    pn.setRank(Rank.UNRANKED);\n    assertName(\"Abax carinatus carinatus\");\n    \n    pn.setRank(null);\n    assertName(\"Abax carinatus carinatus\");\n    \n    pn.setInfraspecificEpithet(\"urinatus\");\n    assertName(\"Abax carinatus urinatus\", \"Abax carinatus urinatus (Duftschmid, 1812)\");\n    \n    pn.setRank(null);\n    assertName(\"Abax carinatus urinatus\", \"Abax carinatus urinatus (Duftschmid, 1812)\");\n    \n    pn.setRank(Rank.SUBSPECIES);\n    assertName(\"Abax carinatus urinatus\", \"Abax carinatus urinatus (Duftschmid, 1812)\");\n    \n    pn.setCode(NomCode.BOTANICAL);\n    assertName(\"Abax carinatus urinatus\", \"Abax carinatus subsp. urinatus (Duftschmid, 1812)\");\n    \n    \n    pn = new ParsedName();\n    pn.setGenus(\"Polypodium\");\n    pn.setSpecificEpithet(\"vulgare\");\n    pn.setInfraspecificEpithet(\"mantoniae\");\n    pn.setBasionymAuthorship(Authorship.authors(\"Rothm.\"));\n    pn.setCombinationAuthorship(Authorship.authors(\"Schidlay\"));\n    pn.setRank(Rank.SUBSPECIES);\n    pn.setNotho(NamePart.INFRASPECIFIC);\n    assertName(\n        \"Polypodium vulgare mantoniae\",\n        \"Polypodium vulgare nothosubsp. mantoniae (Rothm.) Schidlay\",\n        \"Polypodium vulgare nothosubsp. mantoniae (Rothm.) Schidlay\");\n  }", "signature": "void testBuildName()", "full_signature": "@Test public void testBuildName()", "class_method_signature": "NameFormatterTest.testBuildName()", "testcase": true, "constructor": false, "invocations": ["setUninomial", "assertName", "assertHtml", "setUninomial", "setGenus", "setSpecificEpithet", "assertName", "assertHtml", "setCombinationAuthorship", "authors", "assertName", "assertHtml", "setYear", "getCombinationAuthorship", "assertName", "assertHtml", "setBasionymAuthorship", "authors", "assertName", "assertHtml", "setRank", "setInfraspecificEpithet", "clear", "getAuthors", "getBasionymAuthorship", "assertName", "assertHtml", "setStrain", "assertName", "assertHtml", "setYear", "getCombinationAuthorship", "clear", "getAuthors", "getCombinationAuthorship", "assertName", "setTaxonomicNote", "assertHtml", "setGenus", "setSpecificEpithet", "setInfraspecificEpithet", "setBasionymAuthorship", "yearAuthors", "setRank", "assertName", "setRank", "assertName", "setInfraspecificEpithet", "assertName", "setRank", "assertName", "setRank", "assertName", "setCode", "assertName", "setGenus", "setSpecificEpithet", "setInfraspecificEpithet", "setBasionymAuthorship", "authors", "setCombinationAuthorship", "authors", "setRank", "setNotho", "assertName"]}, "focal_class": {"identifier": "NameFormatter", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final char HYBRID_MARKER = '\u00d7';", "modifier": "public static final", "type": "char", "declarator": "HYBRID_MARKER = '\u00d7';", "var_name": "HYBRID_MARKER"}, {"original_string": "private static final String NOTHO_PREFIX = \"notho\";", "modifier": "private static final", "type": "String", "declarator": "NOTHO_PREFIX = \"notho\"", "var_name": "NOTHO_PREFIX"}, {"original_string": "private static final Joiner AUTHORSHIP_JOINER = Joiner.on(\", \").skipNulls();", "modifier": "private static final", "type": "Joiner", "declarator": "AUTHORSHIP_JOINER = Joiner.on(\", \").skipNulls()", "var_name": "AUTHORSHIP_JOINER"}, {"original_string": "private static final String ITALICS_OPEN = \"<i>\";", "modifier": "private static final", "type": "String", "declarator": "ITALICS_OPEN = \"<i>\"", "var_name": "ITALICS_OPEN"}, {"original_string": "private static final String ITALICS_CLOSE = \"</i>\";", "modifier": "private static final", "type": "String", "declarator": "ITALICS_CLOSE = \"</i>\"", "var_name": "ITALICS_CLOSE"}, {"original_string": "private static final Pattern AL = Pattern.compile(\"^al\\\\.?$\");", "modifier": "private static final", "type": "Pattern", "declarator": "AL = Pattern.compile(\"^al\\\\.?$\")", "var_name": "AL"}], "methods": [{"identifier": "NameFormatter", "parameters": "()", "modifiers": "private", "return": "", "signature": " NameFormatter()", "full_signature": "private  NameFormatter()", "class_method_signature": "NameFormatter.NameFormatter()", "testcase": false, "constructor": true}, {"identifier": "canonical", "parameters": "(ParsedName n)", "modifiers": "public static", "return": "String", "signature": "String canonical(ParsedName n)", "full_signature": "public static String canonical(ParsedName n)", "class_method_signature": "NameFormatter.canonical(ParsedName n)", "testcase": false, "constructor": false}, {"identifier": "canonicalWithoutAuthorship", "parameters": "(ParsedName n)", "modifiers": "public static", "return": "String", "signature": "String canonicalWithoutAuthorship(ParsedName n)", "full_signature": "public static String canonicalWithoutAuthorship(ParsedName n)", "class_method_signature": "NameFormatter.canonicalWithoutAuthorship(ParsedName n)", "testcase": false, "constructor": false}, {"identifier": "canonicalMinimal", "parameters": "(ParsedName n)", "modifiers": "public static", "return": "String", "signature": "String canonicalMinimal(ParsedName n)", "full_signature": "public static String canonicalMinimal(ParsedName n)", "class_method_signature": "NameFormatter.canonicalMinimal(ParsedName n)", "testcase": false, "constructor": false}, {"identifier": "canonicalComplete", "parameters": "(ParsedName n)", "modifiers": "public static", "return": "String", "signature": "String canonicalComplete(ParsedName n)", "full_signature": "public static String canonicalComplete(ParsedName n)", "class_method_signature": "NameFormatter.canonicalComplete(ParsedName n)", "testcase": false, "constructor": false}, {"identifier": "canonicalCompleteHtml", "parameters": "(ParsedName n)", "modifiers": "public static", "return": "String", "signature": "String canonicalCompleteHtml(ParsedName n)", "full_signature": "public static String canonicalCompleteHtml(ParsedName n)", "class_method_signature": "NameFormatter.canonicalCompleteHtml(ParsedName n)", "testcase": false, "constructor": false}, {"identifier": "authorshipComplete", "parameters": "(ParsedAuthorship n)", "modifiers": "public static", "return": "String", "signature": "String authorshipComplete(ParsedAuthorship n)", "full_signature": "public static String authorshipComplete(ParsedAuthorship n)", "class_method_signature": "NameFormatter.authorshipComplete(ParsedAuthorship n)", "testcase": false, "constructor": false}, {"identifier": "authorString", "parameters": "(Authorship authors, boolean inclYear)", "modifiers": "public static", "return": "String", "signature": "String authorString(Authorship authors, boolean inclYear)", "full_signature": "public static String authorString(Authorship authors, boolean inclYear)", "class_method_signature": "NameFormatter.authorString(Authorship authors, boolean inclYear)", "testcase": false, "constructor": false}, {"identifier": "openItalics", "parameters": "(StringBuilder sb)", "modifiers": "private static", "return": "void", "signature": "void openItalics(StringBuilder sb)", "full_signature": "private static void openItalics(StringBuilder sb)", "class_method_signature": "NameFormatter.openItalics(StringBuilder sb)", "testcase": false, "constructor": false}, {"identifier": "closeItalics", "parameters": "(StringBuilder sb)", "modifiers": "private static", "return": "void", "signature": "void closeItalics(StringBuilder sb)", "full_signature": "private static void closeItalics(StringBuilder sb)", "class_method_signature": "NameFormatter.closeItalics(StringBuilder sb)", "testcase": false, "constructor": false}, {"identifier": "appendInItalics", "parameters": "(StringBuilder sb, String x, boolean html)", "modifiers": "private static", "return": "void", "signature": "void appendInItalics(StringBuilder sb, String x, boolean html)", "full_signature": "private static void appendInItalics(StringBuilder sb, String x, boolean html)", "class_method_signature": "NameFormatter.appendInItalics(StringBuilder sb, String x, boolean html)", "testcase": false, "constructor": false}, {"identifier": "buildName", "parameters": "(ParsedName n,\n                                 boolean hybridMarker,\n                                 boolean rankMarker,\n                                 boolean authorship,\n                                 boolean genusForinfrageneric,\n                                 boolean infrageneric,\n                                 boolean decomposition,\n                                 boolean asciiOnly,\n                                 boolean showQualifier,\n                                 boolean showIndet,\n                                 boolean nomNote,\n                                 boolean showSensu,\n                                 boolean showCultivar,\n                                 boolean showStrain,\n                                 boolean html\n  )", "modifiers": "public static", "return": "String", "signature": "String buildName(ParsedName n,\n                                 boolean hybridMarker,\n                                 boolean rankMarker,\n                                 boolean authorship,\n                                 boolean genusForinfrageneric,\n                                 boolean infrageneric,\n                                 boolean decomposition,\n                                 boolean asciiOnly,\n                                 boolean showQualifier,\n                                 boolean showIndet,\n                                 boolean nomNote,\n                                 boolean showSensu,\n                                 boolean showCultivar,\n                                 boolean showStrain,\n                                 boolean html\n  )", "full_signature": "public static String buildName(ParsedName n,\n                                 boolean hybridMarker,\n                                 boolean rankMarker,\n                                 boolean authorship,\n                                 boolean genusForinfrageneric,\n                                 boolean infrageneric,\n                                 boolean decomposition,\n                                 boolean asciiOnly,\n                                 boolean showQualifier,\n                                 boolean showIndet,\n                                 boolean nomNote,\n                                 boolean showSensu,\n                                 boolean showCultivar,\n                                 boolean showStrain,\n                                 boolean html\n  )", "class_method_signature": "NameFormatter.buildName(ParsedName n,\n                                 boolean hybridMarker,\n                                 boolean rankMarker,\n                                 boolean authorship,\n                                 boolean genusForinfrageneric,\n                                 boolean infrageneric,\n                                 boolean decomposition,\n                                 boolean asciiOnly,\n                                 boolean showQualifier,\n                                 boolean showIndet,\n                                 boolean nomNote,\n                                 boolean showSensu,\n                                 boolean showCultivar,\n                                 boolean showStrain,\n                                 boolean html\n  )", "testcase": false, "constructor": false}, {"identifier": "appendInfraspecific", "parameters": "(StringBuilder sb, ParsedName n, boolean hybridMarker, boolean showQualifier, boolean rankMarker, boolean forceRankMarker, boolean html)", "modifiers": "private static", "return": "StringBuilder", "signature": "StringBuilder appendInfraspecific(StringBuilder sb, ParsedName n, boolean hybridMarker, boolean showQualifier, boolean rankMarker, boolean forceRankMarker, boolean html)", "full_signature": "private static StringBuilder appendInfraspecific(StringBuilder sb, ParsedName n, boolean hybridMarker, boolean showQualifier, boolean rankMarker, boolean forceRankMarker, boolean html)", "class_method_signature": "NameFormatter.appendInfraspecific(StringBuilder sb, ParsedName n, boolean hybridMarker, boolean showQualifier, boolean rankMarker, boolean forceRankMarker, boolean html)", "testcase": false, "constructor": false}, {"identifier": "appendIfNotEmpty", "parameters": "(StringBuilder sb, String toAppend)", "modifiers": "private static", "return": "StringBuilder", "signature": "StringBuilder appendIfNotEmpty(StringBuilder sb, String toAppend)", "full_signature": "private static StringBuilder appendIfNotEmpty(StringBuilder sb, String toAppend)", "class_method_signature": "NameFormatter.appendIfNotEmpty(StringBuilder sb, String toAppend)", "testcase": false, "constructor": false}, {"identifier": "isNotZoo", "parameters": "(NomCode code)", "modifiers": "private static", "return": "boolean", "signature": "boolean isNotZoo(NomCode code)", "full_signature": "private static boolean isNotZoo(NomCode code)", "class_method_signature": "NameFormatter.isNotZoo(NomCode code)", "testcase": false, "constructor": false}, {"identifier": "isUnknown", "parameters": "(Rank r)", "modifiers": "private static", "return": "boolean", "signature": "boolean isUnknown(Rank r)", "full_signature": "private static boolean isUnknown(Rank r)", "class_method_signature": "NameFormatter.isUnknown(Rank r)", "testcase": false, "constructor": false}, {"identifier": "isInfragenericMarker", "parameters": "(Rank r)", "modifiers": "private static", "return": "boolean", "signature": "boolean isInfragenericMarker(Rank r)", "full_signature": "private static boolean isInfragenericMarker(Rank r)", "class_method_signature": "NameFormatter.isInfragenericMarker(Rank r)", "testcase": false, "constructor": false}, {"identifier": "isInfraspecificMarker", "parameters": "(Rank r)", "modifiers": "private static", "return": "boolean", "signature": "boolean isInfraspecificMarker(Rank r)", "full_signature": "private static boolean isInfraspecificMarker(Rank r)", "class_method_signature": "NameFormatter.isInfraspecificMarker(Rank r)", "testcase": false, "constructor": false}, {"identifier": "appendRankMarker", "parameters": "(StringBuilder sb, Rank rank, boolean nothoPrefix)", "modifiers": "private static", "return": "boolean", "signature": "boolean appendRankMarker(StringBuilder sb, Rank rank, boolean nothoPrefix)", "full_signature": "private static boolean appendRankMarker(StringBuilder sb, Rank rank, boolean nothoPrefix)", "class_method_signature": "NameFormatter.appendRankMarker(StringBuilder sb, Rank rank, boolean nothoPrefix)", "testcase": false, "constructor": false}, {"identifier": "appendRankMarker", "parameters": "(StringBuilder sb, Rank rank, Predicate<Rank> ifRank, boolean nothoPrefix)", "modifiers": "private static", "return": "boolean", "signature": "boolean appendRankMarker(StringBuilder sb, Rank rank, Predicate<Rank> ifRank, boolean nothoPrefix)", "full_signature": "private static boolean appendRankMarker(StringBuilder sb, Rank rank, Predicate<Rank> ifRank, boolean nothoPrefix)", "class_method_signature": "NameFormatter.appendRankMarker(StringBuilder sb, Rank rank, Predicate<Rank> ifRank, boolean nothoPrefix)", "testcase": false, "constructor": false}, {"identifier": "appendGenus", "parameters": "(StringBuilder sb, ParsedName n, boolean hybridMarker, boolean showQualifier, boolean html)", "modifiers": "private static", "return": "StringBuilder", "signature": "StringBuilder appendGenus(StringBuilder sb, ParsedName n, boolean hybridMarker, boolean showQualifier, boolean html)", "full_signature": "private static StringBuilder appendGenus(StringBuilder sb, ParsedName n, boolean hybridMarker, boolean showQualifier, boolean html)", "class_method_signature": "NameFormatter.appendGenus(StringBuilder sb, ParsedName n, boolean hybridMarker, boolean showQualifier, boolean html)", "testcase": false, "constructor": false}, {"identifier": "joinAuthors", "parameters": "(List<String> authors, boolean abbrevWithEtAl)", "modifiers": "private static", "return": "String", "signature": "String joinAuthors(List<String> authors, boolean abbrevWithEtAl)", "full_signature": "private static String joinAuthors(List<String> authors, boolean abbrevWithEtAl)", "class_method_signature": "NameFormatter.joinAuthors(List<String> authors, boolean abbrevWithEtAl)", "testcase": false, "constructor": false}, {"identifier": "appendAuthorship", "parameters": "(StringBuilder sb, Authorship auth, boolean includeYear)", "modifiers": "public static", "return": "void", "signature": "void appendAuthorship(StringBuilder sb, Authorship auth, boolean includeYear)", "full_signature": "public static void appendAuthorship(StringBuilder sb, Authorship auth, boolean includeYear)", "class_method_signature": "NameFormatter.appendAuthorship(StringBuilder sb, Authorship auth, boolean includeYear)", "testcase": false, "constructor": false}, {"identifier": "appendAuthorship", "parameters": "(ParsedAuthorship a, StringBuilder sb)", "modifiers": "private static", "return": "void", "signature": "void appendAuthorship(ParsedAuthorship a, StringBuilder sb)", "full_signature": "private static void appendAuthorship(ParsedAuthorship a, StringBuilder sb)", "class_method_signature": "NameFormatter.appendAuthorship(ParsedAuthorship a, StringBuilder sb)", "testcase": false, "constructor": false}], "file": "name-parser-api/src/main/java/org/gbif/nameparser/util/NameFormatter.java"}, "focal_method": {"identifier": "buildName", "parameters": "(ParsedName n,\n                                 boolean hybridMarker,\n                                 boolean rankMarker,\n                                 boolean authorship,\n                                 boolean genusForinfrageneric,\n                                 boolean infrageneric,\n                                 boolean decomposition,\n                                 boolean asciiOnly,\n                                 boolean showQualifier,\n                                 boolean showIndet,\n                                 boolean nomNote,\n                                 boolean showSensu,\n                                 boolean showCultivar,\n                                 boolean showStrain,\n                                 boolean html\n  )", "modifiers": "public static", "return": "String", "body": "public static String buildName(ParsedName n,\n                                 boolean hybridMarker,\n                                 boolean rankMarker,\n                                 boolean authorship,\n                                 boolean genusForinfrageneric,\n                                 boolean infrageneric,\n                                 boolean decomposition,\n                                 boolean asciiOnly,\n                                 boolean showQualifier,\n                                 boolean showIndet,\n                                 boolean nomNote,\n                                 boolean showSensu,\n                                 boolean showCultivar,\n                                 boolean showStrain,\n                                 boolean html\n  ) {\n    StringBuilder sb = new StringBuilder();\n    \n    boolean candidateItalics = false;\n    if (n.isCandidatus()) {\n      sb.append(\"\\\"\");\n      if (html) {\n        openItalics(sb);\n        candidateItalics = true;\n        // we turn off html here cause the entire name should be in italics!\n        html = false;\n      }\n      sb.append(\"Candidatus \");\n    }\n    \n    if (n.getUninomial() != null) {\n      // higher rank names being just a uninomial!\n      if (hybridMarker && NamePart.GENERIC == n.getNotho()) {\n        sb.append(HYBRID_MARKER)\n            .append(\" \");\n      }\n      appendInItalics(sb, n.getUninomial(), html);\n      \n    } else {\n      // bi- or trinomials or infrageneric names\n      if (n.getInfragenericEpithet() != null) {\n        if ((isUnknown(n.getRank()) && n.getSpecificEpithet() == null) || (n.getRank() != null && n.getRank().isInfragenericStrictly())) {\n          boolean showInfraGen = true;\n          // the infrageneric is the terminal rank. Always show it and wrap it with its genus if requested\n          if (n.getGenus() != null && genusForinfrageneric) {\n            appendGenus(sb, n, hybridMarker, showQualifier, html);\n            sb.append(\" \");\n            // we show zoological infragenerics in brackets,\n            // but use rank markers for botanical names (unless its no defined rank)\n            if (NomCode.ZOOLOGICAL == n.getCode()) {\n              sb.append(\"(\");\n              if (hybridMarker && NamePart.INFRAGENERIC == n.getNotho()) {\n                sb.append(HYBRID_MARKER)\n                    .append(' ');\n              }\n              appendInItalics(sb, n.getInfragenericEpithet(), html);\n              sb.append(\")\");\n              showInfraGen = false;\n            }\n          }\n          if (showInfraGen) {\n            if (rankMarker) {\n              // If we know the rank we use explicit rank markers\n              // this is how botanical infrageneric names are formed, see http://www.iapt-taxon.org/nomen/main.php?page=art21\n              if (appendRankMarker(sb, n.getRank(), hybridMarker && NamePart.INFRAGENERIC == n.getNotho())) {\n                sb.append(' ');\n              }\n            }\n            appendInItalics(sb, n.getInfragenericEpithet(), html);\n          }\n          \n        } else {\n          if (n.getGenus() != null) {\n            appendGenus(sb, n, hybridMarker, showQualifier, html);\n          }\n          if (infrageneric) {\n            // additional subgenus shown for binomial. Always shown in brackets\n            sb.append(\" (\");\n            appendInItalics(sb, n.getInfragenericEpithet(), html);\n            sb.append(\")\");\n          }\n        }\n        \n      } else if (n.getGenus() != null) {\n        appendGenus(sb, n, hybridMarker, showQualifier, html);\n      }\n      \n      if (n.getSpecificEpithet() == null) {\n        if (showIndet && n.getGenus() != null && n.getCultivarEpithet() == null) {\n          if (n.getRank() != null && n.getRank().isSpeciesOrBelow()) {\n            // no species epithet given, indetermined!\n            if (n.getRank().isInfraspecific()) {\n              // maybe we have an infraspecific epithet? force to show the rank marker\n              appendInfraspecific(sb, n, hybridMarker, showQualifier, rankMarker, true, html);\n            } else {\n              sb.append(\" \");\n              sb.append(n.getRank().getMarker());\n            }\n            authorship = false;\n          }\n        } else if (n.getInfraspecificEpithet() != null) {\n          appendInfraspecific(sb, n, hybridMarker, showQualifier, rankMarker, false, html);\n        }\n        \n      } else {\n        // species part\n        sb.append(' ');\n        if (showQualifier && n.hasEpithetQualifier(NamePart.SPECIFIC )) {\n          sb.append(n.getEpithetQualifier().get(NamePart.SPECIFIC))\n              .append(\" \");\n        }\n        if (hybridMarker && NamePart.SPECIFIC == n.getNotho()) {\n          sb.append(HYBRID_MARKER)\n              .append(\" \");\n        }\n        appendInItalics(sb, n.getSpecificEpithet(), html);\n        \n        if (n.getInfraspecificEpithet() == null) {\n          // Indetermined infraspecies? Only show indet cultivar marker if no cultivar epithet exists\n          if (showIndet\n              && n.getRank() != null\n              && n.getRank().isInfraspecific()\n              && (NomCode.CULTIVARS != n.getRank().isRestrictedToCode() || n.getCultivarEpithet() == null)\n          ) {\n            // no infraspecific epitheton given, but rank below species. Indetermined!\n            // use ssp. for subspecies in case of indetermined names\n            if (n.getRank() == Rank.SUBSPECIES) {\n              sb.append(\" ssp.\");\n            } else {\n              sb.append(' ');\n              sb.append(n.getRank().getMarker());\n            }\n            authorship = false;\n          }\n          \n        } else {\n          // infraspecific part\n          appendInfraspecific(sb, n, hybridMarker, showQualifier, rankMarker, false, html);\n          // non autonym authorship ?\n          if (n.isAutonym()) {\n            authorship = false;\n          }\n        }\n      }\n    }\n    \n    // closing quotes for Candidatus names\n    if (n.isCandidatus()) {\n      if (candidateItalics) {\n        closeItalics(sb);\n      }\n      sb.append(\"\\\"\");\n    }\n    \n    // uninomial, genus, infragen, species or infraspecies authorship\n    if (authorship && n.hasAuthorship()) {\n      sb.append(\" \");\n      appendAuthorship(n, sb);\n    }\n    \n    // add strain name\n    if (showStrain && n.getStrain() != null) {\n      sb.append(\" \")\n          .append(n.getStrain());\n    }\n    \n    // add cultivar name\n    if (showCultivar && n.getCultivarEpithet() != null) {\n      if (Rank.CULTIVAR_GROUP == n.getRank()) {\n        sb.append(\" \")\n            .append(n.getCultivarEpithet())\n            .append(\" Group\");\n        \n      } else if (Rank.GREX == n.getRank()) {\n        sb.append(\" \")\n            .append(n.getCultivarEpithet())\n            .append(\" gx\");\n        \n      } else {\n        sb.append(\" '\")\n            .append(n.getCultivarEpithet())\n            .append(\"'\");\n      }\n    }\n    \n    // add sensu/sec reference\n    if (showSensu && n.getTaxonomicNote() != null) {\n      appendIfNotEmpty(sb, \" \")\n          .append(n.getTaxonomicNote());\n    }\n    \n    // add nom status\n    if (nomNote && n.getNomenclaturalNote() != null) {\n      appendIfNotEmpty(sb, \", \")\n          .append(n.getNomenclaturalNote());\n    }\n    \n    // final char transformations\n    String name = sb.toString().trim();\n    if (decomposition) {\n      name = UnicodeUtils.decompose(name);\n    }\n    if (asciiOnly) {\n      name = UnicodeUtils.ascii(name);\n    }\n    return Strings.emptyToNull(name);\n  }", "signature": "String buildName(ParsedName n,\n                                 boolean hybridMarker,\n                                 boolean rankMarker,\n                                 boolean authorship,\n                                 boolean genusForinfrageneric,\n                                 boolean infrageneric,\n                                 boolean decomposition,\n                                 boolean asciiOnly,\n                                 boolean showQualifier,\n                                 boolean showIndet,\n                                 boolean nomNote,\n                                 boolean showSensu,\n                                 boolean showCultivar,\n                                 boolean showStrain,\n                                 boolean html\n  )", "full_signature": "public static String buildName(ParsedName n,\n                                 boolean hybridMarker,\n                                 boolean rankMarker,\n                                 boolean authorship,\n                                 boolean genusForinfrageneric,\n                                 boolean infrageneric,\n                                 boolean decomposition,\n                                 boolean asciiOnly,\n                                 boolean showQualifier,\n                                 boolean showIndet,\n                                 boolean nomNote,\n                                 boolean showSensu,\n                                 boolean showCultivar,\n                                 boolean showStrain,\n                                 boolean html\n  )", "class_method_signature": "NameFormatter.buildName(ParsedName n,\n                                 boolean hybridMarker,\n                                 boolean rankMarker,\n                                 boolean authorship,\n                                 boolean genusForinfrageneric,\n                                 boolean infrageneric,\n                                 boolean decomposition,\n                                 boolean asciiOnly,\n                                 boolean showQualifier,\n                                 boolean showIndet,\n                                 boolean nomNote,\n                                 boolean showSensu,\n                                 boolean showCultivar,\n                                 boolean showStrain,\n                                 boolean html\n  )", "testcase": false, "constructor": false, "invocations": ["isCandidatus", "append", "openItalics", "append", "getUninomial", "getNotho", "append", "append", "appendInItalics", "getUninomial", "getInfragenericEpithet", "isUnknown", "getRank", "getSpecificEpithet", "getRank", "isInfragenericStrictly", "getRank", "getGenus", "appendGenus", "append", "getCode", "append", "getNotho", "append", "append", "appendInItalics", "getInfragenericEpithet", "append", "appendRankMarker", "getRank", "getNotho", "append", "appendInItalics", "getInfragenericEpithet", "getGenus", "appendGenus", "append", "appendInItalics", "getInfragenericEpithet", "append", "getGenus", "appendGenus", "getSpecificEpithet", "getGenus", "getCultivarEpithet", "getRank", "isSpeciesOrBelow", "getRank", "isInfraspecific", "getRank", "appendInfraspecific", "append", "append", "getMarker", "getRank", "getInfraspecificEpithet", "appendInfraspecific", "append", "hasEpithetQualifier", "append", "append", "get", "getEpithetQualifier", "getNotho", "append", "append", "appendInItalics", "getSpecificEpithet", "getInfraspecificEpithet", "getRank", "isInfraspecific", "getRank", "isRestrictedToCode", "getRank", "getCultivarEpithet", "getRank", "append", "append", "append", "getMarker", "getRank", "appendInfraspecific", "isAutonym", "isCandidatus", "closeItalics", "append", "hasAuthorship", "append", "appendAuthorship", "getStrain", "append", "append", "getStrain", "getCultivarEpithet", "getRank", "append", "append", "append", "getCultivarEpithet", "getRank", "append", "append", "append", "getCultivarEpithet", "append", "append", "append", "getCultivarEpithet", "getTaxonomicNote", "append", "appendIfNotEmpty", "getTaxonomicNote", "getNomenclaturalNote", "append", "appendIfNotEmpty", "getNomenclaturalNote", "trim", "toString", "decompose", "ascii", "emptyToNull"]}, "repository": {"repo_id": 16201889, "url": "https://github.com/gbif/name-parser", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 11, "size": 1978, "license": "licensed"}}