{"test_class": {"identifier": "StreamUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "dubbo-common/src/test/java/org/apache/dubbo/common/io/StreamUtilsTest.java"}, "test_case": {"identifier": "testSkipForOriginMarkSupportInput", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSkipForOriginMarkSupportInput() throws IOException {\n        InputStream is = StreamUtilsTest.class.getResourceAsStream(\"/StreamUtilsTest.txt\");\n        InputStream newIs = StreamUtils.markSupportedInputStream(is, 1);\n\n        assertThat(newIs, is(is));\n        is.close();\n    }", "signature": "void testSkipForOriginMarkSupportInput()", "full_signature": "@Test public void testSkipForOriginMarkSupportInput()", "class_method_signature": "StreamUtilsTest.testSkipForOriginMarkSupportInput()", "testcase": true, "constructor": false, "invocations": ["getResourceAsStream", "markSupportedInputStream", "assertThat", "is", "close"]}, "focal_class": {"identifier": "StreamUtils", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "StreamUtils", "parameters": "()", "modifiers": "private", "return": "", "signature": " StreamUtils()", "full_signature": "private  StreamUtils()", "class_method_signature": "StreamUtils.StreamUtils()", "testcase": false, "constructor": true}, {"identifier": "limitedInputStream", "parameters": "(final InputStream is, final int limit)", "modifiers": "public static", "return": "InputStream", "signature": "InputStream limitedInputStream(final InputStream is, final int limit)", "full_signature": "public static InputStream limitedInputStream(final InputStream is, final int limit)", "class_method_signature": "StreamUtils.limitedInputStream(final InputStream is, final int limit)", "testcase": false, "constructor": false}, {"identifier": "markSupportedInputStream", "parameters": "(final InputStream is, final int markBufferSize)", "modifiers": "public static", "return": "InputStream", "signature": "InputStream markSupportedInputStream(final InputStream is, final int markBufferSize)", "full_signature": "public static InputStream markSupportedInputStream(final InputStream is, final int markBufferSize)", "class_method_signature": "StreamUtils.markSupportedInputStream(final InputStream is, final int markBufferSize)", "testcase": false, "constructor": false}, {"identifier": "markSupportedInputStream", "parameters": "(final InputStream is)", "modifiers": "public static", "return": "InputStream", "signature": "InputStream markSupportedInputStream(final InputStream is)", "full_signature": "public static InputStream markSupportedInputStream(final InputStream is)", "class_method_signature": "StreamUtils.markSupportedInputStream(final InputStream is)", "testcase": false, "constructor": false}, {"identifier": "skipUnusedStream", "parameters": "(InputStream is)", "modifiers": "public static", "return": "void", "signature": "void skipUnusedStream(InputStream is)", "full_signature": "public static void skipUnusedStream(InputStream is)", "class_method_signature": "StreamUtils.skipUnusedStream(InputStream is)", "testcase": false, "constructor": false}], "file": "dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java"}, "focal_method": {"identifier": "markSupportedInputStream", "parameters": "(final InputStream is, final int markBufferSize)", "modifiers": "public static", "return": "InputStream", "body": "public static InputStream markSupportedInputStream(final InputStream is, final int markBufferSize) {\n        if (is.markSupported()) {\n            return is;\n        }\n\n        return new InputStream() {\n            byte[] mMarkBuffer;\n\n            boolean mInMarked = false;\n            boolean mInReset = false;\n            boolean mDry = false;\n            private int mPosition = 0;\n            private int mCount = 0;\n\n            @Override\n            public int read() throws IOException {\n                if (!mInMarked) {\n                    return is.read();\n                } else {\n                    if (mPosition < mCount) {\n                        byte b = mMarkBuffer[mPosition++];\n                        return b & 0xFF;\n                    }\n\n                    if (!mInReset) {\n                        if (mDry) {\n                            return -1;\n                        }\n\n                        if (null == mMarkBuffer) {\n                            mMarkBuffer = new byte[markBufferSize];\n                        }\n                        if (mPosition >= markBufferSize) {\n                            throw new IOException(\"Mark buffer is full!\");\n                        }\n\n                        int read = is.read();\n                        if (-1 == read) {\n                            mDry = true;\n                            return -1;\n                        }\n\n                        mMarkBuffer[mPosition++] = (byte) read;\n                        mCount++;\n\n                        return read;\n                    } else {\n                        // mark buffer is used, exit mark status!\n                        mInMarked = false;\n                        mInReset = false;\n                        mPosition = 0;\n                        mCount = 0;\n\n                        return is.read();\n                    }\n                }\n            }\n\n            /**\n             * NOTE: the <code>readlimit</code> argument for this class\n             *  has no meaning.\n             */\n            @Override\n            public synchronized void mark(int readlimit) {\n                mInMarked = true;\n                mInReset = false;\n\n                // mark buffer is not empty\n                int count = mCount - mPosition;\n                if (count > 0) {\n                    System.arraycopy(mMarkBuffer, mPosition, mMarkBuffer, 0, count);\n                    mCount = count;\n                    mPosition = 0;\n                }\n            }\n\n            @Override\n            public synchronized void reset() throws IOException {\n                if (!mInMarked) {\n                    throw new IOException(\"should mark before reset!\");\n                }\n\n                mInReset = true;\n                mPosition = 0;\n            }\n\n            @Override\n            public boolean markSupported() {\n                return true;\n            }\n\n            @Override\n            public int available() throws IOException {\n                int available = is.available();\n\n                if (mInMarked && mInReset) {\n                    available += mCount - mPosition;\n                }\n\n                return available;\n            }\n\n            @Override\n            public void close() throws IOException {\n                is.close();\n            }\n        };\n    }", "signature": "InputStream markSupportedInputStream(final InputStream is, final int markBufferSize)", "full_signature": "public static InputStream markSupportedInputStream(final InputStream is, final int markBufferSize)", "class_method_signature": "StreamUtils.markSupportedInputStream(final InputStream is, final int markBufferSize)", "testcase": false, "constructor": false, "invocations": ["markSupported", "read", "read", "read", "arraycopy", "available", "close"]}, "repository": {"repo_id": 4710920, "url": "https://github.com/apache/dubbo", "stars": 30960, "created": "6/19/2012 7:56:02 AM +00:00", "updates": "2020-01-27T14:21:03+00:00", "fork": "False", "license": "licensed"}}