{"test_class": {"identifier": "SequencerPathExpressionTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private SequencerPathExpression expr;", "modifier": "private", "type": "SequencerPathExpression", "declarator": "expr", "var_name": "expr"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/sequencer/SequencerPathExpressionTest.java"}, "test_case": {"identifier": "shouldNotCompileExpressionWithSelectionExpressionAndDelimiterAndNoOutputExpression", "parameters": "()", "modifiers": "@Test( expected = InvalidSequencerPathExpression.class ) public", "return": "void", "body": "@Test( expected = InvalidSequencerPathExpression.class )\n    public void shouldNotCompileExpressionWithSelectionExpressionAndDelimiterAndNoOutputExpression() throws Exception {\n        SequencerPathExpression.compile(\"/a/b/c=>\");\n    }", "signature": "void shouldNotCompileExpressionWithSelectionExpressionAndDelimiterAndNoOutputExpression()", "full_signature": "@Test( expected = InvalidSequencerPathExpression.class ) public void shouldNotCompileExpressionWithSelectionExpressionAndDelimiterAndNoOutputExpression()", "class_method_signature": "SequencerPathExpressionTest.shouldNotCompileExpressionWithSelectionExpressionAndDelimiterAndNoOutputExpression()", "testcase": true, "constructor": false, "invocations": ["compile"]}, "focal_class": {"identifier": "SequencerPathExpression", "superclass": "", "interfaces": "implements Serializable", "fields": [{"original_string": "private static final long serialVersionUID = 229464314137494765L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 229464314137494765L", "var_name": "serialVersionUID"}, {"original_string": "private static final Pattern TWO_PART_PATTERN = Pattern.compile(\"((?:[^=]|=(?!>))+)(?:=>(.+))?\");", "modifier": "private static final", "type": "Pattern", "declarator": "TWO_PART_PATTERN = Pattern.compile(\"((?:[^=]|=(?!>))+)(?:=>(.+))?\")", "var_name": "TWO_PART_PATTERN"}, {"original_string": "protected static final String DEFAULT_OUTPUT_EXPRESSION = \".\";", "modifier": "protected static final", "type": "String", "declarator": "DEFAULT_OUTPUT_EXPRESSION = \".\"", "var_name": "DEFAULT_OUTPUT_EXPRESSION"}, {"original_string": "private static final String PARENT_PATTERN_STRING = \"[^/]+/\\\\.\\\\./\";", "modifier": "private static final", "type": "String", "declarator": "PARENT_PATTERN_STRING = \"[^/]+/\\\\.\\\\./\"", "var_name": "PARENT_PATTERN_STRING"}, {"original_string": "private static final Pattern PARENT_PATTERN = Pattern.compile(PARENT_PATTERN_STRING);", "modifier": "private static final", "type": "Pattern", "declarator": "PARENT_PATTERN = Pattern.compile(PARENT_PATTERN_STRING)", "var_name": "PARENT_PATTERN"}, {"original_string": "private static final String REPLACEMENT_VARIABLE_PATTERN_STRING = \"(?<!\\\\\\\\)\\\\$(\\\\d+)\";", "modifier": "private static final", "type": "String", "declarator": "REPLACEMENT_VARIABLE_PATTERN_STRING = \"(?<!\\\\\\\\)\\\\$(\\\\d+)\"", "var_name": "REPLACEMENT_VARIABLE_PATTERN_STRING"}, {"original_string": "private static final Pattern REPLACEMENT_VARIABLE_PATTERN = Pattern.compile(REPLACEMENT_VARIABLE_PATTERN_STRING);", "modifier": "private static final", "type": "Pattern", "declarator": "REPLACEMENT_VARIABLE_PATTERN = Pattern.compile(REPLACEMENT_VARIABLE_PATTERN_STRING)", "var_name": "REPLACEMENT_VARIABLE_PATTERN"}, {"original_string": "private final PathExpression selectExpression;", "modifier": "private final", "type": "PathExpression", "declarator": "selectExpression", "var_name": "selectExpression"}, {"original_string": "private final String outputExpression;", "modifier": "private final", "type": "String", "declarator": "outputExpression", "var_name": "outputExpression"}, {"original_string": "private final int hc;", "modifier": "private final", "type": "int", "declarator": "hc", "var_name": "hc"}], "methods": [{"identifier": "compile", "parameters": "( String expression )", "modifiers": "public static final", "return": "SequencerPathExpression", "signature": "SequencerPathExpression compile( String expression )", "full_signature": "public static final SequencerPathExpression compile( String expression )", "class_method_signature": "SequencerPathExpression.compile( String expression )", "testcase": false, "constructor": false}, {"identifier": "SequencerPathExpression", "parameters": "( PathExpression selectExpression,\n                                       String outputExpression )", "modifiers": "protected", "return": "", "signature": " SequencerPathExpression( PathExpression selectExpression,\n                                       String outputExpression )", "full_signature": "protected  SequencerPathExpression( PathExpression selectExpression,\n                                       String outputExpression )", "class_method_signature": "SequencerPathExpression.SequencerPathExpression( PathExpression selectExpression,\n                                       String outputExpression )", "testcase": false, "constructor": true}, {"identifier": "getSelectExpression", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getSelectExpression()", "full_signature": "public String getSelectExpression()", "class_method_signature": "SequencerPathExpression.getSelectExpression()", "testcase": false, "constructor": false}, {"identifier": "getOutputExpression", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getOutputExpression()", "full_signature": "public String getOutputExpression()", "class_method_signature": "SequencerPathExpression.getOutputExpression()", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "SequencerPathExpression.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "( Object obj )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals( Object obj )", "full_signature": "@Override public boolean equals( Object obj )", "class_method_signature": "SequencerPathExpression.equals( Object obj )", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "SequencerPathExpression.toString()", "testcase": false, "constructor": false}, {"identifier": "appliesToWorkspace", "parameters": "( String workspaceName )", "modifiers": "public final", "return": "boolean", "signature": "boolean appliesToWorkspace( String workspaceName )", "full_signature": "public final boolean appliesToWorkspace( String workspaceName )", "class_method_signature": "SequencerPathExpression.appliesToWorkspace( String workspaceName )", "testcase": false, "constructor": false}, {"identifier": "matcher", "parameters": "( String absolutePath )", "modifiers": "public", "return": "Matcher", "signature": "Matcher matcher( String absolutePath )", "full_signature": "public Matcher matcher( String absolutePath )", "class_method_signature": "SequencerPathExpression.matcher( String absolutePath )", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/sequencer/SequencerPathExpression.java"}, "focal_method": {"identifier": "compile", "parameters": "( String expression )", "modifiers": "public static final", "return": "SequencerPathExpression", "body": "public static final SequencerPathExpression compile( String expression ) throws InvalidSequencerPathExpression {\n        CheckArg.isNotNull(expression, \"sequencer path expression\");\n        expression = expression.trim();\n        if (expression.length() == 0) {\n            throw new InvalidSequencerPathExpression(RepositoryI18n.pathExpressionMayNotBeBlank.text());\n        }\n        java.util.regex.Matcher matcher = TWO_PART_PATTERN.matcher(expression);\n        if (!matcher.matches()) {\n            throw new InvalidSequencerPathExpression(RepositoryI18n.pathExpressionIsInvalid.text(expression));\n        }\n        String selectExpression = matcher.group(1);\n        String outputExpression = matcher.group(2);\n        return new SequencerPathExpression(PathExpression.compile(selectExpression), outputExpression);\n    }", "signature": "SequencerPathExpression compile( String expression )", "full_signature": "public static final SequencerPathExpression compile( String expression )", "class_method_signature": "SequencerPathExpression.compile( String expression )", "testcase": false, "constructor": false, "invocations": ["isNotNull", "trim", "length", "text", "matcher", "matches", "text", "group", "group", "compile"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}