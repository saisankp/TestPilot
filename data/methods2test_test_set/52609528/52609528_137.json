{"test_class": {"identifier": "KafkaMessageSenderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private KafkaProducer<String, String> producer;", "modifier": "private", "type": "KafkaProducer<String, String>", "declarator": "producer", "var_name": "producer"}, {"original_string": "private KafkaMessageSender kafkaMessageSender;", "modifier": "private", "type": "KafkaMessageSender", "declarator": "kafkaMessageSender", "var_name": "kafkaMessageSender"}], "file": "gateleen-kafka/src/test/java/org/swisspush/gateleen/kafka/KafkaMessageSenderTest.java"}, "test_case": {"identifier": "sendSingleMessage", "parameters": "(TestContext context)", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void sendSingleMessage(TestContext context) throws ValidationException {\n        Async async = context.async();\n        String topic = \"myTopic\";\n        final List<KafkaProducerRecord<String, String>> records =\n                buildRecords(topic, Buffer.buffer(buildSingleRecordPayload(\"someKey\").encode()));\n\n        doAnswer(invocation -> {\n            Handler<AsyncResult<RecordMetadata>> handler = (Handler<AsyncResult<RecordMetadata>>) invocation.getArguments()[1];\n            handler.handle(Future.succeededFuture(new RecordMetadata(1,1,1,1, topic)));\n            return null;\n        }).when(producer).write(any(KafkaProducerRecord.class), any());\n\n        kafkaMessageSender.sendMessages(producer, records).setHandler(event -> {\n            context.assertTrue(event.succeeded());\n            async.complete();\n        });\n\n        Mockito.verify(producer, times(1)).write(eq(records.get(0)), any());\n    }", "signature": "void sendSingleMessage(TestContext context)", "full_signature": "@Test public void sendSingleMessage(TestContext context)", "class_method_signature": "KafkaMessageSenderTest.sendSingleMessage(TestContext context)", "testcase": true, "constructor": false, "invocations": ["async", "buildRecords", "buffer", "encode", "buildSingleRecordPayload", "write", "when", "doAnswer", "getArguments", "handle", "succeededFuture", "any", "any", "setHandler", "sendMessages", "assertTrue", "succeeded", "complete", "write", "verify", "times", "eq", "get", "any"]}, "focal_class": {"identifier": "KafkaMessageSender", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(KafkaMessageSender.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(KafkaMessageSender.class)", "var_name": "log"}], "methods": [{"identifier": "sendMessages", "parameters": "(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "modifiers": "", "return": "Future<Void>", "signature": "Future<Void> sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "full_signature": " Future<Void> sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "class_method_signature": "KafkaMessageSender.sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "testcase": false, "constructor": false}, {"identifier": "sendMessage", "parameters": "(KafkaProducer<String, String> kafkaProducer, KafkaProducerRecord<String, String> message)", "modifiers": "private", "return": "Future<Void>", "signature": "Future<Void> sendMessage(KafkaProducer<String, String> kafkaProducer, KafkaProducerRecord<String, String> message)", "full_signature": "private Future<Void> sendMessage(KafkaProducer<String, String> kafkaProducer, KafkaProducerRecord<String, String> message)", "class_method_signature": "KafkaMessageSender.sendMessage(KafkaProducer<String, String> kafkaProducer, KafkaProducerRecord<String, String> message)", "testcase": false, "constructor": false}], "file": "gateleen-kafka/src/main/java/org/swisspush/gateleen/kafka/KafkaMessageSender.java"}, "focal_method": {"identifier": "sendMessages", "parameters": "(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "modifiers": "", "return": "Future<Void>", "body": "Future<Void> sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages){\n        Future<Void> future = Future.future();\n        Future<Void> f = Future.succeededFuture();\n\n        messages.stream().reduce(f,\n                (f1, message) -> f1.compose(ignore -> KafkaMessageSender.this.sendMessage(kafkaProducer, message)),\n                (voidFuture, voidFuture2) -> null\n        ).setHandler(res -> {\n            if(res.succeeded()) {\n                future.complete();\n            } else {\n                future.fail(res.cause());\n            }\n        });\n\n        return future;\n    }", "signature": "Future<Void> sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "full_signature": " Future<Void> sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "class_method_signature": "KafkaMessageSender.sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "testcase": false, "constructor": false, "invocations": ["future", "succeededFuture", "setHandler", "reduce", "stream", "compose", "sendMessage", "succeeded", "complete", "fail", "cause"]}, "repository": {"repo_id": 52609528, "url": "https://github.com/swisspush/gateleen", "language": "Java", "is_fork": false, "fork_count": 28, "stargazer_count": 63, "size": 2919, "license": "licensed"}}