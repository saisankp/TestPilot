{"test_class": {"identifier": "MBTilesReaderTest", "superclass": "", "interfaces": "", "fields": [], "file": "modules/unsupported/mbtiles/src/test/java/org/geotools/mbtiles/mosaic/MBTilesReaderTest.java"}, "test_case": {"identifier": "testZoomlevel4", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testZoomlevel4() throws IOException {\n        MBTilesReader reader = new MBTilesReader(getClass().getResource(\"world_lakes.mbtiles\"), null);\n        \n        GeneralParameterValue[] parameters = new GeneralParameterValue[1];\n        GridGeometry2D gg = new GridGeometry2D(new GridEnvelope2D(new Rectangle(500,500)), new ReferencedEnvelope(0,45.0,-85.0,0,MBTilesReader.WGS_84));\n        parameters[0] = new Parameter<GridGeometry2D>(AbstractGridFormat.READ_GRIDGEOMETRY2D, gg);\n        GridCoverage2D gc = reader.read(parameters);\n        RenderedImage img = gc.getRenderedImage();\n        assertEquals(0, gc.getEnvelope().getMinimum(0),0.01);\n        assertEquals(-20037508.34, gc.getEnvelope().getMinimum(1),0.01);\n        assertEquals(7514065.62, gc.getEnvelope().getMaximum(0),0.01);\n        assertEquals(0, gc.getEnvelope().getMaximum(1),0.01);\n        assertEquals(768, img.getWidth());\n        assertEquals(2048, img.getHeight());\n    }", "signature": "void testZoomlevel4()", "full_signature": "@Test public void testZoomlevel4()", "class_method_signature": "MBTilesReaderTest.testZoomlevel4()", "testcase": true, "constructor": false, "invocations": ["getResource", "getClass", "read", "getRenderedImage", "assertEquals", "getMinimum", "getEnvelope", "assertEquals", "getMinimum", "getEnvelope", "assertEquals", "getMaximum", "getEnvelope", "assertEquals", "getMaximum", "getEnvelope", "assertEquals", "getWidth", "assertEquals", "getHeight"]}, "focal_class": {"identifier": "MBTilesReader", "superclass": "extends AbstractGridCoverage2DReader", "interfaces": "", "fields": [{"original_string": "final static CoordinateReferenceSystem SPHERICAL_MERCATOR;", "modifier": "final static", "type": "CoordinateReferenceSystem", "declarator": "SPHERICAL_MERCATOR", "var_name": "SPHERICAL_MERCATOR"}, {"original_string": "final static CoordinateReferenceSystem WGS_84;", "modifier": "final static", "type": "CoordinateReferenceSystem", "declarator": "WGS_84", "var_name": "WGS_84"}, {"original_string": "protected final static ReferencedEnvelope WORLD_ENVELOPE = new ReferencedEnvelope(-20037508.34,20037508.34,-20037508.34,20037508.34, SPHERICAL_MERCATOR);", "modifier": "protected final static", "type": "ReferencedEnvelope", "declarator": "WORLD_ENVELOPE = new ReferencedEnvelope(-20037508.34,20037508.34,-20037508.34,20037508.34, SPHERICAL_MERCATOR)", "var_name": "WORLD_ENVELOPE"}, {"original_string": "protected final static int DEFAULT_TILE_SIZE = 256;", "modifier": "protected final static", "type": "int", "declarator": "DEFAULT_TILE_SIZE = 256", "var_name": "DEFAULT_TILE_SIZE"}, {"original_string": "protected final static int ZOOM_LEVEL_BASE = 2;", "modifier": "protected final static", "type": "int", "declarator": "ZOOM_LEVEL_BASE = 2", "var_name": "ZOOM_LEVEL_BASE"}, {"original_string": "protected GridCoverageFactory coverageFactory;", "modifier": "protected", "type": "GridCoverageFactory", "declarator": "coverageFactory", "var_name": "coverageFactory"}, {"original_string": "protected MBTilesMetadata metadata;", "modifier": "protected", "type": "MBTilesMetadata", "declarator": "metadata", "var_name": "metadata"}, {"original_string": "protected ReferencedEnvelope bounds;", "modifier": "protected", "type": "ReferencedEnvelope", "declarator": "bounds", "var_name": "bounds"}, {"original_string": "protected File sourceFile;", "modifier": "protected", "type": "File", "declarator": "sourceFile", "var_name": "sourceFile"}], "methods": [{"identifier": "MBTilesReader", "parameters": "(Object source, Hints hints)", "modifiers": "public", "return": "", "signature": " MBTilesReader(Object source, Hints hints)", "full_signature": "public  MBTilesReader(Object source, Hints hints)", "class_method_signature": "MBTilesReader.MBTilesReader(Object source, Hints hints)", "testcase": false, "constructor": true}, {"identifier": "getFormat", "parameters": "()", "modifiers": "@Override public", "return": "Format", "signature": "Format getFormat()", "full_signature": "@Override public Format getFormat()", "class_method_signature": "MBTilesReader.getFormat()", "testcase": false, "constructor": false}, {"identifier": "read", "parameters": "(GeneralParameterValue[] parameters)", "modifiers": "@Override public", "return": "GridCoverage2D", "signature": "GridCoverage2D read(GeneralParameterValue[] parameters)", "full_signature": "@Override public GridCoverage2D read(GeneralParameterValue[] parameters)", "class_method_signature": "MBTilesReader.read(GeneralParameterValue[] parameters)", "testcase": false, "constructor": false}, {"identifier": "readImage", "parameters": "(byte[] data, String format)", "modifiers": "protected static", "return": "BufferedImage", "signature": "BufferedImage readImage(byte[] data, String format)", "full_signature": "protected static BufferedImage readImage(byte[] data, String format)", "class_method_signature": "MBTilesReader.readImage(byte[] data, String format)", "testcase": false, "constructor": false}, {"identifier": "getStartImage", "parameters": "(BufferedImage copyFrom, int width, int height)", "modifiers": "protected", "return": "BufferedImage", "signature": "BufferedImage getStartImage(BufferedImage copyFrom, int width, int height)", "full_signature": "protected BufferedImage getStartImage(BufferedImage copyFrom, int width, int height)", "class_method_signature": "MBTilesReader.getStartImage(BufferedImage copyFrom, int width, int height)", "testcase": false, "constructor": false}, {"identifier": "getStartImage", "parameters": "(int imageType, int width, int height)", "modifiers": "protected", "return": "BufferedImage", "signature": "BufferedImage getStartImage(int imageType, int width, int height)", "full_signature": "protected BufferedImage getStartImage(int imageType, int width, int height)", "class_method_signature": "MBTilesReader.getStartImage(int imageType, int width, int height)", "testcase": false, "constructor": false}, {"identifier": "getStartImage", "parameters": "(int width, int height)", "modifiers": "protected", "return": "BufferedImage", "signature": "BufferedImage getStartImage(int width, int height)", "full_signature": "protected BufferedImage getStartImage(int width, int height)", "class_method_signature": "MBTilesReader.getStartImage(int width, int height)", "testcase": false, "constructor": false}], "file": "modules/unsupported/mbtiles/src/main/java/org/geotools/mbtiles/mosaic/MBTilesReader.java"}, "focal_method": {"identifier": "read", "parameters": "(GeneralParameterValue[] parameters)", "modifiers": "@Override public", "return": "GridCoverage2D", "body": "@Override\n    public GridCoverage2D read(GeneralParameterValue[] parameters) throws IllegalArgumentException, IOException {\n        MBTilesFile file = new MBTilesFile(sourceFile);\n        \n        ReferencedEnvelope requestedEnvelope = null;\n        Rectangle dim = null;\n        \n        if (parameters != null) {\n            for (int i = 0; i < parameters.length; i++) {\n                final ParameterValue param = (ParameterValue) parameters[i];\n                final ReferenceIdentifier name = param.getDescriptor().getName();\n                if (name.equals(AbstractGridFormat.READ_GRIDGEOMETRY2D.getName())) {\n                    final GridGeometry2D gg = (GridGeometry2D) param.getValue();\n                    try {                        \n                        requestedEnvelope = ReferencedEnvelope.create(gg.getEnvelope(), gg.getCoordinateReferenceSystem()).transform(SPHERICAL_MERCATOR, true);;\n                    } catch (Exception e) {\n                        requestedEnvelope = null;\n                    }\n                    \n                    dim = gg.getGridRange2D().getBounds();\n                    continue;\n                }\n            }\n        }\n        \n        if (requestedEnvelope == null) {\n            requestedEnvelope = bounds;\n        }    \n        \n        long zoomLevel = 0;\n        long leftTile, topTile, rightTile, bottomTile;\n        \n        if (requestedEnvelope != null && dim != null) {\n            //find the closest zoom based on horizontal resolution\n            double ratioWidth = requestedEnvelope.getSpan(0) / WORLD_ENVELOPE.getSpan(0); //proportion of total width that is being requested\n            double propWidth = dim.getWidth() / ratioWidth; //this is the width in pixels that the whole world would have in the requested resolution\n            zoomLevel = Math.round(Math.log(propWidth / DEFAULT_TILE_SIZE) / Math.log(ZOOM_LEVEL_BASE)); \n            //the closest zoom level to the resolution, based on the formula width = zoom_base^zoom_level * tile_size -> zoom_level = log(width / tile_size)/log(zoom_base)\n        }\n                                \n        try { //now take a zoom level that is available in the database\n            zoomLevel = file.closestZoom(zoomLevel);\n        } catch (SQLException e1) {\n            throw new IOException(e1);\n        }        \n        \n        long numberOfTiles = Math.round(Math.pow(ZOOM_LEVEL_BASE, zoomLevel)); //number of tile columns/rows for chosen zoom level\n        double resX = WORLD_ENVELOPE.getSpan(0) / numberOfTiles; //points per tile\n        double resY = WORLD_ENVELOPE.getSpan(1) / numberOfTiles; //points per tile        \n        double offsetX = WORLD_ENVELOPE.getMinimum(0);\n        double offsetY = WORLD_ENVELOPE.getMinimum(1);      \n        \n        try { //take available tiles from database\n            leftTile = file.minColumn(zoomLevel);\n            rightTile = file.maxColumn(zoomLevel);\n            bottomTile = file.minRow(zoomLevel);\n            topTile = file.maxRow(zoomLevel);            \n        } catch (SQLException e) {\n            throw new IOException(e);\n        }\n        \n        if (requestedEnvelope != null) { //crop tiles to requested envelope                   \n            leftTile = Math.max(leftTile, Math.round(Math.floor((requestedEnvelope.getMinimum(0) - offsetX) / resX )));\n            bottomTile = Math.max(bottomTile, Math.round(Math.floor((requestedEnvelope.getMinimum(1) - offsetY) / resY )));\n            rightTile = Math.max(leftTile, Math.min(rightTile, Math.round(Math.floor((requestedEnvelope.getMaximum(0) - offsetX) / resX ))));\n            topTile = Math.max(bottomTile, Math.min(topTile, Math.round(Math.floor((requestedEnvelope.getMaximum(1) - offsetY) / resY ))));            \n        } \n        \n        int width = (int) (rightTile - leftTile + 1) * DEFAULT_TILE_SIZE;\n        int height = (int) (topTile - bottomTile + 1) * DEFAULT_TILE_SIZE;\n        \n        //recalculate the envelope we are actually returning\n        ReferencedEnvelope resultEnvelope = new ReferencedEnvelope(offsetX + leftTile * resX, offsetX + (rightTile+1) * resX, offsetY + bottomTile * resY, offsetY + (topTile+1) * resY, SPHERICAL_MERCATOR);\n                        \n        BufferedImage image = null;\n        \n        MBTilesFile.TileIterator it;\n        try {\n        \tit = file.tiles(zoomLevel, leftTile, bottomTile, rightTile, topTile);\n        } catch (SQLException e) {\n            throw new IOException(e);\n        } \n\n        while (it.hasNext()) {                \n            MBTilesTile tile = it.next();\n            \n            BufferedImage tileImage = readImage(tile.getData(), metadata.getFormatStr()==null? \"png\" : metadata.getFormatStr());\n            \n            if (image == null) {\n                image = getStartImage(tileImage, width, height);\n            }\n\n            //coordinates\n            int posx = (int) (tile.getTileColumn() - leftTile) * DEFAULT_TILE_SIZE;\n            int posy = (int) (topTile - tile.getTileRow()) * DEFAULT_TILE_SIZE;\n\n            image.getRaster().setRect(posx, posy, tileImage.getData() );\n        }\n        \n        it.close();\n                \n        if (image == null){ // no tiles ??\n            image = getStartImage(width, height);\n        }\n        \n        return coverageFactory.create(metadata.getName()==null? \"nameless mbtiles\" : metadata.getName(), image, resultEnvelope);\n    }", "signature": "GridCoverage2D read(GeneralParameterValue[] parameters)", "full_signature": "@Override public GridCoverage2D read(GeneralParameterValue[] parameters)", "class_method_signature": "MBTilesReader.read(GeneralParameterValue[] parameters)", "testcase": false, "constructor": false, "invocations": ["getName", "getDescriptor", "equals", "getName", "getValue", "transform", "create", "getEnvelope", "getCoordinateReferenceSystem", "getBounds", "getGridRange2D", "getSpan", "getSpan", "getWidth", "round", "log", "log", "closestZoom", "round", "pow", "getSpan", "getSpan", "getMinimum", "getMinimum", "minColumn", "maxColumn", "minRow", "maxRow", "max", "round", "floor", "getMinimum", "max", "round", "floor", "getMinimum", "max", "min", "round", "floor", "getMaximum", "max", "min", "round", "floor", "getMaximum", "tiles", "hasNext", "next", "readImage", "getData", "getFormatStr", "getFormatStr", "getStartImage", "getTileColumn", "getTileRow", "setRect", "getRaster", "getData", "close", "getStartImage", "create", "getName", "getName"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}