{"test_class": {"identifier": "CandidateTest", "superclass": "extends AbstractRaftActorBehaviorTest<Candidate>", "interfaces": "", "fields": [{"original_string": "static final Logger LOG = LoggerFactory.getLogger(CandidateTest.class);", "modifier": "static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(CandidateTest.class)", "var_name": "LOG"}, {"original_string": "private final TestActorRef<MessageCollectorActor> candidateActor = actorFactory.createTestActor(\n            MessageCollectorActor.props().withDispatcher(Dispatchers.DefaultDispatcherId()),\n            actorFactory.generateActorId(\"candidate\"));", "modifier": "private final", "type": "TestActorRef<MessageCollectorActor>", "declarator": "candidateActor = actorFactory.createTestActor(\n            MessageCollectorActor.props().withDispatcher(Dispatchers.DefaultDispatcherId()),\n            actorFactory.generateActorId(\"candidate\"))", "var_name": "candidateActor"}, {"original_string": "private ActorRef[] peerActors;", "modifier": "private", "type": "ActorRef[]", "declarator": "peerActors", "var_name": "peerActors"}, {"original_string": "private RaftActorBehavior candidate;", "modifier": "private", "type": "RaftActorBehavior", "declarator": "candidate", "var_name": "candidate"}], "file": "opendaylight/md-sal/sal-akka-raft/src/test/java/org/opendaylight/controller/cluster/raft/behaviors/CandidateTest.java"}, "test_case": {"identifier": "testHandleAppendEntriesAddSameEntryToLog", "parameters": "()", "modifiers": "@Test @Override public", "return": "void", "body": "@Test\n    @Override\n    public void testHandleAppendEntriesAddSameEntryToLog() {\n        MockRaftActorContext context = createActorContext();\n\n        context.getTermInformation().update(2, \"test\");\n\n        // Prepare the receivers log\n        MockRaftActorContext.MockPayload payload = new MockRaftActorContext.MockPayload(\"zero\");\n        setLastLogEntry(context, 2, 0, payload);\n\n        List<ReplicatedLogEntry> entries = new ArrayList<>();\n        entries.add(new SimpleReplicatedLogEntry(0, 2, payload));\n\n        final AppendEntries appendEntries = new AppendEntries(2, \"leader-1\", -1, -1, entries, 2, -1, (short)0);\n\n        behavior = createBehavior(context);\n\n        // Resetting the Candidates term to make sure it will match\n        // the term sent by AppendEntries. If this was not done then\n        // the test will fail because the Candidate will assume that\n        // the message was sent to it from a lower term peer and will\n        // thus respond with a failure\n        context.getTermInformation().update(2, \"test\");\n\n        // Send an unknown message so that the state of the RaftActor remains unchanged\n        behavior.handleMessage(candidateActor, \"unknown\");\n\n        RaftActorBehavior raftBehavior = behavior.handleMessage(candidateActor, appendEntries);\n\n        assertEquals(\"Raft state\", RaftState.Follower, raftBehavior.state());\n\n        assertEquals(\"ReplicatedLog size\", 1, context.getReplicatedLog().size());\n\n        handleAppendEntriesAddSameEntryToLogReply(candidateActor);\n    }", "signature": "void testHandleAppendEntriesAddSameEntryToLog()", "full_signature": "@Test @Override public void testHandleAppendEntriesAddSameEntryToLog()", "class_method_signature": "CandidateTest.testHandleAppendEntriesAddSameEntryToLog()", "testcase": true, "constructor": false, "invocations": ["createActorContext", "update", "getTermInformation", "setLastLogEntry", "add", "createBehavior", "update", "getTermInformation", "handleMessage", "handleMessage", "assertEquals", "state", "assertEquals", "size", "getReplicatedLog", "handleAppendEntriesAddSameEntryToLogReply"]}, "focal_class": {"identifier": "Candidate", "superclass": "extends AbstractRaftActorBehavior", "interfaces": "", "fields": [{"original_string": "private int voteCount;", "modifier": "private", "type": "int", "declarator": "voteCount", "var_name": "voteCount"}, {"original_string": "private final int votesRequired;", "modifier": "private final", "type": "int", "declarator": "votesRequired", "var_name": "votesRequired"}, {"original_string": "private final Collection<String> votingPeers = new ArrayList<>();", "modifier": "private final", "type": "Collection<String>", "declarator": "votingPeers = new ArrayList<>()", "var_name": "votingPeers"}], "methods": [{"identifier": "Candidate", "parameters": "(final RaftActorContext context)", "modifiers": "public", "return": "", "signature": " Candidate(final RaftActorContext context)", "full_signature": "public  Candidate(final RaftActorContext context)", "class_method_signature": "Candidate.Candidate(final RaftActorContext context)", "testcase": false, "constructor": true}, {"identifier": "getLeaderId", "parameters": "()", "modifiers": "@Override public final", "return": "String", "signature": "String getLeaderId()", "full_signature": "@Override public final String getLeaderId()", "class_method_signature": "Candidate.getLeaderId()", "testcase": false, "constructor": false}, {"identifier": "getLeaderPayloadVersion", "parameters": "()", "modifiers": "@Override public final", "return": "short", "signature": "short getLeaderPayloadVersion()", "full_signature": "@Override public final short getLeaderPayloadVersion()", "class_method_signature": "Candidate.getLeaderPayloadVersion()", "testcase": false, "constructor": false}, {"identifier": "handleAppendEntries", "parameters": "(final ActorRef sender, final AppendEntries appendEntries)", "modifiers": "@Override protected", "return": "RaftActorBehavior", "signature": "RaftActorBehavior handleAppendEntries(final ActorRef sender, final AppendEntries appendEntries)", "full_signature": "@Override protected RaftActorBehavior handleAppendEntries(final ActorRef sender, final AppendEntries appendEntries)", "class_method_signature": "Candidate.handleAppendEntries(final ActorRef sender, final AppendEntries appendEntries)", "testcase": false, "constructor": false}, {"identifier": "handleAppendEntriesReply", "parameters": "(final ActorRef sender,\n            final AppendEntriesReply appendEntriesReply)", "modifiers": "@Override protected", "return": "RaftActorBehavior", "signature": "RaftActorBehavior handleAppendEntriesReply(final ActorRef sender,\n            final AppendEntriesReply appendEntriesReply)", "full_signature": "@Override protected RaftActorBehavior handleAppendEntriesReply(final ActorRef sender,\n            final AppendEntriesReply appendEntriesReply)", "class_method_signature": "Candidate.handleAppendEntriesReply(final ActorRef sender,\n            final AppendEntriesReply appendEntriesReply)", "testcase": false, "constructor": false}, {"identifier": "handleRequestVoteReply", "parameters": "(final ActorRef sender, final RequestVoteReply requestVoteReply)", "modifiers": "@Override protected", "return": "RaftActorBehavior", "signature": "RaftActorBehavior handleRequestVoteReply(final ActorRef sender, final RequestVoteReply requestVoteReply)", "full_signature": "@Override protected RaftActorBehavior handleRequestVoteReply(final ActorRef sender, final RequestVoteReply requestVoteReply)", "class_method_signature": "Candidate.handleRequestVoteReply(final ActorRef sender, final RequestVoteReply requestVoteReply)", "testcase": false, "constructor": false}, {"identifier": "electionDuration", "parameters": "()", "modifiers": "@Override protected", "return": "FiniteDuration", "signature": "FiniteDuration electionDuration()", "full_signature": "@Override protected FiniteDuration electionDuration()", "class_method_signature": "Candidate.electionDuration()", "testcase": false, "constructor": false}, {"identifier": "getApplyStateFor", "parameters": "(final ReplicatedLogEntry entry)", "modifiers": "@Override final", "return": "ApplyState", "signature": "ApplyState getApplyStateFor(final ReplicatedLogEntry entry)", "full_signature": "@Override final ApplyState getApplyStateFor(final ReplicatedLogEntry entry)", "class_method_signature": "Candidate.getApplyStateFor(final ReplicatedLogEntry entry)", "testcase": false, "constructor": false}, {"identifier": "handleMessage", "parameters": "(final ActorRef sender, final Object message)", "modifiers": "@Override public", "return": "RaftActorBehavior", "signature": "RaftActorBehavior handleMessage(final ActorRef sender, final Object message)", "full_signature": "@Override public RaftActorBehavior handleMessage(final ActorRef sender, final Object message)", "class_method_signature": "Candidate.handleMessage(final ActorRef sender, final Object message)", "testcase": false, "constructor": false}, {"identifier": "startNewTerm", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void startNewTerm()", "full_signature": "private void startNewTerm()", "class_method_signature": "Candidate.startNewTerm()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "Candidate.close()", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-akka-raft/src/main/java/org/opendaylight/controller/cluster/raft/behaviors/Candidate.java"}, "focal_method": {"identifier": "handleMessage", "parameters": "(final ActorRef sender, final Object message)", "modifiers": "@Override public", "return": "RaftActorBehavior", "body": "@Override\n    public RaftActorBehavior handleMessage(final ActorRef sender, final Object message) {\n        if (message instanceof ElectionTimeout) {\n            log.debug(\"{}: Received ElectionTimeout\", logName());\n\n            if (votesRequired == 0) {\n                // If there are no peers then we should be a Leader\n                // We wait for the election timeout to occur before declare\n                // ourselves the leader. This gives enough time for a leader\n                // who we do not know about (as a peer)\n                // to send a message to the candidate\n\n                return internalSwitchBehavior(RaftState.Leader);\n            }\n\n            startNewTerm();\n            scheduleElection(electionDuration());\n            return this;\n        }\n\n        if (message instanceof RaftRPC) {\n\n            RaftRPC rpc = (RaftRPC) message;\n\n            log.debug(\"{}: RaftRPC message received {}, my term is {}\", logName(), rpc,\n                        context.getTermInformation().getCurrentTerm());\n\n            // If RPC request or response contains term T > currentTerm:\n            // set currentTerm = T, convert to follower (\u00a75.1)\n            // This applies to all RPC messages and responses\n            if (rpc.getTerm() > context.getTermInformation().getCurrentTerm()) {\n                log.info(\"{}: Term {} in \\\"{}\\\" message is greater than Candidate's term {} - switching to Follower\",\n                        logName(), rpc.getTerm(), rpc, context.getTermInformation().getCurrentTerm());\n\n                context.getTermInformation().updateAndPersist(rpc.getTerm(), null);\n\n                // The raft paper does not say whether or not a Candidate can/should process a RequestVote in\n                // this case but doing so gains quicker convergence when the sender's log is more up-to-date.\n                if (message instanceof RequestVote) {\n                    super.handleMessage(sender, message);\n                }\n\n                return internalSwitchBehavior(RaftState.Follower);\n            }\n        }\n\n        return super.handleMessage(sender, message);\n    }", "signature": "RaftActorBehavior handleMessage(final ActorRef sender, final Object message)", "full_signature": "@Override public RaftActorBehavior handleMessage(final ActorRef sender, final Object message)", "class_method_signature": "Candidate.handleMessage(final ActorRef sender, final Object message)", "testcase": false, "constructor": false, "invocations": ["debug", "logName", "internalSwitchBehavior", "startNewTerm", "scheduleElection", "electionDuration", "debug", "logName", "getCurrentTerm", "getTermInformation", "getTerm", "getCurrentTerm", "getTermInformation", "info", "logName", "getTerm", "getCurrentTerm", "getTermInformation", "updateAndPersist", "getTermInformation", "getTerm", "handleMessage", "internalSwitchBehavior", "handleMessage"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}