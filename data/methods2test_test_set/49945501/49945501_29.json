{"test_class": {"identifier": "FiltersParserTest", "superclass": "", "interfaces": "", "fields": [], "file": "request-parameters/src/test/java/eu/neoteric/starter/request/FiltersParserTest.java"}, "test_case": {"identifier": "testMultipleNestedOperators", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMultipleNestedOperators() throws Exception {\n        Map<String, Object> rawFilters = readFiltersFromResources(\"MultipleNestedOperators.json\");\n\n        Map<RequestObject, Object> filters = FiltersParser.parseFilters(rawFilters);\n        Assertions.assertThat(filters)\n                .hasSize(3)\n                .containsOnlyKeys(RequestField.of(\"name\"), RequestField.of(\"lastName\"), RequestLogicalOperator.of(LogicalOperatorType.OR));\n\n        assertThat((Map) filters.get(RequestField.of(\"name\")))\n                .hasSize(2)\n                .containsEntry(RequestOperator.of(OperatorType.STARTS_WITH), \"John\")\n                .containsEntry(RequestOperator.of(OperatorType.IN), Lists.newArrayList(\"Johnny\", \"Abc\"));\n\n        assertThat((Map) filters.get(RequestField.of(\"lastName\")))\n                .hasSize(1)\n                .containsEntry(RequestLogicalOperator.of(LogicalOperatorType.OR), ImmutableMap.of(\n                        RequestOperator.of(OperatorType.STARTS_WITH), \"John\",\n                        RequestOperator.of(OperatorType.IN), Lists.newArrayList(\"Johnny\", \"Abc\")\n                ));\n\n        assertThat((Map) filters.get(RequestLogicalOperator.of(LogicalOperatorType.OR)))\n                .hasSize(2)\n                .containsEntry(RequestField.of(\"name\"), ImmutableMap.of(RequestOperator.of(OperatorType.EQUAL), \"John\"))\n                .containsEntry(RequestField.of(\"last\"), ImmutableMap.of(RequestOperator.of(OperatorType.EQUAL), \"Doe\"));\n    }", "signature": "void testMultipleNestedOperators()", "full_signature": "@Test public void testMultipleNestedOperators()", "class_method_signature": "FiltersParserTest.testMultipleNestedOperators()", "testcase": true, "constructor": false, "invocations": ["readFiltersFromResources", "parseFilters", "containsOnlyKeys", "hasSize", "assertThat", "of", "of", "of", "containsEntry", "containsEntry", "hasSize", "assertThat", "get", "of", "of", "of", "newArrayList", "containsEntry", "hasSize", "assertThat", "get", "of", "of", "of", "of", "of", "newArrayList", "containsEntry", "containsEntry", "hasSize", "assertThat", "get", "of", "of", "of", "of", "of", "of", "of"]}, "focal_class": {"identifier": "FiltersParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(FiltersParser.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(FiltersParser.class)", "var_name": "LOG"}], "methods": [{"identifier": "FiltersParser", "parameters": "()", "modifiers": "private", "return": "", "signature": " FiltersParser()", "full_signature": "private  FiltersParser()", "class_method_signature": "FiltersParser.FiltersParser()", "testcase": false, "constructor": true}, {"identifier": "parseFilters", "parameters": "(Map<String, Object> rawFilters)", "modifiers": "public static", "return": "Map<RequestObject, Object>", "signature": "Map<RequestObject, Object> parseFilters(Map<String, Object> rawFilters)", "full_signature": "public static Map<RequestObject, Object> parseFilters(Map<String, Object> rawFilters)", "class_method_signature": "FiltersParser.parseFilters(Map<String, Object> rawFilters)", "testcase": false, "constructor": false}, {"identifier": "processRootLogicalOperatorValue", "parameters": "(Map<String, Object> orEntry)", "modifiers": "private static", "return": "Map<RequestObject, Object>", "signature": "Map<RequestObject, Object> processRootLogicalOperatorValue(Map<String, Object> orEntry)", "full_signature": "private static Map<RequestObject, Object> processRootLogicalOperatorValue(Map<String, Object> orEntry)", "class_method_signature": "FiltersParser.processRootLogicalOperatorValue(Map<String, Object> orEntry)", "testcase": false, "constructor": false}, {"identifier": "processLogicalOperatorValue", "parameters": "(Map<String, Object> orEntry)", "modifiers": "private static", "return": "Map<RequestObject, Object>", "signature": "Map<RequestObject, Object> processLogicalOperatorValue(Map<String, Object> orEntry)", "full_signature": "private static Map<RequestObject, Object> processLogicalOperatorValue(Map<String, Object> orEntry)", "class_method_signature": "FiltersParser.processLogicalOperatorValue(Map<String, Object> orEntry)", "testcase": false, "constructor": false}, {"identifier": "processFieldValue", "parameters": "(Map<String, Object> fieldEntry)", "modifiers": "private static", "return": "Map<RequestObject, Object>", "signature": "Map<RequestObject, Object> processFieldValue(Map<String, Object> fieldEntry)", "full_signature": "private static Map<RequestObject, Object> processFieldValue(Map<String, Object> fieldEntry)", "class_method_signature": "FiltersParser.processFieldValue(Map<String, Object> fieldEntry)", "testcase": false, "constructor": false}, {"identifier": "isLogicalOperator", "parameters": "(String key)", "modifiers": "private static", "return": "boolean", "signature": "boolean isLogicalOperator(String key)", "full_signature": "private static boolean isLogicalOperator(String key)", "class_method_signature": "FiltersParser.isLogicalOperator(String key)", "testcase": false, "constructor": false}, {"identifier": "isOperator", "parameters": "(String key)", "modifiers": "private static", "return": "boolean", "signature": "boolean isOperator(String key)", "full_signature": "private static boolean isOperator(String key)", "class_method_signature": "FiltersParser.isOperator(String key)", "testcase": false, "constructor": false}, {"identifier": "isField", "parameters": "(String key)", "modifiers": "private static", "return": "boolean", "signature": "boolean isField(String key)", "full_signature": "private static boolean isField(String key)", "class_method_signature": "FiltersParser.isField(String key)", "testcase": false, "constructor": false}, {"identifier": "isNotOperatorNorLogicalOperator", "parameters": "(String key)", "modifiers": "private static", "return": "boolean", "signature": "boolean isNotOperatorNorLogicalOperator(String key)", "full_signature": "private static boolean isNotOperatorNorLogicalOperator(String key)", "class_method_signature": "FiltersParser.isNotOperatorNorLogicalOperator(String key)", "testcase": false, "constructor": false}, {"identifier": "isNotFieldNorLogicalOperator", "parameters": "(String key)", "modifiers": "private static", "return": "boolean", "signature": "boolean isNotFieldNorLogicalOperator(String key)", "full_signature": "private static boolean isNotFieldNorLogicalOperator(String key)", "class_method_signature": "FiltersParser.isNotFieldNorLogicalOperator(String key)", "testcase": false, "constructor": false}], "file": "request-parameters/src/main/java/eu/neoteric/starter/request/FiltersParser.java"}, "focal_method": {"identifier": "parseFilters", "parameters": "(Map<String, Object> rawFilters)", "modifiers": "public static", "return": "Map<RequestObject, Object>", "body": "public static Map<RequestObject, Object> parseFilters(Map<String, Object> rawFilters) {\n        Map<RequestObject, Object> requestParameters = new HashMap<>();\n\n        rawFilters.forEach((key, entry) -> {\n            if (isNotFieldNorLogicalOperator(key)) {\n                throw new IllegalStateException(key + \" isNotFieldNorLogicalOperator\");\n            }\n            if (isField(key)) {\n                if (!(entry instanceof Map)) {\n                    throw new IllegalStateException(\"Bad value (\" + entry + \") type for field: \" + entry.getClass().toString());\n                }\n                requestParameters.put(RequestField.of(key), processFieldValue((Map) entry));\n            } else {\n                if (!(entry instanceof Map)) {\n                    throw new IllegalStateException(\"Bad value (\" + entry + \") type for or operation: \" + entry.getClass().toString());\n                }\n                requestParameters.put(RequestLogicalOperator.of(key), processRootLogicalOperatorValue((Map) entry));\n            }\n        });\n        LOG.info(\"Parsed filters: {}\", requestParameters);\n        return requestParameters;\n    }", "signature": "Map<RequestObject, Object> parseFilters(Map<String, Object> rawFilters)", "full_signature": "public static Map<RequestObject, Object> parseFilters(Map<String, Object> rawFilters)", "class_method_signature": "FiltersParser.parseFilters(Map<String, Object> rawFilters)", "testcase": false, "constructor": false, "invocations": ["forEach", "isNotFieldNorLogicalOperator", "isField", "toString", "getClass", "put", "of", "processFieldValue", "toString", "getClass", "put", "of", "processRootLogicalOperatorValue", "info"]}, "repository": {"repo_id": 49945501, "url": "https://github.com/neoteric-eu/neo-starters", "language": "Java", "is_fork": false, "fork_count": 9, "stargazer_count": 8, "size": 969, "license": "licensed"}}