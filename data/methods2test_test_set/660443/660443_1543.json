{"test_class": {"identifier": "MomentOfInertiaDescriptorTest", "superclass": "extends MolecularDescriptorTest", "interfaces": "", "fields": [], "file": "descriptor/qsarmolecular/src/test/java/org/openscience/cdk/qsar/descriptors/molecular/MomentOfInertiaDescriptorTest.java"}, "test_case": {"identifier": "testMOIFromSmiles", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMOIFromSmiles() throws InvalidSmilesException {\n        SmilesParser sp = new SmilesParser(DefaultChemObjectBuilder.getInstance());\n        IAtomContainer mol = sp.parseSmiles(\"CCCC\");\n        DescriptorValue value = descriptor.calculate(mol);\n        Assert.assertNotNull(\"The Exception should be non-null since we don't have 3D coords\", value.getException());\n\n    }", "signature": "void testMOIFromSmiles()", "full_signature": "@Test public void testMOIFromSmiles()", "class_method_signature": "MomentOfInertiaDescriptorTest.testMOIFromSmiles()", "testcase": true, "constructor": false, "invocations": ["getInstance", "parseSmiles", "calculate", "assertNotNull", "getException"]}, "focal_class": {"identifier": "MomentOfInertiaDescriptor", "superclass": "extends AbstractMolecularDescriptor", "interfaces": "implements IMolecularDescriptor", "fields": [{"original_string": "private static ILoggingTool   logger = LoggingToolFactory.createLoggingTool(MomentOfInertiaDescriptor.class);", "modifier": "private static", "type": "ILoggingTool", "declarator": "logger = LoggingToolFactory.createLoggingTool(MomentOfInertiaDescriptor.class)", "var_name": "logger"}, {"original_string": "private static final String[] NAMES  = {\"MOMI-X\", \"MOMI-Y\", \"MOMI-Z\", \"MOMI-XY\", \"MOMI-XZ\", \"MOMI-YZ\", \"MOMI-R\"};", "modifier": "private static final", "type": "String[]", "declarator": "NAMES  = {\"MOMI-X\", \"MOMI-Y\", \"MOMI-Z\", \"MOMI-XY\", \"MOMI-XZ\", \"MOMI-YZ\", \"MOMI-R\"}", "var_name": "NAMES"}], "methods": [{"identifier": "getSpecification", "parameters": "()", "modifiers": "@Override public", "return": "DescriptorSpecification", "signature": "DescriptorSpecification getSpecification()", "full_signature": "@Override public DescriptorSpecification getSpecification()", "class_method_signature": "MomentOfInertiaDescriptor.getSpecification()", "testcase": false, "constructor": false}, {"identifier": "setParameters", "parameters": "(Object[] params)", "modifiers": "@Override public", "return": "void", "signature": "void setParameters(Object[] params)", "full_signature": "@Override public void setParameters(Object[] params)", "class_method_signature": "MomentOfInertiaDescriptor.setParameters(Object[] params)", "testcase": false, "constructor": false}, {"identifier": "getParameters", "parameters": "()", "modifiers": "@Override public", "return": "Object[]", "signature": "Object[] getParameters()", "full_signature": "@Override public Object[] getParameters()", "class_method_signature": "MomentOfInertiaDescriptor.getParameters()", "testcase": false, "constructor": false}, {"identifier": "getDescriptorNames", "parameters": "()", "modifiers": "@Override public", "return": "String[]", "signature": "String[] getDescriptorNames()", "full_signature": "@Override public String[] getDescriptorNames()", "class_method_signature": "MomentOfInertiaDescriptor.getDescriptorNames()", "testcase": false, "constructor": false}, {"identifier": "getParameterNames", "parameters": "()", "modifiers": "@Override public", "return": "String[]", "signature": "String[] getParameterNames()", "full_signature": "@Override public String[] getParameterNames()", "class_method_signature": "MomentOfInertiaDescriptor.getParameterNames()", "testcase": false, "constructor": false}, {"identifier": "getParameterType", "parameters": "(String name)", "modifiers": "@Override public", "return": "Object", "signature": "Object getParameterType(String name)", "full_signature": "@Override public Object getParameterType(String name)", "class_method_signature": "MomentOfInertiaDescriptor.getParameterType(String name)", "testcase": false, "constructor": false}, {"identifier": "getDummyDescriptorValue", "parameters": "(Exception e)", "modifiers": "private", "return": "DescriptorValue", "signature": "DescriptorValue getDummyDescriptorValue(Exception e)", "full_signature": "private DescriptorValue getDummyDescriptorValue(Exception e)", "class_method_signature": "MomentOfInertiaDescriptor.getDummyDescriptorValue(Exception e)", "testcase": false, "constructor": false}, {"identifier": "calculate", "parameters": "(IAtomContainer container)", "modifiers": "@Override public", "return": "DescriptorValue", "signature": "DescriptorValue calculate(IAtomContainer container)", "full_signature": "@Override public DescriptorValue calculate(IAtomContainer container)", "class_method_signature": "MomentOfInertiaDescriptor.calculate(IAtomContainer container)", "testcase": false, "constructor": false}, {"identifier": "getDescriptorResultType", "parameters": "()", "modifiers": "@Override public", "return": "IDescriptorResult", "signature": "IDescriptorResult getDescriptorResultType()", "full_signature": "@Override public IDescriptorResult getDescriptorResultType()", "class_method_signature": "MomentOfInertiaDescriptor.getDescriptorResultType()", "testcase": false, "constructor": false}], "file": "descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/MomentOfInertiaDescriptor.java"}, "focal_method": {"identifier": "calculate", "parameters": "(IAtomContainer container)", "modifiers": "@Override public", "return": "DescriptorValue", "body": "@Override\n    public DescriptorValue calculate(IAtomContainer container) {\n        if (!GeometryUtil.has3DCoordinates(container))\n            return getDummyDescriptorValue(new CDKException(\"Molecule must have 3D coordinates\"));\n\n        IAtomContainer clone;\n        IsotopeFactory factory;\n        try {\n            clone = (IAtomContainer) container.clone();\n            factory = Isotopes.getInstance();\n            factory.configureAtoms(clone);\n        } catch (CloneNotSupportedException | IOException e) {\n            logger.debug(e);\n            return getDummyDescriptorValue(e);\n        }\n\n        DoubleArrayResult retval = new DoubleArrayResult(7);\n\n        double ccf = 1.000138;\n        double eps = 1e-5;\n\n        double[][] imat = new double[3][3];\n        Point3d centerOfMass = GeometryUtil.get3DCentreOfMass(clone);\n\n        double xdif;\n        double ydif;\n        double zdif;\n        double xsq;\n        double ysq;\n        double zsq;\n        for (int i = 0; i < clone.getAtomCount(); i++) {\n            IAtom currentAtom = clone.getAtom(i);\n\n            Double mass = factory.getMajorIsotope(currentAtom.getSymbol()).getExactMass();\n            if (mass == null)\n                mass = factory.getNaturalMass(currentAtom);\n\n            xdif = currentAtom.getPoint3d().x - centerOfMass.x;\n            ydif = currentAtom.getPoint3d().y - centerOfMass.y;\n            zdif = currentAtom.getPoint3d().z - centerOfMass.z;\n            xsq = xdif * xdif;\n            ysq = ydif * ydif;\n            zsq = zdif * zdif;\n\n            imat[0][0] += mass * (ysq + zsq);\n            imat[1][1] += mass * (xsq + zsq);\n            imat[2][2] += mass * (xsq + ysq);\n\n            imat[1][0] += -1 * mass * ydif * xdif;\n            imat[0][1] = imat[1][0];\n\n            imat[2][0] += -1 * mass * xdif * zdif;\n            imat[0][2] = imat[2][0];\n\n            imat[2][1] += -1 * mass * ydif * zdif;\n            imat[1][2] = imat[2][1];\n        }\n\n        // diagonalize the MI tensor\n        Matrix tmp = new Matrix(imat);\n        EigenvalueDecomposition eigenDecomp = tmp.eig();\n        double[] eval = eigenDecomp.getRealEigenvalues();\n\n        retval.add(eval[2]);\n        retval.add(eval[1]);\n        retval.add(eval[0]);\n\n        double etmp = eval[0];\n        eval[0] = eval[2];\n        eval[2] = etmp;\n\n        if (Math.abs(eval[1]) > 1e-3)\n            retval.add(eval[0] / eval[1]);\n        else\n            retval.add(1000);\n\n        if (Math.abs(eval[2]) > 1e-3) {\n            retval.add(eval[0] / eval[2]);\n            retval.add(eval[1] / eval[2]);\n        } else {\n            retval.add(1000);\n            retval.add(1000);\n        }\n\n        // finally get the radius of gyration\n        double pri;\n        IMolecularFormula formula = MolecularFormulaManipulator.getMolecularFormula(clone);\n        if (Math.abs(eval[2]) > eps)\n            pri = Math.pow(eval[0] * eval[1] * eval[2], 1.0 / 3.0);\n        else\n            pri = Math.sqrt(eval[0] * ccf / MolecularFormulaManipulator.getTotalExactMass(formula));\n        retval.add(Math.sqrt(Math.PI * 2 * pri * ccf / MolecularFormulaManipulator.getTotalExactMass(formula)));\n\n        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), retval,\n                getDescriptorNames());\n    }", "signature": "DescriptorValue calculate(IAtomContainer container)", "full_signature": "@Override public DescriptorValue calculate(IAtomContainer container)", "class_method_signature": "MomentOfInertiaDescriptor.calculate(IAtomContainer container)", "testcase": false, "constructor": false, "invocations": ["has3DCoordinates", "getDummyDescriptorValue", "clone", "getInstance", "configureAtoms", "debug", "getDummyDescriptorValue", "get3DCentreOfMass", "getAtomCount", "getAtom", "getExactMass", "getMajorIsotope", "getSymbol", "getNaturalMass", "getPoint3d", "getPoint3d", "getPoint3d", "eig", "getRealEigenvalues", "add", "add", "add", "abs", "add", "add", "abs", "add", "add", "add", "add", "getMolecularFormula", "abs", "pow", "sqrt", "getTotalExactMass", "add", "sqrt", "getTotalExactMass", "getSpecification", "getParameterNames", "getParameters", "getDescriptorNames"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}