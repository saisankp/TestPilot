{"test_class": {"identifier": "OpenLRBinaryEncoderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final byte[] DATA_WP_EXAMPLE = {11, 4, 91, 91, 35, 70, -11, 26, 108,\n            9, 0, -101, -2, 59, 27, -76, 4, -1, -21, -1, -93, 43, 89, 68};", "modifier": "static final", "type": "byte[]", "declarator": "DATA_WP_EXAMPLE = {11, 4, 91, 91, 35, 70, -11, 26, 108,\n            9, 0, -101, -2, 59, 27, -76, 4, -1, -21, -1, -93, 43, 89, 68}", "var_name": "DATA_WP_EXAMPLE"}, {"original_string": "private static final byte[] DATA_VALID_NO_OFFSETS_V3 = {11, 4, 91, 91, 35,\n            70, -11, 26, 108, 9, 0, -101, -2, 59, 27, -76, 4, -1, -21, -1, -93,\n            43, 25};", "modifier": "private static final", "type": "byte[]", "declarator": "DATA_VALID_NO_OFFSETS_V3 = {11, 4, 91, 91, 35,\n            70, -11, 26, 108, 9, 0, -101, -2, 59, 27, -76, 4, -1, -21, -1, -93,\n            43, 25}", "var_name": "DATA_VALID_NO_OFFSETS_V3"}, {"original_string": "private static final byte[] DATA_VALID_WITH_OFFSETS_V3 = {11, 4, 91, 91,\n            35, 70, -11, 26, 108, 9, 0, -101, -2, 59, 27, -76, 4, -1, -21, -1,\n            -93, 43, 121, 68, 93};", "modifier": "private static final", "type": "byte[]", "declarator": "DATA_VALID_WITH_OFFSETS_V3 = {11, 4, 91, 91,\n            35, 70, -11, 26, 108, 9, 0, -101, -2, 59, 27, -76, 4, -1, -21, -1,\n            -93, 43, 121, 68, 93}", "var_name": "DATA_VALID_WITH_OFFSETS_V3"}, {"original_string": "private static final int DATA_VALID_WITH_OFFSETS_V2_BYTE1 = 10;", "modifier": "private static final", "type": "int", "declarator": "DATA_VALID_WITH_OFFSETS_V2_BYTE1 = 10", "var_name": "DATA_VALID_WITH_OFFSETS_V2_BYTE1"}, {"original_string": "private static final int POSITIVE_OFFSET_BINARY_V2 = 2;", "modifier": "private static final", "type": "int", "declarator": "POSITIVE_OFFSET_BINARY_V2 = 2", "var_name": "POSITIVE_OFFSET_BINARY_V2"}, {"original_string": "private static final int POSITVE_OFFSET_WP_EXAMPLE = 150;", "modifier": "private static final", "type": "int", "declarator": "POSITVE_OFFSET_WP_EXAMPLE = 150", "var_name": "POSITVE_OFFSET_WP_EXAMPLE"}, {"original_string": "private static final int NEGATIVE_OFFSET = 100;", "modifier": "private static final", "type": "int", "declarator": "NEGATIVE_OFFSET = 100", "var_name": "NEGATIVE_OFFSET"}, {"original_string": "private static final int POSITVE_OFFSET_TOO_LONG = 2000;", "modifier": "private static final", "type": "int", "declarator": "POSITVE_OFFSET_TOO_LONG = 2000", "var_name": "POSITVE_OFFSET_TOO_LONG"}, {"original_string": "private static final OpenLRBinaryEncoder BINARY_ENCODER = new OpenLRBinaryEncoder();", "modifier": "private static final", "type": "OpenLRBinaryEncoder", "declarator": "BINARY_ENCODER = new OpenLRBinaryEncoder()", "var_name": "BINARY_ENCODER"}, {"original_string": "private static byte[] dataValidWithOffsetsV2 = new byte[DATA_VALID_WITH_OFFSETS_V3.length];", "modifier": "private static", "type": "byte[]", "declarator": "dataValidWithOffsetsV2 = new byte[DATA_VALID_WITH_OFFSETS_V3.length]", "var_name": "dataValidWithOffsetsV2"}, {"original_string": "private static Map<Integer, byte[]> expectedData;", "modifier": "private static", "type": "Map<Integer, byte[]>", "declarator": "expectedData", "var_name": "expectedData"}, {"original_string": "private RawLocationReference lineLocRefEmpty;", "modifier": "private", "type": "RawLocationReference", "declarator": "lineLocRefEmpty", "var_name": "lineLocRefEmpty"}, {"original_string": "private RawLocationReference lineLocRefOffsetsNull;", "modifier": "private", "type": "RawLocationReference", "declarator": "lineLocRefOffsetsNull", "var_name": "lineLocRefOffsetsNull"}, {"original_string": "private RawLocationReference lineLocRefValidOffset0;", "modifier": "private", "type": "RawLocationReference", "declarator": "lineLocRefValidOffset0", "var_name": "lineLocRefValidOffset0"}, {"original_string": "private RawLocationReference lineLocRefValidWithOffset;", "modifier": "private", "type": "RawLocationReference", "declarator": "lineLocRefValidWithOffset", "var_name": "lineLocRefValidWithOffset"}, {"original_string": "private RawLocationReference lineLocRefWpExample;", "modifier": "private", "type": "RawLocationReference", "declarator": "lineLocRefWpExample", "var_name": "lineLocRefWpExample"}, {"original_string": "private RawLocationReference lineLocRefValidOffsetTooLong;", "modifier": "private", "type": "RawLocationReference", "declarator": "lineLocRefValidOffsetTooLong", "var_name": "lineLocRefValidOffsetTooLong"}], "file": "binary/src/test/java/openlr/binary/OpenLRBinaryEncoderTest.java"}, "test_case": {"identifier": "testValidWithNoOffsets", "parameters": "()", "modifiers": "@Test public final", "return": "void", "body": "@Test\n    public final void testValidWithNoOffsets() {\n        LocationReference ref = null;\n        ref = BINARY_ENCODER.encodeData(lineLocRefValidOffset0);\n        assertTrue(ref.isValid());\n        if (!\"binary\".equals(ref.getDataIdentifier())) {\n            fail(\"Invalid data identifier\");\n        }\n        if (!checkDataClass(ref)) {\n            fail(\"invalid data class\");\n        }\n\n        assertSame(ref.getVersion(),\n                OpenLRBinaryConstants.LATEST_BINARY_VERSION);\n\n        Utils.checkBinData((ByteArray) ref.getLocationReferenceData(),\n                DATA_VALID_NO_OFFSETS_V3,\n                OpenLRBinaryConstants.LATEST_BINARY_VERSION);\n    }", "signature": "void testValidWithNoOffsets()", "full_signature": "@Test public final void testValidWithNoOffsets()", "class_method_signature": "OpenLRBinaryEncoderTest.testValidWithNoOffsets()", "testcase": true, "constructor": false, "invocations": ["encodeData", "assertTrue", "isValid", "equals", "getDataIdentifier", "fail", "checkDataClass", "fail", "assertSame", "getVersion", "checkBinData", "getLocationReferenceData"]}, "focal_class": {"identifier": "OpenLRBinaryEncoder", "superclass": "", "interfaces": "implements PhysicalEncoder", "fields": [{"original_string": "private static final int[] VERSIONS = {2, 3};", "modifier": "private static final", "type": "int[]", "declarator": "VERSIONS = {2, 3}", "var_name": "VERSIONS"}], "methods": [{"identifier": "checkVersion", "parameters": "(final int version, final LocationType lt)", "modifiers": "private", "return": "boolean", "signature": "boolean checkVersion(final int version, final LocationType lt)", "full_signature": "private boolean checkVersion(final int version, final LocationType lt)", "class_method_signature": "OpenLRBinaryEncoder.checkVersion(final int version, final LocationType lt)", "testcase": false, "constructor": false}, {"identifier": "getDataClass", "parameters": "()", "modifiers": "public final", "return": "Class<?>", "signature": "Class<?> getDataClass()", "full_signature": "public final Class<?> getDataClass()", "class_method_signature": "OpenLRBinaryEncoder.getDataClass()", "testcase": false, "constructor": false}, {"identifier": "getDataFormatIdentifier", "parameters": "()", "modifiers": "public final", "return": "String", "signature": "String getDataFormatIdentifier()", "full_signature": "public final String getDataFormatIdentifier()", "class_method_signature": "OpenLRBinaryEncoder.getDataFormatIdentifier()", "testcase": false, "constructor": false}, {"identifier": "getSupportedVersions", "parameters": "()", "modifiers": "public final", "return": "int[]", "signature": "int[] getSupportedVersions()", "full_signature": "public final int[] getSupportedVersions()", "class_method_signature": "OpenLRBinaryEncoder.getSupportedVersions()", "testcase": false, "constructor": false}, {"identifier": "encodeData", "parameters": "(\n            final RawLocationReference rawLocRef)", "modifiers": "public final", "return": "LocationReference", "signature": "LocationReference encodeData(\n            final RawLocationReference rawLocRef)", "full_signature": "public final LocationReference encodeData(\n            final RawLocationReference rawLocRef)", "class_method_signature": "OpenLRBinaryEncoder.encodeData(\n            final RawLocationReference rawLocRef)", "testcase": false, "constructor": false}, {"identifier": "encodeData", "parameters": "(\n            final RawLocationReference rawLocRef, final int version)", "modifiers": "public final", "return": "LocationReference", "signature": "LocationReference encodeData(\n            final RawLocationReference rawLocRef, final int version)", "full_signature": "public final LocationReference encodeData(\n            final RawLocationReference rawLocRef, final int version)", "class_method_signature": "OpenLRBinaryEncoder.encodeData(\n            final RawLocationReference rawLocRef, final int version)", "testcase": false, "constructor": false}], "file": "binary/src/main/java/openlr/binary/OpenLRBinaryEncoder.java"}, "focal_method": {"identifier": "encodeData", "parameters": "(\n            final RawLocationReference rawLocRef)", "modifiers": "public final", "return": "LocationReference", "body": "public final LocationReference encodeData(\n            final RawLocationReference rawLocRef) {\n        return encodeData(rawLocRef, VERSIONS[VERSIONS.length - 1]);\n    }", "signature": "LocationReference encodeData(\n            final RawLocationReference rawLocRef)", "full_signature": "public final LocationReference encodeData(\n            final RawLocationReference rawLocRef)", "class_method_signature": "OpenLRBinaryEncoder.encodeData(\n            final RawLocationReference rawLocRef)", "testcase": false, "constructor": false, "invocations": ["encodeData"]}, "repository": {"repo_id": 187195345, "url": "https://github.com/tomtom-international/openlr", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 24, "size": 4809, "license": "licensed"}}