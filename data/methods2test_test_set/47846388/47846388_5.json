{"test_class": {"identifier": "ServiceClassParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ServiceClassParser serviceClassParser;", "modifier": "private", "type": "ServiceClassParser", "declarator": "serviceClassParser", "var_name": "serviceClassParser"}, {"original_string": "private TypescriptServiceGeneratorConfiguration settings;", "modifier": "private", "type": "TypescriptServiceGeneratorConfiguration", "declarator": "settings", "var_name": "settings"}], "file": "typescript-service-generator-core/src/test/java/com/palantir/code/ts/generator/ServiceClassParserTest.java"}, "test_case": {"identifier": "duplicateNameResolutionTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void duplicateNameResolutionTest() {\n        // Mock out a simple resolver that does the resolution based on number of parameters\n        Mockito.when(settings.duplicateEndpointNameResolver()).thenReturn(new DuplicateMethodNameResolver() {\n            @Override\n            public Map<Method, String> resolveDuplicateNames(List<Method> methodsWithSameName) {\n                Map<Method, String> result = Maps.newHashMap();\n                for (Method method : methodsWithSameName) {\n                    if (method.getParameterTypes().length > 0) {\n                        result.put(method, \"nonZeroParameters\");\n                    } else {\n                        result.put(method, \"zeroParameters\");\n                    }\n                }\n                return result;\n            }\n        });\n        ServiceModel model = serviceClassParser.parseServiceClass(DuplicateMethodNamesService.class, settings);\n        assertEquals(1, model.innerServiceModels().size());\n        List<ServiceEndpointModel> endpointModels = Lists.newArrayList(model.innerServiceModels().get(0).endpointModels().iterator());\n        Collections.sort(endpointModels);\n        assertEquals(Lists.newArrayList(\"nonZeroParameters\", \"zeroParameters\"),\n                     endpointModels.stream().map(endpoint -> endpoint.endpointName()).collect(Collectors.toList()));\n        assertTrue(endpointModels.get(0).parameters().size() > 0);\n        assertTrue(endpointModels.get(1).parameters().size() == 0);\n    }", "signature": "void duplicateNameResolutionTest()", "full_signature": "@Test public void duplicateNameResolutionTest()", "class_method_signature": "ServiceClassParserTest.duplicateNameResolutionTest()", "testcase": true, "constructor": false, "invocations": ["thenReturn", "when", "duplicateEndpointNameResolver", "newHashMap", "getParameterTypes", "put", "put", "parseServiceClass", "assertEquals", "size", "innerServiceModels", "newArrayList", "iterator", "endpointModels", "get", "innerServiceModels", "sort", "assertEquals", "newArrayList", "collect", "map", "stream", "endpointName", "toList", "assertTrue", "size", "parameters", "get", "assertTrue", "size", "parameters", "get"]}, "focal_class": {"identifier": "ServiceClassParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "@SuppressWarnings(\"unchecked\")\n    private final static List<Class<? extends Annotation>> ANNOTATION_CLASSES = Lists.newArrayList(POST.class, GET.class, DELETE.class, PUT.class, OPTIONS.class);", "modifier": "@SuppressWarnings(\"unchecked\")\n    private final static", "type": "List<Class<? extends Annotation>>", "declarator": "ANNOTATION_CLASSES = Lists.newArrayList(POST.class, GET.class, DELETE.class, PUT.class, OPTIONS.class)", "var_name": "ANNOTATION_CLASSES"}], "methods": [{"identifier": "getAllServiceMethods", "parameters": "(Class<?> serviceClass, MethodFilter methodFilter)", "modifiers": "public", "return": "Set<Method>", "signature": "Set<Method> getAllServiceMethods(Class<?> serviceClass, MethodFilter methodFilter)", "full_signature": "public Set<Method> getAllServiceMethods(Class<?> serviceClass, MethodFilter methodFilter)", "class_method_signature": "ServiceClassParser.getAllServiceMethods(Class<?> serviceClass, MethodFilter methodFilter)", "testcase": false, "constructor": false}, {"identifier": "parseServiceClass", "parameters": "(Class<?> mainServiceClass, TypescriptServiceGeneratorConfiguration settings, Class<?>... serviceClassesToMerge)", "modifiers": "public", "return": "ServiceModel", "signature": "ServiceModel parseServiceClass(Class<?> mainServiceClass, TypescriptServiceGeneratorConfiguration settings, Class<?>... serviceClassesToMerge)", "full_signature": "public ServiceModel parseServiceClass(Class<?> mainServiceClass, TypescriptServiceGeneratorConfiguration settings, Class<?>... serviceClassesToMerge)", "class_method_signature": "ServiceClassParser.parseServiceClass(Class<?> mainServiceClass, TypescriptServiceGeneratorConfiguration settings, Class<?>... serviceClassesToMerge)", "testcase": false, "constructor": false}, {"identifier": "computeEndpointModels", "parameters": "(Set<Method> endpoints, ModelCompiler compiler, TypescriptServiceGeneratorConfiguration settings)", "modifiers": "private static", "return": "List<ServiceEndpointModel>", "signature": "List<ServiceEndpointModel> computeEndpointModels(Set<Method> endpoints, ModelCompiler compiler, TypescriptServiceGeneratorConfiguration settings)", "full_signature": "private static List<ServiceEndpointModel> computeEndpointModels(Set<Method> endpoints, ModelCompiler compiler, TypescriptServiceGeneratorConfiguration settings)", "class_method_signature": "ServiceClassParser.computeEndpointModels(Set<Method> endpoints, ModelCompiler compiler, TypescriptServiceGeneratorConfiguration settings)", "testcase": false, "constructor": false}, {"identifier": "getMethodType", "parameters": "(Method endpoint)", "modifiers": "private static", "return": "String", "signature": "String getMethodType(Method endpoint)", "full_signature": "private static String getMethodType(Method endpoint)", "class_method_signature": "ServiceClassParser.getMethodType(Method endpoint)", "testcase": false, "constructor": false}, {"identifier": "getParamterAnnotationMaps", "parameters": "(Method endpoint)", "modifiers": "private static", "return": "List<Map<Class<?>, Annotation>>", "signature": "List<Map<Class<?>, Annotation>> getParamterAnnotationMaps(Method endpoint)", "full_signature": "private static List<Map<Class<?>, Annotation>> getParamterAnnotationMaps(Method endpoint)", "class_method_signature": "ServiceClassParser.getParamterAnnotationMaps(Method endpoint)", "testcase": false, "constructor": false}, {"identifier": "getTypesFromEndpoint", "parameters": "(Method endpoint, TypescriptServiceGeneratorConfiguration settings)", "modifiers": "private static", "return": "Set<Type>", "signature": "Set<Type> getTypesFromEndpoint(Method endpoint, TypescriptServiceGeneratorConfiguration settings)", "full_signature": "private static Set<Type> getTypesFromEndpoint(Method endpoint, TypescriptServiceGeneratorConfiguration settings)", "class_method_signature": "ServiceClassParser.getTypesFromEndpoint(Method endpoint, TypescriptServiceGeneratorConfiguration settings)", "testcase": false, "constructor": false}], "file": "typescript-service-generator-core/src/main/java/com/palantir/code/ts/generator/ServiceClassParser.java"}, "focal_method": {"identifier": "parseServiceClass", "parameters": "(Class<?> mainServiceClass, TypescriptServiceGeneratorConfiguration settings, Class<?>... serviceClassesToMerge)", "modifiers": "public", "return": "ServiceModel", "body": "public ServiceModel parseServiceClass(Class<?> mainServiceClass, TypescriptServiceGeneratorConfiguration settings, Class<?>... serviceClassesToMerge) {\n        List<Class<?>> serviceClazzes = Lists.newArrayList(mainServiceClass);\n        serviceClazzes.addAll(Lists.newArrayList(serviceClassesToMerge));\n        ImmutableServiceModel.Builder serviceModel = ImmutableServiceModel.builder();\n        serviceModel.name(mainServiceClass.getSimpleName());\n        for (Class<?> serviceClass : serviceClazzes) {\n            ImmutableInnerServiceModel.Builder innerServiceModel = ImmutableInnerServiceModel.builder();\n            Path servicePathAnnotation = serviceClass.getAnnotation(Path.class);\n            innerServiceModel.servicePath(servicePathAnnotation == null ? \"\" : PathUtils.trimSlashes(servicePathAnnotation.value()));\n            innerServiceModel.name(serviceClass.getSimpleName());\n\n            Set<Method> serviceMethods = getAllServiceMethods(serviceClass, settings.methodFilter());\n            // find and stores all types that are referenced by this service\n            Set<Type> referencedTypes = Sets.newHashSet();\n            for (Method method : serviceMethods) {\n                referencedTypes.addAll(getTypesFromEndpoint(method, settings));\n            }\n            serviceModel.addAllReferencedTypes(referencedTypes);\n\n            ModelCompiler compiler = new TypeScriptGenerator(settings.getSettings()).getModelCompiler();\n\n            List<ServiceEndpointModel> endpointModels = Lists.newArrayList();\n            endpointModels = computeEndpointModels(serviceMethods, compiler, settings);\n\n            Collections.sort(endpointModels);\n            innerServiceModel.endpointModels(endpointModels);\n            serviceModel.addInnerServiceModels(innerServiceModel.build());\n        }\n        return serviceModel.build();\n    }", "signature": "ServiceModel parseServiceClass(Class<?> mainServiceClass, TypescriptServiceGeneratorConfiguration settings, Class<?>... serviceClassesToMerge)", "full_signature": "public ServiceModel parseServiceClass(Class<?> mainServiceClass, TypescriptServiceGeneratorConfiguration settings, Class<?>... serviceClassesToMerge)", "class_method_signature": "ServiceClassParser.parseServiceClass(Class<?> mainServiceClass, TypescriptServiceGeneratorConfiguration settings, Class<?>... serviceClassesToMerge)", "testcase": false, "constructor": false, "invocations": ["newArrayList", "addAll", "newArrayList", "builder", "name", "getSimpleName", "builder", "getAnnotation", "servicePath", "trimSlashes", "value", "name", "getSimpleName", "getAllServiceMethods", "methodFilter", "newHashSet", "addAll", "getTypesFromEndpoint", "addAllReferencedTypes", "getModelCompiler", "getSettings", "newArrayList", "computeEndpointModels", "sort", "endpointModels", "addInnerServiceModels", "build", "build"]}, "repository": {"repo_id": 47846388, "url": "https://github.com/palantir/typescript-service-generator", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 20, "size": 371, "license": "licensed"}}