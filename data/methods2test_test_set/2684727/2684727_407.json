{"test_class": {"identifier": "CognitoIdentityProviderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String TOKEN = \"token\";", "modifier": "private static final", "type": "String", "declarator": "TOKEN = \"token\"", "var_name": "TOKEN"}, {"original_string": "private static final String IDENTITY_ID = \"identityId\";", "modifier": "private static final", "type": "String", "declarator": "IDENTITY_ID = \"identityId\"", "var_name": "IDENTITY_ID"}, {"original_string": "private static final Date EXPIRES_AT = new Date(5);", "modifier": "private static final", "type": "Date", "declarator": "EXPIRES_AT = new Date(5)", "var_name": "EXPIRES_AT"}, {"original_string": "CognitoIdentityProvider cognitoIdentityProvider;", "modifier": "", "type": "CognitoIdentityProvider", "declarator": "cognitoIdentityProvider", "var_name": "cognitoIdentityProvider"}, {"original_string": "@Mock\n    IdentityManager identityManager;", "modifier": "@Mock", "type": "IdentityManager", "declarator": "identityManager", "var_name": "identityManager"}, {"original_string": "@Mock\n    LocalCognitoTokenStore localCognitoTokenStore;", "modifier": "@Mock", "type": "LocalCognitoTokenStore", "declarator": "localCognitoTokenStore", "var_name": "localCognitoTokenStore"}, {"original_string": "@Mock\n    MeResponse meResponse;", "modifier": "@Mock", "type": "MeResponse", "declarator": "meResponse", "var_name": "meResponse"}, {"original_string": "@Mock\n    User user;", "modifier": "@Mock", "type": "User", "declarator": "user", "var_name": "user"}], "file": "aws/src/test/java/co/smartreceipts/aws/cognito/CognitoIdentityProviderTest.java"}, "test_case": {"identifier": "prefetchNullToken", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void prefetchNullToken() {\n        final Cognito preCognito = null;\n        Mockito.when(localCognitoTokenStore.getCognitoToken()).thenReturn(preCognito);\n        Mockito.when(identityManager.getMe()).thenReturn(Observable.just(meResponse));\n        Mockito.when(user.getCognitoToken()).thenReturn(TOKEN);\n        Mockito.when(user.getIdentityId()).thenReturn(IDENTITY_ID);\n        Mockito.when(user.getCognitoTokenExpiresAt()).thenReturn(EXPIRES_AT);\n\n        TestObserver<Optional<Cognito>> testObserver = cognitoIdentityProvider.prefetchCognitoTokenIfNeeded().test();\n\n        final Cognito cognito = new Cognito(TOKEN, IDENTITY_ID, EXPIRES_AT);\n        Mockito.verify(localCognitoTokenStore).persist(null);\n        Mockito.verify(localCognitoTokenStore).persist(cognito);\n        testObserver.assertValue(Optional.of(cognito))\n                .assertComplete()\n                .assertNoErrors();\n    }", "signature": "void prefetchNullToken()", "full_signature": "@Test public void prefetchNullToken()", "class_method_signature": "CognitoIdentityProviderTest.prefetchNullToken()", "testcase": true, "constructor": false, "invocations": ["thenReturn", "when", "getCognitoToken", "thenReturn", "when", "getMe", "just", "thenReturn", "when", "getCognitoToken", "thenReturn", "when", "getIdentityId", "thenReturn", "when", "getCognitoTokenExpiresAt", "test", "prefetchCognitoTokenIfNeeded", "persist", "verify", "persist", "verify", "assertNoErrors", "assertComplete", "assertValue", "of"]}, "focal_class": {"identifier": "CognitoIdentityProvider", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final IdentityManager identityManager;", "modifier": "private final", "type": "IdentityManager", "declarator": "identityManager", "var_name": "identityManager"}, {"original_string": "private final LocalCognitoTokenStore localCognitoTokenStore;", "modifier": "private final", "type": "LocalCognitoTokenStore", "declarator": "localCognitoTokenStore", "var_name": "localCognitoTokenStore"}], "methods": [{"identifier": "CognitoIdentityProvider", "parameters": "(@NonNull IdentityManager identityManager,\n                                   @NonNull LocalCognitoTokenStore localCognitoTokenStore)", "modifiers": "@Inject public", "return": "", "signature": " CognitoIdentityProvider(@NonNull IdentityManager identityManager,\n                                   @NonNull LocalCognitoTokenStore localCognitoTokenStore)", "full_signature": "@Inject public  CognitoIdentityProvider(@NonNull IdentityManager identityManager,\n                                   @NonNull LocalCognitoTokenStore localCognitoTokenStore)", "class_method_signature": "CognitoIdentityProvider.CognitoIdentityProvider(@NonNull IdentityManager identityManager,\n                                   @NonNull LocalCognitoTokenStore localCognitoTokenStore)", "testcase": false, "constructor": true}, {"identifier": "prefetchCognitoTokenIfNeeded", "parameters": "()", "modifiers": "@NonNull public", "return": "Single<Optional<Cognito>>", "signature": "Single<Optional<Cognito>> prefetchCognitoTokenIfNeeded()", "full_signature": "@NonNull public Single<Optional<Cognito>> prefetchCognitoTokenIfNeeded()", "class_method_signature": "CognitoIdentityProvider.prefetchCognitoTokenIfNeeded()", "testcase": false, "constructor": false}, {"identifier": "refreshCognitoToken", "parameters": "()", "modifiers": "@NonNull public", "return": "Single<Optional<Cognito>>", "signature": "Single<Optional<Cognito>> refreshCognitoToken()", "full_signature": "@NonNull public Single<Optional<Cognito>> refreshCognitoToken()", "class_method_signature": "CognitoIdentityProvider.refreshCognitoToken()", "testcase": false, "constructor": false}, {"identifier": "synchronouslyRefreshCognitoToken", "parameters": "()", "modifiers": "@Nullable public", "return": "Cognito", "signature": "Cognito synchronouslyRefreshCognitoToken()", "full_signature": "@Nullable public Cognito synchronouslyRefreshCognitoToken()", "class_method_signature": "CognitoIdentityProvider.synchronouslyRefreshCognitoToken()", "testcase": false, "constructor": false}, {"identifier": "getCachedCognitoToken", "parameters": "()", "modifiers": "@NonNull public", "return": "Optional<Cognito>", "signature": "Optional<Cognito> getCachedCognitoToken()", "full_signature": "@NonNull public Optional<Cognito> getCachedCognitoToken()", "class_method_signature": "CognitoIdentityProvider.getCachedCognitoToken()", "testcase": false, "constructor": false}], "file": "aws/src/main/java/co/smartreceipts/aws/cognito/CognitoIdentityProvider.java"}, "focal_method": {"identifier": "prefetchCognitoTokenIfNeeded", "parameters": "()", "modifiers": "@NonNull public", "return": "Single<Optional<Cognito>>", "body": "@NonNull\n    public Single<Optional<Cognito>> prefetchCognitoTokenIfNeeded() {\n        return Single.fromCallable(this::getCachedCognitoToken)\n                .flatMap(cognitoOptional -> {\n                    if (!cognitoOptional.isPresent()\n                            || cognitoOptional.get().getCognitoToken() == null\n                            || cognitoOptional.get().getIdentityId() == null) {\n                        Logger.debug(CognitoIdentityProvider.this, \"Existing cognito token is invalid. Pre-fetching...\");\n                        return refreshCognitoToken();\n                    } else {\n                        Logger.debug(CognitoIdentityProvider.this, \"Existing cognito token is valid\");\n                        return Single.just(cognitoOptional);\n                    }\n                });\n    }", "signature": "Single<Optional<Cognito>> prefetchCognitoTokenIfNeeded()", "full_signature": "@NonNull public Single<Optional<Cognito>> prefetchCognitoTokenIfNeeded()", "class_method_signature": "CognitoIdentityProvider.prefetchCognitoTokenIfNeeded()", "testcase": false, "constructor": false, "invocations": ["flatMap", "fromCallable", "isPresent", "getCognitoToken", "get", "getIdentityId", "get", "debug", "refreshCognitoToken", "debug", "just"]}, "repository": {"repo_id": 2684727, "url": "https://github.com/wbaumann/SmartReceiptsLibrary", "stars": 166, "created": "11/1/2011 12:32:39 AM +00:00", "updates": "2020-01-26T22:04:24+00:00", "fork": "False", "license": "licensed"}}