{"test_class": {"identifier": "TestLoadBalancingSinkProcessor", "superclass": "", "interfaces": "", "fields": [], "file": "flume-ng-core/src/test/java/org/apache/flume/sink/TestLoadBalancingSinkProcessor.java"}, "test_case": {"identifier": "testRoundRobinBackoffIncreasingBackoffs", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testRoundRobinBackoffIncreasingBackoffs()\n      throws EventDeliveryException, InterruptedException {\n    Channel ch = new MockChannel();\n    int n = 100;\n    int numEvents = 3 * n;\n    for (int i = 0; i < numEvents; i++) {\n      ch.put(new MockEvent(\"test\" + i));\n    }\n\n    MockSink s1 = new MockSink(1);\n    s1.setChannel(ch);\n\n    MockSink s2 = new MockSink(2);\n    s2.setChannel(ch);\n    s2.setFail(true);\n\n    MockSink s3 = new MockSink(3);\n    s3.setChannel(ch);\n\n    List<Sink> sinks = new ArrayList<Sink>();\n    sinks.add(s1);\n    sinks.add(s2);\n    sinks.add(s3);\n\n    LoadBalancingSinkProcessor lbsp = getProcessor(\"round_robin\",sinks, true);\n\n    Status s = Status.READY;\n    for (int i = 0; i < 3 && s != Status.BACKOFF; i++) {\n      s = lbsp.process();\n    }\n    Assert.assertEquals(0, s2.getEvents().size());\n    Thread.sleep(2100);\n    // this should let the sink come out of backoff and get backed off  for a longer time\n    for (int i = 0; i < 3 && s != Status.BACKOFF; i++) {\n      s = lbsp.process();\n    }\n    Assert.assertEquals(0, s2.getEvents().size());\n    s2.setFail(false);\n    Thread.sleep(2100);\n    // this time it shouldn't come out of backoff yet as the timeout isn't over\n    for (int i = 0; i < 3 && s != Status.BACKOFF; i++) {\n      s = lbsp.process();\n    }\n    Assert.assertEquals(0, s2.getEvents().size());\n    // after this s2 should be receiving events agains\n    Thread.sleep(2100);\n    while (s != Status.BACKOFF) {\n      s = lbsp.process();\n    }\n\n    Assert.assertEquals( n + 2, s1.getEvents().size());\n    Assert.assertEquals( n - 3, s2.getEvents().size());\n    Assert.assertEquals( n + 1, s3.getEvents().size());\n  }", "signature": "void testRoundRobinBackoffIncreasingBackoffs()", "full_signature": "@Test public void testRoundRobinBackoffIncreasingBackoffs()", "class_method_signature": "TestLoadBalancingSinkProcessor.testRoundRobinBackoffIncreasingBackoffs()", "testcase": true, "constructor": false, "invocations": ["put", "setChannel", "setChannel", "setFail", "setChannel", "add", "add", "add", "getProcessor", "process", "assertEquals", "size", "getEvents", "sleep", "process", "assertEquals", "size", "getEvents", "setFail", "sleep", "process", "assertEquals", "size", "getEvents", "sleep", "process", "assertEquals", "size", "getEvents", "assertEquals", "size", "getEvents", "assertEquals", "size", "getEvents"]}, "focal_class": {"identifier": "LoadBalancingSinkProcessor", "superclass": "extends AbstractSinkProcessor", "interfaces": "", "fields": [{"original_string": "public static final String CONFIG_SELECTOR = \"selector\";", "modifier": "public static final", "type": "String", "declarator": "CONFIG_SELECTOR = \"selector\"", "var_name": "CONFIG_SELECTOR"}, {"original_string": "public static final String CONFIG_SELECTOR_PREFIX = CONFIG_SELECTOR + \".\";", "modifier": "public static final", "type": "String", "declarator": "CONFIG_SELECTOR_PREFIX = CONFIG_SELECTOR + \".\"", "var_name": "CONFIG_SELECTOR_PREFIX"}, {"original_string": "public static final String CONFIG_BACKOFF = \"backoff\";", "modifier": "public static final", "type": "String", "declarator": "CONFIG_BACKOFF = \"backoff\"", "var_name": "CONFIG_BACKOFF"}, {"original_string": "public static final String SELECTOR_NAME_ROUND_ROBIN = \"ROUND_ROBIN\";", "modifier": "public static final", "type": "String", "declarator": "SELECTOR_NAME_ROUND_ROBIN = \"ROUND_ROBIN\"", "var_name": "SELECTOR_NAME_ROUND_ROBIN"}, {"original_string": "public static final String SELECTOR_NAME_RANDOM = \"RANDOM\";", "modifier": "public static final", "type": "String", "declarator": "SELECTOR_NAME_RANDOM = \"RANDOM\"", "var_name": "SELECTOR_NAME_RANDOM"}, {"original_string": "public static final String SELECTOR_NAME_ROUND_ROBIN_BACKOFF = \"ROUND_ROBIN_BACKOFF\";", "modifier": "public static final", "type": "String", "declarator": "SELECTOR_NAME_ROUND_ROBIN_BACKOFF = \"ROUND_ROBIN_BACKOFF\"", "var_name": "SELECTOR_NAME_ROUND_ROBIN_BACKOFF"}, {"original_string": "public static final String SELECTOR_NAME_RANDOM_BACKOFF = \"RANDOM_BACKOFF\";", "modifier": "public static final", "type": "String", "declarator": "SELECTOR_NAME_RANDOM_BACKOFF = \"RANDOM_BACKOFF\"", "var_name": "SELECTOR_NAME_RANDOM_BACKOFF"}, {"original_string": "private static final Logger LOGGER = LoggerFactory\n      .getLogger(LoadBalancingSinkProcessor.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory\n      .getLogger(LoadBalancingSinkProcessor.class)", "var_name": "LOGGER"}, {"original_string": "private SinkSelector selector;", "modifier": "private", "type": "SinkSelector", "declarator": "selector", "var_name": "selector"}], "methods": [{"identifier": "configure", "parameters": "(Context context)", "modifiers": "@Override public", "return": "void", "signature": "void configure(Context context)", "full_signature": "@Override public void configure(Context context)", "class_method_signature": "LoadBalancingSinkProcessor.configure(Context context)", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void start()", "full_signature": "@Override public void start()", "class_method_signature": "LoadBalancingSinkProcessor.start()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void stop()", "full_signature": "@Override public void stop()", "class_method_signature": "LoadBalancingSinkProcessor.stop()", "testcase": false, "constructor": false}, {"identifier": "process", "parameters": "()", "modifiers": "@Override public", "return": "Status", "signature": "Status process()", "full_signature": "@Override public Status process()", "class_method_signature": "LoadBalancingSinkProcessor.process()", "testcase": false, "constructor": false}], "file": "flume-ng-core/src/main/java/org/apache/flume/sink/LoadBalancingSinkProcessor.java"}, "focal_method": {"identifier": "process", "parameters": "()", "modifiers": "@Override public", "return": "Status", "body": "@Override\n  public Status process() throws EventDeliveryException {\n    Status status = null;\n\n    Iterator<Sink> sinkIterator = selector.createSinkIterator();\n    while (sinkIterator.hasNext()) {\n      Sink sink = sinkIterator.next();\n      try {\n        status = sink.process();\n        break;\n      } catch (Exception ex) {\n        selector.informSinkFailed(sink);\n        LOGGER.warn(\"Sink failed to consume event. \"\n            + \"Attempting next sink if available.\", ex);\n      }\n    }\n\n    if (status == null) {\n      throw new EventDeliveryException(\"All configured sinks have failed\");\n    }\n\n    return status;\n  }", "signature": "Status process()", "full_signature": "@Override public Status process()", "class_method_signature": "LoadBalancingSinkProcessor.process()", "testcase": false, "constructor": false, "invocations": ["createSinkIterator", "hasNext", "next", "process", "informSinkFailed", "warn"]}, "repository": {"repo_id": 2198510, "url": "https://github.com/apache/flume", "language": "Java", "is_fork": false, "fork_count": 1372, "stargazer_count": 1971, "size": 44377, "license": "licensed"}}