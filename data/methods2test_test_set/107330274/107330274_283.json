{"test_class": {"identifier": "DefaultApplicationSlaManagementServiceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final TestScheduler testScheduler = Schedulers.test();", "modifier": "private final", "type": "TestScheduler", "declarator": "testScheduler = Schedulers.test()", "var_name": "testScheduler"}, {"original_string": "private final CapacityMonitoringService capacityMonitoringService = mock(CapacityMonitoringService.class);", "modifier": "private final", "type": "CapacityMonitoringService", "declarator": "capacityMonitoringService = mock(CapacityMonitoringService.class)", "var_name": "capacityMonitoringService"}, {"original_string": "private final ApplicationSlaStore storage = mock(ApplicationSlaStore.class);", "modifier": "private final", "type": "ApplicationSlaStore", "declarator": "storage = mock(ApplicationSlaStore.class)", "var_name": "storage"}, {"original_string": "private final ApplicationSlaGenerator generator = new ApplicationSlaGenerator(ApplicationSlaSample.CriticalSmall);", "modifier": "private final", "type": "ApplicationSlaGenerator", "declarator": "generator = new ApplicationSlaGenerator(ApplicationSlaSample.CriticalSmall)", "var_name": "generator"}, {"original_string": "private final DefaultApplicationSlaManagementService slaManagementService = new DefaultApplicationSlaManagementService(\n            capacityMonitoringService,\n            storage,\n            null\n    );", "modifier": "private final", "type": "DefaultApplicationSlaManagementService", "declarator": "slaManagementService = new DefaultApplicationSlaManagementService(\n            capacityMonitoringService,\n            storage,\n            null\n    )", "var_name": "slaManagementService"}], "file": "titus-server-master/src/test/java/com/netflix/titus/master/service/management/internal/DefaultApplicationSlaManagementServiceTest.java"}, "test_case": {"identifier": "testRemovePersistsApplicationSlaAndUpdatesCapacityRequirements", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRemovePersistsApplicationSlaAndUpdatesCapacityRequirements() throws Exception {\n        ApplicationSLA myApp = ApplicationSlaSample.CriticalSmall.build();\n        when(storage.findAll()).thenReturn(Observable.just(myApp));\n        when(storage.remove(myApp.getAppName())).thenReturn(Observable.empty());\n\n        ObservableRecorder<Void> cpmRecorder = ObservableRecorder.newRecorder(Observable.empty());\n        when(capacityMonitoringService.refresh()).thenReturn(cpmRecorder.getObservable());\n\n        // First add new application SLA, which will queue capacity change update\n        slaManagementService.removeApplicationSLA(myApp.getAppName()).toBlocking().firstOrDefault(null);\n\n        // Check that capacityAllocationService is triggered correctly\n        testScheduler.triggerActions();\n        verify(capacityMonitoringService, times(1)).refresh();\n        assertThat(cpmRecorder.numberOfFinishedSubscriptions()).isEqualTo(1);\n    }", "signature": "void testRemovePersistsApplicationSlaAndUpdatesCapacityRequirements()", "full_signature": "@Test public void testRemovePersistsApplicationSlaAndUpdatesCapacityRequirements()", "class_method_signature": "DefaultApplicationSlaManagementServiceTest.testRemovePersistsApplicationSlaAndUpdatesCapacityRequirements()", "testcase": true, "constructor": false, "invocations": ["build", "thenReturn", "when", "findAll", "just", "thenReturn", "when", "remove", "getAppName", "empty", "newRecorder", "empty", "thenReturn", "when", "refresh", "getObservable", "firstOrDefault", "toBlocking", "removeApplicationSLA", "getAppName", "triggerActions", "refresh", "verify", "times", "isEqualTo", "assertThat", "numberOfFinishedSubscriptions"]}, "focal_class": {"identifier": "DefaultApplicationSlaManagementService", "superclass": "", "interfaces": "implements ApplicationSlaManagementService", "fields": [{"original_string": "private final CapacityMonitoringService capacityMonitoringService;", "modifier": "private final", "type": "CapacityMonitoringService", "declarator": "capacityMonitoringService", "var_name": "capacityMonitoringService"}, {"original_string": "private final ApplicationSlaStore storage;", "modifier": "private final", "type": "ApplicationSlaStore", "declarator": "storage", "var_name": "storage"}, {"original_string": "private static final Logger logger = LoggerFactory.getLogger(DefaultApplicationSlaManagementService.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(DefaultApplicationSlaManagementService.class)", "var_name": "logger"}], "methods": [{"identifier": "DefaultApplicationSlaManagementService", "parameters": "(CapacityMonitoringService capacityMonitoringService,\n                                                  ApplicationSlaStore storage,\n                                                  ManagementSubsystemInitializer initializer)", "modifiers": "@Inject public", "return": "", "signature": " DefaultApplicationSlaManagementService(CapacityMonitoringService capacityMonitoringService,\n                                                  ApplicationSlaStore storage,\n                                                  ManagementSubsystemInitializer initializer)", "full_signature": "@Inject public  DefaultApplicationSlaManagementService(CapacityMonitoringService capacityMonitoringService,\n                                                  ApplicationSlaStore storage,\n                                                  ManagementSubsystemInitializer initializer)", "class_method_signature": "DefaultApplicationSlaManagementService.DefaultApplicationSlaManagementService(CapacityMonitoringService capacityMonitoringService,\n                                                  ApplicationSlaStore storage,\n                                                  ManagementSubsystemInitializer initializer)", "testcase": false, "constructor": true}, {"identifier": "getApplicationSLAs", "parameters": "()", "modifiers": "@Override public", "return": "Collection<ApplicationSLA>", "signature": "Collection<ApplicationSLA> getApplicationSLAs()", "full_signature": "@Override public Collection<ApplicationSLA> getApplicationSLAs()", "class_method_signature": "DefaultApplicationSlaManagementService.getApplicationSLAs()", "testcase": false, "constructor": false}, {"identifier": "getApplicationSLAsForScheduler", "parameters": "(String schedulerName)", "modifiers": "@Override public", "return": "Collection<ApplicationSLA>", "signature": "Collection<ApplicationSLA> getApplicationSLAsForScheduler(String schedulerName)", "full_signature": "@Override public Collection<ApplicationSLA> getApplicationSLAsForScheduler(String schedulerName)", "class_method_signature": "DefaultApplicationSlaManagementService.getApplicationSLAsForScheduler(String schedulerName)", "testcase": false, "constructor": false}, {"identifier": "findApplicationSLA", "parameters": "(String applicationName)", "modifiers": "@Override public", "return": "Optional<ApplicationSLA>", "signature": "Optional<ApplicationSLA> findApplicationSLA(String applicationName)", "full_signature": "@Override public Optional<ApplicationSLA> findApplicationSLA(String applicationName)", "class_method_signature": "DefaultApplicationSlaManagementService.findApplicationSLA(String applicationName)", "testcase": false, "constructor": false}, {"identifier": "getApplicationSLA", "parameters": "(String applicationName)", "modifiers": "@Override public", "return": "ApplicationSLA", "signature": "ApplicationSLA getApplicationSLA(String applicationName)", "full_signature": "@Override public ApplicationSLA getApplicationSLA(String applicationName)", "class_method_signature": "DefaultApplicationSlaManagementService.getApplicationSLA(String applicationName)", "testcase": false, "constructor": false}, {"identifier": "addApplicationSLA", "parameters": "(ApplicationSLA applicationSLA)", "modifiers": "@Override public", "return": "Observable<Void>", "signature": "Observable<Void> addApplicationSLA(ApplicationSLA applicationSLA)", "full_signature": "@Override public Observable<Void> addApplicationSLA(ApplicationSLA applicationSLA)", "class_method_signature": "DefaultApplicationSlaManagementService.addApplicationSLA(ApplicationSLA applicationSLA)", "testcase": false, "constructor": false}, {"identifier": "removeApplicationSLA", "parameters": "(String applicationName)", "modifiers": "@Override public", "return": "Observable<Void>", "signature": "Observable<Void> removeApplicationSLA(String applicationName)", "full_signature": "@Override public Observable<Void> removeApplicationSLA(String applicationName)", "class_method_signature": "DefaultApplicationSlaManagementService.removeApplicationSLA(String applicationName)", "testcase": false, "constructor": false}], "file": "titus-server-master/src/main/java/com/netflix/titus/master/service/management/internal/DefaultApplicationSlaManagementService.java"}, "focal_method": {"identifier": "removeApplicationSLA", "parameters": "(String applicationName)", "modifiers": "@Override public", "return": "Observable<Void>", "body": "@Override\n    public Observable<Void> removeApplicationSLA(String applicationName) {\n        if (applicationName.equals(DEFAULT_APPLICATION)) {\n            return Observable.error(new IllegalArgumentException(DEFAULT_APPLICATION + \" cannot be removed\"));\n        }\n        // We trigger refresh, but not wait for the result, as we only care that first part (remove) succeeded.\n        return storage.remove(applicationName).doOnCompleted(() -> capacityMonitoringService.refresh().subscribe());\n    }", "signature": "Observable<Void> removeApplicationSLA(String applicationName)", "full_signature": "@Override public Observable<Void> removeApplicationSLA(String applicationName)", "class_method_signature": "DefaultApplicationSlaManagementService.removeApplicationSLA(String applicationName)", "testcase": false, "constructor": false, "invocations": ["equals", "error", "doOnCompleted", "remove", "subscribe", "refresh"]}, "repository": {"repo_id": 107330274, "url": "https://github.com/Netflix/titus-control-plane", "stars": 241, "created": "10/17/2017 10:20:55 PM +00:00", "updates": "2020-01-25T13:01:05+00:00", "fork": "False", "license": "licensed"}}