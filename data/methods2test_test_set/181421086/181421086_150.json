{"test_class": {"identifier": "SingletonTaskTest", "superclass": "extends FloodlightTestCase", "interfaces": "", "fields": [{"original_string": "public int ran = 0;", "modifier": "public", "type": "int", "declarator": "ran = 0", "var_name": "ran"}, {"original_string": "public int finished = 0;", "modifier": "public", "type": "int", "declarator": "finished = 0", "var_name": "finished"}, {"original_string": "public long time = 0;", "modifier": "public", "type": "long", "declarator": "time = 0", "var_name": "time"}], "file": "src/agents/apps/floodlight/floodlight-1.2/src/test/java/net/floodlightcontroller/core/util/SingletonTaskTest.java"}, "test_case": {"identifier": "testConcurrentAddNoDelay", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testConcurrentAddNoDelay() throws InterruptedException {\n        ScheduledExecutorService ses =\n            Executors.newSingleThreadScheduledExecutor();\n\n        final Object tc = this;\n        SingletonTask st1 = new SingletonTask(ses, new Runnable() {\n            @Override\n            public void run() {\n                synchronized (tc) {\n                    ran += 1;\n                }\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n                synchronized (tc) {\n                    finished += 1;\n                    time = System.nanoTime();\n                }\n            }\n        });\n\n        st1.reschedule(0, null);\n        Thread.sleep(20);\n        assertEquals(\"Check that task started\", 1, ran);\n        assertEquals(\"Check that task not finished\", 0, finished);\n        st1.reschedule(0, null);\n        assertTrue(\"Check task running state true\", st1.context.taskRunning);\n        assertTrue(\"Check task should run state true\", st1.context.taskShouldRun);\n        assertEquals(\"Check that task started\", 1, ran);\n        assertEquals(\"Check that task not finished\", 0, finished);\n\n        Thread.sleep(150);\n\n        assertTrue(\"Check task running state false\", !st1.context.taskRunning);\n        assertTrue(\"Check task should run state false\", !st1.context.taskShouldRun);\n        assertEquals(\"Check that task ran exactly twice\", 2, ran);\n        assertEquals(\"Check that task finished exactly twice\", 2, finished);\n\n        ses.shutdown();\n        ses.awaitTermination(5, TimeUnit.SECONDS);\n    }", "signature": "void testConcurrentAddNoDelay()", "full_signature": "@Test public void testConcurrentAddNoDelay()", "class_method_signature": "SingletonTaskTest.testConcurrentAddNoDelay()", "testcase": true, "constructor": false, "invocations": ["newSingleThreadScheduledExecutor", "sleep", "printStackTrace", "nanoTime", "reschedule", "sleep", "assertEquals", "assertEquals", "reschedule", "assertTrue", "assertTrue", "assertEquals", "assertEquals", "sleep", "assertTrue", "assertTrue", "assertEquals", "assertEquals", "shutdown", "awaitTermination"]}, "focal_class": {"identifier": "SingletonTask", "superclass": "", "interfaces": "", "fields": [{"original_string": "protected static final Logger logger = LoggerFactory.getLogger(SingletonTask.class);", "modifier": "protected static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(SingletonTask.class)", "var_name": "logger"}, {"original_string": "protected SingletonTaskContext context = new SingletonTaskContext();", "modifier": "protected", "type": "SingletonTaskContext", "declarator": "context = new SingletonTaskContext()", "var_name": "context"}, {"original_string": "protected Runnable task;", "modifier": "protected", "type": "Runnable", "declarator": "task", "var_name": "task"}, {"original_string": "protected ScheduledExecutorService ses;", "modifier": "protected", "type": "ScheduledExecutorService", "declarator": "ses", "var_name": "ses"}], "methods": [{"identifier": "SingletonTask", "parameters": "(ScheduledExecutorService ses,\n            Runnable task)", "modifiers": "public", "return": "", "signature": " SingletonTask(ScheduledExecutorService ses,\n            Runnable task)", "full_signature": "public  SingletonTask(ScheduledExecutorService ses,\n            Runnable task)", "class_method_signature": "SingletonTask.SingletonTask(ScheduledExecutorService ses,\n            Runnable task)", "testcase": false, "constructor": true}, {"identifier": "reschedule", "parameters": "(long delay, TimeUnit unit)", "modifiers": "public", "return": "void", "signature": "void reschedule(long delay, TimeUnit unit)", "full_signature": "public void reschedule(long delay, TimeUnit unit)", "class_method_signature": "SingletonTask.reschedule(long delay, TimeUnit unit)", "testcase": false, "constructor": false}], "file": "src/agents/apps/floodlight/floodlight-1.2/src/main/java/net/floodlightcontroller/core/util/SingletonTask.java"}, "focal_method": {"identifier": "reschedule", "parameters": "(long delay, TimeUnit unit)", "modifiers": "public", "return": "void", "body": "public void reschedule(long delay, TimeUnit unit) {\n        boolean needQueue = true;\n        SingletonTaskWorker stw = null;\n\n        synchronized (context) {\n            if (context.taskRunning || context.taskShouldRun) {\n                if (context.taskRunning) {\n                    // schedule to restart at the right time\n                    if (delay > 0) {\n                        long now = System.nanoTime();\n                        long then = now + TimeUnit.NANOSECONDS.convert(delay, unit);\n                        context.waitingTask.nextschedule = then;\n                        logger.debug(\"rescheduled task \" + this + \" for \" + TimeUnit.SECONDS.convert(then, TimeUnit.NANOSECONDS) + \"s. A bunch of these messages -may- indicate you have a blocked task.\");\n                    } else {\n                        context.waitingTask.nextschedule = 0;\n                    }\n                    needQueue = false;\n                } else {\n                    // cancel and requeue\n                    context.waitingTask.canceled = true;\n                    context.waitingTask = null;\n                }\n            }\n\n            context.taskShouldRun = true;\n\n            if (needQueue) {\n                stw = context.waitingTask = new SingletonTaskWorker(this);                    \n            }\n        }\n\n        if (needQueue) {\n            if (delay <= 0) {\n                ses.execute(stw);\n            } else {\n                ses.schedule(stw, delay, unit);\n            }\n        }\n    }", "signature": "void reschedule(long delay, TimeUnit unit)", "full_signature": "public void reschedule(long delay, TimeUnit unit)", "class_method_signature": "SingletonTask.reschedule(long delay, TimeUnit unit)", "testcase": false, "constructor": false, "invocations": ["nanoTime", "convert", "debug", "convert", "execute", "schedule"]}, "repository": {"repo_id": 181421086, "url": "https://github.com/seungsoo-lee/DELTA", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 35, "size": 99244, "license": "licensed"}}