{"test_class": {"identifier": "TextUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "orbisgis-commons/src/test/java/org/orbisgis/commons/utils/TextUtilsTest.java"}, "test_case": {"identifier": "testSimilarToPattern", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n        public void testSimilarToPattern() {\n                Pattern p = TextUtils.buildSimilarToPattern(\"st[ra]_+8\");\n                match(p, \"str%aa8\");\n                match(p, \"str%ab8\");\n                notMatch(p, \"sta8\");\n        }", "signature": "void testSimilarToPattern()", "full_signature": "@Test public void testSimilarToPattern()", "class_method_signature": "TextUtilsTest.testSimilarToPattern()", "testcase": true, "constructor": false, "invocations": ["buildSimilarToPattern", "match", "match", "notMatch"]}, "focal_class": {"identifier": "TextUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Pattern SPLITLIKE = Pattern.compile(\"%|_\");", "modifier": "private static final", "type": "Pattern", "declarator": "SPLITLIKE = Pattern.compile(\"%|_\")", "var_name": "SPLITLIKE"}, {"original_string": "private static final Pattern ESCAPE = Pattern.compile(\"\\\\\\\\\\\\\\\\\");", "modifier": "private static final", "type": "Pattern", "declarator": "ESCAPE = Pattern.compile(\"\\\\\\\\\\\\\\\\\")", "var_name": "ESCAPE"}, {"original_string": "private static final Pattern DOT = Pattern.compile(\"\\\\.\");", "modifier": "private static final", "type": "Pattern", "declarator": "DOT = Pattern.compile(\"\\\\.\")", "var_name": "DOT"}], "methods": [{"identifier": "getEolStr", "parameters": "()", "modifiers": "public static", "return": "String", "signature": "String getEolStr()", "full_signature": "public static String getEolStr()", "class_method_signature": "TextUtils.getEolStr()", "testcase": false, "constructor": false}, {"identifier": "stringToHTMLString", "parameters": "(String string)", "modifiers": "public static", "return": "String", "signature": "String stringToHTMLString(String string)", "full_signature": "public static String stringToHTMLString(String string)", "class_method_signature": "TextUtils.stringToHTMLString(String string)", "testcase": false, "constructor": false}, {"identifier": "getLocation", "parameters": "(int bl, int bc, int el, int ec,\n                String[] lines)", "modifiers": "public static", "return": "int[]", "signature": "int[] getLocation(int bl, int bc, int el, int ec,\n                String[] lines)", "full_signature": "public static int[] getLocation(int bl, int bc, int el, int ec,\n                String[] lines)", "class_method_signature": "TextUtils.getLocation(int bl, int bc, int el, int ec,\n                String[] lines)", "testcase": false, "constructor": false}, {"identifier": "getPosition", "parameters": "(int line, int column, String[] lines)", "modifiers": "private static", "return": "int", "signature": "int getPosition(int line, int column, String[] lines)", "full_signature": "private static int getPosition(int line, int column, String[] lines)", "class_method_signature": "TextUtils.getPosition(int line, int column, String[] lines)", "testcase": false, "constructor": false}, {"identifier": "buildLikePattern", "parameters": "(String pattern)", "modifiers": "public static", "return": "Pattern", "signature": "Pattern buildLikePattern(String pattern)", "full_signature": "public static Pattern buildLikePattern(String pattern)", "class_method_signature": "TextUtils.buildLikePattern(String pattern)", "testcase": false, "constructor": false}, {"identifier": "buildLikePattern", "parameters": "(String pattern, boolean caseInsensitive)", "modifiers": "public static", "return": "Pattern", "signature": "Pattern buildLikePattern(String pattern, boolean caseInsensitive)", "full_signature": "public static Pattern buildLikePattern(String pattern, boolean caseInsensitive)", "class_method_signature": "TextUtils.buildLikePattern(String pattern, boolean caseInsensitive)", "testcase": false, "constructor": false}, {"identifier": "buildSimilarToPattern", "parameters": "(String pattern)", "modifiers": "public static", "return": "Pattern", "signature": "Pattern buildSimilarToPattern(String pattern)", "full_signature": "public static Pattern buildSimilarToPattern(String pattern)", "class_method_signature": "TextUtils.buildSimilarToPattern(String pattern)", "testcase": false, "constructor": false}, {"identifier": "TextUtils", "parameters": "()", "modifiers": "private", "return": "", "signature": " TextUtils()", "full_signature": "private  TextUtils()", "class_method_signature": "TextUtils.TextUtils()", "testcase": false, "constructor": true}], "file": "orbisgis-commons/src/main/java/org/orbisgis/commons/utils/TextUtils.java"}, "focal_method": {"identifier": "buildSimilarToPattern", "parameters": "(String pattern)", "modifiers": "public static", "return": "Pattern", "body": "public static Pattern buildSimilarToPattern(String pattern) {\n                String[] s = SPLITLIKE.split(pattern);\n                StringBuilder b = new StringBuilder();\n                b.append(\"^\");\n                if (s.length == 0) {\n                        for (int i = 0; i < pattern.length(); i++) {\n                                switch (pattern.charAt(i)) {\n                                        case '%':\n                                                b.append(\".*\");\n                                                break;\n                                        case '_':\n                                                b.append(\".\");\n                                                break;\n                                        default:\n                                }\n                        }\n                } else {\n                        int pos = 0;\n                        for (int i = 0; i < s.length; i++) {\n                                boolean esc = false;\n                                if (s[i].endsWith(\"\\\\\")) {\n                                        pos++;\n                                        if (i + 1 < s.length) {\n                                                s[i + 1] = s[i].substring(0, s[i].length() - 1) + pattern.charAt(pos + s[i].length() - 1) + s[i + 1];\n                                                continue;\n                                        } else {\n                                                s[i] = s[i].substring(0, s[i].length() - 1);\n                                                esc = true;\n                                        }\n                                }\n                                if (!s[i].isEmpty()) {\n                                        String t = ESCAPE.matcher(s[i]).replaceAll(\"\\\\\\\\\");\n                                        b.append(DOT.matcher(t).replaceAll(\"\\\\\\\\.\"));\n                                        pos += s[i].length();\n                                }\n                                if (pos < pattern.length()) {\n                                        switch (pattern.charAt(pos)) {\n                                                case '%':\n                                                        if (esc) {\n                                                                b.append(\"%\");\n                                                        } else {\n                                                                b.append(\".*\");\n                                                        }\n                                                        pos++;\n                                                        break;\n                                                case '_':\n                                                        if (esc) {\n                                                                b.append(\"_\");\n                                                        } else {\n                                                                b.append(\".\");\n                                                        }\n                                                        pos++;\n                                                        break;\n                                                default:\n                                        }\n                                }\n                        }\n                        while (pos < pattern.length()) {\n                                switch (pattern.charAt(pos)) {\n                                        case '%':\n                                                b.append(\".*\");\n                                                pos++;\n                                                break;\n                                        case '_':\n                                                b.append(\".\");\n                                                pos++;\n                                                break;\n                                        default:\n                                }\n                        }\n                }\n                b.append(\"$\");\n                return Pattern.compile(b.toString());\n        }", "signature": "Pattern buildSimilarToPattern(String pattern)", "full_signature": "public static Pattern buildSimilarToPattern(String pattern)", "class_method_signature": "TextUtils.buildSimilarToPattern(String pattern)", "testcase": false, "constructor": false, "invocations": ["split", "append", "length", "charAt", "append", "append", "endsWith", "substring", "length", "charAt", "length", "substring", "length", "isEmpty", "replaceAll", "matcher", "append", "replaceAll", "matcher", "length", "length", "charAt", "append", "append", "append", "append", "length", "charAt", "append", "append", "append", "compile", "toString"]}, "repository": {"repo_id": 4735878, "url": "https://github.com/orbisgis/orbisgis", "language": "Java", "is_fork": false, "fork_count": 37, "stargazer_count": 63, "size": 76463, "license": "licensed"}}