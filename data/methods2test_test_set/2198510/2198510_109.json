{"test_class": {"identifier": "TestNettyAvroRpcClient", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory\n      .getLogger(TestNettyAvroRpcClient.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory\n      .getLogger(TestNettyAvroRpcClient.class)", "var_name": "logger"}, {"original_string": "private static final String localhost = \"127.0.0.1\";", "modifier": "private static final", "type": "String", "declarator": "localhost = \"127.0.0.1\"", "var_name": "localhost"}], "file": "flume-ng-sdk/src/test/java/org/apache/flume/api/TestNettyAvroRpcClient.java"}, "test_case": {"identifier": "testUnableToConnect", "parameters": "()", "modifiers": "@Test(expected = FlumeException.class) public", "return": "void", "body": "@Test(expected = FlumeException.class)\n  public void testUnableToConnect() throws FlumeException {\n    @SuppressWarnings(\"unused\")\n    NettyAvroRpcClient client = new NettyAvroRpcClient();\n    Properties props = new Properties();\n    props.setProperty(RpcClientConfigurationConstants.CONFIG_HOSTS, \"localhost\");\n    props.setProperty(RpcClientConfigurationConstants.CONFIG_HOSTS_PREFIX + \"localhost\",\n        localhost + \":\" + 1);\n    client.configure(props);\n  }", "signature": "void testUnableToConnect()", "full_signature": "@Test(expected = FlumeException.class) public void testUnableToConnect()", "class_method_signature": "TestNettyAvroRpcClient.testUnableToConnect()", "testcase": true, "constructor": false, "invocations": ["setProperty", "setProperty", "configure"]}, "focal_class": {"identifier": "NettyAvroRpcClient", "superclass": "extends SSLContextAwareAbstractRpcClient", "interfaces": "", "fields": [{"original_string": "private ExecutorService callTimeoutPool;", "modifier": "private", "type": "ExecutorService", "declarator": "callTimeoutPool", "var_name": "callTimeoutPool"}, {"original_string": "private final ReentrantLock stateLock = new ReentrantLock();", "modifier": "private final", "type": "ReentrantLock", "declarator": "stateLock = new ReentrantLock()", "var_name": "stateLock"}, {"original_string": "private ConnState connState;", "modifier": "private", "type": "ConnState", "declarator": "connState", "var_name": "connState"}, {"original_string": "private InetSocketAddress address;", "modifier": "private", "type": "InetSocketAddress", "declarator": "address", "var_name": "address"}, {"original_string": "private Transceiver transceiver;", "modifier": "private", "type": "Transceiver", "declarator": "transceiver", "var_name": "transceiver"}, {"original_string": "private AvroSourceProtocol.Callback avroClient;", "modifier": "private", "type": "AvroSourceProtocol.Callback", "declarator": "avroClient", "var_name": "avroClient"}, {"original_string": "private static final Logger logger = LoggerFactory\n      .getLogger(NettyAvroRpcClient.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory\n      .getLogger(NettyAvroRpcClient.class)", "var_name": "logger"}, {"original_string": "private boolean enableDeflateCompression;", "modifier": "private", "type": "boolean", "declarator": "enableDeflateCompression", "var_name": "enableDeflateCompression"}, {"original_string": "private int compressionLevel;", "modifier": "private", "type": "int", "declarator": "compressionLevel", "var_name": "compressionLevel"}, {"original_string": "private int maxIoWorkers;", "modifier": "private", "type": "int", "declarator": "maxIoWorkers", "var_name": "maxIoWorkers"}], "methods": [{"identifier": "NettyAvroRpcClient", "parameters": "()", "modifiers": "protected", "return": "", "signature": " NettyAvroRpcClient()", "full_signature": "protected  NettyAvroRpcClient()", "class_method_signature": "NettyAvroRpcClient.NettyAvroRpcClient()", "testcase": false, "constructor": true}, {"identifier": "connect", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void connect()", "full_signature": "private void connect()", "class_method_signature": "NettyAvroRpcClient.connect()", "testcase": false, "constructor": false}, {"identifier": "connect", "parameters": "(long timeout, TimeUnit tu)", "modifiers": "private", "return": "void", "signature": "void connect(long timeout, TimeUnit tu)", "full_signature": "private void connect(long timeout, TimeUnit tu)", "class_method_signature": "NettyAvroRpcClient.connect(long timeout, TimeUnit tu)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "NettyAvroRpcClient.close()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "NettyAvroRpcClient.toString()", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(Event event)", "modifiers": "@Override public", "return": "void", "signature": "void append(Event event)", "full_signature": "@Override public void append(Event event)", "class_method_signature": "NettyAvroRpcClient.append(Event event)", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(Event event, long timeout, TimeUnit tu)", "modifiers": "private", "return": "void", "signature": "void append(Event event, long timeout, TimeUnit tu)", "full_signature": "private void append(Event event, long timeout, TimeUnit tu)", "class_method_signature": "NettyAvroRpcClient.append(Event event, long timeout, TimeUnit tu)", "testcase": false, "constructor": false}, {"identifier": "appendBatch", "parameters": "(List<Event> events)", "modifiers": "@Override public", "return": "void", "signature": "void appendBatch(List<Event> events)", "full_signature": "@Override public void appendBatch(List<Event> events)", "class_method_signature": "NettyAvroRpcClient.appendBatch(List<Event> events)", "testcase": false, "constructor": false}, {"identifier": "appendBatch", "parameters": "(List<Event> events, long timeout, TimeUnit tu)", "modifiers": "private", "return": "void", "signature": "void appendBatch(List<Event> events, long timeout, TimeUnit tu)", "full_signature": "private void appendBatch(List<Event> events, long timeout, TimeUnit tu)", "class_method_signature": "NettyAvroRpcClient.appendBatch(List<Event> events, long timeout, TimeUnit tu)", "testcase": false, "constructor": false}, {"identifier": "waitForStatusOK", "parameters": "(CallFuture<Status> callFuture,\n      long timeout, TimeUnit tu)", "modifiers": "private", "return": "void", "signature": "void waitForStatusOK(CallFuture<Status> callFuture,\n      long timeout, TimeUnit tu)", "full_signature": "private void waitForStatusOK(CallFuture<Status> callFuture,\n      long timeout, TimeUnit tu)", "class_method_signature": "NettyAvroRpcClient.waitForStatusOK(CallFuture<Status> callFuture,\n      long timeout, TimeUnit tu)", "testcase": false, "constructor": false}, {"identifier": "setState", "parameters": "(ConnState newState)", "modifiers": "private", "return": "void", "signature": "void setState(ConnState newState)", "full_signature": "private void setState(ConnState newState)", "class_method_signature": "NettyAvroRpcClient.setState(ConnState newState)", "testcase": false, "constructor": false}, {"identifier": "assertReady", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void assertReady()", "full_signature": "private void assertReady()", "class_method_signature": "NettyAvroRpcClient.assertReady()", "testcase": false, "constructor": false}, {"identifier": "toCharSeqMap", "parameters": "(\n      Map<String, String> stringMap)", "modifiers": "private static", "return": "Map<CharSequence, CharSequence>", "signature": "Map<CharSequence, CharSequence> toCharSeqMap(\n      Map<String, String> stringMap)", "full_signature": "private static Map<CharSequence, CharSequence> toCharSeqMap(\n      Map<String, String> stringMap)", "class_method_signature": "NettyAvroRpcClient.toCharSeqMap(\n      Map<String, String> stringMap)", "testcase": false, "constructor": false}, {"identifier": "isActive", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isActive()", "full_signature": "@Override public boolean isActive()", "class_method_signature": "NettyAvroRpcClient.isActive()", "testcase": false, "constructor": false}, {"identifier": "configure", "parameters": "(Properties properties)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void configure(Properties properties)", "full_signature": "@Override public synchronized void configure(Properties properties)", "class_method_signature": "NettyAvroRpcClient.configure(Properties properties)", "testcase": false, "constructor": false}], "file": "flume-ng-sdk/src/main/java/org/apache/flume/api/NettyAvroRpcClient.java"}, "focal_method": {"identifier": "configure", "parameters": "(Properties properties)", "modifiers": "@Override public synchronized", "return": "void", "body": "@Override\n  public synchronized void configure(Properties properties)\n      throws FlumeException {\n    stateLock.lock();\n    try {\n      if (connState == ConnState.READY || connState == ConnState.DEAD) {\n        throw new FlumeException(\"This client was already configured, \" +\n            \"cannot reconfigure.\");\n      }\n    } finally {\n      stateLock.unlock();\n    }\n\n    batchSize = parseBatchSize(properties);\n\n    // host and port\n    String hostNames = properties.getProperty(\n        RpcClientConfigurationConstants.CONFIG_HOSTS);\n    String[] hosts = null;\n    if (hostNames != null && !hostNames.isEmpty()) {\n      hosts = hostNames.split(\"\\\\s+\");\n    } else {\n      throw new FlumeException(\"Hosts list is invalid: \" + hostNames);\n    }\n\n    if (hosts.length > 1) {\n      logger.warn(\"More than one hosts are specified for the default client. \"\n          + \"Only the first host will be used and others ignored. Specified: \"\n          + hostNames + \"; to be used: \" + hosts[0]);\n    }\n\n    String host = properties.getProperty(\n        RpcClientConfigurationConstants.CONFIG_HOSTS_PREFIX + hosts[0]);\n    if (host == null || host.isEmpty()) {\n      throw new FlumeException(\"Host not found: \" + hosts[0]);\n    }\n    String[] hostAndPort = host.split(\":\");\n    if (hostAndPort.length != 2) {\n      throw new FlumeException(\"Invalid hostname: \" + hosts[0]);\n    }\n    Integer port = null;\n    try {\n      port = Integer.parseInt(hostAndPort[1]);\n    } catch (NumberFormatException e) {\n      throw new FlumeException(\"Invalid Port: \" + hostAndPort[1], e);\n    }\n    this.address = new InetSocketAddress(hostAndPort[0], port);\n\n    // connect timeout\n    connectTimeout =\n        RpcClientConfigurationConstants.DEFAULT_CONNECT_TIMEOUT_MILLIS;\n    String strConnTimeout = properties.getProperty(\n        RpcClientConfigurationConstants.CONFIG_CONNECT_TIMEOUT);\n    if (strConnTimeout != null && strConnTimeout.trim().length() > 0) {\n      try {\n        connectTimeout = Long.parseLong(strConnTimeout);\n        if (connectTimeout < 1000) {\n          logger.warn(\"Connection timeout specified less than 1s. \" +\n              \"Using default value instead.\");\n          connectTimeout =\n              RpcClientConfigurationConstants.DEFAULT_CONNECT_TIMEOUT_MILLIS;\n        }\n      } catch (NumberFormatException ex) {\n        logger.error(\"Invalid connect timeout specified: \" + strConnTimeout);\n      }\n    }\n\n    // request timeout\n    requestTimeout =\n        RpcClientConfigurationConstants.DEFAULT_REQUEST_TIMEOUT_MILLIS;\n    String strReqTimeout = properties.getProperty(\n        RpcClientConfigurationConstants.CONFIG_REQUEST_TIMEOUT);\n    if  (strReqTimeout != null && strReqTimeout.trim().length() > 0) {\n      try {\n        requestTimeout = Long.parseLong(strReqTimeout);\n        if (requestTimeout < 1000) {\n          logger.warn(\"Request timeout specified less than 1s. \" +\n              \"Using default value instead.\");\n          requestTimeout =\n              RpcClientConfigurationConstants.DEFAULT_REQUEST_TIMEOUT_MILLIS;\n        }\n      } catch (NumberFormatException ex) {\n        logger.error(\"Invalid request timeout specified: \" + strReqTimeout);\n      }\n    }\n\n    String enableCompressionStr =\n        properties.getProperty(RpcClientConfigurationConstants.CONFIG_COMPRESSION_TYPE);\n    if (enableCompressionStr != null && enableCompressionStr.equalsIgnoreCase(\"deflate\")) {\n      this.enableDeflateCompression = true;\n      String compressionLvlStr =\n          properties.getProperty(RpcClientConfigurationConstants.CONFIG_COMPRESSION_LEVEL);\n      compressionLevel = RpcClientConfigurationConstants.DEFAULT_COMPRESSION_LEVEL;\n      if (compressionLvlStr != null) {\n        try {\n          compressionLevel = Integer.parseInt(compressionLvlStr);\n        } catch (NumberFormatException ex) {\n          logger.error(\"Invalid compression level: \" + compressionLvlStr);\n        }\n      }\n    }\n\n    configureSSL(properties);\n\n    String maxIoWorkersStr = properties.getProperty(RpcClientConfigurationConstants.MAX_IO_WORKERS);\n    if (!StringUtils.isEmpty(maxIoWorkersStr)) {\n      try {\n        maxIoWorkers = Integer.parseInt(maxIoWorkersStr);\n      } catch (NumberFormatException ex) {\n        logger.warn(\"Invalid maxIOWorkers:\" + maxIoWorkersStr + \" Using \" +\n            \"default maxIOWorkers.\");\n        maxIoWorkers = -1;\n      }\n    }\n\n    if (maxIoWorkers < 1) {\n      logger.info(\"Using default maxIOWorkers\");\n      maxIoWorkers = -1;\n    }\n\n    this.connect();\n  }", "signature": "void configure(Properties properties)", "full_signature": "@Override public synchronized void configure(Properties properties)", "class_method_signature": "NettyAvroRpcClient.configure(Properties properties)", "testcase": false, "constructor": false, "invocations": ["lock", "unlock", "parseBatchSize", "getProperty", "isEmpty", "split", "warn", "getProperty", "isEmpty", "split", "parseInt", "getProperty", "length", "trim", "parseLong", "warn", "error", "getProperty", "length", "trim", "parseLong", "warn", "error", "getProperty", "equalsIgnoreCase", "getProperty", "parseInt", "error", "configureSSL", "getProperty", "isEmpty", "parseInt", "warn", "info", "connect"]}, "repository": {"repo_id": 2198510, "url": "https://github.com/apache/flume", "language": "Java", "is_fork": false, "fork_count": 1372, "stargazer_count": 1971, "size": 44377, "license": "licensed"}}