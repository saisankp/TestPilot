{"test_class": {"identifier": "KTableKTableOuterJoinTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "final private String topic1 = \"topic1\";", "modifier": "final private", "type": "String", "declarator": "topic1 = \"topic1\"", "var_name": "topic1"}, {"original_string": "final private String topic2 = \"topic2\";", "modifier": "final private", "type": "String", "declarator": "topic2 = \"topic2\"", "var_name": "topic2"}, {"original_string": "final private Serde<Integer> intSerde = Serdes.Integer();", "modifier": "final private", "type": "Serde<Integer>", "declarator": "intSerde = Serdes.Integer()", "var_name": "intSerde"}, {"original_string": "final private Serde<String> stringSerde = Serdes.String();", "modifier": "final private", "type": "Serde<String>", "declarator": "stringSerde = Serdes.String()", "var_name": "stringSerde"}, {"original_string": "private KStreamTestDriver driver = null;", "modifier": "private", "type": "KStreamTestDriver", "declarator": "driver = null", "var_name": "driver"}, {"original_string": "private File stateDir = null;", "modifier": "private", "type": "File", "declarator": "stateDir = null", "var_name": "stateDir"}], "file": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoinTest.java"}, "test_case": {"identifier": "testJoin", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testJoin() throws Exception {\n        KStreamBuilder builder = new KStreamBuilder();\n\n        final int[] expectedKeys = new int[]{0, 1, 2, 3};\n\n        KTable<Integer, String> table1;\n        KTable<Integer, String> table2;\n        KTable<Integer, String> joined;\n        MockProcessorSupplier<Integer, String> processor;\n\n        processor = new MockProcessorSupplier<>();\n        table1 = builder.table(intSerde, stringSerde, topic1);\n        table2 = builder.table(intSerde, stringSerde, topic2);\n        joined = table1.outerJoin(table2, MockValueJoiner.STRING_JOINER);\n        joined.toStream().process(processor);\n\n        Collection<Set<String>> copartitionGroups = builder.copartitionGroups();\n\n        assertEquals(1, copartitionGroups.size());\n        assertEquals(new HashSet<>(Arrays.asList(topic1, topic2)), copartitionGroups.iterator().next());\n\n        KTableValueGetterSupplier<Integer, String> getterSupplier = ((KTableImpl<Integer, String, String>) joined).valueGetterSupplier();\n\n        driver = new KStreamTestDriver(builder, stateDir);\n        driver.setTime(0L);\n\n        KTableValueGetter<Integer, String> getter = getterSupplier.get();\n        getter.init(driver.context());\n\n        // push two items to the primary stream. the other table is empty\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, null), kv(3, null));\n\n        // push two items to the other stream. this should produce two items.\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], \"Y\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, null), kv(3, null));\n\n        // push all four items to the primary stream. this should produce four items.\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+Y0\", \"1:X1+Y1\", \"2:X2+null\", \"3:X3+null\");\n        checkJoinedValues(getter, kv(0, \"X0+Y0\"), kv(1, \"X1+Y1\"), kv(2, \"X2+null\"), kv(3, \"X3+null\"));\n\n        // push all items to the other stream. this should produce four items.\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic2, expectedKeys[i], \"YY\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        // push all four items to the primary stream. this should produce four items.\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"X\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+YY0\", \"1:X1+YY1\", \"2:X2+YY2\", \"3:X3+YY3\");\n        checkJoinedValues(getter, kv(0, \"X0+YY0\"), kv(1, \"X1+YY1\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        // push two items with null to the other stream as deletes. this should produce two item.\n\n        for (int i = 0; i < 2; i++) {\n            driver.process(topic2, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"0:X0+null\", \"1:X1+null\");\n        checkJoinedValues(getter, kv(0, \"X0+null\"), kv(1, \"X1+null\"), kv(2, \"X2+YY2\"), kv(3, \"X3+YY3\"));\n\n        // push all four items to the primary stream. this should produce four items.\n\n        for (int i = 0; i < expectedKeys.length; i++) {\n            driver.process(topic1, expectedKeys[i], \"XX\" + expectedKeys[i]);\n        }\n\n        processor.checkAndClearProcessResult(\"0:XX0+null\", \"1:XX1+null\", \"2:XX2+YY2\", \"3:XX3+YY3\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, \"XX1+null\"), kv(2, \"XX2+YY2\"), kv(3, \"XX3+YY3\"));\n\n        // push middle two items to the primary stream with null. this should produce two items.\n\n        for (int i = 1; i < 3; i++) {\n            driver.process(topic1, expectedKeys[i], null);\n        }\n\n        processor.checkAndClearProcessResult(\"1:null\", \"2:null+YY2\");\n        checkJoinedValues(getter, kv(0, \"XX0+null\"), kv(1, null), kv(2, \"null+YY2\"), kv(3, \"XX3+YY3\"));\n    }", "signature": "void testJoin()", "full_signature": "@Test public void testJoin()", "class_method_signature": "KTableKTableOuterJoinTest.testJoin()", "testcase": true, "constructor": false, "invocations": ["table", "table", "outerJoin", "process", "toStream", "copartitionGroups", "assertEquals", "size", "assertEquals", "asList", "next", "iterator", "valueGetterSupplier", "setTime", "get", "init", "context", "process", "checkAndClearProcessResult", "checkJoinedValues", "kv", "kv", "kv", "kv", "process", "checkAndClearProcessResult", "checkJoinedValues", "kv", "kv", "kv", "kv", "process", "checkAndClearProcessResult", "checkJoinedValues", "kv", "kv", "kv", "kv", "process", "checkAndClearProcessResult", "checkJoinedValues", "kv", "kv", "kv", "kv", "process", "checkAndClearProcessResult", "checkJoinedValues", "kv", "kv", "kv", "kv", "process", "checkAndClearProcessResult", "checkJoinedValues", "kv", "kv", "kv", "kv", "process", "checkAndClearProcessResult", "checkJoinedValues", "kv", "kv", "kv", "kv", "process", "checkAndClearProcessResult", "checkJoinedValues", "kv", "kv", "kv", "kv"]}, "focal_class": {"identifier": "KTableKTableOuterJoin", "superclass": "extends KTableKTableAbstractJoin<K, R, V1, V2>", "interfaces": "", "fields": [], "methods": [{"identifier": "KTableKTableOuterJoin", "parameters": "(KTableImpl<K, ?, V1> table1, KTableImpl<K, ?, V2> table2, ValueJoiner<V1, V2, R> joiner)", "modifiers": "", "return": "", "signature": " KTableKTableOuterJoin(KTableImpl<K, ?, V1> table1, KTableImpl<K, ?, V2> table2, ValueJoiner<V1, V2, R> joiner)", "full_signature": "  KTableKTableOuterJoin(KTableImpl<K, ?, V1> table1, KTableImpl<K, ?, V2> table2, ValueJoiner<V1, V2, R> joiner)", "class_method_signature": "KTableKTableOuterJoin.KTableKTableOuterJoin(KTableImpl<K, ?, V1> table1, KTableImpl<K, ?, V2> table2, ValueJoiner<V1, V2, R> joiner)", "testcase": false, "constructor": true}, {"identifier": "get", "parameters": "()", "modifiers": "@Override public", "return": "Processor<K, Change<V1>>", "signature": "Processor<K, Change<V1>> get()", "full_signature": "@Override public Processor<K, Change<V1>> get()", "class_method_signature": "KTableKTableOuterJoin.get()", "testcase": false, "constructor": false}, {"identifier": "view", "parameters": "()", "modifiers": "@Override public", "return": "KTableValueGetterSupplier<K, R>", "signature": "KTableValueGetterSupplier<K, R> view()", "full_signature": "@Override public KTableValueGetterSupplier<K, R> view()", "class_method_signature": "KTableKTableOuterJoin.view()", "testcase": false, "constructor": false}], "file": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableKTableOuterJoin.java"}, "focal_method": {"identifier": "get", "parameters": "()", "modifiers": "@Override public", "return": "Processor<K, Change<V1>>", "body": "@Override\n    public Processor<K, Change<V1>> get() {\n        return new KTableKTableOuterJoinProcessor(valueGetterSupplier2.get());\n    }", "signature": "Processor<K, Change<V1>> get()", "full_signature": "@Override public Processor<K, Change<V1>> get()", "class_method_signature": "KTableKTableOuterJoin.get()", "testcase": false, "constructor": false, "invocations": ["get"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}