{"test_class": {"identifier": "EJBTimerSchedulerTest", "superclass": "", "interfaces": "", "fields": [], "file": "jbpm-services/jbpm-services-ejb/jbpm-services-ejb-timer/src/test/java/org/jbpm/services/ejb/timer/EJBTimerSchedulerTest.java"}, "test_case": {"identifier": "testEjbTimerSchedulerTestOnTimerLoop", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testEjbTimerSchedulerTestOnTimerLoop() {\n        \n        Collection<Timer> timers = new ArrayList<>();\n        \n        TimerService timerService = mock(TimerService.class);\n        when(timerService.getTimers()).thenReturn(timers);\n        \n        TimerJobInstance timerJobInstance1 = mock(TimerJobInstance.class);\n        EjbGlobalJobHandle ejbGlobalJobHandle1 = new EjbGlobalJobHandle(1L, \"test job\", \"test\");\n        ejbGlobalJobHandle1.setTimerJobInstance(timerJobInstance1);\n        when(timerJobInstance1.getJobHandle()).thenReturn(ejbGlobalJobHandle1);\n        \n        Timer timer1 = mock(Timer.class);\n        when(timer1.getInfo()).thenReturn(new EjbTimerJob(timerJobInstance1));\n        \n        timers.add(timer1);\n        \n        EJBTimerScheduler scheduler = new EJBTimerScheduler();\n        scheduler.timerService = timerService;\n        // first call to go over list of timers should not add anything to the cache as there is no matching timers\n        TimerJobInstance jobInstance = scheduler.getTimerByName(\"not existing\");\n        assertNull(jobInstance);\n        // second call should result in exact same behavior\n        jobInstance = scheduler.getTimerByName(\"not existing\");\n        assertNull(jobInstance);\n        // calling for existing timer should return it as it matches and thus also add it to cache\n        jobInstance = scheduler.getTimerByName(\"test job\");\n        assertNotNull(jobInstance);\n    }", "signature": "void testEjbTimerSchedulerTestOnTimerLoop()", "full_signature": "@Test public void testEjbTimerSchedulerTestOnTimerLoop()", "class_method_signature": "EJBTimerSchedulerTest.testEjbTimerSchedulerTestOnTimerLoop()", "testcase": true, "constructor": false, "invocations": ["mock", "thenReturn", "when", "getTimers", "mock", "setTimerJobInstance", "thenReturn", "when", "getJobHandle", "mock", "thenReturn", "when", "getInfo", "add", "getTimerByName", "assertNull", "getTimerByName", "assertNull", "getTimerByName", "assertNotNull"]}, "focal_class": {"identifier": "EJBTimerScheduler", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(EJBTimerScheduler.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(EJBTimerScheduler.class)", "var_name": "logger"}, {"original_string": "private static final Long TIMER_RETRY_INTERVAL = Long.parseLong(System.getProperty(\"org.kie.jbpm.timer.retry.interval\", \"5000\"));", "modifier": "private static final", "type": "Long", "declarator": "TIMER_RETRY_INTERVAL = Long.parseLong(System.getProperty(\"org.kie.jbpm.timer.retry.interval\", \"5000\"))", "var_name": "TIMER_RETRY_INTERVAL"}, {"original_string": "private static final Integer TIMER_RETRY_LIMIT = Integer.parseInt(System.getProperty(\"org.kie.jbpm.timer.retry.limit\", \"3\"));", "modifier": "private static final", "type": "Integer", "declarator": "TIMER_RETRY_LIMIT = Integer.parseInt(System.getProperty(\"org.kie.jbpm.timer.retry.limit\", \"3\"))", "var_name": "TIMER_RETRY_LIMIT"}, {"original_string": "private static final TimerExceptionPolicy TIMER_RETRY_POLICY = Enum.valueOf(TimerExceptionPolicy.class, System.getProperty(\"org.kie.jbpm.timer.retry.policy\", \"PLATFORM\"));", "modifier": "private static final", "type": "TimerExceptionPolicy", "declarator": "TIMER_RETRY_POLICY = Enum.valueOf(TimerExceptionPolicy.class, System.getProperty(\"org.kie.jbpm.timer.retry.policy\", \"PLATFORM\"))", "var_name": "TIMER_RETRY_POLICY"}, {"original_string": "private static final Integer OVERDUE_WAIT_TIME = Integer.parseInt(System.getProperty(\"org.jbpm.overdue.timer.wait\", \"20000\"));", "modifier": "private static final", "type": "Integer", "declarator": "OVERDUE_WAIT_TIME = Integer.parseInt(System.getProperty(\"org.jbpm.overdue.timer.wait\", \"20000\"))", "var_name": "OVERDUE_WAIT_TIME"}, {"original_string": "private static final boolean USE_LOCAL_CACHE = Boolean.parseBoolean(System.getProperty(\"org.jbpm.ejb.timer.local.cache\", \"true\"));", "modifier": "private static final", "type": "boolean", "declarator": "USE_LOCAL_CACHE = Boolean.parseBoolean(System.getProperty(\"org.jbpm.ejb.timer.local.cache\", \"true\"))", "var_name": "USE_LOCAL_CACHE"}, {"original_string": "private ConcurrentMap<String, TimerJobInstance> localCache = new ConcurrentHashMap<String, TimerJobInstance>();", "modifier": "private", "type": "ConcurrentMap<String, TimerJobInstance>", "declarator": "localCache = new ConcurrentHashMap<String, TimerJobInstance>()", "var_name": "localCache"}, {"original_string": "@Resource\n\tprotected javax.ejb.TimerService timerService;", "modifier": "@Resource\n\tprotected", "type": "javax.ejb.TimerService", "declarator": "timerService", "var_name": "timerService"}, {"original_string": "@Resource\n    protected UserTransaction utx;", "modifier": "@Resource\n    protected", "type": "UserTransaction", "declarator": "utx", "var_name": "utx"}], "methods": [{"identifier": "setup", "parameters": "()", "modifiers": "@PostConstruct public", "return": "void", "signature": "void setup()", "full_signature": "@PostConstruct public void setup()", "class_method_signature": "EJBTimerScheduler.setup()", "testcase": false, "constructor": false}, {"identifier": "executeTimerJob", "parameters": "(Timer timer)", "modifiers": "@Timeout public", "return": "void", "signature": "void executeTimerJob(Timer timer)", "full_signature": "@Timeout public void executeTimerJob(Timer timer)", "class_method_signature": "EJBTimerScheduler.executeTimerJob(Timer timer)", "testcase": false, "constructor": false}, {"identifier": "executeTimerJobInstance", "parameters": "(TimerJobInstance timerJobInstance)", "modifiers": "private", "return": "void", "signature": "void executeTimerJobInstance(TimerJobInstance timerJobInstance)", "full_signature": "private void executeTimerJobInstance(TimerJobInstance timerJobInstance)", "class_method_signature": "EJBTimerScheduler.executeTimerJobInstance(TimerJobInstance timerJobInstance)", "testcase": false, "constructor": false}, {"identifier": "recoverTimerJobInstance", "parameters": "(EjbTimerJob ejbTimerJob, Exception e)", "modifiers": "private", "return": "void", "signature": "void recoverTimerJobInstance(EjbTimerJob ejbTimerJob, Exception e)", "full_signature": "private void recoverTimerJobInstance(EjbTimerJob ejbTimerJob, Exception e)", "class_method_signature": "EJBTimerScheduler.recoverTimerJobInstance(EjbTimerJob ejbTimerJob, Exception e)", "testcase": false, "constructor": false}, {"identifier": "transaction", "parameters": "(Transaction<I> operation, I item)", "modifiers": "private", "return": "void", "signature": "void transaction(Transaction<I> operation, I item)", "full_signature": "private void transaction(Transaction<I> operation, I item)", "class_method_signature": "EJBTimerScheduler.transaction(Transaction<I> operation, I item)", "testcase": false, "constructor": false}, {"identifier": "internalSchedule", "parameters": "(TimerJobInstance timerJobInstance)", "modifiers": "public", "return": "void", "signature": "void internalSchedule(TimerJobInstance timerJobInstance)", "full_signature": "public void internalSchedule(TimerJobInstance timerJobInstance)", "class_method_signature": "EJBTimerScheduler.internalSchedule(TimerJobInstance timerJobInstance)", "testcase": false, "constructor": false}, {"identifier": "removeTransientFields", "parameters": "(Serializable info)", "modifiers": "private", "return": "Serializable", "signature": "Serializable removeTransientFields(Serializable info)", "full_signature": "private Serializable removeTransientFields(Serializable info)", "class_method_signature": "EJBTimerScheduler.removeTransientFields(Serializable info)", "testcase": false, "constructor": false}, {"identifier": "removeJob", "parameters": "(JobHandle jobHandle)", "modifiers": "public", "return": "boolean", "signature": "boolean removeJob(JobHandle jobHandle)", "full_signature": "public boolean removeJob(JobHandle jobHandle)", "class_method_signature": "EJBTimerScheduler.removeJob(JobHandle jobHandle)", "testcase": false, "constructor": false}, {"identifier": "getTimerByName", "parameters": "(String jobName)", "modifiers": "public", "return": "TimerJobInstance", "signature": "TimerJobInstance getTimerByName(String jobName)", "full_signature": "public TimerJobInstance getTimerByName(String jobName)", "class_method_signature": "EJBTimerScheduler.getTimerByName(String jobName)", "testcase": false, "constructor": false}], "file": "jbpm-services/jbpm-services-ejb/jbpm-services-ejb-timer/src/main/java/org/jbpm/services/ejb/timer/EJBTimerScheduler.java"}, "focal_method": {"identifier": "getTimerByName", "parameters": "(String jobName)", "modifiers": "public", "return": "TimerJobInstance", "body": "public TimerJobInstance getTimerByName(String jobName) {\n    \tif (USE_LOCAL_CACHE) {\n    \t\tif (localCache.containsKey(jobName)) {\n    \t\t\tlogger.debug(\"Found job {} in cache returning\", jobName);\n    \t\t\treturn localCache.get(jobName);\n    \t\t}\n    \t}\n\t    TimerJobInstance found = null;\n\n\t\tfor (Timer timer : timerService.getTimers()) {\n\t\t    try {\n    \t\t\tSerializable info = timer.getInfo();\n    \t\t\tif (info instanceof EjbTimerJob) {\n    \t\t\t\tEjbTimerJob job = (EjbTimerJob) info;\n\n    \t\t\t\tEjbGlobalJobHandle handle = (EjbGlobalJobHandle) job.getTimerJobInstance().getJobHandle();\n\n    \t\t\t\tif (handle.getUuid().equals(jobName)) {\n    \t\t\t\t\tfound = handle.getTimerJobInstance();\n\t\t\t\t\t\t\tif (USE_LOCAL_CACHE) {\n    \t\t\t\t\t    localCache.putIfAbsent(jobName, found);\n\t\t\t\t\t\t  }\n    \t\t\t\t\tlogger.debug(\"Job {} does match timer and is going to be returned {}\", jobName, found);\n\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n\t\t    } catch (NoSuchObjectLocalException e) {\n                logger.debug(\"Timer info for {} was not found \", timer);\n            }\n\t\t}\n\n\t\treturn found;\n\t}", "signature": "TimerJobInstance getTimerByName(String jobName)", "full_signature": "public TimerJobInstance getTimerByName(String jobName)", "class_method_signature": "EJBTimerScheduler.getTimerByName(String jobName)", "testcase": false, "constructor": false, "invocations": ["containsKey", "debug", "get", "getTimers", "getInfo", "getJobHandle", "getTimerJobInstance", "equals", "getUuid", "getTimerJobInstance", "putIfAbsent", "debug", "debug"]}, "repository": {"repo_id": 930571, "url": "https://github.com/kiegroup/jbpm", "stars": 1035, "created": "9/22/2010 1:19:52 PM +00:00", "updates": "2020-01-22T03:39:57+00:00", "fork": "False", "license": "licensed"}}