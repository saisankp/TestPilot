{"test_class": {"identifier": "TestSourceKafkaClusterValidationManager", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER =\n      LoggerFactory.getLogger(TestSourceKafkaClusterValidationManager.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER =\n      LoggerFactory.getLogger(TestSourceKafkaClusterValidationManager.class)", "var_name": "LOGGER"}, {"original_string": "private static KafkaBrokerTopicObserver kafkaBrokerTopicObserver;", "modifier": "private static", "type": "KafkaBrokerTopicObserver", "declarator": "kafkaBrokerTopicObserver", "var_name": "kafkaBrokerTopicObserver"}, {"original_string": "private KafkaServerStartable kafkaStarter;", "modifier": "private", "type": "KafkaServerStartable", "declarator": "kafkaStarter", "var_name": "kafkaStarter"}, {"original_string": "private HelixMirrorMakerManager helixMirrorMakerManager;", "modifier": "private", "type": "HelixMirrorMakerManager", "declarator": "helixMirrorMakerManager", "var_name": "helixMirrorMakerManager"}, {"original_string": "private SourceKafkaClusterValidationManager sourceKafkaClusterValidationManager;", "modifier": "private", "type": "SourceKafkaClusterValidationManager", "declarator": "sourceKafkaClusterValidationManager", "var_name": "sourceKafkaClusterValidationManager"}], "file": "uReplicator-Controller/src/test/java/com/uber/stream/kafka/mirrormaker/controller/validation/TestSourceKafkaClusterValidationManager.java"}, "test_case": {"identifier": "testValidation", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testValidation() {\n    String validationResult = sourceKafkaClusterValidationManager.validateSourceKafkaCluster();\n    System.out.println(validationResult);\n    Assert.assertEquals(validationResult,\n        \"{\\\"numMissingTopics\\\":0,\\\"numMismatchedTopics\\\":0,\\\"mismatchedTopicPartitions\\\":{},\\\"numMismatchedTopicPartitions\\\":0}\");\n    for (int i = 0; i < 2; ++i) {\n      Assert.assertEquals(helixMirrorMakerManager.getTopicLists().size(), i);\n      String topicName = \"testTopic\" + i;\n      // Create Kafka topic\n      KafkaStarterUtils.createTopic(topicName, KafkaStarterUtils.DEFAULT_ZK_STR);\n      try {\n        Thread.sleep(1000);\n      } catch (Exception e) {\n      }\n      Assert.assertEquals(kafkaBrokerTopicObserver.getNumTopics(), 1 + i);\n      for (int j = 0; j <= i; ++j) {\n        Assert.assertTrue(kafkaBrokerTopicObserver.getAllTopics().contains(\"testTopic\" + j));\n        Assert.assertEquals(\n            kafkaBrokerTopicObserver.getTopicPartition(\"testTopic\" + j).getPartition(), 1);\n      }\n\n      validationResult = sourceKafkaClusterValidationManager.validateSourceKafkaCluster();\n      System.out.println(validationResult);\n      Assert.assertEquals(validationResult,\n        \"{\\\"numMissingTopics\\\":0,\\\"numMismatchedTopics\\\":0,\\\"mismatchedTopicPartitions\\\":{},\\\"numMismatchedTopicPartitions\\\":0}\");\n      helixMirrorMakerManager.addTopicToMirrorMaker(topicName, 1);\n    }\n\n    for (int i = 2; i < 4; ++i) {\n      helixMirrorMakerManager.addTopicToMirrorMaker(\"testTopic\" + i, 1);\n    }\n    JSONObject validationResultJson =\n        JSONObject.parseObject(sourceKafkaClusterValidationManager.validateSourceKafkaCluster());\n    System.out.println(validationResultJson);\n    Assert.assertEquals(validationResultJson.get(\"numMissingTopics\"), 2);\n    for (int i = 2; i < 4; ++i) {\n      Assert.assertEquals(helixMirrorMakerManager.getTopicLists().size(), 4);\n      String topicName = \"testTopic\" + i;\n      // Create Kafka topic\n      KafkaStarterUtils.createTopic(topicName, KafkaStarterUtils.DEFAULT_ZK_STR);\n      try {\n        Thread.sleep(1000);\n      } catch (Exception e) {\n      }\n      Assert.assertEquals(kafkaBrokerTopicObserver.getNumTopics(), 1 + i);\n      for (int j = 0; j <= i; ++j) {\n        Assert.assertTrue(kafkaBrokerTopicObserver.getAllTopics().contains(\"testTopic\" + j));\n        Assert.assertEquals(\n            kafkaBrokerTopicObserver.getTopicPartition(\"testTopic\" + j).getPartition(), 1);\n      }\n\n      validationResultJson =\n          JSONObject.parseObject(sourceKafkaClusterValidationManager.validateSourceKafkaCluster());\n      System.out.println(validationResultJson);\n      Assert.assertEquals(validationResultJson.get(\"numMissingTopics\"), 3 - i);\n    }\n    for (int i = 4; i < 6; ++i) {\n      helixMirrorMakerManager.addTopicToMirrorMaker(\"testTopic\" + i, 2);\n    }\n    validationResultJson =\n        JSONObject.parseObject(sourceKafkaClusterValidationManager.validateSourceKafkaCluster());\n    System.out.println(validationResultJson);\n    Assert.assertEquals(validationResultJson.get(\"numMissingTopics\"), 2);\n    for (int i = 4; i < 6; ++i) {\n      Assert.assertEquals(helixMirrorMakerManager.getTopicLists().size(), 6);\n      String topicName = \"testTopic\" + i;\n      // Create Kafka topic\n      KafkaStarterUtils.createTopic(topicName, KafkaStarterUtils.DEFAULT_ZK_STR);\n      try {\n        Thread.sleep(1000);\n      } catch (Exception e) {\n      }\n      Assert.assertEquals(kafkaBrokerTopicObserver.getNumTopics(), 1 + i);\n      for (int j = 0; j <= i; ++j) {\n        Assert.assertTrue(kafkaBrokerTopicObserver.getAllTopics().contains(\"testTopic\" + j));\n        Assert.assertEquals(\n            kafkaBrokerTopicObserver.getTopicPartition(\"testTopic\" + j).getPartition(), 1);\n      }\n\n      validationResultJson =\n          JSONObject.parseObject(sourceKafkaClusterValidationManager.validateSourceKafkaCluster());\n      System.out.println(validationResultJson);\n      Assert.assertEquals(validationResultJson.get(\"numMissingTopics\"), 5 - i);\n      Assert.assertEquals(validationResultJson.get(\"numMismatchedTopics\"), i - 3);\n      Assert.assertEquals(validationResultJson.get(\"numMismatchedTopicPartitions\"), i - 3);\n      for (int h = 4; h <= i; ++h) {\n        Assert.assertEquals(\n            validationResultJson.getJSONObject(\"mismatchedTopicPartitions\").get(\"testTopic\" + h),\n            1);\n      }\n    }\n\n    for (int i = 4; i < 6; ++i) {\n      helixMirrorMakerManager.deleteTopicInMirrorMaker(\"testTopic\" + i);\n      helixMirrorMakerManager.addTopicToMirrorMaker(\"testTopic\" + i, 1);\n    }\n    validationResult = sourceKafkaClusterValidationManager.validateSourceKafkaCluster();\n    System.out.println(validationResult);\n\n    Assert.assertEquals(validationResult,\n        \"{\\\"numMissingTopics\\\":0,\\\"numMismatchedTopics\\\":0,\\\"mismatchedTopicPartitions\\\":{},\\\"numMismatchedTopicPartitions\\\":0}\");\n   \n  }", "signature": "void testValidation()", "full_signature": "@Test public void testValidation()", "class_method_signature": "TestSourceKafkaClusterValidationManager.testValidation()", "testcase": true, "constructor": false, "invocations": ["validateSourceKafkaCluster", "println", "assertEquals", "assertEquals", "size", "getTopicLists", "createTopic", "sleep", "assertEquals", "getNumTopics", "assertTrue", "contains", "getAllTopics", "assertEquals", "getPartition", "getTopicPartition", "validateSourceKafkaCluster", "println", "assertEquals", "addTopicToMirrorMaker", "addTopicToMirrorMaker", "parseObject", "validateSourceKafkaCluster", "println", "assertEquals", "get", "assertEquals", "size", "getTopicLists", "createTopic", "sleep", "assertEquals", "getNumTopics", "assertTrue", "contains", "getAllTopics", "assertEquals", "getPartition", "getTopicPartition", "parseObject", "validateSourceKafkaCluster", "println", "assertEquals", "get", "addTopicToMirrorMaker", "parseObject", "validateSourceKafkaCluster", "println", "assertEquals", "get", "assertEquals", "size", "getTopicLists", "createTopic", "sleep", "assertEquals", "getNumTopics", "assertTrue", "contains", "getAllTopics", "assertEquals", "getPartition", "getTopicPartition", "parseObject", "validateSourceKafkaCluster", "println", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "getJSONObject", "deleteTopicInMirrorMaker", "addTopicToMirrorMaker", "validateSourceKafkaCluster", "println", "assertEquals"]}, "focal_class": {"identifier": "SourceKafkaClusterValidationManager", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER =\n      LoggerFactory.getLogger(SourceKafkaClusterValidationManager.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER =\n      LoggerFactory.getLogger(SourceKafkaClusterValidationManager.class)", "var_name": "LOGGER"}, {"original_string": "private static final int STOP_TIMEOUT_SEC = 5;", "modifier": "private static final", "type": "int", "declarator": "STOP_TIMEOUT_SEC = 5", "var_name": "STOP_TIMEOUT_SEC"}, {"original_string": "private final HelixMirrorMakerManager _helixMirrorMakerManager;", "modifier": "private final", "type": "HelixMirrorMakerManager", "declarator": "_helixMirrorMakerManager", "var_name": "_helixMirrorMakerManager"}, {"original_string": "private final ScheduledExecutorService _executorService =\n      Executors.newSingleThreadScheduledExecutor();", "modifier": "private final", "type": "ScheduledExecutorService", "declarator": "_executorService =\n      Executors.newSingleThreadScheduledExecutor()", "var_name": "_executorService"}, {"original_string": "private int _timeValue = 60 * 10;", "modifier": "private", "type": "int", "declarator": "_timeValue = 60 * 10", "var_name": "_timeValue"}, {"original_string": "private TimeUnit _timeUnit = TimeUnit.SECONDS;", "modifier": "private", "type": "TimeUnit", "declarator": "_timeUnit = TimeUnit.SECONDS", "var_name": "_timeUnit"}, {"original_string": "private final static String MISMATCHED_METRICS_FORMAT =\n      \"kafkaAndIdealstatesDiscrepancy.mismatched.topic.%s\";", "modifier": "private final static", "type": "String", "declarator": "MISMATCHED_METRICS_FORMAT =\n      \"kafkaAndIdealstatesDiscrepancy.mismatched.topic.%s\"", "var_name": "MISMATCHED_METRICS_FORMAT"}, {"original_string": "private final Counter _numMissingTopics = new Counter();", "modifier": "private final", "type": "Counter", "declarator": "_numMissingTopics = new Counter()", "var_name": "_numMissingTopics"}, {"original_string": "private final Counter _numMismatchedTopics = new Counter();", "modifier": "private final", "type": "Counter", "declarator": "_numMismatchedTopics = new Counter()", "var_name": "_numMismatchedTopics"}, {"original_string": "private final Counter _numMismatchedTopicPartitions = new Counter();", "modifier": "private final", "type": "Counter", "declarator": "_numMismatchedTopicPartitions = new Counter()", "var_name": "_numMismatchedTopicPartitions"}, {"original_string": "private final KafkaBrokerTopicObserver _sourceKafkaTopicObserver;", "modifier": "private final", "type": "KafkaBrokerTopicObserver", "declarator": "_sourceKafkaTopicObserver", "var_name": "_sourceKafkaTopicObserver"}, {"original_string": "private final boolean _enableAutoTopicExpansion;", "modifier": "private final", "type": "boolean", "declarator": "_enableAutoTopicExpansion", "var_name": "_enableAutoTopicExpansion"}, {"original_string": "private final Counter _numAutoExpandedTopics = new Counter();", "modifier": "private final", "type": "Counter", "declarator": "_numAutoExpandedTopics = new Counter()", "var_name": "_numAutoExpandedTopics"}, {"original_string": "private final Counter _numAutoExpandedTopicPartitions = new Counter();", "modifier": "private final", "type": "Counter", "declarator": "_numAutoExpandedTopicPartitions = new Counter()", "var_name": "_numAutoExpandedTopicPartitions"}, {"original_string": "private final Map<String, Counter> _mismatchedTopicPartitionsCounter =\n      new HashMap<String, Counter>();", "modifier": "private final", "type": "Map<String, Counter>", "declarator": "_mismatchedTopicPartitionsCounter =\n      new HashMap<String, Counter>()", "var_name": "_mismatchedTopicPartitionsCounter"}], "methods": [{"identifier": "SourceKafkaClusterValidationManager", "parameters": "(KafkaBrokerTopicObserver sourceKafkaTopicObserver,\n      HelixMirrorMakerManager helixMirrorMakerManager)", "modifiers": "public", "return": "", "signature": " SourceKafkaClusterValidationManager(KafkaBrokerTopicObserver sourceKafkaTopicObserver,\n      HelixMirrorMakerManager helixMirrorMakerManager)", "full_signature": "public  SourceKafkaClusterValidationManager(KafkaBrokerTopicObserver sourceKafkaTopicObserver,\n      HelixMirrorMakerManager helixMirrorMakerManager)", "class_method_signature": "SourceKafkaClusterValidationManager.SourceKafkaClusterValidationManager(KafkaBrokerTopicObserver sourceKafkaTopicObserver,\n      HelixMirrorMakerManager helixMirrorMakerManager)", "testcase": false, "constructor": true}, {"identifier": "SourceKafkaClusterValidationManager", "parameters": "(KafkaBrokerTopicObserver sourceKafkaTopicObserver,\n      HelixMirrorMakerManager helixMirrorMakerManager, boolean enableAutoTopicExpansion)", "modifiers": "public", "return": "", "signature": " SourceKafkaClusterValidationManager(KafkaBrokerTopicObserver sourceKafkaTopicObserver,\n      HelixMirrorMakerManager helixMirrorMakerManager, boolean enableAutoTopicExpansion)", "full_signature": "public  SourceKafkaClusterValidationManager(KafkaBrokerTopicObserver sourceKafkaTopicObserver,\n      HelixMirrorMakerManager helixMirrorMakerManager, boolean enableAutoTopicExpansion)", "class_method_signature": "SourceKafkaClusterValidationManager.SourceKafkaClusterValidationManager(KafkaBrokerTopicObserver sourceKafkaTopicObserver,\n      HelixMirrorMakerManager helixMirrorMakerManager, boolean enableAutoTopicExpansion)", "testcase": false, "constructor": true}, {"identifier": "start", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void start()", "full_signature": "public void start()", "class_method_signature": "SourceKafkaClusterValidationManager.start()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void stop()", "full_signature": "public void stop()", "class_method_signature": "SourceKafkaClusterValidationManager.stop()", "testcase": false, "constructor": false}, {"identifier": "validateSourceKafkaCluster", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String validateSourceKafkaCluster()", "full_signature": "public String validateSourceKafkaCluster()", "class_method_signature": "SourceKafkaClusterValidationManager.validateSourceKafkaCluster()", "testcase": false, "constructor": false}, {"identifier": "registerMetrics", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void registerMetrics()", "full_signature": "private void registerMetrics()", "class_method_signature": "SourceKafkaClusterValidationManager.registerMetrics()", "testcase": false, "constructor": false}, {"identifier": "constructValidationResultJson", "parameters": "(int numMissingTopics, int numMismatchedTopics,\n      int numMismatchedTopicPartitions, JSONObject mismatchedTopicPartitions)", "modifiers": "private", "return": "JSONObject", "signature": "JSONObject constructValidationResultJson(int numMissingTopics, int numMismatchedTopics,\n      int numMismatchedTopicPartitions, JSONObject mismatchedTopicPartitions)", "full_signature": "private JSONObject constructValidationResultJson(int numMissingTopics, int numMismatchedTopics,\n      int numMismatchedTopicPartitions, JSONObject mismatchedTopicPartitions)", "class_method_signature": "SourceKafkaClusterValidationManager.constructValidationResultJson(int numMissingTopics, int numMismatchedTopics,\n      int numMismatchedTopicPartitions, JSONObject mismatchedTopicPartitions)", "testcase": false, "constructor": false}, {"identifier": "constructMismatchedTopicPartitionsJson", "parameters": "(\n      Map<String, Integer> mismatchedTopicPartitions)", "modifiers": "private", "return": "JSONObject", "signature": "JSONObject constructMismatchedTopicPartitionsJson(\n      Map<String, Integer> mismatchedTopicPartitions)", "full_signature": "private JSONObject constructMismatchedTopicPartitionsJson(\n      Map<String, Integer> mismatchedTopicPartitions)", "class_method_signature": "SourceKafkaClusterValidationManager.constructMismatchedTopicPartitionsJson(\n      Map<String, Integer> mismatchedTopicPartitions)", "testcase": false, "constructor": false}, {"identifier": "updateMetrics", "parameters": "(int numMissingTopics, int numMismatchedTopics,\n      int numMismatchedTopicPartitions, Map<String, Integer> misMatchedPartitionNumberTopics)", "modifiers": "private synchronized", "return": "void", "signature": "void updateMetrics(int numMissingTopics, int numMismatchedTopics,\n      int numMismatchedTopicPartitions, Map<String, Integer> misMatchedPartitionNumberTopics)", "full_signature": "private synchronized void updateMetrics(int numMissingTopics, int numMismatchedTopics,\n      int numMismatchedTopicPartitions, Map<String, Integer> misMatchedPartitionNumberTopics)", "class_method_signature": "SourceKafkaClusterValidationManager.updateMetrics(int numMissingTopics, int numMismatchedTopics,\n      int numMismatchedTopicPartitions, Map<String, Integer> misMatchedPartitionNumberTopics)", "testcase": false, "constructor": false}, {"identifier": "getMismatchedTopicMetricName", "parameters": "(String topicName)", "modifiers": "private static", "return": "String", "signature": "String getMismatchedTopicMetricName(String topicName)", "full_signature": "private static String getMismatchedTopicMetricName(String topicName)", "class_method_signature": "SourceKafkaClusterValidationManager.getMismatchedTopicMetricName(String topicName)", "testcase": false, "constructor": false}], "file": "uReplicator-Controller/src/main/java/com/uber/stream/kafka/mirrormaker/controller/validation/SourceKafkaClusterValidationManager.java"}, "focal_method": {"identifier": "validateSourceKafkaCluster", "parameters": "()", "modifiers": "public", "return": "String", "body": "public String validateSourceKafkaCluster() {\n    Set<String> notExistedTopics = new HashSet<String>();\n    Map<String, Integer> misMatchedPartitionNumberTopics = new HashMap<String, Integer>();\n    int numMismatchedTopicPartitions = 0;\n    for (String topic : _helixMirrorMakerManager.getTopicLists()) {\n      TopicPartition tp = _sourceKafkaTopicObserver.getTopicPartition(topic);\n      if (tp == null) {\n        LOGGER.warn(\"Topic {} is not in source kafka broker!\", topic);\n        notExistedTopics.add(topic);\n      } else {\n        int numPartitionsInMirrorMaker =\n            _helixMirrorMakerManager.getIdealStateForTopic(topic).getNumPartitions();\n        if (numPartitionsInMirrorMaker != tp.getPartition()) {\n          int mismatchedPartitions = Math.abs(numPartitionsInMirrorMaker - tp.getPartition());\n          if (_enableAutoTopicExpansion && (tp.getPartition() > numPartitionsInMirrorMaker)) {\n            // Only do topic expansion\n            LOGGER.warn(\n                \"Trying to expand topic {} from {} partitions in mirror maker to {} from source kafka broker!\",\n                topic, numPartitionsInMirrorMaker, tp.getPartition());\n            _numAutoExpandedTopics.inc();\n            _numAutoExpandedTopicPartitions.inc(mismatchedPartitions);\n            _helixMirrorMakerManager.expandTopicInMirrorMaker(tp);\n          } else {\n            numMismatchedTopicPartitions += mismatchedPartitions;\n            misMatchedPartitionNumberTopics.put(topic, mismatchedPartitions);\n            LOGGER.warn(\n                \"Number of partitions not matched for topic {} between mirrormaker:{} and source kafka broker: {}!\",\n                topic, numPartitionsInMirrorMaker, tp.getPartition());\n          }\n        }\n      }\n    }\n    JSONObject mismatchedTopicPartitionsJson =\n        constructMismatchedTopicPartitionsJson(misMatchedPartitionNumberTopics);\n    JSONObject validationResultJson = constructValidationResultJson(notExistedTopics.size(),\n        misMatchedPartitionNumberTopics.size(),\n        numMismatchedTopicPartitions, mismatchedTopicPartitionsJson);\n    if (_helixMirrorMakerManager.isLeader()) {\n      updateMetrics(notExistedTopics.size(), misMatchedPartitionNumberTopics.size(),\n          numMismatchedTopicPartitions, misMatchedPartitionNumberTopics);\n    }\n    return validationResultJson.toJSONString();\n  }", "signature": "String validateSourceKafkaCluster()", "full_signature": "public String validateSourceKafkaCluster()", "class_method_signature": "SourceKafkaClusterValidationManager.validateSourceKafkaCluster()", "testcase": false, "constructor": false, "invocations": ["getTopicLists", "getTopicPartition", "warn", "add", "getNumPartitions", "getIdealStateForTopic", "getPartition", "abs", "getPartition", "getPartition", "warn", "getPartition", "inc", "inc", "expandTopicInMirrorMaker", "put", "warn", "getPartition", "constructMismatchedTopicPartitionsJson", "constructValidationResultJson", "size", "size", "isLeader", "updateMetrics", "size", "size", "toJSONString"]}, "repository": {"repo_id": 60201162, "url": "https://github.com/uber/uReplicator", "language": "Java", "is_fork": false, "fork_count": 148, "stargazer_count": 652, "size": 2223, "license": "licensed"}}