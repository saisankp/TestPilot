{"test_class": {"identifier": "ScriptTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(ScriptTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(ScriptTest.class)", "var_name": "logger"}, {"original_string": "private final String ACTUAL = \"{\\\"id\\\":{\\\"domain\\\":\\\"ACS\\\",\\\"type\\\":\\\"entityId\\\",\\\"value\\\":\\\"bef90f66-bb57-4fea-83aa-a0acc42b0426\\\"},\\\"primaryId\\\":\\\"bef90f66-bb57-4fea-83aa-a0acc42b0426\\\",\\\"created\\\":{\\\"on\\\":\\\"2016-02-28T05:56:48.485+0000\\\"},\\\"lastUpdated\\\":{\\\"on\\\":\\\"2016-02-28T05:56:49.038+0000\\\"},\\\"organization\\\":{\\\"id\\\":{\\\"domain\\\":\\\"ACS\\\",\\\"type\\\":\\\"entityId\\\",\\\"value\\\":\\\"631fafe9-8822-4c82-b4a4-8735b202c16c\\\"},\\\"created\\\":{\\\"on\\\":\\\"2016-02-28T05:56:48.486+0000\\\"},\\\"lastUpdated\\\":{\\\"on\\\":\\\"2016-02-28T05:56:49.038+0000\\\"}},\\\"clientState\\\":\\\"ACTIVE\\\"}\";", "modifier": "private final", "type": "String", "declarator": "ACTUAL = \"{\\\"id\\\":{\\\"domain\\\":\\\"ACS\\\",\\\"type\\\":\\\"entityId\\\",\\\"value\\\":\\\"bef90f66-bb57-4fea-83aa-a0acc42b0426\\\"},\\\"primaryId\\\":\\\"bef90f66-bb57-4fea-83aa-a0acc42b0426\\\",\\\"created\\\":{\\\"on\\\":\\\"2016-02-28T05:56:48.485+0000\\\"},\\\"lastUpdated\\\":{\\\"on\\\":\\\"2016-02-28T05:56:49.038+0000\\\"},\\\"organization\\\":{\\\"id\\\":{\\\"domain\\\":\\\"ACS\\\",\\\"type\\\":\\\"entityId\\\",\\\"value\\\":\\\"631fafe9-8822-4c82-b4a4-8735b202c16c\\\"},\\\"created\\\":{\\\"on\\\":\\\"2016-02-28T05:56:48.486+0000\\\"},\\\"lastUpdated\\\":{\\\"on\\\":\\\"2016-02-28T05:56:49.038+0000\\\"}},\\\"clientState\\\":\\\"ACTIVE\\\"}\"", "var_name": "ACTUAL"}, {"original_string": "private final String EXPECTED = \"{\\\"id\\\":{\\\"domain\\\":\\\"ACS\\\",\\\"type\\\":\\\"entityId\\\",\\\"value\\\":\\\"#ignore\\\"},\\\"primaryId\\\":\\\"#ignore\\\",\\\"created\\\":{\\\"on\\\":\\\"#ignore\\\"},\\\"lastUpdated\\\":{\\\"on\\\":\\\"#ignore\\\"},\\\"organization\\\":{\\\"id\\\":{\\\"domain\\\":\\\"ACS\\\",\\\"type\\\":\\\"entityId\\\",\\\"value\\\":\\\"#ignore\\\"},\\\"created\\\":{\\\"on\\\":\\\"#ignore\\\"},\\\"lastUpdated\\\":{\\\"on\\\":\\\"#ignore\\\"}},\\\"clientState\\\":\\\"ACTIVE\\\"}\";", "modifier": "private final", "type": "String", "declarator": "EXPECTED = \"{\\\"id\\\":{\\\"domain\\\":\\\"ACS\\\",\\\"type\\\":\\\"entityId\\\",\\\"value\\\":\\\"#ignore\\\"},\\\"primaryId\\\":\\\"#ignore\\\",\\\"created\\\":{\\\"on\\\":\\\"#ignore\\\"},\\\"lastUpdated\\\":{\\\"on\\\":\\\"#ignore\\\"},\\\"organization\\\":{\\\"id\\\":{\\\"domain\\\":\\\"ACS\\\",\\\"type\\\":\\\"entityId\\\",\\\"value\\\":\\\"#ignore\\\"},\\\"created\\\":{\\\"on\\\":\\\"#ignore\\\"},\\\"lastUpdated\\\":{\\\"on\\\":\\\"#ignore\\\"}},\\\"clientState\\\":\\\"ACTIVE\\\"}\"", "var_name": "EXPECTED"}], "file": "karate-core/src/test/java/com/intuit/karate/ScriptTest.java"}, "test_case": {"identifier": "testMatchAllJsonPath", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMatchAllJsonPath() {\n        DocumentContext doc = JsonPath.parse(\"{ foo: [{bar: 1, baz: 'a'}, {bar: 2, baz: 'b'}, {bar:3, baz: 'c'}]}\");\n        ScenarioContext ctx = getContext();\n        ctx.vars.put(\"myJson\", doc);\n        ScriptValue myJson = ctx.vars.get(\"myJson\");\n        assertTrue(Script.matchJsonOrObject(MatchType.EQUALS, myJson, \"$.foo\", \"[{bar: 1, baz: 'a'}, {bar: 2, baz: 'b'}, {bar:3, baz: 'c'}]\", ctx).pass);\n        assertTrue(Script.matchJsonOrObject(MatchType.CONTAINS, myJson, \"$.foo\", \"[{bar: 1, baz: 'a'}, {bar: 2, baz: 'b'}, {bar:3, baz: 'c'}]\", ctx).pass);\n        assertFalse(Script.matchJsonOrObject(MatchType.NOT_CONTAINS, myJson, \"$.foo\", \"[{bar: 1, baz: 'a'}]\", ctx).pass);\n        assertTrue(Script.matchJsonOrObject(MatchType.NOT_CONTAINS, myJson, \"$.foo\", \"[{bar: 9, baz: 'z'}, {bar: 99, baz: 'zz'}]\", ctx).pass);\n        assertTrue(Script.matchJsonOrObject(MatchType.CONTAINS_ONLY, myJson, \"$.foo\", \"[{bar: 1, baz: 'a'}, {bar: 2, baz: 'b'}, {bar:3, baz: 'c'}]\", ctx).pass);\n        assertTrue(Script.matchJsonOrObject(MatchType.CONTAINS_ANY, myJson, \"$.foo\", \"[{bar: 9, baz: 'z'}, {bar: 2, baz: 'b'}]\", ctx).pass);\n        assertTrue(Script.matchJsonOrObject(MatchType.CONTAINS_DEEP, myJson, \"$.foo\", \"[{bar: 1}, {bar: 2}, {bar:3}]\", ctx).pass);\n\n        // shuffle\n        assertTrue(Script.matchJsonOrObject(MatchType.CONTAINS_ONLY, myJson, \"$.foo\", \"[{bar: 2, baz: 'b'}, {bar:3, baz: 'c'}, {bar: 1, baz: 'a'}]\", ctx).pass);\n        assertFalse(Script.matchJsonOrObject(MatchType.CONTAINS_ONLY, myJson, \"$.foo\", \"[{bar: 1, baz: 'a'}, {bar: 2, baz: 'b'}]\", ctx).pass);\n        assertTrue(Script.matchJsonOrObject(MatchType.EACH_EQUALS, myJson, \"$.foo\", \"{bar:'#number', baz:'#string'}\", ctx).pass);\n        assertTrue(Script.matchJsonOrObject(MatchType.EACH_CONTAINS, myJson, \"$.foo\", \"{bar:'#number'}\", ctx).pass);\n        assertTrue(Script.matchJsonOrObject(MatchType.EACH_CONTAINS, myJson, \"$.foo\", \"{baz:'#string'}\", ctx).pass);\n        assertTrue(Script.matchJsonOrObject(MatchType.CONTAINS_DEEP, myJson, \"$.foo\", \"[{bar: 1}, {bar: 2}, {bar:3}]\", ctx).pass);\n        assertTrue(Script.matchJsonOrObject(MatchType.EACH_NOT_CONTAINS, myJson, \"$.foo\", \"{baz:'z'}\", ctx).pass);\n        assertFalse(Script.matchJsonOrObject(MatchType.EACH_NOT_CONTAINS, myJson, \"$.foo\", \"{baz:'a'}\", ctx).pass);\n        assertFalse(Script.matchJsonOrObject(MatchType.EACH_EQUALS, myJson, \"$.foo\", \"{bar:'#? _ < 3',  baz:'#string'}\", ctx).pass);\n        assertTrue(Script.matchJsonOrObject(MatchType.CONTAINS_DEEP, myJson, \"$\", \"{foo: [{bar: 1}, {bar: 2}, {bar:3}]}\", ctx).pass);\n\n    }", "signature": "void testMatchAllJsonPath()", "full_signature": "@Test public void testMatchAllJsonPath()", "class_method_signature": "ScriptTest.testMatchAllJsonPath()", "testcase": true, "constructor": false, "invocations": ["parse", "getContext", "put", "get", "assertTrue", "matchJsonOrObject", "assertTrue", "matchJsonOrObject", "assertFalse", "matchJsonOrObject", "assertTrue", "matchJsonOrObject", "assertTrue", "matchJsonOrObject", "assertTrue", "matchJsonOrObject", "assertTrue", "matchJsonOrObject", "assertTrue", "matchJsonOrObject", "assertFalse", "matchJsonOrObject", "assertTrue", "matchJsonOrObject", "assertTrue", "matchJsonOrObject", "assertTrue", "matchJsonOrObject", "assertTrue", "matchJsonOrObject", "assertTrue", "matchJsonOrObject", "assertFalse", "matchJsonOrObject", "assertFalse", "matchJsonOrObject", "assertTrue", "matchJsonOrObject"]}, "focal_class": {"identifier": "Script", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String VAR_SELF = \"_\";", "modifier": "public static final", "type": "String", "declarator": "VAR_SELF = \"_\"", "var_name": "VAR_SELF"}, {"original_string": "public static final String VAR_ROOT = \"$\";", "modifier": "public static final", "type": "String", "declarator": "VAR_ROOT = \"$\"", "var_name": "VAR_ROOT"}, {"original_string": "public static final String VAR_PARENT = \"_$\";", "modifier": "public static final", "type": "String", "declarator": "VAR_PARENT = \"_$\"", "var_name": "VAR_PARENT"}, {"original_string": "public static final String VAR_LOOP = \"__loop\";", "modifier": "public static final", "type": "String", "declarator": "VAR_LOOP = \"__loop\"", "var_name": "VAR_LOOP"}, {"original_string": "public static final String VAR_ARG = \"__arg\";", "modifier": "public static final", "type": "String", "declarator": "VAR_ARG = \"__arg\"", "var_name": "VAR_ARG"}, {"original_string": "public static final String VAR_HEADER = \"header\";", "modifier": "public static final", "type": "String", "declarator": "VAR_HEADER = \"header\"", "var_name": "VAR_HEADER"}, {"original_string": "public static final Map<String, Validator> VALIDATORS;", "modifier": "public static final", "type": "Map<String, Validator>", "declarator": "VALIDATORS", "var_name": "VALIDATORS"}, {"original_string": "private static final Pattern VAR_AND_PATH_PATTERN = Pattern.compile(\"\\\\w+\");", "modifier": "private static final", "type": "Pattern", "declarator": "VAR_AND_PATH_PATTERN = Pattern.compile(\"\\\\w+\")", "var_name": "VAR_AND_PATH_PATTERN"}, {"original_string": "private static final String VARIABLE_PATTERN_STRING = \"[a-zA-Z][\\\\w]*\";", "modifier": "private static final", "type": "String", "declarator": "VARIABLE_PATTERN_STRING = \"[a-zA-Z][\\\\w]*\"", "var_name": "VARIABLE_PATTERN_STRING"}, {"original_string": "private static final Pattern VARIABLE_PATTERN = Pattern.compile(VARIABLE_PATTERN_STRING);", "modifier": "private static final", "type": "Pattern", "declarator": "VARIABLE_PATTERN = Pattern.compile(VARIABLE_PATTERN_STRING)", "var_name": "VARIABLE_PATTERN"}, {"original_string": "private static final String TOKEN = \"token\";", "modifier": "private static final", "type": "String", "declarator": "TOKEN = \"token\"", "var_name": "TOKEN"}, {"original_string": "private static final String PATH = \"path\";", "modifier": "private static final", "type": "String", "declarator": "PATH = \"path\"", "var_name": "PATH"}], "methods": [{"identifier": "Script", "parameters": "()", "modifiers": "private", "return": "", "signature": " Script()", "full_signature": "private  Script()", "class_method_signature": "Script.Script()", "testcase": false, "constructor": true}, {"identifier": "isCallSyntax", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isCallSyntax(String text)", "full_signature": "public static final boolean isCallSyntax(String text)", "class_method_signature": "Script.isCallSyntax(String text)", "testcase": false, "constructor": false}, {"identifier": "isCallOnceSyntax", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isCallOnceSyntax(String text)", "full_signature": "public static final boolean isCallOnceSyntax(String text)", "class_method_signature": "Script.isCallOnceSyntax(String text)", "testcase": false, "constructor": false}, {"identifier": "isGetSyntax", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isGetSyntax(String text)", "full_signature": "public static final boolean isGetSyntax(String text)", "class_method_signature": "Script.isGetSyntax(String text)", "testcase": false, "constructor": false}, {"identifier": "isJson", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isJson(String text)", "full_signature": "public static final boolean isJson(String text)", "class_method_signature": "Script.isJson(String text)", "testcase": false, "constructor": false}, {"identifier": "isJsonPath", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isJsonPath(String text)", "full_signature": "public static final boolean isJsonPath(String text)", "class_method_signature": "Script.isJsonPath(String text)", "testcase": false, "constructor": false}, {"identifier": "isXml", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isXml(String text)", "full_signature": "public static final boolean isXml(String text)", "class_method_signature": "Script.isXml(String text)", "testcase": false, "constructor": false}, {"identifier": "isXmlPath", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isXmlPath(String text)", "full_signature": "public static final boolean isXmlPath(String text)", "class_method_signature": "Script.isXmlPath(String text)", "testcase": false, "constructor": false}, {"identifier": "isXmlPathFunction", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isXmlPathFunction(String text)", "full_signature": "public static final boolean isXmlPathFunction(String text)", "class_method_signature": "Script.isXmlPathFunction(String text)", "testcase": false, "constructor": false}, {"identifier": "isEmbeddedExpression", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isEmbeddedExpression(String text)", "full_signature": "public static final boolean isEmbeddedExpression(String text)", "class_method_signature": "Script.isEmbeddedExpression(String text)", "testcase": false, "constructor": false}, {"identifier": "isWithinParentheses", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isWithinParentheses(String text)", "full_signature": "public static final boolean isWithinParentheses(String text)", "class_method_signature": "Script.isWithinParentheses(String text)", "testcase": false, "constructor": false}, {"identifier": "isContainsMacro", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isContainsMacro(String text)", "full_signature": "public static final boolean isContainsMacro(String text)", "class_method_signature": "Script.isContainsMacro(String text)", "testcase": false, "constructor": false}, {"identifier": "isContainsOnlyMacro", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isContainsOnlyMacro(String text)", "full_signature": "public static final boolean isContainsOnlyMacro(String text)", "class_method_signature": "Script.isContainsOnlyMacro(String text)", "testcase": false, "constructor": false}, {"identifier": "isContainsAnyMacro", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isContainsAnyMacro(String text)", "full_signature": "public static final boolean isContainsAnyMacro(String text)", "class_method_signature": "Script.isContainsAnyMacro(String text)", "testcase": false, "constructor": false}, {"identifier": "isNotContainsMacro", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isNotContainsMacro(String text)", "full_signature": "public static final boolean isNotContainsMacro(String text)", "class_method_signature": "Script.isNotContainsMacro(String text)", "testcase": false, "constructor": false}, {"identifier": "isDollarPrefixedJsonPath", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isDollarPrefixedJsonPath(String text)", "full_signature": "public static final boolean isDollarPrefixedJsonPath(String text)", "class_method_signature": "Script.isDollarPrefixedJsonPath(String text)", "testcase": false, "constructor": false}, {"identifier": "isDollarPrefixedParen", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isDollarPrefixedParen(String text)", "full_signature": "public static final boolean isDollarPrefixedParen(String text)", "class_method_signature": "Script.isDollarPrefixedParen(String text)", "testcase": false, "constructor": false}, {"identifier": "isDollarPrefixed", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isDollarPrefixed(String text)", "full_signature": "public static final boolean isDollarPrefixed(String text)", "class_method_signature": "Script.isDollarPrefixed(String text)", "testcase": false, "constructor": false}, {"identifier": "isVariable", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isVariable(String text)", "full_signature": "public static final boolean isVariable(String text)", "class_method_signature": "Script.isVariable(String text)", "testcase": false, "constructor": false}, {"identifier": "isVariableAndSpaceAndPath", "parameters": "(String text)", "modifiers": "public static final", "return": "boolean", "signature": "boolean isVariableAndSpaceAndPath(String text)", "full_signature": "public static final boolean isVariableAndSpaceAndPath(String text)", "class_method_signature": "Script.isVariableAndSpaceAndPath(String text)", "testcase": false, "constructor": false}, {"identifier": "parseVariableAndPath", "parameters": "(String text)", "modifiers": "public static", "return": "StringUtils.Pair", "signature": "StringUtils.Pair parseVariableAndPath(String text)", "full_signature": "public static StringUtils.Pair parseVariableAndPath(String text)", "class_method_signature": "Script.parseVariableAndPath(String text)", "testcase": false, "constructor": false}, {"identifier": "evalKarateExpressionForMatch", "parameters": "(String text, ScenarioContext context)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue evalKarateExpressionForMatch(String text, ScenarioContext context)", "full_signature": "public static ScriptValue evalKarateExpressionForMatch(String text, ScenarioContext context)", "class_method_signature": "Script.evalKarateExpressionForMatch(String text, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "result", "parameters": "(ScriptValue called, CallResult result, boolean reuseParentConfig, ScenarioContext context)", "modifiers": "private static", "return": "ScriptValue", "signature": "ScriptValue result(ScriptValue called, CallResult result, boolean reuseParentConfig, ScenarioContext context)", "full_signature": "private static ScriptValue result(ScriptValue called, CallResult result, boolean reuseParentConfig, ScenarioContext context)", "class_method_signature": "Script.result(ScriptValue called, CallResult result, boolean reuseParentConfig, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "callWithCache", "parameters": "(String callKey, ScriptValue called, String arg, ScenarioContext context, boolean reuseParentConfig)", "modifiers": "private static", "return": "ScriptValue", "signature": "ScriptValue callWithCache(String callKey, ScriptValue called, String arg, ScenarioContext context, boolean reuseParentConfig)", "full_signature": "private static ScriptValue callWithCache(String callKey, ScriptValue called, String arg, ScenarioContext context, boolean reuseParentConfig)", "class_method_signature": "Script.callWithCache(String callKey, ScriptValue called, String arg, ScenarioContext context, boolean reuseParentConfig)", "testcase": false, "constructor": false}, {"identifier": "getIfVariableReference", "parameters": "(String text, ScenarioContext context)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue getIfVariableReference(String text, ScenarioContext context)", "full_signature": "public static ScriptValue getIfVariableReference(String text, ScenarioContext context)", "class_method_signature": "Script.getIfVariableReference(String text, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "evalKarateExpression", "parameters": "(String text, ScenarioContext context)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue evalKarateExpression(String text, ScenarioContext context)", "full_signature": "public static ScriptValue evalKarateExpression(String text, ScenarioContext context)", "class_method_signature": "Script.evalKarateExpression(String text, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "getValuebyName", "parameters": "(String name, ScenarioContext context)", "modifiers": "private static", "return": "ScriptValue", "signature": "ScriptValue getValuebyName(String name, ScenarioContext context)", "full_signature": "private static ScriptValue getValuebyName(String name, ScenarioContext context)", "class_method_signature": "Script.getValuebyName(String name, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "evalXmlPathOnVarByName", "parameters": "(String name, String path, ScenarioContext context)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue evalXmlPathOnVarByName(String name, String path, ScenarioContext context)", "full_signature": "public static ScriptValue evalXmlPathOnVarByName(String name, String path, ScenarioContext context)", "class_method_signature": "Script.evalXmlPathOnVarByName(String name, String path, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "evalXmlPathOnXmlNode", "parameters": "(Node doc, String path)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue evalXmlPathOnXmlNode(Node doc, String path)", "full_signature": "public static ScriptValue evalXmlPathOnXmlNode(Node doc, String path)", "class_method_signature": "Script.evalXmlPathOnXmlNode(Node doc, String path)", "testcase": false, "constructor": false}, {"identifier": "nodeToValue", "parameters": "(Node node)", "modifiers": "private static", "return": "ScriptValue", "signature": "ScriptValue nodeToValue(Node node)", "full_signature": "private static ScriptValue nodeToValue(Node node)", "class_method_signature": "Script.nodeToValue(Node node)", "testcase": false, "constructor": false}, {"identifier": "evalJsonPathOnVarByName", "parameters": "(String name, String exp, ScenarioContext context)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue evalJsonPathOnVarByName(String name, String exp, ScenarioContext context)", "full_signature": "public static ScriptValue evalJsonPathOnVarByName(String name, String exp, ScenarioContext context)", "class_method_signature": "Script.evalJsonPathOnVarByName(String name, String exp, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "evalJsExpression", "parameters": "(String exp, ScenarioContext context)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue evalJsExpression(String exp, ScenarioContext context)", "full_signature": "public static ScriptValue evalJsExpression(String exp, ScenarioContext context)", "class_method_signature": "Script.evalJsExpression(String exp, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "evalJsExpression", "parameters": "(String exp, ScenarioContext context, ScriptValue selfValue, Object root, Object parent)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue evalJsExpression(String exp, ScenarioContext context, ScriptValue selfValue, Object root, Object parent)", "full_signature": "public static ScriptValue evalJsExpression(String exp, ScenarioContext context, ScriptValue selfValue, Object root, Object parent)", "class_method_signature": "Script.evalJsExpression(String exp, ScenarioContext context, ScriptValue selfValue, Object root, Object parent)", "testcase": false, "constructor": false}, {"identifier": "isValidVariableName", "parameters": "(String name)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidVariableName(String name)", "full_signature": "public static boolean isValidVariableName(String name)", "class_method_signature": "Script.isValidVariableName(String name)", "testcase": false, "constructor": false}, {"identifier": "evalJsonEmbeddedExpressions", "parameters": "(DocumentContext doc, ScenarioContext context)", "modifiers": "public static", "return": "void", "signature": "void evalJsonEmbeddedExpressions(DocumentContext doc, ScenarioContext context)", "full_signature": "public static void evalJsonEmbeddedExpressions(DocumentContext doc, ScenarioContext context)", "class_method_signature": "Script.evalJsonEmbeddedExpressions(DocumentContext doc, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "evalJsonEmbeddedExpressions", "parameters": "(String path, Object o, ScenarioContext context, DocumentContext root)", "modifiers": "private static", "return": "void", "signature": "void evalJsonEmbeddedExpressions(String path, Object o, ScenarioContext context, DocumentContext root)", "full_signature": "private static void evalJsonEmbeddedExpressions(String path, Object o, ScenarioContext context, DocumentContext root)", "class_method_signature": "Script.evalJsonEmbeddedExpressions(String path, Object o, ScenarioContext context, DocumentContext root)", "testcase": false, "constructor": false}, {"identifier": "evalXmlEmbeddedExpressions", "parameters": "(Node node, ScenarioContext context)", "modifiers": "public static", "return": "void", "signature": "void evalXmlEmbeddedExpressions(Node node, ScenarioContext context)", "full_signature": "public static void evalXmlEmbeddedExpressions(Node node, ScenarioContext context)", "class_method_signature": "Script.evalXmlEmbeddedExpressions(Node node, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "copy", "parameters": "(String name, String exp, ScenarioContext context, boolean validateName)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue copy(String name, String exp, ScenarioContext context, boolean validateName)", "full_signature": "public static ScriptValue copy(String name, String exp, ScenarioContext context, boolean validateName)", "class_method_signature": "Script.copy(String name, String exp, ScenarioContext context, boolean validateName)", "testcase": false, "constructor": false}, {"identifier": "assign", "parameters": "(String name, String exp, ScenarioContext context)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue assign(String name, String exp, ScenarioContext context)", "full_signature": "public static ScriptValue assign(String name, String exp, ScenarioContext context)", "class_method_signature": "Script.assign(String name, String exp, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "validateVariableName", "parameters": "(String name)", "modifiers": "private static", "return": "void", "signature": "void validateVariableName(String name)", "full_signature": "private static void validateVariableName(String name)", "class_method_signature": "Script.validateVariableName(String name)", "testcase": false, "constructor": false}, {"identifier": "assign", "parameters": "(AssignType assignType, String name, String exp, ScenarioContext context, boolean validateName)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue assign(AssignType assignType, String name, String exp, ScenarioContext context, boolean validateName)", "full_signature": "public static ScriptValue assign(AssignType assignType, String name, String exp, ScenarioContext context, boolean validateName)", "class_method_signature": "Script.assign(AssignType assignType, String name, String exp, ScenarioContext context, boolean validateName)", "testcase": false, "constructor": false}, {"identifier": "toJsonDoc", "parameters": "(ScriptValue sv, ScenarioContext context)", "modifiers": "public static", "return": "DocumentContext", "signature": "DocumentContext toJsonDoc(ScriptValue sv, ScenarioContext context)", "full_signature": "public static DocumentContext toJsonDoc(ScriptValue sv, ScenarioContext context)", "class_method_signature": "Script.toJsonDoc(ScriptValue sv, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "toXmlDoc", "parameters": "(ScriptValue sv, ScenarioContext context)", "modifiers": "private static", "return": "Node", "signature": "Node toXmlDoc(ScriptValue sv, ScenarioContext context)", "full_signature": "private static Node toXmlDoc(ScriptValue sv, ScenarioContext context)", "class_method_signature": "Script.toXmlDoc(ScriptValue sv, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "matchNamed", "parameters": "(MatchType matchType, String expression, String path, String expected, ScenarioContext context)", "modifiers": "public static", "return": "AssertionResult", "signature": "AssertionResult matchNamed(MatchType matchType, String expression, String path, String expected, ScenarioContext context)", "full_signature": "public static AssertionResult matchNamed(MatchType matchType, String expression, String path, String expected, ScenarioContext context)", "class_method_signature": "Script.matchNamed(MatchType matchType, String expression, String path, String expected, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "matchScriptValue", "parameters": "(MatchType matchType, ScriptValue actual, String path, String expected, ScenarioContext context)", "modifiers": "public static", "return": "AssertionResult", "signature": "AssertionResult matchScriptValue(MatchType matchType, ScriptValue actual, String path, String expected, ScenarioContext context)", "full_signature": "public static AssertionResult matchScriptValue(MatchType matchType, ScriptValue actual, String path, String expected, ScenarioContext context)", "class_method_signature": "Script.matchScriptValue(MatchType matchType, ScriptValue actual, String path, String expected, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "matchString", "parameters": "(MatchType matchType, ScriptValue actual, String expected, String path, ScenarioContext context)", "modifiers": "public static", "return": "AssertionResult", "signature": "AssertionResult matchString(MatchType matchType, ScriptValue actual, String expected, String path, ScenarioContext context)", "full_signature": "public static AssertionResult matchString(MatchType matchType, ScriptValue actual, String expected, String path, ScenarioContext context)", "class_method_signature": "Script.matchString(MatchType matchType, ScriptValue actual, String expected, String path, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "isMacro", "parameters": "(String text)", "modifiers": "public static", "return": "boolean", "signature": "boolean isMacro(String text)", "full_signature": "public static boolean isMacro(String text)", "class_method_signature": "Script.isMacro(String text)", "testcase": false, "constructor": false}, {"identifier": "isOptionalMacro", "parameters": "(String text)", "modifiers": "public static", "return": "boolean", "signature": "boolean isOptionalMacro(String text)", "full_signature": "public static boolean isOptionalMacro(String text)", "class_method_signature": "Script.isOptionalMacro(String text)", "testcase": false, "constructor": false}, {"identifier": "stripParentheses", "parameters": "(String s)", "modifiers": "private static", "return": "String", "signature": "String stripParentheses(String s)", "full_signature": "private static String stripParentheses(String s)", "class_method_signature": "Script.stripParentheses(String s)", "testcase": false, "constructor": false}, {"identifier": "matchStringOrPattern", "parameters": "(char delimiter, String path, MatchType stringMatchType,\n            Object actRoot, Object actParent, ScriptValue actValue, String expected, ScenarioContext context)", "modifiers": "public static", "return": "AssertionResult", "signature": "AssertionResult matchStringOrPattern(char delimiter, String path, MatchType stringMatchType,\n            Object actRoot, Object actParent, ScriptValue actValue, String expected, ScenarioContext context)", "full_signature": "public static AssertionResult matchStringOrPattern(char delimiter, String path, MatchType stringMatchType,\n            Object actRoot, Object actParent, ScriptValue actValue, String expected, ScenarioContext context)", "class_method_signature": "Script.matchStringOrPattern(char delimiter, String path, MatchType stringMatchType,\n            Object actRoot, Object actParent, ScriptValue actValue, String expected, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "matchXml", "parameters": "(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "modifiers": "public static", "return": "AssertionResult", "signature": "AssertionResult matchXml(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "full_signature": "public static AssertionResult matchXml(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "class_method_signature": "Script.matchXml(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "getInnerMatchType", "parameters": "(MatchType outerMatchType)", "modifiers": "private static", "return": "MatchType", "signature": "MatchType getInnerMatchType(MatchType outerMatchType)", "full_signature": "private static MatchType getInnerMatchType(MatchType outerMatchType)", "class_method_signature": "Script.getInnerMatchType(MatchType outerMatchType)", "testcase": false, "constructor": false}, {"identifier": "matchJsonOrObject", "parameters": "(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "modifiers": "public static", "return": "AssertionResult", "signature": "AssertionResult matchJsonOrObject(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "full_signature": "public static AssertionResult matchJsonOrObject(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "class_method_signature": "Script.matchJsonOrObject(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "getLeafNameFromXmlPath", "parameters": "(String path)", "modifiers": "private static", "return": "String", "signature": "String getLeafNameFromXmlPath(String path)", "full_signature": "private static String getLeafNameFromXmlPath(String path)", "class_method_signature": "Script.getLeafNameFromXmlPath(String path)", "testcase": false, "constructor": false}, {"identifier": "toXmlString", "parameters": "(String elementName, Object o)", "modifiers": "private static", "return": "Object", "signature": "Object toXmlString(String elementName, Object o)", "full_signature": "private static Object toXmlString(String elementName, Object o)", "class_method_signature": "Script.toXmlString(String elementName, Object o)", "testcase": false, "constructor": false}, {"identifier": "quoteIfString", "parameters": "(Object o)", "modifiers": "private static", "return": "Object", "signature": "Object quoteIfString(Object o)", "full_signature": "private static Object quoteIfString(Object o)", "class_method_signature": "Script.quoteIfString(Object o)", "testcase": false, "constructor": false}, {"identifier": "isNegation", "parameters": "(MatchType type)", "modifiers": "private static", "return": "boolean", "signature": "boolean isNegation(MatchType type)", "full_signature": "private static boolean isNegation(MatchType type)", "class_method_signature": "Script.isNegation(MatchType type)", "testcase": false, "constructor": false}, {"identifier": "matchFailed", "parameters": "(MatchType matchType, String path,\n            Object actObject, Object expObject, String reason)", "modifiers": "public static", "return": "AssertionResult", "signature": "AssertionResult matchFailed(MatchType matchType, String path,\n            Object actObject, Object expObject, String reason)", "full_signature": "public static AssertionResult matchFailed(MatchType matchType, String path,\n            Object actObject, Object expObject, String reason)", "class_method_signature": "Script.matchFailed(MatchType matchType, String path,\n            Object actObject, Object expObject, String reason)", "testcase": false, "constructor": false}, {"identifier": "matchNestedObject", "parameters": "(char delimiter, String path, MatchType matchType,\n            Object actRoot, Object actParent, Object actObject, Object expObject, ScenarioContext context)", "modifiers": "public static", "return": "AssertionResult", "signature": "AssertionResult matchNestedObject(char delimiter, String path, MatchType matchType,\n            Object actRoot, Object actParent, Object actObject, Object expObject, ScenarioContext context)", "full_signature": "public static AssertionResult matchNestedObject(char delimiter, String path, MatchType matchType,\n            Object actRoot, Object actParent, Object actObject, Object expObject, ScenarioContext context)", "class_method_signature": "Script.matchNestedObject(char delimiter, String path, MatchType matchType,\n            Object actRoot, Object actParent, Object actObject, Object expObject, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "isPrimitive", "parameters": "(Class clazz)", "modifiers": "public static", "return": "boolean", "signature": "boolean isPrimitive(Class clazz)", "full_signature": "public static boolean isPrimitive(Class clazz)", "class_method_signature": "Script.isPrimitive(Class clazz)", "testcase": false, "constructor": false}, {"identifier": "buildListPath", "parameters": "(char delimiter, String path, int index)", "modifiers": "private static", "return": "String", "signature": "String buildListPath(char delimiter, String path, int index)", "full_signature": "private static String buildListPath(char delimiter, String path, int index)", "class_method_signature": "Script.buildListPath(char delimiter, String path, int index)", "testcase": false, "constructor": false}, {"identifier": "convertToBigDecimal", "parameters": "(Object o)", "modifiers": "private static", "return": "BigDecimal", "signature": "BigDecimal convertToBigDecimal(Object o)", "full_signature": "private static BigDecimal convertToBigDecimal(Object o)", "class_method_signature": "Script.convertToBigDecimal(Object o)", "testcase": false, "constructor": false}, {"identifier": "matchPrimitive", "parameters": "(MatchType matchType, String path, Object actObject, Object expObject)", "modifiers": "private static", "return": "AssertionResult", "signature": "AssertionResult matchPrimitive(MatchType matchType, String path, Object actObject, Object expObject)", "full_signature": "private static AssertionResult matchPrimitive(MatchType matchType, String path, Object actObject, Object expObject)", "class_method_signature": "Script.matchPrimitive(MatchType matchType, String path, Object actObject, Object expObject)", "testcase": false, "constructor": false}, {"identifier": "removeValueByPath", "parameters": "(String name, String path, ScenarioContext context)", "modifiers": "public static", "return": "void", "signature": "void removeValueByPath(String name, String path, ScenarioContext context)", "full_signature": "public static void removeValueByPath(String name, String path, ScenarioContext context)", "class_method_signature": "Script.removeValueByPath(String name, String path, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "setValueByPath", "parameters": "(String name, String path, ScriptValue value, ScenarioContext context)", "modifiers": "public static", "return": "void", "signature": "void setValueByPath(String name, String path, ScriptValue value, ScenarioContext context)", "full_signature": "public static void setValueByPath(String name, String path, ScriptValue value, ScenarioContext context)", "class_method_signature": "Script.setValueByPath(String name, String path, ScriptValue value, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "setValueByPath", "parameters": "(String name, String path, String exp, ScenarioContext context)", "modifiers": "public static", "return": "void", "signature": "void setValueByPath(String name, String path, String exp, ScenarioContext context)", "full_signature": "public static void setValueByPath(String name, String path, String exp, ScenarioContext context)", "class_method_signature": "Script.setValueByPath(String name, String path, String exp, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "setValueByPath", "parameters": "(String name, String path, String exp, boolean delete, ScenarioContext context, boolean viaTable)", "modifiers": "public static", "return": "void", "signature": "void setValueByPath(String name, String path, String exp, boolean delete, ScenarioContext context, boolean viaTable)", "full_signature": "public static void setValueByPath(String name, String path, String exp, boolean delete, ScenarioContext context, boolean viaTable)", "class_method_signature": "Script.setValueByPath(String name, String path, String exp, boolean delete, ScenarioContext context, boolean viaTable)", "testcase": false, "constructor": false}, {"identifier": "setValueByPath", "parameters": "(String name, String path, ScriptValue value, boolean delete, ScenarioContext context, boolean viaTable)", "modifiers": "public static", "return": "void", "signature": "void setValueByPath(String name, String path, ScriptValue value, boolean delete, ScenarioContext context, boolean viaTable)", "full_signature": "public static void setValueByPath(String name, String path, ScriptValue value, boolean delete, ScenarioContext context, boolean viaTable)", "class_method_signature": "Script.setValueByPath(String name, String path, ScriptValue value, boolean delete, ScenarioContext context, boolean viaTable)", "testcase": false, "constructor": false}, {"identifier": "call", "parameters": "(ScriptValue called, String argString, ScenarioContext context, boolean reuseParentConfig)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue call(ScriptValue called, String argString, ScenarioContext context, boolean reuseParentConfig)", "full_signature": "public static ScriptValue call(ScriptValue called, String argString, ScenarioContext context, boolean reuseParentConfig)", "class_method_signature": "Script.call(ScriptValue called, String argString, ScenarioContext context, boolean reuseParentConfig)", "testcase": false, "constructor": false}, {"identifier": "evalJavaFunctionCall", "parameters": "(Function function, Object callArg, ScenarioContext context)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue evalJavaFunctionCall(Function function, Object callArg, ScenarioContext context)", "full_signature": "public static ScriptValue evalJavaFunctionCall(Function function, Object callArg, ScenarioContext context)", "class_method_signature": "Script.evalJavaFunctionCall(Function function, Object callArg, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "evalJsFunctionCall", "parameters": "(ScriptObjectMirror som, Object callArg, ScenarioContext context)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue evalJsFunctionCall(ScriptObjectMirror som, Object callArg, ScenarioContext context)", "full_signature": "public static ScriptValue evalJsFunctionCall(ScriptObjectMirror som, Object callArg, ScenarioContext context)", "class_method_signature": "Script.evalJsFunctionCall(ScriptObjectMirror som, Object callArg, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "evalFeatureCall", "parameters": "(Feature feature, Object callArg, ScenarioContext context, boolean reuseParentConfig)", "modifiers": "public static", "return": "ScriptValue", "signature": "ScriptValue evalFeatureCall(Feature feature, Object callArg, ScenarioContext context, boolean reuseParentConfig)", "full_signature": "public static ScriptValue evalFeatureCall(Feature feature, Object callArg, ScenarioContext context, boolean reuseParentConfig)", "class_method_signature": "Script.evalFeatureCall(Feature feature, Object callArg, ScenarioContext context, boolean reuseParentConfig)", "testcase": false, "constructor": false}, {"identifier": "evalFeatureCall", "parameters": "(CallContext callContext)", "modifiers": "private static", "return": "ScriptValue", "signature": "ScriptValue evalFeatureCall(CallContext callContext)", "full_signature": "private static ScriptValue evalFeatureCall(CallContext callContext)", "class_method_signature": "Script.evalFeatureCall(CallContext callContext)", "testcase": false, "constructor": false}, {"identifier": "parseCallArgs", "parameters": "(String line)", "modifiers": "public static", "return": "StringUtils.Pair", "signature": "StringUtils.Pair parseCallArgs(String line)", "full_signature": "public static StringUtils.Pair parseCallArgs(String line)", "class_method_signature": "Script.parseCallArgs(String line)", "testcase": false, "constructor": false}, {"identifier": "callAndUpdateConfigAndAlsoVarsIfMapReturned", "parameters": "(boolean callOnce, String name, String arg, ScenarioContext context)", "modifiers": "public static", "return": "void", "signature": "void callAndUpdateConfigAndAlsoVarsIfMapReturned(boolean callOnce, String name, String arg, ScenarioContext context)", "full_signature": "public static void callAndUpdateConfigAndAlsoVarsIfMapReturned(boolean callOnce, String name, String arg, ScenarioContext context)", "class_method_signature": "Script.callAndUpdateConfigAndAlsoVarsIfMapReturned(boolean callOnce, String name, String arg, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "assertBoolean", "parameters": "(String expression, ScenarioContext context)", "modifiers": "public static", "return": "AssertionResult", "signature": "AssertionResult assertBoolean(String expression, ScenarioContext context)", "full_signature": "public static AssertionResult assertBoolean(String expression, ScenarioContext context)", "class_method_signature": "Script.assertBoolean(String expression, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "replacePlaceholderText", "parameters": "(String text, String token, String replaceWith, ScenarioContext context)", "modifiers": "public static", "return": "String", "signature": "String replacePlaceholderText(String text, String token, String replaceWith, ScenarioContext context)", "full_signature": "public static String replacePlaceholderText(String text, String token, String replaceWith, ScenarioContext context)", "class_method_signature": "Script.replacePlaceholderText(String text, String token, String replaceWith, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "replacePlaceholders", "parameters": "(String text, List<Map<String, String>> list, ScenarioContext context)", "modifiers": "public static", "return": "String", "signature": "String replacePlaceholders(String text, List<Map<String, String>> list, ScenarioContext context)", "full_signature": "public static String replacePlaceholders(String text, List<Map<String, String>> list, ScenarioContext context)", "class_method_signature": "Script.replacePlaceholders(String text, List<Map<String, String>> list, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "evalTable", "parameters": "(List<Map<String, String>> list, ScenarioContext context)", "modifiers": "public static", "return": "List<Map<String, Object>>", "signature": "List<Map<String, Object>> evalTable(List<Map<String, String>> list, ScenarioContext context)", "full_signature": "public static List<Map<String, Object>> evalTable(List<Map<String, String>> list, ScenarioContext context)", "class_method_signature": "Script.evalTable(List<Map<String, String>> list, ScenarioContext context)", "testcase": false, "constructor": false}, {"identifier": "setByPathTable", "parameters": "(String name, String path, List<Map<String, String>> list, ScenarioContext context)", "modifiers": "public static", "return": "void", "signature": "void setByPathTable(String name, String path, List<Map<String, String>> list, ScenarioContext context)", "full_signature": "public static void setByPathTable(String name, String path, List<Map<String, String>> list, ScenarioContext context)", "class_method_signature": "Script.setByPathTable(String name, String path, List<Map<String, String>> list, ScenarioContext context)", "testcase": false, "constructor": false}], "file": "karate-core/src/main/java/com/intuit/karate/Script.java"}, "focal_method": {"identifier": "matchJsonOrObject", "parameters": "(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "modifiers": "public static", "return": "AssertionResult", "body": "public static AssertionResult matchJsonOrObject(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context) {\n        DocumentContext actualDoc;\n        switch (actual.getType()) {\n            case JSON:\n            case MAP:\n            case LIST:\n                actualDoc = actual.getAsJsonDocument();\n                break;\n            case XML: // auto convert !\n                actualDoc = XmlUtils.toJsonDoc(actual.getValue(Node.class));\n                break;\n            case STRING: // an edge case when the variable is a plain string not JSON, so switch to plain string compare\n            case INPUT_STREAM:\n                String actualString = actual.getAsString();\n                ScriptValue expectedString = evalKarateExpression(expression, context);\n                // exit the function early\n                if (!expectedString.isStringOrStream()) {\n                    return matchFailed(matchType, path, actualString, expectedString.getValue(),\n                            \"type of actual value is 'string' but that of expected is \" + expectedString.getType());\n                } else {\n                    return matchStringOrPattern('.', path, matchType, null, null, actual, expectedString.getAsString(), context);\n                }\n            case PRIMITIVE: // an edge case when the variable is non-string, not-json (number / boolean)\n                ScriptValue expected = evalKarateExpression(expression, context);\n                if (expected.isStringOrStream()) { // fuzzy match macro\n                    return matchStringOrPattern('.', path, matchType, null, null, actual, expected.getAsString(), context);\n                } else {\n                    return matchPrimitive(matchType, path, actual.getValue(), expected.getValue());\n                }\n            case NULL: // edge case, assume that this is the root variable that is null and the match is for an optional e.g. '##string'\n                ScriptValue expectedNull = evalKarateExpression(expression, context);\n                if (expectedNull.isNull()) {\n                    if (matchType == MatchType.NOT_EQUALS) {\n                        return matchFailed(matchType, path, null, null, \"actual and expected values are both null\");\n                    }\n                    return AssertionResult.PASS;\n                } else if (!expectedNull.isStringOrStream()) { // primitive or anything which is not a string\n                    if (matchType == MatchType.NOT_EQUALS) {\n                        return AssertionResult.PASS;\n                    }\n                    return matchFailed(matchType, path, null, expectedNull.getValue(), \"actual value is null but expected is \" + expectedNull);\n                } else {\n                    return matchStringOrPattern('.', path, matchType, null, null, actual, expectedNull.getAsString(), context);\n                }\n            case BYTE_ARRAY:\n                ScriptValue expectedBytesValue = evalKarateExpression(expression, context);\n                byte[] expectedBytes = expectedBytesValue.getAsByteArray();\n                byte[] actualBytes = actual.getAsByteArray();\n                if (Arrays.equals(expectedBytes, actualBytes)) {\n                    if (matchType == MatchType.NOT_EQUALS) {\n                        return matchFailed(matchType, path, actualBytes, expectedBytes, \"actual and expected byte-arrays are not equal\");\n                    }\n                    return AssertionResult.PASS;\n                } else {\n                    if (matchType == MatchType.NOT_EQUALS) {\n                        return AssertionResult.PASS;\n                    }\n                    return matchFailed(matchType, path, actualBytes, expectedBytes, \"actual and expected byte-arrays are not equal\");\n                }\n            default:\n                throw new RuntimeException(\"not json, cannot do json path for value: \" + actual + \", path: \" + path);\n        }\n        ScriptValue expected = evalKarateExpressionForMatch(expression, context);\n        Object actObject;\n        try {\n            actObject = actualDoc.read(path); // note that the path for actObject is 'reset' to '$' here\n        } catch (PathNotFoundException e) {\n            if (expected.isString()) {\n                String expString = expected.getAsString();\n                if (isOptionalMacro(expString) || \"#notpresent\".equals(expString) || \"#ignore\".equals(expString)) {\n                    return AssertionResult.PASS;\n                }\n            }\n            return matchFailed(matchType, path, null, expected.getValue(), \"actual json-path does not exist\");\n        }\n        Object expObject;\n        switch (expected.getType()) {\n            case JSON: // convert to map or list\n                expObject = expected.getValue(DocumentContext.class).read(\"$\");\n                break;\n            default:\n                expObject = expected.getValue();\n        }\n        switch (matchType) {\n            case CONTAINS:\n            case NOT_CONTAINS:\n            case CONTAINS_ONLY:\n            case CONTAINS_ANY:\n            case CONTAINS_DEEP:\n                if (actObject instanceof List && !(expObject instanceof List)) { // if RHS is not a list, make it so\n                    expObject = Collections.singletonList(expObject);\n                }\n            case NOT_EQUALS:\n            case EQUALS:\n                return matchNestedObject('.', path, matchType, actualDoc, null, actObject, expObject, context);\n            case EACH_CONTAINS:\n            case EACH_NOT_CONTAINS:\n            case EACH_CONTAINS_ONLY:\n            case EACH_CONTAINS_ANY:\n            case EACH_NOT_EQUALS:\n            case EACH_EQUALS:\n                if (actObject instanceof List) {\n                    List actList = (List) actObject;\n                    MatchType listMatchType = getInnerMatchType(matchType);\n                    int actSize = actList.size();\n                    for (int i = 0; i < actSize; i++) {\n                        Object actListObject = actList.get(i);\n                        AssertionResult ar = matchNestedObject('.', \"$[\" + i + \"]\", listMatchType, actObject, actListObject, actListObject, expObject, context);\n                        if (!ar.pass) {\n                            if (matchType == MatchType.EACH_NOT_EQUALS) {\n                                return AssertionResult.PASS; // exit early\n                            } else {\n                                return ar; // fail early\n                            }\n                        }\n                    }\n                    // if we reached here all list items (each) matched\n                    if (matchType == MatchType.EACH_NOT_EQUALS) {\n                        return matchFailed(matchType, path, actual.getValue(), expected.getValue(), \"all list items matched\");\n                    }\n                    return AssertionResult.PASS;\n                } else {\n                    throw new RuntimeException(\"'match each' failed, not a json array: + \" + actual + \", path: \" + path);\n                }\n            default: // dead code\n                throw new RuntimeException(\"unexpected match type: \" + matchType);\n        }\n    }", "signature": "AssertionResult matchJsonOrObject(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "full_signature": "public static AssertionResult matchJsonOrObject(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "class_method_signature": "Script.matchJsonOrObject(MatchType matchType, ScriptValue actual, String path, String expression, ScenarioContext context)", "testcase": false, "constructor": false, "invocations": ["getType", "getAsJsonDocument", "toJsonDoc", "getValue", "getAsString", "evalKarateExpression", "isStringOrStream", "matchFailed", "getValue", "getType", "matchStringOrPattern", "getAsString", "evalKarateExpression", "isStringOrStream", "matchStringOrPattern", "getAsString", "matchPrimitive", "getValue", "getValue", "evalKarateExpression", "isNull", "matchFailed", "isStringOrStream", "matchFailed", "getValue", "matchStringOrPattern", "getAsString", "evalKarateExpression", "getAsByteArray", "getAsByteArray", "equals", "matchFailed", "matchFailed", "evalKarateExpressionForMatch", "read", "isString", "getAsString", "isOptionalMacro", "equals", "equals", "matchFailed", "getValue", "getType", "read", "getValue", "getValue", "singletonList", "matchNestedObject", "getInnerMatchType", "size", "get", "matchNestedObject", "matchFailed", "getValue", "getValue"]}, "repository": {"repo_id": 81226206, "url": "https://github.com/intuit/karate", "stars": 2712, "created": "2/7/2017 3:59:17 PM +00:00", "updates": "2020-01-27T21:00:57+00:00", "fork": "False", "license": "licensed"}}