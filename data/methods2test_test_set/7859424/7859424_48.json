{"test_class": {"identifier": "PlayerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Player player;", "modifier": "private", "type": "Player", "declarator": "player", "var_name": "player"}, {"original_string": "private CoordinateSystem coords;", "modifier": "private", "type": "CoordinateSystem", "declarator": "coords", "var_name": "coords"}], "file": "src/edu/lclark/orego/mcts/PlayerTest.java"}, "test_case": {"identifier": "testTableOverflow", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testTableOverflow() {\n\t\t// This tests a bug, occasionally encountered on KGS, where Orego\n\t\t// crashes while pondering because the transposition table fills up\n\t\tplayer = new PlayerBuilder().msecPerMove(2000).threads(8).boardWidth(5).memorySize(1).openingBook(false).build();\n\t\t// If there is a problem, this will crash\n\t\tplayer.bestMove();\n\t}", "signature": "void testTableOverflow()", "full_signature": "@Test public void testTableOverflow()", "class_method_signature": "PlayerTest.testTableOverflow()", "testcase": true, "constructor": false, "invocations": ["build", "openingBook", "memorySize", "boardWidth", "threads", "msecPerMove", "bestMove"]}, "focal_class": {"identifier": "Player", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Board board;", "modifier": "private final", "type": "Board", "declarator": "board", "var_name": "board"}, {"original_string": "private OpeningBook book;", "modifier": "private", "type": "OpeningBook", "declarator": "book", "var_name": "book"}, {"original_string": "private boolean cleanupMode;", "modifier": "private", "type": "boolean", "declarator": "cleanupMode", "var_name": "cleanupMode"}, {"original_string": "private final CoordinateSystem coords;", "modifier": "private final", "type": "CoordinateSystem", "declarator": "coords", "var_name": "coords"}, {"original_string": "private boolean coupDeGrace;", "modifier": "private", "type": "boolean", "declarator": "coupDeGrace", "var_name": "coupDeGrace"}, {"original_string": "private TreeDescender descender;", "modifier": "private", "type": "TreeDescender", "declarator": "descender", "var_name": "descender"}, {"original_string": "private ExecutorService executor;", "modifier": "private", "type": "ExecutorService", "declarator": "executor", "var_name": "executor"}, {"original_string": "private final FinalScorer finalScorer;", "modifier": "private final", "type": "FinalScorer", "declarator": "finalScorer", "var_name": "finalScorer"}, {"original_string": "private final HistoryObserver historyObserver;", "modifier": "private final", "type": "HistoryObserver", "declarator": "historyObserver", "var_name": "historyObserver"}, {"original_string": "private boolean keepRunning;", "modifier": "private", "type": "boolean", "declarator": "keepRunning", "var_name": "keepRunning"}, {"original_string": "private CountDownLatch latch;", "modifier": "private", "type": "CountDownLatch", "declarator": "latch", "var_name": "latch"}, {"original_string": "private int msecPerMove;", "modifier": "private", "type": "int", "declarator": "msecPerMove", "var_name": "msecPerMove"}, {"original_string": "private boolean ponder;", "modifier": "private", "type": "boolean", "declarator": "ponder", "var_name": "ponder"}, {"original_string": "private final McRunnable[] runnables;", "modifier": "private final", "type": "McRunnable[]", "declarator": "runnables", "var_name": "runnables"}, {"original_string": "private boolean timeLeftWasSent;", "modifier": "private", "type": "boolean", "declarator": "timeLeftWasSent", "var_name": "timeLeftWasSent"}, {"original_string": "private TimeManager timeManager;", "modifier": "private", "type": "TimeManager", "declarator": "timeManager", "var_name": "timeManager"}, {"original_string": "private TreeUpdater updater;", "modifier": "private", "type": "TreeUpdater", "declarator": "updater", "var_name": "updater"}], "methods": [{"identifier": "Player", "parameters": "(int threads, CopiableStructure stuff)", "modifiers": "public", "return": "", "signature": " Player(int threads, CopiableStructure stuff)", "full_signature": "public  Player(int threads, CopiableStructure stuff)", "class_method_signature": "Player.Player(int threads, CopiableStructure stuff)", "testcase": false, "constructor": true}, {"identifier": "acceptMove", "parameters": "(short point)", "modifiers": "public", "return": "Legality", "signature": "Legality acceptMove(short point)", "full_signature": "public Legality acceptMove(short point)", "class_method_signature": "Player.acceptMove(short point)", "testcase": false, "constructor": false}, {"identifier": "bestMove", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short bestMove()", "full_signature": "public short bestMove()", "class_method_signature": "Player.bestMove()", "testcase": false, "constructor": false}, {"identifier": "canWinByPassing", "parameters": "()", "modifiers": "", "return": "boolean", "signature": "boolean canWinByPassing()", "full_signature": " boolean canWinByPassing()", "class_method_signature": "Player.canWinByPassing()", "testcase": false, "constructor": false}, {"identifier": "clear", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void clear()", "full_signature": "public void clear()", "class_method_signature": "Player.clear()", "testcase": false, "constructor": false}, {"identifier": "descend", "parameters": "(McRunnable runnable)", "modifiers": "public", "return": "void", "signature": "void descend(McRunnable runnable)", "full_signature": "public void descend(McRunnable runnable)", "class_method_signature": "Player.descend(McRunnable runnable)", "testcase": false, "constructor": false}, {"identifier": "endGame", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void endGame()", "full_signature": "public void endGame()", "class_method_signature": "Player.endGame()", "testcase": false, "constructor": false}, {"identifier": "finalScore", "parameters": "()", "modifiers": "public", "return": "double", "signature": "double finalScore()", "full_signature": "public double finalScore()", "class_method_signature": "Player.finalScore()", "testcase": false, "constructor": false}, {"identifier": "findCleanupMoves", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean findCleanupMoves()", "full_signature": "private boolean findCleanupMoves()", "class_method_signature": "Player.findCleanupMoves()", "testcase": false, "constructor": false}, {"identifier": "findDeadStones", "parameters": "(double threshold, StoneColor color)", "modifiers": "public", "return": "ShortSet", "signature": "ShortSet findDeadStones(double threshold, StoneColor color)", "full_signature": "public ShortSet findDeadStones(double threshold, StoneColor color)", "class_method_signature": "Player.findDeadStones(double threshold, StoneColor color)", "testcase": false, "constructor": false}, {"identifier": "getBoard", "parameters": "()", "modifiers": "public", "return": "Board", "signature": "Board getBoard()", "full_signature": "public Board getBoard()", "class_method_signature": "Player.getBoard()", "testcase": false, "constructor": false}, {"identifier": "getDescender", "parameters": "()", "modifiers": "", "return": "TreeDescender", "signature": "TreeDescender getDescender()", "full_signature": " TreeDescender getDescender()", "class_method_signature": "Player.getDescender()", "testcase": false, "constructor": false}, {"identifier": "getFinalScorer", "parameters": "()", "modifiers": "public", "return": "FinalScorer", "signature": "FinalScorer getFinalScorer()", "full_signature": "public FinalScorer getFinalScorer()", "class_method_signature": "Player.getFinalScorer()", "testcase": false, "constructor": false}, {"identifier": "getMcRunnable", "parameters": "(int i)", "modifiers": "public", "return": "McRunnable", "signature": "McRunnable getMcRunnable(int i)", "full_signature": "public McRunnable getMcRunnable(int i)", "class_method_signature": "Player.getMcRunnable(int i)", "testcase": false, "constructor": false}, {"identifier": "getMsecPerMove", "parameters": "()", "modifiers": "", "return": "int", "signature": "int getMsecPerMove()", "full_signature": " int getMsecPerMove()", "class_method_signature": "Player.getMsecPerMove()", "testcase": false, "constructor": false}, {"identifier": "getNumberOfThreads", "parameters": "()", "modifiers": "", "return": "int", "signature": "int getNumberOfThreads()", "full_signature": " int getNumberOfThreads()", "class_method_signature": "Player.getNumberOfThreads()", "testcase": false, "constructor": false}, {"identifier": "getPlayoutCount", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getPlayoutCount()", "full_signature": "public int getPlayoutCount()", "class_method_signature": "Player.getPlayoutCount()", "testcase": false, "constructor": false}, {"identifier": "getRoot", "parameters": "()", "modifiers": "public", "return": "SearchNode", "signature": "SearchNode getRoot()", "full_signature": "public SearchNode getRoot()", "class_method_signature": "Player.getRoot()", "testcase": false, "constructor": false}, {"identifier": "getTimeManager", "parameters": "()", "modifiers": "public", "return": "TimeManager", "signature": "TimeManager getTimeManager()", "full_signature": "public TimeManager getTimeManager()", "class_method_signature": "Player.getTimeManager()", "testcase": false, "constructor": false}, {"identifier": "getUpdater", "parameters": "()", "modifiers": "", "return": "TreeUpdater", "signature": "TreeUpdater getUpdater()", "full_signature": " TreeUpdater getUpdater()", "class_method_signature": "Player.getUpdater()", "testcase": false, "constructor": false}, {"identifier": "notifyMcRunnableDone", "parameters": "()", "modifiers": "", "return": "void", "signature": "void notifyMcRunnableDone()", "full_signature": " void notifyMcRunnableDone()", "class_method_signature": "Player.notifyMcRunnableDone()", "testcase": false, "constructor": false}, {"identifier": "ponder", "parameters": "(boolean pondering)", "modifiers": "public", "return": "void", "signature": "void ponder(boolean pondering)", "full_signature": "public void ponder(boolean pondering)", "class_method_signature": "Player.ponder(boolean pondering)", "testcase": false, "constructor": false}, {"identifier": "setCleanupMode", "parameters": "(boolean cleanup)", "modifiers": "public", "return": "void", "signature": "void setCleanupMode(boolean cleanup)", "full_signature": "public void setCleanupMode(boolean cleanup)", "class_method_signature": "Player.setCleanupMode(boolean cleanup)", "testcase": false, "constructor": false}, {"identifier": "setColorToPlay", "parameters": "(StoneColor stoneColor)", "modifiers": "public", "return": "void", "signature": "void setColorToPlay(StoneColor stoneColor)", "full_signature": "public void setColorToPlay(StoneColor stoneColor)", "class_method_signature": "Player.setColorToPlay(StoneColor stoneColor)", "testcase": false, "constructor": false}, {"identifier": "setCoupDeGrace", "parameters": "(boolean enabled)", "modifiers": "public", "return": "void", "signature": "void setCoupDeGrace(boolean enabled)", "full_signature": "public void setCoupDeGrace(boolean enabled)", "class_method_signature": "Player.setCoupDeGrace(boolean enabled)", "testcase": false, "constructor": false}, {"identifier": "setMsecPerMove", "parameters": "(int msec)", "modifiers": "public", "return": "void", "signature": "void setMsecPerMove(int msec)", "full_signature": "public void setMsecPerMove(int msec)", "class_method_signature": "Player.setMsecPerMove(int msec)", "testcase": false, "constructor": false}, {"identifier": "setOpeningBook", "parameters": "(OpeningBook book)", "modifiers": "public", "return": "void", "signature": "void setOpeningBook(OpeningBook book)", "full_signature": "public void setOpeningBook(OpeningBook book)", "class_method_signature": "Player.setOpeningBook(OpeningBook book)", "testcase": false, "constructor": false}, {"identifier": "setRemainingTime", "parameters": "(int seconds)", "modifiers": "public", "return": "void", "signature": "void setRemainingTime(int seconds)", "full_signature": "public void setRemainingTime(int seconds)", "class_method_signature": "Player.setRemainingTime(int seconds)", "testcase": false, "constructor": false}, {"identifier": "setTimeManager", "parameters": "(TimeManager time)", "modifiers": "public", "return": "void", "signature": "void setTimeManager(TimeManager time)", "full_signature": "public void setTimeManager(TimeManager time)", "class_method_signature": "Player.setTimeManager(TimeManager time)", "testcase": false, "constructor": false}, {"identifier": "setTreeDescender", "parameters": "(TreeDescender descender)", "modifiers": "public", "return": "void", "signature": "void setTreeDescender(TreeDescender descender)", "full_signature": "public void setTreeDescender(TreeDescender descender)", "class_method_signature": "Player.setTreeDescender(TreeDescender descender)", "testcase": false, "constructor": false}, {"identifier": "setTreeUpdater", "parameters": "(TreeUpdater updater)", "modifiers": "public", "return": "void", "signature": "void setTreeUpdater(TreeUpdater updater)", "full_signature": "public void setTreeUpdater(TreeUpdater updater)", "class_method_signature": "Player.setTreeUpdater(TreeUpdater updater)", "testcase": false, "constructor": false}, {"identifier": "setUpHandicap", "parameters": "(int handicapSize)", "modifiers": "public", "return": "void", "signature": "void setUpHandicap(int handicapSize)", "full_signature": "public void setUpHandicap(int handicapSize)", "class_method_signature": "Player.setUpHandicap(int handicapSize)", "testcase": false, "constructor": false}, {"identifier": "setUpSgfGame", "parameters": "(List<Short> moves)", "modifiers": "@SuppressWarnings(\"boxing\") public", "return": "void", "signature": "void setUpSgfGame(List<Short> moves)", "full_signature": "@SuppressWarnings(\"boxing\") public void setUpSgfGame(List<Short> moves)", "class_method_signature": "Player.setUpSgfGame(List<Short> moves)", "testcase": false, "constructor": false}, {"identifier": "shouldKeepRunning", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean shouldKeepRunning()", "full_signature": "public boolean shouldKeepRunning()", "class_method_signature": "Player.shouldKeepRunning()", "testcase": false, "constructor": false}, {"identifier": "startThreads", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void startThreads()", "full_signature": "private void startThreads()", "class_method_signature": "Player.startThreads()", "testcase": false, "constructor": false}, {"identifier": "stopThreads", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void stopThreads()", "full_signature": "private void stopThreads()", "class_method_signature": "Player.stopThreads()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "Player.toString()", "testcase": false, "constructor": false}, {"identifier": "undo", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean undo()", "full_signature": "public boolean undo()", "class_method_signature": "Player.undo()", "testcase": false, "constructor": false}, {"identifier": "updateTree", "parameters": "(Color winner, McRunnable mcRunnable)", "modifiers": "public", "return": "void", "signature": "void updateTree(Color winner, McRunnable mcRunnable)", "full_signature": "public void updateTree(Color winner, McRunnable mcRunnable)", "class_method_signature": "Player.updateTree(Color winner, McRunnable mcRunnable)", "testcase": false, "constructor": false}, {"identifier": "getLiveStones", "parameters": "(double threshold)", "modifiers": "public", "return": "ShortSet", "signature": "ShortSet getLiveStones(double threshold)", "full_signature": "public ShortSet getLiveStones(double threshold)", "class_method_signature": "Player.getLiveStones(double threshold)", "testcase": false, "constructor": false}, {"identifier": "goguiSearchValues", "parameters": "()", "modifiers": "@SuppressWarnings(\"boxing\") public", "return": "String", "signature": "String goguiSearchValues()", "full_signature": "@SuppressWarnings(\"boxing\") public String goguiSearchValues()", "class_method_signature": "Player.goguiSearchValues()", "testcase": false, "constructor": false}, {"identifier": "goguiGetWins", "parameters": "()", "modifiers": "@SuppressWarnings(\"boxing\") public", "return": "String", "signature": "String goguiGetWins()", "full_signature": "@SuppressWarnings(\"boxing\") public String goguiGetWins()", "class_method_signature": "Player.goguiGetWins()", "testcase": false, "constructor": false}, {"identifier": "goguiGetWinrate", "parameters": "()", "modifiers": "@SuppressWarnings(\"boxing\") public", "return": "String", "signature": "String goguiGetWinrate()", "full_signature": "@SuppressWarnings(\"boxing\") public String goguiGetWinrate()", "class_method_signature": "Player.goguiGetWinrate()", "testcase": false, "constructor": false}, {"identifier": "goguiGetRuns", "parameters": "()", "modifiers": "@SuppressWarnings(\"boxing\") public", "return": "String", "signature": "String goguiGetRuns()", "full_signature": "@SuppressWarnings(\"boxing\") public String goguiGetRuns()", "class_method_signature": "Player.goguiGetRuns()", "testcase": false, "constructor": false}], "file": "src/edu/lclark/orego/mcts/Player.java"}, "focal_method": {"identifier": "bestMove", "parameters": "()", "modifiers": "public", "return": "short", "body": "public short bestMove() {\n\t\tstopThreads();\n\t\tfinal short move = book.nextMove(board);\n\t\tif (move != NO_POINT) {\n\t\t\treturn move;\n\t\t}\n\t\tif (cleanupMode) {\n\t\t\tif (!findCleanupMoves()) {\n\t\t\t\treturn PASS;\n\t\t\t}\n\t\t} else if (board.getPasses() == 1 && coupDeGrace) {\n\t\t\tif (canWinByPassing()) {\n\t\t\t\treturn PASS;\n\t\t\t}\n\t\t\tfindCleanupMoves();\n\t\t}\n\t\tif (!timeLeftWasSent) {\n\t\t\t// No time left signal was received\n\t\t\tstartThreads();\n\t\t\ttry {\n\t\t\t\tThread.sleep(msecPerMove);\n\t\t\t} catch (final InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\tstopThreads();\n\t\t} else {\n\t\t\t// Time left signal was received\n\t\t\ttimeManager.startNewTurn();\n\t\t\tmsecPerMove = timeManager.getMsec();\n\t\t\tlog(\"Allocating \" + msecPerMove + \" msec\");\n\t\t\tdo {\n\t\t\t\tstartThreads();\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(msecPerMove);\n\t\t\t\t} catch (final InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n\t\t\t\tstopThreads();\n\t\t\t\tmsecPerMove = timeManager.getMsec();\n\t\t\t} while (msecPerMove > 0);\n\t\t}\n\t\tlong playouts = 0;\n\t\tfor (McRunnable runnable : runnables) {\n\t\t\tplayouts += runnable.getPlayoutsCompleted();\n\t\t}\n\t\tLogging.log(\"Turn : \" + board.getTurn() + \" Playouts : \" + playouts);\n\t\treturn descender.bestPlayMove();\n\t}", "signature": "short bestMove()", "full_signature": "public short bestMove()", "class_method_signature": "Player.bestMove()", "testcase": false, "constructor": false, "invocations": ["stopThreads", "nextMove", "findCleanupMoves", "getPasses", "canWinByPassing", "findCleanupMoves", "startThreads", "sleep", "printStackTrace", "exit", "stopThreads", "startNewTurn", "getMsec", "log", "startThreads", "sleep", "printStackTrace", "exit", "stopThreads", "getMsec", "getPlayoutsCompleted", "log", "getTurn", "bestPlayMove"]}, "repository": {"repo_id": 7859424, "url": "https://github.com/Orego/Orego", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 35, "size": 1341444, "license": "licensed"}}