{"test_class": {"identifier": "DdlParsersTest", "superclass": "extends DdlParserTestHelper", "interfaces": "", "fields": [{"original_string": "private DdlParsers parsers;", "modifier": "private", "type": "DdlParsers", "declarator": "parsers", "var_name": "parsers"}, {"original_string": "public static final String DDL_TEST_FILE_PATH = \"ddl/\";", "modifier": "public static final", "type": "String", "declarator": "DDL_TEST_FILE_PATH = \"ddl/\"", "var_name": "DDL_TEST_FILE_PATH"}], "file": "sequencers/modeshape-sequencer-ddl/src/test/java/org/modeshape/sequencer/ddl/DdlParsersTest.java"}, "test_case": {"identifier": "shouldParseUnterminatedOracleFile", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldParseUnterminatedOracleFile() {\n        printTest(\"shouldParseUnterminatedOracleFile()\");\n        String content = getFileContent(DDL_TEST_FILE_PATH + \"GFM_Physical.ddl\");\n\n        rootNode = parsers.parse(content, null);\n        assertEquals(\"ORACLE\", rootNode.getProperty(StandardDdlLexicon.PARSER_ID));\n\n        // printNodeChildren(rootNode);\n        setPrintToConsole(true);\n\n        final AstNodeFactory nodeFactory = new AstNodeFactory();\n        List<AstNode> problems = nodeFactory.getChildrenForType(rootNode, TYPE_PROBLEM);\n        for (AstNode problem : problems) {\n            printTest(problem.toString());\n        }\n\n        assertThat(rootNode.getChildCount(), is(123));\n\n        List<AstNode> schemaNodes = nodeFactory.getChildrenForType(rootNode, TYPE_CREATE_SCHEMA_STATEMENT);\n        assertThat(schemaNodes.size(), is(1));\n        assertThat(schemaNodes.get(0).getChildCount(), is(53));\n        assertThat(schemaNodes.get(0).getName(), is(\"GLOBALFORCEMGMT\"));\n        List<AstNode> alterNodes = nodeFactory.getChildrenForType(rootNode, TYPE_ALTER_TABLE_STATEMENT);\n        assertThat(alterNodes.size(), is(120));\n        List<AstNode> dropSchemaNodes = nodeFactory.getChildrenForType(rootNode, TYPE_DROP_SCHEMA_STATEMENT);\n        assertThat(dropSchemaNodes.size(), is(1));\n        List<AstNode> unknownNodes = nodeFactory.getChildrenForType(rootNode, TYPE_UNKNOWN_STATEMENT);\n        assertThat(unknownNodes.size(), is(1));\n    }", "signature": "void shouldParseUnterminatedOracleFile()", "full_signature": "@Test public void shouldParseUnterminatedOracleFile()", "class_method_signature": "DdlParsersTest.shouldParseUnterminatedOracleFile()", "testcase": true, "constructor": false, "invocations": ["printTest", "getFileContent", "parse", "assertEquals", "getProperty", "setPrintToConsole", "getChildrenForType", "printTest", "toString", "assertThat", "getChildCount", "is", "getChildrenForType", "assertThat", "size", "is", "assertThat", "getChildCount", "get", "is", "assertThat", "getName", "get", "is", "getChildrenForType", "assertThat", "size", "is", "getChildrenForType", "assertThat", "size", "is", "getChildrenForType", "assertThat", "size", "is"]}, "focal_class": {"identifier": "DdlParsers", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Comparator<Entry<DdlParser, Integer>> SORTER = new Comparator<Entry<DdlParser, Integer>>() {\n\n        @Override\n        public int compare( final Entry<DdlParser, Integer> thisEntry,\n                            final Entry<DdlParser, Integer> thatEntry ) {\n            // reverse order as we want biggest value to sort first\n            int result = (thisEntry.getValue().compareTo(thatEntry.getValue()) * -1);\n\n            // default to standard SQL parser if score is a tie\n            if (result == 0) {\n                if (StandardDdlParser.ID.equals(thisEntry.getKey().getId())\n                    && !StandardDdlParser.ID.equals(thatEntry.getKey().getId())) {\n                    return -1;\n                }\n\n                if (StandardDdlParser.ID.equals(thatEntry.getKey().getId())\n                    && !StandardDdlParser.ID.equals(thisEntry.getKey().getId())) {\n                    return 1;\n                }\n            }\n\n            return result;\n        }\n\n    };", "modifier": "private static final", "type": "Comparator<Entry<DdlParser, Integer>>", "declarator": "SORTER = new Comparator<Entry<DdlParser, Integer>>() {\n\n        @Override\n        public int compare( final Entry<DdlParser, Integer> thisEntry,\n                            final Entry<DdlParser, Integer> thatEntry ) {\n            // reverse order as we want biggest value to sort first\n            int result = (thisEntry.getValue().compareTo(thatEntry.getValue()) * -1);\n\n            // default to standard SQL parser if score is a tie\n            if (result == 0) {\n                if (StandardDdlParser.ID.equals(thisEntry.getKey().getId())\n                    && !StandardDdlParser.ID.equals(thatEntry.getKey().getId())) {\n                    return -1;\n                }\n\n                if (StandardDdlParser.ID.equals(thatEntry.getKey().getId())\n                    && !StandardDdlParser.ID.equals(thisEntry.getKey().getId())) {\n                    return 1;\n                }\n            }\n\n            return result;\n        }\n\n    }", "var_name": "SORTER"}, {"original_string": "public static final List<DdlParser> BUILTIN_PARSERS;", "modifier": "public static final", "type": "List<DdlParser>", "declarator": "BUILTIN_PARSERS", "var_name": "BUILTIN_PARSERS"}, {"original_string": "private List<DdlParser> parsers;", "modifier": "private", "type": "List<DdlParser>", "declarator": "parsers", "var_name": "parsers"}, {"original_string": "private AstNodeFactory nodeFactory = new AstNodeFactory();", "modifier": "private", "type": "AstNodeFactory", "declarator": "nodeFactory = new AstNodeFactory()", "var_name": "nodeFactory"}], "methods": [{"identifier": "DdlParsers", "parameters": "()", "modifiers": "public", "return": "", "signature": " DdlParsers()", "full_signature": "public  DdlParsers()", "class_method_signature": "DdlParsers.DdlParsers()", "testcase": false, "constructor": true}, {"identifier": "DdlParsers", "parameters": "( List<DdlParser> parsers )", "modifiers": "public", "return": "", "signature": " DdlParsers( List<DdlParser> parsers )", "full_signature": "public  DdlParsers( List<DdlParser> parsers )", "class_method_signature": "DdlParsers.DdlParsers( List<DdlParser> parsers )", "testcase": false, "constructor": true}, {"identifier": "createDdlStatementsContainer", "parameters": "( final String parserId )", "modifiers": "private", "return": "AstNode", "signature": "AstNode createDdlStatementsContainer( final String parserId )", "full_signature": "private AstNode createDdlStatementsContainer( final String parserId )", "class_method_signature": "DdlParsers.createDdlStatementsContainer( final String parserId )", "testcase": false, "constructor": false}, {"identifier": "getParser", "parameters": "( final String id )", "modifiers": "public", "return": "DdlParser", "signature": "DdlParser getParser( final String id )", "full_signature": "public DdlParser getParser( final String id )", "class_method_signature": "DdlParsers.getParser( final String id )", "testcase": false, "constructor": false}, {"identifier": "getParsers", "parameters": "()", "modifiers": "public", "return": "Set<DdlParser>", "signature": "Set<DdlParser> getParsers()", "full_signature": "public Set<DdlParser> getParsers()", "class_method_signature": "DdlParsers.getParsers()", "testcase": false, "constructor": false}, {"identifier": "parseUsing", "parameters": "( final String ddl,\n                               final String parserId )", "modifiers": "public", "return": "AstNode", "signature": "AstNode parseUsing( final String ddl,\n                               final String parserId )", "full_signature": "public AstNode parseUsing( final String ddl,\n                               final String parserId )", "class_method_signature": "DdlParsers.parseUsing( final String ddl,\n                               final String parserId )", "testcase": false, "constructor": false}, {"identifier": "parseUsing", "parameters": "( final String ddl,\n                                           final String firstParserId,\n                                           final String secondParserId,\n                                           final String... additionalParserIds )", "modifiers": "public", "return": "List<ParsingResult>", "signature": "List<ParsingResult> parseUsing( final String ddl,\n                                           final String firstParserId,\n                                           final String secondParserId,\n                                           final String... additionalParserIds )", "full_signature": "public List<ParsingResult> parseUsing( final String ddl,\n                                           final String firstParserId,\n                                           final String secondParserId,\n                                           final String... additionalParserIds )", "class_method_signature": "DdlParsers.parseUsing( final String ddl,\n                                           final String firstParserId,\n                                           final String secondParserId,\n                                           final String... additionalParserIds )", "testcase": false, "constructor": false}, {"identifier": "parseUsing", "parameters": "( final String ddl,\n                                            final List<DdlParser> parsers )", "modifiers": "private", "return": "List<ParsingResult>", "signature": "List<ParsingResult> parseUsing( final String ddl,\n                                            final List<DdlParser> parsers )", "full_signature": "private List<ParsingResult> parseUsing( final String ddl,\n                                            final List<DdlParser> parsers )", "class_method_signature": "DdlParsers.parseUsing( final String ddl,\n                                            final List<DdlParser> parsers )", "testcase": false, "constructor": false}, {"identifier": "parseUsingAll", "parameters": "( final String ddl )", "modifiers": "public", "return": "List<ParsingResult>", "signature": "List<ParsingResult> parseUsingAll( final String ddl )", "full_signature": "public List<ParsingResult> parseUsingAll( final String ddl )", "class_method_signature": "DdlParsers.parseUsingAll( final String ddl )", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "( final String ddl,\n                          final String fileName )", "modifiers": "public", "return": "AstNode", "signature": "AstNode parse( final String ddl,\n                          final String fileName )", "full_signature": "public AstNode parse( final String ddl,\n                          final String fileName )", "class_method_signature": "DdlParsers.parse( final String ddl,\n                          final String fileName )", "testcase": false, "constructor": false}], "file": "sequencers/modeshape-sequencer-ddl/src/main/java/org/modeshape/sequencer/ddl/DdlParsers.java"}, "focal_method": {"identifier": "parse", "parameters": "( final String ddl,\n                          final String fileName )", "modifiers": "public", "return": "AstNode", "body": "public AstNode parse( final String ddl,\n                          final String fileName ) throws ParsingException {\n        CheckArg.isNotEmpty(ddl, \"ddl\");\n        RuntimeException firstException = null;\n\n        // Go through each parser and score the DDL content\n        final Map<DdlParser, Integer> scoreMap = new HashMap<DdlParser, Integer>(this.parsers.size());\n        final DdlParserScorer scorer = new DdlParserScorer();\n\n        for (final DdlParser parser : this.parsers) {\n            try {\n                parser.score(ddl, fileName, scorer);\n                scoreMap.put(parser, scorer.getScore());\n            } catch (RuntimeException e) {\n                if (firstException == null) {\n                    firstException = e;\n                }\n            } finally {\n                scorer.reset();\n            }\n        }\n\n        if (scoreMap.isEmpty()) {\n            if (firstException == null) {\n                throw new ParsingException(Position.EMPTY_CONTENT_POSITION,\n                                           DdlSequencerI18n.errorParsingDdlContent.text(this.parsers.size()));\n            }\n\n            throw firstException;\n        }\n\n        // sort the scores\n        final List<Entry<DdlParser, Integer>> scoredParsers = new ArrayList<Entry<DdlParser, Integer>>(scoreMap.entrySet());\n        Collections.sort(scoredParsers, SORTER);\n\n        firstException = null;\n        AstNode astRoot = null;\n\n        for (final Entry<DdlParser, Integer> scoredParser : scoredParsers) {\n            try {\n                final DdlParser parser = scoredParser.getKey();\n\n                // create DDL root node\n                astRoot = createDdlStatementsContainer(parser.getId());\n\n                // parse\n                parser.parse(ddl, astRoot, null);\n                return astRoot; // successfully parsed\n            } catch (final RuntimeException e) {\n                if (astRoot != null) {\n                    astRoot.removeFromParent();\n                }\n\n                if (firstException == null) {\n                    firstException = e;\n                }\n            }\n        }\n\n        if (firstException == null) {\n            throw new ParsingException(Position.EMPTY_CONTENT_POSITION, DdlSequencerI18n.errorParsingDdlContent.text());\n        }\n\n        throw firstException;\n    }", "signature": "AstNode parse( final String ddl,\n                          final String fileName )", "full_signature": "public AstNode parse( final String ddl,\n                          final String fileName )", "class_method_signature": "DdlParsers.parse( final String ddl,\n                          final String fileName )", "testcase": false, "constructor": false, "invocations": ["isNotEmpty", "size", "score", "put", "getScore", "reset", "isEmpty", "text", "size", "entrySet", "sort", "getKey", "createDdlStatementsContainer", "getId", "parse", "removeFromParent", "text"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}