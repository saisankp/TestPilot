{"test_class": {"identifier": "TypesTest", "superclass": "", "interfaces": "", "fields": [], "file": "sjsc/src/test/java/com/samsung/sjs/types/TypesTest.java"}, "test_case": {"identifier": "testRecursiveSubtype", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRecursiveSubtype() {\n        ObjectType o1 = new ObjectType();\n        o1.setProperty(\"f\", o1);\n        ObjectType o2 = new ObjectType();\n        o2.setProperty(\"f\", o2);\n        Assert.assertTrue(Types.isSubtype(o1, o2));\n\n        FunctionType f1 = new FunctionType(oneElementArrayList(null), oneElementArrayList(\"1\"), new VoidType());\n        f1.setParamType(f1, 0);\n        FunctionType f2 = new FunctionType(oneElementArrayList(null), oneElementArrayList(\"1\"), new VoidType());\n        f2.setParamType(f2, 0);\n        Assert.assertTrue(Types.isSubtype(f1, f2));\n    }", "signature": "void testRecursiveSubtype()", "full_signature": "@Test public void testRecursiveSubtype()", "class_method_signature": "TypesTest.testRecursiveSubtype()", "testcase": true, "constructor": false, "invocations": ["setProperty", "setProperty", "assertTrue", "isSubtype", "oneElementArrayList", "oneElementArrayList", "setParamType", "oneElementArrayList", "oneElementArrayList", "setParamType", "assertTrue", "isSubtype"]}, "focal_class": {"identifier": "Types", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "isEqual", "parameters": "(Type type1, Type type2)", "modifiers": "public static", "return": "boolean", "signature": "boolean isEqual(Type type1, Type type2)", "full_signature": "public static boolean isEqual(Type type1, Type type2)", "class_method_signature": "Types.isEqual(Type type1, Type type2)", "testcase": false, "constructor": false}, {"identifier": "isEqualHelper", "parameters": "(Type type1, Type type2, Set<Pair<Type, Type>> queried)", "modifiers": "private static", "return": "boolean", "signature": "boolean isEqualHelper(Type type1, Type type2, Set<Pair<Type, Type>> queried)", "full_signature": "private static boolean isEqualHelper(Type type1, Type type2, Set<Pair<Type, Type>> queried)", "class_method_signature": "Types.isEqualHelper(Type type1, Type type2, Set<Pair<Type, Type>> queried)", "testcase": false, "constructor": false}, {"identifier": "isContainedIn", "parameters": "(List<Type> types, Type type)", "modifiers": "private static", "return": "boolean", "signature": "boolean isContainedIn(List<Type> types, Type type)", "full_signature": "private static boolean isContainedIn(List<Type> types, Type type)", "class_method_signature": "Types.isContainedIn(List<Type> types, Type type)", "testcase": false, "constructor": false}, {"identifier": "isContainedIn", "parameters": "(List<Type> types1, List<Type> types2)", "modifiers": "private static", "return": "boolean", "signature": "boolean isContainedIn(List<Type> types1, List<Type> types2)", "full_signature": "private static boolean isContainedIn(List<Type> types1, List<Type> types2)", "class_method_signature": "Types.isContainedIn(List<Type> types1, List<Type> types2)", "testcase": false, "constructor": false}, {"identifier": "mkArray", "parameters": "(Type celltype)", "modifiers": "public static", "return": "Type", "signature": "Type mkArray(Type celltype)", "full_signature": "public static Type mkArray(Type celltype)", "class_method_signature": "Types.mkArray(Type celltype)", "testcase": false, "constructor": false}, {"identifier": "mkMap", "parameters": "(Type celltype)", "modifiers": "public static", "return": "Type", "signature": "Type mkMap(Type celltype)", "full_signature": "public static Type mkMap(Type celltype)", "class_method_signature": "Types.mkMap(Type celltype)", "testcase": false, "constructor": false}, {"identifier": "mkCtor", "parameters": "(List<Type> paramTypes, List<String> paramNames, Type returnType, Type proto)", "modifiers": "public static", "return": "ConstructorType", "signature": "ConstructorType mkCtor(List<Type> paramTypes, List<String> paramNames, Type returnType, Type proto)", "full_signature": "public static ConstructorType mkCtor(List<Type> paramTypes, List<String> paramNames, Type returnType, Type proto)", "class_method_signature": "Types.mkCtor(List<Type> paramTypes, List<String> paramNames, Type returnType, Type proto)", "testcase": false, "constructor": false}, {"identifier": "mkFunc", "parameters": "(Type ret, List<Type> paramty)", "modifiers": "public static", "return": "FunctionType", "signature": "FunctionType mkFunc(Type ret, List<Type> paramty)", "full_signature": "public static FunctionType mkFunc(Type ret, List<Type> paramty)", "class_method_signature": "Types.mkFunc(Type ret, List<Type> paramty)", "testcase": false, "constructor": false}, {"identifier": "mkFunc", "parameters": "(Type ret, List<Type> paramty, List<String> params)", "modifiers": "public static", "return": "FunctionType", "signature": "FunctionType mkFunc(Type ret, List<Type> paramty, List<String> params)", "full_signature": "public static FunctionType mkFunc(Type ret, List<Type> paramty, List<String> params)", "class_method_signature": "Types.mkFunc(Type ret, List<Type> paramty, List<String> params)", "testcase": false, "constructor": false}, {"identifier": "isStringType", "parameters": "(Type targetType)", "modifiers": "public static", "return": "boolean", "signature": "boolean isStringType(Type targetType)", "full_signature": "public static boolean isStringType(Type targetType)", "class_method_signature": "Types.isStringType(Type targetType)", "testcase": false, "constructor": false}, {"identifier": "isArrayType", "parameters": "(Type targetType)", "modifiers": "public static", "return": "boolean", "signature": "boolean isArrayType(Type targetType)", "full_signature": "public static boolean isArrayType(Type targetType)", "class_method_signature": "Types.isArrayType(Type targetType)", "testcase": false, "constructor": false}, {"identifier": "isMapType", "parameters": "(Type type)", "modifiers": "public static", "return": "boolean", "signature": "boolean isMapType(Type type)", "full_signature": "public static boolean isMapType(Type type)", "class_method_signature": "Types.isMapType(Type type)", "testcase": false, "constructor": false}, {"identifier": "mkAny", "parameters": "()", "modifiers": "public static", "return": "Type", "signature": "Type mkAny()", "full_signature": "public static Type mkAny()", "class_method_signature": "Types.mkAny()", "testcase": false, "constructor": false}, {"identifier": "mkVoid", "parameters": "()", "modifiers": "public static", "return": "Type", "signature": "Type mkVoid()", "full_signature": "public static Type mkVoid()", "class_method_signature": "Types.mkVoid()", "testcase": false, "constructor": false}, {"identifier": "mkFloat", "parameters": "()", "modifiers": "public static", "return": "FloatType", "signature": "FloatType mkFloat()", "full_signature": "public static FloatType mkFloat()", "class_method_signature": "Types.mkFloat()", "testcase": false, "constructor": false}, {"identifier": "mkString", "parameters": "()", "modifiers": "public static", "return": "StringType", "signature": "StringType mkString()", "full_signature": "public static StringType mkString()", "class_method_signature": "Types.mkString()", "testcase": false, "constructor": false}, {"identifier": "mkBool", "parameters": "()", "modifiers": "public static", "return": "BooleanType", "signature": "BooleanType mkBool()", "full_signature": "public static BooleanType mkBool()", "class_method_signature": "Types.mkBool()", "testcase": false, "constructor": false}, {"identifier": "mkInt", "parameters": "()", "modifiers": "public static", "return": "IntegerType", "signature": "IntegerType mkInt()", "full_signature": "public static IntegerType mkInt()", "class_method_signature": "Types.mkInt()", "testcase": false, "constructor": false}, {"identifier": "mkProperty", "parameters": "(final String name, final Type ty)", "modifiers": "public static", "return": "Property", "signature": "Property mkProperty(final String name, final Type ty)", "full_signature": "public static Property mkProperty(final String name, final Type ty)", "class_method_signature": "Types.mkProperty(final String name, final Type ty)", "testcase": false, "constructor": false}, {"identifier": "mkMethod", "parameters": "(final Type thistype, final Type ret, List<Type> pty)", "modifiers": "public static", "return": "AttachedMethodType", "signature": "AttachedMethodType mkMethod(final Type thistype, final Type ret, List<Type> pty)", "full_signature": "public static AttachedMethodType mkMethod(final Type thistype, final Type ret, List<Type> pty)", "class_method_signature": "Types.mkMethod(final Type thistype, final Type ret, List<Type> pty)", "testcase": false, "constructor": false}, {"identifier": "mkMethod", "parameters": "(final Type thistype, final Type ret, Type... args)", "modifiers": "public static", "return": "AttachedMethodType", "signature": "AttachedMethodType mkMethod(final Type thistype, final Type ret, Type... args)", "full_signature": "public static AttachedMethodType mkMethod(final Type thistype, final Type ret, Type... args)", "class_method_signature": "Types.mkMethod(final Type thistype, final Type ret, Type... args)", "testcase": false, "constructor": false}, {"identifier": "mkMethod", "parameters": "(Type thistype, Type ret, List<String> pnames, List<Type> pty)", "modifiers": "public static", "return": "AttachedMethodType", "signature": "AttachedMethodType mkMethod(Type thistype, Type ret, List<String> pnames, List<Type> pty)", "full_signature": "public static AttachedMethodType mkMethod(Type thistype, Type ret, List<String> pnames, List<Type> pty)", "class_method_signature": "Types.mkMethod(Type thistype, Type ret, List<String> pnames, List<Type> pty)", "testcase": false, "constructor": false}, {"identifier": "mkObject", "parameters": "(List<Property> props)", "modifiers": "public static", "return": "ObjectType", "signature": "ObjectType mkObject(List<Property> props)", "full_signature": "public static ObjectType mkObject(List<Property> props)", "class_method_signature": "Types.mkObject(List<Property> props)", "testcase": false, "constructor": false}, {"identifier": "mkMapIteratorType", "parameters": "(Type t)", "modifiers": "public static", "return": "Type", "signature": "Type mkMapIteratorType(Type t)", "full_signature": "public static Type mkMapIteratorType(Type t)", "class_method_signature": "Types.mkMapIteratorType(Type t)", "testcase": false, "constructor": false}, {"identifier": "isComponentOf", "parameters": "(Type type, IntersectionType iType)", "modifiers": "public static", "return": "boolean", "signature": "boolean isComponentOf(Type type, IntersectionType iType)", "full_signature": "public static boolean isComponentOf(Type type, IntersectionType iType)", "class_method_signature": "Types.isComponentOf(Type type, IntersectionType iType)", "testcase": false, "constructor": false}, {"identifier": "isSubtype", "parameters": "(Type subType, Type superType)", "modifiers": "public static", "return": "boolean", "signature": "boolean isSubtype(Type subType, Type superType)", "full_signature": "public static boolean isSubtype(Type subType, Type superType)", "class_method_signature": "Types.isSubtype(Type subType, Type superType)", "testcase": false, "constructor": false}, {"identifier": "isRefType", "parameters": "(Type t)", "modifiers": "public static", "return": "boolean", "signature": "boolean isRefType(Type t)", "full_signature": "public static boolean isRefType(Type t)", "class_method_signature": "Types.isRefType(Type t)", "testcase": false, "constructor": false}, {"identifier": "usableAsConstructor", "parameters": "(Type t)", "modifiers": "public static", "return": "boolean", "signature": "boolean usableAsConstructor(Type t)", "full_signature": "public static boolean usableAsConstructor(Type t)", "class_method_signature": "Types.usableAsConstructor(Type t)", "testcase": false, "constructor": false}, {"identifier": "isSubtypeish", "parameters": "(Type subType, Type superType)", "modifiers": "public static", "return": "boolean", "signature": "boolean isSubtypeish(Type subType, Type superType)", "full_signature": "public static boolean isSubtypeish(Type subType, Type superType)", "class_method_signature": "Types.isSubtypeish(Type subType, Type superType)", "testcase": false, "constructor": false}, {"identifier": "coarseUpperBound", "parameters": "(Type t1, Type t2)", "modifiers": "public static", "return": "Type", "signature": "Type coarseUpperBound(Type t1, Type t2)", "full_signature": "public static Type coarseUpperBound(Type t1, Type t2)", "class_method_signature": "Types.coarseUpperBound(Type t1, Type t2)", "testcase": false, "constructor": false}, {"identifier": "coarseLowerBound", "parameters": "(Type t1, Type t2)", "modifiers": "public static", "return": "Type", "signature": "Type coarseLowerBound(Type t1, Type t2)", "full_signature": "public static Type coarseLowerBound(Type t1, Type t2)", "class_method_signature": "Types.coarseLowerBound(Type t1, Type t2)", "testcase": false, "constructor": false}, {"identifier": "lowestSubtype", "parameters": "(Type t)", "modifiers": "public static", "return": "Type", "signature": "Type lowestSubtype(Type t)", "full_signature": "public static Type lowestSubtype(Type t)", "class_method_signature": "Types.lowestSubtype(Type t)", "testcase": false, "constructor": false}], "file": "sjsc/src/main/java/com/samsung/sjs/types/Types.java"}, "focal_method": {"identifier": "isSubtype", "parameters": "(Type subType, Type superType)", "modifiers": "public static", "return": "boolean", "body": "public static boolean isSubtype(Type subType, Type superType) {\n\t    if (Types.isEqual(subType, superType)) return true;\n\t    if (subType instanceof IntegerType && superType instanceof FloatType) {\n\t        return true;\n\t    }\n\t    if (superType instanceof TopReferenceType && isRefType(subType)) {\n\t        return true;\n\t    }\n\t    if (subType instanceof BottomReferenceType && isRefType(superType)) {\n\t        return true;\n\t    }\n\t    if (subType instanceof ObjectType && superType instanceof ObjectType) {\n\t        // NOTE: this only handles concrete types and does not reason about MRO/MRW\n\t        ObjectType subObjType = (ObjectType) subType;\n\t        List<Property> superTypeProps = ((ObjectType)superType).properties();\n\t        // each super type property should be present in the subtype with (1) the same\n\t        // type and (2) an equally strong or stronger read-write permission\n\t        for (Property superProp: superTypeProps) {\n\t            if (!subObjType.hasProperty(superProp.getName())) {\n\t                return false;\n\t            }\n\t            Property subProp = subObjType.getProperty(superProp.getName());\n\t            if (!Types.isEqual(superProp.getType(), subProp.getType())) {\n\t                return false;\n\t            }\n\t            if (superProp.isRW() && !subProp.isRW()) { // permissions weakened\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t}", "signature": "boolean isSubtype(Type subType, Type superType)", "full_signature": "public static boolean isSubtype(Type subType, Type superType)", "class_method_signature": "Types.isSubtype(Type subType, Type superType)", "testcase": false, "constructor": false, "invocations": ["isEqual", "isRefType", "isRefType", "properties", "hasProperty", "getName", "getProperty", "getName", "isEqual", "getType", "getType", "isRW", "isRW"]}, "repository": {"repo_id": 71089550, "url": "https://github.com/Samsung/SJS", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 26, "size": 5742, "license": "licensed"}}