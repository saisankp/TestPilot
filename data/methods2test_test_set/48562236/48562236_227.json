{"test_class": {"identifier": "CSVParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String CSVINPUT = \"a,b,c,d\\n\"\n                    + \" a , b , 1 2 \\n\"\n                    + \"\\\"foo baar\\\", b,\\n\"\n                    // + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n                    + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\";", "modifier": "private static final", "type": "String", "declarator": "CSVINPUT = \"a,b,c,d\\n\"\n                    + \" a , b , 1 2 \\n\"\n                    + \"\\\"foo baar\\\", b,\\n\"\n                    // + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n                    + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\"", "var_name": "CSVINPUT"}, {"original_string": "private static final String[][] RESULT = {\n            {\"a\", \"b\", \"c\", \"d\"},\n            {\"a\", \"b\", \"1 2\"},\n            {\"foo baar\", \"b\", \"\"},\n            {\"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\"}\n    };", "modifier": "private static final", "type": "String[][]", "declarator": "RESULT = {\n            {\"a\", \"b\", \"c\", \"d\"},\n            {\"a\", \"b\", \"1 2\"},\n            {\"foo baar\", \"b\", \"\"},\n            {\"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\"}\n    }", "var_name": "RESULT"}], "file": "base/lang/src/test/java/leap/lang/csv/CSVParserTest.java"}, "test_case": {"identifier": "testIterator", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testIterator() throws Exception {\n        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n\n        final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator();\n\n        assertTrue(iterator.hasNext());\n        try {\n            iterator.remove();\n            fail(\"expected UnsupportedOperationException\");\n        } catch (final UnsupportedOperationException expected) {\n            // expected\n        }\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, iterator.next().values());\n        assertArrayEquals(new String[]{\"1\", \"2\", \"3\"}, iterator.next().values());\n        assertTrue(iterator.hasNext());\n        assertTrue(iterator.hasNext());\n        assertTrue(iterator.hasNext());\n        assertArrayEquals(new String[]{\"x\", \"y\", \"z\"}, iterator.next().values());\n        assertFalse(iterator.hasNext());\n\n        try {\n            iterator.next();\n            fail(\"NoSuchElementException expected\");\n        } catch (final NoSuchElementException e) {\n            // expected\n        }\n    }", "signature": "void testIterator()", "full_signature": "@Test public void testIterator()", "class_method_signature": "CSVParserTest.testIterator()", "testcase": true, "constructor": false, "invocations": ["iterator", "parse", "assertTrue", "hasNext", "remove", "fail", "assertArrayEquals", "values", "next", "assertArrayEquals", "values", "next", "assertTrue", "hasNext", "assertTrue", "hasNext", "assertTrue", "hasNext", "assertArrayEquals", "values", "next", "assertFalse", "hasNext", "next", "fail"]}, "focal_class": {"identifier": "CSVParser", "superclass": "", "interfaces": "implements Iterable<CSVRecord>, Closeable", "fields": [{"original_string": "private final CSVFormat format;", "modifier": "private final", "type": "CSVFormat", "declarator": "format", "var_name": "format"}, {"original_string": "private final Map<String, Integer> headerMap;", "modifier": "private final", "type": "Map<String, Integer>", "declarator": "headerMap", "var_name": "headerMap"}, {"original_string": "private final Lexer lexer;", "modifier": "private final", "type": "Lexer", "declarator": "lexer", "var_name": "lexer"}, {"original_string": "private final List<String> record = new ArrayList<String>();", "modifier": "private final", "type": "List<String>", "declarator": "record = new ArrayList<String>()", "var_name": "record"}, {"original_string": "private boolean readComment = true;", "modifier": "private", "type": "boolean", "declarator": "readComment = true", "var_name": "readComment"}, {"original_string": "private String recordComment;", "modifier": "private", "type": "String", "declarator": "recordComment", "var_name": "recordComment"}, {"original_string": "private long recordNumber;", "modifier": "private", "type": "long", "declarator": "recordNumber", "var_name": "recordNumber"}, {"original_string": "private final Token reusableToken = new Token();", "modifier": "private final", "type": "Token", "declarator": "reusableToken = new Token()", "var_name": "reusableToken"}], "methods": [{"identifier": "parse", "parameters": "(File file, final CSVFormat format)", "modifiers": "public static", "return": "CSVParser", "signature": "CSVParser parse(File file, final CSVFormat format)", "full_signature": "public static CSVParser parse(File file, final CSVFormat format)", "class_method_signature": "CSVParser.parse(File file, final CSVFormat format)", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "(String string, final CSVFormat format)", "modifiers": "public static", "return": "CSVParser", "signature": "CSVParser parse(String string, final CSVFormat format)", "full_signature": "public static CSVParser parse(String string, final CSVFormat format)", "class_method_signature": "CSVParser.parse(String string, final CSVFormat format)", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "(URL url, Charset charset, final CSVFormat format)", "modifiers": "public static", "return": "CSVParser", "signature": "CSVParser parse(URL url, Charset charset, final CSVFormat format)", "full_signature": "public static CSVParser parse(URL url, Charset charset, final CSVFormat format)", "class_method_signature": "CSVParser.parse(URL url, Charset charset, final CSVFormat format)", "testcase": false, "constructor": false}, {"identifier": "CSVParser", "parameters": "(final Reader reader, final CSVFormat format)", "modifiers": "public", "return": "", "signature": " CSVParser(final Reader reader, final CSVFormat format)", "full_signature": "public  CSVParser(final Reader reader, final CSVFormat format)", "class_method_signature": "CSVParser.CSVParser(final Reader reader, final CSVFormat format)", "testcase": false, "constructor": true}, {"identifier": "addRecordValue", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void addRecordValue()", "full_signature": "private void addRecordValue()", "class_method_signature": "CSVParser.addRecordValue()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "CSVParser.close()", "testcase": false, "constructor": false}, {"identifier": "getCurrentLineNumber", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getCurrentLineNumber()", "full_signature": "public long getCurrentLineNumber()", "class_method_signature": "CSVParser.getCurrentLineNumber()", "testcase": false, "constructor": false}, {"identifier": "getHeaderMap", "parameters": "()", "modifiers": "public", "return": "Map<String, Integer>", "signature": "Map<String, Integer> getHeaderMap()", "full_signature": "public Map<String, Integer> getHeaderMap()", "class_method_signature": "CSVParser.getHeaderMap()", "testcase": false, "constructor": false}, {"identifier": "getRecordNumber", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getRecordNumber()", "full_signature": "public long getRecordNumber()", "class_method_signature": "CSVParser.getRecordNumber()", "testcase": false, "constructor": false}, {"identifier": "getRecords", "parameters": "()", "modifiers": "public", "return": "List<CSVRecord>", "signature": "List<CSVRecord> getRecords()", "full_signature": "public List<CSVRecord> getRecords()", "class_method_signature": "CSVParser.getRecords()", "testcase": false, "constructor": false}, {"identifier": "getRecords1", "parameters": "()", "modifiers": "", "return": "List<String[]>", "signature": "List<String[]> getRecords1()", "full_signature": " List<String[]> getRecords1()", "class_method_signature": "CSVParser.getRecords1()", "testcase": false, "constructor": false}, {"identifier": "initializeHeader", "parameters": "()", "modifiers": "private", "return": "Map<String, Integer>", "signature": "Map<String, Integer> initializeHeader()", "full_signature": "private Map<String, Integer> initializeHeader()", "class_method_signature": "CSVParser.initializeHeader()", "testcase": false, "constructor": false}, {"identifier": "isClosed", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isClosed()", "full_signature": "public boolean isClosed()", "class_method_signature": "CSVParser.isClosed()", "testcase": false, "constructor": false}, {"identifier": "iterator", "parameters": "()", "modifiers": "public", "return": "Iterator<CSVRecord>", "signature": "Iterator<CSVRecord> iterator()", "full_signature": "public Iterator<CSVRecord> iterator()", "class_method_signature": "CSVParser.iterator()", "testcase": false, "constructor": false}, {"identifier": "nextRecord", "parameters": "()", "modifiers": "", "return": "CSVRecord", "signature": "CSVRecord nextRecord()", "full_signature": " CSVRecord nextRecord()", "class_method_signature": "CSVParser.nextRecord()", "testcase": false, "constructor": false}, {"identifier": "nextRecord1", "parameters": "()", "modifiers": "", "return": "String[]", "signature": "String[] nextRecord1()", "full_signature": " String[] nextRecord1()", "class_method_signature": "CSVParser.nextRecord1()", "testcase": false, "constructor": false}, {"identifier": "tryNextRecord", "parameters": "()", "modifiers": "", "return": "boolean", "signature": "boolean tryNextRecord()", "full_signature": " boolean tryNextRecord()", "class_method_signature": "CSVParser.tryNextRecord()", "testcase": false, "constructor": false}], "file": "base/lang/src/main/java/leap/lang/csv/CSVParser.java"}, "focal_method": {"identifier": "iterator", "parameters": "()", "modifiers": "public", "return": "Iterator<CSVRecord>", "body": "public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }", "signature": "Iterator<CSVRecord> iterator()", "full_signature": "public Iterator<CSVRecord> iterator()", "class_method_signature": "CSVParser.iterator()", "testcase": false, "constructor": false, "invocations": ["nextRecord", "isClosed", "getNextRecord", "isClosed", "getNextRecord"]}, "repository": {"repo_id": 48562236, "url": "https://github.com/leapframework/framework", "stars": 42, "created": "12/25/2015 1:54:52 AM +00:00", "updates": "2020-01-20T03:04:15+00:00", "fork": "False", "license": "licensed"}}