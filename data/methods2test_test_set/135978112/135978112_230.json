{"test_class": {"identifier": "KafkaConsumerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final String topic = \"test\";", "modifier": "private final", "type": "String", "declarator": "topic = \"test\"", "var_name": "topic"}, {"original_string": "private final TopicPartition tp0 = new TopicPartition(\"test\", 0);", "modifier": "private final", "type": "TopicPartition", "declarator": "tp0 = new TopicPartition(\"test\", 0)", "var_name": "tp0"}], "file": "clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java"}, "test_case": {"identifier": "testInterceptorConstructorClose", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testInterceptorConstructorClose() throws Exception {\n        try {\n            Properties props = new Properties();\n            // test with client ID assigned by KafkaConsumer\n            props.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:9999\");\n            props.setProperty(ConsumerConfig.INTERCEPTOR_CLASSES_CONFIG, MockConsumerInterceptor.class.getName());\n\n            KafkaConsumer<String, String> consumer = new KafkaConsumer<String, String>(\n                    props, new StringDeserializer(), new StringDeserializer());\n            assertEquals(1, MockConsumerInterceptor.INIT_COUNT.get());\n            assertEquals(0, MockConsumerInterceptor.CLOSE_COUNT.get());\n\n            consumer.close();\n            assertEquals(1, MockConsumerInterceptor.INIT_COUNT.get());\n            assertEquals(1, MockConsumerInterceptor.CLOSE_COUNT.get());\n        } finally {\n            // cleanup since we are using mutable static variables in MockConsumerInterceptor\n            MockConsumerInterceptor.resetCounters();\n        }\n    }", "signature": "void testInterceptorConstructorClose()", "full_signature": "@Test public void testInterceptorConstructorClose()", "class_method_signature": "KafkaConsumerTest.testInterceptorConstructorClose()", "testcase": true, "constructor": false, "invocations": ["setProperty", "setProperty", "getName", "assertEquals", "get", "assertEquals", "get", "close", "assertEquals", "get", "assertEquals", "get", "resetCounters"]}, "focal_class": {"identifier": "KafkaConsumer", "superclass": "", "interfaces": "implements Consumer<K, V>", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(KafkaConsumer.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(KafkaConsumer.class)", "var_name": "log"}, {"original_string": "private static final long NO_CURRENT_THREAD = -1L;", "modifier": "private static final", "type": "long", "declarator": "NO_CURRENT_THREAD = -1L", "var_name": "NO_CURRENT_THREAD"}, {"original_string": "private static final AtomicInteger CONSUMER_CLIENT_ID_SEQUENCE = new AtomicInteger(1);", "modifier": "private static final", "type": "AtomicInteger", "declarator": "CONSUMER_CLIENT_ID_SEQUENCE = new AtomicInteger(1)", "var_name": "CONSUMER_CLIENT_ID_SEQUENCE"}, {"original_string": "private static final String JMX_PREFIX = \"kafka.consumer\";", "modifier": "private static final", "type": "String", "declarator": "JMX_PREFIX = \"kafka.consumer\"", "var_name": "JMX_PREFIX"}, {"original_string": "private final String clientId;", "modifier": "private final", "type": "String", "declarator": "clientId", "var_name": "clientId"}, {"original_string": "private final ConsumerCoordinator coordinator;", "modifier": "private final", "type": "ConsumerCoordinator", "declarator": "coordinator", "var_name": "coordinator"}, {"original_string": "private final Deserializer<K> keyDeserializer;", "modifier": "private final", "type": "Deserializer<K>", "declarator": "keyDeserializer", "var_name": "keyDeserializer"}, {"original_string": "private final Deserializer<V> valueDeserializer;", "modifier": "private final", "type": "Deserializer<V>", "declarator": "valueDeserializer", "var_name": "valueDeserializer"}, {"original_string": "private final Fetcher<K, V> fetcher;", "modifier": "private final", "type": "Fetcher<K, V>", "declarator": "fetcher", "var_name": "fetcher"}, {"original_string": "private final ConsumerInterceptors<K, V> interceptors;", "modifier": "private final", "type": "ConsumerInterceptors<K, V>", "declarator": "interceptors", "var_name": "interceptors"}, {"original_string": "private final Time time;", "modifier": "private final", "type": "Time", "declarator": "time", "var_name": "time"}, {"original_string": "private final ConsumerNetworkClient client;", "modifier": "private final", "type": "ConsumerNetworkClient", "declarator": "client", "var_name": "client"}, {"original_string": "private final Metrics metrics;", "modifier": "private final", "type": "Metrics", "declarator": "metrics", "var_name": "metrics"}, {"original_string": "private final SubscriptionState subscriptions;", "modifier": "private final", "type": "SubscriptionState", "declarator": "subscriptions", "var_name": "subscriptions"}, {"original_string": "private final Metadata metadata;", "modifier": "private final", "type": "Metadata", "declarator": "metadata", "var_name": "metadata"}, {"original_string": "private final long retryBackoffMs;", "modifier": "private final", "type": "long", "declarator": "retryBackoffMs", "var_name": "retryBackoffMs"}, {"original_string": "private final long requestTimeoutMs;", "modifier": "private final", "type": "long", "declarator": "requestTimeoutMs", "var_name": "requestTimeoutMs"}, {"original_string": "private boolean closed = false;", "modifier": "private", "type": "boolean", "declarator": "closed = false", "var_name": "closed"}, {"original_string": "private final AtomicLong currentThread = new AtomicLong(NO_CURRENT_THREAD);", "modifier": "private final", "type": "AtomicLong", "declarator": "currentThread = new AtomicLong(NO_CURRENT_THREAD)", "var_name": "currentThread"}, {"original_string": "private final AtomicInteger refcount = new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "refcount = new AtomicInteger(0)", "var_name": "refcount"}], "methods": [{"identifier": "KafkaConsumer", "parameters": "(Map<String, Object> configs)", "modifiers": "public", "return": "", "signature": " KafkaConsumer(Map<String, Object> configs)", "full_signature": "public  KafkaConsumer(Map<String, Object> configs)", "class_method_signature": "KafkaConsumer.KafkaConsumer(Map<String, Object> configs)", "testcase": false, "constructor": true}, {"identifier": "KafkaConsumer", "parameters": "(Map<String, Object> configs,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "modifiers": "public", "return": "", "signature": " KafkaConsumer(Map<String, Object> configs,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "full_signature": "public  KafkaConsumer(Map<String, Object> configs,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "class_method_signature": "KafkaConsumer.KafkaConsumer(Map<String, Object> configs,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "testcase": false, "constructor": true}, {"identifier": "KafkaConsumer", "parameters": "(Properties properties)", "modifiers": "public", "return": "", "signature": " KafkaConsumer(Properties properties)", "full_signature": "public  KafkaConsumer(Properties properties)", "class_method_signature": "KafkaConsumer.KafkaConsumer(Properties properties)", "testcase": false, "constructor": true}, {"identifier": "KafkaConsumer", "parameters": "(Properties properties,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "modifiers": "public", "return": "", "signature": " KafkaConsumer(Properties properties,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "full_signature": "public  KafkaConsumer(Properties properties,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "class_method_signature": "KafkaConsumer.KafkaConsumer(Properties properties,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "testcase": false, "constructor": true}, {"identifier": "KafkaConsumer", "parameters": "(ConsumerConfig config,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "modifiers": "@SuppressWarnings(\"unchecked\") private", "return": "", "signature": " KafkaConsumer(ConsumerConfig config,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "full_signature": "@SuppressWarnings(\"unchecked\") private  KafkaConsumer(ConsumerConfig config,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "class_method_signature": "KafkaConsumer.KafkaConsumer(ConsumerConfig config,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer)", "testcase": false, "constructor": true}, {"identifier": "KafkaConsumer", "parameters": "(String clientId,\n        ConsumerCoordinator coordinator,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer,\n        Fetcher<K, V> fetcher,\n        ConsumerInterceptors<K, V> interceptors,\n        Time time,\n        ConsumerNetworkClient client,\n        Metrics metrics,\n        SubscriptionState subscriptions,\n        Metadata metadata,\n        long retryBackoffMs,\n        long requestTimeoutMs)", "modifiers": "", "return": "", "signature": " KafkaConsumer(String clientId,\n        ConsumerCoordinator coordinator,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer,\n        Fetcher<K, V> fetcher,\n        ConsumerInterceptors<K, V> interceptors,\n        Time time,\n        ConsumerNetworkClient client,\n        Metrics metrics,\n        SubscriptionState subscriptions,\n        Metadata metadata,\n        long retryBackoffMs,\n        long requestTimeoutMs)", "full_signature": "  KafkaConsumer(String clientId,\n        ConsumerCoordinator coordinator,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer,\n        Fetcher<K, V> fetcher,\n        ConsumerInterceptors<K, V> interceptors,\n        Time time,\n        ConsumerNetworkClient client,\n        Metrics metrics,\n        SubscriptionState subscriptions,\n        Metadata metadata,\n        long retryBackoffMs,\n        long requestTimeoutMs)", "class_method_signature": "KafkaConsumer.KafkaConsumer(String clientId,\n        ConsumerCoordinator coordinator,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer,\n        Fetcher<K, V> fetcher,\n        ConsumerInterceptors<K, V> interceptors,\n        Time time,\n        ConsumerNetworkClient client,\n        Metrics metrics,\n        SubscriptionState subscriptions,\n        Metadata metadata,\n        long retryBackoffMs,\n        long requestTimeoutMs)", "testcase": false, "constructor": true}, {"identifier": "assignment", "parameters": "()", "modifiers": "public", "return": "Set<TopicPartition>", "signature": "Set<TopicPartition> assignment()", "full_signature": "public Set<TopicPartition> assignment()", "class_method_signature": "KafkaConsumer.assignment()", "testcase": false, "constructor": false}, {"identifier": "subscription", "parameters": "()", "modifiers": "public", "return": "Set<String>", "signature": "Set<String> subscription()", "full_signature": "public Set<String> subscription()", "class_method_signature": "KafkaConsumer.subscription()", "testcase": false, "constructor": false}, {"identifier": "subscribe", "parameters": "(Collection<String> topics, ConsumerRebalanceListener listener)", "modifiers": "@Override public", "return": "void", "signature": "void subscribe(Collection<String> topics, ConsumerRebalanceListener listener)", "full_signature": "@Override public void subscribe(Collection<String> topics, ConsumerRebalanceListener listener)", "class_method_signature": "KafkaConsumer.subscribe(Collection<String> topics, ConsumerRebalanceListener listener)", "testcase": false, "constructor": false}, {"identifier": "subscribe", "parameters": "(Collection<String> topics)", "modifiers": "@Override public", "return": "void", "signature": "void subscribe(Collection<String> topics)", "full_signature": "@Override public void subscribe(Collection<String> topics)", "class_method_signature": "KafkaConsumer.subscribe(Collection<String> topics)", "testcase": false, "constructor": false}, {"identifier": "subscribe", "parameters": "(Pattern pattern, ConsumerRebalanceListener listener)", "modifiers": "@Override public", "return": "void", "signature": "void subscribe(Pattern pattern, ConsumerRebalanceListener listener)", "full_signature": "@Override public void subscribe(Pattern pattern, ConsumerRebalanceListener listener)", "class_method_signature": "KafkaConsumer.subscribe(Pattern pattern, ConsumerRebalanceListener listener)", "testcase": false, "constructor": false}, {"identifier": "unsubscribe", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void unsubscribe()", "full_signature": "public void unsubscribe()", "class_method_signature": "KafkaConsumer.unsubscribe()", "testcase": false, "constructor": false}, {"identifier": "assign", "parameters": "(Collection<TopicPartition> partitions)", "modifiers": "@Override public", "return": "void", "signature": "void assign(Collection<TopicPartition> partitions)", "full_signature": "@Override public void assign(Collection<TopicPartition> partitions)", "class_method_signature": "KafkaConsumer.assign(Collection<TopicPartition> partitions)", "testcase": false, "constructor": false}, {"identifier": "poll", "parameters": "(long timeout)", "modifiers": "@Override public", "return": "ConsumerRecords<K, V>", "signature": "ConsumerRecords<K, V> poll(long timeout)", "full_signature": "@Override public ConsumerRecords<K, V> poll(long timeout)", "class_method_signature": "KafkaConsumer.poll(long timeout)", "testcase": false, "constructor": false}, {"identifier": "pollOnce", "parameters": "(long timeout)", "modifiers": "private", "return": "Map<TopicPartition, List<ConsumerRecord<K, V>>>", "signature": "Map<TopicPartition, List<ConsumerRecord<K, V>>> pollOnce(long timeout)", "full_signature": "private Map<TopicPartition, List<ConsumerRecord<K, V>>> pollOnce(long timeout)", "class_method_signature": "KafkaConsumer.pollOnce(long timeout)", "testcase": false, "constructor": false}, {"identifier": "commitSync", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void commitSync()", "full_signature": "@Override public void commitSync()", "class_method_signature": "KafkaConsumer.commitSync()", "testcase": false, "constructor": false}, {"identifier": "commitSync", "parameters": "(final Map<TopicPartition, OffsetAndMetadata> offsets)", "modifiers": "@Override public", "return": "void", "signature": "void commitSync(final Map<TopicPartition, OffsetAndMetadata> offsets)", "full_signature": "@Override public void commitSync(final Map<TopicPartition, OffsetAndMetadata> offsets)", "class_method_signature": "KafkaConsumer.commitSync(final Map<TopicPartition, OffsetAndMetadata> offsets)", "testcase": false, "constructor": false}, {"identifier": "commitAsync", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void commitAsync()", "full_signature": "@Override public void commitAsync()", "class_method_signature": "KafkaConsumer.commitAsync()", "testcase": false, "constructor": false}, {"identifier": "commitAsync", "parameters": "(OffsetCommitCallback callback)", "modifiers": "@Override public", "return": "void", "signature": "void commitAsync(OffsetCommitCallback callback)", "full_signature": "@Override public void commitAsync(OffsetCommitCallback callback)", "class_method_signature": "KafkaConsumer.commitAsync(OffsetCommitCallback callback)", "testcase": false, "constructor": false}, {"identifier": "commitAsync", "parameters": "(final Map<TopicPartition, OffsetAndMetadata> offsets, OffsetCommitCallback callback)", "modifiers": "@Override public", "return": "void", "signature": "void commitAsync(final Map<TopicPartition, OffsetAndMetadata> offsets, OffsetCommitCallback callback)", "full_signature": "@Override public void commitAsync(final Map<TopicPartition, OffsetAndMetadata> offsets, OffsetCommitCallback callback)", "class_method_signature": "KafkaConsumer.commitAsync(final Map<TopicPartition, OffsetAndMetadata> offsets, OffsetCommitCallback callback)", "testcase": false, "constructor": false}, {"identifier": "seek", "parameters": "(TopicPartition partition, long offset)", "modifiers": "@Override public", "return": "void", "signature": "void seek(TopicPartition partition, long offset)", "full_signature": "@Override public void seek(TopicPartition partition, long offset)", "class_method_signature": "KafkaConsumer.seek(TopicPartition partition, long offset)", "testcase": false, "constructor": false}, {"identifier": "seekToBeginning", "parameters": "(Collection<TopicPartition> partitions)", "modifiers": "public", "return": "void", "signature": "void seekToBeginning(Collection<TopicPartition> partitions)", "full_signature": "public void seekToBeginning(Collection<TopicPartition> partitions)", "class_method_signature": "KafkaConsumer.seekToBeginning(Collection<TopicPartition> partitions)", "testcase": false, "constructor": false}, {"identifier": "seekToEnd", "parameters": "(Collection<TopicPartition> partitions)", "modifiers": "public", "return": "void", "signature": "void seekToEnd(Collection<TopicPartition> partitions)", "full_signature": "public void seekToEnd(Collection<TopicPartition> partitions)", "class_method_signature": "KafkaConsumer.seekToEnd(Collection<TopicPartition> partitions)", "testcase": false, "constructor": false}, {"identifier": "position", "parameters": "(TopicPartition partition)", "modifiers": "public", "return": "long", "signature": "long position(TopicPartition partition)", "full_signature": "public long position(TopicPartition partition)", "class_method_signature": "KafkaConsumer.position(TopicPartition partition)", "testcase": false, "constructor": false}, {"identifier": "committed", "parameters": "(TopicPartition partition)", "modifiers": "@Override public", "return": "OffsetAndMetadata", "signature": "OffsetAndMetadata committed(TopicPartition partition)", "full_signature": "@Override public OffsetAndMetadata committed(TopicPartition partition)", "class_method_signature": "KafkaConsumer.committed(TopicPartition partition)", "testcase": false, "constructor": false}, {"identifier": "metrics", "parameters": "()", "modifiers": "@Override public", "return": "Map<MetricName, ? extends Metric>", "signature": "Map<MetricName, ? extends Metric> metrics()", "full_signature": "@Override public Map<MetricName, ? extends Metric> metrics()", "class_method_signature": "KafkaConsumer.metrics()", "testcase": false, "constructor": false}, {"identifier": "partitionsFor", "parameters": "(String topic)", "modifiers": "@Override public", "return": "List<PartitionInfo>", "signature": "List<PartitionInfo> partitionsFor(String topic)", "full_signature": "@Override public List<PartitionInfo> partitionsFor(String topic)", "class_method_signature": "KafkaConsumer.partitionsFor(String topic)", "testcase": false, "constructor": false}, {"identifier": "listTopics", "parameters": "()", "modifiers": "@Override public", "return": "Map<String, List<PartitionInfo>>", "signature": "Map<String, List<PartitionInfo>> listTopics()", "full_signature": "@Override public Map<String, List<PartitionInfo>> listTopics()", "class_method_signature": "KafkaConsumer.listTopics()", "testcase": false, "constructor": false}, {"identifier": "pause", "parameters": "(Collection<TopicPartition> partitions)", "modifiers": "@Override public", "return": "void", "signature": "void pause(Collection<TopicPartition> partitions)", "full_signature": "@Override public void pause(Collection<TopicPartition> partitions)", "class_method_signature": "KafkaConsumer.pause(Collection<TopicPartition> partitions)", "testcase": false, "constructor": false}, {"identifier": "resume", "parameters": "(Collection<TopicPartition> partitions)", "modifiers": "@Override public", "return": "void", "signature": "void resume(Collection<TopicPartition> partitions)", "full_signature": "@Override public void resume(Collection<TopicPartition> partitions)", "class_method_signature": "KafkaConsumer.resume(Collection<TopicPartition> partitions)", "testcase": false, "constructor": false}, {"identifier": "paused", "parameters": "()", "modifiers": "@Override public", "return": "Set<TopicPartition>", "signature": "Set<TopicPartition> paused()", "full_signature": "@Override public Set<TopicPartition> paused()", "class_method_signature": "KafkaConsumer.paused()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "KafkaConsumer.close()", "testcase": false, "constructor": false}, {"identifier": "wakeup", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void wakeup()", "full_signature": "@Override public void wakeup()", "class_method_signature": "KafkaConsumer.wakeup()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "(boolean swallowException)", "modifiers": "private", "return": "void", "signature": "void close(boolean swallowException)", "full_signature": "private void close(boolean swallowException)", "class_method_signature": "KafkaConsumer.close(boolean swallowException)", "testcase": false, "constructor": false}, {"identifier": "updateFetchPositions", "parameters": "(Set<TopicPartition> partitions)", "modifiers": "private", "return": "void", "signature": "void updateFetchPositions(Set<TopicPartition> partitions)", "full_signature": "private void updateFetchPositions(Set<TopicPartition> partitions)", "class_method_signature": "KafkaConsumer.updateFetchPositions(Set<TopicPartition> partitions)", "testcase": false, "constructor": false}, {"identifier": "ensureNotClosed", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void ensureNotClosed()", "full_signature": "private void ensureNotClosed()", "class_method_signature": "KafkaConsumer.ensureNotClosed()", "testcase": false, "constructor": false}, {"identifier": "acquire", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void acquire()", "full_signature": "private void acquire()", "class_method_signature": "KafkaConsumer.acquire()", "testcase": false, "constructor": false}, {"identifier": "main", "parameters": "(String[] args)", "modifiers": "public static", "return": "void", "signature": "void main(String[] args)", "full_signature": "public static void main(String[] args)", "class_method_signature": "KafkaConsumer.main(String[] args)", "testcase": false, "constructor": false}, {"identifier": "release", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void release()", "full_signature": "private void release()", "class_method_signature": "KafkaConsumer.release()", "testcase": false, "constructor": false}], "file": "clients/src/main/java/org/apache/kafka/clients/consumer/KafkaConsumer.java"}, "focal_method": {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void close() {\n        acquire();\n        try {\n            if (closed) {\n                return;\n            }\n            close(false);\n        } finally {\n            release();\n        }\n    }", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "KafkaConsumer.close()", "testcase": false, "constructor": false, "invocations": ["acquire", "close", "release"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}