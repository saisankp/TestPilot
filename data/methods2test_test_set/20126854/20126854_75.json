{"test_class": {"identifier": "MinimalZipParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private byte[] unitTestZipArchive;", "modifier": "private", "type": "byte[]", "declarator": "unitTestZipArchive", "var_name": "unitTestZipArchive"}], "file": "feya/libraries/archive_diff/diff.generator/src/test/java/com/google/archivepatcher/generator/MinimalZipParserTest.java"}, "test_case": {"identifier": "testParseEocd", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testParseEocd() throws IOException {\n    int eocdOffset = MinimalZipParser.locateStartOfEocd(unitTestZipArchive);\n    ByteArrayInputStream in = new ByteArrayInputStream(unitTestZipArchive);\n    Assert.assertEquals(eocdOffset, in.skip(eocdOffset));\n    MinimalCentralDirectoryMetadata centralDirectoryMetadata = MinimalZipParser.parseEocd(in);\n    Assert.assertNotNull(centralDirectoryMetadata);\n\n    // Check that the central directory's first record is at the calculated offset\n    //0x02014b50\n    checkExpectedBytes(\n        new byte[] {0x50, 0x4b, 0x01, 0x02},\n        (int) centralDirectoryMetadata.getOffsetOfCentralDirectory());\n    // Check that the central directory's length is correct, i.e. that the EOCD record follows it.\n    long calculatedEndOfCentralDirectory =\n        centralDirectoryMetadata.getOffsetOfCentralDirectory()\n            + centralDirectoryMetadata.getLengthOfCentralDirectory();\n    checkExpectedBytes(new byte[] {0x50, 0x4b, 0x05, 0x06}, (int) calculatedEndOfCentralDirectory);\n    Assert.assertEquals(\n        UnitTestZipArchive.allEntriesInFileOrder.size(),\n        centralDirectoryMetadata.getNumEntriesInCentralDirectory());\n  }", "signature": "void testParseEocd()", "full_signature": "@Test public void testParseEocd()", "class_method_signature": "MinimalZipParserTest.testParseEocd()", "testcase": true, "constructor": false, "invocations": ["locateStartOfEocd", "assertEquals", "skip", "parseEocd", "assertNotNull", "checkExpectedBytes", "getOffsetOfCentralDirectory", "getOffsetOfCentralDirectory", "getLengthOfCentralDirectory", "checkExpectedBytes", "assertEquals", "size", "getNumEntriesInCentralDirectory"]}, "focal_class": {"identifier": "MinimalZipParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int EOCD_SIGNATURE = 0x06054b50;", "modifier": "public static final", "type": "int", "declarator": "EOCD_SIGNATURE = 0x06054b50", "var_name": "EOCD_SIGNATURE"}, {"original_string": "public static final int CENTRAL_DIRECTORY_ENTRY_SIGNATURE = 0x02014b50;", "modifier": "public static final", "type": "int", "declarator": "CENTRAL_DIRECTORY_ENTRY_SIGNATURE = 0x02014b50", "var_name": "CENTRAL_DIRECTORY_ENTRY_SIGNATURE"}, {"original_string": "public static final int LOCAL_ENTRY_SIGNATURE = 0x04034b50;", "modifier": "public static final", "type": "int", "declarator": "LOCAL_ENTRY_SIGNATURE = 0x04034b50", "var_name": "LOCAL_ENTRY_SIGNATURE"}], "methods": [{"identifier": "readByteOrDie", "parameters": "(InputStream in)", "modifiers": "private static", "return": "int", "signature": "int readByteOrDie(InputStream in)", "full_signature": "private static int readByteOrDie(InputStream in)", "class_method_signature": "MinimalZipParser.readByteOrDie(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "skipOrDie", "parameters": "(InputStream in, long numBytes)", "modifiers": "private static", "return": "void", "signature": "void skipOrDie(InputStream in, long numBytes)", "full_signature": "private static void skipOrDie(InputStream in, long numBytes)", "class_method_signature": "MinimalZipParser.skipOrDie(InputStream in, long numBytes)", "testcase": false, "constructor": false}, {"identifier": "read16BitUnsigned", "parameters": "(InputStream in)", "modifiers": "private static", "return": "int", "signature": "int read16BitUnsigned(InputStream in)", "full_signature": "private static int read16BitUnsigned(InputStream in)", "class_method_signature": "MinimalZipParser.read16BitUnsigned(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "read32BitUnsigned", "parameters": "(InputStream in)", "modifiers": "private static", "return": "long", "signature": "long read32BitUnsigned(InputStream in)", "full_signature": "private static long read32BitUnsigned(InputStream in)", "class_method_signature": "MinimalZipParser.read32BitUnsigned(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "readOrDie", "parameters": "(InputStream in, byte[] buffer, int offset, int length)", "modifiers": "private static", "return": "void", "signature": "void readOrDie(InputStream in, byte[] buffer, int offset, int length)", "full_signature": "private static void readOrDie(InputStream in, byte[] buffer, int offset, int length)", "class_method_signature": "MinimalZipParser.readOrDie(InputStream in, byte[] buffer, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "parseCentralDirectoryEntry", "parameters": "(InputStream in)", "modifiers": "public static", "return": "MinimalZipEntry", "signature": "MinimalZipEntry parseCentralDirectoryEntry(InputStream in)", "full_signature": "public static MinimalZipEntry parseCentralDirectoryEntry(InputStream in)", "class_method_signature": "MinimalZipParser.parseCentralDirectoryEntry(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "parseLocalEntryAndGetCompressedDataOffset", "parameters": "(InputStream in)", "modifiers": "public static", "return": "long", "signature": "long parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "full_signature": "public static long parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "class_method_signature": "MinimalZipParser.parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "locateStartOfEocd", "parameters": "(RandomAccessFileInputStream in, int searchBufferLength)", "modifiers": "public static", "return": "long", "signature": "long locateStartOfEocd(RandomAccessFileInputStream in, int searchBufferLength)", "full_signature": "public static long locateStartOfEocd(RandomAccessFileInputStream in, int searchBufferLength)", "class_method_signature": "MinimalZipParser.locateStartOfEocd(RandomAccessFileInputStream in, int searchBufferLength)", "testcase": false, "constructor": false}, {"identifier": "locateStartOfEocd", "parameters": "(byte[] buffer)", "modifiers": "public static", "return": "int", "signature": "int locateStartOfEocd(byte[] buffer)", "full_signature": "public static int locateStartOfEocd(byte[] buffer)", "class_method_signature": "MinimalZipParser.locateStartOfEocd(byte[] buffer)", "testcase": false, "constructor": false}, {"identifier": "parseEocd", "parameters": "(InputStream in)", "modifiers": "public static", "return": "MinimalCentralDirectoryMetadata", "signature": "MinimalCentralDirectoryMetadata parseEocd(InputStream in)", "full_signature": "public static MinimalCentralDirectoryMetadata parseEocd(InputStream in)", "class_method_signature": "MinimalZipParser.parseEocd(InputStream in)", "testcase": false, "constructor": false}], "file": "feya/libraries/archive_diff/diff.generator/src/main/java/com/google/archivepatcher/generator/MinimalZipParser.java"}, "focal_method": {"identifier": "parseEocd", "parameters": "(InputStream in)", "modifiers": "public static", "return": "MinimalCentralDirectoryMetadata", "body": "public static MinimalCentralDirectoryMetadata parseEocd(InputStream in)\n      throws IOException, ZipException {\n    if (((int) read32BitUnsigned(in)) != EOCD_SIGNATURE) {\n      throw new ZipException(\"Bad eocd header\");\n    }\n\n    // *** 4 bytes encode EOCD_SIGNATURE, ignore (already found and verified).\n    // 2 bytes encode disk number for this archive, ignore.\n    // 2 bytes encode disk number for the central directory, ignore.\n    // 2 bytes encode num entries in the central directory on this disk, ignore.\n    // *** 2 bytes encode num entries in the central directory overall [READ THIS]\n    // *** 4 bytes encode the length of the central directory [READ THIS]\n    // *** 4 bytes encode the file offset of the central directory [READ THIS]\n    // 2 bytes encode the length of the zip file comment, ignore.\n    // Everything else from here to the EOF is the zip file comment, or junk. Ignore.\n    skipOrDie(in, 2 + 2 + 2);\n    int numEntriesInCentralDirectory = read16BitUnsigned(in);\n    if (numEntriesInCentralDirectory == 0xffff) {\n      // If 0xffff, this is a zip64 archive and this code doesn't handle that.\n      throw new ZipException(\"No support for zip64\");\n    }\n    long lengthOfCentralDirectory = read32BitUnsigned(in);\n    long offsetOfCentralDirectory = read32BitUnsigned(in);\n    return new MinimalCentralDirectoryMetadata(\n        numEntriesInCentralDirectory, offsetOfCentralDirectory, lengthOfCentralDirectory);\n  }", "signature": "MinimalCentralDirectoryMetadata parseEocd(InputStream in)", "full_signature": "public static MinimalCentralDirectoryMetadata parseEocd(InputStream in)", "class_method_signature": "MinimalZipParser.parseEocd(InputStream in)", "testcase": false, "constructor": false, "invocations": ["read32BitUnsigned", "skipOrDie", "read16BitUnsigned", "read32BitUnsigned", "read32BitUnsigned"]}, "repository": {"repo_id": 20126854, "url": "https://github.com/kaedea/Feya", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 12, "size": 7798, "license": "licensed"}}