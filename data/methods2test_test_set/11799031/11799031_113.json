{"test_class": {"identifier": "CRSUtilityTest", "superclass": "", "interfaces": "", "fields": [], "file": "gdp-core-processing/src/test/java/gov/usgs/cida/gdp/coreprocessing/analysis/grid/CRSUtilityTest.java"}, "test_case": {"identifier": "testEarthRadiusIfMissingFromGridMapping", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testEarthRadiusIfMissingFromGridMapping() throws IOException {\n        FeatureDataset fd = FeatureDatasetFactoryManager.open(\n                FeatureType.ANY,\n                \"src/test/resources/crs/ACFclimBasins.ncml\",\n                null, \n                new Formatter(System.err));\n        if (fd != null && fd instanceof GridDataset) {\n            \n            GridDataset gd = (GridDataset)fd;\n            \n            GridDatatype gdt = gd.findGridDatatype(\"xppt\");\n            assertNotNull(gdt);\n            \n            GridCoordSystem gcs = gdt.getCoordinateSystem();\n            assertNotNull(gcs);\n            \n            CoordinateReferenceSystem crs = CRSUtility.getCRSFromGridCoordSystem(gcs);\n            assertNotNull(crs);\n            \n            // verify prior issue resolution, that ellipsoid parameters of expected values\n            assertTrue(crs instanceof ProjectedCRS);\n            ProjectedCRS pcrs = (ProjectedCRS)crs;\n            assertEquals(6371229.0, pcrs.getDatum().getEllipsoid().getSemiMajorAxis(), 0);\n            assertEquals(SI.METER, pcrs.getDatum().getEllipsoid().getAxisUnit());\n            \n        } else {\n            fail(\"Unable to open test dataset.\");\n        }\n    }", "signature": "void testEarthRadiusIfMissingFromGridMapping()", "full_signature": "@Test public void testEarthRadiusIfMissingFromGridMapping()", "class_method_signature": "CRSUtilityTest.testEarthRadiusIfMissingFromGridMapping()", "testcase": true, "constructor": false, "invocations": ["open", "findGridDatatype", "assertNotNull", "getCoordinateSystem", "assertNotNull", "getCRSFromGridCoordSystem", "assertNotNull", "assertTrue", "assertEquals", "getSemiMajorAxis", "getEllipsoid", "getDatum", "assertEquals", "getAxisUnit", "getEllipsoid", "getDatum", "fail"]}, "focal_class": {"identifier": "CRSUtility", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final static ParameterDescriptorGroup EMPTY_PARAMETER_DESCRIPTORS =\n\t\t\t\tnew DefaultParameterDescriptorGroup(\"\", new GeneralParameterDescriptor[0] );", "modifier": "private final static", "type": "ParameterDescriptorGroup", "declarator": "EMPTY_PARAMETER_DESCRIPTORS =\n\t\t\t\tnew DefaultParameterDescriptorGroup(\"\", new GeneralParameterDescriptor[0] )", "var_name": "EMPTY_PARAMETER_DESCRIPTORS"}, {"original_string": "private final static MathTransform longitudeCenter180Modulo360Transform = new AbstractMathTransform() {\n\n        @Override public int getSourceDimensions() { return 2; }\n        @Override public int getTargetDimensions() { return 2; }\n\n        @Override\n        public ParameterDescriptorGroup getParameterDescriptors() {\n\t\t\treturn EMPTY_PARAMETER_DESCRIPTORS;\n\t\t}\n\n        @Override\n        public MathTransform inverse() throws NoninvertibleTransformException {\n            return longitudeCenter0Modulo360Transform;\n        }\n\n        @Override\n        public void transform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts) throws TransformException {\n            int count = numPts * 2;\n            for (int index = 0; index < count; index += 2) {\n                dstPts[dstOff + index] = transformLongitudeCenter180Modulo360(srcPts[srcOff + index]);\n                dstPts[dstOff + index + 1] = srcPts[srcOff + index + 1];\n            }\n        }\n    };", "modifier": "private final static", "type": "MathTransform", "declarator": "longitudeCenter180Modulo360Transform = new AbstractMathTransform() {\n\n        @Override public int getSourceDimensions() { return 2; }\n        @Override public int getTargetDimensions() { return 2; }\n\n        @Override\n        public ParameterDescriptorGroup getParameterDescriptors() {\n\t\t\treturn EMPTY_PARAMETER_DESCRIPTORS;\n\t\t}\n\n        @Override\n        public MathTransform inverse() throws NoninvertibleTransformException {\n            return longitudeCenter0Modulo360Transform;\n        }\n\n        @Override\n        public void transform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts) throws TransformException {\n            int count = numPts * 2;\n            for (int index = 0; index < count; index += 2) {\n                dstPts[dstOff + index] = transformLongitudeCenter180Modulo360(srcPts[srcOff + index]);\n                dstPts[dstOff + index + 1] = srcPts[srcOff + index + 1];\n            }\n        }\n    }", "var_name": "longitudeCenter180Modulo360Transform"}, {"original_string": "private final static MathTransform longitudeCenter0Modulo360Transform = new AbstractMathTransform() {\n\n        @Override public int getSourceDimensions() { return 2; }\n        @Override public int getTargetDimensions() { return 2; }\n\n        @Override\n\t\tpublic ParameterDescriptorGroup getParameterDescriptors() {\n\t\t\treturn EMPTY_PARAMETER_DESCRIPTORS;\n\t\t}\n\n        @Override\n        public MathTransform inverse() throws NoninvertibleTransformException {\n            return longitudeCenter180Modulo360Transform;\n        }\n\n        @Override\n        public void transform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts) throws TransformException {\n            int count = numPts * 2;\n            for (int index = srcOff; index < count; index += 2) {\n                dstPts[dstOff + index] = transformLongitudeCenter0Modulo360(srcPts[srcOff + index]);\n                dstPts[dstOff + index + 1] = srcPts[srcOff + index + 1];\n            }\n        }\n    };", "modifier": "private final static", "type": "MathTransform", "declarator": "longitudeCenter0Modulo360Transform = new AbstractMathTransform() {\n\n        @Override public int getSourceDimensions() { return 2; }\n        @Override public int getTargetDimensions() { return 2; }\n\n        @Override\n\t\tpublic ParameterDescriptorGroup getParameterDescriptors() {\n\t\t\treturn EMPTY_PARAMETER_DESCRIPTORS;\n\t\t}\n\n        @Override\n        public MathTransform inverse() throws NoninvertibleTransformException {\n            return longitudeCenter180Modulo360Transform;\n        }\n\n        @Override\n        public void transform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts) throws TransformException {\n            int count = numPts * 2;\n            for (int index = srcOff; index < count; index += 2) {\n                dstPts[dstOff + index] = transformLongitudeCenter0Modulo360(srcPts[srcOff + index]);\n                dstPts[dstOff + index + 1] = srcPts[srcOff + index + 1];\n            }\n        }\n    }", "var_name": "longitudeCenter0Modulo360Transform"}], "methods": [{"identifier": "getCRSFromGridDatatype", "parameters": "(GridDatatype gd)", "modifiers": "public static", "return": "CoordinateReferenceSystem", "signature": "CoordinateReferenceSystem getCRSFromGridDatatype(GridDatatype gd)", "full_signature": "public static CoordinateReferenceSystem getCRSFromGridDatatype(GridDatatype gd)", "class_method_signature": "CRSUtility.getCRSFromGridDatatype(GridDatatype gd)", "testcase": false, "constructor": false}, {"identifier": "getCRSFromGridCoordSystem", "parameters": "(GridCoordSystem gcs)", "modifiers": "public static", "return": "CoordinateReferenceSystem", "signature": "CoordinateReferenceSystem getCRSFromGridCoordSystem(GridCoordSystem gcs)", "full_signature": "public static CoordinateReferenceSystem getCRSFromGridCoordSystem(GridCoordSystem gcs)", "class_method_signature": "CRSUtility.getCRSFromGridCoordSystem(GridCoordSystem gcs)", "testcase": false, "constructor": false}, {"identifier": "generateAxisLengthUnit", "parameters": "(GridCoordSystem gcs)", "modifiers": "private static", "return": "Unit<Length>", "signature": "Unit<Length> generateAxisLengthUnit(GridCoordSystem gcs)", "full_signature": "private static Unit<Length> generateAxisLengthUnit(GridCoordSystem gcs)", "class_method_signature": "CRSUtility.generateAxisLengthUnit(GridCoordSystem gcs)", "testcase": false, "constructor": false}, {"identifier": "generateEllipsoid", "parameters": "(Map<String, Parameter> parameterMap)", "modifiers": "private static", "return": "DefaultEllipsoid", "signature": "DefaultEllipsoid generateEllipsoid(Map<String, Parameter> parameterMap)", "full_signature": "private static DefaultEllipsoid generateEllipsoid(Map<String, Parameter> parameterMap)", "class_method_signature": "CRSUtility.generateEllipsoid(Map<String, Parameter> parameterMap)", "testcase": false, "constructor": false}, {"identifier": "generatePrimeMeridian", "parameters": "(Map<String, Parameter> parameterMap)", "modifiers": "private static", "return": "DefaultPrimeMeridian", "signature": "DefaultPrimeMeridian generatePrimeMeridian(Map<String, Parameter> parameterMap)", "full_signature": "private static DefaultPrimeMeridian generatePrimeMeridian(Map<String, Parameter> parameterMap)", "class_method_signature": "CRSUtility.generatePrimeMeridian(Map<String, Parameter> parameterMap)", "testcase": false, "constructor": false}, {"identifier": "generateGeodeticDatum", "parameters": "(Map<String, Parameter> parameterMap)", "modifiers": "private static", "return": "DefaultGeodeticDatum", "signature": "DefaultGeodeticDatum generateGeodeticDatum(Map<String, Parameter> parameterMap)", "full_signature": "private static DefaultGeodeticDatum generateGeodeticDatum(Map<String, Parameter> parameterMap)", "class_method_signature": "CRSUtility.generateGeodeticDatum(Map<String, Parameter> parameterMap)", "testcase": false, "constructor": false}, {"identifier": "transformLongitudeCenter180Modulo360", "parameters": "(double longitude)", "modifiers": "private static", "return": "double", "signature": "double transformLongitudeCenter180Modulo360(double longitude)", "full_signature": "private static double transformLongitudeCenter180Modulo360(double longitude)", "class_method_signature": "CRSUtility.transformLongitudeCenter180Modulo360(double longitude)", "testcase": false, "constructor": false}, {"identifier": "transformLongitudeCenter0Modulo360", "parameters": "(double longitude)", "modifiers": "private static", "return": "double", "signature": "double transformLongitudeCenter0Modulo360(double longitude)", "full_signature": "private static double transformLongitudeCenter0Modulo360(double longitude)", "class_method_signature": "CRSUtility.transformLongitudeCenter0Modulo360(double longitude)", "testcase": false, "constructor": false}], "file": "gdp-core-processing/src/main/java/gov/usgs/cida/gdp/coreprocessing/analysis/grid/CRSUtility.java"}, "focal_method": {"identifier": "getCRSFromGridCoordSystem", "parameters": "(GridCoordSystem gcs)", "modifiers": "public static", "return": "CoordinateReferenceSystem", "body": "public static CoordinateReferenceSystem getCRSFromGridCoordSystem(GridCoordSystem gcs) {\n\n\t\tProjectionImpl projection = gcs.getProjection();\n\t\tif (projection == null) {\n\t\t\treturn DefaultGeographicCRS.WGS84;\n\t\t}\n\t\n\t\tMap<String, Parameter> parameterMap = new HashMap<String, Parameter>();\n\t\tfor (Parameter p : projection.getProjectionParameters()) {\n\t\t\tparameterMap.put(p.getName(), p);\n\t\t}\n\n\t\tGeodeticDatum datum = generateGeodeticDatum(parameterMap);\n\n\t\tParameter gridMappingNameParameter = parameterMap.get(\"grid_mapping_name\");\n\n\t\tString gridMappingName = gridMappingNameParameter == null ?\n\t\t\t\t\"LatLon\" :\n\t\t\t\tgridMappingNameParameter.getStringValue();\n\n\n\t\tGeographicCRS geographicCRS = (datum == DefaultGeodeticDatum.WGS84) ?\n\t\t\t\tDefaultGeographicCRS.WGS84 :\n\t\t\t\tnew DefaultGeographicCRS(\n\t\t\t\t\t\"CF-Derived Geographic CRS\",\n\t\t\t\t\tdatum,\n\t\t\t\t\tDefaultEllipsoidalCS.GEODETIC_2D);\n\n\t\tif (\"LatLon\".equals(gridMappingName) || \"latitude_longitude\".equals(gridMappingName)) {\n\n            ProjectionRect projectionRect = gcs.getBoundingBox();\n            boolean longitude360 = projectionRect.getMaxX() > 180;\n            if (longitude360) {\n                \n                Map<String, Object> crsPoperties = new HashMap<String, Object>();\n                \n                crsPoperties.put(IdentifiedObject.NAME_KEY, \"CRS LON [0,360]\");\n\n                ExtentImpl extent = new ExtentImpl();\n                List<GeographicExtent> extentList = new ArrayList<GeographicExtent>();\n                extentList.add(new GeographicBoundingBoxImpl(0, 360, -90, 90));\n                extent.setGeographicElements(extentList);\n                crsPoperties.put(ReferenceSystem.DOMAIN_OF_VALIDITY_KEY, extent);\n\n                return new DefaultDerivedCRS(\n                    \"CF-Derived CRS LON [0,360]\",\n                    geographicCRS,\n                    longitudeCenter180Modulo360Transform,\n                    DefaultEllipsoidalCS.GEODETIC_2D);\n            } else {\n                return geographicCRS;\n            }\n\t\t}\n\n\t\ttry {\n\n            Unit<Length> axisLengthUnit = generateAxisLengthUnit(gcs);\n\n\t\t\tDefaultMathTransformFactory transformFactory =\n\t\t\t\t\t\tnew DefaultMathTransformFactory();\n\n\t\t\tParameterValueGroup parameterGroup = null;\n\t\t\n\t\t\tif (\"albers_conical_equal_area\".equals(gridMappingName)) {\n\n\t\t\t\tparameterGroup =\n\t\t\t\t\t\ttransformFactory.getDefaultParameters(\"Albers_Conic_Equal_Area\");\n\t\t\t\tProjectionParameterAdapter adapter = new ProjectionParameterAdapter(axisLengthUnit, parameterMap, parameterGroup);\n\t\t\t\tadapter.transferAngle(\"longitude_of_central_meridian\", \"longitude_of_center\");\n\t\t\t\tadapter.transferAngle(\"latitude_of_projection_origin\", \"latitude_of_center\");\n\t\t\t\tadapter.transferLength(\"false_easting\", \"false_easting\");\n\t\t\t\tadapter.transferLength(\"false_northing\", \"false_northing\");\n\t\t\t\tadapter.transferStandardParallels();\n\t\t\t\tadapter.transferEllipsoid(datum.getEllipsoid());\n\n\t\t\t} else if (\"azimuthal_equidistant\".equals(gridMappingName)) {\n\n\t\t\t\tthrow new RuntimeException(\"azimuthal_equidistant projection is not supported\");\n\n\t\t\t} else if (\"lambert_azimuthal_equal_area\".equals(gridMappingName)) {\n\n\t\t\t\tparameterGroup =\n\t\t\t\t\t\ttransformFactory.getDefaultParameters(\"Lambert_Azimuthal_Equal_Area\");\n\t\t\t\tProjectionParameterAdapter adapter = new ProjectionParameterAdapter(axisLengthUnit, parameterMap, parameterGroup);\n\t\t\t\tadapter.transferAngle(\"longitude_of_projection_origin\", \"longitude_of_center\");\n\t\t\t\tadapter.transferAngle(\"latitude_of_projection_origin\", \"latitude_of_center\");\n\t\t\t\tadapter.transferLength(\"false_easting\", \"false_easting\");\n\t\t\t\tadapter.transferLength(\"false_northing\", \"false_northing\");\n\t\t\t\tadapter.transferEllipsoid(datum.getEllipsoid());\n\n\t\t\t} else if (\"lambert_conformal_conic\".equals(gridMappingName)) {\n\n                boolean is2SP = ProjectionParameterAdapter.getStandardParallelCount(parameterMap) == 2;\n\t\t\t\tparameterGroup = is2SP ?\n                        transformFactory.getDefaultParameters(\"Lambert_Conformal_Conic_2SP\") :\n\t\t\t\t\t\ttransformFactory.getDefaultParameters(\"Lambert_Conformal_Conic_1SP\");\n\t\t\t\tProjectionParameterAdapter adapter = new ProjectionParameterAdapter(axisLengthUnit, parameterMap, parameterGroup);\n\t\t\t\tadapter.transferAngle(\"longitude_of_central_meridian\", \"central_meridian\");\n\t\t\t\tadapter.transferAngle(\"latitude_of_projection_origin\", \"latitude_of_origin\");\n\t\t\t\tadapter.transferLength(\"false_easting\", \"false_easting\");\n\t\t\t\tadapter.transferLength(\"false_northing\", \"false_northing\");\n                if (is2SP) { \n                    adapter.transferStandardParallels();\n                } // else { /* scale_factor parameter is default of 1.0. */ }\n\t\t\t\tadapter.transferEllipsoid(datum.getEllipsoid());\n\n\t\t\t} else if (\"lambert_cylindrical_equal_area\".equals(gridMappingName)) {\n\n\t\t\t\tthrow new RuntimeException(\"lambert_cylindrical_equal_area projection is not supported\");\n\n\t\t\t} else if (\"mercator\".equals(gridMappingName)) {\n\n\t\t\t\t// presence of \"standard_parallel\" indicates Mercator_2SP while\n\t\t\t\t// \"scale_factor_at_projection_origin\" indicates Mercator_1SP\n                boolean is2SP = parameterMap.containsKey(\"standard_parallel\");\n\t\t\t\tparameterGroup = is2SP ?\n\t\t\t\t\t\ttransformFactory.getDefaultParameters(\"Mercator_2SP\") :\n\t\t\t\t\t\ttransformFactory.getDefaultParameters(\"Mercator_1SP\");\n\t\t\t\tProjectionParameterAdapter adapter = new ProjectionParameterAdapter(axisLengthUnit, parameterMap, parameterGroup);\n\t\t\t\tadapter.transferAngle(\"longitude_of_projection_origin\", \"central_meridian\");\n\t\t\t\tadapter.transferLength(\"false_easting\", \"false_easting\");\n\t\t\t\tadapter.transferLength(\"false_northing\", \"false_northing\");\n\t\t\t\tif (is2SP) {\n                    adapter.transferStandardParallels();\n                } else {\n                    adapter.transferUnitless(\"scale_factor_at_projection_origin\", \"scale_factor\");\n                }\n\t\t\t\tadapter.transferEllipsoid(datum.getEllipsoid());\n\n\t\t\t} else if (\"orthographic\".equals(gridMappingName)) {\n\n\t\t\t\tparameterGroup =\n\t\t\t\t\t\ttransformFactory.getDefaultParameters(\"Orthographic\");\n\t\t\t\tProjectionParameterAdapter adapter = new ProjectionParameterAdapter(axisLengthUnit, parameterMap, parameterGroup);\n\t\t\t\tadapter.transferAngle(\"longitude_of_projection_origin\", \"central_meridian\");\n\t\t\t\tadapter.transferAngle(\"latitude_of_projection_origin\", \"latitude_of_origin\");\n\t\t\t\tadapter.transferLength(\"false_easting\", \"false_easting\");\n\t\t\t\tadapter.transferLength(\"false_northing\", \"false_northing\");\n\t\t\t\tadapter.transferEllipsoid(datum.getEllipsoid());\n\n\t\t\t} else if (\"polar_stereographic\".equals(gridMappingName)) {\n\n\t\t\t\tparameterGroup =\n\t\t\t\t\t\ttransformFactory.getDefaultParameters(\"Polar_Stereographic\");\n\t\t\t\tProjectionParameterAdapter adapter = new ProjectionParameterAdapter(axisLengthUnit, parameterMap, parameterGroup);\n\t\t\t\tadapter.transferAngle(\"straight_vertical_longitude_from_pole\", \"central_meridian\");\n\t\t\t\tadapter.transferAngle(\"latitude_of_projection_origin\", \"latitude_of_origin\");\n\t\t\t\tadapter.transferUnitless(\"scale_factor_at_projection_origin\", \"scale_factor\");\n\t\t\t\tadapter.transferLength(\"false_easting\", \"false_easting\");\n\t\t\t\tadapter.transferLength(\"false_northing\", \"false_northing\");\n\t\t\t\tadapter.transferStandardParallels();\n\t\t\t\tadapter.transferEllipsoid(datum.getEllipsoid());\n\n\t\t\t} else if (\"rotated_latitude_longitude\".equals(gridMappingName)) {\n\n\t\t\t\tthrow new RuntimeException(\"rotated_latitude_longitude projection is not supported\");\n\n\t\t\t} else if (\"stereographic\".equals(gridMappingName)) {\n\n\t\t\t\tparameterGroup =\n\t\t\t\t\t\ttransformFactory.getDefaultParameters(\"Stereographic\");\n\t\t\t\tProjectionParameterAdapter adapter = new ProjectionParameterAdapter(axisLengthUnit, parameterMap, parameterGroup);\n\t\t\t\tadapter.transferAngle(\"longitude_of_projection_origin\", \"central_meridian\");\n\t\t\t\tadapter.transferAngle(\"latitude_of_projection_origin\", \"latitude_of_origin\");\n\t\t\t\tadapter.transferUnitless(\"scale_factor_at_projection_origin\", \"scale_factor\");\n\t\t\t\tadapter.transferLength(\"false_easting\", \"false_easting\");\n\t\t\t\tadapter.transferLength(\"false_northing\", \"false_northing\");\n\t\t\t\tadapter.transferEllipsoid(datum.getEllipsoid());\n\n\t\t\t} else if (\"transverse_mercator\".equals(gridMappingName)) {\n\n\t\t\t\tparameterGroup =\n\t\t\t\t\t\ttransformFactory.getDefaultParameters(\"Transverse_Mercator\");\n\t\t\t\tProjectionParameterAdapter adapter = new ProjectionParameterAdapter(axisLengthUnit, parameterMap, parameterGroup);\n\t\t\t\tadapter.transferUnitless(\"scale_factor_at_central_meridian\", \"scale_factor\");\n\t\t\t\tadapter.transferAngle(\"longitude_of_central_meridian\", \"central_meridian\");\n\t\t\t\tadapter.transferAngle(\"latitude_of_projection_origin\", \"latitude_of_origin\");\n\t\t\t\tadapter.transferLength(\"false_easting\", \"false_easting\");\n\t\t\t\tadapter.transferLength(\"false_northing\", \"false_northing\");\n\t\t\t\tadapter.transferEllipsoid(datum.getEllipsoid());\n\n\t\t\t} else if (\"vertical_perspective\".equals(gridMappingName)) {\n\n\t\t\t\tthrow new RuntimeException(\"vertical_perspective projection is not supported\");\n\n            }\n\n\t\t\tif (parameterGroup == null) {\n\t\t\t\tthrow new RuntimeException(\"unknown grid_mapping_name\");\n\t\t\t}\n\n\t\t\tCartesianCS cartesianCS = DefaultCartesianCS.PROJECTED.usingUnit(axisLengthUnit);\n\n\t\t\t/* DOESN'T WORK - settings axis units is not enough, must also perform operation\n\t\t\t * in transform.  see below...\n\t\t\tMathTransform transform = transformFactory.createParameterizedTransform(parameterGroup);\n\t\t\tProjectedCRS projectedCRS = new DefaultProjectedCRS(\n\t\t\t\t\t\"CF-Derived Projected CRS\",\n\t\t\t\t\tgeographicCRS,\n\t\t\t\t\ttransform,\n\t\t\t\t\tcartesianCS);\n\t\t\t */\n\n\t\t\t/*  WORKAROUND - PART 1:  This call will generate ConcatenatedTransform\n\t\t\t *  instance with ability to scale values as needed.\n\t\t\t */\n\t\t\tMathTransform transform = transformFactory.createBaseToDerived(\n\t\t\t\t\t\tgeographicCRS,\n\t\t\t\t\t\tparameterGroup,\n\t\t\t\t\t\tcartesianCS);\n\n\t\t\t/*  WORKAROUND - PART 2: Wrap ConcatenatedTransform instance so\n\t\t\t *  that MathTransform.getParameterDescriptors() returns something\n\t\t\t *  other than null...\n\t\t\t */\n\t\t\tif (! (transform instanceof ConcatenatedTransform)) {\n\t\t\t\tthrow new RuntimeException(\"Expected instance of ConcatenatedTransform\");\n\t\t\t}\n\t\t\tMathTransform wrapped = new ConcatenatedTransformAdapter((ConcatenatedTransform)transform);\n\n\t\t\t/*  WORKAROUND - PART 3: Create ProjectedCRS instance around\n\t\t\t *  wrapped ConcatenatedTransform instance with same axis used\n\t\t\t *  to generate ConcatenatedTransform\n\t\t\t */\n\t\t\tProjectedCRS projectedCRS = new DefaultProjectedCRS(\n\t\t\t\t\"CF-Derived Projected CRS\",\n\t\t\t\tgeographicCRS,\n\t\t\t\twrapped,\n\t\t\t\tcartesianCS);\n\n\t\t\treturn projectedCRS;\n\n\t\t} catch (NoSuchIdentifierException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t} catch (FactoryException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}", "signature": "CoordinateReferenceSystem getCRSFromGridCoordSystem(GridCoordSystem gcs)", "full_signature": "public static CoordinateReferenceSystem getCRSFromGridCoordSystem(GridCoordSystem gcs)", "class_method_signature": "CRSUtility.getCRSFromGridCoordSystem(GridCoordSystem gcs)", "testcase": false, "constructor": false, "invocations": ["getProjection", "getProjectionParameters", "put", "getName", "generateGeodeticDatum", "get", "getStringValue", "equals", "equals", "getBoundingBox", "getMaxX", "put", "add", "setGeographicElements", "put", "generateAxisLengthUnit", "equals", "getDefaultParameters", "transferAngle", "transferAngle", "transferLength", "transferLength", "transferStandardParallels", "transferEllipsoid", "getEllipsoid", "equals", "equals", "getDefaultParameters", "transferAngle", "transferAngle", "transferLength", "transferLength", "transferEllipsoid", "getEllipsoid", "equals", "getStandardParallelCount", "getDefaultParameters", "getDefaultParameters", "transferAngle", "transferAngle", "transferLength", "transferLength", "transferStandardParallels", "transferEllipsoid", "getEllipsoid", "equals", "equals", "containsKey", "getDefaultParameters", "getDefaultParameters", "transferAngle", "transferLength", "transferLength", "transferStandardParallels", "transferUnitless", "transferEllipsoid", "getEllipsoid", "equals", "getDefaultParameters", "transferAngle", "transferAngle", "transferLength", "transferLength", "transferEllipsoid", "getEllipsoid", "equals", "getDefaultParameters", "transferAngle", "transferAngle", "transferUnitless", "transferLength", "transferLength", "transferStandardParallels", "transferEllipsoid", "getEllipsoid", "equals", "equals", "getDefaultParameters", "transferAngle", "transferAngle", "transferUnitless", "transferLength", "transferLength", "transferEllipsoid", "getEllipsoid", "equals", "getDefaultParameters", "transferUnitless", "transferAngle", "transferAngle", "transferLength", "transferLength", "transferEllipsoid", "getEllipsoid", "equals", "usingUnit", "createBaseToDerived"]}, "repository": {"repo_id": 11799031, "url": "https://github.com/USGS-CIDA/geo-data-portal", "language": "Java", "is_fork": false, "fork_count": 21, "stargazer_count": 9, "size": 178468, "license": "licensed"}}