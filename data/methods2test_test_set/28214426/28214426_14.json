{"test_class": {"identifier": "StructuredLoggerImplTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final static String LOG_MSG = \"{}\";", "modifier": "private final static", "type": "String", "declarator": "LOG_MSG = \"{}\"", "var_name": "LOG_MSG"}, {"original_string": "@Mock\n  private Logger innerLogger;", "modifier": "@Mock\n  private", "type": "Logger", "declarator": "innerLogger", "var_name": "innerLogger"}, {"original_string": "@Mock\n  private SchemaAndValue msg;", "modifier": "@Mock\n  private", "type": "SchemaAndValue", "declarator": "msg", "var_name": "msg"}, {"original_string": "@Mock\n  private Supplier<SchemaAndValue> msgSupplier;", "modifier": "@Mock\n  private", "type": "Supplier<SchemaAndValue>", "declarator": "msgSupplier", "var_name": "msgSupplier"}, {"original_string": "@Captor\n  private ArgumentCaptor<SerializableSchemaAndValue> captor;", "modifier": "@Captor\n  private", "type": "ArgumentCaptor<SerializableSchemaAndValue>", "declarator": "captor", "var_name": "captor"}, {"original_string": "private StructuredLoggerImpl logger;", "modifier": "private", "type": "StructuredLoggerImpl", "declarator": "logger", "var_name": "logger"}, {"original_string": "@Rule\n  public MockitoRule rule = MockitoJUnit.rule();", "modifier": "@Rule\n  public", "type": "MockitoRule", "declarator": "rule = MockitoJUnit.rule()", "var_name": "rule"}], "file": "logging/src/test/java/io/confluent/common/logging/StructuredLoggerImplTest.java"}, "test_case": {"identifier": "shouldSerializeMessageToJsonString", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void shouldSerializeMessageToJsonString() throws IOException {\n    // Given:\n    final Schema msgSchema = SchemaBuilder.struct()\n        .field(\"field1\", Schema.STRING_SCHEMA)\n        .field(\"field2\", Schema.INT32_SCHEMA)\n        .build();\n    final Struct msgStruct = new Struct(msgSchema);\n    msgStruct.put(\"field1\", \"foobar\");\n    msgStruct.put(\"field2\", 123);\n    final SchemaAndValue schemaAndValue = new SchemaAndValue(msgSchema, msgStruct);\n\n    // When:\n    logger.info(schemaAndValue);\n\n    // Then:\n    verify(innerLogger).info(any(), captor.capture());\n    final String asString = captor.getValue().toString();\n    final Object deserialized = new ObjectMapper().readValue(asString, Object.class);\n    assertThat(deserialized, instanceOf(Map.class));\n    assertThat(\n        deserialized,\n        equalTo(\n            ImmutableMap.of(\n                \"field1\", \"foobar\",\n                \"field2\", 123)));\n  }", "signature": "void shouldSerializeMessageToJsonString()", "full_signature": "@Test public void shouldSerializeMessageToJsonString()", "class_method_signature": "StructuredLoggerImplTest.shouldSerializeMessageToJsonString()", "testcase": true, "constructor": false, "invocations": ["build", "field", "field", "struct", "put", "put", "info", "info", "verify", "any", "capture", "toString", "getValue", "readValue", "assertThat", "instanceOf", "assertThat", "equalTo", "of"]}, "focal_class": {"identifier": "StructuredLoggerImpl", "superclass": "", "interfaces": "implements StructuredLogger", "fields": [{"original_string": "private static final String LOG_MSG = \"{}\";", "modifier": "private static final", "type": "String", "declarator": "LOG_MSG = \"{}\"", "var_name": "LOG_MSG"}, {"original_string": "private final Logger inner;", "modifier": "private final", "type": "Logger", "declarator": "inner", "var_name": "inner"}], "methods": [{"identifier": "StructuredLoggerImpl", "parameters": "(final Logger inner)", "modifiers": "", "return": "", "signature": " StructuredLoggerImpl(final Logger inner)", "full_signature": "  StructuredLoggerImpl(final Logger inner)", "class_method_signature": "StructuredLoggerImpl.StructuredLoggerImpl(final Logger inner)", "testcase": false, "constructor": true}, {"identifier": "getName", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getName()", "full_signature": "public String getName()", "class_method_signature": "StructuredLoggerImpl.getName()", "testcase": false, "constructor": false}, {"identifier": "error", "parameters": "(final Supplier<SchemaAndValue> msgSupplier)", "modifiers": "public", "return": "void", "signature": "void error(final Supplier<SchemaAndValue> msgSupplier)", "full_signature": "public void error(final Supplier<SchemaAndValue> msgSupplier)", "class_method_signature": "StructuredLoggerImpl.error(final Supplier<SchemaAndValue> msgSupplier)", "testcase": false, "constructor": false}, {"identifier": "error", "parameters": "(final SchemaAndValue msg)", "modifiers": "public", "return": "void", "signature": "void error(final SchemaAndValue msg)", "full_signature": "public void error(final SchemaAndValue msg)", "class_method_signature": "StructuredLoggerImpl.error(final SchemaAndValue msg)", "testcase": false, "constructor": false}, {"identifier": "info", "parameters": "(final Supplier<SchemaAndValue> msgSupplier)", "modifiers": "public", "return": "void", "signature": "void info(final Supplier<SchemaAndValue> msgSupplier)", "full_signature": "public void info(final Supplier<SchemaAndValue> msgSupplier)", "class_method_signature": "StructuredLoggerImpl.info(final Supplier<SchemaAndValue> msgSupplier)", "testcase": false, "constructor": false}, {"identifier": "info", "parameters": "(final SchemaAndValue msg)", "modifiers": "public", "return": "void", "signature": "void info(final SchemaAndValue msg)", "full_signature": "public void info(final SchemaAndValue msg)", "class_method_signature": "StructuredLoggerImpl.info(final SchemaAndValue msg)", "testcase": false, "constructor": false}, {"identifier": "debug", "parameters": "(final Supplier<SchemaAndValue> msgSupplier)", "modifiers": "public", "return": "void", "signature": "void debug(final Supplier<SchemaAndValue> msgSupplier)", "full_signature": "public void debug(final Supplier<SchemaAndValue> msgSupplier)", "class_method_signature": "StructuredLoggerImpl.debug(final Supplier<SchemaAndValue> msgSupplier)", "testcase": false, "constructor": false}, {"identifier": "debug", "parameters": "(final SchemaAndValue msg)", "modifiers": "public", "return": "void", "signature": "void debug(final SchemaAndValue msg)", "full_signature": "public void debug(final SchemaAndValue msg)", "class_method_signature": "StructuredLoggerImpl.debug(final SchemaAndValue msg)", "testcase": false, "constructor": false}], "file": "logging/src/main/java/io/confluent/common/logging/StructuredLoggerImpl.java"}, "focal_method": {"identifier": "info", "parameters": "(final Supplier<SchemaAndValue> msgSupplier)", "modifiers": "public", "return": "void", "body": "public void info(final Supplier<SchemaAndValue> msgSupplier) {\n    if (!inner.isInfoEnabled()) {\n      return;\n    }\n    info(msgSupplier.get());\n  }", "signature": "void info(final Supplier<SchemaAndValue> msgSupplier)", "full_signature": "public void info(final Supplier<SchemaAndValue> msgSupplier)", "class_method_signature": "StructuredLoggerImpl.info(final Supplier<SchemaAndValue> msgSupplier)", "testcase": false, "constructor": false, "invocations": ["isInfoEnabled", "info", "get"]}, "repository": {"repo_id": 28214426, "url": "https://github.com/confluentinc/common", "stars": 46, "created": "12/19/2014 4:38:00 AM +00:00", "updates": "2020-01-22T00:50:00+00:00", "fork": "False", "license": "licensed"}}