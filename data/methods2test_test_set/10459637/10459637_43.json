{"test_class": {"identifier": "SingletonTaskTest", "superclass": "extends FloodlightTestCase", "interfaces": "", "fields": [{"original_string": "public int ran = 0;", "modifier": "public", "type": "int", "declarator": "ran = 0", "var_name": "ran"}, {"original_string": "public int finished = 0;", "modifier": "public", "type": "int", "declarator": "finished = 0", "var_name": "finished"}, {"original_string": "public long time = 0;", "modifier": "public", "type": "long", "declarator": "time = 0", "var_name": "time"}], "file": "network-level/fl-ho-nl/src/test/java/net/floodlightcontroller/core/util/SingletonTaskTest.java"}, "test_case": {"identifier": "testConcurrentAddDelay", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testConcurrentAddDelay() throws InterruptedException {\n        ScheduledExecutorService ses = \n            Executors.newSingleThreadScheduledExecutor();\n\n        final Object tc = this;\n        SingletonTask st1 = new SingletonTask(ses, new Runnable() {\n            @Override\n            public void run() {\n                synchronized (tc) {\n                    ran += 1;\n                }\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                synchronized (tc) {\n                    finished += 1;\n                    time = System.nanoTime();\n                }\n            }\n        });\n        \n        long start = System.nanoTime();\n        st1.reschedule(5, TimeUnit.MILLISECONDS);\n        Thread.sleep(20);\n        assertEquals(\"Check that task started\", 1, ran);\n        assertEquals(\"Check that task not finished\", 0, finished);\n        st1.reschedule(75, TimeUnit.MILLISECONDS);\n        assertTrue(\"Check task running state true\", st1.context.taskRunning);\n        assertTrue(\"Check task should run state true\", st1.context.taskShouldRun);\n        assertEquals(\"Check that task started\", 1, ran);\n        assertEquals(\"Check that task not finished\", 0, finished);\n\n        Thread.sleep(150);\n\n        assertTrue(\"Check task running state false\", !st1.context.taskRunning);\n        assertTrue(\"Check task should run state false\", !st1.context.taskShouldRun);\n        assertEquals(\"Check that task ran exactly twice\", 2, ran);\n        assertEquals(\"Check that task finished exactly twice\", 2, finished);\n        \n        assertTrue(\"Check that time passed appropriately: \" + (time - start),\n                (time - start) >= TimeUnit.NANOSECONDS.convert(130, TimeUnit.MILLISECONDS));\n        assertTrue(\"Check that time passed appropriately: \" + (time - start),\n                (time - start) <= TimeUnit.NANOSECONDS.convert(160, TimeUnit.MILLISECONDS));\n        \n        ses.shutdown();\n        ses.awaitTermination(5, TimeUnit.SECONDS);\n    }", "signature": "void testConcurrentAddDelay()", "full_signature": "@Test public void testConcurrentAddDelay()", "class_method_signature": "SingletonTaskTest.testConcurrentAddDelay()", "testcase": true, "constructor": false, "invocations": ["newSingleThreadScheduledExecutor", "sleep", "printStackTrace", "nanoTime", "nanoTime", "reschedule", "sleep", "assertEquals", "assertEquals", "reschedule", "assertTrue", "assertTrue", "assertEquals", "assertEquals", "sleep", "assertTrue", "assertTrue", "assertEquals", "assertEquals", "assertTrue", "convert", "assertTrue", "convert", "shutdown", "awaitTermination"]}, "focal_class": {"identifier": "SingletonTask", "superclass": "", "interfaces": "", "fields": [{"original_string": "protected static Logger logger = LoggerFactory.getLogger(SingletonTask.class);", "modifier": "protected static", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(SingletonTask.class)", "var_name": "logger"}, {"original_string": "protected SingletonTaskContext context = new SingletonTaskContext();", "modifier": "protected", "type": "SingletonTaskContext", "declarator": "context = new SingletonTaskContext()", "var_name": "context"}, {"original_string": "protected Runnable task;", "modifier": "protected", "type": "Runnable", "declarator": "task", "var_name": "task"}, {"original_string": "protected ScheduledExecutorService ses;", "modifier": "protected", "type": "ScheduledExecutorService", "declarator": "ses", "var_name": "ses"}], "methods": [{"identifier": "SingletonTask", "parameters": "(ScheduledExecutorService ses,\n            Runnable task)", "modifiers": "public", "return": "", "signature": " SingletonTask(ScheduledExecutorService ses,\n            Runnable task)", "full_signature": "public  SingletonTask(ScheduledExecutorService ses,\n            Runnable task)", "class_method_signature": "SingletonTask.SingletonTask(ScheduledExecutorService ses,\n            Runnable task)", "testcase": false, "constructor": true}, {"identifier": "reschedule", "parameters": "(long delay, TimeUnit unit)", "modifiers": "public", "return": "void", "signature": "void reschedule(long delay, TimeUnit unit)", "full_signature": "public void reschedule(long delay, TimeUnit unit)", "class_method_signature": "SingletonTask.reschedule(long delay, TimeUnit unit)", "testcase": false, "constructor": false}], "file": "network-level/fl-ho-nl/src/main/java/net/floodlightcontroller/core/util/SingletonTask.java"}, "focal_method": {"identifier": "reschedule", "parameters": "(long delay, TimeUnit unit)", "modifiers": "public", "return": "void", "body": "public void reschedule(long delay, TimeUnit unit) {\n        boolean needQueue = true;\n        SingletonTaskWorker stw = null;\n\n        synchronized (context) {\n            if (context.taskRunning || context.taskShouldRun) {\n                if (context.taskRunning) {\n                    // schedule to restart at the right time\n                    if (delay > 0) {\n                        long now = System.nanoTime();\n                        long then = \n                            now + TimeUnit.NANOSECONDS.convert(delay, unit);\n                        context.waitingTask.nextschedule = then;\n                    } else {\n                        context.waitingTask.nextschedule = 0;\n                    }\n                    needQueue = false;\n                } else {\n                    // cancel and requeue\n                    context.waitingTask.canceled = true;\n                    context.waitingTask = null;\n                }\n            }\n\n            context.taskShouldRun = true;\n\n            if (needQueue) {\n                stw = context.waitingTask = new SingletonTaskWorker(this);                    \n            }\n        }\n\n        if (needQueue) {\n            if (delay <= 0)\n                ses.execute(stw);\n            else\n                ses.schedule(stw, delay, unit);\n        }\n    }", "signature": "void reschedule(long delay, TimeUnit unit)", "full_signature": "public void reschedule(long delay, TimeUnit unit)", "class_method_signature": "SingletonTask.reschedule(long delay, TimeUnit unit)", "testcase": false, "constructor": false, "invocations": ["nanoTime", "convert", "execute", "schedule"]}, "repository": {"repo_id": 10459637, "url": "https://github.com/rizard/geni-openflow-vertical-handover", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 7, "size": 33971, "license": "licensed"}}