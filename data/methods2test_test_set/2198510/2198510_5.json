{"test_class": {"identifier": "TestCheckpointRebuilder", "superclass": "extends TestFileChannelBase", "interfaces": "", "fields": [{"original_string": "protected static final Logger LOG = LoggerFactory\n      .getLogger(TestCheckpointRebuilder.class);", "modifier": "protected static final", "type": "Logger", "declarator": "LOG = LoggerFactory\n      .getLogger(TestCheckpointRebuilder.class)", "var_name": "LOG"}], "file": "flume-ng-channels/flume-file-channel/src/test/java/org/apache/flume/channel/file/TestCheckpointRebuilder.java"}, "test_case": {"identifier": "testFastReplay", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testFastReplay() throws Exception {\n    Map<String, String> overrides = Maps.newHashMap();\n    overrides.put(FileChannelConfiguration.CAPACITY,\n        String.valueOf(50));\n    overrides.put(FileChannelConfiguration.TRANSACTION_CAPACITY,\n        String.valueOf(50));\n    channel = createFileChannel(overrides);\n    channel.start();\n    Assert.assertTrue(channel.isOpen());\n    Set<String> in = fillChannel(channel, \"checkpointBulder\");\n    channel.stop();\n    File checkpointFile = new File(checkpointDir, \"checkpoint\");\n    File metaDataFile = Serialization.getMetaDataFile(checkpointFile);\n    File inflightTakesFile = new File(checkpointDir, \"inflighttakes\");\n    File inflightPutsFile = new File(checkpointDir, \"inflightputs\");\n    File queueSetDir = new File(checkpointDir, \"queueset\");\n    Assert.assertTrue(checkpointFile.delete());\n    Assert.assertTrue(metaDataFile.delete());\n    Assert.assertTrue(inflightTakesFile.delete());\n    Assert.assertTrue(inflightPutsFile.delete());\n    EventQueueBackingStore backingStore =\n        EventQueueBackingStoreFactory.get(checkpointFile, 50,\n            \"test\", new FileChannelCounter(\"test\"));\n    FlumeEventQueue queue = new FlumeEventQueue(backingStore, inflightTakesFile,\n          inflightPutsFile, queueSetDir);\n    CheckpointRebuilder checkpointRebuilder =\n        new CheckpointRebuilder(getAllLogs(dataDirs), queue, true);\n    Assert.assertTrue(checkpointRebuilder.rebuild());\n    channel = createFileChannel(overrides);\n    channel.start();\n    Assert.assertTrue(channel.isOpen());\n    Set<String> out = consumeChannel(channel);\n    compareInputAndOut(in, out);\n  }", "signature": "void testFastReplay()", "full_signature": "@Test public void testFastReplay()", "class_method_signature": "TestCheckpointRebuilder.testFastReplay()", "testcase": true, "constructor": false, "invocations": ["newHashMap", "put", "valueOf", "put", "valueOf", "createFileChannel", "start", "assertTrue", "isOpen", "fillChannel", "stop", "getMetaDataFile", "assertTrue", "delete", "assertTrue", "delete", "assertTrue", "delete", "assertTrue", "delete", "get", "getAllLogs", "assertTrue", "rebuild", "createFileChannel", "start", "assertTrue", "isOpen", "consumeChannel", "compareInputAndOut"]}, "focal_class": {"identifier": "CheckpointRebuilder", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final List<File> logFiles;", "modifier": "private final", "type": "List<File>", "declarator": "logFiles", "var_name": "logFiles"}, {"original_string": "private final FlumeEventQueue queue;", "modifier": "private final", "type": "FlumeEventQueue", "declarator": "queue", "var_name": "queue"}, {"original_string": "private final Set<ComparableFlumeEventPointer> committedPuts = Sets.newHashSet();", "modifier": "private final", "type": "Set<ComparableFlumeEventPointer>", "declarator": "committedPuts = Sets.newHashSet()", "var_name": "committedPuts"}, {"original_string": "private final Set<ComparableFlumeEventPointer> pendingTakes = Sets.newHashSet();", "modifier": "private final", "type": "Set<ComparableFlumeEventPointer>", "declarator": "pendingTakes = Sets.newHashSet()", "var_name": "pendingTakes"}, {"original_string": "private final SetMultimap<Long, ComparableFlumeEventPointer> uncommittedPuts =\n      HashMultimap.create();", "modifier": "private final", "type": "SetMultimap<Long, ComparableFlumeEventPointer>", "declarator": "uncommittedPuts =\n      HashMultimap.create()", "var_name": "uncommittedPuts"}, {"original_string": "private final SetMultimap<Long, ComparableFlumeEventPointer>\n      uncommittedTakes = HashMultimap.create();", "modifier": "private final", "type": "SetMultimap<Long, ComparableFlumeEventPointer>", "declarator": "uncommittedTakes = HashMultimap.create()", "var_name": "uncommittedTakes"}, {"original_string": "private final boolean fsyncPerTransaction;", "modifier": "private final", "type": "boolean", "declarator": "fsyncPerTransaction", "var_name": "fsyncPerTransaction"}, {"original_string": "private static Logger LOG = LoggerFactory.getLogger(CheckpointRebuilder.class);", "modifier": "private static", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(CheckpointRebuilder.class)", "var_name": "LOG"}], "methods": [{"identifier": "CheckpointRebuilder", "parameters": "(List<File> logFiles, FlumeEventQueue queue,\n                             boolean fsyncPerTransaction)", "modifiers": "public", "return": "", "signature": " CheckpointRebuilder(List<File> logFiles, FlumeEventQueue queue,\n                             boolean fsyncPerTransaction)", "full_signature": "public  CheckpointRebuilder(List<File> logFiles, FlumeEventQueue queue,\n                             boolean fsyncPerTransaction)", "class_method_signature": "CheckpointRebuilder.CheckpointRebuilder(List<File> logFiles, FlumeEventQueue queue,\n                             boolean fsyncPerTransaction)", "testcase": false, "constructor": true}, {"identifier": "rebuild", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean rebuild()", "full_signature": "public boolean rebuild()", "class_method_signature": "CheckpointRebuilder.rebuild()", "testcase": false, "constructor": false}, {"identifier": "writeCheckpoint", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void writeCheckpoint()", "full_signature": "private void writeCheckpoint()", "class_method_signature": "CheckpointRebuilder.writeCheckpoint()", "testcase": false, "constructor": false}, {"identifier": "main", "parameters": "(String[] args)", "modifiers": "public static", "return": "void", "signature": "void main(String[] args)", "full_signature": "public static void main(String[] args)", "class_method_signature": "CheckpointRebuilder.main(String[] args)", "testcase": false, "constructor": false}], "file": "flume-ng-channels/flume-file-channel/src/main/java/org/apache/flume/channel/file/CheckpointRebuilder.java"}, "focal_method": {"identifier": "rebuild", "parameters": "()", "modifiers": "public", "return": "boolean", "body": "public boolean rebuild() throws IOException, Exception {\n    LOG.info(\"Attempting to fast replay the log files.\");\n    List<LogFile.SequentialReader> logReaders = Lists.newArrayList();\n    for (File logFile : logFiles) {\n      try {\n        logReaders.add(LogFileFactory.getSequentialReader(logFile, null,\n            fsyncPerTransaction));\n      } catch (EOFException e) {\n        LOG.warn(\"Ignoring \" + logFile + \" due to EOF\", e);\n      }\n    }\n    long transactionIDSeed = 0;\n    long writeOrderIDSeed = 0;\n    try {\n      for (LogFile.SequentialReader log : logReaders) {\n        LogRecord entry;\n        int fileID = log.getLogFileID();\n        while ((entry = log.next()) != null) {\n          int offset = entry.getOffset();\n          TransactionEventRecord record = entry.getEvent();\n          long trans = record.getTransactionID();\n          long writeOrderID = record.getLogWriteOrderID();\n          transactionIDSeed = Math.max(trans, transactionIDSeed);\n          writeOrderIDSeed = Math.max(writeOrderID, writeOrderIDSeed);\n          if (record.getRecordType() == TransactionEventRecord.Type.PUT.get()) {\n            uncommittedPuts.put(record.getTransactionID(),\n                new ComparableFlumeEventPointer(\n                    new FlumeEventPointer(fileID, offset),\n                    record.getLogWriteOrderID()));\n          } else if (record.getRecordType() == TransactionEventRecord.Type.TAKE.get()) {\n            Take take = (Take) record;\n            uncommittedTakes.put(record.getTransactionID(),\n                new ComparableFlumeEventPointer(\n                    new FlumeEventPointer(take.getFileID(), take.getOffset()),\n                    record.getLogWriteOrderID()));\n          } else if (record.getRecordType() == TransactionEventRecord.Type.COMMIT.get()) {\n            Commit commit = (Commit) record;\n            if (commit.getType() == TransactionEventRecord.Type.PUT.get()) {\n              Set<ComparableFlumeEventPointer> puts =\n                  uncommittedPuts.get(record.getTransactionID());\n              if (puts != null) {\n                for (ComparableFlumeEventPointer put : puts) {\n                  if (!pendingTakes.remove(put)) {\n                    committedPuts.add(put);\n                  }\n                }\n              }\n            } else {\n              Set<ComparableFlumeEventPointer> takes =\n                  uncommittedTakes.get(record.getTransactionID());\n              if (takes != null) {\n                for (ComparableFlumeEventPointer take : takes) {\n                  if (!committedPuts.remove(take)) {\n                    pendingTakes.add(take);\n                  }\n                }\n              }\n            }\n          } else if (record.getRecordType() == TransactionEventRecord.Type.ROLLBACK.get()) {\n            if (uncommittedPuts.containsKey(record.getTransactionID())) {\n              uncommittedPuts.removeAll(record.getTransactionID());\n            } else {\n              uncommittedTakes.removeAll(record.getTransactionID());\n            }\n          }\n        }\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Error while generating checkpoint using fast generation logic\", e);\n      return false;\n    } finally {\n      TransactionIDOracle.setSeed(transactionIDSeed);\n      WriteOrderOracle.setSeed(writeOrderIDSeed);\n      for (LogFile.SequentialReader reader : logReaders) {\n        reader.close();\n      }\n    }\n    Set<ComparableFlumeEventPointer> sortedPuts = Sets.newTreeSet(committedPuts);\n    int count = 0;\n    for (ComparableFlumeEventPointer put : sortedPuts) {\n      queue.addTail(put.pointer);\n      count++;\n    }\n    LOG.info(\"Replayed {} events using fast replay logic.\", count);\n    return true;\n  }", "signature": "boolean rebuild()", "full_signature": "public boolean rebuild()", "class_method_signature": "CheckpointRebuilder.rebuild()", "testcase": false, "constructor": false, "invocations": ["info", "newArrayList", "add", "getSequentialReader", "warn", "getLogFileID", "next", "getOffset", "getEvent", "getTransactionID", "getLogWriteOrderID", "max", "max", "getRecordType", "get", "put", "getTransactionID", "getLogWriteOrderID", "getRecordType", "get", "put", "getTransactionID", "getFileID", "getOffset", "getLogWriteOrderID", "getRecordType", "get", "getType", "get", "get", "getTransactionID", "remove", "add", "get", "getTransactionID", "remove", "add", "getRecordType", "get", "containsKey", "getTransactionID", "removeAll", "getTransactionID", "removeAll", "getTransactionID", "warn", "setSeed", "setSeed", "close", "newTreeSet", "addTail", "info"]}, "repository": {"repo_id": 2198510, "url": "https://github.com/apache/flume", "language": "Java", "is_fork": false, "fork_count": 1372, "stargazer_count": 1971, "size": 44377, "license": "licensed"}}