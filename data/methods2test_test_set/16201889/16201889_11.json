{"test_class": {"identifier": "ParsingJobTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "final static ParsingJob JOB = new ParsingJob(\"Abies\", Rank.UNRANKED, null, new ParserConfigs());", "modifier": "final static", "type": "ParsingJob", "declarator": "JOB = new ParsingJob(\"Abies\", Rank.UNRANKED, null, new ParserConfigs())", "var_name": "JOB"}, {"original_string": "static final Pattern AUTHOR_PATTERN = Pattern.compile(\"^\" + ParsingJob.AUTHOR + \"$\");", "modifier": "static final", "type": "Pattern", "declarator": "AUTHOR_PATTERN = Pattern.compile(\"^\" + ParsingJob.AUTHOR + \"$\")", "var_name": "AUTHOR_PATTERN"}, {"original_string": "static final Pattern AUTHORSHIP_PATTERN = Pattern.compile(\"^\" + ParsingJob.AUTHORSHIP + \"$\");", "modifier": "static final", "type": "Pattern", "declarator": "AUTHORSHIP_PATTERN = Pattern.compile(\"^\" + ParsingJob.AUTHORSHIP + \"$\")", "var_name": "AUTHORSHIP_PATTERN"}], "file": "name-parser/src/test/java/org/gbif/nameparser/ParsingJobTest.java"}, "test_case": {"identifier": "testClean1", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testClean1() throws Exception {\n    assertEquals(\"\", JOB.preClean(\"\"));\n    assertEquals(\"Hallo Spencer\", JOB.preClean(\"Hallo Spencer \"));\n    assertEquals(\"Hallo Spencer\", JOB.preClean(\"' 'Hallo Spencer\"));\n    assertEquals(\"Hallo Spencer 1982\", JOB.preClean(\"'\\\" Hallo  Spencer 1982'\"));\n  }", "signature": "void testClean1()", "full_signature": "@Test public void testClean1()", "class_method_signature": "ParsingJobTest.testClean1()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "preClean", "assertEquals", "preClean", "assertEquals", "preClean", "assertEquals", "preClean"]}, "focal_class": {"identifier": "ParsingJob", "superclass": "", "interfaces": "implements Callable<ParsedName>", "fields": [{"original_string": "static Logger LOG = LoggerFactory.getLogger(ParsingJob.class);", "modifier": "static", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(ParsingJob.class)", "var_name": "LOG"}, {"original_string": "private static final Map<Rank, Rank> DIVISION2PHYLUM = ImmutableMap.of(\n      Rank.SUPERDIVISION, Rank.SUPERPHYLUM,\n      Rank.DIVISION, Rank.PHYLUM,\n      Rank.SUBDIVISION, Rank.SUBPHYLUM,\n      Rank.INFRADIVISION, Rank.INFRAPHYLUM\n  );", "modifier": "private static final", "type": "Map<Rank, Rank>", "declarator": "DIVISION2PHYLUM = ImmutableMap.of(\n      Rank.SUPERDIVISION, Rank.SUPERPHYLUM,\n      Rank.DIVISION, Rank.PHYLUM,\n      Rank.SUBDIVISION, Rank.SUBPHYLUM,\n      Rank.INFRADIVISION, Rank.INFRAPHYLUM\n  )", "var_name": "DIVISION2PHYLUM"}, {"original_string": "private static final Splitter WHITESPACE_SPLITTER = Splitter.on(\" \").trimResults().omitEmptyStrings();", "modifier": "private static final", "type": "Splitter", "declarator": "WHITESPACE_SPLITTER = Splitter.on(\" \").trimResults().omitEmptyStrings()", "var_name": "WHITESPACE_SPLITTER"}, {"original_string": "private static final CharMatcher AUTHORTEAM_DELIMITER = CharMatcher.anyOf(\",&\");", "modifier": "private static final", "type": "CharMatcher", "declarator": "AUTHORTEAM_DELIMITER = CharMatcher.anyOf(\",&\")", "var_name": "AUTHORTEAM_DELIMITER"}, {"original_string": "private static final Splitter AUTHORTEAM_SPLITTER = Splitter.on(AUTHORTEAM_DELIMITER).trimResults().omitEmptyStrings();", "modifier": "private static final", "type": "Splitter", "declarator": "AUTHORTEAM_SPLITTER = Splitter.on(AUTHORTEAM_DELIMITER).trimResults().omitEmptyStrings()", "var_name": "AUTHORTEAM_SPLITTER"}, {"original_string": "private static final Splitter AUTHORTEAM_SEMI_SPLITTER = Splitter.on(\";\").trimResults().omitEmptyStrings();", "modifier": "private static final", "type": "Splitter", "declarator": "AUTHORTEAM_SEMI_SPLITTER = Splitter.on(\";\").trimResults().omitEmptyStrings()", "var_name": "AUTHORTEAM_SEMI_SPLITTER"}, {"original_string": "private static final Pattern AUTHOR_INITIAL_SWAP = Pattern.compile(\"^([^,]+) *, *([^,]+)$\");", "modifier": "private static final", "type": "Pattern", "declarator": "AUTHOR_INITIAL_SWAP = Pattern.compile(\"^([^,]+) *, *([^,]+)$\")", "var_name": "AUTHOR_INITIAL_SWAP"}, {"original_string": "private static final Pattern NORM_EX_HORT = Pattern.compile(\"\\\\b(?:hort(?:usa?)?|cv)[. ]ex \", CASE_INSENSITIVE);", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_EX_HORT = Pattern.compile(\"\\\\b(?:hort(?:usa?)?|cv)[. ]ex \", CASE_INSENSITIVE)", "var_name": "NORM_EX_HORT"}, {"original_string": "private static final String SPACE_AUTHOR = \"\\\\p{Lu}\\\\p{Ll}+ \\\\p{Lu}+\";", "modifier": "private static final", "type": "String", "declarator": "SPACE_AUTHOR = \"\\\\p{Lu}\\\\p{Ll}+ \\\\p{Lu}+\"", "var_name": "SPACE_AUTHOR"}, {"original_string": "private static final Pattern SPACE_AUTHORTEAM = Pattern.compile(\"^\" + SPACE_AUTHOR +\"(?: \" + SPACE_AUTHOR + \")*$\");", "modifier": "private static final", "type": "Pattern", "declarator": "SPACE_AUTHORTEAM = Pattern.compile(\"^\" + SPACE_AUTHOR +\"(?: \" + SPACE_AUTHOR + \")*$\")", "var_name": "SPACE_AUTHORTEAM"}, {"original_string": "private static final Pattern INITIALS = Pattern.compile(\"^\\\\p{Lu}{1,2}(?:[. ]\\\\p{Lu}{1,2}){0,2}\\\\.?$\");", "modifier": "private static final", "type": "Pattern", "declarator": "INITIALS = Pattern.compile(\"^\\\\p{Lu}{1,2}(?:[. ]\\\\p{Lu}{1,2}){0,2}\\\\.?$\")", "var_name": "INITIALS"}, {"original_string": "static final String NAME_LETTERS = \"A-Z\u00cf\u00cb\u00d6\u00dc\u00c4\u00c9\u00c8\u010c\u00c1\u00c0\u00c6\u0152\";", "modifier": "static final", "type": "String", "declarator": "NAME_LETTERS = \"A-Z\u00cf\u00cb\u00d6\u00dc\u00c4\u00c9\u00c8\u010c\u00c1\u00c0\u00c6\u0152\";", "var_name": "NAME_LETTERS"}, {"original_string": "static final String name_letters = \"a-z\u00ef\u00eb\u00f6\u00fc\u00e4\u00e5\u00e9\u00e8\u010d\u00e1\u00e0\u00e6\u0153\";", "modifier": "static final", "type": "String", "declarator": "name_letters = \"a-z\u00ef\u00eb\u00f6\u00fc\u00e4\u00e5\u00e9\u00e8\u010d\u00e1\u00e0\u00e6\u0153\";", "var_name": "name_letters"}, {"original_string": "static final String AUTHOR_LETTERS = NAME_LETTERS + \"\\\\p{Lu}\";", "modifier": "static final", "type": "String", "declarator": "AUTHOR_LETTERS = NAME_LETTERS + \"\\\\p{Lu}\"", "var_name": "AUTHOR_LETTERS"}, {"original_string": "static final String author_letters = name_letters + \"\\\\p{Ll}-?\";", "modifier": "static final", "type": "String", "declarator": "author_letters = name_letters + \"\\\\p{Ll}-?\"", "var_name": "author_letters"}, {"original_string": "private static final String AUTHOR_TOKEN_3 = \"fil|filius|hort|jun|junior|sen|senior\";", "modifier": "private static final", "type": "String", "declarator": "AUTHOR_TOKEN_3 = \"fil|filius|hort|jun|junior|sen|senior\"", "var_name": "AUTHOR_TOKEN_3"}, {"original_string": "private static final String AUTHOR_TOKEN = \"(?:\" +\n      \"(?<=\\\\bden )heede\" +\n      \"|(?:\\\\p{Lu}|-[a-z])[\\\\p{Lu}\\\\p{Ll}'-]*\" +\n      \"|\" + AUTHOR_TOKEN_3 +\n      \"|al|f|j|jr|ms|sr|v|v[ao]n|zu[rm]?|bis|d[aeiou]?|de[nrmls]?|degli|e|l[ae]s?|s|ter|'?t|y\" +\n    \")\\\\.?\";", "modifier": "private static final", "type": "String", "declarator": "AUTHOR_TOKEN = \"(?:\" +\n      \"(?<=\\\\bden )heede\" +\n      \"|(?:\\\\p{Lu}|-[a-z])[\\\\p{Lu}\\\\p{Ll}'-]*\" +\n      \"|\" + AUTHOR_TOKEN_3 +\n      \"|al|f|j|jr|ms|sr|v|v[ao]n|zu[rm]?|bis|d[aeiou]?|de[nrmls]?|degli|e|l[ae]s?|s|ter|'?t|y\" +\n    \")\\\\.?\"", "var_name": "AUTHOR_TOKEN"}, {"original_string": "@VisibleForTesting\n  static final String AUTHOR = AUTHOR_TOKEN + \"(?:[ '-]?\" + AUTHOR_TOKEN + \")*\";", "modifier": "@VisibleForTesting\n  static final", "type": "String", "declarator": "AUTHOR = AUTHOR_TOKEN + \"(?:[ '-]?\" + AUTHOR_TOKEN + \")*\"", "var_name": "AUTHOR"}, {"original_string": "static final String AUTHOR_SUFFIX = \"(?:bis|ter|d(?:[ae][rnl]?|egli))\";", "modifier": "static final", "type": "String", "declarator": "AUTHOR_SUFFIX = \"(?:bis|ter|d(?:[ae][rnl]?|egli))\"", "var_name": "AUTHOR_SUFFIX"}, {"original_string": "private static final Pattern AUTHOR_SUFFIX_P = Pattern.compile(\"^\" + AUTHOR_SUFFIX + \"$\");", "modifier": "private static final", "type": "Pattern", "declarator": "AUTHOR_SUFFIX_P = Pattern.compile(\"^\" + AUTHOR_SUFFIX + \"$\")", "var_name": "AUTHOR_SUFFIX_P"}, {"original_string": "private static final String AUTHOR_TEAM = AUTHOR + \"(?:[&,;]+\" + AUTHOR + \")*\";", "modifier": "private static final", "type": "String", "declarator": "AUTHOR_TEAM = AUTHOR + \"(?:[&,;]+\" + AUTHOR + \")*\"", "var_name": "AUTHOR_TEAM"}, {"original_string": "static final String AUTHORSHIP =\n      // ex authors\n      \"(?:(\" + AUTHOR_TEAM + \") ?\\\\bex[. ])?\" +\n      // main authors\n      \"(\" + AUTHOR_TEAM + \")\" +\n      // 2 well known sanction authors for fungus, see POR-2454\n      \"(?: *: *(Pers\\\\.?|Fr\\\\.?))?\";", "modifier": "static final", "type": "String", "declarator": "AUTHORSHIP =\n      // ex authors\n      \"(?:(\" + AUTHOR_TEAM + \") ?\\\\bex[. ])?\" +\n      // main authors\n      \"(\" + AUTHOR_TEAM + \")\" +\n      // 2 well known sanction authors for fungus, see POR-2454\n      \"(?: *: *(Pers\\\\.?|Fr\\\\.?))?\"", "var_name": "AUTHORSHIP"}, {"original_string": "static final Pattern AUTHOR_TEAM_PATTERN = Pattern.compile(\"^\" + AUTHOR_TEAM + \"$\");", "modifier": "static final", "type": "Pattern", "declarator": "AUTHOR_TEAM_PATTERN = Pattern.compile(\"^\" + AUTHOR_TEAM + \"$\")", "var_name": "AUTHOR_TEAM_PATTERN"}, {"original_string": "private static final String YEAR = \"[12][0-9][0-9][0-9?]\";", "modifier": "private static final", "type": "String", "declarator": "YEAR = \"[12][0-9][0-9][0-9?]\"", "var_name": "YEAR"}, {"original_string": "static final String YEAR_LOOSE = YEAR + \"[abcdh?]?(?:[/,-][0-9]{1,4})?\";", "modifier": "static final", "type": "String", "declarator": "YEAR_LOOSE = YEAR + \"[abcdh?]?(?:[/,-][0-9]{1,4})?\"", "var_name": "YEAR_LOOSE"}, {"original_string": "private static final String NOTHO = \"notho\";", "modifier": "private static final", "type": "String", "declarator": "NOTHO = \"notho\"", "var_name": "NOTHO"}, {"original_string": "static final String RANK_MARKER = (\"(?:\"+NOTHO+\")?(?:(?<!f[ .])sp|\" +\n        StringUtils.join(RankUtils.RANK_MARKER_MAP_INFRASPECIFIC.keySet(), \"|\") +\n    \")\")\n    // avoid hort.ex matches\n    .replace(\"|hort|\", \"|hort(?!\\\\.ex)|\");", "modifier": "static final", "type": "String", "declarator": "RANK_MARKER = (\"(?:\"+NOTHO+\")?(?:(?<!f[ .])sp|\" +\n        StringUtils.join(RankUtils.RANK_MARKER_MAP_INFRASPECIFIC.keySet(), \"|\") +\n    \")\")\n    // avoid hort.ex matches\n    .replace(\"|hort|\", \"|hort(?!\\\\.ex)|\")", "var_name": "RANK_MARKER"}, {"original_string": "static final String RANK_MARKER_MICROBIAL =\n    \"(?:bv\\\\.|ct\\\\.|f\\\\.sp\\\\.|\" +\n        StringUtils.join(Lists.transform(Lists.newArrayList(RankUtils.INFRASUBSPECIFIC_MICROBIAL_RANKS), new Function<Rank, String>() {\n              @Nullable\n              @Override\n              public String apply(@Nullable Rank r) {\n                return r.getMarker().replaceAll(\"\\\\.\", \"\\\\\\\\.\");\n              }\n            }\n        ), \"|\") +\n    \")\";", "modifier": "static final", "type": "String", "declarator": "RANK_MARKER_MICROBIAL =\n    \"(?:bv\\\\.|ct\\\\.|f\\\\.sp\\\\.|\" +\n        StringUtils.join(Lists.transform(Lists.newArrayList(RankUtils.INFRASUBSPECIFIC_MICROBIAL_RANKS), new Function<Rank, String>() {\n              @Nullable\n              @Override\n              public String apply(@Nullable Rank r) {\n                return r.getMarker().replaceAll(\"\\\\.\", \"\\\\\\\\.\");\n              }\n            }\n        ), \"|\") +\n    \")\"", "var_name": "RANK_MARKER_MICROBIAL"}, {"original_string": "private static final String UNALLOWED_EPITHETS = \"aff|and|cf|from|ms|of|the|where\";", "modifier": "private static final", "type": "String", "declarator": "UNALLOWED_EPITHETS = \"aff|and|cf|from|ms|of|the|where\"", "var_name": "UNALLOWED_EPITHETS"}, {"original_string": "private static final String UNALLOWED_EPITHET_ENDING =\n      \"bacilliform|coliform|coryneform|cytoform|chemoform|biovar|serovar|genomovar|agamovar|cultivar|genotype|serotype|subtype|ribotype|isolate\";", "modifier": "private static final", "type": "String", "declarator": "UNALLOWED_EPITHET_ENDING =\n      \"bacilliform|coliform|coryneform|cytoform|chemoform|biovar|serovar|genomovar|agamovar|cultivar|genotype|serotype|subtype|ribotype|isolate\"", "var_name": "UNALLOWED_EPITHET_ENDING"}, {"original_string": "static final String EPI_QUALIFIER = \"(?:\\\\b(aff|cf|nr)[?. ])?\";", "modifier": "static final", "type": "String", "declarator": "EPI_QUALIFIER = \"(?:\\\\b(aff|cf|nr)[?. ])?\"", "var_name": "EPI_QUALIFIER"}, {"original_string": "static final String EPITHET = \"(?:[0-9]+-?|[a-z]-|[doml]'|(?:van|novae) [a-z])?\"\n            // avoid matching to rank markers\n            + \"(?!\"+RANK_MARKER+\"\\\\b)\"\n            + \"[\" + name_letters + \"+-]{1,}(?<! d)[\" + name_letters + \"]\"\n            // avoid epithets and those ending with the unallowed endings, e.g. serovar and author suffices like filius\n            + \"(?<!(?:\\\\b(?:ex|l[ae]|v[ao]n|\"+AUTHOR_TOKEN_3+\")\\\\.?|\\\\b(?:\"+UNALLOWED_EPITHETS+\")|\"+ UNALLOWED_EPITHET_ENDING +\"))(?=\\\\b)\";", "modifier": "static final", "type": "String", "declarator": "EPITHET = \"(?:[0-9]+-?|[a-z]-|[doml]'|(?:van|novae) [a-z])?\"\n            // avoid matching to rank markers\n            + \"(?!\"+RANK_MARKER+\"\\\\b)\"\n            + \"[\" + name_letters + \"+-]{1,}(?<! d)[\" + name_letters + \"]\"\n            // avoid epithets and those ending with the unallowed endings, e.g. serovar and author suffices like filius\n            + \"(?<!(?:\\\\b(?:ex|l[ae]|v[ao]n|\"+AUTHOR_TOKEN_3+\")\\\\.?|\\\\b(?:\"+UNALLOWED_EPITHETS+\")|\"+ UNALLOWED_EPITHET_ENDING +\"))(?=\\\\b)\"", "var_name": "EPITHET"}, {"original_string": "static final String MONOMIAL =\n    \"[\" + NAME_LETTERS + \"](?:\\\\.|[\" + name_letters + \"]+)(?:-[\" + NAME_LETTERS + \"]?[\" + name_letters + \"]+)?\";", "modifier": "static final", "type": "String", "declarator": "MONOMIAL =\n    \"[\" + NAME_LETTERS + \"](?:\\\\.|[\" + name_letters + \"]+)(?:-[\" + NAME_LETTERS + \"]?[\" + name_letters + \"]+)?\"", "var_name": "MONOMIAL"}, {"original_string": "private static final Pattern LATIN_ENDINGS;", "modifier": "private static final", "type": "Pattern", "declarator": "LATIN_ENDINGS", "var_name": "LATIN_ENDINGS"}, {"original_string": "private static final String INFRAGENERIC =\n    \"(?:\\\\(([\" + NAME_LETTERS + \"][\" + name_letters + \"-]+)\\\\)\" +\n        \"| ((?:\"+NOTHO+\")?(?:\" +\n          StringUtils.join(RankUtils.RANK_MARKER_MAP_INFRAGENERIC.keySet(), \"|\") +\n        \"))[. ]([\" + NAME_LETTERS + \"][\" + name_letters + \"-]+)\"\n    + \")\";", "modifier": "private static final", "type": "String", "declarator": "INFRAGENERIC =\n    \"(?:\\\\(([\" + NAME_LETTERS + \"][\" + name_letters + \"-]+)\\\\)\" +\n        \"| ((?:\"+NOTHO+\")?(?:\" +\n          StringUtils.join(RankUtils.RANK_MARKER_MAP_INFRAGENERIC.keySet(), \"|\") +\n        \"))[. ]([\" + NAME_LETTERS + \"][\" + name_letters + \"-]+)\"\n    + \")\"", "var_name": "INFRAGENERIC"}, {"original_string": "static final String RANK_MARKER_ALL = \"(\"+NOTHO+\")? *(\" + StringUtils.join(RankUtils.RANK_MARKER_MAP.keySet(), \"|\") + \")\\\\.?\";", "modifier": "static final", "type": "String", "declarator": "RANK_MARKER_ALL = \"(\"+NOTHO+\")? *(\" + StringUtils.join(RankUtils.RANK_MARKER_MAP.keySet(), \"|\") + \")\\\\.?\"", "var_name": "RANK_MARKER_ALL"}, {"original_string": "private static final Pattern RANK_MARKER_ONLY = Pattern.compile(\"^\" + RANK_MARKER_ALL + \"$\");", "modifier": "private static final", "type": "Pattern", "declarator": "RANK_MARKER_ONLY = Pattern.compile(\"^\" + RANK_MARKER_ALL + \"$\")", "var_name": "RANK_MARKER_ONLY"}, {"original_string": "private static char[] QUOTES = new char[4];", "modifier": "private static", "type": "char[]", "declarator": "QUOTES = new char[4]", "var_name": "QUOTES"}, {"original_string": "public static final String HYBRID_MARKER = \"\u00d7\";", "modifier": "public static final", "type": "String", "declarator": "HYBRID_MARKER = \"\u00d7\";", "var_name": "HYBRID_MARKER"}, {"original_string": "public static final Pattern HYBRID_FORMULA_PATTERN = Pattern.compile(\"[. ]\" + HYBRID_MARKER + \" \");", "modifier": "public static final", "type": "Pattern", "declarator": "HYBRID_FORMULA_PATTERN = Pattern.compile(\"[. ]\" + HYBRID_MARKER + \" \")", "var_name": "HYBRID_FORMULA_PATTERN"}, {"original_string": "public static final String EXTINCT_MARKER = \"\u2020\";", "modifier": "public static final", "type": "String", "declarator": "EXTINCT_MARKER = \"\u2020\";", "var_name": "EXTINCT_MARKER"}, {"original_string": "private static final Pattern EXTINCT_PATTERN = Pattern.compile(\"[\u2020\u2021\u271d]+\\\\s*\");", "modifier": "private static final", "type": "Pattern", "declarator": "EXTINCT_PATTERN = Pattern.compile(\"[\u2020\u2021\u271d]+\\\\s*\");", "var_name": "EXTINCT_PATTERN"}, {"original_string": "@VisibleForTesting\n  protected static final Pattern CULTIVAR = Pattern.compile(\"(?:([. ])cv[. ])?[\\\"'] ?((?:[\" + NAME_LETTERS + \"]?[\" + name_letters + \"]+[- ]?){1,3}) ?[\\\"']\");", "modifier": "@VisibleForTesting\n  protected static final", "type": "Pattern", "declarator": "CULTIVAR = Pattern.compile(\"(?:([. ])cv[. ])?[\\\"'] ?((?:[\" + NAME_LETTERS + \"]?[\" + name_letters + \"]+[- ]?){1,3}) ?[\\\"']\")", "var_name": "CULTIVAR"}, {"original_string": "private static final Pattern CULTIVAR_GROUP = Pattern.compile(\"(?<!^)\\\\b[\\\"']?((?:[\" + NAME_LETTERS + \"][\" + name_letters + \"]{2,}[- ]?){1,3})[\\\"']? (Group|Hybrids|Sort|[Gg]rex|gx)\\\\b\");", "modifier": "private static final", "type": "Pattern", "declarator": "CULTIVAR_GROUP = Pattern.compile(\"(?<!^)\\\\b[\\\"']?((?:[\" + NAME_LETTERS + \"][\" + name_letters + \"]{2,}[- ]?){1,3})[\\\"']? (Group|Hybrids|Sort|[Gg]rex|gx)\\\\b\")", "var_name": "CULTIVAR_GROUP"}, {"original_string": "private static final Pattern BOLD_PLACEHOLDERS = Pattern.compile(\"^([A-Z][a-z]+)_?([A-Z]{1,5}(_\\\\d+)?)$\");", "modifier": "private static final", "type": "Pattern", "declarator": "BOLD_PLACEHOLDERS = Pattern.compile(\"^([A-Z][a-z]+)_?([A-Z]{1,5}(_\\\\d+)?)$\")", "var_name": "BOLD_PLACEHOLDERS"}, {"original_string": "private static final Pattern UNPARSABLE_GROUP  = Pattern.compile(\"^([A-Z][a-z]+)( [a-z]+?)?( species)?[ _-]group$\");", "modifier": "private static final", "type": "Pattern", "declarator": "UNPARSABLE_GROUP  = Pattern.compile(\"^([A-Z][a-z]+)( [a-z]+?)?( species)?[ _-]group$\")", "var_name": "UNPARSABLE_GROUP"}, {"original_string": "private static final Pattern INFRASPEC_UPPER = Pattern.compile(\"(?<=forma? )([A-Z])\\\\b\");", "modifier": "private static final", "type": "Pattern", "declarator": "INFRASPEC_UPPER = Pattern.compile(\"(?<=forma? )([A-Z])\\\\b\")", "var_name": "INFRASPEC_UPPER"}, {"original_string": "private static final Pattern STRAIN = Pattern.compile(\"([a-z]\\\\.?) +([A-Z]+[ -]?(?!\"+YEAR+\")[0-9]+T?)$\");", "modifier": "private static final", "type": "Pattern", "declarator": "STRAIN = Pattern.compile(\"([a-z]\\\\.?) +([A-Z]+[ -]?(?!\"+YEAR+\")[0-9]+T?)$\")", "var_name": "STRAIN"}, {"original_string": "public static final Pattern IS_VIRUS_PATTERN = Pattern.compile(\"virus(es)?\\\\b|\" +\n      \"\\\\b(\" +\n          \"(bacterio|viro)?phage(in|s)?|\" +\n          \"particles?|\" +\n          \"prion|\" +\n          \"replicon|\" +\n          \"(alpha|beta|circular) ?satellites|\" +\n          \"[a-z]+satellite|\" +\n          \"vector|\" +\n          \"viroid|\" +\n          \"ictv$\" +\n      \")\\\\b\", CASE_INSENSITIVE);", "modifier": "public static final", "type": "Pattern", "declarator": "IS_VIRUS_PATTERN = Pattern.compile(\"virus(es)?\\\\b|\" +\n      \"\\\\b(\" +\n          \"(bacterio|viro)?phage(in|s)?|\" +\n          \"particles?|\" +\n          \"prion|\" +\n          \"replicon|\" +\n          \"(alpha|beta|circular) ?satellites|\" +\n          \"[a-z]+satellite|\" +\n          \"vector|\" +\n          \"viroid|\" +\n          \"ictv$\" +\n      \")\\\\b\", CASE_INSENSITIVE)", "var_name": "IS_VIRUS_PATTERN"}, {"original_string": "public static final Pattern IS_VIRUS_PATTERN_CASE_SENSITIVE = Pattern.compile(\"\\\\b(:?[MS]?NP|G)V\\\\b\");", "modifier": "public static final", "type": "Pattern", "declarator": "IS_VIRUS_PATTERN_CASE_SENSITIVE = Pattern.compile(\"\\\\b(:?[MS]?NP|G)V\\\\b\")", "var_name": "IS_VIRUS_PATTERN_CASE_SENSITIVE"}, {"original_string": "private static final Pattern IS_VIRUS_PATTERN_POSTFAIL = Pattern.compile(\"(\\\\b(vector)\\\\b)\", CASE_INSENSITIVE);", "modifier": "private static final", "type": "Pattern", "declarator": "IS_VIRUS_PATTERN_POSTFAIL = Pattern.compile(\"(\\\\b(vector)\\\\b)\", CASE_INSENSITIVE)", "var_name": "IS_VIRUS_PATTERN_POSTFAIL"}, {"original_string": "public static final Pattern IS_GENE = Pattern.compile(\"(RNA|DNA)[0-9]*(?:\\\\b|_)\");", "modifier": "public static final", "type": "Pattern", "declarator": "IS_GENE = Pattern.compile(\"(RNA|DNA)[0-9]*(?:\\\\b|_)\")", "var_name": "IS_GENE"}, {"original_string": "private static final Pattern OTU_PATTERN = Pattern.compile(\"(BOLD:[0-9A-Z]{7}$|SH[0-9]{6,8}\\\\.[0-9]{2}FU)\", CASE_INSENSITIVE);", "modifier": "private static final", "type": "Pattern", "declarator": "OTU_PATTERN = Pattern.compile(\"(BOLD:[0-9A-Z]{7}$|SH[0-9]{6,8}\\\\.[0-9]{2}FU)\", CASE_INSENSITIVE)", "var_name": "OTU_PATTERN"}, {"original_string": "private static final String CANDIDATUS = \"(Candidatus\\\\s|Ca\\\\.)\";", "modifier": "private static final", "type": "String", "declarator": "CANDIDATUS = \"(Candidatus\\\\s|Ca\\\\.)\"", "var_name": "CANDIDATUS"}, {"original_string": "private static final Pattern IS_CANDIDATUS_PATTERN = Pattern.compile(CANDIDATUS);", "modifier": "private static final", "type": "Pattern", "declarator": "IS_CANDIDATUS_PATTERN = Pattern.compile(CANDIDATUS)", "var_name": "IS_CANDIDATUS_PATTERN"}, {"original_string": "private static final Pattern IS_CANDIDATUS_QUOTE_PATTERN = Pattern.compile(\"\\\"\" + CANDIDATUS + \"(.+)\\\"\", CASE_INSENSITIVE);", "modifier": "private static final", "type": "Pattern", "declarator": "IS_CANDIDATUS_QUOTE_PATTERN = Pattern.compile(\"\\\"\" + CANDIDATUS + \"(.+)\\\"\", CASE_INSENSITIVE)", "var_name": "IS_CANDIDATUS_QUOTE_PATTERN"}, {"original_string": "@VisibleForTesting\n  static final Pattern FAMILY_PREFIX = Pattern.compile(\"^[A-Z][a-z]*(?:aceae|idae) +(\" +\n        StringUtils.join(RankUtils.RANK_MARKER_MAP_FAMILY_GROUP.keySet(), \"|\") +\n      \")\\\\b\");", "modifier": "@VisibleForTesting\n  static final", "type": "Pattern", "declarator": "FAMILY_PREFIX = Pattern.compile(\"^[A-Z][a-z]*(?:aceae|idae) +(\" +\n        StringUtils.join(RankUtils.RANK_MARKER_MAP_FAMILY_GROUP.keySet(), \"|\") +\n      \")\\\\b\")", "var_name": "FAMILY_PREFIX"}, {"original_string": "private static final Pattern SUPRA_RANK_PREFIX = Pattern.compile(\"^(\" + StringUtils.join(\n      ImmutableMap.builder()\n          .putAll(RankUtils.RANK_MARKER_MAP_SUPRAGENERIC)\n          .putAll(RankUtils.RANK_MARKER_MAP_INFRAGENERIC)\n          .build().keySet()\n      , \"|\") + \")[\\\\. ] *\");", "modifier": "private static final", "type": "Pattern", "declarator": "SUPRA_RANK_PREFIX = Pattern.compile(\"^(\" + StringUtils.join(\n      ImmutableMap.builder()\n          .putAll(RankUtils.RANK_MARKER_MAP_SUPRAGENERIC)\n          .putAll(RankUtils.RANK_MARKER_MAP_INFRAGENERIC)\n          .build().keySet()\n      , \"|\") + \")[\\\\. ] *\")", "var_name": "SUPRA_RANK_PREFIX"}, {"original_string": "private static final Pattern RANK_MARKER_AT_END = Pattern.compile(\"[ .]\" +\n      RANK_MARKER_ALL.substring(0,RANK_MARKER_ALL.lastIndexOf(')')) +\n      \"|\" +\n      RANK_MARKER_MICROBIAL.substring(3) +\n      // allow for larva/adult life stage indicators: http://dev.gbif.org/issues/browse/POR-3000\n      \"[. ]?(?:Ad|Lv)?\\\\.?\" +\n      \"$\");", "modifier": "private static final", "type": "Pattern", "declarator": "RANK_MARKER_AT_END = Pattern.compile(\"[ .]\" +\n      RANK_MARKER_ALL.substring(0,RANK_MARKER_ALL.lastIndexOf(')')) +\n      \"|\" +\n      RANK_MARKER_MICROBIAL.substring(3) +\n      // allow for larva/adult life stage indicators: http://dev.gbif.org/issues/browse/POR-3000\n      \"[. ]?(?:Ad|Lv)?\\\\.?\" +\n      \"$\")", "var_name": "RANK_MARKER_AT_END"}, {"original_string": "private static final Pattern FILIUS_AT_END = Pattern.compile(\"[ .]f\\\\.?$\");", "modifier": "private static final", "type": "Pattern", "declarator": "FILIUS_AT_END = Pattern.compile(\"[ .]f\\\\.?$\")", "var_name": "FILIUS_AT_END"}, {"original_string": "static final Pattern EXTRACT_SENSU = Pattern.compile(\"[;, ]?(?:\\\\b|^)\" +\n      \"(\" +\n        \"(?:(?:excl[. ](?:gen|sp|var)|mut.char|p.p)[. ])?\" +\n        \"\\\\(?(?:\" +\n          \"ss?[. ](?:(?:ampl|l|s|str)[. ]|(?:ampl|lat|strict)(?:[uo]|issimo)?)\" +\n          \"|(?:(?:ss[. ])?[aA]uctt?|[eE]mend|[fF]ide|[nN]on|[nN]ec|[sS]ec|[sS]ensu|[aA]ccording to)(?:[. ]|\\\\.?$).*\" +\n        \")\\\\)?\" +\n      \")\");", "modifier": "static final", "type": "Pattern", "declarator": "EXTRACT_SENSU = Pattern.compile(\"[;, ]?(?:\\\\b|^)\" +\n      \"(\" +\n        \"(?:(?:excl[. ](?:gen|sp|var)|mut.char|p.p)[. ])?\" +\n        \"\\\\(?(?:\" +\n          \"ss?[. ](?:(?:ampl|l|s|str)[. ]|(?:ampl|lat|strict)(?:[uo]|issimo)?)\" +\n          \"|(?:(?:ss[. ])?[aA]uctt?|[eE]mend|[fF]ide|[nN]on|[nN]ec|[sS]ec|[sS]ensu|[aA]ccording to)(?:[. ]|\\\\.?$).*\" +\n        \")\\\\)?\" +\n      \")\")", "var_name": "EXTRACT_SENSU"}, {"original_string": "private static final String NOV_RANKS = \"((?:[sS]ub)?(?:[fF]am|[gG]en|[sS]s?p(?:ec)?|[vV]ar|[fF](?:orma?)?))\";", "modifier": "private static final", "type": "String", "declarator": "NOV_RANKS = \"((?:[sS]ub)?(?:[fF]am|[gG]en|[sS]s?p(?:ec)?|[vV]ar|[fF](?:orma?)?))\"", "var_name": "NOV_RANKS"}, {"original_string": "private static final Pattern NOV_RANK_MARKER = Pattern.compile(\"(\" + NOV_RANKS + \")\");", "modifier": "private static final", "type": "Pattern", "declarator": "NOV_RANK_MARKER = Pattern.compile(\"(\" + NOV_RANKS + \")\")", "var_name": "NOV_RANK_MARKER"}, {"original_string": "static final String MANUSCRIPT_STATUS = \"(?:(?:comb[. ]?)?ined|ms)\\\\.?($|\\\\s)\";", "modifier": "static final", "type": "String", "declarator": "MANUSCRIPT_STATUS = \"(?:(?:comb[. ]?)?ined|ms)\\\\.?($|\\\\s)\"", "var_name": "MANUSCRIPT_STATUS"}, {"original_string": "static final Pattern MANUSCRIPT_STATUS_PATTERN = Pattern.compile(MANUSCRIPT_STATUS);", "modifier": "static final", "type": "Pattern", "declarator": "MANUSCRIPT_STATUS_PATTERN = Pattern.compile(MANUSCRIPT_STATUS)", "var_name": "MANUSCRIPT_STATUS_PATTERN"}, {"original_string": "static final Pattern EXTRACT_NOMSTATUS = Pattern.compile(\"[;, ]?\"\n      + \"\\\\(?\"\n      + \"\\\\b(\"\n        + \"(?:comb|\"+NOV_RANKS+\")[. ]nov\\\\b[. ]?(?:ined[. ])?\"\n        + \"|\"+MANUSCRIPT_STATUS\n        + \"|nom(?:en)?[. ]\"\n          + \"(?:utiq(?:ue)?[. ])?\"\n          + \"(?:ambig|alter|alt|correct|cons|dubium|dub|herb|illeg|invalid|inval|negatum|neg|novum|nov|nudum|nud|oblitum|obl|praeoccup|prov|prot|transf|superfl|super|rejic|rej)\\\\b[. ]?\"\n          + \"(?:prop[. ]|proposed\\\\b)?\"\n      + \")\"\n      + \"\\\\)?\");", "modifier": "static final", "type": "Pattern", "declarator": "EXTRACT_NOMSTATUS = Pattern.compile(\"[;, ]?\"\n      + \"\\\\(?\"\n      + \"\\\\b(\"\n        + \"(?:comb|\"+NOV_RANKS+\")[. ]nov\\\\b[. ]?(?:ined[. ])?\"\n        + \"|\"+MANUSCRIPT_STATUS\n        + \"|nom(?:en)?[. ]\"\n          + \"(?:utiq(?:ue)?[. ])?\"\n          + \"(?:ambig|alter|alt|correct|cons|dubium|dub|herb|illeg|invalid|inval|negatum|neg|novum|nov|nudum|nud|oblitum|obl|praeoccup|prov|prot|transf|superfl|super|rejic|rej)\\\\b[. ]?\"\n          + \"(?:prop[. ]|proposed\\\\b)?\"\n      + \")\"\n      + \"\\\\)?\")", "var_name": "EXTRACT_NOMSTATUS"}, {"original_string": "private static final Pattern NORM_ANON = Pattern.compile(\"\\\\b(anon\\\\.?)(\\\\b|\\\\s|$)\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_ANON = Pattern.compile(\"\\\\b(anon\\\\.?)(\\\\b|\\\\s|$)\")", "var_name": "NORM_ANON"}, {"original_string": "private static final Pattern COMMA_AFTER_BASYEAR = Pattern.compile(\"(\"+YEAR+\")\\\\s*\\\\)\\\\s*,\");", "modifier": "private static final", "type": "Pattern", "declarator": "COMMA_AFTER_BASYEAR = Pattern.compile(\"(\"+YEAR+\")\\\\s*\\\\)\\\\s*,\")", "var_name": "COMMA_AFTER_BASYEAR"}, {"original_string": "private static final Pattern NORM_APOSTROPHES = Pattern.compile(\"([\\u0060\\u00B4\\u2018\\u2019]+)\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_APOSTROPHES = Pattern.compile(\"([\\u0060\\u00B4\\u2018\\u2019]+)\")", "var_name": "NORM_APOSTROPHES"}, {"original_string": "private static final Pattern NORM_QUOTES = Pattern.compile(\"([\\\"'`\u00b4]+)\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_QUOTES = Pattern.compile(\"([\\\"'`\u00b4]+)\");", "var_name": "NORM_QUOTES"}, {"original_string": "private static final Pattern REPL_GENUS_QUOTE = Pattern.compile(\"^' *(\" + MONOMIAL + \") *'\");", "modifier": "private static final", "type": "Pattern", "declarator": "REPL_GENUS_QUOTE = Pattern.compile(\"^' *(\" + MONOMIAL + \") *'\")", "var_name": "REPL_GENUS_QUOTE"}, {"original_string": "private static final Pattern REPL_ENCLOSING_QUOTE = Pattern.compile(\"^$\");", "modifier": "private static final", "type": "Pattern", "declarator": "REPL_ENCLOSING_QUOTE = Pattern.compile(\"^$\")", "var_name": "REPL_ENCLOSING_QUOTE"}, {"original_string": "private static final Pattern NORM_UPPERCASE_WORDS = Pattern.compile(\"\\\\b(\\\\p{Lu})(\\\\p{Lu}{2,})\\\\b\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_UPPERCASE_WORDS = Pattern.compile(\"\\\\b(\\\\p{Lu})(\\\\p{Lu}{2,})\\\\b\")", "var_name": "NORM_UPPERCASE_WORDS"}, {"original_string": "private static final Pattern NORM_LOWERCASE_BINOMIAL = Pattern.compile(\"^(\" + EPITHET + \") (\" + EPITHET + \")\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_LOWERCASE_BINOMIAL = Pattern.compile(\"^(\" + EPITHET + \") (\" + EPITHET + \")\")", "var_name": "NORM_LOWERCASE_BINOMIAL"}, {"original_string": "private static final Pattern NORM_WHITESPACE = Pattern.compile(\"(?:\\\\\\\\[nr]|\\\\s)+\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_WHITESPACE = Pattern.compile(\"(?:\\\\\\\\[nr]|\\\\s)+\")", "var_name": "NORM_WHITESPACE"}, {"original_string": "private static final Pattern REPL_UNDERSCORE = Pattern.compile(\"_+\");", "modifier": "private static final", "type": "Pattern", "declarator": "REPL_UNDERSCORE = Pattern.compile(\"_+\")", "var_name": "REPL_UNDERSCORE"}, {"original_string": "private static final Pattern NORM_NO_SQUARE_BRACKETS = Pattern.compile(\"\\\\[(.*?)\\\\]\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_NO_SQUARE_BRACKETS = Pattern.compile(\"\\\\[(.*?)\\\\]\")", "var_name": "NORM_NO_SQUARE_BRACKETS"}, {"original_string": "private static final Pattern NORM_BRACKETS_OPEN = Pattern.compile(\"\\\\s*([{(\\\\[])\\\\s*,?\\\\s*\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_BRACKETS_OPEN = Pattern.compile(\"\\\\s*([{(\\\\[])\\\\s*,?\\\\s*\")", "var_name": "NORM_BRACKETS_OPEN"}, {"original_string": "private static final Pattern NORM_BRACKETS_CLOSE = Pattern.compile(\"\\\\s*,?\\\\s*([})\\\\]])\\\\s*\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_BRACKETS_CLOSE = Pattern.compile(\"\\\\s*,?\\\\s*([})\\\\]])\\\\s*\")", "var_name": "NORM_BRACKETS_CLOSE"}, {"original_string": "private static final Pattern NORM_BRACKETS_OPEN_STRONG = Pattern.compile(\"( ?[{\\\\[] ?)+\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_BRACKETS_OPEN_STRONG = Pattern.compile(\"( ?[{\\\\[] ?)+\")", "var_name": "NORM_BRACKETS_OPEN_STRONG"}, {"original_string": "private static final Pattern NORM_BRACKETS_CLOSE_STRONG = Pattern.compile(\"( ?[}\\\\]] ?)+\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_BRACKETS_CLOSE_STRONG = Pattern.compile(\"( ?[}\\\\]] ?)+\")", "var_name": "NORM_BRACKETS_CLOSE_STRONG"}, {"original_string": "private static final Pattern NORM_AND = Pattern.compile(\"\\\\b *(and|et|und|\\\\+|,&) *\\\\b\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_AND = Pattern.compile(\"\\\\b *(and|et|und|\\\\+|,&) *\\\\b\")", "var_name": "NORM_AND"}, {"original_string": "private static final Pattern NORM_SUBGENUS = Pattern.compile(\"(\" + MONOMIAL + \") (\" + MONOMIAL + \") (\" + EPITHET + \")\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_SUBGENUS = Pattern.compile(\"(\" + MONOMIAL + \") (\" + MONOMIAL + \") (\" + EPITHET + \")\")", "var_name": "NORM_SUBGENUS"}, {"original_string": "private static final Pattern NO_Q_MARKS = Pattern.compile(\"([\" + author_letters + \"])\\\\?+\");", "modifier": "private static final", "type": "Pattern", "declarator": "NO_Q_MARKS = Pattern.compile(\"([\" + author_letters + \"])\\\\?+\")", "var_name": "NO_Q_MARKS"}, {"original_string": "private static final Pattern NORM_PUNCTUATIONS = Pattern.compile(\"\\\\s*([.,;:&(){}\\\\[\\\\]-])\\\\s*\\\\1*\\\\s*\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_PUNCTUATIONS = Pattern.compile(\"\\\\s*([.,;:&(){}\\\\[\\\\]-])\\\\s*\\\\1*\\\\s*\")", "var_name": "NORM_PUNCTUATIONS"}, {"original_string": "private static final Pattern NORM_YEAR = Pattern.compile(\"[\\\"'\\\\[]+\\\\s*(\" + YEAR_LOOSE + \")\\\\s*[\\\"'\\\\]]+\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_YEAR = Pattern.compile(\"[\\\"'\\\\[]+\\\\s*(\" + YEAR_LOOSE + \")\\\\s*[\\\"'\\\\]]+\")", "var_name": "NORM_YEAR"}, {"original_string": "private static final Pattern NORM_IMPRINT_YEAR = Pattern.compile(\"(\" + YEAR_LOOSE + \")\\\\s*\" +\n      \"([(\\\\[,&]? *(?:not|imprint)? *\\\"?\" + YEAR_LOOSE + \"\\\"?[)\\\\]]?)\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_IMPRINT_YEAR = Pattern.compile(\"(\" + YEAR_LOOSE + \")\\\\s*\" +\n      \"([(\\\\[,&]? *(?:not|imprint)? *\\\"?\" + YEAR_LOOSE + \"\\\"?[)\\\\]]?)\")", "var_name": "NORM_IMPRINT_YEAR"}, {"original_string": "private static final Pattern NORM_HYBRIDS_GENUS = Pattern.compile(\"^\\\\s*(?:[+\u00d7xX]|\u221a\u00f3)\\\\s*([\" + NAME_LETTERS + \"])\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_HYBRIDS_GENUS = Pattern.compile(\"^\\\\s*(?:[+\u00d7xX]|\u221a\u00f3)\\\\s*([\" + NAME_LETTERS + \"])\");", "var_name": "NORM_HYBRIDS_GENUS"}, {"original_string": "private static final Pattern NORM_HYBRIDS_EPITH = Pattern.compile(\"^\\\\s*(\u00d7?\" + MONOMIAL + \")\\\\s+(?:\u00d7|\u221a\u00f3|[xX]\\\\s)\\\\s*(\" + EPITHET + \")\");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_HYBRIDS_EPITH = Pattern.compile(\"^\\\\s*(\u00d7?\" + MONOMIAL + \")\\\\s+(?:\u00d7|\u221a\u00f3|[xX]\\\\s)\\\\s*(\" + EPITHET + \")\");", "var_name": "NORM_HYBRIDS_EPITH"}, {"original_string": "private static final Pattern NORM_HYBRIDS_FORM = Pattern.compile(\"\\\\b([\u00d7xX]|\u221a\u00f3) \");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_HYBRIDS_FORM = Pattern.compile(\"\\\\b([\u00d7xX]|\u221a\u00f3) \");", "var_name": "NORM_HYBRIDS_FORM"}, {"original_string": "private static final Pattern NORM_TF_GENUS = Pattern.compile(\"^([\" + NAME_LETTERS + \"])\\\\(([\" + name_letters + \"-]+)\\\\)\\\\.? \");", "modifier": "private static final", "type": "Pattern", "declarator": "NORM_TF_GENUS = Pattern.compile(\"^([\" + NAME_LETTERS + \"])\\\\(([\" + name_letters + \"-]+)\\\\)\\\\.? \")", "var_name": "NORM_TF_GENUS"}, {"original_string": "private static final Pattern REPL_FINAL_PUNCTUATIONS = Pattern.compile(\"[,;:]+$\");", "modifier": "private static final", "type": "Pattern", "declarator": "REPL_FINAL_PUNCTUATIONS = Pattern.compile(\"[,;:]+$\")", "var_name": "REPL_FINAL_PUNCTUATIONS"}, {"original_string": "private static final Pattern REPL_IN_REF = Pattern.compile(\"[, ]?\\\\b(in|IN|apud) (\" + AUTHOR_TEAM + \")(.*?)$\");", "modifier": "private static final", "type": "Pattern", "declarator": "REPL_IN_REF = Pattern.compile(\"[, ]?\\\\b(in|IN|apud) (\" + AUTHOR_TEAM + \")(.*?)$\")", "var_name": "REPL_IN_REF"}, {"original_string": "private static final Pattern REPL_RANK_PREFIXES = Pattern.compile(\"^(sub)?(fossil|\" +\n      StringUtils.join(RankUtils.RANK_MARKER_MAP_SUPRAGENERIC.keySet(), \"|\") + \")\\\\.?\\\\s+\", CASE_INSENSITIVE);", "modifier": "private static final", "type": "Pattern", "declarator": "REPL_RANK_PREFIXES = Pattern.compile(\"^(sub)?(fossil|\" +\n      StringUtils.join(RankUtils.RANK_MARKER_MAP_SUPRAGENERIC.keySet(), \"|\") + \")\\\\.?\\\\s+\", CASE_INSENSITIVE)", "var_name": "REPL_RANK_PREFIXES"}, {"original_string": "private static final Pattern MANUSCRIPT_NAMES = Pattern.compile(\"\\\\b(indet|spp?)[. ](?:nov\\\\.)?[A-Z0-9][a-zA-Z0-9-]*(?:\\\\(.+?\\\\))?\");", "modifier": "private static final", "type": "Pattern", "declarator": "MANUSCRIPT_NAMES = Pattern.compile(\"\\\\b(indet|spp?)[. ](?:nov\\\\.)?[A-Z0-9][a-zA-Z0-9-]*(?:\\\\(.+?\\\\))?\")", "var_name": "MANUSCRIPT_NAMES"}, {"original_string": "private static final Pattern NO_LETTERS = Pattern.compile(\"^[^a-zA-Z]+$\");", "modifier": "private static final", "type": "Pattern", "declarator": "NO_LETTERS = Pattern.compile(\"^[^a-zA-Z]+$\")", "var_name": "NO_LETTERS"}, {"original_string": "private static final Pattern REMOVE_PLACEHOLDER_AUTHOR = Pattern.compile(\"\\\\b\"+\n      \"(?:unknown|unspecified|uncertain|\\\\?)\" +\n      \"[, ] ?(\" + YEAR_LOOSE + \")$\", CASE_INSENSITIVE\n  );", "modifier": "private static final", "type": "Pattern", "declarator": "REMOVE_PLACEHOLDER_AUTHOR = Pattern.compile(\"\\\\b\"+\n      \"(?:unknown|unspecified|uncertain|\\\\?)\" +\n      \"[, ] ?(\" + YEAR_LOOSE + \")$\", CASE_INSENSITIVE\n  )", "var_name": "REMOVE_PLACEHOLDER_AUTHOR"}, {"original_string": "private static final Pattern PLACEHOLDER_GENUS = Pattern.compile(\"^(In|Dummy|Missing|Temp|Unknown|Unplaced|Unspecified) (?=[a-z]+)\\\\b\");", "modifier": "private static final", "type": "Pattern", "declarator": "PLACEHOLDER_GENUS = Pattern.compile(\"^(In|Dummy|Missing|Temp|Unknown|Unplaced|Unspecified) (?=[a-z]+)\\\\b\")", "var_name": "PLACEHOLDER_GENUS"}, {"original_string": "private static final String PLACEHOLDER_NAME = \"(?:allocation|awaiting|\" +\n    \"deleted?|dummy|incertae ?sedis|indetermined|mixed|\" +\n    \"not (?:assigned|stated)|\" +\n    \"place ?holder|temp|tobedeleted|\" +\n    \"un(?:accepted|allocated|assigned|certain|classed|classified|cultured|described|det(?:ermined)?|ident|known|named|placed|specified)\" +\n  \")\";", "modifier": "private static final", "type": "String", "declarator": "PLACEHOLDER_NAME = \"(?:allocation|awaiting|\" +\n    \"deleted?|dummy|incertae ?sedis|indetermined|mixed|\" +\n    \"not (?:assigned|stated)|\" +\n    \"place ?holder|temp|tobedeleted|\" +\n    \"un(?:accepted|allocated|assigned|certain|classed|classified|cultured|described|det(?:ermined)?|ident|known|named|placed|specified)\" +\n  \")\"", "var_name": "PLACEHOLDER_NAME"}, {"original_string": "private static final Pattern REMOVE_PLACEHOLDER_INFRAGENERIC = Pattern.compile(\"\\\\b\\\\( ?\"+PLACEHOLDER_NAME+\" ?\\\\) \", CASE_INSENSITIVE);", "modifier": "private static final", "type": "Pattern", "declarator": "REMOVE_PLACEHOLDER_INFRAGENERIC = Pattern.compile(\"\\\\b\\\\( ?\"+PLACEHOLDER_NAME+\" ?\\\\) \", CASE_INSENSITIVE)", "var_name": "REMOVE_PLACEHOLDER_INFRAGENERIC"}, {"original_string": "@VisibleForTesting\n  static final Pattern PLACEHOLDER = Pattern.compile(\"^N\\\\.\\\\s*N\\\\.|\\\\b\"+PLACEHOLDER_NAME+\"\\\\b\", CASE_INSENSITIVE);", "modifier": "@VisibleForTesting\n  static final", "type": "Pattern", "declarator": "PLACEHOLDER = Pattern.compile(\"^N\\\\.\\\\s*N\\\\.|\\\\b\"+PLACEHOLDER_NAME+\"\\\\b\", CASE_INSENSITIVE)", "var_name": "PLACEHOLDER"}, {"original_string": "private static final Pattern DOUBTFUL = Pattern.compile(\"^[\" + AUTHOR_LETTERS + author_letters + HYBRID_MARKER + \"\\\":;&*+\\\\s,.()\\\\[\\\\]/'`\u00b40-9-\u2020]+$\");", "modifier": "private static final", "type": "Pattern", "declarator": "DOUBTFUL = Pattern.compile(\"^[\" + AUTHOR_LETTERS + author_letters + HYBRID_MARKER + \"\\\":;&*+\\\\s,.()\\\\[\\\\]/'`\u00b40-9-\u2020]+$\");", "var_name": "DOUBTFUL"}, {"original_string": "private static final Pattern DOUBTFUL_NULL = Pattern.compile(\"\\\\bnull\\\\b\", CASE_INSENSITIVE);", "modifier": "private static final", "type": "Pattern", "declarator": "DOUBTFUL_NULL = Pattern.compile(\"\\\\bnull\\\\b\", CASE_INSENSITIVE)", "var_name": "DOUBTFUL_NULL"}, {"original_string": "private static final Pattern XML_ENTITY_STRIP = Pattern.compile(\"&\\\\s*([a-z]+)\\\\s*;\");", "modifier": "private static final", "type": "Pattern", "declarator": "XML_ENTITY_STRIP = Pattern.compile(\"&\\\\s*([a-z]+)\\\\s*;\")", "var_name": "XML_ENTITY_STRIP"}, {"original_string": "private static final Pattern AMPERSAND_ENTITY = Pattern.compile(\"& *amp +\");", "modifier": "private static final", "type": "Pattern", "declarator": "AMPERSAND_ENTITY = Pattern.compile(\"& *amp +\")", "var_name": "AMPERSAND_ENTITY"}, {"original_string": "private static final Pattern XML_TAGS = Pattern.compile(\"< */? *[a-zA-Z] *>\");", "modifier": "private static final", "type": "Pattern", "declarator": "XML_TAGS = Pattern.compile(\"< */? *[a-zA-Z] *>\")", "var_name": "XML_TAGS"}, {"original_string": "private static final Pattern STARTING_EPITHET = Pattern.compile(\"^\\\\s*(\" + EPITHET + \")\\\\b\");", "modifier": "private static final", "type": "Pattern", "declarator": "STARTING_EPITHET = Pattern.compile(\"^\\\\s*(\" + EPITHET + \")\\\\b\")", "var_name": "STARTING_EPITHET"}, {"original_string": "private static final Pattern FORM_SPECIALIS = Pattern.compile(\"\\\\bf\\\\. *sp(?:ec)?\\\\b\");", "modifier": "private static final", "type": "Pattern", "declarator": "FORM_SPECIALIS = Pattern.compile(\"\\\\bf\\\\. *sp(?:ec)?\\\\b\")", "var_name": "FORM_SPECIALIS"}, {"original_string": "private static final Pattern SENSU_LATU = Pattern.compile(\"\\\\bs\\\\.l\\\\.\\\\b\");", "modifier": "private static final", "type": "Pattern", "declarator": "SENSU_LATU = Pattern.compile(\"\\\\bs\\\\.l\\\\.\\\\b\")", "var_name": "SENSU_LATU"}, {"original_string": "private static final Pattern NOM_REFS = Pattern.compile(\"[,;.]?[\\\\p{Lu}\\\\p{Ll}\\\\s]*\\\\b(?:Proceedings|Journal|Annals|Bulletin|Systematics|Taxonomy|Series|Memoirs|Mitteilungen|Berichte)\\\\b.+$\");", "modifier": "private static final", "type": "Pattern", "declarator": "NOM_REFS = Pattern.compile(\"[,;.]?[\\\\p{Lu}\\\\p{Ll}\\\\s]*\\\\b(?:Proceedings|Journal|Annals|Bulletin|Systematics|Taxonomy|Series|Memoirs|Mitteilungen|Berichte)\\\\b.+$\")", "var_name": "NOM_REFS"}, {"original_string": "private static final Pattern NOM_REF_VOLUME = Pattern.compile(\"[,;.]?[\\\\p{Lu}\\\\p{Ll}\\\\s]*\\\\b\\\\d+\\\\s*(//(\\\\d+//))?:\\\\s*\\\\d+\\\\b.+$\");", "modifier": "private static final", "type": "Pattern", "declarator": "NOM_REF_VOLUME = Pattern.compile(\"[,;.]?[\\\\p{Lu}\\\\p{Ll}\\\\s]*\\\\b\\\\d+\\\\s*(//(\\\\d+//))?:\\\\s*\\\\d+\\\\b.+$\")", "var_name": "NOM_REF_VOLUME"}, {"original_string": "private static final Pattern TYPE_TO_VAR;", "modifier": "private static final", "type": "Pattern", "declarator": "TYPE_TO_VAR", "var_name": "TYPE_TO_VAR"}, {"original_string": "private static final Set<String> BLACKLIST_EPITHETS;", "modifier": "private static final", "type": "Set<String>", "declarator": "BLACKLIST_EPITHETS", "var_name": "BLACKLIST_EPITHETS"}, {"original_string": "@VisibleForTesting\n  static final Pattern POTENTIAL_NAME_PATTERN = Pattern.compile(\"^\u00d7?\" + MONOMIAL + \"\\\\b\");", "modifier": "@VisibleForTesting\n  static final", "type": "Pattern", "declarator": "POTENTIAL_NAME_PATTERN = Pattern.compile(\"^\u00d7?\" + MONOMIAL + \"\\\\b\");", "var_name": "POTENTIAL_NAME_PATTERN"}, {"original_string": "private static final Pattern REMOVE_INTER_RANKS = Pattern.compile(\"\\\\b((?:subsp|ssp|var)[ .].+)\\\\b(\"+RANK_MARKER+\")\\\\b\");", "modifier": "private static final", "type": "Pattern", "declarator": "REMOVE_INTER_RANKS = Pattern.compile(\"\\\\b((?:subsp|ssp|var)[ .].+)\\\\b(\"+RANK_MARKER+\")\\\\b\")", "var_name": "REMOVE_INTER_RANKS"}, {"original_string": "private static final String SKIP_AUTHORS = \"(?:\\\\b[ \\\\p{Ll}'(-]{0,3}\\\\p{Lu}.*?\\\\b)??\";", "modifier": "private static final", "type": "String", "declarator": "SKIP_AUTHORS = \"(?:\\\\b[ \\\\p{Ll}'(-]{0,3}\\\\p{Lu}.*?\\\\b)??\"", "var_name": "SKIP_AUTHORS"}, {"original_string": "public static final Pattern NAME_PATTERN = Pattern.compile(\"^\" +\n             // #1 genus/monomial\n             \"(\u00d7?(?:\\\\?|\" + MONOMIAL + \"))\" +\n             // #2 or #4 subgenus/section with #3 infrageneric rank marker\n             \"(?:(?<!ceae)\" + INFRAGENERIC + \")?\" +\n             // #5+6 species\n             \"(?:(?:\\\\b| )\"+EPI_QUALIFIER+\"(\u00d7?\" + EPITHET + \")\" +\n                \"(?:\" +\n                // any superfluous intermediate bits before terminal epithets, e.g. species authors\n                \"(?:.*?)\" +\n                // #7 superfluous subspecies epithet\n                \"( \u00d7?\" + EPITHET + \")?\" +\n                // #8 infraspecies qualifier\n                \" ?\"+ EPI_QUALIFIER +\n                // #9 infraspecies rank\n                \"[. ]?(\" + RANK_MARKER + \")?\" +\n                // #10 infraspecies epitheton, avoid matching to bis and degli which is part of (Italian) author names\n                \"[. ](\u00d7?\\\"?(?!\" + AUTHOR_SUFFIX + \"\\\\b)\" + EPITHET + \"\\\"?)\" +\n                \")?\" +\n              \")?\" +\n\n             \"(?: \" +\n               // #11 microbial rank\n               \"(\" + RANK_MARKER_MICROBIAL + \")[ .]\" +\n               // #12 microbial infrasubspecific epithet\n               \"(\\\\S+)\" +\n             \")?\" +\n\n             // #13 indet rank marker after epithets\n             \"([. ]\" + RANK_MARKER + \")?\" +\n\n             // #14 entire authorship incl basionyms and year\n             \"([., ]?\" +\n               \"(?:\\\\(\" +\n                 // #15/16/17 basionym authorship (ex/auth/sanct)\n                 \"(?:\" + AUTHORSHIP + \")?\" +\n                 // #18 basionym year\n                 \"[, ]?(\" + YEAR_LOOSE + \")?\" +\n               \"\\\\))?\" +\n\n               // #19/20/21 authorship (ex/auth/sanct)\n               \"(?:\" + AUTHORSHIP + \")?\" +\n               // #22 year with or without brackets\n               \"(?: ?\\\\(?,?(\" + YEAR_LOOSE + \")\\\\)?)?\" +\n             \")\" +\n\n             // #23 any remainder\n             \"(\\\\b.*?)??$\");", "modifier": "public static final", "type": "Pattern", "declarator": "NAME_PATTERN = Pattern.compile(\"^\" +\n             // #1 genus/monomial\n             \"(\u00d7?(?:\\\\?|\" + MONOMIAL + \"))\" +\n             // #2 or #4 subgenus/section with #3 infrageneric rank marker\n             \"(?:(?<!ceae)\" + INFRAGENERIC + \")?\" +\n             // #5+6 species\n             \"(?:(?:\\\\b| )\"+EPI_QUALIFIER+\"(\u00d7?\" + EPITHET + \")\" +\n                \"(?:\" +\n                // any superfluous intermediate bits before terminal epithets, e.g. species authors\n                \"(?:.*?)\" +\n                // #7 superfluous subspecies epithet\n                \"( \u00d7?\" + EPITHET + \")?\" +\n                // #8 infraspecies qualifier\n                \" ?\"+ EPI_QUALIFIER +\n                // #9 infraspecies rank\n                \"[. ]?(\" + RANK_MARKER + \")?\" +\n                // #10 infraspecies epitheton, avoid matching to bis and degli which is part of (Italian) author names\n                \"[. ](\u00d7?\\\"?(?!\" + AUTHOR_SUFFIX + \"\\\\b)\" + EPITHET + \"\\\"?)\" +\n                \")?\" +\n              \")?\" +\n\n             \"(?: \" +\n               // #11 microbial rank\n               \"(\" + RANK_MARKER_MICROBIAL + \")[ .]\" +\n               // #12 microbial infrasubspecific epithet\n               \"(\\\\S+)\" +\n             \")?\" +\n\n             // #13 indet rank marker after epithets\n             \"([. ]\" + RANK_MARKER + \")?\" +\n\n             // #14 entire authorship incl basionyms and year\n             \"([., ]?\" +\n               \"(?:\\\\(\" +\n                 // #15/16/17 basionym authorship (ex/auth/sanct)\n                 \"(?:\" + AUTHORSHIP + \")?\" +\n                 // #18 basionym year\n                 \"[, ]?(\" + YEAR_LOOSE + \")?\" +\n               \"\\\\))?\" +\n\n               // #19/20/21 authorship (ex/auth/sanct)\n               \"(?:\" + AUTHORSHIP + \")?\" +\n               // #22 year with or without brackets\n               \"(?: ?\\\\(?,?(\" + YEAR_LOOSE + \")\\\\)?)?\" +\n             \")\" +\n\n             // #23 any remainder\n             \"(\\\\b.*?)??$\")", "var_name": "NAME_PATTERN"}, {"original_string": "final Rank rank;", "modifier": "final", "type": "Rank", "declarator": "rank", "var_name": "rank"}, {"original_string": "final String scientificName;", "modifier": "final", "type": "String", "declarator": "scientificName", "var_name": "scientificName"}, {"original_string": "final ParserConfigs configs;", "modifier": "final", "type": "ParserConfigs", "declarator": "configs", "var_name": "configs"}, {"original_string": "final ParsedName pn;", "modifier": "final", "type": "ParsedName", "declarator": "pn", "var_name": "pn"}, {"original_string": "boolean ignoreAuthorship;", "modifier": "", "type": "boolean", "declarator": "ignoreAuthorship", "var_name": "ignoreAuthorship"}, {"original_string": "String name;", "modifier": "", "type": "String", "declarator": "name", "var_name": "name"}, {"original_string": "ParsedName.State state;", "modifier": "", "type": "ParsedName.State", "declarator": "state", "var_name": "state"}], "methods": [{"identifier": "interruptableMatcher", "parameters": "(Pattern pattern, String text)", "modifiers": "static", "return": "Matcher", "signature": "Matcher interruptableMatcher(Pattern pattern, String text)", "full_signature": "static Matcher interruptableMatcher(Pattern pattern, String text)", "class_method_signature": "ParsingJob.interruptableMatcher(Pattern pattern, String text)", "testcase": false, "constructor": false}, {"identifier": "ParsingJob", "parameters": "(String scientificName, Rank rank, NomCode code, ParserConfigs configs)", "modifiers": "", "return": "", "signature": " ParsingJob(String scientificName, Rank rank, NomCode code, ParserConfigs configs)", "full_signature": "  ParsingJob(String scientificName, Rank rank, NomCode code, ParserConfigs configs)", "class_method_signature": "ParsingJob.ParsingJob(String scientificName, Rank rank, NomCode code, ParserConfigs configs)", "testcase": false, "constructor": true}, {"identifier": "unparsable", "parameters": "(NameType type)", "modifiers": "", "return": "void", "signature": "void unparsable(NameType type)", "full_signature": " void unparsable(NameType type)", "class_method_signature": "ParsingJob.unparsable(NameType type)", "testcase": false, "constructor": false}, {"identifier": "call", "parameters": "()", "modifiers": "@Override public", "return": "ParsedName", "signature": "ParsedName call()", "full_signature": "@Override public ParsedName call()", "class_method_signature": "ParsingJob.call()", "testcase": false, "constructor": false}, {"identifier": "stripNomRef", "parameters": "(Matcher m)", "modifiers": "private", "return": "String", "signature": "String stripNomRef(Matcher m)", "full_signature": "private String stripNomRef(Matcher m)", "class_method_signature": "ParsingJob.stripNomRef(Matcher m)", "testcase": false, "constructor": false}, {"identifier": "specialCases", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean specialCases()", "full_signature": "private boolean specialCases()", "class_method_signature": "ParsingJob.specialCases()", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "()", "modifiers": "", "return": "void", "signature": "void parse()", "full_signature": " void parse()", "class_method_signature": "ParsingJob.parse()", "testcase": false, "constructor": false}, {"identifier": "extractPublishedIn", "parameters": "()", "modifiers": "", "return": "void", "signature": "void extractPublishedIn()", "full_signature": " void extractPublishedIn()", "class_method_signature": "ParsingJob.extractPublishedIn()", "testcase": false, "constructor": false}, {"identifier": "detectFurtherUnparsableNames", "parameters": "()", "modifiers": "", "return": "void", "signature": "void detectFurtherUnparsableNames()", "full_signature": " void detectFurtherUnparsableNames()", "class_method_signature": "ParsingJob.detectFurtherUnparsableNames()", "testcase": false, "constructor": false}, {"identifier": "preparseNomRef", "parameters": "()", "modifiers": "", "return": "void", "signature": "void preparseNomRef()", "full_signature": " void preparseNomRef()", "class_method_signature": "ParsingJob.preparseNomRef()", "testcase": false, "constructor": false}, {"identifier": "removePlaceholderAuthor", "parameters": "()", "modifiers": "", "return": "void", "signature": "void removePlaceholderAuthor()", "full_signature": " void removePlaceholderAuthor()", "class_method_signature": "ParsingJob.removePlaceholderAuthor()", "testcase": false, "constructor": false}, {"identifier": "extractSecReference", "parameters": "()", "modifiers": "", "return": "void", "signature": "void extractSecReference()", "full_signature": " void extractSecReference()", "class_method_signature": "ParsingJob.extractSecReference()", "testcase": false, "constructor": false}, {"identifier": "extractNomStatus", "parameters": "()", "modifiers": "", "return": "void", "signature": "void extractNomStatus()", "full_signature": " void extractNomStatus()", "class_method_signature": "ParsingJob.extractNomStatus()", "testcase": false, "constructor": false}, {"identifier": "lowerCaseFirstChar", "parameters": "(String x)", "modifiers": "private static", "return": "String", "signature": "String lowerCaseFirstChar(String x)", "full_signature": "private static String lowerCaseFirstChar(String x)", "class_method_signature": "ParsingJob.lowerCaseFirstChar(String x)", "testcase": false, "constructor": false}, {"identifier": "concat", "parameters": "(String... x)", "modifiers": "private static", "return": "String", "signature": "String concat(String... x)", "full_signature": "private static String concat(String... x)", "class_method_signature": "ParsingJob.concat(String... x)", "testcase": false, "constructor": false}, {"identifier": "normNote", "parameters": "(String note)", "modifiers": "private static", "return": "String", "signature": "String normNote(String note)", "full_signature": "private static String normNote(String note)", "class_method_signature": "ParsingJob.normNote(String note)", "testcase": false, "constructor": false}, {"identifier": "normalize", "parameters": "(String name)", "modifiers": "@VisibleForTesting", "return": "String", "signature": "String normalize(String name)", "full_signature": "@VisibleForTesting String normalize(String name)", "class_method_signature": "ParsingJob.normalize(String name)", "testcase": false, "constructor": false}, {"identifier": "normalizeHort", "parameters": "(String name)", "modifiers": "", "return": "String", "signature": "String normalizeHort(String name)", "full_signature": " String normalizeHort(String name)", "class_method_signature": "ParsingJob.normalizeHort(String name)", "testcase": false, "constructor": false}, {"identifier": "normalizeStrong", "parameters": "(String name)", "modifiers": "@VisibleForTesting", "return": "String", "signature": "String normalizeStrong(String name)", "full_signature": "@VisibleForTesting String normalizeStrong(String name)", "class_method_signature": "ParsingJob.normalizeStrong(String name)", "testcase": false, "constructor": false}, {"identifier": "normWsPunct", "parameters": "(String name)", "modifiers": "", "return": "String", "signature": "String normWsPunct(String name)", "full_signature": " String normWsPunct(String name)", "class_method_signature": "ParsingJob.normWsPunct(String name)", "testcase": false, "constructor": false}, {"identifier": "normBrackets", "parameters": "(String name)", "modifiers": "", "return": "String", "signature": "String normBrackets(String name)", "full_signature": " String normBrackets(String name)", "class_method_signature": "ParsingJob.normBrackets(String name)", "testcase": false, "constructor": false}, {"identifier": "noQMarks", "parameters": "(String name)", "modifiers": "", "return": "String", "signature": "String noQMarks(String name)", "full_signature": " String noQMarks(String name)", "class_method_signature": "ParsingJob.noQMarks(String name)", "testcase": false, "constructor": false}, {"identifier": "preClean", "parameters": "(String name)", "modifiers": "@VisibleForTesting", "return": "String", "signature": "String preClean(String name)", "full_signature": "@VisibleForTesting String preClean(String name)", "class_method_signature": "ParsingJob.preClean(String name)", "testcase": false, "constructor": false}, {"identifier": "preClean", "parameters": "(String name, @Nullable Set<String> warnings)", "modifiers": "public static", "return": "String", "signature": "String preClean(String name, @Nullable Set<String> warnings)", "full_signature": "public static String preClean(String name, @Nullable Set<String> warnings)", "class_method_signature": "ParsingJob.preClean(String name, @Nullable Set<String> warnings)", "testcase": false, "constructor": false}, {"identifier": "setTypeIfNull", "parameters": "(ParsedName pn, NameType type)", "modifiers": "private", "return": "void", "signature": "void setTypeIfNull(ParsedName pn, NameType type)", "full_signature": "private void setTypeIfNull(ParsedName pn, NameType type)", "class_method_signature": "ParsingJob.setTypeIfNull(ParsedName pn, NameType type)", "testcase": false, "constructor": false}, {"identifier": "determineNameType", "parameters": "(String normedName)", "modifiers": "private", "return": "void", "signature": "void determineNameType(String normedName)", "full_signature": "private void determineNameType(String normedName)", "class_method_signature": "ParsingJob.determineNameType(String normedName)", "testcase": false, "constructor": false}, {"identifier": "checkBlacklist", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void checkBlacklist()", "full_signature": "private void checkBlacklist()", "class_method_signature": "ParsingJob.checkBlacklist()", "testcase": false, "constructor": false}, {"identifier": "applyDoubtfulFlag", "parameters": "(String scientificName)", "modifiers": "private", "return": "void", "signature": "void applyDoubtfulFlag(String scientificName)", "full_signature": "private void applyDoubtfulFlag(String scientificName)", "class_method_signature": "ParsingJob.applyDoubtfulFlag(String scientificName)", "testcase": false, "constructor": false}, {"identifier": "determineRank", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void determineRank()", "full_signature": "private void determineRank()", "class_method_signature": "ParsingJob.determineRank()", "testcase": false, "constructor": false}, {"identifier": "determineCode", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void determineCode()", "full_signature": "private void determineCode()", "class_method_signature": "ParsingJob.determineCode()", "testcase": false, "constructor": false}, {"identifier": "parseNormalisedName", "parameters": "(String name)", "modifiers": "private", "return": "boolean", "signature": "boolean parseNormalisedName(String name)", "full_signature": "private boolean parseNormalisedName(String name)", "class_method_signature": "ParsingJob.parseNormalisedName(String name)", "testcase": false, "constructor": false}, {"identifier": "setEpithetQualifier", "parameters": "(NamePart part, String qualifier)", "modifiers": "private", "return": "void", "signature": "void setEpithetQualifier(NamePart part, String qualifier)", "full_signature": "private void setEpithetQualifier(NamePart part, String qualifier)", "class_method_signature": "ParsingJob.setEpithetQualifier(NamePart part, String qualifier)", "testcase": false, "constructor": false}, {"identifier": "cleanYear", "parameters": "(String matchedYear)", "modifiers": "private static", "return": "String", "signature": "String cleanYear(String matchedYear)", "full_signature": "private static String cleanYear(String matchedYear)", "class_method_signature": "ParsingJob.cleanYear(String matchedYear)", "testcase": false, "constructor": false}, {"identifier": "setRank", "parameters": "(String rankMarker)", "modifiers": "private", "return": "void", "signature": "void setRank(String rankMarker)", "full_signature": "private void setRank(String rankMarker)", "class_method_signature": "ParsingJob.setRank(String rankMarker)", "testcase": false, "constructor": false}, {"identifier": "setRank", "parameters": "(String rankMarker, boolean force)", "modifiers": "private", "return": "void", "signature": "void setRank(String rankMarker, boolean force)", "full_signature": "private void setRank(String rankMarker, boolean force)", "class_method_signature": "ParsingJob.setRank(String rankMarker, boolean force)", "testcase": false, "constructor": false}, {"identifier": "setRankIfNotContradicting", "parameters": "(Rank rank)", "modifiers": "private", "return": "void", "signature": "void setRankIfNotContradicting(Rank rank)", "full_signature": "private void setRankIfNotContradicting(Rank rank)", "class_method_signature": "ParsingJob.setRankIfNotContradicting(Rank rank)", "testcase": false, "constructor": false}, {"identifier": "parseRank", "parameters": "(String rankMarker)", "modifiers": "private static", "return": "Rank", "signature": "Rank parseRank(String rankMarker)", "full_signature": "private static Rank parseRank(String rankMarker)", "class_method_signature": "ParsingJob.parseRank(String rankMarker)", "testcase": false, "constructor": false}, {"identifier": "infragenericIsAuthor", "parameters": "(ParsedName pn)", "modifiers": "private static", "return": "boolean", "signature": "boolean infragenericIsAuthor(ParsedName pn)", "full_signature": "private static boolean infragenericIsAuthor(ParsedName pn)", "class_method_signature": "ParsingJob.infragenericIsAuthor(ParsedName pn)", "testcase": false, "constructor": false}, {"identifier": "setUninomialOrGenus", "parameters": "(Matcher matcher, ParsedName pn)", "modifiers": "private", "return": "void", "signature": "void setUninomialOrGenus(Matcher matcher, ParsedName pn)", "full_signature": "private void setUninomialOrGenus(Matcher matcher, ParsedName pn)", "class_method_signature": "ParsingJob.setUninomialOrGenus(Matcher matcher, ParsedName pn)", "testcase": false, "constructor": false}, {"identifier": "lookForIrregularRankMarker", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void lookForIrregularRankMarker()", "full_signature": "private void lookForIrregularRankMarker()", "class_method_signature": "ParsingJob.lookForIrregularRankMarker()", "testcase": false, "constructor": false}, {"identifier": "parseAuthorship", "parameters": "(String ex, String authors, String year)", "modifiers": "@VisibleForTesting static", "return": "Authorship", "signature": "Authorship parseAuthorship(String ex, String authors, String year)", "full_signature": "@VisibleForTesting static Authorship parseAuthorship(String ex, String authors, String year)", "class_method_signature": "ParsingJob.parseAuthorship(String ex, String authors, String year)", "testcase": false, "constructor": false}, {"identifier": "splitTeam", "parameters": "(String team)", "modifiers": "private static", "return": "List<String>", "signature": "List<String> splitTeam(String team)", "full_signature": "private static List<String> splitTeam(String team)", "class_method_signature": "ParsingJob.splitTeam(String team)", "testcase": false, "constructor": false}, {"identifier": "sanitizeAuthors", "parameters": "(List<String> tokens)", "modifiers": "private static", "return": "List<String>", "signature": "List<String> sanitizeAuthors(List<String> tokens)", "full_signature": "private static List<String> sanitizeAuthors(List<String> tokens)", "class_method_signature": "ParsingJob.sanitizeAuthors(List<String> tokens)", "testcase": false, "constructor": false}, {"identifier": "normInitials", "parameters": "(String initials)", "modifiers": "private static", "return": "String", "signature": "String normInitials(String initials)", "full_signature": "private static String normInitials(String initials)", "class_method_signature": "ParsingJob.normInitials(String initials)", "testcase": false, "constructor": false}, {"identifier": "normAuthor", "parameters": "(String authors, boolean normPunctuation)", "modifiers": "private static", "return": "String", "signature": "String normAuthor(String authors, boolean normPunctuation)", "full_signature": "private static String normAuthor(String authors, boolean normPunctuation)", "class_method_signature": "ParsingJob.normAuthor(String authors, boolean normPunctuation)", "testcase": false, "constructor": false}, {"identifier": "logMatcher", "parameters": "(Matcher matcher)", "modifiers": "static", "return": "void", "signature": "void logMatcher(Matcher matcher)", "full_signature": "static void logMatcher(Matcher matcher)", "class_method_signature": "ParsingJob.logMatcher(Matcher matcher)", "testcase": false, "constructor": false}], "file": "name-parser/src/main/java/org/gbif/nameparser/ParsingJob.java"}, "focal_method": {"identifier": "preClean", "parameters": "(String name)", "modifiers": "@VisibleForTesting", "return": "String", "body": "@VisibleForTesting\n  String preClean(String name) {\n    return preClean(name, pn.getWarnings());\n  }", "signature": "String preClean(String name)", "full_signature": "@VisibleForTesting String preClean(String name)", "class_method_signature": "ParsingJob.preClean(String name)", "testcase": false, "constructor": false, "invocations": ["preClean", "getWarnings"]}, "repository": {"repo_id": 16201889, "url": "https://github.com/gbif/name-parser", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 11, "size": 1978, "license": "licensed"}}