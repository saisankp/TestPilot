{"test_class": {"identifier": "BTreeMapTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "Engine engine = new StorageDirect(Volume.memoryFactory(false));", "modifier": "", "type": "Engine", "declarator": "engine = new StorageDirect(Volume.memoryFactory(false))", "var_name": "engine"}], "file": "migration/third-party/org.mapdb/src/test/java/org/mapdb/BTreeMapTest.java"}, "test_case": {"identifier": "test_next_dir_infinity", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void test_next_dir_infinity(){\n        BTreeMap m = new BTreeMap(engine,32,true,false, null,null,null,null);\n        BTreeMap.DirNode d = new BTreeMap.DirNode(\n                new Object[]{null,62,68, 71},\n                new long[]{10,20,30,40});\n        assertEquals(10, m.nextDir(d, 33));\n        assertEquals(10, m.nextDir(d, 62));\n        assertEquals(20, m.nextDir(d, 63));\n\n        d = new BTreeMap.DirNode(\n                new Object[]{44,62,68, null},\n                new long[]{10,20,30,40});\n\n        assertEquals(10, m.nextDir(d, 62));\n        assertEquals(10, m.nextDir(d, 44));\n        assertEquals(10, m.nextDir(d, 48));\n\n        assertEquals(20, m.nextDir(d, 63));\n        assertEquals(20, m.nextDir(d, 64));\n        assertEquals(20, m.nextDir(d, 68));\n\n        assertEquals(30, m.nextDir(d, 69));\n        assertEquals(30, m.nextDir(d, 70));\n        assertEquals(30, m.nextDir(d, 71));\n\n        assertEquals(30, m.nextDir(d, 72));\n        assertEquals(30, m.nextDir(d, 73));\n\n    }", "signature": "void test_next_dir_infinity()", "full_signature": "@Test public void test_next_dir_infinity()", "class_method_signature": "BTreeMapTest.test_next_dir_infinity()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir", "assertEquals", "nextDir"]}, "focal_class": {"identifier": "BTreeMap", "superclass": "extends AbstractMap<K,V>", "interfaces": "implements ConcurrentNavigableMap<K,V>, Bind.MapWithModificationListener<K,V>", "fields": [{"original_string": "protected static final int DEFAULT_MAX_NODE_SIZE = 32;", "modifier": "protected static final", "type": "int", "declarator": "DEFAULT_MAX_NODE_SIZE = 32", "var_name": "DEFAULT_MAX_NODE_SIZE"}, {"original_string": "protected final long rootRecidRef;", "modifier": "protected final", "type": "long", "declarator": "rootRecidRef", "var_name": "rootRecidRef"}, {"original_string": "protected final BTreeKeySerializer keySerializer;", "modifier": "protected final", "type": "BTreeKeySerializer", "declarator": "keySerializer", "var_name": "keySerializer"}, {"original_string": "protected final Serializer<V> valueSerializer;", "modifier": "protected final", "type": "Serializer<V>", "declarator": "valueSerializer", "var_name": "valueSerializer"}, {"original_string": "protected final Comparator comparator;", "modifier": "protected final", "type": "Comparator", "declarator": "comparator", "var_name": "comparator"}, {"original_string": "protected final Locks.RecidLocks nodeLocks = new Locks.LongHashMapRecidLocks();", "modifier": "protected final", "type": "Locks.RecidLocks", "declarator": "nodeLocks = new Locks.LongHashMapRecidLocks()", "var_name": "nodeLocks"}, {"original_string": "protected final int maxNodeSize;", "modifier": "protected final", "type": "int", "declarator": "maxNodeSize", "var_name": "maxNodeSize"}, {"original_string": "protected final Engine engine;", "modifier": "protected final", "type": "Engine", "declarator": "engine", "var_name": "engine"}, {"original_string": "protected final boolean hasValues;", "modifier": "protected final", "type": "boolean", "declarator": "hasValues", "var_name": "hasValues"}, {"original_string": "protected final boolean valsOutsideNodes;", "modifier": "protected final", "type": "boolean", "declarator": "valsOutsideNodes", "var_name": "valsOutsideNodes"}, {"original_string": "protected final long treeRecid;", "modifier": "protected final", "type": "long", "declarator": "treeRecid", "var_name": "treeRecid"}, {"original_string": "private final KeySet keySet;", "modifier": "private final", "type": "KeySet", "declarator": "keySet", "var_name": "keySet"}, {"original_string": "private final EntrySet entrySet = new EntrySet(this);", "modifier": "private final", "type": "EntrySet", "declarator": "entrySet = new EntrySet(this)", "var_name": "entrySet"}, {"original_string": "private final Values values = new Values(this);", "modifier": "private final", "type": "Values", "declarator": "values = new Values(this)", "var_name": "values"}, {"original_string": "protected final Serializer defaultSerializer;", "modifier": "protected final", "type": "Serializer", "declarator": "defaultSerializer", "var_name": "defaultSerializer"}, {"original_string": "protected final Serializer<BNode> nodeSerializer = new Serializer<BNode>() {\n        @Override\n        public void serialize(DataOutput out, BNode value) throws IOException {\n            final boolean isLeaf = value.isLeaf();\n\n            //first byte encodes if is leaf (first bite) and length (last seven bites)\n            if(value.keys().length>255) throw new InternalError();\n            if(!isLeaf && value.child().length!= value.keys().length) throw new InternalError();\n            if(isLeaf && hasValues && value.vals().length!= value.keys().length) throw new InternalError();\n\n            //check node integrity in paranoid mode\n            if(CC.PARANOID){\n                int len = value.keys().length;\n                for(int i=value.keys()[0]==null?2:1;\n                  i<(value.keys()[len-1]==null?len-1:len);\n                  i++){\n                    int comp = comparator.compare(value.keys()[i-1], value.keys()[i]);\n                    int limit = i==len-1 ? 1:0 ;\n                    if(comp>=limit){\n                        throw new AssertionError(\"BTreeNode format error, wrong key order at #\"+i+\"\\n\"+value);\n                    }\n                }\n\n            }\n\n\n            final boolean left = value.keys()[0] == null;\n            final boolean right = value.keys()[value.keys().length-1] == null;\n\n\n            final int header;\n\n            if(isLeaf)\n                if(right){\n                    if(left)\n                        header = B_TREE_NODE_LEAF_LR;\n                    else\n                        header = B_TREE_NODE_LEAF_R;\n                }else{\n                    if(left)\n                        header = B_TREE_NODE_LEAF_L;\n                    else\n                        header = B_TREE_NODE_LEAF_C;\n                }\n            else{\n                if(right){\n                    if(left)\n                        header = B_TREE_NODE_DIR_LR;\n                    else\n                        header = B_TREE_NODE_DIR_R;\n                }else{\n                    if(left)\n                        header = B_TREE_NODE_DIR_L;\n                    else\n                        header = B_TREE_NODE_DIR_C;\n                }\n            }\n\n\n\n            out.write(header);\n            out.write(value.keys().length);\n\n            //longs go first, so it is possible to reconstruct tree without serializer\n            if(isLeaf){\n                Utils.packLong(out, ((LeafNode) value).next);\n            }else{\n                for(long child : ((DirNode)value).child)\n                    Utils.packLong(out, child);\n            }\n\n\n\n            keySerializer.serialize(out,left?1:0,\n                    right?value.keys().length-1:value.keys().length,\n                    value.keys());\n\n            if(isLeaf && hasValues){\n                for(int i=0; i<value.vals().length; i++){\n                    Object val = value.vals()[i];\n                    if(valsOutsideNodes){\n                        long recid = val!=null?  ((ValRef)val).recid :0;\n                        Utils.packLong(out, recid);\n                    }else{\n                        valueSerializer.serialize(out, (V) val);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public BNode deserialize(DataInput in, int available) throws IOException {\n            final int header = in.readUnsignedByte();\n            final int size = in.readUnsignedByte();\n            //first bite indicates leaf\n            final boolean isLeaf =\n                    header == B_TREE_NODE_LEAF_C  || header == B_TREE_NODE_LEAF_L ||\n                    header == B_TREE_NODE_LEAF_LR || header == B_TREE_NODE_LEAF_R;\n            final int start =\n                (header==B_TREE_NODE_LEAF_L  || header == B_TREE_NODE_LEAF_LR || header==B_TREE_NODE_DIR_L  || header == B_TREE_NODE_DIR_LR) ?\n                1:0;\n\n            final int end =\n                (header==B_TREE_NODE_LEAF_R  || header == B_TREE_NODE_LEAF_LR || header==B_TREE_NODE_DIR_R  || header == B_TREE_NODE_DIR_LR) ?\n                size-1:size;\n\n\n            if(isLeaf){\n                long next = Utils.unpackLong(in);\n                Object[] keys = (Object[]) keySerializer.deserialize(in, start,end,size);\n                if(keys.length!=size) throw new InternalError();\n                Object[] vals  = null;\n\n                if(hasValues){\n                    vals = new Object[size];\n                    for(int i=0;i<size;i++){\n                        if(valsOutsideNodes){\n                            long recid = Utils.unpackLong(in);\n                            vals[i] = recid==0? null: new ValRef(recid);\n                        }else{\n                            vals[i] = valueSerializer.deserialize(in, size-1);\n                        }\n                    }\n                }\n                return new LeafNode(keys, vals, next);\n            }else{\n                long[] child = new long[size];\n                for(int i=0;i<size;i++)\n                    child[i] = Utils.unpackLong(in);\n                Object[] keys = (Object[]) keySerializer.deserialize(in, start,end,size);\n                if(keys.length!=size) throw new InternalError();\n                return new DirNode(keys, child);\n            }\n        }\n    };", "modifier": "protected final", "type": "Serializer<BNode>", "declarator": "nodeSerializer = new Serializer<BNode>() {\n        @Override\n        public void serialize(DataOutput out, BNode value) throws IOException {\n            final boolean isLeaf = value.isLeaf();\n\n            //first byte encodes if is leaf (first bite) and length (last seven bites)\n            if(value.keys().length>255) throw new InternalError();\n            if(!isLeaf && value.child().length!= value.keys().length) throw new InternalError();\n            if(isLeaf && hasValues && value.vals().length!= value.keys().length) throw new InternalError();\n\n            //check node integrity in paranoid mode\n            if(CC.PARANOID){\n                int len = value.keys().length;\n                for(int i=value.keys()[0]==null?2:1;\n                  i<(value.keys()[len-1]==null?len-1:len);\n                  i++){\n                    int comp = comparator.compare(value.keys()[i-1], value.keys()[i]);\n                    int limit = i==len-1 ? 1:0 ;\n                    if(comp>=limit){\n                        throw new AssertionError(\"BTreeNode format error, wrong key order at #\"+i+\"\\n\"+value);\n                    }\n                }\n\n            }\n\n\n            final boolean left = value.keys()[0] == null;\n            final boolean right = value.keys()[value.keys().length-1] == null;\n\n\n            final int header;\n\n            if(isLeaf)\n                if(right){\n                    if(left)\n                        header = B_TREE_NODE_LEAF_LR;\n                    else\n                        header = B_TREE_NODE_LEAF_R;\n                }else{\n                    if(left)\n                        header = B_TREE_NODE_LEAF_L;\n                    else\n                        header = B_TREE_NODE_LEAF_C;\n                }\n            else{\n                if(right){\n                    if(left)\n                        header = B_TREE_NODE_DIR_LR;\n                    else\n                        header = B_TREE_NODE_DIR_R;\n                }else{\n                    if(left)\n                        header = B_TREE_NODE_DIR_L;\n                    else\n                        header = B_TREE_NODE_DIR_C;\n                }\n            }\n\n\n\n            out.write(header);\n            out.write(value.keys().length);\n\n            //longs go first, so it is possible to reconstruct tree without serializer\n            if(isLeaf){\n                Utils.packLong(out, ((LeafNode) value).next);\n            }else{\n                for(long child : ((DirNode)value).child)\n                    Utils.packLong(out, child);\n            }\n\n\n\n            keySerializer.serialize(out,left?1:0,\n                    right?value.keys().length-1:value.keys().length,\n                    value.keys());\n\n            if(isLeaf && hasValues){\n                for(int i=0; i<value.vals().length; i++){\n                    Object val = value.vals()[i];\n                    if(valsOutsideNodes){\n                        long recid = val!=null?  ((ValRef)val).recid :0;\n                        Utils.packLong(out, recid);\n                    }else{\n                        valueSerializer.serialize(out, (V) val);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public BNode deserialize(DataInput in, int available) throws IOException {\n            final int header = in.readUnsignedByte();\n            final int size = in.readUnsignedByte();\n            //first bite indicates leaf\n            final boolean isLeaf =\n                    header == B_TREE_NODE_LEAF_C  || header == B_TREE_NODE_LEAF_L ||\n                    header == B_TREE_NODE_LEAF_LR || header == B_TREE_NODE_LEAF_R;\n            final int start =\n                (header==B_TREE_NODE_LEAF_L  || header == B_TREE_NODE_LEAF_LR || header==B_TREE_NODE_DIR_L  || header == B_TREE_NODE_DIR_LR) ?\n                1:0;\n\n            final int end =\n                (header==B_TREE_NODE_LEAF_R  || header == B_TREE_NODE_LEAF_LR || header==B_TREE_NODE_DIR_R  || header == B_TREE_NODE_DIR_LR) ?\n                size-1:size;\n\n\n            if(isLeaf){\n                long next = Utils.unpackLong(in);\n                Object[] keys = (Object[]) keySerializer.deserialize(in, start,end,size);\n                if(keys.length!=size) throw new InternalError();\n                Object[] vals  = null;\n\n                if(hasValues){\n                    vals = new Object[size];\n                    for(int i=0;i<size;i++){\n                        if(valsOutsideNodes){\n                            long recid = Utils.unpackLong(in);\n                            vals[i] = recid==0? null: new ValRef(recid);\n                        }else{\n                            vals[i] = valueSerializer.deserialize(in, size-1);\n                        }\n                    }\n                }\n                return new LeafNode(keys, vals, next);\n            }else{\n                long[] child = new long[size];\n                for(int i=0;i<size;i++)\n                    child[i] = Utils.unpackLong(in);\n                Object[] keys = (Object[]) keySerializer.deserialize(in, start,end,size);\n                if(keys.length!=size) throw new InternalError();\n                return new DirNode(keys, child);\n            }\n        }\n    }", "var_name": "nodeSerializer"}, {"original_string": "protected final Object modListenersLock = new Object();", "modifier": "protected final", "type": "Object", "declarator": "modListenersLock = new Object()", "var_name": "modListenersLock"}, {"original_string": "protected Bind.MapListener<K,V>[] modListeners = new Bind.MapListener[0];", "modifier": "protected", "type": "Bind.MapListener<K,V>[]", "declarator": "modListeners = new Bind.MapListener[0]", "var_name": "modListeners"}], "methods": [{"identifier": "BTreeMap", "parameters": "(Engine engine, int maxNodeSize, boolean hasValues, boolean valsOutsideNodes,\n                    Serializer defaultSerializer,\n                    BTreeKeySerializer<K> keySerializer, Serializer<V> valueSerializer, Comparator<K> comparator)", "modifiers": "public", "return": "", "signature": " BTreeMap(Engine engine, int maxNodeSize, boolean hasValues, boolean valsOutsideNodes,\n                    Serializer defaultSerializer,\n                    BTreeKeySerializer<K> keySerializer, Serializer<V> valueSerializer, Comparator<K> comparator)", "full_signature": "public  BTreeMap(Engine engine, int maxNodeSize, boolean hasValues, boolean valsOutsideNodes,\n                    Serializer defaultSerializer,\n                    BTreeKeySerializer<K> keySerializer, Serializer<V> valueSerializer, Comparator<K> comparator)", "class_method_signature": "BTreeMap.BTreeMap(Engine engine, int maxNodeSize, boolean hasValues, boolean valsOutsideNodes,\n                    Serializer defaultSerializer,\n                    BTreeKeySerializer<K> keySerializer, Serializer<V> valueSerializer, Comparator<K> comparator)", "testcase": false, "constructor": true}, {"identifier": "BTreeMap", "parameters": "(Engine engine, long recid, Serializer defaultSerializer)", "modifiers": "public", "return": "", "signature": " BTreeMap(Engine engine, long recid, Serializer defaultSerializer)", "full_signature": "public  BTreeMap(Engine engine, long recid, Serializer defaultSerializer)", "class_method_signature": "BTreeMap.BTreeMap(Engine engine, long recid, Serializer defaultSerializer)", "testcase": false, "constructor": true}, {"identifier": "findChildren", "parameters": "(final Object key, final Object[] keys)", "modifiers": "protected final", "return": "int", "signature": "int findChildren(final Object key, final Object[] keys)", "full_signature": "protected final int findChildren(final Object key, final Object[] keys)", "class_method_signature": "BTreeMap.findChildren(final Object key, final Object[] keys)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(Object key)", "modifiers": "@Override public", "return": "V", "signature": "V get(Object key)", "full_signature": "@Override public V get(Object key)", "class_method_signature": "BTreeMap.get(Object key)", "testcase": false, "constructor": false}, {"identifier": "valExpand", "parameters": "(Object ret)", "modifiers": "protected", "return": "V", "signature": "V valExpand(Object ret)", "full_signature": "protected V valExpand(Object ret)", "class_method_signature": "BTreeMap.valExpand(Object ret)", "testcase": false, "constructor": false}, {"identifier": "nextDir", "parameters": "(DirNode d, Object key)", "modifiers": "protected", "return": "long", "signature": "long nextDir(DirNode d, Object key)", "full_signature": "protected long nextDir(DirNode d, Object key)", "class_method_signature": "BTreeMap.nextDir(DirNode d, Object key)", "testcase": false, "constructor": false}, {"identifier": "put", "parameters": "(K key, V value)", "modifiers": "@Override public", "return": "V", "signature": "V put(K key, V value)", "full_signature": "@Override public V put(K key, V value)", "class_method_signature": "BTreeMap.put(K key, V value)", "testcase": false, "constructor": false}, {"identifier": "put2", "parameters": "(K v, V value2, final boolean putOnlyIfAbsent)", "modifiers": "protected", "return": "V", "signature": "V put2(K v, V value2, final boolean putOnlyIfAbsent)", "full_signature": "protected V put2(K v, V value2, final boolean putOnlyIfAbsent)", "class_method_signature": "BTreeMap.put2(K v, V value2, final boolean putOnlyIfAbsent)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(Object key)", "modifiers": "@Override public", "return": "V", "signature": "V remove(Object key)", "full_signature": "@Override public V remove(Object key)", "class_method_signature": "BTreeMap.remove(Object key)", "testcase": false, "constructor": false}, {"identifier": "remove2", "parameters": "(Object key, Object value)", "modifiers": "private", "return": "V", "signature": "V remove2(Object key, Object value)", "full_signature": "private V remove2(Object key, Object value)", "class_method_signature": "BTreeMap.remove2(Object key, Object value)", "testcase": false, "constructor": false}, {"identifier": "clear", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void clear()", "full_signature": "@Override public void clear()", "class_method_signature": "BTreeMap.clear()", "testcase": false, "constructor": false}, {"identifier": "makeEntry", "parameters": "(Object key, Object value)", "modifiers": "protected", "return": "Entry<K, V>", "signature": "Entry<K, V> makeEntry(Object key, Object value)", "full_signature": "protected Entry<K, V> makeEntry(Object key, Object value)", "class_method_signature": "BTreeMap.makeEntry(Object key, Object value)", "testcase": false, "constructor": false}, {"identifier": "isEmpty", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isEmpty()", "full_signature": "@Override public boolean isEmpty()", "class_method_signature": "BTreeMap.isEmpty()", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int size()", "full_signature": "@Override public int size()", "class_method_signature": "BTreeMap.size()", "testcase": false, "constructor": false}, {"identifier": "putIfAbsent", "parameters": "(K key, V value)", "modifiers": "@Override public", "return": "V", "signature": "V putIfAbsent(K key, V value)", "full_signature": "@Override public V putIfAbsent(K key, V value)", "class_method_signature": "BTreeMap.putIfAbsent(K key, V value)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(Object key, Object value)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean remove(Object key, Object value)", "full_signature": "@Override public boolean remove(Object key, Object value)", "class_method_signature": "BTreeMap.remove(Object key, Object value)", "testcase": false, "constructor": false}, {"identifier": "replace", "parameters": "(K key, V oldValue, V newValue)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean replace(K key, V oldValue, V newValue)", "full_signature": "@Override public boolean replace(K key, V oldValue, V newValue)", "class_method_signature": "BTreeMap.replace(K key, V oldValue, V newValue)", "testcase": false, "constructor": false}, {"identifier": "replace", "parameters": "(K key, V value)", "modifiers": "@Override public", "return": "V", "signature": "V replace(K key, V value)", "full_signature": "@Override public V replace(K key, V value)", "class_method_signature": "BTreeMap.replace(K key, V value)", "testcase": false, "constructor": false}, {"identifier": "comparator", "parameters": "()", "modifiers": "@Override public", "return": "Comparator<? super K>", "signature": "Comparator<? super K> comparator()", "full_signature": "@Override public Comparator<? super K> comparator()", "class_method_signature": "BTreeMap.comparator()", "testcase": false, "constructor": false}, {"identifier": "firstEntry", "parameters": "()", "modifiers": "@Override public", "return": "Map.Entry<K,V>", "signature": "Map.Entry<K,V> firstEntry()", "full_signature": "@Override public Map.Entry<K,V> firstEntry()", "class_method_signature": "BTreeMap.firstEntry()", "testcase": false, "constructor": false}, {"identifier": "pollFirstEntry", "parameters": "()", "modifiers": "@Override public", "return": "Entry<K, V>", "signature": "Entry<K, V> pollFirstEntry()", "full_signature": "@Override public Entry<K, V> pollFirstEntry()", "class_method_signature": "BTreeMap.pollFirstEntry()", "testcase": false, "constructor": false}, {"identifier": "pollLastEntry", "parameters": "()", "modifiers": "@Override public", "return": "Entry<K, V>", "signature": "Entry<K, V> pollLastEntry()", "full_signature": "@Override public Entry<K, V> pollLastEntry()", "class_method_signature": "BTreeMap.pollLastEntry()", "testcase": false, "constructor": false}, {"identifier": "findSmaller", "parameters": "(K key,boolean inclusive)", "modifiers": "protected", "return": "Entry<K,V>", "signature": "Entry<K,V> findSmaller(K key,boolean inclusive)", "full_signature": "protected Entry<K,V> findSmaller(K key,boolean inclusive)", "class_method_signature": "BTreeMap.findSmaller(K key,boolean inclusive)", "testcase": false, "constructor": false}, {"identifier": "findSmallerRecur", "parameters": "(BNode n, K key, boolean inclusive)", "modifiers": "private", "return": "Entry<K, V>", "signature": "Entry<K, V> findSmallerRecur(BNode n, K key, boolean inclusive)", "full_signature": "private Entry<K, V> findSmallerRecur(BNode n, K key, boolean inclusive)", "class_method_signature": "BTreeMap.findSmallerRecur(BNode n, K key, boolean inclusive)", "testcase": false, "constructor": false}, {"identifier": "lastEntry", "parameters": "()", "modifiers": "@Override public", "return": "Map.Entry<K,V>", "signature": "Map.Entry<K,V> lastEntry()", "full_signature": "@Override public Map.Entry<K,V> lastEntry()", "class_method_signature": "BTreeMap.lastEntry()", "testcase": false, "constructor": false}, {"identifier": "lastEntryRecur", "parameters": "(BNode n)", "modifiers": "private", "return": "Map.Entry<K,V>", "signature": "Map.Entry<K,V> lastEntryRecur(BNode n)", "full_signature": "private Map.Entry<K,V> lastEntryRecur(BNode n)", "class_method_signature": "BTreeMap.lastEntryRecur(BNode n)", "testcase": false, "constructor": false}, {"identifier": "lowerEntry", "parameters": "(K key)", "modifiers": "@Override public", "return": "Map.Entry<K,V>", "signature": "Map.Entry<K,V> lowerEntry(K key)", "full_signature": "@Override public Map.Entry<K,V> lowerEntry(K key)", "class_method_signature": "BTreeMap.lowerEntry(K key)", "testcase": false, "constructor": false}, {"identifier": "lowerKey", "parameters": "(K key)", "modifiers": "@Override public", "return": "K", "signature": "K lowerKey(K key)", "full_signature": "@Override public K lowerKey(K key)", "class_method_signature": "BTreeMap.lowerKey(K key)", "testcase": false, "constructor": false}, {"identifier": "floorEntry", "parameters": "(K key)", "modifiers": "@Override public", "return": "Map.Entry<K,V>", "signature": "Map.Entry<K,V> floorEntry(K key)", "full_signature": "@Override public Map.Entry<K,V> floorEntry(K key)", "class_method_signature": "BTreeMap.floorEntry(K key)", "testcase": false, "constructor": false}, {"identifier": "floorKey", "parameters": "(K key)", "modifiers": "@Override public", "return": "K", "signature": "K floorKey(K key)", "full_signature": "@Override public K floorKey(K key)", "class_method_signature": "BTreeMap.floorKey(K key)", "testcase": false, "constructor": false}, {"identifier": "ceilingEntry", "parameters": "(K key)", "modifiers": "@Override public", "return": "Map.Entry<K,V>", "signature": "Map.Entry<K,V> ceilingEntry(K key)", "full_signature": "@Override public Map.Entry<K,V> ceilingEntry(K key)", "class_method_signature": "BTreeMap.ceilingEntry(K key)", "testcase": false, "constructor": false}, {"identifier": "findLarger", "parameters": "(K key, boolean inclusive)", "modifiers": "protected", "return": "Entry<K, V>", "signature": "Entry<K, V> findLarger(K key, boolean inclusive)", "full_signature": "protected Entry<K, V> findLarger(K key, boolean inclusive)", "class_method_signature": "BTreeMap.findLarger(K key, boolean inclusive)", "testcase": false, "constructor": false}, {"identifier": "ceilingKey", "parameters": "(K key)", "modifiers": "@Override public", "return": "K", "signature": "K ceilingKey(K key)", "full_signature": "@Override public K ceilingKey(K key)", "class_method_signature": "BTreeMap.ceilingKey(K key)", "testcase": false, "constructor": false}, {"identifier": "higherEntry", "parameters": "(K key)", "modifiers": "@Override public", "return": "Map.Entry<K,V>", "signature": "Map.Entry<K,V> higherEntry(K key)", "full_signature": "@Override public Map.Entry<K,V> higherEntry(K key)", "class_method_signature": "BTreeMap.higherEntry(K key)", "testcase": false, "constructor": false}, {"identifier": "higherKey", "parameters": "(K key)", "modifiers": "@Override public", "return": "K", "signature": "K higherKey(K key)", "full_signature": "@Override public K higherKey(K key)", "class_method_signature": "BTreeMap.higherKey(K key)", "testcase": false, "constructor": false}, {"identifier": "containsKey", "parameters": "(Object key)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean containsKey(Object key)", "full_signature": "@Override public boolean containsKey(Object key)", "class_method_signature": "BTreeMap.containsKey(Object key)", "testcase": false, "constructor": false}, {"identifier": "containsValue", "parameters": "(Object value)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean containsValue(Object value)", "full_signature": "@Override public boolean containsValue(Object value)", "class_method_signature": "BTreeMap.containsValue(Object value)", "testcase": false, "constructor": false}, {"identifier": "firstKey", "parameters": "()", "modifiers": "@Override public", "return": "K", "signature": "K firstKey()", "full_signature": "@Override public K firstKey()", "class_method_signature": "BTreeMap.firstKey()", "testcase": false, "constructor": false}, {"identifier": "lastKey", "parameters": "()", "modifiers": "@Override public", "return": "K", "signature": "K lastKey()", "full_signature": "@Override public K lastKey()", "class_method_signature": "BTreeMap.lastKey()", "testcase": false, "constructor": false}, {"identifier": "subMap", "parameters": "(K fromKey,\n                                              boolean fromInclusive,\n                                              K toKey,\n                                              boolean toInclusive)", "modifiers": "@Override public", "return": "ConcurrentNavigableMap<K,V>", "signature": "ConcurrentNavigableMap<K,V> subMap(K fromKey,\n                                              boolean fromInclusive,\n                                              K toKey,\n                                              boolean toInclusive)", "full_signature": "@Override public ConcurrentNavigableMap<K,V> subMap(K fromKey,\n                                              boolean fromInclusive,\n                                              K toKey,\n                                              boolean toInclusive)", "class_method_signature": "BTreeMap.subMap(K fromKey,\n                                              boolean fromInclusive,\n                                              K toKey,\n                                              boolean toInclusive)", "testcase": false, "constructor": false}, {"identifier": "headMap", "parameters": "(K toKey,\n                                               boolean inclusive)", "modifiers": "@Override public", "return": "ConcurrentNavigableMap<K,V>", "signature": "ConcurrentNavigableMap<K,V> headMap(K toKey,\n                                               boolean inclusive)", "full_signature": "@Override public ConcurrentNavigableMap<K,V> headMap(K toKey,\n                                               boolean inclusive)", "class_method_signature": "BTreeMap.headMap(K toKey,\n                                               boolean inclusive)", "testcase": false, "constructor": false}, {"identifier": "tailMap", "parameters": "(K fromKey,\n                                               boolean inclusive)", "modifiers": "@Override public", "return": "ConcurrentNavigableMap<K,V>", "signature": "ConcurrentNavigableMap<K,V> tailMap(K fromKey,\n                                               boolean inclusive)", "full_signature": "@Override public ConcurrentNavigableMap<K,V> tailMap(K fromKey,\n                                               boolean inclusive)", "class_method_signature": "BTreeMap.tailMap(K fromKey,\n                                               boolean inclusive)", "testcase": false, "constructor": false}, {"identifier": "subMap", "parameters": "(K fromKey, K toKey)", "modifiers": "@Override public", "return": "ConcurrentNavigableMap<K,V>", "signature": "ConcurrentNavigableMap<K,V> subMap(K fromKey, K toKey)", "full_signature": "@Override public ConcurrentNavigableMap<K,V> subMap(K fromKey, K toKey)", "class_method_signature": "BTreeMap.subMap(K fromKey, K toKey)", "testcase": false, "constructor": false}, {"identifier": "headMap", "parameters": "(K toKey)", "modifiers": "@Override public", "return": "ConcurrentNavigableMap<K,V>", "signature": "ConcurrentNavigableMap<K,V> headMap(K toKey)", "full_signature": "@Override public ConcurrentNavigableMap<K,V> headMap(K toKey)", "class_method_signature": "BTreeMap.headMap(K toKey)", "testcase": false, "constructor": false}, {"identifier": "tailMap", "parameters": "(K fromKey)", "modifiers": "@Override public", "return": "ConcurrentNavigableMap<K,V>", "signature": "ConcurrentNavigableMap<K,V> tailMap(K fromKey)", "full_signature": "@Override public ConcurrentNavigableMap<K,V> tailMap(K fromKey)", "class_method_signature": "BTreeMap.tailMap(K fromKey)", "testcase": false, "constructor": false}, {"identifier": "keyIterator", "parameters": "()", "modifiers": "", "return": "Iterator<K>", "signature": "Iterator<K> keyIterator()", "full_signature": " Iterator<K> keyIterator()", "class_method_signature": "BTreeMap.keyIterator()", "testcase": false, "constructor": false}, {"identifier": "valueIterator", "parameters": "()", "modifiers": "", "return": "Iterator<V>", "signature": "Iterator<V> valueIterator()", "full_signature": " Iterator<V> valueIterator()", "class_method_signature": "BTreeMap.valueIterator()", "testcase": false, "constructor": false}, {"identifier": "entryIterator", "parameters": "()", "modifiers": "", "return": "Iterator<Map.Entry<K,V>>", "signature": "Iterator<Map.Entry<K,V>> entryIterator()", "full_signature": " Iterator<Map.Entry<K,V>> entryIterator()", "class_method_signature": "BTreeMap.entryIterator()", "testcase": false, "constructor": false}, {"identifier": "keySet", "parameters": "()", "modifiers": "@Override public", "return": "NavigableSet<K>", "signature": "NavigableSet<K> keySet()", "full_signature": "@Override public NavigableSet<K> keySet()", "class_method_signature": "BTreeMap.keySet()", "testcase": false, "constructor": false}, {"identifier": "navigableKeySet", "parameters": "()", "modifiers": "@Override public", "return": "NavigableSet<K>", "signature": "NavigableSet<K> navigableKeySet()", "full_signature": "@Override public NavigableSet<K> navigableKeySet()", "class_method_signature": "BTreeMap.navigableKeySet()", "testcase": false, "constructor": false}, {"identifier": "values", "parameters": "()", "modifiers": "@Override public", "return": "Collection<V>", "signature": "Collection<V> values()", "full_signature": "@Override public Collection<V> values()", "class_method_signature": "BTreeMap.values()", "testcase": false, "constructor": false}, {"identifier": "entrySet", "parameters": "()", "modifiers": "@Override public", "return": "Set<Map.Entry<K,V>>", "signature": "Set<Map.Entry<K,V>> entrySet()", "full_signature": "@Override public Set<Map.Entry<K,V>> entrySet()", "class_method_signature": "BTreeMap.entrySet()", "testcase": false, "constructor": false}, {"identifier": "descendingMap", "parameters": "()", "modifiers": "@Override public", "return": "ConcurrentNavigableMap<K,V>", "signature": "ConcurrentNavigableMap<K,V> descendingMap()", "full_signature": "@Override public ConcurrentNavigableMap<K,V> descendingMap()", "class_method_signature": "BTreeMap.descendingMap()", "testcase": false, "constructor": false}, {"identifier": "descendingKeySet", "parameters": "()", "modifiers": "@Override public", "return": "NavigableSet<K>", "signature": "NavigableSet<K> descendingKeySet()", "full_signature": "@Override public NavigableSet<K> descendingKeySet()", "class_method_signature": "BTreeMap.descendingKeySet()", "testcase": false, "constructor": false}, {"identifier": "toList", "parameters": "(Collection<E> c)", "modifiers": "static final", "return": "List<E>", "signature": "List<E> toList(Collection<E> c)", "full_signature": "static final List<E> toList(Collection<E> c)", "class_method_signature": "BTreeMap.toList(Collection<E> c)", "testcase": false, "constructor": false}, {"identifier": "snapshot", "parameters": "()", "modifiers": "public", "return": "NavigableMap<K,V>", "signature": "NavigableMap<K,V> snapshot()", "full_signature": "public NavigableMap<K,V> snapshot()", "class_method_signature": "BTreeMap.snapshot()", "testcase": false, "constructor": false}, {"identifier": "addModificationListener", "parameters": "(Bind.MapListener<K,V> listener)", "modifiers": "@Override public", "return": "void", "signature": "void addModificationListener(Bind.MapListener<K,V> listener)", "full_signature": "@Override public void addModificationListener(Bind.MapListener<K,V> listener)", "class_method_signature": "BTreeMap.addModificationListener(Bind.MapListener<K,V> listener)", "testcase": false, "constructor": false}, {"identifier": "removeModificationListener", "parameters": "(Bind.MapListener<K,V> listener)", "modifiers": "@Override public", "return": "void", "signature": "void removeModificationListener(Bind.MapListener<K,V> listener)", "full_signature": "@Override public void removeModificationListener(Bind.MapListener<K,V> listener)", "class_method_signature": "BTreeMap.removeModificationListener(Bind.MapListener<K,V> listener)", "testcase": false, "constructor": false}, {"identifier": "notify", "parameters": "(K key, V oldValue, V newValue)", "modifiers": "protected", "return": "void", "signature": "void notify(K key, V oldValue, V newValue)", "full_signature": "protected void notify(K key, V oldValue, V newValue)", "class_method_signature": "BTreeMap.notify(K key, V oldValue, V newValue)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "BTreeMap.close()", "testcase": false, "constructor": false}, {"identifier": "printTreeStructure", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void printTreeStructure()", "full_signature": "public void printTreeStructure()", "class_method_signature": "BTreeMap.printTreeStructure()", "testcase": false, "constructor": false}, {"identifier": "printRecur", "parameters": "(BTreeMap m, long recid, String s)", "modifiers": "private static", "return": "void", "signature": "void printRecur(BTreeMap m, long recid, String s)", "full_signature": "private static void printRecur(BTreeMap m, long recid, String s)", "class_method_signature": "BTreeMap.printRecur(BTreeMap m, long recid, String s)", "testcase": false, "constructor": false}], "file": "migration/third-party/org.mapdb/src/main/java/org/mapdb/BTreeMap.java"}, "focal_method": {"identifier": "nextDir", "parameters": "(DirNode d, Object key)", "modifiers": "protected", "return": "long", "body": "protected long nextDir(DirNode d, Object key) {\n        int pos = findChildren(key, d.keys) - 1;\n        if(pos<0) pos = 0;\n        return d.child[pos];\n    }", "signature": "long nextDir(DirNode d, Object key)", "full_signature": "protected long nextDir(DirNode d, Object key)", "class_method_signature": "BTreeMap.nextDir(DirNode d, Object key)", "testcase": false, "constructor": false, "invocations": ["findChildren"]}, "repository": {"repo_id": 113878762, "url": "https://github.com/crossminer/scava", "language": "Java", "is_fork": false, "fork_count": 12, "stargazer_count": 16, "size": 1903904, "license": "licensed"}}