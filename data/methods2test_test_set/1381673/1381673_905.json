{"test_class": {"identifier": "DrlxParseUtilTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "final TypeResolver typeResolver = new ClassTypeResolver(new HashSet<>(), getClass().getClassLoader());", "modifier": "final", "type": "TypeResolver", "declarator": "typeResolver = new ClassTypeResolver(new HashSet<>(), getClass().getClassLoader())", "var_name": "typeResolver"}], "file": "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/builder/generator/DrlxParseUtilTest.java"}, "test_case": {"identifier": "prependTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void prependTest() {\n\n        final Expression expr = StaticJavaParser.parseExpression(\"getAddressName().startsWith(\\\"M\\\")\");\n        final NameExpr nameExpr = new NameExpr(THIS_PLACEHOLDER);\n\n        final Expression concatenated = DrlxParseUtil.prepend(nameExpr, expr);\n\n        assertEquals(THIS_PLACEHOLDER + \".getAddressName().startsWith(\\\"M\\\")\", concatenated.toString());\n    }", "signature": "void prependTest()", "full_signature": "@Test public void prependTest()", "class_method_signature": "DrlxParseUtilTest.prependTest()", "testcase": true, "constructor": false, "invocations": ["parseExpression", "prepend", "assertEquals", "toString"]}, "focal_class": {"identifier": "DrlxParseUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String THIS_PLACEHOLDER = \"_this\";", "modifier": "public static final", "type": "String", "declarator": "THIS_PLACEHOLDER = \"_this\"", "var_name": "THIS_PLACEHOLDER"}, {"original_string": "private static final Map<String, Method> accessorsCache = new HashMap<>();", "modifier": "private static final", "type": "Map<String, Method>", "declarator": "accessorsCache = new HashMap<>()", "var_name": "accessorsCache"}], "methods": [{"identifier": "isThisExpression", "parameters": "( Node expr )", "modifiers": "public static", "return": "boolean", "signature": "boolean isThisExpression( Node expr )", "full_signature": "public static boolean isThisExpression( Node expr )", "class_method_signature": "DrlxParseUtil.isThisExpression( Node expr )", "testcase": false, "constructor": false}, {"identifier": "toConstraintType", "parameters": "( Operator operator)", "modifiers": "public static", "return": "Index.ConstraintType", "signature": "Index.ConstraintType toConstraintType( Operator operator)", "full_signature": "public static Index.ConstraintType toConstraintType( Operator operator)", "class_method_signature": "DrlxParseUtil.toConstraintType( Operator operator)", "testcase": false, "constructor": false}, {"identifier": "toBinaryExprOperator", "parameters": "(HalfBinaryExpr.Operator operator)", "modifiers": "private static", "return": "Operator", "signature": "Operator toBinaryExprOperator(HalfBinaryExpr.Operator operator)", "full_signature": "private static Operator toBinaryExprOperator(HalfBinaryExpr.Operator operator)", "class_method_signature": "DrlxParseUtil.toBinaryExprOperator(HalfBinaryExpr.Operator operator)", "testcase": false, "constructor": false}, {"identifier": "nameExprToMethodCallExprWithCast", "parameters": "(String name, java.lang.reflect.Type type, Expression scope, Type castType)", "modifiers": "public static", "return": "TypedExpression", "signature": "TypedExpression nameExprToMethodCallExprWithCast(String name, java.lang.reflect.Type type, Expression scope, Type castType)", "full_signature": "public static TypedExpression nameExprToMethodCallExprWithCast(String name, java.lang.reflect.Type type, Expression scope, Type castType)", "class_method_signature": "DrlxParseUtil.nameExprToMethodCallExprWithCast(String name, java.lang.reflect.Type type, Expression scope, Type castType)", "testcase": false, "constructor": false}, {"identifier": "nameExprToMethodCallExpr", "parameters": "(String name, java.lang.reflect.Type type, Expression scope)", "modifiers": "public static", "return": "TypedExpression", "signature": "TypedExpression nameExprToMethodCallExpr(String name, java.lang.reflect.Type type, Expression scope)", "full_signature": "public static TypedExpression nameExprToMethodCallExpr(String name, java.lang.reflect.Type type, Expression scope)", "class_method_signature": "DrlxParseUtil.nameExprToMethodCallExpr(String name, java.lang.reflect.Type type, Expression scope)", "testcase": false, "constructor": false}, {"identifier": "returnTypeOfMethodCallExpr", "parameters": "(RuleContext context, TypeResolver typeResolver, MethodCallExpr methodCallExpr, java.lang.reflect.Type clazz, Collection<String> usedDeclarations)", "modifiers": "public static", "return": "java.lang.reflect.Type", "signature": "java.lang.reflect.Type returnTypeOfMethodCallExpr(RuleContext context, TypeResolver typeResolver, MethodCallExpr methodCallExpr, java.lang.reflect.Type clazz, Collection<String> usedDeclarations)", "full_signature": "public static java.lang.reflect.Type returnTypeOfMethodCallExpr(RuleContext context, TypeResolver typeResolver, MethodCallExpr methodCallExpr, java.lang.reflect.Type clazz, Collection<String> usedDeclarations)", "class_method_signature": "DrlxParseUtil.returnTypeOfMethodCallExpr(RuleContext context, TypeResolver typeResolver, MethodCallExpr methodCallExpr, java.lang.reflect.Type clazz, Collection<String> usedDeclarations)", "testcase": false, "constructor": false}, {"identifier": "getExpressionType", "parameters": "(RuleContext context, TypeResolver typeResolver, Expression expr, Collection<String> usedDeclarations)", "modifiers": "public static", "return": "java.lang.reflect.Type", "signature": "java.lang.reflect.Type getExpressionType(RuleContext context, TypeResolver typeResolver, Expression expr, Collection<String> usedDeclarations)", "full_signature": "public static java.lang.reflect.Type getExpressionType(RuleContext context, TypeResolver typeResolver, Expression expr, Collection<String> usedDeclarations)", "class_method_signature": "DrlxParseUtil.getExpressionType(RuleContext context, TypeResolver typeResolver, Expression expr, Collection<String> usedDeclarations)", "testcase": false, "constructor": false}, {"identifier": "expressionTypeNameExpr", "parameters": "(RuleContext context, Collection<String> usedDeclarations, String nameAsString)", "modifiers": "private static", "return": "java.lang.reflect.Type", "signature": "java.lang.reflect.Type expressionTypeNameExpr(RuleContext context, Collection<String> usedDeclarations, String nameAsString)", "full_signature": "private static java.lang.reflect.Type expressionTypeNameExpr(RuleContext context, Collection<String> usedDeclarations, String nameAsString)", "class_method_signature": "DrlxParseUtil.expressionTypeNameExpr(RuleContext context, Collection<String> usedDeclarations, String nameAsString)", "testcase": false, "constructor": false}, {"identifier": "canCoerceLiteralNumberExpr", "parameters": "(Class<?> type)", "modifiers": "public static", "return": "boolean", "signature": "boolean canCoerceLiteralNumberExpr(Class<?> type)", "full_signature": "public static boolean canCoerceLiteralNumberExpr(Class<?> type)", "class_method_signature": "DrlxParseUtil.canCoerceLiteralNumberExpr(Class<?> type)", "testcase": false, "constructor": false}, {"identifier": "getLiteralExpressionType", "parameters": "( LiteralExpr expr )", "modifiers": "public static", "return": "Class<?>", "signature": "Class<?> getLiteralExpressionType( LiteralExpr expr )", "full_signature": "public static Class<?> getLiteralExpressionType( LiteralExpr expr )", "class_method_signature": "DrlxParseUtil.getLiteralExpressionType( LiteralExpr expr )", "testcase": false, "constructor": false}, {"identifier": "prepend", "parameters": "(Expression scope, Expression expr)", "modifiers": "public static", "return": "Expression", "signature": "Expression prepend(Expression scope, Expression expr)", "full_signature": "public static Expression prepend(Expression scope, Expression expr)", "class_method_signature": "DrlxParseUtil.prepend(Expression scope, Expression expr)", "testcase": false, "constructor": false}, {"identifier": "findRootNodeViaParent", "parameters": "(Node expr)", "modifiers": "public static", "return": "Optional<Node>", "signature": "Optional<Node> findRootNodeViaParent(Node expr)", "full_signature": "public static Optional<Node> findRootNodeViaParent(Node expr)", "class_method_signature": "DrlxParseUtil.findRootNodeViaParent(Node expr)", "testcase": false, "constructor": false}, {"identifier": "replaceAllHalfBinaryChildren", "parameters": "(Node parent)", "modifiers": "public static", "return": "Node", "signature": "Node replaceAllHalfBinaryChildren(Node parent)", "full_signature": "public static Node replaceAllHalfBinaryChildren(Node parent)", "class_method_signature": "DrlxParseUtil.replaceAllHalfBinaryChildren(Node parent)", "testcase": false, "constructor": false}, {"identifier": "trasformHalfBinaryToBinary", "parameters": "(Expression drlxExpr)", "modifiers": "public static", "return": "Expression", "signature": "Expression trasformHalfBinaryToBinary(Expression drlxExpr)", "full_signature": "public static Expression trasformHalfBinaryToBinary(Expression drlxExpr)", "class_method_signature": "DrlxParseUtil.trasformHalfBinaryToBinary(Expression drlxExpr)", "testcase": false, "constructor": false}, {"identifier": "findLastMethodInChain", "parameters": "(MethodCallExpr expr)", "modifiers": "public static", "return": "MethodCallExpr", "signature": "MethodCallExpr findLastMethodInChain(MethodCallExpr expr)", "full_signature": "public static MethodCallExpr findLastMethodInChain(MethodCallExpr expr)", "class_method_signature": "DrlxParseUtil.findLastMethodInChain(MethodCallExpr expr)", "testcase": false, "constructor": false}, {"identifier": "findRemoveRootNodeViaScope", "parameters": "(Expression expr)", "modifiers": "public static", "return": "RemoveRootNodeResult", "signature": "RemoveRootNodeResult findRemoveRootNodeViaScope(Expression expr)", "full_signature": "public static RemoveRootNodeResult findRemoveRootNodeViaScope(Expression expr)", "class_method_signature": "DrlxParseUtil.findRemoveRootNodeViaScope(Expression expr)", "testcase": false, "constructor": false}, {"identifier": "findRootNodeViaScope", "parameters": "(Expression expr)", "modifiers": "public static", "return": "Optional<Expression>", "signature": "Optional<Expression> findRootNodeViaScope(Expression expr)", "full_signature": "public static Optional<Expression> findRootNodeViaScope(Expression expr)", "class_method_signature": "DrlxParseUtil.findRootNodeViaScope(Expression expr)", "testcase": false, "constructor": false}, {"identifier": "removeRootNode", "parameters": "(Expression expr)", "modifiers": "public static", "return": "RemoveRootNodeResult", "signature": "RemoveRootNodeResult removeRootNode(Expression expr)", "full_signature": "public static RemoveRootNodeResult removeRootNode(Expression expr)", "class_method_signature": "DrlxParseUtil.removeRootNode(Expression expr)", "testcase": false, "constructor": false}, {"identifier": "findRootNodeViaScopeRec", "parameters": "(Expression expr, LinkedList<Expression> acc)", "modifiers": "private static", "return": "RemoveRootNodeResult", "signature": "RemoveRootNodeResult findRootNodeViaScopeRec(Expression expr, LinkedList<Expression> acc)", "full_signature": "private static RemoveRootNodeResult findRootNodeViaScopeRec(Expression expr, LinkedList<Expression> acc)", "class_method_signature": "DrlxParseUtil.findRootNodeViaScopeRec(Expression expr, LinkedList<Expression> acc)", "testcase": false, "constructor": false}, {"identifier": "fromVar", "parameters": "(String key)", "modifiers": "public static", "return": "String", "signature": "String fromVar(String key)", "full_signature": "public static String fromVar(String key)", "class_method_signature": "DrlxParseUtil.fromVar(String key)", "testcase": false, "constructor": false}, {"identifier": "parseBlock", "parameters": "(String ruleConsequenceAsBlock)", "modifiers": "public static", "return": "BlockStmt", "signature": "BlockStmt parseBlock(String ruleConsequenceAsBlock)", "full_signature": "public static BlockStmt parseBlock(String ruleConsequenceAsBlock)", "class_method_signature": "DrlxParseUtil.parseBlock(String ruleConsequenceAsBlock)", "testcase": false, "constructor": false}, {"identifier": "generateLambdaWithoutParameters", "parameters": "(Collection<String> usedDeclarations, Expression expr)", "modifiers": "public static", "return": "Expression", "signature": "Expression generateLambdaWithoutParameters(Collection<String> usedDeclarations, Expression expr)", "full_signature": "public static Expression generateLambdaWithoutParameters(Collection<String> usedDeclarations, Expression expr)", "class_method_signature": "DrlxParseUtil.generateLambdaWithoutParameters(Collection<String> usedDeclarations, Expression expr)", "testcase": false, "constructor": false}, {"identifier": "generateLambdaWithoutParameters", "parameters": "(Expression expr)", "modifiers": "public static", "return": "Expression", "signature": "Expression generateLambdaWithoutParameters(Expression expr)", "full_signature": "public static Expression generateLambdaWithoutParameters(Expression expr)", "class_method_signature": "DrlxParseUtil.generateLambdaWithoutParameters(Expression expr)", "testcase": false, "constructor": false}, {"identifier": "generateLambdaWithoutParameters", "parameters": "(Collection<String> usedDeclarations,\n                                                             Expression expr,\n                                                             boolean skipFirstParamAsThis,\n                                                             Optional<Class<?>> patternClass)", "modifiers": "public static", "return": "Expression", "signature": "Expression generateLambdaWithoutParameters(Collection<String> usedDeclarations,\n                                                             Expression expr,\n                                                             boolean skipFirstParamAsThis,\n                                                             Optional<Class<?>> patternClass)", "full_signature": "public static Expression generateLambdaWithoutParameters(Collection<String> usedDeclarations,\n                                                             Expression expr,\n                                                             boolean skipFirstParamAsThis,\n                                                             Optional<Class<?>> patternClass)", "class_method_signature": "DrlxParseUtil.generateLambdaWithoutParameters(Collection<String> usedDeclarations,\n                                                             Expression expr,\n                                                             boolean skipFirstParamAsThis,\n                                                             Optional<Class<?>> patternClass)", "testcase": false, "constructor": false}, {"identifier": "generateLambdaWithoutParameters", "parameters": "(Collection<String> usedDeclarations,\n                                                             Expression expr,\n                                                             boolean skipFirstParamAsThis,\n                                                             Optional<Class<?>> patternClass,\n                                                             RuleContext ruleContext)", "modifiers": "public static", "return": "Expression", "signature": "Expression generateLambdaWithoutParameters(Collection<String> usedDeclarations,\n                                                             Expression expr,\n                                                             boolean skipFirstParamAsThis,\n                                                             Optional<Class<?>> patternClass,\n                                                             RuleContext ruleContext)", "full_signature": "public static Expression generateLambdaWithoutParameters(Collection<String> usedDeclarations,\n                                                             Expression expr,\n                                                             boolean skipFirstParamAsThis,\n                                                             Optional<Class<?>> patternClass,\n                                                             RuleContext ruleContext)", "class_method_signature": "DrlxParseUtil.generateLambdaWithoutParameters(Collection<String> usedDeclarations,\n                                                             Expression expr,\n                                                             boolean skipFirstParamAsThis,\n                                                             Optional<Class<?>> patternClass,\n                                                             RuleContext ruleContext)", "testcase": false, "constructor": false}, {"identifier": "canResolveAllParameterTypes", "parameters": "(Collection<String> usedDeclarations, boolean skipFirstParamAsThis, Optional<Class<?>> patternClass, RuleContext ruleContext)", "modifiers": "private static", "return": "boolean", "signature": "boolean canResolveAllParameterTypes(Collection<String> usedDeclarations, boolean skipFirstParamAsThis, Optional<Class<?>> patternClass, RuleContext ruleContext)", "full_signature": "private static boolean canResolveAllParameterTypes(Collection<String> usedDeclarations, boolean skipFirstParamAsThis, Optional<Class<?>> patternClass, RuleContext ruleContext)", "class_method_signature": "DrlxParseUtil.canResolveAllParameterTypes(Collection<String> usedDeclarations, boolean skipFirstParamAsThis, Optional<Class<?>> patternClass, RuleContext ruleContext)", "testcase": false, "constructor": false}, {"identifier": "getDelarationType", "parameters": "(RuleContext ruleContext, String variableName)", "modifiers": "private static", "return": "Type", "signature": "Type getDelarationType(RuleContext ruleContext, String variableName)", "full_signature": "private static Type getDelarationType(RuleContext ruleContext, String variableName)", "class_method_signature": "DrlxParseUtil.getDelarationType(RuleContext ruleContext, String variableName)", "testcase": false, "constructor": false}, {"identifier": "classToReferenceType", "parameters": "(Class<?> declClass)", "modifiers": "public static", "return": "Type", "signature": "Type classToReferenceType(Class<?> declClass)", "full_signature": "public static Type classToReferenceType(Class<?> declClass)", "class_method_signature": "DrlxParseUtil.classToReferenceType(Class<?> declClass)", "testcase": false, "constructor": false}, {"identifier": "classNameToReferenceType", "parameters": "(String className)", "modifiers": "public static", "return": "Type", "signature": "Type classNameToReferenceType(String className)", "full_signature": "public static Type classNameToReferenceType(String className)", "class_method_signature": "DrlxParseUtil.classNameToReferenceType(String className)", "testcase": false, "constructor": false}, {"identifier": "toType", "parameters": "(Class<?> declClass)", "modifiers": "public static", "return": "Type", "signature": "Type toType(Class<?> declClass)", "full_signature": "public static Type toType(Class<?> declClass)", "class_method_signature": "DrlxParseUtil.toType(Class<?> declClass)", "testcase": false, "constructor": false}, {"identifier": "toClassOrInterfaceType", "parameters": "( Class<?> declClass )", "modifiers": "public static", "return": "ClassOrInterfaceType", "signature": "ClassOrInterfaceType toClassOrInterfaceType( Class<?> declClass )", "full_signature": "public static ClassOrInterfaceType toClassOrInterfaceType( Class<?> declClass )", "class_method_signature": "DrlxParseUtil.toClassOrInterfaceType( Class<?> declClass )", "testcase": false, "constructor": false}, {"identifier": "toClassOrInterfaceType", "parameters": "( String className )", "modifiers": "public static", "return": "ClassOrInterfaceType", "signature": "ClassOrInterfaceType toClassOrInterfaceType( String className )", "full_signature": "public static ClassOrInterfaceType toClassOrInterfaceType( String className )", "class_method_signature": "DrlxParseUtil.toClassOrInterfaceType( String className )", "testcase": false, "constructor": false}, {"identifier": "findBindingIdFromDotExpression", "parameters": "(String expression)", "modifiers": "public static", "return": "Optional<String>", "signature": "Optional<String> findBindingIdFromDotExpression(String expression)", "full_signature": "public static Optional<String> findBindingIdFromDotExpression(String expression)", "class_method_signature": "DrlxParseUtil.findBindingIdFromDotExpression(String expression)", "testcase": false, "constructor": false}, {"identifier": "findViaScopeWithPredicate", "parameters": "(Expression expr, Predicate<Expression> predicate)", "modifiers": "public static", "return": "Optional<Expression>", "signature": "Optional<Expression> findViaScopeWithPredicate(Expression expr, Predicate<Expression> predicate)", "full_signature": "public static Optional<Expression> findViaScopeWithPredicate(Expression expr, Predicate<Expression> predicate)", "class_method_signature": "DrlxParseUtil.findViaScopeWithPredicate(Expression expr, Predicate<Expression> predicate)", "testcase": false, "constructor": false}, {"identifier": "parseExpression", "parameters": "(String expression)", "modifiers": "public static", "return": "DrlxExpression", "signature": "DrlxExpression parseExpression(String expression)", "full_signature": "public static DrlxExpression parseExpression(String expression)", "class_method_signature": "DrlxParseUtil.parseExpression(String expression)", "testcase": false, "constructor": false}, {"identifier": "getClassFromType", "parameters": "(TypeResolver typeResolver, Type type)", "modifiers": "public static", "return": "Class<?>", "signature": "Class<?> getClassFromType(TypeResolver typeResolver, Type type)", "full_signature": "public static Class<?> getClassFromType(TypeResolver typeResolver, Type type)", "class_method_signature": "DrlxParseUtil.getClassFromType(TypeResolver typeResolver, Type type)", "testcase": false, "constructor": false}, {"identifier": "getClassFromContext", "parameters": "(TypeResolver typeResolver, String className)", "modifiers": "public static", "return": "Class<?>", "signature": "Class<?> getClassFromContext(TypeResolver typeResolver, String className)", "full_signature": "public static Class<?> getClassFromContext(TypeResolver typeResolver, String className)", "class_method_signature": "DrlxParseUtil.getClassFromContext(TypeResolver typeResolver, String className)", "testcase": false, "constructor": false}, {"identifier": "isPrimitiveExpression", "parameters": "(Expression expr)", "modifiers": "public static", "return": "boolean", "signature": "boolean isPrimitiveExpression(Expression expr)", "full_signature": "public static boolean isPrimitiveExpression(Expression expr)", "class_method_signature": "DrlxParseUtil.isPrimitiveExpression(Expression expr)", "testcase": false, "constructor": false}, {"identifier": "forceCastForName", "parameters": "(String nameRef, Type type, Expression expression)", "modifiers": "public static", "return": "void", "signature": "void forceCastForName(String nameRef, Type type, Expression expression)", "full_signature": "public static void forceCastForName(String nameRef, Type type, Expression expression)", "class_method_signature": "DrlxParseUtil.forceCastForName(String nameRef, Type type, Expression expression)", "testcase": false, "constructor": false}, {"identifier": "rescopeNamesToNewScope", "parameters": "(Expression newScope, List<String> names, Expression e)", "modifiers": "public static", "return": "void", "signature": "void rescopeNamesToNewScope(Expression newScope, List<String> names, Expression e)", "full_signature": "public static void rescopeNamesToNewScope(Expression newScope, List<String> names, Expression e)", "class_method_signature": "DrlxParseUtil.rescopeNamesToNewScope(Expression newScope, List<String> names, Expression e)", "testcase": false, "constructor": false}, {"identifier": "getPatternListenedProperties", "parameters": "( PatternDescr pattern)", "modifiers": "public static", "return": "List<String>", "signature": "List<String> getPatternListenedProperties( PatternDescr pattern)", "full_signature": "public static List<String> getPatternListenedProperties( PatternDescr pattern)", "class_method_signature": "DrlxParseUtil.getPatternListenedProperties( PatternDescr pattern)", "testcase": false, "constructor": false}, {"identifier": "findLastPattern", "parameters": "(List<Expression> expressions)", "modifiers": "public static", "return": "Optional<MethodCallExpr>", "signature": "Optional<MethodCallExpr> findLastPattern(List<Expression> expressions)", "full_signature": "public static Optional<MethodCallExpr> findLastPattern(List<Expression> expressions)", "class_method_signature": "DrlxParseUtil.findLastPattern(List<Expression> expressions)", "testcase": false, "constructor": false}, {"identifier": "isNameExprWithName", "parameters": "(Node expression, String name)", "modifiers": "public static", "return": "boolean", "signature": "boolean isNameExprWithName(Node expression, String name)", "full_signature": "public static boolean isNameExprWithName(Node expression, String name)", "class_method_signature": "DrlxParseUtil.isNameExprWithName(Node expression, String name)", "testcase": false, "constructor": false}, {"identifier": "findAllChildrenRecursive", "parameters": "(Expression e)", "modifiers": "public static", "return": "List<Node>", "signature": "List<Node> findAllChildrenRecursive(Expression e)", "full_signature": "public static List<Node> findAllChildrenRecursive(Expression e)", "class_method_signature": "DrlxParseUtil.findAllChildrenRecursive(Expression e)", "testcase": false, "constructor": false}, {"identifier": "findAllChildrenRecursiveRec", "parameters": "(List<Node> accumulator, Node e)", "modifiers": "private static", "return": "void", "signature": "void findAllChildrenRecursiveRec(List<Node> accumulator, Node e)", "full_signature": "private static void findAllChildrenRecursiveRec(List<Node> accumulator, Node e)", "class_method_signature": "DrlxParseUtil.findAllChildrenRecursiveRec(List<Node> accumulator, Node e)", "testcase": false, "constructor": false}, {"identifier": "toVar", "parameters": "(String key)", "modifiers": "public static", "return": "String", "signature": "String toVar(String key)", "full_signature": "public static String toVar(String key)", "class_method_signature": "DrlxParseUtil.toVar(String key)", "testcase": false, "constructor": false}, {"identifier": "validateDuplicateBindings", "parameters": "(String ruleName, List<String> allBindings)", "modifiers": "public static", "return": "Optional<InvalidExpressionErrorResult>", "signature": "Optional<InvalidExpressionErrorResult> validateDuplicateBindings(String ruleName, List<String> allBindings)", "full_signature": "public static Optional<InvalidExpressionErrorResult> validateDuplicateBindings(String ruleName, List<String> allBindings)", "class_method_signature": "DrlxParseUtil.validateDuplicateBindings(String ruleName, List<String> allBindings)", "testcase": false, "constructor": false}, {"identifier": "getAccessor", "parameters": "( Class<?> clazz, String name )", "modifiers": "public static", "return": "Method", "signature": "Method getAccessor( Class<?> clazz, String name )", "full_signature": "public static Method getAccessor( Class<?> clazz, String name )", "class_method_signature": "DrlxParseUtil.getAccessor( Class<?> clazz, String name )", "testcase": false, "constructor": false}, {"identifier": "clearAccessorCache", "parameters": "()", "modifiers": "public static", "return": "void", "signature": "void clearAccessorCache()", "full_signature": "public static void clearAccessorCache()", "class_method_signature": "DrlxParseUtil.clearAccessorCache()", "testcase": false, "constructor": false}, {"identifier": "getField", "parameters": "( Class<?> clazz, String name )", "modifiers": "public static", "return": "Field", "signature": "Field getField( Class<?> clazz, String name )", "full_signature": "public static Field getField( Class<?> clazz, String name )", "class_method_signature": "DrlxParseUtil.getField( Class<?> clazz, String name )", "testcase": false, "constructor": false}, {"identifier": "transformDrlNameExprToNameExpr", "parameters": "(T e)", "modifiers": "public static", "return": "T", "signature": "T transformDrlNameExprToNameExpr(T e)", "full_signature": "public static T transformDrlNameExprToNameExpr(T e)", "class_method_signature": "DrlxParseUtil.transformDrlNameExprToNameExpr(T e)", "testcase": false, "constructor": false}, {"identifier": "addCurlyBracesToBlock", "parameters": "(String blockString)", "modifiers": "public static", "return": "String", "signature": "String addCurlyBracesToBlock(String blockString)", "full_signature": "public static String addCurlyBracesToBlock(String blockString)", "class_method_signature": "DrlxParseUtil.addCurlyBracesToBlock(String blockString)", "testcase": false, "constructor": false}, {"identifier": "addSemicolon", "parameters": "(String block)", "modifiers": "public static", "return": "String", "signature": "String addSemicolon(String block)", "full_signature": "public static String addSemicolon(String block)", "class_method_signature": "DrlxParseUtil.addSemicolon(String block)", "testcase": false, "constructor": false}, {"identifier": "uncastExpr", "parameters": "(Expression e)", "modifiers": "public static", "return": "Expression", "signature": "Expression uncastExpr(Expression e)", "full_signature": "public static Expression uncastExpr(Expression e)", "class_method_signature": "DrlxParseUtil.uncastExpr(Expression e)", "testcase": false, "constructor": false}, {"identifier": "collectUsedDeclarationsInExpression", "parameters": "(Expression expr)", "modifiers": "public static", "return": "Collection<String>", "signature": "Collection<String> collectUsedDeclarationsInExpression(Expression expr)", "full_signature": "public static Collection<String> collectUsedDeclarationsInExpression(Expression expr)", "class_method_signature": "DrlxParseUtil.collectUsedDeclarationsInExpression(Expression expr)", "testcase": false, "constructor": false}, {"identifier": "safeResolveType", "parameters": "(TypeResolver typeResolver, String typeName)", "modifiers": "public static", "return": "Optional<java.lang.reflect.Type>", "signature": "Optional<java.lang.reflect.Type> safeResolveType(TypeResolver typeResolver, String typeName)", "full_signature": "public static Optional<java.lang.reflect.Type> safeResolveType(TypeResolver typeResolver, String typeName)", "class_method_signature": "DrlxParseUtil.safeResolveType(TypeResolver typeResolver, String typeName)", "testcase": false, "constructor": false}, {"identifier": "DrlxParseUtil", "parameters": "()", "modifiers": "private", "return": "", "signature": " DrlxParseUtil()", "full_signature": "private  DrlxParseUtil()", "class_method_signature": "DrlxParseUtil.DrlxParseUtil()", "testcase": false, "constructor": true}], "file": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/DrlxParseUtil.java"}, "focal_method": {"identifier": "prepend", "parameters": "(Expression scope, Expression expr)", "modifiers": "public static", "return": "Expression", "body": "public static Expression prepend(Expression scope, Expression expr) {\n        final Optional<Expression> rootNode = findRootNodeViaScope(expr);\n        if (rootNode.isPresent()) {\n            if(rootNode.get() instanceof ThisExpr) {\n                rootNode.get().replace(scope);\n            } else if (rootNode.get() instanceof NodeWithOptionalScope<?>) {\n                ((NodeWithOptionalScope) rootNode.get()).setScope(scope);\n            }\n            return expr;\n        } else {\n            throw new IllegalStateException(\"No root node was found!\");\n        }\n    }", "signature": "Expression prepend(Expression scope, Expression expr)", "full_signature": "public static Expression prepend(Expression scope, Expression expr)", "class_method_signature": "DrlxParseUtil.prepend(Expression scope, Expression expr)", "testcase": false, "constructor": false, "invocations": ["findRootNodeViaScope", "isPresent", "get", "replace", "get", "get", "setScope", "get"]}, "repository": {"repo_id": 1381673, "url": "https://github.com/kiegroup/drools", "stars": 2733, "created": "2/18/2011 8:37:05 AM +00:00", "updates": "2020-01-27T13:12:15+00:00", "fork": "False", "license": "licensed"}}