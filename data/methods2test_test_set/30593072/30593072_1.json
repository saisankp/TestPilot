{"test_class": {"identifier": "TcpTransportTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Mockery mockery;", "modifier": "private", "type": "Mockery", "declarator": "mockery", "var_name": "mockery"}, {"original_string": "private PublishingConnectionObserver publishingTransportObserver;", "modifier": "private", "type": "PublishingConnectionObserver", "declarator": "publishingTransportObserver", "var_name": "publishingTransportObserver"}, {"original_string": "private SocketFactory socketFactory;", "modifier": "private", "type": "SocketFactory", "declarator": "socketFactory", "var_name": "socketFactory"}, {"original_string": "private DelegatingServerSocketChannel serverSocketChannel;", "modifier": "private", "type": "DelegatingServerSocketChannel", "declarator": "serverSocketChannel", "var_name": "serverSocketChannel"}, {"original_string": "private InetSocketAddress socketAddress;", "modifier": "private", "type": "InetSocketAddress", "declarator": "socketAddress", "var_name": "socketAddress"}], "file": "nanofix-client/src/test/java/com/lmax/nanofix/transport/TcpTransportTest.java"}, "test_case": {"identifier": "shouldCreateAnOutboundSocketWhenConnecting", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldCreateAnOutboundSocketWhenConnecting() throws Exception\n    {\n        final TcpTransport tcpTransport = new TcpTransport(publishingTransportObserver, socketAddress, socketFactory, new TransportConfigImpl(false));\n\n        mockery.checking(new Expectations()\n        {\n            {\n                one(socketFactory).createSocketOnOutgoingConnection(with(socketAddress), with(any(SocketFactory.SocketEstablishedCallback.class)));\n            }\n        });\n\n        tcpTransport.connect();\n    }", "signature": "void shouldCreateAnOutboundSocketWhenConnecting()", "full_signature": "@Test public void shouldCreateAnOutboundSocketWhenConnecting()", "class_method_signature": "TcpTransportTest.shouldCreateAnOutboundSocketWhenConnecting()", "testcase": true, "constructor": false, "invocations": ["checking", "createSocketOnOutgoingConnection", "one", "with", "with", "any", "connect"]}, "focal_class": {"identifier": "TcpTransport", "superclass": "", "interfaces": "implements Transport, ConnectionObserver", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(TcpTransport.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(TcpTransport.class)", "var_name": "LOGGER"}, {"original_string": "private final PublishingConnectionObserver publishingTransportObserver;", "modifier": "private final", "type": "PublishingConnectionObserver", "declarator": "publishingTransportObserver", "var_name": "publishingTransportObserver"}, {"original_string": "private final TransportConfig transportConfig;", "modifier": "private final", "type": "TransportConfig", "declarator": "transportConfig", "var_name": "transportConfig"}, {"original_string": "private volatile SocketChannel socketChannel;", "modifier": "private volatile", "type": "SocketChannel", "declarator": "socketChannel", "var_name": "socketChannel"}, {"original_string": "private volatile DelegatingServerSocketChannel serverSocketChannel;", "modifier": "private volatile", "type": "DelegatingServerSocketChannel", "declarator": "serverSocketChannel", "var_name": "serverSocketChannel"}, {"original_string": "private InetSocketAddress socketAddress;", "modifier": "private", "type": "InetSocketAddress", "declarator": "socketAddress", "var_name": "socketAddress"}, {"original_string": "private SocketFactory asyncTcpSocketFactory;", "modifier": "private", "type": "SocketFactory", "declarator": "asyncTcpSocketFactory", "var_name": "asyncTcpSocketFactory"}], "methods": [{"identifier": "TcpTransport", "parameters": "(final PublishingConnectionObserver publishingTransportObserver, final InetSocketAddress socketAddress,\n                        final SocketFactory asyncTcpSocketFactory, final TransportConfig transportConfig)", "modifiers": "public", "return": "", "signature": " TcpTransport(final PublishingConnectionObserver publishingTransportObserver, final InetSocketAddress socketAddress,\n                        final SocketFactory asyncTcpSocketFactory, final TransportConfig transportConfig)", "full_signature": "public  TcpTransport(final PublishingConnectionObserver publishingTransportObserver, final InetSocketAddress socketAddress,\n                        final SocketFactory asyncTcpSocketFactory, final TransportConfig transportConfig)", "class_method_signature": "TcpTransport.TcpTransport(final PublishingConnectionObserver publishingTransportObserver, final InetSocketAddress socketAddress,\n                        final SocketFactory asyncTcpSocketFactory, final TransportConfig transportConfig)", "testcase": false, "constructor": true}, {"identifier": "connect", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void connect()", "full_signature": "@Override public void connect()", "class_method_signature": "TcpTransport.connect()", "testcase": false, "constructor": false}, {"identifier": "listen", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void listen()", "full_signature": "@Override public void listen()", "class_method_signature": "TcpTransport.listen()", "testcase": false, "constructor": false}, {"identifier": "stopListening", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void stopListening()", "full_signature": "@Override public void stopListening()", "class_method_signature": "TcpTransport.stopListening()", "testcase": false, "constructor": false}, {"identifier": "getReadableByteChannel", "parameters": "()", "modifiers": "@Override public", "return": "ReadableByteChannel", "signature": "ReadableByteChannel getReadableByteChannel()", "full_signature": "@Override public ReadableByteChannel getReadableByteChannel()", "class_method_signature": "TcpTransport.getReadableByteChannel()", "testcase": false, "constructor": false}, {"identifier": "getWritableByteChannel", "parameters": "()", "modifiers": "@Override public", "return": "WritableByteChannel", "signature": "WritableByteChannel getWritableByteChannel()", "full_signature": "@Override public WritableByteChannel getWritableByteChannel()", "class_method_signature": "TcpTransport.getWritableByteChannel()", "testcase": false, "constructor": false}, {"identifier": "killSocket", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void killSocket()", "full_signature": "@Override public void killSocket()", "class_method_signature": "TcpTransport.killSocket()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "TcpTransport.close()", "testcase": false, "constructor": false}, {"identifier": "isConnected", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isConnected()", "full_signature": "@Override public boolean isConnected()", "class_method_signature": "TcpTransport.isConnected()", "testcase": false, "constructor": false}, {"identifier": "registerTransportObserver", "parameters": "(final ConnectionObserver connectionObserver)", "modifiers": "@Override public", "return": "void", "signature": "void registerTransportObserver(final ConnectionObserver connectionObserver)", "full_signature": "@Override public void registerTransportObserver(final ConnectionObserver connectionObserver)", "class_method_signature": "TcpTransport.registerTransportObserver(final ConnectionObserver connectionObserver)", "testcase": false, "constructor": false}, {"identifier": "unregisterTransportObserver", "parameters": "(final ConnectionObserver connectionObserver)", "modifiers": "@Override public", "return": "void", "signature": "void unregisterTransportObserver(final ConnectionObserver connectionObserver)", "full_signature": "@Override public void unregisterTransportObserver(final ConnectionObserver connectionObserver)", "class_method_signature": "TcpTransport.unregisterTransportObserver(final ConnectionObserver connectionObserver)", "testcase": false, "constructor": false}, {"identifier": "connectionEstablished", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void connectionEstablished()", "full_signature": "@Override public void connectionEstablished()", "class_method_signature": "TcpTransport.connectionEstablished()", "testcase": false, "constructor": false}, {"identifier": "connectionClosed", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void connectionClosed()", "full_signature": "@Override public void connectionClosed()", "class_method_signature": "TcpTransport.connectionClosed()", "testcase": false, "constructor": false}, {"identifier": "acceptNewConnection", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void acceptNewConnection()", "full_signature": "private void acceptNewConnection()", "class_method_signature": "TcpTransport.acceptNewConnection()", "testcase": false, "constructor": false}], "file": "nanofix-client/src/main/java/com/lmax/nanofix/transport/TcpTransport.java"}, "focal_method": {"identifier": "connect", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void connect()\n    {\n        asyncTcpSocketFactory.createSocketOnOutgoingConnection(socketAddress, new SocketFactory.SocketEstablishedCallback()\n        {\n            @Override\n            public void onSocketEstablished(final SocketChannel socketChannel)\n            {\n                TcpTransport.this.socketChannel = socketChannel;\n                publishingTransportObserver.connectionEstablished();\n            }\n        });\n\n    }", "signature": "void connect()", "full_signature": "@Override public void connect()", "class_method_signature": "TcpTransport.connect()", "testcase": false, "constructor": false, "invocations": ["createSocketOnOutgoingConnection", "connectionEstablished"]}, "repository": {"repo_id": 30593072, "url": "https://github.com/LMAX-Exchange/nanofix", "language": "Java", "is_fork": false, "fork_count": 18, "stargazer_count": 24, "size": 193, "license": "licensed"}}