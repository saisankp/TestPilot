{"test_class": {"identifier": "LocalComputationManagerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String PREFIX = \"test_\";", "modifier": "private static final", "type": "String", "declarator": "PREFIX = \"test_\"", "var_name": "PREFIX"}, {"original_string": "private FileSystem fileSystem;", "modifier": "private", "type": "FileSystem", "declarator": "fileSystem", "var_name": "fileSystem"}, {"original_string": "private Path localDir;", "modifier": "private", "type": "Path", "declarator": "localDir", "var_name": "localDir"}, {"original_string": "private LocalComputationConfig config;", "modifier": "private", "type": "LocalComputationConfig", "declarator": "config", "var_name": "config"}], "file": "computation-local/src/test/java/com/powsybl/computation/local/LocalComputationManagerTest.java"}, "test_case": {"identifier": "cancelDuringExecutionShouldThrowAndEventuallyStopExecution", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void cancelDuringExecutionShouldThrowAndEventuallyStopExecution() throws InterruptedException, ExecutionException, IOException {\n\n        CountDownLatch waitForExecution = new CountDownLatch(1);\n        CountDownLatch execution = new CountDownLatch(1); // Will be interrupted, not decremented\n        CountDownLatch waitForInterruption = new CountDownLatch(1);\n\n        MutableBoolean stopped = new MutableBoolean(false);\n        LocalCommandExecutor localCommandExecutor = new AbstractLocalCommandExecutor() {\n            @Override\n            void nonZeroLog(List<String> cmdLs, int exitCode) {\n            }\n\n            @Override\n            public int execute(String program, List<String> args, Path outFile, Path errFile, Path workingDir, Map<String, String> env) throws IOException, InterruptedException {\n                waitForExecution.countDown();\n                execution.await(); //Simulates process running\n                return 0;\n            }\n\n            @Override\n            public void stop(Path workingDir) {\n                stopped.setTrue();\n                waitForInterruption.countDown();\n            }\n\n            @Override\n            public void stopForcibly(Path workingDir) {\n                stopped.setTrue();\n                waitForInterruption.countDown();\n            }\n        };\n\n        try (ComputationManager computationManager = new LocalComputationManager(config, localCommandExecutor, ForkJoinPool.commonPool())) {\n\n            CompletableFuture<Object> result = computationManager.execute(ExecutionEnvironment.createDefault(), new AbstractExecutionHandler<Object>() {\n                @Override\n                public List<CommandExecution> before(Path workingDir) {\n                    return dummyExecutions();\n                }\n\n                @Override\n                public Object after(Path workingDir, ExecutionReport report) throws IOException {\n                    fail();\n                    return super.after(workingDir, report);\n                }\n            });\n\n            waitForExecution.await();\n            result.cancel(true);\n            result.get();\n            fail(\"Should not happen: result has been cancelled\");\n        } catch (CancellationException exc) {\n            //OK\n        }\n\n        waitForInterruption.await(10, TimeUnit.SECONDS);\n        assertTrue(stopped.isTrue());\n    }", "signature": "void cancelDuringExecutionShouldThrowAndEventuallyStopExecution()", "full_signature": "@Test public void cancelDuringExecutionShouldThrowAndEventuallyStopExecution()", "class_method_signature": "LocalComputationManagerTest.cancelDuringExecutionShouldThrowAndEventuallyStopExecution()", "testcase": true, "constructor": false, "invocations": ["countDown", "await", "setTrue", "countDown", "setTrue", "countDown", "commonPool", "execute", "createDefault", "dummyExecutions", "fail", "after", "await", "cancel", "get", "fail", "await", "assertTrue", "isTrue"]}, "focal_class": {"identifier": "LocalComputationManager", "superclass": "", "interfaces": "implements ComputationManager", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(LocalComputationManager.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(LocalComputationManager.class)", "var_name": "LOGGER"}, {"original_string": "private final LocalComputationConfig config;", "modifier": "private final", "type": "LocalComputationConfig", "declarator": "config", "var_name": "config"}, {"original_string": "private final WorkingDirectory commonDir;", "modifier": "private final", "type": "WorkingDirectory", "declarator": "commonDir", "var_name": "commonDir"}, {"original_string": "private final LocalComputationResourcesStatus status;", "modifier": "private final", "type": "LocalComputationResourcesStatus", "declarator": "status", "var_name": "status"}, {"original_string": "private final Semaphore permits;", "modifier": "private final", "type": "Semaphore", "declarator": "permits", "var_name": "permits"}, {"original_string": "private final Executor threadPool;", "modifier": "private final", "type": "Executor", "declarator": "threadPool", "var_name": "threadPool"}, {"original_string": "private final LocalCommandExecutor localCommandExecutor;", "modifier": "private final", "type": "LocalCommandExecutor", "declarator": "localCommandExecutor", "var_name": "localCommandExecutor"}, {"original_string": "private static final Lock LOCK = new ReentrantLock();", "modifier": "private static final", "type": "Lock", "declarator": "LOCK = new ReentrantLock()", "var_name": "LOCK"}, {"original_string": "private static LocalComputationManager defaultInstance;", "modifier": "private static", "type": "LocalComputationManager", "declarator": "defaultInstance", "var_name": "defaultInstance"}], "methods": [{"identifier": "getDefault", "parameters": "()", "modifiers": "public static", "return": "ComputationManager", "signature": "ComputationManager getDefault()", "full_signature": "public static ComputationManager getDefault()", "class_method_signature": "LocalComputationManager.getDefault()", "testcase": false, "constructor": false}, {"identifier": "getLocalCommandExecutor", "parameters": "()", "modifiers": "private static", "return": "LocalCommandExecutor", "signature": "LocalCommandExecutor getLocalCommandExecutor()", "full_signature": "private static LocalCommandExecutor getLocalCommandExecutor()", "class_method_signature": "LocalComputationManager.getLocalCommandExecutor()", "testcase": false, "constructor": false}, {"identifier": "LocalComputationManager", "parameters": "()", "modifiers": "public", "return": "", "signature": " LocalComputationManager()", "full_signature": "public  LocalComputationManager()", "class_method_signature": "LocalComputationManager.LocalComputationManager()", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(Executor executor)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(Executor executor)", "full_signature": "public  LocalComputationManager(Executor executor)", "class_method_signature": "LocalComputationManager.LocalComputationManager(Executor executor)", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(PlatformConfig platformConfig)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(PlatformConfig platformConfig)", "full_signature": "public  LocalComputationManager(PlatformConfig platformConfig)", "class_method_signature": "LocalComputationManager.LocalComputationManager(PlatformConfig platformConfig)", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(Path localDir)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(Path localDir)", "full_signature": "public  LocalComputationManager(Path localDir)", "class_method_signature": "LocalComputationManager.LocalComputationManager(Path localDir)", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(LocalComputationConfig config)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(LocalComputationConfig config)", "full_signature": "public  LocalComputationManager(LocalComputationConfig config)", "class_method_signature": "LocalComputationManager.LocalComputationManager(LocalComputationConfig config)", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(LocalComputationConfig config, Executor executor)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(LocalComputationConfig config, Executor executor)", "full_signature": "public  LocalComputationManager(LocalComputationConfig config, Executor executor)", "class_method_signature": "LocalComputationManager.LocalComputationManager(LocalComputationConfig config, Executor executor)", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(LocalComputationConfig config, LocalCommandExecutor localCommandExecutor, Executor executor)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(LocalComputationConfig config, LocalCommandExecutor localCommandExecutor, Executor executor)", "full_signature": "public  LocalComputationManager(LocalComputationConfig config, LocalCommandExecutor localCommandExecutor, Executor executor)", "class_method_signature": "LocalComputationManager.LocalComputationManager(LocalComputationConfig config, LocalCommandExecutor localCommandExecutor, Executor executor)", "testcase": false, "constructor": true}, {"identifier": "getVersion", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getVersion()", "full_signature": "@Override public String getVersion()", "class_method_signature": "LocalComputationManager.getVersion()", "testcase": false, "constructor": false}, {"identifier": "getLocalDir", "parameters": "()", "modifiers": "@Override public", "return": "Path", "signature": "Path getLocalDir()", "full_signature": "@Override public Path getLocalDir()", "class_method_signature": "LocalComputationManager.getLocalDir()", "testcase": false, "constructor": false}, {"identifier": "newCommonFile", "parameters": "(String fileName)", "modifiers": "@Override public", "return": "OutputStream", "signature": "OutputStream newCommonFile(String fileName)", "full_signature": "@Override public OutputStream newCommonFile(String fileName)", "class_method_signature": "LocalComputationManager.newCommonFile(String fileName)", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "modifiers": "private", "return": "ExecutionReport", "signature": "ExecutionReport execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "full_signature": "private ExecutionReport execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "class_method_signature": "LocalComputationManager.execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "testcase": false, "constructor": false}, {"identifier": "logExecutingCommand", "parameters": "(Path workingDir, Command command, int executionIndex)", "modifiers": "private", "return": "void", "signature": "void logExecutingCommand(Path workingDir, Command command, int executionIndex)", "full_signature": "private void logExecutingCommand(Path workingDir, Command command, int executionIndex)", "class_method_signature": "LocalComputationManager.logExecutingCommand(Path workingDir, Command command, int executionIndex)", "testcase": false, "constructor": false}, {"identifier": "preProcess", "parameters": "(Path workingDir, Command command, int executionIndex)", "modifiers": "private", "return": "void", "signature": "void preProcess(Path workingDir, Command command, int executionIndex)", "full_signature": "private void preProcess(Path workingDir, Command command, int executionIndex)", "class_method_signature": "LocalComputationManager.preProcess(Path workingDir, Command command, int executionIndex)", "testcase": false, "constructor": false}, {"identifier": "process", "parameters": "(Path workingDir, CommandExecution commandExecution, int executionIndex, Map<String, String> variables, ComputationParameters computationParameters)", "modifiers": "private", "return": "int", "signature": "int process(Path workingDir, CommandExecution commandExecution, int executionIndex, Map<String, String> variables, ComputationParameters computationParameters)", "full_signature": "private int process(Path workingDir, CommandExecution commandExecution, int executionIndex, Map<String, String> variables, ComputationParameters computationParameters)", "class_method_signature": "LocalComputationManager.process(Path workingDir, CommandExecution commandExecution, int executionIndex, Map<String, String> variables, ComputationParameters computationParameters)", "testcase": false, "constructor": false}, {"identifier": "postProcess", "parameters": "(Path workingDir, CommandExecution commandExecution, int executionIndex, int exitValue, List<ExecutionError> errors, ExecutionMonitor monitor)", "modifiers": "private", "return": "void", "signature": "void postProcess(Path workingDir, CommandExecution commandExecution, int executionIndex, int exitValue, List<ExecutionError> errors, ExecutionMonitor monitor)", "full_signature": "private void postProcess(Path workingDir, CommandExecution commandExecution, int executionIndex, int exitValue, List<ExecutionError> errors, ExecutionMonitor monitor)", "class_method_signature": "LocalComputationManager.postProcess(Path workingDir, CommandExecution commandExecution, int executionIndex, int exitValue, List<ExecutionError> errors, ExecutionMonitor monitor)", "testcase": false, "constructor": false}, {"identifier": "checkInputFileExistsInWorkingAndCommons", "parameters": "(Path workingDir, String fileName, InputFile file)", "modifiers": "private", "return": "Path", "signature": "Path checkInputFileExistsInWorkingAndCommons(Path workingDir, String fileName, InputFile file)", "full_signature": "private Path checkInputFileExistsInWorkingAndCommons(Path workingDir, String fileName, InputFile file)", "class_method_signature": "LocalComputationManager.checkInputFileExistsInWorkingAndCommons(Path workingDir, String fileName, InputFile file)", "testcase": false, "constructor": false}, {"identifier": "enter", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void enter()", "full_signature": "private void enter()", "class_method_signature": "LocalComputationManager.enter()", "testcase": false, "constructor": false}, {"identifier": "exit", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void exit()", "full_signature": "private void exit()", "class_method_signature": "LocalComputationManager.exit()", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "(ExecutionEnvironment environment, ExecutionHandler<R> handler)", "modifiers": "@Override public", "return": "CompletableFuture<R>", "signature": "CompletableFuture<R> execute(ExecutionEnvironment environment, ExecutionHandler<R> handler)", "full_signature": "@Override public CompletableFuture<R> execute(ExecutionEnvironment environment, ExecutionHandler<R> handler)", "class_method_signature": "LocalComputationManager.execute(ExecutionEnvironment environment, ExecutionHandler<R> handler)", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "modifiers": "@Override public", "return": "CompletableFuture<R>", "signature": "CompletableFuture<R> execute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "full_signature": "@Override public CompletableFuture<R> execute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "class_method_signature": "LocalComputationManager.execute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "testcase": false, "constructor": false}, {"identifier": "doExecute", "parameters": "(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "modifiers": "private", "return": "R", "signature": "R doExecute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "full_signature": "private R doExecute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "class_method_signature": "LocalComputationManager.doExecute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "testcase": false, "constructor": false}, {"identifier": "getResourcesStatus", "parameters": "()", "modifiers": "@Override public", "return": "ComputationResourcesStatus", "signature": "ComputationResourcesStatus getResourcesStatus()", "full_signature": "@Override public ComputationResourcesStatus getResourcesStatus()", "class_method_signature": "LocalComputationManager.getResourcesStatus()", "testcase": false, "constructor": false}, {"identifier": "getExecutor", "parameters": "()", "modifiers": "@Override public", "return": "Executor", "signature": "Executor getExecutor()", "full_signature": "@Override public Executor getExecutor()", "class_method_signature": "LocalComputationManager.getExecutor()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "LocalComputationManager.close()", "testcase": false, "constructor": false}], "file": "computation-local/src/main/java/com/powsybl/computation/local/LocalComputationManager.java"}, "focal_method": {"identifier": "execute", "parameters": "(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "modifiers": "private", "return": "ExecutionReport", "body": "private ExecutionReport execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)\n            throws InterruptedException {\n        // TODO concurrent\n        List<ExecutionError> errors = new ArrayList<>();\n        ExecutorService executionSubmitter = Executors.newCachedThreadPool();\n\n        for (CommandExecution commandExecution : commandExecutionList) {\n            Command command = commandExecution.getCommand();\n            CountDownLatch latch = new CountDownLatch(commandExecution.getExecutionCount());\n            IntStream.range(0, commandExecution.getExecutionCount()).forEach(idx ->\n                    executionSubmitter.execute(() -> {\n                        try {\n                            enter();\n                            logExecutingCommand(workingDir, command, idx);\n                            preProcess(workingDir, command, idx);\n                            int exitValue = process(workingDir, commandExecution, idx, variables, computationParameters);\n                            postProcess(workingDir, commandExecution, idx, exitValue, errors, monitor);\n                        } catch (Exception e) {\n                            LOGGER.warn(e.getMessage());\n                        } finally {\n                            latch.countDown();\n                            exit();\n                        }\n                    })\n            );\n            latch.await();\n        }\n\n        // TODO remove duplicated code\n        executionSubmitter.shutdown();\n        if (!executionSubmitter.awaitTermination(20, TimeUnit.SECONDS)) {\n            executionSubmitter.shutdownNow();\n            if (!executionSubmitter.awaitTermination(20, TimeUnit.SECONDS)) {\n                LOGGER.error(\"Thread pool did not terminate\");\n            }\n        }\n\n        return new DefaultExecutionReport(errors);\n    }", "signature": "ExecutionReport execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "full_signature": "private ExecutionReport execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "class_method_signature": "LocalComputationManager.execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "testcase": false, "constructor": false, "invocations": ["newCachedThreadPool", "getCommand", "getExecutionCount", "forEach", "range", "getExecutionCount", "execute", "enter", "logExecutingCommand", "preProcess", "process", "postProcess", "warn", "getMessage", "countDown", "exit", "await", "shutdown", "awaitTermination", "shutdownNow", "awaitTermination", "error"]}, "repository": {"repo_id": 105284146, "url": "https://github.com/powsybl/powsybl-core", "stars": 53, "created": "9/29/2017 2:51:18 PM +00:00", "updates": "2020-01-27T10:39:13+00:00", "fork": "False", "license": "licensed"}}