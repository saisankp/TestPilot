{"test_class": {"identifier": "ConditionalOperationTest", "superclass": "", "interfaces": "", "fields": [], "file": "operations/src/test/java/com/nextdoor/bender/operation/conditional/ConditionalOperationTest.java"}, "test_case": {"identifier": "testTwoConditions", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testTwoConditions() {\n    List<Pair<FilterOperation, List<OperationProcessor>>> conditions =\n        new ArrayList<Pair<FilterOperation, List<OperationProcessor>>>();\n    /*\n     * Case 1\n     */\n    List<OperationProcessor> case1Ops = new ArrayList<OperationProcessor>();\n\n    DummyAppendOperationFactory pos = new DummyAppendOperationFactory();\n    DummyAppendOperationConfig posConf = new DummyAppendOperationConfig();\n    posConf.setAppendStr(\"+\");\n    pos.setConf(posConf);\n    case1Ops.add(new OperationProcessor(pos));\n    FilterOperation case1Filter = new BasicFilterOperation(false);\n    conditions\n        .add(new ImmutablePair<FilterOperation, List<OperationProcessor>>(case1Filter, case1Ops));\n\n    /*\n     * Case 2\n     */\n    List<OperationProcessor> case2Ops = new ArrayList<OperationProcessor>();\n\n    DummyAppendOperationFactory neg = new DummyAppendOperationFactory();\n    DummyAppendOperationConfig negConf = new DummyAppendOperationConfig();\n    negConf.setAppendStr(\"-\");\n    neg.setConf(negConf);\n    case2Ops.add(new OperationProcessor(neg));\n    FilterOperation case2Filter = new BasicFilterOperation(true);\n    conditions\n        .add(new ImmutablePair<FilterOperation, List<OperationProcessor>>(case2Filter, case2Ops));\n\n    ConditionalOperation op = new ConditionalOperation(conditions, false);\n\n    /*\n     * Create thread that supplies input events\n     */\n    Queue<InternalEvent> inputQueue = new Queue<InternalEvent>();\n    supply(2, inputQueue);\n\n    /*\n     * Process\n     */\n    Stream<InternalEvent> input = inputQueue.stream();\n    Stream<InternalEvent> output = op.getOutputStream(input);\n\n    List<String> actual = output.map(m -> {\n      return m.getEventObj().getPayload().toString();\n    }).collect(Collectors.toList());\n    List<String> expected = Arrays.asList(\"0-\", \"1-\");\n\n    assertEquals(2, actual.size());\n    assertTrue(expected.containsAll(actual));\n  }", "signature": "void testTwoConditions()", "full_signature": "@Test public void testTwoConditions()", "class_method_signature": "ConditionalOperationTest.testTwoConditions()", "testcase": true, "constructor": false, "invocations": ["setAppendStr", "setConf", "add", "add", "setAppendStr", "setConf", "add", "add", "supply", "stream", "getOutputStream", "collect", "map", "toString", "getPayload", "getEventObj", "toList", "asList", "assertEquals", "size", "assertTrue", "containsAll"]}, "focal_class": {"identifier": "ConditionalOperation", "superclass": "", "interfaces": "implements StreamOperation", "fields": [{"original_string": "private List<Pair<FilterOperation, Queue<InternalEvent>>> filtersAndQueues;", "modifier": "private", "type": "List<Pair<FilterOperation, Queue<InternalEvent>>>", "declarator": "filtersAndQueues", "var_name": "filtersAndQueues"}, {"original_string": "private final List<Pair<FilterOperation, List<OperationProcessor>>> conditionsAndProcs;", "modifier": "private final", "type": "List<Pair<FilterOperation, List<OperationProcessor>>>", "declarator": "conditionsAndProcs", "var_name": "conditionsAndProcs"}, {"original_string": "private final ExecutorService es;", "modifier": "private final", "type": "ExecutorService", "declarator": "es", "var_name": "es"}, {"original_string": "private final boolean filterNonMatch;", "modifier": "private final", "type": "boolean", "declarator": "filterNonMatch", "var_name": "filterNonMatch"}], "methods": [{"identifier": "ConditionalOperation", "parameters": "(\n      List<Pair<FilterOperation, List<OperationProcessor>>> conditionsAndProcs,\n      boolean filterNonMatch)", "modifiers": "public", "return": "", "signature": " ConditionalOperation(\n      List<Pair<FilterOperation, List<OperationProcessor>>> conditionsAndProcs,\n      boolean filterNonMatch)", "full_signature": "public  ConditionalOperation(\n      List<Pair<FilterOperation, List<OperationProcessor>>> conditionsAndProcs,\n      boolean filterNonMatch)", "class_method_signature": "ConditionalOperation.ConditionalOperation(\n      List<Pair<FilterOperation, List<OperationProcessor>>> conditionsAndProcs,\n      boolean filterNonMatch)", "testcase": false, "constructor": true}, {"identifier": "getOutputStream", "parameters": "(Stream<InternalEvent> input)", "modifiers": "public", "return": "Stream<InternalEvent>", "signature": "Stream<InternalEvent> getOutputStream(Stream<InternalEvent> input)", "full_signature": "public Stream<InternalEvent> getOutputStream(Stream<InternalEvent> input)", "class_method_signature": "ConditionalOperation.getOutputStream(Stream<InternalEvent> input)", "testcase": false, "constructor": false}], "file": "operations/src/main/java/com/nextdoor/bender/operation/conditional/ConditionalOperation.java"}, "focal_method": {"identifier": "getOutputStream", "parameters": "(Stream<InternalEvent> input)", "modifiers": "public", "return": "Stream<InternalEvent>", "body": "public Stream<InternalEvent> getOutputStream(Stream<InternalEvent> input) {\n    /*\n     * outputStreams keeps track of the output Stream of each Condition.\n     */\n    List<Stream<InternalEvent>> outputStreams =\n        new ArrayList<Stream<InternalEvent>>(this.conditionsAndProcs.size());\n\n    /*\n     * From a list of operation configurations in each condition construct queues and streams.\n     */\n    this.filtersAndQueues =\n        new ArrayList<Pair<FilterOperation, Queue<InternalEvent>>>(this.conditionsAndProcs.size());\n    for (Pair<FilterOperation, List<OperationProcessor>> filterAndProcs : this.conditionsAndProcs) {\n\n      FilterOperation filter = filterAndProcs.getLeft();\n      List<OperationProcessor> procs = filterAndProcs.getRight();\n\n      /*\n       * Construct a Queue for each conditional. This is the input to each Condition.\n       */\n      Queue<InternalEvent> queue =\n          new Queue<InternalEvent>(new LinkedBlockingQueue<InternalEvent>(procs.size()));\n\n      this.filtersAndQueues\n          .add(new ImmutablePair<FilterOperation, Queue<InternalEvent>>(filter, queue));\n\n      /*\n       * Connect the condition's input Queue with operations. Each operation returns a stream with its\n       * operation concatenated on.\n       */\n      Stream<InternalEvent> conditionInput = queue.jdkStream();\n      for (OperationProcessor proc : procs) {\n        conditionInput = proc.perform(conditionInput);\n      }\n\n      /*\n       * Last input is the output.\n       */\n      outputStreams.add(conditionInput);\n    }\n\n    /*\n     * Condition Consumer Threads\n     * \n     * Combine each condition's output stream and write to the output Queue. When all data is consumed\n     * the last condition closes the output Queue.\n     */\n    Queue<InternalEvent> outputQueue = new Queue<InternalEvent>(\n        new LinkedBlockingQueue<InternalEvent>(this.conditionsAndProcs.size()));\n    AtomicInteger lock = new AtomicInteger(outputStreams.size());\n\n    outputStreams.forEach(stream -> {\n      this.es.execute(new StreamToQueue(stream, outputQueue, lock));\n    });\n\n    /*\n     * Consume input Stream in a thread and publish to each condition's Queue.\n     */\n    new Thread(new Runnable() {\n      @Override\n      public void run() {\n        input.forEach(ievent -> {\n          boolean matches = false;\n\n          for (Pair<FilterOperation, Queue<InternalEvent>> filterAndQueue : filtersAndQueues) {\n            FilterOperation filter = filterAndQueue.getLeft();\n\n            /*\n             * If event passes the filter offer event to queue.\n             */\n            if (filter.test(ievent)) {\n              filterAndQueue.getRight().offer(ievent);\n              matches = true;\n              break;\n            }\n          }\n\n          /*\n           * Send to output queue if no case matches\n           */\n          if (!matches && !filterNonMatch) {\n            outputQueue.offer(ievent);\n          }\n        });\n\n        /*\n         * Close queues when source queue is consumed.\n         */\n        for (Pair<FilterOperation, Queue<InternalEvent>> filterAndQueue : filtersAndQueues) {\n          filterAndQueue.getRight().close();\n        }\n      }\n    }).start();\n\n    return outputQueue.jdkStream();\n  }", "signature": "Stream<InternalEvent> getOutputStream(Stream<InternalEvent> input)", "full_signature": "public Stream<InternalEvent> getOutputStream(Stream<InternalEvent> input)", "class_method_signature": "ConditionalOperation.getOutputStream(Stream<InternalEvent> input)", "testcase": false, "constructor": false, "invocations": ["size", "size", "getLeft", "getRight", "size", "add", "jdkStream", "perform", "add", "size", "size", "forEach", "execute", "start", "forEach", "getLeft", "test", "offer", "getRight", "offer", "close", "getRight", "jdkStream"]}, "repository": {"repo_id": 75955378, "url": "https://github.com/Nextdoor/bender", "language": "Java", "is_fork": false, "fork_count": 15, "stargazer_count": 163, "size": 1503, "license": "licensed"}}