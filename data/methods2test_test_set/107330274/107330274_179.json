{"test_class": {"identifier": "DefaultLoadBalancerServiceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int MIN_TIME_IN_QUEUE_MS = 1_000;", "modifier": "private static final", "type": "int", "declarator": "MIN_TIME_IN_QUEUE_MS = 1_000", "var_name": "MIN_TIME_IN_QUEUE_MS"}, {"original_string": "private static final int FLUSH_WAIT_TIME_MS = 2 * MIN_TIME_IN_QUEUE_MS;", "modifier": "private static final", "type": "int", "declarator": "FLUSH_WAIT_TIME_MS = 2 * MIN_TIME_IN_QUEUE_MS", "var_name": "FLUSH_WAIT_TIME_MS"}, {"original_string": "private TitusRuntime runtime;", "modifier": "private", "type": "TitusRuntime", "declarator": "runtime", "var_name": "runtime"}, {"original_string": "private LoadBalancerConnector client;", "modifier": "private", "type": "LoadBalancerConnector", "declarator": "client", "var_name": "client"}, {"original_string": "private V3JobOperations v3JobOperations;", "modifier": "private", "type": "V3JobOperations", "declarator": "v3JobOperations", "var_name": "v3JobOperations"}, {"original_string": "private LoadBalancerJobOperations loadBalancerJobOperations;", "modifier": "private", "type": "LoadBalancerJobOperations", "declarator": "loadBalancerJobOperations", "var_name": "loadBalancerJobOperations"}, {"original_string": "private LoadBalancerStore loadBalancerStore;", "modifier": "private", "type": "LoadBalancerStore", "declarator": "loadBalancerStore", "var_name": "loadBalancerStore"}, {"original_string": "private LoadBalancerReconciler reconciler;", "modifier": "private", "type": "LoadBalancerReconciler", "declarator": "reconciler", "var_name": "reconciler"}, {"original_string": "private PublishSubject<TargetStateBatchable> reconcilerEvents;", "modifier": "private", "type": "PublishSubject<TargetStateBatchable>", "declarator": "reconcilerEvents", "var_name": "reconcilerEvents"}, {"original_string": "private LoadBalancerJobValidator validator;", "modifier": "private", "type": "LoadBalancerJobValidator", "declarator": "validator", "var_name": "validator"}, {"original_string": "private TestScheduler testScheduler;", "modifier": "private", "type": "TestScheduler", "declarator": "testScheduler", "var_name": "testScheduler"}, {"original_string": "private CallMetadata callMetadata = CallMetadata.newBuilder().withCallerId(\"Load Balancer test\").build();", "modifier": "private", "type": "CallMetadata", "declarator": "callMetadata = CallMetadata.newBuilder().withCallerId(\"Load Balancer test\").build()", "var_name": "callMetadata"}], "file": "titus-server-master/src/test/java/com/netflix/titus/master/loadbalancer/service/DefaultLoadBalancerServiceTest.java"}, "test_case": {"identifier": "backfillsCurrentTargetsToStore", "parameters": "()", "modifiers": "@Test(timeout = 30_000) public", "return": "void", "body": "@Test(timeout = 30_000)\n    public void backfillsCurrentTargetsToStore() {\n        String jobId = UUID.randomUUID().toString();\n        String associatedId = \"lb-\" + UUID.randomUUID().toString();\n        String dissociatedId = \"lb-\" + UUID.randomUUID().toString();\n        String removedId = \"lb-\" + UUID.randomUUID().toString();\n\n        LoadBalancerConfiguration configuration = LoadBalancerTests.mockConfiguration(MIN_TIME_IN_QUEUE_MS);\n        when(configuration.isTargetsToStoreBackfillEnabled()).thenReturn(true);\n        when(configuration.getStoreBackfillConcurrencyLimit()).thenReturn(10);\n        when(configuration.getStoreBackfillTimeoutMs()).thenReturn(5000L);\n\n        // current load balancer state (targets)\n        when(client.getLoadBalancer(associatedId)).thenReturn(Single.just(\n                new LoadBalancer(associatedId, LoadBalancer.State.ACTIVE, CollectionsExt.asSet(\n                        \"1.1.1.1\", \"2.2.2.2\", \"3.3.3.3\"\n                ))\n        ));\n        when(client.getLoadBalancer(dissociatedId)).thenReturn(Single.just(\n                new LoadBalancer(dissociatedId, LoadBalancer.State.ACTIVE, CollectionsExt.asSet(\n                        \"4.4.4.4\", \"5.5.5.5\", \"6.6.6.6\"\n                ))\n        ));\n        when(client.getLoadBalancer(removedId)).thenReturn(Single.just(\n                new LoadBalancer(removedId, LoadBalancer.State.REMOVED, Collections.emptySet())\n        ));\n\n        // current load balancers we are managing\n        loadBalancerStore.addOrUpdateLoadBalancer(\n                new JobLoadBalancer(jobId, associatedId), JobLoadBalancer.State.ASSOCIATED\n        ).await();\n        loadBalancerStore.addOrUpdateLoadBalancer(\n                new JobLoadBalancer(jobId, dissociatedId), JobLoadBalancer.State.DISSOCIATED\n        ).await();\n        loadBalancerStore.addOrUpdateLoadBalancer(\n                new JobLoadBalancer(jobId, removedId), JobLoadBalancer.State.ASSOCIATED\n        ).await();\n\n        DefaultLoadBalancerService service = new DefaultLoadBalancerService(runtime, configuration, client,\n                loadBalancerStore, loadBalancerJobOperations, reconciler, validator, testScheduler);\n\n        service.backfillTargetsToStore();\n\n        assertThat(loadBalancerStore.getLoadBalancerTargets(associatedId).collectList().block())\n                .containsExactlyInAnyOrder(\n                        new LoadBalancerTargetState(\n                                new LoadBalancerTarget(associatedId, \"BACKFILLED\", \"1.1.1.1\"), REGISTERED\n                        ),\n                        new LoadBalancerTargetState(\n                                new LoadBalancerTarget(associatedId, \"BACKFILLED\", \"2.2.2.2\"), REGISTERED\n                        ),\n                        new LoadBalancerTargetState(\n                                new LoadBalancerTarget(associatedId, \"BACKFILLED\", \"3.3.3.3\"), REGISTERED\n                        )\n                );\n\n        assertThat(loadBalancerStore.getLoadBalancerTargets(dissociatedId).collectList().block())\n                .containsExactlyInAnyOrder(\n                        new LoadBalancerTargetState(\n                                new LoadBalancerTarget(dissociatedId, \"BACKFILLED\", \"4.4.4.4\"), REGISTERED\n                        ),\n                        new LoadBalancerTargetState(\n                                new LoadBalancerTarget(dissociatedId, \"BACKFILLED\", \"5.5.5.5\"), REGISTERED\n                        ),\n                        new LoadBalancerTargetState(\n                                new LoadBalancerTarget(dissociatedId, \"BACKFILLED\", \"6.6.6.6\"), REGISTERED\n                        )\n                );\n\n        assertThat(loadBalancerStore.getLoadBalancerTargets(removedId).collectList().block()).isEmpty();\n    }", "signature": "void backfillsCurrentTargetsToStore()", "full_signature": "@Test(timeout = 30_000) public void backfillsCurrentTargetsToStore()", "class_method_signature": "DefaultLoadBalancerServiceTest.backfillsCurrentTargetsToStore()", "testcase": true, "constructor": false, "invocations": ["toString", "randomUUID", "toString", "randomUUID", "toString", "randomUUID", "toString", "randomUUID", "mockConfiguration", "thenReturn", "when", "isTargetsToStoreBackfillEnabled", "thenReturn", "when", "getStoreBackfillConcurrencyLimit", "thenReturn", "when", "getStoreBackfillTimeoutMs", "thenReturn", "when", "getLoadBalancer", "just", "asSet", "thenReturn", "when", "getLoadBalancer", "just", "asSet", "thenReturn", "when", "getLoadBalancer", "just", "emptySet", "await", "addOrUpdateLoadBalancer", "await", "addOrUpdateLoadBalancer", "await", "addOrUpdateLoadBalancer", "backfillTargetsToStore", "containsExactlyInAnyOrder", "assertThat", "block", "collectList", "getLoadBalancerTargets", "containsExactlyInAnyOrder", "assertThat", "block", "collectList", "getLoadBalancerTargets", "isEmpty", "assertThat", "block", "collectList", "getLoadBalancerTargets"]}, "focal_class": {"identifier": "DefaultLoadBalancerService", "superclass": "", "interfaces": "implements LoadBalancerService", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(DefaultLoadBalancerService.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(DefaultLoadBalancerService.class)", "var_name": "logger"}, {"original_string": "private final TitusRuntime runtime;", "modifier": "private final", "type": "TitusRuntime", "declarator": "runtime", "var_name": "runtime"}, {"original_string": "private final LoadBalancerConfiguration configuration;", "modifier": "private final", "type": "LoadBalancerConfiguration", "declarator": "configuration", "var_name": "configuration"}, {"original_string": "private final LoadBalancerConnector loadBalancerConnector;", "modifier": "private final", "type": "LoadBalancerConnector", "declarator": "loadBalancerConnector", "var_name": "loadBalancerConnector"}, {"original_string": "private final LoadBalancerStore loadBalancerStore;", "modifier": "private final", "type": "LoadBalancerStore", "declarator": "loadBalancerStore", "var_name": "loadBalancerStore"}, {"original_string": "private final LoadBalancerJobValidator validator;", "modifier": "private final", "type": "LoadBalancerJobValidator", "declarator": "validator", "var_name": "validator"}, {"original_string": "private final LoadBalancerReconciler reconciler;", "modifier": "private final", "type": "LoadBalancerReconciler", "declarator": "reconciler", "var_name": "reconciler"}, {"original_string": "private final LoadBalancerEngine engine;", "modifier": "private final", "type": "LoadBalancerEngine", "declarator": "engine", "var_name": "engine"}, {"original_string": "private final Scheduler scheduler;", "modifier": "private final", "type": "Scheduler", "declarator": "scheduler", "var_name": "scheduler"}, {"original_string": "private Subscription loadBalancerBatches;", "modifier": "private", "type": "Subscription", "declarator": "loadBalancerBatches", "var_name": "loadBalancerBatches"}], "methods": [{"identifier": "DefaultLoadBalancerService", "parameters": "(TitusRuntime runtime,\n                                      LoadBalancerConfiguration configuration,\n                                      LoadBalancerConnector loadBalancerConnector,\n                                      LoadBalancerStore loadBalancerStore,\n                                      V3JobOperations v3JobOperations,\n                                      LoadBalancerJobValidator validator)", "modifiers": "@Inject public", "return": "", "signature": " DefaultLoadBalancerService(TitusRuntime runtime,\n                                      LoadBalancerConfiguration configuration,\n                                      LoadBalancerConnector loadBalancerConnector,\n                                      LoadBalancerStore loadBalancerStore,\n                                      V3JobOperations v3JobOperations,\n                                      LoadBalancerJobValidator validator)", "full_signature": "@Inject public  DefaultLoadBalancerService(TitusRuntime runtime,\n                                      LoadBalancerConfiguration configuration,\n                                      LoadBalancerConnector loadBalancerConnector,\n                                      LoadBalancerStore loadBalancerStore,\n                                      V3JobOperations v3JobOperations,\n                                      LoadBalancerJobValidator validator)", "class_method_signature": "DefaultLoadBalancerService.DefaultLoadBalancerService(TitusRuntime runtime,\n                                      LoadBalancerConfiguration configuration,\n                                      LoadBalancerConnector loadBalancerConnector,\n                                      LoadBalancerStore loadBalancerStore,\n                                      V3JobOperations v3JobOperations,\n                                      LoadBalancerJobValidator validator)", "testcase": false, "constructor": true}, {"identifier": "DefaultLoadBalancerService", "parameters": "(TitusRuntime runtime,\n                               LoadBalancerConfiguration configuration,\n                               LoadBalancerConnector loadBalancerConnector,\n                               LoadBalancerStore loadBalancerStore,\n                               LoadBalancerJobOperations loadBalancerJobOperations,\n                               LoadBalancerReconciler reconciler,\n                               LoadBalancerJobValidator validator,\n                               Scheduler scheduler)", "modifiers": "@VisibleForTesting", "return": "", "signature": " DefaultLoadBalancerService(TitusRuntime runtime,\n                               LoadBalancerConfiguration configuration,\n                               LoadBalancerConnector loadBalancerConnector,\n                               LoadBalancerStore loadBalancerStore,\n                               LoadBalancerJobOperations loadBalancerJobOperations,\n                               LoadBalancerReconciler reconciler,\n                               LoadBalancerJobValidator validator,\n                               Scheduler scheduler)", "full_signature": "@VisibleForTesting  DefaultLoadBalancerService(TitusRuntime runtime,\n                               LoadBalancerConfiguration configuration,\n                               LoadBalancerConnector loadBalancerConnector,\n                               LoadBalancerStore loadBalancerStore,\n                               LoadBalancerJobOperations loadBalancerJobOperations,\n                               LoadBalancerReconciler reconciler,\n                               LoadBalancerJobValidator validator,\n                               Scheduler scheduler)", "class_method_signature": "DefaultLoadBalancerService.DefaultLoadBalancerService(TitusRuntime runtime,\n                               LoadBalancerConfiguration configuration,\n                               LoadBalancerConnector loadBalancerConnector,\n                               LoadBalancerStore loadBalancerStore,\n                               LoadBalancerJobOperations loadBalancerJobOperations,\n                               LoadBalancerReconciler reconciler,\n                               LoadBalancerJobValidator validator,\n                               Scheduler scheduler)", "testcase": false, "constructor": true}, {"identifier": "getJobLoadBalancers", "parameters": "(String jobId)", "modifiers": "@Override public", "return": "Observable<String>", "signature": "Observable<String> getJobLoadBalancers(String jobId)", "full_signature": "@Override public Observable<String> getJobLoadBalancers(String jobId)", "class_method_signature": "DefaultLoadBalancerService.getJobLoadBalancers(String jobId)", "testcase": false, "constructor": false}, {"identifier": "getAllLoadBalancers", "parameters": "(Page page)", "modifiers": "@Override public", "return": "Pair<List<JobLoadBalancer>, Pagination>", "signature": "Pair<List<JobLoadBalancer>, Pagination> getAllLoadBalancers(Page page)", "full_signature": "@Override public Pair<List<JobLoadBalancer>, Pagination> getAllLoadBalancers(Page page)", "class_method_signature": "DefaultLoadBalancerService.getAllLoadBalancers(Page page)", "testcase": false, "constructor": false}, {"identifier": "addLoadBalancer", "parameters": "(String jobId, String loadBalancerId)", "modifiers": "@Override public", "return": "Completable", "signature": "Completable addLoadBalancer(String jobId, String loadBalancerId)", "full_signature": "@Override public Completable addLoadBalancer(String jobId, String loadBalancerId)", "class_method_signature": "DefaultLoadBalancerService.addLoadBalancer(String jobId, String loadBalancerId)", "testcase": false, "constructor": false}, {"identifier": "removeLoadBalancer", "parameters": "(String jobId, String loadBalancerId)", "modifiers": "@Override public", "return": "Completable", "signature": "Completable removeLoadBalancer(String jobId, String loadBalancerId)", "full_signature": "@Override public Completable removeLoadBalancer(String jobId, String loadBalancerId)", "class_method_signature": "DefaultLoadBalancerService.removeLoadBalancer(String jobId, String loadBalancerId)", "testcase": false, "constructor": false}, {"identifier": "activate", "parameters": "()", "modifiers": "@Activator public", "return": "void", "signature": "void activate()", "full_signature": "@Activator public void activate()", "class_method_signature": "DefaultLoadBalancerService.activate()", "testcase": false, "constructor": false}, {"identifier": "logBatchInfo", "parameters": "(Batch<TargetStateBatchable, String> batch)", "modifiers": "private", "return": "void", "signature": "void logBatchInfo(Batch<TargetStateBatchable, String> batch)", "full_signature": "private void logBatchInfo(Batch<TargetStateBatchable, String> batch)", "class_method_signature": "DefaultLoadBalancerService.logBatchInfo(Batch<TargetStateBatchable, String> batch)", "testcase": false, "constructor": false}, {"identifier": "deactivate", "parameters": "()", "modifiers": "@Deactivator public", "return": "void", "signature": "void deactivate()", "full_signature": "@Deactivator public void deactivate()", "class_method_signature": "DefaultLoadBalancerService.deactivate()", "testcase": false, "constructor": false}, {"identifier": "events", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "Observable<Batch<TargetStateBatchable, String>>", "signature": "Observable<Batch<TargetStateBatchable, String>> events()", "full_signature": "@VisibleForTesting Observable<Batch<TargetStateBatchable, String>> events()", "class_method_signature": "DefaultLoadBalancerService.events()", "testcase": false, "constructor": false}, {"identifier": "backfillTargetsToStore", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void backfillTargetsToStore()", "full_signature": "@VisibleForTesting void backfillTargetsToStore()", "class_method_signature": "DefaultLoadBalancerService.backfillTargetsToStore()", "testcase": false, "constructor": false}, {"identifier": "backfillTargetsToStore", "parameters": "(LoadBalancer loadBalancer)", "modifiers": "private", "return": "Mono<Void>", "signature": "Mono<Void> backfillTargetsToStore(LoadBalancer loadBalancer)", "full_signature": "private Mono<Void> backfillTargetsToStore(LoadBalancer loadBalancer)", "class_method_signature": "DefaultLoadBalancerService.backfillTargetsToStore(LoadBalancer loadBalancer)", "testcase": false, "constructor": false}], "file": "titus-server-master/src/main/java/com/netflix/titus/master/loadbalancer/service/DefaultLoadBalancerService.java"}, "focal_method": {"identifier": "backfillTargetsToStore", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "void", "body": "@VisibleForTesting\n    void backfillTargetsToStore() {\n        Observable<Single<LoadBalancer>> fetchLoadBalancerOperations = loadBalancerStore.getAssociations().stream()\n                .map(a -> a.getJobLoadBalancer().getLoadBalancerId())\n                .map(loadBalancerId -> loadBalancerConnector.getLoadBalancer(loadBalancerId)\n                        // 404s will not error, and just return a LoadBalancer with state=REMOVED and no registered targets\n                        .retryWhen(RetryHandlerBuilder.retryHandler()\n                                .withRetryDelay(10, TimeUnit.MILLISECONDS)\n                                .withRetryCount(10)\n                                .buildExponentialBackoff()\n                        )\n                )\n                .collect(Collectors.collectingAndThen(Collectors.toList(), Observable::from));\n\n        try {\n            int concurrency = configuration.getStoreBackfillConcurrencyLimit();\n            ReactorExt.toFlux(Single.mergeDelayError(fetchLoadBalancerOperations, concurrency))\n                    .flatMap(this::backfillTargetsToStore)\n                    .ignoreElements()\n                    .block(Duration.ofMillis(configuration.getStoreBackfillTimeoutMs()));\n        } catch (Exception e) {\n            Registry registry = runtime.getRegistry();\n            registry.counter(registry.createId(\"titus.loadbalancer.service.backfillErrors\",\n                    \"error\", e.getClass().getSimpleName()\n            )).increment();\n\n            // swallow the error so we do not prevent activation of the leader\n            // regular operations will not be affected by the incomplete backfill, but targets may leak until remaining\n            // targets get backfilled during the next run\n            logger.error(\"Backfill did not complete successfully, missing targets may be orphaned and leak on load balancers (i.e. never deregistered)\", e);\n        }\n    }", "signature": "void backfillTargetsToStore()", "full_signature": "@VisibleForTesting void backfillTargetsToStore()", "class_method_signature": "DefaultLoadBalancerService.backfillTargetsToStore()", "testcase": false, "constructor": false, "invocations": ["collect", "map", "map", "stream", "getAssociations", "getLoadBalancerId", "getJobLoadBalancer", "retryWhen", "getLoadBalancer", "buildExponentialBackoff", "withRetryCount", "withRetryDelay", "retryHandler", "collectingAndThen", "toList", "getStoreBackfillConcurrencyLimit", "block", "ignoreElements", "flatMap", "toFlux", "mergeDelayError", "ofMillis", "getStoreBackfillTimeoutMs", "getRegistry", "increment", "counter", "createId", "getSimpleName", "getClass", "error"]}, "repository": {"repo_id": 107330274, "url": "https://github.com/Netflix/titus-control-plane", "stars": 241, "created": "10/17/2017 10:20:55 PM +00:00", "updates": "2020-01-25T13:01:05+00:00", "fork": "False", "license": "licensed"}}