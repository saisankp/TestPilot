{"test_class": {"identifier": "RedisProtocolTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();", "modifier": "private", "type": "Protocol", "declarator": "protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()", "var_name": "protocol"}, {"original_string": "private ProxyFactory proxy = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();", "modifier": "private", "type": "ProxyFactory", "declarator": "proxy = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension()", "var_name": "proxy"}, {"original_string": "private RedisServer redisServer;", "modifier": "private", "type": "RedisServer", "declarator": "redisServer", "var_name": "redisServer"}, {"original_string": "private URL registryUrl;", "modifier": "private", "type": "URL", "declarator": "registryUrl", "var_name": "registryUrl"}, {"original_string": "@Rule\n    public TestName name = new TestName();", "modifier": "@Rule\n    public", "type": "TestName", "declarator": "name = new TestName()", "var_name": "name"}], "file": "dubbo-rpc/dubbo-rpc-redis/src/test/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocolTest.java"}, "test_case": {"identifier": "testWrongAuthRedis", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testWrongAuthRedis() {\n        String password = \"1234567\";\n        this.registryUrl = this.registryUrl.setPassword(password);\n        Invoker<IDemoService> refer = protocol.refer(IDemoService.class,\n                registryUrl\n                        .addParameter(\"max.idle\", 10)\n                        .addParameter(\"max.active\", 20));\n        IDemoService demoService = this.proxy.getProxy(refer);\n\n        try {\n            String value = demoService.get(\"key\");\n            assertThat(value, is(nullValue()));\n        } catch (RpcException e) {\n            if (e.getCause() instanceof JedisConnectionException && e.getCause().getCause() instanceof JedisDataException) {\n                Assert.assertEquals(\"ERR invalid password\" , e.getCause().getCause().getMessage());\n            } else {\n                Assert.fail(\"no invalid password exception!\");\n            }\n        }\n\n        refer.destroy();\n    }", "signature": "void testWrongAuthRedis()", "full_signature": "@Test public void testWrongAuthRedis()", "class_method_signature": "RedisProtocolTest.testWrongAuthRedis()", "testcase": true, "constructor": false, "invocations": ["setPassword", "refer", "addParameter", "addParameter", "getProxy", "get", "assertThat", "is", "nullValue", "getCause", "getCause", "getCause", "assertEquals", "getMessage", "getCause", "getCause", "fail", "destroy"]}, "focal_class": {"identifier": "RedisProtocol", "superclass": "extends AbstractProtocol", "interfaces": "", "fields": [{"original_string": "public static final int DEFAULT_PORT = 6379;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_PORT = 6379", "var_name": "DEFAULT_PORT"}], "methods": [{"identifier": "getDefaultPort", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getDefaultPort()", "full_signature": "@Override public int getDefaultPort()", "class_method_signature": "RedisProtocol.getDefaultPort()", "testcase": false, "constructor": false}, {"identifier": "export", "parameters": "(final Invoker<T> invoker)", "modifiers": "@Override public", "return": "Exporter<T>", "signature": "Exporter<T> export(final Invoker<T> invoker)", "full_signature": "@Override public Exporter<T> export(final Invoker<T> invoker)", "class_method_signature": "RedisProtocol.export(final Invoker<T> invoker)", "testcase": false, "constructor": false}, {"identifier": "getSerialization", "parameters": "(URL url)", "modifiers": "private", "return": "Serialization", "signature": "Serialization getSerialization(URL url)", "full_signature": "private Serialization getSerialization(URL url)", "class_method_signature": "RedisProtocol.getSerialization(URL url)", "testcase": false, "constructor": false}, {"identifier": "refer", "parameters": "(final Class<T> type, final URL url)", "modifiers": "@Override public", "return": "Invoker<T>", "signature": "Invoker<T> refer(final Class<T> type, final URL url)", "full_signature": "@Override public Invoker<T> refer(final Class<T> type, final URL url)", "class_method_signature": "RedisProtocol.refer(final Class<T> type, final URL url)", "testcase": false, "constructor": false}], "file": "dubbo-rpc/dubbo-rpc-redis/src/main/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocol.java"}, "focal_method": {"identifier": "refer", "parameters": "(final Class<T> type, final URL url)", "modifiers": "@Override public", "return": "Invoker<T>", "body": "@Override\n    public <T> Invoker<T> refer(final Class<T> type, final URL url) throws RpcException {\n        try {\n            GenericObjectPoolConfig config = new GenericObjectPoolConfig();\n            config.setTestOnBorrow(url.getParameter(\"test.on.borrow\", true));\n            config.setTestOnReturn(url.getParameter(\"test.on.return\", false));\n            config.setTestWhileIdle(url.getParameter(\"test.while.idle\", false));\n            if (url.getParameter(\"max.idle\", 0) > 0)\n                config.setMaxIdle(url.getParameter(\"max.idle\", 0));\n            if (url.getParameter(\"min.idle\", 0) > 0)\n                config.setMinIdle(url.getParameter(\"min.idle\", 0));\n            if (url.getParameter(\"max.active\", 0) > 0)\n                config.setMaxTotal(url.getParameter(\"max.active\", 0));\n            if (url.getParameter(\"max.total\", 0) > 0)\n                config.setMaxTotal(url.getParameter(\"max.total\", 0));\n            if (url.getParameter(\"max.wait\", 0) > 0)\n                config.setMaxWaitMillis(url.getParameter(\"max.wait\", 0));\n            if (url.getParameter(\"num.tests.per.eviction.run\", 0) > 0)\n                config.setNumTestsPerEvictionRun(url.getParameter(\"num.tests.per.eviction.run\", 0));\n            if (url.getParameter(\"time.between.eviction.runs.millis\", 0) > 0)\n                config.setTimeBetweenEvictionRunsMillis(url.getParameter(\"time.between.eviction.runs.millis\", 0));\n            if (url.getParameter(\"min.evictable.idle.time.millis\", 0) > 0)\n                config.setMinEvictableIdleTimeMillis(url.getParameter(\"min.evictable.idle.time.millis\", 0));\n            final JedisPool jedisPool = new JedisPool(config, url.getHost(), url.getPort(DEFAULT_PORT),\n                    url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT),\n                    StringUtils.isBlank(url.getPassword()) ? null : url.getPassword(),\n                    url.getParameter(\"db.index\", 0));\n            final int expiry = url.getParameter(\"expiry\", 0);\n            final String get = url.getParameter(\"get\", \"get\");\n            final String set = url.getParameter(\"set\", Map.class.equals(type) ? \"put\" : \"set\");\n            final String delete = url.getParameter(\"delete\", Map.class.equals(type) ? \"remove\" : \"delete\");\n            return new AbstractInvoker<T>(type, url) {\n                @Override\n                protected Result doInvoke(Invocation invocation) throws Throwable {\n                    Jedis resource = null;\n                    try {\n                        resource = jedisPool.getResource();\n\n                        if (get.equals(invocation.getMethodName())) {\n                            if (invocation.getArguments().length != 1) {\n                                throw new IllegalArgumentException(\"The redis get method arguments mismatch, must only one arguments. interface: \" + type.getName() + \", method: \" + invocation.getMethodName() + \", url: \" + url);\n                            }\n                            byte[] value = resource.get(String.valueOf(invocation.getArguments()[0]).getBytes());\n                            if (value == null) {\n                                return new RpcResult();\n                            }\n                            ObjectInput oin = getSerialization(url).deserialize(url, new ByteArrayInputStream(value));\n                            return new RpcResult(oin.readObject());\n                        } else if (set.equals(invocation.getMethodName())) {\n                            if (invocation.getArguments().length != 2) {\n                                throw new IllegalArgumentException(\"The redis set method arguments mismatch, must be two arguments. interface: \" + type.getName() + \", method: \" + invocation.getMethodName() + \", url: \" + url);\n                            }\n                            byte[] key = String.valueOf(invocation.getArguments()[0]).getBytes();\n                            ByteArrayOutputStream output = new ByteArrayOutputStream();\n                            ObjectOutput value = getSerialization(url).serialize(url, output);\n                            value.writeObject(invocation.getArguments()[1]);\n                            resource.set(key, output.toByteArray());\n                            if (expiry > 1000) {\n                                resource.expire(key, expiry / 1000);\n                            }\n                            return new RpcResult();\n                        } else if (delete.equals(invocation.getMethodName())) {\n                            if (invocation.getArguments().length != 1) {\n                                throw new IllegalArgumentException(\"The redis delete method arguments mismatch, must only one arguments. interface: \" + type.getName() + \", method: \" + invocation.getMethodName() + \", url: \" + url);\n                            }\n                            resource.del(String.valueOf(invocation.getArguments()[0]).getBytes());\n                            return new RpcResult();\n                        } else {\n                            throw new UnsupportedOperationException(\"Unsupported method \" + invocation.getMethodName() + \" in redis service.\");\n                        }\n                    } catch (Throwable t) {\n                        RpcException re = new RpcException(\"Failed to invoke redis service method. interface: \" + type.getName() + \", method: \" + invocation.getMethodName() + \", url: \" + url + \", cause: \" + t.getMessage(), t);\n                        if (t instanceof TimeoutException || t instanceof SocketTimeoutException) {\n                            re.setCode(RpcException.TIMEOUT_EXCEPTION);\n                        } else if (t instanceof JedisConnectionException || t instanceof IOException) {\n                            re.setCode(RpcException.NETWORK_EXCEPTION);\n                        } else if (t instanceof JedisDataException) {\n                            re.setCode(RpcException.SERIALIZATION_EXCEPTION);\n                        }\n                        throw re;\n                    } finally {\n                        if (resource != null) {\n                            try {\n                                jedisPool.returnResource(resource);\n                            } catch (Throwable t) {\n                                logger.warn(\"returnResource error: \" + t.getMessage(), t);\n                            }\n                        }\n                    }\n                }\n\n                @Override\n                public void destroy() {\n                    super.destroy();\n                    try {\n                        jedisPool.destroy();\n                    } catch (Throwable e) {\n                        logger.warn(e.getMessage(), e);\n                    }\n                }\n            };\n        } catch (Throwable t) {\n            throw new RpcException(\"Failed to refer redis service. interface: \" + type.getName() + \", url: \" + url + \", cause: \" + t.getMessage(), t);\n        }\n    }", "signature": "Invoker<T> refer(final Class<T> type, final URL url)", "full_signature": "@Override public Invoker<T> refer(final Class<T> type, final URL url)", "class_method_signature": "RedisProtocol.refer(final Class<T> type, final URL url)", "testcase": false, "constructor": false, "invocations": ["setTestOnBorrow", "getParameter", "setTestOnReturn", "getParameter", "setTestWhileIdle", "getParameter", "getParameter", "setMaxIdle", "getParameter", "getParameter", "setMinIdle", "getParameter", "getParameter", "setMaxTotal", "getParameter", "getParameter", "setMaxTotal", "getParameter", "getParameter", "setMaxWaitMillis", "getParameter", "getParameter", "setNumTestsPerEvictionRun", "getParameter", "getParameter", "setTimeBetweenEvictionRunsMillis", "getParameter", "getParameter", "setMinEvictableIdleTimeMillis", "getParameter", "getHost", "getPort", "getParameter", "isBlank", "getPassword", "getPassword", "getParameter", "getParameter", "getParameter", "getParameter", "equals", "getParameter", "equals", "getResource", "equals", "getMethodName", "getArguments", "getName", "getMethodName", "get", "getBytes", "valueOf", "getArguments", "deserialize", "getSerialization", "readObject", "equals", "getMethodName", "getArguments", "getName", "getMethodName", "getBytes", "valueOf", "getArguments", "serialize", "getSerialization", "writeObject", "getArguments", "set", "toByteArray", "expire", "equals", "getMethodName", "getArguments", "getName", "getMethodName", "del", "getBytes", "valueOf", "getArguments", "getMethodName", "getName", "getMethodName", "getMessage", "setCode", "setCode", "setCode", "returnResource", "warn", "getMessage", "destroy", "destroy", "warn", "getMessage", "getName", "getMessage"]}, "repository": {"repo_id": 189562861, "url": "https://github.com/smallFive55/dubbo-dubbo-2.6.6", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 8, "size": 1428, "license": "licensed"}}