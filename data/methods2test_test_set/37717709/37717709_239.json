{"test_class": {"identifier": "TestMarcFeedback", "superclass": "", "interfaces": "implements SynthesizedOutputListener", "fields": [{"original_string": "private final Object lock;", "modifier": "private final", "type": "Object", "declarator": "lock", "var_name": "lock"}, {"original_string": "private SynthesizedOutputEvent event;", "modifier": "private", "type": "SynthesizedOutputEvent", "declarator": "event", "var_name": "event"}], "file": "org.jvoicexml.implementation.marc/src/test/java/org/jvoicexml/implementation/marc/TestMarcFeedback.java"}, "test_case": {"identifier": "testRun", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRun() throws Exception, JVoiceXMLEvent {\n        final MarcSynthesizedOutput output = new MarcSynthesizedOutput();\n        output.connect(null);\n        output.addListener(this);\n        final SpeakableText speakable = new SpeakableSsmlText(\"test\",\n                Locale.US);\n        final String sessionId = UUID.randomUUID().toString();\n        output.queueSpeakable(speakable, sessionId, null);\n        final MarcFeedback feedback = new MarcFeedback(output, 4011);\n        final DatagramSocket server = new DatagramSocket(4012);\n        feedback.start();\n        Thread.sleep(1000);\n        final String msg = \"<event id=\\\"JVoiceXMLTrack:end\\\"/>\";\n        final byte[] buf = msg.getBytes();\n        final InetAddress address = Inet4Address.getLocalHost();\n        final DatagramPacket packet = new DatagramPacket(buf, buf.length,\n                address, 4011);\n        server.send(packet);\n        final String msg2 = \"<event id=\\\"SpeechCommand:end\\\"/>\";\n        final byte[] buf2 = msg2.getBytes();\n        final DatagramPacket packet2 = new DatagramPacket(buf2, buf2.length,\n                address, 4011);\n        server.send(packet2);\n        synchronized (lock) {\n            lock.wait();\n        }\n        Assert.assertTrue(event instanceof OutputEndedEvent);\n        final OutputEndedEvent endedEvent = (OutputEndedEvent) event;\n        Assert.assertEquals(speakable, endedEvent.getSpeakable());\n    }", "signature": "void testRun()", "full_signature": "@Test public void testRun()", "class_method_signature": "TestMarcFeedback.testRun()", "testcase": true, "constructor": false, "invocations": ["connect", "addListener", "toString", "randomUUID", "queueSpeakable", "start", "sleep", "getBytes", "getLocalHost", "send", "getBytes", "send", "wait", "assertTrue", "assertEquals", "getSpeakable"]}, "focal_class": {"identifier": "MarcFeedback", "superclass": "extends Thread", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER =\n            Logger.getLogger(MarcFeedback.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER =\n            Logger.getLogger(MarcFeedback.class)", "var_name": "LOGGER"}, {"original_string": "private static final int BUFFER_SIZE = 1024;", "modifier": "private static final", "type": "int", "declarator": "BUFFER_SIZE = 1024", "var_name": "BUFFER_SIZE"}, {"original_string": "private final int port;", "modifier": "private final", "type": "int", "declarator": "port", "var_name": "port"}, {"original_string": "private final DatagramSocket socket;", "modifier": "private final", "type": "DatagramSocket", "declarator": "socket", "var_name": "socket"}, {"original_string": "private final MarcSynthesizedOutput output;", "modifier": "private final", "type": "MarcSynthesizedOutput", "declarator": "output", "var_name": "output"}], "methods": [{"identifier": "MarcFeedback", "parameters": "(final MarcSynthesizedOutput marcOutput,\n            final int portNumber)", "modifiers": "public", "return": "", "signature": " MarcFeedback(final MarcSynthesizedOutput marcOutput,\n            final int portNumber)", "full_signature": "public  MarcFeedback(final MarcSynthesizedOutput marcOutput,\n            final int portNumber)", "class_method_signature": "MarcFeedback.MarcFeedback(final MarcSynthesizedOutput marcOutput,\n            final int portNumber)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "MarcFeedback.run()", "testcase": false, "constructor": false}, {"identifier": "parseId", "parameters": "(final String response)", "modifiers": "private", "return": "String", "signature": "String parseId(final String response)", "full_signature": "private String parseId(final String response)", "class_method_signature": "MarcFeedback.parseId(final String response)", "testcase": false, "constructor": false}, {"identifier": "isEndOfSpeech", "parameters": "(final String id)", "modifiers": "private", "return": "boolean", "signature": "boolean isEndOfSpeech(final String id)", "full_signature": "private boolean isEndOfSpeech(final String id)", "class_method_signature": "MarcFeedback.isEndOfSpeech(final String id)", "testcase": false, "constructor": false}], "file": "org.jvoicexml.implementation.marc/src/main/java/org/jvoicexml/implementation/marc/MarcFeedback.java"}, "focal_method": {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void run() {\n        try {\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            final ByteArrayOutputStream out = new ByteArrayOutputStream();\n            while (true) {\n                final DatagramPacket packet =\n                        new DatagramPacket(buffer, buffer.length);\n                socket.receive(packet);\n                out.write(buffer, 0, packet.getLength());\n                final String response = out.toString();\n                LOGGER.info(\"received from MARC: '\" + response + \"'\");\n                try {\n                    final String id = parseId(response);\n                    if (isEndOfSpeech(id)) {\n                        output.playEnded(id);\n                    }\n                } catch (TransformerException e) {\n                    LOGGER.warn(\"error parsing the response from MARC\", e);\n                } finally {\n                    out.reset();\n                }\n            }\n        } catch (IOException e) {\n            LOGGER.error(e.getMessage(), e);\n        } finally {\n            if (socket != null) {\n                socket.close();\n            }\n        }\n    }", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "MarcFeedback.run()", "testcase": false, "constructor": false, "invocations": ["receive", "write", "getLength", "toString", "info", "parseId", "isEndOfSpeech", "playEnded", "warn", "reset", "error", "getMessage", "close"]}, "repository": {"repo_id": 37717709, "url": "https://github.com/JVoiceXML/JVoiceXML", "language": "Java", "is_fork": false, "fork_count": 32, "stargazer_count": 50, "size": 436089, "license": "licensed"}}