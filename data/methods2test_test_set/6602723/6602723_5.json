{"test_class": {"identifier": "TestCircuitBreakerAspect", "superclass": "", "interfaces": "", "fields": [{"original_string": "private CircuitBreakerAspect aspect;", "modifier": "private", "type": "CircuitBreakerAspect", "declarator": "aspect", "var_name": "aspect"}, {"original_string": "CircuitBreaker mockAnnotation;", "modifier": "", "type": "CircuitBreaker", "declarator": "mockAnnotation", "var_name": "mockAnnotation"}, {"original_string": "Signature mockSignature;", "modifier": "", "type": "Signature", "declarator": "mockSignature", "var_name": "mockSignature"}, {"original_string": "private static final String TEST_CIRCUIT_BREAKER = \"TestCircuitBreaker\";", "modifier": "private static final", "type": "String", "declarator": "TEST_CIRCUIT_BREAKER = \"TestCircuitBreaker\"", "var_name": "TEST_CIRCUIT_BREAKER"}], "file": "jrugged-aspects/src/test/java/org/fishwife/jrugged/aspects/TestCircuitBreakerAspect.java"}, "test_case": {"identifier": "testMonitor", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMonitor() throws Throwable {\n        ProceedingJoinPoint mockPjp = createPjpMock(mockSignature, 2);\n        expect(mockPjp.proceed()).andReturn(null).times(2);\n        replay(mockPjp);\n\n        // Test monitor without pre-existing circuit breaker.\n        aspect.monitor(mockPjp, mockAnnotation);\n\n        // Test monitor with pre-existing circuit breaker.\n        aspect.monitor(mockPjp, mockAnnotation);\n\n        String otherName = \"OtherMonitor\";\n        ProceedingJoinPoint otherMockPjp = createPjpMock(mockSignature, 1);\n        expect(otherMockPjp.proceed()).andReturn(null).times(1);\n        replay(otherMockPjp);\n\n        CircuitBreaker otherMockAnnotation = createMock(CircuitBreaker.class);\n        expect(otherMockAnnotation.name()).andReturn(otherName).anyTimes();\n        expect(otherMockAnnotation.limit()).andReturn(5).anyTimes();\n        expect(otherMockAnnotation.resetMillis()).andReturn(30000L).anyTimes();\n        expect(otherMockAnnotation.windowMillis()).andReturn(10000L).anyTimes();\n        @SuppressWarnings(\"unchecked\")\n        Class<Throwable>[] ignores = new Class[0];\n        expect(otherMockAnnotation.ignore()).andReturn(ignores);\n        replay(otherMockAnnotation);\n\n        // Test monitor with another circuit breaker.\n        aspect.monitor(otherMockPjp, otherMockAnnotation);\n        verifyBreakerExists(TEST_CIRCUIT_BREAKER);\n        verifyBreakerExists(otherName);\n\n        verify(mockPjp);\n        verify(mockAnnotation);\n        verify(mockSignature);\n        verify(otherMockPjp);\n        verify(otherMockAnnotation);\n    }", "signature": "void testMonitor()", "full_signature": "@Test public void testMonitor()", "class_method_signature": "TestCircuitBreakerAspect.testMonitor()", "testcase": true, "constructor": false, "invocations": ["createPjpMock", "times", "andReturn", "expect", "proceed", "replay", "monitor", "monitor", "createPjpMock", "times", "andReturn", "expect", "proceed", "replay", "createMock", "anyTimes", "andReturn", "expect", "name", "anyTimes", "andReturn", "expect", "limit", "anyTimes", "andReturn", "expect", "resetMillis", "anyTimes", "andReturn", "expect", "windowMillis", "andReturn", "expect", "ignore", "replay", "monitor", "verifyBreakerExists", "verifyBreakerExists", "verify", "verify", "verify", "verify", "verify"]}, "focal_class": {"identifier": "CircuitBreakerAspect", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger =\n            LoggerFactory.getLogger(CircuitBreakerAspect.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger =\n            LoggerFactory.getLogger(CircuitBreakerAspect.class)", "var_name": "logger"}, {"original_string": "private CircuitBreakerFactory circuitBreakerFactory;", "modifier": "private", "type": "CircuitBreakerFactory", "declarator": "circuitBreakerFactory", "var_name": "circuitBreakerFactory"}], "methods": [{"identifier": "CircuitBreakerAspect", "parameters": "()", "modifiers": "public", "return": "", "signature": " CircuitBreakerAspect()", "full_signature": "public  CircuitBreakerAspect()", "class_method_signature": "CircuitBreakerAspect.CircuitBreakerAspect()", "testcase": false, "constructor": true}, {"identifier": "setCircuitBreakerFactory", "parameters": "(\n            CircuitBreakerFactory circuitBreakerFactory)", "modifiers": "public", "return": "void", "signature": "void setCircuitBreakerFactory(\n            CircuitBreakerFactory circuitBreakerFactory)", "full_signature": "public void setCircuitBreakerFactory(\n            CircuitBreakerFactory circuitBreakerFactory)", "class_method_signature": "CircuitBreakerAspect.setCircuitBreakerFactory(\n            CircuitBreakerFactory circuitBreakerFactory)", "testcase": false, "constructor": false}, {"identifier": "getCircuitBreakerFactory", "parameters": "()", "modifiers": "public", "return": "CircuitBreakerFactory", "signature": "CircuitBreakerFactory getCircuitBreakerFactory()", "full_signature": "public CircuitBreakerFactory getCircuitBreakerFactory()", "class_method_signature": "CircuitBreakerAspect.getCircuitBreakerFactory()", "testcase": false, "constructor": false}, {"identifier": "monitor", "parameters": "(final ProceedingJoinPoint pjp,\n              CircuitBreaker circuitBreakerAnnotation)", "modifiers": "@Around(\"@annotation(circuitBreakerAnnotation)\") public", "return": "Object", "signature": "Object monitor(final ProceedingJoinPoint pjp,\n              CircuitBreaker circuitBreakerAnnotation)", "full_signature": "@Around(\"@annotation(circuitBreakerAnnotation)\") public Object monitor(final ProceedingJoinPoint pjp,\n              CircuitBreaker circuitBreakerAnnotation)", "class_method_signature": "CircuitBreakerAspect.monitor(final ProceedingJoinPoint pjp,\n              CircuitBreaker circuitBreakerAnnotation)", "testcase": false, "constructor": false}], "file": "jrugged-aspects/src/main/java/org/fishwife/jrugged/aspects/CircuitBreakerAspect.java"}, "focal_method": {"identifier": "monitor", "parameters": "(final ProceedingJoinPoint pjp,\n              CircuitBreaker circuitBreakerAnnotation)", "modifiers": "@Around(\"@annotation(circuitBreakerAnnotation)\") public", "return": "Object", "body": "@Around(\"@annotation(circuitBreakerAnnotation)\")\n    public Object monitor(final ProceedingJoinPoint pjp,\n              CircuitBreaker circuitBreakerAnnotation) throws Throwable {\n        final String name = circuitBreakerAnnotation.name();\n\n        org.fishwife.jrugged.CircuitBreaker circuitBreaker =\n                circuitBreakerFactory.findCircuitBreaker(name);\n\n        if (circuitBreaker == null) {\n            DefaultFailureInterpreter dfi =\n                    new DefaultFailureInterpreter(\n                            circuitBreakerAnnotation.ignore(),\n                            circuitBreakerAnnotation.limit(),\n                            circuitBreakerAnnotation.windowMillis());\n\n            CircuitBreakerConfig config = new CircuitBreakerConfig(\n                    circuitBreakerAnnotation.resetMillis(), dfi);\n\n            circuitBreaker =\n                    circuitBreakerFactory.createCircuitBreaker(name, config);\n        }\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Have @CircuitBreaker method with breaker name {}, \" +\n                    \"wrapping call on method {} of target object {} with status {}\",\n                    new Object[]{\n                            name,\n                            pjp.getSignature().getName(),\n                            pjp.getTarget(),\n                            circuitBreaker.getStatus()});\n        }\n\n        return circuitBreaker.invoke(new Callable<Object>() {\n            public Object call() throws Exception {\n                try {\n                    return pjp.proceed();\n                } catch (Throwable e) {\n                    if (e instanceof Exception) {\n                        throw (Exception) e;\n                    } else if (e instanceof Error) {\n                        throw (Error) e;\n                    } else {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n        });\n    }", "signature": "Object monitor(final ProceedingJoinPoint pjp,\n              CircuitBreaker circuitBreakerAnnotation)", "full_signature": "@Around(\"@annotation(circuitBreakerAnnotation)\") public Object monitor(final ProceedingJoinPoint pjp,\n              CircuitBreaker circuitBreakerAnnotation)", "class_method_signature": "CircuitBreakerAspect.monitor(final ProceedingJoinPoint pjp,\n              CircuitBreaker circuitBreakerAnnotation)", "testcase": false, "constructor": false, "invocations": ["name", "findCircuitBreaker", "ignore", "limit", "windowMillis", "resetMillis", "createCircuitBreaker", "isDebugEnabled", "debug", "getName", "getSignature", "getTarget", "getStatus", "invoke", "proceed"]}, "repository": {"repo_id": 6602723, "url": "https://github.com/Comcast/jrugged", "language": "Java", "is_fork": false, "fork_count": 90, "stargazer_count": 236, "size": 1302, "license": "licensed"}}