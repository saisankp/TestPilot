{"test_class": {"identifier": "JavaPropertiesResourceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final File INPUT_FILE = new File(\"src/test/resource/resfilter/properties/input.properties\");", "modifier": "private static final", "type": "File", "declarator": "INPUT_FILE = new File(\"src/test/resource/resfilter/properties/input.properties\")", "var_name": "INPUT_FILE"}, {"original_string": "private static final File EXPECTED_WRITE_FILE = new File(\n            \"src/test/resource/resfilter/properties/write-output.properties\");", "modifier": "private static final", "type": "File", "declarator": "EXPECTED_WRITE_FILE = new File(\n            \"src/test/resource/resfilter/properties/write-output.properties\")", "var_name": "EXPECTED_WRITE_FILE"}, {"original_string": "private static final File EXPECTED_WRITE_FILE_ALL = new File(\n            \"src/test/resource/resfilter/properties/write-output-all.properties\");", "modifier": "private static final", "type": "File", "declarator": "EXPECTED_WRITE_FILE_ALL = new File(\n            \"src/test/resource/resfilter/properties/write-output-all.properties\")", "var_name": "EXPECTED_WRITE_FILE_ALL"}, {"original_string": "private static final File EXPECTED_MERGE_FILE = new File(\n            \"src/test/resource/resfilter/properties/merge-output.properties\");", "modifier": "private static final", "type": "File", "declarator": "EXPECTED_MERGE_FILE = new File(\n            \"src/test/resource/resfilter/properties/merge-output.properties\")", "var_name": "EXPECTED_MERGE_FILE"}, {"original_string": "private static final File PARSE_TEST_INPUT_FILE = new File(\n            \"src/test/resource/resfilter/properties/parseline-test-input.properties\");", "modifier": "private static final", "type": "File", "declarator": "PARSE_TEST_INPUT_FILE = new File(\n            \"src/test/resource/resfilter/properties/parseline-test-input.properties\")", "var_name": "PARSE_TEST_INPUT_FILE"}, {"original_string": "private static final Collection<ResourceString> EXPECTED_INPUT_RES_LIST;", "modifier": "private static final", "type": "Collection<ResourceString>", "declarator": "EXPECTED_INPUT_RES_LIST", "var_name": "EXPECTED_INPUT_RES_LIST"}, {"original_string": "private static LanguageBundle WRITE_BUNDLE;", "modifier": "private static", "type": "LanguageBundle", "declarator": "WRITE_BUNDLE", "var_name": "WRITE_BUNDLE"}, {"original_string": "private static LanguageBundle WRITE_BUNDLE_ALL;", "modifier": "private static", "type": "LanguageBundle", "declarator": "WRITE_BUNDLE_ALL", "var_name": "WRITE_BUNDLE_ALL"}, {"original_string": "private static LinkedList<PropDef> EXPECTED_PROP_DEF_LIST;", "modifier": "private static", "type": "LinkedList<PropDef>", "declarator": "EXPECTED_PROP_DEF_LIST", "var_name": "EXPECTED_PROP_DEF_LIST"}, {"original_string": "private static final JavaPropertiesResource res = new JavaPropertiesResource();", "modifier": "private static final", "type": "JavaPropertiesResource", "declarator": "res = new JavaPropertiesResource()", "var_name": "res"}, {"original_string": "private static final String[][] UNESC_TEST_CASES =\n    {\n        {\"\", \"\"},\n        {\"abc\", \"abc\"},\n        {\"\\\\ abc\\\\u0020\", \" abc \"},\n        {\"a\\\\tb\\\\u0009c\", \"a\\tb\\tc\"},\n        {\"a\\\\=\\\\b\", \"a=b\"},\n        {\"a\\\\\\\\b\", \"a\\\\b\"},\n        {\"\\\\t\\\\f\\\\z\", \"\\t\\fz\"},\n        {\"\\\\a\\\\b\\\\c\", \"abc\"},\n        {\"\\\\u304A\\\\u304b\", \"\\u304A\\u304B\"},\n    };", "modifier": "private static final", "type": "String[][]", "declarator": "UNESC_TEST_CASES =\n    {\n        {\"\", \"\"},\n        {\"abc\", \"abc\"},\n        {\"\\\\ abc\\\\u0020\", \" abc \"},\n        {\"a\\\\tb\\\\u0009c\", \"a\\tb\\tc\"},\n        {\"a\\\\=\\\\b\", \"a=b\"},\n        {\"a\\\\\\\\b\", \"a\\\\b\"},\n        {\"\\\\t\\\\f\\\\z\", \"\\t\\fz\"},\n        {\"\\\\a\\\\b\\\\c\", \"abc\"},\n        {\"\\\\u304A\\\\u304b\", \"\\u304A\\u304B\"},\n    }", "var_name": "UNESC_TEST_CASES"}, {"original_string": "private static final String[][] MESSAGE_PATTERN_TEST_CASES = {\n        // {<GP expression>,\n        //     <props expression - auto>[,\n        //     <props expression - all>,                    // if absent, use <prop expression - auto>\n        //     <GP expression after round trip - auto>,     // if absent, use <GP expression>\n        //     <GP expression after round trip - all>]}     // if absent, use <GP expression>\n        { \"You're about to delete {0} rows.\",\n            \"You''re about to delete {0} rows.\" },\n        { \"You're about to delete '{0}' rows in Mike's file {0}.\",\n            \"You''re about to delete '{0}' rows in Mike''s file {0}.\" },\n        { \"Log shows '{''}' in file {0}\",\n            \"Log shows '{''}' in file {0}\" },\n        { \"Log shows '{''} in file {0}\",\n            \"Log shows '{''} in file {0}\",\n            \"Log shows '{''} in file {0}'\", // escape with MessagePatternEscape.ALL\n            null,\n            \"Log shows '{''} in file {0}'\"}, // round trip with MessagePatternEscape.ALL\n        { \"Log shows '{'}' in file {0}\",\n            \"Log shows '{'}'' in file {0}\" },\n        { \"Log shows '{'error'}' in file {0}\",\n            \"Log shows '{'error'}' in file {0}\" },\n        { \"Log shows '{''error''}' in file {0}\",\n            \"Log shows '{''error''}' in file {0}\" },\n        { \"File {0} shows '{''error''}'\",\n            \"File {0} shows '{''error''}'\" },\n        { \"The file isn't in use.\",\n            \"The file isn't in use.\",\n            \"The file isn''t in use.\" }, // escape with MessagePatternEscape.ALL\n        { \"File {0} isn't in use.\",\n            \"File {0} isn''t in use.\"},\n    };", "modifier": "private static final", "type": "String[][]", "declarator": "MESSAGE_PATTERN_TEST_CASES = {\n        // {<GP expression>,\n        //     <props expression - auto>[,\n        //     <props expression - all>,                    // if absent, use <prop expression - auto>\n        //     <GP expression after round trip - auto>,     // if absent, use <GP expression>\n        //     <GP expression after round trip - all>]}     // if absent, use <GP expression>\n        { \"You're about to delete {0} rows.\",\n            \"You''re about to delete {0} rows.\" },\n        { \"You're about to delete '{0}' rows in Mike's file {0}.\",\n            \"You''re about to delete '{0}' rows in Mike''s file {0}.\" },\n        { \"Log shows '{''}' in file {0}\",\n            \"Log shows '{''}' in file {0}\" },\n        { \"Log shows '{''} in file {0}\",\n            \"Log shows '{''} in file {0}\",\n            \"Log shows '{''} in file {0}'\", // escape with MessagePatternEscape.ALL\n            null,\n            \"Log shows '{''} in file {0}'\"}, // round trip with MessagePatternEscape.ALL\n        { \"Log shows '{'}' in file {0}\",\n            \"Log shows '{'}'' in file {0}\" },\n        { \"Log shows '{'error'}' in file {0}\",\n            \"Log shows '{'error'}' in file {0}\" },\n        { \"Log shows '{''error''}' in file {0}\",\n            \"Log shows '{''error''}' in file {0}\" },\n        { \"File {0} shows '{''error''}'\",\n            \"File {0} shows '{''error''}'\" },\n        { \"The file isn't in use.\",\n            \"The file isn't in use.\",\n            \"The file isn''t in use.\" }, // escape with MessagePatternEscape.ALL\n        { \"File {0} isn't in use.\",\n            \"File {0} isn''t in use.\"},\n    }", "var_name": "MESSAGE_PATTERN_TEST_CASES"}], "file": "gp-res-filter/src/test/java/com/ibm/g11n/pipeline/resfilter/impl/JavaPropertiesResourceTest.java"}, "test_case": {"identifier": "testUnescapeMessagePattern", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testUnescapeMessagePattern() throws ResourceFilterException {\n        for (String[] testCase : MESSAGE_PATTERN_TEST_CASES) {\n            String result = JavaPropertiesResource.unescapeMessagePattern(testCase[1], MessagePatternEscape.AUTO);\n            String expected = testCase.length >= 4 && testCase[3] != null ? testCase[3] : testCase[0];\n            assertEquals(\"unescapeMessagePattern(\" + testCase[1] + \", AUTO)\", expected, result);\n        }\n\n        for (String[] testCase : MESSAGE_PATTERN_TEST_CASES) {\n            String input = testCase.length >= 3 && testCase[2] != null ? testCase[2] : testCase[1];\n            String result = JavaPropertiesResource.unescapeMessagePattern(input, MessagePatternEscape.ALL);\n            String expected = testCase.length >= 5 && testCase[4] != null ? testCase[4] : testCase[0];\n            assertEquals(\"unescapeMessagePattern(\" + input + \", ALL)\", expected, result);\n        }\n    }", "signature": "void testUnescapeMessagePattern()", "full_signature": "@Test public void testUnescapeMessagePattern()", "class_method_signature": "JavaPropertiesResourceTest.testUnescapeMessagePattern()", "testcase": true, "constructor": false, "invocations": ["unescapeMessagePattern", "assertEquals", "unescapeMessagePattern", "assertEquals"]}, "focal_class": {"identifier": "JavaPropertiesResource", "superclass": "extends ResourceFilter", "interfaces": "", "fields": [{"original_string": "private final Encoding enc;", "modifier": "private final", "type": "Encoding", "declarator": "enc", "var_name": "enc"}, {"original_string": "private final MessagePatternEscape msgPatEsc;", "modifier": "private final", "type": "MessagePatternEscape", "declarator": "msgPatEsc", "var_name": "msgPatEsc"}, {"original_string": "private static final char BACKSLASH = '\\\\';", "modifier": "private static final", "type": "char", "declarator": "BACKSLASH = '\\\\'", "var_name": "BACKSLASH"}], "methods": [{"identifier": "JavaPropertiesResource", "parameters": "(Encoding enc, MessagePatternEscape msgPatEsc)", "modifiers": "public", "return": "", "signature": " JavaPropertiesResource(Encoding enc, MessagePatternEscape msgPatEsc)", "full_signature": "public  JavaPropertiesResource(Encoding enc, MessagePatternEscape msgPatEsc)", "class_method_signature": "JavaPropertiesResource.JavaPropertiesResource(Encoding enc, MessagePatternEscape msgPatEsc)", "testcase": false, "constructor": true}, {"identifier": "JavaPropertiesResource", "parameters": "()", "modifiers": "public", "return": "", "signature": " JavaPropertiesResource()", "full_signature": "public  JavaPropertiesResource()", "class_method_signature": "JavaPropertiesResource.JavaPropertiesResource()", "testcase": false, "constructor": true}, {"identifier": "parse", "parameters": "(InputStream inStream, FilterOptions options)", "modifiers": "@Override public", "return": "LanguageBundle", "signature": "LanguageBundle parse(InputStream inStream, FilterOptions options)", "full_signature": "@Override public LanguageBundle parse(InputStream inStream, FilterOptions options)", "class_method_signature": "JavaPropertiesResource.parse(InputStream inStream, FilterOptions options)", "testcase": false, "constructor": false}, {"identifier": "isContinuationLine", "parameters": "(String s)", "modifiers": "private", "return": "boolean", "signature": "boolean isContinuationLine(String s)", "full_signature": "private boolean isContinuationLine(String s)", "class_method_signature": "JavaPropertiesResource.isContinuationLine(String s)", "testcase": false, "constructor": false}, {"identifier": "write", "parameters": "(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "modifiers": "@Override public", "return": "void", "signature": "void write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "full_signature": "@Override public void write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "class_method_signature": "JavaPropertiesResource.write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "testcase": false, "constructor": false}, {"identifier": "getCharset", "parameters": "()", "modifiers": "private", "return": "Charset", "signature": "Charset getCharset()", "full_signature": "private Charset getCharset()", "class_method_signature": "JavaPropertiesResource.getCharset()", "testcase": false, "constructor": false}, {"identifier": "escape", "parameters": "(String str, EscapeSpace escSpace, boolean isUTF8)", "modifiers": "private static", "return": "String", "signature": "String escape(String str, EscapeSpace escSpace, boolean isUTF8)", "full_signature": "private static String escape(String str, EscapeSpace escSpace, boolean isUTF8)", "class_method_signature": "JavaPropertiesResource.escape(String str, EscapeSpace escSpace, boolean isUTF8)", "testcase": false, "constructor": false}, {"identifier": "escapePropKey", "parameters": "(String str)", "modifiers": "static", "return": "String", "signature": "String escapePropKey(String str)", "full_signature": "static String escapePropKey(String str)", "class_method_signature": "JavaPropertiesResource.escapePropKey(String str)", "testcase": false, "constructor": false}, {"identifier": "escapePropKey", "parameters": "(String str, boolean isUTF8)", "modifiers": "static", "return": "String", "signature": "String escapePropKey(String str, boolean isUTF8)", "full_signature": "static String escapePropKey(String str, boolean isUTF8)", "class_method_signature": "JavaPropertiesResource.escapePropKey(String str, boolean isUTF8)", "testcase": false, "constructor": false}, {"identifier": "escapePropValue", "parameters": "(String str)", "modifiers": "static", "return": "String", "signature": "String escapePropValue(String str)", "full_signature": "static String escapePropValue(String str)", "class_method_signature": "JavaPropertiesResource.escapePropValue(String str)", "testcase": false, "constructor": false}, {"identifier": "escapePropValue", "parameters": "(String str, boolean isUTF8)", "modifiers": "static", "return": "String", "signature": "String escapePropValue(String str, boolean isUTF8)", "full_signature": "static String escapePropValue(String str, boolean isUTF8)", "class_method_signature": "JavaPropertiesResource.escapePropValue(String str, boolean isUTF8)", "testcase": false, "constructor": false}, {"identifier": "appendUnicodeEscape", "parameters": "(StringBuilder buf, char codeUnit)", "modifiers": "static", "return": "void", "signature": "void appendUnicodeEscape(StringBuilder buf, char codeUnit)", "full_signature": "static void appendUnicodeEscape(StringBuilder buf, char codeUnit)", "class_method_signature": "JavaPropertiesResource.appendUnicodeEscape(StringBuilder buf, char codeUnit)", "testcase": false, "constructor": false}, {"identifier": "unescapePropKey", "parameters": "(String str)", "modifiers": "static", "return": "String", "signature": "String unescapePropKey(String str)", "full_signature": "static String unescapePropKey(String str)", "class_method_signature": "JavaPropertiesResource.unescapePropKey(String str)", "testcase": false, "constructor": false}, {"identifier": "unescapePropValue", "parameters": "(String str)", "modifiers": "static", "return": "String", "signature": "String unescapePropValue(String str)", "full_signature": "static String unescapePropValue(String str)", "class_method_signature": "JavaPropertiesResource.unescapePropValue(String str)", "testcase": false, "constructor": false}, {"identifier": "unescape", "parameters": "(String str)", "modifiers": "private static", "return": "String", "signature": "String unescape(String str)", "full_signature": "private static String unescape(String str)", "class_method_signature": "JavaPropertiesResource.unescape(String str)", "testcase": false, "constructor": false}, {"identifier": "escapeOnlyUnicode", "parameters": "(String str)", "modifiers": "private static", "return": "String", "signature": "String escapeOnlyUnicode(String str)", "full_signature": "private static String escapeOnlyUnicode(String str)", "class_method_signature": "JavaPropertiesResource.escapeOnlyUnicode(String str)", "testcase": false, "constructor": false}, {"identifier": "unescapeOnlyUnicode", "parameters": "(String str)", "modifiers": "private static", "return": "String", "signature": "String unescapeOnlyUnicode(String str)", "full_signature": "private static String unescapeOnlyUnicode(String str)", "class_method_signature": "JavaPropertiesResource.unescapeOnlyUnicode(String str)", "testcase": false, "constructor": false}, {"identifier": "unescapeMessagePattern", "parameters": "(String inputStr, MessagePatternEscape msgPatEsc)", "modifiers": "static", "return": "String", "signature": "String unescapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc)", "full_signature": "static String unescapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc)", "class_method_signature": "JavaPropertiesResource.unescapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc)", "testcase": false, "constructor": false}, {"identifier": "escapeMessagePattern", "parameters": "(String inputStr, MessagePatternEscape msgPatEsc)", "modifiers": "static", "return": "String", "signature": "String escapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc)", "full_signature": "static String escapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc)", "class_method_signature": "JavaPropertiesResource.escapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc)", "testcase": false, "constructor": false}, {"identifier": "hasArgs", "parameters": "(MessagePattern msgPat)", "modifiers": "static", "return": "boolean", "signature": "boolean hasArgs(MessagePattern msgPat)", "full_signature": "static boolean hasArgs(MessagePattern msgPat)", "class_method_signature": "JavaPropertiesResource.hasArgs(MessagePattern msgPat)", "testcase": false, "constructor": false}, {"identifier": "merge", "parameters": "(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "modifiers": "@Override public", "return": "void", "signature": "void merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "full_signature": "@Override public void merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "class_method_signature": "JavaPropertiesResource.merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "testcase": false, "constructor": false}, {"identifier": "getLeadingSpacesLength", "parameters": "(String s)", "modifiers": "private static", "return": "int", "signature": "int getLeadingSpacesLength(String s)", "full_signature": "private static int getLeadingSpacesLength(String s)", "class_method_signature": "JavaPropertiesResource.getLeadingSpacesLength(String s)", "testcase": false, "constructor": false}, {"identifier": "stripLeadingSpaces", "parameters": "(String s)", "modifiers": "private static", "return": "String", "signature": "String stripLeadingSpaces(String s)", "full_signature": "private static String stripLeadingSpaces(String s)", "class_method_signature": "JavaPropertiesResource.stripLeadingSpaces(String s)", "testcase": false, "constructor": false}, {"identifier": "isPropsWhiteSpaceChar", "parameters": "(char c)", "modifiers": "private static", "return": "boolean", "signature": "boolean isPropsWhiteSpaceChar(char c)", "full_signature": "private static boolean isPropsWhiteSpaceChar(char c)", "class_method_signature": "JavaPropertiesResource.isPropsWhiteSpaceChar(char c)", "testcase": false, "constructor": false}], "file": "gp-res-filter/src/main/java/com/ibm/g11n/pipeline/resfilter/impl/JavaPropertiesResource.java"}, "focal_method": {"identifier": "unescapeMessagePattern", "parameters": "(String inputStr, MessagePatternEscape msgPatEsc)", "modifiers": "static", "return": "String", "body": "static String unescapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc) throws ResourceFilterException {\n        // Quick check - if there are no double apostrophes, skip this operation.\n        if (inputStr.indexOf(\"''\") < 0) {\n            return inputStr;\n        }\n\n        MessagePattern msgPat = new MessagePattern(ApostropheMode.DOUBLE_OPTIONAL);\n\n        try {\n            msgPat.parse(inputStr);\n\n            if (msgPatEsc == MessagePatternEscape.AUTO && !hasArgs(msgPat)) {\n                // In AUTO mode, a strings is not handled as message format pattern\n                // when no arguments are found.\n\n                // TODO: A string like \"Can''t delete a file.\" is most likely a message format\n                // pattern without arguments and the implementation can turn it to\n                // \"Can't delete a file.\" during import. However, in this case, there is\n                // no way to determine whether the apostrophe is emitted as-is, or doubled\n                // for export, unless we store the information (whether it was imported as\n                // message format pattern or not) separately. Revisit this later.\n\n                return inputStr;\n            }\n        } catch (Exception e) {\n            // This input string cannot be parsed as MessageFormat pattern.\n            if (msgPatEsc == MessagePatternEscape.ALL) {\n                throw new ResourceFilterException(\"Illegal message pattern string: \" + inputStr);\n            }\n            // If msgPatEsc is not MessagePatternEscape.ALL, input string does\n            // not need to be a valid message pattern. In this case, just return\n            // the input as is.\n            return inputStr;\n        }\n\n        StringBuilder buf = new StringBuilder();\n        int start = 0;\n        PrevState prev = PrevState.OTHER;\n        boolean inQuote = false;\n\n        for (int i = 0; i < msgPat.countParts(); i++) {\n            Part part = msgPat.getPart(i);\n            int limit = part.getLimit();\n            int endIdx = limit;\n\n            Type type = part.getType();\n            if (type == Type.ARG_START) {\n                // If an argument start *IMMEDIATELY* after doubled apostrophe,\n                // this code append the second apostrophe.\n                if (prev == PrevState.DEFERRED_APOSTROPHE && (limit - start) == 1) {\n                    buf.append(\"'\");\n                }\n                prev = PrevState.OTHER;\n            } else if (type == Type.SKIP_SYNTAX) {\n                // Is this skip part a single apostrophe?\n                boolean curApos = msgPat.getSubstring(part).equals(\"'\");\n                // Preceded by an apostrophe?\n                boolean doubleApos = false;\n                if (curApos) {\n                    // Check character before this skip part.\n                    // limit is the index after the skip part,\n                    // and limit -1 is the index for this skip part,\n                    // so the previous character is at the index of\n                    // limit - 2.\n                    doubleApos = inputStr.charAt(limit - 2) == '\\'';\n                }\n                if (doubleApos) {\n                    boolean emitSecondApos = false;\n                    if (inQuote) {\n                        // Double apostrophes in a quoted segment are\n                        // always emitted as is.\n                        emitSecondApos = true;\n                        prev = PrevState.OTHER;\n                    } else if (prev == PrevState.ARG_LIMIT) {\n                        // If previous part was end of argument, and\n                        // double apostrophes immediately follow, then\n                        // double apostrophes are emitted as is.\n                        // Otherwise, defer the decision.\n                        if (start == limit - 2) {\n                            emitSecondApos = true;\n                            prev = PrevState.OTHER;\n                        } else {\n                            prev = PrevState.DEFERRED_APOSTROPHE;\n                        }\n                    } else {\n                        // Defer whether second apostrophe is emitted\n                        // or not after checking next part.\n                        prev = PrevState.DEFERRED_APOSTROPHE;\n                    }\n\n                    if (!emitSecondApos) {\n                        endIdx = part.getIndex();\n                    }\n                } else {\n                    prev = PrevState.OTHER;\n                    if (curApos) {\n                        // Single apostrophe designates either start or end of\n                        // quoted segment.\n                        inQuote = !inQuote;\n                    }\n                }\n            } else if (type == Type.ARG_LIMIT) {\n                prev = PrevState.ARG_LIMIT;\n            } else {\n                prev = PrevState.OTHER;\n            }\n\n            buf.append(inputStr.substring(start, endIdx));\n            start = limit;\n        }\n\n        // Append remaining text\n        if (start < inputStr.length()) {\n            buf.append(inputStr.substring(start, inputStr.length()));\n        }\n\n        return buf.toString();\n    }", "signature": "String unescapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc)", "full_signature": "static String unescapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc)", "class_method_signature": "JavaPropertiesResource.unescapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc)", "testcase": false, "constructor": false, "invocations": ["indexOf", "parse", "hasArgs", "countParts", "getPart", "getLimit", "getType", "append", "equals", "getSubstring", "charAt", "getIndex", "append", "substring", "length", "append", "substring", "length", "toString"]}, "repository": {"repo_id": 46134098, "url": "https://github.com/IBM-Cloud/gp-java-tools", "language": "Java", "is_fork": false, "fork_count": 16, "stargazer_count": 9, "size": 6216, "license": "licensed"}}