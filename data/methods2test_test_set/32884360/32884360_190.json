{"test_class": {"identifier": "MDateAndTimeTest", "superclass": "", "interfaces": "", "fields": [], "file": "fdb-sql-layer-core/src/test/java/com/foundationdb/server/types/mcompat/mtypes/MDateAndTimeTest.java"}, "test_case": {"identifier": "testParseDate_long", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testParseDate_long() {\n        // Assumed to be implemented with parseDateTime.\n        // Sanity\n        arrayEquals(dt(0), parseDate(0));\n        arrayEquals(dt(1995, 5, 1), parseDate(19950501));\n        // But ignores HH:MM:SS\n        arrayEquals(dt(1995, 5, 1), parseDate(19950501101112L));\n    }", "signature": "void testParseDate_long()", "full_signature": "@Test public void testParseDate_long()", "class_method_signature": "MDateAndTimeTest.testParseDate_long()", "testcase": true, "constructor": false, "invocations": ["arrayEquals", "dt", "parseDate", "arrayEquals", "dt", "parseDate", "arrayEquals", "dt", "parseDate"]}, "focal_class": {"identifier": "MDateAndTime", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final TBundleID MBundleID = MBundle.INSTANCE.id();", "modifier": "private static final", "type": "TBundleID", "declarator": "MBundleID = MBundle.INSTANCE.id()", "var_name": "MBundleID"}, {"original_string": "public static final NoAttrTClass DATE = new NoAttrTClass(MBundleID,\n            \"date\", AkCategory.DATE_TIME, FORMAT.DATE, 1, 1, 3, UnderlyingType.INT_32, MParsers.DATE, 10, TypeId.DATE_ID)\n    {\n        @Override\n        public TClass widestComparable()\n        {\n            return DATETIME;\n        }\n    };", "modifier": "public static final", "type": "NoAttrTClass", "declarator": "DATE = new NoAttrTClass(MBundleID,\n            \"date\", AkCategory.DATE_TIME, FORMAT.DATE, 1, 1, 3, UnderlyingType.INT_32, MParsers.DATE, 10, TypeId.DATE_ID)\n    {\n        @Override\n        public TClass widestComparable()\n        {\n            return DATETIME;\n        }\n    }", "var_name": "DATE"}, {"original_string": "public static final NoAttrTClass DATETIME = new NoAttrTClass(MBundleID,\n            \"datetime\", AkCategory.DATE_TIME, FORMAT.DATETIME,  1, 1, 8, UnderlyingType.INT_64, MParsers.DATETIME, 19, TypeId.DATETIME_ID);", "modifier": "public static final", "type": "NoAttrTClass", "declarator": "DATETIME = new NoAttrTClass(MBundleID,\n            \"datetime\", AkCategory.DATE_TIME, FORMAT.DATETIME,  1, 1, 8, UnderlyingType.INT_64, MParsers.DATETIME, 19, TypeId.DATETIME_ID)", "var_name": "DATETIME"}, {"original_string": "public static final NoAttrTClass TIME = new NoAttrTClass(MBundleID,\n            \"time\", AkCategory.DATE_TIME, FORMAT.TIME, 1, 1, 3, UnderlyingType.INT_32, MParsers.TIME, 8, TypeId.TIME_ID);", "modifier": "public static final", "type": "NoAttrTClass", "declarator": "TIME = new NoAttrTClass(MBundleID,\n            \"time\", AkCategory.DATE_TIME, FORMAT.TIME, 1, 1, 3, UnderlyingType.INT_32, MParsers.TIME, 8, TypeId.TIME_ID)", "var_name": "TIME"}, {"original_string": "public static final NoAttrTClass YEAR = new NoAttrTClass(MBundleID,\n            \"year\", AkCategory.DATE_TIME, FORMAT.YEAR, 1, 1, 1, UnderlyingType.INT_16, MParsers.YEAR, 4, TypeId.YEAR_ID);", "modifier": "public static final", "type": "NoAttrTClass", "declarator": "YEAR = new NoAttrTClass(MBundleID,\n            \"year\", AkCategory.DATE_TIME, FORMAT.YEAR, 1, 1, 1, UnderlyingType.INT_16, MParsers.YEAR, 4, TypeId.YEAR_ID)", "var_name": "YEAR"}, {"original_string": "public static final NoAttrTClass TIMESTAMP = new NoAttrTClass(MBundleID,\n            \"timestamp\", AkCategory.DATE_TIME, FORMAT.TIMESTAMP, 1, 1, 4, UnderlyingType.INT_32, MParsers.TIMESTAMP, 19, TypeId.TIMESTAMP_ID);", "modifier": "public static final", "type": "NoAttrTClass", "declarator": "TIMESTAMP = new NoAttrTClass(MBundleID,\n            \"timestamp\", AkCategory.DATE_TIME, FORMAT.TIMESTAMP, 1, 1, 4, UnderlyingType.INT_32, MParsers.TIMESTAMP, 19, TypeId.TIMESTAMP_ID)", "var_name": "TIMESTAMP"}, {"original_string": "public static final Map<String, String[]> MONTHS;", "modifier": "public static final", "type": "Map<String, String[]>", "declarator": "MONTHS", "var_name": "MONTHS"}, {"original_string": "public static final int YEAR_INDEX = 0;", "modifier": "public static final", "type": "int", "declarator": "YEAR_INDEX = 0", "var_name": "YEAR_INDEX"}, {"original_string": "public static final int MONTH_INDEX = 1;", "modifier": "public static final", "type": "int", "declarator": "MONTH_INDEX = 1", "var_name": "MONTH_INDEX"}, {"original_string": "public static final int DAY_INDEX = 2;", "modifier": "public static final", "type": "int", "declarator": "DAY_INDEX = 2", "var_name": "DAY_INDEX"}, {"original_string": "public static final int HOUR_INDEX = 3;", "modifier": "public static final", "type": "int", "declarator": "HOUR_INDEX = 3", "var_name": "HOUR_INDEX"}, {"original_string": "public static final int MIN_INDEX = 4;", "modifier": "public static final", "type": "int", "declarator": "MIN_INDEX = 4", "var_name": "MIN_INDEX"}, {"original_string": "public static final int SEC_INDEX = 5;", "modifier": "public static final", "type": "int", "declarator": "SEC_INDEX = 5", "var_name": "SEC_INDEX"}, {"original_string": "public static final int MAX_INDEX = SEC_INDEX;", "modifier": "public static final", "type": "int", "declarator": "MAX_INDEX = SEC_INDEX", "var_name": "MAX_INDEX"}, {"original_string": "private static final long DATETIME_DATE_SCALE = 1000000L;", "modifier": "private static final", "type": "long", "declarator": "DATETIME_DATE_SCALE = 1000000L", "var_name": "DATETIME_DATE_SCALE"}, {"original_string": "private static final long DATETIME_YEAR_SCALE = 10000L * DATETIME_DATE_SCALE;", "modifier": "private static final", "type": "long", "declarator": "DATETIME_YEAR_SCALE = 10000L * DATETIME_DATE_SCALE", "var_name": "DATETIME_YEAR_SCALE"}, {"original_string": "private static final long DATETIME_MONTH_SCALE = 100L * DATETIME_DATE_SCALE;", "modifier": "private static final", "type": "long", "declarator": "DATETIME_MONTH_SCALE = 100L * DATETIME_DATE_SCALE", "var_name": "DATETIME_MONTH_SCALE"}, {"original_string": "private static final long DATETIME_DAY_SCALE = DATETIME_DATE_SCALE;", "modifier": "private static final", "type": "long", "declarator": "DATETIME_DAY_SCALE = DATETIME_DATE_SCALE", "var_name": "DATETIME_DAY_SCALE"}, {"original_string": "private static final long DATETIME_HOUR_SCALE = 10000L;", "modifier": "private static final", "type": "long", "declarator": "DATETIME_HOUR_SCALE = 10000L", "var_name": "DATETIME_HOUR_SCALE"}, {"original_string": "private static final long DATETIME_MIN_SCALE = 100L;", "modifier": "private static final", "type": "long", "declarator": "DATETIME_MIN_SCALE = 100L", "var_name": "DATETIME_MIN_SCALE"}, {"original_string": "private static final int DATE_GROUP = 1;", "modifier": "private static final", "type": "int", "declarator": "DATE_GROUP = 1", "var_name": "DATE_GROUP"}, {"original_string": "private static final int DATE_YEAR_GROUP = 2;", "modifier": "private static final", "type": "int", "declarator": "DATE_YEAR_GROUP = 2", "var_name": "DATE_YEAR_GROUP"}, {"original_string": "private static final int DATE_MONTH_GROUP = 3;", "modifier": "private static final", "type": "int", "declarator": "DATE_MONTH_GROUP = 3", "var_name": "DATE_MONTH_GROUP"}, {"original_string": "private static final int DATE_DAY_GROUP = 4;", "modifier": "private static final", "type": "int", "declarator": "DATE_DAY_GROUP = 4", "var_name": "DATE_DAY_GROUP"}, {"original_string": "private static final int TIME_GROUP = 5;", "modifier": "private static final", "type": "int", "declarator": "TIME_GROUP = 5", "var_name": "TIME_GROUP"}, {"original_string": "private static final int TIME_HOUR_GROUP = 7;", "modifier": "private static final", "type": "int", "declarator": "TIME_HOUR_GROUP = 7", "var_name": "TIME_HOUR_GROUP"}, {"original_string": "private static final int TIME_MINUTE_GROUP = 8;", "modifier": "private static final", "type": "int", "declarator": "TIME_MINUTE_GROUP = 8", "var_name": "TIME_MINUTE_GROUP"}, {"original_string": "private static final int TIME_SECOND_GROUP = 9;", "modifier": "private static final", "type": "int", "declarator": "TIME_SECOND_GROUP = 9", "var_name": "TIME_SECOND_GROUP"}, {"original_string": "private static final int TIME_FRAC_GROUP = 10;", "modifier": "private static final", "type": "int", "declarator": "TIME_FRAC_GROUP = 10", "var_name": "TIME_FRAC_GROUP"}, {"original_string": "private static final int TIME_TIMEZONE_GROUP = 11;", "modifier": "private static final", "type": "int", "declarator": "TIME_TIMEZONE_GROUP = 11", "var_name": "TIME_TIMEZONE_GROUP"}, {"original_string": "private static final Pattern DATE_PATTERN \n            = Pattern.compile(\"^((\\\\d+)-(\\\\d+)-(\\\\d+))(([T]{1}|\\\\s+)(\\\\d+):(\\\\d+):(\\\\d+)(\\\\.\\\\d+)?)?[Z]?(\\\\s*[+-]\\\\d+:?\\\\d+(:?\\\\d+)?)?$\");", "modifier": "private static final", "type": "Pattern", "declarator": "DATE_PATTERN \n            = Pattern.compile(\"^((\\\\d+)-(\\\\d+)-(\\\\d+))(([T]{1}|\\\\s+)(\\\\d+):(\\\\d+):(\\\\d+)(\\\\.\\\\d+)?)?[Z]?(\\\\s*[+-]\\\\d+:?\\\\d+(:?\\\\d+)?)?$\")", "var_name": "DATE_PATTERN"}, {"original_string": "private static final int TIME_WITH_DAY_DAY_GROUP = 2;", "modifier": "private static final", "type": "int", "declarator": "TIME_WITH_DAY_DAY_GROUP = 2", "var_name": "TIME_WITH_DAY_DAY_GROUP"}, {"original_string": "private static final int TIME_WITH_DAY_HOUR_GROUP = 3;", "modifier": "private static final", "type": "int", "declarator": "TIME_WITH_DAY_HOUR_GROUP = 3", "var_name": "TIME_WITH_DAY_HOUR_GROUP"}, {"original_string": "private static final int TIME_WITH_DAY_MIN_GROUP = 4;", "modifier": "private static final", "type": "int", "declarator": "TIME_WITH_DAY_MIN_GROUP = 4", "var_name": "TIME_WITH_DAY_MIN_GROUP"}, {"original_string": "private static final int TIME_WITH_DAY_SEC_GROUP = 5;", "modifier": "private static final", "type": "int", "declarator": "TIME_WITH_DAY_SEC_GROUP = 5", "var_name": "TIME_WITH_DAY_SEC_GROUP"}, {"original_string": "private static final Pattern TIME_WITH_DAY_PATTERN\n            = Pattern.compile(\"^(([-+]?\\\\d+)\\\\s+(\\\\d+):(\\\\d+):(\\\\d+)(\\\\.\\\\d+)?[Z]?(\\\\s*[+-]\\\\d+:?\\\\d+(:?\\\\d+)?)?)?$\");", "modifier": "private static final", "type": "Pattern", "declarator": "TIME_WITH_DAY_PATTERN\n            = Pattern.compile(\"^(([-+]?\\\\d+)\\\\s+(\\\\d+):(\\\\d+):(\\\\d+)(\\\\.\\\\d+)?[Z]?(\\\\s*[+-]\\\\d+:?\\\\d+(:?\\\\d+)?)?)?$\")", "var_name": "TIME_WITH_DAY_PATTERN"}, {"original_string": "private static final int TIME_WITHOUT_DAY_HOUR_GROUP = 2;", "modifier": "private static final", "type": "int", "declarator": "TIME_WITHOUT_DAY_HOUR_GROUP = 2", "var_name": "TIME_WITHOUT_DAY_HOUR_GROUP"}, {"original_string": "private static final int TIME_WITHOUT_DAY_MIN_GROUP = 3;", "modifier": "private static final", "type": "int", "declarator": "TIME_WITHOUT_DAY_MIN_GROUP = 3", "var_name": "TIME_WITHOUT_DAY_MIN_GROUP"}, {"original_string": "private static final int TIME_WITHOUT_DAY_SEC_GROUP = 4;", "modifier": "private static final", "type": "int", "declarator": "TIME_WITHOUT_DAY_SEC_GROUP = 4", "var_name": "TIME_WITHOUT_DAY_SEC_GROUP"}, {"original_string": "private static final Pattern TIME_WITHOUT_DAY_PATTERN\n            = Pattern.compile(\"^(([-+]?\\\\d+):(\\\\d+):(\\\\d+)(\\\\.\\\\d+)?[Z]?(\\\\s*[+-]\\\\d+:?\\\\d+(:?\\\\d+)?)?)?$\");", "modifier": "private static final", "type": "Pattern", "declarator": "TIME_WITHOUT_DAY_PATTERN\n            = Pattern.compile(\"^(([-+]?\\\\d+):(\\\\d+):(\\\\d+)(\\\\.\\\\d+)?[Z]?(\\\\s*[+-]\\\\d+:?\\\\d+(:?\\\\d+)?)?)?$\")", "var_name": "TIME_WITHOUT_DAY_PATTERN"}, {"original_string": "private static final int TZ_SIGN_GROUP = 1;", "modifier": "private static final", "type": "int", "declarator": "TZ_SIGN_GROUP = 1", "var_name": "TZ_SIGN_GROUP"}, {"original_string": "private static final int TZ_HOUR_GROUP = 2;", "modifier": "private static final", "type": "int", "declarator": "TZ_HOUR_GROUP = 2", "var_name": "TZ_HOUR_GROUP"}, {"original_string": "private static final int TZ_MINUTE_GROUP = 3;", "modifier": "private static final", "type": "int", "declarator": "TZ_MINUTE_GROUP = 3", "var_name": "TZ_MINUTE_GROUP"}, {"original_string": "private static final Pattern TZ_PATTERN = Pattern.compile(\"([-+]?)([\\\\d]{1,2}):([\\\\d]{1,2})\");", "modifier": "private static final", "type": "Pattern", "declarator": "TZ_PATTERN = Pattern.compile(\"([-+]?)([\\\\d]{1,2}):([\\\\d]{1,2})\")", "var_name": "TZ_PATTERN"}, {"original_string": "private static final String DELIM = \"\\\\W\";", "modifier": "private static final", "type": "String", "declarator": "DELIM = \"\\\\W\"", "var_name": "DELIM"}, {"original_string": "public static final long TIMESTAMP_MIN = DateTime.parse(\"1970-01-01T00:00:01Z\").getMillis();", "modifier": "public static final", "type": "long", "declarator": "TIMESTAMP_MIN = DateTime.parse(\"1970-01-01T00:00:01Z\").getMillis()", "var_name": "TIMESTAMP_MIN"}, {"original_string": "public static final long TIMESTAMP_MAX = DateTime.parse(\"2038-01-19T03:14:07Z\").getMillis();", "modifier": "public static final", "type": "long", "declarator": "TIMESTAMP_MAX = DateTime.parse(\"2038-01-19T03:14:07Z\").getMillis()", "var_name": "TIMESTAMP_MAX"}, {"original_string": "public static final long TS_ERROR_VALUE = 0L;", "modifier": "public static final", "type": "long", "declarator": "TS_ERROR_VALUE = 0L", "var_name": "TS_ERROR_VALUE"}, {"original_string": "public static final int TIME_MAX = 8385959;", "modifier": "public static final", "type": "int", "declarator": "TIME_MAX = 8385959", "var_name": "TIME_MAX"}, {"original_string": "public static final int TIME_MIN = -8385959;", "modifier": "public static final", "type": "int", "declarator": "TIME_MIN = -8385959", "var_name": "TIME_MIN"}], "methods": [{"identifier": "getMonthName", "parameters": "(int numericRep, String locale, TExecutionContext context)", "modifiers": "public static", "return": "String", "signature": "String getMonthName(int numericRep, String locale, TExecutionContext context)", "full_signature": "public static String getMonthName(int numericRep, String locale, TExecutionContext context)", "class_method_signature": "MDateAndTime.getMonthName(int numericRep, String locale, TExecutionContext context)", "testcase": false, "constructor": false}, {"identifier": "fromJodaDateTime", "parameters": "(AbstractDateTime date)", "modifiers": "public static", "return": "long[]", "signature": "long[] fromJodaDateTime(AbstractDateTime date)", "full_signature": "public static long[] fromJodaDateTime(AbstractDateTime date)", "class_method_signature": "MDateAndTime.fromJodaDateTime(AbstractDateTime date)", "testcase": false, "constructor": false}, {"identifier": "toJodaDateTime", "parameters": "(long[] dt, String tz)", "modifiers": "public static", "return": "MutableDateTime", "signature": "MutableDateTime toJodaDateTime(long[] dt, String tz)", "full_signature": "public static MutableDateTime toJodaDateTime(long[] dt, String tz)", "class_method_signature": "MDateAndTime.toJodaDateTime(long[] dt, String tz)", "testcase": false, "constructor": false}, {"identifier": "toJodaDateTime", "parameters": "(long[] dt, DateTimeZone dtz)", "modifiers": "public static", "return": "MutableDateTime", "signature": "MutableDateTime toJodaDateTime(long[] dt, DateTimeZone dtz)", "full_signature": "public static MutableDateTime toJodaDateTime(long[] dt, DateTimeZone dtz)", "class_method_signature": "MDateAndTime.toJodaDateTime(long[] dt, DateTimeZone dtz)", "testcase": false, "constructor": false}, {"identifier": "dateToString", "parameters": "(int encodedDate)", "modifiers": "public static", "return": "String", "signature": "String dateToString(int encodedDate)", "full_signature": "public static String dateToString(int encodedDate)", "class_method_signature": "MDateAndTime.dateToString(int encodedDate)", "testcase": false, "constructor": false}, {"identifier": "parseAndEncodeDate", "parameters": "(String input)", "modifiers": "public static", "return": "int", "signature": "int parseAndEncodeDate(String input)", "full_signature": "public static int parseAndEncodeDate(String input)", "class_method_signature": "MDateAndTime.parseAndEncodeDate(String input)", "testcase": false, "constructor": false}, {"identifier": "encodeDate", "parameters": "(long millis, String tz)", "modifiers": "public static", "return": "int", "signature": "int encodeDate(long millis, String tz)", "full_signature": "public static int encodeDate(long millis, String tz)", "class_method_signature": "MDateAndTime.encodeDate(long millis, String tz)", "testcase": false, "constructor": false}, {"identifier": "encodeDate", "parameters": "(long[] dt)", "modifiers": "public static", "return": "int", "signature": "int encodeDate(long[] dt)", "full_signature": "public static int encodeDate(long[] dt)", "class_method_signature": "MDateAndTime.encodeDate(long[] dt)", "testcase": false, "constructor": false}, {"identifier": "encodeDate", "parameters": "(long y, long m, long d)", "modifiers": "public static", "return": "int", "signature": "int encodeDate(long y, long m, long d)", "full_signature": "public static int encodeDate(long y, long m, long d)", "class_method_signature": "MDateAndTime.encodeDate(long y, long m, long d)", "testcase": false, "constructor": false}, {"identifier": "decodeDate", "parameters": "(long encodedDate)", "modifiers": "public static", "return": "long[]", "signature": "long[] decodeDate(long encodedDate)", "full_signature": "public static long[] decodeDate(long encodedDate)", "class_method_signature": "MDateAndTime.decodeDate(long encodedDate)", "testcase": false, "constructor": false}, {"identifier": "parseDate", "parameters": "(long val)", "modifiers": "public static", "return": "long[]", "signature": "long[] parseDate(long val)", "full_signature": "public static long[] parseDate(long val)", "class_method_signature": "MDateAndTime.parseDate(long val)", "testcase": false, "constructor": false}, {"identifier": "parseDateTime", "parameters": "(long val)", "modifiers": "public static", "return": "long[]", "signature": "long[] parseDateTime(long val)", "full_signature": "public static long[] parseDateTime(long val)", "class_method_signature": "MDateAndTime.parseDateTime(long val)", "testcase": false, "constructor": false}, {"identifier": "dateTimeToString", "parameters": "(long encodedDateTime)", "modifiers": "public static", "return": "String", "signature": "String dateTimeToString(long encodedDateTime)", "full_signature": "public static String dateTimeToString(long encodedDateTime)", "class_method_signature": "MDateAndTime.dateTimeToString(long encodedDateTime)", "testcase": false, "constructor": false}, {"identifier": "dateTimeToString", "parameters": "(long[] dt)", "modifiers": "public static", "return": "String", "signature": "String dateTimeToString(long[] dt)", "full_signature": "public static String dateTimeToString(long[] dt)", "class_method_signature": "MDateAndTime.dateTimeToString(long[] dt)", "testcase": false, "constructor": false}, {"identifier": "parseDateOrTime", "parameters": "(String st, long[] dt)", "modifiers": "public static", "return": "StringType", "signature": "StringType parseDateOrTime(String st, long[] dt)", "full_signature": "public static StringType parseDateOrTime(String st, long[] dt)", "class_method_signature": "MDateAndTime.parseDateOrTime(String st, long[] dt)", "testcase": false, "constructor": false}, {"identifier": "parseAndEncodeDateTime", "parameters": "(String input)", "modifiers": "public static", "return": "long", "signature": "long parseAndEncodeDateTime(String input)", "full_signature": "public static long parseAndEncodeDateTime(String input)", "class_method_signature": "MDateAndTime.parseAndEncodeDateTime(String input)", "testcase": false, "constructor": false}, {"identifier": "encodeDateTime", "parameters": "(long millis, String tz)", "modifiers": "public static", "return": "long", "signature": "long encodeDateTime(long millis, String tz)", "full_signature": "public static long encodeDateTime(long millis, String tz)", "class_method_signature": "MDateAndTime.encodeDateTime(long millis, String tz)", "testcase": false, "constructor": false}, {"identifier": "encodeDateTime", "parameters": "(BaseDateTime dt)", "modifiers": "public static", "return": "long", "signature": "long encodeDateTime(BaseDateTime dt)", "full_signature": "public static long encodeDateTime(BaseDateTime dt)", "class_method_signature": "MDateAndTime.encodeDateTime(BaseDateTime dt)", "testcase": false, "constructor": false}, {"identifier": "encodeDateTime", "parameters": "(long[] dt)", "modifiers": "public static", "return": "long", "signature": "long encodeDateTime(long[] dt)", "full_signature": "public static long encodeDateTime(long[] dt)", "class_method_signature": "MDateAndTime.encodeDateTime(long[] dt)", "testcase": false, "constructor": false}, {"identifier": "encodeDateTime", "parameters": "(long year, long month, long day, long hour, long min, long sec)", "modifiers": "public static", "return": "long", "signature": "long encodeDateTime(long year, long month, long day, long hour, long min, long sec)", "full_signature": "public static long encodeDateTime(long year, long month, long day, long hour, long min, long sec)", "class_method_signature": "MDateAndTime.encodeDateTime(long year, long month, long day, long hour, long min, long sec)", "testcase": false, "constructor": false}, {"identifier": "decodeDateTime", "parameters": "(long encodedDateTime)", "modifiers": "public static", "return": "long[]", "signature": "long[] decodeDateTime(long encodedDateTime)", "full_signature": "public static long[] decodeDateTime(long encodedDateTime)", "class_method_signature": "MDateAndTime.decodeDateTime(long encodedDateTime)", "testcase": false, "constructor": false}, {"identifier": "timeToString", "parameters": "(int encodedTime)", "modifiers": "public static", "return": "String", "signature": "String timeToString(int encodedTime)", "full_signature": "public static String timeToString(int encodedTime)", "class_method_signature": "MDateAndTime.timeToString(int encodedTime)", "testcase": false, "constructor": false}, {"identifier": "timeToString", "parameters": "(long[] dt)", "modifiers": "public static", "return": "String", "signature": "String timeToString(long[] dt)", "full_signature": "public static String timeToString(long[] dt)", "class_method_signature": "MDateAndTime.timeToString(long[] dt)", "testcase": false, "constructor": false}, {"identifier": "timeToString", "parameters": "(long h, long m, long s)", "modifiers": "public static", "return": "String", "signature": "String timeToString(long h, long m, long s)", "full_signature": "public static String timeToString(long h, long m, long s)", "class_method_signature": "MDateAndTime.timeToString(long h, long m, long s)", "testcase": false, "constructor": false}, {"identifier": "timeToDatetime", "parameters": "(long[] dt)", "modifiers": "public static", "return": "void", "signature": "void timeToDatetime(long[] dt)", "full_signature": "public static void timeToDatetime(long[] dt)", "class_method_signature": "MDateAndTime.timeToDatetime(long[] dt)", "testcase": false, "constructor": false}, {"identifier": "parseTime", "parameters": "(String string, TExecutionContext context)", "modifiers": "public static", "return": "int", "signature": "int parseTime(String string, TExecutionContext context)", "full_signature": "public static int parseTime(String string, TExecutionContext context)", "class_method_signature": "MDateAndTime.parseTime(String string, TExecutionContext context)", "testcase": false, "constructor": false}, {"identifier": "decodeTime", "parameters": "(long encodedTime)", "modifiers": "public static", "return": "long[]", "signature": "long[] decodeTime(long encodedTime)", "full_signature": "public static long[] decodeTime(long encodedTime)", "class_method_signature": "MDateAndTime.decodeTime(long encodedTime)", "testcase": false, "constructor": false}, {"identifier": "encodeTime", "parameters": "(long millis, String tz)", "modifiers": "public static", "return": "int", "signature": "int encodeTime(long millis, String tz)", "full_signature": "public static int encodeTime(long millis, String tz)", "class_method_signature": "MDateAndTime.encodeTime(long millis, String tz)", "testcase": false, "constructor": false}, {"identifier": "encodeTime", "parameters": "(long[] dt, TExecutionContext context)", "modifiers": "public static", "return": "int", "signature": "int encodeTime(long[] dt, TExecutionContext context)", "full_signature": "public static int encodeTime(long[] dt, TExecutionContext context)", "class_method_signature": "MDateAndTime.encodeTime(long[] dt, TExecutionContext context)", "testcase": false, "constructor": false}, {"identifier": "encodeTime", "parameters": "(long h, long m, long s, TExecutionContext context)", "modifiers": "public static", "return": "int", "signature": "int encodeTime(long h, long m, long s, TExecutionContext context)", "full_signature": "public static int encodeTime(long h, long m, long s, TExecutionContext context)", "class_method_signature": "MDateAndTime.encodeTime(long h, long m, long s, TExecutionContext context)", "testcase": false, "constructor": false}, {"identifier": "parseAndEncodeTimestamp", "parameters": "(String input, String tz, TExecutionContext context)", "modifiers": "public static", "return": "int", "signature": "int parseAndEncodeTimestamp(String input, String tz, TExecutionContext context)", "full_signature": "public static int parseAndEncodeTimestamp(String input, String tz, TExecutionContext context)", "class_method_signature": "MDateAndTime.parseAndEncodeTimestamp(String input, String tz, TExecutionContext context)", "testcase": false, "constructor": false}, {"identifier": "decodeTimestamp", "parameters": "(long encodedTimestamp, String tz)", "modifiers": "public static", "return": "long[]", "signature": "long[] decodeTimestamp(long encodedTimestamp, String tz)", "full_signature": "public static long[] decodeTimestamp(long encodedTimestamp, String tz)", "class_method_signature": "MDateAndTime.decodeTimestamp(long encodedTimestamp, String tz)", "testcase": false, "constructor": false}, {"identifier": "encodeTimestamp", "parameters": "(long[] dt, String tz, TExecutionContext context)", "modifiers": "public static", "return": "int", "signature": "int encodeTimestamp(long[] dt, String tz, TExecutionContext context)", "full_signature": "public static int encodeTimestamp(long[] dt, String tz, TExecutionContext context)", "class_method_signature": "MDateAndTime.encodeTimestamp(long[] dt, String tz, TExecutionContext context)", "testcase": false, "constructor": false}, {"identifier": "encodeTimestamp", "parameters": "(BaseDateTime dateTime, TExecutionContext context)", "modifiers": "public static", "return": "int", "signature": "int encodeTimestamp(BaseDateTime dateTime, TExecutionContext context)", "full_signature": "public static int encodeTimestamp(BaseDateTime dateTime, TExecutionContext context)", "class_method_signature": "MDateAndTime.encodeTimestamp(BaseDateTime dateTime, TExecutionContext context)", "testcase": false, "constructor": false}, {"identifier": "encodeTimestamp", "parameters": "(long millis, TExecutionContext context)", "modifiers": "public static", "return": "int", "signature": "int encodeTimestamp(long millis, TExecutionContext context)", "full_signature": "public static int encodeTimestamp(long millis, TExecutionContext context)", "class_method_signature": "MDateAndTime.encodeTimestamp(long millis, TExecutionContext context)", "testcase": false, "constructor": false}, {"identifier": "isValidTimestamp", "parameters": "(BaseDateTime dt)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidTimestamp(BaseDateTime dt)", "full_signature": "public static boolean isValidTimestamp(BaseDateTime dt)", "class_method_signature": "MDateAndTime.isValidTimestamp(BaseDateTime dt)", "testcase": false, "constructor": false}, {"identifier": "getTimestamp", "parameters": "(long[] dt, String tz)", "modifiers": "public static", "return": "int", "signature": "int getTimestamp(long[] dt, String tz)", "full_signature": "public static int getTimestamp(long[] dt, String tz)", "class_method_signature": "MDateAndTime.getTimestamp(long[] dt, String tz)", "testcase": false, "constructor": false}, {"identifier": "timestampToString", "parameters": "(long encodedTimestamp, String tz)", "modifiers": "public static", "return": "String", "signature": "String timestampToString(long encodedTimestamp, String tz)", "full_signature": "public static String timestampToString(long encodedTimestamp, String tz)", "class_method_signature": "MDateAndTime.timestampToString(long encodedTimestamp, String tz)", "testcase": false, "constructor": false}, {"identifier": "parseTimeZone", "parameters": "(String tz)", "modifiers": "public static", "return": "DateTimeZone", "signature": "DateTimeZone parseTimeZone(String tz)", "full_signature": "public static DateTimeZone parseTimeZone(String tz)", "class_method_signature": "MDateAndTime.parseTimeZone(String tz)", "testcase": false, "constructor": false}, {"identifier": "isValidDateTime_Zeros", "parameters": "(long[] dt)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidDateTime_Zeros(long[] dt)", "full_signature": "public static boolean isValidDateTime_Zeros(long[] dt)", "class_method_signature": "MDateAndTime.isValidDateTime_Zeros(long[] dt)", "testcase": false, "constructor": false}, {"identifier": "isValidDateTime", "parameters": "(long[] dt, ZeroFlag... flags)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidDateTime(long[] dt, ZeroFlag... flags)", "full_signature": "public static boolean isValidDateTime(long[] dt, ZeroFlag... flags)", "class_method_signature": "MDateAndTime.isValidDateTime(long[] dt, ZeroFlag... flags)", "testcase": false, "constructor": false}, {"identifier": "isHrMinSecNegative", "parameters": "(long[] dt)", "modifiers": "public static", "return": "boolean", "signature": "boolean isHrMinSecNegative(long[] dt)", "full_signature": "public static boolean isHrMinSecNegative(long[] dt)", "class_method_signature": "MDateAndTime.isHrMinSecNegative(long[] dt)", "testcase": false, "constructor": false}, {"identifier": "isHrMinSecNegative", "parameters": "(long h, long m, long s)", "modifiers": "public static", "return": "boolean", "signature": "boolean isHrMinSecNegative(long h, long m, long s)", "full_signature": "public static boolean isHrMinSecNegative(long h, long m, long s)", "class_method_signature": "MDateAndTime.isHrMinSecNegative(long h, long m, long s)", "testcase": false, "constructor": false}, {"identifier": "isValidHrMinSec", "parameters": "(long[] dt, boolean checkHour, boolean isFromDateTime)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidHrMinSec(long[] dt, boolean checkHour, boolean isFromDateTime)", "full_signature": "public static boolean isValidHrMinSec(long[] dt, boolean checkHour, boolean isFromDateTime)", "class_method_signature": "MDateAndTime.isValidHrMinSec(long[] dt, boolean checkHour, boolean isFromDateTime)", "testcase": false, "constructor": false}, {"identifier": "isValidHrMinSec", "parameters": "(long h, long m, long s, boolean checkHour, boolean isFromDateTime)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidHrMinSec(long h, long m, long s, boolean checkHour, boolean isFromDateTime)", "full_signature": "public static boolean isValidHrMinSec(long h, long m, long s, boolean checkHour, boolean isFromDateTime)", "class_method_signature": "MDateAndTime.isValidHrMinSec(long h, long m, long s, boolean checkHour, boolean isFromDateTime)", "testcase": false, "constructor": false}, {"identifier": "isZeroDayMonth", "parameters": "(long[] dt)", "modifiers": "public static", "return": "boolean", "signature": "boolean isZeroDayMonth(long[] dt)", "full_signature": "public static boolean isZeroDayMonth(long[] dt)", "class_method_signature": "MDateAndTime.isZeroDayMonth(long[] dt)", "testcase": false, "constructor": false}, {"identifier": "isValidDate_Zeros", "parameters": "(long[] dt)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidDate_Zeros(long[] dt)", "full_signature": "public static boolean isValidDate_Zeros(long[] dt)", "class_method_signature": "MDateAndTime.isValidDate_Zeros(long[] dt)", "testcase": false, "constructor": false}, {"identifier": "isValidDate_NoZeros", "parameters": "(long[] dt)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidDate_NoZeros(long[] dt)", "full_signature": "public static boolean isValidDate_NoZeros(long[] dt)", "class_method_signature": "MDateAndTime.isValidDate_NoZeros(long[] dt)", "testcase": false, "constructor": false}, {"identifier": "isValidDate", "parameters": "(long[] dt, ZeroFlag... flags)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidDate(long[] dt, ZeroFlag... flags)", "full_signature": "public static boolean isValidDate(long[] dt, ZeroFlag... flags)", "class_method_signature": "MDateAndTime.isValidDate(long[] dt, ZeroFlag... flags)", "testcase": false, "constructor": false}, {"identifier": "isValidDate", "parameters": "(long y, long m, long d, ZeroFlag... flags)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidDate(long y, long m, long d, ZeroFlag... flags)", "full_signature": "public static boolean isValidDate(long y, long m, long d, ZeroFlag... flags)", "class_method_signature": "MDateAndTime.isValidDate(long y, long m, long d, ZeroFlag... flags)", "testcase": false, "constructor": false}, {"identifier": "getLastDay", "parameters": "(long[] dt)", "modifiers": "public static", "return": "long", "signature": "long getLastDay(long[] dt)", "full_signature": "public static long getLastDay(long[] dt)", "class_method_signature": "MDateAndTime.getLastDay(long[] dt)", "testcase": false, "constructor": false}, {"identifier": "getLastDay", "parameters": "(long year, long month)", "modifiers": "public static", "return": "long", "signature": "long getLastDay(long year, long month)", "full_signature": "public static long getLastDay(long year, long month)", "class_method_signature": "MDateAndTime.getLastDay(long year, long month)", "testcase": false, "constructor": false}, {"identifier": "adjustTwoDigitYear", "parameters": "(long year)", "modifiers": "protected static", "return": "long", "signature": "long adjustTwoDigitYear(long year)", "full_signature": "protected static long adjustTwoDigitYear(long year)", "class_method_signature": "MDateAndTime.adjustTwoDigitYear(long year)", "testcase": false, "constructor": false}, {"identifier": "stringsToLongs", "parameters": "(long[] dt, boolean convertYear, String... parts)", "modifiers": "private static", "return": "boolean", "signature": "boolean stringsToLongs(long[] dt, boolean convertYear, String... parts)", "full_signature": "private static boolean stringsToLongs(long[] dt, boolean convertYear, String... parts)", "class_method_signature": "MDateAndTime.stringsToLongs(long[] dt, boolean convertYear, String... parts)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(ZeroFlag[] flags, ZeroFlag flag)", "modifiers": "private static", "return": "boolean", "signature": "boolean contains(ZeroFlag[] flags, ZeroFlag flag)", "full_signature": "private static boolean contains(ZeroFlag[] flags, ZeroFlag flag)", "class_method_signature": "MDateAndTime.contains(ZeroFlag[] flags, ZeroFlag flag)", "testcase": false, "constructor": false}, {"identifier": "isValidType", "parameters": "(StringType type)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidType(StringType type)", "full_signature": "public static boolean isValidType(StringType type)", "class_method_signature": "MDateAndTime.isValidType(StringType type)", "testcase": false, "constructor": false}], "file": "fdb-sql-layer-core/src/main/java/com/foundationdb/server/types/mcompat/mtypes/MDateAndTime.java"}, "focal_method": {"identifier": "parseDate", "parameters": "(long val)", "modifiers": "public static", "return": "long[]", "body": "public static long[] parseDate(long val) {\n        long[] dt = parseDateTime(val);\n        dt[HOUR_INDEX] = dt[MIN_INDEX] = dt[SEC_INDEX] = 0;\n        return dt;\n    }", "signature": "long[] parseDate(long val)", "full_signature": "public static long[] parseDate(long val)", "class_method_signature": "MDateAndTime.parseDate(long val)", "testcase": false, "constructor": false, "invocations": ["parseDateTime"]}, "repository": {"repo_id": 32884360, "url": "https://github.com/jaytaylor/sql-layer", "language": "Java", "is_fork": false, "fork_count": 120, "stargazer_count": 77, "size": 138665, "license": "licensed"}}