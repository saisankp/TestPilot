{"test_class": {"identifier": "ClientDAOTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Inject DSLContext jooqContext;", "modifier": "@Inject", "type": "DSLContext", "declarator": "jooqContext", "var_name": "jooqContext"}, {"original_string": "@Inject ClientDAOFactory clientDAOFactory;", "modifier": "@Inject", "type": "ClientDAOFactory", "declarator": "clientDAOFactory", "var_name": "clientDAOFactory"}, {"original_string": "Client client1, client2;", "modifier": "", "type": "Client", "declarator": "client1", "var_name": "client1"}, {"original_string": "ClientDAO clientDAO;", "modifier": "", "type": "ClientDAO", "declarator": "clientDAO", "var_name": "clientDAO"}], "file": "server/src/test/java/keywhiz/service/daos/ClientDAOTest.java"}, "test_case": {"identifier": "sawClientTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void sawClientTest() {\n    assertThat(client1.getLastSeen()).isNull();\n    assertThat(client2.getLastSeen()).isNull();\n\n    Instant expiration = Instant.now();\n    // Remove nanos because database drops it on storage, and we want\n    // to compare later to make sure the proper expiration was set in DB.\n    expiration = expiration.minusNanos(expiration.get(NANO_OF_SECOND));\n\n    CertificatePrincipal principal = mock(CertificatePrincipal.class);\n    when(principal.getCertificateExpiration()).thenReturn(expiration);\n\n    ApiDate now = ApiDate.now();\n    clientDAO.sawClient(client1, principal);\n\n    // reload clients from db, as sawClient doesn't update in-memory object\n    Client client1v2 = clientDAO.getClientByName(client1.getName()).get();\n    Client client2v2 = clientDAO.getClientByName(client2.getName()).get();\n\n    // verify client1 from db has updated lastSeen, and client2 hasn't changed\n    assertThat(client1v2.getLastSeen()).isNotNull();\n    assertTrue(client1v2.getLastSeen().toEpochSecond() >= now.toEpochSecond());\n    assertThat(client2v2.getLastSeen()).isNull();\n    assertThat(client1v2.getExpiration()).isNotNull();\n    assertThat(client1v2.getExpiration().toInstant()).isEqualTo(expiration);\n    assertThat(client2v2.getExpiration()).isNull();\n  }", "signature": "void sawClientTest()", "full_signature": "@Test public void sawClientTest()", "class_method_signature": "ClientDAOTest.sawClientTest()", "testcase": true, "constructor": false, "invocations": ["isNull", "assertThat", "getLastSeen", "isNull", "assertThat", "getLastSeen", "now", "minusNanos", "get", "mock", "thenReturn", "when", "getCertificateExpiration", "now", "sawClient", "get", "getClientByName", "getName", "get", "getClientByName", "getName", "isNotNull", "assertThat", "getLastSeen", "assertTrue", "toEpochSecond", "getLastSeen", "toEpochSecond", "isNull", "assertThat", "getLastSeen", "isNotNull", "assertThat", "getExpiration", "isEqualTo", "assertThat", "toInstant", "getExpiration", "isNull", "assertThat", "getExpiration"]}, "focal_class": {"identifier": "ClientDAO", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final static Duration LAST_SEEN_THRESHOLD = Duration.ofSeconds(24 * 60 * 60);", "modifier": "private final static", "type": "Duration", "declarator": "LAST_SEEN_THRESHOLD = Duration.ofSeconds(24 * 60 * 60)", "var_name": "LAST_SEEN_THRESHOLD"}, {"original_string": "private final DSLContext dslContext;", "modifier": "private final", "type": "DSLContext", "declarator": "dslContext", "var_name": "dslContext"}, {"original_string": "private final ClientMapper clientMapper;", "modifier": "private final", "type": "ClientMapper", "declarator": "clientMapper", "var_name": "clientMapper"}, {"original_string": "private final RowHmacGenerator rowHmacGenerator;", "modifier": "private final", "type": "RowHmacGenerator", "declarator": "rowHmacGenerator", "var_name": "rowHmacGenerator"}], "methods": [{"identifier": "ClientDAO", "parameters": "(DSLContext dslContext, ClientMapper clientMapper,\n      RowHmacGenerator rowHmacGenerator)", "modifiers": "private", "return": "", "signature": " ClientDAO(DSLContext dslContext, ClientMapper clientMapper,\n      RowHmacGenerator rowHmacGenerator)", "full_signature": "private  ClientDAO(DSLContext dslContext, ClientMapper clientMapper,\n      RowHmacGenerator rowHmacGenerator)", "class_method_signature": "ClientDAO.ClientDAO(DSLContext dslContext, ClientMapper clientMapper,\n      RowHmacGenerator rowHmacGenerator)", "testcase": false, "constructor": true}, {"identifier": "createClient", "parameters": "(String name, String user, String description,\n      @Nullable URI spiffeId)", "modifiers": "public", "return": "long", "signature": "long createClient(String name, String user, String description,\n      @Nullable URI spiffeId)", "full_signature": "public long createClient(String name, String user, String description,\n      @Nullable URI spiffeId)", "class_method_signature": "ClientDAO.createClient(String name, String user, String description,\n      @Nullable URI spiffeId)", "testcase": false, "constructor": false}, {"identifier": "deleteClient", "parameters": "(Client client)", "modifiers": "public", "return": "void", "signature": "void deleteClient(Client client)", "full_signature": "public void deleteClient(Client client)", "class_method_signature": "ClientDAO.deleteClient(Client client)", "testcase": false, "constructor": false}, {"identifier": "sawClient", "parameters": "(Client client, @Nullable Principal principal)", "modifiers": "public", "return": "void", "signature": "void sawClient(Client client, @Nullable Principal principal)", "full_signature": "public void sawClient(Client client, @Nullable Principal principal)", "class_method_signature": "ClientDAO.sawClient(Client client, @Nullable Principal principal)", "testcase": false, "constructor": false}, {"identifier": "getClientByName", "parameters": "(String name)", "modifiers": "public", "return": "Optional<Client>", "signature": "Optional<Client> getClientByName(String name)", "full_signature": "public Optional<Client> getClientByName(String name)", "class_method_signature": "ClientDAO.getClientByName(String name)", "testcase": false, "constructor": false}, {"identifier": "getClientBySpiffeId", "parameters": "(URI spiffeId)", "modifiers": "public", "return": "Optional<Client>", "signature": "Optional<Client> getClientBySpiffeId(URI spiffeId)", "full_signature": "public Optional<Client> getClientBySpiffeId(URI spiffeId)", "class_method_signature": "ClientDAO.getClientBySpiffeId(URI spiffeId)", "testcase": false, "constructor": false}, {"identifier": "getClientById", "parameters": "(long id)", "modifiers": "public", "return": "Optional<Client>", "signature": "Optional<Client> getClientById(long id)", "full_signature": "public Optional<Client> getClientById(long id)", "class_method_signature": "ClientDAO.getClientById(long id)", "testcase": false, "constructor": false}, {"identifier": "getClients", "parameters": "()", "modifiers": "public", "return": "ImmutableSet<Client>", "signature": "ImmutableSet<Client> getClients()", "full_signature": "public ImmutableSet<Client> getClients()", "class_method_signature": "ClientDAO.getClients()", "testcase": false, "constructor": false}], "file": "server/src/main/java/keywhiz/service/daos/ClientDAO.java"}, "focal_method": {"identifier": "sawClient", "parameters": "(Client client, @Nullable Principal principal)", "modifiers": "public", "return": "void", "body": "public void sawClient(Client client, @Nullable Principal principal) {\n    Instant now = Instant.now();\n\n    Instant lastSeen = Optional.ofNullable(client.getLastSeen())\n        .map(ls -> Instant.ofEpochSecond(ls.toEpochSecond()))\n        .orElse(EPOCH);\n\n    final Instant expiration;\n    if (principal instanceof CertificatePrincipal) {\n      expiration = ((CertificatePrincipal) principal).getCertificateExpiration();\n    } else {\n      expiration = EPOCH;\n    }\n\n    // Only update last seen if it's been more than `lastSeenThreshold` seconds\n    // this way we can have less granularity on lastSeen and save DB writes\n    if (now.isAfter(lastSeen.plus(LAST_SEEN_THRESHOLD))) {\n      dslContext.transaction(configuration -> {\n        Param<Long> lastSeenValue = DSL.val(now.getEpochSecond(), CLIENTS.LASTSEEN);\n        Param<Long> expirationValue = DSL.val(expiration.getEpochSecond(), CLIENTS.EXPIRATION);\n\n        DSL.using(configuration)\n            .update(CLIENTS)\n            .set(CLIENTS.LASTSEEN,\n                when(CLIENTS.LASTSEEN.isNull(), lastSeenValue)\n                    .otherwise(greatest(CLIENTS.LASTSEEN, lastSeenValue)))\n            .set(CLIENTS.EXPIRATION, expirationValue)\n            .where(CLIENTS.ID.eq(client.getId()))\n            .execute();\n      });\n    }\n  }", "signature": "void sawClient(Client client, @Nullable Principal principal)", "full_signature": "public void sawClient(Client client, @Nullable Principal principal)", "class_method_signature": "ClientDAO.sawClient(Client client, @Nullable Principal principal)", "testcase": false, "constructor": false, "invocations": ["now", "orElse", "map", "ofNullable", "getLastSeen", "ofEpochSecond", "toEpochSecond", "getCertificateExpiration", "isAfter", "plus", "transaction", "val", "getEpochSecond", "val", "getEpochSecond", "execute", "where", "set", "set", "update", "using", "otherwise", "when", "isNull", "greatest", "eq", "getId"]}, "repository": {"repo_id": 32866430, "url": "https://github.com/square/keywhiz", "stars": 2186, "created": "3/25/2015 1:31:39 PM +00:00", "updates": "2020-01-24T18:57:02+00:00", "fork": "False", "license": "licensed"}}