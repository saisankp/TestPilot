{"test_class": {"identifier": "SyncFileManagerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(SyncFileManagerTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(SyncFileManagerTest.class)", "var_name": "logger"}, {"original_string": "private ISyncFileManager manager = SyncFileManager.getInstance();", "modifier": "private", "type": "ISyncFileManager", "declarator": "manager = SyncFileManager.getInstance()", "var_name": "manager"}, {"original_string": "private SyncSenderConfig config = SyncSenderDescriptor.getInstance().getConfig();", "modifier": "private", "type": "SyncSenderConfig", "declarator": "config = SyncSenderDescriptor.getInstance().getConfig()", "var_name": "config"}, {"original_string": "private String dataDir;", "modifier": "private", "type": "String", "declarator": "dataDir", "var_name": "dataDir"}], "file": "server/src/test/java/org/apache/iotdb/db/sync/sender/manage/SyncFileManagerTest.java"}, "test_case": {"identifier": "testGetValidFiles", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testGetValidFiles() throws IOException, MetadataException {\n    Map<String, Map<Long, Set<File>>> allFileList = new HashMap<>();\n\n    Random r = new Random(0);\n    for (int i = 0; i < 3; i++) {\n      IoTDB.metaManager.setStorageGroup(new PartialPath(getSgName(i)));\n    }\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 5; j++) {\n        allFileList.computeIfAbsent(getSgName(i), k -> new HashMap<>())\n            .computeIfAbsent(0L, k -> new HashSet<>());\n        String rand = r.nextInt(10000) + TSFILE_SUFFIX;\n        String fileName = FilePathUtils.regularizePath(dataDir) + IoTDBConstant.SEQUENCE_FLODER_NAME\n            + File.separator + getSgName(i) + File.separator + \"0\" + File.separator + rand;\n        File file = new File(fileName);\n        allFileList.get(getSgName(i)).get(0L).add(file);\n        if (!file.getParentFile().exists()) {\n          file.getParentFile().mkdirs();\n        }\n        if (!file.exists() && !file.createNewFile()) {\n          logger.error(\"Can not create new file {}\", file.getPath());\n        }\n        if (!new File(file.getAbsolutePath() + TsFileResource.RESOURCE_SUFFIX).exists()\n            && !new File(file.getAbsolutePath() + TsFileResource.RESOURCE_SUFFIX).createNewFile()) {\n          logger.error(\"Can not create new file {}\", file.getPath());\n        }\n      }\n    }\n    Map<String, Map<Long, Set<File>>> lastFileMap;\n    Map<String, Map<Long, Set<File>>> curFileMap;\n    Map<String, Map<Long, Set<File>>> deletedFilesMap;\n    Map<String, Map<Long, Set<File>>> toBeSyncedFilesMap;\n\n    // lastFileList is empty\n    manager.getValidFiles(dataDir);\n    assertTrue(SyncUtils.isEmpty(manager.getLastLocalFilesMap()));\n\n    updateLastLocalFiles(allFileList);\n\n    manager.getValidFiles(dataDir);\n    lastFileMap = manager.getLastLocalFilesMap();\n    assertFileMap(allFileList, lastFileMap);\n\n    // add some files\n    Map<String, Map<Long, Set<File>>> correctToBeSyncedFiles = new HashMap<>();\n    r = new Random(1);\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 5; j++) {\n        allFileList.computeIfAbsent(getSgName(i), k -> new HashMap<>())\n            .computeIfAbsent(0L, k -> new HashSet<>());\n        correctToBeSyncedFiles.computeIfAbsent(getSgName(i), k -> new HashMap<>())\n            .computeIfAbsent(0L, k -> new HashSet<>());\n        String rand = r.nextInt(10000) + TSFILE_SUFFIX;\n        String fileName =\n            FilePathUtils.regularizePath(dataDir) + IoTDBConstant.SEQUENCE_FLODER_NAME\n                + File.separator + getSgName(i) + File.separator + \"0\" + File.separator + rand;\n        File file = new File(fileName);\n        allFileList.get(getSgName(i)).get(0L).add(file);\n        correctToBeSyncedFiles.get(getSgName(i)).get(0L).add(file);\n        if (!file.getParentFile().exists()) {\n          file.getParentFile().mkdirs();\n        }\n        if (!file.exists() && !file.createNewFile()) {\n          logger.error(\"Can not create new file {}\", file.getPath());\n        }\n        if (!new File(file.getAbsolutePath() + TsFileResource.RESOURCE_SUFFIX).exists()\n            && !new File(file.getAbsolutePath() + TsFileResource.RESOURCE_SUFFIX).createNewFile()) {\n          logger.error(\"Can not create new file {}\", file.getPath());\n        }\n      }\n    }\n    manager.getValidFiles(dataDir);\n    curFileMap = manager.getCurrentSealedLocalFilesMap();\n    toBeSyncedFilesMap = manager.getToBeSyncedFilesMap();\n    assertFileMap(allFileList, curFileMap);\n    assertFileMap(correctToBeSyncedFiles, toBeSyncedFilesMap);\n\n    updateLastLocalFiles(allFileList);\n    manager.getValidFiles(dataDir);\n    lastFileMap = manager.getLastLocalFilesMap();\n\n    assertFileMap(allFileList, lastFileMap);\n\n    // add some files and delete some files\n    correctToBeSyncedFiles.clear();\n    r = new Random(2);\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 5; j++) {\n        allFileList.computeIfAbsent(getSgName(i), k -> new HashMap<>())\n            .computeIfAbsent(0L, k -> new HashSet<>());\n        correctToBeSyncedFiles.computeIfAbsent(getSgName(i), k -> new HashMap<>())\n            .computeIfAbsent(0L, k -> new HashSet<>());\n        String rand = r.nextInt(10000) + TSFILE_SUFFIX;\n        String fileName =\n            FilePathUtils.regularizePath(dataDir) + IoTDBConstant.SEQUENCE_FLODER_NAME\n                + File.separator + getSgName(i) + File.separator + \"0\" + File.separator\n                + File.separator + rand;\n        File file = new File(fileName);\n        allFileList.get(getSgName(i)).get(0L).add(file);\n        correctToBeSyncedFiles.get(getSgName(i)).get(0L).add(file);\n        if (!file.getParentFile().exists()) {\n          file.getParentFile().mkdirs();\n        }\n        if (!file.exists() && !file.createNewFile()) {\n          logger.error(\"Can not create new file {}\", file.getPath());\n        }\n        if (!new File(file.getAbsolutePath() + TsFileResource.RESOURCE_SUFFIX).exists()\n            && !new File(file.getAbsolutePath() + TsFileResource.RESOURCE_SUFFIX).createNewFile()) {\n          logger.error(\"Can not create new file {}\", file.getPath());\n        }\n      }\n    }\n    int count = 0;\n    Map<String, Map<Long, Set<File>>> correctDeleteFile = new HashMap<>();\n    for (Entry<String, Map<Long, Set<File>>> entry : allFileList.entrySet()) {\n      correctDeleteFile.put(entry.getKey(), new HashMap<>());\n      for (Entry<Long, Set<File>> innerEntry : entry.getValue().entrySet()) {\n        Set<File> files = innerEntry.getValue();\n        correctDeleteFile.get(entry.getKey()).putIfAbsent(innerEntry.getKey(), new HashSet<>());\n        for (File file : files) {\n          count++;\n          if (count % 3 == 0 && lastFileMap.get(entry.getKey()).get(0L).contains(file)) {\n            correctDeleteFile.get(entry.getKey()).get(0L).add(file);\n          }\n        }\n      }\n    }\n    for (Entry<String, Map<Long, Set<File>>> entry : correctDeleteFile.entrySet()) {\n      correctDeleteFile.put(entry.getKey(), new HashMap<>());\n      for (Entry<Long, Set<File>> innerEntry : entry.getValue().entrySet()) {\n        Set<File> files = innerEntry.getValue();\n        correctDeleteFile.get(entry.getKey()).putIfAbsent(innerEntry.getKey(), new HashSet<>());\n        for (File file : innerEntry.getValue()) {\n          file.delete();\n          new File(file.getAbsolutePath() + TsFileResource.RESOURCE_SUFFIX).delete();\n          allFileList.get(entry.getKey()).get(0L).remove(file);\n        }\n      }\n    }\n    manager.getValidFiles(dataDir);\n    curFileMap = manager.getCurrentSealedLocalFilesMap();\n    deletedFilesMap = manager.getDeletedFilesMap();\n    toBeSyncedFilesMap = manager.getToBeSyncedFilesMap();\n    assertFileMap(allFileList, curFileMap);\n    assertFileMap(correctDeleteFile, deletedFilesMap);\n    assertFileMap(correctToBeSyncedFiles, toBeSyncedFilesMap);\n\n    // add some invalid files\n    r = new Random(3);\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 5; j++) {\n        allFileList.computeIfAbsent(getSgName(i), k -> new HashMap<>())\n            .computeIfAbsent(0L, k -> new HashSet<>());\n        String rand = String.valueOf(r.nextInt(10000));\n        String fileName =\n            FilePathUtils.regularizePath(dataDir) + IoTDBConstant.SEQUENCE_FLODER_NAME\n                + File.separator + getSgName(i) + File.separator + \"0\" + File.separator\n                + File.separator + rand;\n        File file = new File(fileName);\n        allFileList.get(getSgName(i)).get(0L).add(file);\n        if (!file.getParentFile().exists()) {\n          file.getParentFile().mkdirs();\n        }\n        if (!file.exists() && !file.createNewFile()) {\n          logger.error(\"Can not create new file {}\", file.getPath());\n        }\n      }\n    }\n    manager.getValidFiles(dataDir);\n    curFileMap = manager.getCurrentSealedLocalFilesMap();\n    deletedFilesMap = manager.getDeletedFilesMap();\n    toBeSyncedFilesMap = manager.getToBeSyncedFilesMap();\n\n    assertFileMap(curFileMap, allFileList);\n    assertFileMap(curFileMap, allFileList);\n    assertFileMap(correctDeleteFile, deletedFilesMap);\n    assertFileMap(correctToBeSyncedFiles, toBeSyncedFilesMap);\n  }", "signature": "void testGetValidFiles()", "full_signature": "@Test public void testGetValidFiles()", "class_method_signature": "SyncFileManagerTest.testGetValidFiles()", "testcase": true, "constructor": false, "invocations": ["setStorageGroup", "getSgName", "computeIfAbsent", "computeIfAbsent", "getSgName", "nextInt", "regularizePath", "getSgName", "add", "get", "get", "getSgName", "exists", "getParentFile", "mkdirs", "getParentFile", "exists", "createNewFile", "error", "getPath", "exists", "getAbsolutePath", "createNewFile", "getAbsolutePath", "error", "getPath", "getValidFiles", "assertTrue", "isEmpty", "getLastLocalFilesMap", "updateLastLocalFiles", "getValidFiles", "getLastLocalFilesMap", "assertFileMap", "computeIfAbsent", "computeIfAbsent", "getSgName", "computeIfAbsent", "computeIfAbsent", "getSgName", "nextInt", "regularizePath", "getSgName", "add", "get", "get", "getSgName", "add", "get", "get", "getSgName", "exists", "getParentFile", "mkdirs", "getParentFile", "exists", "createNewFile", "error", "getPath", "exists", "getAbsolutePath", "createNewFile", "getAbsolutePath", "error", "getPath", "getValidFiles", "getCurrentSealedLocalFilesMap", "getToBeSyncedFilesMap", "assertFileMap", "assertFileMap", "updateLastLocalFiles", "getValidFiles", "getLastLocalFilesMap", "assertFileMap", "clear", "computeIfAbsent", "computeIfAbsent", "getSgName", "computeIfAbsent", "computeIfAbsent", "getSgName", "nextInt", "regularizePath", "getSgName", "add", "get", "get", "getSgName", "add", "get", "get", "getSgName", "exists", "getParentFile", "mkdirs", "getParentFile", "exists", "createNewFile", "error", "getPath", "exists", "getAbsolutePath", "createNewFile", "getAbsolutePath", "error", "getPath", "entrySet", "put", "getKey", "entrySet", "getValue", "getValue", "putIfAbsent", "get", "getKey", "getKey", "contains", "get", "get", "getKey", "add", "get", "get", "getKey", "entrySet", "put", "getKey", "entrySet", "getValue", "getValue", "putIfAbsent", "get", "getKey", "getKey", "getValue", "delete", "delete", "getAbsolutePath", "remove", "get", "get", "getKey", "getValidFiles", "getCurrentSealedLocalFilesMap", "getDeletedFilesMap", "getToBeSyncedFilesMap", "assertFileMap", "assertFileMap", "assertFileMap", "computeIfAbsent", "computeIfAbsent", "getSgName", "valueOf", "nextInt", "regularizePath", "getSgName", "add", "get", "get", "getSgName", "exists", "getParentFile", "mkdirs", "getParentFile", "exists", "createNewFile", "error", "getPath", "getValidFiles", "getCurrentSealedLocalFilesMap", "getDeletedFilesMap", "getToBeSyncedFilesMap", "assertFileMap", "assertFileMap", "assertFileMap", "assertFileMap"]}, "focal_class": {"identifier": "SyncFileManager", "superclass": "", "interfaces": "implements ISyncFileManager", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(SyncFileManager.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(SyncFileManager.class)", "var_name": "LOGGER"}, {"original_string": "private Map<String, Set<Long>> allSGs;", "modifier": "private", "type": "Map<String, Set<Long>>", "declarator": "allSGs", "var_name": "allSGs"}, {"original_string": "private Map<String, Map<Long, Set<File>>> currentSealedLocalFilesMap;", "modifier": "private", "type": "Map<String, Map<Long, Set<File>>>", "declarator": "currentSealedLocalFilesMap", "var_name": "currentSealedLocalFilesMap"}, {"original_string": "private Map<String, Map<Long, Set<File>>> lastLocalFilesMap;", "modifier": "private", "type": "Map<String, Map<Long, Set<File>>>", "declarator": "lastLocalFilesMap", "var_name": "lastLocalFilesMap"}, {"original_string": "private Map<String, Map<Long, Set<File>>> deletedFilesMap;", "modifier": "private", "type": "Map<String, Map<Long, Set<File>>>", "declarator": "deletedFilesMap", "var_name": "deletedFilesMap"}, {"original_string": "private Map<String, Map<Long, Set<File>>> toBeSyncedFilesMap;", "modifier": "private", "type": "Map<String, Map<Long, Set<File>>>", "declarator": "toBeSyncedFilesMap", "var_name": "toBeSyncedFilesMap"}], "methods": [{"identifier": "SyncFileManager", "parameters": "()", "modifiers": "private", "return": "", "signature": " SyncFileManager()", "full_signature": "private  SyncFileManager()", "class_method_signature": "SyncFileManager.SyncFileManager()", "testcase": false, "constructor": true}, {"identifier": "getInstance", "parameters": "()", "modifiers": "public static", "return": "SyncFileManager", "signature": "SyncFileManager getInstance()", "full_signature": "public static SyncFileManager getInstance()", "class_method_signature": "SyncFileManager.getInstance()", "testcase": false, "constructor": false}, {"identifier": "getCurrentLocalFiles", "parameters": "(String dataDir)", "modifiers": "@SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning @Override public", "return": "void", "signature": "void getCurrentLocalFiles(String dataDir)", "full_signature": "@SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning @Override public void getCurrentLocalFiles(String dataDir)", "class_method_signature": "SyncFileManager.getCurrentLocalFiles(String dataDir)", "testcase": false, "constructor": false}, {"identifier": "checkFileValidity", "parameters": "(File file)", "modifiers": "private", "return": "boolean", "signature": "boolean checkFileValidity(File file)", "full_signature": "private boolean checkFileValidity(File file)", "class_method_signature": "SyncFileManager.checkFileValidity(File file)", "testcase": false, "constructor": false}, {"identifier": "getLastLocalFiles", "parameters": "(File lastLocalFileInfo)", "modifiers": "@Override public", "return": "void", "signature": "void getLastLocalFiles(File lastLocalFileInfo)", "full_signature": "@Override public void getLastLocalFiles(File lastLocalFileInfo)", "class_method_signature": "SyncFileManager.getLastLocalFiles(File lastLocalFileInfo)", "testcase": false, "constructor": false}, {"identifier": "getValidFiles", "parameters": "(String dataDir)", "modifiers": "@SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning @Override public", "return": "void", "signature": "void getValidFiles(String dataDir)", "full_signature": "@SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning @Override public void getValidFiles(String dataDir)", "class_method_signature": "SyncFileManager.getValidFiles(String dataDir)", "testcase": false, "constructor": false}, {"identifier": "getCurrentSealedLocalFilesMap", "parameters": "()", "modifiers": "@Override public", "return": "Map<String, Map<Long, Set<File>>>", "signature": "Map<String, Map<Long, Set<File>>> getCurrentSealedLocalFilesMap()", "full_signature": "@Override public Map<String, Map<Long, Set<File>>> getCurrentSealedLocalFilesMap()", "class_method_signature": "SyncFileManager.getCurrentSealedLocalFilesMap()", "testcase": false, "constructor": false}, {"identifier": "getLastLocalFilesMap", "parameters": "()", "modifiers": "@Override public", "return": "Map<String, Map<Long, Set<File>>>", "signature": "Map<String, Map<Long, Set<File>>> getLastLocalFilesMap()", "full_signature": "@Override public Map<String, Map<Long, Set<File>>> getLastLocalFilesMap()", "class_method_signature": "SyncFileManager.getLastLocalFilesMap()", "testcase": false, "constructor": false}, {"identifier": "getDeletedFilesMap", "parameters": "()", "modifiers": "@Override public", "return": "Map<String, Map<Long, Set<File>>>", "signature": "Map<String, Map<Long, Set<File>>> getDeletedFilesMap()", "full_signature": "@Override public Map<String, Map<Long, Set<File>>> getDeletedFilesMap()", "class_method_signature": "SyncFileManager.getDeletedFilesMap()", "testcase": false, "constructor": false}, {"identifier": "getToBeSyncedFilesMap", "parameters": "()", "modifiers": "@Override public", "return": "Map<String, Map<Long, Set<File>>>", "signature": "Map<String, Map<Long, Set<File>>> getToBeSyncedFilesMap()", "full_signature": "@Override public Map<String, Map<Long, Set<File>>> getToBeSyncedFilesMap()", "class_method_signature": "SyncFileManager.getToBeSyncedFilesMap()", "testcase": false, "constructor": false}, {"identifier": "getAllSGs", "parameters": "()", "modifiers": "@Override public", "return": "Map<String, Set<Long>>", "signature": "Map<String, Set<Long>> getAllSGs()", "full_signature": "@Override public Map<String, Set<Long>> getAllSGs()", "class_method_signature": "SyncFileManager.getAllSGs()", "testcase": false, "constructor": false}], "file": "server/src/main/java/org/apache/iotdb/db/sync/sender/manage/SyncFileManager.java"}, "focal_method": {"identifier": "getValidFiles", "parameters": "(String dataDir)", "modifiers": "@SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning @Override public", "return": "void", "body": "@SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n  @Override\n  public void getValidFiles(String dataDir) throws IOException {\n    allSGs = new HashMap<>();\n    getCurrentLocalFiles(dataDir);\n    getLastLocalFiles(\n        new File(SyncSenderDescriptor.getInstance().getConfig().getLastFileInfoPath()));\n    toBeSyncedFilesMap = new HashMap<>();\n    deletedFilesMap = new HashMap<>();\n    for (String sgName : allSGs.keySet()) {\n      toBeSyncedFilesMap.putIfAbsent(sgName, new HashMap<>());\n      deletedFilesMap.putIfAbsent(sgName, new HashMap<>());\n      for (Entry<Long, Set<File>> entry : currentSealedLocalFilesMap\n          .getOrDefault(sgName, Collections.emptyMap()).entrySet()) {\n        Long timeRangeId = entry.getKey();\n        toBeSyncedFilesMap.get(sgName).putIfAbsent(timeRangeId, new HashSet<>());\n        allSGs.get(sgName).add(timeRangeId);\n        for (File newFile : entry.getValue()) {\n          if (!lastLocalFilesMap.getOrDefault(sgName, Collections.emptyMap())\n              .getOrDefault(timeRangeId, Collections.emptySet()).contains(newFile)) {\n            toBeSyncedFilesMap.get(sgName).get(timeRangeId).add(newFile);\n          }\n        }\n      }\n\n      for (Entry<Long, Set<File>> entry : lastLocalFilesMap\n          .getOrDefault(sgName, Collections.emptyMap()).entrySet()) {\n        Long timeRangeId = entry.getKey();\n        deletedFilesMap.get(sgName).putIfAbsent(timeRangeId, new HashSet<>());\n        allSGs.get(sgName).add(timeRangeId);\n        for (File oldFile : entry.getValue()) {\n          if (!currentSealedLocalFilesMap.getOrDefault(sgName, Collections.emptyMap())\n              .getOrDefault(timeRangeId, Collections.emptySet()).contains(oldFile)) {\n            deletedFilesMap.get(sgName).get(timeRangeId).add(oldFile);\n          }\n        }\n      }\n    }\n  }", "signature": "void getValidFiles(String dataDir)", "full_signature": "@SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning @Override public void getValidFiles(String dataDir)", "class_method_signature": "SyncFileManager.getValidFiles(String dataDir)", "testcase": false, "constructor": false, "invocations": ["getCurrentLocalFiles", "getLastLocalFiles", "getLastFileInfoPath", "getConfig", "getInstance", "keySet", "putIfAbsent", "putIfAbsent", "entrySet", "getOrDefault", "emptyMap", "getKey", "putIfAbsent", "get", "add", "get", "getValue", "contains", "getOrDefault", "getOrDefault", "emptyMap", "emptySet", "add", "get", "get", "entrySet", "getOrDefault", "emptyMap", "getKey", "putIfAbsent", "get", "add", "get", "getValue", "contains", "getOrDefault", "getOrDefault", "emptyMap", "emptySet", "add", "get", "get"]}, "repository": {"repo_id": 158975124, "url": "https://github.com/apache/incubator-iotdb", "stars": 449, "created": "11/24/2018 9:29:17 PM +00:00", "updates": "2020-01-21T08:10:15+00:00", "fork": "False", "license": "licensed"}}