{"test_class": {"identifier": "SchedulerFactoryTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Vertx vertx;", "modifier": "private", "type": "Vertx", "declarator": "vertx", "var_name": "vertx"}, {"original_string": "private MonitoringHandler monitoringHandler;", "modifier": "private", "type": "MonitoringHandler", "declarator": "monitoringHandler", "var_name": "monitoringHandler"}, {"original_string": "private RedisClient redisClient;", "modifier": "private", "type": "RedisClient", "declarator": "redisClient", "var_name": "redisClient"}, {"original_string": "private SchedulerFactory schedulerFactory;", "modifier": "private", "type": "SchedulerFactory", "declarator": "schedulerFactory", "var_name": "schedulerFactory"}, {"original_string": "@Rule\n    public ExpectedException thrown= ExpectedException.none();", "modifier": "@Rule\n    public", "type": "ExpectedException", "declarator": "thrown= ExpectedException.none()", "var_name": "thrown"}, {"original_string": "private String schedulersSchema = ResourcesUtils.loadResource(\"gateleen_scheduler_schema_schedulers\", true);", "modifier": "private", "type": "String", "declarator": "schedulersSchema = ResourcesUtils.loadResource(\"gateleen_scheduler_schema_schedulers\", true)", "var_name": "schedulersSchema"}, {"original_string": "private final String VALID_SCHEDULER_RESOURCE = ResourcesUtils.loadResource(\"testresource_valid_scheduler_resource\", true);", "modifier": "private final", "type": "String", "declarator": "VALID_SCHEDULER_RESOURCE = ResourcesUtils.loadResource(\"testresource_valid_scheduler_resource\", true)", "var_name": "VALID_SCHEDULER_RESOURCE"}, {"original_string": "private final String MISSING_SCHEDULERS_PROPERTY = ResourcesUtils.loadResource(\"testresource_missing_schedulers_property\", true);", "modifier": "private final", "type": "String", "declarator": "MISSING_SCHEDULERS_PROPERTY = ResourcesUtils.loadResource(\"testresource_missing_schedulers_property\", true)", "var_name": "MISSING_SCHEDULERS_PROPERTY"}, {"original_string": "private final String MISSING_CRONEXPRESSION_PROPERTY = ResourcesUtils.loadResource(\"testresource_missing_cronexpression_property\", true);", "modifier": "private final", "type": "String", "declarator": "MISSING_CRONEXPRESSION_PROPERTY = ResourcesUtils.loadResource(\"testresource_missing_cronexpression_property\", true)", "var_name": "MISSING_CRONEXPRESSION_PROPERTY"}, {"original_string": "private final String INVALID_JSON = ResourcesUtils.loadResource(\"testresource_invalid_json\", true);", "modifier": "private final", "type": "String", "declarator": "INVALID_JSON = ResourcesUtils.loadResource(\"testresource_invalid_json\", true)", "var_name": "INVALID_JSON"}], "file": "gateleen-scheduler/src/test/java/org/swisspush/gateleen/scheduler/SchedulerFactoryTest.java"}, "test_case": {"identifier": "testMissingSchedulersProperty", "parameters": "(TestContext context)", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMissingSchedulersProperty(TestContext context) throws ValidationException {\n        try {\n            schedulerFactory.parseSchedulers(Buffer.buffer(MISSING_SCHEDULERS_PROPERTY));\n            context.fail(\"Should have thrown a ValidationException since 'schedulers' property is missing\");\n        } catch(ValidationException ex){\n            context.assertNotNull(ex.getValidationDetails());\n            context.assertEquals(2, ex.getValidationDetails().size());\n            for(Object obj : ex.getValidationDetails()){\n                JsonObject jsonObject = (JsonObject) obj;\n                if(\"additionalProperties\".equalsIgnoreCase(jsonObject.getString(\"keyword\"))){\n                    context.assertEquals(\"listofschedulers\", jsonObject.getJsonArray(\"unwanted\").getString(0));\n                } else if(\"required\".equalsIgnoreCase(jsonObject.getString(\"keyword\"))){\n                    context.assertEquals(\"schedulers\", jsonObject.getJsonArray(\"missing\").getString(0));\n                }\n            }\n        }\n    }", "signature": "void testMissingSchedulersProperty(TestContext context)", "full_signature": "@Test public void testMissingSchedulersProperty(TestContext context)", "class_method_signature": "SchedulerFactoryTest.testMissingSchedulersProperty(TestContext context)", "testcase": true, "constructor": false, "invocations": ["parseSchedulers", "buffer", "fail", "assertNotNull", "getValidationDetails", "assertEquals", "size", "getValidationDetails", "getValidationDetails", "equalsIgnoreCase", "getString", "assertEquals", "getString", "getJsonArray", "equalsIgnoreCase", "getString", "assertEquals", "getString", "getJsonArray"]}, "focal_class": {"identifier": "SchedulerFactory", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String HEADERS = \"headers\";", "modifier": "private static final", "type": "String", "declarator": "HEADERS = \"headers\"", "var_name": "HEADERS"}, {"original_string": "private static final String PAYLOAD = \"payload\";", "modifier": "private static final", "type": "String", "declarator": "PAYLOAD = \"payload\"", "var_name": "PAYLOAD"}, {"original_string": "private static final String REQUESTS = \"requests\";", "modifier": "private static final", "type": "String", "declarator": "REQUESTS = \"requests\"", "var_name": "REQUESTS"}, {"original_string": "private static final String SCHEDULERS = \"schedulers\";", "modifier": "private static final", "type": "String", "declarator": "SCHEDULERS = \"schedulers\"", "var_name": "SCHEDULERS"}, {"original_string": "private static final String RANDOM_OFFSET = \"randomOffset\";", "modifier": "private static final", "type": "String", "declarator": "RANDOM_OFFSET = \"randomOffset\"", "var_name": "RANDOM_OFFSET"}, {"original_string": "private static final String EXECUTE_ON_STARTUP = \"executeOnStartup\";", "modifier": "private static final", "type": "String", "declarator": "EXECUTE_ON_STARTUP = \"executeOnStartup\"", "var_name": "EXECUTE_ON_STARTUP"}, {"original_string": "private static final String EXECUTE_ON_RELOAD = \"executeOnReload\";", "modifier": "private static final", "type": "String", "declarator": "EXECUTE_ON_RELOAD = \"executeOnReload\"", "var_name": "EXECUTE_ON_RELOAD"}, {"original_string": "private final Map<String, Object> properties;", "modifier": "private final", "type": "Map<String, Object>", "declarator": "properties", "var_name": "properties"}, {"original_string": "private Vertx vertx;", "modifier": "private", "type": "Vertx", "declarator": "vertx", "var_name": "vertx"}, {"original_string": "private RedisClient redisClient;", "modifier": "private", "type": "RedisClient", "declarator": "redisClient", "var_name": "redisClient"}, {"original_string": "private MonitoringHandler monitoringHandler;", "modifier": "private", "type": "MonitoringHandler", "declarator": "monitoringHandler", "var_name": "monitoringHandler"}, {"original_string": "private String schedulersSchema;", "modifier": "private", "type": "String", "declarator": "schedulersSchema", "var_name": "schedulersSchema"}, {"original_string": "private String redisquesAddress;", "modifier": "private", "type": "String", "declarator": "redisquesAddress", "var_name": "redisquesAddress"}, {"original_string": "private Logger log = LoggerFactory.getLogger(SchedulerFactory.class);", "modifier": "private", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(SchedulerFactory.class)", "var_name": "log"}], "methods": [{"identifier": "SchedulerFactory", "parameters": "(Map<String, Object> properties, Vertx vertx, RedisClient redisClient, MonitoringHandler monitoringHandler, String schedulersSchema, String redisquesAddress)", "modifiers": "public", "return": "", "signature": " SchedulerFactory(Map<String, Object> properties, Vertx vertx, RedisClient redisClient, MonitoringHandler monitoringHandler, String schedulersSchema, String redisquesAddress)", "full_signature": "public  SchedulerFactory(Map<String, Object> properties, Vertx vertx, RedisClient redisClient, MonitoringHandler monitoringHandler, String schedulersSchema, String redisquesAddress)", "class_method_signature": "SchedulerFactory.SchedulerFactory(Map<String, Object> properties, Vertx vertx, RedisClient redisClient, MonitoringHandler monitoringHandler, String schedulersSchema, String redisquesAddress)", "testcase": false, "constructor": true}, {"identifier": "parseSchedulers", "parameters": "(Buffer buffer)", "modifiers": "public", "return": "List<Scheduler>", "signature": "List<Scheduler> parseSchedulers(Buffer buffer)", "full_signature": "public List<Scheduler> parseSchedulers(Buffer buffer)", "class_method_signature": "SchedulerFactory.parseSchedulers(Buffer buffer)", "testcase": false, "constructor": false}, {"identifier": "prepare", "parameters": "(JsonObject httpRequestJsonObject)", "modifiers": "private", "return": "JsonObject", "signature": "JsonObject prepare(JsonObject httpRequestJsonObject)", "full_signature": "private JsonObject prepare(JsonObject httpRequestJsonObject)", "class_method_signature": "SchedulerFactory.prepare(JsonObject httpRequestJsonObject)", "testcase": false, "constructor": false}], "file": "gateleen-scheduler/src/main/java/org/swisspush/gateleen/scheduler/SchedulerFactory.java"}, "focal_method": {"identifier": "parseSchedulers", "parameters": "(Buffer buffer)", "modifiers": "public", "return": "List<Scheduler>", "body": "public List<Scheduler> parseSchedulers(Buffer buffer) throws ValidationException {\n        List<Scheduler> result = new ArrayList<>();\n        String configString;\n        try {\n            configString = StringUtils.replaceWildcardConfigs(buffer.toString(\"UTF-8\"), properties);\n        } catch(Exception e){\n            throw new ValidationException(e);\n        }\n\n        ValidationResult validationResult = Validator.validateStatic(Buffer.buffer(configString), schedulersSchema, log);\n        if(!validationResult.isSuccess()){\n            throw new  ValidationException(validationResult);\n        }\n\n        JsonObject mainObject = new JsonObject(configString);\n        for(Map.Entry<String,Object> entry: mainObject.getJsonObject(SCHEDULERS).getMap().entrySet()) {\n            Map<String,Object> schedulerJson = (Map<String,Object>)entry.getValue();\n\n            boolean executeOnStartup = false;\n            boolean executeOnReload = false;\n            if ( schedulerJson.containsKey(EXECUTE_ON_STARTUP) ) {\n                executeOnStartup = (boolean) schedulerJson.get(EXECUTE_ON_STARTUP);\n\n                // reload is always as a default performed, if startup execution is enforced\n                executeOnReload = executeOnStartup;\n            }\n\n            // do we need to fire a scheduler on a reload?\n            if ( schedulerJson.containsKey(EXECUTE_ON_RELOAD) ) {\n                executeOnReload = (boolean) schedulerJson.get(EXECUTE_ON_RELOAD);\n            }\n\n\n                int maxRandomOffset = 0;\n            if ( schedulerJson.containsKey(RANDOM_OFFSET) ) {\n                try {\n                    maxRandomOffset = (Integer) schedulerJson.get(RANDOM_OFFSET);\n                }\n                catch(NumberFormatException e) {\n                    throw new ValidationException(\"Could not parse \" + RANDOM_OFFSET + \" of scheduler '\"+entry.getKey()+\"'\", e);\n                }\n            }\n\n            List<HttpRequest> requests = new ArrayList<>();\n            for(int i = 0; i< ((ArrayList<Object>)schedulerJson.get(REQUESTS)).size(); i++) {\n                try {\n                    requests.add(new HttpRequest(prepare((JsonObject) mainObject.getJsonObject(SCHEDULERS).getJsonObject(entry.getKey()).getJsonArray(REQUESTS).getValue(i))));\n                } catch(Exception e) {\n                    throw new ValidationException(\"Could not parse request [\"+i+\"] of scheduler \"+entry.getKey(), e);\n                }\n            }\n            try {\n                result.add(new Scheduler(vertx, redisquesAddress, redisClient, entry.getKey(), (String)schedulerJson.get(\"cronExpression\"), requests, monitoringHandler, maxRandomOffset, executeOnStartup, executeOnReload));\n            } catch (ParseException e) {\n                throw new ValidationException(\"Could not parse cron expression of scheduler '\"+entry.getKey()+\"'\", e);\n            }\n        }\n        return result;\n    }", "signature": "List<Scheduler> parseSchedulers(Buffer buffer)", "full_signature": "public List<Scheduler> parseSchedulers(Buffer buffer)", "class_method_signature": "SchedulerFactory.parseSchedulers(Buffer buffer)", "testcase": false, "constructor": false, "invocations": ["replaceWildcardConfigs", "toString", "validateStatic", "buffer", "isSuccess", "entrySet", "getMap", "getJsonObject", "getValue", "containsKey", "get", "containsKey", "get", "containsKey", "get", "getKey", "size", "get", "add", "prepare", "getValue", "getJsonArray", "getJsonObject", "getJsonObject", "getKey", "getKey", "add", "getKey", "get", "getKey"]}, "repository": {"repo_id": 52609528, "url": "https://github.com/swisspush/gateleen", "language": "Java", "is_fork": false, "fork_count": 28, "stargazer_count": 63, "size": 2919, "license": "licensed"}}