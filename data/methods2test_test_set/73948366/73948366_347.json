{"test_class": {"identifier": "DefaultOAuthJwtAccessTokenValidatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Consumer<ThrowingRunnable> assertDoesNotThrow = (func) -> {\n        try {\n            func.run();\n        } catch (Throwable t) {\n            fail(\"assertDoesNotThrow: unexpected throw\", t);\n        }\n    };", "modifier": "private static final", "type": "Consumer<ThrowingRunnable>", "declarator": "assertDoesNotThrow = (func) -> {\n        try {\n            func.run();\n        } catch (Throwable t) {\n            fail(\"assertDoesNotThrow: unexpected throw\", t);\n        }\n    }", "var_name": "assertDoesNotThrow"}, {"original_string": "private static final BiConsumer<ThrowingRunnable, String> assertThrowable = (func, expectedErrMsg) -> {\n        try {\n            func.run();\n        } catch (OAuthJwtAccessTokenException e) {\n            assertEquals(e.getMessage(), expectedErrMsg);\n            return;\n        } catch (Throwable t) {\n            fail(\"assertThrowable: unexpected throw\", t);\n        }\n        fail(\"assertThrowable: does not throw\");\n    };", "modifier": "private static final", "type": "BiConsumer<ThrowingRunnable, String>", "declarator": "assertThrowable = (func, expectedErrMsg) -> {\n        try {\n            func.run();\n        } catch (OAuthJwtAccessTokenException e) {\n            assertEquals(e.getMessage(), expectedErrMsg);\n            return;\n        } catch (Throwable t) {\n            fail(\"assertThrowable: unexpected throw\", t);\n        }\n        fail(\"assertThrowable: does not throw\");\n    }", "var_name": "assertThrowable"}, {"original_string": "private final String trustedIssuer = \"trustedIssuer\";", "modifier": "private final", "type": "String", "declarator": "trustedIssuer = \"trustedIssuer\"", "var_name": "trustedIssuer"}, {"original_string": "private final Set<String> requiredAudiences = new HashSet<>(Arrays.asList(\"aud_1\", \"aud_2\"));", "modifier": "private final", "type": "Set<String>", "declarator": "requiredAudiences = new HashSet<>(Arrays.asList(\"aud_1\", \"aud_2\"))", "var_name": "requiredAudiences"}, {"original_string": "private final Set<String> requiredScopes = new HashSet<>(Arrays.asList(\"scope_1\", \"scope_2\"));", "modifier": "private final", "type": "Set<String>", "declarator": "requiredScopes = new HashSet<>(Arrays.asList(\"scope_1\", \"scope_2\"))", "var_name": "requiredScopes"}, {"original_string": "private final Map<String, Set<String>> authorizedClientIds = Collections.synchronizedMap(new HashMap<>());", "modifier": "private final", "type": "Map<String, Set<String>>", "declarator": "authorizedClientIds = Collections.synchronizedMap(new HashMap<>())", "var_name": "authorizedClientIds"}, {"original_string": "private final DefaultOAuthJwtAccessTokenValidator baseValidator = new DefaultOAuthJwtAccessTokenValidator(this.trustedIssuer, this.requiredAudiences, this.requiredScopes, this.authorizedClientIds);", "modifier": "private final", "type": "DefaultOAuthJwtAccessTokenValidator", "declarator": "baseValidator = new DefaultOAuthJwtAccessTokenValidator(this.trustedIssuer, this.requiredAudiences, this.requiredScopes, this.authorizedClientIds)", "var_name": "baseValidator"}, {"original_string": "private final OAuthJwtAccessToken baseJwt = new OAuthJwtAccessToken() {\n        public String getScope() { return null; }\n        public String getSubject() { return null; }\n        public String getIssuer() { return null; }\n        public String getAudience() { return null; }\n        public List<String>  getAudiences() { return null; }\n        public String getClientId() { return null; }\n        public String getCertificateThumbprint() { return null; }\n        public long getIssuedAt() { return 0L; }\n        public long getExpiration() { return 0L; }\n        public String getSignature() { return null; }\n    };", "modifier": "private final", "type": "OAuthJwtAccessToken", "declarator": "baseJwt = new OAuthJwtAccessToken() {\n        public String getScope() { return null; }\n        public String getSubject() { return null; }\n        public String getIssuer() { return null; }\n        public String getAudience() { return null; }\n        public List<String>  getAudiences() { return null; }\n        public String getClientId() { return null; }\n        public String getCertificateThumbprint() { return null; }\n        public long getIssuedAt() { return 0L; }\n        public long getExpiration() { return 0L; }\n        public String getSignature() { return null; }\n    }", "var_name": "baseJwt"}], "file": "libs/java/auth_core/src/test/java/com/yahoo/athenz/auth/oauth/validator/DefaultOAuthJwtAccessTokenValidatorTest.java"}, "test_case": {"identifier": "testValidateClientId", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testValidateClientId() {\n        final DefaultOAuthJwtAccessTokenValidator validator = this.baseValidator;\n        final OAuthJwtAccessToken mock = Mockito.spy(baseJwt);\n        Mockito.doReturn(null).when(mock).getClientId();\n\n        // null JWT client ID, null CN, invalid\n        assertThrowable.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, null);\n            }\n        }, \"NO mapping of authorized client IDs for certificate principal (null)\");\n        // null JWT client ID ONLY, no mapping\n        assertThrowable.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, \"no_mapping_1\");\n            }\n        }, \"NO mapping of authorized client IDs for certificate principal (no_mapping_1)\");\n        // null JWT client ID ONLY, mapped\n        assertThrowable.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, \"client_cert_common_name\");\n            }\n        }, \"client_id is not authorized for certificate principal (client_cert_common_name): got=null\");\n\n        Mockito.doReturn(\"jwt_client_id\").when(mock).getClientId();\n\n        // null expected client ID ONLY, no mapping\n        assertThrowable.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, null);\n            }\n        }, \"NO mapping of authorized client IDs for certificate principal (null)\");\n        // null expected client ID ONLY, mapped\n        authorizedClientIds.put(null, new HashSet<>(Arrays.asList(\"null_1, null_2\")));\n        assertThrowable.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, null);\n            }\n        }, \"client_id is not authorized for certificate principal (null): got=jwt_client_id\");\n        authorizedClientIds.remove(null);\n\n        // not match, no mapping\n        assertThrowable.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, \"no_mapping_2\");\n            }\n        }, \"NO mapping of authorized client IDs for certificate principal (no_mapping_2)\");\n        // not match, mapped\n        assertThrowable.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, \"client_cert_common_name\");\n            }\n        }, \"client_id is not authorized for certificate principal (client_cert_common_name): got=jwt_client_id\");\n\n        // match, no mapping\n        Mockito.doReturn(\"match.principal.1\").when(mock).getClientId();\n        assertThrowable.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, \"match.principal.1\");\n            }\n        }, \"NO mapping of authorized client IDs for certificate principal (match.principal.1)\");\n        // match, mapped\n        Mockito.doReturn(\"client_id_1\").when(mock).getClientId();\n        assertDoesNotThrow.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, \"client_cert_common_name\");\n            }\n        });\n\n        // no mapping, case-insensitive, match, invalid\n        Mockito.doReturn(\"match.principal.PPP\").when(mock).getClientId();\n        assertThrowable.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, \"match.principal.ppp\");\n            }\n        }, \"NO mapping of authorized client IDs for certificate principal (match.principal.ppp)\");\n        // mapped, case-sensitive, match\n        Mockito.doReturn(\"CLIENT_ID_2\").when(mock).getClientId();\n        assertDoesNotThrow.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, \"client_cert_common_name\");\n            }\n        });\n        // mapped, case-sensitive, not match\n        Mockito.doReturn(\"client_id_2\").when(mock).getClientId();\n        assertThrowable.accept(new ThrowingRunnable() {\n            public void run() throws Throwable {\n                validator.validateClientId(mock, \"client_cert_common_name\");\n            }\n        }, \"client_id is not authorized for certificate principal (client_cert_common_name): got=client_id_2\");\n    }", "signature": "void testValidateClientId()", "full_signature": "@Test public void testValidateClientId()", "class_method_signature": "DefaultOAuthJwtAccessTokenValidatorTest.testValidateClientId()", "testcase": true, "constructor": false, "invocations": ["spy", "getClientId", "when", "doReturn", "accept", "validateClientId", "accept", "validateClientId", "accept", "validateClientId", "getClientId", "when", "doReturn", "accept", "validateClientId", "put", "asList", "accept", "validateClientId", "remove", "accept", "validateClientId", "accept", "validateClientId", "getClientId", "when", "doReturn", "accept", "validateClientId", "getClientId", "when", "doReturn", "accept", "validateClientId", "getClientId", "when", "doReturn", "accept", "validateClientId", "getClientId", "when", "doReturn", "accept", "validateClientId", "getClientId", "when", "doReturn", "accept", "validateClientId"]}, "focal_class": {"identifier": "DefaultOAuthJwtAccessTokenValidator", "superclass": "", "interfaces": "implements OAuthJwtAccessTokenValidator", "fields": [{"original_string": "private String trustedIssuer = null;", "modifier": "private", "type": "String", "declarator": "trustedIssuer = null", "var_name": "trustedIssuer"}, {"original_string": "private Set<String> requiredAudiences = null;", "modifier": "private", "type": "Set<String>", "declarator": "requiredAudiences = null", "var_name": "requiredAudiences"}, {"original_string": "private Set<String> requiredScopes = null;", "modifier": "private", "type": "Set<String>", "declarator": "requiredScopes = null", "var_name": "requiredScopes"}, {"original_string": "private Map<String, Set<String>> authorizedClientIds = null;", "modifier": "private", "type": "Map<String, Set<String>>", "declarator": "authorizedClientIds = null", "var_name": "authorizedClientIds"}], "methods": [{"identifier": "DefaultOAuthJwtAccessTokenValidator", "parameters": "(String trustedIssuer, Set<String> requiredAudiences, Set<String> requiredScopes, Map<String, Set<String>> authorizedClientIds)", "modifiers": "public", "return": "", "signature": " DefaultOAuthJwtAccessTokenValidator(String trustedIssuer, Set<String> requiredAudiences, Set<String> requiredScopes, Map<String, Set<String>> authorizedClientIds)", "full_signature": "public  DefaultOAuthJwtAccessTokenValidator(String trustedIssuer, Set<String> requiredAudiences, Set<String> requiredScopes, Map<String, Set<String>> authorizedClientIds)", "class_method_signature": "DefaultOAuthJwtAccessTokenValidator.DefaultOAuthJwtAccessTokenValidator(String trustedIssuer, Set<String> requiredAudiences, Set<String> requiredScopes, Map<String, Set<String>> authorizedClientIds)", "testcase": false, "constructor": true}, {"identifier": "verifyIssuer", "parameters": "(OAuthJwtAccessToken jwt)", "modifiers": "private", "return": "void", "signature": "void verifyIssuer(OAuthJwtAccessToken jwt)", "full_signature": "private void verifyIssuer(OAuthJwtAccessToken jwt)", "class_method_signature": "DefaultOAuthJwtAccessTokenValidator.verifyIssuer(OAuthJwtAccessToken jwt)", "testcase": false, "constructor": false}, {"identifier": "verifyAudiences", "parameters": "(OAuthJwtAccessToken jwt)", "modifiers": "private", "return": "void", "signature": "void verifyAudiences(OAuthJwtAccessToken jwt)", "full_signature": "private void verifyAudiences(OAuthJwtAccessToken jwt)", "class_method_signature": "DefaultOAuthJwtAccessTokenValidator.verifyAudiences(OAuthJwtAccessToken jwt)", "testcase": false, "constructor": false}, {"identifier": "verifyScopes", "parameters": "(OAuthJwtAccessToken jwt)", "modifiers": "private", "return": "void", "signature": "void verifyScopes(OAuthJwtAccessToken jwt)", "full_signature": "private void verifyScopes(OAuthJwtAccessToken jwt)", "class_method_signature": "DefaultOAuthJwtAccessTokenValidator.verifyScopes(OAuthJwtAccessToken jwt)", "testcase": false, "constructor": false}, {"identifier": "verifyCertificateThumbprint", "parameters": "(OAuthJwtAccessToken jwt, String certificateThumbprint)", "modifiers": "private", "return": "void", "signature": "void verifyCertificateThumbprint(OAuthJwtAccessToken jwt, String certificateThumbprint)", "full_signature": "private void verifyCertificateThumbprint(OAuthJwtAccessToken jwt, String certificateThumbprint)", "class_method_signature": "DefaultOAuthJwtAccessTokenValidator.verifyCertificateThumbprint(OAuthJwtAccessToken jwt, String certificateThumbprint)", "testcase": false, "constructor": false}, {"identifier": "verifyClientId", "parameters": "(OAuthJwtAccessToken jwt, String certificatePrincipal)", "modifiers": "private", "return": "void", "signature": "void verifyClientId(OAuthJwtAccessToken jwt, String certificatePrincipal)", "full_signature": "private void verifyClientId(OAuthJwtAccessToken jwt, String certificatePrincipal)", "class_method_signature": "DefaultOAuthJwtAccessTokenValidator.verifyClientId(OAuthJwtAccessToken jwt, String certificatePrincipal)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(OAuthJwtAccessToken jwt)", "modifiers": "@Override public", "return": "void", "signature": "void validate(OAuthJwtAccessToken jwt)", "full_signature": "@Override public void validate(OAuthJwtAccessToken jwt)", "class_method_signature": "DefaultOAuthJwtAccessTokenValidator.validate(OAuthJwtAccessToken jwt)", "testcase": false, "constructor": false}, {"identifier": "validateClientId", "parameters": "(OAuthJwtAccessToken jwt, String clientId)", "modifiers": "@Override public", "return": "void", "signature": "void validateClientId(OAuthJwtAccessToken jwt, String clientId)", "full_signature": "@Override public void validateClientId(OAuthJwtAccessToken jwt, String clientId)", "class_method_signature": "DefaultOAuthJwtAccessTokenValidator.validateClientId(OAuthJwtAccessToken jwt, String clientId)", "testcase": false, "constructor": false}, {"identifier": "validateCertificateBinding", "parameters": "(OAuthJwtAccessToken jwt, String certificateThumbprint)", "modifiers": "@Override public", "return": "void", "signature": "void validateCertificateBinding(OAuthJwtAccessToken jwt, String certificateThumbprint)", "full_signature": "@Override public void validateCertificateBinding(OAuthJwtAccessToken jwt, String certificateThumbprint)", "class_method_signature": "DefaultOAuthJwtAccessTokenValidator.validateCertificateBinding(OAuthJwtAccessToken jwt, String certificateThumbprint)", "testcase": false, "constructor": false}], "file": "libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/oauth/validator/DefaultOAuthJwtAccessTokenValidator.java"}, "focal_method": {"identifier": "validateClientId", "parameters": "(OAuthJwtAccessToken jwt, String clientId)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void validateClientId(OAuthJwtAccessToken jwt, String clientId) throws OAuthJwtAccessTokenException {\n        this.verifyClientId(jwt, clientId);\n    }", "signature": "void validateClientId(OAuthJwtAccessToken jwt, String clientId)", "full_signature": "@Override public void validateClientId(OAuthJwtAccessToken jwt, String clientId)", "class_method_signature": "DefaultOAuthJwtAccessTokenValidator.validateClientId(OAuthJwtAccessToken jwt, String clientId)", "testcase": false, "constructor": false, "invocations": ["verifyClientId"]}, "repository": {"repo_id": 73948366, "url": "https://github.com/yahoo/athenz", "stars": 394, "created": "11/16/2016 6:23:08 PM +00:00", "updates": "2020-01-27T15:36:13+00:00", "fork": "False", "license": "licensed"}}