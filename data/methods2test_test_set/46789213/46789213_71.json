{"test_class": {"identifier": "TestWaksmanUtils", "superclass": "", "interfaces": "", "fields": [], "file": "lib/common/src/test/java/dk/alexandra/fresco/lib/common/collections/permute/TestWaksmanUtils.java"}, "test_case": {"identifier": "testSetControlBits", "parameters": "()", "modifiers": "@Test(expected = UnsupportedOperationException.class) public", "return": "void", "body": "@Test(expected = UnsupportedOperationException.class)\n  public void testSetControlBits(){\n    WaksmanUtils util = new WaksmanUtils();\n   \n    int[] controlBits = new int[]{2,3,0,1};\n    Matrix<BigInteger> permutationMatrix = util.setControlBits(controlBits);\n    assertThat(permutationMatrix.getHeight(), is(2));\n    assertThat(permutationMatrix.getWidth(), is(controlBits.length-1));\n        \n    util.setControlBits(new int[]{2,1,0});\n  }", "signature": "void testSetControlBits()", "full_signature": "@Test(expected = UnsupportedOperationException.class) public void testSetControlBits()", "class_method_signature": "TestWaksmanUtils.testSetControlBits()", "testcase": true, "constructor": false, "invocations": ["setControlBits", "assertThat", "getHeight", "is", "assertThat", "getWidth", "is", "setControlBits"]}, "focal_class": {"identifier": "WaksmanUtils", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "log2", "parameters": "(int n)", "modifiers": "private", "return": "int", "signature": "int log2(int n)", "full_signature": "private int log2(int n)", "class_method_signature": "WaksmanUtils.log2(int n)", "testcase": false, "constructor": false}, {"identifier": "nextUnsetSwapperIdx", "parameters": "(int[] swappers)", "modifiers": "private", "return": "int", "signature": "int nextUnsetSwapperIdx(int[] swappers)", "full_signature": "private int nextUnsetSwapperIdx(int[] swappers)", "class_method_signature": "WaksmanUtils.nextUnsetSwapperIdx(int[] swappers)", "testcase": false, "constructor": false}, {"identifier": "swapperIdxOf", "parameters": "(int elIdx)", "modifiers": "private", "return": "int", "signature": "int swapperIdxOf(int elIdx)", "full_signature": "private int swapperIdxOf(int elIdx)", "class_method_signature": "WaksmanUtils.swapperIdxOf(int elIdx)", "testcase": false, "constructor": false}, {"identifier": "topElIndexOf", "parameters": "(int swIdx)", "modifiers": "private", "return": "int", "signature": "int topElIndexOf(int swIdx)", "full_signature": "private int topElIndexOf(int swIdx)", "class_method_signature": "WaksmanUtils.topElIndexOf(int swIdx)", "testcase": false, "constructor": false}, {"identifier": "even", "parameters": "(int n)", "modifiers": "private", "return": "boolean", "signature": "boolean even(int n)", "full_signature": "private boolean even(int n)", "class_method_signature": "WaksmanUtils.even(int n)", "testcase": false, "constructor": false}, {"identifier": "isTopEl", "parameters": "(int elIdx)", "modifiers": "private", "return": "boolean", "signature": "boolean isTopEl(int elIdx)", "full_signature": "private boolean isTopEl(int elIdx)", "class_method_signature": "WaksmanUtils.isTopEl(int elIdx)", "testcase": false, "constructor": false}, {"identifier": "neighElIdxOf", "parameters": "(int elIdx)", "modifiers": "private", "return": "int", "signature": "int neighElIdxOf(int elIdx)", "full_signature": "private int neighElIdxOf(int elIdx)", "class_method_signature": "WaksmanUtils.neighElIdxOf(int elIdx)", "testcase": false, "constructor": false}, {"identifier": "hasNextUnsetSwapper", "parameters": "(int[] rowO)", "modifiers": "private", "return": "boolean", "signature": "boolean hasNextUnsetSwapper(int[] rowO)", "full_signature": "private boolean hasNextUnsetSwapper(int[] rowO)", "class_method_signature": "WaksmanUtils.hasNextUnsetSwapper(int[] rowO)", "testcase": false, "constructor": false}, {"identifier": "routeFromOutputToInput", "parameters": "(int rowOElIdx, int[] invPerm, int[] topPerm, int[] rowI)", "modifiers": "private", "return": "int", "signature": "int routeFromOutputToInput(int rowOElIdx, int[] invPerm, int[] topPerm, int[] rowI)", "full_signature": "private int routeFromOutputToInput(int rowOElIdx, int[] invPerm, int[] topPerm, int[] rowI)", "class_method_signature": "WaksmanUtils.routeFromOutputToInput(int rowOElIdx, int[] invPerm, int[] topPerm, int[] rowI)", "testcase": false, "constructor": false}, {"identifier": "routeFromInputToOutput", "parameters": "(int rowIElIdx, int[] perm, int[] bottomPerm, int[] rowO)", "modifiers": "private", "return": "int", "signature": "int routeFromInputToOutput(int rowIElIdx, int[] perm, int[] bottomPerm, int[] rowO)", "full_signature": "private int routeFromInputToOutput(int rowIElIdx, int[] perm, int[] bottomPerm, int[] rowO)", "class_method_signature": "WaksmanUtils.routeFromInputToOutput(int rowIElIdx, int[] perm, int[] bottomPerm, int[] rowO)", "testcase": false, "constructor": false}, {"identifier": "route", "parameters": "(int fromElIdx, int[] perm, int[] subPerm, int[] swappers,\n      boolean outputToInput)", "modifiers": "private", "return": "int", "signature": "int route(int fromElIdx, int[] perm, int[] subPerm, int[] swappers,\n      boolean outputToInput)", "full_signature": "private int route(int fromElIdx, int[] perm, int[] subPerm, int[] swappers,\n      boolean outputToInput)", "class_method_signature": "WaksmanUtils.route(int fromElIdx, int[] perm, int[] subPerm, int[] swappers,\n      boolean outputToInput)", "testcase": false, "constructor": false}, {"identifier": "setControlBits", "parameters": "(int[] perm, int[][] controlBits, int rowIdx, int colIdx)", "modifiers": "private", "return": "void", "signature": "void setControlBits(int[] perm, int[][] controlBits, int rowIdx, int colIdx)", "full_signature": "private void setControlBits(int[] perm, int[][] controlBits, int rowIdx, int colIdx)", "class_method_signature": "WaksmanUtils.setControlBits(int[] perm, int[][] controlBits, int rowIdx, int colIdx)", "testcase": false, "constructor": false}, {"identifier": "getNumRowsRequired", "parameters": "(int n)", "modifiers": "public", "return": "int", "signature": "int getNumRowsRequired(int n)", "full_signature": "public int getNumRowsRequired(int n)", "class_method_signature": "WaksmanUtils.getNumRowsRequired(int n)", "testcase": false, "constructor": false}, {"identifier": "getNumColsRequired", "parameters": "(int n)", "modifiers": "public", "return": "int", "signature": "int getNumColsRequired(int n)", "full_signature": "public int getNumColsRequired(int n)", "class_method_signature": "WaksmanUtils.getNumColsRequired(int n)", "testcase": false, "constructor": false}, {"identifier": "isPow2", "parameters": "(int n)", "modifiers": "public", "return": "boolean", "signature": "boolean isPow2(int n)", "full_signature": "public boolean isPow2(int n)", "class_method_signature": "WaksmanUtils.isPow2(int n)", "testcase": false, "constructor": false}, {"identifier": "invert", "parameters": "(int[] p)", "modifiers": "public", "return": "int[]", "signature": "int[] invert(int[] p)", "full_signature": "public int[] invert(int[] p)", "class_method_signature": "WaksmanUtils.invert(int[] p)", "testcase": false, "constructor": false}, {"identifier": "setControlBits", "parameters": "(int[] perm)", "modifiers": "public", "return": "Matrix<BigInteger>", "signature": "Matrix<BigInteger> setControlBits(int[] perm)", "full_signature": "public Matrix<BigInteger> setControlBits(int[] perm)", "class_method_signature": "WaksmanUtils.setControlBits(int[] perm)", "testcase": false, "constructor": false}], "file": "lib/common/src/main/java/dk/alexandra/fresco/lib/common/collections/permute/WaksmanUtils.java"}, "focal_method": {"identifier": "setControlBits", "parameters": "(int[] perm, int[][] controlBits, int rowIdx, int colIdx)", "modifiers": "private", "return": "void", "body": "private void setControlBits(int[] perm, int[][] controlBits, int rowIdx, int colIdx) {\n    int n = perm.length;\n\n    if (n == 2) {\n      // for our base case we only have one swapper gate\n      // which we can set directly\n      controlBits[rowIdx][colIdx] = perm[0];\n      return;\n    }\n\n    int[] rowI = new int[n / 2];\n    int[] rowO = new int[n / 2];\n    for (int j = 0; j < rowO.length; j++) {\n      rowI[j] = -1;\n      rowO[j] = -1;\n    }\n\n    int[] topPerm = new int[n / 2];\n    int[] bottomPerm = new int[n / 2];\n\n    int[] permInv = invert(perm);\n\n    // loop until we have set all swappers at this level of the network\n    while (hasNextUnsetSwapper(rowO)) {\n      // find next O swapper that doesn't have control bit set\n      int rowOSwIdx = nextUnsetSwapperIdx(rowO);\n      // route through bottom\n      rowO[rowOSwIdx] = 0;\n\n      int firstOElIdx = topElIndexOf(rowOSwIdx);\n      int rowOElIdx = firstOElIdx;\n\n      // route from output to input and back again\n      int rowIElIdx = routeFromOutputToInput(rowOElIdx, permInv, topPerm, rowI);\n      rowOElIdx = routeFromInputToOutput(rowIElIdx, perm, bottomPerm, rowO);\n\n      // loop until we're back at the start\n      while (!(rowOElIdx == firstOElIdx)) {\n        rowIElIdx = routeFromOutputToInput(rowOElIdx, permInv, topPerm, rowI);\n        rowOElIdx = routeFromInputToOutput(rowIElIdx, perm, bottomPerm, rowO);\n      }\n    }\n\n    // we have set all input and output swappers at this level of the network so we update our\n    // swapper matrix and continue setting the swappers for our two sub permutations\n    int numCols = controlBits[0].length;\n    for (int j = 0; j < rowI.length; j++) {\n      controlBits[rowIdx + j][colIdx] = rowI[j];\n      controlBits[rowIdx + j][numCols - 1 - colIdx] = rowO[j];\n    }\n    setControlBits(topPerm, controlBits, rowIdx, colIdx + 1);\n    setControlBits(bottomPerm, controlBits, rowIdx + rowI.length / 2, colIdx + 1);\n  }", "signature": "void setControlBits(int[] perm, int[][] controlBits, int rowIdx, int colIdx)", "full_signature": "private void setControlBits(int[] perm, int[][] controlBits, int rowIdx, int colIdx)", "class_method_signature": "WaksmanUtils.setControlBits(int[] perm, int[][] controlBits, int rowIdx, int colIdx)", "testcase": false, "constructor": false, "invocations": ["invert", "hasNextUnsetSwapper", "nextUnsetSwapperIdx", "topElIndexOf", "routeFromOutputToInput", "routeFromInputToOutput", "routeFromOutputToInput", "routeFromInputToOutput", "setControlBits", "setControlBits"]}, "repository": {"repo_id": 46789213, "url": "https://github.com/aicis/fresco", "language": "Java", "is_fork": false, "fork_count": 35, "stargazer_count": 72, "size": 17923, "license": "licensed"}}