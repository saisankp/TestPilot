{"test_class": {"identifier": "MatchStepTest", "superclass": "", "interfaces": "", "fields": [], "file": "karate-core/src/test/java/com/intuit/karate/core/MatchStepTest.java"}, "test_case": {"identifier": "testMatchStep", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMatchStep() {\n        test(\"aXml //active == '#regex (false|true)'\", EQUALS, \"aXml\", \"//active\", \"'#regex (false|true)'\");\n        test(\"hello ==\", EQUALS, \"hello\", null, null);\n        test(\"hello world == foo\", EQUALS, \"hello\", \"world\", \"foo\");\n        test(\"each hello world == foo\", EACH_EQUALS, \"hello\", \"world\", \"foo\");\n        test(\"hello.foo(bar) != blah\", NOT_EQUALS, \"hello.foo(bar)\", null, \"blah\");\n        test(\"foo count(/records//record) contains any blah\", CONTAINS_ANY, \"foo\", \"count(/records//record)\", \"blah\");\n        test(\"__arg == karate.get('foos[' + __loop + ']')\", EQUALS, \"__arg\", null, \"karate.get('foos[' + __loop + ']')\");\n        test(\"response $[?(@.b=='ab')] == '#[1]'\", EQUALS, \"response\", \"$[?(@.b=='ab')]\", \"'#[1]'\");\n        test(\"test != '#? _.length == 2'\", NOT_EQUALS, \"test\", null, \"'#? _.length == 2'\");\n        test(\"actual[0] !contains badSchema\", NOT_CONTAINS, \"actual[0]\", null, \"badSchema\");\n        test(\"actual[0] contains badSchema\", CONTAINS, \"actual[0]\", null, \"badSchema\");\n        test(\"driver.eval('{ foo: \\\"bar\\\" }') == { hello: 'world' }\", EQUALS, \"driver.eval('{ foo: \\\"bar\\\" }')\", null, \"{ hello: 'world' }\");\n        test(\"response.integration.serviceData['Usage Data'][0].Stage ==\", EQUALS, \"response.integration.serviceData['Usage Data'][0].Stage\", null, null);\n        test(\"response contains { foo: 'a any b' }\", CONTAINS, \"response\", null, \"{ foo: 'a any b' }\");\n        test(\"response.foo == 'a contains b'\", EQUALS, \"response.foo\", null, \"'a contains b'\");\n        test(\"$.addOns[?(@.entitlementStateChangeReason=='RESUBSCRIBE')].addOnOfferID contains only toAddOnOfferIDs\", CONTAINS_ONLY, \"$.addOns[?(@.entitlementStateChangeReason=='RESUBSCRIBE')].addOnOfferID\", null, \"toAddOnOfferIDs\");\n    }", "signature": "void testMatchStep()", "full_signature": "@Test public void testMatchStep()", "class_method_signature": "MatchStepTest.testMatchStep()", "testcase": true, "constructor": false, "invocations": ["test", "test", "test", "test", "test", "test", "test", "test", "test", "test", "test", "test", "test", "test", "test", "test"]}, "focal_class": {"identifier": "MatchStep", "superclass": "", "interfaces": "", "fields": [{"original_string": "public final String name;", "modifier": "public final", "type": "String", "declarator": "name", "var_name": "name"}, {"original_string": "public final String path;", "modifier": "public final", "type": "String", "declarator": "path", "var_name": "path"}, {"original_string": "public final MatchType type;", "modifier": "public final", "type": "MatchType", "declarator": "type", "var_name": "type"}, {"original_string": "public final String expected;", "modifier": "public final", "type": "String", "declarator": "expected", "var_name": "expected"}], "methods": [{"identifier": "MatchStep", "parameters": "(String raw)", "modifiers": "public", "return": "", "signature": " MatchStep(String raw)", "full_signature": "public  MatchStep(String raw)", "class_method_signature": "MatchStep.MatchStep(String raw)", "testcase": false, "constructor": true}, {"identifier": "min", "parameters": "(int a, int b)", "modifiers": "private static", "return": "int", "signature": "int min(int a, int b)", "full_signature": "private static int min(int a, int b)", "class_method_signature": "MatchStep.min(int a, int b)", "testcase": false, "constructor": false}, {"identifier": "getType", "parameters": "(boolean each, boolean not, boolean contains, boolean only, boolean any, boolean deep)", "modifiers": "private static", "return": "MatchType", "signature": "MatchType getType(boolean each, boolean not, boolean contains, boolean only, boolean any, boolean deep)", "full_signature": "private static MatchType getType(boolean each, boolean not, boolean contains, boolean only, boolean any, boolean deep)", "class_method_signature": "MatchStep.getType(boolean each, boolean not, boolean contains, boolean only, boolean any, boolean deep)", "testcase": false, "constructor": false}], "file": "karate-core/src/main/java/com/intuit/karate/core/MatchStep.java"}, "focal_method": {"identifier": "MatchStep", "parameters": "(String raw)", "modifiers": "public", "return": "", "body": "public MatchStep(String raw) {\n        boolean each = false;\n        raw = raw.trim();\n        if (raw.startsWith(\"each\")) {\n            each = true;\n            raw = raw.substring(4).trim();\n        }\n        boolean contains = false;\n        boolean not = false;\n        boolean only = false;\n        boolean any = false;\n        boolean deep = false;\n        int spacePos = raw.indexOf(' ');\n        int leftParenPos = raw.indexOf('(');\n        int rightParenPos = raw.indexOf(')');\n        int lhsEndPos = raw.indexOf(\" contains\");\n        if (lhsEndPos == -1) {\n            lhsEndPos = raw.indexOf(\" !contains\");\n        }\n        int searchPos = 0;\n        int eqPos = raw.indexOf(\" == \");\n        if (eqPos == -1) {\n            eqPos = raw.indexOf(\" != \");\n        }\n        if (lhsEndPos != -1 && (eqPos == -1 || eqPos > lhsEndPos)) {\n            contains = true;\n            not = raw.charAt(lhsEndPos + 1) == '!';\n            searchPos = lhsEndPos + (not ? 10 : 9);\n            String anyOrOnlyOrDeep = raw.substring(searchPos).trim();\n            if (anyOrOnlyOrDeep.startsWith(\"only\")) {\n                int onlyPos = raw.indexOf(\" only\", searchPos);\n                only = true;\n                searchPos = onlyPos + 5;\n            } else if (anyOrOnlyOrDeep.startsWith(\"any\")) {\n                int anyPos = raw.indexOf(\" any\", searchPos);\n                any = true;\n                searchPos = anyPos + 4;\n            } else if (anyOrOnlyOrDeep.startsWith(\"deep\")) {\n                int deepPos = raw.indexOf(\" deep\", searchPos);\n                deep = true;\n                searchPos = deepPos + 5;\n            }\n        } else {\n            int equalPos = raw.indexOf(\" ==\", searchPos);\n            int notEqualPos = raw.indexOf(\" !=\", searchPos);\n            if (equalPos == -1 && notEqualPos == -1) {\n                throw new RuntimeException(\"syntax error, expected '==' for match\");\n            }\n            lhsEndPos = min(equalPos, notEqualPos);\n            if (lhsEndPos > spacePos && rightParenPos != -1 \n                    && rightParenPos > lhsEndPos && rightParenPos < leftParenPos) {\n                equalPos = raw.indexOf(\" ==\", rightParenPos);\n                notEqualPos = raw.indexOf(\" !=\", rightParenPos);\n                if (equalPos == -1 && notEqualPos == -1) {\n                    throw new RuntimeException(\"syntax error, expected '==' for match\");\n                }\n                lhsEndPos = min(equalPos, notEqualPos);\n            }\n            not = lhsEndPos == notEqualPos;\n            searchPos = lhsEndPos + 3;\n        }\n        String lhs = raw.substring(0, lhsEndPos).trim();\n        if (leftParenPos == -1) {\n            leftParenPos = lhs.indexOf('[');\n        }\n        if (spacePos != -1 && (leftParenPos > spacePos || leftParenPos == -1)) {\n            name = lhs.substring(0, spacePos);\n            path = StringUtils.trimToNull(lhs.substring(spacePos));\n        } else {\n            name = lhs;\n            path = null;\n        }\n        expected = StringUtils.trimToNull(raw.substring(searchPos));\n        type = getType(each, not, contains, only, any, deep);\n    }", "signature": " MatchStep(String raw)", "full_signature": "public  MatchStep(String raw)", "class_method_signature": "MatchStep.MatchStep(String raw)", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 81226206, "url": "https://github.com/intuit/karate", "stars": 2712, "created": "2/7/2017 3:59:17 PM +00:00", "updates": "2020-01-27T21:00:57+00:00", "fork": "False", "license": "licensed"}}