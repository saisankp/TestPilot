{"test_class": {"identifier": "FetcherManagerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private String testTopic1 = \"ConsumerFetcherManagerTest1\";", "modifier": "private", "type": "String", "declarator": "testTopic1 = \"ConsumerFetcherManagerTest1\"", "var_name": "testTopic1"}, {"original_string": "private String testTopic2 = \"ConsumerFetcherManagerTest2\";", "modifier": "private", "type": "String", "declarator": "testTopic2 = \"ConsumerFetcherManagerTest2\"", "var_name": "testTopic2"}, {"original_string": "private Map<String, ConsumerFetcherThread> fetcherThreadMap = new HashMap<>();", "modifier": "private", "type": "Map<String, ConsumerFetcherThread>", "declarator": "fetcherThreadMap = new HashMap<>()", "var_name": "fetcherThreadMap"}, {"original_string": "private final ConsumerFetcherThread mockFetcherThread1 = EasyMock\n      .createMock(ConsumerFetcherThread.class);", "modifier": "private final", "type": "ConsumerFetcherThread", "declarator": "mockFetcherThread1 = EasyMock\n      .createMock(ConsumerFetcherThread.class)", "var_name": "mockFetcherThread1"}, {"original_string": "private final ConsumerFetcherThread mockFetcherThread2 = EasyMock\n      .createMock(ConsumerFetcherThread.class);", "modifier": "private final", "type": "ConsumerFetcherThread", "declarator": "mockFetcherThread2 = EasyMock\n      .createMock(ConsumerFetcherThread.class)", "var_name": "mockFetcherThread2"}, {"original_string": "private KafkaClusterObserver kafkaClusterObserver = EasyMock\n      .createMock(KafkaClusterObserver.class);", "modifier": "private", "type": "KafkaClusterObserver", "declarator": "kafkaClusterObserver = EasyMock\n      .createMock(KafkaClusterObserver.class)", "var_name": "kafkaClusterObserver"}, {"original_string": "private ConsumerFetcherThread mockConsumerFetcherThread = EasyMock\n      .createMock(ConsumerFetcherThread.class);", "modifier": "private", "type": "ConsumerFetcherThread", "declarator": "mockConsumerFetcherThread = EasyMock\n      .createMock(ConsumerFetcherThread.class)", "var_name": "mockConsumerFetcherThread"}], "file": "uReplicator-Worker-3.0/src/test/java/com/uber/stream/ureplicator/worker/FetcherManagerTest.java"}, "test_case": {"identifier": "testAddFetcherForTopicPartition", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testAddFetcherForTopicPartition() {\n    CustomizedConsumerConfig consumerConfig = new CustomizedConsumerConfig(new Properties());\n    consumerConfig.setProperty(ConsumerConfig.CLIENT_ID_CONFIG, \"ureplicator\");\n    consumerConfig.setProperty(ConsumerConfig.GROUP_ID_CONFIG, \"ureplicator\");\n    List<BlockingQueue<FetchedDataChunk>> messageQueue = new ArrayList<>();\n    BlockingQueue<FetchedDataChunk> queue = new LinkedBlockingQueue<>(3);\n    messageQueue.add(queue);\n    MockFetcherManager fetcherManagerByHashId = new MockFetcherManager(\n        \"FetcherManagerGroupByHashId\",\n        consumerConfig, messageQueue);\n    TopicPartition tp1 = new TopicPartition(testTopic1, 0);\n    TopicPartition tp2 = new TopicPartition(testTopic2, 1);\n    PartitionOffsetInfo partitionOffsetInfo1 = new PartitionOffsetInfo(tp1, 0L, 10L);\n    PartitionOffsetInfo partitionOffsetInfo2 = new PartitionOffsetInfo(tp2, 0L, 10L);\n\n    EasyMock.reset(mockConsumerFetcherThread);\n\n    mockConsumerFetcherThread.start();\n    EasyMock.expectLastCall().times(2);\n\n    mockConsumerFetcherThread.addPartitions(Collections.singletonMap(tp1, partitionOffsetInfo1));\n    EasyMock.expectLastCall().times(1);\n    mockConsumerFetcherThread.addPartitions(Collections.singletonMap(tp2, partitionOffsetInfo2));\n    EasyMock.expectLastCall().times(1);\n\n    EasyMock.replay(mockConsumerFetcherThread);\n\n    fetcherManagerByHashId\n        .addFetcherForTopicPartition(tp1, partitionOffsetInfo1, \"fetcherThread-1\");\n    fetcherManagerByHashId\n        .addFetcherForTopicPartition(tp2, partitionOffsetInfo2, \"fetcherThread-2\");\n\n    Assert.assertEquals(fetcherManagerByHashId.clientId.size(), 2);\n    Assert.assertTrue(fetcherManagerByHashId.clientId.contains(\"ureplicator-1\"));\n    Assert.assertTrue(fetcherManagerByHashId.clientId.contains(\"ureplicator-2\"));\n    Assert.assertEquals(consumerConfig.getProperty(ConsumerConfig.CLIENT_ID_CONFIG), \"ureplicator\");\n\n    EasyMock.verify(mockConsumerFetcherThread);\n\n\n  }", "signature": "void testAddFetcherForTopicPartition()", "full_signature": "@Test public void testAddFetcherForTopicPartition()", "class_method_signature": "FetcherManagerTest.testAddFetcherForTopicPartition()", "testcase": true, "constructor": false, "invocations": ["setProperty", "setProperty", "add", "reset", "start", "times", "expectLastCall", "addPartitions", "singletonMap", "times", "expectLastCall", "addPartitions", "singletonMap", "times", "expectLastCall", "replay", "addFetcherForTopicPartition", "addFetcherForTopicPartition", "assertEquals", "size", "assertTrue", "contains", "assertTrue", "contains", "assertEquals", "getProperty", "verify"]}, "focal_class": {"identifier": "FetcherManager", "superclass": "extends ShutdownableThread", "interfaces": "implements\n    IConsumerFetcherManager", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory\n      .getLogger(FetcherManager.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory\n      .getLogger(FetcherManager.class)", "var_name": "LOGGER"}, {"original_string": "protected final String FETCHER_THREAD_PREFIX = \"ConsumerFetcherThread\";", "modifier": "protected final", "type": "String", "declarator": "FETCHER_THREAD_PREFIX = \"ConsumerFetcherThread\"", "var_name": "FETCHER_THREAD_PREFIX"}, {"original_string": "protected final Object fetcherMapLock;", "modifier": "protected final", "type": "Object", "declarator": "fetcherMapLock", "var_name": "fetcherMapLock"}, {"original_string": "protected final Object updateMapLock;", "modifier": "protected final", "type": "Object", "declarator": "updateMapLock", "var_name": "updateMapLock"}, {"original_string": "@GuardedBy(\"fetcherMapLock\")\n  protected final Map<TopicPartition, String> partitionThreadMap;", "modifier": "@GuardedBy(\"fetcherMapLock\")\n  protected final", "type": "Map<TopicPartition, String>", "declarator": "partitionThreadMap", "var_name": "partitionThreadMap"}, {"original_string": "@GuardedBy(\"updateMapLock\")\n  protected final Map<TopicPartition, PartitionOffsetInfo> partitionMap;", "modifier": "@GuardedBy(\"updateMapLock\")\n  protected final", "type": "Map<TopicPartition, PartitionOffsetInfo>", "declarator": "partitionMap", "var_name": "partitionMap"}, {"original_string": "@GuardedBy(\"updateMapLock\")\n  protected final Map<TopicPartition, PartitionOffsetInfo> partitionAddMap;", "modifier": "@GuardedBy(\"updateMapLock\")\n  protected final", "type": "Map<TopicPartition, PartitionOffsetInfo>", "declarator": "partitionAddMap", "var_name": "partitionAddMap"}, {"original_string": "@GuardedBy(\"updateMapLock\")\n  protected final Map<TopicPartition, Boolean> partitionDeleteMap;", "modifier": "@GuardedBy(\"updateMapLock\")\n  protected final", "type": "Map<TopicPartition, Boolean>", "declarator": "partitionDeleteMap", "var_name": "partitionDeleteMap"}, {"original_string": "protected final Map<String, ConsumerFetcherThread> fetcherThreadMap;", "modifier": "protected final", "type": "Map<String, ConsumerFetcherThread>", "declarator": "fetcherThreadMap", "var_name": "fetcherThreadMap"}, {"original_string": "protected final CustomizedConsumerConfig consumerProperties;", "modifier": "protected final", "type": "CustomizedConsumerConfig", "declarator": "consumerProperties", "var_name": "consumerProperties"}, {"original_string": "protected final int refreshBackoff;", "modifier": "protected final", "type": "int", "declarator": "refreshBackoff", "var_name": "refreshBackoff"}, {"original_string": "protected final int numberOfConsumerFetcher;", "modifier": "protected final", "type": "int", "declarator": "numberOfConsumerFetcher", "var_name": "numberOfConsumerFetcher"}, {"original_string": "protected final RateLimiter messageLimiter;", "modifier": "protected final", "type": "RateLimiter", "declarator": "messageLimiter", "var_name": "messageLimiter"}, {"original_string": "protected final List<BlockingQueue<FetchedDataChunk>> messageQueue;", "modifier": "protected final", "type": "List<BlockingQueue<FetchedDataChunk>>", "declarator": "messageQueue", "var_name": "messageQueue"}, {"original_string": "protected final AtomicInteger fetcherId;", "modifier": "protected final", "type": "AtomicInteger", "declarator": "fetcherId", "var_name": "fetcherId"}], "methods": [{"identifier": "FetcherManager", "parameters": "(String threadName,\n      CustomizedConsumerConfig consumerProperties,\n      List<BlockingQueue<FetchedDataChunk>> messageQueue)", "modifiers": "public", "return": "", "signature": " FetcherManager(String threadName,\n      CustomizedConsumerConfig consumerProperties,\n      List<BlockingQueue<FetchedDataChunk>> messageQueue)", "full_signature": "public  FetcherManager(String threadName,\n      CustomizedConsumerConfig consumerProperties,\n      List<BlockingQueue<FetchedDataChunk>> messageQueue)", "class_method_signature": "FetcherManager.FetcherManager(String threadName,\n      CustomizedConsumerConfig consumerProperties,\n      List<BlockingQueue<FetchedDataChunk>> messageQueue)", "testcase": false, "constructor": true}, {"identifier": "FetcherManager", "parameters": "(String threadName,\n      CustomizedConsumerConfig consumerProperties,\n      Map<String, ConsumerFetcherThread> fetcherThreadMap,\n      List<BlockingQueue<FetchedDataChunk>> messageQueue)", "modifiers": "@VisibleForTesting protected", "return": "", "signature": " FetcherManager(String threadName,\n      CustomizedConsumerConfig consumerProperties,\n      Map<String, ConsumerFetcherThread> fetcherThreadMap,\n      List<BlockingQueue<FetchedDataChunk>> messageQueue)", "full_signature": "@VisibleForTesting protected  FetcherManager(String threadName,\n      CustomizedConsumerConfig consumerProperties,\n      Map<String, ConsumerFetcherThread> fetcherThreadMap,\n      List<BlockingQueue<FetchedDataChunk>> messageQueue)", "class_method_signature": "FetcherManager.FetcherManager(String threadName,\n      CustomizedConsumerConfig consumerProperties,\n      Map<String, ConsumerFetcherThread> fetcherThreadMap,\n      List<BlockingQueue<FetchedDataChunk>> messageQueue)", "testcase": false, "constructor": true}, {"identifier": "setMessageRate", "parameters": "(Double rate)", "modifiers": "public", "return": "void", "signature": "void setMessageRate(Double rate)", "full_signature": "public void setMessageRate(Double rate)", "class_method_signature": "FetcherManager.setMessageRate(Double rate)", "testcase": false, "constructor": false}, {"identifier": "addTopicPartition", "parameters": "(TopicPartition topicPartition, PartitionOffsetInfo partitionInfo)", "modifiers": "public", "return": "void", "signature": "void addTopicPartition(TopicPartition topicPartition, PartitionOffsetInfo partitionInfo)", "full_signature": "public void addTopicPartition(TopicPartition topicPartition, PartitionOffsetInfo partitionInfo)", "class_method_signature": "FetcherManager.addTopicPartition(TopicPartition topicPartition, PartitionOffsetInfo partitionInfo)", "testcase": false, "constructor": false}, {"identifier": "removeTopicPartition", "parameters": "(TopicPartition topicPartition)", "modifiers": "public", "return": "void", "signature": "void removeTopicPartition(TopicPartition topicPartition)", "full_signature": "public void removeTopicPartition(TopicPartition topicPartition)", "class_method_signature": "FetcherManager.removeTopicPartition(TopicPartition topicPartition)", "testcase": false, "constructor": false}, {"identifier": "removeFetcherForPartitions", "parameters": "(Set<TopicPartition> topicPartition)", "modifiers": "@GuardedBy(\"fetcherMapLock\") private", "return": "void", "signature": "void removeFetcherForPartitions(Set<TopicPartition> topicPartition)", "full_signature": "@GuardedBy(\"fetcherMapLock\") private void removeFetcherForPartitions(Set<TopicPartition> topicPartition)", "class_method_signature": "FetcherManager.removeFetcherForPartitions(Set<TopicPartition> topicPartition)", "testcase": false, "constructor": false}, {"identifier": "addFetcherForTopicPartition", "parameters": "(\n      TopicPartition tp, PartitionOffsetInfo offsetInfo, String fetcherThreadName)", "modifiers": "@GuardedBy(\"fetcherMapLock\") protected", "return": "void", "signature": "void addFetcherForTopicPartition(\n      TopicPartition tp, PartitionOffsetInfo offsetInfo, String fetcherThreadName)", "full_signature": "@GuardedBy(\"fetcherMapLock\") protected void addFetcherForTopicPartition(\n      TopicPartition tp, PartitionOffsetInfo offsetInfo, String fetcherThreadName)", "class_method_signature": "FetcherManager.addFetcherForTopicPartition(\n      TopicPartition tp, PartitionOffsetInfo offsetInfo, String fetcherThreadName)", "testcase": false, "constructor": false}, {"identifier": "createConsumerFetcherThread", "parameters": "(String threadName,\n      CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "modifiers": "@VisibleForTesting protected", "return": "ConsumerFetcherThread", "signature": "ConsumerFetcherThread createConsumerFetcherThread(String threadName,\n      CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "full_signature": "@VisibleForTesting protected ConsumerFetcherThread createConsumerFetcherThread(String threadName,\n      CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "class_method_signature": "FetcherManager.createConsumerFetcherThread(String threadName,\n      CustomizedConsumerConfig properties,\n      RateLimiter rateLimiter, BlockingQueue<FetchedDataChunk> chunkQueue)", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "FetcherManager.shutdown()", "testcase": false, "constructor": false}, {"identifier": "getTopicPartitions", "parameters": "()", "modifiers": "public", "return": "Set<TopicPartition>", "signature": "Set<TopicPartition> getTopicPartitions()", "full_signature": "public Set<TopicPartition> getTopicPartitions()", "class_method_signature": "FetcherManager.getTopicPartitions()", "testcase": false, "constructor": false}, {"identifier": "getFetcherThreadName", "parameters": "(TopicPartition tp)", "modifiers": "protected", "return": "String", "signature": "String getFetcherThreadName(TopicPartition tp)", "full_signature": "protected String getFetcherThreadName(TopicPartition tp)", "class_method_signature": "FetcherManager.getFetcherThreadName(TopicPartition tp)", "testcase": false, "constructor": false}, {"identifier": "addTopicPartitionsToFetcherThread", "parameters": "(\n      Map<TopicPartition, PartitionOffsetInfo> topicPartitions)", "modifiers": "protected", "return": "Map<TopicPartition, PartitionOffsetInfo>", "signature": "Map<TopicPartition, PartitionOffsetInfo> addTopicPartitionsToFetcherThread(\n      Map<TopicPartition, PartitionOffsetInfo> topicPartitions)", "full_signature": "protected Map<TopicPartition, PartitionOffsetInfo> addTopicPartitionsToFetcherThread(\n      Map<TopicPartition, PartitionOffsetInfo> topicPartitions)", "class_method_signature": "FetcherManager.addTopicPartitionsToFetcherThread(\n      Map<TopicPartition, PartitionOffsetInfo> topicPartitions)", "testcase": false, "constructor": false}, {"identifier": "doWork", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void doWork()", "full_signature": "@Override public void doWork()", "class_method_signature": "FetcherManager.doWork()", "testcase": false, "constructor": false}], "file": "uReplicator-Worker-3.0/src/main/java/com/uber/stream/ureplicator/worker/FetcherManager.java"}, "focal_method": {"identifier": "addFetcherForTopicPartition", "parameters": "(\n      TopicPartition tp, PartitionOffsetInfo offsetInfo, String fetcherThreadName)", "modifiers": "@GuardedBy(\"fetcherMapLock\") protected", "return": "void", "body": "@GuardedBy(\"fetcherMapLock\")\n  protected void addFetcherForTopicPartition(\n      TopicPartition tp, PartitionOffsetInfo offsetInfo, String fetcherThreadName) {\n    LOGGER.info(\"Enter add fetcher thread for partitions {}, fetcherThread {}\", tp,\n        fetcherThreadName);\n    synchronized (fetcherMapLock) {\n      if (StringUtils.isBlank(fetcherThreadName)) {\n        LOGGER.warn(\"Unexpected behavior, can't find threadName for topic partition {}\", tp);\n        return;\n      }\n\n      ConsumerFetcherThread fetcherThread = fetcherThreadMap\n          .getOrDefault(fetcherThreadName, null);\n      if (fetcherThread == null) {\n        try {\n          int queueSize = Math.abs(fetcherThreadName.hashCode() % messageQueue.size());\n\n          LOGGER.info(\"Creating fetcher thread {}\", fetcherThreadName);\n          CustomizedConsumerConfig cloned = (CustomizedConsumerConfig) consumerProperties.clone();\n          String clientIdPrefix = consumerProperties\n              .getProperty(ConsumerConfig.CLIENT_ID_CONFIG, \"ureplicator\");\n          int fetcherThreadId = fetcherId.incrementAndGet();\n          // Kafka Consumer doesn't support having two kafka consumer using the same client id,\n          // It throws error: WARN Error registering AppInfo mbean\n          cloned.setProperty(ConsumerConfig.CLIENT_ID_CONFIG,\n              String.format(\"%s-%d\", clientIdPrefix, fetcherThreadId));\n          fetcherThread = createConsumerFetcherThread(fetcherThreadName, cloned,\n              messageLimiter, messageQueue.get(queueSize));\n          fetcherThread.start();\n          fetcherThreadMap.put(fetcherThreadName, fetcherThread);\n          LOGGER.info(\"Fetcher fetcher thread {} created\", fetcherThreadName);\n        } catch (Exception e) {\n          LOGGER.error(\"Failed to create new fetcher thread {}\", getName(), e);\n          return;\n        }\n      }\n      fetcherThread.addPartitions(ImmutableMap.of(tp, offsetInfo));\n      partitionThreadMap.putIfAbsent(tp, fetcherThreadName);\n    }\n    LOGGER.info(\"Add fetcher thread for partitions {} finished\", tp);\n  }", "signature": "void addFetcherForTopicPartition(\n      TopicPartition tp, PartitionOffsetInfo offsetInfo, String fetcherThreadName)", "full_signature": "@GuardedBy(\"fetcherMapLock\") protected void addFetcherForTopicPartition(\n      TopicPartition tp, PartitionOffsetInfo offsetInfo, String fetcherThreadName)", "class_method_signature": "FetcherManager.addFetcherForTopicPartition(\n      TopicPartition tp, PartitionOffsetInfo offsetInfo, String fetcherThreadName)", "testcase": false, "constructor": false, "invocations": ["info", "isBlank", "warn", "getOrDefault", "abs", "hashCode", "size", "info", "clone", "getProperty", "incrementAndGet", "setProperty", "format", "createConsumerFetcherThread", "get", "start", "put", "info", "error", "getName", "addPartitions", "of", "putIfAbsent", "info"]}, "repository": {"repo_id": 60201162, "url": "https://github.com/uber/uReplicator", "language": "Java", "is_fork": false, "fork_count": 148, "stargazer_count": 652, "size": 2223, "license": "licensed"}}