{"test_class": {"identifier": "NodeCollectionWatcherTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static TestingCluster zkServer;", "modifier": "private static", "type": "TestingCluster", "declarator": "zkServer", "var_name": "zkServer"}, {"original_string": "private static CuratorFramework curator;", "modifier": "private static", "type": "CuratorFramework", "declarator": "curator", "var_name": "curator"}, {"original_string": "private static ZooKeeper zooKeeper;", "modifier": "private static", "type": "ZooKeeper", "declarator": "zooKeeper", "var_name": "zooKeeper"}, {"original_string": "private final AtomicInteger counter = new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "counter = new AtomicInteger(0)", "var_name": "counter"}], "file": "cn-zookeeper/src/test/java/org/cloudname/backends/zookeeper/NodeCollectionWatcherTest.java"}, "test_case": {"identifier": "networkPartitionTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void networkPartitionTest() throws Exception {\n        assumeThat(System.getProperty(\"NodeCollectionWatcher.SlowTests\"), is(\"ok\"));\n\n        final int maxPropagationTime = 10;\n\n        final String pathPrefix = \"/foo/partition\";\n        curator.create().creatingParentsIfNeeded().forPath(pathPrefix);\n\n        final int nodeCount = 10;\n\n        final ListenerCounter listener = new ListenerCounter(nodeCount, nodeCount, nodeCount);\n\n        final NodeCollectionWatcher nodeCollectionWatcher = new NodeCollectionWatcher(zooKeeper, pathPrefix, listener);\n\n        // Create a few nodes to set the initial state\n        for (int i = 0; i < nodeCount; i++) {\n            curator.create().forPath(pathPrefix + \"/node\" + i, getData());\n        }\n        assertTrue(listener.createLatch.await(maxPropagationTime, TimeUnit.MILLISECONDS));\n        assertThat(listener.createCount.get(), is(nodeCount));\n        assertThat(listener.removeCount.get(), is(0));\n        assertThat(listener.dataCount.get(), is(0));\n\n        final InstanceSpec firstInstance = zkServer.findConnectionInstance(zooKeeper);\n        zkServer.killServer(firstInstance);\n\n        listener.createLatch = new CountDownLatch(1);\n        // Client should reconnect to one of the two remaining\n        curator.create().forPath(pathPrefix + \"/stillalive\", getData());\n        // Wait for the notification to go through. This could take some time since there's\n        // reconnects and all sorts of magic happening under the hood\n        assertTrue(listener.createLatch.await(10, TimeUnit.SECONDS));\n        assertThat(listener.createCount.get(), is(nodeCount + 1));\n        assertThat(listener.removeCount.get(), is(0));\n        assertThat(listener.dataCount.get(), is(0));\n\n        // Kill the 2nd server. The cluster won't have a quorum now\n        final InstanceSpec secondInstance = zkServer.findConnectionInstance(zooKeeper);\n        assertThat(firstInstance, is(not(secondInstance)));\n        zkServer.killServer(secondInstance);\n\n        boolean retry;\n        do {\n            System.out.println(\"Checking node with Curator... This might take a while...\");\n            try {\n                final Stat stat = curator.checkExists().forPath(pathPrefix);\n                retry = false;\n                assertThat(stat, is(notNullValue()));\n            } catch (CuratorConnectionLossException ex) {\n                System.out.println(\"Missing connection. Retrying\");\n                retry = true;\n            }\n        } while (retry);\n\n        zkServer.restartServer(firstInstance);\n        zkServer.restartServer(secondInstance);\n        listener.createLatch = new CountDownLatch(1);\n\n        System.out.println(\"Creating node via Curator... This might take a while...\");\n        curator.create().forPath(pathPrefix + \"/imback\", getData());\n\n        assertTrue(listener.createLatch.await(maxPropagationTime, TimeUnit.MILLISECONDS));\n        assertThat(listener.createCount.get(), is(nodeCount + 2));\n        assertThat(listener.removeCount.get(), is(0));\n        assertThat(listener.dataCount.get(), is(0));\n\n        // Ensure data notifications are propagated after a failure\n        for (int i = 0; i < nodeCount; i++) {\n            final Stat stat = curator.setData().forPath(pathPrefix + \"/node\" + i, getData());\n            assertThat(stat, is(notNullValue()));\n        }\n        assertTrue(listener.dataLatch.await(maxPropagationTime, TimeUnit.MILLISECONDS));\n        assertThat(listener.createCount.get(), is(nodeCount + 2));\n        assertThat(listener.removeCount.get(), is(0));\n        assertThat(listener.dataCount.get(), is(nodeCount));\n\n        // ..and remove notifications are sent\n        for (int i = 0; i < nodeCount; i++) {\n            curator.delete().forPath(pathPrefix + \"/node\" + i);\n        }\n        assertTrue(listener.removeLatch.await(maxPropagationTime, TimeUnit.MILLISECONDS));\n        assertThat(listener.createCount.get(), is(nodeCount + 2));\n        assertThat(listener.removeCount.get(), is(nodeCount));\n        assertThat(listener.dataCount.get(), is(nodeCount));\n\n        nodeCollectionWatcher.shutdown();\n\n    }", "signature": "void networkPartitionTest()", "full_signature": "@Test public void networkPartitionTest()", "class_method_signature": "NodeCollectionWatcherTest.networkPartitionTest()", "testcase": true, "constructor": false, "invocations": ["assumeThat", "getProperty", "is", "forPath", "creatingParentsIfNeeded", "create", "forPath", "create", "getData", "assertTrue", "await", "assertThat", "get", "is", "assertThat", "get", "is", "assertThat", "get", "is", "findConnectionInstance", "killServer", "forPath", "create", "getData", "assertTrue", "await", "assertThat", "get", "is", "assertThat", "get", "is", "assertThat", "get", "is", "findConnectionInstance", "assertThat", "is", "not", "killServer", "println", "forPath", "checkExists", "assertThat", "is", "notNullValue", "println", "restartServer", "restartServer", "println", "forPath", "create", "getData", "assertTrue", "await", "assertThat", "get", "is", "assertThat", "get", "is", "assertThat", "get", "is", "forPath", "setData", "getData", "assertThat", "is", "notNullValue", "assertTrue", "await", "assertThat", "get", "is", "assertThat", "get", "is", "assertThat", "get", "is", "forPath", "delete", "assertTrue", "await", "assertThat", "get", "is", "assertThat", "get", "is", "assertThat", "get", "is", "shutdown"]}, "focal_class": {"identifier": "NodeCollectionWatcher", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = Logger.getLogger(NodeCollectionWatcher.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(NodeCollectionWatcher.class.getName())", "var_name": "LOG"}, {"original_string": "private final Map<String, Long> childMzxid = new HashMap<>();", "modifier": "private final", "type": "Map<String, Long>", "declarator": "childMzxid = new HashMap<>()", "var_name": "childMzxid"}, {"original_string": "private final Object syncObject = new Object();", "modifier": "private final", "type": "Object", "declarator": "syncObject = new Object()", "var_name": "syncObject"}, {"original_string": "private final ZooKeeper zk;", "modifier": "private final", "type": "ZooKeeper", "declarator": "zk", "var_name": "zk"}, {"original_string": "private final String pathToWatch;", "modifier": "private final", "type": "String", "declarator": "pathToWatch", "var_name": "pathToWatch"}, {"original_string": "private final AtomicBoolean shuttingDown = new AtomicBoolean(false);", "modifier": "private final", "type": "AtomicBoolean", "declarator": "shuttingDown = new AtomicBoolean(false)", "var_name": "shuttingDown"}, {"original_string": "private final NodeWatcherListener listener;", "modifier": "private final", "type": "NodeWatcherListener", "declarator": "listener", "var_name": "listener"}, {"original_string": "private final Watcher nodeCollectionWatcher = (watchedEvent) -> {\n        switch (watchedEvent.getType()) {\n            case NodeChildrenChanged:\n                // Child values have changed, read children, generate events\n                readChildNodes();\n                break;\n            case None:\n                // Some zookeeper event. Watches might not apply anymore. Reapply.\n                switch (watchedEvent.getState()) {\n                    case ConnectedReadOnly:\n                        LOG.severe(\"Connected to readonly cluster\");\n                        // Connected to a cluster without quorum. Nodes might not be\n                        // correct but re-read the nodes.\n                        readChildNodes();\n                        break;\n                    case SyncConnected:\n                        LOG.info(\"Connected to cluster\");\n                        // (re-)Connected to the cluster. Nodes must be re-read. Discard\n                        // those that aren't found, keep unchanged ones.\n                        readChildNodes();\n                        break;\n                    case Disconnected:\n                        // Disconnected from the cluster. The nodes might not be\n                        // up to date (but a reconnect might solve the issue)\n                        LOG.log(Level.WARNING, \"Disconnected from zk cluster\");\n                        break;\n                    case Expired:\n                        // Session has expired. Nodes are no longer available\n                        removeAllChildNodes();\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            default:\n                break;\n        }\n    };", "modifier": "private final", "type": "Watcher", "declarator": "nodeCollectionWatcher = (watchedEvent) -> {\n        switch (watchedEvent.getType()) {\n            case NodeChildrenChanged:\n                // Child values have changed, read children, generate events\n                readChildNodes();\n                break;\n            case None:\n                // Some zookeeper event. Watches might not apply anymore. Reapply.\n                switch (watchedEvent.getState()) {\n                    case ConnectedReadOnly:\n                        LOG.severe(\"Connected to readonly cluster\");\n                        // Connected to a cluster without quorum. Nodes might not be\n                        // correct but re-read the nodes.\n                        readChildNodes();\n                        break;\n                    case SyncConnected:\n                        LOG.info(\"Connected to cluster\");\n                        // (re-)Connected to the cluster. Nodes must be re-read. Discard\n                        // those that aren't found, keep unchanged ones.\n                        readChildNodes();\n                        break;\n                    case Disconnected:\n                        // Disconnected from the cluster. The nodes might not be\n                        // up to date (but a reconnect might solve the issue)\n                        LOG.log(Level.WARNING, \"Disconnected from zk cluster\");\n                        break;\n                    case Expired:\n                        // Session has expired. Nodes are no longer available\n                        removeAllChildNodes();\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            default:\n                break;\n        }\n    }", "var_name": "nodeCollectionWatcher"}, {"original_string": "private final Watcher changeWatcher = (watchedEvent) -> {\n        if (shuttingDown.get()) {\n            return;\n        }\n        switch (watchedEvent.getType()) {\n            case NodeDeleted:\n                removeChildNode(watchedEvent.getPath());\n                break;\n            case NodeDataChanged:\n                processNode(watchedEvent.getPath());\n                break;\n            default:\n                break;\n        }\n    };", "modifier": "private final", "type": "Watcher", "declarator": "changeWatcher = (watchedEvent) -> {\n        if (shuttingDown.get()) {\n            return;\n        }\n        switch (watchedEvent.getType()) {\n            case NodeDeleted:\n                removeChildNode(watchedEvent.getPath());\n                break;\n            case NodeDataChanged:\n                processNode(watchedEvent.getPath());\n                break;\n            default:\n                break;\n        }\n    }", "var_name": "changeWatcher"}], "methods": [{"identifier": "NodeCollectionWatcher", "parameters": "(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "modifiers": "public", "return": "", "signature": " NodeCollectionWatcher(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "full_signature": "public  NodeCollectionWatcher(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "class_method_signature": "NodeCollectionWatcher.NodeCollectionWatcher(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "testcase": false, "constructor": true}, {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "NodeCollectionWatcher.shutdown()", "testcase": false, "constructor": false}, {"identifier": "removeAllChildNodes", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void removeAllChildNodes()", "full_signature": "private void removeAllChildNodes()", "class_method_signature": "NodeCollectionWatcher.removeAllChildNodes()", "testcase": false, "constructor": false}, {"identifier": "readChildNodes", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void readChildNodes()", "full_signature": "private void readChildNodes()", "class_method_signature": "NodeCollectionWatcher.readChildNodes()", "testcase": false, "constructor": false}, {"identifier": "processNode", "parameters": "(final String nodePath)", "modifiers": "private", "return": "void", "signature": "void processNode(final String nodePath)", "full_signature": "private void processNode(final String nodePath)", "class_method_signature": "NodeCollectionWatcher.processNode(final String nodePath)", "testcase": false, "constructor": false}, {"identifier": "removeChildNode", "parameters": "(final String nodePath)", "modifiers": "private", "return": "void", "signature": "void removeChildNode(final String nodePath)", "full_signature": "private void removeChildNode(final String nodePath)", "class_method_signature": "NodeCollectionWatcher.removeChildNode(final String nodePath)", "testcase": false, "constructor": false}, {"identifier": "generateCreateEvent", "parameters": "(final String nodePath, final String data)", "modifiers": "private", "return": "void", "signature": "void generateCreateEvent(final String nodePath, final String data)", "full_signature": "private void generateCreateEvent(final String nodePath, final String data)", "class_method_signature": "NodeCollectionWatcher.generateCreateEvent(final String nodePath, final String data)", "testcase": false, "constructor": false}, {"identifier": "generateDataChangeEvent", "parameters": "(final String nodePath, final String data)", "modifiers": "private", "return": "void", "signature": "void generateDataChangeEvent(final String nodePath, final String data)", "full_signature": "private void generateDataChangeEvent(final String nodePath, final String data)", "class_method_signature": "NodeCollectionWatcher.generateDataChangeEvent(final String nodePath, final String data)", "testcase": false, "constructor": false}, {"identifier": "generateRemoveEvent", "parameters": "(final String nodePath)", "modifiers": "private", "return": "void", "signature": "void generateRemoveEvent(final String nodePath)", "full_signature": "private void generateRemoveEvent(final String nodePath)", "class_method_signature": "NodeCollectionWatcher.generateRemoveEvent(final String nodePath)", "testcase": false, "constructor": false}], "file": "cn-zookeeper/src/main/java/org/cloudname/backends/zookeeper/NodeCollectionWatcher.java"}, "focal_method": {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void shutdown() {\n        shuttingDown.set(true);\n    }", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "NodeCollectionWatcher.shutdown()", "testcase": false, "constructor": false, "invocations": ["set"]}, "repository": {"repo_id": 2329961, "url": "https://github.com/Cloudname/cloudname", "language": "Java", "is_fork": false, "fork_count": 23, "stargazer_count": 21, "size": 26031, "license": "licensed"}}