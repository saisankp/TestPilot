{"test_class": {"identifier": "StreamGraphGeneratorTest", "superclass": "", "interfaces": "", "fields": [], "file": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorTest.java"}, "test_case": {"identifier": "testOutputTypeConfigurationWithTwoInputTransformation", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testOutputTypeConfigurationWithTwoInputTransformation() throws Exception {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 10);\n\t\tDataStream<Integer> source2 = env.fromElements(2, 11);\n\n\t\tConnectedStreams<Integer, Integer> connectedSource = source1.connect(source2);\n\n\t\tOutputTypeConfigurableOperationWithTwoInputs outputTypeConfigurableOperation = new OutputTypeConfigurableOperationWithTwoInputs();\n\n\t\tDataStream<Integer> result = connectedSource.transform(\n\t\t\t\t\"Two input and output type configurable operation\",\n\t\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n\t\t\t\toutputTypeConfigurableOperation);\n\n\t\tresult.addSink(new NoOpSink<Integer>());\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tassertEquals(BasicTypeInfo.INT_TYPE_INFO, outputTypeConfigurableOperation.getTypeInformation());\n\t}", "signature": "void testOutputTypeConfigurationWithTwoInputTransformation()", "full_signature": "@Test public void testOutputTypeConfigurationWithTwoInputTransformation()", "class_method_signature": "StreamGraphGeneratorTest.testOutputTypeConfigurationWithTwoInputTransformation()", "testcase": true, "constructor": false, "invocations": ["getExecutionEnvironment", "fromElements", "fromElements", "connect", "transform", "addSink", "getStreamGraph", "assertEquals", "getTypeInformation"]}, "focal_class": {"identifier": "StreamGraphGenerator", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(StreamGraphGenerator.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(StreamGraphGenerator.class)", "var_name": "LOG"}, {"original_string": "private StreamGraph streamGraph;", "modifier": "private", "type": "StreamGraph", "declarator": "streamGraph", "var_name": "streamGraph"}, {"original_string": "private final StreamExecutionEnvironment env;", "modifier": "private final", "type": "StreamExecutionEnvironment", "declarator": "env", "var_name": "env"}, {"original_string": "protected static Integer iterationIdCounter = 0;", "modifier": "protected static", "type": "Integer", "declarator": "iterationIdCounter = 0", "var_name": "iterationIdCounter"}, {"original_string": "private Map<StreamTransformation<?>, Collection<Integer>> alreadyTransformed;", "modifier": "private", "type": "Map<StreamTransformation<?>, Collection<Integer>>", "declarator": "alreadyTransformed", "var_name": "alreadyTransformed"}], "methods": [{"identifier": "getNewIterationNodeId", "parameters": "()", "modifiers": "public static", "return": "int", "signature": "int getNewIterationNodeId()", "full_signature": "public static int getNewIterationNodeId()", "class_method_signature": "StreamGraphGenerator.getNewIterationNodeId()", "testcase": false, "constructor": false}, {"identifier": "StreamGraphGenerator", "parameters": "(StreamExecutionEnvironment env)", "modifiers": "private", "return": "", "signature": " StreamGraphGenerator(StreamExecutionEnvironment env)", "full_signature": "private  StreamGraphGenerator(StreamExecutionEnvironment env)", "class_method_signature": "StreamGraphGenerator.StreamGraphGenerator(StreamExecutionEnvironment env)", "testcase": false, "constructor": true}, {"identifier": "generate", "parameters": "(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations)", "modifiers": "public static", "return": "StreamGraph", "signature": "StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations)", "full_signature": "public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations)", "class_method_signature": "StreamGraphGenerator.generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations)", "testcase": false, "constructor": false}, {"identifier": "generateInternal", "parameters": "(List<StreamTransformation<?>> transformations)", "modifiers": "private", "return": "StreamGraph", "signature": "StreamGraph generateInternal(List<StreamTransformation<?>> transformations)", "full_signature": "private StreamGraph generateInternal(List<StreamTransformation<?>> transformations)", "class_method_signature": "StreamGraphGenerator.generateInternal(List<StreamTransformation<?>> transformations)", "testcase": false, "constructor": false}, {"identifier": "transform", "parameters": "(StreamTransformation<?> transform)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> transform(StreamTransformation<?> transform)", "full_signature": "private Collection<Integer> transform(StreamTransformation<?> transform)", "class_method_signature": "StreamGraphGenerator.transform(StreamTransformation<?> transform)", "testcase": false, "constructor": false}, {"identifier": "transformUnion", "parameters": "(UnionTransformation<T> union)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> transformUnion(UnionTransformation<T> union)", "full_signature": "private Collection<Integer> transformUnion(UnionTransformation<T> union)", "class_method_signature": "StreamGraphGenerator.transformUnion(UnionTransformation<T> union)", "testcase": false, "constructor": false}, {"identifier": "transformPartition", "parameters": "(PartitionTransformation<T> partition)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> transformPartition(PartitionTransformation<T> partition)", "full_signature": "private Collection<Integer> transformPartition(PartitionTransformation<T> partition)", "class_method_signature": "StreamGraphGenerator.transformPartition(PartitionTransformation<T> partition)", "testcase": false, "constructor": false}, {"identifier": "transformSplit", "parameters": "(SplitTransformation<T> split)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> transformSplit(SplitTransformation<T> split)", "full_signature": "private Collection<Integer> transformSplit(SplitTransformation<T> split)", "class_method_signature": "StreamGraphGenerator.transformSplit(SplitTransformation<T> split)", "testcase": false, "constructor": false}, {"identifier": "transformSelect", "parameters": "(SelectTransformation<T> select)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> transformSelect(SelectTransformation<T> select)", "full_signature": "private Collection<Integer> transformSelect(SelectTransformation<T> select)", "class_method_signature": "StreamGraphGenerator.transformSelect(SelectTransformation<T> select)", "testcase": false, "constructor": false}, {"identifier": "transformFeedback", "parameters": "(FeedbackTransformation<T> iterate)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate)", "full_signature": "private Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate)", "class_method_signature": "StreamGraphGenerator.transformFeedback(FeedbackTransformation<T> iterate)", "testcase": false, "constructor": false}, {"identifier": "transformCoFeedback", "parameters": "(CoFeedbackTransformation<F> coIterate)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate)", "full_signature": "private Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate)", "class_method_signature": "StreamGraphGenerator.transformCoFeedback(CoFeedbackTransformation<F> coIterate)", "testcase": false, "constructor": false}, {"identifier": "transformSource", "parameters": "(SourceTransformation<T> source)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> transformSource(SourceTransformation<T> source)", "full_signature": "private Collection<Integer> transformSource(SourceTransformation<T> source)", "class_method_signature": "StreamGraphGenerator.transformSource(SourceTransformation<T> source)", "testcase": false, "constructor": false}, {"identifier": "transformSink", "parameters": "(SinkTransformation<T> sink)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> transformSink(SinkTransformation<T> sink)", "full_signature": "private Collection<Integer> transformSink(SinkTransformation<T> sink)", "class_method_signature": "StreamGraphGenerator.transformSink(SinkTransformation<T> sink)", "testcase": false, "constructor": false}, {"identifier": "transformOnInputTransform", "parameters": "(OneInputTransformation<IN, OUT> transform)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform)", "full_signature": "private Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform)", "class_method_signature": "StreamGraphGenerator.transformOnInputTransform(OneInputTransformation<IN, OUT> transform)", "testcase": false, "constructor": false}, {"identifier": "transformTwoInputTransform", "parameters": "(TwoInputTransformation<IN1, IN2, OUT> transform)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform)", "full_signature": "private Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform)", "class_method_signature": "StreamGraphGenerator.transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform)", "testcase": false, "constructor": false}, {"identifier": "determineSlotSharingGroup", "parameters": "(String specifiedGroup, Collection<Integer> inputIds)", "modifiers": "private", "return": "String", "signature": "String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds)", "full_signature": "private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds)", "class_method_signature": "StreamGraphGenerator.determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds)", "testcase": false, "constructor": false}], "file": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java"}, "focal_method": {"identifier": "transform", "parameters": "(StreamTransformation<?> transform)", "modifiers": "private", "return": "Collection<Integer>", "body": "private Collection<Integer> transform(StreamTransformation<?> transform) {\n\n\t\tif (alreadyTransformed.containsKey(transform)) {\n\t\t\treturn alreadyTransformed.get(transform);\n\t\t}\n\n\t\tLOG.debug(\"Transforming \" + transform);\n\n\t\t// call at least once to trigger exceptions about MissingTypeInfo\n\t\ttransform.getOutputType();\n\n\t\tCollection<Integer> transformedIds;\n\t\tif (transform instanceof OneInputTransformation<?, ?>) {\n\t\t\ttransformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform);\n\t\t} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {\n\t\t\ttransformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform);\n\t\t} else if (transform instanceof SourceTransformation<?>) {\n\t\t\ttransformedIds = transformSource((SourceTransformation<?>) transform);\n\t\t} else if (transform instanceof SinkTransformation<?>) {\n\t\t\ttransformedIds = transformSink((SinkTransformation<?>) transform);\n\t\t} else if (transform instanceof UnionTransformation<?>) {\n\t\t\ttransformedIds = transformUnion((UnionTransformation<?>) transform);\n\t\t} else if (transform instanceof SplitTransformation<?>) {\n\t\t\ttransformedIds = transformSplit((SplitTransformation<?>) transform);\n\t\t} else if (transform instanceof SelectTransformation<?>) {\n\t\t\ttransformedIds = transformSelect((SelectTransformation<?>) transform);\n\t\t} else if (transform instanceof FeedbackTransformation<?>) {\n\t\t\ttransformedIds = transformFeedback((FeedbackTransformation<?>) transform);\n\t\t} else if (transform instanceof CoFeedbackTransformation<?>) {\n\t\t\ttransformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform);\n\t\t} else if (transform instanceof PartitionTransformation<?>) {\n\t\t\ttransformedIds = transformPartition((PartitionTransformation<?>) transform);\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Unknown transformation: \" + transform);\n\t\t}\n\n\t\t// need this check because the iterate transformation adds itself before\n\t\t// transforming the feedback edges\n\t\tif (!alreadyTransformed.containsKey(transform)) {\n\t\t\talreadyTransformed.put(transform, transformedIds);\n\t\t}\n\n\t\tif (transform.getBufferTimeout() > 0) {\n\t\t\tstreamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout());\n\t\t}\n\t\tif (transform.getUid() != null) {\n\t\t\tstreamGraph.setTransformationId(transform.getId(), transform.getUid());\n\t\t}\n\n\t\treturn transformedIds;\n\t}", "signature": "Collection<Integer> transform(StreamTransformation<?> transform)", "full_signature": "private Collection<Integer> transform(StreamTransformation<?> transform)", "class_method_signature": "StreamGraphGenerator.transform(StreamTransformation<?> transform)", "testcase": false, "constructor": false, "invocations": ["containsKey", "get", "debug", "getOutputType", "transformOnInputTransform", "transformTwoInputTransform", "transformSource", "transformSink", "transformUnion", "transformSplit", "transformSelect", "transformFeedback", "transformCoFeedback", "transformPartition", "containsKey", "put", "getBufferTimeout", "setBufferTimeout", "getId", "getBufferTimeout", "getUid", "setTransformationId", "getId", "getUid"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}