{"test_class": {"identifier": "ParamProcessWorkerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Mock\n    protected AccountManager accountManager;", "modifier": "@Mock\n    protected", "type": "AccountManager", "declarator": "accountManager", "var_name": "accountManager"}, {"original_string": "protected ParamProcessWorker paramProcessWorker;", "modifier": "protected", "type": "ParamProcessWorker", "declarator": "paramProcessWorker", "var_name": "paramProcessWorker"}], "file": "server/src/test/java/com/cloud/api/dispatch/ParamProcessWorkerTest.java"}, "test_case": {"identifier": "processParameters", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void processParameters() {\n        final HashMap<String, String> params = new HashMap<String, String>();\n        params.put(\"strparam1\", \"foo\");\n        params.put(\"intparam1\", \"100\");\n        params.put(\"boolparam1\", \"true\");\n        params.put(\"doubleparam1\", \"11.89\");\n        final TestCmd cmd = new TestCmd();\n        paramProcessWorker.processParameters(cmd, params);\n        Assert.assertEquals(\"foo\", cmd.strparam1);\n        Assert.assertEquals(100, cmd.intparam1);\n        Assert.assertTrue(Double.compare(cmd.doubleparam1, 11.89) == 0);\n    }", "signature": "void processParameters()", "full_signature": "@Test public void processParameters()", "class_method_signature": "ParamProcessWorkerTest.processParameters()", "testcase": true, "constructor": false, "invocations": ["put", "put", "put", "put", "processParameters", "assertEquals", "assertEquals", "assertTrue", "compare"]}, "focal_class": {"identifier": "ParamProcessWorker", "superclass": "", "interfaces": "implements DispatchWorker", "fields": [{"original_string": "private static final Logger s_logger = LoggerFactory.getLogger(ParamProcessWorker.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "s_logger = LoggerFactory.getLogger(ParamProcessWorker.class.getName())", "var_name": "s_logger"}, {"original_string": "public final DateFormat inputFormat = new SimpleDateFormat(\"yyyy-MM-dd\");", "modifier": "public final", "type": "DateFormat", "declarator": "inputFormat = new SimpleDateFormat(\"yyyy-MM-dd\")", "var_name": "inputFormat"}, {"original_string": "public final DateFormat newInputFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");", "modifier": "public final", "type": "DateFormat", "declarator": "newInputFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")", "var_name": "newInputFormat"}, {"original_string": "@Inject\n    protected AccountManager _accountMgr;", "modifier": "@Inject\n    protected", "type": "AccountManager", "declarator": "_accountMgr", "var_name": "_accountMgr"}, {"original_string": "@Inject\n    protected EntityManager _entityMgr;", "modifier": "@Inject\n    protected", "type": "EntityManager", "declarator": "_entityMgr", "var_name": "_entityMgr"}, {"original_string": "List<SecurityChecker> _secChecker;", "modifier": "", "type": "List<SecurityChecker>", "declarator": "_secChecker", "var_name": "_secChecker"}], "methods": [{"identifier": "getSecChecker", "parameters": "()", "modifiers": "public", "return": "List<SecurityChecker>", "signature": "List<SecurityChecker> getSecChecker()", "full_signature": "public List<SecurityChecker> getSecChecker()", "class_method_signature": "ParamProcessWorker.getSecChecker()", "testcase": false, "constructor": false}, {"identifier": "setSecChecker", "parameters": "(List<SecurityChecker> secChecker)", "modifiers": "@Inject public", "return": "void", "signature": "void setSecChecker(List<SecurityChecker> secChecker)", "full_signature": "@Inject public void setSecChecker(List<SecurityChecker> secChecker)", "class_method_signature": "ParamProcessWorker.setSecChecker(List<SecurityChecker> secChecker)", "testcase": false, "constructor": false}, {"identifier": "handle", "parameters": "(final DispatchTask task)", "modifiers": "@Override public", "return": "void", "signature": "void handle(final DispatchTask task)", "full_signature": "@Override public void handle(final DispatchTask task)", "class_method_signature": "ParamProcessWorker.handle(final DispatchTask task)", "testcase": false, "constructor": false}, {"identifier": "processParameters", "parameters": "(final BaseCmd cmd, final Map params)", "modifiers": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) public", "return": "void", "signature": "void processParameters(final BaseCmd cmd, final Map params)", "full_signature": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) public void processParameters(final BaseCmd cmd, final Map params)", "class_method_signature": "ParamProcessWorker.processParameters(final BaseCmd cmd, final Map params)", "testcase": false, "constructor": false}, {"identifier": "doAccessChecks", "parameters": "(BaseCmd cmd, Map<Object, AccessType> entitiesToAccess)", "modifiers": "private", "return": "void", "signature": "void doAccessChecks(BaseCmd cmd, Map<Object, AccessType> entitiesToAccess)", "full_signature": "private void doAccessChecks(BaseCmd cmd, Map<Object, AccessType> entitiesToAccess)", "class_method_signature": "ParamProcessWorker.doAccessChecks(BaseCmd cmd, Map<Object, AccessType> entitiesToAccess)", "testcase": false, "constructor": false}, {"identifier": "setFieldValue", "parameters": "(final Field field, final BaseCmd cmdObj, final Object paramObj, final Parameter annotation)", "modifiers": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) private", "return": "void", "signature": "void setFieldValue(final Field field, final BaseCmd cmdObj, final Object paramObj, final Parameter annotation)", "full_signature": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) private void setFieldValue(final Field field, final BaseCmd cmdObj, final Object paramObj, final Parameter annotation)", "class_method_signature": "ParamProcessWorker.setFieldValue(final Field field, final BaseCmd cmdObj, final Object paramObj, final Parameter annotation)", "testcase": false, "constructor": false}, {"identifier": "isObjInNewDateFormat", "parameters": "(final String string)", "modifiers": "private", "return": "boolean", "signature": "boolean isObjInNewDateFormat(final String string)", "full_signature": "private boolean isObjInNewDateFormat(final String string)", "class_method_signature": "ParamProcessWorker.isObjInNewDateFormat(final String string)", "testcase": false, "constructor": false}, {"identifier": "messageDate", "parameters": "(final Date date, final int hourOfDay, final int minute, final int second)", "modifiers": "private", "return": "Date", "signature": "Date messageDate(final Date date, final int hourOfDay, final int minute, final int second)", "full_signature": "private Date messageDate(final Date date, final int hourOfDay, final int minute, final int second)", "class_method_signature": "ParamProcessWorker.messageDate(final Date date, final int hourOfDay, final int minute, final int second)", "testcase": false, "constructor": false}, {"identifier": "translateUuidToInternalId", "parameters": "(final String uuid, final Parameter annotation)", "modifiers": "private", "return": "Long", "signature": "Long translateUuidToInternalId(final String uuid, final Parameter annotation)", "full_signature": "private Long translateUuidToInternalId(final String uuid, final Parameter annotation)", "class_method_signature": "ParamProcessWorker.translateUuidToInternalId(final String uuid, final Parameter annotation)", "testcase": false, "constructor": false}], "file": "server/src/main/java/com/cloud/api/dispatch/ParamProcessWorker.java"}, "focal_method": {"identifier": "processParameters", "parameters": "(final BaseCmd cmd, final Map params)", "modifiers": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) public", "return": "void", "body": "@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public void processParameters(final BaseCmd cmd, final Map params) {\n        final Map<Object, AccessType> entitiesToAccess = new HashMap<Object, AccessType>();\n\n        final List<Field> cmdFields = cmd.getParamFields();\n\n        for (final Field field : cmdFields) {\n            final Parameter parameterAnnotation = field.getAnnotation(Parameter.class);\n            final Object paramObj = params.get(parameterAnnotation.name());\n            if (paramObj == null) {\n                if (parameterAnnotation.required()) {\n                    throw new ServerApiException(ApiErrorCode.PARAM_ERROR, \"Unable to execute API command \" +\n                            cmd.getCommandName().substring(0, cmd.getCommandName().length() - 8) +\n                            \" due to missing parameter \" + parameterAnnotation.name());\n                }\n                continue;\n            }\n\n            // marshall the parameter into the correct type and set the field value\n            try {\n                setFieldValue(field, cmd, paramObj, parameterAnnotation);\n            } catch (final IllegalArgumentException argEx) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Unable to execute API command \" + cmd.getCommandName() + \" due to invalid value \" + paramObj + \" for parameter \" +\n                            parameterAnnotation.name());\n                }\n                throw new ServerApiException(ApiErrorCode.PARAM_ERROR, \"Unable to execute API command \" +\n                        cmd.getCommandName().substring(0, cmd.getCommandName().length() - 8) + \" due to invalid value \" + paramObj + \" for parameter \" +\n                        parameterAnnotation.name());\n            } catch (final ParseException parseEx) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Invalid date parameter \" + paramObj + \" passed to command \" + cmd.getCommandName().substring(0, cmd.getCommandName().length() - 8));\n                }\n                throw new ServerApiException(ApiErrorCode.PARAM_ERROR, \"Unable to parse date \" + paramObj + \" for command \" +\n                        cmd.getCommandName().substring(0, cmd.getCommandName().length() - 8) + \", please pass dates in the format mentioned in the api documentation\");\n            } catch (final InvalidParameterValueException invEx) {\n                throw new ServerApiException(ApiErrorCode.PARAM_ERROR, \"Unable to execute API command \" +\n                        cmd.getCommandName().substring(0, cmd.getCommandName().length() - 8) + \" due to invalid value. \" + invEx.getMessage());\n            } catch (final CloudRuntimeException cloudEx) {\n                s_logger.error(\"CloudRuntimeException\", cloudEx);\n                // FIXME: Better error message? This only happens if the API command is not executable, which typically\n                //means\n                // there was\n                // and IllegalAccessException setting one of the parameters.\n                throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, \"Internal error executing API command \" +\n                        cmd.getCommandName().substring(0, cmd.getCommandName().length() - 8));\n            }\n\n            //check access on the resource this field points to\n            try {\n                final ACL checkAccess = field.getAnnotation(ACL.class);\n                final CommandType fieldType = parameterAnnotation.type();\n\n                if (checkAccess != null) {\n                    // Verify that caller can perform actions in behalf of vm\n                    // owner acumulate all Controlled Entities together.\n                    // parse the array of resource types and in case of map\n                    // check access on key or value or both as specified in @acl\n                    // implement external dao for classes that need findByName\n                    // for maps, specify access to be checkd on key or value.\n                    // Find the controlled entity DBid by uuid\n\n                    if (parameterAnnotation.entityType() != null && parameterAnnotation.entityType().length > 0\n                            && parameterAnnotation.entityType()[0].getAnnotation(EntityReference.class) != null) {\n                        final Class<?>[] entityList = parameterAnnotation.entityType()[0].getAnnotation(EntityReference.class).value();\n\n                        // Check if the parameter type is a single\n                        // Id or list of id's/name's\n                        switch (fieldType) {\n                        case LIST:\n                            final CommandType listType = parameterAnnotation.collectionType();\n                            switch (listType) {\n                            case LONG:\n                            case UUID:\n                                final List<Long> listParam = (List<Long>) field.get(cmd);\n                                for (final Long entityId : listParam) {\n                                    for (final Class entity : entityList) {\n                                        final Object entityObj = _entityMgr.findById(entity, entityId);\n                                        if(entityObj != null){\n                                            entitiesToAccess.put(entityObj, checkAccess.accessType());\n                                            break;\n                                        }\n                                    }\n                                }\n                                break;\n                                /*\n                                 * case STRING: List<String> listParam = new\n                                 * ArrayList<String>(); listParam =\n                                 * (List)field.get(cmd); for(String entityName:\n                                 * listParam){ ControlledEntity entityObj =\n                                 * (ControlledEntity )daoClassInstance(entityId);\n                                 * entitiesToAccess.add(entityObj); } break;\n                                 */\n                            default:\n                                break;\n                            }\n                            break;\n                        case LONG:\n                        case UUID:\n                            for (final Class entity : entityList) {\n                                final Object entityObj = _entityMgr.findById(entity, (Long) field.get(cmd));\n                                if(entityObj != null){\n                                    entitiesToAccess.put(entityObj, checkAccess.accessType());\n                                    break;\n                                }\n                            }\n                            break;\n                        default:\n                            break;\n                        }\n                    }\n                }\n\n            } catch (final IllegalArgumentException e) {\n                s_logger.error(\"Error initializing command \" + cmd.getCommandName() + \", field \" + field.getName() + \" is not accessible.\");\n                throw new CloudRuntimeException(\"Internal error initializing parameters for command \" + cmd.getCommandName() + \" [field \" + field.getName() +\n                        \" is not accessible]\");\n            } catch (final IllegalAccessException e) {\n                s_logger.error(\"Error initializing command \" + cmd.getCommandName() + \", field \" + field.getName() + \" is not accessible.\");\n                throw new CloudRuntimeException(\"Internal error initializing parameters for command \" + cmd.getCommandName() + \" [field \" + field.getName() +\n                        \" is not accessible]\");\n            }\n\n        }\n\n        doAccessChecks(cmd, entitiesToAccess);\n    }", "signature": "void processParameters(final BaseCmd cmd, final Map params)", "full_signature": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) public void processParameters(final BaseCmd cmd, final Map params)", "class_method_signature": "ParamProcessWorker.processParameters(final BaseCmd cmd, final Map params)", "testcase": false, "constructor": false, "invocations": ["getParamFields", "getAnnotation", "get", "name", "required", "substring", "getCommandName", "length", "getCommandName", "name", "setFieldValue", "isDebugEnabled", "debug", "getCommandName", "name", "substring", "getCommandName", "length", "getCommandName", "name", "isDebugEnabled", "debug", "substring", "getCommandName", "length", "getCommandName", "substring", "getCommandName", "length", "getCommandName", "substring", "getCommandName", "length", "getCommandName", "getMessage", "error", "substring", "getCommandName", "length", "getCommandName", "getAnnotation", "type", "entityType", "entityType", "getAnnotation", "entityType", "value", "getAnnotation", "entityType", "collectionType", "get", "findById", "put", "accessType", "findById", "get", "put", "accessType", "error", "getCommandName", "getName", "getCommandName", "getName", "error", "getCommandName", "getName", "getCommandName", "getName", "doAccessChecks"]}, "repository": {"repo_id": 49943894, "url": "https://github.com/MissionCriticalCloudOldRepos/cosmic-core", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 9, "size": 18165, "license": "licensed"}}