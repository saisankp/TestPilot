{"test_class": {"identifier": "WaitForSeProcessingTest", "superclass": "extends CoreBaseTest", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(WaitForSeProcessingTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(WaitForSeProcessingTest.class)", "var_name": "logger"}, {"original_string": "final String PLUGIN_NAME = \"WaitForSeProcessingTestP\";", "modifier": "final", "type": "String", "declarator": "PLUGIN_NAME = \"WaitForSeProcessingTestP\"", "var_name": "PLUGIN_NAME"}, {"original_string": "final String READER_NAME = \"WaitForSeProcessingTest\";", "modifier": "final", "type": "String", "declarator": "READER_NAME = \"WaitForSeProcessingTest\"", "var_name": "READER_NAME"}, {"original_string": "final ExecutorService executorService = Executors.newSingleThreadExecutor();", "modifier": "final", "type": "ExecutorService", "declarator": "executorService = Executors.newSingleThreadExecutor()", "var_name": "executorService"}, {"original_string": "BlankSmartPresenceTheadedReader r;", "modifier": "", "type": "BlankSmartPresenceTheadedReader", "declarator": "r", "var_name": "r"}, {"original_string": "WaitForSeProcessing waitForSeProcessing;", "modifier": "", "type": "WaitForSeProcessing", "declarator": "waitForSeProcessing", "var_name": "waitForSeProcessing"}], "file": "java/component/keyple-core/src/test/java/org/eclipse/keyple/core/seproxy/plugin/reader/WaitForSeProcessingTest.java"}, "test_case": {"identifier": "waitForProcessed_processed", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void waitForProcessed_processed() throws Exception {\n    /*\n     * ------------ input polling mode is CONTINUE SE has been processed within timeout\n     */\n\n    doReturn(ObservableReader.PollingMode.REPEATING).when(r).getPollingMode();\n    doReturn(false).when(r).waitForCardAbsentNative();\n\n    /* test */\n    waitForSeProcessing.onActivate();\n    waitForSeProcessing.onEvent(AbstractObservableLocalReader.InternalEvent.SE_PROCESSED);\n\n    /* Assert */\n    // Assert.assertEquals(WAIT_FOR_START_DETECTION, r.getCurrentState().getMonitoringState());\n    verify(r, times(1)).switchState(WAIT_FOR_SE_REMOVAL);\n  }", "signature": "void waitForProcessed_processed()", "full_signature": "@Test public void waitForProcessed_processed()", "class_method_signature": "WaitForSeProcessingTest.waitForProcessed_processed()", "testcase": true, "constructor": false, "invocations": ["getPollingMode", "when", "doReturn", "waitForCardAbsentNative", "when", "doReturn", "onActivate", "onEvent", "switchState", "verify", "times"]}, "focal_class": {"identifier": "WaitForSeProcessing", "superclass": "extends AbstractObservableState", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(WaitForSeProcessing.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(WaitForSeProcessing.class)", "var_name": "logger"}], "methods": [{"identifier": "WaitForSeProcessing", "parameters": "(AbstractObservableLocalReader reader)", "modifiers": "public", "return": "", "signature": " WaitForSeProcessing(AbstractObservableLocalReader reader)", "full_signature": "public  WaitForSeProcessing(AbstractObservableLocalReader reader)", "class_method_signature": "WaitForSeProcessing.WaitForSeProcessing(AbstractObservableLocalReader reader)", "testcase": false, "constructor": true}, {"identifier": "WaitForSeProcessing", "parameters": "(\n      AbstractObservableLocalReader reader,\n      AbstractMonitoringJob monitoringJob,\n      ExecutorService executorService)", "modifiers": "public", "return": "", "signature": " WaitForSeProcessing(\n      AbstractObservableLocalReader reader,\n      AbstractMonitoringJob monitoringJob,\n      ExecutorService executorService)", "full_signature": "public  WaitForSeProcessing(\n      AbstractObservableLocalReader reader,\n      AbstractMonitoringJob monitoringJob,\n      ExecutorService executorService)", "class_method_signature": "WaitForSeProcessing.WaitForSeProcessing(\n      AbstractObservableLocalReader reader,\n      AbstractMonitoringJob monitoringJob,\n      ExecutorService executorService)", "testcase": false, "constructor": true}, {"identifier": "onEvent", "parameters": "(AbstractObservableLocalReader.InternalEvent event)", "modifiers": "@Override public", "return": "void", "signature": "void onEvent(AbstractObservableLocalReader.InternalEvent event)", "full_signature": "@Override public void onEvent(AbstractObservableLocalReader.InternalEvent event)", "class_method_signature": "WaitForSeProcessing.onEvent(AbstractObservableLocalReader.InternalEvent event)", "testcase": false, "constructor": false}], "file": "java/component/keyple-core/src/main/java/org/eclipse/keyple/core/seproxy/plugin/reader/WaitForSeProcessing.java"}, "focal_method": {"identifier": "onEvent", "parameters": "(AbstractObservableLocalReader.InternalEvent event)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void onEvent(AbstractObservableLocalReader.InternalEvent event) {\n    if (logger.isTraceEnabled()) {\n      logger.trace(\n          \"[{}] onEvent => Event {} received in currentState {}\", reader.getName(), event, state);\n    }\n    /*\n     * Process InternalEvent\n     */\n    switch (event) {\n      case SE_PROCESSED:\n        if (this.reader.getPollingMode() == ObservableReader.PollingMode.REPEATING) {\n          switchState(MonitoringState.WAIT_FOR_SE_REMOVAL);\n        } else {\n          // We close the channels now and notify the application of\n          // the SE_REMOVED event.\n          this.reader.processSeRemoved();\n          switchState(MonitoringState.WAIT_FOR_START_DETECTION);\n        }\n        break;\n\n      case SE_REMOVED:\n        // the SE has been removed, we close all channels and return to\n        // the currentState of waiting\n        // for insertion\n        // We notify the application of the SE_REMOVED event.\n        reader.processSeRemoved();\n        if (reader.getPollingMode() == ObservableReader.PollingMode.REPEATING) {\n          switchState(MonitoringState.WAIT_FOR_SE_INSERTION);\n        } else {\n          switchState(MonitoringState.WAIT_FOR_START_DETECTION);\n        }\n        break;\n\n      case STOP_DETECT:\n        reader.processSeRemoved();\n        switchState(MonitoringState.WAIT_FOR_START_DETECTION);\n        break;\n\n      default:\n        logger.warn(\n            \"[{}] Ignore =>  Event {} received in currentState {}\", reader.getName(), event, state);\n        break;\n    }\n  }", "signature": "void onEvent(AbstractObservableLocalReader.InternalEvent event)", "full_signature": "@Override public void onEvent(AbstractObservableLocalReader.InternalEvent event)", "class_method_signature": "WaitForSeProcessing.onEvent(AbstractObservableLocalReader.InternalEvent event)", "testcase": false, "constructor": false, "invocations": ["isTraceEnabled", "trace", "getName", "getPollingMode", "switchState", "processSeRemoved", "switchState", "processSeRemoved", "getPollingMode", "switchState", "switchState", "processSeRemoved", "switchState", "warn", "getName"]}, "repository": {"repo_id": 156416177, "url": "https://github.com/eclipse/keyple-java", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 8, "size": 10325, "license": "licensed"}}