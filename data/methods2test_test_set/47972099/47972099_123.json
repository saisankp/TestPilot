{"test_class": {"identifier": "DelimitedInputFormatTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final DelimitedInputFormat<String> format = new MyTextInputFormat();", "modifier": "private final", "type": "DelimitedInputFormat<String>", "declarator": "format = new MyTextInputFormat()", "var_name": "format"}], "file": "flink-core/src/test/java/org/apache/flink/api/common/io/DelimitedInputFormatTest.java"}, "test_case": {"identifier": "testOpen", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testOpen() throws IOException {\n\t\tfinal String myString = \"my mocked line 1\\nmy mocked line 2\\n\";\n\t\tfinal FileInputSplit split = createTempFile(myString);\n\t\t\n\t\tint bufferSize = 5;\n\t\tformat.setBufferSize(bufferSize);\n\t\tformat.open(split);\n\t\tassertEquals(0, format.splitStart);\n\t\tassertEquals(myString.length() - bufferSize, format.splitLength);\n\t\tassertEquals(bufferSize, format.getBufferSize());\n\t}", "signature": "void testOpen()", "full_signature": "@Test public void testOpen()", "class_method_signature": "DelimitedInputFormatTest.testOpen()", "testcase": true, "constructor": false, "invocations": ["createTempFile", "setBufferSize", "open", "assertEquals", "assertEquals", "length", "assertEquals", "getBufferSize"]}, "focal_class": {"identifier": "DelimitedInputFormat", "superclass": "extends FileInputFormat<OT>", "interfaces": "", "fields": [{"original_string": "private static final long serialVersionUID = 1L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 1L", "var_name": "serialVersionUID"}, {"original_string": "private static final Logger LOG = LoggerFactory.getLogger(DelimitedInputFormat.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(DelimitedInputFormat.class)", "var_name": "LOG"}, {"original_string": "private static final int DEFAULT_READ_BUFFER_SIZE = 1024 * 1024;", "modifier": "private static final", "type": "int", "declarator": "DEFAULT_READ_BUFFER_SIZE = 1024 * 1024", "var_name": "DEFAULT_READ_BUFFER_SIZE"}, {"original_string": "private static final int NUM_SAMPLES_UNDEFINED = -1;", "modifier": "private static final", "type": "int", "declarator": "NUM_SAMPLES_UNDEFINED = -1", "var_name": "NUM_SAMPLES_UNDEFINED"}, {"original_string": "private static int DEFAULT_MAX_NUM_SAMPLES;", "modifier": "private static", "type": "int", "declarator": "DEFAULT_MAX_NUM_SAMPLES", "var_name": "DEFAULT_MAX_NUM_SAMPLES"}, {"original_string": "private static int DEFAULT_MIN_NUM_SAMPLES;", "modifier": "private static", "type": "int", "declarator": "DEFAULT_MIN_NUM_SAMPLES", "var_name": "DEFAULT_MIN_NUM_SAMPLES"}, {"original_string": "private static int MAX_SAMPLE_LEN;", "modifier": "private static", "type": "int", "declarator": "MAX_SAMPLE_LEN", "var_name": "MAX_SAMPLE_LEN"}, {"original_string": "private transient byte[] readBuffer;", "modifier": "private transient", "type": "byte[]", "declarator": "readBuffer", "var_name": "readBuffer"}, {"original_string": "private transient byte[] wrapBuffer;", "modifier": "private transient", "type": "byte[]", "declarator": "wrapBuffer", "var_name": "wrapBuffer"}, {"original_string": "private transient int readPos;", "modifier": "private transient", "type": "int", "declarator": "readPos", "var_name": "readPos"}, {"original_string": "private transient int limit;", "modifier": "private transient", "type": "int", "declarator": "limit", "var_name": "limit"}, {"original_string": "private transient byte[] currBuffer;", "modifier": "private transient", "type": "byte[]", "declarator": "currBuffer", "var_name": "currBuffer"}, {"original_string": "private transient int currOffset;", "modifier": "private transient", "type": "int", "declarator": "currOffset", "var_name": "currOffset"}, {"original_string": "private transient int currLen;", "modifier": "private transient", "type": "int", "declarator": "currLen", "var_name": "currLen"}, {"original_string": "private transient boolean overLimit;", "modifier": "private transient", "type": "boolean", "declarator": "overLimit", "var_name": "overLimit"}, {"original_string": "private transient boolean end;", "modifier": "private transient", "type": "boolean", "declarator": "end", "var_name": "end"}, {"original_string": "private byte[] delimiter = new byte[] {'\\n'};", "modifier": "private", "type": "byte[]", "declarator": "delimiter = new byte[] {'\\n'}", "var_name": "delimiter"}, {"original_string": "private int lineLengthLimit = Integer.MAX_VALUE;", "modifier": "private", "type": "int", "declarator": "lineLengthLimit = Integer.MAX_VALUE", "var_name": "lineLengthLimit"}, {"original_string": "private int bufferSize = -1;", "modifier": "private", "type": "int", "declarator": "bufferSize = -1", "var_name": "bufferSize"}, {"original_string": "private int numLineSamples = NUM_SAMPLES_UNDEFINED;", "modifier": "private", "type": "int", "declarator": "numLineSamples = NUM_SAMPLES_UNDEFINED", "var_name": "numLineSamples"}, {"original_string": "protected static final String RECORD_DELIMITER = \"delimited-format.delimiter\";", "modifier": "protected static final", "type": "String", "declarator": "RECORD_DELIMITER = \"delimited-format.delimiter\"", "var_name": "RECORD_DELIMITER"}, {"original_string": "private static final String NUM_STATISTICS_SAMPLES = \"delimited-format.numSamples\";", "modifier": "private static final", "type": "String", "declarator": "NUM_STATISTICS_SAMPLES = \"delimited-format.numSamples\"", "var_name": "NUM_STATISTICS_SAMPLES"}], "methods": [{"identifier": "loadGlobalConfigParams", "parameters": "()", "modifiers": "protected static", "return": "void", "signature": "void loadGlobalConfigParams()", "full_signature": "protected static void loadGlobalConfigParams()", "class_method_signature": "DelimitedInputFormat.loadGlobalConfigParams()", "testcase": false, "constructor": false}, {"identifier": "DelimitedInputFormat", "parameters": "()", "modifiers": "public", "return": "", "signature": " DelimitedInputFormat()", "full_signature": "public  DelimitedInputFormat()", "class_method_signature": "DelimitedInputFormat.DelimitedInputFormat()", "testcase": false, "constructor": true}, {"identifier": "DelimitedInputFormat", "parameters": "(Path filePath)", "modifiers": "protected", "return": "", "signature": " DelimitedInputFormat(Path filePath)", "full_signature": "protected  DelimitedInputFormat(Path filePath)", "class_method_signature": "DelimitedInputFormat.DelimitedInputFormat(Path filePath)", "testcase": false, "constructor": true}, {"identifier": "getDelimiter", "parameters": "()", "modifiers": "public", "return": "byte[]", "signature": "byte[] getDelimiter()", "full_signature": "public byte[] getDelimiter()", "class_method_signature": "DelimitedInputFormat.getDelimiter()", "testcase": false, "constructor": false}, {"identifier": "setDelimiter", "parameters": "(byte[] delimiter)", "modifiers": "public", "return": "void", "signature": "void setDelimiter(byte[] delimiter)", "full_signature": "public void setDelimiter(byte[] delimiter)", "class_method_signature": "DelimitedInputFormat.setDelimiter(byte[] delimiter)", "testcase": false, "constructor": false}, {"identifier": "setDelimiter", "parameters": "(char delimiter)", "modifiers": "public", "return": "void", "signature": "void setDelimiter(char delimiter)", "full_signature": "public void setDelimiter(char delimiter)", "class_method_signature": "DelimitedInputFormat.setDelimiter(char delimiter)", "testcase": false, "constructor": false}, {"identifier": "setDelimiter", "parameters": "(String delimiter)", "modifiers": "public", "return": "void", "signature": "void setDelimiter(String delimiter)", "full_signature": "public void setDelimiter(String delimiter)", "class_method_signature": "DelimitedInputFormat.setDelimiter(String delimiter)", "testcase": false, "constructor": false}, {"identifier": "getLineLengthLimit", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getLineLengthLimit()", "full_signature": "public int getLineLengthLimit()", "class_method_signature": "DelimitedInputFormat.getLineLengthLimit()", "testcase": false, "constructor": false}, {"identifier": "setLineLengthLimit", "parameters": "(int lineLengthLimit)", "modifiers": "public", "return": "void", "signature": "void setLineLengthLimit(int lineLengthLimit)", "full_signature": "public void setLineLengthLimit(int lineLengthLimit)", "class_method_signature": "DelimitedInputFormat.setLineLengthLimit(int lineLengthLimit)", "testcase": false, "constructor": false}, {"identifier": "getBufferSize", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getBufferSize()", "full_signature": "public int getBufferSize()", "class_method_signature": "DelimitedInputFormat.getBufferSize()", "testcase": false, "constructor": false}, {"identifier": "setBufferSize", "parameters": "(int bufferSize)", "modifiers": "public", "return": "void", "signature": "void setBufferSize(int bufferSize)", "full_signature": "public void setBufferSize(int bufferSize)", "class_method_signature": "DelimitedInputFormat.setBufferSize(int bufferSize)", "testcase": false, "constructor": false}, {"identifier": "getNumLineSamples", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getNumLineSamples()", "full_signature": "public int getNumLineSamples()", "class_method_signature": "DelimitedInputFormat.getNumLineSamples()", "testcase": false, "constructor": false}, {"identifier": "setNumLineSamples", "parameters": "(int numLineSamples)", "modifiers": "public", "return": "void", "signature": "void setNumLineSamples(int numLineSamples)", "full_signature": "public void setNumLineSamples(int numLineSamples)", "class_method_signature": "DelimitedInputFormat.setNumLineSamples(int numLineSamples)", "testcase": false, "constructor": false}, {"identifier": "readRecord", "parameters": "(OT reuse, byte[] bytes, int offset, int numBytes)", "modifiers": "public abstract", "return": "OT", "signature": "OT readRecord(OT reuse, byte[] bytes, int offset, int numBytes)", "full_signature": "public abstract OT readRecord(OT reuse, byte[] bytes, int offset, int numBytes)", "class_method_signature": "DelimitedInputFormat.readRecord(OT reuse, byte[] bytes, int offset, int numBytes)", "testcase": false, "constructor": false}, {"identifier": "configure", "parameters": "(Configuration parameters)", "modifiers": "@Override public", "return": "void", "signature": "void configure(Configuration parameters)", "full_signature": "@Override public void configure(Configuration parameters)", "class_method_signature": "DelimitedInputFormat.configure(Configuration parameters)", "testcase": false, "constructor": false}, {"identifier": "getStatistics", "parameters": "(BaseStatistics cachedStats)", "modifiers": "@Override public", "return": "FileBaseStatistics", "signature": "FileBaseStatistics getStatistics(BaseStatistics cachedStats)", "full_signature": "@Override public FileBaseStatistics getStatistics(BaseStatistics cachedStats)", "class_method_signature": "DelimitedInputFormat.getStatistics(BaseStatistics cachedStats)", "testcase": false, "constructor": false}, {"identifier": "open", "parameters": "(FileInputSplit split)", "modifiers": "@Override public", "return": "void", "signature": "void open(FileInputSplit split)", "full_signature": "@Override public void open(FileInputSplit split)", "class_method_signature": "DelimitedInputFormat.open(FileInputSplit split)", "testcase": false, "constructor": false}, {"identifier": "reachedEnd", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean reachedEnd()", "full_signature": "@Override public boolean reachedEnd()", "class_method_signature": "DelimitedInputFormat.reachedEnd()", "testcase": false, "constructor": false}, {"identifier": "nextRecord", "parameters": "(OT record)", "modifiers": "@Override public", "return": "OT", "signature": "OT nextRecord(OT record)", "full_signature": "@Override public OT nextRecord(OT record)", "class_method_signature": "DelimitedInputFormat.nextRecord(OT record)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "DelimitedInputFormat.close()", "testcase": false, "constructor": false}, {"identifier": "readLine", "parameters": "()", "modifiers": "protected final", "return": "boolean", "signature": "boolean readLine()", "full_signature": "protected final boolean readLine()", "class_method_signature": "DelimitedInputFormat.readLine()", "testcase": false, "constructor": false}, {"identifier": "setResult", "parameters": "(byte[] buffer, int offset, int len)", "modifiers": "private", "return": "void", "signature": "void setResult(byte[] buffer, int offset, int len)", "full_signature": "private void setResult(byte[] buffer, int offset, int len)", "class_method_signature": "DelimitedInputFormat.setResult(byte[] buffer, int offset, int len)", "testcase": false, "constructor": false}, {"identifier": "fillBuffer", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean fillBuffer()", "full_signature": "private boolean fillBuffer()", "class_method_signature": "DelimitedInputFormat.fillBuffer()", "testcase": false, "constructor": false}], "file": "flink-core/src/main/java/org/apache/flink/api/common/io/DelimitedInputFormat.java"}, "focal_method": {"identifier": "open", "parameters": "(FileInputSplit split)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void open(FileInputSplit split) throws IOException {\n\t\tsuper.open(split);\n\t\t\n\t\tthis.bufferSize = this.bufferSize <= 0 ? DEFAULT_READ_BUFFER_SIZE : this.bufferSize;\n\t\t\n\t\tif (this.readBuffer == null || this.readBuffer.length != this.bufferSize) {\n\t\t\tthis.readBuffer = new byte[this.bufferSize];\n\t\t}\n\t\tif (this.wrapBuffer == null || this.wrapBuffer.length < 256) {\n\t\t\tthis.wrapBuffer = new byte[256];\n\t\t}\n\n\t\tthis.readPos = 0;\n\t\tthis.limit = 0;\n\t\tthis.overLimit = false;\n\t\tthis.end = false;\n\n\t\tif (this.splitStart != 0) {\n\t\t\tthis.stream.seek(this.splitStart);\n\t\t\treadLine();\n\t\t\t\n\t\t\t// if the first partial record already pushes the stream over the limit of our split, then no\n\t\t\t// record starts within this split \n\t\t\tif (this.overLimit) {\n\t\t\t\tthis.end = true;\n\t\t\t}\n\t\t} else {\n\t\t\tfillBuffer();\n\t\t}\n\t}", "signature": "void open(FileInputSplit split)", "full_signature": "@Override public void open(FileInputSplit split)", "class_method_signature": "DelimitedInputFormat.open(FileInputSplit split)", "testcase": false, "constructor": false, "invocations": ["open", "seek", "readLine", "fillBuffer"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}