{"test_class": {"identifier": "ParallelSnapshotReaderTest", "superclass": "", "interfaces": "", "fields": [], "file": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/ParallelSnapshotReaderTest.java"}, "test_case": {"identifier": "pollReturnsOldIfNewReaderIsStopped", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void pollReturnsOldIfNewReaderIsStopped() throws InterruptedException {\n        BinlogReader mockOldBinlogReader = mock(BinlogReader.class);\n        SnapshotReader mockNewSnapshotReader = mock(SnapshotReader.class);\n        BinlogReader mockNewBinlogReader = mock(BinlogReader.class);\n\n        ParallelSnapshotReader parallelSnapshotReader = new ParallelSnapshotReader(mockOldBinlogReader, mockNewSnapshotReader, mockNewBinlogReader);\n\n        SourceRecord oldBinlogSourceRecord = mock(SourceRecord.class);\n        List<SourceRecord> oldBinlogRecords = new ArrayList<>();\n        oldBinlogRecords.add(oldBinlogSourceRecord);\n\n        when(mockOldBinlogReader.isRunning()).thenReturn(true);\n        when(mockOldBinlogReader.poll()).thenReturn(oldBinlogRecords);\n\n        // cheap way to have the new reader be stopped is to just not start it; so don't start the parallel reader\n\n        List<SourceRecord> parallelRecords = parallelSnapshotReader.poll();\n\n        Assert.assertEquals(1, parallelRecords.size());\n        Assert.assertTrue(parallelRecords.contains(oldBinlogSourceRecord));\n    }", "signature": "void pollReturnsOldIfNewReaderIsStopped()", "full_signature": "@Test public void pollReturnsOldIfNewReaderIsStopped()", "class_method_signature": "ParallelSnapshotReaderTest.pollReturnsOldIfNewReaderIsStopped()", "testcase": true, "constructor": false, "invocations": ["mock", "mock", "mock", "mock", "add", "thenReturn", "when", "isRunning", "thenReturn", "when", "poll", "poll", "assertEquals", "size", "assertTrue", "contains"]}, "focal_class": {"identifier": "ParallelSnapshotReader", "superclass": "", "interfaces": "implements Reader", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ParallelSnapshotReader.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ParallelSnapshotReader.class)", "var_name": "LOGGER"}, {"original_string": "private final BinlogReader oldTablesReader;", "modifier": "private final", "type": "BinlogReader", "declarator": "oldTablesReader", "var_name": "oldTablesReader"}, {"original_string": "private final BinlogReader newTablesBinlogReader;", "modifier": "private final", "type": "BinlogReader", "declarator": "newTablesBinlogReader", "var_name": "newTablesBinlogReader"}, {"original_string": "private final ChainedReader newTablesReader;", "modifier": "private final", "type": "ChainedReader", "declarator": "newTablesReader", "var_name": "newTablesReader"}, {"original_string": "private final AtomicBoolean running = new AtomicBoolean(false);", "modifier": "private final", "type": "AtomicBoolean", "declarator": "running = new AtomicBoolean(false)", "var_name": "running"}, {"original_string": "private final AtomicBoolean completed = new AtomicBoolean(false);", "modifier": "private final", "type": "AtomicBoolean", "declarator": "completed = new AtomicBoolean(false)", "var_name": "completed"}, {"original_string": "private final AtomicReference<Runnable> uponCompletion = new AtomicReference<>();", "modifier": "private final", "type": "AtomicReference<Runnable>", "declarator": "uponCompletion = new AtomicReference<>()", "var_name": "uponCompletion"}, {"original_string": "private final MySqlConnectorTask.ServerIdGenerator serverIdGenerator;", "modifier": "private final", "type": "MySqlConnectorTask.ServerIdGenerator", "declarator": "serverIdGenerator", "var_name": "serverIdGenerator"}], "methods": [{"identifier": "ParallelSnapshotReader", "parameters": "(Configuration config,\n                                  MySqlTaskContext noSnapshotContext,\n                                  Filters snapshotFilters,\n                                  MySqlConnectorTask.ServerIdGenerator serverIdGenerator)", "modifiers": "public", "return": "", "signature": " ParallelSnapshotReader(Configuration config,\n                                  MySqlTaskContext noSnapshotContext,\n                                  Filters snapshotFilters,\n                                  MySqlConnectorTask.ServerIdGenerator serverIdGenerator)", "full_signature": "public  ParallelSnapshotReader(Configuration config,\n                                  MySqlTaskContext noSnapshotContext,\n                                  Filters snapshotFilters,\n                                  MySqlConnectorTask.ServerIdGenerator serverIdGenerator)", "class_method_signature": "ParallelSnapshotReader.ParallelSnapshotReader(Configuration config,\n                                  MySqlTaskContext noSnapshotContext,\n                                  Filters snapshotFilters,\n                                  MySqlConnectorTask.ServerIdGenerator serverIdGenerator)", "testcase": false, "constructor": true}, {"identifier": "ParallelSnapshotReader", "parameters": "(BinlogReader oldTablesBinlogReader,\n                                                 SnapshotReader newTablesSnapshotReader,\n                                                 BinlogReader newTablesBinlogReader)", "modifiers": "", "return": "", "signature": " ParallelSnapshotReader(BinlogReader oldTablesBinlogReader,\n                                                 SnapshotReader newTablesSnapshotReader,\n                                                 BinlogReader newTablesBinlogReader)", "full_signature": "  ParallelSnapshotReader(BinlogReader oldTablesBinlogReader,\n                                                 SnapshotReader newTablesSnapshotReader,\n                                                 BinlogReader newTablesBinlogReader)", "class_method_signature": "ParallelSnapshotReader.ParallelSnapshotReader(BinlogReader oldTablesBinlogReader,\n                                                 SnapshotReader newTablesSnapshotReader,\n                                                 BinlogReader newTablesBinlogReader)", "testcase": false, "constructor": true}, {"identifier": "createReconcilingBinlogReader", "parameters": "(BinlogReader unifiedReader)", "modifiers": "public", "return": "ReconcilingBinlogReader", "signature": "ReconcilingBinlogReader createReconcilingBinlogReader(BinlogReader unifiedReader)", "full_signature": "public ReconcilingBinlogReader createReconcilingBinlogReader(BinlogReader unifiedReader)", "class_method_signature": "ParallelSnapshotReader.createReconcilingBinlogReader(BinlogReader unifiedReader)", "testcase": false, "constructor": false}, {"identifier": "uponCompletion", "parameters": "(Runnable handler)", "modifiers": "@Override public", "return": "void", "signature": "void uponCompletion(Runnable handler)", "full_signature": "@Override public void uponCompletion(Runnable handler)", "class_method_signature": "ParallelSnapshotReader.uponCompletion(Runnable handler)", "testcase": false, "constructor": false}, {"identifier": "initialize", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void initialize()", "full_signature": "@Override public void initialize()", "class_method_signature": "ParallelSnapshotReader.initialize()", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void start()", "full_signature": "@Override public void start()", "class_method_signature": "ParallelSnapshotReader.start()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void stop()", "full_signature": "@Override public void stop()", "class_method_signature": "ParallelSnapshotReader.stop()", "testcase": false, "constructor": false}, {"identifier": "state", "parameters": "()", "modifiers": "@Override public", "return": "State", "signature": "State state()", "full_signature": "@Override public State state()", "class_method_signature": "ParallelSnapshotReader.state()", "testcase": false, "constructor": false}, {"identifier": "poll", "parameters": "()", "modifiers": "@Override public", "return": "List<SourceRecord>", "signature": "List<SourceRecord> poll()", "full_signature": "@Override public List<SourceRecord> poll()", "class_method_signature": "ParallelSnapshotReader.poll()", "testcase": false, "constructor": false}, {"identifier": "completeSuccessfully", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void completeSuccessfully()", "full_signature": "private void completeSuccessfully()", "class_method_signature": "ParallelSnapshotReader.completeSuccessfully()", "testcase": false, "constructor": false}, {"identifier": "name", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String name()", "full_signature": "@Override public String name()", "class_method_signature": "ParallelSnapshotReader.name()", "testcase": false, "constructor": false}], "file": "debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/ParallelSnapshotReader.java"}, "focal_method": {"identifier": "poll", "parameters": "()", "modifiers": "@Override public", "return": "List<SourceRecord>", "body": "@Override\n    public List<SourceRecord> poll() throws InterruptedException {\n        // the old tables reader is a raw BinlogReader and will throw an exception of poll is called when it is not running.\n        List<SourceRecord> allRecords = oldTablesReader.isRunning() ? oldTablesReader.poll() : null;\n        List<SourceRecord> newTablesRecords = newTablesReader.poll();\n        if (newTablesRecords != null) {\n            if (allRecords == null) {\n                allRecords = newTablesRecords;\n            }\n            else {\n                allRecords.addAll(newTablesRecords);\n            }\n        }\n        else {\n            // else newTableRecords == null\n            if (allRecords == null) {\n                // if both readers have stopped, we need to stop.\n                completeSuccessfully();\n            }\n        }\n        return allRecords;\n    }", "signature": "List<SourceRecord> poll()", "full_signature": "@Override public List<SourceRecord> poll()", "class_method_signature": "ParallelSnapshotReader.poll()", "testcase": false, "constructor": false, "invocations": ["isRunning", "poll", "poll", "addAll", "completeSuccessfully"]}, "repository": {"repo_id": 50205233, "url": "https://github.com/debezium/debezium", "stars": 2686, "created": "1/22/2016 8:17:05 PM +00:00", "updates": "2020-01-27T20:48:54+00:00", "fork": "False", "license": "licensed"}}