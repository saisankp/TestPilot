{"test_class": {"identifier": "IndexUtilsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Inject\n    private IndexDao indexDao;", "modifier": "@Inject\n    private", "type": "IndexDao", "declarator": "indexDao", "var_name": "indexDao"}, {"original_string": "@Inject\n    private IndexUtils indexUtils;", "modifier": "@Inject\n    private", "type": "IndexUtils", "declarator": "indexUtils", "var_name": "indexUtils"}, {"original_string": "@Inject\n    private IdGeneratorService generatorService;", "modifier": "@Inject\n    private", "type": "IdGeneratorService", "declarator": "generatorService", "var_name": "generatorService"}, {"original_string": "private static final Logger log = LoggerFactory.getLogger(IndexUtilsTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(IndexUtilsTest.class)", "var_name": "log"}], "file": "index/src/test/java/io/blobkeeper/index/util/IndexUtilsTest.java"}, "test_case": {"identifier": "buildMerkleTree", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void buildMerkleTree() {\n        Partition partition = new Partition(42, 42);\n\n        assertTrue(indexDao.getListById(303277865741324292L).isEmpty());\n        assertNull(indexDao.getById(303277865741324292L, 1));\n\n        IndexElt expected1 = new IndexElt.IndexEltBuilder()\n                .id(303277865741324292L)\n                .type(1)\n                .partition(partition)\n                .offset(0L)\n                .length(128L)\n                .metadata(ImmutableMap.of(\"key\", \"value\"))\n                .crc(42L)\n                .build();\n\n        indexDao.add(expected1);\n\n        IndexElt expected2 = new IndexElt.IndexEltBuilder()\n                .id(303277865741324292L)\n                .type(2)\n                .partition(partition)\n                .offset(128L)\n                .length(128L)\n                .metadata(ImmutableMap.of(\"key\", \"value\"))\n                .crc(42L)\n                .build();\n\n        indexDao.add(expected2);\n\n        IndexElt expected3 = new IndexElt.IndexEltBuilder()\n                .id(303277865741324291L)\n                .type(0)\n                .partition(partition)\n                .offset(0L)\n                .length(128L)\n                .metadata(ImmutableMap.of(\"key\", \"value\"))\n                .crc(42L)\n                .build();\n\n        indexDao.add(expected3);\n\n        MerkleTree merkleTree = indexUtils.buildMerkleTree(partition);\n        assertEquals(merkleTree.getLeafNodes().size(), 2);\n\n        log.info(\"{}\", merkleTree.getLeafNodes().get(1).getHash());\n\n        assertEquals(merkleTree.getLeafNodes().get(1).getHash(), new byte[]{4, 53, 117, -100, -81, -64, 16, 4, 0, 0, 0, 1, 0, 0, 0, 2});\n    }", "signature": "void buildMerkleTree()", "full_signature": "@Test public void buildMerkleTree()", "class_method_signature": "IndexUtilsTest.buildMerkleTree()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "isEmpty", "getListById", "assertNull", "getById", "build", "crc", "metadata", "length", "offset", "partition", "type", "id", "of", "add", "build", "crc", "metadata", "length", "offset", "partition", "type", "id", "of", "add", "build", "crc", "metadata", "length", "offset", "partition", "type", "id", "of", "add", "buildMerkleTree", "assertEquals", "size", "getLeafNodes", "info", "getHash", "get", "getLeafNodes", "assertEquals", "getHash", "get", "getLeafNodes"]}, "focal_class": {"identifier": "IndexUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(IndexUtils.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(IndexUtils.class)", "var_name": "log"}, {"original_string": "@Inject\n    private IndexService indexService;", "modifier": "@Inject\n    private", "type": "IndexService", "declarator": "indexService", "var_name": "indexService"}], "methods": [{"identifier": "getOffset", "parameters": "(@NotNull List<IndexElt> elts)", "modifiers": "public", "return": "long", "signature": "long getOffset(@NotNull List<IndexElt> elts)", "full_signature": "public long getOffset(@NotNull List<IndexElt> elts)", "class_method_signature": "IndexUtils.getOffset(@NotNull List<IndexElt> elts)", "testcase": false, "constructor": false}, {"identifier": "buildMerkleTree", "parameters": "(@NotNull Partition partition)", "modifiers": "@NotNull public", "return": "MerkleTree", "signature": "MerkleTree buildMerkleTree(@NotNull Partition partition)", "full_signature": "@NotNull public MerkleTree buildMerkleTree(@NotNull Partition partition)", "class_method_signature": "IndexUtils.buildMerkleTree(@NotNull Partition partition)", "testcase": false, "constructor": false}], "file": "index/src/main/java/io/blobkeeper/index/util/IndexUtils.java"}, "focal_method": {"identifier": "buildMerkleTree", "parameters": "(@NotNull Partition partition)", "modifiers": "@NotNull public", "return": "MerkleTree", "body": "@NotNull\n    public MerkleTree buildMerkleTree(@NotNull Partition partition) {\n        List<IndexElt> elts = indexService.getListByPartition(partition);\n\n        SortedMap<Long, Block> blocks = elts.stream()\n                .collect(groupingBy(IndexElt::getId))\n                .values()\n                .stream()\n                .map(groupedElts -> new Block(groupedElts.get(0).getId(), groupedElts.stream()\n                        .map(IndexElt::toBlockElt)\n                        .sorted(new BlockEltComparator())\n                        .collect(ImmutableList.toImmutableList()))\n                ).collect(\n                        // TODO: replace with ImmutableSortedMap\n                        toMap(\n                                Block::getId,\n                                Function.identity(),\n                                Utils.throwingMerger(),\n                                TreeMap::new\n                        )\n                );\n\n        MerkleTree tree = new MerkleTree(indexService.getMinMaxRange(partition), MAX_LEVEL);\n        MerkleTree.fillTree(tree, blocks);\n        tree.calculate();\n\n        return tree;\n    }", "signature": "MerkleTree buildMerkleTree(@NotNull Partition partition)", "full_signature": "@NotNull public MerkleTree buildMerkleTree(@NotNull Partition partition)", "class_method_signature": "IndexUtils.buildMerkleTree(@NotNull Partition partition)", "testcase": false, "constructor": false, "invocations": ["getListByPartition", "collect", "map", "stream", "values", "collect", "stream", "groupingBy", "getId", "get", "collect", "sorted", "map", "stream", "toImmutableList", "toMap", "identity", "throwingMerger", "getMinMaxRange", "fillTree", "calculate"]}, "repository": {"repo_id": 43258821, "url": "https://github.com/sherman/blobkeeper", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 20, "size": 417, "license": "licensed"}}