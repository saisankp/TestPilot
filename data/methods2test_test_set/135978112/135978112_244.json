{"test_class": {"identifier": "BufferPoolTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final MockTime time = new MockTime();", "modifier": "private final", "type": "MockTime", "declarator": "time = new MockTime()", "var_name": "time"}, {"original_string": "private final SystemTime systemTime = new SystemTime();", "modifier": "private final", "type": "SystemTime", "declarator": "systemTime = new SystemTime()", "var_name": "systemTime"}, {"original_string": "private final Metrics metrics = new Metrics(time);", "modifier": "private final", "type": "Metrics", "declarator": "metrics = new Metrics(time)", "var_name": "metrics"}, {"original_string": "private final long maxBlockTimeMs = 2000;", "modifier": "private final", "type": "long", "declarator": "maxBlockTimeMs = 2000", "var_name": "maxBlockTimeMs"}, {"original_string": "private final String metricGroup = \"TestMetrics\";", "modifier": "private final", "type": "String", "declarator": "metricGroup = \"TestMetrics\"", "var_name": "metricGroup"}], "file": "clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java"}, "test_case": {"identifier": "testBlockTimeout", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testBlockTimeout() throws Exception {\n        BufferPool pool = new BufferPool(10, 1, metrics, systemTime, metricGroup);\n        ByteBuffer buffer1 = pool.allocate(1, maxBlockTimeMs);\n        ByteBuffer buffer2 = pool.allocate(1, maxBlockTimeMs);\n        ByteBuffer buffer3 = pool.allocate(1, maxBlockTimeMs);\n        // First two buffers will be de-allocated within maxBlockTimeMs since the most recent de-allocation\n        delayedDeallocate(pool, buffer1, maxBlockTimeMs / 2);\n        delayedDeallocate(pool, buffer2, maxBlockTimeMs);\n        // The third buffer will be de-allocated after maxBlockTimeMs since the most recent de-allocation\n        delayedDeallocate(pool, buffer3, maxBlockTimeMs / 2 * 5);\n\n        long beginTimeMs = systemTime.milliseconds();\n        try {\n            pool.allocate(10, maxBlockTimeMs);\n            fail(\"The buffer allocated more memory than its maximum value 10\");\n        } catch (TimeoutException e) {\n            // this is good\n        }\n        long endTimeMs = systemTime.milliseconds();\n        assertTrue(\"Allocation should finish not much later than maxBlockTimeMs\", endTimeMs - beginTimeMs < maxBlockTimeMs + 1000);\n    }", "signature": "void testBlockTimeout()", "full_signature": "@Test public void testBlockTimeout()", "class_method_signature": "BufferPoolTest.testBlockTimeout()", "testcase": true, "constructor": false, "invocations": ["allocate", "allocate", "allocate", "delayedDeallocate", "delayedDeallocate", "delayedDeallocate", "milliseconds", "allocate", "fail", "milliseconds", "assertTrue"]}, "focal_class": {"identifier": "BufferPool", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final long totalMemory;", "modifier": "private final", "type": "long", "declarator": "totalMemory", "var_name": "totalMemory"}, {"original_string": "private final int poolableSize;", "modifier": "private final", "type": "int", "declarator": "poolableSize", "var_name": "poolableSize"}, {"original_string": "private final ReentrantLock lock;", "modifier": "private final", "type": "ReentrantLock", "declarator": "lock", "var_name": "lock"}, {"original_string": "private final Deque<ByteBuffer> free;", "modifier": "private final", "type": "Deque<ByteBuffer>", "declarator": "free", "var_name": "free"}, {"original_string": "private final Deque<Condition> waiters;", "modifier": "private final", "type": "Deque<Condition>", "declarator": "waiters", "var_name": "waiters"}, {"original_string": "private long availableMemory;", "modifier": "private", "type": "long", "declarator": "availableMemory", "var_name": "availableMemory"}, {"original_string": "private final Metrics metrics;", "modifier": "private final", "type": "Metrics", "declarator": "metrics", "var_name": "metrics"}, {"original_string": "private final Time time;", "modifier": "private final", "type": "Time", "declarator": "time", "var_name": "time"}, {"original_string": "private final Sensor waitTime;", "modifier": "private final", "type": "Sensor", "declarator": "waitTime", "var_name": "waitTime"}], "methods": [{"identifier": "BufferPool", "parameters": "(long memory, int poolableSize, Metrics metrics, Time time, String metricGrpName)", "modifiers": "public", "return": "", "signature": " BufferPool(long memory, int poolableSize, Metrics metrics, Time time, String metricGrpName)", "full_signature": "public  BufferPool(long memory, int poolableSize, Metrics metrics, Time time, String metricGrpName)", "class_method_signature": "BufferPool.BufferPool(long memory, int poolableSize, Metrics metrics, Time time, String metricGrpName)", "testcase": false, "constructor": true}, {"identifier": "allocate", "parameters": "(int size, long maxTimeToBlockMs)", "modifiers": "public", "return": "ByteBuffer", "signature": "ByteBuffer allocate(int size, long maxTimeToBlockMs)", "full_signature": "public ByteBuffer allocate(int size, long maxTimeToBlockMs)", "class_method_signature": "BufferPool.allocate(int size, long maxTimeToBlockMs)", "testcase": false, "constructor": false}, {"identifier": "freeUp", "parameters": "(int size)", "modifiers": "private", "return": "void", "signature": "void freeUp(int size)", "full_signature": "private void freeUp(int size)", "class_method_signature": "BufferPool.freeUp(int size)", "testcase": false, "constructor": false}, {"identifier": "deallocate", "parameters": "(ByteBuffer buffer, int size)", "modifiers": "public", "return": "void", "signature": "void deallocate(ByteBuffer buffer, int size)", "full_signature": "public void deallocate(ByteBuffer buffer, int size)", "class_method_signature": "BufferPool.deallocate(ByteBuffer buffer, int size)", "testcase": false, "constructor": false}, {"identifier": "deallocate", "parameters": "(ByteBuffer buffer)", "modifiers": "public", "return": "void", "signature": "void deallocate(ByteBuffer buffer)", "full_signature": "public void deallocate(ByteBuffer buffer)", "class_method_signature": "BufferPool.deallocate(ByteBuffer buffer)", "testcase": false, "constructor": false}, {"identifier": "availableMemory", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long availableMemory()", "full_signature": "public long availableMemory()", "class_method_signature": "BufferPool.availableMemory()", "testcase": false, "constructor": false}, {"identifier": "unallocatedMemory", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long unallocatedMemory()", "full_signature": "public long unallocatedMemory()", "class_method_signature": "BufferPool.unallocatedMemory()", "testcase": false, "constructor": false}, {"identifier": "queued", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int queued()", "full_signature": "public int queued()", "class_method_signature": "BufferPool.queued()", "testcase": false, "constructor": false}, {"identifier": "poolableSize", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int poolableSize()", "full_signature": "public int poolableSize()", "class_method_signature": "BufferPool.poolableSize()", "testcase": false, "constructor": false}, {"identifier": "totalMemory", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long totalMemory()", "full_signature": "public long totalMemory()", "class_method_signature": "BufferPool.totalMemory()", "testcase": false, "constructor": false}, {"identifier": "waiters", "parameters": "()", "modifiers": "", "return": "Deque<Condition>", "signature": "Deque<Condition> waiters()", "full_signature": " Deque<Condition> waiters()", "class_method_signature": "BufferPool.waiters()", "testcase": false, "constructor": false}], "file": "clients/src/main/java/org/apache/kafka/clients/producer/internals/BufferPool.java"}, "focal_method": {"identifier": "allocate", "parameters": "(int size, long maxTimeToBlockMs)", "modifiers": "public", "return": "ByteBuffer", "body": "public ByteBuffer allocate(int size, long maxTimeToBlockMs) throws InterruptedException {\n        if (size > this.totalMemory) {\n            throw new IllegalArgumentException(\"Attempt to allocate \" + size\n                + \" bytes, but there is a hard limit of \"\n                + this.totalMemory\n                + \" on memory allocations.\");\n        }\n\n        this.lock.lock();\n        try {\n            // check if we have a free buffer of the right size pooled\n            // \u6821\u9a8c\u662f\u5426\u6709\u5408\u9002\u7684\u5c0f\u7684\u7a7a\u95f2\u7684buffer\n            if (size == poolableSize && !this.free.isEmpty()) {\n                return this.free.pollFirst();\n            }\n\n            // now check if the request is immediately satisfiable with the\n            // memory on hand or if we need to block\n            // \u6821\u9a8c\u73b0\u5728\u7684\u5185\u5b58\u662f\u5426\u53ef\u4ee5\u7acb\u5373\u6ee1\u8db3\u8bf7\u6c42\uff0c\u6216\u8005\u662f\u5426\u9700\u8981\u963b\u585e\n            int freeListSize = this.free.size() * this.poolableSize;\n\n            // \u5982\u679c\u53ef\u7528\u5185\u5b58+freeList\u5927\u5c0f\u5927\u4e8e\u7533\u8bf7\u5927\u5c0f\n            if (this.availableMemory + freeListSize >= size) {\n                // we have enough unallocated or pooled memory to immediately\n                // satisfy the request\n                // \u6709\u8db3\u591f\u7684\u88ab\u91ca\u653e\u6216\u5b58\u653e\u5728\u6c60\u4e2d\u7684\u5185\u5b58\u6765\u7acb\u5373\u6ee1\u8db3\u8bf7\u6c42\n                freeUp(size);\n                this.availableMemory -= size;\n                lock.unlock();\n                return ByteBuffer.allocate(size);\n            } else {// \u73b0\u5728\u53ef\u7528\u7684\u5185\u5b58\u5927\u5c0f\u65e0\u6cd5\u6ee1\u8db3\n                // we are out of memory and will have to block\n                // \u9700\u8981\u7684\u5185\u5b58\u53ef\u80fd\u4f1a\u5bfc\u81f4\u6ea2\u51fa\uff0c\u6240\u4ee5\u9700\u8981\u963b\u585e\n                int accumulated = 0;\n                ByteBuffer buffer = null;\n\n                Condition moreMemory = this.lock.newCondition();\n                long remainingTimeToBlockNs = TimeUnit.MILLISECONDS.toNanos(maxTimeToBlockMs);\n                this.waiters.addLast(moreMemory);\n\n                // loop over and over until we have a buffer or have reserved\n                // enough memory to allocate one\n                // \u5faa\u73af\u7b49\u5f85\uff0c\u76f4\u5230\u83b7\u53d6\u5230\u7533\u8bf7\u5230\u8db3\u591f\u7684\u5185\u5b58\n                while (accumulated < size) {\n                    long startWaitNs = time.nanoseconds();\n                    long timeNs;\n                    boolean waitingTimeElapsed;\n                    try {\n                        // \u5f53\u524dcondition\u8fdb\u884c\u7b49\u5f85 remainingTimeToBlockNs \u6beb\u79d2\n                        waitingTimeElapsed = !moreMemory.await(remainingTimeToBlockNs, TimeUnit.NANOSECONDS);\n                    } catch (InterruptedException e) {\n                        this.waiters.remove(moreMemory);\n                        throw e;\n                    } finally {\n                        long endWaitNs = time.nanoseconds();\n                        timeNs = Math.max(0L, endWaitNs - startWaitNs);\n                        // \u7edf\u8ba1\u963b\u585e\u65f6\u95f4\n                        this.waitTime.record(timeNs, time.milliseconds());\n                    }\n\n                    // \u4ee3\u8868\u8d85\u65f6\u4e86\n                    if (waitingTimeElapsed) {\n                        this.waiters.remove(moreMemory);\n                        throw new TimeoutException(\"Failed to allocate memory within the configured max blocking time \" + maxTimeToBlockMs + \" ms.\");\n                    }\n\n                    // \u6ca1\u8d85\u65f6\uff0c\u5269\u4f59\u65f6\u95f4\u7b49\u4e8e\u81ea\u5df1\u51cf\u53bb\u8017\u65f6\n                    remainingTimeToBlockNs -= timeNs;\n                    // check if we can satisfy this request from the free list,\n                    // otherwise allocate memory\n                    // \u68c0\u67e5free list\u662f\u5426\u53ef\u4ee5\u6ee1\u8db3\u8bf7\u6c42\uff0c\u4e0d\u6ee1\u8db3\u5219\u7533\u8bf7\u5185\u5b58\n                    if (accumulated == 0 && size == this.poolableSize && !this.free.isEmpty()) {\n                        // just grab a buffer from the free list\n                        // \u548c\u524d\u9762\u662f\u4e00\u6837\u7684\uff0c\u4ecefree list\u4e2d\u53d6\u4e00\u4e2a\u51fa\u6765\n                        buffer = this.free.pollFirst();\n                        accumulated = size;\n                    } else {\n\n                        //todo: \u8d70\u5230\u8fd9\u91cc\u8bf4\u660e\u7533\u8bf7\u7684\u5927\u5c0f\u8981\u5927\u4e8epoolableSize\uff0c\u6216\u8005free\u4e3a\u7a7a\n                        // we'll need to allocate memory, but we may only get\n                        // part of what we need on this iteration\n                        // \u9700\u8981\u7533\u8bf7\u5185\u5b58\uff0c\u4f46\u662f\u5728\u8fd9\u4e2a\u5faa\u73af\u53ef\u80fd\u53ea\u80fd\u4ece\u4e2d\u83b7\u53d6\u9700\u8981\u5185\u5b58\u7684\u4e00\u90e8\u5206\uff0c\u4e5f\u5c31\u662f\u8bf4\u592a\u5927\u4e86\uff0c\u4f1a\u518d\u83b7\u53d6\u4e00\u6b21\n                        // size\uff1a\u8981\u7533\u8bf7\u7684\u5927\u5c0f\u3002\n                        freeUp(size - accumulated);\n\n                        int got = (int) Math.min(size - accumulated, this.availableMemory);\n                        this.availableMemory -= got;\n                        accumulated += got;\n                    }\n                }\n\n                // remove the condition for this thread to let the next thread\n                // in line start getting memory\n                Condition removed = this.waiters.removeFirst();\n                if (removed != moreMemory) {\n                    throw new IllegalStateException(\"Wrong condition: this shouldn't happen.\");\n                }\n\n                // signal any additional waiters if there is more memory left\n                // over for them\n                // \u901a\u77e5\u5176\u4ed6waiters\u53bb\u62ff\u5185\u5b58\n                if (this.availableMemory > 0 || !this.free.isEmpty()) {\n                    if (!this.waiters.isEmpty()) {\n                        this.waiters.peekFirst()\n                                    .signal();\n                    }\n                }\n\n                // unlock and return the buffer\n                lock.unlock();\n                if (buffer == null) {// buffer = null \u4ee3\u8868\u5185\u5b58\u65f6\u76f4\u63a5\u4ecefree\u4e2d\u8f6e\u8be2\u91ca\u653e\u7684\n                    return ByteBuffer.allocate(size);\n                } else {// buffer\u4e0d\u4e3a\u7a7a\uff0c\u662f\u76f4\u63a5\u590d\u7528free\u4e2d\u7684\u5185\u5b58\n                    return buffer;\n                }\n            }\n        } finally {\n            if (lock.isHeldByCurrentThread()) {\n                lock.unlock();\n            }\n        }\n    }", "signature": "ByteBuffer allocate(int size, long maxTimeToBlockMs)", "full_signature": "public ByteBuffer allocate(int size, long maxTimeToBlockMs)", "class_method_signature": "BufferPool.allocate(int size, long maxTimeToBlockMs)", "testcase": false, "constructor": false, "invocations": ["lock", "isEmpty", "pollFirst", "size", "freeUp", "unlock", "allocate", "newCondition", "toNanos", "addLast", "nanoseconds", "await", "remove", "nanoseconds", "max", "record", "milliseconds", "remove", "isEmpty", "pollFirst", "freeUp", "min", "removeFirst", "isEmpty", "isEmpty", "signal", "peekFirst", "unlock", "allocate", "isHeldByCurrentThread", "unlock"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}