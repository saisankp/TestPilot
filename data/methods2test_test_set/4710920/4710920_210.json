{"test_class": {"identifier": "MockInvokerTest", "superclass": "", "interfaces": "", "fields": [], "file": "dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/MockInvokerTest.java"}, "test_case": {"identifier": "testInvoke", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testInvoke() {\n        URL url = URL.valueOf(\"remote://1.2.3.4/\" + String.class.getName());\n        url = url.addParameter(MOCK_KEY, \"return \");\n        MockInvoker mockInvoker = new MockInvoker(url, String.class);\n\n        RpcInvocation invocation = new RpcInvocation();\n        invocation.setMethodName(\"getSomething\");\n        Assertions.assertEquals(new HashMap<>(),\n                mockInvoker.invoke(invocation).getObjectAttachments());\n    }", "signature": "void testInvoke()", "full_signature": "@Test public void testInvoke()", "class_method_signature": "MockInvokerTest.testInvoke()", "testcase": true, "constructor": false, "invocations": ["valueOf", "getName", "addParameter", "setMethodName", "assertEquals", "getObjectAttachments", "invoke"]}, "focal_class": {"identifier": "MockInvoker", "superclass": "", "interfaces": "implements Invoker<T>", "fields": [{"original_string": "private final static ProxyFactory PROXY_FACTORY = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();", "modifier": "private final static", "type": "ProxyFactory", "declarator": "PROXY_FACTORY = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension()", "var_name": "PROXY_FACTORY"}, {"original_string": "private final static Map<String, Invoker<?>> MOCK_MAP = new ConcurrentHashMap<String, Invoker<?>>();", "modifier": "private final static", "type": "Map<String, Invoker<?>>", "declarator": "MOCK_MAP = new ConcurrentHashMap<String, Invoker<?>>()", "var_name": "MOCK_MAP"}, {"original_string": "private final static Map<String, Throwable> THROWABLE_MAP = new ConcurrentHashMap<String, Throwable>();", "modifier": "private final static", "type": "Map<String, Throwable>", "declarator": "THROWABLE_MAP = new ConcurrentHashMap<String, Throwable>()", "var_name": "THROWABLE_MAP"}, {"original_string": "private final URL url;", "modifier": "private final", "type": "URL", "declarator": "url", "var_name": "url"}, {"original_string": "private final Class<T> type;", "modifier": "private final", "type": "Class<T>", "declarator": "type", "var_name": "type"}], "methods": [{"identifier": "MockInvoker", "parameters": "(URL url, Class<T> type)", "modifiers": "public", "return": "", "signature": " MockInvoker(URL url, Class<T> type)", "full_signature": "public  MockInvoker(URL url, Class<T> type)", "class_method_signature": "MockInvoker.MockInvoker(URL url, Class<T> type)", "testcase": false, "constructor": true}, {"identifier": "parseMockValue", "parameters": "(String mock)", "modifiers": "public static", "return": "Object", "signature": "Object parseMockValue(String mock)", "full_signature": "public static Object parseMockValue(String mock)", "class_method_signature": "MockInvoker.parseMockValue(String mock)", "testcase": false, "constructor": false}, {"identifier": "parseMockValue", "parameters": "(String mock, Type[] returnTypes)", "modifiers": "public static", "return": "Object", "signature": "Object parseMockValue(String mock, Type[] returnTypes)", "full_signature": "public static Object parseMockValue(String mock, Type[] returnTypes)", "class_method_signature": "MockInvoker.parseMockValue(String mock, Type[] returnTypes)", "testcase": false, "constructor": false}, {"identifier": "invoke", "parameters": "(Invocation invocation)", "modifiers": "@Override public", "return": "Result", "signature": "Result invoke(Invocation invocation)", "full_signature": "@Override public Result invoke(Invocation invocation)", "class_method_signature": "MockInvoker.invoke(Invocation invocation)", "testcase": false, "constructor": false}, {"identifier": "getThrowable", "parameters": "(String throwstr)", "modifiers": "public static", "return": "Throwable", "signature": "Throwable getThrowable(String throwstr)", "full_signature": "public static Throwable getThrowable(String throwstr)", "class_method_signature": "MockInvoker.getThrowable(String throwstr)", "testcase": false, "constructor": false}, {"identifier": "getInvoker", "parameters": "(String mockService)", "modifiers": "@SuppressWarnings(\"unchecked\") private", "return": "Invoker<T>", "signature": "Invoker<T> getInvoker(String mockService)", "full_signature": "@SuppressWarnings(\"unchecked\") private Invoker<T> getInvoker(String mockService)", "class_method_signature": "MockInvoker.getInvoker(String mockService)", "testcase": false, "constructor": false}, {"identifier": "getMockObject", "parameters": "(String mockService, Class serviceType)", "modifiers": "@SuppressWarnings(\"unchecked\") public static", "return": "Object", "signature": "Object getMockObject(String mockService, Class serviceType)", "full_signature": "@SuppressWarnings(\"unchecked\") public static Object getMockObject(String mockService, Class serviceType)", "class_method_signature": "MockInvoker.getMockObject(String mockService, Class serviceType)", "testcase": false, "constructor": false}, {"identifier": "normalizeMock", "parameters": "(String mock)", "modifiers": "public static", "return": "String", "signature": "String normalizeMock(String mock)", "full_signature": "public static String normalizeMock(String mock)", "class_method_signature": "MockInvoker.normalizeMock(String mock)", "testcase": false, "constructor": false}, {"identifier": "getUrl", "parameters": "()", "modifiers": "@Override public", "return": "URL", "signature": "URL getUrl()", "full_signature": "@Override public URL getUrl()", "class_method_signature": "MockInvoker.getUrl()", "testcase": false, "constructor": false}, {"identifier": "isAvailable", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isAvailable()", "full_signature": "@Override public boolean isAvailable()", "class_method_signature": "MockInvoker.isAvailable()", "testcase": false, "constructor": false}, {"identifier": "destroy", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void destroy()", "full_signature": "@Override public void destroy()", "class_method_signature": "MockInvoker.destroy()", "testcase": false, "constructor": false}, {"identifier": "getInterface", "parameters": "()", "modifiers": "@Override public", "return": "Class<T>", "signature": "Class<T> getInterface()", "full_signature": "@Override public Class<T> getInterface()", "class_method_signature": "MockInvoker.getInterface()", "testcase": false, "constructor": false}], "file": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockInvoker.java"}, "focal_method": {"identifier": "invoke", "parameters": "(Invocation invocation)", "modifiers": "@Override public", "return": "Result", "body": "@Override\n    public Result invoke(Invocation invocation) throws RpcException {\n        if (invocation instanceof RpcInvocation) {\n            ((RpcInvocation) invocation).setInvoker(this);\n        }\n        String mock = null;\n        if (getUrl().hasMethodParameter(invocation.getMethodName())) {\n            mock = getUrl().getParameter(invocation.getMethodName() + \".\" + MOCK_KEY);\n        }\n        if (StringUtils.isBlank(mock)) {\n            mock = getUrl().getParameter(MOCK_KEY);\n        }\n\n        if (StringUtils.isBlank(mock)) {\n            throw new RpcException(new IllegalAccessException(\"mock can not be null. url :\" + url));\n        }\n        mock = normalizeMock(URL.decode(mock));\n        if (mock.startsWith(RETURN_PREFIX)) {\n            mock = mock.substring(RETURN_PREFIX.length()).trim();\n            try {\n                Type[] returnTypes = RpcUtils.getReturnTypes(invocation);\n                Object value = parseMockValue(mock, returnTypes);\n                return AsyncRpcResult.newDefaultAsyncResult(value, invocation);\n            } catch (Exception ew) {\n                throw new RpcException(\"mock return invoke error. method :\" + invocation.getMethodName()\n                        + \", mock:\" + mock + \", url: \" + url, ew);\n            }\n        } else if (mock.startsWith(THROW_PREFIX)) {\n            mock = mock.substring(THROW_PREFIX.length()).trim();\n            if (StringUtils.isBlank(mock)) {\n                throw new RpcException(\"mocked exception for service degradation.\");\n            } else { // user customized class\n                Throwable t = getThrowable(mock);\n                throw new RpcException(RpcException.BIZ_EXCEPTION, t);\n            }\n        } else { //impl mock\n            try {\n                Invoker<T> invoker = getInvoker(mock);\n                return invoker.invoke(invocation);\n            } catch (Throwable t) {\n                throw new RpcException(\"Failed to create mock implementation class \" + mock, t);\n            }\n        }\n    }", "signature": "Result invoke(Invocation invocation)", "full_signature": "@Override public Result invoke(Invocation invocation)", "class_method_signature": "MockInvoker.invoke(Invocation invocation)", "testcase": false, "constructor": false, "invocations": ["setInvoker", "hasMethodParameter", "getUrl", "getMethodName", "getParameter", "getUrl", "getMethodName", "isBlank", "getParameter", "getUrl", "isBlank", "normalizeMock", "decode", "startsWith", "trim", "substring", "length", "getReturnTypes", "parseMockValue", "newDefaultAsyncResult", "getMethodName", "startsWith", "trim", "substring", "length", "isBlank", "getThrowable", "getInvoker", "invoke"]}, "repository": {"repo_id": 4710920, "url": "https://github.com/apache/dubbo", "stars": 30960, "created": "6/19/2012 7:56:02 AM +00:00", "updates": "2020-01-27T14:21:03+00:00", "fork": "False", "license": "licensed"}}