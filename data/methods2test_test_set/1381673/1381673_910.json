{"test_class": {"identifier": "ToMethodCallTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "final TypeResolver typeResolver = new ClassTypeResolver(new HashSet<>(), getClass().getClassLoader());", "modifier": "final", "type": "TypeResolver", "declarator": "typeResolver = new ClassTypeResolver(new HashSet<>(), getClass().getClassLoader())", "var_name": "typeResolver"}], "file": "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/builder/generator/ToMethodCallTest.java"}, "test_case": {"identifier": "transformMethodExpressionToMethodCallExpressionTypeSafe", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void transformMethodExpressionToMethodCallExpressionTypeSafe() {\n\n        final Expression expr = StaticJavaParser.parseExpression(\"address.city.startsWith(\\\"M\\\")\");\n        final Expression expr1 = StaticJavaParser.parseExpression(\"getAddress().city.startsWith(\\\"M\\\")\");\n        final Expression expr2 = StaticJavaParser.parseExpression(\"address.getCity().startsWith(\\\"M\\\")\");\n\n        final MethodCallExpr expected = StaticJavaParser.parseExpression(\"getAddress().getCity().startsWith(\\\"M\\\")\");\n\n        assertEquals(expected.toString(), new ToMethodCall(typeResolver).toMethodCallWithClassCheck(expr, null, Person.class).getExpression().toString());\n        assertEquals(expected.toString(), new ToMethodCall(typeResolver).toMethodCallWithClassCheck(expr1, null, Person.class).getExpression().toString());\n        assertEquals(expected.toString(), new ToMethodCall(typeResolver).toMethodCallWithClassCheck(expr2, null, Person.class).getExpression().toString());\n    }", "signature": "void transformMethodExpressionToMethodCallExpressionTypeSafe()", "full_signature": "@Test public void transformMethodExpressionToMethodCallExpressionTypeSafe()", "class_method_signature": "ToMethodCallTest.transformMethodExpressionToMethodCallExpressionTypeSafe()", "testcase": true, "constructor": false, "invocations": ["parseExpression", "parseExpression", "parseExpression", "parseExpression", "assertEquals", "toString", "toString", "getExpression", "toMethodCallWithClassCheck", "assertEquals", "toString", "toString", "getExpression", "toMethodCallWithClassCheck", "assertEquals", "toString", "toString", "getExpression", "toMethodCallWithClassCheck"]}, "focal_class": {"identifier": "ToMethodCall", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final RuleContext context;", "modifier": "private final", "type": "RuleContext", "declarator": "context", "var_name": "context"}, {"original_string": "private final TypeResolver typeResolver;", "modifier": "private final", "type": "TypeResolver", "declarator": "typeResolver", "var_name": "typeResolver"}, {"original_string": "java.lang.reflect.Type previousClass;", "modifier": "", "type": "java.lang.reflect.Type", "declarator": "previousClass", "var_name": "previousClass"}, {"original_string": "Expression previousScope;", "modifier": "", "type": "Expression", "declarator": "previousScope", "var_name": "previousScope"}, {"original_string": "private Expression inlineCastExpression;", "modifier": "private", "type": "Expression", "declarator": "inlineCastExpression", "var_name": "inlineCastExpression"}], "methods": [{"identifier": "ToMethodCall", "parameters": "(RuleContext context)", "modifiers": "public", "return": "", "signature": " ToMethodCall(RuleContext context)", "full_signature": "public  ToMethodCall(RuleContext context)", "class_method_signature": "ToMethodCall.ToMethodCall(RuleContext context)", "testcase": false, "constructor": true}, {"identifier": "ToMethodCall", "parameters": "(TypeResolver typeResolver)", "modifiers": "public", "return": "", "signature": " ToMethodCall(TypeResolver typeResolver)", "full_signature": "public  ToMethodCall(TypeResolver typeResolver)", "class_method_signature": "ToMethodCall.ToMethodCall(TypeResolver typeResolver)", "testcase": false, "constructor": true}, {"identifier": "toMethodCallWithClassCheck", "parameters": "(Expression expr, String bindingId, Class<?> clazz)", "modifiers": "public", "return": "TypedExpression", "signature": "TypedExpression toMethodCallWithClassCheck(Expression expr, String bindingId, Class<?> clazz)", "full_signature": "public TypedExpression toMethodCallWithClassCheck(Expression expr, String bindingId, Class<?> clazz)", "class_method_signature": "ToMethodCall.toMethodCallWithClassCheck(Expression expr, String bindingId, Class<?> clazz)", "testcase": false, "constructor": false}, {"identifier": "getImplicitCastExpression", "parameters": "()", "modifiers": "public", "return": "Optional<Expression>", "signature": "Optional<Expression> getImplicitCastExpression()", "full_signature": "public Optional<Expression> getImplicitCastExpression()", "class_method_signature": "ToMethodCall.getImplicitCastExpression()", "testcase": false, "constructor": false}, {"identifier": "needConversionRec", "parameters": "(Expression expression)", "modifiers": "private", "return": "boolean", "signature": "boolean needConversionRec(Expression expression)", "full_signature": "private boolean needConversionRec(Expression expression)", "class_method_signature": "ToMethodCall.needConversionRec(Expression expression)", "testcase": false, "constructor": false}, {"identifier": "needConversion", "parameters": "(Expression expression)", "modifiers": "private", "return": "boolean", "signature": "boolean needConversion(Expression expression)", "full_signature": "private boolean needConversion(Expression expression)", "class_method_signature": "ToMethodCall.needConversion(Expression expression)", "testcase": false, "constructor": false}, {"identifier": "setCursorForEnclosedExpr", "parameters": "(ParsedMethod e)", "modifiers": "private", "return": "void", "signature": "void setCursorForEnclosedExpr(ParsedMethod e)", "full_signature": "private void setCursorForEnclosedExpr(ParsedMethod e)", "class_method_signature": "ToMethodCall.setCursorForEnclosedExpr(ParsedMethod e)", "testcase": false, "constructor": false}, {"identifier": "setCursorForMethodCall", "parameters": "(ParsedMethod e)", "modifiers": "private", "return": "void", "signature": "void setCursorForMethodCall(ParsedMethod e)", "full_signature": "private void setCursorForMethodCall(ParsedMethod e)", "class_method_signature": "ToMethodCall.setCursorForMethodCall(ParsedMethod e)", "testcase": false, "constructor": false}, {"identifier": "convertNameToMethod", "parameters": "(String bindingId, ParsedMethod e)", "modifiers": "private", "return": "void", "signature": "void convertNameToMethod(String bindingId, ParsedMethod e)", "full_signature": "private void convertNameToMethod(String bindingId, ParsedMethod e)", "class_method_signature": "ToMethodCall.convertNameToMethod(String bindingId, ParsedMethod e)", "testcase": false, "constructor": false}, {"identifier": "setCursorForMissingClass", "parameters": "(ParsedMethod e)", "modifiers": "private", "return": "void", "signature": "void setCursorForMissingClass(ParsedMethod e)", "full_signature": "private void setCursorForMissingClass(ParsedMethod e)", "class_method_signature": "ToMethodCall.setCursorForMissingClass(ParsedMethod e)", "testcase": false, "constructor": false}, {"identifier": "createExpressionCallLeftToRight", "parameters": "(Expression expr)", "modifiers": "private", "return": "Deque<ParsedMethod>", "signature": "Deque<ParsedMethod> createExpressionCallLeftToRight(Expression expr)", "full_signature": "private Deque<ParsedMethod> createExpressionCallLeftToRight(Expression expr)", "class_method_signature": "ToMethodCall.createExpressionCallLeftToRight(Expression expr)", "testcase": false, "constructor": false}, {"identifier": "createExpressionCallRec", "parameters": "(Expression expr, Deque<ParsedMethod> expressions)", "modifiers": "private static", "return": "void", "signature": "void createExpressionCallRec(Expression expr, Deque<ParsedMethod> expressions)", "full_signature": "private static void createExpressionCallRec(Expression expr, Deque<ParsedMethod> expressions)", "class_method_signature": "ToMethodCall.createExpressionCallRec(Expression expr, Deque<ParsedMethod> expressions)", "testcase": false, "constructor": false}], "file": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/ToMethodCall.java"}, "focal_method": {"identifier": "toMethodCallWithClassCheck", "parameters": "(Expression expr, String bindingId, Class<?> clazz)", "modifiers": "public", "return": "TypedExpression", "body": "public TypedExpression toMethodCallWithClassCheck(Expression expr, String bindingId, Class<?> clazz) {\n        Deque<ParsedMethod> createExpressionCallLeftToRight = createExpressionCallLeftToRight(expr);\n\n        previousClass = clazz; // Start from input class\n\n        for (ParsedMethod e : createExpressionCallLeftToRight) {\n            if (e.expression instanceof EnclosedExpr) { // inline cast\n                setCursorForEnclosedExpr(e);\n            } else if (e.expression instanceof MethodCallExpr) {\n                setCursorForMethodCall(e);\n            } else {\n                convertNameToMethod(bindingId, e);\n            }\n        }\n\n        return new TypedExpression(previousScope, previousClass);\n    }", "signature": "TypedExpression toMethodCallWithClassCheck(Expression expr, String bindingId, Class<?> clazz)", "full_signature": "public TypedExpression toMethodCallWithClassCheck(Expression expr, String bindingId, Class<?> clazz)", "class_method_signature": "ToMethodCall.toMethodCallWithClassCheck(Expression expr, String bindingId, Class<?> clazz)", "testcase": false, "constructor": false, "invocations": ["createExpressionCallLeftToRight", "setCursorForEnclosedExpr", "setCursorForMethodCall", "convertNameToMethod"]}, "repository": {"repo_id": 1381673, "url": "https://github.com/kiegroup/drools", "stars": 2733, "created": "2/18/2011 8:37:05 AM +00:00", "updates": "2020-01-27T13:12:15+00:00", "fork": "False", "license": "licensed"}}