{"test_class": {"identifier": "UtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "httpdlog/httpdlog-parser/src/test/java/nl/basjes/parse/httpdlog/UtilsTest.java"}, "test_case": {"identifier": "testApacheLogDecoder", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testApacheLogDecoder() {\n        // Decoding a value\n        assertEquals(\"bla bla bla\", Utils.decodeApacheHTTPDLogValue(\"bla bla bla\"));\n        assertEquals(\"bla bla bla\", Utils.decodeApacheHTTPDLogValue(\"bla\\\\x20bla bla\"));\n        assertEquals(\"bla\\bbla\\nbla\\tbla\", Utils.decodeApacheHTTPDLogValue(\"bla\\\\bbla\\\\nbla\\\\tbla\"));\n        assertEquals(\"bla\\\"bla\\nbla\\tbla\", Utils.decodeApacheHTTPDLogValue(\"bla\\\\\\\"bla\\\\nbla\\\\tbla\"));\n        assertEquals(new String(new byte[] {(byte)0x0b}), Utils.decodeApacheHTTPDLogValue(\"\\\\v\"));\n\n        // Specials\n        assertEquals(\"\\\\q\", Utils.decodeApacheHTTPDLogValue(\"\\\\q\"));\n        assertEquals(\"\", Utils.decodeApacheHTTPDLogValue(\"\"));\n        assertEquals(null, Utils.decodeApacheHTTPDLogValue(null));\n    }", "signature": "void testApacheLogDecoder()", "full_signature": "@Test public void testApacheLogDecoder()", "class_method_signature": "UtilsTest.testApacheLogDecoder()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "decodeApacheHTTPDLogValue", "assertEquals", "decodeApacheHTTPDLogValue", "assertEquals", "decodeApacheHTTPDLogValue", "assertEquals", "decodeApacheHTTPDLogValue", "assertEquals", "decodeApacheHTTPDLogValue", "assertEquals", "decodeApacheHTTPDLogValue", "assertEquals", "decodeApacheHTTPDLogValue", "assertEquals", "decodeApacheHTTPDLogValue"]}, "focal_class": {"identifier": "Utils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Pattern CHOPPED_STANDARD       = Pattern.compile(\"%[0-9A-Fa-f]?$\");", "modifier": "private static final", "type": "Pattern", "declarator": "CHOPPED_STANDARD       = Pattern.compile(\"%[0-9A-Fa-f]?$\")", "var_name": "CHOPPED_STANDARD"}, {"original_string": "private static final Pattern VALID_NON_STANDARD     = Pattern.compile(\"%u([0-9A-Fa-f][0-9A-Fa-f])+\");", "modifier": "private static final", "type": "Pattern", "declarator": "VALID_NON_STANDARD     = Pattern.compile(\"%u([0-9A-Fa-f][0-9A-Fa-f])+\")", "var_name": "VALID_NON_STANDARD"}, {"original_string": "private static final Pattern CHOPPED_NON_STANDARD   = Pattern.compile(\"%u[0-9A-Fa-f]{0,3}$\");", "modifier": "private static final", "type": "Pattern", "declarator": "CHOPPED_NON_STANDARD   = Pattern.compile(\"%u[0-9A-Fa-f]{0,3}$\")", "var_name": "CHOPPED_NON_STANDARD"}, {"original_string": "private static final Map<String, String> HTML_ENTITY_REPLACE_MAP;", "modifier": "private static final", "type": "Map<String, String>", "declarator": "HTML_ENTITY_REPLACE_MAP", "var_name": "HTML_ENTITY_REPLACE_MAP"}], "methods": [{"identifier": "Utils", "parameters": "()", "modifiers": "private", "return": "", "signature": " Utils()", "full_signature": "private  Utils()", "class_method_signature": "Utils.Utils()", "testcase": false, "constructor": true}, {"identifier": "resilientUrlDecode", "parameters": "(String input)", "modifiers": "public static", "return": "String", "signature": "String resilientUrlDecode(String input)", "full_signature": "public static String resilientUrlDecode(String input)", "class_method_signature": "Utils.resilientUrlDecode(String input)", "testcase": false, "constructor": false}, {"identifier": "hexCharsToByte", "parameters": "(String twoHexDigits)", "modifiers": "public static", "return": "byte", "signature": "byte hexCharsToByte(String twoHexDigits)", "full_signature": "public static byte hexCharsToByte(String twoHexDigits)", "class_method_signature": "Utils.hexCharsToByte(String twoHexDigits)", "testcase": false, "constructor": false}, {"identifier": "hexCharsToByte", "parameters": "(char c1, char c2)", "modifiers": "public static", "return": "byte", "signature": "byte hexCharsToByte(char c1, char c2)", "full_signature": "public static byte hexCharsToByte(char c1, char c2)", "class_method_signature": "Utils.hexCharsToByte(char c1, char c2)", "testcase": false, "constructor": false}, {"identifier": "decodeApacheHTTPDLogValue", "parameters": "(String input)", "modifiers": "public static", "return": "String", "signature": "String decodeApacheHTTPDLogValue(String input)", "full_signature": "public static String decodeApacheHTTPDLogValue(String input)", "class_method_signature": "Utils.decodeApacheHTTPDLogValue(String input)", "testcase": false, "constructor": false}, {"identifier": "htmlEntityToURLEncoded", "parameters": "(String entity)", "modifiers": "private static", "return": "String", "signature": "String htmlEntityToURLEncoded(String entity)", "full_signature": "private static String htmlEntityToURLEncoded(String entity)", "class_method_signature": "Utils.htmlEntityToURLEncoded(String entity)", "testcase": false, "constructor": false}, {"identifier": "makeHTMLEncodedInert", "parameters": "(String uriString)", "modifiers": "public static", "return": "String", "signature": "String makeHTMLEncodedInert(String uriString)", "full_signature": "public static String makeHTMLEncodedInert(String uriString)", "class_method_signature": "Utils.makeHTMLEncodedInert(String uriString)", "testcase": false, "constructor": false}, {"identifier": "replaceString", "parameters": "(\n        final String input,\n        final String searchFor,\n        final String replaceWith\n    )", "modifiers": "public static", "return": "String", "signature": "String replaceString(\n        final String input,\n        final String searchFor,\n        final String replaceWith\n    )", "full_signature": "public static String replaceString(\n        final String input,\n        final String searchFor,\n        final String replaceWith\n    )", "class_method_signature": "Utils.replaceString(\n        final String input,\n        final String searchFor,\n        final String replaceWith\n    )", "testcase": false, "constructor": false}], "file": "httpdlog/httpdlog-parser/src/main/java/nl/basjes/parse/httpdlog/Utils.java"}, "focal_method": {"identifier": "decodeApacheHTTPDLogValue", "parameters": "(String input)", "modifiers": "public static", "return": "String", "body": "public static String decodeApacheHTTPDLogValue(String input){\n        if (input == null || input.length() == 0) {\n            return input;\n        }\n\n        if (!input.contains(\"\\\\\")) {\n            return input;\n        }\n\n        StringBuilder sb = new StringBuilder(input.length());\n\n        // https://stackoverflow.com/q/8894258/114196 : Fastest way to iterate over all the chars in a String\n        for (int i = 0; i < input.length(); i++) {\n            char chr = input.charAt(i);\n\n            if (chr == '\\\\') {\n                chr = input.charAt(++i);\n                switch (chr){\n                    case '\"':\n                    case '\\\\':\n                        sb.append(chr);\n                        break;\n                    case 'b':\n                        sb.append('\\b');\n                        break;\n                    case 'n':\n                        sb.append('\\n');\n                        break;\n                    case 'r':\n                        sb.append('\\r');\n                        break;\n                    case 't':\n                        sb.append('\\t');\n                        break;\n                    case 'v':\n                        sb.append((char)hexCharsToByte('0', 'b'));\n                        break;\n                    case 'x':\n                        // This should be \\xhh  (hh = [0-9a-f][0-9a-f])\n                        char chr1 = input.charAt(++i);\n                        char chr2 = input.charAt(++i);\n                        sb.append((char)hexCharsToByte(chr1, chr2));\n                        break;\n                    default:\n                        // This shouldn't happen.\n                        // Let's just append the unmodified input for now.\n                        sb.append('\\\\').append(chr);\n                }\n            } else {\n                sb.append(chr);\n            }\n\n        }\n        return sb.toString();\n    }", "signature": "String decodeApacheHTTPDLogValue(String input)", "full_signature": "public static String decodeApacheHTTPDLogValue(String input)", "class_method_signature": "Utils.decodeApacheHTTPDLogValue(String input)", "testcase": false, "constructor": false, "invocations": ["length", "contains", "length", "length", "charAt", "charAt", "append", "append", "append", "append", "append", "append", "hexCharsToByte", "charAt", "charAt", "append", "hexCharsToByte", "append", "append", "append", "toString"]}, "repository": {"repo_id": 12652963, "url": "https://github.com/nielsbasjes/logparser", "language": "Java", "is_fork": false, "fork_count": 29, "stargazer_count": 94, "size": 2121, "license": "licensed"}}