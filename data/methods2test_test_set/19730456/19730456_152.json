{"test_class": {"identifier": "EncryptionHandshakeTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ECKey myKey;", "modifier": "private", "type": "ECKey", "declarator": "myKey", "var_name": "myKey"}, {"original_string": "private ECKey remoteKey;", "modifier": "private", "type": "ECKey", "declarator": "remoteKey", "var_name": "remoteKey"}, {"original_string": "private EncryptionHandshake initiator;", "modifier": "private", "type": "EncryptionHandshake", "declarator": "initiator", "var_name": "initiator"}], "file": "ethereumj-core/src/test/java/org/ethereum/net/rlpx/EncryptionHandshakeTest.java"}, "test_case": {"identifier": "testCreateAuthInitiate", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCreateAuthInitiate() throws Exception {\n        AuthInitiateMessage message = initiator.createAuthInitiate(new byte[32], myKey);\n        int expectedLength = 65+32+64+32+1;\n        byte[] buffer = message.encode();\n        assertEquals(expectedLength, buffer.length);\n    }", "signature": "void testCreateAuthInitiate()", "full_signature": "@Test public void testCreateAuthInitiate()", "class_method_signature": "EncryptionHandshakeTest.testCreateAuthInitiate()", "testcase": true, "constructor": false, "invocations": ["createAuthInitiate", "encode", "assertEquals"]}, "focal_class": {"identifier": "EncryptionHandshake", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int NONCE_SIZE = 32;", "modifier": "public static final", "type": "int", "declarator": "NONCE_SIZE = 32", "var_name": "NONCE_SIZE"}, {"original_string": "public static final int MAC_SIZE = 256;", "modifier": "public static final", "type": "int", "declarator": "MAC_SIZE = 256", "var_name": "MAC_SIZE"}, {"original_string": "public static final int SECRET_SIZE = 32;", "modifier": "public static final", "type": "int", "declarator": "SECRET_SIZE = 32", "var_name": "SECRET_SIZE"}, {"original_string": "private SecureRandom random = new SecureRandom();", "modifier": "private", "type": "SecureRandom", "declarator": "random = new SecureRandom()", "var_name": "random"}, {"original_string": "private boolean isInitiator;", "modifier": "private", "type": "boolean", "declarator": "isInitiator", "var_name": "isInitiator"}, {"original_string": "private ECKey ephemeralKey;", "modifier": "private", "type": "ECKey", "declarator": "ephemeralKey", "var_name": "ephemeralKey"}, {"original_string": "private ECPoint remotePublicKey;", "modifier": "private", "type": "ECPoint", "declarator": "remotePublicKey", "var_name": "remotePublicKey"}, {"original_string": "private ECPoint remoteEphemeralKey;", "modifier": "private", "type": "ECPoint", "declarator": "remoteEphemeralKey", "var_name": "remoteEphemeralKey"}, {"original_string": "private byte[] initiatorNonce;", "modifier": "private", "type": "byte[]", "declarator": "initiatorNonce", "var_name": "initiatorNonce"}, {"original_string": "private byte[] responderNonce;", "modifier": "private", "type": "byte[]", "declarator": "responderNonce", "var_name": "responderNonce"}, {"original_string": "private Secrets secrets;", "modifier": "private", "type": "Secrets", "declarator": "secrets", "var_name": "secrets"}], "methods": [{"identifier": "EncryptionHandshake", "parameters": "(ECPoint remotePublicKey)", "modifiers": "public", "return": "", "signature": " EncryptionHandshake(ECPoint remotePublicKey)", "full_signature": "public  EncryptionHandshake(ECPoint remotePublicKey)", "class_method_signature": "EncryptionHandshake.EncryptionHandshake(ECPoint remotePublicKey)", "testcase": false, "constructor": true}, {"identifier": "EncryptionHandshake", "parameters": "(ECPoint remotePublicKey, ECKey ephemeralKey, byte[] initiatorNonce, byte[] responderNonce, boolean isInitiator)", "modifiers": "", "return": "", "signature": " EncryptionHandshake(ECPoint remotePublicKey, ECKey ephemeralKey, byte[] initiatorNonce, byte[] responderNonce, boolean isInitiator)", "full_signature": "  EncryptionHandshake(ECPoint remotePublicKey, ECKey ephemeralKey, byte[] initiatorNonce, byte[] responderNonce, boolean isInitiator)", "class_method_signature": "EncryptionHandshake.EncryptionHandshake(ECPoint remotePublicKey, ECKey ephemeralKey, byte[] initiatorNonce, byte[] responderNonce, boolean isInitiator)", "testcase": false, "constructor": true}, {"identifier": "EncryptionHandshake", "parameters": "()", "modifiers": "public", "return": "", "signature": " EncryptionHandshake()", "full_signature": "public  EncryptionHandshake()", "class_method_signature": "EncryptionHandshake.EncryptionHandshake()", "testcase": false, "constructor": true}, {"identifier": "createAuthInitiateV4", "parameters": "(ECKey key)", "modifiers": "public", "return": "AuthInitiateMessageV4", "signature": "AuthInitiateMessageV4 createAuthInitiateV4(ECKey key)", "full_signature": "public AuthInitiateMessageV4 createAuthInitiateV4(ECKey key)", "class_method_signature": "EncryptionHandshake.createAuthInitiateV4(ECKey key)", "testcase": false, "constructor": false}, {"identifier": "encryptAuthInitiateV4", "parameters": "(AuthInitiateMessageV4 message)", "modifiers": "public", "return": "byte[]", "signature": "byte[] encryptAuthInitiateV4(AuthInitiateMessageV4 message)", "full_signature": "public byte[] encryptAuthInitiateV4(AuthInitiateMessageV4 message)", "class_method_signature": "EncryptionHandshake.encryptAuthInitiateV4(AuthInitiateMessageV4 message)", "testcase": false, "constructor": false}, {"identifier": "decryptAuthInitiateV4", "parameters": "(byte[] in, ECKey myKey)", "modifiers": "public", "return": "AuthInitiateMessageV4", "signature": "AuthInitiateMessageV4 decryptAuthInitiateV4(byte[] in, ECKey myKey)", "full_signature": "public AuthInitiateMessageV4 decryptAuthInitiateV4(byte[] in, ECKey myKey)", "class_method_signature": "EncryptionHandshake.decryptAuthInitiateV4(byte[] in, ECKey myKey)", "testcase": false, "constructor": false}, {"identifier": "encryptAuthResponseV4", "parameters": "(AuthResponseMessageV4 message)", "modifiers": "public", "return": "byte[]", "signature": "byte[] encryptAuthResponseV4(AuthResponseMessageV4 message)", "full_signature": "public byte[] encryptAuthResponseV4(AuthResponseMessageV4 message)", "class_method_signature": "EncryptionHandshake.encryptAuthResponseV4(AuthResponseMessageV4 message)", "testcase": false, "constructor": false}, {"identifier": "decryptAuthResponseV4", "parameters": "(byte[] in, ECKey myKey)", "modifiers": "public", "return": "AuthResponseMessageV4", "signature": "AuthResponseMessageV4 decryptAuthResponseV4(byte[] in, ECKey myKey)", "full_signature": "public AuthResponseMessageV4 decryptAuthResponseV4(byte[] in, ECKey myKey)", "class_method_signature": "EncryptionHandshake.decryptAuthResponseV4(byte[] in, ECKey myKey)", "testcase": false, "constructor": false}, {"identifier": "makeAuthInitiateV4", "parameters": "(AuthInitiateMessageV4 initiate, ECKey key)", "modifiers": "", "return": "AuthResponseMessageV4", "signature": "AuthResponseMessageV4 makeAuthInitiateV4(AuthInitiateMessageV4 initiate, ECKey key)", "full_signature": " AuthResponseMessageV4 makeAuthInitiateV4(AuthInitiateMessageV4 initiate, ECKey key)", "class_method_signature": "EncryptionHandshake.makeAuthInitiateV4(AuthInitiateMessageV4 initiate, ECKey key)", "testcase": false, "constructor": false}, {"identifier": "handleAuthResponseV4", "parameters": "(ECKey myKey, byte[] initiatePacket, byte[] responsePacket)", "modifiers": "public", "return": "AuthResponseMessageV4", "signature": "AuthResponseMessageV4 handleAuthResponseV4(ECKey myKey, byte[] initiatePacket, byte[] responsePacket)", "full_signature": "public AuthResponseMessageV4 handleAuthResponseV4(ECKey myKey, byte[] initiatePacket, byte[] responsePacket)", "class_method_signature": "EncryptionHandshake.handleAuthResponseV4(ECKey myKey, byte[] initiatePacket, byte[] responsePacket)", "testcase": false, "constructor": false}, {"identifier": "encryptAuthEIP8", "parameters": "(byte[] msg)", "modifiers": "", "return": "byte[]", "signature": "byte[] encryptAuthEIP8(byte[] msg)", "full_signature": " byte[] encryptAuthEIP8(byte[] msg)", "class_method_signature": "EncryptionHandshake.encryptAuthEIP8(byte[] msg)", "testcase": false, "constructor": false}, {"identifier": "createAuthInitiate", "parameters": "(@Nullable byte[] token, ECKey key)", "modifiers": "public", "return": "AuthInitiateMessage", "signature": "AuthInitiateMessage createAuthInitiate(@Nullable byte[] token, ECKey key)", "full_signature": "public AuthInitiateMessage createAuthInitiate(@Nullable byte[] token, ECKey key)", "class_method_signature": "EncryptionHandshake.createAuthInitiate(@Nullable byte[] token, ECKey key)", "testcase": false, "constructor": false}, {"identifier": "xor", "parameters": "(byte[] b1, byte[] b2)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] xor(byte[] b1, byte[] b2)", "full_signature": "private static byte[] xor(byte[] b1, byte[] b2)", "class_method_signature": "EncryptionHandshake.xor(byte[] b1, byte[] b2)", "testcase": false, "constructor": false}, {"identifier": "encryptAuthMessage", "parameters": "(AuthInitiateMessage message)", "modifiers": "public", "return": "byte[]", "signature": "byte[] encryptAuthMessage(AuthInitiateMessage message)", "full_signature": "public byte[] encryptAuthMessage(AuthInitiateMessage message)", "class_method_signature": "EncryptionHandshake.encryptAuthMessage(AuthInitiateMessage message)", "testcase": false, "constructor": false}, {"identifier": "encryptAuthResponse", "parameters": "(AuthResponseMessage message)", "modifiers": "public", "return": "byte[]", "signature": "byte[] encryptAuthResponse(AuthResponseMessage message)", "full_signature": "public byte[] encryptAuthResponse(AuthResponseMessage message)", "class_method_signature": "EncryptionHandshake.encryptAuthResponse(AuthResponseMessage message)", "testcase": false, "constructor": false}, {"identifier": "decryptAuthResponse", "parameters": "(byte[] ciphertext, ECKey myKey)", "modifiers": "public", "return": "AuthResponseMessage", "signature": "AuthResponseMessage decryptAuthResponse(byte[] ciphertext, ECKey myKey)", "full_signature": "public AuthResponseMessage decryptAuthResponse(byte[] ciphertext, ECKey myKey)", "class_method_signature": "EncryptionHandshake.decryptAuthResponse(byte[] ciphertext, ECKey myKey)", "testcase": false, "constructor": false}, {"identifier": "decryptAuthInitiate", "parameters": "(byte[] ciphertext, ECKey myKey)", "modifiers": "public", "return": "AuthInitiateMessage", "signature": "AuthInitiateMessage decryptAuthInitiate(byte[] ciphertext, ECKey myKey)", "full_signature": "public AuthInitiateMessage decryptAuthInitiate(byte[] ciphertext, ECKey myKey)", "class_method_signature": "EncryptionHandshake.decryptAuthInitiate(byte[] ciphertext, ECKey myKey)", "testcase": false, "constructor": false}, {"identifier": "handleAuthResponse", "parameters": "(ECKey myKey, byte[] initiatePacket, byte[] responsePacket)", "modifiers": "public", "return": "AuthResponseMessage", "signature": "AuthResponseMessage handleAuthResponse(ECKey myKey, byte[] initiatePacket, byte[] responsePacket)", "full_signature": "public AuthResponseMessage handleAuthResponse(ECKey myKey, byte[] initiatePacket, byte[] responsePacket)", "class_method_signature": "EncryptionHandshake.handleAuthResponse(ECKey myKey, byte[] initiatePacket, byte[] responsePacket)", "testcase": false, "constructor": false}, {"identifier": "agreeSecret", "parameters": "(byte[] initiatePacket, byte[] responsePacket)", "modifiers": "", "return": "void", "signature": "void agreeSecret(byte[] initiatePacket, byte[] responsePacket)", "full_signature": " void agreeSecret(byte[] initiatePacket, byte[] responsePacket)", "class_method_signature": "EncryptionHandshake.agreeSecret(byte[] initiatePacket, byte[] responsePacket)", "testcase": false, "constructor": false}, {"identifier": "handleAuthInitiate", "parameters": "(byte[] initiatePacket, ECKey key)", "modifiers": "public", "return": "byte[]", "signature": "byte[] handleAuthInitiate(byte[] initiatePacket, ECKey key)", "full_signature": "public byte[] handleAuthInitiate(byte[] initiatePacket, ECKey key)", "class_method_signature": "EncryptionHandshake.handleAuthInitiate(byte[] initiatePacket, ECKey key)", "testcase": false, "constructor": false}, {"identifier": "makeAuthInitiate", "parameters": "(byte[] initiatePacket, ECKey key)", "modifiers": "", "return": "AuthResponseMessage", "signature": "AuthResponseMessage makeAuthInitiate(byte[] initiatePacket, ECKey key)", "full_signature": " AuthResponseMessage makeAuthInitiate(byte[] initiatePacket, ECKey key)", "class_method_signature": "EncryptionHandshake.makeAuthInitiate(byte[] initiatePacket, ECKey key)", "testcase": false, "constructor": false}, {"identifier": "makeAuthInitiate", "parameters": "(AuthInitiateMessage initiate, ECKey key)", "modifiers": "", "return": "AuthResponseMessage", "signature": "AuthResponseMessage makeAuthInitiate(AuthInitiateMessage initiate, ECKey key)", "full_signature": " AuthResponseMessage makeAuthInitiate(AuthInitiateMessage initiate, ECKey key)", "class_method_signature": "EncryptionHandshake.makeAuthInitiate(AuthInitiateMessage initiate, ECKey key)", "testcase": false, "constructor": false}, {"identifier": "padEip8", "parameters": "(byte[] msg)", "modifiers": "private", "return": "byte[]", "signature": "byte[] padEip8(byte[] msg)", "full_signature": "private byte[] padEip8(byte[] msg)", "class_method_signature": "EncryptionHandshake.padEip8(byte[] msg)", "testcase": false, "constructor": false}, {"identifier": "recIdFromSignatureV", "parameters": "(int v)", "modifiers": "static public", "return": "byte", "signature": "byte recIdFromSignatureV(int v)", "full_signature": "static public byte recIdFromSignatureV(int v)", "class_method_signature": "EncryptionHandshake.recIdFromSignatureV(int v)", "testcase": false, "constructor": false}, {"identifier": "getSecrets", "parameters": "()", "modifiers": "public", "return": "Secrets", "signature": "Secrets getSecrets()", "full_signature": "public Secrets getSecrets()", "class_method_signature": "EncryptionHandshake.getSecrets()", "testcase": false, "constructor": false}, {"identifier": "getRemotePublicKey", "parameters": "()", "modifiers": "public", "return": "ECPoint", "signature": "ECPoint getRemotePublicKey()", "full_signature": "public ECPoint getRemotePublicKey()", "class_method_signature": "EncryptionHandshake.getRemotePublicKey()", "testcase": false, "constructor": false}, {"identifier": "isInitiator", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isInitiator()", "full_signature": "public boolean isInitiator()", "class_method_signature": "EncryptionHandshake.isInitiator()", "testcase": false, "constructor": false}], "file": "ethereumj-core/src/main/java/org/ethereum/net/rlpx/EncryptionHandshake.java"}, "focal_method": {"identifier": "createAuthInitiate", "parameters": "(@Nullable byte[] token, ECKey key)", "modifiers": "public", "return": "AuthInitiateMessage", "body": "public AuthInitiateMessage createAuthInitiate(@Nullable byte[] token, ECKey key) {\n        AuthInitiateMessage message = new AuthInitiateMessage();\n        boolean isToken;\n        if (token == null) {\n            isToken = false;\n            BigInteger secretScalar = key.keyAgreement(remotePublicKey);\n            token = ByteUtil.bigIntegerToBytes(secretScalar, NONCE_SIZE);\n        } else {\n            isToken = true;\n        }\n\n        byte[] nonce = initiatorNonce;\n        byte[] signed = xor(token, nonce);\n        message.signature = ephemeralKey.sign(signed);\n        message.isTokenUsed = isToken;\n        message.ephemeralPublicHash = sha3(ephemeralKey.getPubKey(), 1, 64);\n        message.publicKey = key.getPubKeyPoint();\n        message.nonce = initiatorNonce;\n        return message;\n    }", "signature": "AuthInitiateMessage createAuthInitiate(@Nullable byte[] token, ECKey key)", "full_signature": "public AuthInitiateMessage createAuthInitiate(@Nullable byte[] token, ECKey key)", "class_method_signature": "EncryptionHandshake.createAuthInitiate(@Nullable byte[] token, ECKey key)", "testcase": false, "constructor": false, "invocations": ["keyAgreement", "bigIntegerToBytes", "xor", "sign", "sha3", "getPubKey", "getPubKeyPoint"]}, "repository": {"repo_id": 19730456, "url": "https://github.com/ethereum/ethereumj", "language": "Java", "is_fork": false, "fork_count": 1034, "stargazer_count": 2058, "size": 47979, "license": "licensed"}}