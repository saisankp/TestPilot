{"test_class": {"identifier": "ProcessorStateManagerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Set<TopicPartition> noPartitions = Collections.emptySet();", "modifier": "private final", "type": "Set<TopicPartition>", "declarator": "noPartitions = Collections.emptySet()", "var_name": "noPartitions"}, {"original_string": "private final String applicationId = \"test-application\";", "modifier": "private final", "type": "String", "declarator": "applicationId = \"test-application\"", "var_name": "applicationId"}, {"original_string": "private final String stateDir = \"test\";", "modifier": "private final", "type": "String", "declarator": "stateDir = \"test\"", "var_name": "stateDir"}, {"original_string": "private final String persistentStoreName = \"persistentStore\";", "modifier": "private final", "type": "String", "declarator": "persistentStoreName = \"persistentStore\"", "var_name": "persistentStoreName"}, {"original_string": "private final String nonPersistentStoreName = \"nonPersistentStore\";", "modifier": "private final", "type": "String", "declarator": "nonPersistentStoreName = \"nonPersistentStore\"", "var_name": "nonPersistentStoreName"}, {"original_string": "private final String persistentStoreTopicName = ProcessorStateManager.storeChangelogTopic(applicationId, persistentStoreName);", "modifier": "private final", "type": "String", "declarator": "persistentStoreTopicName = ProcessorStateManager.storeChangelogTopic(applicationId, persistentStoreName)", "var_name": "persistentStoreTopicName"}, {"original_string": "private final String nonPersistentStoreTopicName = ProcessorStateManager.storeChangelogTopic(applicationId, nonPersistentStoreName);", "modifier": "private final", "type": "String", "declarator": "nonPersistentStoreTopicName = ProcessorStateManager.storeChangelogTopic(applicationId, nonPersistentStoreName)", "var_name": "nonPersistentStoreTopicName"}], "file": "streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorStateManagerTest.java"}, "test_case": {"identifier": "testClose", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testClose() throws IOException {\n        File baseDir = Files.createTempDirectory(stateDir).toFile();\n        File checkpointFile = new File(baseDir, ProcessorStateManager.CHECKPOINT_FILE_NAME);\n        try {\n            // write an empty checkpoint file\n            OffsetCheckpoint oldCheckpoint = new OffsetCheckpoint(checkpointFile);\n            oldCheckpoint.write(Collections.<TopicPartition, Long>emptyMap());\n\n            MockRestoreConsumer restoreConsumer = new MockRestoreConsumer();\n\n            restoreConsumer.updatePartitions(persistentStoreTopicName, Utils.mkList(\n                    new PartitionInfo(persistentStoreTopicName, 1, Node.noNode(), new Node[0], new Node[0])\n            ));\n            restoreConsumer.updatePartitions(nonPersistentStoreTopicName, Utils.mkList(\n                    new PartitionInfo(nonPersistentStoreTopicName, 1, Node.noNode(), new Node[0], new Node[0])\n            ));\n\n            // set up ack'ed offsets\n            HashMap<TopicPartition, Long> ackedOffsets = new HashMap<>();\n            ackedOffsets.put(new TopicPartition(persistentStoreTopicName, 1), 123L);\n            ackedOffsets.put(new TopicPartition(nonPersistentStoreTopicName, 1), 456L);\n            ackedOffsets.put(new TopicPartition(ProcessorStateManager.storeChangelogTopic(applicationId, \"otherTopic\"), 1), 789L);\n\n            MockStateStoreSupplier.MockStateStore persistentStore = new MockStateStoreSupplier.MockStateStore(persistentStoreName, true);\n            MockStateStoreSupplier.MockStateStore nonPersistentStore = new MockStateStoreSupplier.MockStateStore(nonPersistentStoreName, false);\n\n            ProcessorStateManager stateMgr = new ProcessorStateManager(applicationId, 1, noPartitions, baseDir, restoreConsumer, false);\n            try {\n                // make sure the checkpoint file is deleted\n                assertFalse(checkpointFile.exists());\n\n                restoreConsumer.reset();\n                stateMgr.register(persistentStore, true, persistentStore.stateRestoreCallback);\n\n                restoreConsumer.reset();\n                stateMgr.register(nonPersistentStore, true, nonPersistentStore.stateRestoreCallback);\n            } finally {\n                // close the state manager with the ack'ed offsets\n                stateMgr.close(ackedOffsets);\n            }\n\n            // make sure all stores are closed, and the checkpoint file is written.\n            assertTrue(persistentStore.flushed);\n            assertTrue(persistentStore.closed);\n            assertTrue(nonPersistentStore.flushed);\n            assertTrue(nonPersistentStore.closed);\n            assertTrue(checkpointFile.exists());\n\n            // the checkpoint file should contain an offset from the persistent store only.\n            OffsetCheckpoint newCheckpoint = new OffsetCheckpoint(checkpointFile);\n            Map<TopicPartition, Long> checkpointedOffsets = newCheckpoint.read();\n            assertEquals(1, checkpointedOffsets.size());\n            assertEquals(new Long(123L + 1L), checkpointedOffsets.get(new TopicPartition(persistentStoreTopicName, 1)));\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }", "signature": "void testClose()", "full_signature": "@Test public void testClose()", "class_method_signature": "ProcessorStateManagerTest.testClose()", "testcase": true, "constructor": false, "invocations": ["toFile", "createTempDirectory", "write", "emptyMap", "updatePartitions", "mkList", "noNode", "updatePartitions", "mkList", "noNode", "put", "put", "put", "storeChangelogTopic", "assertFalse", "exists", "reset", "register", "reset", "register", "close", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "exists", "read", "assertEquals", "size", "assertEquals", "get", "delete"]}, "focal_class": {"identifier": "ProcessorStateManager", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(ProcessorStateManager.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(ProcessorStateManager.class)", "var_name": "log"}, {"original_string": "public static final String STATE_CHANGELOG_TOPIC_SUFFIX = \"-changelog\";", "modifier": "public static final", "type": "String", "declarator": "STATE_CHANGELOG_TOPIC_SUFFIX = \"-changelog\"", "var_name": "STATE_CHANGELOG_TOPIC_SUFFIX"}, {"original_string": "public static final String CHECKPOINT_FILE_NAME = \".checkpoint\";", "modifier": "public static final", "type": "String", "declarator": "CHECKPOINT_FILE_NAME = \".checkpoint\"", "var_name": "CHECKPOINT_FILE_NAME"}, {"original_string": "public static final String LOCK_FILE_NAME = \".lock\";", "modifier": "public static final", "type": "String", "declarator": "LOCK_FILE_NAME = \".lock\"", "var_name": "LOCK_FILE_NAME"}, {"original_string": "private final String applicationId;", "modifier": "private final", "type": "String", "declarator": "applicationId", "var_name": "applicationId"}, {"original_string": "private final int defaultPartition;", "modifier": "private final", "type": "int", "declarator": "defaultPartition", "var_name": "defaultPartition"}, {"original_string": "private final Map<String, TopicPartition> partitionForTopic;", "modifier": "private final", "type": "Map<String, TopicPartition>", "declarator": "partitionForTopic", "var_name": "partitionForTopic"}, {"original_string": "private final File baseDir;", "modifier": "private final", "type": "File", "declarator": "baseDir", "var_name": "baseDir"}, {"original_string": "private final FileLock directoryLock;", "modifier": "private final", "type": "FileLock", "declarator": "directoryLock", "var_name": "directoryLock"}, {"original_string": "private final Map<String, StateStore> stores;", "modifier": "private final", "type": "Map<String, StateStore>", "declarator": "stores", "var_name": "stores"}, {"original_string": "private final Set<String> loggingEnabled;", "modifier": "private final", "type": "Set<String>", "declarator": "loggingEnabled", "var_name": "loggingEnabled"}, {"original_string": "private final Consumer<byte[], byte[]> restoreConsumer;", "modifier": "private final", "type": "Consumer<byte[], byte[]>", "declarator": "restoreConsumer", "var_name": "restoreConsumer"}, {"original_string": "private final Map<TopicPartition, Long> restoredOffsets;", "modifier": "private final", "type": "Map<TopicPartition, Long>", "declarator": "restoredOffsets", "var_name": "restoredOffsets"}, {"original_string": "private final Map<TopicPartition, Long> checkpointedOffsets;", "modifier": "private final", "type": "Map<TopicPartition, Long>", "declarator": "checkpointedOffsets", "var_name": "checkpointedOffsets"}, {"original_string": "private final Map<TopicPartition, Long> offsetLimits;", "modifier": "private final", "type": "Map<TopicPartition, Long>", "declarator": "offsetLimits", "var_name": "offsetLimits"}, {"original_string": "private final boolean isStandby;", "modifier": "private final", "type": "boolean", "declarator": "isStandby", "var_name": "isStandby"}, {"original_string": "private final Map<String, StateRestoreCallback> restoreCallbacks;", "modifier": "private final", "type": "Map<String, StateRestoreCallback>", "declarator": "restoreCallbacks", "var_name": "restoreCallbacks"}], "methods": [{"identifier": "ProcessorStateManager", "parameters": "(String applicationId, int defaultPartition, Collection<TopicPartition> sources, File baseDir, Consumer<byte[], byte[]> restoreConsumer, boolean isStandby)", "modifiers": "public", "return": "", "signature": " ProcessorStateManager(String applicationId, int defaultPartition, Collection<TopicPartition> sources, File baseDir, Consumer<byte[], byte[]> restoreConsumer, boolean isStandby)", "full_signature": "public  ProcessorStateManager(String applicationId, int defaultPartition, Collection<TopicPartition> sources, File baseDir, Consumer<byte[], byte[]> restoreConsumer, boolean isStandby)", "class_method_signature": "ProcessorStateManager.ProcessorStateManager(String applicationId, int defaultPartition, Collection<TopicPartition> sources, File baseDir, Consumer<byte[], byte[]> restoreConsumer, boolean isStandby)", "testcase": false, "constructor": true}, {"identifier": "createStateDirectory", "parameters": "(File stateDir)", "modifiers": "private static", "return": "void", "signature": "void createStateDirectory(File stateDir)", "full_signature": "private static void createStateDirectory(File stateDir)", "class_method_signature": "ProcessorStateManager.createStateDirectory(File stateDir)", "testcase": false, "constructor": false}, {"identifier": "storeChangelogTopic", "parameters": "(String applicationId, String storeName)", "modifiers": "public static", "return": "String", "signature": "String storeChangelogTopic(String applicationId, String storeName)", "full_signature": "public static String storeChangelogTopic(String applicationId, String storeName)", "class_method_signature": "ProcessorStateManager.storeChangelogTopic(String applicationId, String storeName)", "testcase": false, "constructor": false}, {"identifier": "lockStateDirectory", "parameters": "(File stateDir)", "modifiers": "public static", "return": "FileLock", "signature": "FileLock lockStateDirectory(File stateDir)", "full_signature": "public static FileLock lockStateDirectory(File stateDir)", "class_method_signature": "ProcessorStateManager.lockStateDirectory(File stateDir)", "testcase": false, "constructor": false}, {"identifier": "lockStateDirectory", "parameters": "(File stateDir, int retry)", "modifiers": "private static", "return": "FileLock", "signature": "FileLock lockStateDirectory(File stateDir, int retry)", "full_signature": "private static FileLock lockStateDirectory(File stateDir, int retry)", "class_method_signature": "ProcessorStateManager.lockStateDirectory(File stateDir, int retry)", "testcase": false, "constructor": false}, {"identifier": "lockStateDirectory", "parameters": "(FileChannel channel)", "modifiers": "private static", "return": "FileLock", "signature": "FileLock lockStateDirectory(FileChannel channel)", "full_signature": "private static FileLock lockStateDirectory(FileChannel channel)", "class_method_signature": "ProcessorStateManager.lockStateDirectory(FileChannel channel)", "testcase": false, "constructor": false}, {"identifier": "baseDir", "parameters": "()", "modifiers": "public", "return": "File", "signature": "File baseDir()", "full_signature": "public File baseDir()", "class_method_signature": "ProcessorStateManager.baseDir()", "testcase": false, "constructor": false}, {"identifier": "register", "parameters": "(StateStore store, boolean loggingEnabled, StateRestoreCallback stateRestoreCallback)", "modifiers": "public", "return": "void", "signature": "void register(StateStore store, boolean loggingEnabled, StateRestoreCallback stateRestoreCallback)", "full_signature": "public void register(StateStore store, boolean loggingEnabled, StateRestoreCallback stateRestoreCallback)", "class_method_signature": "ProcessorStateManager.register(StateStore store, boolean loggingEnabled, StateRestoreCallback stateRestoreCallback)", "testcase": false, "constructor": false}, {"identifier": "restoreActiveState", "parameters": "(String topicName, StateRestoreCallback stateRestoreCallback)", "modifiers": "private", "return": "void", "signature": "void restoreActiveState(String topicName, StateRestoreCallback stateRestoreCallback)", "full_signature": "private void restoreActiveState(String topicName, StateRestoreCallback stateRestoreCallback)", "class_method_signature": "ProcessorStateManager.restoreActiveState(String topicName, StateRestoreCallback stateRestoreCallback)", "testcase": false, "constructor": false}, {"identifier": "checkpointedOffsets", "parameters": "()", "modifiers": "public", "return": "Map<TopicPartition, Long>", "signature": "Map<TopicPartition, Long> checkpointedOffsets()", "full_signature": "public Map<TopicPartition, Long> checkpointedOffsets()", "class_method_signature": "ProcessorStateManager.checkpointedOffsets()", "testcase": false, "constructor": false}, {"identifier": "updateStandbyStates", "parameters": "(TopicPartition storePartition, List<ConsumerRecord<byte[], byte[]>> records)", "modifiers": "public", "return": "List<ConsumerRecord<byte[], byte[]>>", "signature": "List<ConsumerRecord<byte[], byte[]>> updateStandbyStates(TopicPartition storePartition, List<ConsumerRecord<byte[], byte[]>> records)", "full_signature": "public List<ConsumerRecord<byte[], byte[]>> updateStandbyStates(TopicPartition storePartition, List<ConsumerRecord<byte[], byte[]>> records)", "class_method_signature": "ProcessorStateManager.updateStandbyStates(TopicPartition storePartition, List<ConsumerRecord<byte[], byte[]>> records)", "testcase": false, "constructor": false}, {"identifier": "putOffsetLimit", "parameters": "(TopicPartition partition, long limit)", "modifiers": "public", "return": "void", "signature": "void putOffsetLimit(TopicPartition partition, long limit)", "full_signature": "public void putOffsetLimit(TopicPartition partition, long limit)", "class_method_signature": "ProcessorStateManager.putOffsetLimit(TopicPartition partition, long limit)", "testcase": false, "constructor": false}, {"identifier": "offsetLimit", "parameters": "(TopicPartition partition)", "modifiers": "private", "return": "long", "signature": "long offsetLimit(TopicPartition partition)", "full_signature": "private long offsetLimit(TopicPartition partition)", "class_method_signature": "ProcessorStateManager.offsetLimit(TopicPartition partition)", "testcase": false, "constructor": false}, {"identifier": "getStore", "parameters": "(String name)", "modifiers": "public", "return": "StateStore", "signature": "StateStore getStore(String name)", "full_signature": "public StateStore getStore(String name)", "class_method_signature": "ProcessorStateManager.getStore(String name)", "testcase": false, "constructor": false}, {"identifier": "flush", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void flush()", "full_signature": "public void flush()", "class_method_signature": "ProcessorStateManager.flush()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "(Map<TopicPartition, Long> ackedOffsets)", "modifiers": "public", "return": "void", "signature": "void close(Map<TopicPartition, Long> ackedOffsets)", "full_signature": "public void close(Map<TopicPartition, Long> ackedOffsets)", "class_method_signature": "ProcessorStateManager.close(Map<TopicPartition, Long> ackedOffsets)", "testcase": false, "constructor": false}, {"identifier": "getPartition", "parameters": "(String topic)", "modifiers": "private", "return": "int", "signature": "int getPartition(String topic)", "full_signature": "private int getPartition(String topic)", "class_method_signature": "ProcessorStateManager.getPartition(String topic)", "testcase": false, "constructor": false}], "file": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorStateManager.java"}, "focal_method": {"identifier": "close", "parameters": "(Map<TopicPartition, Long> ackedOffsets)", "modifiers": "public", "return": "void", "body": "public void close(Map<TopicPartition, Long> ackedOffsets) throws IOException {\n        try {\n            // attempting to flush and close the stores, just in case they\n            // are not closed by a ProcessorNode yet\n            if (!stores.isEmpty()) {\n                log.debug(\"Closing stores.\");\n                for (Map.Entry<String, StateStore> entry : stores.entrySet()) {\n                    log.debug(\"Closing storage engine {}\", entry.getKey());\n                    entry.getValue().flush();\n                    entry.getValue().close();\n                }\n\n                Map<TopicPartition, Long> checkpointOffsets = new HashMap<>();\n                for (String storeName : stores.keySet()) {\n                    TopicPartition part;\n                    if (loggingEnabled.contains(storeName))\n                        part = new TopicPartition(storeChangelogTopic(applicationId, storeName), getPartition(storeName));\n                    else\n                        part = new TopicPartition(storeName, getPartition(storeName));\n\n                    // only checkpoint the offset to the offsets file if it is persistent;\n                    if (stores.get(storeName).persistent()) {\n                        Long offset = ackedOffsets.get(part);\n\n                        if (offset != null) {\n                            // store the last offset + 1 (the log position after restoration)\n                            checkpointOffsets.put(part, offset + 1);\n                        } else {\n                            // if no record was produced. we need to check the restored offset.\n                            offset = restoredOffsets.get(part);\n                            if (offset != null)\n                                checkpointOffsets.put(part, offset);\n                        }\n                    }\n                }\n\n                // write the checkpoint file before closing, to indicate clean shutdown\n                OffsetCheckpoint checkpoint = new OffsetCheckpoint(new File(this.baseDir, CHECKPOINT_FILE_NAME));\n                checkpoint.write(checkpointOffsets);\n            }\n        } finally {\n            // release the state directory directoryLock\n            directoryLock.release();\n            directoryLock.channel().close();\n        }\n    }", "signature": "void close(Map<TopicPartition, Long> ackedOffsets)", "full_signature": "public void close(Map<TopicPartition, Long> ackedOffsets)", "class_method_signature": "ProcessorStateManager.close(Map<TopicPartition, Long> ackedOffsets)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "debug", "entrySet", "debug", "getKey", "flush", "getValue", "close", "getValue", "keySet", "contains", "storeChangelogTopic", "getPartition", "getPartition", "persistent", "get", "get", "put", "get", "put", "write", "release", "close", "channel"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}