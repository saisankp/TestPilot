{"test_class": {"identifier": "HttpNetworkTest", "superclass": "", "interfaces": "", "fields": [], "file": "jus-java/src/test/java/io/apptik/comm/jus/toolbox/HttpNetworkTest.java"}, "test_case": {"identifier": "cacheHeadersFromCache", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void cacheHeadersFromCache() throws Exception {\n        MockHttpStack mockHttpStack = new MockHttpStack();\n        final NetworkResponse fakeResponse = new NetworkResponse(304, new byte[0],\n                new Headers.Builder().add(\"responseheader\", \"response-foo\").build(), 0);\n\n        mockHttpStack.setResponseToReturn(fakeResponse);\n        HttpNetwork httpNetwork = new HttpNetwork(mockHttpStack);\n        Request<NetworkResponse> request = new Request<NetworkResponse>(Request.Method.GET, \"http://foo\") {\n            @Override\n            protected void deliverResponse(NetworkResponse response) {\n            }\n\n            @Override\n            public Cache.Entry getCacheEntry() {\n                Cache.Entry entry = new Cache.Entry();\n                entry.data = \"cached-foo\".getBytes();\n                entry.responseHeaders = new Headers.Builder()\n                        .add(\"Date: Sun, 15 May 2016 11:03:26 GMT\")\n                        .add(\"ETag: W/\\\"123456\\\"\")\n                        .add(\"Cache-Control: public, max-age=60, s-maxage=60\")\n                        .add(\"Expires: Mon, 14 Nov 2016 11:03:26 GMT\")\n                        .add(\"Vary: Accept\")\n                        .add(\"Content-Location: /cache\")\n                        .build();\n                return entry;\n            }\n        };\n        request.setNetworkRequest(new NetworkRequest.Builder()\n                .setHeader(\"requestheader\", \"foo\").build());\n        NetworkResponse networkResponse =  httpNetwork.performRequest(request);\n\n        assertEquals(\"foo\", mockHttpStack.getLastHeaders().get(\"requestheader\"));\n        assertEquals(\"cached-foo\", new String(networkResponse.data));\n        assertEquals(\"response-foo\", networkResponse.headers.get(\"responseheader\"));\n        assertEquals(\"Sun, 15 May 2016 11:03:26 GMT\", networkResponse.headers.get(\"Date\"));\n        assertEquals(\"W/\\\"123456\\\"\", networkResponse.headers.get(\"ETag\"));\n        assertEquals(\"public, max-age=60, s-maxage=60\", networkResponse.headers.get(\"Cache-Control\"));\n        assertEquals(\"Mon, 14 Nov 2016 11:03:26 GMT\", networkResponse.headers.get(\"Expires\"));\n        assertEquals(\"Accept\", networkResponse.headers.get(\"Vary\"));\n        assertEquals(\"/cache\", networkResponse.headers.get(\"Content-Location\"));\n    }", "signature": "void cacheHeadersFromCache()", "full_signature": "@Test public void cacheHeadersFromCache()", "class_method_signature": "HttpNetworkTest.cacheHeadersFromCache()", "testcase": true, "constructor": false, "invocations": ["build", "add", "setResponseToReturn", "getBytes", "build", "add", "add", "add", "add", "add", "add", "setNetworkRequest", "build", "setHeader", "performRequest", "assertEquals", "get", "getLastHeaders", "assertEquals", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "HttpNetwork", "superclass": "", "interfaces": "implements Network", "fields": [{"original_string": "protected final HttpStack httpStack;", "modifier": "protected final", "type": "HttpStack", "declarator": "httpStack", "var_name": "httpStack"}, {"original_string": "protected final ByteArrayPool pool;", "modifier": "protected final", "type": "ByteArrayPool", "declarator": "pool", "var_name": "pool"}, {"original_string": "public static final int DEFAULT_POOL_SIZE = 4096;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_POOL_SIZE = 4096", "var_name": "DEFAULT_POOL_SIZE"}], "methods": [{"identifier": "HttpNetwork", "parameters": "(HttpStack httpStack)", "modifiers": "public", "return": "", "signature": " HttpNetwork(HttpStack httpStack)", "full_signature": "public  HttpNetwork(HttpStack httpStack)", "class_method_signature": "HttpNetwork.HttpNetwork(HttpStack httpStack)", "testcase": false, "constructor": true}, {"identifier": "HttpNetwork", "parameters": "(HttpStack httpStack, ByteArrayPool pool)", "modifiers": "public", "return": "", "signature": " HttpNetwork(HttpStack httpStack, ByteArrayPool pool)", "full_signature": "public  HttpNetwork(HttpStack httpStack, ByteArrayPool pool)", "class_method_signature": "HttpNetwork.HttpNetwork(HttpStack httpStack, ByteArrayPool pool)", "testcase": false, "constructor": true}, {"identifier": "performRequest", "parameters": "(Request<?> request)", "modifiers": "@Override public", "return": "NetworkResponse", "signature": "NetworkResponse performRequest(Request<?> request)", "full_signature": "@Override public NetworkResponse performRequest(Request<?> request)", "class_method_signature": "HttpNetwork.performRequest(Request<?> request)", "testcase": false, "constructor": false}, {"identifier": "logSlowRequests", "parameters": "(long requestLifetime, Request<?> request,\n                                 byte[] responseContents, int statusCode)", "modifiers": "private", "return": "void", "signature": "void logSlowRequests(long requestLifetime, Request<?> request,\n                                 byte[] responseContents, int statusCode)", "full_signature": "private void logSlowRequests(long requestLifetime, Request<?> request,\n                                 byte[] responseContents, int statusCode)", "class_method_signature": "HttpNetwork.logSlowRequests(long requestLifetime, Request<?> request,\n                                 byte[] responseContents, int statusCode)", "testcase": false, "constructor": false}, {"identifier": "attemptRetryOnException", "parameters": "(String logPrefix, Request<?> request,\n                                                JusError exception)", "modifiers": "private static", "return": "void", "signature": "void attemptRetryOnException(String logPrefix, Request<?> request,\n                                                JusError exception)", "full_signature": "private static void attemptRetryOnException(String logPrefix, Request<?> request,\n                                                JusError exception)", "class_method_signature": "HttpNetwork.attemptRetryOnException(String logPrefix, Request<?> request,\n                                                JusError exception)", "testcase": false, "constructor": false}, {"identifier": "addServerAuthHeaders", "parameters": "(Authenticator authenticator, Headers.Builder headers)", "modifiers": "private", "return": "void", "signature": "void addServerAuthHeaders(Authenticator authenticator, Headers.Builder headers)", "full_signature": "private void addServerAuthHeaders(Authenticator authenticator, Headers.Builder headers)", "class_method_signature": "HttpNetwork.addServerAuthHeaders(Authenticator authenticator, Headers.Builder headers)", "testcase": false, "constructor": false}, {"identifier": "addProxyAuthHeaders", "parameters": "(Authenticator authenticator, Headers.Builder headers)", "modifiers": "private", "return": "void", "signature": "void addProxyAuthHeaders(Authenticator authenticator, Headers.Builder headers)", "full_signature": "private void addProxyAuthHeaders(Authenticator authenticator, Headers.Builder headers)", "class_method_signature": "HttpNetwork.addProxyAuthHeaders(Authenticator authenticator, Headers.Builder headers)", "testcase": false, "constructor": false}, {"identifier": "addCacheHeaders", "parameters": "(Headers.Builder headers, Cache.Entry entry)", "modifiers": "private", "return": "void", "signature": "void addCacheHeaders(Headers.Builder headers, Cache.Entry entry)", "full_signature": "private void addCacheHeaders(Headers.Builder headers, Cache.Entry entry)", "class_method_signature": "HttpNetwork.addCacheHeaders(Headers.Builder headers, Cache.Entry entry)", "testcase": false, "constructor": false}], "file": "jus-java/src/main/java/io/apptik/comm/jus/toolbox/HttpNetwork.java"}, "focal_method": {"identifier": "performRequest", "parameters": "(Request<?> request)", "modifiers": "@Override public", "return": "NetworkResponse", "body": "@Override\n    public NetworkResponse performRequest(Request<?> request) throws JusError {\n        long requestStart = System.nanoTime();\n        boolean serverAuthRequested = false;\n        boolean proxyAuthRequested = false;\n        while (true) {\n            if (request.isCanceled()) {\n                //it will be handled/ignored later\n                return null;\n            }\n            if (request.getNoConnectionPolicy() != null\n                    && request.getConnectivityManager() != null) {\n                if (request.getConnectivityManager().getActiveNetwork() == null\n                        || !request.getConnectivityManager().getActiveNetwork().isConnected()) {\n                    JusError error = request.getNoConnectionPolicy().throwOnNoConnection(request);\n                    if (error != null) {\n                        throw error;\n                    }\n                }\n            }\n            NetworkResponse httpResponse = null;\n            try {\n                // Gather headers.\n                Headers.Builder headers = new Headers.Builder();\n                addCacheHeaders(headers, request.getCacheEntry());\n                addServerAuthHeaders(request.getServerAuthenticator(), headers);\n                addProxyAuthHeaders(request.getProxyAuthenticator(), headers);\n\n                Headers extraHeaders = headers.build();\n                request.addMarker(Request.EVENT_NETWORK_STACK_SEND, request.getNetworkRequest(),\n                        extraHeaders);\n                httpResponse = httpStack.performRequest(request, extraHeaders, pool);\n                if (httpResponse == null) {\n                    throw new NetworkError(\"No Response\");\n                }\n\n                //Check for redirects\n                if (request.getRedirectPolicy() != null) {\n                    Request newR = request.getRedirectPolicy().verifyRedirect(request,\n                            httpResponse);\n                    Headers rHeaders = new Headers.Builder().build();\n                    while (newR != null) {\n                        request.addMarker(Request.EVENT_NETWORK_STACK_REDIRECT_SEND, newR);\n                        httpResponse = httpStack.performRequest(newR, rHeaders, pool);\n                        request.addMarker(Request.EVENT_NETWORK_STACK_REDIRECT_COMPLETE,\n                                httpResponse);\n                        newR = request.getRedirectPolicy().verifyRedirect(request, httpResponse);\n                    }\n                }\n\n                request.addMarker(Request.EVENT_NETWORK_STACK_COMPLETE, httpResponse);\n\n                //currently all requests that came to here normally needs to be attached to the\n                // queue\n                //however due the complete decoupling of the components in Jus a Network may be set\n                //to perform internal requests, i.e. which was not passed to the queue, possibly\n                // auth\n                //requests. So we shall check\n                if (request.getRequestQueue() != null) {\n                    httpResponse = request.getRequestQueue().transformResponse(request,\n                            httpResponse);\n                    request.addMarker(Request.EVENT_NETWORK_TRANSFORM_COMPLETE, httpResponse);\n                }\n\n                //check completeness of body\n                if (httpResponse != null && httpResponse.headers != null) {\n                    String contentLen = httpResponse.headers.get(HTTP.CONTENT_LEN);\n                    if (contentLen != null) {\n                        int cLen = Integer.parseInt(contentLen);\n                        if (cLen > httpResponse.data.length\n                                && request.getMethod() != Request.Method.HEAD) {\n                            throw new NetworkError(httpResponse, \"Response Body not completely \" +\n                                    \"received\");\n                        }\n                    }\n                }\n\n                //Check for Auth\n                if (httpResponse.statusCode == HttpURLConnection.HTTP_UNAUTHORIZED) {\n                    request.addMarker(Request.EVENT_NETWORK_STACK_AUTH_ERROR,\n                            httpResponse);\n                    if (request.getServerAuthenticator() != null && !serverAuthRequested) {\n                        request.getServerAuthenticator().clearAuthValue();\n                        try {\n                            //typical implementation would try to refresh the token\n                            //after being set to invalid\n                            request.getServerAuthenticator().getAuthValue();\n                        } catch (AuthError authError) {\n                            //finally we didn't succeed\n                            throw authError;\n                        }\n                        //retry the request\n                        request.addMarker(Request.EVENT_NETWORK_STACK_AUTH_ERROR_RESEND,\n                                httpResponse);\n                        serverAuthRequested = true;\n                        continue;\n                    } else {\n                        //or if another way of auth is used\n                        throw new AuthError(httpResponse);\n                    }\n                } else if (httpResponse.statusCode == HttpURLConnection.HTTP_PROXY_AUTH) {\n                    request.addMarker(Request.EVENT_NETWORK_STACK_AUTH_PROXY_ERROR,\n                            httpResponse);\n                    if (request.getProxyAuthenticator() != null && !proxyAuthRequested) {\n                        request.getProxyAuthenticator().clearAuthValue();\n                        try {\n                            //typical implementation would try to refresh the token\n                            //after being set to invalid\n                            request.getProxyAuthenticator().getAuthValue();\n                        } catch (AuthError authError) {\n                            //finally we didn't succeed\n                            throw authError;\n                        }\n                        //retry the request\n                        request.addMarker(Request.EVENT_NETWORK_STACK_AUTH_ERROR_RESEND,\n                                httpResponse);\n                        proxyAuthRequested = true;\n                        continue;\n                    } else {\n                        //or if another way of auth is used\n                        throw new AuthError(httpResponse);\n                    }\n                }\n\n                // if the request is slow, log it.\n                long requestLifetime = System.nanoTime() - requestStart;\n                logSlowRequests(requestLifetime, request, httpResponse.data, httpResponse\n                        .statusCode);\n\n                // Handle cache validation.\n                if (httpResponse.statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) {\n\n                    Entry entry = request.getCacheEntry();\n                    if (entry != null) {\n\n                        // A HTTP 304 response does not have all header fields. We\n                        // have to use the header fields from the cache entry plus\n                        // the new ones from the response.\n                        // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5\n                        final Map<String, List<String>> responseHeaders = httpResponse.headers.toMultimap();\n                        final Map<String, List<String>> cacheHeaders = entry.responseHeaders.toMultimap();\n                        Headers.Builder hBuilder = new Headers.Builder();\n                        hBuilder.addMMap(responseHeaders);\n                        if (cacheHeaders != null) {\n                            for (Map.Entry<String, List<String>> hentry : cacheHeaders.entrySet()) {\n                                //could be status line\n                                if (hentry.getKey() != null\n                                        && !responseHeaders.containsKey(hentry.getKey())) {\n                                    hBuilder.add(hentry.getKey(), hentry.getValue());\n                                }\n                            }\n                        }\n\n                        httpResponse = new NetworkResponse(\n                                httpResponse.statusCode,\n                                entry.data, hBuilder.build(),\n                                System.nanoTime() - requestStart\n                        );\n                    } else {\n                        httpResponse = new NetworkResponse(\n                                httpResponse.statusCode,\n                                null,\n                                httpResponse.headers,\n                                System.nanoTime() - requestStart\n                        );\n                    }\n                } else if (httpResponse.statusCode < 200 || httpResponse.statusCode > 299) {\n                    //todo Not really nice throw better\n                    throw new IOException();\n                }\n                return httpResponse;\n            } catch (SocketTimeoutException e) {\n                attemptRetryOnException(\"socket\", request, new TimeoutError(\"socket Timeout\", e));\n            } catch (MalformedURLException e) {\n                throw new RuntimeException(\"Bad URL \" + request.getUrlString(), e);\n            } catch (IOException e) {\n                NetworkResponse networkResponse;\n                if (httpResponse != null) {\n                    networkResponse = httpResponse;\n                } else {\n                    throw new NetworkError(e);\n                }\n                //todo add queue markers\n//                JusLog.e(\"Unexpected response code %d for %s\", networkResponse.statusCode,\n//                        request.getUrlString());\n                if (networkResponse != null) {\n                    if (networkResponse.statusCode == HttpURLConnection\n                            .HTTP_CLIENT_TIMEOUT) {\n                        attemptRetryOnException(\"http-client\", request, new RequestError\n                                (networkResponse, \"HTTP_CLIENT_TIMEOUT\"));\n                    } else if (networkResponse.statusCode > 399 && networkResponse.statusCode <\n                            500) {\n                        //some request query error that does not make sense to retry, assuming\n                        // the service we use is deterministic\n                        throw new RequestError(networkResponse);\n                    } else if (networkResponse.statusCode > 499) {\n                        //some server error might not need to be retried\n                        //however retry policy set to this request should handle it as it needs.\n                        attemptRetryOnException(\"server\",\n                                request, new ServerError(networkResponse));\n                    } else {\n                        //unclassified error\n                        throw new JusError(networkResponse, e);\n                    }\n                } else {\n                    //this can result doe to many reasons and the implementations may have some\n                    // means to know if a retry is needed\n                    attemptRetryOnException(\"network\", request, new NetworkError());\n                }\n            } catch (AuthError authError) {\n                //we have failed to get a token so give it up\n                throw authError;\n            }\n        }\n    }", "signature": "NetworkResponse performRequest(Request<?> request)", "full_signature": "@Override public NetworkResponse performRequest(Request<?> request)", "class_method_signature": "HttpNetwork.performRequest(Request<?> request)", "testcase": false, "constructor": false, "invocations": ["nanoTime", "isCanceled", "getNoConnectionPolicy", "getConnectivityManager", "getActiveNetwork", "getConnectivityManager", "isConnected", "getActiveNetwork", "getConnectivityManager", "throwOnNoConnection", "getNoConnectionPolicy", "addCacheHeaders", "getCacheEntry", "addServerAuthHeaders", "getServerAuthenticator", "addProxyAuthHeaders", "getProxyAuthenticator", "build", "addMarker", "getNetworkRequest", "performRequest", "getRedirectPolicy", "verifyRedirect", "getRedirectPolicy", "build", "addMarker", "performRequest", "addMarker", "verifyRedirect", "getRedirectPolicy", "addMarker", "getRequestQueue", "transformResponse", "getRequestQueue", "addMarker", "get", "parseInt", "getMethod", "addMarker", "getServerAuthenticator", "clearAuthValue", "getServerAuthenticator", "getAuthValue", "getServerAuthenticator", "addMarker", "addMarker", "getProxyAuthenticator", "clearAuthValue", "getProxyAuthenticator", "getAuthValue", "getProxyAuthenticator", "addMarker", "nanoTime", "logSlowRequests", "getCacheEntry", "toMultimap", "toMultimap", "addMMap", "entrySet", "getKey", "containsKey", "getKey", "add", "getKey", "getValue", "build", "nanoTime", "nanoTime", "attemptRetryOnException", "getUrlString", "attemptRetryOnException", "attemptRetryOnException", "attemptRetryOnException"]}, "repository": {"repo_id": 28505345, "url": "https://github.com/apptik/jus", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 56, "size": 2057, "license": "licensed"}}