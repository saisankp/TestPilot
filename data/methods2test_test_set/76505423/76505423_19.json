{"test_class": {"identifier": "JoinFilterPushDownTest", "superclass": "", "interfaces": "", "fields": [], "file": "yqlplus_engine/src/test/java/com/yahoo/yqlplus/engine/rules/JoinFilterPushDownTest.java"}, "test_case": {"identifier": "testMultiClausePush", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMultiClausePush() throws IOException, RecognitionException {\n        ProgramParser parser = new ProgramParser();\n        OperatorNode<SequenceOperator> query = parser.parseQuery(\n                \"SELECT * \" +\n                        \"FROM left \" +\n                        \"JOIN right ON left.id = right.id \" +\n                        \"JOIN middle ON right.id = middle.id \" +\n                        \"WHERE left.category = 1 AND right.woeid = 2 AND middle.id = 1\"\n        );\n        OperatorNode<SequenceOperator> transformed = new JoinFilterPushDown().visitSequenceOperator(query);\n        Assert.assertEquals(transformed.getOperator(), SequenceOperator.JOIN);\n        Assert.assertEquals(((OperatorNode) transformed.getArgument(0)).getOperator(), SequenceOperator.JOIN);\n        Assert.assertEquals(((OperatorNode) transformed.getArgument(1)).getOperator(), SequenceOperator.FILTER);\n        // TODO: validate the rest of the tree\n    }", "signature": "void testMultiClausePush()", "full_signature": "@Test public void testMultiClausePush()", "class_method_signature": "JoinFilterPushDownTest.testMultiClausePush()", "testcase": true, "constructor": false, "invocations": ["parseQuery", "visitSequenceOperator", "assertEquals", "getOperator", "assertEquals", "getOperator", "getArgument", "assertEquals", "getOperator", "getArgument"]}, "focal_class": {"identifier": "JoinFilterPushDown", "superclass": "extends LogicalOperatorTransform", "interfaces": "", "fields": [], "methods": [{"identifier": "findSources", "parameters": "(final OperatorNode<SequenceOperator> node)", "modifiers": "private", "return": "Set<String>", "signature": "Set<String> findSources(final OperatorNode<SequenceOperator> node)", "full_signature": "private Set<String> findSources(final OperatorNode<SequenceOperator> node)", "class_method_signature": "JoinFilterPushDown.findSources(final OperatorNode<SequenceOperator> node)", "testcase": false, "constructor": false}, {"identifier": "findReferencedSources", "parameters": "(final OperatorNode<ExpressionOperator> node)", "modifiers": "private", "return": "Set<String>", "signature": "Set<String> findReferencedSources(final OperatorNode<ExpressionOperator> node)", "full_signature": "private Set<String> findReferencedSources(final OperatorNode<ExpressionOperator> node)", "class_method_signature": "JoinFilterPushDown.findReferencedSources(final OperatorNode<ExpressionOperator> node)", "testcase": false, "constructor": false}, {"identifier": "visitSequenceOperator", "parameters": "(OperatorNode<SequenceOperator> node)", "modifiers": "@Override public", "return": "OperatorNode<SequenceOperator>", "signature": "OperatorNode<SequenceOperator> visitSequenceOperator(OperatorNode<SequenceOperator> node)", "full_signature": "@Override public OperatorNode<SequenceOperator> visitSequenceOperator(OperatorNode<SequenceOperator> node)", "class_method_signature": "JoinFilterPushDown.visitSequenceOperator(OperatorNode<SequenceOperator> node)", "testcase": false, "constructor": false}, {"identifier": "flatten", "parameters": "(List<OperatorNode<ExpressionOperator>> top, List<OperatorNode<ExpressionOperator>> argument)", "modifiers": "private", "return": "void", "signature": "void flatten(List<OperatorNode<ExpressionOperator>> top, List<OperatorNode<ExpressionOperator>> argument)", "full_signature": "private void flatten(List<OperatorNode<ExpressionOperator>> top, List<OperatorNode<ExpressionOperator>> argument)", "class_method_signature": "JoinFilterPushDown.flatten(List<OperatorNode<ExpressionOperator>> top, List<OperatorNode<ExpressionOperator>> argument)", "testcase": false, "constructor": false}, {"identifier": "createFilter", "parameters": "(List<OperatorNode<ExpressionOperator>> rightFilter)", "modifiers": "private", "return": "OperatorNode<ExpressionOperator>", "signature": "OperatorNode<ExpressionOperator> createFilter(List<OperatorNode<ExpressionOperator>> rightFilter)", "full_signature": "private OperatorNode<ExpressionOperator> createFilter(List<OperatorNode<ExpressionOperator>> rightFilter)", "class_method_signature": "JoinFilterPushDown.createFilter(List<OperatorNode<ExpressionOperator>> rightFilter)", "testcase": false, "constructor": false}], "file": "yqlplus_engine/src/main/java/com/yahoo/yqlplus/engine/rules/JoinFilterPushDown.java"}, "focal_method": {"identifier": "visitSequenceOperator", "parameters": "(OperatorNode<SequenceOperator> node)", "modifiers": "@Override public", "return": "OperatorNode<SequenceOperator>", "body": "@Override\n    public OperatorNode<SequenceOperator> visitSequenceOperator(OperatorNode<SequenceOperator> node) {\n        // if this is a FILTER AND it contains a JOIN (perhaps with some other transforms in the way)\n        //   AND the filter contains only references to the left side of the join\n        if (node.getOperator() != SequenceOperator.FILTER) {\n            return super.visitSequenceOperator(node);\n        }\n        // we have a FILTER, see if there's a JOIN underneath\n        OperatorNode<SequenceOperator> target = node.getArgument(0);\n        OperatorNode<ExpressionOperator> filter = node.getArgument(1);\n        // It has to be *directly* underneath due to the way logical operands are constructed by the current parser\n        // there may be a stack of JOINs, but we can attack each one in sequence\n\n        if (target.getOperator() == SequenceOperator.JOIN || target.getOperator() == SequenceOperator.LEFT_JOIN) {\n            List<OperatorNode<ExpressionOperator>> top = Lists.newArrayList();\n            List<OperatorNode<ExpressionOperator>> leftFilter = Lists.newArrayList();\n            List<OperatorNode<ExpressionOperator>> rightFilter = Lists.newArrayList();\n            OperatorNode<SequenceOperator> leftSide = target.getArgument(0);\n            OperatorNode<SequenceOperator> rightSide = target.getArgument(1);\n            OperatorNode<ExpressionOperator> joinExpr = target.getArgument(2);\n            if (filter.getOperator() == ExpressionOperator.AND) {\n                flatten(top, (List<OperatorNode<ExpressionOperator>>) filter.getArgument(0));\n            } else {\n                top.add(filter);\n            }\n            Iterator<OperatorNode<ExpressionOperator>> topIterator = top.iterator();\n            while (topIterator.hasNext()) {\n                OperatorNode<ExpressionOperator> clause = topIterator.next();\n                Set<String> left = findSources(leftSide);\n                Set<String> right = findSources(rightSide);\n                Set<String> referencedFilter = findReferencedSources(clause);\n                boolean useLeft = !Sets.intersection(referencedFilter, left).isEmpty();\n                boolean useRight = !Sets.intersection(referencedFilter, right).isEmpty();\n                if (useLeft && useRight) {\n                    // can't do anything\n                } else if (useLeft) {\n                    leftFilter.add(clause);\n                    topIterator.remove();\n                } else if (useRight) {\n                    rightFilter.add(clause);\n                    topIterator.remove();\n                }\n            }\n            OperatorNode<SequenceOperator> result = node;\n            if (rightFilter.size() > 0) {\n                rightSide = visitSequenceOperator(new MergeFilters().visitSequenceOperator(OperatorNode.create(node.getLocation(), SequenceOperator.FILTER, rightSide, createFilter(rightFilter))));\n            }\n            if (leftFilter.size() > 0) {\n                leftSide = visitSequenceOperator(new MergeFilters().visitSequenceOperator(OperatorNode.create(node.getLocation(), SequenceOperator.FILTER, leftSide, createFilter(leftFilter))));\n            }\n            if (rightFilter.size() > 0 || leftFilter.size() > 0) {\n                result = OperatorNode.create(target.getLocation(), target.getAnnotations(), target.getOperator(),\n                        leftSide, rightSide, joinExpr);\n                if (top.size() > 0) {\n                    result = OperatorNode.create(node.getLocation(), node.getAnnotations(), node.getOperator(), result, createFilter(top));\n                } else {\n                    for (Map.Entry<String, Object> e : node.getAnnotations().entrySet()) {\n                        result.putAnnotation(e.getKey(), e.getValue());\n                    }\n                }\n            }\n            return super.visitSequenceOperator(result);\n        }\n        return node;\n    }", "signature": "OperatorNode<SequenceOperator> visitSequenceOperator(OperatorNode<SequenceOperator> node)", "full_signature": "@Override public OperatorNode<SequenceOperator> visitSequenceOperator(OperatorNode<SequenceOperator> node)", "class_method_signature": "JoinFilterPushDown.visitSequenceOperator(OperatorNode<SequenceOperator> node)", "testcase": false, "constructor": false, "invocations": ["getOperator", "visitSequenceOperator", "getArgument", "getArgument", "getOperator", "getOperator", "newArrayList", "newArrayList", "newArrayList", "getArgument", "getArgument", "getArgument", "getOperator", "flatten", "getArgument", "add", "iterator", "hasNext", "next", "findSources", "findSources", "findReferencedSources", "isEmpty", "intersection", "isEmpty", "intersection", "add", "remove", "add", "remove", "size", "visitSequenceOperator", "visitSequenceOperator", "create", "getLocation", "createFilter", "size", "visitSequenceOperator", "visitSequenceOperator", "create", "getLocation", "createFilter", "size", "size", "create", "getLocation", "getAnnotations", "getOperator", "size", "create", "getLocation", "getAnnotations", "getOperator", "createFilter", "entrySet", "getAnnotations", "putAnnotation", "getKey", "getValue", "visitSequenceOperator"]}, "repository": {"repo_id": 76505423, "url": "https://github.com/yahoo/yql-plus", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 30, "size": 1315, "license": "licensed"}}