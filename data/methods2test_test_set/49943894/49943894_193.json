{"test_class": {"identifier": "ProcessUtilTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "File pidFile;", "modifier": "", "type": "File", "declarator": "pidFile", "var_name": "pidFile"}], "file": "utils/src/test/java/com/cloud/utils/ProcessUtilTest.java"}, "test_case": {"identifier": "pidCheck", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void pidCheck() throws ConfigurationException, IOException {\n        Assume.assumeTrue(SystemUtils.IS_OS_LINUX);\n        FileUtils.writeStringToFile(pidFile, \"123456\\n\");\n        ProcessUtil.pidCheck(pidFile.getParent(), pidFile.getName());\n        String pidStr = FileUtils.readFileToString(pidFile);\n        Assert.assertFalse(\"pid can not be blank\", pidStr.isEmpty());\n        int pid = Integer.parseInt(pidStr.trim());\n        int maxPid = Integer.parseInt(FileUtils.readFileToString(new File(\"/proc/sys/kernel/pid_max\")).trim());\n        Assert.assertTrue(pid <= maxPid);\n    }", "signature": "void pidCheck()", "full_signature": "@Test public void pidCheck()", "class_method_signature": "ProcessUtilTest.pidCheck()", "testcase": true, "constructor": false, "invocations": ["assumeTrue", "writeStringToFile", "pidCheck", "getParent", "getName", "readFileToString", "assertFalse", "isEmpty", "parseInt", "trim", "parseInt", "trim", "readFileToString", "assertTrue"]}, "focal_class": {"identifier": "ProcessUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger s_logger = LoggerFactory.getLogger(ProcessUtil.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "s_logger = LoggerFactory.getLogger(ProcessUtil.class.getName())", "var_name": "s_logger"}], "methods": [{"identifier": "pidCheck", "parameters": "(String pidDir, String run)", "modifiers": "public static", "return": "void", "signature": "void pidCheck(String pidDir, String run)", "full_signature": "public static void pidCheck(String pidDir, String run)", "class_method_signature": "ProcessUtil.pidCheck(String pidDir, String run)", "testcase": false, "constructor": false}, {"identifier": "dumpStack", "parameters": "()", "modifiers": "public static", "return": "String", "signature": "String dumpStack()", "full_signature": "public static String dumpStack()", "class_method_signature": "ProcessUtil.dumpStack()", "testcase": false, "constructor": false}], "file": "utils/src/main/java/com/cloud/utils/ProcessUtil.java"}, "focal_method": {"identifier": "pidCheck", "parameters": "(String pidDir, String run)", "modifiers": "public static", "return": "void", "body": "public static void pidCheck(String pidDir, String run) throws ConfigurationException {\n\n        String dir = pidDir == null ? \"/var/run\" : pidDir;\n\n        try {\n            final File propsFile = PropertiesUtil.findConfigFile(\"environment.properties\");\n            if (propsFile == null) {\n                s_logger.debug(\"environment.properties could not be opened\");\n            } else {\n                final Properties props = PropertiesUtil.loadFromFile(propsFile);\n                dir = props.getProperty(\"paths.pid\");\n                if (dir == null) {\n                    dir = pidDir == null ? \"/var/run\" : pidDir;\n                }\n            }\n        } catch (IOException e) {\n            s_logger.debug(\"environment.properties could not be opened\");\n        }\n\n        final File pidFile = new File(dir + File.separator + run);\n        try {\n            if (!pidFile.createNewFile()) {\n                if (!pidFile.exists()) {\n                    throw new ConfigurationException(\"Unable to write to \" + pidFile.getAbsolutePath() + \".  Are you sure you're running as root?\");\n                }\n\n                final String pidLine = FileUtils.readFileToString(pidFile).trim();\n                if (pidLine.isEmpty()) {\n                    throw new ConfigurationException(\"Java process is being started twice.  If this is not true, remove \" + pidFile.getAbsolutePath());\n                }\n                try {\n                    final long pid = Long.parseLong(pidLine);\n                    final Script script = new Script(\"bash\", 120000, s_logger);\n                    script.add(\"-c\", \"ps -p \" + pid);\n                    final String result = script.execute();\n                    if (result == null) {\n                        throw new ConfigurationException(\"Java process is being started twice.  If this is not true, remove \" + pidFile.getAbsolutePath());\n                    }\n                    if (!pidFile.delete()) {\n                        throw new ConfigurationException(\"Java process is being started twice.  If this is not true, remove \" + pidFile.getAbsolutePath());\n                    }\n                    if (!pidFile.createNewFile()) {\n                        throw new ConfigurationException(\"Java process is being started twice.  If this is not true, remove \" + pidFile.getAbsolutePath());\n                    }\n                } catch (final NumberFormatException e) {\n                    throw new ConfigurationException(\"Java process is being started twice.  If this is not true, remove \" + pidFile.getAbsolutePath());\n                }\n            }\n            pidFile.deleteOnExit();\n\n            final Script script = new Script(\"bash\", 120000, s_logger);\n            script.add(\"-c\", \"echo $PPID\");\n            final OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser();\n            script.execute(parser);\n\n            final String pid = parser.getLine();\n\n            FileUtils.writeStringToFile(pidFile, pid + \"\\n\");\n        } catch (final IOException e) {\n            throw new CloudRuntimeException(\"Unable to create the \" + pidFile.getAbsolutePath() + \".  Are you running as root?\", e);\n        }\n    }", "signature": "void pidCheck(String pidDir, String run)", "full_signature": "public static void pidCheck(String pidDir, String run)", "class_method_signature": "ProcessUtil.pidCheck(String pidDir, String run)", "testcase": false, "constructor": false, "invocations": ["findConfigFile", "debug", "loadFromFile", "getProperty", "debug", "createNewFile", "exists", "getAbsolutePath", "trim", "readFileToString", "isEmpty", "getAbsolutePath", "parseLong", "add", "execute", "getAbsolutePath", "delete", "getAbsolutePath", "createNewFile", "getAbsolutePath", "getAbsolutePath", "deleteOnExit", "add", "execute", "getLine", "writeStringToFile", "getAbsolutePath"]}, "repository": {"repo_id": 49943894, "url": "https://github.com/MissionCriticalCloudOldRepos/cosmic-core", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 9, "size": 18165, "license": "licensed"}}