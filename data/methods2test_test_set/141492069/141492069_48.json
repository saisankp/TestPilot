{"test_class": {"identifier": "TestConfigurableUDPSource", "superclass": "extends UDPTestBase", "interfaces": "", "fields": [{"original_string": "FalseClient client;", "modifier": "", "type": "FalseClient", "declarator": "client", "var_name": "client"}, {"original_string": "String sourceName;", "modifier": "", "type": "String", "declarator": "sourceName", "var_name": "sourceName"}, {"original_string": "InetAddress invalidAddress;", "modifier": "", "type": "InetAddress", "declarator": "invalidAddress", "var_name": "invalidAddress"}], "file": "udpSource/src/test/java/io/vantiq/extsrc/udp/TestConfigurableUDPSource.java"}, "test_case": {"identifier": "testSetNotificationHandler", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSetNotificationHandler() throws UnknownHostException {\n        InetAddress address = InetAddress.getByName(\"localhost\");\n        int port = 10213;\n        \n        // ============== Use a map where all each has one valid entry ===============\n        Map<String,Object> incoming = new LinkedHashMap<>();\n        List<Object> l = new ArrayList<>(); l.add(\"localhost\"); l.add(\"notValidAddress\"); l.add(1354);\n        incoming.put(\"receiveAddresses\", l);\n        l = new ArrayList<>(); l.add(port); l.add(-1); l.add(123456789);\n        incoming.put(\"receivePorts\", l);\n        l = new ArrayList<>();\n        List<Object> subl = new ArrayList<>(); subl.add(\"invalid address\"); subl.add(2000); l.add(subl); // bad address\n        subl = new ArrayList<>(); subl.add(\"localhost\"); subl.add(-1); l.add(subl); // bad port\n        subl = new ArrayList<>(); subl.add(2000); subl.add(\"localhost\"); l.add(subl); // wrong order\n        subl = new ArrayList<>(); subl.add(\"localhost\"); subl.add(port); l.add(subl);\n        incoming.put(\"receiveServers\", l);\n        \n        UDPNotificationHandler handler = new UDPNotificationHandler(incoming, client);\n        \n        ConfigurableUDPSource.setNotificationHandler(handler, sourceName, incoming);\n        \n        assert ConfigurableUDPSource.notificationHandlers.get(sourceName) == handler;\n        l = (List) ConfigurableUDPSource.sourcePorts.get(sourceName);\n        assert l.contains(port);\n        assert l.size() == 1;\n        l = (List) ConfigurableUDPSource.sourceAddresses.get(sourceName);\n        assert l.contains(address);\n        assert l.size() == 1;\n        subl = new ArrayList<>(); subl.add(address); subl.add(port);\n        l = (List) ConfigurableUDPSource.sourceServers.get(sourceName);\n        assert l.contains(subl);\n        assert l.size() == 1;\n        \n        // =================== Use a map with ALL_ADDR/PORT set =================\n        ConfigurableUDPSource.sourceServers.clear(); // Don't need to clear the rest, they will be overwritten\n        incoming = new LinkedHashMap<>();\n        incoming.put(\"receiveAllAddresses\", true);\n        incoming.put(\"receiveAllPorts\", true);\n        \n        handler = new UDPNotificationHandler(incoming, client);\n        ConfigurableUDPSource.setNotificationHandler(handler, sourceName, incoming);\n        \n        assert ConfigurableUDPSource.notificationHandlers.get(sourceName) == handler;\n        String addr = (String) ConfigurableUDPSource.sourceAddresses.get(sourceName);\n        assert addr.equals(ConfigurableUDPSource.ALL_ADDR);\n        int prt = (Integer) ConfigurableUDPSource.sourcePorts.get(sourceName);\n        assert prt == ConfigurableUDPSource.ALL_PORTS;\n        \n        // =================== Use a map with only Servers set ==========================\n        incoming = new LinkedHashMap<>();\n        subl = new ArrayList<>(); subl.add(\"localhost\"); subl.add(port); l.add(subl);\n        incoming.put(\"receiveServers\", l);\n        \n        handler = new UDPNotificationHandler(incoming, client);\n        ConfigurableUDPSource.setNotificationHandler(handler, sourceName, incoming);\n        \n        assert ConfigurableUDPSource.notificationHandlers.get(sourceName) == handler;\n        addr = (String) ConfigurableUDPSource.sourceAddresses.get(sourceName);\n        assert addr.equals(ConfigurableUDPSource.NO_ADDR);\n        prt = (Integer) ConfigurableUDPSource.sourcePorts.get(sourceName);\n        assert prt == ConfigurableUDPSource.NO_PORTS;\n        subl = new ArrayList<>(); subl.add(address); subl.add(port);\n        l = (List) ConfigurableUDPSource.sourceServers.get(sourceName);\n        assert l.contains(subl);\n        assert l.size() == 1;\n    }", "signature": "void testSetNotificationHandler()", "full_signature": "@Test public void testSetNotificationHandler()", "class_method_signature": "TestConfigurableUDPSource.testSetNotificationHandler()", "testcase": true, "constructor": false, "invocations": ["getByName", "add", "add", "add", "put", "add", "add", "add", "put", "add", "add", "add", "add", "add", "add", "add", "add", "add", "add", "add", "add", "put", "setNotificationHandler", "get", "get", "contains", "size", "get", "contains", "size", "add", "add", "get", "contains", "size", "clear", "put", "put", "setNotificationHandler", "get", "get", "equals", "get", "add", "add", "add", "put", "setNotificationHandler", "get", "get", "equals", "get", "add", "add", "get", "contains", "size"]}, "focal_class": {"identifier": "ConfigurableUDPSource", "superclass": "", "interfaces": "", "fields": [{"original_string": "static Handler<ExtensionServiceMessage> UDPDefaultPublish = new Handler<ExtensionServiceMessage>() {\n        @Override\n        public void handleMessage(ExtensionServiceMessage message) {\n            // Translate the data from the Publish message to what we want it to be\n            log.warn(\"Vantiq requesting message sent from {}, but no handler is set up for it\", message.getSourceName());\n        }\n    };", "modifier": "static", "type": "Handler<ExtensionServiceMessage>", "declarator": "UDPDefaultPublish = new Handler<ExtensionServiceMessage>() {\n        @Override\n        public void handleMessage(ExtensionServiceMessage message) {\n            // Translate the data from the Publish message to what we want it to be\n            log.warn(\"Vantiq requesting message sent from {}, but no handler is set up for it\", message.getSourceName());\n        }\n    }", "var_name": "UDPDefaultPublish"}, {"original_string": "static UDPConfigHandler UDPConfig = new UDPConfigHandler();", "modifier": "static", "type": "UDPConfigHandler", "declarator": "UDPConfig = new UDPConfigHandler()", "var_name": "UDPConfig"}, {"original_string": "static Handler<ExtensionServiceMessage> UDPReconnectHandler = new Handler<ExtensionServiceMessage>() {\n\n        @Override\n        public void handleMessage(ExtensionServiceMessage message) {\n            clearSourceHandlers(message.getSourceName());\n            \n            ExtensionWebSocketClient client = clients.get(message.getSourceName());\n            client.connectToSource();\n            try {\n                if (client.getSourceConnectionFuture().get(10, TimeUnit.SECONDS) == false) {\n                    client.stop();\n                }\n            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                client.stop();\n                e.printStackTrace();\n            }\n        }\n        \n    };", "modifier": "static", "type": "Handler<ExtensionServiceMessage>", "declarator": "UDPReconnectHandler = new Handler<ExtensionServiceMessage>() {\n\n        @Override\n        public void handleMessage(ExtensionServiceMessage message) {\n            clearSourceHandlers(message.getSourceName());\n            \n            ExtensionWebSocketClient client = clients.get(message.getSourceName());\n            client.connectToSource();\n            try {\n                if (client.getSourceConnectionFuture().get(10, TimeUnit.SECONDS) == false) {\n                    client.stop();\n                }\n            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                client.stop();\n                e.printStackTrace();\n            }\n        }\n        \n    }", "var_name": "UDPReconnectHandler"}, {"original_string": "static Handler<ExtensionWebSocketClient> UDPCloseHandler = new Handler<ExtensionWebSocketClient>() {\n        @Override\n        public void handleMessage(ExtensionWebSocketClient client) {\n            clearSourceHandlers(client.getSourceName());\n            \n            client.initiateFullConnection(targetVantiqServer, authToken);\n            try {\n                if (client.getSourceConnectionFuture().get(10, TimeUnit.SECONDS) == false) {\n                    client.stop();\n                }\n            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                client.stop();\n                e.printStackTrace();\n            }\n        }\n    };", "modifier": "static", "type": "Handler<ExtensionWebSocketClient>", "declarator": "UDPCloseHandler = new Handler<ExtensionWebSocketClient>() {\n        @Override\n        public void handleMessage(ExtensionWebSocketClient client) {\n            clearSourceHandlers(client.getSourceName());\n            \n            client.initiateFullConnection(targetVantiqServer, authToken);\n            try {\n                if (client.getSourceConnectionFuture().get(10, TimeUnit.SECONDS) == false) {\n                    client.stop();\n                }\n            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                client.stop();\n                e.printStackTrace();\n            }\n        }\n    }", "var_name": "UDPCloseHandler"}, {"original_string": "static Map<String, UDPNotificationHandler> notificationHandlers = new ConcurrentHashMap<>();", "modifier": "static", "type": "Map<String, UDPNotificationHandler>", "declarator": "notificationHandlers = new ConcurrentHashMap<>()", "var_name": "notificationHandlers"}, {"original_string": "static Map<String, Object> sourceAddresses = new LinkedHashMap<>();", "modifier": "static", "type": "Map<String, Object>", "declarator": "sourceAddresses = new LinkedHashMap<>()", "var_name": "sourceAddresses"}, {"original_string": "static Map<String, Object> sourcePorts = new LinkedHashMap<>();", "modifier": "static", "type": "Map<String, Object>", "declarator": "sourcePorts = new LinkedHashMap<>()", "var_name": "sourcePorts"}, {"original_string": "static Map<String, List<List>> sourceServers = new LinkedHashMap<>();", "modifier": "static", "type": "Map<String, List<List>>", "declarator": "sourceServers = new LinkedHashMap<>()", "var_name": "sourceServers"}, {"original_string": "static Map<DatagramSocket, List<String>> udpSocketToSources = new LinkedHashMap<>();", "modifier": "static", "type": "Map<DatagramSocket, List<String>>", "declarator": "udpSocketToSources = new LinkedHashMap<>()", "var_name": "udpSocketToSources"}, {"original_string": "static Object socketLock = new Object();", "modifier": "static", "type": "Object", "declarator": "socketLock = new Object()", "var_name": "socketLock"}, {"original_string": "static Map<String, ExtensionWebSocketClient> clients = new LinkedHashMap<>();", "modifier": "static", "type": "Map<String, ExtensionWebSocketClient>", "declarator": "clients = new LinkedHashMap<>()", "var_name": "clients"}, {"original_string": "static InetAddress LISTENING_ADDRESS = null;", "modifier": "static", "type": "InetAddress", "declarator": "LISTENING_ADDRESS = null", "var_name": "LISTENING_ADDRESS"}, {"original_string": "static int LISTENING_PORT = 3141;", "modifier": "static", "type": "int", "declarator": "LISTENING_PORT = 3141", "var_name": "LISTENING_PORT"}, {"original_string": "static int MAX_UDP_DATA = 1024;", "modifier": "static", "type": "int", "declarator": "MAX_UDP_DATA = 1024", "var_name": "MAX_UDP_DATA"}, {"original_string": "static final Logger log = LoggerFactory.getLogger(ConfigurableUDPSource.class);", "modifier": "static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(ConfigurableUDPSource.class)", "var_name": "log"}, {"original_string": "static final String ALL_ADDR = \"_ALL\";", "modifier": "static final", "type": "String", "declarator": "ALL_ADDR = \"_ALL\"", "var_name": "ALL_ADDR"}, {"original_string": "static final int ALL_PORTS = -1;", "modifier": "static final", "type": "int", "declarator": "ALL_PORTS = -1", "var_name": "ALL_PORTS"}, {"original_string": "static final String NO_ADDR = \"_NONE\";", "modifier": "static final", "type": "String", "declarator": "NO_ADDR = \"_NONE\"", "var_name": "NO_ADDR"}, {"original_string": "static final int NO_PORTS = -2;", "modifier": "static final", "type": "int", "declarator": "NO_PORTS = -2", "var_name": "NO_PORTS"}, {"original_string": "static String targetVantiqServer = null;", "modifier": "static", "type": "String", "declarator": "targetVantiqServer = null", "var_name": "targetVantiqServer"}, {"original_string": "static String authToken = null;", "modifier": "static", "type": "String", "declarator": "authToken = null", "var_name": "authToken"}], "methods": [{"identifier": "clearSourceHandlers", "parameters": "(String sourceName)", "modifiers": "static", "return": "void", "signature": "void clearSourceHandlers(String sourceName)", "full_signature": "static void clearSourceHandlers(String sourceName)", "class_method_signature": "ConfigurableUDPSource.clearSourceHandlers(String sourceName)", "testcase": false, "constructor": false}, {"identifier": "createUDPSocket", "parameters": "(int port, InetAddress address, String sourceName)", "modifiers": "public static", "return": "DatagramSocket", "signature": "DatagramSocket createUDPSocket(int port, InetAddress address, String sourceName)", "full_signature": "public static DatagramSocket createUDPSocket(int port, InetAddress address, String sourceName)", "class_method_signature": "ConfigurableUDPSource.createUDPSocket(int port, InetAddress address, String sourceName)", "testcase": false, "constructor": false}, {"identifier": "listenOnUDPSocket", "parameters": "(int port, InetAddress address, String sourceName)", "modifiers": "public static", "return": "DatagramSocket", "signature": "DatagramSocket listenOnUDPSocket(int port, InetAddress address, String sourceName)", "full_signature": "public static DatagramSocket listenOnUDPSocket(int port, InetAddress address, String sourceName)", "class_method_signature": "ConfigurableUDPSource.listenOnUDPSocket(int port, InetAddress address, String sourceName)", "testcase": false, "constructor": false}, {"identifier": "setNotificationHandler", "parameters": "(UDPNotificationHandler handler, String sourceName, Map incoming)", "modifiers": "public static", "return": "void", "signature": "void setNotificationHandler(UDPNotificationHandler handler, String sourceName, Map incoming)", "full_signature": "public static void setNotificationHandler(UDPNotificationHandler handler, String sourceName, Map incoming)", "class_method_signature": "ConfigurableUDPSource.setNotificationHandler(UDPNotificationHandler handler, String sourceName, Map incoming)", "testcase": false, "constructor": false}, {"identifier": "getValidInetAddresses", "parameters": "(List potentialAddresses, String sourceName)", "modifiers": "static", "return": "List<InetAddress>", "signature": "List<InetAddress> getValidInetAddresses(List potentialAddresses, String sourceName)", "full_signature": "static List<InetAddress> getValidInetAddresses(List potentialAddresses, String sourceName)", "class_method_signature": "ConfigurableUDPSource.getValidInetAddresses(List potentialAddresses, String sourceName)", "testcase": false, "constructor": false}, {"identifier": "getValidPorts", "parameters": "(List potentialPorts)", "modifiers": "static", "return": "List<Integer>", "signature": "List<Integer> getValidPorts(List potentialPorts)", "full_signature": "static List<Integer> getValidPorts(List potentialPorts)", "class_method_signature": "ConfigurableUDPSource.getValidPorts(List potentialPorts)", "testcase": false, "constructor": false}, {"identifier": "getValidServers", "parameters": "(List potentialServers)", "modifiers": "static", "return": "List<List>", "signature": "List<List> getValidServers(List potentialServers)", "full_signature": "static List<List> getValidServers(List potentialServers)", "class_method_signature": "ConfigurableUDPSource.getValidServers(List potentialServers)", "testcase": false, "constructor": false}, {"identifier": "isValidServer", "parameters": "(Object server)", "modifiers": "static", "return": "boolean", "signature": "boolean isValidServer(Object server)", "full_signature": "static boolean isValidServer(Object server)", "class_method_signature": "ConfigurableUDPSource.isValidServer(Object server)", "testcase": false, "constructor": false}, {"identifier": "obtainServerConfig", "parameters": "(String fileName)", "modifiers": "static", "return": "Map<String, Object>", "signature": "Map<String, Object> obtainServerConfig(String fileName)", "full_signature": "static Map<String, Object> obtainServerConfig(String fileName)", "class_method_signature": "ConfigurableUDPSource.obtainServerConfig(String fileName)", "testcase": false, "constructor": false}, {"identifier": "setupServer", "parameters": "(Map config)", "modifiers": "static", "return": "void", "signature": "void setupServer(Map config)", "full_signature": "static void setupServer(Map config)", "class_method_signature": "ConfigurableUDPSource.setupServer(Map config)", "testcase": false, "constructor": false}, {"identifier": "main", "parameters": "(String[] args)", "modifiers": "public static", "return": "void", "signature": "void main(String[] args)", "full_signature": "public static void main(String[] args)", "class_method_signature": "ConfigurableUDPSource.main(String[] args)", "testcase": false, "constructor": false}, {"identifier": "sendFromDatagram", "parameters": "(DatagramPacket packet, List<String> sources)", "modifiers": "public static", "return": "void", "signature": "void sendFromDatagram(DatagramPacket packet, List<String> sources)", "full_signature": "public static void sendFromDatagram(DatagramPacket packet, List<String> sources)", "class_method_signature": "ConfigurableUDPSource.sendFromDatagram(DatagramPacket packet, List<String> sources)", "testcase": false, "constructor": false}, {"identifier": "receivingFromServer", "parameters": "(String sourceName, int port, InetAddress address)", "modifiers": "static", "return": "boolean", "signature": "boolean receivingFromServer(String sourceName, int port, InetAddress address)", "full_signature": "static boolean receivingFromServer(String sourceName, int port, InetAddress address)", "class_method_signature": "ConfigurableUDPSource.receivingFromServer(String sourceName, int port, InetAddress address)", "testcase": false, "constructor": false}, {"identifier": "matchesPort", "parameters": "(String sourceName, int port)", "modifiers": "static", "return": "boolean", "signature": "boolean matchesPort(String sourceName, int port)", "full_signature": "static boolean matchesPort(String sourceName, int port)", "class_method_signature": "ConfigurableUDPSource.matchesPort(String sourceName, int port)", "testcase": false, "constructor": false}, {"identifier": "matchesAddress", "parameters": "(String sourceName, InetAddress address)", "modifiers": "static", "return": "boolean", "signature": "boolean matchesAddress(String sourceName, InetAddress address)", "full_signature": "static boolean matchesAddress(String sourceName, InetAddress address)", "class_method_signature": "ConfigurableUDPSource.matchesAddress(String sourceName, InetAddress address)", "testcase": false, "constructor": false}, {"identifier": "matchesServer", "parameters": "(String sourceName, int port, InetAddress address)", "modifiers": "static", "return": "boolean", "signature": "boolean matchesServer(String sourceName, int port, InetAddress address)", "full_signature": "static boolean matchesServer(String sourceName, int port, InetAddress address)", "class_method_signature": "ConfigurableUDPSource.matchesServer(String sourceName, int port, InetAddress address)", "testcase": false, "constructor": false}, {"identifier": "valueIsTrue", "parameters": "(Map map, Object key)", "modifiers": "static", "return": "boolean", "signature": "boolean valueIsTrue(Map map, Object key)", "full_signature": "static boolean valueIsTrue(Map map, Object key)", "class_method_signature": "ConfigurableUDPSource.valueIsTrue(Map map, Object key)", "testcase": false, "constructor": false}], "file": "udpSource/src/main/java/io/vantiq/extsrc/udp/ConfigurableUDPSource.java"}, "focal_method": {"identifier": "setNotificationHandler", "parameters": "(UDPNotificationHandler handler, String sourceName, Map incoming)", "modifiers": "public static", "return": "void", "body": "public static void setNotificationHandler(UDPNotificationHandler handler, String sourceName, Map incoming) {\n        log.trace(\"Setting Notification handler for '{}'\", sourceName);\n        notificationHandlers.put(sourceName, handler);\n\n        List<InetAddress> addresses = null;\n        List<Integer> ports = null;\n        List<List> servers = null;\n\n        // Obtain all valid addresses, ports, and servers from the respective arrays specified in the configuration document\n        if (incoming != null) {\n            if (incoming.get(\"receiveAddresses\") instanceof List) {\n                addresses = getValidInetAddresses((List) incoming.get(\"receiveAddresses\"), sourceName);\n            }\n            if (incoming.get(\"receivePorts\") instanceof List) {\n                ports = getValidPorts((List) incoming.get(\"receivePorts\"));\n            }\n            if (incoming.get(\"receiveServers\") instanceof List) {\n                servers = getValidServers((List) incoming.get(\"receiveServers\"));\n            }\n        }\n\n        // Use the addresses specified\n        if (addresses != null) {\n            sourceAddresses.put(sourceName, addresses);\n            log.debug(\"Source '{}' listening for addresses {}\", sourceName, addresses);\n        }\n        // We should ignore all addresses only if there are requested servers and no valid settings for addresses or ports\n        else if (servers != null && !valueIsTrue(incoming, \"receiveAllAddresses\")\n                && !valueIsTrue(incoming, \"receiveAllPorts\") && ports == null) {\n            sourceAddresses.put(sourceName, NO_ADDR);\n        }\n        // Either receiveAllAddresses is set to true with no addresses specified\n        // or the settings allow defaulting to all addresses\n        else {\n            sourceAddresses.put(sourceName, ALL_ADDR);\n            log.debug(\"Source '{}' listening for all addresses\", sourceName);\n        }\n\n        // Use the ports if specified\n        if (ports != null) {\n            sourcePorts.put(sourceName, ports);\n            log.debug(\"Source '{}' listening on ports {}\", sourceName, ports);\n        }\n        // We should ignore all ports only if there are requested servers and no valid settings for addresses or ports\n        else if (servers != null && !valueIsTrue(incoming, \"receiveAllAddresses\")\n                && !valueIsTrue(incoming, \"receiveAllPorts\") && addresses == null) {\n            sourcePorts.put(sourceName, NO_PORTS);\n        }\n        // Either receiveAllPorts is set to true with no ports specified or the settings allow defaulting to all ports\n        else {\n            sourcePorts.put(sourceName, ALL_PORTS);\n            log.debug(\"Source '{}' listening on all ports\", sourceName);\n        }\n\n        // Use the servers specified\n        if (servers != null) {\n            sourceServers.put(sourceName, servers);\n        }\n    }", "signature": "void setNotificationHandler(UDPNotificationHandler handler, String sourceName, Map incoming)", "full_signature": "public static void setNotificationHandler(UDPNotificationHandler handler, String sourceName, Map incoming)", "class_method_signature": "ConfigurableUDPSource.setNotificationHandler(UDPNotificationHandler handler, String sourceName, Map incoming)", "testcase": false, "constructor": false, "invocations": ["trace", "put", "get", "getValidInetAddresses", "get", "get", "getValidPorts", "get", "get", "getValidServers", "get", "put", "debug", "valueIsTrue", "valueIsTrue", "put", "put", "debug", "put", "debug", "valueIsTrue", "valueIsTrue", "put", "put", "debug", "put"]}, "repository": {"repo_id": 141492069, "url": "https://github.com/Vantiq/vantiq-extension-sources", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 9, "size": 16261, "license": "licensed"}}