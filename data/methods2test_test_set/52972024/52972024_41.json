{"test_class": {"identifier": "CheckpointActorTest", "superclass": "extends PluginsLoadingTestBase", "interfaces": "", "fields": [{"original_string": "private final Object connectionPool = new Object();", "modifier": "private final", "type": "Object", "declarator": "connectionPool = new Object()", "var_name": "connectionPool"}, {"original_string": "private final Object connectionOptions = new Object();", "modifier": "private final", "type": "Object", "declarator": "connectionOptions = new Object()", "var_name": "connectionOptions"}, {"original_string": "private IQueue taskQueueMock;", "modifier": "private", "type": "IQueue", "declarator": "taskQueueMock", "var_name": "taskQueueMock"}, {"original_string": "private ISchedulerEntryStorage storageMock;", "modifier": "private", "type": "ISchedulerEntryStorage", "declarator": "storageMock", "var_name": "storageMock"}, {"original_string": "private ISchedulerService serviceMock;", "modifier": "private", "type": "ISchedulerService", "declarator": "serviceMock", "var_name": "serviceMock"}, {"original_string": "private IAction activationActionMock;", "modifier": "private", "type": "IAction", "declarator": "activationActionMock", "var_name": "activationActionMock"}, {"original_string": "private IMessageBusHandler messageBusHandlerMock;", "modifier": "private", "type": "IMessageBusHandler", "declarator": "messageBusHandlerMock", "var_name": "messageBusHandlerMock"}, {"original_string": "private ISchedulerEntryStorageObserver observer;", "modifier": "private", "type": "ISchedulerEntryStorageObserver", "declarator": "observer", "var_name": "observer"}, {"original_string": "private final String collectionName = \"the_collection_name\";", "modifier": "private final", "type": "String", "declarator": "collectionName = \"the_collection_name\"", "var_name": "collectionName"}, {"original_string": "private IResolveDependencyStrategy newEntryStrategyMock;", "modifier": "private", "type": "IResolveDependencyStrategy", "declarator": "newEntryStrategyMock", "var_name": "newEntryStrategyMock"}, {"original_string": "private ISchedulerEntry entryMock[];", "modifier": "private", "type": "ISchedulerEntry", "declarator": "entryMock[]", "var_name": "entryMock"}, {"original_string": "private EnteringMessage enteringMessageMock;", "modifier": "private", "type": "EnteringMessage", "declarator": "enteringMessageMock", "var_name": "enteringMessageMock"}, {"original_string": "private FeedbackMessage feedbackMessageMock;", "modifier": "private", "type": "FeedbackMessage", "declarator": "feedbackMessageMock", "var_name": "feedbackMessageMock"}, {"original_string": "private ArgumentCaptor<Object> objectsArgumentCaptor;", "modifier": "private", "type": "ArgumentCaptor<Object>", "declarator": "objectsArgumentCaptor", "var_name": "objectsArgumentCaptor"}, {"original_string": "private ArgumentCaptor<IObject> iObjectArgumentCaptor;", "modifier": "private", "type": "ArgumentCaptor<IObject>", "declarator": "iObjectArgumentCaptor", "var_name": "iObjectArgumentCaptor"}, {"original_string": "private IMessageProcessor messageProcessorMock;", "modifier": "private", "type": "IMessageProcessor", "declarator": "messageProcessorMock", "var_name": "messageProcessorMock"}, {"original_string": "private IMessageProcessingSequence messageProcessingSequenceMock;", "modifier": "private", "type": "IMessageProcessingSequence", "declarator": "messageProcessingSequenceMock", "var_name": "messageProcessingSequenceMock"}, {"original_string": "private IUpCounter upCounterMock;", "modifier": "private", "type": "IUpCounter", "declarator": "upCounterMock", "var_name": "upCounterMock"}], "file": "CoreFeatures/Checkpoint/CheckpointActor/src/test/java/info/smart_tools/smartactors/checkpoint/checkpoint_actor/CheckpointActorTest.java"}, "test_case": {"identifier": "Should_createNewEntryForNewEnteringMessage", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void Should_createNewEntryForNewEnteringMessage()\n            throws Exception {\n        IObject args = IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.iobject.IObject\"),\n                (\"{\" +\n                        \"'connectionOptionsDependency':'the connection options',\" +\n                        \"'connectionPoolDependency':'the connection pool',\" +\n                        \"'collectionName':'\" + collectionName + \"'\" +\n                        \"}\").replace('\\'','\"'));\n\n        CheckpointActor actor = new CheckpointActor(args);\n\n        IObject message = IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.iobject.IObject\"),\n                \"{'theUniqueAndVeryImportantField':'42'}\".replace('\\'','\"'));\n\n        when(enteringMessageMock.getCheckpointId()).thenReturn(\"thisCp\");\n        when(enteringMessageMock.getCheckpointStatus()).thenReturn(null);\n        when(enteringMessageMock.getMessage()).thenReturn(message);\n        when(enteringMessageMock.getProcessor()).thenReturn(messageProcessorMock);\n        when(enteringMessageMock.getRecoverConfiguration()).thenReturn(mock(IObject.class));\n        when(enteringMessageMock.getSchedulingConfiguration()).thenReturn(mock(IObject.class));\n\n        when(newEntryStrategyMock.resolve(objectsArgumentCaptor.capture())).thenReturn(entryMock[0]);\n        when(entryMock[0].getId()).thenReturn(\"entry0\");\n\n        actor.enter(enteringMessageMock);\n\n        verify(newEntryStrategyMock).resolve(any(), any());\n\n        assertSame(storageMock, objectsArgumentCaptor.getAllValues().get(1));\n\n        IObject entryArgs = (IObject) objectsArgumentCaptor.getAllValues().get(0);\n\n        assertSame(enteringMessageMock.getRecoverConfiguration(),\n                entryArgs.getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"), \"recover\")));\n        assertSame(enteringMessageMock.getSchedulingConfiguration(),\n                entryArgs.getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"), \"scheduling\")));\n        assertEquals(\"checkpoint scheduler action\",\n                entryArgs.getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"), \"action\")));\n        assertEquals(\"42\",\n                ((IObject) entryArgs.getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"), \"message\")))\n                    .getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"), \"theUniqueAndVeryImportantField\")));\n        assertNotSame(message, entryArgs.getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"), \"message\")));\n        assertSame(messageProcessorMock, entryArgs.getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"), \"processor\")));\n\n        verify(enteringMessageMock).setCheckpointStatus(iObjectArgumentCaptor.capture());\n\n        IObject newCS = iObjectArgumentCaptor.getValue();\n\n        assertEquals(\"thisCp\", newCS.getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"), \"responsibleCheckpointId\")));\n        assertEquals(\"entry0\", newCS.getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"), \"checkpointEntryId\")));\n    }", "signature": "void Should_createNewEntryForNewEnteringMessage()", "full_signature": "@Test public void Should_createNewEntryForNewEnteringMessage()", "class_method_signature": "CheckpointActorTest.Should_createNewEntryForNewEnteringMessage()", "testcase": true, "constructor": false, "invocations": ["resolve", "getOrAdd", "replace", "resolve", "getOrAdd", "replace", "thenReturn", "when", "getCheckpointId", "thenReturn", "when", "getCheckpointStatus", "thenReturn", "when", "getMessage", "thenReturn", "when", "getProcessor", "thenReturn", "when", "getRecoverConfiguration", "mock", "thenReturn", "when", "getSchedulingConfiguration", "mock", "thenReturn", "when", "resolve", "capture", "thenReturn", "when", "getId", "enter", "resolve", "verify", "any", "any", "assertSame", "get", "getAllValues", "get", "getAllValues", "assertSame", "getRecoverConfiguration", "getValue", "resolve", "getOrAdd", "assertSame", "getSchedulingConfiguration", "getValue", "resolve", "getOrAdd", "assertEquals", "getValue", "resolve", "getOrAdd", "assertEquals", "getValue", "getValue", "resolve", "getOrAdd", "resolve", "getOrAdd", "assertNotSame", "getValue", "resolve", "getOrAdd", "assertSame", "getValue", "resolve", "getOrAdd", "setCheckpointStatus", "verify", "capture", "getValue", "assertEquals", "getValue", "resolve", "getOrAdd", "assertEquals", "getValue", "resolve", "getOrAdd"]}, "focal_class": {"identifier": "CheckpointActor", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String FEEDBACK_CHAIN_NAME = \"checkpoint_feedback_chain\";", "modifier": "private static final", "type": "String", "declarator": "FEEDBACK_CHAIN_NAME = \"checkpoint_feedback_chain\"", "var_name": "FEEDBACK_CHAIN_NAME"}, {"original_string": "private static final String CHECKPOINT_ACTION = \"checkpoint scheduler action\";", "modifier": "private static final", "type": "String", "declarator": "CHECKPOINT_ACTION = \"checkpoint scheduler action\"", "var_name": "CHECKPOINT_ACTION"}, {"original_string": "private static final long COMPLETE_ENTRY_RESCHEDULE_DELAY = 1000;", "modifier": "private static final", "type": "long", "declarator": "COMPLETE_ENTRY_RESCHEDULE_DELAY = 1000", "var_name": "COMPLETE_ENTRY_RESCHEDULE_DELAY"}, {"original_string": "private final ISchedulerService service;", "modifier": "private final", "type": "ISchedulerService", "declarator": "service", "var_name": "service"}, {"original_string": "private final Object feedbackChainId;", "modifier": "private final", "type": "Object", "declarator": "feedbackChainId", "var_name": "feedbackChainId"}, {"original_string": "private final CheckpointSchedulerEntryStorageObserver storageObserver;", "modifier": "private final", "type": "CheckpointSchedulerEntryStorageObserver", "declarator": "storageObserver", "var_name": "storageObserver"}, {"original_string": "private final IFieldName responsibleCheckpointIdFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "responsibleCheckpointIdFieldName", "var_name": "responsibleCheckpointIdFieldName"}, {"original_string": "private final IFieldName checkpointEntryIdFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "checkpointEntryIdFieldName", "var_name": "checkpointEntryIdFieldName"}, {"original_string": "private final IFieldName schedulingFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "schedulingFieldName", "var_name": "schedulingFieldName"}, {"original_string": "private final IFieldName messageFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "messageFieldName", "var_name": "messageFieldName"}, {"original_string": "private final IFieldName prevCheckpointEntryIdFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "prevCheckpointEntryIdFieldName", "var_name": "prevCheckpointEntryIdFieldName"}, {"original_string": "private final IFieldName prevCheckpointIdFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "prevCheckpointIdFieldName", "var_name": "prevCheckpointIdFieldName"}, {"original_string": "private final IFieldName actionFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "actionFieldName", "var_name": "actionFieldName"}, {"original_string": "private final IFieldName recoverFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "recoverFieldName", "var_name": "recoverFieldName"}, {"original_string": "private final IFieldName completedFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "completedFieldName", "var_name": "completedFieldName"}, {"original_string": "private final IFieldName gotFeedbackFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "gotFeedbackFieldName", "var_name": "gotFeedbackFieldName"}, {"original_string": "private final IFieldName processorFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "processorFieldName", "var_name": "processorFieldName"}], "methods": [{"identifier": "CheckpointActor", "parameters": "(final IObject args)", "modifiers": "public", "return": "", "signature": " CheckpointActor(final IObject args)", "full_signature": "public  CheckpointActor(final IObject args)", "class_method_signature": "CheckpointActor.CheckpointActor(final IObject args)", "testcase": false, "constructor": true}, {"identifier": "enter", "parameters": "(final EnteringMessage message)", "modifiers": "public", "return": "void", "signature": "void enter(final EnteringMessage message)", "full_signature": "public void enter(final EnteringMessage message)", "class_method_signature": "CheckpointActor.enter(final EnteringMessage message)", "testcase": false, "constructor": false}, {"identifier": "feedback", "parameters": "(final FeedbackMessage message)", "modifiers": "public", "return": "void", "signature": "void feedback(final FeedbackMessage message)", "full_signature": "public void feedback(final FeedbackMessage message)", "class_method_signature": "CheckpointActor.feedback(final FeedbackMessage message)", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "(final StartStopMessage message)", "modifiers": "public", "return": "void", "signature": "void start(final StartStopMessage message)", "full_signature": "public void start(final StartStopMessage message)", "class_method_signature": "CheckpointActor.start(final StartStopMessage message)", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "(final StartStopMessage message)", "modifiers": "public", "return": "void", "signature": "void stop(final StartStopMessage message)", "full_signature": "public void stop(final StartStopMessage message)", "class_method_signature": "CheckpointActor.stop(final StartStopMessage message)", "testcase": false, "constructor": false}, {"identifier": "configure", "parameters": "(final ConfigureMessage message)", "modifiers": "public", "return": "void", "signature": "void configure(final ConfigureMessage message)", "full_signature": "public void configure(final ConfigureMessage message)", "class_method_signature": "CheckpointActor.configure(final ConfigureMessage message)", "testcase": false, "constructor": false}, {"identifier": "cloneMessage", "parameters": "(final IObject message)", "modifiers": "private", "return": "IObject", "signature": "IObject cloneMessage(final IObject message)", "full_signature": "private IObject cloneMessage(final IObject message)", "class_method_signature": "CheckpointActor.cloneMessage(final IObject message)", "testcase": false, "constructor": false}, {"identifier": "sendFeedback", "parameters": "(final IObject checkpointStatus, final String fromCheckpoint, final String newId)", "modifiers": "private", "return": "void", "signature": "void sendFeedback(final IObject checkpointStatus, final String fromCheckpoint, final String newId)", "full_signature": "private void sendFeedback(final IObject checkpointStatus, final String fromCheckpoint, final String newId)", "class_method_signature": "CheckpointActor.sendFeedback(final IObject checkpointStatus, final String fromCheckpoint, final String newId)", "testcase": false, "constructor": false}], "file": "CoreFeatures/Checkpoint/CheckpointActor/src/main/java/info/smart_tools/smartactors/checkpoint/checkpoint_actor/CheckpointActor.java"}, "focal_method": {"identifier": "enter", "parameters": "(final EnteringMessage message)", "modifiers": "public", "return": "void", "body": "public void enter(final EnteringMessage message)\n            throws ReadValueException, InvalidArgumentException, ResolutionException, ChangeValueException,\n            SendingMessageException, SerializeException {\n        IObject originalCheckpointStatus = message.getCheckpointStatus();\n\n        if (null != originalCheckpointStatus) {\n            ISchedulerEntry presentEntry = storageObserver\n                    .getPresentEntry(originalCheckpointStatus.getValue(checkpointEntryIdFieldName).toString());\n\n            if (null != presentEntry) {\n                // If this checkpoint already received the message and has entry for it ...\n                // Notify (again) previous checkpoint\n                sendFeedback(originalCheckpointStatus, message.getCheckpointId(),\n                        presentEntry.getId());\n\n                // And stop processing of the message\n                message.getProcessor().getSequence().end();\n                return;\n            }\n        }\n\n        IObject entryArguments = IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.iobject.IObject\"));\n\n        entryArguments.setValue(schedulingFieldName, message.getSchedulingConfiguration());\n        entryArguments.setValue(messageFieldName, cloneMessage(message.getMessage()));\n\n        if (null != originalCheckpointStatus) {\n            entryArguments.setValue(prevCheckpointEntryIdFieldName,\n                    originalCheckpointStatus.getValue(responsibleCheckpointIdFieldName));\n            entryArguments.setValue(prevCheckpointIdFieldName,\n                    originalCheckpointStatus.getValue(checkpointEntryIdFieldName));\n        }\n\n        // Checkpoint action will initialize recover strategy\n        entryArguments.setValue(recoverFieldName, message.getRecoverConfiguration());\n        entryArguments.setValue(actionFieldName, CHECKPOINT_ACTION);\n        entryArguments.setValue(processorFieldName, message.getProcessor());\n\n        ISchedulerEntry entry = IOC.resolve(Keys.getOrAdd(\"new scheduler entry\"), entryArguments, service.getEntryStorage());\n\n        // Update checkpoint status in message.\n        // Checkpoint status of re-sent messages will be set by checkpoint scheduler action.\n        IObject newCheckpointStatus = IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.iobject.IObject\"));\n\n        newCheckpointStatus.setValue(responsibleCheckpointIdFieldName, message.getCheckpointId());\n        newCheckpointStatus.setValue(checkpointEntryIdFieldName, entry.getId());\n\n        message.setCheckpointStatus(newCheckpointStatus);\n\n        // Send feedback message to previous checkpoint\n        if (null != originalCheckpointStatus) {\n            sendFeedback(originalCheckpointStatus, message.getCheckpointId(), entry.getId());\n        }\n    }", "signature": "void enter(final EnteringMessage message)", "full_signature": "public void enter(final EnteringMessage message)", "class_method_signature": "CheckpointActor.enter(final EnteringMessage message)", "testcase": false, "constructor": false, "invocations": ["getCheckpointStatus", "getPresentEntry", "toString", "getValue", "sendFeedback", "getCheckpointId", "getId", "end", "getSequence", "getProcessor", "resolve", "getOrAdd", "setValue", "getSchedulingConfiguration", "setValue", "cloneMessage", "getMessage", "setValue", "getValue", "setValue", "getValue", "setValue", "getRecoverConfiguration", "setValue", "setValue", "getProcessor", "resolve", "getOrAdd", "getEntryStorage", "resolve", "getOrAdd", "setValue", "getCheckpointId", "setValue", "getId", "setCheckpointStatus", "sendFeedback", "getCheckpointId", "getId"]}, "repository": {"repo_id": 52972024, "url": "https://github.com/SmartTools/smartactors-core", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 17, "size": 58816, "license": "licensed"}}