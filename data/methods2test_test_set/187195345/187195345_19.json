{"test_class": {"identifier": "OpenLRBinaryDecoderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int RFU_POSITION_IN_HEADER = 128;", "modifier": "private static final", "type": "int", "declarator": "RFU_POSITION_IN_HEADER = 128", "var_name": "RFU_POSITION_IN_HEADER"}, {"original_string": "private static final byte[] VALID_BIN_DATA_POS_OFFSET_V2 = {10, 4, 91, 91,\n            35, 70, -11, 26, 108, 9, 0, -102, -2, 59, 27, -76, 4, -1, -21, -1, -92,\n            43, 121, 3, 2};", "modifier": "private static final", "type": "byte[]", "declarator": "VALID_BIN_DATA_POS_OFFSET_V2 = {10, 4, 91, 91,\n            35, 70, -11, 26, 108, 9, 0, -102, -2, 59, 27, -76, 4, -1, -21, -1, -92,\n            43, 121, 3, 2}", "var_name": "VALID_BIN_DATA_POS_OFFSET_V2"}, {"original_string": "private static final byte[] VALID_BIN_DATA_OFFSETS_V3 = {11, 4, 91, 91,\n            35, 70, -11, 26, 108, 9, 0, -102, -2, 59, 27, -76, 4, -1, -21, -1, -92,\n            43, 121, 93, 97};", "modifier": "private static final", "type": "byte[]", "declarator": "VALID_BIN_DATA_OFFSETS_V3 = {11, 4, 91, 91,\n            35, 70, -11, 26, 108, 9, 0, -102, -2, 59, 27, -76, 4, -1, -21, -1, -92,\n            43, 121, 93, 97}", "var_name": "VALID_BIN_DATA_OFFSETS_V3"}, {"original_string": "private static final byte[] VALID_BIN_DATA_NO_OFFSET_V3 = {11, 4, 91, 91,\n            35, 70, -11, 26, 108, 9, 0, -102, -2, 59, 27, -76, 4, -1, -21, -1,\n            -92, 43, 25};", "modifier": "private static final", "type": "byte[]", "declarator": "VALID_BIN_DATA_NO_OFFSET_V3 = {11, 4, 91, 91,\n            35, 70, -11, 26, 108, 9, 0, -102, -2, 59, 27, -76, 4, -1, -21, -1,\n            -92, 43, 25}", "var_name": "VALID_BIN_DATA_NO_OFFSET_V3"}, {"original_string": "private static final byte[] INVALID_BIN_LOC_DATA = {\n            Byte.parseByte(\"00001010\", 2), Byte.parseByte(\"00000100\", 2),\n            Byte.parseByte(\"01011011\", 2), Byte.parseByte(\"01011011\", 2),\n            Byte.parseByte(\"00100011\", 2), Byte.parseByte(\"01000110\", 2),\n            Byte.parseByte(\"-1110100\", 2), Byte.parseByte(\"00011010\", 2),\n            Byte.parseByte(\"01101100\", 2), Byte.parseByte(\"00001001\", 2),\n            Byte.parseByte(\"-1111111\", 2), Byte.parseByte(\"01100101\", 2),\n            Byte.parseByte(\"00000001\", 2), Byte.parseByte(\"-1000101\", 2),\n            Byte.parseByte(\"00011011\", 2), Byte.parseByte(\"-0110100\", 2),\n            Byte.parseByte(\"00000100\", 2), Byte.parseByte(\"00000010\", 2),\n            Byte.parseByte(\"-0001011\", 2), Byte.parseByte(\"00000000\", 2),\n            Byte.parseByte(\"01011101\", 2), Byte.parseByte(\"00101011\", 2),\n            Byte.parseByte(\"01011001\", 2)};", "modifier": "private static final", "type": "byte[]", "declarator": "INVALID_BIN_LOC_DATA = {\n            Byte.parseByte(\"00001010\", 2), Byte.parseByte(\"00000100\", 2),\n            Byte.parseByte(\"01011011\", 2), Byte.parseByte(\"01011011\", 2),\n            Byte.parseByte(\"00100011\", 2), Byte.parseByte(\"01000110\", 2),\n            Byte.parseByte(\"-1110100\", 2), Byte.parseByte(\"00011010\", 2),\n            Byte.parseByte(\"01101100\", 2), Byte.parseByte(\"00001001\", 2),\n            Byte.parseByte(\"-1111111\", 2), Byte.parseByte(\"01100101\", 2),\n            Byte.parseByte(\"00000001\", 2), Byte.parseByte(\"-1000101\", 2),\n            Byte.parseByte(\"00011011\", 2), Byte.parseByte(\"-0110100\", 2),\n            Byte.parseByte(\"00000100\", 2), Byte.parseByte(\"00000010\", 2),\n            Byte.parseByte(\"-0001011\", 2), Byte.parseByte(\"00000000\", 2),\n            Byte.parseByte(\"01011101\", 2), Byte.parseByte(\"00101011\", 2),\n            Byte.parseByte(\"01011001\", 2)}", "var_name": "INVALID_BIN_LOC_DATA"}, {"original_string": "private static final OpenLRBinaryDecoder DECODER = new OpenLRBinaryDecoder();", "modifier": "private static final", "type": "OpenLRBinaryDecoder", "declarator": "DECODER = new OpenLRBinaryDecoder()", "var_name": "DECODER"}, {"original_string": "private static final int EXPECTED_POS_OFFSET_V2 = 205;", "modifier": "private static final", "type": "int", "declarator": "EXPECTED_POS_OFFSET_V2 = 205", "var_name": "EXPECTED_POS_OFFSET_V2"}, {"original_string": "private static final int EXPECTED_NEG_OFFSET_V2 = 147;", "modifier": "private static final", "type": "int", "declarator": "EXPECTED_NEG_OFFSET_V2 = 147", "var_name": "EXPECTED_NEG_OFFSET_V2"}, {"original_string": "private static final int EXPECTED_POS_OFFSET_V3 = 203;", "modifier": "private static final", "type": "int", "declarator": "EXPECTED_POS_OFFSET_V3 = 203", "var_name": "EXPECTED_POS_OFFSET_V3"}, {"original_string": "private static final int EXPECTED_POS_OFFSET_WP_EXAMPLE = 149;", "modifier": "private static final", "type": "int", "declarator": "EXPECTED_POS_OFFSET_WP_EXAMPLE = 149", "var_name": "EXPECTED_POS_OFFSET_WP_EXAMPLE"}, {"original_string": "private static final int EXPECTED_NEG_OFFSET_V3 = 101;", "modifier": "private static final", "type": "int", "declarator": "EXPECTED_NEG_OFFSET_V3 = 101", "var_name": "EXPECTED_NEG_OFFSET_V3"}, {"original_string": "private RawLocationReference validDecodeLocation;", "modifier": "private", "type": "RawLocationReference", "declarator": "validDecodeLocation", "var_name": "validDecodeLocation"}], "file": "binary/src/test/java/openlr/binary/OpenLRBinaryDecoderTest.java"}, "test_case": {"identifier": "testWhitepaperExample", "parameters": "()", "modifiers": "@Test public final", "return": "void", "body": "@Test\n    public final void testWhitepaperExample() {\n\n        ByteArray validBinLoc = new ByteArray(\n                OpenLRBinaryEncoderTest.DATA_WP_EXAMPLE);\n\n        try {\n            RawLocationReference decodeData = decodeData(validBinLoc);\n            Lrp[] expectedLrps = new Lrp[]{Lrp.LINE_DEC_LRP1, Lrp.LINE_DEC_LRP2_WP,\n                    Lrp.LINE_DEC_LRP3_WP};\n            Utils.checkDecodedLrps(decodeData, expectedLrps);\n            checkOffsetsV3(decodeData.getOffsets(),\n                    EXPECTED_POS_OFFSET_WP_EXAMPLE, null);\n        } catch (PhysicalFormatException e) {\n            fail(\"failed on valid input\", e);\n        }\n    }", "signature": "void testWhitepaperExample()", "full_signature": "@Test public final void testWhitepaperExample()", "class_method_signature": "OpenLRBinaryDecoderTest.testWhitepaperExample()", "testcase": true, "constructor": false, "invocations": ["decodeData", "checkDecodedLrps", "checkOffsetsV3", "getOffsets", "fail"]}, "focal_class": {"identifier": "OpenLRBinaryDecoder", "superclass": "", "interfaces": "implements PhysicalDecoder", "fields": [{"original_string": "private static final int[] VERSIONS = {2, 3};", "modifier": "private static final", "type": "int[]", "declarator": "VERSIONS = {2, 3}", "var_name": "VERSIONS"}, {"original_string": "private static final Logger LOG = Logger\n            .getLogger(OpenLRBinaryDecoder.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = Logger\n            .getLogger(OpenLRBinaryDecoder.class)", "var_name": "LOG"}], "methods": [{"identifier": "getVersions", "parameters": "()", "modifiers": "public static", "return": "int[]", "signature": "int[] getVersions()", "full_signature": "public static int[] getVersions()", "class_method_signature": "OpenLRBinaryDecoder.getVersions()", "testcase": false, "constructor": false}, {"identifier": "checkVersion", "parameters": "(final Header h)", "modifiers": "private", "return": "boolean", "signature": "boolean checkVersion(final Header h)", "full_signature": "private boolean checkVersion(final Header h)", "class_method_signature": "OpenLRBinaryDecoder.checkVersion(final Header h)", "testcase": false, "constructor": false}, {"identifier": "parseBinaryData", "parameters": "(final String id,\n                                                 final byte[] data, final RawBinaryData binData)", "modifiers": "private", "return": "RawLocationReference", "signature": "RawLocationReference parseBinaryData(final String id,\n                                                 final byte[] data, final RawBinaryData binData)", "full_signature": "private RawLocationReference parseBinaryData(final String id,\n                                                 final byte[] data, final RawBinaryData binData)", "class_method_signature": "OpenLRBinaryDecoder.parseBinaryData(final String id,\n                                                 final byte[] data, final RawBinaryData binData)", "testcase": false, "constructor": false}, {"identifier": "decodeData", "parameters": "(final LocationReference lr)", "modifiers": "@Override public", "return": "RawLocationReference", "signature": "RawLocationReference decodeData(final LocationReference lr)", "full_signature": "@Override public RawLocationReference decodeData(final LocationReference lr)", "class_method_signature": "OpenLRBinaryDecoder.decodeData(final LocationReference lr)", "testcase": false, "constructor": false}, {"identifier": "getDataClass", "parameters": "()", "modifiers": "@Override public", "return": "Class<?>", "signature": "Class<?> getDataClass()", "full_signature": "@Override public Class<?> getDataClass()", "class_method_signature": "OpenLRBinaryDecoder.getDataClass()", "testcase": false, "constructor": false}, {"identifier": "getDataFormatIdentifier", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getDataFormatIdentifier()", "full_signature": "@Override public String getDataFormatIdentifier()", "class_method_signature": "OpenLRBinaryDecoder.getDataFormatIdentifier()", "testcase": false, "constructor": false}, {"identifier": "resolveBinaryData", "parameters": "(final String id, final ByteArray ba)", "modifiers": "public", "return": "RawBinaryData", "signature": "RawBinaryData resolveBinaryData(final String id, final ByteArray ba)", "full_signature": "public RawBinaryData resolveBinaryData(final String id, final ByteArray ba)", "class_method_signature": "OpenLRBinaryDecoder.resolveBinaryData(final String id, final ByteArray ba)", "testcase": false, "constructor": false}], "file": "binary/src/main/java/openlr/binary/OpenLRBinaryDecoder.java"}, "focal_method": {"identifier": "decodeData", "parameters": "(final LocationReference lr)", "modifiers": "@Override public", "return": "RawLocationReference", "body": "@Override\n    public RawLocationReference decodeData(final LocationReference lr)\n            throws PhysicalFormatException {\n        Object data = lr.getLocationReferenceData();\n        if (data == null || !(data instanceof ByteArray)) {\n            throw new OpenLRBinaryException(\n                    PhysicalFormatError.INVALID_BINARY_DATA);\n        }\n        ByteArray dataList = (ByteArray) data;\n        return parseBinaryData(lr.getID(), dataList.getData(), null);\n    }", "signature": "RawLocationReference decodeData(final LocationReference lr)", "full_signature": "@Override public RawLocationReference decodeData(final LocationReference lr)", "class_method_signature": "OpenLRBinaryDecoder.decodeData(final LocationReference lr)", "testcase": false, "constructor": false, "invocations": ["getLocationReferenceData", "parseBinaryData", "getID", "getData"]}, "repository": {"repo_id": 187195345, "url": "https://github.com/tomtom-international/openlr", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 24, "size": 4809, "license": "licensed"}}