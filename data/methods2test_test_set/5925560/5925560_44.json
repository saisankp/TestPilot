{"test_class": {"identifier": "NumberUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "dexlib2/src/test/java/org/jf/util/NumberUtilsTest.java"}, "test_case": {"identifier": "isLikelyDoubleTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void isLikelyDoubleTest() {\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(1.23f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(1.0f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(Double.NaN)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(Double.NEGATIVE_INFINITY)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(Double.POSITIVE_INFINITY)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(1e-30f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(1000f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(1f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(-1f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(-5f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(1.3333f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(1.33333f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(4.5f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(.1f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(50000f)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(Double.MAX_VALUE)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(Math.PI)));\n        Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(Math.E)));\n\n        // Double.MIN_VALUE is equivalent to integer value 1 - this should be detected as an integer\n        //Assert.assertTrue(NumberUtils.isLikelyDouble(Double.doubleToRawLongBits(Double.MIN_VALUE)));\n\n        Assert.assertFalse(NumberUtils.isLikelyDouble(0));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(1));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(10));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(100));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(1000));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(1024));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(1234));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(-5));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(-13));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(-123));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(20000000));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(2000000000));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(-2000000000));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(Integer.MAX_VALUE));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(Integer.MIN_VALUE));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(Short.MIN_VALUE));\n        Assert.assertFalse(NumberUtils.isLikelyDouble(Short.MAX_VALUE));\n    }", "signature": "void isLikelyDoubleTest()", "full_signature": "@Test public void isLikelyDoubleTest()", "class_method_signature": "NumberUtilsTest.isLikelyDoubleTest()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertTrue", "isLikelyDouble", "doubleToRawLongBits", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble", "assertFalse", "isLikelyDouble"]}, "focal_class": {"identifier": "NumberUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int canonicalFloatNaN = Float.floatToRawIntBits(Float.NaN);", "modifier": "private static final", "type": "int", "declarator": "canonicalFloatNaN = Float.floatToRawIntBits(Float.NaN)", "var_name": "canonicalFloatNaN"}, {"original_string": "private static final int maxFloat = Float.floatToRawIntBits(Float.MAX_VALUE);", "modifier": "private static final", "type": "int", "declarator": "maxFloat = Float.floatToRawIntBits(Float.MAX_VALUE)", "var_name": "maxFloat"}, {"original_string": "private static final int piFloat = Float.floatToRawIntBits((float)Math.PI);", "modifier": "private static final", "type": "int", "declarator": "piFloat = Float.floatToRawIntBits((float)Math.PI)", "var_name": "piFloat"}, {"original_string": "private static final int eFloat = Float.floatToRawIntBits((float)Math.E);", "modifier": "private static final", "type": "int", "declarator": "eFloat = Float.floatToRawIntBits((float)Math.E)", "var_name": "eFloat"}, {"original_string": "private static final long canonicalDoubleNaN = Double.doubleToRawLongBits(Double.NaN);", "modifier": "private static final", "type": "long", "declarator": "canonicalDoubleNaN = Double.doubleToRawLongBits(Double.NaN)", "var_name": "canonicalDoubleNaN"}, {"original_string": "private static final long maxDouble = Double.doubleToLongBits(Double.MAX_VALUE);", "modifier": "private static final", "type": "long", "declarator": "maxDouble = Double.doubleToLongBits(Double.MAX_VALUE)", "var_name": "maxDouble"}, {"original_string": "private static final long piDouble = Double.doubleToLongBits(Math.PI);", "modifier": "private static final", "type": "long", "declarator": "piDouble = Double.doubleToLongBits(Math.PI)", "var_name": "piDouble"}, {"original_string": "private static final long eDouble = Double.doubleToLongBits(Math.E);", "modifier": "private static final", "type": "long", "declarator": "eDouble = Double.doubleToLongBits(Math.E)", "var_name": "eDouble"}, {"original_string": "private static final DecimalFormat format = new DecimalFormat(\"0.####################E0\");", "modifier": "private static final", "type": "DecimalFormat", "declarator": "format = new DecimalFormat(\"0.####################E0\")", "var_name": "format"}], "methods": [{"identifier": "isLikelyFloat", "parameters": "(int value)", "modifiers": "public static", "return": "boolean", "signature": "boolean isLikelyFloat(int value)", "full_signature": "public static boolean isLikelyFloat(int value)", "class_method_signature": "NumberUtils.isLikelyFloat(int value)", "testcase": false, "constructor": false}, {"identifier": "isLikelyDouble", "parameters": "(long value)", "modifiers": "public static", "return": "boolean", "signature": "boolean isLikelyDouble(long value)", "full_signature": "public static boolean isLikelyDouble(long value)", "class_method_signature": "NumberUtils.isLikelyDouble(long value)", "testcase": false, "constructor": false}], "file": "dexlib2/src/main/java/org/jf/util/NumberUtils.java"}, "focal_method": {"identifier": "isLikelyDouble", "parameters": "(long value)", "modifiers": "public static", "return": "boolean", "body": "public static boolean isLikelyDouble(long value) {\n        // Check for some common named double values\n        // We don't check for Double.MIN_VALUE, which has a long representation of 1\n        if (value == canonicalDoubleNaN ||\n                value == maxDouble ||\n                value == piDouble ||\n                value == eDouble) {\n            return true;\n        }\n\n        // Check for some named long values\n        if (value == Long.MAX_VALUE || value == Long.MIN_VALUE) {\n            return false;\n        }\n\n        // a non-canocical NaN is more likely to be an long\n        double doubleValue = Double.longBitsToDouble(value);\n        if (Double.isNaN(doubleValue)) {\n            return false;\n        }\n\n        // Otherwise, whichever has a shorter scientific notation representation is more likely.\n        // Long wins the tie\n        String asLong = format.format(value);\n        String asDouble = format.format(doubleValue);\n\n        // try to strip off any small imprecision near the end of the mantissa\n        int decimalPoint = asDouble.indexOf('.');\n        int exponent = asDouble.indexOf(\"E\");\n        int zeros = asDouble.indexOf(\"000\");\n        if (zeros > decimalPoint && zeros < exponent) {\n            asDouble = asDouble.substring(0, zeros) + asDouble.substring(exponent);\n        } else {\n            int nines = asDouble.indexOf(\"999\");\n            if (nines > decimalPoint && nines < exponent) {\n                asDouble = asDouble.substring(0, nines) + asDouble.substring(exponent);\n            }\n        }\n\n        return asDouble.length() < asLong.length();\n    }", "signature": "boolean isLikelyDouble(long value)", "full_signature": "public static boolean isLikelyDouble(long value)", "class_method_signature": "NumberUtils.isLikelyDouble(long value)", "testcase": false, "constructor": false, "invocations": ["longBitsToDouble", "isNaN", "format", "format", "indexOf", "indexOf", "indexOf", "substring", "substring", "indexOf", "substring", "substring", "length", "length"]}, "repository": {"repo_id": 5925560, "url": "https://github.com/JesusFreke/smali", "language": "Java", "is_fork": false, "fork_count": 875, "stargazer_count": 4465, "size": 9375, "license": "licensed"}}