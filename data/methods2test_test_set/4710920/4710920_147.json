{"test_class": {"identifier": "DubboProtocolTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();", "modifier": "private", "type": "Protocol", "declarator": "protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()", "var_name": "protocol"}, {"original_string": "private ProxyFactory proxy = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();", "modifier": "private", "type": "ProxyFactory", "declarator": "proxy = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension()", "var_name": "proxy"}], "file": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocolTest.java"}, "test_case": {"identifier": "testDubboProtocol", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDubboProtocol() throws Exception {\n        DemoService service = new DemoServiceImpl();\n        int port = NetUtils.getAvailablePort();\n        protocol.export(proxy.getInvoker(service, DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:\" + port + \"/\" + DemoService.class.getName())));\n        service = proxy.getProxy(protocol.refer(DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:\" + port + \"/\" + DemoService.class.getName()).addParameter(\"timeout\",\n                3000L)));\n        assertEquals(service.enumlength(new Type[]{}), Type.Lower);\n        assertEquals(service.getSize(null), -1);\n        assertEquals(service.getSize(new String[]{\"\", \"\", \"\"}), 3);\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"aa\", \"bb\");\n        Set<String> set = service.keys(map);\n        assertEquals(set.size(), 1);\n        assertEquals(set.iterator().next(), \"aa\");\n        service.invoke(\"dubbo://127.0.0.1:\" + port + \"/\" + DemoService.class.getName() + \"\", \"invoke\");\n\n        service = proxy.getProxy(protocol.refer(DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:\" + port + \"/\" + DemoService.class.getName() + \"?client=netty\").addParameter(\"timeout\",\n                3000L)));\n        // test netty client\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < 1024 * 32 + 32; i++)\n            buf.append('A');\n        System.out.println(service.stringLength(buf.toString()));\n\n        // cast to EchoService\n        EchoService echo = proxy.getProxy(protocol.refer(EchoService.class, URL.valueOf(\"dubbo://127.0.0.1:\" + port + \"/\" + DemoService.class.getName() + \"?client=netty\").addParameter(\"timeout\",\n                3000L)));\n        assertEquals(echo.$echo(buf.toString()), buf.toString());\n        assertEquals(echo.$echo(\"test\"), \"test\");\n        assertEquals(echo.$echo(\"abcdefg\"), \"abcdefg\");\n        assertEquals(echo.$echo(1234), 1234);\n    }", "signature": "void testDubboProtocol()", "full_signature": "@Test public void testDubboProtocol()", "class_method_signature": "DubboProtocolTest.testDubboProtocol()", "testcase": true, "constructor": false, "invocations": ["getAvailablePort", "export", "getInvoker", "valueOf", "getName", "getProxy", "refer", "addParameter", "valueOf", "getName", "assertEquals", "enumlength", "assertEquals", "getSize", "assertEquals", "getSize", "put", "keys", "assertEquals", "size", "assertEquals", "next", "iterator", "invoke", "getName", "getProxy", "refer", "addParameter", "valueOf", "getName", "append", "println", "stringLength", "toString", "getProxy", "refer", "addParameter", "valueOf", "getName", "assertEquals", "echo", "toString", "toString", "assertEquals", "echo", "assertEquals", "echo", "assertEquals", "echo"]}, "focal_class": {"identifier": "DubboProtocol", "superclass": "extends AbstractProtocol", "interfaces": "", "fields": [{"original_string": "public static final String NAME = \"dubbo\";", "modifier": "public static final", "type": "String", "declarator": "NAME = \"dubbo\"", "var_name": "NAME"}, {"original_string": "public static final int DEFAULT_PORT = 20880;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_PORT = 20880", "var_name": "DEFAULT_PORT"}, {"original_string": "private static final String IS_CALLBACK_SERVICE_INVOKE = \"_isCallBackServiceInvoke\";", "modifier": "private static final", "type": "String", "declarator": "IS_CALLBACK_SERVICE_INVOKE = \"_isCallBackServiceInvoke\"", "var_name": "IS_CALLBACK_SERVICE_INVOKE"}, {"original_string": "private static DubboProtocol INSTANCE;", "modifier": "private static", "type": "DubboProtocol", "declarator": "INSTANCE", "var_name": "INSTANCE"}, {"original_string": "private final Map<String, List<ReferenceCountExchangeClient>> referenceClientMap = new ConcurrentHashMap<>();", "modifier": "private final", "type": "Map<String, List<ReferenceCountExchangeClient>>", "declarator": "referenceClientMap = new ConcurrentHashMap<>()", "var_name": "referenceClientMap"}, {"original_string": "private final ConcurrentMap<String, Object> locks = new ConcurrentHashMap<>();", "modifier": "private final", "type": "ConcurrentMap<String, Object>", "declarator": "locks = new ConcurrentHashMap<>()", "var_name": "locks"}, {"original_string": "private final Set<String> optimizers = new ConcurrentHashSet<>();", "modifier": "private final", "type": "Set<String>", "declarator": "optimizers = new ConcurrentHashSet<>()", "var_name": "optimizers"}, {"original_string": "private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() {\n\n        @Override\n        public CompletableFuture<Object> reply(ExchangeChannel channel, Object message) throws RemotingException {\n\n            if (!(message instanceof Invocation)) {\n                throw new RemotingException(channel, \"Unsupported request: \"\n                        + (message == null ? null : (message.getClass().getName() + \": \" + message))\n                        + \", channel: consumer: \" + channel.getRemoteAddress() + \" --> provider: \" + channel.getLocalAddress());\n            }\n\n            Invocation inv = (Invocation) message;\n            Invoker<?> invoker = getInvoker(channel, inv);\n            // need to consider backward-compatibility if it's a callback\n            if (Boolean.TRUE.toString().equals(inv.getObjectAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {\n                String methodsStr = invoker.getUrl().getParameters().get(\"methods\");\n                boolean hasMethod = false;\n                if (methodsStr == null || !methodsStr.contains(\",\")) {\n                    hasMethod = inv.getMethodName().equals(methodsStr);\n                } else {\n                    String[] methods = methodsStr.split(\",\");\n                    for (String method : methods) {\n                        if (inv.getMethodName().equals(method)) {\n                            hasMethod = true;\n                            break;\n                        }\n                    }\n                }\n                if (!hasMethod) {\n                    logger.warn(new IllegalStateException(\"The methodName \" + inv.getMethodName()\n                            + \" not found in callback service interface ,invoke will be ignored.\"\n                            + \" please update the api interface. url is:\"\n                            + invoker.getUrl()) + \" ,invocation is :\" + inv);\n                    return null;\n                }\n            }\n            RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());\n            Result result = invoker.invoke(inv);\n            return result.thenApply(Function.identity());\n        }\n\n        @Override\n        public void received(Channel channel, Object message) throws RemotingException {\n            if (message instanceof Invocation) {\n                reply((ExchangeChannel) channel, message);\n\n            } else {\n                super.received(channel, message);\n            }\n        }\n\n        @Override\n        public void connected(Channel channel) throws RemotingException {\n            invoke(channel, ON_CONNECT_KEY);\n        }\n\n        @Override\n        public void disconnected(Channel channel) throws RemotingException {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"disconnected from \" + channel.getRemoteAddress() + \",url:\" + channel.getUrl());\n            }\n            invoke(channel, ON_DISCONNECT_KEY);\n        }\n\n        private void invoke(Channel channel, String methodKey) {\n            Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);\n            if (invocation != null) {\n                try {\n                    received(channel, invocation);\n                } catch (Throwable t) {\n                    logger.warn(\"Failed to invoke event method \" + invocation.getMethodName() + \"(), cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n\n        /**\n         * FIXME channel.getUrl() always binds to a fixed service, and this service is random.\n         * we can choose to use a common service to carry onConnect event if there's no easy way to get the specific\n         * service this connection is binding to.\n         * @param channel\n         * @param url\n         * @param methodKey\n         * @return\n         */\n        private Invocation createInvocation(Channel channel, URL url, String methodKey) {\n            String method = url.getParameter(methodKey);\n            if (method == null || method.length() == 0) {\n                return null;\n            }\n\n            RpcInvocation invocation = new RpcInvocation(method, url.getParameter(INTERFACE_KEY), \"\", new Class<?>[0], new Object[0]);\n            invocation.setAttachment(PATH_KEY, url.getPath());\n            invocation.setAttachment(GROUP_KEY, url.getParameter(GROUP_KEY));\n            invocation.setAttachment(INTERFACE_KEY, url.getParameter(INTERFACE_KEY));\n            invocation.setAttachment(VERSION_KEY, url.getParameter(VERSION_KEY));\n            if (url.getParameter(STUB_EVENT_KEY, false)) {\n                invocation.setAttachment(STUB_EVENT_KEY, Boolean.TRUE.toString());\n            }\n\n            return invocation;\n        }\n    };", "modifier": "private", "type": "ExchangeHandler", "declarator": "requestHandler = new ExchangeHandlerAdapter() {\n\n        @Override\n        public CompletableFuture<Object> reply(ExchangeChannel channel, Object message) throws RemotingException {\n\n            if (!(message instanceof Invocation)) {\n                throw new RemotingException(channel, \"Unsupported request: \"\n                        + (message == null ? null : (message.getClass().getName() + \": \" + message))\n                        + \", channel: consumer: \" + channel.getRemoteAddress() + \" --> provider: \" + channel.getLocalAddress());\n            }\n\n            Invocation inv = (Invocation) message;\n            Invoker<?> invoker = getInvoker(channel, inv);\n            // need to consider backward-compatibility if it's a callback\n            if (Boolean.TRUE.toString().equals(inv.getObjectAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {\n                String methodsStr = invoker.getUrl().getParameters().get(\"methods\");\n                boolean hasMethod = false;\n                if (methodsStr == null || !methodsStr.contains(\",\")) {\n                    hasMethod = inv.getMethodName().equals(methodsStr);\n                } else {\n                    String[] methods = methodsStr.split(\",\");\n                    for (String method : methods) {\n                        if (inv.getMethodName().equals(method)) {\n                            hasMethod = true;\n                            break;\n                        }\n                    }\n                }\n                if (!hasMethod) {\n                    logger.warn(new IllegalStateException(\"The methodName \" + inv.getMethodName()\n                            + \" not found in callback service interface ,invoke will be ignored.\"\n                            + \" please update the api interface. url is:\"\n                            + invoker.getUrl()) + \" ,invocation is :\" + inv);\n                    return null;\n                }\n            }\n            RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());\n            Result result = invoker.invoke(inv);\n            return result.thenApply(Function.identity());\n        }\n\n        @Override\n        public void received(Channel channel, Object message) throws RemotingException {\n            if (message instanceof Invocation) {\n                reply((ExchangeChannel) channel, message);\n\n            } else {\n                super.received(channel, message);\n            }\n        }\n\n        @Override\n        public void connected(Channel channel) throws RemotingException {\n            invoke(channel, ON_CONNECT_KEY);\n        }\n\n        @Override\n        public void disconnected(Channel channel) throws RemotingException {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"disconnected from \" + channel.getRemoteAddress() + \",url:\" + channel.getUrl());\n            }\n            invoke(channel, ON_DISCONNECT_KEY);\n        }\n\n        private void invoke(Channel channel, String methodKey) {\n            Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);\n            if (invocation != null) {\n                try {\n                    received(channel, invocation);\n                } catch (Throwable t) {\n                    logger.warn(\"Failed to invoke event method \" + invocation.getMethodName() + \"(), cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n\n        /**\n         * FIXME channel.getUrl() always binds to a fixed service, and this service is random.\n         * we can choose to use a common service to carry onConnect event if there's no easy way to get the specific\n         * service this connection is binding to.\n         * @param channel\n         * @param url\n         * @param methodKey\n         * @return\n         */\n        private Invocation createInvocation(Channel channel, URL url, String methodKey) {\n            String method = url.getParameter(methodKey);\n            if (method == null || method.length() == 0) {\n                return null;\n            }\n\n            RpcInvocation invocation = new RpcInvocation(method, url.getParameter(INTERFACE_KEY), \"\", new Class<?>[0], new Object[0]);\n            invocation.setAttachment(PATH_KEY, url.getPath());\n            invocation.setAttachment(GROUP_KEY, url.getParameter(GROUP_KEY));\n            invocation.setAttachment(INTERFACE_KEY, url.getParameter(INTERFACE_KEY));\n            invocation.setAttachment(VERSION_KEY, url.getParameter(VERSION_KEY));\n            if (url.getParameter(STUB_EVENT_KEY, false)) {\n                invocation.setAttachment(STUB_EVENT_KEY, Boolean.TRUE.toString());\n            }\n\n            return invocation;\n        }\n    }", "var_name": "requestHandler"}], "methods": [{"identifier": "DubboProtocol", "parameters": "()", "modifiers": "public", "return": "", "signature": " DubboProtocol()", "full_signature": "public  DubboProtocol()", "class_method_signature": "DubboProtocol.DubboProtocol()", "testcase": false, "constructor": true}, {"identifier": "getDubboProtocol", "parameters": "()", "modifiers": "public static", "return": "DubboProtocol", "signature": "DubboProtocol getDubboProtocol()", "full_signature": "public static DubboProtocol getDubboProtocol()", "class_method_signature": "DubboProtocol.getDubboProtocol()", "testcase": false, "constructor": false}, {"identifier": "getExporters", "parameters": "()", "modifiers": "public", "return": "Collection<Exporter<?>>", "signature": "Collection<Exporter<?>> getExporters()", "full_signature": "public Collection<Exporter<?>> getExporters()", "class_method_signature": "DubboProtocol.getExporters()", "testcase": false, "constructor": false}, {"identifier": "isClientSide", "parameters": "(Channel channel)", "modifiers": "private", "return": "boolean", "signature": "boolean isClientSide(Channel channel)", "full_signature": "private boolean isClientSide(Channel channel)", "class_method_signature": "DubboProtocol.isClientSide(Channel channel)", "testcase": false, "constructor": false}, {"identifier": "getInvoker", "parameters": "(Channel channel, Invocation inv)", "modifiers": "", "return": "Invoker<?>", "signature": "Invoker<?> getInvoker(Channel channel, Invocation inv)", "full_signature": " Invoker<?> getInvoker(Channel channel, Invocation inv)", "class_method_signature": "DubboProtocol.getInvoker(Channel channel, Invocation inv)", "testcase": false, "constructor": false}, {"identifier": "getInvokers", "parameters": "()", "modifiers": "public", "return": "Collection<Invoker<?>>", "signature": "Collection<Invoker<?>> getInvokers()", "full_signature": "public Collection<Invoker<?>> getInvokers()", "class_method_signature": "DubboProtocol.getInvokers()", "testcase": false, "constructor": false}, {"identifier": "getDefaultPort", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getDefaultPort()", "full_signature": "@Override public int getDefaultPort()", "class_method_signature": "DubboProtocol.getDefaultPort()", "testcase": false, "constructor": false}, {"identifier": "export", "parameters": "(Invoker<T> invoker)", "modifiers": "@Override public", "return": "Exporter<T>", "signature": "Exporter<T> export(Invoker<T> invoker)", "full_signature": "@Override public Exporter<T> export(Invoker<T> invoker)", "class_method_signature": "DubboProtocol.export(Invoker<T> invoker)", "testcase": false, "constructor": false}, {"identifier": "openServer", "parameters": "(URL url)", "modifiers": "private", "return": "void", "signature": "void openServer(URL url)", "full_signature": "private void openServer(URL url)", "class_method_signature": "DubboProtocol.openServer(URL url)", "testcase": false, "constructor": false}, {"identifier": "createServer", "parameters": "(URL url)", "modifiers": "private", "return": "ProtocolServer", "signature": "ProtocolServer createServer(URL url)", "full_signature": "private ProtocolServer createServer(URL url)", "class_method_signature": "DubboProtocol.createServer(URL url)", "testcase": false, "constructor": false}, {"identifier": "optimizeSerialization", "parameters": "(URL url)", "modifiers": "private", "return": "void", "signature": "void optimizeSerialization(URL url)", "full_signature": "private void optimizeSerialization(URL url)", "class_method_signature": "DubboProtocol.optimizeSerialization(URL url)", "testcase": false, "constructor": false}, {"identifier": "protocolBindingRefer", "parameters": "(Class<T> serviceType, URL url)", "modifiers": "@Override public", "return": "Invoker<T>", "signature": "Invoker<T> protocolBindingRefer(Class<T> serviceType, URL url)", "full_signature": "@Override public Invoker<T> protocolBindingRefer(Class<T> serviceType, URL url)", "class_method_signature": "DubboProtocol.protocolBindingRefer(Class<T> serviceType, URL url)", "testcase": false, "constructor": false}, {"identifier": "getClients", "parameters": "(URL url)", "modifiers": "private", "return": "ExchangeClient[]", "signature": "ExchangeClient[] getClients(URL url)", "full_signature": "private ExchangeClient[] getClients(URL url)", "class_method_signature": "DubboProtocol.getClients(URL url)", "testcase": false, "constructor": false}, {"identifier": "getSharedClient", "parameters": "(URL url, int connectNum)", "modifiers": "private", "return": "List<ReferenceCountExchangeClient>", "signature": "List<ReferenceCountExchangeClient> getSharedClient(URL url, int connectNum)", "full_signature": "private List<ReferenceCountExchangeClient> getSharedClient(URL url, int connectNum)", "class_method_signature": "DubboProtocol.getSharedClient(URL url, int connectNum)", "testcase": false, "constructor": false}, {"identifier": "checkClientCanUse", "parameters": "(List<ReferenceCountExchangeClient> referenceCountExchangeClients)", "modifiers": "private", "return": "boolean", "signature": "boolean checkClientCanUse(List<ReferenceCountExchangeClient> referenceCountExchangeClients)", "full_signature": "private boolean checkClientCanUse(List<ReferenceCountExchangeClient> referenceCountExchangeClients)", "class_method_signature": "DubboProtocol.checkClientCanUse(List<ReferenceCountExchangeClient> referenceCountExchangeClients)", "testcase": false, "constructor": false}, {"identifier": "batchClientRefIncr", "parameters": "(List<ReferenceCountExchangeClient> referenceCountExchangeClients)", "modifiers": "private", "return": "void", "signature": "void batchClientRefIncr(List<ReferenceCountExchangeClient> referenceCountExchangeClients)", "full_signature": "private void batchClientRefIncr(List<ReferenceCountExchangeClient> referenceCountExchangeClients)", "class_method_signature": "DubboProtocol.batchClientRefIncr(List<ReferenceCountExchangeClient> referenceCountExchangeClients)", "testcase": false, "constructor": false}, {"identifier": "buildReferenceCountExchangeClientList", "parameters": "(URL url, int connectNum)", "modifiers": "private", "return": "List<ReferenceCountExchangeClient>", "signature": "List<ReferenceCountExchangeClient> buildReferenceCountExchangeClientList(URL url, int connectNum)", "full_signature": "private List<ReferenceCountExchangeClient> buildReferenceCountExchangeClientList(URL url, int connectNum)", "class_method_signature": "DubboProtocol.buildReferenceCountExchangeClientList(URL url, int connectNum)", "testcase": false, "constructor": false}, {"identifier": "buildReferenceCountExchangeClient", "parameters": "(URL url)", "modifiers": "private", "return": "ReferenceCountExchangeClient", "signature": "ReferenceCountExchangeClient buildReferenceCountExchangeClient(URL url)", "full_signature": "private ReferenceCountExchangeClient buildReferenceCountExchangeClient(URL url)", "class_method_signature": "DubboProtocol.buildReferenceCountExchangeClient(URL url)", "testcase": false, "constructor": false}, {"identifier": "initClient", "parameters": "(URL url)", "modifiers": "private", "return": "ExchangeClient", "signature": "ExchangeClient initClient(URL url)", "full_signature": "private ExchangeClient initClient(URL url)", "class_method_signature": "DubboProtocol.initClient(URL url)", "testcase": false, "constructor": false}, {"identifier": "destroy", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void destroy()", "full_signature": "@Override public void destroy()", "class_method_signature": "DubboProtocol.destroy()", "testcase": false, "constructor": false}, {"identifier": "closeReferenceCountExchangeClient", "parameters": "(ReferenceCountExchangeClient client)", "modifiers": "private", "return": "void", "signature": "void closeReferenceCountExchangeClient(ReferenceCountExchangeClient client)", "full_signature": "private void closeReferenceCountExchangeClient(ReferenceCountExchangeClient client)", "class_method_signature": "DubboProtocol.closeReferenceCountExchangeClient(ReferenceCountExchangeClient client)", "testcase": false, "constructor": false}, {"identifier": "getInvocationWithoutData", "parameters": "(Invocation invocation)", "modifiers": "private", "return": "Invocation", "signature": "Invocation getInvocationWithoutData(Invocation invocation)", "full_signature": "private Invocation getInvocationWithoutData(Invocation invocation)", "class_method_signature": "DubboProtocol.getInvocationWithoutData(Invocation invocation)", "testcase": false, "constructor": false}], "file": "dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java"}, "focal_method": {"identifier": "DubboProtocol", "parameters": "()", "modifiers": "public", "return": "", "body": "public DubboProtocol() {\n        INSTANCE = this;\n    }", "signature": " DubboProtocol()", "full_signature": "public  DubboProtocol()", "class_method_signature": "DubboProtocol.DubboProtocol()", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 4710920, "url": "https://github.com/apache/dubbo", "stars": 30960, "created": "6/19/2012 7:56:02 AM +00:00", "updates": "2020-01-27T14:21:03+00:00", "fork": "False", "license": "licensed"}}