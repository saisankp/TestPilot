{"test_class": {"identifier": "AbstractPathTest", "superclass": "extends BaseValueFactoryTest", "interfaces": "", "fields": [{"original_string": "protected Path path;", "modifier": "protected", "type": "Path", "declarator": "path", "var_name": "path"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/value/basic/AbstractPathTest.java"}, "test_case": {"identifier": "shouldReturnSelfForSubpathStartingAtZero", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldReturnSelfForSubpathStartingAtZero() {\n        assertThat(path.subpath(0), is(sameInstance(path)));\n        assertThat(path.subpath(0, path.size()), is(sameInstance(path)));\n    }", "signature": "void shouldReturnSelfForSubpathStartingAtZero()", "full_signature": "@Test public void shouldReturnSelfForSubpathStartingAtZero()", "class_method_signature": "AbstractPathTest.shouldReturnSelfForSubpathStartingAtZero()", "testcase": true, "constructor": false, "invocations": ["assertThat", "subpath", "is", "sameInstance", "assertThat", "subpath", "size", "is", "sameInstance"]}, "focal_class": {"identifier": "AbstractPath", "superclass": "", "interfaces": "implements Path", "fields": [{"original_string": "private static final long serialVersionUID = 1L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 1L", "var_name": "serialVersionUID"}, {"original_string": "public static final Path SELF_PATH = new BasicPath(Collections.singletonList(Path.SELF_SEGMENT), false);", "modifier": "public static final", "type": "Path", "declarator": "SELF_PATH = new BasicPath(Collections.singletonList(Path.SELF_SEGMENT), false)", "var_name": "SELF_PATH"}, {"original_string": "protected static Iterator<Path.Segment> EMPTY_PATH_ITERATOR = new Iterator<Segment>() {\n        @Override\n        public boolean hasNext() {\n            return false;\n        }\n\n        @Override\n        public Segment next() {\n            throw new NoSuchElementException();\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };", "modifier": "protected static", "type": "Iterator<Path.Segment>", "declarator": "EMPTY_PATH_ITERATOR = new Iterator<Segment>() {\n        @Override\n        public boolean hasNext() {\n            return false;\n        }\n\n        @Override\n        public Segment next() {\n            throw new NoSuchElementException();\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }", "var_name": "EMPTY_PATH_ITERATOR"}, {"original_string": "private transient int hc = 0;", "modifier": "private transient", "type": "int", "declarator": "hc = 0", "var_name": "hc"}], "methods": [{"identifier": "isNormalized", "parameters": "( List<Segment> segments )", "modifiers": "protected", "return": "boolean", "signature": "boolean isNormalized( List<Segment> segments )", "full_signature": "protected boolean isNormalized( List<Segment> segments )", "class_method_signature": "AbstractPath.isNormalized( List<Segment> segments )", "testcase": false, "constructor": false}, {"identifier": "isIdentifier", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isIdentifier()", "full_signature": "@Override public boolean isIdentifier()", "class_method_signature": "AbstractPath.isIdentifier()", "testcase": false, "constructor": false}, {"identifier": "getCanonicalPath", "parameters": "()", "modifiers": "@Override public", "return": "Path", "signature": "Path getCanonicalPath()", "full_signature": "@Override public Path getCanonicalPath()", "class_method_signature": "AbstractPath.getCanonicalPath()", "testcase": false, "constructor": false}, {"identifier": "getCommonAncestor", "parameters": "( Path that )", "modifiers": "@Override public", "return": "Path", "signature": "Path getCommonAncestor( Path that )", "full_signature": "@Override public Path getCommonAncestor( Path that )", "class_method_signature": "AbstractPath.getCommonAncestor( Path that )", "testcase": false, "constructor": false}, {"identifier": "getLastSegment", "parameters": "()", "modifiers": "@Override public", "return": "Path.Segment", "signature": "Path.Segment getLastSegment()", "full_signature": "@Override public Path.Segment getLastSegment()", "class_method_signature": "AbstractPath.getLastSegment()", "testcase": false, "constructor": false}, {"identifier": "endsWith", "parameters": "( Name nameOfLastSegment )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean endsWith( Name nameOfLastSegment )", "full_signature": "@Override public boolean endsWith( Name nameOfLastSegment )", "class_method_signature": "AbstractPath.endsWith( Name nameOfLastSegment )", "testcase": false, "constructor": false}, {"identifier": "endsWith", "parameters": "( Name nameOfLastSegment,\n                             int snsIndex )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean endsWith( Name nameOfLastSegment,\n                             int snsIndex )", "full_signature": "@Override public boolean endsWith( Name nameOfLastSegment,\n                             int snsIndex )", "class_method_signature": "AbstractPath.endsWith( Name nameOfLastSegment,\n                             int snsIndex )", "testcase": false, "constructor": false}, {"identifier": "getParent", "parameters": "()", "modifiers": "@Override public", "return": "Path", "signature": "Path getParent()", "full_signature": "@Override public Path getParent()", "class_method_signature": "AbstractPath.getParent()", "testcase": false, "constructor": false}, {"identifier": "getSegment", "parameters": "( int index )", "modifiers": "@Override public", "return": "Segment", "signature": "Segment getSegment( int index )", "full_signature": "@Override public Segment getSegment( int index )", "class_method_signature": "AbstractPath.getSegment( int index )", "testcase": false, "constructor": false}, {"identifier": "getSegmentsArray", "parameters": "()", "modifiers": "@Override public", "return": "Segment[]", "signature": "Segment[] getSegmentsArray()", "full_signature": "@Override public Segment[] getSegmentsArray()", "class_method_signature": "AbstractPath.getSegmentsArray()", "testcase": false, "constructor": false}, {"identifier": "getNormalizedPath", "parameters": "()", "modifiers": "@Override public", "return": "Path", "signature": "Path getNormalizedPath()", "full_signature": "@Override public Path getNormalizedPath()", "class_method_signature": "AbstractPath.getNormalizedPath()", "testcase": false, "constructor": false}, {"identifier": "getString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getString()", "full_signature": "@Override public String getString()", "class_method_signature": "AbstractPath.getString()", "testcase": false, "constructor": false}, {"identifier": "getString", "parameters": "( TextEncoder encoder )", "modifiers": "@Override public", "return": "String", "signature": "String getString( TextEncoder encoder )", "full_signature": "@Override public String getString( TextEncoder encoder )", "class_method_signature": "AbstractPath.getString( TextEncoder encoder )", "testcase": false, "constructor": false}, {"identifier": "getString", "parameters": "( NamespaceRegistry namespaceRegistry )", "modifiers": "@Override public", "return": "String", "signature": "String getString( NamespaceRegistry namespaceRegistry )", "full_signature": "@Override public String getString( NamespaceRegistry namespaceRegistry )", "class_method_signature": "AbstractPath.getString( NamespaceRegistry namespaceRegistry )", "testcase": false, "constructor": false}, {"identifier": "getString", "parameters": "( NamespaceRegistry namespaceRegistry,\n                             TextEncoder encoder )", "modifiers": "@Override public", "return": "String", "signature": "String getString( NamespaceRegistry namespaceRegistry,\n                             TextEncoder encoder )", "full_signature": "@Override public String getString( NamespaceRegistry namespaceRegistry,\n                             TextEncoder encoder )", "class_method_signature": "AbstractPath.getString( NamespaceRegistry namespaceRegistry,\n                             TextEncoder encoder )", "testcase": false, "constructor": false}, {"identifier": "getString", "parameters": "( NamespaceRegistry namespaceRegistry,\n                             TextEncoder encoder,\n                             TextEncoder delimiterEncoder )", "modifiers": "@Override public", "return": "String", "signature": "String getString( NamespaceRegistry namespaceRegistry,\n                             TextEncoder encoder,\n                             TextEncoder delimiterEncoder )", "full_signature": "@Override public String getString( NamespaceRegistry namespaceRegistry,\n                             TextEncoder encoder,\n                             TextEncoder delimiterEncoder )", "class_method_signature": "AbstractPath.getString( NamespaceRegistry namespaceRegistry,\n                             TextEncoder encoder,\n                             TextEncoder delimiterEncoder )", "testcase": false, "constructor": false}, {"identifier": "doGetString", "parameters": "( NamespaceRegistry namespaceRegistry,\n                                  TextEncoder encoder,\n                                  TextEncoder delimiterEncoder )", "modifiers": "protected", "return": "String", "signature": "String doGetString( NamespaceRegistry namespaceRegistry,\n                                  TextEncoder encoder,\n                                  TextEncoder delimiterEncoder )", "full_signature": "protected String doGetString( NamespaceRegistry namespaceRegistry,\n                                  TextEncoder encoder,\n                                  TextEncoder delimiterEncoder )", "class_method_signature": "AbstractPath.doGetString( NamespaceRegistry namespaceRegistry,\n                                  TextEncoder encoder,\n                                  TextEncoder delimiterEncoder )", "testcase": false, "constructor": false}, {"identifier": "hasSameAncestor", "parameters": "( Path that )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean hasSameAncestor( Path that )", "full_signature": "@Override public boolean hasSameAncestor( Path that )", "class_method_signature": "AbstractPath.hasSameAncestor( Path that )", "testcase": false, "constructor": false}, {"identifier": "isAncestorOf", "parameters": "( Path descendant )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isAncestorOf( Path descendant )", "full_signature": "@Override public boolean isAncestorOf( Path descendant )", "class_method_signature": "AbstractPath.isAncestorOf( Path descendant )", "testcase": false, "constructor": false}, {"identifier": "isAtOrBelow", "parameters": "( Path other )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isAtOrBelow( Path other )", "full_signature": "@Override public boolean isAtOrBelow( Path other )", "class_method_signature": "AbstractPath.isAtOrBelow( Path other )", "testcase": false, "constructor": false}, {"identifier": "isAtOrAbove", "parameters": "( Path other )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isAtOrAbove( Path other )", "full_signature": "@Override public boolean isAtOrAbove( Path other )", "class_method_signature": "AbstractPath.isAtOrAbove( Path other )", "testcase": false, "constructor": false}, {"identifier": "isDescendantOf", "parameters": "( Path ancestor )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isDescendantOf( Path ancestor )", "full_signature": "@Override public boolean isDescendantOf( Path ancestor )", "class_method_signature": "AbstractPath.isDescendantOf( Path ancestor )", "testcase": false, "constructor": false}, {"identifier": "isSameAs", "parameters": "( Path other )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isSameAs( Path other )", "full_signature": "@Override public boolean isSameAs( Path other )", "class_method_signature": "AbstractPath.isSameAs( Path other )", "testcase": false, "constructor": false}, {"identifier": "iterator", "parameters": "()", "modifiers": "@Override public", "return": "Iterator<Segment>", "signature": "Iterator<Segment> iterator()", "full_signature": "@Override public Iterator<Segment> iterator()", "class_method_signature": "AbstractPath.iterator()", "testcase": false, "constructor": false}, {"identifier": "pathsFromRoot", "parameters": "()", "modifiers": "@Override public", "return": "Iterator<Path>", "signature": "Iterator<Path> pathsFromRoot()", "full_signature": "@Override public Iterator<Path> pathsFromRoot()", "class_method_signature": "AbstractPath.pathsFromRoot()", "testcase": false, "constructor": false}, {"identifier": "relativeToRoot", "parameters": "()", "modifiers": "@Override public", "return": "Path", "signature": "Path relativeToRoot()", "full_signature": "@Override public Path relativeToRoot()", "class_method_signature": "AbstractPath.relativeToRoot()", "testcase": false, "constructor": false}, {"identifier": "relativeTo", "parameters": "( Path startingPath )", "modifiers": "@Override public", "return": "Path", "signature": "Path relativeTo( Path startingPath )", "full_signature": "@Override public Path relativeTo( Path startingPath )", "class_method_signature": "AbstractPath.relativeTo( Path startingPath )", "testcase": false, "constructor": false}, {"identifier": "resolve", "parameters": "( Path relativePath )", "modifiers": "@Override public", "return": "Path", "signature": "Path resolve( Path relativePath )", "full_signature": "@Override public Path resolve( Path relativePath )", "class_method_signature": "AbstractPath.resolve( Path relativePath )", "testcase": false, "constructor": false}, {"identifier": "resolveAgainst", "parameters": "( Path absolutePath )", "modifiers": "@Override public", "return": "Path", "signature": "Path resolveAgainst( Path absolutePath )", "full_signature": "@Override public Path resolveAgainst( Path absolutePath )", "class_method_signature": "AbstractPath.resolveAgainst( Path absolutePath )", "testcase": false, "constructor": false}, {"identifier": "subpath", "parameters": "( int beginIndex )", "modifiers": "@Override public", "return": "Path", "signature": "Path subpath( int beginIndex )", "full_signature": "@Override public Path subpath( int beginIndex )", "class_method_signature": "AbstractPath.subpath( int beginIndex )", "testcase": false, "constructor": false}, {"identifier": "subpath", "parameters": "( int beginIndex,\n                         int endIndex )", "modifiers": "@Override public", "return": "Path", "signature": "Path subpath( int beginIndex,\n                         int endIndex )", "full_signature": "@Override public Path subpath( int beginIndex,\n                         int endIndex )", "class_method_signature": "AbstractPath.subpath( int beginIndex,\n                         int endIndex )", "testcase": false, "constructor": false}, {"identifier": "createSegmentsSubList", "parameters": "( int validBeginIndex,\n                                                   int validEndIndex )", "modifiers": "protected", "return": "List<Segment>", "signature": "List<Segment> createSegmentsSubList( int validBeginIndex,\n                                                   int validEndIndex )", "full_signature": "protected List<Segment> createSegmentsSubList( int validBeginIndex,\n                                                   int validEndIndex )", "class_method_signature": "AbstractPath.createSegmentsSubList( int validBeginIndex,\n                                                   int validEndIndex )", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "AbstractPath.hashCode()", "testcase": false, "constructor": false}, {"identifier": "getSegmentsOfParent", "parameters": "()", "modifiers": "protected abstract", "return": "Iterator<Segment>", "signature": "Iterator<Segment> getSegmentsOfParent()", "full_signature": "protected abstract Iterator<Segment> getSegmentsOfParent()", "class_method_signature": "AbstractPath.getSegmentsOfParent()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "( Object obj )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals( Object obj )", "full_signature": "@Override public boolean equals( Object obj )", "class_method_signature": "AbstractPath.equals( Object obj )", "testcase": false, "constructor": false}, {"identifier": "compareTo", "parameters": "( Path that )", "modifiers": "@Override public", "return": "int", "signature": "int compareTo( Path that )", "full_signature": "@Override public int compareTo( Path that )", "class_method_signature": "AbstractPath.compareTo( Path that )", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "AbstractPath.toString()", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/value/basic/AbstractPath.java"}, "focal_method": {"identifier": "subpath", "parameters": "( int beginIndex )", "modifiers": "@Override public", "return": "Path", "body": "@Override\n    public Path subpath( int beginIndex ) {\n        return subpath(beginIndex, size());\n    }", "signature": "Path subpath( int beginIndex )", "full_signature": "@Override public Path subpath( int beginIndex )", "class_method_signature": "AbstractPath.subpath( int beginIndex )", "testcase": false, "constructor": false, "invocations": ["subpath", "size"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}