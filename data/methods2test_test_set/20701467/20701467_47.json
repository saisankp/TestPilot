{"test_class": {"identifier": "EthernetDecoderTest", "superclass": "", "interfaces": "", "fields": [], "file": "packethandler/implementation/src/test/java/org/opendaylight/l2switch/packethandler/decoders/EthernetDecoderTest.java"}, "test_case": {"identifier": "testDecode_Length", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDecode_Length() throws Exception {\n        byte[] packet = {\n            0x01, 0x23, 0x45, 0x67, (byte) 0x89, (byte) 0xab,\n            (byte) 0xcd, (byte) 0xef, 0x01, 0x23, 0x45, 0x67,\n            0x00, 0x0e,\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,\n            0x00, (byte)0xfe, (byte)0xdc, (byte)0xba\n        };\n        NotificationProviderService mock = Mockito.mock(NotificationProviderService.class);\n        EthernetPacketReceived notification = new EthernetDecoder(mock)\n                .decode(new PacketReceivedBuilder().setPayload(packet).setMatch(new MatchBuilder().build()).build());\n        EthernetPacket ethernetPacket = (EthernetPacket) notification.getPacketChain().get(1).getPacket();\n        assertNull(ethernetPacket.getEthertype());\n        assertEquals(14, ethernetPacket.getEthernetLength().intValue());\n        assertNull(ethernetPacket.getHeader8021q());\n        assertEquals(\"01:23:45:67:89:ab\", ethernetPacket.getDestinationMac().getValue());\n        assertEquals(\"cd:ef:01:23:45:67\", ethernetPacket.getSourceMac().getValue());\n        assertEquals(14, ethernetPacket.getPayloadOffset().intValue());\n        assertEquals(13, ethernetPacket.getPayloadLength().intValue());\n        assertEquals(16702650L, ethernetPacket.getCrc().longValue());\n        assertTrue(Arrays.equals(packet, notification.getPayload()));\n    }", "signature": "void testDecode_Length()", "full_signature": "@Test public void testDecode_Length()", "class_method_signature": "EthernetDecoderTest.testDecode_Length()", "testcase": true, "constructor": false, "invocations": ["mock", "decode", "build", "setMatch", "setPayload", "build", "getPacket", "get", "getPacketChain", "assertNull", "getEthertype", "assertEquals", "intValue", "getEthernetLength", "assertNull", "getHeader8021q", "assertEquals", "getValue", "getDestinationMac", "assertEquals", "getValue", "getSourceMac", "assertEquals", "intValue", "getPayloadOffset", "assertEquals", "intValue", "getPayloadLength", "assertEquals", "longValue", "getCrc", "assertTrue", "equals", "getPayload"]}, "focal_class": {"identifier": "EthernetDecoder", "superclass": "extends AbstractPacketDecoder<PacketReceived, EthernetPacketReceived>", "interfaces": "implements PacketProcessingListener", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(EthernetDecoder.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(EthernetDecoder.class)", "var_name": "LOG"}, {"original_string": "public static final Integer LENGTH_MAX = 1500;", "modifier": "public static final", "type": "Integer", "declarator": "LENGTH_MAX = 1500", "var_name": "LENGTH_MAX"}, {"original_string": "public static final Integer ETHERTYPE_MIN = 1536;", "modifier": "public static final", "type": "Integer", "declarator": "ETHERTYPE_MIN = 1536", "var_name": "ETHERTYPE_MIN"}, {"original_string": "public static final Integer ETHERTYPE_8021Q = 0x8100;", "modifier": "public static final", "type": "Integer", "declarator": "ETHERTYPE_8021Q = 0x8100", "var_name": "ETHERTYPE_8021Q"}, {"original_string": "public static final Integer ETHERTYPE_QINQ = 0x9100;", "modifier": "public static final", "type": "Integer", "declarator": "ETHERTYPE_QINQ = 0x9100", "var_name": "ETHERTYPE_QINQ"}], "methods": [{"identifier": "EthernetDecoder", "parameters": "(NotificationProviderService notificationProviderService)", "modifiers": "public", "return": "", "signature": " EthernetDecoder(NotificationProviderService notificationProviderService)", "full_signature": "public  EthernetDecoder(NotificationProviderService notificationProviderService)", "class_method_signature": "EthernetDecoder.EthernetDecoder(NotificationProviderService notificationProviderService)", "testcase": false, "constructor": true}, {"identifier": "onPacketReceived", "parameters": "(PacketReceived packetReceived)", "modifiers": "@Override public", "return": "void", "signature": "void onPacketReceived(PacketReceived packetReceived)", "full_signature": "@Override public void onPacketReceived(PacketReceived packetReceived)", "class_method_signature": "EthernetDecoder.onPacketReceived(PacketReceived packetReceived)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(PacketReceived packetReceived)", "modifiers": "@Override public", "return": "EthernetPacketReceived", "signature": "EthernetPacketReceived decode(PacketReceived packetReceived)", "full_signature": "@Override public EthernetPacketReceived decode(PacketReceived packetReceived)", "class_method_signature": "EthernetDecoder.decode(PacketReceived packetReceived)", "testcase": false, "constructor": false}, {"identifier": "getConsumedNotificationListener", "parameters": "()", "modifiers": "@Override public", "return": "NotificationListener", "signature": "NotificationListener getConsumedNotificationListener()", "full_signature": "@Override public NotificationListener getConsumedNotificationListener()", "class_method_signature": "EthernetDecoder.getConsumedNotificationListener()", "testcase": false, "constructor": false}, {"identifier": "canDecode", "parameters": "(PacketReceived packetReceived)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean canDecode(PacketReceived packetReceived)", "full_signature": "@Override public boolean canDecode(PacketReceived packetReceived)", "class_method_signature": "EthernetDecoder.canDecode(PacketReceived packetReceived)", "testcase": false, "constructor": false}], "file": "packethandler/implementation/src/main/java/org/opendaylight/l2switch/packethandler/decoders/EthernetDecoder.java"}, "focal_method": {"identifier": "decode", "parameters": "(PacketReceived packetReceived)", "modifiers": "@Override public", "return": "EthernetPacketReceived", "body": "@Override\n    public EthernetPacketReceived decode(PacketReceived packetReceived) {\n        byte[] data = packetReceived.getPayload();\n        EthernetPacketReceivedBuilder builder = new EthernetPacketReceivedBuilder();\n\n        // Save original rawPacket & set the payloadOffset/payloadLength fields\n        RawPacketBuilder rpb = new RawPacketBuilder().setIngress(packetReceived.getIngress())\n                .setConnectionCookie(packetReceived.getConnectionCookie()).setFlowCookie(packetReceived.getFlowCookie())\n                .setTableId(packetReceived.getTableId()).setPacketInReason(packetReceived.getPacketInReason())\n                .setPayloadOffset(0).setPayloadLength(data.length);\n        if (packetReceived.getMatch() != null) {\n            rpb.setMatch(new MatchBuilder(packetReceived.getMatch()).build());\n        }\n        RawPacket rp = rpb.build();\n        ArrayList<PacketChain> packetChain = new ArrayList<>();\n        packetChain.add(new PacketChainBuilder().setPacket(rp).build());\n\n        try {\n            EthernetPacketBuilder epBuilder = new EthernetPacketBuilder();\n\n            // Deserialize the destination & source fields\n            epBuilder.setDestinationMac(\n                    new MacAddress(HexEncode.bytesToHexStringFormat(BitBufferHelper.getBits(data, 0, 48))));\n            epBuilder.setSourceMac(\n                    new MacAddress(HexEncode.bytesToHexStringFormat(BitBufferHelper.getBits(data, 48, 48))));\n\n            // Deserialize the optional field 802.1Q headers\n            Integer nextField = BitBufferHelper.getInt(BitBufferHelper.getBits(data, 96, 16));\n            int extraHeaderBits = 0;\n            ArrayList<Header8021q> headerList = new ArrayList<>();\n            while (nextField.equals(ETHERTYPE_8021Q) || nextField.equals(ETHERTYPE_QINQ)) {\n                Header8021qBuilder headerBuilder = new Header8021qBuilder();\n                headerBuilder.setTPID(Header8021qType.forValue(nextField));\n\n                // Read 2 more bytes for priority (3bits), drop eligible (1bit),\n                // vlan-id (12bits)\n                byte[] vlanBytes = BitBufferHelper.getBits(data, 112 + extraHeaderBits, 16);\n\n                // Remove the sign & right-shift to get the priority code\n                headerBuilder.setPriorityCode((short) ((vlanBytes[0] & 0xff) >> 5));\n\n                // Remove the sign & remove priority code bits & right-shift to\n                // get drop-eligible bit\n                headerBuilder.setDropEligible(1 == (vlanBytes[0] & 0xff & 0x10) >> 4);\n\n                // Remove priority code & drop-eligible bits, to get the VLAN-id\n                vlanBytes[0] = (byte) (vlanBytes[0] & 0x0F);\n                headerBuilder.setVlan(new VlanId(BitBufferHelper.getInt(vlanBytes)));\n\n                // Add 802.1Q header to the growing collection\n                headerList.add(headerBuilder.build());\n\n                // Reset value of \"nextField\" to correspond to following 2 bytes\n                // for next 802.1Q header or EtherType/Length\n                nextField = BitBufferHelper.getInt(BitBufferHelper.getBits(data, 128 + extraHeaderBits, 16));\n\n                // 802.1Q header means payload starts at a later position\n                extraHeaderBits += 32;\n            }\n            // Set 802.1Q headers\n            if (!headerList.isEmpty()) {\n                epBuilder.setHeader8021q(headerList);\n            }\n\n            // Deserialize the EtherType or Length field\n            if (nextField >= ETHERTYPE_MIN) {\n                epBuilder.setEthertype(KnownEtherType.forValue(nextField));\n            } else if (nextField <= LENGTH_MAX) {\n                epBuilder.setEthernetLength(nextField);\n            } else {\n                LOG.debug(\"Undefined header, value is not valid EtherType or length.  Value is {}\", nextField);\n            }\n\n            // Determine start & end of payload\n            int payloadStart = (112 + extraHeaderBits) / NetUtils.NUM_BITS_IN_A_BYTE;\n            int payloadEnd = data.length - 4;\n            epBuilder.setPayloadOffset(payloadStart);\n            epBuilder.setPayloadLength(payloadEnd - payloadStart);\n\n            // Deserialize the CRC\n            epBuilder.setCrc(BitBufferHelper\n                    .getLong(BitBufferHelper.getBits(data, (data.length - 4) * NetUtils.NUM_BITS_IN_A_BYTE, 32)));\n\n            // Set EthernetPacket field\n            packetChain.add(new PacketChainBuilder().setPacket(epBuilder.build()).build());\n\n            // Set Payload field\n            builder.setPayload(data);\n        } catch (BufferException be) {\n            LOG.info(\"Exception during decoding raw packet to ethernet.\");\n        }\n\n        // ToDo: Possibly log these values\n        /*\n         * if (_logger.isTraceEnabled()) {\n         * _logger.trace(\"{}: {}: {} (offset {} bitsize {})\", new Object[] {\n         * this.getClass().getSimpleName(), hdrField,\n         * HexEncode.bytesToHexString(hdrFieldBytes), startOffset, numBits }); }\n         */\n        builder.setPacketChain(packetChain);\n        return builder.build();\n    }", "signature": "EthernetPacketReceived decode(PacketReceived packetReceived)", "full_signature": "@Override public EthernetPacketReceived decode(PacketReceived packetReceived)", "class_method_signature": "EthernetDecoder.decode(PacketReceived packetReceived)", "testcase": false, "constructor": false, "invocations": ["getPayload", "setPayloadLength", "setPayloadOffset", "setPacketInReason", "setTableId", "setFlowCookie", "setConnectionCookie", "setIngress", "getIngress", "getConnectionCookie", "getFlowCookie", "getTableId", "getPacketInReason", "getMatch", "setMatch", "build", "getMatch", "build", "add", "build", "setPacket", "setDestinationMac", "bytesToHexStringFormat", "getBits", "setSourceMac", "bytesToHexStringFormat", "getBits", "getInt", "getBits", "equals", "equals", "setTPID", "forValue", "getBits", "setPriorityCode", "setDropEligible", "setVlan", "getInt", "add", "build", "getInt", "getBits", "isEmpty", "setHeader8021q", "setEthertype", "forValue", "setEthernetLength", "debug", "setPayloadOffset", "setPayloadLength", "setCrc", "getLong", "getBits", "add", "build", "setPacket", "build", "setPayload", "info", "setPacketChain", "build"]}, "repository": {"repo_id": 20701467, "url": "https://github.com/opendaylight/l2switch", "language": "Java", "is_fork": false, "fork_count": 30, "stargazer_count": 25, "size": 4178, "license": "licensed"}}