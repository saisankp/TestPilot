{"test_class": {"identifier": "ReactorMergeOperationsTest", "superclass": "", "interfaces": "", "fields": [], "file": "titus-common/src/test/java/com/netflix/titus/common/util/rx/ReactorMergeOperationsTest.java"}, "test_case": {"identifier": "testMonoMerge", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMonoMerge() {\n        Set<String> resultCollector = new HashSet<>();\n\n        Map<String, Mono<Void>> monoMap = ImmutableMap.<String, Mono<Void>>builder()\n                .put(\"mono1\", Mono.defer(() -> {\n                    resultCollector.add(\"mono1\");\n                    return Mono.empty();\n                }))\n                .put(\"mono2\", Mono.defer(() -> {\n                    resultCollector.add(\"mono2\");\n                    return Mono.empty();\n                }))\n                .build();\n\n        Map<String, Optional<Throwable>> executionResult = ReactorExt.merge(monoMap, 2, Schedulers.parallel()).block();\n        assertThat(executionResult).hasSize(2);\n        assertThat(executionResult.get(\"mono1\")).isEmpty();\n        assertThat(executionResult.get(\"mono2\")).isEmpty();\n        assertThat(resultCollector).contains(\"mono1\", \"mono2\");\n    }", "signature": "void testMonoMerge()", "full_signature": "@Test public void testMonoMerge()", "class_method_signature": "ReactorMergeOperationsTest.testMonoMerge()", "testcase": true, "constructor": false, "invocations": ["build", "put", "put", "builder", "defer", "add", "empty", "defer", "add", "empty", "block", "merge", "parallel", "hasSize", "assertThat", "isEmpty", "assertThat", "get", "isEmpty", "assertThat", "get", "contains", "assertThat"]}, "focal_class": {"identifier": "ReactorMergeOperations", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "merge", "parameters": "(Map<K, Mono<Void>> monos, int concurrencyLimit, Scheduler scheduler)", "modifiers": "public static", "return": "Mono<Map<K, Optional<Throwable>>>", "signature": "Mono<Map<K, Optional<Throwable>>> merge(Map<K, Mono<Void>> monos, int concurrencyLimit, Scheduler scheduler)", "full_signature": "public static Mono<Map<K, Optional<Throwable>>> merge(Map<K, Mono<Void>> monos, int concurrencyLimit, Scheduler scheduler)", "class_method_signature": "ReactorMergeOperations.merge(Map<K, Mono<Void>> monos, int concurrencyLimit, Scheduler scheduler)", "testcase": false, "constructor": false}], "file": "titus-common/src/main/java/com/netflix/titus/common/util/rx/ReactorMergeOperations.java"}, "focal_method": {"identifier": "merge", "parameters": "(Map<K, Mono<Void>> monos, int concurrencyLimit, Scheduler scheduler)", "modifiers": "public static", "return": "Mono<Map<K, Optional<Throwable>>>", "body": "public static <K> Mono<Map<K, Optional<Throwable>>> merge(Map<K, Mono<Void>> monos, int concurrencyLimit, Scheduler scheduler) {\n        List<Flux<Pair<K, Optional<Throwable>>>> m2 = new ArrayList<>();\n        monos.forEach((key, mono) -> {\n\n            Flux<Pair<K, Optional<Throwable>>> x = mono.toProcessor().ignoreElement().materialize().map(result -> {\n                        Optional<Throwable> error = result.getType() == SignalType.ON_ERROR\n                                ? Optional.of(result.getThrowable())\n                                : Optional.empty();\n                        return Pair.of(key, error);\n                    }\n            ).flux();\n            m2.add(x);\n        });\n\n        return Flux.merge(Flux.fromIterable(m2), concurrencyLimit)\n                .subscribeOn(scheduler)\n                .collectList()\n                .map(list -> list.stream().collect(Collectors.toMap(Pair::getLeft, Pair::getRight)));\n    }", "signature": "Mono<Map<K, Optional<Throwable>>> merge(Map<K, Mono<Void>> monos, int concurrencyLimit, Scheduler scheduler)", "full_signature": "public static Mono<Map<K, Optional<Throwable>>> merge(Map<K, Mono<Void>> monos, int concurrencyLimit, Scheduler scheduler)", "class_method_signature": "ReactorMergeOperations.merge(Map<K, Mono<Void>> monos, int concurrencyLimit, Scheduler scheduler)", "testcase": false, "constructor": false, "invocations": ["forEach", "flux", "map", "materialize", "ignoreElement", "toProcessor", "getType", "of", "getThrowable", "empty", "of", "add", "map", "collectList", "subscribeOn", "merge", "fromIterable", "collect", "stream", "toMap"]}, "repository": {"repo_id": 107330274, "url": "https://github.com/Netflix/titus-control-plane", "stars": 241, "created": "10/17/2017 10:20:55 PM +00:00", "updates": "2020-01-25T13:01:05+00:00", "fork": "False", "license": "licensed"}}