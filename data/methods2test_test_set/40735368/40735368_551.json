{"test_class": {"identifier": "LRSMeasureProcessTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private DataStore featureSource;", "modifier": "private", "type": "DataStore", "declarator": "featureSource", "var_name": "featureSource"}, {"original_string": "private final GeometryFactory geometryFactory = new GeometryFactory();", "modifier": "private final", "type": "GeometryFactory", "declarator": "geometryFactory = new GeometryFactory()", "var_name": "geometryFactory"}], "file": "modules/unsupported/process-feature/src/test/java/org/geotools/process/vector/LRSMeasureProcessTest.java"}, "test_case": {"identifier": "testNullParamToLrs", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testNullParamToLrs() throws Exception {\n        SimpleFeatureSource source = featureSource.getFeatureSource(\"lrssimple\");\n        LRSMeasureProcess process = new LRSMeasureProcess();\n        SimpleFeatureCollection origional = source.getFeatures();\n        Point point = geometryFactory.createPoint(new Coordinate(1.0, 0.0));\n\n        try {\n            FeatureCollection result = process.execute(origional, \"from_lrs\", null, point, null);\n            Assert.fail(\"Expected error from bad to_lrs name\");\n        } catch (ProcessException e) {\n            // Successful\n        }\n    }", "signature": "void testNullParamToLrs()", "full_signature": "@Test public void testNullParamToLrs()", "class_method_signature": "LRSMeasureProcessTest.testNullParamToLrs()", "testcase": true, "constructor": false, "invocations": ["getFeatureSource", "getFeatures", "createPoint", "execute", "fail"]}, "focal_class": {"identifier": "LRSMeasureProcess", "superclass": "", "interfaces": "implements VectorProcess", "fields": [{"original_string": "private static final Logger LOGGER = Logging.getLogger(LRSMeasureProcess.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = Logging.getLogger(LRSMeasureProcess.class)", "var_name": "LOGGER"}, {"original_string": "private final GeometryFactory geometryFactory = new GeometryFactory();", "modifier": "private final", "type": "GeometryFactory", "declarator": "geometryFactory = new GeometryFactory()", "var_name": "geometryFactory"}], "methods": [{"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"point\", description = \"Point whose location to measure\") Point point,\n            @DescribeParameter(name = \"crs\", min = 0, description = \"Coordinate reference system to use for input (default is the input collection CRS)\") CoordinateReferenceSystem crs)", "modifiers": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public", "return": "FeatureCollection", "signature": "FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"point\", description = \"Point whose location to measure\") Point point,\n            @DescribeParameter(name = \"crs\", min = 0, description = \"Coordinate reference system to use for input (default is the input collection CRS)\") CoordinateReferenceSystem crs)", "full_signature": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"point\", description = \"Point whose location to measure\") Point point,\n            @DescribeParameter(name = \"crs\", min = 0, description = \"Coordinate reference system to use for input (default is the input collection CRS)\") CoordinateReferenceSystem crs)", "class_method_signature": "LRSMeasureProcess.execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"point\", description = \"Point whose location to measure\") Point point,\n            @DescribeParameter(name = \"crs\", min = 0, description = \"Coordinate reference system to use for input (default is the input collection CRS)\") CoordinateReferenceSystem crs)", "testcase": false, "constructor": false}, {"identifier": "createTargetFeatureType", "parameters": "(FeatureType sourceFeatureType)", "modifiers": "private", "return": "SimpleFeatureType", "signature": "SimpleFeatureType createTargetFeatureType(FeatureType sourceFeatureType)", "full_signature": "private SimpleFeatureType createTargetFeatureType(FeatureType sourceFeatureType)", "class_method_signature": "LRSMeasureProcess.createTargetFeatureType(FeatureType sourceFeatureType)", "testcase": false, "constructor": false}, {"identifier": "createTargetFeature", "parameters": "(Feature feature, SimpleFeatureType targetFeatureType,\n            Double lrsMeasure)", "modifiers": "private", "return": "SimpleFeature", "signature": "SimpleFeature createTargetFeature(Feature feature, SimpleFeatureType targetFeatureType,\n            Double lrsMeasure)", "full_signature": "private SimpleFeature createTargetFeature(Feature feature, SimpleFeatureType targetFeatureType,\n            Double lrsMeasure)", "class_method_signature": "LRSMeasureProcess.createTargetFeature(Feature feature, SimpleFeatureType targetFeatureType,\n            Double lrsMeasure)", "testcase": false, "constructor": false}, {"identifier": "calcBearing", "parameters": "(Coordinate[] coords)", "modifiers": "private", "return": "double", "signature": "double calcBearing(Coordinate[] coords)", "full_signature": "private double calcBearing(Coordinate[] coords)", "class_method_signature": "LRSMeasureProcess.calcBearing(Coordinate[] coords)", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/LRSMeasureProcess.java"}, "focal_method": {"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"point\", description = \"Point whose location to measure\") Point point,\n            @DescribeParameter(name = \"crs\", min = 0, description = \"Coordinate reference system to use for input (default is the input collection CRS)\") CoordinateReferenceSystem crs)", "modifiers": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public", "return": "FeatureCollection", "body": "@DescribeResult(name = \"result\", description = \"Output feature collection\")\n    public FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"point\", description = \"Point whose location to measure\") Point point,\n            @DescribeParameter(name = \"crs\", min = 0, description = \"Coordinate reference system to use for input (default is the input collection CRS)\") CoordinateReferenceSystem crs)\n            throws ProcessException {\n        DefaultFeatureCollection results = new DefaultFeatureCollection();\n        try {\n            if (featureCollection == null || featureCollection.size() == 0) {\n                LOGGER.info(\"No features provided in request\");\n                return results;\n            }\n            if (crs == null) {\n                GeometryDescriptor gd = featureCollection.getSchema().getGeometryDescriptor();\n                if (gd != null) {\n                    crs = gd.getCoordinateReferenceSystem();\n                }\n            }\n            if (crs == null) {\n                throw new ProcessException(\n                        \"The CRS parameter was not provided and the feature collection does not have a default one either\");\n            }\n            if (fromMeasureAttb == null\n                    || featureCollection.getSchema().getDescriptor(fromMeasureAttb) == null) {\n                throw new ProcessException(\n                        \"The from_measure_attb parameter was not provided or not defined in schema\");\n            }\n            if (toMeasureAttb == null\n                    || featureCollection.getSchema().getDescriptor(toMeasureAttb) == null) {\n                throw new ProcessException(\"The to_measure_attb parameter was not provided\");\n            }\n            if (point == null) {\n                throw new ProcessException(\"The point parameter was not provided\");\n            }\n\n            CoordinateReferenceSystem epsg4326;\n            try {\n                epsg4326 = CRS.decode(\"EPSG:4326\");\n            } catch (Exception e) {\n                throw new ProcessException(\"Unknown CRS code: EPSG:4326\", e);\n            }\n            MathTransform crsTransform = CRS.findMathTransform(crs, epsg4326);\n\n            FeatureType targetFeatureType = createTargetFeatureType(featureCollection.getSchema());\n            Unit fromUnit = SI.METER;\n            Unit toUnit = Unit.valueOf(\"mi\");\n            UnitConverter unitConvert = fromUnit.getConverterTo(toUnit);\n            Feature nearestFeature = null;\n            double nearestDistance = 9e9;\n            Coordinate[] nearestCoords = null;\n            FeatureIterator<Feature> featureIterator = null;\n            try {\n                featureIterator = featureCollection.features();\n                while (featureIterator.hasNext()) {\n                    SimpleFeature f = (SimpleFeature) featureIterator.next();\n                    if (f.getDefaultGeometryProperty().getValue() == null)\n                        continue;\n                    DistanceOp op = new DistanceOp(point, (Geometry) f.getDefaultGeometryProperty()\n                            .getValue());\n                    Coordinate[] co = op.closestPoints();\n                    double[] co0 = new double[] { co[0].x, co[0].y, };\n                    double[] co1 = new double[] { co[1].x, co[1].y, };\n                    double[] geo0 = new double[2];\n                    double[] geo1 = new double[2];\n                    crsTransform.transform(co0, 0, geo0, 0, 1);\n                    crsTransform.transform(co1, 0, geo1, 0, 1);\n\n                    // get distance\n                    Measure m = DefaultGeographicCRS.WGS84.distance(geo0, geo1);\n                    if (m.doubleValue() > nearestDistance)\n                        continue;\n                    nearestFeature = f;\n                    nearestDistance = m.doubleValue();\n                    nearestCoords = co;\n                }\n            } finally {\n                if (featureIterator != null)\n                    featureIterator.close();\n            }\n            if (nearestFeature != null) {\n                LengthIndexedLine lengthIndexedLine = new LengthIndexedLine(\n                        (Geometry) nearestFeature.getDefaultGeometryProperty().getValue());\n                double lineIndex = lengthIndexedLine.indexOf(nearestCoords[1]);\n                double lineLength = ((Geometry) nearestFeature.getDefaultGeometryProperty()\n                        .getValue()).getLength();\n                Double featureFromMeasure = (Double) nearestFeature.getProperty(fromMeasureAttb)\n                        .getValue();\n                Double featureToMeasure = (Double) nearestFeature.getProperty(toMeasureAttb)\n                        .getValue();\n                double lrsMeasure = featureFromMeasure + (featureToMeasure - featureFromMeasure)\n                        * lineIndex / lineLength;\n                nearestFeature.getDefaultGeometryProperty().setValue(\n                        geometryFactory.createPoint(new Coordinate(nearestCoords[1].x,\n                                nearestCoords[1].y)));\n                results.add(createTargetFeature(nearestFeature,\n                        (SimpleFeatureType) targetFeatureType, lrsMeasure));\n                return results;\n            }\n            return results;\n        } catch (ProcessException e) {\n            throw e;\n        } catch (Throwable e) {\n            LOGGER.warning(\"Error executing method: \" + e);\n            throw new ProcessException(\"Error executing method: \" + e, e);\n        }\n    }", "signature": "FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"point\", description = \"Point whose location to measure\") Point point,\n            @DescribeParameter(name = \"crs\", min = 0, description = \"Coordinate reference system to use for input (default is the input collection CRS)\") CoordinateReferenceSystem crs)", "full_signature": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"point\", description = \"Point whose location to measure\") Point point,\n            @DescribeParameter(name = \"crs\", min = 0, description = \"Coordinate reference system to use for input (default is the input collection CRS)\") CoordinateReferenceSystem crs)", "class_method_signature": "LRSMeasureProcess.execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"point\", description = \"Point whose location to measure\") Point point,\n            @DescribeParameter(name = \"crs\", min = 0, description = \"Coordinate reference system to use for input (default is the input collection CRS)\") CoordinateReferenceSystem crs)", "testcase": false, "constructor": false, "invocations": ["size", "info", "getGeometryDescriptor", "getSchema", "getCoordinateReferenceSystem", "getDescriptor", "getSchema", "getDescriptor", "getSchema", "decode", "findMathTransform", "createTargetFeatureType", "getSchema", "valueOf", "getConverterTo", "features", "hasNext", "next", "getValue", "getDefaultGeometryProperty", "getValue", "getDefaultGeometryProperty", "closestPoints", "transform", "transform", "distance", "doubleValue", "doubleValue", "close", "getValue", "getDefaultGeometryProperty", "indexOf", "getLength", "getValue", "getDefaultGeometryProperty", "getValue", "getProperty", "getValue", "getProperty", "setValue", "getDefaultGeometryProperty", "createPoint", "add", "createTargetFeature", "warning"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}