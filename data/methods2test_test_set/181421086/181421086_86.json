{"test_class": {"identifier": "DeviceManagerImplTest", "superclass": "extends FloodlightTestCase", "interfaces": "", "fields": [{"original_string": "protected static Logger logger =\n\t\t\tLoggerFactory.getLogger(DeviceManagerImplTest.class);", "modifier": "protected static", "type": "Logger", "declarator": "logger =\n\t\t\tLoggerFactory.getLogger(DeviceManagerImplTest.class)", "var_name": "logger"}, {"original_string": "protected OFPacketIn testARPReplyPacketIn_1, testARPReplyPacketIn_2;", "modifier": "protected", "type": "OFPacketIn", "declarator": "testARPReplyPacketIn_1", "var_name": "testARPReplyPacketIn_1"}, {"original_string": "protected OFPacketIn testUDPPacketIn;", "modifier": "protected", "type": "OFPacketIn", "declarator": "testUDPPacketIn", "var_name": "testUDPPacketIn"}, {"original_string": "protected IPacket testARPReplyPacket_1, testARPReplyPacket_2;", "modifier": "protected", "type": "IPacket", "declarator": "testARPReplyPacket_1", "var_name": "testARPReplyPacket_1"}, {"original_string": "protected Ethernet testUDPPacket;", "modifier": "protected", "type": "Ethernet", "declarator": "testUDPPacket", "var_name": "testUDPPacket"}, {"original_string": "protected byte[] testARPReplyPacket_1_Srld, testARPReplyPacket_2_Srld;", "modifier": "protected", "type": "byte[]", "declarator": "testARPReplyPacket_1_Srld", "var_name": "testARPReplyPacket_1_Srld"}, {"original_string": "protected byte[] testUDPPacketSrld;", "modifier": "protected", "type": "byte[]", "declarator": "testUDPPacketSrld", "var_name": "testUDPPacketSrld"}, {"original_string": "private MockSyncService syncService;", "modifier": "private", "type": "MockSyncService", "declarator": "syncService", "var_name": "syncService"}, {"original_string": "private IStoreClient<String, DeviceSyncRepresentation> storeClient;", "modifier": "private", "type": "IStoreClient<String, DeviceSyncRepresentation>", "declarator": "storeClient", "var_name": "storeClient"}, {"original_string": "DeviceManagerImpl deviceManager;", "modifier": "", "type": "DeviceManagerImpl", "declarator": "deviceManager", "var_name": "deviceManager"}, {"original_string": "MemoryStorageSource storageSource;", "modifier": "", "type": "MemoryStorageSource", "declarator": "storageSource", "var_name": "storageSource"}, {"original_string": "IDebugCounterService debugCounterService;", "modifier": "", "type": "IDebugCounterService", "declarator": "debugCounterService", "var_name": "debugCounterService"}, {"original_string": "IDebugEventService debugEventService;", "modifier": "", "type": "IDebugEventService", "declarator": "debugEventService", "var_name": "debugEventService"}], "file": "src/agents/apps/floodlight/floodlight-1.0/src/test/java/net/floodlightcontroller/devicemanager/internal/DeviceManagerImplTest.java"}, "test_case": {"identifier": "testGetIPv4Addresses", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testGetIPv4Addresses() {\n\t\t// Looks like Date is only 1s granularity\n\n\t\tITopologyService mockTopology = createMock(ITopologyService.class);\n\t\tdeviceManager.topology = mockTopology;\n\t\texpect(mockTopology.isAttachmentPointPort(DatapathId.of(anyLong()),\n\t\t\t\tOFPort.of(anyShort()))).\n\t\t\t\tandReturn(true).anyTimes();\n\t\texpect(mockTopology.getL2DomainId(DatapathId.of(anyLong()))).andReturn(DatapathId.of(1L)).anyTimes();\n\t\texpect(mockTopology.isConsistent(DatapathId.of(EasyMock.anyLong()),\n\t\t\t\tOFPort.of(EasyMock.anyShort()),\n\t\t\t\tDatapathId.of(EasyMock.anyLong()),\n\t\t\t\tOFPort.of(EasyMock.anyShort())))\n\t\t\t\t.andReturn(false)\n\t\t\t\t.anyTimes();\n\t\texpect(mockTopology.isBroadcastDomainPort(DatapathId.of(EasyMock.anyLong()),\n\t\t\t\tOFPort.of(EasyMock.anyShort())))\n\t\t\t\t.andReturn(false)\n\t\t\t\t.anyTimes();\n\t\texpect(mockTopology.isInSameBroadcastDomain(DatapathId.of(EasyMock.anyLong()),\n\t\t\t\tOFPort.of(EasyMock.anyShort()),\n\t\t\t\tDatapathId.of(EasyMock.anyLong()),\n\t\t\t\tOFPort.of(EasyMock.anyShort()))).\n\t\t\t\tandReturn(false).anyTimes();\n\t\treplay(mockTopology);\n\n\t\tEntity e1 = new Entity(MacAddress.of(1L), VlanVid.ofVlan(1), null, null, null, new Date(2000));\n\t\tDevice d1 = deviceManager.learnDeviceByEntity(e1);\n\t\tassertArrayEquals(new Integer[0], d1.getIPv4Addresses());\n\n\n\t\tEntity e2 = new Entity(MacAddress.of(2L), VlanVid.ofVlan(2), IPv4Address.of(2), null, null, new Date(2000));\n\t\tDevice d2 = deviceManager.learnDeviceByEntity(e2);\n\t\td2 = deviceManager.learnDeviceByEntity(e2);\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(2) }, d2.getIPv4Addresses());\n\t\t// More than one entity\n\t\tEntity e2b = new Entity(MacAddress.of(2L), VlanVid.ofVlan(2), null, DatapathId.of(2L), OFPort.of(2), new Date(3000));\n\t\td2 = deviceManager.learnDeviceByEntity(e2b);\n\t\tassertEquals(2, d2.entities.length);\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(2) }, d2.getIPv4Addresses());\n\t\t// and now add an entity with an IP\n\t\tEntity e2c = new Entity(MacAddress.of(2L), VlanVid.ofVlan(2), IPv4Address.of(2), DatapathId.of(2L), OFPort.of(3), new Date(3000));\n\t\td2 = deviceManager.learnDeviceByEntity(e2c);\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(2) }, d2.getIPv4Addresses());\n\t\tassertEquals(3, d2.entities.length);\n\n\t\t// Other devices with different IPs shouldn't interfere\n\t\tEntity e3 = new Entity(MacAddress.of(3L), VlanVid.ofVlan(3), IPv4Address.of(3), null, null, new Date(4000));\n\t\tEntity e3b = new Entity(MacAddress.of(3L), VlanVid.ofVlan(3), IPv4Address.of(3), DatapathId.of(3L), OFPort.of(3), new Date(4400));\n\t\tDevice d3 = deviceManager.learnDeviceByEntity(e3);\n\t\td3 = deviceManager.learnDeviceByEntity(e3b);\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(2) }, d2.getIPv4Addresses());\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(3) }, d3.getIPv4Addresses());\n\n\t\t// Add another IP to d3\n\t\tEntity e3c = new Entity(MacAddress.of(3L), VlanVid.ofVlan(3), IPv4Address.of(33), DatapathId.of(3L), OFPort.of(3), new Date(4400));\n\t\td3 = deviceManager.learnDeviceByEntity(e3c);\n\t\tIPv4Address[] ips = d3.getIPv4Addresses();\n\t\tArrays.sort(ips);\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(3), IPv4Address.of(33) }, ips);\n\n\t\t// Add another device that also claims IP2 but is older than e2\n\t\tEntity e4 = new Entity(MacAddress.of(4L), VlanVid.ofVlan(4), IPv4Address.of(2), null, null, new Date(1000));\n\t\tEntity e4b = new Entity(MacAddress.of(4L), VlanVid.ofVlan(4), null, DatapathId.of(4L), OFPort.of(4), new Date(1000));\n\t\tDevice d4 = deviceManager.learnDeviceByEntity(e4);\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(2) }, d2.getIPv4Addresses());\n\t\tassertArrayEquals(new IPv4Address[0],  d4.getIPv4Addresses());\n\t\t// add another entity to d4\n\t\td4 = deviceManager.learnDeviceByEntity(e4b);\n\t\tassertArrayEquals(new IPv4Address[0], d4.getIPv4Addresses());\n\n\t\t// Make e4 and e4a newer\n\t\tEntity e4c = new Entity(MacAddress.of(4L), VlanVid.ofVlan(4), IPv4Address.of(2), null, null, new Date(5000));\n\t\tEntity e4d = new Entity(MacAddress.of(4L), VlanVid.ofVlan(4), null, DatapathId.of(4L), OFPort.of(5), new Date(5000));\n\t\td4 = deviceManager.learnDeviceByEntity(e4c);\n\t\td4 = deviceManager.learnDeviceByEntity(e4d);\n\t\tassertArrayEquals(new IPv4Address[0], d2.getIPv4Addresses());\n\t\t// FIXME: d4 should not return IP4\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(2) }, d4.getIPv4Addresses());\n\n\t\t// Add another newer entity to d2 but with different IP\n\t\tEntity e2d = new Entity(MacAddress.of(2L), VlanVid.ofVlan(2), IPv4Address.of(22), DatapathId.of(4L), OFPort.of(6), new Date(6000));\n\t\td2 = deviceManager.learnDeviceByEntity(e2d);\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(22) }, d2.getIPv4Addresses());\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(2) }, d4.getIPv4Addresses());\n\n\t\t// new IP for d2,d4 but with same timestamp. Both devices get the IP\n\t\tEntity e2e = new Entity(MacAddress.of(2L), VlanVid.ofVlan(2), IPv4Address.of(42), DatapathId.of(2L), OFPort.of(4), new Date(7000));\n\t\td2 = deviceManager.learnDeviceByEntity(e2e);\n\t\tips= d2.getIPv4Addresses();\n\t\tArrays.sort(ips);\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(22), IPv4Address.of(42) }, ips);\n\t\tEntity e4e = new Entity(MacAddress.of(4L), VlanVid.ofVlan(4), IPv4Address.of(42), DatapathId.of(4L), OFPort.of(7), new Date(7000));\n\t\td4 = deviceManager.learnDeviceByEntity(e4e);\n\t\tips= d4.getIPv4Addresses();\n\t\tArrays.sort(ips);\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(2), IPv4Address.of(42) }, ips);\n\n\t\t// add a couple more IPs\n\t\tEntity e2f = new Entity(MacAddress.of(2L), VlanVid.ofVlan(2), IPv4Address.of(4242), DatapathId.of(2L), OFPort.of(5), new Date(8000));\n\t\td2 = deviceManager.learnDeviceByEntity(e2f);\n\t\tips= d2.getIPv4Addresses();\n\t\tArrays.sort(ips);\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(22), IPv4Address.of(42), IPv4Address.of(4242) }, ips);\n\t\tEntity e4f = new Entity(MacAddress.of(4L), VlanVid.ofVlan(4), IPv4Address.of(4242), DatapathId.of(4L), OFPort.of(8), new Date(9000));\n\t\td4 = deviceManager.learnDeviceByEntity(e4f);\n\t\tips= d4.getIPv4Addresses();\n\t\tArrays.sort(ips);\n\t\tassertArrayEquals(new IPv4Address[] { IPv4Address.of(2), IPv4Address.of(42), IPv4Address.of(4242) }, ips);\n\t}", "signature": "void testGetIPv4Addresses()", "full_signature": "@Test public void testGetIPv4Addresses()", "class_method_signature": "DeviceManagerImplTest.testGetIPv4Addresses()", "testcase": true, "constructor": false, "invocations": ["createMock", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "of", "anyLong", "of", "anyShort", "anyTimes", "andReturn", "expect", "getL2DomainId", "of", "anyLong", "of", "anyTimes", "andReturn", "expect", "isConsistent", "of", "anyLong", "of", "anyShort", "of", "anyLong", "of", "anyShort", "anyTimes", "andReturn", "expect", "isBroadcastDomainPort", "of", "anyLong", "of", "anyShort", "anyTimes", "andReturn", "expect", "isInSameBroadcastDomain", "of", "anyLong", "of", "anyShort", "of", "anyLong", "of", "anyShort", "replay", "of", "ofVlan", "learnDeviceByEntity", "assertArrayEquals", "getIPv4Addresses", "of", "ofVlan", "of", "learnDeviceByEntity", "learnDeviceByEntity", "assertArrayEquals", "of", "getIPv4Addresses", "of", "ofVlan", "of", "of", "learnDeviceByEntity", "assertEquals", "assertArrayEquals", "of", "getIPv4Addresses", "of", "ofVlan", "of", "of", "of", "learnDeviceByEntity", "assertArrayEquals", "of", "getIPv4Addresses", "assertEquals", "of", "ofVlan", "of", "of", "ofVlan", "of", "of", "of", "learnDeviceByEntity", "learnDeviceByEntity", "assertArrayEquals", "of", "getIPv4Addresses", "assertArrayEquals", "of", "getIPv4Addresses", "of", "ofVlan", "of", "of", "of", "learnDeviceByEntity", "getIPv4Addresses", "sort", "assertArrayEquals", "of", "of", "of", "ofVlan", "of", "of", "ofVlan", "of", "of", "learnDeviceByEntity", "assertArrayEquals", "of", "getIPv4Addresses", "assertArrayEquals", "getIPv4Addresses", "learnDeviceByEntity", "assertArrayEquals", "getIPv4Addresses", "of", "ofVlan", "of", "of", "ofVlan", "of", "of", "learnDeviceByEntity", "learnDeviceByEntity", "assertArrayEquals", "getIPv4Addresses", "assertArrayEquals", "of", "getIPv4Addresses", "of", "ofVlan", "of", "of", "of", "learnDeviceByEntity", "assertArrayEquals", "of", "getIPv4Addresses", "assertArrayEquals", "of", "getIPv4Addresses", "of", "ofVlan", "of", "of", "of", "learnDeviceByEntity", "getIPv4Addresses", "sort", "assertArrayEquals", "of", "of", "of", "ofVlan", "of", "of", "of", "learnDeviceByEntity", "getIPv4Addresses", "sort", "assertArrayEquals", "of", "of", "of", "ofVlan", "of", "of", "of", "learnDeviceByEntity", "getIPv4Addresses", "sort", "assertArrayEquals", "of", "of", "of", "of", "ofVlan", "of", "of", "of", "learnDeviceByEntity", "getIPv4Addresses", "sort", "assertArrayEquals", "of", "of", "of"]}, "focal_class": {"identifier": "DeviceManagerImpl", "superclass": "", "interfaces": "implements IDeviceService, IOFMessageListener, ITopologyListener, IFloodlightModule, IEntityClassListener, IInfoProvider", "fields": [{"original_string": "protected static Logger logger = LoggerFactory.getLogger(DeviceManagerImpl.class);", "modifier": "protected static", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(DeviceManagerImpl.class)", "var_name": "logger"}, {"original_string": "protected IFloodlightProviderService floodlightProvider;", "modifier": "protected", "type": "IFloodlightProviderService", "declarator": "floodlightProvider", "var_name": "floodlightProvider"}, {"original_string": "protected ITopologyService topology;", "modifier": "protected", "type": "ITopologyService", "declarator": "topology", "var_name": "topology"}, {"original_string": "protected IStorageSourceService storageSource;", "modifier": "protected", "type": "IStorageSourceService", "declarator": "storageSource", "var_name": "storageSource"}, {"original_string": "protected IRestApiService restApi;", "modifier": "protected", "type": "IRestApiService", "declarator": "restApi", "var_name": "restApi"}, {"original_string": "protected IThreadPoolService threadPool;", "modifier": "protected", "type": "IThreadPoolService", "declarator": "threadPool", "var_name": "threadPool"}, {"original_string": "protected IDebugCounterService debugCounters;", "modifier": "protected", "type": "IDebugCounterService", "declarator": "debugCounters", "var_name": "debugCounters"}, {"original_string": "private ISyncService syncService;", "modifier": "private", "type": "ISyncService", "declarator": "syncService", "var_name": "syncService"}, {"original_string": "private IStoreClient<String, DeviceSyncRepresentation> storeClient;", "modifier": "private", "type": "IStoreClient<String, DeviceSyncRepresentation>", "declarator": "storeClient", "var_name": "storeClient"}, {"original_string": "private DeviceSyncManager deviceSyncManager;", "modifier": "private", "type": "DeviceSyncManager", "declarator": "deviceSyncManager", "var_name": "deviceSyncManager"}, {"original_string": "public static final String MODULE_NAME = \"devicemanager\";", "modifier": "public static final", "type": "String", "declarator": "MODULE_NAME = \"devicemanager\"", "var_name": "MODULE_NAME"}, {"original_string": "public static final String PACKAGE = DeviceManagerImpl.class.getPackage().getName();", "modifier": "public static final", "type": "String", "declarator": "PACKAGE = DeviceManagerImpl.class.getPackage().getName()", "var_name": "PACKAGE"}, {"original_string": "public IDebugCounter cntIncoming;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntIncoming", "var_name": "cntIncoming"}, {"original_string": "public IDebugCounter cntReconcileRequest;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntReconcileRequest", "var_name": "cntReconcileRequest"}, {"original_string": "public IDebugCounter cntReconcileNoSource;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntReconcileNoSource", "var_name": "cntReconcileNoSource"}, {"original_string": "public IDebugCounter cntReconcileNoDest;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntReconcileNoDest", "var_name": "cntReconcileNoDest"}, {"original_string": "public IDebugCounter cntInvalidSource;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntInvalidSource", "var_name": "cntInvalidSource"}, {"original_string": "public IDebugCounter cntInvalidDest;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntInvalidDest", "var_name": "cntInvalidDest"}, {"original_string": "public IDebugCounter cntNoSource;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntNoSource", "var_name": "cntNoSource"}, {"original_string": "public IDebugCounter cntNoDest;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntNoDest", "var_name": "cntNoDest"}, {"original_string": "public IDebugCounter cntDhcpClientNameSnooped;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntDhcpClientNameSnooped", "var_name": "cntDhcpClientNameSnooped"}, {"original_string": "public IDebugCounter cntDeviceOnInternalPortNotLearned;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntDeviceOnInternalPortNotLearned", "var_name": "cntDeviceOnInternalPortNotLearned"}, {"original_string": "public IDebugCounter cntPacketNotAllowed;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntPacketNotAllowed", "var_name": "cntPacketNotAllowed"}, {"original_string": "public IDebugCounter cntNewDevice;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntNewDevice", "var_name": "cntNewDevice"}, {"original_string": "public IDebugCounter cntPacketOnInternalPortForKnownDevice;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntPacketOnInternalPortForKnownDevice", "var_name": "cntPacketOnInternalPortForKnownDevice"}, {"original_string": "public IDebugCounter cntNewEntity;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntNewEntity", "var_name": "cntNewEntity"}, {"original_string": "public IDebugCounter cntDeviceChanged;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntDeviceChanged", "var_name": "cntDeviceChanged"}, {"original_string": "public IDebugCounter cntDeviceMoved;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntDeviceMoved", "var_name": "cntDeviceMoved"}, {"original_string": "public IDebugCounter cntCleanupEntitiesRuns;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntCleanupEntitiesRuns", "var_name": "cntCleanupEntitiesRuns"}, {"original_string": "public IDebugCounter cntEntityRemovedTimeout;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntEntityRemovedTimeout", "var_name": "cntEntityRemovedTimeout"}, {"original_string": "public IDebugCounter cntDeviceDeleted;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntDeviceDeleted", "var_name": "cntDeviceDeleted"}, {"original_string": "public IDebugCounter cntDeviceReclassifyDelete;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntDeviceReclassifyDelete", "var_name": "cntDeviceReclassifyDelete"}, {"original_string": "public IDebugCounter cntDeviceStrored;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntDeviceStrored", "var_name": "cntDeviceStrored"}, {"original_string": "public IDebugCounter cntDeviceStoreThrottled;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntDeviceStoreThrottled", "var_name": "cntDeviceStoreThrottled"}, {"original_string": "public IDebugCounter cntDeviceRemovedFromStore;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntDeviceRemovedFromStore", "var_name": "cntDeviceRemovedFromStore"}, {"original_string": "public IDebugCounter cntSyncException;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntSyncException", "var_name": "cntSyncException"}, {"original_string": "public IDebugCounter cntDevicesFromStore;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntDevicesFromStore", "var_name": "cntDevicesFromStore"}, {"original_string": "public IDebugCounter cntConsolidateStoreRuns;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntConsolidateStoreRuns", "var_name": "cntConsolidateStoreRuns"}, {"original_string": "public IDebugCounter cntConsolidateStoreDevicesRemoved;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntConsolidateStoreDevicesRemoved", "var_name": "cntConsolidateStoreDevicesRemoved"}, {"original_string": "public IDebugCounter cntTransitionToMaster;", "modifier": "public", "type": "IDebugCounter", "declarator": "cntTransitionToMaster", "var_name": "cntTransitionToMaster"}, {"original_string": "private IDebugEventService debugEventService;", "modifier": "private", "type": "IDebugEventService", "declarator": "debugEventService", "var_name": "debugEventService"}, {"original_string": "private IEventCategory<DeviceEvent> debugEventCategory;", "modifier": "private", "type": "IEventCategory<DeviceEvent>", "declarator": "debugEventCategory", "var_name": "debugEventCategory"}, {"original_string": "private boolean isMaster = false;", "modifier": "private", "type": "boolean", "declarator": "isMaster = false", "var_name": "isMaster"}, {"original_string": "static final String DEVICE_SYNC_STORE_NAME =\n\t\t\tDeviceManagerImpl.class.getCanonicalName() + \".stateStore\";", "modifier": "static final", "type": "String", "declarator": "DEVICE_SYNC_STORE_NAME =\n\t\t\tDeviceManagerImpl.class.getCanonicalName() + \".stateStore\"", "var_name": "DEVICE_SYNC_STORE_NAME"}, {"original_string": "static final int DEFAULT_SYNC_STORE_WRITE_INTERVAL_MS = 5*60*1000;", "modifier": "static final", "type": "int", "declarator": "DEFAULT_SYNC_STORE_WRITE_INTERVAL_MS = 5*60*1000", "var_name": "DEFAULT_SYNC_STORE_WRITE_INTERVAL_MS"}, {"original_string": "private int syncStoreWriteIntervalMs = DEFAULT_SYNC_STORE_WRITE_INTERVAL_MS;", "modifier": "private", "type": "int", "declarator": "syncStoreWriteIntervalMs = DEFAULT_SYNC_STORE_WRITE_INTERVAL_MS", "var_name": "syncStoreWriteIntervalMs"}, {"original_string": "static final int DEFAULT_INITIAL_SYNC_STORE_CONSOLIDATE_MS =\n\t\t\t15*1000;", "modifier": "static final", "type": "int", "declarator": "DEFAULT_INITIAL_SYNC_STORE_CONSOLIDATE_MS =\n\t\t\t15*1000", "var_name": "DEFAULT_INITIAL_SYNC_STORE_CONSOLIDATE_MS"}, {"original_string": "private int initialSyncStoreConsolidateMs =\n\t\t\tDEFAULT_INITIAL_SYNC_STORE_CONSOLIDATE_MS;", "modifier": "private", "type": "int", "declarator": "initialSyncStoreConsolidateMs =\n\t\t\tDEFAULT_INITIAL_SYNC_STORE_CONSOLIDATE_MS", "var_name": "initialSyncStoreConsolidateMs"}, {"original_string": "static final int DEFAULT_SYNC_STORE_CONSOLIDATE_INTERVAL_MS =\n\t\t\t75*60*1000;", "modifier": "static final", "type": "int", "declarator": "DEFAULT_SYNC_STORE_CONSOLIDATE_INTERVAL_MS =\n\t\t\t75*60*1000", "var_name": "DEFAULT_SYNC_STORE_CONSOLIDATE_INTERVAL_MS"}, {"original_string": "private final int syncStoreConsolidateIntervalMs =\n\t\t\tDEFAULT_SYNC_STORE_CONSOLIDATE_INTERVAL_MS;", "modifier": "private final", "type": "int", "declarator": "syncStoreConsolidateIntervalMs =\n\t\t\tDEFAULT_SYNC_STORE_CONSOLIDATE_INTERVAL_MS", "var_name": "syncStoreConsolidateIntervalMs"}, {"original_string": "protected static final int ENTITY_TIMEOUT = 60*60*1000;", "modifier": "protected static final", "type": "int", "declarator": "ENTITY_TIMEOUT = 60*60*1000", "var_name": "ENTITY_TIMEOUT"}, {"original_string": "protected static final int ENTITY_CLEANUP_INTERVAL = 60*60;", "modifier": "protected static final", "type": "int", "declarator": "ENTITY_CLEANUP_INTERVAL = 60*60", "var_name": "ENTITY_CLEANUP_INTERVAL"}, {"original_string": "protected ConcurrentHashMap<Long, Device> deviceMap;", "modifier": "protected", "type": "ConcurrentHashMap<Long, Device>", "declarator": "deviceMap", "var_name": "deviceMap"}, {"original_string": "protected AtomicLong deviceKeyCounter = new AtomicLong(0);", "modifier": "protected", "type": "AtomicLong", "declarator": "deviceKeyCounter = new AtomicLong(0)", "var_name": "deviceKeyCounter"}, {"original_string": "protected DeviceUniqueIndex primaryIndex;", "modifier": "protected", "type": "DeviceUniqueIndex", "declarator": "primaryIndex", "var_name": "primaryIndex"}, {"original_string": "protected Map<EnumSet<DeviceField>, DeviceIndex> secondaryIndexMap;", "modifier": "protected", "type": "Map<EnumSet<DeviceField>, DeviceIndex>", "declarator": "secondaryIndexMap", "var_name": "secondaryIndexMap"}, {"original_string": "protected ConcurrentHashMap<String, ClassState> classStateMap;", "modifier": "protected", "type": "ConcurrentHashMap<String, ClassState>", "declarator": "classStateMap", "var_name": "classStateMap"}, {"original_string": "protected Set<EnumSet<DeviceField>> perClassIndices;", "modifier": "protected", "type": "Set<EnumSet<DeviceField>>", "declarator": "perClassIndices", "var_name": "perClassIndices"}, {"original_string": "protected IEntityClassifierService entityClassifier;", "modifier": "protected", "type": "IEntityClassifierService", "declarator": "entityClassifier", "var_name": "entityClassifier"}, {"original_string": "protected ListenerDispatcher<String,IDeviceListener> deviceListeners;", "modifier": "protected", "type": "ListenerDispatcher<String,IDeviceListener>", "declarator": "deviceListeners", "var_name": "deviceListeners"}, {"original_string": "public AttachmentPointComparator apComparator;", "modifier": "public", "type": "AttachmentPointComparator", "declarator": "apComparator", "var_name": "apComparator"}, {"original_string": "private Set<SwitchPort> suppressAPs;", "modifier": "private", "type": "Set<SwitchPort>", "declarator": "suppressAPs", "var_name": "suppressAPs"}, {"original_string": "public SingletonTask entityCleanupTask;", "modifier": "public", "type": "SingletonTask", "declarator": "entityCleanupTask", "var_name": "entityCleanupTask"}, {"original_string": "private SingletonTask storeConsolidateTask;", "modifier": "private", "type": "SingletonTask", "declarator": "storeConsolidateTask", "var_name": "storeConsolidateTask"}, {"original_string": "protected HAListenerDelegate haListenerDelegate;", "modifier": "protected", "type": "HAListenerDelegate", "declarator": "haListenerDelegate", "var_name": "haListenerDelegate"}], "methods": [{"identifier": "getDevice", "parameters": "(Long deviceKey)", "modifiers": "@Override public", "return": "IDevice", "signature": "IDevice getDevice(Long deviceKey)", "full_signature": "@Override public IDevice getDevice(Long deviceKey)", "class_method_signature": "DeviceManagerImpl.getDevice(Long deviceKey)", "testcase": false, "constructor": false}, {"identifier": "findDevice", "parameters": "(MacAddress macAddress, VlanVid vlan,\n\t\t\tIPv4Address ipv4Address, DatapathId switchDPID,\n\t\t\tOFPort switchPort)", "modifiers": "@Override public", "return": "IDevice", "signature": "IDevice findDevice(MacAddress macAddress, VlanVid vlan,\n\t\t\tIPv4Address ipv4Address, DatapathId switchDPID,\n\t\t\tOFPort switchPort)", "full_signature": "@Override public IDevice findDevice(MacAddress macAddress, VlanVid vlan,\n\t\t\tIPv4Address ipv4Address, DatapathId switchDPID,\n\t\t\tOFPort switchPort)", "class_method_signature": "DeviceManagerImpl.findDevice(MacAddress macAddress, VlanVid vlan,\n\t\t\tIPv4Address ipv4Address, DatapathId switchDPID,\n\t\t\tOFPort switchPort)", "testcase": false, "constructor": false}, {"identifier": "findClassDevice", "parameters": "(IEntityClass entityClass, MacAddress macAddress,\n\t\t\tVlanVid vlan, IPv4Address ipv4Address)", "modifiers": "@Override public", "return": "IDevice", "signature": "IDevice findClassDevice(IEntityClass entityClass, MacAddress macAddress,\n\t\t\tVlanVid vlan, IPv4Address ipv4Address)", "full_signature": "@Override public IDevice findClassDevice(IEntityClass entityClass, MacAddress macAddress,\n\t\t\tVlanVid vlan, IPv4Address ipv4Address)", "class_method_signature": "DeviceManagerImpl.findClassDevice(IEntityClass entityClass, MacAddress macAddress,\n\t\t\tVlanVid vlan, IPv4Address ipv4Address)", "testcase": false, "constructor": false}, {"identifier": "getAllDevices", "parameters": "()", "modifiers": "@Override public", "return": "Collection<? extends IDevice>", "signature": "Collection<? extends IDevice> getAllDevices()", "full_signature": "@Override public Collection<? extends IDevice> getAllDevices()", "class_method_signature": "DeviceManagerImpl.getAllDevices()", "testcase": false, "constructor": false}, {"identifier": "addIndex", "parameters": "(boolean perClass,\n\t\t\tEnumSet<DeviceField> keyFields)", "modifiers": "@Override public", "return": "void", "signature": "void addIndex(boolean perClass,\n\t\t\tEnumSet<DeviceField> keyFields)", "full_signature": "@Override public void addIndex(boolean perClass,\n\t\t\tEnumSet<DeviceField> keyFields)", "class_method_signature": "DeviceManagerImpl.addIndex(boolean perClass,\n\t\t\tEnumSet<DeviceField> keyFields)", "testcase": false, "constructor": false}, {"identifier": "queryDevices", "parameters": "(MacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "modifiers": "@Override public", "return": "Iterator<? extends IDevice>", "signature": "Iterator<? extends IDevice> queryDevices(MacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "full_signature": "@Override public Iterator<? extends IDevice> queryDevices(MacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "class_method_signature": "DeviceManagerImpl.queryDevices(MacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "testcase": false, "constructor": false}, {"identifier": "queryClassDevices", "parameters": "(IEntityClass entityClass,\n\t\t\tMacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "modifiers": "@Override public", "return": "Iterator<? extends IDevice>", "signature": "Iterator<? extends IDevice> queryClassDevices(IEntityClass entityClass,\n\t\t\tMacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "full_signature": "@Override public Iterator<? extends IDevice> queryClassDevices(IEntityClass entityClass,\n\t\t\tMacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "class_method_signature": "DeviceManagerImpl.queryClassDevices(IEntityClass entityClass,\n\t\t\tMacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "testcase": false, "constructor": false}, {"identifier": "getDeviceIteratorForQuery", "parameters": "(MacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "modifiers": "protected", "return": "Iterator<Device>", "signature": "Iterator<Device> getDeviceIteratorForQuery(MacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "full_signature": "protected Iterator<Device> getDeviceIteratorForQuery(MacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "class_method_signature": "DeviceManagerImpl.getDeviceIteratorForQuery(MacAddress macAddress,\n\t\t\tVlanVid vlan,\n\t\t\tIPv4Address ipv4Address,\n\t\t\tDatapathId switchDPID,\n\t\t\tOFPort switchPort)", "testcase": false, "constructor": false}, {"identifier": "addListener", "parameters": "(IDeviceListener listener)", "modifiers": "@Override public", "return": "void", "signature": "void addListener(IDeviceListener listener)", "full_signature": "@Override public void addListener(IDeviceListener listener)", "class_method_signature": "DeviceManagerImpl.addListener(IDeviceListener listener)", "testcase": false, "constructor": false}, {"identifier": "addSuppressAPs", "parameters": "(DatapathId swId, OFPort port)", "modifiers": "@Override public", "return": "void", "signature": "void addSuppressAPs(DatapathId swId, OFPort port)", "full_signature": "@Override public void addSuppressAPs(DatapathId swId, OFPort port)", "class_method_signature": "DeviceManagerImpl.addSuppressAPs(DatapathId swId, OFPort port)", "testcase": false, "constructor": false}, {"identifier": "removeSuppressAPs", "parameters": "(DatapathId swId, OFPort port)", "modifiers": "@Override public", "return": "void", "signature": "void removeSuppressAPs(DatapathId swId, OFPort port)", "full_signature": "@Override public void removeSuppressAPs(DatapathId swId, OFPort port)", "class_method_signature": "DeviceManagerImpl.removeSuppressAPs(DatapathId swId, OFPort port)", "testcase": false, "constructor": false}, {"identifier": "getSuppressAPs", "parameters": "()", "modifiers": "@Override public", "return": "Set<SwitchPort>", "signature": "Set<SwitchPort> getSuppressAPs()", "full_signature": "@Override public Set<SwitchPort> getSuppressAPs()", "class_method_signature": "DeviceManagerImpl.getSuppressAPs()", "testcase": false, "constructor": false}, {"identifier": "logListeners", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void logListeners()", "full_signature": "private void logListeners()", "class_method_signature": "DeviceManagerImpl.logListeners()", "testcase": false, "constructor": false}, {"identifier": "getInfo", "parameters": "(String type)", "modifiers": "@Override public", "return": "Map<String, Object>", "signature": "Map<String, Object> getInfo(String type)", "full_signature": "@Override public Map<String, Object> getInfo(String type)", "class_method_signature": "DeviceManagerImpl.getInfo(String type)", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getName()", "full_signature": "@Override public String getName()", "class_method_signature": "DeviceManagerImpl.getName()", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPrereq", "parameters": "(OFType type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPrereq(OFType type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPrereq(OFType type, String name)", "class_method_signature": "DeviceManagerImpl.isCallbackOrderingPrereq(OFType type, String name)", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPostreq", "parameters": "(OFType type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPostreq(OFType type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPostreq(OFType type, String name)", "class_method_signature": "DeviceManagerImpl.isCallbackOrderingPostreq(OFType type, String name)", "testcase": false, "constructor": false}, {"identifier": "receive", "parameters": "(IOFSwitch sw, OFMessage msg,\n\t\t\tFloodlightContext cntx)", "modifiers": "@Override public", "return": "Command", "signature": "Command receive(IOFSwitch sw, OFMessage msg,\n\t\t\tFloodlightContext cntx)", "full_signature": "@Override public Command receive(IOFSwitch sw, OFMessage msg,\n\t\t\tFloodlightContext cntx)", "class_method_signature": "DeviceManagerImpl.receive(IOFSwitch sw, OFMessage msg,\n\t\t\tFloodlightContext cntx)", "testcase": false, "constructor": false}, {"identifier": "getModuleServices", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleServices()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleServices()", "class_method_signature": "DeviceManagerImpl.getModuleServices()", "testcase": false, "constructor": false}, {"identifier": "getServiceImpls", "parameters": "()", "modifiers": "@Override public", "return": "Map<Class<? extends IFloodlightService>, IFloodlightService>", "signature": "Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "full_signature": "@Override public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "class_method_signature": "DeviceManagerImpl.getServiceImpls()", "testcase": false, "constructor": false}, {"identifier": "getModuleDependencies", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "class_method_signature": "DeviceManagerImpl.getModuleDependencies()", "testcase": false, "constructor": false}, {"identifier": "init", "parameters": "(FloodlightModuleContext fmc)", "modifiers": "@Override public", "return": "void", "signature": "void init(FloodlightModuleContext fmc)", "full_signature": "@Override public void init(FloodlightModuleContext fmc)", "class_method_signature": "DeviceManagerImpl.init(FloodlightModuleContext fmc)", "testcase": false, "constructor": false}, {"identifier": "registerDeviceManagerDebugEvents", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void registerDeviceManagerDebugEvents()", "full_signature": "private void registerDeviceManagerDebugEvents()", "class_method_signature": "DeviceManagerImpl.registerDeviceManagerDebugEvents()", "testcase": false, "constructor": false}, {"identifier": "startUp", "parameters": "(FloodlightModuleContext fmc)", "modifiers": "@Override public", "return": "void", "signature": "void startUp(FloodlightModuleContext fmc)", "full_signature": "@Override public void startUp(FloodlightModuleContext fmc)", "class_method_signature": "DeviceManagerImpl.startUp(FloodlightModuleContext fmc)", "testcase": false, "constructor": false}, {"identifier": "registerDeviceManagerDebugCounters", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void registerDeviceManagerDebugCounters()", "full_signature": "private void registerDeviceManagerDebugCounters()", "class_method_signature": "DeviceManagerImpl.registerDeviceManagerDebugCounters()", "testcase": false, "constructor": false}, {"identifier": "processPacketInMessage", "parameters": "(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "modifiers": "protected", "return": "Command", "signature": "Command processPacketInMessage(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "full_signature": "protected Command processPacketInMessage(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "class_method_signature": "DeviceManagerImpl.processPacketInMessage(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "testcase": false, "constructor": false}, {"identifier": "snoopDHCPClientName", "parameters": "(Ethernet eth, Device srcDevice)", "modifiers": "private", "return": "void", "signature": "void snoopDHCPClientName(Ethernet eth, Device srcDevice)", "full_signature": "private void snoopDHCPClientName(Ethernet eth, Device srcDevice)", "class_method_signature": "DeviceManagerImpl.snoopDHCPClientName(Ethernet eth, Device srcDevice)", "testcase": false, "constructor": false}, {"identifier": "isValidAttachmentPoint", "parameters": "(DatapathId switchDPID,\n\t\t\tOFPort switchPort)", "modifiers": "public", "return": "boolean", "signature": "boolean isValidAttachmentPoint(DatapathId switchDPID,\n\t\t\tOFPort switchPort)", "full_signature": "public boolean isValidAttachmentPoint(DatapathId switchDPID,\n\t\t\tOFPort switchPort)", "class_method_signature": "DeviceManagerImpl.isValidAttachmentPoint(DatapathId switchDPID,\n\t\t\tOFPort switchPort)", "testcase": false, "constructor": false}, {"identifier": "getSrcNwAddr", "parameters": "(Ethernet eth, MacAddress dlAddr)", "modifiers": "private", "return": "IPv4Address", "signature": "IPv4Address getSrcNwAddr(Ethernet eth, MacAddress dlAddr)", "full_signature": "private IPv4Address getSrcNwAddr(Ethernet eth, MacAddress dlAddr)", "class_method_signature": "DeviceManagerImpl.getSrcNwAddr(Ethernet eth, MacAddress dlAddr)", "testcase": false, "constructor": false}, {"identifier": "getSourceEntityFromPacket", "parameters": "(Ethernet eth, DatapathId swdpid, OFPort port)", "modifiers": "protected", "return": "Entity", "signature": "Entity getSourceEntityFromPacket(Ethernet eth, DatapathId swdpid, OFPort port)", "full_signature": "protected Entity getSourceEntityFromPacket(Ethernet eth, DatapathId swdpid, OFPort port)", "class_method_signature": "DeviceManagerImpl.getSourceEntityFromPacket(Ethernet eth, DatapathId swdpid, OFPort port)", "testcase": false, "constructor": false}, {"identifier": "learnDeviceFromArpResponseData", "parameters": "(Ethernet eth,\n\t\t\tDatapathId swdpid,\n\t\t\tOFPort port)", "modifiers": "protected", "return": "void", "signature": "void learnDeviceFromArpResponseData(Ethernet eth,\n\t\t\tDatapathId swdpid,\n\t\t\tOFPort port)", "full_signature": "protected void learnDeviceFromArpResponseData(Ethernet eth,\n\t\t\tDatapathId swdpid,\n\t\t\tOFPort port)", "class_method_signature": "DeviceManagerImpl.learnDeviceFromArpResponseData(Ethernet eth,\n\t\t\tDatapathId swdpid,\n\t\t\tOFPort port)", "testcase": false, "constructor": false}, {"identifier": "getDestEntityFromPacket", "parameters": "(Ethernet eth)", "modifiers": "protected", "return": "Entity", "signature": "Entity getDestEntityFromPacket(Ethernet eth)", "full_signature": "protected Entity getDestEntityFromPacket(Ethernet eth)", "class_method_signature": "DeviceManagerImpl.getDestEntityFromPacket(Ethernet eth)", "testcase": false, "constructor": false}, {"identifier": "findDeviceByEntity", "parameters": "(Entity entity)", "modifiers": "protected", "return": "Device", "signature": "Device findDeviceByEntity(Entity entity)", "full_signature": "protected Device findDeviceByEntity(Entity entity)", "class_method_signature": "DeviceManagerImpl.findDeviceByEntity(Entity entity)", "testcase": false, "constructor": false}, {"identifier": "findDestByEntity", "parameters": "(IEntityClass reference,\n\t\t\tEntity dstEntity)", "modifiers": "protected", "return": "Device", "signature": "Device findDestByEntity(IEntityClass reference,\n\t\t\tEntity dstEntity)", "full_signature": "protected Device findDestByEntity(IEntityClass reference,\n\t\t\tEntity dstEntity)", "class_method_signature": "DeviceManagerImpl.findDestByEntity(IEntityClass reference,\n\t\t\tEntity dstEntity)", "testcase": false, "constructor": false}, {"identifier": "learnDeviceByEntity", "parameters": "(Entity entity)", "modifiers": "protected", "return": "Device", "signature": "Device learnDeviceByEntity(Entity entity)", "full_signature": "protected Device learnDeviceByEntity(Entity entity)", "class_method_signature": "DeviceManagerImpl.learnDeviceByEntity(Entity entity)", "testcase": false, "constructor": false}, {"identifier": "isEntityAllowed", "parameters": "(Entity entity, IEntityClass entityClass)", "modifiers": "protected", "return": "boolean", "signature": "boolean isEntityAllowed(Entity entity, IEntityClass entityClass)", "full_signature": "protected boolean isEntityAllowed(Entity entity, IEntityClass entityClass)", "class_method_signature": "DeviceManagerImpl.isEntityAllowed(Entity entity, IEntityClass entityClass)", "testcase": false, "constructor": false}, {"identifier": "findChangedFields", "parameters": "(Device device,\n\t\t\tEntity newEntity)", "modifiers": "protected", "return": "EnumSet<DeviceField>", "signature": "EnumSet<DeviceField> findChangedFields(Device device,\n\t\t\tEntity newEntity)", "full_signature": "protected EnumSet<DeviceField> findChangedFields(Device device,\n\t\t\tEntity newEntity)", "class_method_signature": "DeviceManagerImpl.findChangedFields(Device device,\n\t\t\tEntity newEntity)", "testcase": false, "constructor": false}, {"identifier": "processUpdates", "parameters": "(Queue<DeviceUpdate> updates)", "modifiers": "protected", "return": "void", "signature": "void processUpdates(Queue<DeviceUpdate> updates)", "full_signature": "protected void processUpdates(Queue<DeviceUpdate> updates)", "class_method_signature": "DeviceManagerImpl.processUpdates(Queue<DeviceUpdate> updates)", "testcase": false, "constructor": false}, {"identifier": "notifyListeners", "parameters": "(List<IDeviceListener> listeners, DeviceUpdate update)", "modifiers": "protected", "return": "void", "signature": "void notifyListeners(List<IDeviceListener> listeners, DeviceUpdate update)", "full_signature": "protected void notifyListeners(List<IDeviceListener> listeners, DeviceUpdate update)", "class_method_signature": "DeviceManagerImpl.notifyListeners(List<IDeviceListener> listeners, DeviceUpdate update)", "testcase": false, "constructor": false}, {"identifier": "allKeyFieldsPresent", "parameters": "(Entity e, EnumSet<DeviceField> keyFields)", "modifiers": "protected", "return": "boolean", "signature": "boolean allKeyFieldsPresent(Entity e, EnumSet<DeviceField> keyFields)", "full_signature": "protected boolean allKeyFieldsPresent(Entity e, EnumSet<DeviceField> keyFields)", "class_method_signature": "DeviceManagerImpl.allKeyFieldsPresent(Entity e, EnumSet<DeviceField> keyFields)", "testcase": false, "constructor": false}, {"identifier": "updateUpdates", "parameters": "(LinkedList<DeviceUpdate> list, DeviceUpdate update)", "modifiers": "private", "return": "LinkedList<DeviceUpdate>", "signature": "LinkedList<DeviceUpdate> updateUpdates(LinkedList<DeviceUpdate> list, DeviceUpdate update)", "full_signature": "private LinkedList<DeviceUpdate> updateUpdates(LinkedList<DeviceUpdate> list, DeviceUpdate update)", "class_method_signature": "DeviceManagerImpl.updateUpdates(LinkedList<DeviceUpdate> list, DeviceUpdate update)", "testcase": false, "constructor": false}, {"identifier": "getClassState", "parameters": "(IEntityClass clazz)", "modifiers": "private", "return": "ClassState", "signature": "ClassState getClassState(IEntityClass clazz)", "full_signature": "private ClassState getClassState(IEntityClass clazz)", "class_method_signature": "DeviceManagerImpl.getClassState(IEntityClass clazz)", "testcase": false, "constructor": false}, {"identifier": "updateIndices", "parameters": "(Device device, Long deviceKey)", "modifiers": "private", "return": "boolean", "signature": "boolean updateIndices(Device device, Long deviceKey)", "full_signature": "private boolean updateIndices(Device device, Long deviceKey)", "class_method_signature": "DeviceManagerImpl.updateIndices(Device device, Long deviceKey)", "testcase": false, "constructor": false}, {"identifier": "updateSecondaryIndices", "parameters": "(Entity entity,\n\t\t\t IEntityClass entityClass,\n\t\t\t Long deviceKey)", "modifiers": "private", "return": "void", "signature": "void updateSecondaryIndices(Entity entity,\n\t\t\t IEntityClass entityClass,\n\t\t\t Long deviceKey)", "full_signature": "private void updateSecondaryIndices(Entity entity,\n\t\t\t IEntityClass entityClass,\n\t\t\t Long deviceKey)", "class_method_signature": "DeviceManagerImpl.updateSecondaryIndices(Entity entity,\n\t\t\t IEntityClass entityClass,\n\t\t\t Long deviceKey)", "testcase": false, "constructor": false}, {"identifier": "cleanupEntities", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void cleanupEntities()", "full_signature": "protected void cleanupEntities()", "class_method_signature": "DeviceManagerImpl.cleanupEntities()", "testcase": false, "constructor": false}, {"identifier": "removeEntity", "parameters": "(Entity removed,\n\t\t\t IEntityClass entityClass,\n\t\t\t Long deviceKey,\n\t\t\t Collection<Entity> others)", "modifiers": "protected", "return": "void", "signature": "void removeEntity(Entity removed,\n\t\t\t IEntityClass entityClass,\n\t\t\t Long deviceKey,\n\t\t\t Collection<Entity> others)", "full_signature": "protected void removeEntity(Entity removed,\n\t\t\t IEntityClass entityClass,\n\t\t\t Long deviceKey,\n\t\t\t Collection<Entity> others)", "class_method_signature": "DeviceManagerImpl.removeEntity(Entity removed,\n\t\t\t IEntityClass entityClass,\n\t\t\t Long deviceKey,\n\t\t\t Collection<Entity> others)", "testcase": false, "constructor": false}, {"identifier": "deleteDevice", "parameters": "(Device device)", "modifiers": "protected", "return": "void", "signature": "void deleteDevice(Device device)", "full_signature": "protected void deleteDevice(Device device)", "class_method_signature": "DeviceManagerImpl.deleteDevice(Device device)", "testcase": false, "constructor": false}, {"identifier": "getEntityKeys", "parameters": "(MacAddress macAddress,\n\t\t\t VlanVid vlan,\n\t\t\t IPv4Address ipv4Address,\n\t\t\t DatapathId switchDPID,\n\t\t\t OFPort switchPort)", "modifiers": "private", "return": "EnumSet<DeviceField>", "signature": "EnumSet<DeviceField> getEntityKeys(MacAddress macAddress,\n\t\t\t VlanVid vlan,\n\t\t\t IPv4Address ipv4Address,\n\t\t\t DatapathId switchDPID,\n\t\t\t OFPort switchPort)", "full_signature": "private EnumSet<DeviceField> getEntityKeys(MacAddress macAddress,\n\t\t\t VlanVid vlan,\n\t\t\t IPv4Address ipv4Address,\n\t\t\t DatapathId switchDPID,\n\t\t\t OFPort switchPort)", "class_method_signature": "DeviceManagerImpl.getEntityKeys(MacAddress macAddress,\n\t\t\t VlanVid vlan,\n\t\t\t IPv4Address ipv4Address,\n\t\t\t DatapathId switchDPID,\n\t\t\t OFPort switchPort)", "testcase": false, "constructor": false}, {"identifier": "queryClassByEntity", "parameters": "(IEntityClass clazz,\n\t\t\t EnumSet<DeviceField> keyFields,\n\t\t\t Entity entity)", "modifiers": "protected", "return": "Iterator<Device>", "signature": "Iterator<Device> queryClassByEntity(IEntityClass clazz,\n\t\t\t EnumSet<DeviceField> keyFields,\n\t\t\t Entity entity)", "full_signature": "protected Iterator<Device> queryClassByEntity(IEntityClass clazz,\n\t\t\t EnumSet<DeviceField> keyFields,\n\t\t\t Entity entity)", "class_method_signature": "DeviceManagerImpl.queryClassByEntity(IEntityClass clazz,\n\t\t\t EnumSet<DeviceField> keyFields,\n\t\t\t Entity entity)", "testcase": false, "constructor": false}, {"identifier": "allocateDevice", "parameters": "(Long deviceKey,\n\t\t\t Entity entity,\n\t\t\t IEntityClass entityClass)", "modifiers": "protected", "return": "Device", "signature": "Device allocateDevice(Long deviceKey,\n\t\t\t Entity entity,\n\t\t\t IEntityClass entityClass)", "full_signature": "protected Device allocateDevice(Long deviceKey,\n\t\t\t Entity entity,\n\t\t\t IEntityClass entityClass)", "class_method_signature": "DeviceManagerImpl.allocateDevice(Long deviceKey,\n\t\t\t Entity entity,\n\t\t\t IEntityClass entityClass)", "testcase": false, "constructor": false}, {"identifier": "allocateDevice", "parameters": "(Long deviceKey,\n\t\t\t String dhcpClientName,\n\t\t\t List<AttachmentPoint> aps,\n\t\t\t List<AttachmentPoint> trueAPs,\n\t\t\t Collection<Entity> entities,\n\t\t\t IEntityClass entityClass)", "modifiers": "protected", "return": "Device", "signature": "Device allocateDevice(Long deviceKey,\n\t\t\t String dhcpClientName,\n\t\t\t List<AttachmentPoint> aps,\n\t\t\t List<AttachmentPoint> trueAPs,\n\t\t\t Collection<Entity> entities,\n\t\t\t IEntityClass entityClass)", "full_signature": "protected Device allocateDevice(Long deviceKey,\n\t\t\t String dhcpClientName,\n\t\t\t List<AttachmentPoint> aps,\n\t\t\t List<AttachmentPoint> trueAPs,\n\t\t\t Collection<Entity> entities,\n\t\t\t IEntityClass entityClass)", "class_method_signature": "DeviceManagerImpl.allocateDevice(Long deviceKey,\n\t\t\t String dhcpClientName,\n\t\t\t List<AttachmentPoint> aps,\n\t\t\t List<AttachmentPoint> trueAPs,\n\t\t\t Collection<Entity> entities,\n\t\t\t IEntityClass entityClass)", "testcase": false, "constructor": false}, {"identifier": "allocateDevice", "parameters": "(Device device,\n\t\t\t Entity entity,\n\t\t\t int insertionpoint)", "modifiers": "protected", "return": "Device", "signature": "Device allocateDevice(Device device,\n\t\t\t Entity entity,\n\t\t\t int insertionpoint)", "full_signature": "protected Device allocateDevice(Device device,\n\t\t\t Entity entity,\n\t\t\t int insertionpoint)", "class_method_signature": "DeviceManagerImpl.allocateDevice(Device device,\n\t\t\t Entity entity,\n\t\t\t int insertionpoint)", "testcase": false, "constructor": false}, {"identifier": "allocateDevice", "parameters": "(Device device, Set <Entity> entities)", "modifiers": "protected", "return": "Device", "signature": "Device allocateDevice(Device device, Set <Entity> entities)", "full_signature": "protected Device allocateDevice(Device device, Set <Entity> entities)", "class_method_signature": "DeviceManagerImpl.allocateDevice(Device device, Set <Entity> entities)", "testcase": false, "constructor": false}, {"identifier": "topologyChanged", "parameters": "(List<LDUpdate> updateList)", "modifiers": "@Override public", "return": "void", "signature": "void topologyChanged(List<LDUpdate> updateList)", "full_signature": "@Override public void topologyChanged(List<LDUpdate> updateList)", "class_method_signature": "DeviceManagerImpl.topologyChanged(List<LDUpdate> updateList)", "testcase": false, "constructor": false}, {"identifier": "sendDeviceMovedNotification", "parameters": "(Device d)", "modifiers": "protected", "return": "void", "signature": "void sendDeviceMovedNotification(Device d)", "full_signature": "protected void sendDeviceMovedNotification(Device d)", "class_method_signature": "DeviceManagerImpl.sendDeviceMovedNotification(Device d)", "testcase": false, "constructor": false}, {"identifier": "entityClassChanged", "parameters": "(Set<String> entityClassNames)", "modifiers": "@Override public", "return": "void", "signature": "void entityClassChanged(Set<String> entityClassNames)", "full_signature": "@Override public void entityClassChanged(Set<String> entityClassNames)", "class_method_signature": "DeviceManagerImpl.entityClassChanged(Set<String> entityClassNames)", "testcase": false, "constructor": false}, {"identifier": "reclassifyDevice", "parameters": "(Device device)", "modifiers": "protected", "return": "boolean", "signature": "boolean reclassifyDevice(Device device)", "full_signature": "protected boolean reclassifyDevice(Device device)", "class_method_signature": "DeviceManagerImpl.reclassifyDevice(Device device)", "testcase": false, "constructor": false}, {"identifier": "setSyncStoreWriteInterval", "parameters": "(int intervalMs)", "modifiers": "", "return": "void", "signature": "void setSyncStoreWriteInterval(int intervalMs)", "full_signature": " void setSyncStoreWriteInterval(int intervalMs)", "class_method_signature": "DeviceManagerImpl.setSyncStoreWriteInterval(int intervalMs)", "testcase": false, "constructor": false}, {"identifier": "setInitialSyncStoreConsolidateMs", "parameters": "(int intervalMs)", "modifiers": "", "return": "void", "signature": "void setInitialSyncStoreConsolidateMs(int intervalMs)", "full_signature": " void setInitialSyncStoreConsolidateMs(int intervalMs)", "class_method_signature": "DeviceManagerImpl.setInitialSyncStoreConsolidateMs(int intervalMs)", "testcase": false, "constructor": false}, {"identifier": "scheduleConsolidateStoreNow", "parameters": "()", "modifiers": "", "return": "void", "signature": "void scheduleConsolidateStoreNow()", "full_signature": " void scheduleConsolidateStoreNow()", "class_method_signature": "DeviceManagerImpl.scheduleConsolidateStoreNow()", "testcase": false, "constructor": false}, {"identifier": "setSyncServiceIfNotSet", "parameters": "(ISyncService syncService)", "modifiers": "protected", "return": "void", "signature": "void setSyncServiceIfNotSet(ISyncService syncService)", "full_signature": "protected void setSyncServiceIfNotSet(ISyncService syncService)", "class_method_signature": "DeviceManagerImpl.setSyncServiceIfNotSet(ISyncService syncService)", "testcase": false, "constructor": false}, {"identifier": "getHAListener", "parameters": "()", "modifiers": "", "return": "IHAListener", "signature": "IHAListener getHAListener()", "full_signature": " IHAListener getHAListener()", "class_method_signature": "DeviceManagerImpl.getHAListener()", "testcase": false, "constructor": false}], "file": "src/agents/apps/floodlight/floodlight-1.0/src/main/java/net/floodlightcontroller/devicemanager/internal/DeviceManagerImpl.java"}, "focal_method": {"identifier": "learnDeviceByEntity", "parameters": "(Entity entity)", "modifiers": "protected", "return": "Device", "body": "protected Device learnDeviceByEntity(Entity entity) {\n\t\tArrayList<Long> deleteQueue = null;\n\t\tLinkedList<DeviceUpdate> deviceUpdates = null;\n\t\tDevice device = null;\n\n\t\t// we may need to restart the learning process if we detect\n\t\t// concurrent modification.  Note that we ensure that at least\n\t\t// one thread should always succeed so we don't get into infinite\n\t\t// starvation loops\n\t\twhile (true) {\n\t\t\tdeviceUpdates = null;\n\n\t\t\t// Look up the fully-qualified entity to see if it already\n\t\t\t// exists in the primary entity index.\n\t\t\tLong deviceKey = primaryIndex.findByEntity(entity);\n\t\t\tIEntityClass entityClass = null;\n\n\t\t\tif (deviceKey == null) {\n\t\t\t\t// If the entity does not exist in the primary entity index,\n\t\t\t\t// use the entity classifier for find the classes for the\n\t\t\t\t// entity. Look up the entity in the returned class'\n\t\t\t\t// class entity index.\n\t\t\t\tentityClass = entityClassifier.classifyEntity(entity);\n\t\t\t\tif (entityClass == null) {\n\t\t\t\t\t// could not classify entity. No device\n\t\t\t\t\tdevice = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tClassState classState = getClassState(entityClass);\n\n\t\t\t\tif (classState.classIndex != null) {\n\t\t\t\t\tdeviceKey = classState.classIndex.findByEntity(entity);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (deviceKey != null) {\n\t\t\t\t// If the primary or secondary index contains the entity\n\t\t\t\t// use resulting device key to look up the device in the\n\t\t\t\t// device map, and use the referenced Device below.\n\t\t\t\tdevice = deviceMap.get(deviceKey);\n\t\t\t\tif (device == null) {\n\t\t\t\t\t// This can happen due to concurrent modification\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"No device for deviceKey {} while \"\n\t\t\t\t\t\t\t\t+ \"while processing entity {}\",\n\t\t\t\t\t\t\t\tdeviceKey, entity);\n\t\t\t\t\t}\n\t\t\t\t\t// if so, then try again till we don't even get the device key\n\t\t\t\t\t// and so we recreate the device\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If the secondary index does not contain the entity,\n\t\t\t\t// create a new Device object containing the entity, and\n\t\t\t\t// generate a new device ID if the the entity is on an\n\t\t\t\t// attachment point port. Otherwise ignore.\n\t\t\t\tif (entity.hasSwitchPort() && !topology.isAttachmentPointPort(entity.getSwitchDPID(), entity.getSwitchPort())) {\n\t\t\t\t\tcntDeviceOnInternalPortNotLearned.increment();\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Not learning new device on internal\"\n\t\t\t\t\t\t\t\t+ \" link: {}\", entity);\n\t\t\t\t\t}\n\t\t\t\t\tdevice = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Before we create the new device also check if\n\t\t\t\t// the entity is allowed (e.g., for spoofing protection)\n\t\t\t\tif (!isEntityAllowed(entity, entityClass)) {\n\t\t\t\t\tcntPacketNotAllowed.increment();\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"PacketIn is not allowed {} {}\",\n\t\t\t\t\t\t\t\tentityClass.getName(), entity);\n\t\t\t\t\t}\n\t\t\t\t\tdevice = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdeviceKey = deviceKeyCounter.getAndIncrement();\n\t\t\t\tdevice = allocateDevice(deviceKey, entity, entityClass);\n\n\n\t\t\t\t// Add the new device to the primary map with a simple put\n\t\t\t\tdeviceMap.put(deviceKey, device);\n\t\t\t\t// update indices\n\t\t\t\tif (!updateIndices(device, deviceKey)) {\n\t\t\t\t\tif (deleteQueue == null)\n\t\t\t\t\t\tdeleteQueue = new ArrayList<Long>();\n\t\t\t\t\tdeleteQueue.add(deviceKey);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tupdateSecondaryIndices(entity, entityClass, deviceKey);\n\n\t\t\t\t// We need to count and log here. If we log earlier we could\n\t\t\t\t// hit a concurrent modification and restart the dev creation\n\t\t\t\t// and potentially count the device twice.\n\t\t\t\tcntNewDevice.increment();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"New device created: {} deviceKey={}, entity={}\",\n\t\t\t\t\t\t\tnew Object[]{device, deviceKey, entity});\n\t\t\t\t}\n\t\t\t\t// generate new device update\n\t\t\t\tdeviceUpdates = updateUpdates(deviceUpdates, new DeviceUpdate(device, ADD, null));\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// if it gets here, we have a pre-existing Device for this Entity\n\t\t\tif (!isEntityAllowed(entity, device.getEntityClass())) {\n\t\t\t\tcntPacketNotAllowed.increment();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.info(\"PacketIn is not allowed {} {}\",\n\t\t\t\t\t\t\tdevice.getEntityClass().getName(), entity);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// If this is not an attachment point port we don't learn the new entity\n\t\t\t// and don't update indexes. But we do allow the device to continue up\n\t\t\t// the chain.\n\t\t\tif (entity.hasSwitchPort() && !topology.isAttachmentPointPort(entity.getSwitchDPID(), entity.getSwitchPort())) {\n\t\t\t\tcntPacketOnInternalPortForKnownDevice.increment();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint entityindex = -1;\n\t\t\tif ((entityindex = device.entityIndex(entity)) >= 0) {\n\t\t\t\t// Entity already exists\n\t\t\t\t// update timestamp on the found entity\n\t\t\t\tDate lastSeen = entity.getLastSeenTimestamp();\n\t\t\t\tif (lastSeen == null) {\n\t\t\t\t\tlastSeen = new Date();\n\t\t\t\t\tentity.setLastSeenTimestamp(lastSeen);\n\t\t\t\t}\n\t\t\t\tdevice.entities[entityindex].setLastSeenTimestamp(lastSeen);\n\t\t\t\t// we break the loop after checking for changes to the AP\n\t\t\t} else {\n\t\t\t\t// New entity for this device\n\t\t\t\t// compute the insertion point for the entity.\n\t\t\t\t// see Arrays.binarySearch()\n\t\t\t\tentityindex = -(entityindex + 1);\n\t\t\t\tDevice newDevice = allocateDevice(device, entity, entityindex);\n\n\t\t\t\t// generate updates\n\t\t\t\tEnumSet<DeviceField> changedFields = findChangedFields(device, entity);\n\n\t\t\t\t// update the device map with a replace call\n\t\t\t\tboolean res = deviceMap.replace(deviceKey, device, newDevice);\n\t\t\t\t// If replace returns false, restart the process from the\n\t\t\t\t// beginning (this implies another thread concurrently\n\t\t\t\t// modified this Device).\n\t\t\t\tif (!res)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdevice = newDevice;\n\t\t\t\t// update indices\n\t\t\t\tif (!updateIndices(device, deviceKey)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tupdateSecondaryIndices(entity,\n\t\t\t\t\t\tdevice.getEntityClass(),\n\t\t\t\t\t\tdeviceKey);\n\n\t\t\t\t// We need to count here after all the possible \"continue\"\n\t\t\t\t// statements in this branch\n\t\t\t\tcntNewEntity.increment();\n\t\t\t\tif (changedFields.size() > 0) {\n\t\t\t\t\tcntDeviceChanged.increment();\n\t\t\t\t\tdeviceUpdates =\n\t\t\t\t\t\t\tupdateUpdates(deviceUpdates,\n\t\t\t\t\t\t\t\t\tnew DeviceUpdate(newDevice, CHANGE,\n\t\t\t\t\t\t\t\t\t\t\tchangedFields));\n\t\t\t\t}\n\t\t\t\t// we break the loop after checking for changed AP\n\t\t\t}\n\t\t\t// Update attachment point (will only be hit if the device\n\t\t\t// already existed and no concurrent modification)\n\t\t\tif (entity.hasSwitchPort()) {\n\t\t\t\tboolean moved = device.updateAttachmentPoint(entity.getSwitchDPID(),\n\t\t\t\t\t\tentity.getSwitchPort(),\n\t\t\t\t\t\tentity.getLastSeenTimestamp());\n\t\t\t\t// TODO: use update mechanism instead of sending the\n\t\t\t\t// notification directly\n\t\t\t\tif (moved) {\n\t\t\t\t\t// we count device moved events in sendDeviceMovedNotification()\n\t\t\t\t\tsendDeviceMovedNotification(device);\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Device moved: attachment points {},\" +\n\t\t\t\t\t\t\t\t\"entities {}\", device.attachmentPoints,\n\t\t\t\t\t\t\t\tdevice.entities);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Device attachment point updated: \" +\n\t\t\t\t\t\t\t\t\"attachment points {},\" +\n\t\t\t\t\t\t\t\t\"entities {}\", device.attachmentPoints,\n\t\t\t\t\t\t\t\tdevice.entities);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (deleteQueue != null) {\n\t\t\tfor (Long l : deleteQueue) {\n\t\t\t\tDevice dev = deviceMap.get(l);\n\t\t\t\tthis.deleteDevice(dev);\n\t\t\t}\n\t\t}\n\t\tprocessUpdates(deviceUpdates);\n\t\tdeviceSyncManager.storeDeviceThrottled(device);\n\n\t\treturn device;\n\t}", "signature": "Device learnDeviceByEntity(Entity entity)", "full_signature": "protected Device learnDeviceByEntity(Entity entity)", "class_method_signature": "DeviceManagerImpl.learnDeviceByEntity(Entity entity)", "testcase": false, "constructor": false, "invocations": ["findByEntity", "classifyEntity", "getClassState", "findByEntity", "get", "isDebugEnabled", "debug", "hasSwitchPort", "isAttachmentPointPort", "getSwitchDPID", "getSwitchPort", "increment", "isDebugEnabled", "debug", "isEntityAllowed", "increment", "isDebugEnabled", "debug", "getName", "getAndIncrement", "allocateDevice", "put", "updateIndices", "add", "updateSecondaryIndices", "increment", "isDebugEnabled", "debug", "updateUpdates", "isEntityAllowed", "getEntityClass", "increment", "isDebugEnabled", "info", "getName", "getEntityClass", "hasSwitchPort", "isAttachmentPointPort", "getSwitchDPID", "getSwitchPort", "increment", "entityIndex", "getLastSeenTimestamp", "setLastSeenTimestamp", "setLastSeenTimestamp", "allocateDevice", "findChangedFields", "replace", "updateIndices", "updateSecondaryIndices", "getEntityClass", "increment", "size", "increment", "updateUpdates", "hasSwitchPort", "updateAttachmentPoint", "getSwitchDPID", "getSwitchPort", "getLastSeenTimestamp", "sendDeviceMovedNotification", "isTraceEnabled", "trace", "isTraceEnabled", "trace", "get", "deleteDevice", "processUpdates", "storeDeviceThrottled"]}, "repository": {"repo_id": 181421086, "url": "https://github.com/seungsoo-lee/DELTA", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 35, "size": 99244, "license": "licensed"}}