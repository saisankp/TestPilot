{"test_class": {"identifier": "CollectionQueryEngineTest", "superclass": "", "interfaces": "", "fields": [], "file": "code/src/test/java/com/googlecode/cqengine/engine/CollectionQueryEngineTest.java"}, "test_case": {"identifier": "testOrQueryCollectionScan", "parameters": "()", "modifiers": "@Test @SuppressWarnings({\"MismatchedQueryAndUpdateOfCollection\", \"StatementWithEmptyBody\"}) public", "return": "void", "body": "@Test\n    @SuppressWarnings({\"MismatchedQueryAndUpdateOfCollection\", \"StatementWithEmptyBody\"})\n    public void testOrQueryCollectionScan() {\n        IterationCountingSet<Car> iterationCountingSet = new IterationCountingSet<Car>(CarFactory.createCollectionOfCars(10));\n        IndexedCollection<Car> collection = new ConcurrentIndexedCollection<Car>(WrappingPersistence.aroundCollection(iterationCountingSet));\n\n        Query<Car> query = or(equal(Car.COLOR, Car.Color.BLUE), equal(Car.MANUFACTURER, \"Honda\"));\n        ResultSet<Car> resultSet = collection.retrieve(query);\n\n        for (Car car : resultSet) {\n            // No op\n        }\n\n        // The two-branch or() query should have been evaluated by scanning the collection only once...\n        Assert.assertEquals(iterationCountingSet.size(), iterationCountingSet.getItemsIteratedCount());\n    }", "signature": "void testOrQueryCollectionScan()", "full_signature": "@Test @SuppressWarnings({\"MismatchedQueryAndUpdateOfCollection\", \"StatementWithEmptyBody\"}) public void testOrQueryCollectionScan()", "class_method_signature": "CollectionQueryEngineTest.testOrQueryCollectionScan()", "testcase": true, "constructor": false, "invocations": ["createCollectionOfCars", "aroundCollection", "or", "equal", "equal", "retrieve", "assertEquals", "size", "getItemsIteratedCount"]}, "focal_class": {"identifier": "CollectionQueryEngine", "superclass": "", "interfaces": "implements QueryEngineInternal<O>", "fields": [{"original_string": "public static final String ROOT_QUERY = \"ROOT_QUERY\";", "modifier": "public static final", "type": "String", "declarator": "ROOT_QUERY = \"ROOT_QUERY\"", "var_name": "ROOT_QUERY"}, {"original_string": "private volatile Persistence<O, ? extends Comparable> persistence;", "modifier": "private volatile", "type": "Persistence<O, ? extends Comparable>", "declarator": "persistence", "var_name": "persistence"}, {"original_string": "private volatile ObjectStore<O> objectStore;", "modifier": "private volatile", "type": "ObjectStore<O>", "declarator": "objectStore", "var_name": "objectStore"}, {"original_string": "private final ConcurrentMap<Attribute<O, ?>, Set<Index<O>>> attributeIndexes = new ConcurrentHashMap<Attribute<O, ?>, Set<Index<O>>>();", "modifier": "private final", "type": "ConcurrentMap<Attribute<O, ?>, Set<Index<O>>>", "declarator": "attributeIndexes = new ConcurrentHashMap<Attribute<O, ?>, Set<Index<O>>>()", "var_name": "attributeIndexes"}, {"original_string": "private final ConcurrentMap<Attribute<O, ?>, Index<O>> uniqueIndexes = new ConcurrentHashMap<Attribute<O, ?>, Index<O>>();", "modifier": "private final", "type": "ConcurrentMap<Attribute<O, ?>, Index<O>>", "declarator": "uniqueIndexes = new ConcurrentHashMap<Attribute<O, ?>, Index<O>>()", "var_name": "uniqueIndexes"}, {"original_string": "private final ConcurrentMap<CompoundAttribute<O>, CompoundIndex<O>> compoundIndexes = new ConcurrentHashMap<CompoundAttribute<O>, CompoundIndex<O>>();", "modifier": "private final", "type": "ConcurrentMap<CompoundAttribute<O>, CompoundIndex<O>>", "declarator": "compoundIndexes = new ConcurrentHashMap<CompoundAttribute<O>, CompoundIndex<O>>()", "var_name": "compoundIndexes"}, {"original_string": "private final ConcurrentMap<Query<O>, Index<O>> standingQueryIndexes = new ConcurrentHashMap<Query<O>, Index<O>>();", "modifier": "private final", "type": "ConcurrentMap<Query<O>, Index<O>>", "declarator": "standingQueryIndexes = new ConcurrentHashMap<Query<O>, Index<O>>()", "var_name": "standingQueryIndexes"}, {"original_string": "private final FallbackIndex<O> fallbackIndex = new FallbackIndex<O>();", "modifier": "private final", "type": "FallbackIndex<O>", "declarator": "fallbackIndex = new FallbackIndex<O>()", "var_name": "fallbackIndex"}, {"original_string": "private final Set<Index<O>> immutableIndexes = Collections.newSetFromMap(new ConcurrentHashMap<>());", "modifier": "private final", "type": "Set<Index<O>>", "declarator": "immutableIndexes = Collections.newSetFromMap(new ConcurrentHashMap<>())", "var_name": "immutableIndexes"}], "methods": [{"identifier": "CollectionQueryEngine", "parameters": "()", "modifiers": "public", "return": "", "signature": " CollectionQueryEngine()", "full_signature": "public  CollectionQueryEngine()", "class_method_signature": "CollectionQueryEngine.CollectionQueryEngine()", "testcase": false, "constructor": true}, {"identifier": "init", "parameters": "(final ObjectStore<O> objectStore, final QueryOptions queryOptions)", "modifiers": "@Override public", "return": "void", "signature": "void init(final ObjectStore<O> objectStore, final QueryOptions queryOptions)", "full_signature": "@Override public void init(final ObjectStore<O> objectStore, final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.init(final ObjectStore<O> objectStore, final QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "destroy", "parameters": "(QueryOptions queryOptions)", "modifiers": "@Override public", "return": "void", "signature": "void destroy(QueryOptions queryOptions)", "full_signature": "@Override public void destroy(QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.destroy(QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "addIndex", "parameters": "(Index<O> index, QueryOptions queryOptions)", "modifiers": "@Override public", "return": "void", "signature": "void addIndex(Index<O> index, QueryOptions queryOptions)", "full_signature": "@Override public void addIndex(Index<O> index, QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.addIndex(Index<O> index, QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "addAttributeIndex", "parameters": "(AttributeIndex<A, O> attributeIndex, QueryOptions queryOptions)", "modifiers": "", "return": "void", "signature": "void addAttributeIndex(AttributeIndex<A, O> attributeIndex, QueryOptions queryOptions)", "full_signature": " void addAttributeIndex(AttributeIndex<A, O> attributeIndex, QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.addAttributeIndex(AttributeIndex<A, O> attributeIndex, QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "addStandingQueryIndex", "parameters": "(Index<O> standingQueryIndex, Query<O> standingQuery, QueryOptions queryOptions)", "modifiers": "", "return": "void", "signature": "void addStandingQueryIndex(Index<O> standingQueryIndex, Query<O> standingQuery, QueryOptions queryOptions)", "full_signature": " void addStandingQueryIndex(Index<O> standingQueryIndex, Query<O> standingQuery, QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.addStandingQueryIndex(Index<O> standingQueryIndex, Query<O> standingQuery, QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "addCompoundIndex", "parameters": "(CompoundIndex<O> compoundIndex, CompoundAttribute<O> compoundAttribute, QueryOptions queryOptions)", "modifiers": "", "return": "void", "signature": "void addCompoundIndex(CompoundIndex<O> compoundIndex, CompoundAttribute<O> compoundAttribute, QueryOptions queryOptions)", "full_signature": " void addCompoundIndex(CompoundIndex<O> compoundIndex, CompoundAttribute<O> compoundAttribute, QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.addCompoundIndex(CompoundIndex<O> compoundIndex, CompoundAttribute<O> compoundAttribute, QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "removeIndex", "parameters": "(Index<O> index, QueryOptions queryOptions)", "modifiers": "@Override public", "return": "void", "signature": "void removeIndex(Index<O> index, QueryOptions queryOptions)", "full_signature": "@Override public void removeIndex(Index<O> index, QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.removeIndex(Index<O> index, QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "getIndexes", "parameters": "()", "modifiers": "@Override public", "return": "Iterable<Index<O>>", "signature": "Iterable<Index<O>> getIndexes()", "full_signature": "@Override public Iterable<Index<O>> getIndexes()", "class_method_signature": "CollectionQueryEngine.getIndexes()", "testcase": false, "constructor": false}, {"identifier": "getIndexesOnAttribute", "parameters": "(Attribute<O, ?> attribute)", "modifiers": "", "return": "Iterable<Index<O>>", "signature": "Iterable<Index<O>> getIndexesOnAttribute(Attribute<O, ?> attribute)", "full_signature": " Iterable<Index<O>> getIndexesOnAttribute(Attribute<O, ?> attribute)", "class_method_signature": "CollectionQueryEngine.getIndexesOnAttribute(Attribute<O, ?> attribute)", "testcase": false, "constructor": false}, {"identifier": "getEntireCollectionAsResultSet", "parameters": "(final Query<O> query, final QueryOptions queryOptions)", "modifiers": "", "return": "ResultSet<O>", "signature": "ResultSet<O> getEntireCollectionAsResultSet(final Query<O> query, final QueryOptions queryOptions)", "full_signature": " ResultSet<O> getEntireCollectionAsResultSet(final Query<O> query, final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.getEntireCollectionAsResultSet(final Query<O> query, final QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "retrieveSimpleQuery", "parameters": "(SimpleQuery<O, A> query, QueryOptions queryOptions)", "modifiers": "", "return": "ResultSet<O>", "signature": "ResultSet<O> retrieveSimpleQuery(SimpleQuery<O, A> query, QueryOptions queryOptions)", "full_signature": " ResultSet<O> retrieveSimpleQuery(SimpleQuery<O, A> query, QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.retrieveSimpleQuery(SimpleQuery<O, A> query, QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "retrieveComparativeQuery", "parameters": "(ComparativeQuery<O, A> query, QueryOptions queryOptions)", "modifiers": "", "return": "ResultSet<O>", "signature": "ResultSet<O> retrieveComparativeQuery(ComparativeQuery<O, A> query, QueryOptions queryOptions)", "full_signature": " ResultSet<O> retrieveComparativeQuery(ComparativeQuery<O, A> query, QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.retrieveComparativeQuery(ComparativeQuery<O, A> query, QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "retrieve", "parameters": "(final Query<O> query, final QueryOptions queryOptions)", "modifiers": "@Override public", "return": "ResultSet<O>", "signature": "ResultSet<O> retrieve(final Query<O> query, final QueryOptions queryOptions)", "full_signature": "@Override public ResultSet<O> retrieve(final Query<O> query, final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.retrieve(final Query<O> query, final QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "retrieveWithoutIndexOrdering", "parameters": "(Query<O> query, QueryOptions queryOptions, OrderByOption<O> orderByOption)", "modifiers": "", "return": "ResultSet<O>", "signature": "ResultSet<O> retrieveWithoutIndexOrdering(Query<O> query, QueryOptions queryOptions, OrderByOption<O> orderByOption)", "full_signature": " ResultSet<O> retrieveWithoutIndexOrdering(Query<O> query, QueryOptions queryOptions, OrderByOption<O> orderByOption)", "class_method_signature": "CollectionQueryEngine.retrieveWithoutIndexOrdering(Query<O> query, QueryOptions queryOptions, OrderByOption<O> orderByOption)", "testcase": false, "constructor": false}, {"identifier": "retrieveWithIndexOrdering", "parameters": "(final Query<O> query, final QueryOptions queryOptions, final OrderByOption<O> orderByOption, final SortedKeyStatisticsIndex<?, O> indexForOrdering)", "modifiers": "", "return": "ResultSet<O>", "signature": "ResultSet<O> retrieveWithIndexOrdering(final Query<O> query, final QueryOptions queryOptions, final OrderByOption<O> orderByOption, final SortedKeyStatisticsIndex<?, O> indexForOrdering)", "full_signature": " ResultSet<O> retrieveWithIndexOrdering(final Query<O> query, final QueryOptions queryOptions, final OrderByOption<O> orderByOption, final SortedKeyStatisticsIndex<?, O> indexForOrdering)", "class_method_signature": "CollectionQueryEngine.retrieveWithIndexOrdering(final Query<O> query, final QueryOptions queryOptions, final OrderByOption<O> orderByOption, final SortedKeyStatisticsIndex<?, O> indexForOrdering)", "testcase": false, "constructor": false}, {"identifier": "retrieveWithIndexOrderingMainResults", "parameters": "(final Query<O> query, QueryOptions queryOptions, SortedKeyStatisticsIndex<?, O> indexForOrdering, List<AttributeOrder<O>> allSortOrders, RangeBounds<?> rangeBoundsFromQuery, boolean attributeCanHaveMoreThanOneValue, boolean primarySortDescending)", "modifiers": "", "return": "Iterator<O>", "signature": "Iterator<O> retrieveWithIndexOrderingMainResults(final Query<O> query, QueryOptions queryOptions, SortedKeyStatisticsIndex<?, O> indexForOrdering, List<AttributeOrder<O>> allSortOrders, RangeBounds<?> rangeBoundsFromQuery, boolean attributeCanHaveMoreThanOneValue, boolean primarySortDescending)", "full_signature": " Iterator<O> retrieveWithIndexOrderingMainResults(final Query<O> query, QueryOptions queryOptions, SortedKeyStatisticsIndex<?, O> indexForOrdering, List<AttributeOrder<O>> allSortOrders, RangeBounds<?> rangeBoundsFromQuery, boolean attributeCanHaveMoreThanOneValue, boolean primarySortDescending)", "class_method_signature": "CollectionQueryEngine.retrieveWithIndexOrderingMainResults(final Query<O> query, QueryOptions queryOptions, SortedKeyStatisticsIndex<?, O> indexForOrdering, List<AttributeOrder<O>> allSortOrders, RangeBounds<?> rangeBoundsFromQuery, boolean attributeCanHaveMoreThanOneValue, boolean primarySortDescending)", "testcase": false, "constructor": false}, {"identifier": "retrieveWithIndexOrderingMissingResults", "parameters": "(final Query<O> query, QueryOptions queryOptions, Attribute<O, Comparable> primarySortAttribute, List<AttributeOrder<O>> allSortOrders, boolean attributeCanHaveMoreThanOneValue)", "modifiers": "", "return": "Iterator<O>", "signature": "Iterator<O> retrieveWithIndexOrderingMissingResults(final Query<O> query, QueryOptions queryOptions, Attribute<O, Comparable> primarySortAttribute, List<AttributeOrder<O>> allSortOrders, boolean attributeCanHaveMoreThanOneValue)", "full_signature": " Iterator<O> retrieveWithIndexOrderingMissingResults(final Query<O> query, QueryOptions queryOptions, Attribute<O, Comparable> primarySortAttribute, List<AttributeOrder<O>> allSortOrders, boolean attributeCanHaveMoreThanOneValue)", "class_method_signature": "CollectionQueryEngine.retrieveWithIndexOrderingMissingResults(final Query<O> query, QueryOptions queryOptions, Attribute<O, Comparable> primarySortAttribute, List<AttributeOrder<O>> allSortOrders, boolean attributeCanHaveMoreThanOneValue)", "testcase": false, "constructor": false}, {"identifier": "filterIndexOrderingCandidateResults", "parameters": "(final Iterator<O> sortedCandidateResults, final Query<O> query, final QueryOptions queryOptions)", "modifiers": "", "return": "Iterator<O>", "signature": "Iterator<O> filterIndexOrderingCandidateResults(final Iterator<O> sortedCandidateResults, final Query<O> query, final QueryOptions queryOptions)", "full_signature": " Iterator<O> filterIndexOrderingCandidateResults(final Iterator<O> sortedCandidateResults, final Query<O> query, final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.filterIndexOrderingCandidateResults(final Iterator<O> sortedCandidateResults, final Query<O> query, final QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "getPersistenceFromQueryOptions", "parameters": "(QueryOptions queryOptions)", "modifiers": "static", "return": "Persistence<O, A>", "signature": "Persistence<O, A> getPersistenceFromQueryOptions(QueryOptions queryOptions)", "full_signature": "static Persistence<O, A> getPersistenceFromQueryOptions(QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.getPersistenceFromQueryOptions(QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "determineAdditionalSortOrdersForIndexOrdering", "parameters": "(List<AttributeOrder<O>> allSortOrders, boolean attributeCanHaveMoreThanOneValue, Index<O> index, QueryOptions queryOptions)", "modifiers": "static", "return": "List<AttributeOrder<O>>", "signature": "List<AttributeOrder<O>> determineAdditionalSortOrdersForIndexOrdering(List<AttributeOrder<O>> allSortOrders, boolean attributeCanHaveMoreThanOneValue, Index<O> index, QueryOptions queryOptions)", "full_signature": "static List<AttributeOrder<O>> determineAdditionalSortOrdersForIndexOrdering(List<AttributeOrder<O>> allSortOrders, boolean attributeCanHaveMoreThanOneValue, Index<O> index, QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.determineAdditionalSortOrdersForIndexOrdering(List<AttributeOrder<O>> allSortOrders, boolean attributeCanHaveMoreThanOneValue, Index<O> index, QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "getKeysAndValuesInRange", "parameters": "(SortedKeyStatisticsIndex<A, O> index, RangeBounds<?> queryBounds, boolean descending, QueryOptions queryOptions)", "modifiers": "static", "return": "CloseableIterator<KeyValue<A, O>>", "signature": "CloseableIterator<KeyValue<A, O>> getKeysAndValuesInRange(SortedKeyStatisticsIndex<A, O> index, RangeBounds<?> queryBounds, boolean descending, QueryOptions queryOptions)", "full_signature": "static CloseableIterator<KeyValue<A, O>> getKeysAndValuesInRange(SortedKeyStatisticsIndex<A, O> index, RangeBounds<?> queryBounds, boolean descending, QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.getKeysAndValuesInRange(SortedKeyStatisticsIndex<A, O> index, RangeBounds<?> queryBounds, boolean descending, QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "getBoundsFromQuery", "parameters": "(Query<O> query, Attribute<O, A> attribute)", "modifiers": "static", "return": "RangeBounds", "signature": "RangeBounds getBoundsFromQuery(Query<O> query, Attribute<O, A> attribute)", "full_signature": "static RangeBounds getBoundsFromQuery(Query<O> query, Attribute<O, A> attribute)", "class_method_signature": "CollectionQueryEngine.getBoundsFromQuery(Query<O> query, Attribute<O, A> attribute)", "testcase": false, "constructor": false}, {"identifier": "retrieveRecursive", "parameters": "(Query<O> query, final QueryOptions queryOptions)", "modifiers": "", "return": "ResultSet<O>", "signature": "ResultSet<O> retrieveRecursive(Query<O> query, final QueryOptions queryOptions)", "full_signature": " ResultSet<O> retrieveRecursive(Query<O> query, final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.retrieveRecursive(Query<O> query, final QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "retrieveIntersectionOfSimpleQueries", "parameters": "(Collection<SimpleQuery<O, ?>> queries, QueryOptions queryOptions, boolean indexMergeStrategyEnabled)", "modifiers": "", "return": "ResultSet<O>", "signature": "ResultSet<O> retrieveIntersectionOfSimpleQueries(Collection<SimpleQuery<O, ?>> queries, QueryOptions queryOptions, boolean indexMergeStrategyEnabled)", "full_signature": " ResultSet<O> retrieveIntersectionOfSimpleQueries(Collection<SimpleQuery<O, ?>> queries, QueryOptions queryOptions, boolean indexMergeStrategyEnabled)", "class_method_signature": "CollectionQueryEngine.retrieveIntersectionOfSimpleQueries(Collection<SimpleQuery<O, ?>> queries, QueryOptions queryOptions, boolean indexMergeStrategyEnabled)", "testcase": false, "constructor": false}, {"identifier": "retrieveIntersectionOfComparativeQueries", "parameters": "(Collection<ComparativeQuery<O, ?>> queries, QueryOptions queryOptions)", "modifiers": "", "return": "ResultSet<O>", "signature": "ResultSet<O> retrieveIntersectionOfComparativeQueries(Collection<ComparativeQuery<O, ?>> queries, QueryOptions queryOptions)", "full_signature": " ResultSet<O> retrieveIntersectionOfComparativeQueries(Collection<ComparativeQuery<O, ?>> queries, QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.retrieveIntersectionOfComparativeQueries(Collection<ComparativeQuery<O, ?>> queries, QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "retrieveUnionOfSimpleQueries", "parameters": "(final Collection<SimpleQuery<O, ?>> queries, final QueryOptions queryOptions)", "modifiers": "", "return": "ResultSet<O>", "signature": "ResultSet<O> retrieveUnionOfSimpleQueries(final Collection<SimpleQuery<O, ?>> queries, final QueryOptions queryOptions)", "full_signature": " ResultSet<O> retrieveUnionOfSimpleQueries(final Collection<SimpleQuery<O, ?>> queries, final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.retrieveUnionOfSimpleQueries(final Collection<SimpleQuery<O, ?>> queries, final QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "retrieveUnionOfComparativeQueries", "parameters": "(final Collection<ComparativeQuery<O, ?>> queries, final QueryOptions queryOptions)", "modifiers": "", "return": "ResultSet<O>", "signature": "ResultSet<O> retrieveUnionOfComparativeQueries(final Collection<ComparativeQuery<O, ?>> queries, final QueryOptions queryOptions)", "full_signature": " ResultSet<O> retrieveUnionOfComparativeQueries(final Collection<ComparativeQuery<O, ?>> queries, final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.retrieveUnionOfComparativeQueries(final Collection<ComparativeQuery<O, ?>> queries, final QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "retrieveFromStandingQueryIndexIfAvailable", "parameters": "(Query<O> query, final QueryOptions queryOptions)", "modifiers": "", "return": "ResultSet<O>", "signature": "ResultSet<O> retrieveFromStandingQueryIndexIfAvailable(Query<O> query, final QueryOptions queryOptions)", "full_signature": " ResultSet<O> retrieveFromStandingQueryIndexIfAvailable(Query<O> query, final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.retrieveFromStandingQueryIndexIfAvailable(Query<O> query, final QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "addAll", "parameters": "(final ObjectSet<O> objectSet, final QueryOptions queryOptions)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean addAll(final ObjectSet<O> objectSet, final QueryOptions queryOptions)", "full_signature": "@Override public boolean addAll(final ObjectSet<O> objectSet, final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.addAll(final ObjectSet<O> objectSet, final QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "removeAll", "parameters": "(final ObjectSet<O> objectSet, final QueryOptions queryOptions)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean removeAll(final ObjectSet<O> objectSet, final QueryOptions queryOptions)", "full_signature": "@Override public boolean removeAll(final ObjectSet<O> objectSet, final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.removeAll(final ObjectSet<O> objectSet, final QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "clear", "parameters": "(final QueryOptions queryOptions)", "modifiers": "@Override public", "return": "void", "signature": "void clear(final QueryOptions queryOptions)", "full_signature": "@Override public void clear(final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.clear(final QueryOptions queryOptions)", "testcase": false, "constructor": false}, {"identifier": "isMutable", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isMutable()", "full_signature": "@Override public boolean isMutable()", "class_method_signature": "CollectionQueryEngine.isMutable()", "testcase": false, "constructor": false}, {"identifier": "ensureMutable", "parameters": "()", "modifiers": "", "return": "void", "signature": "void ensureMutable()", "full_signature": " void ensureMutable()", "class_method_signature": "CollectionQueryEngine.ensureMutable()", "testcase": false, "constructor": false}, {"identifier": "forEachIndexDo", "parameters": "(IndexOperation<O> indexOperation)", "modifiers": "", "return": "boolean", "signature": "boolean forEachIndexDo(IndexOperation<O> indexOperation)", "full_signature": " boolean forEachIndexDo(IndexOperation<O> indexOperation)", "class_method_signature": "CollectionQueryEngine.forEachIndexDo(IndexOperation<O> indexOperation)", "testcase": false, "constructor": false}, {"identifier": "getClassNameNullSafe", "parameters": "(Object object)", "modifiers": "static", "return": "String", "signature": "String getClassNameNullSafe(Object object)", "full_signature": "static String getClassNameNullSafe(Object object)", "class_method_signature": "CollectionQueryEngine.getClassNameNullSafe(Object object)", "testcase": false, "constructor": false}, {"identifier": "shouldUseIndexMergeStrategy", "parameters": "(boolean strategyRequested, boolean comparativeQueriesPresent, Iterable<ResultSet<O>> resultSetsToMerge)", "modifiers": "static", "return": "boolean", "signature": "boolean shouldUseIndexMergeStrategy(boolean strategyRequested, boolean comparativeQueriesPresent, Iterable<ResultSet<O>> resultSetsToMerge)", "full_signature": "static boolean shouldUseIndexMergeStrategy(boolean strategyRequested, boolean comparativeQueriesPresent, Iterable<ResultSet<O>> resultSetsToMerge)", "class_method_signature": "CollectionQueryEngine.shouldUseIndexMergeStrategy(boolean strategyRequested, boolean comparativeQueriesPresent, Iterable<ResultSet<O>> resultSetsToMerge)", "testcase": false, "constructor": false}, {"identifier": "indexesAvailableForAllResultSets", "parameters": "(Iterable<ResultSet<O>> resultSetsToMerge)", "modifiers": "static", "return": "boolean", "signature": "boolean indexesAvailableForAllResultSets(Iterable<ResultSet<O>> resultSetsToMerge)", "full_signature": "static boolean indexesAvailableForAllResultSets(Iterable<ResultSet<O>> resultSetsToMerge)", "class_method_signature": "CollectionQueryEngine.indexesAvailableForAllResultSets(Iterable<ResultSet<O>> resultSetsToMerge)", "testcase": false, "constructor": false}], "file": "code/src/main/java/com/googlecode/cqengine/engine/CollectionQueryEngine.java"}, "focal_method": {"identifier": "retrieve", "parameters": "(final Query<O> query, final QueryOptions queryOptions)", "modifiers": "@Override public", "return": "ResultSet<O>", "body": "@Override\n    public ResultSet<O> retrieve(final Query<O> query, final QueryOptions queryOptions) {\n        @SuppressWarnings(\"unchecked\")\n        OrderByOption<O> orderByOption = (OrderByOption<O>) queryOptions.get(OrderByOption.class);\n\n        // Store the root query in the queryOptions, so that when retrieveRecursive() examines child branches, that\n        // both the branch query and the root query will be available to PartialIndexes so they may determine if they\n        // can be used to accelerate the overall query...\n        queryOptions.put(ROOT_QUERY, query);\n\n        // Log decisions made to the query log, if provided...\n        final QueryLog queryLog = queryOptions.get(QueryLog.class); // might be null\n\n        SortedKeyStatisticsAttributeIndex<?, O> indexForOrdering = null;\n        if (orderByOption != null) {\n            // Results must be ordered. Determine the ordering strategy to use: i.e. if we should use an index to order\n            // results, or if we should retrieve results and sort them afterwards instead.\n\n            Double selectivityThreshold = Thresholds.getThreshold(queryOptions, EngineThresholds.INDEX_ORDERING_SELECTIVITY);\n            if (selectivityThreshold == null) {\n                selectivityThreshold = EngineThresholds.INDEX_ORDERING_SELECTIVITY.getThresholdDefault();\n            }\n            final List<AttributeOrder<O>> allSortOrders = orderByOption.getAttributeOrders();\n            if (selectivityThreshold != 0.0) {\n                // Index ordering can be used.\n                // Check if an index is actually available to support it...\n                AttributeOrder<O> firstOrder = allSortOrders.iterator().next();\n                @SuppressWarnings(\"unchecked\")\n                Attribute<O, Comparable> firstAttribute = (Attribute<O, Comparable>)firstOrder.getAttribute();\n                if (firstAttribute instanceof OrderControlAttribute) {\n                    @SuppressWarnings(\"unchecked\")\n                    Attribute<O, Comparable> firstAttributeDelegate = ((OrderControlAttribute)firstAttribute).getDelegateAttribute();\n                    firstAttribute = firstAttributeDelegate;\n                }\n\n                // Before we check if an index is available to support index ordering, we need to account for the fact\n                // that even if such an index is available, it might not contain all objects in the collection.\n                //\n                // An index built on a SimpleAttribute, is guaranteed to contain all objects in the collection, because\n                // SimpleAttribute is guaranteed to return a value for every object.\n                // OTOH an index built on a non-SimpleAttribute, is not guaranteed to contain all objects in the\n                // collection, because non-SimpleAttributes are permitted to return *zero* or more values for any\n                // object. Objects for which non-SimpleAttributes return zero values, will be omitted from the index.\n                //\n                // Therefore, if we will use an index to order results, we must ensure that the collection also has a\n                // suitable index to allow the objects which are not in the index to be retrieved as well. When\n                // ordering results, we must return those objects either before or after the objects which are found in\n                // the index. Here we proceed to locate a suitable index to use for ordering results, only if we will\n                // also be able to retrieve the objects missing from that index efficiently as well...\n                if (firstAttribute instanceof SimpleAttribute || standingQueryIndexes.get(not(has(firstAttribute))) != null) {\n                    // Either we are sorting by a SimpleAttribute, or we are sorting by a non-SimpleAttribute and we\n                    // also will be able to retrieve objects which do not have values for the non-SimpleAttribute\n                    // efficiently. Now check if an index exists which would allow index ordering...\n                    for (Index<O> index : this.getIndexesOnAttribute(firstAttribute)) {\n                        if (index instanceof SortedKeyStatisticsAttributeIndex && !index.isQuantized()) {\n                            indexForOrdering = (SortedKeyStatisticsAttributeIndex<?, O>)index;\n                            break;\n                        }\n                    }\n                }\n\n\n                if (queryLog != null) {\n                    queryLog.log(\"indexForOrdering: \" + (indexForOrdering == null ? null : indexForOrdering.getClass().getSimpleName()));\n                }\n                // At this point we might have found an appropriate indexForOrdering, or it might still be null.\n                if (indexForOrdering != null) {\n                    // We found an appropriate index.\n                    // Determine if the selectivity of the query is below the selectivity threshold to use index ordering...\n                    final double querySelectivity;\n                    if (selectivityThreshold == 1.0) {\n                        // Index ordering has been requested explicitly.\n                        // Don't bother calculating query selectivity, assign low selectivity so we will use the index...\n                        querySelectivity = 0.0;\n                    }\n                    else if (!indexForOrdering.supportsQuery(has(firstAttribute), queryOptions)) {\n                        // Index ordering was not requested explicitly, and we cannot calculate the selectivity.\n                        // In this case even though we have an index which supports index ordering,\n                        // we don't have enough information to say that it would be beneficial.\n                        // Assign high selectivity so that the materialize strategy will be used instead...\n                        querySelectivity = 1.0;\n                    }\n                    else {\n                        // The index supports has() queries, which allows us to calculate selectivity.\n                        // Calculate query selectivity, based on the query cardinality and index cardinality...\n                        final int queryCardinality = retrieveRecursive(query, queryOptions).getMergeCost();\n                        final int indexCardinality = indexForOrdering.retrieve(has(firstAttribute), queryOptions).getMergeCost();\n                        if (queryLog != null) {\n                            queryLog.log(\"queryCardinality: \" + queryCardinality);\n                            queryLog.log(\"indexCardinality: \" + indexCardinality);\n                        }\n                        if (indexCardinality == 0) {\n                            // Handle edge case where the index is empty.\n                            querySelectivity = 1.0; // treat is as if the query has high selectivity (tend to use materialize).\n                        }\n                        else if (queryCardinality > indexCardinality) {\n                            // Handle edge case where query cardinality is greater than index cardinality.\n                            querySelectivity = 0.0; // treat is as if the query has low selectivity (tend to use index ordering).\n                        }\n                        else {\n                            querySelectivity = 1.0 - queryCardinality / (double)indexCardinality;\n                        }\n                    }\n\n                    if (queryLog != null) {\n                        queryLog.log(\"querySelectivity: \" + querySelectivity);\n                        queryLog.log(\"selectivityThreshold: \" + selectivityThreshold);\n                    }\n                    if (querySelectivity > selectivityThreshold) {\n                        // Selectivity is too high for index ordering strategy.\n                        // Use the materialize ordering strategy instead.\n                        indexForOrdering = null;\n                    }\n                    // else: querySelectivity <= selectivityThreshold, so we use the index ordering strategy.\n                }\n            }\n        }\n        ResultSet<O> resultSet;\n        if (indexForOrdering != null) {\n            // Retrieve results, using an index to accelerate ordering...\n            resultSet = retrieveWithIndexOrdering(query, queryOptions, orderByOption, indexForOrdering);\n            if (queryLog != null) {\n                queryLog.log(\"orderingStrategy: index\");\n            }\n        }\n        else {\n            // Retrieve results, without using an index to accelerate ordering...\n            resultSet = retrieveWithoutIndexOrdering(query, queryOptions, orderByOption);\n            if (queryLog != null) {\n                queryLog.log(\"orderingStrategy: materialize\");\n            }\n        }\n\n        // Return the results, ensuring that the close() method will close any resources which were opened...\n        // TODO: possibly not necessary to wrap here, as the IndexedCollections also ensure close() is called...\n        return new CloseableResultSet<O>(resultSet, query, queryOptions) {\n            @Override\n            public void close() {\n                super.close();\n                CloseableRequestResources.closeForQueryOptions(queryOptions);\n            }\n        };\n    }", "signature": "ResultSet<O> retrieve(final Query<O> query, final QueryOptions queryOptions)", "full_signature": "@Override public ResultSet<O> retrieve(final Query<O> query, final QueryOptions queryOptions)", "class_method_signature": "CollectionQueryEngine.retrieve(final Query<O> query, final QueryOptions queryOptions)", "testcase": false, "constructor": false, "invocations": ["get", "put", "get", "getThreshold", "getThresholdDefault", "getAttributeOrders", "next", "iterator", "getAttribute", "getDelegateAttribute", "get", "not", "has", "getIndexesOnAttribute", "isQuantized", "log", "getSimpleName", "getClass", "supportsQuery", "has", "getMergeCost", "retrieveRecursive", "getMergeCost", "retrieve", "has", "log", "log", "log", "log", "retrieveWithIndexOrdering", "log", "retrieveWithoutIndexOrdering", "log", "close", "closeForQueryOptions"]}, "repository": {"repo_id": 41263775, "url": "https://github.com/npgall/cqengine", "language": "Java", "is_fork": false, "fork_count": 180, "stargazer_count": 1194, "size": 11701, "license": "licensed"}}