{"test_class": {"identifier": "TestRangeBasedReaderWriterLock", "superclass": "", "interfaces": "", "fields": [{"original_string": "BufferPositionParser _parser = new BufferPositionParser(Integer.MAX_VALUE, Integer.MAX_VALUE);", "modifier": "", "type": "BufferPositionParser", "declarator": "_parser = new BufferPositionParser(Integer.MAX_VALUE, Integer.MAX_VALUE)", "var_name": "_parser"}], "file": "databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/util/TestRangeBasedReaderWriterLock.java"}, "test_case": {"identifier": "testAcquireReaderLock", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testAcquireReaderLock() throws Exception {\n\t\tRangeBasedReaderWriterLock lock = new RangeBasedReaderWriterLock();\n\t\tLockToken token = lock.acquireReaderLock(10, 200,_parser, \"testAcquireReaderLock\");\n\t\tAssertJUnit.assertEquals(10, token._id.start);\n\t\tAssertJUnit.assertEquals(200, token._id.end);\n\n\t}", "signature": "void testAcquireReaderLock()", "full_signature": "@Test public void testAcquireReaderLock()", "class_method_signature": "TestRangeBasedReaderWriterLock.testAcquireReaderLock()", "testcase": true, "constructor": false, "invocations": ["acquireReaderLock", "assertEquals", "assertEquals"]}, "focal_class": {"identifier": "RangeBasedReaderWriterLock", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String MODULE = RangeBasedReaderWriterLock.class.getName();", "modifier": "public static final", "type": "String", "declarator": "MODULE = RangeBasedReaderWriterLock.class.getName()", "var_name": "MODULE"}, {"original_string": "public static final Logger LOG = Logger.getLogger(MODULE);", "modifier": "public static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(MODULE)", "var_name": "LOG"}, {"original_string": "private static final long MAX_LOCK_WAIT_MS = 60000;", "modifier": "private static final", "type": "long", "declarator": "MAX_LOCK_WAIT_MS = 60000", "var_name": "MAX_LOCK_WAIT_MS"}, {"original_string": "private final PriorityQueue<LockToken> readerRanges;", "modifier": "private final", "type": "PriorityQueue<LockToken>", "declarator": "readerRanges", "var_name": "readerRanges"}, {"original_string": "private final ReentrantLock mutex;", "modifier": "private final", "type": "ReentrantLock", "declarator": "mutex", "var_name": "mutex"}, {"original_string": "private final Condition writesPossible;", "modifier": "private final", "type": "Condition", "declarator": "writesPossible", "var_name": "writesPossible"}, {"original_string": "private final Condition readsPossible;", "modifier": "private final", "type": "Condition", "declarator": "readsPossible", "var_name": "readsPossible"}, {"original_string": "private Range writerRange;", "modifier": "private", "type": "Range", "declarator": "writerRange", "var_name": "writerRange"}, {"original_string": "private boolean writerIn;", "modifier": "private", "type": "boolean", "declarator": "writerIn", "var_name": "writerIn"}, {"original_string": "private boolean writerWaiting;", "modifier": "private", "type": "boolean", "declarator": "writerWaiting", "var_name": "writerWaiting"}], "methods": [{"identifier": "RangeBasedReaderWriterLock", "parameters": "()", "modifiers": "public", "return": "", "signature": " RangeBasedReaderWriterLock()", "full_signature": "public  RangeBasedReaderWriterLock()", "class_method_signature": "RangeBasedReaderWriterLock.RangeBasedReaderWriterLock()", "testcase": false, "constructor": true}, {"identifier": "acquireReaderLock", "parameters": "(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "modifiers": "public", "return": "LockToken", "signature": "LockToken acquireReaderLock(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "full_signature": "public LockToken acquireReaderLock(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "class_method_signature": "RangeBasedReaderWriterLock.acquireReaderLock(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "testcase": false, "constructor": false}, {"identifier": "shiftReaderLockStart", "parameters": "(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "modifiers": "public", "return": "void", "signature": "void shiftReaderLockStart(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "full_signature": "public void shiftReaderLockStart(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "class_method_signature": "RangeBasedReaderWriterLock.shiftReaderLockStart(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "testcase": false, "constructor": false}, {"identifier": "shiftReaderLockStartIfWriterWaiting", "parameters": "(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "modifiers": "public", "return": "void", "signature": "void shiftReaderLockStartIfWriterWaiting(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "full_signature": "public void shiftReaderLockStartIfWriterWaiting(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "class_method_signature": "RangeBasedReaderWriterLock.shiftReaderLockStartIfWriterWaiting(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "testcase": false, "constructor": false}, {"identifier": "releaseReaderLock", "parameters": "(LockToken lockId)", "modifiers": "public", "return": "void", "signature": "void releaseReaderLock(LockToken lockId)", "full_signature": "public void releaseReaderLock(LockToken lockId)", "class_method_signature": "RangeBasedReaderWriterLock.releaseReaderLock(LockToken lockId)", "testcase": false, "constructor": false}, {"identifier": "acquireWriterLock", "parameters": "(long start, long end, BufferPositionParser parser)", "modifiers": "public", "return": "void", "signature": "void acquireWriterLock(long start, long end, BufferPositionParser parser)", "full_signature": "public void acquireWriterLock(long start, long end, BufferPositionParser parser)", "class_method_signature": "RangeBasedReaderWriterLock.acquireWriterLock(long start, long end, BufferPositionParser parser)", "testcase": false, "constructor": false}, {"identifier": "releaseWriterLock", "parameters": "(BufferPositionParser parser)", "modifiers": "public", "return": "void", "signature": "void releaseWriterLock(BufferPositionParser parser)", "full_signature": "public void releaseWriterLock(BufferPositionParser parser)", "class_method_signature": "RangeBasedReaderWriterLock.releaseWriterLock(BufferPositionParser parser)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "(BufferPositionParser parser, boolean doSort)", "modifiers": "public", "return": "String", "signature": "String toString(BufferPositionParser parser, boolean doSort)", "full_signature": "public String toString(BufferPositionParser parser, boolean doSort)", "class_method_signature": "RangeBasedReaderWriterLock.toString(BufferPositionParser parser, boolean doSort)", "testcase": false, "constructor": false}, {"identifier": "getReaderRanges", "parameters": "()", "modifiers": "", "return": "PriorityQueue<LockToken>", "signature": "PriorityQueue<LockToken> getReaderRanges()", "full_signature": " PriorityQueue<LockToken> getReaderRanges()", "class_method_signature": "RangeBasedReaderWriterLock.getReaderRanges()", "testcase": false, "constructor": false}, {"identifier": "isWriterIn", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isWriterIn()", "full_signature": "public boolean isWriterIn()", "class_method_signature": "RangeBasedReaderWriterLock.isWriterIn()", "testcase": false, "constructor": false}, {"identifier": "isWriterWaiting", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isWriterWaiting()", "full_signature": "public boolean isWriterWaiting()", "class_method_signature": "RangeBasedReaderWriterLock.isWriterWaiting()", "testcase": false, "constructor": false}, {"identifier": "getWriterRange", "parameters": "()", "modifiers": "public", "return": "Range", "signature": "Range getWriterRange()", "full_signature": "public Range getWriterRange()", "class_method_signature": "RangeBasedReaderWriterLock.getWriterRange()", "testcase": false, "constructor": false}, {"identifier": "getNumReaders", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getNumReaders()", "full_signature": "public int getNumReaders()", "class_method_signature": "RangeBasedReaderWriterLock.getNumReaders()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "RangeBasedReaderWriterLock.toString()", "testcase": false, "constructor": false}], "file": "databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/util/RangeBasedReaderWriterLock.java"}, "focal_method": {"identifier": "acquireReaderLock", "parameters": "(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "modifiers": "public", "return": "LockToken", "body": "public LockToken acquireReaderLock(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)\n      throws InterruptedException, TimeoutException\n  {\n\tboolean debug = LOG.isDebugEnabled();\n    if (debug)\n    {\n      LOG.debug(\"Asked to acquire reader lock from \" + parser.toString(startOffset) +\n                \" to \" + parser.toString(endOffset) + \" for \" + ownerName);\n    }\n\n    //LOG.info(Thread.currentThread().getName() + \"-Asked to acquire reader lock from \" + parser.toString(startOffset) + \" to \" + parser.toString(endOffset));\n\n    Range readerRange = new Range(startOffset, endOffset);\n    mutex.lock();\n    try\n    {\n      boolean timeout = false;\n      while (writerIn && writerRange.intersects(readerRange))\n      {\n        if ( debug )\n        {\n      \t  LOG.debug(\"Waiting for reads to be possible since writer is In. Reader Range is :\" + readerRange.toString(parser)\n      \t\t  + \". Writer Range is :\" + writerRange.toString(parser));\n        }\n        if (timeout)\n          throw new TimeoutException();\n\n        if (!readsPossible.await(MAX_LOCK_WAIT_MS, TimeUnit.MILLISECONDS))\n          timeout = true;\n        if ( debug )\n        {\n        \tLOG.info(\"Waiting for reads to be possible: coming out of wait\");\n        }\n      }\n      LockToken returnVal = new LockToken(readerRange, ownerName);\n      readerRanges.add(returnVal);\n      if (debug)\n      {\n        LOG.debug(\"Returning with reader lock from \" + parser.toString(startOffset) + \" to \" + parser.toString(endOffset));\n      }\n\n      return returnVal;\n    }\n    finally\n    {\n      mutex.unlock();\n    }\n\n  }", "signature": "LockToken acquireReaderLock(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "full_signature": "public LockToken acquireReaderLock(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "class_method_signature": "RangeBasedReaderWriterLock.acquireReaderLock(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "testcase": false, "constructor": false, "invocations": ["isDebugEnabled", "debug", "toString", "toString", "lock", "intersects", "debug", "toString", "toString", "await", "info", "add", "debug", "toString", "toString", "unlock"]}, "repository": {"repo_id": 7209229, "url": "https://github.com/linkedin/databus", "language": "Java", "is_fork": false, "fork_count": 653, "stargazer_count": 2899, "size": 51191, "license": "licensed"}}