{"test_class": {"identifier": "AddressObservationWriterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private AddressCapableNodeConnector addrCapableNc;", "modifier": "private", "type": "AddressCapableNodeConnector", "declarator": "addrCapableNc", "var_name": "addrCapableNc"}, {"original_string": "private ReadOnlyTransaction readTransaction;", "modifier": "private", "type": "ReadOnlyTransaction", "declarator": "readTransaction", "var_name": "readTransaction"}, {"original_string": "private WriteTransaction writeTransaction;", "modifier": "private", "type": "WriteTransaction", "declarator": "writeTransaction", "var_name": "writeTransaction"}, {"original_string": "private DataBroker dataService;", "modifier": "private", "type": "DataBroker", "declarator": "dataService", "var_name": "dataService"}, {"original_string": "private Optional<NodeConnector> dataObjectOptional;", "modifier": "private", "type": "Optional<NodeConnector>", "declarator": "dataObjectOptional", "var_name": "dataObjectOptional"}, {"original_string": "private CheckedFuture checkedFuture;", "modifier": "private", "type": "CheckedFuture", "declarator": "checkedFuture", "var_name": "checkedFuture"}, {"original_string": "private NodeConnector nodeConnector;", "modifier": "private", "type": "NodeConnector", "declarator": "nodeConnector", "var_name": "nodeConnector"}, {"original_string": "private Addresses address;", "modifier": "private", "type": "Addresses", "declarator": "address", "var_name": "address"}, {"original_string": "private AddressesKey addrKey;", "modifier": "private", "type": "AddressesKey", "declarator": "addrKey", "var_name": "addrKey"}, {"original_string": "private MacAddress macAddress;", "modifier": "private", "type": "MacAddress", "declarator": "macAddress", "var_name": "macAddress"}, {"original_string": "private IpAddress ipAddress;", "modifier": "private", "type": "IpAddress", "declarator": "ipAddress", "var_name": "ipAddress"}, {"original_string": "private NodeConnectorRef realNcRef;", "modifier": "private", "type": "NodeConnectorRef", "declarator": "realNcRef", "var_name": "realNcRef"}], "file": "addresstracker/implementation/src/test/java/org/opendaylight/l2switch/addresstracker/addressobserver/AddressObservationWriterTest.java"}, "test_case": {"identifier": "addAddressTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void addAddressTest() throws Exception {\n        AddressObservationWriter addressObservationWriter = new AddressObservationWriter(dataService);\n        addressObservationWriter.setTimestampUpdateInterval(20L);\n        addressObservationWriter.addAddress(macAddress, ipAddress, realNcRef);\n        verify(readTransaction, times(1)).read(any(LogicalDatastoreType.class), any(InstanceIdentifier.class));\n        verify(readTransaction, times(1)).close();\n        verify(writeTransaction, times(1)).merge(any(LogicalDatastoreType.class), any(InstanceIdentifier.class),\n                any(AddressCapableNodeConnector.class));\n        verify(writeTransaction, times(1)).submit();\n    }", "signature": "void addAddressTest()", "full_signature": "@Test public void addAddressTest()", "class_method_signature": "AddressObservationWriterTest.addAddressTest()", "testcase": true, "constructor": false, "invocations": ["setTimestampUpdateInterval", "addAddress", "read", "verify", "times", "any", "any", "close", "verify", "times", "merge", "verify", "times", "any", "any", "any", "submit", "verify", "times"]}, "focal_class": {"identifier": "AddressObservationWriter", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(AddressObservationWriter.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(AddressObservationWriter.class)", "var_name": "LOG"}, {"original_string": "private final AtomicLong addressKey = new AtomicLong(0);", "modifier": "private final", "type": "AtomicLong", "declarator": "addressKey = new AtomicLong(0)", "var_name": "addressKey"}, {"original_string": "private long timestampUpdateInterval;", "modifier": "private", "type": "long", "declarator": "timestampUpdateInterval", "var_name": "timestampUpdateInterval"}, {"original_string": "private final DataBroker dataService;", "modifier": "private final", "type": "DataBroker", "declarator": "dataService", "var_name": "dataService"}, {"original_string": "private final Map<NodeConnectorRef, NodeConnectorLock> lockMap = new ConcurrentHashMap<>();", "modifier": "private final", "type": "Map<NodeConnectorRef, NodeConnectorLock>", "declarator": "lockMap = new ConcurrentHashMap<>()", "var_name": "lockMap"}, {"original_string": "private final Map<NodeConnectorLock, ListenableFuture<Void>> futureMap = new ConcurrentHashMap<>();", "modifier": "private final", "type": "Map<NodeConnectorLock, ListenableFuture<Void>>", "declarator": "futureMap = new ConcurrentHashMap<>()", "var_name": "futureMap"}], "methods": [{"identifier": "AddressObservationWriter", "parameters": "(DataBroker dataService)", "modifiers": "public", "return": "", "signature": " AddressObservationWriter(DataBroker dataService)", "full_signature": "public  AddressObservationWriter(DataBroker dataService)", "class_method_signature": "AddressObservationWriter.AddressObservationWriter(DataBroker dataService)", "testcase": false, "constructor": true}, {"identifier": "setTimestampUpdateInterval", "parameters": "(long timestampUpdateInterval)", "modifiers": "public", "return": "void", "signature": "void setTimestampUpdateInterval(long timestampUpdateInterval)", "full_signature": "public void setTimestampUpdateInterval(long timestampUpdateInterval)", "class_method_signature": "AddressObservationWriter.setTimestampUpdateInterval(long timestampUpdateInterval)", "testcase": false, "constructor": false}, {"identifier": "addAddress", "parameters": "(MacAddress macAddress, IpAddress ipAddress, NodeConnectorRef nodeConnectorRef)", "modifiers": "public", "return": "void", "signature": "void addAddress(MacAddress macAddress, IpAddress ipAddress, NodeConnectorRef nodeConnectorRef)", "full_signature": "public void addAddress(MacAddress macAddress, IpAddress ipAddress, NodeConnectorRef nodeConnectorRef)", "class_method_signature": "AddressObservationWriter.addAddress(MacAddress macAddress, IpAddress ipAddress, NodeConnectorRef nodeConnectorRef)", "testcase": false, "constructor": false}], "file": "addresstracker/implementation/src/main/java/org/opendaylight/l2switch/addresstracker/addressobserver/AddressObservationWriter.java"}, "focal_method": {"identifier": "addAddress", "parameters": "(MacAddress macAddress, IpAddress ipAddress, NodeConnectorRef nodeConnectorRef)", "modifiers": "public", "return": "void", "body": "public void addAddress(MacAddress macAddress, IpAddress ipAddress, NodeConnectorRef nodeConnectorRef) {\n        if (macAddress == null || ipAddress == null || nodeConnectorRef == null) {\n            return;\n        }\n\n        // get the lock for given node connector so at a time only one\n        // observation can be made on a node connector\n        NodeConnectorLock nodeConnectorLock = lockMap.computeIfAbsent(nodeConnectorRef, key -> new NodeConnectorLock());\n\n        synchronized (nodeConnectorLock) {\n            // Ensure previous transaction finished writing to the db\n            ListenableFuture<Void> future = futureMap.get(nodeConnectorLock);\n            if (future != null) {\n                try {\n                    future.get();\n                } catch (InterruptedException | ExecutionException e) {\n                    LOG.error(\"Exception while waiting for previous transaction to finish\", e);\n                }\n            }\n\n            // Initialize builders\n            long now = new Date().getTime();\n            final AddressCapableNodeConnectorBuilder acncBuilder = new AddressCapableNodeConnectorBuilder();\n            final AddressesBuilder addressBuilder = new AddressesBuilder().setIp(ipAddress).setMac(macAddress)\n                    .setFirstSeen(now).setLastSeen(now);\n            List<Addresses> addresses = null;\n\n            // Read existing address observations from data tree\n            ReadOnlyTransaction readTransaction = dataService.newReadOnlyTransaction();\n\n            NodeConnector nc = null;\n            try {\n                Optional<NodeConnector> dataObjectOptional = readTransaction.read(LogicalDatastoreType.OPERATIONAL,\n                        (InstanceIdentifier<NodeConnector>) nodeConnectorRef.getValue()).get();\n                if (dataObjectOptional.isPresent()) {\n                    nc = dataObjectOptional.get();\n                }\n            } catch (InterruptedException | ExecutionException e) {\n                LOG.error(\"Error reading node connector {}\", nodeConnectorRef.getValue());\n                readTransaction.close();\n                throw new RuntimeException(\"Error reading from operational store, node connector : \" + nodeConnectorRef,\n                        e);\n            }\n            readTransaction.close();\n            if (nc == null) {\n                return;\n            }\n            AddressCapableNodeConnector acnc = nc\n                    .getAugmentation(AddressCapableNodeConnector.class);\n\n            // Address observations exist\n            if (acnc != null && acnc.getAddresses() != null) {\n                // Search for this mac-ip pair in the existing address\n                // observations & update last-seen timestamp\n                addresses = acnc.getAddresses();\n                for (int i = 0; i < addresses.size(); i++) {\n                    if (addresses.get(i).getIp().equals(ipAddress) && addresses.get(i).getMac().equals(macAddress)) {\n                        if (now - addresses.get(i).getLastSeen() > timestampUpdateInterval) {\n                            addressBuilder.setFirstSeen(addresses.get(i).getFirstSeen())\n                                    .setKey(addresses.get(i).getKey());\n                            addresses.remove(i);\n                            break;\n                        } else {\n                            return;\n                        }\n                    }\n                }\n            }\n            // Address observations don't exist, so create the list\n            else {\n                addresses = new ArrayList<>();\n            }\n\n            if (addressBuilder.getKey() == null) {\n                addressBuilder.setKey(new AddressesKey(BigInteger.valueOf(addressKey.getAndIncrement())));\n            }\n\n            // Add as an augmentation\n            addresses.add(addressBuilder.build());\n            acncBuilder.setAddresses(addresses);\n\n            // build Instance Id for AddressCapableNodeConnector\n            InstanceIdentifier<AddressCapableNodeConnector> addressCapableNcInstanceId =\n                    ((InstanceIdentifier<NodeConnector>) nodeConnectorRef\n                            .getValue()).augmentation(AddressCapableNodeConnector.class);\n            final WriteTransaction writeTransaction = dataService.newWriteOnlyTransaction();\n            // Update this AddressCapableNodeConnector in the MD-SAL data tree\n            writeTransaction.merge(LogicalDatastoreType.OPERATIONAL, addressCapableNcInstanceId, acncBuilder.build());\n            final ListenableFuture<Void> writeTxResultFuture = writeTransaction.submit();\n            Futures.addCallback(writeTxResultFuture, new FutureCallback<Void>() {\n                @Override\n                public void onSuccess(Void notUsed) {\n                    LOG.debug(\"AddressObservationWriter write successful for tx :{}\",\n                            writeTransaction.getIdentifier());\n                }\n\n                @Override\n                public void onFailure(Throwable throwable) {\n                    LOG.error(\"AddressObservationWriter write transaction {} failed\",\n                            writeTransaction.getIdentifier(), throwable.getCause());\n                }\n            }, MoreExecutors.directExecutor());\n            futureMap.put(nodeConnectorLock, writeTxResultFuture);\n        }\n    }", "signature": "void addAddress(MacAddress macAddress, IpAddress ipAddress, NodeConnectorRef nodeConnectorRef)", "full_signature": "public void addAddress(MacAddress macAddress, IpAddress ipAddress, NodeConnectorRef nodeConnectorRef)", "class_method_signature": "AddressObservationWriter.addAddress(MacAddress macAddress, IpAddress ipAddress, NodeConnectorRef nodeConnectorRef)", "testcase": false, "constructor": false, "invocations": ["computeIfAbsent", "get", "get", "error", "getTime", "setLastSeen", "setFirstSeen", "setMac", "setIp", "newReadOnlyTransaction", "get", "read", "getValue", "isPresent", "get", "error", "getValue", "close", "close", "getAugmentation", "getAddresses", "getAddresses", "size", "equals", "getIp", "get", "equals", "getMac", "get", "getLastSeen", "get", "setKey", "setFirstSeen", "getFirstSeen", "get", "getKey", "get", "remove", "getKey", "setKey", "valueOf", "getAndIncrement", "add", "build", "setAddresses", "augmentation", "getValue", "newWriteOnlyTransaction", "merge", "build", "submit", "addCallback", "debug", "getIdentifier", "error", "getIdentifier", "getCause", "directExecutor", "put"]}, "repository": {"repo_id": 20701467, "url": "https://github.com/opendaylight/l2switch", "language": "Java", "is_fork": false, "fork_count": 30, "stargazer_count": 25, "size": 4178, "license": "licensed"}}