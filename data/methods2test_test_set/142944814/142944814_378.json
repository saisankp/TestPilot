{"test_class": {"identifier": "SignatureSpecTest", "superclass": "extends AbstractTestCase", "interfaces": "", "fields": [], "file": "core/common/src/test/java/hera/key/SignatureSpecTest.java"}, "test_case": {"identifier": "testSerialize", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testSerialize() throws Exception {\n    final ECDSASignature ecdsaSignature = ECDSASignature.of(\n        new BigInteger(\n            \"77742016982977049819968937189730099006007209897399569418319639670259283246582\"),\n        new BigInteger(\n            \"24080111729304174841921585755879357193051484773881703660717104599905026449822\"));\n    final Signature signature = SignatureSpec.serialize(ecdsaSignature);\n    assertTrue(Arrays.equals(HexUtils.decode(\n        \"3045022100ABE06C1B99DE0C51B4790D24EE52674F532D9057744ED9EEF3F61425F9D1BDF60220353CDC395B12ABB6E297085B4D6F1A9DF7783DB66F95A7E0CE28246FC538219E\"),\n        signature.getSign().getValue()));\n  }", "signature": "void testSerialize()", "full_signature": "@Test public void testSerialize()", "class_method_signature": "SignatureSpecTest.testSerialize()", "testcase": true, "constructor": false, "invocations": ["of", "serialize", "assertTrue", "equals", "decode", "getValue", "getSign"]}, "focal_class": {"identifier": "SignatureSpec", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int SIGN_HEADER_MAGIC = 0x30;", "modifier": "public static final", "type": "int", "declarator": "SIGN_HEADER_MAGIC = 0x30", "var_name": "SIGN_HEADER_MAGIC"}, {"original_string": "public static final int SIGN_INT_MARKER = 0x02;", "modifier": "public static final", "type": "int", "declarator": "SIGN_INT_MARKER = 0x02", "var_name": "SIGN_INT_MARKER"}, {"original_string": "public static final int SIGN_MINIMUM_LENGTH = 8;", "modifier": "public static final", "type": "int", "declarator": "SIGN_MINIMUM_LENGTH = 8", "var_name": "SIGN_MINIMUM_LENGTH"}, {"original_string": "public static final BigInteger ecParamsN = ECDSAKeyGenerator.ecParams.getN();", "modifier": "public static final", "type": "BigInteger", "declarator": "ecParamsN = ECDSAKeyGenerator.ecParams.getN()", "var_name": "ecParamsN"}, {"original_string": "protected static final Logger logger = getLogger(SignatureSpec.class);", "modifier": "protected static final", "type": "Logger", "declarator": "logger = getLogger(SignatureSpec.class)", "var_name": "logger"}], "methods": [{"identifier": "serialize", "parameters": "(final ECDSASignature ecdsaSignature)", "modifiers": "public static", "return": "Signature", "signature": "Signature serialize(final ECDSASignature ecdsaSignature)", "full_signature": "public static Signature serialize(final ECDSASignature ecdsaSignature)", "class_method_signature": "SignatureSpec.serialize(final ECDSASignature ecdsaSignature)", "testcase": false, "constructor": false}, {"identifier": "deserialize", "parameters": "(final Signature signature)", "modifiers": "public static", "return": "ECDSASignature", "signature": "ECDSASignature deserialize(final Signature signature)", "full_signature": "public static ECDSASignature deserialize(final Signature signature)", "class_method_signature": "SignatureSpec.deserialize(final Signature signature)", "testcase": false, "constructor": false}, {"identifier": "validateHeader", "parameters": "(final byte[] source, final int start)", "modifiers": "protected static", "return": "int", "signature": "int validateHeader(final byte[] source, final int start)", "full_signature": "protected static int validateHeader(final byte[] source, final int start)", "class_method_signature": "SignatureSpec.validateHeader(final byte[] source, final int start)", "testcase": false, "constructor": false}, {"identifier": "parseInteger", "parameters": "(final byte[] source, final int start,\n      final BigInteger order)", "modifiers": "protected static", "return": "Pair<BigInteger, Integer>", "signature": "Pair<BigInteger, Integer> parseInteger(final byte[] source, final int start,\n      final BigInteger order)", "full_signature": "protected static Pair<BigInteger, Integer> parseInteger(final byte[] source, final int start,\n      final BigInteger order)", "class_method_signature": "SignatureSpec.parseInteger(final byte[] source, final int start,\n      final BigInteger order)", "testcase": false, "constructor": false}], "file": "core/common/src/main/java/hera/key/SignatureSpec.java"}, "focal_method": {"identifier": "serialize", "parameters": "(final ECDSASignature ecdsaSignature)", "modifiers": "public static", "return": "Signature", "body": "public static Signature serialize(final ECDSASignature ecdsaSignature) {\n    assertNotNull(ecdsaSignature, \"ECDSASignature must not null\");\n\n    final BigInteger order = ecParamsN;\n    final BigInteger halfOrder = order.divide(BigInteger.valueOf(2L));\n\n    final BigInteger r = ecdsaSignature.getR();\n    BigInteger s = ecdsaSignature.getS();\n    if (s.compareTo(halfOrder) > 0) {\n      s = order.subtract(s);\n    }\n\n    // in this case, use canonical byte array, not raw bytes\n    final byte[] rbyteArray = r.toByteArray();\n    final byte[] sbyteArray = s.toByteArray();\n    if (logger.isTraceEnabled()) {\n      logger.trace(\"Canonical r: {}, len: {}\", HexUtils.encode(rbyteArray), rbyteArray.length);\n      logger.trace(\"Canonical s: {}, len: {}\", HexUtils.encode(sbyteArray), sbyteArray.length);\n    }\n\n    final byte[] serialized = new byte[6 + rbyteArray.length + sbyteArray.length];\n\n    // Header\n    serialized[0] = SIGN_HEADER_MAGIC;\n    serialized[1] = (byte) (serialized.length - 2);\n\n    // <int-marker> + <R.length> + <R.bytes>\n    serialized[2] = SIGN_INT_MARKER;\n    serialized[3] = (byte) rbyteArray.length;\n    System.arraycopy(rbyteArray, 0, serialized, 4, rbyteArray.length);\n\n    // <int-marker> + <S.length> + <S.bytes>\n    final int offset = 4 + rbyteArray.length;\n    serialized[offset] = SIGN_INT_MARKER;\n    serialized[offset + 1] = (byte) sbyteArray.length;\n    System.arraycopy(sbyteArray, 0, serialized, offset + 2, sbyteArray.length);\n\n    return Signature.newBuilder().sign(BytesValue.of(serialized)).build();\n  }", "signature": "Signature serialize(final ECDSASignature ecdsaSignature)", "full_signature": "public static Signature serialize(final ECDSASignature ecdsaSignature)", "class_method_signature": "SignatureSpec.serialize(final ECDSASignature ecdsaSignature)", "testcase": false, "constructor": false, "invocations": ["assertNotNull", "divide", "valueOf", "getR", "getS", "compareTo", "subtract", "toByteArray", "toByteArray", "isTraceEnabled", "trace", "encode", "trace", "encode", "arraycopy", "arraycopy", "build", "sign", "newBuilder", "of"]}, "repository": {"repo_id": 142944814, "url": "https://github.com/aergoio/heraj", "language": "Java", "is_fork": false, "fork_count": 4, "stargazer_count": 18, "size": 11443, "license": "licensed"}}