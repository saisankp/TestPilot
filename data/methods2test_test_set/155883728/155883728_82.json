{"test_class": {"identifier": "ChecklistExporterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "final File testBaseDir = new File(\"target/repos/ChecklistExporterTest\");", "modifier": "final", "type": "File", "declarator": "testBaseDir = new File(\"target/repos/ChecklistExporterTest\")", "var_name": "testBaseDir"}], "file": "webster/src/test/java/net/adamcin/oakpal/webster/ChecklistExporterTest.java"}, "test_case": {"identifier": "testFindRoots", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testFindRoots() throws Exception {\n        final String pathPrefix = \"/test\";\n        final File tempDir = new File(testBaseDir, \"testFindRoots\");\n        final File repoDir = new File(tempDir, \"repo/segmentstore\");\n\n        final int sample = 5;\n        List<String> orderedPaths = IntStream.range(0, sample).mapToObj(val -> pathPrefix + \"/ordered\" + val).collect(Collectors.toList());\n        List<String> unorderedPaths = IntStream.range(0, sample).mapToObj(val -> pathPrefix + \"/unordered\" + val).collect(Collectors.toList());\n        assertEquals(\"should generate n paths: \", sample, orderedPaths.size());\n\n        TestUtil.prepareRepo(repoDir, session -> {\n            TestUtil.installCndFromURL(session, getClass().getResource(\"/sling_nodetypes.cnd\"));\n            orderedPaths.forEach(Fun.tryOrVoid1(path ->\n                    JcrUtils.getOrCreateByPath(path, \"nt:folder\",\n                            \"sling:OrderedFolder\", session, true)));\n            unorderedPaths.forEach(Fun.tryOrVoid1(path ->\n                    JcrUtils.getOrCreateByPath(path, \"nt:folder\",\n                            \"sling:Folder\", session, true)));\n        });\n\n        List<String> allPaths = new ArrayList<>(orderedPaths);\n        allPaths.addAll(unorderedPaths);\n        allPaths.add(pathPrefix);\n\n        TestUtil.withReadOnlyFixture(repoDir, session -> {\n            ChecklistExporter pathExporter = new ChecklistExporter.Builder().byPath(allPaths.toArray(new String[0])).build();\n            List<ForcedRoot> byPath = pathExporter.findRoots(session);\n\n            for (String path : unorderedPaths) {\n                ForcedRoot root0 = byPath.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                assertNotNull(String.format(\"[path] root for path %s should not be null\", path), root0);\n                assertEquals(String.format(\"[path] root primaryType for path %s should be sling:Folder\", path),\n                        \"sling:Folder\", root0.getPrimaryType());\n            }\n            for (String path : orderedPaths) {\n                ForcedRoot root0 = byPath.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                assertNotNull(String.format(\"[path] root for path %s should not be null\", path), root0);\n                assertEquals(String.format(\"[path] root primaryType for path %s should be sling:OrderedFolder\", path),\n                        \"sling:OrderedFolder\", root0.getPrimaryType());\n            }\n\n            final String queryPrefix = ISO9075.encodePath(\"/jcr:root\" + pathPrefix);\n            ChecklistExporter queryExporter = new ChecklistExporter.Builder().byQuery(queryPrefix + \"//element(*, sling:Folder)\").build();\n            List<ForcedRoot> byQuery = queryExporter.findRoots(session);\n            for (String path : unorderedPaths) {\n                ForcedRoot root0 = byQuery.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                assertNotNull(String.format(\"[query] root for path %s should not be null\", path), root0);\n                assertEquals(String.format(\"[query] root primaryType for path %s should be sling:Folder\", path),\n                        \"sling:Folder\", root0.getPrimaryType());\n            }\n            for (String path : orderedPaths) {\n                ForcedRoot root0 = byQuery.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                assertNotNull(String.format(\"[query] root for path %s should not be null\", path), root0);\n                assertEquals(String.format(\"[query] root primaryType for path %s should be sling:OrderedFolder\", path),\n                        \"sling:OrderedFolder\", root0.getPrimaryType());\n            }\n\n            ChecklistExporter ntExporter = new ChecklistExporter.Builder().byNodeType(\"nt:folder\", \"+sling:Folder\").build();\n            List<ForcedRoot> byNt = ntExporter.findRoots(session);\n            for (String path : unorderedPaths) {\n                ForcedRoot root0 = byNt.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                assertNotNull(String.format(\"[nodetype] root for path %s should not be null\", path), root0);\n                assertEquals(String.format(\"[nodetype] root primaryType for path %s should be sling:Folder\", path),\n                        \"sling:Folder\", root0.getPrimaryType());\n            }\n            for (String path : orderedPaths) {\n                ForcedRoot root0 = byNt.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                assertNotNull(String.format(\"[nodetype] root for path %s should not be null\", path), root0);\n                assertEquals(String.format(\"[nodetype] root primaryType for path %s should be sling:OrderedFolder\", path),\n                        \"sling:OrderedFolder\", root0.getPrimaryType());\n            }\n            for (String path : Collections.singletonList(pathPrefix)) {\n                ForcedRoot root0 = byNt.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                assertNotNull(String.format(\"[nodetype] root for path %s should not be null\", path), root0);\n                assertEquals(String.format(\"[nodetype] root primaryType for path %s should be nt:folder\", path),\n                        \"nt:folder\", root0.getPrimaryType());\n            }\n\n        });\n    }", "signature": "void testFindRoots()", "full_signature": "@Test public void testFindRoots()", "class_method_signature": "ChecklistExporterTest.testFindRoots()", "testcase": true, "constructor": false, "invocations": ["collect", "mapToObj", "range", "toList", "collect", "mapToObj", "range", "toList", "assertEquals", "size", "prepareRepo", "installCndFromURL", "getResource", "getClass", "forEach", "tryOrVoid1", "getOrCreateByPath", "forEach", "tryOrVoid1", "getOrCreateByPath", "addAll", "add", "withReadOnlyFixture", "build", "byPath", "toArray", "findRoots", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType", "encodePath", "build", "byQuery", "findRoots", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType", "build", "byNodeType", "findRoots", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType", "singletonList", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType"]}, "focal_class": {"identifier": "ChecklistExporter", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ChecklistExporter.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ChecklistExporter.class)", "var_name": "LOGGER"}, {"original_string": "private final List<Op> operations;", "modifier": "private final", "type": "List<Op>", "declarator": "operations", "var_name": "operations"}, {"original_string": "private final List<String> exportTypeDefs;", "modifier": "private final", "type": "List<String>", "declarator": "exportTypeDefs", "var_name": "exportTypeDefs"}, {"original_string": "private final List<Rule> pathScopes;", "modifier": "private final", "type": "List<Rule>", "declarator": "pathScopes", "var_name": "pathScopes"}, {"original_string": "private final List<Rule> nodeTypeFilters;", "modifier": "private final", "type": "List<Rule>", "declarator": "nodeTypeFilters", "var_name": "nodeTypeFilters"}, {"original_string": "private final List<JcrNs> jcrNamespaces;", "modifier": "private final", "type": "List<JcrNs>", "declarator": "jcrNamespaces", "var_name": "jcrNamespaces"}, {"original_string": "public static final ForcedRootUpdatePolicy DEFAULT_UPDATE_POLICY = ForcedRootUpdatePolicy.REPLACE;", "modifier": "public static final", "type": "ForcedRootUpdatePolicy", "declarator": "DEFAULT_UPDATE_POLICY = ForcedRootUpdatePolicy.REPLACE", "var_name": "DEFAULT_UPDATE_POLICY"}, {"original_string": "public static final String COVARIANT_PREFIX = \"+\";", "modifier": "public static final", "type": "String", "declarator": "COVARIANT_PREFIX = \"+\"", "var_name": "COVARIANT_PREFIX"}, {"original_string": "static final Predicate<String> COVARIANT_FILTER = name -> name.startsWith(COVARIANT_PREFIX);", "modifier": "static final", "type": "Predicate<String>", "declarator": "COVARIANT_FILTER = name -> name.startsWith(COVARIANT_PREFIX)", "var_name": "COVARIANT_FILTER"}, {"original_string": "static final Function<String, String> COVARIANT_FORMAT = name -> name.substring(COVARIANT_PREFIX.length());", "modifier": "static final", "type": "Function<String, String>", "declarator": "COVARIANT_FORMAT = name -> name.substring(COVARIANT_PREFIX.length())", "var_name": "COVARIANT_FORMAT"}], "methods": [{"identifier": "ChecklistExporter", "parameters": "(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "modifiers": "private", "return": "", "signature": " ChecklistExporter(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "full_signature": "private  ChecklistExporter(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "class_method_signature": "ChecklistExporter.ChecklistExporter(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "testcase": false, "constructor": true}, {"identifier": "ensureNamespaces", "parameters": "(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "modifiers": "static", "return": "void", "signature": "void ensureNamespaces(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "full_signature": "static void ensureNamespaces(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "class_method_signature": "ChecklistExporter.ensureNamespaces(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "testcase": false, "constructor": false}, {"identifier": "findJcrPrefixesInForcedRoot", "parameters": "(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "modifiers": "static", "return": "Set<String>", "signature": "Set<String> findJcrPrefixesInForcedRoot(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "full_signature": "static Set<String> findJcrPrefixesInForcedRoot(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "class_method_signature": "ChecklistExporter.findJcrPrefixesInForcedRoot(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "testcase": false, "constructor": false}, {"identifier": "findNodeTypesInForcedRoot", "parameters": "(final Set<String> acc, final ForcedRoot forcedRoot)", "modifiers": "static", "return": "Set<String>", "signature": "Set<String> findNodeTypesInForcedRoot(final Set<String> acc, final ForcedRoot forcedRoot)", "full_signature": "static Set<String> findNodeTypesInForcedRoot(final Set<String> acc, final ForcedRoot forcedRoot)", "class_method_signature": "ChecklistExporter.findNodeTypesInForcedRoot(final Set<String> acc, final ForcedRoot forcedRoot)", "testcase": false, "constructor": false}, {"identifier": "preferDifferent", "parameters": "(final @NotNull U value)", "modifiers": "static", "return": "BinaryOperator<U>", "signature": "BinaryOperator<U> preferDifferent(final @NotNull U value)", "full_signature": "static BinaryOperator<U> preferDifferent(final @NotNull U value)", "class_method_signature": "ChecklistExporter.preferDifferent(final @NotNull U value)", "testcase": false, "constructor": false}, {"identifier": "nsRemapName", "parameters": "(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "modifiers": "static", "return": "Function<String, String>", "signature": "Function<String, String> nsRemapName(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "full_signature": "static Function<String, String> nsRemapName(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "class_method_signature": "ChecklistExporter.nsRemapName(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "testcase": false, "constructor": false}, {"identifier": "nsRemapForcedRoot", "parameters": "(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "modifiers": "static", "return": "Function<ForcedRoot, ForcedRoot>", "signature": "Function<ForcedRoot, ForcedRoot> nsRemapForcedRoot(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "full_signature": "static Function<ForcedRoot, ForcedRoot> nsRemapForcedRoot(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "class_method_signature": "ChecklistExporter.nsRemapForcedRoot(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "testcase": false, "constructor": false}, {"identifier": "getRetainFilter", "parameters": "(final ForcedRootUpdatePolicy updatePolicy)", "modifiers": "", "return": "Predicate<ForcedRoot>", "signature": "Predicate<ForcedRoot> getRetainFilter(final ForcedRootUpdatePolicy updatePolicy)", "full_signature": " Predicate<ForcedRoot> getRetainFilter(final ForcedRootUpdatePolicy updatePolicy)", "class_method_signature": "ChecklistExporter.getRetainFilter(final ForcedRootUpdatePolicy updatePolicy)", "testcase": false, "constructor": false}, {"identifier": "exportTypeDefSelector", "parameters": "()", "modifiers": "", "return": "BiPredicate<NamePathResolver, NodeType>", "signature": "BiPredicate<NamePathResolver, NodeType> exportTypeDefSelector()", "full_signature": " BiPredicate<NamePathResolver, NodeType> exportTypeDefSelector()", "class_method_signature": "ChecklistExporter.exportTypeDefSelector()", "testcase": false, "constructor": false}, {"identifier": "updateChecklist", "parameters": "(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "modifiers": "public", "return": "void", "signature": "void updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "full_signature": "public void updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "class_method_signature": "ChecklistExporter.updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "testcase": false, "constructor": false}, {"identifier": "addToLeft", "parameters": "()", "modifiers": "static", "return": "BinaryOperator<U>", "signature": "BinaryOperator<U> addToLeft()", "full_signature": "static BinaryOperator<U> addToLeft()", "class_method_signature": "ChecklistExporter.addToLeft()", "testcase": false, "constructor": false}, {"identifier": "findRoots", "parameters": "(final Session session)", "modifiers": "public", "return": "List<ForcedRoot>", "signature": "List<ForcedRoot> findRoots(final Session session)", "full_signature": "public List<ForcedRoot> findRoots(final Session session)", "class_method_signature": "ChecklistExporter.findRoots(final Session session)", "testcase": false, "constructor": false}, {"identifier": "ntStatement", "parameters": "(final Session session, final List<String> nodeTypeNames)", "modifiers": "", "return": "String", "signature": "String ntStatement(final Session session, final List<String> nodeTypeNames)", "full_signature": " String ntStatement(final Session session, final List<String> nodeTypeNames)", "class_method_signature": "ChecklistExporter.ntStatement(final Session session, final List<String> nodeTypeNames)", "testcase": false, "constructor": false}, {"identifier": "query", "parameters": "(final Session session, final String statement)", "modifiers": "", "return": "List<ForcedRoot>", "signature": "List<ForcedRoot> query(final Session session, final String statement)", "full_signature": " List<ForcedRoot> query(final Session session, final String statement)", "class_method_signature": "ChecklistExporter.query(final Session session, final String statement)", "testcase": false, "constructor": false}, {"identifier": "traverse", "parameters": "(final Session session, final List<String> paths)", "modifiers": "", "return": "List<ForcedRoot>", "signature": "List<ForcedRoot> traverse(final Session session, final List<String> paths)", "full_signature": " List<ForcedRoot> traverse(final Session session, final List<String> paths)", "class_method_signature": "ChecklistExporter.traverse(final Session session, final List<String> paths)", "testcase": false, "constructor": false}, {"identifier": "nodeToRoot", "parameters": "(final Node node, final NamespaceMapping mapping)", "modifiers": "", "return": "Optional<ForcedRoot>", "signature": "Optional<ForcedRoot> nodeToRoot(final Node node, final NamespaceMapping mapping)", "full_signature": " Optional<ForcedRoot> nodeToRoot(final Node node, final NamespaceMapping mapping)", "class_method_signature": "ChecklistExporter.nodeToRoot(final Node node, final NamespaceMapping mapping)", "testcase": false, "constructor": false}], "file": "webster/src/main/java/net/adamcin/oakpal/webster/ChecklistExporter.java"}, "focal_method": {"identifier": "findRoots", "parameters": "(final Session session)", "modifiers": "public", "return": "List<ForcedRoot>", "body": "public List<ForcedRoot> findRoots(final Session session) throws RepositoryException {\n        List<ForcedRoot> roots = new ArrayList<>();\n        for (Op op : this.operations) {\n            switch (op.selectorType) {\n                case PATH:\n                    roots.addAll(traverse(session, op.args));\n                    break;\n                case NODETYPE:\n                    roots.addAll(query(session, ntStatement(session, op.args)));\n                    break;\n                case QUERY:\n                default:\n                    roots.addAll(query(session, op.args.get(0)));\n                    break;\n            }\n        }\n        return roots;\n    }", "signature": "List<ForcedRoot> findRoots(final Session session)", "full_signature": "public List<ForcedRoot> findRoots(final Session session)", "class_method_signature": "ChecklistExporter.findRoots(final Session session)", "testcase": false, "constructor": false, "invocations": ["addAll", "traverse", "addAll", "query", "ntStatement", "addAll", "query", "get"]}, "repository": {"repo_id": 155883728, "url": "https://github.com/adamcin/oakpal", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 6, "size": 13349, "license": "licensed"}}