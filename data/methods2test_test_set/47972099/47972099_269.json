{"test_class": {"identifier": "TimestampsAndPeriodicWatermarksOperatorTest", "superclass": "", "interfaces": "", "fields": [], "file": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/TimestampsAndPeriodicWatermarksOperatorTest.java"}, "test_case": {"identifier": "testTimestampsAndPeriodicWatermarksOperator", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testTimestampsAndPeriodicWatermarksOperator() throws Exception {\n\t\t\n\t\tfinal TimestampsAndPeriodicWatermarksOperator<Long> operator = \n\t\t\t\tnew TimestampsAndPeriodicWatermarksOperator<Long>(new LongExtractor());\n\n\t\tfinal ExecutionConfig config = new ExecutionConfig();\n\t\tconfig.setAutoWatermarkInterval(50);\n\t\t\n\t\tOneInputStreamOperatorTestHarness<Long, Long> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<Long, Long>(operator, config);\n\n\t\ttestHarness.open();\n\t\t\n\t\ttestHarness.processElement(new StreamRecord<>(1L, 1));\n\t\ttestHarness.processElement(new StreamRecord<>(2L, 1));\n\t\ttestHarness.processWatermark(new Watermark(2)); // this watermark should be ignored\n\t\ttestHarness.processElement(new StreamRecord<>(3L, 3));\n\t\ttestHarness.processElement(new StreamRecord<>(4L, 3));\n\t\t\n\t\t// validate first part of the sequence. we poll elements until our\n\t\t// watermark updates to \"3\", which must be the result of the \"4\" element.\n\t\t{\n\t\t\tConcurrentLinkedQueue<Object> output = testHarness.getOutput();\n\t\t\tlong nextElementValue = 1L;\n\t\t\tlong lastWatermark = -1L;\n\t\t\t\n\t\t\twhile (lastWatermark < 3) {\n\t\t\t\tif (output.size() > 0) {\n\t\t\t\t\tObject next = output.poll();\n\t\t\t\t\tassertNotNull(next);\n\t\t\t\t\tTuple2<Long, Long> update = validateElement(next, nextElementValue, lastWatermark);\n\t\t\t\t\tnextElementValue = update.f0;\n\t\t\t\t\tlastWatermark = update.f1;\n\t\t\t\t\t\n\t\t\t\t\t// check the invariant\n\t\t\t\t\tassertTrue(lastWatermark < nextElementValue);\n\t\t\t\t} else {\n\t\t\t\t\tThread.sleep(10);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\toutput.clear();\n\t\t}\n\n\t\ttestHarness.processElement(new StreamRecord<>(4L, 4));\n\t\ttestHarness.processElement(new StreamRecord<>(5L, 4));\n\t\ttestHarness.processElement(new StreamRecord<>(6L, 4));\n\t\ttestHarness.processElement(new StreamRecord<>(7L, 4));\n\t\ttestHarness.processElement(new StreamRecord<>(8L, 4));\n\n\t\t// validate the next part of the sequence. we poll elements until our\n\t\t// watermark updates to \"7\", which must be the result of the \"8\" element.\n\t\t{\n\t\t\tConcurrentLinkedQueue<Object> output = testHarness.getOutput();\n\t\t\tlong nextElementValue = 4L;\n\t\t\tlong lastWatermark = 2L;\n\n\t\t\twhile (lastWatermark < 7) {\n\t\t\t\tif (output.size() > 0) {\n\t\t\t\t\tObject next = output.poll();\n\t\t\t\t\tassertNotNull(next);\n\t\t\t\t\tTuple2<Long, Long> update = validateElement(next, nextElementValue, lastWatermark);\n\t\t\t\t\tnextElementValue = update.f0;\n\t\t\t\t\tlastWatermark = update.f1;\n\t\t\t\t\t\n\t\t\t\t\t// check the invariant\n\t\t\t\t\tassertTrue(lastWatermark < nextElementValue);\n\t\t\t\t} else {\n\t\t\t\t\tThread.sleep(10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toutput.clear();\n\t\t}\n\t\t\n\t\ttestHarness.processWatermark(new Watermark(Long.MAX_VALUE));\n\t\tassertEquals(Long.MAX_VALUE, ((Watermark) testHarness.getOutput().poll()).getTimestamp());\n\t}", "signature": "void testTimestampsAndPeriodicWatermarksOperator()", "full_signature": "@Test public void testTimestampsAndPeriodicWatermarksOperator()", "class_method_signature": "TimestampsAndPeriodicWatermarksOperatorTest.testTimestampsAndPeriodicWatermarksOperator()", "testcase": true, "constructor": false, "invocations": ["setAutoWatermarkInterval", "open", "processElement", "processElement", "processWatermark", "processElement", "processElement", "getOutput", "size", "poll", "assertNotNull", "validateElement", "assertTrue", "sleep", "clear", "processElement", "processElement", "processElement", "processElement", "processElement", "getOutput", "size", "poll", "assertNotNull", "validateElement", "assertTrue", "sleep", "clear", "processWatermark", "assertEquals", "getTimestamp", "poll", "getOutput"]}, "focal_class": {"identifier": "TimestampsAndPeriodicWatermarksOperator", "superclass": "extends AbstractUdfStreamOperator<T, AssignerWithPeriodicWatermarks<T>>", "interfaces": "implements OneInputStreamOperator<T, T>, Triggerable", "fields": [{"original_string": "private static final long serialVersionUID = 1L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 1L", "var_name": "serialVersionUID"}, {"original_string": "private transient long watermarkInterval;", "modifier": "private transient", "type": "long", "declarator": "watermarkInterval", "var_name": "watermarkInterval"}, {"original_string": "private transient long currentWatermark;", "modifier": "private transient", "type": "long", "declarator": "currentWatermark", "var_name": "currentWatermark"}], "methods": [{"identifier": "TimestampsAndPeriodicWatermarksOperator", "parameters": "(AssignerWithPeriodicWatermarks<T> assigner)", "modifiers": "public", "return": "", "signature": " TimestampsAndPeriodicWatermarksOperator(AssignerWithPeriodicWatermarks<T> assigner)", "full_signature": "public  TimestampsAndPeriodicWatermarksOperator(AssignerWithPeriodicWatermarks<T> assigner)", "class_method_signature": "TimestampsAndPeriodicWatermarksOperator.TimestampsAndPeriodicWatermarksOperator(AssignerWithPeriodicWatermarks<T> assigner)", "testcase": false, "constructor": true}, {"identifier": "open", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void open()", "full_signature": "@Override public void open()", "class_method_signature": "TimestampsAndPeriodicWatermarksOperator.open()", "testcase": false, "constructor": false}, {"identifier": "processElement", "parameters": "(StreamRecord<T> element)", "modifiers": "@Override public", "return": "void", "signature": "void processElement(StreamRecord<T> element)", "full_signature": "@Override public void processElement(StreamRecord<T> element)", "class_method_signature": "TimestampsAndPeriodicWatermarksOperator.processElement(StreamRecord<T> element)", "testcase": false, "constructor": false}, {"identifier": "trigger", "parameters": "(long timestamp)", "modifiers": "@Override public", "return": "void", "signature": "void trigger(long timestamp)", "full_signature": "@Override public void trigger(long timestamp)", "class_method_signature": "TimestampsAndPeriodicWatermarksOperator.trigger(long timestamp)", "testcase": false, "constructor": false}, {"identifier": "processWatermark", "parameters": "(Watermark mark)", "modifiers": "@Override public", "return": "void", "signature": "void processWatermark(Watermark mark)", "full_signature": "@Override public void processWatermark(Watermark mark)", "class_method_signature": "TimestampsAndPeriodicWatermarksOperator.processWatermark(Watermark mark)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "TimestampsAndPeriodicWatermarksOperator.close()", "testcase": false, "constructor": false}], "file": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/TimestampsAndPeriodicWatermarksOperator.java"}, "focal_method": {"identifier": "TimestampsAndPeriodicWatermarksOperator", "parameters": "(AssignerWithPeriodicWatermarks<T> assigner)", "modifiers": "public", "return": "", "body": "public TimestampsAndPeriodicWatermarksOperator(AssignerWithPeriodicWatermarks<T> assigner) {\n\t\tsuper(assigner);\n\t\tthis.chainingStrategy = ChainingStrategy.ALWAYS;\n\t}", "signature": " TimestampsAndPeriodicWatermarksOperator(AssignerWithPeriodicWatermarks<T> assigner)", "full_signature": "public  TimestampsAndPeriodicWatermarksOperator(AssignerWithPeriodicWatermarks<T> assigner)", "class_method_signature": "TimestampsAndPeriodicWatermarksOperator.TimestampsAndPeriodicWatermarksOperator(AssignerWithPeriodicWatermarks<T> assigner)", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}