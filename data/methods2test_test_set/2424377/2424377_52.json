{"test_class": {"identifier": "STCClusteringAlgorithmTest", "superclass": "extends ClusteringAlgorithmTestBase<STCClusteringAlgorithm>", "interfaces": "", "fields": [], "file": "core/src/test/java/org/carrot2/clustering/stc/STCClusteringAlgorithmTest.java"}, "test_case": {"identifier": "testMergingBaseClustersWithStemEquivalentPhrases", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testMergingBaseClustersWithStemEquivalentPhrases() {\n    List<String> titles =\n        Arrays.asList(\n            \"good programs . foo1\",\n            \"foo2 good programs . foo2\",\n            \"good programs taste good\",\n            \"good programs are good\",\n            \"good programming . foo3\",\n            \"foo4 good programming . foo4\",\n            \"good programming makes you feel better\");\n\n    STCClusteringAlgorithm algorithm = algorithm();\n    algorithm.minBaseClusterScore.set(0d);\n\n    Stream<TestDocument> documentStream = titles.stream().map(title -> new TestDocument(title));\n    List<Cluster<Document>> clusters =\n        algorithm.cluster(documentStream, CachedLangComponents.loadCached(\"English\"));\n\n    Assertions.assertThat(clusters.stream().flatMap(cluster -> cluster.getLabels().stream()))\n        .contains(\"Good Programs\")\n        .doesNotContain(\"Good Programming\");\n  }", "signature": "void testMergingBaseClustersWithStemEquivalentPhrases()", "full_signature": "@Test public void testMergingBaseClustersWithStemEquivalentPhrases()", "class_method_signature": "STCClusteringAlgorithmTest.testMergingBaseClustersWithStemEquivalentPhrases()", "testcase": true, "constructor": false, "invocations": ["asList", "algorithm", "set", "map", "stream", "cluster", "loadCached", "doesNotContain", "contains", "assertThat", "flatMap", "stream", "stream", "getLabels"]}, "focal_class": {"identifier": "STCClusteringAlgorithm", "superclass": "extends AttrComposite", "interfaces": "implements ClusteringAlgorithm", "fields": [{"original_string": "private static final Set<Class<?>> REQUIRED_LANGUAGE_COMPONENTS =\n      new HashSet<>(\n          Arrays.asList(Stemmer.class, Tokenizer.class, LexicalData.class, LabelFormatter.class));", "modifier": "private static final", "type": "Set<Class<?>>", "declarator": "REQUIRED_LANGUAGE_COMPONENTS =\n      new HashSet<>(\n          Arrays.asList(Stemmer.class, Tokenizer.class, LexicalData.class, LabelFormatter.class))", "var_name": "REQUIRED_LANGUAGE_COMPONENTS"}, {"original_string": "public static final String NAME = \"STC\";", "modifier": "public static final", "type": "String", "declarator": "NAME = \"STC\"", "var_name": "NAME"}, {"original_string": "public final AttrString queryHint =\n      attributes.register(\"queryHint\", SharedInfrastructure.queryHintAttribute());", "modifier": "public final", "type": "AttrString", "declarator": "queryHint =\n      attributes.register(\"queryHint\", SharedInfrastructure.queryHintAttribute())", "var_name": "queryHint"}, {"original_string": "public AttrDouble ignoreWordIfInHigherDocsPercent =\n      attributes.register(\n          \"ignoreWordIfInHigherDocsPercent\",\n          AttrDouble.builder()\n              .label(\"Ignore words appearing in more than a given fraction of documents\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.9));", "modifier": "public", "type": "AttrDouble", "declarator": "ignoreWordIfInHigherDocsPercent =\n      attributes.register(\n          \"ignoreWordIfInHigherDocsPercent\",\n          AttrDouble.builder()\n              .label(\"Ignore words appearing in more than a given fraction of documents\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.9))", "var_name": "ignoreWordIfInHigherDocsPercent"}, {"original_string": "public AttrDouble minBaseClusterScore =\n      attributes.register(\n          \"minBaseClusterScore\",\n          AttrDouble.builder().label(\"Minimum base cluster score\").min(0).max(10).defaultValue(2.));", "modifier": "public", "type": "AttrDouble", "declarator": "minBaseClusterScore =\n      attributes.register(\n          \"minBaseClusterScore\",\n          AttrDouble.builder().label(\"Minimum base cluster score\").min(0).max(10).defaultValue(2.))", "var_name": "minBaseClusterScore"}, {"original_string": "public AttrInteger minBaseClusterSize =\n      attributes.register(\n          \"minBaseClusterSize\",\n          AttrInteger.builder()\n              .label(\"Minimum number of documents in a base cluster\")\n              .min(2)\n              .max(20)\n              .defaultValue(2));", "modifier": "public", "type": "AttrInteger", "declarator": "minBaseClusterSize =\n      attributes.register(\n          \"minBaseClusterSize\",\n          AttrInteger.builder()\n              .label(\"Minimum number of documents in a base cluster\")\n              .min(2)\n              .max(20)\n              .defaultValue(2))", "var_name": "minBaseClusterSize"}, {"original_string": "public AttrInteger maxBaseClusters =\n      attributes.register(\n          \"maxBaseClusters\",\n          AttrInteger.builder().label(\"Maximum number of base cluster\").min(2).defaultValue(300));", "modifier": "public", "type": "AttrInteger", "declarator": "maxBaseClusters =\n      attributes.register(\n          \"maxBaseClusters\",\n          AttrInteger.builder().label(\"Maximum number of base cluster\").min(2).defaultValue(300))", "var_name": "maxBaseClusters"}, {"original_string": "public AttrInteger maxClusters =\n      attributes.register(\n          \"maxClusters\",\n          AttrInteger.builder().label(\"Maximum number of final clusters\").min(1).defaultValue(15));", "modifier": "public", "type": "AttrInteger", "declarator": "maxClusters =\n      attributes.register(\n          \"maxClusters\",\n          AttrInteger.builder().label(\"Maximum number of final clusters\").min(1).defaultValue(15))", "var_name": "maxClusters"}, {"original_string": "public AttrDouble mergeThreshold =\n      attributes.register(\n          \"mergeThreshold\",\n          AttrDouble.builder()\n              .label(\"Base cluster merge threshold\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.6));", "modifier": "public", "type": "AttrDouble", "declarator": "mergeThreshold =\n      attributes.register(\n          \"mergeThreshold\",\n          AttrDouble.builder()\n              .label(\"Base cluster merge threshold\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.6))", "var_name": "mergeThreshold"}, {"original_string": "public AttrDouble maxPhraseOverlap =\n      attributes.register(\n          \"maxPhraseOverlap\",\n          AttrDouble.builder()\n              .label(\"Maximum cluster phrase overlap\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.6));", "modifier": "public", "type": "AttrDouble", "declarator": "maxPhraseOverlap =\n      attributes.register(\n          \"maxPhraseOverlap\",\n          AttrDouble.builder()\n              .label(\"Maximum cluster phrase overlap\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.6))", "var_name": "maxPhraseOverlap"}, {"original_string": "public AttrDouble mostGeneralPhraseCoverage =\n      attributes.register(\n          \"mostGeneralPhraseCoverage\",\n          AttrDouble.builder()\n              .label(\"Minimum general phrase coverage\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.5));", "modifier": "public", "type": "AttrDouble", "declarator": "mostGeneralPhraseCoverage =\n      attributes.register(\n          \"mostGeneralPhraseCoverage\",\n          AttrDouble.builder()\n              .label(\"Minimum general phrase coverage\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.5))", "var_name": "mostGeneralPhraseCoverage"}, {"original_string": "public AttrInteger maxWordsPerLabel =\n      attributes.register(\n          \"maxWordsPerLabel\",\n          AttrInteger.builder().label(\"Maximum words per label\").min(1).defaultValue(4));", "modifier": "public", "type": "AttrInteger", "declarator": "maxWordsPerLabel =\n      attributes.register(\n          \"maxWordsPerLabel\",\n          AttrInteger.builder().label(\"Maximum words per label\").min(1).defaultValue(4))", "var_name": "maxWordsPerLabel"}, {"original_string": "public AttrInteger maxPhrasesPerLabel =\n      attributes.register(\n          \"maxPhrasesPerLabel\",\n          AttrInteger.builder().label(\"Maximum phrases per label\").min(1).defaultValue(3));", "modifier": "public", "type": "AttrInteger", "declarator": "maxPhrasesPerLabel =\n      attributes.register(\n          \"maxPhrasesPerLabel\",\n          AttrInteger.builder().label(\"Maximum phrases per label\").min(1).defaultValue(3))", "var_name": "maxPhrasesPerLabel"}, {"original_string": "public AttrDouble singleTermBoost =\n      attributes.register(\n          \"singleTermBoost\",\n          AttrDouble.builder().label(\"Boost single-term clusters\").min(0).defaultValue(0.5));", "modifier": "public", "type": "AttrDouble", "declarator": "singleTermBoost =\n      attributes.register(\n          \"singleTermBoost\",\n          AttrDouble.builder().label(\"Boost single-term clusters\").min(0).defaultValue(0.5))", "var_name": "singleTermBoost"}, {"original_string": "public AttrInteger optimalPhraseLength =\n      attributes.register(\n          \"optimalPhraseLength\",\n          AttrInteger.builder().label(\"Optimal cluster label length\").min(1).defaultValue(3));", "modifier": "public", "type": "AttrInteger", "declarator": "optimalPhraseLength =\n      attributes.register(\n          \"optimalPhraseLength\",\n          AttrInteger.builder().label(\"Optimal cluster label length\").min(1).defaultValue(3))", "var_name": "optimalPhraseLength"}, {"original_string": "public AttrDouble optimalPhraseLengthDev =\n      attributes.register(\n          \"optimalPhraseLengthDev\",\n          AttrDouble.builder()\n              .label(\"Optimal cluster label length's tolerance\")\n              .min(0.5)\n              .defaultValue(2.));", "modifier": "public", "type": "AttrDouble", "declarator": "optimalPhraseLengthDev =\n      attributes.register(\n          \"optimalPhraseLengthDev\",\n          AttrDouble.builder()\n              .label(\"Optimal cluster label length's tolerance\")\n              .min(0.5)\n              .defaultValue(2.))", "var_name": "optimalPhraseLengthDev"}, {"original_string": "public AttrDouble documentCountBoost =\n      attributes.register(\n          \"documentCountBoost\",\n          AttrDouble.builder().label(\"Base cluster document count boost\").min(0).defaultValue(1.));", "modifier": "public", "type": "AttrDouble", "declarator": "documentCountBoost =\n      attributes.register(\n          \"documentCountBoost\",\n          AttrDouble.builder().label(\"Base cluster document count boost\").min(0).defaultValue(1.))", "var_name": "documentCountBoost"}, {"original_string": "public AttrDouble scoreWeight =\n      attributes.register(\n          \"scoreWeight\",\n          AttrDouble.builder().label(\"Size-score sorting ratio\").min(0).max(1).defaultValue(0.));", "modifier": "public", "type": "AttrDouble", "declarator": "scoreWeight =\n      attributes.register(\n          \"scoreWeight\",\n          AttrDouble.builder().label(\"Size-score sorting ratio\").min(0).max(1).defaultValue(0.))", "var_name": "scoreWeight"}, {"original_string": "public AttrBoolean mergeStemEquivalentBaseClusters =\n      attributes.register(\n          \"mergeStemEquivalentBaseClusters\",\n          AttrBoolean.builder()\n              .label(\"Merge all stem-equivalent phrases when discovering base clusters\")\n              .defaultValue(true));", "modifier": "public", "type": "AttrBoolean", "declarator": "mergeStemEquivalentBaseClusters =\n      attributes.register(\n          \"mergeStemEquivalentBaseClusters\",\n          AttrBoolean.builder()\n              .label(\"Merge all stem-equivalent phrases when discovering base clusters\")\n              .defaultValue(true))", "var_name": "mergeStemEquivalentBaseClusters"}, {"original_string": "public BasicPreprocessingPipeline preprocessing;", "modifier": "public", "type": "BasicPreprocessingPipeline", "declarator": "preprocessing", "var_name": "preprocessing"}, {"original_string": "private LabelFormatter labelFormatter;", "modifier": "private", "type": "LabelFormatter", "declarator": "labelFormatter", "var_name": "labelFormatter"}, {"original_string": "private static final Predicate<PhraseCandidate> NOT_SELECTED = (p) -> !p.selected;", "modifier": "private static final", "type": "Predicate<PhraseCandidate>", "declarator": "NOT_SELECTED = (p) -> !p.selected", "var_name": "NOT_SELECTED"}, {"original_string": "private GeneralizedSuffixTree.SequenceBuilder sb;", "modifier": "private", "type": "GeneralizedSuffixTree.SequenceBuilder", "declarator": "sb", "var_name": "sb"}, {"original_string": "private PreprocessingContext context;", "modifier": "private", "type": "PreprocessingContext", "declarator": "context", "var_name": "context"}], "methods": [{"identifier": "requiredLanguageComponents", "parameters": "()", "modifiers": "@Override public", "return": "Set<Class<?>>", "signature": "Set<Class<?>> requiredLanguageComponents()", "full_signature": "@Override public Set<Class<?>> requiredLanguageComponents()", "class_method_signature": "STCClusteringAlgorithm.requiredLanguageComponents()", "testcase": false, "constructor": false}, {"identifier": "cluster", "parameters": "(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "modifiers": "@Override public", "return": "List<Cluster<T>>", "signature": "List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "full_signature": "@Override public List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "class_method_signature": "STCClusteringAlgorithm.cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "testcase": false, "constructor": false}, {"identifier": "createBaseClusters", "parameters": "(SequenceBuilder sb)", "modifiers": "private", "return": "List<ClusterCandidate>", "signature": "List<ClusterCandidate> createBaseClusters(SequenceBuilder sb)", "full_signature": "private List<ClusterCandidate> createBaseClusters(SequenceBuilder sb)", "class_method_signature": "STCClusteringAlgorithm.createBaseClusters(SequenceBuilder sb)", "testcase": false, "constructor": false}, {"identifier": "mergeStemEquivalentBaseClusters", "parameters": "(\n      SequenceBuilder sb, final List<ClusterCandidate> candidates)", "modifiers": "private", "return": "void", "signature": "void mergeStemEquivalentBaseClusters(\n      SequenceBuilder sb, final List<ClusterCandidate> candidates)", "full_signature": "private void mergeStemEquivalentBaseClusters(\n      SequenceBuilder sb, final List<ClusterCandidate> candidates)", "class_method_signature": "STCClusteringAlgorithm.mergeStemEquivalentBaseClusters(\n      SequenceBuilder sb, final List<ClusterCandidate> candidates)", "testcase": false, "constructor": false}, {"identifier": "createMergedClusters", "parameters": "(List<ClusterCandidate> baseClusters)", "modifiers": "private", "return": "ArrayList<ClusterCandidate>", "signature": "ArrayList<ClusterCandidate> createMergedClusters(List<ClusterCandidate> baseClusters)", "full_signature": "private ArrayList<ClusterCandidate> createMergedClusters(List<ClusterCandidate> baseClusters)", "class_method_signature": "STCClusteringAlgorithm.createMergedClusters(List<ClusterCandidate> baseClusters)", "testcase": false, "constructor": false}, {"identifier": "merge", "parameters": "(\n      PreprocessingContext context, IntStack mergeList, List<ClusterCandidate> baseClusters)", "modifiers": "private", "return": "ClusterCandidate", "signature": "ClusterCandidate merge(\n      PreprocessingContext context, IntStack mergeList, List<ClusterCandidate> baseClusters)", "full_signature": "private ClusterCandidate merge(\n      PreprocessingContext context, IntStack mergeList, List<ClusterCandidate> baseClusters)", "class_method_signature": "STCClusteringAlgorithm.merge(\n      PreprocessingContext context, IntStack mergeList, List<ClusterCandidate> baseClusters)", "testcase": false, "constructor": false}, {"identifier": "markSubSuperPhrases", "parameters": "(ArrayList<PhraseCandidate> phrases)", "modifiers": "private", "return": "void", "signature": "void markSubSuperPhrases(ArrayList<PhraseCandidate> phrases)", "full_signature": "private void markSubSuperPhrases(ArrayList<PhraseCandidate> phrases)", "class_method_signature": "STCClusteringAlgorithm.markSubSuperPhrases(ArrayList<PhraseCandidate> phrases)", "testcase": false, "constructor": false}, {"identifier": "markOverlappingPhrases", "parameters": "(\n      PreprocessingContext context, ArrayList<PhraseCandidate> phrases)", "modifiers": "private", "return": "void", "signature": "void markOverlappingPhrases(\n      PreprocessingContext context, ArrayList<PhraseCandidate> phrases)", "full_signature": "private void markOverlappingPhrases(\n      PreprocessingContext context, ArrayList<PhraseCandidate> phrases)", "class_method_signature": "STCClusteringAlgorithm.markOverlappingPhrases(\n      PreprocessingContext context, ArrayList<PhraseCandidate> phrases)", "testcase": false, "constructor": false}, {"identifier": "computeIntersection", "parameters": "(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "modifiers": "static", "return": "int", "signature": "int computeIntersection(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "full_signature": "static int computeIntersection(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "class_method_signature": "STCClusteringAlgorithm.computeIntersection(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "testcase": false, "constructor": false}, {"identifier": "appendUniqueWords", "parameters": "(\n      PreprocessingContext context, IntStack words, IntStack offsets, PhraseCandidate p)", "modifiers": "private", "return": "void", "signature": "void appendUniqueWords(\n      PreprocessingContext context, IntStack words, IntStack offsets, PhraseCandidate p)", "full_signature": "private void appendUniqueWords(\n      PreprocessingContext context, IntStack words, IntStack offsets, PhraseCandidate p)", "class_method_signature": "STCClusteringAlgorithm.appendUniqueWords(\n      PreprocessingContext context, IntStack words, IntStack offsets, PhraseCandidate p)", "testcase": false, "constructor": false}, {"identifier": "appendWords", "parameters": "(IntStack words, IntStack offsets, PhraseCandidate p)", "modifiers": "private", "return": "void", "signature": "void appendWords(IntStack words, IntStack offsets, PhraseCandidate p)", "full_signature": "private void appendWords(IntStack words, IntStack offsets, PhraseCandidate p)", "class_method_signature": "STCClusteringAlgorithm.appendWords(IntStack words, IntStack offsets, PhraseCandidate p)", "testcase": false, "constructor": false}, {"identifier": "postProcessing", "parameters": "(\n      List<T> documents, List<ClusterCandidate> candidates, List<Cluster<T>> clusters)", "modifiers": "private", "return": "void", "signature": "void postProcessing(\n      List<T> documents, List<ClusterCandidate> candidates, List<Cluster<T>> clusters)", "full_signature": "private void postProcessing(\n      List<T> documents, List<ClusterCandidate> candidates, List<Cluster<T>> clusters)", "class_method_signature": "STCClusteringAlgorithm.postProcessing(\n      List<T> documents, List<ClusterCandidate> candidates, List<Cluster<T>> clusters)", "testcase": false, "constructor": false}, {"identifier": "collectPhrases", "parameters": "(ClusterCandidate c, Cluster<?> cluster)", "modifiers": "private", "return": "void", "signature": "void collectPhrases(ClusterCandidate c, Cluster<?> cluster)", "full_signature": "private void collectPhrases(ClusterCandidate c, Cluster<?> cluster)", "class_method_signature": "STCClusteringAlgorithm.collectPhrases(ClusterCandidate c, Cluster<?> cluster)", "testcase": false, "constructor": false}, {"identifier": "collectDocuments", "parameters": "(\n      List<T> documents, List<T> l, BitSet bitset)", "modifiers": "private", "return": "List<T>", "signature": "List<T> collectDocuments(\n      List<T> documents, List<T> l, BitSet bitset)", "full_signature": "private List<T> collectDocuments(\n      List<T> documents, List<T> l, BitSet bitset)", "class_method_signature": "STCClusteringAlgorithm.collectDocuments(\n      List<T> documents, List<T> l, BitSet bitset)", "testcase": false, "constructor": false}, {"identifier": "buildLabel", "parameters": "(int[] phraseIndices)", "modifiers": "private", "return": "String", "signature": "String buildLabel(int[] phraseIndices)", "full_signature": "private String buildLabel(int[] phraseIndices)", "class_method_signature": "STCClusteringAlgorithm.buildLabel(int[] phraseIndices)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "(PhraseCandidate c)", "modifiers": "@SuppressWarnings(\"unused\") private", "return": "String", "signature": "String toString(PhraseCandidate c)", "full_signature": "@SuppressWarnings(\"unused\") private String toString(PhraseCandidate c)", "class_method_signature": "STCClusteringAlgorithm.toString(PhraseCandidate c)", "testcase": false, "constructor": false}, {"identifier": "buildDebugLabel", "parameters": "(int[] phraseIndices)", "modifiers": "@SuppressWarnings(\"unused\") private", "return": "String", "signature": "String buildDebugLabel(int[] phraseIndices)", "full_signature": "@SuppressWarnings(\"unused\") private String buildDebugLabel(int[] phraseIndices)", "class_method_signature": "STCClusteringAlgorithm.buildDebugLabel(int[] phraseIndices)", "testcase": false, "constructor": false}, {"identifier": "checkAcceptablePhrase", "parameters": "(IntStack path)", "modifiers": "final", "return": "boolean", "signature": "boolean checkAcceptablePhrase(IntStack path)", "full_signature": "final boolean checkAcceptablePhrase(IntStack path)", "class_method_signature": "STCClusteringAlgorithm.checkAcceptablePhrase(IntStack path)", "testcase": false, "constructor": false}, {"identifier": "effectivePhraseLength", "parameters": "(IntStack path)", "modifiers": "final", "return": "int", "signature": "int effectivePhraseLength(IntStack path)", "full_signature": "final int effectivePhraseLength(IntStack path)", "class_method_signature": "STCClusteringAlgorithm.effectivePhraseLength(IntStack path)", "testcase": false, "constructor": false}, {"identifier": "baseClusterScore", "parameters": "(final int phraseLength, final int documentCount)", "modifiers": "final", "return": "float", "signature": "float baseClusterScore(final int phraseLength, final int documentCount)", "full_signature": "final float baseClusterScore(final int phraseLength, final int documentCount)", "class_method_signature": "STCClusteringAlgorithm.baseClusterScore(final int phraseLength, final int documentCount)", "testcase": false, "constructor": false}, {"identifier": "indexOf", "parameters": "(\n      int[] source,\n      int sourceOffset,\n      int sourceCount,\n      int[] target,\n      int targetOffset,\n      int targetCount)", "modifiers": "private static", "return": "int", "signature": "int indexOf(\n      int[] source,\n      int sourceOffset,\n      int sourceCount,\n      int[] target,\n      int targetOffset,\n      int targetCount)", "full_signature": "private static int indexOf(\n      int[] source,\n      int sourceOffset,\n      int sourceCount,\n      int[] target,\n      int targetOffset,\n      int targetCount)", "class_method_signature": "STCClusteringAlgorithm.indexOf(\n      int[] source,\n      int sourceOffset,\n      int sourceCount,\n      int[] target,\n      int targetOffset,\n      int targetCount)", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/carrot2/clustering/stc/STCClusteringAlgorithm.java"}, "focal_method": {"identifier": "cluster", "parameters": "(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "modifiers": "@Override public", "return": "List<Cluster<T>>", "body": "@Override\n  public <T extends Document> List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents) {\n    List<T> documents = docStream.collect(Collectors.toList());\n    List<Cluster<T>> clusters = new ArrayList<>();\n\n    /*\n     * Step 1. Preprocessing: tokenization, stop word marking and stemming (if available).\n     */\n    context = preprocessing.preprocess(documents.stream(), queryHint.get(), languageComponents);\n    labelFormatter = context.languageComponents.get(LabelFormatter.class);\n\n    /*\n     * Step 2: Create a generalized suffix tree from phrases in the input.\n     */\n    sb = new GeneralizedSuffixTree.SequenceBuilder();\n\n    final int[] tokenIndex = context.allTokens.wordIndex;\n    final short[] tokenType = context.allTokens.type;\n    for (int i = 0; i < tokenIndex.length; i++) {\n      /* Advance until the first real token. */\n      if (tokenIndex[i] == -1) {\n        if ((tokenType[i] & (Tokenizer.TF_SEPARATOR_DOCUMENT | Tokenizer.TF_TERMINATOR)) != 0) {\n          sb.endDocument();\n        }\n        continue;\n      }\n\n      /* We have the first token. Advance until non-token. */\n      final int s = i;\n\n      while (tokenIndex[i + 1] != -1) i++;\n      final int phraseLength = 1 + i - s;\n      if (phraseLength >= 1) {\n        /* We have a phrase. */\n        sb.addPhrase(tokenIndex, s, phraseLength);\n      }\n    }\n    sb.buildSuffixTree();\n\n    /*\n     * Step 3: Find \"base\" clusters by looking up frequently recurring phrases in the\n     * generalized suffix tree.\n     */\n    List<ClusterCandidate> baseClusters = createBaseClusters(sb);\n\n    /*\n     * Step 4: Merge base clusters that overlap too much to form final clusters.\n     */\n    List<ClusterCandidate> mergedClusters = createMergedClusters(baseClusters);\n\n    /*\n     * Step 5: Create the junk (unassigned documents) cluster and create the final\n     * set of clusters in Carrot2 format.\n     */\n    postProcessing(documents, mergedClusters, clusters);\n\n    return SharedInfrastructure.reorderByWeightedScoreAndSize(clusters, this.scoreWeight.get());\n  }", "signature": "List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "full_signature": "@Override public List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "class_method_signature": "STCClusteringAlgorithm.cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "testcase": false, "constructor": false, "invocations": ["collect", "toList", "preprocess", "stream", "get", "get", "endDocument", "addPhrase", "buildSuffixTree", "createBaseClusters", "createMergedClusters", "postProcessing", "reorderByWeightedScoreAndSize", "get"]}, "repository": {"repo_id": 2424377, "url": "https://github.com/carrot2/carrot2", "stars": 393, "created": "9/20/2011 6:19:05 PM +00:00", "updates": "2020-01-24T20:43:38+00:00", "fork": "False", "license": "licensed"}}