{"test_class": {"identifier": "GDBTrainerTest", "superclass": "extends TrainerTest", "interfaces": "", "fields": [], "file": "modules/ml/src/test/java/org/apache/ignite/ml/composition/boosting/GDBTrainerTest.java"}, "test_case": {"identifier": "testFitRegression", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testFitRegression() {\n        int size = 100;\n        double[] xs = new double[size];\n        double[] ys = new double[size];\n        double from = -5.0;\n        double to = 5.0;\n        double step = Math.abs(from - to) / size;\n\n        Map<Integer, double[]> learningSample = new HashMap<>();\n        for (int i = 0; i < size; i++) {\n            xs[i] = from + step * i;\n            ys[i] = 2 * xs[i];\n            learningSample.put(i, new double[] {xs[i], ys[i]});\n        }\n\n        GDBTrainer trainer = new GDBRegressionOnTreesTrainer(1.0, 400, 3, 0.0)\n            .withUsingIdx(true);\n\n        IgniteModel<Vector, Double> mdl = trainer.fit(\n            learningSample, 1,\n            new DoubleArrayVectorizer<Integer>().labeled(Vectorizer.LabelCoordinate.LAST)\n        );\n\n        double mse = 0.0;\n        for (int j = 0; j < size; j++) {\n            double x = xs[j];\n            double y = ys[j];\n            double p = mdl.predict(VectorUtils.of(x));\n            mse += Math.pow(y - p, 2);\n        }\n        mse /= size;\n\n        assertEquals(0.0, mse, 0.0001);\n\n        ModelsComposition composition = (ModelsComposition)mdl;\n        assertTrue(!composition.toString().isEmpty());\n        assertTrue(!composition.toString(true).isEmpty());\n        assertTrue(!composition.toString(false).isEmpty());\n\n        composition.getModels().forEach(m -> assertTrue(m instanceof DecisionTreeConditionalNode));\n\n        assertEquals(400, composition.getModels().size());\n        assertTrue(composition.getPredictionsAggregator() instanceof WeightedPredictionsAggregator);\n\n        trainer = trainer.withCheckConvergenceStgyFactory(new MeanAbsValueConvergenceCheckerFactory(0.1));\n        assertTrue(trainer.fit(learningSample, 1, new DoubleArrayVectorizer<Integer>().labeled(1)).getModels().size() < 2000);\n    }", "signature": "void testFitRegression()", "full_signature": "@Test public void testFitRegression()", "class_method_signature": "GDBTrainerTest.testFitRegression()", "testcase": true, "constructor": false, "invocations": ["abs", "put", "withUsingIdx", "fit", "labeled", "predict", "of", "pow", "assertEquals", "assertTrue", "isEmpty", "toString", "assertTrue", "isEmpty", "toString", "assertTrue", "isEmpty", "toString", "forEach", "getModels", "assertTrue", "assertEquals", "size", "getModels", "assertTrue", "getPredictionsAggregator", "withCheckConvergenceStgyFactory", "assertTrue", "size", "getModels", "fit", "labeled"]}, "focal_class": {"identifier": "GDBTrainer", "superclass": "extends DatasetTrainer<ModelsComposition, Double>", "interfaces": "", "fields": [{"original_string": "private final double gradientStep;", "modifier": "private final", "type": "double", "declarator": "gradientStep", "var_name": "gradientStep"}, {"original_string": "private final int cntOfIterations;", "modifier": "private final", "type": "int", "declarator": "cntOfIterations", "var_name": "cntOfIterations"}, {"original_string": "protected final Loss loss;", "modifier": "protected final", "type": "Loss", "declarator": "loss", "var_name": "loss"}, {"original_string": "protected ConvergenceCheckerFactory checkConvergenceStgyFactory = new MeanAbsValueConvergenceCheckerFactory(0.001);", "modifier": "protected", "type": "ConvergenceCheckerFactory", "declarator": "checkConvergenceStgyFactory = new MeanAbsValueConvergenceCheckerFactory(0.001)", "var_name": "checkConvergenceStgyFactory"}], "methods": [{"identifier": "GDBTrainer", "parameters": "(double gradStepSize, Integer cntOfIterations, Loss loss)", "modifiers": "public", "return": "", "signature": " GDBTrainer(double gradStepSize, Integer cntOfIterations, Loss loss)", "full_signature": "public  GDBTrainer(double gradStepSize, Integer cntOfIterations, Loss loss)", "class_method_signature": "GDBTrainer.GDBTrainer(double gradStepSize, Integer cntOfIterations, Loss loss)", "testcase": false, "constructor": true}, {"identifier": "fitWithInitializedDeployingContext", "parameters": "(DatasetBuilder<K, V> datasetBuilder,\n                                                  Preprocessor<K, V> preprocessor)", "modifiers": "@Override public", "return": "ModelsComposition", "signature": "ModelsComposition fitWithInitializedDeployingContext(DatasetBuilder<K, V> datasetBuilder,\n                                                  Preprocessor<K, V> preprocessor)", "full_signature": "@Override public ModelsComposition fitWithInitializedDeployingContext(DatasetBuilder<K, V> datasetBuilder,\n                                                  Preprocessor<K, V> preprocessor)", "class_method_signature": "GDBTrainer.fitWithInitializedDeployingContext(DatasetBuilder<K, V> datasetBuilder,\n                                                  Preprocessor<K, V> preprocessor)", "testcase": false, "constructor": false}, {"identifier": "updateModel", "parameters": "(ModelsComposition mdl,\n                                                             DatasetBuilder<K, V> datasetBuilder,\n                                                             Preprocessor<K, V> preprocessor)", "modifiers": "@Override protected", "return": "ModelsComposition", "signature": "ModelsComposition updateModel(ModelsComposition mdl,\n                                                             DatasetBuilder<K, V> datasetBuilder,\n                                                             Preprocessor<K, V> preprocessor)", "full_signature": "@Override protected ModelsComposition updateModel(ModelsComposition mdl,\n                                                             DatasetBuilder<K, V> datasetBuilder,\n                                                             Preprocessor<K, V> preprocessor)", "class_method_signature": "GDBTrainer.updateModel(ModelsComposition mdl,\n                                                             DatasetBuilder<K, V> datasetBuilder,\n                                                             Preprocessor<K, V> preprocessor)", "testcase": false, "constructor": false}, {"identifier": "isUpdateable", "parameters": "(ModelsComposition mdl)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isUpdateable(ModelsComposition mdl)", "full_signature": "@Override public boolean isUpdateable(ModelsComposition mdl)", "class_method_signature": "GDBTrainer.isUpdateable(ModelsComposition mdl)", "testcase": false, "constructor": false}, {"identifier": "withEnvironmentBuilder", "parameters": "(LearningEnvironmentBuilder envBuilder)", "modifiers": "@Override public", "return": "GDBTrainer", "signature": "GDBTrainer withEnvironmentBuilder(LearningEnvironmentBuilder envBuilder)", "full_signature": "@Override public GDBTrainer withEnvironmentBuilder(LearningEnvironmentBuilder envBuilder)", "class_method_signature": "GDBTrainer.withEnvironmentBuilder(LearningEnvironmentBuilder envBuilder)", "testcase": false, "constructor": false}, {"identifier": "learnLabels", "parameters": "(DatasetBuilder<K, V> builder,\n                                                  Preprocessor<K, V> preprocessor)", "modifiers": "protected abstract", "return": "boolean", "signature": "boolean learnLabels(DatasetBuilder<K, V> builder,\n                                                  Preprocessor<K, V> preprocessor)", "full_signature": "protected abstract boolean learnLabels(DatasetBuilder<K, V> builder,\n                                                  Preprocessor<K, V> preprocessor)", "class_method_signature": "GDBTrainer.learnLabels(DatasetBuilder<K, V> builder,\n                                                  Preprocessor<K, V> preprocessor)", "testcase": false, "constructor": false}, {"identifier": "buildBaseModelTrainer", "parameters": "()", "modifiers": "@NotNull protected abstract", "return": "DatasetTrainer<? extends IgniteModel<Vector, Double>, Double>", "signature": "DatasetTrainer<? extends IgniteModel<Vector, Double>, Double> buildBaseModelTrainer()", "full_signature": "@NotNull protected abstract DatasetTrainer<? extends IgniteModel<Vector, Double>, Double> buildBaseModelTrainer()", "class_method_signature": "GDBTrainer.buildBaseModelTrainer()", "testcase": false, "constructor": false}, {"identifier": "externalLabelToInternal", "parameters": "(double lbl)", "modifiers": "protected abstract", "return": "double", "signature": "double externalLabelToInternal(double lbl)", "full_signature": "protected abstract double externalLabelToInternal(double lbl)", "class_method_signature": "GDBTrainer.externalLabelToInternal(double lbl)", "testcase": false, "constructor": false}, {"identifier": "internalLabelToExternal", "parameters": "(double lbl)", "modifiers": "protected abstract", "return": "double", "signature": "double internalLabelToExternal(double lbl)", "full_signature": "protected abstract double internalLabelToExternal(double lbl)", "class_method_signature": "GDBTrainer.internalLabelToExternal(double lbl)", "testcase": false, "constructor": false}, {"identifier": "computeInitialValue", "parameters": "(\n        LearningEnvironmentBuilder envBuilder,\n        DatasetBuilder<K, V> builder,\n        Preprocessor<K, V> preprocessor)", "modifiers": "protected", "return": "IgniteBiTuple<Double, Long>", "signature": "IgniteBiTuple<Double, Long> computeInitialValue(\n        LearningEnvironmentBuilder envBuilder,\n        DatasetBuilder<K, V> builder,\n        Preprocessor<K, V> preprocessor)", "full_signature": "protected IgniteBiTuple<Double, Long> computeInitialValue(\n        LearningEnvironmentBuilder envBuilder,\n        DatasetBuilder<K, V> builder,\n        Preprocessor<K, V> preprocessor)", "class_method_signature": "GDBTrainer.computeInitialValue(\n        LearningEnvironmentBuilder envBuilder,\n        DatasetBuilder<K, V> builder,\n        Preprocessor<K, V> preprocessor)", "testcase": false, "constructor": false}, {"identifier": "withCheckConvergenceStgyFactory", "parameters": "(ConvergenceCheckerFactory factory)", "modifiers": "public", "return": "GDBTrainer", "signature": "GDBTrainer withCheckConvergenceStgyFactory(ConvergenceCheckerFactory factory)", "full_signature": "public GDBTrainer withCheckConvergenceStgyFactory(ConvergenceCheckerFactory factory)", "class_method_signature": "GDBTrainer.withCheckConvergenceStgyFactory(ConvergenceCheckerFactory factory)", "testcase": false, "constructor": false}, {"identifier": "getLearningStrategy", "parameters": "()", "modifiers": "protected", "return": "GDBLearningStrategy", "signature": "GDBLearningStrategy getLearningStrategy()", "full_signature": "protected GDBLearningStrategy getLearningStrategy()", "class_method_signature": "GDBTrainer.getLearningStrategy()", "testcase": false, "constructor": false}], "file": "modules/ml/src/main/java/org/apache/ignite/ml/composition/boosting/GDBTrainer.java"}, "focal_method": {"identifier": "withCheckConvergenceStgyFactory", "parameters": "(ConvergenceCheckerFactory factory)", "modifiers": "public", "return": "GDBTrainer", "body": "public GDBTrainer withCheckConvergenceStgyFactory(ConvergenceCheckerFactory factory) {\n        this.checkConvergenceStgyFactory = factory;\n        return this;\n    }", "signature": "GDBTrainer withCheckConvergenceStgyFactory(ConvergenceCheckerFactory factory)", "full_signature": "public GDBTrainer withCheckConvergenceStgyFactory(ConvergenceCheckerFactory factory)", "class_method_signature": "GDBTrainer.withCheckConvergenceStgyFactory(ConvergenceCheckerFactory factory)", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 170496871, "url": "https://github.com/gridgain/gridgain", "stars": 46, "created": "2/13/2019 11:31:35 AM +00:00", "updates": "2020-01-27T16:02:24+00:00", "fork": "False", "license": "licensed"}}