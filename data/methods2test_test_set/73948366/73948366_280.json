{"test_class": {"identifier": "PrincipalTokenTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final String svcVersion = \"S1\";", "modifier": "private final", "type": "String", "declarator": "svcVersion = \"S1\"", "var_name": "svcVersion"}, {"original_string": "private final String usrVersion = \"U1\";", "modifier": "private final", "type": "String", "declarator": "usrVersion = \"U1\"", "var_name": "usrVersion"}, {"original_string": "private final String svcDomain = \"sports\";", "modifier": "private final", "type": "String", "declarator": "svcDomain = \"sports\"", "var_name": "svcDomain"}, {"original_string": "private final String svcName = \"fantasy\";", "modifier": "private final", "type": "String", "declarator": "svcName = \"fantasy\"", "var_name": "svcName"}, {"original_string": "private final String usrDomain = \"user\";", "modifier": "private final", "type": "String", "declarator": "usrDomain = \"user\"", "var_name": "usrDomain"}, {"original_string": "private final String usrName = \"john\";", "modifier": "private final", "type": "String", "declarator": "usrName = \"john\"", "var_name": "usrName"}, {"original_string": "private final String host = \"somehost.somecompany.com\";", "modifier": "private final", "type": "String", "declarator": "host = \"somehost.somecompany.com\"", "var_name": "host"}, {"original_string": "private final String salt = \"saltvalue\";", "modifier": "private final", "type": "String", "declarator": "salt = \"saltvalue\"", "var_name": "salt"}, {"original_string": "private final long expirationTime = 10;", "modifier": "private final", "type": "long", "declarator": "expirationTime = 10", "var_name": "expirationTime"}, {"original_string": "private String servicePublicKeyStringK0 = null;", "modifier": "private", "type": "String", "declarator": "servicePublicKeyStringK0 = null", "var_name": "servicePublicKeyStringK0"}, {"original_string": "private String servicePrivateKeyStringK0 = null;", "modifier": "private", "type": "String", "declarator": "servicePrivateKeyStringK0 = null", "var_name": "servicePrivateKeyStringK0"}, {"original_string": "private String servicePublicKeyStringK1 = null;", "modifier": "private", "type": "String", "declarator": "servicePublicKeyStringK1 = null", "var_name": "servicePublicKeyStringK1"}, {"original_string": "private String servicePrivateKeyStringK1 = null;", "modifier": "private", "type": "String", "declarator": "servicePrivateKeyStringK1 = null", "var_name": "servicePrivateKeyStringK1"}], "file": "libs/java/auth_core/src/test/java/com/yahoo/athenz/auth/token/PrincipalTokenTest.java"}, "test_case": {"identifier": "testIsValidAuthorizedServiceTokenSvcNoSigYes", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testIsValidAuthorizedServiceTokenSvcNoSigYes() {\n\n        // we're going to test where we have an authorized\n        // service signature but no service name\n\n        String token = \"v=S1;d=domain;n=service;t=1234;e=1235;k=0;h=host1;i=1.2.3.4;s=signature;bk=0;bs=signature\";\n        PrincipalToken svcToken = new PrincipalToken(token);\n        StringBuilder errMsg = new StringBuilder();\n        assertFalse(svcToken.isValidAuthorizedServiceToken(errMsg));\n        assertTrue(!errMsg.toString().isEmpty());\n    }", "signature": "void testIsValidAuthorizedServiceTokenSvcNoSigYes()", "full_signature": "@Test public void testIsValidAuthorizedServiceTokenSvcNoSigYes()", "class_method_signature": "PrincipalTokenTest.testIsValidAuthorizedServiceTokenSvcNoSigYes()", "testcase": true, "constructor": false, "invocations": ["assertFalse", "isValidAuthorizedServiceToken", "assertTrue", "isEmpty", "toString"]}, "focal_class": {"identifier": "PrincipalToken", "superclass": "extends Token", "interfaces": "", "fields": [{"original_string": "private String name = null;", "modifier": "private", "type": "String", "declarator": "name = null", "var_name": "name"}, {"original_string": "private String originalRequestor = null;", "modifier": "private", "type": "String", "declarator": "originalRequestor = null", "var_name": "originalRequestor"}, {"original_string": "protected String keyService = null;", "modifier": "protected", "type": "String", "declarator": "keyService = null", "var_name": "keyService"}, {"original_string": "private List<String> authorizedServices = null;", "modifier": "private", "type": "List<String>", "declarator": "authorizedServices = null", "var_name": "authorizedServices"}, {"original_string": "private String authorizedServiceName = null;", "modifier": "private", "type": "String", "declarator": "authorizedServiceName = null", "var_name": "authorizedServiceName"}, {"original_string": "private String authorizedServiceKeyId = \"0\";", "modifier": "private", "type": "String", "declarator": "authorizedServiceKeyId = \"0\"", "var_name": "authorizedServiceKeyId"}, {"original_string": "private String authorizedServiceSignature = null;", "modifier": "private", "type": "String", "declarator": "authorizedServiceSignature = null", "var_name": "authorizedServiceSignature"}, {"original_string": "private static final Logger LOG = LoggerFactory.getLogger(PrincipalToken.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(PrincipalToken.class)", "var_name": "LOG"}], "methods": [{"identifier": "PrincipalToken", "parameters": "(Builder builder)", "modifiers": "private", "return": "", "signature": " PrincipalToken(Builder builder)", "full_signature": "private  PrincipalToken(Builder builder)", "class_method_signature": "PrincipalToken.PrincipalToken(Builder builder)", "testcase": false, "constructor": true}, {"identifier": "PrincipalToken", "parameters": "(String signedToken)", "modifiers": "public", "return": "", "signature": " PrincipalToken(String signedToken)", "full_signature": "public  PrincipalToken(String signedToken)", "class_method_signature": "PrincipalToken.PrincipalToken(String signedToken)", "testcase": false, "constructor": true}, {"identifier": "signForAuthorizedService", "parameters": "(String authorizedServiceName, String authorizedServiceKeyId,\n            String privKey)", "modifiers": "public", "return": "void", "signature": "void signForAuthorizedService(String authorizedServiceName, String authorizedServiceKeyId,\n            String privKey)", "full_signature": "public void signForAuthorizedService(String authorizedServiceName, String authorizedServiceKeyId,\n            String privKey)", "class_method_signature": "PrincipalToken.signForAuthorizedService(String authorizedServiceName, String authorizedServiceKeyId,\n            String privKey)", "testcase": false, "constructor": false}, {"identifier": "signForAuthorizedService", "parameters": "(String authorizedServiceName, String authorizedServiceKeyId,\n            PrivateKey key)", "modifiers": "public", "return": "void", "signature": "void signForAuthorizedService(String authorizedServiceName, String authorizedServiceKeyId,\n            PrivateKey key)", "full_signature": "public void signForAuthorizedService(String authorizedServiceName, String authorizedServiceKeyId,\n            PrivateKey key)", "class_method_signature": "PrincipalToken.signForAuthorizedService(String authorizedServiceName, String authorizedServiceKeyId,\n            PrivateKey key)", "testcase": false, "constructor": false}, {"identifier": "validateForAuthorizedService", "parameters": "(String pubKey, StringBuilder errMsg)", "modifiers": "public", "return": "boolean", "signature": "boolean validateForAuthorizedService(String pubKey, StringBuilder errMsg)", "full_signature": "public boolean validateForAuthorizedService(String pubKey, StringBuilder errMsg)", "class_method_signature": "PrincipalToken.validateForAuthorizedService(String pubKey, StringBuilder errMsg)", "testcase": false, "constructor": false}, {"identifier": "isValidAuthorizedServiceToken", "parameters": "(StringBuilder errMsg)", "modifiers": "public", "return": "boolean", "signature": "boolean isValidAuthorizedServiceToken(StringBuilder errMsg)", "full_signature": "public boolean isValidAuthorizedServiceToken(StringBuilder errMsg)", "class_method_signature": "PrincipalToken.isValidAuthorizedServiceToken(StringBuilder errMsg)", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getName()", "full_signature": "public String getName()", "class_method_signature": "PrincipalToken.getName()", "testcase": false, "constructor": false}, {"identifier": "getKeyService", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getKeyService()", "full_signature": "public String getKeyService()", "class_method_signature": "PrincipalToken.getKeyService()", "testcase": false, "constructor": false}, {"identifier": "getOriginalRequestor", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getOriginalRequestor()", "full_signature": "public String getOriginalRequestor()", "class_method_signature": "PrincipalToken.getOriginalRequestor()", "testcase": false, "constructor": false}, {"identifier": "getAuthorizedServices", "parameters": "()", "modifiers": "public", "return": "List<String>", "signature": "List<String> getAuthorizedServices()", "full_signature": "public List<String> getAuthorizedServices()", "class_method_signature": "PrincipalToken.getAuthorizedServices()", "testcase": false, "constructor": false}, {"identifier": "getAuthorizedServiceName", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getAuthorizedServiceName()", "full_signature": "public String getAuthorizedServiceName()", "class_method_signature": "PrincipalToken.getAuthorizedServiceName()", "testcase": false, "constructor": false}, {"identifier": "getAuthorizedServiceKeyId", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getAuthorizedServiceKeyId()", "full_signature": "public String getAuthorizedServiceKeyId()", "class_method_signature": "PrincipalToken.getAuthorizedServiceKeyId()", "testcase": false, "constructor": false}, {"identifier": "getAuthorizedServiceSignature", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getAuthorizedServiceSignature()", "full_signature": "public String getAuthorizedServiceSignature()", "class_method_signature": "PrincipalToken.getAuthorizedServiceSignature()", "testcase": false, "constructor": false}], "file": "libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/token/PrincipalToken.java"}, "focal_method": {"identifier": "isValidAuthorizedServiceToken", "parameters": "(StringBuilder errMsg)", "modifiers": "public", "return": "boolean", "body": "public boolean isValidAuthorizedServiceToken(StringBuilder errMsg) {\n        \n        /* we start our by checking if this is an authorized service token */\n        errMsg = errMsg == null ? new StringBuilder(512) : errMsg;\n        if (authorizedServices == null) {\n            \n            /* if both the service name list and signature are not present\n             * then we have a standard principal token */\n            \n            if (authorizedServiceSignature == null) {\n                return true;\n            }\n            \n            /* otherwise we have an invalid token without the signature */\n            errMsg.append(\"PrincipalToken:isValidAuthorizedServiceToken: Invalid Token=\").\n                   append(unsignedToken).\n                   append(\" : Authorized Service Signature available without service name\"); \n            LOG.error(errMsg.toString());\n            return false;\n        }\n        \n        /* if we have an authorized service name then we must have a corresponding\n         * signature available in the token */\n        \n        if (authorizedServiceSignature == null) {\n            errMsg.append(\"PrincipalToken:isValidAuthorizedServiceToken: Invalid Token=\").\n                   append(unsignedToken).\n                   append(\" : Missing signature for specified authorized service\"); \n            LOG.error(errMsg.toString());\n            return false;\n        }\n        \n        /* if we have a specific authorized service name specified then\n         * it must be present in our service list otherwise we must\n         * have a single entry in our list */\n        \n        if (authorizedServiceName != null) {\n            if (!authorizedServices.contains(authorizedServiceName)) {\n                errMsg.append(\"PrincipalToken:isValidAuthorizedServiceToken: Invalid Token=\").\n                       append(unsignedToken).\n                       append(\" : Authorized service name=\").append(authorizedServiceName).\n                       append(\" is not listed in the service list\"); \n                LOG.error(errMsg.toString());\n                return false;\n            }\n        } else if (authorizedServices.size() != 1) {\n            errMsg.append(\"PrincipalToken:isValidAuthorizedServiceToken: Invalid Token=\").\n                   append(unsignedToken).\n                   append(\" : No service name and Authorized service list contains multiple entries\"); \n            LOG.error(errMsg.toString());\n            return false;\n        }\n        \n        return true;\n    }", "signature": "boolean isValidAuthorizedServiceToken(StringBuilder errMsg)", "full_signature": "public boolean isValidAuthorizedServiceToken(StringBuilder errMsg)", "class_method_signature": "PrincipalToken.isValidAuthorizedServiceToken(StringBuilder errMsg)", "testcase": false, "constructor": false, "invocations": ["append", "append", "append", "error", "toString", "append", "append", "append", "error", "toString", "contains", "append", "append", "append", "append", "append", "error", "toString", "size", "append", "append", "append", "error", "toString"]}, "repository": {"repo_id": 73948366, "url": "https://github.com/yahoo/athenz", "stars": 394, "created": "11/16/2016 6:23:08 PM +00:00", "updates": "2020-01-27T15:36:13+00:00", "fork": "False", "license": "licensed"}}