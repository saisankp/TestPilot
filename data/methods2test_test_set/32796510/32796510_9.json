{"test_class": {"identifier": "RegexModifierTest", "superclass": "extends AbstractRegexModifierTest", "interfaces": "", "fields": [], "file": "streamflyer-core/src/test/java/com/github/rwitzel/streamflyer/regex/RegexModifierTest.java"}, "test_case": {"identifier": "testExampleFromHomepage_advancedExample_greedyQuantifierOnDot", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testExampleFromHomepage_advancedExample_greedyQuantifierOnDot() throws Exception {\n\n        // Don't do this! This example uses a greedy quantifier on a dot\n        Modifier myModifier4 = new RegexModifier(\"edit.*stream\", 0, \"modify stream\");\n\n        // test: does not find the nearest match\n        assertNotEquals(\"modify stream modify stream\", modify(\"edit stream edit stream\", myModifier4));\n\n        // modifier with greedy quantifier on whitespace\n        Modifier myModifier5 = new RegexModifier(\"edit\\\\s*stream\", 0, \"modify stream\");\n\n        // test: finds the nearest match\n        assertNotEquals(\"modify stream modify stream\", modify(\"edit stream edit stream\", myModifier5));\n    }", "signature": "void testExampleFromHomepage_advancedExample_greedyQuantifierOnDot()", "full_signature": "@Test public void testExampleFromHomepage_advancedExample_greedyQuantifierOnDot()", "class_method_signature": "RegexModifierTest.testExampleFromHomepage_advancedExample_greedyQuantifierOnDot()", "testcase": true, "constructor": false, "invocations": ["assertNotEquals", "modify", "assertNotEquals", "modify"]}, "focal_class": {"identifier": "RegexModifier", "superclass": "", "interfaces": "implements Modifier", "fields": [{"original_string": "protected ModificationFactory factory;", "modifier": "protected", "type": "ModificationFactory", "declarator": "factory", "var_name": "factory"}, {"original_string": "protected MatchProcessor matchProcessor;", "modifier": "protected", "type": "MatchProcessor", "declarator": "matchProcessor", "var_name": "matchProcessor"}, {"original_string": "protected OnStreamMatcher matcher;", "modifier": "protected", "type": "OnStreamMatcher", "declarator": "matcher", "var_name": "matcher"}, {"original_string": "protected int newNumberOfChars = -1;", "modifier": "protected", "type": "int", "declarator": "newNumberOfChars = -1", "var_name": "newNumberOfChars"}, {"original_string": "private int unseenCharactersToSkip = 0;", "modifier": "private", "type": "int", "declarator": "unseenCharactersToSkip = 0", "var_name": "unseenCharactersToSkip"}], "methods": [{"identifier": "RegexModifier", "parameters": "()", "modifiers": "protected", "return": "", "signature": " RegexModifier()", "full_signature": "protected  RegexModifier()", "class_method_signature": "RegexModifier.RegexModifier()", "testcase": false, "constructor": true}, {"identifier": "RegexModifier", "parameters": "(String regex, int flags, String replacement)", "modifiers": "public", "return": "", "signature": " RegexModifier(String regex, int flags, String replacement)", "full_signature": "public  RegexModifier(String regex, int flags, String replacement)", "class_method_signature": "RegexModifier.RegexModifier(String regex, int flags, String replacement)", "testcase": false, "constructor": true}, {"identifier": "RegexModifier", "parameters": "(String regex, int flags, String replacement, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "modifiers": "public", "return": "", "signature": " RegexModifier(String regex, int flags, String replacement, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "full_signature": "public  RegexModifier(String regex, int flags, String replacement, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "class_method_signature": "RegexModifier.RegexModifier(String regex, int flags, String replacement, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "testcase": false, "constructor": true}, {"identifier": "RegexModifier", "parameters": "(String regex, int flags, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "modifiers": "public", "return": "", "signature": " RegexModifier(String regex, int flags, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "full_signature": "public  RegexModifier(String regex, int flags, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "class_method_signature": "RegexModifier.RegexModifier(String regex, int flags, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "testcase": false, "constructor": true}, {"identifier": "RegexModifier", "parameters": "(OnStreamMatcher matcher, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "modifiers": "public", "return": "", "signature": " RegexModifier(OnStreamMatcher matcher, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "full_signature": "public  RegexModifier(OnStreamMatcher matcher, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "class_method_signature": "RegexModifier.RegexModifier(OnStreamMatcher matcher, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "testcase": false, "constructor": true}, {"identifier": "init", "parameters": "(OnStreamMatcher matcher, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "modifiers": "@SuppressWarnings(\"hiding\") protected", "return": "void", "signature": "void init(OnStreamMatcher matcher, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "full_signature": "@SuppressWarnings(\"hiding\") protected void init(OnStreamMatcher matcher, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "class_method_signature": "RegexModifier.init(OnStreamMatcher matcher, MatchProcessor matchProcessor, int minimumLengthOfLookBehind,\n            int newNumberOfChars)", "testcase": false, "constructor": false}, {"identifier": "modify", "parameters": "(StringBuilder characterBuffer, int firstModifiableCharacterInBuffer,\n            boolean endOfStreamHit)", "modifiers": "@Override public", "return": "AfterModification", "signature": "AfterModification modify(StringBuilder characterBuffer, int firstModifiableCharacterInBuffer,\n            boolean endOfStreamHit)", "full_signature": "@Override public AfterModification modify(StringBuilder characterBuffer, int firstModifiableCharacterInBuffer,\n            boolean endOfStreamHit)", "class_method_signature": "RegexModifier.modify(StringBuilder characterBuffer, int firstModifiableCharacterInBuffer,\n            boolean endOfStreamHit)", "testcase": false, "constructor": false}, {"identifier": "__checkpoint", "parameters": "(Object... checkpointDescription)", "modifiers": "protected", "return": "boolean", "signature": "boolean __checkpoint(Object... checkpointDescription)", "full_signature": "protected boolean __checkpoint(Object... checkpointDescription)", "class_method_signature": "RegexModifier.__checkpoint(Object... checkpointDescription)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "RegexModifier.toString()", "testcase": false, "constructor": false}, {"identifier": "setMatchProcessor", "parameters": "(MatchProcessor matchProcessor)", "modifiers": "public", "return": "void", "signature": "void setMatchProcessor(MatchProcessor matchProcessor)", "full_signature": "public void setMatchProcessor(MatchProcessor matchProcessor)", "class_method_signature": "RegexModifier.setMatchProcessor(MatchProcessor matchProcessor)", "testcase": false, "constructor": false}], "file": "streamflyer-core/src/main/java/com/github/rwitzel/streamflyer/regex/RegexModifier.java"}, "focal_method": {"identifier": "modify", "parameters": "(StringBuilder characterBuffer, int firstModifiableCharacterInBuffer,\n            boolean endOfStreamHit)", "modifiers": "@Override public", "return": "AfterModification", "body": "@Override\n    public AfterModification modify(StringBuilder characterBuffer, int firstModifiableCharacterInBuffer,\n            boolean endOfStreamHit) {\n\n        // the first position we will match from.\n        Integer minFrom = null;\n\n        while (true) {\n\n            // determine the range [minFrom, maxFrom] that will contain the\n            // first character of the matching string\n\n            if (minFrom == null) {\n                minFrom = firstModifiableCharacterInBuffer;\n\n                if (unseenCharactersToSkip > 0) {\n\n                    // is there at least one modifiable character in the buffer?\n                    if (minFrom + unseenCharactersToSkip > characterBuffer.length()) {\n                        // no -> we need more input to skip the characters\n\n                        if (endOfStreamHit) {\n                            // -> stop\n                            return factory.stop(characterBuffer, firstModifiableCharacterInBuffer, endOfStreamHit);\n                        } else {\n                            // -> fetch more input\n                            return factory.fetchMoreInput(0, characterBuffer, firstModifiableCharacterInBuffer,\n                                    endOfStreamHit);\n                        }\n\n                    } else {\n                        // yes -> increase the *minFrom*\n                        minFrom += unseenCharactersToSkip;\n                        unseenCharactersToSkip = 0;\n                    }\n                }\n            }\n\n            // we have to restrict maxFrom in order to prevent that the\n            // requested number of characters increases more and more\n            int maxFrom = firstModifiableCharacterInBuffer + newNumberOfChars;\n\n            // adjust maxFrom if it is bigger than the given buffer\n            if (maxFrom > characterBuffer.length()) {\n                // this is NOT set to characterBuffer.length() -1 by intention\n                // as a regular expression might match on the zero length string\n                // (but with positive look-behind)!\n                maxFrom = characterBuffer.length();\n            }\n\n            // find first match\n            // (as the match processor might have modified the buffer, we reset\n            // the matcher inside the loop instead of outside of the loop)\n            matcher.reset(characterBuffer);\n            boolean matchFound = matcher.findUnlessHitEnd(minFrom, maxFrom);\n\n            if (matchFound) {\n                // we found a match\n\n                // could change this positive match into a negative one\n                // (matcher.requireEnd()) or into a longer one (greedy\n                // operator)?\n                if (matcher.hitEnd() && !endOfStreamHit) {\n                    // (match_open) yes, it could -> we need more input\n\n                    int numberOfCharactersToSkip = matcher.lastFrom() - firstModifiableCharacterInBuffer;\n\n                    // read more input (skip some characters if possible)\n                    AfterModification mod = factory.fetchMoreInput(numberOfCharactersToSkip, characterBuffer,\n                            firstModifiableCharacterInBuffer, endOfStreamHit);\n\n                    assert __checkpoint( //\n                            \"name\", \"match_open\", //\n                            \"minLen\", firstModifiableCharacterInBuffer, //\n                            \"characterBuffer\", characterBuffer, //\n                            \"endOfStreamHit\", endOfStreamHit, //\n                            \"afterModification\", mod);\n\n                    return mod;\n                } else {\n                    // no -> thus we can use this match -> process the match\n\n                    // process the match\n                    MatchResult matchResult = matcher; // .toMatchResult()?\n                    // (I could pass firstModifiableCharacterInBuffer instead of\n                    // minFrom as well)\n                    MatchProcessorResult matchProcessorResult = matchProcessor.process(characterBuffer, minFrom,\n                            matchResult);\n                    minFrom = matchProcessorResult.getFirstModifiableCharacterInBuffer();\n\n                    // match again without skip? (even for minFrom == maxFrom we\n                    // try a match) (minFrom <= maxFrom is needed so that the\n                    // buffer does not increase if the replacement is longer\n                    // than the replaced string, i.e. minFrom > maxFrom means\n                    // that a SKIP is needed)\n                    // (I (rwoo) think an earlier SKIP (minFrom < maxFrom\n                    // instead of minFrom <= maxFrom) would also be possible.\n                    // This has no impact on the matching and only minimal\n                    // impact on the performance)\n                    if (minFrom <= maxFrom && matchProcessorResult.isContinueMatching()) {\n                        // (match_n_continue) no skip needed yet -> continue\n                        // matching on the existing buffer content\n\n                        assert __checkpoint( //\n                                \"name\", \"match_n_continue\", //\n                                \"minLen\", firstModifiableCharacterInBuffer, //\n                                \"characterBuffer\", characterBuffer, //\n                                \"endOfStreamHit\", endOfStreamHit, //\n                                \"minFrom\", minFrom);\n\n                        // We try the next match on the modified input, i.e.\n                        // not match only once -> next loop\n                        continue;\n                    } else {\n\n                        // we shall not continue matching on the\n                        // existing buffer content but skip (keep the buffer\n                        // small)\n\n                        int numberOfCharactersToSkip;\n                        if (minFrom > characterBuffer.length()) {\n                            // this happens when we avoid endless loops after\n                            // we matched an empty string\n                            unseenCharactersToSkip = minFrom - characterBuffer.length();\n                            ZzzAssert.isTrue(unseenCharactersToSkip == 1, \"unseenCharactersToSkip must be one but was \"\n                                    + unseenCharactersToSkip);\n                            numberOfCharactersToSkip = characterBuffer.length() - firstModifiableCharacterInBuffer;\n                        } else {\n                            numberOfCharactersToSkip = minFrom - firstModifiableCharacterInBuffer;\n                        }\n\n                        if (numberOfCharactersToSkip == 0) {\n\n                            // (match_n_refill) there are no characters left in\n                            // the buffer after the replacement ->\n                            // MODIFY_AGAIN_IMMEDIATELY is only thing we can do\n                            // (the match processor implementation must not\n                            // cause an endless loop)\n\n                            // (passing false for endOfStreamHit is ugly!!!)\n                            // we should offer a new method in\n                            // ModificationFactory, something like\n                            // continueAfterModification(...) that chooses the\n                            // appropriate action. the following code is always\n                            // a MODIFY_AGAIN_IMMEDIATELY\n                            AfterModification mod = factory.fetchMoreInput(numberOfCharactersToSkip, characterBuffer,\n                                    firstModifiableCharacterInBuffer, false);\n\n                            assert __checkpoint( //\n                                    \"name\", \"match_n_refill\", //\n                                    \"minLen\", firstModifiableCharacterInBuffer, //\n                                    \"characterBuffer\", characterBuffer, //\n                                    \"endOfStreamHit\", endOfStreamHit, //\n                                    \"afterModification\", mod);\n\n                            return mod;\n                        } else {\n                            // (match_n_skip) there are characters left in\n                            // the buffer -> SKIP\n\n                            AfterModification mod = factory.skipOrStop(numberOfCharactersToSkip, characterBuffer,\n                                    firstModifiableCharacterInBuffer, endOfStreamHit);\n\n                            assert __checkpoint( //\n                                    \"name\", \"match_n_skip\", //\n                                    \"minLen\", firstModifiableCharacterInBuffer, //\n                                    \"characterBuffer\", characterBuffer, //\n                                    \"endOfStreamHit\", endOfStreamHit, //\n                                    \"afterModification\", mod);\n\n                            return mod;\n                        }\n                    }\n\n                }\n            } else {\n                // we haven't found a match\n\n                // By looking for matches (including the empty string) that\n                // start in the range [from, maxFrom], is the end of the buffer\n                // hit?\n                if (matcher.lastFrom() <= maxFrom) {\n                    // yes, the end of the buffer was hit\n\n                    // can we get more input?\n                    if (endOfStreamHit) {\n                        // (nomatch_eos) no, in the entire stream we will not\n                        // found more matches that start in range [from,\n                        // maxFrom] -> skip the characters from range [from,\n                        // maxFrom]\n\n                        int numberOfCharactersToSkip = maxFrom - firstModifiableCharacterInBuffer;\n                        AfterModification mod = factory.skipOrStop(numberOfCharactersToSkip, characterBuffer,\n                                firstModifiableCharacterInBuffer, endOfStreamHit);\n\n                        assert __checkpoint( //\n                                \"name\", \"nomatch_eos\", //\n                                \"minLen\", firstModifiableCharacterInBuffer, //\n                                \"characterBuffer\", characterBuffer, //\n                                \"endOfStreamHit\", endOfStreamHit, //\n                                \"afterModification\", mod);\n\n                        return mod;\n\n                    } else {\n                        // (nomatch_fetch) yes > we should fetch more input\n                        // (because end of stream is not hit yet)\n\n                        // if maxFrom == characterBuffer.length() and lastFrom()\n                        // == maxFrom we cannot decide whether this is really an\n                        // open match or rather a not a match at all. But by\n                        // skipping the characters in front of lastFrom() and\n                        // fetching more input we cannot do anything wrong\n\n                        int numberOfCharactersToSkip = matcher.lastFrom() - firstModifiableCharacterInBuffer;\n                        AfterModification mod = factory.fetchMoreInput(numberOfCharactersToSkip, characterBuffer,\n                                firstModifiableCharacterInBuffer, endOfStreamHit);\n\n                        assert __checkpoint( //\n                                \"name\", \"nomatch_fetch\", //\n                                \"minLen\", firstModifiableCharacterInBuffer, //\n                                \"characterBuffer\", characterBuffer, //\n                                \"endOfStreamHit\", endOfStreamHit, //\n                                \"afterModification\", mod);\n\n                        return mod;\n                    }\n\n                } else { // matcher.lastFrom() == maxFrom + 1\n\n                    // (nomatch_skip) no, we are matching not a single character\n\n                    // -> skip the characters from range [from, maxFrom]\n                    int numberOfCharactersToSkip = maxFrom - firstModifiableCharacterInBuffer;\n                    AfterModification mod = factory.skipOrStop(numberOfCharactersToSkip, characterBuffer,\n                            firstModifiableCharacterInBuffer, endOfStreamHit);\n\n                    assert __checkpoint( //\n                            \"name\", \"nomatch_skip\", //\n                            \"minLen\", firstModifiableCharacterInBuffer, //\n                            \"characterBuffer\", characterBuffer, //\n                            \"endOfStreamHit\", endOfStreamHit, //\n                            \"afterModification\", mod);\n\n                    return mod;\n                }\n            }\n        }\n\n    }", "signature": "AfterModification modify(StringBuilder characterBuffer, int firstModifiableCharacterInBuffer,\n            boolean endOfStreamHit)", "full_signature": "@Override public AfterModification modify(StringBuilder characterBuffer, int firstModifiableCharacterInBuffer,\n            boolean endOfStreamHit)", "class_method_signature": "RegexModifier.modify(StringBuilder characterBuffer, int firstModifiableCharacterInBuffer,\n            boolean endOfStreamHit)", "testcase": false, "constructor": false, "invocations": ["length", "stop", "fetchMoreInput", "length", "length", "reset", "findUnlessHitEnd", "hitEnd", "lastFrom", "fetchMoreInput", "__checkpoint", "process", "getFirstModifiableCharacterInBuffer", "isContinueMatching", "__checkpoint", "length", "length", "isTrue", "length", "fetchMoreInput", "__checkpoint", "skipOrStop", "__checkpoint", "lastFrom", "skipOrStop", "__checkpoint", "lastFrom", "fetchMoreInput", "__checkpoint", "skipOrStop", "__checkpoint"]}, "repository": {"repo_id": 32796510, "url": "https://github.com/rwitzel/streamflyer", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 26, "size": 2880, "license": "licensed"}}