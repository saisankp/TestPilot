{"test_class": {"identifier": "BuildCapabilityProcessTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private BuildCapabilityProcess buildCapabilityProcess = new BuildCapabilityProcess();", "modifier": "private", "type": "BuildCapabilityProcess", "declarator": "buildCapabilityProcess = new BuildCapabilityProcess()", "var_name": "buildCapabilityProcess"}], "file": "component/core/src/test/java/fr/norad/visuwall/core/business/process/capabilities/BuildCapabilityProcessTest.java"}, "test_case": {"identifier": "should_not_return_update_needed_when_no_new_build_in_software", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void should_not_return_update_needed_when_no_new_build_in_software() throws Exception {\n        Project project = initProject(\"42\", false, \"42\", false);\n\n        String[] buildIdToUpdate = buildCapabilityProcess.updateStatusAndReturnBuildsToUpdate(project);\n\n        Assert.assertArrayEquals(new String[] {}, buildIdToUpdate);\n        Assert.assertFalse(project.getLastBuild().isBuilding());\n        Assert.assertEquals(\"42\", project.getLastBuildId());\n        Mockito.verify(buildCapabilityProcess.scheduler, Mockito.times(0)).schedule(Matchers.any(Runnable.class),\n                Matchers.any(Date.class));\n    }", "signature": "void should_not_return_update_needed_when_no_new_build_in_software()", "full_signature": "@Test public void should_not_return_update_needed_when_no_new_build_in_software()", "class_method_signature": "BuildCapabilityProcessTest.should_not_return_update_needed_when_no_new_build_in_software()", "testcase": true, "constructor": false, "invocations": ["initProject", "updateStatusAndReturnBuildsToUpdate", "assertArrayEquals", "assertFalse", "isBuilding", "getLastBuild", "assertEquals", "getLastBuildId", "schedule", "verify", "times", "any", "any"]}, "focal_class": {"identifier": "BuildCapabilityProcess", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(BuildCapabilityProcess.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(BuildCapabilityProcess.class)", "var_name": "LOG"}, {"original_string": "@Autowired\n    TaskScheduler scheduler;", "modifier": "@Autowired", "type": "TaskScheduler", "declarator": "scheduler", "var_name": "scheduler"}], "methods": [{"identifier": "updatePreviousCompletedBuild", "parameters": "(Project project)", "modifiers": "public", "return": "void", "signature": "void updatePreviousCompletedBuild(Project project)", "full_signature": "public void updatePreviousCompletedBuild(Project project)", "class_method_signature": "BuildCapabilityProcess.updatePreviousCompletedBuild(Project project)", "testcase": false, "constructor": false}, {"identifier": "getCreatedWithContentBuild", "parameters": "(Project project, String buildId)", "modifiers": "private", "return": "Build", "signature": "Build getCreatedWithContentBuild(Project project, String buildId)", "full_signature": "private Build getCreatedWithContentBuild(Project project, String buildId)", "class_method_signature": "BuildCapabilityProcess.getCreatedWithContentBuild(Project project, String buildId)", "testcase": false, "constructor": false}, {"identifier": "updateLastNotBuildingId", "parameters": "(Project project)", "modifiers": "public", "return": "void", "signature": "void updateLastNotBuildingId(Project project)", "full_signature": "public void updateLastNotBuildingId(Project project)", "class_method_signature": "BuildCapabilityProcess.updateLastNotBuildingId(Project project)", "testcase": false, "constructor": false}, {"identifier": "updateBuild", "parameters": "(Project project, String buildId)", "modifiers": "public", "return": "void", "signature": "void updateBuild(Project project, String buildId)", "full_signature": "public void updateBuild(Project project, String buildId)", "class_method_signature": "BuildCapabilityProcess.updateBuild(Project project, String buildId)", "testcase": false, "constructor": false}, {"identifier": "updateStatusAndReturnBuildsToUpdate", "parameters": "(Project project)", "modifiers": "public", "return": "String[]", "signature": "String[] updateStatusAndReturnBuildsToUpdate(Project project)", "full_signature": "public String[] updateStatusAndReturnBuildsToUpdate(Project project)", "class_method_signature": "BuildCapabilityProcess.updateStatusAndReturnBuildsToUpdate(Project project)", "testcase": false, "constructor": false}, {"identifier": "getEstimatedFinishTimeRunner", "parameters": "(final Project project, final Build build)", "modifiers": "", "return": "Runnable", "signature": "Runnable getEstimatedFinishTimeRunner(final Project project, final Build build)", "full_signature": " Runnable getEstimatedFinishTimeRunner(final Project project, final Build build)", "class_method_signature": "BuildCapabilityProcess.getEstimatedFinishTimeRunner(final Project project, final Build build)", "testcase": false, "constructor": false}], "file": "component/core/src/main/java/fr/norad/visuwall/core/business/process/capabilities/BuildCapabilityProcess.java"}, "focal_method": {"identifier": "updateStatusAndReturnBuildsToUpdate", "parameters": "(Project project)", "modifiers": "public", "return": "String[]", "body": "public String[] updateStatusAndReturnBuildsToUpdate(Project project) throws ProjectNotFoundException,\n            BuildNotFoundException {\n        try {\n            String lastBuildId = project.getBuildConnection().getLastBuildId(project.getBuildProjectId());\n            boolean lastBuilding = project.getBuildConnection().isBuilding(project.getBuildProjectId(), lastBuildId);\n\n            String previousLastBuildId = project.getLastBuildId();\n            boolean previousBuilding = false;\n            try {\n                previousBuilding = project.getLastBuild().isBuilding();\n            } catch (BuildNotFoundException e) {\n                LOG.debug(\"No lastBuild found to say the project was building before refresh \" + project);\n            }\n\n            Build lastBuild = project.findCreatedBuild(lastBuildId);\n\n            try {\n                if (previousBuilding == false && lastBuilding == false && !lastBuildId.equals(previousLastBuildId)) {\n                    LOG.info(\"there is an already finished new build {}  {}\", lastBuildId, project);\n                    return new String[] { lastBuildId };\n                }\n                if (previousBuilding == false && lastBuilding == true) {\n                    LOG.info(\"Build {} is now running {}\", lastBuild.getBuildId(), project);\n                    Runnable finishTimeRunner = getEstimatedFinishTimeRunner(project, lastBuild);\n                    scheduler.schedule(finishTimeRunner, new Date());\n                }\n                if (previousBuilding == true && lastBuilding == true) {\n                    if (!lastBuildId.equals(previousLastBuildId)) {\n                        LOG.info(\"Previous build {} is over and a new build {} is already running {}\", new Object[] {\n                                previousLastBuildId, lastBuildId, project });\n                        project.getBuilds().get(previousLastBuildId).setEstimatedFinishTime(null);\n                        project.getBuilds().get(previousLastBuildId).setBuilding(false);\n                        Runnable finishTimeRunner = getEstimatedFinishTimeRunner(project, lastBuild);\n                        scheduler.schedule(finishTimeRunner, new Date());\n                        return new String[] { previousLastBuildId };\n                    }\n                    // building is still running\n                }\n\n                if (previousBuilding == true && lastBuilding == false) {\n                    // build is over\n                    project.getBuilds().get(previousLastBuildId).setEstimatedFinishTime(null);\n                    project.getBuilds().get(previousLastBuildId).setBuilding(false);\n                    if (!lastBuildId.equals(previousLastBuildId)) {\n                        LOG.info(\"previous build {} is over and a new build {} is also over {}\", new Object[] {\n                                previousLastBuildId, lastBuildId, project });\n                        return new String[] { previousLastBuildId, lastBuildId };\n                    }\n                    LOG.info(\"Previous build {} is over and no new build \", previousLastBuildId, project);\n                    return new String[] { previousLastBuildId };\n                }\n            } finally {\n                lastBuild.setBuilding(lastBuilding);\n                project.setLastBuildId(lastBuildId);\n            }\n        } catch (BuildIdNotFoundException e) {\n            LOG.debug(\"No last build id found to update project \" + project);\n        }\n        return new String[] {};\n    }", "signature": "String[] updateStatusAndReturnBuildsToUpdate(Project project)", "full_signature": "public String[] updateStatusAndReturnBuildsToUpdate(Project project)", "class_method_signature": "BuildCapabilityProcess.updateStatusAndReturnBuildsToUpdate(Project project)", "testcase": false, "constructor": false, "invocations": ["getLastBuildId", "getBuildConnection", "getBuildProjectId", "isBuilding", "getBuildConnection", "getBuildProjectId", "getLastBuildId", "isBuilding", "getLastBuild", "debug", "findCreatedBuild", "equals", "info", "info", "getBuildId", "getEstimatedFinishTimeRunner", "schedule", "equals", "info", "setEstimatedFinishTime", "get", "getBuilds", "setBuilding", "get", "getBuilds", "getEstimatedFinishTimeRunner", "schedule", "setEstimatedFinishTime", "get", "getBuilds", "setBuilding", "get", "getBuilds", "equals", "info", "info", "setBuilding", "setLastBuildId", "debug"]}, "repository": {"repo_id": 29774200, "url": "https://github.com/n0rad/visuwall", "language": "Java", "is_fork": false, "fork_count": 4, "stargazer_count": 5, "size": 19747, "license": "licensed"}}