{"test_class": {"identifier": "QueueDrainHelperTest", "superclass": "", "interfaces": "", "fields": [], "file": "rxjava/src/test/java/io/reactivex/internal/util/QueueDrainHelperTest.java"}, "test_case": {"identifier": "drainMaxLoopMissingBackpressureWithResource", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void drainMaxLoopMissingBackpressureWithResource() {\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n        ts.onSubscribe(new BooleanSubscription());\n\n        QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() {\n            @Override\n            public boolean cancelled() {\n                return false;\n            }\n\n            @Override\n            public boolean done() {\n                return false;\n            }\n\n            @Override\n            public Throwable error() {\n                return null;\n            }\n\n            @Override\n            public boolean enter() {\n                return true;\n            }\n\n            @Override\n            public long requested() {\n                return 0;\n            }\n\n            @Override\n            public long produced(long n) {\n                return 0;\n            }\n\n            @Override\n            public int leave(int m) {\n                return 0;\n            }\n\n            @Override\n            public boolean accept(Subscriber<? super Integer> a, Integer v) {\n                return false;\n            }\n        };\n\n        SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);\n        q.offer(1);\n\n        Disposable d = Disposables.empty();\n\n        QueueDrainHelper.drainMaxLoop(q, ts, false, d, qd);\n\n        ts.assertFailure(MissingBackpressureException.class);\n\n        assertTrue(d.isDisposed());\n    }", "signature": "void drainMaxLoopMissingBackpressureWithResource()", "full_signature": "@Test public void drainMaxLoopMissingBackpressureWithResource()", "class_method_signature": "QueueDrainHelperTest.drainMaxLoopMissingBackpressureWithResource()", "testcase": true, "constructor": false, "invocations": ["onSubscribe", "offer", "empty", "drainMaxLoop", "assertFailure", "assertTrue", "isDisposed"]}, "focal_class": {"identifier": "QueueDrainHelper", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final long COMPLETED_MASK = 0x8000000000000000L;", "modifier": "static final", "type": "long", "declarator": "COMPLETED_MASK = 0x8000000000000000L", "var_name": "COMPLETED_MASK"}, {"original_string": "static final long REQUESTED_MASK = 0x7FFFFFFFFFFFFFFFL;", "modifier": "static final", "type": "long", "declarator": "REQUESTED_MASK = 0x7FFFFFFFFFFFFFFFL", "var_name": "REQUESTED_MASK"}], "methods": [{"identifier": "QueueDrainHelper", "parameters": "()", "modifiers": "private", "return": "", "signature": " QueueDrainHelper()", "full_signature": "private  QueueDrainHelper()", "class_method_signature": "QueueDrainHelper.QueueDrainHelper()", "testcase": false, "constructor": true}, {"identifier": "drainMaxLoop", "parameters": "(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,\n            Disposable dispose, QueueDrain<T, U> qd)", "modifiers": "public static", "return": "void", "signature": "void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,\n            Disposable dispose, QueueDrain<T, U> qd)", "full_signature": "public static void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,\n            Disposable dispose, QueueDrain<T, U> qd)", "class_method_signature": "QueueDrainHelper.drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,\n            Disposable dispose, QueueDrain<T, U> qd)", "testcase": false, "constructor": false}, {"identifier": "checkTerminated", "parameters": "(boolean d, boolean empty,\n            Subscriber<?> s, boolean delayError, SimpleQueue<?> q, QueueDrain<T, U> qd)", "modifiers": "public static", "return": "boolean", "signature": "boolean checkTerminated(boolean d, boolean empty,\n            Subscriber<?> s, boolean delayError, SimpleQueue<?> q, QueueDrain<T, U> qd)", "full_signature": "public static boolean checkTerminated(boolean d, boolean empty,\n            Subscriber<?> s, boolean delayError, SimpleQueue<?> q, QueueDrain<T, U> qd)", "class_method_signature": "QueueDrainHelper.checkTerminated(boolean d, boolean empty,\n            Subscriber<?> s, boolean delayError, SimpleQueue<?> q, QueueDrain<T, U> qd)", "testcase": false, "constructor": false}, {"identifier": "drainLoop", "parameters": "(SimplePlainQueue<T> q, Observer<? super U> a, boolean delayError, Disposable dispose, ObservableQueueDrain<T, U> qd)", "modifiers": "public static", "return": "void", "signature": "void drainLoop(SimplePlainQueue<T> q, Observer<? super U> a, boolean delayError, Disposable dispose, ObservableQueueDrain<T, U> qd)", "full_signature": "public static void drainLoop(SimplePlainQueue<T> q, Observer<? super U> a, boolean delayError, Disposable dispose, ObservableQueueDrain<T, U> qd)", "class_method_signature": "QueueDrainHelper.drainLoop(SimplePlainQueue<T> q, Observer<? super U> a, boolean delayError, Disposable dispose, ObservableQueueDrain<T, U> qd)", "testcase": false, "constructor": false}, {"identifier": "checkTerminated", "parameters": "(boolean d, boolean empty,\n            Observer<?> s, boolean delayError, SimpleQueue<?> q, Disposable disposable, ObservableQueueDrain<T, U> qd)", "modifiers": "public static", "return": "boolean", "signature": "boolean checkTerminated(boolean d, boolean empty,\n            Observer<?> s, boolean delayError, SimpleQueue<?> q, Disposable disposable, ObservableQueueDrain<T, U> qd)", "full_signature": "public static boolean checkTerminated(boolean d, boolean empty,\n            Observer<?> s, boolean delayError, SimpleQueue<?> q, Disposable disposable, ObservableQueueDrain<T, U> qd)", "class_method_signature": "QueueDrainHelper.checkTerminated(boolean d, boolean empty,\n            Observer<?> s, boolean delayError, SimpleQueue<?> q, Disposable disposable, ObservableQueueDrain<T, U> qd)", "testcase": false, "constructor": false}, {"identifier": "createQueue", "parameters": "(int capacityHint)", "modifiers": "public static", "return": "SimpleQueue<T>", "signature": "SimpleQueue<T> createQueue(int capacityHint)", "full_signature": "public static SimpleQueue<T> createQueue(int capacityHint)", "class_method_signature": "QueueDrainHelper.createQueue(int capacityHint)", "testcase": false, "constructor": false}, {"identifier": "request", "parameters": "(Subscription s, int prefetch)", "modifiers": "public static", "return": "void", "signature": "void request(Subscription s, int prefetch)", "full_signature": "public static void request(Subscription s, int prefetch)", "class_method_signature": "QueueDrainHelper.request(Subscription s, int prefetch)", "testcase": false, "constructor": false}, {"identifier": "postCompleteRequest", "parameters": "(long n,\n                                                  Subscriber<? super T> actual,\n                                                  Queue<T> queue,\n                                                  AtomicLong state,\n                                                  BooleanSupplier isCancelled)", "modifiers": "public static", "return": "boolean", "signature": "boolean postCompleteRequest(long n,\n                                                  Subscriber<? super T> actual,\n                                                  Queue<T> queue,\n                                                  AtomicLong state,\n                                                  BooleanSupplier isCancelled)", "full_signature": "public static boolean postCompleteRequest(long n,\n                                                  Subscriber<? super T> actual,\n                                                  Queue<T> queue,\n                                                  AtomicLong state,\n                                                  BooleanSupplier isCancelled)", "class_method_signature": "QueueDrainHelper.postCompleteRequest(long n,\n                                                  Subscriber<? super T> actual,\n                                                  Queue<T> queue,\n                                                  AtomicLong state,\n                                                  BooleanSupplier isCancelled)", "testcase": false, "constructor": false}, {"identifier": "isCancelled", "parameters": "(BooleanSupplier cancelled)", "modifiers": "static", "return": "boolean", "signature": "boolean isCancelled(BooleanSupplier cancelled)", "full_signature": "static boolean isCancelled(BooleanSupplier cancelled)", "class_method_signature": "QueueDrainHelper.isCancelled(BooleanSupplier cancelled)", "testcase": false, "constructor": false}, {"identifier": "postCompleteDrain", "parameters": "(long n,\n                                         Subscriber<? super T> actual,\n                                         Queue<T> queue,\n                                         AtomicLong state,\n                                         BooleanSupplier isCancelled)", "modifiers": "static", "return": "boolean", "signature": "boolean postCompleteDrain(long n,\n                                         Subscriber<? super T> actual,\n                                         Queue<T> queue,\n                                         AtomicLong state,\n                                         BooleanSupplier isCancelled)", "full_signature": "static boolean postCompleteDrain(long n,\n                                         Subscriber<? super T> actual,\n                                         Queue<T> queue,\n                                         AtomicLong state,\n                                         BooleanSupplier isCancelled)", "class_method_signature": "QueueDrainHelper.postCompleteDrain(long n,\n                                         Subscriber<? super T> actual,\n                                         Queue<T> queue,\n                                         AtomicLong state,\n                                         BooleanSupplier isCancelled)", "testcase": false, "constructor": false}, {"identifier": "postComplete", "parameters": "(Subscriber<? super T> actual,\n                                        Queue<T> queue,\n                                        AtomicLong state,\n                                        BooleanSupplier isCancelled)", "modifiers": "public static", "return": "void", "signature": "void postComplete(Subscriber<? super T> actual,\n                                        Queue<T> queue,\n                                        AtomicLong state,\n                                        BooleanSupplier isCancelled)", "full_signature": "public static void postComplete(Subscriber<? super T> actual,\n                                        Queue<T> queue,\n                                        AtomicLong state,\n                                        BooleanSupplier isCancelled)", "class_method_signature": "QueueDrainHelper.postComplete(Subscriber<? super T> actual,\n                                        Queue<T> queue,\n                                        AtomicLong state,\n                                        BooleanSupplier isCancelled)", "testcase": false, "constructor": false}], "file": "rxjava/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java"}, "focal_method": {"identifier": "drainMaxLoop", "parameters": "(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,\n            Disposable dispose, QueueDrain<T, U> qd)", "modifiers": "public static", "return": "void", "body": "public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,\n            Disposable dispose, QueueDrain<T, U> qd) {\n        int missed = 1;\n\n        for (;;) {\n            for (;;) {\n                boolean d = qd.done();\n\n                T v = q.poll();\n\n                boolean empty = v == null;\n\n                if (checkTerminated(d, empty, a, delayError, q, qd)) {\n                    if (dispose != null) {\n                        dispose.dispose();\n                    }\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                long r = qd.requested();\n                if (r != 0L) {\n                    if (qd.accept(a, v)) {\n                        if (r != Long.MAX_VALUE) {\n                            qd.produced(1);\n                        }\n                    }\n                } else {\n                    q.clear();\n                    if (dispose != null) {\n                        dispose.dispose();\n                    }\n                    a.onError(new MissingBackpressureException(\"Could not emit value due to lack of requests.\"));\n                    return;\n                }\n            }\n\n            missed = qd.leave(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }", "signature": "void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,\n            Disposable dispose, QueueDrain<T, U> qd)", "full_signature": "public static void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,\n            Disposable dispose, QueueDrain<T, U> qd)", "class_method_signature": "QueueDrainHelper.drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,\n            Disposable dispose, QueueDrain<T, U> qd)", "testcase": false, "constructor": false, "invocations": ["done", "poll", "checkTerminated", "dispose", "requested", "accept", "produced", "clear", "dispose", "onError", "leave"]}, "repository": {"repo_id": 128274093, "url": "https://github.com/artem-zinnatullin/error-prone-performance", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 13, "size": 22484, "license": "licensed"}}