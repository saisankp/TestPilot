{"test_class": {"identifier": "PagedListTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private TestExecutor mMainThread = new TestExecutor();", "modifier": "private", "type": "TestExecutor", "declarator": "mMainThread = new TestExecutor()", "var_name": "mMainThread"}, {"original_string": "private TestExecutor mBackgroundThread = new TestExecutor();", "modifier": "private", "type": "TestExecutor", "declarator": "mBackgroundThread = new TestExecutor()", "var_name": "mBackgroundThread"}, {"original_string": "private TestDataSource mDataSource = new TestDataSource();", "modifier": "private", "type": "TestDataSource", "declarator": "mDataSource = new TestDataSource()", "var_name": "mDataSource"}, {"original_string": "private PagedList.ChangeCallback mChangeCallback = Mockito.mock(PagedList.ChangeCallback.class);", "modifier": "private", "type": "PagedList.ChangeCallback", "declarator": "mChangeCallback = Mockito.mock(PagedList.ChangeCallback.class)", "var_name": "mChangeCallback"}], "file": "paging/common/src/test/java/android/arch/util/paging/PagedListTest.java"}, "test_case": {"identifier": "initializeFrom", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void initializeFrom() {\n        PagedList<User> pagedList = createPagedList(20, 20);\n        pagedList.triggerInitialLoad(null);\n        drain();\n    }", "signature": "void initializeFrom()", "full_signature": "@Test public void initializeFrom()", "class_method_signature": "PagedListTest.initializeFrom()", "testcase": true, "constructor": false, "invocations": ["createPagedList", "triggerInitialLoad", "drain"]}, "focal_class": {"identifier": "PagedList", "superclass": "extends PagerBase<Type>", "interfaces": "", "fields": [{"original_string": "private static final int INVALID_DATA_POSITION = -1;", "modifier": "private static final", "type": "int", "declarator": "INVALID_DATA_POSITION = -1", "var_name": "INVALID_DATA_POSITION"}, {"original_string": "private int mMinTarget = 0;", "modifier": "private", "type": "int", "declarator": "mMinTarget = 0", "var_name": "mMinTarget"}, {"original_string": "private int mMaxTarget = 0;", "modifier": "private", "type": "int", "declarator": "mMaxTarget = 0", "var_name": "mMaxTarget"}, {"original_string": "private volatile int mInterestedKeyOffset = -1;", "modifier": "private volatile", "type": "int", "declarator": "mInterestedKeyOffset = -1", "var_name": "mInterestedKeyOffset"}, {"original_string": "private int mAnchor = 0;", "modifier": "private", "type": "int", "declarator": "mAnchor = 0", "var_name": "mAnchor"}, {"original_string": "private DataSource<Object, Type> mDataSource;", "modifier": "private", "type": "DataSource<Object, Type>", "declarator": "mDataSource", "var_name": "mDataSource"}, {"original_string": "private SafeIterableMap<ChangeCallback,\n                ChangeCallbackWrapper> mCallbacks = new SafeIterableMap<>();", "modifier": "private", "type": "SafeIterableMap<ChangeCallback,\n                ChangeCallbackWrapper>", "declarator": "mCallbacks = new SafeIterableMap<>()", "var_name": "mCallbacks"}], "methods": [{"identifier": "PagedList", "parameters": "(@NonNull DataSource<Key, Type> dataSource,\n            @NonNull Executor mainThreadExecutor, @NonNull Executor backgroundThreadExecutor,\n            @NonNull ListConfig config)", "modifiers": "@WorkerThread public", "return": "<Key>", "signature": "<Key> PagedList(@NonNull DataSource<Key, Type> dataSource,\n            @NonNull Executor mainThreadExecutor, @NonNull Executor backgroundThreadExecutor,\n            @NonNull ListConfig config)", "full_signature": "@WorkerThread public <Key> PagedList(@NonNull DataSource<Key, Type> dataSource,\n            @NonNull Executor mainThreadExecutor, @NonNull Executor backgroundThreadExecutor,\n            @NonNull ListConfig config)", "class_method_signature": "PagedList.PagedList(@NonNull DataSource<Key, Type> dataSource,\n            @NonNull Executor mainThreadExecutor, @NonNull Executor backgroundThreadExecutor,\n            @NonNull ListConfig config)", "testcase": false, "constructor": true}, {"identifier": "get", "parameters": "(int index)", "modifiers": "@Override @NonNull public", "return": "Type", "signature": "Type get(int index)", "full_signature": "@Override @NonNull public Type get(int index)", "class_method_signature": "PagedList.get(int index)", "testcase": false, "constructor": false}, {"identifier": "access", "parameters": "(int index)", "modifiers": "@Override @NonNull public", "return": "Type", "signature": "Type access(int index)", "full_signature": "@Override @NonNull public Type access(int index)", "class_method_signature": "PagedList.access(int index)", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int size()", "full_signature": "@Override public int size()", "class_method_signature": "PagedList.size()", "testcase": false, "constructor": false}, {"identifier": "triggerInitialLoad", "parameters": "(final Key initialLoadKey)", "modifiers": "@MainThread public", "return": "void", "signature": "void triggerInitialLoad(final Key initialLoadKey)", "full_signature": "@MainThread public void triggerInitialLoad(final Key initialLoadKey)", "class_method_signature": "PagedList.triggerInitialLoad(final Key initialLoadKey)", "testcase": false, "constructor": false}, {"identifier": "initializeFrom", "parameters": "(PagedList<Type> old)", "modifiers": "@WorkerThread public", "return": "boolean", "signature": "boolean initializeFrom(PagedList<Type> old)", "full_signature": "@WorkerThread public boolean initializeFrom(PagedList<Type> old)", "class_method_signature": "PagedList.initializeFrom(PagedList<Type> old)", "testcase": false, "constructor": false}, {"identifier": "setInitialDataAndDispatch", "parameters": "(List<Type> items)", "modifiers": "private", "return": "void", "signature": "void setInitialDataAndDispatch(List<Type> items)", "full_signature": "private void setInitialDataAndDispatch(List<Type> items)", "class_method_signature": "PagedList.setInitialDataAndDispatch(List<Type> items)", "testcase": false, "constructor": false}, {"identifier": "addCallback", "parameters": "(ChangeCallback callback)", "modifiers": "@SuppressWarnings(\"WeakerAccess\") public", "return": "void", "signature": "void addCallback(ChangeCallback callback)", "full_signature": "@SuppressWarnings(\"WeakerAccess\") public void addCallback(ChangeCallback callback)", "class_method_signature": "PagedList.addCallback(ChangeCallback callback)", "testcase": false, "constructor": false}, {"identifier": "removeCallback", "parameters": "(ChangeCallback callback)", "modifiers": "@SuppressWarnings(\"WeakerAccess\") public", "return": "void", "signature": "void removeCallback(ChangeCallback callback)", "full_signature": "@SuppressWarnings(\"WeakerAccess\") public void removeCallback(ChangeCallback callback)", "class_method_signature": "PagedList.removeCallback(ChangeCallback callback)", "testcase": false, "constructor": false}, {"identifier": "dispatchChange", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void dispatchChange()", "full_signature": "private void dispatchChange()", "class_method_signature": "PagedList.dispatchChange()", "testcase": false, "constructor": false}, {"identifier": "onItemsPrepended", "parameters": "(int count)", "modifiers": "@Override", "return": "void", "signature": "void onItemsPrepended(int count)", "full_signature": "@Override void onItemsPrepended(int count)", "class_method_signature": "PagedList.onItemsPrepended(int count)", "testcase": false, "constructor": false}, {"identifier": "onItemsAppended", "parameters": "(int count)", "modifiers": "@Override", "return": "void", "signature": "void onItemsAppended(int count)", "full_signature": "@Override void onItemsAppended(int count)", "class_method_signature": "PagedList.onItemsAppended(int count)", "testcase": false, "constructor": false}, {"identifier": "loadBeforeIfNeeded", "parameters": "()", "modifiers": "@Override", "return": "void", "signature": "void loadBeforeIfNeeded()", "full_signature": "@Override void loadBeforeIfNeeded()", "class_method_signature": "PagedList.loadBeforeIfNeeded()", "testcase": false, "constructor": false}, {"identifier": "loadAfterIfNeeded", "parameters": "()", "modifiers": "@Override", "return": "void", "signature": "void loadAfterIfNeeded()", "full_signature": "@Override void loadAfterIfNeeded()", "class_method_signature": "PagedList.loadAfterIfNeeded()", "testcase": false, "constructor": false}, {"identifier": "loadBeforeImpl", "parameters": "(int position, Type item)", "modifiers": "@Nullable @Override", "return": "List<Type>", "signature": "List<Type> loadBeforeImpl(int position, Type item)", "full_signature": "@Nullable @Override List<Type> loadBeforeImpl(int position, Type item)", "class_method_signature": "PagedList.loadBeforeImpl(int position, Type item)", "testcase": false, "constructor": false}, {"identifier": "loadAfterImpl", "parameters": "(int position, Type item)", "modifiers": "@Nullable @Override", "return": "List<Type>", "signature": "List<Type> loadAfterImpl(int position, Type item)", "full_signature": "@Nullable @Override List<Type> loadAfterImpl(int position, Type item)", "class_method_signature": "PagedList.loadAfterImpl(int position, Type item)", "testcase": false, "constructor": false}], "file": "paging/common/src/main/java/android/arch/util/paging/PagedList.java"}, "focal_method": {"identifier": "initializeFrom", "parameters": "(PagedList<Type> old)", "modifiers": "@WorkerThread public", "return": "boolean", "body": "@WorkerThread\n    public boolean initializeFrom(PagedList<Type> old) {\n        // Note: even though old may be actively used on the foreground thread, we carefully only\n        // access parts that are immutable once old is invalid:\n        // mAnchor, and mItems (since no further prepends/appends can occur)\n\n        int targetIndex = (old.mAnchor + old.mInterestedKeyOffset);\n        int loadAfterIndex = Math.max(0, targetIndex - mConfig.mPageSize / 2) - 1;\n\n        Object loadAfterKey = null;\n        if (loadAfterIndex >= 0) {\n            Type loadAfterItem = old.mItems.get(loadAfterIndex);\n            loadAfterKey = mDataSource.getKey(loadAfterItem);\n        }\n\n        List<Type> initialData =\n                mDataSource.loadAfterInitial(loadAfterKey, mConfig.mPageSize);\n        if (initialData != null) {\n            setInitialDataAndDispatch(initialData);\n            mInitialized = true;\n            return true;\n        } else {\n            freeze();\n            return false;\n        }\n    }", "signature": "boolean initializeFrom(PagedList<Type> old)", "full_signature": "@WorkerThread public boolean initializeFrom(PagedList<Type> old)", "class_method_signature": "PagedList.initializeFrom(PagedList<Type> old)", "testcase": false, "constructor": false, "invocations": ["max", "get", "getKey", "loadAfterInitial", "setInitialDataAndDispatch", "freeze"]}, "repository": {"repo_id": 104025215, "url": "https://github.com/Rayduh/support", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 8, "size": 253405, "license": "licensed"}}