{"test_class": {"identifier": "TimeWarpEditDistanceTest", "superclass": "", "interfaces": "", "fields": [], "file": "JAICore/jaicore-basic/src/test/java/ai/libs/jaicore/basic/metric/TimeWarpEditDistanceTest.java"}, "test_case": {"identifier": "testCorrectnessForDistanceCalculation", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testCorrectnessForDistanceCalculation() {\n\t\t// Input.\n\t\tdouble[] timeSeries1 = { 1, 1, 1, 1, 1, 1 };\n\t\tdouble[] timeSeries2 = { 1, 1, 1, 1, 1, 1 };\n\t\t// Expectation.\n\t\tdouble expectation = 0;\n\n\t\tdouble lambda = 1.0;\n\t\tdouble nu = 0.001;\n\t\tTimeWarpEditDistance twed = new TimeWarpEditDistance(lambda, nu);\n\t\tdouble distance = twed.distance(timeSeries1, timeSeries2);\n\n\t\tassertEquals(expectation, distance, 0);\n\t}", "signature": "void testCorrectnessForDistanceCalculation()", "full_signature": "@Test public void testCorrectnessForDistanceCalculation()", "class_method_signature": "TimeWarpEditDistanceTest.testCorrectnessForDistanceCalculation()", "testcase": true, "constructor": false, "invocations": ["distance", "assertEquals"]}, "focal_class": {"identifier": "TimeWarpEditDistance", "superclass": "", "interfaces": "implements ITimeseriesDistanceMetric", "fields": [{"original_string": "private double nu;", "modifier": "private", "type": "double", "declarator": "nu", "var_name": "nu"}, {"original_string": "private double lambda;", "modifier": "private", "type": "double", "declarator": "lambda", "var_name": "lambda"}, {"original_string": "private IScalarDistance d;", "modifier": "private", "type": "IScalarDistance", "declarator": "d", "var_name": "d"}], "methods": [{"identifier": "TimeWarpEditDistance", "parameters": "(final double lambda, final double nu, final IScalarDistance d)", "modifiers": "public", "return": "", "signature": " TimeWarpEditDistance(final double lambda, final double nu, final IScalarDistance d)", "full_signature": "public  TimeWarpEditDistance(final double lambda, final double nu, final IScalarDistance d)", "class_method_signature": "TimeWarpEditDistance.TimeWarpEditDistance(final double lambda, final double nu, final IScalarDistance d)", "testcase": false, "constructor": true}, {"identifier": "TimeWarpEditDistance", "parameters": "(final double lambda, final double nu)", "modifiers": "public", "return": "", "signature": " TimeWarpEditDistance(final double lambda, final double nu)", "full_signature": "public  TimeWarpEditDistance(final double lambda, final double nu)", "class_method_signature": "TimeWarpEditDistance.TimeWarpEditDistance(final double lambda, final double nu)", "testcase": false, "constructor": true}, {"identifier": "distance", "parameters": "(final double[] a, final double[] tA, final double[] b, final double[] tB)", "modifiers": "@Override public", "return": "double", "signature": "double distance(final double[] a, final double[] tA, final double[] b, final double[] tB)", "full_signature": "@Override public double distance(final double[] a, final double[] tA, final double[] b, final double[] tB)", "class_method_signature": "TimeWarpEditDistance.distance(final double[] a, final double[] tA, final double[] b, final double[] tB)", "testcase": false, "constructor": false}], "file": "JAICore/jaicore-basic/src/main/java/ai/libs/jaicore/basic/metric/TimeWarpEditDistance.java"}, "focal_method": {"identifier": "distance", "parameters": "(final double[] a, final double[] tA, final double[] b, final double[] tB)", "modifiers": "@Override public", "return": "double", "body": "@Override\n\tpublic double distance(final double[] a, final double[] tA, final double[] b, final double[] tB) {\n\t\tint n = a.length;\n\t\tint m = b.length;\n\n\t\t// DP[0..n, 0..m]\n\t\tdouble[][] dp = new double[n + 1][m + 1];\n\n\t\t// declare A[0] := 0, tA[0] := 0\n\t\t// declare B[0] := 0, tB[0] := 0\n\t\t// Note: Zero pad A and B, i.e. when referencing A[i] use A[i-1], when\n\t\t// referencing A[i-1] use A[i-2]\n\n\t\t// Dynamic Programming initialization.\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdp[i][0] = Double.MAX_VALUE;\n\t\t}\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tdp[0][i] = Double.MAX_VALUE;\n\t\t}\n\t\tdp[0][0] = 0d;\n\n\t\t// Dynamic programming.\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\n\t\t\t\t// Cost for Deletion in A.\n\t\t\t\tdouble c1;\n\t\t\t\t// Cost for Deletion in B.\n\t\t\t\tdouble c2;\n\t\t\t\t// Cost for a match.\n\t\t\t\tdouble c3;\n\n\t\t\t\tif (i == 1 && j == 1) {\n\t\t\t\t\t// Substitute A[i-2] with 0 and B[j-2] with 0.\n\t\t\t\t\tc1 = dp[i - 1][j] + this.d.distance(0, a[i - 1]) + this.nu * tA[i - 1] + this.lambda;\n\t\t\t\t\tc2 = dp[i][j - 1] + this.d.distance(0, b[j - 1]) + this.nu * tB[j - 1] + this.lambda;\n\t\t\t\t\tc3 = dp[i - 1][j - 1] + this.d.distance(a[i - 1], b[i - 1]) + this.nu * Math.abs(tA[i - 1] - tB[j - 1]);\n\t\t\t\t} else if (i == 1) {\n\t\t\t\t\t// Substitute A[i-2] with 0.\n\t\t\t\t\tc1 = dp[i - 1][j] + this.d.distance(0, a[i - 1]) + this.nu * tA[i - 1] + this.lambda;\n\t\t\t\t\tc2 = dp[i][j - 1] + this.d.distance(b[j - 2], b[j - 1]) + this.nu * (tB[j - 1] - tB[j - 2]) + this.lambda;\n\t\t\t\t\tc3 = dp[i - 1][j - 1] + this.d.distance(a[i - 1], b[i - 1]) + this.d.distance(0, b[j - 2]) + this.nu * (Math.abs(tA[i - 1] - tB[j - 1]) + tB[j - 2]);\n\t\t\t\t} else if (j == 1) {\n\t\t\t\t\t// Substitute B[j-2] with 0.\n\t\t\t\t\tc1 = dp[i - 1][j] + this.d.distance(a[i - 2], a[i - 1]) + this.nu * (tA[i - 1] - tA[i - 2]) + this.lambda;\n\t\t\t\t\tc2 = dp[i][j - 1] + this.d.distance(0, b[j - 1]) + this.nu * tB[j - 1] + this.lambda;\n\t\t\t\t\tc3 = dp[i - 1][j - 1] + this.d.distance(a[i - 1], b[i - 1]) + this.d.distance(a[i - 2], 0) + this.nu * (Math.abs(tA[i - 1] - tB[j - 1]) + tA[i - 2]);\n\t\t\t\t} else {\n\t\t\t\t\t// No substitution.\n\t\t\t\t\tc1 = dp[i - 1][j] + this.d.distance(a[i - 2], a[i - 1]) + this.nu * (tA[i - 1] - tA[i - 2]) + this.lambda;\n\t\t\t\t\tc2 = dp[i][j - 1] + this.d.distance(b[j - 2], b[j - 1]) + this.nu * (tB[j - 1] - tB[j - 2]) + this.lambda;\n\t\t\t\t\tc3 = dp[i - 1][j - 1] + this.d.distance(a[i - 1], b[i - 1]) + this.d.distance(a[i - 2], b[j - 2]) + this.nu * (Math.abs(tA[i - 1] - tB[j - 1]) + Math.abs(tA[i - 2] - tB[j - 2]));\n\t\t\t\t}\n\n\t\t\t\t// Minimum cost.\n\t\t\t\tdouble minimum = Math.min(c1, Math.min(c2, c3));\n\t\t\t\tdp[i][j] = minimum;\n\t\t\t}\n\t\t}\n\n\t\treturn dp[n][m];\n\t}", "signature": "double distance(final double[] a, final double[] tA, final double[] b, final double[] tB)", "full_signature": "@Override public double distance(final double[] a, final double[] tA, final double[] b, final double[] tB)", "class_method_signature": "TimeWarpEditDistance.distance(final double[] a, final double[] tA, final double[] b, final double[] tB)", "testcase": false, "constructor": false, "invocations": ["distance", "distance", "distance", "abs", "distance", "distance", "distance", "distance", "abs", "distance", "distance", "distance", "distance", "abs", "distance", "distance", "distance", "distance", "abs", "abs", "min", "min"]}, "repository": {"repo_id": 95635499, "url": "https://github.com/fmohr/AILibs", "language": "Java", "is_fork": false, "fork_count": 26, "stargazer_count": 25, "size": 155873, "license": "licensed"}}