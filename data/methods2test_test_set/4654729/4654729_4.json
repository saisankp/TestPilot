{"test_class": {"identifier": "BindingConditionsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "ClassLoader classLoader = Thread.currentThread().getContextClassLoader();", "modifier": "", "type": "ClassLoader", "declarator": "classLoader = Thread.currentThread().getContextClassLoader()", "var_name": "classLoader"}, {"original_string": "BindingCondition<Object> nonConfirming = new BindingCondition<Object>() {\n        \n        @Override\n        public boolean fulfilled(ClassInjector injector, Class<Object> type, Map<String, Class<? extends Object>[]> inheritanceTree, Annotation qualifier,\n                ClassLoader classLoader) {\n            return false;\n        }\n        \n    };", "modifier": "", "type": "BindingCondition<Object>", "declarator": "nonConfirming = new BindingCondition<Object>() {\n        \n        @Override\n        public boolean fulfilled(ClassInjector injector, Class<Object> type, Map<String, Class<? extends Object>[]> inheritanceTree, Annotation qualifier,\n                ClassLoader classLoader) {\n            return false;\n        }\n        \n    }", "var_name": "nonConfirming"}, {"original_string": "BindingCondition<Object> confirming = new BindingCondition<Object>() {\n        \n        @Override\n        public boolean fulfilled(ClassInjector injector, Class<Object> type, Map<String, Class<? extends Object>[]> inheritanceTree, Annotation qualifier,\n                ClassLoader classLoader) {\n            return true;\n        }\n        \n    };", "modifier": "", "type": "BindingCondition<Object>", "declarator": "confirming = new BindingCondition<Object>() {\n        \n        @Override\n        public boolean fulfilled(ClassInjector injector, Class<Object> type, Map<String, Class<? extends Object>[]> inheritanceTree, Annotation qualifier,\n                ClassLoader classLoader) {\n            return true;\n        }\n        \n    }", "var_name": "confirming"}], "file": "config-builder/src/test/java/com/github/jsr330/spi/config/builder/BindingConditionsTest.java"}, "test_case": {"identifier": "isNamedIgnoringCase", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void isNamedIgnoringCase() {\n        assertTrue(BindingConditions.isNamedIgnoringCase(Tire.class, \"spare\").fulfilled(null, Tire.class, null, new Named() {\n            \n            @Override\n            public Class<? extends Annotation> annotationType() {\n                return Named.class;\n            }\n            \n            @Override\n            public String value() {\n                return \"SPARE\";\n            }\n            \n        }, classLoader));\n    }", "signature": "void isNamedIgnoringCase()", "full_signature": "@Test public void isNamedIgnoringCase()", "class_method_signature": "BindingConditionsTest.isNamedIgnoringCase()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "fulfilled", "isNamedIgnoringCase"]}, "focal_class": {"identifier": "BindingConditions", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "annotationIsPresent", "parameters": "(Class<? extends T> type, Class<? extends Annotation> annotation)", "modifiers": "@SuppressWarnings(\"unchecked\") public static", "return": "BindingCondition<T>", "signature": "BindingCondition<T> annotationIsPresent(Class<? extends T> type, Class<? extends Annotation> annotation)", "full_signature": "@SuppressWarnings(\"unchecked\") public static BindingCondition<T> annotationIsPresent(Class<? extends T> type, Class<? extends Annotation> annotation)", "class_method_signature": "BindingConditions.annotationIsPresent(Class<? extends T> type, Class<? extends Annotation> annotation)", "testcase": false, "constructor": false}, {"identifier": "qualifierIs", "parameters": "(Class<? extends T> type, final Class<? extends Annotation> expectedQualifier)", "modifiers": "public static", "return": "BindingCondition<T>", "signature": "BindingCondition<T> qualifierIs(Class<? extends T> type, final Class<? extends Annotation> expectedQualifier)", "full_signature": "public static BindingCondition<T> qualifierIs(Class<? extends T> type, final Class<? extends Annotation> expectedQualifier)", "class_method_signature": "BindingConditions.qualifierIs(Class<? extends T> type, final Class<? extends Annotation> expectedQualifier)", "testcase": false, "constructor": false}, {"identifier": "isNamed", "parameters": "(Class<? extends T> type, final CharSequence value)", "modifiers": "public static", "return": "BindingCondition<T>", "signature": "BindingCondition<T> isNamed(Class<? extends T> type, final CharSequence value)", "full_signature": "public static BindingCondition<T> isNamed(Class<? extends T> type, final CharSequence value)", "class_method_signature": "BindingConditions.isNamed(Class<? extends T> type, final CharSequence value)", "testcase": false, "constructor": false}, {"identifier": "isNamedIgnoringCase", "parameters": "(Class<? extends T> type, final CharSequence value)", "modifiers": "public static", "return": "BindingCondition<T>", "signature": "BindingCondition<T> isNamedIgnoringCase(Class<? extends T> type, final CharSequence value)", "full_signature": "public static BindingCondition<T> isNamedIgnoringCase(Class<? extends T> type, final CharSequence value)", "class_method_signature": "BindingConditions.isNamedIgnoringCase(Class<? extends T> type, final CharSequence value)", "testcase": false, "constructor": false}, {"identifier": "allAnnotationsArePresent", "parameters": "(Class<? extends T> type, final Class<? extends Annotation>... annotations)", "modifiers": "public static", "return": "BindingCondition<T>", "signature": "BindingCondition<T> allAnnotationsArePresent(Class<? extends T> type, final Class<? extends Annotation>... annotations)", "full_signature": "public static BindingCondition<T> allAnnotationsArePresent(Class<? extends T> type, final Class<? extends Annotation>... annotations)", "class_method_signature": "BindingConditions.allAnnotationsArePresent(Class<? extends T> type, final Class<? extends Annotation>... annotations)", "testcase": false, "constructor": false}, {"identifier": "anyAnnotationIsPresent", "parameters": "(Class<? extends T> type, final Class<? extends Annotation>... annotations)", "modifiers": "public static", "return": "BindingCondition<T>", "signature": "BindingCondition<T> anyAnnotationIsPresent(Class<? extends T> type, final Class<? extends Annotation>... annotations)", "full_signature": "public static BindingCondition<T> anyAnnotationIsPresent(Class<? extends T> type, final Class<? extends Annotation>... annotations)", "class_method_signature": "BindingConditions.anyAnnotationIsPresent(Class<? extends T> type, final Class<? extends Annotation>... annotations)", "testcase": false, "constructor": false}, {"identifier": "and", "parameters": "(final BindingCondition<T>... conditions)", "modifiers": "public static", "return": "BindingCondition<T>", "signature": "BindingCondition<T> and(final BindingCondition<T>... conditions)", "full_signature": "public static BindingCondition<T> and(final BindingCondition<T>... conditions)", "class_method_signature": "BindingConditions.and(final BindingCondition<T>... conditions)", "testcase": false, "constructor": false}, {"identifier": "or", "parameters": "(final BindingCondition<T>... conditions)", "modifiers": "public static", "return": "BindingCondition<T>", "signature": "BindingCondition<T> or(final BindingCondition<T>... conditions)", "full_signature": "public static BindingCondition<T> or(final BindingCondition<T>... conditions)", "class_method_signature": "BindingConditions.or(final BindingCondition<T>... conditions)", "testcase": false, "constructor": false}, {"identifier": "xor", "parameters": "(final BindingCondition<T> condition1, final BindingCondition<T> condition2)", "modifiers": "public static", "return": "BindingCondition<T>", "signature": "BindingCondition<T> xor(final BindingCondition<T> condition1, final BindingCondition<T> condition2)", "full_signature": "public static BindingCondition<T> xor(final BindingCondition<T> condition1, final BindingCondition<T> condition2)", "class_method_signature": "BindingConditions.xor(final BindingCondition<T> condition1, final BindingCondition<T> condition2)", "testcase": false, "constructor": false}], "file": "config-builder/src/main/java/com/github/jsr330/spi/config/builder/BindingConditions.java"}, "focal_method": {"identifier": "isNamedIgnoringCase", "parameters": "(Class<? extends T> type, final CharSequence value)", "modifiers": "public static", "return": "BindingCondition<T>", "body": "public static <T> BindingCondition<T> isNamedIgnoringCase(Class<? extends T> type, final CharSequence value) {\n        return new BindingCondition<T>() {\n            \n            @Override\n            public boolean fulfilled(ClassInjector injector, Class<T> type, Map<String, Class<? extends T>[]> inheritanceTree, Annotation qualifier,\n                    ClassLoader classLoader) {\n                return qualifier instanceof Named && ((Named) qualifier).value().equalsIgnoreCase(value.toString());\n            }\n            \n        };\n    }", "signature": "BindingCondition<T> isNamedIgnoringCase(Class<? extends T> type, final CharSequence value)", "full_signature": "public static BindingCondition<T> isNamedIgnoringCase(Class<? extends T> type, final CharSequence value)", "class_method_signature": "BindingConditions.isNamedIgnoringCase(Class<? extends T> type, final CharSequence value)", "testcase": false, "constructor": false, "invocations": ["equalsIgnoreCase", "value", "toString"]}, "repository": {"repo_id": 4654729, "url": "https://github.com/rstiller/JSR-330", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 10, "size": 747, "license": "licensed"}}