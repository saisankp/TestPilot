{"test_class": {"identifier": "GeoTiffReaderTest", "superclass": "extends org.junit.Assert", "interfaces": "", "fields": [{"original_string": "private final static Logger LOGGER = org.geotools.util.logging.Logging\n\t\t\t.getLogger(GeoTiffReaderTest.class.toString());", "modifier": "private final static", "type": "Logger", "declarator": "LOGGER = org.geotools.util.logging.Logging\n\t\t\t.getLogger(GeoTiffReaderTest.class.toString())", "var_name": "LOGGER"}, {"original_string": "static boolean oldOverrideInnerCRS;", "modifier": "static", "type": "boolean", "declarator": "oldOverrideInnerCRS", "var_name": "oldOverrideInnerCRS"}], "file": "modules/plugin/geotiff/src/test/java/org/geotools/gce/geotiff/GeoTiffReaderTest.java"}, "test_case": {"identifier": "testTransparencySettings", "parameters": "()", "modifiers": "@Test // @Ignore public", "return": "void", "body": "@Test\n//    @Ignore\n    public void testTransparencySettings() throws Exception {\n\n        \n        final AbstractGridFormat format = new GeoTiffFormat();\n        File file = TestData.file(GeoTiffReaderTest.class,\"002025_0100_010722_l7_01_utm2.tiff\");        \n        if (format.accepts(file)) {\n            // getting a reader\n            GeoTiffReader reader = new GeoTiffReader(file, new Hints(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.TRUE));\n            if (reader != null) {\n                // reading the coverage\n                GridCoverage2D coverage = reader.read(null);\n                assertNotNull(coverage);\n                assertTrue(coverage.getRenderedImage().getSampleModel().getNumBands() == 1);\n                final ParameterValue<Color> colorPV = AbstractGridFormat.INPUT_TRANSPARENT_COLOR.createValue();\n                colorPV.setValue(Color.BLACK);\n                coverage = reader.read(new GeneralParameterValue[] { colorPV });\n                assertNotNull(coverage);\n                assertTrue(coverage.getRenderedImage().getSampleModel().getNumBands() == 2);\n\n                // showing it\n                if (TestData.isInteractiveTest())\n                    coverage.show();\n                else\n                    PlanarImage.wrapRenderedImage(coverage.getRenderedImage()).getTiles();\n\n            }\n\n        } else\n            assertFalse(true); // we should not get here\n\n        \n        file = TestData.file(GeoTiffReaderTest.class,\"gaarc_subset.tiff\");        \n        if (format.accepts(file)) {\n            // getting a reader\n            GeoTiffReader reader = new GeoTiffReader(file, new Hints(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.TRUE));\n            if (reader != null) {\n                // reading the coverage\n                GridCoverage2D coverage = reader.read(null);\n                assertNotNull(coverage);\n                assertTrue(coverage.getRenderedImage().getSampleModel().getNumBands() == 3);\n                final ParameterValue<Color> colorPV = AbstractGridFormat.INPUT_TRANSPARENT_COLOR.createValue();\n                colorPV.setValue(new Color(34,53,87));\n                coverage = reader.read(new GeneralParameterValue[] { colorPV });\n                assertNotNull(coverage);\n                assertTrue(coverage.getRenderedImage().getSampleModel().getNumBands() == 4);\n\n                // showing it\n                if (TestData.isInteractiveTest())\n                    coverage.show();\n                else\n                    PlanarImage.wrapRenderedImage(coverage.getRenderedImage()).getTiles();\n\n            }\n\n        } else\n            assertFalse(true); // we should not get here\n        \n        // now we test that we cannot do colormasking on a non-rendered output\n        file = TestData.file(GeoTiffReaderTest.class,\"wind.tiff\");        \n        if (format.accepts(file)) {\n            // getting a reader\n            GeoTiffReader reader = new GeoTiffReader(file, new Hints(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.TRUE));\n            if (reader != null) {\n                // reading the coverage\n                GridCoverage2D coverage = reader.read(null);\n                assertNotNull(coverage);\n                assertTrue(coverage.getRenderedImage().getSampleModel().getNumBands() == 2);\n                final ParameterValue<Color> colorPV = AbstractGridFormat.INPUT_TRANSPARENT_COLOR.createValue();\n                colorPV.setValue(new Color(34,53,87));\n                try{\n                    coverage = reader.read(new GeneralParameterValue[] { colorPV });\n                    assertFalse(true); // we should not get here\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            }\n\n        } \n            \n    }", "signature": "void testTransparencySettings()", "full_signature": "@Test // @Ignore public void testTransparencySettings()", "class_method_signature": "GeoTiffReaderTest.testTransparencySettings()", "testcase": true, "constructor": false, "invocations": ["file", "accepts", "read", "assertNotNull", "assertTrue", "getNumBands", "getSampleModel", "getRenderedImage", "createValue", "setValue", "read", "assertNotNull", "assertTrue", "getNumBands", "getSampleModel", "getRenderedImage", "isInteractiveTest", "show", "getTiles", "wrapRenderedImage", "getRenderedImage", "assertFalse", "file", "accepts", "read", "assertNotNull", "assertTrue", "getNumBands", "getSampleModel", "getRenderedImage", "createValue", "setValue", "read", "assertNotNull", "assertTrue", "getNumBands", "getSampleModel", "getRenderedImage", "isInteractiveTest", "show", "getTiles", "wrapRenderedImage", "getRenderedImage", "assertFalse", "file", "accepts", "read", "assertNotNull", "assertTrue", "getNumBands", "getSampleModel", "getRenderedImage", "createValue", "setValue", "read", "assertFalse"]}, "focal_class": {"identifier": "GeoTiffReader", "superclass": "extends AbstractGridCoverage2DReader", "interfaces": "implements GridCoverage2DReader", "fields": [{"original_string": "private Logger LOGGER = org.geotools.util.logging.Logging.getLogger(GeoTiffReader.class.toString());", "modifier": "private", "type": "Logger", "declarator": "LOGGER = org.geotools.util.logging.Logging.getLogger(GeoTiffReader.class.toString())", "var_name": "LOGGER"}, {"original_string": "public static final String OVERRIDE_CRS_SWITCH = \"org.geotools.gce.geotiff.override.crs\";", "modifier": "public static final", "type": "String", "declarator": "OVERRIDE_CRS_SWITCH = \"org.geotools.gce.geotiff.override.crs\"", "var_name": "OVERRIDE_CRS_SWITCH"}, {"original_string": "static boolean OVERRIDE_INNER_CRS=Boolean.valueOf(System.getProperty(GeoTiffReader.OVERRIDE_CRS_SWITCH, \"True\"));", "modifier": "static", "type": "boolean", "declarator": "OVERRIDE_INNER_CRS=Boolean.valueOf(System.getProperty(GeoTiffReader.OVERRIDE_CRS_SWITCH, \"True\"))", "var_name": "OVERRIDE_INNER_CRS"}, {"original_string": "private final static TIFFImageReaderSpi READER_SPI = new TIFFImageReaderSpi();", "modifier": "private final static", "type": "TIFFImageReaderSpi", "declarator": "READER_SPI = new TIFFImageReaderSpi()", "var_name": "READER_SPI"}, {"original_string": "private GeoTiffMetadata2CRSAdapter gtcs;", "modifier": "private", "type": "GeoTiffMetadata2CRSAdapter", "declarator": "gtcs", "var_name": "gtcs"}, {"original_string": "private double noData = Double.NaN;", "modifier": "private", "type": "double", "declarator": "noData = Double.NaN", "var_name": "noData"}, {"original_string": "private File ovrSource;", "modifier": "private", "type": "File", "declarator": "ovrSource", "var_name": "ovrSource"}, {"original_string": "private ImageInputStreamSpi ovrInStreamSPI = null;", "modifier": "private", "type": "ImageInputStreamSpi", "declarator": "ovrInStreamSPI = null", "var_name": "ovrInStreamSPI"}, {"original_string": "private int extOvrImgChoice = -1;", "modifier": "private", "type": "int", "declarator": "extOvrImgChoice = -1", "var_name": "extOvrImgChoice"}, {"original_string": "private GroundControlPoints gcps;", "modifier": "private", "type": "GroundControlPoints", "declarator": "gcps", "var_name": "gcps"}], "methods": [{"identifier": "GeoTiffReader", "parameters": "(Object input)", "modifiers": "public", "return": "", "signature": " GeoTiffReader(Object input)", "full_signature": "public  GeoTiffReader(Object input)", "class_method_signature": "GeoTiffReader.GeoTiffReader(Object input)", "testcase": false, "constructor": true}, {"identifier": "GeoTiffReader", "parameters": "(Object input, Hints uHints)", "modifiers": "public", "return": "", "signature": " GeoTiffReader(Object input, Hints uHints)", "full_signature": "public  GeoTiffReader(Object input, Hints uHints)", "class_method_signature": "GeoTiffReader.GeoTiffReader(Object input, Hints uHints)", "testcase": false, "constructor": true}, {"identifier": "checkForExternalOverviews", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void checkForExternalOverviews()", "full_signature": "private void checkForExternalOverviews()", "class_method_signature": "GeoTiffReader.checkForExternalOverviews()", "testcase": false, "constructor": false}, {"identifier": "getHRInfo", "parameters": "(Hints hints)", "modifiers": "private", "return": "void", "signature": "void getHRInfo(Hints hints)", "full_signature": "private void getHRInfo(Hints hints)", "class_method_signature": "GeoTiffReader.getHRInfo(Hints hints)", "testcase": false, "constructor": false}, {"identifier": "getFormat", "parameters": "()", "modifiers": "public", "return": "Format", "signature": "Format getFormat()", "full_signature": "public Format getFormat()", "class_method_signature": "GeoTiffReader.getFormat()", "testcase": false, "constructor": false}, {"identifier": "read", "parameters": "(GeneralParameterValue[] params)", "modifiers": "public", "return": "GridCoverage2D", "signature": "GridCoverage2D read(GeneralParameterValue[] params)", "full_signature": "public GridCoverage2D read(GeneralParameterValue[] params)", "class_method_signature": "GeoTiffReader.read(GeneralParameterValue[] params)", "testcase": false, "constructor": false}, {"identifier": "getMetadata", "parameters": "()", "modifiers": "public", "return": "GeoTiffIIOMetadataDecoder", "signature": "GeoTiffIIOMetadataDecoder getMetadata()", "full_signature": "public GeoTiffIIOMetadataDecoder getMetadata()", "class_method_signature": "GeoTiffReader.getMetadata()", "testcase": false, "constructor": false}, {"identifier": "createCoverage", "parameters": "(PlanarImage image, MathTransform raster2Model)", "modifiers": "protected final", "return": "GridCoverage2D", "signature": "GridCoverage2D createCoverage(PlanarImage image, MathTransform raster2Model)", "full_signature": "protected final GridCoverage2D createCoverage(PlanarImage image, MathTransform raster2Model)", "class_method_signature": "GeoTiffReader.createCoverage(PlanarImage image, MathTransform raster2Model)", "testcase": false, "constructor": false}, {"identifier": "getCRS", "parameters": "(Object source)", "modifiers": "private", "return": "CoordinateReferenceSystem", "signature": "CoordinateReferenceSystem getCRS(Object source)", "full_signature": "private CoordinateReferenceSystem getCRS(Object source)", "class_method_signature": "GeoTiffReader.getCRS(Object source)", "testcase": false, "constructor": false}, {"identifier": "parseWorldFile", "parameters": "(Object source)", "modifiers": "static", "return": "MathTransform", "signature": "MathTransform parseWorldFile(Object source)", "full_signature": "static MathTransform parseWorldFile(Object source)", "class_method_signature": "GeoTiffReader.parseWorldFile(Object source)", "testcase": false, "constructor": false}, {"identifier": "parseMapInfoFile", "parameters": "(Object source)", "modifiers": "static", "return": "MapInfoFileReader", "signature": "MapInfoFileReader parseMapInfoFile(Object source)", "full_signature": "static MapInfoFileReader parseMapInfoFile(Object source)", "class_method_signature": "GeoTiffReader.parseMapInfoFile(Object source)", "testcase": false, "constructor": false}, {"identifier": "getGridCoverageCount", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getGridCoverageCount()", "full_signature": "@Override public int getGridCoverageCount()", "class_method_signature": "GeoTiffReader.getGridCoverageCount()", "testcase": false, "constructor": false}, {"identifier": "getGroundControlPoints", "parameters": "()", "modifiers": "@Override public", "return": "GroundControlPoints", "signature": "GroundControlPoints getGroundControlPoints()", "full_signature": "@Override public GroundControlPoints getGroundControlPoints()", "class_method_signature": "GeoTiffReader.getGroundControlPoints()", "testcase": false, "constructor": false}], "file": "modules/plugin/geotiff/src/main/java/org/geotools/gce/geotiff/GeoTiffReader.java"}, "focal_method": {"identifier": "read", "parameters": "(GeneralParameterValue[] params)", "modifiers": "public", "return": "GridCoverage2D", "body": "public GridCoverage2D read(GeneralParameterValue[] params) throws IOException {\n\t\tGeneralEnvelope requestedEnvelope = null;\n\t\tRectangle dim = null;\n\t\tColor inputTransparentColor=null;\n\t\tOverviewPolicy overviewPolicy=null;\n\t\tint[] suggestedTileSize=null;\n\t\tif (params != null) {\n\n\t\t\t//\n\t\t\t// Checking params\n\t\t\t//\n\t\t\tif (params != null) {\n\t\t\t\tfor (int i = 0; i < params.length; i++) {\n\t\t\t\t\tfinal ParameterValue param = (ParameterValue) params[i];\n\t\t\t\t\tfinal ReferenceIdentifier name = param.getDescriptor().getName();\n\t\t\t\t\tif (name.equals(AbstractGridFormat.READ_GRIDGEOMETRY2D.getName())) {\n\t\t\t\t\t\tfinal GridGeometry2D gg = (GridGeometry2D) param.getValue();\n\t\t\t\t\t\trequestedEnvelope = new GeneralEnvelope((Envelope) gg.getEnvelope2D());\n\t\t\t\t\t\tdim = gg.getGridRange2D().getBounds();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (name.equals(AbstractGridFormat.OVERVIEW_POLICY.getName())) {\n\t\t\t\t\t\toverviewPolicy=(OverviewPolicy) param.getValue();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\t\n                    if (name.equals(AbstractGridFormat.INPUT_TRANSPARENT_COLOR.getName())) {\n                        inputTransparentColor = (Color) param.getValue();\n                        continue;\n                    }\t\n                    if (name.equals(AbstractGridFormat.SUGGESTED_TILE_SIZE.getName())) {\n                        String suggestedTileSize_= (String) param.getValue();\n                        if(suggestedTileSize_!=null&&suggestedTileSize_.length()>0){\n                            suggestedTileSize_=suggestedTileSize_.trim();\n                            int commaPosition=suggestedTileSize_.indexOf(\",\");\n                            if(commaPosition<0){\n                                int tileDim=Integer.parseInt(suggestedTileSize_);\n                                suggestedTileSize= new int[]{tileDim,tileDim};\n                            } else {\n                                int tileW=Integer.parseInt(suggestedTileSize_.substring(0,commaPosition));\n                                int tileH=Integer.parseInt(suggestedTileSize_.substring(commaPosition+1));\n                                suggestedTileSize= new int[]{tileW,tileH};\n                            }\n                        }\n                        continue;\n                    }                                               \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// set params\n\t\t//\n\t\tInteger imageChoice = new Integer(0);\n\t\tfinal ImageReadParam readP = new ImageReadParam();\n\t\ttry {\n\t\t\timageChoice = setReadParams(overviewPolicy, readP,requestedEnvelope, dim);\n\t\t} catch (TransformException e) {\n\t\t\tnew DataSourceException(e);\n\t\t}\n\n\t\t//\n\t\t// IMAGE READ OPERATION\n\t\t//\n        Hints newHints = null;\n\t\tif(suggestedTileSize!=null){\n\t\t    newHints= hints.clone();\n            final ImageLayout layout = new ImageLayout();\n            layout.setTileGridXOffset(0);\n            layout.setTileGridYOffset(0);\n            layout.setTileHeight(suggestedTileSize[1]);\n            layout.setTileWidth(suggestedTileSize[0]);\n            newHints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT, layout));\n\t\t}\n\t\tfinal ParameterBlock pbjRead = new ParameterBlock();\n        if (extOvrImgChoice >= 0 && imageChoice >= extOvrImgChoice) {\n            pbjRead.add(ovrInStreamSPI.createInputStreamInstance(ovrSource, ImageIO.getUseCache(),ImageIO.getCacheDirectory()));\n            pbjRead.add(imageChoice - extOvrImgChoice);\n        } else {\n            pbjRead.add(inStreamSPI != null ? inStreamSPI.createInputStreamInstance(source, ImageIO.getUseCache(), ImageIO.getCacheDirectory()) : ImageIO.createImageInputStream(source));\n            pbjRead.add(imageChoice);\n        }\n    \tpbjRead.add(Boolean.FALSE);\n\t\tpbjRead.add(Boolean.FALSE);\n\t\tpbjRead.add(Boolean.FALSE);\n\t\tpbjRead.add(null);\n\t\tpbjRead.add(null);\n\t\tpbjRead.add(readP);\n\t\tpbjRead.add(READER_SPI.createReaderInstance());\n\t\tRenderedOp coverageRaster=JAI.create(\"ImageRead\", pbjRead,newHints!=null?(RenderingHints) newHints:null);\n\t\t\n        //\n        // MASKING INPUT COLOR as indicated\n        //\n\t\tif(inputTransparentColor!=null){\n\t\t    coverageRaster= new ImageWorker(coverageRaster).setRenderingHints(newHints).makeColorTransparent(inputTransparentColor).getRenderedOperation();\n\t\t}\n\t\t\n\n        AffineTransform rasterToModel = getRescaledRasterToModel(coverageRaster);\n        try {\n            return createCoverage(coverageRaster, ProjectiveTransform.create(rasterToModel));\n        } catch (Exception e) {\n            // dispose and close file\n            ImageUtilities.disposePlanarImageChain(coverageRaster);\n\n            // rethrow\n            if (e instanceof DataSourceException) {\n                throw (DataSourceException) e;\n            }\n            throw new DataSourceException(e);\n        }\n\t}", "signature": "GridCoverage2D read(GeneralParameterValue[] params)", "full_signature": "public GridCoverage2D read(GeneralParameterValue[] params)", "class_method_signature": "GeoTiffReader.read(GeneralParameterValue[] params)", "testcase": false, "constructor": false, "invocations": ["getName", "getDescriptor", "equals", "getName", "getValue", "getEnvelope2D", "getBounds", "getGridRange2D", "equals", "getName", "getValue", "equals", "getName", "getValue", "equals", "getName", "getValue", "length", "trim", "indexOf", "parseInt", "parseInt", "substring", "parseInt", "substring", "setReadParams", "clone", "setTileGridXOffset", "setTileGridYOffset", "setTileHeight", "setTileWidth", "add", "add", "createInputStreamInstance", "getUseCache", "getCacheDirectory", "add", "add", "createInputStreamInstance", "getUseCache", "getCacheDirectory", "createImageInputStream", "add", "add", "add", "add", "add", "add", "add", "add", "createReaderInstance", "create", "getRenderedOperation", "makeColorTransparent", "setRenderingHints", "getRescaledRasterToModel", "createCoverage", "create", "disposePlanarImageChain"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}