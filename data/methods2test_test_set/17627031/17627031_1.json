{"test_class": {"identifier": "WaveModuleTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private WaveModule module;", "modifier": "private", "type": "WaveModule", "declarator": "module", "var_name": "module"}], "file": "jhove-modules/wave-hul/src/test/java/edu/harvard/hul/ois/jhove/module/WaveModuleTest.java"}, "test_case": {"identifier": "testSample3", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testSample3() throws IOException {\n\t\tFile f = new File(\"src/test/resources/wave/sample3.wav\");\n\t\tRepInfo info = new RepInfo(f.getName());\n\n\t\t// Parse\n\t\tmodule.parse(new FileInputStream(f), info, 0);\n\n\t\t// Check that JHOVE found this was NOT well formed:\n\t\tassertEquals(\"Should not be well formed. \", info.getWellFormed(),\n\t\t\t\tRepInfo.FALSE);\n\n\t\t// Check that there is a message:\n\t\tassertTrue(\"There should be at least one message. \", info.getMessage()\n\t\t\t\t.size() > 0);\n\n\t\t// Go though messages looking for the expected error:\n\t\tboolean foundEofMessage = false;\n\t\tfor( Message m : info.getMessage()) {\n\t\t\t// Use ID to be language independent\n\t\t\tif (\"WAVE-HUL-3\".equals(m.getId())\n\t\t\t\t\t&& m.getOffset() == 96) {\n\t\t\t\tfoundEofMessage = true;\n\t\t\t}\n\t\t\tSystem.out.println(\"MESSAGE: (\" + m.getId() + \") \" + m.getMessage() + \" \"\n\t\t\t\t\t+ m.getSubMessage()\n\t\t\t\t\t+ \" @\" + m.getOffset());\n\t\t}\n\t\t// Fail if the error was not found.\n\t\tassertTrue(\"The message of id=WAVE-HUL-3 ('Unexpected end of file')@96 was not found. \",\n\t\t\t\tfoundEofMessage);\n\t}", "signature": "void testSample3()", "full_signature": "@Test public void testSample3()", "class_method_signature": "WaveModuleTest.testSample3()", "testcase": true, "constructor": false, "invocations": ["getName", "parse", "assertEquals", "getWellFormed", "assertTrue", "size", "getMessage", "getMessage", "equals", "getId", "getOffset", "println", "getId", "getMessage", "getSubMessage", "getOffset", "assertTrue"]}, "focal_class": {"identifier": "WaveModule", "superclass": "extends ModuleBase", "interfaces": "", "fields": [{"original_string": "private static final String NAME = \"WAVE-hul\";", "modifier": "private static final", "type": "String", "declarator": "NAME = \"WAVE-hul\"", "var_name": "NAME"}, {"original_string": "private static final String RELEASE = \"1.8.1\";", "modifier": "private static final", "type": "String", "declarator": "RELEASE = \"1.8.1\"", "var_name": "RELEASE"}, {"original_string": "private static final int [] DATE = { 2019, 12, 10 };", "modifier": "private static final", "type": "int []", "declarator": "DATE = { 2019, 12, 10 }", "var_name": "DATE"}, {"original_string": "private static final String[] FORMATS = { \"WAVE\", \"Audio for Windows\",\n            \"EBU Technical Specification 3285\", \"Broadcast Wave Format\", \"BWF\",\n            \"EBU Technical Specification 3306\", \"RF64\" };", "modifier": "private static final", "type": "String[]", "declarator": "FORMATS = { \"WAVE\", \"Audio for Windows\",\n            \"EBU Technical Specification 3285\", \"Broadcast Wave Format\", \"BWF\",\n            \"EBU Technical Specification 3306\", \"RF64\" }", "var_name": "FORMATS"}, {"original_string": "private static final String COVERAGE = \"WAVE (PCMWAVEFORMAT, WAVEFORMATEX, WAVEFORMATEXTENSIBLE); \"\n            + \"Broadcast Wave Format (BWF) version 0, 1 and 2; RF64\";", "modifier": "private static final", "type": "String", "declarator": "COVERAGE = \"WAVE (PCMWAVEFORMAT, WAVEFORMATEX, WAVEFORMATEXTENSIBLE); \"\n            + \"Broadcast Wave Format (BWF) version 0, 1 and 2; RF64\"", "var_name": "COVERAGE"}, {"original_string": "private static final String[] MIMETYPES = { \"audio/vnd.wave\", \"audio/wav\",\n            \"audio/wave\", \"audio/x-wav\", \"audio/x-wave\" };", "modifier": "private static final", "type": "String[]", "declarator": "MIMETYPES = { \"audio/vnd.wave\", \"audio/wav\",\n            \"audio/wave\", \"audio/x-wav\", \"audio/x-wave\" }", "var_name": "MIMETYPES"}, {"original_string": "private static final String WELLFORMED = null;", "modifier": "private static final", "type": "String", "declarator": "WELLFORMED = null", "var_name": "WELLFORMED"}, {"original_string": "private static final String VALIDITY = null;", "modifier": "private static final", "type": "String", "declarator": "VALIDITY = null", "var_name": "VALIDITY"}, {"original_string": "private static final String REPINFO = null;", "modifier": "private static final", "type": "String", "declarator": "REPINFO = null", "var_name": "REPINFO"}, {"original_string": "private static final String NOTE = \"There is no published standard for WAVE files. This module regards \"\n            + \"a file as valid if it conforms to common usage practices.\";", "modifier": "private static final", "type": "String", "declarator": "NOTE = \"There is no published standard for WAVE files. This module regards \"\n            + \"a file as valid if it conforms to common usage practices.\"", "var_name": "NOTE"}, {"original_string": "private static final String RIGHTS = \"Copyright 2004-2007 by JSTOR and the \"\n            + \"President and Fellows of Harvard College. \"\n            + \"Released under the GNU Lesser General Public License.\";", "modifier": "private static final", "type": "String", "declarator": "RIGHTS = \"Copyright 2004-2007 by JSTOR and the \"\n            + \"President and Fellows of Harvard College. \"\n            + \"Released under the GNU Lesser General Public License.\"", "var_name": "RIGHTS"}, {"original_string": "private static final String RIFF_SIGNATURE = \"RIFF\";", "modifier": "private static final", "type": "String", "declarator": "RIFF_SIGNATURE = \"RIFF\"", "var_name": "RIFF_SIGNATURE"}, {"original_string": "private static final String RF64_SIGNATURE = \"RF64\";", "modifier": "private static final", "type": "String", "declarator": "RF64_SIGNATURE = \"RF64\"", "var_name": "RF64_SIGNATURE"}, {"original_string": "private static final int RIFF_FORM_TYPE_LENGTH = 4;", "modifier": "private static final", "type": "int", "declarator": "RIFF_FORM_TYPE_LENGTH = 4", "var_name": "RIFF_FORM_TYPE_LENGTH"}, {"original_string": "public static final long LOOKUP_EXTENDED_DATA_SIZE = 0xFFFFFFFFL;", "modifier": "public static final", "type": "long", "declarator": "LOOKUP_EXTENDED_DATA_SIZE = 0xFFFFFFFFL", "var_name": "LOOKUP_EXTENDED_DATA_SIZE"}, {"original_string": "protected Map<String, Long> extendedChunkSizes;", "modifier": "protected", "type": "Map<String, Long>", "declarator": "extendedChunkSizes", "var_name": "extendedChunkSizes"}, {"original_string": "protected Property _metadata;", "modifier": "protected", "type": "Property", "declarator": "_metadata", "var_name": "_metadata"}, {"original_string": "protected List<Property> _propList;", "modifier": "protected", "type": "List<Property>", "declarator": "_propList", "var_name": "_propList"}, {"original_string": "protected List<Property> _notes;", "modifier": "protected", "type": "List<Property>", "declarator": "_notes", "var_name": "_notes"}, {"original_string": "protected List<Property> _labels;", "modifier": "protected", "type": "List<Property>", "declarator": "_labels", "var_name": "_labels"}, {"original_string": "protected List<Property> _labeledText;", "modifier": "protected", "type": "List<Property>", "declarator": "_labeledText", "var_name": "_labeledText"}, {"original_string": "protected List<Property> _samples;", "modifier": "protected", "type": "List<Property>", "declarator": "_samples", "var_name": "_samples"}, {"original_string": "protected AESAudioMetadata _aesMetadata;", "modifier": "protected", "type": "AESAudioMetadata", "declarator": "_aesMetadata", "var_name": "_aesMetadata"}, {"original_string": "protected long riffSize;", "modifier": "protected", "type": "long", "declarator": "riffSize", "var_name": "riffSize"}, {"original_string": "protected int _blockAlign;", "modifier": "protected", "type": "int", "declarator": "_blockAlign", "var_name": "_blockAlign"}, {"original_string": "protected ExifInfo _exifInfo;", "modifier": "protected", "type": "ExifInfo", "declarator": "_exifInfo", "var_name": "_exifInfo"}, {"original_string": "protected int waveCodec;", "modifier": "protected", "type": "int", "declarator": "waveCodec", "var_name": "waveCodec"}, {"original_string": "protected long extendedRiffSize;", "modifier": "protected", "type": "long", "declarator": "extendedRiffSize", "var_name": "extendedRiffSize"}, {"original_string": "protected long extendedSampleLength;", "modifier": "protected", "type": "long", "declarator": "extendedSampleLength", "var_name": "extendedSampleLength"}, {"original_string": "protected long sampleCount;", "modifier": "protected", "type": "long", "declarator": "sampleCount", "var_name": "sampleCount"}, {"original_string": "protected long sampleRate;", "modifier": "protected", "type": "long", "declarator": "sampleRate", "var_name": "sampleRate"}, {"original_string": "protected boolean formatChunkSeen;", "modifier": "protected", "type": "boolean", "declarator": "formatChunkSeen", "var_name": "formatChunkSeen"}, {"original_string": "protected boolean factChunkSeen;", "modifier": "protected", "type": "boolean", "declarator": "factChunkSeen", "var_name": "factChunkSeen"}, {"original_string": "protected boolean dataChunkSeen;", "modifier": "protected", "type": "boolean", "declarator": "dataChunkSeen", "var_name": "dataChunkSeen"}, {"original_string": "protected boolean dataSize64ChunkSeen;", "modifier": "protected", "type": "boolean", "declarator": "dataSize64ChunkSeen", "var_name": "dataSize64ChunkSeen"}, {"original_string": "protected boolean instrumentChunkSeen;", "modifier": "protected", "type": "boolean", "declarator": "instrumentChunkSeen", "var_name": "instrumentChunkSeen"}, {"original_string": "protected boolean mpegChunkSeen;", "modifier": "protected", "type": "boolean", "declarator": "mpegChunkSeen", "var_name": "mpegChunkSeen"}, {"original_string": "protected boolean cartChunkSeen;", "modifier": "protected", "type": "boolean", "declarator": "cartChunkSeen", "var_name": "cartChunkSeen"}, {"original_string": "protected boolean broadcastExtChunkSeen;", "modifier": "protected", "type": "boolean", "declarator": "broadcastExtChunkSeen", "var_name": "broadcastExtChunkSeen"}, {"original_string": "protected boolean peakChunkSeen;", "modifier": "protected", "type": "boolean", "declarator": "peakChunkSeen", "var_name": "peakChunkSeen"}, {"original_string": "protected boolean linkChunkSeen;", "modifier": "protected", "type": "boolean", "declarator": "linkChunkSeen", "var_name": "linkChunkSeen"}, {"original_string": "protected boolean cueChunkSeen;", "modifier": "protected", "type": "boolean", "declarator": "cueChunkSeen", "var_name": "cueChunkSeen"}, {"original_string": "protected boolean flagPCMWaveFormat;", "modifier": "protected", "type": "boolean", "declarator": "flagPCMWaveFormat", "var_name": "flagPCMWaveFormat"}, {"original_string": "protected boolean flagWaveFormatEx;", "modifier": "protected", "type": "boolean", "declarator": "flagWaveFormatEx", "var_name": "flagWaveFormatEx"}, {"original_string": "protected boolean flagWaveFormatExtensible;", "modifier": "protected", "type": "boolean", "declarator": "flagWaveFormatExtensible", "var_name": "flagWaveFormatExtensible"}, {"original_string": "protected boolean flagRF64;", "modifier": "protected", "type": "boolean", "declarator": "flagRF64", "var_name": "flagRF64"}, {"original_string": "protected boolean firstSampleOffsetMarked;", "modifier": "protected", "type": "boolean", "declarator": "firstSampleOffsetMarked", "var_name": "firstSampleOffsetMarked"}], "methods": [{"identifier": "WaveModule", "parameters": "()", "modifiers": "public", "return": "", "signature": " WaveModule()", "full_signature": "public  WaveModule()", "class_method_signature": "WaveModule.WaveModule()", "testcase": false, "constructor": true}, {"identifier": "parse", "parameters": "(InputStream stream, RepInfo info, int parseIndex)", "modifiers": "@Override public", "return": "int", "signature": "int parse(InputStream stream, RepInfo info, int parseIndex)", "full_signature": "@Override public int parse(InputStream stream, RepInfo info, int parseIndex)", "class_method_signature": "WaveModule.parse(InputStream stream, RepInfo info, int parseIndex)", "testcase": false, "constructor": false}, {"identifier": "markFirstSampleOffset", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void markFirstSampleOffset()", "full_signature": "public void markFirstSampleOffset()", "class_method_signature": "WaveModule.markFirstSampleOffset()", "testcase": false, "constructor": false}, {"identifier": "setExifInfo", "parameters": "(ExifInfo exifInfo)", "modifiers": "public", "return": "void", "signature": "void setExifInfo(ExifInfo exifInfo)", "full_signature": "public void setExifInfo(ExifInfo exifInfo)", "class_method_signature": "WaveModule.setExifInfo(ExifInfo exifInfo)", "testcase": false, "constructor": false}, {"identifier": "setBlockAlign", "parameters": "(int align)", "modifiers": "public", "return": "void", "signature": "void setBlockAlign(int align)", "full_signature": "public void setBlockAlign(int align)", "class_method_signature": "WaveModule.setBlockAlign(int align)", "testcase": false, "constructor": false}, {"identifier": "getExifInfo", "parameters": "()", "modifiers": "public", "return": "ExifInfo", "signature": "ExifInfo getExifInfo()", "full_signature": "public ExifInfo getExifInfo()", "class_method_signature": "WaveModule.getExifInfo()", "testcase": false, "constructor": false}, {"identifier": "getWaveCodec", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getWaveCodec()", "full_signature": "public int getWaveCodec()", "class_method_signature": "WaveModule.getWaveCodec()", "testcase": false, "constructor": false}, {"identifier": "getBlockAlign", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getBlockAlign()", "full_signature": "public int getBlockAlign()", "class_method_signature": "WaveModule.getBlockAlign()", "testcase": false, "constructor": false}, {"identifier": "addWaveProperty", "parameters": "(Property prop)", "modifiers": "public", "return": "void", "signature": "void addWaveProperty(Property prop)", "full_signature": "public void addWaveProperty(Property prop)", "class_method_signature": "WaveModule.addWaveProperty(Property prop)", "testcase": false, "constructor": false}, {"identifier": "addLabel", "parameters": "(Property p)", "modifiers": "public", "return": "void", "signature": "void addLabel(Property p)", "full_signature": "public void addLabel(Property p)", "class_method_signature": "WaveModule.addLabel(Property p)", "testcase": false, "constructor": false}, {"identifier": "addLabeledText", "parameters": "(Property p)", "modifiers": "public", "return": "void", "signature": "void addLabeledText(Property p)", "full_signature": "public void addLabeledText(Property p)", "class_method_signature": "WaveModule.addLabeledText(Property p)", "testcase": false, "constructor": false}, {"identifier": "addSample", "parameters": "(Property p)", "modifiers": "public", "return": "void", "signature": "void addSample(Property p)", "full_signature": "public void addSample(Property p)", "class_method_signature": "WaveModule.addSample(Property p)", "testcase": false, "constructor": false}, {"identifier": "addNote", "parameters": "(Property p)", "modifiers": "public", "return": "void", "signature": "void addNote(Property p)", "full_signature": "public void addNote(Property p)", "class_method_signature": "WaveModule.addNote(Property p)", "testcase": false, "constructor": false}, {"identifier": "addListInfo", "parameters": "(List l)", "modifiers": "public", "return": "void", "signature": "void addListInfo(List l)", "full_signature": "public void addListInfo(List l)", "class_method_signature": "WaveModule.addListInfo(List l)", "testcase": false, "constructor": false}, {"identifier": "readSignedLong", "parameters": "(DataInputStream stream)", "modifiers": "public", "return": "long", "signature": "long readSignedLong(DataInputStream stream)", "full_signature": "public long readSignedLong(DataInputStream stream)", "class_method_signature": "WaveModule.readSignedLong(DataInputStream stream)", "testcase": false, "constructor": false}, {"identifier": "readUnsignedInt", "parameters": "(DataInputStream stream)", "modifiers": "public", "return": "long", "signature": "long readUnsignedInt(DataInputStream stream)", "full_signature": "public long readUnsignedInt(DataInputStream stream)", "class_method_signature": "WaveModule.readUnsignedInt(DataInputStream stream)", "testcase": false, "constructor": false}, {"identifier": "readSignedInt", "parameters": "(DataInputStream stream)", "modifiers": "public", "return": "int", "signature": "int readSignedInt(DataInputStream stream)", "full_signature": "public int readSignedInt(DataInputStream stream)", "class_method_signature": "WaveModule.readSignedInt(DataInputStream stream)", "testcase": false, "constructor": false}, {"identifier": "readUnsignedShort", "parameters": "(DataInputStream stream)", "modifiers": "public", "return": "int", "signature": "int readUnsignedShort(DataInputStream stream)", "full_signature": "public int readUnsignedShort(DataInputStream stream)", "class_method_signature": "WaveModule.readUnsignedShort(DataInputStream stream)", "testcase": false, "constructor": false}, {"identifier": "readSignedShort", "parameters": "(DataInputStream stream)", "modifiers": "public", "return": "int", "signature": "int readSignedShort(DataInputStream stream)", "full_signature": "public int readSignedShort(DataInputStream stream)", "class_method_signature": "WaveModule.readSignedShort(DataInputStream stream)", "testcase": false, "constructor": false}, {"identifier": "read4Chars", "parameters": "(DataInputStream stream)", "modifiers": "public", "return": "String", "signature": "String read4Chars(DataInputStream stream)", "full_signature": "public String read4Chars(DataInputStream stream)", "class_method_signature": "WaveModule.read4Chars(DataInputStream stream)", "testcase": false, "constructor": false}, {"identifier": "setWaveCodec", "parameters": "(int value)", "modifiers": "public", "return": "void", "signature": "void setWaveCodec(int value)", "full_signature": "public void setWaveCodec(int value)", "class_method_signature": "WaveModule.setWaveCodec(int value)", "testcase": false, "constructor": false}, {"identifier": "addSamples", "parameters": "(long samples)", "modifiers": "public", "return": "void", "signature": "void addSamples(long samples)", "full_signature": "public void addSamples(long samples)", "class_method_signature": "WaveModule.addSamples(long samples)", "testcase": false, "constructor": false}, {"identifier": "setSampleRate", "parameters": "(long rate)", "modifiers": "public", "return": "void", "signature": "void setSampleRate(long rate)", "full_signature": "public void setSampleRate(long rate)", "class_method_signature": "WaveModule.setSampleRate(long rate)", "testcase": false, "constructor": false}, {"identifier": "setPCMWaveFormat", "parameters": "(boolean b)", "modifiers": "public", "return": "void", "signature": "void setPCMWaveFormat(boolean b)", "full_signature": "public void setPCMWaveFormat(boolean b)", "class_method_signature": "WaveModule.setPCMWaveFormat(boolean b)", "testcase": false, "constructor": false}, {"identifier": "setWaveFormatEx", "parameters": "(boolean b)", "modifiers": "public", "return": "void", "signature": "void setWaveFormatEx(boolean b)", "full_signature": "public void setWaveFormatEx(boolean b)", "class_method_signature": "WaveModule.setWaveFormatEx(boolean b)", "testcase": false, "constructor": false}, {"identifier": "setWaveFormatExtensible", "parameters": "(boolean b)", "modifiers": "public", "return": "void", "signature": "void setWaveFormatExtensible(boolean b)", "full_signature": "public void setWaveFormatExtensible(boolean b)", "class_method_signature": "WaveModule.setWaveFormatExtensible(boolean b)", "testcase": false, "constructor": false}, {"identifier": "initParse", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void initParse()", "full_signature": "@Override protected void initParse()", "class_method_signature": "WaveModule.initParse()", "testcase": false, "constructor": false}, {"identifier": "readChunk", "parameters": "(RepInfo info)", "modifiers": "protected", "return": "boolean", "signature": "boolean readChunk(RepInfo info)", "full_signature": "protected boolean readChunk(RepInfo info)", "class_method_signature": "WaveModule.readChunk(RepInfo info)", "testcase": false, "constructor": false}, {"identifier": "remainingDataInfo", "parameters": "(DataInputStream stream, RepInfo info,\n\t\t\t\t\t\t\t\t   long bytesToProcess, String chunkId)", "modifiers": "private", "return": "void", "signature": "void remainingDataInfo(DataInputStream stream, RepInfo info,\n\t\t\t\t\t\t\t\t   long bytesToProcess, String chunkId)", "full_signature": "private void remainingDataInfo(DataInputStream stream, RepInfo info,\n\t\t\t\t\t\t\t\t   long bytesToProcess, String chunkId)", "class_method_signature": "WaveModule.remainingDataInfo(DataInputStream stream, RepInfo info,\n\t\t\t\t\t\t\t\t   long bytesToProcess, String chunkId)", "testcase": false, "constructor": false}, {"identifier": "getBytesRemaining", "parameters": "()", "modifiers": "private", "return": "long", "signature": "long getBytesRemaining()", "full_signature": "private long getBytesRemaining()", "class_method_signature": "WaveModule.getBytesRemaining()", "testcase": false, "constructor": false}, {"identifier": "getAESMetadata", "parameters": "()", "modifiers": "public", "return": "AESAudioMetadata", "signature": "AESAudioMetadata getAESMetadata()", "full_signature": "public AESAudioMetadata getAESMetadata()", "class_method_signature": "WaveModule.getAESMetadata()", "testcase": false, "constructor": false}, {"identifier": "dupChunkError", "parameters": "(RepInfo info, String chunkName)", "modifiers": "protected", "return": "void", "signature": "void dupChunkError(RepInfo info, String chunkName)", "full_signature": "protected void dupChunkError(RepInfo info, String chunkName)", "class_method_signature": "WaveModule.dupChunkError(RepInfo info, String chunkName)", "testcase": false, "constructor": false}, {"identifier": "buildBitmaskProperty", "parameters": "(int val, String name,\n\t\t\tString[] oneValueNames, String[] zeroValueNames)", "modifiers": "public", "return": "Property", "signature": "Property buildBitmaskProperty(int val, String name,\n\t\t\tString[] oneValueNames, String[] zeroValueNames)", "full_signature": "public Property buildBitmaskProperty(int val, String name,\n\t\t\tString[] oneValueNames, String[] zeroValueNames)", "class_method_signature": "WaveModule.buildBitmaskProperty(int val, String name,\n\t\t\tString[] oneValueNames, String[] zeroValueNames)", "testcase": false, "constructor": false}, {"identifier": "hasExtendedDataSizes", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean hasExtendedDataSizes()", "full_signature": "public boolean hasExtendedDataSizes()", "class_method_signature": "WaveModule.hasExtendedDataSizes()", "testcase": false, "constructor": false}, {"identifier": "setExtendedRiffSize", "parameters": "(long size)", "modifiers": "public", "return": "void", "signature": "void setExtendedRiffSize(long size)", "full_signature": "public void setExtendedRiffSize(long size)", "class_method_signature": "WaveModule.setExtendedRiffSize(long size)", "testcase": false, "constructor": false}, {"identifier": "setExtendedSampleLength", "parameters": "(long length)", "modifiers": "public", "return": "void", "signature": "void setExtendedSampleLength(long length)", "full_signature": "public void setExtendedSampleLength(long length)", "class_method_signature": "WaveModule.setExtendedSampleLength(long length)", "testcase": false, "constructor": false}, {"identifier": "getExtendedSampleLength", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getExtendedSampleLength()", "full_signature": "public long getExtendedSampleLength()", "class_method_signature": "WaveModule.getExtendedSampleLength()", "testcase": false, "constructor": false}, {"identifier": "addExtendedChunkSize", "parameters": "(String chunkId, Long chunkSize)", "modifiers": "public", "return": "void", "signature": "void addExtendedChunkSize(String chunkId, Long chunkSize)", "full_signature": "public void addExtendedChunkSize(String chunkId, Long chunkSize)", "class_method_signature": "WaveModule.addExtendedChunkSize(String chunkId, Long chunkSize)", "testcase": false, "constructor": false}], "file": "jhove-modules/wave-hul/src/main/java/edu/harvard/hul/ois/jhove/module/WaveModule.java"}, "focal_method": {"identifier": "parse", "parameters": "(InputStream stream, RepInfo info, int parseIndex)", "modifiers": "@Override public", "return": "int", "body": "@Override\n\tpublic int parse(InputStream stream, RepInfo info, int parseIndex) {\n\t\tinitParse();\n\t\tinfo.setModule(this);\n\n\t\t_aesMetadata.setPrimaryIdentifier(info.getUri());\n\t\tif (info.getURLFlag()) {\n\t\t\t_aesMetadata.setOtherPrimaryIdentifierType(\"URI\");\n\t\t} else {\n\t\t\t_aesMetadata.setPrimaryIdentifierType(AESAudioMetadata.FILE_NAME);\n\t\t}\n\n\t\t// We may have already done the checksums\n\t\t// while converting a temporary file.\n\t\tsetupDataStream(stream, info);\n\n\t\ttry {\n\t\t\t// Check the start of the file for the right opening bytes\n\t\t\tString firstFourChars = read4Chars(_dstream);\n\t\t\tif (firstFourChars.equals(RF64_SIGNATURE)) {\n\t\t\t\tinfo.setProfile(\"RF64\");\n\t\t\t\tflagRF64 = true;\n\t\t\t} else if (!firstFourChars.equals(RIFF_SIGNATURE)) {\n\t\t\t\tinfo.setMessage(\n\t\t\t\t\t\tnew ErrorMessage(MessageConstants.WAVE_HUL_1, 0));\n\t\t\t\tinfo.setWellFormed(false);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// Get the length of the Form chunk. This includes all\n\t\t\t// subsequent form fields and form subchunks, but excludes\n\t\t\t// the form chunk's header (its ID and the its length).\n\t\t\triffSize = readUnsignedInt(_dstream);\n\n\t\t\t// Read the RIFF form type\n\t\t\tString formType = read4Chars(_dstream);\n\t\t\tif (!\"WAVE\".equals(formType)) {\n\t\t\t\tinfo.setMessage(new ErrorMessage(\n\t\t\t\t\t\tMessageConstants.WAVE_HUL_2,\n\t\t\t\t\t\t_nByte - RIFF_FORM_TYPE_LENGTH));\n\t\t\t\tinfo.setWellFormed(false);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// If we get this far, the signature is OK.\n\t\t\tinfo.setSigMatch(_name);\n\t\t\tinfo.setFormat(_format[0]);\n\t\t\tinfo.setMimeType(_mimeType[0]);\n\n\t\t\tif (flagRF64) {\n\t\t\t\t// For RF64 files the first chunk should be a Data Size 64 chunk\n\t\t\t\t// containing the extended data sizes for a number of elements.\n\t\t\t\tif (readChunk(info) && dataSize64ChunkSeen) {\n\t\t\t\t\tif (riffSize == LOOKUP_EXTENDED_DATA_SIZE) {\n\t\t\t\t\t\t// Even though RF64 can support files larger than\n\t\t\t\t\t\t// Long.MAX_VALUE, this module currently does not.\n\t\t\t\t\t\tif (Long.compareUnsigned(extendedRiffSize,\n\t\t\t\t\t\t\t\tLong.MAX_VALUE) > 0) {\n\t\t\t\t\t\t\tinfo.setMessage(new InfoMessage(\n\t\t\t\t\t\t\t\t\tMessageConstants.WAVE_HUL_22));\n\t\t\t\t\t\t\tinfo.setWellFormed(RepInfo.UNDETERMINED);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinfo.setMessage(new ErrorMessage(\n\t\t\t\t\t\t\tMessageConstants.WAVE_HUL_23,\n\t\t\t\t\t\t\tChunk.HEADER_LENGTH + RIFF_FORM_TYPE_LENGTH));\n\t\t\t\t\tinfo.setWellFormed(false);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (getBytesRemaining() > 0) {\n\t\t\t\tif (!readChunk(info)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getBytesRemaining() > 0) {\n\t\t\t\t// The file has been truncated or there\n\t\t\t\t// remains unexpected chunk data to skip\n\t\t\t\tremainingDataInfo(_dstream, info, getBytesRemaining(),\n\t\t\t\t\t\tfirstFourChars);\n\t\t\t}\n\n\t\t} catch (EOFException eofe) {\n\t\t\tinfo.setWellFormed(false);\n\t\t\tString subMessage = String.format(\n\t\t\t\t\tMessageConstants.WAVE_HUL_3_SUB.getMessage(),\n\t\t\t\t\tgetBytesRemaining());\n\t\t\tif (eofe.getMessage() != null) {\n\t\t\t\tsubMessage += \"; \" + eofe.getMessage();\n\t\t\t}\n\t\t\tinfo.setMessage(new ErrorMessage(MessageConstants.WAVE_HUL_3,\n\t\t\t\t\tsubMessage, _nByte));\n\t\t} catch (Exception e) { // TODO make this more specific\n\t\t\te.printStackTrace();\n\t\t\tinfo.setWellFormed(false);\n\t\t\tJhoveMessage message = JhoveMessages.getMessageInstance(\n\t\t\t\t\tMessageConstants.WAVE_HUL_4.getId(),\n\t\t\t\t\tString.format(MessageConstants.WAVE_HUL_4.getMessage(),\n\t\t\t\t\t\t\te.getClass().getName() + \", \" + e.getMessage()));\n\t\t\tinfo.setMessage(new ErrorMessage(message, _nByte));\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Set duration from number of samples and rate.\n\t\tif (sampleCount > 0) {\n\t\t\t_aesMetadata.setDuration(sampleCount);\n\t\t}\n\n\t\t// Add note and label properties, if there's anything to report.\n\t\tif (!_labels.isEmpty()) {\n\t\t\t_propList.add(new Property(\"Labels\", PropertyType.PROPERTY,\n\t\t\t\t\tPropertyArity.LIST, _labels));\n\t\t}\n\t\tif (!_labeledText.isEmpty()) {\n\t\t\t_propList.add(new Property(\"LabeledText\", PropertyType.PROPERTY,\n\t\t\t\t\tPropertyArity.LIST, _labeledText));\n\t\t}\n\t\tif (!_notes.isEmpty()) {\n\t\t\t_propList.add(new Property(\"Notes\", PropertyType.PROPERTY,\n\t\t\t\t\tPropertyArity.LIST, _notes));\n\t\t}\n\t\tif (!_samples.isEmpty()) {\n\t\t\t_propList.add(new Property(\"Samples\", PropertyType.PROPERTY,\n\t\t\t\t\tPropertyArity.LIST, _samples));\n\t\t}\n\t\tif (_exifInfo != null) {\n\t\t\t_propList.add(_exifInfo.buildProperty());\n\t\t}\n\n\t\tif (!formatChunkSeen) {\n\t\t\tinfo.setMessage(new ErrorMessage(MessageConstants.WAVE_HUL_5));\n\t\t\tinfo.setWellFormed(false);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!dataChunkSeen) {\n\t\t\tinfo.setMessage(new ErrorMessage(MessageConstants.WAVE_HUL_24));\n\t\t\tinfo.setWellFormed(false);\n\t\t\treturn 0;\n\t\t}\n\n\t\t// This file looks OK.\n\t\tif (_ckSummer != null) {\n\t\t\tskipDstreamToEnd(info);\n\t\t\t// Set the checksums in the report if they're calculated\n\t\t\tsetChecksums(this._ckSummer, info);\n\t\t}\n\n\t\tinfo.setProperty(_metadata);\n\n\t\t// Indicate satisfied profiles.\n\t\tif (flagPCMWaveFormat) {\n\t\t\tinfo.setProfile(\"PCMWAVEFORMAT\");\n\t\t}\n\t\tif (flagWaveFormatEx) {\n\t\t\tinfo.setProfile(\"WAVEFORMATEX\");\n\t\t}\n\t\tif (flagWaveFormatExtensible) {\n\t\t\tinfo.setProfile(\"WAVEFORMATEXTENSIBLE\");\n\t\t}\n\t\tif (broadcastExtChunkSeen && (\n                        (waveCodec == FormatChunk.WAVE_FORMAT_MPEG && factChunkSeen)\n                        || waveCodec == FormatChunk.WAVE_FORMAT_PCM)) {\n                    info.setProfile(\"BWF\");\n\t\t}\n                return 0;\n\t}", "signature": "int parse(InputStream stream, RepInfo info, int parseIndex)", "full_signature": "@Override public int parse(InputStream stream, RepInfo info, int parseIndex)", "class_method_signature": "WaveModule.parse(InputStream stream, RepInfo info, int parseIndex)", "testcase": false, "constructor": false, "invocations": ["initParse", "setModule", "setPrimaryIdentifier", "getUri", "getURLFlag", "setOtherPrimaryIdentifierType", "setPrimaryIdentifierType", "setupDataStream", "read4Chars", "equals", "setProfile", "equals", "setMessage", "setWellFormed", "readUnsignedInt", "read4Chars", "equals", "setMessage", "setWellFormed", "setSigMatch", "setFormat", "setMimeType", "readChunk", "compareUnsigned", "setMessage", "setWellFormed", "setMessage", "setWellFormed", "getBytesRemaining", "readChunk", "getBytesRemaining", "remainingDataInfo", "getBytesRemaining", "setWellFormed", "format", "getMessage", "getBytesRemaining", "getMessage", "getMessage", "setMessage", "printStackTrace", "setWellFormed", "getMessageInstance", "getId", "format", "getMessage", "getName", "getClass", "getMessage", "setMessage", "setDuration", "isEmpty", "add", "isEmpty", "add", "isEmpty", "add", "isEmpty", "add", "add", "buildProperty", "setMessage", "setWellFormed", "setMessage", "setWellFormed", "skipDstreamToEnd", "setChecksums", "setProperty", "setProfile", "setProfile", "setProfile", "setProfile"]}, "repository": {"repo_id": 17627031, "url": "https://github.com/openpreserve/jhove", "stars": 91, "created": "3/11/2014 10:47:10 AM +00:00", "updates": "2020-01-24T19:19:11+00:00", "fork": "False", "license": "licensed"}}