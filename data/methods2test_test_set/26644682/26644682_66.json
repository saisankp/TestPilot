{"test_class": {"identifier": "FormatAnalysisTest", "superclass": "extends DataSetBaseTest", "interfaces": "", "fields": [{"original_string": "@Autowired\n    FormatAnalysis formatAnalysis;", "modifier": "@Autowired", "type": "FormatAnalysis", "declarator": "formatAnalysis", "var_name": "formatAnalysis"}], "file": "dataprep-dataset/src/test/java/org/talend/dataprep/dataset/service/analysis/synchronous/FormatAnalysisTest.java"}, "test_case": {"identifier": "testEncodingDetection", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testEncodingDetection() {\n        String id = UUID.randomUUID().toString();\n        final DataSetMetadata metadata = metadataBuilder.metadata().id(id).build();\n        dataSetMetadataRepository.save(metadata);\n        contentStore.storeAsRaw(metadata, DataSetServiceTest.class.getResourceAsStream(\"../wave_lab_utf16_LE.txt\"));\n        formatAnalysis.analyze(id);\n        final DataSetMetadata actual = dataSetMetadataRepository.get(id);\n        assertThat(actual, notNullValue());\n        assertThat(actual.getContent().getFormatFamilyId(), is(CSVFormatFamily.BEAN_ID));\n        assertThat(actual.getContent().getMediaType(), is(\"text/csv\"));\n        assertThat(actual.getContent().getParameters().get(\"SEPARATOR\"), is(\"\\t\"));\n        assertThat(actual.getEncoding(), is(\"UTF-16LE\"));\n    }", "signature": "void testEncodingDetection()", "full_signature": "@Test public void testEncodingDetection()", "class_method_signature": "FormatAnalysisTest.testEncodingDetection()", "testcase": true, "constructor": false, "invocations": ["toString", "randomUUID", "build", "id", "metadata", "save", "storeAsRaw", "getResourceAsStream", "analyze", "get", "assertThat", "notNullValue", "assertThat", "getFormatFamilyId", "getContent", "is", "assertThat", "getMediaType", "getContent", "is", "assertThat", "get", "getParameters", "getContent", "is", "assertThat", "getEncoding", "is"]}, "focal_class": {"identifier": "FormatAnalysis", "superclass": "", "interfaces": "implements SynchronousDataSetAnalyzer", "fields": [{"original_string": "private static final byte[] NO_BOM = {};", "modifier": "private static final", "type": "byte[]", "declarator": "NO_BOM = {}", "var_name": "NO_BOM"}, {"original_string": "private static final byte[] UTF_16_LE_BOM = { (byte) 0xFF, (byte) 0xFE };", "modifier": "private static final", "type": "byte[]", "declarator": "UTF_16_LE_BOM = { (byte) 0xFF, (byte) 0xFE }", "var_name": "UTF_16_LE_BOM"}, {"original_string": "private static final byte[] UTF_16_BE_BOM = { (byte) 0xFE, (byte) 0xFF };", "modifier": "private static final", "type": "byte[]", "declarator": "UTF_16_BE_BOM = { (byte) 0xFE, (byte) 0xFF }", "var_name": "UTF_16_BE_BOM"}, {"original_string": "private static final byte[] UTF_32_LE_BOM = { (byte) 0xFE, (byte) 0xFF, (byte) 0x00, (byte) 0x00 };", "modifier": "private static final", "type": "byte[]", "declarator": "UTF_32_LE_BOM = { (byte) 0xFE, (byte) 0xFF, (byte) 0x00, (byte) 0x00 }", "var_name": "UTF_32_LE_BOM"}, {"original_string": "private static final byte[] UTF_32_BE_BOM = { (byte) 0x00, (byte) 0x00, (byte) 0xFE, (byte) 0xFF };", "modifier": "private static final", "type": "byte[]", "declarator": "UTF_32_BE_BOM = { (byte) 0x00, (byte) 0x00, (byte) 0xFE, (byte) 0xFF }", "var_name": "UTF_32_BE_BOM"}, {"original_string": "private static final byte[] UTF_8_BOM = { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF };", "modifier": "private static final", "type": "byte[]", "declarator": "UTF_8_BOM = { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF }", "var_name": "UTF_8_BOM"}, {"original_string": "private static final byte[][] BOMS =\n            { NO_BOM, UTF_16_LE_BOM, UTF_16_BE_BOM, UTF_32_LE_BOM, UTF_32_BE_BOM, UTF_8_BOM };", "modifier": "private static final", "type": "byte[][]", "declarator": "BOMS =\n            { NO_BOM, UTF_16_LE_BOM, UTF_16_BE_BOM, UTF_32_LE_BOM, UTF_32_BE_BOM, UTF_8_BOM }", "var_name": "BOMS"}, {"original_string": "private static final Logger LOG = LoggerFactory.getLogger(FormatAnalysis.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(FormatAnalysis.class)", "var_name": "LOG"}, {"original_string": "@Autowired\n    private DataSetMetadataRepository repository;", "modifier": "@Autowired\n    private", "type": "DataSetMetadataRepository", "declarator": "repository", "var_name": "repository"}, {"original_string": "@Autowired\n    private ContentStoreRouter store;", "modifier": "@Autowired\n    private", "type": "ContentStoreRouter", "declarator": "store", "var_name": "store"}, {"original_string": "@Autowired\n    private FormatFamilyFactory formatFamilyFactory;", "modifier": "@Autowired\n    private", "type": "FormatFamilyFactory", "declarator": "formatFamilyFactory", "var_name": "formatFamilyFactory"}, {"original_string": "@Autowired\n    private CompositeFormatDetector detector;", "modifier": "@Autowired\n    private", "type": "CompositeFormatDetector", "declarator": "detector", "var_name": "detector"}], "methods": [{"identifier": "analyze", "parameters": "(String dataSetId)", "modifiers": "@Override public", "return": "void", "signature": "void analyze(String dataSetId)", "full_signature": "@Override public void analyze(String dataSetId)", "class_method_signature": "FormatAnalysis.analyze(String dataSetId)", "testcase": false, "constructor": false}, {"identifier": "verifyFormat", "parameters": "(Format detectedFormat)", "modifiers": "private", "return": "void", "signature": "void verifyFormat(Format detectedFormat)", "full_signature": "private void verifyFormat(Format detectedFormat)", "class_method_signature": "FormatAnalysis.verifyFormat(Format detectedFormat)", "testcase": false, "constructor": false}, {"identifier": "internalUpdateMetadata", "parameters": "(DataSetMetadata updatedMetadata, Format format)", "modifiers": "private", "return": "void", "signature": "void internalUpdateMetadata(DataSetMetadata updatedMetadata, Format format)", "full_signature": "private void internalUpdateMetadata(DataSetMetadata updatedMetadata, Format format)", "class_method_signature": "FormatAnalysis.internalUpdateMetadata(DataSetMetadata updatedMetadata, Format format)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(DataSetMetadata original, DataSetMetadata updated)", "modifiers": "public", "return": "void", "signature": "void update(DataSetMetadata original, DataSetMetadata updated)", "full_signature": "public void update(DataSetMetadata original, DataSetMetadata updated)", "class_method_signature": "FormatAnalysis.update(DataSetMetadata original, DataSetMetadata updated)", "testcase": false, "constructor": false}, {"identifier": "parseColumnNameInformation", "parameters": "(String dataSetId, DataSetMetadata metadata, Format format)", "modifiers": "private", "return": "void", "signature": "void parseColumnNameInformation(String dataSetId, DataSetMetadata metadata, Format format)", "full_signature": "private void parseColumnNameInformation(String dataSetId, DataSetMetadata metadata, Format format)", "class_method_signature": "FormatAnalysis.parseColumnNameInformation(String dataSetId, DataSetMetadata metadata, Format format)", "testcase": false, "constructor": false}, {"identifier": "order", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int order()", "full_signature": "@Override public int order()", "class_method_signature": "FormatAnalysis.order()", "testcase": false, "constructor": false}, {"identifier": "addBOM", "parameters": "(InputStream stream, byte[] bom)", "modifiers": "private", "return": "InputStream", "signature": "InputStream addBOM(InputStream stream, byte[] bom)", "full_signature": "private InputStream addBOM(InputStream stream, byte[] bom)", "class_method_signature": "FormatAnalysis.addBOM(InputStream stream, byte[] bom)", "testcase": false, "constructor": false}], "file": "dataprep-dataset/src/main/java/org/talend/dataprep/dataset/service/analysis/synchronous/FormatAnalysis.java"}, "focal_method": {"identifier": "analyze", "parameters": "(String dataSetId)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void analyze(String dataSetId) {\n\n        if (StringUtils.isEmpty(dataSetId)) {\n            throw new IllegalArgumentException(\"Data set id cannot be null or empty.\");\n        }\n\n        final Marker marker = Markers.dataset(dataSetId);\n\n        DistributedLock datasetLock = repository.createDatasetMetadataLock(dataSetId);\n        datasetLock.lock();\n        try {\n            DataSetMetadata metadata = repository.get(dataSetId);\n            if (metadata != null) {\n\n                Format detectedFormat = null;\n                for (byte[] bom : BOMS) {\n                    try (InputStream content = store.getAsRaw(metadata, 10)) { // 10 line should be enough to detect format\n\n                        detectedFormat = detector.detect(addBOM(content, bom));\n                    } catch (IOException e) {\n                        throw new TDPException(DataSetErrorCodes.UNABLE_TO_READ_DATASET_CONTENT, e);\n                    }\n                    if (detectedFormat != null\n                            && !(detectedFormat.getFormatFamily() instanceof UnsupportedFormatFamily)) {\n                        break;\n                    }\n                }\n\n                LOG.debug(marker, \"using {} to parse the dataset\", detectedFormat);\n\n                verifyFormat(detectedFormat);\n\n                internalUpdateMetadata(metadata, detectedFormat);\n\n                LOG.debug(marker, \"format analysed for dataset\");\n            } else {\n                LOG.info(marker, \"Data set no longer exists.\");\n            }\n        } finally {\n            datasetLock.unlock();\n        }\n    }", "signature": "void analyze(String dataSetId)", "full_signature": "@Override public void analyze(String dataSetId)", "class_method_signature": "FormatAnalysis.analyze(String dataSetId)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "dataset", "createDatasetMetadataLock", "lock", "get", "getAsRaw", "detect", "addBOM", "getFormatFamily", "debug", "verifyFormat", "internalUpdateMetadata", "debug", "info", "unlock"]}, "repository": {"repo_id": 26644682, "url": "https://github.com/Talend/data-prep", "language": "Java", "is_fork": false, "fork_count": 29, "stargazer_count": 53, "size": 70450, "license": "licensed"}}