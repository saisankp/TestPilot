{"test_class": {"identifier": "ImgscalrImageManipulatorTest", "superclass": "extends AbstractImageTest", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(ImgscalrImageManipulatorTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(ImgscalrImageManipulatorTest.class)", "var_name": "log"}, {"original_string": "private ImgscalrImageManipulator manipulator;", "modifier": "private", "type": "ImgscalrImageManipulator", "declarator": "manipulator", "var_name": "manipulator"}], "file": "services/image-imgscalr/src/test/java/com/gentics/mesh/image/ImgscalrImageManipulatorTest.java"}, "test_case": {"identifier": "testResizeImage", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testResizeImage() {\n\t\t// Width only\n\t\tBufferedImage bi = new BufferedImage(100, 200, BufferedImage.TYPE_INT_ARGB);\n\t\tbi = manipulator.resizeIfRequested(bi, new ImageManipulationParametersImpl().setWidth(200));\n\t\tassertEquals(200, bi.getWidth());\n\t\tassertEquals(400, bi.getHeight());\n\n\t\t// Same width\n\t\tbi = new BufferedImage(100, 200, BufferedImage.TYPE_INT_ARGB);\n\t\tBufferedImage outputImage = manipulator.resizeIfRequested(bi, new ImageManipulationParametersImpl().setWidth(100));\n\t\tassertEquals(100, bi.getWidth());\n\t\tassertEquals(200, bi.getHeight());\n\t\tassertEquals(\"The image should not have been resized since the parameters match the source image dimension.\", bi.hashCode(), outputImage\n\t\t\t.hashCode());\n\n\t\t// Height only\n\t\tbi = new BufferedImage(100, 200, BufferedImage.TYPE_INT_ARGB);\n\t\tbi = manipulator.resizeIfRequested(bi, new ImageManipulationParametersImpl().setHeight(50));\n\t\tassertEquals(25, bi.getWidth());\n\t\tassertEquals(50, bi.getHeight());\n\n\t\t// Same height\n\t\tbi = new BufferedImage(100, 200, BufferedImage.TYPE_INT_ARGB);\n\t\toutputImage = manipulator.resizeIfRequested(bi, new ImageManipulationParametersImpl().setHeight(200));\n\t\tassertEquals(100, bi.getWidth());\n\t\tassertEquals(200, bi.getHeight());\n\t\tassertEquals(\"The image should not have been resized since the parameters match the source image dimension.\", bi.hashCode(), outputImage\n\t\t\t.hashCode());\n\n\t\t// Height and Width\n\t\tbi = new BufferedImage(100, 200, BufferedImage.TYPE_INT_ARGB);\n\t\tbi = manipulator.resizeIfRequested(bi, new ImageManipulationParametersImpl().setWidth(200).setHeight(300));\n\t\tassertEquals(200, bi.getWidth());\n\t\tassertEquals(300, bi.getHeight());\n\n\t\t// No parameters\n\t\tbi = new BufferedImage(100, 200, BufferedImage.TYPE_INT_ARGB);\n\t\toutputImage = manipulator.resizeIfRequested(bi, new ImageManipulationParametersImpl());\n\t\tassertEquals(100, outputImage.getWidth());\n\t\tassertEquals(200, outputImage.getHeight());\n\t\tassertEquals(\"The image should not have been resized since no parameters were set.\", bi.hashCode(), outputImage.hashCode());\n\n\t\t// Same height / width\n\t\tbi = new BufferedImage(100, 200, BufferedImage.TYPE_INT_ARGB);\n\t\toutputImage = manipulator.resizeIfRequested(bi, new ImageManipulationParametersImpl().setWidth(100).setHeight(200));\n\t\tassertEquals(100, bi.getWidth());\n\t\tassertEquals(200, bi.getHeight());\n\t\tassertEquals(\"The image should not have been resized since the parameters match the source image dimension.\", bi.hashCode(), outputImage\n\t\t\t.hashCode());\n\n\t}", "signature": "void testResizeImage()", "full_signature": "@Test public void testResizeImage()", "class_method_signature": "ImgscalrImageManipulatorTest.testResizeImage()", "testcase": true, "constructor": false, "invocations": ["resizeIfRequested", "setWidth", "assertEquals", "getWidth", "assertEquals", "getHeight", "resizeIfRequested", "setWidth", "assertEquals", "getWidth", "assertEquals", "getHeight", "assertEquals", "hashCode", "hashCode", "resizeIfRequested", "setHeight", "assertEquals", "getWidth", "assertEquals", "getHeight", "resizeIfRequested", "setHeight", "assertEquals", "getWidth", "assertEquals", "getHeight", "assertEquals", "hashCode", "hashCode", "resizeIfRequested", "setHeight", "setWidth", "assertEquals", "getWidth", "assertEquals", "getHeight", "resizeIfRequested", "assertEquals", "getWidth", "assertEquals", "getHeight", "assertEquals", "hashCode", "hashCode", "resizeIfRequested", "setHeight", "setWidth", "assertEquals", "getWidth", "assertEquals", "getHeight", "assertEquals", "hashCode", "hashCode"]}, "focal_class": {"identifier": "ImgscalrImageManipulator", "superclass": "extends AbstractImageManipulator", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(ImgscalrImageManipulator.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(ImgscalrImageManipulator.class)", "var_name": "log"}, {"original_string": "private FocalPointModifier focalPointModifier;", "modifier": "private", "type": "FocalPointModifier", "declarator": "focalPointModifier", "var_name": "focalPointModifier"}, {"original_string": "private WorkerExecutor workerPool;", "modifier": "private", "type": "WorkerExecutor", "declarator": "workerPool", "var_name": "workerPool"}, {"original_string": "private final BootstrapInitializer boot;", "modifier": "private final", "type": "BootstrapInitializer", "declarator": "boot", "var_name": "boot"}], "methods": [{"identifier": "ImgscalrImageManipulator", "parameters": "(Vertx vertx, MeshOptions options, BootstrapInitializer boot)", "modifiers": "public", "return": "", "signature": " ImgscalrImageManipulator(Vertx vertx, MeshOptions options, BootstrapInitializer boot)", "full_signature": "public  ImgscalrImageManipulator(Vertx vertx, MeshOptions options, BootstrapInitializer boot)", "class_method_signature": "ImgscalrImageManipulator.ImgscalrImageManipulator(Vertx vertx, MeshOptions options, BootstrapInitializer boot)", "testcase": false, "constructor": true}, {"identifier": "ImgscalrImageManipulator", "parameters": "(Vertx vertx, ImageManipulatorOptions options, BootstrapInitializer boot)", "modifiers": "", "return": "", "signature": " ImgscalrImageManipulator(Vertx vertx, ImageManipulatorOptions options, BootstrapInitializer boot)", "full_signature": "  ImgscalrImageManipulator(Vertx vertx, ImageManipulatorOptions options, BootstrapInitializer boot)", "class_method_signature": "ImgscalrImageManipulator.ImgscalrImageManipulator(Vertx vertx, ImageManipulatorOptions options, BootstrapInitializer boot)", "testcase": false, "constructor": true}, {"identifier": "crop", "parameters": "(BufferedImage originalImage, ImageRect cropArea)", "modifiers": "protected", "return": "BufferedImage", "signature": "BufferedImage crop(BufferedImage originalImage, ImageRect cropArea)", "full_signature": "protected BufferedImage crop(BufferedImage originalImage, ImageRect cropArea)", "class_method_signature": "ImgscalrImageManipulator.crop(BufferedImage originalImage, ImageRect cropArea)", "testcase": false, "constructor": false}, {"identifier": "resizeIfRequested", "parameters": "(BufferedImage originalImage, ImageManipulationParameters parameters)", "modifiers": "protected", "return": "BufferedImage", "signature": "BufferedImage resizeIfRequested(BufferedImage originalImage, ImageManipulationParameters parameters)", "full_signature": "protected BufferedImage resizeIfRequested(BufferedImage originalImage, ImageManipulationParameters parameters)", "class_method_signature": "ImgscalrImageManipulator.resizeIfRequested(BufferedImage originalImage, ImageManipulationParameters parameters)", "testcase": false, "constructor": false}, {"identifier": "getImageReader", "parameters": "(ImageInputStream input)", "modifiers": "private", "return": "ImageReader", "signature": "ImageReader getImageReader(ImageInputStream input)", "full_signature": "private ImageReader getImageReader(ImageInputStream input)", "class_method_signature": "ImgscalrImageManipulator.getImageReader(ImageInputStream input)", "testcase": false, "constructor": false}, {"identifier": "getImageWriter", "parameters": "(ImageReader reader, ImageOutputStream out)", "modifiers": "private", "return": "ImageWriter", "signature": "ImageWriter getImageWriter(ImageReader reader, ImageOutputStream out)", "full_signature": "private ImageWriter getImageWriter(ImageReader reader, ImageOutputStream out)", "class_method_signature": "ImgscalrImageManipulator.getImageWriter(ImageReader reader, ImageOutputStream out)", "testcase": false, "constructor": false}, {"identifier": "cropAndResize", "parameters": "(BufferedImage image, ImageManipulationParameters parameters)", "modifiers": "protected", "return": "BufferedImage", "signature": "BufferedImage cropAndResize(BufferedImage image, ImageManipulationParameters parameters)", "full_signature": "protected BufferedImage cropAndResize(BufferedImage image, ImageManipulationParameters parameters)", "class_method_signature": "ImgscalrImageManipulator.cropAndResize(BufferedImage image, ImageManipulationParameters parameters)", "testcase": false, "constructor": false}, {"identifier": "handleResize", "parameters": "(Binary binary, ImageManipulationParameters parameters)", "modifiers": "@Override public", "return": "Single<String>", "signature": "Single<String> handleResize(Binary binary, ImageManipulationParameters parameters)", "full_signature": "@Override public Single<String> handleResize(Binary binary, ImageManipulationParameters parameters)", "class_method_signature": "ImgscalrImageManipulator.handleResize(Binary binary, ImageManipulationParameters parameters)", "testcase": false, "constructor": false}, {"identifier": "getImageWriteparams", "parameters": "(String extension)", "modifiers": "private", "return": "ImageWriteParam", "signature": "ImageWriteParam getImageWriteparams(String extension)", "full_signature": "private ImageWriteParam getImageWriteparams(String extension)", "class_method_signature": "ImgscalrImageManipulator.getImageWriteparams(String extension)", "testcase": false, "constructor": false}, {"identifier": "isJpeg", "parameters": "(String extension)", "modifiers": "private", "return": "boolean", "signature": "boolean isJpeg(String extension)", "full_signature": "private boolean isJpeg(String extension)", "class_method_signature": "ImgscalrImageManipulator.isJpeg(String extension)", "testcase": false, "constructor": false}, {"identifier": "calculateDominantColor", "parameters": "(BufferedImage image)", "modifiers": "@Override public", "return": "int[]", "signature": "int[] calculateDominantColor(BufferedImage image)", "full_signature": "@Override public int[] calculateDominantColor(BufferedImage image)", "class_method_signature": "ImgscalrImageManipulator.calculateDominantColor(BufferedImage image)", "testcase": false, "constructor": false}, {"identifier": "getMetadata", "parameters": "(InputStream ins)", "modifiers": "@Override public", "return": "Single<Map<String, String>>", "signature": "Single<Map<String, String>> getMetadata(InputStream ins)", "full_signature": "@Override public Single<Map<String, String>> getMetadata(InputStream ins)", "class_method_signature": "ImgscalrImageManipulator.getMetadata(InputStream ins)", "testcase": false, "constructor": false}], "file": "services/image-imgscalr/src/main/java/com/gentics/mesh/image/ImgscalrImageManipulator.java"}, "focal_method": {"identifier": "resizeIfRequested", "parameters": "(BufferedImage originalImage, ImageManipulationParameters parameters)", "modifiers": "protected", "return": "BufferedImage", "body": "protected BufferedImage resizeIfRequested(BufferedImage originalImage, ImageManipulationParameters parameters) {\n\t\tint originalHeight = originalImage.getHeight();\n\t\tint originalWidth = originalImage.getWidth();\n\t\tdouble aspectRatio = (double) originalWidth / (double) originalHeight;\n\n\t\t// Resize if required and calculate missing parameters if needed\n\t\tInteger pHeight = NumberUtils.toInt(parameters.getHeight(), 0);\n\t\tInteger pWidth = NumberUtils.toInt(parameters.getWidth(), 0);\n\n\t\t// Resizing is only needed when one of the parameters has been specified\n\t\tif (pHeight != 0 || pWidth != 0) {\n\n\t\t\t// No operation needed when width is the same and no height was set\n\t\t\tif (pHeight == 0 && pWidth == originalWidth) {\n\t\t\t\treturn originalImage;\n\t\t\t}\n\n\t\t\t// No operation needed when height is the same and no width was set\n\t\t\tif (pWidth == 0 && pHeight == originalHeight) {\n\t\t\t\treturn originalImage;\n\t\t\t}\n\n\t\t\t// No operation needed when width and height match original image\n\t\t\tif (pWidth != 0 && pWidth == originalWidth && pHeight != 0 && pHeight == originalHeight) {\n\t\t\t\treturn originalImage;\n\t\t\t}\n\t\t\tResizeMode resizeMode = parameters.getResizeMode();\n\t\t\t// if the mode used is smart, and one of the dimensions is auto then set this dimension to the original Value\n\t\t\tif (resizeMode == ResizeMode.SMART) {\n\t\t\t\tif (parameters.getWidth() != null && parameters.getWidth().equals(\"auto\")) {\n\t\t\t\t\tpWidth = originalWidth;\n\t\t\t\t}\n\t\t\t\tif (parameters.getHeight() != null && parameters.getHeight().equals(\"auto\")) {\n\t\t\t\t\tpHeight = originalHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint width = pWidth == 0 ? (int) (pHeight * aspectRatio) : pWidth;\n\t\t\tint height = pHeight == 0 ? (int) (width / aspectRatio) : pHeight;\n\n\n\t\t\t// if we want to use smart resizing we need to crop the original image to the correct format before resizing to avoid distortion\n\t\t\tif (pWidth != 0 && pHeight != 0 && resizeMode == ResizeMode.SMART) {\n\n\t\t\t\tdouble pAspectRatio = (double) pWidth / (double) pHeight;\n\t\t\t\tif (aspectRatio != pAspectRatio) {\n\t\t\t\t\tif (aspectRatio < pAspectRatio) {\n\t\t\t\t\t\t// crop height (top & bottom)\n\t\t\t\t\t\tint resizeHeight = Math.max(1, (int) (originalWidth / pAspectRatio));\n\t\t\t\t\t\tint startY = (int) (originalHeight * 0.5 - resizeHeight * 0.5);\n\t\t\t\t\t\toriginalImage = crop(originalImage, new ImageRect(0, startY, resizeHeight, originalWidth));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// crop width (left & right)\n\t\t\t\t\t\tint resizeWidth = Math.max(1, (int) (originalHeight * pAspectRatio));\n\t\t\t\t\t\tint startX = (int) (originalWidth * 0.5 - resizeWidth * 0.5);\n\t\t\t\t\t\toriginalImage = crop(originalImage, new ImageRect(startX, 0, originalHeight, resizeWidth));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if we want to use proportional resizing we need to make sure the destination dimension fits inside the provided dimensions\n\t\t\tif (pWidth != 0 && pHeight != 0 && resizeMode == ResizeMode.PROP) {\n\t\t\t\tdouble pAspectRatio = (double) pWidth / (double) pHeight;\n\t\t\t\tif (aspectRatio < pAspectRatio) {\n\t\t\t\t\t// scale to pHeight\n\t\t\t\t\twidth = Math.max(1, (int) (pHeight * aspectRatio));\n\t\t\t\t\theight = Math.max(1, pHeight);\n\t\t\t\t} else {\n\t\t\t\t\t// scale to pWidth\n\t\t\t\t\twidth = Math.max(1, pWidth);\n\t\t\t\t\theight = Math.max(1, (int) (pWidth / aspectRatio));\n\t\t\t\t}\n\n\t\t\t\t// Should the resulting format be the same as the original image we do not need to resize\n\t\t\t\tif (width == originalWidth && height == originalHeight) {\n\t\t\t\t\treturn originalImage;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tBufferedImage image = Scalr.apply(originalImage, new ResampleOp(width, height, options.getResampleFilter().getFilter()));\n\t\t\t\toriginalImage.flush();\n\t\t\t\treturn image;\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tthrow error(BAD_REQUEST, \"image_error_resizing_failed\", e);\n\t\t\t}\n\t\t}\n\n\t\treturn originalImage;\n\t}", "signature": "BufferedImage resizeIfRequested(BufferedImage originalImage, ImageManipulationParameters parameters)", "full_signature": "protected BufferedImage resizeIfRequested(BufferedImage originalImage, ImageManipulationParameters parameters)", "class_method_signature": "ImgscalrImageManipulator.resizeIfRequested(BufferedImage originalImage, ImageManipulationParameters parameters)", "testcase": false, "constructor": false, "invocations": ["getHeight", "getWidth", "toInt", "getHeight", "toInt", "getWidth", "getResizeMode", "getWidth", "equals", "getWidth", "getHeight", "equals", "getHeight", "max", "crop", "max", "crop", "max", "max", "max", "max", "apply", "getFilter", "getResampleFilter", "flush", "error"]}, "repository": {"repo_id": 67999496, "url": "https://github.com/gentics/mesh", "stars": 412, "created": "9/12/2016 10:28:41 AM +00:00", "updates": "2020-01-27T10:25:42+00:00", "fork": "False", "license": "licensed"}}