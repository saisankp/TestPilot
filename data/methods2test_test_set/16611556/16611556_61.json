{"test_class": {"identifier": "UpdateMultiCacheAdviceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static UpdateMultiCacheAdvice cut;", "modifier": "private static", "type": "UpdateMultiCacheAdvice", "declarator": "cut", "var_name": "cut"}], "file": "simple-spring-memcached/src/test/java/com/google/code/ssm/aop/UpdateMultiCacheAdviceTest.java"}, "test_case": {"identifier": "testUpdateCache", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testUpdateCache() throws Exception {\n        final Method method = AnnotationTest.class.getMethod(\"cacheMe01\", List.class);\n        final UpdateMultiCache annotation = method.getAnnotation(UpdateMultiCache.class);\n        final AnnotationData data = AnnotationDataBuilder.buildAnnotationData(annotation, UpdateMultiCache.class, method);\n\n        final List<String> keys = new ArrayList<String>();\n        final List<Object> objs = new ArrayList<Object>();\n        keys.add(\"Key1-\" + System.currentTimeMillis());\n        keys.add(\"Key2-\" + System.currentTimeMillis());\n\n        try {\n            cut.updateCache(keys, objs, method, data, null);\n            fail(\"Expected Exception.\");\n        } catch (InvalidAnnotationException ex) {\n            assertTrue(ex.getMessage().contains(\"do not match in size\"));\n        }\n\n        final Cache cache = EasyMock.createMock(Cache.class);\n        EasyMock.expect(cache.getName()).andReturn(AnnotationConstants.DEFAULT_CACHE_NAME);\n        EasyMock.expect(cache.getAliases()).andReturn(Collections.<String> emptyList()).anyTimes();\n        EasyMock.expect(cache.getProperties()).andReturn(new CacheProperties()).anyTimes();\n        for (final String key : keys) {\n            final String value = \"ValueFor-\" + key;\n            objs.add(value);\n            cache.setSilently(key, data.getExpiration(), value, null);\n            EasyMock.expectLastCall();\n        }\n        keys.add(\"BigFatNull\");\n        objs.add(null);\n        cache.setSilently(keys.get(2), data.getExpiration(), new PertinentNegativeNull(), null);\n        EasyMock.expectLastCall();\n\n        EasyMock.replay(cache);\n\n        cut.getCacheBase().addCache(cache);\n        cut.updateCache(keys, objs, method, data, null);\n\n        EasyMock.verify(cache);\n    }", "signature": "void testUpdateCache()", "full_signature": "@Test public void testUpdateCache()", "class_method_signature": "UpdateMultiCacheAdviceTest.testUpdateCache()", "testcase": true, "constructor": false, "invocations": ["getMethod", "getAnnotation", "buildAnnotationData", "add", "currentTimeMillis", "add", "currentTimeMillis", "updateCache", "fail", "assertTrue", "contains", "getMessage", "createMock", "andReturn", "expect", "getName", "anyTimes", "andReturn", "expect", "getAliases", "emptyList", "anyTimes", "andReturn", "expect", "getProperties", "add", "setSilently", "getExpiration", "expectLastCall", "add", "add", "setSilently", "get", "getExpiration", "expectLastCall", "replay", "addCache", "getCacheBase", "updateCache", "verify"]}, "focal_class": {"identifier": "UpdateMultiCacheAdvice", "superclass": "extends MultiCacheAdvice", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(UpdateMultiCacheAdvice.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(UpdateMultiCacheAdvice.class)", "var_name": "LOG"}], "methods": [{"identifier": "updateMulti", "parameters": "()", "modifiers": "@Pointcut(\"@annotation(com.google.code.ssm.api.UpdateMultiCache)\") public", "return": "void", "signature": "void updateMulti()", "full_signature": "@Pointcut(\"@annotation(com.google.code.ssm.api.UpdateMultiCache)\") public void updateMulti()", "class_method_signature": "UpdateMultiCacheAdvice.updateMulti()", "testcase": false, "constructor": false}, {"identifier": "cacheUpdateMulti", "parameters": "(final JoinPoint jp, final Object retVal)", "modifiers": "@AfterReturning(pointcut = \"updateMulti()\", returning = \"retVal\") public", "return": "void", "signature": "void cacheUpdateMulti(final JoinPoint jp, final Object retVal)", "full_signature": "@AfterReturning(pointcut = \"updateMulti()\", returning = \"retVal\") public void cacheUpdateMulti(final JoinPoint jp, final Object retVal)", "class_method_signature": "UpdateMultiCacheAdvice.cacheUpdateMulti(final JoinPoint jp, final Object retVal)", "testcase": false, "constructor": false}, {"identifier": "convertIdObjectsToKeyMap", "parameters": "(final List<Object> idObjects, final AnnotationData data)", "modifiers": "", "return": "MapHolder", "signature": "MapHolder convertIdObjectsToKeyMap(final List<Object> idObjects, final AnnotationData data)", "full_signature": " MapHolder convertIdObjectsToKeyMap(final List<Object> idObjects, final AnnotationData data)", "class_method_signature": "UpdateMultiCacheAdvice.convertIdObjectsToKeyMap(final List<Object> idObjects, final AnnotationData data)", "testcase": false, "constructor": false}, {"identifier": "updateCache", "parameters": "(final List<String> cacheKeys, final List<Object> returnList, final Method methodToCache, final AnnotationData data,\n            final SerializationType serializationType)", "modifiers": "", "return": "void", "signature": "void updateCache(final List<String> cacheKeys, final List<Object> returnList, final Method methodToCache, final AnnotationData data,\n            final SerializationType serializationType)", "full_signature": " void updateCache(final List<String> cacheKeys, final List<Object> returnList, final Method methodToCache, final AnnotationData data,\n            final SerializationType serializationType)", "class_method_signature": "UpdateMultiCacheAdvice.updateCache(final List<String> cacheKeys, final List<Object> returnList, final Method methodToCache, final AnnotationData data,\n            final SerializationType serializationType)", "testcase": false, "constructor": false}, {"identifier": "updateCacheWithMissed", "parameters": "(final List<Object> dataUpdateContents, final MultiCacheCoordinator coord,\n            final UpdateMultiCacheOption option, final SerializationType serializationType)", "modifiers": "private", "return": "void", "signature": "void updateCacheWithMissed(final List<Object> dataUpdateContents, final MultiCacheCoordinator coord,\n            final UpdateMultiCacheOption option, final SerializationType serializationType)", "full_signature": "private void updateCacheWithMissed(final List<Object> dataUpdateContents, final MultiCacheCoordinator coord,\n            final UpdateMultiCacheOption option, final SerializationType serializationType)", "class_method_signature": "UpdateMultiCacheAdvice.updateCacheWithMissed(final List<Object> dataUpdateContents, final MultiCacheCoordinator coord,\n            final UpdateMultiCacheOption option, final SerializationType serializationType)", "testcase": false, "constructor": false}, {"identifier": "getLogger", "parameters": "()", "modifiers": "@Override protected", "return": "Logger", "signature": "Logger getLogger()", "full_signature": "@Override protected Logger getLogger()", "class_method_signature": "UpdateMultiCacheAdvice.getLogger()", "testcase": false, "constructor": false}], "file": "simple-spring-memcached/src/main/java/com/google/code/ssm/aop/UpdateMultiCacheAdvice.java"}, "focal_method": {"identifier": "updateCache", "parameters": "(final List<String> cacheKeys, final List<Object> returnList, final Method methodToCache, final AnnotationData data,\n            final SerializationType serializationType)", "modifiers": "", "return": "void", "body": "void updateCache(final List<String> cacheKeys, final List<Object> returnList, final Method methodToCache, final AnnotationData data,\n            final SerializationType serializationType) {\n        if (returnList.size() != cacheKeys.size()) {\n            throw new InvalidAnnotationException(String.format(\n                    \"The key generation objects, and the resulting objects do not match in size for [%s].\", methodToCache.toString()));\n        }\n\n        Iterator<Object> returnListIter = returnList.iterator();\n        Iterator<String> cacheKeyIter = cacheKeys.iterator();\n        String cacheKey;\n        Object result, cacheObject;\n        while (returnListIter.hasNext()) {\n            result = returnListIter.next();\n            cacheKey = cacheKeyIter.next();\n            cacheObject = getCacheBase().getSubmission(result);\n            getCacheBase().getCache(data).setSilently(cacheKey, data.getExpiration(), cacheObject, serializationType);\n        }\n    }", "signature": "void updateCache(final List<String> cacheKeys, final List<Object> returnList, final Method methodToCache, final AnnotationData data,\n            final SerializationType serializationType)", "full_signature": " void updateCache(final List<String> cacheKeys, final List<Object> returnList, final Method methodToCache, final AnnotationData data,\n            final SerializationType serializationType)", "class_method_signature": "UpdateMultiCacheAdvice.updateCache(final List<String> cacheKeys, final List<Object> returnList, final Method methodToCache, final AnnotationData data,\n            final SerializationType serializationType)", "testcase": false, "constructor": false, "invocations": ["size", "size", "format", "toString", "iterator", "iterator", "hasNext", "next", "next", "getSubmission", "getCacheBase", "setSilently", "getCache", "getCacheBase", "getExpiration"]}, "repository": {"repo_id": 16611556, "url": "https://github.com/ragnor/simple-spring-memcached", "language": "Java", "is_fork": false, "fork_count": 86, "stargazer_count": 181, "size": 3625, "license": "licensed"}}