{"test_class": {"identifier": "VanillaDataCacheTest", "superclass": "extends VanillaChronicleTestBase", "interfaces": "", "fields": [], "file": "chronicle/src/test/java/net/openhft/chronicle/VanillaDataCacheTest.java"}, "test_case": {"identifier": "testDataFor", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDataFor() throws Exception {\n        final String baseDir = getTestPath();\n        assertNotNull(baseDir);\n\n        final DateCache dateCache = new DateCache(\"yyyyMMddHHmmss\", 1000);\n        final VanillaDataCache cache = new VanillaDataCache(baseDir, 10 + 6, dateCache);\n\n        try {\n            int cycle = (int) (System.currentTimeMillis() / 1000);\n            VanillaMappedBytes vanillaBuffer0 = cache.dataFor(cycle, AffinitySupport.getThreadId(), 0, true);\n            vanillaBuffer0.writeLong(0, 0x12345678);\n            File file0 = cache.fileFor(cycle, AffinitySupport.getThreadId(), 0, true);\n            assertEquals(64 << 10, file0.length());\n            assertEquals(0x12345678L, vanillaBuffer0.readLong(0));\n            vanillaBuffer0.release();\n\n            VanillaMappedBytes vanillaBuffer1 = cache.dataFor(cycle, AffinitySupport.getThreadId(), 1, true);\n            File file1 = cache.fileFor(cycle, AffinitySupport.getThreadId(), 1, true);\n            assertEquals(64 << 10, file1.length());\n            vanillaBuffer1.release();\n            assertNotEquals(file1, file0);\n\n            VanillaMappedBytes vanillaBuffer2 = cache.dataFor(cycle, AffinitySupport.getThreadId(), 2, true);\n            File file2 = cache.fileFor(cycle, AffinitySupport.getThreadId(), 2, true);\n            assertEquals(64 << 10, file2.length());\n            vanillaBuffer2.release();\n\n            assertNotEquals(file2, file0);\n            assertNotEquals(file2, file1);\n            cache.close();\n\n            assertEquals(0, vanillaBuffer0.refCount());\n            assertEquals(0, vanillaBuffer1.refCount());\n            assertEquals(0, vanillaBuffer2.refCount());\n\n            // check you can delete after closing.\n            assertTrue(file0.delete());\n            assertTrue(file1.delete());\n            assertTrue(file2.delete());\n            assertTrue(file0.getParentFile().delete());\n\n            cache.checkCounts(1, 1);\n        } finally {\n            cache.close();\n            IOTools.deleteDir(baseDir);\n\n            assertFalse(new File(baseDir).exists());\n        }\n    }", "signature": "void testDataFor()", "full_signature": "@Test public void testDataFor()", "class_method_signature": "VanillaDataCacheTest.testDataFor()", "testcase": true, "constructor": false, "invocations": ["getTestPath", "assertNotNull", "currentTimeMillis", "dataFor", "getThreadId", "writeLong", "fileFor", "getThreadId", "assertEquals", "length", "assertEquals", "readLong", "release", "dataFor", "getThreadId", "fileFor", "getThreadId", "assertEquals", "length", "release", "assertNotEquals", "dataFor", "getThreadId", "fileFor", "getThreadId", "assertEquals", "length", "release", "assertNotEquals", "assertNotEquals", "close", "assertEquals", "refCount", "assertEquals", "refCount", "assertEquals", "refCount", "assertTrue", "delete", "assertTrue", "delete", "assertTrue", "delete", "assertTrue", "delete", "getParentFile", "checkCounts", "close", "deleteDir", "assertFalse", "exists"]}, "focal_class": {"identifier": "VanillaDataCache", "superclass": "", "interfaces": "implements Closeable", "fields": [{"original_string": "private static final String FILE_NAME_PREFIX = \"data-\";", "modifier": "private static final", "type": "String", "declarator": "FILE_NAME_PREFIX = \"data-\"", "var_name": "FILE_NAME_PREFIX"}, {"original_string": "private final String basePath;", "modifier": "private final", "type": "String", "declarator": "basePath", "var_name": "basePath"}, {"original_string": "private final DataKey key = new DataKey();", "modifier": "private final", "type": "DataKey", "declarator": "key = new DataKey()", "var_name": "key"}, {"original_string": "private final int blockBits;", "modifier": "private final", "type": "int", "declarator": "blockBits", "var_name": "blockBits"}, {"original_string": "private final DateCache dateCache;", "modifier": "private final", "type": "DateCache", "declarator": "dateCache", "var_name": "dateCache"}, {"original_string": "private final VanillaMappedCache<DataKey> cache;", "modifier": "private final", "type": "VanillaMappedCache<DataKey>", "declarator": "cache", "var_name": "cache"}], "methods": [{"identifier": "VanillaDataCache", "parameters": "(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache)", "modifiers": "public", "return": "", "signature": " VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache)", "full_signature": "public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache)", "class_method_signature": "VanillaDataCache.VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache)", "testcase": false, "constructor": true}, {"identifier": "VanillaDataCache", "parameters": "(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, @NotNull VanillaChronicleConfig config)", "modifiers": "public", "return": "", "signature": " VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, @NotNull VanillaChronicleConfig config)", "full_signature": "public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, @NotNull VanillaChronicleConfig config)", "class_method_signature": "VanillaDataCache.VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, @NotNull VanillaChronicleConfig config)", "testcase": false, "constructor": true}, {"identifier": "VanillaDataCache", "parameters": "(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity)", "modifiers": "public", "return": "", "signature": " VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity)", "full_signature": "public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity)", "class_method_signature": "VanillaDataCache.VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity)", "testcase": false, "constructor": true}, {"identifier": "VanillaDataCache", "parameters": "(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity, boolean cleanupOnClose)", "modifiers": "public", "return": "", "signature": " VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity, boolean cleanupOnClose)", "full_signature": "public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity, boolean cleanupOnClose)", "class_method_signature": "VanillaDataCache.VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity, boolean cleanupOnClose)", "testcase": false, "constructor": true}, {"identifier": "fileFor", "parameters": "(int cycle, int threadId, int dataCount, boolean forWrite)", "modifiers": "public", "return": "File", "signature": "File fileFor(int cycle, int threadId, int dataCount, boolean forWrite)", "full_signature": "public File fileFor(int cycle, int threadId, int dataCount, boolean forWrite)", "class_method_signature": "VanillaDataCache.fileFor(int cycle, int threadId, int dataCount, boolean forWrite)", "testcase": false, "constructor": false}, {"identifier": "fileFor", "parameters": "(int cycle, int threadId)", "modifiers": "public", "return": "File", "signature": "File fileFor(int cycle, int threadId)", "full_signature": "public File fileFor(int cycle, int threadId)", "class_method_signature": "VanillaDataCache.fileFor(int cycle, int threadId)", "testcase": false, "constructor": false}, {"identifier": "dataFor", "parameters": "(int cycle, int threadId, int dataCount, boolean forWrite)", "modifiers": "public synchronized", "return": "VanillaMappedBytes", "signature": "VanillaMappedBytes dataFor(int cycle, int threadId, int dataCount, boolean forWrite)", "full_signature": "public synchronized VanillaMappedBytes dataFor(int cycle, int threadId, int dataCount, boolean forWrite)", "class_method_signature": "VanillaDataCache.dataFor(int cycle, int threadId, int dataCount, boolean forWrite)", "testcase": false, "constructor": false}, {"identifier": "findEndOfData", "parameters": "(final VanillaMappedBytes buffer)", "modifiers": "private", "return": "void", "signature": "void findEndOfData(final VanillaMappedBytes buffer)", "full_signature": "private void findEndOfData(final VanillaMappedBytes buffer)", "class_method_signature": "VanillaDataCache.findEndOfData(final VanillaMappedBytes buffer)", "testcase": false, "constructor": false}, {"identifier": "nextWordAlignment", "parameters": "(int len)", "modifiers": "", "return": "int", "signature": "int nextWordAlignment(int len)", "full_signature": " int nextWordAlignment(int len)", "class_method_signature": "VanillaDataCache.nextWordAlignment(int len)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void close()", "full_signature": "@Override public synchronized void close()", "class_method_signature": "VanillaDataCache.close()", "testcase": false, "constructor": false}, {"identifier": "findNextDataCount", "parameters": "(int cycle, int threadId)", "modifiers": "public", "return": "int", "signature": "int findNextDataCount(int cycle, int threadId)", "full_signature": "public int findNextDataCount(int cycle, int threadId)", "class_method_signature": "VanillaDataCache.findNextDataCount(int cycle, int threadId)", "testcase": false, "constructor": false}, {"identifier": "checkCounts", "parameters": "(int min, int max)", "modifiers": "public", "return": "void", "signature": "void checkCounts(int min, int max)", "full_signature": "public void checkCounts(int min, int max)", "class_method_signature": "VanillaDataCache.checkCounts(int min, int max)", "testcase": false, "constructor": false}], "file": "chronicle/src/main/java/net/openhft/chronicle/VanillaDataCache.java"}, "focal_method": {"identifier": "dataFor", "parameters": "(int cycle, int threadId, int dataCount, boolean forWrite)", "modifiers": "public synchronized", "return": "VanillaMappedBytes", "body": "public synchronized VanillaMappedBytes dataFor(int cycle, int threadId, int dataCount, boolean forWrite) throws IOException {\n        key.cycle = cycle;\n        key.threadId = threadId;\n        key.dataCount = dataCount;\n\n        VanillaMappedBytes vmb = this.cache.get(key);\n        if(vmb == null) {\n            vmb = this.cache.put(\n                key.clone(),\n                VanillaChronicleUtils.mkFiles(\n                    basePath,\n                    dateCache.formatFor(cycle),\n                    FILE_NAME_PREFIX + threadId + \"-\" + dataCount,\n                    forWrite),\n                1L << blockBits,\n                dataCount);\n        }\n\n        vmb.reserve();\n\n        return vmb;\n    }", "signature": "VanillaMappedBytes dataFor(int cycle, int threadId, int dataCount, boolean forWrite)", "full_signature": "public synchronized VanillaMappedBytes dataFor(int cycle, int threadId, int dataCount, boolean forWrite)", "class_method_signature": "VanillaDataCache.dataFor(int cycle, int threadId, int dataCount, boolean forWrite)", "testcase": false, "constructor": false, "invocations": ["get", "put", "clone", "mkFiles", "formatFor", "reserve"]}, "repository": {"repo_id": 23783621, "url": "https://github.com/peter-lawrey/Java-Chronicle-OLD", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 33, "size": 1275, "license": "licensed"}}