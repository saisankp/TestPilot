{"test_class": {"identifier": "InductivePartialChargesTest", "superclass": "extends CDKTestCase", "interfaces": "", "fields": [{"original_string": "private static IAtomContainer mol;", "modifier": "private static", "type": "IAtomContainer", "declarator": "mol", "var_name": "mol"}], "file": "tool/charges/src/test/java/org/openscience/cdk/charges/InductivePartialChargesTest.java"}, "test_case": {"identifier": "testCalculateCharges_IAtomContainer", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCalculateCharges_IAtomContainer() throws java.lang.Exception {\n        double[] testResult = {0.197, -0.492, 0.051, 0.099, 0.099};\n        Point3d c_coord = new Point3d(1.392, 0.0, 0.0);\n        Point3d f_coord = new Point3d(0.0, 0.0, 0.0);\n        Point3d h1_coord = new Point3d(1.7439615035767404, 1.0558845107302222, 0.0);\n        Point3d h2_coord = new Point3d(1.7439615035767404, -0.5279422553651107, 0.914422809754875);\n        Point3d h3_coord = new Point3d(1.7439615035767402, -0.5279422553651113, -0.9144228097548747);\n\n        IAtomContainer mol = new AtomContainer(); // molecule is CF\n\n        Atom c = new Atom(\"C\");\n        mol.addAtom(c);\n        c.setPoint3d(c_coord);\n\n        Atom f = new Atom(\"F\");\n        mol.addAtom(f);\n        f.setPoint3d(f_coord);\n\n        Atom h1 = new Atom(\"H\");\n        mol.addAtom(h1);\n        h1.setPoint3d(h1_coord);\n\n        Atom h2 = new Atom(\"H\");\n        mol.addAtom(h2);\n        h2.setPoint3d(h2_coord);\n\n        Atom h3 = new Atom(\"H\");\n        mol.addAtom(h3);\n        h3.setPoint3d(h3_coord);\n\n        mol.addBond(0, 1, IBond.Order.SINGLE); // 1\n        mol.addBond(0, 2, IBond.Order.SINGLE); // 1\n        mol.addBond(0, 3, IBond.Order.SINGLE); // 1\n        mol.addBond(0, 4, IBond.Order.SINGLE); // 1\n        InductivePartialCharges ipc = new InductivePartialCharges();\n        ipc.assignInductivePartialCharges(mol);\n        for (int i = 0; i < mol.getAtomCount(); i++) {\n            Assert.assertEquals(testResult[i],\n                    ((Double) mol.getAtom(i).getProperty(\"InductivePartialCharge\")).doubleValue(), 0.1);\n            //logger.debug(\"CHARGE AT \" + ac.getAtomAt(i).getSymbol() + \" \" + ac.getAtomAt(i).getProperty(\"MMFF94charge\"));\n        }\n    }", "signature": "void testCalculateCharges_IAtomContainer()", "full_signature": "@Test public void testCalculateCharges_IAtomContainer()", "class_method_signature": "InductivePartialChargesTest.testCalculateCharges_IAtomContainer()", "testcase": true, "constructor": false, "invocations": ["addAtom", "setPoint3d", "addAtom", "setPoint3d", "addAtom", "setPoint3d", "addAtom", "setPoint3d", "addAtom", "setPoint3d", "addBond", "addBond", "addBond", "addBond", "assignInductivePartialCharges", "getAtomCount", "assertEquals", "doubleValue", "getProperty", "getAtom"]}, "focal_class": {"identifier": "InductivePartialCharges", "superclass": "", "interfaces": "implements IChargeCalculator", "fields": [{"original_string": "private static double[]     pauling;", "modifier": "private static", "type": "double[]", "declarator": "pauling", "var_name": "pauling"}, {"original_string": "private IsotopeFactory      ifac    = null;", "modifier": "private", "type": "IsotopeFactory", "declarator": "ifac    = null", "var_name": "ifac"}, {"original_string": "private AtomTypeFactory     factory = null;", "modifier": "private", "type": "AtomTypeFactory", "declarator": "factory = null", "var_name": "factory"}, {"original_string": "private static ILoggingTool logger  = LoggingToolFactory.createLoggingTool(InductivePartialCharges.class);", "modifier": "private static", "type": "ILoggingTool", "declarator": "logger  = LoggingToolFactory.createLoggingTool(InductivePartialCharges.class)", "var_name": "logger"}], "methods": [{"identifier": "InductivePartialCharges", "parameters": "()", "modifiers": "public", "return": "", "signature": " InductivePartialCharges()", "full_signature": "public  InductivePartialCharges()", "class_method_signature": "InductivePartialCharges.InductivePartialCharges()", "testcase": false, "constructor": true}, {"identifier": "assignInductivePartialCharges", "parameters": "(IAtomContainer ac)", "modifiers": "public", "return": "IAtomContainer", "signature": "IAtomContainer assignInductivePartialCharges(IAtomContainer ac)", "full_signature": "public IAtomContainer assignInductivePartialCharges(IAtomContainer ac)", "class_method_signature": "InductivePartialCharges.assignInductivePartialCharges(IAtomContainer ac)", "testcase": false, "constructor": false}, {"identifier": "calculateCharges", "parameters": "(IAtomContainer container)", "modifiers": "@Override public", "return": "void", "signature": "void calculateCharges(IAtomContainer container)", "full_signature": "@Override public void calculateCharges(IAtomContainer container)", "class_method_signature": "InductivePartialCharges.calculateCharges(IAtomContainer container)", "testcase": false, "constructor": false}, {"identifier": "getPaulingElectronegativities", "parameters": "(IAtomContainer ac, boolean modified)", "modifiers": "public", "return": "double[]", "signature": "double[] getPaulingElectronegativities(IAtomContainer ac, boolean modified)", "full_signature": "public double[] getPaulingElectronegativities(IAtomContainer ac, boolean modified)", "class_method_signature": "InductivePartialCharges.getPaulingElectronegativities(IAtomContainer ac, boolean modified)", "testcase": false, "constructor": false}, {"identifier": "getAtomicSoftnessCore", "parameters": "(IAtomContainer ac, int atomPosition)", "modifiers": "public", "return": "double", "signature": "double getAtomicSoftnessCore(IAtomContainer ac, int atomPosition)", "full_signature": "public double getAtomicSoftnessCore(IAtomContainer ac, int atomPosition)", "class_method_signature": "InductivePartialCharges.getAtomicSoftnessCore(IAtomContainer ac, int atomPosition)", "testcase": false, "constructor": false}, {"identifier": "getAtomicChargeIncrement", "parameters": "(IAtomContainer ac, int atomPosition, double[] ElEn, int as)", "modifiers": "private", "return": "double", "signature": "double getAtomicChargeIncrement(IAtomContainer ac, int atomPosition, double[] ElEn, int as)", "full_signature": "private double getAtomicChargeIncrement(IAtomContainer ac, int atomPosition, double[] ElEn, int as)", "class_method_signature": "InductivePartialCharges.getAtomicChargeIncrement(IAtomContainer ac, int atomPosition, double[] ElEn, int as)", "testcase": false, "constructor": false}, {"identifier": "getCovalentRadius", "parameters": "(String symbol, IBond.Order maxBondOrder)", "modifiers": "private", "return": "double", "signature": "double getCovalentRadius(String symbol, IBond.Order maxBondOrder)", "full_signature": "private double getCovalentRadius(String symbol, IBond.Order maxBondOrder)", "class_method_signature": "InductivePartialCharges.getCovalentRadius(String symbol, IBond.Order maxBondOrder)", "testcase": false, "constructor": false}, {"identifier": "calculateSquaredDistanceBetweenTwoAtoms", "parameters": "(IAtom atom1, IAtom atom2)", "modifiers": "private", "return": "double", "signature": "double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2)", "full_signature": "private double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2)", "class_method_signature": "InductivePartialCharges.calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2)", "testcase": false, "constructor": false}], "file": "tool/charges/src/main/java/org/openscience/cdk/charges/InductivePartialCharges.java"}, "focal_method": {"identifier": "assignInductivePartialCharges", "parameters": "(IAtomContainer ac)", "modifiers": "public", "return": "IAtomContainer", "body": "public IAtomContainer assignInductivePartialCharges(IAtomContainer ac) throws Exception {\n        if (factory == null) {\n            factory = AtomTypeFactory\n                    .getInstance(\"org/openscience/cdk/config/data/jmol_atomtypes.txt\", ac.getBuilder());\n        }\n\n        int stepsLimit = 9;\n        IAtom[] atoms = AtomContainerManipulator.getAtomArray(ac);\n        double[] pChInch = new double[atoms.length * (stepsLimit + 1)];\n        double[] ElEn = new double[atoms.length * (stepsLimit + 1)];\n        double[] pCh = new double[atoms.length * (stepsLimit + 1)];\n        double[] startEE = getPaulingElectronegativities(ac, true);\n        for (int e = 0; e < atoms.length; e++) {\n            ElEn[e] = startEE[e];\n            //logger.debug(\"INDU: initial EE \"+startEE[e]);\n        }\n        //double tmp1 = 0;\n        //double tmp2 = 0;\n        for (int s = 1; s < 10; s++) {\n            for (int a = 0; a < atoms.length; a++) {\n                pChInch[a + (s * atoms.length)] = getAtomicChargeIncrement(ac, a, ElEn, s);\n                pCh[a + (s * atoms.length)] = pChInch[a + (s * atoms.length)] + pCh[a + ((s - 1) * atoms.length)];\n                ElEn[a + (s * atoms.length)] = ElEn[a + ((s - 1) * atoms.length)]\n                        + (pChInch[a + (s * atoms.length)] / getAtomicSoftnessCore(ac, a));\n                if (s == 9) {\n                    atoms[a].setProperty(\"InductivePartialCharge\", new Double(pCh[a + (s * atoms.length)]));\n                    atoms[a].setProperty(\"EffectiveAtomicElectronegativity\", new Double(ElEn[a + (s * atoms.length)]));\n                }\n                //tmp1 = pCh[a + (s * atoms.length)];\n                //tmp2 = ElEn[a + (s * atoms.length)];\n                //logger.debug(\"DONE step \" + s + \", atom \" + atoms[a].getSymbol() + \", ch \" + tmp1 + \", ee \" + tmp2);\n            }\n        }\n        return ac;\n    }", "signature": "IAtomContainer assignInductivePartialCharges(IAtomContainer ac)", "full_signature": "public IAtomContainer assignInductivePartialCharges(IAtomContainer ac)", "class_method_signature": "InductivePartialCharges.assignInductivePartialCharges(IAtomContainer ac)", "testcase": false, "constructor": false, "invocations": ["getInstance", "getBuilder", "getAtomArray", "getPaulingElectronegativities", "getAtomicChargeIncrement", "getAtomicSoftnessCore", "setProperty", "setProperty"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}