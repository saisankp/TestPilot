{"test_class": {"identifier": "GlobalizeJsResourceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final File INPUT_FILE = new File(\"src/test/resource/resfilter/globalizejs/input.json\");", "modifier": "private static final", "type": "File", "declarator": "INPUT_FILE = new File(\"src/test/resource/resfilter/globalizejs/input.json\")", "var_name": "INPUT_FILE"}, {"original_string": "private static final File EXPECTED_WRITE_FILE = new File(\"src/test/resource/resfilter/globalizejs/write-output.json\");", "modifier": "private static final", "type": "File", "declarator": "EXPECTED_WRITE_FILE = new File(\"src/test/resource/resfilter/globalizejs/write-output.json\")", "var_name": "EXPECTED_WRITE_FILE"}, {"original_string": "private static final Collection<ResourceString> EXPECTED_INPUT_RES_LIST;", "modifier": "private static final", "type": "Collection<ResourceString>", "declarator": "EXPECTED_INPUT_RES_LIST", "var_name": "EXPECTED_INPUT_RES_LIST"}, {"original_string": "private static final String LONG_TEXT_STRING = \n        \"This is a really long sentence which \" +\n        \"is supposed to be joined together with \" +\n        \"a space between each string, \" +\n        \"or at least that is what the documentation says.\";", "modifier": "private static final", "type": "String", "declarator": "LONG_TEXT_STRING = \n        \"This is a really long sentence which \" +\n        \"is supposed to be joined together with \" +\n        \"a space between each string, \" +\n        \"or at least that is what the documentation says.\"", "var_name": "LONG_TEXT_STRING"}, {"original_string": "private static final String LONG_TEXT_STRING_DE =\n        \"Dies ist ein wirklich langer Satz, \" +\n        \"der zusammen mit einem Leerzeichen zwischen jedem String verbunden sein soll, \" +\n        \"oder zumindest das ist, was die Dokumentation sagt.\";", "modifier": "private static final", "type": "String", "declarator": "LONG_TEXT_STRING_DE =\n        \"Dies ist ein wirklich langer Satz, \" +\n        \"der zusammen mit einem Leerzeichen zwischen jedem String verbunden sein soll, \" +\n        \"oder zumindest das ist, was die Dokumentation sagt.\"", "var_name": "LONG_TEXT_STRING_DE"}, {"original_string": "private static LanguageBundle WRITE_BUNDLE;", "modifier": "private static", "type": "LanguageBundle", "declarator": "WRITE_BUNDLE", "var_name": "WRITE_BUNDLE"}, {"original_string": "private static final GlobalizeJsResource res = new GlobalizeJsResource();", "modifier": "private static final", "type": "GlobalizeJsResource", "declarator": "res = new GlobalizeJsResource()", "var_name": "res"}], "file": "gp-res-filter/src/test/java/com/ibm/g11n/pipeline/resfilter/impl/GlobalizeJsResourceTest.java"}, "test_case": {"identifier": "testParse", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testParse() throws IOException, ResourceFilterException {\n        assertTrue(\"The input test file <\" + INPUT_FILE + \"> does not exist.\", INPUT_FILE.exists());\n\n        try (InputStream is = new FileInputStream(INPUT_FILE)) {\n            LanguageBundle bundle = res.parse(is, null);\n            List<ResourceString> resStrList = new ArrayList<>(bundle.getResourceStrings());\n            Collections.sort(resStrList, new ResourceStringComparator());\n            assertEquals(\"ResourceStrings did not match.\", EXPECTED_INPUT_RES_LIST, resStrList);\n        }\n    }", "signature": "void testParse()", "full_signature": "@Test public void testParse()", "class_method_signature": "GlobalizeJsResourceTest.testParse()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "exists", "parse", "getResourceStrings", "sort", "assertEquals"]}, "focal_class": {"identifier": "GlobalizeJsResource", "superclass": "extends JsonResource", "interfaces": "", "fields": [], "methods": [{"identifier": "parse", "parameters": "(InputStream inStream, FilterOptions options)", "modifiers": "@Override public", "return": "LanguageBundle", "signature": "LanguageBundle parse(InputStream inStream, FilterOptions options)", "full_signature": "@Override public LanguageBundle parse(InputStream inStream, FilterOptions options)", "class_method_signature": "GlobalizeJsResource.parse(InputStream inStream, FilterOptions options)", "testcase": false, "constructor": false}, {"identifier": "addBundleStrings", "parameters": "(JsonObject obj, String keyPrefix, LanguageBundleBuilder bb, int sequenceNum)", "modifiers": "@Override protected", "return": "int", "signature": "int addBundleStrings(JsonObject obj, String keyPrefix, LanguageBundleBuilder bb, int sequenceNum)", "full_signature": "@Override protected int addBundleStrings(JsonObject obj, String keyPrefix, LanguageBundleBuilder bb, int sequenceNum)", "class_method_signature": "GlobalizeJsResource.addBundleStrings(JsonObject obj, String keyPrefix, LanguageBundleBuilder bb, int sequenceNum)", "testcase": false, "constructor": false}], "file": "gp-res-filter/src/main/java/com/ibm/g11n/pipeline/resfilter/impl/GlobalizeJsResource.java"}, "focal_method": {"identifier": "parse", "parameters": "(InputStream inStream, FilterOptions options)", "modifiers": "@Override public", "return": "LanguageBundle", "body": "@Override\n    public LanguageBundle parse(InputStream inStream, FilterOptions options)\n            throws IOException, ResourceFilterException {\n        LanguageBundleBuilder bb = new LanguageBundleBuilder(false);    // TODO: can we use auto sequence# mode?\n        try (InputStreamReader reader = new InputStreamReader(new BomInputStream(inStream), StandardCharsets.UTF_8)) {\n            JsonElement root = new JsonParser().parse(reader);\n            if (!root.isJsonObject()) {\n                throw new IllegalResourceFormatException(\"The root JSON element is not a JSON object.\");\n            }\n            JsonObject root_obj = root.getAsJsonObject();\n            Set<Map.Entry<String, JsonElement>> root_elements = root_obj.entrySet();\n            if (root_elements.size() != 1) {\n                throw new IllegalResourceFormatException(\n                        \"Only one top level language tag element is allowed per file.\");\n            }\n            Map.Entry<String, JsonElement> top_level = root_elements.iterator().next();\n            String language = top_level.getKey();\n            // We just hang on to the language tag as part of the bundle.\n            // When doing an import, we can validate that the language tag matches what they\n            // say they are importing.\n            bb.embeddedLanguageCode(language);\n            JsonElement language_obj = top_level.getValue();\n            if (!language_obj.isJsonObject()) {\n                throw new IllegalResourceFormatException(\"The top level language element is not a JSON object.\");\n            }\n            addBundleStrings(language_obj.getAsJsonObject(), \"\", bb, 0);\n        } catch (JsonParseException e) {\n            throw new IllegalResourceFormatException(\"Failed to parse the specified JSON contents.\", e);\n        }\n        return bb.build();\n    }", "signature": "LanguageBundle parse(InputStream inStream, FilterOptions options)", "full_signature": "@Override public LanguageBundle parse(InputStream inStream, FilterOptions options)", "class_method_signature": "GlobalizeJsResource.parse(InputStream inStream, FilterOptions options)", "testcase": false, "constructor": false, "invocations": ["parse", "isJsonObject", "getAsJsonObject", "entrySet", "size", "next", "iterator", "getKey", "embeddedLanguageCode", "getValue", "isJsonObject", "addBundleStrings", "getAsJsonObject", "build"]}, "repository": {"repo_id": 46134098, "url": "https://github.com/IBM-Cloud/gp-java-tools", "language": "Java", "is_fork": false, "fork_count": 16, "stargazer_count": 9, "size": 6216, "license": "licensed"}}