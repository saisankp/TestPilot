{"test_class": {"identifier": "RateLimitingPreExecutionInterceptorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private RateLimitingPreExecutionInterceptor interceptor;", "modifier": "private", "type": "RateLimitingPreExecutionInterceptor", "declarator": "interceptor", "var_name": "interceptor"}, {"original_string": "private TracingPlugin tracingPlugin;", "modifier": "private", "type": "TracingPlugin", "declarator": "tracingPlugin", "var_name": "tracingPlugin"}, {"original_string": "private PreExecutionInterceptorContext context;", "modifier": "private", "type": "PreExecutionInterceptorContext", "declarator": "context", "var_name": "context"}, {"original_string": "private SpanContextInformation spanContext;", "modifier": "private", "type": "SpanContextInformation", "declarator": "spanContext", "var_name": "spanContext"}, {"original_string": "private ConfigurationRegistry configuration;", "modifier": "private", "type": "ConfigurationRegistry", "declarator": "configuration", "var_name": "configuration"}], "file": "stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/RateLimitingPreExecutionInterceptorTest.java"}, "test_case": {"identifier": "testAlwaysReportSpan", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testAlwaysReportSpan() throws Exception {\n\t\ttracingPlugin.getDefaultRateLimitSpansPerMinuteOption().update(1_000_000.0, SimpleSource.NAME);\n\n\t\tinterceptor.interceptReport(context);\n\n\t\tassertTrue(context.isReport());\n\t}", "signature": "void testAlwaysReportSpan()", "full_signature": "@Test public void testAlwaysReportSpan()", "class_method_signature": "RateLimitingPreExecutionInterceptorTest.testAlwaysReportSpan()", "testcase": true, "constructor": false, "invocations": ["update", "getDefaultRateLimitSpansPerMinuteOption", "interceptReport", "assertTrue", "isReport"]}, "focal_class": {"identifier": "RateLimitingPreExecutionInterceptor", "superclass": "extends PreExecutionSpanInterceptor", "interfaces": "", "fields": [{"original_string": "private RateLimiter rateLimiter;", "modifier": "private", "type": "RateLimiter", "declarator": "rateLimiter", "var_name": "rateLimiter"}, {"original_string": "private TracingPlugin tracingPlugin;", "modifier": "private", "type": "TracingPlugin", "declarator": "tracingPlugin", "var_name": "tracingPlugin"}], "methods": [{"identifier": "init", "parameters": "(ConfigurationRegistry configuration)", "modifiers": "@Override public", "return": "void", "signature": "void init(ConfigurationRegistry configuration)", "full_signature": "@Override public void init(ConfigurationRegistry configuration)", "class_method_signature": "RateLimitingPreExecutionInterceptor.init(ConfigurationRegistry configuration)", "testcase": false, "constructor": false}, {"identifier": "getRateLimiter", "parameters": "(double creditsPerMinute)", "modifiers": "public static", "return": "RateLimiter", "signature": "RateLimiter getRateLimiter(double creditsPerMinute)", "full_signature": "public static RateLimiter getRateLimiter(double creditsPerMinute)", "class_method_signature": "RateLimitingPreExecutionInterceptor.getRateLimiter(double creditsPerMinute)", "testcase": false, "constructor": false}, {"identifier": "interceptReport", "parameters": "(PreExecutionInterceptorContext context)", "modifiers": "@Override public", "return": "void", "signature": "void interceptReport(PreExecutionInterceptorContext context)", "full_signature": "@Override public void interceptReport(PreExecutionInterceptorContext context)", "class_method_signature": "RateLimitingPreExecutionInterceptor.interceptReport(PreExecutionInterceptorContext context)", "testcase": false, "constructor": false}, {"identifier": "isRoot", "parameters": "(SpanWrapper span)", "modifiers": "protected", "return": "boolean", "signature": "boolean isRoot(SpanWrapper span)", "full_signature": "protected boolean isRoot(SpanWrapper span)", "class_method_signature": "RateLimitingPreExecutionInterceptor.isRoot(SpanWrapper span)", "testcase": false, "constructor": false}, {"identifier": "isRateExceeded", "parameters": "(RateLimiter rateLimiter)", "modifiers": "public static", "return": "boolean", "signature": "boolean isRateExceeded(RateLimiter rateLimiter)", "full_signature": "public static boolean isRateExceeded(RateLimiter rateLimiter)", "class_method_signature": "RateLimitingPreExecutionInterceptor.isRateExceeded(RateLimiter rateLimiter)", "testcase": false, "constructor": false}], "file": "stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/RateLimitingPreExecutionInterceptor.java"}, "focal_method": {"identifier": "interceptReport", "parameters": "(PreExecutionInterceptorContext context)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void interceptReport(PreExecutionInterceptorContext context) {\n\t\tif (rateLimiter == null) {\n\t\t\treturn;\n\t\t}\n\t\t// the rate limit is per span but we either sample a trace as a whole or don't sample it\n\t\t// even though we don't make sampling decisions for non root spans\n\t\t// we need to tell the rate limiter that there is another span being sampled\n\t\t// so that the cost is incorporated\n\t\tif (isRateExceeded(rateLimiter) && isRoot(context.getSpanContext().getSpanWrapper())) {\n\t\t\tcontext.shouldNotReport(getClass());\n\t\t}\n\t}", "signature": "void interceptReport(PreExecutionInterceptorContext context)", "full_signature": "@Override public void interceptReport(PreExecutionInterceptorContext context)", "class_method_signature": "RateLimitingPreExecutionInterceptor.interceptReport(PreExecutionInterceptorContext context)", "testcase": false, "constructor": false, "invocations": ["isRateExceeded", "isRoot", "getSpanWrapper", "getSpanContext", "shouldNotReport", "getClass"]}, "repository": {"repo_id": 11845993, "url": "https://github.com/stagemonitor/stagemonitor", "language": "Java", "is_fork": false, "fork_count": 268, "stargazer_count": 1585, "size": 10342, "license": "licensed"}}