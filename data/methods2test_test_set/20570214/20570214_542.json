{"test_class": {"identifier": "WebPushHybridEncryptTest", "superclass": "", "interfaces": "", "fields": [], "file": "apps/webpush/src/test/java/com/google/crypto/tink/apps/webpush/WebPushHybridEncryptTest.java"}, "test_case": {"identifier": "testEncryptDecrypt", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testEncryptDecrypt() throws Exception {\n    KeyPair uaKeyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);\n    ECPrivateKey uaPrivateKey = (ECPrivateKey) uaKeyPair.getPrivate();\n    ECPublicKey uaPublicKey = (ECPublicKey) uaKeyPair.getPublic();\n    byte[] uaPublicKeyBytes =\n        EllipticCurves.pointEncode(\n            WebPushConstants.NIST_P256_CURVE_TYPE,\n            WebPushConstants.UNCOMPRESSED_POINT_FORMAT,\n            uaPublicKey.getW());\n    byte[] authSecret = Random.randBytes(16);\n    HybridEncrypt hybridEncrypt =\n        new WebPushHybridEncrypt.Builder()\n            .withAuthSecret(authSecret)\n            .withRecipientPublicKey(uaPublicKeyBytes)\n            .build();\n    HybridDecrypt hybridDecrypt =\n        new WebPushHybridDecrypt.Builder()\n            .withAuthSecret(authSecret)\n            .withRecipientPublicKey(uaPublicKeyBytes)\n            .withRecipientPrivateKey(uaPrivateKey)\n            .build();\n\n    Set<String> salts = new TreeSet<>();\n    Set<String> ephemeralPublicKeys = new TreeSet<>();\n    Set<String> payloads = new TreeSet<>();\n    int numTests = 100;\n    if (TestUtil.isTsan()) {\n      numTests = 5;\n    }\n    for (int j = 0; j < numTests; j++) {\n      byte[] plaintext = Random.randBytes(j);\n      byte[] ciphertext = hybridEncrypt.encrypt(plaintext, null /* contextInfo */);\n      assertEquals(ciphertext.length, plaintext.length + WebPushConstants.CIPHERTEXT_OVERHEAD);\n      assertArrayEquals(plaintext, hybridDecrypt.decrypt(ciphertext, null /* contextInfo */));\n\n      // Checks that the encryption is randomized.\n      ByteBuffer record = ByteBuffer.wrap(ciphertext);\n      byte[] salt = new byte[WebPushConstants.SALT_SIZE];\n      record.get(salt);\n      salts.add(Hex.encode(salt));\n\n      int unused1 = record.getInt();\n      int unused2 = (int) record.get();\n\n      byte[] ephemeralPublicKey = new byte[WebPushConstants.PUBLIC_KEY_SIZE];\n      record.get(ephemeralPublicKey);\n      ephemeralPublicKeys.add(Hex.encode(ephemeralPublicKey));\n\n      byte[] payload = new byte[ciphertext.length - WebPushConstants.CONTENT_CODING_HEADER_SIZE];\n      record.get(payload);\n      payloads.add(Hex.encode(payload));\n    }\n    assertEquals(numTests, salts.size());\n    assertEquals(numTests, ephemeralPublicKeys.size());\n    assertEquals(numTests, payloads.size());\n  }", "signature": "void testEncryptDecrypt()", "full_signature": "@Test public void testEncryptDecrypt()", "class_method_signature": "WebPushHybridEncryptTest.testEncryptDecrypt()", "testcase": true, "constructor": false, "invocations": ["generateKeyPair", "getPrivate", "getPublic", "pointEncode", "getW", "randBytes", "build", "withRecipientPublicKey", "withAuthSecret", "build", "withRecipientPrivateKey", "withRecipientPublicKey", "withAuthSecret", "isTsan", "randBytes", "encrypt", "assertEquals", "assertArrayEquals", "decrypt", "wrap", "get", "add", "encode", "getInt", "get", "get", "add", "encode", "get", "add", "encode", "assertEquals", "size", "assertEquals", "size", "assertEquals", "size"]}, "focal_class": {"identifier": "WebPushHybridEncrypt", "superclass": "", "interfaces": "implements HybridEncrypt", "fields": [{"original_string": "private final byte[] recipientPublicKey;", "modifier": "private final", "type": "byte[]", "declarator": "recipientPublicKey", "var_name": "recipientPublicKey"}, {"original_string": "private final byte[] authSecret;", "modifier": "private final", "type": "byte[]", "declarator": "authSecret", "var_name": "authSecret"}, {"original_string": "private final ECPoint recipientPublicPoint;", "modifier": "private final", "type": "ECPoint", "declarator": "recipientPublicPoint", "var_name": "recipientPublicPoint"}, {"original_string": "private final int recordSize;", "modifier": "private final", "type": "int", "declarator": "recordSize", "var_name": "recordSize"}], "methods": [{"identifier": "WebPushHybridEncrypt", "parameters": "(Builder builder)", "modifiers": "private", "return": "", "signature": " WebPushHybridEncrypt(Builder builder)", "full_signature": "private  WebPushHybridEncrypt(Builder builder)", "class_method_signature": "WebPushHybridEncrypt.WebPushHybridEncrypt(Builder builder)", "testcase": false, "constructor": true}, {"identifier": "encrypt", "parameters": "(final byte[] plaintext, final byte[] contextInfo /* unused */)", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] encrypt(final byte[] plaintext, final byte[] contextInfo /* unused */)", "full_signature": "@Override public byte[] encrypt(final byte[] plaintext, final byte[] contextInfo /* unused */)", "class_method_signature": "WebPushHybridEncrypt.encrypt(final byte[] plaintext, final byte[] contextInfo /* unused */)", "testcase": false, "constructor": false}, {"identifier": "encrypt", "parameters": "(final byte[] key, final byte[] nonce, final byte[] plaintext)", "modifiers": "private", "return": "byte[]", "signature": "byte[] encrypt(final byte[] key, final byte[] nonce, final byte[] plaintext)", "full_signature": "private byte[] encrypt(final byte[] key, final byte[] nonce, final byte[] plaintext)", "class_method_signature": "WebPushHybridEncrypt.encrypt(final byte[] key, final byte[] nonce, final byte[] plaintext)", "testcase": false, "constructor": false}], "file": "apps/webpush/src/main/java/com/google/crypto/tink/apps/webpush/WebPushHybridEncrypt.java"}, "focal_method": {"identifier": "encrypt", "parameters": "(final byte[] plaintext, final byte[] contextInfo /* unused */)", "modifiers": "@Override public", "return": "byte[]", "body": "@Override\n  public byte[] encrypt(final byte[] plaintext, final byte[] contextInfo /* unused */)\n      throws GeneralSecurityException {\n    if (contextInfo != null) {\n      throw new GeneralSecurityException(\"contextInfo must be null because it is unused\");\n    }\n\n    if (plaintext.length > recordSize - WebPushConstants.CIPHERTEXT_OVERHEAD) {\n      throw new GeneralSecurityException(\"plaintext too long\");\n    }\n\n    // See https://tools.ietf.org/html/rfc8291#section-3.4.\n    KeyPair keyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);\n    ECPrivateKey ephemeralPrivateKey = (ECPrivateKey) keyPair.getPrivate();\n    ECPublicKey ephemeralPublicKey = (ECPublicKey) keyPair.getPublic();\n    byte[] ecdhSecret =\n        EllipticCurves.computeSharedSecret(ephemeralPrivateKey, recipientPublicPoint);\n    byte[] ephemeralPublicKeyBytes =\n        EllipticCurves.pointEncode(\n            WebPushConstants.NIST_P256_CURVE_TYPE,\n            WebPushConstants.UNCOMPRESSED_POINT_FORMAT,\n            ephemeralPublicKey.getW());\n    byte[] ikm =\n        WebPushUtil.computeIkm(ecdhSecret, authSecret, recipientPublicKey, ephemeralPublicKeyBytes);\n    byte[] salt = Random.randBytes(WebPushConstants.SALT_SIZE);\n    byte[] cek = WebPushUtil.computeCek(ikm, salt);\n    byte[] nonce = WebPushUtil.computeNonce(ikm, salt);\n    return ByteBuffer.allocate(WebPushConstants.CIPHERTEXT_OVERHEAD + plaintext.length)\n        .put(salt)\n        .putInt(recordSize)\n        .put((byte) WebPushConstants.PUBLIC_KEY_SIZE)\n        .put(ephemeralPublicKeyBytes)\n        .put(encrypt(cek, nonce, plaintext))\n        .array();\n  }", "signature": "byte[] encrypt(final byte[] plaintext, final byte[] contextInfo /* unused */)", "full_signature": "@Override public byte[] encrypt(final byte[] plaintext, final byte[] contextInfo /* unused */)", "class_method_signature": "WebPushHybridEncrypt.encrypt(final byte[] plaintext, final byte[] contextInfo /* unused */)", "testcase": false, "constructor": false, "invocations": ["generateKeyPair", "getPrivate", "getPublic", "computeSharedSecret", "pointEncode", "getW", "computeIkm", "randBytes", "computeCek", "computeNonce", "array", "put", "put", "put", "putInt", "put", "allocate", "encrypt"]}, "repository": {"repo_id": 20570214, "url": "https://github.com/google/tink", "stars": 8884, "created": "6/6/2014 4:21:09 PM +00:00", "updates": "2020-01-27T11:52:16+00:00", "fork": "False", "license": "licensed"}}