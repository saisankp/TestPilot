{"test_class": {"identifier": "LearnerHandlerTest", "superclass": "extends ZKTestCase", "interfaces": "", "fields": [{"original_string": "protected static final Logger LOG = LoggerFactory\n            .getLogger(LearnerHandlerTest.class);", "modifier": "protected static final", "type": "Logger", "declarator": "LOG = LoggerFactory\n            .getLogger(LearnerHandlerTest.class)", "var_name": "LOG"}, {"original_string": "private MockLearnerHandler learnerHandler;", "modifier": "private", "type": "MockLearnerHandler", "declarator": "learnerHandler", "var_name": "learnerHandler"}, {"original_string": "private Socket sock;", "modifier": "private", "type": "Socket", "declarator": "sock", "var_name": "sock"}, {"original_string": "private Leader leader;", "modifier": "private", "type": "Leader", "declarator": "leader", "var_name": "leader"}, {"original_string": "private long currentZxid;", "modifier": "private", "type": "long", "declarator": "currentZxid", "var_name": "currentZxid"}, {"original_string": "private MockZKDatabase db;", "modifier": "private", "type": "MockZKDatabase", "declarator": "db", "var_name": "db"}], "file": "zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LearnerHandlerTest.java"}, "test_case": {"identifier": "testTxnLogProposalIteratorClosure", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testTxnLogProposalIteratorClosure() throws Exception {\n        long peerZxid;\n\n        // CommmitedLog is empty, we will use txnlog up to lastProcessZxid\n        db = new MockZKDatabase(null) {\n            @Override\n            public Iterator<Proposal> getProposalsFromTxnLog(long peerZxid,\n                    long limit) {\n                return TxnLogProposalIterator.EMPTY_ITERATOR;\n            }\n        };\n        db.lastProcessedZxid = 7;\n        db.txnLog.add(createProposal(2));\n        db.txnLog.add(createProposal(3));\n\n        // Peer zxid\n        peerZxid = 4;\n        assertTrue(\"Couldn't identify snapshot transfer!\",\n                learnerHandler.syncFollower(peerZxid, db, leader));\n        reset();\n    }", "signature": "void testTxnLogProposalIteratorClosure()", "full_signature": "@Test public void testTxnLogProposalIteratorClosure()", "class_method_signature": "LearnerHandlerTest.testTxnLogProposalIteratorClosure()", "testcase": true, "constructor": false, "invocations": ["add", "createProposal", "add", "createProposal", "assertTrue", "syncFollower", "reset"]}, "focal_class": {"identifier": "LearnerHandler", "superclass": "extends ZooKeeperThread", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(LearnerHandler.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(LearnerHandler.class)", "var_name": "LOG"}, {"original_string": "protected final Socket sock;", "modifier": "protected final", "type": "Socket", "declarator": "sock", "var_name": "sock"}, {"original_string": "final Leader leader;", "modifier": "final", "type": "Leader", "declarator": "leader", "var_name": "leader"}, {"original_string": "volatile long tickOfNextAckDeadline;", "modifier": "volatile", "type": "long", "declarator": "tickOfNextAckDeadline", "var_name": "tickOfNextAckDeadline"}, {"original_string": "protected long sid = 0;", "modifier": "protected", "type": "long", "declarator": "sid = 0", "var_name": "sid"}, {"original_string": "protected int version = 0x1;", "modifier": "protected", "type": "int", "declarator": "version = 0x1", "var_name": "version"}, {"original_string": "final LinkedBlockingQueue<QuorumPacket> queuedPackets =\n        new LinkedBlockingQueue<QuorumPacket>();", "modifier": "final", "type": "LinkedBlockingQueue<QuorumPacket>", "declarator": "queuedPackets =\n        new LinkedBlockingQueue<QuorumPacket>()", "var_name": "queuedPackets"}, {"original_string": "private SyncLimitCheck syncLimitCheck = new SyncLimitCheck();", "modifier": "private", "type": "SyncLimitCheck", "declarator": "syncLimitCheck = new SyncLimitCheck()", "var_name": "syncLimitCheck"}, {"original_string": "private BinaryInputArchive ia;", "modifier": "private", "type": "BinaryInputArchive", "declarator": "ia", "var_name": "ia"}, {"original_string": "private BinaryOutputArchive oa;", "modifier": "private", "type": "BinaryOutputArchive", "declarator": "oa", "var_name": "oa"}, {"original_string": "private final BufferedInputStream bufferedInput;", "modifier": "private final", "type": "BufferedInputStream", "declarator": "bufferedInput", "var_name": "bufferedInput"}, {"original_string": "private BufferedOutputStream bufferedOutput;", "modifier": "private", "type": "BufferedOutputStream", "declarator": "bufferedOutput", "var_name": "bufferedOutput"}, {"original_string": "private volatile boolean sendingThreadStarted = false;", "modifier": "private volatile", "type": "boolean", "declarator": "sendingThreadStarted = false", "var_name": "sendingThreadStarted"}, {"original_string": "public static final String FORCE_SNAP_SYNC = \"zookeeper.forceSnapshotSync\";", "modifier": "public static final", "type": "String", "declarator": "FORCE_SNAP_SYNC = \"zookeeper.forceSnapshotSync\"", "var_name": "FORCE_SNAP_SYNC"}, {"original_string": "private boolean forceSnapSync = false;", "modifier": "private", "type": "boolean", "declarator": "forceSnapSync = false", "var_name": "forceSnapSync"}, {"original_string": "private boolean needOpPacket = true;", "modifier": "private", "type": "boolean", "declarator": "needOpPacket = true", "var_name": "needOpPacket"}, {"original_string": "private long leaderLastZxid;", "modifier": "private", "type": "long", "declarator": "leaderLastZxid", "var_name": "leaderLastZxid"}, {"original_string": "final QuorumPacket proposalOfDeath = new QuorumPacket();", "modifier": "final", "type": "QuorumPacket", "declarator": "proposalOfDeath = new QuorumPacket()", "var_name": "proposalOfDeath"}, {"original_string": "private LearnerType  learnerType = LearnerType.PARTICIPANT;", "modifier": "private", "type": "LearnerType", "declarator": "learnerType = LearnerType.PARTICIPANT", "var_name": "learnerType"}], "methods": [{"identifier": "getSocket", "parameters": "()", "modifiers": "public", "return": "Socket", "signature": "Socket getSocket()", "full_signature": "public Socket getSocket()", "class_method_signature": "LearnerHandler.getSocket()", "testcase": false, "constructor": false}, {"identifier": "getSid", "parameters": "()", "modifiers": "", "return": "long", "signature": "long getSid()", "full_signature": " long getSid()", "class_method_signature": "LearnerHandler.getSid()", "testcase": false, "constructor": false}, {"identifier": "getVersion", "parameters": "()", "modifiers": "", "return": "int", "signature": "int getVersion()", "full_signature": " int getVersion()", "class_method_signature": "LearnerHandler.getVersion()", "testcase": false, "constructor": false}, {"identifier": "LearnerHandler", "parameters": "(Socket sock, BufferedInputStream bufferedInput,Leader leader)", "modifiers": "", "return": "", "signature": " LearnerHandler(Socket sock, BufferedInputStream bufferedInput,Leader leader)", "full_signature": "  LearnerHandler(Socket sock, BufferedInputStream bufferedInput,Leader leader)", "class_method_signature": "LearnerHandler.LearnerHandler(Socket sock, BufferedInputStream bufferedInput,Leader leader)", "testcase": false, "constructor": true}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "LearnerHandler.toString()", "testcase": false, "constructor": false}, {"identifier": "getLearnerType", "parameters": "()", "modifiers": "public", "return": "LearnerType", "signature": "LearnerType getLearnerType()", "full_signature": "public LearnerType getLearnerType()", "class_method_signature": "LearnerHandler.getLearnerType()", "testcase": false, "constructor": false}, {"identifier": "sendPackets", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void sendPackets()", "full_signature": "private void sendPackets()", "class_method_signature": "LearnerHandler.sendPackets()", "testcase": false, "constructor": false}, {"identifier": "packetToString", "parameters": "(QuorumPacket p)", "modifiers": "static public", "return": "String", "signature": "String packetToString(QuorumPacket p)", "full_signature": "static public String packetToString(QuorumPacket p)", "class_method_signature": "LearnerHandler.packetToString(QuorumPacket p)", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "LearnerHandler.run()", "testcase": false, "constructor": false}, {"identifier": "startSendingPackets", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void startSendingPackets()", "full_signature": "protected void startSendingPackets()", "class_method_signature": "LearnerHandler.startSendingPackets()", "testcase": false, "constructor": false}, {"identifier": "syncFollower", "parameters": "(long peerLastZxid, ZKDatabase db, Leader leader)", "modifiers": "public", "return": "boolean", "signature": "boolean syncFollower(long peerLastZxid, ZKDatabase db, Leader leader)", "full_signature": "public boolean syncFollower(long peerLastZxid, ZKDatabase db, Leader leader)", "class_method_signature": "LearnerHandler.syncFollower(long peerLastZxid, ZKDatabase db, Leader leader)", "testcase": false, "constructor": false}, {"identifier": "queueCommittedProposals", "parameters": "(Iterator<Proposal> itr,\n            long peerLastZxid, Long maxZxid, Long lastCommittedZxid)", "modifiers": "protected", "return": "long", "signature": "long queueCommittedProposals(Iterator<Proposal> itr,\n            long peerLastZxid, Long maxZxid, Long lastCommittedZxid)", "full_signature": "protected long queueCommittedProposals(Iterator<Proposal> itr,\n            long peerLastZxid, Long maxZxid, Long lastCommittedZxid)", "class_method_signature": "LearnerHandler.queueCommittedProposals(Iterator<Proposal> itr,\n            long peerLastZxid, Long maxZxid, Long lastCommittedZxid)", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "LearnerHandler.shutdown()", "testcase": false, "constructor": false}, {"identifier": "tickOfNextAckDeadline", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long tickOfNextAckDeadline()", "full_signature": "public long tickOfNextAckDeadline()", "class_method_signature": "LearnerHandler.tickOfNextAckDeadline()", "testcase": false, "constructor": false}, {"identifier": "ping", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void ping()", "full_signature": "public void ping()", "class_method_signature": "LearnerHandler.ping()", "testcase": false, "constructor": false}, {"identifier": "queueOpPacket", "parameters": "(int type, long zxid)", "modifiers": "private", "return": "void", "signature": "void queueOpPacket(int type, long zxid)", "full_signature": "private void queueOpPacket(int type, long zxid)", "class_method_signature": "LearnerHandler.queueOpPacket(int type, long zxid)", "testcase": false, "constructor": false}, {"identifier": "queuePacket", "parameters": "(QuorumPacket p)", "modifiers": "", "return": "void", "signature": "void queuePacket(QuorumPacket p)", "full_signature": " void queuePacket(QuorumPacket p)", "class_method_signature": "LearnerHandler.queuePacket(QuorumPacket p)", "testcase": false, "constructor": false}, {"identifier": "synced", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean synced()", "full_signature": "public boolean synced()", "class_method_signature": "LearnerHandler.synced()", "testcase": false, "constructor": false}, {"identifier": "getQueuedPackets", "parameters": "()", "modifiers": "public", "return": "Queue<QuorumPacket>", "signature": "Queue<QuorumPacket> getQueuedPackets()", "full_signature": "public Queue<QuorumPacket> getQueuedPackets()", "class_method_signature": "LearnerHandler.getQueuedPackets()", "testcase": false, "constructor": false}, {"identifier": "setFirstPacket", "parameters": "(boolean value)", "modifiers": "public", "return": "void", "signature": "void setFirstPacket(boolean value)", "full_signature": "public void setFirstPacket(boolean value)", "class_method_signature": "LearnerHandler.setFirstPacket(boolean value)", "testcase": false, "constructor": false}], "file": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java"}, "focal_method": {"identifier": "syncFollower", "parameters": "(long peerLastZxid, ZKDatabase db, Leader leader)", "modifiers": "public", "return": "boolean", "body": "public boolean syncFollower(long peerLastZxid, ZKDatabase db, Leader leader) {\n        /*\n         * When leader election is completed, the leader will set its\n         * lastProcessedZxid to be (epoch < 32). There will be no txn associated\n         * with this zxid.\n         *\n         * The learner will set its lastProcessedZxid to the same value if\n         * it get DIFF or SNAP from the leader. If the same learner come\n         * back to sync with leader using this zxid, we will never find this\n         * zxid in our history. In this case, we will ignore TRUNC logic and\n         * always send DIFF if we have old enough history\n         */\n        boolean isPeerNewEpochZxid = (peerLastZxid & 0xffffffffL) == 0;\n        // Keep track of the latest zxid which already queued\n        long currentZxid = peerLastZxid;\n        boolean needSnap = true;\n        boolean txnLogSyncEnabled = db.isTxnLogSyncEnabled();\n        ReentrantReadWriteLock lock = db.getLogLock();\n        ReadLock rl = lock.readLock();\n        try {\n            rl.lock();\n            long maxCommittedLog = db.getmaxCommittedLog();\n            long minCommittedLog = db.getminCommittedLog();\n            long lastProcessedZxid = db.getDataTreeLastProcessedZxid();\n\n            LOG.info(\"Synchronizing with Follower sid: {} maxCommittedLog=0x{}\"\n                    + \" minCommittedLog=0x{} lastProcessedZxid=0x{}\"\n                    + \" peerLastZxid=0x{}\", getSid(),\n                    Long.toHexString(maxCommittedLog),\n                    Long.toHexString(minCommittedLog),\n                    Long.toHexString(lastProcessedZxid),\n                    Long.toHexString(peerLastZxid));\n\n            if (db.getCommittedLog().isEmpty()) {\n                /*\n                 * It is possible that committedLog is empty. In that case\n                 * setting these value to the latest txn in leader db\n                 * will reduce the case that we need to handle\n                 *\n                 * Here is how each case handle by the if block below\n                 * 1. lastProcessZxid == peerZxid -> Handle by (2)\n                 * 2. lastProcessZxid < peerZxid -> Handle by (3)\n                 * 3. lastProcessZxid > peerZxid -> Handle by (5)\n                 */\n                minCommittedLog = lastProcessedZxid;\n                maxCommittedLog = lastProcessedZxid;\n            }\n\n            /*\n             * Here are the cases that we want to handle\n             *\n             * 1. Force sending snapshot (for testing purpose)\n             * 2. Peer and leader is already sync, send empty diff\n             * 3. Follower has txn that we haven't seen. This may be old leader\n             *    so we need to send TRUNC. However, if peer has newEpochZxid,\n             *    we cannot send TRUNC since the follower has no txnlog\n             * 4. Follower is within committedLog range or already in-sync.\n             *    We may need to send DIFF or TRUNC depending on follower's zxid\n             *    We always send empty DIFF if follower is already in-sync\n             * 5. Follower missed the committedLog. We will try to use on-disk\n             *    txnlog + committedLog to sync with follower. If that fail,\n             *    we will send snapshot\n             */\n\n            if (forceSnapSync) {\n                // Force leader to use snapshot to sync with follower\n                LOG.warn(\"Forcing snapshot sync - should not see this in production\");\n            } else if (lastProcessedZxid == peerLastZxid) {\n                // Follower is already sync with us, send empty diff\n                LOG.info(\"Sending DIFF zxid=0x\" + Long.toHexString(peerLastZxid) +\n                         \" for peer sid: \" +  getSid());\n                queueOpPacket(Leader.DIFF, peerLastZxid);\n                needOpPacket = false;\n                needSnap = false;\n            } else if (peerLastZxid > maxCommittedLog && !isPeerNewEpochZxid) {\n                // Newer than committedLog, send trunc and done\n                LOG.debug(\"Sending TRUNC to follower zxidToSend=0x\" +\n                          Long.toHexString(maxCommittedLog) +\n                          \" for peer sid:\" +  getSid());\n                queueOpPacket(Leader.TRUNC, maxCommittedLog);\n                currentZxid = maxCommittedLog;\n                needOpPacket = false;\n                needSnap = false;\n            } else if ((maxCommittedLog >= peerLastZxid)\n                    && (minCommittedLog <= peerLastZxid)) {\n                // Follower is within commitLog range\n                LOG.info(\"Using committedLog for peer sid: \" +  getSid());\n                Iterator<Proposal> itr = db.getCommittedLog().iterator();\n                currentZxid = queueCommittedProposals(itr, peerLastZxid,\n                                                     null, maxCommittedLog);\n                needSnap = false;\n            } else if (peerLastZxid < minCommittedLog && txnLogSyncEnabled) {\n                // Use txnlog and committedLog to sync\n\n                // Calculate sizeLimit that we allow to retrieve txnlog from disk\n                long sizeLimit = db.calculateTxnLogSizeLimit();\n                // This method can return empty iterator if the requested zxid\n                // is older than on-disk txnlog\n                Iterator<Proposal> txnLogItr = db.getProposalsFromTxnLog(\n                        peerLastZxid, sizeLimit);\n                if (txnLogItr.hasNext()) {\n                    LOG.info(\"Use txnlog and committedLog for peer sid: \" +  getSid());\n                    currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid,\n                                                         minCommittedLog, maxCommittedLog);\n\n                    LOG.debug(\"Queueing committedLog 0x\" + Long.toHexString(currentZxid));\n                    Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();\n                    currentZxid = queueCommittedProposals(committedLogItr, currentZxid,\n                                                         null, maxCommittedLog);\n                    needSnap = false;\n                }\n                // closing the resources\n                if (txnLogItr instanceof TxnLogProposalIterator) {\n                    TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;\n                    txnProposalItr.close();\n                }\n            } else {\n                LOG.warn(\"Unhandled scenario for peer sid: \" +  getSid());\n            }\n            LOG.debug(\"Start forwarding 0x\" + Long.toHexString(currentZxid) +\n                      \" for peer sid: \" +  getSid());\n            leaderLastZxid = leader.startForwarding(this, currentZxid);\n        } finally {\n            rl.unlock();\n        }\n\n        if (needOpPacket && !needSnap) {\n            // This should never happen, but we should fall back to sending\n            // snapshot just in case.\n            LOG.error(\"Unhandled scenario for peer sid: \" +  getSid() +\n                     \" fall back to use snapshot\");\n            needSnap = true;\n        }\n\n        return needSnap;\n    }", "signature": "boolean syncFollower(long peerLastZxid, ZKDatabase db, Leader leader)", "full_signature": "public boolean syncFollower(long peerLastZxid, ZKDatabase db, Leader leader)", "class_method_signature": "LearnerHandler.syncFollower(long peerLastZxid, ZKDatabase db, Leader leader)", "testcase": false, "constructor": false, "invocations": ["isTxnLogSyncEnabled", "getLogLock", "readLock", "lock", "getmaxCommittedLog", "getminCommittedLog", "getDataTreeLastProcessedZxid", "info", "getSid", "toHexString", "toHexString", "toHexString", "toHexString", "isEmpty", "getCommittedLog", "warn", "info", "toHexString", "getSid", "queueOpPacket", "debug", "toHexString", "getSid", "queueOpPacket", "info", "getSid", "iterator", "getCommittedLog", "queueCommittedProposals", "calculateTxnLogSizeLimit", "getProposalsFromTxnLog", "hasNext", "info", "getSid", "queueCommittedProposals", "debug", "toHexString", "iterator", "getCommittedLog", "queueCommittedProposals", "close", "warn", "getSid", "debug", "toHexString", "getSid", "startForwarding", "unlock", "error", "getSid"]}, "repository": {"repo_id": 230430206, "url": "https://github.com/boomblog/zookeeper-vip2", "language": "Java", "is_fork": false, "fork_count": 29, "stargazer_count": 10, "size": 3105, "license": "licensed"}}