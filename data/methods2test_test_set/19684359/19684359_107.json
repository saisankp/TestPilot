{"test_class": {"identifier": "DynamicFileListRecordReaderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String RECORD_0 = \"{'day':'Sunday','letters':'6'}\";", "modifier": "private static final", "type": "String", "declarator": "RECORD_0 = \"{'day':'Sunday','letters':'6'}\"", "var_name": "RECORD_0"}, {"original_string": "private static final String RECORD_1 = \"{'day':'Monday','letters':'6'}\";", "modifier": "private static final", "type": "String", "declarator": "RECORD_1 = \"{'day':'Monday','letters':'6'}\"", "var_name": "RECORD_1"}, {"original_string": "private static final String RECORD_2 = \"{'day':'Tuesday','letters':'7'}\";", "modifier": "private static final", "type": "String", "declarator": "RECORD_2 = \"{'day':'Tuesday','letters':'7'}\"", "var_name": "RECORD_2"}, {"original_string": "private static final String SLEEP_ID = \"test-sleep-id-12345\";", "modifier": "private static final", "type": "String", "declarator": "SLEEP_ID = \"test-sleep-id-12345\"", "var_name": "SLEEP_ID"}, {"original_string": "private JsonParser jsonParser = new JsonParser();", "modifier": "private", "type": "JsonParser", "declarator": "jsonParser = new JsonParser()", "var_name": "jsonParser"}, {"original_string": "private Configuration config;", "modifier": "private", "type": "Configuration", "declarator": "config", "var_name": "config"}, {"original_string": "@Mock private TaskAttemptContext mockTaskContext;", "modifier": "@Mock private", "type": "TaskAttemptContext", "declarator": "mockTaskContext", "var_name": "mockTaskContext"}, {"original_string": "@Mock private Sleeper mockSleeper;", "modifier": "@Mock private", "type": "Sleeper", "declarator": "mockSleeper", "var_name": "mockSleeper"}, {"original_string": "private Path basePath;", "modifier": "private", "type": "Path", "declarator": "basePath", "var_name": "basePath"}, {"original_string": "private Path shardPath;", "modifier": "private", "type": "Path", "declarator": "shardPath", "var_name": "shardPath"}, {"original_string": "private long estimatedNumRecords;", "modifier": "private", "type": "long", "declarator": "estimatedNumRecords", "var_name": "estimatedNumRecords"}, {"original_string": "private ShardedInputSplit inputSplit;", "modifier": "private", "type": "ShardedInputSplit", "declarator": "inputSplit", "var_name": "inputSplit"}, {"original_string": "private DynamicFileListRecordReader<LongWritable, JsonObject> recordReader;", "modifier": "private", "type": "DynamicFileListRecordReader<LongWritable, JsonObject>", "declarator": "recordReader", "var_name": "recordReader"}, {"original_string": "private FileSystem fileSystem;", "modifier": "private", "type": "FileSystem", "declarator": "fileSystem", "var_name": "fileSystem"}], "file": "bigquery/src/test/java/com/google/cloud/hadoop/io/bigquery/DynamicFileListRecordReaderTest.java"}, "test_case": {"identifier": "testEmptyFileIsOnlyFileAndNotZeroIndex", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testEmptyFileIsOnlyFileAndNotZeroIndex() throws IOException {\n    fileSystem.createNewFile(new Path(shardPath.getParent(), \"data-001.json\"));\n    checkNextKeyValueWouldBlock();\n    fileSystem.createNewFile(new Path(shardPath.getParent(), \"data-002.json\"));\n    // Second file-marker with different index causes IllegalStateException.\n    assertThrows(IllegalStateException.class, () -> recordReader.nextKeyValue());\n  }", "signature": "void testEmptyFileIsOnlyFileAndNotZeroIndex()", "full_signature": "@Test public void testEmptyFileIsOnlyFileAndNotZeroIndex()", "class_method_signature": "DynamicFileListRecordReaderTest.testEmptyFileIsOnlyFileAndNotZeroIndex()", "testcase": true, "constructor": false, "invocations": ["createNewFile", "getParent", "checkNextKeyValueWouldBlock", "createNewFile", "getParent", "assertThrows", "nextKeyValue"]}, "focal_class": {"identifier": "DynamicFileListRecordReader", "superclass": "extends RecordReader<K, V>", "interfaces": "", "fields": [{"original_string": "private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();", "modifier": "private static final", "type": "GoogleLogger", "declarator": "logger = GoogleLogger.forEnclosingClass()", "var_name": "logger"}, {"original_string": "private Path inputDirectoryAndPattern;", "modifier": "private", "type": "Path", "declarator": "inputDirectoryAndPattern", "var_name": "inputDirectoryAndPattern"}, {"original_string": "private long estimatedNumRecords;", "modifier": "private", "type": "long", "declarator": "estimatedNumRecords", "var_name": "estimatedNumRecords"}, {"original_string": "private int maxPollAttempts;", "modifier": "private", "type": "int", "declarator": "maxPollAttempts", "var_name": "maxPollAttempts"}, {"original_string": "private int pollIntervalMs;", "modifier": "private", "type": "int", "declarator": "pollIntervalMs", "var_name": "pollIntervalMs"}, {"original_string": "private TaskAttemptContext context;", "modifier": "private", "type": "TaskAttemptContext", "declarator": "context", "var_name": "context"}, {"original_string": "private FileSystem fileSystem;", "modifier": "private", "type": "FileSystem", "declarator": "fileSystem", "var_name": "fileSystem"}, {"original_string": "private Pattern exportPattern;", "modifier": "private", "type": "Pattern", "declarator": "exportPattern", "var_name": "exportPattern"}, {"original_string": "private long recordsRead = 0;", "modifier": "private", "type": "long", "declarator": "recordsRead = 0", "var_name": "recordsRead"}, {"original_string": "private DelegateRecordReaderFactory<K, V> delegateRecordReaderFactory;", "modifier": "private", "type": "DelegateRecordReaderFactory<K, V>", "declarator": "delegateRecordReaderFactory", "var_name": "delegateRecordReaderFactory"}, {"original_string": "private RecordReader<K, V> delegateReader = null;", "modifier": "private", "type": "RecordReader<K, V>", "declarator": "delegateReader = null", "var_name": "delegateReader"}, {"original_string": "private Set<String> knownFileSet = new HashSet<>();", "modifier": "private", "type": "Set<String>", "declarator": "knownFileSet = new HashSet<>()", "var_name": "knownFileSet"}, {"original_string": "private Queue<FileStatus> fileQueue = new ArrayDeque<>();", "modifier": "private", "type": "Queue<FileStatus>", "declarator": "fileQueue = new ArrayDeque<>()", "var_name": "fileQueue"}, {"original_string": "private int endFileNumber = -1;", "modifier": "private", "type": "int", "declarator": "endFileNumber = -1", "var_name": "endFileNumber"}, {"original_string": "private Sleeper sleeper = Sleeper.DEFAULT;", "modifier": "private", "type": "Sleeper", "declarator": "sleeper = Sleeper.DEFAULT", "var_name": "sleeper"}, {"original_string": "private K currentKey = null;", "modifier": "private", "type": "K", "declarator": "currentKey = null", "var_name": "currentKey"}, {"original_string": "private V currentValue = null;", "modifier": "private", "type": "V", "declarator": "currentValue = null", "var_name": "currentValue"}], "methods": [{"identifier": "DynamicFileListRecordReader", "parameters": "(\n      DelegateRecordReaderFactory<K, V> delegateRecordReaderFactory)", "modifiers": "public", "return": "", "signature": " DynamicFileListRecordReader(\n      DelegateRecordReaderFactory<K, V> delegateRecordReaderFactory)", "full_signature": "public  DynamicFileListRecordReader(\n      DelegateRecordReaderFactory<K, V> delegateRecordReaderFactory)", "class_method_signature": "DynamicFileListRecordReader.DynamicFileListRecordReader(\n      DelegateRecordReaderFactory<K, V> delegateRecordReaderFactory)", "testcase": false, "constructor": true}, {"identifier": "initialize", "parameters": "(InputSplit genericSplit, TaskAttemptContext context)", "modifiers": "@Override public", "return": "void", "signature": "void initialize(InputSplit genericSplit, TaskAttemptContext context)", "full_signature": "@Override public void initialize(InputSplit genericSplit, TaskAttemptContext context)", "class_method_signature": "DynamicFileListRecordReader.initialize(InputSplit genericSplit, TaskAttemptContext context)", "testcase": false, "constructor": false}, {"identifier": "nextKeyValue", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean nextKeyValue()", "full_signature": "@Override public boolean nextKeyValue()", "class_method_signature": "DynamicFileListRecordReader.nextKeyValue()", "testcase": false, "constructor": false}, {"identifier": "getCurrentKey", "parameters": "()", "modifiers": "@Override public", "return": "K", "signature": "K getCurrentKey()", "full_signature": "@Override public K getCurrentKey()", "class_method_signature": "DynamicFileListRecordReader.getCurrentKey()", "testcase": false, "constructor": false}, {"identifier": "getCurrentValue", "parameters": "()", "modifiers": "@Override public", "return": "V", "signature": "V getCurrentValue()", "full_signature": "@Override public V getCurrentValue()", "class_method_signature": "DynamicFileListRecordReader.getCurrentValue()", "testcase": false, "constructor": false}, {"identifier": "getProgress", "parameters": "()", "modifiers": "@Override public", "return": "float", "signature": "float getProgress()", "full_signature": "@Override public float getProgress()", "class_method_signature": "DynamicFileListRecordReader.getProgress()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "DynamicFileListRecordReader.close()", "testcase": false, "constructor": false}, {"identifier": "setSleeper", "parameters": "(Sleeper sleeper)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void setSleeper(Sleeper sleeper)", "full_signature": "@VisibleForTesting void setSleeper(Sleeper sleeper)", "class_method_signature": "DynamicFileListRecordReader.setSleeper(Sleeper sleeper)", "testcase": false, "constructor": false}, {"identifier": "populateCurrentKeyValue", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void populateCurrentKeyValue()", "full_signature": "private void populateCurrentKeyValue()", "class_method_signature": "DynamicFileListRecordReader.populateCurrentKeyValue()", "testcase": false, "constructor": false}, {"identifier": "isNextFileReady", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean isNextFileReady()", "full_signature": "private boolean isNextFileReady()", "class_method_signature": "DynamicFileListRecordReader.isNextFileReady()", "testcase": false, "constructor": false}, {"identifier": "moveToNextFile", "parameters": "()", "modifiers": "private", "return": "FileStatus", "signature": "FileStatus moveToNextFile()", "full_signature": "private FileStatus moveToNextFile()", "class_method_signature": "DynamicFileListRecordReader.moveToNextFile()", "testcase": false, "constructor": false}, {"identifier": "shouldExpectMoreFiles", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean shouldExpectMoreFiles()", "full_signature": "private boolean shouldExpectMoreFiles()", "class_method_signature": "DynamicFileListRecordReader.shouldExpectMoreFiles()", "testcase": false, "constructor": false}, {"identifier": "parseFileIndex", "parameters": "(String fileName)", "modifiers": "private", "return": "int", "signature": "int parseFileIndex(String fileName)", "full_signature": "private int parseFileIndex(String fileName)", "class_method_signature": "DynamicFileListRecordReader.parseFileIndex(String fileName)", "testcase": false, "constructor": false}, {"identifier": "setEndFileMarkerFile", "parameters": "(String fileName)", "modifiers": "private", "return": "void", "signature": "void setEndFileMarkerFile(String fileName)", "full_signature": "private void setEndFileMarkerFile(String fileName)", "class_method_signature": "DynamicFileListRecordReader.setEndFileMarkerFile(String fileName)", "testcase": false, "constructor": false}, {"identifier": "refreshFileList", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void refreshFileList()", "full_signature": "private void refreshFileList()", "class_method_signature": "DynamicFileListRecordReader.refreshFileList()", "testcase": false, "constructor": false}], "file": "bigquery/src/main/java/com/google/cloud/hadoop/io/bigquery/DynamicFileListRecordReader.java"}, "focal_method": {"identifier": "nextKeyValue", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "body": "@Override\n  public boolean nextKeyValue() throws IOException, InterruptedException {\n    currentValue = null;\n\n    // Check if we already have a reader in-progress.\n    if (delegateReader != null) {\n      if (delegateReader.nextKeyValue()) {\n        populateCurrentKeyValue();\n        return true;\n      } else {\n        delegateReader.close();\n        delegateReader = null;\n      }\n    }\n\n    boolean needRefresh = !isNextFileReady() && shouldExpectMoreFiles();\n    int pollAttempt = 0;\n    while (needRefresh && (maxPollAttempts < 0 || pollAttempt < maxPollAttempts)) {\n      logger.atFine().log(\n          \"No files available after %d attempt(s), but more are expected; refreshing ...\",\n          pollAttempt + 1);\n      refreshFileList();\n      needRefresh = !isNextFileReady() && shouldExpectMoreFiles();\n      if (needRefresh) {\n        logger.atFine().log(\"No new files found, sleeping before trying again...\");\n        sleeper.sleep(pollIntervalMs);\n        context.progress();\n        pollAttempt++;\n      }\n    }\n\n    if (needRefresh) {\n      throw new IllegalStateException(\n          String.format(\n              \"Couldn't obtain any files after %d attempt(s). This could happen if in the first\"\n                  + \" failed task attempt BigQuery returned 0 records, but didn't create 0-record\"\n                  + \" file, in this case the second task attempt record reader will wait\"\n                  + \" indefinitely, but no files will appear.\",\n              pollAttempt));\n    }\n\n    if (isNextFileReady()) {\n      // Open the file and see if it's the 0-record end of dataset marker:\n      FileStatus newFile = moveToNextFile();\n      logger.atInfo().log(\n          \"Moving to next file '%s' which has %s bytes. Records read so far: %s\",\n          newFile.getPath(), newFile.getLen(), recordsRead);\n\n      InputSplit split = new FileSplit(newFile.getPath(), 0, newFile.getLen(), new String[0]);\n      delegateReader = delegateRecordReaderFactory.createDelegateRecordReader(\n          split, context.getConfiguration());\n      delegateReader.initialize(split, context);\n      if (!delegateReader.nextKeyValue()) {\n        // we found the end of dataset marker.\n        setEndFileMarkerFile(newFile.getPath().getName());\n        return nextKeyValue();\n      } else {\n        populateCurrentKeyValue();\n        return true;\n      }\n    }\n\n    Preconditions.checkState(\n        !shouldExpectMoreFiles(),\n        \"Should not have exited the refresh loop shouldExpectMoreFiles = true \"\n            + \"and no files ready to read.\");\n\n    // No files ready and we shouldn't expect any more.\n    return false;\n  }", "signature": "boolean nextKeyValue()", "full_signature": "@Override public boolean nextKeyValue()", "class_method_signature": "DynamicFileListRecordReader.nextKeyValue()", "testcase": false, "constructor": false, "invocations": ["nextKeyValue", "populateCurrentKeyValue", "close", "isNextFileReady", "shouldExpectMoreFiles", "log", "atFine", "refreshFileList", "isNextFileReady", "shouldExpectMoreFiles", "log", "atFine", "sleep", "progress", "format", "isNextFileReady", "moveToNextFile", "log", "atInfo", "getPath", "getLen", "getPath", "getLen", "createDelegateRecordReader", "getConfiguration", "initialize", "nextKeyValue", "setEndFileMarkerFile", "getName", "getPath", "nextKeyValue", "populateCurrentKeyValue", "checkState", "shouldExpectMoreFiles"]}, "repository": {"repo_id": 19684359, "url": "https://github.com/GoogleCloudDataproc/bigdata-interop", "stars": 178, "created": "5/12/2014 3:11:55 AM +00:00", "updates": "2020-01-23T23:10:40+00:00", "fork": "False", "license": "licensed"}}