{"test_class": {"identifier": "HystrixCommandTest", "superclass": "extends CommonHystrixCommandTests<TestHystrixCommand<Integer>>", "interfaces": "", "fields": [{"original_string": "@Rule\n    public HystrixRequestContextRule ctx = new HystrixRequestContextRule();", "modifier": "@Rule\n    public", "type": "HystrixRequestContextRule", "declarator": "ctx = new HystrixRequestContextRule()", "var_name": "ctx"}, {"original_string": "static AtomicInteger uniqueNameCounter = new AtomicInteger(1);", "modifier": "static", "type": "AtomicInteger", "declarator": "uniqueNameCounter = new AtomicInteger(1)", "var_name": "uniqueNameCounter"}], "file": "hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java"}, "test_case": {"identifier": "testInterruptFutureOnTimeout", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testInterruptFutureOnTimeout() throws InterruptedException, ExecutionException {\n        // given\n        InterruptibleCommand cmd = new InterruptibleCommand(new TestCircuitBreaker(), true);\n\n        // when\n        Future<Boolean> f = cmd.queue();\n\n        // then\n        Thread.sleep(500);\n        assertTrue(cmd.hasBeenInterrupted());\n    }", "signature": "void testInterruptFutureOnTimeout()", "full_signature": "@Test public void testInterruptFutureOnTimeout()", "class_method_signature": "HystrixCommandTest.testInterruptFutureOnTimeout()", "testcase": true, "constructor": false, "invocations": ["queue", "sleep", "assertTrue", "hasBeenInterrupted"]}, "focal_class": {"identifier": "HystrixCommand", "superclass": "extends AbstractCommand<R>", "interfaces": "implements HystrixExecutable<R>, HystrixInvokableInfo<R>, HystrixObservable<R>", "fields": [{"original_string": "private final AtomicReference<Thread> executionThread = new AtomicReference<Thread>();", "modifier": "private final", "type": "AtomicReference<Thread>", "declarator": "executionThread = new AtomicReference<Thread>()", "var_name": "executionThread"}, {"original_string": "private final AtomicBoolean interruptOnFutureCancel = new AtomicBoolean(false);", "modifier": "private final", "type": "AtomicBoolean", "declarator": "interruptOnFutureCancel = new AtomicBoolean(false)", "var_name": "interruptOnFutureCancel"}], "methods": [{"identifier": "HystrixCommand", "parameters": "(HystrixCommandGroupKey group)", "modifiers": "protected", "return": "", "signature": " HystrixCommand(HystrixCommandGroupKey group)", "full_signature": "protected  HystrixCommand(HystrixCommandGroupKey group)", "class_method_signature": "HystrixCommand.HystrixCommand(HystrixCommandGroupKey group)", "testcase": false, "constructor": true}, {"identifier": "HystrixCommand", "parameters": "(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool)", "modifiers": "protected", "return": "", "signature": " HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool)", "full_signature": "protected  HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool)", "class_method_signature": "HystrixCommand.HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool)", "testcase": false, "constructor": true}, {"identifier": "HystrixCommand", "parameters": "(HystrixCommandGroupKey group, int executionIsolationThreadTimeoutInMilliseconds)", "modifiers": "protected", "return": "", "signature": " HystrixCommand(HystrixCommandGroupKey group, int executionIsolationThreadTimeoutInMilliseconds)", "full_signature": "protected  HystrixCommand(HystrixCommandGroupKey group, int executionIsolationThreadTimeoutInMilliseconds)", "class_method_signature": "HystrixCommand.HystrixCommand(HystrixCommandGroupKey group, int executionIsolationThreadTimeoutInMilliseconds)", "testcase": false, "constructor": true}, {"identifier": "HystrixCommand", "parameters": "(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool, int executionIsolationThreadTimeoutInMilliseconds)", "modifiers": "protected", "return": "", "signature": " HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool, int executionIsolationThreadTimeoutInMilliseconds)", "full_signature": "protected  HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool, int executionIsolationThreadTimeoutInMilliseconds)", "class_method_signature": "HystrixCommand.HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool, int executionIsolationThreadTimeoutInMilliseconds)", "testcase": false, "constructor": true}, {"identifier": "HystrixCommand", "parameters": "(Setter setter)", "modifiers": "protected", "return": "", "signature": " HystrixCommand(Setter setter)", "full_signature": "protected  HystrixCommand(Setter setter)", "class_method_signature": "HystrixCommand.HystrixCommand(Setter setter)", "testcase": false, "constructor": true}, {"identifier": "HystrixCommand", "parameters": "(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,\n            HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,\n            HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,\n            HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)", "modifiers": "", "return": "", "signature": " HystrixCommand(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,\n            HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,\n            HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,\n            HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)", "full_signature": "  HystrixCommand(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,\n            HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,\n            HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,\n            HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)", "class_method_signature": "HystrixCommand.HystrixCommand(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,\n            HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,\n            HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,\n            HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "protected abstract", "return": "R", "signature": "R run()", "full_signature": "protected abstract R run()", "class_method_signature": "HystrixCommand.run()", "testcase": false, "constructor": false}, {"identifier": "getFallback", "parameters": "()", "modifiers": "protected", "return": "R", "signature": "R getFallback()", "full_signature": "protected R getFallback()", "class_method_signature": "HystrixCommand.getFallback()", "testcase": false, "constructor": false}, {"identifier": "getExecutionObservable", "parameters": "()", "modifiers": "@Override final protected", "return": "Observable<R>", "signature": "Observable<R> getExecutionObservable()", "full_signature": "@Override final protected Observable<R> getExecutionObservable()", "class_method_signature": "HystrixCommand.getExecutionObservable()", "testcase": false, "constructor": false}, {"identifier": "getFallbackObservable", "parameters": "()", "modifiers": "@Override final protected", "return": "Observable<R>", "signature": "Observable<R> getFallbackObservable()", "full_signature": "@Override final protected Observable<R> getFallbackObservable()", "class_method_signature": "HystrixCommand.getFallbackObservable()", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "()", "modifiers": "public", "return": "R", "signature": "R execute()", "full_signature": "public R execute()", "class_method_signature": "HystrixCommand.execute()", "testcase": false, "constructor": false}, {"identifier": "queue", "parameters": "()", "modifiers": "public", "return": "Future<R>", "signature": "Future<R> queue()", "full_signature": "public Future<R> queue()", "class_method_signature": "HystrixCommand.queue()", "testcase": false, "constructor": false}, {"identifier": "getFallbackMethodName", "parameters": "()", "modifiers": "@Override protected", "return": "String", "signature": "String getFallbackMethodName()", "full_signature": "@Override protected String getFallbackMethodName()", "class_method_signature": "HystrixCommand.getFallbackMethodName()", "testcase": false, "constructor": false}, {"identifier": "isFallbackUserDefined", "parameters": "()", "modifiers": "@Override protected", "return": "boolean", "signature": "boolean isFallbackUserDefined()", "full_signature": "@Override protected boolean isFallbackUserDefined()", "class_method_signature": "HystrixCommand.isFallbackUserDefined()", "testcase": false, "constructor": false}, {"identifier": "commandIsScalar", "parameters": "()", "modifiers": "@Override protected", "return": "boolean", "signature": "boolean commandIsScalar()", "full_signature": "@Override protected boolean commandIsScalar()", "class_method_signature": "HystrixCommand.commandIsScalar()", "testcase": false, "constructor": false}], "file": "hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java"}, "focal_method": {"identifier": "queue", "parameters": "()", "modifiers": "public", "return": "Future<R>", "body": "public Future<R> queue() {\n        /*\n         * The Future returned by Observable.toBlocking().toFuture() does not implement the\n         * interruption of the execution thread when the \"mayInterrupt\" flag of Future.cancel(boolean) is set to true;\n         * thus, to comply with the contract of Future, we must wrap around it.\n         */\n        final Future<R> delegate = toObservable().toBlocking().toFuture();\n    \t\n        final Future<R> f = new Future<R>() {\n\n            @Override\n            public boolean cancel(boolean mayInterruptIfRunning) {\n                if (delegate.isCancelled()) {\n                    return false;\n                }\n\n                if (HystrixCommand.this.getProperties().executionIsolationThreadInterruptOnFutureCancel().get()) {\n                    /*\n                     * The only valid transition here is false -> true. If there are two futures, say f1 and f2, created by this command\n                     * (which is super-weird, but has never been prohibited), and calls to f1.cancel(true) and to f2.cancel(false) are\n                     * issued by different threads, it's unclear about what value would be used by the time mayInterruptOnCancel is checked.\n                     * The most consistent way to deal with this scenario is to say that if *any* cancellation is invoked with interruption,\n                     * than that interruption request cannot be taken back.\n                     */\n                    interruptOnFutureCancel.compareAndSet(false, mayInterruptIfRunning);\n        \t\t}\n\n                final boolean res = delegate.cancel(interruptOnFutureCancel.get());\n\n                if (!isExecutionComplete() && interruptOnFutureCancel.get()) {\n                    final Thread t = executionThread.get();\n                    if (t != null && !t.equals(Thread.currentThread())) {\n                        t.interrupt();\n                    }\n                }\n\n                return res;\n\t\t\t}\n\n            @Override\n            public boolean isCancelled() {\n                return delegate.isCancelled();\n\t\t\t}\n\n            @Override\n            public boolean isDone() {\n                return delegate.isDone();\n\t\t\t}\n\n            @Override\n            public R get() throws InterruptedException, ExecutionException {\n                return delegate.get();\n            }\n\n            @Override\n            public R get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n                return delegate.get(timeout, unit);\n            }\n        \t\n        };\n\n        /* special handling of error states that throw immediately */\n        if (f.isDone()) {\n            try {\n                f.get();\n                return f;\n            } catch (Exception e) {\n                Throwable t = decomposeException(e);\n                if (t instanceof HystrixBadRequestException) {\n                    return f;\n                } else if (t instanceof HystrixRuntimeException) {\n                    HystrixRuntimeException hre = (HystrixRuntimeException) t;\n                    switch (hre.getFailureType()) {\n\t\t\t\t\tcase COMMAND_EXCEPTION:\n\t\t\t\t\tcase TIMEOUT:\n\t\t\t\t\t\t// we don't throw these types from queue() only from queue().get() as they are execution errors\n\t\t\t\t\t\treturn f;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// these are errors we throw from queue() as they as rejection type errors\n\t\t\t\t\t\tthrow hre;\n\t\t\t\t\t}\n                } else {\n                    throw Exceptions.sneakyThrow(t);\n                }\n            }\n        }\n\n        return f;\n    }", "signature": "Future<R> queue()", "full_signature": "public Future<R> queue()", "class_method_signature": "HystrixCommand.queue()", "testcase": false, "constructor": false, "invocations": ["toFuture", "toBlocking", "toObservable", "isCancelled", "get", "executionIsolationThreadInterruptOnFutureCancel", "getProperties", "compareAndSet", "cancel", "get", "isExecutionComplete", "get", "get", "equals", "currentThread", "interrupt", "isCancelled", "isDone", "get", "get", "isDone", "get", "decomposeException", "getFailureType", "sneakyThrow"]}, "repository": {"repo_id": 6766558, "url": "https://github.com/Netflix/Hystrix", "stars": 19028, "created": "11/19/2012 8:14:46 PM +00:00", "updates": "2020-01-27T17:55:28+00:00", "fork": "False", "license": "licensed"}}