{"test_class": {"identifier": "ThriftCodecTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ThriftCodec codec = new ThriftCodec();", "modifier": "private", "type": "ThriftCodec", "declarator": "codec = new ThriftCodec()", "var_name": "codec"}, {"original_string": "private Channel channel = new MockedChannel(URL.valueOf(\"thrift://127.0.0.1\"));", "modifier": "private", "type": "Channel", "declarator": "channel = new MockedChannel(URL.valueOf(\"thrift://127.0.0.1\"))", "var_name": "channel"}], "file": "dubbo-rpc/dubbo-rpc-thrift/src/test/java/org/apache/dubbo/rpc/protocol/thrift/ThriftCodecTest.java"}, "test_case": {"identifier": "testEncodeRequest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testEncodeRequest() throws Exception {\n\n        Request request = createRequest();\n\n        ChannelBuffer output = ChannelBuffers.dynamicBuffer(1024);\n\n        codec.encode(channel, output, request);\n\n        byte[] bytes = new byte[output.readableBytes()];\n        output.readBytes(bytes);\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n\n        TTransport transport = new TIOStreamTransport(bis);\n\n        TBinaryProtocol protocol = new TBinaryProtocol(transport);\n\n        // frame\n        byte[] length = new byte[4];\n        transport.read(length, 0, 4);\n\n        if (bis.markSupported()) {\n            bis.mark(0);\n        }\n\n        // magic\n        Assertions.assertEquals(ThriftCodec.MAGIC, protocol.readI16());\n\n        // message length\n        int messageLength = protocol.readI32();\n        Assertions.assertEquals(messageLength + 4, bytes.length);\n\n        // header length\n        short headerLength = protocol.readI16();\n        // version\n        Assertions.assertEquals(ThriftCodec.VERSION, protocol.readByte());\n        // service name\n        Assertions.assertEquals(Demo.Iface.class.getName(), protocol.readString());\n        // path\n        Assertions.assertEquals(Demo.Iface.class.getName(), protocol.readString());\n        // dubbo request id\n        Assertions.assertEquals(request.getId(), protocol.readI64());\n\n        // test message header length\n        if (bis.markSupported()) {\n            bis.reset();\n            bis.skip(headerLength);\n        }\n\n        TMessage message = protocol.readMessageBegin();\n\n        Demo.echoString_args args = new Demo.echoString_args();\n\n        args.read(protocol);\n\n        protocol.readMessageEnd();\n\n        Assertions.assertEquals(\"echoString\", message.name);\n\n        Assertions.assertEquals(TMessageType.CALL, message.type);\n\n        Assertions.assertEquals(\"Hello, World!\", args.getArg());\n\n    }", "signature": "void testEncodeRequest()", "full_signature": "@Test public void testEncodeRequest()", "class_method_signature": "ThriftCodecTest.testEncodeRequest()", "testcase": true, "constructor": false, "invocations": ["createRequest", "dynamicBuffer", "encode", "readableBytes", "readBytes", "read", "markSupported", "mark", "assertEquals", "readI16", "readI32", "assertEquals", "readI16", "assertEquals", "readByte", "assertEquals", "getName", "readString", "assertEquals", "getName", "readString", "assertEquals", "getId", "readI64", "markSupported", "reset", "skip", "readMessageBegin", "read", "readMessageEnd", "assertEquals", "assertEquals", "assertEquals", "getArg"]}, "focal_class": {"identifier": "ThriftCodec", "superclass": "", "interfaces": "implements Codec2", "fields": [{"original_string": "public static final int MESSAGE_LENGTH_INDEX = 2;", "modifier": "public static final", "type": "int", "declarator": "MESSAGE_LENGTH_INDEX = 2", "var_name": "MESSAGE_LENGTH_INDEX"}, {"original_string": "public static final int MESSAGE_HEADER_LENGTH_INDEX = 6;", "modifier": "public static final", "type": "int", "declarator": "MESSAGE_HEADER_LENGTH_INDEX = 6", "var_name": "MESSAGE_HEADER_LENGTH_INDEX"}, {"original_string": "public static final int MESSAGE_SHORTEST_LENGTH = 10;", "modifier": "public static final", "type": "int", "declarator": "MESSAGE_SHORTEST_LENGTH = 10", "var_name": "MESSAGE_SHORTEST_LENGTH"}, {"original_string": "public static final String NAME = \"thrift\";", "modifier": "public static final", "type": "String", "declarator": "NAME = \"thrift\"", "var_name": "NAME"}, {"original_string": "public static final String PARAMETER_CLASS_NAME_GENERATOR = \"class.name.generator\";", "modifier": "public static final", "type": "String", "declarator": "PARAMETER_CLASS_NAME_GENERATOR = \"class.name.generator\"", "var_name": "PARAMETER_CLASS_NAME_GENERATOR"}, {"original_string": "public static final byte VERSION = (byte) 1;", "modifier": "public static final", "type": "byte", "declarator": "VERSION = (byte) 1", "var_name": "VERSION"}, {"original_string": "public static final short MAGIC = (short) 0xdabc;", "modifier": "public static final", "type": "short", "declarator": "MAGIC = (short) 0xdabc", "var_name": "MAGIC"}, {"original_string": "static final ConcurrentMap<Long, RequestData> CACHED_REQUEST =\n            new ConcurrentHashMap<>();", "modifier": "static final", "type": "ConcurrentMap<Long, RequestData>", "declarator": "CACHED_REQUEST =\n            new ConcurrentHashMap<>()", "var_name": "CACHED_REQUEST"}, {"original_string": "private static final AtomicInteger THRIFT_SEQ_ID = new AtomicInteger(0);", "modifier": "private static final", "type": "AtomicInteger", "declarator": "THRIFT_SEQ_ID = new AtomicInteger(0)", "var_name": "THRIFT_SEQ_ID"}, {"original_string": "private static final ConcurrentMap<String, Class<?>> CACHED_CLASS =\n            new ConcurrentHashMap<>();", "modifier": "private static final", "type": "ConcurrentMap<String, Class<?>>", "declarator": "CACHED_CLASS =\n            new ConcurrentHashMap<>()", "var_name": "CACHED_CLASS"}], "methods": [{"identifier": "nextSeqId", "parameters": "()", "modifiers": "private static", "return": "int", "signature": "int nextSeqId()", "full_signature": "private static int nextSeqId()", "class_method_signature": "ThriftCodec.nextSeqId()", "testcase": false, "constructor": false}, {"identifier": "getSeqId", "parameters": "()", "modifiers": "static", "return": "int", "signature": "int getSeqId()", "full_signature": "static int getSeqId()", "class_method_signature": "ThriftCodec.getSeqId()", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(Channel channel, ChannelBuffer buffer, Object message)", "modifiers": "@Override public", "return": "void", "signature": "void encode(Channel channel, ChannelBuffer buffer, Object message)", "full_signature": "@Override public void encode(Channel channel, ChannelBuffer buffer, Object message)", "class_method_signature": "ThriftCodec.encode(Channel channel, ChannelBuffer buffer, Object message)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(Channel channel, ChannelBuffer buffer)", "modifiers": "@Override public", "return": "Object", "signature": "Object decode(Channel channel, ChannelBuffer buffer)", "full_signature": "@Override public Object decode(Channel channel, ChannelBuffer buffer)", "class_method_signature": "ThriftCodec.decode(Channel channel, ChannelBuffer buffer)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(TProtocol protocol)", "modifiers": "private", "return": "Object", "signature": "Object decode(TProtocol protocol)", "full_signature": "private Object decode(TProtocol protocol)", "class_method_signature": "ThriftCodec.decode(TProtocol protocol)", "testcase": false, "constructor": false}, {"identifier": "encodeRequest", "parameters": "(Channel channel, ChannelBuffer buffer, Request request)", "modifiers": "private", "return": "void", "signature": "void encodeRequest(Channel channel, ChannelBuffer buffer, Request request)", "full_signature": "private void encodeRequest(Channel channel, ChannelBuffer buffer, Request request)", "class_method_signature": "ThriftCodec.encodeRequest(Channel channel, ChannelBuffer buffer, Request request)", "testcase": false, "constructor": false}, {"identifier": "encodeResponse", "parameters": "(Channel channel, ChannelBuffer buffer, Response response)", "modifiers": "private", "return": "void", "signature": "void encodeResponse(Channel channel, ChannelBuffer buffer, Response response)", "full_signature": "private void encodeResponse(Channel channel, ChannelBuffer buffer, Response response)", "class_method_signature": "ThriftCodec.encodeResponse(Channel channel, ChannelBuffer buffer, Response response)", "testcase": false, "constructor": false}], "file": "dubbo-rpc/dubbo-rpc-thrift/src/main/java/org/apache/dubbo/rpc/protocol/thrift/ThriftCodec.java"}, "focal_method": {"identifier": "encodeRequest", "parameters": "(Channel channel, ChannelBuffer buffer, Request request)", "modifiers": "private", "return": "void", "body": "private void encodeRequest(Channel channel, ChannelBuffer buffer, Request request)\n            throws IOException {\n\n        RpcInvocation inv = (RpcInvocation) request.getData();\n\n        int seqId = nextSeqId();\n\n        String serviceName = inv.getAttachment(INTERFACE_KEY);\n\n        if (StringUtils.isEmpty(serviceName)) {\n            throw new IllegalArgumentException(\"Could not find service name in attachment with key \"\n                    + INTERFACE_KEY);\n        }\n\n        TMessage message = new TMessage(\n                inv.getMethodName(),\n                TMessageType.CALL,\n                seqId);\n\n        String methodArgs = ExtensionLoader.getExtensionLoader(ClassNameGenerator.class)\n                .getExtension(channel.getUrl().getParameter(ThriftConstants.CLASS_NAME_GENERATOR_KEY, ThriftClassNameGenerator.NAME))\n                .generateArgsClassName(serviceName, inv.getMethodName());\n\n        if (StringUtils.isEmpty(methodArgs)) {\n            throw new RpcException(RpcException.SERIALIZATION_EXCEPTION,\n                    \"Could not encode request, the specified interface may be incorrect.\");\n        }\n\n        Class<?> clazz = CACHED_CLASS.get(methodArgs);\n\n        if (clazz == null) {\n\n            try {\n\n                clazz = ClassUtils.forNameWithThreadContextClassLoader(methodArgs);\n\n                CACHED_CLASS.putIfAbsent(methodArgs, clazz);\n\n            } catch (ClassNotFoundException e) {\n                throw new RpcException(RpcException.SERIALIZATION_EXCEPTION, e.getMessage(), e);\n            }\n\n        }\n\n        TBase args;\n\n        try {\n            args = (TBase) clazz.newInstance();\n        } catch (InstantiationException | IllegalAccessException e) {\n            throw new RpcException(RpcException.SERIALIZATION_EXCEPTION, e.getMessage(), e);\n        }\n\n        for (int i = 0; i < inv.getArguments().length; i++) {\n\n            Object obj = inv.getArguments()[i];\n\n            if (obj == null) {\n                continue;\n            }\n\n            TFieldIdEnum field = args.fieldForId(i + 1);\n\n            String setMethodName = ThriftUtils.generateSetMethodName(field.getFieldName());\n\n            Method method;\n\n            try {\n                method = clazz.getMethod(setMethodName, inv.getParameterTypes()[i]);\n            } catch (NoSuchMethodException e) {\n                throw new RpcException(RpcException.SERIALIZATION_EXCEPTION, e.getMessage(), e);\n            }\n\n            try {\n                method.invoke(args, obj);\n            } catch (IllegalAccessException | InvocationTargetException e) {\n                throw new RpcException(RpcException.SERIALIZATION_EXCEPTION, e.getMessage(), e);\n            }\n\n        }\n\n        RandomAccessByteArrayOutputStream bos = new RandomAccessByteArrayOutputStream(1024);\n\n        TIOStreamTransport transport = new TIOStreamTransport(bos);\n\n        TBinaryProtocol protocol = new TBinaryProtocol(transport);\n\n        int headerLength, messageLength;\n\n        byte[] bytes = new byte[4];\n        try {\n            // magic\n            protocol.writeI16(MAGIC);\n            // message length placeholder\n            protocol.writeI32(Integer.MAX_VALUE);\n            // message header length placeholder\n            protocol.writeI16(Short.MAX_VALUE);\n            // version\n            protocol.writeByte(VERSION);\n            // service name\n            protocol.writeString(serviceName);\n            // path\n            protocol.writeString(inv.getAttachment(PATH_KEY));\n            // dubbo request id\n            protocol.writeI64(request.getId());\n            protocol.getTransport().flush();\n            // header size\n            headerLength = bos.size();\n\n            // message body\n            protocol.writeMessageBegin(message);\n            args.write(protocol);\n            protocol.writeMessageEnd();\n            protocol.getTransport().flush();\n            int oldIndex = messageLength = bos.size();\n\n            // fill in message length and header length\n            try {\n                TFramedTransport.encodeFrameSize(messageLength, bytes);\n                bos.setWriteIndex(MESSAGE_LENGTH_INDEX);\n                protocol.writeI32(messageLength);\n                bos.setWriteIndex(MESSAGE_HEADER_LENGTH_INDEX);\n                protocol.writeI16((short) (0xffff & headerLength));\n            } finally {\n                bos.setWriteIndex(oldIndex);\n            }\n\n        } catch (TException e) {\n            throw new RpcException(RpcException.SERIALIZATION_EXCEPTION, e.getMessage(), e);\n        }\n\n        buffer.writeBytes(bytes);\n        buffer.writeBytes(bos.toByteArray());\n\n    }", "signature": "void encodeRequest(Channel channel, ChannelBuffer buffer, Request request)", "full_signature": "private void encodeRequest(Channel channel, ChannelBuffer buffer, Request request)", "class_method_signature": "ThriftCodec.encodeRequest(Channel channel, ChannelBuffer buffer, Request request)", "testcase": false, "constructor": false, "invocations": ["getData", "nextSeqId", "getAttachment", "isEmpty", "getMethodName", "generateArgsClassName", "getExtension", "getExtensionLoader", "getParameter", "getUrl", "getMethodName", "isEmpty", "get", "forNameWithThreadContextClassLoader", "putIfAbsent", "getMessage", "newInstance", "getMessage", "getArguments", "getArguments", "fieldForId", "generateSetMethodName", "getFieldName", "getMethod", "getParameterTypes", "getMessage", "invoke", "getMessage", "writeI16", "writeI32", "writeI16", "writeByte", "writeString", "writeString", "getAttachment", "writeI64", "getId", "flush", "getTransport", "size", "writeMessageBegin", "write", "writeMessageEnd", "flush", "getTransport", "size", "encodeFrameSize", "setWriteIndex", "writeI32", "setWriteIndex", "writeI16", "setWriteIndex", "getMessage", "writeBytes", "writeBytes", "toByteArray"]}, "repository": {"repo_id": 4710920, "url": "https://github.com/apache/dubbo", "stars": 30960, "created": "6/19/2012 7:56:02 AM +00:00", "updates": "2020-01-27T14:21:03+00:00", "fork": "False", "license": "licensed"}}