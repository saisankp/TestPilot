{"test_class": {"identifier": "PcapHandleTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private PcapHandle ph;", "modifier": "private", "type": "PcapHandle", "declarator": "ph", "var_name": "ph"}], "file": "pcap4j-core/src/test/java/org/pcap4j/core/PcapHandleTest.java"}, "test_case": {"identifier": "testGetStats", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testGetStats() throws Exception {\n    if (ph != null) {\n      ph.close();\n    }\n\n    List<PcapNetworkInterface> nifs = Pcaps.findAllDevs();\n    if (nifs.isEmpty()) {\n      ph = Pcaps.openDead(DataLinkType.EN10MB, 2048);\n      try {\n        ph.getStats();\n        fail(\"getStats on a pcap_open_dead pcap_t should throw a PcapNativeException.\");\n      } catch (PcapNativeException e) {\n        assertEquals(\"Statistics aren't available from a pcap_open_dead pcap_t\", e.getMessage());\n      }\n    } else {\n      try {\n        ph = nifs.get(0).openLive(55555, PromiscuousMode.PROMISCUOUS, 100);\n        PcapStat ps = ph.getStats();\n        assertNotNull(ps);\n      } catch (PcapNativeException e) {\n        assertTrue(\n            \"The exception should complain about permission to capture.\",\n            e.getMessage().contains(\"You don't have permission to capture on that device\"));\n      }\n    }\n  }", "signature": "void testGetStats()", "full_signature": "@Test public void testGetStats()", "class_method_signature": "PcapHandleTest.testGetStats()", "testcase": true, "constructor": false, "invocations": ["close", "findAllDevs", "isEmpty", "openDead", "getStats", "fail", "assertEquals", "getMessage", "openLive", "get", "getStats", "assertNotNull", "assertTrue", "contains", "getMessage"]}, "focal_class": {"identifier": "PcapHandle", "superclass": "", "interfaces": "implements Closeable", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(PcapHandle.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(PcapHandle.class)", "var_name": "logger"}, {"original_string": "private volatile DataLinkType dlt;", "modifier": "private volatile", "type": "DataLinkType", "declarator": "dlt", "var_name": "dlt"}, {"original_string": "private final TimestampPrecision timestampPrecision;", "modifier": "private final", "type": "TimestampPrecision", "declarator": "timestampPrecision", "var_name": "timestampPrecision"}, {"original_string": "private final Pointer handle;", "modifier": "private final", "type": "Pointer", "declarator": "handle", "var_name": "handle"}, {"original_string": "private final ThreadLocal<Timestamp> timestamps = new ThreadLocal<Timestamp>();", "modifier": "private final", "type": "ThreadLocal<Timestamp>", "declarator": "timestamps = new ThreadLocal<Timestamp>()", "var_name": "timestamps"}, {"original_string": "private final ThreadLocal<Integer> originalLengths = new ThreadLocal<Integer>();", "modifier": "private final", "type": "ThreadLocal<Integer>", "declarator": "originalLengths = new ThreadLocal<Integer>()", "var_name": "originalLengths"}, {"original_string": "private final ReentrantReadWriteLock handleLock = new ReentrantReadWriteLock(true);", "modifier": "private final", "type": "ReentrantReadWriteLock", "declarator": "handleLock = new ReentrantReadWriteLock(true)", "var_name": "handleLock"}, {"original_string": "private static final Object compileLock = new Object();", "modifier": "private static final", "type": "Object", "declarator": "compileLock = new Object()", "var_name": "compileLock"}, {"original_string": "private volatile boolean open = true;", "modifier": "private volatile", "type": "boolean", "declarator": "open = true", "var_name": "open"}, {"original_string": "private volatile String filteringExpression = \"\";", "modifier": "private volatile", "type": "String", "declarator": "filteringExpression = \"\"", "var_name": "filteringExpression"}, {"original_string": "public static final Inet4Address PCAP_NETMASK_UNKNOWN;", "modifier": "public static final", "type": "Inet4Address", "declarator": "PCAP_NETMASK_UNKNOWN", "var_name": "PCAP_NETMASK_UNKNOWN"}], "methods": [{"identifier": "PcapHandle", "parameters": "(Pointer handle, TimestampPrecision timestampPrecision)", "modifiers": "", "return": "", "signature": " PcapHandle(Pointer handle, TimestampPrecision timestampPrecision)", "full_signature": "  PcapHandle(Pointer handle, TimestampPrecision timestampPrecision)", "class_method_signature": "PcapHandle.PcapHandle(Pointer handle, TimestampPrecision timestampPrecision)", "testcase": false, "constructor": true}, {"identifier": "PcapHandle", "parameters": "(Builder builder)", "modifiers": "private", "return": "", "signature": " PcapHandle(Builder builder)", "full_signature": "private  PcapHandle(Builder builder)", "class_method_signature": "PcapHandle.PcapHandle(Builder builder)", "testcase": false, "constructor": true}, {"identifier": "getDltByNative", "parameters": "()", "modifiers": "private", "return": "DataLinkType", "signature": "DataLinkType getDltByNative()", "full_signature": "private DataLinkType getDltByNative()", "class_method_signature": "PcapHandle.getDltByNative()", "testcase": false, "constructor": false}, {"identifier": "getDlt", "parameters": "()", "modifiers": "public", "return": "DataLinkType", "signature": "DataLinkType getDlt()", "full_signature": "public DataLinkType getDlt()", "class_method_signature": "PcapHandle.getDlt()", "testcase": false, "constructor": false}, {"identifier": "setDlt", "parameters": "(DataLinkType dlt)", "modifiers": "public", "return": "void", "signature": "void setDlt(DataLinkType dlt)", "full_signature": "public void setDlt(DataLinkType dlt)", "class_method_signature": "PcapHandle.setDlt(DataLinkType dlt)", "testcase": false, "constructor": false}, {"identifier": "isOpen", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isOpen()", "full_signature": "public boolean isOpen()", "class_method_signature": "PcapHandle.isOpen()", "testcase": false, "constructor": false}, {"identifier": "getFilteringExpression", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getFilteringExpression()", "full_signature": "public String getFilteringExpression()", "class_method_signature": "PcapHandle.getFilteringExpression()", "testcase": false, "constructor": false}, {"identifier": "getTimestampPrecision", "parameters": "()", "modifiers": "public", "return": "TimestampPrecision", "signature": "TimestampPrecision getTimestampPrecision()", "full_signature": "public TimestampPrecision getTimestampPrecision()", "class_method_signature": "PcapHandle.getTimestampPrecision()", "testcase": false, "constructor": false}, {"identifier": "setDirection", "parameters": "(PcapDirection direction)", "modifiers": "public", "return": "void", "signature": "void setDirection(PcapDirection direction)", "full_signature": "public void setDirection(PcapDirection direction)", "class_method_signature": "PcapHandle.setDirection(PcapDirection direction)", "testcase": false, "constructor": false}, {"identifier": "getTimestamp", "parameters": "()", "modifiers": "public", "return": "Timestamp", "signature": "Timestamp getTimestamp()", "full_signature": "public Timestamp getTimestamp()", "class_method_signature": "PcapHandle.getTimestamp()", "testcase": false, "constructor": false}, {"identifier": "getOriginalLength", "parameters": "()", "modifiers": "public", "return": "Integer", "signature": "Integer getOriginalLength()", "full_signature": "public Integer getOriginalLength()", "class_method_signature": "PcapHandle.getOriginalLength()", "testcase": false, "constructor": false}, {"identifier": "getSnapshot", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getSnapshot()", "full_signature": "public int getSnapshot()", "class_method_signature": "PcapHandle.getSnapshot()", "testcase": false, "constructor": false}, {"identifier": "isSwapped", "parameters": "()", "modifiers": "public", "return": "SwappedType", "signature": "SwappedType isSwapped()", "full_signature": "public SwappedType isSwapped()", "class_method_signature": "PcapHandle.isSwapped()", "testcase": false, "constructor": false}, {"identifier": "getMajorVersion", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMajorVersion()", "full_signature": "public int getMajorVersion()", "class_method_signature": "PcapHandle.getMajorVersion()", "testcase": false, "constructor": false}, {"identifier": "getMinorVersion", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMinorVersion()", "full_signature": "public int getMinorVersion()", "class_method_signature": "PcapHandle.getMinorVersion()", "testcase": false, "constructor": false}, {"identifier": "compileFilter", "parameters": "(String bpfExpression, BpfCompileMode mode, Inet4Address netmask)", "modifiers": "public", "return": "BpfProgram", "signature": "BpfProgram compileFilter(String bpfExpression, BpfCompileMode mode, Inet4Address netmask)", "full_signature": "public BpfProgram compileFilter(String bpfExpression, BpfCompileMode mode, Inet4Address netmask)", "class_method_signature": "PcapHandle.compileFilter(String bpfExpression, BpfCompileMode mode, Inet4Address netmask)", "testcase": false, "constructor": false}, {"identifier": "setFilter", "parameters": "(String bpfExpression, BpfCompileMode mode, Inet4Address netmask)", "modifiers": "public", "return": "void", "signature": "void setFilter(String bpfExpression, BpfCompileMode mode, Inet4Address netmask)", "full_signature": "public void setFilter(String bpfExpression, BpfCompileMode mode, Inet4Address netmask)", "class_method_signature": "PcapHandle.setFilter(String bpfExpression, BpfCompileMode mode, Inet4Address netmask)", "testcase": false, "constructor": false}, {"identifier": "setFilter", "parameters": "(String bpfExpression, BpfCompileMode mode)", "modifiers": "public", "return": "void", "signature": "void setFilter(String bpfExpression, BpfCompileMode mode)", "full_signature": "public void setFilter(String bpfExpression, BpfCompileMode mode)", "class_method_signature": "PcapHandle.setFilter(String bpfExpression, BpfCompileMode mode)", "testcase": false, "constructor": false}, {"identifier": "setFilter", "parameters": "(BpfProgram prog)", "modifiers": "public", "return": "void", "signature": "void setFilter(BpfProgram prog)", "full_signature": "public void setFilter(BpfProgram prog)", "class_method_signature": "PcapHandle.setFilter(BpfProgram prog)", "testcase": false, "constructor": false}, {"identifier": "setBlockingMode", "parameters": "(BlockingMode mode)", "modifiers": "public", "return": "void", "signature": "void setBlockingMode(BlockingMode mode)", "full_signature": "public void setBlockingMode(BlockingMode mode)", "class_method_signature": "PcapHandle.setBlockingMode(BlockingMode mode)", "testcase": false, "constructor": false}, {"identifier": "getBlockingMode", "parameters": "()", "modifiers": "public", "return": "BlockingMode", "signature": "BlockingMode getBlockingMode()", "full_signature": "public BlockingMode getBlockingMode()", "class_method_signature": "PcapHandle.getBlockingMode()", "testcase": false, "constructor": false}, {"identifier": "getNextPacket", "parameters": "()", "modifiers": "public", "return": "Packet", "signature": "Packet getNextPacket()", "full_signature": "public Packet getNextPacket()", "class_method_signature": "PcapHandle.getNextPacket()", "testcase": false, "constructor": false}, {"identifier": "getNextRawPacket", "parameters": "()", "modifiers": "public", "return": "byte[]", "signature": "byte[] getNextRawPacket()", "full_signature": "public byte[] getNextRawPacket()", "class_method_signature": "PcapHandle.getNextRawPacket()", "testcase": false, "constructor": false}, {"identifier": "getNextPacketEx", "parameters": "()", "modifiers": "public", "return": "Packet", "signature": "Packet getNextPacketEx()", "full_signature": "public Packet getNextPacketEx()", "class_method_signature": "PcapHandle.getNextPacketEx()", "testcase": false, "constructor": false}, {"identifier": "getNextRawPacketEx", "parameters": "()", "modifiers": "public", "return": "byte[]", "signature": "byte[] getNextRawPacketEx()", "full_signature": "public byte[] getNextRawPacketEx()", "class_method_signature": "PcapHandle.getNextRawPacketEx()", "testcase": false, "constructor": false}, {"identifier": "loop", "parameters": "(int packetCount, PacketListener listener)", "modifiers": "public", "return": "void", "signature": "void loop(int packetCount, PacketListener listener)", "full_signature": "public void loop(int packetCount, PacketListener listener)", "class_method_signature": "PcapHandle.loop(int packetCount, PacketListener listener)", "testcase": false, "constructor": false}, {"identifier": "loop", "parameters": "(int packetCount, PacketListener listener, Executor executor)", "modifiers": "public", "return": "void", "signature": "void loop(int packetCount, PacketListener listener, Executor executor)", "full_signature": "public void loop(int packetCount, PacketListener listener, Executor executor)", "class_method_signature": "PcapHandle.loop(int packetCount, PacketListener listener, Executor executor)", "testcase": false, "constructor": false}, {"identifier": "loop", "parameters": "(int packetCount, RawPacketListener listener)", "modifiers": "public", "return": "void", "signature": "void loop(int packetCount, RawPacketListener listener)", "full_signature": "public void loop(int packetCount, RawPacketListener listener)", "class_method_signature": "PcapHandle.loop(int packetCount, RawPacketListener listener)", "testcase": false, "constructor": false}, {"identifier": "loop", "parameters": "(int packetCount, RawPacketListener listener, Executor executor)", "modifiers": "public", "return": "void", "signature": "void loop(int packetCount, RawPacketListener listener, Executor executor)", "full_signature": "public void loop(int packetCount, RawPacketListener listener, Executor executor)", "class_method_signature": "PcapHandle.loop(int packetCount, RawPacketListener listener, Executor executor)", "testcase": false, "constructor": false}, {"identifier": "doLoop", "parameters": "(int packetCount, NativeMappings.pcap_handler handler)", "modifiers": "private", "return": "void", "signature": "void doLoop(int packetCount, NativeMappings.pcap_handler handler)", "full_signature": "private void doLoop(int packetCount, NativeMappings.pcap_handler handler)", "class_method_signature": "PcapHandle.doLoop(int packetCount, NativeMappings.pcap_handler handler)", "testcase": false, "constructor": false}, {"identifier": "dispatch", "parameters": "(int packetCount, PacketListener listener)", "modifiers": "public", "return": "int", "signature": "int dispatch(int packetCount, PacketListener listener)", "full_signature": "public int dispatch(int packetCount, PacketListener listener)", "class_method_signature": "PcapHandle.dispatch(int packetCount, PacketListener listener)", "testcase": false, "constructor": false}, {"identifier": "dispatch", "parameters": "(int packetCount, PacketListener listener, Executor executor)", "modifiers": "public", "return": "int", "signature": "int dispatch(int packetCount, PacketListener listener, Executor executor)", "full_signature": "public int dispatch(int packetCount, PacketListener listener, Executor executor)", "class_method_signature": "PcapHandle.dispatch(int packetCount, PacketListener listener, Executor executor)", "testcase": false, "constructor": false}, {"identifier": "dispatch", "parameters": "(int packetCount, RawPacketListener listener)", "modifiers": "public", "return": "int", "signature": "int dispatch(int packetCount, RawPacketListener listener)", "full_signature": "public int dispatch(int packetCount, RawPacketListener listener)", "class_method_signature": "PcapHandle.dispatch(int packetCount, RawPacketListener listener)", "testcase": false, "constructor": false}, {"identifier": "dispatch", "parameters": "(int packetCount, RawPacketListener listener, Executor executor)", "modifiers": "public", "return": "int", "signature": "int dispatch(int packetCount, RawPacketListener listener, Executor executor)", "full_signature": "public int dispatch(int packetCount, RawPacketListener listener, Executor executor)", "class_method_signature": "PcapHandle.dispatch(int packetCount, RawPacketListener listener, Executor executor)", "testcase": false, "constructor": false}, {"identifier": "doDispatch", "parameters": "(int packetCount, NativeMappings.pcap_handler handler)", "modifiers": "private", "return": "int", "signature": "int doDispatch(int packetCount, NativeMappings.pcap_handler handler)", "full_signature": "private int doDispatch(int packetCount, NativeMappings.pcap_handler handler)", "class_method_signature": "PcapHandle.doDispatch(int packetCount, NativeMappings.pcap_handler handler)", "testcase": false, "constructor": false}, {"identifier": "dumpOpen", "parameters": "(String filePath)", "modifiers": "public", "return": "PcapDumper", "signature": "PcapDumper dumpOpen(String filePath)", "full_signature": "public PcapDumper dumpOpen(String filePath)", "class_method_signature": "PcapHandle.dumpOpen(String filePath)", "testcase": false, "constructor": false}, {"identifier": "loop", "parameters": "(int packetCount, PcapDumper dumper)", "modifiers": "public", "return": "void", "signature": "void loop(int packetCount, PcapDumper dumper)", "full_signature": "public void loop(int packetCount, PcapDumper dumper)", "class_method_signature": "PcapHandle.loop(int packetCount, PcapDumper dumper)", "testcase": false, "constructor": false}, {"identifier": "breakLoop", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void breakLoop()", "full_signature": "public void breakLoop()", "class_method_signature": "PcapHandle.breakLoop()", "testcase": false, "constructor": false}, {"identifier": "sendPacket", "parameters": "(Packet packet)", "modifiers": "public", "return": "void", "signature": "void sendPacket(Packet packet)", "full_signature": "public void sendPacket(Packet packet)", "class_method_signature": "PcapHandle.sendPacket(Packet packet)", "testcase": false, "constructor": false}, {"identifier": "sendPacket", "parameters": "(byte[] bytes)", "modifiers": "public", "return": "void", "signature": "void sendPacket(byte[] bytes)", "full_signature": "public void sendPacket(byte[] bytes)", "class_method_signature": "PcapHandle.sendPacket(byte[] bytes)", "testcase": false, "constructor": false}, {"identifier": "sendPacket", "parameters": "(byte[] bytes, int len)", "modifiers": "public", "return": "void", "signature": "void sendPacket(byte[] bytes, int len)", "full_signature": "public void sendPacket(byte[] bytes, int len)", "class_method_signature": "PcapHandle.sendPacket(byte[] bytes, int len)", "testcase": false, "constructor": false}, {"identifier": "getStats", "parameters": "()", "modifiers": "public", "return": "PcapStat", "signature": "PcapStat getStats()", "full_signature": "public PcapStat getStats()", "class_method_signature": "PcapHandle.getStats()", "testcase": false, "constructor": false}, {"identifier": "listDatalinks", "parameters": "()", "modifiers": "public", "return": "List<DataLinkType>", "signature": "List<DataLinkType> listDatalinks()", "full_signature": "public List<DataLinkType> listDatalinks()", "class_method_signature": "PcapHandle.listDatalinks()", "testcase": false, "constructor": false}, {"identifier": "getError", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getError()", "full_signature": "public String getError()", "class_method_signature": "PcapHandle.getError()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "PcapHandle.close()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "PcapHandle.toString()", "testcase": false, "constructor": false}, {"identifier": "buildTimestamp", "parameters": "(Pointer header)", "modifiers": "private", "return": "Timestamp", "signature": "Timestamp buildTimestamp(Pointer header)", "full_signature": "private Timestamp buildTimestamp(Pointer header)", "class_method_signature": "PcapHandle.buildTimestamp(Pointer header)", "testcase": false, "constructor": false}], "file": "pcap4j-core/src/main/java/org/pcap4j/core/PcapHandle.java"}, "focal_method": {"identifier": "getStats", "parameters": "()", "modifiers": "public", "return": "PcapStat", "body": "public PcapStat getStats() throws PcapNativeException, NotOpenException {\n    if (!open) {\n      throw new NotOpenException();\n    }\n\n    if (!handleLock.readLock().tryLock()) {\n      throw new NotOpenException();\n    }\n    try {\n      if (!open) {\n        throw new NotOpenException();\n      }\n\n      if (Platform.isWindows()) {\n        IntByReference pcapStatSize = new IntByReference();\n        Pointer psp = PcapLibrary.INSTANCE.win_pcap_stats_ex(handle, pcapStatSize);\n        if (!getError()\n            .equals(\"Cannot retrieve the extended statistics from a file or a TurboCap port\")) {\n          if (pcapStatSize.getValue() != 24) {\n            throw new PcapNativeException(getError());\n          }\n          if (psp == null) {\n            throw new PcapNativeException(getError());\n          }\n          return new PcapStat(psp, true);\n        }\n      }\n\n      pcap_stat ps = new pcap_stat();\n      ps.setAutoSynch(false);\n      int rc = NativeMappings.pcap_stats(handle, ps);\n      if (rc < 0) {\n        throw new PcapNativeException(getError(), rc);\n      }\n\n      return new PcapStat(ps.getPointer(), false);\n    } finally {\n      handleLock.readLock().unlock();\n    }\n  }", "signature": "PcapStat getStats()", "full_signature": "public PcapStat getStats()", "class_method_signature": "PcapHandle.getStats()", "testcase": false, "constructor": false, "invocations": ["tryLock", "readLock", "isWindows", "win_pcap_stats_ex", "equals", "getError", "getValue", "getError", "getError", "setAutoSynch", "pcap_stats", "getError", "getPointer", "unlock", "readLock"]}, "repository": {"repo_id": 3005042, "url": "https://github.com/kaitoy/pcap4j", "language": "Java", "is_fork": false, "fork_count": 247, "stargazer_count": 779, "size": 15246, "license": "licensed"}}