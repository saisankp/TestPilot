{"test_class": {"identifier": "MemoryProfilerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final Memory.MemoryAllocSamplingData DEFAULT_MEMORY_ALLOCATION_SAMPLING_DATA =\n    Memory.MemoryAllocSamplingData.newBuilder().setSamplingNumInterval(10).build();", "modifier": "public static final", "type": "Memory.MemoryAllocSamplingData", "declarator": "DEFAULT_MEMORY_ALLOCATION_SAMPLING_DATA =\n    Memory.MemoryAllocSamplingData.newBuilder().setSamplingNumInterval(10).build()", "var_name": "DEFAULT_MEMORY_ALLOCATION_SAMPLING_DATA"}, {"original_string": "private static final int FAKE_PID = 111;", "modifier": "private static final", "type": "int", "declarator": "FAKE_PID = 111", "var_name": "FAKE_PID"}, {"original_string": "private static final Common.Session TEST_SESSION = Common.Session.newBuilder().setSessionId(1).setPid(FAKE_PID).build();", "modifier": "private static final", "type": "Common.Session", "declarator": "TEST_SESSION = Common.Session.newBuilder().setSessionId(1).setPid(FAKE_PID).build()", "var_name": "TEST_SESSION"}, {"original_string": "private static final long DEVICE_STARTTIME_NS = 0;", "modifier": "private static final", "type": "long", "declarator": "DEVICE_STARTTIME_NS = 0", "var_name": "DEVICE_STARTTIME_NS"}, {"original_string": "private final FakeTimer myTimer = new FakeTimer();", "modifier": "private final", "type": "FakeTimer", "declarator": "myTimer = new FakeTimer()", "var_name": "myTimer"}, {"original_string": "private final FakeTransportService myTransportService = new FakeTransportService(myTimer, false);", "modifier": "private final", "type": "FakeTransportService", "declarator": "myTransportService = new FakeTransportService(myTimer, false)", "var_name": "myTransportService"}, {"original_string": "private final FakeMemoryService myMemoryService = new FakeMemoryService();", "modifier": "private final", "type": "FakeMemoryService", "declarator": "myMemoryService = new FakeMemoryService()", "var_name": "myMemoryService"}, {"original_string": "@Rule public FakeGrpcChannel myGrpcChannel =\n    new FakeGrpcChannel(\"MemoryProfilerTest\", myMemoryService, myTransportService, new FakeProfilerService(myTimer), new FakeEventService(),\n                        new FakeCpuService(),\n                        FakeNetworkService.newBuilder().build());", "modifier": "@Rule public", "type": "FakeGrpcChannel", "declarator": "myGrpcChannel =\n    new FakeGrpcChannel(\"MemoryProfilerTest\", myMemoryService, myTransportService, new FakeProfilerService(myTimer), new FakeEventService(),\n                        new FakeCpuService(),\n                        FakeNetworkService.newBuilder().build())", "var_name": "myGrpcChannel"}, {"original_string": "private StudioProfilers myStudioProfiler;", "modifier": "private", "type": "StudioProfilers", "declarator": "myStudioProfiler", "var_name": "myStudioProfiler"}, {"original_string": "private FakeIdeProfilerServices myIdeProfilerServices;", "modifier": "private", "type": "FakeIdeProfilerServices", "declarator": "myIdeProfilerServices", "var_name": "myIdeProfilerServices"}, {"original_string": "private Common.Device myDevice;", "modifier": "private", "type": "Common.Device", "declarator": "myDevice", "var_name": "myDevice"}, {"original_string": "private Common.Process myProcess;", "modifier": "private", "type": "Common.Process", "declarator": "myProcess", "var_name": "myProcess"}, {"original_string": "private final boolean myUnifiedPipeline;", "modifier": "private final", "type": "boolean", "declarator": "myUnifiedPipeline", "var_name": "myUnifiedPipeline"}], "file": "profilers/testSrc/com/android/tools/profilers/memory/MemoryProfilerTest.java"}, "test_case": {"identifier": "testgetAllocationInfosForSession", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testgetAllocationInfosForSession() {\n    Assume.assumeTrue(myUnifiedPipeline);\n\n    Common.Session session = myStudioProfiler.getSession();\n\n    // Insert a completed info.\n    Memory.AllocationsInfo info1 = Memory.AllocationsInfo.newBuilder()\n      .setStartTime(1).setEndTime(2).setSuccess(true).setLegacy(true).build();\n    myTransportService.addEventToStream(\n      session.getStreamId(),\n      ProfilersTestData.generateMemoryAllocationInfoData(1, session.getPid(), info1).build());\n\n    List<Memory.AllocationsInfo> infos = MemoryProfiler.getAllocationInfosForSession(myStudioProfiler.getClient(),\n                                                                                     session,\n                                                                                     new Range(0, 10),\n                                                                                     myStudioProfiler.getIdeServices());\n    Truth.assertThat(infos).containsExactly(info1);\n\n    // Insert a not yet completed info followed up by a generic end event.\n    Memory.AllocationsInfo info2 = Memory.AllocationsInfo.newBuilder().setStartTime(5).setEndTime(Long.MAX_VALUE).setLegacy(true).build();\n    myTransportService.addEventToStream(\n      session.getStreamId(),\n      Common.Event.newBuilder().setTimestamp(5).setGroupId(5).setKind(Common.Event.Kind.MEMORY_ALLOC_TRACKING)\n        .setPid(session.getPid())\n        .setMemoryAllocTracking(Memory.MemoryAllocTrackingData.newBuilder().setInfo(info2))\n        .build());\n    myTransportService.addEventToStream(\n      session.getStreamId(),\n      Common.Event.newBuilder().setTimestamp(10).setGroupId(5).setKind(Common.Event.Kind.MEMORY_ALLOC_TRACKING)\n        .setPid(session.getPid()).setIsEnded(true).build());\n    infos = MemoryProfiler.getAllocationInfosForSession(myStudioProfiler.getClient(),\n                                                        session,\n                                                        new Range(0, 10),\n                                                        myStudioProfiler.getIdeServices());\n    Truth.assertThat(infos).containsExactly(info1, info2.toBuilder().setEndTime(session.getEndTimestamp()).setSuccess(false).build());\n  }", "signature": "void testgetAllocationInfosForSession()", "full_signature": "@Test public void testgetAllocationInfosForSession()", "class_method_signature": "MemoryProfilerTest.testgetAllocationInfosForSession()", "testcase": true, "constructor": false, "invocations": ["assumeTrue", "getSession", "build", "setLegacy", "setSuccess", "setEndTime", "setStartTime", "newBuilder", "addEventToStream", "getStreamId", "build", "generateMemoryAllocationInfoData", "getPid", "getAllocationInfosForSession", "getClient", "getIdeServices", "containsExactly", "assertThat", "build", "setLegacy", "setEndTime", "setStartTime", "newBuilder", "addEventToStream", "getStreamId", "build", "setMemoryAllocTracking", "setPid", "setKind", "setGroupId", "setTimestamp", "newBuilder", "getPid", "setInfo", "newBuilder", "addEventToStream", "getStreamId", "build", "setIsEnded", "setPid", "setKind", "setGroupId", "setTimestamp", "newBuilder", "getPid", "getAllocationInfosForSession", "getClient", "getIdeServices", "containsExactly", "assertThat", "build", "setSuccess", "setEndTime", "toBuilder", "getEndTimestamp"]}, "focal_class": {"identifier": "MemoryProfiler", "superclass": "extends StudioProfiler", "interfaces": "", "fields": [{"original_string": "@NotNull private final AspectObserver myAspectObserver = new AspectObserver();", "modifier": "@NotNull private final", "type": "AspectObserver", "declarator": "myAspectObserver = new AspectObserver()", "var_name": "myAspectObserver"}], "methods": [{"identifier": "getLogger", "parameters": "()", "modifiers": "private static", "return": "Logger", "signature": "Logger getLogger()", "full_signature": "private static Logger getLogger()", "class_method_signature": "MemoryProfiler.getLogger()", "testcase": false, "constructor": false}, {"identifier": "MemoryProfiler", "parameters": "(@NotNull StudioProfilers profilers)", "modifiers": "public", "return": "", "signature": " MemoryProfiler(@NotNull StudioProfilers profilers)", "full_signature": "public  MemoryProfiler(@NotNull StudioProfilers profilers)", "class_method_signature": "MemoryProfiler.MemoryProfiler(@NotNull StudioProfilers profilers)", "testcase": false, "constructor": true}, {"identifier": "newMonitor", "parameters": "()", "modifiers": "@Override public", "return": "ProfilerMonitor", "signature": "ProfilerMonitor newMonitor()", "full_signature": "@Override public ProfilerMonitor newMonitor()", "class_method_signature": "MemoryProfiler.newMonitor()", "testcase": false, "constructor": false}, {"identifier": "startProfiling", "parameters": "(Common.Session session)", "modifiers": "@Override public", "return": "void", "signature": "void startProfiling(Common.Session session)", "full_signature": "@Override public void startProfiling(Common.Session session)", "class_method_signature": "MemoryProfiler.startProfiling(Common.Session session)", "testcase": false, "constructor": false}, {"identifier": "stopProfiling", "parameters": "(Common.Session session)", "modifiers": "@Override public", "return": "void", "signature": "void stopProfiling(Common.Session session)", "full_signature": "@Override public void stopProfiling(Common.Session session)", "class_method_signature": "MemoryProfiler.stopProfiling(Common.Session session)", "testcase": false, "constructor": false}, {"identifier": "agentStatusChanged", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void agentStatusChanged()", "full_signature": "private void agentStatusChanged()", "class_method_signature": "MemoryProfiler.agentStatusChanged()", "testcase": false, "constructor": false}, {"identifier": "importHprof", "parameters": "(@NotNull File file)", "modifiers": "private", "return": "void", "signature": "void importHprof(@NotNull File file)", "full_signature": "private void importHprof(@NotNull File file)", "class_method_signature": "MemoryProfiler.importHprof(@NotNull File file)", "testcase": false, "constructor": false}, {"identifier": "importLegacyAllocations", "parameters": "(@NotNull File file)", "modifiers": "private", "return": "void", "signature": "void importLegacyAllocations(@NotNull File file)", "full_signature": "private void importLegacyAllocations(@NotNull File file)", "class_method_signature": "MemoryProfiler.importLegacyAllocations(@NotNull File file)", "testcase": false, "constructor": false}, {"identifier": "isUsingLiveAllocation", "parameters": "(@NotNull StudioProfilers profilers, @NotNull Common.Session session)", "modifiers": "static", "return": "boolean", "signature": "boolean isUsingLiveAllocation(@NotNull StudioProfilers profilers, @NotNull Common.Session session)", "full_signature": "static boolean isUsingLiveAllocation(@NotNull StudioProfilers profilers, @NotNull Common.Session session)", "class_method_signature": "MemoryProfiler.isUsingLiveAllocation(@NotNull StudioProfilers profilers, @NotNull Common.Session session)", "testcase": false, "constructor": false}, {"identifier": "hasOnlyFullAllocationTrackingWithinRegion", "parameters": "(@NotNull StudioProfilers profilers,\n                                                                  @NotNull Common.Session session, long startTimeUs, long endTimeUs)", "modifiers": "public static", "return": "boolean", "signature": "boolean hasOnlyFullAllocationTrackingWithinRegion(@NotNull StudioProfilers profilers,\n                                                                  @NotNull Common.Session session, long startTimeUs, long endTimeUs)", "full_signature": "public static boolean hasOnlyFullAllocationTrackingWithinRegion(@NotNull StudioProfilers profilers,\n                                                                  @NotNull Common.Session session, long startTimeUs, long endTimeUs)", "class_method_signature": "MemoryProfiler.hasOnlyFullAllocationTrackingWithinRegion(@NotNull StudioProfilers profilers,\n                                                                  @NotNull Common.Session session, long startTimeUs, long endTimeUs)", "testcase": false, "constructor": false}, {"identifier": "saveHeapDumpToFile", "parameters": "(@NotNull ProfilerClient client,\n                                        @NotNull Common.Session session,\n                                        @NotNull HeapDumpInfo info,\n                                        @NotNull OutputStream outputStream,\n                                        @NotNull FeatureTracker featureTracker)", "modifiers": "public static", "return": "void", "signature": "void saveHeapDumpToFile(@NotNull ProfilerClient client,\n                                        @NotNull Common.Session session,\n                                        @NotNull HeapDumpInfo info,\n                                        @NotNull OutputStream outputStream,\n                                        @NotNull FeatureTracker featureTracker)", "full_signature": "public static void saveHeapDumpToFile(@NotNull ProfilerClient client,\n                                        @NotNull Common.Session session,\n                                        @NotNull HeapDumpInfo info,\n                                        @NotNull OutputStream outputStream,\n                                        @NotNull FeatureTracker featureTracker)", "class_method_signature": "MemoryProfiler.saveHeapDumpToFile(@NotNull ProfilerClient client,\n                                        @NotNull Common.Session session,\n                                        @NotNull HeapDumpInfo info,\n                                        @NotNull OutputStream outputStream,\n                                        @NotNull FeatureTracker featureTracker)", "testcase": false, "constructor": false}, {"identifier": "saveLegacyAllocationToFile", "parameters": "(@NotNull ProfilerClient client,\n                                                @NotNull Common.Session session,\n                                                @NotNull AllocationsInfo info,\n                                                @NotNull OutputStream outputStream,\n                                                @NotNull FeatureTracker featureTracker)", "modifiers": "public static", "return": "void", "signature": "void saveLegacyAllocationToFile(@NotNull ProfilerClient client,\n                                                @NotNull Common.Session session,\n                                                @NotNull AllocationsInfo info,\n                                                @NotNull OutputStream outputStream,\n                                                @NotNull FeatureTracker featureTracker)", "full_signature": "public static void saveLegacyAllocationToFile(@NotNull ProfilerClient client,\n                                                @NotNull Common.Session session,\n                                                @NotNull AllocationsInfo info,\n                                                @NotNull OutputStream outputStream,\n                                                @NotNull FeatureTracker featureTracker)", "class_method_signature": "MemoryProfiler.saveLegacyAllocationToFile(@NotNull ProfilerClient client,\n                                                @NotNull Common.Session session,\n                                                @NotNull AllocationsInfo info,\n                                                @NotNull OutputStream outputStream,\n                                                @NotNull FeatureTracker featureTracker)", "testcase": false, "constructor": false}, {"identifier": "generateCaptureFileName", "parameters": "()", "modifiers": "@NotNull static", "return": "String", "signature": "String generateCaptureFileName()", "full_signature": "@NotNull static String generateCaptureFileName()", "class_method_signature": "MemoryProfiler.generateCaptureFileName()", "testcase": false, "constructor": false}, {"identifier": "getHeapDumpsForSession", "parameters": "(@NotNull ProfilerClient client,\n                                                          @NotNull Common.Session session,\n                                                          @NotNull Range rangeUs,\n                                                          @NotNull IdeProfilerServices profilerService)", "modifiers": "public static", "return": "List<HeapDumpInfo>", "signature": "List<HeapDumpInfo> getHeapDumpsForSession(@NotNull ProfilerClient client,\n                                                          @NotNull Common.Session session,\n                                                          @NotNull Range rangeUs,\n                                                          @NotNull IdeProfilerServices profilerService)", "full_signature": "public static List<HeapDumpInfo> getHeapDumpsForSession(@NotNull ProfilerClient client,\n                                                          @NotNull Common.Session session,\n                                                          @NotNull Range rangeUs,\n                                                          @NotNull IdeProfilerServices profilerService)", "class_method_signature": "MemoryProfiler.getHeapDumpsForSession(@NotNull ProfilerClient client,\n                                                          @NotNull Common.Session session,\n                                                          @NotNull Range rangeUs,\n                                                          @NotNull IdeProfilerServices profilerService)", "testcase": false, "constructor": false}, {"identifier": "getAllocationInfosForSession", "parameters": "(@NotNull ProfilerClient client,\n                                                                   @NotNull Common.Session session,\n                                                                   @NotNull Range rangeUs,\n                                                                   @NotNull IdeProfilerServices profilerService)", "modifiers": "public static", "return": "List<AllocationsInfo>", "signature": "List<AllocationsInfo> getAllocationInfosForSession(@NotNull ProfilerClient client,\n                                                                   @NotNull Common.Session session,\n                                                                   @NotNull Range rangeUs,\n                                                                   @NotNull IdeProfilerServices profilerService)", "full_signature": "public static List<AllocationsInfo> getAllocationInfosForSession(@NotNull ProfilerClient client,\n                                                                   @NotNull Common.Session session,\n                                                                   @NotNull Range rangeUs,\n                                                                   @NotNull IdeProfilerServices profilerService)", "class_method_signature": "MemoryProfiler.getAllocationInfosForSession(@NotNull ProfilerClient client,\n                                                                   @NotNull Common.Session session,\n                                                                   @NotNull Range rangeUs,\n                                                                   @NotNull IdeProfilerServices profilerService)", "testcase": false, "constructor": false}, {"identifier": "trackAllocations", "parameters": "(@NotNull StudioProfilers profilers,\n                                      @NotNull Common.Session session,\n                                      boolean enable,\n                                      @Nullable Consumer<Memory.TrackStatus> responseHandler)", "modifiers": "public static", "return": "void", "signature": "void trackAllocations(@NotNull StudioProfilers profilers,\n                                      @NotNull Common.Session session,\n                                      boolean enable,\n                                      @Nullable Consumer<Memory.TrackStatus> responseHandler)", "full_signature": "public static void trackAllocations(@NotNull StudioProfilers profilers,\n                                      @NotNull Common.Session session,\n                                      boolean enable,\n                                      @Nullable Consumer<Memory.TrackStatus> responseHandler)", "class_method_signature": "MemoryProfiler.trackAllocations(@NotNull StudioProfilers profilers,\n                                      @NotNull Common.Session session,\n                                      boolean enable,\n                                      @Nullable Consumer<Memory.TrackStatus> responseHandler)", "testcase": false, "constructor": false}], "file": "profilers/src/com/android/tools/profilers/memory/MemoryProfiler.java"}, "focal_method": {"identifier": "getAllocationInfosForSession", "parameters": "(@NotNull ProfilerClient client,\n                                                                   @NotNull Common.Session session,\n                                                                   @NotNull Range rangeUs,\n                                                                   @NotNull IdeProfilerServices profilerService)", "modifiers": "public static", "return": "List<AllocationsInfo>", "body": "public static List<AllocationsInfo> getAllocationInfosForSession(@NotNull ProfilerClient client,\n                                                                   @NotNull Common.Session session,\n                                                                   @NotNull Range rangeUs,\n                                                                   @NotNull IdeProfilerServices profilerService) {\n    long fromTimestamp = rangeUs.getMin() == Long.MIN_VALUE ? Long.MIN_VALUE : TimeUnit.MICROSECONDS.toNanos((long)rangeUs.getMin());\n    long toTimestamp = rangeUs.getMax() == Long.MAX_VALUE ? Long.MAX_VALUE : TimeUnit.MICROSECONDS.toNanos((long)rangeUs.getMax());\n    if (profilerService.getFeatureConfig().isUnifiedPipelineEnabled()) {\n      Transport.GetEventGroupsRequest request = Transport.GetEventGroupsRequest.newBuilder()\n        .setStreamId(session.getStreamId())\n        .setPid(session.getPid())\n        .setKind(Common.Event.Kind.MEMORY_ALLOC_TRACKING)\n        .setFromTimestamp(fromTimestamp)\n        .setToTimestamp(toTimestamp)\n        .build();\n      Transport.GetEventGroupsResponse response = client.getTransportClient().getEventGroups(request);\n\n      List<AllocationsInfo> infos = new ArrayList<>();\n      for (Transport.EventGroup group : response.getGroupsList()) {\n        // We only need the last event to get the most recent HeapDumpInfo\n        Common.Event lastEvent = group.getEvents(group.getEventsCount() - 1);\n        AllocationsInfo info = lastEvent.getMemoryAllocTracking().getInfo();\n        if (info.equals(AllocationsInfo.getDefaultInstance())) {\n          // A default instance means that we have a generically ended group due to device disconnect.\n          // In those case, we look for the start event and use its AllocationsInfo instead.\n          assert group.getEventsCount() > 1;\n          info = group.getEvents(0).getMemoryAllocTracking().getInfo();\n          if (info.getLegacy() && info.getEndTime() == Long.MAX_VALUE) {\n            info = info.toBuilder().setEndTime(session.getEndTimestamp()).setSuccess(false).build();\n          }\n        }\n\n        infos.add(info);\n      }\n      return infos;\n    }\n    else {\n      MemoryRequest dataRequest = MemoryRequest.newBuilder()\n        .setSession(session)\n        .setStartTime(fromTimestamp)\n        .setEndTime(toTimestamp)\n        .build();\n      return client.getMemoryClient().getData(dataRequest).getAllocationsInfoList();\n    }\n  }", "signature": "List<AllocationsInfo> getAllocationInfosForSession(@NotNull ProfilerClient client,\n                                                                   @NotNull Common.Session session,\n                                                                   @NotNull Range rangeUs,\n                                                                   @NotNull IdeProfilerServices profilerService)", "full_signature": "public static List<AllocationsInfo> getAllocationInfosForSession(@NotNull ProfilerClient client,\n                                                                   @NotNull Common.Session session,\n                                                                   @NotNull Range rangeUs,\n                                                                   @NotNull IdeProfilerServices profilerService)", "class_method_signature": "MemoryProfiler.getAllocationInfosForSession(@NotNull ProfilerClient client,\n                                                                   @NotNull Common.Session session,\n                                                                   @NotNull Range rangeUs,\n                                                                   @NotNull IdeProfilerServices profilerService)", "testcase": false, "constructor": false, "invocations": ["getMin", "toNanos", "getMin", "getMax", "toNanos", "getMax", "isUnifiedPipelineEnabled", "getFeatureConfig", "build", "setToTimestamp", "setFromTimestamp", "setKind", "setPid", "setStreamId", "newBuilder", "getStreamId", "getPid", "getEventGroups", "getTransportClient", "getGroupsList", "getEvents", "getEventsCount", "getInfo", "getMemoryAllocTracking", "equals", "getDefaultInstance", "getEventsCount", "getInfo", "getMemoryAllocTracking", "getEvents", "getLegacy", "getEndTime", "build", "setSuccess", "setEndTime", "toBuilder", "getEndTimestamp", "add", "build", "setEndTime", "setStartTime", "setSession", "newBuilder", "getAllocationsInfoList", "getData", "getMemoryClient"]}, "repository": {"repo_id": 60701247, "url": "https://github.com/JetBrains/android", "stars": 486, "created": "6/8/2016 1:46:48 PM +00:00", "updates": "2020-01-27T16:45:40+00:00", "fork": "False", "license": "licensed"}}