{"test_class": {"identifier": "KafkaUtilsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private KafkaTestBroker broker;", "modifier": "private", "type": "KafkaTestBroker", "declarator": "broker", "var_name": "broker"}, {"original_string": "private SimpleConsumer simpleConsumer;", "modifier": "private", "type": "SimpleConsumer", "declarator": "simpleConsumer", "var_name": "simpleConsumer"}, {"original_string": "private KafkaConfig config;", "modifier": "private", "type": "KafkaConfig", "declarator": "config", "var_name": "config"}, {"original_string": "private BrokerHosts brokerHosts;", "modifier": "private", "type": "BrokerHosts", "declarator": "brokerHosts", "var_name": "brokerHosts"}], "file": "storm/storm-app/src/test/java/storm/kafka/KafkaUtilsTest.java"}, "test_case": {"identifier": "brokerIsDown", "parameters": "()", "modifiers": "@Test(expected = FailedFetchException.class) public", "return": "void", "body": "@Test(expected = FailedFetchException.class)\n    public void brokerIsDown() throws Exception {\n        int port = broker.getPort();\n        broker.shutdown();\n        SimpleConsumer simpleConsumer = new SimpleConsumer(\"localhost\", port, 100, 1024, \"testClient\");\n        try {\n            KafkaUtils.fetchMessages(config, simpleConsumer, new Partition(Broker.fromString(broker.getBrokerConnectionString()), 0), OffsetRequest.LatestTime());\n        } finally {\n            simpleConsumer.close();\n        }\n    }", "signature": "void brokerIsDown()", "full_signature": "@Test(expected = FailedFetchException.class) public void brokerIsDown()", "class_method_signature": "KafkaUtilsTest.brokerIsDown()", "testcase": true, "constructor": false, "invocations": ["getPort", "shutdown", "fetchMessages", "fromString", "getBrokerConnectionString", "LatestTime", "close"]}, "focal_class": {"identifier": "KafkaUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final Logger LOG = LoggerFactory.getLogger(KafkaUtils.class);", "modifier": "public static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(KafkaUtils.class)", "var_name": "LOG"}, {"original_string": "private static final int NO_OFFSET = -5;", "modifier": "private static final", "type": "int", "declarator": "NO_OFFSET = -5", "var_name": "NO_OFFSET"}], "methods": [{"identifier": "makeBrokerReader", "parameters": "(Map stormConf, KafkaConfig conf)", "modifiers": "public static", "return": "IBrokerReader", "signature": "IBrokerReader makeBrokerReader(Map stormConf, KafkaConfig conf)", "full_signature": "public static IBrokerReader makeBrokerReader(Map stormConf, KafkaConfig conf)", "class_method_signature": "KafkaUtils.makeBrokerReader(Map stormConf, KafkaConfig conf)", "testcase": false, "constructor": false}, {"identifier": "getOffset", "parameters": "(SimpleConsumer consumer, String topic, int partition, KafkaConfig config)", "modifiers": "public static", "return": "long", "signature": "long getOffset(SimpleConsumer consumer, String topic, int partition, KafkaConfig config)", "full_signature": "public static long getOffset(SimpleConsumer consumer, String topic, int partition, KafkaConfig config)", "class_method_signature": "KafkaUtils.getOffset(SimpleConsumer consumer, String topic, int partition, KafkaConfig config)", "testcase": false, "constructor": false}, {"identifier": "getOffset", "parameters": "(SimpleConsumer consumer, String topic, int partition, long startOffsetTime)", "modifiers": "public static", "return": "long", "signature": "long getOffset(SimpleConsumer consumer, String topic, int partition, long startOffsetTime)", "full_signature": "public static long getOffset(SimpleConsumer consumer, String topic, int partition, long startOffsetTime)", "class_method_signature": "KafkaUtils.getOffset(SimpleConsumer consumer, String topic, int partition, long startOffsetTime)", "testcase": false, "constructor": false}, {"identifier": "fetchMessages", "parameters": "(KafkaConfig config, SimpleConsumer consumer, Partition partition, long offset)", "modifiers": "public static", "return": "ByteBufferMessageSet", "signature": "ByteBufferMessageSet fetchMessages(KafkaConfig config, SimpleConsumer consumer, Partition partition, long offset)", "full_signature": "public static ByteBufferMessageSet fetchMessages(KafkaConfig config, SimpleConsumer consumer, Partition partition, long offset)", "class_method_signature": "KafkaUtils.fetchMessages(KafkaConfig config, SimpleConsumer consumer, Partition partition, long offset)", "testcase": false, "constructor": false}, {"identifier": "generateTuples", "parameters": "(KafkaConfig kafkaConfig, Message msg)", "modifiers": "public static", "return": "Iterable<List<Object>>", "signature": "Iterable<List<Object>> generateTuples(KafkaConfig kafkaConfig, Message msg)", "full_signature": "public static Iterable<List<Object>> generateTuples(KafkaConfig kafkaConfig, Message msg)", "class_method_signature": "KafkaUtils.generateTuples(KafkaConfig kafkaConfig, Message msg)", "testcase": false, "constructor": false}, {"identifier": "calculatePartitionsForTask", "parameters": "(GlobalPartitionInformation partitionInformation, int totalTasks, int taskIndex)", "modifiers": "public static", "return": "List<Partition>", "signature": "List<Partition> calculatePartitionsForTask(GlobalPartitionInformation partitionInformation, int totalTasks, int taskIndex)", "full_signature": "public static List<Partition> calculatePartitionsForTask(GlobalPartitionInformation partitionInformation, int totalTasks, int taskIndex)", "class_method_signature": "KafkaUtils.calculatePartitionsForTask(GlobalPartitionInformation partitionInformation, int totalTasks, int taskIndex)", "testcase": false, "constructor": false}, {"identifier": "logPartitionMapping", "parameters": "(int totalTasks, int taskIndex, List<Partition> taskPartitions)", "modifiers": "private static", "return": "void", "signature": "void logPartitionMapping(int totalTasks, int taskIndex, List<Partition> taskPartitions)", "full_signature": "private static void logPartitionMapping(int totalTasks, int taskIndex, List<Partition> taskPartitions)", "class_method_signature": "KafkaUtils.logPartitionMapping(int totalTasks, int taskIndex, List<Partition> taskPartitions)", "testcase": false, "constructor": false}, {"identifier": "taskId", "parameters": "(int taskIndex, int totalTasks)", "modifiers": "public static", "return": "String", "signature": "String taskId(int taskIndex, int totalTasks)", "full_signature": "public static String taskId(int taskIndex, int totalTasks)", "class_method_signature": "KafkaUtils.taskId(int taskIndex, int totalTasks)", "testcase": false, "constructor": false}], "file": "storm/storm-app/src/main/java/storm/kafka/KafkaUtils.java"}, "focal_method": {"identifier": "fetchMessages", "parameters": "(KafkaConfig config, SimpleConsumer consumer, Partition partition, long offset)", "modifiers": "public static", "return": "ByteBufferMessageSet", "body": "public static ByteBufferMessageSet fetchMessages(KafkaConfig config, SimpleConsumer consumer, Partition partition, long offset)\n            throws TopicOffsetOutOfRangeException, FailedFetchException,RuntimeException {\n        ByteBufferMessageSet msgs = null;\n        String topic = config.topic;\n        int partitionId = partition.partition;\n\n        FetchRequestBuilder builder = new FetchRequestBuilder();\n        //Builder\u94fe\u5f0f\u8c03\u7528. fetchSizeBytes\u8868\u793a\u4e00\u6b21\u8981\u83b7\u53d6\u591a\u5c11\u6570\u636e\u91cf. \u6240\u4ee5\u4eceoffset\u5f00\u59cb,\u4e00\u6b21\u83b7\u53d6\u4e0d\u6b62\u4e00\u6761\u6d88\u606f\n        FetchRequest fetchRequest = builder.addFetch(topic, partitionId, offset, config.fetchSizeBytes).\n                clientId(config.clientId).maxWait(config.fetchMaxWait).build();\n        FetchResponse fetchResponse;\n        try {\n            //\u6d88\u8d39\u8005\u4f20\u5165\u83b7\u53d6\u8bf7\u6c42,\u5f97\u5230\u83b7\u53d6\u54cd\u5e94\n            fetchResponse = consumer.fetch(fetchRequest);\n        } catch (Exception e) {\n            if (e instanceof ConnectException ||\n                    e instanceof SocketTimeoutException ||\n                    e instanceof IOException ||\n                    e instanceof UnresolvedAddressException\n                    ) {\n                LOG.warn(\"Network error when fetching messages:\", e);\n                throw new FailedFetchException(e);\n            } else {\n                throw new RuntimeException(e);\n            }\n        }\n        // \u4e3b\u8981\u5904\u7406offset outofrange\u7684case\uff0c\u901a\u8fc7getOffset\u4eceearliest\u6216latest\u8bfb\n        if (fetchResponse.hasError()) {\n            KafkaError error = KafkaError.getError(fetchResponse.errorCode(topic, partitionId));\n            if (error.equals(KafkaError.OFFSET_OUT_OF_RANGE) && config.useStartOffsetTimeIfOffsetOutOfRange) {\n                String msg = \"Got fetch request with offset out of range: [\" + offset + \"]\";\n                LOG.warn(msg);\n                throw new TopicOffsetOutOfRangeException(msg);\n            } else {\n                String message = \"Error fetching data from [\" + partition + \"] for topic [\" + topic + \"]: [\" + error + \"]\";\n                LOG.error(message);\n                throw new FailedFetchException(message);\n            }\n        } else {\n            msgs = fetchResponse.messageSet(topic, partitionId);\n        }\n        return msgs;\n    }", "signature": "ByteBufferMessageSet fetchMessages(KafkaConfig config, SimpleConsumer consumer, Partition partition, long offset)", "full_signature": "public static ByteBufferMessageSet fetchMessages(KafkaConfig config, SimpleConsumer consumer, Partition partition, long offset)", "class_method_signature": "KafkaUtils.fetchMessages(KafkaConfig config, SimpleConsumer consumer, Partition partition, long offset)", "testcase": false, "constructor": false, "invocations": ["build", "maxWait", "clientId", "addFetch", "fetch", "warn", "hasError", "getError", "errorCode", "equals", "warn", "error", "messageSet"]}, "repository": {"repo_id": 44512524, "url": "https://github.com/zqhxuyuan/bigdata", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 8, "size": 91550, "license": "licensed"}}