{"test_class": {"identifier": "ElasticsearchReporterTest", "superclass": "extends ESIntegTestCase", "interfaces": "", "fields": [{"original_string": "private ElasticsearchReporter elasticsearchReporter;", "modifier": "private", "type": "ElasticsearchReporter", "declarator": "elasticsearchReporter", "var_name": "elasticsearchReporter"}, {"original_string": "private MetricRegistry registry = new MetricRegistry();", "modifier": "private", "type": "MetricRegistry", "declarator": "registry = new MetricRegistry()", "var_name": "registry"}, {"original_string": "private String index = randomAsciiOfLength(12).toLowerCase();", "modifier": "private", "type": "String", "declarator": "index = randomAsciiOfLength(12).toLowerCase()", "var_name": "index"}, {"original_string": "private String indexWithDate = String.format(\"%s-%s-%02d\", index, Calendar.getInstance().get(Calendar.YEAR), Calendar.getInstance().get(Calendar.MONTH) + 1);", "modifier": "private", "type": "String", "declarator": "indexWithDate = String.format(\"%s-%s-%02d\", index, Calendar.getInstance().get(Calendar.YEAR), Calendar.getInstance().get(Calendar.MONTH) + 1)", "var_name": "indexWithDate"}, {"original_string": "private String prefix = randomAsciiOfLength(12).toLowerCase();", "modifier": "private", "type": "String", "declarator": "prefix = randomAsciiOfLength(12).toLowerCase()", "var_name": "prefix"}], "file": "neo-starter-metrics/src/test/java/eu/neoteric/starter/metrics/report/elastic/ElasticsearchReporterTest.java"}, "test_case": {"identifier": "testThatEmptyMetricsDoNotResultInBrokenBulkRequest", "parameters": "()", "modifiers": "@Test // issue #6 public", "return": "void", "body": "@Test // issue #6\n    public void testThatEmptyMetricsDoNotResultInBrokenBulkRequest() throws Exception {\n        long connectionsBeforeReporting = getTotalHttpConnections();\n        elasticsearchReporter.report();\n        long connectionsAfterReporting = getTotalHttpConnections();\n\n        org.assertj.core.api.Assertions.assertThat(connectionsAfterReporting).isEqualTo(connectionsBeforeReporting);\n    }", "signature": "void testThatEmptyMetricsDoNotResultInBrokenBulkRequest()", "full_signature": "@Test // issue #6 public void testThatEmptyMetricsDoNotResultInBrokenBulkRequest()", "class_method_signature": "ElasticsearchReporterTest.testThatEmptyMetricsDoNotResultInBrokenBulkRequest()", "testcase": true, "constructor": false, "invocations": ["getTotalHttpConnections", "report", "getTotalHttpConnections", "isEqualTo", "assertThat"]}, "focal_class": {"identifier": "ElasticsearchReporter", "superclass": "extends ScheduledReporter", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ElasticsearchReporter.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ElasticsearchReporter.class)", "var_name": "LOGGER"}, {"original_string": "private static final int DEFAULT_BULK_SIZE = 2500;", "modifier": "private static final", "type": "int", "declarator": "DEFAULT_BULK_SIZE = 2500", "var_name": "DEFAULT_BULK_SIZE"}, {"original_string": "private static final int DEFAULT_TIMEOUT = 1000;", "modifier": "private static final", "type": "int", "declarator": "DEFAULT_TIMEOUT = 1000", "var_name": "DEFAULT_TIMEOUT"}, {"original_string": "private final String[] hosts;", "modifier": "private final", "type": "String[]", "declarator": "hosts", "var_name": "hosts"}, {"original_string": "private final Clock clock;", "modifier": "private final", "type": "Clock", "declarator": "clock", "var_name": "clock"}, {"original_string": "private final String prefix;", "modifier": "private final", "type": "String", "declarator": "prefix", "var_name": "prefix"}, {"original_string": "private final String index;", "modifier": "private final", "type": "String", "declarator": "index", "var_name": "index"}, {"original_string": "private final int bulkSize;", "modifier": "private final", "type": "int", "declarator": "bulkSize", "var_name": "bulkSize"}, {"original_string": "private final int timeout;", "modifier": "private final", "type": "int", "declarator": "timeout", "var_name": "timeout"}, {"original_string": "private final ObjectMapper objectMapper = new ObjectMapper();", "modifier": "private final", "type": "ObjectMapper", "declarator": "objectMapper = new ObjectMapper()", "var_name": "objectMapper"}, {"original_string": "private final ObjectWriter writer;", "modifier": "private final", "type": "ObjectWriter", "declarator": "writer", "var_name": "writer"}, {"original_string": "private MetricFilter percolationFilter;", "modifier": "private", "type": "MetricFilter", "declarator": "percolationFilter", "var_name": "percolationFilter"}, {"original_string": "private Notifier notifier;", "modifier": "private", "type": "Notifier", "declarator": "notifier", "var_name": "notifier"}, {"original_string": "private String currentIndexName;", "modifier": "private", "type": "String", "declarator": "currentIndexName", "var_name": "currentIndexName"}, {"original_string": "private SimpleDateFormat indexDateFormat;", "modifier": "private", "type": "SimpleDateFormat", "declarator": "indexDateFormat", "var_name": "indexDateFormat"}, {"original_string": "private boolean checkedForIndexTemplate;", "modifier": "private", "type": "boolean", "declarator": "checkedForIndexTemplate", "var_name": "checkedForIndexTemplate"}], "methods": [{"identifier": "ElasticsearchReporter", "parameters": "(MetricRegistry registry, String[] hosts, int timeout,\n                                 String index, String indexDateFormat, int bulkSize, Clock clock, String prefix, TimeUnit rateUnit, TimeUnit durationUnit,\n                                 MetricFilter filter, MetricFilter percolationFilter, Notifier percolationNotifier, String timestampFieldname, Map<String, Object> additionalFields)", "modifiers": "public", "return": "", "signature": " ElasticsearchReporter(MetricRegistry registry, String[] hosts, int timeout,\n                                 String index, String indexDateFormat, int bulkSize, Clock clock, String prefix, TimeUnit rateUnit, TimeUnit durationUnit,\n                                 MetricFilter filter, MetricFilter percolationFilter, Notifier percolationNotifier, String timestampFieldname, Map<String, Object> additionalFields)", "full_signature": "public  ElasticsearchReporter(MetricRegistry registry, String[] hosts, int timeout,\n                                 String index, String indexDateFormat, int bulkSize, Clock clock, String prefix, TimeUnit rateUnit, TimeUnit durationUnit,\n                                 MetricFilter filter, MetricFilter percolationFilter, Notifier percolationNotifier, String timestampFieldname, Map<String, Object> additionalFields)", "class_method_signature": "ElasticsearchReporter.ElasticsearchReporter(MetricRegistry registry, String[] hosts, int timeout,\n                                 String index, String indexDateFormat, int bulkSize, Clock clock, String prefix, TimeUnit rateUnit, TimeUnit durationUnit,\n                                 MetricFilter filter, MetricFilter percolationFilter, Notifier percolationNotifier, String timestampFieldname, Map<String, Object> additionalFields)", "testcase": false, "constructor": true}, {"identifier": "forRegistry", "parameters": "(MetricRegistry registry)", "modifiers": "public static", "return": "Builder", "signature": "Builder forRegistry(MetricRegistry registry)", "full_signature": "public static Builder forRegistry(MetricRegistry registry)", "class_method_signature": "ElasticsearchReporter.forRegistry(MetricRegistry registry)", "testcase": false, "constructor": false}, {"identifier": "report", "parameters": "(SortedMap<String, Gauge> gauges,\n                       SortedMap<String, Counter> counters,\n                       SortedMap<String, Histogram> histograms,\n                       SortedMap<String, Meter> meters,\n                       SortedMap<String, Timer> timers)", "modifiers": "@Override public", "return": "void", "signature": "void report(SortedMap<String, Gauge> gauges,\n                       SortedMap<String, Counter> counters,\n                       SortedMap<String, Histogram> histograms,\n                       SortedMap<String, Meter> meters,\n                       SortedMap<String, Timer> timers)", "full_signature": "@Override public void report(SortedMap<String, Gauge> gauges,\n                       SortedMap<String, Counter> counters,\n                       SortedMap<String, Histogram> histograms,\n                       SortedMap<String, Meter> meters,\n                       SortedMap<String, Timer> timers)", "class_method_signature": "ElasticsearchReporter.report(SortedMap<String, Gauge> gauges,\n                       SortedMap<String, Counter> counters,\n                       SortedMap<String, Histogram> histograms,\n                       SortedMap<String, Meter> meters,\n                       SortedMap<String, Timer> timers)", "testcase": false, "constructor": false}, {"identifier": "getPercolationMatches", "parameters": "(JsonMetric jsonMetric)", "modifiers": "private", "return": "List<String>", "signature": "List<String> getPercolationMatches(JsonMetric jsonMetric)", "full_signature": "private List<String> getPercolationMatches(JsonMetric jsonMetric)", "class_method_signature": "ElasticsearchReporter.getPercolationMatches(JsonMetric jsonMetric)", "testcase": false, "constructor": false}, {"identifier": "addJsonMetricToPercolationIfMatching", "parameters": "(JsonMetric<? extends Metric> jsonMetric, List<JsonMetric> percolationMetrics)", "modifiers": "private", "return": "void", "signature": "void addJsonMetricToPercolationIfMatching(JsonMetric<? extends Metric> jsonMetric, List<JsonMetric> percolationMetrics)", "full_signature": "private void addJsonMetricToPercolationIfMatching(JsonMetric<? extends Metric> jsonMetric, List<JsonMetric> percolationMetrics)", "class_method_signature": "ElasticsearchReporter.addJsonMetricToPercolationIfMatching(JsonMetric<? extends Metric> jsonMetric, List<JsonMetric> percolationMetrics)", "testcase": false, "constructor": false}, {"identifier": "writeJsonMetricAndRecreateConnectionIfNeeded", "parameters": "(JsonMetric jsonMetric, HttpURLConnection connection,\n                                                                           AtomicInteger entriesWritten)", "modifiers": "private", "return": "HttpURLConnection", "signature": "HttpURLConnection writeJsonMetricAndRecreateConnectionIfNeeded(JsonMetric jsonMetric, HttpURLConnection connection,\n                                                                           AtomicInteger entriesWritten)", "full_signature": "private HttpURLConnection writeJsonMetricAndRecreateConnectionIfNeeded(JsonMetric jsonMetric, HttpURLConnection connection,\n                                                                           AtomicInteger entriesWritten)", "class_method_signature": "ElasticsearchReporter.writeJsonMetricAndRecreateConnectionIfNeeded(JsonMetric jsonMetric, HttpURLConnection connection,\n                                                                           AtomicInteger entriesWritten)", "testcase": false, "constructor": false}, {"identifier": "closeConnection", "parameters": "(HttpURLConnection connection)", "modifiers": "private", "return": "void", "signature": "void closeConnection(HttpURLConnection connection)", "full_signature": "private void closeConnection(HttpURLConnection connection)", "class_method_signature": "ElasticsearchReporter.closeConnection(HttpURLConnection connection)", "testcase": false, "constructor": false}, {"identifier": "createNewConnectionIfBulkSizeReached", "parameters": "(HttpURLConnection connection, int entriesWritten)", "modifiers": "private", "return": "HttpURLConnection", "signature": "HttpURLConnection createNewConnectionIfBulkSizeReached(HttpURLConnection connection, int entriesWritten)", "full_signature": "private HttpURLConnection createNewConnectionIfBulkSizeReached(HttpURLConnection connection, int entriesWritten)", "class_method_signature": "ElasticsearchReporter.createNewConnectionIfBulkSizeReached(HttpURLConnection connection, int entriesWritten)", "testcase": false, "constructor": false}, {"identifier": "writeJsonMetric", "parameters": "(JsonMetric jsonMetric, ObjectWriter writer, OutputStream out)", "modifiers": "private", "return": "void", "signature": "void writeJsonMetric(JsonMetric jsonMetric, ObjectWriter writer, OutputStream out)", "full_signature": "private void writeJsonMetric(JsonMetric jsonMetric, ObjectWriter writer, OutputStream out)", "class_method_signature": "ElasticsearchReporter.writeJsonMetric(JsonMetric jsonMetric, ObjectWriter writer, OutputStream out)", "testcase": false, "constructor": false}, {"identifier": "openConnection", "parameters": "(String uri, String method)", "modifiers": "private", "return": "HttpURLConnection", "signature": "HttpURLConnection openConnection(String uri, String method)", "full_signature": "private HttpURLConnection openConnection(String uri, String method)", "class_method_signature": "ElasticsearchReporter.openConnection(String uri, String method)", "testcase": false, "constructor": false}, {"identifier": "checkForIndexTemplate", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void checkForIndexTemplate()", "full_signature": "private void checkForIndexTemplate()", "class_method_signature": "ElasticsearchReporter.checkForIndexTemplate()", "testcase": false, "constructor": false}], "file": "neo-starter-metrics/src/main/java/eu/neoteric/starter/metrics/report/elastic/ElasticsearchReporter.java"}, "focal_method": {"identifier": "report", "parameters": "(SortedMap<String, Gauge> gauges,\n                       SortedMap<String, Counter> counters,\n                       SortedMap<String, Histogram> histograms,\n                       SortedMap<String, Meter> meters,\n                       SortedMap<String, Timer> timers)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void report(SortedMap<String, Gauge> gauges,\n                       SortedMap<String, Counter> counters,\n                       SortedMap<String, Histogram> histograms,\n                       SortedMap<String, Meter> meters,\n                       SortedMap<String, Timer> timers) {\n\n        // nothing to do if we dont have any metrics to report\n        if (gauges.isEmpty() && counters.isEmpty() && histograms.isEmpty() && meters.isEmpty() && timers.isEmpty()) {\n            LOGGER.info(\"All metrics empty, nothing to report\");\n            return;\n        }\n\n        if (!checkedForIndexTemplate) {\n            checkForIndexTemplate();\n        }\n        final long timestamp = clock.getTime() / 1000;\n\n        currentIndexName = index;\n        if (indexDateFormat != null) {\n            currentIndexName += \"-\" + indexDateFormat.format(new Date(timestamp * 1000));\n        }\n\n        try {\n            HttpURLConnection connection;\n            try {\n                connection = openConnection(\"/_bulk\", \"POST\");\n            } catch (ElasticsearchConnectionException e) {\n                LOGGER.error(\"Could not connect to any configured elasticsearch instances: {}\", Arrays.asList(hosts), e);\n                return;\n            }\n\n            List<JsonMetrics.JsonMetric> percolationMetrics = new ArrayList<>();\n            AtomicInteger entriesWritten = new AtomicInteger(0);\n\n            for (Map.Entry<String, Gauge> entry : gauges.entrySet()) {\n                if (entry.getValue().getValue() != null) {\n                    JsonMetrics.JsonMetric jsonMetric = new JsonMetrics.JsonGauge(name(prefix, entry.getKey()), timestamp, entry.getValue());\n                    connection = writeJsonMetricAndRecreateConnectionIfNeeded(jsonMetric, connection, entriesWritten);\n                    addJsonMetricToPercolationIfMatching(jsonMetric, percolationMetrics);\n                }\n            }\n\n            for (Map.Entry<String, Counter> entry : counters.entrySet()) {\n                JsonCounter jsonMetric = new JsonCounter(name(prefix, entry.getKey()), timestamp, entry.getValue());\n                connection = writeJsonMetricAndRecreateConnectionIfNeeded(jsonMetric, connection, entriesWritten);\n                addJsonMetricToPercolationIfMatching(jsonMetric, percolationMetrics);\n            }\n\n            for (Map.Entry<String, Histogram> entry : histograms.entrySet()) {\n                JsonHistogram jsonMetric = new JsonHistogram(name(prefix, entry.getKey()), timestamp, entry.getValue());\n                connection = writeJsonMetricAndRecreateConnectionIfNeeded(jsonMetric, connection, entriesWritten);\n                addJsonMetricToPercolationIfMatching(jsonMetric, percolationMetrics);\n            }\n\n            for (Map.Entry<String, Meter> entry : meters.entrySet()) {\n                JsonMeter jsonMetric = new JsonMeter(name(prefix, entry.getKey()), timestamp, entry.getValue());\n                connection = writeJsonMetricAndRecreateConnectionIfNeeded(jsonMetric, connection, entriesWritten);\n                addJsonMetricToPercolationIfMatching(jsonMetric, percolationMetrics);\n            }\n\n            for (Map.Entry<String, Timer> entry : timers.entrySet()) {\n                JsonTimer jsonMetric = new JsonTimer(name(prefix, entry.getKey()), timestamp, entry.getValue());\n                connection = writeJsonMetricAndRecreateConnectionIfNeeded(jsonMetric, connection, entriesWritten);\n                addJsonMetricToPercolationIfMatching(jsonMetric, percolationMetrics);\n            }\n\n            closeConnection(connection);\n\n            // execute the notifier impl, in case percolation found matches\n            if (percolationMetrics.size() > 0 && notifier != null) {\n                for (JsonMetric jsonMetric : percolationMetrics) {\n                    List<String> matches = getPercolationMatches(jsonMetric);\n                    for (String match : matches) {\n                        notifier.notify(jsonMetric, match);\n                    }\n                }\n            }\n            // catch the exception to make sure we do not interrupt the live application\n        } catch (ElasticsearchConnectionException e) {\n            LOGGER.error(\"Couldnt report to elasticsearch server\", e);\n        } catch (IOException e) {\n            LOGGER.error(\"Couldnt report to elasticsearch server\", e);\n        }\n    }", "signature": "void report(SortedMap<String, Gauge> gauges,\n                       SortedMap<String, Counter> counters,\n                       SortedMap<String, Histogram> histograms,\n                       SortedMap<String, Meter> meters,\n                       SortedMap<String, Timer> timers)", "full_signature": "@Override public void report(SortedMap<String, Gauge> gauges,\n                       SortedMap<String, Counter> counters,\n                       SortedMap<String, Histogram> histograms,\n                       SortedMap<String, Meter> meters,\n                       SortedMap<String, Timer> timers)", "class_method_signature": "ElasticsearchReporter.report(SortedMap<String, Gauge> gauges,\n                       SortedMap<String, Counter> counters,\n                       SortedMap<String, Histogram> histograms,\n                       SortedMap<String, Meter> meters,\n                       SortedMap<String, Timer> timers)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "isEmpty", "isEmpty", "isEmpty", "isEmpty", "info", "checkForIndexTemplate", "getTime", "format", "openConnection", "error", "asList", "entrySet", "getValue", "getValue", "name", "getKey", "getValue", "writeJsonMetricAndRecreateConnectionIfNeeded", "addJsonMetricToPercolationIfMatching", "entrySet", "name", "getKey", "getValue", "writeJsonMetricAndRecreateConnectionIfNeeded", "addJsonMetricToPercolationIfMatching", "entrySet", "name", "getKey", "getValue", "writeJsonMetricAndRecreateConnectionIfNeeded", "addJsonMetricToPercolationIfMatching", "entrySet", "name", "getKey", "getValue", "writeJsonMetricAndRecreateConnectionIfNeeded", "addJsonMetricToPercolationIfMatching", "entrySet", "name", "getKey", "getValue", "writeJsonMetricAndRecreateConnectionIfNeeded", "addJsonMetricToPercolationIfMatching", "closeConnection", "size", "getPercolationMatches", "notify", "error", "error"]}, "repository": {"repo_id": 49945501, "url": "https://github.com/neoteric-eu/neo-starters", "language": "Java", "is_fork": false, "fork_count": 9, "stargazer_count": 8, "size": 969, "license": "licensed"}}