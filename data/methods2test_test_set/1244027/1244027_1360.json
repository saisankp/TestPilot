{"test_class": {"identifier": "DocumentOptimizerTest", "superclass": "extends AbstractSessionCacheTest", "interfaces": "", "fields": [{"original_string": "private DocumentOptimizer optimizer;", "modifier": "private", "type": "DocumentOptimizer", "declarator": "optimizer", "var_name": "optimizer"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/cache/document/DocumentOptimizerTest.java"}, "test_case": {"identifier": "shouldSplitDocumentThatRepeatedlyContainsTooManyChildReferencesIntoMultipleSegments", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldSplitDocumentThatRepeatedlyContainsTooManyChildReferencesIntoMultipleSegments() throws Exception {\n        MutableCachedNode nodeB = check(session1).mutableNode(\"/childB\");\n        NodeKey key = nodeB.getKey();\n\n        // Make it optimum to start out ...\n        runInTransaction(() -> optimizer.optimizeChildrenBlocks(key, null, 5, 2)); // will merge into a single block ...\n        // Save the session, otherwise the database is inconsistent after the optimize operation\n        session1.save();\n        nodeB = check(session1).mutableNode(\"/childB\");\n        print(false);\n        print(document(key), true);\n        print(false);\n\n        for (int j = 0; j != 5; ++j) {\n            // Create a bunch of children ...\n            for (int i = 0; i != 5; ++i) {\n                NodeKey newKey = key.withId(\"child\" + ((j * 5) + i + 1));\n                nodeB.createChild(session(), newKey, name(\"newChild\"), property(\"p1a\", 344), property(\"p2\", false));\n            }\n            session1.save();\n            // Find node B again after the save ...\n            nodeB = check(session1).mutableNode(\"/childB\");\n\n            print(false);\n            print(\"\\nOptimizing...\");\n            print(document(key), true);\n            runInTransaction(() -> optimizer.optimizeChildrenBlocks(key, null, 5, 2)); // will split into blocks ...)\n            print(\"\\nOptimized...\");\n            print(document(key), true);\n            print(false);\n        }\n        \n        runInTransaction(() -> optimizer.optimizeChildrenBlocks(key, null, 5, 2));\n\n        print(false);\n        print(document(key), true);\n    }", "signature": "void shouldSplitDocumentThatRepeatedlyContainsTooManyChildReferencesIntoMultipleSegments()", "full_signature": "@Test public void shouldSplitDocumentThatRepeatedlyContainsTooManyChildReferencesIntoMultipleSegments()", "class_method_signature": "DocumentOptimizerTest.shouldSplitDocumentThatRepeatedlyContainsTooManyChildReferencesIntoMultipleSegments()", "testcase": true, "constructor": false, "invocations": ["mutableNode", "check", "getKey", "runInTransaction", "optimizeChildrenBlocks", "save", "mutableNode", "check", "print", "print", "document", "print", "withId", "createChild", "session", "name", "property", "property", "save", "mutableNode", "check", "print", "print", "print", "document", "runInTransaction", "optimizeChildrenBlocks", "print", "print", "document", "print", "runInTransaction", "optimizeChildrenBlocks", "print", "print", "document"]}, "focal_class": {"identifier": "DocumentOptimizer", "superclass": "", "interfaces": "implements DocumentConstants", "fields": [{"original_string": "private final DocumentStore documentStore;", "modifier": "private final", "type": "DocumentStore", "declarator": "documentStore", "var_name": "documentStore"}], "methods": [{"identifier": "DocumentOptimizer", "parameters": "( DocumentStore documentStore )", "modifiers": "public", "return": "", "signature": " DocumentOptimizer( DocumentStore documentStore )", "full_signature": "public  DocumentOptimizer( DocumentStore documentStore )", "class_method_signature": "DocumentOptimizer.DocumentOptimizer( DocumentStore documentStore )", "testcase": false, "constructor": true}, {"identifier": "optimizeChildrenBlocks", "parameters": "( NodeKey key,\n                                           EditableDocument document,\n                                           int targetCountPerBlock,\n                                           int tolerance )", "modifiers": "public", "return": "boolean", "signature": "boolean optimizeChildrenBlocks( NodeKey key,\n                                           EditableDocument document,\n                                           int targetCountPerBlock,\n                                           int tolerance )", "full_signature": "public boolean optimizeChildrenBlocks( NodeKey key,\n                                           EditableDocument document,\n                                           int targetCountPerBlock,\n                                           int tolerance )", "class_method_signature": "DocumentOptimizer.optimizeChildrenBlocks( NodeKey key,\n                                           EditableDocument document,\n                                           int targetCountPerBlock,\n                                           int tolerance )", "testcase": false, "constructor": false}, {"identifier": "edit", "parameters": "( String key )", "modifiers": "protected", "return": "EditableDocument", "signature": "EditableDocument edit( String key )", "full_signature": "protected EditableDocument edit( String key )", "class_method_signature": "DocumentOptimizer.edit( String key )", "testcase": false, "constructor": false}, {"identifier": "splitChildren", "parameters": "( NodeKey key,\n                                     EditableDocument document,\n                                     EditableArray children,\n                                     int targetCountPerBlock,\n                                     int tolerance,\n                                     boolean isFirst,\n                                     String nextBlock )", "modifiers": "protected", "return": "boolean", "signature": "boolean splitChildren( NodeKey key,\n                                     EditableDocument document,\n                                     EditableArray children,\n                                     int targetCountPerBlock,\n                                     int tolerance,\n                                     boolean isFirst,\n                                     String nextBlock )", "full_signature": "protected boolean splitChildren( NodeKey key,\n                                     EditableDocument document,\n                                     EditableArray children,\n                                     int targetCountPerBlock,\n                                     int tolerance,\n                                     boolean isFirst,\n                                     String nextBlock )", "class_method_signature": "DocumentOptimizer.splitChildren( NodeKey key,\n                                     EditableDocument document,\n                                     EditableArray children,\n                                     int targetCountPerBlock,\n                                     int tolerance,\n                                     boolean isFirst,\n                                     String nextBlock )", "testcase": false, "constructor": false}, {"identifier": "mergeChildren", "parameters": "( NodeKey key,\n                                    EditableDocument document,\n                                    EditableArray children,\n                                    boolean isFirst,\n                                    String nextBlock )", "modifiers": "protected", "return": "String", "signature": "String mergeChildren( NodeKey key,\n                                    EditableDocument document,\n                                    EditableArray children,\n                                    boolean isFirst,\n                                    String nextBlock )", "full_signature": "protected String mergeChildren( NodeKey key,\n                                    EditableDocument document,\n                                    EditableArray children,\n                                    boolean isFirst,\n                                    String nextBlock )", "class_method_signature": "DocumentOptimizer.mergeChildren( NodeKey key,\n                                    EditableDocument document,\n                                    EditableArray children,\n                                    boolean isFirst,\n                                    String nextBlock )", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/cache/document/DocumentOptimizer.java"}, "focal_method": {"identifier": "optimizeChildrenBlocks", "parameters": "( NodeKey key,\n                                           EditableDocument document,\n                                           int targetCountPerBlock,\n                                           int tolerance )", "modifiers": "public", "return": "boolean", "body": "public boolean optimizeChildrenBlocks( NodeKey key,\n                                           EditableDocument document,\n                                           int targetCountPerBlock,\n                                           int tolerance ) {\n        if (document == null) {\n            document = edit(key.toString());\n            if (document == null) {\n                return false;\n            }\n        }\n        EditableArray children = document.getArray(CHILDREN);\n        if (children == null) {\n            // There are no children to optimize\n            return false;\n        }\n\n        // Get the children info\n        EditableDocument info = document.getDocument(CHILDREN_INFO);\n        boolean selfContained = true;\n        if (info != null) {\n            selfContained = !info.containsField(NEXT_BLOCK);\n        }\n\n        boolean changed = false;\n        if (selfContained) {\n            // This is a self-contained block; we only need to do something if the child count is larger than target +/- tolerance\n            int total = children.size();\n            if (total < targetCountPerBlock + tolerance) {\n                // The number of children is small enough ...\n                return false;\n            }\n            // Otherwise, there are more children than our target + tolerance, so we need to split the children ...\n            splitChildren(key, document, children, targetCountPerBlock, tolerance, true, null);\n            changed = true;\n        } else {\n            assert info != null;\n            // This is not self-contained; there are already at least two blocks.\n            // Go through each block, and either split it, merge it with the previous block, or leave it.\n            EditableDocument doc = document;\n            NodeKey docKey = key;\n            while (doc != null) {\n                EditableDocument docInfo = doc.getDocument(CHILDREN_INFO);\n                String nextKey = docInfo != null ? docInfo.getString(NEXT_BLOCK) : null;\n                children = doc.getArray(CHILDREN);\n                int count = children.size();\n                boolean isFirst = doc == document;\n                if (count > (targetCountPerBlock + tolerance)) {\n                    // This block is too big, so we should split it into multiple blocks...\n                    splitChildren(docKey, doc, children, targetCountPerBlock, tolerance, isFirst, nextKey);\n                    changed = true;\n                } else if (count < (targetCountPerBlock - tolerance) && nextKey != null) {\n                    // This block is too small, so always combine it with the next block, if there is one\n                    // (even if that makes the next block too big, since it will be split in a later pass).\n                    // Note that since we're only splitting if there is a next block, a last block that\n                    // is too small will be left untouched. At this time, we think this is okay.\n                    nextKey = mergeChildren(docKey, doc, children, isFirst, nextKey);\n                    changed = true;\n\n                    if (nextKey == null) {\n                        // We merged the last block into this document, so we need to change the pointer in 'document'\n                        // to be this doc ...\n                        info.setString(LAST_BLOCK, docKey.toString());\n                    }\n                }\n                // Otherwise, this block is just right\n\n                // Find the next block ...\n                if (nextKey != null) {\n                    doc = edit(nextKey);\n                    docKey = new NodeKey(nextKey);\n                } else {\n                    doc = null;\n                }\n            }\n        }\n        return changed;\n    }", "signature": "boolean optimizeChildrenBlocks( NodeKey key,\n                                           EditableDocument document,\n                                           int targetCountPerBlock,\n                                           int tolerance )", "full_signature": "public boolean optimizeChildrenBlocks( NodeKey key,\n                                           EditableDocument document,\n                                           int targetCountPerBlock,\n                                           int tolerance )", "class_method_signature": "DocumentOptimizer.optimizeChildrenBlocks( NodeKey key,\n                                           EditableDocument document,\n                                           int targetCountPerBlock,\n                                           int tolerance )", "testcase": false, "constructor": false, "invocations": ["edit", "toString", "getArray", "getDocument", "containsField", "size", "splitChildren", "getDocument", "getString", "getArray", "size", "splitChildren", "mergeChildren", "setString", "toString", "edit"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}