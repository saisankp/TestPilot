{"test_class": {"identifier": "HBaseScanConfigBuilderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Charset CHARSET = StandardCharsets.UTF_8;", "modifier": "private static final", "type": "Charset", "declarator": "CHARSET = StandardCharsets.UTF_8", "var_name": "CHARSET"}, {"original_string": "HBaseScanConfigBuilder hBaseScanConfigBuilder;", "modifier": "", "type": "HBaseScanConfigBuilder", "declarator": "hBaseScanConfigBuilder", "var_name": "hBaseScanConfigBuilder"}, {"original_string": "@Mocked\n    IndexMapper<Notification> mockIndexMapper;", "modifier": "@Mocked", "type": "IndexMapper<Notification>", "declarator": "mockIndexMapper", "var_name": "mockIndexMapper"}, {"original_string": "@Mocked\n    Criteria<Notification> mockNotificationCriteria;", "modifier": "@Mocked", "type": "Criteria<Notification>", "declarator": "mockNotificationCriteria", "var_name": "mockNotificationCriteria"}], "file": "streams/notification/src/test/java/com/hortonworks/streamline/streams/notification/store/hbase/HBaseScanConfigBuilderTest.java"}, "test_case": {"identifier": "testGetScanConfig", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGetScanConfig() throws Exception {\n        final List<Criteria.Field> fr = new ArrayList<>();\n        fr.add(new CriteriaImpl.FieldImpl(\"notifierName\", \"test_notifier\"));\n        fr.add(new CriteriaImpl.FieldImpl(\"status\", \"NEW\"));\n\n\n        final List<byte[]> nnList = Arrays.asList(\"s\".getBytes(CHARSET),\n                                                  \"qs\".getBytes(CHARSET),\n                                                  \"NEW\".getBytes(CHARSET));\n        new Expectations() {\n            {\n                mockNotificationCriteria.clazz();\n                times = 1;\n                result = Notification.class;\n                mockNotificationCriteria.fieldRestrictions();\n                times = 1;\n                result = fr;\n                mockIndexMapper.getIndexedFieldNames(); times = 1;\n                result = Arrays.asList(\"notifierName\");\n                mockNotificationCriteria.numRows(); times = 1;\n                result = 5;\n                mockIndexMapper.mapMemberValue(\"status\", \"NEW\"); times = 1;\n                result = nnList;\n            }\n        };\n\n        hBaseScanConfigBuilder = new HBaseScanConfigBuilder();\n        hBaseScanConfigBuilder.addMappers(Notification.class, Arrays.asList(mockIndexMapper));\n\n        Criteria<Notification> eventCriteria = new CriteriaImpl<>(Notification.class);\n\n        HBaseScanConfig<Notification> notificationScanConfig = hBaseScanConfigBuilder.getScanConfig(mockNotificationCriteria);\n\n        System.out.println(notificationScanConfig);\n        assertEquals(mockIndexMapper, notificationScanConfig.getMapper());\n        assertArrayEquals(\"test_notifier|0\".getBytes(CHARSET), notificationScanConfig.getStartRow());\n        assertArrayEquals((\"test_notifier|\"+Long.MAX_VALUE).getBytes(CHARSET), notificationScanConfig.getStopRow());\n        assertEquals(2, notificationScanConfig.filterList().getFilters().size());\n        // column filter should be first\n        Filter firstFilter = notificationScanConfig.filterList().getFilters().get(0);\n        assertEquals(SingleColumnValueFilter.class, firstFilter.getClass());\n        // page filter should be last\n        Filter secondFilter = notificationScanConfig.filterList().getFilters().get(1);\n        assertEquals(PageFilter.class, secondFilter.getClass());\n    }", "signature": "void testGetScanConfig()", "full_signature": "@Test public void testGetScanConfig()", "class_method_signature": "HBaseScanConfigBuilderTest.testGetScanConfig()", "testcase": true, "constructor": false, "invocations": ["add", "add", "asList", "getBytes", "getBytes", "getBytes", "clazz", "fieldRestrictions", "getIndexedFieldNames", "asList", "numRows", "mapMemberValue", "addMappers", "asList", "getScanConfig", "println", "assertEquals", "getMapper", "assertArrayEquals", "getBytes", "getStartRow", "assertArrayEquals", "getBytes", "getStopRow", "assertEquals", "size", "getFilters", "filterList", "get", "getFilters", "filterList", "assertEquals", "getClass", "get", "getFilters", "filterList", "assertEquals", "getClass"]}, "focal_class": {"identifier": "HBaseScanConfigBuilder", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(HBaseScanConfigBuilder.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(HBaseScanConfigBuilder.class)", "var_name": "LOG"}, {"original_string": "private static final List<String> DEFAULT_INDEX_FIELD_NAMES = Arrays.asList(\"ts\");", "modifier": "private static final", "type": "List<String>", "declarator": "DEFAULT_INDEX_FIELD_NAMES = Arrays.asList(\"ts\")", "var_name": "DEFAULT_INDEX_FIELD_NAMES"}, {"original_string": "private final Map<Class<?>, Map<List<String>, IndexMapper<?>>> mappers = new HashMap<>();", "modifier": "private final", "type": "Map<Class<?>, Map<List<String>, IndexMapper<?>>>", "declarator": "mappers = new HashMap<>()", "var_name": "mappers"}, {"original_string": "private static final Comparator<IndexMapper<?>> reverseIndexFieldsLengthComparator =\n            new Comparator<IndexMapper<?>>() {\n                @Override\n                public int compare(IndexMapper<?> im1, IndexMapper<?> im2) {\n                    return im2.getIndexedFieldNames().size() - im1.getIndexedFieldNames().size();\n                }\n            };", "modifier": "private static final", "type": "Comparator<IndexMapper<?>>", "declarator": "reverseIndexFieldsLengthComparator =\n            new Comparator<IndexMapper<?>>() {\n                @Override\n                public int compare(IndexMapper<?> im1, IndexMapper<?> im2) {\n                    return im2.getIndexedFieldNames().size() - im1.getIndexedFieldNames().size();\n                }\n            }", "var_name": "reverseIndexFieldsLengthComparator"}], "methods": [{"identifier": "addMappers", "parameters": "(Class<T> clazz, List<? extends IndexMapper<T>> indexMappers)", "modifiers": "public", "return": "void", "signature": "void addMappers(Class<T> clazz, List<? extends IndexMapper<T>> indexMappers)", "full_signature": "public void addMappers(Class<T> clazz, List<? extends IndexMapper<T>> indexMappers)", "class_method_signature": "HBaseScanConfigBuilder.addMappers(Class<T> clazz, List<? extends IndexMapper<T>> indexMappers)", "testcase": false, "constructor": false}, {"identifier": "fieldsValue", "parameters": "(List<Criteria.Field> fields)", "modifiers": "private", "return": "String", "signature": "String fieldsValue(List<Criteria.Field> fields)", "full_signature": "private String fieldsValue(List<Criteria.Field> fields)", "class_method_signature": "HBaseScanConfigBuilder.fieldsValue(List<Criteria.Field> fields)", "testcase": false, "constructor": false}, {"identifier": "bestMatch", "parameters": "(Map<List<String>, IndexMapper<?>> indexMap,\n                                                              Set<String> queryFieldNames)", "modifiers": "private", "return": "Map.Entry<List<String>, IndexMapper<?>>", "signature": "Map.Entry<List<String>, IndexMapper<?>> bestMatch(Map<List<String>, IndexMapper<?>> indexMap,\n                                                              Set<String> queryFieldNames)", "full_signature": "private Map.Entry<List<String>, IndexMapper<?>> bestMatch(Map<List<String>, IndexMapper<?>> indexMap,\n                                                              Set<String> queryFieldNames)", "class_method_signature": "HBaseScanConfigBuilder.bestMatch(Map<List<String>, IndexMapper<?>> indexMap,\n                                                              Set<String> queryFieldNames)", "testcase": false, "constructor": false}, {"identifier": "getScanConfig", "parameters": "(Criteria<T> criteria)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "HBaseScanConfig<T>", "signature": "HBaseScanConfig<T> getScanConfig(Criteria<T> criteria)", "full_signature": "@SuppressWarnings(\"unchecked\") public HBaseScanConfig<T> getScanConfig(Criteria<T> criteria)", "class_method_signature": "HBaseScanConfigBuilder.getScanConfig(Criteria<T> criteria)", "testcase": false, "constructor": false}], "file": "streams/notification/src/main/java/com/hortonworks/streamline/streams/notification/store/hbase/HBaseScanConfigBuilder.java"}, "focal_method": {"identifier": "getScanConfig", "parameters": "(Criteria<T> criteria)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "HBaseScanConfig<T>", "body": "@SuppressWarnings(\"unchecked\")\n    public <T> HBaseScanConfig<T> getScanConfig(Criteria<T> criteria) {\n        Map<List<String>, IndexMapper<?>> indexMap = mappers.get(criteria.clazz());\n        HBaseScanConfig<T> hBaseScanConfig = null;\n        if (indexMap != null) {\n            hBaseScanConfig = new HBaseScanConfig<>();\n            IndexMapper<T> indexMapper = null;\n            List<Criteria.Field> nonIndexedFields = new ArrayList<>();\n            List<Criteria.Field> indexedFields = new ArrayList<>();\n            List<Criteria.Field> fieldRestrictions = criteria.fieldRestrictions();\n            if (!fieldRestrictions.isEmpty()) {\n                // construct query field name -> Field map\n                Map<String, Criteria.Field> queryFieldMap = new HashMap<>();\n                for (Criteria.Field field : fieldRestrictions) {\n                    queryFieldMap.put(field.getName(), field);\n                }\n                // find the best index mapper to use\n                Map.Entry<List<String>, IndexMapper<?>> bestEntry = bestMatch(indexMap, queryFieldMap.keySet());\n                if (bestEntry != null) {\n                    LOG.debug(\"Found bestEntry {} for fieldRestrictions {}\", bestEntry, fieldRestrictions);\n                    indexMapper = (IndexMapper<T>) bestEntry.getValue();\n                    hBaseScanConfig.setMapper(indexMapper);\n                    // add the fields available in the query to indexedFields\n                    for (String indexedFieldName : bestEntry.getKey()) {\n                        Criteria.Field field;\n                        if ((field = queryFieldMap.remove(indexedFieldName)) != null) {\n                            indexedFields.add(field);\n                        } else {\n                            break; // no more fields can be used as prefix so stop.\n                        }\n                    }\n                    hBaseScanConfig.setIndexedFieldValue(fieldsValue(indexedFields));\n                    nonIndexedFields.addAll(queryFieldMap.values()); // remaining fields\n                }\n            }\n\n            // we haven't found an index mapper, use the default index table if available\n            if (indexMapper == null) {\n                if ((indexMapper = (IndexMapper<T>) indexMap.get(DEFAULT_INDEX_FIELD_NAMES)) == null) {\n                    return null; // no default index table, we can't proceed with the scan\n                }\n                hBaseScanConfig.setMapper(indexMapper);\n                nonIndexedFields.addAll(fieldRestrictions);\n            }\n\n            LOG.debug(\"nonIndexedFields {}\", nonIndexedFields);\n            // add filters for non-indexed fields\n            for (Criteria.Field field : nonIndexedFields) {\n                List<byte[]> CfCqCv = indexMapper.mapMemberValue(field.getName(), field.getValue());\n                if (CfCqCv != null) {\n                    SingleColumnValueFilter filter = new SingleColumnValueFilter(CfCqCv.get(0),\n                                                                                 CfCqCv.get(1),\n                                                                                 CompareFilter.CompareOp.EQUAL,\n                                                                                 CfCqCv.get(2));\n                    filter.setFilterIfMissing(true);\n                    hBaseScanConfig.addFilter(filter);\n                } else {\n                    return null; // field not found\n                }\n            }\n            hBaseScanConfig.setStartTs(criteria.startTs());\n            hBaseScanConfig.setEndTs(criteria.endTs());\n            hBaseScanConfig.setNumRows(criteria.numRows());\n        }\n\n        return hBaseScanConfig;\n    }", "signature": "HBaseScanConfig<T> getScanConfig(Criteria<T> criteria)", "full_signature": "@SuppressWarnings(\"unchecked\") public HBaseScanConfig<T> getScanConfig(Criteria<T> criteria)", "class_method_signature": "HBaseScanConfigBuilder.getScanConfig(Criteria<T> criteria)", "testcase": false, "constructor": false, "invocations": ["get", "clazz", "fieldRestrictions", "isEmpty", "put", "getName", "bestMatch", "keySet", "debug", "getValue", "setMapper", "getKey", "remove", "add", "setIndexedFieldValue", "fieldsValue", "addAll", "values", "get", "setMapper", "addAll", "debug", "mapMemberValue", "getName", "getValue", "get", "get", "get", "setFilterIfMissing", "addFilter", "setStartTs", "startTs", "setEndTs", "endTs", "setNumRows", "numRows"]}, "repository": {"repo_id": 35627039, "url": "https://github.com/hortonworks/streamline", "language": "Java", "is_fork": false, "fork_count": 94, "stargazer_count": 147, "size": 69226, "license": "licensed"}}