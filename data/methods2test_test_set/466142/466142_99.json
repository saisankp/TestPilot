{"test_class": {"identifier": "TestPoolWatchThread", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ConnectionPartition mockPartition;", "modifier": "private", "type": "ConnectionPartition", "declarator": "mockPartition", "var_name": "mockPartition"}, {"original_string": "private BoneCP mockPool;", "modifier": "private", "type": "BoneCP", "declarator": "mockPool", "var_name": "mockPool"}, {"original_string": "static PoolWatchThread testClass;", "modifier": "static", "type": "PoolWatchThread", "declarator": "testClass", "var_name": "testClass"}, {"original_string": "private Logger mockLogger;", "modifier": "private", "type": "Logger", "declarator": "mockLogger", "var_name": "mockLogger"}, {"original_string": "static boolean first = true;", "modifier": "static", "type": "boolean", "declarator": "first = true", "var_name": "first"}, {"original_string": "private BoneCPConfig mockConfig;", "modifier": "private", "type": "BoneCPConfig", "declarator": "mockConfig", "var_name": "mockConfig"}, {"original_string": "private MockJDBCDriver driver;", "modifier": "private", "type": "MockJDBCDriver", "declarator": "driver", "var_name": "driver"}], "file": "bonecp/src/test/java/com/jolbox/bonecp/TestPoolWatchThread.java"}, "test_case": {"identifier": "testRunCreateConnections", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testRunCreateConnections() throws InterruptedException, SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException, SQLException{\n\t\texpect(mockLogger.isDebugEnabled()).andReturn(true).anyTimes();\n\n\t\tLinkedBlockingQueue<ConnectionHandle> fakeConnections = new LinkedBlockingQueue<ConnectionHandle>(100);\n//\t\tmockPartition.almostFullWait();\n//\t\texpectLastCall().anyTimes();\n\t\texpect(mockPartition.getMaxConnections()).andAnswer(new IAnswer<Integer>() {\n\n\t\t\t// @Override\n\t\t\tpublic Integer answer() throws Throwable {\n\t\t\t\tif (first) {\n\t\t\t\t\tfirst=false;\n\t\t\t\t\treturn 4;\n\t\t\t\t} \n\t\t\t\tField field = testClass.getClass().getDeclaredField(\"signalled\");\n\t\t\t\tfield.setAccessible(true);\n\t\t\t\tfield.setBoolean(testClass, true);\n\t\t\t\treturn 4;\n\n\t\t\t}\n\t\t}).anyTimes();\n\t\t\n\t\texpect(mockPartition.getFreeConnections()).andReturn(fakeConnections).anyTimes();\n\n\n\t\texpect(mockPartition.getAcquireIncrement()).andReturn(1);\n\t\t\n\t\t\n\t\texpect(mockPartition.getUrl()).andReturn(CommonTestUtils.url).anyTimes();\n\t\texpect(mockPartition.getPassword()).andReturn(CommonTestUtils.password).anyTimes();\n\t\texpect(mockPartition.getUsername()).andReturn(CommonTestUtils.username).anyTimes();\n\t\texpect(mockPartition.getAvailableConnections()).andReturn(fakeConnections.size()).anyTimes();\n\n\t\tmockPartition.addFreeConnection((ConnectionHandle)anyObject());\n\t\texpectLastCall().once();\n\t\texpect(mockPool.obtainInternalConnection((ConnectionHandle)anyObject())).andReturn(EasyMock.createNiceMock(Connection.class)).anyTimes();\n\t\texpect(mockPool.getDbIsDown()).andReturn(new AtomicBoolean()).anyTimes();\n    \texpect(mockPool.getConfig()).andReturn(mockConfig).anyTimes();\n\t\treplay(mockPool, mockPartition, mockLogger);\n\t\ttestClass.run();\n\t\tEasyMock.verify(mockPartition);\n\t\t\n\t\t// check exceptional cases\n\t\treset(mockPartition, mockPool, mockLogger);\n\t\tresetSignalled();\n\n\n\t\tfirst = true;\n//\t\tmockPartition.unlockAlmostFullLock();\n//\t\texpectLastCall().once();\n\t\t\n//\t\tmockPartition.lockAlmostFullLock();\n//\t\texpectLastCall().andThrow(new RuntimeException());\n\t\treplay(mockPartition, mockLogger);\n\t\ttry{\n\t\t\ttestClass.run();\n\t\t\tAssert.fail(\"Exception should have been thrown\");\n\t\t} catch (RuntimeException e){\n\t\t\t// do nothing\n\t\t}\n\t\tEasyMock.verify(mockPartition);\n\n\t\t\n\t\t// check case where creating new ConnectionHandle fails\n\t\treset(mockPool, mockLogger, mockConfig);\n\t\treset(mockPartition);\n\t\tresetSignalled();\n\n\t\tfirst = true;\n\t\texpect(mockPartition.getFreeConnections()).andReturn(fakeConnections).anyTimes();\n\t\t\n\t\texpect(mockPartition.getMaxConnections()).andAnswer(new IAnswer<Integer>() {\n\n\t\t\t// @Override\n\t\t\tpublic Integer answer() throws Throwable {\n\t\t\t\tif (first) {\n\t\t\t\t\tfirst=false;\n\t\t\t\t\treturn 4;\n\t\t\t\t} \n\t\t\t\tField field = testClass.getClass().getDeclaredField(\"signalled\");\n\t\t\t\tfield.setAccessible(true);\n\t\t\t\tfield.setBoolean(testClass, true);\n\t\t\t\treturn 4;\n\n\t\t\t}\n\t\t}).anyTimes();\n\t\t\n//\t\tmockPartition.unlockAlmostFullLock();\n//\t\texpectLastCall().once();\n\t\t\n//\t\tmockPartition.lockAlmostFullLock();\n//\t\texpectLastCall().once();\n\n\t\texpect(mockConfig.getStatementsCacheSize()).andAnswer(new IAnswer<Integer>() {\n\t\t\t\n\t\t\t// @Override\n\t\t\tpublic Integer answer() throws Throwable {\n\t\t\t\tthrow new SQLException();\n\t\t\t\t\n\t\t\t} \n\t\t}).once();\n\t\texpect(mockPartition.getAcquireIncrement()).andReturn(1).anyTimes();\n\t\texpect(mockPartition.getAvailableConnections()).andReturn(fakeConnections.size()).anyTimes();\n    \texpect(mockPool.getConfig()).andReturn(mockConfig).anyTimes();\n\n\t\texpect(mockConfig.getAcquireRetryAttempts()).andReturn(0).anyTimes();\n\n\t\tmockLogger.error((String)anyObject(), anyObject());\n\t\texpectLastCall(); \n\t\texpect(mockPool.getDbIsDown()).andReturn(new AtomicBoolean()).anyTimes();\n\t\treplay(mockPartition, mockPool, mockLogger, mockConfig);\n\t\ttestClass.run();\n\t\tEasyMock.verify(mockPartition);\n\n\t}", "signature": "void testRunCreateConnections()", "full_signature": "@Test public void testRunCreateConnections()", "class_method_signature": "TestPoolWatchThread.testRunCreateConnections()", "testcase": true, "constructor": false, "invocations": ["anyTimes", "andReturn", "expect", "isDebugEnabled", "anyTimes", "andAnswer", "expect", "getMaxConnections", "getDeclaredField", "getClass", "setAccessible", "setBoolean", "anyTimes", "andReturn", "expect", "getFreeConnections", "andReturn", "expect", "getAcquireIncrement", "anyTimes", "andReturn", "expect", "getUrl", "anyTimes", "andReturn", "expect", "getPassword", "anyTimes", "andReturn", "expect", "getUsername", "anyTimes", "andReturn", "expect", "getAvailableConnections", "size", "addFreeConnection", "anyObject", "once", "expectLastCall", "anyTimes", "andReturn", "expect", "obtainInternalConnection", "anyObject", "createNiceMock", "anyTimes", "andReturn", "expect", "getDbIsDown", "anyTimes", "andReturn", "expect", "getConfig", "replay", "run", "verify", "reset", "resetSignalled", "replay", "run", "fail", "verify", "reset", "reset", "resetSignalled", "anyTimes", "andReturn", "expect", "getFreeConnections", "anyTimes", "andAnswer", "expect", "getMaxConnections", "getDeclaredField", "getClass", "setAccessible", "setBoolean", "once", "andAnswer", "expect", "getStatementsCacheSize", "anyTimes", "andReturn", "expect", "getAcquireIncrement", "anyTimes", "andReturn", "expect", "getAvailableConnections", "size", "anyTimes", "andReturn", "expect", "getConfig", "anyTimes", "andReturn", "expect", "getAcquireRetryAttempts", "error", "anyObject", "anyObject", "expectLastCall", "anyTimes", "andReturn", "expect", "getDbIsDown", "replay", "run", "verify"]}, "focal_class": {"identifier": "PoolWatchThread", "superclass": "", "interfaces": "implements Runnable", "fields": [{"original_string": "private ConnectionPartition partition;", "modifier": "private", "type": "ConnectionPartition", "declarator": "partition", "var_name": "partition"}, {"original_string": "private BoneCP pool;", "modifier": "private", "type": "BoneCP", "declarator": "pool", "var_name": "pool"}, {"original_string": "private boolean signalled;", "modifier": "private", "type": "boolean", "declarator": "signalled", "var_name": "signalled"}, {"original_string": "private long acquireRetryDelayInMs = 1000L;", "modifier": "private", "type": "long", "declarator": "acquireRetryDelayInMs = 1000L", "var_name": "acquireRetryDelayInMs"}, {"original_string": "protected boolean lazyInit;", "modifier": "protected", "type": "boolean", "declarator": "lazyInit", "var_name": "lazyInit"}, {"original_string": "private int poolAvailabilityThreshold;", "modifier": "private", "type": "int", "declarator": "poolAvailabilityThreshold", "var_name": "poolAvailabilityThreshold"}, {"original_string": "private static final Logger logger = LoggerFactory.getLogger(PoolWatchThread.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(PoolWatchThread.class)", "var_name": "logger"}], "methods": [{"identifier": "PoolWatchThread", "parameters": "(ConnectionPartition connectionPartition, BoneCP pool)", "modifiers": "public", "return": "", "signature": " PoolWatchThread(ConnectionPartition connectionPartition, BoneCP pool)", "full_signature": "public  PoolWatchThread(ConnectionPartition connectionPartition, BoneCP pool)", "class_method_signature": "PoolWatchThread.PoolWatchThread(ConnectionPartition connectionPartition, BoneCP pool)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void run()", "full_signature": "public void run()", "class_method_signature": "PoolWatchThread.run()", "testcase": false, "constructor": false}, {"identifier": "fillConnections", "parameters": "(int connectionsToCreate)", "modifiers": "private", "return": "void", "signature": "void fillConnections(int connectionsToCreate)", "full_signature": "private void fillConnections(int connectionsToCreate)", "class_method_signature": "PoolWatchThread.fillConnections(int connectionsToCreate)", "testcase": false, "constructor": false}], "file": "bonecp/src/main/java/com/jolbox/bonecp/PoolWatchThread.java"}, "focal_method": {"identifier": "run", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void run() {\n\t\tint maxNewConnections;\n\t\twhile (!this.signalled){\n\t\t\tmaxNewConnections=0;\n\n\t\t\ttry{\n\t\t\t\tif (this.lazyInit){ // block the first time if this is on.\n\t\t\t\t\tthis.partition.getPoolWatchThreadSignalQueue().take();\n\t\t\t\t}\n \n\n\t\t\t\tmaxNewConnections = this.partition.getMaxConnections()-this.partition.getCreatedConnections();\n\t\t\t\t// loop for spurious interrupt\n\t\t\t\twhile (maxNewConnections == 0 || (this.partition.getAvailableConnections() *100/this.partition.getMaxConnections() > this.poolAvailabilityThreshold)){\n\t\t\t\t\tif (maxNewConnections == 0){\n\t\t\t\t\t\tthis.partition.setUnableToCreateMoreTransactions(true);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.partition.getPoolWatchThreadSignalQueue().take();\n\t\t\t\t\tmaxNewConnections = this.partition.getMaxConnections()-this.partition.getCreatedConnections();\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tif (maxNewConnections > 0 \n\t\t\t\t\t\t&& !this.pool.poolShuttingDown){\n\t\t\t\t\tfillConnections(Math.min(maxNewConnections, this.partition.getAcquireIncrement()));\n\t\t\t\t\t// for the case where we have killed off all our connections due to network/db error\n\t\t\t\t\tif (this.partition.getCreatedConnections() < this.partition.getMinConnections()){\n\t\t\t\t\t\tfillConnections(this.partition.getMinConnections() - this.partition.getCreatedConnections() );\n\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.pool.poolShuttingDown){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlogger.debug(\"Terminating pool watch thread\");\n\t\t\t\treturn; // we've been asked to terminate.\n\t\t\t}\n\t\t}\n\t}", "signature": "void run()", "full_signature": "public void run()", "class_method_signature": "PoolWatchThread.run()", "testcase": false, "constructor": false, "invocations": ["take", "getPoolWatchThreadSignalQueue", "getMaxConnections", "getCreatedConnections", "getAvailableConnections", "getMaxConnections", "setUnableToCreateMoreTransactions", "take", "getPoolWatchThreadSignalQueue", "getMaxConnections", "getCreatedConnections", "fillConnections", "min", "getAcquireIncrement", "getCreatedConnections", "getMinConnections", "fillConnections", "getMinConnections", "getCreatedConnections", "debug"]}, "repository": {"repo_id": 466142, "url": "https://github.com/wwadge/bonecp", "language": "Java", "is_fork": false, "fork_count": 161, "stargazer_count": 544, "size": 3833, "license": "licensed"}}