{"test_class": {"identifier": "NetUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "flink-core/src/test/java/org/apache/flink/util/NetUtilsTest.java"}, "test_case": {"identifier": "testFreePortRangeUtility", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testFreePortRangeUtility() {\n\t\t// inspired by Hadoop's example for \"yarn.app.mapreduce.am.job.client.port-range\"\n\t\tString rangeDefinition = \"50000-50050, 50100-50200,51234 \"; // this also contains some whitespaces\n\t\tIterator<Integer> portsIter = NetUtils.getPortRangeFromString(rangeDefinition);\n\t\tSet<Integer> ports = new HashSet<>();\n\t\twhile(portsIter.hasNext()) {\n\t\t\tAssert.assertTrue(\"Duplicate element\", ports.add(portsIter.next()));\n\t\t}\n\n\t\tAssert.assertEquals(51+101+1, ports.size());\n\t\t// check first range\n\t\tAssert.assertThat(ports, hasItems(50000, 50001, 50002, 50050));\n\t\t// check second range and last point\n\t\tAssert.assertThat(ports, hasItems(50100, 50101, 50110, 50200, 51234));\n\t\t// check that only ranges are included\n\t\tAssert.assertThat(ports, not(hasItems(50051, 50052, 1337, 50201, 49999, 50099)));\n\n\n\t\t// test single port \"range\":\n\t\tportsIter = NetUtils.getPortRangeFromString(\" 51234\");\n\t\tAssert.assertTrue(portsIter.hasNext());\n\t\tAssert.assertEquals(51234, (int)portsIter.next());\n\t\tAssert.assertFalse(portsIter.hasNext());\n\n\t\t// test port list\n\t\tportsIter = NetUtils.getPortRangeFromString(\"5,1,2,3,4\");\n\t\tAssert.assertTrue(portsIter.hasNext());\n\t\tAssert.assertEquals(5, (int)portsIter.next());\n\t\tAssert.assertEquals(1, (int)portsIter.next());\n\t\tAssert.assertEquals(2, (int)portsIter.next());\n\t\tAssert.assertEquals(3, (int)portsIter.next());\n\t\tAssert.assertEquals(4, (int)portsIter.next());\n\t\tAssert.assertFalse(portsIter.hasNext());\n\n\n\t\tThrowable error = null;\n\n\t\t// try some wrong values: String\n\t\ttry { NetUtils.getPortRangeFromString(\"localhost\"); } catch(Throwable t) { error = t; }\n\t\tAssert.assertTrue(error instanceof NumberFormatException);\n\t\terror = null;\n\n\t\t// incomplete range\n\t\ttry { NetUtils.getPortRangeFromString(\"5-\"); } catch(Throwable t) { error = t; }\n\t\tAssert.assertTrue(error instanceof NumberFormatException);\n\t\terror = null;\n\n\t\t// incomplete range\n\t\ttry { NetUtils.getPortRangeFromString(\"-5\"); } catch(Throwable t) { error = t; }\n\t\tAssert.assertTrue(error instanceof NumberFormatException);\n\t\terror = null;\n\n\t\t// empty range\n\t\ttry { NetUtils.getPortRangeFromString(\",5\"); } catch(Throwable t) { error = t; }\n\t\tAssert.assertTrue(error instanceof NumberFormatException);\n\t\terror = null;\n\n\t}", "signature": "void testFreePortRangeUtility()", "full_signature": "@Test public void testFreePortRangeUtility()", "class_method_signature": "NetUtilsTest.testFreePortRangeUtility()", "testcase": true, "constructor": false, "invocations": ["getPortRangeFromString", "hasNext", "assertTrue", "add", "next", "assertEquals", "size", "assertThat", "hasItems", "assertThat", "hasItems", "assertThat", "not", "hasItems", "getPortRangeFromString", "assertTrue", "hasNext", "assertEquals", "next", "assertFalse", "hasNext", "getPortRangeFromString", "assertTrue", "hasNext", "assertEquals", "next", "assertEquals", "next", "assertEquals", "next", "assertEquals", "next", "assertEquals", "next", "assertFalse", "hasNext", "getPortRangeFromString", "assertTrue", "getPortRangeFromString", "assertTrue", "getPortRangeFromString", "assertTrue", "getPortRangeFromString", "assertTrue"]}, "focal_class": {"identifier": "NetUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(NetUtils.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(NetUtils.class)", "var_name": "LOG"}], "methods": [{"identifier": "getHostnameFromFQDN", "parameters": "(String fqdn)", "modifiers": "public static", "return": "String", "signature": "String getHostnameFromFQDN(String fqdn)", "full_signature": "public static String getHostnameFromFQDN(String fqdn)", "class_method_signature": "NetUtils.getHostnameFromFQDN(String fqdn)", "testcase": false, "constructor": false}, {"identifier": "getCorrectHostnamePort", "parameters": "(String hostPort)", "modifiers": "public static", "return": "URL", "signature": "URL getCorrectHostnamePort(String hostPort)", "full_signature": "public static URL getCorrectHostnamePort(String hostPort)", "class_method_signature": "NetUtils.getCorrectHostnamePort(String hostPort)", "testcase": false, "constructor": false}, {"identifier": "getAvailablePort", "parameters": "()", "modifiers": "public static", "return": "int", "signature": "int getAvailablePort()", "full_signature": "public static int getAvailablePort()", "class_method_signature": "NetUtils.getAvailablePort()", "testcase": false, "constructor": false}, {"identifier": "ipAddressToUrlString", "parameters": "(InetAddress address)", "modifiers": "public static", "return": "String", "signature": "String ipAddressToUrlString(InetAddress address)", "full_signature": "public static String ipAddressToUrlString(InetAddress address)", "class_method_signature": "NetUtils.ipAddressToUrlString(InetAddress address)", "testcase": false, "constructor": false}, {"identifier": "ipAddressAndPortToUrlString", "parameters": "(InetAddress address, int port)", "modifiers": "public static", "return": "String", "signature": "String ipAddressAndPortToUrlString(InetAddress address, int port)", "full_signature": "public static String ipAddressAndPortToUrlString(InetAddress address, int port)", "class_method_signature": "NetUtils.ipAddressAndPortToUrlString(InetAddress address, int port)", "testcase": false, "constructor": false}, {"identifier": "socketAddressToUrlString", "parameters": "(InetSocketAddress address)", "modifiers": "public static", "return": "String", "signature": "String socketAddressToUrlString(InetSocketAddress address)", "full_signature": "public static String socketAddressToUrlString(InetSocketAddress address)", "class_method_signature": "NetUtils.socketAddressToUrlString(InetSocketAddress address)", "testcase": false, "constructor": false}, {"identifier": "hostAndPortToUrlString", "parameters": "(String host, int port)", "modifiers": "public static", "return": "String", "signature": "String hostAndPortToUrlString(String host, int port)", "full_signature": "public static String hostAndPortToUrlString(String host, int port)", "class_method_signature": "NetUtils.hostAndPortToUrlString(String host, int port)", "testcase": false, "constructor": false}, {"identifier": "getPortRangeFromString", "parameters": "(String rangeDefinition)", "modifiers": "public static", "return": "Iterator<Integer>", "signature": "Iterator<Integer> getPortRangeFromString(String rangeDefinition)", "full_signature": "public static Iterator<Integer> getPortRangeFromString(String rangeDefinition)", "class_method_signature": "NetUtils.getPortRangeFromString(String rangeDefinition)", "testcase": false, "constructor": false}, {"identifier": "createSocketFromPorts", "parameters": "(Iterator<Integer> portsIterator, SocketFactory factory)", "modifiers": "public static", "return": "ServerSocket", "signature": "ServerSocket createSocketFromPorts(Iterator<Integer> portsIterator, SocketFactory factory)", "full_signature": "public static ServerSocket createSocketFromPorts(Iterator<Integer> portsIterator, SocketFactory factory)", "class_method_signature": "NetUtils.createSocketFromPorts(Iterator<Integer> portsIterator, SocketFactory factory)", "testcase": false, "constructor": false}], "file": "flink-core/src/main/java/org/apache/flink/util/NetUtils.java"}, "focal_method": {"identifier": "getPortRangeFromString", "parameters": "(String rangeDefinition)", "modifiers": "public static", "return": "Iterator<Integer>", "body": "public static Iterator<Integer> getPortRangeFromString(String rangeDefinition) throws NumberFormatException {\n\t\tfinal String[] ranges = rangeDefinition.trim().split(\",\");\n\t\tList<Iterator<Integer>> iterators = new ArrayList<>(ranges.length);\n\t\tfor(String rawRange: ranges) {\n\t\t\tIterator<Integer> rangeIterator = null;\n\t\t\tString range = rawRange.trim();\n\t\t\tint dashIdx = range.indexOf('-');\n\t\t\tif (dashIdx == -1) {\n\t\t\t\t// only one port in range:\n\t\t\t\trangeIterator = Iterators.singletonIterator(Integer.valueOf(range));\n\t\t\t} else {\n\t\t\t\t// evaluate range\n\t\t\t\tfinal int start = Integer.valueOf(range.substring(0, dashIdx));\n\t\t\t\tfinal int end = Integer.valueOf(range.substring(dashIdx+1, range.length()));\n\t\t\t\trangeIterator = new Iterator<Integer>() {\n\t\t\t\t\tint i = start;\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\treturn i <= end;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer next() {\n\t\t\t\t\t\treturn i++;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void remove() {\n\t\t\t\t\t\tthrow new UnsupportedOperationException(\"Remove not supported\");\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\titerators.add(rangeIterator);\n\t\t}\n\t\treturn Iterators.concat(iterators.iterator());\n\t}", "signature": "Iterator<Integer> getPortRangeFromString(String rangeDefinition)", "full_signature": "public static Iterator<Integer> getPortRangeFromString(String rangeDefinition)", "class_method_signature": "NetUtils.getPortRangeFromString(String rangeDefinition)", "testcase": false, "constructor": false, "invocations": ["split", "trim", "trim", "indexOf", "singletonIterator", "valueOf", "valueOf", "substring", "valueOf", "substring", "length", "add", "concat", "iterator"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}