{"test_class": {"identifier": "CSVIngesterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(CSVIngesterTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(CSVIngesterTest.class)", "var_name": "log"}], "file": "legacy/src/test/java/macrobase/ingest/CSVIngesterTest.java"}, "test_case": {"identifier": "testMissingData", "parameters": "()", "modifiers": "@Test /** * Test that when we encounter missing metrics we skip the entire row and read * all of the valid rows. */ public", "return": "void", "body": "@Test\n    /**\n     * Test that when we encounter missing metrics we skip the entire row and read\n     * all of the valid rows.\n     */\n    public void testMissingData() throws Exception {\n        MacroBaseConf conf = new MacroBaseConf();\n        conf.set(MacroBaseConf.CSV_INPUT_FILE, \"src/test/resources/data/missingdata.csv\");\n        conf.set(MacroBaseConf.ATTRIBUTES, Lists.newArrayList(\"a1\"));\n        conf.set(MacroBaseConf.METRICS, Lists.newArrayList(\"m1\",\"m2\"));\n\n        CSVIngester ingester = new CSVIngester(conf);\n        List<Datum> data = ingester.getStream().drain();\n\n        int count = 0;\n        for(Datum d : data) {\n            if (count == 3) {\n                assertEquals(5, d.metrics().getEntry(0), 0.0);\n            }\n            count++;\n        }\n\n        assertEquals(4, count);\n    }", "signature": "void testMissingData()", "full_signature": "@Test /** * Test that when we encounter missing metrics we skip the entire row and read * all of the valid rows. */ public void testMissingData()", "class_method_signature": "CSVIngesterTest.testMissingData()", "testcase": true, "constructor": false, "invocations": ["set", "set", "newArrayList", "set", "newArrayList", "drain", "getStream", "assertEquals", "getEntry", "metrics", "assertEquals"]}, "focal_class": {"identifier": "CSVIngester", "superclass": "extends DataIngester", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(CSVIngester.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(CSVIngester.class)", "var_name": "log"}, {"original_string": "private CSVParser csvParser;", "modifier": "private", "type": "CSVParser", "declarator": "csvParser", "var_name": "csvParser"}, {"original_string": "private Map<String, Integer> schema;", "modifier": "private", "type": "Map<String, Integer>", "declarator": "schema", "var_name": "schema"}, {"original_string": "private String filename;", "modifier": "private", "type": "String", "declarator": "filename", "var_name": "filename"}, {"original_string": "private MBStream<Datum> dataStream = new MBStream<>();", "modifier": "private", "type": "MBStream<Datum>", "declarator": "dataStream = new MBStream<>()", "var_name": "dataStream"}, {"original_string": "private boolean loaded = false;", "modifier": "private", "type": "boolean", "declarator": "loaded = false", "var_name": "loaded"}, {"original_string": "private int badRows = 0;", "modifier": "private", "type": "int", "declarator": "badRows = 0", "var_name": "badRows"}], "methods": [{"identifier": "CSVIngester", "parameters": "(MacroBaseConf conf)", "modifiers": "public", "return": "", "signature": " CSVIngester(MacroBaseConf conf)", "full_signature": "public  CSVIngester(MacroBaseConf conf)", "class_method_signature": "CSVIngester.CSVIngester(MacroBaseConf conf)", "testcase": false, "constructor": true}, {"identifier": "parseRecord", "parameters": "(CSVRecord record)", "modifiers": "private", "return": "Datum", "signature": "Datum parseRecord(CSVRecord record)", "full_signature": "private Datum parseRecord(CSVRecord record)", "class_method_signature": "CSVIngester.parseRecord(CSVRecord record)", "testcase": false, "constructor": false}, {"identifier": "getStream", "parameters": "()", "modifiers": "@Override public", "return": "MBStream<Datum>", "signature": "MBStream<Datum> getStream()", "full_signature": "@Override public MBStream<Datum> getStream()", "class_method_signature": "CSVIngester.getStream()", "testcase": false, "constructor": false}, {"identifier": "getRows", "parameters": "(String baseQuery,\n                          Map<String, String> preds,\n                          int limit,\n                          int offset)", "modifiers": "@Override public", "return": "RowSet", "signature": "RowSet getRows(String baseQuery,\n                          Map<String, String> preds,\n                          int limit,\n                          int offset)", "full_signature": "@Override public RowSet getRows(String baseQuery,\n                          Map<String, String> preds,\n                          int limit,\n                          int offset)", "class_method_signature": "CSVIngester.getRows(String baseQuery,\n                          Map<String, String> preds,\n                          int limit,\n                          int offset)", "testcase": false, "constructor": false}, {"identifier": "includeRow", "parameters": "(CSVRecord record, Map<String, String> preds)", "modifiers": "private", "return": "boolean", "signature": "boolean includeRow(CSVRecord record, Map<String, String> preds)", "full_signature": "private boolean includeRow(CSVRecord record, Map<String, String> preds)", "class_method_signature": "CSVIngester.includeRow(CSVRecord record, Map<String, String> preds)", "testcase": false, "constructor": false}], "file": "legacy/src/main/java/macrobase/ingest/CSVIngester.java"}, "focal_method": {"identifier": "getStream", "parameters": "()", "modifiers": "@Override public", "return": "MBStream<Datum>", "body": "@Override\n    public MBStream<Datum> getStream() throws Exception {\n        if(!loaded) {\n            long st = System.currentTimeMillis();\n\n            filename = conf.getString(MacroBaseConf.CSV_INPUT_FILE);\n            Compression compression = conf.getCsvCompression();\n\n            if (compression == Compression.GZIP) {\n                InputStream fileStream = new FileInputStream(filename);\n                InputStream gzipStream = new GZIPInputStream(fileStream);\n                Reader decoder = new InputStreamReader(gzipStream);\n                csvParser = new CSVParser(decoder, CSVFormat.DEFAULT.withHeader());\n            } else {\n                File csvFile = new File(conf.getString(MacroBaseConf.CSV_INPUT_FILE));\n                csvParser = CSVParser.parse(csvFile, Charset.defaultCharset(), CSVFormat.DEFAULT.withHeader());\n            }\n            schema = csvParser.getHeaderMap(); //equal to resultSet.getmetadata or smt\n\n            for (Map.Entry<String, Integer> se : schema.entrySet()) {\n                conf.getEncoder().recordAttributeName(se.getValue() + 1, se.getKey()); //numbering off each column for encoding\n            }\n\n            // Load all records into memory to filter out rows with missing data\n            Iterator<CSVRecord> rawIterator = csvParser.iterator();\n\n            int numRows = 0;\n            while (rawIterator.hasNext()) {\n                try {\n                    CSVRecord record = rawIterator.next();\n                    Datum curRow = parseRecord(record);\n                    dataStream.add(curRow);\n                    numRows++;\n                } catch (NumberFormatException e) {\n                    badRows++;\n                }\n            }\n            log.info(\"{}/{} rows successfully parsed ({} malformed rows)\", numRows, numRows + badRows, badRows);\n        }\n\n        return dataStream;\n    }", "signature": "MBStream<Datum> getStream()", "full_signature": "@Override public MBStream<Datum> getStream()", "class_method_signature": "CSVIngester.getStream()", "testcase": false, "constructor": false, "invocations": ["currentTimeMillis", "getString", "getCsvCompression", "withHeader", "getString", "parse", "defaultCharset", "withHeader", "getHeaderMap", "entrySet", "recordAttributeName", "getEncoder", "getValue", "getKey", "iterator", "hasNext", "next", "parseRecord", "add", "info"]}, "repository": {"repo_id": 48199522, "url": "https://github.com/stanford-futuredata/macrobase", "language": "Java", "is_fork": false, "fork_count": 116, "stargazer_count": 606, "size": 27614, "license": "licensed"}}