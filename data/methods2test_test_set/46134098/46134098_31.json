{"test_class": {"identifier": "XLIFFResourceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final File INPUT_FILE = new File(\"src/test/resource/resfilter/xliff/input.xlf\");", "modifier": "private static final", "type": "File", "declarator": "INPUT_FILE = new File(\"src/test/resource/resfilter/xliff/input.xlf\")", "var_name": "INPUT_FILE"}, {"original_string": "private static final File EXPECTED_WRITE_FILE = new File(\"src/test/resource/resfilter/xliff/write-output.xlf\");", "modifier": "private static final", "type": "File", "declarator": "EXPECTED_WRITE_FILE = new File(\"src/test/resource/resfilter/xliff/write-output.xlf\")", "var_name": "EXPECTED_WRITE_FILE"}, {"original_string": "private static final File MERGE_INPUT_1_FILE = new File(\"src/test/resource/resfilter/xliff/merge-input-1.xlf\");", "modifier": "private static final", "type": "File", "declarator": "MERGE_INPUT_1_FILE = new File(\"src/test/resource/resfilter/xliff/merge-input-1.xlf\")", "var_name": "MERGE_INPUT_1_FILE"}, {"original_string": "private static final File MERGE_INPUT_2_FILE = new File(\"src/test/resource/resfilter/xliff/merge-input-2.xlf\");", "modifier": "private static final", "type": "File", "declarator": "MERGE_INPUT_2_FILE = new File(\"src/test/resource/resfilter/xliff/merge-input-2.xlf\")", "var_name": "MERGE_INPUT_2_FILE"}, {"original_string": "@SuppressWarnings(\"unused\")\n    private static final File EXPECTED_MERGE_1_FILE = new File(\"src/test/resource/resfilter/xliff/merge-output-1.xlf\");", "modifier": "@SuppressWarnings(\"unused\")\n    private static final", "type": "File", "declarator": "EXPECTED_MERGE_1_FILE = new File(\"src/test/resource/resfilter/xliff/merge-output-1.xlf\")", "var_name": "EXPECTED_MERGE_1_FILE"}, {"original_string": "@SuppressWarnings(\"unused\")\n    private static final File EXPECTED_MERGE_2_FILE = new File(\"src/test/resource/resfilter/xliff/merge-output-2.xlf\");", "modifier": "@SuppressWarnings(\"unused\")\n    private static final", "type": "File", "declarator": "EXPECTED_MERGE_2_FILE = new File(\"src/test/resource/resfilter/xliff/merge-output-2.xlf\")", "var_name": "EXPECTED_MERGE_2_FILE"}, {"original_string": "private static final Collection<ResourceString> EXPECTED_INPUT_RES_LIST;", "modifier": "private static final", "type": "Collection<ResourceString>", "declarator": "EXPECTED_INPUT_RES_LIST", "var_name": "EXPECTED_INPUT_RES_LIST"}, {"original_string": "private static LanguageBundle WRITE_BUNDLE;", "modifier": "private static", "type": "LanguageBundle", "declarator": "WRITE_BUNDLE", "var_name": "WRITE_BUNDLE"}, {"original_string": "private static LanguageBundle MERGE_BUNDLE;", "modifier": "private static", "type": "LanguageBundle", "declarator": "MERGE_BUNDLE", "var_name": "MERGE_BUNDLE"}, {"original_string": "private static final XLIFFResource res = new XLIFFResource();", "modifier": "private static final", "type": "XLIFFResource", "declarator": "res = new XLIFFResource()", "var_name": "res"}], "file": "gp-res-filter/src/test/java/com/ibm/g11n/pipeline/resfilter/impl/XLIFFResourceTest.java"}, "test_case": {"identifier": "testMerge", "parameters": "()", "modifiers": "@SuppressWarnings(\"deprecation\") @Test public", "return": "void", "body": "@SuppressWarnings(\"deprecation\")\n    @Test\n    public void testMerge() throws IOException, ResourceFilterException {\n        File tempFile;\n\n        tempFile = File.createTempFile(this.getClass().getSimpleName(), \".xlf\");\n        tempFile.deleteOnExit();\n\n        try (OutputStream os = new FileOutputStream(tempFile);\n                InputStream is = new FileInputStream(MERGE_INPUT_1_FILE)) {\n            res.merge(is, os, MERGE_BUNDLE, new FilterOptions(Locale.ENGLISH));\n            os.flush();\n            // TODO: Not ready yet\n            // assertTrue(ResourceTestUtil.compareFiles(EXPECTED_MERGE_1_FILE,\n            // tempFile));\n        }\n\n        tempFile = File.createTempFile(this.getClass().getSimpleName(), \".xlf\");\n        tempFile.deleteOnExit();\n\n        try (OutputStream os = new FileOutputStream(tempFile);\n                InputStream is = new FileInputStream(MERGE_INPUT_2_FILE)) {\n            res.merge(is, os, MERGE_BUNDLE, new FilterOptions(Locale.JAPANESE));\n            os.flush();\n            // TODO: Not ready yet\n            // assertTrue(ResourceTestUtil.compareFiles(EXPECTED_MERGE_2_FILE,\n            // tempFile));\n        }\n    }", "signature": "void testMerge()", "full_signature": "@SuppressWarnings(\"deprecation\") @Test public void testMerge()", "class_method_signature": "XLIFFResourceTest.testMerge()", "testcase": true, "constructor": false, "invocations": ["createTempFile", "getSimpleName", "getClass", "deleteOnExit", "merge", "flush", "createTempFile", "getSimpleName", "getClass", "deleteOnExit", "merge", "flush"]}, "focal_class": {"identifier": "XLIFFResource", "superclass": "extends ResourceFilter", "interfaces": "", "fields": [{"original_string": "private static final String VERSION_STRING = \"version\";", "modifier": "private static final", "type": "String", "declarator": "VERSION_STRING = \"version\"", "var_name": "VERSION_STRING"}, {"original_string": "private static final String VERSION_NUMBER_STRING = \"1.2\";", "modifier": "private static final", "type": "String", "declarator": "VERSION_NUMBER_STRING = \"1.2\"", "var_name": "VERSION_NUMBER_STRING"}, {"original_string": "private static final String XMLNS_STRING = \"xmlns:xsi\";", "modifier": "private static final", "type": "String", "declarator": "XMLNS_STRING = \"xmlns:xsi\"", "var_name": "XMLNS_STRING"}, {"original_string": "private static final String XMLNS_VALUE_STRING = \"http://www.w3.org/2001/XMLSchema-instance\";", "modifier": "private static final", "type": "String", "declarator": "XMLNS_VALUE_STRING = \"http://www.w3.org/2001/XMLSchema-instance\"", "var_name": "XMLNS_VALUE_STRING"}, {"original_string": "private static final String XSI_STRING = \"xsi:schemaLocation\";", "modifier": "private static final", "type": "String", "declarator": "XSI_STRING = \"xsi:schemaLocation\"", "var_name": "XSI_STRING"}, {"original_string": "private static final String XSI_VALUE_STRING = \"urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-strict.xsd\";", "modifier": "private static final", "type": "String", "declarator": "XSI_VALUE_STRING = \"urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-strict.xsd\"", "var_name": "XSI_VALUE_STRING"}, {"original_string": "private static final String UNIT_STRING = \"trans-unit\";", "modifier": "private static final", "type": "String", "declarator": "UNIT_STRING = \"trans-unit\"", "var_name": "UNIT_STRING"}, {"original_string": "private static final String ID_STRING = \"id\";", "modifier": "private static final", "type": "String", "declarator": "ID_STRING = \"id\"", "var_name": "ID_STRING"}, {"original_string": "private static final String SOURCE_STRING = \"source\";", "modifier": "private static final", "type": "String", "declarator": "SOURCE_STRING = \"source\"", "var_name": "SOURCE_STRING"}, {"original_string": "private static final String TARGET_STRING = \"target\";", "modifier": "private static final", "type": "String", "declarator": "TARGET_STRING = \"target\"", "var_name": "TARGET_STRING"}, {"original_string": "private static final String XLIFF_STRING = \"xliff\";", "modifier": "private static final", "type": "String", "declarator": "XLIFF_STRING = \"xliff\"", "var_name": "XLIFF_STRING"}, {"original_string": "private static final String FILE_STRING = \"file\";", "modifier": "private static final", "type": "String", "declarator": "FILE_STRING = \"file\"", "var_name": "FILE_STRING"}, {"original_string": "private static final String ORIGINAL_STRING = \"original\";", "modifier": "private static final", "type": "String", "declarator": "ORIGINAL_STRING = \"original\"", "var_name": "ORIGINAL_STRING"}, {"original_string": "private static final String GLOBAL_STRING = \"g11n-pipeline\";", "modifier": "private static final", "type": "String", "declarator": "GLOBAL_STRING = \"g11n-pipeline\"", "var_name": "GLOBAL_STRING"}, {"original_string": "private static final String DATATYPE_STRING = \"datatype\";", "modifier": "private static final", "type": "String", "declarator": "DATATYPE_STRING = \"datatype\"", "var_name": "DATATYPE_STRING"}, {"original_string": "private static final String PLAINTEXT_STRING = \"plaintext\";", "modifier": "private static final", "type": "String", "declarator": "PLAINTEXT_STRING = \"plaintext\"", "var_name": "PLAINTEXT_STRING"}, {"original_string": "private static final String SOURCE_LANGUAGE_STRING = \"source-language\";", "modifier": "private static final", "type": "String", "declarator": "SOURCE_LANGUAGE_STRING = \"source-language\"", "var_name": "SOURCE_LANGUAGE_STRING"}, {"original_string": "private static final String ENGLISH = \"en\";", "modifier": "private static final", "type": "String", "declarator": "ENGLISH = \"en\"", "var_name": "ENGLISH"}, {"original_string": "private static final String TARGET_LANGUAGE_STRING = \"target-language\";", "modifier": "private static final", "type": "String", "declarator": "TARGET_LANGUAGE_STRING = \"target-language\"", "var_name": "TARGET_LANGUAGE_STRING"}, {"original_string": "private static final String BODY_STRING = \"body\";", "modifier": "private static final", "type": "String", "declarator": "BODY_STRING = \"body\"", "var_name": "BODY_STRING"}], "methods": [{"identifier": "parse", "parameters": "(InputStream inStream, FilterOptions options)", "modifiers": "@Override public", "return": "LanguageBundle", "signature": "LanguageBundle parse(InputStream inStream, FilterOptions options)", "full_signature": "@Override public LanguageBundle parse(InputStream inStream, FilterOptions options)", "class_method_signature": "XLIFFResource.parse(InputStream inStream, FilterOptions options)", "testcase": false, "constructor": false}, {"identifier": "collectResourceStrings", "parameters": "(NodeList nodeList, LanguageBundleBuilder bb, int version, String key)", "modifiers": "private", "return": "void", "signature": "void collectResourceStrings(NodeList nodeList, LanguageBundleBuilder bb, int version, String key)", "full_signature": "private void collectResourceStrings(NodeList nodeList, LanguageBundleBuilder bb, int version, String key)", "class_method_signature": "XLIFFResource.collectResourceStrings(NodeList nodeList, LanguageBundleBuilder bb, int version, String key)", "testcase": false, "constructor": false}, {"identifier": "write", "parameters": "(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "modifiers": "@Override public", "return": "void", "signature": "void write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "full_signature": "@Override public void write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "class_method_signature": "XLIFFResource.write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "testcase": false, "constructor": false}, {"identifier": "merge", "parameters": "(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "modifiers": "@Override @Deprecated /* * This method is incomplete and may not produce the expected output. * * (non-Javadoc) * @see com.ibm.g11n.pipeline.resfilter.ResourceFilter#merge(java.io.InputStream, java.io.OutputStream, java.lang.String, java.util.Collection) */ public", "return": "void", "signature": "void merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "full_signature": "@Override @Deprecated /* * This method is incomplete and may not produce the expected output. * * (non-Javadoc) * @see com.ibm.g11n.pipeline.resfilter.ResourceFilter#merge(java.io.InputStream, java.io.OutputStream, java.lang.String, java.util.Collection) */ public void merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "class_method_signature": "XLIFFResource.merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "testcase": false, "constructor": false}], "file": "gp-res-filter/src/main/java/com/ibm/g11n/pipeline/resfilter/impl/XLIFFResource.java"}, "focal_method": {"identifier": "merge", "parameters": "(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "modifiers": "@Override @Deprecated /* * This method is incomplete and may not produce the expected output. * * (non-Javadoc) * @see com.ibm.g11n.pipeline.resfilter.ResourceFilter#merge(java.io.InputStream, java.io.OutputStream, java.lang.String, java.util.Collection) */ public", "return": "void", "body": "@Override\n    @Deprecated\n    /*\n     * This method is incomplete and may not produce the expected output.\n     *\n     * (non-Javadoc)\n     * @see com.ibm.g11n.pipeline.resfilter.ResourceFilter#merge(java.io.InputStream, java.io.OutputStream, java.lang.String, java.util.Collection)\n     */\n    public void merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options) throws IOException, ResourceFilterException {\n\n        String targetLanguage = languageBundle.getEmbeddedLanguageCode();\n        if (targetLanguage == null || targetLanguage.isEmpty()) {\n            throw new ResourceFilterException(\"Target language is not specified.\");\n        }\n\n        Map<String, String> kvMap = Utils.createKeyValueMap(languageBundle.getResourceStrings());\n\n        // TODO: We should use xml encoding declaration, instead of hardcoding\n        // \"UTF-8\"\n        Scanner in = new Scanner(baseStream, \"UTF-8\");\n        String line = \"\";\n        String key_pattern = \"^.*<unit.*id=\\\".*\\\">\\n$\";\n        String end_source_pattern = \".*</source>\\n$\";\n        while (in.hasNextLine()) {\n            line = in.nextLine() + '\\n';\n            if (!line.matches(key_pattern)) {\n                if (line.indexOf(\"<xliff\") != -1) {\n                    StringBuilder newline = new StringBuilder(100);\n                    newline.append(\"<xliff version=\\\"2.0\\\" srcLang=\\\"en\\\" targLang=\\\"\").append(targetLanguage).append(\"\\\">\");\n                    line = newline.toString();\n                }\n                outStream.write(line.getBytes());\n            } else {\n                String[] wordList = line.split(\"\\\"\");\n                String key = wordList[1];\n\n                // +2 for source and source block\n                String whiteSpace = line.substring(0, line.indexOf(\"<\")) + \"  \";\n\n                // writes key line\n                while (!line.matches(end_source_pattern)) {\n                    outStream.write(line.getBytes());\n                    line = in.nextLine() + '\\n';\n                }\n\n                outStream.write(line.getBytes());\n                // TODO: Instead of linear search resource key every time,\n                // we may create hash map first.\n\n                if (kvMap.containsKey(key)) {\n                    String value = kvMap.get(key);\n                    final int character_offset = 80;\n\n                    BreakIterator b = BreakIterator.getWordInstance();\n                    b.setText(value);\n\n                    int offset = 80;\n                    int start = 0;\n\n                    boolean first = true;\n\n                    StringBuilder temp = new StringBuilder(100);\n                    temp.append(whiteSpace).append(\"<target>\");\n                    while (start < value.length()) {\n                        if (value.length() > character_offset) {\n\n                            if (!first) {\n                                temp.append(whiteSpace).append(\" \");\n                            }\n\n                            first = false;\n                            int end = b.following(offset);\n                            String str = value.substring(start, end);\n                            start = end;\n                            offset += 80;\n                            temp.append(str).append(\" \\\\\\n\");\n                        } else {\n                            temp.append(value);\n                            start = value.length();\n                        }\n                    }\n\n                    if (value.length() > character_offset) {\n                        temp.append(whiteSpace);\n                    }\n\n                    temp.append(\"</target>\\n\");\n                    outStream.write(temp.toString().getBytes());\n                } else {\n                    outStream.write(line.getBytes());\n                }\n\n            }\n        }\n        in.close();\n    }", "signature": "void merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "full_signature": "@Override @Deprecated /* * This method is incomplete and may not produce the expected output. * * (non-Javadoc) * @see com.ibm.g11n.pipeline.resfilter.ResourceFilter#merge(java.io.InputStream, java.io.OutputStream, java.lang.String, java.util.Collection) */ public void merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "class_method_signature": "XLIFFResource.merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options)", "testcase": false, "constructor": false, "invocations": ["getEmbeddedLanguageCode", "isEmpty", "createKeyValueMap", "getResourceStrings", "hasNextLine", "nextLine", "matches", "indexOf", "append", "append", "append", "toString", "write", "getBytes", "split", "substring", "indexOf", "matches", "write", "getBytes", "nextLine", "write", "getBytes", "containsKey", "get", "getWordInstance", "setText", "append", "append", "length", "length", "append", "append", "following", "substring", "append", "append", "append", "length", "length", "append", "append", "write", "getBytes", "toString", "write", "getBytes", "close"]}, "repository": {"repo_id": 46134098, "url": "https://github.com/IBM-Cloud/gp-java-tools", "language": "Java", "is_fork": false, "fork_count": 16, "stargazer_count": 9, "size": 6216, "license": "licensed"}}