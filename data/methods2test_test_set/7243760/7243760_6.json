{"test_class": {"identifier": "BarBuilderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final ValueFactory FACTORY = ValueFactoryImpl.getInstance();", "modifier": "private static final", "type": "ValueFactory", "declarator": "FACTORY = ValueFactoryImpl.getInstance()", "var_name": "FACTORY"}], "file": "series/src/test/java/com/barchart/feed/series/analytics/BarBuilderTest.java"}, "test_case": {"identifier": "testSecondsToMinutes", "parameters": "()", "modifiers": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) @Test public", "return": "void", "body": "@SuppressWarnings({\n\t\t\t\"unchecked\", \"rawtypes\"\n\t})\n\t@Test\n\tpublic void testSecondsToMinutes() {\n\t\tString symbol = \"ESZ13\";\n\t\tInstrument instr = TestHarness.makeInstrument(symbol);\n\t\tDateTime dt2 = new DateTime(2013, 12, 10, 12, 0, 0);\n\t\tTimeFrameImpl tf2 = new TimeFrameImpl(new Period(PeriodType.MINUTE, 1), dt2, null);\n\n\t\tSeriesSubscription sub2 = new SeriesSubscription(\n\t\t\t\"ESZ13\", instr, \"IO\", new TimeFrameImpl[] { tf2 }, TradingWeekImpl.DEFAULT);\n\n\t\tBarBuilder barBuilder = new BarBuilder(sub2);\n\t\tbarBuilder.addInputTimeSeries(BarBuilder.INPUT_KEY, new DataSeriesImpl<BarImpl>(new Period(PeriodType.SECOND, 1)));\n\t\tDataSeriesImpl<BarImpl> inputSeries =\n\t\t\t(DataSeriesImpl) barBuilder.getInputTimeSeries(BarBuilder.INPUT_KEY);\n\t\tassertNotNull(inputSeries);\n\n\t\tbarBuilder.addOutputTimeSeries(BarBuilder.OUTPUT_KEY, new DataSeriesImpl<BarImpl>(new Period(PeriodType.MINUTE, 1)));\n\t\tDataSeriesImpl<BarImpl> outputSeries =\n\t\t\t(DataSeriesImpl) barBuilder.getOutputTimeSeries(BarBuilder.OUTPUT_KEY);\n\t\tassertNotNull(outputSeries);\n\t\tassertEquals(new Period(PeriodType.MINUTE, 1), outputSeries.getPeriod());\n\n\t\tList<BarImpl> list = getBars3();\n\t\tSpanImpl span = new SpanImpl(new Period(PeriodType.SECOND, 1),\n\t\t\tnew DateTime(2013, 12, 10, 12, 0, 0),\n\t\t\t\tnew DateTime(2013, 12, 10, 12, 0, 0));\n\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tinputSeries.add(list.get(i));\n\t\t}\n\n\t\tspan.setNextDate(inputSeries.get(inputSeries.size() - 1).getDate());\n\n\t\tbarBuilder.process(span);\n\n\t\tassertEquals(6, outputSeries.size());\n\n\t\tlist = getBars4();\n\t\tfor (BarImpl db : list) {\n\t\t\tinputSeries.add(db);\n\t\t\tspan.setDate(db.getDate());\n\t\t\tspan.setNextDate(db.getDate());\n\t\t\tbarBuilder.process(span);\n\t\t}\n\n\t\tassertEquals(12, outputSeries.size());\n\t\tSystem.out.println(\"output series size: \" + outputSeries.size());\n\t}", "signature": "void testSecondsToMinutes()", "full_signature": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) @Test public void testSecondsToMinutes()", "class_method_signature": "BarBuilderTest.testSecondsToMinutes()", "testcase": true, "constructor": false, "invocations": ["makeInstrument", "addInputTimeSeries", "getInputTimeSeries", "assertNotNull", "addOutputTimeSeries", "getOutputTimeSeries", "assertNotNull", "assertEquals", "getPeriod", "getBars3", "size", "add", "get", "setNextDate", "getDate", "get", "size", "process", "assertEquals", "size", "getBars4", "add", "setDate", "getDate", "setNextDate", "getDate", "process", "assertEquals", "size", "println", "size"]}, "focal_class": {"identifier": "BarBuilder", "superclass": "extends AnalyticBase", "interfaces": "", "fields": [{"original_string": "public static final String NAME = \"BarBuilder\";", "modifier": "public static final", "type": "String", "declarator": "NAME = \"BarBuilder\"", "var_name": "NAME"}, {"original_string": "public static final String INPUT_KEY = \"Input\";", "modifier": "public static final", "type": "String", "declarator": "INPUT_KEY = \"Input\"", "var_name": "INPUT_KEY"}, {"original_string": "public static final String OUTPUT_KEY = \"Output\";", "modifier": "public static final", "type": "String", "declarator": "OUTPUT_KEY = \"Output\"", "var_name": "OUTPUT_KEY"}, {"original_string": "private static String[] inputs = new String[] { INPUT_KEY };", "modifier": "private static", "type": "String[]", "declarator": "inputs = new String[] { INPUT_KEY }", "var_name": "inputs"}, {"original_string": "private static String[] outputs = new String[] { OUTPUT_KEY };", "modifier": "private static", "type": "String[]", "declarator": "outputs = new String[] { OUTPUT_KEY }", "var_name": "outputs"}, {"original_string": "private BarImpl currentMergeBar;", "modifier": "private", "type": "BarImpl", "declarator": "currentMergeBar", "var_name": "currentMergeBar"}, {"original_string": "private SpanImpl inputSpan;", "modifier": "private", "type": "SpanImpl", "declarator": "inputSpan", "var_name": "inputSpan"}, {"original_string": "private SpanImpl workingSpan;", "modifier": "private", "type": "SpanImpl", "declarator": "workingSpan", "var_name": "workingSpan"}, {"original_string": "private DateTime workingTargetDate;", "modifier": "private", "type": "DateTime", "declarator": "workingTargetDate", "var_name": "workingTargetDate"}, {"original_string": "private SeriesSubscription subscription;", "modifier": "private", "type": "SeriesSubscription", "declarator": "subscription", "var_name": "subscription"}], "methods": [{"identifier": "BarBuilder", "parameters": "(SeriesSubscription s)", "modifiers": "", "return": "", "signature": " BarBuilder(SeriesSubscription s)", "full_signature": "  BarBuilder(SeriesSubscription s)", "class_method_signature": "BarBuilder.BarBuilder(SeriesSubscription s)", "testcase": false, "constructor": true}, {"identifier": "getSubscription", "parameters": "()", "modifiers": "public", "return": "SeriesSubscription", "signature": "SeriesSubscription getSubscription()", "full_signature": "public SeriesSubscription getSubscription()", "class_method_signature": "BarBuilder.getSubscription()", "testcase": false, "constructor": false}, {"identifier": "process", "parameters": "(Span span)", "modifiers": "@SuppressWarnings(value = { \"unchecked\", \"rawtypes\" }) @Override public", "return": "Span", "signature": "Span process(Span span)", "full_signature": "@SuppressWarnings(value = { \"unchecked\", \"rawtypes\" }) @Override public Span process(Span span)", "class_method_signature": "BarBuilder.process(Span span)", "testcase": false, "constructor": false}, {"identifier": "getInputKeys", "parameters": "()", "modifiers": "public static", "return": "String[]", "signature": "String[] getInputKeys()", "full_signature": "public static String[] getInputKeys()", "class_method_signature": "BarBuilder.getInputKeys()", "testcase": false, "constructor": false}, {"identifier": "getOutputKeys", "parameters": "()", "modifiers": "public static", "return": "String[]", "signature": "String[] getOutputKeys()", "full_signature": "public static String[] getOutputKeys()", "class_method_signature": "BarBuilder.getOutputKeys()", "testcase": false, "constructor": false}], "file": "series/src/main/java/com/barchart/feed/series/analytics/BarBuilder.java"}, "focal_method": {"identifier": "process", "parameters": "(Span span)", "modifiers": "@SuppressWarnings(value = { \"unchecked\", \"rawtypes\" }) @Override public", "return": "Span", "body": "@SuppressWarnings(value = { \"unchecked\", \"rawtypes\" })\n\t@Override\n\tpublic Span process(Span span) {\n\t    //System.out.println(this + \" processing span: \" + span);\n\t\tthis.inputSpan = (SpanImpl)span;\n\n\t\tDataSeriesImpl<DataPointImpl> outputSeries = (DataSeriesImpl)getOutputTimeSeries(BarBuilder.OUTPUT_KEY);\n\t\tDataSeriesImpl<DataPointImpl> inputSeries = (DataSeriesImpl)getInputTimeSeries(BarBuilder.INPUT_KEY);\n\t\tint inputStartIdx = inputSeries.indexOf(inputSpan.getDate(), false);\n\t\tint inputLastIdx = inputSeries.indexOf(inputSpan.getNextDate(), false);\n\n\t\tPeriod inputPeriod = inputSeries.getPeriod();\n        Period outputPeriod = outputSeries.getPeriod();\n\n        boolean barCompleted = false;\n\n        if(inputPeriod.equals(outputPeriod)) {\n\t\t    for(int i = inputStartIdx;i <= inputLastIdx;i++) {\n\t\t        outputSeries.insertData(inputSeries.get(i));\n\t\t    }\n\t\t    return new SpanImpl(inputSpan);\n\t\t}else{\n\t\t\tif(inputPeriod.size() > 1) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Can't build bars from Type with an Interval that's not 1. Input=\" +\n\t\t\t\t\t\tinputPeriod + \", output=\" + outputPeriod);\n\t\t\t}\n\n\t\t\tif(subscription.getTimeFrame(0).getPeriod().equals(new Period(PeriodType.SECOND, 1))) {\n\t\t\t    System.out.println(\"debug\");\n\t\t\t}\n\n\t\t\tboolean wasAddedDuringInit = false;\n\t\t\tif(currentMergeBar == null) {\n\t\t\t    wasAddedDuringInit = true;\n\t\t\t\tcurrentMergeBar = new BarImpl((BarImpl)inputSeries.get(inputStartIdx));\n\t\t\t\tworkingTargetDate = subscription.getTradingWeek().getNextSessionDate(inputSpan.getDate(), outputPeriod);\n\t\t\t\tcurrentMergeBar.setDate(workingTargetDate);\n\t\t\t\tworkingSpan = new SpanImpl(subscription.getTimeFrame(0).getPeriod(), inputSpan.getDate(), inputSpan.getNextDate());\n\t\t\t\tthis.workingSpan.setNextDate(workingTargetDate);\n\t\t\t\tSystem.out.println(\"IS INIT: ADDING NEW BAR \" + currentMergeBar + \"   \" + outputSeries.getPeriod() + \"  :  span = \" + this.workingSpan);\n\t\t\t\toutputSeries.add(currentMergeBar);\n\t\t\t}else{\n\t\t\t\tworkingSpan.setDate(workingTargetDate);\n\t\t\t}\n\n\t\t\tfor(int i = wasAddedDuringInit ? inputStartIdx + 1 : inputStartIdx;i <= inputLastIdx;i++) {\n\t\t\t\tBarImpl currentIdxBar = (BarImpl)inputSeries.get(i);\n\t\t\t\tif(currentIdxBar.getDate().isAfter(workingTargetDate)) {\n\t\t\t\t\tworkingTargetDate = subscription.getTradingWeek().getNextSessionDate(workingTargetDate, outputPeriod);\n\t\t\t\t\tcurrentMergeBar = new BarImpl(currentIdxBar);\n\t\t\t\t\tcurrentMergeBar.setDate(workingTargetDate);\n\t\t\t\t\tthis.workingSpan.setNextDate(workingTargetDate);\n\t\t\t\t\tSystem.out.println(\"IS AFTER: ADDING NEW BAR \" + currentMergeBar + \"   \" + outputSeries.getPeriod() + \"  :  span = \" + this.workingSpan);\n\t\t\t\t\toutputSeries.add(currentMergeBar);\n\t\t\t\t\tbarCompleted = true;\n\t\t\t\t}else{\n\t\t\t\t    currentMergeBar.merge(currentIdxBar, false);\n\t\t\t\t    if(workingSpan.getPeriod().equals(new Period(PeriodType.SECOND, 1))) {\n\t\t\t\t        System.out.println(\"\\tNOT IS AFTER: MERGING NEW BAR \" + currentMergeBar + \"   \" + outputSeries.getPeriod() + \"  :  span = \" + this.workingSpan);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Notify of change\n\t\t\tvalueUpdated();\n\t\t}\n\n\t\treturn barCompleted ? workingSpan : null;\n\t}", "signature": "Span process(Span span)", "full_signature": "@SuppressWarnings(value = { \"unchecked\", \"rawtypes\" }) @Override public Span process(Span span)", "class_method_signature": "BarBuilder.process(Span span)", "testcase": false, "constructor": false, "invocations": ["getOutputTimeSeries", "getInputTimeSeries", "indexOf", "getDate", "indexOf", "getNextDate", "getPeriod", "getPeriod", "equals", "insertData", "get", "size", "equals", "getPeriod", "getTimeFrame", "println", "get", "getNextSessionDate", "getTradingWeek", "getDate", "setDate", "getPeriod", "getTimeFrame", "getDate", "getNextDate", "setNextDate", "println", "getPeriod", "add", "setDate", "get", "isAfter", "getDate", "getNextSessionDate", "getTradingWeek", "setDate", "setNextDate", "println", "getPeriod", "add", "merge", "equals", "getPeriod", "println", "getPeriod", "valueUpdated"]}, "repository": {"repo_id": 7243760, "url": "https://github.com/barchart/barchart-feed", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 6, "size": 64172, "license": "licensed"}}