{"test_class": {"identifier": "PcapNetworkInterfaceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(PcapNetworkInterfaceTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(PcapNetworkInterfaceTest.class)", "var_name": "logger"}], "file": "pcap4j-core/src/test/java/org/pcap4j/core/PcapNetworkInterfaceTest.java"}, "test_case": {"identifier": "testOpenLive", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testOpenLive() throws Exception {\n    PcapHandle handle;\n    try {\n      handle = Pcaps.findAllDevs().get(0).openLive(55555, PromiscuousMode.PROMISCUOUS, 100);\n    } catch (IndexOutOfBoundsException e) {\n      return;\n    } catch (PcapNativeException e) {\n      assertTrue(\n          \"The exception should complain about permission to capture.\",\n          e.getMessage().contains(\"You don't have permission to capture on that device\"));\n      return;\n    }\n\n    assertNotNull(handle);\n    assertTrue(handle.isOpen());\n\n    logger.info(handle.toString());\n  }", "signature": "void testOpenLive()", "full_signature": "@Test public void testOpenLive()", "class_method_signature": "PcapNetworkInterfaceTest.testOpenLive()", "testcase": true, "constructor": false, "invocations": ["openLive", "get", "findAllDevs", "assertTrue", "contains", "getMessage", "assertNotNull", "assertTrue", "isOpen", "info", "toString"]}, "focal_class": {"identifier": "PcapNetworkInterface", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(PcapNetworkInterface.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(PcapNetworkInterface.class)", "var_name": "logger"}, {"original_string": "private static final int PCAP_IF_LOOPBACK = 0x00000001;", "modifier": "private static final", "type": "int", "declarator": "PCAP_IF_LOOPBACK = 0x00000001", "var_name": "PCAP_IF_LOOPBACK"}, {"original_string": "private static final int PCAP_IF_UP = 0x00000002;", "modifier": "private static final", "type": "int", "declarator": "PCAP_IF_UP = 0x00000002", "var_name": "PCAP_IF_UP"}, {"original_string": "private static final int PCAP_IF_RUNNING = 0x00000004;", "modifier": "private static final", "type": "int", "declarator": "PCAP_IF_RUNNING = 0x00000004", "var_name": "PCAP_IF_RUNNING"}, {"original_string": "private final String name;", "modifier": "private final", "type": "String", "declarator": "name", "var_name": "name"}, {"original_string": "private final String description;", "modifier": "private final", "type": "String", "declarator": "description", "var_name": "description"}, {"original_string": "private final List<PcapAddress> addresses = new ArrayList<PcapAddress>();", "modifier": "private final", "type": "List<PcapAddress>", "declarator": "addresses = new ArrayList<PcapAddress>()", "var_name": "addresses"}, {"original_string": "private final List<LinkLayerAddress> linkLayerAddresses = new ArrayList<LinkLayerAddress>();", "modifier": "private final", "type": "List<LinkLayerAddress>", "declarator": "linkLayerAddresses = new ArrayList<LinkLayerAddress>()", "var_name": "linkLayerAddresses"}, {"original_string": "private final boolean loopBack;", "modifier": "private final", "type": "boolean", "declarator": "loopBack", "var_name": "loopBack"}, {"original_string": "private final boolean up;", "modifier": "private final", "type": "boolean", "declarator": "up", "var_name": "up"}, {"original_string": "private final boolean running;", "modifier": "private final", "type": "boolean", "declarator": "running", "var_name": "running"}, {"original_string": "private final boolean local;", "modifier": "private final", "type": "boolean", "declarator": "local", "var_name": "local"}], "methods": [{"identifier": "PcapNetworkInterface", "parameters": "(pcap_if pif, boolean local)", "modifiers": "private", "return": "", "signature": " PcapNetworkInterface(pcap_if pif, boolean local)", "full_signature": "private  PcapNetworkInterface(pcap_if pif, boolean local)", "class_method_signature": "PcapNetworkInterface.PcapNetworkInterface(pcap_if pif, boolean local)", "testcase": false, "constructor": true}, {"identifier": "newInstance", "parameters": "(pcap_if pif, boolean local)", "modifiers": "static", "return": "PcapNetworkInterface", "signature": "PcapNetworkInterface newInstance(pcap_if pif, boolean local)", "full_signature": "static PcapNetworkInterface newInstance(pcap_if pif, boolean local)", "class_method_signature": "PcapNetworkInterface.newInstance(pcap_if pif, boolean local)", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getName()", "full_signature": "public String getName()", "class_method_signature": "PcapNetworkInterface.getName()", "testcase": false, "constructor": false}, {"identifier": "getDescription", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getDescription()", "full_signature": "public String getDescription()", "class_method_signature": "PcapNetworkInterface.getDescription()", "testcase": false, "constructor": false}, {"identifier": "getAddresses", "parameters": "()", "modifiers": "public", "return": "List<PcapAddress>", "signature": "List<PcapAddress> getAddresses()", "full_signature": "public List<PcapAddress> getAddresses()", "class_method_signature": "PcapNetworkInterface.getAddresses()", "testcase": false, "constructor": false}, {"identifier": "getLinkLayerAddresses", "parameters": "()", "modifiers": "public", "return": "ArrayList<LinkLayerAddress>", "signature": "ArrayList<LinkLayerAddress> getLinkLayerAddresses()", "full_signature": "public ArrayList<LinkLayerAddress> getLinkLayerAddresses()", "class_method_signature": "PcapNetworkInterface.getLinkLayerAddresses()", "testcase": false, "constructor": false}, {"identifier": "isLoopBack", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isLoopBack()", "full_signature": "public boolean isLoopBack()", "class_method_signature": "PcapNetworkInterface.isLoopBack()", "testcase": false, "constructor": false}, {"identifier": "isUp", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isUp()", "full_signature": "public boolean isUp()", "class_method_signature": "PcapNetworkInterface.isUp()", "testcase": false, "constructor": false}, {"identifier": "isRunning", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isRunning()", "full_signature": "public boolean isRunning()", "class_method_signature": "PcapNetworkInterface.isRunning()", "testcase": false, "constructor": false}, {"identifier": "isLocal", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isLocal()", "full_signature": "public boolean isLocal()", "class_method_signature": "PcapNetworkInterface.isLocal()", "testcase": false, "constructor": false}, {"identifier": "openLive", "parameters": "(int snaplen, PromiscuousMode mode, int timeoutMillis)", "modifiers": "public", "return": "PcapHandle", "signature": "PcapHandle openLive(int snaplen, PromiscuousMode mode, int timeoutMillis)", "full_signature": "public PcapHandle openLive(int snaplen, PromiscuousMode mode, int timeoutMillis)", "class_method_signature": "PcapNetworkInterface.openLive(int snaplen, PromiscuousMode mode, int timeoutMillis)", "testcase": false, "constructor": false}, {"identifier": "getMacAddress", "parameters": "(String nifName)", "modifiers": "private", "return": "MacAddress", "signature": "MacAddress getMacAddress(String nifName)", "full_signature": "private MacAddress getMacAddress(String nifName)", "class_method_signature": "PcapNetworkInterface.getMacAddress(String nifName)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "PcapNetworkInterface.toString()", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "PcapNetworkInterface.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "PcapNetworkInterface.equals(Object obj)", "testcase": false, "constructor": false}], "file": "pcap4j-core/src/main/java/org/pcap4j/core/PcapNetworkInterface.java"}, "focal_method": {"identifier": "openLive", "parameters": "(int snaplen, PromiscuousMode mode, int timeoutMillis)", "modifiers": "public", "return": "PcapHandle", "body": "public PcapHandle openLive(int snaplen, PromiscuousMode mode, int timeoutMillis)\n      throws PcapNativeException {\n    if (mode == null) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"mode: \").append(mode);\n      throw new NullPointerException(sb.toString());\n    }\n\n    PcapErrbuf errbuf = new PcapErrbuf();\n    Pointer handle =\n        NativeMappings.pcap_open_live(name, snaplen, mode.getValue(), timeoutMillis, errbuf);\n    if (handle == null || errbuf.length() != 0) {\n      throw new PcapNativeException(errbuf.toString());\n    }\n\n    if (timeoutMillis == 0 && Platform.isSolaris()) {\n      // disable buffering\n      timeval to = new timeval();\n      to.tv_sec = new NativeLong(0);\n      to.tv_usec = new NativeLong(0);\n\n      int rc =\n          PcapLibrary.INSTANCE.strioctl(\n              NativeMappings.getFdFromPcapT(handle),\n              NativeMappings.SBIOCSTIME,\n              to.size(),\n              to.getPointer());\n\n      if (rc < 0) {\n        throw new PcapNativeException(\n            \"SBIOCSTIME: \"\n                + NativeMappings.pcap_strerror(NativeMappings.ERRNO_P.getInt(0)).getString(0));\n      }\n    }\n\n    return new PcapHandle(handle, TimestampPrecision.MICRO);\n  }", "signature": "PcapHandle openLive(int snaplen, PromiscuousMode mode, int timeoutMillis)", "full_signature": "public PcapHandle openLive(int snaplen, PromiscuousMode mode, int timeoutMillis)", "class_method_signature": "PcapNetworkInterface.openLive(int snaplen, PromiscuousMode mode, int timeoutMillis)", "testcase": false, "constructor": false, "invocations": ["append", "append", "toString", "pcap_open_live", "getValue", "length", "toString", "isSolaris", "strioctl", "getFdFromPcapT", "size", "getPointer", "getString", "pcap_strerror", "getInt"]}, "repository": {"repo_id": 3005042, "url": "https://github.com/kaitoy/pcap4j", "language": "Java", "is_fork": false, "fork_count": 247, "stargazer_count": 779, "size": 15246, "license": "licensed"}}