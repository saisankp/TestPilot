{"test_class": {"identifier": "InventoryReaderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@MockitoAnnotations.Mock\n    private DataBroker dataBroker;", "modifier": "@MockitoAnnotations.Mock\n    private", "type": "DataBroker", "declarator": "dataBroker", "var_name": "dataBroker"}, {"original_string": "private InventoryReader inventoryReader;", "modifier": "private", "type": "InventoryReader", "declarator": "inventoryReader", "var_name": "inventoryReader"}], "file": "arphandler/src/test/java/org/opendaylight/l2switch/arphandler/inventory/InventoryReaderTest.java"}, "test_case": {"identifier": "testGetNodeConnector", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGetNodeConnector() throws Exception {\n        List<Addresses> addressesList = new ArrayList<Addresses>();\n        addressesList.add(new AddressesBuilder().setLastSeen(0L).setMac(new MacAddress(\"aa:bb:cc:dd:ee:ff\")).build());\n        AddressCapableNodeConnector addressCapableNodeConnector = new AddressCapableNodeConnectorBuilder()\n                .setAddresses(addressesList).build();\n        StpStatusAwareNodeConnector stpStatusAwareNodeConnector = new StpStatusAwareNodeConnectorBuilder()\n                .setStatus(StpStatus.Forwarding).build();\n        NodeConnector nodeConnector = new NodeConnectorBuilder()\n                .addAugmentation(StpStatusAwareNodeConnector.class, stpStatusAwareNodeConnector)\n                .addAugmentation(AddressCapableNodeConnector.class, addressCapableNodeConnector).build();\n\n        List<NodeConnector> nodeConnectors = new ArrayList<NodeConnector>();\n        nodeConnectors.add(nodeConnector);\n        Node node = new NodeBuilder().setNodeConnector(nodeConnectors).build();\n        Optional<Node> optionalNode = Optional.of(node);\n\n        ReadOnlyTransaction readOnlyTransaction = Mockito.mock(ReadOnlyTransaction.class);\n        CheckedFuture checkedFuture = Mockito.mock(CheckedFuture.class);\n        when(checkedFuture.get()).thenReturn(optionalNode);\n        when(readOnlyTransaction.read(any(LogicalDatastoreType.class), any(InstanceIdentifier.class)))\n                .thenReturn(checkedFuture);\n        when(dataBroker.newReadOnlyTransaction()).thenReturn(readOnlyTransaction);\n\n        assertNotNull(\n                inventoryReader\n                        .getNodeConnector(\n                                InstanceIdentifier.builder(Nodes.class)\n                                        .child(Node.class, new NodeKey(new NodeId(\"openflow:1\"))).build(),\n                                new MacAddress(\"aa:bb:cc:dd:ee:ff\")));\n        verify(readOnlyTransaction, times(1)).close();\n    }", "signature": "void testGetNodeConnector()", "full_signature": "@Test public void testGetNodeConnector()", "class_method_signature": "InventoryReaderTest.testGetNodeConnector()", "testcase": true, "constructor": false, "invocations": ["add", "build", "setMac", "setLastSeen", "build", "setAddresses", "build", "setStatus", "build", "addAugmentation", "addAugmentation", "add", "build", "setNodeConnector", "of", "mock", "mock", "thenReturn", "when", "get", "thenReturn", "when", "read", "any", "any", "thenReturn", "when", "newReadOnlyTransaction", "assertNotNull", "getNodeConnector", "build", "child", "builder", "close", "verify", "times"]}, "focal_class": {"identifier": "InventoryReader", "superclass": "", "interfaces": "implements DataTreeChangeListener<DataObject>", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(InventoryReader.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(InventoryReader.class)", "var_name": "LOG"}, {"original_string": "private final DataBroker dataService;", "modifier": "private final", "type": "DataBroker", "declarator": "dataService", "var_name": "dataService"}, {"original_string": "private final HashMap<String, NodeConnectorRef> controllerSwitchConnectors;", "modifier": "private final", "type": "HashMap<String, NodeConnectorRef>", "declarator": "controllerSwitchConnectors", "var_name": "controllerSwitchConnectors"}, {"original_string": "private final HashMap<String, List<NodeConnectorRef>> switchNodeConnectors;", "modifier": "private final", "type": "HashMap<String, List<NodeConnectorRef>>", "declarator": "switchNodeConnectors", "var_name": "switchNodeConnectors"}, {"original_string": "private final List<Registration> listenerRegistrationList = new CopyOnWriteArrayList<>();", "modifier": "private final", "type": "List<Registration>", "declarator": "listenerRegistrationList = new CopyOnWriteArrayList<>()", "var_name": "listenerRegistrationList"}, {"original_string": "private volatile boolean refreshData = false;", "modifier": "private volatile", "type": "boolean", "declarator": "refreshData = false", "var_name": "refreshData"}, {"original_string": "private final long refreshDataDelay = 20L;", "modifier": "private final", "type": "long", "declarator": "refreshDataDelay = 20L", "var_name": "refreshDataDelay"}, {"original_string": "private volatile boolean refreshDataScheduled = false;", "modifier": "private volatile", "type": "boolean", "declarator": "refreshDataScheduled = false", "var_name": "refreshDataScheduled"}, {"original_string": "private final ScheduledExecutorService nodeConnectorDataChangeEventProcessor = Executors.newScheduledThreadPool(1);", "modifier": "private final", "type": "ScheduledExecutorService", "declarator": "nodeConnectorDataChangeEventProcessor = Executors.newScheduledThreadPool(1)", "var_name": "nodeConnectorDataChangeEventProcessor"}], "methods": [{"identifier": "InventoryReader", "parameters": "(DataBroker dataService)", "modifiers": "public", "return": "", "signature": " InventoryReader(DataBroker dataService)", "full_signature": "public  InventoryReader(DataBroker dataService)", "class_method_signature": "InventoryReader.InventoryReader(DataBroker dataService)", "testcase": false, "constructor": true}, {"identifier": "setRefreshData", "parameters": "(boolean refreshData)", "modifiers": "public", "return": "void", "signature": "void setRefreshData(boolean refreshData)", "full_signature": "public void setRefreshData(boolean refreshData)", "class_method_signature": "InventoryReader.setRefreshData(boolean refreshData)", "testcase": false, "constructor": false}, {"identifier": "registerAsDataChangeListener", "parameters": "()", "modifiers": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) private", "return": "void", "signature": "void registerAsDataChangeListener()", "full_signature": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) private void registerAsDataChangeListener()", "class_method_signature": "InventoryReader.registerAsDataChangeListener()", "testcase": false, "constructor": false}, {"identifier": "getControllerSwitchConnectors", "parameters": "()", "modifiers": "public", "return": "HashMap<String, NodeConnectorRef>", "signature": "HashMap<String, NodeConnectorRef> getControllerSwitchConnectors()", "full_signature": "public HashMap<String, NodeConnectorRef> getControllerSwitchConnectors()", "class_method_signature": "InventoryReader.getControllerSwitchConnectors()", "testcase": false, "constructor": false}, {"identifier": "getSwitchNodeConnectors", "parameters": "()", "modifiers": "public", "return": "HashMap<String, List<NodeConnectorRef>>", "signature": "HashMap<String, List<NodeConnectorRef>> getSwitchNodeConnectors()", "full_signature": "public HashMap<String, List<NodeConnectorRef>> getSwitchNodeConnectors()", "class_method_signature": "InventoryReader.getSwitchNodeConnectors()", "testcase": false, "constructor": false}, {"identifier": "onDataTreeChanged", "parameters": "(Collection<DataTreeModification<DataObject>> changes)", "modifiers": "@Override public", "return": "void", "signature": "void onDataTreeChanged(Collection<DataTreeModification<DataObject>> changes)", "full_signature": "@Override public void onDataTreeChanged(Collection<DataTreeModification<DataObject>> changes)", "class_method_signature": "InventoryReader.onDataTreeChanged(Collection<DataTreeModification<DataObject>> changes)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "InventoryReader.close()", "testcase": false, "constructor": false}, {"identifier": "readInventory", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void readInventory()", "full_signature": "public void readInventory()", "class_method_signature": "InventoryReader.readInventory()", "testcase": false, "constructor": false}, {"identifier": "getNodeConnector", "parameters": "(InstanceIdentifier<Node> nodeInsId, MacAddress macAddress)", "modifiers": "public", "return": "NodeConnectorRef", "signature": "NodeConnectorRef getNodeConnector(InstanceIdentifier<Node> nodeInsId, MacAddress macAddress)", "full_signature": "public NodeConnectorRef getNodeConnector(InstanceIdentifier<Node> nodeInsId, MacAddress macAddress)", "class_method_signature": "InventoryReader.getNodeConnector(InstanceIdentifier<Node> nodeInsId, MacAddress macAddress)", "testcase": false, "constructor": false}], "file": "arphandler/src/main/java/org/opendaylight/l2switch/arphandler/inventory/InventoryReader.java"}, "focal_method": {"identifier": "getNodeConnector", "parameters": "(InstanceIdentifier<Node> nodeInsId, MacAddress macAddress)", "modifiers": "public", "return": "NodeConnectorRef", "body": "public NodeConnectorRef getNodeConnector(InstanceIdentifier<Node> nodeInsId, MacAddress macAddress) {\n        if (nodeInsId == null || macAddress == null) {\n            return null;\n        }\n\n        NodeConnectorRef destNodeConnector = null;\n        long latest = -1;\n        ReadOnlyTransaction readOnlyTransaction = dataService.newReadOnlyTransaction();\n        try {\n            Optional<Node> dataObjectOptional = null;\n            dataObjectOptional = readOnlyTransaction.read(LogicalDatastoreType.OPERATIONAL, nodeInsId).get();\n            if (dataObjectOptional.isPresent()) {\n                Node node = dataObjectOptional.get();\n                LOG.debug(\"Looking address{} in node : {}\", macAddress, nodeInsId);\n                if (node.getNodeConnector() != null) {\n                    for (NodeConnector nc : node.getNodeConnector()) {\n                        // Don't look for mac in discarding node connectors\n                        StpStatusAwareNodeConnector saNodeConnector = nc\n                                .getAugmentation(StpStatusAwareNodeConnector.class);\n                        if (saNodeConnector != null && StpStatus.Discarding.equals(saNodeConnector.getStatus())) {\n                            continue;\n                        }\n                        LOG.debug(\"Looking address{} in nodeconnector : {}\", macAddress, nc.getKey());\n                        AddressCapableNodeConnector acnc = nc.getAugmentation(AddressCapableNodeConnector.class);\n                        if (acnc != null) {\n                            List<Addresses> addressesList = acnc.getAddresses();\n                            for (Addresses add : addressesList) {\n                                if (macAddress.equals(add.getMac())) {\n                                    if (add.getLastSeen() > latest) {\n                                        destNodeConnector = new NodeConnectorRef(\n                                                nodeInsId.child(NodeConnector.class, nc.getKey()));\n                                        latest = add.getLastSeen();\n                                        LOG.debug(\"Found address{} in nodeconnector : {}\", macAddress, nc.getKey());\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    LOG.debug(\"Node connectors data is not present for node {}\", node.getId());\n                }\n            }\n        } catch (InterruptedException e) {\n            LOG.error(\"Failed to read nodes from Operation data store.\");\n            readOnlyTransaction.close();\n            throw new RuntimeException(\"Failed to read nodes from Operation data store.\", e);\n        } catch (ExecutionException e) {\n            LOG.error(\"Failed to read nodes from Operation data store.\");\n            readOnlyTransaction.close();\n            throw new RuntimeException(\"Failed to read nodes from Operation data store.\", e);\n        }\n        readOnlyTransaction.close();\n        return destNodeConnector;\n    }", "signature": "NodeConnectorRef getNodeConnector(InstanceIdentifier<Node> nodeInsId, MacAddress macAddress)", "full_signature": "public NodeConnectorRef getNodeConnector(InstanceIdentifier<Node> nodeInsId, MacAddress macAddress)", "class_method_signature": "InventoryReader.getNodeConnector(InstanceIdentifier<Node> nodeInsId, MacAddress macAddress)", "testcase": false, "constructor": false, "invocations": ["newReadOnlyTransaction", "get", "read", "isPresent", "get", "debug", "getNodeConnector", "getNodeConnector", "getAugmentation", "equals", "getStatus", "debug", "getKey", "getAugmentation", "getAddresses", "equals", "getMac", "getLastSeen", "child", "getKey", "getLastSeen", "debug", "getKey", "debug", "getId", "error", "close", "error", "close", "close"]}, "repository": {"repo_id": 20701467, "url": "https://github.com/opendaylight/l2switch", "language": "Java", "is_fork": false, "fork_count": 30, "stargazer_count": 25, "size": 4178, "license": "licensed"}}