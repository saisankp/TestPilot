{"test_class": {"identifier": "TestScribeSender", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ScribeMockClient scribeClient;", "modifier": "private", "type": "ScribeMockClient", "declarator": "scribeClient", "var_name": "scribeClient"}, {"original_string": "private ScribeSender scribeSender;", "modifier": "private", "type": "ScribeSender", "declarator": "scribeSender", "var_name": "scribeSender"}, {"original_string": "private Event thriftEvent;", "modifier": "private", "type": "Event", "declarator": "thriftEvent", "var_name": "thriftEvent"}], "file": "scribe/src/test/java/com/ning/metrics/eventtracker/TestScribeSender.java"}, "test_case": {"identifier": "testSend", "parameters": "()", "modifiers": "@Test(groups = \"fast\") public", "return": "void", "body": "@Test(groups = \"fast\")\n    public void testSend() throws Exception\n    {\n        int i = 100;\n        while (i > 0) {\n//            scribeSender.send(thriftEvent, new CallbackHandler()\n//            {\n//\n//                @Override\n//                public void onError(Throwable t, File file)\n//                {\n//                    assertTrue(false);\n//                }\n//\n//                @Override\n//                public void onSuccess(File file)\n//                {\n//                    assertTrue(true);\n//                }\n//            });\n            i--;\n        }\n    }", "signature": "void testSend()", "full_signature": "@Test(groups = \"fast\") public void testSend()", "class_method_signature": "TestScribeSender.testSend()", "testcase": true, "constructor": false, "invocations": []}, "focal_class": {"identifier": "ScribeSender", "superclass": "", "interfaces": "implements EventSender", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(ScribeSender.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(ScribeSender.class)", "var_name": "log"}, {"original_string": "private static final Charset CHARSET = Charset.forName(\"ISO-8859-1\");", "modifier": "private static final", "type": "Charset", "declarator": "CHARSET = Charset.forName(\"ISO-8859-1\")", "var_name": "CHARSET"}, {"original_string": "private final AtomicInteger connectionRetries = new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "connectionRetries = new AtomicInteger(0)", "var_name": "connectionRetries"}, {"original_string": "private final ScribeClient scribeClient;", "modifier": "private final", "type": "ScribeClient", "declarator": "scribeClient", "var_name": "scribeClient"}, {"original_string": "private final AtomicInteger messagesSuccessfullySent = new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "messagesSuccessfullySent = new AtomicInteger(0)", "var_name": "messagesSuccessfullySent"}, {"original_string": "private final AtomicInteger messagesSuccessfullySentSinceLastReconnection = new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "messagesSuccessfullySentSinceLastReconnection = new AtomicInteger(0)", "var_name": "messagesSuccessfullySentSinceLastReconnection"}, {"original_string": "private int messagesToSendBeforeReconnecting = 0;", "modifier": "private", "type": "int", "declarator": "messagesToSendBeforeReconnecting = 0", "var_name": "messagesToSendBeforeReconnecting"}, {"original_string": "private final AtomicBoolean sleeping = new AtomicBoolean(true);", "modifier": "private final", "type": "AtomicBoolean", "declarator": "sleeping = new AtomicBoolean(true)", "var_name": "sleeping"}, {"original_string": "private final AtomicBoolean isClosed = new AtomicBoolean(true);", "modifier": "private final", "type": "AtomicBoolean", "declarator": "isClosed = new AtomicBoolean(true)", "var_name": "isClosed"}], "methods": [{"identifier": "ScribeSender", "parameters": "(final ScribeClient scribeClient, final int messagesToSendBeforeReconnecting, final int maxIdleTimeInMinutes)", "modifiers": "public", "return": "", "signature": " ScribeSender(final ScribeClient scribeClient, final int messagesToSendBeforeReconnecting, final int maxIdleTimeInMinutes)", "full_signature": "public  ScribeSender(final ScribeClient scribeClient, final int messagesToSendBeforeReconnecting, final int maxIdleTimeInMinutes)", "class_method_signature": "ScribeSender.ScribeSender(final ScribeClient scribeClient, final int messagesToSendBeforeReconnecting, final int maxIdleTimeInMinutes)", "testcase": false, "constructor": true}, {"identifier": "createConnection", "parameters": "()", "modifiers": "public synchronized", "return": "void", "signature": "void createConnection()", "full_signature": "public synchronized void createConnection()", "class_method_signature": "ScribeSender.createConnection()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void close()", "full_signature": "@Override public synchronized void close()", "class_method_signature": "ScribeSender.close()", "testcase": false, "constructor": false}, {"identifier": "send", "parameters": "(final File file, final CallbackHandler handler)", "modifiers": "@Override public", "return": "void", "signature": "void send(final File file, final CallbackHandler handler)", "full_signature": "@Override public void send(final File file, final CallbackHandler handler)", "class_method_signature": "ScribeSender.send(final File file, final CallbackHandler handler)", "testcase": false, "constructor": false}, {"identifier": "createScribePayload", "parameters": "(final File file, final CallbackHandler handler)", "modifiers": "private", "return": "List<LogEntry>", "signature": "List<LogEntry> createScribePayload(final File file, final CallbackHandler handler)", "full_signature": "private List<LogEntry> createScribePayload(final File file, final CallbackHandler handler)", "class_method_signature": "ScribeSender.createScribePayload(final File file, final CallbackHandler handler)", "testcase": false, "constructor": false}, {"identifier": "eventToLogEntryMessage", "parameters": "(final Event event)", "modifiers": "protected static", "return": "String", "signature": "String eventToLogEntryMessage(final Event event)", "full_signature": "protected static String eventToLogEntryMessage(final Event event)", "class_method_signature": "ScribeSender.eventToLogEntryMessage(final Event event)", "testcase": false, "constructor": false}, {"identifier": "getMessagesSuccessfullySent", "parameters": "()", "modifiers": "@Managed(description = \"Get the number of messages successfully sent since startup to Scribe\") public", "return": "long", "signature": "long getMessagesSuccessfullySent()", "full_signature": "@Managed(description = \"Get the number of messages successfully sent since startup to Scribe\") public long getMessagesSuccessfullySent()", "class_method_signature": "ScribeSender.getMessagesSuccessfullySent()", "testcase": false, "constructor": false}, {"identifier": "getMessagesSuccessfullySentSinceLastReconnection", "parameters": "()", "modifiers": "@Managed(description = \"Get the number of messages successfully sent since last reconnection to Scribe\") public", "return": "long", "signature": "long getMessagesSuccessfullySentSinceLastReconnection()", "full_signature": "@Managed(description = \"Get the number of messages successfully sent since last reconnection to Scribe\") public long getMessagesSuccessfullySentSinceLastReconnection()", "class_method_signature": "ScribeSender.getMessagesSuccessfullySentSinceLastReconnection()", "testcase": false, "constructor": false}, {"identifier": "getConnectionRetries", "parameters": "()", "modifiers": "@Managed(description = \"Get the number of times we retried to connect to Scribe\") public", "return": "long", "signature": "long getConnectionRetries()", "full_signature": "@Managed(description = \"Get the number of times we retried to connect to Scribe\") public long getConnectionRetries()", "class_method_signature": "ScribeSender.getConnectionRetries()", "testcase": false, "constructor": false}], "file": "scribe/src/main/java/com/ning/metrics/eventtracker/ScribeSender.java"}, "focal_method": {"identifier": "send", "parameters": "(final File file, final CallbackHandler handler)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void send(final File file, final CallbackHandler handler)\n    {\n        if (isClosed.get()) {\n            createConnection();\n        }\n\n        // Tell the watchdog that we are doing something\n        sleeping.set(false);\n\n        // Parse the underlying file and generate the payload for Scribe\n        final List<LogEntry> list = createScribePayload(file, handler);\n        if (list == null) {\n            // Something went wrong\n            return;\n        }\n\n        try {\n            scribeClient.log(list);\n            // Get rid of the file. We do it early, because the reconnection may fail\n            handler.onSuccess(file);\n\n            messagesSuccessfullySent.addAndGet(list.size());\n            messagesSuccessfullySentSinceLastReconnection.addAndGet(list.size());\n\n            // For load balancing capabilities, we don't want to make sticky connections to Scribe.\n            // After a certain threshold, force a refresh of the connection.\n            if (messagesSuccessfullySentSinceLastReconnection.get() > messagesToSendBeforeReconnecting) {\n                log.info(\"Recycling connection with Scribe\");\n                messagesSuccessfullySentSinceLastReconnection.set(0);\n                createConnection();\n            }\n        }\n        catch (org.apache.thrift.TException e) {\n            // Connection flacky?\n            log.warn(\"Error while sending message to Scribe: {}\", e.getLocalizedMessage());\n            createConnection();\n            handler.onError(new Throwable(e), file);\n        }\n    }", "signature": "void send(final File file, final CallbackHandler handler)", "full_signature": "@Override public void send(final File file, final CallbackHandler handler)", "class_method_signature": "ScribeSender.send(final File file, final CallbackHandler handler)", "testcase": false, "constructor": false, "invocations": ["get", "createConnection", "set", "createScribePayload", "log", "onSuccess", "addAndGet", "size", "addAndGet", "size", "get", "info", "set", "createConnection", "warn", "getLocalizedMessage", "createConnection", "onError"]}, "repository": {"repo_id": 1027501, "url": "https://github.com/pierre/eventtracker", "language": "Java", "is_fork": false, "fork_count": 4, "stargazer_count": 10, "size": 509, "license": "licensed"}}