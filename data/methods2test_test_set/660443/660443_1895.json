{"test_class": {"identifier": "CxSmilesGeneratorTest", "superclass": "", "interfaces": "", "fields": [], "file": "storage/smiles/src/test/java/org/openscience/cdk/smiles/CxSmilesGeneratorTest.java"}, "test_case": {"identifier": "sgroups", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void sgroups() {\n        CxSmilesState state = new CxSmilesState();\n        state.mysgroups = new ArrayList<>(1);\n        state.mysgroups.add(new CxSmilesState.CxPolymerSgroup(\"n\", Arrays.asList(2,3), \"n\", \"ht\"));\n        state.mysgroups.add(new CxSmilesState.CxPolymerSgroup(\"n\", Arrays.asList(5), \"m\", \"ht\"));\n        assertThat(CxSmilesGenerator.generate(state, SmiFlavor.CxPolymer, new int[0], new int[]{7, 6, 5, 4, 3, 2, 1, 0}),\n                   is(\" |Sg:n:2:m:ht,Sg:n:4,5:n:ht|\"));\n    }", "signature": "void sgroups()", "full_signature": "@Test public void sgroups()", "class_method_signature": "CxSmilesGeneratorTest.sgroups()", "testcase": true, "constructor": false, "invocations": ["add", "asList", "add", "asList", "assertThat", "generate", "is"]}, "focal_class": {"identifier": "CxSmilesGenerator", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "inverse", "parameters": "(int[] perm)", "modifiers": "private static", "return": "int[]", "signature": "int[] inverse(int[] perm)", "full_signature": "private static int[] inverse(int[] perm)", "class_method_signature": "CxSmilesGenerator.inverse(int[] perm)", "testcase": false, "constructor": false}, {"identifier": "encode_alias", "parameters": "(String label)", "modifiers": "private static", "return": "String", "signature": "String encode_alias(String label)", "full_signature": "private static String encode_alias(String label)", "class_method_signature": "CxSmilesGenerator.encode_alias(String label)", "testcase": false, "constructor": false}, {"identifier": "compare", "parameters": "(Comparator<Integer> comp, List<Integer> a, List<Integer> b)", "modifiers": "private static", "return": "int", "signature": "int compare(Comparator<Integer> comp, List<Integer> a, List<Integer> b)", "full_signature": "private static int compare(Comparator<Integer> comp, List<Integer> a, List<Integer> b)", "class_method_signature": "CxSmilesGenerator.compare(Comparator<Integer> comp, List<Integer> a, List<Integer> b)", "testcase": false, "constructor": false}, {"identifier": "generate", "parameters": "(CxSmilesState state, int opts, int[] components, final int[] ordering)", "modifiers": "static", "return": "String", "signature": "String generate(CxSmilesState state, int opts, int[] components, final int[] ordering)", "full_signature": "static String generate(CxSmilesState state, int opts, int[] components, final int[] ordering)", "class_method_signature": "CxSmilesGenerator.generate(CxSmilesState state, int opts, int[] components, final int[] ordering)", "testcase": false, "constructor": false}, {"identifier": "appendIntegers", "parameters": "(int[] invorder, char sep, StringBuilder sb, List<Integer> vals)", "modifiers": "private static", "return": "void", "signature": "void appendIntegers(int[] invorder, char sep, StringBuilder sb, List<Integer> vals)", "full_signature": "private static void appendIntegers(int[] invorder, char sep, StringBuilder sb, List<Integer> vals)", "class_method_signature": "CxSmilesGenerator.appendIntegers(int[] invorder, char sep, StringBuilder sb, List<Integer> vals)", "testcase": false, "constructor": false}], "file": "storage/smiles/src/main/java/org/openscience/cdk/smiles/CxSmilesGenerator.java"}, "focal_method": {"identifier": "generate", "parameters": "(CxSmilesState state, int opts, int[] components, final int[] ordering)", "modifiers": "static", "return": "String", "body": "static String generate(CxSmilesState state, int opts, int[] components, final int[] ordering) {\n\n        if (!SmiFlavor.isSet(opts, SmiFlavor.CxSmilesWithCoords))\n            return \"\";\n\n        final int[] invorder = inverse(ordering);\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(' ');\n        sb.append('|');\n\n        final Comparator<Integer> invComp = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                return Integer.compare(invorder[a], invorder[b]);\n            }\n        };\n        final Comparator<Integer> comp = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                return Integer.compare(ordering[a], ordering[b]);\n            }\n        };\n\n        // Fragment Grouping\n        if (SmiFlavor.isSet(opts, SmiFlavor.CxFragmentGroup) &&\n            state.fragGroups != null && !state.fragGroups.isEmpty()) {\n\n            int maxCompId = 0;\n            for (int compId : components) {\n                if (compId > maxCompId)\n                    maxCompId = compId;\n            }\n\n            // get the output component order\n            final int[] compMap = new int[maxCompId + 1];\n            int compId = 1;\n            for (int idx : invorder) {\n                int component = components[idx];\n                if (compMap[component] == 0)\n                    compMap[component] = compId++;\n            }\n            // index vs number, we need to output index\n            for (int i = 0; i < compMap.length; i++)\n                compMap[i]--;\n\n            final Comparator<Integer> compComp = new Comparator<Integer>() {\n                @Override\n                public int compare(Integer a, Integer b) {\n                    return Integer.compare(compMap[a], compMap[b]);\n                }\n            };\n\n            List<List<Integer>> fragGroupCpy = new ArrayList<>(state.fragGroups);\n            for (List<Integer> idxs : fragGroupCpy)\n                Collections.sort(idxs, compComp);\n            Collections.sort(fragGroupCpy, new Comparator<List<Integer>>() {\n                @Override\n                public int compare(List<Integer> a, List<Integer> b) {\n                    return CxSmilesGenerator.compare(compComp, a, b);\n                }\n            });\n\n            // C1=CC=CC=C1.C1=CC=CC=C1.[OH-].[Na+]>> |f:0.1,2.3,c:0,2,4,6,8,10|\n            sb.append('f');\n            sb.append(':');\n            for (int i = 0; i < fragGroupCpy.size(); i++) {\n                if (i > 0) sb.append(',');\n                appendIntegers(compMap, '.', sb, fragGroupCpy.get(i));\n            }\n        }\n\n        // Atom Labels\n        if (SmiFlavor.isSet(opts, SmiFlavor.CxAtomLabel) &&\n            state.atomLabels != null && !state.atomLabels.isEmpty()) {\n\n            if (sb.length() > 2)\n                sb.append(',');\n            sb.append('$');\n            int nonempty_cnt = 0;\n            for (int idx : invorder) {\n                String label = state.atomLabels.get(idx);\n                if (label == null || label.isEmpty()) label = \"\";\n                else nonempty_cnt++;\n                sb.append(encode_alias(label));\n                // don't need to write anymore more ';'\n                if (nonempty_cnt == state.atomLabels.size())\n                    break;\n                sb.append(\";\");\n            }\n            sb.append('$');\n        }\n\n        // Atom Values\n        if (SmiFlavor.isSet(opts, SmiFlavor.CxAtomValue) &&\n            state.atomValues != null && !state.atomValues.isEmpty()) {\n\n            if (sb.length() > 2)\n                sb.append(',');\n            sb.append(\"$_AV:\");\n            int nonempty_cnt = 0;\n            for (int idx : invorder) {\n                String label = state.atomValues.get(idx);\n                if (label == null || label.isEmpty()) label = \"\";\n                else nonempty_cnt++;\n                sb.append(encode_alias(label));\n                // don't need to write anymore more ';'\n                if (nonempty_cnt == state.atomValues.size())\n                    break;\n                sb.append(\";\");\n            }\n            sb.append('$');\n        }\n\n        // 2D/3D Coordinates\n        if (SmiFlavor.isSet(opts, SmiFlavor.CxCoordinates) &&\n            state.atomCoords != null && !state.atomCoords.isEmpty()) {\n            DecimalFormat fmt = new DecimalFormat(\"#.##\", DecimalFormatSymbols.getInstance(Locale.ROOT));\n            if (sb.length() > 2) sb.append(',');\n            sb.append('(');\n            for (int i = 0; i < ordering.length; i++) {\n                double[] xyz = state.atomCoords.get(invorder[i]);\n                if (i != 0) sb.append(';');\n                if (xyz[0] != 0)\n                    sb.append(fmt.format(xyz[0]));\n                sb.append(',');\n                if (xyz[1] != 0)\n                    sb.append(fmt.format(xyz[1]));\n                sb.append(',');\n                if (xyz[2] != 0)\n                    sb.append(fmt.format(xyz[2]));\n            }\n            sb.append(')');\n        }\n\n        // Multicenter/Positional variation bonds\n        if (SmiFlavor.isSet(opts, SmiFlavor.CxMulticenter) &&\n            state.positionVar != null && !state.positionVar.isEmpty()) {\n\n            if (sb.length() > 2) sb.append(',');\n            sb.append('m');\n            sb.append(':');\n\n            List<Map.Entry<Integer, List<Integer>>> multicenters = new ArrayList<>(state.positionVar.entrySet());\n\n            // consistent output order\n            multicenters.sort((a, b) -> comp.compare(a.getKey(), b.getKey()));\n\n            for (int i = 0; i < multicenters.size(); i++) {\n                if (i != 0) sb.append(',');\n                Map.Entry<Integer, List<Integer>> e = multicenters.get(i);\n                sb.append(ordering[e.getKey()]);\n                sb.append(':');\n                List<Integer> vals = new ArrayList<>(e.getValue());\n                vals.sort(comp);\n                appendIntegers(ordering, '.', sb, vals);\n            }\n\n        }\n\n        if (SmiFlavor.isSet(opts, SmiFlavor.CxLigandOrder) &&\n            state.ligandOrdering != null && !state.ligandOrdering.isEmpty()) {\n\n            if (sb.length() > 2) sb.append(',');\n            sb.append(\"LO\");\n            sb.append(':');\n\n            List<Map.Entry<Integer, List<Integer>>> ligandorderings = new ArrayList<>(state.ligandOrdering.entrySet());\n\n            // consistent output order\n            ligandorderings.sort((a, b) -> comp.compare(a.getKey(), b.getKey()));\n\n            for (int i = 0; i < ligandorderings.size(); i++) {\n                if (i != 0) sb.append(',');\n                Map.Entry<Integer, List<Integer>> e = ligandorderings.get(i);\n                sb.append(ordering[e.getKey()]);\n                sb.append(':');\n                appendIntegers(ordering, '.', sb, e.getValue());\n            }\n\n        }\n\n\n        int numSgroups = 0;\n\n        // *CCO* |$_AP1;;;;_AP2$,Sg:n:1,2,3::ht|\n        if (SmiFlavor.isSet(opts, SmiFlavor.CxPolymer) &&\n            state.mysgroups != null && !state.mysgroups.isEmpty()) {\n            List<CxPolymerSgroup> polysgroups = new ArrayList<>();\n            for (CxSgroup polysgroup : state.mysgroups) {\n                if (polysgroup instanceof CxPolymerSgroup) {\n                    polysgroups.add((CxPolymerSgroup) polysgroup);\n                    Collections.sort(polysgroup.atoms, comp);\n                }\n            }\n\n            Collections.sort(polysgroups, new Comparator<CxPolymerSgroup>() {\n                @Override\n                public int compare(CxPolymerSgroup a, CxPolymerSgroup b) {\n                    int cmp = 0;\n                    cmp = a.type.compareTo(b.type);\n                    if (cmp != 0) return cmp;\n                    cmp = CxSmilesGenerator.compare(comp, a.atoms, b.atoms);\n                    return cmp;\n                }\n            });\n\n            for (CxPolymerSgroup cxPolymerSgroup : polysgroups) {\n                cxPolymerSgroup.id = numSgroups++;\n                if (sb.length() > 2) sb.append(',');\n                sb.append(\"Sg:\");\n                sb.append(cxPolymerSgroup.type);\n                sb.append(':');\n                appendIntegers(ordering, ',', sb, cxPolymerSgroup.atoms);\n                sb.append(':');\n                if (cxPolymerSgroup.subscript != null)\n                    sb.append(cxPolymerSgroup.subscript);\n                sb.append(':');\n                if (cxPolymerSgroup.supscript != null)\n                    sb.append(cxPolymerSgroup.supscript.toLowerCase(Locale.ROOT));\n            }\n        }\n\n        if (SmiFlavor.isSet(opts, SmiFlavor.CxDataSgroups) &&\n            state.mysgroups != null && !state.mysgroups.isEmpty()) {\n            List<CxDataSgroup> datasgroups = new ArrayList<>();\n            for (CxSgroup datasgroup : state.mysgroups) {\n                if (datasgroup instanceof CxDataSgroup) {\n                    datasgroups.add((CxDataSgroup)datasgroup);\n                    Collections.sort(datasgroup.atoms, comp);\n                }\n            }\n\n            Collections.sort(datasgroups, new Comparator<CxDataSgroup>() {\n                @Override\n                public int compare(CxDataSgroup a, CxDataSgroup b) {\n                    int cmp = 0;\n                    cmp = a.field.compareTo(b.field);\n                    if (cmp != 0) return cmp;\n                    cmp = a.value.compareTo(b.value);\n                    if (cmp != 0) return cmp;\n                    cmp = CxSmilesGenerator.compare(comp, a.atoms, b.atoms);\n                    return cmp;\n                }\n            });\n\n            for (CxDataSgroup cxDataSgroup : datasgroups) {\n                cxDataSgroup.id = numSgroups++;\n                if (sb.length() > 2) sb.append(',');\n                sb.append(\"SgD:\");\n                appendIntegers(ordering, ',', sb, cxDataSgroup.atoms);\n                sb.append(':');\n                if (cxDataSgroup.field != null)\n                    sb.append(cxDataSgroup.field);\n                sb.append(':');\n                if (cxDataSgroup.value != null)\n                    sb.append(cxDataSgroup.value);\n                sb.append(':');\n                if (cxDataSgroup.operator != null)\n                    sb.append(cxDataSgroup.operator);\n                sb.append(':');\n                if (cxDataSgroup.unit != null)\n                    sb.append(cxDataSgroup.unit);\n                // fmt (t/f/n) + coords?\n            }\n        }\n\n        // hierarchy information\n        if (numSgroups > 0) {\n            boolean firstSgH = true;\n            if (state.mysgroups != null) {\n                state.mysgroups.sort(Comparator.comparingInt(o -> o.id));\n                for (CxSgroup sgroup : state.mysgroups) {\n                    if (sgroup.children.isEmpty())\n                        continue;\n                    if (sb.length() > 2) sb.append(',');\n                    if (firstSgH) {\n                        sb.append(\"SgH:\");\n                        firstSgH = false;\n                    }\n                    sb.append(sgroup.id).append(':');\n                    boolean first = true;\n                    List<CxSgroup> children = new ArrayList<>(sgroup.children);\n                    children.sort(Comparator.comparingInt(o -> o.id));\n                    for (CxSgroup child : children) {\n                        if (child.id < 0)\n                            continue;\n                        if (!first)\n                            sb.append('.');\n                        first = false;\n                        sb.append(child.id);\n                    }\n                }\n            }\n        }\n\n        // [C]1[CH][CH]CCC1 |^1:1,2,^3:0|\n        if (SmiFlavor.isSet(opts, SmiFlavor.CxRadical) &&\n            state.atomRads != null && !state.atomRads.isEmpty()) {\n            Map<CxSmilesState.Radical, List<Integer>> radinv = new TreeMap<>();\n            for (Map.Entry<Integer, CxSmilesState.Radical> e : state.atomRads.entrySet()) {\n                List<Integer> idxs = radinv.get(e.getValue());\n                if (idxs == null)\n                    radinv.put(e.getValue(), idxs = new ArrayList<Integer>());\n                idxs.add(e.getKey());\n            }\n            for (Map.Entry<CxSmilesState.Radical, List<Integer>> e : radinv.entrySet()) {\n                if (sb.length() > 2) sb.append(',');\n                sb.append('^');\n                sb.append(e.getKey().ordinal() + 1);\n                sb.append(':');\n                Collections.sort(e.getValue(), comp);\n                appendIntegers(ordering, ',', sb, e.getValue());\n            }\n        }\n\n        sb.append('|');\n        if (sb.length() <= 3) {\n            return \"\";\n        } else {\n            return sb.toString();\n        }\n    }", "signature": "String generate(CxSmilesState state, int opts, int[] components, final int[] ordering)", "full_signature": "static String generate(CxSmilesState state, int opts, int[] components, final int[] ordering)", "class_method_signature": "CxSmilesGenerator.generate(CxSmilesState state, int opts, int[] components, final int[] ordering)", "testcase": false, "constructor": false, "invocations": ["isSet", "inverse", "append", "append", "compare", "compare", "isSet", "isEmpty", "compare", "sort", "sort", "compare", "append", "append", "size", "append", "appendIntegers", "get", "isSet", "isEmpty", "length", "append", "append", "get", "isEmpty", "append", "encode_alias", "size", "append", "append", "isSet", "isEmpty", "length", "append", "append", "get", "isEmpty", "append", "encode_alias", "size", "append", "append", "isSet", "isEmpty", "getInstance", "length", "append", "append", "get", "append", "append", "format", "append", "append", "format", "append", "append", "format", "append", "isSet", "isEmpty", "length", "append", "append", "append", "entrySet", "sort", "compare", "getKey", "getKey", "size", "append", "get", "append", "getKey", "append", "getValue", "sort", "appendIntegers", "isSet", "isEmpty", "length", "append", "append", "append", "entrySet", "sort", "compare", "getKey", "getKey", "size", "append", "get", "append", "getKey", "append", "appendIntegers", "getValue", "isSet", "isEmpty", "add", "sort", "sort", "compareTo", "compare", "length", "append", "append", "append", "append", "appendIntegers", "append", "append", "append", "append", "toLowerCase", "isSet", "isEmpty", "add", "sort", "sort", "compareTo", "compareTo", "compare", "length", "append", "append", "appendIntegers", "append", "append", "append", "append", "append", "append", "append", "append", "sort", "comparingInt", "isEmpty", "length", "append", "append", "append", "append", "sort", "comparingInt", "append", "append", "isSet", "isEmpty", "entrySet", "get", "getValue", "put", "getValue", "add", "getKey", "entrySet", "length", "append", "append", "append", "ordinal", "getKey", "append", "sort", "getValue", "appendIntegers", "getValue", "append", "length", "toString"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}