{"test_class": {"identifier": "MarkovChainLanguageModelTest", "superclass": "", "interfaces": "", "fields": [], "file": "text/nlp/src/test/java/org/openimaj/text/nlp/language/MarkovChainLanguageModelTest.java"}, "test_case": {"identifier": "testGenerate", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testGenerate() throws UnsupportedEncodingException {\n\t\tfinal MarkovChainLanguageModel model = new MarkovChainLanguageModel();\n\t\tmodel.train(Locale.ENGLISH, \"This is an english sentence\", \"UTF-8\");\n\t}", "signature": "void testGenerate()", "full_signature": "@Test public void testGenerate()", "class_method_signature": "MarkovChainLanguageModelTest.testGenerate()", "testcase": true, "constructor": false, "invocations": ["train"]}, "focal_class": {"identifier": "MarkovChainLanguageModel", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Map<Locale, Matrix> chains = new HashMap<Locale, Matrix>();", "modifier": "private", "type": "Map<Locale, Matrix>", "declarator": "chains = new HashMap<Locale, Matrix>()", "var_name": "chains"}, {"original_string": "private Map<Locale, long[]> chainCounts = new HashMap<Locale, long[]>();", "modifier": "private", "type": "Map<Locale, long[]>", "declarator": "chainCounts = new HashMap<Locale, long[]>()", "var_name": "chainCounts"}], "methods": [{"identifier": "MarkovChainLanguageModel", "parameters": "()", "modifiers": "public", "return": "", "signature": " MarkovChainLanguageModel()", "full_signature": "public  MarkovChainLanguageModel()", "class_method_signature": "MarkovChainLanguageModel.MarkovChainLanguageModel()", "testcase": false, "constructor": true}, {"identifier": "train", "parameters": "(Locale language, String example, String encoding)", "modifiers": "public", "return": "void", "signature": "void train(Locale language, String example, String encoding)", "full_signature": "public void train(Locale language, String example, String encoding)", "class_method_signature": "MarkovChainLanguageModel.train(Locale language, String example, String encoding)", "testcase": false, "constructor": false}, {"identifier": "train", "parameters": "(Locale language, InputStream stream)", "modifiers": "public", "return": "void", "signature": "void train(Locale language, InputStream stream)", "full_signature": "public void train(Locale language, InputStream stream)", "class_method_signature": "MarkovChainLanguageModel.train(Locale language, InputStream stream)", "testcase": false, "constructor": false}, {"identifier": "generate", "parameters": "(Locale language, int length, String encoding)", "modifiers": "public", "return": "String", "signature": "String generate(Locale language, int length, String encoding)", "full_signature": "public String generate(Locale language, int length, String encoding)", "class_method_signature": "MarkovChainLanguageModel.generate(Locale language, int length, String encoding)", "testcase": false, "constructor": false}], "file": "text/nlp/src/main/java/org/openimaj/text/nlp/language/MarkovChainLanguageModel.java"}, "focal_method": {"identifier": "generate", "parameters": "(Locale language, int length, String encoding)", "modifiers": "public", "return": "String", "body": "public String generate(Locale language, int length, String encoding) throws UnsupportedEncodingException {\n\n\t\tfinal Matrix chain = this.chains.get(language);\n\t\tif (chain == null)\n\t\t\treturn null;\n\t\tfinal double[][] chainData = chain.getArray();\n\t\tfinal long[] chainCount = this.chainCounts.get(language);\n\n\t\tint currentIndex = 0;\n\t\tfinal byte[] newString = new byte[length];\n\t\tfinal Random r = new Random();\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tfinal double prob = r.nextDouble();\n\t\t\tfinal double[] currentLine = chainData[currentIndex];\n\t\t\tdouble probSum = 0.0;\n\t\t\tint newIndex = 0;\n\t\t\t// System.out.println(\"CURRENT STATE:\" + (char)(currentIndex-1));\n\t\t\twhile (probSum + (currentLine[newIndex] / chainCount[currentIndex]) < prob) {\n\t\t\t\tfinal double probForIndex = (currentLine[newIndex++] / chainCount[currentIndex]);\n\t\t\t\t// System.out.println(probForIndex);\n\t\t\t\t// if(probForIndex > 0){\n\t\t\t\t// System.out.println(\"Prob to go to:\" + (char)(newIndex-2) +\n\t\t\t\t// \" = \" + probForIndex);\n\t\t\t\t// }\n\t\t\t\tprobSum += probForIndex;\n\t\t\t}\n\t\t\t// System.out.println(\"NEW STATE:\" + (char)(newIndex-1));\n\t\t\tnewString[i] = (byte) (newIndex - 1);\n\t\t\tcurrentIndex = newIndex;\n\t\t}\n\n\t\treturn new String(newString, encoding);\n\t}", "signature": "String generate(Locale language, int length, String encoding)", "full_signature": "public String generate(Locale language, int length, String encoding)", "class_method_signature": "MarkovChainLanguageModel.generate(Locale language, int length, String encoding)", "testcase": false, "constructor": false, "invocations": ["get", "getArray", "get", "nextDouble"]}, "repository": {"repo_id": 4114800, "url": "https://github.com/sinjax/trendminer-java", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 10, "size": 209307, "license": "licensed"}}