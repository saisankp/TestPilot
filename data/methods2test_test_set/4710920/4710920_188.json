{"test_class": {"identifier": "ActiveLimitFilterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "ActiveLimitFilter activeLimitFilter = new ActiveLimitFilter();", "modifier": "", "type": "ActiveLimitFilter", "declarator": "activeLimitFilter = new ActiveLimitFilter()", "var_name": "activeLimitFilter"}], "file": "dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ActiveLimitFilterTest.java"}, "test_case": {"identifier": "testInvokeGreaterActives", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testInvokeGreaterActives() {\n        AtomicInteger count = new AtomicInteger(0);\n        URL url = URL.valueOf(\"test://test:11/test?accesslog=true&group=dubbo&version=1.1&actives=1&timeout=1\");\n        final Invoker<ActiveLimitFilterTest> invoker = new BlockMyInvoker<ActiveLimitFilterTest>(url, 100);\n        final Invocation invocation = new MockInvocation();\n        final CountDownLatch latch = new CountDownLatch(1);\n        for (int i = 0; i < 100; i++) {\n            Thread thread = new Thread(new Runnable() {\n\n                public void run() {\n                    try {\n                        latch.await();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    for (int i = 0; i < 100; i++) {\n                        try {\n                            activeLimitFilter.invoke(invoker, invocation);\n                        } catch (RpcException expected) {\n                            count.incrementAndGet();\n                        }\n                    }\n                }\n            });\n            thread.start();\n        }\n        latch.countDown();\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        assertNotSame(0, count.intValue());\n    }", "signature": "void testInvokeGreaterActives()", "full_signature": "@Test public void testInvokeGreaterActives()", "class_method_signature": "ActiveLimitFilterTest.testInvokeGreaterActives()", "testcase": true, "constructor": false, "invocations": ["valueOf", "await", "printStackTrace", "invoke", "incrementAndGet", "start", "countDown", "sleep", "printStackTrace", "assertNotSame", "intValue"]}, "focal_class": {"identifier": "ActiveLimitFilter", "superclass": "", "interfaces": "implements Filter, Filter.Listener", "fields": [{"original_string": "private static final String ACTIVELIMIT_FILTER_START_TIME = \"activelimit_filter_start_time\";", "modifier": "private static final", "type": "String", "declarator": "ACTIVELIMIT_FILTER_START_TIME = \"activelimit_filter_start_time\"", "var_name": "ACTIVELIMIT_FILTER_START_TIME"}], "methods": [{"identifier": "invoke", "parameters": "(Invoker<?> invoker, Invocation invocation)", "modifiers": "@Override public", "return": "Result", "signature": "Result invoke(Invoker<?> invoker, Invocation invocation)", "full_signature": "@Override public Result invoke(Invoker<?> invoker, Invocation invocation)", "class_method_signature": "ActiveLimitFilter.invoke(Invoker<?> invoker, Invocation invocation)", "testcase": false, "constructor": false}, {"identifier": "onResponse", "parameters": "(Result appResponse, Invoker<?> invoker, Invocation invocation)", "modifiers": "@Override public", "return": "void", "signature": "void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation)", "full_signature": "@Override public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation)", "class_method_signature": "ActiveLimitFilter.onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation)", "testcase": false, "constructor": false}, {"identifier": "onError", "parameters": "(Throwable t, Invoker<?> invoker, Invocation invocation)", "modifiers": "@Override public", "return": "void", "signature": "void onError(Throwable t, Invoker<?> invoker, Invocation invocation)", "full_signature": "@Override public void onError(Throwable t, Invoker<?> invoker, Invocation invocation)", "class_method_signature": "ActiveLimitFilter.onError(Throwable t, Invoker<?> invoker, Invocation invocation)", "testcase": false, "constructor": false}, {"identifier": "getElapsed", "parameters": "(Invocation invocation)", "modifiers": "private", "return": "long", "signature": "long getElapsed(Invocation invocation)", "full_signature": "private long getElapsed(Invocation invocation)", "class_method_signature": "ActiveLimitFilter.getElapsed(Invocation invocation)", "testcase": false, "constructor": false}, {"identifier": "notifyFinish", "parameters": "(final RpcStatus rpcStatus, int max)", "modifiers": "private", "return": "void", "signature": "void notifyFinish(final RpcStatus rpcStatus, int max)", "full_signature": "private void notifyFinish(final RpcStatus rpcStatus, int max)", "class_method_signature": "ActiveLimitFilter.notifyFinish(final RpcStatus rpcStatus, int max)", "testcase": false, "constructor": false}], "file": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ActiveLimitFilter.java"}, "focal_method": {"identifier": "invoke", "parameters": "(Invoker<?> invoker, Invocation invocation)", "modifiers": "@Override public", "return": "Result", "body": "@Override\n    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n        URL url = invoker.getUrl();\n        String methodName = invocation.getMethodName();\n        int max = invoker.getUrl().getMethodParameter(methodName, ACTIVES_KEY, 0);\n        final RpcStatus rpcStatus = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());\n        if (!RpcStatus.beginCount(url, methodName, max)) {\n            long timeout = invoker.getUrl().getMethodParameter(invocation.getMethodName(), TIMEOUT_KEY, 0);\n            long start = System.currentTimeMillis();\n            long remain = timeout;\n            synchronized (rpcStatus) {\n                while (!RpcStatus.beginCount(url, methodName, max)) {\n                    try {\n                        rpcStatus.wait(remain);\n                    } catch (InterruptedException e) {\n                        // ignore\n                    }\n                    long elapsed = System.currentTimeMillis() - start;\n                    remain = timeout - elapsed;\n                    if (remain <= 0) {\n                        throw new RpcException(RpcException.LIMIT_EXCEEDED_EXCEPTION,\n                                \"Waiting concurrent invoke timeout in client-side for service:  \" +\n                                        invoker.getInterface().getName() + \", method: \" + invocation.getMethodName() +\n                                        \", elapsed: \" + elapsed + \", timeout: \" + timeout + \". concurrent invokes: \" +\n                                        rpcStatus.getActive() + \". max concurrent invoke limit: \" + max);\n                    }\n                }\n            }\n        }\n\n        invocation.put(ACTIVELIMIT_FILTER_START_TIME, System.currentTimeMillis());\n\n        return invoker.invoke(invocation);\n    }", "signature": "Result invoke(Invoker<?> invoker, Invocation invocation)", "full_signature": "@Override public Result invoke(Invoker<?> invoker, Invocation invocation)", "class_method_signature": "ActiveLimitFilter.invoke(Invoker<?> invoker, Invocation invocation)", "testcase": false, "constructor": false, "invocations": ["getUrl", "getMethodName", "getMethodParameter", "getUrl", "getStatus", "getUrl", "getMethodName", "beginCount", "getMethodParameter", "getUrl", "getMethodName", "currentTimeMillis", "beginCount", "wait", "currentTimeMillis", "getName", "getInterface", "getMethodName", "getActive", "put", "currentTimeMillis", "invoke"]}, "repository": {"repo_id": 4710920, "url": "https://github.com/apache/dubbo", "stars": 30960, "created": "6/19/2012 7:56:02 AM +00:00", "updates": "2020-01-27T14:21:03+00:00", "fork": "False", "license": "licensed"}}