{"test_class": {"identifier": "LRSGeocodeProcessTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private DataStore featureSource;", "modifier": "private", "type": "DataStore", "declarator": "featureSource", "var_name": "featureSource"}], "file": "modules/unsupported/process-feature/src/test/java/org/geotools/process/vector/LRSGeocodeProcessTest.java"}, "test_case": {"identifier": "testBadParamToLrs", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testBadParamToLrs() throws Exception {\n        SimpleFeatureSource source = featureSource.getFeatureSource(\"lrssimple\");\n        LRSGeocodeProcess process = new LRSGeocodeProcess();\n        SimpleFeatureCollection origional = source.getFeatures();\n\n        try {\n            FeatureCollection result = process.execute(origional, \"from_lrs\", \"to_lrs_bad\", 1.0);\n            Assert.fail(\"Expected error from bad to_lrs name\");\n        } catch (ProcessException e) {\n            // Successful\n        }\n    }", "signature": "void testBadParamToLrs()", "full_signature": "@Test public void testBadParamToLrs()", "class_method_signature": "LRSGeocodeProcessTest.testBadParamToLrs()", "testcase": true, "constructor": false, "invocations": ["getFeatureSource", "getFeatures", "execute", "fail"]}, "focal_class": {"identifier": "LRSGeocodeProcess", "superclass": "", "interfaces": "implements VectorProcess", "fields": [{"original_string": "private static final Logger LOGGER = Logging.getLogger(LRSGeocodeProcess.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = Logging.getLogger(LRSGeocodeProcess.class)", "var_name": "LOGGER"}, {"original_string": "private final GeometryFactory geometryFactory = new GeometryFactory();", "modifier": "private final", "type": "GeometryFactory", "declarator": "geometryFactory = new GeometryFactory()", "var_name": "geometryFactory"}], "methods": [{"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"measure\", description = \"Measure of the point along the feature to be computed\") Double measure)", "modifiers": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public", "return": "FeatureCollection", "signature": "FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"measure\", description = \"Measure of the point along the feature to be computed\") Double measure)", "full_signature": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"measure\", description = \"Measure of the point along the feature to be computed\") Double measure)", "class_method_signature": "LRSGeocodeProcess.execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"measure\", description = \"Measure of the point along the feature to be computed\") Double measure)", "testcase": false, "constructor": false}, {"identifier": "createTargetFeatureType", "parameters": "(FeatureType sourceFeatureType)", "modifiers": "private", "return": "SimpleFeatureType", "signature": "SimpleFeatureType createTargetFeatureType(FeatureType sourceFeatureType)", "full_signature": "private SimpleFeatureType createTargetFeatureType(FeatureType sourceFeatureType)", "class_method_signature": "LRSGeocodeProcess.createTargetFeatureType(FeatureType sourceFeatureType)", "testcase": false, "constructor": false}, {"identifier": "createTargetFeature", "parameters": "(Feature feature, SimpleFeatureType targetFeatureType,\n            Coordinate geocodePoint)", "modifiers": "private", "return": "SimpleFeature", "signature": "SimpleFeature createTargetFeature(Feature feature, SimpleFeatureType targetFeatureType,\n            Coordinate geocodePoint)", "full_signature": "private SimpleFeature createTargetFeature(Feature feature, SimpleFeatureType targetFeatureType,\n            Coordinate geocodePoint)", "class_method_signature": "LRSGeocodeProcess.createTargetFeature(Feature feature, SimpleFeatureType targetFeatureType,\n            Coordinate geocodePoint)", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/LRSGeocodeProcess.java"}, "focal_method": {"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"measure\", description = \"Measure of the point along the feature to be computed\") Double measure)", "modifiers": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public", "return": "FeatureCollection", "body": "@DescribeResult(name = \"result\", description = \"Output feature collection\")\n    public FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"measure\", description = \"Measure of the point along the feature to be computed\") Double measure)\n            throws ProcessException {\n        DefaultFeatureCollection results = new DefaultFeatureCollection();\n        try {\n            if (featureCollection == null || featureCollection.size() == 0) {\n                LOGGER.info(\"No features provided in request\");\n                return results;\n            }\n            if (fromMeasureAttb == null\n                    || featureCollection.getSchema().getDescriptor(fromMeasureAttb) == null) {\n                throw new ProcessException(\n                        \"The from_measure_attb parameter was not provided or not defined in schema\");\n            }\n            if (toMeasureAttb == null\n                    || featureCollection.getSchema().getDescriptor(toMeasureAttb) == null) {\n                throw new ProcessException(\"The to_measure_attb parameter was not provided\");\n            }\n            if (measure == null) {\n                throw new ProcessException(\"The measure parameter was not provided\");\n            }\n            SimpleFeatureType targetFeatureType = createTargetFeatureType(featureCollection\n                    .getSchema());\n\n            FeatureIterator<Feature> featureIterator = null;\n            try {\n                featureIterator = featureCollection.features();\n                Feature feature = featureIterator.next();\n                Double featureFromMeasure = (Double) feature.getProperty(fromMeasureAttb)\n                        .getValue();\n                Double featureToMeasure = (Double) feature.getProperty(toMeasureAttb).getValue();\n                LengthIndexedLine lengthIndexedLine = new LengthIndexedLine((Geometry) feature\n                        .getDefaultGeometryProperty().getValue());\n                double featureLength = featureToMeasure - featureFromMeasure;\n                double startOffset = measure - featureFromMeasure;\n                double calcLength = ((Geometry) feature.getDefaultGeometryProperty().getValue())\n                        .getLength();\n                if (calcLength == 0) {\n                    LOGGER.info(\"Edge feature has zero length\");\n                    return results;\n                }\n                if (featureLength == 0) {\n                    LOGGER.info(\"Requested feature has zero length\");\n                    return results;\n                }\n                Coordinate point = lengthIndexedLine.extractPoint(startOffset * calcLength\n                        / featureLength);\n                results.add(createTargetFeature(feature, targetFeatureType, point));\n            } finally {\n                if (featureIterator != null)\n                    featureIterator.close();\n            }\n            return results;\n        } catch (ProcessException e) {\n            throw e;\n        } catch (Throwable e) {\n            LOGGER.warning(\"Error executing method: \" + e);\n            throw new ProcessException(\"Error executing method: \" + e, e);\n        }\n    }", "signature": "FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"measure\", description = \"Measure of the point along the feature to be computed\") Double measure)", "full_signature": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"measure\", description = \"Measure of the point along the feature to be computed\") Double measure)", "class_method_signature": "LRSGeocodeProcess.execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"measure\", description = \"Measure of the point along the feature to be computed\") Double measure)", "testcase": false, "constructor": false, "invocations": ["size", "info", "getDescriptor", "getSchema", "getDescriptor", "getSchema", "createTargetFeatureType", "getSchema", "features", "next", "getValue", "getProperty", "getValue", "getProperty", "getValue", "getDefaultGeometryProperty", "getLength", "getValue", "getDefaultGeometryProperty", "info", "info", "extractPoint", "add", "createTargetFeature", "close", "warning"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}