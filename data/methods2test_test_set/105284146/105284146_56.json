{"test_class": {"identifier": "LocalComputationManagerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String PREFIX = \"test_\";", "modifier": "private static final", "type": "String", "declarator": "PREFIX = \"test_\"", "var_name": "PREFIX"}, {"original_string": "private FileSystem fileSystem;", "modifier": "private", "type": "FileSystem", "declarator": "fileSystem", "var_name": "fileSystem"}, {"original_string": "private Path localDir;", "modifier": "private", "type": "Path", "declarator": "localDir", "var_name": "localDir"}, {"original_string": "private LocalComputationConfig config;", "modifier": "private", "type": "LocalComputationConfig", "declarator": "config", "var_name": "config"}], "file": "computation-local/src/test/java/com/powsybl/computation/local/LocalComputationManagerTest.java"}, "test_case": {"identifier": "test1", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void test1() throws Exception {\n        LocalCommandExecutor localCommandExecutor = new AbstractLocalCommandExecutor() {\n            @Override\n            void nonZeroLog(List<String> cmdLs, int exitCode) {\n\n            }\n\n            @Override\n            public int execute(String program, List<String> args, Path outFile, Path errFile, Path workingDir, Map<String, String> env) throws IOException, InterruptedException {\n                // check command line is correct\n                assertEquals(\"prog1\", program);\n                assertEquals(ImmutableList.of(\"file1\", \"file2\", \"file3\"), args);\n                assertEquals(ImmutableMap.of(\"var1\", \"val1\"), env);\n\n                // check working directory exists, contains inout files and standard output file\n                assertTrue(Files.exists(workingDir));\n                assertEquals(workingDir.resolve(\"prog1_cmd_0.out\").toString(), outFile.toString());\n                assertEquals(workingDir.resolve(\"prog1_cmd_0.err\").toString(), errFile.toString());\n                assertTrue(Files.exists(workingDir.resolve(\"file1\")));\n                assertTrue(Files.exists(workingDir.resolve(\"file2\")));\n                assertTrue(Files.exists(workingDir.resolve(\"file3\")));\n\n                // command exits badly\n                return 1;\n            }\n        };\n        try (ComputationManager computationManager = new LocalComputationManager(config, localCommandExecutor, ForkJoinPool.commonPool())) {\n            computationManager.execute(new ExecutionEnvironment(ImmutableMap.of(\"var1\", \"val1\"), PREFIX, false),\n                    new AbstractExecutionHandler<Object>() {\n                        @Override\n                        public List<CommandExecution> before(Path workingDir) throws IOException {\n                            // create files in the working directory\n                            Files.createFile(workingDir.resolve(\"file1\"));\n                            try (OutputStream os = new GZIPOutputStream(Files.newOutputStream(workingDir.resolve(\"file2.gz\")))) {\n                            }\n                            try (ZipOutputStream os = new ZipOutputStream(Files.newOutputStream(workingDir.resolve(\"file3.zip\")))) {\n                                os.putNextEntry(new ZipEntry(\"file3\"));\n                                os.closeEntry();\n                            }\n\n                            // run the command\n                            Command command = new SimpleCommandBuilder()\n                                    .id(\"prog1_cmd\")\n                                    .program(\"prog1\")\n                                    .args(\"file1\", \"file2\", \"file3\")\n                                    .timeout(60)\n                                    .inputFiles(new InputFile(\"file1\"),\n                                                new InputFile(\"file2.gz\", FilePreProcessor.FILE_GUNZIP),\n                                                new InputFile(\"file3.zip\", FilePreProcessor.ARCHIVE_UNZIP))\n                                    .build();\n                            return Collections.singletonList(new CommandExecution(command, 1));\n                        }\n\n                        @Override\n                        public Object after(Path workingDir, ExecutionReport report) throws IOException {\n                            // check command exits with an error\n                            assertEquals(1, report.getErrors().size());\n                            assertEquals(\"prog1_cmd\", report.getErrors().get(0).getCommand().getId());\n                            assertEquals(0, report.getErrors().get(0).getIndex());\n                            assertEquals(1, report.getErrors().get(0).getExitCode());\n\n                            return null;\n                        }\n                    }).join();\n        }\n    }", "signature": "void test1()", "full_signature": "@Test public void test1()", "class_method_signature": "LocalComputationManagerTest.test1()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "assertEquals", "of", "assertEquals", "of", "assertTrue", "exists", "assertEquals", "toString", "resolve", "toString", "assertEquals", "toString", "resolve", "toString", "assertTrue", "exists", "resolve", "assertTrue", "exists", "resolve", "assertTrue", "exists", "resolve", "commonPool", "join", "execute", "of", "createFile", "resolve", "newOutputStream", "resolve", "newOutputStream", "resolve", "putNextEntry", "closeEntry", "build", "inputFiles", "timeout", "args", "program", "id", "singletonList", "assertEquals", "size", "getErrors", "assertEquals", "getId", "getCommand", "get", "getErrors", "assertEquals", "getIndex", "get", "getErrors", "assertEquals", "getExitCode", "get", "getErrors"]}, "focal_class": {"identifier": "LocalComputationManager", "superclass": "", "interfaces": "implements ComputationManager", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(LocalComputationManager.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(LocalComputationManager.class)", "var_name": "LOGGER"}, {"original_string": "private final LocalComputationConfig config;", "modifier": "private final", "type": "LocalComputationConfig", "declarator": "config", "var_name": "config"}, {"original_string": "private final WorkingDirectory commonDir;", "modifier": "private final", "type": "WorkingDirectory", "declarator": "commonDir", "var_name": "commonDir"}, {"original_string": "private final LocalComputationResourcesStatus status;", "modifier": "private final", "type": "LocalComputationResourcesStatus", "declarator": "status", "var_name": "status"}, {"original_string": "private final Semaphore permits;", "modifier": "private final", "type": "Semaphore", "declarator": "permits", "var_name": "permits"}, {"original_string": "private final Executor threadPool;", "modifier": "private final", "type": "Executor", "declarator": "threadPool", "var_name": "threadPool"}, {"original_string": "private final LocalCommandExecutor localCommandExecutor;", "modifier": "private final", "type": "LocalCommandExecutor", "declarator": "localCommandExecutor", "var_name": "localCommandExecutor"}, {"original_string": "private static final Lock LOCK = new ReentrantLock();", "modifier": "private static final", "type": "Lock", "declarator": "LOCK = new ReentrantLock()", "var_name": "LOCK"}, {"original_string": "private static LocalComputationManager defaultInstance;", "modifier": "private static", "type": "LocalComputationManager", "declarator": "defaultInstance", "var_name": "defaultInstance"}], "methods": [{"identifier": "getDefault", "parameters": "()", "modifiers": "public static", "return": "ComputationManager", "signature": "ComputationManager getDefault()", "full_signature": "public static ComputationManager getDefault()", "class_method_signature": "LocalComputationManager.getDefault()", "testcase": false, "constructor": false}, {"identifier": "getLocalCommandExecutor", "parameters": "()", "modifiers": "private static", "return": "LocalCommandExecutor", "signature": "LocalCommandExecutor getLocalCommandExecutor()", "full_signature": "private static LocalCommandExecutor getLocalCommandExecutor()", "class_method_signature": "LocalComputationManager.getLocalCommandExecutor()", "testcase": false, "constructor": false}, {"identifier": "LocalComputationManager", "parameters": "()", "modifiers": "public", "return": "", "signature": " LocalComputationManager()", "full_signature": "public  LocalComputationManager()", "class_method_signature": "LocalComputationManager.LocalComputationManager()", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(Executor executor)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(Executor executor)", "full_signature": "public  LocalComputationManager(Executor executor)", "class_method_signature": "LocalComputationManager.LocalComputationManager(Executor executor)", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(PlatformConfig platformConfig)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(PlatformConfig platformConfig)", "full_signature": "public  LocalComputationManager(PlatformConfig platformConfig)", "class_method_signature": "LocalComputationManager.LocalComputationManager(PlatformConfig platformConfig)", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(Path localDir)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(Path localDir)", "full_signature": "public  LocalComputationManager(Path localDir)", "class_method_signature": "LocalComputationManager.LocalComputationManager(Path localDir)", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(LocalComputationConfig config)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(LocalComputationConfig config)", "full_signature": "public  LocalComputationManager(LocalComputationConfig config)", "class_method_signature": "LocalComputationManager.LocalComputationManager(LocalComputationConfig config)", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(LocalComputationConfig config, Executor executor)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(LocalComputationConfig config, Executor executor)", "full_signature": "public  LocalComputationManager(LocalComputationConfig config, Executor executor)", "class_method_signature": "LocalComputationManager.LocalComputationManager(LocalComputationConfig config, Executor executor)", "testcase": false, "constructor": true}, {"identifier": "LocalComputationManager", "parameters": "(LocalComputationConfig config, LocalCommandExecutor localCommandExecutor, Executor executor)", "modifiers": "public", "return": "", "signature": " LocalComputationManager(LocalComputationConfig config, LocalCommandExecutor localCommandExecutor, Executor executor)", "full_signature": "public  LocalComputationManager(LocalComputationConfig config, LocalCommandExecutor localCommandExecutor, Executor executor)", "class_method_signature": "LocalComputationManager.LocalComputationManager(LocalComputationConfig config, LocalCommandExecutor localCommandExecutor, Executor executor)", "testcase": false, "constructor": true}, {"identifier": "getVersion", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getVersion()", "full_signature": "@Override public String getVersion()", "class_method_signature": "LocalComputationManager.getVersion()", "testcase": false, "constructor": false}, {"identifier": "getLocalDir", "parameters": "()", "modifiers": "@Override public", "return": "Path", "signature": "Path getLocalDir()", "full_signature": "@Override public Path getLocalDir()", "class_method_signature": "LocalComputationManager.getLocalDir()", "testcase": false, "constructor": false}, {"identifier": "newCommonFile", "parameters": "(String fileName)", "modifiers": "@Override public", "return": "OutputStream", "signature": "OutputStream newCommonFile(String fileName)", "full_signature": "@Override public OutputStream newCommonFile(String fileName)", "class_method_signature": "LocalComputationManager.newCommonFile(String fileName)", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "modifiers": "private", "return": "ExecutionReport", "signature": "ExecutionReport execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "full_signature": "private ExecutionReport execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "class_method_signature": "LocalComputationManager.execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "testcase": false, "constructor": false}, {"identifier": "logExecutingCommand", "parameters": "(Path workingDir, Command command, int executionIndex)", "modifiers": "private", "return": "void", "signature": "void logExecutingCommand(Path workingDir, Command command, int executionIndex)", "full_signature": "private void logExecutingCommand(Path workingDir, Command command, int executionIndex)", "class_method_signature": "LocalComputationManager.logExecutingCommand(Path workingDir, Command command, int executionIndex)", "testcase": false, "constructor": false}, {"identifier": "preProcess", "parameters": "(Path workingDir, Command command, int executionIndex)", "modifiers": "private", "return": "void", "signature": "void preProcess(Path workingDir, Command command, int executionIndex)", "full_signature": "private void preProcess(Path workingDir, Command command, int executionIndex)", "class_method_signature": "LocalComputationManager.preProcess(Path workingDir, Command command, int executionIndex)", "testcase": false, "constructor": false}, {"identifier": "process", "parameters": "(Path workingDir, CommandExecution commandExecution, int executionIndex, Map<String, String> variables, ComputationParameters computationParameters)", "modifiers": "private", "return": "int", "signature": "int process(Path workingDir, CommandExecution commandExecution, int executionIndex, Map<String, String> variables, ComputationParameters computationParameters)", "full_signature": "private int process(Path workingDir, CommandExecution commandExecution, int executionIndex, Map<String, String> variables, ComputationParameters computationParameters)", "class_method_signature": "LocalComputationManager.process(Path workingDir, CommandExecution commandExecution, int executionIndex, Map<String, String> variables, ComputationParameters computationParameters)", "testcase": false, "constructor": false}, {"identifier": "postProcess", "parameters": "(Path workingDir, CommandExecution commandExecution, int executionIndex, int exitValue, List<ExecutionError> errors, ExecutionMonitor monitor)", "modifiers": "private", "return": "void", "signature": "void postProcess(Path workingDir, CommandExecution commandExecution, int executionIndex, int exitValue, List<ExecutionError> errors, ExecutionMonitor monitor)", "full_signature": "private void postProcess(Path workingDir, CommandExecution commandExecution, int executionIndex, int exitValue, List<ExecutionError> errors, ExecutionMonitor monitor)", "class_method_signature": "LocalComputationManager.postProcess(Path workingDir, CommandExecution commandExecution, int executionIndex, int exitValue, List<ExecutionError> errors, ExecutionMonitor monitor)", "testcase": false, "constructor": false}, {"identifier": "checkInputFileExistsInWorkingAndCommons", "parameters": "(Path workingDir, String fileName, InputFile file)", "modifiers": "private", "return": "Path", "signature": "Path checkInputFileExistsInWorkingAndCommons(Path workingDir, String fileName, InputFile file)", "full_signature": "private Path checkInputFileExistsInWorkingAndCommons(Path workingDir, String fileName, InputFile file)", "class_method_signature": "LocalComputationManager.checkInputFileExistsInWorkingAndCommons(Path workingDir, String fileName, InputFile file)", "testcase": false, "constructor": false}, {"identifier": "enter", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void enter()", "full_signature": "private void enter()", "class_method_signature": "LocalComputationManager.enter()", "testcase": false, "constructor": false}, {"identifier": "exit", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void exit()", "full_signature": "private void exit()", "class_method_signature": "LocalComputationManager.exit()", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "(ExecutionEnvironment environment, ExecutionHandler<R> handler)", "modifiers": "@Override public", "return": "CompletableFuture<R>", "signature": "CompletableFuture<R> execute(ExecutionEnvironment environment, ExecutionHandler<R> handler)", "full_signature": "@Override public CompletableFuture<R> execute(ExecutionEnvironment environment, ExecutionHandler<R> handler)", "class_method_signature": "LocalComputationManager.execute(ExecutionEnvironment environment, ExecutionHandler<R> handler)", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "modifiers": "@Override public", "return": "CompletableFuture<R>", "signature": "CompletableFuture<R> execute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "full_signature": "@Override public CompletableFuture<R> execute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "class_method_signature": "LocalComputationManager.execute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "testcase": false, "constructor": false}, {"identifier": "doExecute", "parameters": "(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "modifiers": "private", "return": "R", "signature": "R doExecute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "full_signature": "private R doExecute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "class_method_signature": "LocalComputationManager.doExecute(ExecutionEnvironment environment, ExecutionHandler<R> handler, ComputationParameters parameters)", "testcase": false, "constructor": false}, {"identifier": "getResourcesStatus", "parameters": "()", "modifiers": "@Override public", "return": "ComputationResourcesStatus", "signature": "ComputationResourcesStatus getResourcesStatus()", "full_signature": "@Override public ComputationResourcesStatus getResourcesStatus()", "class_method_signature": "LocalComputationManager.getResourcesStatus()", "testcase": false, "constructor": false}, {"identifier": "getExecutor", "parameters": "()", "modifiers": "@Override public", "return": "Executor", "signature": "Executor getExecutor()", "full_signature": "@Override public Executor getExecutor()", "class_method_signature": "LocalComputationManager.getExecutor()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "LocalComputationManager.close()", "testcase": false, "constructor": false}], "file": "computation-local/src/main/java/com/powsybl/computation/local/LocalComputationManager.java"}, "focal_method": {"identifier": "execute", "parameters": "(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "modifiers": "private", "return": "ExecutionReport", "body": "private ExecutionReport execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)\n            throws InterruptedException {\n        // TODO concurrent\n        List<ExecutionError> errors = new ArrayList<>();\n        ExecutorService executionSubmitter = Executors.newCachedThreadPool();\n\n        for (CommandExecution commandExecution : commandExecutionList) {\n            Command command = commandExecution.getCommand();\n            CountDownLatch latch = new CountDownLatch(commandExecution.getExecutionCount());\n            IntStream.range(0, commandExecution.getExecutionCount()).forEach(idx ->\n                    executionSubmitter.execute(() -> {\n                        try {\n                            enter();\n                            logExecutingCommand(workingDir, command, idx);\n                            preProcess(workingDir, command, idx);\n                            int exitValue = process(workingDir, commandExecution, idx, variables, computationParameters);\n                            postProcess(workingDir, commandExecution, idx, exitValue, errors, monitor);\n                        } catch (Exception e) {\n                            LOGGER.warn(e.getMessage());\n                        } finally {\n                            latch.countDown();\n                            exit();\n                        }\n                    })\n            );\n            latch.await();\n        }\n\n        // TODO remove duplicated code\n        executionSubmitter.shutdown();\n        if (!executionSubmitter.awaitTermination(20, TimeUnit.SECONDS)) {\n            executionSubmitter.shutdownNow();\n            if (!executionSubmitter.awaitTermination(20, TimeUnit.SECONDS)) {\n                LOGGER.error(\"Thread pool did not terminate\");\n            }\n        }\n\n        return new DefaultExecutionReport(errors);\n    }", "signature": "ExecutionReport execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "full_signature": "private ExecutionReport execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "class_method_signature": "LocalComputationManager.execute(Path workingDir, List<CommandExecution> commandExecutionList, Map<String, String> variables, ComputationParameters computationParameters, ExecutionMonitor monitor)", "testcase": false, "constructor": false, "invocations": ["newCachedThreadPool", "getCommand", "getExecutionCount", "forEach", "range", "getExecutionCount", "execute", "enter", "logExecutingCommand", "preProcess", "process", "postProcess", "warn", "getMessage", "countDown", "exit", "await", "shutdown", "awaitTermination", "shutdownNow", "awaitTermination", "error"]}, "repository": {"repo_id": 105284146, "url": "https://github.com/powsybl/powsybl-core", "stars": 53, "created": "9/29/2017 2:51:18 PM +00:00", "updates": "2020-01-27T10:39:13+00:00", "fork": "False", "license": "licensed"}}