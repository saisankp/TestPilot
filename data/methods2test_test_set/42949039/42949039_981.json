{"test_class": {"identifier": "DownloaderControllerTest", "superclass": "extends AbstractDownloaderTest", "interfaces": "", "fields": [], "file": "herd-code/herd-tools/herd-downloader/src/test/java/org/finra/herd/tools/downloader/DownloaderControllerTest.java"}, "test_case": {"identifier": "testPerformDownloadAssertCleanTargetDirectoryWhenError", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testPerformDownloadAssertCleanTargetDirectoryWhenError() throws Exception\n    {\n        /*\n         * Create and inject mock objects\n         */\n        DownloaderWebClient mockDownloaderWebClient = mock(DownloaderWebClient.class);\n        DownloaderWebClient originalDownloaderWebClient = (DownloaderWebClient) ReflectionTestUtils.getField(downloaderController, \"downloaderWebClient\");\n        ReflectionTestUtils.setField(downloaderController, \"downloaderWebClient\", mockDownloaderWebClient);\n\n        DownloaderManifestReader mockDownloaderManifestReader = mock(DownloaderManifestReader.class);\n        DownloaderManifestReader originalDownloaderManifestReader =\n            (DownloaderManifestReader) ReflectionTestUtils.getField(downloaderController, \"manifestReader\");\n        ReflectionTestUtils.setField(downloaderController, \"manifestReader\", mockDownloaderManifestReader);\n\n        BusinessObjectDataHelper mockBusinessObjectDataHelper = mock(BusinessObjectDataHelper.class);\n        BusinessObjectDataHelper originalBusinessObjectDataHelper =\n            (BusinessObjectDataHelper) ReflectionTestUtils.getField(downloaderController, \"businessObjectDataHelper\");\n        ReflectionTestUtils.setField(downloaderController, \"businessObjectDataHelper\", mockBusinessObjectDataHelper);\n\n        S3Service mockS3Service = mock(S3Service.class);\n        S3Service originalS3Service = (S3Service) ReflectionTestUtils.getField(downloaderController, \"s3Service\");\n        ReflectionTestUtils.setField(downloaderController, \"s3Service\", mockS3Service);\n\n        StorageFileHelper mockStorageFileHelper = mock(StorageFileHelper.class);\n        StorageFileHelper originalStorageFileHelper = (StorageFileHelper) ReflectionTestUtils.getField(downloaderController, \"storageFileHelper\");\n        ReflectionTestUtils.setField(downloaderController, \"storageFileHelper\", mockStorageFileHelper);\n\n        StorageHelper mockStorageHelper = mock(StorageHelper.class);\n        StorageHelper originalStorageHelper = (StorageHelper) ReflectionTestUtils.getField(downloaderController, \"storageHelper\");\n        ReflectionTestUtils.setField(downloaderController, \"storageHelper\", mockStorageHelper);\n\n        /*\n         * Start test\n         */\n        Path localPath = Files.createTempDirectory(null);\n        try\n        {\n            String s3KeyPrefix = \"s3KeyPrefix\";\n            String storageName = \"storageName\";\n            IOException expectedException = new IOException();\n            Path targetDirectoryPath = localPath.resolve(s3KeyPrefix);\n\n            DownloaderInputManifestDto downloaderInputManifestDto = new DownloaderInputManifestDto();\n            BusinessObjectData businessObjectData = new BusinessObjectData();\n            StorageUnit storageUnit = new StorageUnit(new Storage(storageName, null, null), null, null, StorageUnitStatusEntity.ENABLED, null, null, null);\n            S3KeyPrefixInformation s3KeyPrefixInformation = new S3KeyPrefixInformation();\n            s3KeyPrefixInformation.setS3KeyPrefix(s3KeyPrefix);\n\n            /*\n             * Mock operations on mocked dependencies\n             */\n            when(mockDownloaderManifestReader.readJsonManifest(any())).thenReturn(downloaderInputManifestDto);\n            when(mockDownloaderWebClient.getBusinessObjectData(any())).thenReturn(businessObjectData);\n            when(mockBusinessObjectDataHelper.getStorageUnitByStorageName(any(), any())).thenReturn(storageUnit);\n            when(mockDownloaderWebClient.getS3KeyPrefix(any())).thenReturn(s3KeyPrefixInformation);\n            when(mockS3Service.downloadDirectory(any())).then(new Answer<S3FileTransferResultsDto>()\n            {\n                @Override\n                public S3FileTransferResultsDto answer(InvocationOnMock invocation) throws Throwable\n                {\n                    Files.createFile(targetDirectoryPath.resolve(\"file\"));\n                    throw expectedException;\n                }\n            });\n\n            /*\n             * Make the call to the method under test\n             */\n            RegServerAccessParamsDto regServerAccessParamsDto = null;\n            File manifestPath = null;\n            S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto = new S3FileTransferRequestParamsDto();\n            s3FileTransferRequestParamsDto.setLocalPath(localPath.toString());\n            s3FileTransferRequestParamsDto.setMaxThreads(1);\n\n            try\n            {\n                downloaderController.performDownload(regServerAccessParamsDto, manifestPath, s3FileTransferRequestParamsDto);\n                // Expect an exception, fail if no exception\n                fail();\n            }\n            catch (Exception e)\n            {\n                // Assert that the exception thrown by the mock is what is actually thrown\n                assertEquals(expectedException, e);\n                // Assert that the target directory is cleaned\n                assertEquals(0, targetDirectoryPath.toFile().list().length);\n            }\n        }\n        finally\n        {\n            /*\n             * Restore mocked dependencies to their original implementation\n             */\n            ReflectionTestUtils.setField(downloaderController, \"downloaderWebClient\", originalDownloaderWebClient);\n            ReflectionTestUtils.setField(downloaderController, \"manifestReader\", originalDownloaderManifestReader);\n            ReflectionTestUtils.setField(downloaderController, \"businessObjectDataHelper\", originalBusinessObjectDataHelper);\n            ReflectionTestUtils.setField(downloaderController, \"s3Service\", originalS3Service);\n            ReflectionTestUtils.setField(downloaderController, \"storageFileHelper\", originalStorageFileHelper);\n            ReflectionTestUtils.setField(downloaderController, \"storageHelper\", originalStorageHelper);\n\n            // Clean up any temporary files\n            FileUtils.deleteDirectory(localPath.toFile());\n        }\n    }", "signature": "void testPerformDownloadAssertCleanTargetDirectoryWhenError()", "full_signature": "@Test public void testPerformDownloadAssertCleanTargetDirectoryWhenError()", "class_method_signature": "DownloaderControllerTest.testPerformDownloadAssertCleanTargetDirectoryWhenError()", "testcase": true, "constructor": false, "invocations": ["mock", "getField", "setField", "mock", "getField", "setField", "mock", "getField", "setField", "mock", "getField", "setField", "mock", "getField", "setField", "mock", "getField", "setField", "createTempDirectory", "resolve", "setS3KeyPrefix", "thenReturn", "when", "readJsonManifest", "any", "thenReturn", "when", "getBusinessObjectData", "any", "thenReturn", "when", "getStorageUnitByStorageName", "any", "any", "thenReturn", "when", "getS3KeyPrefix", "any", "then", "when", "downloadDirectory", "any", "createFile", "resolve", "setLocalPath", "toString", "setMaxThreads", "performDownload", "fail", "assertEquals", "assertEquals", "list", "toFile", "setField", "setField", "setField", "setField", "setField", "setField", "deleteDirectory", "toFile"]}, "focal_class": {"identifier": "DownloaderController", "superclass": "extends DataBridgeController", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(DownloaderController.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(DownloaderController.class)", "var_name": "LOGGER"}, {"original_string": "@Autowired\n    private BusinessObjectDataHelper businessObjectDataHelper;", "modifier": "@Autowired\n    private", "type": "BusinessObjectDataHelper", "declarator": "businessObjectDataHelper", "var_name": "businessObjectDataHelper"}, {"original_string": "@Autowired\n    private ConfigurationHelper configurationHelper;", "modifier": "@Autowired\n    private", "type": "ConfigurationHelper", "declarator": "configurationHelper", "var_name": "configurationHelper"}, {"original_string": "@Autowired\n    private DownloaderManifestReader manifestReader;", "modifier": "@Autowired\n    private", "type": "DownloaderManifestReader", "declarator": "manifestReader", "var_name": "manifestReader"}, {"original_string": "@Autowired\n    private DownloaderManifestWriter manifestWriter;", "modifier": "@Autowired\n    private", "type": "DownloaderManifestWriter", "declarator": "manifestWriter", "var_name": "manifestWriter"}, {"original_string": "@Autowired\n    private DownloaderWebClient downloaderWebClient;", "modifier": "@Autowired\n    private", "type": "DownloaderWebClient", "declarator": "downloaderWebClient", "var_name": "downloaderWebClient"}, {"original_string": "@Autowired\n    private StorageFileHelper storageFileHelper;", "modifier": "@Autowired\n    private", "type": "StorageFileHelper", "declarator": "storageFileHelper", "var_name": "storageFileHelper"}, {"original_string": "@Autowired\n    private StorageHelper storageHelper;", "modifier": "@Autowired\n    private", "type": "StorageHelper", "declarator": "storageHelper", "var_name": "storageHelper"}, {"original_string": "private static final String OUTPUT_MANIFEST_FILE_NAME = \"manifest.json\";", "modifier": "private static final", "type": "String", "declarator": "OUTPUT_MANIFEST_FILE_NAME = \"manifest.json\"", "var_name": "OUTPUT_MANIFEST_FILE_NAME"}], "methods": [{"identifier": "performDownload", "parameters": "(RegServerAccessParamsDto regServerAccessParamsDto, File manifestPath,\n        S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto)", "modifiers": "@SuppressFBWarnings(value = {\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\", \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\"}, justification = \"manifestReader.readJsonManifest will always return an DownloaderInputManifestDto object. targetLocalDirectory.list().length will not\" + \" return a NullPointerException.\") public", "return": "void", "signature": "void performDownload(RegServerAccessParamsDto regServerAccessParamsDto, File manifestPath,\n        S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto)", "full_signature": "@SuppressFBWarnings(value = {\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\", \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\"}, justification = \"manifestReader.readJsonManifest will always return an DownloaderInputManifestDto object. targetLocalDirectory.list().length will not\" + \" return a NullPointerException.\") public void performDownload(RegServerAccessParamsDto regServerAccessParamsDto, File manifestPath,\n        S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto)", "class_method_signature": "DownloaderController.performDownload(RegServerAccessParamsDto regServerAccessParamsDto, File manifestPath,\n        S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto)", "testcase": false, "constructor": false}, {"identifier": "logLocalDirectoryContents", "parameters": "(File directory)", "modifiers": "private", "return": "void", "signature": "void logLocalDirectoryContents(File directory)", "full_signature": "private void logLocalDirectoryContents(File directory)", "class_method_signature": "DownloaderController.logLocalDirectoryContents(File directory)", "testcase": false, "constructor": false}, {"identifier": "createDownloaderOutputManifestDto", "parameters": "(BusinessObjectData businessObjectData, StorageUnit storageUnit, String s3KeyPrefix)", "modifiers": "protected", "return": "DownloaderOutputManifestDto", "signature": "DownloaderOutputManifestDto createDownloaderOutputManifestDto(BusinessObjectData businessObjectData, StorageUnit storageUnit, String s3KeyPrefix)", "full_signature": "protected DownloaderOutputManifestDto createDownloaderOutputManifestDto(BusinessObjectData businessObjectData, StorageUnit storageUnit, String s3KeyPrefix)", "class_method_signature": "DownloaderController.createDownloaderOutputManifestDto(BusinessObjectData businessObjectData, StorageUnit storageUnit, String s3KeyPrefix)", "testcase": false, "constructor": false}], "file": "herd-code/herd-tools/herd-downloader/src/main/java/org/finra/herd/tools/downloader/DownloaderController.java"}, "focal_method": {"identifier": "performDownload", "parameters": "(RegServerAccessParamsDto regServerAccessParamsDto, File manifestPath,\n        S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto)", "modifiers": "@SuppressFBWarnings(value = {\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\", \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\"}, justification = \"manifestReader.readJsonManifest will always return an DownloaderInputManifestDto object. targetLocalDirectory.list().length will not\" + \" return a NullPointerException.\") public", "return": "void", "body": "@SuppressFBWarnings(value = {\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\", \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\"}, justification =\n        \"manifestReader.readJsonManifest will always return an DownloaderInputManifestDto object. targetLocalDirectory.list().length will not\" +\n            \" return a NullPointerException.\")\n    public void performDownload(RegServerAccessParamsDto regServerAccessParamsDto, File manifestPath,\n        S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto)\n        throws InterruptedException, JAXBException, IOException, URISyntaxException, NoSuchAlgorithmException, KeyStoreException, KeyManagementException\n    {\n        boolean cleanUpTargetLocalDirectoryOnFailure = false;\n        File targetLocalDirectory = null;\n\n        try\n        {\n            // Process manifest file.\n            DownloaderInputManifestDto manifest = manifestReader.readJsonManifest(manifestPath);\n\n            String storageName = getStorageNameFromManifest(manifest);\n\n            // Get business object data from the herd registration server.\n            downloaderWebClient.setRegServerAccessParamsDto(regServerAccessParamsDto);\n            BusinessObjectData businessObjectData = downloaderWebClient.getBusinessObjectData(manifest);\n\n            manifest.setBusinessObjectDataVersion(String.valueOf(businessObjectData.getVersion()));\n            manifest.setBusinessObjectFormatVersion(String.valueOf(businessObjectData.getBusinessObjectFormatVersion()));\n            s3FileTransferRequestParamsDto.getAdditionalAwsCredentialsProviders().add(new AutoRefreshCredentialProvider()\n            {\n                @Override\n                public AwsCredential getNewAwsCredential() throws Exception\n                {\n                    return downloaderWebClient.getStorageUnitDownloadCredential(manifest, storageName).getAwsCredential();\n                }\n            });\n\n            // Get a storage unit that belongs to the S3 storage.\n            StorageUnit storageUnit = businessObjectDataHelper.getStorageUnitByStorageName(businessObjectData, storageName);\n\n            // Get the expected S3 key prefix and S3 bucket name.\n            S3KeyPrefixInformation s3KeyPrefixInformation = downloaderWebClient.getS3KeyPrefix(businessObjectData);\n\n            // Check if the target folder (local directory + S3 key prefix) exists and try to create it if it does not.\n            targetLocalDirectory = Paths.get(s3FileTransferRequestParamsDto.getLocalPath(), s3KeyPrefixInformation.getS3KeyPrefix()).toFile();\n            if (!targetLocalDirectory.isDirectory())\n            {\n                // Create the local directory including any necessary but nonexistent parent directories.\n                if (!targetLocalDirectory.mkdirs())\n                {\n                    throw new IllegalArgumentException(String.format(\"Failed to create target local directory \\\"%s\\\".\", targetLocalDirectory.getPath()));\n                }\n            }\n            else\n            {\n                // Check if the target local directory is empty.\n                if (targetLocalDirectory.list().length > 0)\n                {\n                    throw new IllegalArgumentException(String.format(\"The target local directory \\\"%s\\\" is not empty.\", targetLocalDirectory.getPath()));\n                }\n            }\n\n            // Get S3 bucket information.\n            Storage storage = downloaderWebClient.getStorage(storageName);\n\n            // Get S3 bucket name.  Please note that since this value is required we pass a \"true\" flag.\n            String s3BucketName =\n                storageHelper.getStorageAttributeValueByName(configurationHelper.getProperty(ConfigurationValue.S3_ATTRIBUTE_NAME_BUCKET_NAME), storage, true);\n\n            // Get the list of S3 files matching the expected S3 key prefix.\n            s3FileTransferRequestParamsDto.setS3BucketName(s3BucketName);\n            // Since the S3 key prefix represents a directory, we add a trailing '/' character to it.\n            s3FileTransferRequestParamsDto.setS3KeyPrefix(s3KeyPrefixInformation.getS3KeyPrefix() + \"/\");\n            // When listing S3 files, we ignore 0 byte objects that represent S3 directories.\n            List<String> actualS3Files = storageFileHelper.getFilePathsFromS3ObjectSummaries(s3Service.listDirectory(s3FileTransferRequestParamsDto, true));\n\n            // Validate S3 files before we start the download.\n            storageFileHelper.validateStorageUnitS3Files(storageUnit, actualS3Files, s3KeyPrefixInformation.getS3KeyPrefix());\n\n            // Special handling for the maxThreads command line option.\n            s3FileTransferRequestParamsDto.setMaxThreads(adjustIntegerValue(s3FileTransferRequestParamsDto.getMaxThreads(), MIN_THREADS, MAX_THREADS));\n\n            // Download S3 files to the target local directory.\n            s3FileTransferRequestParamsDto.setRecursive(true);\n            cleanUpTargetLocalDirectoryOnFailure = true;\n            s3Service.downloadDirectory(s3FileTransferRequestParamsDto);\n\n            // Validate the downloaded files.\n            storageFileHelper.validateDownloadedS3Files(s3FileTransferRequestParamsDto.getLocalPath(), s3KeyPrefixInformation.getS3KeyPrefix(), storageUnit);\n\n            // Log a list of files downloaded to the target local directory.\n            if (LOGGER.isInfoEnabled())\n            {\n                logLocalDirectoryContents(targetLocalDirectory);\n            }\n\n            // Create a downloader output manifest file.\n            DownloaderOutputManifestDto downloaderOutputManifestDto =\n                createDownloaderOutputManifestDto(businessObjectData, storageUnit, s3KeyPrefixInformation.getS3KeyPrefix());\n            manifestWriter.writeJsonManifest(targetLocalDirectory, OUTPUT_MANIFEST_FILE_NAME, downloaderOutputManifestDto);\n        }\n        catch (InterruptedException | JAXBException | IOException | URISyntaxException e)\n        {\n            // If we got to the point of validating the target local directory being empty before this failure\n            // occurred, let's rollback the data transfer by cleaning up the local target directory.\n            if (cleanUpTargetLocalDirectoryOnFailure)\n            {\n                LOGGER.info(String.format(\"Rolling back the S3 data transfer by cleaning up \\\"%s\\\" target local directory.\", targetLocalDirectory));\n                HerdFileUtils.cleanDirectoryIgnoreException(targetLocalDirectory);\n            }\n\n            throw e;\n        }\n    }", "signature": "void performDownload(RegServerAccessParamsDto regServerAccessParamsDto, File manifestPath,\n        S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto)", "full_signature": "@SuppressFBWarnings(value = {\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\", \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\"}, justification = \"manifestReader.readJsonManifest will always return an DownloaderInputManifestDto object. targetLocalDirectory.list().length will not\" + \" return a NullPointerException.\") public void performDownload(RegServerAccessParamsDto regServerAccessParamsDto, File manifestPath,\n        S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto)", "class_method_signature": "DownloaderController.performDownload(RegServerAccessParamsDto regServerAccessParamsDto, File manifestPath,\n        S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto)", "testcase": false, "constructor": false, "invocations": ["readJsonManifest", "getStorageNameFromManifest", "setRegServerAccessParamsDto", "getBusinessObjectData", "setBusinessObjectDataVersion", "valueOf", "getVersion", "setBusinessObjectFormatVersion", "valueOf", "getBusinessObjectFormatVersion", "add", "getAdditionalAwsCredentialsProviders", "getAwsCredential", "getStorageUnitDownloadCredential", "getStorageUnitByStorageName", "getS3KeyPrefix", "toFile", "get", "getLocalPath", "getS3KeyPrefix", "isDirectory", "mkdirs", "format", "getPath", "list", "format", "getPath", "getStorage", "getStorageAttributeValueByName", "getProperty", "setS3BucketName", "setS3KeyPrefix", "getS3KeyPrefix", "getFilePathsFromS3ObjectSummaries", "listDirectory", "validateStorageUnitS3Files", "getS3KeyPrefix", "setMaxThreads", "adjustIntegerValue", "getMaxThreads", "setRecursive", "downloadDirectory", "validateDownloadedS3Files", "getLocalPath", "getS3KeyPrefix", "isInfoEnabled", "logLocalDirectoryContents", "createDownloaderOutputManifestDto", "getS3KeyPrefix", "writeJsonManifest", "info", "format", "cleanDirectoryIgnoreException"]}, "repository": {"repo_id": 42949039, "url": "https://github.com/FINRAOS/herd", "language": "Java", "is_fork": false, "fork_count": 36, "stargazer_count": 120, "size": 205797, "license": "licensed"}}