{"test_class": {"identifier": "TestGoldenGateEventProducer", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static Logger LOG = Logger.getLogger(TestGoldenGateEventProducer.class);", "modifier": "public static", "type": "Logger", "declarator": "LOG = Logger.getLogger(TestGoldenGateEventProducer.class)", "var_name": "LOG"}, {"original_string": "private final String avroSchema =\n    \"{\" +\n    \"\\\"type\\\" : \\\"record\\\",\" +\n    \"\\\"name\\\" : \\\"user\\\",\" +\n    \"\\\"namespace\\\" : \\\"my.example\\\",\" +\n    \"\\\"fields\\\" : [{\\\"name\\\" : \\\"name\\\", \\\"type\\\" : \\\"string\\\"}]\" +\n    \"}\";", "modifier": "private final", "type": "String", "declarator": "avroSchema =\n    \"{\" +\n    \"\\\"type\\\" : \\\"record\\\",\" +\n    \"\\\"name\\\" : \\\"user\\\",\" +\n    \"\\\"namespace\\\" : \\\"my.example\\\",\" +\n    \"\\\"fields\\\" : [{\\\"name\\\" : \\\"name\\\", \\\"type\\\" : \\\"string\\\"}]\" +\n    \"}\"", "var_name": "avroSchema"}, {"original_string": "private final String avroSchema2 =\n      \"{\" +\n      \"\\\"type\\\" : \\\"record\\\",\" +\n      \"\\\"name\\\" : \\\"user\\\",\" +\n      \"\\\"namespace\\\" : \\\"my.example\\\",\" +\n      \"\\\"fields\\\" : [{\\\"name\\\" : \\\"name1\\\", \\\"type\\\" : \\\"string\\\"},\" +\n      \"              {\\\"name\\\" : \\\"name2\\\", \\\"type\\\" : \\\"string\\\"}]\" +\n      \"}\";", "modifier": "private final", "type": "String", "declarator": "avroSchema2 =\n      \"{\" +\n      \"\\\"type\\\" : \\\"record\\\",\" +\n      \"\\\"name\\\" : \\\"user\\\",\" +\n      \"\\\"namespace\\\" : \\\"my.example\\\",\" +\n      \"\\\"fields\\\" : [{\\\"name\\\" : \\\"name1\\\", \\\"type\\\" : \\\"string\\\"},\" +\n      \"              {\\\"name\\\" : \\\"name2\\\", \\\"type\\\" : \\\"string\\\"}]\" +\n      \"}\"", "var_name": "avroSchema2"}, {"original_string": "private final String sourceAvroSchema = \"{\"\n  + \"  \\\"name\\\" : \\\"Shortlinks_V3\\\",  \"\n  + \"   \\\"doc\\\" : \\\"Auto-generated Avro schema for SHORTLINKS. Generated at May 21, 2013 12:05:14 PM PDT\\\",\"\n  + \" \\\"type\\\" : \\\"record\\\", \"\n  + \"   \\\"meta\\\" : \\\"dbFieldName=SHORTLINKS;dbFieldType=SHORTLINKS;pk=linkCode;\\\",\"\n  + \"   \\\"fields\\\" : [ {\"\n  + \"     \\\"name\\\" : \\\"linkCode\\\", \"\n  + \"     \\\"type\\\" : [ \\\"string\\\", \\\"null\\\" ],\"\n  + \"     \\\"meta\\\" : \\\"dbFieldName=LINK_CODE;dbFieldPosition=0;dbFieldType=VARCHAR2;\\\"\"\n  + \"   }, {\"\n  + \"     \\\"name\\\" : \\\"ggModiTs\\\",\"\n  + \"     \\\"type\\\" : [ \\\"long\\\", \\\"null\\\" ],\"\n  + \"     \\\"meta\\\" : \\\"dbFieldName=GG_MODI_TS;dbFieldPosition=8;dbFieldType=TIMESTAMP;\\\"\"\n  + \"   }, {\"\n  + \"     \\\"name\\\" : \\\"ggStatus\\\",\"\n  + \"     \\\"type\\\" : [ \\\"string\\\", \\\"null\\\" ],\"\n  + \"     \\\"meta\\\" : \\\"dbFieldName=GG_STATUS;dbFieldPosition=9;dbFieldType=VARCHAR2;\\\"\"\n  + \"   } ],\"\n  + \"   \\\"namespace\\\" : \\\"com.linkedin.events.sourc\\\"\"\n  + \" }\";", "modifier": "private final", "type": "String", "declarator": "sourceAvroSchema = \"{\"\n  + \"  \\\"name\\\" : \\\"Shortlinks_V3\\\",  \"\n  + \"   \\\"doc\\\" : \\\"Auto-generated Avro schema for SHORTLINKS. Generated at May 21, 2013 12:05:14 PM PDT\\\",\"\n  + \" \\\"type\\\" : \\\"record\\\", \"\n  + \"   \\\"meta\\\" : \\\"dbFieldName=SHORTLINKS;dbFieldType=SHORTLINKS;pk=linkCode;\\\",\"\n  + \"   \\\"fields\\\" : [ {\"\n  + \"     \\\"name\\\" : \\\"linkCode\\\", \"\n  + \"     \\\"type\\\" : [ \\\"string\\\", \\\"null\\\" ],\"\n  + \"     \\\"meta\\\" : \\\"dbFieldName=LINK_CODE;dbFieldPosition=0;dbFieldType=VARCHAR2;\\\"\"\n  + \"   }, {\"\n  + \"     \\\"name\\\" : \\\"ggModiTs\\\",\"\n  + \"     \\\"type\\\" : [ \\\"long\\\", \\\"null\\\" ],\"\n  + \"     \\\"meta\\\" : \\\"dbFieldName=GG_MODI_TS;dbFieldPosition=8;dbFieldType=TIMESTAMP;\\\"\"\n  + \"   }, {\"\n  + \"     \\\"name\\\" : \\\"ggStatus\\\",\"\n  + \"     \\\"type\\\" : [ \\\"string\\\", \\\"null\\\" ],\"\n  + \"     \\\"meta\\\" : \\\"dbFieldName=GG_STATUS;dbFieldPosition=9;dbFieldType=VARCHAR2;\\\"\"\n  + \"   } ],\"\n  + \"   \\\"namespace\\\" : \\\"com.linkedin.events.sourc\\\"\"\n  + \" }\"", "var_name": "sourceAvroSchema"}, {"original_string": "private final String SCNPATTERN = \"SCNPATTERN\";", "modifier": "private final", "type": "String", "declarator": "SCNPATTERN = \"SCNPATTERN\"", "var_name": "SCNPATTERN"}, {"original_string": "private final String _transactionPattern = \"\"\n  + \"<transaction timestamp=\\\"2013-07-29:13:26:15.000000\\\">\\n\"\n  + \"<dbupdate table=\\\"part1.source1\\\" type=\\\"insert\\\">\\n\"\n  + \"    <columns>\\n\"\n  + \"      <column name=\\\"LINK_CODE\\\" key=\\\"true\\\">100</column>\\n\"\n  + \"      <column name=\\\"GG_MODI_TS\\\">2013-07-28:13:26:15.208130000</column>\\n\"\n  + \"      <column name=\\\"GG_STATUS\\\">o</column>\\n\"\n  + \"    </columns>\\n\"\n  + \"    <tokens>\\n\"\n  + \"      <token name=\\\"TK-XID\\\">4.24.94067</token>\\n\"\n  + \"      <token name=\\\"TK-CSN\\\">\" + SCNPATTERN + \"</token>\\n\"\n  + \"      <token name=\\\"TK-UNAME\\\">SOURCE1</token>\\n\"\n  + \"    </tokens>\\n\"\n  + \"  </dbupdate>\\n\"\n  + \"  <dbupdate table=\\\"part1.source2\\\" type=\\\"insert\\\">\\n\"\n  + \"    <columns>\\n\"\n  + \"      <column name=\\\"LINK_CODE\\\" key=\\\"true\\\">101</column>\\n\"\n  + \"      <column name=\\\"GG_MODI_TS\\\">2013-07-29:13:26:15.212166000</column>\\n\"\n  + \"      <column name=\\\"GG_STATUS\\\">o</column>\\n\"\n  + \"    </columns>\\n\"\n  + \"    <tokens>\\n\"\n  + \"      <token name=\\\"TK-XID\\\">4.24.94067</token>\\n\"\n  + \"      <token name=\\\"TK-CSN\\\">\" + SCNPATTERN + \"</token>\\n\"\n  + \"      <token name=\\\"TK-UNAME\\\">SOURCE2</token>\\n\"\n  + \"    </tokens>\\n\"\n  + \"  </dbupdate>\\n\"\n  + \"</transaction>\";", "modifier": "private final", "type": "String", "declarator": "_transactionPattern = \"\"\n  + \"<transaction timestamp=\\\"2013-07-29:13:26:15.000000\\\">\\n\"\n  + \"<dbupdate table=\\\"part1.source1\\\" type=\\\"insert\\\">\\n\"\n  + \"    <columns>\\n\"\n  + \"      <column name=\\\"LINK_CODE\\\" key=\\\"true\\\">100</column>\\n\"\n  + \"      <column name=\\\"GG_MODI_TS\\\">2013-07-28:13:26:15.208130000</column>\\n\"\n  + \"      <column name=\\\"GG_STATUS\\\">o</column>\\n\"\n  + \"    </columns>\\n\"\n  + \"    <tokens>\\n\"\n  + \"      <token name=\\\"TK-XID\\\">4.24.94067</token>\\n\"\n  + \"      <token name=\\\"TK-CSN\\\">\" + SCNPATTERN + \"</token>\\n\"\n  + \"      <token name=\\\"TK-UNAME\\\">SOURCE1</token>\\n\"\n  + \"    </tokens>\\n\"\n  + \"  </dbupdate>\\n\"\n  + \"  <dbupdate table=\\\"part1.source2\\\" type=\\\"insert\\\">\\n\"\n  + \"    <columns>\\n\"\n  + \"      <column name=\\\"LINK_CODE\\\" key=\\\"true\\\">101</column>\\n\"\n  + \"      <column name=\\\"GG_MODI_TS\\\">2013-07-29:13:26:15.212166000</column>\\n\"\n  + \"      <column name=\\\"GG_STATUS\\\">o</column>\\n\"\n  + \"    </columns>\\n\"\n  + \"    <tokens>\\n\"\n  + \"      <token name=\\\"TK-XID\\\">4.24.94067</token>\\n\"\n  + \"      <token name=\\\"TK-CSN\\\">\" + SCNPATTERN + \"</token>\\n\"\n  + \"      <token name=\\\"TK-UNAME\\\">SOURCE2</token>\\n\"\n  + \"    </tokens>\\n\"\n  + \"  </dbupdate>\\n\"\n  + \"</transaction>\"", "var_name": "_transactionPattern"}, {"original_string": "private final int _transactionPatternSize = _transactionPattern.length() - 7*2;", "modifier": "private final", "type": "int", "declarator": "_transactionPatternSize = _transactionPattern.length() - 7*2", "var_name": "_transactionPatternSize"}], "file": "databus2-relay/databus2-relay-impl/src/test/java/com/linkedin/databus2/relay/TestGoldenGateEventProducer.java"}, "test_case": {"identifier": "testAddEventToBuffer", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testAddEventToBuffer() throws InvalidConfigException,\n      UnsupportedKeyException, DatabusException\n  {\n    // No rate control\n    long rate = 0;\n    PhysicalSourceStaticConfig pssc = buildPssc(rate, 0L);\n    long scn = 10;\n    DbusEventBuffer mb = (DbusEventBuffer)createBufMult(pssc);\n\n    GoldenGateEventProducer gg = new GoldenGateEventProducer(pssc, null, mb,\n        null, null);\n    List<TransactionState.PerSourceTransactionalUpdate> dbUpdates = new ArrayList<TransactionState.PerSourceTransactionalUpdate>(\n        10);\n    int sourceId = 505;\n    HashSet<DBUpdateImage> db = new HashSet<DBUpdateImage>();\n\n    Object key = new String(\"name\");\n    Schema.Type keyType = Schema.Type.RECORD;\n    ColumnsState.KeyPair kp = new ColumnsState.KeyPair(key, keyType);\n    ArrayList<ColumnsState.KeyPair> keyPairs = new ArrayList<ColumnsState.KeyPair>(\n        1);\n    keyPairs.add(kp);\n\n    Schema s = Schema.parse(avroSchema);\n    GenericRecord gr = new GenericData.Record(s);\n    gr.put(\"name\", \"phani\");\n\n    DBUpdateImage dbi = new DBUpdateImage(keyPairs, scn, gr, s,\n        DbUpdateState.DBUpdateImage.OpType.INSERT,false);\n    db.add(dbi);\n    TransactionState.PerSourceTransactionalUpdate dbUpdate = new TransactionState.PerSourceTransactionalUpdate(\n        sourceId, db);\n    dbUpdates.add(dbUpdate);\n\n    long timestamp = System.nanoTime();\n    gg.addEventToBuffer(dbUpdates, new TransactionInfo(0, 0, timestamp, scn));\n    Assert.assertEquals(gg.getRateControl().getNumSleeps(), 0);\n    DbusEventIterator iter  = mb.acquireIterator(\"test\");\n    int count = 0;\n    long eventTs = 0;\n    while(iter.hasNext()) {\n      DbusEvent e = iter.next();\n      if(count==1) { // first event prev control event\n        eventTs = e.timestampInNanos();\n      }\n\n      count ++;\n    }\n     Assert.assertEquals(\"Event timestamp in Ns\", timestamp, eventTs);\n    Assert.assertEquals(\"Got events \" , 3, count);\n\n    return;\n  }", "signature": "void testAddEventToBuffer()", "full_signature": "@Test public void testAddEventToBuffer()", "class_method_signature": "TestGoldenGateEventProducer.testAddEventToBuffer()", "testcase": true, "constructor": false, "invocations": ["buildPssc", "createBufMult", "add", "parse", "put", "add", "add", "nanoTime", "addEventToBuffer", "assertEquals", "getNumSleeps", "getRateControl", "acquireIterator", "hasNext", "next", "timestampInNanos", "assertEquals", "assertEquals"]}, "focal_class": {"identifier": "GoldenGateEventProducer", "superclass": "extends AbstractEventProducer", "interfaces": "", "fields": [{"original_string": "private final PhysicalSourceStaticConfig _pConfig;", "modifier": "private final", "type": "PhysicalSourceStaticConfig", "declarator": "_pConfig", "var_name": "_pConfig"}, {"original_string": "private final SchemaRegistryService _schemaRegistryService;", "modifier": "private final", "type": "SchemaRegistryService", "declarator": "_schemaRegistryService", "var_name": "_schemaRegistryService"}, {"original_string": "private final DbusEventsStatisticsCollector _statsCollector;", "modifier": "private final", "type": "DbusEventsStatisticsCollector", "declarator": "_statsCollector", "var_name": "_statsCollector"}, {"original_string": "private final AtomicLong _scn = new AtomicLong(-1);", "modifier": "private final", "type": "AtomicLong", "declarator": "_scn = new AtomicLong(-1)", "var_name": "_scn"}, {"original_string": "private final AtomicLong _startPrevScn = new AtomicLong(-1);", "modifier": "private final", "type": "AtomicLong", "declarator": "_startPrevScn = new AtomicLong(-1)", "var_name": "_startPrevScn"}, {"original_string": "State _currentState = State.INIT;", "modifier": "", "type": "State", "declarator": "_currentState = State.INIT", "var_name": "_currentState"}, {"original_string": "private WorkerThread _worker;", "modifier": "private", "type": "WorkerThread", "declarator": "_worker", "var_name": "_worker"}, {"original_string": "private final Lock _pauseLock = new ReentrantLock(true);", "modifier": "private final", "type": "Lock", "declarator": "_pauseLock = new ReentrantLock(true)", "var_name": "_pauseLock"}, {"original_string": "private final Condition _pausedCondition = _pauseLock.newCondition();", "modifier": "private final", "type": "Condition", "declarator": "_pausedCondition = _pauseLock.newCondition()", "var_name": "_pausedCondition"}, {"original_string": "private final HashMap<Integer,PartitionFunction>  _partitionFunctionHashMap;", "modifier": "private final", "type": "HashMap<Integer,PartitionFunction>", "declarator": "_partitionFunctionHashMap", "var_name": "_partitionFunctionHashMap"}, {"original_string": "private RateControl _rc;", "modifier": "private", "type": "RateControl", "declarator": "_rc", "var_name": "_rc"}, {"original_string": "private final GGParserStatistics _ggParserStats;", "modifier": "private final", "type": "GGParserStatistics", "declarator": "_ggParserStats", "var_name": "_ggParserStats"}, {"original_string": "private final Map<Short, GGMonitoredSourceInfo> _monitoredSources = new HashMap<Short, GGMonitoredSourceInfo>();", "modifier": "private final", "type": "Map<Short, GGMonitoredSourceInfo>", "declarator": "_monitoredSources = new HashMap<Short, GGMonitoredSourceInfo>()", "var_name": "_monitoredSources"}, {"original_string": "public static final short GLOBAL_SOURCE_ID=0;", "modifier": "public static final", "type": "short", "declarator": "GLOBAL_SOURCE_ID=0", "var_name": "GLOBAL_SOURCE_ID"}, {"original_string": "private final List<ObjectName> _registeredMbeans = new ArrayList<ObjectName>();", "modifier": "private final", "type": "List<ObjectName>", "declarator": "_registeredMbeans = new ArrayList<ObjectName>()", "var_name": "_registeredMbeans"}, {"original_string": "private final MBeanServer _mbeanServer = ManagementFactory.getPlatformMBeanServer();", "modifier": "private final", "type": "MBeanServer", "declarator": "_mbeanServer = ManagementFactory.getPlatformMBeanServer()", "var_name": "_mbeanServer"}, {"original_string": "private final Logger _eventsLog;", "modifier": "private final", "type": "Logger", "declarator": "_eventsLog", "var_name": "_eventsLog"}, {"original_string": "public final Logger _log;", "modifier": "public final", "type": "Logger", "declarator": "_log", "var_name": "_log"}], "methods": [{"identifier": "GoldenGateEventProducer", "parameters": "(PhysicalSourceStaticConfig pConfig,\n                                 SchemaRegistryService schemaRegistryService,\n                                 DbusEventBufferAppendable dbusEventBuffer,\n                                 DbusEventsStatisticsCollector statsCollector,\n                                 MaxSCNReaderWriter maxScnReaderWriters)", "modifiers": "public", "return": "", "signature": " GoldenGateEventProducer(PhysicalSourceStaticConfig pConfig,\n                                 SchemaRegistryService schemaRegistryService,\n                                 DbusEventBufferAppendable dbusEventBuffer,\n                                 DbusEventsStatisticsCollector statsCollector,\n                                 MaxSCNReaderWriter maxScnReaderWriters)", "full_signature": "public  GoldenGateEventProducer(PhysicalSourceStaticConfig pConfig,\n                                 SchemaRegistryService schemaRegistryService,\n                                 DbusEventBufferAppendable dbusEventBuffer,\n                                 DbusEventsStatisticsCollector statsCollector,\n                                 MaxSCNReaderWriter maxScnReaderWriters)", "class_method_signature": "GoldenGateEventProducer.GoldenGateEventProducer(PhysicalSourceStaticConfig pConfig,\n                                 SchemaRegistryService schemaRegistryService,\n                                 DbusEventBufferAppendable dbusEventBuffer,\n                                 DbusEventsStatisticsCollector statsCollector,\n                                 MaxSCNReaderWriter maxScnReaderWriters)", "testcase": false, "constructor": true}, {"identifier": "buildGGMonitoredSourceInfo", "parameters": "(\n            LogicalSourceStaticConfig sourceConfig, PhysicalSourceStaticConfig pConfig)", "modifiers": "public", "return": "GGMonitoredSourceInfo", "signature": "GGMonitoredSourceInfo buildGGMonitoredSourceInfo(\n            LogicalSourceStaticConfig sourceConfig, PhysicalSourceStaticConfig pConfig)", "full_signature": "public GGMonitoredSourceInfo buildGGMonitoredSourceInfo(\n            LogicalSourceStaticConfig sourceConfig, PhysicalSourceStaticConfig pConfig)", "class_method_signature": "GoldenGateEventProducer.buildGGMonitoredSourceInfo(\n            LogicalSourceStaticConfig sourceConfig, PhysicalSourceStaticConfig pConfig)", "testcase": false, "constructor": false}, {"identifier": "registerParserMbean", "parameters": "(GGParserStatisticsMBean parserBean)", "modifiers": "private", "return": "void", "signature": "void registerParserMbean(GGParserStatisticsMBean parserBean)", "full_signature": "private void registerParserMbean(GGParserStatisticsMBean parserBean)", "class_method_signature": "GoldenGateEventProducer.registerParserMbean(GGParserStatisticsMBean parserBean)", "testcase": false, "constructor": false}, {"identifier": "registerMbeans", "parameters": "(GGMonitoredSourceInfo source)", "modifiers": "private", "return": "void", "signature": "void registerMbeans(GGMonitoredSourceInfo source)", "full_signature": "private void registerMbeans(GGMonitoredSourceInfo source)", "class_method_signature": "GoldenGateEventProducer.registerMbeans(GGMonitoredSourceInfo source)", "testcase": false, "constructor": false}, {"identifier": "getParserStats", "parameters": "()", "modifiers": "public", "return": "GGParserStatistics", "signature": "GGParserStatistics getParserStats()", "full_signature": "public GGParserStatistics getParserStats()", "class_method_signature": "GoldenGateEventProducer.getParserStats()", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getName()", "full_signature": "@Override public String getName()", "class_method_signature": "GoldenGateEventProducer.getName()", "testcase": false, "constructor": false}, {"identifier": "getSCN", "parameters": "()", "modifiers": "@Override public", "return": "long", "signature": "long getSCN()", "full_signature": "@Override public long getSCN()", "class_method_signature": "GoldenGateEventProducer.getSCN()", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "(long sinceSCN)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void start(long sinceSCN)", "full_signature": "@Override public synchronized void start(long sinceSCN)", "class_method_signature": "GoldenGateEventProducer.start(long sinceSCN)", "testcase": false, "constructor": false}, {"identifier": "isRunning", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isRunning()", "full_signature": "@Override public boolean isRunning()", "class_method_signature": "GoldenGateEventProducer.isRunning()", "testcase": false, "constructor": false}, {"identifier": "isPaused", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isPaused()", "full_signature": "@Override public boolean isPaused()", "class_method_signature": "GoldenGateEventProducer.isPaused()", "testcase": false, "constructor": false}, {"identifier": "unpause", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void unpause()", "full_signature": "@Override public void unpause()", "class_method_signature": "GoldenGateEventProducer.unpause()", "testcase": false, "constructor": false}, {"identifier": "pause", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void pause()", "full_signature": "@Override public void pause()", "class_method_signature": "GoldenGateEventProducer.pause()", "testcase": false, "constructor": false}, {"identifier": "isPauseRequested", "parameters": "()", "modifiers": "private synchronized", "return": "boolean", "signature": "boolean isPauseRequested()", "full_signature": "private synchronized boolean isPauseRequested()", "class_method_signature": "GoldenGateEventProducer.isPauseRequested()", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void shutdown()", "full_signature": "@Override public synchronized void shutdown()", "class_method_signature": "GoldenGateEventProducer.shutdown()", "testcase": false, "constructor": false}, {"identifier": "waitForShutdown", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void waitForShutdown()", "full_signature": "@Override public synchronized void waitForShutdown()", "class_method_signature": "GoldenGateEventProducer.waitForShutdown()", "testcase": false, "constructor": false}, {"identifier": "waitForShutdown", "parameters": "(long timeout)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void waitForShutdown(long timeout)", "full_signature": "@Override public synchronized void waitForShutdown(long timeout)", "class_method_signature": "GoldenGateEventProducer.waitForShutdown(long timeout)", "testcase": false, "constructor": false}, {"identifier": "readEventsFromAllSources", "parameters": "(long sinceSCN)", "modifiers": "@Override protected", "return": "ReadEventCycleSummary", "signature": "ReadEventCycleSummary readEventsFromAllSources(long sinceSCN)", "full_signature": "@Override protected ReadEventCycleSummary readEventsFromAllSources(long sinceSCN)", "class_method_signature": "GoldenGateEventProducer.readEventsFromAllSources(long sinceSCN)", "testcase": false, "constructor": false}, {"identifier": "wrapStreamWithXmlTags", "parameters": "(InputStream compositeInputStream)", "modifiers": "private", "return": "InputStream", "signature": "InputStream wrapStreamWithXmlTags(InputStream compositeInputStream)", "full_signature": "private InputStream wrapStreamWithXmlTags(InputStream compositeInputStream)", "class_method_signature": "GoldenGateEventProducer.wrapStreamWithXmlTags(InputStream compositeInputStream)", "testcase": false, "constructor": false}, {"identifier": "locateScnInTrailFile", "parameters": "(String xmlDir, String xmlPrefix)", "modifiers": "private", "return": "ConcurrentAppendableCompositeFileInputStream", "signature": "ConcurrentAppendableCompositeFileInputStream locateScnInTrailFile(String xmlDir, String xmlPrefix)", "full_signature": "private ConcurrentAppendableCompositeFileInputStream locateScnInTrailFile(String xmlDir, String xmlPrefix)", "class_method_signature": "GoldenGateEventProducer.locateScnInTrailFile(String xmlDir, String xmlPrefix)", "testcase": false, "constructor": false}, {"identifier": "obtainKey", "parameters": "(DbUpdateState.DBUpdateImage dbUpdate)", "modifiers": "static protected", "return": "Object", "signature": "Object obtainKey(DbUpdateState.DBUpdateImage dbUpdate)", "full_signature": "static protected Object obtainKey(DbUpdateState.DBUpdateImage dbUpdate)", "class_method_signature": "GoldenGateEventProducer.obtainKey(DbUpdateState.DBUpdateImage dbUpdate)", "testcase": false, "constructor": false}, {"identifier": "addEventToBuffer", "parameters": "(List<TransactionState.PerSourceTransactionalUpdate> dbUpdates, TransactionInfo ti)", "modifiers": "protected", "return": "void", "signature": "void addEventToBuffer(List<TransactionState.PerSourceTransactionalUpdate> dbUpdates, TransactionInfo ti)", "full_signature": "protected void addEventToBuffer(List<TransactionState.PerSourceTransactionalUpdate> dbUpdates, TransactionInfo ti)", "class_method_signature": "GoldenGateEventProducer.addEventToBuffer(List<TransactionState.PerSourceTransactionalUpdate> dbUpdates, TransactionInfo ti)", "testcase": false, "constructor": false}, {"identifier": "getRateControl", "parameters": "()", "modifiers": "protected", "return": "RateControl", "signature": "RateControl getRateControl()", "full_signature": "protected RateControl getRateControl()", "class_method_signature": "GoldenGateEventProducer.getRateControl()", "testcase": false, "constructor": false}, {"identifier": "getSources", "parameters": "()", "modifiers": "@Override public", "return": "List<? extends EventSourceStatisticsIface>", "signature": "List<? extends EventSourceStatisticsIface> getSources()", "full_signature": "@Override public List<? extends EventSourceStatisticsIface> getSources()", "class_method_signature": "GoldenGateEventProducer.getSources()", "testcase": false, "constructor": false}, {"identifier": "getSource", "parameters": "(short sourceId)", "modifiers": "public", "return": "GGMonitoredSourceInfo", "signature": "GGMonitoredSourceInfo getSource(short sourceId)", "full_signature": "public GGMonitoredSourceInfo getSource(short sourceId)", "class_method_signature": "GoldenGateEventProducer.getSource(short sourceId)", "testcase": false, "constructor": false}], "file": "databus2-relay/databus2-relay-impl/src/main/java/com/linkedin/databus2/relay/GoldenGateEventProducer.java"}, "focal_method": {"identifier": "addEventToBuffer", "parameters": "(List<TransactionState.PerSourceTransactionalUpdate> dbUpdates, TransactionInfo ti)", "modifiers": "protected", "return": "void", "body": "protected void addEventToBuffer(List<TransactionState.PerSourceTransactionalUpdate> dbUpdates, TransactionInfo ti)\n      throws DatabusException, UnsupportedKeyException\n  {\n    if(dbUpdates.size() == 0)\n      throw new DatabusException(\"Cannot handle empty dbUpdates\");\n\n    long scn = ti.getScn();\n    long timestamp = ti.getTransactionTimeStampNs();\n    EventSourceStatistics globalStats = getSource(GLOBAL_SOURCE_ID).getStatisticsBean();\n\n    /**\n     * We skip the start scn of the relay, we have already added a EOP for this SCN in the buffer.\n     * Why is this not a problem ?\n     * There are two cases:\n     * 1. When we use the earliest/latest scn if there is no maxScn (We don't really have a start point). So it's really OK to miss the first event.\n     * 2. If it's the maxSCN, then event was already seen by the relay.\n     */\n    if(scn == _startPrevScn.get())\n    {\n      _log.info(\"Skipping this transaction, EOP already send for this event\");\n      return;\n    }\n\n    getEventBuffer().startEvents();\n\n    int eventsInTransactionCount = 0;\n\n    List<EventReaderSummary> summaries = new ArrayList<EventReaderSummary>();\n\n    for (int i = 0; i < dbUpdates.size(); ++i)\n    {\n      GenericRecord record = null;\n      TransactionState.PerSourceTransactionalUpdate perSourceUpdate = dbUpdates.get(i);\n      short sourceId = (short)perSourceUpdate.getSourceId();\n      // prepare stats collection per source\n      EventSourceStatistics perSourceStats = getSource(sourceId).getStatisticsBean();\n\n      Iterator<DbUpdateState.DBUpdateImage> dbUpdateIterator = perSourceUpdate.getDbUpdatesSet().iterator();\n      int eventsInDbUpdate = 0;\n      long dbUpdatesEventsSize = 0;\n      long startDbUpdatesMs = System.currentTimeMillis();\n\n      while(dbUpdateIterator.hasNext())  //TODO verify if there is any case where we need to rollback.\n      {\n        DbUpdateState.DBUpdateImage dbUpdate =  dbUpdateIterator.next();\n\n        //Construct the Databus Event key, determine the key type and construct the key\n        Object keyObj = obtainKey(dbUpdate);\n        DbusEventKey eventKey = new DbusEventKey(keyObj);\n\n        //Get the logicalparition id\n        PartitionFunction partitionFunction = _partitionFunctionHashMap.get((int)sourceId);\n        short lPartitionId = partitionFunction.getPartition(eventKey);\n\n        record = dbUpdate.getGenericRecord();\n        //Write the event to the buffer\n        if (record == null)\n          throw new DatabusException(\"Cannot write event to buffer because record = \" + record);\n\n        if(record.getSchema() == null)\n          throw new DatabusException(\"The record does not have a schema (null schema)\");\n\n        try\n        {\n          //Collect stats on number of dbUpdates for one source\n          eventsInDbUpdate++;\n\n          //Count of all the events in the current transaction\n          eventsInTransactionCount++;\n          // Serialize the row\n          ByteArrayOutputStream bos = new ByteArrayOutputStream();\n          Encoder encoder = new BinaryEncoder(bos);\n          GenericDatumWriter<GenericRecord> writer = new GenericDatumWriter<GenericRecord>(\n              record.getSchema());\n          writer.write(record, encoder);\n          byte[] serializedValue = bos.toByteArray();\n\n          //Get the md5 for the schema\n          SchemaId schemaId = SchemaId.createWithMd5(dbUpdate.getSchema());\n\n          //Determine the operation type and convert to dbus opcode\n          DbusOpcode opCode;\n          if(dbUpdate.getOpType() == DbUpdateState.DBUpdateImage.OpType.INSERT || dbUpdate.getOpType() == DbUpdateState.DBUpdateImage.OpType.UPDATE)\n          {\n            opCode = DbusOpcode.UPSERT;\n            if(_log.isDebugEnabled())\n              _log.debug(\"The event with scn \"+ scn +\" is INSERT/UPDATE\");\n          }\n          else if(dbUpdate.getOpType() == DbUpdateState.DBUpdateImage.OpType.DELETE)\n          {\n            opCode = DbusOpcode.DELETE;\n            if(_log.isDebugEnabled())\n              _log.debug(\"The event with scn \"+ scn +\" is DELETE\");\n          }\n          else\n          {\n            throw new DatabusException(\"Unknown opcode from dbUpdate for event with scn:\" + scn);\n          }\n\n\n          //Construct the dbusEvent info\n          DbusEventInfo dbusEventInfo = new DbusEventInfo(opCode,\n                                                          scn,\n                                                          (short)_pConfig.getId(),\n                                                          lPartitionId,\n                                                          timestamp,\n                                                          sourceId,\n                                                          schemaId.getByteArray(),\n                                                          serializedValue,\n                                                          false,\n                                                          false);\n          dbusEventInfo.setReplicated(dbUpdate.isReplicated());\n\n          perSourceStats.addEventCycle(1, ti.getTransactionTimeRead(), serializedValue.length, scn);\n          globalStats.addEventCycle(1, ti.getTransactionTimeRead(), serializedValue.length, scn);\n\n          long tsEnd = System.currentTimeMillis();\n          perSourceStats.addTimeOfLastDBAccess(tsEnd);\n          globalStats.addTimeOfLastDBAccess(tsEnd);\n\n          //Append to the event buffer\n          getEventBuffer().appendEvent(eventKey, dbusEventInfo, _statsCollector);\n          _rc.incrementEventCount();\n          dbUpdatesEventsSize += serializedValue.length;\n        }\n        catch (IOException io)\n        {\n          perSourceStats.addError();\n          globalStats.addEmptyEventCycle();\n          _log.error(\"Cannot create byte stream payload: \" + dbUpdates.get(i).getSourceId());\n        }\n      }\n      long endDbUpdatesMs = System.currentTimeMillis();\n      long dbUpdatesElapsedTimeMs = endDbUpdatesMs - startDbUpdatesMs;\n\n      // Log Event Summary at logical source level\n      EventReaderSummary summary = new EventReaderSummary(sourceId, _monitoredSources.get(sourceId).getSourceName(),\n                                                          scn, eventsInDbUpdate, dbUpdatesEventsSize,-1L /* Not supported */,\n                                                          dbUpdatesElapsedTimeMs,  timestamp, timestamp, -1L /* Not supported */);\n      if (_eventsLog.isInfoEnabled())\n      {\n        _eventsLog.info(summary.toString());\n      }\n      summaries.add(summary);\n\n      if(_log.isDebugEnabled())\n        _log.debug(\"There are \"+ eventsInDbUpdate + \" events seen in the current dbUpdate\");\n    }\n\n    // Log Event Summary at Physical source level\n    ReadEventCycleSummary summary = new ReadEventCycleSummary(_pConfig.getName(),\n                                                              summaries,\n                                                              scn,\n                                                              -1 /* Overall time including query time not calculated */);\n\n    if (_eventsLog.isInfoEnabled())\n    {\n      _eventsLog.info(summary.toString());\n    }\n\n    _log.info(\"Writing \"+ eventsInTransactionCount + \" events from transaction with scn: \" + scn);\n    if(scn <= 0)\n      throw new DatabusException(\"Unable to write events to buffer because of negative/zero scn: \" + scn);\n\n    getEventBuffer().endEvents(scn, _statsCollector);\n    _scn.set(scn);\n\n    if (getMaxScnReaderWriter() != null)\n    {\n      try\n      {\n        getMaxScnReaderWriter().saveMaxScn(_scn.get());\n      }\n      catch (DatabusException e)\n      {\n        _log.error(\"Cannot save scn = \" + _scn + \" for physical source = \" + getName(), e);\n      }\n    }\n  }", "signature": "void addEventToBuffer(List<TransactionState.PerSourceTransactionalUpdate> dbUpdates, TransactionInfo ti)", "full_signature": "protected void addEventToBuffer(List<TransactionState.PerSourceTransactionalUpdate> dbUpdates, TransactionInfo ti)", "class_method_signature": "GoldenGateEventProducer.addEventToBuffer(List<TransactionState.PerSourceTransactionalUpdate> dbUpdates, TransactionInfo ti)", "testcase": false, "constructor": false, "invocations": ["size", "getScn", "getTransactionTimeStampNs", "getStatisticsBean", "getSource", "get", "info", "startEvents", "getEventBuffer", "size", "get", "getSourceId", "getStatisticsBean", "getSource", "iterator", "getDbUpdatesSet", "currentTimeMillis", "hasNext", "next", "obtainKey", "get", "getPartition", "getGenericRecord", "getSchema", "getSchema", "write", "toByteArray", "createWithMd5", "getSchema", "getOpType", "getOpType", "isDebugEnabled", "debug", "getOpType", "isDebugEnabled", "debug", "getId", "getByteArray", "setReplicated", "isReplicated", "addEventCycle", "getTransactionTimeRead", "addEventCycle", "getTransactionTimeRead", "currentTimeMillis", "addTimeOfLastDBAccess", "addTimeOfLastDBAccess", "appendEvent", "getEventBuffer", "incrementEventCount", "addError", "addEmptyEventCycle", "error", "getSourceId", "get", "currentTimeMillis", "getSourceName", "get", "isInfoEnabled", "info", "toString", "add", "isDebugEnabled", "debug", "getName", "isInfoEnabled", "info", "toString", "info", "endEvents", "getEventBuffer", "set", "getMaxScnReaderWriter", "saveMaxScn", "getMaxScnReaderWriter", "get", "error", "getName"]}, "repository": {"repo_id": 7209229, "url": "https://github.com/linkedin/databus", "language": "Java", "is_fork": false, "fork_count": 653, "stargazer_count": 2899, "size": 51191, "license": "licensed"}}