{"test_class": {"identifier": "FileUtilsTest", "superclass": "extends BaseFileTest", "interfaces": "", "fields": [{"original_string": "@Inject\n    private IndexService indexService;", "modifier": "@Inject\n    private", "type": "IndexService", "declarator": "indexService", "var_name": "indexService"}, {"original_string": "@Inject\n    private FileListService fileListService;", "modifier": "@Inject\n    private", "type": "FileListService", "declarator": "fileListService", "var_name": "fileListService"}, {"original_string": "@Inject\n    private PartitionService partitionService;", "modifier": "@Inject\n    private", "type": "PartitionService", "declarator": "partitionService", "var_name": "partitionService"}, {"original_string": "@Inject\n    private FileConfiguration fileConfiguration;", "modifier": "@Inject\n    private", "type": "FileConfiguration", "declarator": "fileConfiguration", "var_name": "fileConfiguration"}, {"original_string": "@Inject\n    private IndexConfiguration indexConfiguration;", "modifier": "@Inject\n    private", "type": "IndexConfiguration", "declarator": "indexConfiguration", "var_name": "indexConfiguration"}], "file": "file/src/test/java/io/blobkeeper/file/util/FileUtilsTest.java"}, "test_case": {"identifier": "buildMerkleTree", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void buildMerkleTree() throws IOException {\n        java.io.File dataFile1 = getFilePathByPartition(configuration, 0, 0);\n        Files.touch(dataFile1);\n\n        partitionService.setActive(new Partition(0, 0));\n\n        File file = fileListService.getFile(0, 0);\n\n        byte[] data = new byte[128];\n        for (int i = 0; i < 128; i++) {\n            data[i] = 0x1;\n        }\n\n        file.getFileChannel().write(ByteBuffer.wrap(data), 0);\n\n        IndexElt expected = new IndexElt.IndexEltBuilder()\n                .id(214803434770010112L)\n                .type(1)\n                .partition(new Partition(0, 0))\n                .offset(0L)\n                .length(128L)\n                .metadata(ImmutableMap.of(\"key\", \"value\"))\n                .crc(FileUtils.getCrc(data))\n                .build();\n\n        indexService.add(expected);\n\n        MerkleTree tree = FileUtils.buildMerkleTree(indexService, file, new Partition(0, 0));\n        assertEquals(tree.getLeafNodes().get(0).getRange(), Range.openClosed(214803434770010111L, 214803434770010112L));\n        assertEquals(tree.getLeafNodes().get(0).getHash(), new byte[]{2, -5, 34, -107, -6, 0, 16, 0, 0, 0, 0, 1});\n\n        file.close();\n    }", "signature": "void buildMerkleTree()", "full_signature": "@Test public void buildMerkleTree()", "class_method_signature": "FileUtilsTest.buildMerkleTree()", "testcase": true, "constructor": false, "invocations": ["getFilePathByPartition", "touch", "setActive", "getFile", "write", "getFileChannel", "wrap", "build", "crc", "metadata", "length", "offset", "partition", "type", "id", "of", "getCrc", "add", "buildMerkleTree", "assertEquals", "getRange", "get", "getLeafNodes", "openClosed", "assertEquals", "getHash", "get", "getLeafNodes", "close"]}, "focal_class": {"identifier": "FileUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(FileUtils.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(FileUtils.class)", "var_name": "log"}, {"original_string": "private static final int CHUNK_SIZE = 8192;", "modifier": "private static final", "type": "int", "declarator": "CHUNK_SIZE = 8192", "var_name": "CHUNK_SIZE"}], "methods": [{"identifier": "FileUtils", "parameters": "()", "modifiers": "private", "return": "", "signature": " FileUtils()", "full_signature": "private  FileUtils()", "class_method_signature": "FileUtils.FileUtils()", "testcase": false, "constructor": true}, {"identifier": "isFileEmpty", "parameters": "(@NotNull File file, @NotNull IndexElt elt)", "modifiers": "public static", "return": "boolean", "signature": "boolean isFileEmpty(@NotNull File file, @NotNull IndexElt elt)", "full_signature": "public static boolean isFileEmpty(@NotNull File file, @NotNull IndexElt elt)", "class_method_signature": "FileUtils.isFileEmpty(@NotNull File file, @NotNull IndexElt elt)", "testcase": false, "constructor": false}, {"identifier": "getCrc", "parameters": "(byte[] data)", "modifiers": "public static", "return": "long", "signature": "long getCrc(byte[] data)", "full_signature": "public static long getCrc(byte[] data)", "class_method_signature": "FileUtils.getCrc(byte[] data)", "testcase": false, "constructor": false}, {"identifier": "getCrc", "parameters": "(@NotNull File file)", "modifiers": "public static", "return": "long", "signature": "long getCrc(@NotNull File file)", "full_signature": "public static long getCrc(@NotNull File file)", "class_method_signature": "FileUtils.getCrc(@NotNull File file)", "testcase": false, "constructor": false}, {"identifier": "getDiskPathByDisk", "parameters": "(@NotNull FileConfiguration configuration, int disk)", "modifiers": "public static", "return": "java.io.File", "signature": "java.io.File getDiskPathByDisk(@NotNull FileConfiguration configuration, int disk)", "full_signature": "public static java.io.File getDiskPathByDisk(@NotNull FileConfiguration configuration, int disk)", "class_method_signature": "FileUtils.getDiskPathByDisk(@NotNull FileConfiguration configuration, int disk)", "testcase": false, "constructor": false}, {"identifier": "getFilePathByPartition", "parameters": "(@NotNull FileConfiguration configuration, int disk, int partition)", "modifiers": "public static", "return": "java.io.File", "signature": "java.io.File getFilePathByPartition(@NotNull FileConfiguration configuration, int disk, int partition)", "full_signature": "public static java.io.File getFilePathByPartition(@NotNull FileConfiguration configuration, int disk, int partition)", "class_method_signature": "FileUtils.getFilePathByPartition(@NotNull FileConfiguration configuration, int disk, int partition)", "testcase": false, "constructor": false}, {"identifier": "getFilePathByPartition", "parameters": "(@NotNull FileConfiguration configuration, @NotNull Partition partition)", "modifiers": "public static", "return": "java.io.File", "signature": "java.io.File getFilePathByPartition(@NotNull FileConfiguration configuration, @NotNull Partition partition)", "full_signature": "public static java.io.File getFilePathByPartition(@NotNull FileConfiguration configuration, @NotNull Partition partition)", "class_method_signature": "FileUtils.getFilePathByPartition(@NotNull FileConfiguration configuration, @NotNull Partition partition)", "testcase": false, "constructor": false}, {"identifier": "getOrCreateFile", "parameters": "(@NotNull FileConfiguration configuration, @NotNull Partition partition)", "modifiers": "public static", "return": "File", "signature": "File getOrCreateFile(@NotNull FileConfiguration configuration, @NotNull Partition partition)", "full_signature": "public static File getOrCreateFile(@NotNull FileConfiguration configuration, @NotNull Partition partition)", "class_method_signature": "FileUtils.getOrCreateFile(@NotNull FileConfiguration configuration, @NotNull Partition partition)", "testcase": false, "constructor": false}, {"identifier": "readFile", "parameters": "(@NotNull File file, long offset, long length)", "modifiers": "public static", "return": "ByteBuffer", "signature": "ByteBuffer readFile(@NotNull File file, long offset, long length)", "full_signature": "public static ByteBuffer readFile(@NotNull File file, long offset, long length)", "class_method_signature": "FileUtils.readFile(@NotNull File file, long offset, long length)", "testcase": false, "constructor": false}, {"identifier": "writeFile", "parameters": "(@NotNull File file, byte[] bytes, long offset)", "modifiers": "public static", "return": "int", "signature": "int writeFile(@NotNull File file, byte[] bytes, long offset)", "full_signature": "public static int writeFile(@NotNull File file, byte[] bytes, long offset)", "class_method_signature": "FileUtils.writeFile(@NotNull File file, byte[] bytes, long offset)", "testcase": false, "constructor": false}, {"identifier": "readFile", "parameters": "(@NotNull java.io.File javaFile)", "modifiers": "@NotNull public static", "return": "ByteBuffer", "signature": "ByteBuffer readFile(@NotNull java.io.File javaFile)", "full_signature": "@NotNull public static ByteBuffer readFile(@NotNull java.io.File javaFile)", "class_method_signature": "FileUtils.readFile(@NotNull java.io.File javaFile)", "testcase": false, "constructor": false}, {"identifier": "readFileToString", "parameters": "(@NotNull java.io.File javaFile)", "modifiers": "@NotNull public static", "return": "String", "signature": "String readFileToString(@NotNull java.io.File javaFile)", "full_signature": "@NotNull public static String readFileToString(@NotNull java.io.File javaFile)", "class_method_signature": "FileUtils.readFileToString(@NotNull java.io.File javaFile)", "testcase": false, "constructor": false}, {"identifier": "readBlob", "parameters": "(@NotNull IndexService indexService, @NotNull File blob, @NotNull Partition partition)", "modifiers": "@NotNull public static", "return": "SortedMap<Long, Block>", "signature": "SortedMap<Long, Block> readBlob(@NotNull IndexService indexService, @NotNull File blob, @NotNull Partition partition)", "full_signature": "@NotNull public static SortedMap<Long, Block> readBlob(@NotNull IndexService indexService, @NotNull File blob, @NotNull Partition partition)", "class_method_signature": "FileUtils.readBlob(@NotNull IndexService indexService, @NotNull File blob, @NotNull Partition partition)", "testcase": false, "constructor": false}, {"identifier": "buildMerkleTree", "parameters": "(\n            @NotNull IndexService indexService,\n            @NotNull File blob,\n            @NotNull Partition partition\n    )", "modifiers": "@NotNull public static", "return": "MerkleTree", "signature": "MerkleTree buildMerkleTree(\n            @NotNull IndexService indexService,\n            @NotNull File blob,\n            @NotNull Partition partition\n    )", "full_signature": "@NotNull public static MerkleTree buildMerkleTree(\n            @NotNull IndexService indexService,\n            @NotNull File blob,\n            @NotNull Partition partition\n    )", "class_method_signature": "FileUtils.buildMerkleTree(\n            @NotNull IndexService indexService,\n            @NotNull File blob,\n            @NotNull Partition partition\n    )", "testcase": false, "constructor": false}, {"identifier": "getPercentOfDeleted", "parameters": "(\n            @NotNull FileConfiguration configuration,\n            @NotNull IndexService indexService,\n            @NotNull Partition partition\n    )", "modifiers": "public static", "return": "int", "signature": "int getPercentOfDeleted(\n            @NotNull FileConfiguration configuration,\n            @NotNull IndexService indexService,\n            @NotNull Partition partition\n    )", "full_signature": "public static int getPercentOfDeleted(\n            @NotNull FileConfiguration configuration,\n            @NotNull IndexService indexService,\n            @NotNull Partition partition\n    )", "class_method_signature": "FileUtils.getPercentOfDeleted(\n            @NotNull FileConfiguration configuration,\n            @NotNull IndexService indexService,\n            @NotNull Partition partition\n    )", "testcase": false, "constructor": false}], "file": "file/src/main/java/io/blobkeeper/file/util/FileUtils.java"}, "focal_method": {"identifier": "buildMerkleTree", "parameters": "(\n            @NotNull IndexService indexService,\n            @NotNull File blob,\n            @NotNull Partition partition\n    )", "modifiers": "@NotNull public static", "return": "MerkleTree", "body": "@NotNull\n    public static MerkleTree buildMerkleTree(\n            @NotNull IndexService indexService,\n            @NotNull File blob,\n            @NotNull Partition partition\n    ) {\n        SortedMap<Long, Block> blocks = readBlob(indexService, blob, partition);\n\n        MerkleTree tree = new MerkleTree(indexService.getMinMaxRange(partition), MAX_LEVEL);\n        MerkleTree.fillTree(tree, blocks);\n        tree.calculate();\n\n        return tree;\n    }", "signature": "MerkleTree buildMerkleTree(\n            @NotNull IndexService indexService,\n            @NotNull File blob,\n            @NotNull Partition partition\n    )", "full_signature": "@NotNull public static MerkleTree buildMerkleTree(\n            @NotNull IndexService indexService,\n            @NotNull File blob,\n            @NotNull Partition partition\n    )", "class_method_signature": "FileUtils.buildMerkleTree(\n            @NotNull IndexService indexService,\n            @NotNull File blob,\n            @NotNull Partition partition\n    )", "testcase": false, "constructor": false, "invocations": ["readBlob", "getMinMaxRange", "fillTree", "calculate"]}, "repository": {"repo_id": 43258821, "url": "https://github.com/sherman/blobkeeper", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 20, "size": 417, "license": "licensed"}}