{"test_class": {"identifier": "OperationFactoryTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Metadata metadata;", "modifier": "private", "type": "Metadata", "declarator": "metadata", "var_name": "metadata"}, {"original_string": "private ResourceAddress address;", "modifier": "private", "type": "ResourceAddress", "declarator": "address", "var_name": "address"}, {"original_string": "private OperationFactory operationFactory;", "modifier": "private", "type": "OperationFactory", "declarator": "operationFactory", "var_name": "operationFactory"}], "file": "core/src/test/java/org/jboss/hal/core/OperationFactoryTest.java"}, "test_case": {"identifier": "alternativesNoConflictsWithRequires", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void alternativesNoConflictsWithRequires() {\n        Composite composite = operationFactory.fromChangeSet(address,\n                ImmutableMap.of(\"security-domain\", \"foo\"), metadata);\n\n        assertEquals(6, composite.size());\n        assertUndefine(composite, \"security-application\");\n        assertUndefine(composite, \"security-domain-and-application\");\n        assertUndefine(composite, \"elytron-enabled\");\n        assertUndefine(composite, \"authentication-context\");\n        assertUndefine(composite, \"authentication-context-and-application\");\n        assertWrite(composite, \"security-domain\", \"foo\");\n    }", "signature": "void alternativesNoConflictsWithRequires()", "full_signature": "@Test public void alternativesNoConflictsWithRequires()", "class_method_signature": "OperationFactoryTest.alternativesNoConflictsWithRequires()", "testcase": true, "constructor": false, "invocations": ["fromChangeSet", "of", "assertEquals", "size", "assertUndefine", "assertUndefine", "assertUndefine", "assertUndefine", "assertUndefine", "assertWrite"]}, "focal_class": {"identifier": "OperationFactory", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(OperationFactory.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(OperationFactory.class)", "var_name": "logger"}, {"original_string": "private final Function<String, String> nameFn;", "modifier": "private final", "type": "Function<String, String>", "declarator": "nameFn", "var_name": "nameFn"}], "methods": [{"identifier": "OperationFactory", "parameters": "()", "modifiers": "public", "return": "", "signature": " OperationFactory()", "full_signature": "public  OperationFactory()", "class_method_signature": "OperationFactory.OperationFactory()", "testcase": false, "constructor": true}, {"identifier": "OperationFactory", "parameters": "(Function<String, String> nameFn)", "modifiers": "public", "return": "", "signature": " OperationFactory(Function<String, String> nameFn)", "full_signature": "public  OperationFactory(Function<String, String> nameFn)", "class_method_signature": "OperationFactory.OperationFactory(Function<String, String> nameFn)", "testcase": false, "constructor": true}, {"identifier": "fromChangeSet", "parameters": "(ResourceAddress address, Map<String, Object> changeSet,\n            Metadata metadata)", "modifiers": "public", "return": "Composite", "signature": "Composite fromChangeSet(ResourceAddress address, Map<String, Object> changeSet,\n            Metadata metadata)", "full_signature": "public Composite fromChangeSet(ResourceAddress address, Map<String, Object> changeSet,\n            Metadata metadata)", "class_method_signature": "OperationFactory.fromChangeSet(ResourceAddress address, Map<String, Object> changeSet,\n            Metadata metadata)", "testcase": false, "constructor": false}, {"identifier": "resetResource", "parameters": "(ResourceAddress address, Set<String> attributes,\n            Metadata metadata)", "modifiers": "", "return": "Composite", "signature": "Composite resetResource(ResourceAddress address, Set<String> attributes,\n            Metadata metadata)", "full_signature": " Composite resetResource(ResourceAddress address, Set<String> attributes,\n            Metadata metadata)", "class_method_signature": "OperationFactory.resetResource(ResourceAddress address, Set<String> attributes,\n            Metadata metadata)", "testcase": false, "constructor": false}, {"identifier": "isNullOrEmpty", "parameters": "(Object value)", "modifiers": "private", "return": "boolean", "signature": "boolean isNullOrEmpty(Object value)", "full_signature": "private boolean isNullOrEmpty(Object value)", "class_method_signature": "OperationFactory.isNullOrEmpty(Object value)", "testcase": false, "constructor": false}, {"identifier": "undefineAttribute", "parameters": "(ResourceAddress address, String name)", "modifiers": "private", "return": "Operation", "signature": "Operation undefineAttribute(ResourceAddress address, String name)", "full_signature": "private Operation undefineAttribute(ResourceAddress address, String name)", "class_method_signature": "OperationFactory.undefineAttribute(ResourceAddress address, String name)", "testcase": false, "constructor": false}, {"identifier": "writeAttribute", "parameters": "(ResourceAddress address, String name, Object value,\n            ResourceDescription resourceDescription)", "modifiers": "private", "return": "Operation", "signature": "Operation writeAttribute(ResourceAddress address, String name, Object value,\n            ResourceDescription resourceDescription)", "full_signature": "private Operation writeAttribute(ResourceAddress address, String name, Object value,\n            ResourceDescription resourceDescription)", "class_method_signature": "OperationFactory.writeAttribute(ResourceAddress address, String name, Object value,\n            ResourceDescription resourceDescription)", "testcase": false, "constructor": false}, {"identifier": "attributeName", "parameters": "(String name)", "modifiers": "private", "return": "String", "signature": "String attributeName(String name)", "full_signature": "private String attributeName(String name)", "class_method_signature": "OperationFactory.attributeName(String name)", "testcase": false, "constructor": false}, {"identifier": "asValueNode", "parameters": "(String name, Object value, ResourceDescription resourceDescription)", "modifiers": "private", "return": "ModelNode", "signature": "ModelNode asValueNode(String name, Object value, ResourceDescription resourceDescription)", "full_signature": "private ModelNode asValueNode(String name, Object value, ResourceDescription resourceDescription)", "class_method_signature": "OperationFactory.asValueNode(String name, Object value, ResourceDescription resourceDescription)", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/jboss/hal/core/OperationFactory.java"}, "focal_method": {"identifier": "fromChangeSet", "parameters": "(ResourceAddress address, Map<String, Object> changeSet,\n            Metadata metadata)", "modifiers": "public", "return": "Composite", "body": "public Composite fromChangeSet(ResourceAddress address, Map<String, Object> changeSet,\n            Metadata metadata) {\n\n        // TODO Is it safe to always use ATTRIBUTES as path when calling ResourceDescription methods?\n        Map<String, Operation> operations = new HashMap<>();\n        HashMap<String, Object> localChanges = new HashMap<>(changeSet);\n        ResourceDescription resourceDescription = metadata.getDescription();\n\n        // look for alternatives\n        Set<String> conflicts = new HashSet<>();\n        Map<String, List<String>> allAlternatives = localChanges.keySet().stream()\n                .filter(name -> {\n                    Object value = changeSet.get(name);\n                    return !isNullOrEmpty(value);\n                })\n                .collect(toMap(identity(), name -> resourceDescription.findAlternatives(ATTRIBUTES, name)));\n        allAlternatives.forEach((attribute, alternatives) -> {\n\n            logger.debug(\"Alternatives resolution for {} -> [{}]\", attribute, String.join(\", \", alternatives));\n            HashSet<String> intersection = new HashSet<>(alternatives);\n            intersection.retainAll(changeSet.keySet());\n            if (intersection.isEmpty()) {\n\n                // the easy part: no conflicts\n                alternatives.forEach(alternative -> {\n                    boolean alternativeDoesntExist = resourceDescription.findAttribute(ATTRIBUTES, alternative) == null;\n                    if (resourceDescription.isDeprecated(ATTRIBUTES, alternative) || alternativeDoesntExist) {\n                        logger.debug(\"Skip undefine operations for deprecated or non-existent alternative {}\",\n                                alternative);\n                    } else {\n                        logger.debug(\"Add undefine operations for alternative {}\", alternative);\n                        operations.putIfAbsent(alternative, undefineAttribute(address, alternative));\n                        List<String> requires = resourceDescription.findRequires(ATTRIBUTES, alternative);\n                        if (!requires.isEmpty()) {\n                            logger.debug(\"Add undefine operations for attributes which require {}: [{}]\", alternative,\n                                    String.join(\", \", requires));\n                            requires.forEach(r -> operations.putIfAbsent(r, undefineAttribute(address, r)));\n                        }\n                    }\n                });\n\n            } else {\n                // possible conflicts: one or more alternatives are also in the change-set\n                // just collect for now and resolve later\n                conflicts.add(attribute);\n                conflicts.addAll(intersection);\n                logger.debug(\"Record conflict {} <-> [{}]\", attribute, String.join(\", \", intersection));\n            }\n\n            alternatives.forEach(localChanges::remove);\n        });\n\n        if (!conflicts.isEmpty()) {\n            // try to resolve conflicts: only one of the conflicting attributes must have a value other than\n            // null, empty or default\n            logger.debug(\"Try to resolve conflicts between alternatives [{}]\", String.join(\", \", conflicts));\n            Map<Boolean, List<String>> resolution = conflicts.stream().collect(groupingBy(conflict -> {\n                Object value = changeSet.get(conflict);\n                return isNullOrEmpty(value) || resourceDescription.isDefaultValue(ATTRIBUTES, conflict, value);\n            }));\n            List<String> undefine = resolution.getOrDefault(true, Collections.emptyList());\n            List<String> write = resolution.getOrDefault(false, Collections.emptyList());\n            if (write.size() > 1) {\n                logger.error(\n                        \"More than one conflicting alternative attribute which is not null, empty or default: [{}]. This should have been caught by a form validation. Adding the write operations anyway to get an appropriate error message from the server.\",\n                        String.join(\", \", write));\n            }\n\n            logger.debug(\"Add undefine operations for [{}], write operation for [{}]\",\n                    String.join(\", \", undefine), String.join(\", \", write));\n            undefine.forEach(u -> {\n                operations.putIfAbsent(u, undefineAttribute(address, u));\n                localChanges.remove(u);\n                // process requires of the current undefine attribute\n                List<String> requires = resourceDescription.findRequires(ATTRIBUTES, u);\n                requires.forEach(ur -> {\n                    operations.putIfAbsent(ur, undefineAttribute(address, ur));\n                    localChanges.remove(ur);\n                });\n            });\n\n            write.forEach(w -> {\n                operations.putIfAbsent(w, writeAttribute(address, w, changeSet.get(w), resourceDescription));\n                localChanges.remove(w);\n                List<String> writeAlternatives = resourceDescription.findAlternatives(ATTRIBUTES, w);\n                // process alternatives of the current write attribute\n                writeAlternatives.forEach(wa -> {\n                    operations.putIfAbsent(wa, undefineAttribute(address, wa));\n                    localChanges.remove(wa);\n                });\n            });\n        }\n\n        // handle the remaining attributes\n        logger.debug(\"Process remaining attributes [{}]\", String.join(\", \", localChanges.keySet()));\n        localChanges.forEach((name, value) ->\n                operations.putIfAbsent(name, writeAttribute(address, name, value, resourceDescription)));\n        return new Composite(operations.values().stream().filter(Objects::nonNull).collect(toList()));\n    }", "signature": "Composite fromChangeSet(ResourceAddress address, Map<String, Object> changeSet,\n            Metadata metadata)", "full_signature": "public Composite fromChangeSet(ResourceAddress address, Map<String, Object> changeSet,\n            Metadata metadata)", "class_method_signature": "OperationFactory.fromChangeSet(ResourceAddress address, Map<String, Object> changeSet,\n            Metadata metadata)", "testcase": false, "constructor": false, "invocations": ["getDescription", "collect", "filter", "stream", "keySet", "get", "isNullOrEmpty", "toMap", "identity", "findAlternatives", "forEach", "debug", "join", "retainAll", "keySet", "isEmpty", "forEach", "findAttribute", "isDeprecated", "debug", "debug", "putIfAbsent", "undefineAttribute", "findRequires", "isEmpty", "debug", "join", "forEach", "putIfAbsent", "undefineAttribute", "add", "addAll", "debug", "join", "forEach", "isEmpty", "debug", "join", "collect", "stream", "groupingBy", "get", "isNullOrEmpty", "isDefaultValue", "getOrDefault", "emptyList", "getOrDefault", "emptyList", "size", "error", "join", "debug", "join", "join", "forEach", "putIfAbsent", "undefineAttribute", "remove", "findRequires", "forEach", "putIfAbsent", "undefineAttribute", "remove", "forEach", "putIfAbsent", "writeAttribute", "get", "remove", "findAlternatives", "forEach", "putIfAbsent", "undefineAttribute", "remove", "debug", "join", "keySet", "forEach", "putIfAbsent", "writeAttribute", "collect", "filter", "stream", "values", "toList"]}, "repository": {"repo_id": 38317187, "url": "https://github.com/hal/console", "stars": 34, "created": "6/30/2015 3:26:19 PM +00:00", "updates": "2020-01-26T16:25:43+00:00", "fork": "False", "license": "licensed"}}