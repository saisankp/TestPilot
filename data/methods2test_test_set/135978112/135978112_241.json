{"test_class": {"identifier": "MetadataTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private long refreshBackoffMs = 100;", "modifier": "private", "type": "long", "declarator": "refreshBackoffMs = 100", "var_name": "refreshBackoffMs"}, {"original_string": "private long metadataExpireMs = 1000;", "modifier": "private", "type": "long", "declarator": "metadataExpireMs = 1000", "var_name": "metadataExpireMs"}, {"original_string": "private Metadata metadata = new Metadata(refreshBackoffMs, metadataExpireMs);", "modifier": "private", "type": "Metadata", "declarator": "metadata = new Metadata(refreshBackoffMs, metadataExpireMs)", "var_name": "metadata"}, {"original_string": "private AtomicReference<String> backgroundError = new AtomicReference<String>();", "modifier": "private", "type": "AtomicReference<String>", "declarator": "backgroundError = new AtomicReference<String>()", "var_name": "backgroundError"}], "file": "clients/src/test/java/org/apache/kafka/clients/MetadataTest.java"}, "test_case": {"identifier": "testMetadata", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMetadata() throws Exception {\n        long time = 0;\n        metadata.update(Cluster.empty(), time);\n        assertFalse(\"No update needed.\", metadata.timeToNextUpdate(time) == 0);\n        metadata.requestUpdate();\n        assertFalse(\"Still no updated needed due to backoff\", metadata.timeToNextUpdate(time) == 0);\n        time += refreshBackoffMs;\n        assertTrue(\"Update needed now that backoff time expired\", metadata.timeToNextUpdate(time) == 0);\n        String topic = \"my-topic\";\n        Thread t1 = asyncFetch(topic);\n        Thread t2 = asyncFetch(topic);\n        assertTrue(\"Awaiting update\", t1.isAlive());\n        assertTrue(\"Awaiting update\", t2.isAlive());\n        // Perform metadata update when an update is requested on the async fetch thread\n        // This simulates the metadata update sequence in KafkaProducer\n        while (t1.isAlive() || t2.isAlive()) {\n            if (metadata.timeToNextUpdate(time) == 0) {\n                metadata.update(TestUtils.singletonCluster(topic, 1), time);\n                time += refreshBackoffMs;\n            }\n            Thread.sleep(1);\n        }\n        t1.join();\n        t2.join();\n        assertFalse(\"No update needed.\", metadata.timeToNextUpdate(time) == 0);\n        time += metadataExpireMs;\n        assertTrue(\"Update needed due to stale metadata.\", metadata.timeToNextUpdate(time) == 0);\n    }", "signature": "void testMetadata()", "full_signature": "@Test public void testMetadata()", "class_method_signature": "MetadataTest.testMetadata()", "testcase": true, "constructor": false, "invocations": ["update", "empty", "assertFalse", "timeToNextUpdate", "requestUpdate", "assertFalse", "timeToNextUpdate", "assertTrue", "timeToNextUpdate", "asyncFetch", "asyncFetch", "assertTrue", "isAlive", "assertTrue", "isAlive", "isAlive", "isAlive", "timeToNextUpdate", "update", "singletonCluster", "sleep", "join", "join", "assertFalse", "timeToNextUpdate", "assertTrue", "timeToNextUpdate"]}, "focal_class": {"identifier": "Metadata", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(Metadata.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(Metadata.class)", "var_name": "log"}, {"original_string": "private final long refreshBackoffMs;", "modifier": "private final", "type": "long", "declarator": "refreshBackoffMs", "var_name": "refreshBackoffMs"}, {"original_string": "private final long metadataExpireMs;", "modifier": "private final", "type": "long", "declarator": "metadataExpireMs", "var_name": "metadataExpireMs"}, {"original_string": "private int version;", "modifier": "private", "type": "int", "declarator": "version", "var_name": "version"}, {"original_string": "private long lastRefreshMs;", "modifier": "private", "type": "long", "declarator": "lastRefreshMs", "var_name": "lastRefreshMs"}, {"original_string": "private long lastSuccessfulRefreshMs;", "modifier": "private", "type": "long", "declarator": "lastSuccessfulRefreshMs", "var_name": "lastSuccessfulRefreshMs"}, {"original_string": "private Cluster cluster;", "modifier": "private", "type": "Cluster", "declarator": "cluster", "var_name": "cluster"}, {"original_string": "private boolean needUpdate;", "modifier": "private", "type": "boolean", "declarator": "needUpdate", "var_name": "needUpdate"}, {"original_string": "private final Set<String> topics;", "modifier": "private final", "type": "Set<String>", "declarator": "topics", "var_name": "topics"}, {"original_string": "private final List<Listener> listeners;", "modifier": "private final", "type": "List<Listener>", "declarator": "listeners", "var_name": "listeners"}, {"original_string": "private boolean needMetadataForAllTopics;", "modifier": "private", "type": "boolean", "declarator": "needMetadataForAllTopics", "var_name": "needMetadataForAllTopics"}], "methods": [{"identifier": "Metadata", "parameters": "()", "modifiers": "public", "return": "", "signature": " Metadata()", "full_signature": "public  Metadata()", "class_method_signature": "Metadata.Metadata()", "testcase": false, "constructor": true}, {"identifier": "Metadata", "parameters": "(long refreshBackoffMs, long metadataExpireMs)", "modifiers": "public", "return": "", "signature": " Metadata(long refreshBackoffMs, long metadataExpireMs)", "full_signature": "public  Metadata(long refreshBackoffMs, long metadataExpireMs)", "class_method_signature": "Metadata.Metadata(long refreshBackoffMs, long metadataExpireMs)", "testcase": false, "constructor": true}, {"identifier": "fetch", "parameters": "()", "modifiers": "public synchronized", "return": "Cluster", "signature": "Cluster fetch()", "full_signature": "public synchronized Cluster fetch()", "class_method_signature": "Metadata.fetch()", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(String topic)", "modifiers": "public synchronized", "return": "void", "signature": "void add(String topic)", "full_signature": "public synchronized void add(String topic)", "class_method_signature": "Metadata.add(String topic)", "testcase": false, "constructor": false}, {"identifier": "timeToNextUpdate", "parameters": "(long nowMs)", "modifiers": "public synchronized", "return": "long", "signature": "long timeToNextUpdate(long nowMs)", "full_signature": "public synchronized long timeToNextUpdate(long nowMs)", "class_method_signature": "Metadata.timeToNextUpdate(long nowMs)", "testcase": false, "constructor": false}, {"identifier": "requestUpdate", "parameters": "()", "modifiers": "public synchronized", "return": "int", "signature": "int requestUpdate()", "full_signature": "public synchronized int requestUpdate()", "class_method_signature": "Metadata.requestUpdate()", "testcase": false, "constructor": false}, {"identifier": "updateRequested", "parameters": "()", "modifiers": "public synchronized", "return": "boolean", "signature": "boolean updateRequested()", "full_signature": "public synchronized boolean updateRequested()", "class_method_signature": "Metadata.updateRequested()", "testcase": false, "constructor": false}, {"identifier": "awaitUpdate", "parameters": "(final int lastVersion, final long maxWaitMs)", "modifiers": "public synchronized", "return": "void", "signature": "void awaitUpdate(final int lastVersion, final long maxWaitMs)", "full_signature": "public synchronized void awaitUpdate(final int lastVersion, final long maxWaitMs)", "class_method_signature": "Metadata.awaitUpdate(final int lastVersion, final long maxWaitMs)", "testcase": false, "constructor": false}, {"identifier": "setTopics", "parameters": "(Collection<String> topics)", "modifiers": "public synchronized", "return": "void", "signature": "void setTopics(Collection<String> topics)", "full_signature": "public synchronized void setTopics(Collection<String> topics)", "class_method_signature": "Metadata.setTopics(Collection<String> topics)", "testcase": false, "constructor": false}, {"identifier": "topics", "parameters": "()", "modifiers": "public synchronized", "return": "Set<String>", "signature": "Set<String> topics()", "full_signature": "public synchronized Set<String> topics()", "class_method_signature": "Metadata.topics()", "testcase": false, "constructor": false}, {"identifier": "containsTopic", "parameters": "(String topic)", "modifiers": "public synchronized", "return": "boolean", "signature": "boolean containsTopic(String topic)", "full_signature": "public synchronized boolean containsTopic(String topic)", "class_method_signature": "Metadata.containsTopic(String topic)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(Cluster cluster, long now)", "modifiers": "public synchronized", "return": "void", "signature": "void update(Cluster cluster, long now)", "full_signature": "public synchronized void update(Cluster cluster, long now)", "class_method_signature": "Metadata.update(Cluster cluster, long now)", "testcase": false, "constructor": false}, {"identifier": "failedUpdate", "parameters": "(long now)", "modifiers": "public synchronized", "return": "void", "signature": "void failedUpdate(long now)", "full_signature": "public synchronized void failedUpdate(long now)", "class_method_signature": "Metadata.failedUpdate(long now)", "testcase": false, "constructor": false}, {"identifier": "version", "parameters": "()", "modifiers": "public synchronized", "return": "int", "signature": "int version()", "full_signature": "public synchronized int version()", "class_method_signature": "Metadata.version()", "testcase": false, "constructor": false}, {"identifier": "lastSuccessfulUpdate", "parameters": "()", "modifiers": "public synchronized", "return": "long", "signature": "long lastSuccessfulUpdate()", "full_signature": "public synchronized long lastSuccessfulUpdate()", "class_method_signature": "Metadata.lastSuccessfulUpdate()", "testcase": false, "constructor": false}, {"identifier": "refreshBackoff", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long refreshBackoff()", "full_signature": "public long refreshBackoff()", "class_method_signature": "Metadata.refreshBackoff()", "testcase": false, "constructor": false}, {"identifier": "needMetadataForAllTopics", "parameters": "(boolean needMetadataForAllTopics)", "modifiers": "public synchronized", "return": "void", "signature": "void needMetadataForAllTopics(boolean needMetadataForAllTopics)", "full_signature": "public synchronized void needMetadataForAllTopics(boolean needMetadataForAllTopics)", "class_method_signature": "Metadata.needMetadataForAllTopics(boolean needMetadataForAllTopics)", "testcase": false, "constructor": false}, {"identifier": "needMetadataForAllTopics", "parameters": "()", "modifiers": "public synchronized", "return": "boolean", "signature": "boolean needMetadataForAllTopics()", "full_signature": "public synchronized boolean needMetadataForAllTopics()", "class_method_signature": "Metadata.needMetadataForAllTopics()", "testcase": false, "constructor": false}, {"identifier": "addListener", "parameters": "(Listener listener)", "modifiers": "public synchronized", "return": "void", "signature": "void addListener(Listener listener)", "full_signature": "public synchronized void addListener(Listener listener)", "class_method_signature": "Metadata.addListener(Listener listener)", "testcase": false, "constructor": false}, {"identifier": "removeListener", "parameters": "(Listener listener)", "modifiers": "public synchronized", "return": "void", "signature": "void removeListener(Listener listener)", "full_signature": "public synchronized void removeListener(Listener listener)", "class_method_signature": "Metadata.removeListener(Listener listener)", "testcase": false, "constructor": false}, {"identifier": "getClusterForCurrentTopics", "parameters": "(Cluster cluster)", "modifiers": "private", "return": "Cluster", "signature": "Cluster getClusterForCurrentTopics(Cluster cluster)", "full_signature": "private Cluster getClusterForCurrentTopics(Cluster cluster)", "class_method_signature": "Metadata.getClusterForCurrentTopics(Cluster cluster)", "testcase": false, "constructor": false}], "file": "clients/src/main/java/org/apache/kafka/clients/Metadata.java"}, "focal_method": {"identifier": "Metadata", "parameters": "()", "modifiers": "public", "return": "", "body": "public Metadata() {\n        this(100L, 60 * 60 * 1000L);\n    }", "signature": " Metadata()", "full_signature": "public  Metadata()", "class_method_signature": "Metadata.Metadata()", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}