{"test_class": {"identifier": "SelectorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "protected static final int BUFFER_SIZE = 4 * 1024;", "modifier": "protected static final", "type": "int", "declarator": "BUFFER_SIZE = 4 * 1024", "var_name": "BUFFER_SIZE"}, {"original_string": "protected EchoServer server;", "modifier": "protected", "type": "EchoServer", "declarator": "server", "var_name": "server"}, {"original_string": "protected Time time;", "modifier": "protected", "type": "Time", "declarator": "time", "var_name": "time"}, {"original_string": "protected Selector selector;", "modifier": "protected", "type": "Selector", "declarator": "selector", "var_name": "selector"}, {"original_string": "protected ChannelBuilder channelBuilder;", "modifier": "protected", "type": "ChannelBuilder", "declarator": "channelBuilder", "var_name": "channelBuilder"}, {"original_string": "private Metrics metrics;", "modifier": "private", "type": "Metrics", "declarator": "metrics", "var_name": "metrics"}], "file": "clients/src/test/java/org/apache/kafka/common/network/SelectorTest.java"}, "test_case": {"identifier": "testNoRouteToHost", "parameters": "()", "modifiers": "@Test(expected = IOException.class) public", "return": "void", "body": "@Test(expected = IOException.class)\n    public void testNoRouteToHost() throws Exception {\n        selector.connect(\"0\", new InetSocketAddress(\"asdf.asdf.dsc\", server.port), BUFFER_SIZE, BUFFER_SIZE);\n    }", "signature": "void testNoRouteToHost()", "full_signature": "@Test(expected = IOException.class) public void testNoRouteToHost()", "class_method_signature": "SelectorTest.testNoRouteToHost()", "testcase": true, "constructor": false, "invocations": ["connect"]}, "focal_class": {"identifier": "Selector", "superclass": "", "interfaces": "implements Selectable", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(Selector.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(Selector.class)", "var_name": "log"}, {"original_string": "private final java.nio.channels.Selector nioSelector;", "modifier": "private final", "type": "java.nio.channels.Selector", "declarator": "nioSelector", "var_name": "nioSelector"}, {"original_string": "private final Map<String/* nodeId */, KafkaChannel> channels;", "modifier": "private final", "type": "Map<String/* nodeId */, KafkaChannel>", "declarator": "channels", "var_name": "channels"}, {"original_string": "private final List<Send> completedSends;", "modifier": "private final", "type": "List<Send>", "declarator": "completedSends", "var_name": "completedSends"}, {"original_string": "private final List<NetworkReceive> completedReceives;", "modifier": "private final", "type": "List<NetworkReceive>", "declarator": "completedReceives", "var_name": "completedReceives"}, {"original_string": "private final Map<KafkaChannel, Deque<NetworkReceive>> stagedReceives;", "modifier": "private final", "type": "Map<KafkaChannel, Deque<NetworkReceive>>", "declarator": "stagedReceives", "var_name": "stagedReceives"}, {"original_string": "private final Set<SelectionKey> immediatelyConnectedKeys;", "modifier": "private final", "type": "Set<SelectionKey>", "declarator": "immediatelyConnectedKeys", "var_name": "immediatelyConnectedKeys"}, {"original_string": "private final List<String> disconnected;", "modifier": "private final", "type": "List<String>", "declarator": "disconnected", "var_name": "disconnected"}, {"original_string": "private final List<String> connected;", "modifier": "private final", "type": "List<String>", "declarator": "connected", "var_name": "connected"}, {"original_string": "private final List<String> failedSends;", "modifier": "private final", "type": "List<String>", "declarator": "failedSends", "var_name": "failedSends"}, {"original_string": "private final Time time;", "modifier": "private final", "type": "Time", "declarator": "time", "var_name": "time"}, {"original_string": "private final SelectorMetrics sensors;", "modifier": "private final", "type": "SelectorMetrics", "declarator": "sensors", "var_name": "sensors"}, {"original_string": "private final String metricGrpPrefix;", "modifier": "private final", "type": "String", "declarator": "metricGrpPrefix", "var_name": "metricGrpPrefix"}, {"original_string": "private final Map<String, String> metricTags;", "modifier": "private final", "type": "Map<String, String>", "declarator": "metricTags", "var_name": "metricTags"}, {"original_string": "private final ChannelBuilder channelBuilder;", "modifier": "private final", "type": "ChannelBuilder", "declarator": "channelBuilder", "var_name": "channelBuilder"}, {"original_string": "private final Map<String, Long> lruConnections;", "modifier": "private final", "type": "Map<String, Long>", "declarator": "lruConnections", "var_name": "lruConnections"}, {"original_string": "private final long connectionsMaxIdleNanos;", "modifier": "private final", "type": "long", "declarator": "connectionsMaxIdleNanos", "var_name": "connectionsMaxIdleNanos"}, {"original_string": "private final int maxReceiveSize;", "modifier": "private final", "type": "int", "declarator": "maxReceiveSize", "var_name": "maxReceiveSize"}, {"original_string": "private final boolean metricsPerConnection;", "modifier": "private final", "type": "boolean", "declarator": "metricsPerConnection", "var_name": "metricsPerConnection"}, {"original_string": "private long currentTimeNanos;", "modifier": "private", "type": "long", "declarator": "currentTimeNanos", "var_name": "currentTimeNanos"}, {"original_string": "private long nextIdleCloseCheckTime;", "modifier": "private", "type": "long", "declarator": "nextIdleCloseCheckTime", "var_name": "nextIdleCloseCheckTime"}], "methods": [{"identifier": "Selector", "parameters": "(int maxReceiveSize, long connectionMaxIdleMs, Metrics metrics, Time time, String metricGrpPrefix, Map<String, String> metricTags, boolean metricsPerConnection,\n        ChannelBuilder channelBuilder)", "modifiers": "public", "return": "", "signature": " Selector(int maxReceiveSize, long connectionMaxIdleMs, Metrics metrics, Time time, String metricGrpPrefix, Map<String, String> metricTags, boolean metricsPerConnection,\n        ChannelBuilder channelBuilder)", "full_signature": "public  Selector(int maxReceiveSize, long connectionMaxIdleMs, Metrics metrics, Time time, String metricGrpPrefix, Map<String, String> metricTags, boolean metricsPerConnection,\n        ChannelBuilder channelBuilder)", "class_method_signature": "Selector.Selector(int maxReceiveSize, long connectionMaxIdleMs, Metrics metrics, Time time, String metricGrpPrefix, Map<String, String> metricTags, boolean metricsPerConnection,\n        ChannelBuilder channelBuilder)", "testcase": false, "constructor": true}, {"identifier": "Selector", "parameters": "(long connectionMaxIdleMS, Metrics metrics, Time time, String metricGrpPrefix, ChannelBuilder channelBuilder)", "modifiers": "public", "return": "", "signature": " Selector(long connectionMaxIdleMS, Metrics metrics, Time time, String metricGrpPrefix, ChannelBuilder channelBuilder)", "full_signature": "public  Selector(long connectionMaxIdleMS, Metrics metrics, Time time, String metricGrpPrefix, ChannelBuilder channelBuilder)", "class_method_signature": "Selector.Selector(long connectionMaxIdleMS, Metrics metrics, Time time, String metricGrpPrefix, ChannelBuilder channelBuilder)", "testcase": false, "constructor": true}, {"identifier": "connect", "parameters": "(String id, InetSocketAddress address, int sendBufferSize, int receiveBufferSize)", "modifiers": "@Override public", "return": "void", "signature": "void connect(String id, InetSocketAddress address, int sendBufferSize, int receiveBufferSize)", "full_signature": "@Override public void connect(String id, InetSocketAddress address, int sendBufferSize, int receiveBufferSize)", "class_method_signature": "Selector.connect(String id, InetSocketAddress address, int sendBufferSize, int receiveBufferSize)", "testcase": false, "constructor": false}, {"identifier": "register", "parameters": "(String id, SocketChannel socketChannel)", "modifiers": "public", "return": "void", "signature": "void register(String id, SocketChannel socketChannel)", "full_signature": "public void register(String id, SocketChannel socketChannel)", "class_method_signature": "Selector.register(String id, SocketChannel socketChannel)", "testcase": false, "constructor": false}, {"identifier": "wakeup", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void wakeup()", "full_signature": "@Override public void wakeup()", "class_method_signature": "Selector.wakeup()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "Selector.close()", "testcase": false, "constructor": false}, {"identifier": "send", "parameters": "(Send send)", "modifiers": "public", "return": "void", "signature": "void send(Send send)", "full_signature": "public void send(Send send)", "class_method_signature": "Selector.send(Send send)", "testcase": false, "constructor": false}, {"identifier": "poll", "parameters": "(long timeout)", "modifiers": "@Override public", "return": "void", "signature": "void poll(long timeout)", "full_signature": "@Override public void poll(long timeout)", "class_method_signature": "Selector.poll(long timeout)", "testcase": false, "constructor": false}, {"identifier": "pollSelectionKeys", "parameters": "(Iterable<SelectionKey> selectionKeys, boolean isImmediatelyConnected)", "modifiers": "private", "return": "void", "signature": "void pollSelectionKeys(Iterable<SelectionKey> selectionKeys, boolean isImmediatelyConnected)", "full_signature": "private void pollSelectionKeys(Iterable<SelectionKey> selectionKeys, boolean isImmediatelyConnected)", "class_method_signature": "Selector.pollSelectionKeys(Iterable<SelectionKey> selectionKeys, boolean isImmediatelyConnected)", "testcase": false, "constructor": false}, {"identifier": "main", "parameters": "(String[] args)", "modifiers": "public static", "return": "void", "signature": "void main(String[] args)", "full_signature": "public static void main(String[] args)", "class_method_signature": "Selector.main(String[] args)", "testcase": false, "constructor": false}, {"identifier": "completedSends", "parameters": "()", "modifiers": "@Override public", "return": "List<Send>", "signature": "List<Send> completedSends()", "full_signature": "@Override public List<Send> completedSends()", "class_method_signature": "Selector.completedSends()", "testcase": false, "constructor": false}, {"identifier": "completedReceives", "parameters": "()", "modifiers": "@Override public", "return": "List<NetworkReceive>", "signature": "List<NetworkReceive> completedReceives()", "full_signature": "@Override public List<NetworkReceive> completedReceives()", "class_method_signature": "Selector.completedReceives()", "testcase": false, "constructor": false}, {"identifier": "disconnected", "parameters": "()", "modifiers": "@Override public", "return": "List<String>", "signature": "List<String> disconnected()", "full_signature": "@Override public List<String> disconnected()", "class_method_signature": "Selector.disconnected()", "testcase": false, "constructor": false}, {"identifier": "connected", "parameters": "()", "modifiers": "@Override public", "return": "List<String>", "signature": "List<String> connected()", "full_signature": "@Override public List<String> connected()", "class_method_signature": "Selector.connected()", "testcase": false, "constructor": false}, {"identifier": "maybeCloseOldestConnection", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void maybeCloseOldestConnection()", "full_signature": "private void maybeCloseOldestConnection()", "class_method_signature": "Selector.maybeCloseOldestConnection()", "testcase": false, "constructor": false}, {"identifier": "clear", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void clear()", "full_signature": "private void clear()", "class_method_signature": "Selector.clear()", "testcase": false, "constructor": false}, {"identifier": "select", "parameters": "(long ms)", "modifiers": "private", "return": "int", "signature": "int select(long ms)", "full_signature": "private int select(long ms)", "class_method_signature": "Selector.select(long ms)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "(String id)", "modifiers": "public", "return": "void", "signature": "void close(String id)", "full_signature": "public void close(String id)", "class_method_signature": "Selector.close(String id)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "(KafkaChannel channel)", "modifiers": "private", "return": "void", "signature": "void close(KafkaChannel channel)", "full_signature": "private void close(KafkaChannel channel)", "class_method_signature": "Selector.close(KafkaChannel channel)", "testcase": false, "constructor": false}, {"identifier": "isChannelReady", "parameters": "(String id)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isChannelReady(String id)", "full_signature": "@Override public boolean isChannelReady(String id)", "class_method_signature": "Selector.isChannelReady(String id)", "testcase": false, "constructor": false}, {"identifier": "channelOrFail", "parameters": "(String id)", "modifiers": "private", "return": "KafkaChannel", "signature": "KafkaChannel channelOrFail(String id)", "full_signature": "private KafkaChannel channelOrFail(String id)", "class_method_signature": "Selector.channelOrFail(String id)", "testcase": false, "constructor": false}, {"identifier": "channels", "parameters": "()", "modifiers": "public", "return": "List<KafkaChannel>", "signature": "List<KafkaChannel> channels()", "full_signature": "public List<KafkaChannel> channels()", "class_method_signature": "Selector.channels()", "testcase": false, "constructor": false}, {"identifier": "channel", "parameters": "(String id)", "modifiers": "public", "return": "KafkaChannel", "signature": "KafkaChannel channel(String id)", "full_signature": "public KafkaChannel channel(String id)", "class_method_signature": "Selector.channel(String id)", "testcase": false, "constructor": false}, {"identifier": "channel", "parameters": "(SelectionKey key)", "modifiers": "private", "return": "KafkaChannel", "signature": "KafkaChannel channel(SelectionKey key)", "full_signature": "private KafkaChannel channel(SelectionKey key)", "class_method_signature": "Selector.channel(SelectionKey key)", "testcase": false, "constructor": false}, {"identifier": "hasStagedReceive", "parameters": "(KafkaChannel channel)", "modifiers": "private", "return": "boolean", "signature": "boolean hasStagedReceive(KafkaChannel channel)", "full_signature": "private boolean hasStagedReceive(KafkaChannel channel)", "class_method_signature": "Selector.hasStagedReceive(KafkaChannel channel)", "testcase": false, "constructor": false}, {"identifier": "hasStagedReceives", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean hasStagedReceives()", "full_signature": "private boolean hasStagedReceives()", "class_method_signature": "Selector.hasStagedReceives()", "testcase": false, "constructor": false}, {"identifier": "addToStagedReceives", "parameters": "(KafkaChannel channel, NetworkReceive receive)", "modifiers": "private", "return": "void", "signature": "void addToStagedReceives(KafkaChannel channel, NetworkReceive receive)", "full_signature": "private void addToStagedReceives(KafkaChannel channel, NetworkReceive receive)", "class_method_signature": "Selector.addToStagedReceives(KafkaChannel channel, NetworkReceive receive)", "testcase": false, "constructor": false}, {"identifier": "addToCompletedReceives", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void addToCompletedReceives()", "full_signature": "private void addToCompletedReceives()", "class_method_signature": "Selector.addToCompletedReceives()", "testcase": false, "constructor": false}, {"identifier": "mute", "parameters": "(String id)", "modifiers": "@Override public", "return": "void", "signature": "void mute(String id)", "full_signature": "@Override public void mute(String id)", "class_method_signature": "Selector.mute(String id)", "testcase": false, "constructor": false}, {"identifier": "mute", "parameters": "(KafkaChannel channel)", "modifiers": "private", "return": "void", "signature": "void mute(KafkaChannel channel)", "full_signature": "private void mute(KafkaChannel channel)", "class_method_signature": "Selector.mute(KafkaChannel channel)", "testcase": false, "constructor": false}, {"identifier": "unmute", "parameters": "(String id)", "modifiers": "@Override public", "return": "void", "signature": "void unmute(String id)", "full_signature": "@Override public void unmute(String id)", "class_method_signature": "Selector.unmute(String id)", "testcase": false, "constructor": false}, {"identifier": "unmute", "parameters": "(KafkaChannel channel)", "modifiers": "private", "return": "void", "signature": "void unmute(KafkaChannel channel)", "full_signature": "private void unmute(KafkaChannel channel)", "class_method_signature": "Selector.unmute(KafkaChannel channel)", "testcase": false, "constructor": false}, {"identifier": "muteAll", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void muteAll()", "full_signature": "@Override public void muteAll()", "class_method_signature": "Selector.muteAll()", "testcase": false, "constructor": false}, {"identifier": "unmuteAll", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void unmuteAll()", "full_signature": "@Override public void unmuteAll()", "class_method_signature": "Selector.unmuteAll()", "testcase": false, "constructor": false}], "file": "clients/src/main/java/org/apache/kafka/common/network/Selector.java"}, "focal_method": {"identifier": "connect", "parameters": "(String id, InetSocketAddress address, int sendBufferSize, int receiveBufferSize)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void connect(String id, InetSocketAddress address, int sendBufferSize, int receiveBufferSize) throws IOException {\n        if (this.channels.containsKey(id)) {\n            throw new IllegalStateException(\"There is already a connection for id \" + id);\n        }\n\n        SocketChannel socketChannel = SocketChannel.open();// \u521b\u5efa\u4e00\u4e2asocketChannel\uff0c\u5e76\u4e14\u5728\u540e\u7eed\u8c03\u7528 socketChannel.connect(address)\uff0c\u65f6\u6253\u5f00\u8fde\u63a5\n        socketChannel.configureBlocking(false);// \u975e\u963b\u585e\u6a21\u5f0f\n        Socket socket = socketChannel.socket();\n        socket.setKeepAlive(true);// \u8bbe\u7f6e\u4e3a\u957f\u8fde\u63a5\n        if (sendBufferSize != Selectable.USE_DEFAULT_BUFFER_SIZE) {\n            socket.setSendBufferSize(sendBufferSize);// \u8bbe\u7f6eSO_SNDBUF \u5927\u5c0f\n        }\n        if (receiveBufferSize != Selectable.USE_DEFAULT_BUFFER_SIZE) {\n            socket.setReceiveBufferSize(receiveBufferSize);// \u8bbe\u7f6e SO_RCVBUF \u5927\u5c0f\n        }\n        socket.setTcpNoDelay(true);\n        boolean connected;\n        try {\n            connected = socketChannel.connect(address);// \u56e0\u4e3a\u662f\u975e\u963b\u585e\u6a21\u5f0f\uff0c\u6240\u4ee5\u65b9\u6cd5\u53ef\u80fd\u4f1a\u5728\u8fde\u63a5\u6b63\u5f0f\u8fde\u63a5\u4e4b\u524d\u8fd4\u56de\n        } catch (UnresolvedAddressException e) {\n            socketChannel.close();\n            throw new IOException(\"Can't resolve address: \" + address, e);\n        } catch (IOException e) {\n            socketChannel.close();\n            throw e;\n        }\n        SelectionKey key = socketChannel.register(nioSelector, SelectionKey.OP_CONNECT);// \u5c06\u5f53\u524d\u8fd9\u4e2asocketChannel\u6ce8\u518c\u5230nioSelector\u4e0a\uff0c\u5e76\u5173\u6ce8OP_CONNECT\u4e8b\u4ef6\n        KafkaChannel channel = channelBuilder.buildChannel(id, key, maxReceiveSize);// \u521b\u5efaKafkaChannel\n        key.attach(channel);// \u5c06channel\u7ed1\u5b9a\u5230key\u4e0a\n        this.channels.put(id, channel);// \u5c06 nodeId \u548c Channel\u7ed1\u5b9a\n\n        if (connected) {\n            // OP_CONNECT won't trigger for immediately connected channels\n            log.debug(\"Immediately connected to node {}\", channel.id());\n            immediatelyConnectedKeys.add(key);\n            key.interestOps(0);\n        }\n    }", "signature": "void connect(String id, InetSocketAddress address, int sendBufferSize, int receiveBufferSize)", "full_signature": "@Override public void connect(String id, InetSocketAddress address, int sendBufferSize, int receiveBufferSize)", "class_method_signature": "Selector.connect(String id, InetSocketAddress address, int sendBufferSize, int receiveBufferSize)", "testcase": false, "constructor": false, "invocations": ["containsKey", "open", "configureBlocking", "socket", "setKeepAlive", "setSendBufferSize", "setReceiveBufferSize", "setTcpNoDelay", "connect", "close", "close", "register", "buildChannel", "attach", "put", "debug", "id", "add", "interestOps"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}