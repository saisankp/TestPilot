{"test_class": {"identifier": "DubboProtocolTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();", "modifier": "private", "type": "Protocol", "declarator": "protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()", "var_name": "protocol"}, {"original_string": "private ProxyFactory proxy = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();", "modifier": "private", "type": "ProxyFactory", "declarator": "proxy = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension()", "var_name": "proxy"}], "file": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboProtocolTest.java"}, "test_case": {"identifier": "testDubboProtocol", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDubboProtocol() throws Exception {\n        DemoService service = new DemoServiceImpl();\n        protocol.export(proxy.getInvoker(service, DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:9010/\" + DemoService.class.getName())));\n        service = proxy.getProxy(protocol.refer(DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:9010/\" + DemoService.class.getName())));\n        assertEquals(service.enumlength(new Type[]{}), Type.Lower);\n        assertEquals(service.getSize(null), -1);\n        assertEquals(service.getSize(new String[]{\"\", \"\", \"\"}), 3);\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"aa\", \"bb\");\n        Set<String> set = service.keys(map);\n        assertEquals(set.size(), 1);\n        assertEquals(set.iterator().next(), \"aa\");\n        service.invoke(\"dubbo://127.0.0.1:9010/\" + DemoService.class.getName() + \"\", \"invoke\");\n\n        service = proxy.getProxy(protocol.refer(DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:9010/\" + DemoService.class.getName() + \"?client=netty\")));\n        // test netty client\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < 1024 * 32 + 32; i++)\n            buf.append('A');\n        System.out.println(service.stringLength(buf.toString()));\n\n        // cast to EchoService\n        EchoService echo = proxy.getProxy(protocol.refer(EchoService.class, URL.valueOf(\"dubbo://127.0.0.1:9010/\" + DemoService.class.getName() + \"?client=netty\")));\n        assertEquals(echo.$echo(buf.toString()), buf.toString());\n        assertEquals(echo.$echo(\"test\"), \"test\");\n        assertEquals(echo.$echo(\"abcdefg\"), \"abcdefg\");\n        assertEquals(echo.$echo(1234), 1234);\n    }", "signature": "void testDubboProtocol()", "full_signature": "@Test public void testDubboProtocol()", "class_method_signature": "DubboProtocolTest.testDubboProtocol()", "testcase": true, "constructor": false, "invocations": ["export", "getInvoker", "valueOf", "getName", "getProxy", "refer", "valueOf", "getName", "assertEquals", "enumlength", "assertEquals", "getSize", "assertEquals", "getSize", "put", "keys", "assertEquals", "size", "assertEquals", "next", "iterator", "invoke", "getName", "getProxy", "refer", "valueOf", "getName", "append", "println", "stringLength", "toString", "getProxy", "refer", "valueOf", "getName", "assertEquals", "echo", "toString", "toString", "assertEquals", "echo", "assertEquals", "echo", "assertEquals", "echo"]}, "focal_class": {"identifier": "DubboProtocol", "superclass": "extends AbstractProtocol", "interfaces": "", "fields": [{"original_string": "public static final String NAME = \"dubbo\";", "modifier": "public static final", "type": "String", "declarator": "NAME = \"dubbo\"", "var_name": "NAME"}, {"original_string": "public static final int DEFAULT_PORT = 20880;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_PORT = 20880", "var_name": "DEFAULT_PORT"}, {"original_string": "private static final String IS_CALLBACK_SERVICE_INVOKE = \"_isCallBackServiceInvoke\";", "modifier": "private static final", "type": "String", "declarator": "IS_CALLBACK_SERVICE_INVOKE = \"_isCallBackServiceInvoke\"", "var_name": "IS_CALLBACK_SERVICE_INVOKE"}, {"original_string": "private static DubboProtocol INSTANCE;", "modifier": "private static", "type": "DubboProtocol", "declarator": "INSTANCE", "var_name": "INSTANCE"}, {"original_string": "private final Map<String, ExchangeServer> serverMap = new ConcurrentHashMap<String, ExchangeServer>();", "modifier": "private final", "type": "Map<String, ExchangeServer>", "declarator": "serverMap = new ConcurrentHashMap<String, ExchangeServer>()", "var_name": "serverMap"}, {"original_string": "private final Map<String, ReferenceCountExchangeClient> referenceClientMap = new ConcurrentHashMap<String, ReferenceCountExchangeClient>();", "modifier": "private final", "type": "Map<String, ReferenceCountExchangeClient>", "declarator": "referenceClientMap = new ConcurrentHashMap<String, ReferenceCountExchangeClient>()", "var_name": "referenceClientMap"}, {"original_string": "private final ConcurrentMap<String, LazyConnectExchangeClient> ghostClientMap = new ConcurrentHashMap<String, LazyConnectExchangeClient>();", "modifier": "private final", "type": "ConcurrentMap<String, LazyConnectExchangeClient>", "declarator": "ghostClientMap = new ConcurrentHashMap<String, LazyConnectExchangeClient>()", "var_name": "ghostClientMap"}, {"original_string": "private final ConcurrentMap<String, Object> locks = new ConcurrentHashMap<String, Object>();", "modifier": "private final", "type": "ConcurrentMap<String, Object>", "declarator": "locks = new ConcurrentHashMap<String, Object>()", "var_name": "locks"}, {"original_string": "private final Set<String> optimizers = new ConcurrentHashSet<String>();", "modifier": "private final", "type": "Set<String>", "declarator": "optimizers = new ConcurrentHashSet<String>()", "var_name": "optimizers"}, {"original_string": "private final ConcurrentMap<String, String> stubServiceMethodsMap = new ConcurrentHashMap<String, String>();", "modifier": "private final", "type": "ConcurrentMap<String, String>", "declarator": "stubServiceMethodsMap = new ConcurrentHashMap<String, String>()", "var_name": "stubServiceMethodsMap"}, {"original_string": "private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() {\n\n        @Override\n        public Object reply(ExchangeChannel channel, Object message) throws RemotingException {\n            if (message instanceof Invocation) {\n                Invocation inv = (Invocation) message;\n                Invoker<?> invoker = getInvoker(channel, inv);\n                // need to consider backward-compatibility if it's a callback\n                if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {\n                    String methodsStr = invoker.getUrl().getParameters().get(\"methods\");\n                    boolean hasMethod = false;\n                    if (methodsStr == null || methodsStr.indexOf(\",\") == -1) {\n                        hasMethod = inv.getMethodName().equals(methodsStr);\n                    } else {\n                        String[] methods = methodsStr.split(\",\");\n                        for (String method : methods) {\n                            if (inv.getMethodName().equals(method)) {\n                                hasMethod = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (!hasMethod) {\n                        logger.warn(new IllegalStateException(\"The methodName \" + inv.getMethodName()\n                                + \" not found in callback service interface ,invoke will be ignored.\"\n                                + \" please update the api interface. url is:\"\n                                + invoker.getUrl()) + \" ,invocation is :\" + inv);\n                        return null;\n                    }\n                }\n                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());\n                return invoker.invoke(inv);\n            }\n            throw new RemotingException(channel, \"Unsupported request: \"\n                    + (message == null ? null : (message.getClass().getName() + \": \" + message))\n                    + \", channel: consumer: \" + channel.getRemoteAddress() + \" --> provider: \" + channel.getLocalAddress());\n        }\n\n        @Override\n        public void received(Channel channel, Object message) throws RemotingException {\n            if (message instanceof Invocation) {\n                reply((ExchangeChannel) channel, message);\n            } else {\n                super.received(channel, message);\n            }\n        }\n\n        @Override\n        public void connected(Channel channel) throws RemotingException {\n            invoke(channel, Constants.ON_CONNECT_KEY);\n        }\n\n        @Override\n        public void disconnected(Channel channel) throws RemotingException {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"disconnected from \" + channel.getRemoteAddress() + \",url:\" + channel.getUrl());\n            }\n            invoke(channel, Constants.ON_DISCONNECT_KEY);\n        }\n\n        private void invoke(Channel channel, String methodKey) {\n            Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);\n            if (invocation != null) {\n                try {\n                    received(channel, invocation);\n                } catch (Throwable t) {\n                    logger.warn(\"Failed to invoke event method \" + invocation.getMethodName() + \"(), cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n\n        private Invocation createInvocation(Channel channel, URL url, String methodKey) {\n            String method = url.getParameter(methodKey);\n            if (method == null || method.length() == 0) {\n                return null;\n            }\n            RpcInvocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);\n            invocation.setAttachment(Constants.PATH_KEY, url.getPath());\n            invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));\n            invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));\n            invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY));\n            if (url.getParameter(Constants.STUB_EVENT_KEY, false)) {\n                invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString());\n            }\n            return invocation;\n        }\n    };", "modifier": "private", "type": "ExchangeHandler", "declarator": "requestHandler = new ExchangeHandlerAdapter() {\n\n        @Override\n        public Object reply(ExchangeChannel channel, Object message) throws RemotingException {\n            if (message instanceof Invocation) {\n                Invocation inv = (Invocation) message;\n                Invoker<?> invoker = getInvoker(channel, inv);\n                // need to consider backward-compatibility if it's a callback\n                if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {\n                    String methodsStr = invoker.getUrl().getParameters().get(\"methods\");\n                    boolean hasMethod = false;\n                    if (methodsStr == null || methodsStr.indexOf(\",\") == -1) {\n                        hasMethod = inv.getMethodName().equals(methodsStr);\n                    } else {\n                        String[] methods = methodsStr.split(\",\");\n                        for (String method : methods) {\n                            if (inv.getMethodName().equals(method)) {\n                                hasMethod = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (!hasMethod) {\n                        logger.warn(new IllegalStateException(\"The methodName \" + inv.getMethodName()\n                                + \" not found in callback service interface ,invoke will be ignored.\"\n                                + \" please update the api interface. url is:\"\n                                + invoker.getUrl()) + \" ,invocation is :\" + inv);\n                        return null;\n                    }\n                }\n                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());\n                return invoker.invoke(inv);\n            }\n            throw new RemotingException(channel, \"Unsupported request: \"\n                    + (message == null ? null : (message.getClass().getName() + \": \" + message))\n                    + \", channel: consumer: \" + channel.getRemoteAddress() + \" --> provider: \" + channel.getLocalAddress());\n        }\n\n        @Override\n        public void received(Channel channel, Object message) throws RemotingException {\n            if (message instanceof Invocation) {\n                reply((ExchangeChannel) channel, message);\n            } else {\n                super.received(channel, message);\n            }\n        }\n\n        @Override\n        public void connected(Channel channel) throws RemotingException {\n            invoke(channel, Constants.ON_CONNECT_KEY);\n        }\n\n        @Override\n        public void disconnected(Channel channel) throws RemotingException {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"disconnected from \" + channel.getRemoteAddress() + \",url:\" + channel.getUrl());\n            }\n            invoke(channel, Constants.ON_DISCONNECT_KEY);\n        }\n\n        private void invoke(Channel channel, String methodKey) {\n            Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);\n            if (invocation != null) {\n                try {\n                    received(channel, invocation);\n                } catch (Throwable t) {\n                    logger.warn(\"Failed to invoke event method \" + invocation.getMethodName() + \"(), cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n\n        private Invocation createInvocation(Channel channel, URL url, String methodKey) {\n            String method = url.getParameter(methodKey);\n            if (method == null || method.length() == 0) {\n                return null;\n            }\n            RpcInvocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);\n            invocation.setAttachment(Constants.PATH_KEY, url.getPath());\n            invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));\n            invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));\n            invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY));\n            if (url.getParameter(Constants.STUB_EVENT_KEY, false)) {\n                invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString());\n            }\n            return invocation;\n        }\n    }", "var_name": "requestHandler"}], "methods": [{"identifier": "DubboProtocol", "parameters": "()", "modifiers": "public", "return": "", "signature": " DubboProtocol()", "full_signature": "public  DubboProtocol()", "class_method_signature": "DubboProtocol.DubboProtocol()", "testcase": false, "constructor": true}, {"identifier": "getDubboProtocol", "parameters": "()", "modifiers": "public static", "return": "DubboProtocol", "signature": "DubboProtocol getDubboProtocol()", "full_signature": "public static DubboProtocol getDubboProtocol()", "class_method_signature": "DubboProtocol.getDubboProtocol()", "testcase": false, "constructor": false}, {"identifier": "getServers", "parameters": "()", "modifiers": "public", "return": "Collection<ExchangeServer>", "signature": "Collection<ExchangeServer> getServers()", "full_signature": "public Collection<ExchangeServer> getServers()", "class_method_signature": "DubboProtocol.getServers()", "testcase": false, "constructor": false}, {"identifier": "getExporters", "parameters": "()", "modifiers": "public", "return": "Collection<Exporter<?>>", "signature": "Collection<Exporter<?>> getExporters()", "full_signature": "public Collection<Exporter<?>> getExporters()", "class_method_signature": "DubboProtocol.getExporters()", "testcase": false, "constructor": false}, {"identifier": "getExporterMap", "parameters": "()", "modifiers": "", "return": "Map<String, Exporter<?>>", "signature": "Map<String, Exporter<?>> getExporterMap()", "full_signature": " Map<String, Exporter<?>> getExporterMap()", "class_method_signature": "DubboProtocol.getExporterMap()", "testcase": false, "constructor": false}, {"identifier": "isClientSide", "parameters": "(Channel channel)", "modifiers": "private", "return": "boolean", "signature": "boolean isClientSide(Channel channel)", "full_signature": "private boolean isClientSide(Channel channel)", "class_method_signature": "DubboProtocol.isClientSide(Channel channel)", "testcase": false, "constructor": false}, {"identifier": "getInvoker", "parameters": "(Channel channel, Invocation inv)", "modifiers": "", "return": "Invoker<?>", "signature": "Invoker<?> getInvoker(Channel channel, Invocation inv)", "full_signature": " Invoker<?> getInvoker(Channel channel, Invocation inv)", "class_method_signature": "DubboProtocol.getInvoker(Channel channel, Invocation inv)", "testcase": false, "constructor": false}, {"identifier": "getInvokers", "parameters": "()", "modifiers": "public", "return": "Collection<Invoker<?>>", "signature": "Collection<Invoker<?>> getInvokers()", "full_signature": "public Collection<Invoker<?>> getInvokers()", "class_method_signature": "DubboProtocol.getInvokers()", "testcase": false, "constructor": false}, {"identifier": "getDefaultPort", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getDefaultPort()", "full_signature": "@Override public int getDefaultPort()", "class_method_signature": "DubboProtocol.getDefaultPort()", "testcase": false, "constructor": false}, {"identifier": "export", "parameters": "(Invoker<T> invoker)", "modifiers": "@Override public", "return": "Exporter<T>", "signature": "Exporter<T> export(Invoker<T> invoker)", "full_signature": "@Override public Exporter<T> export(Invoker<T> invoker)", "class_method_signature": "DubboProtocol.export(Invoker<T> invoker)", "testcase": false, "constructor": false}, {"identifier": "openServer", "parameters": "(URL url)", "modifiers": "private", "return": "void", "signature": "void openServer(URL url)", "full_signature": "private void openServer(URL url)", "class_method_signature": "DubboProtocol.openServer(URL url)", "testcase": false, "constructor": false}, {"identifier": "createServer", "parameters": "(URL url)", "modifiers": "private", "return": "ExchangeServer", "signature": "ExchangeServer createServer(URL url)", "full_signature": "private ExchangeServer createServer(URL url)", "class_method_signature": "DubboProtocol.createServer(URL url)", "testcase": false, "constructor": false}, {"identifier": "optimizeSerialization", "parameters": "(URL url)", "modifiers": "private", "return": "void", "signature": "void optimizeSerialization(URL url)", "full_signature": "private void optimizeSerialization(URL url)", "class_method_signature": "DubboProtocol.optimizeSerialization(URL url)", "testcase": false, "constructor": false}, {"identifier": "refer", "parameters": "(Class<T> serviceType, URL url)", "modifiers": "@Override public", "return": "Invoker<T>", "signature": "Invoker<T> refer(Class<T> serviceType, URL url)", "full_signature": "@Override public Invoker<T> refer(Class<T> serviceType, URL url)", "class_method_signature": "DubboProtocol.refer(Class<T> serviceType, URL url)", "testcase": false, "constructor": false}, {"identifier": "getClients", "parameters": "(URL url)", "modifiers": "private", "return": "ExchangeClient[]", "signature": "ExchangeClient[] getClients(URL url)", "full_signature": "private ExchangeClient[] getClients(URL url)", "class_method_signature": "DubboProtocol.getClients(URL url)", "testcase": false, "constructor": false}, {"identifier": "getSharedClient", "parameters": "(URL url)", "modifiers": "private", "return": "ExchangeClient", "signature": "ExchangeClient getSharedClient(URL url)", "full_signature": "private ExchangeClient getSharedClient(URL url)", "class_method_signature": "DubboProtocol.getSharedClient(URL url)", "testcase": false, "constructor": false}, {"identifier": "initClient", "parameters": "(URL url)", "modifiers": "private", "return": "ExchangeClient", "signature": "ExchangeClient initClient(URL url)", "full_signature": "private ExchangeClient initClient(URL url)", "class_method_signature": "DubboProtocol.initClient(URL url)", "testcase": false, "constructor": false}, {"identifier": "destroy", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void destroy()", "full_signature": "@Override public void destroy()", "class_method_signature": "DubboProtocol.destroy()", "testcase": false, "constructor": false}], "file": "dubbo-rpc/dubbo-rpc-dubbo/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboProtocol.java"}, "focal_method": {"identifier": "DubboProtocol", "parameters": "()", "modifiers": "public", "return": "", "body": "public DubboProtocol() {\n        INSTANCE = this;\n    }", "signature": " DubboProtocol()", "full_signature": "public  DubboProtocol()", "class_method_signature": "DubboProtocol.DubboProtocol()", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 189562861, "url": "https://github.com/smallFive55/dubbo-dubbo-2.6.6", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 8, "size": 1428, "license": "licensed"}}