{"test_class": {"identifier": "DoubleBond3DParityTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int OPPOSITE = +1;", "modifier": "private static final", "type": "int", "declarator": "OPPOSITE = +1", "var_name": "OPPOSITE"}, {"original_string": "private static final int TOGETHER = -1;", "modifier": "private static final", "type": "int", "declarator": "TOGETHER = -1", "var_name": "TOGETHER"}], "file": "tool/hash/src/test/java/org/openscience/cdk/hash/stereo/DoubleBond3DParityTest.java"}, "test_case": {"identifier": "opposite_endOn", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void opposite_endOn() throws Exception {\n        GeometricParity geometric = new DoubleBond3DParity(new Point3d(-4.3262, 0.3192, 0.6495), new Point3d(-4.3206,\n                0.3724, -0.8896), new Point3d(-4.3367, -1.0402, 1.3729), new Point3d(-4.3101, 1.7319, -1.6131));\n        assertEquals(OPPOSITE, geometric.parity());\n    }", "signature": "void opposite_endOn()", "full_signature": "@Test public void opposite_endOn()", "class_method_signature": "DoubleBond3DParityTest.opposite_endOn()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "parity"]}, "focal_class": {"identifier": "DoubleBond3DParity", "superclass": "extends GeometricParity", "interfaces": "", "fields": [{"original_string": "private Point3d u, v, x, w;", "modifier": "private", "type": "Point3d", "declarator": "u", "var_name": "u"}], "methods": [{"identifier": "DoubleBond3DParity", "parameters": "(Point3d left, Point3d right, Point3d leftSubstituent, Point3d rightSubstituent)", "modifiers": "public", "return": "", "signature": " DoubleBond3DParity(Point3d left, Point3d right, Point3d leftSubstituent, Point3d rightSubstituent)", "full_signature": "public  DoubleBond3DParity(Point3d left, Point3d right, Point3d leftSubstituent, Point3d rightSubstituent)", "class_method_signature": "DoubleBond3DParity.DoubleBond3DParity(Point3d left, Point3d right, Point3d leftSubstituent, Point3d rightSubstituent)", "testcase": false, "constructor": true}, {"identifier": "parity", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int parity()", "full_signature": "@Override public int parity()", "class_method_signature": "DoubleBond3DParity.parity()", "testcase": false, "constructor": false}, {"identifier": "toVector", "parameters": "(Point3d src, Point3d dest)", "modifiers": "private static", "return": "double[]", "signature": "double[] toVector(Point3d src, Point3d dest)", "full_signature": "private static double[] toVector(Point3d src, Point3d dest)", "class_method_signature": "DoubleBond3DParity.toVector(Point3d src, Point3d dest)", "testcase": false, "constructor": false}, {"identifier": "dot", "parameters": "(double[] u, double[] v)", "modifiers": "private static", "return": "double", "signature": "double dot(double[] u, double[] v)", "full_signature": "private static double dot(double[] u, double[] v)", "class_method_signature": "DoubleBond3DParity.dot(double[] u, double[] v)", "testcase": false, "constructor": false}, {"identifier": "crossProduct", "parameters": "(double[] u, double[] v)", "modifiers": "private static", "return": "double[]", "signature": "double[] crossProduct(double[] u, double[] v)", "full_signature": "private static double[] crossProduct(double[] u, double[] v)", "class_method_signature": "DoubleBond3DParity.crossProduct(double[] u, double[] v)", "testcase": false, "constructor": false}], "file": "tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBond3DParity.java"}, "focal_method": {"identifier": "parity", "parameters": "()", "modifiers": "@Override public", "return": "int", "body": "@Override\n    public int parity() {\n\n        // create three vectors, v->u, v->w and u->x\n        double[] vu = toVector(v, u);\n        double[] vw = toVector(v, w);\n        double[] ux = toVector(u, x);\n\n        // normal vector (to compare against), the normal vector (n) looks like:\n        // x     n w\n        //  \\    |/\n        //   u = v\n        double[] normal = crossProduct(vu, crossProduct(vu, vw));\n\n        // compare the dot products of v->w and u->x, if the signs are the same\n        // they are both pointing the same direction. if a value is close to 0\n        // then it is at pi/2 radians (i.e. unspecified) however 3D coordinates\n        // are generally discrete and do not normally represent on unspecified\n        // stereo configurations so we don't check this\n        int parity = (int) Math.signum(dot(normal, vw)) * (int) Math.signum(dot(normal, ux));\n\n        // invert sign, this then matches with Sp2 double bond parity\n        return parity * -1;\n    }", "signature": "int parity()", "full_signature": "@Override public int parity()", "class_method_signature": "DoubleBond3DParity.parity()", "testcase": false, "constructor": false, "invocations": ["toVector", "toVector", "toVector", "crossProduct", "crossProduct", "signum", "dot", "signum", "dot"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}