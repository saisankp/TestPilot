{"test_class": {"identifier": "RangeComparatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Multimap<BigInteger, Throwable> errors = HashMultimap.create();", "modifier": "private", "type": "Multimap<BigInteger, Throwable>", "declarator": "errors = HashMultimap.create()", "var_name": "errors"}, {"original_string": "private BiConsumer<Throwable, BigInteger> errorReporter = (e, t) -> errors.put(t, e);", "modifier": "private", "type": "BiConsumer<Throwable, BigInteger>", "declarator": "errorReporter = (e, t) -> errors.put(t, e)", "var_name": "errorReporter"}, {"original_string": "private Multimap<BigInteger, MismatchType> mismatches = HashMultimap.create();", "modifier": "private", "type": "Multimap<BigInteger, MismatchType>", "declarator": "mismatches = HashMultimap.create()", "var_name": "mismatches"}, {"original_string": "private BiConsumer<MismatchType, BigInteger> mismatchReporter = (m, t) -> mismatches.put(t, m);", "modifier": "private", "type": "BiConsumer<MismatchType, BigInteger>", "declarator": "mismatchReporter = (m, t) -> mismatches.put(t, m)", "var_name": "mismatchReporter"}, {"original_string": "private Multimap<BigInteger, RangeStats> journal= HashMultimap.create();", "modifier": "private", "type": "Multimap<BigInteger, RangeStats>", "declarator": "journal= HashMultimap.create()", "var_name": "journal"}, {"original_string": "private BiConsumer<RangeStats, BigInteger> progressReporter = (r, t) -> journal.put(t, copyOf(r));", "modifier": "private", "type": "BiConsumer<RangeStats, BigInteger>", "declarator": "progressReporter = (r, t) -> journal.put(t, copyOf(r))", "var_name": "progressReporter"}, {"original_string": "private Set<BigInteger> comparedPartitions = new HashSet<>();", "modifier": "private", "type": "Set<BigInteger>", "declarator": "comparedPartitions = new HashSet<>()", "var_name": "comparedPartitions"}, {"original_string": "private ComparisonExecutor executor = ComparisonExecutor.newExecutor(1, new MetricRegistry());", "modifier": "private", "type": "ComparisonExecutor", "declarator": "executor = ComparisonExecutor.newExecutor(1, new MetricRegistry())", "var_name": "executor"}, {"original_string": "private RetryStrategyProvider mockRetryStrategyFactory = RetryStrategyProvider.create(null);", "modifier": "private", "type": "RetryStrategyProvider", "declarator": "mockRetryStrategyFactory = RetryStrategyProvider.create(null)", "var_name": "mockRetryStrategyFactory"}], "file": "spark-job/src/test/java/org/apache/cassandra/diff/RangeComparatorTest.java"}, "test_case": {"identifier": "partitionPresentOnlyInTarget", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void partitionPresentOnlyInTarget() {\n        RangeComparator comparator = comparator(context(0L, 100L));\n        RangeStats stats = comparator.compare(keys(7, 8), keys(7, 8, 9), this::alwaysMatch);\n        assertFalse(stats.isEmpty());\n        assertEquals(0, stats.getOnlyInSource());\n        assertEquals(1, stats.getOnlyInTarget());\n        assertEquals(2, stats.getMatchedPartitions());\n        assertReported(9, MismatchType.ONLY_IN_TARGET, mismatches);\n        assertNothingReported(errors, journal);\n        assertCompared(7, 8);\n    }", "signature": "void partitionPresentOnlyInTarget()", "full_signature": "@Test public void partitionPresentOnlyInTarget()", "class_method_signature": "RangeComparatorTest.partitionPresentOnlyInTarget()", "testcase": true, "constructor": false, "invocations": ["comparator", "context", "compare", "keys", "keys", "assertFalse", "isEmpty", "assertEquals", "getOnlyInSource", "assertEquals", "getOnlyInTarget", "assertEquals", "getMatchedPartitions", "assertReported", "assertNothingReported", "assertCompared"]}, "focal_class": {"identifier": "RangeComparator", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(RangeComparator.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(RangeComparator.class)", "var_name": "logger"}, {"original_string": "private final DiffContext context;", "modifier": "private final", "type": "DiffContext", "declarator": "context", "var_name": "context"}, {"original_string": "private final BiConsumer<Throwable, BigInteger> errorReporter;", "modifier": "private final", "type": "BiConsumer<Throwable, BigInteger>", "declarator": "errorReporter", "var_name": "errorReporter"}, {"original_string": "private final BiConsumer<MismatchType, BigInteger> mismatchReporter;", "modifier": "private final", "type": "BiConsumer<MismatchType, BigInteger>", "declarator": "mismatchReporter", "var_name": "mismatchReporter"}, {"original_string": "private final BiConsumer<RangeStats, BigInteger> journal;", "modifier": "private final", "type": "BiConsumer<RangeStats, BigInteger>", "declarator": "journal", "var_name": "journal"}, {"original_string": "private final ComparisonExecutor comparisonExecutor;", "modifier": "private final", "type": "ComparisonExecutor", "declarator": "comparisonExecutor", "var_name": "comparisonExecutor"}], "methods": [{"identifier": "RangeComparator", "parameters": "(DiffContext context,\n                           BiConsumer<Throwable, BigInteger> errorReporter,\n                           BiConsumer<MismatchType,BigInteger> mismatchReporter,\n                           BiConsumer<RangeStats, BigInteger> journal,\n                           ComparisonExecutor comparisonExecutor)", "modifiers": "public", "return": "", "signature": " RangeComparator(DiffContext context,\n                           BiConsumer<Throwable, BigInteger> errorReporter,\n                           BiConsumer<MismatchType,BigInteger> mismatchReporter,\n                           BiConsumer<RangeStats, BigInteger> journal,\n                           ComparisonExecutor comparisonExecutor)", "full_signature": "public  RangeComparator(DiffContext context,\n                           BiConsumer<Throwable, BigInteger> errorReporter,\n                           BiConsumer<MismatchType,BigInteger> mismatchReporter,\n                           BiConsumer<RangeStats, BigInteger> journal,\n                           ComparisonExecutor comparisonExecutor)", "class_method_signature": "RangeComparator.RangeComparator(DiffContext context,\n                           BiConsumer<Throwable, BigInteger> errorReporter,\n                           BiConsumer<MismatchType,BigInteger> mismatchReporter,\n                           BiConsumer<RangeStats, BigInteger> journal,\n                           ComparisonExecutor comparisonExecutor)", "testcase": false, "constructor": true}, {"identifier": "compare", "parameters": "(Iterator<PartitionKey> sourceKeys,\n                              Iterator<PartitionKey> targetKeys,\n                              Function<PartitionKey, PartitionComparator> partitionTaskProvider)", "modifiers": "public", "return": "RangeStats", "signature": "RangeStats compare(Iterator<PartitionKey> sourceKeys,\n                              Iterator<PartitionKey> targetKeys,\n                              Function<PartitionKey, PartitionComparator> partitionTaskProvider)", "full_signature": "public RangeStats compare(Iterator<PartitionKey> sourceKeys,\n                              Iterator<PartitionKey> targetKeys,\n                              Function<PartitionKey, PartitionComparator> partitionTaskProvider)", "class_method_signature": "RangeComparator.compare(Iterator<PartitionKey> sourceKeys,\n                              Iterator<PartitionKey> targetKeys,\n                              Function<PartitionKey, PartitionComparator> partitionTaskProvider)", "testcase": false, "constructor": false}, {"identifier": "drain", "parameters": "(Iterator<PartitionKey> sourceKeys,\n                             Iterator<PartitionKey> targetKeys,\n                             RangeStats rangeStats)", "modifiers": "private", "return": "void", "signature": "void drain(Iterator<PartitionKey> sourceKeys,\n                             Iterator<PartitionKey> targetKeys,\n                             RangeStats rangeStats)", "full_signature": "private void drain(Iterator<PartitionKey> sourceKeys,\n                             Iterator<PartitionKey> targetKeys,\n                             RangeStats rangeStats)", "class_method_signature": "RangeComparator.drain(Iterator<PartitionKey> sourceKeys,\n                             Iterator<PartitionKey> targetKeys,\n                             RangeStats rangeStats)", "testcase": false, "constructor": false}, {"identifier": "onlyInTarget", "parameters": "(RangeStats stats, PartitionKey key)", "modifiers": "private", "return": "void", "signature": "void onlyInTarget(RangeStats stats, PartitionKey key)", "full_signature": "private void onlyInTarget(RangeStats stats, PartitionKey key)", "class_method_signature": "RangeComparator.onlyInTarget(RangeStats stats, PartitionKey key)", "testcase": false, "constructor": false}, {"identifier": "onlyInSource", "parameters": "(RangeStats stats, PartitionKey key)", "modifiers": "private", "return": "void", "signature": "void onlyInSource(RangeStats stats, PartitionKey key)", "full_signature": "private void onlyInSource(RangeStats stats, PartitionKey key)", "class_method_signature": "RangeComparator.onlyInSource(RangeStats stats, PartitionKey key)", "testcase": false, "constructor": false}, {"identifier": "nextKey", "parameters": "(Iterator<PartitionKey> keys)", "modifiers": "private", "return": "PartitionKey", "signature": "PartitionKey nextKey(Iterator<PartitionKey> keys)", "full_signature": "private PartitionKey nextKey(Iterator<PartitionKey> keys)", "class_method_signature": "RangeComparator.nextKey(Iterator<PartitionKey> keys)", "testcase": false, "constructor": false}, {"identifier": "onSuccess", "parameters": "(final RangeStats rangeStats,\n                                               final AtomicLong partitionCount,\n                                               final BigInteger currentToken,\n                                               final AtomicReference<BigInteger> highestSeenToken,\n                                               final BiConsumer<MismatchType, BigInteger> mismatchReporter,\n                                               final BiConsumer<RangeStats, BigInteger> journal)", "modifiers": "private", "return": "Consumer<PartitionStats>", "signature": "Consumer<PartitionStats> onSuccess(final RangeStats rangeStats,\n                                               final AtomicLong partitionCount,\n                                               final BigInteger currentToken,\n                                               final AtomicReference<BigInteger> highestSeenToken,\n                                               final BiConsumer<MismatchType, BigInteger> mismatchReporter,\n                                               final BiConsumer<RangeStats, BigInteger> journal)", "full_signature": "private Consumer<PartitionStats> onSuccess(final RangeStats rangeStats,\n                                               final AtomicLong partitionCount,\n                                               final BigInteger currentToken,\n                                               final AtomicReference<BigInteger> highestSeenToken,\n                                               final BiConsumer<MismatchType, BigInteger> mismatchReporter,\n                                               final BiConsumer<RangeStats, BigInteger> journal)", "class_method_signature": "RangeComparator.onSuccess(final RangeStats rangeStats,\n                                               final AtomicLong partitionCount,\n                                               final BigInteger currentToken,\n                                               final AtomicReference<BigInteger> highestSeenToken,\n                                               final BiConsumer<MismatchType, BigInteger> mismatchReporter,\n                                               final BiConsumer<RangeStats, BigInteger> journal)", "testcase": false, "constructor": false}, {"identifier": "onError", "parameters": "(final RangeStats rangeStats,\n                                        final BigInteger currentToken,\n                                        final BiConsumer<Throwable, BigInteger> errorReporter)", "modifiers": "private", "return": "Consumer<Throwable>", "signature": "Consumer<Throwable> onError(final RangeStats rangeStats,\n                                        final BigInteger currentToken,\n                                        final BiConsumer<Throwable, BigInteger> errorReporter)", "full_signature": "private Consumer<Throwable> onError(final RangeStats rangeStats,\n                                        final BigInteger currentToken,\n                                        final BiConsumer<Throwable, BigInteger> errorReporter)", "class_method_signature": "RangeComparator.onError(final RangeStats rangeStats,\n                                        final BigInteger currentToken,\n                                        final BiConsumer<Throwable, BigInteger> errorReporter)", "testcase": false, "constructor": false}, {"identifier": "recordError", "parameters": "(final RangeStats rangeStats,\n                             final BigInteger currentToken,\n                             final BiConsumer<Throwable, BigInteger> errorReporter,\n                             final Throwable error)", "modifiers": "private", "return": "void", "signature": "void recordError(final RangeStats rangeStats,\n                             final BigInteger currentToken,\n                             final BiConsumer<Throwable, BigInteger> errorReporter,\n                             final Throwable error)", "full_signature": "private void recordError(final RangeStats rangeStats,\n                             final BigInteger currentToken,\n                             final BiConsumer<Throwable, BigInteger> errorReporter,\n                             final Throwable error)", "class_method_signature": "RangeComparator.recordError(final RangeStats rangeStats,\n                             final BigInteger currentToken,\n                             final BiConsumer<Throwable, BigInteger> errorReporter,\n                             final Throwable error)", "testcase": false, "constructor": false}], "file": "spark-job/src/main/java/org/apache/cassandra/diff/RangeComparator.java"}, "focal_method": {"identifier": "compare", "parameters": "(Iterator<PartitionKey> sourceKeys,\n                              Iterator<PartitionKey> targetKeys,\n                              Function<PartitionKey, PartitionComparator> partitionTaskProvider)", "modifiers": "public", "return": "RangeStats", "body": "public RangeStats compare(Iterator<PartitionKey> sourceKeys,\n                              Iterator<PartitionKey> targetKeys,\n                              Function<PartitionKey, PartitionComparator> partitionTaskProvider) {\n\n        final RangeStats rangeStats = RangeStats.newStats();\n        // We can catch this condition earlier, but it doesn't hurt to also check here\n        if (context.startToken.equals(context.endToken))\n            return rangeStats;\n\n        Phaser phaser = new Phaser(1);\n        AtomicLong partitionCount = new AtomicLong(0);\n        AtomicReference<BigInteger> highestTokenSeen = new AtomicReference<>(context.startToken);\n\n        logger.info(\"Comparing range [{},{}]\", context.startToken, context.endToken);\n        try {\n            PartitionKey sourceKey = nextKey(sourceKeys);\n            PartitionKey targetKey = nextKey(targetKeys);\n\n            // special case for start of range - handles one cluster supplying an empty range\n            if ((sourceKey == null) != (targetKey == null)) {\n                if (sourceKey == null) {\n                    logger.info(\"First in range, source iter is empty {}\", context);\n                    onlyInTarget(rangeStats, targetKey);\n                    targetKeys.forEachRemaining(key -> onlyInTarget(rangeStats, key));\n                } else {\n                    logger.info(\"First in range, target iter is empty {}\", context);\n                    onlyInSource(rangeStats, sourceKey);\n                    sourceKeys.forEachRemaining(key -> onlyInSource(rangeStats, key));\n                }\n                return rangeStats;\n            }\n\n            while (sourceKey != null && targetKey != null) {\n\n                int ret = sourceKey.compareTo(targetKey);\n                if (ret > 0) {\n                    onlyInTarget(rangeStats, targetKey);\n                    targetKey = nextKey(targetKeys);\n                } else if (ret < 0) {\n                    onlyInSource(rangeStats, sourceKey);\n                    sourceKey = nextKey(sourceKeys);\n                } else {\n\n                    Verify.verify(sourceKey.equals(targetKey),\n                                  \"Can only compare partitions with identical keys: (%s, %s)\",\n                                  sourceKey, targetKey);\n\n                    // For results where the key exists in both, we'll fire off an async task to walk the\n                    // partition and compare all the rows. The result of that comparison is added to the\n                    // totals for the range and the highest seen token updated in the onSuccess callback\n\n                    if (!context.isTokenAllowed(sourceKey.getTokenAsBigInteger())) {\n                        logger.debug(\"Skipping disallowed token {}\", sourceKey.getTokenAsBigInteger());\n                        rangeStats.skipPartition();\n                        sourceKey = nextKey(sourceKeys);\n                        targetKey = nextKey(targetKeys);\n                        continue;\n                    }\n\n                    BigInteger token = sourceKey.getTokenAsBigInteger();\n                    try {\n                        PartitionComparator comparisonTask = partitionTaskProvider.apply(sourceKey);\n                        comparisonExecutor.submit(comparisonTask,\n                                                  onSuccess(rangeStats, partitionCount, token, highestTokenSeen, mismatchReporter, journal),\n                                                  onError(rangeStats, token, errorReporter),\n                                                  phaser);\n                    } catch (Throwable t) {\n                        // Handle errors thrown when creating the comparison task. This should trap timeouts and\n                        // unavailables occurring when performing the initial query to read the full partition.\n                        // Errors thrown when paging through the partition in comparisonTask will be handled by\n                        // the onError callback.\n                        recordError(rangeStats, token, errorReporter, t);\n                    } finally {\n                        // if the cluster has been shutdown because the task failed the underlying iterators\n                        // of partition keys will return hasNext == false\n                        sourceKey = nextKey(sourceKeys);\n                        targetKey = nextKey(targetKeys);\n                    }\n                }\n            }\n\n            // handle case where only one iterator is exhausted\n            if (sourceKey != null)\n                onlyInSource(rangeStats, sourceKey);\n            else if (targetKey != null)\n                onlyInTarget(rangeStats, targetKey);\n\n            drain(sourceKeys, targetKeys, rangeStats);\n\n        } catch (Exception e) {\n            // Handles errors thrown by iteration of underlying resultsets of partition keys by\n            // calls to nextKey(). Such errors should cause the overall range comparison to fail,\n            // but we must ensure that any in-flight partition comparisons complete so that either\n            // the onSuccess or onError callback is fired for each one. This is necessary to ensure\n            // that we record the highest seen token and any failed partitions and can safely re-run.\n            logger.debug(\"Waiting for {} in flight tasks before propagating error\", phaser.getUnarrivedParties());\n            phaser.arriveAndAwaitAdvance();\n            throw new RuntimeException(String.format(\"Error encountered during range comparison for [%s:%s]\",\n                                       context.startToken, context.endToken), e);\n        }\n\n        logger.debug(\"Waiting for {} in flight tasks before returning\", phaser.getUnarrivedParties());\n        phaser.arriveAndAwaitAdvance();\n\n        if (!rangeStats.allMatches())\n            logger.info(\"Segment [{}:{}] stats - ({})\", context.startToken, context.endToken, rangeStats);\n\n        return rangeStats;\n    }", "signature": "RangeStats compare(Iterator<PartitionKey> sourceKeys,\n                              Iterator<PartitionKey> targetKeys,\n                              Function<PartitionKey, PartitionComparator> partitionTaskProvider)", "full_signature": "public RangeStats compare(Iterator<PartitionKey> sourceKeys,\n                              Iterator<PartitionKey> targetKeys,\n                              Function<PartitionKey, PartitionComparator> partitionTaskProvider)", "class_method_signature": "RangeComparator.compare(Iterator<PartitionKey> sourceKeys,\n                              Iterator<PartitionKey> targetKeys,\n                              Function<PartitionKey, PartitionComparator> partitionTaskProvider)", "testcase": false, "constructor": false, "invocations": ["newStats", "equals", "info", "nextKey", "nextKey", "info", "onlyInTarget", "forEachRemaining", "onlyInTarget", "info", "onlyInSource", "forEachRemaining", "onlyInSource", "compareTo", "onlyInTarget", "nextKey", "onlyInSource", "nextKey", "verify", "equals", "isTokenAllowed", "getTokenAsBigInteger", "debug", "getTokenAsBigInteger", "skipPartition", "nextKey", "nextKey", "getTokenAsBigInteger", "apply", "submit", "onSuccess", "onError", "recordError", "nextKey", "nextKey", "onlyInSource", "onlyInTarget", "drain", "debug", "getUnarrivedParties", "arriveAndAwaitAdvance", "format", "debug", "getUnarrivedParties", "arriveAndAwaitAdvance", "allMatches", "info"]}, "repository": {"repo_id": 204657216, "url": "https://github.com/apache/cassandra-diff", "language": "Java", "is_fork": false, "fork_count": 9, "stargazer_count": 5, "size": 112, "license": "licensed"}}