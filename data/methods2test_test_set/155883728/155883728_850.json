{"test_class": {"identifier": "ExpectAcesTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final NamePathResolver resolver = new DefaultNamePathResolver(JsonCnd.BUILTIN_MAPPINGS);", "modifier": "private final", "type": "NamePathResolver", "declarator": "resolver = new DefaultNamePathResolver(JsonCnd.BUILTIN_MAPPINGS)", "var_name": "resolver"}, {"original_string": "static final Privilege[] emptyPrivileges = new Privilege[0];", "modifier": "static final", "type": "Privilege[]", "declarator": "emptyPrivileges = new Privilege[0]", "var_name": "emptyPrivileges"}], "file": "core/src/test/java/net/adamcin/oakpal/core/checks/ExpectAcesTest.java"}, "test_case": {"identifier": "testSuppressAfterExtractViolationIfExpectationSatisfiedAfterScanPackage", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSuppressAfterExtractViolationIfExpectationSatisfiedAfterScanPackage() throws Exception {\n        final PackageId fooId = PackageId.fromString(\"some\");\n        final PackageId barEmbedId = PackageId.fromString(\"other\");\n        final EmbeddedPackageInstallable installable = new EmbeddedPackageInstallable(fooId, \"\", barEmbedId);\n        ExpectAces.Check check = checkFor(obj()\n                .key(ExpectAces.keys().principal(), \"nouser\")\n                .key(\"ignoreNestedPackages\", true)\n                .key(ExpectAces.keys().expectedAces(), arr()\n                        .val(\"type=allow;path=/foo1;privileges=jcr:read\")\n                        .val(\"type=allow;path=/foo1;privileges=rep:write\")\n                )\n                .key(ExpectAces.keys().notExpectedAces(), arr()\n                        .val(\"type=allow;path=/foo2;privileges=jcr:read\")\n                        .val(\"type=allow;path=/foo2;privileges=rep:write\")\n                        // foo3 is not created. a non-existent path should satisfy not-expected aces\n                        .val(\"type=allow;path=/foo3;privileges=rep:write\")\n                )\n                .get());\n\n        final Principal principal = new PrincipalImpl(\"nouser\");\n        new OakMachine.Builder().build().adminInitAndInspect(session -> {\n            final JackrabbitAccessControlManager accessControlManager =\n                    (JackrabbitAccessControlManager) session.getAccessControlManager();\n            final PrivilegeManager privilegeManager = ((JackrabbitWorkspace) session.getWorkspace()).getPrivilegeManager();\n            final Privilege jcrRead = privilegeManager.getPrivilege(\"jcr:read\");\n\n            final Node foo1 = session.getRootNode().addNode(\"foo1\", resolver.getJCRName(NameConstants.NT_FOLDER));\n            foo1.addMixin(\"rep:AccessControllable\");\n            final Node foo2 = session.getRootNode().addNode(\"foo2\", resolver.getJCRName(NameConstants.NT_FOLDER));\n            foo2.addMixin(\"rep:AccessControllable\");\n            session.save();\n\n            for (String path : new String[]{\"/foo1\", \"/foo2\"}) {\n                for (AccessControlPolicyIterator policyIt = accessControlManager.getApplicablePolicies(path); policyIt.hasNext(); ) {\n                    AccessControlPolicy policy = policyIt.nextAccessControlPolicy();\n                    if (policy instanceof JackrabbitAccessControlList) {\n                        JackrabbitAccessControlList acl = (JackrabbitAccessControlList) policy;\n                        acl.addEntry(principal, new Privilege[]{jcrRead}, true);\n                        accessControlManager.setPolicy(path, acl);\n                    }\n                }\n            }\n            check.startedScan();\n            check.identifyPackage(fooId, null);\n            check.afterExtract(fooId, session);\n            check.beforeSlingInstall(fooId, installable, session);\n            check.identifyEmbeddedPackage(barEmbedId, fooId, installable);\n            check.afterExtract(barEmbedId, session);\n            check.afterScanPackage(fooId, session);\n            check.finishedScan();\n        });\n\n        Assert.assertEquals(\"expected violation count\", 1, check.getReportedViolations().stream().filter(viol -> viol.getDescription().startsWith(\"expected: \")).count());\n        Assert.assertEquals(\"expected violated spec ends with rep:write\", 1,\n                check.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"expected: \")\n                                && viol.getDescription().endsWith(\"rep:write\")).count());\n        Assert.assertEquals(\"unexpected violation count\", 1, check.getReportedViolations().stream().filter(viol -> viol.getDescription().startsWith(\"unexpected: \")).count());\n        Assert.assertEquals(\"unexpected violated spec ends with jcr:read\", 1,\n                check.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"unexpected: \")\n                                && viol.getDescription().endsWith(\"jcr:read\")).count());\n\n        // run again, but this time\n        new OakMachine.Builder().build().adminInitAndInspect(session -> {\n            final JackrabbitAccessControlManager accessControlManager =\n                    (JackrabbitAccessControlManager) session.getAccessControlManager();\n            final PrivilegeManager privilegeManager = ((JackrabbitWorkspace) session.getWorkspace()).getPrivilegeManager();\n            final Privilege jcrRead = privilegeManager.getPrivilege(\"jcr:read\");\n\n            final Node foo1 = session.getRootNode().addNode(\"foo1\", resolver.getJCRName(NameConstants.NT_FOLDER));\n            foo1.addMixin(\"rep:AccessControllable\");\n            final Node foo2 = session.getRootNode().addNode(\"foo2\", resolver.getJCRName(NameConstants.NT_FOLDER));\n            foo2.addMixin(\"rep:AccessControllable\");\n            session.save();\n\n            for (String path : new String[]{\"/foo1\", \"/foo2\"}) {\n                for (AccessControlPolicyIterator policyIt = accessControlManager.getApplicablePolicies(path); policyIt.hasNext(); ) {\n                    AccessControlPolicy policy = policyIt.nextAccessControlPolicy();\n                    if (policy instanceof JackrabbitAccessControlList) {\n                        JackrabbitAccessControlList acl = (JackrabbitAccessControlList) policy;\n                        acl.addEntry(principal, new Privilege[]{jcrRead}, true);\n                        accessControlManager.setPolicy(path, acl);\n                    }\n                }\n            }\n            check.startedScan();\n            check.identifyPackage(fooId, null);\n            check.afterExtract(fooId, session);\n            check.beforeSlingInstall(fooId, installable, session);\n            check.identifyEmbeddedPackage(barEmbedId, fooId, installable);\n            foo2.remove();\n            check.afterExtract(barEmbedId, session);\n            check.afterScanPackage(fooId, session);\n            check.finishedScan();\n        });\n\n        Assert.assertEquals(\"expected violation count\", 1, check.getReportedViolations().stream().filter(viol -> viol.getDescription().startsWith(\"expected: \")).count());\n        Assert.assertEquals(\"expected violated spec ends with rep:write\", 1,\n                check.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"expected: \")\n                                && viol.getDescription().endsWith(\"rep:write\")).count());\n        Assert.assertEquals(\"no unexpected violations\", 0,\n                check.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"unexpected: \")).count());\n    }", "signature": "void testSuppressAfterExtractViolationIfExpectationSatisfiedAfterScanPackage()", "full_signature": "@Test public void testSuppressAfterExtractViolationIfExpectationSatisfiedAfterScanPackage()", "class_method_signature": "ExpectAcesTest.testSuppressAfterExtractViolationIfExpectationSatisfiedAfterScanPackage()", "testcase": true, "constructor": false, "invocations": ["fromString", "fromString", "checkFor", "get", "key", "key", "key", "key", "obj", "principal", "keys", "expectedAces", "keys", "val", "val", "arr", "notExpectedAces", "keys", "val", "val", "val", "arr", "adminInitAndInspect", "build", "getAccessControlManager", "getPrivilegeManager", "getWorkspace", "getPrivilege", "addNode", "getRootNode", "getJCRName", "addMixin", "addNode", "getRootNode", "getJCRName", "addMixin", "save", "getApplicablePolicies", "hasNext", "nextAccessControlPolicy", "addEntry", "setPolicy", "startedScan", "identifyPackage", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "afterExtract", "afterScanPackage", "finishedScan", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "endsWith", "getDescription", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "endsWith", "getDescription", "adminInitAndInspect", "build", "getAccessControlManager", "getPrivilegeManager", "getWorkspace", "getPrivilege", "addNode", "getRootNode", "getJCRName", "addMixin", "addNode", "getRootNode", "getJCRName", "addMixin", "save", "getApplicablePolicies", "hasNext", "nextAccessControlPolicy", "addEntry", "setPolicy", "startedScan", "identifyPackage", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "remove", "afterExtract", "afterScanPackage", "finishedScan", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "endsWith", "getDescription", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription"]}, "focal_class": {"identifier": "ExpectAces", "superclass": "", "interfaces": "implements ProgressCheckFactory", "fields": [{"original_string": "private static final JsonKeys KEYS = new JsonKeys() {\n        @Override\n        public String principal() {\n            return \"principal\";\n        }\n\n        @Override\n        public String principals() {\n            return \"principals\";\n        }\n\n        @Override\n        public String expectedAces() {\n            return \"expectedAces\";\n        }\n\n        @Override\n        public String notExpectedAces() {\n            return \"notExpectedAces\";\n        }\n\n        @Override\n        public String afterPackageIdRules() {\n            return \"afterPackageIdRules\";\n        }\n\n        @Override\n        public String severity() {\n            return \"severity\";\n        }\n\n        @Override\n        public String type() {\n            return \"type\";\n        }\n\n        @Override\n        public String privileges() {\n            return \"privileges\";\n        }\n\n        @Override\n        public String path() {\n            return \"path\";\n        }\n    };", "modifier": "private static final", "type": "JsonKeys", "declarator": "KEYS = new JsonKeys() {\n        @Override\n        public String principal() {\n            return \"principal\";\n        }\n\n        @Override\n        public String principals() {\n            return \"principals\";\n        }\n\n        @Override\n        public String expectedAces() {\n            return \"expectedAces\";\n        }\n\n        @Override\n        public String notExpectedAces() {\n            return \"notExpectedAces\";\n        }\n\n        @Override\n        public String afterPackageIdRules() {\n            return \"afterPackageIdRules\";\n        }\n\n        @Override\n        public String severity() {\n            return \"severity\";\n        }\n\n        @Override\n        public String type() {\n            return \"type\";\n        }\n\n        @Override\n        public String privileges() {\n            return \"privileges\";\n        }\n\n        @Override\n        public String path() {\n            return \"path\";\n        }\n    }", "var_name": "KEYS"}, {"original_string": "@Deprecated\n    public static final String CONFIG_PRINCIPAL = keys().principal();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "CONFIG_PRINCIPAL = keys().principal()", "var_name": "CONFIG_PRINCIPAL"}, {"original_string": "@Deprecated\n    public static final String CONFIG_PRINCIPALS = keys().principals();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "CONFIG_PRINCIPALS = keys().principals()", "var_name": "CONFIG_PRINCIPALS"}, {"original_string": "@Deprecated\n    public static final String CONFIG_EXPECTED_ACES = keys().expectedAces();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "CONFIG_EXPECTED_ACES = keys().expectedAces()", "var_name": "CONFIG_EXPECTED_ACES"}, {"original_string": "@Deprecated\n    public static final String CONFIG_NOT_EXPECTED_ACES = keys().notExpectedAces();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "CONFIG_NOT_EXPECTED_ACES = keys().notExpectedAces()", "var_name": "CONFIG_NOT_EXPECTED_ACES"}, {"original_string": "@Deprecated\n    public static final String CONFIG_AFTER_PACKAGE_ID_RULES = keys().afterPackageIdRules();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "CONFIG_AFTER_PACKAGE_ID_RULES = keys().afterPackageIdRules()", "var_name": "CONFIG_AFTER_PACKAGE_ID_RULES"}, {"original_string": "@Deprecated\n    public static final String ACE_PARAM_TYPE = keys().type();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "ACE_PARAM_TYPE = keys().type()", "var_name": "ACE_PARAM_TYPE"}, {"original_string": "@Deprecated\n    public static final String ACE_PARAM_PRIVILEGES = keys().privileges();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "ACE_PARAM_PRIVILEGES = keys().privileges()", "var_name": "ACE_PARAM_PRIVILEGES"}, {"original_string": "@Deprecated\n    public static final String ACE_PARAM_PATH = keys().path();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "ACE_PARAM_PATH = keys().path()", "var_name": "ACE_PARAM_PATH"}, {"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ExpectAces.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ExpectAces.class)", "var_name": "LOGGER"}, {"original_string": "static final Severity DEFAULT_SEVERITY = Severity.MAJOR;", "modifier": "static final", "type": "Severity", "declarator": "DEFAULT_SEVERITY = Severity.MAJOR", "var_name": "DEFAULT_SEVERITY"}, {"original_string": "public static final String DELIM_PARAM = \";\";", "modifier": "public static final", "type": "String", "declarator": "DELIM_PARAM = \";\"", "var_name": "DELIM_PARAM"}, {"original_string": "public static final String DELIM_VALUE = \"=\";", "modifier": "public static final", "type": "String", "declarator": "DELIM_VALUE = \"=\"", "var_name": "DELIM_VALUE"}, {"original_string": "public static final String DELIM_LIST = \",\";", "modifier": "public static final", "type": "String", "declarator": "DELIM_LIST = \",\"", "var_name": "DELIM_LIST"}], "methods": [{"identifier": "keys", "parameters": "()", "modifiers": "@NotNull public static", "return": "JsonKeys", "signature": "JsonKeys keys()", "full_signature": "@NotNull public static JsonKeys keys()", "class_method_signature": "ExpectAces.keys()", "testcase": false, "constructor": false}, {"identifier": "newInstance", "parameters": "(final JsonObject config)", "modifiers": "@Override public", "return": "ProgressCheck", "signature": "ProgressCheck newInstance(final JsonObject config)", "full_signature": "@Override public ProgressCheck newInstance(final JsonObject config)", "class_method_signature": "ExpectAces.newInstance(final JsonObject config)", "testcase": false, "constructor": false}, {"identifier": "isPrincipalSpec", "parameters": "(final @NotNull String spec)", "modifiers": "static", "return": "boolean", "signature": "boolean isPrincipalSpec(final @NotNull String spec)", "full_signature": "static boolean isPrincipalSpec(final @NotNull String spec)", "class_method_signature": "ExpectAces.isPrincipalSpec(final @NotNull String spec)", "testcase": false, "constructor": false}, {"identifier": "isGeneralSpec", "parameters": "(final @NotNull String spec)", "modifiers": "static", "return": "boolean", "signature": "boolean isGeneralSpec(final @NotNull String spec)", "full_signature": "static boolean isGeneralSpec(final @NotNull String spec)", "class_method_signature": "ExpectAces.isGeneralSpec(final @NotNull String spec)", "testcase": false, "constructor": false}, {"identifier": "parseAceCriteria", "parameters": "(final @NotNull JsonObject config,\n                                              final @NotNull String[] principals,\n                                              final @NotNull String key)", "modifiers": "static", "return": "List<AceCriteria>", "signature": "List<AceCriteria> parseAceCriteria(final @NotNull JsonObject config,\n                                              final @NotNull String[] principals,\n                                              final @NotNull String key)", "full_signature": "static List<AceCriteria> parseAceCriteria(final @NotNull JsonObject config,\n                                              final @NotNull String[] principals,\n                                              final @NotNull String key)", "class_method_signature": "ExpectAces.parseAceCriteria(final @NotNull JsonObject config,\n                                              final @NotNull String[] principals,\n                                              final @NotNull String key)", "testcase": false, "constructor": false}, {"identifier": "restrictionMatcher", "parameters": "(final @NotNull JackrabbitAccessControlList acl,\n                       final @NotNull RestrictionCriteria[] restrictionCriterias)", "modifiers": "static", "return": "Predicate<JackrabbitAccessControlEntry>", "signature": "Predicate<JackrabbitAccessControlEntry> restrictionMatcher(final @NotNull JackrabbitAccessControlList acl,\n                       final @NotNull RestrictionCriteria[] restrictionCriterias)", "full_signature": "static Predicate<JackrabbitAccessControlEntry> restrictionMatcher(final @NotNull JackrabbitAccessControlList acl,\n                       final @NotNull RestrictionCriteria[] restrictionCriterias)", "class_method_signature": "ExpectAces.restrictionMatcher(final @NotNull JackrabbitAccessControlList acl,\n                       final @NotNull RestrictionCriteria[] restrictionCriterias)", "testcase": false, "constructor": false}], "file": "core/src/main/java/net/adamcin/oakpal/core/checks/ExpectAces.java"}, "focal_method": {"identifier": "keys", "parameters": "()", "modifiers": "@NotNull public static", "return": "JsonKeys", "body": "@NotNull\n    public static JsonKeys keys() {\n        return KEYS;\n    }", "signature": "JsonKeys keys()", "full_signature": "@NotNull public static JsonKeys keys()", "class_method_signature": "ExpectAces.keys()", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 155883728, "url": "https://github.com/adamcin/oakpal", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 6, "size": 13349, "license": "licensed"}}