{"test_class": {"identifier": "NetUtilTest", "superclass": "", "interfaces": "", "fields": [], "file": "bundles/org.openhab.core/src/test/java/org/openhab/core/net/NetUtilTest.java"}, "test_case": {"identifier": "testBroadcastAddress", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testBroadcastAddress() {\n        String broadcast = NetUtil.getIpv4NetBroadcastAddress(\"192.168.0.1\", (short) 24);\n        assertThat(broadcast, is(\"192.168.0.255\"));\n\n        broadcast = NetUtil.getIpv4NetBroadcastAddress(\"192.168.23.5\", (short) 24);\n        assertThat(broadcast, is(\"192.168.23.255\"));\n\n        broadcast = NetUtil.getIpv4NetBroadcastAddress(\"172.16.42.23\", (short) 16);\n        assertThat(broadcast, is(\"172.16.255.255\"));\n\n        broadcast = NetUtil.getIpv4NetBroadcastAddress(\"10.8.13.5\", (short) 8);\n        assertThat(broadcast, is(\"10.255.255.255\"));\n\n        broadcast = NetUtil.getIpv4NetBroadcastAddress(\"192.168.5.8\", (short) 23);\n        assertThat(broadcast, is(\"192.168.5.255\"));\n\n        broadcast = NetUtil.getIpv4NetBroadcastAddress(\"192.168.5.8\", (short) 27);\n        assertThat(broadcast, is(\"192.168.5.31\"));\n\n        broadcast = NetUtil.getIpv4NetBroadcastAddress(\"192.168.5.8\", (short) 29);\n        assertThat(broadcast, is(\"192.168.5.15\"));\n\n        try {\n            broadcast = NetUtil.getIpv4NetBroadcastAddress(\"192.168.5.8\", (short) 33);\n        } catch (IllegalArgumentException iae) {\n            assertThat(iae.getMessage(), is(\"Prefix '33' is out of bounds (1-32)\"));\n        }\n        try {\n            broadcast = NetUtil.getIpv4NetBroadcastAddress(\"192.168.58\", (short) 24);\n        } catch (IllegalArgumentException iae) {\n            assertThat(iae.getMessage(), is(\"IP '192.168.58' is not a valid IPv4 address\"));\n        }\n        try {\n            broadcast = NetUtil.getIpv4NetBroadcastAddress(\"192.168.58\", (short) 24);\n        } catch (IllegalArgumentException iae) {\n            assertThat(iae.getMessage(), is(\"IP '192.168.58' is not a valid IPv4 address\"));\n        }\n        try {\n            broadcast = NetUtil.getIpv4NetBroadcastAddress(\"SOME_TEXT\", (short) 42);\n        } catch (IllegalArgumentException iae) {\n            assertThat(iae.getMessage(), is(\"IP 'SOME_TEXT' is not a valid IPv4 address\"));\n        }\n    }", "signature": "void testBroadcastAddress()", "full_signature": "@Test public void testBroadcastAddress()", "class_method_signature": "NetUtilTest.testBroadcastAddress()", "testcase": true, "constructor": false, "invocations": ["getIpv4NetBroadcastAddress", "assertThat", "is", "getIpv4NetBroadcastAddress", "assertThat", "is", "getIpv4NetBroadcastAddress", "assertThat", "is", "getIpv4NetBroadcastAddress", "assertThat", "is", "getIpv4NetBroadcastAddress", "assertThat", "is", "getIpv4NetBroadcastAddress", "assertThat", "is", "getIpv4NetBroadcastAddress", "assertThat", "is", "getIpv4NetBroadcastAddress", "assertThat", "getMessage", "is", "getIpv4NetBroadcastAddress", "assertThat", "getMessage", "is", "getIpv4NetBroadcastAddress", "assertThat", "getMessage", "is", "getIpv4NetBroadcastAddress", "assertThat", "getMessage", "is"]}, "focal_class": {"identifier": "NetUtil", "superclass": "", "interfaces": "implements NetworkAddressService", "fields": [{"original_string": "private static final String PRIMARY_ADDRESS = \"primaryAddress\";", "modifier": "private static final", "type": "String", "declarator": "PRIMARY_ADDRESS = \"primaryAddress\"", "var_name": "PRIMARY_ADDRESS"}, {"original_string": "private static final String BROADCAST_ADDRESS = \"broadcastAddress\";", "modifier": "private static final", "type": "String", "declarator": "BROADCAST_ADDRESS = \"broadcastAddress\"", "var_name": "BROADCAST_ADDRESS"}, {"original_string": "private static final String POLL_INTERVAL = \"pollInterval\";", "modifier": "private static final", "type": "String", "declarator": "POLL_INTERVAL = \"pollInterval\"", "var_name": "POLL_INTERVAL"}, {"original_string": "private static final String USE_ONLY_ONE_ADDRESS = \"useOnlyOneAddress\";", "modifier": "private static final", "type": "String", "declarator": "USE_ONLY_ONE_ADDRESS = \"useOnlyOneAddress\"", "var_name": "USE_ONLY_ONE_ADDRESS"}, {"original_string": "private static final String USE_IPV6 = \"useIPv6\";", "modifier": "private static final", "type": "String", "declarator": "USE_IPV6 = \"useIPv6\"", "var_name": "USE_IPV6"}, {"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(NetUtil.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(NetUtil.class)", "var_name": "LOGGER"}, {"original_string": "public static final int POLL_INTERVAL_SECONDS = 60;", "modifier": "public static final", "type": "int", "declarator": "POLL_INTERVAL_SECONDS = 60", "var_name": "POLL_INTERVAL_SECONDS"}, {"original_string": "private static final Pattern IPV4_PATTERN = Pattern\n            .compile(\"^(([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.){3}([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$\");", "modifier": "private static final", "type": "Pattern", "declarator": "IPV4_PATTERN = Pattern\n            .compile(\"^(([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.){3}([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$\")", "var_name": "IPV4_PATTERN"}, {"original_string": "private @Nullable String primaryAddress;", "modifier": "private @Nullable", "type": "String", "declarator": "primaryAddress", "var_name": "primaryAddress"}, {"original_string": "private @Nullable String configuredBroadcastAddress;", "modifier": "private @Nullable", "type": "String", "declarator": "configuredBroadcastAddress", "var_name": "configuredBroadcastAddress"}, {"original_string": "private boolean useOnlyOneAddress;", "modifier": "private", "type": "boolean", "declarator": "useOnlyOneAddress", "var_name": "useOnlyOneAddress"}, {"original_string": "private boolean useIPv6;", "modifier": "private", "type": "boolean", "declarator": "useIPv6", "var_name": "useIPv6"}, {"original_string": "private Set<NetworkAddressChangeListener> networkAddressChangeListeners = ConcurrentHashMap.newKeySet();", "modifier": "private", "type": "Set<NetworkAddressChangeListener>", "declarator": "networkAddressChangeListeners = ConcurrentHashMap.newKeySet()", "var_name": "networkAddressChangeListeners"}, {"original_string": "private Collection<CidrAddress> lastKnownInterfaceAddresses = Collections.emptyList();", "modifier": "private", "type": "Collection<CidrAddress>", "declarator": "lastKnownInterfaceAddresses = Collections.emptyList()", "var_name": "lastKnownInterfaceAddresses"}, {"original_string": "private final ScheduledExecutorService scheduledExecutorService = ThreadPoolManager\n            .getScheduledPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);", "modifier": "private final", "type": "ScheduledExecutorService", "declarator": "scheduledExecutorService = ThreadPoolManager\n            .getScheduledPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON)", "var_name": "scheduledExecutorService"}, {"original_string": "private @Nullable ScheduledFuture<?> networkInterfacePollFuture = null;", "modifier": "private @Nullable", "type": "ScheduledFuture<?>", "declarator": "networkInterfacePollFuture = null", "var_name": "networkInterfacePollFuture"}, {"original_string": "private final SafeCaller safeCaller;", "modifier": "private final", "type": "SafeCaller", "declarator": "safeCaller", "var_name": "safeCaller"}], "methods": [{"identifier": "NetUtil", "parameters": "(final @Reference SafeCaller safeCaller)", "modifiers": "@Activate public", "return": "", "signature": " NetUtil(final @Reference SafeCaller safeCaller)", "full_signature": "@Activate public  NetUtil(final @Reference SafeCaller safeCaller)", "class_method_signature": "NetUtil.NetUtil(final @Reference SafeCaller safeCaller)", "testcase": false, "constructor": true}, {"identifier": "activate", "parameters": "(Map<String, Object> props)", "modifiers": "@Activate protected", "return": "void", "signature": "void activate(Map<String, Object> props)", "full_signature": "@Activate protected void activate(Map<String, Object> props)", "class_method_signature": "NetUtil.activate(Map<String, Object> props)", "testcase": false, "constructor": false}, {"identifier": "deactivate", "parameters": "()", "modifiers": "@Deactivate protected", "return": "void", "signature": "void deactivate()", "full_signature": "@Deactivate protected void deactivate()", "class_method_signature": "NetUtil.deactivate()", "testcase": false, "constructor": false}, {"identifier": "modified", "parameters": "(Map<String, Object> config)", "modifiers": "@Modified public synchronized", "return": "void", "signature": "void modified(Map<String, Object> config)", "full_signature": "@Modified public synchronized void modified(Map<String, Object> config)", "class_method_signature": "NetUtil.modified(Map<String, Object> config)", "testcase": false, "constructor": false}, {"identifier": "getPrimaryIpv4HostAddress", "parameters": "()", "modifiers": "@Override public @Nullable", "return": "String", "signature": "String getPrimaryIpv4HostAddress()", "full_signature": "@Override public @Nullable String getPrimaryIpv4HostAddress()", "class_method_signature": "NetUtil.getPrimaryIpv4HostAddress()", "testcase": false, "constructor": false}, {"identifier": "isUseOnlyOneAddress", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isUseOnlyOneAddress()", "full_signature": "@Override public boolean isUseOnlyOneAddress()", "class_method_signature": "NetUtil.isUseOnlyOneAddress()", "testcase": false, "constructor": false}, {"identifier": "isUseIPv6", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isUseIPv6()", "full_signature": "@Override public boolean isUseIPv6()", "class_method_signature": "NetUtil.isUseIPv6()", "testcase": false, "constructor": false}, {"identifier": "addNetworkAddressChangeListener", "parameters": "(NetworkAddressChangeListener listener)", "modifiers": "@Override public", "return": "void", "signature": "void addNetworkAddressChangeListener(NetworkAddressChangeListener listener)", "full_signature": "@Override public void addNetworkAddressChangeListener(NetworkAddressChangeListener listener)", "class_method_signature": "NetUtil.addNetworkAddressChangeListener(NetworkAddressChangeListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeNetworkAddressChangeListener", "parameters": "(NetworkAddressChangeListener listener)", "modifiers": "@Override public", "return": "void", "signature": "void removeNetworkAddressChangeListener(NetworkAddressChangeListener listener)", "full_signature": "@Override public void removeNetworkAddressChangeListener(NetworkAddressChangeListener listener)", "class_method_signature": "NetUtil.removeNetworkAddressChangeListener(NetworkAddressChangeListener listener)", "testcase": false, "constructor": false}, {"identifier": "getFirstLocalIPv4Address", "parameters": "()", "modifiers": "private @Nullable", "return": "String", "signature": "String getFirstLocalIPv4Address()", "full_signature": "private @Nullable String getFirstLocalIPv4Address()", "class_method_signature": "NetUtil.getFirstLocalIPv4Address()", "testcase": false, "constructor": false}, {"identifier": "getAllBroadcastAddresses", "parameters": "()", "modifiers": "public static", "return": "List<String>", "signature": "List<String> getAllBroadcastAddresses()", "full_signature": "public static List<String> getAllBroadcastAddresses()", "class_method_signature": "NetUtil.getAllBroadcastAddresses()", "testcase": false, "constructor": false}, {"identifier": "getConfiguredBroadcastAddress", "parameters": "()", "modifiers": "@Override public @Nullable", "return": "String", "signature": "String getConfiguredBroadcastAddress()", "full_signature": "@Override public @Nullable String getConfiguredBroadcastAddress()", "class_method_signature": "NetUtil.getConfiguredBroadcastAddress()", "testcase": false, "constructor": false}, {"identifier": "getPrimaryBroadcastAddress", "parameters": "()", "modifiers": "private @Nullable", "return": "String", "signature": "String getPrimaryBroadcastAddress()", "full_signature": "private @Nullable String getPrimaryBroadcastAddress()", "class_method_signature": "NetUtil.getPrimaryBroadcastAddress()", "testcase": false, "constructor": false}, {"identifier": "getFirstIpv4BroadcastAddress", "parameters": "()", "modifiers": "private static @Nullable", "return": "String", "signature": "String getFirstIpv4BroadcastAddress()", "full_signature": "private static @Nullable String getFirstIpv4BroadcastAddress()", "class_method_signature": "NetUtil.getFirstIpv4BroadcastAddress()", "testcase": false, "constructor": false}, {"identifier": "getAllInterfaceAddresses", "parameters": "()", "modifiers": "public static", "return": "Collection<CidrAddress>", "signature": "Collection<CidrAddress> getAllInterfaceAddresses()", "full_signature": "public static Collection<CidrAddress> getAllInterfaceAddresses()", "class_method_signature": "NetUtil.getAllInterfaceAddresses()", "testcase": false, "constructor": false}, {"identifier": "networkPrefixLengthToNetmask", "parameters": "(int prefixLength)", "modifiers": "public static", "return": "String", "signature": "String networkPrefixLengthToNetmask(int prefixLength)", "full_signature": "public static String networkPrefixLengthToNetmask(int prefixLength)", "class_method_signature": "NetUtil.networkPrefixLengthToNetmask(int prefixLength)", "testcase": false, "constructor": false}, {"identifier": "getIpv4NetAddress", "parameters": "(String ipAddressString, short netMask)", "modifiers": "public static", "return": "String", "signature": "String getIpv4NetAddress(String ipAddressString, short netMask)", "full_signature": "public static String getIpv4NetAddress(String ipAddressString, short netMask)", "class_method_signature": "NetUtil.getIpv4NetAddress(String ipAddressString, short netMask)", "testcase": false, "constructor": false}, {"identifier": "getIpv4NetBroadcastAddress", "parameters": "(String ipAddressString, short prefix)", "modifiers": "public static", "return": "String", "signature": "String getIpv4NetBroadcastAddress(String ipAddressString, short prefix)", "full_signature": "public static String getIpv4NetBroadcastAddress(String ipAddressString, short prefix)", "class_method_signature": "NetUtil.getIpv4NetBroadcastAddress(String ipAddressString, short prefix)", "testcase": false, "constructor": false}, {"identifier": "getIPv4inSubnet", "parameters": "(String ipAddress, String subnetMask)", "modifiers": "private @Nullable", "return": "String", "signature": "String getIPv4inSubnet(String ipAddress, String subnetMask)", "full_signature": "private @Nullable String getIPv4inSubnet(String ipAddress, String subnetMask)", "class_method_signature": "NetUtil.getIPv4inSubnet(String ipAddress, String subnetMask)", "testcase": false, "constructor": false}, {"identifier": "isValidIPConfig", "parameters": "(String ipAddress)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidIPConfig(String ipAddress)", "full_signature": "public static boolean isValidIPConfig(String ipAddress)", "class_method_signature": "NetUtil.isValidIPConfig(String ipAddress)", "testcase": false, "constructor": false}, {"identifier": "scheduleToPollNetworkInterface", "parameters": "(int intervalInSeconds)", "modifiers": "private", "return": "void", "signature": "void scheduleToPollNetworkInterface(int intervalInSeconds)", "full_signature": "private void scheduleToPollNetworkInterface(int intervalInSeconds)", "class_method_signature": "NetUtil.scheduleToPollNetworkInterface(int intervalInSeconds)", "testcase": false, "constructor": false}, {"identifier": "pollAndNotifyNetworkInterfaceAddress", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void pollAndNotifyNetworkInterfaceAddress()", "full_signature": "private void pollAndNotifyNetworkInterfaceAddress()", "class_method_signature": "NetUtil.pollAndNotifyNetworkInterfaceAddress()", "testcase": false, "constructor": false}, {"identifier": "notifyListeners", "parameters": "(List<CidrAddress> added, List<CidrAddress> removed)", "modifiers": "private", "return": "void", "signature": "void notifyListeners(List<CidrAddress> added, List<CidrAddress> removed)", "full_signature": "private void notifyListeners(List<CidrAddress> added, List<CidrAddress> removed)", "class_method_signature": "NetUtil.notifyListeners(List<CidrAddress> added, List<CidrAddress> removed)", "testcase": false, "constructor": false}, {"identifier": "notifyPrimaryAddressChange", "parameters": "(@Nullable String oldPrimaryAddress, @Nullable String newPrimaryAddress)", "modifiers": "private", "return": "void", "signature": "void notifyPrimaryAddressChange(@Nullable String oldPrimaryAddress, @Nullable String newPrimaryAddress)", "full_signature": "private void notifyPrimaryAddressChange(@Nullable String oldPrimaryAddress, @Nullable String newPrimaryAddress)", "class_method_signature": "NetUtil.notifyPrimaryAddressChange(@Nullable String oldPrimaryAddress, @Nullable String newPrimaryAddress)", "testcase": false, "constructor": false}, {"identifier": "getConfigParameter", "parameters": "(Map<String, Object> parameters, String parameter, boolean defaultValue)", "modifiers": "private", "return": "boolean", "signature": "boolean getConfigParameter(Map<String, Object> parameters, String parameter, boolean defaultValue)", "full_signature": "private boolean getConfigParameter(Map<String, Object> parameters, String parameter, boolean defaultValue)", "class_method_signature": "NetUtil.getConfigParameter(Map<String, Object> parameters, String parameter, boolean defaultValue)", "testcase": false, "constructor": false}], "file": "bundles/org.openhab.core/src/main/java/org/openhab/core/net/NetUtil.java"}, "focal_method": {"identifier": "getIpv4NetBroadcastAddress", "parameters": "(String ipAddressString, short prefix)", "modifiers": "public static", "return": "String", "body": "public static String getIpv4NetBroadcastAddress(String ipAddressString, short prefix) {\n        String errorString = \"IP '\" + ipAddressString + \"' is not a valid IPv4 address\";\n        if (!isValidIPConfig(ipAddressString)) {\n            throw new IllegalArgumentException(errorString);\n        }\n        if (prefix < 1 || prefix > 32) {\n            throw new IllegalArgumentException(\"Prefix '\" + prefix + \"' is out of bounds (1-32)\");\n        }\n\n        try {\n            byte[] addr = InetAddress.getByName(ipAddressString).getAddress();\n            byte[] netmask = InetAddress.getByName(networkPrefixLengthToNetmask(prefix)).getAddress();\n            byte[] broadcast = new byte[] { (byte) (~netmask[0] | addr[0]), (byte) (~netmask[1] | addr[1]),\n                    (byte) (~netmask[2] | addr[2]), (byte) (~netmask[3] | addr[3]) };\n            return InetAddress.getByAddress(broadcast).getHostAddress();\n        } catch (UnknownHostException ex) {\n            throw new IllegalArgumentException(errorString);\n        }\n    }", "signature": "String getIpv4NetBroadcastAddress(String ipAddressString, short prefix)", "full_signature": "public static String getIpv4NetBroadcastAddress(String ipAddressString, short prefix)", "class_method_signature": "NetUtil.getIpv4NetBroadcastAddress(String ipAddressString, short prefix)", "testcase": false, "constructor": false, "invocations": ["isValidIPConfig", "getAddress", "getByName", "getAddress", "getByName", "networkPrefixLengthToNetmask", "getHostAddress", "getByAddress"]}, "repository": {"repo_id": 48337670, "url": "https://github.com/openhab/openhab-core", "stars": 241, "created": "12/20/2015 9:23:20 PM +00:00", "updates": "2020-01-27T16:55:53+00:00", "fork": "False", "license": "licensed"}}