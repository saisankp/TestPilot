{"test_class": {"identifier": "ApiListenerServletTest", "superclass": "extends Mockito", "interfaces": "", "fields": [{"original_string": "private Logger log = LogUtil.getLogger(this);", "modifier": "private", "type": "Logger", "declarator": "log = LogUtil.getLogger(this)", "var_name": "log"}, {"original_string": "private List<ApiListener> listeners = Collections.synchronizedList(new ArrayList<ApiListener>());", "modifier": "private", "type": "List<ApiListener>", "declarator": "listeners = Collections.synchronizedList(new ArrayList<ApiListener>())", "var_name": "listeners"}, {"original_string": "private ApiListenerServlet servlet;", "modifier": "private", "type": "ApiListenerServlet", "declarator": "servlet", "var_name": "servlet"}, {"original_string": "private Map<String, Object> session = null;", "modifier": "private", "type": "Map<String, Object>", "declarator": "session = null", "var_name": "session"}], "file": "core/src/test/java/nl/nn/adapterframework/http/rest/ApiListenerServletTest.java"}, "test_case": {"identifier": "headerAuthentication200", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void headerAuthentication200() throws ServletException, IOException, ListenerException, ConfigurationException {\n\t\tString uri = \"header\";\n\t\taddListener(uri, Methods.POST, AuthMethods.HEADER);\n\t\tString authToken = \"random-token_thing\";\n\n\t\tApiPrincipal principal = new ApiPrincipal();\n\t\tassertTrue(\"principal is not logged in? ttl expired?\", principal.isLoggedIn());\n\t\tApiCacheManager.getInstance().put(authToken, principal);\n\n\t\tMap<String, String> headers = new HashMap<String, String>();\n\t\theaders.put(\"Authorization\", authToken);\n\t\tResponse result = service(createRequest(uri, Methods.POST, \"{\\\"tralalalallala\\\":true}\", headers));\n\n\t\tString sessionAuthToken = (String) session.get(\"authorizationToken\");\n\t\tassertNotNull(\"session should contain auth token\", sessionAuthToken);\n\t\tassertEquals(\"auth tokens should match\", authToken, sessionAuthToken);\n\n\t\tassertEquals(200, result.getStatus());\n\t\tassertTrue(result.containsHeader(\"Allow\"));\n\t\tassertNull(result.getErrorMessage());\n\t}", "signature": "void headerAuthentication200()", "full_signature": "@Test public void headerAuthentication200()", "class_method_signature": "ApiListenerServletTest.headerAuthentication200()", "testcase": true, "constructor": false, "invocations": ["addListener", "assertTrue", "isLoggedIn", "put", "getInstance", "put", "service", "createRequest", "get", "assertNotNull", "assertEquals", "assertEquals", "getStatus", "assertTrue", "containsHeader", "assertNull", "getErrorMessage"]}, "focal_class": {"identifier": "ApiListenerServlet", "superclass": "extends HttpServletBase", "interfaces": "", "fields": [{"original_string": "private static final long serialVersionUID = 1L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 1L", "var_name": "serialVersionUID"}, {"original_string": "private List<String> IGNORE_HEADERS = Arrays.asList(\"connection\", \"transfer-encoding\", \"content-type\", \"authorization\");", "modifier": "private", "type": "List<String>", "declarator": "IGNORE_HEADERS = Arrays.asList(\"connection\", \"transfer-encoding\", \"content-type\", \"authorization\")", "var_name": "IGNORE_HEADERS"}, {"original_string": "protected Logger log = LogUtil.getLogger(this);", "modifier": "protected", "type": "Logger", "declarator": "log = LogUtil.getLogger(this)", "var_name": "log"}, {"original_string": "private ApiServiceDispatcher dispatcher = null;", "modifier": "private", "type": "ApiServiceDispatcher", "declarator": "dispatcher = null", "var_name": "dispatcher"}, {"original_string": "private IApiCache cache = null;", "modifier": "private", "type": "IApiCache", "declarator": "cache = null", "var_name": "cache"}, {"original_string": "private int authTTL = AppConstants.getInstance().getInt(\"api.auth.token-ttl\", 60 * 60 * 24 * 7);", "modifier": "private", "type": "int", "declarator": "authTTL = AppConstants.getInstance().getInt(\"api.auth.token-ttl\", 60 * 60 * 24 * 7)", "var_name": "authTTL"}, {"original_string": "private String CorsAllowOrigin = AppConstants.getInstance().getString(\"api.auth.cors.allowOrigin\", \"*\");", "modifier": "private", "type": "String", "declarator": "CorsAllowOrigin = AppConstants.getInstance().getString(\"api.auth.cors.allowOrigin\", \"*\")", "var_name": "CorsAllowOrigin"}, {"original_string": "private String CorsExposeHeaders = AppConstants.getInstance().getString(\"api.auth.cors.exposeHeaders\", \"Allow, ETag, Content-Disposition\");", "modifier": "private", "type": "String", "declarator": "CorsExposeHeaders = AppConstants.getInstance().getString(\"api.auth.cors.exposeHeaders\", \"Allow, ETag, Content-Disposition\")", "var_name": "CorsExposeHeaders"}], "methods": [{"identifier": "init", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void init()", "full_signature": "@Override public void init()", "class_method_signature": "ApiListenerServlet.init()", "testcase": false, "constructor": false}, {"identifier": "destroy", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void destroy()", "full_signature": "@Override public void destroy()", "class_method_signature": "ApiListenerServlet.destroy()", "testcase": false, "constructor": false}, {"identifier": "returnJson", "parameters": "(HttpServletResponse response, int status, JsonObject json)", "modifiers": "public", "return": "void", "signature": "void returnJson(HttpServletResponse response, int status, JsonObject json)", "full_signature": "public void returnJson(HttpServletResponse response, int status, JsonObject json)", "class_method_signature": "ApiListenerServlet.returnJson(HttpServletResponse response, int status, JsonObject json)", "testcase": false, "constructor": false}, {"identifier": "service", "parameters": "(HttpServletRequest request, HttpServletResponse response)", "modifiers": "@Override protected", "return": "void", "signature": "void service(HttpServletRequest request, HttpServletResponse response)", "full_signature": "@Override protected void service(HttpServletRequest request, HttpServletResponse response)", "class_method_signature": "ApiListenerServlet.service(HttpServletRequest request, HttpServletResponse response)", "testcase": false, "constructor": false}, {"identifier": "getUrlMapping", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getUrlMapping()", "full_signature": "@Override public String getUrlMapping()", "class_method_signature": "ApiListenerServlet.getUrlMapping()", "testcase": false, "constructor": false}], "file": "core/src/main/java/nl/nn/adapterframework/http/rest/ApiListenerServlet.java"}, "focal_method": {"identifier": "service", "parameters": "(HttpServletRequest request, HttpServletResponse response)", "modifiers": "@Override protected", "return": "void", "body": "@Override\n\tprotected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n\t\tString uri = request.getPathInfo();\n\t\tString method = request.getMethod().toUpperCase();\n\t\tlog.trace(\"ApiListenerServlet dispatching uri [\"+uri+\"] and method [\"+method+\"]\");\n\n\t\tif (uri==null) {\n\t\t\tresponse.setStatus(400);\n\t\t\tlog.warn(\"Aborting request with status [400], empty uri\");\n\t\t\treturn;\n\t\t}\n\t\tif(uri.startsWith(\"/\"))\n\t\t\turi = uri.substring(1);\n\t\tif(uri.endsWith(\"/\"))\n\t\t\turi = uri.substring(0, uri.length()-1);\n\n\t\t/**\n\t\t * Generate an OpenApi json file\n\t\t */\n\t\tif(uri.equalsIgnoreCase(\"openapi.json\")) {\n\t\t\tJsonObject jsonSchema = dispatcher.generateOpenApiJsonSchema();\n\t\t\treturnJson(response, 200, jsonSchema);\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * Generate an OpenApi json file for a set of ApiDispatchConfigs\n\t\t */\n\t\tif(uri.endsWith(\"/openapi.json\")) {\n\t\t\turi = uri.substring(0, uri.length()-\"/openapi.json\".length());\n\t\t\tList<ApiDispatchConfig> apiConfigs = dispatcher.findMatchingConfigsForUri(uri);\n\t\t\tJsonObject jsonSchema = dispatcher.generateOpenApiJsonSchema(apiConfigs);\n\t\t\treturnJson(response, 200, jsonSchema);\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * Initiate and populate messageContext\n\t\t */\n\t\tPipeLineSessionBase messageContext = new PipeLineSessionBase();\n\t\tmessageContext.put(IPipeLineSession.HTTP_REQUEST_KEY, request);\n\t\tmessageContext.put(IPipeLineSession.HTTP_RESPONSE_KEY, response);\n\t\tmessageContext.put(IPipeLineSession.SERVLET_CONTEXT_KEY, getServletContext());\n\t\tmessageContext.setSecurityHandler(new HttpSecurityHandler(request));\n\n\t\ttry {\n\t\t\tApiDispatchConfig config = dispatcher.findConfigForUri(uri);\n\t\t\tif(config == null) {\n\t\t\t\tresponse.setStatus(404);\n\t\t\t\tif(log.isTraceEnabled()) log.trace(\"Aborting request with status [404], no ApiListener configured for [\"+uri+\"]\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle Cross-Origin Resource Sharing\n\t\t\t * TODO make this work behind loadbalancers/reverse proxies\n\t\t\t * TODO check if request ip/origin header matches allowOrigin property\n\t\t\t */\n\t\t\tString origin = request.getHeader(\"Origin\");\n\t\t\tif(method.equals(\"OPTIONS\") || origin != null) {\n\t\t\t\tresponse.setHeader(\"Access-Control-Allow-Origin\", CorsAllowOrigin);\n\t\t\t\tString headers = request.getHeader(\"Access-Control-Request-Headers\");\n\t\t\t\tif (headers != null)\n\t\t\t\t\tresponse.setHeader(\"Access-Control-Allow-Headers\", headers);\n\t\t\t\tresponse.setHeader(\"Access-Control-Expose-Headers\", CorsExposeHeaders);\n\t\n\t\t\t\tStringBuilder methods = new StringBuilder();\n\t\t\t\tfor (String mtd : config.getMethods()) {\n\t\t\t\t\tmethods.append(\", \").append(mtd);\n\t\t\t\t}\n\t\t\t\tresponse.setHeader(\"Access-Control-Allow-Methods\", methods.toString());\n\n\t\t\t\t//Only cut off OPTIONS (aka preflight) requests\n\t\t\t\tif(method.equals(\"OPTIONS\")) {\n\t\t\t\t\tresponse.setStatus(200);\n\t\t\t\t\tif(log.isTraceEnabled()) log.trace(\"Aborting preflight request with status [200], method [\"+method+\"]\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get serviceClient\n\t\t\t */\n\t\t\tApiListener listener = config.getApiListener(method);\n\t\t\tif(listener == null) {\n\t\t\t\tresponse.setStatus(405);\n\t\t\t\tif(log.isTraceEnabled()) log.trace(\"Aborting request with status [405], method [\"+method+\"] not allowed\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(log.isTraceEnabled()) log.trace(\"ApiListenerServlet calling service [\"+listener.getName()+\"]\");\n\n\t\t\t/**\n\t\t\t * Check authentication\n\t\t\t */\n\t\t\tApiPrincipal userPrincipal = null;\n\n\t\t\tif(!AuthenticationMethods.NONE.equals(listener.getAuthenticationMethod())) {\n\t\t\t\tString authorizationToken = null;\n\t\t\t\tCookie authorizationCookie = null;\n\n\t\t\t\tswitch (listener.getAuthenticationMethod()) {\n\t\t\t\tcase COOKIE:\n\t\t\t\t\tCookie[] cookies = request.getCookies();\n\t\t\t\t\tif(cookies != null) {\n\t\t\t\t\t\tfor (Cookie cookie : cookies) {\n\t\t\t\t\t\t\tif(\"authenticationToken\".equals(cookie.getName())) {\n\t\t\t\t\t\t\t\tauthorizationToken = cookie.getValue();\n\t\t\t\t\t\t\t\tauthorizationCookie = cookie;\n\t\t\t\t\t\t\t\tauthorizationCookie.setPath(\"/\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase HEADER:\n\t\t\t\t\tauthorizationToken = request.getHeader(\"Authorization\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase AUTHROLE:\n\t\t\t\t\tList<String> roles = listener.getAuthenticationRoles();\n\t\t\t\t\tif(roles != null) {\n\t\t\t\t\t\tfor (String role : roles) {\n\t\t\t\t\t\t\tif(request.isUserInRole(role)) {\n\t\t\t\t\t\t\t\tuserPrincipal = new ApiPrincipal(); //Create a dummy user\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(authorizationToken != null && cache.containsKey(authorizationToken))\n\t\t\t\t\tuserPrincipal = (ApiPrincipal) cache.get(authorizationToken);\n\n\t\t\t\tif(userPrincipal == null || !userPrincipal.isLoggedIn()) {\n\t\t\t\t\tcache.remove(authorizationToken);\n\t\t\t\t\tif(authorizationCookie != null) {\n\t\t\t\t\t\tauthorizationCookie.setMaxAge(0);\n\t\t\t\t\t\tresponse.addCookie(authorizationCookie);\n\t\t\t\t\t}\n\n\t\t\t\t\tresponse.setStatus(401);\n\t\t\t\t\tif(log.isTraceEnabled()) log.trace(\"Aborting request with status [401], no (valid) credentials supplied\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif(authorizationCookie != null) {\n\t\t\t\t\tauthorizationCookie.setMaxAge(authTTL);\n\t\t\t\t\tresponse.addCookie(authorizationCookie);\n\t\t\t\t}\n\n\t\t\t\tif(authorizationToken != null) {\n\t\t\t\t\tuserPrincipal.updateExpiry();\n\t\t\t\t\tuserPrincipal.setToken(authorizationToken);\n\t\t\t\t\tcache.put(authorizationToken, userPrincipal, authTTL);\n\t\t\t\t\tmessageContext.put(\"authorizationToken\", authorizationToken);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Remove this? it's now available as header value\n\t\t\tmessageContext.put(\"remoteAddr\", request.getRemoteAddr());\n\t\t\tif(userPrincipal != null)\n\t\t\t\tmessageContext.put(IPipeLineSession.API_PRINCIPAL_KEY, userPrincipal);\n\t\t\tmessageContext.put(\"uri\", uri);\n\n\t\t\t/**\n\t\t\t * Evaluate preconditions\n\t\t\t */\n\t\t\tString acceptHeader = request.getHeader(\"Accept\");\n\t\t\tif(StringUtils.isNotEmpty(acceptHeader)) { //If an Accept header is present, make sure we comply to it!\n\t\t\t\tif(!listener.accepts(acceptHeader)) {\n\t\t\t\t\tresponse.setStatus(406);\n\t\t\t\t\tresponse.getWriter().print(\"It appears you expected the MediaType [\"+acceptHeader+\"] but I only support the MediaType [\"+listener.getContentType()+\"] :)\");\n\t\t\t\t\tif(log.isTraceEnabled()) log.trace(\"Aborting request with status [406], client expects [\"+acceptHeader+\"] got [\"+listener.getContentType()+\"] instead\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(request.getContentType() != null && !listener.isConsumable(request.getContentType())) {\n\t\t\t\tresponse.setStatus(415);\n\t\t\t\tif(log.isTraceEnabled()) log.trace(\"Aborting request with status [415], did not match consumes [\"+listener.getConsumes()+\"] got [\"+request.getContentType()+\"] instead\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString etagCacheKey = ApiCacheManager.buildCacheKey(uri);\n\t\t\tlog.debug(\"Evaluating preconditions for listener[\"+listener.getName()+\"] etagKey[\"+etagCacheKey+\"]\");\n\t\t\tif(cache.containsKey(etagCacheKey)) {\n\t\t\t\tString cachedEtag = (String) cache.get(etagCacheKey);\n\t\t\t\tlog.debug(\"found etag value[\"+cachedEtag+\"] for key[\"+etagCacheKey+\"]\");\n\n\t\t\t\tif(method.equals(\"GET\")) {\n\t\t\t\t\tString ifNoneMatch = request.getHeader(\"If-None-Match\");\n\t\t\t\t\tif(ifNoneMatch != null && ifNoneMatch.equals(cachedEtag)) {\n\t\t\t\t\t\tresponse.setStatus(304);\n\t\t\t\t\t\tif(log.isTraceEnabled()) log.trace(\"Aborting request with status [304], matched if-none-match [\"+ifNoneMatch+\"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString ifMatch = request.getHeader(\"If-Match\");\n\t\t\t\t\tif(ifMatch != null && !ifMatch.equals(cachedEtag)) {\n\t\t\t\t\t\tresponse.setStatus(412);\n\t\t\t\t\t\tif(log.isTraceEnabled()) log.trace(\"Aborting request with status [412], matched if-match [\"+ifMatch+\"] method [\"+method+\"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmessageContext.put(\"updateEtag\", listener.getUpdateEtag());\n\n\t\t\t/**\n\t\t\t * Check authorization\n\t\t\t */\n\t\t\t//TODO: authentication implementation\n\n\t\t\t/**\n\t\t\t * Map uriIdentifiers into messageContext \n\t\t\t */\n\t\t\tString patternSegments[] = listener.getUriPattern().split(\"/\");\n\t\t\tString uriSegments[] = uri.split(\"/\");\n\t\t\tint uriIdentifier = 0;\n\t\t\tfor (int i = 0; i < patternSegments.length; i++) {\n\t\t\t\tString segment = patternSegments[i];\n\t\t\t\tString name = null;\n\n\t\t\t\tif(\"*\".equals(segment)) {\n\t\t\t\t\tname = \"uriIdentifier_\"+uriIdentifier;\n\t\t\t\t}\n\t\t\t\telse if(segment.startsWith(\"{\") && segment.endsWith(\"}\")) {\n\t\t\t\t\tname = segment.substring(1, segment.length()-1);\n\t\t\t\t}\n\n\t\t\t\tif(name != null) {\n\t\t\t\t\turiIdentifier++;\n\t\t\t\t\tif(log.isTraceEnabled()) log.trace(\"setting uriSegment [\"+name+\"] to [\"+uriSegments[i]+\"]\");\n\t\t\t\t\tmessageContext.put(name, uriSegments[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Map queryParameters into messageContext\n\t\t\t */\n\t\t\tEnumeration<String> paramnames = request.getParameterNames();\n\t\t\twhile (paramnames.hasMoreElements()) {\n\t\t\t\tString paramname = paramnames.nextElement();\n\t\t\t\tString paramvalue = request.getParameter(paramname);\n\n\t\t\t\tif(log.isTraceEnabled()) log.trace(\"setting queryParameter [\"+paramname+\"] to [\"+paramvalue+\"]\");\n\t\t\t\tmessageContext.put(paramname, paramvalue);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Map headers into messageContext\n\t\t\t */\n\t\t\tEnumeration<String> headers = request.getHeaderNames();\n\t\t\tXmlBuilder headersXml = new XmlBuilder(\"headers\");\n\t\t\twhile (headers.hasMoreElements()) {\n\t\t\t\tString headerName = headers.nextElement().toLowerCase();\n\t\t\t\tif(IGNORE_HEADERS.contains(headerName))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tString headerValue = request.getHeader(headerName);\n\t\t\t\ttry {\n\t\t\t\t\tXmlBuilder headerXml = new XmlBuilder(\"header\");\n\t\t\t\t\theaderXml.addAttribute(\"name\", headerName);\n\t\t\t\t\theaderXml.setValue(headerValue);\n\t\t\t\t\theadersXml.addSubElement(headerXml);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\tlog.info(\"unable to convert header to xml name[\"+headerName+\"] value[\"+headerValue+\"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tmessageContext.put(\"headers\", headersXml.toXML());\n\n\t\t\t/**\n\t\t\t * Map multipart parts into messageContext\n\t\t\t */\n\t\t\tString body = \"\";\n\t\t\tif (ServletFileUpload.isMultipartContent(request)) {\n\t\t\t\tDiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory();\n\t\t\t\tServletFileUpload servletFileUpload = new ServletFileUpload(diskFileItemFactory);\n\t\t\t\tList<FileItem> items = servletFileUpload.parseRequest(request);\n\t\t\t\tXmlBuilder attachments = new XmlBuilder(\"parts\");\n\t\t\t\tint i = 0;\n\t\t\t\tString multipartBodyName = listener.getMultipartBodyName();\n\t\t\t\tfor (FileItem item : items) {\n\t\t\t\t\tString fieldName = item.getFieldName();\n\t\t\t\t\t//First part -> pipeline input when multipartBodyName=null\n\t\t\t\t\tif((i == 0 && multipartBodyName == null) || fieldName.equalsIgnoreCase(multipartBodyName)) {\n\t\t\t\t\t\t//TODO this is possible because it's been read from disk multiple times, ideally you want to stream it directly!\n\t\t\t\t\t\tbody = Misc.streamToString(item.getInputStream(),\"\\n\",false);\n\t\t\t\t\t}\n\n\t\t\t\t\tXmlBuilder attachment = new XmlBuilder(\"part\");\n\t\t\t\t\tattachment.addAttribute(\"name\", fieldName);\n\t\t\t\t\tif (item.isFormField()) {\n\t\t\t\t\t\t// Process regular form field (input type=\"text|radio|checkbox|etc\", select, etc).\n\t\t\t\t\t\tString fieldValue = item.getString();\n\t\t\t\t\t\tif(log.isTraceEnabled()) log.trace(\"setting multipart formField [\"+fieldName+\"] to [\"+fieldValue+\"]\");\n\t\t\t\t\t\tmessageContext.put(fieldName, fieldValue);\n\t\t\t\t\t\tattachment.addAttribute(\"type\", \"text\");\n\t\t\t\t\t\tattachment.addAttribute(\"value\", fieldValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Process form file field (input type=\"file\").\n\t\t\t\t\t\tString fieldNameName = fieldName + \"Name\";\n\t\t\t\t\t\tString fileName = FilenameUtils.getName(item.getName());\n\t\t\t\t\t\tif(log.isTraceEnabled()) log.trace(\"setting multipart formFile [\"+fieldNameName+\"] to [\"+fileName+\"]\");\n\t\t\t\t\t\tmessageContext.put(fieldNameName, fileName);\n\t\t\t\t\t\tif(log.isTraceEnabled()) log.trace(\"setting parameter [\"+fieldName+\"] to input stream of file [\"+fileName+\"]\");\n\t\t\t\t\t\tmessageContext.put(fieldName, item.getInputStream());\n\n\t\t\t\t\t\tattachment.addAttribute(\"type\", \"file\");\n\t\t\t\t\t\tattachment.addAttribute(\"filename\", fileName);\n\t\t\t\t\t\tattachment.addAttribute(\"size\", item.getSize());\n\t\t\t\t\t\tattachment.addAttribute(\"sessionKey\", fieldName);\n\t\t\t\t\t\tString contentType = item.getContentType();\n\t\t\t\t\t\tif(contentType != null) {\n\t\t\t\t\t\t\tString mimeType = contentType;\n\t\t\t\t\t\t\tint semicolon = contentType.indexOf(\";\");\n\t\t\t\t\t\t\tif(semicolon >= 0) {\n\t\t\t\t\t\t\t\tmimeType = contentType.substring(0, semicolon);\n\t\t\t\t\t\t\t\tString mightContainCharSet = contentType.substring(semicolon+1).trim();\n\t\t\t\t\t\t\t\tif(mightContainCharSet.contains(\"charset=\")) {\n\t\t\t\t\t\t\t\t\tString charSet = mightContainCharSet.substring(mightContainCharSet.indexOf(\"charset=\")+8);\n\t\t\t\t\t\t\t\t\tattachment.addAttribute(\"charSet\", charSet);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tmimeType = contentType;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tattachment.addAttribute(\"mimeType\", mimeType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tattachments.addSubElement(attachment);\n\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tmessageContext.put(\"multipartAttachments\", attachments.toXML());\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Compile Allow header\n\t\t\t */\n\t\t\tStringBuilder methods = new StringBuilder();\n\t\t\tmethods.append(\"OPTIONS, \");\n\t\t\tfor (String mtd : config.getMethods()) {\n\t\t\t\tmethods.append(mtd + \", \");\n\t\t\t}\n\t\t\tmessageContext.put(\"allowedMethods\", methods.substring(0, methods.length()-2));\n\n\t\t\t/**\n\t\t\t * Process the request through the pipeline\n\t\t\t */\n\t\t\tif (!ServletFileUpload.isMultipartContent(request)) {\n\t\t\t\tbody = Misc.streamToString(request.getInputStream(),\"\\n\",false);\n\t\t\t}\n\n\t\t\tString messageId = null;\n\t\t\tif(StringUtils.isNotEmpty(listener.getMessageIdHeader())) {\n\t\t\t\tString messageIdHeader = request.getHeader(listener.getMessageIdHeader());\n\t\t\t\tif(StringUtils.isNotEmpty(messageIdHeader)) {\n\t\t\t\t\tmessageId = messageIdHeader;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPipeLineSessionBase.setListenerParameters(messageContext, messageId, null, null, null); //We're only using this method to keep setting id/cid/tcid uniform\n\t\t\tString result = listener.processRequest(null, body, messageContext);\n\n\t\t\t/**\n\t\t\t * Calculate an eTag over the processed result and store in cache\n\t\t\t */\n\t\t\tif(messageContext.get(\"updateEtag\", true)) {\n\t\t\t\tlog.debug(\"calculating etags over processed result\");\n\t\t\t\tString cleanPattern = listener.getCleanPattern();\n\t\t\t\tif(result != null && method.equals(\"GET\") && cleanPattern != null) {\n\t\t\t\t\tString eTag = ApiCacheManager.buildEtag(cleanPattern, result.hashCode());\n\t\t\t\t\tlog.debug(\"adding/overwriting etag with key[\"+etagCacheKey+\"] value[\"+eTag+\"]\");\n\t\t\t\t\tcache.put(etagCacheKey, eTag);\n\t\t\t\t\tresponse.addHeader(\"etag\", eTag);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug(\"removing etag with key[\"+etagCacheKey+\"]\");\n\t\t\t\t\tcache.remove(etagCacheKey);\n\n\t\t\t\t\t// Not only remove the eTag for the selected resources but also the collection\n\t\t\t\t\tString key = ApiCacheManager.getParentCacheKey(listener, uri);\n\t\t\t\t\tif(key != null) {\n\t\t\t\t\t\tlog.debug(\"removing parent etag with key[\"+key+\"]\");\n\t\t\t\t\t\tcache.remove(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Add headers\n\t\t\t */\n\t\t\tresponse.addHeader(\"Allow\", (String) messageContext.get(\"allowedMethods\"));\n\n\t\t\tString contentType = listener.getContentType();\n\t\t\tif(listener.getProduces().equals(\"ANY\")) {\n\t\t\t\tcontentType = messageContext.get(\"contentType\", contentType);\n\t\t\t}\n\t\t\tresponse.setHeader(\"Content-Type\", contentType);\n\n\t\t\t/**\n\t\t\t * Check if an exitcode has been defined or if a statuscode has been added to the messageContext.\n\t\t\t */\n\t\t\tint statusCode = messageContext.get(\"exitcode\", 0);\n\t\t\tif(statusCode > 0)\n\t\t\t\tresponse.setStatus(statusCode);\n\n\t\t\t/**\n\t\t\t * Finalize the pipeline and write the result to the response\n\t\t\t */\n\t\t\tif(result != null)\n\t\t\t\tresponse.getWriter().print(result);\n\t\t\tif(log.isTraceEnabled()) log.trace(\"ApiListenerServlet finished with statusCode [\"+statusCode+\"] result [\"+result+\"]\");\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.warn(\"ApiListenerServlet caught exception, will rethrow as ServletException\", e);\n\t\t\ttry {\n\t\t\t\tresponse.reset();\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t//We're only informing the end user(s), no need to catch this error...\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t\t\t}\n\t\t}\n\t}", "signature": "void service(HttpServletRequest request, HttpServletResponse response)", "full_signature": "@Override protected void service(HttpServletRequest request, HttpServletResponse response)", "class_method_signature": "ApiListenerServlet.service(HttpServletRequest request, HttpServletResponse response)", "testcase": false, "constructor": false, "invocations": ["getPathInfo", "toUpperCase", "getMethod", "trace", "setStatus", "warn", "startsWith", "substring", "endsWith", "substring", "length", "equalsIgnoreCase", "generateOpenApiJsonSchema", "returnJson", "endsWith", "substring", "length", "length", "findMatchingConfigsForUri", "generateOpenApiJsonSchema", "returnJson", "put", "put", "put", "getServletContext", "setSecurityHandler", "findConfigForUri", "setStatus", "isTraceEnabled", "trace", "getHeader", "equals", "setHeader", "getHeader", "setHeader", "setHeader", "getMethods", "append", "append", "setHeader", "toString", "equals", "setStatus", "isTraceEnabled", "trace", "getApiListener", "setStatus", "isTraceEnabled", "trace", "isTraceEnabled", "trace", "getName", "equals", "getAuthenticationMethod", "getAuthenticationMethod", "getCookies", "equals", "getName", "getValue", "setPath", "getHeader", "getAuthenticationRoles", "isUserInRole", "containsKey", "get", "isLoggedIn", "remove", "setMaxAge", "addCookie", "setStatus", "isTraceEnabled", "trace", "setMaxAge", "addCookie", "updateExpiry", "setToken", "put", "put", "put", "getRemoteAddr", "put", "put", "getHeader", "isNotEmpty", "accepts", "setStatus", "print", "getWriter", "getContentType", "isTraceEnabled", "trace", "getContentType", "getContentType", "isConsumable", "getContentType", "setStatus", "isTraceEnabled", "trace", "getConsumes", "getContentType", "buildCacheKey", "debug", "getName", "containsKey", "get", "debug", "equals", "getHeader", "equals", "setStatus", "isTraceEnabled", "trace", "getHeader", "equals", "setStatus", "isTraceEnabled", "trace", "put", "getUpdateEtag", "split", "getUriPattern", "split", "equals", "startsWith", "endsWith", "substring", "length", "isTraceEnabled", "trace", "put", "getParameterNames", "hasMoreElements", "nextElement", "getParameter", "isTraceEnabled", "trace", "put", "getHeaderNames", "hasMoreElements", "toLowerCase", "nextElement", "contains", "getHeader", "addAttribute", "setValue", "addSubElement", "info", "put", "toXML", "isMultipartContent", "parseRequest", "getMultipartBodyName", "getFieldName", "equalsIgnoreCase", "streamToString", "getInputStream", "addAttribute", "isFormField", "getString", "isTraceEnabled", "trace", "put", "addAttribute", "addAttribute", "getName", "getName", "isTraceEnabled", "trace", "put", "isTraceEnabled", "trace", "put", "getInputStream", "addAttribute", "addAttribute", "addAttribute", "getSize", "addAttribute", "getContentType", "indexOf", "substring", "trim", "substring", "contains", "substring", "indexOf", "addAttribute", "addAttribute", "addSubElement", "put", "toXML", "append", "getMethods", "append", "put", "substring", "length", "isMultipartContent", "streamToString", "getInputStream", "isNotEmpty", "getMessageIdHeader", "getHeader", "getMessageIdHeader", "isNotEmpty", "setListenerParameters", "processRequest", "get", "debug", "getCleanPattern", "equals", "buildEtag", "hashCode", "debug", "put", "addHeader", "debug", "remove", "getParentCacheKey", "debug", "remove", "addHeader", "get", "getContentType", "equals", "getProduces", "get", "setHeader", "get", "setStatus", "print", "getWriter", "isTraceEnabled", "trace", "warn", "reset", "sendError", "getMessage", "setStatus"]}, "repository": {"repo_id": 8927606, "url": "https://github.com/ibissource/iaf", "stars": 17, "created": "3/21/2013 11:48:24 AM +00:00", "updates": "2020-01-27T15:25:21+00:00", "fork": "False", "license": "licensed"}}