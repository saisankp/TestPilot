{"test_class": {"identifier": "MinimalZipParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private byte[] unitTestZipArchive;", "modifier": "private", "type": "byte[]", "declarator": "unitTestZipArchive", "var_name": "unitTestZipArchive"}], "file": "feya/libraries/archive_diff/diff.generator/src/test/java/com/google/archivepatcher/generator/MinimalZipParserTest.java"}, "test_case": {"identifier": "testParseCentralDirectoryEntry", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testParseCentralDirectoryEntry() throws Exception {\n    ByteArrayInputStream in = new ByteArrayInputStream(unitTestZipArchive);\n    in.mark(unitTestZipArchive.length);\n    int eocdOffset = MinimalZipParser.locateStartOfEocd(unitTestZipArchive);\n    Assert.assertEquals(eocdOffset, in.skip(eocdOffset));\n    MinimalCentralDirectoryMetadata metadata = MinimalZipParser.parseEocd(in);\n    in.reset();\n    Assert.assertEquals(\n        metadata.getOffsetOfCentralDirectory(), in.skip(metadata.getOffsetOfCentralDirectory()));\n\n    // Read each entry and verify all fields *except* the value returned by\n    // MinimalZipEntry.getFileOffsetOfCompressedData(), as that has yet to be computed.\n    for (UnitTestZipEntry expectedEntry : UnitTestZipArchive.allEntriesInFileOrder) {\n      MinimalZipEntry parsed = MinimalZipParser.parseCentralDirectoryEntry(in);\n      Assert.assertEquals(expectedEntry.path, parsed.getFileName());\n\n      // Verify that the local signature header is at the calculated position\n      byte[] expectedSignatureBlock = new byte[] {0x50, 0x4b, 0x03, 0x04};\n      for (int index = 0; index < 4; index++) {\n        byte actualByte = unitTestZipArchive[((int) parsed.getFileOffsetOfLocalEntry()) + index];\n        Assert.assertEquals(expectedSignatureBlock[index], actualByte);\n      }\n\n      if (expectedEntry.level > 0) {\n        Assert.assertEquals(8 /* deflate */, parsed.getCompressionMethod());\n      } else {\n        Assert.assertEquals(0 /* store */, parsed.getCompressionMethod());\n      }\n      byte[] uncompressedContent = expectedEntry.getUncompressedBinaryContent();\n      Assert.assertEquals(uncompressedContent.length, parsed.getUncompressedSize());\n      CRC32 crc32 = new CRC32();\n      crc32.update(uncompressedContent);\n      Assert.assertEquals(crc32.getValue(), parsed.getCrc32OfUncompressedData());\n      byte[] compressedContent = expectedEntry.getCompressedBinaryContent();\n      Assert.assertEquals(compressedContent.length, parsed.getCompressedSize());\n    }\n  }", "signature": "void testParseCentralDirectoryEntry()", "full_signature": "@Test public void testParseCentralDirectoryEntry()", "class_method_signature": "MinimalZipParserTest.testParseCentralDirectoryEntry()", "testcase": true, "constructor": false, "invocations": ["mark", "locateStartOfEocd", "assertEquals", "skip", "parseEocd", "reset", "assertEquals", "getOffsetOfCentralDirectory", "skip", "getOffsetOfCentralDirectory", "parseCentralDirectoryEntry", "assertEquals", "getFileName", "getFileOffsetOfLocalEntry", "assertEquals", "assertEquals", "getCompressionMethod", "assertEquals", "getCompressionMethod", "getUncompressedBinaryContent", "assertEquals", "getUncompressedSize", "update", "assertEquals", "getValue", "getCrc32OfUncompressedData", "getCompressedBinaryContent", "assertEquals", "getCompressedSize"]}, "focal_class": {"identifier": "MinimalZipParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int EOCD_SIGNATURE = 0x06054b50;", "modifier": "public static final", "type": "int", "declarator": "EOCD_SIGNATURE = 0x06054b50", "var_name": "EOCD_SIGNATURE"}, {"original_string": "public static final int CENTRAL_DIRECTORY_ENTRY_SIGNATURE = 0x02014b50;", "modifier": "public static final", "type": "int", "declarator": "CENTRAL_DIRECTORY_ENTRY_SIGNATURE = 0x02014b50", "var_name": "CENTRAL_DIRECTORY_ENTRY_SIGNATURE"}, {"original_string": "public static final int LOCAL_ENTRY_SIGNATURE = 0x04034b50;", "modifier": "public static final", "type": "int", "declarator": "LOCAL_ENTRY_SIGNATURE = 0x04034b50", "var_name": "LOCAL_ENTRY_SIGNATURE"}], "methods": [{"identifier": "readByteOrDie", "parameters": "(InputStream in)", "modifiers": "private static", "return": "int", "signature": "int readByteOrDie(InputStream in)", "full_signature": "private static int readByteOrDie(InputStream in)", "class_method_signature": "MinimalZipParser.readByteOrDie(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "skipOrDie", "parameters": "(InputStream in, long numBytes)", "modifiers": "private static", "return": "void", "signature": "void skipOrDie(InputStream in, long numBytes)", "full_signature": "private static void skipOrDie(InputStream in, long numBytes)", "class_method_signature": "MinimalZipParser.skipOrDie(InputStream in, long numBytes)", "testcase": false, "constructor": false}, {"identifier": "read16BitUnsigned", "parameters": "(InputStream in)", "modifiers": "private static", "return": "int", "signature": "int read16BitUnsigned(InputStream in)", "full_signature": "private static int read16BitUnsigned(InputStream in)", "class_method_signature": "MinimalZipParser.read16BitUnsigned(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "read32BitUnsigned", "parameters": "(InputStream in)", "modifiers": "private static", "return": "long", "signature": "long read32BitUnsigned(InputStream in)", "full_signature": "private static long read32BitUnsigned(InputStream in)", "class_method_signature": "MinimalZipParser.read32BitUnsigned(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "readOrDie", "parameters": "(InputStream in, byte[] buffer, int offset, int length)", "modifiers": "private static", "return": "void", "signature": "void readOrDie(InputStream in, byte[] buffer, int offset, int length)", "full_signature": "private static void readOrDie(InputStream in, byte[] buffer, int offset, int length)", "class_method_signature": "MinimalZipParser.readOrDie(InputStream in, byte[] buffer, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "parseCentralDirectoryEntry", "parameters": "(InputStream in)", "modifiers": "public static", "return": "MinimalZipEntry", "signature": "MinimalZipEntry parseCentralDirectoryEntry(InputStream in)", "full_signature": "public static MinimalZipEntry parseCentralDirectoryEntry(InputStream in)", "class_method_signature": "MinimalZipParser.parseCentralDirectoryEntry(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "parseLocalEntryAndGetCompressedDataOffset", "parameters": "(InputStream in)", "modifiers": "public static", "return": "long", "signature": "long parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "full_signature": "public static long parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "class_method_signature": "MinimalZipParser.parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "locateStartOfEocd", "parameters": "(RandomAccessFileInputStream in, int searchBufferLength)", "modifiers": "public static", "return": "long", "signature": "long locateStartOfEocd(RandomAccessFileInputStream in, int searchBufferLength)", "full_signature": "public static long locateStartOfEocd(RandomAccessFileInputStream in, int searchBufferLength)", "class_method_signature": "MinimalZipParser.locateStartOfEocd(RandomAccessFileInputStream in, int searchBufferLength)", "testcase": false, "constructor": false}, {"identifier": "locateStartOfEocd", "parameters": "(byte[] buffer)", "modifiers": "public static", "return": "int", "signature": "int locateStartOfEocd(byte[] buffer)", "full_signature": "public static int locateStartOfEocd(byte[] buffer)", "class_method_signature": "MinimalZipParser.locateStartOfEocd(byte[] buffer)", "testcase": false, "constructor": false}, {"identifier": "parseEocd", "parameters": "(InputStream in)", "modifiers": "public static", "return": "MinimalCentralDirectoryMetadata", "signature": "MinimalCentralDirectoryMetadata parseEocd(InputStream in)", "full_signature": "public static MinimalCentralDirectoryMetadata parseEocd(InputStream in)", "class_method_signature": "MinimalZipParser.parseEocd(InputStream in)", "testcase": false, "constructor": false}], "file": "feya/libraries/archive_diff/diff.generator/src/main/java/com/google/archivepatcher/generator/MinimalZipParser.java"}, "focal_method": {"identifier": "parseCentralDirectoryEntry", "parameters": "(InputStream in)", "modifiers": "public static", "return": "MinimalZipEntry", "body": "public static MinimalZipEntry parseCentralDirectoryEntry(InputStream in) throws IOException {\n    // *** 4 bytes encode the CENTRAL_DIRECTORY_ENTRY_SIGNATURE, verify for sanity\n    // 2 bytes encode the version-made-by, ignore\n    // 2 bytes encode the version-needed-to-extract, ignore\n    // *** 2 bytes encode the general-purpose flags, read for language encoding. [READ THIS]\n    // *** 2 bytes encode the compression method, [READ THIS]\n    // 2 bytes encode the MSDOS last modified file time, ignore\n    // 2 bytes encode the MSDOS last modified file date, ignore\n    // *** 4 bytes encode the CRC32 of the uncompressed data [READ THIS]\n    // *** 4 bytes encode the compressed size [READ THIS]\n    // *** 4 bytes encode the uncompressed size [READ THIS]\n    // *** 2 bytes encode the length of the file name [READ THIS]\n    // *** 2 bytes encode the length of the extras, needed to skip the bytes later [READ THIS]\n    // *** 2 bytes encode the length of the comment, needed to skip the bytes later [READ THIS]\n    // 2 bytes encode the disk number, ignore\n    // 2 bytes encode the internal file attributes, ignore\n    // 4 bytes encode the external file attributes, ignore\n    // *** 4 bytes encode the offset of the local section entry, where the data is [READ THIS]\n    // n bytes encode the file name\n    // n bytes encode the extras\n    // n bytes encode the comment\n    if (((int) read32BitUnsigned(in)) != CENTRAL_DIRECTORY_ENTRY_SIGNATURE) {\n      throw new ZipException(\"Bad central directory header\");\n    }\n    skipOrDie(in, 2 + 2); // Skip version stuff\n    int generalPurposeFlags = read16BitUnsigned(in);\n    int compressionMethod = read16BitUnsigned(in);\n    skipOrDie(in, 2 + 2); // Skip MSDOS junk\n    long crc32OfUncompressedData = read32BitUnsigned(in);\n    long compressedSize = read32BitUnsigned(in);\n    long uncompressedSize = read32BitUnsigned(in);\n    int fileNameLength = read16BitUnsigned(in);\n    int extrasLength = read16BitUnsigned(in);\n    int commentLength = read16BitUnsigned(in);\n    skipOrDie(in, 2 + 2 + 4); // Skip the disk number and file attributes\n    long fileOffsetOfLocalEntry = read32BitUnsigned(in);\n    byte[] fileNameBuffer = new byte[fileNameLength];\n    readOrDie(in, fileNameBuffer, 0, fileNameBuffer.length);\n    skipOrDie(in, extrasLength + commentLength);\n    // General purpose flag bit 11 is an important hint for the character set used for file names.\n    boolean generalPurposeFlagBit11 = (generalPurposeFlags & (0x1 << 10)) != 0;\n    return new MinimalZipEntry(\n        compressionMethod,\n        crc32OfUncompressedData,\n        compressedSize,\n        uncompressedSize,\n        fileNameBuffer,\n        generalPurposeFlagBit11,\n        fileOffsetOfLocalEntry);\n  }", "signature": "MinimalZipEntry parseCentralDirectoryEntry(InputStream in)", "full_signature": "public static MinimalZipEntry parseCentralDirectoryEntry(InputStream in)", "class_method_signature": "MinimalZipParser.parseCentralDirectoryEntry(InputStream in)", "testcase": false, "constructor": false, "invocations": ["read32BitUnsigned", "skipOrDie", "read16BitUnsigned", "read16BitUnsigned", "skipOrDie", "read32BitUnsigned", "read32BitUnsigned", "read32BitUnsigned", "read16BitUnsigned", "read16BitUnsigned", "read16BitUnsigned", "skipOrDie", "read32BitUnsigned", "readOrDie", "skipOrDie"]}, "repository": {"repo_id": 20126854, "url": "https://github.com/kaedea/Feya", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 12, "size": 7798, "license": "licensed"}}