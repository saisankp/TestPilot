{"test_class": {"identifier": "UtilTest", "superclass": "", "interfaces": "", "fields": [], "file": "core/src/test/java/net/adamcin/oakpal/core/UtilTest.java"}, "test_case": {"identifier": "testMapManifestHeaderResources", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMapManifestHeaderResources() throws Exception {\n        final Logger logger = getLoggerFactory().getLogger(Util.class);\n        final Level oldLevel = logger.getLevel();\n        final File mfDir = new File(\"src/test/resources/utiljar\");\n        final File mfFile = new File(mfDir, JarFile.MANIFEST_NAME);\n        try (InputStream mfStream = new FileInputStream(mfFile)) {\n            Manifest manifest = new Manifest(mfStream);\n\n            final File targetDir = new File(\"target/test-temp\");\n            targetDir.mkdirs();\n            final File mfJar = new File(targetDir, \"utiljar.jar\");\n            if (mfJar.exists()) {\n                mfJar.delete();\n            }\n\n            try (JarOutputStream mfJarOut = new JarOutputStream(new FileOutputStream(mfJar), manifest)) {\n                // nothing to add\n            }\n\n            // test against directory manifest only\n            Map<URL, List<URL>> dirMapped = Util.mapManifestHeaderResources(\"Good-RelPaths\",\n                    Collections.singletonList(mfDir));\n            assertEquals(\"Expect two good paths for directory manifest: \" + dirMapped, 2,\n                    dirMapped.values().iterator().next().size());\n\n            // test against constructed jar manifest only\n            Map<URL, List<URL>> mapped = Util.mapManifestHeaderResources(\"Good-RelPaths\",\n                    Collections.singletonList(mfJar));\n            assertEquals(\"Expect two good paths for jar manifest: \" + mapped, 2,\n                    mapped.values().iterator().next().size());\n\n            // test mapping of both manifests for two resources each\n            Map<URL, List<URL>> bothMapped = Util.mapManifestHeaderResources(\"Good-RelPaths\",\n                    Arrays.asList(mfDir, mfJar));\n            assertEquals(\"Expect two entries in both mapped: \" + bothMapped, 2,\n                    bothMapped.size());\n            assertTrue(\"Expect two good paths for all entries when both mapped: \" + bothMapped,\n                    bothMapped.values().stream().allMatch(resources -> resources.size() == 2));\n        } finally {\n            logger.setLevel(oldLevel);\n        }\n    }", "signature": "void testMapManifestHeaderResources()", "full_signature": "@Test public void testMapManifestHeaderResources()", "class_method_signature": "UtilTest.testMapManifestHeaderResources()", "testcase": true, "constructor": false, "invocations": ["getLogger", "getLoggerFactory", "getLevel", "mkdirs", "exists", "delete", "mapManifestHeaderResources", "singletonList", "assertEquals", "size", "next", "iterator", "values", "mapManifestHeaderResources", "singletonList", "assertEquals", "size", "next", "iterator", "values", "mapManifestHeaderResources", "asList", "assertEquals", "size", "assertTrue", "allMatch", "stream", "values", "size", "setLevel"]}, "focal_class": {"identifier": "Util", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(Util.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(Util.class)", "var_name": "LOGGER"}], "methods": [{"identifier": "Util", "parameters": "()", "modifiers": "private", "return": "", "signature": " Util()", "full_signature": "private  Util()", "class_method_signature": "Util.Util()", "testcase": false, "constructor": true}, {"identifier": "isEmpty", "parameters": "(final String value)", "modifiers": "static", "return": "boolean", "signature": "boolean isEmpty(final String value)", "full_signature": "static boolean isEmpty(final String value)", "class_method_signature": "Util.isEmpty(final String value)", "testcase": false, "constructor": false}, {"identifier": "wrapSessionReadOnly", "parameters": "(final Session session)", "modifiers": "public static", "return": "Session", "signature": "Session wrapSessionReadOnly(final Session session)", "full_signature": "public static Session wrapSessionReadOnly(final Session session)", "class_method_signature": "Util.wrapSessionReadOnly(final Session session)", "testcase": false, "constructor": false}, {"identifier": "getManifestHeaderValues", "parameters": "(final Manifest manifest, final String headerName)", "modifiers": "public static", "return": "List<String>", "signature": "List<String> getManifestHeaderValues(final Manifest manifest, final String headerName)", "full_signature": "public static List<String> getManifestHeaderValues(final Manifest manifest, final String headerName)", "class_method_signature": "Util.getManifestHeaderValues(final Manifest manifest, final String headerName)", "testcase": false, "constructor": false}, {"identifier": "escapeManifestHeaderValue", "parameters": "(final @NotNull String... values)", "modifiers": "public static", "return": "String", "signature": "String escapeManifestHeaderValue(final @NotNull String... values)", "full_signature": "public static String escapeManifestHeaderValue(final @NotNull String... values)", "class_method_signature": "Util.escapeManifestHeaderValue(final @NotNull String... values)", "testcase": false, "constructor": false}, {"identifier": "escapeManifestHeaderValues", "parameters": "(final @NotNull List<String> values)", "modifiers": "public static", "return": "String", "signature": "String escapeManifestHeaderValues(final @NotNull List<String> values)", "full_signature": "public static String escapeManifestHeaderValues(final @NotNull List<String> values)", "class_method_signature": "Util.escapeManifestHeaderValues(final @NotNull List<String> values)", "testcase": false, "constructor": false}, {"identifier": "resolveManifestResources", "parameters": "(final URL manifestUrl, final List<String> resources)", "modifiers": "public static", "return": "List<URL>", "signature": "List<URL> resolveManifestResources(final URL manifestUrl, final List<String> resources)", "full_signature": "public static List<URL> resolveManifestResources(final URL manifestUrl, final List<String> resources)", "class_method_signature": "Util.resolveManifestResources(final URL manifestUrl, final List<String> resources)", "testcase": false, "constructor": false}, {"identifier": "mapManifestHeaderResources", "parameters": "(final String headerName, final ClassLoader classLoader)", "modifiers": "public static", "return": "Map<URL, List<URL>>", "signature": "Map<URL, List<URL>> mapManifestHeaderResources(final String headerName, final ClassLoader classLoader)", "full_signature": "public static Map<URL, List<URL>> mapManifestHeaderResources(final String headerName, final ClassLoader classLoader)", "class_method_signature": "Util.mapManifestHeaderResources(final String headerName, final ClassLoader classLoader)", "testcase": false, "constructor": false}, {"identifier": "mapManifestHeaderResources", "parameters": "(final String headerName, final List<File> files)", "modifiers": "public static", "return": "Map<URL, List<URL>>", "signature": "Map<URL, List<URL>> mapManifestHeaderResources(final String headerName, final List<File> files)", "full_signature": "public static Map<URL, List<URL>> mapManifestHeaderResources(final String headerName, final List<File> files)", "class_method_signature": "Util.mapManifestHeaderResources(final String headerName, final List<File> files)", "testcase": false, "constructor": false}, {"identifier": "mapManifestHeaderResources", "parameters": "(final String headerName, final URL manifestUrl)", "modifiers": "public static", "return": "Map<URL, List<URL>>", "signature": "Map<URL, List<URL>> mapManifestHeaderResources(final String headerName, final URL manifestUrl)", "full_signature": "public static Map<URL, List<URL>> mapManifestHeaderResources(final String headerName, final URL manifestUrl)", "class_method_signature": "Util.mapManifestHeaderResources(final String headerName, final URL manifestUrl)", "testcase": false, "constructor": false}, {"identifier": "getDefaultClassLoader", "parameters": "()", "modifiers": "static", "return": "ClassLoader", "signature": "ClassLoader getDefaultClassLoader()", "full_signature": "static ClassLoader getDefaultClassLoader()", "class_method_signature": "Util.getDefaultClassLoader()", "testcase": false, "constructor": false}, {"identifier": "debugFilter", "parameters": "(final Logger logger, final String format)", "modifiers": "public static", "return": "Predicate<T>", "signature": "Predicate<T> debugFilter(final Logger logger, final String format)", "full_signature": "public static Predicate<T> debugFilter(final Logger logger, final String format)", "class_method_signature": "Util.debugFilter(final Logger logger, final String format)", "testcase": false, "constructor": false}, {"identifier": "traceFilter", "parameters": "(final Logger logger, final String format)", "modifiers": "public static", "return": "Predicate<T>", "signature": "Predicate<T> traceFilter(final Logger logger, final String format)", "full_signature": "public static Predicate<T> traceFilter(final Logger logger, final String format)", "class_method_signature": "Util.traceFilter(final Logger logger, final String format)", "testcase": false, "constructor": false}, {"identifier": "composeTry", "parameters": "(final Function<R, M> monadUnit,\n                                                      final Supplier<M> monadZero,\n                                                      final TryFunction<T, R> onElement,\n                                                      final BiConsumer<T, Exception> onError)", "modifiers": "@Deprecated public static", "return": "Function<T, M>", "signature": "Function<T, M> composeTry(final Function<R, M> monadUnit,\n                                                      final Supplier<M> monadZero,\n                                                      final TryFunction<T, R> onElement,\n                                                      final BiConsumer<T, Exception> onError)", "full_signature": "@Deprecated public static Function<T, M> composeTry(final Function<R, M> monadUnit,\n                                                      final Supplier<M> monadZero,\n                                                      final TryFunction<T, R> onElement,\n                                                      final BiConsumer<T, Exception> onError)", "class_method_signature": "Util.composeTry(final Function<R, M> monadUnit,\n                                                      final Supplier<M> monadZero,\n                                                      final TryFunction<T, R> onElement,\n                                                      final BiConsumer<T, Exception> onError)", "testcase": false, "constructor": false}, {"identifier": "optFunc", "parameters": "(final Function<T, R> inputFunc)", "modifiers": "@Deprecated public static", "return": "Function<T, Optional<R>>", "signature": "Function<T, Optional<R>> optFunc(final Function<T, R> inputFunc)", "full_signature": "@Deprecated public static Function<T, Optional<R>> optFunc(final Function<T, R> inputFunc)", "class_method_signature": "Util.optFunc(final Function<T, R> inputFunc)", "testcase": false, "constructor": false}, {"identifier": "compose", "parameters": "(final Function<T, I> before, final Function<I, R> after)", "modifiers": "@Deprecated public static", "return": "Function<T, R>", "signature": "Function<T, R> compose(final Function<T, I> before, final Function<I, R> after)", "full_signature": "@Deprecated public static Function<T, R> compose(final Function<T, I> before, final Function<I, R> after)", "class_method_signature": "Util.compose(final Function<T, I> before, final Function<I, R> after)", "testcase": false, "constructor": false}], "file": "core/src/main/java/net/adamcin/oakpal/core/Util.java"}, "focal_method": {"identifier": "mapManifestHeaderResources", "parameters": "(final String headerName, final ClassLoader classLoader)", "modifiers": "public static", "return": "Map<URL, List<URL>>", "body": "public static Map<URL, List<URL>> mapManifestHeaderResources(final String headerName, final ClassLoader classLoader) throws IOException {\n        Map<URL, List<URL>> map = new LinkedHashMap<>();\n        Enumeration<URL> resEnum = classLoader.getResources(JarFile.MANIFEST_NAME);\n        while (resEnum.hasMoreElements()) {\n            URL url = resEnum.nextElement();\n            try (InputStream is = url.openStream()) {\n                Manifest manifest = new Manifest(is);\n                List<URL> headerResources = resolveManifestResources(url, getManifestHeaderValues(manifest, headerName));\n                map.put(url, headerResources);\n            }\n        }\n\n        return map;\n    }", "signature": "Map<URL, List<URL>> mapManifestHeaderResources(final String headerName, final ClassLoader classLoader)", "full_signature": "public static Map<URL, List<URL>> mapManifestHeaderResources(final String headerName, final ClassLoader classLoader)", "class_method_signature": "Util.mapManifestHeaderResources(final String headerName, final ClassLoader classLoader)", "testcase": false, "constructor": false, "invocations": ["getResources", "hasMoreElements", "nextElement", "openStream", "resolveManifestResources", "getManifestHeaderValues", "put"]}, "repository": {"repo_id": 155883728, "url": "https://github.com/adamcin/oakpal", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 6, "size": 13349, "license": "licensed"}}