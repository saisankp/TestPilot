{"test_class": {"identifier": "SelectionParametersTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Types typeUtils = new Types() {\n        @Override\n        public Element asElement(TypeMirror t) {\n            throw new UnsupportedOperationException( \"asElement is not supported\" );\n        }\n\n        @Override\n        public boolean isSameType(TypeMirror t1, TypeMirror t2) {\n            return t1.toString().equals( t2.toString() );\n        }\n\n        @Override\n        public boolean isSubtype(TypeMirror t1, TypeMirror t2) {\n            throw new UnsupportedOperationException( \"isSubType is not supported\" );\n        }\n\n        @Override\n        public boolean isAssignable(TypeMirror t1, TypeMirror t2) {\n            throw new UnsupportedOperationException( \"isAssignable is not supported\" );\n        }\n\n        @Override\n        public boolean contains(TypeMirror t1, TypeMirror t2) {\n            throw new UnsupportedOperationException( \"contains is not supported\" );\n        }\n\n        @Override\n        public boolean isSubsignature(ExecutableType m1, ExecutableType m2) {\n            throw new UnsupportedOperationException( \"isSubSignature is not supported\" );\n        }\n\n        @Override\n        public List<? extends TypeMirror> directSupertypes(TypeMirror t) {\n            throw new UnsupportedOperationException( \"directSupertypes is not supported\" );\n        }\n\n        @Override\n        public TypeMirror erasure(TypeMirror t) {\n            throw new UnsupportedOperationException( \"erasure is not supported\" );\n        }\n\n        @Override\n        public TypeElement boxedClass(PrimitiveType p) {\n            throw new UnsupportedOperationException( \"boxedClass is not supported\" );\n        }\n\n        @Override\n        public PrimitiveType unboxedType(TypeMirror t) {\n            throw new UnsupportedOperationException( \"unboxedType is not supported\" );\n        }\n\n        @Override\n        public TypeMirror capture(TypeMirror t) {\n            throw new UnsupportedOperationException( \"capture is not supported\" );\n        }\n\n        @Override\n        public PrimitiveType getPrimitiveType(TypeKind kind) {\n            throw new UnsupportedOperationException( \"getPrimitiveType is not supported\" );\n        }\n\n        @Override\n        public NullType getNullType() {\n            throw new UnsupportedOperationException( \"nullType is not supported\" );\n        }\n\n        @Override\n        public NoType getNoType(TypeKind kind) {\n            throw new UnsupportedOperationException( \"noType is not supported\" );\n        }\n\n        @Override\n        public ArrayType getArrayType(TypeMirror componentType) {\n            throw new UnsupportedOperationException( \"getArrayType is not supported\" );\n        }\n\n        @Override\n        public WildcardType getWildcardType(TypeMirror extendsBound, TypeMirror superBound) {\n            throw new UnsupportedOperationException( \"getWildCardType is not supported\" );\n        }\n\n        @Override\n        public DeclaredType getDeclaredType(TypeElement typeElem, TypeMirror... typeArgs) {\n            throw new UnsupportedOperationException( \"getDeclaredType is not supported\" );\n        }\n\n        @Override\n        public DeclaredType getDeclaredType(DeclaredType containing, TypeElement typeElem, TypeMirror... typeArgs) {\n            throw new UnsupportedOperationException( \"getDeclaredType is not supported\" );\n        }\n\n        @Override\n        public TypeMirror asMemberOf(DeclaredType containing, Element element) {\n            throw new UnsupportedOperationException( \"asMemberOf is not supported\" );\n        }\n    };", "modifier": "private final", "type": "Types", "declarator": "typeUtils = new Types() {\n        @Override\n        public Element asElement(TypeMirror t) {\n            throw new UnsupportedOperationException( \"asElement is not supported\" );\n        }\n\n        @Override\n        public boolean isSameType(TypeMirror t1, TypeMirror t2) {\n            return t1.toString().equals( t2.toString() );\n        }\n\n        @Override\n        public boolean isSubtype(TypeMirror t1, TypeMirror t2) {\n            throw new UnsupportedOperationException( \"isSubType is not supported\" );\n        }\n\n        @Override\n        public boolean isAssignable(TypeMirror t1, TypeMirror t2) {\n            throw new UnsupportedOperationException( \"isAssignable is not supported\" );\n        }\n\n        @Override\n        public boolean contains(TypeMirror t1, TypeMirror t2) {\n            throw new UnsupportedOperationException( \"contains is not supported\" );\n        }\n\n        @Override\n        public boolean isSubsignature(ExecutableType m1, ExecutableType m2) {\n            throw new UnsupportedOperationException( \"isSubSignature is not supported\" );\n        }\n\n        @Override\n        public List<? extends TypeMirror> directSupertypes(TypeMirror t) {\n            throw new UnsupportedOperationException( \"directSupertypes is not supported\" );\n        }\n\n        @Override\n        public TypeMirror erasure(TypeMirror t) {\n            throw new UnsupportedOperationException( \"erasure is not supported\" );\n        }\n\n        @Override\n        public TypeElement boxedClass(PrimitiveType p) {\n            throw new UnsupportedOperationException( \"boxedClass is not supported\" );\n        }\n\n        @Override\n        public PrimitiveType unboxedType(TypeMirror t) {\n            throw new UnsupportedOperationException( \"unboxedType is not supported\" );\n        }\n\n        @Override\n        public TypeMirror capture(TypeMirror t) {\n            throw new UnsupportedOperationException( \"capture is not supported\" );\n        }\n\n        @Override\n        public PrimitiveType getPrimitiveType(TypeKind kind) {\n            throw new UnsupportedOperationException( \"getPrimitiveType is not supported\" );\n        }\n\n        @Override\n        public NullType getNullType() {\n            throw new UnsupportedOperationException( \"nullType is not supported\" );\n        }\n\n        @Override\n        public NoType getNoType(TypeKind kind) {\n            throw new UnsupportedOperationException( \"noType is not supported\" );\n        }\n\n        @Override\n        public ArrayType getArrayType(TypeMirror componentType) {\n            throw new UnsupportedOperationException( \"getArrayType is not supported\" );\n        }\n\n        @Override\n        public WildcardType getWildcardType(TypeMirror extendsBound, TypeMirror superBound) {\n            throw new UnsupportedOperationException( \"getWildCardType is not supported\" );\n        }\n\n        @Override\n        public DeclaredType getDeclaredType(TypeElement typeElem, TypeMirror... typeArgs) {\n            throw new UnsupportedOperationException( \"getDeclaredType is not supported\" );\n        }\n\n        @Override\n        public DeclaredType getDeclaredType(DeclaredType containing, TypeElement typeElem, TypeMirror... typeArgs) {\n            throw new UnsupportedOperationException( \"getDeclaredType is not supported\" );\n        }\n\n        @Override\n        public TypeMirror asMemberOf(DeclaredType containing, Element element) {\n            throw new UnsupportedOperationException( \"asMemberOf is not supported\" );\n        }\n    }", "var_name": "typeUtils"}], "file": "processor/src/test/java/org/mapstruct/ap/internal/model/source/SelectionParametersTest.java"}, "test_case": {"identifier": "testHashCode", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testHashCode() {\n        List<String> qualifyingNames = Arrays.asList( \"language\", \"german\" );\n        TypeMirror resultType = new TestTypeMirror( \"resultType\" );\n        SelectionParameters params = new SelectionParameters( null, qualifyingNames, resultType, null );\n\n        int expectedHash = 3 * 97 + qualifyingNames.hashCode();\n        expectedHash = 97 * expectedHash + \"resultType\".hashCode();\n        assertThat( params.hashCode() ).as( \"Expected HashCode\" ).isEqualTo( expectedHash );\n    }", "signature": "void testHashCode()", "full_signature": "@Test public void testHashCode()", "class_method_signature": "SelectionParametersTest.testHashCode()", "testcase": true, "constructor": false, "invocations": ["asList", "hashCode", "hashCode", "isEqualTo", "as", "assertThat", "hashCode"]}, "focal_class": {"identifier": "SelectionParameters", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final List<TypeMirror> qualifiers;", "modifier": "private final", "type": "List<TypeMirror>", "declarator": "qualifiers", "var_name": "qualifiers"}, {"original_string": "private final List<String> qualifyingNames;", "modifier": "private final", "type": "List<String>", "declarator": "qualifyingNames", "var_name": "qualifyingNames"}, {"original_string": "private final TypeMirror resultType;", "modifier": "private final", "type": "TypeMirror", "declarator": "resultType", "var_name": "resultType"}, {"original_string": "private final Types typeUtils;", "modifier": "private final", "type": "Types", "declarator": "typeUtils", "var_name": "typeUtils"}, {"original_string": "private final SourceRHS sourceRHS;", "modifier": "private final", "type": "SourceRHS", "declarator": "sourceRHS", "var_name": "sourceRHS"}], "methods": [{"identifier": "forInheritance", "parameters": "(SelectionParameters selectionParameters)", "modifiers": "public static", "return": "SelectionParameters", "signature": "SelectionParameters forInheritance(SelectionParameters selectionParameters)", "full_signature": "public static SelectionParameters forInheritance(SelectionParameters selectionParameters)", "class_method_signature": "SelectionParameters.forInheritance(SelectionParameters selectionParameters)", "testcase": false, "constructor": false}, {"identifier": "SelectionParameters", "parameters": "(List<TypeMirror> qualifiers, List<String> qualifyingNames, TypeMirror resultType,\n        Types typeUtils)", "modifiers": "public", "return": "", "signature": " SelectionParameters(List<TypeMirror> qualifiers, List<String> qualifyingNames, TypeMirror resultType,\n        Types typeUtils)", "full_signature": "public  SelectionParameters(List<TypeMirror> qualifiers, List<String> qualifyingNames, TypeMirror resultType,\n        Types typeUtils)", "class_method_signature": "SelectionParameters.SelectionParameters(List<TypeMirror> qualifiers, List<String> qualifyingNames, TypeMirror resultType,\n        Types typeUtils)", "testcase": false, "constructor": true}, {"identifier": "SelectionParameters", "parameters": "(List<TypeMirror> qualifiers, List<String> qualifyingNames, TypeMirror resultType,\n        Types typeUtils, SourceRHS sourceRHS)", "modifiers": "private", "return": "", "signature": " SelectionParameters(List<TypeMirror> qualifiers, List<String> qualifyingNames, TypeMirror resultType,\n        Types typeUtils, SourceRHS sourceRHS)", "full_signature": "private  SelectionParameters(List<TypeMirror> qualifiers, List<String> qualifyingNames, TypeMirror resultType,\n        Types typeUtils, SourceRHS sourceRHS)", "class_method_signature": "SelectionParameters.SelectionParameters(List<TypeMirror> qualifiers, List<String> qualifyingNames, TypeMirror resultType,\n        Types typeUtils, SourceRHS sourceRHS)", "testcase": false, "constructor": true}, {"identifier": "getQualifiers", "parameters": "()", "modifiers": "public", "return": "List<TypeMirror>", "signature": "List<TypeMirror> getQualifiers()", "full_signature": "public List<TypeMirror> getQualifiers()", "class_method_signature": "SelectionParameters.getQualifiers()", "testcase": false, "constructor": false}, {"identifier": "getQualifyingNames", "parameters": "()", "modifiers": "public", "return": "List<String>", "signature": "List<String> getQualifyingNames()", "full_signature": "public List<String> getQualifyingNames()", "class_method_signature": "SelectionParameters.getQualifyingNames()", "testcase": false, "constructor": false}, {"identifier": "getResultType", "parameters": "()", "modifiers": "public", "return": "TypeMirror", "signature": "TypeMirror getResultType()", "full_signature": "public TypeMirror getResultType()", "class_method_signature": "SelectionParameters.getResultType()", "testcase": false, "constructor": false}, {"identifier": "getSourceRHS", "parameters": "()", "modifiers": "public", "return": "SourceRHS", "signature": "SourceRHS getSourceRHS()", "full_signature": "public SourceRHS getSourceRHS()", "class_method_signature": "SelectionParameters.getSourceRHS()", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "SelectionParameters.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "SelectionParameters.equals(Object obj)", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(List<TypeMirror> mirrors1, List<TypeMirror> mirrors2)", "modifiers": "private", "return": "boolean", "signature": "boolean equals(List<TypeMirror> mirrors1, List<TypeMirror> mirrors2)", "full_signature": "private boolean equals(List<TypeMirror> mirrors1, List<TypeMirror> mirrors2)", "class_method_signature": "SelectionParameters.equals(List<TypeMirror> mirrors1, List<TypeMirror> mirrors2)", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(TypeMirror mirror1, TypeMirror mirror2)", "modifiers": "private", "return": "boolean", "signature": "boolean equals(TypeMirror mirror1, TypeMirror mirror2)", "full_signature": "private boolean equals(TypeMirror mirror1, TypeMirror mirror2)", "class_method_signature": "SelectionParameters.equals(TypeMirror mirror1, TypeMirror mirror2)", "testcase": false, "constructor": false}, {"identifier": "forSourceRHS", "parameters": "(SourceRHS sourceRHS)", "modifiers": "public static", "return": "SelectionParameters", "signature": "SelectionParameters forSourceRHS(SourceRHS sourceRHS)", "full_signature": "public static SelectionParameters forSourceRHS(SourceRHS sourceRHS)", "class_method_signature": "SelectionParameters.forSourceRHS(SourceRHS sourceRHS)", "testcase": false, "constructor": false}], "file": "processor/src/main/java/org/mapstruct/ap/internal/model/source/SelectionParameters.java"}, "focal_method": {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "body": "@Override\n    public int hashCode() {\n        int hash = 3;\n        hash = 97 * hash + (this.qualifyingNames != null ? this.qualifyingNames.hashCode() : 0);\n        hash = 97 * hash + (this.resultType != null ? this.resultType.toString().hashCode() : 0);\n        return hash;\n    }", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "SelectionParameters.hashCode()", "testcase": false, "constructor": false, "invocations": ["hashCode", "hashCode", "toString"]}, "repository": {"repo_id": 4470435, "url": "https://github.com/mapstruct/mapstruct", "stars": 2319, "created": "5/28/2012 12:42:42 PM +00:00", "updates": "2020-01-27T19:16:09+00:00", "fork": "False", "license": "licensed"}}