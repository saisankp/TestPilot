{"test_class": {"identifier": "TransactionChainProxyTest", "superclass": "extends AbstractTransactionProxyTest", "interfaces": "", "fields": [{"original_string": "private LocalHistoryIdentifier historyId;", "modifier": "private", "type": "LocalHistoryIdentifier", "declarator": "historyId", "var_name": "historyId"}], "file": "opendaylight/md-sal/sal-distributed-datastore/src/test/java/org/opendaylight/controller/cluster/datastore/TransactionChainProxyTest.java"}, "test_case": {"identifier": "testChainedReadWriteTransactions", "parameters": "()", "modifiers": "@Test @SuppressWarnings(\"checkstyle:IllegalCatch\") public", "return": "void", "body": "@Test\n    @SuppressWarnings(\"checkstyle:IllegalCatch\")\n    public void testChainedReadWriteTransactions() throws Exception {\n        try (TransactionChainProxy txChainProxy = new TransactionChainProxy(mockComponentFactory, historyId)) {\n\n            ActorRef txActorRef1 = setupActorContextWithInitialCreateTransaction(getSystem(), READ_WRITE);\n\n            expectBatchedModifications(txActorRef1, 1);\n\n            Promise<Object> readyReplyPromise1 = akka.dispatch.Futures.promise();\n            doReturn(readyReplyPromise1.future()).when(mockActorContext).executeOperationAsync(\n                    eq(actorSelection(txActorRef1)), isA(BatchedModifications.class), any(Timeout.class));\n\n            DOMStoreWriteTransaction writeTx1 = txChainProxy.newReadWriteTransaction();\n\n            NormalizedNode<?, ?> writeNode1 = ImmutableNodes.containerNode(TestModel.TEST_QNAME);\n            writeTx1.write(TestModel.TEST_PATH, writeNode1);\n\n            writeTx1.ready();\n\n            verifyOneBatchedModification(txActorRef1, new WriteModification(TestModel.TEST_PATH, writeNode1), true);\n\n            String tx2MemberName = \"mock-member\";\n            ActorRef shardActorRef2 = setupActorContextWithoutInitialCreateTransaction(getSystem());\n            ActorRef txActorRef2 = setupActorContextWithInitialCreateTransaction(getSystem(), READ_WRITE,\n                    DataStoreVersions.CURRENT_VERSION, tx2MemberName, shardActorRef2);\n\n            expectBatchedModifications(txActorRef2, 1);\n\n            final NormalizedNode<?, ?> writeNode2 = ImmutableNodes.containerNode(TestModel.OUTER_LIST_QNAME);\n\n            final DOMStoreWriteTransaction writeTx2 = txChainProxy.newReadWriteTransaction();\n\n            final AtomicReference<Exception> caughtEx = new AtomicReference<>();\n            final CountDownLatch write2Complete = new CountDownLatch(1);\n            new Thread(() -> {\n                try {\n                    writeTx2.write(TestModel.OUTER_LIST_PATH, writeNode2);\n                } catch (Exception e) {\n                    caughtEx.set(e);\n                } finally {\n                    write2Complete.countDown();\n                }\n            }).start();\n\n            assertTrue(\"Tx 2 write should've completed\", write2Complete.await(5, TimeUnit.SECONDS));\n\n            if (caughtEx.get() != null) {\n                throw caughtEx.get();\n            }\n\n            try {\n                verify(mockActorContext, never()).executeOperationAsync(\n                        eq(getSystem().actorSelection(shardActorRef2.path())),\n                        eqCreateTransaction(tx2MemberName, READ_WRITE));\n            } catch (AssertionError e) {\n                fail(\"Tx 2 should not have initiated until the Tx 1's ready future completed\");\n            }\n\n            readyReplyPromise1.success(readyTxReply(txActorRef1.path().toString()).value().get().get());\n\n            verify(mockActorContext, timeout(5000)).executeOperationAsync(\n                    eq(getSystem().actorSelection(shardActorRef2.path())),\n                    eqCreateTransaction(tx2MemberName, READ_WRITE), any(Timeout.class));\n        }\n    }", "signature": "void testChainedReadWriteTransactions()", "full_signature": "@Test @SuppressWarnings(\"checkstyle:IllegalCatch\") public void testChainedReadWriteTransactions()", "class_method_signature": "TransactionChainProxyTest.testChainedReadWriteTransactions()", "testcase": true, "constructor": false, "invocations": ["setupActorContextWithInitialCreateTransaction", "getSystem", "expectBatchedModifications", "promise", "executeOperationAsync", "when", "doReturn", "future", "eq", "actorSelection", "isA", "any", "newReadWriteTransaction", "containerNode", "write", "ready", "verifyOneBatchedModification", "setupActorContextWithoutInitialCreateTransaction", "getSystem", "setupActorContextWithInitialCreateTransaction", "getSystem", "expectBatchedModifications", "containerNode", "newReadWriteTransaction", "start", "write", "set", "countDown", "assertTrue", "await", "get", "get", "executeOperationAsync", "verify", "never", "eq", "actorSelection", "getSystem", "path", "eqCreateTransaction", "fail", "success", "get", "get", "value", "readyTxReply", "toString", "path", "executeOperationAsync", "verify", "timeout", "eq", "actorSelection", "getSystem", "path", "eqCreateTransaction", "any"]}, "focal_class": {"identifier": "TransactionChainProxy", "superclass": "extends AbstractTransactionContextFactory<LocalTransactionChain>", "interfaces": "implements DOMStoreTransactionChain", "fields": [{"original_string": "private static final State IDLE_STATE = new DefaultState() {\n        @Override\n        void checkReady() {\n            // Okay to allocate\n        }\n    };", "modifier": "private static final", "type": "State", "declarator": "IDLE_STATE = new DefaultState() {\n        @Override\n        void checkReady() {\n            // Okay to allocate\n        }\n    }", "var_name": "IDLE_STATE"}, {"original_string": "private static final State CLOSED_STATE = new DefaultState() {\n        @Override\n        void checkReady() {\n            throw new DOMTransactionChainClosedException(\"Transaction chain has been closed\");\n        }\n    };", "modifier": "private static final", "type": "State", "declarator": "CLOSED_STATE = new DefaultState() {\n        @Override\n        void checkReady() {\n            throw new DOMTransactionChainClosedException(\"Transaction chain has been closed\");\n        }\n    }", "var_name": "CLOSED_STATE"}, {"original_string": "private static final Logger LOG = LoggerFactory.getLogger(TransactionChainProxy.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(TransactionChainProxy.class)", "var_name": "LOG"}, {"original_string": "private static final AtomicReferenceFieldUpdater<TransactionChainProxy, State> STATE_UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(TransactionChainProxy.class, State.class, \"currentState\");", "modifier": "private static final", "type": "AtomicReferenceFieldUpdater<TransactionChainProxy, State>", "declarator": "STATE_UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(TransactionChainProxy.class, State.class, \"currentState\")", "var_name": "STATE_UPDATER"}, {"original_string": "private final TransactionContextFactory parent;", "modifier": "private final", "type": "TransactionContextFactory", "declarator": "parent", "var_name": "parent"}, {"original_string": "private volatile State currentState = IDLE_STATE;", "modifier": "private volatile", "type": "State", "declarator": "currentState = IDLE_STATE", "var_name": "currentState"}, {"original_string": "private final ConcurrentMap<TransactionIdentifier, Promise<Object>> priorReadOnlyTxPromises =\n            new ConcurrentHashMap<>();", "modifier": "private final", "type": "ConcurrentMap<TransactionIdentifier, Promise<Object>>", "declarator": "priorReadOnlyTxPromises =\n            new ConcurrentHashMap<>()", "var_name": "priorReadOnlyTxPromises"}], "methods": [{"identifier": "TransactionChainProxy", "parameters": "(final TransactionContextFactory parent, final LocalHistoryIdentifier historyId)", "modifiers": "", "return": "", "signature": " TransactionChainProxy(final TransactionContextFactory parent, final LocalHistoryIdentifier historyId)", "full_signature": "  TransactionChainProxy(final TransactionContextFactory parent, final LocalHistoryIdentifier historyId)", "class_method_signature": "TransactionChainProxy.TransactionChainProxy(final TransactionContextFactory parent, final LocalHistoryIdentifier historyId)", "testcase": false, "constructor": true}, {"identifier": "newReadOnlyTransaction", "parameters": "()", "modifiers": "@Override public", "return": "DOMStoreReadTransaction", "signature": "DOMStoreReadTransaction newReadOnlyTransaction()", "full_signature": "@Override public DOMStoreReadTransaction newReadOnlyTransaction()", "class_method_signature": "TransactionChainProxy.newReadOnlyTransaction()", "testcase": false, "constructor": false}, {"identifier": "newReadWriteTransaction", "parameters": "()", "modifiers": "@Override public", "return": "DOMStoreReadWriteTransaction", "signature": "DOMStoreReadWriteTransaction newReadWriteTransaction()", "full_signature": "@Override public DOMStoreReadWriteTransaction newReadWriteTransaction()", "class_method_signature": "TransactionChainProxy.newReadWriteTransaction()", "testcase": false, "constructor": false}, {"identifier": "newWriteOnlyTransaction", "parameters": "()", "modifiers": "@Override public", "return": "DOMStoreWriteTransaction", "signature": "DOMStoreWriteTransaction newWriteOnlyTransaction()", "full_signature": "@Override public DOMStoreWriteTransaction newWriteOnlyTransaction()", "class_method_signature": "TransactionChainProxy.newWriteOnlyTransaction()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "TransactionChainProxy.close()", "testcase": false, "constructor": false}, {"identifier": "allocateWriteTransaction", "parameters": "(final TransactionType type)", "modifiers": "private", "return": "TransactionProxy", "signature": "TransactionProxy allocateWriteTransaction(final TransactionType type)", "full_signature": "private TransactionProxy allocateWriteTransaction(final TransactionType type)", "class_method_signature": "TransactionChainProxy.allocateWriteTransaction(final TransactionType type)", "testcase": false, "constructor": false}, {"identifier": "factoryForShard", "parameters": "(final String shardName, final ActorSelection shardLeader,\n            final ReadOnlyDataTree dataTree)", "modifiers": "@Override protected", "return": "LocalTransactionChain", "signature": "LocalTransactionChain factoryForShard(final String shardName, final ActorSelection shardLeader,\n            final ReadOnlyDataTree dataTree)", "full_signature": "@Override protected LocalTransactionChain factoryForShard(final String shardName, final ActorSelection shardLeader,\n            final ReadOnlyDataTree dataTree)", "class_method_signature": "TransactionChainProxy.factoryForShard(final String shardName, final ActorSelection shardLeader,\n            final ReadOnlyDataTree dataTree)", "testcase": false, "constructor": false}, {"identifier": "findPrimaryShard", "parameters": "(final String shardName, final TransactionIdentifier txId)", "modifiers": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) @Override protected", "return": "Future<PrimaryShardInfo>", "signature": "Future<PrimaryShardInfo> findPrimaryShard(final String shardName, final TransactionIdentifier txId)", "full_signature": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) @Override protected Future<PrimaryShardInfo> findPrimaryShard(final String shardName, final TransactionIdentifier txId)", "class_method_signature": "TransactionChainProxy.findPrimaryShard(final String shardName, final TransactionIdentifier txId)", "testcase": false, "constructor": false}, {"identifier": "combineFutureWithPossiblePriorReadOnlyTxFutures", "parameters": "(final Future<T> future,\n            final TransactionIdentifier txId)", "modifiers": "private", "return": "Future<T>", "signature": "Future<T> combineFutureWithPossiblePriorReadOnlyTxFutures(final Future<T> future,\n            final TransactionIdentifier txId)", "full_signature": "private Future<T> combineFutureWithPossiblePriorReadOnlyTxFutures(final Future<T> future,\n            final TransactionIdentifier txId)", "class_method_signature": "TransactionChainProxy.combineFutureWithPossiblePriorReadOnlyTxFutures(final Future<T> future,\n            final TransactionIdentifier txId)", "testcase": false, "constructor": false}, {"identifier": "combineWithPriorReadOnlyTxFutures", "parameters": "(final Future<T> future, final TransactionIdentifier txId)", "modifiers": "private", "return": "Future<T>", "signature": "Future<T> combineWithPriorReadOnlyTxFutures(final Future<T> future, final TransactionIdentifier txId)", "full_signature": "private Future<T> combineWithPriorReadOnlyTxFutures(final Future<T> future, final TransactionIdentifier txId)", "class_method_signature": "TransactionChainProxy.combineWithPriorReadOnlyTxFutures(final Future<T> future, final TransactionIdentifier txId)", "testcase": false, "constructor": false}, {"identifier": "onTransactionReady", "parameters": "(final TransactionIdentifier transaction,\n            final Collection<Future<T>> cohortFutures)", "modifiers": "@Override protected", "return": "void", "signature": "void onTransactionReady(final TransactionIdentifier transaction,\n            final Collection<Future<T>> cohortFutures)", "full_signature": "@Override protected void onTransactionReady(final TransactionIdentifier transaction,\n            final Collection<Future<T>> cohortFutures)", "class_method_signature": "TransactionChainProxy.onTransactionReady(final TransactionIdentifier transaction,\n            final Collection<Future<T>> cohortFutures)", "testcase": false, "constructor": false}, {"identifier": "onTransactionContextCreated", "parameters": "(final TransactionIdentifier transactionId)", "modifiers": "@Override protected", "return": "void", "signature": "void onTransactionContextCreated(final TransactionIdentifier transactionId)", "full_signature": "@Override protected void onTransactionContextCreated(final TransactionIdentifier transactionId)", "class_method_signature": "TransactionChainProxy.onTransactionContextCreated(final TransactionIdentifier transactionId)", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-distributed-datastore/src/main/java/org/opendaylight/controller/cluster/datastore/TransactionChainProxy.java"}, "focal_method": {"identifier": "newReadWriteTransaction", "parameters": "()", "modifiers": "@Override public", "return": "DOMStoreReadWriteTransaction", "body": "@Override\n    public DOMStoreReadWriteTransaction newReadWriteTransaction() {\n        getActorUtils().acquireTxCreationPermit();\n        return allocateWriteTransaction(TransactionType.READ_WRITE);\n    }", "signature": "DOMStoreReadWriteTransaction newReadWriteTransaction()", "full_signature": "@Override public DOMStoreReadWriteTransaction newReadWriteTransaction()", "class_method_signature": "TransactionChainProxy.newReadWriteTransaction()", "testcase": false, "constructor": false, "invocations": ["acquireTxCreationPermit", "getActorUtils", "allocateWriteTransaction"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}