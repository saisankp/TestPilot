{"test_class": {"identifier": "CusumDetectorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double WEAK_SIGMAS = 3.0;", "modifier": "private static final", "type": "double", "declarator": "WEAK_SIGMAS = 3.0", "var_name": "WEAK_SIGMAS"}, {"original_string": "private static final double STRONG_SIGMAS = 4.0;", "modifier": "private static final", "type": "double", "declarator": "STRONG_SIGMAS = 4.0", "var_name": "STRONG_SIGMAS"}, {"original_string": "private static final double TOLERANCE = 0.01;", "modifier": "private static final", "type": "double", "declarator": "TOLERANCE = 0.01", "var_name": "TOLERANCE"}, {"original_string": "private static final int WARMUP_PERIOD = 25;", "modifier": "private static final", "type": "int", "declarator": "WARMUP_PERIOD = 25", "var_name": "WARMUP_PERIOD"}, {"original_string": "private UUID detectorUuid;", "modifier": "private", "type": "UUID", "declarator": "detectorUuid", "var_name": "detectorUuid"}, {"original_string": "private MetricDefinition metricDefinition;", "modifier": "private", "type": "MetricDefinition", "declarator": "metricDefinition", "var_name": "metricDefinition"}, {"original_string": "private long epochSecond;", "modifier": "private", "type": "long", "declarator": "epochSecond", "var_name": "epochSecond"}, {"original_string": "private static List<CusumDetectorTestRow> data;", "modifier": "private static", "type": "List<CusumDetectorTestRow>", "declarator": "data", "var_name": "data"}], "file": "anomdetect/src/test/java/com/expedia/adaptivealerting/anomdetect/detect/outlier/algo/cusum/CusumDetectorTest.java"}, "test_case": {"identifier": "testClassify_rightTailed", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testClassify_rightTailed() {\n        val testRows = data.listIterator();\n        val testRow0 = testRows.next();\n\n        val anomalyType = AnomalyType.RIGHT_TAILED;\n        val trusted = true;\n\n        val params = new CusumDetectorParams()\n                .setType(anomalyType)\n                .setTargetValue(0.16)\n                .setWeakSigmas(WEAK_SIGMAS)\n                .setStrongSigmas(STRONG_SIGMAS)\n                .setSlackParam(0.5)\n                .setInitMeanEstimate(testRow0.getObserved())\n                .setWarmUpPeriod(WARMUP_PERIOD);\n\n        val detector = new CusumDetector(detectorUuid, params, trusted);\n\n        int numDataPoints = 1;\n\n        while (testRows.hasNext()) {\n            val testRow = testRows.next();\n            val observed = testRow.getObserved();\n            val metricData = new MetricData(metricDefinition, observed, epochSecond);\n            val result = (OutlierDetectorResult) detector.detect(metricData);\n            val level = result.getAnomalyLevel();\n\n            assertEquals(AnomalyLevel.valueOf(testRow.getLevel()), level);\n\n            // TODO Why not apply these assertions to all rows? [WLW]\n            if (numDataPoints >= WARMUP_PERIOD) {\n                assertApproxEqual(testRow.getSh(), detector.getSumHigh());\n                assertApproxEqual(testRow.getSl(), detector.getSumLow());\n            }\n\n            numDataPoints++;\n        }\n    }", "signature": "void testClassify_rightTailed()", "full_signature": "@Test public void testClassify_rightTailed()", "class_method_signature": "CusumDetectorTest.testClassify_rightTailed()", "testcase": true, "constructor": false, "invocations": ["listIterator", "next", "setWarmUpPeriod", "setInitMeanEstimate", "setSlackParam", "setStrongSigmas", "setWeakSigmas", "setTargetValue", "setType", "getObserved", "hasNext", "next", "getObserved", "detect", "getAnomalyLevel", "assertEquals", "valueOf", "getLevel", "assertApproxEqual", "getSh", "getSumHigh", "assertApproxEqual", "getSl", "getSumLow"]}, "focal_class": {"identifier": "CusumDetector", "superclass": "extends AbstractOutlierDetector", "interfaces": "", "fields": [{"original_string": "private static final String NAME = \"cusum\";", "modifier": "private static final", "type": "String", "declarator": "NAME = \"cusum\"", "var_name": "NAME"}, {"original_string": "private static final double STD_DEV_DIVISOR = 1.128;", "modifier": "private static final", "type": "double", "declarator": "STD_DEV_DIVISOR = 1.128", "var_name": "STD_DEV_DIVISOR"}, {"original_string": "@Getter\n    private CusumDetectorParams params;", "modifier": "@Getter\n    private", "type": "CusumDetectorParams", "declarator": "params", "var_name": "params"}, {"original_string": "@Getter\n    private boolean trusted;", "modifier": "@Getter\n    private", "type": "boolean", "declarator": "trusted", "var_name": "trusted"}, {"original_string": "private int totalDataPoints = 1;", "modifier": "private", "type": "int", "declarator": "totalDataPoints = 1", "var_name": "totalDataPoints"}, {"original_string": "@Getter\n    private double sumHigh = 0.0;", "modifier": "@Getter\n    private", "type": "double", "declarator": "sumHigh = 0.0", "var_name": "sumHigh"}, {"original_string": "@Getter\n    private double sumLow = 0.0;", "modifier": "@Getter\n    private", "type": "double", "declarator": "sumLow = 0.0", "var_name": "sumLow"}, {"original_string": "private double movingRange = 0.0;", "modifier": "private", "type": "double", "declarator": "movingRange = 0.0", "var_name": "movingRange"}, {"original_string": "private double prevValue;", "modifier": "private", "type": "double", "declarator": "prevValue", "var_name": "prevValue"}], "methods": [{"identifier": "CusumDetector", "parameters": "(UUID uuid, CusumDetectorParams params, boolean trusted)", "modifiers": "public", "return": "", "signature": " CusumDetector(UUID uuid, CusumDetectorParams params, boolean trusted)", "full_signature": "public  CusumDetector(UUID uuid, CusumDetectorParams params, boolean trusted)", "class_method_signature": "CusumDetector.CusumDetector(UUID uuid, CusumDetectorParams params, boolean trusted)", "testcase": false, "constructor": true}, {"identifier": "detect", "parameters": "(MetricData metricData)", "modifiers": "@Override public", "return": "DetectorResult", "signature": "DetectorResult detect(MetricData metricData)", "full_signature": "@Override public DetectorResult detect(MetricData metricData)", "class_method_signature": "CusumDetector.detect(MetricData metricData)", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getName()", "full_signature": "@Override public String getName()", "class_method_signature": "CusumDetector.getName()", "testcase": false, "constructor": false}, {"identifier": "resetSums", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void resetSums()", "full_signature": "private void resetSums()", "class_method_signature": "CusumDetector.resetSums()", "testcase": false, "constructor": false}, {"identifier": "avgMovingRange", "parameters": "()", "modifiers": "private", "return": "double", "signature": "double avgMovingRange()", "full_signature": "private double avgMovingRange()", "class_method_signature": "CusumDetector.avgMovingRange()", "testcase": false, "constructor": false}], "file": "anomdetect/src/main/java/com/expedia/adaptivealerting/anomdetect/detect/outlier/algo/cusum/CusumDetector.java"}, "focal_method": {"identifier": "detect", "parameters": "(MetricData metricData)", "modifiers": "@Override public", "return": "DetectorResult", "body": "@Override\n    public DetectorResult detect(MetricData metricData) {\n        AssertUtil.notNull(metricData, \"metricData can't be null\");\n\n        val params = getParams();\n        val trusted = isTrusted();\n        val observed = metricData.getValue();\n\n        this.movingRange += Math.abs(this.prevValue - observed);\n\n        val stdDev = avgMovingRange() / STD_DEV_DIVISOR;\n        val slack = params.getSlackParam() * stdDev;\n        val weakDelta = params.getWeakSigmas() * stdDev;\n        val strongDelta = params.getStrongSigmas() * stdDev;\n\n        this.sumHigh = Math.max(0, this.sumHigh + observed - (params.getTargetValue() + slack));\n        this.sumLow = Math.min(0, this.sumLow + observed - (params.getTargetValue() - slack));\n\n        this.prevValue = observed;\n\n        // FIXME This eventually overflows. Realistically it won't happen, but would be nice to fix it anyway. [WLW]\n        this.totalDataPoints++;\n\n        Double upperStrong;\n        Double upperWeak;\n        Double lowerStrong;\n        Double lowerWeak;\n        AnomalyLevel level;\n\n        if (totalDataPoints <= params.getWarmUpPeriod()) {\n            level = MODEL_WARMUP;\n        } else {\n            level = NORMAL;\n\n            upperWeak = weakDelta;\n            upperStrong = strongDelta;\n            lowerWeak = -weakDelta;\n            lowerStrong = -strongDelta;\n\n            // Below we use strict inequalities for anomaly checks instead of nonstrict.\n            // The reason is that if a metric runs at a constant value, then the stdev is\n            // 0, and another incoming metric data with the same constant value should\n            // come out as NORMAL, not STRONG. [WLW]\n\n            switch (params.getType()) {\n                case LEFT_TAILED:\n                    lowerWeak = -weakDelta;\n                    lowerStrong = -strongDelta;\n                    if (this.sumLow < lowerStrong) {\n                        level = STRONG;\n                        // TODO Check whether this is really what we are supposed to do here. [WLW]\n                        resetSums();\n                    } else if (this.sumLow < lowerWeak) {\n                        level = WEAK;\n                    }\n                    break;\n                case RIGHT_TAILED:\n                    if (this.sumHigh > upperStrong) {\n                        level = STRONG;\n                        // TODO Check whether this is really what we are supposed to do here. [WLW]\n                        resetSums();\n                    } else if (this.sumHigh > upperWeak) {\n                        level = WEAK;\n                    }\n                    break;\n                case TWO_TAILED:\n                    if (this.sumHigh > upperStrong || this.sumLow < lowerStrong) {\n                        level = STRONG;\n                        // TODO Check whether this is really what we are supposed to do here. [WLW]\n                        resetSums();\n                    } else if (this.sumHigh > upperWeak || this.sumLow < lowerWeak) {\n                        level = WEAK;\n                    }\n                    break;\n                default:\n                    throw new IllegalStateException(\"Illegal type: \" + params.getType());\n            }\n        }\n\n        return new OutlierDetectorResult(level, trusted);\n    }", "signature": "DetectorResult detect(MetricData metricData)", "full_signature": "@Override public DetectorResult detect(MetricData metricData)", "class_method_signature": "CusumDetector.detect(MetricData metricData)", "testcase": false, "constructor": false, "invocations": ["notNull", "getParams", "isTrusted", "getValue", "abs", "avgMovingRange", "getSlackParam", "getWeakSigmas", "getStrongSigmas", "max", "getTargetValue", "min", "getTargetValue", "getWarmUpPeriod", "getType", "resetSums", "resetSums", "resetSums", "getType"]}, "repository": {"repo_id": 129125498, "url": "https://github.com/ExpediaDotCom/adaptive-alerting", "stars": 104, "created": "4/11/2018 4:51:18 PM +00:00", "updates": "2020-01-24T16:20:26+00:00", "fork": "False", "license": "licensed"}}