{"test_class": {"identifier": "ContinuouslyRepeatScheduleStrategyTest", "superclass": "extends PluginsLoadingTestBase", "interfaces": "", "fields": [{"original_string": "private ISchedulerEntry entry;", "modifier": "private", "type": "ISchedulerEntry", "declarator": "entry", "var_name": "entry"}, {"original_string": "private IFieldName start;", "modifier": "private", "type": "IFieldName", "declarator": "start", "var_name": "start"}, {"original_string": "private IFieldName interval;", "modifier": "private", "type": "IFieldName", "declarator": "interval", "var_name": "interval"}], "file": "CoreFeatures/Scheduler/SchedulingStrategies/src/test/java/info/smart_tools/smartactors/scheduler/strategies/ContinuouslyRepeatScheduleStrategyTest.java"}, "test_case": {"identifier": "Should_initializeEntry", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void Should_initializeEntry()\n            throws Exception {\n        ISchedulingStrategy strategy = new ContinuouslyRepeatScheduleStrategy();\n\n        strategy.init(entry,\n                IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.iobject.IObject\"),\n                    \"{'start':'3410-01-01T00:00:01','interval':'PT24H'}\".replace('\\'','\"')));\n\n        // Happy new year to the people of 3410'th year (if you are alive) (if you still use smartactors)\n        assertEquals(\"3410-01-01T00:00:01\", entry.getState().getValue(start));\n        assertEquals(\"PT24H\", entry.getState().getValue(interval));\n\n        verify(entry).scheduleNext(LocalDateTime.parse(\"3410-01-01T00:00:01\").atZone(ZoneOffset.UTC).toInstant().toEpochMilli());\n        verify(entry).save();\n    }", "signature": "void Should_initializeEntry()", "full_signature": "@Test public void Should_initializeEntry()", "class_method_signature": "ContinuouslyRepeatScheduleStrategyTest.Should_initializeEntry()", "testcase": true, "constructor": false, "invocations": ["init", "resolve", "getOrAdd", "replace", "assertEquals", "getValue", "getState", "assertEquals", "getValue", "getState", "scheduleNext", "verify", "toEpochMilli", "toInstant", "atZone", "parse", "save", "verify"]}, "focal_class": {"identifier": "ContinuouslyRepeatScheduleStrategy", "superclass": "", "interfaces": "implements ISchedulingStrategy", "fields": [{"original_string": "private final IFieldName startFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "startFieldName", "var_name": "startFieldName"}, {"original_string": "private final IFieldName intervalFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "intervalFieldName", "var_name": "intervalFieldName"}, {"original_string": "private final IFieldName saveFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "saveFieldName", "var_name": "saveFieldName"}], "methods": [{"identifier": "nextTime", "parameters": "(final LocalDateTime startTime, final TemporalAmount period, final long now)", "modifiers": "private", "return": "long", "signature": "long nextTime(final LocalDateTime startTime, final TemporalAmount period, final long now)", "full_signature": "private long nextTime(final LocalDateTime startTime, final TemporalAmount period, final long now)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.nextTime(final LocalDateTime startTime, final TemporalAmount period, final long now)", "testcase": false, "constructor": false}, {"identifier": "datetimeToMillis", "parameters": "(final LocalDateTime localDateTime)", "modifiers": "private", "return": "long", "signature": "long datetimeToMillis(final LocalDateTime localDateTime)", "full_signature": "private long datetimeToMillis(final LocalDateTime localDateTime)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.datetimeToMillis(final LocalDateTime localDateTime)", "testcase": false, "constructor": false}, {"identifier": "millisToDatetime", "parameters": "(final long millis)", "modifiers": "private", "return": "LocalDateTime", "signature": "LocalDateTime millisToDatetime(final long millis)", "full_signature": "private LocalDateTime millisToDatetime(final long millis)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.millisToDatetime(final long millis)", "testcase": false, "constructor": false}, {"identifier": "ContinuouslyRepeatScheduleStrategy", "parameters": "()", "modifiers": "public", "return": "", "signature": " ContinuouslyRepeatScheduleStrategy()", "full_signature": "public  ContinuouslyRepeatScheduleStrategy()", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.ContinuouslyRepeatScheduleStrategy()", "testcase": false, "constructor": true}, {"identifier": "init", "parameters": "(final ISchedulerEntry entry, final IObject args)", "modifiers": "@Override public", "return": "void", "signature": "void init(final ISchedulerEntry entry, final IObject args)", "full_signature": "@Override public void init(final ISchedulerEntry entry, final IObject args)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.init(final ISchedulerEntry entry, final IObject args)", "testcase": false, "constructor": false}, {"identifier": "postProcess", "parameters": "(final ISchedulerEntry entry)", "modifiers": "@Override public", "return": "void", "signature": "void postProcess(final ISchedulerEntry entry)", "full_signature": "@Override public void postProcess(final ISchedulerEntry entry)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.postProcess(final ISchedulerEntry entry)", "testcase": false, "constructor": false}, {"identifier": "restore", "parameters": "(final ISchedulerEntry entry)", "modifiers": "@Override public", "return": "void", "signature": "void restore(final ISchedulerEntry entry)", "full_signature": "@Override public void restore(final ISchedulerEntry entry)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.restore(final ISchedulerEntry entry)", "testcase": false, "constructor": false}, {"identifier": "processException", "parameters": "(final ISchedulerEntry entry, final Throwable e)", "modifiers": "@Override public", "return": "void", "signature": "void processException(final ISchedulerEntry entry, final Throwable e)", "full_signature": "@Override public void processException(final ISchedulerEntry entry, final Throwable e)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.processException(final ISchedulerEntry entry, final Throwable e)", "testcase": false, "constructor": false}, {"identifier": "notifyPaused", "parameters": "(final ISchedulerEntry entry)", "modifiers": "@Override public", "return": "void", "signature": "void notifyPaused(final ISchedulerEntry entry)", "full_signature": "@Override public void notifyPaused(final ISchedulerEntry entry)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.notifyPaused(final ISchedulerEntry entry)", "testcase": false, "constructor": false}, {"identifier": "notifyUnPaused", "parameters": "(final ISchedulerEntry entry)", "modifiers": "@Override public", "return": "void", "signature": "void notifyUnPaused(final ISchedulerEntry entry)", "full_signature": "@Override public void notifyUnPaused(final ISchedulerEntry entry)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.notifyUnPaused(final ISchedulerEntry entry)", "testcase": false, "constructor": false}, {"identifier": "processPausedExecution", "parameters": "(final ISchedulerEntry entry)", "modifiers": "@Override public", "return": "void", "signature": "void processPausedExecution(final ISchedulerEntry entry)", "full_signature": "@Override public void processPausedExecution(final ISchedulerEntry entry)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.processPausedExecution(final ISchedulerEntry entry)", "testcase": false, "constructor": false}, {"identifier": "parseInterval", "parameters": "(final String intervalString)", "modifiers": "private", "return": "TemporalAmount", "signature": "TemporalAmount parseInterval(final String intervalString)", "full_signature": "private TemporalAmount parseInterval(final String intervalString)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.parseInterval(final String intervalString)", "testcase": false, "constructor": false}], "file": "CoreFeatures/Scheduler/SchedulingStrategies/src/main/java/info/smart_tools/smartactors/scheduler/strategies/ContinuouslyRepeatScheduleStrategy.java"}, "focal_method": {"identifier": "init", "parameters": "(final ISchedulerEntry entry, final IObject args)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void init(final ISchedulerEntry entry, final IObject args) throws SchedulingStrategyExecutionException {\n        try {\n            String start = (String) args.getValue(startFieldName);\n            LocalDateTime startTime;\n            TemporalAmount interval = parseInterval((String) args.getValue(intervalFieldName));\n            LocalDateTime now = LocalDateTime.now(ZoneOffset.UTC);\n\n            if (start == null) {\n                startTime = now;\n            } else {\n                startTime = LocalDateTime.parse(start);\n            }\n\n            entry.getState().setValue(startFieldName, startTime.toString());\n            entry.getState().setValue(intervalFieldName, interval.toString());\n\n            if (args.getValue(saveFieldName) == null || (Boolean) args.getValue(saveFieldName)) {\n                entry.save();\n            }\n\n            entry.scheduleNext(nextTime(startTime, interval, datetimeToMillis(now)));\n        } catch (ReadValueException | InvalidArgumentException | EntryScheduleException | EntryStorageAccessException\n                | ChangeValueException e) {\n            throw new SchedulingStrategyExecutionException(\"Error occurred initializing scheduler entry.\", e);\n        }\n    }", "signature": "void init(final ISchedulerEntry entry, final IObject args)", "full_signature": "@Override public void init(final ISchedulerEntry entry, final IObject args)", "class_method_signature": "ContinuouslyRepeatScheduleStrategy.init(final ISchedulerEntry entry, final IObject args)", "testcase": false, "constructor": false, "invocations": ["getValue", "parseInterval", "getValue", "now", "parse", "setValue", "getState", "toString", "setValue", "getState", "toString", "getValue", "getValue", "save", "scheduleNext", "nextTime", "datetimeToMillis"]}, "repository": {"repo_id": 52972024, "url": "https://github.com/SmartTools/smartactors-core", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 17, "size": 58816, "license": "licensed"}}