{"test_class": {"identifier": "ParallelFunctionEvaluatorTest", "superclass": "extends TestCase", "interfaces": "", "fields": [], "file": "jcool/benchmark/src/test/java/cz/cvut/felk/cig/jcool/benchmark/method/evolutionary/evaluators/ParallelFunctionEvaluatorTest.java"}, "test_case": {"identifier": "testEvaluate2", "parameters": "()", "modifiers": "@Test // test two threads public", "return": "void", "body": "@Test\n    // test two threads\n    public void testEvaluate2() throws Exception {\n        DeJongParabolaFunction function = new DeJongParabolaFunction();\n        function.setDimension(2);\n        function.setOffset(0.0);\n        function.setInverted(false);\n\n        SimpleIndividual ind1 = new SimpleIndividual(1, 0.0, new SimplePhenotypeRepresentation(new double[]{1.0, 2.0}));\n        SimpleIndividual ind2 = new SimpleIndividual(1, 0.0, new SimplePhenotypeRepresentation(new double[]{-2.0, 2.0}));\n        SimpleIndividual ind3 = new SimpleIndividual(1, 0.0, new SimplePhenotypeRepresentation(new double[]{-3.0, -2.0}));\n        SimpleIndividual ind4 = new SimpleIndividual(1, 0.0, new SimplePhenotypeRepresentation(new double[]{1.0, -3.0}));\n        ind1.setValue(0.0); ind2.setValue(0.0); ind3.setValue(0.0); ind4.setValue(0.0);\n\n        Individual[] individuals = new Individual[]{ind1, ind2, ind3, ind4};\n        Population[] populations = new Population[]{new SimplePopulation(individuals)};\n\n        ParallelFunctionEvaluator evaluator = new ParallelFunctionEvaluator(2);\n\n        evaluator.evaluate(populations, function);\n\n        assertEquals(5.0, ind1.getValue(), 0.0);\n        assertEquals(8.0, ind2.getValue(), 0.0);\n        assertEquals(13.0, ind3.getValue(), 0.0);\n        assertEquals(10.0, ind4.getValue(), 0.0);\n    }", "signature": "void testEvaluate2()", "full_signature": "@Test // test two threads public void testEvaluate2()", "class_method_signature": "ParallelFunctionEvaluatorTest.testEvaluate2()", "testcase": true, "constructor": false, "invocations": ["setDimension", "setOffset", "setInverted", "setValue", "setValue", "setValue", "setValue", "evaluate", "assertEquals", "getValue", "assertEquals", "getValue", "assertEquals", "getValue", "assertEquals", "getValue"]}, "focal_class": {"identifier": "ParallelFunctionEvaluator", "superclass": "", "interfaces": "implements FunctionEvaluator", "fields": [{"original_string": "protected CyclicBarrier barrier;", "modifier": "protected", "type": "CyclicBarrier", "declarator": "barrier", "var_name": "barrier"}, {"original_string": "protected int numProcessors;", "modifier": "protected", "type": "int", "declarator": "numProcessors", "var_name": "numProcessors"}], "methods": [{"identifier": "ParallelFunctionEvaluator", "parameters": "()", "modifiers": "public", "return": "", "signature": " ParallelFunctionEvaluator()", "full_signature": "public  ParallelFunctionEvaluator()", "class_method_signature": "ParallelFunctionEvaluator.ParallelFunctionEvaluator()", "testcase": false, "constructor": true}, {"identifier": "ParallelFunctionEvaluator", "parameters": "(int numThreads)", "modifiers": "public", "return": "", "signature": " ParallelFunctionEvaluator(int numThreads)", "full_signature": "public  ParallelFunctionEvaluator(int numThreads)", "class_method_signature": "ParallelFunctionEvaluator.ParallelFunctionEvaluator(int numThreads)", "testcase": false, "constructor": true}, {"identifier": "evaluate", "parameters": "(Population[] populations, Function function)", "modifiers": "public synchronized", "return": "void", "signature": "void evaluate(Population[] populations, Function function)", "full_signature": "public synchronized void evaluate(Population[] populations, Function function)", "class_method_signature": "ParallelFunctionEvaluator.evaluate(Population[] populations, Function function)", "testcase": false, "constructor": false}, {"identifier": "getIndexBehindIndividual", "parameters": "(Population[] populations, int individualIdx)", "modifiers": "protected", "return": "PositionDescriptor", "signature": "PositionDescriptor getIndexBehindIndividual(Population[] populations, int individualIdx)", "full_signature": "protected PositionDescriptor getIndexBehindIndividual(Population[] populations, int individualIdx)", "class_method_signature": "ParallelFunctionEvaluator.getIndexBehindIndividual(Population[] populations, int individualIdx)", "testcase": false, "constructor": false}, {"identifier": "getIndexForIndividual", "parameters": "(Population[] populations, int individualIdx)", "modifiers": "protected", "return": "PositionDescriptor", "signature": "PositionDescriptor getIndexForIndividual(Population[] populations, int individualIdx)", "full_signature": "protected PositionDescriptor getIndexForIndividual(Population[] populations, int individualIdx)", "class_method_signature": "ParallelFunctionEvaluator.getIndexForIndividual(Population[] populations, int individualIdx)", "testcase": false, "constructor": false}], "file": "jcool/benchmark/src/main/java/cz/cvut/felk/cig/jcool/benchmark/method/evolutionary/evaluators/ParallelFunctionEvaluator.java"}, "focal_method": {"identifier": "evaluate", "parameters": "(Population[] populations, Function function)", "modifiers": "public synchronized", "return": "void", "body": "public synchronized void evaluate(Population[] populations, Function function) {\n        this.barrier.reset();\n\n        int totalIndividuals = PopulationUtils.sumSizes(populations);\n        int individualsPerThread = totalIndividuals / numProcessors;\n        PositionDescriptor from = new PositionDescriptor(0, 0);\n        PositionDescriptor toExclusive;\n        if (individualsPerThread > 0){\n            int currentIndividualExclusive = individualsPerThread;\n            for (int i = 0; i < numProcessors - 1; i++){\n                toExclusive = getIndexForIndividual(populations, currentIndividualExclusive);\n                new Thread(new EvaluatorThread(this.barrier, function, populations, from, toExclusive)).start();\n\n                from = getIndexForIndividual(populations, currentIndividualExclusive);\n                currentIndividualExclusive += individualsPerThread;\n            }\n        }\n        // final worker is this thread\n        toExclusive = new PositionDescriptor(populations.length - 1, populations[populations.length-1].getIndividuals().length);\n        new EvaluatorThread(this.barrier, function, populations, from, toExclusive).run(); // except of join we rather compute\n    }", "signature": "void evaluate(Population[] populations, Function function)", "full_signature": "public synchronized void evaluate(Population[] populations, Function function)", "class_method_signature": "ParallelFunctionEvaluator.evaluate(Population[] populations, Function function)", "testcase": false, "constructor": false, "invocations": ["reset", "sumSizes", "getIndexForIndividual", "start", "getIndexForIndividual", "getIndividuals", "run"]}, "repository": {"repo_id": 3865446, "url": "https://github.com/dhonza/JCOOL", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 12, "size": 415, "license": "licensed"}}