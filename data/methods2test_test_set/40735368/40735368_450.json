{"test_class": {"identifier": "AggregatingDataStoreTest", "superclass": "extends AbstractAggregatingStoreTest", "interfaces": "", "fields": [{"original_string": "private static final String ROAD_SEGMENTS = \"RoadSegments\";", "modifier": "private static final", "type": "String", "declarator": "ROAD_SEGMENTS = \"RoadSegments\"", "var_name": "ROAD_SEGMENTS"}, {"original_string": "private static final String BASIC_POLYGONS = \"BasicPolygons\";", "modifier": "private static final", "type": "String", "declarator": "BASIC_POLYGONS = \"BasicPolygons\"", "var_name": "BASIC_POLYGONS"}, {"original_string": "AggregatingDataStore store = new AggregatingDataStore(repository,\n            Executors.newCachedThreadPool());", "modifier": "", "type": "AggregatingDataStore", "declarator": "store = new AggregatingDataStore(repository,\n            Executors.newCachedThreadPool())", "var_name": "store"}, {"original_string": "FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(null);", "modifier": "", "type": "FilterFactory2", "declarator": "ff = CommonFactoryFinder.getFilterFactory2(null)", "var_name": "ff"}], "file": "modules/unsupported/feature-aggregate/src/test/java/org/geotools/data/aggregate/AggregatingDataStoreTest.java"}, "test_case": {"identifier": "testReadSorted", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testReadSorted() throws Exception {\n        store.autoConfigureStores(Arrays.asList(\"store1\", \"store2\"));\n        Query q = new Query(BASIC_POLYGONS);\n        q.setSortBy(new SortBy[] { ff.sort(\"ID\", SortOrder.DESCENDING) });\n        List<SimpleFeature> features = listFeatures(q);\n        \n        assertEquals(4, features.size());\n        String prev = null;\n        for (SimpleFeature f : features) {\n            String id = (String) f.getAttribute(\"ID\");\n            if(prev != null) {\n                assertTrue(prev.compareTo(id) >= 0);\n            }\n            prev = id;\n        }\n    }", "signature": "void testReadSorted()", "full_signature": "@Test public void testReadSorted()", "class_method_signature": "AggregatingDataStoreTest.testReadSorted()", "testcase": true, "constructor": false, "invocations": ["autoConfigureStores", "asList", "setSortBy", "sort", "listFeatures", "assertEquals", "size", "getAttribute", "assertTrue", "compareTo"]}, "focal_class": {"identifier": "AggregatingDataStore", "superclass": "extends ContentDataStore", "interfaces": "", "fields": [{"original_string": "static final Logger LOGGER = Logging.getLogger(AggregatingDataStore.class);", "modifier": "static final", "type": "Logger", "declarator": "LOGGER = Logging.getLogger(AggregatingDataStore.class)", "var_name": "LOGGER"}, {"original_string": "Repository repository;", "modifier": "", "type": "Repository", "declarator": "repository", "var_name": "repository"}, {"original_string": "boolean tolerant;", "modifier": "", "type": "boolean", "declarator": "tolerant", "var_name": "tolerant"}, {"original_string": "Map<String, AggregateTypeConfiguration> typeMap = new LinkedHashMap<String, AggregateTypeConfiguration>();", "modifier": "", "type": "Map<String, AggregateTypeConfiguration>", "declarator": "typeMap = new LinkedHashMap<String, AggregateTypeConfiguration>()", "var_name": "typeMap"}, {"original_string": "ExecutorService executor;", "modifier": "", "type": "ExecutorService", "declarator": "executor", "var_name": "executor"}], "methods": [{"identifier": "AggregatingDataStore", "parameters": "(Repository repository, ExecutorService executor)", "modifiers": "public", "return": "", "signature": " AggregatingDataStore(Repository repository, ExecutorService executor)", "full_signature": "public  AggregatingDataStore(Repository repository, ExecutorService executor)", "class_method_signature": "AggregatingDataStore.AggregatingDataStore(Repository repository, ExecutorService executor)", "testcase": false, "constructor": true}, {"identifier": "isTolerant", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isTolerant()", "full_signature": "public boolean isTolerant()", "class_method_signature": "AggregatingDataStore.isTolerant()", "testcase": false, "constructor": false}, {"identifier": "setTolerant", "parameters": "(boolean tolerant)", "modifiers": "public", "return": "void", "signature": "void setTolerant(boolean tolerant)", "full_signature": "public void setTolerant(boolean tolerant)", "class_method_signature": "AggregatingDataStore.setTolerant(boolean tolerant)", "testcase": false, "constructor": false}, {"identifier": "createTypeNames", "parameters": "()", "modifiers": "@Override protected", "return": "List<Name>", "signature": "List<Name> createTypeNames()", "full_signature": "@Override protected List<Name> createTypeNames()", "class_method_signature": "AggregatingDataStore.createTypeNames()", "testcase": false, "constructor": false}, {"identifier": "createFeatureSource", "parameters": "(ContentEntry entry)", "modifiers": "@Override protected", "return": "ContentFeatureSource", "signature": "ContentFeatureSource createFeatureSource(ContentEntry entry)", "full_signature": "@Override protected ContentFeatureSource createFeatureSource(ContentEntry entry)", "class_method_signature": "AggregatingDataStore.createFeatureSource(ContentEntry entry)", "testcase": false, "constructor": false}, {"identifier": "autoConfigureStores", "parameters": "(List<String> storeNames)", "modifiers": "public", "return": "void", "signature": "void autoConfigureStores(List<String> storeNames)", "full_signature": "public void autoConfigureStores(List<String> storeNames)", "class_method_signature": "AggregatingDataStore.autoConfigureStores(List<String> storeNames)", "testcase": false, "constructor": false}, {"identifier": "addType", "parameters": "(AggregateTypeConfiguration config)", "modifiers": "public", "return": "void", "signature": "void addType(AggregateTypeConfiguration config)", "full_signature": "public void addType(AggregateTypeConfiguration config)", "class_method_signature": "AggregatingDataStore.addType(AggregateTypeConfiguration config)", "testcase": false, "constructor": false}, {"identifier": "getConfiguration", "parameters": "(String name)", "modifiers": "public", "return": "AggregateTypeConfiguration", "signature": "AggregateTypeConfiguration getConfiguration(String name)", "full_signature": "public AggregateTypeConfiguration getConfiguration(String name)", "class_method_signature": "AggregatingDataStore.getConfiguration(String name)", "testcase": false, "constructor": false}, {"identifier": "removeType", "parameters": "(String name)", "modifiers": "public", "return": "AggregateTypeConfiguration", "signature": "AggregateTypeConfiguration removeType(String name)", "full_signature": "public AggregateTypeConfiguration removeType(String name)", "class_method_signature": "AggregatingDataStore.removeType(String name)", "testcase": false, "constructor": false}, {"identifier": "resetConfiguration", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void resetConfiguration()", "full_signature": "public void resetConfiguration()", "class_method_signature": "AggregatingDataStore.resetConfiguration()", "testcase": false, "constructor": false}, {"identifier": "getConfigurations", "parameters": "()", "modifiers": "public", "return": "Map<String, AggregateTypeConfiguration>", "signature": "Map<String, AggregateTypeConfiguration> getConfigurations()", "full_signature": "public Map<String, AggregateTypeConfiguration> getConfigurations()", "class_method_signature": "AggregatingDataStore.getConfigurations()", "testcase": false, "constructor": false}, {"identifier": "getStore", "parameters": "(String storeName, boolean tolerant)", "modifiers": "", "return": "DataStore", "signature": "DataStore getStore(String storeName, boolean tolerant)", "full_signature": " DataStore getStore(String storeName, boolean tolerant)", "class_method_signature": "AggregatingDataStore.getStore(String storeName, boolean tolerant)", "testcase": false, "constructor": false}, {"identifier": "getStore", "parameters": "(Name name, boolean tolerant)", "modifiers": "", "return": "DataStore", "signature": "DataStore getStore(Name name, boolean tolerant)", "full_signature": " DataStore getStore(Name name, boolean tolerant)", "class_method_signature": "AggregatingDataStore.getStore(Name name, boolean tolerant)", "testcase": false, "constructor": false}, {"identifier": "submit", "parameters": "(Callable<V> callable)", "modifiers": "", "return": "Future<V>", "signature": "Future<V> submit(Callable<V> callable)", "full_signature": " Future<V> submit(Callable<V> callable)", "class_method_signature": "AggregatingDataStore.submit(Callable<V> callable)", "testcase": false, "constructor": false}], "file": "modules/unsupported/feature-aggregate/src/main/java/org/geotools/data/aggregate/AggregatingDataStore.java"}, "focal_method": {"identifier": "autoConfigureStores", "parameters": "(List<String> storeNames)", "modifiers": "public", "return": "void", "body": "public void autoConfigureStores(List<String> storeNames) throws IOException {\n        if (storeNames == null || storeNames.size() == 0) {\n            return;\n        }\n\n        // collect all type names\n        Map<String, Set<String>> allNames = new LinkedHashMap<String, Set<String>>();\n        for (String storeName : storeNames) {\n            DataStore store = getStore(storeName, tolerant);\n            if (store != null) {\n                Set<String> typeNames = new LinkedHashSet<String>(Arrays.asList(store\n                        .getTypeNames()));\n                allNames.put(storeName, typeNames);\n            } else {\n                allNames.put(storeName, (Set<String>) Collections.EMPTY_SET);\n            }\n        }\n\n        // build the feature type maps\n        for (int i = 0; i < storeNames.size(); i++) {\n            String storeName = storeNames.get(i);\n            Set<String> baseNames = allNames.get(storeName);\n            for (String baseName : baseNames) {\n                AggregateTypeConfiguration config = new AggregateTypeConfiguration(baseName);\n                config.addSourceType(storeName, baseName);\n                for (int j = i + 1; j < storeNames.size(); j++) {\n                    String otherStore = storeNames.get(j);\n                    if (allNames.get(otherStore).remove(baseName)) {\n                        config.addSourceType(otherStore, baseName);\n                    }\n                }\n\n                addType(config);\n            }\n        }\n\n    }", "signature": "void autoConfigureStores(List<String> storeNames)", "full_signature": "public void autoConfigureStores(List<String> storeNames)", "class_method_signature": "AggregatingDataStore.autoConfigureStores(List<String> storeNames)", "testcase": false, "constructor": false, "invocations": ["size", "getStore", "asList", "getTypeNames", "put", "put", "size", "get", "get", "addSourceType", "size", "get", "remove", "get", "addSourceType", "addType"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}