{"test_class": {"identifier": "AesGcmHkdfStreamingTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule public TemporaryFolder tmpFolder = new TemporaryFolder();", "modifier": "@Rule public", "type": "TemporaryFolder", "declarator": "tmpFolder = new TemporaryFolder()", "var_name": "tmpFolder"}], "file": "java_src/src/test/java/com/google/crypto/tink/subtle/AesGcmHkdfStreamingTest.java"}, "test_case": {"identifier": "testEncryptLimitedCiphertextChannel", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testEncryptLimitedCiphertextChannel() throws Exception {\n    int segmentSize = 512;\n    int firstSegmentOffset = 0;\n    int keySizeInBytes = 16;\n    byte[] ikm =\n        TestUtil.hexDecode(\"000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff\");\n    AesGcmHkdfStreaming ags =\n        new AesGcmHkdfStreaming(ikm, \"HmacSha256\", keySizeInBytes, segmentSize,\n            firstSegmentOffset);\n    int plaintextSize = 1 << 15;\n    int maxChunkSize = 100;\n    byte[] aad = TestUtil.hexDecode(\"aabbccddeeff\");\n    byte[] plaintext = StreamingTestUtil.generatePlaintext(plaintextSize);\n    int ciphertextLength = (int) ags.expectedCiphertextSize(plaintextSize);\n    ByteBuffer ciphertext = ByteBuffer.allocate(ciphertextLength);\n    WritableByteChannel ctChannel = new SeekableByteBufferChannel(ciphertext, maxChunkSize);\n    WritableByteChannel encChannel = ags.newEncryptingChannel(ctChannel, aad);\n    ByteBuffer plaintextBuffer = ByteBuffer.wrap(plaintext);\n    int loops = 0;\n    while (plaintextBuffer.remaining() > 0) {\n      encChannel.write(plaintextBuffer);\n      loops += 1;\n      if (loops > 100000) {\n        System.out.println(encChannel.toString());\n        fail(\"Too many loops\");\n      }\n    }\n    encChannel.close();\n    assertFalse(encChannel.isOpen());\n    StreamingTestUtil.isValidCiphertext(ags, plaintext, aad, ciphertext.array());\n  }", "signature": "void testEncryptLimitedCiphertextChannel()", "full_signature": "@Test public void testEncryptLimitedCiphertextChannel()", "class_method_signature": "AesGcmHkdfStreamingTest.testEncryptLimitedCiphertextChannel()", "testcase": true, "constructor": false, "invocations": ["hexDecode", "hexDecode", "generatePlaintext", "expectedCiphertextSize", "allocate", "newEncryptingChannel", "wrap", "remaining", "write", "println", "toString", "fail", "close", "assertFalse", "isOpen", "isValidCiphertext", "array"]}, "focal_class": {"identifier": "AesGcmHkdfStreaming", "superclass": "extends NonceBasedStreamingAead", "interfaces": "", "fields": [{"original_string": "private static final int NONCE_SIZE_IN_BYTES = 12;", "modifier": "private static final", "type": "int", "declarator": "NONCE_SIZE_IN_BYTES = 12", "var_name": "NONCE_SIZE_IN_BYTES"}, {"original_string": "private static final int NONCE_PREFIX_IN_BYTES = 7;", "modifier": "private static final", "type": "int", "declarator": "NONCE_PREFIX_IN_BYTES = 7", "var_name": "NONCE_PREFIX_IN_BYTES"}, {"original_string": "private static final int TAG_SIZE_IN_BYTES = 16;", "modifier": "private static final", "type": "int", "declarator": "TAG_SIZE_IN_BYTES = 16", "var_name": "TAG_SIZE_IN_BYTES"}, {"original_string": "private final int keySizeInBytes;", "modifier": "private final", "type": "int", "declarator": "keySizeInBytes", "var_name": "keySizeInBytes"}, {"original_string": "private final int ciphertextSegmentSize;", "modifier": "private final", "type": "int", "declarator": "ciphertextSegmentSize", "var_name": "ciphertextSegmentSize"}, {"original_string": "private final int plaintextSegmentSize;", "modifier": "private final", "type": "int", "declarator": "plaintextSegmentSize", "var_name": "plaintextSegmentSize"}, {"original_string": "private final int firstSegmentOffset;", "modifier": "private final", "type": "int", "declarator": "firstSegmentOffset", "var_name": "firstSegmentOffset"}, {"original_string": "private final String hkdfAlg;", "modifier": "private final", "type": "String", "declarator": "hkdfAlg", "var_name": "hkdfAlg"}, {"original_string": "private final byte[] ikm;", "modifier": "private final", "type": "byte[]", "declarator": "ikm", "var_name": "ikm"}], "methods": [{"identifier": "AesGcmHkdfStreaming", "parameters": "(byte[] ikm, String hkdfAlg, int keySizeInBytes,\n      int ciphertextSegmentSize, int firstSegmentOffset)", "modifiers": "public", "return": "", "signature": " AesGcmHkdfStreaming(byte[] ikm, String hkdfAlg, int keySizeInBytes,\n      int ciphertextSegmentSize, int firstSegmentOffset)", "full_signature": "public  AesGcmHkdfStreaming(byte[] ikm, String hkdfAlg, int keySizeInBytes,\n      int ciphertextSegmentSize, int firstSegmentOffset)", "class_method_signature": "AesGcmHkdfStreaming.AesGcmHkdfStreaming(byte[] ikm, String hkdfAlg, int keySizeInBytes,\n      int ciphertextSegmentSize, int firstSegmentOffset)", "testcase": false, "constructor": true}, {"identifier": "newStreamSegmentEncrypter", "parameters": "(byte[] aad)", "modifiers": "@Override public", "return": "AesGcmHkdfStreamEncrypter", "signature": "AesGcmHkdfStreamEncrypter newStreamSegmentEncrypter(byte[] aad)", "full_signature": "@Override public AesGcmHkdfStreamEncrypter newStreamSegmentEncrypter(byte[] aad)", "class_method_signature": "AesGcmHkdfStreaming.newStreamSegmentEncrypter(byte[] aad)", "testcase": false, "constructor": false}, {"identifier": "newStreamSegmentDecrypter", "parameters": "()", "modifiers": "@Override public", "return": "AesGcmHkdfStreamDecrypter", "signature": "AesGcmHkdfStreamDecrypter newStreamSegmentDecrypter()", "full_signature": "@Override public AesGcmHkdfStreamDecrypter newStreamSegmentDecrypter()", "class_method_signature": "AesGcmHkdfStreaming.newStreamSegmentDecrypter()", "testcase": false, "constructor": false}, {"identifier": "getPlaintextSegmentSize", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getPlaintextSegmentSize()", "full_signature": "@Override public int getPlaintextSegmentSize()", "class_method_signature": "AesGcmHkdfStreaming.getPlaintextSegmentSize()", "testcase": false, "constructor": false}, {"identifier": "getCiphertextSegmentSize", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getCiphertextSegmentSize()", "full_signature": "@Override public int getCiphertextSegmentSize()", "class_method_signature": "AesGcmHkdfStreaming.getCiphertextSegmentSize()", "testcase": false, "constructor": false}, {"identifier": "getHeaderLength", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getHeaderLength()", "full_signature": "@Override public int getHeaderLength()", "class_method_signature": "AesGcmHkdfStreaming.getHeaderLength()", "testcase": false, "constructor": false}, {"identifier": "getCiphertextOffset", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getCiphertextOffset()", "full_signature": "@Override public int getCiphertextOffset()", "class_method_signature": "AesGcmHkdfStreaming.getCiphertextOffset()", "testcase": false, "constructor": false}, {"identifier": "getCiphertextOverhead", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getCiphertextOverhead()", "full_signature": "@Override public int getCiphertextOverhead()", "class_method_signature": "AesGcmHkdfStreaming.getCiphertextOverhead()", "testcase": false, "constructor": false}, {"identifier": "getFirstSegmentOffset", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getFirstSegmentOffset()", "full_signature": "public int getFirstSegmentOffset()", "class_method_signature": "AesGcmHkdfStreaming.getFirstSegmentOffset()", "testcase": false, "constructor": false}, {"identifier": "expectedCiphertextSize", "parameters": "(long plaintextSize)", "modifiers": "public", "return": "long", "signature": "long expectedCiphertextSize(long plaintextSize)", "full_signature": "public long expectedCiphertextSize(long plaintextSize)", "class_method_signature": "AesGcmHkdfStreaming.expectedCiphertextSize(long plaintextSize)", "testcase": false, "constructor": false}, {"identifier": "cipherInstance", "parameters": "()", "modifiers": "private static", "return": "Cipher", "signature": "Cipher cipherInstance()", "full_signature": "private static Cipher cipherInstance()", "class_method_signature": "AesGcmHkdfStreaming.cipherInstance()", "testcase": false, "constructor": false}, {"identifier": "randomSalt", "parameters": "()", "modifiers": "private", "return": "byte[]", "signature": "byte[] randomSalt()", "full_signature": "private byte[] randomSalt()", "class_method_signature": "AesGcmHkdfStreaming.randomSalt()", "testcase": false, "constructor": false}, {"identifier": "paramsForSegment", "parameters": "(byte[] prefix, long segmentNr, boolean last)", "modifiers": "private static", "return": "GCMParameterSpec", "signature": "GCMParameterSpec paramsForSegment(byte[] prefix, long segmentNr, boolean last)", "full_signature": "private static GCMParameterSpec paramsForSegment(byte[] prefix, long segmentNr, boolean last)", "class_method_signature": "AesGcmHkdfStreaming.paramsForSegment(byte[] prefix, long segmentNr, boolean last)", "testcase": false, "constructor": false}, {"identifier": "randomNonce", "parameters": "()", "modifiers": "private static", "return": "byte[]", "signature": "byte[] randomNonce()", "full_signature": "private static byte[] randomNonce()", "class_method_signature": "AesGcmHkdfStreaming.randomNonce()", "testcase": false, "constructor": false}, {"identifier": "deriveKeySpec", "parameters": "(byte[] salt, byte[] aad)", "modifiers": "private", "return": "SecretKeySpec", "signature": "SecretKeySpec deriveKeySpec(byte[] salt, byte[] aad)", "full_signature": "private SecretKeySpec deriveKeySpec(byte[] salt, byte[] aad)", "class_method_signature": "AesGcmHkdfStreaming.deriveKeySpec(byte[] salt, byte[] aad)", "testcase": false, "constructor": false}], "file": "java_src/src/main/java/com/google/crypto/tink/subtle/AesGcmHkdfStreaming.java"}, "focal_method": {"identifier": "expectedCiphertextSize", "parameters": "(long plaintextSize)", "modifiers": "public", "return": "long", "body": "public long expectedCiphertextSize(long plaintextSize) {\n    long offset = getCiphertextOffset();\n    long fullSegments = (plaintextSize + offset) / plaintextSegmentSize;\n    long ciphertextSize = fullSegments * ciphertextSegmentSize;\n    long lastSegmentSize = (plaintextSize + offset) % plaintextSegmentSize;\n    if (lastSegmentSize > 0) {\n      ciphertextSize += lastSegmentSize + TAG_SIZE_IN_BYTES;\n    }\n    return ciphertextSize;\n  }", "signature": "long expectedCiphertextSize(long plaintextSize)", "full_signature": "public long expectedCiphertextSize(long plaintextSize)", "class_method_signature": "AesGcmHkdfStreaming.expectedCiphertextSize(long plaintextSize)", "testcase": false, "constructor": false, "invocations": ["getCiphertextOffset"]}, "repository": {"repo_id": 20570214, "url": "https://github.com/google/tink", "stars": 8884, "created": "6/6/2014 4:21:09 PM +00:00", "updates": "2020-01-27T11:52:16+00:00", "fork": "False", "license": "licensed"}}