{"test_class": {"identifier": "TestRfc3492Idn", "superclass": "", "interfaces": "", "fields": [], "file": "external_sources/httpclient-4.1.1/httpclient/src/test/java/org/apache/ogt/http/client/utils/TestRfc3492Idn.java"}, "test_case": {"identifier": "testDecode", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDecode() throws Exception {\n        Rfc3492Idn idn = new Rfc3492Idn();\n        // (A) Arabic\n        Assert.assertEquals(\"\\u0644\\u064A\\u0647\\u0645\\u0627\\u0628\\u062A\\u0643\\u0644\" +\n                     \"\\u0645\\u0648\\u0634\\u0639\\u0631\\u0628\\u064A\\u061F\",\n                     idn.decode(\"egbpdaj6bu4bxfgehfvwxn\"));\n\n        // (B) Chinese (simplified)\n        Assert.assertEquals(\"\\u4ED6\\u4EEC\\u4E3A\\u4EC0\\u4E48\\u4E0D\\u8BF4\\u4E2D\\u6587\",\n                     idn.decode(\"ihqwcrb4cv8a8dqg056pqjye\"));\n\n        // (I) Russian (Cyrillic)\n        Assert.assertEquals(\"\\u043F\\u043E\\u0447\\u0435\\u043C\\u0443\\u0436\\u0435\\u043E\"+\n                     \"\\u043D\\u0438\\u043D\\u0435\\u0433\\u043E\\u0432\\u043E\\u0440\"+\n                     \"\\u044F\\u0442\\u043F\\u043E\\u0440\\u0443\\u0441\\u0441\\u043A\"+\n                     \"\\u0438\",\n                     idn.decode(\"b1abfaaepdrnnbgefbaDotcwatmq2g4l\"));\n\n        // (P) Maji<de>Koi<suru>5<byou><mae>\n        Assert.assertEquals(\"\\u004D\\u0061\\u006A\\u0069\\u3067\\u004B\\u006F\\u0069\\u3059\" +\n                     \"\\u308B\\u0035\\u79D2\\u524D\",\n                     idn.decode(\"MajiKoi5-783gue6qz075azm5e\"));\n\n    }", "signature": "void testDecode()", "full_signature": "@Test public void testDecode()", "class_method_signature": "TestRfc3492Idn.testDecode()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "decode", "assertEquals", "decode", "assertEquals", "decode", "assertEquals", "decode"]}, "focal_class": {"identifier": "Rfc3492Idn", "superclass": "", "interfaces": "implements Idn", "fields": [{"original_string": "private static final int base = 36;", "modifier": "private static final", "type": "int", "declarator": "base = 36", "var_name": "base"}, {"original_string": "private static final int tmin = 1;", "modifier": "private static final", "type": "int", "declarator": "tmin = 1", "var_name": "tmin"}, {"original_string": "private static final int tmax = 26;", "modifier": "private static final", "type": "int", "declarator": "tmax = 26", "var_name": "tmax"}, {"original_string": "private static final int skew = 38;", "modifier": "private static final", "type": "int", "declarator": "skew = 38", "var_name": "skew"}, {"original_string": "private static final int damp = 700;", "modifier": "private static final", "type": "int", "declarator": "damp = 700", "var_name": "damp"}, {"original_string": "private static final int initial_bias = 72;", "modifier": "private static final", "type": "int", "declarator": "initial_bias = 72", "var_name": "initial_bias"}, {"original_string": "private static final int initial_n = 128;", "modifier": "private static final", "type": "int", "declarator": "initial_n = 128", "var_name": "initial_n"}, {"original_string": "private static final char delimiter = '-';", "modifier": "private static final", "type": "char", "declarator": "delimiter = '-'", "var_name": "delimiter"}, {"original_string": "private static final String ACE_PREFIX = \"xn--\";", "modifier": "private static final", "type": "String", "declarator": "ACE_PREFIX = \"xn--\"", "var_name": "ACE_PREFIX"}], "methods": [{"identifier": "adapt", "parameters": "(int delta, int numpoints, boolean firsttime)", "modifiers": "private", "return": "int", "signature": "int adapt(int delta, int numpoints, boolean firsttime)", "full_signature": "private int adapt(int delta, int numpoints, boolean firsttime)", "class_method_signature": "Rfc3492Idn.adapt(int delta, int numpoints, boolean firsttime)", "testcase": false, "constructor": false}, {"identifier": "digit", "parameters": "(char c)", "modifiers": "private", "return": "int", "signature": "int digit(char c)", "full_signature": "private int digit(char c)", "class_method_signature": "Rfc3492Idn.digit(char c)", "testcase": false, "constructor": false}, {"identifier": "toUnicode", "parameters": "(String punycode)", "modifiers": "public", "return": "String", "signature": "String toUnicode(String punycode)", "full_signature": "public String toUnicode(String punycode)", "class_method_signature": "Rfc3492Idn.toUnicode(String punycode)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(String input)", "modifiers": "protected", "return": "String", "signature": "String decode(String input)", "full_signature": "protected String decode(String input)", "class_method_signature": "Rfc3492Idn.decode(String input)", "testcase": false, "constructor": false}], "file": "external_sources/httpclient-4.1.1/httpclient/src/main/java/org/apache/ogt/http/client/utils/Rfc3492Idn.java"}, "focal_method": {"identifier": "decode", "parameters": "(String input)", "modifiers": "protected", "return": "String", "body": "protected String decode(String input) {\n        int n = initial_n;\n        int i = 0;\n        int bias = initial_bias;\n        StringBuilder output = new StringBuilder(input.length());\n        int lastdelim = input.lastIndexOf(delimiter);\n        if (lastdelim != -1) {\n            output.append(input.subSequence(0, lastdelim));\n            input = input.substring(lastdelim + 1);\n        }\n\n        while (input.length() > 0) {\n            int oldi = i;\n            int w = 1;\n            for (int k = base;; k += base) {\n                if (input.length() == 0) break;\n                char c = input.charAt(0);\n                input = input.substring(1);\n                int digit = digit(c);\n                i = i + digit * w; // FIXME fail on overflow\n                int t;\n                if (k <= bias + tmin) {\n                    t = tmin;\n                } else if (k >= bias + tmax) {\n                    t = tmax;\n                } else {\n                    t = k - bias;\n                }\n                if (digit < t) break;\n                w = w * (base - t); // FIXME fail on overflow\n            }\n            bias = adapt(i - oldi, output.length() + 1, (oldi == 0));\n            n = n + i / (output.length() + 1); // FIXME fail on overflow\n            i = i % (output.length() + 1);\n            // {if n is a basic code point then fail}\n            output.insert(i, (char) n);\n            i++;\n        }\n        return output.toString();\n    }", "signature": "String decode(String input)", "full_signature": "protected String decode(String input)", "class_method_signature": "Rfc3492Idn.decode(String input)", "testcase": false, "constructor": false, "invocations": ["length", "lastIndexOf", "append", "subSequence", "substring", "length", "length", "charAt", "substring", "digit", "adapt", "length", "length", "length", "insert", "toString"]}, "repository": {"repo_id": 3384018, "url": "https://github.com/f8full/open-bixi-gpstracker", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 5, "size": 2028, "license": "licensed"}}