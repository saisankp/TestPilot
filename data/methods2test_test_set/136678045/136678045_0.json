{"test_class": {"identifier": "TestLogFileHandler", "superclass": "", "interfaces": "", "fields": [{"original_string": "byte[] testUnescaped = new byte[]{0x00, 0x55, -27, 0x00, 0x56, 0x10, -128, 0x55, 0x54};", "modifier": "", "type": "byte[]", "declarator": "testUnescaped = new byte[]{0x00, 0x55, -27, 0x00, 0x56, 0x10, -128, 0x55, 0x54}", "var_name": "testUnescaped"}, {"original_string": "byte[] expectedEscaped = new byte[]{0x55, 0x00, 0x00, 0x00, 0x09, 0x00, 0x56, 0x00, -27, 0x00, 0x56, 0x01, 0x10, -128, 0x56, 0x00, 0x54};", "modifier": "", "type": "byte[]", "declarator": "expectedEscaped = new byte[]{0x55, 0x00, 0x00, 0x00, 0x09, 0x00, 0x56, 0x00, -27, 0x00, 0x56, 0x01, 0x10, -128, 0x56, 0x00, 0x54}", "var_name": "expectedEscaped"}, {"original_string": "private TestingLogFileHandler lfh;", "modifier": "private", "type": "TestingLogFileHandler", "declarator": "lfh", "var_name": "lfh"}], "file": "main/src/test/java/de/blinkt/openvpn/core/TestLogFileHandler.java"}, "test_case": {"identifier": "testWriteByteArray", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testWriteByteArray() throws IOException {\n\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n\n        lfh.setLogFile(byteArrayOutputStream);\n\n        lfh.writeEscapedBytes(testUnescaped);\n\n        byte[] result = byteArrayOutputStream.toByteArray();\n        Assert.assertTrue(Arrays.equals(expectedEscaped, result));\n    }", "signature": "void testWriteByteArray()", "full_signature": "@Test public void testWriteByteArray()", "class_method_signature": "TestLogFileHandler.testWriteByteArray()", "testcase": true, "constructor": false, "invocations": ["setLogFile", "writeEscapedBytes", "toByteArray", "assertTrue", "equals"]}, "focal_class": {"identifier": "LogFileHandler", "superclass": "extends Handler", "interfaces": "", "fields": [{"original_string": "static final int TRIM_LOG_FILE = 100;", "modifier": "static final", "type": "int", "declarator": "TRIM_LOG_FILE = 100", "var_name": "TRIM_LOG_FILE"}, {"original_string": "static final int FLUSH_TO_DISK = 101;", "modifier": "static final", "type": "int", "declarator": "FLUSH_TO_DISK = 101", "var_name": "FLUSH_TO_DISK"}, {"original_string": "static final int LOG_INIT = 102;", "modifier": "static final", "type": "int", "declarator": "LOG_INIT = 102", "var_name": "LOG_INIT"}, {"original_string": "public static final int LOG_MESSAGE = 103;", "modifier": "public static final", "type": "int", "declarator": "LOG_MESSAGE = 103", "var_name": "LOG_MESSAGE"}, {"original_string": "public static final int MAGIC_BYTE = 0x55;", "modifier": "public static final", "type": "int", "declarator": "MAGIC_BYTE = 0x55", "var_name": "MAGIC_BYTE"}, {"original_string": "protected OutputStream mLogFile;", "modifier": "protected", "type": "OutputStream", "declarator": "mLogFile", "var_name": "mLogFile"}, {"original_string": "public static final String LOGFILE_NAME = \"logcache.dat\";", "modifier": "public static final", "type": "String", "declarator": "LOGFILE_NAME = \"logcache.dat\"", "var_name": "LOGFILE_NAME"}, {"original_string": "private final static char[] hexArray = \"0123456789ABCDEF\".toCharArray();", "modifier": "private final static", "type": "char[]", "declarator": "hexArray = \"0123456789ABCDEF\".toCharArray()", "var_name": "hexArray"}], "methods": [{"identifier": "LogFileHandler", "parameters": "(Looper looper)", "modifiers": "public", "return": "", "signature": " LogFileHandler(Looper looper)", "full_signature": "public  LogFileHandler(Looper looper)", "class_method_signature": "LogFileHandler.LogFileHandler(Looper looper)", "testcase": false, "constructor": true}, {"identifier": "handleMessage", "parameters": "(Message msg)", "modifiers": "@Override public", "return": "void", "signature": "void handleMessage(Message msg)", "full_signature": "@Override public void handleMessage(Message msg)", "class_method_signature": "LogFileHandler.handleMessage(Message msg)", "testcase": false, "constructor": false}, {"identifier": "flushToDisk", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void flushToDisk()", "full_signature": "private void flushToDisk()", "class_method_signature": "LogFileHandler.flushToDisk()", "testcase": false, "constructor": false}, {"identifier": "trimLogFile", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void trimLogFile()", "full_signature": "private void trimLogFile()", "class_method_signature": "LogFileHandler.trimLogFile()", "testcase": false, "constructor": false}, {"identifier": "writeLogItemToDisk", "parameters": "(LogItem li)", "modifiers": "private", "return": "void", "signature": "void writeLogItemToDisk(LogItem li)", "full_signature": "private void writeLogItemToDisk(LogItem li)", "class_method_signature": "LogFileHandler.writeLogItemToDisk(LogItem li)", "testcase": false, "constructor": false}, {"identifier": "writeEscapedBytes", "parameters": "(byte[] bytes)", "modifiers": "public", "return": "void", "signature": "void writeEscapedBytes(byte[] bytes)", "full_signature": "public void writeEscapedBytes(byte[] bytes)", "class_method_signature": "LogFileHandler.writeEscapedBytes(byte[] bytes)", "testcase": false, "constructor": false}, {"identifier": "openLogFile", "parameters": "(File cacheDir)", "modifiers": "private", "return": "void", "signature": "void openLogFile(File cacheDir)", "full_signature": "private void openLogFile(File cacheDir)", "class_method_signature": "LogFileHandler.openLogFile(File cacheDir)", "testcase": false, "constructor": false}, {"identifier": "readLogCache", "parameters": "(File cacheDir)", "modifiers": "private", "return": "void", "signature": "void readLogCache(File cacheDir)", "full_signature": "private void readLogCache(File cacheDir)", "class_method_signature": "LogFileHandler.readLogCache(File cacheDir)", "testcase": false, "constructor": false}, {"identifier": "readCacheContents", "parameters": "(InputStream in)", "modifiers": "protected", "return": "void", "signature": "void readCacheContents(InputStream in)", "full_signature": "protected void readCacheContents(InputStream in)", "class_method_signature": "LogFileHandler.readCacheContents(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "restoreLogItem", "parameters": "(byte[] buf, int len)", "modifiers": "protected", "return": "void", "signature": "void restoreLogItem(byte[] buf, int len)", "full_signature": "protected void restoreLogItem(byte[] buf, int len)", "class_method_signature": "LogFileHandler.restoreLogItem(byte[] buf, int len)", "testcase": false, "constructor": false}, {"identifier": "bytesToHex", "parameters": "(byte[] bytes, int len)", "modifiers": "public static", "return": "String", "signature": "String bytesToHex(byte[] bytes, int len)", "full_signature": "public static String bytesToHex(byte[] bytes, int len)", "class_method_signature": "LogFileHandler.bytesToHex(byte[] bytes, int len)", "testcase": false, "constructor": false}], "file": "main/src/main/java/de/blinkt/openvpn/core/LogFileHandler.java"}, "focal_method": {"identifier": "writeEscapedBytes", "parameters": "(byte[] bytes)", "modifiers": "public", "return": "void", "body": "public void writeEscapedBytes(byte[] bytes) throws IOException {\n        int magic = 0;\n        for (byte b : bytes)\n            if (b == MAGIC_BYTE || b == MAGIC_BYTE + 1)\n                magic++;\n\n        byte eBytes[] = new byte[bytes.length + magic];\n\n        int i = 0;\n        for (byte b : bytes) {\n            if (b == MAGIC_BYTE || b == MAGIC_BYTE + 1) {\n                eBytes[i++] = MAGIC_BYTE + 1;\n                eBytes[i++] = (byte) (b - MAGIC_BYTE);\n            } else {\n                eBytes[i++] = b;\n            }\n        }\n\n        byte[] lenBytes = ByteBuffer.allocate(4).putInt(bytes.length).array();\n        synchronized (mLogFile) {\n            mLogFile.write(MAGIC_BYTE);\n            mLogFile.write(lenBytes);\n            mLogFile.write(eBytes);\n        }\n    }", "signature": "void writeEscapedBytes(byte[] bytes)", "full_signature": "public void writeEscapedBytes(byte[] bytes)", "class_method_signature": "LogFileHandler.writeEscapedBytes(byte[] bytes)", "testcase": false, "constructor": false, "invocations": ["array", "putInt", "allocate", "write", "write", "write"]}, "repository": {"repo_id": 136678045, "url": "https://github.com/jessaofraksss/OpenVPN-Connect-for-Android", "language": "Java", "is_fork": false, "fork_count": 5, "stargazer_count": 5, "size": 34560, "license": "licensed"}}