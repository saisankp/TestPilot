{"test_class": {"identifier": "HmsLocalRestServiceMgmtTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Logger logger = Logger.getLogger( HmsLocalRestServiceMgmtTest.class );", "modifier": "private static", "type": "Logger", "declarator": "logger = Logger.getLogger( HmsLocalRestServiceMgmtTest.class )", "var_name": "logger"}, {"original_string": "@InjectMocks\n    HmsLocalRestServiceMgmt hmsLocalRestServiceMgmt;", "modifier": "@InjectMocks", "type": "HmsLocalRestServiceMgmt", "declarator": "hmsLocalRestServiceMgmt", "var_name": "hmsLocalRestServiceMgmt"}, {"original_string": "@Mock\n    HMSDebuggerComponent debuggerUtil;", "modifier": "@Mock", "type": "HMSDebuggerComponent", "declarator": "debuggerUtil", "var_name": "debuggerUtil"}], "file": "modules/hms-aggregator/src/test/java/com/vmware/vrack/hms/controller/HmsLocalRestServiceMgmtTest.java"}, "test_case": {"identifier": "performLogArchivingForSwitchTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void performLogArchivingForSwitchTest()\n        throws Exception, IllegalArgumentException\n    {\n\n        // PowerMockito.method(HMSDebuggerComponent.class, parameterTypes)\n        Mockito.doReturn( \"logs archive directory\" ).when( debuggerUtil ).archiveHmsDebugLogs( anyString(), anyString(),\n                                                                                               anyString(), anyString(),\n                                                                                               anyString(), anyString(),\n                                                                                               anyString(), anyInt(),\n                                                                                               Matchers.any( EventComponent.class ) );\n\n        BaseResponse responseMock = new BaseResponse();\n        responseMock.setStatusCode( 200 );\n        responseMock.setStatusMessage( \"Hms debug logs archive will be created shortly at logs archive directory\" );\n\n        // HmsLocalRestServiceMgmt hmsLocalServerRestService = new HmsLocalRestServiceMgmt();\n        // when(debuggerUtil.archiveHmsDebugLogs(anyString(), anyString(), anyString(), anyString(), anyString(),\n        // anyString(), anyString(), anyInt(), Matchers.any(EventComponent.class))).thenReturn(\"logs archive\n        // directory\");\n        // Call to perform archiving for the switch\n        BaseResponse response = hmsLocalRestServiceMgmt.performLogArchivingForSwitch( \"S1\", \"100\", HttpMethod.PUT );\n\n        // check if the response is returned with a status code 200\n        assertNotNull( response );\n        assertEquals( response.getStatusCode(), responseMock.getStatusCode() );\n    }", "signature": "void performLogArchivingForSwitchTest()", "full_signature": "@Test public void performLogArchivingForSwitchTest()", "class_method_signature": "HmsLocalRestServiceMgmtTest.performLogArchivingForSwitchTest()", "testcase": true, "constructor": false, "invocations": ["archiveHmsDebugLogs", "when", "doReturn", "anyString", "anyString", "anyString", "anyString", "anyString", "anyString", "anyString", "anyInt", "any", "setStatusCode", "setStatusMessage", "performLogArchivingForSwitch", "assertNotNull", "assertEquals", "getStatusCode", "getStatusCode"]}, "focal_class": {"identifier": "HmsLocalRestServiceMgmt", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Logger logger = Logger.getLogger( HmsLocalRestServiceMgmt.class );", "modifier": "private static", "type": "Logger", "declarator": "logger = Logger.getLogger( HmsLocalRestServiceMgmt.class )", "var_name": "logger"}, {"original_string": "@Autowired\n    private HMSDebuggerComponent debuggerUtil;", "modifier": "@Autowired\n    private", "type": "HMSDebuggerComponent", "declarator": "debuggerUtil", "var_name": "debuggerUtil"}, {"original_string": "@Value( \"${hms.switch.host}\" )\n    private String hmsIpAddr;", "modifier": "@Value( \"${hms.switch.host}\" )\n    private", "type": "String", "declarator": "hmsIpAddr", "var_name": "hmsIpAddr"}, {"original_string": "@Value( \"${hms.switch.port}\" )\n    private int hmsPort;", "modifier": "@Value( \"${hms.switch.port}\" )\n    private", "type": "int", "declarator": "hmsPort", "var_name": "hmsPort"}, {"original_string": "@Value( \"${hms.switch.username}\" )\n    private String hmsOobUsername;", "modifier": "@Value( \"${hms.switch.username}\" )\n    private", "type": "String", "declarator": "hmsOobUsername", "var_name": "hmsOobUsername"}, {"original_string": "@Value( \"${hms.switch.password}\" )\n    private String hmsOobPassword;", "modifier": "@Value( \"${hms.switch.password}\" )\n    private", "type": "String", "declarator": "hmsOobPassword", "var_name": "hmsOobPassword"}, {"original_string": "@Value( \"${hms.log.archiver.script}\" )\n    private String hmsLogArchiverScript;", "modifier": "@Value( \"${hms.log.archiver.script}\" )\n    private", "type": "String", "declarator": "hmsLogArchiverScript", "var_name": "hmsLogArchiverScript"}, {"original_string": "@Value( \"${hms.log.archive.dir}\" )\n    private String hmsLogArchiveLocation;", "modifier": "@Value( \"${hms.log.archive.dir}\" )\n    private", "type": "String", "declarator": "hmsLogArchiveLocation", "var_name": "hmsLogArchiveLocation"}, {"original_string": "@Value( \"${hms.oob.log.location}\" )\n    private String hmsOobLogLocation;", "modifier": "@Value( \"${hms.oob.log.location}\" )\n    private", "type": "String", "declarator": "hmsOobLogLocation", "var_name": "hmsOobLogLocation"}, {"original_string": "@Value( \"${hms.ib.log.location}\" )\n    private String hmsIbLogLocation;", "modifier": "@Value( \"${hms.ib.log.location}\" )\n    private", "type": "String", "declarator": "hmsIbLogLocation", "var_name": "hmsIbLogLocation"}, {"original_string": "@Value( \"${hms.log.extract.lines:20000}\" )\n    private int hmsLogLineExtractLimit;", "modifier": "@Value( \"${hms.log.extract.lines:20000}\" )\n    private", "type": "int", "declarator": "hmsLogLineExtractLimit", "var_name": "hmsLogLineExtractLimit"}], "methods": [{"identifier": "performLogArchiving", "parameters": "( @PathVariable\n    final String host_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "modifiers": "@RequestMapping( value = \"/debug/host/{host_id}\", method = RequestMethod.PUT ) @ResponseBody public", "return": "BaseResponse", "signature": "BaseResponse performLogArchiving( @PathVariable\n    final String host_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "full_signature": "@RequestMapping( value = \"/debug/host/{host_id}\", method = RequestMethod.PUT ) @ResponseBody public BaseResponse performLogArchiving( @PathVariable\n    final String host_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "class_method_signature": "HmsLocalRestServiceMgmt.performLogArchiving( @PathVariable\n    final String host_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "testcase": false, "constructor": false}, {"identifier": "cleanUpLogs", "parameters": "( @RequestBody( required = false )\n    final String body, HttpMethod method )", "modifiers": "@RequestMapping( value = \"/debug/host\", method = RequestMethod.DELETE ) @ResponseBody public", "return": "BaseResponse", "signature": "BaseResponse cleanUpLogs( @RequestBody( required = false )\n    final String body, HttpMethod method )", "full_signature": "@RequestMapping( value = \"/debug/host\", method = RequestMethod.DELETE ) @ResponseBody public BaseResponse cleanUpLogs( @RequestBody( required = false )\n    final String body, HttpMethod method )", "class_method_signature": "HmsLocalRestServiceMgmt.cleanUpLogs( @RequestBody( required = false )\n    final String body, HttpMethod method )", "testcase": false, "constructor": false}, {"identifier": "performLogArchivingForSwitch", "parameters": "( @PathVariable\n    final String switch_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "modifiers": "@RequestMapping( value = \"/debug/switch/{switch_id}\", method = RequestMethod.PUT ) @ResponseBody public", "return": "BaseResponse", "signature": "BaseResponse performLogArchivingForSwitch( @PathVariable\n    final String switch_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "full_signature": "@RequestMapping( value = \"/debug/switch/{switch_id}\", method = RequestMethod.PUT ) @ResponseBody public BaseResponse performLogArchivingForSwitch( @PathVariable\n    final String switch_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "class_method_signature": "HmsLocalRestServiceMgmt.performLogArchivingForSwitch( @PathVariable\n    final String switch_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "testcase": false, "constructor": false}], "file": "modules/hms-aggregator/src/main/java/com/vmware/vrack/hms/controller/HmsLocalRestServiceMgmt.java"}, "focal_method": {"identifier": "performLogArchivingForSwitch", "parameters": "( @PathVariable\n    final String switch_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "modifiers": "@RequestMapping( value = \"/debug/switch/{switch_id}\", method = RequestMethod.PUT ) @ResponseBody public", "return": "BaseResponse", "body": "@RequestMapping( value = \"/debug/switch/{switch_id}\", method = RequestMethod.PUT )\n    @ResponseBody\n    public BaseResponse performLogArchivingForSwitch( @PathVariable\n    final String switch_id, @RequestBody( required = false )\n    final String body, HttpMethod method )\n        throws HMSRestException\n    {\n        BaseResponse response = new BaseResponse();\n        if ( !InventoryLoader.getInstance().getSwitchNodeMap().containsKey( switch_id ) )\n        {\n            throw new HMSRestException( Status.NOT_FOUND.getStatusCode(), \"Invalid Request\",\n                                        \"Can't find switch with id \" + switch_id );\n        }\n\n        int noOfLines = hmsLogLineExtractLimit;\n\n        if ( body != null )\n        {\n            ObjectMapper mapper = new ObjectMapper();\n            try\n            {\n                HmsLogExtractOptions options = mapper.readValue( body, HmsLogExtractOptions.class );\n                noOfLines = options.getNoOfLines();\n            }\n            catch ( Exception e )\n            {\n                logger.warn( \"Cannot find number of lines to read from node [ \" + switch_id\n                    + \" ] IB and OOB logs, in request body. So using default value [ \" + noOfLines + \" ]\" );\n            }\n        }\n        if ( noOfLines <= 500 )\n        {\n            noOfLines = hmsLogLineExtractLimit;\n        }\n        try\n        {\n            String targetArchive =\n                debuggerUtil.archiveHmsDebugLogs( switch_id, hmsIpAddr, hmsOobUsername, hmsLogArchiverScript,\n                                                  hmsLogArchiveLocation, hmsOobLogLocation, hmsIbLogLocation, noOfLines,\n                                                  EventComponent.SWITCH );\n\n            response.setStatusCode( Status.OK.getStatusCode() );\n            response.setStatusMessage( \"Hms debug logs archive will be created shortly at \" + targetArchive );\n            return response;\n        }\n        catch ( IllegalArgumentException e )\n        {\n            String err = \"Exception occured during Log archiving for node [ \" + switch_id + \" ]\";\n            String debugString =\n                String.format( \"host_id [ %s ], hmsIpAddr [ %s ], hmsOobUsername [ %s ], hmsLogArchiverScript [ %s ], hmsLogArchiveLocation [ %s ], hmsOobLogLocation [ %s ], hmsIbLogLocation [ %s ], noOfLines[ %s ]\",\n                               switch_id, hmsIpAddr, hmsOobUsername, hmsLogArchiverScript, hmsLogArchiveLocation,\n                               hmsOobLogLocation, hmsIbLogLocation, noOfLines );\n            logger.error( err + debugString );\n            response.setStatusCode( Status.INTERNAL_SERVER_ERROR.getStatusCode() );\n            response.setStatusMessage( err );\n            return response;\n        }\n\n    }", "signature": "BaseResponse performLogArchivingForSwitch( @PathVariable\n    final String switch_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "full_signature": "@RequestMapping( value = \"/debug/switch/{switch_id}\", method = RequestMethod.PUT ) @ResponseBody public BaseResponse performLogArchivingForSwitch( @PathVariable\n    final String switch_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "class_method_signature": "HmsLocalRestServiceMgmt.performLogArchivingForSwitch( @PathVariable\n    final String switch_id, @RequestBody( required = false )\n    final String body, HttpMethod method )", "testcase": false, "constructor": false, "invocations": ["containsKey", "getSwitchNodeMap", "getInstance", "getStatusCode", "readValue", "getNoOfLines", "warn", "archiveHmsDebugLogs", "setStatusCode", "getStatusCode", "setStatusMessage", "format", "error", "setStatusCode", "getStatusCode", "setStatusMessage"]}, "repository": {"repo_id": 61566208, "url": "https://github.com/vmware-archive/OHMS", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 14, "size": 16092, "license": "licensed"}}