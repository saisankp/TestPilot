{"test_class": {"identifier": "CSVSerializerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private CSVSerializer serializer;", "modifier": "private", "type": "CSVSerializer", "declarator": "serializer", "var_name": "serializer"}], "file": "dataprep-backend-service/src/test/java/org/talend/dataprep/schema/csv/CSVSerializerTest.java"}, "test_case": {"identifier": "should_use_custom_import_parameters_double_quote_escape", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void should_use_custom_import_parameters_double_quote_escape() throws Exception {\n\n        // given (text escape char is |)\n        InputStream inputStream = this.getClass().getResourceAsStream(\"tdp-4602_custom_param_csv_import.csv\");\n        DataSetMetadata datasetMetadata = getSimpleDataSetMetadata(\"column1\", \"column2\");\n        datasetMetadata.getContent().addParameter(SEPARATOR_PARAMETER, \",\");\n        datasetMetadata.getContent().addParameter(ESCAPE_CHAR, \"\\\"\");\n        datasetMetadata.getContent().addParameter(TEXT_ENCLOSURE_CHAR, \"+\");\n\n        // when\n        InputStream input = serializer.serialize(inputStream, datasetMetadata, -1);\n        String actual = IOUtils.toString(input, UTF_8);\n\n        // then\n        final String expected = IOUtils.toString(\n                this.getClass().getResourceAsStream(\"tdp-4602_custom_param_csv_import_double_quote_escape.json\"),\n                UTF_8);\n        JSONAssert.assertEquals(expected, actual, false);\n    }", "signature": "void should_use_custom_import_parameters_double_quote_escape()", "full_signature": "@Test public void should_use_custom_import_parameters_double_quote_escape()", "class_method_signature": "CSVSerializerTest.should_use_custom_import_parameters_double_quote_escape()", "testcase": true, "constructor": false, "invocations": ["getResourceAsStream", "getClass", "getSimpleDataSetMetadata", "addParameter", "getContent", "addParameter", "getContent", "addParameter", "getContent", "serialize", "toString", "toString", "getResourceAsStream", "getClass", "assertEquals"]}, "focal_class": {"identifier": "CSVSerializer", "superclass": "", "interfaces": "implements Serializer", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(CSVSerializer.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(CSVSerializer.class)", "var_name": "LOGGER"}, {"original_string": "@Value(\"${default.import.text.enclosure:\\\"}\")\n    private String defaultTextEnclosure;", "modifier": "@Value(\"${default.import.text.enclosure:\\\"}\")\n    private", "type": "String", "declarator": "defaultTextEnclosure", "var_name": "defaultTextEnclosure"}, {"original_string": "@Value(\"${default.import.text.escape:\\u0000}\")\n    private String defaultEscapeChar;", "modifier": "@Value(\"${default.import.text.escape:\\u0000}\")\n    private", "type": "String", "declarator": "defaultEscapeChar", "var_name": "defaultEscapeChar"}, {"original_string": "@Resource(name = \"serializer#csv#executor\")\n    private TaskExecutor executor;", "modifier": "@Resource(name = \"serializer#csv#executor\")\n    private", "type": "TaskExecutor", "declarator": "executor", "var_name": "executor"}], "methods": [{"identifier": "serialize", "parameters": "(InputStream rawContent, DataSetMetadata metadata, long limit)", "modifiers": "@Override public", "return": "InputStream", "signature": "InputStream serialize(InputStream rawContent, DataSetMetadata metadata, long limit)", "full_signature": "@Override public InputStream serialize(InputStream rawContent, DataSetMetadata metadata, long limit)", "class_method_signature": "CSVSerializer.serialize(InputStream rawContent, DataSetMetadata metadata, long limit)", "testcase": false, "constructor": false}, {"identifier": "getFromParameters", "parameters": "(Map<String, String> parameters, String key, String defaultValue)", "modifiers": "private", "return": "char", "signature": "char getFromParameters(Map<String, String> parameters, String key, String defaultValue)", "full_signature": "private char getFromParameters(Map<String, String> parameters, String key, String defaultValue)", "class_method_signature": "CSVSerializer.getFromParameters(Map<String, String> parameters, String key, String defaultValue)", "testcase": false, "constructor": false}, {"identifier": "writeLineContent", "parameters": "(CSVReader reader, DataSetMetadata metadata, JsonGenerator generator, String separator,\n            long limit)", "modifiers": "private", "return": "void", "signature": "void writeLineContent(CSVReader reader, DataSetMetadata metadata, JsonGenerator generator, String separator,\n            long limit)", "full_signature": "private void writeLineContent(CSVReader reader, DataSetMetadata metadata, JsonGenerator generator, String separator,\n            long limit)", "class_method_signature": "CSVSerializer.writeLineContent(CSVReader reader, DataSetMetadata metadata, JsonGenerator generator, String separator,\n            long limit)", "testcase": false, "constructor": false}, {"identifier": "withinLimit", "parameters": "(long limit, int current)", "modifiers": "private", "return": "boolean", "signature": "boolean withinLimit(long limit, int current)", "full_signature": "private boolean withinLimit(long limit, int current)", "class_method_signature": "CSVSerializer.withinLimit(long limit, int current)", "testcase": false, "constructor": false}, {"identifier": "cleanCharacters", "parameters": "(final String value)", "modifiers": "private", "return": "String", "signature": "String cleanCharacters(final String value)", "full_signature": "private String cleanCharacters(final String value)", "class_method_signature": "CSVSerializer.cleanCharacters(final String value)", "testcase": false, "constructor": false}, {"identifier": "getRemainingColumns", "parameters": "(String[] line, int start, String separator)", "modifiers": "private", "return": "String", "signature": "String getRemainingColumns(String[] line, int start, String separator)", "full_signature": "private String getRemainingColumns(String[] line, int start, String separator)", "class_method_signature": "CSVSerializer.getRemainingColumns(String[] line, int start, String separator)", "testcase": false, "constructor": false}], "file": "dataprep-backend-service/src/main/java/org/talend/dataprep/schema/csv/CSVSerializer.java"}, "focal_method": {"identifier": "serialize", "parameters": "(InputStream rawContent, DataSetMetadata metadata, long limit)", "modifiers": "@Override public", "return": "InputStream", "body": "@Override\n    public InputStream serialize(InputStream rawContent, DataSetMetadata metadata, long limit) {\n        try {\n            PipedInputStream pipe = new PipedInputStream();\n            PipedOutputStream jsonOutput = new PipedOutputStream(pipe);\n            // Serialize asynchronously for better performance (especially if caller doesn't consume all, see sampling).\n            Runnable r = () -> {\n                final Map<String, String> parameters = metadata.getContent().getParameters();\n                final String separator = parameters.get(CSVFormatFamily.SEPARATOR_PARAMETER);\n                final char actualSeparator = separator.charAt(0);\n                final char textEnclosureChar = getFromParameters(parameters, TEXT_ENCLOSURE_CHAR, defaultTextEnclosure);\n                final char escapeChar = getFromParameters(parameters, CSVFormatFamily.ESCAPE_CHAR, defaultEscapeChar);\n\n                try (InputStreamReader input = new InputStreamReader(rawContent, metadata.getEncoding());\n                        CSVReader reader = new CSVReader(input, actualSeparator, textEnclosureChar, escapeChar)) {\n\n                    JsonGenerator generator = new JsonFactory().createGenerator(jsonOutput);\n                    int i = 0;\n                    while (i++ < metadata.getContent().getNbLinesInHeader()) {\n                        reader.readNext(); // Skip all header lines\n                    }\n                    generator.writeStartArray();\n                    writeLineContent(reader, metadata, generator, separator, limit);\n                    generator.writeEndArray();\n                    generator.flush();\n                } catch (Exception e) {\n                    // Consumer may very well interrupt consumption of stream (in case of limit(n) use for sampling).\n                    // This is not an issue as consumer is allowed to partially consumes results, it's up to the\n                    // consumer to ensure data it consumed is consistent.\n                    LOGGER.debug(\"Unable to continue serialization for {}. Skipping remaining content.\",\n                            metadata.getId(), e);\n                } finally {\n                    try {\n                        jsonOutput.close();\n                    } catch (IOException e) {\n                        LOGGER.error(\"Unable to close output\", e);\n                    }\n                }\n            };\n            executor.execute(r);\n            return pipe;\n        } catch (IOException e) {\n            throw new TDPException(CommonErrorCodes.UNABLE_TO_SERIALIZE_TO_JSON, e);\n        }\n    }", "signature": "InputStream serialize(InputStream rawContent, DataSetMetadata metadata, long limit)", "full_signature": "@Override public InputStream serialize(InputStream rawContent, DataSetMetadata metadata, long limit)", "class_method_signature": "CSVSerializer.serialize(InputStream rawContent, DataSetMetadata metadata, long limit)", "testcase": false, "constructor": false, "invocations": ["getParameters", "getContent", "get", "charAt", "getFromParameters", "getFromParameters", "getEncoding", "createGenerator", "getNbLinesInHeader", "getContent", "readNext", "writeStartArray", "writeLineContent", "writeEndArray", "flush", "debug", "getId", "close", "error", "execute"]}, "repository": {"repo_id": 26644682, "url": "https://github.com/Talend/data-prep", "language": "Java", "is_fork": false, "fork_count": 29, "stargazer_count": 53, "size": 70450, "license": "licensed"}}