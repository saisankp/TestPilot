{"test_class": {"identifier": "FetcherTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ConsumerRebalanceListener listener = new NoOpConsumerRebalanceListener();", "modifier": "private", "type": "ConsumerRebalanceListener", "declarator": "listener = new NoOpConsumerRebalanceListener()", "var_name": "listener"}, {"original_string": "private String topicName = \"test\";", "modifier": "private", "type": "String", "declarator": "topicName = \"test\"", "var_name": "topicName"}, {"original_string": "private String groupId = \"test-group\";", "modifier": "private", "type": "String", "declarator": "groupId = \"test-group\"", "var_name": "groupId"}, {"original_string": "private final String metricGroup = \"consumer\" + groupId + \"-fetch-manager-metrics\";", "modifier": "private final", "type": "String", "declarator": "metricGroup = \"consumer\" + groupId + \"-fetch-manager-metrics\"", "var_name": "metricGroup"}, {"original_string": "private TopicPartition tp = new TopicPartition(topicName, 0);", "modifier": "private", "type": "TopicPartition", "declarator": "tp = new TopicPartition(topicName, 0)", "var_name": "tp"}, {"original_string": "private int minBytes = 1;", "modifier": "private", "type": "int", "declarator": "minBytes = 1", "var_name": "minBytes"}, {"original_string": "private int maxWaitMs = 0;", "modifier": "private", "type": "int", "declarator": "maxWaitMs = 0", "var_name": "maxWaitMs"}, {"original_string": "private int fetchSize = 1000;", "modifier": "private", "type": "int", "declarator": "fetchSize = 1000", "var_name": "fetchSize"}, {"original_string": "private long retryBackoffMs = 100;", "modifier": "private", "type": "long", "declarator": "retryBackoffMs = 100", "var_name": "retryBackoffMs"}, {"original_string": "private MockTime time = new MockTime(1);", "modifier": "private", "type": "MockTime", "declarator": "time = new MockTime(1)", "var_name": "time"}, {"original_string": "private MockClient client = new MockClient(time);", "modifier": "private", "type": "MockClient", "declarator": "client = new MockClient(time)", "var_name": "client"}, {"original_string": "private Metadata metadata = new Metadata(0, Long.MAX_VALUE);", "modifier": "private", "type": "Metadata", "declarator": "metadata = new Metadata(0, Long.MAX_VALUE)", "var_name": "metadata"}, {"original_string": "private Cluster cluster = TestUtils.singletonCluster(topicName, 1);", "modifier": "private", "type": "Cluster", "declarator": "cluster = TestUtils.singletonCluster(topicName, 1)", "var_name": "cluster"}, {"original_string": "private Node node = cluster.nodes().get(0);", "modifier": "private", "type": "Node", "declarator": "node = cluster.nodes().get(0)", "var_name": "node"}, {"original_string": "private SubscriptionState subscriptions = new SubscriptionState(OffsetResetStrategy.EARLIEST);", "modifier": "private", "type": "SubscriptionState", "declarator": "subscriptions = new SubscriptionState(OffsetResetStrategy.EARLIEST)", "var_name": "subscriptions"}, {"original_string": "private SubscriptionState subscriptionsNoAutoReset = new SubscriptionState(OffsetResetStrategy.NONE);", "modifier": "private", "type": "SubscriptionState", "declarator": "subscriptionsNoAutoReset = new SubscriptionState(OffsetResetStrategy.NONE)", "var_name": "subscriptionsNoAutoReset"}, {"original_string": "private Metrics metrics = new Metrics(time);", "modifier": "private", "type": "Metrics", "declarator": "metrics = new Metrics(time)", "var_name": "metrics"}, {"original_string": "private static final double EPSILON = 0.0001;", "modifier": "private static final", "type": "double", "declarator": "EPSILON = 0.0001", "var_name": "EPSILON"}, {"original_string": "private ConsumerNetworkClient consumerClient = new ConsumerNetworkClient(client, metadata, time, 100, 1000);", "modifier": "private", "type": "ConsumerNetworkClient", "declarator": "consumerClient = new ConsumerNetworkClient(client, metadata, time, 100, 1000)", "var_name": "consumerClient"}, {"original_string": "private MemoryRecords records = MemoryRecords.emptyRecords(ByteBuffer.allocate(1024), CompressionType.NONE);", "modifier": "private", "type": "MemoryRecords", "declarator": "records = MemoryRecords.emptyRecords(ByteBuffer.allocate(1024), CompressionType.NONE)", "var_name": "records"}, {"original_string": "private MemoryRecords nextRecords = MemoryRecords.emptyRecords(ByteBuffer.allocate(1024), CompressionType.NONE);", "modifier": "private", "type": "MemoryRecords", "declarator": "nextRecords = MemoryRecords.emptyRecords(ByteBuffer.allocate(1024), CompressionType.NONE)", "var_name": "nextRecords"}, {"original_string": "private Fetcher<byte[], byte[]> fetcher = createFetcher(subscriptions, metrics);", "modifier": "private", "type": "Fetcher<byte[], byte[]>", "declarator": "fetcher = createFetcher(subscriptions, metrics)", "var_name": "fetcher"}, {"original_string": "private Metrics fetcherMetrics = new Metrics(time);", "modifier": "private", "type": "Metrics", "declarator": "fetcherMetrics = new Metrics(time)", "var_name": "fetcherMetrics"}, {"original_string": "private Fetcher<byte[], byte[]> fetcherNoAutoReset = createFetcher(subscriptionsNoAutoReset, fetcherMetrics);", "modifier": "private", "type": "Fetcher<byte[], byte[]>", "declarator": "fetcherNoAutoReset = createFetcher(subscriptionsNoAutoReset, fetcherMetrics)", "var_name": "fetcherNoAutoReset"}], "file": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetcherTest.java"}, "test_case": {"identifier": "testUpdateFetchPositionResetToLatestOffset", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testUpdateFetchPositionResetToLatestOffset() {\n        subscriptions.assignFromUser(Arrays.asList(tp));\n        subscriptions.needOffsetReset(tp, OffsetResetStrategy.LATEST);\n\n        client.prepareResponse(listOffsetRequestMatcher(ListOffsetRequest.LATEST_TIMESTAMP),\n                               listOffsetResponse(Errors.NONE, Arrays.asList(5L)));\n        fetcher.updateFetchPositions(Collections.singleton(tp));\n        assertFalse(subscriptions.isOffsetResetNeeded(tp));\n        assertTrue(subscriptions.isFetchable(tp));\n        assertEquals(5, subscriptions.position(tp).longValue());\n    }", "signature": "void testUpdateFetchPositionResetToLatestOffset()", "full_signature": "@Test public void testUpdateFetchPositionResetToLatestOffset()", "class_method_signature": "FetcherTest.testUpdateFetchPositionResetToLatestOffset()", "testcase": true, "constructor": false, "invocations": ["assignFromUser", "asList", "needOffsetReset", "prepareResponse", "listOffsetRequestMatcher", "listOffsetResponse", "asList", "updateFetchPositions", "singleton", "assertFalse", "isOffsetResetNeeded", "assertTrue", "isFetchable", "assertEquals", "longValue", "position"]}, "focal_class": {"identifier": "Fetcher", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(Fetcher.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(Fetcher.class)", "var_name": "log"}, {"original_string": "private final ConsumerNetworkClient client;", "modifier": "private final", "type": "ConsumerNetworkClient", "declarator": "client", "var_name": "client"}, {"original_string": "private final Time time;", "modifier": "private final", "type": "Time", "declarator": "time", "var_name": "time"}, {"original_string": "private final int minBytes;", "modifier": "private final", "type": "int", "declarator": "minBytes", "var_name": "minBytes"}, {"original_string": "private final int maxWaitMs;", "modifier": "private final", "type": "int", "declarator": "maxWaitMs", "var_name": "maxWaitMs"}, {"original_string": "private final int fetchSize;", "modifier": "private final", "type": "int", "declarator": "fetchSize", "var_name": "fetchSize"}, {"original_string": "private final long retryBackoffMs;", "modifier": "private final", "type": "long", "declarator": "retryBackoffMs", "var_name": "retryBackoffMs"}, {"original_string": "private final int maxPollRecords;", "modifier": "private final", "type": "int", "declarator": "maxPollRecords", "var_name": "maxPollRecords"}, {"original_string": "private final boolean checkCrcs;", "modifier": "private final", "type": "boolean", "declarator": "checkCrcs", "var_name": "checkCrcs"}, {"original_string": "private final Metadata metadata;", "modifier": "private final", "type": "Metadata", "declarator": "metadata", "var_name": "metadata"}, {"original_string": "private final FetchManagerMetrics sensors;", "modifier": "private final", "type": "FetchManagerMetrics", "declarator": "sensors", "var_name": "sensors"}, {"original_string": "private final SubscriptionState subscriptions;", "modifier": "private final", "type": "SubscriptionState", "declarator": "subscriptions", "var_name": "subscriptions"}, {"original_string": "private final List<CompletedFetch> completedFetches;", "modifier": "private final", "type": "List<CompletedFetch>", "declarator": "completedFetches", "var_name": "completedFetches"}, {"original_string": "private final Deserializer<K> keyDeserializer;", "modifier": "private final", "type": "Deserializer<K>", "declarator": "keyDeserializer", "var_name": "keyDeserializer"}, {"original_string": "private final Deserializer<V> valueDeserializer;", "modifier": "private final", "type": "Deserializer<V>", "declarator": "valueDeserializer", "var_name": "valueDeserializer"}, {"original_string": "private PartitionRecords<K, V> nextInLineRecords = null;", "modifier": "private", "type": "PartitionRecords<K, V>", "declarator": "nextInLineRecords = null", "var_name": "nextInLineRecords"}], "methods": [{"identifier": "Fetcher", "parameters": "(ConsumerNetworkClient client,\n        int minBytes,\n        int maxWaitMs,\n        int fetchSize,\n        int maxPollRecords,\n        boolean checkCrcs,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer,\n        Metadata metadata,\n        SubscriptionState subscriptions,\n        Metrics metrics,\n        String metricGrpPrefix,\n        Time time,\n        long retryBackoffMs)", "modifiers": "public", "return": "", "signature": " Fetcher(ConsumerNetworkClient client,\n        int minBytes,\n        int maxWaitMs,\n        int fetchSize,\n        int maxPollRecords,\n        boolean checkCrcs,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer,\n        Metadata metadata,\n        SubscriptionState subscriptions,\n        Metrics metrics,\n        String metricGrpPrefix,\n        Time time,\n        long retryBackoffMs)", "full_signature": "public  Fetcher(ConsumerNetworkClient client,\n        int minBytes,\n        int maxWaitMs,\n        int fetchSize,\n        int maxPollRecords,\n        boolean checkCrcs,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer,\n        Metadata metadata,\n        SubscriptionState subscriptions,\n        Metrics metrics,\n        String metricGrpPrefix,\n        Time time,\n        long retryBackoffMs)", "class_method_signature": "Fetcher.Fetcher(ConsumerNetworkClient client,\n        int minBytes,\n        int maxWaitMs,\n        int fetchSize,\n        int maxPollRecords,\n        boolean checkCrcs,\n        Deserializer<K> keyDeserializer,\n        Deserializer<V> valueDeserializer,\n        Metadata metadata,\n        SubscriptionState subscriptions,\n        Metrics metrics,\n        String metricGrpPrefix,\n        Time time,\n        long retryBackoffMs)", "testcase": false, "constructor": true}, {"identifier": "sendFetches", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void sendFetches()", "full_signature": "public void sendFetches()", "class_method_signature": "Fetcher.sendFetches()", "testcase": false, "constructor": false}, {"identifier": "parseFetchedData", "parameters": "(CompletedFetch completedFetch)", "modifiers": "private", "return": "PartitionRecords<K, V>", "signature": "PartitionRecords<K, V> parseFetchedData(CompletedFetch completedFetch)", "full_signature": "private PartitionRecords<K, V> parseFetchedData(CompletedFetch completedFetch)", "class_method_signature": "Fetcher.parseFetchedData(CompletedFetch completedFetch)", "testcase": false, "constructor": false}, {"identifier": "fetchedRecords", "parameters": "()", "modifiers": "public", "return": "Map<TopicPartition, List<ConsumerRecord<K, V>>>", "signature": "Map<TopicPartition, List<ConsumerRecord<K, V>>> fetchedRecords()", "full_signature": "public Map<TopicPartition, List<ConsumerRecord<K, V>>> fetchedRecords()", "class_method_signature": "Fetcher.fetchedRecords()", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(Map<TopicPartition, List<ConsumerRecord<K, V>>> drained, PartitionRecords<K, V> partitionRecords, int maxRecords)", "modifiers": "private", "return": "int", "signature": "int append(Map<TopicPartition, List<ConsumerRecord<K, V>>> drained, PartitionRecords<K, V> partitionRecords, int maxRecords)", "full_signature": "private int append(Map<TopicPartition, List<ConsumerRecord<K, V>>> drained, PartitionRecords<K, V> partitionRecords, int maxRecords)", "class_method_signature": "Fetcher.append(Map<TopicPartition, List<ConsumerRecord<K, V>>> drained, PartitionRecords<K, V> partitionRecords, int maxRecords)", "testcase": false, "constructor": false}, {"identifier": "updateFetchPositions", "parameters": "(Set<TopicPartition> partitions)", "modifiers": "public", "return": "void", "signature": "void updateFetchPositions(Set<TopicPartition> partitions)", "full_signature": "public void updateFetchPositions(Set<TopicPartition> partitions)", "class_method_signature": "Fetcher.updateFetchPositions(Set<TopicPartition> partitions)", "testcase": false, "constructor": false}, {"identifier": "getAllTopicMetadata", "parameters": "(long timeout)", "modifiers": "public", "return": "Map<String, List<PartitionInfo>>", "signature": "Map<String, List<PartitionInfo>> getAllTopicMetadata(long timeout)", "full_signature": "public Map<String, List<PartitionInfo>> getAllTopicMetadata(long timeout)", "class_method_signature": "Fetcher.getAllTopicMetadata(long timeout)", "testcase": false, "constructor": false}, {"identifier": "getTopicMetadata", "parameters": "(MetadataRequest request, long timeout)", "modifiers": "public", "return": "Map<String, List<PartitionInfo>>", "signature": "Map<String, List<PartitionInfo>> getTopicMetadata(MetadataRequest request, long timeout)", "full_signature": "public Map<String, List<PartitionInfo>> getTopicMetadata(MetadataRequest request, long timeout)", "class_method_signature": "Fetcher.getTopicMetadata(MetadataRequest request, long timeout)", "testcase": false, "constructor": false}, {"identifier": "sendMetadataRequest", "parameters": "(MetadataRequest request)", "modifiers": "private", "return": "RequestFuture<ClientResponse>", "signature": "RequestFuture<ClientResponse> sendMetadataRequest(MetadataRequest request)", "full_signature": "private RequestFuture<ClientResponse> sendMetadataRequest(MetadataRequest request)", "class_method_signature": "Fetcher.sendMetadataRequest(MetadataRequest request)", "testcase": false, "constructor": false}, {"identifier": "resetOffset", "parameters": "(TopicPartition partition)", "modifiers": "private", "return": "void", "signature": "void resetOffset(TopicPartition partition)", "full_signature": "private void resetOffset(TopicPartition partition)", "class_method_signature": "Fetcher.resetOffset(TopicPartition partition)", "testcase": false, "constructor": false}, {"identifier": "listOffset", "parameters": "(TopicPartition partition, long timestamp)", "modifiers": "private", "return": "long", "signature": "long listOffset(TopicPartition partition, long timestamp)", "full_signature": "private long listOffset(TopicPartition partition, long timestamp)", "class_method_signature": "Fetcher.listOffset(TopicPartition partition, long timestamp)", "testcase": false, "constructor": false}, {"identifier": "sendListOffsetRequest", "parameters": "(final TopicPartition topicPartition, long timestamp)", "modifiers": "private", "return": "RequestFuture<Long>", "signature": "RequestFuture<Long> sendListOffsetRequest(final TopicPartition topicPartition, long timestamp)", "full_signature": "private RequestFuture<Long> sendListOffsetRequest(final TopicPartition topicPartition, long timestamp)", "class_method_signature": "Fetcher.sendListOffsetRequest(final TopicPartition topicPartition, long timestamp)", "testcase": false, "constructor": false}, {"identifier": "handleListOffsetResponse", "parameters": "(TopicPartition topicPartition,\n        ClientResponse clientResponse,\n        RequestFuture<Long> future)", "modifiers": "private", "return": "void", "signature": "void handleListOffsetResponse(TopicPartition topicPartition,\n        ClientResponse clientResponse,\n        RequestFuture<Long> future)", "full_signature": "private void handleListOffsetResponse(TopicPartition topicPartition,\n        ClientResponse clientResponse,\n        RequestFuture<Long> future)", "class_method_signature": "Fetcher.handleListOffsetResponse(TopicPartition topicPartition,\n        ClientResponse clientResponse,\n        RequestFuture<Long> future)", "testcase": false, "constructor": false}, {"identifier": "fetchablePartitions", "parameters": "()", "modifiers": "private", "return": "Set<TopicPartition>", "signature": "Set<TopicPartition> fetchablePartitions()", "full_signature": "private Set<TopicPartition> fetchablePartitions()", "class_method_signature": "Fetcher.fetchablePartitions()", "testcase": false, "constructor": false}, {"identifier": "createFetchRequests", "parameters": "()", "modifiers": "private", "return": "Map<Node, FetchRequest>", "signature": "Map<Node, FetchRequest> createFetchRequests()", "full_signature": "private Map<Node, FetchRequest> createFetchRequests()", "class_method_signature": "Fetcher.createFetchRequests()", "testcase": false, "constructor": false}, {"identifier": "parseRecord", "parameters": "(TopicPartition partition, LogEntry logEntry)", "modifiers": "private", "return": "ConsumerRecord<K, V>", "signature": "ConsumerRecord<K, V> parseRecord(TopicPartition partition, LogEntry logEntry)", "full_signature": "private ConsumerRecord<K, V> parseRecord(TopicPartition partition, LogEntry logEntry)", "class_method_signature": "Fetcher.parseRecord(TopicPartition partition, LogEntry logEntry)", "testcase": false, "constructor": false}], "file": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java"}, "focal_method": {"identifier": "updateFetchPositions", "parameters": "(Set<TopicPartition> partitions)", "modifiers": "public", "return": "void", "body": "public void updateFetchPositions(Set<TopicPartition> partitions) {\n        // reset the fetch position to the committed position\n        for (TopicPartition tp : partitions) {\n            if (!subscriptions.isAssigned(tp) || subscriptions.isFetchable(tp)) {// \u6ca1\u5206\u914d\u6216\u8005\u6ca1\u6682\u505c\u4e4b\u7c7b\u7684\u624d\u80fdupdate\n                continue;\n            }\n\n            // TODO: If there are several offsets to reset, we could submit offset requests in parallel\n            if (subscriptions.isOffsetResetNeeded(tp)) {// resetStrategy != null; \u91cd\u8bbe\u7b56\u7565\u4e0d\u4e3a\u7a7a\n                resetOffset(tp);\n            } else if (subscriptions.committed(tp) == null) {\n                // there's no committed position, so we need to reset with the default strategy\n                subscriptions.needOffsetReset(tp);\n                resetOffset(tp);\n            } else {\n                // \u5982\u679c\u6ca1\u6709\u91cd\u7f6e\u7b56\u7565\u5219\u7b80\u5355\u5c06commit\u8bbe\u7f6e\u4e3aoffset\n                long committed = subscriptions.committed(tp)\n                                              .offset();\n                log.debug(\"Resetting offset for partition {} to the committed offset {}\", tp, committed);\n                subscriptions.seek(tp, committed);\n            }\n        }\n    }", "signature": "void updateFetchPositions(Set<TopicPartition> partitions)", "full_signature": "public void updateFetchPositions(Set<TopicPartition> partitions)", "class_method_signature": "Fetcher.updateFetchPositions(Set<TopicPartition> partitions)", "testcase": false, "constructor": false, "invocations": ["isAssigned", "isFetchable", "isOffsetResetNeeded", "resetOffset", "committed", "needOffsetReset", "resetOffset", "offset", "committed", "debug", "seek"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}