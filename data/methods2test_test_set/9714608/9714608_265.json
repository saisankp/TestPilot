{"test_class": {"identifier": "TextUtilTest", "superclass": "extends AbstractTestCase", "interfaces": "", "fields": [], "file": "core/text/src/test/java/org/arakhne/afc/text/TextUtilTest.java"}, "test_case": {"identifier": "cutString", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void cutString() throws Exception {\n\t\tString src, res, actual;\n\t\t\n\t\tsrc = Locale.getString(\"A_SOURCE\");  //$NON-NLS-1$\n\t\tres = Locale.getString(\"A_RESULT\");  //$NON-NLS-1$\n\t\tactual = TextUtil.cutString(src, 80);\n\t\tassertNotNull(actual);\n\t\tassertEquals(res, actual, \"A:\");  //$NON-NLS-1$\n\n\t\tsrc = Locale.getString(\"B_SOURCE\");  //$NON-NLS-1$\n\t\tres = Locale.getString(\"B_RESULT\");  //$NON-NLS-1$\n\t\tactual = TextUtil.cutString(src, 80);\n\t\tassertNotNull(actual);\n\t\tassertEquals(res, actual, \"B:\");  //$NON-NLS-1$\n\n\t\tsrc = Locale.getString(\"C_SOURCE\");  //$NON-NLS-1$\n\t\tres = Locale.getString(\"C_RESULT\");  //$NON-NLS-1$\n\t\tactual = TextUtil.cutString(src, 80);\n\t\tassertNotNull(actual);\n\t\tassertEquals(res, actual, \"C:\");  //$NON-NLS-1$\n\n\t\tsrc = Locale.getString(\"D_SOURCE\");  //$NON-NLS-1$\n\t\tres = Locale.getString(\"D_RESULT\");  //$NON-NLS-1$\n\t\tactual = TextUtil.cutString(src, 80);\n\t\tassertNotNull(actual);\n\t\tassertEquals(res, actual, \"D:\");  //$NON-NLS-1$\n\t}", "signature": "void cutString()", "full_signature": "@Test public void cutString()", "class_method_signature": "TextUtilTest.cutString()", "testcase": true, "constructor": false, "invocations": ["getString", "getString", "cutString", "assertNotNull", "assertEquals", "getString", "getString", "cutString", "assertNotNull", "assertEquals", "getString", "getString", "cutString", "assertNotNull", "assertEquals", "getString", "getString", "cutString", "assertNotNull", "assertEquals"]}, "focal_class": {"identifier": "TextUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final ReentrantLock LOCK = new ReentrantLock();", "modifier": "private static final", "type": "ReentrantLock", "declarator": "LOCK = new ReentrantLock()", "var_name": "LOCK"}, {"original_string": "private static SoftReference<Map<Character, String>> accentTransTbl;", "modifier": "private static", "type": "SoftReference<Map<Character, String>>", "declarator": "accentTransTbl", "var_name": "accentTransTbl"}, {"original_string": "private static SoftReference<Map<String, Integer>> htmlToJavaTransTbl;", "modifier": "private static", "type": "SoftReference<Map<String, Integer>>", "declarator": "htmlToJavaTransTbl", "var_name": "htmlToJavaTransTbl"}, {"original_string": "private static SoftReference<Map<Character, String>> javaToHtmlTransTbl;", "modifier": "private static", "type": "SoftReference<Map<Character, String>>", "declarator": "javaToHtmlTransTbl", "var_name": "javaToHtmlTransTbl"}], "methods": [{"identifier": "TextUtil", "parameters": "()", "modifiers": "private", "return": "", "signature": " TextUtil()", "full_signature": "private  TextUtil()", "class_method_signature": "TextUtil.TextUtil()", "testcase": false, "constructor": true}, {"identifier": "equalsIgnoreCase", "parameters": "(String firstText, String secondText, boolean isNullEmptyEquivalence)", "modifiers": "@Pure public static", "return": "boolean", "signature": "boolean equalsIgnoreCase(String firstText, String secondText, boolean isNullEmptyEquivalence)", "full_signature": "@Pure public static boolean equalsIgnoreCase(String firstText, String secondText, boolean isNullEmptyEquivalence)", "class_method_signature": "TextUtil.equalsIgnoreCase(String firstText, String secondText, boolean isNullEmptyEquivalence)", "testcase": false, "constructor": false}, {"identifier": "encodeBase26", "parameters": "(int number)", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:magicnumber\") public static", "return": "String", "signature": "String encodeBase26(int number)", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:magicnumber\") public static String encodeBase26(int number)", "class_method_signature": "TextUtil.encodeBase26(int number)", "testcase": false, "constructor": false}, {"identifier": "getHtmlToJavaTranslationTable", "parameters": "()", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static", "return": "Map<String, Integer>", "signature": "Map<String, Integer> getHtmlToJavaTranslationTable()", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static Map<String, Integer> getHtmlToJavaTranslationTable()", "class_method_signature": "TextUtil.getHtmlToJavaTranslationTable()", "testcase": false, "constructor": false}, {"identifier": "getJavaToHTMLTranslationTable", "parameters": "()", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static", "return": "Map<Character, String>", "signature": "Map<Character, String> getJavaToHTMLTranslationTable()", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static Map<Character, String> getJavaToHTMLTranslationTable()", "class_method_signature": "TextUtil.getJavaToHTMLTranslationTable()", "testcase": false, "constructor": false}, {"identifier": "parseHTML", "parameters": "(String html)", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:magicnumber\") public static", "return": "String", "signature": "String parseHTML(String html)", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:magicnumber\") public static String parseHTML(String html)", "class_method_signature": "TextUtil.parseHTML(String html)", "testcase": false, "constructor": false}, {"identifier": "toHTML", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String toHTML(String text)", "full_signature": "@Pure public static String toHTML(String text)", "class_method_signature": "TextUtil.toHTML(String text)", "testcase": false, "constructor": false}, {"identifier": "cutString", "parameters": "(String text, int column)", "modifiers": "@Pure public static", "return": "String", "signature": "String cutString(String text, int column)", "full_signature": "@Pure public static String cutString(String text, int column)", "class_method_signature": "TextUtil.cutString(String text, int column)", "testcase": false, "constructor": false}, {"identifier": "cutStringAsArray", "parameters": "(String text, int column)", "modifiers": "@Pure public static", "return": "String[]", "signature": "String[] cutStringAsArray(String text, int column)", "full_signature": "@Pure public static String[] cutStringAsArray(String text, int column)", "class_method_signature": "TextUtil.cutStringAsArray(String text, int column)", "testcase": false, "constructor": false}, {"identifier": "cutStringAsArray", "parameters": "(String text, CutStringCritera critera, List<String> output)", "modifiers": "public static", "return": "void", "signature": "void cutStringAsArray(String text, CutStringCritera critera, List<String> output)", "full_signature": "public static void cutStringAsArray(String text, CutStringCritera critera, List<String> output)", "class_method_signature": "TextUtil.cutStringAsArray(String text, CutStringCritera critera, List<String> output)", "testcase": false, "constructor": false}, {"identifier": "cutStringAlgo", "parameters": "(String text, CutStringCritera critera, CutStringAlgorithm algo)", "modifiers": "private static", "return": "void", "signature": "void cutStringAlgo(String text, CutStringCritera critera, CutStringAlgorithm algo)", "full_signature": "private static void cutStringAlgo(String text, CutStringCritera critera, CutStringAlgorithm algo)", "class_method_signature": "TextUtil.cutStringAlgo(String text, CutStringCritera critera, CutStringAlgorithm algo)", "testcase": false, "constructor": false}, {"identifier": "getMnemonicChar", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "char", "signature": "char getMnemonicChar(String text)", "full_signature": "@Pure public static char getMnemonicChar(String text)", "class_method_signature": "TextUtil.getMnemonicChar(String text)", "testcase": false, "constructor": false}, {"identifier": "removeMnemonicChar", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String removeMnemonicChar(String text)", "full_signature": "@Pure public static String removeMnemonicChar(String text)", "class_method_signature": "TextUtil.removeMnemonicChar(String text)", "testcase": false, "constructor": false}, {"identifier": "getAccentTranslationTable", "parameters": "()", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static", "return": "Map<Character, String>", "signature": "Map<Character, String> getAccentTranslationTable()", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static Map<Character, String> getAccentTranslationTable()", "class_method_signature": "TextUtil.getAccentTranslationTable()", "testcase": false, "constructor": false}, {"identifier": "removeAccents", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String removeAccents(String text)", "full_signature": "@Pure public static String removeAccents(String text)", "class_method_signature": "TextUtil.removeAccents(String text)", "testcase": false, "constructor": false}, {"identifier": "removeAccents", "parameters": "(String text, Map<Character, String> map)", "modifiers": "@Pure public static", "return": "String", "signature": "String removeAccents(String text, Map<Character, String> map)", "full_signature": "@Pure public static String removeAccents(String text, Map<Character, String> map)", "class_method_signature": "TextUtil.removeAccents(String text, Map<Character, String> map)", "testcase": false, "constructor": false}, {"identifier": "splitBrackets", "parameters": "(String str)", "modifiers": "@Pure @Inline(value = \"textUtil.split('{', '}', $1)\", imported = {TextUtil.class}) public static", "return": "String[]", "signature": "String[] splitBrackets(String str)", "full_signature": "@Pure @Inline(value = \"textUtil.split('{', '}', $1)\", imported = {TextUtil.class}) public static String[] splitBrackets(String str)", "class_method_signature": "TextUtil.splitBrackets(String str)", "testcase": false, "constructor": false}, {"identifier": "split", "parameters": "(char leftSeparator, char rightSeparator, String str)", "modifiers": "@Pure public static", "return": "String[]", "signature": "String[] split(char leftSeparator, char rightSeparator, String str)", "full_signature": "@Pure public static String[] split(char leftSeparator, char rightSeparator, String str)", "class_method_signature": "TextUtil.split(char leftSeparator, char rightSeparator, String str)", "testcase": false, "constructor": false}, {"identifier": "splitBracketsAsList", "parameters": "(String str)", "modifiers": "@Pure @Inline(value = \"textUtil.splitAsList('{', '}', $1)\", imported = {TextUtil.class}) public static", "return": "List<String>", "signature": "List<String> splitBracketsAsList(String str)", "full_signature": "@Pure @Inline(value = \"textUtil.splitAsList('{', '}', $1)\", imported = {TextUtil.class}) public static List<String> splitBracketsAsList(String str)", "class_method_signature": "TextUtil.splitBracketsAsList(String str)", "testcase": false, "constructor": false}, {"identifier": "splitAsList", "parameters": "(char leftSeparator, char rightSeparator, String str)", "modifiers": "@Pure public static", "return": "List<String>", "signature": "List<String> splitAsList(char leftSeparator, char rightSeparator, String str)", "full_signature": "@Pure public static List<String> splitAsList(char leftSeparator, char rightSeparator, String str)", "class_method_signature": "TextUtil.splitAsList(char leftSeparator, char rightSeparator, String str)", "testcase": false, "constructor": false}, {"identifier": "splitSeparatorAlgorithm", "parameters": "(\n\t\t\tchar leftSeparator, char rightSeparator,\n\t\t\tString str, SplitSeparatorAlgorithm buffer)", "modifiers": "@SuppressWarnings({\"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\"}) private static", "return": "void", "signature": "void splitSeparatorAlgorithm(\n\t\t\tchar leftSeparator, char rightSeparator,\n\t\t\tString str, SplitSeparatorAlgorithm buffer)", "full_signature": "@SuppressWarnings({\"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\"}) private static void splitSeparatorAlgorithm(\n\t\t\tchar leftSeparator, char rightSeparator,\n\t\t\tString str, SplitSeparatorAlgorithm buffer)", "class_method_signature": "TextUtil.splitSeparatorAlgorithm(\n\t\t\tchar leftSeparator, char rightSeparator,\n\t\t\tString str, SplitSeparatorAlgorithm buffer)", "testcase": false, "constructor": false}, {"identifier": "splitBracketsAsUUIDs", "parameters": "(String str)", "modifiers": "@Pure @Inline(value = \"textUtil.splitAsUUIDs('{', '}', $1)\", imported = {TextUtil.class}) public static", "return": "List<UUID>", "signature": "List<UUID> splitBracketsAsUUIDs(String str)", "full_signature": "@Pure @Inline(value = \"textUtil.splitAsUUIDs('{', '}', $1)\", imported = {TextUtil.class}) public static List<UUID> splitBracketsAsUUIDs(String str)", "class_method_signature": "TextUtil.splitBracketsAsUUIDs(String str)", "testcase": false, "constructor": false}, {"identifier": "splitAsUUIDs", "parameters": "(char leftSeparator, char rightSeparator, String str)", "modifiers": "@Pure public static", "return": "List<UUID>", "signature": "List<UUID> splitAsUUIDs(char leftSeparator, char rightSeparator, String str)", "full_signature": "@Pure public static List<UUID> splitAsUUIDs(char leftSeparator, char rightSeparator, String str)", "class_method_signature": "TextUtil.splitAsUUIDs(char leftSeparator, char rightSeparator, String str)", "testcase": false, "constructor": false}, {"identifier": "mergeBrackets", "parameters": "(@SuppressWarnings(\"unchecked\") T... strs)", "modifiers": "@Pure @Inline(value = \"TextUtil.join('{', '}', $1)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String mergeBrackets(@SuppressWarnings(\"unchecked\") T... strs)", "full_signature": "@Pure @Inline(value = \"TextUtil.join('{', '}', $1)\", imported = {TextUtil.class}) public static String mergeBrackets(@SuppressWarnings(\"unchecked\") T... strs)", "class_method_signature": "TextUtil.mergeBrackets(@SuppressWarnings(\"unchecked\") T... strs)", "testcase": false, "constructor": false}, {"identifier": "mergeBrackets", "parameters": "(Iterable<?> strs)", "modifiers": "@Pure @Inline(value = \"TextUtil.join('{', '}', $1)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String mergeBrackets(Iterable<?> strs)", "full_signature": "@Pure @Inline(value = \"TextUtil.join('{', '}', $1)\", imported = {TextUtil.class}) public static String mergeBrackets(Iterable<?> strs)", "class_method_signature": "TextUtil.mergeBrackets(Iterable<?> strs)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(char leftSeparator, char rightSeparator, @SuppressWarnings(\"unchecked\") T... strs)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(char leftSeparator, char rightSeparator, @SuppressWarnings(\"unchecked\") T... strs)", "full_signature": "@Pure public static String join(char leftSeparator, char rightSeparator, @SuppressWarnings(\"unchecked\") T... strs)", "class_method_signature": "TextUtil.join(char leftSeparator, char rightSeparator, @SuppressWarnings(\"unchecked\") T... strs)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(char leftSeparator, char rightSeparator, Iterable<?> strs)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(char leftSeparator, char rightSeparator, Iterable<?> strs)", "full_signature": "@Pure public static String join(char leftSeparator, char rightSeparator, Iterable<?> strs)", "class_method_signature": "TextUtil.join(char leftSeparator, char rightSeparator, Iterable<?> strs)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, @SuppressWarnings(\"unchecked\") T... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, Arrays.asList($2))\", imported = {TextUtil.class, Arrays.class}) public static", "return": "String", "signature": "String join(String joinText, @SuppressWarnings(\"unchecked\") T... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, Arrays.asList($2))\", imported = {TextUtil.class, Arrays.class}) public static String join(String joinText, @SuppressWarnings(\"unchecked\") T... elements)", "class_method_signature": "TextUtil.join(String joinText, @SuppressWarnings(\"unchecked\") T... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, boolean... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, boolean... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, boolean... elements)", "class_method_signature": "TextUtil.join(String joinText, boolean... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, byte... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, byte... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, byte... elements)", "class_method_signature": "TextUtil.join(String joinText, byte... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, char... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, char... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, char... elements)", "class_method_signature": "TextUtil.join(String joinText, char... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, short... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, short... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, short... elements)", "class_method_signature": "TextUtil.join(String joinText, short... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, int... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, int... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, int... elements)", "class_method_signature": "TextUtil.join(String joinText, int... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, long... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, long... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, long... elements)", "class_method_signature": "TextUtil.join(String joinText, long... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, float... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, float... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, float... elements)", "class_method_signature": "TextUtil.join(String joinText, float... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, double... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, double... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, double... elements)", "class_method_signature": "TextUtil.join(String joinText, double... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, Iterable<?> elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, Iterable<?> elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, Iterable<?> elements)", "class_method_signature": "TextUtil.join(String joinText, Iterable<?> elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, @SuppressWarnings(\"unchecked\") T... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, $2, $3, Arrays.asList($4))\", imported = {TextUtil.class, Arrays.class}) public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, @SuppressWarnings(\"unchecked\") T... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, $2, $3, Arrays.asList($4))\", imported = {TextUtil.class, Arrays.class}) public static String join(String joinText, String prefix, String postfix, @SuppressWarnings(\"unchecked\") T... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, @SuppressWarnings(\"unchecked\") T... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, Iterable<?> elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, Iterable<?> elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, Iterable<?> elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, Iterable<?> elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, boolean... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, boolean... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, boolean... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, boolean... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, byte... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, byte... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, byte... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, byte... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, char... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, char... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, char... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, char... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, short... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, short... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, short... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, short... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, int... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, int... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, int... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, int... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, long... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, long... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, long... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, long... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, float... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, float... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, float... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, float... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, double... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, double... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, double... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, double... elements)", "testcase": false, "constructor": false}, {"identifier": "equalsIgnoreAccents", "parameters": "(String s1, String s2, Map<Character, String> map)", "modifiers": "@Pure @Inline(value = \"TextUtil.removeAccents($1, $3).equals(TextUtil.removeAccents($2, $3))\", imported = {TextUtil.class}) public static", "return": "boolean", "signature": "boolean equalsIgnoreAccents(String s1, String s2, Map<Character, String> map)", "full_signature": "@Pure @Inline(value = \"TextUtil.removeAccents($1, $3).equals(TextUtil.removeAccents($2, $3))\", imported = {TextUtil.class}) public static boolean equalsIgnoreAccents(String s1, String s2, Map<Character, String> map)", "class_method_signature": "TextUtil.equalsIgnoreAccents(String s1, String s2, Map<Character, String> map)", "testcase": false, "constructor": false}, {"identifier": "equalsIgnoreCaseAccents", "parameters": "(String s1, String s2, Map<Character, String> map)", "modifiers": "@Pure @Inline(value = \"TextUtil.removeAccents($1, $3).equalsIgnoreCase(TextUtil.removeAccents($2, $3))\", imported = {TextUtil.class}) public static", "return": "boolean", "signature": "boolean equalsIgnoreCaseAccents(String s1, String s2, Map<Character, String> map)", "full_signature": "@Pure @Inline(value = \"TextUtil.removeAccents($1, $3).equalsIgnoreCase(TextUtil.removeAccents($2, $3))\", imported = {TextUtil.class}) public static boolean equalsIgnoreCaseAccents(String s1, String s2, Map<Character, String> map)", "class_method_signature": "TextUtil.equalsIgnoreCaseAccents(String s1, String s2, Map<Character, String> map)", "testcase": false, "constructor": false}, {"identifier": "toLowerCaseWithoutAccent", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String toLowerCaseWithoutAccent(String text)", "full_signature": "@Pure public static String toLowerCaseWithoutAccent(String text)", "class_method_signature": "TextUtil.toLowerCaseWithoutAccent(String text)", "testcase": false, "constructor": false}, {"identifier": "toLowerCaseWithoutAccent", "parameters": "(String text, Map<Character, String> map)", "modifiers": "@Pure public static", "return": "String", "signature": "String toLowerCaseWithoutAccent(String text, Map<Character, String> map)", "full_signature": "@Pure public static String toLowerCaseWithoutAccent(String text, Map<Character, String> map)", "class_method_signature": "TextUtil.toLowerCaseWithoutAccent(String text, Map<Character, String> map)", "testcase": false, "constructor": false}, {"identifier": "toUpperCaseWithoutAccent", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String toUpperCaseWithoutAccent(String text)", "full_signature": "@Pure public static String toUpperCaseWithoutAccent(String text)", "class_method_signature": "TextUtil.toUpperCaseWithoutAccent(String text)", "testcase": false, "constructor": false}, {"identifier": "toUpperCaseWithoutAccent", "parameters": "(String text, Map<Character, String> map)", "modifiers": "@Pure public static", "return": "String", "signature": "String toUpperCaseWithoutAccent(String text, Map<Character, String> map)", "full_signature": "@Pure public static String toUpperCaseWithoutAccent(String text, Map<Character, String> map)", "class_method_signature": "TextUtil.toUpperCaseWithoutAccent(String text, Map<Character, String> map)", "testcase": false, "constructor": false}, {"identifier": "formatTime", "parameters": "(double amount, TimeUnit unit)", "modifiers": "@Pure @SuppressWarnings({\"checkstyle:magicnumber\", \"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\"}) public static", "return": "String", "signature": "String formatTime(double amount, TimeUnit unit)", "full_signature": "@Pure @SuppressWarnings({\"checkstyle:magicnumber\", \"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\"}) public static String formatTime(double amount, TimeUnit unit)", "class_method_signature": "TextUtil.formatTime(double amount, TimeUnit unit)", "testcase": false, "constructor": false}, {"identifier": "formatHex", "parameters": "(int amount, int digits)", "modifiers": "@Pure @Inline(value = \"$3.formatHex($1, $2)\", imported = {StringEscaper.class}) public static", "return": "String", "signature": "String formatHex(int amount, int digits)", "full_signature": "@Pure @Inline(value = \"$3.formatHex($1, $2)\", imported = {StringEscaper.class}) public static String formatHex(int amount, int digits)", "class_method_signature": "TextUtil.formatHex(int amount, int digits)", "testcase": false, "constructor": false}, {"identifier": "formatDouble", "parameters": "(double amount, int decimalCount)", "modifiers": "@Pure public static", "return": "String", "signature": "String formatDouble(double amount, int decimalCount)", "full_signature": "@Pure public static String formatDouble(double amount, int decimalCount)", "class_method_signature": "TextUtil.formatDouble(double amount, int decimalCount)", "testcase": false, "constructor": false}, {"identifier": "formatFloat", "parameters": "(float amount, int decimalCount)", "modifiers": "@Pure public static", "return": "String", "signature": "String formatFloat(float amount, int decimalCount)", "full_signature": "@Pure public static String formatFloat(float amount, int decimalCount)", "class_method_signature": "TextUtil.formatFloat(float amount, int decimalCount)", "testcase": false, "constructor": false}, {"identifier": "getLevenshteinDistance", "parameters": "(String firstString, String secondString)", "modifiers": "public static", "return": "int", "signature": "int getLevenshteinDistance(String firstString, String secondString)", "full_signature": "public static int getLevenshteinDistance(String firstString, String secondString)", "class_method_signature": "TextUtil.getLevenshteinDistance(String firstString, String secondString)", "testcase": false, "constructor": false}, {"identifier": "toJavaString", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String toJavaString(String text)", "full_signature": "@Pure public static String toJavaString(String text)", "class_method_signature": "TextUtil.toJavaString(String text)", "testcase": false, "constructor": false}, {"identifier": "toJsonString", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String toJsonString(String text)", "full_signature": "@Pure public static String toJsonString(String text)", "class_method_signature": "TextUtil.toJsonString(String text)", "testcase": false, "constructor": false}], "file": "core/text/src/main/java/org/arakhne/afc/text/TextUtil.java"}, "focal_method": {"identifier": "cutString", "parameters": "(String text, int column)", "modifiers": "@Pure public static", "return": "String", "body": "@Pure\n\tpublic static String cutString(String text, int column) {\n\t\tfinal StringBuilder buffer = new StringBuilder();\n\t\tcutStringAlgo(text, new CutStringColumnCritera(column), new CutStringToString(buffer));\n\t\treturn buffer.toString();\n\t}", "signature": "String cutString(String text, int column)", "full_signature": "@Pure public static String cutString(String text, int column)", "class_method_signature": "TextUtil.cutString(String text, int column)", "testcase": false, "constructor": false, "invocations": ["cutStringAlgo", "toString"]}, "repository": {"repo_id": 9714608, "url": "https://github.com/gallandarakhneorg/afc", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 12, "size": 19091, "license": "licensed"}}