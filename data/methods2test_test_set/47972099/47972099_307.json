{"test_class": {"identifier": "SocketTextStreamFunctionTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String LOCALHOST = \"127.0.0.1\";", "modifier": "private static final", "type": "String", "declarator": "LOCALHOST = \"127.0.0.1\"", "var_name": "LOCALHOST"}], "file": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/functions/source/SocketTextStreamFunctionTest.java"}, "test_case": {"identifier": "testSocketSourceOutputWithRetries", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testSocketSourceOutputWithRetries() throws Exception {\n\t\tServerSocket server = new ServerSocket(0);\n\t\tSocket channel = null;\n\n\t\ttry {\n\t\t\tSocketTextStreamFunction source = new SocketTextStreamFunction(LOCALHOST, server.getLocalPort(), '\\n', 10, 100);\n\n\t\t\tSocketSourceThread runner = new SocketSourceThread(source, \"test1\", \"check\");\n\t\t\trunner.start();\n\n\t\t\t// first connection: nothing\n\t\t\tchannel = server.accept();\n\t\t\tchannel.close();\n\n\t\t\t// second connection: first string\n\t\t\tchannel = server.accept();\n\t\t\tOutputStreamWriter writer = new OutputStreamWriter(channel.getOutputStream());\n\t\t\twriter.write(\"test1\\n\");\n\t\t\twriter.close();\n\t\t\tchannel.close();\n\n\t\t\t// third connection: nothing\n\t\t\tchannel = server.accept();\n\t\t\tchannel.close();\n\n\t\t\t// forth connection: second string\n\t\t\tchannel = server.accept();\n\t\t\twriter = new OutputStreamWriter(channel.getOutputStream());\n\t\t\twriter.write(\"check\\n\");\n\t\t\twriter.flush();\n\n\t\t\trunner.waitForNumElements(2);\n\t\t\trunner.cancel();\n\t\t\trunner.waitUntilDone();\n\t\t}\n\t\tfinally {\n\t\t\tif (channel != null) {\n\t\t\t\tIOUtils.closeQuietly(channel);\n\t\t\t}\n\t\t\tIOUtils.closeQuietly(server);\n\t\t}\n\t}", "signature": "void testSocketSourceOutputWithRetries()", "full_signature": "@Test public void testSocketSourceOutputWithRetries()", "class_method_signature": "SocketTextStreamFunctionTest.testSocketSourceOutputWithRetries()", "testcase": true, "constructor": false, "invocations": ["getLocalPort", "start", "accept", "close", "accept", "getOutputStream", "write", "close", "close", "accept", "close", "accept", "getOutputStream", "write", "flush", "waitForNumElements", "cancel", "waitUntilDone", "closeQuietly", "closeQuietly"]}, "focal_class": {"identifier": "SocketTextStreamFunction", "superclass": "", "interfaces": "implements SourceFunction<String>", "fields": [{"original_string": "private static final long serialVersionUID = 1L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 1L", "var_name": "serialVersionUID"}, {"original_string": "private static final Logger LOG = LoggerFactory.getLogger(SocketTextStreamFunction.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(SocketTextStreamFunction.class)", "var_name": "LOG"}, {"original_string": "private static final int DEFAULT_CONNECTION_RETRY_SLEEP = 500;", "modifier": "private static final", "type": "int", "declarator": "DEFAULT_CONNECTION_RETRY_SLEEP = 500", "var_name": "DEFAULT_CONNECTION_RETRY_SLEEP"}, {"original_string": "private static final int CONNECTION_TIMEOUT_TIME = 0;", "modifier": "private static final", "type": "int", "declarator": "CONNECTION_TIMEOUT_TIME = 0", "var_name": "CONNECTION_TIMEOUT_TIME"}, {"original_string": "private final String hostname;", "modifier": "private final", "type": "String", "declarator": "hostname", "var_name": "hostname"}, {"original_string": "private final int port;", "modifier": "private final", "type": "int", "declarator": "port", "var_name": "port"}, {"original_string": "private final char delimiter;", "modifier": "private final", "type": "char", "declarator": "delimiter", "var_name": "delimiter"}, {"original_string": "private final long maxNumRetries;", "modifier": "private final", "type": "long", "declarator": "maxNumRetries", "var_name": "maxNumRetries"}, {"original_string": "private final long delayBetweenRetries;", "modifier": "private final", "type": "long", "declarator": "delayBetweenRetries", "var_name": "delayBetweenRetries"}, {"original_string": "private transient Socket currentSocket;", "modifier": "private transient", "type": "Socket", "declarator": "currentSocket", "var_name": "currentSocket"}, {"original_string": "private volatile boolean isRunning = true;", "modifier": "private volatile", "type": "boolean", "declarator": "isRunning = true", "var_name": "isRunning"}], "methods": [{"identifier": "SocketTextStreamFunction", "parameters": "(String hostname, int port, char delimiter, long maxNumRetries)", "modifiers": "public", "return": "", "signature": " SocketTextStreamFunction(String hostname, int port, char delimiter, long maxNumRetries)", "full_signature": "public  SocketTextStreamFunction(String hostname, int port, char delimiter, long maxNumRetries)", "class_method_signature": "SocketTextStreamFunction.SocketTextStreamFunction(String hostname, int port, char delimiter, long maxNumRetries)", "testcase": false, "constructor": true}, {"identifier": "SocketTextStreamFunction", "parameters": "(String hostname, int port, char delimiter, long maxNumRetries, long delayBetweenRetries)", "modifiers": "public", "return": "", "signature": " SocketTextStreamFunction(String hostname, int port, char delimiter, long maxNumRetries, long delayBetweenRetries)", "full_signature": "public  SocketTextStreamFunction(String hostname, int port, char delimiter, long maxNumRetries, long delayBetweenRetries)", "class_method_signature": "SocketTextStreamFunction.SocketTextStreamFunction(String hostname, int port, char delimiter, long maxNumRetries, long delayBetweenRetries)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "(SourceContext<String> ctx)", "modifiers": "@Override public", "return": "void", "signature": "void run(SourceContext<String> ctx)", "full_signature": "@Override public void run(SourceContext<String> ctx)", "class_method_signature": "SocketTextStreamFunction.run(SourceContext<String> ctx)", "testcase": false, "constructor": false}, {"identifier": "cancel", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void cancel()", "full_signature": "@Override public void cancel()", "class_method_signature": "SocketTextStreamFunction.cancel()", "testcase": false, "constructor": false}], "file": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/SocketTextStreamFunction.java"}, "focal_method": {"identifier": "cancel", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void cancel() {\n\t\tisRunning = false;\n\t\t\n\t\t// we need to close the socket as well, because the Thread.interrupt() function will\n\t\t// not wake the thread in the socketStream.read() method when blocked.\n\t\tSocket theSocket = this.currentSocket;\n\t\tif (theSocket != null) {\n\t\t\tIOUtils.closeSocket(theSocket);\n\t\t}\n\t}", "signature": "void cancel()", "full_signature": "@Override public void cancel()", "class_method_signature": "SocketTextStreamFunction.cancel()", "testcase": false, "constructor": false, "invocations": ["closeSocket"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}