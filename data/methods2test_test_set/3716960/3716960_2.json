{"test_class": {"identifier": "DijkstraTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static HierarchyMapGraph test3;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "test3", "var_name": "test3"}, {"original_string": "private static HierarchyMapGraph test5;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "test5", "var_name": "test5"}, {"original_string": "private static HierarchyMapGraph test8;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "test8", "var_name": "test8"}, {"original_string": "private static HierarchyMapGraph testGraph1;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph1", "var_name": "testGraph1"}, {"original_string": "private static HierarchyMapGraph testGraph2;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph2", "var_name": "testGraph2"}, {"original_string": "private static HierarchyMapGraph testGraph3;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph3", "var_name": "testGraph3"}, {"original_string": "private static HierarchyMapGraph testGraph4;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph4", "var_name": "testGraph4"}, {"original_string": "private static boolean fastBackup;", "modifier": "private static", "type": "boolean", "declarator": "fastBackup", "var_name": "fastBackup"}], "file": "SoftwarePraktikum/src/algorithmen/DijkstraTest.java"}, "test_case": {"identifier": "testBidirectional", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testBidirectional() throws Exception {\n\t\t\n\t\tConfig.fastestPathMode = false;\n\t\t\n\t\t//boolean fehler = false;\n\t\tArrayList<MapNode> liste = null;\n\t\tMapGraph graph = null;\n\t\tString test;\n\t\t\n\t\t/*\n\t\t * Test 1 \n\t\t * Teste auf einem leeren Graphen - erwarte eine leere Liste\n\t\t */\n\t\t\n\t\t\n\t\ttry {\n\t\t\tliste = Dijkstra.bidirectional(new MapGraph(new GPSCoordinate(50,-50),new GPSCoordinate(-50,50)), 5, 6);\n\t\t} catch (Exception e) {\n\t\t\tfail(\"Auf einem leeren Graohen wurde keine Exception geworfen\");\n\t\t}\n\t\t\t\n\t\t/*\n\t\tif (liste.size() != 0)\n\t\t\tfail(\"Die Ausgabe auf einem leeren Graphen sollte leer sein. Stattdessen gibt es so viele Elemente: \"+liste.size());\n\t\t*/\n\t\t\n\t\t/*\n\t\t * Test 2\n\t\t * Teste mit nciht-existerenden End-Knoten - erwarte eine leere Liste\n\t\t */\n\t\t\t\n\t\tgraph = randomGraph(50,0.3f,3);\n\t\t\t\n\t\t//fehler = false;\n\t\ttry {\n\t\t\tliste = Dijkstra.bidirectional(graph, 5, 100);\n\t\t} catch (Exception e) {\n\t\t\tfail(\"Bei nicht-existierendem Endknoten wurde eine Exception geworfen, statt einer leeren Liste auszugeben: \"+e.getLocalizedMessage());\n\t\t}\n\t\tif (liste.size() != 0)\n\t\t\tfail(\"Die Ausgabe ohne existerenden Endknoten sollte leer sein. Stattdessen gibt es so viele Elemente: \"+liste.size());\n\t\t\t\n\t\t\n\t\t\n\t\t/*\n\t\t * Test 3\n\t\t * Teste mit unerrecihbaren End-Knoten - erwarte leere Liste\n\t\t */\n\t\t\n\t\t\n\t\tgraph.insertNode(10001, new GPSCoordinate(0,0));\n\t\ttry {\n\t\t\tliste = Dijkstra.bidirectional(graph, 5, 10001);\n\t\t} catch (Exception e) {\n\t\t\tfail(\"Bei nicht-erreichbaren Endknoten wurde eine Exception geworfen, statt einer leeren Liste auszugeben: \"+e.getLocalizedMessage());\n\t\t}\n\t\tif (liste.size() != 0)\n\t\t\tfail(\"Die Ausgabe sollte leer sein. Stattdessen gibt es so viele Elemente: \"+liste.size());\n\t\t\t\n\t\t\n\t\t/*\n\t\t * Test 4\n\t\t * Teste mit gleichen start-/End-Knoten - erwarte leere Liste\n\t\t */\n\t\t\t\n\t\ttry {\n\t\t\tliste = Dijkstra.bidirectional(graph, 5, 5);\n\t\t} catch (Exception e) {\n\t\t\tfail(\"Bei nicht-existierendem Endknoten wurde eine Exception geworfen, statt einer leeren Liste auszugeben: \"+e.getLocalizedMessage());\n\t\t}\n\t\tif (liste.size() != 0)\n\t\t\tfail(\"Die Ausgabe auf start=Ende sollte leer sein. Stattdessen gibt es so viele Elemente: \"+liste.size());\n\t\t\t\n\t\t\n\t\t\n\t\t/*\n\t\t * Test 5\n\t\t * Test mit wohldefiniertem Graphen die korrekten Entfernungen\n\t\t * Test zunaechst im Falle von Einbahnstrassen\n\t\t */\n\t\t// Definiere Graph:\n\t\t\t\n\t\tgraph = new MapGraph(new GPSCoordinate(50,-50),new GPSCoordinate(-50,50));\n\t\tfor(int i=1;i<9;i++) {\n\t\t\tgraph.insertNode(i, new GPSCoordinate(i,i));\n\t\t}\n\t\tgraph.insertEdge(1, 2, 1, 1, StreetType.SECONDARY);\n\t\tgraph.insertEdge(1, 3, 2, 1, StreetType.SECONDARY);\n\t\tgraph.insertEdge(1, 4, 3, 5, StreetType.SECONDARY);\n\t\tgraph.insertEdge(2, 3, 4, 2, StreetType.SECONDARY);\n\t\tgraph.insertEdge(2, 4, 5, 3, StreetType.SECONDARY);\n\t\tgraph.insertEdge(3, 5, 6, 6, StreetType.SECONDARY);\n\t\tgraph.insertEdge(4, 6, 7, 1, StreetType.SECONDARY);\n\t\tgraph.insertEdge(4, 5, 8, 1, StreetType.SECONDARY);\n\t\tgraph.insertEdge(4, 7, 9, 4, StreetType.SECONDARY);\n\t\tgraph.insertEdge(6, 7, 10, 2, StreetType.SECONDARY);\n\t\tgraph.insertEdge(5, 7, 11, 3, StreetType.SECONDARY);\n\t\tgraph.insertEdge(5, 8, 12, 5, StreetType.SECONDARY);\n\t\tgraph.insertEdge(7, 8, 13, 2, StreetType.SECONDARY);\n\t\t\n\t\tLogger.getInstance().log(\"DijkstraTest\",\"======\");\n\t\t\n\t\t//Test nur die Strecken 1->8 und die Strecke 8->1 (erwarte Laenge 9 und eine leere Liste)\n\t\tliste = Dijkstra.bidirectional(graph, 1, 8);\n\t\tif (liste.size() != 6)\n\t\t\tfail(\"Ausgabeliste hat falsche Groesse - erwarte 6, habe: \"+liste.size());\n\t\t//Teste korrekte Reihenfolge\n\t\t\n\t\ttest = Pfad(liste);\n\t\tif (!test.equalsIgnoreCase(\"1-2-4-6-7-8\"))\n\t\t\tfail(\"Die Reihenfolge der besuchten Knoten ist falsch. Erwarte: 1-2-4-6-7-8, habe: \"+test);\n\t\t\n\t\tliste = Dijkstra.bidirectional(graph, 8, 1);\n\t\tif (liste.size() != 0)\n\t\t\tfail(\"Ausgabeliste hat falsche Groesse - erwarte 0, habe: \"+liste.size());\n\t\t\t\n\t\t/*\n\t\t * Test 6\n\t\t * Teste nun mit wegen (beide Richtungen) verschiedene kurze wege\n\t\t */\n\t\t\n\t\t//Definiere Graph\n\t\tgraph = new MapGraph(new GPSCoordinate(50,-50),new GPSCoordinate(-50,50));\n\t\tfor(int i=1;i<9;i++) {\n\t\t\tgraph.insertNode(i, new GPSCoordinate(i,i));\n\t\t}\n\t\tweg(graph,1,2,1,1);\n\t\tweg(graph,1,3,2,1);\n\t\tweg(graph,1,4,3,5);\n\t\tweg(graph,2,3,4,2);\n\t\tweg(graph,2,4,5,3);\n\t\tweg(graph,3,5,6,6);\n\t\tweg(graph,4,6,7,1);\n\t\tweg(graph,4,5,8,1);\n\t\tweg(graph,4,7,9,4);\n\t\tweg(graph,6,7,10,2);\n\t\tweg(graph,5,7,11,3);\n\t\tweg(graph,5,8,12,5);\n\t\tweg(graph,7,8,13,2);\n\n\t\t//Teste nun wieder 1->8 (gleiches Ergebnis wie eben bitte!)\n\t\tliste = Dijkstra.bidirectional(graph, 1, 8);\n\t\tif (liste.size() != 6)\n\t\t\tfail(\"Ausgabeliste hat falsche Groesse - erwarte 6, habe: \"+liste.size());\n\t\t//teste Reihenfolge\n\t\ttest = Pfad(liste);\n\t\tif (!test.equalsIgnoreCase(\"1-2-4-6-7-8\"))\n\t\t\tfail(\"Die Reihenfolge der besuchten Knoten ist falsch. Erwarte: -1-2-4-6-7-8, habe: \"+test);\n\t\t\n\t\t//Teste 8->1\n\t\tliste = Dijkstra.bidirectional(graph, 8, 1);\n\t\tif (liste.size() != 6)\n\t\t\tfail(\"Ausgabeliste hat falsche Groesse - erwarte 6, habe: \"+liste.size());\n\t\t//teste Reihenfolge\n\t\ttest = Pfad(liste);\n\t\tif (!test.equalsIgnoreCase(\"8-7-6-4-2-1\"))\n\t\t\tfail(\"Die Reihenfolge der besuchten Knoten ist falsch. Erwarte: 8-7-6-4-2-1, habe: \"+test);\n\t\t\n\t\t\n\t\t//Test nun 1->5\n\t\tliste = Dijkstra.bidirectional(graph, 1, 5);\n\t\tif (liste.size() != 4)\n\t\t\tfail(\"Ausgabeliste hat falsche Groesse - erwarte 3, habe: \"+liste.size());\n\t\t//teste Reihenfolge\n\t\ttest = Pfad(liste);\n\t\tif (!test.equalsIgnoreCase(\"1-2-4-5\"))\n\t\t\tfail(\"Die Reihenfolge der besuchten Knoten ist falsch. Erwarte: 1-4-5, habe: \"+test);\n\t\t\n\t\t//Teste nun 3->4\n\t\tliste = Dijkstra.bidirectional(graph, 3, 4);\n\t\tif (liste.size() != 3)\n\t\t\tfail(\"Ausgabeliste hat falsche Groesse - erwarte 3, habe: \"+liste.size());\n\t\t//teste Reihenfolge\n\t\ttest = Pfad(liste);\n\t\tif (!test.equalsIgnoreCase(\"3-2-4\"))\n\t\t\tfail(\"Die Reihenfolge der besuchten Knoten ist falsch. Erwarte: 3-2-4, habe: \"+test);\n\t\t\n\t\t//Teste 7->4\n\t\tliste = Dijkstra.bidirectional(graph, 7, 4);\n\t\tif (liste.size() != 3)\n\t\t\tfail(\"Ausgabeliste hat falsche Groesse - erwarte 3, habe: \"+liste.size());\n\t\t//teste Reihenfolge\n\t\ttest = Pfad(liste);\n\t\tif (!test.equalsIgnoreCase(\"7-6-4\"))\n\t\t\tfail(\"Die Reihenfolge der besuchten Knoten ist falsch. Erwarte: 7-6-4, habe: \"+test);\n\t\t\n\t\t/*\n\t\t * Test 7\n\t\t * erstelle zufallige Graphen und pruefe, ob ein ehler auftritt\n\t\t * Teste dabei auch die Zeit\n\t\t */\n\t\t\n\t\ttry {\n\t\t\t//for (int l = 0;l<10;l++) {\n\t\t\t\tBelastungsTest(50,0.3f,3);\n\t\t\t\tBelastungsTest(100,0.3f,5);\n\t\t\t\tBelastungsTest(500,0.3f,5);\n\t\t\t\tBelastungsTest(1000,0.3f,5);\n\t\t\t\tBelastungsTest(5000,0.3f,5);\n\t\t\t\t//BelastungsTest(10000,0.3f,5);\n\t\t\t\t//BelastungsTest(50000,0.3f,5);\n\t\t\t\t//BelastungsTest(100000,0.3f,5);\n\t\t\t\t//BelastungsTest(500000,0.3f,5);\n\t\t\t\t//BelastungsTest(1000000,0.3f,5);\n\t\t\t//}\n\t\t} catch (Exception e) {\n\t\t\tfail(\"Es gab einen Fehler innerhalb der Belastungstests: \"+e.getLocalizedMessage());\n\t\t}\n\t\t\n\t\t/*\n\t\tlong time =0;\n\t\ttry{\n\t\t\tfor (int i=0; i<10;i++){\n\t\t\t\t//Logger.getInstance().log(\"DijkstraTest\",\"Durchlauf\"+ (i+1));\n\t\t\t\ttime += BelastungsTest(5000,0.1f,5);\n\t\t\t\t//Logger.getInstance().log(\"DijkstraTest\",\"Gesamtzeit bisher: \"+time+\"ms\");\n\t\t\t\ttime += BelastungsTest(5000,0.2f,5);\n\t\t\t\t//Logger.getInstance().log(\"DijkstraTest\",\"Gesamtzeit bisher: \"+time+\"ms\");\n\t\t\t\ttime += BelastungsTest(5000,0.3f,5);\n\t\t\t\t//Logger.getInstance().log(\"DijkstraTest\",\"Gesamtzeit bisher: \"+time+\"ms\");\n\t\t\t\ttime += BelastungsTest(5000,0.4f,5);\n\t\t\t\t//Logger.getInstance().log(\"DijkstraTest\",\"Gesamtzeit bisher: \"+time+\"ms\");\n\t\t\t\ttime += BelastungsTest(5000,0.5f,5);\n\t\t\t\t//Logger.getInstance().log(\"DijkstraTest\",\"Gesamtzeit bisher: \"+time+\"ms\");\n\t\t\t\ttime += BelastungsTest(5000,0.6f,5);\n\t\t\t\t//Logger.getInstance().log(\"DijkstraTest\",\"Gesamtzeit bisher: \"+time+\"ms\");\n\t\t\t\ttime += BelastungsTest(5000,0.7f,5);\n\t\t\t\t//Logger.getInstance().log(\"DijkstraTest\",\"Gesamtzeit bisher: \"+time+\"ms\");\n\t\t\t\ttime += BelastungsTest(5000,0.8f,5);\n\t\t\t\t//Logger.getInstance().log(\"DijkstraTest\",\"Gesamtzeit bisher: \"+time+\"ms\");\n\t\t\t\ttime += BelastungsTest(5000,0.9f,5);\n\t\t\t\t//Logger.getInstance().log(\"DijkstraTest\",\"Gesamtzeit bisher: \"+time+\"ms\");\n\t\t\t\ttime += BelastungsTest(5000,1.0f,5);\n\t\t\t\t//Logger.getInstance().log(\"DijkstraTest\",\"Gesamtzeit bisher: \"+time+\"ms\");\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tfail(\"Es gab einen Fehler innerhalb der Belastungstests: \"+e.getLocalizedMessage());\n\t\t}\n\t\t*/\n\t\t\n\n\t\t/*\n\t\t * Test 8\n\t\t * Teste die Dtestgraph\n\t\t */\n\t\t\n\t\tMapGraph testGraph = null;\n\t\tOSMImporter osm_imp;\n\t\t\n\t\ttry {\n\t\t\tosm_imp = new OSMImporter(new File(\"testdateien/DtestGraph.osm\"));\n\t\t\ttestGraph = osm_imp.getTile(osm_imp.getMapCenter(), 0);\n\t\t} catch (Exception e) {\n\t\t\tfail(\"Fehler beim Einlesen der DtestGraph: \"+e.getLocalizedMessage());\n\t\t}\n\t\t\n\t\tArrayList<MapNode> myway = Dijkstra.bidirectional(testGraph, 3, 10);\n\t\t\n\t\tLogger.getInstance().log(\"DijkstraTest\", \"Die Laenge der Strecke ist: \"+weglaenge(myway));\n\t\t\n\t\t/*\n\t\t * Gitter-Test\n\t\t */\n\t\tLogger.getInstance().log(\"DijkstraTest\",\"Starte Gitter-Test (n=3)\");\n\t\tMapGraph Gittertest = GitterGraph(3);\n\t\tliste = Dijkstra.bidirectional(Gittertest, 1, 3*3);\n\t\tif (!(Pfad(liste).equals(\"1-2-5-6-9\")))\n\t\t\tfail(\"Der Algo ibt nicht auf dem Gitter die kuerzeste Route aus\");\n\t\tLogger.getInstance().log(\"DijkstraTest\",\"Weglaenge (soll: 4): \"+weglaenge(liste));\n\t\tif (weglaenge(liste) != 4)\n\t\t\tfail(\"Der berechnete Weg ist nciht der kuerzeste!\");\n\t\t\t/*\n\t\tLogger.getInstance().log(\"DijkstraTest\",\"Starte Gitter-Test (n=1.000)\");\n\t\tGittertest = GitterGraph(1000);\n\t\tliste = Dijkstra.bidirectional(Gittertest, 1, 1000*1000);\n\t\tLogger.getInstance().log(\"DijkstraTest\",\"Weglaenge (soll: 1998): \"+weglaenge(liste));\n\t\tif (weglaenge(liste) != 1998)\n\t\t\tfail(\"Der berechnete Weg ist nciht der kuerzeste!\");\n\t\t\t*/\n\t}", "signature": "void testBidirectional()", "full_signature": "@Test public void testBidirectional()", "class_method_signature": "DijkstraTest.testBidirectional()", "testcase": true, "constructor": false, "invocations": ["bidirectional", "fail", "randomGraph", "bidirectional", "fail", "getLocalizedMessage", "size", "fail", "size", "insertNode", "bidirectional", "fail", "getLocalizedMessage", "size", "fail", "size", "bidirectional", "fail", "getLocalizedMessage", "size", "fail", "size", "insertNode", "insertEdge", "insertEdge", "insertEdge", "insertEdge", "insertEdge", "insertEdge", "insertEdge", "insertEdge", "insertEdge", "insertEdge", "insertEdge", "insertEdge", "insertEdge", "log", "getInstance", "bidirectional", "size", "fail", "size", "Pfad", "equalsIgnoreCase", "fail", "bidirectional", "size", "fail", "size", "insertNode", "weg", "weg", "weg", "weg", "weg", "weg", "weg", "weg", "weg", "weg", "weg", "weg", "weg", "bidirectional", "size", "fail", "size", "Pfad", "equalsIgnoreCase", "fail", "bidirectional", "size", "fail", "size", "Pfad", "equalsIgnoreCase", "fail", "bidirectional", "size", "fail", "size", "Pfad", "equalsIgnoreCase", "fail", "bidirectional", "size", "fail", "size", "Pfad", "equalsIgnoreCase", "fail", "bidirectional", "size", "fail", "size", "Pfad", "equalsIgnoreCase", "fail", "BelastungsTest", "BelastungsTest", "BelastungsTest", "BelastungsTest", "BelastungsTest", "fail", "getLocalizedMessage", "getTile", "getMapCenter", "fail", "getLocalizedMessage", "bidirectional", "log", "getInstance", "weglaenge", "log", "getInstance", "GitterGraph", "bidirectional", "equals", "Pfad", "fail", "log", "getInstance", "weglaenge", "weglaenge", "fail"]}, "focal_class": {"identifier": "Dijkstra", "superclass": "", "interfaces": "", "fields": [{"original_string": "static boolean debug = false;", "modifier": "static", "type": "boolean", "declarator": "debug = false", "var_name": "debug"}, {"original_string": "private static Logger logger = Logger.getInstance();", "modifier": "private static", "type": "Logger", "declarator": "logger = Logger.getInstance()", "var_name": "logger"}], "methods": [{"identifier": "updateNeighbours", "parameters": "(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "modifiers": "private static", "return": "void", "signature": "void updateNeighbours(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "full_signature": "private static void updateNeighbours(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "class_method_signature": "Dijkstra.updateNeighbours(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "testcase": false, "constructor": false}, {"identifier": "neighbourhood", "parameters": "(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "modifiers": "public static", "return": "long", "signature": "long neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "full_signature": "public static long neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "class_method_signature": "Dijkstra.neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "testcase": false, "constructor": false}, {"identifier": "handleQueues", "parameters": "(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "modifiers": "private static", "return": "boolean", "signature": "boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "full_signature": "private static boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "class_method_signature": "Dijkstra.handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "testcase": false, "constructor": false}, {"identifier": "bidirectional", "parameters": "(MapGraph graph, int startnode, int endnode)", "modifiers": "public static", "return": "ArrayList<MapNode>", "signature": "ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode)", "full_signature": "public static ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode)", "class_method_signature": "Dijkstra.bidirectional(MapGraph graph, int startnode, int endnode)", "testcase": false, "constructor": false}, {"identifier": "handleQueues", "parameters": "(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "modifiers": "private static", "return": "boolean", "signature": "boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "full_signature": "private static boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "class_method_signature": "Dijkstra.handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "testcase": false, "constructor": false}, {"identifier": "bidirectional", "parameters": "(HierarchyMapGraph graph, int startnode, int endnode)", "modifiers": "public static", "return": "Path", "signature": "Path bidirectional(HierarchyMapGraph graph, int startnode, int endnode)", "full_signature": "public static Path bidirectional(HierarchyMapGraph graph, int startnode, int endnode)", "class_method_signature": "Dijkstra.bidirectional(HierarchyMapGraph graph, int startnode, int endnode)", "testcase": false, "constructor": false}], "file": "SoftwarePraktikum/src/algorithmen/Dijkstra.java"}, "focal_method": {"identifier": "bidirectional", "parameters": "(MapGraph graph, int startnode, int endnode)", "modifiers": "public static", "return": "ArrayList<MapNode>", "body": "public static ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode) throws Exception{\n\t\t\n\t\tif (graph == null) throw new EmptyInputException(\"Leerer Graph uebergeben\");\n\t\t//Hier breche ich immer wieder ab, was echt bloed ist und mich nervt das langsam echt!\n\t\tif (graph.getNode(startnode) == null || graph.getNode(endnode) == null || startnode == endnode) return new ArrayList<MapNode>();\n\t\t\n\t\tHashMap<Integer,Vertex> nodes1 = new HashMap<Integer,Vertex>(); // In einzelnen Listen wird gespeichert welcher Knoten.\n\t\tHashMap<Integer,Vertex> nodes2 = new HashMap<Integer,Vertex>(); //von welcher Richtung aus schon besucht worden ist.\n\t\t\n\t\tPrQueue forward = new PrQueue(); //Priority Queue, die alle erreichbaren Knoten enthaelt\n\t\tPrQueue backward = new PrQueue(); //Priority Queue, die alle erreichbaren Knoten enthaelt\n\t\t\n\t\tVertex start = new Vertex(graph.getNode(startnode),0,0); //Vertex ist die Hilfsklasse, in der zusaetzliche Infos ueber Knoten gespeichert werden.\n\t\tVertex end = new Vertex(graph.getNode(endnode),0,0); //Vertex ist die Hilfsklasse, in der zusaetzliche Infos ueber Knoten gespeichert werden.\n\t\t\n\t\tnodes1.put(startnode,start); \n\t\tnodes2.put(endnode,end);\n\t\t\n\t\tforward.insert(start);\n\t\tbackward.insert(end);\n        \n\t\twhile (forward.getSize() != 0 && backward.getSize() != 0){ //Wenn beide Queues leer, Abbruch\n\t\t\tboolean abort;\n\t\t\tabort = handleQueues(nodes1,forward,graph,nodes2,backward,true); //Berechne vorwaerts\n\t\t\tif(abort) break;\n\t\t\tabort = handleQueues(nodes1,forward,graph,nodes2,backward,false); //Berechne rueckwaerts\n\t\t\tif(abort) break;\n\t\t}\n\t\t\n\t\tlong distance = -1;\n\t\tVertex meet = null;\n\t\t\n\t\t\n\t\t//Wir suchen den Punkt ueber den der kuerzeste Weg verlueuft\n\t\tfor (Vertex currentNode : nodes1.values()){\n\t\t\t\n\t\t\t//ueber pruefe ob Node in beiden Listen vorhanden ist\n\t\t\t\n\t\t\tint ID = currentNode.node.getUID();\n\t\t\tif (nodes2.containsKey(ID) == false){\n\t\t\t\tcontinue;  //node noch nicht von anderer Seite ueberprueft => liegt nicht auf kuerzestem Weg\n\t\t\t}\n\t\t\t\n\t\t\tif (distance == -1) {\n\t\t\t\tdistance = nodes1.get(ID).getDist() + nodes2.get(ID).getDist();\n\t\t\t\tmeet = nodes1.get(ID);\n\t\t\t\t\n\n\t\t\t}else{\n\t\t\t\tlong newDist = nodes1.get(ID).getDist() + nodes2.get(ID).getDist();\n\t\t\t\tif (distance > newDist){\n\t\t\t\t\tdistance = nodes1.get(ID).getDist() + nodes2.get(ID).getDist();\n\t\t\t\t\tmeet = nodes1.get(ID);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif (meet == null) return new ArrayList<MapNode>();\n\t\t\n\t\tArrayList<MapNode> route = new ArrayList<MapNode>();\n\n\t\troute.add(graph.getNode(meet.node.getUID() ) );\n\t\tVertex pos = meet;\n\t\t\n\t\twhile (pos.getPredecessor() != 0){ //Ermittle alle Knoten, die vor meet besucht wurden\n\t\t\tVertex parent = nodes1.get(pos.getPredecessor());\n\t\t\troute.add(0, graph.getNode(parent.node.getUID()));\n\t\t\tpos = parent;\n\t\t}\n\t\t\n\t\tpos = nodes2.get( meet.node.getUID());\n\t\t\n\t\twhile (pos.getPredecessor() != 0){ //Ermittle alle Knoten die nach meet besucht wurden \n\t\t\tVertex parent = nodes2.get(pos.getPredecessor());\n\t\t\troute.add(graph.getNode(parent.node.getUID()));\n\t\t\tpos = parent;\n\t\t}\t\t\n\t\t\n\t\tif(debug){ \n\t\t\tlogger.log(\"Dijkstra.biderectional\",\"Vom Startknoten aus evaluiert: \"+nodes1.values().size());\n\t\t\tlogger.log(\"Dijkstra.biderectional\",\"Vom Zielknoten aus evaluiert: \"+nodes2.values().size());\n\t\t\tlogger.log(\"Dijkstra.biderectional\",\"Knoten auf der Route: \"+route.size());\n\t\t}\n\t\t\n\t\treturn route; //gib die Liste zurueck\n\t}", "signature": "ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode)", "full_signature": "public static ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode)", "class_method_signature": "Dijkstra.bidirectional(MapGraph graph, int startnode, int endnode)", "testcase": false, "constructor": false, "invocations": ["getNode", "getNode", "getNode", "getNode", "put", "put", "insert", "insert", "getSize", "getSize", "handleQueues", "handleQueues", "values", "getUID", "containsKey", "getDist", "get", "getDist", "get", "get", "getDist", "get", "getDist", "get", "getDist", "get", "getDist", "get", "get", "add", "getNode", "getUID", "getPredecessor", "get", "getPredecessor", "add", "getNode", "getUID", "get", "getUID", "getPredecessor", "get", "getPredecessor", "add", "getNode", "getUID", "log", "size", "values", "log", "size", "values", "log", "size"]}, "repository": {"repo_id": 3716960, "url": "https://github.com/auxua/SWP-Routenplaner", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 5, "size": 13806, "license": "licensed"}}