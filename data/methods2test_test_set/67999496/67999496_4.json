{"test_class": {"identifier": "ImgscalrImageManipulatorTest", "superclass": "extends AbstractImageTest", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(ImgscalrImageManipulatorTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(ImgscalrImageManipulatorTest.class)", "var_name": "log"}, {"original_string": "private ImgscalrImageManipulator manipulator;", "modifier": "private", "type": "ImgscalrImageManipulator", "declarator": "manipulator", "var_name": "manipulator"}], "file": "services/image-imgscalr/src/test/java/com/gentics/mesh/image/ImgscalrImageManipulatorTest.java"}, "test_case": {"identifier": "testResize", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testResize() throws Exception {\n\t\tcheckImages((imageName, width, height, color, refImage, path, bs) -> {\n\t\t\tlog.debug(\"Handling \" + imageName);\n\n\t\t\tSingle<byte[]> obs = manipulator\n\t\t\t\t.handleResize(createMockedBinary(path), new ImageManipulationParametersImpl().setWidth(150).setHeight(180))\n\t\t\t\t.map(file -> Files.readAllBytes(Paths.get(file)));\n\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\tobs.subscribe(data -> {\n\t\t\t\ttry {\n\t\t\t\t\tassertNotNull(data);\n\t\t\t\t\ttry (ByteArrayInputStream bis = new ByteArrayInputStream(data)) {\n\t\t\t\t\t\tBufferedImage resizedImage = ImageIO.read(bis);\n\t\t\t\t\t\tString referenceFilename = \"outputImage-\" + imageName.replace(\".\", \"_\") + \"-resize-reference.png\";\n\t\t\t\t\t\t// when you want to update the referenceImage, execute the code below\n\t\t\t\t\t\t// and copy the files to src/test/resources/references/\n\t\t\t\t\t\t// ImageTestUtil.writePngImage(resizedImage, new File(\"target/\" + referenceFilename));\n\t\t\t\t\t\t// ImageTestUtil.displayImage(resizedImage);\n\t\t\t\t\t\tassertThat(resizedImage).as(imageName).hasSize(150, 180).matchesReference(referenceFilename);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tfail(\"Error occured\");\n\t\t\t\t}\n\t\t\t\tlatch.countDown();\n\t\t\t});\n\t\t\ttry {\n\t\t\t\tif (!latch.await(20, TimeUnit.SECONDS)) {\n\t\t\t\t\tfail(\"Timeout reached\");\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t});\n\n\t}", "signature": "void testResize()", "full_signature": "@Test public void testResize()", "class_method_signature": "ImgscalrImageManipulatorTest.testResize()", "testcase": true, "constructor": false, "invocations": ["checkImages", "debug", "map", "handleResize", "createMockedBinary", "setHeight", "setWidth", "readAllBytes", "get", "subscribe", "assertNotNull", "read", "replace", "matchesReference", "hasSize", "as", "assertThat", "printStackTrace", "fail", "countDown", "await", "fail"]}, "focal_class": {"identifier": "ImgscalrImageManipulator", "superclass": "extends AbstractImageManipulator", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(ImgscalrImageManipulator.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(ImgscalrImageManipulator.class)", "var_name": "log"}, {"original_string": "private FocalPointModifier focalPointModifier;", "modifier": "private", "type": "FocalPointModifier", "declarator": "focalPointModifier", "var_name": "focalPointModifier"}, {"original_string": "private WorkerExecutor workerPool;", "modifier": "private", "type": "WorkerExecutor", "declarator": "workerPool", "var_name": "workerPool"}, {"original_string": "private final BootstrapInitializer boot;", "modifier": "private final", "type": "BootstrapInitializer", "declarator": "boot", "var_name": "boot"}], "methods": [{"identifier": "ImgscalrImageManipulator", "parameters": "(Vertx vertx, MeshOptions options, BootstrapInitializer boot)", "modifiers": "public", "return": "", "signature": " ImgscalrImageManipulator(Vertx vertx, MeshOptions options, BootstrapInitializer boot)", "full_signature": "public  ImgscalrImageManipulator(Vertx vertx, MeshOptions options, BootstrapInitializer boot)", "class_method_signature": "ImgscalrImageManipulator.ImgscalrImageManipulator(Vertx vertx, MeshOptions options, BootstrapInitializer boot)", "testcase": false, "constructor": true}, {"identifier": "ImgscalrImageManipulator", "parameters": "(Vertx vertx, ImageManipulatorOptions options, BootstrapInitializer boot)", "modifiers": "", "return": "", "signature": " ImgscalrImageManipulator(Vertx vertx, ImageManipulatorOptions options, BootstrapInitializer boot)", "full_signature": "  ImgscalrImageManipulator(Vertx vertx, ImageManipulatorOptions options, BootstrapInitializer boot)", "class_method_signature": "ImgscalrImageManipulator.ImgscalrImageManipulator(Vertx vertx, ImageManipulatorOptions options, BootstrapInitializer boot)", "testcase": false, "constructor": true}, {"identifier": "crop", "parameters": "(BufferedImage originalImage, ImageRect cropArea)", "modifiers": "protected", "return": "BufferedImage", "signature": "BufferedImage crop(BufferedImage originalImage, ImageRect cropArea)", "full_signature": "protected BufferedImage crop(BufferedImage originalImage, ImageRect cropArea)", "class_method_signature": "ImgscalrImageManipulator.crop(BufferedImage originalImage, ImageRect cropArea)", "testcase": false, "constructor": false}, {"identifier": "resizeIfRequested", "parameters": "(BufferedImage originalImage, ImageManipulationParameters parameters)", "modifiers": "protected", "return": "BufferedImage", "signature": "BufferedImage resizeIfRequested(BufferedImage originalImage, ImageManipulationParameters parameters)", "full_signature": "protected BufferedImage resizeIfRequested(BufferedImage originalImage, ImageManipulationParameters parameters)", "class_method_signature": "ImgscalrImageManipulator.resizeIfRequested(BufferedImage originalImage, ImageManipulationParameters parameters)", "testcase": false, "constructor": false}, {"identifier": "getImageReader", "parameters": "(ImageInputStream input)", "modifiers": "private", "return": "ImageReader", "signature": "ImageReader getImageReader(ImageInputStream input)", "full_signature": "private ImageReader getImageReader(ImageInputStream input)", "class_method_signature": "ImgscalrImageManipulator.getImageReader(ImageInputStream input)", "testcase": false, "constructor": false}, {"identifier": "getImageWriter", "parameters": "(ImageReader reader, ImageOutputStream out)", "modifiers": "private", "return": "ImageWriter", "signature": "ImageWriter getImageWriter(ImageReader reader, ImageOutputStream out)", "full_signature": "private ImageWriter getImageWriter(ImageReader reader, ImageOutputStream out)", "class_method_signature": "ImgscalrImageManipulator.getImageWriter(ImageReader reader, ImageOutputStream out)", "testcase": false, "constructor": false}, {"identifier": "cropAndResize", "parameters": "(BufferedImage image, ImageManipulationParameters parameters)", "modifiers": "protected", "return": "BufferedImage", "signature": "BufferedImage cropAndResize(BufferedImage image, ImageManipulationParameters parameters)", "full_signature": "protected BufferedImage cropAndResize(BufferedImage image, ImageManipulationParameters parameters)", "class_method_signature": "ImgscalrImageManipulator.cropAndResize(BufferedImage image, ImageManipulationParameters parameters)", "testcase": false, "constructor": false}, {"identifier": "handleResize", "parameters": "(Binary binary, ImageManipulationParameters parameters)", "modifiers": "@Override public", "return": "Single<String>", "signature": "Single<String> handleResize(Binary binary, ImageManipulationParameters parameters)", "full_signature": "@Override public Single<String> handleResize(Binary binary, ImageManipulationParameters parameters)", "class_method_signature": "ImgscalrImageManipulator.handleResize(Binary binary, ImageManipulationParameters parameters)", "testcase": false, "constructor": false}, {"identifier": "getImageWriteparams", "parameters": "(String extension)", "modifiers": "private", "return": "ImageWriteParam", "signature": "ImageWriteParam getImageWriteparams(String extension)", "full_signature": "private ImageWriteParam getImageWriteparams(String extension)", "class_method_signature": "ImgscalrImageManipulator.getImageWriteparams(String extension)", "testcase": false, "constructor": false}, {"identifier": "isJpeg", "parameters": "(String extension)", "modifiers": "private", "return": "boolean", "signature": "boolean isJpeg(String extension)", "full_signature": "private boolean isJpeg(String extension)", "class_method_signature": "ImgscalrImageManipulator.isJpeg(String extension)", "testcase": false, "constructor": false}, {"identifier": "calculateDominantColor", "parameters": "(BufferedImage image)", "modifiers": "@Override public", "return": "int[]", "signature": "int[] calculateDominantColor(BufferedImage image)", "full_signature": "@Override public int[] calculateDominantColor(BufferedImage image)", "class_method_signature": "ImgscalrImageManipulator.calculateDominantColor(BufferedImage image)", "testcase": false, "constructor": false}, {"identifier": "getMetadata", "parameters": "(InputStream ins)", "modifiers": "@Override public", "return": "Single<Map<String, String>>", "signature": "Single<Map<String, String>> getMetadata(InputStream ins)", "full_signature": "@Override public Single<Map<String, String>> getMetadata(InputStream ins)", "class_method_signature": "ImgscalrImageManipulator.getMetadata(InputStream ins)", "testcase": false, "constructor": false}], "file": "services/image-imgscalr/src/main/java/com/gentics/mesh/image/ImgscalrImageManipulator.java"}, "focal_method": {"identifier": "handleResize", "parameters": "(Binary binary, ImageManipulationParameters parameters)", "modifiers": "@Override public", "return": "Single<String>", "body": "@Override\n\tpublic Single<String> handleResize(Binary binary, ImageManipulationParameters parameters) {\n\t\t// Validate the resize parameters\n\t\tparameters.validate();\n\t\tparameters.validateLimits(options);\n\n\t\tBinaryDaoWrapper binaryDao = boot.binaryDao();\n\t\tSupplier<InputStream> stream = binaryDao.openBlockingStream(binary);\n\n\t\treturn getCacheFilePath(binary.getSHA512Sum(), parameters)\n\t\t\t.flatMap(cacheFileInfo -> {\n\t\t\t\tif (cacheFileInfo.exists) {\n\t\t\t\t\treturn Single.just(cacheFileInfo.path);\n\t\t\t\t} else {\n\t\t\t\t\t// TODO handle execution timeout\n\t\t\t\t\t// Make sure to run that code in the dedicated thread pool it may be CPU intensive for larger images and we don't want to exhaust the\n\t\t\t\t\t// regular worker\n\t\t\t\t\t// pool\n\t\t\t\t\treturn workerPool.<String>rxExecuteBlocking(bh -> {\n\t\t\t\t\t\ttry (\n\t\t\t\t\t\t\tInputStream is = stream.get();\n\t\t\t\t\t\t\tImageInputStream ins = ImageIO.createImageInputStream(is)) {\n\t\t\t\t\t\t\tBufferedImage image;\n\t\t\t\t\t\t\tImageReader reader = getImageReader(ins);\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\timage = reader.read(0);\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tlog.error(\"Could not read input image\", e);\n\n\t\t\t\t\t\t\t\tthrow error(BAD_REQUEST, \"image_error_reading_failed\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog.debug(\"Read image from stream \" + ins.hashCode() + \" with reader \" + reader.getClass().getName());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\timage = cropAndResize(image, parameters);\n\n\t\t\t\t\t\t\tString[] extensions = reader.getOriginatingProvider().getFileSuffixes();\n\t\t\t\t\t\t\tString extension = ArrayUtils.isEmpty(extensions) ? \"\" : extensions[0];\n\t\t\t\t\t\t\tString cacheFilePath = cacheFileInfo.path + \".\" + extension;\n\t\t\t\t\t\t\tFile outCacheFile = new File(cacheFilePath);\n\n\t\t\t\t\t\t\t// Write image\n\t\t\t\t\t\t\ttry (ImageOutputStream out = new FileImageOutputStream(outCacheFile)) {\n\t\t\t\t\t\t\t\tImageWriteParam params = getImageWriteparams(extension);\n\n\t\t\t\t\t\t\t\t// same as write(image), but with image parameters\n\t\t\t\t\t\t\t\tgetImageWriter(reader, out).write(null, new IIOImage(image, null, null), params);\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tthrow error(BAD_REQUEST, \"image_error_writing_failed\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Return buffer to written cache file\n\t\t\t\t\t\t\tbh.complete(cacheFilePath);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tbh.fail(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, false).toSingle();\n\t\t\t\t}\n\t\t\t});\n\t}", "signature": "Single<String> handleResize(Binary binary, ImageManipulationParameters parameters)", "full_signature": "@Override public Single<String> handleResize(Binary binary, ImageManipulationParameters parameters)", "class_method_signature": "ImgscalrImageManipulator.handleResize(Binary binary, ImageManipulationParameters parameters)", "testcase": false, "constructor": false, "invocations": ["validate", "validateLimits", "binaryDao", "openBlockingStream", "flatMap", "getCacheFilePath", "getSHA512Sum", "just", "toSingle", "rxExecuteBlocking", "get", "createImageInputStream", "getImageReader", "read", "error", "error", "isDebugEnabled", "debug", "hashCode", "getName", "getClass", "cropAndResize", "getFileSuffixes", "getOriginatingProvider", "isEmpty", "getImageWriteparams", "write", "getImageWriter", "error", "complete", "fail"]}, "repository": {"repo_id": 67999496, "url": "https://github.com/gentics/mesh", "stars": 412, "created": "9/12/2016 10:28:41 AM +00:00", "updates": "2020-01-27T10:25:42+00:00", "fork": "False", "license": "licensed"}}