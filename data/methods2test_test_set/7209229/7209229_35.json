{"test_class": {"identifier": "TestRangeBasedReaderWriterLock", "superclass": "", "interfaces": "", "fields": [{"original_string": "BufferPositionParser _parser = new BufferPositionParser(Integer.MAX_VALUE, Integer.MAX_VALUE);", "modifier": "", "type": "BufferPositionParser", "declarator": "_parser = new BufferPositionParser(Integer.MAX_VALUE, Integer.MAX_VALUE)", "var_name": "_parser"}], "file": "databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/util/TestRangeBasedReaderWriterLock.java"}, "test_case": {"identifier": "testAcquireWriterLock", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testAcquireWriterLock() throws InterruptedException, TimeoutException\n\t{\n\t  final Logger log = Logger.getLogger(\"TestRangeBasedReaderWriterLock.testAcquireWriterLock\");\n\t   final RangeBasedReaderWriterLock lock = new RangeBasedReaderWriterLock();\n\n\t   {\n\t     /*\n          * When Readers with same GenIds present\n          */\n         LockToken token1 = lock.acquireReaderLock(_parser.setGenId(1000, 1),\n                                                   _parser.setGenId(20000, 1),\n                                                   _parser,\n                                                   \"testAcquireWriterLock1\");\n         LockToken token2 = lock.acquireReaderLock(_parser.setGenId(1000,1),\n                                                   _parser.setGenId(20000,1),\n                                                   _parser,\n                                                   \"testAcquireWriterLock2\");\n         LockToken token3 = lock.acquireReaderLock(_parser.setGenId(10000,1),\n                                                   _parser.setGenId(20000,1),\n                                                   _parser,\n                                                   \"testAcquireWriterLock3\");\n\n         Runnable writer = new Runnable() {\n           @Override\n          public void run()\n           {\n             try\n            {\n              lock.acquireWriterLock(_parser.setGenId(0,1), _parser.setGenId(1001,1), _parser);\n            }\n            catch (InterruptedException e)\n            {\n              log.error(e);\n            }\n            catch (TimeoutException e)\n            {\n              log.error(e);\n            }\n           }\n         };\n\n         Thread writerThread = new Thread(writer);\n         writerThread.start();\n\n         try\n         {\n           Thread.sleep(100);\n         } catch ( InterruptedException ie) { throw new RuntimeException(ie); }\n\n         AssertJUnit.assertTrue(lock.isWriterWaiting());\n         AssertJUnit.assertFalse(lock.isWriterIn());\n         lock.releaseReaderLock(token1);\n\n         try\n         {\n           Thread.sleep(100);\n         } catch ( InterruptedException ie) { throw new RuntimeException(ie); }\n         AssertJUnit.assertTrue(lock.isWriterWaiting());\n         AssertJUnit.assertFalse(lock.isWriterIn());\n         lock.releaseReaderLock(token2);\n\n         try\n         {\n           writerThread.join(1000);\n         } catch (InterruptedException ie) {throw new RuntimeException(ie); }\n\n         AssertJUnit.assertTrue(lock.isWriterIn());\n         AssertJUnit.assertFalse(lock.isWriterWaiting());\n         AssertJUnit.assertFalse(writerThread.isAlive());\n         lock.releaseReaderLock(token3);\n         lock.releaseWriterLock(_parser);\n\t   }\n\n\n\t   {\n\t     /*\n\t      * When Readers with different GenIds present\n\t      */\n\t     LockToken token1 = lock.acquireReaderLock(_parser.setGenId(10, 1),\n\t                                               _parser.setGenId(200, 1),\n\t                                               _parser,\n\t                                               \"testAcquireWriterLock4\");\n\t     LockToken token2 = lock.acquireReaderLock(_parser.setGenId(10,1),\n\t                                               _parser.setGenId(2000,1),\n\t                                               _parser,\n\t                                               \"testAcquireWriterLock5\");\n\t     LockToken token3 = lock.acquireReaderLock(2000, 3000, _parser, \"testAcquireWriterLock6\");\n\n\t     Runnable writer = new Runnable() {\n\t       @Override\n        public void run()\n\t       {\n\t         try\n\t         {\n\t           lock.acquireWriterLock(_parser.setGenId(2000,1), _parser.setGenId(11000,1), _parser);\n\t         }\n\t         catch (InterruptedException e)\n\t         {\n\t           log.error(e);\n\t         }\n\t         catch (TimeoutException e)\n\t         {\n\t           log.error(e);\n\t         }\n\t       }\n\t     };\n\n\t     Thread writerThread = new Thread(writer);\n\t     writerThread.start();\n\n\t     try\n\t     {\n\t       Thread.sleep(100);\n\t     } catch ( InterruptedException ie) { throw new RuntimeException(ie); }\n\n\t     AssertJUnit.assertTrue(lock.isWriterWaiting());\n\t     AssertJUnit.assertFalse(lock.isWriterIn());\n\t     lock.releaseReaderLock(token3);\n\n\t     try\n\t     {\n\t       writerThread.join(1000);\n\t     } catch (InterruptedException ie) {throw new RuntimeException(ie); }\n\n\t     AssertJUnit.assertTrue(lock.isWriterIn());\n\t     AssertJUnit.assertFalse(lock.isWriterWaiting());\n\t     AssertJUnit.assertFalse(writerThread.isAlive());\n\t     lock.releaseReaderLock(token1);\n\t     lock.releaseReaderLock(token2);\n         lock.releaseWriterLock(_parser);\n\t   }\n\t}", "signature": "void testAcquireWriterLock()", "full_signature": "@Test public void testAcquireWriterLock()", "class_method_signature": "TestRangeBasedReaderWriterLock.testAcquireWriterLock()", "testcase": true, "constructor": false, "invocations": ["getLogger", "acquireReaderLock", "setGenId", "setGenId", "acquireReaderLock", "setGenId", "setGenId", "acquireReaderLock", "setGenId", "setGenId", "acquireWriterLock", "setGenId", "setGenId", "error", "error", "start", "sleep", "assertTrue", "isWriterWaiting", "assertFalse", "isWriterIn", "releaseReaderLock", "sleep", "assertTrue", "isWriterWaiting", "assertFalse", "isWriterIn", "releaseReaderLock", "join", "assertTrue", "isWriterIn", "assertFalse", "isWriterWaiting", "assertFalse", "isAlive", "releaseReaderLock", "releaseWriterLock", "acquireReaderLock", "setGenId", "setGenId", "acquireReaderLock", "setGenId", "setGenId", "acquireReaderLock", "acquireWriterLock", "setGenId", "setGenId", "error", "error", "start", "sleep", "assertTrue", "isWriterWaiting", "assertFalse", "isWriterIn", "releaseReaderLock", "join", "assertTrue", "isWriterIn", "assertFalse", "isWriterWaiting", "assertFalse", "isAlive", "releaseReaderLock", "releaseReaderLock", "releaseWriterLock"]}, "focal_class": {"identifier": "RangeBasedReaderWriterLock", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String MODULE = RangeBasedReaderWriterLock.class.getName();", "modifier": "public static final", "type": "String", "declarator": "MODULE = RangeBasedReaderWriterLock.class.getName()", "var_name": "MODULE"}, {"original_string": "public static final Logger LOG = Logger.getLogger(MODULE);", "modifier": "public static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(MODULE)", "var_name": "LOG"}, {"original_string": "private static final long MAX_LOCK_WAIT_MS = 60000;", "modifier": "private static final", "type": "long", "declarator": "MAX_LOCK_WAIT_MS = 60000", "var_name": "MAX_LOCK_WAIT_MS"}, {"original_string": "private final PriorityQueue<LockToken> readerRanges;", "modifier": "private final", "type": "PriorityQueue<LockToken>", "declarator": "readerRanges", "var_name": "readerRanges"}, {"original_string": "private final ReentrantLock mutex;", "modifier": "private final", "type": "ReentrantLock", "declarator": "mutex", "var_name": "mutex"}, {"original_string": "private final Condition writesPossible;", "modifier": "private final", "type": "Condition", "declarator": "writesPossible", "var_name": "writesPossible"}, {"original_string": "private final Condition readsPossible;", "modifier": "private final", "type": "Condition", "declarator": "readsPossible", "var_name": "readsPossible"}, {"original_string": "private Range writerRange;", "modifier": "private", "type": "Range", "declarator": "writerRange", "var_name": "writerRange"}, {"original_string": "private boolean writerIn;", "modifier": "private", "type": "boolean", "declarator": "writerIn", "var_name": "writerIn"}, {"original_string": "private boolean writerWaiting;", "modifier": "private", "type": "boolean", "declarator": "writerWaiting", "var_name": "writerWaiting"}], "methods": [{"identifier": "RangeBasedReaderWriterLock", "parameters": "()", "modifiers": "public", "return": "", "signature": " RangeBasedReaderWriterLock()", "full_signature": "public  RangeBasedReaderWriterLock()", "class_method_signature": "RangeBasedReaderWriterLock.RangeBasedReaderWriterLock()", "testcase": false, "constructor": true}, {"identifier": "acquireReaderLock", "parameters": "(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "modifiers": "public", "return": "LockToken", "signature": "LockToken acquireReaderLock(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "full_signature": "public LockToken acquireReaderLock(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "class_method_signature": "RangeBasedReaderWriterLock.acquireReaderLock(long startOffset, long endOffset, BufferPositionParser parser,\n                                     String ownerName)", "testcase": false, "constructor": false}, {"identifier": "shiftReaderLockStart", "parameters": "(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "modifiers": "public", "return": "void", "signature": "void shiftReaderLockStart(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "full_signature": "public void shiftReaderLockStart(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "class_method_signature": "RangeBasedReaderWriterLock.shiftReaderLockStart(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "testcase": false, "constructor": false}, {"identifier": "shiftReaderLockStartIfWriterWaiting", "parameters": "(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "modifiers": "public", "return": "void", "signature": "void shiftReaderLockStartIfWriterWaiting(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "full_signature": "public void shiftReaderLockStartIfWriterWaiting(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "class_method_signature": "RangeBasedReaderWriterLock.shiftReaderLockStartIfWriterWaiting(LockToken lockId, long newStartOffset, BufferPositionParser parser)", "testcase": false, "constructor": false}, {"identifier": "releaseReaderLock", "parameters": "(LockToken lockId)", "modifiers": "public", "return": "void", "signature": "void releaseReaderLock(LockToken lockId)", "full_signature": "public void releaseReaderLock(LockToken lockId)", "class_method_signature": "RangeBasedReaderWriterLock.releaseReaderLock(LockToken lockId)", "testcase": false, "constructor": false}, {"identifier": "acquireWriterLock", "parameters": "(long start, long end, BufferPositionParser parser)", "modifiers": "public", "return": "void", "signature": "void acquireWriterLock(long start, long end, BufferPositionParser parser)", "full_signature": "public void acquireWriterLock(long start, long end, BufferPositionParser parser)", "class_method_signature": "RangeBasedReaderWriterLock.acquireWriterLock(long start, long end, BufferPositionParser parser)", "testcase": false, "constructor": false}, {"identifier": "releaseWriterLock", "parameters": "(BufferPositionParser parser)", "modifiers": "public", "return": "void", "signature": "void releaseWriterLock(BufferPositionParser parser)", "full_signature": "public void releaseWriterLock(BufferPositionParser parser)", "class_method_signature": "RangeBasedReaderWriterLock.releaseWriterLock(BufferPositionParser parser)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "(BufferPositionParser parser, boolean doSort)", "modifiers": "public", "return": "String", "signature": "String toString(BufferPositionParser parser, boolean doSort)", "full_signature": "public String toString(BufferPositionParser parser, boolean doSort)", "class_method_signature": "RangeBasedReaderWriterLock.toString(BufferPositionParser parser, boolean doSort)", "testcase": false, "constructor": false}, {"identifier": "getReaderRanges", "parameters": "()", "modifiers": "", "return": "PriorityQueue<LockToken>", "signature": "PriorityQueue<LockToken> getReaderRanges()", "full_signature": " PriorityQueue<LockToken> getReaderRanges()", "class_method_signature": "RangeBasedReaderWriterLock.getReaderRanges()", "testcase": false, "constructor": false}, {"identifier": "isWriterIn", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isWriterIn()", "full_signature": "public boolean isWriterIn()", "class_method_signature": "RangeBasedReaderWriterLock.isWriterIn()", "testcase": false, "constructor": false}, {"identifier": "isWriterWaiting", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isWriterWaiting()", "full_signature": "public boolean isWriterWaiting()", "class_method_signature": "RangeBasedReaderWriterLock.isWriterWaiting()", "testcase": false, "constructor": false}, {"identifier": "getWriterRange", "parameters": "()", "modifiers": "public", "return": "Range", "signature": "Range getWriterRange()", "full_signature": "public Range getWriterRange()", "class_method_signature": "RangeBasedReaderWriterLock.getWriterRange()", "testcase": false, "constructor": false}, {"identifier": "getNumReaders", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getNumReaders()", "full_signature": "public int getNumReaders()", "class_method_signature": "RangeBasedReaderWriterLock.getNumReaders()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "RangeBasedReaderWriterLock.toString()", "testcase": false, "constructor": false}], "file": "databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/util/RangeBasedReaderWriterLock.java"}, "focal_method": {"identifier": "acquireWriterLock", "parameters": "(long start, long end, BufferPositionParser parser)", "modifiers": "public", "return": "void", "body": "public void acquireWriterLock(long start, long end, BufferPositionParser parser)\n         throws InterruptedException, TimeoutException\n  {\n    long startOffset = parser.address(start);\n    long endOffset = parser.address(end);\n\n    boolean debug = LOG.isDebugEnabled();\n\n    if (debug)\n      LOG.debug(\"Acquiring writer lock from \" + parser.toString(start) + \" to \" + parser.toString(end));\n\n    mutex.lock();\n\n    try\n    {\n        boolean timeout = false;\n        while (!readerRanges.isEmpty() &&\n                Range.contains(startOffset, endOffset, parser.address(readerRanges.peek()._id.start)))\n        {\n          if ( debug )\n          {\n        \t  LOG.debug(\"Entering wait because reader(s) exist: Writer Range: [\"\n        \t\t\t  + parser.toString(start) + \"(Address:\" +  parser.toString(startOffset) + \")-\"\n        \t\t\t  + parser.toString(end) + \"(Address:\" + parser.toString(endOffset) +\n        \t\t\t  \")]. Nearest Reader Range :\" + readerRanges.peek().toString(parser));\n          }\n          if (timeout)\n          {\n            LOG.error(\"timed out waiting for a write lock for [\" + parser.toString(start) +\n                      \",\" + parser.toString(end) + \"); this: \" + this );\n            throw new TimeoutException();\n          }\n\n          for (LockToken token: readerRanges)\n          {\n            LOG.info(token.toString(parser));\n          }\n          writerWaiting = true;\n          if (!writesPossible.await(MAX_LOCK_WAIT_MS, TimeUnit.MILLISECONDS))\n            timeout = true;\n\n          if ( debug )\n            LOG.debug(\"Writer coming out of wait\");\n        }\n      writerWaiting = false;\n      writerIn = true;\n      writerRange.start = start;\n      writerRange.end = end;\n    }\n    finally\n    {\n      mutex.unlock();\n    }\n\n  }", "signature": "void acquireWriterLock(long start, long end, BufferPositionParser parser)", "full_signature": "public void acquireWriterLock(long start, long end, BufferPositionParser parser)", "class_method_signature": "RangeBasedReaderWriterLock.acquireWriterLock(long start, long end, BufferPositionParser parser)", "testcase": false, "constructor": false, "invocations": ["address", "address", "isDebugEnabled", "debug", "toString", "toString", "lock", "isEmpty", "contains", "address", "peek", "debug", "toString", "toString", "toString", "toString", "toString", "peek", "error", "toString", "toString", "info", "toString", "await", "debug", "unlock"]}, "repository": {"repo_id": 7209229, "url": "https://github.com/linkedin/databus", "language": "Java", "is_fork": false, "fork_count": 653, "stargazer_count": 2899, "size": 51191, "license": "licensed"}}