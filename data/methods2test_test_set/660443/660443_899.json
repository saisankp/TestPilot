{"test_class": {"identifier": "CrossoverMachineTest", "superclass": "extends CDKTestCase", "interfaces": "", "fields": [], "file": "tool/structgen/src/test/java/org/openscience/cdk/structgen/stochastic/operator/CrossoverMachineTest.java"}, "test_case": {"identifier": "testdoCrossover_IAtomContainer", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testdoCrossover_IAtomContainer() throws Exception {\n        String filename = \"data/smiles/c10h16isomers.smi\";\n        InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename);\n        SMILESReader reader = new SMILESReader(ins);\n        IAtomContainerSet som = reader.read(new AtomContainerSet());\n        Assert.assertEquals(\"We must have read 99 structures\", 99, som.getAtomContainerCount());\n        CrossoverMachine cm = new CrossoverMachine();\n        String correctFormula = \"C10H16\";\n        int errorcount = 0;\n        for (int i = 0; i < som.getAtomContainerCount(); i++) {\n            int[] hydrogencount1 = new int[4];\n            for (IAtom atom : som.getAtomContainer(i).atoms()) {\n                hydrogencount1[atom.getImplicitHydrogenCount()]++;\n            }\n            for (int k = i + 1; k < som.getAtomContainerCount(); k++) {\n                try {\n                    List<IAtomContainer> result = cm.doCrossover(som.getAtomContainer(i), som.getAtomContainer(k));\n                    int[] hydrogencount2 = new int[4];\n                    for (IAtom atom : som.getAtomContainer(k).atoms()) {\n                        hydrogencount2[atom.getImplicitHydrogenCount()]++;\n                    }\n                    Assert.assertEquals(\"Result size must be 2\", 2, result.size());\n                    for (int l = 0; l < 2; l++) {\n                        IAtomContainer ac = result.get(l);\n                        Assert.assertTrue(\"Result must be connected\", ConnectivityChecker.isConnected(ac));\n                        Assert.assertEquals(\"Molecular formula must be the same as\" + \"of the input\",\n                                MolecularFormulaManipulator.getString(MolecularFormulaManipulator\n                                        .getMolecularFormula(ac)), correctFormula);\n                        int[] hydrogencountresult = new int[4];\n                        int hcounttotal = 0;\n                        for (IAtom atom : result.get(l).atoms()) {\n                            hydrogencountresult[atom.getImplicitHydrogenCount()]++;\n                            hcounttotal += atom.getImplicitHydrogenCount();\n                        }\n                        if (hydrogencount1[0] == hydrogencount2[0])\n                            Assert.assertEquals(\"Hydrogen count of the result must\" + \" be same as of input\",\n                                    hydrogencount1[0], hydrogencountresult[0]);\n                        if (hydrogencount1[1] == hydrogencount2[1])\n                            Assert.assertEquals(\"Hydrogen count of the result must\" + \" be same as of input\",\n                                    hydrogencount1[1], hydrogencountresult[1]);\n                        if (hydrogencount1[2] == hydrogencount2[2])\n                            Assert.assertEquals(\"Hydrogen count of the result must\" + \" be same as of input\",\n                                    hydrogencount1[2], hydrogencountresult[2]);\n                        if (hydrogencount1[3] == hydrogencount2[3])\n                            Assert.assertEquals(\"Hydrogen count of the result must\" + \" be same as of input\",\n                                    hydrogencount1[3], hydrogencountresult[3]);\n                        Assert.assertEquals(16, hcounttotal);\n                    }\n                } catch (CDKException ex) {\n                    errorcount++;\n                }\n            }\n        }\n        Assert.assertTrue(\"We tolerate up to 300 errors\", errorcount < 300);\n    }", "signature": "void testdoCrossover_IAtomContainer()", "full_signature": "@Test public void testdoCrossover_IAtomContainer()", "class_method_signature": "CrossoverMachineTest.testdoCrossover_IAtomContainer()", "testcase": true, "constructor": false, "invocations": ["getResourceAsStream", "getClassLoader", "getClass", "read", "assertEquals", "getAtomContainerCount", "getAtomContainerCount", "atoms", "getAtomContainer", "getImplicitHydrogenCount", "getAtomContainerCount", "doCrossover", "getAtomContainer", "getAtomContainer", "atoms", "getAtomContainer", "getImplicitHydrogenCount", "assertEquals", "size", "get", "assertTrue", "isConnected", "assertEquals", "getString", "getMolecularFormula", "atoms", "get", "getImplicitHydrogenCount", "getImplicitHydrogenCount", "assertEquals", "assertEquals", "assertEquals", "assertEquals", "assertEquals", "assertTrue"]}, "focal_class": {"identifier": "CrossoverMachine", "superclass": "", "interfaces": "", "fields": [{"original_string": "PartialFilledStructureMerger pfsm;", "modifier": "", "type": "PartialFilledStructureMerger", "declarator": "pfsm", "var_name": "pfsm"}, {"original_string": "int                          splitMode                = 2;", "modifier": "", "type": "int", "declarator": "splitMode                = 2", "var_name": "splitMode"}, {"original_string": "int                          numatoms                 = 5;", "modifier": "", "type": "int", "declarator": "numatoms                 = 5", "var_name": "numatoms"}, {"original_string": "public static final int      SPLIT_MODE_RADNDOM       = 0;", "modifier": "public static final", "type": "int", "declarator": "SPLIT_MODE_RADNDOM       = 0", "var_name": "SPLIT_MODE_RADNDOM"}, {"original_string": "public static final int      SPLIT_MODE_DEPTH_FIRST   = 1;", "modifier": "public static final", "type": "int", "declarator": "SPLIT_MODE_DEPTH_FIRST   = 1", "var_name": "SPLIT_MODE_DEPTH_FIRST"}, {"original_string": "public static final int      SPLIT_MODE_BREADTH_FIRST = 2;", "modifier": "public static final", "type": "int", "declarator": "SPLIT_MODE_BREADTH_FIRST = 2", "var_name": "SPLIT_MODE_BREADTH_FIRST"}], "methods": [{"identifier": "CrossoverMachine", "parameters": "()", "modifiers": "public", "return": "", "signature": " CrossoverMachine()", "full_signature": "public  CrossoverMachine()", "class_method_signature": "CrossoverMachine.CrossoverMachine()", "testcase": false, "constructor": true}, {"identifier": "doCrossover", "parameters": "(IAtomContainer dad, IAtomContainer mom)", "modifiers": "public", "return": "List<IAtomContainer>", "signature": "List<IAtomContainer> doCrossover(IAtomContainer dad, IAtomContainer mom)", "full_signature": "public List<IAtomContainer> doCrossover(IAtomContainer dad, IAtomContainer mom)", "class_method_signature": "CrossoverMachine.doCrossover(IAtomContainer dad, IAtomContainer mom)", "testcase": false, "constructor": false}], "file": "tool/structgen/src/main/java/org/openscience/cdk/structgen/stochastic/operator/CrossoverMachine.java"}, "focal_method": {"identifier": "doCrossover", "parameters": "(IAtomContainer dad, IAtomContainer mom)", "modifiers": "public", "return": "List<IAtomContainer>", "body": "public List<IAtomContainer> doCrossover(IAtomContainer dad, IAtomContainer mom) throws CDKException {\n        int tries = 0;\n        while (true) {\n            int dim = dad.getAtomCount();\n            IAtomContainer[] redChild = new IAtomContainer[2];\n            IAtomContainer[] blueChild = new IAtomContainer[2];\n\n            List<Integer> redAtoms = new ArrayList<Integer>();\n            List<Integer> blueAtoms = new ArrayList<Integer>();\n\n            /* *randomly divide atoms into two parts: redAtoms and blueAtoms.** */\n            if (splitMode == SPLIT_MODE_RADNDOM) {\n                /*\n                 * better way to randomly divide atoms into two parts: redAtoms\n                 * and blueAtoms.\n                 */\n                for (int i = 0; i < dim; i++)\n                    redAtoms.add(Integer.valueOf(i));\n                for (int i = 0; i < (dim - numatoms); i++) {\n                    int ranInt = RandomNumbersTool.randomInt(0, redAtoms.size() - 1);\n                    redAtoms.remove(Integer.valueOf(ranInt));\n                    blueAtoms.add(Integer.valueOf(ranInt));\n                }\n\n            } else {\n                /* split graph using depth/breadth first traverse */\n                ChemGraph graph = new ChemGraph(dad);\n                graph.setNumAtoms(numatoms);\n                if (splitMode == SPLIT_MODE_DEPTH_FIRST) {\n                    redAtoms = graph.pickDFgraph();\n                } else {\n                    //this is SPLIT_MODE_BREADTH_FIRST\n                    redAtoms = graph.pickBFgraph();\n                }\n\n                for (int i = 0; i < dim; i++) {\n                    Integer element = Integer.valueOf(i);\n                    if (!(redAtoms.contains(element))) {\n                        blueAtoms.add(element);\n                    }\n                }\n            }\n            /* * dividing over ** */\n            redChild[0] = dad.getBuilder().newInstance(IAtomContainer.class, dad);\n            blueChild[0] = dad.getBuilder().newInstance(IAtomContainer.class, dad);\n            redChild[1] = dad.getBuilder().newInstance(IAtomContainer.class, mom);\n            blueChild[1] = dad.getBuilder().newInstance(IAtomContainer.class, mom);\n\n            List<IAtom> blueAtomsInRedChild0 = new ArrayList<IAtom>();\n            for (int j = 0; j < blueAtoms.size(); j++) {\n                blueAtomsInRedChild0.add(redChild[0].getAtom((Integer) blueAtoms.get(j)));\n            }\n            for (int j = 0; j < blueAtomsInRedChild0.size(); j++) {\n                redChild[0].removeAtom(blueAtomsInRedChild0.get(j));\n            }\n            List<IAtom> blueAtomsInRedChild1 = new ArrayList<IAtom>();\n            for (int j = 0; j < blueAtoms.size(); j++) {\n                blueAtomsInRedChild1.add(redChild[1].getAtom((Integer) blueAtoms.get(j)));\n            }\n            for (int j = 0; j < blueAtomsInRedChild1.size(); j++) {\n                redChild[1].removeAtom(blueAtomsInRedChild1.get(j));\n            }\n            List<IAtom> redAtomsInBlueChild0 = new ArrayList<IAtom>();\n            for (int j = 0; j < redAtoms.size(); j++) {\n                redAtomsInBlueChild0.add(blueChild[0].getAtom((Integer) redAtoms.get(j)));\n            }\n            for (int j = 0; j < redAtomsInBlueChild0.size(); j++) {\n                blueChild[0].removeAtom(redAtomsInBlueChild0.get(j));\n            }\n            List<IAtom> redAtomsInBlueChild1 = new ArrayList<IAtom>();\n            for (int j = 0; j < redAtoms.size(); j++) {\n                redAtomsInBlueChild1.add(blueChild[1].getAtom((Integer) redAtoms.get(j)));\n            }\n            for (int j = 0; j < redAtomsInBlueChild1.size(); j++) {\n                blueChild[1].removeAtom(redAtomsInBlueChild1.get(j));\n            }\n            //if the two fragments of one and only one parent have an uneven number\n            //of attachment points, we need to rearrange them\n            SaturationChecker satCheck = new SaturationChecker();\n            double red1attachpoints = 0;\n            for (int i = 0; i < redChild[0].getAtomCount(); i++) {\n                red1attachpoints += satCheck.getCurrentMaxBondOrder(redChild[0].getAtom(i), redChild[0]);\n            }\n            double red2attachpoints = 0;\n            for (int i = 0; i < redChild[1].getAtomCount(); i++) {\n                red2attachpoints += satCheck.getCurrentMaxBondOrder(redChild[1].getAtom(i), redChild[1]);\n            }\n            boolean isok = true;\n            if (red1attachpoints % 2 == 1 ^ red2attachpoints % 2 == 1) {\n                isok = false;\n                IAtomContainer firstToBalance = redChild[1];\n                IAtomContainer secondToBalance = blueChild[0];\n                if (red1attachpoints % 2 == 1) {\n                    firstToBalance = redChild[0];\n                    secondToBalance = blueChild[1];\n                }\n                //we need an atom which has\n                //- an uneven number of \"attachment points\" and\n                //- an even number of outgoing bonds\n                for (IAtom atom : firstToBalance.atoms()) {\n                    if (satCheck.getCurrentMaxBondOrder(atom, firstToBalance) % 2 == 1\n                            && firstToBalance.getBondOrderSum(atom) % 2 == 0) {\n                        //we remove this from it's current container and add it to the other one\n                        firstToBalance.removeAtom(atom);\n                        secondToBalance.addAtom(atom);\n                        isok = true;\n                        break;\n                    }\n                }\n            }\n            //if we have combinable fragments\n            if (isok) {\n                //combine the fragments crosswise\n                IAtomContainerSet[] newstrucs = new IAtomContainerSet[2];\n                newstrucs[0] = dad.getBuilder().newInstance(IAtomContainerSet.class);\n                newstrucs[0].add(ConnectivityChecker.partitionIntoMolecules(redChild[0]));\n                newstrucs[0].add(ConnectivityChecker.partitionIntoMolecules(blueChild[1]));\n                newstrucs[1] = dad.getBuilder().newInstance(IAtomContainerSet.class);\n                newstrucs[1].add(ConnectivityChecker.partitionIntoMolecules(redChild[1]));\n                newstrucs[1].add(ConnectivityChecker.partitionIntoMolecules(blueChild[0]));\n\n                //and merge\n                List<IAtomContainer> children = new ArrayList<IAtomContainer>(2);\n                for (int f = 0; f < 2; f++) {\n                    try {\n                        children.add(f, pfsm.generate(newstrucs[f]));\n                    } catch (Exception ex) {\n                        //if children are not correct, the outer loop will repeat,\n                        //so we ignore this\n                    }\n                }\n                if (children.size() == 2 && ConnectivityChecker.isConnected(children.get(0))\n                        && ConnectivityChecker.isConnected(children.get(1))) return children;\n            }\n            tries++;\n            if (tries > 20) throw new CDKException(\"Could not mate these properly\");\n        }\n    }", "signature": "List<IAtomContainer> doCrossover(IAtomContainer dad, IAtomContainer mom)", "full_signature": "public List<IAtomContainer> doCrossover(IAtomContainer dad, IAtomContainer mom)", "class_method_signature": "CrossoverMachine.doCrossover(IAtomContainer dad, IAtomContainer mom)", "testcase": false, "constructor": false, "invocations": ["getAtomCount", "add", "valueOf", "randomInt", "size", "remove", "valueOf", "add", "valueOf", "setNumAtoms", "pickDFgraph", "pickBFgraph", "valueOf", "contains", "add", "newInstance", "getBuilder", "newInstance", "getBuilder", "newInstance", "getBuilder", "newInstance", "getBuilder", "size", "add", "getAtom", "get", "size", "removeAtom", "get", "size", "add", "getAtom", "get", "size", "removeAtom", "get", "size", "add", "getAtom", "get", "size", "removeAtom", "get", "size", "add", "getAtom", "get", "size", "removeAtom", "get", "getAtomCount", "getCurrentMaxBondOrder", "getAtom", "getAtomCount", "getCurrentMaxBondOrder", "getAtom", "atoms", "getCurrentMaxBondOrder", "getBondOrderSum", "removeAtom", "addAtom", "newInstance", "getBuilder", "add", "partitionIntoMolecules", "add", "partitionIntoMolecules", "newInstance", "getBuilder", "add", "partitionIntoMolecules", "add", "partitionIntoMolecules", "add", "generate", "size", "isConnected", "get", "isConnected", "get"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}