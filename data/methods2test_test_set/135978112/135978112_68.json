{"test_class": {"identifier": "AbstractHerderTest", "superclass": "extends EasyMockSupport", "interfaces": "", "fields": [], "file": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/AbstractHerderTest.java"}, "test_case": {"identifier": "connectorStatus", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void connectorStatus() {\n        Worker worker = null;\n        String workerId = \"workerId\";\n        String connector = \"connector\";\n        int generation = 5;\n        ConnectorTaskId taskId = new ConnectorTaskId(connector, 0);\n\n        ConfigBackingStore configStore = strictMock(ConfigBackingStore.class);\n        StatusBackingStore statusStore = strictMock(StatusBackingStore.class);\n\n        AbstractHerder herder = partialMockBuilder(AbstractHerder.class)\n                .withConstructor(Worker.class, String.class, StatusBackingStore.class, ConfigBackingStore.class)\n                .withArgs(worker, workerId, statusStore, configStore)\n                .addMockedMethod(\"generation\")\n                .createMock();\n\n        EasyMock.expect(herder.generation()).andStubReturn(generation);\n\n        EasyMock.expect(statusStore.get(connector))\n                .andReturn(new ConnectorStatus(connector, AbstractStatus.State.RUNNING, workerId, generation));\n\n        EasyMock.expect(statusStore.getAll(connector))\n                .andReturn(Collections.singletonList(\n                        new TaskStatus(taskId, AbstractStatus.State.UNASSIGNED, workerId, generation)));\n\n        replayAll();\n\n\n        ConnectorStateInfo state = herder.connectorStatus(connector);\n\n        assertEquals(connector, state.name());\n        assertEquals(\"RUNNING\", state.connector().state());\n        assertEquals(1, state.tasks().size());\n        assertEquals(workerId, state.connector().workerId());\n\n        ConnectorStateInfo.TaskState taskState = state.tasks().get(0);\n        assertEquals(0, taskState.id());\n        assertEquals(\"UNASSIGNED\", taskState.state());\n        assertEquals(workerId, taskState.workerId());\n\n        verifyAll();\n    }", "signature": "void connectorStatus()", "full_signature": "@Test public void connectorStatus()", "class_method_signature": "AbstractHerderTest.connectorStatus()", "testcase": true, "constructor": false, "invocations": ["strictMock", "strictMock", "createMock", "addMockedMethod", "withArgs", "withConstructor", "partialMockBuilder", "andStubReturn", "expect", "generation", "andReturn", "expect", "get", "andReturn", "expect", "getAll", "singletonList", "replayAll", "connectorStatus", "assertEquals", "name", "assertEquals", "state", "connector", "assertEquals", "size", "tasks", "assertEquals", "workerId", "connector", "get", "tasks", "assertEquals", "id", "assertEquals", "state", "assertEquals", "workerId", "verifyAll"]}, "focal_class": {"identifier": "AbstractHerder", "superclass": "", "interfaces": "implements Herder, TaskStatus.Listener, ConnectorStatus.Listener", "fields": [{"original_string": "private final String workerId;", "modifier": "private final", "type": "String", "declarator": "workerId", "var_name": "workerId"}, {"original_string": "protected final Worker worker;", "modifier": "protected final", "type": "Worker", "declarator": "worker", "var_name": "worker"}, {"original_string": "protected final StatusBackingStore statusBackingStore;", "modifier": "protected final", "type": "StatusBackingStore", "declarator": "statusBackingStore", "var_name": "statusBackingStore"}, {"original_string": "protected final ConfigBackingStore configBackingStore;", "modifier": "protected final", "type": "ConfigBackingStore", "declarator": "configBackingStore", "var_name": "configBackingStore"}, {"original_string": "private Map<String, Connector> tempConnectors = new ConcurrentHashMap<>();", "modifier": "private", "type": "Map<String, Connector>", "declarator": "tempConnectors = new ConcurrentHashMap<>()", "var_name": "tempConnectors"}, {"original_string": "private static List<ConnectorPluginInfo> validConnectorPlugins;", "modifier": "private static", "type": "List<ConnectorPluginInfo>", "declarator": "validConnectorPlugins", "var_name": "validConnectorPlugins"}, {"original_string": "private static final Object LOCK = new Object();", "modifier": "private static final", "type": "Object", "declarator": "LOCK = new Object()", "var_name": "LOCK"}, {"original_string": "private Thread classPathTraverser;", "modifier": "private", "type": "Thread", "declarator": "classPathTraverser", "var_name": "classPathTraverser"}, {"original_string": "private static final List<Class<? extends Connector>> EXCLUDES = Arrays.asList(\n            VerifiableSourceConnector.class, VerifiableSinkConnector.class,\n            MockConnector.class, MockSourceConnector.class, MockSinkConnector.class);", "modifier": "private static final", "type": "List<Class<? extends Connector>>", "declarator": "EXCLUDES = Arrays.asList(\n            VerifiableSourceConnector.class, VerifiableSinkConnector.class,\n            MockConnector.class, MockSourceConnector.class, MockSinkConnector.class)", "var_name": "EXCLUDES"}], "methods": [{"identifier": "AbstractHerder", "parameters": "(Worker worker,\n                          String workerId,\n                          StatusBackingStore statusBackingStore,\n                          ConfigBackingStore configBackingStore)", "modifiers": "public", "return": "", "signature": " AbstractHerder(Worker worker,\n                          String workerId,\n                          StatusBackingStore statusBackingStore,\n                          ConfigBackingStore configBackingStore)", "full_signature": "public  AbstractHerder(Worker worker,\n                          String workerId,\n                          StatusBackingStore statusBackingStore,\n                          ConfigBackingStore configBackingStore)", "class_method_signature": "AbstractHerder.AbstractHerder(Worker worker,\n                          String workerId,\n                          StatusBackingStore statusBackingStore,\n                          ConfigBackingStore configBackingStore)", "testcase": false, "constructor": true}, {"identifier": "generation", "parameters": "()", "modifiers": "protected abstract", "return": "int", "signature": "int generation()", "full_signature": "protected abstract int generation()", "class_method_signature": "AbstractHerder.generation()", "testcase": false, "constructor": false}, {"identifier": "startServices", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void startServices()", "full_signature": "protected void startServices()", "class_method_signature": "AbstractHerder.startServices()", "testcase": false, "constructor": false}, {"identifier": "stopServices", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void stopServices()", "full_signature": "protected void stopServices()", "class_method_signature": "AbstractHerder.stopServices()", "testcase": false, "constructor": false}, {"identifier": "onStartup", "parameters": "(String connector)", "modifiers": "@Override public", "return": "void", "signature": "void onStartup(String connector)", "full_signature": "@Override public void onStartup(String connector)", "class_method_signature": "AbstractHerder.onStartup(String connector)", "testcase": false, "constructor": false}, {"identifier": "onPause", "parameters": "(String connector)", "modifiers": "@Override public", "return": "void", "signature": "void onPause(String connector)", "full_signature": "@Override public void onPause(String connector)", "class_method_signature": "AbstractHerder.onPause(String connector)", "testcase": false, "constructor": false}, {"identifier": "onResume", "parameters": "(String connector)", "modifiers": "@Override public", "return": "void", "signature": "void onResume(String connector)", "full_signature": "@Override public void onResume(String connector)", "class_method_signature": "AbstractHerder.onResume(String connector)", "testcase": false, "constructor": false}, {"identifier": "onShutdown", "parameters": "(String connector)", "modifiers": "@Override public", "return": "void", "signature": "void onShutdown(String connector)", "full_signature": "@Override public void onShutdown(String connector)", "class_method_signature": "AbstractHerder.onShutdown(String connector)", "testcase": false, "constructor": false}, {"identifier": "onFailure", "parameters": "(String connector, Throwable cause)", "modifiers": "@Override public", "return": "void", "signature": "void onFailure(String connector, Throwable cause)", "full_signature": "@Override public void onFailure(String connector, Throwable cause)", "class_method_signature": "AbstractHerder.onFailure(String connector, Throwable cause)", "testcase": false, "constructor": false}, {"identifier": "onStartup", "parameters": "(ConnectorTaskId id)", "modifiers": "@Override public", "return": "void", "signature": "void onStartup(ConnectorTaskId id)", "full_signature": "@Override public void onStartup(ConnectorTaskId id)", "class_method_signature": "AbstractHerder.onStartup(ConnectorTaskId id)", "testcase": false, "constructor": false}, {"identifier": "onFailure", "parameters": "(ConnectorTaskId id, Throwable cause)", "modifiers": "@Override public", "return": "void", "signature": "void onFailure(ConnectorTaskId id, Throwable cause)", "full_signature": "@Override public void onFailure(ConnectorTaskId id, Throwable cause)", "class_method_signature": "AbstractHerder.onFailure(ConnectorTaskId id, Throwable cause)", "testcase": false, "constructor": false}, {"identifier": "onShutdown", "parameters": "(ConnectorTaskId id)", "modifiers": "@Override public", "return": "void", "signature": "void onShutdown(ConnectorTaskId id)", "full_signature": "@Override public void onShutdown(ConnectorTaskId id)", "class_method_signature": "AbstractHerder.onShutdown(ConnectorTaskId id)", "testcase": false, "constructor": false}, {"identifier": "onResume", "parameters": "(ConnectorTaskId id)", "modifiers": "@Override public", "return": "void", "signature": "void onResume(ConnectorTaskId id)", "full_signature": "@Override public void onResume(ConnectorTaskId id)", "class_method_signature": "AbstractHerder.onResume(ConnectorTaskId id)", "testcase": false, "constructor": false}, {"identifier": "onPause", "parameters": "(ConnectorTaskId id)", "modifiers": "@Override public", "return": "void", "signature": "void onPause(ConnectorTaskId id)", "full_signature": "@Override public void onPause(ConnectorTaskId id)", "class_method_signature": "AbstractHerder.onPause(ConnectorTaskId id)", "testcase": false, "constructor": false}, {"identifier": "onDeletion", "parameters": "(String connector)", "modifiers": "@Override public", "return": "void", "signature": "void onDeletion(String connector)", "full_signature": "@Override public void onDeletion(String connector)", "class_method_signature": "AbstractHerder.onDeletion(String connector)", "testcase": false, "constructor": false}, {"identifier": "pauseConnector", "parameters": "(String connector)", "modifiers": "@Override public", "return": "void", "signature": "void pauseConnector(String connector)", "full_signature": "@Override public void pauseConnector(String connector)", "class_method_signature": "AbstractHerder.pauseConnector(String connector)", "testcase": false, "constructor": false}, {"identifier": "resumeConnector", "parameters": "(String connector)", "modifiers": "@Override public", "return": "void", "signature": "void resumeConnector(String connector)", "full_signature": "@Override public void resumeConnector(String connector)", "class_method_signature": "AbstractHerder.resumeConnector(String connector)", "testcase": false, "constructor": false}, {"identifier": "connectorStatus", "parameters": "(String connName)", "modifiers": "@Override public", "return": "ConnectorStateInfo", "signature": "ConnectorStateInfo connectorStatus(String connName)", "full_signature": "@Override public ConnectorStateInfo connectorStatus(String connName)", "class_method_signature": "AbstractHerder.connectorStatus(String connName)", "testcase": false, "constructor": false}, {"identifier": "taskStatus", "parameters": "(ConnectorTaskId id)", "modifiers": "@Override public", "return": "ConnectorStateInfo.TaskState", "signature": "ConnectorStateInfo.TaskState taskStatus(ConnectorTaskId id)", "full_signature": "@Override public ConnectorStateInfo.TaskState taskStatus(ConnectorTaskId id)", "class_method_signature": "AbstractHerder.taskStatus(ConnectorTaskId id)", "testcase": false, "constructor": false}, {"identifier": "validateConfigs", "parameters": "(String connType, Map<String, String> connectorConfig)", "modifiers": "@Override public", "return": "ConfigInfos", "signature": "ConfigInfos validateConfigs(String connType, Map<String, String> connectorConfig)", "full_signature": "@Override public ConfigInfos validateConfigs(String connType, Map<String, String> connectorConfig)", "class_method_signature": "AbstractHerder.validateConfigs(String connType, Map<String, String> connectorConfig)", "testcase": false, "constructor": false}, {"identifier": "connectorPlugins", "parameters": "()", "modifiers": "public static", "return": "List<ConnectorPluginInfo>", "signature": "List<ConnectorPluginInfo> connectorPlugins()", "full_signature": "public static List<ConnectorPluginInfo> connectorPlugins()", "class_method_signature": "AbstractHerder.connectorPlugins()", "testcase": false, "constructor": false}, {"identifier": "generateResult", "parameters": "(String connType, Map<String, ConfigKey> configKeys, List<ConfigValue> configValues, List<String> groups)", "modifiers": "public static", "return": "ConfigInfos", "signature": "ConfigInfos generateResult(String connType, Map<String, ConfigKey> configKeys, List<ConfigValue> configValues, List<String> groups)", "full_signature": "public static ConfigInfos generateResult(String connType, Map<String, ConfigKey> configKeys, List<ConfigValue> configValues, List<String> groups)", "class_method_signature": "AbstractHerder.generateResult(String connType, Map<String, ConfigKey> configKeys, List<ConfigValue> configValues, List<String> groups)", "testcase": false, "constructor": false}, {"identifier": "convertConfigKey", "parameters": "(ConfigKey configKey)", "modifiers": "private static", "return": "ConfigKeyInfo", "signature": "ConfigKeyInfo convertConfigKey(ConfigKey configKey)", "full_signature": "private static ConfigKeyInfo convertConfigKey(ConfigKey configKey)", "class_method_signature": "AbstractHerder.convertConfigKey(ConfigKey configKey)", "testcase": false, "constructor": false}, {"identifier": "convertConfigValue", "parameters": "(ConfigValue configValue, Type type)", "modifiers": "private static", "return": "ConfigValueInfo", "signature": "ConfigValueInfo convertConfigValue(ConfigValue configValue, Type type)", "full_signature": "private static ConfigValueInfo convertConfigValue(ConfigValue configValue, Type type)", "class_method_signature": "AbstractHerder.convertConfigValue(ConfigValue configValue, Type type)", "testcase": false, "constructor": false}, {"identifier": "getConnector", "parameters": "(String connType)", "modifiers": "private", "return": "Connector", "signature": "Connector getConnector(String connType)", "full_signature": "private Connector getConnector(String connType)", "class_method_signature": "AbstractHerder.getConnector(String connType)", "testcase": false, "constructor": false}, {"identifier": "trace", "parameters": "(Throwable t)", "modifiers": "private", "return": "String", "signature": "String trace(Throwable t)", "full_signature": "private String trace(Throwable t)", "class_method_signature": "AbstractHerder.trace(Throwable t)", "testcase": false, "constructor": false}, {"identifier": "traverseClassPath", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void traverseClassPath()", "full_signature": "private void traverseClassPath()", "class_method_signature": "AbstractHerder.traverseClassPath()", "testcase": false, "constructor": false}], "file": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/AbstractHerder.java"}, "focal_method": {"identifier": "connectorStatus", "parameters": "(String connName)", "modifiers": "@Override public", "return": "ConnectorStateInfo", "body": "@Override\n    public ConnectorStateInfo connectorStatus(String connName) {\n        ConnectorStatus connector = statusBackingStore.get(connName);\n        if (connector == null)\n            throw new NotFoundException(\"No status found for connector \" + connName);\n\n        Collection<TaskStatus> tasks = statusBackingStore.getAll(connName);\n\n        ConnectorStateInfo.ConnectorState connectorState = new ConnectorStateInfo.ConnectorState(\n                connector.state().toString(), connector.workerId(), connector.trace());\n        List<ConnectorStateInfo.TaskState> taskStates = new ArrayList<>();\n\n        for (TaskStatus status : tasks) {\n            taskStates.add(new ConnectorStateInfo.TaskState(status.id().task(),\n                    status.state().toString(), status.workerId(), status.trace()));\n        }\n\n        Collections.sort(taskStates);\n\n        return new ConnectorStateInfo(connName, connectorState, taskStates);\n    }", "signature": "ConnectorStateInfo connectorStatus(String connName)", "full_signature": "@Override public ConnectorStateInfo connectorStatus(String connName)", "class_method_signature": "AbstractHerder.connectorStatus(String connName)", "testcase": false, "constructor": false, "invocations": ["get", "getAll", "toString", "state", "workerId", "trace", "add", "task", "id", "toString", "state", "workerId", "trace", "sort"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}