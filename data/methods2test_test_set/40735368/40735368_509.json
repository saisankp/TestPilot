{"test_class": {"identifier": "BarnesSurfaceProcessTest", "superclass": "", "interfaces": "", "fields": [], "file": "modules/unsupported/process-feature/src/test/java/org/geotools/process/vector/BarnesSurfaceProcessTest.java"}, "test_case": {"identifier": "testSimpleSurface", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSimpleSurface() {\n\n        ReferencedEnvelope bounds = new ReferencedEnvelope(0, 30, 0, 30, DefaultGeographicCRS.WGS84);\n        Coordinate[] data = new Coordinate[] { \n                new Coordinate(10, 10, 100),\n                new Coordinate(10, 20, 20), \n                new Coordinate(20, 10, 0), \n                new Coordinate(20, 20, 80) };\n        SimpleFeatureCollection fc = createPoints(data, bounds);\n\n        ProgressListener monitor = null;\n\n        BarnesSurfaceProcess process = new BarnesSurfaceProcess();\n        GridCoverage2D cov = process.execute(fc, // data\n                \"value\", // valueAttr\n                1000, // dataLimit\n                10.0, // scale\n                (Double) null, // convergence\n                (Integer) 2, // passes\n                (Integer) null, // minObservations\n                (Double) null, // maxObservationDistance\n                -999.0, // noDataValue\n                1, // pixelsPerCell\n                0.0, // queryBuffer\n                bounds, // outputEnv\n                100, // outputWidth\n                100, // outputHeight\n                monitor // monitor)\n        );\n        \n//      System.out.println(coverageValue(cov, 20, 20));\n\n        double ERROR_TOL = 10;\n        \n        for (Coordinate p : data) {\n            float covval = coverageValue(cov, p.x, p.y);\n            double error = Math.abs(p.z - covval);\n            assertTrue(error < ERROR_TOL);\n        }\n\n        assertEquals(1, cov.getSampleDimensions().length);\n        assertEquals(\"values\", cov.getSampleDimensions()[0].getDescription().toString());\n    }", "signature": "void testSimpleSurface()", "full_signature": "@Test public void testSimpleSurface()", "class_method_signature": "BarnesSurfaceProcessTest.testSimpleSurface()", "testcase": true, "constructor": false, "invocations": ["createPoints", "execute", "coverageValue", "abs", "assertTrue", "assertEquals", "getSampleDimensions", "assertEquals", "toString", "getDescription", "getSampleDimensions"]}, "focal_class": {"identifier": "BarnesSurfaceProcess", "superclass": "", "interfaces": "implements VectorProcess", "fields": [{"original_string": "private static final double METRES_PER_DEGREE = 111320;", "modifier": "private static final", "type": "double", "declarator": "METRES_PER_DEGREE = 111320", "var_name": "METRES_PER_DEGREE"}], "methods": [{"identifier": "execute", "parameters": "(\n            \n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n            @DescribeParameter(name = \"valueAttr\", description = \"Name of attribute containing the data value to be interpolated\") String valueAttr,\n            @DescribeParameter(name = \"dataLimit\", description = \"Limit for the number of input features processed\", min=0, max=1) Integer argDataLimit,\n            \n            // process parameters\n            @DescribeParameter(name = \"scale\", description = \"Length scale for the interpolation, in units of the source data CRS\", min=1, max=1) Double argScale,\n            @DescribeParameter(name = \"convergence\", description = \"Convergence factor for refinement (between 0 and 1, default 0.3)\", min=0, max=1, defaultValue=\"0.3\") Double argConvergence,\n            @DescribeParameter(name = \"passes\", description = \"Number of passes to compute (default = 2)\", min=0, max=1) Integer argPasses,\n            @DescribeParameter(name = \"minObservations\", description = \"Minimum number of observations required to support a grid cell (default = 2)\", min=0, max=1, defaultValue=\"2\") Integer argMinObsCount,\n            @DescribeParameter(name = \"maxObservationDistance\", description = \"Maximum distance to an observation for it to support a grid cell, in units of the source CRS (default = 0, meaning all observations used)\", defaultValue=\"0\", min=0, max=1) Double argMaxObsDistance,\n            @DescribeParameter(name = \"noDataValue\", description = \"Value to use for NO_DATA cells (default = -999)\", defaultValue=\"-999\", min=0, max=1) Double argNoDataValue,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution of the computed grid in pixels per grid cell (default = 1)\", defaultValue=\"1\", min=0, max=1) Integer argPixelsPerCell,\n            \n            // query modification parameters\n            @DescribeParameter(name = \"queryBuffer\", description = \"Distance to expand the query envelope by, in units of the source CRS (larger values provide a more stable surface)\", min=0, max=1) Double argQueryBuffer,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box for output\") ReferencedEnvelope outputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster in pixels\") Integer outputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster in pixels\") Integer outputHeight,\n            \n            ProgressListener monitor)", "modifiers": "@DescribeResult(name = \"result\", description = \"Output raster\") public", "return": "GridCoverage2D", "signature": "GridCoverage2D execute(\n            \n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n            @DescribeParameter(name = \"valueAttr\", description = \"Name of attribute containing the data value to be interpolated\") String valueAttr,\n            @DescribeParameter(name = \"dataLimit\", description = \"Limit for the number of input features processed\", min=0, max=1) Integer argDataLimit,\n            \n            // process parameters\n            @DescribeParameter(name = \"scale\", description = \"Length scale for the interpolation, in units of the source data CRS\", min=1, max=1) Double argScale,\n            @DescribeParameter(name = \"convergence\", description = \"Convergence factor for refinement (between 0 and 1, default 0.3)\", min=0, max=1, defaultValue=\"0.3\") Double argConvergence,\n            @DescribeParameter(name = \"passes\", description = \"Number of passes to compute (default = 2)\", min=0, max=1) Integer argPasses,\n            @DescribeParameter(name = \"minObservations\", description = \"Minimum number of observations required to support a grid cell (default = 2)\", min=0, max=1, defaultValue=\"2\") Integer argMinObsCount,\n            @DescribeParameter(name = \"maxObservationDistance\", description = \"Maximum distance to an observation for it to support a grid cell, in units of the source CRS (default = 0, meaning all observations used)\", defaultValue=\"0\", min=0, max=1) Double argMaxObsDistance,\n            @DescribeParameter(name = \"noDataValue\", description = \"Value to use for NO_DATA cells (default = -999)\", defaultValue=\"-999\", min=0, max=1) Double argNoDataValue,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution of the computed grid in pixels per grid cell (default = 1)\", defaultValue=\"1\", min=0, max=1) Integer argPixelsPerCell,\n            \n            // query modification parameters\n            @DescribeParameter(name = \"queryBuffer\", description = \"Distance to expand the query envelope by, in units of the source CRS (larger values provide a more stable surface)\", min=0, max=1) Double argQueryBuffer,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box for output\") ReferencedEnvelope outputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster in pixels\") Integer outputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster in pixels\") Integer outputHeight,\n            \n            ProgressListener monitor)", "full_signature": "@DescribeResult(name = \"result\", description = \"Output raster\") public GridCoverage2D execute(\n            \n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n            @DescribeParameter(name = \"valueAttr\", description = \"Name of attribute containing the data value to be interpolated\") String valueAttr,\n            @DescribeParameter(name = \"dataLimit\", description = \"Limit for the number of input features processed\", min=0, max=1) Integer argDataLimit,\n            \n            // process parameters\n            @DescribeParameter(name = \"scale\", description = \"Length scale for the interpolation, in units of the source data CRS\", min=1, max=1) Double argScale,\n            @DescribeParameter(name = \"convergence\", description = \"Convergence factor for refinement (between 0 and 1, default 0.3)\", min=0, max=1, defaultValue=\"0.3\") Double argConvergence,\n            @DescribeParameter(name = \"passes\", description = \"Number of passes to compute (default = 2)\", min=0, max=1) Integer argPasses,\n            @DescribeParameter(name = \"minObservations\", description = \"Minimum number of observations required to support a grid cell (default = 2)\", min=0, max=1, defaultValue=\"2\") Integer argMinObsCount,\n            @DescribeParameter(name = \"maxObservationDistance\", description = \"Maximum distance to an observation for it to support a grid cell, in units of the source CRS (default = 0, meaning all observations used)\", defaultValue=\"0\", min=0, max=1) Double argMaxObsDistance,\n            @DescribeParameter(name = \"noDataValue\", description = \"Value to use for NO_DATA cells (default = -999)\", defaultValue=\"-999\", min=0, max=1) Double argNoDataValue,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution of the computed grid in pixels per grid cell (default = 1)\", defaultValue=\"1\", min=0, max=1) Integer argPixelsPerCell,\n            \n            // query modification parameters\n            @DescribeParameter(name = \"queryBuffer\", description = \"Distance to expand the query envelope by, in units of the source CRS (larger values provide a more stable surface)\", min=0, max=1) Double argQueryBuffer,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box for output\") ReferencedEnvelope outputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster in pixels\") Integer outputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster in pixels\") Integer outputHeight,\n            \n            ProgressListener monitor)", "class_method_signature": "BarnesSurfaceProcess.execute(\n            \n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n            @DescribeParameter(name = \"valueAttr\", description = \"Name of attribute containing the data value to be interpolated\") String valueAttr,\n            @DescribeParameter(name = \"dataLimit\", description = \"Limit for the number of input features processed\", min=0, max=1) Integer argDataLimit,\n            \n            // process parameters\n            @DescribeParameter(name = \"scale\", description = \"Length scale for the interpolation, in units of the source data CRS\", min=1, max=1) Double argScale,\n            @DescribeParameter(name = \"convergence\", description = \"Convergence factor for refinement (between 0 and 1, default 0.3)\", min=0, max=1, defaultValue=\"0.3\") Double argConvergence,\n            @DescribeParameter(name = \"passes\", description = \"Number of passes to compute (default = 2)\", min=0, max=1) Integer argPasses,\n            @DescribeParameter(name = \"minObservations\", description = \"Minimum number of observations required to support a grid cell (default = 2)\", min=0, max=1, defaultValue=\"2\") Integer argMinObsCount,\n            @DescribeParameter(name = \"maxObservationDistance\", description = \"Maximum distance to an observation for it to support a grid cell, in units of the source CRS (default = 0, meaning all observations used)\", defaultValue=\"0\", min=0, max=1) Double argMaxObsDistance,\n            @DescribeParameter(name = \"noDataValue\", description = \"Value to use for NO_DATA cells (default = -999)\", defaultValue=\"-999\", min=0, max=1) Double argNoDataValue,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution of the computed grid in pixels per grid cell (default = 1)\", defaultValue=\"1\", min=0, max=1) Integer argPixelsPerCell,\n            \n            // query modification parameters\n            @DescribeParameter(name = \"queryBuffer\", description = \"Distance to expand the query envelope by, in units of the source CRS (larger values provide a more stable surface)\", min=0, max=1) Double argQueryBuffer,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box for output\") ReferencedEnvelope outputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster in pixels\") Integer outputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster in pixels\") Integer outputHeight,\n            \n            ProgressListener monitor)", "testcase": false, "constructor": false}, {"identifier": "distanceConversionFactor", "parameters": "(CoordinateReferenceSystem srcCRS,CoordinateReferenceSystem dstCRS)", "modifiers": "private static", "return": "double", "signature": "double distanceConversionFactor(CoordinateReferenceSystem srcCRS,CoordinateReferenceSystem dstCRS)", "full_signature": "private static double distanceConversionFactor(CoordinateReferenceSystem srcCRS,CoordinateReferenceSystem dstCRS)", "class_method_signature": "BarnesSurfaceProcess.distanceConversionFactor(CoordinateReferenceSystem srcCRS,CoordinateReferenceSystem dstCRS)", "testcase": false, "constructor": false}, {"identifier": "flipXY", "parameters": "(float[][] grid)", "modifiers": "private static", "return": "float[][]", "signature": "float[][] flipXY(float[][] grid)", "full_signature": "private static float[][] flipXY(float[][] grid)", "class_method_signature": "BarnesSurfaceProcess.flipXY(float[][] grid)", "testcase": false, "constructor": false}, {"identifier": "createBarnesGrid", "parameters": "(Coordinate[] pts, \n            double lengthScale,\n            double convergenceFactor,\n            int passes,\n            int minObservationCount,\n            double maxObservationDistance,\n            float noDataValue,\n            Envelope destEnv,\n            int width, int height)", "modifiers": "private", "return": "float[][]", "signature": "float[][] createBarnesGrid(Coordinate[] pts, \n            double lengthScale,\n            double convergenceFactor,\n            int passes,\n            int minObservationCount,\n            double maxObservationDistance,\n            float noDataValue,\n            Envelope destEnv,\n            int width, int height)", "full_signature": "private float[][] createBarnesGrid(Coordinate[] pts, \n            double lengthScale,\n            double convergenceFactor,\n            int passes,\n            int minObservationCount,\n            double maxObservationDistance,\n            float noDataValue,\n            Envelope destEnv,\n            int width, int height)", "class_method_signature": "BarnesSurfaceProcess.createBarnesGrid(Coordinate[] pts, \n            double lengthScale,\n            double convergenceFactor,\n            int passes,\n            int minObservationCount,\n            double maxObservationDistance,\n            float noDataValue,\n            Envelope destEnv,\n            int width, int height)", "testcase": false, "constructor": false}, {"identifier": "upsample", "parameters": "(float[][] grid,\n            float noDataValue, \n            int width,\n            int height)", "modifiers": "private", "return": "float[][]", "signature": "float[][] upsample(float[][] grid,\n            float noDataValue, \n            int width,\n            int height)", "full_signature": "private float[][] upsample(float[][] grid,\n            float noDataValue, \n            int width,\n            int height)", "class_method_signature": "BarnesSurfaceProcess.upsample(float[][] grid,\n            float noDataValue, \n            int width,\n            int height)", "testcase": false, "constructor": false}, {"identifier": "invertQuery", "parameters": "(\n            @DescribeParameter(name = \"queryBuffer\", description = \"The distance by which to expand the query window\", min=0, max=1) Double argQueryBuffer,\n            Query targetQuery, GridGeometry targetGridGeometry)", "modifiers": "public", "return": "Query", "signature": "Query invertQuery(\n            @DescribeParameter(name = \"queryBuffer\", description = \"The distance by which to expand the query window\", min=0, max=1) Double argQueryBuffer,\n            Query targetQuery, GridGeometry targetGridGeometry)", "full_signature": "public Query invertQuery(\n            @DescribeParameter(name = \"queryBuffer\", description = \"The distance by which to expand the query window\", min=0, max=1) Double argQueryBuffer,\n            Query targetQuery, GridGeometry targetGridGeometry)", "class_method_signature": "BarnesSurfaceProcess.invertQuery(\n            @DescribeParameter(name = \"queryBuffer\", description = \"The distance by which to expand the query window\", min=0, max=1) Double argQueryBuffer,\n            Query targetQuery, GridGeometry targetGridGeometry)", "testcase": false, "constructor": false}, {"identifier": "expandBBox", "parameters": "(Filter filter, double distance)", "modifiers": "private", "return": "Filter", "signature": "Filter expandBBox(Filter filter, double distance)", "full_signature": "private Filter expandBBox(Filter filter, double distance)", "class_method_signature": "BarnesSurfaceProcess.expandBBox(Filter filter, double distance)", "testcase": false, "constructor": false}, {"identifier": "extractPoints", "parameters": "(SimpleFeatureCollection obsPoints, String attrName, MathTransform trans, int dataLimit)", "modifiers": "public static", "return": "Coordinate[]", "signature": "Coordinate[] extractPoints(SimpleFeatureCollection obsPoints, String attrName, MathTransform trans, int dataLimit)", "full_signature": "public static Coordinate[] extractPoints(SimpleFeatureCollection obsPoints, String attrName, MathTransform trans, int dataLimit)", "class_method_signature": "BarnesSurfaceProcess.extractPoints(SimpleFeatureCollection obsPoints, String attrName, MathTransform trans, int dataLimit)", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/BarnesSurfaceProcess.java"}, "focal_method": {"identifier": "execute", "parameters": "(\n            \n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n            @DescribeParameter(name = \"valueAttr\", description = \"Name of attribute containing the data value to be interpolated\") String valueAttr,\n            @DescribeParameter(name = \"dataLimit\", description = \"Limit for the number of input features processed\", min=0, max=1) Integer argDataLimit,\n            \n            // process parameters\n            @DescribeParameter(name = \"scale\", description = \"Length scale for the interpolation, in units of the source data CRS\", min=1, max=1) Double argScale,\n            @DescribeParameter(name = \"convergence\", description = \"Convergence factor for refinement (between 0 and 1, default 0.3)\", min=0, max=1, defaultValue=\"0.3\") Double argConvergence,\n            @DescribeParameter(name = \"passes\", description = \"Number of passes to compute (default = 2)\", min=0, max=1) Integer argPasses,\n            @DescribeParameter(name = \"minObservations\", description = \"Minimum number of observations required to support a grid cell (default = 2)\", min=0, max=1, defaultValue=\"2\") Integer argMinObsCount,\n            @DescribeParameter(name = \"maxObservationDistance\", description = \"Maximum distance to an observation for it to support a grid cell, in units of the source CRS (default = 0, meaning all observations used)\", defaultValue=\"0\", min=0, max=1) Double argMaxObsDistance,\n            @DescribeParameter(name = \"noDataValue\", description = \"Value to use for NO_DATA cells (default = -999)\", defaultValue=\"-999\", min=0, max=1) Double argNoDataValue,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution of the computed grid in pixels per grid cell (default = 1)\", defaultValue=\"1\", min=0, max=1) Integer argPixelsPerCell,\n            \n            // query modification parameters\n            @DescribeParameter(name = \"queryBuffer\", description = \"Distance to expand the query envelope by, in units of the source CRS (larger values provide a more stable surface)\", min=0, max=1) Double argQueryBuffer,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box for output\") ReferencedEnvelope outputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster in pixels\") Integer outputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster in pixels\") Integer outputHeight,\n            \n            ProgressListener monitor)", "modifiers": "@DescribeResult(name = \"result\", description = \"Output raster\") public", "return": "GridCoverage2D", "body": "@DescribeResult(name = \"result\", description = \"Output raster\")\n    public GridCoverage2D execute(\n            \n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n            @DescribeParameter(name = \"valueAttr\", description = \"Name of attribute containing the data value to be interpolated\") String valueAttr,\n            @DescribeParameter(name = \"dataLimit\", description = \"Limit for the number of input features processed\", min=0, max=1) Integer argDataLimit,\n            \n            // process parameters\n            @DescribeParameter(name = \"scale\", description = \"Length scale for the interpolation, in units of the source data CRS\", min=1, max=1) Double argScale,\n            @DescribeParameter(name = \"convergence\", description = \"Convergence factor for refinement (between 0 and 1, default 0.3)\", min=0, max=1, defaultValue=\"0.3\") Double argConvergence,\n            @DescribeParameter(name = \"passes\", description = \"Number of passes to compute (default = 2)\", min=0, max=1) Integer argPasses,\n            @DescribeParameter(name = \"minObservations\", description = \"Minimum number of observations required to support a grid cell (default = 2)\", min=0, max=1, defaultValue=\"2\") Integer argMinObsCount,\n            @DescribeParameter(name = \"maxObservationDistance\", description = \"Maximum distance to an observation for it to support a grid cell, in units of the source CRS (default = 0, meaning all observations used)\", defaultValue=\"0\", min=0, max=1) Double argMaxObsDistance,\n            @DescribeParameter(name = \"noDataValue\", description = \"Value to use for NO_DATA cells (default = -999)\", defaultValue=\"-999\", min=0, max=1) Double argNoDataValue,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution of the computed grid in pixels per grid cell (default = 1)\", defaultValue=\"1\", min=0, max=1) Integer argPixelsPerCell,\n            \n            // query modification parameters\n            @DescribeParameter(name = \"queryBuffer\", description = \"Distance to expand the query envelope by, in units of the source CRS (larger values provide a more stable surface)\", min=0, max=1) Double argQueryBuffer,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box for output\") ReferencedEnvelope outputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster in pixels\") Integer outputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster in pixels\") Integer outputHeight,\n            \n            ProgressListener monitor) throws ProcessException {\n\n        /**---------------------------------------------\n         * Check that process arguments are valid\n         * ---------------------------------------------\n         */\n        if (valueAttr == null || valueAttr.length() <= 0) {\n            throw new IllegalArgumentException(\"Value attribute must be specified\");\n        }\n\n        /**---------------------------------------------\n         * Set up required information from process arguments.\n         * ---------------------------------------------\n         */\n        int dataLimit = 0;\n        if (argDataLimit != null) dataLimit = argDataLimit;\n        \n        double lengthScale = argScale;\n        double convergenceFactor = argConvergence != null ? argConvergence : 0.3;\n        int passes = argPasses != null ? argPasses : 2;\n        int minObsCount = argMinObsCount != null ? argMinObsCount : 2;\n        double maxObsDistance = argMaxObsDistance != null ? argMaxObsDistance : 0.0;\n        float noDataValue = (float) (argNoDataValue != null ? argNoDataValue : -999);\n        int pixelsPerCell = 1;\n        if (argPixelsPerCell != null && argPixelsPerCell > 1) {\n            pixelsPerCell = argPixelsPerCell;\n        }\n        int gridWidth = outputWidth;\n        int gridHeight = outputHeight;\n        if (pixelsPerCell > 1) {\n            gridWidth = outputWidth / pixelsPerCell;\n            gridHeight = outputHeight / pixelsPerCell;\n        }\n        \n        CoordinateReferenceSystem srcCRS = obsFeatures.getSchema().getCoordinateReferenceSystem();\n        CoordinateReferenceSystem dstCRS = outputEnv.getCoordinateReferenceSystem();\n        MathTransform trans = null;\n        try {\n            trans = CRS.findMathTransform(srcCRS, dstCRS);\n        } catch (FactoryException e) {\n            throw new ProcessException(e);\n        }\n        /**---------------------------------------------\n         * Convert distance parameters to units of the destination CRS.\n         * ---------------------------------------------\n         */\n        double distanceConversionFactor = distanceConversionFactor(srcCRS, dstCRS);\n        double dstLengthScale = lengthScale * distanceConversionFactor;\n        double dstMaxObsDistance = maxObsDistance * distanceConversionFactor;\n\n        /**---------------------------------------------\n         * Extract the input observation points\n         * ---------------------------------------------\n         */\n        Coordinate[] pts = null;\n        try {\n            pts = extractPoints(obsFeatures, valueAttr, trans, dataLimit);\n        } catch (CQLException e) {\n            throw new ProcessException(e);\n        }\n\n        /**---------------------------------------------\n         * Do the processing\n         * ---------------------------------------------\n         */\n        //Stopwatch sw = new Stopwatch();\n        // interpolate the surface at the specified resolution\n        float[][] barnesGrid = createBarnesGrid(pts, dstLengthScale, convergenceFactor, passes, minObsCount, dstMaxObsDistance, noDataValue, outputEnv, gridWidth, gridHeight);\n        \n        // flip now, since grid size may be smaller\n        barnesGrid = flipXY(barnesGrid);\n        \n        // upsample to output resolution if necessary\n        float[][] outGrid = barnesGrid;\n        if (pixelsPerCell > 1)\n            outGrid = upsample(barnesGrid, noDataValue, outputWidth, outputHeight);\n        \n        // convert to the GridCoverage2D required for output\n        GridCoverageFactory gcf = CoverageFactoryFinder.getGridCoverageFactory(GeoTools.getDefaultHints());\n        GridCoverage2D gridCov = gcf.create(\"values\", outGrid, outputEnv);\n        \n        //System.out.println(\"**************  Barnes Surface computed in \" + sw.getTimeString());\n        \n        return gridCov;\n    }", "signature": "GridCoverage2D execute(\n            \n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n            @DescribeParameter(name = \"valueAttr\", description = \"Name of attribute containing the data value to be interpolated\") String valueAttr,\n            @DescribeParameter(name = \"dataLimit\", description = \"Limit for the number of input features processed\", min=0, max=1) Integer argDataLimit,\n            \n            // process parameters\n            @DescribeParameter(name = \"scale\", description = \"Length scale for the interpolation, in units of the source data CRS\", min=1, max=1) Double argScale,\n            @DescribeParameter(name = \"convergence\", description = \"Convergence factor for refinement (between 0 and 1, default 0.3)\", min=0, max=1, defaultValue=\"0.3\") Double argConvergence,\n            @DescribeParameter(name = \"passes\", description = \"Number of passes to compute (default = 2)\", min=0, max=1) Integer argPasses,\n            @DescribeParameter(name = \"minObservations\", description = \"Minimum number of observations required to support a grid cell (default = 2)\", min=0, max=1, defaultValue=\"2\") Integer argMinObsCount,\n            @DescribeParameter(name = \"maxObservationDistance\", description = \"Maximum distance to an observation for it to support a grid cell, in units of the source CRS (default = 0, meaning all observations used)\", defaultValue=\"0\", min=0, max=1) Double argMaxObsDistance,\n            @DescribeParameter(name = \"noDataValue\", description = \"Value to use for NO_DATA cells (default = -999)\", defaultValue=\"-999\", min=0, max=1) Double argNoDataValue,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution of the computed grid in pixels per grid cell (default = 1)\", defaultValue=\"1\", min=0, max=1) Integer argPixelsPerCell,\n            \n            // query modification parameters\n            @DescribeParameter(name = \"queryBuffer\", description = \"Distance to expand the query envelope by, in units of the source CRS (larger values provide a more stable surface)\", min=0, max=1) Double argQueryBuffer,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box for output\") ReferencedEnvelope outputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster in pixels\") Integer outputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster in pixels\") Integer outputHeight,\n            \n            ProgressListener monitor)", "full_signature": "@DescribeResult(name = \"result\", description = \"Output raster\") public GridCoverage2D execute(\n            \n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n            @DescribeParameter(name = \"valueAttr\", description = \"Name of attribute containing the data value to be interpolated\") String valueAttr,\n            @DescribeParameter(name = \"dataLimit\", description = \"Limit for the number of input features processed\", min=0, max=1) Integer argDataLimit,\n            \n            // process parameters\n            @DescribeParameter(name = \"scale\", description = \"Length scale for the interpolation, in units of the source data CRS\", min=1, max=1) Double argScale,\n            @DescribeParameter(name = \"convergence\", description = \"Convergence factor for refinement (between 0 and 1, default 0.3)\", min=0, max=1, defaultValue=\"0.3\") Double argConvergence,\n            @DescribeParameter(name = \"passes\", description = \"Number of passes to compute (default = 2)\", min=0, max=1) Integer argPasses,\n            @DescribeParameter(name = \"minObservations\", description = \"Minimum number of observations required to support a grid cell (default = 2)\", min=0, max=1, defaultValue=\"2\") Integer argMinObsCount,\n            @DescribeParameter(name = \"maxObservationDistance\", description = \"Maximum distance to an observation for it to support a grid cell, in units of the source CRS (default = 0, meaning all observations used)\", defaultValue=\"0\", min=0, max=1) Double argMaxObsDistance,\n            @DescribeParameter(name = \"noDataValue\", description = \"Value to use for NO_DATA cells (default = -999)\", defaultValue=\"-999\", min=0, max=1) Double argNoDataValue,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution of the computed grid in pixels per grid cell (default = 1)\", defaultValue=\"1\", min=0, max=1) Integer argPixelsPerCell,\n            \n            // query modification parameters\n            @DescribeParameter(name = \"queryBuffer\", description = \"Distance to expand the query envelope by, in units of the source CRS (larger values provide a more stable surface)\", min=0, max=1) Double argQueryBuffer,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box for output\") ReferencedEnvelope outputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster in pixels\") Integer outputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster in pixels\") Integer outputHeight,\n            \n            ProgressListener monitor)", "class_method_signature": "BarnesSurfaceProcess.execute(\n            \n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n            @DescribeParameter(name = \"valueAttr\", description = \"Name of attribute containing the data value to be interpolated\") String valueAttr,\n            @DescribeParameter(name = \"dataLimit\", description = \"Limit for the number of input features processed\", min=0, max=1) Integer argDataLimit,\n            \n            // process parameters\n            @DescribeParameter(name = \"scale\", description = \"Length scale for the interpolation, in units of the source data CRS\", min=1, max=1) Double argScale,\n            @DescribeParameter(name = \"convergence\", description = \"Convergence factor for refinement (between 0 and 1, default 0.3)\", min=0, max=1, defaultValue=\"0.3\") Double argConvergence,\n            @DescribeParameter(name = \"passes\", description = \"Number of passes to compute (default = 2)\", min=0, max=1) Integer argPasses,\n            @DescribeParameter(name = \"minObservations\", description = \"Minimum number of observations required to support a grid cell (default = 2)\", min=0, max=1, defaultValue=\"2\") Integer argMinObsCount,\n            @DescribeParameter(name = \"maxObservationDistance\", description = \"Maximum distance to an observation for it to support a grid cell, in units of the source CRS (default = 0, meaning all observations used)\", defaultValue=\"0\", min=0, max=1) Double argMaxObsDistance,\n            @DescribeParameter(name = \"noDataValue\", description = \"Value to use for NO_DATA cells (default = -999)\", defaultValue=\"-999\", min=0, max=1) Double argNoDataValue,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution of the computed grid in pixels per grid cell (default = 1)\", defaultValue=\"1\", min=0, max=1) Integer argPixelsPerCell,\n            \n            // query modification parameters\n            @DescribeParameter(name = \"queryBuffer\", description = \"Distance to expand the query envelope by, in units of the source CRS (larger values provide a more stable surface)\", min=0, max=1) Double argQueryBuffer,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box for output\") ReferencedEnvelope outputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster in pixels\") Integer outputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster in pixels\") Integer outputHeight,\n            \n            ProgressListener monitor)", "testcase": false, "constructor": false, "invocations": ["length", "getCoordinateReferenceSystem", "getSchema", "getCoordinateReferenceSystem", "findMathTransform", "distanceConversionFactor", "extractPoints", "createBarnesGrid", "flipXY", "upsample", "getGridCoverageFactory", "getDefaultHints", "create"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}