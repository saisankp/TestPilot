{"test_class": {"identifier": "RecordAccumulatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private String topic = \"test\";", "modifier": "private", "type": "String", "declarator": "topic = \"test\"", "var_name": "topic"}, {"original_string": "private int partition1 = 0;", "modifier": "private", "type": "int", "declarator": "partition1 = 0", "var_name": "partition1"}, {"original_string": "private int partition2 = 1;", "modifier": "private", "type": "int", "declarator": "partition2 = 1", "var_name": "partition2"}, {"original_string": "private int partition3 = 2;", "modifier": "private", "type": "int", "declarator": "partition3 = 2", "var_name": "partition3"}, {"original_string": "private Node node1 = new Node(0, \"localhost\", 1111);", "modifier": "private", "type": "Node", "declarator": "node1 = new Node(0, \"localhost\", 1111)", "var_name": "node1"}, {"original_string": "private Node node2 = new Node(1, \"localhost\", 1112);", "modifier": "private", "type": "Node", "declarator": "node2 = new Node(1, \"localhost\", 1112)", "var_name": "node2"}, {"original_string": "private TopicPartition tp1 = new TopicPartition(topic, partition1);", "modifier": "private", "type": "TopicPartition", "declarator": "tp1 = new TopicPartition(topic, partition1)", "var_name": "tp1"}, {"original_string": "private TopicPartition tp2 = new TopicPartition(topic, partition2);", "modifier": "private", "type": "TopicPartition", "declarator": "tp2 = new TopicPartition(topic, partition2)", "var_name": "tp2"}, {"original_string": "private TopicPartition tp3 = new TopicPartition(topic, partition3);", "modifier": "private", "type": "TopicPartition", "declarator": "tp3 = new TopicPartition(topic, partition3)", "var_name": "tp3"}, {"original_string": "private PartitionInfo part1 = new PartitionInfo(topic, partition1, node1, null, null);", "modifier": "private", "type": "PartitionInfo", "declarator": "part1 = new PartitionInfo(topic, partition1, node1, null, null)", "var_name": "part1"}, {"original_string": "private PartitionInfo part2 = new PartitionInfo(topic, partition2, node1, null, null);", "modifier": "private", "type": "PartitionInfo", "declarator": "part2 = new PartitionInfo(topic, partition2, node1, null, null)", "var_name": "part2"}, {"original_string": "private PartitionInfo part3 = new PartitionInfo(topic, partition3, node2, null, null);", "modifier": "private", "type": "PartitionInfo", "declarator": "part3 = new PartitionInfo(topic, partition3, node2, null, null)", "var_name": "part3"}, {"original_string": "private MockTime time = new MockTime();", "modifier": "private", "type": "MockTime", "declarator": "time = new MockTime()", "var_name": "time"}, {"original_string": "private SystemTime systemTime = new SystemTime();", "modifier": "private", "type": "SystemTime", "declarator": "systemTime = new SystemTime()", "var_name": "systemTime"}, {"original_string": "private byte[] key = \"key\".getBytes();", "modifier": "private", "type": "byte[]", "declarator": "key = \"key\".getBytes()", "var_name": "key"}, {"original_string": "private byte[] value = \"value\".getBytes();", "modifier": "private", "type": "byte[]", "declarator": "value = \"value\".getBytes()", "var_name": "value"}, {"original_string": "private int msgSize = Records.LOG_OVERHEAD + Record.recordSize(key, value);", "modifier": "private", "type": "int", "declarator": "msgSize = Records.LOG_OVERHEAD + Record.recordSize(key, value)", "var_name": "msgSize"}, {"original_string": "private Cluster cluster = new Cluster(Arrays.asList(node1, node2), Arrays.asList(part1, part2, part3), Collections.<String>emptySet());", "modifier": "private", "type": "Cluster", "declarator": "cluster = new Cluster(Arrays.asList(node1, node2), Arrays.asList(part1, part2, part3), Collections.<String>emptySet())", "var_name": "cluster"}, {"original_string": "private Metrics metrics = new Metrics(time);", "modifier": "private", "type": "Metrics", "declarator": "metrics = new Metrics(time)", "var_name": "metrics"}, {"original_string": "private final long maxBlockTimeMs = 1000;", "modifier": "private final", "type": "long", "declarator": "maxBlockTimeMs = 1000", "var_name": "maxBlockTimeMs"}], "file": "clients/src/test/java/org/apache/kafka/clients/producer/internals/RecordAccumulatorTest.java"}, "test_case": {"identifier": "testAbortIncompleteBatches", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testAbortIncompleteBatches() throws Exception {\n        long lingerMs = Long.MAX_VALUE;\n        final AtomicInteger numExceptionReceivedInCallback = new AtomicInteger(0);\n        final RecordAccumulator accum = new RecordAccumulator(4 * 1024, 64 * 1024, CompressionType.NONE, lingerMs, 100L, metrics, time);\n        class TestCallback implements Callback {\n            @Override\n            public void onCompletion(RecordMetadata metadata, Exception exception) {\n                assertTrue(exception.getMessage().equals(\"Producer is closed forcefully.\"));\n                numExceptionReceivedInCallback.incrementAndGet();\n            }\n        }\n        for (int i = 0; i < 100; i++)\n            accum.append(new TopicPartition(topic, i % 3), 0L, key, value, new TestCallback(), maxBlockTimeMs);\n        RecordAccumulator.ReadyCheckResult result = accum.ready(cluster, time.milliseconds());\n        assertEquals(\"No nodes should be ready.\", 0, result.readyNodes.size());\n\n        accum.abortIncompleteBatches();\n        assertEquals(numExceptionReceivedInCallback.get(), 100);\n        assertFalse(accum.hasUnsent());\n\n    }", "signature": "void testAbortIncompleteBatches()", "full_signature": "@Test public void testAbortIncompleteBatches()", "class_method_signature": "RecordAccumulatorTest.testAbortIncompleteBatches()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "equals", "getMessage", "incrementAndGet", "append", "ready", "milliseconds", "assertEquals", "size", "abortIncompleteBatches", "assertEquals", "get", "assertFalse", "hasUnsent"]}, "focal_class": {"identifier": "RecordAccumulator", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(RecordAccumulator.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(RecordAccumulator.class)", "var_name": "log"}, {"original_string": "private volatile boolean closed;", "modifier": "private volatile", "type": "boolean", "declarator": "closed", "var_name": "closed"}, {"original_string": "private final AtomicInteger flushesInProgress;", "modifier": "private final", "type": "AtomicInteger", "declarator": "flushesInProgress", "var_name": "flushesInProgress"}, {"original_string": "private final AtomicInteger appendsInProgress;", "modifier": "private final", "type": "AtomicInteger", "declarator": "appendsInProgress", "var_name": "appendsInProgress"}, {"original_string": "private final int batchSize;", "modifier": "private final", "type": "int", "declarator": "batchSize", "var_name": "batchSize"}, {"original_string": "private final CompressionType compression;", "modifier": "private final", "type": "CompressionType", "declarator": "compression", "var_name": "compression"}, {"original_string": "private final long lingerMs;", "modifier": "private final", "type": "long", "declarator": "lingerMs", "var_name": "lingerMs"}, {"original_string": "private final long retryBackoffMs;", "modifier": "private final", "type": "long", "declarator": "retryBackoffMs", "var_name": "retryBackoffMs"}, {"original_string": "private final BufferPool free;", "modifier": "private final", "type": "BufferPool", "declarator": "free", "var_name": "free"}, {"original_string": "private final Time time;", "modifier": "private final", "type": "Time", "declarator": "time", "var_name": "time"}, {"original_string": "private final ConcurrentMap<TopicPartition, Deque<RecordBatch>> batches;", "modifier": "private final", "type": "ConcurrentMap<TopicPartition, Deque<RecordBatch>>", "declarator": "batches", "var_name": "batches"}, {"original_string": "private final IncompleteRecordBatches incomplete;", "modifier": "private final", "type": "IncompleteRecordBatches", "declarator": "incomplete", "var_name": "incomplete"}, {"original_string": "private final Set<TopicPartition> muted;", "modifier": "private final", "type": "Set<TopicPartition>", "declarator": "muted", "var_name": "muted"}, {"original_string": "private int drainIndex;", "modifier": "private", "type": "int", "declarator": "drainIndex", "var_name": "drainIndex"}], "methods": [{"identifier": "RecordAccumulator", "parameters": "(int batchSize,\n        long totalSize,\n        CompressionType compression,\n        long lingerMs,\n        long retryBackoffMs,\n        Metrics metrics,\n        Time time)", "modifiers": "public", "return": "", "signature": " RecordAccumulator(int batchSize,\n        long totalSize,\n        CompressionType compression,\n        long lingerMs,\n        long retryBackoffMs,\n        Metrics metrics,\n        Time time)", "full_signature": "public  RecordAccumulator(int batchSize,\n        long totalSize,\n        CompressionType compression,\n        long lingerMs,\n        long retryBackoffMs,\n        Metrics metrics,\n        Time time)", "class_method_signature": "RecordAccumulator.RecordAccumulator(int batchSize,\n        long totalSize,\n        CompressionType compression,\n        long lingerMs,\n        long retryBackoffMs,\n        Metrics metrics,\n        Time time)", "testcase": false, "constructor": true}, {"identifier": "registerMetrics", "parameters": "(Metrics metrics, String metricGrpName)", "modifiers": "private", "return": "void", "signature": "void registerMetrics(Metrics metrics, String metricGrpName)", "full_signature": "private void registerMetrics(Metrics metrics, String metricGrpName)", "class_method_signature": "RecordAccumulator.registerMetrics(Metrics metrics, String metricGrpName)", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(TopicPartition tp,\n        long timestamp,\n        byte[] key,\n        byte[] value,\n        Callback callback,\n        long maxTimeToBlock)", "modifiers": "public", "return": "RecordAppendResult", "signature": "RecordAppendResult append(TopicPartition tp,\n        long timestamp,\n        byte[] key,\n        byte[] value,\n        Callback callback,\n        long maxTimeToBlock)", "full_signature": "public RecordAppendResult append(TopicPartition tp,\n        long timestamp,\n        byte[] key,\n        byte[] value,\n        Callback callback,\n        long maxTimeToBlock)", "class_method_signature": "RecordAccumulator.append(TopicPartition tp,\n        long timestamp,\n        byte[] key,\n        byte[] value,\n        Callback callback,\n        long maxTimeToBlock)", "testcase": false, "constructor": false}, {"identifier": "tryAppend", "parameters": "(long timestamp, byte[] key, byte[] value, Callback callback, Deque<RecordBatch> deque)", "modifiers": "private", "return": "RecordAppendResult", "signature": "RecordAppendResult tryAppend(long timestamp, byte[] key, byte[] value, Callback callback, Deque<RecordBatch> deque)", "full_signature": "private RecordAppendResult tryAppend(long timestamp, byte[] key, byte[] value, Callback callback, Deque<RecordBatch> deque)", "class_method_signature": "RecordAccumulator.tryAppend(long timestamp, byte[] key, byte[] value, Callback callback, Deque<RecordBatch> deque)", "testcase": false, "constructor": false}, {"identifier": "abortExpiredBatches", "parameters": "(int requestTimeout, long now)", "modifiers": "public", "return": "List<RecordBatch>", "signature": "List<RecordBatch> abortExpiredBatches(int requestTimeout, long now)", "full_signature": "public List<RecordBatch> abortExpiredBatches(int requestTimeout, long now)", "class_method_signature": "RecordAccumulator.abortExpiredBatches(int requestTimeout, long now)", "testcase": false, "constructor": false}, {"identifier": "reenqueue", "parameters": "(RecordBatch batch, long now)", "modifiers": "public", "return": "void", "signature": "void reenqueue(RecordBatch batch, long now)", "full_signature": "public void reenqueue(RecordBatch batch, long now)", "class_method_signature": "RecordAccumulator.reenqueue(RecordBatch batch, long now)", "testcase": false, "constructor": false}, {"identifier": "ready", "parameters": "(Cluster cluster, long nowMs)", "modifiers": "public", "return": "ReadyCheckResult", "signature": "ReadyCheckResult ready(Cluster cluster, long nowMs)", "full_signature": "public ReadyCheckResult ready(Cluster cluster, long nowMs)", "class_method_signature": "RecordAccumulator.ready(Cluster cluster, long nowMs)", "testcase": false, "constructor": false}, {"identifier": "hasUnsent", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean hasUnsent()", "full_signature": "public boolean hasUnsent()", "class_method_signature": "RecordAccumulator.hasUnsent()", "testcase": false, "constructor": false}, {"identifier": "drain", "parameters": "(Cluster cluster,\n        Set<Node> nodes,\n        int maxSize,\n        long now)", "modifiers": "public", "return": "Map<Integer, List<RecordBatch>>", "signature": "Map<Integer, List<RecordBatch>> drain(Cluster cluster,\n        Set<Node> nodes,\n        int maxSize,\n        long now)", "full_signature": "public Map<Integer, List<RecordBatch>> drain(Cluster cluster,\n        Set<Node> nodes,\n        int maxSize,\n        long now)", "class_method_signature": "RecordAccumulator.drain(Cluster cluster,\n        Set<Node> nodes,\n        int maxSize,\n        long now)", "testcase": false, "constructor": false}, {"identifier": "getDeque", "parameters": "(TopicPartition tp)", "modifiers": "private", "return": "Deque<RecordBatch>", "signature": "Deque<RecordBatch> getDeque(TopicPartition tp)", "full_signature": "private Deque<RecordBatch> getDeque(TopicPartition tp)", "class_method_signature": "RecordAccumulator.getDeque(TopicPartition tp)", "testcase": false, "constructor": false}, {"identifier": "getOrCreateDeque", "parameters": "(TopicPartition tp)", "modifiers": "private", "return": "Deque<RecordBatch>", "signature": "Deque<RecordBatch> getOrCreateDeque(TopicPartition tp)", "full_signature": "private Deque<RecordBatch> getOrCreateDeque(TopicPartition tp)", "class_method_signature": "RecordAccumulator.getOrCreateDeque(TopicPartition tp)", "testcase": false, "constructor": false}, {"identifier": "deallocate", "parameters": "(RecordBatch batch)", "modifiers": "public", "return": "void", "signature": "void deallocate(RecordBatch batch)", "full_signature": "public void deallocate(RecordBatch batch)", "class_method_signature": "RecordAccumulator.deallocate(RecordBatch batch)", "testcase": false, "constructor": false}, {"identifier": "flushInProgress", "parameters": "()", "modifiers": "", "return": "boolean", "signature": "boolean flushInProgress()", "full_signature": " boolean flushInProgress()", "class_method_signature": "RecordAccumulator.flushInProgress()", "testcase": false, "constructor": false}, {"identifier": "batches", "parameters": "()", "modifiers": "", "return": "Map<TopicPartition, Deque<RecordBatch>>", "signature": "Map<TopicPartition, Deque<RecordBatch>> batches()", "full_signature": " Map<TopicPartition, Deque<RecordBatch>> batches()", "class_method_signature": "RecordAccumulator.batches()", "testcase": false, "constructor": false}, {"identifier": "beginFlush", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void beginFlush()", "full_signature": "public void beginFlush()", "class_method_signature": "RecordAccumulator.beginFlush()", "testcase": false, "constructor": false}, {"identifier": "appendsInProgress", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean appendsInProgress()", "full_signature": "private boolean appendsInProgress()", "class_method_signature": "RecordAccumulator.appendsInProgress()", "testcase": false, "constructor": false}, {"identifier": "awaitFlushCompletion", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void awaitFlushCompletion()", "full_signature": "public void awaitFlushCompletion()", "class_method_signature": "RecordAccumulator.awaitFlushCompletion()", "testcase": false, "constructor": false}, {"identifier": "abortIncompleteBatches", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void abortIncompleteBatches()", "full_signature": "public void abortIncompleteBatches()", "class_method_signature": "RecordAccumulator.abortIncompleteBatches()", "testcase": false, "constructor": false}, {"identifier": "abortBatches", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void abortBatches()", "full_signature": "private void abortBatches()", "class_method_signature": "RecordAccumulator.abortBatches()", "testcase": false, "constructor": false}, {"identifier": "mutePartition", "parameters": "(TopicPartition tp)", "modifiers": "public", "return": "void", "signature": "void mutePartition(TopicPartition tp)", "full_signature": "public void mutePartition(TopicPartition tp)", "class_method_signature": "RecordAccumulator.mutePartition(TopicPartition tp)", "testcase": false, "constructor": false}, {"identifier": "unmutePartition", "parameters": "(TopicPartition tp)", "modifiers": "public", "return": "void", "signature": "void unmutePartition(TopicPartition tp)", "full_signature": "public void unmutePartition(TopicPartition tp)", "class_method_signature": "RecordAccumulator.unmutePartition(TopicPartition tp)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "RecordAccumulator.close()", "testcase": false, "constructor": false}], "file": "clients/src/main/java/org/apache/kafka/clients/producer/internals/RecordAccumulator.java"}, "focal_method": {"identifier": "abortIncompleteBatches", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void abortIncompleteBatches() {\n        // We need to keep aborting the incomplete batch until no thread is trying to append to\n        // 1. Avoid losing batches.\n        // 2. Free up memory in case appending threads are blocked on buffer full.\n        // This is a tight loop but should be able to get through very quickly.\n        do {\n            abortBatches();\n        } while (appendsInProgress());\n        // After this point, no thread will append any messages because they will see the close\n        // flag set. We need to do the last abort after no thread was appending in case there was a new\n        // batch appended by the last appending thread.\n        abortBatches();\n        this.batches.clear();\n    }", "signature": "void abortIncompleteBatches()", "full_signature": "public void abortIncompleteBatches()", "class_method_signature": "RecordAccumulator.abortIncompleteBatches()", "testcase": false, "constructor": false, "invocations": ["abortBatches", "appendsInProgress", "abortBatches", "clear"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}