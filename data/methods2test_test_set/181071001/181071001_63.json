{"test_class": {"identifier": "TestStandardFDConnectionService", "superclass": "extends BaseFDServiceTest", "interfaces": "", "fields": [{"original_string": "private VersionedConnection connectionConfig;", "modifier": "private", "type": "VersionedConnection", "declarator": "connectionConfig", "var_name": "connectionConfig"}, {"original_string": "private FDConnectionService connectionService;", "modifier": "private", "type": "FDConnectionService", "declarator": "connectionService", "var_name": "connectionService"}], "file": "efm/efm-flow-designer/efm-flow-designer-framework/src/test/java/com/cloudera/cem/efm/service/component/TestStandardFDConnectionService.java"}, "test_case": {"identifier": "testCreateConnectionWhenDestGroupNotChildOfConnectionGroup", "parameters": "()", "modifiers": "@Test(expected = IllegalStateException.class) public", "return": "void", "body": "@Test(expected = IllegalStateException.class)\n    public void testCreateConnectionWhenDestGroupNotChildOfConnectionGroup() {\n        final String flowId = flow.getFlowMetadata().getIdentifier();\n        final String groupId = group2.getIdentifier();\n\n        when(flowManager.getFlow(flowId)).thenReturn(Optional.of(flow));\n\n        // Make the dest an input port in process group 1 which is not a child group of the connection group\n        final ConnectableComponent newDest = ComponentUtils.createConnectableComponent(group1InputPort);\n        connectionConfig.setDestination(newDest);\n\n        connectionService.create(flowId, groupId, connectionConfig);\n    }", "signature": "void testCreateConnectionWhenDestGroupNotChildOfConnectionGroup()", "full_signature": "@Test(expected = IllegalStateException.class) public void testCreateConnectionWhenDestGroupNotChildOfConnectionGroup()", "class_method_signature": "TestStandardFDConnectionService.testCreateConnectionWhenDestGroupNotChildOfConnectionGroup()", "testcase": true, "constructor": false, "invocations": ["getIdentifier", "getFlowMetadata", "getIdentifier", "thenReturn", "when", "getFlow", "of", "createConnectableComponent", "setDestination", "create"]}, "focal_class": {"identifier": "StandardFDConnectionService", "superclass": "extends BaseComponentService<VersionedConnection, FDConnection>", "interfaces": "implements com.cloudera.cem.efm.service.component.FDConnectionService", "fields": [{"original_string": "public static final String DEFAULT_BACK_PRESSURE_DATA_SIZE_THRESHOLD = \"10000 B\";", "modifier": "public static final", "type": "String", "declarator": "DEFAULT_BACK_PRESSURE_DATA_SIZE_THRESHOLD = \"10000 B\"", "var_name": "DEFAULT_BACK_PRESSURE_DATA_SIZE_THRESHOLD"}, {"original_string": "public static final long DEFAULT_BACK_PRESSURE_OBJECT_SIZE_THRESHOLD = 0;", "modifier": "public static final", "type": "long", "declarator": "DEFAULT_BACK_PRESSURE_OBJECT_SIZE_THRESHOLD = 0", "var_name": "DEFAULT_BACK_PRESSURE_OBJECT_SIZE_THRESHOLD"}, {"original_string": "public static final String DEFAULT_FLOW_FILE_EXPIRATION = \"60 seconds\";", "modifier": "public static final", "type": "String", "declarator": "DEFAULT_FLOW_FILE_EXPIRATION = \"60 seconds\"", "var_name": "DEFAULT_FLOW_FILE_EXPIRATION"}, {"original_string": "private static Map<ConnectableComponentType, Function<VersionedProcessGroup, Set<? extends VersionedComponent>>> componentTypeFunctionMap;", "modifier": "private static", "type": "Map<ConnectableComponentType, Function<VersionedProcessGroup, Set<? extends VersionedComponent>>>", "declarator": "componentTypeFunctionMap", "var_name": "componentTypeFunctionMap"}], "methods": [{"identifier": "StandardFDConnectionService", "parameters": "(final FDFlowManager flowManager, final ValidationService validationService)", "modifiers": "public", "return": "", "signature": " StandardFDConnectionService(final FDFlowManager flowManager, final ValidationService validationService)", "full_signature": "public  StandardFDConnectionService(final FDFlowManager flowManager, final ValidationService validationService)", "class_method_signature": "StandardFDConnectionService.StandardFDConnectionService(final FDFlowManager flowManager, final ValidationService validationService)", "testcase": false, "constructor": true}, {"identifier": "create", "parameters": "(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "modifiers": "@Override public", "return": "FDConnection", "signature": "FDConnection create(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "full_signature": "@Override public FDConnection create(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "class_method_signature": "StandardFDConnectionService.create(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(final String flowId, final String componentId)", "modifiers": "@Override public", "return": "FDConnection", "signature": "FDConnection get(final String flowId, final String componentId)", "full_signature": "@Override public FDConnection get(final String flowId, final String componentId)", "class_method_signature": "StandardFDConnectionService.get(final String flowId, final String componentId)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(final String flowId, final VersionedConnection requestComponentConfig)", "modifiers": "@Override public", "return": "FDConnection", "signature": "FDConnection update(final String flowId, final VersionedConnection requestComponentConfig)", "full_signature": "@Override public FDConnection update(final String flowId, final VersionedConnection requestComponentConfig)", "class_method_signature": "StandardFDConnectionService.update(final String flowId, final VersionedConnection requestComponentConfig)", "testcase": false, "constructor": false}, {"identifier": "delete", "parameters": "(final String flowId, final String componentId)", "modifiers": "@Override public", "return": "void", "signature": "void delete(final String flowId, final String componentId)", "full_signature": "@Override public void delete(final String flowId, final String componentId)", "class_method_signature": "StandardFDConnectionService.delete(final String flowId, final String componentId)", "testcase": false, "constructor": false}, {"identifier": "instantiateComponent", "parameters": "(final VersionedConnection componentConfig)", "modifiers": "@Override protected", "return": "FDConnection", "signature": "FDConnection instantiateComponent(final VersionedConnection componentConfig)", "full_signature": "@Override protected FDConnection instantiateComponent(final VersionedConnection componentConfig)", "class_method_signature": "StandardFDConnectionService.instantiateComponent(final VersionedConnection componentConfig)", "testcase": false, "constructor": false}, {"identifier": "configureComponentSpecifics", "parameters": "(final VersionedConnection requestComponent,\n                                               final VersionedConnection resultComponent)", "modifiers": "@Override protected", "return": "void", "signature": "void configureComponentSpecifics(final VersionedConnection requestComponent,\n                                               final VersionedConnection resultComponent)", "full_signature": "@Override protected void configureComponentSpecifics(final VersionedConnection requestComponent,\n                                               final VersionedConnection resultComponent)", "class_method_signature": "StandardFDConnectionService.configureComponentSpecifics(final VersionedConnection requestComponent,\n                                               final VersionedConnection resultComponent)", "testcase": false, "constructor": false}, {"identifier": "containsChildGroup", "parameters": "(final VersionedProcessGroup parentGroup, final String childGroupId)", "modifiers": "private", "return": "boolean", "signature": "boolean containsChildGroup(final VersionedProcessGroup parentGroup, final String childGroupId)", "full_signature": "private boolean containsChildGroup(final VersionedProcessGroup parentGroup, final String childGroupId)", "class_method_signature": "StandardFDConnectionService.containsChildGroup(final VersionedProcessGroup parentGroup, final String childGroupId)", "testcase": false, "constructor": false}, {"identifier": "containsConnectable", "parameters": "(final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "modifiers": "private", "return": "boolean", "signature": "boolean containsConnectable(final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "full_signature": "private boolean containsConnectable(final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "class_method_signature": "StandardFDConnectionService.containsConnectable(final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "testcase": false, "constructor": false}, {"identifier": "getVersionedComponentConnectable", "parameters": "(\n            final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "modifiers": "private", "return": "Optional<VersionedComponent>", "signature": "Optional<VersionedComponent> getVersionedComponentConnectable(\n            final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "full_signature": "private Optional<VersionedComponent> getVersionedComponentConnectable(\n            final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "class_method_signature": "StandardFDConnectionService.getVersionedComponentConnectable(\n            final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "testcase": false, "constructor": false}, {"identifier": "isDestStillUsed", "parameters": "(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingDestination,\n                                    final VersionedProcessGroup connectionGroup)", "modifiers": "private", "return": "boolean", "signature": "boolean isDestStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingDestination,\n                                    final VersionedProcessGroup connectionGroup)", "full_signature": "private boolean isDestStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingDestination,\n                                    final VersionedProcessGroup connectionGroup)", "class_method_signature": "StandardFDConnectionService.isDestStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingDestination,\n                                    final VersionedProcessGroup connectionGroup)", "testcase": false, "constructor": false}, {"identifier": "isSourceStillUsed", "parameters": "(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingSource,\n                                    final VersionedProcessGroup connectionGroup)", "modifiers": "private", "return": "boolean", "signature": "boolean isSourceStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingSource,\n                                    final VersionedProcessGroup connectionGroup)", "full_signature": "private boolean isSourceStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingSource,\n                                    final VersionedProcessGroup connectionGroup)", "class_method_signature": "StandardFDConnectionService.isSourceStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingSource,\n                                    final VersionedProcessGroup connectionGroup)", "testcase": false, "constructor": false}, {"identifier": "removeRemoteInputPort", "parameters": "(final VersionedProcessGroup connectionGroup, final ConnectableComponent remoteInputPort)", "modifiers": "private", "return": "void", "signature": "void removeRemoteInputPort(final VersionedProcessGroup connectionGroup, final ConnectableComponent remoteInputPort)", "full_signature": "private void removeRemoteInputPort(final VersionedProcessGroup connectionGroup, final ConnectableComponent remoteInputPort)", "class_method_signature": "StandardFDConnectionService.removeRemoteInputPort(final VersionedProcessGroup connectionGroup, final ConnectableComponent remoteInputPort)", "testcase": false, "constructor": false}, {"identifier": "removeRemoteOutputPort", "parameters": "(VersionedProcessGroup connectionGroup, ConnectableComponent remoteOutputPort)", "modifiers": "private", "return": "void", "signature": "void removeRemoteOutputPort(VersionedProcessGroup connectionGroup, ConnectableComponent remoteOutputPort)", "full_signature": "private void removeRemoteOutputPort(VersionedProcessGroup connectionGroup, ConnectableComponent remoteOutputPort)", "class_method_signature": "StandardFDConnectionService.removeRemoteOutputPort(VersionedProcessGroup connectionGroup, ConnectableComponent remoteOutputPort)", "testcase": false, "constructor": false}, {"identifier": "validateRequestConfig", "parameters": "(final VersionedConnection requestComponentConfig)", "modifiers": "private", "return": "void", "signature": "void validateRequestConfig(final VersionedConnection requestComponentConfig)", "full_signature": "private void validateRequestConfig(final VersionedConnection requestComponentConfig)", "class_method_signature": "StandardFDConnectionService.validateRequestConfig(final VersionedConnection requestComponentConfig)", "testcase": false, "constructor": false}], "file": "efm/efm-flow-designer/efm-flow-designer-framework/src/main/java/com/cloudera/cem/efm/service/component/StandardFDConnectionService.java"}, "focal_method": {"identifier": "create", "parameters": "(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "modifiers": "@Override public", "return": "FDConnection", "body": "@Override\n    public FDConnection create(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig) {\n        final ConnectableComponent sourceConnectable = requestComponentConfig.getSource();\n        final ConnectableComponent destConnectable = requestComponentConfig.getDestination();\n\n        if (sourceConnectable == null || destConnectable == null) {\n            throw new IllegalArgumentException(\"Both source and destination must be specified\");\n        }\n\n        if (sourceConnectable.getId() == null || destConnectable.getId() == null) {\n            throw new IllegalArgumentException(\"Both source and destination ids must be specified\");\n        }\n\n        if (sourceConnectable.getType() == null || destConnectable.getType() == null) {\n            throw new IllegalArgumentException(\"Both source and destination types must be specified\");\n        }\n\n        if (sourceConnectable.getType() == ConnectableComponentType.FUNNEL\n                && destConnectable.getType() == ConnectableComponentType.FUNNEL\n                && sourceConnectable.getId().equals(destConnectable.getId())) {\n            throw new IllegalArgumentException(\"A funnel cannot be connected to itself\");\n        }\n\n        if (sourceConnectable.getGroupId() == null) {\n            sourceConnectable.setGroupId(processGroupId);\n        }\n\n        if (destConnectable.getGroupId() == null) {\n            destConnectable.setGroupId(processGroupId);\n        }\n\n        // Ensure that processors specify the selected relationships\n        if (sourceConnectable.getType() == ConnectableComponentType.PROCESSOR) {\n            if (requestComponentConfig.getSelectedRelationships() == null || requestComponentConfig.getSelectedRelationships().isEmpty()) {\n                throw new IllegalArgumentException(\"Selected relationships must be specified\");\n            }\n        }\n\n        validateRequestConfig(requestComponentConfig);\n\n        final FDFlow currentFlow = getFlowOrNotFound(flowId);\n        final VersionedProcessGroup flowContent = currentFlow.getFlowContent();\n        final VersionedProcessGroup connectionGroup = ComponentUtils.getProcessGroupOrNotFound(processGroupId, flowContent);\n\n        final String sourceId = sourceConnectable.getId();\n        final String sourceGroupId = sourceConnectable.getGroupId();\n\n        final String destId = destConnectable.getId();\n        final String destGroupId = destConnectable.getGroupId();\n\n        // VALIDATE SOURCE\n\n        VersionedRemoteProcessGroup sourceRemoteProcessGroup = null;\n        VersionedRemoteGroupPort newRemoteOutputPort = null;\n\n        if (sourceConnectable.getType() == ConnectableComponentType.REMOTE_OUTPUT_PORT) {\n            try {\n                UUID.fromString(sourceId);\n            } catch (Exception  e) {\n                throw new IllegalArgumentException(\"The ID of a remote output port must be a UUID\");\n            }\n\n            // Locate the remote process group with the group id specified in the source, or throw exception\n            sourceRemoteProcessGroup = connectionGroup.getRemoteProcessGroups().stream()\n                    .filter(rpg -> rpg.getIdentifier().equals(sourceGroupId))\n                    .findFirst()\n                    .orElseThrow(() -> new IllegalArgumentException(\"Unable to find the specified remote process group for connection source\"));\n\n            // Find the output port in the remote process group with the target id of the specified source\n            final Optional<VersionedRemoteGroupPort> remoteGroupPort = sourceRemoteProcessGroup.getOutputPorts().stream()\n                    .filter(p -> p.getTargetId().equals(sourceId)).findFirst();\n\n            // If we couldn't find a remote output port with that id then create a new one, but don't add it to the RPG until later\n            if (!remoteGroupPort.isPresent()) {\n                newRemoteOutputPort = new VersionedRemoteGroupPort();\n                newRemoteOutputPort.setIdentifier(UUID.randomUUID().toString());\n                newRemoteOutputPort.setGroupIdentifier(connectionGroup.getIdentifier());\n                newRemoteOutputPort.setRemoteGroupId(sourceRemoteProcessGroup.getIdentifier());\n                newRemoteOutputPort.setTargetId(sourceId);\n                newRemoteOutputPort.setName(sourceId);\n                newRemoteOutputPort.setComponentType(ComponentType.REMOTE_OUTPUT_PORT);\n            }\n\n            // set the remote input port name to the id\n            sourceConnectable.setName(sourceId);\n        } else {\n            // Validate source group exists and that the source connectable exists in the source group\n            final VersionedProcessGroup sourceGroup = ComponentUtils.getProcessGroupOrIllegalArgument(sourceGroupId, flowContent);\n\n            final boolean sourceGroupContainsSource = containsConnectable(sourceGroup, sourceConnectable);\n            if (!sourceGroupContainsSource) {\n                throw new IllegalStateException(\"Cannot add connection because the source component was not found in the source group\");\n            }\n\n            // If the source is not located in the same group as the connection, then ensure the source group is a child group\n            // of the connection group, and ensure the source is an output port\n            if (!processGroupId.equals(sourceGroupId)) {\n                if (sourceConnectable.getType() != ConnectableComponentType.OUTPUT_PORT) {\n                    throw new IllegalStateException(\"Cannot add connection between \" + sourceId + \" and \" + destId\n                            + \" because they are in different process groups and the source is not an output port\");\n                }\n\n                boolean connectionGroupContainsSourceGroup = containsChildGroup(connectionGroup, sourceGroupId);\n                if (!connectionGroupContainsSourceGroup) {\n                    throw new IllegalStateException(\"Cannot add connection between \" + sourceId + \" and \" + destId\n                            + \" because the source group is not a child group of the connection group\");\n                }\n            }\n        }\n\n\n        // VALIDATE DESTINATION\n\n        VersionedRemoteProcessGroup destRemoteProcessGroup = null;\n        VersionedRemoteGroupPort newRemoteInputPort = null;\n\n        if (destConnectable.getType() == ConnectableComponentType.REMOTE_INPUT_PORT) {\n            try {\n                UUID.fromString(destId);\n            } catch (Exception  e) {\n                throw new IllegalArgumentException(\"The ID of a remote input port must be a UUID\");\n            }\n\n            // Locate the remote process group with the group id specified in the dest, or throw exception\n            destRemoteProcessGroup = connectionGroup.getRemoteProcessGroups().stream()\n                    .filter(rpg -> rpg.getIdentifier().equals(destGroupId))\n                    .findFirst()\n                    .orElseThrow(() -> new IllegalArgumentException(\"Unable to find the specified remote process group for connection destination\"));\n\n            // Find the input port in the remote process group with the target id of the specified dest\n            final Optional<VersionedRemoteGroupPort> remoteGroupPort = destRemoteProcessGroup.getInputPorts().stream()\n                    .filter(p -> p.getTargetId().equals(destId)).findFirst();\n\n            // If we couldn't find a remote input port with that target id then create a new one, but don't add it to the RPG until later\n            if (!remoteGroupPort.isPresent()) {\n                newRemoteInputPort = new VersionedRemoteGroupPort();\n                newRemoteInputPort.setIdentifier(UUID.randomUUID().toString());\n                newRemoteInputPort.setGroupIdentifier(connectionGroup.getIdentifier());\n                newRemoteInputPort.setRemoteGroupId(destRemoteProcessGroup.getIdentifier());\n                newRemoteInputPort.setTargetId(destId);\n                newRemoteInputPort.setName(destId);\n                newRemoteInputPort.setComponentType(ComponentType.REMOTE_INPUT_PORT);\n            }\n\n            // set the remote output port name to the id\n            destConnectable.setName(destId);\n        } else {\n            // Validate dest group exists and that the dest connectable exists in the source group\n            final VersionedProcessGroup destGroup = ComponentUtils.getProcessGroupOrIllegalArgument(destGroupId, flowContent);\n\n            final boolean destGroupContainsSource = containsConnectable(destGroup, destConnectable);\n            if (!destGroupContainsSource) {\n                throw new IllegalStateException(\"Cannot add connection because the destination component was not found in the destination group\");\n            }\n\n            // If the dest is not located in the same group as the connection, then ensure the dest group is a child group\n            // of the connection group, and ensure the dest is an input port\n            if (!processGroupId.equals(destGroupId)) {\n                if (destConnectable.getType() != ConnectableComponentType.INPUT_PORT) {\n                    throw new IllegalStateException(\"Cannot add connection between \" + sourceId + \" and \" + destId\n                            + \" because they are in different process groups and the destination is not an input port\");\n                }\n\n                boolean connectionGroupContainsDestGroup = containsChildGroup(connectionGroup, destGroupId);\n                if (!connectionGroupContainsDestGroup) {\n                    throw new IllegalStateException(\"Cannot add connection between \" + sourceId + \" and \" + destId\n                            + \" because the destination group is not a child group of the connection group\");\n                }\n            }\n        }\n\n        // Now that both source and dest passed validation we can add them to the remote process group\n        if (newRemoteOutputPort != null) {\n            sourceRemoteProcessGroup.getOutputPorts().add(newRemoteOutputPort);\n        }\n        if (newRemoteInputPort != null) {\n            destRemoteProcessGroup.getInputPorts().add(newRemoteInputPort);\n        }\n\n        // Continue on to normal create...\n\n        final FDConnection created = createComponent(\n                currentFlow,\n                connectionGroup,\n                null,\n                requestComponentConfig,\n                () -> {\n                    final VersionedConnection connectionConfig = new VersionedConnection();\n                    connectionConfig.setSource(sourceConnectable);\n                    connectionConfig.setDestination(destConnectable);\n                    connectionConfig.setSelectedRelationships(new HashSet<>());\n                    connectionConfig.setName(\"\");\n                    connectionConfig.setBends(new ArrayList<>());\n                    connectionConfig.setPrioritizers(new ArrayList<>());\n                    connectionConfig.setzIndex(new Long(0));\n                    connectionConfig.setLabelIndex(new Integer(1));\n                    connectionConfig.setBackPressureDataSizeThreshold(DEFAULT_BACK_PRESSURE_DATA_SIZE_THRESHOLD);\n                    connectionConfig.setBackPressureObjectThreshold(DEFAULT_BACK_PRESSURE_OBJECT_SIZE_THRESHOLD);\n                    connectionConfig.setFlowFileExpiration(DEFAULT_FLOW_FILE_EXPIRATION);\n\n                    final FDConnection connection = new FDConnection();\n                    connection.setComponentConfiguration(connectionConfig);\n                    return connection;\n                    },\n                VersionedProcessGroup::getConnections,\n                null);\n\n        getValidationService().clearValidationErrors(sourceConnectable.getId());\n        getValidationService().clearValidationErrors(destConnectable.getId());\n\n        return created;\n    }", "signature": "FDConnection create(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "full_signature": "@Override public FDConnection create(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "class_method_signature": "StandardFDConnectionService.create(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "testcase": false, "constructor": false, "invocations": ["getSource", "getDestination", "getId", "getId", "getType", "getType", "getType", "getType", "equals", "getId", "getId", "getGroupId", "setGroupId", "getGroupId", "setGroupId", "getType", "getSelectedRelationships", "isEmpty", "getSelectedRelationships", "validateRequestConfig", "getFlowOrNotFound", "getFlowContent", "getProcessGroupOrNotFound", "getId", "getGroupId", "getId", "getGroupId", "getType", "fromString", "orElseThrow", "findFirst", "filter", "stream", "getRemoteProcessGroups", "equals", "getIdentifier", "findFirst", "filter", "stream", "getOutputPorts", "equals", "getTargetId", "isPresent", "setIdentifier", "toString", "randomUUID", "setGroupIdentifier", "getIdentifier", "setRemoteGroupId", "getIdentifier", "setTargetId", "setName", "setComponentType", "setName", "getProcessGroupOrIllegalArgument", "containsConnectable", "equals", "getType", "containsChildGroup", "getType", "fromString", "orElseThrow", "findFirst", "filter", "stream", "getRemoteProcessGroups", "equals", "getIdentifier", "findFirst", "filter", "stream", "getInputPorts", "equals", "getTargetId", "isPresent", "setIdentifier", "toString", "randomUUID", "setGroupIdentifier", "getIdentifier", "setRemoteGroupId", "getIdentifier", "setTargetId", "setName", "setComponentType", "setName", "getProcessGroupOrIllegalArgument", "containsConnectable", "equals", "getType", "containsChildGroup", "add", "getOutputPorts", "add", "getInputPorts", "createComponent", "setSource", "setDestination", "setSelectedRelationships", "setName", "setBends", "setPrioritizers", "setzIndex", "setLabelIndex", "setBackPressureDataSizeThreshold", "setBackPressureObjectThreshold", "setFlowFileExpiration", "setComponentConfiguration", "clearValidationErrors", "getValidationService", "getId", "clearValidationErrors", "getValidationService", "getId"]}, "repository": {"repo_id": 181071001, "url": "https://github.com/hortonworks/efm", "language": "Java", "is_fork": false, "fork_count": 5, "stargazer_count": 7, "size": 2003, "license": "licensed"}}