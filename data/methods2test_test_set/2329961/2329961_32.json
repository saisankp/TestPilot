{"test_class": {"identifier": "FlagsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n    public ExpectedException exception = ExpectedException.none();", "modifier": "@Rule\n    public", "type": "ExpectedException", "declarator": "exception = ExpectedException.none()", "var_name": "exception"}, {"original_string": "@Rule\n    public ExpectedException expectedException = ExpectedException.none();", "modifier": "@Rule\n    public", "type": "ExpectedException", "declarator": "expectedException = ExpectedException.none()", "var_name": "expectedException"}], "file": "flags/src/test/java/org/cloudname/flags/FlagsTest.java"}, "test_case": {"identifier": "testPrintHelp", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testPrintHelp() {\n        try {\n            Flags flags = new Flags()\n            .loadOpts(FlagsHelpTest.class);\n            flags.printHelp(System.out);\n        } catch (Exception e) {\n            assertFalse(\"Cought exception.\", true);\n        }\n    }", "signature": "void testPrintHelp()", "full_signature": "@Test public void testPrintHelp()", "class_method_signature": "FlagsTest.testPrintHelp()", "testcase": true, "constructor": false, "invocations": ["loadOpts", "printHelp", "assertFalse"]}, "focal_class": {"identifier": "Flags", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final OptionParser optionParser = new OptionParser();", "modifier": "private final", "type": "OptionParser", "declarator": "optionParser = new OptionParser()", "var_name": "optionParser"}, {"original_string": "private final OptionSpec<Void> HELP = optionParser\n            .accepts(\"help\", \"Show this help\");", "modifier": "private final", "type": "OptionSpec<Void>", "declarator": "HELP = optionParser\n            .accepts(\"help\", \"Show this help\")", "var_name": "HELP"}, {"original_string": "private final OptionSpec<Void> VERSION = optionParser\n        .accepts(\"version\", \"Show version\");", "modifier": "private final", "type": "OptionSpec<Void>", "declarator": "VERSION = optionParser\n        .accepts(\"version\", \"Show version\")", "var_name": "VERSION"}, {"original_string": "private final OptionSpec<String> PROPERTIES_FILE = optionParser.accepts(\"properties-file\",\n        \"Load properties from a given file\").withRequiredArg().ofType(String.class).withValuesSeparatedBy(';');", "modifier": "private final", "type": "OptionSpec<String>", "declarator": "PROPERTIES_FILE = optionParser.accepts(\"properties-file\",\n        \"Load properties from a given file\").withRequiredArg().ofType(String.class).withValuesSeparatedBy(';')", "var_name": "PROPERTIES_FILE"}, {"original_string": "private String versionString = \"NA\";", "modifier": "private", "type": "String", "declarator": "versionString = \"NA\"", "var_name": "versionString"}, {"original_string": "private final Map<String, OptionHolder> options = new HashMap<String, OptionHolder>();", "modifier": "private final", "type": "Map<String, OptionHolder>", "declarator": "options = new HashMap<String, OptionHolder>()", "var_name": "options"}, {"original_string": "private OptionSet optionSet;", "modifier": "private", "type": "OptionSet", "declarator": "optionSet", "var_name": "optionSet"}, {"original_string": "private List<String> nonOptionArguments;", "modifier": "private", "type": "List<String>", "declarator": "nonOptionArguments", "var_name": "nonOptionArguments"}, {"original_string": "private final Map<Class<? extends Enum<?>>, List<String>> enumOptions = new HashMap<Class<? extends Enum<?>>, List<String>>();", "modifier": "private final", "type": "Map<Class<? extends Enum<?>>, List<String>>", "declarator": "enumOptions = new HashMap<Class<? extends Enum<?>>, List<String>>()", "var_name": "enumOptions"}, {"original_string": "private final List<Object> objects = new ArrayList<Object>();", "modifier": "private final", "type": "List<Object>", "declarator": "objects = new ArrayList<Object>()", "var_name": "objects"}, {"original_string": "private final List<Class<?>> classes = new ArrayList<Class<?>>();", "modifier": "private final", "type": "List<Class<?>>", "declarator": "classes = new ArrayList<Class<?>>()", "var_name": "classes"}], "methods": [{"identifier": "loadOpts", "parameters": "(Class<?> c)", "modifiers": "public", "return": "Flags", "signature": "Flags loadOpts(Class<?> c)", "full_signature": "public Flags loadOpts(Class<?> c)", "class_method_signature": "Flags.loadOpts(Class<?> c)", "testcase": false, "constructor": false}, {"identifier": "loadOpts", "parameters": "(final Object o)", "modifiers": "public", "return": "Flags", "signature": "Flags loadOpts(final Object o)", "full_signature": "public Flags loadOpts(final Object o)", "class_method_signature": "Flags.loadOpts(final Object o)", "testcase": false, "constructor": false}, {"identifier": "loadOpts", "parameters": "(Object o, boolean instanced)", "modifiers": "private", "return": "Flags", "signature": "Flags loadOpts(Object o, boolean instanced)", "full_signature": "private Flags loadOpts(Object o, boolean instanced)", "class_method_signature": "Flags.loadOpts(Object o, boolean instanced)", "testcase": false, "constructor": false}, {"identifier": "setVersionString", "parameters": "(final String versionString)", "modifiers": "public", "return": "void", "signature": "void setVersionString(final String versionString)", "full_signature": "public void setVersionString(final String versionString)", "class_method_signature": "Flags.setVersionString(final String versionString)", "testcase": false, "constructor": false}, {"identifier": "getNonOptionArguments", "parameters": "()", "modifiers": "public", "return": "List<String>", "signature": "List<String> getNonOptionArguments()", "full_signature": "public List<String> getNonOptionArguments()", "class_method_signature": "Flags.getNonOptionArguments()", "testcase": false, "constructor": false}, {"identifier": "addEnumOption", "parameters": "(Class<? extends Enum<?>> enumClass, String validOption)", "modifiers": "private", "return": "void", "signature": "void addEnumOption(Class<? extends Enum<?>> enumClass, String validOption)", "full_signature": "private void addEnumOption(Class<? extends Enum<?>> enumClass, String validOption)", "class_method_signature": "Flags.addEnumOption(Class<? extends Enum<?>> enumClass, String validOption)", "testcase": false, "constructor": false}, {"identifier": "addOption", "parameters": "(FieldType type, Flag flag, Field field, OptionSpec<?> option, Class<?> c)", "modifiers": "private", "return": "void", "signature": "void addOption(FieldType type, Flag flag, Field field, OptionSpec<?> option, Class<?> c)", "full_signature": "private void addOption(FieldType type, Flag flag, Field field, OptionSpec<?> option, Class<?> c)", "class_method_signature": "Flags.addOption(FieldType type, Flag flag, Field field, OptionSpec<?> option, Class<?> c)", "testcase": false, "constructor": false}, {"identifier": "addInstancedOption", "parameters": "(FieldType type, Flag flag, Field field, OptionSpec<?> option, Object c)", "modifiers": "private", "return": "void", "signature": "void addInstancedOption(FieldType type, Flag flag, Field field, OptionSpec<?> option, Object c)", "full_signature": "private void addInstancedOption(FieldType type, Flag flag, Field field, OptionSpec<?> option, Object c)", "class_method_signature": "Flags.addInstancedOption(FieldType type, Flag flag, Field field, OptionSpec<?> option, Object c)", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "(String[] args)", "modifiers": "public", "return": "Flags", "signature": "Flags parse(String[] args)", "full_signature": "public Flags parse(String[] args)", "class_method_signature": "Flags.parse(String[] args)", "testcase": false, "constructor": false}, {"identifier": "callPostConstructMethods", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void callPostConstructMethods()", "full_signature": "private void callPostConstructMethods()", "class_method_signature": "Flags.callPostConstructMethods()", "testcase": false, "constructor": false}, {"identifier": "findPostConstructMethod", "parameters": "(final Class<?> type, final boolean instanced)", "modifiers": "private", "return": "List<Method>", "signature": "List<Method> findPostConstructMethod(final Class<?> type, final boolean instanced)", "full_signature": "private List<Method> findPostConstructMethod(final Class<?> type, final boolean instanced)", "class_method_signature": "Flags.findPostConstructMethod(final Class<?> type, final boolean instanced)", "testcase": false, "constructor": false}, {"identifier": "checkNoMethodArguments", "parameters": "(final Method method)", "modifiers": "private", "return": "void", "signature": "void checkNoMethodArguments(final Method method)", "full_signature": "private void checkNoMethodArguments(final Method method)", "class_method_signature": "Flags.checkNoMethodArguments(final Method method)", "testcase": false, "constructor": false}, {"identifier": "printHelp", "parameters": "(OutputStream out)", "modifiers": "public", "return": "void", "signature": "void printHelp(OutputStream out)", "full_signature": "public void printHelp(OutputStream out)", "class_method_signature": "Flags.printHelp(OutputStream out)", "testcase": false, "constructor": false}, {"identifier": "printVersion", "parameters": "(final OutputStream out)", "modifiers": "public", "return": "void", "signature": "void printVersion(final OutputStream out)", "full_signature": "public void printVersion(final OutputStream out)", "class_method_signature": "Flags.printVersion(final OutputStream out)", "testcase": false, "constructor": false}, {"identifier": "helpFlagged", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean helpFlagged()", "full_signature": "public boolean helpFlagged()", "class_method_signature": "Flags.helpFlagged()", "testcase": false, "constructor": false}, {"identifier": "versionFlagged", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean versionFlagged()", "full_signature": "public boolean versionFlagged()", "class_method_signature": "Flags.versionFlagged()", "testcase": false, "constructor": false}, {"identifier": "propertiesFlagged", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean propertiesFlagged()", "full_signature": "public boolean propertiesFlagged()", "class_method_signature": "Flags.propertiesFlagged()", "testcase": false, "constructor": false}, {"identifier": "printFlags", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void printFlags()", "full_signature": "public void printFlags()", "class_method_signature": "Flags.printFlags()", "testcase": false, "constructor": false}, {"identifier": "fieldTypeOf", "parameters": "(Field field, Flag flag)", "modifiers": "private static", "return": "FieldType", "signature": "FieldType fieldTypeOf(Field field, Flag flag)", "full_signature": "private static FieldType fieldTypeOf(Field field, Flag flag)", "class_method_signature": "Flags.fieldTypeOf(Field field, Flag flag)", "testcase": false, "constructor": false}, {"identifier": "getFlagsAsList", "parameters": "()", "modifiers": "public", "return": "List<Flag>", "signature": "List<Flag> getFlagsAsList()", "full_signature": "public List<Flag> getFlagsAsList()", "class_method_signature": "Flags.getFlagsAsList()", "testcase": false, "constructor": false}], "file": "flags/src/main/java/org/cloudname/flags/Flags.java"}, "focal_method": {"identifier": "printHelp", "parameters": "(OutputStream out)", "modifiers": "public", "return": "void", "body": "public void printHelp(OutputStream out) {\n        PrintWriter w = new PrintWriter(out);\n\n        Map<String, List<OptionHolder>> holdersByClass = new TreeMap<String, List<OptionHolder>>();\n\n        // Iterate over all the options we have gathered and stash them by class.\n        for (OptionHolder holder : options.values()) {\n            // Fetch list corresponding to source class name\n            final String className;\n            if (holder.isInstanced()) {\n                className = holder.getObjectSource().getClass().getName();\n            } else {\n                className = holder.getClassSource().getName();\n            }\n            List<OptionHolder> holderList = holdersByClass.get(className);\n            if (null == holderList) {\n                // The list did not exist.  Create it.\n                holderList = new LinkedList<OptionHolder>();\n                holdersByClass.put(className, holderList);\n            }\n\n            holderList.add(holder);\n        }\n\n        // Output options by class\n        for (Map.Entry<String, List<OptionHolder>> ent : holdersByClass.entrySet()) {\n            String className = ent.getKey();\n            List<OptionHolder> holderList = ent.getValue();\n\n            // Sort the options. In Java, sorting collections is worse\n            // than watching Pandas fuck.\n            Collections.sort(holderList, new Comparator<OptionHolder>() {\n                @Override\n                public int compare(OptionHolder a, OptionHolder b) {\n                    return a.getFlag().name().toLowerCase().compareTo(b.getFlag().name().toLowerCase());\n                }\n            });\n\n            StringBuffer buff = new StringBuffer();\n\n            buff.append(\"\\n\\n\")\n            .append(className)\n            .append(\"\\n\")\n            .append(\"------------------------------------------------------------------------\")\n            .append(\"\\n\");\n\n            for (OptionHolder holder : holderList) {\n                // Mark required flags with a \"*\"\n                buff.append(holder.getFlag().required() ? \"* \" : \"  \");\n\n                String s;\n                try {\n                    s = \"  --\" + holder.getFlag().name() + \" <\" + holder.getType() + \"> default: \"\n                            + (holder.isInstanced()\n                                ? holder.getField().get(holder.getObjectSource())\n                                : holder.getField().get(holder.getClassSource()));\n                } catch (IllegalAccessException e) {\n                    throw new RuntimeException(e);\n                }\n\n                //TODO: handle enum options\n                if (holder.getFlag().options() != NoOption.class) {\n                    s = s + \" options: \"+enumOptions.get(holder.getFlag().options()).toString();\n                }\n\n                // Avert your eyes.\n                int spaces = 50 - s.length();\n                spaces = spaces < 0 ? 0 : spaces;\n                buff.append(s)\n                .append(\"  . . . . . . . . . . . . . . . . . . . . . . . . \".substring(0, spaces))\n                .append(\"| \" + holder.getFlag().description())\n                .append(\"\\n\");\n            }\n            w.println(buff.toString());\n        }\n        w.flush();\n    }", "signature": "void printHelp(OutputStream out)", "full_signature": "public void printHelp(OutputStream out)", "class_method_signature": "Flags.printHelp(OutputStream out)", "testcase": false, "constructor": false, "invocations": ["values", "isInstanced", "getName", "getClass", "getObjectSource", "getName", "getClassSource", "get", "put", "add", "entrySet", "getKey", "getValue", "sort", "compareTo", "toLowerCase", "name", "getFlag", "toLowerCase", "name", "getFlag", "append", "append", "append", "append", "append", "append", "required", "getFlag", "name", "getFlag", "getType", "isInstanced", "get", "getField", "getObjectSource", "get", "getField", "getClassSource", "options", "getFlag", "toString", "get", "options", "getFlag", "length", "append", "append", "append", "append", "substring", "description", "getFlag", "println", "toString", "flush"]}, "repository": {"repo_id": 2329961, "url": "https://github.com/Cloudname/cloudname", "language": "Java", "is_fork": false, "fork_count": 23, "stargazer_count": 21, "size": 26031, "license": "licensed"}}