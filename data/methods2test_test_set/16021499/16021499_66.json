{"test_class": {"identifier": "NodeTypeValidatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private NodeTypeValidator validator;", "modifier": "private", "type": "NodeTypeValidator", "declarator": "validator", "var_name": "validator"}, {"original_string": "private DefaultWorkspaceFilter filter;", "modifier": "private", "type": "DefaultWorkspaceFilter", "declarator": "filter", "var_name": "filter"}], "file": "vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorTest.java"}, "test_case": {"identifier": "testUnknownNamespace", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testUnknownNamespace() {\n        NodeContext nodeContext = new NodeContextImpl(\"/apps/test/node4\", Paths.get(\"node4\"), Paths.get(\"\"));\n\n        Map<String, DocViewProperty> props = new HashMap<>();\n        DocViewProperty prop = new DocViewProperty(\"{}invalid-prop\", new String[] { \"some-value\" }, false, PropertyType.STRING);\n        props.put(\"{}invalid-prop\", prop);\n        props.put(NameConstants.JCR_PRIMARYTYPE.toString(), new DocViewProperty(NameConstants.JCR_PRIMARYTYPE.toString(),\n                new String[] { \"sling:Folder\" }, false, PropertyType.STRING));\n        // nt:file is only supposed to have jcr:created property\n        DocViewNode node = new DocViewNode(\"jcr:root\", \"jcr:root\", null, props, null, \"sling:Folder\");\n        ValidationExecutorTest.assertViolation(validator.validate(node, nodeContext, false),\n                new ValidationMessage(ValidationMessageSeverity.WARN,\n                        String.format(NodeTypeValidator.MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE,\n                                \"Invalid primary type sling:Folder: 'sling: is not a registered namespace prefix.'\")));\n    }", "signature": "void testUnknownNamespace()", "full_signature": "@Test public void testUnknownNamespace()", "class_method_signature": "NodeTypeValidatorTest.testUnknownNamespace()", "testcase": true, "constructor": false, "invocations": ["get", "get", "put", "put", "toString", "toString", "assertViolation", "validate", "format"]}, "focal_class": {"identifier": "NodeTypeValidator", "superclass": "", "interfaces": "implements DocumentViewXmlValidator, JcrPathValidator", "fields": [{"original_string": "static final String MESSAGE_MANDATORY_CHILD_NODE_MISSING = \"Mandatory child node missing: %s\";", "modifier": "static final", "type": "String", "declarator": "MESSAGE_MANDATORY_CHILD_NODE_MISSING = \"Mandatory child node missing: %s\"", "var_name": "MESSAGE_MANDATORY_CHILD_NODE_MISSING"}, {"original_string": "static final String MESSAGE_PROPERTY_ERROR = \"Error while retrieving property '%s': %s\";", "modifier": "static final", "type": "String", "declarator": "MESSAGE_PROPERTY_ERROR = \"Error while retrieving property '%s': %s\"", "var_name": "MESSAGE_PROPERTY_ERROR"}, {"original_string": "static final String MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE = \"%s. Skip validation of nodes with that type/name\";", "modifier": "static final", "type": "String", "declarator": "MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE = \"%s. Skip validation of nodes with that type/name\"", "var_name": "MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE"}, {"original_string": "static final String MESSAGE_MISSING_PRIMARY_TYPE = \"Mandatory jcr:primaryType missing on node '%s'\";", "modifier": "static final", "type": "String", "declarator": "MESSAGE_MISSING_PRIMARY_TYPE = \"Mandatory jcr:primaryType missing on node '%s'\"", "var_name": "MESSAGE_MISSING_PRIMARY_TYPE"}, {"original_string": "static final String MESSAGE_PROPERTY_NOT_ALLOWED = \"Property '%s' is not allowed in node with types '[%s]': %s\";", "modifier": "static final", "type": "String", "declarator": "MESSAGE_PROPERTY_NOT_ALLOWED = \"Property '%s' is not allowed in node with types '[%s]': %s\"", "var_name": "MESSAGE_PROPERTY_NOT_ALLOWED"}, {"original_string": "static final String MESSAGE_MANDATORY_PROPERTY_MISSING = \"Mandatory property '%s' missing in node with types [%s]\";", "modifier": "static final", "type": "String", "declarator": "MESSAGE_MANDATORY_PROPERTY_MISSING = \"Mandatory property '%s' missing in node with types [%s]\"", "var_name": "MESSAGE_MANDATORY_PROPERTY_MISSING"}, {"original_string": "static final String MESSAGE_CHILD_NODE_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED = \"Node '%s' is not allowed as child of not contained node with potential default types '[%s]': %s\";", "modifier": "static final", "type": "String", "declarator": "MESSAGE_CHILD_NODE_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED = \"Node '%s' is not allowed as child of not contained node with potential default types '[%s]': %s\"", "var_name": "MESSAGE_CHILD_NODE_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED"}, {"original_string": "static final String MESSAGE_CHILD_NODE_NOT_ALLOWED = \"Node '%s' is not allowed as child of node with types '[%s]': %s\";", "modifier": "static final", "type": "String", "declarator": "MESSAGE_CHILD_NODE_NOT_ALLOWED = \"Node '%s' is not allowed as child of node with types '[%s]': %s\"", "var_name": "MESSAGE_CHILD_NODE_NOT_ALLOWED"}, {"original_string": "private final WorkspaceFilter filter;", "modifier": "private final", "type": "WorkspaceFilter", "declarator": "filter", "var_name": "filter"}, {"original_string": "private final ValidationMessageSeverity defaultSeverity;", "modifier": "private final", "type": "ValidationMessageSeverity", "declarator": "defaultSeverity", "var_name": "defaultSeverity"}, {"original_string": "private final ValidationMessageSeverity severityForUnknownNodeTypes;", "modifier": "private final", "type": "ValidationMessageSeverity", "declarator": "severityForUnknownNodeTypes", "var_name": "severityForUnknownNodeTypes"}, {"original_string": "private final DocViewPropertyValueFactory docViewPropertyValueFactory;", "modifier": "private final", "type": "DocViewPropertyValueFactory", "declarator": "docViewPropertyValueFactory", "var_name": "docViewPropertyValueFactory"}, {"original_string": "private final NodeTypeManagerProvider ntManagerProvider;", "modifier": "private final", "type": "NodeTypeManagerProvider", "declarator": "ntManagerProvider", "var_name": "ntManagerProvider"}, {"original_string": "private final Set<String> loggedUnknownNodeTypeMessages;", "modifier": "private final", "type": "Set<String>", "declarator": "loggedUnknownNodeTypeMessages", "var_name": "loggedUnknownNodeTypeMessages"}, {"original_string": "private final EffectiveNodeType defaultType;", "modifier": "private final", "type": "EffectiveNodeType", "declarator": "defaultType", "var_name": "defaultType"}, {"original_string": "private final UserManagement userManagement;", "modifier": "private final", "type": "UserManagement", "declarator": "userManagement", "var_name": "userManagement"}, {"original_string": "private final ACLManagement aclManagement;", "modifier": "private final", "type": "ACLManagement", "declarator": "aclManagement", "var_name": "aclManagement"}, {"original_string": "private NodeContext protectedNodeContext;", "modifier": "private", "type": "NodeContext", "declarator": "protectedNodeContext", "var_name": "protectedNodeContext"}, {"original_string": "private Map<String, NodeNameAndType> nodeTypePerPath;", "modifier": "private", "type": "Map<String, NodeNameAndType>", "declarator": "nodeTypePerPath", "var_name": "nodeTypePerPath"}, {"original_string": "private static final Collection<Name> ALLOWED_PROTECTED_PROPERTIES = Arrays.asList(NameConstants.JCR_PRIMARYTYPE,\n            NameConstants.JCR_MIXINTYPES);", "modifier": "private static final", "type": "Collection<Name>", "declarator": "ALLOWED_PROTECTED_PROPERTIES = Arrays.asList(NameConstants.JCR_PRIMARYTYPE,\n            NameConstants.JCR_MIXINTYPES)", "var_name": "ALLOWED_PROTECTED_PROPERTIES"}, {"original_string": "private static final Map<Name, List<Name>> IGNORED_MANDATORY_PROPERTIES_PER_NODE_TYPE = Stream.of(\n            new SimpleEntry<>(NameConstants.NT_RESOURCE,\n                    Arrays.asList(NameConstants.JCR_DATA)))\n            .collect(Collectors.toMap(SimpleEntry::getKey, SimpleEntry::getValue));", "modifier": "private static final", "type": "Map<Name, List<Name>>", "declarator": "IGNORED_MANDATORY_PROPERTIES_PER_NODE_TYPE = Stream.of(\n            new SimpleEntry<>(NameConstants.NT_RESOURCE,\n                    Arrays.asList(NameConstants.JCR_DATA)))\n            .collect(Collectors.toMap(SimpleEntry::getKey, SimpleEntry::getValue))", "var_name": "IGNORED_MANDATORY_PROPERTIES_PER_NODE_TYPE"}], "methods": [{"identifier": "NodeTypeValidator", "parameters": "(@NotNull WorkspaceFilter filter, @NotNull NodeTypeManagerProvider ntManagerProvider,\n            @NotNull EffectiveNodeType defaultEffectiveNodeType, @NotNull ValidationMessageSeverity defaultSeverity,\n            @NotNull ValidationMessageSeverity severityForUnknownNodeTypes)", "modifiers": "public", "return": "", "signature": " NodeTypeValidator(@NotNull WorkspaceFilter filter, @NotNull NodeTypeManagerProvider ntManagerProvider,\n            @NotNull EffectiveNodeType defaultEffectiveNodeType, @NotNull ValidationMessageSeverity defaultSeverity,\n            @NotNull ValidationMessageSeverity severityForUnknownNodeTypes)", "full_signature": "public  NodeTypeValidator(@NotNull WorkspaceFilter filter, @NotNull NodeTypeManagerProvider ntManagerProvider,\n            @NotNull EffectiveNodeType defaultEffectiveNodeType, @NotNull ValidationMessageSeverity defaultSeverity,\n            @NotNull ValidationMessageSeverity severityForUnknownNodeTypes)", "class_method_signature": "NodeTypeValidator.NodeTypeValidator(@NotNull WorkspaceFilter filter, @NotNull NodeTypeManagerProvider ntManagerProvider,\n            @NotNull EffectiveNodeType defaultEffectiveNodeType, @NotNull ValidationMessageSeverity defaultSeverity,\n            @NotNull ValidationMessageSeverity severityForUnknownNodeTypes)", "testcase": false, "constructor": true}, {"identifier": "getDocViewNodeLabel", "parameters": "(DocViewNode node)", "modifiers": "static", "return": "String", "signature": "String getDocViewNodeLabel(DocViewNode node)", "full_signature": "static String getDocViewNodeLabel(DocViewNode node)", "class_method_signature": "NodeTypeValidator.getDocViewNodeLabel(DocViewNode node)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "full_signature": "@Override public @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "class_method_signature": "NodeTypeValidator.validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "testcase": false, "constructor": false}, {"identifier": "validateEnd", "parameters": "(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validateEnd(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "full_signature": "@Override public @Nullable Collection<ValidationMessage> validateEnd(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "class_method_signature": "NodeTypeValidator.validateEnd(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "testcase": false, "constructor": false}, {"identifier": "validateJcrPath", "parameters": "(@NotNull NodeContext nodeContext, boolean isFolder)", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext, boolean isFolder)", "full_signature": "@Override public @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext, boolean isFolder)", "class_method_signature": "NodeTypeValidator.validateJcrPath(@NotNull NodeContext nodeContext, boolean isFolder)", "testcase": false, "constructor": false}, {"identifier": "effectiveNodeTypeToString", "parameters": "(NameResolver nameResolver, EffectiveNodeType nodeType)", "modifiers": "static", "return": "String", "signature": "String effectiveNodeTypeToString(NameResolver nameResolver, EffectiveNodeType nodeType)", "full_signature": "static String effectiveNodeTypeToString(NameResolver nameResolver, EffectiveNodeType nodeType)", "class_method_signature": "NodeTypeValidator.effectiveNodeTypeToString(NameResolver nameResolver, EffectiveNodeType nodeType)", "testcase": false, "constructor": false}, {"identifier": "nodeDefinitionToString", "parameters": "(NameResolver nameResolver, QNodeDefinition nodeDefinition)", "modifiers": "static", "return": "String", "signature": "String nodeDefinitionToString(NameResolver nameResolver, QNodeDefinition nodeDefinition)", "full_signature": "static String nodeDefinitionToString(NameResolver nameResolver, QNodeDefinition nodeDefinition)", "class_method_signature": "NodeTypeValidator.nodeDefinitionToString(NameResolver nameResolver, QNodeDefinition nodeDefinition)", "testcase": false, "constructor": false}, {"identifier": "joinAsQualifiedJcrName", "parameters": "(NameResolver nameResolver, Name[] names)", "modifiers": "private static", "return": "String", "signature": "String joinAsQualifiedJcrName(NameResolver nameResolver, Name[] names)", "full_signature": "private static String joinAsQualifiedJcrName(NameResolver nameResolver, Name[] names)", "class_method_signature": "NodeTypeValidator.joinAsQualifiedJcrName(NameResolver nameResolver, Name[] names)", "testcase": false, "constructor": false}, {"identifier": "getPropertyDefinition", "parameters": "(Name name, int type, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, boolean multiValued)", "modifiers": "private static", "return": "QPropertyDefinition", "signature": "QPropertyDefinition getPropertyDefinition(Name name, int type, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, boolean multiValued)", "full_signature": "private static QPropertyDefinition getPropertyDefinition(Name name, int type, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, boolean multiValued)", "class_method_signature": "NodeTypeValidator.getPropertyDefinition(Name name, int type, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, boolean multiValued)", "testcase": false, "constructor": false}, {"identifier": "validateValueConstraints", "parameters": "(Value value, QPropertyDefinition def, ValueFactory valueFactory,\n            QValueFactory qValueFactory, NamePathResolver namePathResolver)", "modifiers": "private static", "return": "void", "signature": "void validateValueConstraints(Value value, QPropertyDefinition def, ValueFactory valueFactory,\n            QValueFactory qValueFactory, NamePathResolver namePathResolver)", "full_signature": "private static void validateValueConstraints(Value value, QPropertyDefinition def, ValueFactory valueFactory,\n            QValueFactory qValueFactory, NamePathResolver namePathResolver)", "class_method_signature": "NodeTypeValidator.validateValueConstraints(Value value, QPropertyDefinition def, ValueFactory valueFactory,\n            QValueFactory qValueFactory, NamePathResolver namePathResolver)", "testcase": false, "constructor": false}, {"identifier": "getPropertyConstraintViolation", "parameters": "(DocViewProperty property, EffectiveNodeType effectiveNodeType, boolean allowProtected)", "modifiers": "", "return": "String", "signature": "String getPropertyConstraintViolation(DocViewProperty property, EffectiveNodeType effectiveNodeType, boolean allowProtected)", "full_signature": " String getPropertyConstraintViolation(DocViewProperty property, EffectiveNodeType effectiveNodeType, boolean allowProtected)", "class_method_signature": "NodeTypeValidator.getPropertyConstraintViolation(DocViewProperty property, EffectiveNodeType effectiveNodeType, boolean allowProtected)", "testcase": false, "constructor": false}, {"identifier": "getPropertyConstraintViolation", "parameters": "(Name name, Value value, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, ValueFactory valueFactory, QValueFactory qValueFactory,\n            NamePathResolver namePathResolver, boolean allowProtected)", "modifiers": "static", "return": "String", "signature": "String getPropertyConstraintViolation(Name name, Value value, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, ValueFactory valueFactory, QValueFactory qValueFactory,\n            NamePathResolver namePathResolver, boolean allowProtected)", "full_signature": "static String getPropertyConstraintViolation(Name name, Value value, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, ValueFactory valueFactory, QValueFactory qValueFactory,\n            NamePathResolver namePathResolver, boolean allowProtected)", "class_method_signature": "NodeTypeValidator.getPropertyConstraintViolation(Name name, Value value, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, ValueFactory valueFactory, QValueFactory qValueFactory,\n            NamePathResolver namePathResolver, boolean allowProtected)", "testcase": false, "constructor": false}, {"identifier": "getPropertyConstraintViolation", "parameters": "(Name name, Value[] values, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, ValueFactory valueFactory, QValueFactory qValueFactory,\n            NamePathResolver namePathResolver, boolean allowProtected)", "modifiers": "static", "return": "String", "signature": "String getPropertyConstraintViolation(Name name, Value[] values, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, ValueFactory valueFactory, QValueFactory qValueFactory,\n            NamePathResolver namePathResolver, boolean allowProtected)", "full_signature": "static String getPropertyConstraintViolation(Name name, Value[] values, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, ValueFactory valueFactory, QValueFactory qValueFactory,\n            NamePathResolver namePathResolver, boolean allowProtected)", "class_method_signature": "NodeTypeValidator.getPropertyConstraintViolation(Name name, Value[] values, EffectiveNodeType effectiveNodeType,\n            ItemDefinitionProvider itemDefinitionProvider, ValueFactory valueFactory, QValueFactory qValueFactory,\n            NamePathResolver namePathResolver, boolean allowProtected)", "testcase": false, "constructor": false}, {"identifier": "getChildNodeConstraintViolation", "parameters": "(DocViewNode node, EffectiveNodeType nodeType,\n            NodeTypeDefinitionProvider nodeTypeDefinitionProvider,\n            NameResolver nameResolver, ItemDefinitionProvider itemDefinitionProvider, boolean allowProtected)", "modifiers": "static", "return": "String", "signature": "String getChildNodeConstraintViolation(DocViewNode node, EffectiveNodeType nodeType,\n            NodeTypeDefinitionProvider nodeTypeDefinitionProvider,\n            NameResolver nameResolver, ItemDefinitionProvider itemDefinitionProvider, boolean allowProtected)", "full_signature": "static String getChildNodeConstraintViolation(DocViewNode node, EffectiveNodeType nodeType,\n            NodeTypeDefinitionProvider nodeTypeDefinitionProvider,\n            NameResolver nameResolver, ItemDefinitionProvider itemDefinitionProvider, boolean allowProtected)", "class_method_signature": "NodeTypeValidator.getChildNodeConstraintViolation(DocViewNode node, EffectiveNodeType nodeType,\n            NodeTypeDefinitionProvider nodeTypeDefinitionProvider,\n            NameResolver nameResolver, ItemDefinitionProvider itemDefinitionProvider, boolean allowProtected)", "testcase": false, "constructor": false}, {"identifier": "done", "parameters": "()", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> done()", "full_signature": "@Override public @Nullable Collection<ValidationMessage> done()", "class_method_signature": "NodeTypeValidator.done()", "testcase": false, "constructor": false}], "file": "vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java"}, "focal_method": {"identifier": "validate", "parameters": "(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "body": "@Override\n    public @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot) {\n\n        if (node.primary == null) {\n            // only an issue if contained in the filter\n            // if other properties are set this node is not only used for ordering purposes\n            if (filter.contains(nodeContext.getNodePath()) && !node.props.isEmpty()) {\n                return Collections.singleton(\n                        new ValidationMessage(defaultSeverity, String.format(MESSAGE_MISSING_PRIMARY_TYPE, nodeContext.getNodePath())));\n            } else {\n                // order node only or outside filter\n                return null;\n            }\n        }\n\n        // special handling for users and acls\n        if (aclManagement.isACLNodeType(node.primary) || userManagement.isAuthorizableNodeType(node.primary)) {\n            protectedNodeContext = nodeContext;\n        }\n\n        boolean allowProtectedSubNodesAndProperties = protectedNodeContext != null;\n        Collection<ValidationMessage> messages = new LinkedList<>();\n        String parentNodePath = Text.getRelativeParent(nodeContext.getNodePath(), 1);\n        NodeNameAndType parentNodeNameAndType = nodeTypePerPath.get(parentNodePath);\n        NodeNameAndType newNodeNameAndType = null;\n        try {\n            // check node itself against parent node type\n            if (!aclManagement.isACLNodeType(node.primary)) {\n                final EffectiveNodeType parentNodeType;\n                final boolean useDefaultNodeType;\n\n                if (parentNodeNameAndType == null || !filter.contains(parentNodePath)) {\n                    parentNodeType = defaultType;\n                    useDefaultNodeType = true;\n                } else if (!parentNodeNameAndType.isUnknown()) {\n                    parentNodeType = parentNodeNameAndType.getEffectiveNodeType();\n                    useDefaultNodeType = false;\n                } else {\n                    parentNodeType = null;\n                    useDefaultNodeType = false;\n                }\n\n                if (parentNodeType != null) {\n                    String constraintViolation = getChildNodeConstraintViolation(node, parentNodeType,\n                            ntManagerProvider.getNodeTypeDefinitionProvider(),\n                            ntManagerProvider.getNameResolver(), ntManagerProvider.getItemDefinitionProvider(),\n                            allowProtectedSubNodesAndProperties);\n                    if (constraintViolation != null) {\n                        messages.add(new ValidationMessage(defaultSeverity,\n                                String.format(\n                                        useDefaultNodeType ? MESSAGE_CHILD_NODE_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED\n                                                : MESSAGE_CHILD_NODE_NOT_ALLOWED,\n                                        getDocViewNodeLabel(node),\n                                        effectiveNodeTypeToString(ntManagerProvider.getNameResolver(), parentNodeType),\n                                        constraintViolation)));\n\n                    }\n                }\n            }\n\n            // get current node's node type and name and register in tree\n            newNodeNameAndType = new NodeNameAndType(ntManagerProvider.getNameResolver(),\n                    ntManagerProvider.getEffectiveNodeTypeProvider(), node);\n            nodeTypePerPath.put(nodeContext.getNodePath(), newNodeNameAndType);\n\n            // check all properties\n            Collection<Name> foundProperties = new ArrayList<>(node.props.size());\n            for (DocViewProperty property : node.props.values()) {\n                String constraintViolation = getPropertyConstraintViolation(property, newNodeNameAndType.getEffectiveNodeType(),\n                        allowProtectedSubNodesAndProperties);\n                if (constraintViolation != null) {\n                    messages.add(new ValidationMessage(defaultSeverity, String.format(MESSAGE_PROPERTY_NOT_ALLOWED, property,\n                            effectiveNodeTypeToString(ntManagerProvider.getNameResolver(), newNodeNameAndType.getEffectiveNodeType()),\n                            constraintViolation)));\n                }\n                foundProperties.add(NameFactoryImpl.getInstance().create(property.name));\n            }\n            // are all mandatory properties covered?\n            for (QPropertyDefinition mandatoryPropertyDefinition : newNodeNameAndType.getEffectiveNodeType()\n                    .getMandatoryQPropertyDefinitions()) {\n                // ignore auto-created properties as they are created on-demand\n                if (!mandatoryPropertyDefinition.isAutoCreated() && !foundProperties.contains(mandatoryPropertyDefinition.getName())) {\n\n                    // ignore propertes which may be provided by the {@link FileArtifactHandler} (they are part of another file)\n                    List<Name> ignoredProperties = IGNORED_MANDATORY_PROPERTIES_PER_NODE_TYPE\n                            .get(mandatoryPropertyDefinition.getDeclaringNodeType());\n                    if (ignoredProperties != null && ignoredProperties.contains(mandatoryPropertyDefinition.getName())) {\n                        // TODO: skipping for now as validating those from other files requires major effort\n                        continue;\n                    }\n                    messages.add(new ValidationMessage(defaultSeverity,\n                            String.format(MESSAGE_MANDATORY_PROPERTY_MISSING, mandatoryPropertyDefinition.getName(),\n                                    effectiveNodeTypeToString(ntManagerProvider.getNameResolver(),\n                                            newNodeNameAndType.getEffectiveNodeType()))));\n                }\n            }\n\n        } catch (NoSuchNodeTypeException | IllegalNameException | NamespaceException e) {\n            // log each unknown node type/namespace only once!\n            if (!loggedUnknownNodeTypeMessages.contains(e.getMessage())) {\n                messages.add(new ValidationMessage(severityForUnknownNodeTypes,\n                        String.format(MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage()), e));\n                loggedUnknownNodeTypeMessages.add(e.getMessage());\n            }\n            if (newNodeNameAndType == null) {\n                nodeTypePerPath.put(nodeContext.getNodePath(), NodeNameAndType.createUnknownNodeNameAndType(parentNodeNameAndType));\n            }\n        } catch (RepositoryException e) {\n            throw new IllegalStateException(\"Could not validate nodes/properties against node types: \" + e.getMessage(), e);\n        }\n        return messages;\n    }", "signature": "Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "full_signature": "@Override public @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "class_method_signature": "NodeTypeValidator.validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "testcase": false, "constructor": false, "invocations": ["contains", "getNodePath", "isEmpty", "singleton", "format", "getNodePath", "isACLNodeType", "isAuthorizableNodeType", "getRelativeParent", "getNodePath", "get", "isACLNodeType", "contains", "isUnknown", "getEffectiveNodeType", "getChildNodeConstraintViolation", "getNodeTypeDefinitionProvider", "getNameResolver", "getItemDefinitionProvider", "add", "format", "getDocViewNodeLabel", "effectiveNodeTypeToString", "getNameResolver", "getNameResolver", "getEffectiveNodeTypeProvider", "put", "getNodePath", "size", "values", "getPropertyConstraintViolation", "getEffectiveNodeType", "add", "format", "effectiveNodeTypeToString", "getNameResolver", "getEffectiveNodeType", "add", "create", "getInstance", "getMandatoryQPropertyDefinitions", "getEffectiveNodeType", "isAutoCreated", "contains", "getName", "get", "getDeclaringNodeType", "contains", "getName", "add", "format", "getName", "effectiveNodeTypeToString", "getNameResolver", "getEffectiveNodeType", "contains", "getMessage", "add", "format", "getMessage", "add", "getMessage", "put", "getNodePath", "createUnknownNodeNameAndType", "getMessage"]}, "repository": {"repo_id": 16021499, "url": "https://github.com/apache/jackrabbit-filevault", "stars": 24, "created": "1/18/2014 8:00:07 AM +00:00", "updates": "2020-01-22T11:47:21+00:00", "fork": "False", "license": "licensed"}}