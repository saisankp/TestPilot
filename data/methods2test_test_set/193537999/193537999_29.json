{"test_class": {"identifier": "NormalizerTest", "superclass": "", "interfaces": "", "fields": [], "file": "vortex-api/src/test/java/mil/army/usace/hec/vortex/math/NormalizerTest.java"}, "test_case": {"identifier": "DtoArraysAreNormalized", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n    void DtoArraysAreNormalized() {\n        VortexGrid dto1 = mock(VortexGrid.class);\n        when(dto1.data()).thenReturn(new float[]{0,Float.NaN,2,4,2,2,2,2});\n        when(dto1.startTime()).thenReturn(ZonedDateTime.of(0, 1, 1,0,0,0,0, ZoneId.of(\"UTC\")));\n        when(dto1.endTime()).thenReturn(ZonedDateTime.of(0, 1, 1,0,0,0,0, ZoneId.of(\"UTC\")));\n\n        VortexGrid dto2 = mock(VortexGrid.class);\n        when(dto2.data()).thenReturn(new float[]{0,2,2,4,2,2,2,1});\n        when(dto2.startTime()).thenReturn(ZonedDateTime.of(0, 1, 1,0,0,0,0, ZoneId.of(\"UTC\")));\n        when(dto2.endTime()).thenReturn(ZonedDateTime.of(0, 1, 1,0,0,0,0, ZoneId.of(\"UTC\")));\n\n        VortexGrid dto3 = mock(VortexGrid.class);\n        when(dto3.data()).thenReturn(new float[]{0,2,Float.NaN,6,2,8,2,2});\n        when(dto3.startTime()).thenReturn(ZonedDateTime.of(0, 1, 1,0,0,0,0, ZoneId.of(\"UTC\")));\n        when(dto3.endTime()).thenReturn(ZonedDateTime.of(0, 1, 1,0,0,0,0, ZoneId.of(\"UTC\")));\n\n        List<VortexGrid> inputs = new ArrayList<>();\n        inputs.add(dto1);\n        inputs.add(dto2);\n\n        List<VortexGrid> normals = new ArrayList<>();\n        normals.add(dto3);\n\n        List<VortexGrid> normalized = Normalizer.normalize(inputs, normals);\n\n        float[] expected1 = new float[]{0, Float.NaN, 2, 3, 1, 4, 1, Float.parseFloat(\"1.333\")};\n\n        float[] normalized1 = normalized.get(0).data();\n        for (int i = 0; i < normalized1.length; i++){\n            try {\n                assertEquals(expected1[i], normalized1[i], 1E-3);\n            }catch(AssertionError e){\n                System.out.println(\"Error index: \" + i);\n                throw e;\n            }\n        }\n\n        float[] expected2 = new float[]{0, 2, 2, 3, 1, 4, 1, Float.parseFloat(\"0.667\")};\n\n        float[] normalized2 = normalized.get(1).data();\n        for (int i = 0; i < normalized2.length; i++) {\n            try {\n                assertEquals(expected2[i], normalized2[i], 1E-3);\n            } catch (AssertionError e) {\n                System.out.println(\"Error index: \" + i);\n                throw e;\n            }\n        }\n    }", "signature": "void DtoArraysAreNormalized()", "full_signature": "@Test void DtoArraysAreNormalized()", "class_method_signature": "NormalizerTest.DtoArraysAreNormalized()", "testcase": true, "constructor": false, "invocations": ["mock", "thenReturn", "when", "data", "thenReturn", "when", "startTime", "of", "of", "thenReturn", "when", "endTime", "of", "of", "mock", "thenReturn", "when", "data", "thenReturn", "when", "startTime", "of", "of", "thenReturn", "when", "endTime", "of", "of", "mock", "thenReturn", "when", "data", "thenReturn", "when", "startTime", "of", "of", "thenReturn", "when", "endTime", "of", "of", "add", "add", "add", "normalize", "parseFloat", "data", "get", "assertEquals", "println", "parseFloat", "data", "get", "assertEquals", "println"]}, "focal_class": {"identifier": "Normalizer", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Logger logger = Logger.getLogger(Normalizer.class.getName());", "modifier": "private static", "type": "Logger", "declarator": "logger = Logger.getLogger(Normalizer.class.getName())", "var_name": "logger"}, {"original_string": "private static DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd-MMM-yyyy HH:mm\").withZone(ZoneId.of(\"UTC\"));", "modifier": "private static", "type": "DateTimeFormatter", "declarator": "formatter = DateTimeFormatter.ofPattern(\"dd-MMM-yyyy HH:mm\").withZone(ZoneId.of(\"UTC\"))", "var_name": "formatter"}, {"original_string": "private String pathToSource;", "modifier": "private", "type": "String", "declarator": "pathToSource", "var_name": "pathToSource"}, {"original_string": "private String pathToNormals;", "modifier": "private", "type": "String", "declarator": "pathToNormals", "var_name": "pathToNormals"}, {"original_string": "private Set<String> sourceVariables;", "modifier": "private", "type": "Set<String>", "declarator": "sourceVariables", "var_name": "sourceVariables"}, {"original_string": "private Set<String> normalsVariables;", "modifier": "private", "type": "Set<String>", "declarator": "normalsVariables", "var_name": "normalsVariables"}, {"original_string": "private ZonedDateTime startTime;", "modifier": "private", "type": "ZonedDateTime", "declarator": "startTime", "var_name": "startTime"}, {"original_string": "private ZonedDateTime endTime;", "modifier": "private", "type": "ZonedDateTime", "declarator": "endTime", "var_name": "endTime"}, {"original_string": "private Duration interval;", "modifier": "private", "type": "Duration", "declarator": "interval", "var_name": "interval"}, {"original_string": "private Path destination;", "modifier": "private", "type": "Path", "declarator": "destination", "var_name": "destination"}, {"original_string": "private Options writeOptions;", "modifier": "private", "type": "Options", "declarator": "writeOptions", "var_name": "writeOptions"}], "methods": [{"identifier": "Normalizer", "parameters": "(NormalizerBuilder builder)", "modifiers": "private", "return": "", "signature": " Normalizer(NormalizerBuilder builder)", "full_signature": "private  Normalizer(NormalizerBuilder builder)", "class_method_signature": "Normalizer.Normalizer(NormalizerBuilder builder)", "testcase": false, "constructor": true}, {"identifier": "builder", "parameters": "()", "modifiers": "public static", "return": "NormalizerBuilder", "signature": "NormalizerBuilder builder()", "full_signature": "public static NormalizerBuilder builder()", "class_method_signature": "Normalizer.builder()", "testcase": false, "constructor": false}, {"identifier": "normalize", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void normalize()", "full_signature": "public void normalize()", "class_method_signature": "Normalizer.normalize()", "testcase": false, "constructor": false}, {"identifier": "normalize", "parameters": "(List<VortexGrid> source, List<VortexGrid> normals)", "modifiers": "static", "return": "List<VortexGrid>", "signature": "List<VortexGrid> normalize(List<VortexGrid> source, List<VortexGrid> normals)", "full_signature": "static List<VortexGrid> normalize(List<VortexGrid> source, List<VortexGrid> normals)", "class_method_signature": "Normalizer.normalize(List<VortexGrid> source, List<VortexGrid> normals)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(List<VortexGrid> source, List<VortexGrid> normals)", "modifiers": "private static", "return": "boolean", "signature": "boolean validate(List<VortexGrid> source, List<VortexGrid> normals)", "full_signature": "private static boolean validate(List<VortexGrid> source, List<VortexGrid> normals)", "class_method_signature": "Normalizer.validate(List<VortexGrid> source, List<VortexGrid> normals)", "testcase": false, "constructor": false}, {"identifier": "logValidationFailure", "parameters": "(String origin, VortexGrid reference, VortexGrid invalid)", "modifiers": "private static", "return": "void", "signature": "void logValidationFailure(String origin, VortexGrid reference, VortexGrid invalid)", "full_signature": "private static void logValidationFailure(String origin, VortexGrid reference, VortexGrid invalid)", "class_method_signature": "Normalizer.logValidationFailure(String origin, VortexGrid reference, VortexGrid invalid)", "testcase": false, "constructor": false}], "file": "vortex-api/src/main/java/mil/army/usace/hec/vortex/math/Normalizer.java"}, "focal_method": {"identifier": "normalize", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void normalize(){\n\n        logger.info(() -> \"Normalization started...\");\n\n        List<VortexData> source = new ArrayList<>();\n        sourceVariables.forEach(variable -> source.addAll(\n                DataReader.builder()\n                        .path(pathToSource)\n                        .variable(variable)\n                        .build()\n                        .getDtos()));\n\n        List<VortexData> normals = new ArrayList<>();\n        normalsVariables.forEach(variable -> normals.addAll(\n                DataReader.builder()\n                        .path(pathToNormals)\n                        .variable(variable)\n                        .build()\n                        .getDtos()));\n\n        AtomicReference<ZonedDateTime> intervalStart = new AtomicReference<>();\n        intervalStart.set(startTime);\n\n        AtomicInteger count = new AtomicInteger();\n        while (intervalStart.get().isBefore(endTime)){\n            ZonedDateTime start = intervalStart.get();\n            ZonedDateTime end = intervalStart.get().plus(interval);\n\n            List<VortexGrid> sourceFiltered = source.stream().filter(grid -> ((grid.startTime().isEqual(start) || grid.startTime().isAfter(start))\n                    && (grid.endTime().isEqual(end) || grid.endTime().isBefore(end))))\n                    .map(grid -> (VortexGrid)grid)\n                    .collect(Collectors.toList());\n\n            if (sourceFiltered.isEmpty()) {\n                logger.warning(() -> format(\"No source grids for period %s to %s\", formatter.format(start), formatter.format(end)));\n            }\n\n            List<VortexGrid> normalsFiltered = normals.stream().filter(grid -> ((grid.startTime().equals(start) || grid.startTime().isAfter(start))\n                    && (grid.endTime().isEqual(end) || grid.endTime().isBefore(end))))\n                    .map(grid -> (VortexGrid)grid)\n                    .collect(Collectors.toList());\n\n            if (normalsFiltered.isEmpty()){\n                logger.warning(() -> format(\"No normals grids for period %s to %s\", formatter.format(start), formatter.format(end)));\n            }\n\n            List<VortexGrid> output = normalize(sourceFiltered, normalsFiltered);\n\n            output.forEach(grid -> {\n                List<VortexData> data = new ArrayList<>();\n                data.add(grid);\n\n                DataWriter writer = DataWriter.builder()\n                        .data(data)\n                        .destination(destination)\n                        .options(writeOptions)\n                        .build();\n\n                writer.write();\n            });\n\n            intervalStart.set(end);\n            count.addAndGet(output.size());\n        }\n        logger.info(() -> format(\"Normalization complete: %s grids normalized.\", count.get()));\n    }", "signature": "void normalize()", "full_signature": "public void normalize()", "class_method_signature": "Normalizer.normalize()", "testcase": false, "constructor": false, "invocations": ["info", "forEach", "addAll", "getDtos", "build", "variable", "path", "builder", "forEach", "addAll", "getDtos", "build", "variable", "path", "builder", "set", "isBefore", "get", "get", "plus", "get", "collect", "map", "filter", "stream", "isEqual", "startTime", "isAfter", "startTime", "isEqual", "endTime", "isBefore", "endTime", "toList", "isEmpty", "warning", "format", "format", "format", "collect", "map", "filter", "stream", "equals", "startTime", "isAfter", "startTime", "isEqual", "endTime", "isBefore", "endTime", "toList", "isEmpty", "warning", "format", "format", "format", "normalize", "forEach", "add", "build", "options", "destination", "data", "builder", "write", "set", "addAndGet", "size", "info", "format", "get"]}, "repository": {"repo_id": 193537999, "url": "https://github.com/HydrologicEngineeringCenter/Vortex", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 5, "size": 448543, "license": "licensed"}}