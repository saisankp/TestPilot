{"test_class": {"identifier": "CSVWrapperTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final String CSV_FILE_NAME =  \"test.csv.csv\";", "modifier": "private final", "type": "String", "declarator": "CSV_FILE_NAME =  \"test.csv.csv\"", "var_name": "CSV_FILE_NAME"}, {"original_string": "private final String CHECK_POINT_DIR = \"csv-check-points.csv\";", "modifier": "private final", "type": "String", "declarator": "CHECK_POINT_DIR = \"csv-check-points.csv\"", "var_name": "CHECK_POINT_DIR"}], "file": "gsn-core/src/test/java/ch/epfl/gsn/wrappers/general/CSVWrapperTest.java"}, "test_case": {"identifier": "testFieldConverting", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testFieldConverting() throws IOException {\n\t\tString fields = \"TIMED, air_temp , TIMED , AiR_TeMp2\";\n\t\tString formats = \"Timestamp(d.M.y ) , Numeric , timestamp(k:m) , numeric    \";\n\t\tString badFormat = \"Timestamp(d.M.y k:m) , numeric , numeric, numeric,numeric,dollluble \";\n\t\tString badFormat2 =\"Timestamp(d.Mjo0o.y k:m) , numeric, numeric, numeric\";\n\t\t\n\t\tCSVHandler wrapper = new CSVHandler();\n\t\tassertEquals(false,wrapper.initialize(\"test.csv.csv\", fields,badFormat,',','\\\"',0,\"NaN,-1234,4321\"));\n\t\tassertEquals(false,wrapper.initialize(\"test.csv.csv\", fields,badFormat,',','\\\"',0,\"NaN,-1234,4321\"));\n\t\tassertEquals(false,wrapper.initialize(\"test.csv.csv\", fields,badFormat2,',','\\\"',0,\"NaN,-1234,4321\"));\n\t\t\n\t\tassertEquals(true,wrapper.initialize(\"test.csv.csv\", fields,formats,',','\\\"',0,\"NaN,-1234,4321\"));\n\t\t\n\t\tFileUtils.writeStringToFile(new File(wrapper.getCheckPointFile()),  \"\",\"UTF-8\");\n\t\tString[] formatsParsed = wrapper.getFormats();\n\t\tString[] fieldsParsed =  wrapper.getFields();\n\t\tassertEquals(true,compare(fieldsParsed, new String[] {\"timed\",\"air_temp\",\"timed\",\"air_temp2\"}));\n\t\tassertEquals(true,compare(formatsParsed, new String[] {\"Timestamp(d.M.y )\",\"Numeric\",\"timestamp(k:m)\",\"numeric\"}));\n\t\t\n\t\tTreeMap<String, Serializable> se = wrapper.convertTo(wrapper.getFormats(),wrapper.getFields(),wrapper.getNulls(),new String[] {} , wrapper.getSeparator());\n\t\tassertEquals(wrapper.getFields().length-1, se.keySet().size());//timestamp is douplicated.\n\t\tassertEquals(null, se.get(\"timed\"));\n\t\tse = wrapper.convertTo(wrapper.getFormats(),wrapper.getFields(),wrapper.getNulls(),new String[] {\"\",\"\",\"\",\"-1234\",\"4321\",\"NaN\"} , wrapper.getSeparator());\n\t\tassertEquals(null, se.get(\"timed\"));\n\t\t\n\t\tse = wrapper.convertTo(wrapper.getFormats(),wrapper.getFields(),wrapper.getNulls(),new String[] {\"\",\"\",\"\",\"-1234\",\"4321\",\"NaN\"} , wrapper.getSeparator());\n\t\tassertEquals(null, se.get(\"timed\"));\n\t\t\n\t\tse = wrapper.convertTo(wrapper.getFormats(),wrapper.getFields(),wrapper.getNulls(),new String[] {\"01.01.2009\",\"1234\",\"\",\"-4321\",\"ignore-me\",\"NaN\"} , wrapper.getSeparator());\n\t\tlong parsedTimestamp = (Long)se.get(\"timed\");\n\t\tassertEquals(true,parsedTimestamp>0);\n\t\tassertEquals(1234.0, se.get(\"air_temp\"));\n\t\tassertEquals(-4321.0, se.get(\"air_temp2\"));\n\t\t\n\t\tse = wrapper.convertTo(wrapper.getFormats(),wrapper.getFields(),wrapper.getNulls(),new String[] {\"01.01.2009\",\"-1234\",\"10:10\",\"-4321\",\"ignore-me\",\"NaN\"} , wrapper.getSeparator());\n\t\tassertEquals(true,((Long)se.get(\"timed\"))>parsedTimestamp);\n\t\tassertNull(se.get(\"air_temp\"));\n\t\n\t}", "signature": "void testFieldConverting()", "full_signature": "@Test public void testFieldConverting()", "class_method_signature": "CSVWrapperTest.testFieldConverting()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "initialize", "assertEquals", "initialize", "assertEquals", "initialize", "assertEquals", "initialize", "writeStringToFile", "getCheckPointFile", "getFormats", "getFields", "assertEquals", "compare", "assertEquals", "compare", "convertTo", "getFormats", "getFields", "getNulls", "getSeparator", "assertEquals", "getFields", "size", "keySet", "assertEquals", "get", "convertTo", "getFormats", "getFields", "getNulls", "getSeparator", "assertEquals", "get", "convertTo", "getFormats", "getFields", "getNulls", "getSeparator", "assertEquals", "get", "convertTo", "getFormats", "getFields", "getNulls", "getSeparator", "get", "assertEquals", "assertEquals", "get", "assertEquals", "get", "convertTo", "getFormats", "getFields", "getNulls", "getSeparator", "assertEquals", "get", "assertNull", "get"]}, "focal_class": {"identifier": "CSVWrapper", "superclass": "extends AbstractWrapper", "interfaces": "", "fields": [{"original_string": "private final transient Logger logger = LoggerFactory.getLogger(CSVWrapper.class);", "modifier": "private final transient", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(CSVWrapper.class)", "var_name": "logger"}, {"original_string": "private static int threadCounter = 0;", "modifier": "private static", "type": "int", "declarator": "threadCounter = 0", "var_name": "threadCounter"}, {"original_string": "private DataField[] dataField;", "modifier": "private", "type": "DataField[]", "declarator": "dataField", "var_name": "dataField"}, {"original_string": "private CSVHandler handler = new CSVHandler();", "modifier": "private", "type": "CSVHandler", "declarator": "handler = new CSVHandler()", "var_name": "handler"}, {"original_string": "private int samplingPeriodInMsc;", "modifier": "private", "type": "int", "declarator": "samplingPeriodInMsc", "var_name": "samplingPeriodInMsc"}, {"original_string": "private String checkPointDir;", "modifier": "private", "type": "String", "declarator": "checkPointDir", "var_name": "checkPointDir"}, {"original_string": "private String dataFile;", "modifier": "private", "type": "String", "declarator": "dataFile", "var_name": "dataFile"}, {"original_string": "boolean useCounterForCheckPoint = false;", "modifier": "", "type": "boolean", "declarator": "useCounterForCheckPoint = false", "var_name": "useCounterForCheckPoint"}, {"original_string": "long processedLineCounter = 0;", "modifier": "", "type": "long", "declarator": "processedLineCounter = 0", "var_name": "processedLineCounter"}], "methods": [{"identifier": "initialize", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean initialize()", "full_signature": "public boolean initialize()", "class_method_signature": "CSVWrapper.initialize()", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void run()", "full_signature": "public void run()", "class_method_signature": "CSVWrapper.run()", "testcase": false, "constructor": false}, {"identifier": "getOutputFormat", "parameters": "()", "modifiers": "public", "return": "DataField[]", "signature": "DataField[] getOutputFormat()", "full_signature": "public DataField[] getOutputFormat()", "class_method_signature": "CSVWrapper.getOutputFormat()", "testcase": false, "constructor": false}, {"identifier": "getWrapperName", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getWrapperName()", "full_signature": "public String getWrapperName()", "class_method_signature": "CSVWrapper.getWrapperName()", "testcase": false, "constructor": false}, {"identifier": "dispose", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void dispose()", "full_signature": "public void dispose()", "class_method_signature": "CSVWrapper.dispose()", "testcase": false, "constructor": false}, {"identifier": "DEBUG_INFO", "parameters": "(String s)", "modifiers": "public", "return": "void", "signature": "void DEBUG_INFO(String s)", "full_signature": "public void DEBUG_INFO(String s)", "class_method_signature": "CSVWrapper.DEBUG_INFO(String s)", "testcase": false, "constructor": false}, {"identifier": "list", "parameters": "(String name, long value)", "modifiers": "", "return": "String", "signature": "String list(String name, long value)", "full_signature": " String list(String name, long value)", "class_method_signature": "CSVWrapper.list(String name, long value)", "testcase": false, "constructor": false}], "file": "gsn-core/src/main/java/ch/epfl/gsn/wrappers/general/CSVWrapper.java"}, "focal_method": {"identifier": "initialize", "parameters": "()", "modifiers": "public", "return": "boolean", "body": "public boolean initialize() {\n        AddressBean addressBean = getActiveAddressBean();\n        dataFile = addressBean.getPredicateValueWithException(\"file\");\n        String csvFields = addressBean.getPredicateValueWithException(\"fields\");\n        String csvFormats = addressBean.getPredicateValueWithException(\"formats\");\n        //String csvSeparator = addressBean.getPredicateValueWithDefault(\"separator\",\",\");\n        String value = addressBean.getPredicateValue(\"separator\");\n        String csvSeparator = (value == null || value.length() == 0) ? \",\" : value;\n        checkPointDir = addressBean.getPredicateValueWithDefault(\"check-point-directory\", \"./csv-check-points\");\n        String csvStringQuote = addressBean.getPredicateValueWithDefault(\"quote\", \"\\\"\");\n        int skipFirstXLine = addressBean.getPredicateValueAsInt(\"skip-first-lines\", 0);\n        String timezone = addressBean.getPredicateValueWithDefault(\"timezone\", handler.LOCAL_TIMEZONE_ID);\n        String nullValues = addressBean.getPredicateValueWithDefault(\"bad-values\", \"\");\n        String strUseCounterForCheckPoint = addressBean.getPredicateValueWithDefault(\"use-counter-for-check-point\", \"false\");\n        samplingPeriodInMsc = addressBean.getPredicateValueAsInt(\"sampling\", 10000);\n\n        /*\n        DEBUG_INFO(dataFile);\n        */\n\n        if (csvSeparator != null && csvSeparator.length() != 1) {\n            logger.warn(\"The provided CSV separator:>\" + csvSeparator + \"< should only have  1 character, thus ignored and instead \\\",\\\" is used.\");\n            csvSeparator = \",\";\n        }\n\n        if (csvStringQuote.length() != 1) {\n            logger.warn(\"The provided CSV quote:>\" + csvSeparator + \"< should only have 1 character, thus ignored and instead '\\\"' is used.\");\n            csvStringQuote = \"\\\"\";\n        }\n\n        try {\n            if (strUseCounterForCheckPoint.equalsIgnoreCase(\"true\")) {\n                useCounterForCheckPoint = true;\n                logger.warn(\"Using counter-based check points\");\n            }\n            //String checkPointFile = new File(checkPointDir).getAbsolutePath()+\"/\"+(new File(dataFile).getName())+\"-\"+addressBean.hashCode();\n            StringBuilder checkPointFile = new StringBuilder()\n                    .append(new File(checkPointDir).getAbsolutePath())\n                    .append(\"/\")\n                    .append(addressBean.getVirtualSensorName())\n                    .append(\"_\")\n                    .append(addressBean.getInputStreamName())\n                    .append(\"_\")\n                    .append(addressBean.getWrapper())\n                    .append(\"_\")\n                    .append(new File(dataFile).getName());\n            if (!handler.initialize(dataFile.trim(), csvFields, csvFormats, csvSeparator.toCharArray()[0], csvStringQuote.toCharArray()[0], skipFirstXLine, nullValues, timezone, checkPointFile.toString()))\n                return false;\n\n            String val = FileUtils.readFileToString(new File(checkPointFile.toString()), \"UTF-8\");\n            long lastItem = 0;\n            if (val != null && val.trim().length() > 0)\n                lastItem = Long.parseLong(val.trim());\n            logger.warn(\"Latest item: \"+lastItem);\n\n            if (useCounterForCheckPoint) {\n                processedLineCounter = lastItem;\n            }\n\n        } catch (Exception e) {\n            logger.error(\"Loading the csv-wrapper failed:\" + e.getMessage(), e);\n            return false;\n        }\n\n        dataField = handler.getDataFields();\n\n        logger.warn(\"Reading from: \" + dataFile);\n\n        return true;\n    }", "signature": "boolean initialize()", "full_signature": "public boolean initialize()", "class_method_signature": "CSVWrapper.initialize()", "testcase": false, "constructor": false, "invocations": ["getActiveAddressBean", "getPredicateValueWithException", "getPredicateValueWithException", "getPredicateValueWithException", "getPredicateValue", "length", "getPredicateValueWithDefault", "getPredicateValueWithDefault", "getPredicateValueAsInt", "getPredicateValueWithDefault", "getPredicateValueWithDefault", "getPredicateValueWithDefault", "getPredicateValueAsInt", "length", "warn", "length", "warn", "equalsIgnoreCase", "warn", "append", "append", "append", "append", "append", "append", "append", "append", "append", "getAbsolutePath", "getVirtualSensorName", "getInputStreamName", "getWrapper", "getName", "initialize", "trim", "toCharArray", "toCharArray", "toString", "readFileToString", "toString", "length", "trim", "parseLong", "trim", "warn", "error", "getMessage", "getDataFields", "warn"]}, "repository": {"repo_id": 16885508, "url": "https://github.com/LSIR/gsn", "language": "Java", "is_fork": false, "fork_count": 41, "stargazer_count": 51, "size": 375887, "license": "licensed"}}