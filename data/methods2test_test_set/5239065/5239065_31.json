{"test_class": {"identifier": "ConcurrentTreeTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Pattern delimiter = Pattern.compile(\"/\");", "modifier": "private final", "type": "Pattern", "declarator": "delimiter = Pattern.compile(\"/\")", "var_name": "delimiter"}], "file": "exposure-engine/common/src/test/java/com/alu/e3/common/util/ConcurrentTreeTest.java"}, "test_case": {"identifier": "testAdd", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testAdd() {\n\t\tConcurrentTree<String, String> tree = setupTree();\n\t\t\n\t\ttree.add(delimiter.split(\"c\"), \"c\");\n\t\tassertEquals(tree.get(delimiter.split(\"c\")), \"c\");\n\t\t\n\t\ttree.add(delimiter.split(\"c\"), \"d\");\n\t\tassertEquals(tree.get(delimiter.split(\"c\")), \"d\");\n\t\t\n\t\ttree.add(delimiter.split(\"/c\"), \"e\");\n\t\tassertEquals(tree.get(delimiter.split(\"c\")), \"d\");\n\t\tassertEquals(tree.get(delimiter.split(\"/c\")), \"e\");\n\t\t\n\t\ttree.add(delimiter.split(\"c/ \"), \"f\");\n\t\tassertEquals(tree.get(delimiter.split(\"c\")), \"d\");\n\t\tassertEquals(tree.get(delimiter.split(\"c/ \")), \"f\");\n\t\t\t\n\t\ttree.add(delimiter.split(\"a/c\"), \"g\");\n\t\tassertEquals(tree.get(delimiter.split(\"a/c\")), \"g\");\n\t\t\n\t\ttree.add(delimiter.split(\"a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z\"), \"z\");\n\t\tassertEquals(tree.get(delimiter.split(\"a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z\")), \"z\");\n\t\t\n\t\ttree.add(delimiter.split(\"a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p//q/r/s/t/u/v/w/x/y/z\"), \"y\");\n\t\tassertEquals(tree.get(delimiter.split(\"a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p//q/r/s/t/u/v/w/x/y/z\")), \"y\");\n\t\tassertEquals(tree.get(delimiter.split(\"a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z\")), \"z\");\n\t}", "signature": "void testAdd()", "full_signature": "@Test public void testAdd()", "class_method_signature": "ConcurrentTreeTest.testAdd()", "testcase": true, "constructor": false, "invocations": ["setupTree", "add", "split", "assertEquals", "get", "split", "add", "split", "assertEquals", "get", "split", "add", "split", "assertEquals", "get", "split", "assertEquals", "get", "split", "add", "split", "assertEquals", "get", "split", "assertEquals", "get", "split", "add", "split", "assertEquals", "get", "split", "add", "split", "assertEquals", "get", "split", "add", "split", "assertEquals", "get", "split", "assertEquals", "get", "split"]}, "focal_class": {"identifier": "ConcurrentTree", "superclass": "extends ConcurrentTreeNode<K, V>", "interfaces": "", "fields": [], "methods": [{"identifier": "add", "parameters": "(final K[] path, final V value)", "modifiers": "public synchronized", "return": "void", "signature": "void add(final K[] path, final V value)", "full_signature": "public synchronized void add(final K[] path, final V value)", "class_method_signature": "ConcurrentTree.add(final K[] path, final V value)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(final K[] path)", "modifiers": "public synchronized", "return": "V", "signature": "V remove(final K[] path)", "full_signature": "public synchronized V remove(final K[] path)", "class_method_signature": "ConcurrentTree.remove(final K[] path)", "testcase": false, "constructor": false}, {"identifier": "getNode", "parameters": "(final K[] path)", "modifiers": "protected", "return": "ConcurrentTreeNode<K, V>", "signature": "ConcurrentTreeNode<K, V> getNode(final K[] path)", "full_signature": "protected ConcurrentTreeNode<K, V> getNode(final K[] path)", "class_method_signature": "ConcurrentTree.getNode(final K[] path)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(final K[] path)", "modifiers": "public", "return": "V", "signature": "V get(final K[] path)", "full_signature": "public V get(final K[] path)", "class_method_signature": "ConcurrentTree.get(final K[] path)", "testcase": false, "constructor": false}, {"identifier": "getMatches", "parameters": "(final K[] path)", "modifiers": "public", "return": "List<V>", "signature": "List<V> getMatches(final K[] path)", "full_signature": "public List<V> getMatches(final K[] path)", "class_method_signature": "ConcurrentTree.getMatches(final K[] path)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "ConcurrentTree.toString()", "testcase": false, "constructor": false}], "file": "exposure-engine/common/src/main/java/com/alu/e3/common/util/ConcurrentTree.java"}, "focal_method": {"identifier": "add", "parameters": "(final K[] path, final V value)", "modifiers": "public synchronized", "return": "void", "body": "public synchronized void add(final K[] path, final V value) {\n\t\tConcurrentTreeNode<K, V> node = this;\n\t\tfor (final K part : path) {\n\t\t\tif (node.getChild(part) == null) {\n\t\t\t\tnode.addChild(new ConcurrentTreeNode<K, V>(part, node));\n\t\t\t}\n\t\t\tnode = node.getChild(part);\n\t\t}\n\n\t\tnode.setValue(value);\n\t}", "signature": "void add(final K[] path, final V value)", "full_signature": "public synchronized void add(final K[] path, final V value)", "class_method_signature": "ConcurrentTree.add(final K[] path, final V value)", "testcase": false, "constructor": false, "invocations": ["getChild", "addChild", "getChild", "setValue"]}, "repository": {"repo_id": 5239065, "url": "https://github.com/apigrove/apigrove", "language": "Java", "is_fork": false, "fork_count": 33, "stargazer_count": 118, "size": 215144, "license": "licensed"}}