{"test_class": {"identifier": "CoercedExpressionTest", "superclass": "", "interfaces": "", "fields": [], "file": "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/builder/generator/drlxparse/CoercedExpressionTest.java"}, "test_case": {"identifier": "stringToInt", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void stringToInt() {\n        final TypedExpression left = expr(THIS_PLACEHOLDER + \".getName()\", String.class);\n        final TypedExpression right = expr(\"40\", int.class);\n        final CoercedExpression.CoercedExpressionResult coerce = new CoercedExpression(left, right, false).coerce();\n        assertEquals(expr(\"String.valueOf(40)\", String.class), coerce.getCoercedRight());\n    }", "signature": "void stringToInt()", "full_signature": "@Test public void stringToInt()", "class_method_signature": "CoercedExpressionTest.stringToInt()", "testcase": true, "constructor": false, "invocations": ["expr", "expr", "coerce", "assertEquals", "expr", "getCoercedRight"]}, "focal_class": {"identifier": "CoercedExpression", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final List<Class<?>> LITERAL_NUMBER_CLASSES = Arrays.asList(int.class, long.class, double.class, Integer.class, Long.class, Double.class);", "modifier": "private static final", "type": "List<Class<?>>", "declarator": "LITERAL_NUMBER_CLASSES = Arrays.asList(int.class, long.class, double.class, Integer.class, Long.class, Double.class)", "var_name": "LITERAL_NUMBER_CLASSES"}, {"original_string": "private final TypedExpression left;", "modifier": "private final", "type": "TypedExpression", "declarator": "left", "var_name": "left"}, {"original_string": "private final TypedExpression right;", "modifier": "private final", "type": "TypedExpression", "declarator": "right", "var_name": "right"}, {"original_string": "private final boolean equalityExpr;", "modifier": "private final", "type": "boolean", "declarator": "equalityExpr", "var_name": "equalityExpr"}, {"original_string": "private static Map<Class, List<Class<?>>> narrowingTypes = new HashMap<>();", "modifier": "private static", "type": "Map<Class, List<Class<?>>>", "declarator": "narrowingTypes = new HashMap<>()", "var_name": "narrowingTypes"}], "methods": [{"identifier": "CoercedExpression", "parameters": "(TypedExpression left, TypedExpression right, boolean equalityExpr)", "modifiers": "public", "return": "", "signature": " CoercedExpression(TypedExpression left, TypedExpression right, boolean equalityExpr)", "full_signature": "public  CoercedExpression(TypedExpression left, TypedExpression right, boolean equalityExpr)", "class_method_signature": "CoercedExpression.CoercedExpression(TypedExpression left, TypedExpression right, boolean equalityExpr)", "testcase": false, "constructor": true}, {"identifier": "coerce", "parameters": "()", "modifiers": "public", "return": "CoercedExpressionResult", "signature": "CoercedExpressionResult coerce()", "full_signature": "public CoercedExpressionResult coerce()", "class_method_signature": "CoercedExpression.coerce()", "testcase": false, "constructor": false}, {"identifier": "isBoolean", "parameters": "(Class<?> leftClass)", "modifiers": "private", "return": "boolean", "signature": "boolean isBoolean(Class<?> leftClass)", "full_signature": "private boolean isBoolean(Class<?> leftClass)", "class_method_signature": "CoercedExpression.isBoolean(Class<?> leftClass)", "testcase": false, "constructor": false}, {"identifier": "shouldCoerceBToMap", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean shouldCoerceBToMap()", "full_signature": "private boolean shouldCoerceBToMap()", "class_method_signature": "CoercedExpression.shouldCoerceBToMap()", "testcase": false, "constructor": false}, {"identifier": "canCoerce", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean canCoerce()", "full_signature": "private boolean canCoerce()", "class_method_signature": "CoercedExpression.canCoerce()", "testcase": false, "constructor": false}, {"identifier": "castToClass", "parameters": "(Class<?> clazz)", "modifiers": "private", "return": "TypedExpression", "signature": "TypedExpression castToClass(Class<?> clazz)", "full_signature": "private TypedExpression castToClass(Class<?> clazz)", "class_method_signature": "CoercedExpression.castToClass(Class<?> clazz)", "testcase": false, "constructor": false}, {"identifier": "coerceToString", "parameters": "(TypedExpression typedExpression)", "modifiers": "private static", "return": "TypedExpression", "signature": "TypedExpression coerceToString(TypedExpression typedExpression)", "full_signature": "private static TypedExpression coerceToString(TypedExpression typedExpression)", "class_method_signature": "CoercedExpression.coerceToString(TypedExpression typedExpression)", "testcase": false, "constructor": false}, {"identifier": "coerceToDate", "parameters": "(TypedExpression typedExpression)", "modifiers": "private static", "return": "TypedExpression", "signature": "TypedExpression coerceToDate(TypedExpression typedExpression)", "full_signature": "private static TypedExpression coerceToDate(TypedExpression typedExpression)", "class_method_signature": "CoercedExpression.coerceToDate(TypedExpression typedExpression)", "testcase": false, "constructor": false}, {"identifier": "coerceBoolean", "parameters": "(TypedExpression typedExpression)", "modifiers": "private static", "return": "TypedExpression", "signature": "TypedExpression coerceBoolean(TypedExpression typedExpression)", "full_signature": "private static TypedExpression coerceBoolean(TypedExpression typedExpression)", "class_method_signature": "CoercedExpression.coerceBoolean(TypedExpression typedExpression)", "testcase": false, "constructor": false}, {"identifier": "canCoerceLiteralNumberExpr", "parameters": "(Class<?> type)", "modifiers": "private static", "return": "boolean", "signature": "boolean canCoerceLiteralNumberExpr(Class<?> type)", "full_signature": "private static boolean canCoerceLiteralNumberExpr(Class<?> type)", "class_method_signature": "CoercedExpression.canCoerceLiteralNumberExpr(Class<?> type)", "testcase": false, "constructor": false}, {"identifier": "shouldCoerceBToString", "parameters": "(TypedExpression a, TypedExpression b)", "modifiers": "private static", "return": "boolean", "signature": "boolean shouldCoerceBToString(TypedExpression a, TypedExpression b)", "full_signature": "private static boolean shouldCoerceBToString(TypedExpression a, TypedExpression b)", "class_method_signature": "CoercedExpression.shouldCoerceBToString(TypedExpression a, TypedExpression b)", "testcase": false, "constructor": false}, {"identifier": "isNotBinaryExpression", "parameters": "(TypedExpression e)", "modifiers": "private static", "return": "boolean", "signature": "boolean isNotBinaryExpression(TypedExpression e)", "full_signature": "private static boolean isNotBinaryExpression(TypedExpression e)", "class_method_signature": "CoercedExpression.isNotBinaryExpression(TypedExpression e)", "testcase": false, "constructor": false}, {"identifier": "coerceLiteralNumberExprToType", "parameters": "(LiteralStringValueExpr expr, Class<?> type)", "modifiers": "private", "return": "Expression", "signature": "Expression coerceLiteralNumberExprToType(LiteralStringValueExpr expr, Class<?> type)", "full_signature": "private Expression coerceLiteralNumberExprToType(LiteralStringValueExpr expr, Class<?> type)", "class_method_signature": "CoercedExpression.coerceLiteralNumberExprToType(LiteralStringValueExpr expr, Class<?> type)", "testcase": false, "constructor": false}, {"identifier": "isLongLiteral", "parameters": "(String value)", "modifiers": "private", "return": "boolean", "signature": "boolean isLongLiteral(String value)", "full_signature": "private boolean isLongLiteral(String value)", "class_method_signature": "CoercedExpression.isLongLiteral(String value)", "testcase": false, "constructor": false}, {"identifier": "canBeNarrowed", "parameters": "(Class<?> leftType, Class<?> rightType)", "modifiers": "private", "return": "boolean", "signature": "boolean canBeNarrowed(Class<?> leftType, Class<?> rightType)", "full_signature": "private boolean canBeNarrowed(Class<?> leftType, Class<?> rightType)", "class_method_signature": "CoercedExpression.canBeNarrowed(Class<?> leftType, Class<?> rightType)", "testcase": false, "constructor": false}], "file": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/CoercedExpression.java"}, "focal_method": {"identifier": "coerce", "parameters": "()", "modifiers": "public", "return": "CoercedExpressionResult", "body": "public CoercedExpressionResult coerce() {\n        final TypedExpression coercedRight;\n\n        final Class<?> leftClass = left.getRawClass();\n        final Class<?> rightClass = right.getRawClass();\n\n        boolean sameClass = leftClass == rightClass;\n        boolean isUnificationExpression = left instanceof UnificationTypedExpression || right instanceof UnificationTypedExpression;\n\n        if (sameClass || isUnificationExpression) {\n            return new CoercedExpressionResult(left, right);\n        }\n\n        if (!canCoerce()) {\n            throw new CoercedExpressionException(new InvalidExpressionErrorResult(\"Comparison operation requires compatible types. Found \" + leftClass + \" and \" + rightClass));\n        }\n\n        final Expression rightExpression = right.getExpression();\n\n        final boolean leftIsPrimitive = leftClass.isPrimitive() || Number.class.isAssignableFrom( leftClass );\n        final boolean canCoerceLiteralNumberExpr = canCoerceLiteralNumberExpr(leftClass);\n\n        if (leftIsPrimitive && canCoerceLiteralNumberExpr && rightExpression instanceof LiteralStringValueExpr) {\n            final Expression coercedLiteralNumberExprToType = coerceLiteralNumberExprToType((LiteralStringValueExpr) right.getExpression(), leftClass);\n            coercedRight = right.cloneWithNewExpression(coercedLiteralNumberExprToType);\n        } else if (shouldCoerceBToString(left, right)) {\n            coercedRight = coerceToString(right);\n        } else if (isNotBinaryExpression(right) && canBeNarrowed(leftClass, rightClass) && right.isNumberLiteral()) {\n            coercedRight = castToClass(leftClass);\n        } else if (leftClass == long.class && rightClass == int.class) {\n            coercedRight = right.cloneWithNewExpression(new CastExpr(PrimitiveType.longType(), right.getExpression()));\n        } else if (leftClass == Date.class && rightClass == String.class) {\n            coercedRight = coerceToDate(right);\n        } else if (shouldCoerceBToMap()) {\n            coercedRight = castToClass(toNonPrimitiveType(leftClass));\n        } else if (isBoolean(leftClass) && !isBoolean(rightClass)) {\n            coercedRight = coerceBoolean(right);\n        } else {\n            coercedRight = right;\n        }\n\n        final TypedExpression coercedLeft;\n        if (toNonPrimitiveType(leftClass) == Character.class && shouldCoerceBToString(right, left)) {\n            coercedLeft = coerceToString(left);\n        } else {\n            coercedLeft = left;\n        }\n\n        return new CoercedExpressionResult(coercedLeft, coercedRight);\n    }", "signature": "CoercedExpressionResult coerce()", "full_signature": "public CoercedExpressionResult coerce()", "class_method_signature": "CoercedExpression.coerce()", "testcase": false, "constructor": false, "invocations": ["getRawClass", "getRawClass", "canCoerce", "getExpression", "isPrimitive", "isAssignableFrom", "canCoerceLiteralNumberExpr", "coerceLiteralNumberExprToType", "getExpression", "cloneWithNewExpression", "shouldCoerceBToString", "coerceToString", "isNotBinaryExpression", "canBeNarrowed", "isNumberLiteral", "castToClass", "cloneWithNewExpression", "longType", "getExpression", "coerceToDate", "shouldCoerceBToMap", "castToClass", "toNonPrimitiveType", "isBoolean", "isBoolean", "coerceBoolean", "toNonPrimitiveType", "shouldCoerceBToString", "coerceToString"]}, "repository": {"repo_id": 1381673, "url": "https://github.com/kiegroup/drools", "stars": 2733, "created": "2/18/2011 8:37:05 AM +00:00", "updates": "2020-01-27T13:12:15+00:00", "fork": "False", "license": "licensed"}}