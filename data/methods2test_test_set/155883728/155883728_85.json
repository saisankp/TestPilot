{"test_class": {"identifier": "ChecklistExporterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "final File testBaseDir = new File(\"target/repos/ChecklistExporterTest\");", "modifier": "final", "type": "File", "declarator": "testBaseDir = new File(\"target/repos/ChecklistExporterTest\")", "var_name": "testBaseDir"}], "file": "webster/src/test/java/net/adamcin/oakpal/webster/ChecklistExporterTest.java"}, "test_case": {"identifier": "testNodeToRootNodeTypeScoped", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testNodeToRootNodeTypeScoped() throws Exception {\n        TestUtil.withInMemoryRepo(session -> {\n            TestUtil.installCndFromURL(session, getClass().getResource(\"/sling_nodetypes.cnd\"));\n            final NamespaceMapping mapping = new NamespaceMapping(new SessionNamespaceResolver(session));\n\n            Node node1 = JcrUtils.getOrCreateByPath(\"/test/node1\", \"nt:folder\", session);\n            node1.addMixin(\"mix:title\");\n            node1.addMixin(\"sling:Resource\");\n            node1.addMixin(\"sling:ResourceSuperType\");\n\n            ChecklistExporter mixExporter = new ChecklistExporter.Builder().withNodeTypeFilters(\n                    Rules.fromJsonArray(arr(key(\"type\", \"include\").key(\"pattern\", \"mix:.*\"))\n                            .get())).build();\n\n            ChecklistExporter slingExporter = new ChecklistExporter.Builder().withNodeTypeFilters(\n                    Rules.fromJsonArray(arr(key(\"type\", \"include\").key(\"pattern\", \"sling:.*\"))\n                            .get())).build();\n\n            ChecklistExporter rtExporter = new ChecklistExporter.Builder().withNodeTypeFilters(\n                    Rules.fromJsonArray(arr(key(\"type\", \"include\").key(\"pattern\", \"sling:Resource\"))\n                            .get())).build();\n\n            ForcedRoot mixRoot = mixExporter.nodeToRoot(node1, mapping).orElse(null);\n            assertNotNull(\"mixRoot should not be null\", mixRoot);\n            assertTrue(\"mixRoot should contain mix:title mixin\", mixRoot.getMixinTypes().contains(\"mix:title\"));\n            assertFalse(\"mixRoot should not contain sling:Resource mixin\", mixRoot.getMixinTypes().contains(\"sling:Resource\"));\n            assertFalse(\"mixRoot should not contain sling:ResourceSuperType mixin\", mixRoot.getMixinTypes().contains(\"sling:ResourceSuperType\"));\n\n            ForcedRoot slingRoot = slingExporter.nodeToRoot(node1, mapping).orElse(null);\n            assertNotNull(\"slingRoot should not be null\", slingRoot);\n            assertFalse(\"slingRoot should not contain mix:title mixin\", slingRoot.getMixinTypes().contains(\"mix:title\"));\n            assertTrue(\"slingRoot should contain sling:Resource mixin\", slingRoot.getMixinTypes().contains(\"sling:Resource\"));\n            assertTrue(\"slingRoot should contain sling:ResourceSuperType mixin\", slingRoot.getMixinTypes().contains(\"sling:ResourceSuperType\"));\n\n            ForcedRoot rtRoot = rtExporter.nodeToRoot(node1, mapping).orElse(null);\n            assertNotNull(\"rtRoot should not be null\", rtRoot);\n            assertNull(\"rtRoot primaryType should be null\", rtRoot.getPrimaryType());\n            assertFalse(\"rtRoot should not contain mix:title mixin\", rtRoot.getMixinTypes().contains(\"mix:title\"));\n            assertTrue(\"rtRoot should contain sling:Resource mixin\", rtRoot.getMixinTypes().contains(\"sling:Resource\"));\n            assertFalse(\"rtRoot should not contain sling:ResourceSuperType mixin\", rtRoot.getMixinTypes().contains(\"sling:ResourceSuperType\"));\n        });\n    }", "signature": "void testNodeToRootNodeTypeScoped()", "full_signature": "@Test public void testNodeToRootNodeTypeScoped()", "class_method_signature": "ChecklistExporterTest.testNodeToRootNodeTypeScoped()", "testcase": true, "constructor": false, "invocations": ["withInMemoryRepo", "installCndFromURL", "getResource", "getClass", "getOrCreateByPath", "addMixin", "addMixin", "addMixin", "build", "withNodeTypeFilters", "fromJsonArray", "get", "arr", "key", "key", "build", "withNodeTypeFilters", "fromJsonArray", "get", "arr", "key", "key", "build", "withNodeTypeFilters", "fromJsonArray", "get", "arr", "key", "key", "orElse", "nodeToRoot", "assertNotNull", "assertTrue", "contains", "getMixinTypes", "assertFalse", "contains", "getMixinTypes", "assertFalse", "contains", "getMixinTypes", "orElse", "nodeToRoot", "assertNotNull", "assertFalse", "contains", "getMixinTypes", "assertTrue", "contains", "getMixinTypes", "assertTrue", "contains", "getMixinTypes", "orElse", "nodeToRoot", "assertNotNull", "assertNull", "getPrimaryType", "assertFalse", "contains", "getMixinTypes", "assertTrue", "contains", "getMixinTypes", "assertFalse", "contains", "getMixinTypes"]}, "focal_class": {"identifier": "ChecklistExporter", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ChecklistExporter.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ChecklistExporter.class)", "var_name": "LOGGER"}, {"original_string": "private final List<Op> operations;", "modifier": "private final", "type": "List<Op>", "declarator": "operations", "var_name": "operations"}, {"original_string": "private final List<String> exportTypeDefs;", "modifier": "private final", "type": "List<String>", "declarator": "exportTypeDefs", "var_name": "exportTypeDefs"}, {"original_string": "private final List<Rule> pathScopes;", "modifier": "private final", "type": "List<Rule>", "declarator": "pathScopes", "var_name": "pathScopes"}, {"original_string": "private final List<Rule> nodeTypeFilters;", "modifier": "private final", "type": "List<Rule>", "declarator": "nodeTypeFilters", "var_name": "nodeTypeFilters"}, {"original_string": "private final List<JcrNs> jcrNamespaces;", "modifier": "private final", "type": "List<JcrNs>", "declarator": "jcrNamespaces", "var_name": "jcrNamespaces"}, {"original_string": "public static final ForcedRootUpdatePolicy DEFAULT_UPDATE_POLICY = ForcedRootUpdatePolicy.REPLACE;", "modifier": "public static final", "type": "ForcedRootUpdatePolicy", "declarator": "DEFAULT_UPDATE_POLICY = ForcedRootUpdatePolicy.REPLACE", "var_name": "DEFAULT_UPDATE_POLICY"}, {"original_string": "public static final String COVARIANT_PREFIX = \"+\";", "modifier": "public static final", "type": "String", "declarator": "COVARIANT_PREFIX = \"+\"", "var_name": "COVARIANT_PREFIX"}, {"original_string": "static final Predicate<String> COVARIANT_FILTER = name -> name.startsWith(COVARIANT_PREFIX);", "modifier": "static final", "type": "Predicate<String>", "declarator": "COVARIANT_FILTER = name -> name.startsWith(COVARIANT_PREFIX)", "var_name": "COVARIANT_FILTER"}, {"original_string": "static final Function<String, String> COVARIANT_FORMAT = name -> name.substring(COVARIANT_PREFIX.length());", "modifier": "static final", "type": "Function<String, String>", "declarator": "COVARIANT_FORMAT = name -> name.substring(COVARIANT_PREFIX.length())", "var_name": "COVARIANT_FORMAT"}], "methods": [{"identifier": "ChecklistExporter", "parameters": "(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "modifiers": "private", "return": "", "signature": " ChecklistExporter(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "full_signature": "private  ChecklistExporter(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "class_method_signature": "ChecklistExporter.ChecklistExporter(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "testcase": false, "constructor": true}, {"identifier": "ensureNamespaces", "parameters": "(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "modifiers": "static", "return": "void", "signature": "void ensureNamespaces(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "full_signature": "static void ensureNamespaces(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "class_method_signature": "ChecklistExporter.ensureNamespaces(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "testcase": false, "constructor": false}, {"identifier": "findJcrPrefixesInForcedRoot", "parameters": "(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "modifiers": "static", "return": "Set<String>", "signature": "Set<String> findJcrPrefixesInForcedRoot(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "full_signature": "static Set<String> findJcrPrefixesInForcedRoot(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "class_method_signature": "ChecklistExporter.findJcrPrefixesInForcedRoot(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "testcase": false, "constructor": false}, {"identifier": "findNodeTypesInForcedRoot", "parameters": "(final Set<String> acc, final ForcedRoot forcedRoot)", "modifiers": "static", "return": "Set<String>", "signature": "Set<String> findNodeTypesInForcedRoot(final Set<String> acc, final ForcedRoot forcedRoot)", "full_signature": "static Set<String> findNodeTypesInForcedRoot(final Set<String> acc, final ForcedRoot forcedRoot)", "class_method_signature": "ChecklistExporter.findNodeTypesInForcedRoot(final Set<String> acc, final ForcedRoot forcedRoot)", "testcase": false, "constructor": false}, {"identifier": "preferDifferent", "parameters": "(final @NotNull U value)", "modifiers": "static", "return": "BinaryOperator<U>", "signature": "BinaryOperator<U> preferDifferent(final @NotNull U value)", "full_signature": "static BinaryOperator<U> preferDifferent(final @NotNull U value)", "class_method_signature": "ChecklistExporter.preferDifferent(final @NotNull U value)", "testcase": false, "constructor": false}, {"identifier": "nsRemapName", "parameters": "(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "modifiers": "static", "return": "Function<String, String>", "signature": "Function<String, String> nsRemapName(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "full_signature": "static Function<String, String> nsRemapName(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "class_method_signature": "ChecklistExporter.nsRemapName(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "testcase": false, "constructor": false}, {"identifier": "nsRemapForcedRoot", "parameters": "(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "modifiers": "static", "return": "Function<ForcedRoot, ForcedRoot>", "signature": "Function<ForcedRoot, ForcedRoot> nsRemapForcedRoot(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "full_signature": "static Function<ForcedRoot, ForcedRoot> nsRemapForcedRoot(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "class_method_signature": "ChecklistExporter.nsRemapForcedRoot(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "testcase": false, "constructor": false}, {"identifier": "getRetainFilter", "parameters": "(final ForcedRootUpdatePolicy updatePolicy)", "modifiers": "", "return": "Predicate<ForcedRoot>", "signature": "Predicate<ForcedRoot> getRetainFilter(final ForcedRootUpdatePolicy updatePolicy)", "full_signature": " Predicate<ForcedRoot> getRetainFilter(final ForcedRootUpdatePolicy updatePolicy)", "class_method_signature": "ChecklistExporter.getRetainFilter(final ForcedRootUpdatePolicy updatePolicy)", "testcase": false, "constructor": false}, {"identifier": "exportTypeDefSelector", "parameters": "()", "modifiers": "", "return": "BiPredicate<NamePathResolver, NodeType>", "signature": "BiPredicate<NamePathResolver, NodeType> exportTypeDefSelector()", "full_signature": " BiPredicate<NamePathResolver, NodeType> exportTypeDefSelector()", "class_method_signature": "ChecklistExporter.exportTypeDefSelector()", "testcase": false, "constructor": false}, {"identifier": "updateChecklist", "parameters": "(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "modifiers": "public", "return": "void", "signature": "void updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "full_signature": "public void updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "class_method_signature": "ChecklistExporter.updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "testcase": false, "constructor": false}, {"identifier": "addToLeft", "parameters": "()", "modifiers": "static", "return": "BinaryOperator<U>", "signature": "BinaryOperator<U> addToLeft()", "full_signature": "static BinaryOperator<U> addToLeft()", "class_method_signature": "ChecklistExporter.addToLeft()", "testcase": false, "constructor": false}, {"identifier": "findRoots", "parameters": "(final Session session)", "modifiers": "public", "return": "List<ForcedRoot>", "signature": "List<ForcedRoot> findRoots(final Session session)", "full_signature": "public List<ForcedRoot> findRoots(final Session session)", "class_method_signature": "ChecklistExporter.findRoots(final Session session)", "testcase": false, "constructor": false}, {"identifier": "ntStatement", "parameters": "(final Session session, final List<String> nodeTypeNames)", "modifiers": "", "return": "String", "signature": "String ntStatement(final Session session, final List<String> nodeTypeNames)", "full_signature": " String ntStatement(final Session session, final List<String> nodeTypeNames)", "class_method_signature": "ChecklistExporter.ntStatement(final Session session, final List<String> nodeTypeNames)", "testcase": false, "constructor": false}, {"identifier": "query", "parameters": "(final Session session, final String statement)", "modifiers": "", "return": "List<ForcedRoot>", "signature": "List<ForcedRoot> query(final Session session, final String statement)", "full_signature": " List<ForcedRoot> query(final Session session, final String statement)", "class_method_signature": "ChecklistExporter.query(final Session session, final String statement)", "testcase": false, "constructor": false}, {"identifier": "traverse", "parameters": "(final Session session, final List<String> paths)", "modifiers": "", "return": "List<ForcedRoot>", "signature": "List<ForcedRoot> traverse(final Session session, final List<String> paths)", "full_signature": " List<ForcedRoot> traverse(final Session session, final List<String> paths)", "class_method_signature": "ChecklistExporter.traverse(final Session session, final List<String> paths)", "testcase": false, "constructor": false}, {"identifier": "nodeToRoot", "parameters": "(final Node node, final NamespaceMapping mapping)", "modifiers": "", "return": "Optional<ForcedRoot>", "signature": "Optional<ForcedRoot> nodeToRoot(final Node node, final NamespaceMapping mapping)", "full_signature": " Optional<ForcedRoot> nodeToRoot(final Node node, final NamespaceMapping mapping)", "class_method_signature": "ChecklistExporter.nodeToRoot(final Node node, final NamespaceMapping mapping)", "testcase": false, "constructor": false}], "file": "webster/src/main/java/net/adamcin/oakpal/webster/ChecklistExporter.java"}, "focal_method": {"identifier": "nodeToRoot", "parameters": "(final Node node, final NamespaceMapping mapping)", "modifiers": "", "return": "Optional<ForcedRoot>", "body": "Optional<ForcedRoot> nodeToRoot(final Node node, final NamespaceMapping mapping) throws RepositoryException {\n        if (Rules.lastMatch(pathScopes, node.getPath()).isExclude()) {\n            return Optional.empty();\n        }\n\n        ForcedRoot forcedRoot = new ForcedRoot();\n        forcedRoot.setPath(node.getPath());\n        final String primaryType = node.getPrimaryNodeType().getName();\n        if (Rules.lastMatch(nodeTypeFilters, QName.parseQName(mapping, QName.Type.NODETYPE, primaryType).toString()).isInclude()) {\n            forcedRoot.setPrimaryType(primaryType);\n        }\n        final List<String> mixinTypes = Stream.of(node.getMixinNodeTypes())\n                .map(compose1(NodeType::getName,\n                        qName -> QName.parseQName(mapping, QName.Type.NODETYPE, qName).toString()))\n                .filter(name -> Rules.lastMatch(nodeTypeFilters, name).isInclude())\n                .collect(Collectors.toList());\n        forcedRoot.setMixinTypes(mixinTypes);\n        return Optional.of(forcedRoot);\n    }", "signature": "Optional<ForcedRoot> nodeToRoot(final Node node, final NamespaceMapping mapping)", "full_signature": " Optional<ForcedRoot> nodeToRoot(final Node node, final NamespaceMapping mapping)", "class_method_signature": "ChecklistExporter.nodeToRoot(final Node node, final NamespaceMapping mapping)", "testcase": false, "constructor": false, "invocations": ["isExclude", "lastMatch", "getPath", "empty", "setPath", "getPath", "getName", "getPrimaryNodeType", "isInclude", "lastMatch", "toString", "parseQName", "setPrimaryType", "collect", "filter", "map", "of", "getMixinNodeTypes", "compose1", "toString", "parseQName", "isInclude", "lastMatch", "toList", "setMixinTypes", "of"]}, "repository": {"repo_id": 155883728, "url": "https://github.com/adamcin/oakpal", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 6, "size": 13349, "license": "licensed"}}