{"test_class": {"identifier": "AbstractBinaryStoreTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n    public TestRule skipTestRule = new SkipTestRule();", "modifier": "@Rule\n    public", "type": "TestRule", "declarator": "skipTestRule = new SkipTestRule()", "var_name": "skipTestRule"}, {"original_string": "public static final int LARGE_BINARY_SIZE = (int) AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES * 4;", "modifier": "public static final", "type": "int", "declarator": "LARGE_BINARY_SIZE = (int) AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES * 4", "var_name": "LARGE_BINARY_SIZE"}, {"original_string": "public static final byte[] STORED_LARGE_BINARY = new byte[LARGE_BINARY_SIZE];", "modifier": "public static final", "type": "byte[]", "declarator": "STORED_LARGE_BINARY = new byte[LARGE_BINARY_SIZE]", "var_name": "STORED_LARGE_BINARY"}, {"original_string": "public static final BinaryKey STORED_LARGE_KEY;", "modifier": "public static final", "type": "BinaryKey", "declarator": "STORED_LARGE_KEY", "var_name": "STORED_LARGE_KEY"}, {"original_string": "public static final byte[] IN_MEMORY_BINARY = new byte[(int)(AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES / 2)];", "modifier": "public static final", "type": "byte[]", "declarator": "IN_MEMORY_BINARY = new byte[(int)(AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES / 2)]", "var_name": "IN_MEMORY_BINARY"}, {"original_string": "public static final BinaryKey IN_MEMORY_KEY;", "modifier": "public static final", "type": "BinaryKey", "declarator": "IN_MEMORY_KEY", "var_name": "IN_MEMORY_KEY"}, {"original_string": "public static final byte[] STORED_MEDIUM_BINARY = new byte[(int)(AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES * 2)];", "modifier": "public static final", "type": "byte[]", "declarator": "STORED_MEDIUM_BINARY = new byte[(int)(AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES * 2)]", "var_name": "STORED_MEDIUM_BINARY"}, {"original_string": "public static final BinaryKey STORED_MEDIUM_KEY;", "modifier": "public static final", "type": "BinaryKey", "declarator": "STORED_MEDIUM_KEY", "var_name": "STORED_MEDIUM_KEY"}, {"original_string": "public static final byte[] EMPTY_BINARY = new byte[0];", "modifier": "public static final", "type": "byte[]", "declarator": "EMPTY_BINARY = new byte[0]", "var_name": "EMPTY_BINARY"}, {"original_string": "public static final BinaryKey EMPTY_BINARY_KEY;", "modifier": "public static final", "type": "BinaryKey", "declarator": "EMPTY_BINARY_KEY", "var_name": "EMPTY_BINARY_KEY"}, {"original_string": "public static final String TEXT_DATA;", "modifier": "public static final", "type": "String", "declarator": "TEXT_DATA", "var_name": "TEXT_DATA"}, {"original_string": "protected static final MimeTypeDetector DEFAULT_DETECTOR = new DefaultMimeTypeDetector();", "modifier": "protected static final", "type": "MimeTypeDetector", "declarator": "DEFAULT_DETECTOR = new DefaultMimeTypeDetector()", "var_name": "DEFAULT_DETECTOR"}, {"original_string": "private static final Random RANDOM = new Random();", "modifier": "private static final", "type": "Random", "declarator": "RANDOM = new Random()", "var_name": "RANDOM"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/value/binary/AbstractBinaryStoreTest.java"}, "test_case": {"identifier": "shouldMarkBinariesAsUsed", "parameters": "()", "modifiers": "@Test @FixFor( \"MODE-2302\" ) public", "return": "void", "body": "@Test\n    @FixFor( \"MODE-2302\" )\n    public void shouldMarkBinariesAsUsed() throws Exception {\n        BinaryStore binaryStore = getBinaryStore();\n\n        binaryStore.storeValue(new ByteArrayInputStream(IN_MEMORY_BINARY), false);\n        binaryStore.markAsUnused(Arrays.asList(IN_MEMORY_KEY));\n        Thread.sleep(100);\n\n        binaryStore.markAsUsed(Arrays.asList(IN_MEMORY_KEY));\n        Thread.sleep(2);\n        binaryStore.removeValuesUnusedLongerThan(1, TimeUnit.MILLISECONDS);\n        InputStream is = binaryStore.getInputStream(IN_MEMORY_KEY);\n        assertNotNull(is);\n    }", "signature": "void shouldMarkBinariesAsUsed()", "full_signature": "@Test @FixFor( \"MODE-2302\" ) public void shouldMarkBinariesAsUsed()", "class_method_signature": "AbstractBinaryStoreTest.shouldMarkBinariesAsUsed()", "testcase": true, "constructor": false, "invocations": ["getBinaryStore", "storeValue", "markAsUnused", "asList", "sleep", "markAsUsed", "asList", "sleep", "removeValuesUnusedLongerThan", "getInputStream", "assertNotNull"]}, "focal_class": {"identifier": "AbstractBinaryStore", "superclass": "", "interfaces": "implements BinaryStore", "fields": [{"original_string": "static final long DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES = 1024 * 4;", "modifier": "static final", "type": "long", "declarator": "DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES = 1024 * 4", "var_name": "DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES"}, {"original_string": "private static final long DEFAULT_LATCH_WAIT_IN_SECONDS = 10L;", "modifier": "private static final", "type": "long", "declarator": "DEFAULT_LATCH_WAIT_IN_SECONDS = 10L", "var_name": "DEFAULT_LATCH_WAIT_IN_SECONDS"}, {"original_string": "private static final long LARGE_SIZE = 1 << 25;", "modifier": "private static final", "type": "long", "declarator": "LARGE_SIZE = 1 << 25", "var_name": "LARGE_SIZE"}, {"original_string": "private static final long MEDIUM_FILE_SIZE = 1 << 20;", "modifier": "private static final", "type": "long", "declarator": "MEDIUM_FILE_SIZE = 1 << 20", "var_name": "MEDIUM_FILE_SIZE"}, {"original_string": "private static final long SMALL_FILE_SIZE = 1 << 15;", "modifier": "private static final", "type": "long", "declarator": "SMALL_FILE_SIZE = 1 << 15", "var_name": "SMALL_FILE_SIZE"}, {"original_string": "private static final long TINY_FILE_SIZE = 1 << 10;", "modifier": "private static final", "type": "long", "declarator": "TINY_FILE_SIZE = 1 << 10", "var_name": "TINY_FILE_SIZE"}, {"original_string": "private static final int LARGE_BUFFER_SIZE = 1 << 20;", "modifier": "private static final", "type": "int", "declarator": "LARGE_BUFFER_SIZE = 1 << 20", "var_name": "LARGE_BUFFER_SIZE"}, {"original_string": "protected static final int MEDIUM_BUFFER_SIZE = 1 << 16;", "modifier": "protected static final", "type": "int", "declarator": "MEDIUM_BUFFER_SIZE = 1 << 16", "var_name": "MEDIUM_BUFFER_SIZE"}, {"original_string": "private static final int SMALL_BUFFER_SIZE = 1 << 12;", "modifier": "private static final", "type": "int", "declarator": "SMALL_BUFFER_SIZE = 1 << 12", "var_name": "SMALL_BUFFER_SIZE"}, {"original_string": "private static final int TINY_BUFFER_SIZE = 1 << 11;", "modifier": "private static final", "type": "int", "declarator": "TINY_BUFFER_SIZE = 1 << 11", "var_name": "TINY_BUFFER_SIZE"}, {"original_string": "protected final Logger logger = Logger.getLogger(getClass());", "modifier": "protected final", "type": "Logger", "declarator": "logger = Logger.getLogger(getClass())", "var_name": "logger"}, {"original_string": "private final AtomicLong minBinarySizeInBytes = new AtomicLong(DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES);", "modifier": "private final", "type": "AtomicLong", "declarator": "minBinarySizeInBytes = new AtomicLong(DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES)", "var_name": "minBinarySizeInBytes"}, {"original_string": "private volatile TextExtractors extractors;", "modifier": "private volatile", "type": "TextExtractors", "declarator": "extractors", "var_name": "extractors"}, {"original_string": "private volatile MimeTypeDetector detector = NullMimeTypeDetector.INSTANCE;", "modifier": "private volatile", "type": "MimeTypeDetector", "declarator": "detector = NullMimeTypeDetector.INSTANCE", "var_name": "detector"}], "methods": [{"identifier": "bestBufferSize", "parameters": "( long fileSize )", "modifiers": "public static", "return": "int", "signature": "int bestBufferSize( long fileSize )", "full_signature": "public static int bestBufferSize( long fileSize )", "class_method_signature": "AbstractBinaryStore.bestBufferSize( long fileSize )", "testcase": false, "constructor": false}, {"identifier": "getMinimumBinarySizeInBytes", "parameters": "()", "modifiers": "@Override public", "return": "long", "signature": "long getMinimumBinarySizeInBytes()", "full_signature": "@Override public long getMinimumBinarySizeInBytes()", "class_method_signature": "AbstractBinaryStore.getMinimumBinarySizeInBytes()", "testcase": false, "constructor": false}, {"identifier": "setMinimumBinarySizeInBytes", "parameters": "( long minSizeInBytes )", "modifiers": "@Override public", "return": "void", "signature": "void setMinimumBinarySizeInBytes( long minSizeInBytes )", "full_signature": "@Override public void setMinimumBinarySizeInBytes( long minSizeInBytes )", "class_method_signature": "AbstractBinaryStore.setMinimumBinarySizeInBytes( long minSizeInBytes )", "testcase": false, "constructor": false}, {"identifier": "setTextExtractors", "parameters": "( TextExtractors textExtractors )", "modifiers": "@Override public", "return": "void", "signature": "void setTextExtractors( TextExtractors textExtractors )", "full_signature": "@Override public void setTextExtractors( TextExtractors textExtractors )", "class_method_signature": "AbstractBinaryStore.setTextExtractors( TextExtractors textExtractors )", "testcase": false, "constructor": false}, {"identifier": "setMimeTypeDetector", "parameters": "( MimeTypeDetector mimeTypeDetector )", "modifiers": "@Override public", "return": "void", "signature": "void setMimeTypeDetector( MimeTypeDetector mimeTypeDetector )", "full_signature": "@Override public void setMimeTypeDetector( MimeTypeDetector mimeTypeDetector )", "class_method_signature": "AbstractBinaryStore.setMimeTypeDetector( MimeTypeDetector mimeTypeDetector )", "testcase": false, "constructor": false}, {"identifier": "getText", "parameters": "( BinaryValue binary )", "modifiers": "@Override public final", "return": "String", "signature": "String getText( BinaryValue binary )", "full_signature": "@Override public final String getText( BinaryValue binary )", "class_method_signature": "AbstractBinaryStore.getText( BinaryValue binary )", "testcase": false, "constructor": false}, {"identifier": "getMimeType", "parameters": "( BinaryValue binary,\n                               String name )", "modifiers": "@Override public", "return": "String", "signature": "String getMimeType( BinaryValue binary,\n                               String name )", "full_signature": "@Override public String getMimeType( BinaryValue binary,\n                               String name )", "class_method_signature": "AbstractBinaryStore.getMimeType( BinaryValue binary,\n                               String name )", "testcase": false, "constructor": false}, {"identifier": "hasBinary", "parameters": "( BinaryKey key )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean hasBinary( BinaryKey key )", "full_signature": "@Override public boolean hasBinary( BinaryKey key )", "class_method_signature": "AbstractBinaryStore.hasBinary( BinaryKey key )", "testcase": false, "constructor": false}, {"identifier": "getStoredMimeType", "parameters": "( BinaryValue binaryValue )", "modifiers": "protected abstract", "return": "String", "signature": "String getStoredMimeType( BinaryValue binaryValue )", "full_signature": "protected abstract String getStoredMimeType( BinaryValue binaryValue )", "class_method_signature": "AbstractBinaryStore.getStoredMimeType( BinaryValue binaryValue )", "testcase": false, "constructor": false}, {"identifier": "storeMimeType", "parameters": "( BinaryValue binaryValue,\n                                           String mimeType )", "modifiers": "protected abstract", "return": "void", "signature": "void storeMimeType( BinaryValue binaryValue,\n                                           String mimeType )", "full_signature": "protected abstract void storeMimeType( BinaryValue binaryValue,\n                                           String mimeType )", "class_method_signature": "AbstractBinaryStore.storeMimeType( BinaryValue binaryValue,\n                                           String mimeType )", "testcase": false, "constructor": false}, {"identifier": "storeExtractedText", "parameters": "( BinaryValue source,\n                                             String extractedText )", "modifiers": "public abstract", "return": "void", "signature": "void storeExtractedText( BinaryValue source,\n                                             String extractedText )", "full_signature": "public abstract void storeExtractedText( BinaryValue source,\n                                             String extractedText )", "class_method_signature": "AbstractBinaryStore.storeExtractedText( BinaryValue source,\n                                             String extractedText )", "testcase": false, "constructor": false}, {"identifier": "getExtractedText", "parameters": "( BinaryValue source )", "modifiers": "public abstract", "return": "String", "signature": "String getExtractedText( BinaryValue source )", "full_signature": "public abstract String getExtractedText( BinaryValue source )", "class_method_signature": "AbstractBinaryStore.getExtractedText( BinaryValue source )", "testcase": false, "constructor": false}, {"identifier": "extractors", "parameters": "()", "modifiers": "protected final", "return": "TextExtractors", "signature": "TextExtractors extractors()", "full_signature": "protected final TextExtractors extractors()", "class_method_signature": "AbstractBinaryStore.extractors()", "testcase": false, "constructor": false}, {"identifier": "detector", "parameters": "()", "modifiers": "protected final", "return": "MimeTypeDetector", "signature": "MimeTypeDetector detector()", "full_signature": "protected final MimeTypeDetector detector()", "class_method_signature": "AbstractBinaryStore.detector()", "testcase": false, "constructor": false}, {"identifier": "storeValue", "parameters": "( InputStream stream, String hint, boolean markAsUnused )", "modifiers": "@Override public", "return": "BinaryValue", "signature": "BinaryValue storeValue( InputStream stream, String hint, boolean markAsUnused )", "full_signature": "@Override public BinaryValue storeValue( InputStream stream, String hint, boolean markAsUnused )", "class_method_signature": "AbstractBinaryStore.storeValue( InputStream stream, String hint, boolean markAsUnused )", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void start()", "full_signature": "@Override public void start()", "class_method_signature": "AbstractBinaryStore.start()", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void shutdown()", "full_signature": "@Override public void shutdown()", "class_method_signature": "AbstractBinaryStore.shutdown()", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/value/binary/AbstractBinaryStore.java"}, "focal_method": {"identifier": "storeValue", "parameters": "( InputStream stream, String hint, boolean markAsUnused )", "modifiers": "@Override public", "return": "BinaryValue", "body": "@Override\n    public BinaryValue storeValue( InputStream stream, String hint, boolean markAsUnused ) throws BinaryStoreException {\n        return storeValue(stream, markAsUnused);\n    }", "signature": "BinaryValue storeValue( InputStream stream, String hint, boolean markAsUnused )", "full_signature": "@Override public BinaryValue storeValue( InputStream stream, String hint, boolean markAsUnused )", "class_method_signature": "AbstractBinaryStore.storeValue( InputStream stream, String hint, boolean markAsUnused )", "testcase": false, "constructor": false, "invocations": ["storeValue"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}