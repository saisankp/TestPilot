{"test_class": {"identifier": "MainTest", "superclass": "", "interfaces": "", "fields": [], "file": "core/src/test/java/ji/core/MainTest.java"}, "test_case": {"identifier": "should_capture_name_of_method_called", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void should_capture_name_of_method_called() throws Exception {\n        final Instrumentation inst = ByteBuddyAgent.install();\n\n        final ByteBuddy bb = new ByteBuddy();\n        final P2<Gather.Exports, Gather.Transforms> pair =\n                List.iterableList(TypeDescription.ForLoadedType.of(Foo.class).getDeclaredMethods())\n                    .foldLeft(Main.gather(bb, new MockComp()), P.p(c -> TreeMap.empty(Ord.stringOrd), c -> r -> a -> a));\n\n        final Config config = ConfigFactory.empty();\n        pair._2()\n            .f(config)\n            .f(k -> pair._1().f(config).get().f(k).some())\n            .f(new AgentBuilder.Default(bb).with(Main.LoggerListener.DEFAULT)).installOn(inst);\n\n        final Class<?> bar = getClass().getClassLoader().loadClass(\"ji.core.MainTest$Bar\");\n        bar.getDeclaredMethod(\"baz\", String.class).invoke(null, \"123\");\n        assertThat(Foo.ref().get(), is(\"baz\"));\n    }", "signature": "void should_capture_name_of_method_called()", "full_signature": "@Test public void should_capture_name_of_method_called()", "class_method_signature": "MainTest.should_capture_name_of_method_called()", "testcase": true, "constructor": false, "invocations": ["install", "foldLeft", "iterableList", "getDeclaredMethods", "of", "gather", "p", "empty", "empty", "installOn", "f", "f", "f", "_2", "some", "f", "get", "f", "_1", "with", "loadClass", "getClassLoader", "getClass", "invoke", "getDeclaredMethod", "assertThat", "get", "ref", "is"]}, "focal_class": {"identifier": "Main", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "premain", "parameters": "(final String args, final Instrumentation inst)", "modifiers": "public static", "return": "void", "signature": "void premain(final String args, final Instrumentation inst)", "full_signature": "public static void premain(final String args, final Instrumentation inst)", "class_method_signature": "Main.premain(final String args, final Instrumentation inst)", "testcase": false, "constructor": false}, {"identifier": "declaredMethods", "parameters": "(TypeDescription t)", "modifiers": "private static", "return": "MethodList<MethodDescription.InDefinedShape>", "signature": "MethodList<MethodDescription.InDefinedShape> declaredMethods(TypeDescription t)", "full_signature": "private static MethodList<MethodDescription.InDefinedShape> declaredMethods(TypeDescription t)", "class_method_signature": "Main.declaredMethods(TypeDescription t)", "testcase": false, "constructor": false}, {"identifier": "gather", "parameters": "(ByteBuddy bb, Compoundable comp)", "modifiers": "@VisibleForTesting static", "return": "F<P2<Exports, Transforms>, F<MethodDescription.InDefinedShape, P2<Exports, Transforms>>>", "signature": "F<P2<Exports, Transforms>, F<MethodDescription.InDefinedShape, P2<Exports, Transforms>>> gather(ByteBuddy bb, Compoundable comp)", "full_signature": "@VisibleForTesting static F<P2<Exports, Transforms>, F<MethodDescription.InDefinedShape, P2<Exports, Transforms>>> gather(ByteBuddy bb, Compoundable comp)", "class_method_signature": "Main.gather(ByteBuddy bb, Compoundable comp)", "testcase": false, "constructor": false}, {"identifier": "ab", "parameters": "(ByteBuddy bb)", "modifiers": "private static", "return": "AgentBuilder", "signature": "AgentBuilder ab(ByteBuddy bb)", "full_signature": "private static AgentBuilder ab(ByteBuddy bb)", "class_method_signature": "Main.ab(ByteBuddy bb)", "testcase": false, "constructor": false}, {"identifier": "appendBootstrapClassLoaderSearchBy", "parameters": "(Instrumentation inst)", "modifiers": "@VisibleForTesting static", "return": "Iterable<Class<?>>", "signature": "Iterable<Class<?>> appendBootstrapClassLoaderSearchBy(Instrumentation inst)", "full_signature": "@VisibleForTesting static Iterable<Class<?>> appendBootstrapClassLoaderSearchBy(Instrumentation inst)", "class_method_signature": "Main.appendBootstrapClassLoaderSearchBy(Instrumentation inst)", "testcase": false, "constructor": false}, {"identifier": "Main", "parameters": "()", "modifiers": "private", "return": "", "signature": " Main()", "full_signature": "private  Main()", "class_method_signature": "Main.Main()", "testcase": false, "constructor": true}], "file": "core/src/main/java/ji/core/Main.java"}, "focal_method": {"identifier": "gather", "parameters": "(ByteBuddy bb, Compoundable comp)", "modifiers": "@VisibleForTesting static", "return": "F<P2<Exports, Transforms>, F<MethodDescription.InDefinedShape, P2<Exports, Transforms>>>", "body": "@VisibleForTesting\n    static F<P2<Exports, Transforms>, F<MethodDescription.InDefinedShape, P2<Exports, Transforms>>> gather(ByteBuddy bb, Compoundable comp) {\n        final Export.Default export = Export.Default.of(bb);\n        final Transform.Default transform = Transform.Default.of(bb, comp);\n\n        return pair -> md -> {\n\n            if (!md.isStatic()) {\n                LOG.debug(\"Ignored non-static method %s\", md);\n                return pair;\n            }\n\n            if (!md.isPublic()) {\n                LOG.debug(\"Ignored non-public method %s\", md);\n                return pair;\n            }\n\n            if (md.getReturnType().equals(TypeDescription.Generic.VOID)) {\n                LOG.debug(\"Ignored return void method %s\", md);\n                return pair;\n            }\n\n            final Option<P2<Exports, Transforms>> exportsMayChanged = export.f(md, pair._1()).map(e -> P.p(e, pair._2())).toOption();\n            final Option<P2<Exports, Transforms>> transformsMayChanged = transform.f(md, pair._2()).map(t -> P.p(pair._1(), t)).toOption();\n\n            return exportsMayChanged.orElse(transformsMayChanged).orSome(() -> {\n                LOG.debug(\"Ignored invalid annotated method %s\", md);\n                return pair;\n            });\n        };\n\n    }", "signature": "F<P2<Exports, Transforms>, F<MethodDescription.InDefinedShape, P2<Exports, Transforms>>> gather(ByteBuddy bb, Compoundable comp)", "full_signature": "@VisibleForTesting static F<P2<Exports, Transforms>, F<MethodDescription.InDefinedShape, P2<Exports, Transforms>>> gather(ByteBuddy bb, Compoundable comp)", "class_method_signature": "Main.gather(ByteBuddy bb, Compoundable comp)", "testcase": false, "constructor": false, "invocations": ["of", "of", "isStatic", "debug", "isPublic", "debug", "equals", "getReturnType", "debug", "toOption", "map", "f", "_1", "p", "_2", "toOption", "map", "f", "_2", "p", "_1", "orSome", "orElse", "debug"]}, "repository": {"repo_id": 167169496, "url": "https://github.com/jiboard/ji", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 6, "size": 109, "license": "licensed"}}