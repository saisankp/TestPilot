{"test_class": {"identifier": "BackPressureStatsTrackerTest", "superclass": "", "interfaces": "", "fields": [], "file": "flink-runtime-web/src/test/java/org/apache/flink/runtime/webmonitor/BackPressureStatsTrackerTest.java"}, "test_case": {"identifier": "testTriggerStackTraceSample", "parameters": "()", "modifiers": "@Test @SuppressWarnings(\"unchecked\") public", "return": "void", "body": "@Test\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void testTriggerStackTraceSample() throws Exception {\n\t\tPromise<StackTraceSample> samplePromise = new Promise.DefaultPromise<>();\n\n\t\tStackTraceSampleCoordinator sampleCoordinator = mock(StackTraceSampleCoordinator.class);\n\t\twhen(sampleCoordinator.triggerStackTraceSample(\n\t\t\t\tany(ExecutionVertex[].class),\n\t\t\t\tanyInt(),\n\t\t\t\tany(FiniteDuration.class),\n\t\t\t\tanyInt())).thenReturn(samplePromise.future());\n\n\t\tExecutionGraph graph = mock(ExecutionGraph.class);\n\t\twhen(graph.getState()).thenReturn(JobStatus.RUNNING);\n\n\t\t// Same Thread execution context\n\t\twhen(graph.getExecutionContext()).thenReturn(new ExecutionContext() {\n\n\t\t\t@Override\n\t\t\tpublic void execute(Runnable runnable) {\n\t\t\t\trunnable.run();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void reportFailure(Throwable t) {\n\t\t\t\tfail();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ExecutionContext prepare() {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t});\n\n\t\tExecutionVertex[] taskVertices = new ExecutionVertex[4];\n\n\t\tExecutionJobVertex jobVertex = mock(ExecutionJobVertex.class);\n\t\twhen(jobVertex.getJobId()).thenReturn(new JobID());\n\t\twhen(jobVertex.getJobVertexId()).thenReturn(new JobVertexID());\n\t\twhen(jobVertex.getGraph()).thenReturn(graph);\n\t\twhen(jobVertex.getTaskVertices()).thenReturn(taskVertices);\n\n\t\ttaskVertices[0] = mockExecutionVertex(jobVertex, 0);\n\t\ttaskVertices[1] = mockExecutionVertex(jobVertex, 1);\n\t\ttaskVertices[2] = mockExecutionVertex(jobVertex, 2);\n\t\ttaskVertices[3] = mockExecutionVertex(jobVertex, 3);\n\n\t\tint numSamples = 100;\n\t\tFiniteDuration delayBetweenSamples = new FiniteDuration(100, TimeUnit.MILLISECONDS);\n\n\t\tBackPressureStatsTracker tracker = new BackPressureStatsTracker(\n\t\t\t\tsampleCoordinator, 9999, numSamples, delayBetweenSamples);\n\n\t\t// Trigger\n\t\tassertTrue(\"Failed to trigger\", tracker.triggerStackTraceSample(jobVertex));\n\n\t\tverify(sampleCoordinator).triggerStackTraceSample(\n\t\t\t\teq(taskVertices),\n\t\t\t\teq(numSamples),\n\t\t\t\teq(delayBetweenSamples),\n\t\t\t\teq(BackPressureStatsTracker.MAX_STACK_TRACE_DEPTH));\n\n\t\t// Trigger again for pending request, should not fire\n\t\tassertFalse(\"Unexpected trigger\", tracker.triggerStackTraceSample(jobVertex));\n\n\t\tassertTrue(tracker.getOperatorBackPressureStats(jobVertex).isEmpty());\n\n\t\tverify(sampleCoordinator).triggerStackTraceSample(\n\t\t\t\teq(taskVertices),\n\t\t\t\teq(numSamples),\n\t\t\t\teq(delayBetweenSamples),\n\t\t\t\teq(BackPressureStatsTracker.MAX_STACK_TRACE_DEPTH));\n\n\t\tassertTrue(tracker.getOperatorBackPressureStats(jobVertex).isEmpty());\n\n\t\t// Complete the future\n\t\tMap<ExecutionAttemptID, List<StackTraceElement[]>> traces = new HashMap<>();\n\t\tfor (ExecutionVertex vertex : taskVertices) {\n\t\t\tList<StackTraceElement[]> taskTraces = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < taskVertices.length; i++) {\n\t\t\t\t// Traces until sub task index are back pressured\n\t\t\t\ttaskTraces.add(createStackTrace(i <= vertex.getParallelSubtaskIndex()));\n\t\t\t}\n\n\t\t\ttraces.put(vertex.getCurrentExecutionAttempt().getAttemptId(), taskTraces);\n\t\t}\n\n\t\tint sampleId = 1231;\n\t\tint endTime = 841;\n\n\t\tStackTraceSample sample = new StackTraceSample(\n\t\t\t\tsampleId,\n\t\t\t\t0,\n\t\t\t\tendTime,\n\t\t\t\ttraces);\n\n\t\t// Succeed the promise\n\t\tsamplePromise.success(sample);\n\n\t\tassertTrue(tracker.getOperatorBackPressureStats(jobVertex).isDefined());\n\n\t\tOperatorBackPressureStats stats = tracker.getOperatorBackPressureStats(jobVertex).get();\n\n\t\t// Verify the stats\n\t\tassertEquals(sampleId, stats.getSampleId());\n\t\tassertEquals(endTime, stats.getEndTimestamp());\n\t\tassertEquals(taskVertices.length, stats.getNumberOfSubTasks());\n\t\t\n\t\tfor (int i = 0; i < taskVertices.length; i++) {\n\t\t\tdouble ratio = stats.getBackPressureRatio(i);\n\t\t\t// Traces until sub task index are back pressured\n\t\t\tassertEquals((i + 1) / ((double) 4), ratio, 0.0);\n\t\t}\n\t}", "signature": "void testTriggerStackTraceSample()", "full_signature": "@Test @SuppressWarnings(\"unchecked\") public void testTriggerStackTraceSample()", "class_method_signature": "BackPressureStatsTrackerTest.testTriggerStackTraceSample()", "testcase": true, "constructor": false, "invocations": ["mock", "thenReturn", "when", "triggerStackTraceSample", "any", "anyInt", "any", "anyInt", "future", "mock", "thenReturn", "when", "getState", "thenReturn", "when", "getExecutionContext", "run", "fail", "mock", "thenReturn", "when", "getJobId", "thenReturn", "when", "getJobVertexId", "thenReturn", "when", "getGraph", "thenReturn", "when", "getTaskVertices", "mockExecutionVertex", "mockExecutionVertex", "mockExecutionVertex", "mockExecutionVertex", "assertTrue", "triggerStackTraceSample", "triggerStackTraceSample", "verify", "eq", "eq", "eq", "eq", "assertFalse", "triggerStackTraceSample", "assertTrue", "isEmpty", "getOperatorBackPressureStats", "triggerStackTraceSample", "verify", "eq", "eq", "eq", "eq", "assertTrue", "isEmpty", "getOperatorBackPressureStats", "add", "createStackTrace", "getParallelSubtaskIndex", "put", "getAttemptId", "getCurrentExecutionAttempt", "success", "assertTrue", "isDefined", "getOperatorBackPressureStats", "get", "getOperatorBackPressureStats", "assertEquals", "getSampleId", "assertEquals", "getEndTimestamp", "assertEquals", "getNumberOfSubTasks", "getBackPressureRatio", "assertEquals"]}, "focal_class": {"identifier": "BackPressureStatsTracker", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(BackPressureStatsTracker.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(BackPressureStatsTracker.class)", "var_name": "LOG"}, {"original_string": "static final int MAX_STACK_TRACE_DEPTH = 3;", "modifier": "static final", "type": "int", "declarator": "MAX_STACK_TRACE_DEPTH = 3", "var_name": "MAX_STACK_TRACE_DEPTH"}, {"original_string": "static final String EXPECTED_CLASS_NAME = \"org.apache.flink.runtime.io.network.buffer.LocalBufferPool\";", "modifier": "static final", "type": "String", "declarator": "EXPECTED_CLASS_NAME = \"org.apache.flink.runtime.io.network.buffer.LocalBufferPool\"", "var_name": "EXPECTED_CLASS_NAME"}, {"original_string": "static final String EXPECTED_METHOD_NAME = \"requestBufferBlocking\";", "modifier": "static final", "type": "String", "declarator": "EXPECTED_METHOD_NAME = \"requestBufferBlocking\"", "var_name": "EXPECTED_METHOD_NAME"}, {"original_string": "private final Object lock = new Object();", "modifier": "private final", "type": "Object", "declarator": "lock = new Object()", "var_name": "lock"}, {"original_string": "private final StackTraceSampleCoordinator coordinator;", "modifier": "private final", "type": "StackTraceSampleCoordinator", "declarator": "coordinator", "var_name": "coordinator"}, {"original_string": "private final Cache<ExecutionJobVertex, OperatorBackPressureStats> operatorStatsCache;", "modifier": "private final", "type": "Cache<ExecutionJobVertex, OperatorBackPressureStats>", "declarator": "operatorStatsCache", "var_name": "operatorStatsCache"}, {"original_string": "private final Set<ExecutionJobVertex> pendingStats = new HashSet<>();", "modifier": "private final", "type": "Set<ExecutionJobVertex>", "declarator": "pendingStats = new HashSet<>()", "var_name": "pendingStats"}, {"original_string": "private final int cleanUpInterval;", "modifier": "private final", "type": "int", "declarator": "cleanUpInterval", "var_name": "cleanUpInterval"}, {"original_string": "private final int numSamples;", "modifier": "private final", "type": "int", "declarator": "numSamples", "var_name": "numSamples"}, {"original_string": "private final FiniteDuration delayBetweenSamples;", "modifier": "private final", "type": "FiniteDuration", "declarator": "delayBetweenSamples", "var_name": "delayBetweenSamples"}, {"original_string": "private boolean shutDown;", "modifier": "private", "type": "boolean", "declarator": "shutDown", "var_name": "shutDown"}], "methods": [{"identifier": "BackPressureStatsTracker", "parameters": "(\n\t\t\tStackTraceSampleCoordinator coordinator,\n\t\t\tint cleanUpInterval,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples)", "modifiers": "public", "return": "", "signature": " BackPressureStatsTracker(\n\t\t\tStackTraceSampleCoordinator coordinator,\n\t\t\tint cleanUpInterval,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples)", "full_signature": "public  BackPressureStatsTracker(\n\t\t\tStackTraceSampleCoordinator coordinator,\n\t\t\tint cleanUpInterval,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples)", "class_method_signature": "BackPressureStatsTracker.BackPressureStatsTracker(\n\t\t\tStackTraceSampleCoordinator coordinator,\n\t\t\tint cleanUpInterval,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples)", "testcase": false, "constructor": true}, {"identifier": "getCleanUpInterval", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getCleanUpInterval()", "full_signature": "public long getCleanUpInterval()", "class_method_signature": "BackPressureStatsTracker.getCleanUpInterval()", "testcase": false, "constructor": false}, {"identifier": "getOperatorBackPressureStats", "parameters": "(ExecutionJobVertex vertex)", "modifiers": "public", "return": "Option<OperatorBackPressureStats>", "signature": "Option<OperatorBackPressureStats> getOperatorBackPressureStats(ExecutionJobVertex vertex)", "full_signature": "public Option<OperatorBackPressureStats> getOperatorBackPressureStats(ExecutionJobVertex vertex)", "class_method_signature": "BackPressureStatsTracker.getOperatorBackPressureStats(ExecutionJobVertex vertex)", "testcase": false, "constructor": false}, {"identifier": "triggerStackTraceSample", "parameters": "(ExecutionJobVertex vertex)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "boolean", "signature": "boolean triggerStackTraceSample(ExecutionJobVertex vertex)", "full_signature": "@SuppressWarnings(\"unchecked\") public boolean triggerStackTraceSample(ExecutionJobVertex vertex)", "class_method_signature": "BackPressureStatsTracker.triggerStackTraceSample(ExecutionJobVertex vertex)", "testcase": false, "constructor": false}, {"identifier": "cleanUpOperatorStatsCache", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void cleanUpOperatorStatsCache()", "full_signature": "public void cleanUpOperatorStatsCache()", "class_method_signature": "BackPressureStatsTracker.cleanUpOperatorStatsCache()", "testcase": false, "constructor": false}, {"identifier": "shutDown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutDown()", "full_signature": "public void shutDown()", "class_method_signature": "BackPressureStatsTracker.shutDown()", "testcase": false, "constructor": false}, {"identifier": "invalidateOperatorStatsCache", "parameters": "()", "modifiers": "", "return": "void", "signature": "void invalidateOperatorStatsCache()", "full_signature": " void invalidateOperatorStatsCache()", "class_method_signature": "BackPressureStatsTracker.invalidateOperatorStatsCache()", "testcase": false, "constructor": false}], "file": "flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/BackPressureStatsTracker.java"}, "focal_method": {"identifier": "triggerStackTraceSample", "parameters": "(ExecutionJobVertex vertex)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "boolean", "body": "@SuppressWarnings(\"unchecked\")\n\tpublic boolean triggerStackTraceSample(ExecutionJobVertex vertex) {\n\t\tsynchronized (lock) {\n\t\t\tif (shutDown) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!pendingStats.contains(vertex) &&\n\t\t\t\t\t!vertex.getGraph().getState().isTerminalState()) {\n\n\t\t\t\tExecutionContext executionContext = vertex.getGraph().getExecutionContext();\n\n\t\t\t\t// Only trigger if still active job\n\t\t\t\tif (executionContext != null) {\n\t\t\t\t\tpendingStats.add(vertex);\n\n\t\t\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\t\t\tLOG.debug(\"Triggering stack trace sample for tasks: \" + Arrays.toString(vertex.getTaskVertices()));\n\t\t\t\t\t}\n\n\t\t\t\t\tFuture<StackTraceSample> sample = coordinator.triggerStackTraceSample(\n\t\t\t\t\t\t\tvertex.getTaskVertices(),\n\t\t\t\t\t\t\tnumSamples,\n\t\t\t\t\t\t\tdelayBetweenSamples,\n\t\t\t\t\t\t\tMAX_STACK_TRACE_DEPTH);\n\n\t\t\t\t\tsample.onComplete(new StackTraceSampleCompletionCallback(vertex), executionContext);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}", "signature": "boolean triggerStackTraceSample(ExecutionJobVertex vertex)", "full_signature": "@SuppressWarnings(\"unchecked\") public boolean triggerStackTraceSample(ExecutionJobVertex vertex)", "class_method_signature": "BackPressureStatsTracker.triggerStackTraceSample(ExecutionJobVertex vertex)", "testcase": false, "constructor": false, "invocations": ["contains", "isTerminalState", "getState", "getGraph", "getExecutionContext", "getGraph", "add", "isDebugEnabled", "debug", "toString", "getTaskVertices", "triggerStackTraceSample", "getTaskVertices", "onComplete"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}