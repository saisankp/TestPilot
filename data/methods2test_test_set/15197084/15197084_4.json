{"test_class": {"identifier": "ThreadBridgeTest", "superclass": "", "interfaces": "", "fields": [], "file": "reactfx/src/test/java/org/reactfx/ThreadBridgeTest.java"}, "test_case": {"identifier": "test", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void test() throws InterruptedException, ExecutionException {\n        ThreadFactory threadFactory1 = runnable -> new Thread(runnable, \"thread 1\");\n        ThreadFactory threadFactory2 = runnable -> new Thread(runnable, \"thread 2\");\n        ExecutorService exec1 = Executors.newSingleThreadExecutor(threadFactory1);\n        ExecutorService exec2 = Executors.newSingleThreadExecutor(threadFactory2);\n        EventSource<Integer> src1 = new EventSource<>();\n        EventStream<Integer> stream2 = src1.threadBridge(exec1, exec2);\n        EventStream<Integer> stream1 = stream2.threadBridge(exec2, exec1);\n\n        List<Integer> emittedFrom2 = new ArrayList<>();\n        List<Integer> emittedFrom1 = new ArrayList<>();\n        List<String> emissionThreads2 = new ArrayList<>();\n        List<String> emissionThreads1 = new ArrayList<>();\n\n        CompletableFuture<List<Integer>> emittedFrom2Final = new CompletableFuture<>();\n        CompletableFuture<List<Integer>> emittedFrom1Final = new CompletableFuture<>();\n        CompletableFuture<List<String>> emissionThreads2Final = new CompletableFuture<>();\n        CompletableFuture<List<String>> emissionThreads1Final = new CompletableFuture<>();\n\n        CountDownLatch subscribed = new CountDownLatch(2);\n        exec2.execute(() -> {\n            stream2.subscribe(i -> {\n                if(i != null) {\n                    emittedFrom2.add(i);\n                    emissionThreads2.add(Thread.currentThread().getName());\n                } else {\n                    emittedFrom2Final.complete(emittedFrom2);\n                    emissionThreads2Final.complete(emissionThreads2);\n                }\n            });\n            subscribed.countDown();\n        });\n        exec1.execute(() -> {\n            stream1.subscribe(i -> {\n                if(i != null) {\n                    emittedFrom1.add(i);\n                    emissionThreads1.add(Thread.currentThread().getName());\n                } else {\n                    emittedFrom1Final.complete(emittedFrom1);\n                    emissionThreads1Final.complete(emissionThreads1);\n                }\n            });\n            subscribed.countDown();\n        });\n\n        subscribed.await();\n        exec1.execute(() -> {\n            src1.push(1);\n            src1.push(2);\n            src1.push(3);\n            src1.push(null);\n        });\n\n        assertEquals(Arrays.asList(1, 2, 3), emittedFrom2Final.get());\n        assertEquals(Arrays.asList(1, 2, 3), emittedFrom1Final.get());\n        assertEquals(Arrays.asList(\"thread 2\", \"thread 2\", \"thread 2\"), emissionThreads2Final.get());\n        assertEquals(Arrays.asList(\"thread 1\", \"thread 1\", \"thread 1\"), emissionThreads1Final.get());\n\n        exec1.shutdown();\n        exec2.shutdown();\n    }", "signature": "void test()", "full_signature": "@Test public void test()", "class_method_signature": "ThreadBridgeTest.test()", "testcase": true, "constructor": false, "invocations": ["newSingleThreadExecutor", "newSingleThreadExecutor", "threadBridge", "threadBridge", "execute", "subscribe", "add", "add", "getName", "currentThread", "complete", "complete", "countDown", "execute", "subscribe", "add", "add", "getName", "currentThread", "complete", "complete", "countDown", "await", "execute", "push", "push", "push", "push", "assertEquals", "asList", "get", "assertEquals", "asList", "get", "assertEquals", "asList", "get", "assertEquals", "asList", "get", "shutdown", "shutdown"]}, "focal_class": {"identifier": "ThreadBridge", "superclass": "extends EventStreamBase<T>", "interfaces": "", "fields": [{"original_string": "private final EventStream<T> input;", "modifier": "private final", "type": "EventStream<T>", "declarator": "input", "var_name": "input"}, {"original_string": "private final Executor sourceThreadExecutor;", "modifier": "private final", "type": "Executor", "declarator": "sourceThreadExecutor", "var_name": "sourceThreadExecutor"}, {"original_string": "private final Executor targetThreadExecutor;", "modifier": "private final", "type": "Executor", "declarator": "targetThreadExecutor", "var_name": "targetThreadExecutor"}], "methods": [{"identifier": "ThreadBridge", "parameters": "(\n            EventStream<T> input,\n            Executor sourceThreadExecutor,\n            Executor targetThreadExecutor)", "modifiers": "public", "return": "", "signature": " ThreadBridge(\n            EventStream<T> input,\n            Executor sourceThreadExecutor,\n            Executor targetThreadExecutor)", "full_signature": "public  ThreadBridge(\n            EventStream<T> input,\n            Executor sourceThreadExecutor,\n            Executor targetThreadExecutor)", "class_method_signature": "ThreadBridge.ThreadBridge(\n            EventStream<T> input,\n            Executor sourceThreadExecutor,\n            Executor targetThreadExecutor)", "testcase": false, "constructor": true}, {"identifier": "observeInputs", "parameters": "()", "modifiers": "@Override protected", "return": "Subscription", "signature": "Subscription observeInputs()", "full_signature": "@Override protected Subscription observeInputs()", "class_method_signature": "ThreadBridge.observeInputs()", "testcase": false, "constructor": false}], "file": "reactfx/src/main/java/org/reactfx/ThreadBridge.java"}, "focal_method": {"identifier": "ThreadBridge", "parameters": "(\n            EventStream<T> input,\n            Executor sourceThreadExecutor,\n            Executor targetThreadExecutor)", "modifiers": "public", "return": "", "body": "public ThreadBridge(\n            EventStream<T> input,\n            Executor sourceThreadExecutor,\n            Executor targetThreadExecutor) {\n        this.input = input;\n        this.sourceThreadExecutor = sourceThreadExecutor;\n        this.targetThreadExecutor = targetThreadExecutor;\n    }", "signature": " ThreadBridge(\n            EventStream<T> input,\n            Executor sourceThreadExecutor,\n            Executor targetThreadExecutor)", "full_signature": "public  ThreadBridge(\n            EventStream<T> input,\n            Executor sourceThreadExecutor,\n            Executor targetThreadExecutor)", "class_method_signature": "ThreadBridge.ThreadBridge(\n            EventStream<T> input,\n            Executor sourceThreadExecutor,\n            Executor targetThreadExecutor)", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 15197084, "url": "https://github.com/TomasMikula/ReactFX", "language": "Java", "is_fork": false, "fork_count": 42, "stargazer_count": 326, "size": 891, "license": "licensed"}}