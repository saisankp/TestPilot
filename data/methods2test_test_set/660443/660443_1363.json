{"test_class": {"identifier": "SuppressedAtomHashGeneratorTest", "superclass": "", "interfaces": "", "fields": [], "file": "tool/hash/src/test/java/org/openscience/cdk/hash/SuppressedAtomHashGeneratorTest.java"}, "test_case": {"identifier": "testRotation", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRotation() throws Exception {\n\n        AtomHashGenerator seedMock = mock(AtomHashGenerator.class);\n        IAtomContainer container = mock(IAtomContainer.class);\n\n        SuppressedAtomHashGenerator generator = new SuppressedAtomHashGenerator(mock(AtomHashGenerator.class),\n                new Xorshift(), AtomSuppression.unsuppressed(), 2);\n\n        int[][] graph = new int[][]{{1, 2, 3}, {0}, {0}, {0}};\n\n        // simulate 3 identical neighbors\n        long[] invs = new long[]{21, 31, 31, 31};\n        long[] unique = new long[4];\n        long[] rotated = new long[4];\n\n        // non-suppressed\n        {\n            long value = generator.next(graph, 0, invs, unique, rotated, Suppressed.none());\n\n            assertThat(unique, is(new long[]{31, 0, 0, 0}));\n            assertThat(rotated, is(new long[]{generator.rotate(31, 2), 0, 0, 0}));\n            assertThat(value, is(generator.distribute(21) ^ 31 ^ generator.rotate(31) ^ generator.rotate(31, 2)));\n        }\n\n        // okay now suppress vertices 1\n        {\n            BitSet suppressed = new BitSet();\n            suppressed.set(1);\n\n            long value = generator.next(graph, 0, invs, unique, rotated, Suppressed.fromBitSet(suppressed));\n\n            assertThat(unique, is(new long[]{31, 0, 0, 0}));\n            assertThat(rotated, is(new long[]{generator.rotate(31, 1), 0, 0, 0})); // 31 only encountered twice\n            assertThat(value, is(generator.distribute(21) ^ 31 ^ generator.rotate(31)));\n        }\n\n        // okay now suppress vertices 1 and 3\n        {\n            BitSet suppressed = new BitSet();\n            suppressed.set(1);\n            suppressed.set(3);\n\n            long value = generator.next(graph, 0, invs, unique, rotated, Suppressed.fromBitSet(suppressed));\n\n            assertThat(unique, is(new long[]{31, 0, 0, 0}));\n            assertThat(rotated, is(new long[]{31, 0, 0, 0})); // 31 only encountered once and is not rotated\n            assertThat(value, is(generator.distribute(21) ^ 31)); // only encountered once\n        }\n\n    }", "signature": "void testRotation()", "full_signature": "@Test public void testRotation()", "class_method_signature": "SuppressedAtomHashGeneratorTest.testRotation()", "testcase": true, "constructor": false, "invocations": ["mock", "mock", "mock", "unsuppressed", "next", "none", "assertThat", "is", "assertThat", "is", "rotate", "assertThat", "is", "distribute", "rotate", "rotate", "set", "next", "fromBitSet", "assertThat", "is", "assertThat", "is", "rotate", "assertThat", "is", "distribute", "rotate", "set", "set", "next", "fromBitSet", "assertThat", "is", "assertThat", "is", "assertThat", "is", "distribute"]}, "focal_class": {"identifier": "SuppressedAtomHashGenerator", "superclass": "extends AbstractAtomHashGenerator", "interfaces": "implements AtomHashGenerator", "fields": [{"original_string": "private final AtomHashGenerator    seedGenerator;", "modifier": "private final", "type": "AtomHashGenerator", "declarator": "seedGenerator", "var_name": "seedGenerator"}, {"original_string": "private final StereoEncoderFactory factory;", "modifier": "private final", "type": "StereoEncoderFactory", "declarator": "factory", "var_name": "factory"}, {"original_string": "private final int                  depth;", "modifier": "private final", "type": "int", "declarator": "depth", "var_name": "depth"}, {"original_string": "private final AtomSuppression      suppression;", "modifier": "private final", "type": "AtomSuppression", "declarator": "suppression", "var_name": "suppression"}], "methods": [{"identifier": "SuppressedAtomHashGenerator", "parameters": "(AtomHashGenerator seedGenerator, Pseudorandom pseudorandom,\n            StereoEncoderFactory factory, AtomSuppression suppression, int depth)", "modifiers": "public", "return": "", "signature": " SuppressedAtomHashGenerator(AtomHashGenerator seedGenerator, Pseudorandom pseudorandom,\n            StereoEncoderFactory factory, AtomSuppression suppression, int depth)", "full_signature": "public  SuppressedAtomHashGenerator(AtomHashGenerator seedGenerator, Pseudorandom pseudorandom,\n            StereoEncoderFactory factory, AtomSuppression suppression, int depth)", "class_method_signature": "SuppressedAtomHashGenerator.SuppressedAtomHashGenerator(AtomHashGenerator seedGenerator, Pseudorandom pseudorandom,\n            StereoEncoderFactory factory, AtomSuppression suppression, int depth)", "testcase": false, "constructor": true}, {"identifier": "SuppressedAtomHashGenerator", "parameters": "(AtomHashGenerator seedGenerator, Pseudorandom pseudorandom,\n            AtomSuppression suppression, int depth)", "modifiers": "public", "return": "", "signature": " SuppressedAtomHashGenerator(AtomHashGenerator seedGenerator, Pseudorandom pseudorandom,\n            AtomSuppression suppression, int depth)", "full_signature": "public  SuppressedAtomHashGenerator(AtomHashGenerator seedGenerator, Pseudorandom pseudorandom,\n            AtomSuppression suppression, int depth)", "class_method_signature": "SuppressedAtomHashGenerator.SuppressedAtomHashGenerator(AtomHashGenerator seedGenerator, Pseudorandom pseudorandom,\n            AtomSuppression suppression, int depth)", "testcase": false, "constructor": true}, {"identifier": "generate", "parameters": "(IAtomContainer container)", "modifiers": "@Override public", "return": "long[]", "signature": "long[] generate(IAtomContainer container)", "full_signature": "@Override public long[] generate(IAtomContainer container)", "class_method_signature": "SuppressedAtomHashGenerator.generate(IAtomContainer container)", "testcase": false, "constructor": false}, {"identifier": "generate", "parameters": "(long[] current, StereoEncoder encoder, int[][] graph, Suppressed suppressed)", "modifiers": "@Override", "return": "long[]", "signature": "long[] generate(long[] current, StereoEncoder encoder, int[][] graph, Suppressed suppressed)", "full_signature": "@Override long[] generate(long[] current, StereoEncoder encoder, int[][] graph, Suppressed suppressed)", "class_method_signature": "SuppressedAtomHashGenerator.generate(long[] current, StereoEncoder encoder, int[][] graph, Suppressed suppressed)", "testcase": false, "constructor": false}, {"identifier": "next", "parameters": "(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed)", "modifiers": "", "return": "long", "signature": "long next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed)", "full_signature": " long next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed)", "class_method_signature": "SuppressedAtomHashGenerator.next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed)", "testcase": false, "constructor": false}], "file": "tool/hash/src/main/java/org/openscience/cdk/hash/SuppressedAtomHashGenerator.java"}, "focal_method": {"identifier": "next", "parameters": "(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed)", "modifiers": "", "return": "long", "body": "long next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed) {\n\n        if (suppressed.contains(v)) return current[v];\n\n        long invariant = distribute(current[v]);\n        int nUnique = 0;\n\n        for (int w : graph[v]) {\n\n            // skip suppressed atom\n            if (suppressed.contains(w)) continue;\n\n            long adjInv = current[w];\n\n            // find index of already included neighbor\n            int i = 0;\n            while (i < nUnique && unique[i] != adjInv) {\n                ++i;\n            }\n\n            // no match, then the value is unique, use adjInv\n            // match, then rotate the previously included value\n            included[i] = (i == nUnique) ? unique[nUnique++] = adjInv : rotate(included[i]);\n\n            invariant ^= included[i];\n        }\n\n        return invariant;\n    }", "signature": "long next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed)", "full_signature": " long next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed)", "class_method_signature": "SuppressedAtomHashGenerator.next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed)", "testcase": false, "constructor": false, "invocations": ["contains", "distribute", "contains", "rotate"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}