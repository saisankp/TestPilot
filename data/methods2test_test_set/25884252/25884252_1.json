{"test_class": {"identifier": "ConstraintSolverTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverTest.class);", "modifier": "static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(ConstraintSolverTest.class)", "var_name": "LOG"}], "file": "core/src/test/java/edu/tuberlin/dima/textmining/jedi/core/features/ConstraintSolverTest.java"}, "test_case": {"identifier": "testSolve", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSolve() throws Exception {\n\n        ConstraintSolver.ConstraintSolverBuilder<String> solverBuilder = new ConstraintSolver.ConstraintSolverBuilder<>();\n\n\n        solverBuilder.add(\"E1\", \"E2\", \"x -> y\", \"1\", \"A\", \"D\", 1, 1, 1);\n        solverBuilder.add(\"E1\", \"E2\", \"x -> y\", \"2\", \"A#\", \"D\", 3, 1, 1);\n        solverBuilder.add(\"E2\", \"E3\", \"x -> y\", \"3\", \"D\", \"B\", 1, 1, 1);\n        solverBuilder.add(\"E1\", \"E3\", \"x -> y\", \"4\", \"A\", \"B\", 1, 1, 1);\n\n\n        solverBuilder.add(\"E3\", \"E4\", \"x -> y\", \"5\", \"B\", \"C\", 1, 1, 1);\n        PrintCollector printCollector = new PrintCollector(true);\n\n        final List<DetectedRelation<String>> solve = solverBuilder.build().solve(printCollector);\n\n        assertNotNull(solve);\n        assertThat(solve.size(), is(4));\n\n        assertThat(solve.get(0).getEdge(), is(new Edge(1, \"1\", \"x -> y\", \"A\", \"D\", 1, 1, 1, false)));\n        assertThat(solve.get(1).getEdge(), is(new Edge(4, \"4\", \"x -> y\", \"A\", \"B\", 1, 1, 1, false)));\n        assertThat(solve.get(2).getEdge(), is(new Edge(3, \"3\", \"x -> y\", \"D\", \"B\", 1, 1, 1, false)));\n        assertThat(solve.get(3).getEdge(), is(new Edge(5, \"5\", \"x -> y\", \"B\", \"C\", 1, 1, 1, false)));\n\n        printCollector.print(Joiner.on(\"\\n\").join(solve));\n\n        printCollector.print(Graph.transform(solve).toString());\n    }", "signature": "void testSolve()", "full_signature": "@Test public void testSolve()", "class_method_signature": "ConstraintSolverTest.testSolve()", "testcase": true, "constructor": false, "invocations": ["add", "add", "add", "add", "add", "solve", "build", "assertNotNull", "assertThat", "size", "is", "assertThat", "getEdge", "get", "is", "assertThat", "getEdge", "get", "is", "assertThat", "getEdge", "get", "is", "assertThat", "getEdge", "get", "is", "print", "join", "on", "print", "toString", "transform"]}, "focal_class": {"identifier": "ConstraintSolver", "superclass": "", "interfaces": "", "fields": [{"original_string": "final Set<String> types;", "modifier": "final", "type": "Set<String>", "declarator": "types", "var_name": "types"}, {"original_string": "final Table<String, String, String> rel;", "modifier": "final", "type": "Table<String, String, String>", "declarator": "rel", "var_name": "rel"}, {"original_string": "Multigraph<T, Edge> graph;", "modifier": "", "type": "Multigraph<T, Edge>", "declarator": "graph", "var_name": "graph"}, {"original_string": "private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolver.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(ConstraintSolver.class)", "var_name": "LOG"}, {"original_string": "private final Predicate<T> orphanedVerticesPredicate = new Predicate<T>() {\n        @Override\n        public boolean apply(@Nullable T input) {\n            return graph.degreeOf(input) == 0;\n        }\n    };", "modifier": "private final", "type": "Predicate<T>", "declarator": "orphanedVerticesPredicate = new Predicate<T>() {\n        @Override\n        public boolean apply(@Nullable T input) {\n            return graph.degreeOf(input) == 0;\n        }\n    }", "var_name": "orphanedVerticesPredicate"}, {"original_string": "private final Comparator<List<DetectedRelation<T>>> solutionComparator = (o1, o2) -> {\n\n        // compare size of detectedRelation chain as well\n        return ComparisonChain.start()/*.compare(o1.size(), o2.size())*/.compare(score(o1), score(o2)).result();\n    };", "modifier": "private final", "type": "Comparator<List<DetectedRelation<T>>>", "declarator": "solutionComparator = (o1, o2) -> {\n\n        // compare size of detectedRelation chain as well\n        return ComparisonChain.start()/*.compare(o1.size(), o2.size())*/.compare(score(o1), score(o2)).result();\n    }", "var_name": "solutionComparator"}, {"original_string": "private final List<DetectedRelation<T>> emptyList = Lists.<DetectedRelation<T>>newArrayList();", "modifier": "private final", "type": "List<DetectedRelation<T>>", "declarator": "emptyList = Lists.<DetectedRelation<T>>newArrayList()", "var_name": "emptyList"}, {"original_string": "private final Function<T, String> vertexToString = new Function<T, String>() {\n        @Nullable\n        @Override\n        public String apply(@Nullable T input) {\n            return transformToString(input) + \" \" + input.hashCode();\n        }\n    };", "modifier": "private final", "type": "Function<T, String>", "declarator": "vertexToString = new Function<T, String>() {\n        @Nullable\n        @Override\n        public String apply(@Nullable T input) {\n            return transformToString(input) + \" \" + input.hashCode();\n        }\n    }", "var_name": "vertexToString"}], "methods": [{"identifier": "ConstraintSolver", "parameters": "(Set<String> types, Table<String, String, String> rel, Multigraph<T, Edge> graph)", "modifiers": "private", "return": "", "signature": " ConstraintSolver(Set<String> types, Table<String, String, String> rel, Multigraph<T, Edge> graph)", "full_signature": "private  ConstraintSolver(Set<String> types, Table<String, String, String> rel, Multigraph<T, Edge> graph)", "class_method_signature": "ConstraintSolver.ConstraintSolver(Set<String> types, Table<String, String, String> rel, Multigraph<T, Edge> graph)", "testcase": false, "constructor": true}, {"identifier": "score", "parameters": "(List<DetectedRelation<T>> detectedRelation)", "modifiers": "private", "return": "float", "signature": "float score(List<DetectedRelation<T>> detectedRelation)", "full_signature": "private float score(List<DetectedRelation<T>> detectedRelation)", "class_method_signature": "ConstraintSolver.score(List<DetectedRelation<T>> detectedRelation)", "testcase": false, "constructor": false}, {"identifier": "pruneGraph", "parameters": "(PrintCollector printCollector)", "modifiers": "private", "return": "void", "signature": "void pruneGraph(PrintCollector printCollector)", "full_signature": "private void pruneGraph(PrintCollector printCollector)", "class_method_signature": "ConstraintSolver.pruneGraph(PrintCollector printCollector)", "testcase": false, "constructor": false}, {"identifier": "solve", "parameters": "(PrintCollector printCollector)", "modifiers": "public", "return": "List<DetectedRelation<T>>", "signature": "List<DetectedRelation<T>> solve(PrintCollector printCollector)", "full_signature": "public List<DetectedRelation<T>> solve(PrintCollector printCollector)", "class_method_signature": "ConstraintSolver.solve(PrintCollector printCollector)", "testcase": false, "constructor": false}, {"identifier": "solveConnectedComponent", "parameters": "(PrintCollector printCollector, Set<T> connectedComponents)", "modifiers": "private", "return": "List<DetectedRelation<T>>", "signature": "List<DetectedRelation<T>> solveConnectedComponent(PrintCollector printCollector, Set<T> connectedComponents)", "full_signature": "private List<DetectedRelation<T>> solveConnectedComponent(PrintCollector printCollector, Set<T> connectedComponents)", "class_method_signature": "ConstraintSolver.solveConnectedComponent(PrintCollector printCollector, Set<T> connectedComponents)", "testcase": false, "constructor": false}, {"identifier": "internalSolve", "parameters": "(final PrintCollector printCollector, final boolean initial)", "modifiers": "private", "return": "InternalSolveResult<T>", "signature": "InternalSolveResult<T> internalSolve(final PrintCollector printCollector, final boolean initial)", "full_signature": "private InternalSolveResult<T> internalSolve(final PrintCollector printCollector, final boolean initial)", "class_method_signature": "ConstraintSolver.internalSolve(final PrintCollector printCollector, final boolean initial)", "testcase": false, "constructor": false}, {"identifier": "generateSolution", "parameters": "(final BiMap<Integer, String> typeMapping, Map<T, IntVar> encoding)", "modifiers": "private", "return": "List<DetectedRelation<T>>", "signature": "List<DetectedRelation<T>> generateSolution(final BiMap<Integer, String> typeMapping, Map<T, IntVar> encoding)", "full_signature": "private List<DetectedRelation<T>> generateSolution(final BiMap<Integer, String> typeMapping, Map<T, IntVar> encoding)", "class_method_signature": "ConstraintSolver.generateSolution(final BiMap<Integer, String> typeMapping, Map<T, IntVar> encoding)", "testcase": false, "constructor": false}, {"identifier": "transformToString", "parameters": "(T node)", "modifiers": "private static", "return": "String", "signature": "String transformToString(T node)", "full_signature": "private static String transformToString(T node)", "class_method_signature": "ConstraintSolver.transformToString(T node)", "testcase": false, "constructor": false}], "file": "core/src/main/java/edu/tuberlin/dima/textmining/jedi/core/features/ConstraintSolver.java"}, "focal_method": {"identifier": "solve", "parameters": "(PrintCollector printCollector)", "modifiers": "public", "return": "List<DetectedRelation<T>>", "body": "public List<DetectedRelation<T>> solve(PrintCollector printCollector) {\n\n        List<DetectedRelation<T>> detectedRelations = Lists.newArrayList();\n\n        // prune graph\n        pruneGraph(printCollector);\n\n        ConnectivityInspector<T, Edge> connectivityInspector = new ConnectivityInspector<>(graph);\n\n        List<Set<T>> connectedComponents = connectivityInspector.connectedSets();\n\n/*        for (Edge edge : graph.edgeSet()) {\n            T edgeSource = graph.getEdgeSource(edge);\n            T edgeTarget = graph.getEdgeTarget(edge);\n            System.out.println(\n                    Joiner.on(\" \").join(transformToString(edgeSource), ((Annotation)edgeSource).getBegin(), ((Annotation)edgeSource).getEnd(), edgeSource.hashCode()) + \"   ->  \" +\n                            Joiner.on(\" \").join(((Annotation)edgeTarget).getCoveredText(),((Annotation)edgeTarget).getBegin(), ((Annotation)edgeTarget).getEnd(), edgeTarget.hashCode()));\n        } */\n\n        // solve each connected component separately\n\n        // save the current state of the graph to revert\n        final UndirectedGraph<T, Edge> restored = new Multigraph<>(Edge.class);\n        Graphs.addGraph(restored, graph);\n\n        printCollector.print(String.format(\"Graph has %2d components\", connectedComponents.size()));\n        for (Set<T> connectedComponent : connectedComponents) {\n\n            // remove all vertices that are not part of the connected component\n            printCollector.print(String.format(\"Solving connected component with %d vertices\", connectedComponent.size()));\n            //printCollector.print(Iterables.toString(Iterables.transform(connectedComponent, vertexToString)));\n\n            // determine which nodes need to go\n            HashSet<T> difference = Sets.newHashSet(Sets.difference(graph.vertexSet(), connectedComponent));\n            graph.removeAllVertices(difference);\n\n            detectedRelations.addAll(solveConnectedComponent(printCollector, connectedComponent));\n\n            // restore graph\n            Graphs.addGraph(graph, restored);\n        }\n\n        return detectedRelations;\n    }", "signature": "List<DetectedRelation<T>> solve(PrintCollector printCollector)", "full_signature": "public List<DetectedRelation<T>> solve(PrintCollector printCollector)", "class_method_signature": "ConstraintSolver.solve(PrintCollector printCollector)", "testcase": false, "constructor": false, "invocations": ["newArrayList", "pruneGraph", "connectedSets", "addGraph", "print", "format", "size", "print", "format", "size", "newHashSet", "difference", "vertexSet", "removeAllVertices", "addAll", "solveConnectedComponent", "addGraph"]}, "repository": {"repo_id": 25884252, "url": "https://github.com/jkirsch/jedi", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 5, "size": 759, "license": "licensed"}}