{"test_class": {"identifier": "TestTimer", "superclass": "", "interfaces": "", "fields": [{"original_string": "private HardwareClock mockClock;", "modifier": "private", "type": "HardwareClock", "declarator": "mockClock", "var_name": "mockClock"}, {"original_string": "private Timer impl;", "modifier": "private", "type": "Timer", "declarator": "impl", "var_name": "impl"}], "file": "jrugged-core/src/test/java/org/fishwife/jrugged/clocks/TestTimer.java"}, "test_case": {"identifier": "cannotAskForRemainingTimeIfNotSet", "parameters": "()", "modifiers": "@Test(expected=IllegalStateException.class) public", "return": "void", "body": "@Test(expected=IllegalStateException.class)\n    public void cannotAskForRemainingTimeIfNotSet() {\n        expect(mockClock.getGranularity()).andReturn(1L).anyTimes();\n        expect(mockClock.getNanoTime()).andReturn(new DiscreteInterval(4L,5L)).anyTimes();\n        replay(mockClock);\n        impl.getTimeRemaining();\n    }", "signature": "void cannotAskForRemainingTimeIfNotSet()", "full_signature": "@Test(expected=IllegalStateException.class) public void cannotAskForRemainingTimeIfNotSet()", "class_method_signature": "TestTimer.cannotAskForRemainingTimeIfNotSet()", "testcase": true, "constructor": false, "invocations": ["anyTimes", "andReturn", "expect", "getGranularity", "anyTimes", "andReturn", "expect", "getNanoTime", "replay", "getTimeRemaining"]}, "focal_class": {"identifier": "Timer", "superclass": "", "interfaces": "", "fields": [{"original_string": "private HardwareClock clock;", "modifier": "private", "type": "HardwareClock", "declarator": "clock", "var_name": "clock"}, {"original_string": "private boolean wasSet = false;", "modifier": "private", "type": "boolean", "declarator": "wasSet = false", "var_name": "wasSet"}, {"original_string": "private DiscreteInterval targetElapsedTime;", "modifier": "private", "type": "DiscreteInterval", "declarator": "targetElapsedTime", "var_name": "targetElapsedTime"}, {"original_string": "private DiscreteInterval startTime;", "modifier": "private", "type": "DiscreteInterval", "declarator": "startTime", "var_name": "startTime"}, {"original_string": "private DiscreteInterval targetEndTime;", "modifier": "private", "type": "DiscreteInterval", "declarator": "targetEndTime", "var_name": "targetEndTime"}], "methods": [{"identifier": "Timer", "parameters": "()", "modifiers": "public", "return": "", "signature": " Timer()", "full_signature": "public  Timer()", "class_method_signature": "Timer.Timer()", "testcase": false, "constructor": true}, {"identifier": "Timer", "parameters": "(HardwareClock clock)", "modifiers": "public", "return": "", "signature": " Timer(HardwareClock clock)", "full_signature": "public  Timer(HardwareClock clock)", "class_method_signature": "Timer.Timer(HardwareClock clock)", "testcase": false, "constructor": true}, {"identifier": "set", "parameters": "(long duration, long error)", "modifiers": "public", "return": "boolean", "signature": "boolean set(long duration, long error)", "full_signature": "public boolean set(long duration, long error)", "class_method_signature": "Timer.set(long duration, long error)", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void start()", "full_signature": "public void start()", "class_method_signature": "Timer.start()", "testcase": false, "constructor": false}, {"identifier": "hasElapsed", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean hasElapsed()", "full_signature": "public boolean hasElapsed()", "class_method_signature": "Timer.hasElapsed()", "testcase": false, "constructor": false}, {"identifier": "isLate", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isLate()", "full_signature": "public boolean isLate()", "class_method_signature": "Timer.isLate()", "testcase": false, "constructor": false}, {"identifier": "getTimeRemaining", "parameters": "()", "modifiers": "public", "return": "DiscreteInterval", "signature": "DiscreteInterval getTimeRemaining()", "full_signature": "public DiscreteInterval getTimeRemaining()", "class_method_signature": "Timer.getTimeRemaining()", "testcase": false, "constructor": false}, {"identifier": "waitUntilElapsed", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void waitUntilElapsed()", "full_signature": "public void waitUntilElapsed()", "class_method_signature": "Timer.waitUntilElapsed()", "testcase": false, "constructor": false}], "file": "jrugged-core/src/main/java/org/fishwife/jrugged/clocks/Timer.java"}, "focal_method": {"identifier": "getTimeRemaining", "parameters": "()", "modifiers": "public", "return": "DiscreteInterval", "body": "public DiscreteInterval getTimeRemaining() {\n        if (!wasSet) throw new IllegalStateException(\"cannot compute time remaining without having duration set\");\n        if (startTime == null) return targetElapsedTime;\n        DiscreteInterval diff = targetEndTime.minus(clock.getNanoTime());\n        return (diff.getMin() <= 0L) ? new DiscreteInterval(0L,0L) : diff;\n    }", "signature": "DiscreteInterval getTimeRemaining()", "full_signature": "public DiscreteInterval getTimeRemaining()", "class_method_signature": "Timer.getTimeRemaining()", "testcase": false, "constructor": false, "invocations": ["minus", "getNanoTime", "getMin"]}, "repository": {"repo_id": 6602723, "url": "https://github.com/Comcast/jrugged", "language": "Java", "is_fork": false, "fork_count": 90, "stargazer_count": 236, "size": 1302, "license": "licensed"}}