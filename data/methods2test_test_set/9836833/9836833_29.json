{"test_class": {"identifier": "TypesTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n\tpublic JUnitSoftAssertions softly = new JUnitSoftAssertions();", "modifier": "@Rule\n\tpublic", "type": "JUnitSoftAssertions", "declarator": "softly = new JUnitSoftAssertions()", "var_name": "softly"}], "file": "restx-common/src/test/java/restx/common/TypesTest.java"}, "test_case": {"identifier": "isAssignableFrom_should_manage_to_match_generic_variable_from_sub_types_to_super_types", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void isAssignableFrom_should_manage_to_match_generic_variable_from_sub_types_to_super_types() {\n\t\t// SomethingMap and SuperMap\n\n\t\tsoftly.assertThat(isAssignableFrom(\n\t\t\t\tnew TypeReference<GenericInterface<Double>>() {}.getType(),\n\t\t\t\tnew TypeReference<SomethingMap<Double, Integer>>() {}.getType()\n\t\t)).isTrue();\n\n\t\tsoftly.assertThat(isAssignableFrom(\n\t\t\t\tnew TypeReference<GenericInterface<String>>() {}.getType(),\n\t\t\t\tnew TypeReference<SomethingMap<String, Integer>>() {}.getType()\n\t\t)).isTrue();\n\n\t\tsoftly.assertThat(isAssignableFrom(\n\t\t\t\tnew TypeReference<GenericInterface<String>>() {}.getType(),\n\t\t\t\tnew TypeReference<SomethingMap<Number, Integer>>() {}.getType()\n\t\t)).isFalse();\n\n\t\tsoftly.assertThat(isAssignableFrom(\n\t\t\t\tnew TypeReference<GenericInterface<Double>>() {}.getType(),\n\t\t\t\tnew TypeReference<SuperMap<Integer, Double>>() {}.getType()\n\t\t)).isTrue();\n\n\t\tsoftly.assertThat(isAssignableFrom(\n\t\t\t\tnew TypeReference<GenericInterface<String>>() {}.getType(),\n\t\t\t\tnew TypeReference<SuperMap<Integer, String>>() {}.getType()\n\t\t)).isTrue();\n\n\t\tsoftly.assertThat(isAssignableFrom(\n\t\t\t\tnew TypeReference<GenericInterface<String>>() {}.getType(),\n\t\t\t\tnew TypeReference<SuperMap<Integer, Number>>() {}.getType()\n\t\t)).isFalse();\n\n\t\t// FixedSomethingMap and FixedSuperMap\n\n\t\tsoftly.assertThat(isAssignableFrom(\n\t\t\t\tnew TypeReference<GenericInterface<Double>>() {}.getType(),\n\t\t\t\tnew TypeReference<FixedSuperMap<Integer, Long>>() {}.getType()\n\t\t)).isTrue();\n\n\t\tsoftly.assertThat(isAssignableFrom(\n\t\t\t\tnew TypeReference<GenericInterface<Double>>() {}.getType(),\n\t\t\t\tnew TypeReference<FixedSuperMap<Number, Double>>() {}.getType()\n\t\t)).isTrue();\n\n\t\tsoftly.assertThat(isAssignableFrom(\n\t\t\t\tnew TypeReference<GenericInterface<Integer>>() {}.getType(),\n\t\t\t\tnew TypeReference<FixedSuperMap<Number, Double>>() {}.getType()\n\t\t)).isFalse();\n\t}", "signature": "void isAssignableFrom_should_manage_to_match_generic_variable_from_sub_types_to_super_types()", "full_signature": "@Test public void isAssignableFrom_should_manage_to_match_generic_variable_from_sub_types_to_super_types()", "class_method_signature": "TypesTest.isAssignableFrom_should_manage_to_match_generic_variable_from_sub_types_to_super_types()", "testcase": true, "constructor": false, "invocations": ["isTrue", "assertThat", "isAssignableFrom", "getType", "getType", "isTrue", "assertThat", "isAssignableFrom", "getType", "getType", "isFalse", "assertThat", "isAssignableFrom", "getType", "getType", "isTrue", "assertThat", "isAssignableFrom", "getType", "getType", "isTrue", "assertThat", "isAssignableFrom", "getType", "getType", "isFalse", "assertThat", "isAssignableFrom", "getType", "getType", "isTrue", "assertThat", "isAssignableFrom", "getType", "getType", "isTrue", "assertThat", "isAssignableFrom", "getType", "getType", "isFalse", "assertThat", "isAssignableFrom", "getType", "getType"]}, "focal_class": {"identifier": "Types", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "newParameterizedType", "parameters": "(final Class<?> rawType, final Type... arguments)", "modifiers": "public static", "return": "ParameterizedType", "signature": "ParameterizedType newParameterizedType(final Class<?> rawType, final Type... arguments)", "full_signature": "public static ParameterizedType newParameterizedType(final Class<?> rawType, final Type... arguments)", "class_method_signature": "Types.newParameterizedType(final Class<?> rawType, final Type... arguments)", "testcase": false, "constructor": false}, {"identifier": "getRawType", "parameters": "(Type type)", "modifiers": "public static", "return": "Class<?>", "signature": "Class<?> getRawType(Type type)", "full_signature": "public static Class<?> getRawType(Type type)", "class_method_signature": "Types.getRawType(Type type)", "testcase": false, "constructor": false}, {"identifier": "isAssignableFrom", "parameters": "(Type t1, Type t2)", "modifiers": "public static", "return": "boolean", "signature": "boolean isAssignableFrom(Type t1, Type t2)", "full_signature": "public static boolean isAssignableFrom(Type t1, Type t2)", "class_method_signature": "Types.isAssignableFrom(Type t1, Type t2)", "testcase": false, "constructor": false}], "file": "restx-common/src/main/java/restx/common/Types.java"}, "focal_method": {"identifier": "isAssignableFrom", "parameters": "(Type t1, Type t2)", "modifiers": "public static", "return": "boolean", "body": "public static boolean isAssignableFrom(Type t1, Type t2) {\n\t\tcheckNotNull(t1);\n\t\tcheckNotNull(t2);\n\n\t\tif (t1.equals(t2)) {\n\t\t\t// easy case, types are equals\n\t\t\treturn true;\n\t\t}\n\n\t\tif (t1 instanceof Class<?>) {\n\t\t\t/*\n\t\t\t\tfirst type is a reifiable class, so any raw type, generic or not,\n\t\t\t\twhich is assignable by the raw type of t1 means that t1 is assignable from t2\n\t\t\t\tand the reverse is also true\n\t\t\t */\n\t\t\treturn ((Class<?>) t1).isAssignableFrom(getRawType(t2));\n\t\t}\n\n\t\tif (t1 instanceof ParameterizedType) {\n\t\t\tClass<?> rawTypeT1 = getRawType(t1);\n\t\t\tClass<?> rawTypeT2 = getRawType(t2);\n\n\t\t\tif (!rawTypeT1.isAssignableFrom(rawTypeT2) || rawTypeT1.equals(rawTypeT2)) {\n\t\t\t\t/*\n\t\t\t\t\tdon't need to go further and to check generics, raw type of first type is not assignable\n\t\t\t\t\tfrom second one, or raw types are equals but type aren't, so has one can not reference\n\t\t\t\t\ta same type having a different generic type than his, it also means that t1 is not\n\t\t\t\t\tassignable from t2\n\t\t\t\t */\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (t2 instanceof Class<?>) {\n\t\t\t\t/*\n\t\t\t\t\twe need to launch a recursive analysis on generic super type, and generic interfaces, because\n\t\t\t\t\tt2 is a reifiable class, so there is no way that t1 can be directly assigned from t2,\n\t\t\t\t\tso it has to be one of the sub-types of t2\n\t\t\t\t */\n\n\t\t\t\tType genericSuperclass = ((Class) t2).getGenericSuperclass();\n\t\t\t\tif (genericSuperclass != null) {\n\t\t\t\t\tif (isAssignableFrom(t1, genericSuperclass)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tType[] genericInterfaces = ((Class) t2).getGenericInterfaces();\n\t\t\t\tfor (Type genericInterface : genericInterfaces) {\n\t\t\t\t\tif (isAssignableFrom(t1, genericInterface)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (t2 instanceof ParameterizedType) {\n\t\t\t\t/*\n\t\t\t\t\tExtract generics type, and variables of the class, in order to know the concrete type of each variables\n\t\t\t\t */\n\t\t\t\tType[] actualTypeArguments = ((ParameterizedType) t2).getActualTypeArguments();\n\t\t\t\tTypeVariable<? extends Class<?>>[] typeParameters = rawTypeT2.getTypeParameters();\n\t\t\t\tMap<TypeVariable<? extends Class<?>>, Type> typesMap = Maps.newHashMapWithExpectedSize(typeParameters.length);\n\t\t\t\tfor (int i = 0; i < typeParameters.length; i++) {\n\t\t\t\t\ttypesMap.put(typeParameters[i], actualTypeArguments[i]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t\tTry with the superclass, and fill variable with concrete types\n\t\t\t\t */\n\t\t\t\tType genericSuperclass = rawTypeT2.getGenericSuperclass();\n\t\t\t\tif (genericSuperclass != null) {\n\t\t\t\t\tif (genericSuperclass instanceof Class<?>) {\n\t\t\t\t\t\tif (isAssignableFrom(t1, genericSuperclass)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (genericSuperclass instanceof ParameterizedType) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tWe need to replace type parameters with concrete types\n\t\t\t\t\t\t */\n\t\t\t\t\t\tParameterizedType genericSuperclassParameterized = (ParameterizedType) genericSuperclass;\n\t\t\t\t\t\tType[] genericSuperclassActualTypeArguments = genericSuperclassParameterized.getActualTypeArguments();\n\t\t\t\t\t\tfor (int i = 0; i < genericSuperclassActualTypeArguments.length; i++) {\n\t\t\t\t\t\t\tif (genericSuperclassActualTypeArguments[i] instanceof TypeVariable) {\n\t\t\t\t\t\t\t\tgenericSuperclassActualTypeArguments[i] = typesMap.get(genericSuperclassActualTypeArguments[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tType genericSuperclassRawType = genericSuperclassParameterized.getRawType();\n\t\t\t\t\t\tif (isAssignableFrom(t1, Types.newParameterizedType((Class<?>) genericSuperclassRawType,\n\t\t\t\t\t\t\t\tgenericSuperclassActualTypeArguments))) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t\tTry the same thing with interfaces\n\t\t\t\t */\n\t\t\t\tType[] genericInterfaces = rawTypeT2.getGenericInterfaces();\n\t\t\t\tfor (Type genericInterface : genericInterfaces) {\n\t\t\t\t\tif (genericInterface instanceof Class<?>) {\n\t\t\t\t\t\tif (isAssignableFrom(t1, genericInterface)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (genericInterface instanceof ParameterizedType) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tWe need to replace type parameters with concrete types\n\t\t\t\t\t\t */\n\t\t\t\t\t\tParameterizedType genericInterfaceParameterized = (ParameterizedType) genericInterface;\n\t\t\t\t\t\tType[] genericInterfaceActualTypeArguments = genericInterfaceParameterized.getActualTypeArguments();\n\t\t\t\t\t\tfor (int i = 0; i < genericInterfaceActualTypeArguments.length; i++) {\n\t\t\t\t\t\t\tif (genericInterfaceActualTypeArguments[i] instanceof TypeVariable) {\n\t\t\t\t\t\t\t\tgenericInterfaceActualTypeArguments[i] = typesMap.get(genericInterfaceActualTypeArguments[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tType genericInterfaceRawType = genericInterfaceParameterized.getRawType();\n\t\t\t\t\t\tif (isAssignableFrom(t1, Types.newParameterizedType((Class<?>) genericInterfaceRawType,\n\t\t\t\t\t\t\t\tgenericInterfaceActualTypeArguments))) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "signature": "boolean isAssignableFrom(Type t1, Type t2)", "full_signature": "public static boolean isAssignableFrom(Type t1, Type t2)", "class_method_signature": "Types.isAssignableFrom(Type t1, Type t2)", "testcase": false, "constructor": false, "invocations": ["checkNotNull", "checkNotNull", "equals", "isAssignableFrom", "getRawType", "getRawType", "getRawType", "isAssignableFrom", "equals", "getGenericSuperclass", "isAssignableFrom", "getGenericInterfaces", "isAssignableFrom", "getActualTypeArguments", "getTypeParameters", "newHashMapWithExpectedSize", "put", "getGenericSuperclass", "isAssignableFrom", "getActualTypeArguments", "get", "getRawType", "isAssignableFrom", "newParameterizedType", "getGenericInterfaces", "isAssignableFrom", "getActualTypeArguments", "get", "getRawType", "isAssignableFrom", "newParameterizedType"]}, "repository": {"repo_id": 9836833, "url": "https://github.com/restx/restx", "language": "Java", "is_fork": false, "fork_count": 78, "stargazer_count": 433, "size": 7896, "license": "licensed"}}