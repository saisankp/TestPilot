{"test_class": {"identifier": "MinHashLSHTest", "superclass": "", "interfaces": "", "fields": [], "file": "core/src/test/java/com/alibaba/alink/operator/common/feature/MinHashLSHTest.java"}, "test_case": {"identifier": "testHashFunction", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testHashFunction() {\n        MinHashLSH lsh = new MinHashLSH(0, 2, 2);\n        Vector vec1 = new DenseVector(new double[] {1, 2, 3, 4, 5});\n        Assert.assertEquals(new DenseVector(new double[] {478212008, -1798305157}), lsh.hashFunction(vec1));\n        Vector vec2 = new SparseVector(5, new int[] {0, 4}, new double[] {1.0, 4.0});\n        Assert.assertEquals(new DenseVector(new double[] {-967745172, -594675602}), lsh.hashFunction(vec2));\n    }", "signature": "void testHashFunction()", "full_signature": "@Test public void testHashFunction()", "class_method_signature": "MinHashLSHTest.testHashFunction()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "hashFunction", "assertEquals", "hashFunction"]}, "focal_class": {"identifier": "MinHashLSH", "superclass": "extends BaseLSH", "interfaces": "", "fields": [{"original_string": "private static int HASH_PRIME = 2038074743;", "modifier": "private static", "type": "int", "declarator": "HASH_PRIME = 2038074743", "var_name": "HASH_PRIME"}, {"original_string": "int[][] randCoefficientsA, randCoefficientsB;", "modifier": "", "type": "int[][]", "declarator": "randCoefficientsA", "var_name": "randCoefficientsA"}], "methods": [{"identifier": "MinHashLSH", "parameters": "(long seed, int numProjectionsPerTable, int numHashTables)", "modifiers": "public", "return": "", "signature": " MinHashLSH(long seed, int numProjectionsPerTable, int numHashTables)", "full_signature": "public  MinHashLSH(long seed, int numProjectionsPerTable, int numHashTables)", "class_method_signature": "MinHashLSH.MinHashLSH(long seed, int numProjectionsPerTable, int numHashTables)", "testcase": false, "constructor": true}, {"identifier": "MinHashLSH", "parameters": "(int[][] randCoefficientsA, int[][] randCoefficientsB)", "modifiers": "public", "return": "", "signature": " MinHashLSH(int[][] randCoefficientsA, int[][] randCoefficientsB)", "full_signature": "public  MinHashLSH(int[][] randCoefficientsA, int[][] randCoefficientsB)", "class_method_signature": "MinHashLSH.MinHashLSH(int[][] randCoefficientsA, int[][] randCoefficientsB)", "testcase": false, "constructor": true}, {"identifier": "hashFunction", "parameters": "(Vector vec)", "modifiers": "@Override public", "return": "DenseVector", "signature": "DenseVector hashFunction(Vector vec)", "full_signature": "@Override public DenseVector hashFunction(Vector vec)", "class_method_signature": "MinHashLSH.hashFunction(Vector vec)", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/alibaba/alink/operator/common/feature/MinHashLSH.java"}, "focal_method": {"identifier": "hashFunction", "parameters": "(Vector vec)", "modifiers": "@Override public", "return": "DenseVector", "body": "@Override\n    public DenseVector hashFunction(Vector vec) {\n        double[] minHashSet = new double[randCoefficientsA.length];\n        if (randCoefficientsA.length > 0) {\n            int[] hashValues = new int[randCoefficientsA[0].length];\n            if (vec instanceof SparseVector) {\n                SparseVector elem = (SparseVector)vec;\n                int[] indices = elem.getIndices();\n                for (int i = 0; i < minHashSet.length; i++) {\n                    for (int j = 0; j < hashValues.length; j++) {\n                        int tmp = HASH_PRIME, cur;\n                        for (int index : indices) {\n                            cur = (int)((1L + index) * randCoefficientsA[i][j] + randCoefficientsB[i][j])\n                                % HASH_PRIME;\n                            tmp = Math.min(tmp, cur);\n                        }\n                        hashValues[j] = tmp;\n                    }\n                    minHashSet[i] = tableHash(hashValues);\n                }\n            } else if (vec instanceof DenseVector) {\n                double[] elem = ((DenseVector)vec).getData();\n                for (int i = 0; i < minHashSet.length; i++) {\n                    for (int j = 0; j < hashValues.length; j++) {\n                        int tmp = HASH_PRIME, cur;\n                        for (int m = 0; m < elem.length; m++) {\n                            if (elem[m] != 0) {\n                                cur = (int)((1L + m) * randCoefficientsA[i][j] + randCoefficientsB[i][j]) % HASH_PRIME;\n                                tmp = Math.min(tmp, cur);\n                            }\n                        }\n                        hashValues[j] = tmp;\n                    }\n                    minHashSet[i] = tableHash(hashValues);\n                }\n            }\n        }\n        return new DenseVector(minHashSet);\n    }", "signature": "DenseVector hashFunction(Vector vec)", "full_signature": "@Override public DenseVector hashFunction(Vector vec)", "class_method_signature": "MinHashLSH.hashFunction(Vector vec)", "testcase": false, "constructor": false, "invocations": ["getIndices", "min", "tableHash", "getData", "min", "tableHash"]}, "repository": {"repo_id": 150938406, "url": "https://github.com/alibaba/Alink", "stars": 1923, "created": "9/30/2018 6:36:11 AM +00:00", "updates": "2020-01-27T10:24:34+00:00", "fork": "False", "license": "licensed"}}