{"test_class": {"identifier": "OperatorPublishTest", "superclass": "", "interfaces": "", "fields": [], "file": "zava/src/test/java/rx/internal/operators/OperatorPublishTest.java"}, "test_case": {"identifier": "testBackpressureFastSlow", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testBackpressureFastSlow() {\n        ConnectableObservable<Integer> is = Observable.range(1, RxRingBuffer.SIZE * 2).publish();\n        Observable<Integer> fast = is.observeOn(Schedulers.computation()).doOnCompleted(new Action0() {\n\n            @Override\n            public void call() {\n                System.out.println(\"^^^^^^^^^^^^^ completed FAST\");\n            }\n\n        });\n        Observable<Integer> slow = is.observeOn(Schedulers.computation()).map(new Func1<Integer, Integer>() {\n            int c = 0;\n\n            @Override\n            public Integer call(Integer i) {\n                if (c == 0) {\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                    }\n                }\n                c++;\n                return i;\n            }\n\n        }).doOnCompleted(new Action0() {\n\n            @Override\n            public void call() {\n                System.out.println(\"^^^^^^^^^^^^^ completed SLOW\");\n            }\n\n        });\n\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n        Observable.merge(fast, slow).subscribe(ts);\n        is.connect();\n        ts.awaitTerminalEvent();\n        ts.assertNoErrors();\n        assertEquals(RxRingBuffer.SIZE * 4, ts.getOnNextEvents().size());\n    }", "signature": "void testBackpressureFastSlow()", "full_signature": "@Test public void testBackpressureFastSlow()", "class_method_signature": "OperatorPublishTest.testBackpressureFastSlow()", "testcase": true, "constructor": false, "invocations": ["publish", "range", "doOnCompleted", "observeOn", "computation", "println", "doOnCompleted", "map", "observeOn", "computation", "sleep", "println", "subscribe", "merge", "connect", "awaitTerminalEvent", "assertNoErrors", "assertEquals", "size", "getOnNextEvents"]}, "focal_class": {"identifier": "OperatorPublish", "superclass": "extends ConnectableObservable<T>", "interfaces": "", "fields": [{"original_string": "final Observable<? extends T> source;", "modifier": "final", "type": "Observable<? extends T>", "declarator": "source", "var_name": "source"}, {"original_string": "private final RequestHandler<T> requestHandler;", "modifier": "private final", "type": "RequestHandler<T>", "declarator": "requestHandler", "var_name": "requestHandler"}], "methods": [{"identifier": "create", "parameters": "(Observable<? extends T> source)", "modifiers": "public static", "return": "ConnectableObservable<T>", "signature": "ConnectableObservable<T> create(Observable<? extends T> source)", "full_signature": "public static ConnectableObservable<T> create(Observable<? extends T> source)", "class_method_signature": "OperatorPublish.create(Observable<? extends T> source)", "testcase": false, "constructor": false}, {"identifier": "create", "parameters": "(final Observable<? extends T> source, final Func1<? super Observable<T>, ? extends Observable<R>> selector)", "modifiers": "public static", "return": "Observable<R>", "signature": "Observable<R> create(final Observable<? extends T> source, final Func1<? super Observable<T>, ? extends Observable<R>> selector)", "full_signature": "public static Observable<R> create(final Observable<? extends T> source, final Func1<? super Observable<T>, ? extends Observable<R>> selector)", "class_method_signature": "OperatorPublish.create(final Observable<? extends T> source, final Func1<? super Observable<T>, ? extends Observable<R>> selector)", "testcase": false, "constructor": false}, {"identifier": "OperatorPublish", "parameters": "(Observable<? extends T> source)", "modifiers": "private", "return": "", "signature": " OperatorPublish(Observable<? extends T> source)", "full_signature": "private  OperatorPublish(Observable<? extends T> source)", "class_method_signature": "OperatorPublish.OperatorPublish(Observable<? extends T> source)", "testcase": false, "constructor": true}, {"identifier": "OperatorPublish", "parameters": "(Observable<? extends T> source, final Object guard, final RequestHandler<T> requestHandler)", "modifiers": "private", "return": "", "signature": " OperatorPublish(Observable<? extends T> source, final Object guard, final RequestHandler<T> requestHandler)", "full_signature": "private  OperatorPublish(Observable<? extends T> source, final Object guard, final RequestHandler<T> requestHandler)", "class_method_signature": "OperatorPublish.OperatorPublish(Observable<? extends T> source, final Object guard, final RequestHandler<T> requestHandler)", "testcase": false, "constructor": true}, {"identifier": "connect", "parameters": "(Action1<? super Subscription> connection)", "modifiers": "@Override public", "return": "void", "signature": "void connect(Action1<? super Subscription> connection)", "full_signature": "@Override public void connect(Action1<? super Subscription> connection)", "class_method_signature": "OperatorPublish.connect(Action1<? super Subscription> connection)", "testcase": false, "constructor": false}], "file": "zava/src/main/java/rx/internal/operators/OperatorPublish.java"}, "focal_method": {"identifier": "connect", "parameters": "(Action1<? super Subscription> connection)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void connect(Action1<? super Subscription> connection) {\n        // each time we connect we create a new Subscription\n        boolean shouldSubscribe = false;\n        \n        // subscription is the state of whether we are connected or not\n        OriginSubscriber<T> origin = requestHandler.state.getOrigin();\n        if (origin == null) {\n            shouldSubscribe = true;\n            requestHandler.state.setOrigin(new OriginSubscriber<T>(requestHandler));\n        }\n\n        // in the lock above we determined we should subscribe, do it now outside the lock\n        if (shouldSubscribe) {\n            // register a subscription that will shut this down\n            connection.call(Subscriptions.create(new Action0() {\n                @Override\n                public void call() {\n                    OriginSubscriber<T> s = requestHandler.state.getOrigin();\n                    requestHandler.state.setOrigin(null);\n                    if (s != null) {\n                        s.unsubscribe();\n                    }\n                }\n            }));\n\n            // now that everything is hooked up let's subscribe\n            // as long as the subscription is not null (which can happen if already unsubscribed)\n            OriginSubscriber<T> os = requestHandler.state.getOrigin();\n            if (os != null) {\n                source.unsafeSubscribe(os);\n            }\n        }\n    }", "signature": "void connect(Action1<? super Subscription> connection)", "full_signature": "@Override public void connect(Action1<? super Subscription> connection)", "class_method_signature": "OperatorPublish.connect(Action1<? super Subscription> connection)", "testcase": false, "constructor": false, "invocations": ["getOrigin", "setOrigin", "call", "create", "getOrigin", "setOrigin", "unsubscribe", "getOrigin", "unsafeSubscribe"]}, "repository": {"repo_id": 33645537, "url": "https://github.com/zqhxuyuan/tutorials", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 5, "size": 35273, "license": "licensed"}}