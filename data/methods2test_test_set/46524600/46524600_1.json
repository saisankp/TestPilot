{"test_class": {"identifier": "TestBase64", "superclass": "", "interfaces": "", "fields": [{"original_string": "protected static final Encoder ENCODER = Base64.getEncoder();", "modifier": "protected static final", "type": "Encoder", "declarator": "ENCODER = Base64.getEncoder()", "var_name": "ENCODER"}, {"original_string": "protected static final String USERNAME = \"ihaveaverylongname@onaverylongdomain.withaverylongtld\";", "modifier": "protected static final", "type": "String", "declarator": "USERNAME = \"ihaveaverylongname@onaverylongdomain.withaverylongtld\"", "var_name": "USERNAME"}, {"original_string": "protected static final String PASSWORD = \"ohmypasswordislongtoo:abcdefghijklmnopqrstuvwxyz\";", "modifier": "protected static final", "type": "String", "declarator": "PASSWORD = \"ohmypasswordislongtoo:abcdefghijklmnopqrstuvwxyz\"", "var_name": "PASSWORD"}], "file": "nuxeo-java-client/src/test/java/org/nuxeo/client/util/TestBase64.java"}, "test_case": {"identifier": "testEncodeDoesNotBreakLine", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testEncodeDoesNotBreakLine() {\n\n        String info = USERNAME + \":\" + PASSWORD;\n        String formerToken = \"Basic \"\n                + org.nuxeo.client.util.Base64.encode(info, org.nuxeo.client.util.Base64.DONT_BREAK_LINES);\n        String token = \"Basic \" + ENCODER.encodeToString(info.getBytes(UTF_8));\n        assertEquals(token, formerToken);\n    }", "signature": "void testEncodeDoesNotBreakLine()", "full_signature": "@Test public void testEncodeDoesNotBreakLine()", "class_method_signature": "TestBase64.testEncodeDoesNotBreakLine()", "testcase": true, "constructor": false, "invocations": ["encode", "encodeToString", "getBytes", "assertEquals"]}, "focal_class": {"identifier": "Base64", "superclass": "", "interfaces": "", "fields": [{"original_string": "public final static int NO_OPTIONS = 0;", "modifier": "public final static", "type": "int", "declarator": "NO_OPTIONS = 0", "var_name": "NO_OPTIONS"}, {"original_string": "public final static int ENCODE = 1;", "modifier": "public final static", "type": "int", "declarator": "ENCODE = 1", "var_name": "ENCODE"}, {"original_string": "public final static int DECODE = 0;", "modifier": "public final static", "type": "int", "declarator": "DECODE = 0", "var_name": "DECODE"}, {"original_string": "public final static int GZIP = 2;", "modifier": "public final static", "type": "int", "declarator": "GZIP = 2", "var_name": "GZIP"}, {"original_string": "public final static int DONT_BREAK_LINES = 8;", "modifier": "public final static", "type": "int", "declarator": "DONT_BREAK_LINES = 8", "var_name": "DONT_BREAK_LINES"}, {"original_string": "private final static int MAX_LINE_LENGTH = 76;", "modifier": "private final static", "type": "int", "declarator": "MAX_LINE_LENGTH = 76", "var_name": "MAX_LINE_LENGTH"}, {"original_string": "private final static byte EQUALS_SIGN = (byte) '=';", "modifier": "private final static", "type": "byte", "declarator": "EQUALS_SIGN = (byte) '='", "var_name": "EQUALS_SIGN"}, {"original_string": "private final static byte NEW_LINE = (byte) '\\n';", "modifier": "private final static", "type": "byte", "declarator": "NEW_LINE = (byte) '\\n'", "var_name": "NEW_LINE"}, {"original_string": "private final static String PREFERRED_ENCODING = \"UTF-8\";", "modifier": "private final static", "type": "String", "declarator": "PREFERRED_ENCODING = \"UTF-8\"", "var_name": "PREFERRED_ENCODING"}, {"original_string": "private final static byte[] ALPHABET;", "modifier": "private final static", "type": "byte[]", "declarator": "ALPHABET", "var_name": "ALPHABET"}, {"original_string": "private final static byte[] _NATIVE_ALPHABET = /* May be something funny like EBCDIC */\n    { (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I',\n            (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R',\n            (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) 'a',\n            (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',\n            (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's',\n            (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y', (byte) 'z', (byte) '0', (byte) '1',\n            (byte) '2', (byte) '3', (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) '+',\n            (byte) '/' };", "modifier": "private final static", "type": "byte[]", "declarator": "_NATIVE_ALPHABET = /* May be something funny like EBCDIC */\n    { (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I',\n            (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R',\n            (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) 'a',\n            (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',\n            (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's',\n            (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y', (byte) 'z', (byte) '0', (byte) '1',\n            (byte) '2', (byte) '3', (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) '+',\n            (byte) '/' }", "var_name": "_NATIVE_ALPHABET"}, {"original_string": "private final static byte[] DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 0 - 8\n            -5, -5, // Whitespace: Tab and Linefeed\n            -9, -9, // Decimal 11 - 12\n            -5, // Whitespace: Carriage Return\n            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26\n            -9, -9, -9, -9, -9, // Decimal 27 - 31\n            -5, // Whitespace: Space\n            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42\n            62, // Plus sign at decimal 43\n            -9, -9, -9, // Decimal 44 - 46\n            63, // Slash at decimal 47\n            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine\n            -9, -9, -9, // Decimal 58 - 60\n            -1, // Equals sign at decimal 61\n            -9, -9, -9, // Decimal 62 - 64\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'\n            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'\n            -9, -9, -9, -9, -9, -9, // Decimal 91 - 96\n            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'\n            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'\n            -9, -9, -9, -9 // Decimal 123 - 126\n    /*\n     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal\n     * 140 - 152 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //\n     * Decimal 166 - 178 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191\n     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal\n     * 205 - 217 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //\n     * Decimal 231 - 243 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255\n     */\n    };", "modifier": "private final static", "type": "byte[]", "declarator": "DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 0 - 8\n            -5, -5, // Whitespace: Tab and Linefeed\n            -9, -9, // Decimal 11 - 12\n            -5, // Whitespace: Carriage Return\n            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26\n            -9, -9, -9, -9, -9, // Decimal 27 - 31\n            -5, // Whitespace: Space\n            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42\n            62, // Plus sign at decimal 43\n            -9, -9, -9, // Decimal 44 - 46\n            63, // Slash at decimal 47\n            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine\n            -9, -9, -9, // Decimal 58 - 60\n            -1, // Equals sign at decimal 61\n            -9, -9, -9, // Decimal 62 - 64\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'\n            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'\n            -9, -9, -9, -9, -9, -9, // Decimal 91 - 96\n            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'\n            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'\n            -9, -9, -9, -9 // Decimal 123 - 126\n    /*\n     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal\n     * 140 - 152 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //\n     * Decimal 166 - 178 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191\n     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal\n     * 205 - 217 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //\n     * Decimal 231 - 243 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255\n     */\n    }", "var_name": "DECODABET"}, {"original_string": "private final static byte WHITE_SPACE_ENC = -5;", "modifier": "private final static", "type": "byte", "declarator": "WHITE_SPACE_ENC = -5", "var_name": "WHITE_SPACE_ENC"}, {"original_string": "private final static byte EQUALS_SIGN_ENC = -1;", "modifier": "private final static", "type": "byte", "declarator": "EQUALS_SIGN_ENC = -1", "var_name": "EQUALS_SIGN_ENC"}], "methods": [{"identifier": "Base64", "parameters": "()", "modifiers": "private", "return": "", "signature": " Base64()", "full_signature": "private  Base64()", "class_method_signature": "Base64.Base64()", "testcase": false, "constructor": true}, {"identifier": "encode3to4", "parameters": "(byte[] b4, byte[] threeBytes, int numSigBytes)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] encode3to4(byte[] b4, byte[] threeBytes, int numSigBytes)", "full_signature": "private static byte[] encode3to4(byte[] b4, byte[] threeBytes, int numSigBytes)", "class_method_signature": "Base64.encode3to4(byte[] b4, byte[] threeBytes, int numSigBytes)", "testcase": false, "constructor": false}, {"identifier": "encode3to4", "parameters": "(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset)", "full_signature": "private static byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset)", "class_method_signature": "Base64.encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset)", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(byte[] bytes)", "modifiers": "public static", "return": "String", "signature": "String encode(byte[] bytes)", "full_signature": "public static String encode(byte[] bytes)", "class_method_signature": "Base64.encode(byte[] bytes)", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(String content)", "modifiers": "public static", "return": "String", "signature": "String encode(String content)", "full_signature": "public static String encode(String content)", "class_method_signature": "Base64.encode(String content)", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(String content, int options)", "modifiers": "public static", "return": "String", "signature": "String encode(String content, int options)", "full_signature": "public static String encode(String content, int options)", "class_method_signature": "Base64.encode(String content, int options)", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(String content, String charset)", "modifiers": "public static", "return": "String", "signature": "String encode(String content, String charset)", "full_signature": "public static String encode(String content, String charset)", "class_method_signature": "Base64.encode(String content, String charset)", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(String content, Charset charset)", "modifiers": "public static", "return": "String", "signature": "String encode(String content, Charset charset)", "full_signature": "public static String encode(String content, Charset charset)", "class_method_signature": "Base64.encode(String content, Charset charset)", "testcase": false, "constructor": false}, {"identifier": "encodeObject", "parameters": "(java.io.Serializable serializableObject)", "modifiers": "public static", "return": "String", "signature": "String encodeObject(java.io.Serializable serializableObject)", "full_signature": "public static String encodeObject(java.io.Serializable serializableObject)", "class_method_signature": "Base64.encodeObject(java.io.Serializable serializableObject)", "testcase": false, "constructor": false}, {"identifier": "encodeObject", "parameters": "(java.io.Serializable serializableObject, int options)", "modifiers": "public static", "return": "String", "signature": "String encodeObject(java.io.Serializable serializableObject, int options)", "full_signature": "public static String encodeObject(java.io.Serializable serializableObject, int options)", "class_method_signature": "Base64.encodeObject(java.io.Serializable serializableObject, int options)", "testcase": false, "constructor": false}, {"identifier": "encodeBytes", "parameters": "(byte[] source)", "modifiers": "public static", "return": "String", "signature": "String encodeBytes(byte[] source)", "full_signature": "public static String encodeBytes(byte[] source)", "class_method_signature": "Base64.encodeBytes(byte[] source)", "testcase": false, "constructor": false}, {"identifier": "encodeBytes", "parameters": "(byte[] source, int options)", "modifiers": "public static", "return": "String", "signature": "String encodeBytes(byte[] source, int options)", "full_signature": "public static String encodeBytes(byte[] source, int options)", "class_method_signature": "Base64.encodeBytes(byte[] source, int options)", "testcase": false, "constructor": false}, {"identifier": "encodeBytes", "parameters": "(byte[] source, int off, int len)", "modifiers": "public static", "return": "String", "signature": "String encodeBytes(byte[] source, int off, int len)", "full_signature": "public static String encodeBytes(byte[] source, int off, int len)", "class_method_signature": "Base64.encodeBytes(byte[] source, int off, int len)", "testcase": false, "constructor": false}, {"identifier": "encodeBytes", "parameters": "(byte[] source, int off, int len, int options)", "modifiers": "public static", "return": "String", "signature": "String encodeBytes(byte[] source, int off, int len, int options)", "full_signature": "public static String encodeBytes(byte[] source, int off, int len, int options)", "class_method_signature": "Base64.encodeBytes(byte[] source, int off, int len, int options)", "testcase": false, "constructor": false}, {"identifier": "decode4to3", "parameters": "(byte[] source, int srcOffset, byte[] destination, int destOffset)", "modifiers": "private static", "return": "int", "signature": "int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset)", "full_signature": "private static int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset)", "class_method_signature": "Base64.decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(byte[] source, int off, int len)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] decode(byte[] source, int off, int len)", "full_signature": "public static byte[] decode(byte[] source, int off, int len)", "class_method_signature": "Base64.decode(byte[] source, int off, int len)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(String s)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] decode(String s)", "full_signature": "public static byte[] decode(String s)", "class_method_signature": "Base64.decode(String s)", "testcase": false, "constructor": false}, {"identifier": "decodeToObject", "parameters": "(String encodedObject)", "modifiers": "public static", "return": "Object", "signature": "Object decodeToObject(String encodedObject)", "full_signature": "public static Object decodeToObject(String encodedObject)", "class_method_signature": "Base64.decodeToObject(String encodedObject)", "testcase": false, "constructor": false}, {"identifier": "encodeToFile", "parameters": "(byte[] dataToEncode, String filename)", "modifiers": "public static", "return": "boolean", "signature": "boolean encodeToFile(byte[] dataToEncode, String filename)", "full_signature": "public static boolean encodeToFile(byte[] dataToEncode, String filename)", "class_method_signature": "Base64.encodeToFile(byte[] dataToEncode, String filename)", "testcase": false, "constructor": false}, {"identifier": "decodeToFile", "parameters": "(String dataToDecode, String filename)", "modifiers": "public static", "return": "boolean", "signature": "boolean decodeToFile(String dataToDecode, String filename)", "full_signature": "public static boolean decodeToFile(String dataToDecode, String filename)", "class_method_signature": "Base64.decodeToFile(String dataToDecode, String filename)", "testcase": false, "constructor": false}, {"identifier": "decodeFromFile", "parameters": "(String filename)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] decodeFromFile(String filename)", "full_signature": "public static byte[] decodeFromFile(String filename)", "class_method_signature": "Base64.decodeFromFile(String filename)", "testcase": false, "constructor": false}, {"identifier": "encodeFromFile", "parameters": "(String filename)", "modifiers": "public static", "return": "String", "signature": "String encodeFromFile(String filename)", "full_signature": "public static String encodeFromFile(String filename)", "class_method_signature": "Base64.encodeFromFile(String filename)", "testcase": false, "constructor": false}], "file": "nuxeo-java-client/src/main/java/org/nuxeo/client/util/Base64.java"}, "focal_method": {"identifier": "encode", "parameters": "(byte[] bytes)", "modifiers": "public static", "return": "String", "body": "public static String encode(byte[] bytes) {\n        return encodeBytes(bytes);\n    }", "signature": "String encode(byte[] bytes)", "full_signature": "public static String encode(byte[] bytes)", "class_method_signature": "Base64.encode(byte[] bytes)", "testcase": false, "constructor": false, "invocations": ["encodeBytes"]}, "repository": {"repo_id": 46524600, "url": "https://github.com/nuxeo/nuxeo-java-client", "language": "Java", "is_fork": false, "fork_count": 16, "stargazer_count": 10, "size": 7849, "license": "licensed"}}