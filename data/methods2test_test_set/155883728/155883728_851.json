{"test_class": {"identifier": "ExpectAcesTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final NamePathResolver resolver = new DefaultNamePathResolver(JsonCnd.BUILTIN_MAPPINGS);", "modifier": "private final", "type": "NamePathResolver", "declarator": "resolver = new DefaultNamePathResolver(JsonCnd.BUILTIN_MAPPINGS)", "var_name": "resolver"}, {"original_string": "static final Privilege[] emptyPrivileges = new Privilege[0];", "modifier": "static final", "type": "Privilege[]", "declarator": "emptyPrivileges = new Privilege[0]", "var_name": "emptyPrivileges"}], "file": "core/src/test/java/net/adamcin/oakpal/core/checks/ExpectAcesTest.java"}, "test_case": {"identifier": "testSuppressAfterExtractViolationIfExpectationSatisfiedAfterScanPackage_multipleViolators", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSuppressAfterExtractViolationIfExpectationSatisfiedAfterScanPackage_multipleViolators() throws Exception {\n        final String foo1 = \"/foo1\";\n        final String foo2 = \"/foo2\";\n\n        final PackageId container = PackageId.fromString(\"container\");\n        final PackageId embed1 = PackageId.fromString(\"embed1\");\n        SlingInstallable installable1 = mock(SlingInstallable.class);\n        when(installable1.getParentId()).thenReturn(embed1);\n        EmbeddedPackageInstallable epInstallable1 = new EmbeddedPackageInstallable(container, \"\", embed1);\n        final PackageId embed2 = PackageId.fromString(\"embed2\");\n        SlingInstallable installable2 = mock(SlingInstallable.class);\n        when(installable2.getParentId()).thenReturn(embed2);\n        EmbeddedPackageInstallable epInstallable2 = new EmbeddedPackageInstallable(container, \"\", embed2);\n        final PackageId embed3 = PackageId.fromString(\"embed3\");\n        SlingInstallable installable3 = mock(SlingInstallable.class);\n        when(installable3.getParentId()).thenReturn(embed3);\n        EmbeddedPackageInstallable epInstallable3 = new EmbeddedPackageInstallable(container, \"\", embed3);\n\n        final Principal principal = new PrincipalImpl(\"nouser\");\n        final List<String> repoInits = Arrays.asList(\n                \"create service user nouser\",\n                \"create path (nt:folder) /foo1\",\n                \"set ACL on /foo1\",\n                \"  allow jcr:read for nouser\",\n                \"end\",\n                \"create path (nt:folder) /foo2\",\n                \"set ACL on /foo2\",\n                \"  allow jcr:read for nouser\",\n                \"end\"\n        );\n\n        final ExpectAces.Check check1 = checkFor(obj()\n                .key(ExpectAces.keys().principal(), \"nouser\")\n                .key(ExpectAces.keys().expectedAces(), arr()\n                        .val(\"type=allow;path=/foo1;privileges=jcr:read\")\n                        .val(\"type=allow;path=/foo1;privileges=rep:write\")\n                )\n                .get());\n        new OakpalPlan.Builder(null, null)\n                .withRepoInits(repoInits)\n                .build().toOakMachineBuilder(null, getClass().getClassLoader()).build()\n                .adminInitAndInspect(session -> {\n\n                    check1.startedScan();\n                    check1.identifyPackage(container, null);\n                    check1.afterExtract(container, session);\n                    check1.beforeSlingInstall(container, epInstallable1, session);\n                    check1.identifyEmbeddedPackage(embed1, container, epInstallable1);\n                    check1.afterExtract(embed1, session);\n                    check1.beforeSlingInstall(container, epInstallable2, session);\n                    check1.identifyEmbeddedPackage(embed2, container, epInstallable2);\n                    check1.afterExtract(embed2, session);\n                    check1.beforeSlingInstall(container, epInstallable3, session);\n                    check1.identifyEmbeddedPackage(embed3, container, epInstallable3);\n                    check1.afterExtract(embed3, session);\n                    check1.beforeSlingInstall(container, installable1, session);\n                    check1.beforeSlingInstall(container, installable2, session);\n                    check1.beforeSlingInstall(container, installable3, session);\n                    check1.afterScanPackage(container, session);\n                    check1.finishedScan();\n                });\n\n        Assert.assertEquals(\"expected violation count\", 1,\n                check1.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"expected: \")).count());\n        Assert.assertEquals(\"expected violated spec ends with rep:write\", 1,\n                check1.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"expected: \")\n                                && viol.getDescription().contains(\"/foo1\")\n                                && viol.getDescription().endsWith(\"rep:write\")).count());\n        Assert.assertEquals(\"no unexpected violations\", 0,\n                check1.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"unexpected: \")).count());\n        final Violation exViolation1 = check1.getReportedViolations().stream().findFirst().get();\n        assertEquals(\"expected violators\",\n                Stream.of(container).collect(Collectors.toSet()),\n                new HashSet<>(exViolation1.getPackages()));\n\n        new OakpalPlan.Builder(null, null)\n                .withRepoInits(repoInits)\n                .build().toOakMachineBuilder(null, getClass().getClassLoader()).build()\n                .adminInitAndInspect(session -> {\n                    check1.startedScan();\n                    check1.identifyPackage(container, null);\n                    check1.afterExtract(container, session);\n                    check1.beforeSlingInstall(container, epInstallable1, session);\n                    check1.identifyEmbeddedPackage(embed1, container, epInstallable1);\n                    resetAcl(session.getNode(foo1), (acl, privMan) -> {\n                        Stream.of(acl.getAccessControlEntries())\n                                .filter(composeTest1(AccessControlEntry::getPrincipal, principal::equals))\n                                .forEachOrdered(uncheckVoid1(acl::removeAccessControlEntry));\n                        acl.addEntry(principal, new Privilege[]{privMan.getPrivilege(\"rep:write\")}, true);\n                    });\n                    check1.afterExtract(embed1, session);\n                    check1.beforeSlingInstall(container, epInstallable2, session);\n                    check1.identifyEmbeddedPackage(embed2, container, epInstallable2);\n                    check1.afterExtract(embed2, session);\n                    check1.beforeSlingInstall(container, epInstallable3, session);\n                    check1.identifyEmbeddedPackage(embed3, container, epInstallable3);\n                    check1.afterExtract(embed3, session);\n                    check1.beforeSlingInstall(container, installable1, session);\n                    check1.beforeSlingInstall(container, installable2, session);\n                    check1.beforeSlingInstall(container, installable3, session);\n                    check1.afterScanPackage(container, session);\n                    check1.finishedScan();\n                });\n\n        Assert.assertEquals(\"expected violation count\", 1,\n                check1.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"expected: \")).count());\n        Assert.assertEquals(\"expected violated spec ends with jcr:read\", 1,\n                check1.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"expected: \")\n                                && viol.getDescription().contains(\"/foo1\")\n                                && viol.getDescription().endsWith(\"jcr:read\")).count());\n        Assert.assertEquals(\"no unexpected violations\", 0,\n                check1.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"unexpected: \")).count());\n        final Violation exViolation2 = check1.getReportedViolations().stream().findFirst().get();\n        assertEquals(\"expected violators\",\n                Stream.of(embed1, container).collect(Collectors.toSet()),\n                new HashSet<>(exViolation2.getPackages()));\n\n        final ExpectAces.Check check2 = checkFor(obj()\n                .key(ExpectAces.keys().principal(), \"nouser\")\n                .key(ExpectAces.keys().notExpectedAces(), arr()\n                        .val(\"type=allow;path=/foo2;privileges=jcr:read\")\n                        .val(\"type=allow;path=/foo2;privileges=rep:write\")\n                        // foo3 is not created. a non-existent path should satisfy not-expected aces\n                        .val(\"type=allow;path=/foo3;privileges=rep:write\")\n                )\n                .get());\n        new OakpalPlan.Builder(null, null)\n                .withRepoInits(repoInits)\n                .build().toOakMachineBuilder(null, getClass().getClassLoader()).build()\n                .adminInitAndInspect(session -> {\n                    check2.startedScan();\n                    check2.identifyPackage(container, null);\n                    check2.afterExtract(container, session);\n                    check2.beforeSlingInstall(embed1, epInstallable1, session);\n                    check2.identifyEmbeddedPackage(embed1, container, epInstallable1);\n                    check2.afterExtract(embed1, session);\n                    check2.beforeSlingInstall(embed2, epInstallable2, session);\n                    check2.identifyEmbeddedPackage(embed2, container, epInstallable2);\n                    check2.afterExtract(embed2, session);\n                    check2.beforeSlingInstall(embed3, epInstallable3, session);\n                    check2.identifyEmbeddedPackage(embed3, container, epInstallable3);\n                    check2.afterExtract(embed3, session);\n                    check2.beforeSlingInstall(container, installable1, session);\n                    check2.beforeSlingInstall(container, installable2, session);\n                    check2.beforeSlingInstall(container, installable3, session);\n                    check2.afterScanPackage(container, session);\n                    check2.finishedScan();\n                });\n\n        Assert.assertEquals(\"unexpected violation count\", 1,\n                check2.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"unexpected: \")).count());\n        Assert.assertEquals(\"unexpected violated spec ends with jcr:read\", 1,\n                check2.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"unexpected: \")\n                                && viol.getDescription().contains(\"/foo2\")\n                                && viol.getDescription().endsWith(\"jcr:read\")).count());\n        Assert.assertEquals(\"no expected violations\", 0,\n                check2.getReportedViolations().stream()\n                        .filter(viol -> viol.getDescription().startsWith(\"expected: \")).count());\n        final Violation unViolation1 = check2.getReportedViolations().stream().findFirst().get();\n        assertEquals(\"expected violators\",\n                Stream.of(container).collect(Collectors.toSet()),\n                new HashSet<>(unViolation1.getPackages()));\n\n        new OakpalPlan.Builder(null, null)\n                .withRepoInits(repoInits)\n                .build().toOakMachineBuilder(null, getClass().getClassLoader()).build()\n                .adminInitAndInspect(session -> {\n                    check2.startedScan();\n                    check2.identifyPackage(container, null);\n                    resetAcl(session.getNode(foo2), (acl, priv) -> {\n                        Stream.of(acl.getAccessControlEntries())\n                                .forEachOrdered(uncheckVoid1(acl::removeAccessControlEntry));\n                    });\n                    check2.afterExtract(container, session);\n                    check2.beforeSlingInstall(embed1, epInstallable1, session);\n                    check2.identifyEmbeddedPackage(embed1, container, epInstallable1);\n                    resetAcl(session.getNode(foo2), (acl, priv) -> {\n                        acl.addEntry(principal, Stream.of(\"rep:write\")\n                                .map(uncheck1(priv::getPrivilege)).toArray(Privilege[]::new), true);\n                    });\n                    check2.afterExtract(embed1, session);\n                    check2.beforeSlingInstall(embed2, epInstallable2, session);\n                    check2.identifyEmbeddedPackage(embed2, container, epInstallable2);\n                    check2.afterExtract(embed2, session);\n                    check2.beforeSlingInstall(embed3, epInstallable3, session);\n                    check2.identifyEmbeddedPackage(embed3, container, epInstallable3);\n                    session.getNode(foo2).remove();\n                    check2.afterExtract(embed3, session);\n                    check2.beforeSlingInstall(container, installable1, session);\n                    check2.beforeSlingInstall(container, installable2, session);\n                    Node node3 = JcrUtils.getOrCreateByPath(\"/foo3\", \"nt:folder\", session);\n                    resetAcl(node3, (acl, priv) -> {\n                        acl.addEntry(principal, new Privilege[]{priv.getPrivilege(\"rep:write\")}, true);\n                    });\n                    check2.appliedRepoInitScripts(container, Collections.emptyList(), installable2, session);\n                    check2.beforeSlingInstall(container, installable3, session);\n                    check2.afterScanPackage(container, session);\n                    check2.finishedScan();\n                });\n\n\n        assertEquals(\"expect 2 unexpected violations\", 2, check2.getReportedViolations().size());\n        final Collection<Violation> unViolations = check2.getReportedViolations();\n        assertTrue(\"all start with unexpected \" + unViolations, unViolations.stream()\n                .allMatch(vio -> vio.getDescription().startsWith(\"unexpected: \")));\n        assertEquals(\"one contains /foo2: \" + unViolations, 1, unViolations.stream()\n                .filter(vio -> vio.getDescription().contains(\"/foo2\")).count());\n        assertEquals(\"one contains /foo3: \" + unViolations, 1, unViolations.stream()\n                .filter(vio -> vio.getDescription().contains(\"/foo3\")).count());\n        assertEquals(\"expected violators of /foo2\",\n                Stream.of(embed1).collect(Collectors.toSet()), unViolations.stream()\n                        .filter(vio -> vio.getDescription().contains(\"/foo2\"))\n                        .flatMap(Fun.compose1(Violation::getPackages, Collection::stream))\n                        .collect(Collectors.toSet()));\n        assertEquals(\"expected violators of /foo3\",\n                Stream.of(embed2, container).collect(Collectors.toSet()), unViolations.stream()\n                        .filter(vio -> vio.getDescription().contains(\"/foo3\"))\n                        .flatMap(Fun.compose1(Violation::getPackages, Collection::stream))\n                        .collect(Collectors.toSet()));\n\n    }", "signature": "void testSuppressAfterExtractViolationIfExpectationSatisfiedAfterScanPackage_multipleViolators()", "full_signature": "@Test public void testSuppressAfterExtractViolationIfExpectationSatisfiedAfterScanPackage_multipleViolators()", "class_method_signature": "ExpectAcesTest.testSuppressAfterExtractViolationIfExpectationSatisfiedAfterScanPackage_multipleViolators()", "testcase": true, "constructor": false, "invocations": ["fromString", "fromString", "mock", "thenReturn", "when", "getParentId", "fromString", "mock", "thenReturn", "when", "getParentId", "fromString", "mock", "thenReturn", "when", "getParentId", "asList", "checkFor", "get", "key", "key", "obj", "principal", "keys", "expectedAces", "keys", "val", "val", "arr", "adminInitAndInspect", "build", "toOakMachineBuilder", "build", "withRepoInits", "getClassLoader", "getClass", "startedScan", "identifyPackage", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "afterExtract", "beforeSlingInstall", "beforeSlingInstall", "beforeSlingInstall", "afterScanPackage", "finishedScan", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "contains", "getDescription", "endsWith", "getDescription", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "get", "findFirst", "stream", "getReportedViolations", "assertEquals", "collect", "of", "toSet", "getPackages", "adminInitAndInspect", "build", "toOakMachineBuilder", "build", "withRepoInits", "getClassLoader", "getClass", "startedScan", "identifyPackage", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "resetAcl", "getNode", "forEachOrdered", "filter", "of", "getAccessControlEntries", "composeTest1", "uncheckVoid1", "addEntry", "getPrivilege", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "afterExtract", "beforeSlingInstall", "beforeSlingInstall", "beforeSlingInstall", "afterScanPackage", "finishedScan", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "contains", "getDescription", "endsWith", "getDescription", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "get", "findFirst", "stream", "getReportedViolations", "assertEquals", "collect", "of", "toSet", "getPackages", "checkFor", "get", "key", "key", "obj", "principal", "keys", "notExpectedAces", "keys", "val", "val", "val", "arr", "adminInitAndInspect", "build", "toOakMachineBuilder", "build", "withRepoInits", "getClassLoader", "getClass", "startedScan", "identifyPackage", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "afterExtract", "beforeSlingInstall", "beforeSlingInstall", "beforeSlingInstall", "afterScanPackage", "finishedScan", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "contains", "getDescription", "endsWith", "getDescription", "assertEquals", "count", "filter", "stream", "getReportedViolations", "startsWith", "getDescription", "get", "findFirst", "stream", "getReportedViolations", "assertEquals", "collect", "of", "toSet", "getPackages", "adminInitAndInspect", "build", "toOakMachineBuilder", "build", "withRepoInits", "getClassLoader", "getClass", "startedScan", "identifyPackage", "resetAcl", "getNode", "forEachOrdered", "of", "getAccessControlEntries", "uncheckVoid1", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "resetAcl", "getNode", "addEntry", "toArray", "map", "of", "uncheck1", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "afterExtract", "beforeSlingInstall", "identifyEmbeddedPackage", "remove", "getNode", "afterExtract", "beforeSlingInstall", "beforeSlingInstall", "getOrCreateByPath", "resetAcl", "addEntry", "getPrivilege", "appliedRepoInitScripts", "emptyList", "beforeSlingInstall", "afterScanPackage", "finishedScan", "assertEquals", "size", "getReportedViolations", "getReportedViolations", "assertTrue", "allMatch", "stream", "startsWith", "getDescription", "assertEquals", "count", "filter", "stream", "contains", "getDescription", "assertEquals", "count", "filter", "stream", "contains", "getDescription", "assertEquals", "collect", "of", "toSet", "collect", "flatMap", "filter", "stream", "contains", "getDescription", "compose1", "toSet", "assertEquals", "collect", "of", "toSet", "collect", "flatMap", "filter", "stream", "contains", "getDescription", "compose1", "toSet"]}, "focal_class": {"identifier": "ExpectAces", "superclass": "", "interfaces": "implements ProgressCheckFactory", "fields": [{"original_string": "private static final JsonKeys KEYS = new JsonKeys() {\n        @Override\n        public String principal() {\n            return \"principal\";\n        }\n\n        @Override\n        public String principals() {\n            return \"principals\";\n        }\n\n        @Override\n        public String expectedAces() {\n            return \"expectedAces\";\n        }\n\n        @Override\n        public String notExpectedAces() {\n            return \"notExpectedAces\";\n        }\n\n        @Override\n        public String afterPackageIdRules() {\n            return \"afterPackageIdRules\";\n        }\n\n        @Override\n        public String severity() {\n            return \"severity\";\n        }\n\n        @Override\n        public String type() {\n            return \"type\";\n        }\n\n        @Override\n        public String privileges() {\n            return \"privileges\";\n        }\n\n        @Override\n        public String path() {\n            return \"path\";\n        }\n    };", "modifier": "private static final", "type": "JsonKeys", "declarator": "KEYS = new JsonKeys() {\n        @Override\n        public String principal() {\n            return \"principal\";\n        }\n\n        @Override\n        public String principals() {\n            return \"principals\";\n        }\n\n        @Override\n        public String expectedAces() {\n            return \"expectedAces\";\n        }\n\n        @Override\n        public String notExpectedAces() {\n            return \"notExpectedAces\";\n        }\n\n        @Override\n        public String afterPackageIdRules() {\n            return \"afterPackageIdRules\";\n        }\n\n        @Override\n        public String severity() {\n            return \"severity\";\n        }\n\n        @Override\n        public String type() {\n            return \"type\";\n        }\n\n        @Override\n        public String privileges() {\n            return \"privileges\";\n        }\n\n        @Override\n        public String path() {\n            return \"path\";\n        }\n    }", "var_name": "KEYS"}, {"original_string": "@Deprecated\n    public static final String CONFIG_PRINCIPAL = keys().principal();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "CONFIG_PRINCIPAL = keys().principal()", "var_name": "CONFIG_PRINCIPAL"}, {"original_string": "@Deprecated\n    public static final String CONFIG_PRINCIPALS = keys().principals();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "CONFIG_PRINCIPALS = keys().principals()", "var_name": "CONFIG_PRINCIPALS"}, {"original_string": "@Deprecated\n    public static final String CONFIG_EXPECTED_ACES = keys().expectedAces();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "CONFIG_EXPECTED_ACES = keys().expectedAces()", "var_name": "CONFIG_EXPECTED_ACES"}, {"original_string": "@Deprecated\n    public static final String CONFIG_NOT_EXPECTED_ACES = keys().notExpectedAces();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "CONFIG_NOT_EXPECTED_ACES = keys().notExpectedAces()", "var_name": "CONFIG_NOT_EXPECTED_ACES"}, {"original_string": "@Deprecated\n    public static final String CONFIG_AFTER_PACKAGE_ID_RULES = keys().afterPackageIdRules();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "CONFIG_AFTER_PACKAGE_ID_RULES = keys().afterPackageIdRules()", "var_name": "CONFIG_AFTER_PACKAGE_ID_RULES"}, {"original_string": "@Deprecated\n    public static final String ACE_PARAM_TYPE = keys().type();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "ACE_PARAM_TYPE = keys().type()", "var_name": "ACE_PARAM_TYPE"}, {"original_string": "@Deprecated\n    public static final String ACE_PARAM_PRIVILEGES = keys().privileges();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "ACE_PARAM_PRIVILEGES = keys().privileges()", "var_name": "ACE_PARAM_PRIVILEGES"}, {"original_string": "@Deprecated\n    public static final String ACE_PARAM_PATH = keys().path();", "modifier": "@Deprecated\n    public static final", "type": "String", "declarator": "ACE_PARAM_PATH = keys().path()", "var_name": "ACE_PARAM_PATH"}, {"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ExpectAces.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ExpectAces.class)", "var_name": "LOGGER"}, {"original_string": "static final Severity DEFAULT_SEVERITY = Severity.MAJOR;", "modifier": "static final", "type": "Severity", "declarator": "DEFAULT_SEVERITY = Severity.MAJOR", "var_name": "DEFAULT_SEVERITY"}, {"original_string": "public static final String DELIM_PARAM = \";\";", "modifier": "public static final", "type": "String", "declarator": "DELIM_PARAM = \";\"", "var_name": "DELIM_PARAM"}, {"original_string": "public static final String DELIM_VALUE = \"=\";", "modifier": "public static final", "type": "String", "declarator": "DELIM_VALUE = \"=\"", "var_name": "DELIM_VALUE"}, {"original_string": "public static final String DELIM_LIST = \",\";", "modifier": "public static final", "type": "String", "declarator": "DELIM_LIST = \",\"", "var_name": "DELIM_LIST"}], "methods": [{"identifier": "keys", "parameters": "()", "modifiers": "@NotNull public static", "return": "JsonKeys", "signature": "JsonKeys keys()", "full_signature": "@NotNull public static JsonKeys keys()", "class_method_signature": "ExpectAces.keys()", "testcase": false, "constructor": false}, {"identifier": "newInstance", "parameters": "(final JsonObject config)", "modifiers": "@Override public", "return": "ProgressCheck", "signature": "ProgressCheck newInstance(final JsonObject config)", "full_signature": "@Override public ProgressCheck newInstance(final JsonObject config)", "class_method_signature": "ExpectAces.newInstance(final JsonObject config)", "testcase": false, "constructor": false}, {"identifier": "isPrincipalSpec", "parameters": "(final @NotNull String spec)", "modifiers": "static", "return": "boolean", "signature": "boolean isPrincipalSpec(final @NotNull String spec)", "full_signature": "static boolean isPrincipalSpec(final @NotNull String spec)", "class_method_signature": "ExpectAces.isPrincipalSpec(final @NotNull String spec)", "testcase": false, "constructor": false}, {"identifier": "isGeneralSpec", "parameters": "(final @NotNull String spec)", "modifiers": "static", "return": "boolean", "signature": "boolean isGeneralSpec(final @NotNull String spec)", "full_signature": "static boolean isGeneralSpec(final @NotNull String spec)", "class_method_signature": "ExpectAces.isGeneralSpec(final @NotNull String spec)", "testcase": false, "constructor": false}, {"identifier": "parseAceCriteria", "parameters": "(final @NotNull JsonObject config,\n                                              final @NotNull String[] principals,\n                                              final @NotNull String key)", "modifiers": "static", "return": "List<AceCriteria>", "signature": "List<AceCriteria> parseAceCriteria(final @NotNull JsonObject config,\n                                              final @NotNull String[] principals,\n                                              final @NotNull String key)", "full_signature": "static List<AceCriteria> parseAceCriteria(final @NotNull JsonObject config,\n                                              final @NotNull String[] principals,\n                                              final @NotNull String key)", "class_method_signature": "ExpectAces.parseAceCriteria(final @NotNull JsonObject config,\n                                              final @NotNull String[] principals,\n                                              final @NotNull String key)", "testcase": false, "constructor": false}, {"identifier": "restrictionMatcher", "parameters": "(final @NotNull JackrabbitAccessControlList acl,\n                       final @NotNull RestrictionCriteria[] restrictionCriterias)", "modifiers": "static", "return": "Predicate<JackrabbitAccessControlEntry>", "signature": "Predicate<JackrabbitAccessControlEntry> restrictionMatcher(final @NotNull JackrabbitAccessControlList acl,\n                       final @NotNull RestrictionCriteria[] restrictionCriterias)", "full_signature": "static Predicate<JackrabbitAccessControlEntry> restrictionMatcher(final @NotNull JackrabbitAccessControlList acl,\n                       final @NotNull RestrictionCriteria[] restrictionCriterias)", "class_method_signature": "ExpectAces.restrictionMatcher(final @NotNull JackrabbitAccessControlList acl,\n                       final @NotNull RestrictionCriteria[] restrictionCriterias)", "testcase": false, "constructor": false}], "file": "core/src/main/java/net/adamcin/oakpal/core/checks/ExpectAces.java"}, "focal_method": {"identifier": "keys", "parameters": "()", "modifiers": "@NotNull public static", "return": "JsonKeys", "body": "@NotNull\n    public static JsonKeys keys() {\n        return KEYS;\n    }", "signature": "JsonKeys keys()", "full_signature": "@NotNull public static JsonKeys keys()", "class_method_signature": "ExpectAces.keys()", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 155883728, "url": "https://github.com/adamcin/oakpal", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 6, "size": 13349, "license": "licensed"}}