{"test_class": {"identifier": "LTMTopicMapWriterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final static String testdataDirectory = \"ltmWriter\";", "modifier": "private final static", "type": "String", "declarator": "testdataDirectory = \"ltmWriter\"", "var_name": "testdataDirectory"}, {"original_string": "private TopicMapBuilderIF builder;", "modifier": "private", "type": "TopicMapBuilderIF", "declarator": "builder", "var_name": "builder"}, {"original_string": "private TopicMapIF tm;", "modifier": "private", "type": "TopicMapIF", "declarator": "tm", "var_name": "tm"}], "file": "ontopia-engine/src/test/java/net/ontopia/topicmaps/utils/ltm/LTMTopicMapWriterTest.java"}, "test_case": {"identifier": "testBadId", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testBadId() throws IOException {\n    LocatorIF base = new URILocator(\"http://example.com\");\n    TopicIF topic = builder.makeTopic();\n    topic.addItemIdentifier(base.resolveAbsolute(\"#22\"));\n    \n    String root = TestFileUtils.getTestdataOutputDirectory();\n    TestFileUtils.verifyDirectory(root, testdataDirectory);\n    String thebase = root + File.separator + testdataDirectory + File.separator;\n    TestFileUtils.verifyDirectory(thebase, \"out\");\n    File file = new File(thebase + File.separator + \"out\" + File.separator +\n      \"testBadId.ltm\");\n    \n    new LTMTopicMapWriter(file).write(tm);\n\n    tm = new LTMTopicMapReader(file).read();\n    topic = (TopicIF) tm.getTopics().iterator().next();\n    LocatorIF itemid = (LocatorIF) topic.getItemIdentifiers().iterator().next();\n    Assert.assertTrue(\"Bad item ID was not filtered out\",\n               itemid.getAddress().endsWith(\"testBadId.ltm#id1\"));\n  }", "signature": "void testBadId()", "full_signature": "@Test public void testBadId()", "class_method_signature": "LTMTopicMapWriterTest.testBadId()", "testcase": true, "constructor": false, "invocations": ["makeTopic", "addItemIdentifier", "resolveAbsolute", "getTestdataOutputDirectory", "verifyDirectory", "verifyDirectory", "write", "read", "next", "iterator", "getTopics", "next", "iterator", "getItemIdentifiers", "assertTrue", "endsWith", "getAddress"]}, "focal_class": {"identifier": "LTMTopicMapWriter", "superclass": "", "interfaces": "implements TopicMapWriterIF", "fields": [{"original_string": "private static final String COLON = \" : \";", "modifier": "private static final", "type": "String", "declarator": "COLON = \" : \"", "var_name": "COLON"}, {"original_string": "public static final String PROPERTY_PREFIXES = \"prefixes\";", "modifier": "public static final", "type": "String", "declarator": "PROPERTY_PREFIXES = \"prefixes\"", "var_name": "PROPERTY_PREFIXES"}, {"original_string": "public static final String PROPERTY_FILTER = \"filter\";", "modifier": "public static final", "type": "String", "declarator": "PROPERTY_FILTER = \"filter\"", "var_name": "PROPERTY_FILTER"}, {"original_string": "public static final String PROPERTY_PRESERVE_IDS = \"preserveIds\";", "modifier": "public static final", "type": "String", "declarator": "PROPERTY_PRESERVE_IDS = \"preserveIds\"", "var_name": "PROPERTY_PRESERVE_IDS"}, {"original_string": "private static final Logger log = LoggerFactory.getLogger(LTMTopicMapWriter.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(LTMTopicMapWriter.class.getName())", "var_name": "log"}, {"original_string": "protected String encoding;", "modifier": "protected", "type": "String", "declarator": "encoding", "var_name": "encoding"}, {"original_string": "protected boolean preserveIds;", "modifier": "protected", "type": "boolean", "declarator": "preserveIds", "var_name": "preserveIds"}, {"original_string": "protected Map<String, Integer> roleCounter;", "modifier": "protected", "type": "Map<String, Integer>", "declarator": "roleCounter", "var_name": "roleCounter"}, {"original_string": "protected Map<String, Boolean> rolesCounted;", "modifier": "protected", "type": "Map<String, Boolean>", "declarator": "rolesCounted", "var_name": "rolesCounted"}, {"original_string": "protected Writer out;", "modifier": "protected", "type": "Writer", "declarator": "out", "var_name": "out"}, {"original_string": "protected boolean closeWriter = false;", "modifier": "protected", "type": "boolean", "declarator": "closeWriter = false", "var_name": "closeWriter"}, {"original_string": "protected Calendar calendar;", "modifier": "protected", "type": "Calendar", "declarator": "calendar", "var_name": "calendar"}, {"original_string": "protected String base;", "modifier": "protected", "type": "String", "declarator": "base", "var_name": "base"}, {"original_string": "protected DeciderIF<Object> filter;", "modifier": "protected", "type": "DeciderIF<Object>", "declarator": "filter", "var_name": "filter"}, {"original_string": "protected Comparator<AssociationIF> associationComparator;", "modifier": "protected", "type": "Comparator<AssociationIF>", "declarator": "associationComparator", "var_name": "associationComparator"}, {"original_string": "protected Comparator<TopicNameIF> baseNameComparator;", "modifier": "protected", "type": "Comparator<TopicNameIF>", "declarator": "baseNameComparator", "var_name": "baseNameComparator"}, {"original_string": "protected Comparator<TopicIF> elementIdComparator;", "modifier": "protected", "type": "Comparator<TopicIF>", "declarator": "elementIdComparator", "var_name": "elementIdComparator"}, {"original_string": "protected Comparator<AssociationIF> supersubComparator;", "modifier": "protected", "type": "Comparator<AssociationIF>", "declarator": "supersubComparator", "var_name": "supersubComparator"}, {"original_string": "protected Comparator<AssociationRoleIF> supersubRoleComparator;", "modifier": "protected", "type": "Comparator<AssociationRoleIF>", "declarator": "supersubRoleComparator", "var_name": "supersubRoleComparator"}, {"original_string": "protected Comparator<OccurrenceIF> occurrenceComparator;", "modifier": "protected", "type": "Comparator<OccurrenceIF>", "declarator": "occurrenceComparator", "var_name": "occurrenceComparator"}, {"original_string": "protected Comparator<Collection<TopicIF>> reifierComparator;", "modifier": "protected", "type": "Comparator<Collection<TopicIF>>", "declarator": "reifierComparator", "var_name": "reifierComparator"}, {"original_string": "protected Comparator<AssociationRoleIF> roleComparator;", "modifier": "protected", "type": "Comparator<AssociationRoleIF>", "declarator": "roleComparator", "var_name": "roleComparator"}, {"original_string": "protected Comparator<Collection<TopicIF>> scopeComparator;", "modifier": "protected", "type": "Comparator<Collection<TopicIF>>", "declarator": "scopeComparator", "var_name": "scopeComparator"}, {"original_string": "protected Comparator<TopicIF> topicComparator;", "modifier": "protected", "type": "Comparator<TopicIF>", "declarator": "topicComparator", "var_name": "topicComparator"}, {"original_string": "protected Comparator<VariantNameIF> variantComparator;", "modifier": "protected", "type": "Comparator<VariantNameIF>", "declarator": "variantComparator", "var_name": "variantComparator"}, {"original_string": "protected IdManager idManager;", "modifier": "protected", "type": "IdManager", "declarator": "idManager", "var_name": "idManager"}, {"original_string": "protected String groupString1;", "modifier": "protected", "type": "String", "declarator": "groupString1", "var_name": "groupString1"}, {"original_string": "private Map<String, String> prefixes = new HashMap<String, String>();", "modifier": "private", "type": "Map<String, String>", "declarator": "prefixes = new HashMap<String, String>()", "var_name": "prefixes"}], "methods": [{"identifier": "LTMTopicMapWriter", "parameters": "(File file)", "modifiers": "public", "return": "", "signature": " LTMTopicMapWriter(File file)", "full_signature": "public  LTMTopicMapWriter(File file)", "class_method_signature": "LTMTopicMapWriter.LTMTopicMapWriter(File file)", "testcase": false, "constructor": true}, {"identifier": "LTMTopicMapWriter", "parameters": "(File file, String encoding)", "modifiers": "public", "return": "", "signature": " LTMTopicMapWriter(File file, String encoding)", "full_signature": "public  LTMTopicMapWriter(File file, String encoding)", "class_method_signature": "LTMTopicMapWriter.LTMTopicMapWriter(File file, String encoding)", "testcase": false, "constructor": true}, {"identifier": "LTMTopicMapWriter", "parameters": "(OutputStream stream)", "modifiers": "public", "return": "", "signature": " LTMTopicMapWriter(OutputStream stream)", "full_signature": "public  LTMTopicMapWriter(OutputStream stream)", "class_method_signature": "LTMTopicMapWriter.LTMTopicMapWriter(OutputStream stream)", "testcase": false, "constructor": true}, {"identifier": "LTMTopicMapWriter", "parameters": "(OutputStream stream, String encoding)", "modifiers": "public", "return": "", "signature": " LTMTopicMapWriter(OutputStream stream, String encoding)", "full_signature": "public  LTMTopicMapWriter(OutputStream stream, String encoding)", "class_method_signature": "LTMTopicMapWriter.LTMTopicMapWriter(OutputStream stream, String encoding)", "testcase": false, "constructor": true}, {"identifier": "LTMTopicMapWriter", "parameters": "(Writer out, String encoding)", "modifiers": "public", "return": "", "signature": " LTMTopicMapWriter(Writer out, String encoding)", "full_signature": "public  LTMTopicMapWriter(Writer out, String encoding)", "class_method_signature": "LTMTopicMapWriter.LTMTopicMapWriter(Writer out, String encoding)", "testcase": false, "constructor": true}, {"identifier": "setPreserveIds", "parameters": "(boolean preserveIds)", "modifiers": "public", "return": "void", "signature": "void setPreserveIds(boolean preserveIds)", "full_signature": "public void setPreserveIds(boolean preserveIds)", "class_method_signature": "LTMTopicMapWriter.setPreserveIds(boolean preserveIds)", "testcase": false, "constructor": false}, {"identifier": "setFilter", "parameters": "(DeciderIF<Object> filter)", "modifiers": "public", "return": "void", "signature": "void setFilter(DeciderIF<Object> filter)", "full_signature": "public void setFilter(DeciderIF<Object> filter)", "class_method_signature": "LTMTopicMapWriter.setFilter(DeciderIF<Object> filter)", "testcase": false, "constructor": false}, {"identifier": "hasUnfiltered", "parameters": "(Collection<? extends TMObjectIF> collection)", "modifiers": "private", "return": "boolean", "signature": "boolean hasUnfiltered(Collection<? extends TMObjectIF> collection)", "full_signature": "private boolean hasUnfiltered(Collection<? extends TMObjectIF> collection)", "class_method_signature": "LTMTopicMapWriter.hasUnfiltered(Collection<? extends TMObjectIF> collection)", "testcase": false, "constructor": false}, {"identifier": "addPrefix", "parameters": "(String key, String prefix)", "modifiers": "public", "return": "boolean", "signature": "boolean addPrefix(String key, String prefix)", "full_signature": "public boolean addPrefix(String key, String prefix)", "class_method_signature": "LTMTopicMapWriter.addPrefix(String key, String prefix)", "testcase": false, "constructor": false}, {"identifier": "write", "parameters": "(TopicMapIF tm)", "modifiers": "@Override public", "return": "void", "signature": "void write(TopicMapIF tm)", "full_signature": "@Override public void write(TopicMapIF tm)", "class_method_signature": "LTMTopicMapWriter.write(TopicMapIF tm)", "testcase": false, "constructor": false}, {"identifier": "writeTopics", "parameters": "(Collection<TopicIF> topics)", "modifiers": "private", "return": "void", "signature": "void writeTopics(Collection<TopicIF> topics)", "full_signature": "private void writeTopics(Collection<TopicIF> topics)", "class_method_signature": "LTMTopicMapWriter.writeTopics(Collection<TopicIF> topics)", "testcase": false, "constructor": false}, {"identifier": "playerAssociations", "parameters": "(Collection<TopicIF> rolePlayers,\n      Collection<AssociationIF> associations)", "modifiers": "private", "return": "SortedSet<AssociationIF>", "signature": "SortedSet<AssociationIF> playerAssociations(Collection<TopicIF> rolePlayers,\n      Collection<AssociationIF> associations)", "full_signature": "private SortedSet<AssociationIF> playerAssociations(Collection<TopicIF> rolePlayers,\n      Collection<AssociationIF> associations)", "class_method_signature": "LTMTopicMapWriter.playerAssociations(Collection<TopicIF> rolePlayers,\n      Collection<AssociationIF> associations)", "testcase": false, "constructor": false}, {"identifier": "topicTypes", "parameters": "(Collection<TopicIF> topics, Collection<TopicIF> topicInstances)", "modifiers": "private", "return": "SortedSet<TopicIF>", "signature": "SortedSet<TopicIF> topicTypes(Collection<TopicIF> topics, Collection<TopicIF> topicInstances)", "full_signature": "private SortedSet<TopicIF> topicTypes(Collection<TopicIF> topics, Collection<TopicIF> topicInstances)", "class_method_signature": "LTMTopicMapWriter.topicTypes(Collection<TopicIF> topics, Collection<TopicIF> topicInstances)", "testcase": false, "constructor": false}, {"identifier": "associationTypes", "parameters": "(Collection<AssociationIF> associations,\n      Collection<TopicIF> topicInstances)", "modifiers": "private", "return": "SortedSet<TopicIF>", "signature": "SortedSet<TopicIF> associationTypes(Collection<AssociationIF> associations,\n      Collection<TopicIF> topicInstances)", "full_signature": "private SortedSet<TopicIF> associationTypes(Collection<AssociationIF> associations,\n      Collection<TopicIF> topicInstances)", "class_method_signature": "LTMTopicMapWriter.associationTypes(Collection<AssociationIF> associations,\n      Collection<TopicIF> topicInstances)", "testcase": false, "constructor": false}, {"identifier": "roleTypes", "parameters": "(Collection<AssociationIF> associations, Collection<TopicIF> topicInstances)", "modifiers": "private", "return": "SortedSet<TopicIF>", "signature": "SortedSet<TopicIF> roleTypes(Collection<AssociationIF> associations, Collection<TopicIF> topicInstances)", "full_signature": "private SortedSet<TopicIF> roleTypes(Collection<AssociationIF> associations, Collection<TopicIF> topicInstances)", "class_method_signature": "LTMTopicMapWriter.roleTypes(Collection<AssociationIF> associations, Collection<TopicIF> topicInstances)", "testcase": false, "constructor": false}, {"identifier": "occurrenceTypes", "parameters": "(Collection<TopicIF> topics, Collection<TopicIF> topicInstances)", "modifiers": "private", "return": "SortedSet<TopicIF>", "signature": "SortedSet<TopicIF> occurrenceTypes(Collection<TopicIF> topics, Collection<TopicIF> topicInstances)", "full_signature": "private SortedSet<TopicIF> occurrenceTypes(Collection<TopicIF> topics, Collection<TopicIF> topicInstances)", "class_method_signature": "LTMTopicMapWriter.occurrenceTypes(Collection<TopicIF> topics, Collection<TopicIF> topicInstances)", "testcase": false, "constructor": false}, {"identifier": "sort", "parameters": "(Collection<E> collection, Comparator<? super E> comparator)", "modifiers": "private", "return": "SortedSet<E>", "signature": "SortedSet<E> sort(Collection<E> collection, Comparator<? super E> comparator)", "full_signature": "private SortedSet<E> sort(Collection<E> collection, Comparator<? super E> comparator)", "class_method_signature": "LTMTopicMapWriter.sort(Collection<E> collection, Comparator<? super E> comparator)", "testcase": false, "constructor": false}, {"identifier": "getElementId", "parameters": "(TopicIF topic)", "modifiers": "private", "return": "String", "signature": "String getElementId(TopicIF topic)", "full_signature": "private String getElementId(TopicIF topic)", "class_method_signature": "LTMTopicMapWriter.getElementId(TopicIF topic)", "testcase": false, "constructor": false}, {"identifier": "writeTopic", "parameters": "(TopicIF topic, Writer out)", "modifiers": "private", "return": "void", "signature": "void writeTopic(TopicIF topic, Writer out)", "full_signature": "private void writeTopic(TopicIF topic, Writer out)", "class_method_signature": "LTMTopicMapWriter.writeTopic(TopicIF topic, Writer out)", "testcase": false, "constructor": false}, {"identifier": "writeTopic", "parameters": "(TopicIF topic, Writer out, boolean writeHeaders)", "modifiers": "private", "return": "void", "signature": "void writeTopic(TopicIF topic, Writer out, boolean writeHeaders)", "full_signature": "private void writeTopic(TopicIF topic, Writer out, boolean writeHeaders)", "class_method_signature": "LTMTopicMapWriter.writeTopic(TopicIF topic, Writer out, boolean writeHeaders)", "testcase": false, "constructor": false}, {"identifier": "writeAssociation", "parameters": "(AssociationIF association, Writer out)", "modifiers": "private", "return": "void", "signature": "void writeAssociation(AssociationIF association, Writer out)", "full_signature": "private void writeAssociation(AssociationIF association, Writer out)", "class_method_signature": "LTMTopicMapWriter.writeAssociation(AssociationIF association, Writer out)", "testcase": false, "constructor": false}, {"identifier": "writeAssociation", "parameters": "(AssociationIF association, Writer out,\n      boolean writeHeaders)", "modifiers": "private", "return": "void", "signature": "void writeAssociation(AssociationIF association, Writer out,\n      boolean writeHeaders)", "full_signature": "private void writeAssociation(AssociationIF association, Writer out,\n      boolean writeHeaders)", "class_method_signature": "LTMTopicMapWriter.writeAssociation(AssociationIF association, Writer out,\n      boolean writeHeaders)", "testcase": false, "constructor": false}, {"identifier": "repeatString", "parameters": "(String string, int length)", "modifiers": "private", "return": "String", "signature": "String repeatString(String string, int length)", "full_signature": "private String repeatString(String string, int length)", "class_method_signature": "LTMTopicMapWriter.repeatString(String string, int length)", "testcase": false, "constructor": false}, {"identifier": "writeSupersub", "parameters": "(AssociationIF association, Writer out)", "modifiers": "private", "return": "void", "signature": "void writeSupersub(AssociationIF association, Writer out)", "full_signature": "private void writeSupersub(AssociationIF association, Writer out)", "class_method_signature": "LTMTopicMapWriter.writeSupersub(AssociationIF association, Writer out)", "testcase": false, "constructor": false}, {"identifier": "writeAssociationRole", "parameters": "(AssociationRoleIF role, Writer out)", "modifiers": "private", "return": "void", "signature": "void writeAssociationRole(AssociationRoleIF role, Writer out)", "full_signature": "private void writeAssociationRole(AssociationRoleIF role, Writer out)", "class_method_signature": "LTMTopicMapWriter.writeAssociationRole(AssociationRoleIF role, Writer out)", "testcase": false, "constructor": false}, {"identifier": "filterCollection", "parameters": "(Collection<E> unfiltered)", "modifiers": "private", "return": "Collection<E>", "signature": "Collection<E> filterCollection(Collection<E> unfiltered)", "full_signature": "private Collection<E> filterCollection(Collection<E> unfiltered)", "class_method_signature": "LTMTopicMapWriter.filterCollection(Collection<E> unfiltered)", "testcase": false, "constructor": false}, {"identifier": "filterOk", "parameters": "(Object unfiltered)", "modifiers": "private", "return": "boolean", "signature": "boolean filterOk(Object unfiltered)", "full_signature": "private boolean filterOk(Object unfiltered)", "class_method_signature": "LTMTopicMapWriter.filterOk(Object unfiltered)", "testcase": false, "constructor": false}, {"identifier": "firstNameWithScopingPSI", "parameters": "(Collection<VariantNameIF> variants,\n      LocatorIF si)", "modifiers": "private", "return": "VariantNameIF", "signature": "VariantNameIF firstNameWithScopingPSI(Collection<VariantNameIF> variants,\n      LocatorIF si)", "full_signature": "private VariantNameIF firstNameWithScopingPSI(Collection<VariantNameIF> variants,\n      LocatorIF si)", "class_method_signature": "LTMTopicMapWriter.firstNameWithScopingPSI(Collection<VariantNameIF> variants,\n      LocatorIF si)", "testcase": false, "constructor": false}, {"identifier": "writeTopicName", "parameters": "(TopicNameIF baseName, Writer out,\n      String indentString)", "modifiers": "private", "return": "void", "signature": "void writeTopicName(TopicNameIF baseName, Writer out,\n      String indentString)", "full_signature": "private void writeTopicName(TopicNameIF baseName, Writer out,\n      String indentString)", "class_method_signature": "LTMTopicMapWriter.writeTopicName(TopicNameIF baseName, Writer out,\n      String indentString)", "testcase": false, "constructor": false}, {"identifier": "writeVariant", "parameters": "(VariantNameIF variant, Writer out)", "modifiers": "private", "return": "void", "signature": "void writeVariant(VariantNameIF variant, Writer out)", "full_signature": "private void writeVariant(VariantNameIF variant, Writer out)", "class_method_signature": "LTMTopicMapWriter.writeVariant(VariantNameIF variant, Writer out)", "testcase": false, "constructor": false}, {"identifier": "writeOccurrence", "parameters": "(OccurrenceIF occurrence, Writer out)", "modifiers": "private", "return": "void", "signature": "void writeOccurrence(OccurrenceIF occurrence, Writer out)", "full_signature": "private void writeOccurrence(OccurrenceIF occurrence, Writer out)", "class_method_signature": "LTMTopicMapWriter.writeOccurrence(OccurrenceIF occurrence, Writer out)", "testcase": false, "constructor": false}, {"identifier": "writeReifiers", "parameters": "(ReifiableIF reifiable, Writer out)", "modifiers": "private", "return": "void", "signature": "void writeReifiers(ReifiableIF reifiable, Writer out)", "full_signature": "private void writeReifiers(ReifiableIF reifiable, Writer out)", "class_method_signature": "LTMTopicMapWriter.writeReifiers(ReifiableIF reifiable, Writer out)", "testcase": false, "constructor": false}, {"identifier": "writeScope", "parameters": "(ScopedIF tmObject, Writer out)", "modifiers": "private", "return": "void", "signature": "void writeScope(ScopedIF tmObject, Writer out)", "full_signature": "private void writeScope(ScopedIF tmObject, Writer out)", "class_method_signature": "LTMTopicMapWriter.writeScope(ScopedIF tmObject, Writer out)", "testcase": false, "constructor": false}, {"identifier": "count", "parameters": "(AssociationIF association, AssociationRoleIF role)", "modifiers": "private", "return": "void", "signature": "void count(AssociationIF association, AssociationRoleIF role)", "full_signature": "private void count(AssociationIF association, AssociationRoleIF role)", "class_method_signature": "LTMTopicMapWriter.count(AssociationIF association, AssociationRoleIF role)", "testcase": false, "constructor": false}, {"identifier": "countMaxRolesOf", "parameters": "(AssociationIF association)", "modifiers": "private", "return": "void", "signature": "void countMaxRolesOf(AssociationIF association)", "full_signature": "private void countMaxRolesOf(AssociationIF association)", "class_method_signature": "LTMTopicMapWriter.countMaxRolesOf(AssociationIF association)", "testcase": false, "constructor": false}, {"identifier": "maxRolesOf", "parameters": "(AssociationIF association)", "modifiers": "private", "return": "int", "signature": "int maxRolesOf(AssociationIF association)", "full_signature": "private int maxRolesOf(AssociationIF association)", "class_method_signature": "LTMTopicMapWriter.maxRolesOf(AssociationIF association)", "testcase": false, "constructor": false}, {"identifier": "countRoles", "parameters": "(Collection<AssociationIF> associations)", "modifiers": "private", "return": "void", "signature": "void countRoles(Collection<AssociationIF> associations)", "full_signature": "private void countRoles(Collection<AssociationIF> associations)", "class_method_signature": "LTMTopicMapWriter.countRoles(Collection<AssociationIF> associations)", "testcase": false, "constructor": false}, {"identifier": "existsUnspecifiedRolePlayer", "parameters": "(Collection<AssociationIF> associations)", "modifiers": "private", "return": "boolean", "signature": "boolean existsUnspecifiedRolePlayer(Collection<AssociationIF> associations)", "full_signature": "private boolean existsUnspecifiedRolePlayer(Collection<AssociationIF> associations)", "class_method_signature": "LTMTopicMapWriter.existsUnspecifiedRolePlayer(Collection<AssociationIF> associations)", "testcase": false, "constructor": false}, {"identifier": "generateId", "parameters": "(TopicIF topic)", "modifiers": "private", "return": "String", "signature": "String generateId(TopicIF topic)", "full_signature": "private String generateId(TopicIF topic)", "class_method_signature": "LTMTopicMapWriter.generateId(TopicIF topic)", "testcase": false, "constructor": false}, {"identifier": "getCount", "parameters": "(AssociationIF association, AssociationRoleIF role)", "modifiers": "private", "return": "Integer", "signature": "Integer getCount(AssociationIF association, AssociationRoleIF role)", "full_signature": "private Integer getCount(AssociationIF association, AssociationRoleIF role)", "class_method_signature": "LTMTopicMapWriter.getCount(AssociationIF association, AssociationRoleIF role)", "testcase": false, "constructor": false}, {"identifier": "lazyPlayerElementId", "parameters": "(AssociationRoleIF role)", "modifiers": "private", "return": "String", "signature": "String lazyPlayerElementId(AssociationRoleIF role)", "full_signature": "private String lazyPlayerElementId(AssociationRoleIF role)", "class_method_signature": "LTMTopicMapWriter.lazyPlayerElementId(AssociationRoleIF role)", "testcase": false, "constructor": false}, {"identifier": "lazyTypeElementId", "parameters": "(TypedIF tmObject)", "modifiers": "private", "return": "String", "signature": "String lazyTypeElementId(TypedIF tmObject)", "full_signature": "private String lazyTypeElementId(TypedIF tmObject)", "class_method_signature": "LTMTopicMapWriter.lazyTypeElementId(TypedIF tmObject)", "testcase": false, "constructor": false}, {"identifier": "preserveId", "parameters": "(TopicIF topic)", "modifiers": "private", "return": "String", "signature": "String preserveId(TopicIF topic)", "full_signature": "private String preserveId(TopicIF topic)", "class_method_signature": "LTMTopicMapWriter.preserveId(TopicIF topic)", "testcase": false, "constructor": false}, {"identifier": "recordIds", "parameters": "(Collection<TopicIF> topics)", "modifiers": "private", "return": "void", "signature": "void recordIds(Collection<TopicIF> topics)", "full_signature": "private void recordIds(Collection<TopicIF> topics)", "class_method_signature": "LTMTopicMapWriter.recordIds(Collection<TopicIF> topics)", "testcase": false, "constructor": false}, {"identifier": "allDigits", "parameters": "(String source)", "modifiers": "private static", "return": "boolean", "signature": "boolean allDigits(String source)", "full_signature": "private static boolean allDigits(String source)", "class_method_signature": "LTMTopicMapWriter.allDigits(String source)", "testcase": false, "constructor": false}, {"identifier": "allSameAs", "parameters": "(String source, char sameAs)", "modifiers": "private static", "return": "boolean", "signature": "boolean allSameAs(String source, char sameAs)", "full_signature": "private static boolean allSameAs(String source, char sameAs)", "class_method_signature": "LTMTopicMapWriter.allSameAs(String source, char sameAs)", "testcase": false, "constructor": false}, {"identifier": "createSpaces", "parameters": "(int length)", "modifiers": "private static", "return": "String", "signature": "String createSpaces(int length)", "full_signature": "private static String createSpaces(int length)", "class_method_signature": "LTMTopicMapWriter.createSpaces(int length)", "testcase": false, "constructor": false}, {"identifier": "escapeString", "parameters": "(String source)", "modifiers": "private static", "return": "String", "signature": "String escapeString(String source)", "full_signature": "private static String escapeString(String source)", "class_method_signature": "LTMTopicMapWriter.escapeString(String source)", "testcase": false, "constructor": false}, {"identifier": "escapeInternalOccurrence", "parameters": "(String source)", "modifiers": "private static", "return": "String", "signature": "String escapeInternalOccurrence(String source)", "full_signature": "private static String escapeInternalOccurrence(String source)", "class_method_signature": "LTMTopicMapWriter.escapeInternalOccurrence(String source)", "testcase": false, "constructor": false}, {"identifier": "getFragment", "parameters": "(LocatorIF locator)", "modifiers": "private", "return": "String", "signature": "String getFragment(LocatorIF locator)", "full_signature": "private String getFragment(LocatorIF locator)", "class_method_signature": "LTMTopicMapWriter.getFragment(LocatorIF locator)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(String id)", "modifiers": "private", "return": "boolean", "signature": "boolean validate(String id)", "full_signature": "private boolean validate(String id)", "class_method_signature": "LTMTopicMapWriter.validate(String id)", "testcase": false, "constructor": false}, {"identifier": "lazyHasLocator", "parameters": "(TopicIF topic, LocatorIF uri)", "modifiers": "private static", "return": "boolean", "signature": "boolean lazyHasLocator(TopicIF topic, LocatorIF uri)", "full_signature": "private static boolean lazyHasLocator(TopicIF topic, LocatorIF uri)", "class_method_signature": "LTMTopicMapWriter.lazyHasLocator(TopicIF topic, LocatorIF uri)", "testcase": false, "constructor": false}, {"identifier": "isReservedId", "parameters": "(String fragmentId)", "modifiers": "private static", "return": "boolean", "signature": "boolean isReservedId(String fragmentId)", "full_signature": "private static boolean isReservedId(String fragmentId)", "class_method_signature": "LTMTopicMapWriter.isReservedId(String fragmentId)", "testcase": false, "constructor": false}, {"identifier": "inRange", "parameters": "(char lowerBound, char it, char upperBound)", "modifiers": "private static", "return": "boolean", "signature": "boolean inRange(char lowerBound, char it, char upperBound)", "full_signature": "private static boolean inRange(char lowerBound, char it, char upperBound)", "class_method_signature": "LTMTopicMapWriter.inRange(char lowerBound, char it, char upperBound)", "testcase": false, "constructor": false}, {"identifier": "lazyStringCompare", "parameters": "(String source1, String source2)", "modifiers": "private static", "return": "int", "signature": "int lazyStringCompare(String source1, String source2)", "full_signature": "private static int lazyStringCompare(String source1, String source2)", "class_method_signature": "LTMTopicMapWriter.lazyStringCompare(String source1, String source2)", "testcase": false, "constructor": false}, {"identifier": "minLengthString", "parameters": "(int source, int length)", "modifiers": "private static", "return": "String", "signature": "String minLengthString(int source, int length)", "full_signature": "private static String minLengthString(int source, int length)", "class_method_signature": "LTMTopicMapWriter.minLengthString(int source, int length)", "testcase": false, "constructor": false}, {"identifier": "setAdditionalProperties", "parameters": "(Map<String, Object> properties)", "modifiers": "@SuppressWarnings(\"unchecked\") @Override public", "return": "void", "signature": "void setAdditionalProperties(Map<String, Object> properties)", "full_signature": "@SuppressWarnings(\"unchecked\") @Override public void setAdditionalProperties(Map<String, Object> properties)", "class_method_signature": "LTMTopicMapWriter.setAdditionalProperties(Map<String, Object> properties)", "testcase": false, "constructor": false}], "file": "ontopia-engine/src/main/java/net/ontopia/topicmaps/utils/ltm/LTMTopicMapWriter.java"}, "focal_method": {"identifier": "write", "parameters": "(TopicMapIF tm)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void write(TopicMapIF tm) throws IOException {\n    LocatorIF baseLocator = tm.getStore().getBaseAddress();\n    base = (baseLocator == null) ? null : baseLocator.getExternalForm();\n    idManager = new IdManager();\n\n    ClassInstanceIndexIF classIndex = (ClassInstanceIndexIF)tm.getIndex(\n            \"net.ontopia.topicmaps.core.index.ClassInstanceIndexIF\");\n\n    // Check if there are any untyped associations, association roles or\n    // occurrences\n    boolean existsUntyped = (hasUnfiltered(classIndex.getAssociationRoles(null))\n        || hasUnfiltered(classIndex.getAssociations(null)) || hasUnfiltered(classIndex\n        .getOccurrences(null)));\n\n    Collection<TopicIF> topics = tm.getTopics();\n\n    recordIds(topics);\n\n    // Get all relevant topics sorted.\n    topics = sort(filterCollection(topics), topicComparator);\n\n    // Get the topic(s) that reifies the topicmap.\n    TopicIF reifier = tm.getReifier();\n    // FIXME: no need to treat this as a collection anymore\n    Collection<TopicIF> tmReifiers = (reifier == null ? Collections.<TopicIF>emptySet() : Collections.singleton(reifier));\n    tmReifiers = filterCollection(tmReifiers);\n    topics.removeAll(tmReifiers);\n\n    // Get all associations.\n    Collection<AssociationIF> allAssociations = filterCollection(tm.getAssociations());\n    boolean existsUnspecified = existsUnspecifiedRolePlayer(allAssociations);\n\n    // Sort all the topics.\n    Collection<TopicIF> topicInstances = sort(topics, topicComparator);\n\n    // Filter out the topics that are used to type other topics.\n    Collection<TopicIF> topicTypes = topicTypes(topics, topicInstances);\n\n    // Filter out the topics that are used to type association roles.\n    Collection<TopicIF> roleTypes = roleTypes(allAssociations, topicInstances);\n\n    // Filter out the topics that are used to type associations.\n    Collection<TopicIF> associationTypes = associationTypes(allAssociations,\n        topicInstances);\n\n    // Filter out the topics that are used to type occurrences.\n    Collection<TopicIF> occurrenceTypes = occurrenceTypes(topics, topicInstances);\n\n    // Count up the number of associations that a particular role, e.g.\n    // \"player : type\" takes part in.\n    countRoles(allAssociations);\n\n    // Get all the associations in correct output order.\n    allAssociations = sort(allAssociations, associationComparator);\n\n    // Filter out all superclass/subclass associations\n    TopicIF supersubtype = tm.getTopicBySubjectIdentifier(PSI\n        .getXTMSuperclassSubclass());\n    Collection<AssociationIF> supersubAssociations = classIndex.getAssociations(supersubtype);\n    supersubAssociations = filterCollection(supersubAssociations);\n    allAssociations.removeAll(supersubAssociations);\n\n    // Filter out the associations that have roles reifying the topic map.\n    Collection<AssociationIF> tmReifierAssociations = playerAssociations(tmReifiers,\n        allAssociations);\n\n    // Output preamble.\n    if (encoding != null)\n      out.write(\"@\\\"\" + encoding + \"\\\"\\n\");\n    out.write(\"#VERSION \\\"1.3\\\"\\n\");\n    out.write(\"/*\\n   Generator: Ontopia\");\n    out.write(\"\\n   Date:      \");\n    out.write(minLengthString(calendar.get(Calendar.YEAR), 4));\n    out.write('-');\n    out.write(minLengthString(calendar.get(Calendar.MONTH)+1, 2));\n    out.write('-');\n    out.write(minLengthString(calendar.get(Calendar.DAY_OF_MONTH), 2));\n    out.write(' ');\n    out.write(minLengthString(calendar.get(Calendar.HOUR_OF_DAY), 2));\n    out.write(':');\n    out.write(minLengthString(calendar.get(Calendar.MINUTE), 2));\n    out.write(\"\\n*/\\n\");\n\n    for (String key : prefixes.keySet()) {\n      out.write(\"#PREFIX \" + key + \" @\\\"\" + prefixes.get(key) + \"\\\"\\n\");\n    }\n\n    // If necessary, output the prefix for untyped topic map constructs.\n    if (existsUntyped)\n      out.write(\"\\n#PREFIX untyped @\\\"http://psi.ontopia.net/ltm/untyped#\\\"\\n\");\n\n    // If necessary, output prefix for unspecified topic map constructs(roles).\n    if (existsUnspecified) {\n      out.write(\"\\n#PREFIX unspecified\");\n      out.write(\" @\\\"http://psi.ontopia.net/ltm/unspecified#\\\"\\n\");\n    }\n\n    // If necessary, output the TOPICMAP directive with any topic reification.\n    Iterator<TopicIF> tmReifiersIt = tmReifiers.iterator();\n    if (!tmReifiers.isEmpty()) {\n      out.write(\"\\n/* ----------------- TOPIC MAP ----------------- */\\n\");\n      out.write(\"\\n#TOPICMAP\");\n      writeReifiers(tm, out);\n      out.write(\"\\n\");\n\n      // Output the topic map reifier(s)(usually one).\n      groupString1 = \"\";\n      tmReifiersIt = tmReifiers.iterator();\n\n      // Output the reifiers\n      while (tmReifiersIt.hasNext())\n        writeTopic(tmReifiersIt.next(), out, false);\n    }\n\n    // Output all associations that the tm reifier(s) are directly involved in.\n    groupString1 = \"\";\n    Iterator<AssociationIF> tmReifierAssociationsIt = tmReifierAssociations.iterator();\n    while (tmReifierAssociationsIt.hasNext())\n      writeAssociation(tmReifierAssociationsIt.next(), out,\n          false);\n\n    out.write(\"\\n/* ----------------- ONTOLOGY ------------------ */\\n\");\n\n    out.write(\"\\n/* ----------------- Topic Types --------------- */\\n\");\n\n    // Output all the topic types.\n    writeTopics(topicTypes);\n\n    out.write(\"\\n/* ----------------- Type Hierarchy ------------ */\\n\");\n\n    // Write all supertype subtype associations\n    groupString1 = \"\";\n    Iterator<AssociationIF> hierarchyIt = sort(supersubAssociations, supersubComparator)\n        .iterator();\n    if (hierarchyIt.hasNext())\n      out.write(\"\\n\");\n    while (hierarchyIt.hasNext()) {\n      AssociationIF currentAssociation = hierarchyIt.next();\n      writeSupersub(currentAssociation, out);\n    }\n\n    out.write(\"\\n/* ----------------- Role Types ---------------- */\\n\");\n    // Write all remaining association role types.\n    writeTopics(roleTypes);\n\n    out.write(\"\\n/* ----------------- Association Types --------- */\\n\");\n    // Write all remaining association types\n    writeTopics(associationTypes);\n\n    out.write(\"\\n/* ----------------- Occurrence Types ---------- */\\n\");\n    // Write all remaining occurrence types\n    writeTopics(occurrenceTypes);\n\n    out.write(\"\\n/* ----------------- INSTANCES ----------------- */\\n\");\n\n    out.write(\"\\n/* ----------------- Topics -------------------- */\\n\");\n    // Write all remaining instance topics\n    writeTopics(topicInstances);\n\n    out.write(\"\\n/* ----------------- Associations -------------- */\\n\");\n    // Write all remaining associations\n    groupString1 = \"\";\n    Iterator<AssociationIF> associationsIt = allAssociations.iterator();\n    while (associationsIt.hasNext())\n      writeAssociation(associationsIt.next(), out);\n\n    out.flush();\n    \n    if (closeWriter) {\n      out.close();\n    }\n  }", "signature": "void write(TopicMapIF tm)", "full_signature": "@Override public void write(TopicMapIF tm)", "class_method_signature": "LTMTopicMapWriter.write(TopicMapIF tm)", "testcase": false, "constructor": false, "invocations": ["getBaseAddress", "getStore", "getExternalForm", "getIndex", "hasUnfiltered", "getAssociationRoles", "hasUnfiltered", "getAssociations", "hasUnfiltered", "getOccurrences", "getTopics", "recordIds", "sort", "filterCollection", "getReifier", "emptySet", "singleton", "filterCollection", "removeAll", "filterCollection", "getAssociations", "existsUnspecifiedRolePlayer", "sort", "topicTypes", "roleTypes", "associationTypes", "occurrenceTypes", "countRoles", "sort", "getTopicBySubjectIdentifier", "getXTMSuperclassSubclass", "getAssociations", "filterCollection", "removeAll", "playerAssociations", "write", "write", "write", "write", "write", "minLengthString", "get", "write", "write", "minLengthString", "get", "write", "write", "minLengthString", "get", "write", "write", "minLengthString", "get", "write", "write", "minLengthString", "get", "write", "keySet", "write", "get", "write", "write", "write", "iterator", "isEmpty", "write", "write", "writeReifiers", "write", "iterator", "hasNext", "writeTopic", "next", "iterator", "hasNext", "writeAssociation", "next", "write", "write", "writeTopics", "write", "iterator", "sort", "hasNext", "write", "hasNext", "next", "writeSupersub", "write", "writeTopics", "write", "writeTopics", "write", "writeTopics", "write", "write", "writeTopics", "write", "iterator", "hasNext", "writeAssociation", "next", "flush", "close"]}, "repository": {"repo_id": 32357795, "url": "https://github.com/ontopia/ontopia", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 35, "size": 68637, "license": "licensed"}}