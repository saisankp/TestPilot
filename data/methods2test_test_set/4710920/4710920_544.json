{"test_class": {"identifier": "CompatibleTypeUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "dubbo-common/src/test/java/org/apache/dubbo/common/utils/CompatibleTypeUtilsTest.java"}, "test_case": {"identifier": "testCompatibleTypeConvert", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") @Test public", "return": "void", "body": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testCompatibleTypeConvert() throws Exception {\n        Object result;\n\n        {\n            Object input = new Object();\n            result = CompatibleTypeUtils.compatibleTypeConvert(input, Date.class);\n            assertSame(input, result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(input, null);\n            assertSame(input, result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(null, Date.class);\n            assertNull(result);\n        }\n\n        {\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"a\", char.class);\n            assertEquals(Character.valueOf('a'), (Character) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"A\", MyEnum.class);\n            assertEquals(MyEnum.A, (MyEnum) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"3\", BigInteger.class);\n            assertEquals(new BigInteger(\"3\"), (BigInteger) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"3\", BigDecimal.class);\n            assertEquals(new BigDecimal(\"3\"), (BigDecimal) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11 12:24:12\", Date.class);\n            assertEquals(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").parse(\"2011-12-11 12:24:12\"), (Date) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11 12:24:12\", java.sql.Date.class);\n            assertEquals(new SimpleDateFormat(\"yyyy-MM-dd\").format((java.sql.Date) result), \"2011-12-11\");\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11 12:24:12\", java.sql.Time.class);\n            assertEquals(new SimpleDateFormat(\"HH:mm:ss\").format((java.sql.Time) result), \"12:24:12\");\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11 12:24:12\", java.sql.Timestamp.class);\n            assertEquals(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format((java.sql.Timestamp) result), \"2011-12-11 12:24:12\");\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11T12:24:12.047\", java.time.LocalDateTime.class);\n            assertEquals(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\").format((java.time.LocalDateTime) result), \"2011-12-11 12:24:12\");\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11T12:24:12.047\", java.time.LocalTime.class);\n            assertEquals(DateTimeFormatter.ofPattern(\"HH:mm:ss\").format((java.time.LocalTime) result), \"12:24:12\");\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11T12:24:12.047\", java.time.LocalDate.class);\n            assertEquals(DateTimeFormatter.ofPattern(\"yyyy-MM-dd\").format((java.time.LocalDate) result), \"2011-12-11\");\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"ab\", char[].class);\n            assertEquals(2, ((char[]) result).length);\n            assertEquals('a', ((char[]) result)[0]);\n            assertEquals('b', ((char[]) result)[1]);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(\"\", char[].class);\n            assertEquals(0, ((char[]) result).length);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(null, char[].class);\n            assertNull(result);\n        }\n\n        {\n            result = CompatibleTypeUtils.compatibleTypeConvert(3, byte.class);\n            assertEquals(Byte.valueOf((byte) 3), (Byte) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert((byte) 3, int.class);\n            assertEquals(Integer.valueOf(3), (Integer) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(3, short.class);\n            assertEquals(Short.valueOf((short) 3), (Short) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert((short) 3, int.class);\n            assertEquals(Integer.valueOf(3), (Integer) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(3, int.class);\n            assertEquals(Integer.valueOf(3), (Integer) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(3, long.class);\n            assertEquals(Long.valueOf(3), (Long) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(3L, int.class);\n            assertEquals(Integer.valueOf(3), (Integer) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(3L, BigInteger.class);\n            assertEquals(BigInteger.valueOf(3L), (BigInteger) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(BigInteger.valueOf(3L), int.class);\n            assertEquals(Integer.valueOf(3), (Integer) result);\n        }\n\n        {\n            result = CompatibleTypeUtils.compatibleTypeConvert(3D, float.class);\n            assertEquals(Float.valueOf(3), (Float) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(3F, double.class);\n            assertEquals(Double.valueOf(3), (Double) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(3D, double.class);\n            assertEquals(Double.valueOf(3), (Double) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(3D, BigDecimal.class);\n            assertEquals(BigDecimal.valueOf(3D), (BigDecimal) result);\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(BigDecimal.valueOf(3D), double.class);\n            assertEquals(Double.valueOf(3), (Double) result);\n        }\n\n        {\n            List<String> list = new ArrayList<String>();\n            list.add(\"a\");\n            list.add(\"b\");\n\n            Set<String> set = new HashSet<String>();\n            set.add(\"a\");\n            set.add(\"b\");\n\n            String[] array = new String[]{\"a\", \"b\"};\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(array, List.class);\n            assertEquals(ArrayList.class, result.getClass());\n            assertEquals(2, ((List<String>) result).size());\n            assertTrue(((List<String>) result).contains(\"a\"));\n            assertTrue(((List<String>) result).contains(\"b\"));\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(set, List.class);\n            assertEquals(ArrayList.class, result.getClass());\n            assertEquals(2, ((List<String>) result).size());\n            assertTrue(((List<String>) result).contains(\"a\"));\n            assertTrue(((List<String>) result).contains(\"b\"));\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(array, CopyOnWriteArrayList.class);\n            assertEquals(CopyOnWriteArrayList.class, result.getClass());\n            assertEquals(2, ((List<String>) result).size());\n            assertTrue(((List<String>) result).contains(\"a\"));\n            assertTrue(((List<String>) result).contains(\"b\"));\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(set, CopyOnWriteArrayList.class);\n            assertEquals(CopyOnWriteArrayList.class, result.getClass());\n            assertEquals(2, ((List<String>) result).size());\n            assertTrue(((List<String>) result).contains(\"a\"));\n            assertTrue(((List<String>) result).contains(\"b\"));\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(set, String[].class);\n            assertEquals(String[].class, result.getClass());\n            assertEquals(2, ((String[]) result).length);\n            assertTrue(((String[]) result)[0].equals(\"a\") || ((String[]) result)[0].equals(\"b\"));\n            assertTrue(((String[]) result)[1].equals(\"a\") || ((String[]) result)[1].equals(\"b\"));\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(array, Set.class);\n            assertEquals(HashSet.class, result.getClass());\n            assertEquals(2, ((Set<String>) result).size());\n            assertTrue(((Set<String>) result).contains(\"a\"));\n            assertTrue(((Set<String>) result).contains(\"b\"));\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(list, Set.class);\n            assertEquals(HashSet.class, result.getClass());\n            assertEquals(2, ((Set<String>) result).size());\n            assertTrue(((Set<String>) result).contains(\"a\"));\n            assertTrue(((Set<String>) result).contains(\"b\"));\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(array, ConcurrentHashSet.class);\n            assertEquals(ConcurrentHashSet.class, result.getClass());\n            assertEquals(2, ((Set<String>) result).size());\n            assertTrue(((Set<String>) result).contains(\"a\"));\n            assertTrue(((Set<String>) result).contains(\"b\"));\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(list, ConcurrentHashSet.class);\n            assertEquals(ConcurrentHashSet.class, result.getClass());\n            assertEquals(2, ((Set<String>) result).size());\n            assertTrue(((Set<String>) result).contains(\"a\"));\n            assertTrue(((Set<String>) result).contains(\"b\"));\n\n            result = CompatibleTypeUtils.compatibleTypeConvert(list, String[].class);\n            assertEquals(String[].class, result.getClass());\n            assertEquals(2, ((String[]) result).length);\n            assertTrue(((String[]) result)[0].equals(\"a\"));\n            assertTrue(((String[]) result)[1].equals(\"b\"));\n\n        }\n\n    }", "signature": "void testCompatibleTypeConvert()", "full_signature": "@SuppressWarnings(\"unchecked\") @Test public void testCompatibleTypeConvert()", "class_method_signature": "CompatibleTypeUtilsTest.testCompatibleTypeConvert()", "testcase": true, "constructor": false, "invocations": ["compatibleTypeConvert", "assertSame", "compatibleTypeConvert", "assertSame", "compatibleTypeConvert", "assertNull", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "compatibleTypeConvert", "assertEquals", "compatibleTypeConvert", "assertEquals", "compatibleTypeConvert", "assertEquals", "parse", "compatibleTypeConvert", "assertEquals", "format", "compatibleTypeConvert", "assertEquals", "format", "compatibleTypeConvert", "assertEquals", "format", "compatibleTypeConvert", "assertEquals", "format", "ofPattern", "compatibleTypeConvert", "assertEquals", "format", "ofPattern", "compatibleTypeConvert", "assertEquals", "format", "ofPattern", "compatibleTypeConvert", "assertEquals", "assertEquals", "assertEquals", "compatibleTypeConvert", "assertEquals", "compatibleTypeConvert", "assertNull", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "valueOf", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "assertEquals", "valueOf", "compatibleTypeConvert", "valueOf", "assertEquals", "valueOf", "add", "add", "add", "add", "compatibleTypeConvert", "assertEquals", "getClass", "assertEquals", "size", "assertTrue", "contains", "assertTrue", "contains", "compatibleTypeConvert", "assertEquals", "getClass", "assertEquals", "size", "assertTrue", "contains", "assertTrue", "contains", "compatibleTypeConvert", "assertEquals", "getClass", "assertEquals", "size", "assertTrue", "contains", "assertTrue", "contains", "compatibleTypeConvert", "assertEquals", "getClass", "assertEquals", "size", "assertTrue", "contains", "assertTrue", "contains", "compatibleTypeConvert", "assertEquals", "getClass", "assertEquals", "assertTrue", "equals", "equals", "assertTrue", "equals", "equals", "compatibleTypeConvert", "assertEquals", "getClass", "assertEquals", "size", "assertTrue", "contains", "assertTrue", "contains", "compatibleTypeConvert", "assertEquals", "getClass", "assertEquals", "size", "assertTrue", "contains", "assertTrue", "contains", "compatibleTypeConvert", "assertEquals", "getClass", "assertEquals", "size", "assertTrue", "contains", "assertTrue", "contains", "compatibleTypeConvert", "assertEquals", "getClass", "assertEquals", "size", "assertTrue", "contains", "assertTrue", "contains", "compatibleTypeConvert", "assertEquals", "getClass", "assertEquals", "assertTrue", "equals", "assertTrue", "equals"]}, "focal_class": {"identifier": "CompatibleTypeUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";", "modifier": "private static final", "type": "String", "declarator": "DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\"", "var_name": "DATE_FORMAT"}], "methods": [{"identifier": "CompatibleTypeUtils", "parameters": "()", "modifiers": "private", "return": "", "signature": " CompatibleTypeUtils()", "full_signature": "private  CompatibleTypeUtils()", "class_method_signature": "CompatibleTypeUtils.CompatibleTypeUtils()", "testcase": false, "constructor": true}, {"identifier": "compatibleTypeConvert", "parameters": "(Object value, Class<?> type)", "modifiers": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) public static", "return": "Object", "signature": "Object compatibleTypeConvert(Object value, Class<?> type)", "full_signature": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) public static Object compatibleTypeConvert(Object value, Class<?> type)", "class_method_signature": "CompatibleTypeUtils.compatibleTypeConvert(Object value, Class<?> type)", "testcase": false, "constructor": false}], "file": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java"}, "focal_method": {"identifier": "compatibleTypeConvert", "parameters": "(Object value, Class<?> type)", "modifiers": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) public static", "return": "Object", "body": "@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static Object compatibleTypeConvert(Object value, Class<?> type) {\n        if (value == null || type == null || type.isAssignableFrom(value.getClass())) {\n            return value;\n        }\n\n        if (value instanceof String) {\n            String string = (String) value;\n            if (char.class.equals(type) || Character.class.equals(type)) {\n                if (string.length() != 1) {\n                    throw new IllegalArgumentException(String.format(\"CAN NOT convert String(%s) to char!\" +\n                            \" when convert String to char, the String MUST only 1 char.\", string));\n                }\n                return string.charAt(0);\n            }\n            if (type.isEnum()) {\n                return Enum.valueOf((Class<Enum>) type, string);\n            }\n            if (type == BigInteger.class) {\n                return new BigInteger(string);\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(string);\n            }\n            if (type == Short.class || type == short.class) {\n                return new Short(string);\n            }\n            if (type == Integer.class || type == int.class) {\n                return new Integer(string);\n            }\n            if (type == Long.class || type == long.class) {\n                return new Long(string);\n            }\n            if (type == Double.class || type == double.class) {\n                return new Double(string);\n            }\n            if (type == Float.class || type == float.class) {\n                return new Float(string);\n            }\n            if (type == Byte.class || type == byte.class) {\n                return new Byte(string);\n            }\n            if (type == Boolean.class || type == boolean.class) {\n                return Boolean.valueOf(string);\n            }\n            if (type == Date.class || type == java.sql.Date.class || type == java.sql.Timestamp.class\n                    || type == java.sql.Time.class) {\n                try {\n                    Date date = new SimpleDateFormat(DATE_FORMAT).parse(string);\n                    if (type == java.sql.Date.class) {\n                        return new java.sql.Date(date.getTime());\n                    }\n                    if (type == java.sql.Timestamp.class) {\n                        return new java.sql.Timestamp(date.getTime());\n                    }\n                    if (type == java.sql.Time.class) {\n                        return new java.sql.Time(date.getTime());\n                    }\n                    return date;\n                } catch (ParseException e) {\n                    throw new IllegalStateException(\"Failed to parse date \" + value + \" by format \"\n                            + DATE_FORMAT + \", cause: \" + e.getMessage(), e);\n                }\n            }\n            if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class\n                    || type == java.time.LocalTime.class) {\n\n                LocalDateTime localDateTime = LocalDateTime.parse(string);\n                if (type == java.time.LocalDate.class) {\n                    return localDateTime.toLocalDate();\n                }\n                if (type == java.time.LocalTime.class) {\n                    return localDateTime.toLocalTime();\n                }\n                return localDateTime;\n            }\n            if (type == Class.class) {\n                try {\n                    return ReflectUtils.name2class(string);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n            if (char[].class.equals(type)) {\n                // Process string to char array for generic invoke\n                // See\n                // - https://github.com/apache/dubbo/issues/2003\n                int len = string.length();\n                char[] chars = new char[len];\n                string.getChars(0, len, chars, 0);\n                return chars;\n            }\n        }\n        if (value instanceof Number) {\n            Number number = (Number) value;\n            if (type == byte.class || type == Byte.class) {\n                return number.byteValue();\n            }\n            if (type == short.class || type == Short.class) {\n                return number.shortValue();\n            }\n            if (type == int.class || type == Integer.class) {\n                return number.intValue();\n            }\n            if (type == long.class || type == Long.class) {\n                return number.longValue();\n            }\n            if (type == float.class || type == Float.class) {\n                return number.floatValue();\n            }\n            if (type == double.class || type == Double.class) {\n                return number.doubleValue();\n            }\n            if (type == BigInteger.class) {\n                return BigInteger.valueOf(number.longValue());\n            }\n            if (type == BigDecimal.class) {\n                return BigDecimal.valueOf(number.doubleValue());\n            }\n            if (type == Date.class) {\n                return new Date(number.longValue());\n            }\n            if (type == boolean.class || type == Boolean.class) {\n                return 0 != number.intValue();\n            }\n        }\n        if (value instanceof Collection) {\n            Collection collection = (Collection) value;\n            if (type.isArray()) {\n                int length = collection.size();\n                Object array = Array.newInstance(type.getComponentType(), length);\n                int i = 0;\n                for (Object item : collection) {\n                    Array.set(array, i++, item);\n                }\n                return array;\n            }\n            if (!type.isInterface()) {\n                try {\n                    Collection result = (Collection) type.newInstance();\n                    result.addAll(collection);\n                    return result;\n                } catch (Throwable ignored) {\n                }\n            }\n            if (type == List.class) {\n                return new ArrayList<Object>(collection);\n            }\n            if (type == Set.class) {\n                return new HashSet<Object>(collection);\n            }\n        }\n        if (value.getClass().isArray() && Collection.class.isAssignableFrom(type)) {\n            Collection collection;\n            if (!type.isInterface()) {\n                try {\n                    collection = (Collection) type.newInstance();\n                } catch (Throwable e) {\n                    collection = new ArrayList<Object>();\n                }\n            } else if (type == Set.class) {\n                collection = new HashSet<Object>();\n            } else {\n                collection = new ArrayList<Object>();\n            }\n            int length = Array.getLength(value);\n            for (int i = 0; i < length; i++) {\n                collection.add(Array.get(value, i));\n            }\n            return collection;\n        }\n        return value;\n    }", "signature": "Object compatibleTypeConvert(Object value, Class<?> type)", "full_signature": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) public static Object compatibleTypeConvert(Object value, Class<?> type)", "class_method_signature": "CompatibleTypeUtils.compatibleTypeConvert(Object value, Class<?> type)", "testcase": false, "constructor": false, "invocations": ["isAssignableFrom", "getClass", "equals", "equals", "length", "format", "charAt", "isEnum", "valueOf", "valueOf", "parse", "getTime", "getTime", "getTime", "getMessage", "parse", "toLocalDate", "toLocalTime", "name2class", "getMessage", "equals", "length", "getChars", "byteValue", "shortValue", "intValue", "longValue", "floatValue", "doubleValue", "valueOf", "longValue", "valueOf", "doubleValue", "longValue", "intValue", "isArray", "size", "newInstance", "getComponentType", "set", "isInterface", "newInstance", "addAll", "isArray", "getClass", "isAssignableFrom", "isInterface", "newInstance", "getLength", "add", "get"]}, "repository": {"repo_id": 4710920, "url": "https://github.com/apache/dubbo", "stars": 30960, "created": "6/19/2012 7:56:02 AM +00:00", "updates": "2020-01-27T14:21:03+00:00", "fork": "False", "license": "licensed"}}