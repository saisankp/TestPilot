{"test_class": {"identifier": "AdVpnThreadTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private AdVpnService service;", "modifier": "private", "type": "AdVpnService", "declarator": "service", "var_name": "service"}, {"original_string": "private AdVpnThread thread;", "modifier": "private", "type": "AdVpnThread", "declarator": "thread", "var_name": "thread"}, {"original_string": "private Configuration config;", "modifier": "private", "type": "Configuration", "declarator": "config", "var_name": "config"}, {"original_string": "private VpnService.Builder builder;", "modifier": "private", "type": "VpnService.Builder", "declarator": "builder", "var_name": "builder"}, {"original_string": "private List<InetAddress> serversAdded;", "modifier": "private", "type": "List<InetAddress>", "declarator": "serversAdded", "var_name": "serversAdded"}], "file": "app/src/test/java/org/jak_linux/dns66/vpn/AdVpnThreadTest.java"}, "test_case": {"identifier": "testConfigurePackages", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testConfigurePackages() throws Exception {\n        final List<String> disallowed = new ArrayList<>();\n        final List<String> allowed = new ArrayList<>();\n        when(builder.addDisallowedApplication(anyString())).thenAnswer(new Answer<Object>() {\n            @Override\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                disallowed.add(invocation.getArgumentAt(0, String.class));\n                return null;\n            }\n        });\n        when(builder.addAllowedApplication(anyString())).thenAnswer(new Answer<Object>() {\n            @Override\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                allowed.add(invocation.getArgumentAt(0, String.class));\n                return null;\n            }\n        });\n\n        // We are defaulting to disallow: allow all allowed packages.\n        allowed.clear();\n        disallowed.clear();\n        config.whitelist.defaultMode = Configuration.Whitelist.DEFAULT_MODE_NOT_ON_VPN;\n        thread.configurePackages(builder, config);\n        assertTrue(allowed.contains(\"onVpn\"));\n        assertEquals(new ArrayList<String>(), disallowed);\n\n        // We are defaulting to allow: deny all non-allowed packages.\n        allowed.clear();\n        disallowed.clear();\n        config.whitelist.defaultMode = Configuration.Whitelist.DEFAULT_MODE_ON_VPN;\n        thread.configurePackages(builder, config);\n        assertTrue(disallowed.contains(\"notOnVpn\"));\n        assertEquals(new ArrayList<String>(), allowed);\n\n        // Intelligent is like allow, it only disallows system apps\n        allowed.clear();\n        disallowed.clear();\n        config.whitelist.defaultMode = Configuration.Whitelist.DEFAULT_MODE_INTELLIGENT;\n        thread.configurePackages(builder, config);\n        assertTrue(disallowed.contains(\"notOnVpn\"));\n        assertEquals(new ArrayList<String>(), allowed);\n\n    }", "signature": "void testConfigurePackages()", "full_signature": "@Test public void testConfigurePackages()", "class_method_signature": "AdVpnThreadTest.testConfigurePackages()", "testcase": true, "constructor": false, "invocations": ["thenAnswer", "when", "addDisallowedApplication", "anyString", "add", "getArgumentAt", "thenAnswer", "when", "addAllowedApplication", "anyString", "add", "getArgumentAt", "clear", "clear", "configurePackages", "assertTrue", "contains", "assertEquals", "clear", "clear", "configurePackages", "assertTrue", "contains", "assertEquals", "clear", "clear", "configurePackages", "assertTrue", "contains", "assertEquals"]}, "focal_class": {"identifier": "AdVpnThread", "superclass": "", "interfaces": "implements Runnable, DnsPacketProxy.EventLoop", "fields": [{"original_string": "private static final String TAG = \"AdVpnThread\";", "modifier": "private static final", "type": "String", "declarator": "TAG = \"AdVpnThread\"", "var_name": "TAG"}, {"original_string": "private static final int MIN_RETRY_TIME = 5;", "modifier": "private static final", "type": "int", "declarator": "MIN_RETRY_TIME = 5", "var_name": "MIN_RETRY_TIME"}, {"original_string": "private static final int MAX_RETRY_TIME = 2 * 60;", "modifier": "private static final", "type": "int", "declarator": "MAX_RETRY_TIME = 2 * 60", "var_name": "MAX_RETRY_TIME"}, {"original_string": "private static final long RETRY_RESET_SEC = 60;", "modifier": "private static final", "type": "long", "declarator": "RETRY_RESET_SEC = 60", "var_name": "RETRY_RESET_SEC"}, {"original_string": "private static final int DNS_MAXIMUM_WAITING = 1024;", "modifier": "private static final", "type": "int", "declarator": "DNS_MAXIMUM_WAITING = 1024", "var_name": "DNS_MAXIMUM_WAITING"}, {"original_string": "private static final long DNS_TIMEOUT_SEC = 10;", "modifier": "private static final", "type": "long", "declarator": "DNS_TIMEOUT_SEC = 10", "var_name": "DNS_TIMEOUT_SEC"}, {"original_string": "final ArrayList<InetAddress> upstreamDnsServers = new ArrayList<>();", "modifier": "final", "type": "ArrayList<InetAddress>", "declarator": "upstreamDnsServers = new ArrayList<>()", "var_name": "upstreamDnsServers"}, {"original_string": "private final VpnService vpnService;", "modifier": "private final", "type": "VpnService", "declarator": "vpnService", "var_name": "vpnService"}, {"original_string": "private final Notify notify;", "modifier": "private final", "type": "Notify", "declarator": "notify", "var_name": "notify"}, {"original_string": "private final Queue<byte[]> deviceWrites = new LinkedList<>();", "modifier": "private final", "type": "Queue<byte[]>", "declarator": "deviceWrites = new LinkedList<>()", "var_name": "deviceWrites"}, {"original_string": "private final WospList dnsIn = new WospList();", "modifier": "private final", "type": "WospList", "declarator": "dnsIn = new WospList()", "var_name": "dnsIn"}, {"original_string": "private final DnsPacketProxy dnsPacketProxy = new DnsPacketProxy(this);", "modifier": "private final", "type": "DnsPacketProxy", "declarator": "dnsPacketProxy = new DnsPacketProxy(this)", "var_name": "dnsPacketProxy"}, {"original_string": "private final VpnWatchdog vpnWatchDog = new VpnWatchdog();", "modifier": "private final", "type": "VpnWatchdog", "declarator": "vpnWatchDog = new VpnWatchdog()", "var_name": "vpnWatchDog"}, {"original_string": "private Thread thread = null;", "modifier": "private", "type": "Thread", "declarator": "thread = null", "var_name": "thread"}, {"original_string": "private FileDescriptor mBlockFd = null;", "modifier": "private", "type": "FileDescriptor", "declarator": "mBlockFd = null", "var_name": "mBlockFd"}, {"original_string": "private FileDescriptor mInterruptFd = null;", "modifier": "private", "type": "FileDescriptor", "declarator": "mInterruptFd = null", "var_name": "mInterruptFd"}, {"original_string": "private int pcap4jFactoryClearCacheCounter = 0;", "modifier": "private", "type": "int", "declarator": "pcap4jFactoryClearCacheCounter = 0", "var_name": "pcap4jFactoryClearCacheCounter"}], "methods": [{"identifier": "AdVpnThread", "parameters": "(VpnService vpnService, Notify notify)", "modifiers": "public", "return": "", "signature": " AdVpnThread(VpnService vpnService, Notify notify)", "full_signature": "public  AdVpnThread(VpnService vpnService, Notify notify)", "class_method_signature": "AdVpnThread.AdVpnThread(VpnService vpnService, Notify notify)", "testcase": false, "constructor": true}, {"identifier": "getDnsServers", "parameters": "(Context context)", "modifiers": "private static", "return": "List<InetAddress>", "signature": "List<InetAddress> getDnsServers(Context context)", "full_signature": "private static List<InetAddress> getDnsServers(Context context)", "class_method_signature": "AdVpnThread.getDnsServers(Context context)", "testcase": false, "constructor": false}, {"identifier": "startThread", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void startThread()", "full_signature": "public void startThread()", "class_method_signature": "AdVpnThread.startThread()", "testcase": false, "constructor": false}, {"identifier": "stopThread", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void stopThread()", "full_signature": "public void stopThread()", "class_method_signature": "AdVpnThread.stopThread()", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void run()", "full_signature": "@Override public synchronized void run()", "class_method_signature": "AdVpnThread.run()", "testcase": false, "constructor": false}, {"identifier": "runVpn", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void runVpn()", "full_signature": "private void runVpn()", "class_method_signature": "AdVpnThread.runVpn()", "testcase": false, "constructor": false}, {"identifier": "doOne", "parameters": "(FileInputStream inputStream, FileOutputStream outFd, byte[] packet)", "modifiers": "private", "return": "boolean", "signature": "boolean doOne(FileInputStream inputStream, FileOutputStream outFd, byte[] packet)", "full_signature": "private boolean doOne(FileInputStream inputStream, FileOutputStream outFd, byte[] packet)", "class_method_signature": "AdVpnThread.doOne(FileInputStream inputStream, FileOutputStream outFd, byte[] packet)", "testcase": false, "constructor": false}, {"identifier": "writeToDevice", "parameters": "(FileOutputStream outFd)", "modifiers": "private", "return": "void", "signature": "void writeToDevice(FileOutputStream outFd)", "full_signature": "private void writeToDevice(FileOutputStream outFd)", "class_method_signature": "AdVpnThread.writeToDevice(FileOutputStream outFd)", "testcase": false, "constructor": false}, {"identifier": "readPacketFromDevice", "parameters": "(FileInputStream inputStream, byte[] packet)", "modifiers": "private", "return": "void", "signature": "void readPacketFromDevice(FileInputStream inputStream, byte[] packet)", "full_signature": "private void readPacketFromDevice(FileInputStream inputStream, byte[] packet)", "class_method_signature": "AdVpnThread.readPacketFromDevice(FileInputStream inputStream, byte[] packet)", "testcase": false, "constructor": false}, {"identifier": "forwardPacket", "parameters": "(DatagramPacket outPacket, IpPacket parsedPacket)", "modifiers": "public", "return": "void", "signature": "void forwardPacket(DatagramPacket outPacket, IpPacket parsedPacket)", "full_signature": "public void forwardPacket(DatagramPacket outPacket, IpPacket parsedPacket)", "class_method_signature": "AdVpnThread.forwardPacket(DatagramPacket outPacket, IpPacket parsedPacket)", "testcase": false, "constructor": false}, {"identifier": "handleRawDnsResponse", "parameters": "(IpPacket parsedPacket, DatagramSocket dnsSocket)", "modifiers": "private", "return": "void", "signature": "void handleRawDnsResponse(IpPacket parsedPacket, DatagramSocket dnsSocket)", "full_signature": "private void handleRawDnsResponse(IpPacket parsedPacket, DatagramSocket dnsSocket)", "class_method_signature": "AdVpnThread.handleRawDnsResponse(IpPacket parsedPacket, DatagramSocket dnsSocket)", "testcase": false, "constructor": false}, {"identifier": "queueDeviceWrite", "parameters": "(IpPacket ipOutPacket)", "modifiers": "public", "return": "void", "signature": "void queueDeviceWrite(IpPacket ipOutPacket)", "full_signature": "public void queueDeviceWrite(IpPacket ipOutPacket)", "class_method_signature": "AdVpnThread.queueDeviceWrite(IpPacket ipOutPacket)", "testcase": false, "constructor": false}, {"identifier": "newDNSServer", "parameters": "(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "modifiers": "", "return": "void", "signature": "void newDNSServer(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "full_signature": " void newDNSServer(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "class_method_signature": "AdVpnThread.newDNSServer(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "testcase": false, "constructor": false}, {"identifier": "configurePackages", "parameters": "(VpnService.Builder builder, Configuration config)", "modifiers": "", "return": "void", "signature": "void configurePackages(VpnService.Builder builder, Configuration config)", "full_signature": " void configurePackages(VpnService.Builder builder, Configuration config)", "class_method_signature": "AdVpnThread.configurePackages(VpnService.Builder builder, Configuration config)", "testcase": false, "constructor": false}, {"identifier": "configure", "parameters": "()", "modifiers": "private", "return": "ParcelFileDescriptor", "signature": "ParcelFileDescriptor configure()", "full_signature": "private ParcelFileDescriptor configure()", "class_method_signature": "AdVpnThread.configure()", "testcase": false, "constructor": false}, {"identifier": "hasIpV6Servers", "parameters": "(Configuration config, List<InetAddress> dnsServers)", "modifiers": "", "return": "boolean", "signature": "boolean hasIpV6Servers(Configuration config, List<InetAddress> dnsServers)", "full_signature": " boolean hasIpV6Servers(Configuration config, List<InetAddress> dnsServers)", "class_method_signature": "AdVpnThread.hasIpV6Servers(Configuration config, List<InetAddress> dnsServers)", "testcase": false, "constructor": false}], "file": "app/src/main/java/org/jak_linux/dns66/vpn/AdVpnThread.java"}, "focal_method": {"identifier": "configurePackages", "parameters": "(VpnService.Builder builder, Configuration config)", "modifiers": "", "return": "void", "body": "void configurePackages(VpnService.Builder builder, Configuration config) {\n        Set<String> allowOnVpn = new HashSet<>();\n        Set<String> doNotAllowOnVpn = new HashSet<>();\n\n        config.whitelist.resolve(vpnService.getPackageManager(), allowOnVpn, doNotAllowOnVpn);\n\n        if (config.whitelist.defaultMode == Configuration.Whitelist.DEFAULT_MODE_NOT_ON_VPN) {\n            for (String app : allowOnVpn) {\n                try {\n                    Log.d(TAG, \"configure: Allowing \" + app + \" to use the DNS VPN\");\n                    builder.addAllowedApplication(app);\n                } catch (Exception e) {\n                    Log.w(TAG, \"configure: Cannot disallow\", e);\n                }\n            }\n        } else {\n            for (String app : doNotAllowOnVpn) {\n                try {\n                    Log.d(TAG, \"configure: Disallowing \" + app + \" from using the DNS VPN\");\n                    builder.addDisallowedApplication(app);\n                } catch (Exception e) {\n                    Log.w(TAG, \"configure: Cannot disallow\", e);\n                }\n            }\n        }\n    }", "signature": "void configurePackages(VpnService.Builder builder, Configuration config)", "full_signature": " void configurePackages(VpnService.Builder builder, Configuration config)", "class_method_signature": "AdVpnThread.configurePackages(VpnService.Builder builder, Configuration config)", "testcase": false, "constructor": false, "invocations": ["resolve", "getPackageManager", "d", "addAllowedApplication", "w", "d", "addDisallowedApplication", "w"]}, "repository": {"repo_id": 70996010, "url": "https://github.com/julian-klode/dns66", "stars": 1372, "created": "10/15/2016 3:27:17 PM +00:00", "updates": "2020-01-26T10:51:30+00:00", "fork": "False", "license": "licensed"}}