{"test_class": {"identifier": "AnalyserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int NUMBER_OF_NO_RUN_BUILDS_IN_SEQUENCE = 15;", "modifier": "public static final", "type": "int", "declarator": "NUMBER_OF_NO_RUN_BUILDS_IN_SEQUENCE = 15", "var_name": "NUMBER_OF_NO_RUN_BUILDS_IN_SEQUENCE"}, {"original_string": "private TestName test1TestName;", "modifier": "private", "type": "TestName", "declarator": "test1TestName", "var_name": "test1TestName"}, {"original_string": "private TestName test2TestName;", "modifier": "private", "type": "TestName", "declarator": "test2TestName", "var_name": "test2TestName"}, {"original_string": "private STestRun test1STestRun;", "modifier": "private", "type": "STestRun", "declarator": "test1STestRun", "var_name": "test1STestRun"}, {"original_string": "private STest test1STest;", "modifier": "private", "type": "STest", "declarator": "test1STest", "var_name": "test1STest"}, {"original_string": "private TestInfo test1FailureTestInfo;", "modifier": "private", "type": "TestInfo", "declarator": "test1FailureTestInfo", "var_name": "test1FailureTestInfo"}, {"original_string": "private STestRun test2STestRun;", "modifier": "private", "type": "STestRun", "declarator": "test2STestRun", "var_name": "test2STestRun"}, {"original_string": "private STest test2STest;", "modifier": "private", "type": "STest", "declarator": "test2STest", "var_name": "test2STest"}, {"original_string": "private TestInfo test2FailureTestInfo;", "modifier": "private", "type": "TestInfo", "declarator": "test2FailureTestInfo", "var_name": "test2FailureTestInfo"}, {"original_string": "private BuildStatistics buildStatisticsGood;", "modifier": "private", "type": "BuildStatistics", "declarator": "buildStatisticsGood", "var_name": "buildStatisticsGood"}, {"original_string": "private BuildStatistics buildStatisticsNoRun;", "modifier": "private", "type": "BuildStatistics", "declarator": "buildStatisticsNoRun", "var_name": "buildStatisticsNoRun"}, {"original_string": "private SVcsModification change0;", "modifier": "private", "type": "SVcsModification", "declarator": "change0", "var_name": "change0"}, {"original_string": "private SVcsModification change1;", "modifier": "private", "type": "SVcsModification", "declarator": "change1", "var_name": "change1"}, {"original_string": "private SVcsModification change2;", "modifier": "private", "type": "SVcsModification", "declarator": "change2", "var_name": "change2"}, {"original_string": "private SFinishedBuild buildGood;", "modifier": "private", "type": "SFinishedBuild", "declarator": "buildGood", "var_name": "buildGood"}, {"original_string": "private SFinishedBuild buildBad1;", "modifier": "private", "type": "SFinishedBuild", "declarator": "buildBad1", "var_name": "buildBad1"}, {"original_string": "private SFinishedBuild buildBad2;", "modifier": "private", "type": "SFinishedBuild", "declarator": "buildBad2", "var_name": "buildBad2"}, {"original_string": "private SFinishedBuild buildNoRun;", "modifier": "private", "type": "SFinishedBuild", "declarator": "buildNoRun", "var_name": "buildNoRun"}, {"original_string": "private List<SFinishedBuild> buildNoRunSequence;", "modifier": "private", "type": "List<SFinishedBuild>", "declarator": "buildNoRunSequence", "var_name": "buildNoRunSequence"}, {"original_string": "private Mockery mockery;", "modifier": "private", "type": "Mockery", "declarator": "mockery", "var_name": "mockery"}], "file": "sin-city-server/src/test/java/sferencik/teamcity/sincity/failureCulpritOverview/AnalyserTest.java"}, "test_case": {"identifier": "test03NoChangeOneBuild", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void test03NoChangeOneBuild() {\n        /*\n            A trivial history:\n                * change0     -> buildGood[success1]\n                * [no change] -> buildBad1[failure1]\n\n            gives the following culprit table:\n\n                      | buildBad1\n                      | no change\n             ---------+----------\n             failure1 | buildBad1\n         */\n\n        // arrange\n        mockery.checking(new Expectations() {{\n            allowing(buildBad1).getTestMessages(0, -1); will(returnValue(Collections.singletonList(test1FailureTestInfo)));\n            allowing(test1FailureTestInfo).getTestName(); will(returnValue(test1TestName));\n\n            allowing(buildGood).getTestMessages(0, -1); will(returnValue(Collections.emptyList()));\n            allowing(buildGood).getBuildStatistics(BuildStatisticsOptions.ALL_TESTS_NO_DETAILS); will(returnValue(buildStatisticsGood));\n            allowing(buildStatisticsGood).getAllTests(); will(returnValue(Collections.singletonList(test1STestRun)));\n            allowing(test1STestRun).getTest(); will(returnValue(test1STest));\n            allowing(test1STest).getName(); will(returnValue(test1TestName));\n        }});\n\n        // act\n        Table culpritTable = Analyser.createCulpritMatrix(Arrays.asList(\n                new FinishedBuildWithChanges(buildBad1, change0, Collections.<SVcsModification>emptyList()),\n                new FinishedBuildWithChanges(buildGood, change0, Collections.<SVcsModification>emptyList())));\n\n        // assert\n        assertThat(culpritTable.getNumberOfColumns(), is(1));\n\n        assertThat(culpritTable.getNumberOfRows(), is(1));\n\n        assertThat(culpritTable.getBuildRowCell(0).getContent().getBuild(), is(buildBad1));\n        assertThat(culpritTable.getBuildRowCell(0).getColspan(), is(1));\n\n        assertThat(culpritTable.getChangeRowCell(0).getContent(), nullValue());  // note the null\n        assertThat(culpritTable.getChangeRowCell(0).getColspan(), is(1));\n\n        assertThat(culpritTable.getFailureColumnCell(0).getContent(), is(test1TestName));\n        assertThat(culpritTable.getFailureColumnCell(0).getColspan(), is(1));\n\n        assertThat(culpritTable.getCell(0, 0).getContent().getBuild(), is(buildBad1));\n        assertThat(culpritTable.getCell(0, 0).getColspan(), is(1));\n    }", "signature": "void test03NoChangeOneBuild()", "full_signature": "@Test public void test03NoChangeOneBuild()", "class_method_signature": "AnalyserTest.test03NoChangeOneBuild()", "testcase": true, "constructor": false, "invocations": ["checking", "getTestMessages", "allowing", "will", "returnValue", "singletonList", "getTestName", "allowing", "will", "returnValue", "getTestMessages", "allowing", "will", "returnValue", "emptyList", "getBuildStatistics", "allowing", "will", "returnValue", "getAllTests", "allowing", "will", "returnValue", "singletonList", "getTest", "allowing", "will", "returnValue", "getName", "allowing", "will", "returnValue", "createCulpritMatrix", "asList", "emptyList", "emptyList", "assertThat", "getNumberOfColumns", "is", "assertThat", "getNumberOfRows", "is", "assertThat", "getBuild", "getContent", "getBuildRowCell", "is", "assertThat", "getColspan", "getBuildRowCell", "is", "assertThat", "getContent", "getChangeRowCell", "nullValue", "assertThat", "getColspan", "getChangeRowCell", "is", "assertThat", "getContent", "getFailureColumnCell", "is", "assertThat", "getColspan", "getFailureColumnCell", "is", "assertThat", "getBuild", "getContent", "getCell", "is", "assertThat", "getColspan", "getCell", "is"]}, "focal_class": {"identifier": "Analyser", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "createCulpritMatrix", "parameters": "(List<FinishedBuildWithChanges> buildsWithContainingChanges)", "modifiers": "@NotNull public static", "return": "Table", "signature": "Table createCulpritMatrix(List<FinishedBuildWithChanges> buildsWithContainingChanges)", "full_signature": "@NotNull public static Table createCulpritMatrix(List<FinishedBuildWithChanges> buildsWithContainingChanges)", "class_method_signature": "Analyser.createCulpritMatrix(List<FinishedBuildWithChanges> buildsWithContainingChanges)", "testcase": false, "constructor": false}, {"identifier": "getMaxNumberOfConsecutiveBuildsWithoutNewInfo", "parameters": "()", "modifiers": "static", "return": "int", "signature": "int getMaxNumberOfConsecutiveBuildsWithoutNewInfo()", "full_signature": "static int getMaxNumberOfConsecutiveBuildsWithoutNewInfo()", "class_method_signature": "Analyser.getMaxNumberOfConsecutiveBuildsWithoutNewInfo()", "testcase": false, "constructor": false}], "file": "sin-city-server/src/main/java/sferencik/teamcity/sincity/failureCulpritOverview/Analyser.java"}, "focal_method": {"identifier": "createCulpritMatrix", "parameters": "(List<FinishedBuildWithChanges> buildsWithContainingChanges)", "modifiers": "@NotNull public static", "return": "Table", "body": "@NotNull\n    public static Table createCulpritMatrix(List<FinishedBuildWithChanges> buildsWithContainingChanges) {\n        if (buildsWithContainingChanges.size() == 0) {\n            // there are no builds and thus no outstanding failuresInMostRecentBuild\n            return new Table(\n                    new ArrayList<TestName>(),\n                    new ArrayList<FinishedBuildWithChanges>(),\n                    new HashMap<TestName, FinishedBuildWithChanges>(),\n                    new HashMap<TestName, Set<FinishedBuildWithChanges>>());\n        }\n\n        // the outstanding test failures that the overview tab will help diagnose; get them from the last build\n        List<TestName> failuresInMostRecentBuild = new ArrayList<TestName>();\n        for (TestName testFailure : SinCityUtils.getNamesOfFailingTests(buildsWithContainingChanges.get(0).getBuild())) {\n            failuresInMostRecentBuild.add(testFailure);\n        }\n\n        // the build(s) suspected of causing each test failure\n        Map<TestName, Set<FinishedBuildWithChanges>> buildsSuspectedOfCausingFailure = new HashMap<TestName, Set<FinishedBuildWithChanges>>();\n\n        // the build in which the test failure first occurred\n        Map<TestName, FinishedBuildWithChanges> buildInWhichFailureFirstOccurred = new HashMap<TestName, FinishedBuildWithChanges>();\n\n        // the test failures which the build is suspected of causing\n        Map<FinishedBuildWithChanges, Set<TestName>> failuresSuspectedToBeCausedByBuild = new LinkedHashMap<FinishedBuildWithChanges, Set<TestName>>();\n\n        HashSet<TestName> issuesNotYetClarified = new HashSet<TestName>(failuresInMostRecentBuild);\n        int consecutiveBuildsWithoutNewInfo = 0;   // how many builds have we gone without seeing any new info?\n\n        for (FinishedBuildWithChanges build : buildsWithContainingChanges) {\n            FinishedBuildTestInfo buildTestInfo = new FinishedBuildTestInfo(build.getBuild());\n\n            consecutiveBuildsWithoutNewInfo++;\n\n            // use an explicit iterator so I can remove from the set while iterating it\n            Iterator<TestName> issuesNotYetClarifiedIterator = issuesNotYetClarified.iterator();\n            while (issuesNotYetClarifiedIterator.hasNext()) {\n                TestName testFailure = issuesNotYetClarifiedIterator.next();\n\n                if (buildTestInfo.testFailed(testFailure)) {\n                    // the test failure occurred in this build (the build problem occurred/the test failed)\n\n                    // absolve the previous suspects\n                    if (buildsSuspectedOfCausingFailure.containsKey(testFailure)) {\n                        for (FinishedBuildWithChanges previousSuspectBuild : buildsSuspectedOfCausingFailure.get(testFailure)) {\n                            failuresSuspectedToBeCausedByBuild.get(previousSuspectBuild).remove(testFailure);\n                            if (failuresSuspectedToBeCausedByBuild.get(previousSuspectBuild).isEmpty()) {\n                                // this build has been absolved of all blame\n                                failuresSuspectedToBeCausedByBuild.remove(previousSuspectBuild);\n                            }\n                        }\n                    }\n\n                    // take note of this build where the test failure occurred\n                    buildInWhichFailureFirstOccurred.put(testFailure, build);\n\n                    // add this test failure to the blame list for this build\n                    if (!failuresSuspectedToBeCausedByBuild.containsKey(build)) {\n                        failuresSuspectedToBeCausedByBuild.put(build, new HashSet<TestName>());\n                    }\n                    failuresSuspectedToBeCausedByBuild.get(build).add(testFailure);\n                    buildsSuspectedOfCausingFailure.put(testFailure, new HashSet<FinishedBuildWithChanges>(Collections.singletonList(build)));\n\n                    consecutiveBuildsWithoutNewInfo = 0;\n                }\n                else if (buildTestInfo.testSucceeded(testFailure)) {\n                    // the test failure didn't occur in this build (the test passed); the investigation is now complete;\n                    // the list of suspects is final\n                    issuesNotYetClarifiedIterator.remove();\n\n                    consecutiveBuildsWithoutNewInfo = 0;\n                }\n                else {\n                    // the test failure didn't exhibit itself but it seems the test never ran either; this may be due to\n                    // several reasons:\n                    // i)   the test is new and it's been failing from the start; we're now going down the history of\n                    //      builds where the test didn't even exist yet; we could go all the way to the Big Bang and\n                    //      find nothing\n                    // ii)  the build may have failed before running the test; again, in this case we should find the\n                    //      test (passing or failing) further back in the history and decide based on that\n                    // iii) the test existed as of this version but we didn't run it, possibly because someone had\n                    //      somehow skipped it (we actually suggest running only a subset of tests in README.md when\n                    //      explaining the meaning of the %sincity.test.failure.json% parameter; if this is implemented\n                    //      and the culprit-finding builds only rerun the new failures, the old failures won't make an\n                    //      appearance in the culprit-finding builds at all - and yet they predate these builds); in\n                    //      this case we should find the test (passing or failing) further back in the history and\n                    //      decide based on that\n                    // at any rate, this build's changes must be treated as suspect\n\n                    // add this testFailure to the blame list for this build\n                    if (!failuresSuspectedToBeCausedByBuild.containsKey(build)) {\n                        failuresSuspectedToBeCausedByBuild.put(build, new HashSet<TestName>());\n                    }\n                    failuresSuspectedToBeCausedByBuild.get(build).add(testFailure);\n                    buildsSuspectedOfCausingFailure.get(testFailure).add(build);\n                }\n            }\n\n            if (consecutiveBuildsWithoutNewInfo >= getMaxNumberOfConsecutiveBuildsWithoutNewInfo())\n                break;\n        }\n\n        return new Table(\n                failuresInMostRecentBuild,\n                new ArrayList<FinishedBuildWithChanges>(failuresSuspectedToBeCausedByBuild.keySet()),\n                buildInWhichFailureFirstOccurred,\n                buildsSuspectedOfCausingFailure\n        );\n    }", "signature": "Table createCulpritMatrix(List<FinishedBuildWithChanges> buildsWithContainingChanges)", "full_signature": "@NotNull public static Table createCulpritMatrix(List<FinishedBuildWithChanges> buildsWithContainingChanges)", "class_method_signature": "Analyser.createCulpritMatrix(List<FinishedBuildWithChanges> buildsWithContainingChanges)", "testcase": false, "constructor": false, "invocations": ["size", "getNamesOfFailingTests", "getBuild", "get", "add", "getBuild", "iterator", "hasNext", "next", "testFailed", "containsKey", "get", "remove", "get", "isEmpty", "get", "remove", "put", "containsKey", "put", "add", "get", "put", "singletonList", "testSucceeded", "remove", "containsKey", "put", "add", "get", "add", "get", "getMaxNumberOfConsecutiveBuildsWithoutNewInfo", "keySet"]}, "repository": {"repo_id": 39228827, "url": "https://github.com/sferencik/SinCity", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 561, "license": "licensed"}}