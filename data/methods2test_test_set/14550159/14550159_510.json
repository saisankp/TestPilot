{"test_class": {"identifier": "HeaderHelperTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n    public ExpectedException thrown = ExpectedException.none();", "modifier": "@Rule\n    public", "type": "ExpectedException", "declarator": "thrown = ExpectedException.none()", "var_name": "thrown"}], "file": "everrest-core/src/test/java/org/everrest/core/impl/header/HeaderHelperTest.java"}, "test_case": {"identifier": "parsesNewCookies", "parameters": "(String cookieHeader, NewCookie expectedNewCookie)", "modifiers": "@UseDataProvider(\"forParsesNewCookies\") @Test public", "return": "void", "body": "@UseDataProvider(\"forParsesNewCookies\")\n    @Test\n    public void parsesNewCookies(String cookieHeader, NewCookie expectedNewCookie) {\n        NewCookie newCookie = HeaderHelper.parseNewCookie(cookieHeader);\n\n        assertNotNull(newCookie);\n        assertEquals(expectedNewCookie.getName(), newCookie.getName());\n        assertEquals(expectedNewCookie.getValue(), newCookie.getValue());\n        if (expectedNewCookie.getExpiry() != null) {\n            assertTrue(String.format(\"Expiry dates are not equal. Expected %s, actual %s\", expectedNewCookie.getExpiry(), newCookie.getExpiry()),\n                       Math.abs(expectedNewCookie.getExpiry().getTime() - newCookie.getExpiry().getTime()) < 1000);\n        }\n        assertEquals(expectedNewCookie.getMaxAge(), newCookie.getMaxAge());\n        assertEquals(expectedNewCookie.getPath(), newCookie.getPath());\n        assertEquals(expectedNewCookie.getDomain(), newCookie.getDomain());\n        assertEquals(expectedNewCookie.getComment(), newCookie.getComment());\n        assertEquals(expectedNewCookie.getVersion(), newCookie.getVersion());\n        assertEquals(expectedNewCookie.isSecure(), newCookie.isSecure());\n        assertEquals(expectedNewCookie.isHttpOnly(), newCookie.isHttpOnly());\n    }", "signature": "void parsesNewCookies(String cookieHeader, NewCookie expectedNewCookie)", "full_signature": "@UseDataProvider(\"forParsesNewCookies\") @Test public void parsesNewCookies(String cookieHeader, NewCookie expectedNewCookie)", "class_method_signature": "HeaderHelperTest.parsesNewCookies(String cookieHeader, NewCookie expectedNewCookie)", "testcase": true, "constructor": false, "invocations": ["parseNewCookie", "assertNotNull", "assertEquals", "getName", "getName", "assertEquals", "getValue", "getValue", "getExpiry", "assertTrue", "format", "getExpiry", "getExpiry", "abs", "getTime", "getExpiry", "getTime", "getExpiry", "assertEquals", "getMaxAge", "getMaxAge", "assertEquals", "getPath", "getPath", "assertEquals", "getDomain", "getDomain", "assertEquals", "getComment", "getComment", "assertEquals", "getVersion", "getVersion", "assertEquals", "isSecure", "isSecure", "assertEquals", "isHttpOnly", "isHttpOnly"]}, "focal_class": {"identifier": "HeaderHelper", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Pattern WHITESPACE_QUOTE_PATTERN = Pattern.compile(\"[\\\\s\\\"]\");", "modifier": "private static final", "type": "Pattern", "declarator": "WHITESPACE_QUOTE_PATTERN = Pattern.compile(\"[\\\\s\\\"]\")", "var_name": "WHITESPACE_QUOTE_PATTERN"}, {"original_string": "private static final Pattern WHITESPACE_PATTERN = Pattern.compile(\"\\\\s\");", "modifier": "private static final", "type": "Pattern", "declarator": "WHITESPACE_PATTERN = Pattern.compile(\"\\\\s\")", "var_name": "WHITESPACE_PATTERN"}, {"original_string": "private static final boolean[] SEPARATORS = new boolean[128];", "modifier": "private static final", "type": "boolean[]", "declarator": "SEPARATORS = new boolean[128]", "var_name": "SEPARATORS"}, {"original_string": "private static final List<AcceptMediaType> ACCEPT_ALL_MEDIA_TYPE = Collections.singletonList(AcceptMediaType.DEFAULT);", "modifier": "private static final", "type": "List<AcceptMediaType>", "declarator": "ACCEPT_ALL_MEDIA_TYPE = Collections.singletonList(AcceptMediaType.DEFAULT)", "var_name": "ACCEPT_ALL_MEDIA_TYPE"}, {"original_string": "private static final List<AcceptLanguage> ACCEPT_ALL_LANGUAGE = Collections.singletonList(AcceptLanguage.DEFAULT);", "modifier": "private static final", "type": "List<AcceptLanguage>", "declarator": "ACCEPT_ALL_LANGUAGE = Collections.singletonList(AcceptLanguage.DEFAULT)", "var_name": "ACCEPT_ALL_LANGUAGE"}, {"original_string": "private static final List<AcceptToken> ACCEPT_ALL_TOKENS = Collections.singletonList(new AcceptToken(\"*\"));", "modifier": "private static final", "type": "List<AcceptToken>", "declarator": "ACCEPT_ALL_TOKENS = Collections.singletonList(new AcceptToken(\"*\"))", "var_name": "ACCEPT_ALL_TOKENS"}, {"original_string": "public static final Comparator<QualityValue> QUALITY_VALUE_COMPARATOR = new Comparator<QualityValue>() {\n        @Override\n        public int compare(QualityValue qualityValueOne, QualityValue qualityValueTwo) {\n            float q1 = qualityValueOne.getQvalue();\n            float q2 = qualityValueTwo.getQvalue();\n            if (q1 < q2) {\n                return 1;\n            }\n            if (q1 > q2) {\n                return -1;\n            }\n            return 0;\n        }\n    };", "modifier": "public static final", "type": "Comparator<QualityValue>", "declarator": "QUALITY_VALUE_COMPARATOR = new Comparator<QualityValue>() {\n        @Override\n        public int compare(QualityValue qualityValueOne, QualityValue qualityValueTwo) {\n            float q1 = qualityValueOne.getQvalue();\n            float q2 = qualityValueTwo.getQvalue();\n            if (q1 < q2) {\n                return 1;\n            }\n            if (q1 > q2) {\n                return -1;\n            }\n            return 0;\n        }\n    }", "var_name": "QUALITY_VALUE_COMPARATOR"}, {"original_string": "private static final ListHeaderProducer<AcceptMediaType> LIST_MEDIA_TYPE_PRODUCER = new ListHeaderProducer<>(new AcceptMediaTypeFactory());", "modifier": "private static final", "type": "ListHeaderProducer<AcceptMediaType>", "declarator": "LIST_MEDIA_TYPE_PRODUCER = new ListHeaderProducer<>(new AcceptMediaTypeFactory())", "var_name": "LIST_MEDIA_TYPE_PRODUCER"}, {"original_string": "private static final ListHeaderProducer<AcceptLanguage> LIST_LANGUAGE_PRODUCER = new ListHeaderProducer<>(new AcceptLanguageFactory());", "modifier": "private static final", "type": "ListHeaderProducer<AcceptLanguage>", "declarator": "LIST_LANGUAGE_PRODUCER = new ListHeaderProducer<>(new AcceptLanguageFactory())", "var_name": "LIST_LANGUAGE_PRODUCER"}, {"original_string": "private static final ListHeaderProducer<AcceptToken> LIST_TOKEN_PRODUCER = new ListHeaderProducer<>(new AcceptTokenFactory());", "modifier": "private static final", "type": "ListHeaderProducer<AcceptToken>", "declarator": "LIST_TOKEN_PRODUCER = new ListHeaderProducer<>(new AcceptTokenFactory())", "var_name": "LIST_TOKEN_PRODUCER"}], "methods": [{"identifier": "HeaderHelper", "parameters": "()", "modifiers": "private", "return": "", "signature": " HeaderHelper()", "full_signature": "private  HeaderHelper()", "class_method_signature": "HeaderHelper.HeaderHelper()", "testcase": false, "constructor": true}, {"identifier": "createAcceptMediaTypeList", "parameters": "(String header)", "modifiers": "public static", "return": "List<AcceptMediaType>", "signature": "List<AcceptMediaType> createAcceptMediaTypeList(String header)", "full_signature": "public static List<AcceptMediaType> createAcceptMediaTypeList(String header)", "class_method_signature": "HeaderHelper.createAcceptMediaTypeList(String header)", "testcase": false, "constructor": false}, {"identifier": "createAcceptedLanguageList", "parameters": "(String header)", "modifiers": "public static", "return": "List<AcceptLanguage>", "signature": "List<AcceptLanguage> createAcceptedLanguageList(String header)", "full_signature": "public static List<AcceptLanguage> createAcceptedLanguageList(String header)", "class_method_signature": "HeaderHelper.createAcceptedLanguageList(String header)", "testcase": false, "constructor": false}, {"identifier": "createAcceptedCharsetList", "parameters": "(String header)", "modifiers": "public static", "return": "List<AcceptToken>", "signature": "List<AcceptToken> createAcceptedCharsetList(String header)", "full_signature": "public static List<AcceptToken> createAcceptedCharsetList(String header)", "class_method_signature": "HeaderHelper.createAcceptedCharsetList(String header)", "testcase": false, "constructor": false}, {"identifier": "createAcceptedEncodingList", "parameters": "(String header)", "modifiers": "public static", "return": "List<AcceptToken>", "signature": "List<AcceptToken> createAcceptedEncodingList(String header)", "full_signature": "public static List<AcceptToken> createAcceptedEncodingList(String header)", "class_method_signature": "HeaderHelper.createAcceptedEncodingList(String header)", "testcase": false, "constructor": false}, {"identifier": "parseCookies", "parameters": "(String cookiesString)", "modifiers": "public static", "return": "List<Cookie>", "signature": "List<Cookie> parseCookies(String cookiesString)", "full_signature": "public static List<Cookie> parseCookies(String cookiesString)", "class_method_signature": "HeaderHelper.parseCookies(String cookiesString)", "testcase": false, "constructor": false}, {"identifier": "parseNewCookie", "parameters": "(String newCookieString)", "modifiers": "public static", "return": "NewCookie", "signature": "NewCookie parseNewCookie(String newCookieString)", "full_signature": "public static NewCookie parseNewCookie(String newCookieString)", "class_method_signature": "HeaderHelper.parseNewCookie(String newCookieString)", "testcase": false, "constructor": false}, {"identifier": "parseDateHeader", "parameters": "(String header)", "modifiers": "public static", "return": "Date", "signature": "Date parseDateHeader(String header)", "full_signature": "public static Date parseDateHeader(String header)", "class_method_signature": "HeaderHelper.parseDateHeader(String header)", "testcase": false, "constructor": false}, {"identifier": "formatDate", "parameters": "(Date date)", "modifiers": "public static", "return": "String", "signature": "String formatDate(Date date)", "full_signature": "public static String formatDate(Date date)", "class_method_signature": "HeaderHelper.formatDate(Date date)", "testcase": false, "constructor": false}, {"identifier": "getContentLengthLong", "parameters": "(MultivaluedMap<String, String> httpHeaders)", "modifiers": "public static", "return": "long", "signature": "long getContentLengthLong(MultivaluedMap<String, String> httpHeaders)", "full_signature": "public static long getContentLengthLong(MultivaluedMap<String, String> httpHeaders)", "class_method_signature": "HeaderHelper.getContentLengthLong(MultivaluedMap<String, String> httpHeaders)", "testcase": false, "constructor": false}, {"identifier": "getHeaderAsString", "parameters": "(Object o)", "modifiers": "@SuppressWarnings({\"unchecked\"}) public static", "return": "String", "signature": "String getHeaderAsString(Object o)", "full_signature": "@SuppressWarnings({\"unchecked\"}) public static String getHeaderAsString(Object o)", "class_method_signature": "HeaderHelper.getHeaderAsString(Object o)", "testcase": false, "constructor": false}, {"identifier": "convertToString", "parameters": "(Collection<String> collection)", "modifiers": "public static", "return": "String", "signature": "String convertToString(Collection<String> collection)", "full_signature": "public static String convertToString(Collection<String> collection)", "class_method_signature": "HeaderHelper.convertToString(Collection<String> collection)", "testcase": false, "constructor": false}, {"identifier": "appendWithQuote", "parameters": "(StringBuilder target, String appendMe)", "modifiers": "static", "return": "void", "signature": "void appendWithQuote(StringBuilder target, String appendMe)", "full_signature": "static void appendWithQuote(StringBuilder target, String appendMe)", "class_method_signature": "HeaderHelper.appendWithQuote(StringBuilder target, String appendMe)", "testcase": false, "constructor": false}, {"identifier": "appendEscapeQuote", "parameters": "(StringBuilder target, String appendMe)", "modifiers": "static", "return": "void", "signature": "void appendEscapeQuote(StringBuilder target, String appendMe)", "full_signature": "static void appendEscapeQuote(StringBuilder target, String appendMe)", "class_method_signature": "HeaderHelper.appendEscapeQuote(StringBuilder target, String appendMe)", "testcase": false, "constructor": false}, {"identifier": "removeWhitespaces", "parameters": "(String str)", "modifiers": "static", "return": "String", "signature": "String removeWhitespaces(String str)", "full_signature": "static String removeWhitespaces(String str)", "class_method_signature": "HeaderHelper.removeWhitespaces(String str)", "testcase": false, "constructor": false}, {"identifier": "addQuotesIfHasWhitespace", "parameters": "(String str)", "modifiers": "static", "return": "String", "signature": "String addQuotesIfHasWhitespace(String str)", "full_signature": "static String addQuotesIfHasWhitespace(String str)", "class_method_signature": "HeaderHelper.addQuotesIfHasWhitespace(String str)", "testcase": false, "constructor": false}, {"identifier": "parseQualityValue", "parameters": "(String qString)", "modifiers": "static", "return": "float", "signature": "float parseQualityValue(String qString)", "full_signature": "static float parseQualityValue(String qString)", "class_method_signature": "HeaderHelper.parseQualityValue(String qString)", "testcase": false, "constructor": false}, {"identifier": "isToken", "parameters": "(String token)", "modifiers": "static", "return": "int", "signature": "int isToken(String token)", "full_signature": "static int isToken(String token)", "class_method_signature": "HeaderHelper.isToken(String token)", "testcase": false, "constructor": false}, {"identifier": "findCookieParameterSeparator", "parameters": "(String cookie, int start)", "modifiers": "private static", "return": "int", "signature": "int findCookieParameterSeparator(String cookie, int start)", "full_signature": "private static int findCookieParameterSeparator(String cookie, int start)", "class_method_signature": "HeaderHelper.findCookieParameterSeparator(String cookie, int start)", "testcase": false, "constructor": false}, {"identifier": "removeQuoteEscapes", "parameters": "(String token)", "modifiers": "static", "return": "String", "signature": "String removeQuoteEscapes(String token)", "full_signature": "static String removeQuoteEscapes(String token)", "class_method_signature": "HeaderHelper.removeQuoteEscapes(String token)", "testcase": false, "constructor": false}], "file": "everrest-core/src/main/java/org/everrest/core/impl/header/HeaderHelper.java"}, "focal_method": {"identifier": "parseNewCookie", "parameters": "(String newCookieString)", "modifiers": "public static", "return": "NewCookie", "body": "public static NewCookie parseNewCookie(String newCookieString) {\n        int p = 0;\n        int n = findCookieParameterSeparator(newCookieString, p);\n        int separator = -1;\n        if (n > 0 && n < newCookieString.length()) {\n            separator = newCookieString.charAt(n);\n        }\n        NewCookieBuilder newCookieBuilder = null;\n\n        while (p < newCookieString.length()) {\n\n            String pair = newCookieString.substring(p, n);\n\n            String name;\n            String value = \"\";\n\n            int eq = scan(pair, '=');\n            if (charAtIs(pair, eq, '=')) {\n                name = pair.substring(0, eq).trim();\n                value = pair.substring(eq + 1).trim();\n                if (value.length() > 1 && value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {\n                    value = value.substring(1, value.length() - 1);\n                }\n            } else {\n                name = pair.trim();\n            }\n\n            if (newCookieBuilder == null) {\n                newCookieBuilder = aNewCookie().withName(name).withValue(value).withVersion(Cookie.DEFAULT_VERSION);\n            } else {\n                if (name.equalsIgnoreCase(\"version\")) {\n                    newCookieBuilder.withVersion(Integer.parseInt(value));\n                } else if (name.equalsIgnoreCase(\"domain\")) {\n                    newCookieBuilder.withDomain(value);\n                } else if (name.equalsIgnoreCase(\"path\")) {\n                    newCookieBuilder.withPath(value);\n                } else if (name.equalsIgnoreCase(\"secure\")) {\n                    newCookieBuilder.withSecure(true);\n                } else if (name.equalsIgnoreCase(\"HttpOnly\")) {\n                    newCookieBuilder.withHttpOnly(true);\n                } else if (name.equalsIgnoreCase(\"Max-Age\")) {\n                    newCookieBuilder.withMaxAge(Integer.parseInt(value));\n                } else if (name.equalsIgnoreCase(\"expires\")) {\n                    try {\n                        newCookieBuilder.withExpiry(parseDateHeader(value));\n                    } catch (IllegalArgumentException ignored) {\n                        ignored.printStackTrace();\n                    }\n                } else if (name.equalsIgnoreCase(\"comment\")) {\n                    newCookieBuilder.withComment(value);\n                }\n            }\n            if (separator == -1) {\n                break;\n            }\n            p = n + 1;\n            n = scan(newCookieString, p, (char)separator);\n        }\n\n        if (newCookieBuilder == null) {\n            return null;\n        }\n        return newCookieBuilder.build();\n    }", "signature": "NewCookie parseNewCookie(String newCookieString)", "full_signature": "public static NewCookie parseNewCookie(String newCookieString)", "class_method_signature": "HeaderHelper.parseNewCookie(String newCookieString)", "testcase": false, "constructor": false, "invocations": ["findCookieParameterSeparator", "length", "charAt", "length", "substring", "scan", "charAtIs", "trim", "substring", "trim", "substring", "length", "startsWith", "endsWith", "substring", "length", "trim", "withVersion", "withValue", "withName", "aNewCookie", "equalsIgnoreCase", "withVersion", "parseInt", "equalsIgnoreCase", "withDomain", "equalsIgnoreCase", "withPath", "equalsIgnoreCase", "withSecure", "equalsIgnoreCase", "withHttpOnly", "equalsIgnoreCase", "withMaxAge", "parseInt", "equalsIgnoreCase", "withExpiry", "parseDateHeader", "printStackTrace", "equalsIgnoreCase", "withComment", "scan", "build"]}, "repository": {"repo_id": 14550159, "url": "https://github.com/codenvy/everrest", "language": "Java", "is_fork": false, "fork_count": 14, "stargazer_count": 24, "size": 4563, "license": "licensed"}}