{"test_class": {"identifier": "CDSShardAccessImplTest", "superclass": "extends AbstractActorTest", "interfaces": "", "fields": [{"original_string": "private static final DOMDataTreeIdentifier TEST_ID =\n            new DOMDataTreeIdentifier(LogicalDatastoreType.CONFIGURATION, TestModel.TEST_PATH);", "modifier": "private static final", "type": "DOMDataTreeIdentifier", "declarator": "TEST_ID =\n            new DOMDataTreeIdentifier(LogicalDatastoreType.CONFIGURATION, TestModel.TEST_PATH)", "var_name": "TEST_ID"}, {"original_string": "private CDSShardAccessImpl shardAccess;", "modifier": "private", "type": "CDSShardAccessImpl", "declarator": "shardAccess", "var_name": "shardAccess"}, {"original_string": "private ActorUtils context;", "modifier": "private", "type": "ActorUtils", "declarator": "context", "var_name": "context"}], "file": "opendaylight/md-sal/sal-distributed-datastore/src/test/java/org/opendaylight/controller/cluster/sharding/CDSShardAccessImplTest.java"}, "test_case": {"identifier": "testRegisterLeaderLocationListener", "parameters": "()", "modifiers": "@Test @SuppressWarnings(\"checkstyle:IllegalCatch\") public", "return": "void", "body": "@Test\n    @SuppressWarnings(\"checkstyle:IllegalCatch\")\n    public void testRegisterLeaderLocationListener() {\n        final LeaderLocationListener listener1 = mock(LeaderLocationListener.class);\n\n        // first registration should be OK\n        shardAccess.registerLeaderLocationListener(listener1);\n\n        // second registration should fail with IllegalArgumentEx\n        try {\n            shardAccess.registerLeaderLocationListener(listener1);\n            fail(\"Should throw exception\");\n        } catch (final Exception e) {\n            assertTrue(e instanceof IllegalArgumentException);\n        }\n\n        // null listener registration should fail with NPE\n        try {\n            shardAccess.registerLeaderLocationListener(null);\n            fail(\"Should throw exception\");\n        } catch (final Exception e) {\n            assertTrue(e instanceof NullPointerException);\n        }\n\n        // registering listener on closed shard access should fail with IllegalStateEx\n        final LeaderLocationListener listener2 = mock(LeaderLocationListener.class);\n        shardAccess.close();\n        try {\n            shardAccess.registerLeaderLocationListener(listener2);\n            fail(\"Should throw exception\");\n        } catch (final Exception ex) {\n            assertTrue(ex instanceof IllegalStateException);\n        }\n    }", "signature": "void testRegisterLeaderLocationListener()", "full_signature": "@Test @SuppressWarnings(\"checkstyle:IllegalCatch\") public void testRegisterLeaderLocationListener()", "class_method_signature": "CDSShardAccessImplTest.testRegisterLeaderLocationListener()", "testcase": true, "constructor": false, "invocations": ["mock", "registerLeaderLocationListener", "registerLeaderLocationListener", "fail", "assertTrue", "registerLeaderLocationListener", "fail", "assertTrue", "mock", "close", "registerLeaderLocationListener", "fail", "assertTrue"]}, "focal_class": {"identifier": "CDSShardAccessImpl", "superclass": "", "interfaces": "implements CDSShardAccess, LeaderLocationListener, AutoCloseable", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(CDSShardAccessImpl.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(CDSShardAccessImpl.class)", "var_name": "LOG"}, {"original_string": "private final Collection<LeaderLocationListener> listeners = ConcurrentHashMap.newKeySet();", "modifier": "private final", "type": "Collection<LeaderLocationListener>", "declarator": "listeners = ConcurrentHashMap.newKeySet()", "var_name": "listeners"}, {"original_string": "private final DOMDataTreeIdentifier prefix;", "modifier": "private final", "type": "DOMDataTreeIdentifier", "declarator": "prefix", "var_name": "prefix"}, {"original_string": "private final ActorUtils actorUtils;", "modifier": "private final", "type": "ActorUtils", "declarator": "actorUtils", "var_name": "actorUtils"}, {"original_string": "private final Timeout makeLeaderLocalTimeout;", "modifier": "private final", "type": "Timeout", "declarator": "makeLeaderLocalTimeout", "var_name": "makeLeaderLocalTimeout"}, {"original_string": "private ActorRef roleChangeListenerActor;", "modifier": "private", "type": "ActorRef", "declarator": "roleChangeListenerActor", "var_name": "roleChangeListenerActor"}, {"original_string": "private volatile LeaderLocation currentLeader = LeaderLocation.UNKNOWN;", "modifier": "private volatile", "type": "LeaderLocation", "declarator": "currentLeader = LeaderLocation.UNKNOWN", "var_name": "currentLeader"}, {"original_string": "private volatile boolean closed = false;", "modifier": "private volatile", "type": "boolean", "declarator": "closed = false", "var_name": "closed"}], "methods": [{"identifier": "CDSShardAccessImpl", "parameters": "(final DOMDataTreeIdentifier prefix, final ActorUtils actorUtils)", "modifiers": "", "return": "", "signature": " CDSShardAccessImpl(final DOMDataTreeIdentifier prefix, final ActorUtils actorUtils)", "full_signature": "  CDSShardAccessImpl(final DOMDataTreeIdentifier prefix, final ActorUtils actorUtils)", "class_method_signature": "CDSShardAccessImpl.CDSShardAccessImpl(final DOMDataTreeIdentifier prefix, final ActorUtils actorUtils)", "testcase": false, "constructor": true}, {"identifier": "checkNotClosed", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void checkNotClosed()", "full_signature": "private void checkNotClosed()", "class_method_signature": "CDSShardAccessImpl.checkNotClosed()", "testcase": false, "constructor": false}, {"identifier": "getShardIdentifier", "parameters": "()", "modifiers": "@Override public", "return": "DOMDataTreeIdentifier", "signature": "DOMDataTreeIdentifier getShardIdentifier()", "full_signature": "@Override public DOMDataTreeIdentifier getShardIdentifier()", "class_method_signature": "CDSShardAccessImpl.getShardIdentifier()", "testcase": false, "constructor": false}, {"identifier": "getLeaderLocation", "parameters": "()", "modifiers": "@Override public", "return": "LeaderLocation", "signature": "LeaderLocation getLeaderLocation()", "full_signature": "@Override public LeaderLocation getLeaderLocation()", "class_method_signature": "CDSShardAccessImpl.getLeaderLocation()", "testcase": false, "constructor": false}, {"identifier": "makeLeaderLocal", "parameters": "()", "modifiers": "@Override public", "return": "CompletionStage<Void>", "signature": "CompletionStage<Void> makeLeaderLocal()", "full_signature": "@Override public CompletionStage<Void> makeLeaderLocal()", "class_method_signature": "CDSShardAccessImpl.makeLeaderLocal()", "testcase": false, "constructor": false}, {"identifier": "registerLeaderLocationListener", "parameters": "(final L listener)", "modifiers": "@Override public", "return": "LeaderLocationListenerRegistration<L>", "signature": "LeaderLocationListenerRegistration<L> registerLeaderLocationListener(final L listener)", "full_signature": "@Override public LeaderLocationListenerRegistration<L> registerLeaderLocationListener(final L listener)", "class_method_signature": "CDSShardAccessImpl.registerLeaderLocationListener(final L listener)", "testcase": false, "constructor": false}, {"identifier": "onLeaderLocationChanged", "parameters": "(final LeaderLocation location)", "modifiers": "@Override @SuppressWarnings(\"checkstyle:IllegalCatch\") public", "return": "void", "signature": "void onLeaderLocationChanged(final LeaderLocation location)", "full_signature": "@Override @SuppressWarnings(\"checkstyle:IllegalCatch\") public void onLeaderLocationChanged(final LeaderLocation location)", "class_method_signature": "CDSShardAccessImpl.onLeaderLocationChanged(final LeaderLocation location)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "CDSShardAccessImpl.close()", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-distributed-datastore/src/main/java/org/opendaylight/controller/cluster/sharding/CDSShardAccessImpl.java"}, "focal_method": {"identifier": "registerLeaderLocationListener", "parameters": "(final L listener)", "modifiers": "@Override public", "return": "LeaderLocationListenerRegistration<L>", "body": "@Override\n    public <L extends LeaderLocationListener> LeaderLocationListenerRegistration<L>\n            registerLeaderLocationListener(final L listener) {\n        checkNotClosed();\n        requireNonNull(listener);\n        checkArgument(!listeners.contains(listener), \"Listener %s is already registered with ShardAccess %s\", listener,\n            this);\n\n        LOG.debug(\"Registering LeaderLocationListener {}\", listener);\n\n        listeners.add(listener);\n\n        return new LeaderLocationListenerRegistration<L>() {\n            @Override\n            public L getInstance() {\n                return listener;\n            }\n\n            @Override\n            public void close() {\n                listeners.remove(listener);\n            }\n        };\n    }", "signature": "LeaderLocationListenerRegistration<L> registerLeaderLocationListener(final L listener)", "full_signature": "@Override public LeaderLocationListenerRegistration<L> registerLeaderLocationListener(final L listener)", "class_method_signature": "CDSShardAccessImpl.registerLeaderLocationListener(final L listener)", "testcase": false, "constructor": false, "invocations": ["checkNotClosed", "requireNonNull", "checkArgument", "contains", "debug", "add", "remove"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}