{"test_class": {"identifier": "AbstractNPointCrossoverReproductionOperatorTest", "superclass": "extends TestCase", "interfaces": "", "fields": [{"original_string": "protected AbstractNPointCrossoverReproductionOperator operator;", "modifier": "protected", "type": "AbstractNPointCrossoverReproductionOperator", "declarator": "operator", "var_name": "operator"}], "file": "jcool/benchmark/src/test/java/cz/cvut/felk/cig/jcool/benchmark/method/evolutionary/operators/reproduction/AbstractNPointCrossoverReproductionOperatorTest.java"}, "test_case": {"identifier": "testMakeCutPointFlags2", "parameters": "()", "modifiers": "@Test // test nontrivial cases of cut points and function dimension public", "return": "void", "body": "@Test\n    // test nontrivial cases of cut points and function dimension\n    public void testMakeCutPointFlags2() throws Exception {\n        for (int cutPoints = 1; cutPoints < 10; cutPoints++){\n            int totalLength = cutPoints * 4;\n            boolean[] flags = this.operator.makeCutPointFlags(cutPoints, totalLength);\n            int flips = countFlips(flags);\n            assertEquals(cutPoints, flips);\n        }\n    }", "signature": "void testMakeCutPointFlags2()", "full_signature": "@Test // test nontrivial cases of cut points and function dimension public void testMakeCutPointFlags2()", "class_method_signature": "AbstractNPointCrossoverReproductionOperatorTest.testMakeCutPointFlags2()", "testcase": true, "constructor": false, "invocations": ["makeCutPointFlags", "countFlips", "assertEquals"]}, "focal_class": {"identifier": "AbstractNPointCrossoverReproductionOperator", "superclass": "extends AbstractCrossoverReproductionOperator", "interfaces": "", "fields": [{"original_string": "@Property(name = \"number of crossover points\")\n    @Range(from = 1, to = Integer.MAX_VALUE)\n    protected int crossPointCount = 1;", "modifier": "@Property(name = \"number of crossover points\")\n    @Range(from = 1, to = Integer.MAX_VALUE)\n    protected", "type": "int", "declarator": "crossPointCount = 1", "var_name": "crossPointCount"}], "methods": [{"identifier": "checkConsistency", "parameters": "(Population[] populations)", "modifiers": "@Override public", "return": "void", "signature": "void checkConsistency(Population[] populations)", "full_signature": "@Override public void checkConsistency(Population[] populations)", "class_method_signature": "AbstractNPointCrossoverReproductionOperator.checkConsistency(Population[] populations)", "testcase": false, "constructor": false}, {"identifier": "reproduce", "parameters": "(Population[] populations)", "modifiers": "public", "return": "Population[]", "signature": "Population[] reproduce(Population[] populations)", "full_signature": "public Population[] reproduce(Population[] populations)", "class_method_signature": "AbstractNPointCrossoverReproductionOperator.reproduce(Population[] populations)", "testcase": false, "constructor": false}, {"identifier": "reproduceInternal", "parameters": "(Individual[] firstChildren, Individual[] secondChildren)", "modifiers": "protected abstract", "return": "void", "signature": "void reproduceInternal(Individual[] firstChildren, Individual[] secondChildren)", "full_signature": "protected abstract void reproduceInternal(Individual[] firstChildren, Individual[] secondChildren)", "class_method_signature": "AbstractNPointCrossoverReproductionOperator.reproduceInternal(Individual[] firstChildren, Individual[] secondChildren)", "testcase": false, "constructor": false}, {"identifier": "getCrossPointCount", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getCrossPointCount()", "full_signature": "public int getCrossPointCount()", "class_method_signature": "AbstractNPointCrossoverReproductionOperator.getCrossPointCount()", "testcase": false, "constructor": false}, {"identifier": "setCrossPointCount", "parameters": "(int crossPointCount)", "modifiers": "public", "return": "void", "signature": "void setCrossPointCount(int crossPointCount)", "full_signature": "public void setCrossPointCount(int crossPointCount)", "class_method_signature": "AbstractNPointCrossoverReproductionOperator.setCrossPointCount(int crossPointCount)", "testcase": false, "constructor": false}, {"identifier": "makeCutPointFlags", "parameters": "(int numCrossings, int arrayLength)", "modifiers": "protected", "return": "boolean[]", "signature": "boolean[] makeCutPointFlags(int numCrossings, int arrayLength)", "full_signature": "protected boolean[] makeCutPointFlags(int numCrossings, int arrayLength)", "class_method_signature": "AbstractNPointCrossoverReproductionOperator.makeCutPointFlags(int numCrossings, int arrayLength)", "testcase": false, "constructor": false}], "file": "jcool/benchmark/src/main/java/cz/cvut/felk/cig/jcool/benchmark/method/evolutionary/operators/reproduction/AbstractNPointCrossoverReproductionOperator.java"}, "focal_method": {"identifier": "makeCutPointFlags", "parameters": "(int numCrossings, int arrayLength)", "modifiers": "protected", "return": "boolean[]", "body": "protected boolean[] makeCutPointFlags(int numCrossings, int arrayLength){\n        int[] indexes = new int[numCrossings];\n        // trivial case when numCrossings is by one smaller than dimension count\n        if ((numCrossings + 1) == arrayLength){\n            for (int i = 0; i < numCrossings; i++){\n                indexes[i] = i + 1;\n            }\n        } else {\n            // generating of cross points into set which is ordered and then transform it into int[].\n            Set<Integer> indexSet = new TreeSet<Integer>();\n            while (indexSet.size() < numCrossings){\n                indexSet.add(this.randomGenerator.nextInt(1, arrayLength));\n            }\n\n            // probably the best solution without creating temporary Integer[] array from indexSet\n            int idx = 0;\n            for (Integer integer : indexSet){\n                indexes[idx++] = integer;\n            }\n        }\n        // we have generated cross points and now can generate boolean flag array\n        boolean[] flagArray = new boolean[arrayLength];\n        boolean flag = true;\n        int index = 0;\n        for (int i = 0; i < arrayLength; i++){\n            // if at inverting position then invert and shift index\n            if (index < numCrossings && indexes[index] == i){\n                flag = !flag;\n                index++;\n            }\n            flagArray[i] = flag;\n        }\n        return flagArray;\n    }", "signature": "boolean[] makeCutPointFlags(int numCrossings, int arrayLength)", "full_signature": "protected boolean[] makeCutPointFlags(int numCrossings, int arrayLength)", "class_method_signature": "AbstractNPointCrossoverReproductionOperator.makeCutPointFlags(int numCrossings, int arrayLength)", "testcase": false, "constructor": false, "invocations": ["size", "add", "nextInt"]}, "repository": {"repo_id": 3865446, "url": "https://github.com/dhonza/JCOOL", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 12, "size": 415, "license": "licensed"}}