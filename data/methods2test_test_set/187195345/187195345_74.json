{"test_class": {"identifier": "NodeCheckTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int THREE_CONNECTED_LINES = 3;", "modifier": "private static final", "type": "int", "declarator": "THREE_CONNECTED_LINES = 3", "var_name": "THREE_CONNECTED_LINES"}, {"original_string": "private static final int FOUR_CONNECTED_LINES = 4;", "modifier": "private static final", "type": "int", "declarator": "FOUR_CONNECTED_LINES = 4", "var_name": "FOUR_CONNECTED_LINES"}, {"original_string": "private static final int FIVE_CONNECTED_LINES = 5;", "modifier": "private static final", "type": "int", "declarator": "FIVE_CONNECTED_LINES = 5", "var_name": "FIVE_CONNECTED_LINES"}], "file": "map/src/test/java/openlr/map/utils/NodeCheckTest.java"}, "test_case": {"identifier": "testIsNodeValid", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testIsNodeValid() {\n        Mockery context = new Mockery();\n        final Node valid1 = context.mock(Node.class, \"valid1\");\n        final Node valid2 = context.mock(Node.class, \"valid2\");\n        final Node valid3 = context.mock(Node.class, \"valid3\");\n        final Node valid4 = context.mock(Node.class, \"valid4\");\n        final Node valid5 = context.mock(Node.class, \"valid5\");\n\n        final Node invalid2 = context.mock(Node.class, \"invalid2\");\n        final Node invalid4 = context.mock(Node.class, \"invalid4\");\n\n        final Node n1 = context.mock(Node.class, \"n1\");\n        final Node n2 = context.mock(Node.class, \"n2\");\n        final Node n3 = context.mock(Node.class, \"n3\");\n\n        final Line l1 = context.mock(Line.class, \"l1\");\n        final Line l2 = context.mock(Line.class, \"l2\");\n        final Line l3 = context.mock(Line.class, \"l3\");\n        final Line l4 = context.mock(Line.class, \"l4\");\n        final Line l5 = context.mock(Line.class, \"l5\");\n\n        context.checking(new Expectations() {\n            {\n                allowing(valid2).getID();\n                will(returnValue(2l));\n            }\n        });\n        context.checking(new Expectations() {\n            {\n                allowing(valid1).getNumberConnectedLines();\n                will(returnValue(1));\n            }\n        });\n\n        final HashSet<Line> set2 = new HashSet<Line>();\n        set2.add(l1);\n        set2.add(l2);\n        context.checking(new Expectations() {\n            {\n                allowing(valid2).getNumberConnectedLines();\n                will(returnValue(2));\n            }\n\n            {\n                allowing(valid2).getConnectedLines();\n                will(returnValue(set2.iterator()));\n            }\n        });\n        context.checking(new Expectations() {\n            {\n                allowing(n1).getID();\n                will(returnValue(1l));\n            }\n\n            {\n                allowing(n2).getID();\n                will(returnValue(2l));\n            }\n\n            {\n                allowing(n3).getID();\n                will(returnValue(3l));\n            }\n        });\n        context.checking(new Expectations() {\n            {\n                allowing(l1).getStartNode();\n                will(returnValue(n1));\n            }\n\n            {\n                allowing(l1).getEndNode();\n                will(returnValue(valid2));\n            }\n        });\n        context.checking(new Expectations() {\n            {\n                allowing(l2).getStartNode();\n                will(returnValue(valid2));\n            }\n\n            {\n                allowing(l2).getEndNode();\n                will(returnValue(n1));\n            }\n        });\n\n        context.checking(new Expectations() {\n            {\n                allowing(valid3).getNumberConnectedLines();\n                will(returnValue(THREE_CONNECTED_LINES));\n            }\n        });\n\n        context.checking(new Expectations() {\n            {\n                allowing(valid5).getNumberConnectedLines();\n                will(returnValue(FIVE_CONNECTED_LINES));\n            }\n        });\n\n        final HashSet<Line> set4 = new HashSet<Line>();\n        set4.addAll(set2);\n        set4.add(l3);\n        set4.add(l4);\n        context.checking(new Expectations() {\n            {\n                allowing(valid4).getNumberConnectedLines();\n                will(returnValue(FOUR_CONNECTED_LINES));\n            }\n\n            {\n                allowing(valid4).getConnectedLines();\n                will(returnValue(set4.iterator()));\n            }\n        });\n        context.checking(new Expectations() {\n            {\n                allowing(l3).getStartNode();\n                will(returnValue(n2));\n            }\n\n            {\n                allowing(l3).getEndNode();\n                will(returnValue(valid2));\n            }\n        });\n        context.checking(new Expectations() {\n            {\n                allowing(l4).getStartNode();\n                will(returnValue(valid2));\n            }\n\n            {\n                allowing(l4).getEndNode();\n                will(returnValue(n3));\n            }\n        });\n\n        context.checking(new Expectations() {\n            {\n                allowing(l5).getStartNode();\n                will(returnValue(valid2));\n            }\n\n            {\n                allowing(l5).getEndNode();\n                will(returnValue(n2));\n            }\n        });\n\n        final HashSet<Line> set4invalid = new HashSet<Line>();\n        set4invalid.addAll(set2);\n        set4invalid.add(l3);\n        set4invalid.add(l5);\n        context.checking(new Expectations() {\n            {\n                allowing(invalid4).getNumberConnectedLines();\n                will(returnValue(FOUR_CONNECTED_LINES));\n            }\n\n            {\n                allowing(invalid4).getConnectedLines();\n                will(returnValue(set4invalid.iterator()));\n            }\n        });\n\n        final HashSet<Line> set2invalid = new HashSet<Line>();\n        set2invalid.add(l3);\n        set2invalid.add(l4);\n        context.checking(new Expectations() {\n            {\n                allowing(invalid2).getNumberConnectedLines();\n                will(returnValue(2));\n            }\n\n            {\n                allowing(invalid2).getConnectedLines();\n                will(returnValue(set2invalid.iterator()));\n            }\n        });\n\n        assertTrue(NodeCheck.isValidNode(valid1));\n        assertTrue(NodeCheck.isValidNode(valid2));\n        assertTrue(NodeCheck.isValidNode(valid3));\n        assertTrue(NodeCheck.isValidNode(valid4));\n        assertTrue(NodeCheck.isValidNode(valid5));\n\n        assertFalse(NodeCheck.isValidNode(invalid2));\n        assertFalse(NodeCheck.isValidNode(invalid4));\n    }", "signature": "void testIsNodeValid()", "full_signature": "@Test public void testIsNodeValid()", "class_method_signature": "NodeCheckTest.testIsNodeValid()", "testcase": true, "constructor": false, "invocations": ["mock", "mock", "mock", "mock", "mock", "mock", "mock", "mock", "mock", "mock", "mock", "mock", "mock", "mock", "mock", "checking", "getID", "allowing", "will", "returnValue", "checking", "getNumberConnectedLines", "allowing", "will", "returnValue", "add", "add", "checking", "getNumberConnectedLines", "allowing", "will", "returnValue", "getConnectedLines", "allowing", "will", "returnValue", "iterator", "checking", "getID", "allowing", "will", "returnValue", "getID", "allowing", "will", "returnValue", "getID", "allowing", "will", "returnValue", "checking", "getStartNode", "allowing", "will", "returnValue", "getEndNode", "allowing", "will", "returnValue", "checking", "getStartNode", "allowing", "will", "returnValue", "getEndNode", "allowing", "will", "returnValue", "checking", "getNumberConnectedLines", "allowing", "will", "returnValue", "checking", "getNumberConnectedLines", "allowing", "will", "returnValue", "addAll", "add", "add", "checking", "getNumberConnectedLines", "allowing", "will", "returnValue", "getConnectedLines", "allowing", "will", "returnValue", "iterator", "checking", "getStartNode", "allowing", "will", "returnValue", "getEndNode", "allowing", "will", "returnValue", "checking", "getStartNode", "allowing", "will", "returnValue", "getEndNode", "allowing", "will", "returnValue", "checking", "getStartNode", "allowing", "will", "returnValue", "getEndNode", "allowing", "will", "returnValue", "addAll", "add", "add", "checking", "getNumberConnectedLines", "allowing", "will", "returnValue", "getConnectedLines", "allowing", "will", "returnValue", "iterator", "add", "add", "checking", "getNumberConnectedLines", "allowing", "will", "returnValue", "getConnectedLines", "allowing", "will", "returnValue", "iterator", "assertTrue", "isValidNode", "assertTrue", "isValidNode", "assertTrue", "isValidNode", "assertTrue", "isValidNode", "assertTrue", "isValidNode", "assertFalse", "isValidNode", "assertFalse", "isValidNode"]}, "focal_class": {"identifier": "NodeCheck", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int DEGREE_2 = 2;", "modifier": "private static final", "type": "int", "declarator": "DEGREE_2 = 2", "var_name": "DEGREE_2"}, {"original_string": "private static final int DEGREE_4 = 4;", "modifier": "private static final", "type": "int", "declarator": "DEGREE_4 = 4", "var_name": "DEGREE_4"}], "methods": [{"identifier": "NodeCheck", "parameters": "()", "modifiers": "private", "return": "", "signature": " NodeCheck()", "full_signature": "private  NodeCheck()", "class_method_signature": "NodeCheck.NodeCheck()", "testcase": false, "constructor": true}, {"identifier": "isValidNode", "parameters": "(final Node n)", "modifiers": "public static", "return": "boolean", "signature": "boolean isValidNode(final Node n)", "full_signature": "public static boolean isValidNode(final Node n)", "class_method_signature": "NodeCheck.isValidNode(final Node n)", "testcase": false, "constructor": false}, {"identifier": "isPair", "parameters": "(final Line line1, final Line line2)", "modifiers": "public static", "return": "boolean", "signature": "boolean isPair(final Line line1, final Line line2)", "full_signature": "public static boolean isPair(final Line line1, final Line line2)", "class_method_signature": "NodeCheck.isPair(final Line line1, final Line line2)", "testcase": false, "constructor": false}], "file": "map/src/main/java/openlr/map/utils/NodeCheck.java"}, "focal_method": {"identifier": "isValidNode", "parameters": "(final Node n)", "modifiers": "public static", "return": "boolean", "body": "public static boolean isValidNode(final Node n) {\n        if (n == null) {\n            return false;\n        }\n        // node degree is 2\n        int degree = n.getNumberConnectedLines();\n        if (degree == DEGREE_2) {\n            Iterator<? extends Line> iter = n.getConnectedLines();\n            Line line1 = iter.next();\n            Line line2 = iter.next();\n            // if isPair then we have a dead-end street\n            // otherwise we can travel along the streets without coming back to\n            // the start point\n            return isPair(line1, line2);\n        }\n        // node degree is 4\n        if (degree == DEGREE_4) {\n            Iterator<? extends Line> connectedLines = n.getConnectedLines();\n            List<Line> lines = new ArrayList<Line>();\n            while (connectedLines.hasNext()) {\n                lines.add(connectedLines.next());\n            }\n\n            // find two pairs within this array\n            // if there are two pairs then the node is avoidable otherwise we\n            // are connecting more than\n            // two nodes and this node needs to be considered\n            Line line = lines.get(0);\n            boolean found = false;\n            int pos = 1;\n            // find a pair containing the first line and delete both lines\n            while (!found && pos < lines.size()) {\n                if (isPair(line, lines.get(pos))) {\n                    found = true;\n                    lines.remove(pos);\n                    lines.remove(0);\n                }\n                pos++;\n            }\n            // if no pair containing the first line can be found then we have a\n            // considerable node\n            if (!found) {\n                return true;\n            }\n            // check the remaining edges if they form a pair and if so, then\n            // avoid the node\n            if (isPair(lines.get(0), lines.get(1))) {\n                return false;\n            }\n            return true;\n        }\n        return true;\n    }", "signature": "boolean isValidNode(final Node n)", "full_signature": "public static boolean isValidNode(final Node n)", "class_method_signature": "NodeCheck.isValidNode(final Node n)", "testcase": false, "constructor": false, "invocations": ["getNumberConnectedLines", "getConnectedLines", "next", "next", "isPair", "getConnectedLines", "hasNext", "add", "next", "get", "size", "isPair", "get", "remove", "remove", "isPair", "get", "get"]}, "repository": {"repo_id": 187195345, "url": "https://github.com/tomtom-international/openlr", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 24, "size": 4809, "license": "licensed"}}