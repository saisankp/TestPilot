{"test_class": {"identifier": "TypeInfoParserTest", "superclass": "", "interfaces": "", "fields": [], "file": "flink-core/src/test/java/org/apache/flink/api/java/typeutils/TypeInfoParserTest.java"}, "test_case": {"identifier": "testGenericType", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testGenericType() {\n\t\tTypeInformation<?> ti = TypeInfoParser.parse(\"java.lang.Class\");\n\t\tAssert.assertTrue(ti instanceof GenericTypeInfo);\n\t\tAssert.assertEquals(Class.class, ((GenericTypeInfo<?>) ti).getTypeClass());\n\t}", "signature": "void testGenericType()", "full_signature": "@Test public void testGenericType()", "class_method_signature": "TypeInfoParserTest.testGenericType()", "testcase": true, "constructor": false, "invocations": ["parse", "assertTrue", "assertEquals", "getTypeClass"]}, "focal_class": {"identifier": "TypeInfoParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String TUPLE_PACKAGE = \"org.apache.flink.api.java.tuple\";", "modifier": "private static final", "type": "String", "declarator": "TUPLE_PACKAGE = \"org.apache.flink.api.java.tuple\"", "var_name": "TUPLE_PACKAGE"}, {"original_string": "private static final String VALUE_PACKAGE = \"org.apache.flink.types\";", "modifier": "private static final", "type": "String", "declarator": "VALUE_PACKAGE = \"org.apache.flink.types\"", "var_name": "VALUE_PACKAGE"}, {"original_string": "private static final String WRITABLE_PACKAGE = \"org.apache.hadoop.io\";", "modifier": "private static final", "type": "String", "declarator": "WRITABLE_PACKAGE = \"org.apache.hadoop.io\"", "var_name": "WRITABLE_PACKAGE"}, {"original_string": "private static final Pattern tuplePattern = Pattern.compile(\"^(\" + TUPLE_PACKAGE.replaceAll(\"\\\\.\", \"\\\\\\\\.\") + \"\\\\.)?((Tuple[1-9][0-9]?)<|(Tuple0))\");", "modifier": "private static final", "type": "Pattern", "declarator": "tuplePattern = Pattern.compile(\"^(\" + TUPLE_PACKAGE.replaceAll(\"\\\\.\", \"\\\\\\\\.\") + \"\\\\.)?((Tuple[1-9][0-9]?)<|(Tuple0))\")", "var_name": "tuplePattern"}, {"original_string": "private static final Pattern writablePattern = Pattern.compile(\"^((\" + WRITABLE_PACKAGE.replaceAll(\"\\\\.\", \"\\\\\\\\.\") + \"\\\\.)?Writable)<([^\\\\s,>]*)(,|>|$|\\\\[)\");", "modifier": "private static final", "type": "Pattern", "declarator": "writablePattern = Pattern.compile(\"^((\" + WRITABLE_PACKAGE.replaceAll(\"\\\\.\", \"\\\\\\\\.\") + \"\\\\.)?Writable)<([^\\\\s,>]*)(,|>|$|\\\\[)\")", "var_name": "writablePattern"}, {"original_string": "private static final Pattern enumPattern = Pattern.compile(\"^((java\\\\.lang\\\\.)?Enum)<([^\\\\s,>]*)(,|>|$|\\\\[)\");", "modifier": "private static final", "type": "Pattern", "declarator": "enumPattern = Pattern.compile(\"^((java\\\\.lang\\\\.)?Enum)<([^\\\\s,>]*)(,|>|$|\\\\[)\")", "var_name": "enumPattern"}, {"original_string": "private static final Pattern basicTypePattern = Pattern\n\t\t\t.compile(\"^((java\\\\.lang\\\\.)?(String|Integer|Byte|Short|Character|Double|Float|Long|Boolean|Void))(,|>|$|\\\\[)\");", "modifier": "private static final", "type": "Pattern", "declarator": "basicTypePattern = Pattern\n\t\t\t.compile(\"^((java\\\\.lang\\\\.)?(String|Integer|Byte|Short|Character|Double|Float|Long|Boolean|Void))(,|>|$|\\\\[)\")", "var_name": "basicTypePattern"}, {"original_string": "private static final Pattern basicTypeDatePattern = Pattern.compile(\"^((java\\\\.util\\\\.)?Date)(,|>|$|\\\\[)\");", "modifier": "private static final", "type": "Pattern", "declarator": "basicTypeDatePattern = Pattern.compile(\"^((java\\\\.util\\\\.)?Date)(,|>|$|\\\\[)\")", "var_name": "basicTypeDatePattern"}, {"original_string": "private static final Pattern primitiveTypePattern = Pattern.compile(\"^(int|byte|short|char|double|float|long|boolean|void)(,|>|$|\\\\[)\");", "modifier": "private static final", "type": "Pattern", "declarator": "primitiveTypePattern = Pattern.compile(\"^(int|byte|short|char|double|float|long|boolean|void)(,|>|$|\\\\[)\")", "var_name": "primitiveTypePattern"}, {"original_string": "private static final Pattern valueTypePattern = Pattern.compile(\"^((\" + VALUE_PACKAGE.replaceAll(\"\\\\.\", \"\\\\\\\\.\")\n\t\t\t+ \"\\\\.)?(String|Int|Byte|Short|Char|Double|Float|Long|Boolean|List|Map|Null))Value(,|>|$|\\\\[)\");", "modifier": "private static final", "type": "Pattern", "declarator": "valueTypePattern = Pattern.compile(\"^((\" + VALUE_PACKAGE.replaceAll(\"\\\\.\", \"\\\\\\\\.\")\n\t\t\t+ \"\\\\.)?(String|Int|Byte|Short|Char|Double|Float|Long|Boolean|List|Map|Null))Value(,|>|$|\\\\[)\")", "var_name": "valueTypePattern"}, {"original_string": "private static final Pattern pojoGenericObjectPattern = Pattern.compile(\"^([^\\\\s,<>\\\\[]+)(<)?\");", "modifier": "private static final", "type": "Pattern", "declarator": "pojoGenericObjectPattern = Pattern.compile(\"^([^\\\\s,<>\\\\[]+)(<)?\")", "var_name": "pojoGenericObjectPattern"}, {"original_string": "private static final Pattern fieldPattern = Pattern.compile(\"^([^\\\\s,<>\\\\[]+)=\");", "modifier": "private static final", "type": "Pattern", "declarator": "fieldPattern = Pattern.compile(\"^([^\\\\s,<>\\\\[]+)=\")", "var_name": "fieldPattern"}], "methods": [{"identifier": "parse", "parameters": "(String infoString)", "modifiers": "@SuppressWarnings(\"unchecked\") public static", "return": "TypeInformation<X>", "signature": "TypeInformation<X> parse(String infoString)", "full_signature": "@SuppressWarnings(\"unchecked\") public static TypeInformation<X> parse(String infoString)", "class_method_signature": "TypeInfoParser.parse(String infoString)", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "(StringBuilder sb)", "modifiers": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" }) private static", "return": "TypeInformation<?>", "signature": "TypeInformation<?> parse(StringBuilder sb)", "full_signature": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" }) private static TypeInformation<?> parse(StringBuilder sb)", "class_method_signature": "TypeInfoParser.parse(StringBuilder sb)", "testcase": false, "constructor": false}, {"identifier": "loadClass", "parameters": "(String fullyQualifiedName)", "modifiers": "private static", "return": "Class<?>", "signature": "Class<?> loadClass(String fullyQualifiedName)", "full_signature": "private static Class<?> loadClass(String fullyQualifiedName)", "class_method_signature": "TypeInfoParser.loadClass(String fullyQualifiedName)", "testcase": false, "constructor": false}], "file": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java"}, "focal_method": {"identifier": "parse", "parameters": "(String infoString)", "modifiers": "@SuppressWarnings(\"unchecked\") public static", "return": "TypeInformation<X>", "body": "@SuppressWarnings(\"unchecked\")\n\tpublic static <X> TypeInformation<X> parse(String infoString) {\n\t\ttry {\n\t\t\tif (infoString == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"String is null.\");\n\t\t\t}\n\t\t\tString clearedString = infoString.replaceAll(\"\\\\s\", \"\");\n\t\t\tif (clearedString.length() == 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"String must not be empty.\");\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder(clearedString);\n\t\t\tTypeInformation<X> ti = (TypeInformation<X>) parse(sb);\n\t\t\tif (sb.length() > 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"String could not be parsed completely.\");\n\t\t\t}\n\t\t\treturn ti;\n\t\t} catch (Exception e) {\n\t\t\tthrow new IllegalArgumentException(\"String could not be parsed: \" + e.getMessage(), e);\n\t\t}\n\t}", "signature": "TypeInformation<X> parse(String infoString)", "full_signature": "@SuppressWarnings(\"unchecked\") public static TypeInformation<X> parse(String infoString)", "class_method_signature": "TypeInfoParser.parse(String infoString)", "testcase": false, "constructor": false, "invocations": ["replaceAll", "length", "parse", "length", "getMessage"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}