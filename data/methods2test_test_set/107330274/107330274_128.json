{"test_class": {"identifier": "EvaluatorsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final RuntimeException SIMULATED_ERROR = new RuntimeException(\"simulated error\");", "modifier": "private static final", "type": "RuntimeException", "declarator": "SIMULATED_ERROR = new RuntimeException(\"simulated error\")", "var_name": "SIMULATED_ERROR"}, {"original_string": "private int counter;", "modifier": "private", "type": "int", "declarator": "counter", "var_name": "counter"}], "file": "titus-common/src/test/java/com/netflix/titus/common/util/EvaluatorsTest.java"}, "test_case": {"identifier": "testMemoizeLast", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMemoizeLast() {\n        Function<String, String> evaluator = Evaluators.memoizeLast(s -> {\n            counter++;\n            return (\"\" + s).toUpperCase();\n        });\n\n        assertThat(evaluator.apply(\"a\")).isEqualTo(\"A\");\n        assertThat(evaluator.apply(\"a\")).isEqualTo(\"A\");\n        assertThat(counter).isEqualTo(1);\n\n        assertThat(evaluator.apply(null)).isEqualTo(\"NULL\");\n        assertThat(evaluator.apply(null)).isEqualTo(\"NULL\");\n        assertThat(counter).isEqualTo(2);\n\n        assertThat(evaluator.apply(\"b\")).isEqualTo(\"B\");\n        assertThat(evaluator.apply(\"b\")).isEqualTo(\"B\");\n        assertThat(counter).isEqualTo(3);\n    }", "signature": "void testMemoizeLast()", "full_signature": "@Test public void testMemoizeLast()", "class_method_signature": "EvaluatorsTest.testMemoizeLast()", "testcase": true, "constructor": false, "invocations": ["memoizeLast", "toUpperCase", "isEqualTo", "assertThat", "apply", "isEqualTo", "assertThat", "apply", "isEqualTo", "assertThat", "isEqualTo", "assertThat", "apply", "isEqualTo", "assertThat", "apply", "isEqualTo", "assertThat", "isEqualTo", "assertThat", "apply", "isEqualTo", "assertThat", "apply", "isEqualTo", "assertThat"]}, "focal_class": {"identifier": "Evaluators", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "Evaluators", "parameters": "()", "modifiers": "private", "return": "", "signature": " Evaluators()", "full_signature": "private  Evaluators()", "class_method_signature": "Evaluators.Evaluators()", "testcase": false, "constructor": true}, {"identifier": "consumeNothing", "parameters": "(T value)", "modifiers": "public static", "return": "void", "signature": "void consumeNothing(T value)", "full_signature": "public static void consumeNothing(T value)", "class_method_signature": "Evaluators.consumeNothing(T value)", "testcase": false, "constructor": false}, {"identifier": "doNothing", "parameters": "()", "modifiers": "public static", "return": "void", "signature": "void doNothing()", "full_signature": "public static void doNothing()", "class_method_signature": "Evaluators.doNothing()", "testcase": false, "constructor": false}, {"identifier": "acceptNotNull", "parameters": "(T value, Consumer<T> consumer)", "modifiers": "public static", "return": "void", "signature": "void acceptNotNull(T value, Consumer<T> consumer)", "full_signature": "public static void acceptNotNull(T value, Consumer<T> consumer)", "class_method_signature": "Evaluators.acceptNotNull(T value, Consumer<T> consumer)", "testcase": false, "constructor": false}, {"identifier": "acceptIfTrue", "parameters": "(T value, Consumer<Boolean> consumer)", "modifiers": "public static", "return": "void", "signature": "void acceptIfTrue(T value, Consumer<Boolean> consumer)", "full_signature": "public static void acceptIfTrue(T value, Consumer<Boolean> consumer)", "class_method_signature": "Evaluators.acceptIfTrue(T value, Consumer<Boolean> consumer)", "testcase": false, "constructor": false}, {"identifier": "applyNotNull", "parameters": "(T value, Function<T, R> transformer)", "modifiers": "public static", "return": "R", "signature": "R applyNotNull(T value, Function<T, R> transformer)", "full_signature": "public static R applyNotNull(T value, Function<T, R> transformer)", "class_method_signature": "Evaluators.applyNotNull(T value, Function<T, R> transformer)", "testcase": false, "constructor": false}, {"identifier": "getOrDefault", "parameters": "(T value, T defaultValue)", "modifiers": "public static", "return": "T", "signature": "T getOrDefault(T value, T defaultValue)", "full_signature": "public static T getOrDefault(T value, T defaultValue)", "class_method_signature": "Evaluators.getOrDefault(T value, T defaultValue)", "testcase": false, "constructor": false}, {"identifier": "getFirstNotNull", "parameters": "(T... values)", "modifiers": "public static", "return": "T", "signature": "T getFirstNotNull(T... values)", "full_signature": "public static T getFirstNotNull(T... values)", "class_method_signature": "Evaluators.getFirstNotNull(T... values)", "testcase": false, "constructor": false}, {"identifier": "times", "parameters": "(int count, Runnable task)", "modifiers": "public static", "return": "void", "signature": "void times(int count, Runnable task)", "full_signature": "public static void times(int count, Runnable task)", "class_method_signature": "Evaluators.times(int count, Runnable task)", "testcase": false, "constructor": false}, {"identifier": "times", "parameters": "(int count, Consumer<Integer> task)", "modifiers": "public static", "return": "void", "signature": "void times(int count, Consumer<Integer> task)", "full_signature": "public static void times(int count, Consumer<Integer> task)", "class_method_signature": "Evaluators.times(int count, Consumer<Integer> task)", "testcase": false, "constructor": false}, {"identifier": "evaluateTimes", "parameters": "(int count, Function<Integer, T> transformer)", "modifiers": "public static", "return": "List<T>", "signature": "List<T> evaluateTimes(int count, Function<Integer, T> transformer)", "full_signature": "public static List<T> evaluateTimes(int count, Function<Integer, T> transformer)", "class_method_signature": "Evaluators.evaluateTimes(int count, Function<Integer, T> transformer)", "testcase": false, "constructor": false}, {"identifier": "firstPresent", "parameters": "(Supplier<Optional<T>>... optionalSuppliers)", "modifiers": "@SafeVarargs public static", "return": "Optional<T>", "signature": "Optional<T> firstPresent(Supplier<Optional<T>>... optionalSuppliers)", "full_signature": "@SafeVarargs public static Optional<T> firstPresent(Supplier<Optional<T>>... optionalSuppliers)", "class_method_signature": "Evaluators.firstPresent(Supplier<Optional<T>>... optionalSuppliers)", "testcase": false, "constructor": false}, {"identifier": "memoizeLast", "parameters": "(Function<T, R> function)", "modifiers": "public static", "return": "Function<T, R>", "signature": "Function<T, R> memoizeLast(Function<T, R> function)", "full_signature": "public static Function<T, R> memoizeLast(Function<T, R> function)", "class_method_signature": "Evaluators.memoizeLast(Function<T, R> function)", "testcase": false, "constructor": false}, {"identifier": "memoizeLast", "parameters": "(BiFunction<T, Optional<R>, R> computation)", "modifiers": "public static", "return": "Function<T, R>", "signature": "Function<T, R> memoizeLast(BiFunction<T, Optional<R>, R> computation)", "full_signature": "public static Function<T, R> memoizeLast(BiFunction<T, Optional<R>, R> computation)", "class_method_signature": "Evaluators.memoizeLast(BiFunction<T, Optional<R>, R> computation)", "testcase": false, "constructor": false}], "file": "titus-common/src/main/java/com/netflix/titus/common/util/Evaluators.java"}, "focal_method": {"identifier": "memoizeLast", "parameters": "(Function<T, R> function)", "modifiers": "public static", "return": "Function<T, R>", "body": "public static <T, R> Function<T, R> memoizeLast(Function<T, R> function) {\n        AtomicReference<Pair<T, Either<R, Throwable>>> lastRef = new AtomicReference<>();\n        return argument -> {\n            Pair<T, Either<R, Throwable>> last = lastRef.get();\n            if (last != null && Objects.equals(argument, last.getLeft())) {\n                if (last.getRight().hasValue()) {\n                    return last.getRight().getValue();\n                }\n                Throwable error = last.getRight().getError();\n                if (error instanceof RuntimeException) {\n                    throw (RuntimeException) error;\n                }\n                if (error instanceof Error) {\n                    throw (Error) error;\n                }\n                throw new IllegalStateException(error);\n            }\n            try {\n                R result = function.apply(argument);\n                lastRef.set(Pair.of(argument, Either.ofValue(result)));\n                return result;\n            } catch (Throwable e) {\n                lastRef.set(Pair.of(argument, Either.ofError(e)));\n                throw e;\n            }\n        };\n    }", "signature": "Function<T, R> memoizeLast(Function<T, R> function)", "full_signature": "public static Function<T, R> memoizeLast(Function<T, R> function)", "class_method_signature": "Evaluators.memoizeLast(Function<T, R> function)", "testcase": false, "constructor": false, "invocations": ["get", "equals", "getLeft", "hasValue", "getRight", "getValue", "getRight", "getError", "getRight", "apply", "set", "of", "ofValue", "set", "of", "ofError"]}, "repository": {"repo_id": 107330274, "url": "https://github.com/Netflix/titus-control-plane", "stars": 241, "created": "10/17/2017 10:20:55 PM +00:00", "updates": "2020-01-25T13:01:05+00:00", "fork": "False", "license": "licensed"}}