{"test_class": {"identifier": "LoginExeTest", "superclass": "extends ExeletTest", "interfaces": "", "fields": [], "file": "module/com.sandpolis.core.server/src/test/java/com/sandpolis/core/server/auth/LoginExeTest.java"}, "test_case": {"identifier": "rq_login_2", "parameters": "()", "modifiers": "@Test @DisplayName(\"Login with incorrect password fails\")", "return": "void", "body": "@Test\n\t@DisplayName(\"Login with incorrect password fails\")\n\tvoid rq_login_2() {\n\t\tUserStore.add(UserConfig.newBuilder().setUsername(\"user123\").setPassword(\"pass123\").build());\n\t\tvar rq = RQ_Login.newBuilder().setUsername(\"user123\").setPassword(\"pass1234\").build();\n\t\tvar rs = LoginExe.rq_login(context, rq);\n\n\t\tassertFalse(((Outcome) rs).getResult());\n\t}", "signature": "void rq_login_2()", "full_signature": "@Test @DisplayName(\"Login with incorrect password fails\") void rq_login_2()", "class_method_signature": "LoginExeTest.rq_login_2()", "testcase": true, "constructor": false, "invocations": ["add", "build", "setPassword", "setUsername", "newBuilder", "build", "setPassword", "setUsername", "newBuilder", "rq_login", "assertFalse", "getResult"]}, "focal_class": {"identifier": "LoginExe", "superclass": "extends Exelet", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(LoginExe.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(LoginExe.class)", "var_name": "log"}, {"original_string": "private static final TimeBasedOneTimePasswordGenerator TOTP;", "modifier": "private static final", "type": "TimeBasedOneTimePasswordGenerator", "declarator": "TOTP", "var_name": "TOTP"}], "methods": [{"identifier": "rq_logout", "parameters": "(ExeletContext context, RQ_Logout rq)", "modifiers": "@Handler(auth = true, instances = VIEWER) public static", "return": "void", "signature": "void rq_logout(ExeletContext context, RQ_Logout rq)", "full_signature": "@Handler(auth = true, instances = VIEWER) public static void rq_logout(ExeletContext context, RQ_Logout rq)", "class_method_signature": "LoginExe.rq_logout(ExeletContext context, RQ_Logout rq)", "testcase": false, "constructor": false}, {"identifier": "rq_login", "parameters": "(ExeletContext context, RQ_Login rq)", "modifiers": "@Handler(auth = false, instances = VIEWER) public static", "return": "MessageOrBuilder", "signature": "MessageOrBuilder rq_login(ExeletContext context, RQ_Login rq)", "full_signature": "@Handler(auth = false, instances = VIEWER) public static MessageOrBuilder rq_login(ExeletContext context, RQ_Login rq)", "class_method_signature": "LoginExe.rq_login(ExeletContext context, RQ_Login rq)", "testcase": false, "constructor": false}, {"identifier": "LoginExe", "parameters": "()", "modifiers": "private", "return": "", "signature": " LoginExe()", "full_signature": "private  LoginExe()", "class_method_signature": "LoginExe.LoginExe()", "testcase": false, "constructor": true}], "file": "module/com.sandpolis.core.server/src/main/java/com/sandpolis/core/server/auth/LoginExe.java"}, "focal_method": {"identifier": "rq_login", "parameters": "(ExeletContext context, RQ_Login rq)", "modifiers": "@Handler(auth = false, instances = VIEWER) public static", "return": "MessageOrBuilder", "body": "@Handler(auth = false, instances = VIEWER)\n\tpublic static MessageOrBuilder rq_login(ExeletContext context, RQ_Login rq) {\n\t\tlog.debug(\"Processing login request from: {}\", context.connector.getRemoteAddress());\n\t\tvar outcome = begin();\n\n\t\t// Validate username\n\t\tString username = rq.getUsername();\n\t\tif (!ValidationUtil.username(username)) {\n\t\t\tlog.debug(\"The username ({}) is invalid\", username);\n\t\t\treturn failure(outcome, INVALID_USERNAME);\n\t\t}\n\n\t\tUser user = UserStore.getByUsername(username).orElse(null);\n\t\tif (user == null) {\n\t\t\tlog.debug(\"The user ({}) does not exist\", username);\n\t\t\treturn failure(outcome, ACCESS_DENIED);\n\t\t}\n\n\t\t// Check expiration\n\t\tif (user.isExpired()) {\n\t\t\tlog.debug(\"The user ({}) is expired\", username);\n\t\t\treturn failure(outcome, ACCESS_DENIED);\n\t\t}\n\n\t\t// Check OTP if required\n\t\tif (user.totpSecret().isPresent()) {\n\t\t\tvar key = new SecretKeySpec(user.getTotpSecret(), TOTP.getAlgorithm());\n\t\t\ttry {\n\t\t\t\tif (rq.getTotp() != TOTP.generateOneTimePassword(key, Instant.now())) {\n\t\t\t\t\tlog.debug(\"OTP validation failed\", username);\n\t\t\t\t\treturn failure(outcome, ACCESS_DENIED);\n\t\t\t\t}\n\t\t\t} catch (InvalidKeyException e) {\n\t\t\t\tlog.error(\"Invalid TOTP secret\", e);\n\t\t\t\treturn failure(outcome, ACCESS_DENIED);\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tkey.destroy();\n\t\t\t\t} catch (DestroyFailedException e) {\n\t\t\t\t\tlog.error(\"Failed to destroy TOTP secret\", e);\n\t\t\t\t\treturn failure(outcome, ACCESS_DENIED);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check password\n\t\tif (!CryptoUtil.PBKDF2.check(rq.getPassword(), user.getHash())) {\n\t\t\tlog.debug(\"Password validation failed\", username);\n\t\t\treturn failure(outcome, ACCESS_DENIED);\n\t\t}\n\n\t\tlog.debug(\"Accepting login request for user: {}\", username);\n\n\t\t// Mark connection as authenticated\n\t\tcontext.connector.authenticate();\n\n\t\t// Update login metadata\n\t\tProfileStore.getViewer(username).ifPresentOrElse(profile -> {\n\t\t\tprofile.viewer().ip().set(context.connector.getRemoteAddress());\n\t\t}, () -> {\n\t\t\tProfileStore.create(profile -> {\n\t\t\t\tprofile.uuid().set(context.connector.getRemoteUuid());\n\t\t\t\tprofile.instanceType().set(context.connector.getRemoteInstance());\n\t\t\t\tprofile.instanceFlavor().set(context.connector.getRemoteInstanceFlavor());\n\t\t\t\tprofile.viewer().username().set(username);\n\t\t\t\tprofile.viewer().ip().set(context.connector.getRemoteAddress());\n\t\t\t});\n\t\t});\n\n\t\treturn success(outcome);\n\t}", "signature": "MessageOrBuilder rq_login(ExeletContext context, RQ_Login rq)", "full_signature": "@Handler(auth = false, instances = VIEWER) public static MessageOrBuilder rq_login(ExeletContext context, RQ_Login rq)", "class_method_signature": "LoginExe.rq_login(ExeletContext context, RQ_Login rq)", "testcase": false, "constructor": false, "invocations": ["debug", "getRemoteAddress", "begin", "getUsername", "username", "debug", "failure", "orElse", "getByUsername", "debug", "failure", "isExpired", "debug", "failure", "isPresent", "totpSecret", "getTotpSecret", "getAlgorithm", "getTotp", "generateOneTimePassword", "now", "debug", "failure", "error", "failure", "destroy", "error", "failure", "check", "getPassword", "getHash", "debug", "failure", "debug", "authenticate", "ifPresentOrElse", "getViewer", "set", "ip", "viewer", "getRemoteAddress", "create", "set", "uuid", "getRemoteUuid", "set", "instanceType", "getRemoteInstance", "set", "instanceFlavor", "getRemoteInstanceFlavor", "set", "username", "viewer", "set", "ip", "viewer", "getRemoteAddress", "success"]}, "repository": {"repo_id": 100069523, "url": "https://github.com/Subterranean-Security/Sandpolis", "stars": 25, "created": "8/11/2017 8:55:30 PM +00:00", "updates": "2020-01-27T01:41:01+00:00", "fork": "False", "license": "licensed"}}