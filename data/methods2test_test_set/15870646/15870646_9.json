{"test_class": {"identifier": "OsmNogoPolygonTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final int OFFSET_X = 11000000;", "modifier": "static final", "type": "int", "declarator": "OFFSET_X = 11000000", "var_name": "OFFSET_X"}, {"original_string": "static final int OFFSET_Y = 50000000;", "modifier": "static final", "type": "int", "declarator": "OFFSET_Y = 50000000", "var_name": "OFFSET_Y"}, {"original_string": "static OsmNogoPolygon polygon;", "modifier": "static", "type": "OsmNogoPolygon", "declarator": "polygon", "var_name": "polygon"}, {"original_string": "static OsmNogoPolygon polyline;", "modifier": "static", "type": "OsmNogoPolygon", "declarator": "polyline", "var_name": "polyline"}, {"original_string": "static final double[] lons = {  1.0,  1.0,  0.5, 0.5, 1.0, 1.0, -1.1, -1.0 };", "modifier": "static final", "type": "double[]", "declarator": "lons = {  1.0,  1.0,  0.5, 0.5, 1.0, 1.0, -1.1, -1.0 }", "var_name": "lons"}, {"original_string": "static final double[] lats = { -1.0, -0.1, -0.1, 0.1, 0.1, 1.0,  1.1, -1.0 };", "modifier": "static final", "type": "double[]", "declarator": "lats = { -1.0, -0.1, -0.1, 0.1, 0.1, 1.0,  1.1, -1.0 }", "var_name": "lats"}], "file": "brouter-core/src/test/java/btools/router/OsmNogoPolygonTest.java"}, "test_case": {"identifier": "testDistanceWithinPolygon", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testDistanceWithinPolygon() {\n      // Testing polygon\n      final double[] lons = { 2.333523, 2.333432, 2.333833, 2.333983, 2.334815, 2.334766 };\n      final double[] lats = { 48.823778, 48.824091, 48.82389, 48.824165, 48.824232, 48.82384 };\n      OsmNogoPolygon polygon = new OsmNogoPolygon(true);\n      for (int i = 0; i < lons.length; i++) {\n          polygon.addVertex(toOsmLon(lons[i], 0), toOsmLat(lats[i], 0));\n      }\n      OsmNogoPolygon polyline = new OsmNogoPolygon(false);\n      for (int i = 0; i < lons.length; i++) {\n          polyline.addVertex(toOsmLon(lons[i], 0), toOsmLat(lats[i], 0));\n      }\n\n      // Check with a segment with a single intersection with the polygon\n      int lon1 = toOsmLon(2.33308732509613, 0);\n      int lat1 = toOsmLat(48.8238790443901, 0);\n      int lon2 = toOsmLon(2.33378201723099, 0);\n      int lat2 = toOsmLat(48.8239585098974, 0);\n      assertEquals(\n        \"Should give the correct length for a segment with a single intersection\",\n        17.5,\n        polygon.distanceWithinPolygon(lon1, lat1, lon2, lat2),\n        0.05 * 17.5\n      );\n\n      // Check with a segment crossing multiple times the polygon\n      lon2 = toOsmLon(2.33488172292709, 0);\n      lat2 = toOsmLat(48.8240891862353, 0);\n      assertEquals(\n        \"Should give the correct length for a segment with multiple intersections\",\n        85,\n        polygon.distanceWithinPolygon(lon1, lat1, lon2, lat2),\n        0.05 * 85\n      );\n\n      // Check that it works when a point is within the polygon\n      lon2 = toOsmLon(2.33433187007904, 0);\n      lat2 = toOsmLat(48.8240238480664, 0);\n      assertEquals(\n        \"Should give the correct length when last point is within the polygon\",\n        50,\n        polygon.distanceWithinPolygon(lon1, lat1, lon2, lat2),\n        0.05 * 50\n      );\n      lon1 = toOsmLon(2.33433187007904, 0);\n      lat1 = toOsmLat(48.8240238480664, 0);\n      lon2 = toOsmLon(2.33488172292709, 0);\n      lat2 = toOsmLat(48.8240891862353, 0);\n      assertEquals(\n        \"Should give the correct length when first point is within the polygon\",\n        35,\n        polygon.distanceWithinPolygon(lon1, lat1, lon2, lat2),\n        0.05 * 35\n      );\n\n      lon1 = toOsmLon(2.333523, 0);\n      lat1 = toOsmLat(48.823778, 0);\n      lon2 = toOsmLon(2.333432, 0);\n      lat2 = toOsmLat(48.824091, 0);\n      assertEquals(\n        \"Should give the correct length if the segment overlaps with an edge of the polygon\",\n        CheapRuler.distance(lon1, lat1, lon2, lat2),\n        polygon.distanceWithinPolygon(lon1, lat1, lon2, lat2),\n        0.05 * CheapRuler.distance(lon1, lat1, lon2, lat2)\n      );\n\n      lon1 = toOsmLon(2.333523, 0);\n      lat1 = toOsmLat(48.823778, 0);\n      lon2 = toOsmLon(2.3334775, 0);\n      lat2 = toOsmLat(48.8239345, 0);\n      assertEquals(\n        \"Should give the correct length if the segment overlaps with a polyline\",\n        CheapRuler.distance(lon1, lat1, lon2, lat2),\n        polyline.distanceWithinPolygon(lon1, lat1, lon2, lat2),\n        0.05 * CheapRuler.distance(lon1, lat1, lon2, lat2)\n      );\n  }", "signature": "void testDistanceWithinPolygon()", "full_signature": "@Test public void testDistanceWithinPolygon()", "class_method_signature": "OsmNogoPolygonTest.testDistanceWithinPolygon()", "testcase": true, "constructor": false, "invocations": ["addVertex", "toOsmLon", "toOsmLat", "addVertex", "toOsmLon", "toOsmLat", "toOsmLon", "toOsmLat", "toOsmLon", "toOsmLat", "assertEquals", "distanceWithinPolygon", "toOsmLon", "toOsmLat", "assertEquals", "distanceWithinPolygon", "toOsmLon", "toOsmLat", "assertEquals", "distanceWithinPolygon", "toOsmLon", "toOsmLat", "toOsmLon", "toOsmLat", "assertEquals", "distanceWithinPolygon", "toOsmLon", "toOsmLat", "toOsmLon", "toOsmLat", "assertEquals", "distance", "distanceWithinPolygon", "distance", "toOsmLon", "toOsmLat", "toOsmLon", "toOsmLat", "assertEquals", "distance", "distanceWithinPolygon", "distance"]}, "focal_class": {"identifier": "OsmNogoPolygon", "superclass": "extends OsmNodeNamed", "interfaces": "", "fields": [{"original_string": "public final List<Point> points = new ArrayList<Point>();", "modifier": "public final", "type": "List<Point>", "declarator": "points = new ArrayList<Point>()", "var_name": "points"}, {"original_string": "public final boolean isClosed;", "modifier": "public final", "type": "boolean", "declarator": "isClosed", "var_name": "isClosed"}], "methods": [{"identifier": "OsmNogoPolygon", "parameters": "(boolean closed)", "modifiers": "public", "return": "", "signature": " OsmNogoPolygon(boolean closed)", "full_signature": "public  OsmNogoPolygon(boolean closed)", "class_method_signature": "OsmNogoPolygon.OsmNogoPolygon(boolean closed)", "testcase": false, "constructor": true}, {"identifier": "addVertex", "parameters": "(int lon, int lat)", "modifiers": "public final", "return": "void", "signature": "void addVertex(int lon, int lat)", "full_signature": "public final void addVertex(int lon, int lat)", "class_method_signature": "OsmNogoPolygon.addVertex(int lon, int lat)", "testcase": false, "constructor": false}, {"identifier": "calcBoundingCircle", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void calcBoundingCircle()", "full_signature": "public void calcBoundingCircle()", "class_method_signature": "OsmNogoPolygon.calcBoundingCircle()", "testcase": false, "constructor": false}, {"identifier": "intersects", "parameters": "(int lon0, int lat0, int lon1, int lat1)", "modifiers": "public", "return": "boolean", "signature": "boolean intersects(int lon0, int lat0, int lon1, int lat1)", "full_signature": "public boolean intersects(int lon0, int lat0, int lon1, int lat1)", "class_method_signature": "OsmNogoPolygon.intersects(int lon0, int lat0, int lon1, int lat1)", "testcase": false, "constructor": false}, {"identifier": "isOnPolyline", "parameters": "( long px, long py )", "modifiers": "public", "return": "boolean", "signature": "boolean isOnPolyline( long px, long py )", "full_signature": "public boolean isOnPolyline( long px, long py )", "class_method_signature": "OsmNogoPolygon.isOnPolyline( long px, long py )", "testcase": false, "constructor": false}, {"identifier": "isOnLine", "parameters": "( long px, long py, long p0x, long p0y, long p1x, long p1y )", "modifiers": "public static", "return": "boolean", "signature": "boolean isOnLine( long px, long py, long p0x, long p0y, long p1x, long p1y )", "full_signature": "public static boolean isOnLine( long px, long py, long p0x, long p0y, long p1x, long p1y )", "class_method_signature": "OsmNogoPolygon.isOnLine( long px, long py, long p0x, long p0y, long p1x, long p1y )", "testcase": false, "constructor": false}, {"identifier": "isWithin", "parameters": "(final long px, final long py)", "modifiers": "public", "return": "boolean", "signature": "boolean isWithin(final long px, final long py)", "full_signature": "public boolean isWithin(final long px, final long py)", "class_method_signature": "OsmNogoPolygon.isWithin(final long px, final long py)", "testcase": false, "constructor": false}, {"identifier": "distanceWithinPolygon", "parameters": "(int lon1, int lat1, int lon2, int lat2)", "modifiers": "public", "return": "double", "signature": "double distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "full_signature": "public double distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "class_method_signature": "OsmNogoPolygon.distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "testcase": false, "constructor": false}, {"identifier": "inSegment", "parameters": "( final Point p, final Point seg_p0, final Point seg_p1)", "modifiers": "private static", "return": "boolean", "signature": "boolean inSegment( final Point p, final Point seg_p0, final Point seg_p1)", "full_signature": "private static boolean inSegment( final Point p, final Point seg_p0, final Point seg_p1)", "class_method_signature": "OsmNogoPolygon.inSegment( final Point p, final Point seg_p0, final Point seg_p1)", "testcase": false, "constructor": false}, {"identifier": "intersect2D_2Segments", "parameters": "( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "modifiers": "private static", "return": "int", "signature": "int intersect2D_2Segments( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "full_signature": "private static int intersect2D_2Segments( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "class_method_signature": "OsmNogoPolygon.intersect2D_2Segments( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "testcase": false, "constructor": false}], "file": "brouter-core/src/main/java/btools/router/OsmNogoPolygon.java"}, "focal_method": {"identifier": "distanceWithinPolygon", "parameters": "(int lon1, int lat1, int lon2, int lat2)", "modifiers": "public", "return": "double", "body": "public double distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2) {\n    double distance = 0.;\n\n    // Extremities of the segments\n    final Point p1 = new Point (lon1, lat1);\n    final Point p2 = new Point (lon2, lat2);\n\n    Point previousIntersectionOnSegment = null;\n    if (isWithin(lon1, lat1))\n    {\n      // Start point of the segment is within the polygon, this is the first\n      // \"intersection\".\n      previousIntersectionOnSegment = p1;\n    }\n\n    // Loop over edges of the polygon to find intersections\n    int i_last = points.size() - 1;\n    for (int i = (isClosed ? 0 : 1), j = (isClosed ? i_last : 0); i <= i_last; j = i++)\n    {\n      Point edgePoint1 = points.get(j);\n      Point edgePoint2 = points.get(i);\n      int intersectsEdge = intersect2D_2Segments(p1, p2, edgePoint1, edgePoint2);\n\n      if (isClosed && intersectsEdge == 1)\n      {\n        // Intersects with a (closed) polygon edge on a single point\n        // Distance is zero when crossing a polyline.\n        // Let's find this intersection point\n        int xdiffSegment = lon1 - lon2;\n        int xdiffEdge = edgePoint1.x - edgePoint2.x;\n        int ydiffSegment = lat1 - lat2;\n        int ydiffEdge = edgePoint1.y - edgePoint2.y;\n        int div = xdiffSegment * ydiffEdge - xdiffEdge * ydiffSegment;\n        long dSegment = (long) lon1 * (long) lat2 - (long) lon2 * (long) lat1;\n        long dEdge = (long) edgePoint1.x * (long) edgePoint2.y - (long) edgePoint2.x * (long) edgePoint1.y;\n        // Coordinates of the intersection\n        Point intersection = new Point(\n          (int) ((dSegment * xdiffEdge - dEdge * xdiffSegment) / div),\n          (int) ((dSegment * ydiffEdge - dEdge * ydiffSegment) / div)\n        );\n        if (\n          previousIntersectionOnSegment != null\n          && isWithin(\n            (intersection.x + previousIntersectionOnSegment.x) >> 1,\n            (intersection.y + previousIntersectionOnSegment.y) >> 1\n          )\n        ) {\n          // There was a previous match within the polygon and this part of the\n          // segment is within the polygon.\n          distance += CheapRuler.distance(\n            previousIntersectionOnSegment.x, previousIntersectionOnSegment.y,\n            intersection.x, intersection.y\n          );\n        }\n        previousIntersectionOnSegment = intersection;\n      }\n      else if (intersectsEdge == 2) {\n        // Segment and edge overlaps\n        // FIXME: Could probably be done in a smarter way\n        distance += Math.min(\n          CheapRuler.distance(p1.x, p1.y, p2.x, p2.y),\n          Math.min(\n            CheapRuler.distance(edgePoint1.x, edgePoint1.y, edgePoint2.x, edgePoint2.y),\n            Math.min(\n              CheapRuler.distance(p1.x, p1.y, edgePoint2.x, edgePoint2.y),\n              CheapRuler.distance(edgePoint1.x, edgePoint1.y, p2.x, p2.y)\n            )\n          )\n        );\n        // FIXME: We could store intersection.\n        previousIntersectionOnSegment = null;\n      }\n    }\n\n    if (\n      previousIntersectionOnSegment != null\n      && isWithin(lon2, lat2)\n    ) {\n      // Last point is within the polygon, add the remaining missing distance.\n      distance += CheapRuler.distance(\n        previousIntersectionOnSegment.x, previousIntersectionOnSegment.y,\n        lon2, lat2\n      );\n    }\n    return distance;\n  }", "signature": "double distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "full_signature": "public double distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "class_method_signature": "OsmNogoPolygon.distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "testcase": false, "constructor": false, "invocations": ["isWithin", "size", "get", "get", "intersect2D_2Segments", "isWithin", "distance", "min", "distance", "min", "distance", "min", "distance", "distance", "isWithin", "distance"]}, "repository": {"repo_id": 15870646, "url": "https://github.com/abrensch/brouter", "language": "Java", "is_fork": false, "fork_count": 65, "stargazer_count": 172, "size": 3569, "license": "licensed"}}