{"test_class": {"identifier": "TestUDPPublishHandler", "superclass": "", "interfaces": "", "fields": [{"original_string": "FalseSocket fakeSocket;", "modifier": "", "type": "FalseSocket", "declarator": "fakeSocket", "var_name": "fakeSocket"}, {"original_string": "String sourceName;", "modifier": "", "type": "String", "declarator": "sourceName", "var_name": "sourceName"}, {"original_string": "ExtensionServiceMessage extMsg;", "modifier": "", "type": "ExtensionServiceMessage", "declarator": "extMsg", "var_name": "extMsg"}, {"original_string": "ObjectMapper mapper = new ObjectMapper();", "modifier": "", "type": "ObjectMapper", "declarator": "mapper = new ObjectMapper()", "var_name": "mapper"}, {"original_string": "int port;", "modifier": "", "type": "int", "declarator": "port", "var_name": "port"}, {"original_string": "String address;", "modifier": "", "type": "String", "declarator": "address", "var_name": "address"}, {"original_string": "UDPPublishHandler pHandler;", "modifier": "", "type": "UDPPublishHandler", "declarator": "pHandler", "var_name": "pHandler"}, {"original_string": "Map<String,Object> outgoing = new LinkedHashMap<>();", "modifier": "", "type": "Map<String,Object>", "declarator": "outgoing = new LinkedHashMap<>()", "var_name": "outgoing"}], "file": "udpSource/src/test/java/io/vantiq/extsrc/udp/TestUDPPublishHandler.java"}, "test_case": {"identifier": "testXml", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testXml() {\n        outgoing.put(\"sendXmlRoot\", \"route\");\n        outgoing.put(\"passPureMapOut\", true);\n        \n        pHandler = new UDPPublishHandler(outgoing, fakeSocket, sourceName);\n        \n        Map<String,Object> testMap = new LinkedHashMap<>();\n        testMap.put(\"Hello\", \"World\");\n        testMap.put(\"Goodbye\",\"Cruel World\");\n        \n        String expectedData = \"<route><Hello>World</Hello><Goodbye>Cruel World</Goodbye></route>\";\n        \n        // Test UUT\n        createMessage(testMap);\n        pHandler.handleMessage(extMsg);\n        \n        assert fakeSocket.compareData(expectedData);\n    }", "signature": "void testXml()", "full_signature": "@Test public void testXml()", "class_method_signature": "TestUDPPublishHandler.testXml()", "testcase": true, "constructor": false, "invocations": ["put", "put", "put", "put", "createMessage", "handleMessage", "compareData"]}, "focal_class": {"identifier": "UDPPublishHandler", "superclass": "extends Handler<ExtensionServiceMessage>", "interfaces": "", "fields": [{"original_string": "private MapTransformer transformer = null;", "modifier": "private", "type": "MapTransformer", "declarator": "transformer = null", "var_name": "transformer"}, {"original_string": "private InetAddress address;", "modifier": "private", "type": "InetAddress", "declarator": "address", "var_name": "address"}, {"original_string": "private int port;", "modifier": "private", "type": "int", "declarator": "port", "var_name": "port"}, {"original_string": "private DatagramSocket socket;", "modifier": "private", "type": "DatagramSocket", "declarator": "socket", "var_name": "socket"}, {"original_string": "private ObjectWriter writer = new ObjectMapper().writer();", "modifier": "private", "type": "ObjectWriter", "declarator": "writer = new ObjectMapper().writer()", "var_name": "writer"}, {"original_string": "final private Logger log;", "modifier": "final private", "type": "Logger", "declarator": "log", "var_name": "log"}, {"original_string": "private boolean passingPureMap = false;", "modifier": "private", "type": "boolean", "declarator": "passingPureMap = false", "var_name": "passingPureMap"}, {"original_string": "private boolean passingUnspecified = false;", "modifier": "private", "type": "boolean", "declarator": "passingUnspecified = false", "var_name": "passingUnspecified"}, {"original_string": "private String bytesLocation = null;", "modifier": "private", "type": "String", "declarator": "bytesLocation = null", "var_name": "bytesLocation"}, {"original_string": "private String formatPattern = null;", "modifier": "private", "type": "String", "declarator": "formatPattern = null", "var_name": "formatPattern"}, {"original_string": "private Formatter formatter = null;", "modifier": "private", "type": "Formatter", "declarator": "formatter = null", "var_name": "formatter"}, {"original_string": "private String[] formatLocations = null;", "modifier": "private", "type": "String[]", "declarator": "formatLocations = null", "var_name": "formatLocations"}, {"original_string": "private StringBuilder formattedString = null;", "modifier": "private", "type": "StringBuilder", "declarator": "formattedString = null", "var_name": "formattedString"}, {"original_string": "private String altPatternLocation = null;", "modifier": "private", "type": "String", "declarator": "altPatternLocation = null", "var_name": "altPatternLocation"}, {"original_string": "private String altLocations = null;", "modifier": "private", "type": "String", "declarator": "altLocations = null", "var_name": "altLocations"}, {"original_string": "private String csvSource = null;", "modifier": "private", "type": "String", "declarator": "csvSource = null", "var_name": "csvSource"}, {"original_string": "private CsvSchema csvSchema = null;", "modifier": "private", "type": "CsvSchema", "declarator": "csvSchema = null", "var_name": "csvSchema"}, {"original_string": "private String csvSchemaLocation = null;", "modifier": "private", "type": "String", "declarator": "csvSchemaLocation = null", "var_name": "csvSchemaLocation"}], "methods": [{"identifier": "UDPPublishHandler", "parameters": "(Map outgoing, DatagramSocket socket, String sourceName)", "modifiers": "public", "return": "", "signature": " UDPPublishHandler(Map outgoing, DatagramSocket socket, String sourceName)", "full_signature": "public  UDPPublishHandler(Map outgoing, DatagramSocket socket, String sourceName)", "class_method_signature": "UDPPublishHandler.UDPPublishHandler(Map outgoing, DatagramSocket socket, String sourceName)", "testcase": false, "constructor": true}, {"identifier": "hasOutgoingTransformations", "parameters": "(Map outgoing)", "modifiers": "private static", "return": "boolean", "signature": "boolean hasOutgoingTransformations(Map outgoing)", "full_signature": "private static boolean hasOutgoingTransformations(Map outgoing)", "class_method_signature": "UDPPublishHandler.hasOutgoingTransformations(Map outgoing)", "testcase": false, "constructor": false}, {"identifier": "handleMessage", "parameters": "(ExtensionServiceMessage message)", "modifiers": "@Override public", "return": "void", "signature": "void handleMessage(ExtensionServiceMessage message)", "full_signature": "@Override public void handleMessage(ExtensionServiceMessage message)", "class_method_signature": "UDPPublishHandler.handleMessage(ExtensionServiceMessage message)", "testcase": false, "constructor": false}, {"identifier": "buildCsv", "parameters": "(Map<String,Object> map)", "modifiers": "private", "return": "String", "signature": "String buildCsv(Map<String,Object> map)", "full_signature": "private String buildCsv(Map<String,Object> map)", "class_method_signature": "UDPPublishHandler.buildCsv(Map<String,Object> map)", "testcase": false, "constructor": false}, {"identifier": "getFormattedOutput", "parameters": "(Map receivedData)", "modifiers": "private", "return": "byte[]", "signature": "byte[] getFormattedOutput(Map receivedData)", "full_signature": "private byte[] getFormattedOutput(Map receivedData)", "class_method_signature": "UDPPublishHandler.getFormattedOutput(Map receivedData)", "testcase": false, "constructor": false}, {"identifier": "retrieveLocationsFrom", "parameters": "(List potentialLocations)", "modifiers": "private", "return": "String[]", "signature": "String[] retrieveLocationsFrom(List potentialLocations)", "full_signature": "private String[] retrieveLocationsFrom(List potentialLocations)", "class_method_signature": "UDPPublishHandler.retrieveLocationsFrom(List potentialLocations)", "testcase": false, "constructor": false}], "file": "udpSource/src/main/java/io/vantiq/extsrc/udp/UDPPublishHandler.java"}, "focal_method": {"identifier": "handleMessage", "parameters": "(ExtensionServiceMessage message)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void handleMessage(ExtensionServiceMessage message) {\n        Map receivedMsg = (Map) message.getObject();\n        Map sendMsg = new LinkedHashMap<String,Object>();\n        byte[] sendBytes = null;\n\n        // Translate the message as requested in the Configuration document\n        if (formatLocations != null) {\n            sendBytes = getFormattedOutput(receivedMsg);\n        }\n        else if (csvSource != null) {\n            String str = buildCsv(receivedMsg);\n            sendBytes = str.getBytes();\n        }\n        else if (bytesLocation != null) {\n            sendBytes = ((String)receivedMsg.get(bytesLocation)).getBytes();\n        }\n        else if (passingPureMap) {\n            sendMsg = receivedMsg;\n        }\n        else if (passingUnspecified) {\n            sendMsg = receivedMsg;\n            if (this.transformer != null) {\n                this.transformer.transform(receivedMsg, sendMsg, true);\n            }\n        }\n        else if (transformer == null) {\n            // This means that no transform was specified and neither were any pass___ parameters in which case\n            // the design decision is to send an empty Map, so the UDP server is notified that a Publish was sent\n            sendMsg = new LinkedHashMap<String,Object>();\n        }\n        else {\n            this.transformer.transform(receivedMsg, sendMsg, false);\n        }\n\n        \n        // Turn the message into bytes for a UDP message then send it\n        try {\n            if (sendBytes == null) {\n                log.debug(\"Sending message to address {} and port {} with contents: {}\"\n                        , address.getHostAddress(), port, sendMsg);\n                sendBytes = writer.writeValueAsBytes(sendMsg);\n            }\n            else {\n                log.debug(\"Sending message to address {} and port {} with contents: {}\"\n                        , address.getHostAddress(), port, new String(sendBytes));\n            }\n            DatagramPacket packet = new DatagramPacket(sendBytes, sendBytes.length, address, port);\n            socket.send(packet);\n        }\n        catch (Exception e) {\n            log.warn(\"Failed trying to translate and send the message.\", e);\n        }\n    }", "signature": "void handleMessage(ExtensionServiceMessage message)", "full_signature": "@Override public void handleMessage(ExtensionServiceMessage message)", "class_method_signature": "UDPPublishHandler.handleMessage(ExtensionServiceMessage message)", "testcase": false, "constructor": false, "invocations": ["getObject", "getFormattedOutput", "buildCsv", "getBytes", "getBytes", "get", "transform", "transform", "debug", "getHostAddress", "writeValueAsBytes", "debug", "getHostAddress", "send", "warn"]}, "repository": {"repo_id": 141492069, "url": "https://github.com/Vantiq/vantiq-extension-sources", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 9, "size": 16261, "license": "licensed"}}