{"test_class": {"identifier": "STCClusteringAlgorithmTest", "superclass": "extends ClusteringAlgorithmTestBase<STCClusteringAlgorithm>", "interfaces": "", "fields": [], "file": "core/src/test/java/org/carrot2/clustering/stc/STCClusteringAlgorithmTest.java"}, "test_case": {"identifier": "testComputeIntersection", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testComputeIntersection() {\n    int[] t1;\n\n    t1 = new int[] {0, 1, 2, 1, 2, 3};\n    Assertions.assertThat(STCClusteringAlgorithm.computeIntersection(t1, 0, 3, t1, 3, 3))\n        .isEqualTo(2);\n\n    t1 = new int[] {0, 1, 2, 3, 5, 6};\n    Assertions.assertThat(STCClusteringAlgorithm.computeIntersection(t1, 0, 3, t1, 3, 3))\n        .isEqualTo(0);\n\n    t1 = new int[] {0, 1, 2, -1, 2, 6};\n    Assertions.assertThat(STCClusteringAlgorithm.computeIntersection(t1, 0, 3, t1, 3, 3))\n        .isEqualTo(1);\n\n    t1 = new int[] {0, 1, 2, 0};\n    Assertions.assertThat(STCClusteringAlgorithm.computeIntersection(t1, 0, 3, t1, 3, 1))\n        .isEqualTo(1);\n  }", "signature": "void testComputeIntersection()", "full_signature": "@Test public void testComputeIntersection()", "class_method_signature": "STCClusteringAlgorithmTest.testComputeIntersection()", "testcase": true, "constructor": false, "invocations": ["isEqualTo", "assertThat", "computeIntersection", "isEqualTo", "assertThat", "computeIntersection", "isEqualTo", "assertThat", "computeIntersection", "isEqualTo", "assertThat", "computeIntersection"]}, "focal_class": {"identifier": "STCClusteringAlgorithm", "superclass": "extends AttrComposite", "interfaces": "implements ClusteringAlgorithm", "fields": [{"original_string": "private static final Set<Class<?>> REQUIRED_LANGUAGE_COMPONENTS =\n      new HashSet<>(\n          Arrays.asList(Stemmer.class, Tokenizer.class, LexicalData.class, LabelFormatter.class));", "modifier": "private static final", "type": "Set<Class<?>>", "declarator": "REQUIRED_LANGUAGE_COMPONENTS =\n      new HashSet<>(\n          Arrays.asList(Stemmer.class, Tokenizer.class, LexicalData.class, LabelFormatter.class))", "var_name": "REQUIRED_LANGUAGE_COMPONENTS"}, {"original_string": "public static final String NAME = \"STC\";", "modifier": "public static final", "type": "String", "declarator": "NAME = \"STC\"", "var_name": "NAME"}, {"original_string": "public final AttrString queryHint =\n      attributes.register(\"queryHint\", SharedInfrastructure.queryHintAttribute());", "modifier": "public final", "type": "AttrString", "declarator": "queryHint =\n      attributes.register(\"queryHint\", SharedInfrastructure.queryHintAttribute())", "var_name": "queryHint"}, {"original_string": "public AttrDouble ignoreWordIfInHigherDocsPercent =\n      attributes.register(\n          \"ignoreWordIfInHigherDocsPercent\",\n          AttrDouble.builder()\n              .label(\"Ignore words appearing in more than a given fraction of documents\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.9));", "modifier": "public", "type": "AttrDouble", "declarator": "ignoreWordIfInHigherDocsPercent =\n      attributes.register(\n          \"ignoreWordIfInHigherDocsPercent\",\n          AttrDouble.builder()\n              .label(\"Ignore words appearing in more than a given fraction of documents\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.9))", "var_name": "ignoreWordIfInHigherDocsPercent"}, {"original_string": "public AttrDouble minBaseClusterScore =\n      attributes.register(\n          \"minBaseClusterScore\",\n          AttrDouble.builder().label(\"Minimum base cluster score\").min(0).max(10).defaultValue(2.));", "modifier": "public", "type": "AttrDouble", "declarator": "minBaseClusterScore =\n      attributes.register(\n          \"minBaseClusterScore\",\n          AttrDouble.builder().label(\"Minimum base cluster score\").min(0).max(10).defaultValue(2.))", "var_name": "minBaseClusterScore"}, {"original_string": "public AttrInteger minBaseClusterSize =\n      attributes.register(\n          \"minBaseClusterSize\",\n          AttrInteger.builder()\n              .label(\"Minimum number of documents in a base cluster\")\n              .min(2)\n              .max(20)\n              .defaultValue(2));", "modifier": "public", "type": "AttrInteger", "declarator": "minBaseClusterSize =\n      attributes.register(\n          \"minBaseClusterSize\",\n          AttrInteger.builder()\n              .label(\"Minimum number of documents in a base cluster\")\n              .min(2)\n              .max(20)\n              .defaultValue(2))", "var_name": "minBaseClusterSize"}, {"original_string": "public AttrInteger maxBaseClusters =\n      attributes.register(\n          \"maxBaseClusters\",\n          AttrInteger.builder().label(\"Maximum number of base cluster\").min(2).defaultValue(300));", "modifier": "public", "type": "AttrInteger", "declarator": "maxBaseClusters =\n      attributes.register(\n          \"maxBaseClusters\",\n          AttrInteger.builder().label(\"Maximum number of base cluster\").min(2).defaultValue(300))", "var_name": "maxBaseClusters"}, {"original_string": "public AttrInteger maxClusters =\n      attributes.register(\n          \"maxClusters\",\n          AttrInteger.builder().label(\"Maximum number of final clusters\").min(1).defaultValue(15));", "modifier": "public", "type": "AttrInteger", "declarator": "maxClusters =\n      attributes.register(\n          \"maxClusters\",\n          AttrInteger.builder().label(\"Maximum number of final clusters\").min(1).defaultValue(15))", "var_name": "maxClusters"}, {"original_string": "public AttrDouble mergeThreshold =\n      attributes.register(\n          \"mergeThreshold\",\n          AttrDouble.builder()\n              .label(\"Base cluster merge threshold\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.6));", "modifier": "public", "type": "AttrDouble", "declarator": "mergeThreshold =\n      attributes.register(\n          \"mergeThreshold\",\n          AttrDouble.builder()\n              .label(\"Base cluster merge threshold\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.6))", "var_name": "mergeThreshold"}, {"original_string": "public AttrDouble maxPhraseOverlap =\n      attributes.register(\n          \"maxPhraseOverlap\",\n          AttrDouble.builder()\n              .label(\"Maximum cluster phrase overlap\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.6));", "modifier": "public", "type": "AttrDouble", "declarator": "maxPhraseOverlap =\n      attributes.register(\n          \"maxPhraseOverlap\",\n          AttrDouble.builder()\n              .label(\"Maximum cluster phrase overlap\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.6))", "var_name": "maxPhraseOverlap"}, {"original_string": "public AttrDouble mostGeneralPhraseCoverage =\n      attributes.register(\n          \"mostGeneralPhraseCoverage\",\n          AttrDouble.builder()\n              .label(\"Minimum general phrase coverage\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.5));", "modifier": "public", "type": "AttrDouble", "declarator": "mostGeneralPhraseCoverage =\n      attributes.register(\n          \"mostGeneralPhraseCoverage\",\n          AttrDouble.builder()\n              .label(\"Minimum general phrase coverage\")\n              .min(0)\n              .max(1)\n              .defaultValue(0.5))", "var_name": "mostGeneralPhraseCoverage"}, {"original_string": "public AttrInteger maxWordsPerLabel =\n      attributes.register(\n          \"maxWordsPerLabel\",\n          AttrInteger.builder().label(\"Maximum words per label\").min(1).defaultValue(4));", "modifier": "public", "type": "AttrInteger", "declarator": "maxWordsPerLabel =\n      attributes.register(\n          \"maxWordsPerLabel\",\n          AttrInteger.builder().label(\"Maximum words per label\").min(1).defaultValue(4))", "var_name": "maxWordsPerLabel"}, {"original_string": "public AttrInteger maxPhrasesPerLabel =\n      attributes.register(\n          \"maxPhrasesPerLabel\",\n          AttrInteger.builder().label(\"Maximum phrases per label\").min(1).defaultValue(3));", "modifier": "public", "type": "AttrInteger", "declarator": "maxPhrasesPerLabel =\n      attributes.register(\n          \"maxPhrasesPerLabel\",\n          AttrInteger.builder().label(\"Maximum phrases per label\").min(1).defaultValue(3))", "var_name": "maxPhrasesPerLabel"}, {"original_string": "public AttrDouble singleTermBoost =\n      attributes.register(\n          \"singleTermBoost\",\n          AttrDouble.builder().label(\"Boost single-term clusters\").min(0).defaultValue(0.5));", "modifier": "public", "type": "AttrDouble", "declarator": "singleTermBoost =\n      attributes.register(\n          \"singleTermBoost\",\n          AttrDouble.builder().label(\"Boost single-term clusters\").min(0).defaultValue(0.5))", "var_name": "singleTermBoost"}, {"original_string": "public AttrInteger optimalPhraseLength =\n      attributes.register(\n          \"optimalPhraseLength\",\n          AttrInteger.builder().label(\"Optimal cluster label length\").min(1).defaultValue(3));", "modifier": "public", "type": "AttrInteger", "declarator": "optimalPhraseLength =\n      attributes.register(\n          \"optimalPhraseLength\",\n          AttrInteger.builder().label(\"Optimal cluster label length\").min(1).defaultValue(3))", "var_name": "optimalPhraseLength"}, {"original_string": "public AttrDouble optimalPhraseLengthDev =\n      attributes.register(\n          \"optimalPhraseLengthDev\",\n          AttrDouble.builder()\n              .label(\"Optimal cluster label length's tolerance\")\n              .min(0.5)\n              .defaultValue(2.));", "modifier": "public", "type": "AttrDouble", "declarator": "optimalPhraseLengthDev =\n      attributes.register(\n          \"optimalPhraseLengthDev\",\n          AttrDouble.builder()\n              .label(\"Optimal cluster label length's tolerance\")\n              .min(0.5)\n              .defaultValue(2.))", "var_name": "optimalPhraseLengthDev"}, {"original_string": "public AttrDouble documentCountBoost =\n      attributes.register(\n          \"documentCountBoost\",\n          AttrDouble.builder().label(\"Base cluster document count boost\").min(0).defaultValue(1.));", "modifier": "public", "type": "AttrDouble", "declarator": "documentCountBoost =\n      attributes.register(\n          \"documentCountBoost\",\n          AttrDouble.builder().label(\"Base cluster document count boost\").min(0).defaultValue(1.))", "var_name": "documentCountBoost"}, {"original_string": "public AttrDouble scoreWeight =\n      attributes.register(\n          \"scoreWeight\",\n          AttrDouble.builder().label(\"Size-score sorting ratio\").min(0).max(1).defaultValue(0.));", "modifier": "public", "type": "AttrDouble", "declarator": "scoreWeight =\n      attributes.register(\n          \"scoreWeight\",\n          AttrDouble.builder().label(\"Size-score sorting ratio\").min(0).max(1).defaultValue(0.))", "var_name": "scoreWeight"}, {"original_string": "public AttrBoolean mergeStemEquivalentBaseClusters =\n      attributes.register(\n          \"mergeStemEquivalentBaseClusters\",\n          AttrBoolean.builder()\n              .label(\"Merge all stem-equivalent phrases when discovering base clusters\")\n              .defaultValue(true));", "modifier": "public", "type": "AttrBoolean", "declarator": "mergeStemEquivalentBaseClusters =\n      attributes.register(\n          \"mergeStemEquivalentBaseClusters\",\n          AttrBoolean.builder()\n              .label(\"Merge all stem-equivalent phrases when discovering base clusters\")\n              .defaultValue(true))", "var_name": "mergeStemEquivalentBaseClusters"}, {"original_string": "public BasicPreprocessingPipeline preprocessing;", "modifier": "public", "type": "BasicPreprocessingPipeline", "declarator": "preprocessing", "var_name": "preprocessing"}, {"original_string": "private LabelFormatter labelFormatter;", "modifier": "private", "type": "LabelFormatter", "declarator": "labelFormatter", "var_name": "labelFormatter"}, {"original_string": "private static final Predicate<PhraseCandidate> NOT_SELECTED = (p) -> !p.selected;", "modifier": "private static final", "type": "Predicate<PhraseCandidate>", "declarator": "NOT_SELECTED = (p) -> !p.selected", "var_name": "NOT_SELECTED"}, {"original_string": "private GeneralizedSuffixTree.SequenceBuilder sb;", "modifier": "private", "type": "GeneralizedSuffixTree.SequenceBuilder", "declarator": "sb", "var_name": "sb"}, {"original_string": "private PreprocessingContext context;", "modifier": "private", "type": "PreprocessingContext", "declarator": "context", "var_name": "context"}], "methods": [{"identifier": "requiredLanguageComponents", "parameters": "()", "modifiers": "@Override public", "return": "Set<Class<?>>", "signature": "Set<Class<?>> requiredLanguageComponents()", "full_signature": "@Override public Set<Class<?>> requiredLanguageComponents()", "class_method_signature": "STCClusteringAlgorithm.requiredLanguageComponents()", "testcase": false, "constructor": false}, {"identifier": "cluster", "parameters": "(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "modifiers": "@Override public", "return": "List<Cluster<T>>", "signature": "List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "full_signature": "@Override public List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "class_method_signature": "STCClusteringAlgorithm.cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "testcase": false, "constructor": false}, {"identifier": "createBaseClusters", "parameters": "(SequenceBuilder sb)", "modifiers": "private", "return": "List<ClusterCandidate>", "signature": "List<ClusterCandidate> createBaseClusters(SequenceBuilder sb)", "full_signature": "private List<ClusterCandidate> createBaseClusters(SequenceBuilder sb)", "class_method_signature": "STCClusteringAlgorithm.createBaseClusters(SequenceBuilder sb)", "testcase": false, "constructor": false}, {"identifier": "mergeStemEquivalentBaseClusters", "parameters": "(\n      SequenceBuilder sb, final List<ClusterCandidate> candidates)", "modifiers": "private", "return": "void", "signature": "void mergeStemEquivalentBaseClusters(\n      SequenceBuilder sb, final List<ClusterCandidate> candidates)", "full_signature": "private void mergeStemEquivalentBaseClusters(\n      SequenceBuilder sb, final List<ClusterCandidate> candidates)", "class_method_signature": "STCClusteringAlgorithm.mergeStemEquivalentBaseClusters(\n      SequenceBuilder sb, final List<ClusterCandidate> candidates)", "testcase": false, "constructor": false}, {"identifier": "createMergedClusters", "parameters": "(List<ClusterCandidate> baseClusters)", "modifiers": "private", "return": "ArrayList<ClusterCandidate>", "signature": "ArrayList<ClusterCandidate> createMergedClusters(List<ClusterCandidate> baseClusters)", "full_signature": "private ArrayList<ClusterCandidate> createMergedClusters(List<ClusterCandidate> baseClusters)", "class_method_signature": "STCClusteringAlgorithm.createMergedClusters(List<ClusterCandidate> baseClusters)", "testcase": false, "constructor": false}, {"identifier": "merge", "parameters": "(\n      PreprocessingContext context, IntStack mergeList, List<ClusterCandidate> baseClusters)", "modifiers": "private", "return": "ClusterCandidate", "signature": "ClusterCandidate merge(\n      PreprocessingContext context, IntStack mergeList, List<ClusterCandidate> baseClusters)", "full_signature": "private ClusterCandidate merge(\n      PreprocessingContext context, IntStack mergeList, List<ClusterCandidate> baseClusters)", "class_method_signature": "STCClusteringAlgorithm.merge(\n      PreprocessingContext context, IntStack mergeList, List<ClusterCandidate> baseClusters)", "testcase": false, "constructor": false}, {"identifier": "markSubSuperPhrases", "parameters": "(ArrayList<PhraseCandidate> phrases)", "modifiers": "private", "return": "void", "signature": "void markSubSuperPhrases(ArrayList<PhraseCandidate> phrases)", "full_signature": "private void markSubSuperPhrases(ArrayList<PhraseCandidate> phrases)", "class_method_signature": "STCClusteringAlgorithm.markSubSuperPhrases(ArrayList<PhraseCandidate> phrases)", "testcase": false, "constructor": false}, {"identifier": "markOverlappingPhrases", "parameters": "(\n      PreprocessingContext context, ArrayList<PhraseCandidate> phrases)", "modifiers": "private", "return": "void", "signature": "void markOverlappingPhrases(\n      PreprocessingContext context, ArrayList<PhraseCandidate> phrases)", "full_signature": "private void markOverlappingPhrases(\n      PreprocessingContext context, ArrayList<PhraseCandidate> phrases)", "class_method_signature": "STCClusteringAlgorithm.markOverlappingPhrases(\n      PreprocessingContext context, ArrayList<PhraseCandidate> phrases)", "testcase": false, "constructor": false}, {"identifier": "computeIntersection", "parameters": "(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "modifiers": "static", "return": "int", "signature": "int computeIntersection(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "full_signature": "static int computeIntersection(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "class_method_signature": "STCClusteringAlgorithm.computeIntersection(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "testcase": false, "constructor": false}, {"identifier": "appendUniqueWords", "parameters": "(\n      PreprocessingContext context, IntStack words, IntStack offsets, PhraseCandidate p)", "modifiers": "private", "return": "void", "signature": "void appendUniqueWords(\n      PreprocessingContext context, IntStack words, IntStack offsets, PhraseCandidate p)", "full_signature": "private void appendUniqueWords(\n      PreprocessingContext context, IntStack words, IntStack offsets, PhraseCandidate p)", "class_method_signature": "STCClusteringAlgorithm.appendUniqueWords(\n      PreprocessingContext context, IntStack words, IntStack offsets, PhraseCandidate p)", "testcase": false, "constructor": false}, {"identifier": "appendWords", "parameters": "(IntStack words, IntStack offsets, PhraseCandidate p)", "modifiers": "private", "return": "void", "signature": "void appendWords(IntStack words, IntStack offsets, PhraseCandidate p)", "full_signature": "private void appendWords(IntStack words, IntStack offsets, PhraseCandidate p)", "class_method_signature": "STCClusteringAlgorithm.appendWords(IntStack words, IntStack offsets, PhraseCandidate p)", "testcase": false, "constructor": false}, {"identifier": "postProcessing", "parameters": "(\n      List<T> documents, List<ClusterCandidate> candidates, List<Cluster<T>> clusters)", "modifiers": "private", "return": "void", "signature": "void postProcessing(\n      List<T> documents, List<ClusterCandidate> candidates, List<Cluster<T>> clusters)", "full_signature": "private void postProcessing(\n      List<T> documents, List<ClusterCandidate> candidates, List<Cluster<T>> clusters)", "class_method_signature": "STCClusteringAlgorithm.postProcessing(\n      List<T> documents, List<ClusterCandidate> candidates, List<Cluster<T>> clusters)", "testcase": false, "constructor": false}, {"identifier": "collectPhrases", "parameters": "(ClusterCandidate c, Cluster<?> cluster)", "modifiers": "private", "return": "void", "signature": "void collectPhrases(ClusterCandidate c, Cluster<?> cluster)", "full_signature": "private void collectPhrases(ClusterCandidate c, Cluster<?> cluster)", "class_method_signature": "STCClusteringAlgorithm.collectPhrases(ClusterCandidate c, Cluster<?> cluster)", "testcase": false, "constructor": false}, {"identifier": "collectDocuments", "parameters": "(\n      List<T> documents, List<T> l, BitSet bitset)", "modifiers": "private", "return": "List<T>", "signature": "List<T> collectDocuments(\n      List<T> documents, List<T> l, BitSet bitset)", "full_signature": "private List<T> collectDocuments(\n      List<T> documents, List<T> l, BitSet bitset)", "class_method_signature": "STCClusteringAlgorithm.collectDocuments(\n      List<T> documents, List<T> l, BitSet bitset)", "testcase": false, "constructor": false}, {"identifier": "buildLabel", "parameters": "(int[] phraseIndices)", "modifiers": "private", "return": "String", "signature": "String buildLabel(int[] phraseIndices)", "full_signature": "private String buildLabel(int[] phraseIndices)", "class_method_signature": "STCClusteringAlgorithm.buildLabel(int[] phraseIndices)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "(PhraseCandidate c)", "modifiers": "@SuppressWarnings(\"unused\") private", "return": "String", "signature": "String toString(PhraseCandidate c)", "full_signature": "@SuppressWarnings(\"unused\") private String toString(PhraseCandidate c)", "class_method_signature": "STCClusteringAlgorithm.toString(PhraseCandidate c)", "testcase": false, "constructor": false}, {"identifier": "buildDebugLabel", "parameters": "(int[] phraseIndices)", "modifiers": "@SuppressWarnings(\"unused\") private", "return": "String", "signature": "String buildDebugLabel(int[] phraseIndices)", "full_signature": "@SuppressWarnings(\"unused\") private String buildDebugLabel(int[] phraseIndices)", "class_method_signature": "STCClusteringAlgorithm.buildDebugLabel(int[] phraseIndices)", "testcase": false, "constructor": false}, {"identifier": "checkAcceptablePhrase", "parameters": "(IntStack path)", "modifiers": "final", "return": "boolean", "signature": "boolean checkAcceptablePhrase(IntStack path)", "full_signature": "final boolean checkAcceptablePhrase(IntStack path)", "class_method_signature": "STCClusteringAlgorithm.checkAcceptablePhrase(IntStack path)", "testcase": false, "constructor": false}, {"identifier": "effectivePhraseLength", "parameters": "(IntStack path)", "modifiers": "final", "return": "int", "signature": "int effectivePhraseLength(IntStack path)", "full_signature": "final int effectivePhraseLength(IntStack path)", "class_method_signature": "STCClusteringAlgorithm.effectivePhraseLength(IntStack path)", "testcase": false, "constructor": false}, {"identifier": "baseClusterScore", "parameters": "(final int phraseLength, final int documentCount)", "modifiers": "final", "return": "float", "signature": "float baseClusterScore(final int phraseLength, final int documentCount)", "full_signature": "final float baseClusterScore(final int phraseLength, final int documentCount)", "class_method_signature": "STCClusteringAlgorithm.baseClusterScore(final int phraseLength, final int documentCount)", "testcase": false, "constructor": false}, {"identifier": "indexOf", "parameters": "(\n      int[] source,\n      int sourceOffset,\n      int sourceCount,\n      int[] target,\n      int targetOffset,\n      int targetCount)", "modifiers": "private static", "return": "int", "signature": "int indexOf(\n      int[] source,\n      int sourceOffset,\n      int sourceCount,\n      int[] target,\n      int targetOffset,\n      int targetCount)", "full_signature": "private static int indexOf(\n      int[] source,\n      int sourceOffset,\n      int sourceCount,\n      int[] target,\n      int targetOffset,\n      int targetCount)", "class_method_signature": "STCClusteringAlgorithm.indexOf(\n      int[] source,\n      int sourceOffset,\n      int sourceCount,\n      int[] target,\n      int targetOffset,\n      int targetCount)", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/carrot2/clustering/stc/STCClusteringAlgorithm.java"}, "focal_method": {"identifier": "computeIntersection", "parameters": "(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "modifiers": "static", "return": "int", "body": "static int computeIntersection(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength) {\n    final int maxa = aPos + aLength;\n    final int maxb = bPos + bLength;\n\n    int ea;\n    int eb;\n    int common = 0;\n    while (aPos < maxa && bPos < maxb) {\n      ea = a[aPos];\n      eb = b[bPos];\n      if (ea >= eb) bPos++;\n      if (ea <= eb) aPos++;\n      if (ea == eb) common++;\n    }\n\n    return common;\n  }", "signature": "int computeIntersection(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "full_signature": "static int computeIntersection(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "class_method_signature": "STCClusteringAlgorithm.computeIntersection(int[] a, int aPos, int aLength, int[] b, int bPos, int bLength)", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 2424377, "url": "https://github.com/carrot2/carrot2", "stars": 393, "created": "9/20/2011 6:19:05 PM +00:00", "updates": "2020-01-24T20:43:38+00:00", "fork": "False", "license": "licensed"}}