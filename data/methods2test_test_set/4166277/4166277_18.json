{"test_class": {"identifier": "TimeRangeCheckerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static String DATE_FORMAT = \"yyyy.MM.dd_HH:mm:ss\";", "modifier": "private static", "type": "String", "declarator": "DATE_FORMAT = \"yyyy.MM.dd_HH:mm:ss\"", "var_name": "DATE_FORMAT"}, {"original_string": "private static TimeZone UTC = TimeZone.getTimeZone(\"UTC\");", "modifier": "private static", "type": "TimeZone", "declarator": "UTC = TimeZone.getTimeZone(\"UTC\")", "var_name": "UTC"}], "file": "sjk-stacktrace/src/test/java/org/gridkit/jvmtool/stacktrace/analytics/TimeRangeCheckerTest.java"}, "test_case": {"identifier": "verify_year_wrap_range", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void verify_year_wrap_range() {\n        TimeRangeChecker checker = new TimeRangeChecker(\"02.20_18:10:00\", \"04.10_02:20:00\", UTC);\n\n        assertFalse(checker.evaluate(date(\"2016.02.20_18:09:00\")));\n        assertTrue (checker.evaluate(date(\"2017.02.20_18:10:00\")));\n        assertTrue (checker.evaluate(date(\"2018.02.25_10:11:00\")));\n        assertTrue (checker.evaluate(date(\"2019.03.13_11:18:00\")));\n        assertTrue (checker.evaluate(date(\"2020.03.14_11:40:00\")));\n        assertTrue (checker.evaluate(date(\"2021.04.10_02:19:59\")));\n        assertFalse(checker.evaluate(date(\"2022.04.10_02:20:00\")));\n        assertFalse(checker.evaluate(date(\"2023.09.20_02:21:00\")));\n\n        // Second pass\n        assertFalse(checker.evaluate(date(\"2016.02.20_18:09:00\")));\n        assertTrue (checker.evaluate(date(\"2017.02.20_18:10:00\")));\n        assertTrue (checker.evaluate(date(\"2018.02.25_10:11:00\")));\n        assertTrue (checker.evaluate(date(\"2019.03.13_11:18:00\")));\n        assertTrue (checker.evaluate(date(\"2020.03.14_11:40:00\")));\n        assertTrue (checker.evaluate(date(\"2021.04.10_02:19:59\")));\n        assertFalse(checker.evaluate(date(\"2022.04.10_02:20:00\")));\n        assertFalse(checker.evaluate(date(\"2023.09.20_02:21:00\")));\n    }", "signature": "void verify_year_wrap_range()", "full_signature": "@Test public void verify_year_wrap_range()", "class_method_signature": "TimeRangeCheckerTest.verify_year_wrap_range()", "testcase": true, "constructor": false, "invocations": ["assertFalse", "evaluate", "date", "assertTrue", "evaluate", "date", "assertTrue", "evaluate", "date", "assertTrue", "evaluate", "date", "assertTrue", "evaluate", "date", "assertTrue", "evaluate", "date", "assertFalse", "evaluate", "date", "assertFalse", "evaluate", "date", "assertFalse", "evaluate", "date", "assertTrue", "evaluate", "date", "assertTrue", "evaluate", "date", "assertTrue", "evaluate", "date", "assertTrue", "evaluate", "date", "assertTrue", "evaluate", "date", "assertFalse", "evaluate", "date", "assertFalse", "evaluate", "date"]}, "focal_class": {"identifier": "TimeRangeChecker", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static String DATE_FORMAT = \"yyyy.MM.dd_HH:mm:ss\";", "modifier": "private static", "type": "String", "declarator": "DATE_FORMAT = \"yyyy.MM.dd_HH:mm:ss\"", "var_name": "DATE_FORMAT"}, {"original_string": "private static String DATE_PATTERN = \"(((((((\\\\d\\\\d)?\\\\d\\\\d[.])?\\\\d\\\\d[.])?\\\\d\\\\d[_])?\\\\d\\\\d[:])?\\\\d\\\\d[:])\\\\d\\\\d)\";", "modifier": "private static", "type": "String", "declarator": "DATE_PATTERN = \"(((((((\\\\d\\\\d)?\\\\d\\\\d[.])?\\\\d\\\\d[.])?\\\\d\\\\d[_])?\\\\d\\\\d[:])?\\\\d\\\\d[:])\\\\d\\\\d)\"", "var_name": "DATE_PATTERN"}, {"original_string": "private long[] whiteCache = new long[0];", "modifier": "private", "type": "long[]", "declarator": "whiteCache = new long[0]", "var_name": "whiteCache"}, {"original_string": "private long[] blackCache = new long[0];", "modifier": "private", "type": "long[]", "declarator": "blackCache = new long[0]", "var_name": "blackCache"}, {"original_string": "private int[] lowerBound;", "modifier": "private", "type": "int[]", "declarator": "lowerBound", "var_name": "lowerBound"}, {"original_string": "private int[] upperBound;", "modifier": "private", "type": "int[]", "declarator": "upperBound", "var_name": "upperBound"}, {"original_string": "private TimeZone tz;", "modifier": "private", "type": "TimeZone", "declarator": "tz", "var_name": "tz"}, {"original_string": "private boolean inverted = false;", "modifier": "private", "type": "boolean", "declarator": "inverted = false", "var_name": "inverted"}, {"original_string": "private static int[] FIELDS = {Calendar.YEAR, Calendar.YEAR, Calendar.MONTH, Calendar.DAY_OF_MONTH, Calendar.HOUR_OF_DAY, Calendar.MINUTE, Calendar.SECOND};", "modifier": "private static", "type": "int[]", "declarator": "FIELDS = {Calendar.YEAR, Calendar.YEAR, Calendar.MONTH, Calendar.DAY_OF_MONTH, Calendar.HOUR_OF_DAY, Calendar.MINUTE, Calendar.SECOND}", "var_name": "FIELDS"}], "methods": [{"identifier": "TimeRangeChecker", "parameters": "(String lower, String upper, TimeZone tz)", "modifiers": "public", "return": "", "signature": " TimeRangeChecker(String lower, String upper, TimeZone tz)", "full_signature": "public  TimeRangeChecker(String lower, String upper, TimeZone tz)", "class_method_signature": "TimeRangeChecker.TimeRangeChecker(String lower, String upper, TimeZone tz)", "testcase": false, "constructor": true}, {"identifier": "parse", "parameters": "(String bound)", "modifiers": "private", "return": "int[]", "signature": "int[] parse(String bound)", "full_signature": "private int[] parse(String bound)", "class_method_signature": "TimeRangeChecker.parse(String bound)", "testcase": false, "constructor": false}, {"identifier": "substring", "parameters": "(String txt, int n, int m)", "modifiers": "private", "return": "String", "signature": "String substring(String txt, int n, int m)", "full_signature": "private String substring(String txt, int n, int m)", "class_method_signature": "TimeRangeChecker.substring(String txt, int n, int m)", "testcase": false, "constructor": false}, {"identifier": "isCached", "parameters": "(long timestamp)", "modifiers": "", "return": "boolean", "signature": "boolean isCached(long timestamp)", "full_signature": " boolean isCached(long timestamp)", "class_method_signature": "TimeRangeChecker.isCached(long timestamp)", "testcase": false, "constructor": false}, {"identifier": "evaluate", "parameters": "(long timestamp)", "modifiers": "public", "return": "boolean", "signature": "boolean evaluate(long timestamp)", "full_signature": "public boolean evaluate(long timestamp)", "class_method_signature": "TimeRangeChecker.evaluate(long timestamp)", "testcase": false, "constructor": false}, {"identifier": "match", "parameters": "(int[] p, int[] lower, int[] upper)", "modifiers": "private", "return": "boolean", "signature": "boolean match(int[] p, int[] lower, int[] upper)", "full_signature": "private boolean match(int[] p, int[] lower, int[] upper)", "class_method_signature": "TimeRangeChecker.match(int[] p, int[] lower, int[] upper)", "testcase": false, "constructor": false}, {"identifier": "checkInRange", "parameters": "(int[] p, int i, boolean matchLower, boolean matchUpper)", "modifiers": "private", "return": "boolean", "signature": "boolean checkInRange(int[] p, int i, boolean matchLower, boolean matchUpper)", "full_signature": "private boolean checkInRange(int[] p, int i, boolean matchLower, boolean matchUpper)", "class_method_signature": "TimeRangeChecker.checkInRange(int[] p, int i, boolean matchLower, boolean matchUpper)", "testcase": false, "constructor": false}, {"identifier": "adjust", "parameters": "(long ldate, int step)", "modifiers": "private", "return": "long", "signature": "long adjust(long ldate, int step)", "full_signature": "private long adjust(long ldate, int step)", "class_method_signature": "TimeRangeChecker.adjust(long ldate, int step)", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(long[] cache, long ldate, long udate)", "modifiers": "private", "return": "long[]", "signature": "long[] add(long[] cache, long ldate, long udate)", "full_signature": "private long[] add(long[] cache, long ldate, long udate)", "class_method_signature": "TimeRangeChecker.add(long[] cache, long ldate, long udate)", "testcase": false, "constructor": false}, {"identifier": "toDate", "parameters": "(int[] r)", "modifiers": "private", "return": "long", "signature": "long toDate(int[] r)", "full_signature": "private long toDate(int[] r)", "class_method_signature": "TimeRangeChecker.toDate(int[] r)", "testcase": false, "constructor": false}, {"identifier": "match", "parameters": "(long[] cache, long timestamp)", "modifiers": "private", "return": "boolean", "signature": "boolean match(long[] cache, long timestamp)", "full_signature": "private boolean match(long[] cache, long timestamp)", "class_method_signature": "TimeRangeChecker.match(long[] cache, long timestamp)", "testcase": false, "constructor": false}], "file": "sjk-stacktrace/src/main/java/org/gridkit/jvmtool/stacktrace/analytics/TimeRangeChecker.java"}, "focal_method": {"identifier": "evaluate", "parameters": "(long timestamp)", "modifiers": "public", "return": "boolean", "body": "public boolean evaluate(long timestamp) {\n        if (match(whiteCache, timestamp)) {\n            return true;\n        }\n        if (match(blackCache, timestamp)) {\n            return false;\n        }\n\n        SimpleDateFormat fmt = new SimpleDateFormat(DATE_FORMAT);\n        fmt.setTimeZone(tz);\n        String date = fmt.format(timestamp);\n\n        int[] p = parse(date);\n        int[] rl = Arrays.copyOf(p, p.length);\n        int[] ru = Arrays.copyOf(p, p.length);\n\n        boolean match = match(p, lowerBound, upperBound);\n\n        for(int j = 0; j != rl.length; ++j) {\n            if (lowerBound[j] != -1) {\n                rl[j] = lowerBound[j];\n                ru[j] = upperBound[j];\n            }\n        }\n        if (match) {\n            // match\n            long ldate = toDate(rl);\n            long udate = toDate(ru);\n            if (ldate == -1 || udate == -1) {\n                // do not cache\n                return true;\n            }\n            if (udate > ldate) {\n                whiteCache = add(whiteCache, ldate, udate);\n            }\n            else {\n                if (timestamp >= ldate && timestamp >= udate) {\n                    udate = adjust(udate, 1);\n                    whiteCache = add(whiteCache, ldate, udate);\n                }\n                else {\n                    ldate = adjust(ldate, -1);\n                    whiteCache = add(whiteCache, ldate, udate);\n                }\n            }\n            return true;\n        }\n        else {\n            // do not match\n            long ldate = toDate(rl);\n            long udate = toDate(ru);\n            if (ldate == -1 || udate == -1) {\n                // do not cache\n                return false;\n            }\n            if (timestamp >= ldate && timestamp >= udate) {\n                ldate = adjust(ldate, 1);\n                blackCache = add(blackCache, udate, ldate);\n            }\n            else {\n                udate = adjust(udate, -1);\n                blackCache = add(blackCache, udate, ldate);\n            }\n            return false;\n        }\n    }", "signature": "boolean evaluate(long timestamp)", "full_signature": "public boolean evaluate(long timestamp)", "class_method_signature": "TimeRangeChecker.evaluate(long timestamp)", "testcase": false, "constructor": false, "invocations": ["match", "match", "setTimeZone", "format", "parse", "copyOf", "copyOf", "match", "toDate", "toDate", "add", "adjust", "add", "adjust", "add", "toDate", "toDate", "adjust", "add", "adjust", "add"]}, "repository": {"repo_id": 4166277, "url": "https://github.com/aragozin/jvm-tools", "language": "Java", "is_fork": false, "fork_count": 443, "stargazer_count": 2728, "size": 4961, "license": "licensed"}}