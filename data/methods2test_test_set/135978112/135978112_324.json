{"test_class": {"identifier": "DefaultPartitionGrouperTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private List<PartitionInfo> infos = Arrays.asList(\n            new PartitionInfo(\"topic1\", 0, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic1\", 1, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic1\", 2, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic2\", 0, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic2\", 1, Node.noNode(), new Node[0], new Node[0])\n    );", "modifier": "private", "type": "List<PartitionInfo>", "declarator": "infos = Arrays.asList(\n            new PartitionInfo(\"topic1\", 0, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic1\", 1, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic1\", 2, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic2\", 0, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic2\", 1, Node.noNode(), new Node[0], new Node[0])\n    )", "var_name": "infos"}, {"original_string": "private Cluster metadata = new Cluster(Collections.singletonList(Node.noNode()), infos, Collections.<String>emptySet());", "modifier": "private", "type": "Cluster", "declarator": "metadata = new Cluster(Collections.singletonList(Node.noNode()), infos, Collections.<String>emptySet())", "var_name": "metadata"}], "file": "streams/src/test/java/org/apache/kafka/streams/processor/DefaultPartitionGrouperTest.java"}, "test_case": {"identifier": "testGrouping", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGrouping() {\n        PartitionGrouper grouper = new DefaultPartitionGrouper();\n        int topicGroupId;\n        Map<TaskId, Set<TopicPartition>> expectedPartitionsForTask;\n        Map<Integer, Set<String>> topicGroups;\n\n        topicGroups = new HashMap<>();\n        topicGroups.put(0, mkSet(\"topic1\"));\n        topicGroups.put(1, mkSet(\"topic2\"));\n\n        expectedPartitionsForTask = new HashMap<>();\n        topicGroupId = 0;\n        expectedPartitionsForTask.put(new TaskId(topicGroupId, 0), mkSet(new TopicPartition(\"topic1\", 0)));\n        expectedPartitionsForTask.put(new TaskId(topicGroupId, 1), mkSet(new TopicPartition(\"topic1\", 1)));\n        expectedPartitionsForTask.put(new TaskId(topicGroupId, 2), mkSet(new TopicPartition(\"topic1\", 2)));\n        topicGroupId++;\n        expectedPartitionsForTask.put(new TaskId(topicGroupId, 0), mkSet(new TopicPartition(\"topic2\", 0)));\n        expectedPartitionsForTask.put(new TaskId(topicGroupId, 1), mkSet(new TopicPartition(\"topic2\", 1)));\n\n        assertEquals(expectedPartitionsForTask, grouper.partitionGroups(topicGroups, metadata));\n\n        topicGroups = new HashMap<>();\n        topicGroups.put(0, mkSet(\"topic1\", \"topic2\"));\n\n        expectedPartitionsForTask = new HashMap<>();\n        topicGroupId = 0;\n        expectedPartitionsForTask.put(new TaskId(topicGroupId, 0), mkSet(new TopicPartition(\"topic1\", 0), new TopicPartition(\"topic2\", 0)));\n        expectedPartitionsForTask.put(new TaskId(topicGroupId, 1), mkSet(new TopicPartition(\"topic1\", 1), new TopicPartition(\"topic2\", 1)));\n        expectedPartitionsForTask.put(new TaskId(topicGroupId, 2), mkSet(new TopicPartition(\"topic1\", 2)));\n\n        assertEquals(expectedPartitionsForTask, grouper.partitionGroups(topicGroups, metadata));\n    }", "signature": "void testGrouping()", "full_signature": "@Test public void testGrouping()", "class_method_signature": "DefaultPartitionGrouperTest.testGrouping()", "testcase": true, "constructor": false, "invocations": ["put", "mkSet", "put", "mkSet", "put", "mkSet", "put", "mkSet", "put", "mkSet", "put", "mkSet", "put", "mkSet", "assertEquals", "partitionGroups", "put", "mkSet", "put", "mkSet", "put", "mkSet", "put", "mkSet", "assertEquals", "partitionGroups"]}, "focal_class": {"identifier": "DefaultPartitionGrouper", "superclass": "", "interfaces": "implements PartitionGrouper", "fields": [], "methods": [{"identifier": "partitionGroups", "parameters": "(Map<Integer, Set<String>> topicGroups, Cluster metadata)", "modifiers": "public", "return": "Map<TaskId, Set<TopicPartition>>", "signature": "Map<TaskId, Set<TopicPartition>> partitionGroups(Map<Integer, Set<String>> topicGroups, Cluster metadata)", "full_signature": "public Map<TaskId, Set<TopicPartition>> partitionGroups(Map<Integer, Set<String>> topicGroups, Cluster metadata)", "class_method_signature": "DefaultPartitionGrouper.partitionGroups(Map<Integer, Set<String>> topicGroups, Cluster metadata)", "testcase": false, "constructor": false}, {"identifier": "maxNumPartitions", "parameters": "(Cluster metadata, Set<String> topics)", "modifiers": "protected", "return": "int", "signature": "int maxNumPartitions(Cluster metadata, Set<String> topics)", "full_signature": "protected int maxNumPartitions(Cluster metadata, Set<String> topics)", "class_method_signature": "DefaultPartitionGrouper.maxNumPartitions(Cluster metadata, Set<String> topics)", "testcase": false, "constructor": false}], "file": "streams/src/main/java/org/apache/kafka/streams/processor/DefaultPartitionGrouper.java"}, "focal_method": {"identifier": "partitionGroups", "parameters": "(Map<Integer, Set<String>> topicGroups, Cluster metadata)", "modifiers": "public", "return": "Map<TaskId, Set<TopicPartition>>", "body": "public Map<TaskId, Set<TopicPartition>> partitionGroups(Map<Integer, Set<String>> topicGroups, Cluster metadata) {\n        Map<TaskId, Set<TopicPartition>> groups = new HashMap<>();\n\n        for (Map.Entry<Integer, Set<String>> entry : topicGroups.entrySet()) {\n            Integer topicGroupId = entry.getKey();\n            Set<String> topicGroup = entry.getValue();\n\n            int maxNumPartitions = maxNumPartitions(metadata, topicGroup);\n\n            for (int partitionId = 0; partitionId < maxNumPartitions; partitionId++) {\n                Set<TopicPartition> group = new HashSet<>(topicGroup.size());\n\n                for (String topic : topicGroup) {\n                    if (partitionId < metadata.partitionsForTopic(topic).size()) {\n                        group.add(new TopicPartition(topic, partitionId));\n                    }\n                }\n                groups.put(new TaskId(topicGroupId, partitionId), Collections.unmodifiableSet(group));\n            }\n        }\n\n        return Collections.unmodifiableMap(groups);\n    }", "signature": "Map<TaskId, Set<TopicPartition>> partitionGroups(Map<Integer, Set<String>> topicGroups, Cluster metadata)", "full_signature": "public Map<TaskId, Set<TopicPartition>> partitionGroups(Map<Integer, Set<String>> topicGroups, Cluster metadata)", "class_method_signature": "DefaultPartitionGrouper.partitionGroups(Map<Integer, Set<String>> topicGroups, Cluster metadata)", "testcase": false, "constructor": false, "invocations": ["entrySet", "getKey", "getValue", "maxNumPartitions", "size", "size", "partitionsForTopic", "add", "put", "unmodifiableSet", "unmodifiableMap"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}