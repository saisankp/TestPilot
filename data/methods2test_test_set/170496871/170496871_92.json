{"test_class": {"identifier": "PartitionReconciliationProcessorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String DEFAULT_CACHE = \"default-cache\";", "modifier": "private static final", "type": "String", "declarator": "DEFAULT_CACHE = \"default-cache\"", "var_name": "DEFAULT_CACHE"}, {"original_string": "private static final int PARTITION_ID = 123;", "modifier": "private static final", "type": "int", "declarator": "PARTITION_ID = 123", "var_name": "PARTITION_ID"}, {"original_string": "private static final long SESSION_ID = 123;", "modifier": "private static final", "type": "long", "declarator": "SESSION_ID = 123", "var_name": "SESSION_ID"}, {"original_string": "private static final int MAX_RECHECK_ATTEMPTS = 3;", "modifier": "private static final", "type": "int", "declarator": "MAX_RECHECK_ATTEMPTS = 3", "var_name": "MAX_RECHECK_ATTEMPTS"}], "file": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/checker/processor/PartitionReconciliationProcessorTest.java"}, "test_case": {"identifier": "testRecheckShouldFinishWithoutActionIfConflictWasSolved", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRecheckShouldFinishWithoutActionIfConflictWasSolved() throws IgniteCheckedException {\n        UUID nodeId1 = UUID.randomUUID();\n        UUID nodeId2 = UUID.randomUUID();\n\n        MockedProcessor processor = MockedProcessor.create(false, Arrays.asList(nodeId1, nodeId2));\n\n        KeyCacheObjectImpl key = new KeyCacheObjectImpl(1, null, PARTITION_ID);\n        GridCacheVersion ver = new GridCacheVersion(1, 0, 0, 0);\n\n        Map<KeyCacheObject, Map<UUID, GridCacheVersion>> batchRes = new HashMap<>();\n        Map<UUID, GridCacheVersion> oldKeys = new HashMap<>();\n        oldKeys.put(nodeId1, ver);\n        oldKeys.put(nodeId2, ver);\n        batchRes.put(key, oldKeys);\n\n        Map<KeyCacheObject, Map<UUID, VersionedValue>> sameRes = new HashMap<>();\n        Map<UUID, VersionedValue> actualKey = new HashMap<>();\n        actualKey.put(nodeId1, new VersionedValue(null, ver, 1, 1));\n        actualKey.put(nodeId2, new VersionedValue(null, ver, 1, 1));\n        sameRes.put(key, actualKey);\n\n        processor.addTask(new Recheck(ReconciliationExecutionContext.IGNORE_JOB_PERMITS_SESSION_ID, UUID.randomUUID(),\n            batchRes, DEFAULT_CACHE, PARTITION_ID, 0, 0))\n            .whereResult(CollectPartitionKeysByRecheckRequestTask.class, new ExecutionResult<>(sameRes))\n            .execute();\n\n        processor.verify(never()).schedule(any());\n        processor.verify(never()).schedule(any(), anyInt(), any());\n        processor.verify(never()).scheduleHighPriority(any());\n    }", "signature": "void testRecheckShouldFinishWithoutActionIfConflictWasSolved()", "full_signature": "@Test public void testRecheckShouldFinishWithoutActionIfConflictWasSolved()", "class_method_signature": "PartitionReconciliationProcessorTest.testRecheckShouldFinishWithoutActionIfConflictWasSolved()", "testcase": true, "constructor": false, "invocations": ["randomUUID", "randomUUID", "create", "asList", "put", "put", "put", "put", "put", "put", "execute", "whereResult", "addTask", "randomUUID", "schedule", "verify", "never", "any", "schedule", "verify", "never", "any", "anyInt", "any", "scheduleHighPriority", "verify", "never", "any"]}, "focal_class": {"identifier": "PartitionReconciliationProcessor", "superclass": "extends AbstractPipelineProcessor", "interfaces": "", "fields": [{"original_string": "public static final String SESSION_CHANGE_MSG = \"Reconciliation session has changed.\";", "modifier": "public static final", "type": "String", "declarator": "SESSION_CHANGE_MSG = \"Reconciliation session has changed.\"", "var_name": "SESSION_CHANGE_MSG"}, {"original_string": "public static final String TOPOLOGY_CHANGE_MSG = \"Topology has changed. Partition reconciliation task was stopped.\";", "modifier": "public static final", "type": "String", "declarator": "TOPOLOGY_CHANGE_MSG = \"Topology has changed. Partition reconciliation task was stopped.\"", "var_name": "TOPOLOGY_CHANGE_MSG"}, {"original_string": "public static final String WORK_PROGRESS_MSG = \"Partition reconciliation task [sesId=%s, total=%s, remaining=%s]\";", "modifier": "public static final", "type": "String", "declarator": "WORK_PROGRESS_MSG = \"Partition reconciliation task [sesId=%s, total=%s, remaining=%s]\"", "var_name": "WORK_PROGRESS_MSG"}, {"original_string": "public static final String START_EXECUTION_MSG = \"Partition reconciliation has started [repair=%s, repairAlg=%s, \" +\n        \"fastCheck=%s, batchSize=%s, recheckAttempts=%s, parallelismLevel=%s, caches=%s]\";", "modifier": "public static final", "type": "String", "declarator": "START_EXECUTION_MSG = \"Partition reconciliation has started [repair=%s, repairAlg=%s, \" +\n        \"fastCheck=%s, batchSize=%s, recheckAttempts=%s, parallelismLevel=%s, caches=%s]\"", "var_name": "START_EXECUTION_MSG"}, {"original_string": "public static final String ERROR_REASON = \"Reason [msg=%s, exception=%s]\";", "modifier": "public static final", "type": "String", "declarator": "ERROR_REASON = \"Reason [msg=%s, exception=%s]\"", "var_name": "ERROR_REASON"}, {"original_string": "private final long workProgressPrintInterval = getLong(\"WORK_PROGRESS_PRINT_INTERVAL\", 1000 * 60 * 3);", "modifier": "private final", "type": "long", "declarator": "workProgressPrintInterval = getLong(\"WORK_PROGRESS_PRINT_INTERVAL\", 1000 * 60 * 3)", "var_name": "workProgressPrintInterval"}, {"original_string": "private final int recheckDelay;", "modifier": "private final", "type": "int", "declarator": "recheckDelay", "var_name": "recheckDelay"}, {"original_string": "private final Collection<String> caches;", "modifier": "private final", "type": "Collection<String>", "declarator": "caches", "var_name": "caches"}, {"original_string": "private final boolean repair;", "modifier": "private final", "type": "boolean", "declarator": "repair", "var_name": "repair"}, {"original_string": "private final Map<Integer, Set<Integer>> partsToValidate;", "modifier": "private final", "type": "Map<Integer, Set<Integer>>", "declarator": "partsToValidate", "var_name": "partsToValidate"}, {"original_string": "private final int batchSize;", "modifier": "private final", "type": "int", "declarator": "batchSize", "var_name": "batchSize"}, {"original_string": "private final int recheckAttempts;", "modifier": "private final", "type": "int", "declarator": "recheckAttempts", "var_name": "recheckAttempts"}, {"original_string": "private final RepairAlgorithm repairAlg;", "modifier": "private final", "type": "RepairAlgorithm", "declarator": "repairAlg", "var_name": "repairAlg"}, {"original_string": "private final WorkloadTracker workloadTracker = new WorkloadTracker();", "modifier": "private final", "type": "WorkloadTracker", "declarator": "workloadTracker = new WorkloadTracker()", "var_name": "workloadTracker"}, {"original_string": "final ReconciliationResultCollector collector;", "modifier": "final", "type": "ReconciliationResultCollector", "declarator": "collector", "var_name": "collector"}], "methods": [{"identifier": "PartitionReconciliationProcessor", "parameters": "(\n        long sesId,\n        IgniteEx ignite,\n        Collection<String> caches,\n        Map<Integer, Set<Integer>> partsToValidate,\n        boolean repair,\n        RepairAlgorithm repairAlg,\n        int parallelismLevel,\n        int batchSize,\n        int recheckAttempts,\n        int recheckDelay,\n        boolean compact,\n        boolean includeSensitive\n    )", "modifiers": "@SuppressWarnings(\"AssignmentOrReturnOfFieldWithMutableType\") public", "return": "", "signature": " PartitionReconciliationProcessor(\n        long sesId,\n        IgniteEx ignite,\n        Collection<String> caches,\n        Map<Integer, Set<Integer>> partsToValidate,\n        boolean repair,\n        RepairAlgorithm repairAlg,\n        int parallelismLevel,\n        int batchSize,\n        int recheckAttempts,\n        int recheckDelay,\n        boolean compact,\n        boolean includeSensitive\n    )", "full_signature": "@SuppressWarnings(\"AssignmentOrReturnOfFieldWithMutableType\") public  PartitionReconciliationProcessor(\n        long sesId,\n        IgniteEx ignite,\n        Collection<String> caches,\n        Map<Integer, Set<Integer>> partsToValidate,\n        boolean repair,\n        RepairAlgorithm repairAlg,\n        int parallelismLevel,\n        int batchSize,\n        int recheckAttempts,\n        int recheckDelay,\n        boolean compact,\n        boolean includeSensitive\n    )", "class_method_signature": "PartitionReconciliationProcessor.PartitionReconciliationProcessor(\n        long sesId,\n        IgniteEx ignite,\n        Collection<String> caches,\n        Map<Integer, Set<Integer>> partsToValidate,\n        boolean repair,\n        RepairAlgorithm repairAlg,\n        int parallelismLevel,\n        int batchSize,\n        int recheckAttempts,\n        int recheckDelay,\n        boolean compact,\n        boolean includeSensitive\n    )", "testcase": false, "constructor": true}, {"identifier": "execute", "parameters": "()", "modifiers": "public", "return": "ExecutionResult<ReconciliationAffectedEntries>", "signature": "ExecutionResult<ReconciliationAffectedEntries> execute()", "full_signature": "public ExecutionResult<ReconciliationAffectedEntries> execute()", "class_method_signature": "PartitionReconciliationProcessor.execute()", "testcase": false, "constructor": false}, {"identifier": "collector", "parameters": "()", "modifiers": "public", "return": "ReconciliationResultCollector", "signature": "ReconciliationResultCollector collector()", "full_signature": "public ReconciliationResultCollector collector()", "class_method_signature": "PartitionReconciliationProcessor.collector()", "testcase": false, "constructor": false}, {"identifier": "partitions", "parameters": "(String name)", "modifiers": "private", "return": "int[]", "signature": "int[] partitions(String name)", "full_signature": "private int[] partitions(String name)", "class_method_signature": "PartitionReconciliationProcessor.partitions(String name)", "testcase": false, "constructor": false}, {"identifier": "handle", "parameters": "(Batch workload)", "modifiers": "private", "return": "void", "signature": "void handle(Batch workload)", "full_signature": "private void handle(Batch workload)", "class_method_signature": "PartitionReconciliationProcessor.handle(Batch workload)", "testcase": false, "constructor": false}, {"identifier": "handle", "parameters": "(Recheck workload)", "modifiers": "private", "return": "void", "signature": "void handle(Recheck workload)", "full_signature": "private void handle(Recheck workload)", "class_method_signature": "PartitionReconciliationProcessor.handle(Recheck workload)", "testcase": false, "constructor": false}, {"identifier": "handle", "parameters": "(Repair workload)", "modifiers": "private", "return": "void", "signature": "void handle(Repair workload)", "full_signature": "private void handle(Repair workload)", "class_method_signature": "PartitionReconciliationProcessor.handle(Repair workload)", "testcase": false, "constructor": false}, {"identifier": "repair", "parameters": "(\n        long sesId,\n        UUID workloadChainId,\n        String cacheName,\n        int partId,\n        Map<KeyCacheObject, Map<UUID, GridCacheVersion>> notResolvingConflicts,\n        Map<KeyCacheObject, Map<UUID, VersionedValue>> actualKeys,\n        int repairAttempts\n    )", "modifiers": "private", "return": "Repair", "signature": "Repair repair(\n        long sesId,\n        UUID workloadChainId,\n        String cacheName,\n        int partId,\n        Map<KeyCacheObject, Map<UUID, GridCacheVersion>> notResolvingConflicts,\n        Map<KeyCacheObject, Map<UUID, VersionedValue>> actualKeys,\n        int repairAttempts\n    )", "full_signature": "private Repair repair(\n        long sesId,\n        UUID workloadChainId,\n        String cacheName,\n        int partId,\n        Map<KeyCacheObject, Map<UUID, GridCacheVersion>> notResolvingConflicts,\n        Map<KeyCacheObject, Map<UUID, VersionedValue>> actualKeys,\n        int repairAttempts\n    )", "class_method_signature": "PartitionReconciliationProcessor.repair(\n        long sesId,\n        UUID workloadChainId,\n        String cacheName,\n        int partId,\n        Map<KeyCacheObject, Map<UUID, GridCacheVersion>> notResolvingConflicts,\n        Map<KeyCacheObject, Map<UUID, VersionedValue>> actualKeys,\n        int repairAttempts\n    )", "testcase": false, "constructor": false}], "file": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/checker/processor/PartitionReconciliationProcessor.java"}, "focal_method": {"identifier": "execute", "parameters": "()", "modifiers": "public", "return": "ExecutionResult<ReconciliationAffectedEntries>", "body": "public ExecutionResult<ReconciliationAffectedEntries> execute() {\n        if (log.isInfoEnabled()) {\n            log.info(String.format(\n                START_EXECUTION_MSG,\n                repair,\n                repairAlg,\n                partsToValidate != null,\n                batchSize,\n                recheckAttempts,\n                parallelismLevel,\n                caches));\n        }\n\n        try {\n            for (String cache : caches) {\n                IgniteInternalCache<Object, Object> cachex = ignite.cachex(cache);\n\n                ExpiryPolicy expPlc = cachex.context().expiry();\n                if (expPlc != null && !(expPlc instanceof EternalExpiryPolicy)) {\n                    log.warning(\"The cache '\" + cache + \"' was skipped because CacheConfiguration#setExpiryPolicyFactory is set.\");\n\n                    continue;\n                }\n\n                int[] partitions = partitions(cache);\n\n                for (int partId : partitions) {\n                    Batch workload = new Batch(sesId, UUID.randomUUID(), cache, partId, null);\n\n                    workloadTracker.addTrackingChain(workload);\n\n                    schedule(workload);\n                }\n            }\n\n            boolean live = false;\n            long lastUpdateTime = 0;\n\n            while (!isEmpty() || (live = hasLiveHandlers())) {\n                if (topologyChanged())\n                    throw new IgniteException(TOPOLOGY_CHANGE_MSG);\n\n                if (isSessionExpired())\n                    throw new IgniteException(SESSION_CHANGE_MSG);\n\n                if (isInterrupted())\n                    throw new IgniteException(error.get());\n\n                if (isEmpty() && live) {\n                    U.sleep(100);\n\n                    continue;\n                }\n\n                long currTimeMillis = System.currentTimeMillis();\n\n                if (currTimeMillis >= lastUpdateTime + workProgressPrintInterval) {\n                    if (log.isInfoEnabled()) {\n                        log.info(String.format(\n                            WORK_PROGRESS_MSG,\n                            sesId,\n                            workloadTracker.totalChains(),\n                            workloadTracker.remaningChains()));\n                    }\n\n                    lastUpdateTime = currTimeMillis;\n                }\n\n                PipelineWorkload workload = takeTask();\n\n                if (workload instanceof Batch)\n                    handle((Batch)workload);\n                else if (workload instanceof Recheck)\n                    handle((Recheck)workload);\n                else if (workload instanceof Repair)\n                    handle((Repair)workload);\n                else {\n                    String err = \"Unsupported workload type: \" + workload;\n\n                    log.error(err);\n\n                    throw new IgniteException(err);\n                }\n            }\n\n            return new ExecutionResult<>(collector.result());\n        }\n        catch (InterruptedException | IgniteException e) {\n            String errMsg = \"Partition reconciliation was interrupted.\";\n\n            waitWorkFinish();\n\n            log.warning(errMsg, e);\n\n            return new ExecutionResult<>(collector.result(), errMsg + ' ' + String.format(ERROR_REASON, e.getMessage(), e.getClass()));\n        }\n        catch (Exception e) {\n            String errMsg = \"Unexpected error.\";\n\n            log.error(errMsg, e);\n\n            return new ExecutionResult<>(collector.result(), errMsg + ' ' + String.format(ERROR_REASON, e.getMessage(), e.getClass()));\n        }\n    }", "signature": "ExecutionResult<ReconciliationAffectedEntries> execute()", "full_signature": "public ExecutionResult<ReconciliationAffectedEntries> execute()", "class_method_signature": "PartitionReconciliationProcessor.execute()", "testcase": false, "constructor": false, "invocations": ["isInfoEnabled", "info", "format", "cachex", "expiry", "context", "warning", "partitions", "randomUUID", "addTrackingChain", "schedule", "isEmpty", "hasLiveHandlers", "topologyChanged", "isSessionExpired", "isInterrupted", "get", "isEmpty", "sleep", "currentTimeMillis", "isInfoEnabled", "info", "format", "totalChains", "remaningChains", "takeTask", "handle", "handle", "handle", "error", "result", "waitWorkFinish", "warning", "result", "format", "getMessage", "getClass", "error", "result", "format", "getMessage", "getClass"]}, "repository": {"repo_id": 170496871, "url": "https://github.com/gridgain/gridgain", "stars": 46, "created": "2/13/2019 11:31:35 AM +00:00", "updates": "2020-01-27T16:02:24+00:00", "fork": "False", "license": "licensed"}}