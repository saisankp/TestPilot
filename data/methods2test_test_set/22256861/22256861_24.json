{"test_class": {"identifier": "RayleighCorrAlgorithmTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private RayleighCorrAlgorithm algo;", "modifier": "private", "type": "RayleighCorrAlgorithm", "declarator": "algo", "var_name": "algo"}], "file": "s3tbx-olci-radiometry/src/test/java/org/esa/s3tbx/olci/radiometry/rayleigh/RayleighCorrAlgorithmTest.java"}, "test_case": {"identifier": "testGetRhoWithRayleighAux", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGetRhoWithRayleighAux() {\n        RayleighAux rayleighAux = getRayleighAux();\n        double[] corrOzoneRefl = {1.0, 2.2, 2.3, 1.7};\n        double[] rayleighOpticalThickness = {1.0, 2, 0.7, 1.3};\n\n        double[] expectedRhoBrr = algo.getRhoBrr(rayleighAux, rayleighOpticalThickness, corrOzoneRefl);\n        assertEquals(4, expectedRhoBrr.length);\n\n    }", "signature": "void testGetRhoWithRayleighAux()", "full_signature": "@Test public void testGetRhoWithRayleighAux()", "class_method_signature": "RayleighCorrAlgorithmTest.testGetRhoWithRayleighAux()", "testcase": true, "constructor": false, "invocations": ["getRayleighAux", "getRhoBrr", "assertEquals"]}, "focal_class": {"identifier": "RayleighCorrAlgorithm", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Sensor sensor;", "modifier": "private", "type": "Sensor", "declarator": "sensor", "var_name": "sensor"}, {"original_string": "private int numBands;", "modifier": "private", "type": "int", "declarator": "numBands", "var_name": "numBands"}, {"original_string": "private String bandNamePattern;", "modifier": "private", "type": "String", "declarator": "bandNamePattern", "var_name": "bandNamePattern"}], "methods": [{"identifier": "RayleighCorrAlgorithm", "parameters": "(String bandPattern, int numBands)", "modifiers": "public", "return": "", "signature": " RayleighCorrAlgorithm(String bandPattern, int numBands)", "full_signature": "public  RayleighCorrAlgorithm(String bandPattern, int numBands)", "class_method_signature": "RayleighCorrAlgorithm.RayleighCorrAlgorithm(String bandPattern, int numBands)", "testcase": false, "constructor": true}, {"identifier": "RayleighCorrAlgorithm", "parameters": "(Sensor sensor)", "modifiers": "public", "return": "", "signature": " RayleighCorrAlgorithm(Sensor sensor)", "full_signature": "public  RayleighCorrAlgorithm(Sensor sensor)", "class_method_signature": "RayleighCorrAlgorithm.RayleighCorrAlgorithm(Sensor sensor)", "testcase": false, "constructor": true}, {"identifier": "waterVaporCorrection709", "parameters": "(double[] reflectances, double[] bWVRefTile, double[] bWVTile)", "modifiers": "", "return": "double[]", "signature": "double[] waterVaporCorrection709(double[] reflectances, double[] bWVRefTile, double[] bWVTile)", "full_signature": " double[] waterVaporCorrection709(double[] reflectances, double[] bWVRefTile, double[] bWVTile)", "class_method_signature": "RayleighCorrAlgorithm.waterVaporCorrection709(double[] reflectances, double[] bWVRefTile, double[] bWVTile)", "testcase": false, "constructor": false}, {"identifier": "getCrossSectionSigma", "parameters": "(Product sourceProduct, int numBands, String getBandNamePattern)", "modifiers": "", "return": "double[]", "signature": "double[] getCrossSectionSigma(Product sourceProduct, int numBands, String getBandNamePattern)", "full_signature": " double[] getCrossSectionSigma(Product sourceProduct, int numBands, String getBandNamePattern)", "class_method_signature": "RayleighCorrAlgorithm.getCrossSectionSigma(Product sourceProduct, int numBands, String getBandNamePattern)", "testcase": false, "constructor": false}, {"identifier": "isSentinelB", "parameters": "(Product sourceProduct)", "modifiers": "private", "return": "boolean", "signature": "boolean isSentinelB(Product sourceProduct)", "full_signature": "private boolean isSentinelB(Product sourceProduct)", "class_method_signature": "RayleighCorrAlgorithm.isSentinelB(Product sourceProduct)", "testcase": false, "constructor": false}, {"identifier": "getCrossSection", "parameters": "(double[] lambdas)", "modifiers": "", "return": "double[]", "signature": "double[] getCrossSection(double[] lambdas)", "full_signature": " double[] getCrossSection(double[] lambdas)", "class_method_signature": "RayleighCorrAlgorithm.getCrossSection(double[] lambdas)", "testcase": false, "constructor": false}, {"identifier": "getCorrOzone", "parameters": "(double[] rho_ng_ref, double absorpO, double[] ozones, double[] cosOZARads,\n                          double[] cosSZARads)", "modifiers": "", "return": "double[]", "signature": "double[] getCorrOzone(double[] rho_ng_ref, double absorpO, double[] ozones, double[] cosOZARads,\n                          double[] cosSZARads)", "full_signature": " double[] getCorrOzone(double[] rho_ng_ref, double absorpO, double[] ozones, double[] cosOZARads,\n                          double[] cosSZARads)", "class_method_signature": "RayleighCorrAlgorithm.getCorrOzone(double[] rho_ng_ref, double absorpO, double[] ozones, double[] cosOZARads,\n                          double[] cosSZARads)", "testcase": false, "constructor": false}, {"identifier": "getCorrOzone", "parameters": "(double rho_ng, double absorpO, double ozone, double cts, double ctv)", "modifiers": "", "return": "double", "signature": "double getCorrOzone(double rho_ng, double absorpO, double ozone, double cts, double ctv)", "full_signature": " double getCorrOzone(double rho_ng, double absorpO, double ozone, double cts, double ctv)", "class_method_signature": "RayleighCorrAlgorithm.getCorrOzone(double rho_ng, double absorpO, double ozone, double cts, double ctv)", "testcase": false, "constructor": false}, {"identifier": "getRhoBrr", "parameters": "(RayleighAux rayleighAux, double[] rayleighOpticalThickness, double[] corrOzoneRefl)", "modifiers": "", "return": "double[]", "signature": "double[] getRhoBrr(RayleighAux rayleighAux, double[] rayleighOpticalThickness, double[] corrOzoneRefl)", "full_signature": " double[] getRhoBrr(RayleighAux rayleighAux, double[] rayleighOpticalThickness, double[] corrOzoneRefl)", "class_method_signature": "RayleighCorrAlgorithm.getRhoBrr(RayleighAux rayleighAux, double[] rayleighOpticalThickness, double[] corrOzoneRefl)", "testcase": false, "constructor": false}, {"identifier": "getRhoRayleigh", "parameters": "(RayleighAux rayleighAux, double[] rayleighOpticalThickness,\n                            double[] corrOzoneRefl)", "modifiers": "", "return": "double[]", "signature": "double[] getRhoRayleigh(RayleighAux rayleighAux, double[] rayleighOpticalThickness,\n                            double[] corrOzoneRefl)", "full_signature": " double[] getRhoRayleigh(RayleighAux rayleighAux, double[] rayleighOpticalThickness,\n                            double[] corrOzoneRefl)", "class_method_signature": "RayleighCorrAlgorithm.getRhoRayleigh(RayleighAux rayleighAux, double[] rayleighOpticalThickness,\n                            double[] corrOzoneRefl)", "testcase": false, "constructor": false}, {"identifier": "getFourierSeries", "parameters": "(double rayleighOpticalThickness, double massAir, double cosOZARad,\n                              double cosSZARad, List<double[]> interpolateValues, double[] fourierSeriesCof)", "modifiers": "", "return": "double[]", "signature": "double[] getFourierSeries(double rayleighOpticalThickness, double massAir, double cosOZARad,\n                              double cosSZARad, List<double[]> interpolateValues, double[] fourierSeriesCof)", "full_signature": " double[] getFourierSeries(double rayleighOpticalThickness, double massAir, double cosOZARad,\n                              double cosSZARad, List<double[]> interpolateValues, double[] fourierSeriesCof)", "class_method_signature": "RayleighCorrAlgorithm.getFourierSeries(double rayleighOpticalThickness, double massAir, double cosOZARad,\n                              double cosSZARad, List<double[]> interpolateValues, double[] fourierSeriesCof)", "testcase": false, "constructor": false}, {"identifier": "getRayleighReflectance", "parameters": "(RayleighInput rayleighInput, RayleighAux rayleighAux,\n                                                 double[] absorptionOfBand, Product product)", "modifiers": "public", "return": "RayleighOutput", "signature": "RayleighOutput getRayleighReflectance(RayleighInput rayleighInput, RayleighAux rayleighAux,\n                                                 double[] absorptionOfBand, Product product)", "full_signature": "public RayleighOutput getRayleighReflectance(RayleighInput rayleighInput, RayleighAux rayleighAux,\n                                                 double[] absorptionOfBand, Product product)", "class_method_signature": "RayleighCorrAlgorithm.getRayleighReflectance(RayleighInput rayleighInput, RayleighAux rayleighAux,\n                                                 double[] absorptionOfBand, Product product)", "testcase": false, "constructor": false}, {"identifier": "getRayleigh", "parameters": "(RayleighAux rayleighAux, double absorptionOfBand, double[] thicknessAllBand,\n                                float[] ref)", "modifiers": "private", "return": "float[]", "signature": "float[] getRayleigh(RayleighAux rayleighAux, double absorptionOfBand, double[] thicknessAllBand,\n                                float[] ref)", "full_signature": "private float[] getRayleigh(RayleighAux rayleighAux, double absorptionOfBand, double[] thicknessAllBand,\n                                float[] ref)", "class_method_signature": "RayleighCorrAlgorithm.getRayleigh(RayleighAux rayleighAux, double absorptionOfBand, double[] thicknessAllBand,\n                                float[] ref)", "testcase": false, "constructor": false}, {"identifier": "convertFloatToDouble", "parameters": "(float[] ref)", "modifiers": "private", "return": "double[]", "signature": "double[] convertFloatToDouble(float[] ref)", "full_signature": "private double[] convertFloatToDouble(float[] ref)", "class_method_signature": "RayleighCorrAlgorithm.convertFloatToDouble(float[] ref)", "testcase": false, "constructor": false}, {"identifier": "convertDoubleToFloat", "parameters": "(double[] ref)", "modifiers": "private", "return": "float[]", "signature": "float[] convertDoubleToFloat(double[] ref)", "full_signature": "private float[] convertDoubleToFloat(double[] ref)", "class_method_signature": "RayleighCorrAlgorithm.convertDoubleToFloat(double[] ref)", "testcase": false, "constructor": false}, {"identifier": "getRayleighThickness", "parameters": "(RayleighAux rayleighAux,\n                                  double[] crossSectionSigma,\n                                  int sourceBandIndex,\n                                  String targetBandName)", "modifiers": "", "return": "double[]", "signature": "double[] getRayleighThickness(RayleighAux rayleighAux,\n                                  double[] crossSectionSigma,\n                                  int sourceBandIndex,\n                                  String targetBandName)", "full_signature": " double[] getRayleighThickness(RayleighAux rayleighAux,\n                                  double[] crossSectionSigma,\n                                  int sourceBandIndex,\n                                  String targetBandName)", "class_method_signature": "RayleighCorrAlgorithm.getRayleighThickness(RayleighAux rayleighAux,\n                                  double[] crossSectionSigma,\n                                  int sourceBandIndex,\n                                  String targetBandName)", "testcase": false, "constructor": false}, {"identifier": "getRayleighThicknessBodhaineTest", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void getRayleighThicknessBodhaineTest()", "full_signature": "public void getRayleighThicknessBodhaineTest()", "class_method_signature": "RayleighCorrAlgorithm.getRayleighThicknessBodhaineTest()", "testcase": false, "constructor": false}, {"identifier": "getRayleighOpticalThickness", "parameters": "(double sigma, double seaLevelPressure, double altitude,\n                                       double latitude)", "modifiers": "", "return": "double", "signature": "double getRayleighOpticalThickness(double sigma, double seaLevelPressure, double altitude,\n                                       double latitude)", "full_signature": " double getRayleighOpticalThickness(double sigma, double seaLevelPressure, double altitude,\n                                       double latitude)", "class_method_signature": "RayleighCorrAlgorithm.getRayleighOpticalThickness(double sigma, double seaLevelPressure, double altitude,\n                                       double latitude)", "testcase": false, "constructor": false}, {"identifier": "getRayleightOptThickness", "parameters": "(double sigma, double altitude, double latitude, double pressure)", "modifiers": "private", "return": "double", "signature": "double getRayleightOptThickness(double sigma, double altitude, double latitude, double pressure)", "full_signature": "private double getRayleightOptThickness(double sigma, double altitude, double latitude, double pressure)", "class_method_signature": "RayleighCorrAlgorithm.getRayleightOptThickness(double sigma, double altitude, double latitude, double pressure)", "testcase": false, "constructor": false}, {"identifier": "convertRadsToRefls", "parameters": "(double[] radiance, double[] solarIrradiance, double[] sza)", "modifiers": "", "return": "double[]", "signature": "double[] convertRadsToRefls(double[] radiance, double[] solarIrradiance, double[] sza)", "full_signature": " double[] convertRadsToRefls(double[] radiance, double[] solarIrradiance, double[] sza)", "class_method_signature": "RayleighCorrAlgorithm.convertRadsToRefls(double[] radiance, double[] solarIrradiance, double[] sza)", "testcase": false, "constructor": false}, {"identifier": "getCrossSectionSigmaIndex", "parameters": "(int sourceBandIndex, String targetBandName)", "modifiers": "private", "return": "int", "signature": "int getCrossSectionSigmaIndex(int sourceBandIndex, String targetBandName)", "full_signature": "private int getCrossSectionSigmaIndex(int sourceBandIndex, String targetBandName)", "class_method_signature": "RayleighCorrAlgorithm.getCrossSectionSigmaIndex(int sourceBandIndex, String targetBandName)", "testcase": false, "constructor": false}], "file": "s3tbx-olci-radiometry/src/main/java/org/esa/s3tbx/olci/radiometry/rayleigh/RayleighCorrAlgorithm.java"}, "focal_method": {"identifier": "getRhoBrr", "parameters": "(RayleighAux rayleighAux, double[] rayleighOpticalThickness, double[] corrOzoneRefl)", "modifiers": "", "return": "double[]", "body": "double[] getRhoBrr(RayleighAux rayleighAux, double[] rayleighOpticalThickness, double[] corrOzoneRefl) {\n        final double[] airMasses = rayleighAux.getAirMass();\n        final double[] aziDiffs = rayleighAux.getAziDifferent();\n        final double[] cosSZARads = rayleighAux.getCosSZARads();\n        final double[] cosOZARads = rayleighAux.getCosOZARads();\n        final double[] sARay = rayleighAux.getInterpolateRayleighThickness(rayleighOpticalThickness);\n        final double[] tau_ray = rayleighAux.getTaur();\n\n        final Map<Integer, double[]> fourier = rayleighAux.getFourier();\n        final Map<Integer, List<double[]>> interpolation = rayleighAux.getInterpolation();\n        final int length = cosOZARads.length;\n\n        final double[] rho_BRR = new double[length];\n\n        for (int index = 0; index < length; index++) {\n\n            double corrOzone = corrOzoneRefl[index];\n            if (Double.isNaN(corrOzone)) {\n                rho_BRR[index] = RayleighConstants.INVALID_VALUE;\n                continue;\n            }\n            if (corrOzone <= 0) {\n                rho_BRR[index] = 0.0;\n                continue;\n            }\n            double taurVal = rayleighOpticalThickness[index];\n            if (Double.isNaN(taurVal)) {\n                rho_BRR[index] = taurVal;\n                continue;\n            }\n            double aziDiff = aziDiffs[index];\n            double massAir = airMasses[index];\n\n            double cosOZARad = cosOZARads[index];\n            double cosSZARad = cosSZARads[index];\n\n            List<double[]> interpolateValues = interpolation.get(index);\n            if (interpolateValues == null || interpolateValues.size() == 0) {\n                // this might happen if we are out of range of RayleighAux data (e.g. SZA > 80deg)\n                // --> set to NaN (CB, 20171026)\n                rho_BRR[index] = RayleighConstants.INVALID_VALUE;\n                continue;\n            }\n            double[] fourierSeries = fourier.get(index);\n\n            double[] rho_Rm = getFourierSeries(taurVal, massAir, cosOZARad, cosSZARad, interpolateValues, fourierSeries);\n\n            double rho_R = rho_Rm[0] + 2.0 * rho_Rm[1] * Math.cos(aziDiff) + 2.0 * rho_Rm[2] * Math.cos(2.0 * aziDiff);\n\n            // polynomial coefficients tpoly0, tpoly1 and tpoly2 from MERIS LUT\n\n            double tRs = ((2.0 / 3.0 + cosSZARad) + (2.0 / 3.0 - cosSZARad) * Math.exp(-taurVal / cosSZARad)) / (4.0 / 3.0 + taurVal);\n\n            double tR_thetaS = tau_ray[0] + tau_ray[1] * tRs + tau_ray[2] * Math.pow(tRs, 2);\n            //#Rayleigh Transmittance sun - surface\n            double tRv = ((2.0 / 3.0 + cosOZARad) + (2.0 / 3.0 - cosOZARad) * Math.exp(-taurVal / cosOZARad)) / (4.0 / 3.0 + taurVal);\n            //#Rayleigh Transmittance surface - sensor\n            double tR_thetaV = tau_ray[0] + tau_ray[1] * tRv + tau_ray[2] * Math.pow(tRv, 2);\n\n            double saRay = sARay[index];\n\n\n            double rho_toaR = (corrOzone - rho_R) / (tR_thetaS * tR_thetaV); //toa corrOzoneRefl corrected for Rayleigh scattering\n            double sphericalFactor = 1.0 / (1.0 + saRay * rho_toaR); //#factor used in the next equation to account for the spherical albedo\n            //#top of aerosol reflectance, which is equal to bottom of Rayleigh reflectance\n            rho_BRR[index] = (rho_toaR * sphericalFactor);\n        }\n        return rho_BRR;\n    }", "signature": "double[] getRhoBrr(RayleighAux rayleighAux, double[] rayleighOpticalThickness, double[] corrOzoneRefl)", "full_signature": " double[] getRhoBrr(RayleighAux rayleighAux, double[] rayleighOpticalThickness, double[] corrOzoneRefl)", "class_method_signature": "RayleighCorrAlgorithm.getRhoBrr(RayleighAux rayleighAux, double[] rayleighOpticalThickness, double[] corrOzoneRefl)", "testcase": false, "constructor": false, "invocations": ["getAirMass", "getAziDifferent", "getCosSZARads", "getCosOZARads", "getInterpolateRayleighThickness", "getTaur", "getFourier", "getInterpolation", "isNaN", "isNaN", "get", "size", "get", "getFourierSeries", "cos", "cos", "exp", "pow", "exp", "pow"]}, "repository": {"repo_id": 22256861, "url": "https://github.com/senbox-org/s3tbx", "stars": 22, "created": "7/25/2014 12:57:22 PM +00:00", "updates": "2020-01-27T10:23:46+00:00", "fork": "False", "license": "licensed"}}