{"test_class": {"identifier": "TestDexcomAdapterService", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String SERIAL_NUMBER = \"serial\";", "modifier": "private static final", "type": "String", "declarator": "SERIAL_NUMBER = \"serial\"", "var_name": "SERIAL_NUMBER"}, {"original_string": "private static final String HARDWARE_REVISION = \"revision1\";", "modifier": "private static final", "type": "String", "declarator": "HARDWARE_REVISION = \"revision1\"", "var_name": "HARDWARE_REVISION"}, {"original_string": "private static final String HARDWARE_ID = \"hardwareId\";", "modifier": "private static final", "type": "String", "declarator": "HARDWARE_ID = \"hardwareId\"", "var_name": "HARDWARE_ID"}, {"original_string": "private static final Integer NORMAL_READ_TEST_VALUE = 83;", "modifier": "private static final", "type": "Integer", "declarator": "NORMAL_READ_TEST_VALUE = 83", "var_name": "NORMAL_READ_TEST_VALUE"}, {"original_string": "private static final List<GlucoseRead> EMPTY_GLUCOSE_READS = Collections.emptyList();", "modifier": "private static final", "type": "List<GlucoseRead>", "declarator": "EMPTY_GLUCOSE_READS = Collections.emptyList()", "var_name": "EMPTY_GLUCOSE_READS"}, {"original_string": "private static final List<GlucoseReadRecord> EMPTY_GLUCOSE_READ_RECORDS = Collections.emptyList();", "modifier": "private static final", "type": "List<GlucoseReadRecord>", "declarator": "EMPTY_GLUCOSE_READ_RECORDS = Collections.emptyList()", "var_name": "EMPTY_GLUCOSE_READ_RECORDS"}, {"original_string": "private static final List<InsulinInjection> EMPTY_INSULIN_INJECTIONS = Collections.emptyList();", "modifier": "private static final", "type": "List<InsulinInjection>", "declarator": "EMPTY_INSULIN_INJECTIONS = Collections.emptyList()", "var_name": "EMPTY_INSULIN_INJECTIONS"}, {"original_string": "private static final List<UserEventRecord> EMPTY_USER_EVENT_RECORDS = Collections.emptyList();", "modifier": "private static final", "type": "List<UserEventRecord>", "declarator": "EMPTY_USER_EVENT_RECORDS = Collections.emptyList()", "var_name": "EMPTY_USER_EVENT_RECORDS"}, {"original_string": "private static final List<FoodEvent> EMPTY_FOOD_EVENTS = Collections.emptyList();", "modifier": "private static final", "type": "List<FoodEvent>", "declarator": "EMPTY_FOOD_EVENTS = Collections.emptyList()", "var_name": "EMPTY_FOOD_EVENTS"}, {"original_string": "private static final List<ExerciseSession> EMPTY_EXERCISE_SESSIONS = Collections.emptyList();", "modifier": "private static final", "type": "List<ExerciseSession>", "declarator": "EMPTY_EXERCISE_SESSIONS = Collections.emptyList()", "var_name": "EMPTY_EXERCISE_SESSIONS"}, {"original_string": "private static final Instant TEST_TIME = Instant.ofEpochMilli(100L);", "modifier": "private static final", "type": "Instant", "declarator": "TEST_TIME = Instant.ofEpochMilli(100L)", "var_name": "TEST_TIME"}], "file": "dexcom-receiver/src/test/java/org/glukit/dexcom/sync/TestDexcomAdapterService.java"}, "test_case": {"identifier": "noReadsShouldConvertSuccessfully", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void noReadsShouldConvertSuccessfully() throws Exception {\n    DexcomAdapterService dexcomAdapterService = new DexcomAdapterService();\n\n    SyncData syncData = dexcomAdapterService.convertData(\n        new DexcomSyncData(EMPTY_GLUCOSE_READ_RECORDS,\n            EMPTY_USER_EVENT_RECORDS,\n            new ManufacturingParameters(SERIAL_NUMBER, \"partNumber\", HARDWARE_REVISION, \"2013-10-18 10:10\", HARDWARE_ID),\n                TEST_TIME));\n\n    SyncData expectedSyncData = new SyncData(EMPTY_GLUCOSE_READS, EMPTY_INSULIN_INJECTIONS, EMPTY_FOOD_EVENTS,\n        EMPTY_EXERCISE_SESSIONS, new DeviceInfo(SERIAL_NUMBER, HARDWARE_ID, HARDWARE_REVISION), TEST_TIME);\n\n    assertThat(syncData, is(equalTo(expectedSyncData)));\n  }", "signature": "void noReadsShouldConvertSuccessfully()", "full_signature": "@Test public void noReadsShouldConvertSuccessfully()", "class_method_signature": "TestDexcomAdapterService.noReadsShouldConvertSuccessfully()", "testcase": true, "constructor": false, "invocations": ["convertData", "assertThat", "is", "equalTo"]}, "focal_class": {"identifier": "DexcomAdapterService", "superclass": "", "interfaces": "implements AdapterService<DexcomSyncData>", "fields": [{"original_string": "private static final int GLUCOSE_DISPLAY_ONLY_MASK = 0x8000;", "modifier": "private static final", "type": "int", "declarator": "GLUCOSE_DISPLAY_ONLY_MASK = 0x8000", "var_name": "GLUCOSE_DISPLAY_ONLY_MASK"}, {"original_string": "private static final int GLUCOSE_READ_VALUE_MASK = 0x3ff;", "modifier": "private static final", "type": "int", "declarator": "GLUCOSE_READ_VALUE_MASK = 0x3ff", "var_name": "GLUCOSE_READ_VALUE_MASK"}, {"original_string": "private static final float INVALID_GLUCOSE_RECORD_VALUE = -1.0f;", "modifier": "private static final", "type": "float", "declarator": "INVALID_GLUCOSE_RECORD_VALUE = -1.0f", "var_name": "INVALID_GLUCOSE_RECORD_VALUE"}, {"original_string": "public static final Predicate<GlucoseRead> VALID_READS_FILTER = new Predicate<GlucoseRead>() {\n    @Override\n    public boolean apply(@Nullable GlucoseRead input) {\n      return input.getValue() != INVALID_GLUCOSE_RECORD_VALUE;\n    }\n  };", "modifier": "public static final", "type": "Predicate<GlucoseRead>", "declarator": "VALID_READS_FILTER = new Predicate<GlucoseRead>() {\n    @Override\n    public boolean apply(@Nullable GlucoseRead input) {\n      return input.getValue() != INVALID_GLUCOSE_RECORD_VALUE;\n    }\n  }", "var_name": "VALID_READS_FILTER"}, {"original_string": "static final List<Integer> SPECIAL_GLUCOSE_VALUES = Arrays.asList(0, 1, 2, 3, 5, 6, 9, 10, 12);", "modifier": "static final", "type": "List<Integer>", "declarator": "SPECIAL_GLUCOSE_VALUES = Arrays.asList(0, 1, 2, 3, 5, 6, 9, 10, 12)", "var_name": "SPECIAL_GLUCOSE_VALUES"}, {"original_string": "private static final Predicate<UserEventRecord> INSULIN_EVENT_FILTER = new Predicate<UserEventRecord>() {\n    @Override\n    public boolean apply(@Nullable UserEventRecord input) {\n      return input.getEventType() == INSULIN;\n    }\n  };", "modifier": "private static final", "type": "Predicate<UserEventRecord>", "declarator": "INSULIN_EVENT_FILTER = new Predicate<UserEventRecord>() {\n    @Override\n    public boolean apply(@Nullable UserEventRecord input) {\n      return input.getEventType() == INSULIN;\n    }\n  }", "var_name": "INSULIN_EVENT_FILTER"}, {"original_string": "private static final Predicate<UserEventRecord> EXERCISE_EVENT_FILTER = new Predicate<UserEventRecord>() {\n    @Override\n    public boolean apply(@Nullable UserEventRecord input) {\n      return input.getEventType() == EXERCISE;\n    }\n  };", "modifier": "private static final", "type": "Predicate<UserEventRecord>", "declarator": "EXERCISE_EVENT_FILTER = new Predicate<UserEventRecord>() {\n    @Override\n    public boolean apply(@Nullable UserEventRecord input) {\n      return input.getEventType() == EXERCISE;\n    }\n  }", "var_name": "EXERCISE_EVENT_FILTER"}, {"original_string": "private static final Predicate<UserEventRecord> CARB_EVENT_FILTER = new Predicate<UserEventRecord>() {\n    @Override\n    public boolean apply(@Nullable UserEventRecord input) {\n      return input.getEventType() == CARBS;\n    }\n  };", "modifier": "private static final", "type": "Predicate<UserEventRecord>", "declarator": "CARB_EVENT_FILTER = new Predicate<UserEventRecord>() {\n    @Override\n    public boolean apply(@Nullable UserEventRecord input) {\n      return input.getEventType() == CARBS;\n    }\n  }", "var_name": "CARB_EVENT_FILTER"}, {"original_string": "private Function<Long, Instant> DEXCOM_SYSTEM_TIME_TO_INSTANT = new Function<Long, Instant>() {\n    @Nullable\n    @Override\n    public Instant apply(@Nullable Long secondsSinceDexcomEpoch) {\n      checkNotNull(secondsSinceDexcomEpoch, \"secondsSinceDexcomEpoch should be non-null.\");\n      return DexcomG4Constants.DEXCOM_EPOCH.plusSeconds(secondsSinceDexcomEpoch);\n    }\n  };", "modifier": "private", "type": "Function<Long, Instant>", "declarator": "DEXCOM_SYSTEM_TIME_TO_INSTANT = new Function<Long, Instant>() {\n    @Nullable\n    @Override\n    public Instant apply(@Nullable Long secondsSinceDexcomEpoch) {\n      checkNotNull(secondsSinceDexcomEpoch, \"secondsSinceDexcomEpoch should be non-null.\");\n      return DexcomG4Constants.DEXCOM_EPOCH.plusSeconds(secondsSinceDexcomEpoch);\n    }\n  }", "var_name": "DEXCOM_SYSTEM_TIME_TO_INSTANT"}, {"original_string": "private Function<Long, LocalDateTime> DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME = new Function<Long, LocalDateTime>() {\n    @Nullable\n    @Override\n    public LocalDateTime apply(@Nullable Long secondsSinceDexcomEpoch) {\n      checkNotNull(secondsSinceDexcomEpoch, \"secondsSinceDexcomEpoch should be non-null.\");\n      Instant instantInUTC = DexcomG4Constants.DEXCOM_EPOCH.plusSeconds(secondsSinceDexcomEpoch);\n      return LocalDateTime.ofInstant(instantInUTC, ZoneId.of(\"UTC\"));\n    }\n  };", "modifier": "private", "type": "Function<Long, LocalDateTime>", "declarator": "DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME = new Function<Long, LocalDateTime>() {\n    @Nullable\n    @Override\n    public LocalDateTime apply(@Nullable Long secondsSinceDexcomEpoch) {\n      checkNotNull(secondsSinceDexcomEpoch, \"secondsSinceDexcomEpoch should be non-null.\");\n      Instant instantInUTC = DexcomG4Constants.DEXCOM_EPOCH.plusSeconds(secondsSinceDexcomEpoch);\n      return LocalDateTime.ofInstant(instantInUTC, ZoneId.of(\"UTC\"));\n    }\n  }", "var_name": "DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME"}, {"original_string": "private Function<Integer, Float> DEXCOM_GLUCOSE_VALUE_TO_GLUCOSE_VALUE =\n      new Function<Integer, Float>() {\n        @Nullable\n        @Override\n        public Float apply(@Nullable Integer readValue) {\n          checkNotNull(readValue, \"readValue should be non-null.\");\n\n          boolean isDisplayOnly = (readValue & GLUCOSE_DISPLAY_ONLY_MASK) != 0;\n\n          if (isDisplayOnly) {\n            return INVALID_GLUCOSE_RECORD_VALUE;\n          } else {\n            int actualValue = readValue & GLUCOSE_READ_VALUE_MASK;\n            if (SPECIAL_GLUCOSE_VALUES.contains(actualValue)) {\n              return INVALID_GLUCOSE_RECORD_VALUE;\n            } else {\n              return readValue.floatValue();\n            }\n          }\n        }\n      };", "modifier": "private", "type": "Function<Integer, Float>", "declarator": "DEXCOM_GLUCOSE_VALUE_TO_GLUCOSE_VALUE =\n      new Function<Integer, Float>() {\n        @Nullable\n        @Override\n        public Float apply(@Nullable Integer readValue) {\n          checkNotNull(readValue, \"readValue should be non-null.\");\n\n          boolean isDisplayOnly = (readValue & GLUCOSE_DISPLAY_ONLY_MASK) != 0;\n\n          if (isDisplayOnly) {\n            return INVALID_GLUCOSE_RECORD_VALUE;\n          } else {\n            int actualValue = readValue & GLUCOSE_READ_VALUE_MASK;\n            if (SPECIAL_GLUCOSE_VALUES.contains(actualValue)) {\n              return INVALID_GLUCOSE_RECORD_VALUE;\n            } else {\n              return readValue.floatValue();\n            }\n          }\n        }\n      }", "var_name": "DEXCOM_GLUCOSE_VALUE_TO_GLUCOSE_VALUE"}, {"original_string": "private Function<GlucoseReadRecord, GlucoseRead> DEXCOM_GLUCOSE_RECORD_TO_GLUCOSE_READ =\n      new Function<GlucoseReadRecord, GlucoseRead>() {\n        @Override\n        public GlucoseRead apply(@javax.annotation.Nullable GlucoseReadRecord glucoseReadRecord) {\n          checkNotNull(glucoseReadRecord, \"glucoseReadRecord should be non-null\");\n\n          Instant internalTimeUTC =\n              DEXCOM_SYSTEM_TIME_TO_INSTANT.apply(glucoseReadRecord.getInternalSecondsSinceDexcomEpoch());\n          LocalDateTime displayTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(glucoseReadRecord.getLocalSecondsSinceDexcomEpoch());\n\n          float glucoseValue =\n              DEXCOM_GLUCOSE_VALUE_TO_GLUCOSE_VALUE.apply(glucoseReadRecord.getGlucoseValueWithFlags());\n\n          // TODO: remove the hardcoded unit and replace by the actual unit as per the configuration settings of the\n          // receiver\n          return new GlucoseRead(internalTimeUTC, displayTime, glucoseValue, GlucoseRead.Unit.MG_PER_DL);\n        }\n      };", "modifier": "private", "type": "Function<GlucoseReadRecord, GlucoseRead>", "declarator": "DEXCOM_GLUCOSE_RECORD_TO_GLUCOSE_READ =\n      new Function<GlucoseReadRecord, GlucoseRead>() {\n        @Override\n        public GlucoseRead apply(@javax.annotation.Nullable GlucoseReadRecord glucoseReadRecord) {\n          checkNotNull(glucoseReadRecord, \"glucoseReadRecord should be non-null\");\n\n          Instant internalTimeUTC =\n              DEXCOM_SYSTEM_TIME_TO_INSTANT.apply(glucoseReadRecord.getInternalSecondsSinceDexcomEpoch());\n          LocalDateTime displayTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(glucoseReadRecord.getLocalSecondsSinceDexcomEpoch());\n\n          float glucoseValue =\n              DEXCOM_GLUCOSE_VALUE_TO_GLUCOSE_VALUE.apply(glucoseReadRecord.getGlucoseValueWithFlags());\n\n          // TODO: remove the hardcoded unit and replace by the actual unit as per the configuration settings of the\n          // receiver\n          return new GlucoseRead(internalTimeUTC, displayTime, glucoseValue, GlucoseRead.Unit.MG_PER_DL);\n        }\n      }", "var_name": "DEXCOM_GLUCOSE_RECORD_TO_GLUCOSE_READ"}, {"original_string": "private Function<ManufacturingParameters, DeviceInfo> DEXCOM_MANUFACTURING_PARAMS_TO_DEVICE_INFO =\n      new Function<ManufacturingParameters, DeviceInfo>() {\n        @Override\n        public DeviceInfo apply(@javax.annotation.Nullable ManufacturingParameters manufacturingParameters) {\n          checkNotNull(manufacturingParameters, \"manufacturingParameters should be non-null\");\n\n          return new DeviceInfo(manufacturingParameters.getSerialNumber(),  manufacturingParameters.getHardwareId(),\n              manufacturingParameters.getHardwareRevision());\n        }\n      };", "modifier": "private", "type": "Function<ManufacturingParameters, DeviceInfo>", "declarator": "DEXCOM_MANUFACTURING_PARAMS_TO_DEVICE_INFO =\n      new Function<ManufacturingParameters, DeviceInfo>() {\n        @Override\n        public DeviceInfo apply(@javax.annotation.Nullable ManufacturingParameters manufacturingParameters) {\n          checkNotNull(manufacturingParameters, \"manufacturingParameters should be non-null\");\n\n          return new DeviceInfo(manufacturingParameters.getSerialNumber(),  manufacturingParameters.getHardwareId(),\n              manufacturingParameters.getHardwareRevision());\n        }\n      }", "var_name": "DEXCOM_MANUFACTURING_PARAMS_TO_DEVICE_INFO"}, {"original_string": "private Function<UserEventRecord, InsulinInjection> USER_EVENT_RECORD_TO_INSULIN_INJECTION =\n      new Function<UserEventRecord, InsulinInjection>() {\n        @Override\n        public InsulinInjection apply(@javax.annotation.Nullable UserEventRecord insulinEvent) {\n          checkNotNull(insulinEvent, \"insulinEvent should be non-null\");\n          checkArgument(insulinEvent.getEventType() == INSULIN);\n\n          Instant internalTimeUTC =\n              DEXCOM_SYSTEM_TIME_TO_INSTANT.apply(insulinEvent.getInternalSecondsSinceDexcomEpoch());\n          LocalDateTime localRecordedTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(insulinEvent.getLocalSecondsSinceDexcomEpoch());\n          LocalDateTime eventLocalTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(insulinEvent.getEventSecondsSinceDexcomEpoch());\n\n          float unitValue = insulinEvent.getEventValue() / 100.f;\n\n          return new InsulinInjection(internalTimeUTC, localRecordedTime, eventLocalTime, unitValue, UNKNOWN,\n              UNAVAILABLE_INSULIN_NAME);\n        }\n      };", "modifier": "private", "type": "Function<UserEventRecord, InsulinInjection>", "declarator": "USER_EVENT_RECORD_TO_INSULIN_INJECTION =\n      new Function<UserEventRecord, InsulinInjection>() {\n        @Override\n        public InsulinInjection apply(@javax.annotation.Nullable UserEventRecord insulinEvent) {\n          checkNotNull(insulinEvent, \"insulinEvent should be non-null\");\n          checkArgument(insulinEvent.getEventType() == INSULIN);\n\n          Instant internalTimeUTC =\n              DEXCOM_SYSTEM_TIME_TO_INSTANT.apply(insulinEvent.getInternalSecondsSinceDexcomEpoch());\n          LocalDateTime localRecordedTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(insulinEvent.getLocalSecondsSinceDexcomEpoch());\n          LocalDateTime eventLocalTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(insulinEvent.getEventSecondsSinceDexcomEpoch());\n\n          float unitValue = insulinEvent.getEventValue() / 100.f;\n\n          return new InsulinInjection(internalTimeUTC, localRecordedTime, eventLocalTime, unitValue, UNKNOWN,\n              UNAVAILABLE_INSULIN_NAME);\n        }\n      }", "var_name": "USER_EVENT_RECORD_TO_INSULIN_INJECTION"}, {"original_string": "private Function<UserEventRecord, FoodEvent> USER_EVENT_RECORD_TO_FOOD_EVENT =\n      new Function<UserEventRecord, FoodEvent>() {\n        @Override\n        public FoodEvent apply(@javax.annotation.Nullable UserEventRecord carbEvent) {\n          checkNotNull(carbEvent, \"insulinEvent should be non-null\");\n          checkArgument(carbEvent.getEventType() == CARBS);\n\n          Instant internalTimeUTC =\n              DEXCOM_SYSTEM_TIME_TO_INSTANT.apply(carbEvent.getInternalSecondsSinceDexcomEpoch());\n          LocalDateTime localRecordedTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(carbEvent.getLocalSecondsSinceDexcomEpoch());\n          LocalDateTime eventLocalTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(carbEvent.getEventSecondsSinceDexcomEpoch());\n\n          float unitValue = carbEvent.getEventValue();\n\n          return new FoodEvent(internalTimeUTC, localRecordedTime, eventLocalTime, unitValue, 0f);\n        }\n      };", "modifier": "private", "type": "Function<UserEventRecord, FoodEvent>", "declarator": "USER_EVENT_RECORD_TO_FOOD_EVENT =\n      new Function<UserEventRecord, FoodEvent>() {\n        @Override\n        public FoodEvent apply(@javax.annotation.Nullable UserEventRecord carbEvent) {\n          checkNotNull(carbEvent, \"insulinEvent should be non-null\");\n          checkArgument(carbEvent.getEventType() == CARBS);\n\n          Instant internalTimeUTC =\n              DEXCOM_SYSTEM_TIME_TO_INSTANT.apply(carbEvent.getInternalSecondsSinceDexcomEpoch());\n          LocalDateTime localRecordedTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(carbEvent.getLocalSecondsSinceDexcomEpoch());\n          LocalDateTime eventLocalTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(carbEvent.getEventSecondsSinceDexcomEpoch());\n\n          float unitValue = carbEvent.getEventValue();\n\n          return new FoodEvent(internalTimeUTC, localRecordedTime, eventLocalTime, unitValue, 0f);\n        }\n      }", "var_name": "USER_EVENT_RECORD_TO_FOOD_EVENT"}, {"original_string": "private Function<UserEventRecord.ExerciseIntensity, ExerciseSession.Intensity> DEXCOM_EXERCISE_INTENSITY_TO_INTENSITY = new Function<UserEventRecord.ExerciseIntensity, ExerciseSession.Intensity>() {\n    @Nullable\n    @Override\n    public ExerciseSession.Intensity apply(@Nullable UserEventRecord.ExerciseIntensity exerciseIntensity) {\n      checkNotNull(exerciseIntensity, \"exerciseIntensity should be non-null\");\n\n      switch (exerciseIntensity) {\n        case LIGHT:\n          return ExerciseSession.Intensity.LIGHT;\n        case MEDIUM:\n          return ExerciseSession.Intensity.MEDIUM;\n        case HEAVY:\n          return ExerciseSession.Intensity.HEAVY;\n        default:\n          return null;\n      }\n    }\n  };", "modifier": "private", "type": "Function<UserEventRecord.ExerciseIntensity, ExerciseSession.Intensity>", "declarator": "DEXCOM_EXERCISE_INTENSITY_TO_INTENSITY = new Function<UserEventRecord.ExerciseIntensity, ExerciseSession.Intensity>() {\n    @Nullable\n    @Override\n    public ExerciseSession.Intensity apply(@Nullable UserEventRecord.ExerciseIntensity exerciseIntensity) {\n      checkNotNull(exerciseIntensity, \"exerciseIntensity should be non-null\");\n\n      switch (exerciseIntensity) {\n        case LIGHT:\n          return ExerciseSession.Intensity.LIGHT;\n        case MEDIUM:\n          return ExerciseSession.Intensity.MEDIUM;\n        case HEAVY:\n          return ExerciseSession.Intensity.HEAVY;\n        default:\n          return null;\n      }\n    }\n  }", "var_name": "DEXCOM_EXERCISE_INTENSITY_TO_INTENSITY"}, {"original_string": "private Function<UserEventRecord, ExerciseSession> USER_EVENT_RECORD_TO_EXERCISE_SESSION =\n      new Function<UserEventRecord, ExerciseSession>() {\n        @Override\n        public ExerciseSession apply(@javax.annotation.Nullable UserEventRecord exerciseSession) {\n          checkNotNull(exerciseSession, \"exerciseSession should be non-null\");\n          checkArgument(exerciseSession.getEventType() == EXERCISE);\n\n          Instant internalTimeUTC =\n              DEXCOM_SYSTEM_TIME_TO_INSTANT.apply(exerciseSession.getInternalSecondsSinceDexcomEpoch());\n          LocalDateTime localRecordedTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(exerciseSession.getLocalSecondsSinceDexcomEpoch());\n          LocalDateTime eventLocalTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(exerciseSession.getEventSecondsSinceDexcomEpoch());\n\n          long duration = exerciseSession.getEventValue();\n\n          UserEventRecord.ExerciseIntensity exerciseIntensity =\n              UserEventRecord.ExerciseIntensity.fromId(exerciseSession.getEventSubType());\n          ExerciseSession.Intensity intensity =\n              DEXCOM_EXERCISE_INTENSITY_TO_INTENSITY.apply(exerciseIntensity);\n\n          return new ExerciseSession(internalTimeUTC, localRecordedTime, eventLocalTime,\n              intensity, Duration.ofMinutes(duration), EMPTY_DESCRIPTION);\n        }\n      };", "modifier": "private", "type": "Function<UserEventRecord, ExerciseSession>", "declarator": "USER_EVENT_RECORD_TO_EXERCISE_SESSION =\n      new Function<UserEventRecord, ExerciseSession>() {\n        @Override\n        public ExerciseSession apply(@javax.annotation.Nullable UserEventRecord exerciseSession) {\n          checkNotNull(exerciseSession, \"exerciseSession should be non-null\");\n          checkArgument(exerciseSession.getEventType() == EXERCISE);\n\n          Instant internalTimeUTC =\n              DEXCOM_SYSTEM_TIME_TO_INSTANT.apply(exerciseSession.getInternalSecondsSinceDexcomEpoch());\n          LocalDateTime localRecordedTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(exerciseSession.getLocalSecondsSinceDexcomEpoch());\n          LocalDateTime eventLocalTime =\n              DEXCOM_DISPLAY_TIME_TO_LOCAL_DATE_TIME.apply(exerciseSession.getEventSecondsSinceDexcomEpoch());\n\n          long duration = exerciseSession.getEventValue();\n\n          UserEventRecord.ExerciseIntensity exerciseIntensity =\n              UserEventRecord.ExerciseIntensity.fromId(exerciseSession.getEventSubType());\n          ExerciseSession.Intensity intensity =\n              DEXCOM_EXERCISE_INTENSITY_TO_INTENSITY.apply(exerciseIntensity);\n\n          return new ExerciseSession(internalTimeUTC, localRecordedTime, eventLocalTime,\n              intensity, Duration.ofMinutes(duration), EMPTY_DESCRIPTION);\n        }\n      }", "var_name": "USER_EVENT_RECORD_TO_EXERCISE_SESSION"}], "methods": [{"identifier": "convertData", "parameters": "(DexcomSyncData source)", "modifiers": "@Override public", "return": "SyncData", "signature": "SyncData convertData(DexcomSyncData source)", "full_signature": "@Override public SyncData convertData(DexcomSyncData source)", "class_method_signature": "DexcomAdapterService.convertData(DexcomSyncData source)", "testcase": false, "constructor": false}], "file": "dexcom-receiver/src/main/java/org/glukit/dexcom/sync/DexcomAdapterService.java"}, "focal_method": {"identifier": "convertData", "parameters": "(DexcomSyncData source)", "modifiers": "@Override public", "return": "SyncData", "body": "@Override\n  public SyncData convertData(DexcomSyncData source) {\n    List<GlucoseRead> glucoseReads = newArrayList(Collections2.filter(Collections2.transform(source.getGlucoseReads(),\n        DEXCOM_GLUCOSE_RECORD_TO_GLUCOSE_READ), VALID_READS_FILTER));\n\n    DeviceInfo deviceInfo = DEXCOM_MANUFACTURING_PARAMS_TO_DEVICE_INFO.apply(source.getManufacturingParameters());\n\n    Collection<UserEventRecord> insulinEvents = Collections2.filter(source.getUserEvents(), INSULIN_EVENT_FILTER);\n    Collection<UserEventRecord> exerciseEvents = Collections2.filter(source.getUserEvents(), EXERCISE_EVENT_FILTER);\n    Collection<UserEventRecord> carbEvents = Collections2.filter(source.getUserEvents(), CARB_EVENT_FILTER);\n\n    List<InsulinInjection> injections =\n        newArrayList(Collections2.transform(insulinEvents, USER_EVENT_RECORD_TO_INSULIN_INJECTION));\n    List<ExerciseSession> exerciseSessions =\n        newArrayList(Collections2.transform(exerciseEvents, USER_EVENT_RECORD_TO_EXERCISE_SESSION));\n    List<FoodEvent> foodEvents =\n        newArrayList(Collections2.transform(carbEvents, USER_EVENT_RECORD_TO_FOOD_EVENT));\n\n    return new SyncData(glucoseReads, injections, foodEvents, exerciseSessions, deviceInfo, source.getUpdateTime());\n  }", "signature": "SyncData convertData(DexcomSyncData source)", "full_signature": "@Override public SyncData convertData(DexcomSyncData source)", "class_method_signature": "DexcomAdapterService.convertData(DexcomSyncData source)", "testcase": false, "constructor": false, "invocations": ["newArrayList", "filter", "transform", "getGlucoseReads", "apply", "getManufacturingParameters", "filter", "getUserEvents", "filter", "getUserEvents", "filter", "getUserEvents", "newArrayList", "transform", "newArrayList", "transform", "newArrayList", "transform", "getUpdateTime"]}, "repository": {"repo_id": 13185812, "url": "https://github.com/alexandre-normand/blood-shepherd", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 7, "size": 408, "license": "licensed"}}