{"test_class": {"identifier": "TopologyLinkDataChangeHandlerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@MockitoAnnotations.Mock\n    private DataBroker dataBroker;", "modifier": "@MockitoAnnotations.Mock\n    private", "type": "DataBroker", "declarator": "dataBroker", "var_name": "dataBroker"}, {"original_string": "@MockitoAnnotations.Mock\n    private NetworkGraphService networkGraphService;", "modifier": "@MockitoAnnotations.Mock\n    private", "type": "NetworkGraphService", "declarator": "networkGraphService", "var_name": "networkGraphService"}, {"original_string": "private TopologyLinkDataChangeHandler topologyLinkDataChangeHandler;", "modifier": "private", "type": "TopologyLinkDataChangeHandler", "declarator": "topologyLinkDataChangeHandler", "var_name": "topologyLinkDataChangeHandler"}], "file": "loopremover/implementation/src/test/java/org/opendaylight/l2switch/loopremover/topology/TopologyLinkDataChangeHandlerTest.java"}, "test_case": {"identifier": "testUpdateNodeConnectorStatus_WithLinks", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") @Test public", "return": "void", "body": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testUpdateNodeConnectorStatus_WithLinks() throws Exception {\n        // Setup code to trigger the TopologyDataChangeEventProcessor\n        InstanceIdentifier<Link> instanceId = InstanceIdentifier.create(Link.class);\n        Link nodeLink = new LinkBuilder().setLinkId(new LinkId(\"openflow:1\")).build();\n        DataTreeModification<Link> mockChange = Mockito.mock(DataTreeModification.class);\n        DataObjectModification<Link> mockModification = Mockito.mock(DataObjectModification.class);\n        when(mockModification.getDataAfter()).thenReturn(nodeLink);\n        when(mockModification.getModificationType()).thenReturn(DataObjectModification.ModificationType.WRITE);\n        when(mockChange.getRootPath()).thenReturn(new DataTreeIdentifier<>(LogicalDatastoreType.OPERATIONAL,\n                instanceId));\n        when(mockChange.getRootNode()).thenReturn(mockModification);\n\n        // getLinksFromTopology\n        List<Link> links = new ArrayList<>();\n        links.add(new LinkBuilder().setLinkId(new LinkId(\"openflow:1\")).build());\n        Topology topology = new TopologyBuilder().setLink(links).build();\n        Optional<Topology> topologyOptional = Optional.of(topology);\n        CheckedFuture checkedFuture = Mockito.mock(CheckedFuture.class);\n        when(checkedFuture.get()).thenReturn(topologyOptional);\n        ReadOnlyTransaction readOnlyTransaction = Mockito.mock(ReadOnlyTransaction.class);\n        when(readOnlyTransaction.read(any(LogicalDatastoreType.class), any(InstanceIdentifier.class)))\n                .thenReturn(checkedFuture);\n        when(dataBroker.newReadOnlyTransaction()).thenReturn(readOnlyTransaction);\n\n        // run\n        ReadWriteTransaction readWriteTransaction = Mockito.mock(ReadWriteTransaction.class);\n        when(dataBroker.newReadWriteTransaction()).thenReturn(readWriteTransaction);\n\n        // updateNodeConnectorStatus\n        Link link1 = new LinkBuilder().setLinkId(new LinkId(\"openflow:1\"))\n                .setSource(new SourceBuilder().setSourceNode(new NodeId(\"openflow:1\"))\n                        .setSourceTp(new TpId(\"openflow:1\")).build())\n                .setDestination(new DestinationBuilder().setDestNode(new NodeId(\"openflow:1\"))\n                        .setDestTp(new TpId(\"openflow:1\")).build())\n                .build();\n        Link link2 = new LinkBuilder().setLinkId(new LinkId(\"openflow:2\"))\n                .setSource(new SourceBuilder().setSourceNode(new NodeId(\"openflow:2\"))\n                        .setSourceTp(new TpId(\"openflow:2\")).build())\n                .setDestination(new DestinationBuilder().setDestNode(new NodeId(\"openflow:2\"))\n                        .setDestTp(new TpId(\"openflow:2\")).build())\n                .build();\n\n        List<Link> allLinks = new ArrayList<>();\n        allLinks.add(link1);\n        allLinks.add(link2);\n        when(networkGraphService.getAllLinks()).thenReturn(allLinks);\n        List<Link> mstLinks = new ArrayList<>();\n        mstLinks.add(link1);\n        when(networkGraphService.getLinksInMst()).thenReturn(mstLinks);\n\n        // checkIfExistAndUpdateNodeConnector\n        NodeConnector nodeConnector = new NodeConnectorBuilder().build();\n        Optional<NodeConnector> optionalNodeConnector = Optional.of(nodeConnector);\n        CheckedFuture checkedFutureNc = Mockito.mock(CheckedFuture.class);\n        when(checkedFutureNc.get()).thenReturn(optionalNodeConnector);\n        when(readWriteTransaction.read(any(LogicalDatastoreType.class), any(InstanceIdentifier.class)))\n                .thenReturn(checkedFutureNc);\n\n        topologyLinkDataChangeHandler.onDataTreeChanged(Collections.singletonList(mockChange));\n        Thread.sleep(500);\n        verify(dataBroker, times(1)).newReadWriteTransaction();\n        verify(networkGraphService, times(1)).addLinks(any(ArrayList.class));\n        verify(networkGraphService, times(1)).getAllLinks();\n        verify(networkGraphService, times(1)).getLinksInMst();\n        verify(readWriteTransaction, times(4)).merge(any(LogicalDatastoreType.class), any(InstanceIdentifier.class),\n                any(StpStatusAwareNodeConnector.class));\n        verify(readWriteTransaction, times(1)).submit();\n    }", "signature": "void testUpdateNodeConnectorStatus_WithLinks()", "full_signature": "@SuppressWarnings(\"unchecked\") @Test public void testUpdateNodeConnectorStatus_WithLinks()", "class_method_signature": "TopologyLinkDataChangeHandlerTest.testUpdateNodeConnectorStatus_WithLinks()", "testcase": true, "constructor": false, "invocations": ["create", "build", "setLinkId", "mock", "mock", "thenReturn", "when", "getDataAfter", "thenReturn", "when", "getModificationType", "thenReturn", "when", "getRootPath", "thenReturn", "when", "getRootNode", "add", "build", "setLinkId", "build", "setLink", "of", "mock", "thenReturn", "when", "get", "mock", "thenReturn", "when", "read", "any", "any", "thenReturn", "when", "newReadOnlyTransaction", "mock", "thenReturn", "when", "newReadWriteTransaction", "build", "setDestination", "setSource", "setLinkId", "build", "setSourceTp", "setSourceNode", "build", "setDestTp", "setDestNode", "build", "setDestination", "setSource", "setLinkId", "build", "setSourceTp", "setSourceNode", "build", "setDestTp", "setDestNode", "add", "add", "thenReturn", "when", "getAllLinks", "add", "thenReturn", "when", "getLinksInMst", "build", "of", "mock", "thenReturn", "when", "get", "thenReturn", "when", "read", "any", "any", "onDataTreeChanged", "singletonList", "sleep", "newReadWriteTransaction", "verify", "times", "addLinks", "verify", "times", "any", "getAllLinks", "verify", "times", "getLinksInMst", "verify", "times", "merge", "verify", "times", "any", "any", "any", "submit", "verify", "times"]}, "focal_class": {"identifier": "TopologyLinkDataChangeHandler", "superclass": "", "interfaces": "implements DataTreeChangeListener<Link>", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(TopologyLinkDataChangeHandler.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(TopologyLinkDataChangeHandler.class)", "var_name": "LOG"}, {"original_string": "private static final String DEFAULT_TOPOLOGY_ID = \"flow:1\";", "modifier": "private static final", "type": "String", "declarator": "DEFAULT_TOPOLOGY_ID = \"flow:1\"", "var_name": "DEFAULT_TOPOLOGY_ID"}, {"original_string": "private static final long DEFAULT_GRAPH_REFRESH_DELAY = 1000;", "modifier": "private static final", "type": "long", "declarator": "DEFAULT_GRAPH_REFRESH_DELAY = 1000", "var_name": "DEFAULT_GRAPH_REFRESH_DELAY"}, {"original_string": "private final ScheduledExecutorService topologyDataChangeEventProcessor = Executors.newScheduledThreadPool(1);", "modifier": "private final", "type": "ScheduledExecutorService", "declarator": "topologyDataChangeEventProcessor = Executors.newScheduledThreadPool(1)", "var_name": "topologyDataChangeEventProcessor"}, {"original_string": "private final NetworkGraphService networkGraphService;", "modifier": "private final", "type": "NetworkGraphService", "declarator": "networkGraphService", "var_name": "networkGraphService"}, {"original_string": "private volatile boolean networkGraphRefreshScheduled = false;", "modifier": "private volatile", "type": "boolean", "declarator": "networkGraphRefreshScheduled = false", "var_name": "networkGraphRefreshScheduled"}, {"original_string": "private volatile boolean threadReschedule = false;", "modifier": "private volatile", "type": "boolean", "declarator": "threadReschedule = false", "var_name": "threadReschedule"}, {"original_string": "private long graphRefreshDelay;", "modifier": "private", "type": "long", "declarator": "graphRefreshDelay", "var_name": "graphRefreshDelay"}, {"original_string": "private String topologyId;", "modifier": "private", "type": "String", "declarator": "topologyId", "var_name": "topologyId"}, {"original_string": "private final DataBroker dataBroker;", "modifier": "private final", "type": "DataBroker", "declarator": "dataBroker", "var_name": "dataBroker"}], "methods": [{"identifier": "TopologyLinkDataChangeHandler", "parameters": "(DataBroker dataBroker, NetworkGraphService networkGraphService)", "modifiers": "public", "return": "", "signature": " TopologyLinkDataChangeHandler(DataBroker dataBroker, NetworkGraphService networkGraphService)", "full_signature": "public  TopologyLinkDataChangeHandler(DataBroker dataBroker, NetworkGraphService networkGraphService)", "class_method_signature": "TopologyLinkDataChangeHandler.TopologyLinkDataChangeHandler(DataBroker dataBroker, NetworkGraphService networkGraphService)", "testcase": false, "constructor": true}, {"identifier": "setGraphRefreshDelay", "parameters": "(long graphRefreshDelay)", "modifiers": "public", "return": "void", "signature": "void setGraphRefreshDelay(long graphRefreshDelay)", "full_signature": "public void setGraphRefreshDelay(long graphRefreshDelay)", "class_method_signature": "TopologyLinkDataChangeHandler.setGraphRefreshDelay(long graphRefreshDelay)", "testcase": false, "constructor": false}, {"identifier": "setTopologyId", "parameters": "(String topologyId)", "modifiers": "public", "return": "void", "signature": "void setTopologyId(String topologyId)", "full_signature": "public void setTopologyId(String topologyId)", "class_method_signature": "TopologyLinkDataChangeHandler.setTopologyId(String topologyId)", "testcase": false, "constructor": false}, {"identifier": "registerAsDataChangeListener", "parameters": "()", "modifiers": "public", "return": "ListenerRegistration<TopologyLinkDataChangeHandler>", "signature": "ListenerRegistration<TopologyLinkDataChangeHandler> registerAsDataChangeListener()", "full_signature": "public ListenerRegistration<TopologyLinkDataChangeHandler> registerAsDataChangeListener()", "class_method_signature": "TopologyLinkDataChangeHandler.registerAsDataChangeListener()", "testcase": false, "constructor": false}, {"identifier": "onDataTreeChanged", "parameters": "(Collection<DataTreeModification<Link>> changes)", "modifiers": "@Override public", "return": "void", "signature": "void onDataTreeChanged(Collection<DataTreeModification<Link>> changes)", "full_signature": "@Override public void onDataTreeChanged(Collection<DataTreeModification<Link>> changes)", "class_method_signature": "TopologyLinkDataChangeHandler.onDataTreeChanged(Collection<DataTreeModification<Link>> changes)", "testcase": false, "constructor": false}], "file": "loopremover/implementation/src/main/java/org/opendaylight/l2switch/loopremover/topology/TopologyLinkDataChangeHandler.java"}, "focal_method": {"identifier": "onDataTreeChanged", "parameters": "(Collection<DataTreeModification<Link>> changes)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void onDataTreeChanged(Collection<DataTreeModification<Link>> changes) {\n        boolean isGraphUpdated = false;\n\n        for (DataTreeModification<Link> change: changes) {\n            DataObjectModification<Link> rootNode = change.getRootNode();\n            switch (rootNode.getModificationType()) {\n                case WRITE:\n                    Link createdLink = rootNode.getDataAfter();\n                    if (rootNode.getDataBefore() == null && !createdLink.getLinkId().getValue().contains(\"host\")) {\n                        isGraphUpdated = true;\n                        LOG.debug(\"Graph is updated! Added Link {}\", createdLink.getLinkId().getValue());\n                    }\n                    break;\n                case DELETE:\n                    Link deletedLink = rootNode.getDataBefore();\n                    if (!deletedLink.getLinkId().getValue().contains(\"host\")) {\n                        isGraphUpdated = true;\n                        LOG.debug(\"Graph is updated! Removed Link {}\", deletedLink.getLinkId().getValue());\n                        break;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (!isGraphUpdated) {\n            return;\n        }\n        if (!networkGraphRefreshScheduled) {\n            synchronized (this) {\n                if (!networkGraphRefreshScheduled) {\n                    topologyDataChangeEventProcessor.schedule(new TopologyDataChangeEventProcessor(), graphRefreshDelay,\n                            TimeUnit.MILLISECONDS);\n                    networkGraphRefreshScheduled = true;\n                    LOG.debug(\"Scheduled Graph for refresh.\");\n                }\n            }\n        } else {\n            LOG.debug(\"Already scheduled for network graph refresh.\");\n            threadReschedule = true;\n        }\n    }", "signature": "void onDataTreeChanged(Collection<DataTreeModification<Link>> changes)", "full_signature": "@Override public void onDataTreeChanged(Collection<DataTreeModification<Link>> changes)", "class_method_signature": "TopologyLinkDataChangeHandler.onDataTreeChanged(Collection<DataTreeModification<Link>> changes)", "testcase": false, "constructor": false, "invocations": ["getRootNode", "getModificationType", "getDataAfter", "getDataBefore", "contains", "getValue", "getLinkId", "debug", "getValue", "getLinkId", "getDataBefore", "contains", "getValue", "getLinkId", "debug", "getValue", "getLinkId", "schedule", "debug", "debug"]}, "repository": {"repo_id": 20701467, "url": "https://github.com/opendaylight/l2switch", "language": "Java", "is_fork": false, "fork_count": 30, "stargazer_count": 25, "size": 4178, "license": "licensed"}}