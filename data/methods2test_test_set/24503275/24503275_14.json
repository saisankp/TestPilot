{"test_class": {"identifier": "RLPTest", "superclass": "", "interfaces": "", "fields": [], "file": "ethereumj-core/src/test/java/org/ethereum/util/RLPTest.java"}, "test_case": {"identifier": "testEncodeInt", "parameters": "()", "modifiers": "@Test /** encode int */ public", "return": "void", "body": "@Test /** encode int */\n    public void testEncodeInt() {\n\n        byte[] expected = {(byte)0x80};\n        byte[] data = RLP.encodeInt(0);\n        assertArrayEquals(expected, data);\n\n        byte[] expected2 = {(byte)0x78};\n        data = RLP.encodeInt(120);\n        assertArrayEquals(expected2, data);\n\n        byte[] expected3 = {(byte)0x81, (byte)0x7F};\n        data = RLP.encodeInt(127);\n        assertArrayEquals(expected3, data);\n\n        byte[] expected4 = {(byte)0x82, (byte)0x76, (byte)0x5F};\n        data = RLP.encodeInt(30303);\n        assertArrayEquals(expected4, data);\n\n        byte[] expected5 = {(byte)0x82, (byte)0x4E, (byte)0xEA};\n        data = RLP.encodeInt(20202);\n        assertArrayEquals(expected5, data);\n        \n        byte[] expected6 = {(byte)0x83, 1, 0, 0};\n        data = RLP.encodeInt(65536);\n        assertArrayEquals(expected6, data);\n        \n        byte[] expected7 = {(byte)0x80};\n        data = RLP.encodeInt(Integer.MIN_VALUE);\n        assertArrayEquals(expected7, data);\n\n        byte[] expected8 = {(byte)0x84, (byte)0x7F, (byte)0xFF, (byte)0xFF, (byte)0xFF};\n        data = RLP.encodeInt(Integer.MAX_VALUE);\n        assertArrayEquals(expected8, data);\n    }", "signature": "void testEncodeInt()", "full_signature": "@Test /** encode int */ public void testEncodeInt()", "class_method_signature": "RLPTest.testEncodeInt()", "testcase": true, "constructor": false, "invocations": ["encodeInt", "assertArrayEquals", "encodeInt", "assertArrayEquals", "encodeInt", "assertArrayEquals", "encodeInt", "assertArrayEquals", "encodeInt", "assertArrayEquals", "encodeInt", "assertArrayEquals", "encodeInt", "assertArrayEquals", "encodeInt", "assertArrayEquals"]}, "focal_class": {"identifier": "RLP", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static double MAX_ITEM_LENGTH = Math.pow(256, 8);", "modifier": "private static", "type": "double", "declarator": "MAX_ITEM_LENGTH = Math.pow(256, 8)", "var_name": "MAX_ITEM_LENGTH"}, {"original_string": "private static int SIZE_THRESHOLD = 56;", "modifier": "private static", "type": "int", "declarator": "SIZE_THRESHOLD = 56", "var_name": "SIZE_THRESHOLD"}, {"original_string": "private static int OFFSET_SHORT_ITEM = 0x80;", "modifier": "private static", "type": "int", "declarator": "OFFSET_SHORT_ITEM = 0x80", "var_name": "OFFSET_SHORT_ITEM"}, {"original_string": "private static int OFFSET_LONG_ITEM = 0xb7;", "modifier": "private static", "type": "int", "declarator": "OFFSET_LONG_ITEM = 0xb7", "var_name": "OFFSET_LONG_ITEM"}, {"original_string": "private static int OFFSET_SHORT_LIST = 0xc0;", "modifier": "private static", "type": "int", "declarator": "OFFSET_SHORT_LIST = 0xc0", "var_name": "OFFSET_SHORT_LIST"}, {"original_string": "private static int OFFSET_LONG_LIST = 0xf7;", "modifier": "private static", "type": "int", "declarator": "OFFSET_LONG_LIST = 0xf7", "var_name": "OFFSET_LONG_LIST"}], "methods": [{"identifier": "decodeOneByteItem", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "byte", "signature": "byte decodeOneByteItem(byte[] data, int index)", "full_signature": "private static byte decodeOneByteItem(byte[] data, int index)", "class_method_signature": "RLP.decodeOneByteItem(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeInt", "parameters": "(byte[] data, int index)", "modifiers": "public static", "return": "int", "signature": "int decodeInt(byte[] data, int index)", "full_signature": "public static int decodeInt(byte[] data, int index)", "class_method_signature": "RLP.decodeInt(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeShort", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "short", "signature": "short decodeShort(byte[] data, int index)", "full_signature": "private static short decodeShort(byte[] data, int index)", "class_method_signature": "RLP.decodeShort(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeLong", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "long", "signature": "long decodeLong(byte[] data, int index)", "full_signature": "private static long decodeLong(byte[] data, int index)", "class_method_signature": "RLP.decodeLong(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeStringItem", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "String", "signature": "String decodeStringItem(byte[] data, int index)", "full_signature": "private static String decodeStringItem(byte[] data, int index)", "class_method_signature": "RLP.decodeStringItem(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeItemBytes", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] decodeItemBytes(byte[] data, int index)", "full_signature": "private static byte[] decodeItemBytes(byte[] data, int index)", "class_method_signature": "RLP.decodeItemBytes(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeBigInteger", "parameters": "(byte[] data, int index)", "modifiers": "public static", "return": "BigInteger", "signature": "BigInteger decodeBigInteger(byte[] data, int index)", "full_signature": "public static BigInteger decodeBigInteger(byte[] data, int index)", "class_method_signature": "RLP.decodeBigInteger(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeByteArray", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] decodeByteArray(byte[] data, int index)", "full_signature": "private static byte[] decodeByteArray(byte[] data, int index)", "class_method_signature": "RLP.decodeByteArray(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "nextItemLength", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "int", "signature": "int nextItemLength(byte[] data, int index)", "full_signature": "private static int nextItemLength(byte[] data, int index)", "class_method_signature": "RLP.nextItemLength(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeIP4Bytes", "parameters": "(byte[] data, int index)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] decodeIP4Bytes(byte[] data, int index)", "full_signature": "public static byte[] decodeIP4Bytes(byte[] data, int index)", "class_method_signature": "RLP.decodeIP4Bytes(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "getFirstListElement", "parameters": "(byte[] payload, int pos)", "modifiers": "public static", "return": "int", "signature": "int getFirstListElement(byte[] payload, int pos)", "full_signature": "public static int getFirstListElement(byte[] payload, int pos)", "class_method_signature": "RLP.getFirstListElement(byte[] payload, int pos)", "testcase": false, "constructor": false}, {"identifier": "getNextElementIndex", "parameters": "(byte[] payload, int pos)", "modifiers": "public static", "return": "int", "signature": "int getNextElementIndex(byte[] payload, int pos)", "full_signature": "public static int getNextElementIndex(byte[] payload, int pos)", "class_method_signature": "RLP.getNextElementIndex(byte[] payload, int pos)", "testcase": false, "constructor": false}, {"identifier": "fullTraverse", "parameters": "(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "modifiers": "public static", "return": "void", "signature": "void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "full_signature": "public static void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "class_method_signature": "RLP.fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "testcase": false, "constructor": false}, {"identifier": "calcLength", "parameters": "(int lengthOfLength, byte[] msgData, int pos)", "modifiers": "private static", "return": "int", "signature": "int calcLength(int lengthOfLength, byte[] msgData, int pos)", "full_signature": "private static int calcLength(int lengthOfLength, byte[] msgData, int pos)", "class_method_signature": "RLP.calcLength(int lengthOfLength, byte[] msgData, int pos)", "testcase": false, "constructor": false}, {"identifier": "calcLengthRaw", "parameters": "(int lengthOfLength, byte[] msgData, int index)", "modifiers": "private static", "return": "int", "signature": "int calcLengthRaw(int lengthOfLength, byte[] msgData, int index)", "full_signature": "private static int calcLengthRaw(int lengthOfLength, byte[] msgData, int index)", "class_method_signature": "RLP.calcLengthRaw(int lengthOfLength, byte[] msgData, int index)", "testcase": false, "constructor": false}, {"identifier": "getCommandCode", "parameters": "(byte[] data)", "modifiers": "public static", "return": "byte", "signature": "byte getCommandCode(byte[] data)", "full_signature": "public static byte getCommandCode(byte[] data)", "class_method_signature": "RLP.getCommandCode(byte[] data)", "testcase": false, "constructor": false}, {"identifier": "decode2", "parameters": "(byte[] msgData)", "modifiers": "public static", "return": "RLPList", "signature": "RLPList decode2(byte[] msgData)", "full_signature": "public static RLPList decode2(byte[] msgData)", "class_method_signature": "RLP.decode2(byte[] msgData)", "testcase": false, "constructor": false}, {"identifier": "fullTraverse", "parameters": "(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "modifiers": "private static", "return": "void", "signature": "void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "full_signature": "private static void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "class_method_signature": "RLP.fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(byte[] data, int pos)", "modifiers": "public static", "return": "DecodeResult", "signature": "DecodeResult decode(byte[] data, int pos)", "full_signature": "public static DecodeResult decode(byte[] data, int pos)", "class_method_signature": "RLP.decode(byte[] data, int pos)", "testcase": false, "constructor": false}, {"identifier": "decodeList", "parameters": "(byte[] data, int pos, int prevPos, int len)", "modifiers": "private static", "return": "DecodeResult", "signature": "DecodeResult decodeList(byte[] data, int pos, int prevPos, int len)", "full_signature": "private static DecodeResult decodeList(byte[] data, int pos, int prevPos, int len)", "class_method_signature": "RLP.decodeList(byte[] data, int pos, int prevPos, int len)", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(Object input)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encode(Object input)", "full_signature": "public static byte[] encode(Object input)", "class_method_signature": "RLP.encode(Object input)", "testcase": false, "constructor": false}, {"identifier": "encodeLength", "parameters": "(int length, int offset)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeLength(int length, int offset)", "full_signature": "public static byte[] encodeLength(int length, int offset)", "class_method_signature": "RLP.encodeLength(int length, int offset)", "testcase": false, "constructor": false}, {"identifier": "encodeByte", "parameters": "(byte singleByte)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeByte(byte singleByte)", "full_signature": "public static byte[] encodeByte(byte singleByte)", "class_method_signature": "RLP.encodeByte(byte singleByte)", "testcase": false, "constructor": false}, {"identifier": "encodeShort", "parameters": "(short singleShort)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeShort(short singleShort)", "full_signature": "public static byte[] encodeShort(short singleShort)", "class_method_signature": "RLP.encodeShort(short singleShort)", "testcase": false, "constructor": false}, {"identifier": "encodeInt", "parameters": "(int singleInt)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeInt(int singleInt)", "full_signature": "public static byte[] encodeInt(int singleInt)", "class_method_signature": "RLP.encodeInt(int singleInt)", "testcase": false, "constructor": false}, {"identifier": "encodeString", "parameters": "(String srcString)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeString(String srcString)", "full_signature": "public static byte[] encodeString(String srcString)", "class_method_signature": "RLP.encodeString(String srcString)", "testcase": false, "constructor": false}, {"identifier": "encodeBigInteger", "parameters": "(BigInteger srcBigInteger)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeBigInteger(BigInteger srcBigInteger)", "full_signature": "public static byte[] encodeBigInteger(BigInteger srcBigInteger)", "class_method_signature": "RLP.encodeBigInteger(BigInteger srcBigInteger)", "testcase": false, "constructor": false}, {"identifier": "encodeElement", "parameters": "(byte[] srcData)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeElement(byte[] srcData)", "full_signature": "public static byte[] encodeElement(byte[] srcData)", "class_method_signature": "RLP.encodeElement(byte[] srcData)", "testcase": false, "constructor": false}, {"identifier": "encodeList", "parameters": "(byte[]... elements)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeList(byte[]... elements)", "full_signature": "public static byte[] encodeList(byte[]... elements)", "class_method_signature": "RLP.encodeList(byte[]... elements)", "testcase": false, "constructor": false}, {"identifier": "toBytes", "parameters": "(Object input)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] toBytes(Object input)", "full_signature": "private static byte[] toBytes(Object input)", "class_method_signature": "RLP.toBytes(Object input)", "testcase": false, "constructor": false}], "file": "ethereumj-core/src/main/java/org/ethereum/util/RLP.java"}, "focal_method": {"identifier": "encodeInt", "parameters": "(int singleInt)", "modifiers": "public static", "return": "byte[]", "body": "public static byte[] encodeInt(int singleInt) {\n        if (singleInt <= 0xFF)\n            return encodeByte((byte) singleInt);\n        else if (singleInt <= 0xFFFF)\n    \t\treturn encodeShort((short) singleInt);\n        else if (singleInt <= 0xFFFFFF)\n\t\t\treturn new byte[] { (byte) (OFFSET_SHORT_ITEM + 3),\n\t\t\t\t(byte) (singleInt >>> 16),\n\t\t\t\t(byte) (singleInt >>> 8),\n\t\t\t\t(byte) singleInt};\n        else {\n\t\t\treturn new byte[] { (byte) (OFFSET_SHORT_ITEM + 4),\n\t\t\t\t\t(byte) (singleInt >>> 24),\n\t\t\t\t\t(byte) (singleInt >>> 16),\n\t\t\t\t\t(byte) (singleInt >>> 8),\n\t\t\t\t\t(byte) singleInt};\n        }\n    }", "signature": "byte[] encodeInt(int singleInt)", "full_signature": "public static byte[] encodeInt(int singleInt)", "class_method_signature": "RLP.encodeInt(int singleInt)", "testcase": false, "constructor": false, "invocations": ["encodeByte", "encodeShort"]}, "repository": {"repo_id": 24503275, "url": "https://github.com/ethereumj/ethereumj", "language": "Java", "is_fork": false, "fork_count": 22, "stargazer_count": 27, "size": 13884, "license": "licensed"}}