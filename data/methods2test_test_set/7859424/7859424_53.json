{"test_class": {"identifier": "TranspositionTableTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private TranspositionTable table;", "modifier": "private", "type": "TranspositionTable", "declarator": "table", "var_name": "table"}], "file": "src/edu/lclark/orego/mcts/TranspositionTableTest.java"}, "test_case": {"identifier": "testSweep", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testSweep() {\n\t\tSearchNode a = table.findOrAllocate(0L);\n\t\tSearchNode b = table.findOrAllocate(1L);\n\t\tSearchNode c = table.findOrAllocate(2L);\n\t\tSearchNode d = table.findOrAllocate(3L);\n\t\tSearchNode e = table.findOrAllocate(4L);\n\t\ttable.addChild(a, b);\n\t\ttable.addChild(b, c);\n\t\ttable.addChild(b, d);\n\t\ttable.addChild(c, e);\n\t\ttable.addChild(d, e);\n\t\ttable.markNodesReachableFrom(b);\n\t\ttable.sweep();\n\t\tassertNull(table.findIfPresent(0L));\n\t\tassertEquals(b, table.findIfPresent(1L));\n\t\tassertEquals(c, table.findIfPresent(2L));\n\t\tassertEquals(d, table.findIfPresent(3L));\n\t\tassertEquals(e, table.findIfPresent(4L));\n\t}", "signature": "void testSweep()", "full_signature": "@Test public void testSweep()", "class_method_signature": "TranspositionTableTest.testSweep()", "testcase": true, "constructor": false, "invocations": ["findOrAllocate", "findOrAllocate", "findOrAllocate", "findOrAllocate", "findOrAllocate", "addChild", "addChild", "addChild", "addChild", "addChild", "markNodesReachableFrom", "sweep", "assertNull", "findIfPresent", "assertEquals", "findIfPresent", "assertEquals", "findIfPresent", "assertEquals", "findIfPresent", "assertEquals", "findIfPresent"]}, "focal_class": {"identifier": "TranspositionTable", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final CoordinateSystem coords;", "modifier": "private final", "type": "CoordinateSystem", "declarator": "coords", "var_name": "coords"}, {"original_string": "private final Pool<ListNode<SearchNode>> listNodes;", "modifier": "private final", "type": "Pool<ListNode<SearchNode>>", "declarator": "listNodes", "var_name": "listNodes"}, {"original_string": "private final SearchNode[] table;", "modifier": "private final", "type": "SearchNode[]", "declarator": "table", "var_name": "table"}, {"original_string": "private int nodesInUse;", "modifier": "private", "type": "int", "declarator": "nodesInUse", "var_name": "nodesInUse"}], "methods": [{"identifier": "TranspositionTable", "parameters": "(int megabytes, SearchNodeBuilder builder,\n\t\t\tCoordinateSystem coords)", "modifiers": "public", "return": "", "signature": " TranspositionTable(int megabytes, SearchNodeBuilder builder,\n\t\t\tCoordinateSystem coords)", "full_signature": "public  TranspositionTable(int megabytes, SearchNodeBuilder builder,\n\t\t\tCoordinateSystem coords)", "class_method_signature": "TranspositionTable.TranspositionTable(int megabytes, SearchNodeBuilder builder,\n\t\t\tCoordinateSystem coords)", "testcase": false, "constructor": true}, {"identifier": "addChild", "parameters": "(SearchNode parent, SearchNode child)", "modifiers": "", "return": "void", "signature": "void addChild(SearchNode parent, SearchNode child)", "full_signature": " void addChild(SearchNode parent, SearchNode child)", "class_method_signature": "TranspositionTable.addChild(SearchNode parent, SearchNode child)", "testcase": false, "constructor": false}, {"identifier": "dagSize", "parameters": "(SearchNode root)", "modifiers": "public", "return": "int", "signature": "int dagSize(SearchNode root)", "full_signature": "public int dagSize(SearchNode root)", "class_method_signature": "TranspositionTable.dagSize(SearchNode root)", "testcase": false, "constructor": false}, {"identifier": "findIfPresent", "parameters": "(long fancyHash)", "modifiers": "public synchronized", "return": "SearchNode", "signature": "SearchNode findIfPresent(long fancyHash)", "full_signature": "public synchronized SearchNode findIfPresent(long fancyHash)", "class_method_signature": "TranspositionTable.findIfPresent(long fancyHash)", "testcase": false, "constructor": false}, {"identifier": "findOrAllocate", "parameters": "(long fancyHash)", "modifiers": "synchronized", "return": "SearchNode", "signature": "SearchNode findOrAllocate(long fancyHash)", "full_signature": "synchronized SearchNode findOrAllocate(long fancyHash)", "class_method_signature": "TranspositionTable.findOrAllocate(long fancyHash)", "testcase": false, "constructor": false}, {"identifier": "getCapacity", "parameters": "()", "modifiers": "", "return": "int", "signature": "int getCapacity()", "full_signature": " int getCapacity()", "class_method_signature": "TranspositionTable.getCapacity()", "testcase": false, "constructor": false}, {"identifier": "markNodesReachableFrom", "parameters": "(SearchNode root)", "modifiers": "", "return": "int", "signature": "int markNodesReachableFrom(SearchNode root)", "full_signature": " int markNodesReachableFrom(SearchNode root)", "class_method_signature": "TranspositionTable.markNodesReachableFrom(SearchNode root)", "testcase": false, "constructor": false}, {"identifier": "getNodesInUse", "parameters": "()", "modifiers": "", "return": "int", "signature": "int getNodesInUse()", "full_signature": " int getNodesInUse()", "class_method_signature": "TranspositionTable.getNodesInUse()", "testcase": false, "constructor": false}, {"identifier": "sweep", "parameters": "()", "modifiers": "", "return": "void", "signature": "void sweep()", "full_signature": " void sweep()", "class_method_signature": "TranspositionTable.sweep()", "testcase": false, "constructor": false}], "file": "src/edu/lclark/orego/mcts/TranspositionTable.java"}, "focal_method": {"identifier": "sweep", "parameters": "()", "modifiers": "", "return": "void", "body": "void sweep() {\n\t\tLogging.log(\"Nodes in use \" + nodesInUse + \"/\" + table.length + \" (\" + (nodesInUse* 100)/table.length  + \"%)\");\n\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\tfinal SearchNode node = table[i];\n\t\t\tif (node.isInUse()) {\n\t\t\t\tif (node.isMarked()) {\n\t\t\t\t\tnode.setMarked(false);\n\t\t\t\t} else {\n\t\t\t\t\tListNode<SearchNode> n = node.getChildren();\n\t\t\t\t\twhile (n != null) {\n\t\t\t\t\t\tn = listNodes.free(n);\n\t\t\t\t\t}\n\t\t\t\t\tnode.free();\n\t\t\t\t\tnodesInUse--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "signature": "void sweep()", "full_signature": " void sweep()", "class_method_signature": "TranspositionTable.sweep()", "testcase": false, "constructor": false, "invocations": ["log", "isInUse", "isMarked", "setMarked", "getChildren", "free", "free"]}, "repository": {"repo_id": 7859424, "url": "https://github.com/Orego/Orego", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 35, "size": 1341444, "license": "licensed"}}