{"test_class": {"identifier": "DateTimeUtilsTest", "superclass": "extends AbstractBaseTest", "interfaces": "", "fields": [{"original_string": "private static final long MINUTE_IN_MILLISECONDS = 60 * 1000L;", "modifier": "private static final", "type": "long", "declarator": "MINUTE_IN_MILLISECONDS = 60 * 1000L", "var_name": "MINUTE_IN_MILLISECONDS"}, {"original_string": "private static final long FIFTY_NINE_SECONDS_IN_MILLISECONDS = 59 * 1000L;", "modifier": "private static final", "type": "long", "declarator": "FIFTY_NINE_SECONDS_IN_MILLISECONDS = 59 * 1000L", "var_name": "FIFTY_NINE_SECONDS_IN_MILLISECONDS"}, {"original_string": "private static final long HOUR_IN_MILLISECONDS = 60 * 60 * 1000L;", "modifier": "private static final", "type": "long", "declarator": "HOUR_IN_MILLISECONDS = 60 * 60 * 1000L", "var_name": "HOUR_IN_MILLISECONDS"}], "file": "jbpm/jbpm-flow/src/test/java/org/jbpm/process/core/timer/DateTimeUtilsTest.java"}, "test_case": {"identifier": "testParseDateTime", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testParseDateTime() {\n        OffsetDateTime hourAfterEpoch = OffsetDateTime.of(1970, 1, 1, 1, 0, 0, 0, ZoneOffset.UTC);\n\n        long parsedMilliseconds = DateTimeUtils.parseDateTime(hourAfterEpoch.format(DateTimeFormatter.ISO_DATE_TIME));\n\n        assertEquals(HOUR_IN_MILLISECONDS, parsedMilliseconds);\n    }", "signature": "void testParseDateTime()", "full_signature": "@Test public void testParseDateTime()", "class_method_signature": "DateTimeUtilsTest.testParseDateTime()", "testcase": true, "constructor": false, "invocations": ["of", "parseDateTime", "format", "assertEquals"]}, "focal_class": {"identifier": "DateTimeUtils", "superclass": "extends TimeUtils", "interfaces": "", "fields": [], "methods": [{"identifier": "isRepeatable", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "boolean", "signature": "boolean isRepeatable(String dateTimeStr)", "full_signature": "public static boolean isRepeatable(String dateTimeStr)", "class_method_signature": "DateTimeUtils.isRepeatable(String dateTimeStr)", "testcase": false, "constructor": false}, {"identifier": "isPeriod", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "boolean", "signature": "boolean isPeriod(String dateTimeStr)", "full_signature": "public static boolean isPeriod(String dateTimeStr)", "class_method_signature": "DateTimeUtils.isPeriod(String dateTimeStr)", "testcase": false, "constructor": false}, {"identifier": "isNumeric", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "boolean", "signature": "boolean isNumeric(String dateTimeStr)", "full_signature": "public static boolean isNumeric(String dateTimeStr)", "class_method_signature": "DateTimeUtils.isNumeric(String dateTimeStr)", "testcase": false, "constructor": false}, {"identifier": "parseDateTime", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "long", "signature": "long parseDateTime(String dateTimeStr)", "full_signature": "public static long parseDateTime(String dateTimeStr)", "class_method_signature": "DateTimeUtils.parseDateTime(String dateTimeStr)", "testcase": false, "constructor": false}, {"identifier": "parseDuration", "parameters": "(String durationStr)", "modifiers": "public static", "return": "long", "signature": "long parseDuration(String durationStr)", "full_signature": "public static long parseDuration(String durationStr)", "class_method_signature": "DateTimeUtils.parseDuration(String durationStr)", "testcase": false, "constructor": false}, {"identifier": "parseDateAsDuration", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "long", "signature": "long parseDateAsDuration(String dateTimeStr)", "full_signature": "public static long parseDateAsDuration(String dateTimeStr)", "class_method_signature": "DateTimeUtils.parseDateAsDuration(String dateTimeStr)", "testcase": false, "constructor": false}, {"identifier": "parseISORepeatable", "parameters": "(String isoString)", "modifiers": "public static", "return": "String[]", "signature": "String[] parseISORepeatable(String isoString)", "full_signature": "public static String[] parseISORepeatable(String isoString)", "class_method_signature": "DateTimeUtils.parseISORepeatable(String isoString)", "testcase": false, "constructor": false}, {"identifier": "parseRepeatableDateTime", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "long[]", "signature": "long[] parseRepeatableDateTime(String dateTimeStr)", "full_signature": "public static long[] parseRepeatableDateTime(String dateTimeStr)", "class_method_signature": "DateTimeUtils.parseRepeatableDateTime(String dateTimeStr)", "testcase": false, "constructor": false}], "file": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/timer/DateTimeUtils.java"}, "focal_method": {"identifier": "parseDateTime", "parameters": "(String dateTimeStr)", "modifiers": "public static", "return": "long", "body": "public static long parseDateTime(String dateTimeStr) {\n        OffsetDateTime dateTime = OffsetDateTime.parse(dateTimeStr, DateTimeFormatter.ISO_DATE_TIME);\n        return dateTime.toInstant().toEpochMilli();\n    }", "signature": "long parseDateTime(String dateTimeStr)", "full_signature": "public static long parseDateTime(String dateTimeStr)", "class_method_signature": "DateTimeUtils.parseDateTime(String dateTimeStr)", "testcase": false, "constructor": false, "invocations": ["parse", "toEpochMilli", "toInstant"]}, "repository": {"repo_id": 174306645, "url": "https://github.com/kiegroup/kogito-runtimes", "stars": 78, "created": "3/7/2019 8:49:09 AM +00:00", "updates": "2020-01-26T20:41:49+00:00", "fork": "False", "license": "licensed"}}