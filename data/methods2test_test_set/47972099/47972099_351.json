{"test_class": {"identifier": "DataSinkTaskTest", "superclass": "extends TaskTestBase", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(DataSinkTaskTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(DataSinkTaskTest.class)", "var_name": "LOG"}, {"original_string": "private static final int MEMORY_MANAGER_SIZE = 3 * 1024 * 1024;", "modifier": "private static final", "type": "int", "declarator": "MEMORY_MANAGER_SIZE = 3 * 1024 * 1024", "var_name": "MEMORY_MANAGER_SIZE"}, {"original_string": "private static final int NETWORK_BUFFER_SIZE = 1024;", "modifier": "private static final", "type": "int", "declarator": "NETWORK_BUFFER_SIZE = 1024", "var_name": "NETWORK_BUFFER_SIZE"}, {"original_string": "private final String tempTestPath = constructTestPath(DataSinkTaskTest.class, \"dst_test\");", "modifier": "private final", "type": "String", "declarator": "tempTestPath = constructTestPath(DataSinkTaskTest.class, \"dst_test\")", "var_name": "tempTestPath"}], "file": "flink-runtime/src/test/java/org/apache/flink/runtime/operators/DataSinkTaskTest.java"}, "test_case": {"identifier": "testFailingSortingDataSinkTask", "parameters": "()", "modifiers": "@Test @SuppressWarnings(\"unchecked\") public", "return": "void", "body": "@Test\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void testFailingSortingDataSinkTask() {\n\n\t\tint keyCnt = 100;\n\t\tint valCnt = 20;\n\t\tdouble memoryFraction = 1.0;\n\n\t\tsuper.initEnvironment(MEMORY_MANAGER_SIZE, NETWORK_BUFFER_SIZE);\n\t\tsuper.addInput(new UniformRecordGenerator(keyCnt, valCnt, true), 0);\n\n\t\tDataSinkTask<Record> testTask = new DataSinkTask<>();\n\t\tConfiguration stubParams = new Configuration();\n\t\tsuper.getTaskConfig().setStubParameters(stubParams);\n\n\t\t// set sorting\n\t\tsuper.getTaskConfig().setInputLocalStrategy(0, LocalStrategy.SORT);\n\t\tsuper.getTaskConfig().setInputComparator(\n\t\t\t\tnew RecordComparatorFactory(new int[]{1}, ( new Class[]{IntValue.class})), 0);\n\t\tsuper.getTaskConfig().setRelativeMemoryInput(0, memoryFraction);\n\t\tsuper.getTaskConfig().setFilehandlesInput(0, 8);\n\t\tsuper.getTaskConfig().setSpillingThresholdInput(0, 0.8f);\n\n\t\tsuper.registerFileOutputTask(testTask, MockFailingOutputFormat.class, new File(tempTestPath).toURI().toString());\n\n\t\tboolean stubFailed = false;\n\n\t\ttry {\n\t\t\ttestTask.invoke();\n\t\t} catch (Exception e) {\n\t\t\tstubFailed = true;\n\t\t}\n\t\tAssert.assertTrue(\"Function exception was not forwarded.\", stubFailed);\n\n\t\t// assert that temp file was removed\n\t\tFile tempTestFile = new File(this.tempTestPath);\n\t\tAssert.assertFalse(\"Temp output file has not been removed\", tempTestFile.exists());\n\n\t}", "signature": "void testFailingSortingDataSinkTask()", "full_signature": "@Test @SuppressWarnings(\"unchecked\") public void testFailingSortingDataSinkTask()", "class_method_signature": "DataSinkTaskTest.testFailingSortingDataSinkTask()", "testcase": true, "constructor": false, "invocations": ["initEnvironment", "addInput", "setStubParameters", "getTaskConfig", "setInputLocalStrategy", "getTaskConfig", "setInputComparator", "getTaskConfig", "setRelativeMemoryInput", "getTaskConfig", "setFilehandlesInput", "getTaskConfig", "setSpillingThresholdInput", "getTaskConfig", "registerFileOutputTask", "toString", "toURI", "invoke", "assertTrue", "assertFalse", "exists"]}, "focal_class": {"identifier": "DataSinkTask", "superclass": "extends AbstractInvokable", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(DataSinkTask.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(DataSinkTask.class)", "var_name": "LOG"}, {"original_string": "private volatile OutputFormat<IT> format;", "modifier": "private volatile", "type": "OutputFormat<IT>", "declarator": "format", "var_name": "format"}, {"original_string": "private MutableReader<?> inputReader;", "modifier": "private", "type": "MutableReader<?>", "declarator": "inputReader", "var_name": "inputReader"}, {"original_string": "private MutableObjectIterator<IT> reader;", "modifier": "private", "type": "MutableObjectIterator<IT>", "declarator": "reader", "var_name": "reader"}, {"original_string": "private TypeSerializerFactory<IT> inputTypeSerializerFactory;", "modifier": "private", "type": "TypeSerializerFactory<IT>", "declarator": "inputTypeSerializerFactory", "var_name": "inputTypeSerializerFactory"}, {"original_string": "private CloseableInputProvider<IT> localStrategy;", "modifier": "private", "type": "CloseableInputProvider<IT>", "declarator": "localStrategy", "var_name": "localStrategy"}, {"original_string": "private TaskConfig config;", "modifier": "private", "type": "TaskConfig", "declarator": "config", "var_name": "config"}, {"original_string": "private volatile boolean taskCanceled;", "modifier": "private volatile", "type": "boolean", "declarator": "taskCanceled", "var_name": "taskCanceled"}, {"original_string": "private volatile boolean cleanupCalled;", "modifier": "private volatile", "type": "boolean", "declarator": "cleanupCalled", "var_name": "cleanupCalled"}], "methods": [{"identifier": "invoke", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void invoke()", "full_signature": "@Override public void invoke()", "class_method_signature": "DataSinkTask.invoke()", "testcase": false, "constructor": false}, {"identifier": "cancel", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void cancel()", "full_signature": "@Override public void cancel()", "class_method_signature": "DataSinkTask.cancel()", "testcase": false, "constructor": false}, {"identifier": "initOutputFormat", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void initOutputFormat()", "full_signature": "private void initOutputFormat()", "class_method_signature": "DataSinkTask.initOutputFormat()", "testcase": false, "constructor": false}, {"identifier": "initInputReaders", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") private", "return": "void", "signature": "void initInputReaders()", "full_signature": "@SuppressWarnings(\"unchecked\") private void initInputReaders()", "class_method_signature": "DataSinkTask.initInputReaders()", "testcase": false, "constructor": false}, {"identifier": "getLogString", "parameters": "(String message)", "modifiers": "private", "return": "String", "signature": "String getLogString(String message)", "full_signature": "private String getLogString(String message)", "class_method_signature": "DataSinkTask.getLogString(String message)", "testcase": false, "constructor": false}, {"identifier": "createRuntimeContext", "parameters": "()", "modifiers": "public", "return": "DistributedRuntimeUDFContext", "signature": "DistributedRuntimeUDFContext createRuntimeContext()", "full_signature": "public DistributedRuntimeUDFContext createRuntimeContext()", "class_method_signature": "DataSinkTask.createRuntimeContext()", "testcase": false, "constructor": false}], "file": "flink-runtime/src/main/java/org/apache/flink/runtime/operators/DataSinkTask.java"}, "focal_method": {"identifier": "invoke", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void invoke() throws Exception {\n\t\t// --------------------------------------------------------------------\n\t\t// Initialize\n\t\t// --------------------------------------------------------------------\n\t\tLOG.debug(getLogString(\"Start registering input and output\"));\n\n\t\t// initialize OutputFormat\n\t\tinitOutputFormat();\n\n\t\t// initialize input readers\n\t\ttry {\n\t\t\tinitInputReaders();\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(\"Initializing the input streams failed\" +\n\t\t\t\t\t(e.getMessage() == null ? \".\" : \": \" + e.getMessage()), e);\n\t\t}\n\n\t\tLOG.debug(getLogString(\"Finished registering input and output\"));\n\n\t\t// --------------------------------------------------------------------\n\t\t// Invoke\n\t\t// --------------------------------------------------------------------\n\t\tLOG.debug(getLogString(\"Starting data sink operator\"));\n\n\t\tif(RichOutputFormat.class.isAssignableFrom(this.format.getClass())){\n\t\t\t((RichOutputFormat) this.format).setRuntimeContext(createRuntimeContext());\n\t\t\tLOG.debug(getLogString(\"Rich Sink detected. Initializing runtime context.\"));\n\t\t}\n\n\t\tExecutionConfig executionConfig;\n\t\ttry {\n\t\t\tExecutionConfig c = InstantiationUtil.readObjectFromConfig(\n\t\t\t\t\tgetJobConfiguration(),\n\t\t\t\t\tExecutionConfig.CONFIG_KEY,\n\t\t\t\t\tgetUserCodeClassLoader());\n\t\t\tif (c != null) {\n\t\t\t\texecutionConfig = c;\n\t\t\t} else {\n\t\t\t\tLOG.warn(\"The execution config returned by the configuration was null\");\n\t\t\t\texecutionConfig = new ExecutionConfig();\n\t\t\t}\n\t\t} catch (IOException | ClassNotFoundException e) {\n\t\t\tthrow new RuntimeException(\"Could not load ExecutionConfig from Job Configuration: \" + e);\n\t\t}\n\t\tboolean objectReuseEnabled = executionConfig.isObjectReuseEnabled();\n\t\t\n\t\ttry {\n\t\t\t// initialize local strategies\n\t\t\tMutableObjectIterator<IT> input1;\n\t\t\tswitch (this.config.getInputLocalStrategy(0)) {\n\t\t\tcase NONE:\n\t\t\t\t// nothing to do\n\t\t\t\tlocalStrategy = null;\n\t\t\t\tinput1 = reader;\n\t\t\t\tbreak;\n\t\t\tcase SORT:\n\t\t\t\t// initialize sort local strategy\n\t\t\t\ttry {\n\t\t\t\t\t// get type comparator\n\t\t\t\t\tTypeComparatorFactory<IT> compFact = this.config.getInputComparator(0,\n\t\t\t\t\t\t\tgetUserCodeClassLoader());\n\t\t\t\t\tif (compFact == null) {\n\t\t\t\t\t\tthrow new Exception(\"Missing comparator factory for local strategy on input \" + 0);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// initialize sorter\n\t\t\t\t\tUnilateralSortMerger<IT> sorter = new UnilateralSortMerger<IT>(\n\t\t\t\t\t\t\tgetEnvironment().getMemoryManager(), \n\t\t\t\t\t\t\tgetEnvironment().getIOManager(),\n\t\t\t\t\t\t\tthis.reader, this, this.inputTypeSerializerFactory, compFact.createComparator(),\n\t\t\t\t\t\t\tthis.config.getRelativeMemoryInput(0), this.config.getFilehandlesInput(0),\n\t\t\t\t\t\t\tthis.config.getSpillingThresholdInput(0),\n\t\t\t\t\t\t\tthis.getExecutionConfig().isObjectReuseEnabled());\n\t\t\t\t\t\n\t\t\t\t\tthis.localStrategy = sorter;\n\t\t\t\t\tinput1 = sorter.getIterator();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new RuntimeException(\"Initializing the input processing failed\" +\n\t\t\t\t\t\t\t(e.getMessage() == null ? \".\" : \": \" + e.getMessage()), e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Invalid local strategy for DataSinkTask\");\n\t\t\t}\n\t\t\t\n\t\t\t// read the reader and write it to the output\n\t\t\t\n\t\t\tfinal TypeSerializer<IT> serializer = this.inputTypeSerializerFactory.getSerializer();\n\t\t\tfinal MutableObjectIterator<IT> input = input1;\n\t\t\tfinal OutputFormat<IT> format = this.format;\n\n\n\t\t\t// check if task has been canceled\n\t\t\tif (this.taskCanceled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLOG.debug(getLogString(\"Starting to produce output\"));\n\n\t\t\t// open\n\t\t\tformat.open(this.getEnvironment().getTaskInfo().getIndexOfThisSubtask(), this.getEnvironment().getTaskInfo().getNumberOfParallelSubtasks());\n\n\t\t\tif (objectReuseEnabled) {\n\t\t\t\tIT record = serializer.createInstance();\n\n\t\t\t\t// work!\n\t\t\t\twhile (!this.taskCanceled && ((record = input.next(record)) != null)) {\n\t\t\t\t\tformat.writeRecord(record);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tIT record;\n\n\t\t\t\t// work!\n\t\t\t\twhile (!this.taskCanceled && ((record = input.next()) != null)) {\n\t\t\t\t\tformat.writeRecord(record);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// close. We close here such that a regular close throwing an exception marks a task as failed.\n\t\t\tif (!this.taskCanceled) {\n\t\t\t\tthis.format.close();\n\t\t\t\tthis.format = null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t\n\t\t\t// make a best effort to clean up\n\t\t\ttry {\n\t\t\t\tif (!cleanupCalled && format instanceof CleanupWhenUnsuccessful) {\n\t\t\t\t\tcleanupCalled = true;\n\t\t\t\t\t((CleanupWhenUnsuccessful) format).tryCleanupOnError();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tLOG.error(\"Cleanup on error failed.\", t);\n\t\t\t}\n\t\t\t\n\t\t\tex = ExceptionInChainedStubException.exceptionUnwrap(ex);\n\n\t\t\tif (ex instanceof CancelTaskException) {\n\t\t\t\t// forward canceling exception\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\t// drop, if the task was canceled\n\t\t\telse if (!this.taskCanceled) {\n\t\t\t\tif (LOG.isErrorEnabled()) {\n\t\t\t\t\tLOG.error(getLogString(\"Error in user code: \" + ex.getMessage()), ex);\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (this.format != null) {\n\t\t\t\t// close format, if it has not been closed, yet.\n\t\t\t\t// This should only be the case if we had a previous error, or were canceled.\n\t\t\t\ttry {\n\t\t\t\t\tthis.format.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\tif (LOG.isWarnEnabled()) {\n\t\t\t\t\t\tLOG.warn(getLogString(\"Error closing the output format\"), t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// close local strategy if necessary\n\t\t\tif (localStrategy != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.localStrategy.close();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLOG.error(\"Error closing local strategy\", t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBatchTask.clearReaders(new MutableReader<?>[]{inputReader});\n\t\t}\n\n\t\tif (!this.taskCanceled) {\n\t\t\tLOG.debug(getLogString(\"Finished data sink operator\"));\n\t\t}\n\t\telse {\n\t\t\tLOG.debug(getLogString(\"Data sink operator cancelled\"));\n\t\t}\n\t}", "signature": "void invoke()", "full_signature": "@Override public void invoke()", "class_method_signature": "DataSinkTask.invoke()", "testcase": false, "constructor": false, "invocations": ["debug", "getLogString", "initOutputFormat", "initInputReaders", "getMessage", "getMessage", "debug", "getLogString", "debug", "getLogString", "isAssignableFrom", "getClass", "setRuntimeContext", "createRuntimeContext", "debug", "getLogString", "readObjectFromConfig", "getJobConfiguration", "getUserCodeClassLoader", "warn", "isObjectReuseEnabled", "getInputLocalStrategy", "getInputComparator", "getUserCodeClassLoader", "getMemoryManager", "getEnvironment", "getIOManager", "getEnvironment", "createComparator", "getRelativeMemoryInput", "getFilehandlesInput", "getSpillingThresholdInput", "isObjectReuseEnabled", "getExecutionConfig", "getIterator", "getMessage", "getMessage", "getSerializer", "debug", "getLogString", "open", "getIndexOfThisSubtask", "getTaskInfo", "getEnvironment", "getNumberOfParallelSubtasks", "getTaskInfo", "getEnvironment", "createInstance", "next", "writeRecord", "next", "writeRecord", "close", "tryCleanupOnError", "error", "exceptionUnwrap", "isErrorEnabled", "error", "getLogString", "getMessage", "close", "isWarnEnabled", "warn", "getLogString", "close", "error", "clearReaders", "debug", "getLogString", "debug", "getLogString"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}