{"test_class": {"identifier": "HeatmapProcessTest", "superclass": "", "interfaces": "", "fields": [], "file": "modules/unsupported/process-feature/src/test/java/org/geotools/process/vector/HeatmapProcessTest.java"}, "test_case": {"identifier": "testSimpleSurface", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSimpleSurface() {\n\n        ReferencedEnvelope bounds = new ReferencedEnvelope(0, 10, 0, 10, DefaultGeographicCRS.WGS84);\n        Coordinate[] data = new Coordinate[] { \n                new Coordinate(4, 4),\n                new Coordinate(4, 6),\n                // include a coordinate outside the heatmap buffer bounds, to ensure it is filtered correctly\n                new Coordinate(100, 100)\n        };\n        SimpleFeatureCollection fc = createPoints(data, bounds);\n\n        ProgressListener monitor = null;\n\n        HeatmapProcess process = new HeatmapProcess();\n        GridCoverage2D cov = process.execute(fc, // data\n                20,  //radius\n                null, // weightAttr\n                1, // pixelsPerCell\n                bounds, // outputEnv\n                100, // outputWidth\n                100, // outputHeight\n                monitor // monitor)\n        );\n        \n        // following tests are checking for an appropriate shape for the surface\n        \n        float center1 = coverageValue(cov, 4, 4);\n        float center2 = coverageValue(cov, 4, 6);\n        float midway = coverageValue(cov, 4, 5);\n        float far = coverageValue(cov, 9, 9);\n        \n        // peaks are roughly equal\n        float peakDiff = Math.abs(center1 - center2);\n        assert(peakDiff < center1 / 10);\n        \n        // dip between peaks\n        assertTrue(midway > center1 / 2);\n        \n        // surface is flat far away\n        assertTrue(far < center1 / 1000);\n\n    }", "signature": "void testSimpleSurface()", "full_signature": "@Test public void testSimpleSurface()", "class_method_signature": "HeatmapProcessTest.testSimpleSurface()", "testcase": true, "constructor": false, "invocations": ["createPoints", "execute", "coverageValue", "coverageValue", "coverageValue", "coverageValue", "abs", "assertTrue", "assertTrue"]}, "focal_class": {"identifier": "HeatmapProcess", "superclass": "", "interfaces": "implements VectorProcess", "fields": [{"original_string": "private static final double METRES_PER_DEGREE = 111320;", "modifier": "private static final", "type": "double", "declarator": "METRES_PER_DEGREE = 111320", "var_name": "METRES_PER_DEGREE"}], "methods": [{"identifier": "execute", "parameters": "(\n\n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n\n            // process parameters\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius of the density kernel in pixels\") Integer argRadiusPixels,\n            @DescribeParameter(name = \"weightAttr\", description = \"Name of the attribute to use for data point weight\", min = 0, max = 1) String valueAttr,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution at which to compute the heatmap (in pixels). Default = 1\", defaultValue=\"1\", min = 0, max = 1) Integer argPixelsPerCell,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of output raster in pixels\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of output raster in pixels\") Integer argOutputHeight,\n\n            ProgressListener monitor)", "modifiers": "@DescribeResult(name = \"result\", description = \"Output raster\") public", "return": "GridCoverage2D", "signature": "GridCoverage2D execute(\n\n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n\n            // process parameters\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius of the density kernel in pixels\") Integer argRadiusPixels,\n            @DescribeParameter(name = \"weightAttr\", description = \"Name of the attribute to use for data point weight\", min = 0, max = 1) String valueAttr,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution at which to compute the heatmap (in pixels). Default = 1\", defaultValue=\"1\", min = 0, max = 1) Integer argPixelsPerCell,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of output raster in pixels\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of output raster in pixels\") Integer argOutputHeight,\n\n            ProgressListener monitor)", "full_signature": "@DescribeResult(name = \"result\", description = \"Output raster\") public GridCoverage2D execute(\n\n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n\n            // process parameters\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius of the density kernel in pixels\") Integer argRadiusPixels,\n            @DescribeParameter(name = \"weightAttr\", description = \"Name of the attribute to use for data point weight\", min = 0, max = 1) String valueAttr,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution at which to compute the heatmap (in pixels). Default = 1\", defaultValue=\"1\", min = 0, max = 1) Integer argPixelsPerCell,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of output raster in pixels\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of output raster in pixels\") Integer argOutputHeight,\n\n            ProgressListener monitor)", "class_method_signature": "HeatmapProcess.execute(\n\n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n\n            // process parameters\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius of the density kernel in pixels\") Integer argRadiusPixels,\n            @DescribeParameter(name = \"weightAttr\", description = \"Name of the attribute to use for data point weight\", min = 0, max = 1) String valueAttr,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution at which to compute the heatmap (in pixels). Default = 1\", defaultValue=\"1\", min = 0, max = 1) Integer argPixelsPerCell,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of output raster in pixels\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of output raster in pixels\") Integer argOutputHeight,\n\n            ProgressListener monitor)", "testcase": false, "constructor": false}, {"identifier": "distanceConversionFactor", "parameters": "(CoordinateReferenceSystem srcCRS,\n            CoordinateReferenceSystem dstCRS)", "modifiers": "private static", "return": "double", "signature": "double distanceConversionFactor(CoordinateReferenceSystem srcCRS,\n            CoordinateReferenceSystem dstCRS)", "full_signature": "private static double distanceConversionFactor(CoordinateReferenceSystem srcCRS,\n            CoordinateReferenceSystem dstCRS)", "class_method_signature": "HeatmapProcess.distanceConversionFactor(CoordinateReferenceSystem srcCRS,\n            CoordinateReferenceSystem dstCRS)", "testcase": false, "constructor": false}, {"identifier": "flipXY", "parameters": "(float[][] grid)", "modifiers": "private", "return": "float[][]", "signature": "float[][] flipXY(float[][] grid)", "full_signature": "private float[][] flipXY(float[][] grid)", "class_method_signature": "HeatmapProcess.flipXY(float[][] grid)", "testcase": false, "constructor": false}, {"identifier": "upsample", "parameters": "(float[][] grid, float noDataValue, int width, int height)", "modifiers": "private", "return": "float[][]", "signature": "float[][] upsample(float[][] grid, float noDataValue, int width, int height)", "full_signature": "private float[][] upsample(float[][] grid, float noDataValue, int width, int height)", "class_method_signature": "HeatmapProcess.upsample(float[][] grid, float noDataValue, int width, int height)", "testcase": false, "constructor": false}, {"identifier": "invertQuery", "parameters": "(\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius to use for the kernel\", min = 0, max = 1) Integer argRadiusPixels,\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Georeferenced bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster\") Integer argOutputHeight,\n\n            Query targetQuery, GridGeometry targetGridGeometry)", "modifiers": "public", "return": "Query", "signature": "Query invertQuery(\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius to use for the kernel\", min = 0, max = 1) Integer argRadiusPixels,\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Georeferenced bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster\") Integer argOutputHeight,\n\n            Query targetQuery, GridGeometry targetGridGeometry)", "full_signature": "public Query invertQuery(\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius to use for the kernel\", min = 0, max = 1) Integer argRadiusPixels,\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Georeferenced bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster\") Integer argOutputHeight,\n\n            Query targetQuery, GridGeometry targetGridGeometry)", "class_method_signature": "HeatmapProcess.invertQuery(\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius to use for the kernel\", min = 0, max = 1) Integer argRadiusPixels,\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Georeferenced bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of the output raster\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of the output raster\") Integer argOutputHeight,\n\n            Query targetQuery, GridGeometry targetGridGeometry)", "testcase": false, "constructor": false}, {"identifier": "pixelSize", "parameters": "(ReferencedEnvelope outputEnv, int outputWidth, int outputHeight)", "modifiers": "private", "return": "double", "signature": "double pixelSize(ReferencedEnvelope outputEnv, int outputWidth, int outputHeight)", "full_signature": "private double pixelSize(ReferencedEnvelope outputEnv, int outputWidth, int outputHeight)", "class_method_signature": "HeatmapProcess.pixelSize(ReferencedEnvelope outputEnv, int outputWidth, int outputHeight)", "testcase": false, "constructor": false}, {"identifier": "expandBBox", "parameters": "(Filter filter, double distance)", "modifiers": "private", "return": "Filter", "signature": "Filter expandBBox(Filter filter, double distance)", "full_signature": "private Filter expandBBox(Filter filter, double distance)", "class_method_signature": "HeatmapProcess.expandBBox(Filter filter, double distance)", "testcase": false, "constructor": false}, {"identifier": "extractPoints", "parameters": "(SimpleFeatureCollection obsPoints, String attrName,\n            MathTransform trans, HeatmapSurface heatMap)", "modifiers": "public static", "return": "void", "signature": "void extractPoints(SimpleFeatureCollection obsPoints, String attrName,\n            MathTransform trans, HeatmapSurface heatMap)", "full_signature": "public static void extractPoints(SimpleFeatureCollection obsPoints, String attrName,\n            MathTransform trans, HeatmapSurface heatMap)", "class_method_signature": "HeatmapProcess.extractPoints(SimpleFeatureCollection obsPoints, String attrName,\n            MathTransform trans, HeatmapSurface heatMap)", "testcase": false, "constructor": false}, {"identifier": "getPoint", "parameters": "(Geometry g)", "modifiers": "private static", "return": "Coordinate", "signature": "Coordinate getPoint(Geometry g)", "full_signature": "private static Coordinate getPoint(Geometry g)", "class_method_signature": "HeatmapProcess.getPoint(Geometry g)", "testcase": false, "constructor": false}, {"identifier": "getPointValue", "parameters": "(SimpleFeature feature, Expression attrExpr)", "modifiers": "private static", "return": "double", "signature": "double getPointValue(SimpleFeature feature, Expression attrExpr)", "full_signature": "private static double getPointValue(SimpleFeature feature, Expression attrExpr)", "class_method_signature": "HeatmapProcess.getPointValue(SimpleFeature feature, Expression attrExpr)", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/HeatmapProcess.java"}, "focal_method": {"identifier": "execute", "parameters": "(\n\n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n\n            // process parameters\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius of the density kernel in pixels\") Integer argRadiusPixels,\n            @DescribeParameter(name = \"weightAttr\", description = \"Name of the attribute to use for data point weight\", min = 0, max = 1) String valueAttr,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution at which to compute the heatmap (in pixels). Default = 1\", defaultValue=\"1\", min = 0, max = 1) Integer argPixelsPerCell,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of output raster in pixels\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of output raster in pixels\") Integer argOutputHeight,\n\n            ProgressListener monitor)", "modifiers": "@DescribeResult(name = \"result\", description = \"Output raster\") public", "return": "GridCoverage2D", "body": "@DescribeResult(name = \"result\", description = \"Output raster\")\n    public GridCoverage2D execute(\n\n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n\n            // process parameters\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius of the density kernel in pixels\") Integer argRadiusPixels,\n            @DescribeParameter(name = \"weightAttr\", description = \"Name of the attribute to use for data point weight\", min = 0, max = 1) String valueAttr,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution at which to compute the heatmap (in pixels). Default = 1\", defaultValue=\"1\", min = 0, max = 1) Integer argPixelsPerCell,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of output raster in pixels\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of output raster in pixels\") Integer argOutputHeight,\n\n            ProgressListener monitor) throws ProcessException {\n\n        /**\n         * -------- Extract required information from process arguments -------------\n         */\n        int pixelsPerCell = 1;\n        if (argPixelsPerCell != null && argPixelsPerCell > 1) {\n            pixelsPerCell = argPixelsPerCell;\n        }\n        int outputWidth = argOutputWidth;\n        int outputHeight = argOutputHeight;\n        int gridWidth = outputWidth;\n        int gridHeight = outputHeight;\n        if (pixelsPerCell > 1) {\n            gridWidth = outputWidth / pixelsPerCell;\n            gridHeight = outputHeight / pixelsPerCell;\n        }\n\n        /**\n         * Compute transform to convert input coords into output CRS\n         */\n        CoordinateReferenceSystem srcCRS = obsFeatures.getSchema().getCoordinateReferenceSystem();\n        CoordinateReferenceSystem dstCRS = argOutputEnv.getCoordinateReferenceSystem();\n        MathTransform trans = null;\n        try {\n            trans = CRS.findMathTransform(srcCRS, dstCRS);\n        } catch (FactoryException e) {\n            throw new ProcessException(e);\n        }\n\n        //------------ Kernel Radius\n        /*\n         * // not used for now - only pixel radius values are supported double\n         * distanceConversionFactor = distanceConversionFactor(srcCRS, dstCRS); double dstRadius =\n         * argRadius * distanceConversionFactor;\n         */\n        int radiusCells = 100;\n        if (argRadiusPixels != null)\n            radiusCells = argRadiusPixels;\n        if (pixelsPerCell > 1) {\n            radiusCells /= pixelsPerCell;\n        }\n\n\n        /**\n         * -------------- Extract the input observation points -----------\n         */\n        HeatmapSurface heatMap = new HeatmapSurface(radiusCells, argOutputEnv, gridWidth,\n                gridHeight);\n        try {\n            extractPoints(obsFeatures, valueAttr, trans, heatMap);\n        } catch (CQLException e) {\n            throw new ProcessException(e);\n        }\n\n        /**\n         * --------------- Do the processing ------------------------------\n         */\n        // Stopwatch sw = new Stopwatch();\n        // compute the heatmap at the specified resolution\n        float[][] heatMapGrid = heatMap.computeSurface();\n\n        // flip now, since grid size may be smaller\n        heatMapGrid = flipXY(heatMapGrid);\n\n        // upsample to output resolution if necessary\n        float[][] outGrid = heatMapGrid;\n        if (pixelsPerCell > 1)\n            outGrid = upsample(heatMapGrid, -999, outputWidth, outputHeight);\n\n        // convert to the GridCoverage2D required for output\n        GridCoverageFactory gcf = CoverageFactoryFinder.getGridCoverageFactory(GeoTools.getDefaultHints());\n        GridCoverage2D gridCov = gcf.create(\"Process Results\", outGrid, argOutputEnv);\n\n        // System.out.println(\"**************  Heatmap computed in \" + sw.getTimeString());\n\n        return gridCov;\n    }", "signature": "GridCoverage2D execute(\n\n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n\n            // process parameters\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius of the density kernel in pixels\") Integer argRadiusPixels,\n            @DescribeParameter(name = \"weightAttr\", description = \"Name of the attribute to use for data point weight\", min = 0, max = 1) String valueAttr,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution at which to compute the heatmap (in pixels). Default = 1\", defaultValue=\"1\", min = 0, max = 1) Integer argPixelsPerCell,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of output raster in pixels\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of output raster in pixels\") Integer argOutputHeight,\n\n            ProgressListener monitor)", "full_signature": "@DescribeResult(name = \"result\", description = \"Output raster\") public GridCoverage2D execute(\n\n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n\n            // process parameters\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius of the density kernel in pixels\") Integer argRadiusPixels,\n            @DescribeParameter(name = \"weightAttr\", description = \"Name of the attribute to use for data point weight\", min = 0, max = 1) String valueAttr,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution at which to compute the heatmap (in pixels). Default = 1\", defaultValue=\"1\", min = 0, max = 1) Integer argPixelsPerCell,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of output raster in pixels\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of output raster in pixels\") Integer argOutputHeight,\n\n            ProgressListener monitor)", "class_method_signature": "HeatmapProcess.execute(\n\n            // process data\n            @DescribeParameter(name = \"data\", description = \"Input features\") SimpleFeatureCollection obsFeatures,\n\n            // process parameters\n            @DescribeParameter(name = \"radiusPixels\", description = \"Radius of the density kernel in pixels\") Integer argRadiusPixels,\n            @DescribeParameter(name = \"weightAttr\", description = \"Name of the attribute to use for data point weight\", min = 0, max = 1) String valueAttr,\n            @DescribeParameter(name = \"pixelsPerCell\", description = \"Resolution at which to compute the heatmap (in pixels). Default = 1\", defaultValue=\"1\", min = 0, max = 1) Integer argPixelsPerCell,\n\n            // output image parameters\n            @DescribeParameter(name = \"outputBBOX\", description = \"Bounding box of the output\") ReferencedEnvelope argOutputEnv,\n            @DescribeParameter(name = \"outputWidth\", description = \"Width of output raster in pixels\") Integer argOutputWidth,\n            @DescribeParameter(name = \"outputHeight\", description = \"Height of output raster in pixels\") Integer argOutputHeight,\n\n            ProgressListener monitor)", "testcase": false, "constructor": false, "invocations": ["getCoordinateReferenceSystem", "getSchema", "getCoordinateReferenceSystem", "findMathTransform", "extractPoints", "computeSurface", "flipXY", "upsample", "getGridCoverageFactory", "getDefaultHints", "create"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}