{"test_class": {"identifier": "SenderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int MAX_REQUEST_SIZE = 1024 * 1024;", "modifier": "private static final", "type": "int", "declarator": "MAX_REQUEST_SIZE = 1024 * 1024", "var_name": "MAX_REQUEST_SIZE"}, {"original_string": "private static final short ACKS_ALL = -1;", "modifier": "private static final", "type": "short", "declarator": "ACKS_ALL = -1", "var_name": "ACKS_ALL"}, {"original_string": "private static final int MAX_RETRIES = 0;", "modifier": "private static final", "type": "int", "declarator": "MAX_RETRIES = 0", "var_name": "MAX_RETRIES"}, {"original_string": "private static final String CLIENT_ID = \"clientId\";", "modifier": "private static final", "type": "String", "declarator": "CLIENT_ID = \"clientId\"", "var_name": "CLIENT_ID"}, {"original_string": "private static final String METRIC_GROUP = \"producer-metrics\";", "modifier": "private static final", "type": "String", "declarator": "METRIC_GROUP = \"producer-metrics\"", "var_name": "METRIC_GROUP"}, {"original_string": "private static final double EPS = 0.0001;", "modifier": "private static final", "type": "double", "declarator": "EPS = 0.0001", "var_name": "EPS"}, {"original_string": "private static final int MAX_BLOCK_TIMEOUT = 1000;", "modifier": "private static final", "type": "int", "declarator": "MAX_BLOCK_TIMEOUT = 1000", "var_name": "MAX_BLOCK_TIMEOUT"}, {"original_string": "private static final int REQUEST_TIMEOUT = 1000;", "modifier": "private static final", "type": "int", "declarator": "REQUEST_TIMEOUT = 1000", "var_name": "REQUEST_TIMEOUT"}, {"original_string": "private TopicPartition tp = new TopicPartition(\"test\", 0);", "modifier": "private", "type": "TopicPartition", "declarator": "tp = new TopicPartition(\"test\", 0)", "var_name": "tp"}, {"original_string": "private MockTime time = new MockTime();", "modifier": "private", "type": "MockTime", "declarator": "time = new MockTime()", "var_name": "time"}, {"original_string": "private MockClient client = new MockClient(time);", "modifier": "private", "type": "MockClient", "declarator": "client = new MockClient(time)", "var_name": "client"}, {"original_string": "private int batchSize = 16 * 1024;", "modifier": "private", "type": "int", "declarator": "batchSize = 16 * 1024", "var_name": "batchSize"}, {"original_string": "private Metadata metadata = new Metadata(0, Long.MAX_VALUE);", "modifier": "private", "type": "Metadata", "declarator": "metadata = new Metadata(0, Long.MAX_VALUE)", "var_name": "metadata"}, {"original_string": "private Cluster cluster = TestUtils.singletonCluster(\"test\", 1);", "modifier": "private", "type": "Cluster", "declarator": "cluster = TestUtils.singletonCluster(\"test\", 1)", "var_name": "cluster"}, {"original_string": "private Metrics metrics = null;", "modifier": "private", "type": "Metrics", "declarator": "metrics = null", "var_name": "metrics"}, {"original_string": "private RecordAccumulator accumulator = null;", "modifier": "private", "type": "RecordAccumulator", "declarator": "accumulator = null", "var_name": "accumulator"}, {"original_string": "private Sender sender = null;", "modifier": "private", "type": "Sender", "declarator": "sender = null", "var_name": "sender"}], "file": "clients/src/test/java/org/apache/kafka/clients/producer/internals/SenderTest.java"}, "test_case": {"identifier": "testRetries", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRetries() throws Exception {\n        // create a sender with retries = 1\n        int maxRetries = 1;\n        Metrics m = new Metrics();\n        try {\n            Sender sender = new Sender(client,\n                                       metadata,\n                                       this.accumulator,\n                                       false,\n                                       MAX_REQUEST_SIZE,\n                                       ACKS_ALL,\n                                       maxRetries,\n                                       m,\n                                       time,\n                                       \"clientId\",\n                                       REQUEST_TIMEOUT);\n            // do a successful retry\n            Future<RecordMetadata> future = accumulator.append(tp, 0L, \"key\".getBytes(), \"value\".getBytes(), null, MAX_BLOCK_TIMEOUT).future;\n            sender.run(time.milliseconds()); // connect\n            sender.run(time.milliseconds()); // send produce request\n            String id = client.requests().peek().request().destination();\n            Node node = new Node(Integer.valueOf(id), \"localhost\", 0);\n            assertEquals(1, client.inFlightRequestCount());\n            assertTrue(\"Client ready status should be true\", client.isReady(node, 0L));\n            client.disconnect(id);\n            assertEquals(0, client.inFlightRequestCount());\n            assertFalse(\"Client ready status should be false\", client.isReady(node, 0L));\n            sender.run(time.milliseconds()); // receive error\n            sender.run(time.milliseconds()); // reconnect\n            sender.run(time.milliseconds()); // resend\n            assertEquals(1, client.inFlightRequestCount());\n            long offset = 0;\n            client.respond(produceResponse(tp, offset, Errors.NONE.code(), 0));\n            sender.run(time.milliseconds());\n            assertTrue(\"Request should have retried and completed\", future.isDone());\n            assertEquals(offset, future.get().offset());\n\n            // do an unsuccessful retry\n            future = accumulator.append(tp, 0L, \"key\".getBytes(), \"value\".getBytes(), null, MAX_BLOCK_TIMEOUT).future;\n            sender.run(time.milliseconds()); // send produce request\n            for (int i = 0; i < maxRetries + 1; i++) {\n                client.disconnect(client.requests().peek().request().destination());\n                sender.run(time.milliseconds()); // receive error\n                sender.run(time.milliseconds()); // reconnect\n                sender.run(time.milliseconds()); // resend\n            }\n            sender.run(time.milliseconds());\n            completedWithError(future, Errors.NETWORK_EXCEPTION);\n        } finally {\n            m.close();\n        }\n    }", "signature": "void testRetries()", "full_signature": "@Test public void testRetries()", "class_method_signature": "SenderTest.testRetries()", "testcase": true, "constructor": false, "invocations": ["append", "getBytes", "getBytes", "run", "milliseconds", "run", "milliseconds", "destination", "request", "peek", "requests", "valueOf", "assertEquals", "inFlightRequestCount", "assertTrue", "isReady", "disconnect", "assertEquals", "inFlightRequestCount", "assertFalse", "isReady", "run", "milliseconds", "run", "milliseconds", "run", "milliseconds", "assertEquals", "inFlightRequestCount", "respond", "produceResponse", "code", "run", "milliseconds", "assertTrue", "isDone", "assertEquals", "offset", "get", "append", "getBytes", "getBytes", "run", "milliseconds", "disconnect", "destination", "request", "peek", "requests", "run", "milliseconds", "run", "milliseconds", "run", "milliseconds", "run", "milliseconds", "completedWithError", "close"]}, "focal_class": {"identifier": "Sender", "superclass": "", "interfaces": "implements Runnable", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(Sender.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(Sender.class)", "var_name": "log"}, {"original_string": "private final KafkaClient client;", "modifier": "private final", "type": "KafkaClient", "declarator": "client", "var_name": "client"}, {"original_string": "private final RecordAccumulator accumulator;", "modifier": "private final", "type": "RecordAccumulator", "declarator": "accumulator", "var_name": "accumulator"}, {"original_string": "private final Metadata metadata;", "modifier": "private final", "type": "Metadata", "declarator": "metadata", "var_name": "metadata"}, {"original_string": "private final boolean guaranteeMessageOrder;", "modifier": "private final", "type": "boolean", "declarator": "guaranteeMessageOrder", "var_name": "guaranteeMessageOrder"}, {"original_string": "private final int maxRequestSize;", "modifier": "private final", "type": "int", "declarator": "maxRequestSize", "var_name": "maxRequestSize"}, {"original_string": "private final short acks;", "modifier": "private final", "type": "short", "declarator": "acks", "var_name": "acks"}, {"original_string": "private final int retries;", "modifier": "private final", "type": "int", "declarator": "retries", "var_name": "retries"}, {"original_string": "private final Time time;", "modifier": "private final", "type": "Time", "declarator": "time", "var_name": "time"}, {"original_string": "private volatile boolean running;", "modifier": "private volatile", "type": "boolean", "declarator": "running", "var_name": "running"}, {"original_string": "private volatile boolean forceClose;", "modifier": "private volatile", "type": "boolean", "declarator": "forceClose", "var_name": "forceClose"}, {"original_string": "private final SenderMetrics sensors;", "modifier": "private final", "type": "SenderMetrics", "declarator": "sensors", "var_name": "sensors"}, {"original_string": "private String clientId;", "modifier": "private", "type": "String", "declarator": "clientId", "var_name": "clientId"}, {"original_string": "private final int requestTimeout;", "modifier": "private final", "type": "int", "declarator": "requestTimeout", "var_name": "requestTimeout"}], "methods": [{"identifier": "Sender", "parameters": "(KafkaClient client,\n        Metadata metadata,\n        RecordAccumulator accumulator,\n        boolean guaranteeMessageOrder,\n        int maxRequestSize,\n        short acks,\n        int retries,\n        Metrics metrics,\n        Time time,\n        String clientId,\n        int requestTimeout)", "modifiers": "public", "return": "", "signature": " Sender(KafkaClient client,\n        Metadata metadata,\n        RecordAccumulator accumulator,\n        boolean guaranteeMessageOrder,\n        int maxRequestSize,\n        short acks,\n        int retries,\n        Metrics metrics,\n        Time time,\n        String clientId,\n        int requestTimeout)", "full_signature": "public  Sender(KafkaClient client,\n        Metadata metadata,\n        RecordAccumulator accumulator,\n        boolean guaranteeMessageOrder,\n        int maxRequestSize,\n        short acks,\n        int retries,\n        Metrics metrics,\n        Time time,\n        String clientId,\n        int requestTimeout)", "class_method_signature": "Sender.Sender(KafkaClient client,\n        Metadata metadata,\n        RecordAccumulator accumulator,\n        boolean guaranteeMessageOrder,\n        int maxRequestSize,\n        short acks,\n        int retries,\n        Metrics metrics,\n        Time time,\n        String clientId,\n        int requestTimeout)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void run()", "full_signature": "public void run()", "class_method_signature": "Sender.run()", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "(long now)", "modifiers": "", "return": "void", "signature": "void run(long now)", "full_signature": " void run(long now)", "class_method_signature": "Sender.run(long now)", "testcase": false, "constructor": false}, {"identifier": "initiateClose", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void initiateClose()", "full_signature": "public void initiateClose()", "class_method_signature": "Sender.initiateClose()", "testcase": false, "constructor": false}, {"identifier": "forceClose", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void forceClose()", "full_signature": "public void forceClose()", "class_method_signature": "Sender.forceClose()", "testcase": false, "constructor": false}, {"identifier": "handleProduceResponse", "parameters": "(ClientResponse response, Map<TopicPartition, RecordBatch> batches, long now)", "modifiers": "private", "return": "void", "signature": "void handleProduceResponse(ClientResponse response, Map<TopicPartition, RecordBatch> batches, long now)", "full_signature": "private void handleProduceResponse(ClientResponse response, Map<TopicPartition, RecordBatch> batches, long now)", "class_method_signature": "Sender.handleProduceResponse(ClientResponse response, Map<TopicPartition, RecordBatch> batches, long now)", "testcase": false, "constructor": false}, {"identifier": "completeBatch", "parameters": "(RecordBatch batch, Errors error, long baseOffset, long timestamp, long correlationId, long now)", "modifiers": "private", "return": "void", "signature": "void completeBatch(RecordBatch batch, Errors error, long baseOffset, long timestamp, long correlationId, long now)", "full_signature": "private void completeBatch(RecordBatch batch, Errors error, long baseOffset, long timestamp, long correlationId, long now)", "class_method_signature": "Sender.completeBatch(RecordBatch batch, Errors error, long baseOffset, long timestamp, long correlationId, long now)", "testcase": false, "constructor": false}, {"identifier": "canRetry", "parameters": "(RecordBatch batch, Errors error)", "modifiers": "private", "return": "boolean", "signature": "boolean canRetry(RecordBatch batch, Errors error)", "full_signature": "private boolean canRetry(RecordBatch batch, Errors error)", "class_method_signature": "Sender.canRetry(RecordBatch batch, Errors error)", "testcase": false, "constructor": false}, {"identifier": "createProduceRequests", "parameters": "(Map<Integer/* nodeId */, List<RecordBatch>> collated, long now)", "modifiers": "private", "return": "List<ClientRequest>", "signature": "List<ClientRequest> createProduceRequests(Map<Integer/* nodeId */, List<RecordBatch>> collated, long now)", "full_signature": "private List<ClientRequest> createProduceRequests(Map<Integer/* nodeId */, List<RecordBatch>> collated, long now)", "class_method_signature": "Sender.createProduceRequests(Map<Integer/* nodeId */, List<RecordBatch>> collated, long now)", "testcase": false, "constructor": false}, {"identifier": "produceRequest", "parameters": "(long now, int destination, short acks, int timeout, List<RecordBatch> batches)", "modifiers": "private", "return": "ClientRequest", "signature": "ClientRequest produceRequest(long now, int destination, short acks, int timeout, List<RecordBatch> batches)", "full_signature": "private ClientRequest produceRequest(long now, int destination, short acks, int timeout, List<RecordBatch> batches)", "class_method_signature": "Sender.produceRequest(long now, int destination, short acks, int timeout, List<RecordBatch> batches)", "testcase": false, "constructor": false}, {"identifier": "wakeup", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void wakeup()", "full_signature": "public void wakeup()", "class_method_signature": "Sender.wakeup()", "testcase": false, "constructor": false}], "file": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java"}, "focal_method": {"identifier": "run", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void run() {\n        log.debug(\"Starting Kafka producer I/O thread.\");\n\n        // main loop, runs until close is called\n        while (running) {\n            try {\n                run(time.milliseconds());\n            } catch (Exception e) {\n                log.error(\"Uncaught error in kafka producer I/O thread: \", e);\n            }\n        }\n\n        log.debug(\"Beginning shutdown of Kafka producer I/O thread, sending remaining records.\");\n\n        // okay we stopped accepting requests but there may still be\n        // requests in the accumulator or waiting for acknowledgment,\n        // wait until these are completed.\n        while (!forceClose && (this.accumulator.hasUnsent() || this.client.inFlightRequestCount() > 0)) {\n            try {\n                run(time.milliseconds());\n            } catch (Exception e) {\n                log.error(\"Uncaught error in kafka producer I/O thread: \", e);\n            }\n        }\n        if (forceClose) {\n            // We need to fail all the incomplete batches and wake up the threads waiting on\n            // the futures.\n            this.accumulator.abortIncompleteBatches();\n        }\n        try {\n            this.client.close();\n        } catch (Exception e) {\n            log.error(\"Failed to close network client\", e);\n        }\n\n        log.debug(\"Shutdown of Kafka producer I/O thread has completed.\");\n    }", "signature": "void run()", "full_signature": "public void run()", "class_method_signature": "Sender.run()", "testcase": false, "constructor": false, "invocations": ["debug", "run", "milliseconds", "error", "debug", "hasUnsent", "inFlightRequestCount", "run", "milliseconds", "error", "abortIncompleteBatches", "close", "error", "debug"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}