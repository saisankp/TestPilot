{"test_class": {"identifier": "CpuThreadCountDataSeriesTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final FakeTransportService myTransportService = new FakeTransportService(new FakeTimer(), false);", "modifier": "private final", "type": "FakeTransportService", "declarator": "myTransportService = new FakeTransportService(new FakeTimer(), false)", "var_name": "myTransportService"}, {"original_string": "@Rule\n  public FakeGrpcChannel myGrpcChannel =\n    new FakeGrpcChannel(\"CpuThreadCountDataSeriesTest\", new FakeCpuService(), myTransportService);", "modifier": "@Rule\n  public", "type": "FakeGrpcChannel", "declarator": "myGrpcChannel =\n    new FakeGrpcChannel(\"CpuThreadCountDataSeriesTest\", new FakeCpuService(), myTransportService)", "var_name": "myGrpcChannel"}, {"original_string": "private boolean myIsUnifiedPipeline;", "modifier": "private", "type": "boolean", "declarator": "myIsUnifiedPipeline", "var_name": "myIsUnifiedPipeline"}, {"original_string": "private DataSeries<Long> myDataSeries;", "modifier": "private", "type": "DataSeries<Long>", "declarator": "myDataSeries", "var_name": "myDataSeries"}], "file": "profilers/testSrc/com/android/tools/profilers/cpu/CpuThreadCountDataSeriesTest.java"}, "test_case": {"identifier": "threadDiesBeforeRangeMax", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void threadDiesBeforeRangeMax() {\n    Range range = new Range(TimeUnit.SECONDS.toMicros(10), TimeUnit.SECONDS.toMicros(20));\n    List<SeriesData<Long>> seriesDataList = myDataSeries.getDataForRange(range);\n    assertEquals(3, seriesDataList.size());\n\n    // Threads count by thread2 state change to RUNNING\n    SeriesData<Long> seriesData = seriesDataList.get(0);\n    Objects.requireNonNull(seriesData);\n    // In the new pipeline, we only return the -1 thread state, so the timestamp of that event is 8 instead of the first thread state\n    // activity at t = 6.\n    long timestamp = myIsUnifiedPipeline ? TimeUnit.SECONDS.toMicros(8) : TimeUnit.SECONDS.toMicros(6);\n    assertEquals(timestamp, seriesData.x, 0);\n    assertEquals(1, (long)seriesData.value); // thread2 is alive\n\n    // Threads count by thread2 state change to DEAD\n    seriesData = seriesDataList.get(1);\n    Objects.requireNonNull(seriesData);\n    assertEquals(TimeUnit.SECONDS.toMicros(15), seriesData.x, 0);\n    assertEquals(0, (long)seriesData.value); // thread2 is dead now\n\n    // Threads count by range.getMax(). This value is added when range.getMax()\n    // is greater than the timestamp of the thread state change to DEAD\n    seriesData = seriesDataList.get(2);\n    Objects.requireNonNull(seriesData);\n    assertEquals(range.getMax(), seriesData.x, 0);\n    assertEquals(0, (long)seriesData.value); // thread2 is still dead\n  }", "signature": "void threadDiesBeforeRangeMax()", "full_signature": "@Test public void threadDiesBeforeRangeMax()", "class_method_signature": "CpuThreadCountDataSeriesTest.threadDiesBeforeRangeMax()", "testcase": true, "constructor": false, "invocations": ["toMicros", "toMicros", "getDataForRange", "assertEquals", "size", "get", "requireNonNull", "toMicros", "toMicros", "assertEquals", "assertEquals", "get", "requireNonNull", "assertEquals", "toMicros", "assertEquals", "get", "requireNonNull", "assertEquals", "getMax", "assertEquals"]}, "focal_class": {"identifier": "CpuThreadCountDataSeries", "superclass": "", "interfaces": "implements DataSeries<Long>", "fields": [{"original_string": "@NotNull private final TransportServiceGrpc.TransportServiceBlockingStub myClient;", "modifier": "@NotNull private final", "type": "TransportServiceGrpc.TransportServiceBlockingStub", "declarator": "myClient", "var_name": "myClient"}, {"original_string": "private final long myStreamId;", "modifier": "private final", "type": "long", "declarator": "myStreamId", "var_name": "myStreamId"}, {"original_string": "private final int myPid;", "modifier": "private final", "type": "int", "declarator": "myPid", "var_name": "myPid"}], "methods": [{"identifier": "CpuThreadCountDataSeries", "parameters": "(@NotNull TransportServiceGrpc.TransportServiceBlockingStub client, long streamId, int pid)", "modifiers": "public", "return": "", "signature": " CpuThreadCountDataSeries(@NotNull TransportServiceGrpc.TransportServiceBlockingStub client, long streamId, int pid)", "full_signature": "public  CpuThreadCountDataSeries(@NotNull TransportServiceGrpc.TransportServiceBlockingStub client, long streamId, int pid)", "class_method_signature": "CpuThreadCountDataSeries.CpuThreadCountDataSeries(@NotNull TransportServiceGrpc.TransportServiceBlockingStub client, long streamId, int pid)", "testcase": false, "constructor": true}, {"identifier": "getDataForRange", "parameters": "(Range rangeUs)", "modifiers": "@Override public", "return": "List<SeriesData<Long>>", "signature": "List<SeriesData<Long>> getDataForRange(Range rangeUs)", "full_signature": "@Override public List<SeriesData<Long>> getDataForRange(Range rangeUs)", "class_method_signature": "CpuThreadCountDataSeries.getDataForRange(Range rangeUs)", "testcase": false, "constructor": false}], "file": "profilers/src/com/android/tools/profilers/cpu/CpuThreadCountDataSeries.java"}, "focal_method": {"identifier": "getDataForRange", "parameters": "(Range rangeUs)", "modifiers": "@Override public", "return": "List<SeriesData<Long>>", "body": "@Override\n  public List<SeriesData<Long>> getDataForRange(Range rangeUs) {\n    long minNs = TimeUnit.MICROSECONDS.toNanos((long)rangeUs.getMin());\n    long maxNs = TimeUnit.MICROSECONDS.toNanos((long)rangeUs.getMax());\n\n    GetEventGroupsRequest request = GetEventGroupsRequest.newBuilder()\n      .setStreamId(myStreamId)\n      .setPid(myPid)\n      .setKind(Common.Event.Kind.CPU_THREAD)\n      .setFromTimestamp(minNs)\n      .setToTimestamp(maxNs)\n      .build();\n    GetEventGroupsResponse response = myClient.getEventGroups(request);\n\n    // Count the first and last events of a thread by timestamp. If the event is terminal, use -1 towards the count to offset the summing\n    // phase later.\n    //\n    // Threads states:\n    // +: non terminal\n    // @: terminal\n    // Timestamp    0  1  2  3  4  5\n    // Thread 1        +-----@\n    // Thread 2           +-----+--@\n    // First Pass   x  1  1 -1  x -1\n    // Total Count  0  1  2  1  1  0\n    TreeMap<Long, Long> timestampToCountMap = new TreeMap<>();\n    for (Transport.EventGroup group : response.getGroupsList()) {\n      if (group.getEventsCount() > 0) {\n        Common.Event first = group.getEvents(0);\n        Common.Event last = group.getEvents(group.getEventsCount() - 1);\n        timestampToCountMap.compute(first.getTimestamp(), (timestamp, count) -> count == null ? 1 : count + 1);\n        if (last.getIsEnded()) {\n          timestampToCountMap.compute(last.getTimestamp(), (timestamp, count) -> count == null ? -1 : count - 1);\n        }\n      }\n    }\n    List<SeriesData<Long>> data = new ArrayList<>();\n    long total = 0;\n    for (Map.Entry<Long, Long> entry : timestampToCountMap.entrySet()) {\n      total += entry.getValue();\n      data.add(new SeriesData<>(TimeUnit.NANOSECONDS.toMicros(entry.getKey()), total));\n    }\n\n    // When no threads are found within the requested range, we add the threads count (0)\n    // to both range's min and max. Otherwise we wouldn't add any information to the data series\n    // within timeCurrentRangeUs and nothing would be added to the chart.\n    if (timestampToCountMap.isEmpty()) {\n      data.add(new SeriesData<>((long)rangeUs.getMin(), total));\n      data.add(new SeriesData<>((long)rangeUs.getMax(), total));\n    }\n    // If the last timestamp added to the data series is less than timeCurrentRangeUs.getMax(),\n    // we need to replicate the last value in timeCurrentRangeUs.getMax(), so the chart renders this value\n    // until the end of the selected range.\n    else if (data.get(data.size() - 1).x < rangeUs.getMax()) {\n      data.add(new SeriesData<>((long)rangeUs.getMax(), total));\n    }\n\n    return data;\n  }", "signature": "List<SeriesData<Long>> getDataForRange(Range rangeUs)", "full_signature": "@Override public List<SeriesData<Long>> getDataForRange(Range rangeUs)", "class_method_signature": "CpuThreadCountDataSeries.getDataForRange(Range rangeUs)", "testcase": false, "constructor": false, "invocations": ["toNanos", "getMin", "toNanos", "getMax", "build", "setToTimestamp", "setFromTimestamp", "setKind", "setPid", "setStreamId", "newBuilder", "getEventGroups", "getGroupsList", "getEventsCount", "getEvents", "getEvents", "getEventsCount", "compute", "getTimestamp", "getIsEnded", "compute", "getTimestamp", "entrySet", "getValue", "add", "toMicros", "getKey", "isEmpty", "add", "getMin", "add", "getMax", "get", "size", "getMax", "add", "getMax"]}, "repository": {"repo_id": 60701247, "url": "https://github.com/JetBrains/android", "stars": 486, "created": "6/8/2016 1:46:48 PM +00:00", "updates": "2020-01-27T16:45:40+00:00", "fork": "False", "license": "licensed"}}