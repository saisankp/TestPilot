{"test_class": {"identifier": "BondRefinableTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static IChemObjectBuilder builder = SilentChemObjectBuilder.getInstance();", "modifier": "public static", "type": "IChemObjectBuilder", "declarator": "builder = SilentChemObjectBuilder.getInstance()", "var_name": "builder"}], "file": "tool/group/src/test/java/org/openscience/cdk/group/BondRefinableTest.java"}, "test_case": {"identifier": "getBondPartitionTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void getBondPartitionTest() {\n        String acpString = \"C0C1C2C3O4 0:1(2),0:4(1),1:2(1),2:3(2),3:4(1)\";\n        IAtomContainer ac = AtomContainerPrinter.fromString(acpString, builder);\n        BondRefinable refinable = new BondRefinable(ac);\n        Partition bondPartition = refinable.getInitialPartition();\n        Partition expected = Partition.fromString(\"0,3|1,4|2\");\n        assertEquals(expected, bondPartition);\n    }", "signature": "void getBondPartitionTest()", "full_signature": "@Test public void getBondPartitionTest()", "class_method_signature": "BondRefinableTest.getBondPartitionTest()", "testcase": true, "constructor": false, "invocations": ["fromString", "getInitialPartition", "fromString", "assertEquals"]}, "focal_class": {"identifier": "BondRefinable", "superclass": "", "interfaces": "implements Refinable", "fields": [{"original_string": "private final IAtomContainer atomContainer;", "modifier": "private final", "type": "IAtomContainer", "declarator": "atomContainer", "var_name": "atomContainer"}, {"original_string": "private int[][] connectionTable;", "modifier": "private", "type": "int[][]", "declarator": "connectionTable", "var_name": "connectionTable"}, {"original_string": "private boolean ignoreBondOrders;", "modifier": "private", "type": "boolean", "declarator": "ignoreBondOrders", "var_name": "ignoreBondOrders"}], "methods": [{"identifier": "BondRefinable", "parameters": "(IAtomContainer atomContainer)", "modifiers": "public", "return": "", "signature": " BondRefinable(IAtomContainer atomContainer)", "full_signature": "public  BondRefinable(IAtomContainer atomContainer)", "class_method_signature": "BondRefinable.BondRefinable(IAtomContainer atomContainer)", "testcase": false, "constructor": true}, {"identifier": "BondRefinable", "parameters": "(IAtomContainer atomContainer, boolean ignoreBondOrders)", "modifiers": "public", "return": "", "signature": " BondRefinable(IAtomContainer atomContainer, boolean ignoreBondOrders)", "full_signature": "public  BondRefinable(IAtomContainer atomContainer, boolean ignoreBondOrders)", "class_method_signature": "BondRefinable.BondRefinable(IAtomContainer atomContainer, boolean ignoreBondOrders)", "testcase": false, "constructor": true}, {"identifier": "getVertexCount", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getVertexCount()", "full_signature": "@Override public int getVertexCount()", "class_method_signature": "BondRefinable.getVertexCount()", "testcase": false, "constructor": false}, {"identifier": "getConnectivity", "parameters": "(int vertexI, int vertexJ)", "modifiers": "@Override public", "return": "int", "signature": "int getConnectivity(int vertexI, int vertexJ)", "full_signature": "@Override public int getConnectivity(int vertexI, int vertexJ)", "class_method_signature": "BondRefinable.getConnectivity(int vertexI, int vertexJ)", "testcase": false, "constructor": false}, {"identifier": "neighboursInBlock", "parameters": "(Set<Integer> block, int vertexIndex)", "modifiers": "@Override public", "return": "Invariant", "signature": "Invariant neighboursInBlock(Set<Integer> block, int vertexIndex)", "full_signature": "@Override public Invariant neighboursInBlock(Set<Integer> block, int vertexIndex)", "class_method_signature": "BondRefinable.neighboursInBlock(Set<Integer> block, int vertexIndex)", "testcase": false, "constructor": false}, {"identifier": "getConnectedIndices", "parameters": "(int vertexIndex)", "modifiers": "private", "return": "int[]", "signature": "int[] getConnectedIndices(int vertexIndex)", "full_signature": "private int[] getConnectedIndices(int vertexIndex)", "class_method_signature": "BondRefinable.getConnectedIndices(int vertexIndex)", "testcase": false, "constructor": false}, {"identifier": "getInitialPartition", "parameters": "()", "modifiers": "public", "return": "Partition", "signature": "Partition getInitialPartition()", "full_signature": "public Partition getInitialPartition()", "class_method_signature": "BondRefinable.getInitialPartition()", "testcase": false, "constructor": false}, {"identifier": "setupConnectionTable", "parameters": "(IAtomContainer atomContainer)", "modifiers": "private", "return": "void", "signature": "void setupConnectionTable(IAtomContainer atomContainer)", "full_signature": "private void setupConnectionTable(IAtomContainer atomContainer)", "class_method_signature": "BondRefinable.setupConnectionTable(IAtomContainer atomContainer)", "testcase": false, "constructor": false}], "file": "tool/group/src/main/java/org/openscience/cdk/group/BondRefinable.java"}, "focal_method": {"identifier": "getInitialPartition", "parameters": "()", "modifiers": "public", "return": "Partition", "body": "public Partition getInitialPartition() {\n        int bondCount = atomContainer.getBondCount();\n        Map<String, SortedSet<Integer>> cellMap = new HashMap<String, SortedSet<Integer>>();\n\n        // make mini-'descriptors' for bonds like \"C=O\" or \"C#N\" etc\n        for (int bondIndex = 0; bondIndex < bondCount; bondIndex++) {\n            IBond bond = atomContainer.getBond(bondIndex);\n            String el0 = bond.getAtom(0).getSymbol();\n            String el1 = bond.getAtom(1).getSymbol();\n            String boS;\n            if (ignoreBondOrders) {\n                // doesn't matter what it is, so long as it's constant\n                boS = \"1\";\n            } else {\n                boolean isArom = bond.getFlag(CDKConstants.ISAROMATIC);\n                int orderNumber = (isArom) ? 5 : bond.getOrder().numeric();\n                boS = String.valueOf(orderNumber);\n            }\n            String bondString;\n            if (el0.compareTo(el1) < 0) {\n                bondString = el0 + boS + el1;\n            } else {\n                bondString = el1 + boS + el0;\n            }\n            SortedSet<Integer> cell;\n            if (cellMap.containsKey(bondString)) {\n                cell = cellMap.get(bondString);\n            } else {\n                cell = new TreeSet<Integer>();\n                cellMap.put(bondString, cell);\n            }\n            cell.add(bondIndex);\n        }\n\n        // sorting is necessary to get cells in order\n        List<String> bondStrings = new ArrayList<String>(cellMap.keySet());\n        Collections.sort(bondStrings);\n\n        // the partition of the bonds by these 'descriptors'\n        Partition bondPartition = new Partition();\n        for (String key : bondStrings) {\n            SortedSet<Integer> cell = cellMap.get(key);\n            bondPartition.addCell(cell);\n        }\n        bondPartition.order();\n        return bondPartition;\n    }", "signature": "Partition getInitialPartition()", "full_signature": "public Partition getInitialPartition()", "class_method_signature": "BondRefinable.getInitialPartition()", "testcase": false, "constructor": false, "invocations": ["getBondCount", "getBond", "getSymbol", "getAtom", "getSymbol", "getAtom", "getFlag", "numeric", "getOrder", "valueOf", "compareTo", "containsKey", "get", "put", "add", "keySet", "sort", "get", "addCell", "order"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}