{"test_class": {"identifier": "RateLimitingProcessorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String CHANGE_TOKEN = \"DOES NOT MATTER\";", "modifier": "public static final", "type": "String", "declarator": "CHANGE_TOKEN = \"DOES NOT MATTER\"", "var_name": "CHANGE_TOKEN"}, {"original_string": "RateLimitingProcessor processor;", "modifier": "", "type": "RateLimitingProcessor", "declarator": "processor", "var_name": "processor"}, {"original_string": "LogProcessorLambdaConfig config;", "modifier": "", "type": "LogProcessorLambdaConfig", "declarator": "config", "var_name": "config"}, {"original_string": "private static final String FAKE_BUCKET_NAME = \"blah\";", "modifier": "private static final", "type": "String", "declarator": "FAKE_BUCKET_NAME = \"blah\"", "var_name": "FAKE_BUCKET_NAME"}, {"original_string": "@Mock\n    AWSWAFRegional awswaf;", "modifier": "@Mock", "type": "AWSWAFRegional", "declarator": "awswaf", "var_name": "awswaf"}, {"original_string": "@Mock\n    AmazonS3 amazonS3;", "modifier": "@Mock", "type": "AmazonS3", "declarator": "amazonS3", "var_name": "amazonS3"}, {"original_string": "@Mock\n    LogProcessorLambdaConfig logProcessorLambdaConfig;", "modifier": "@Mock", "type": "LogProcessorLambdaConfig", "declarator": "logProcessorLambdaConfig", "var_name": "logProcessorLambdaConfig"}], "file": "cerberus-log-processor-lambda/src/test/java/com/nike/cerberus/lambda/waf/processor/RateLimitingProcessorTest.java"}, "test_case": {"identifier": "testThatGetCurrentlyBlockedIpsAndDateViolatedMapReturnsEmptyMapWhenS3HasNoObject", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testThatGetCurrentlyBlockedIpsAndDateViolatedMapReturnsEmptyMapWhenS3HasNoObject() {\n        when(amazonS3.getObject(isA(GetObjectRequest.class))).thenReturn(null);\n        Map<String, ViolationMetaData> map = processor.getCurrentlyBlockedIpsAndDateViolatedMap(FAKE_BUCKET_NAME);\n        assertTrue(\"The map should be empty\", map.size() == 0);\n    }", "signature": "void testThatGetCurrentlyBlockedIpsAndDateViolatedMapReturnsEmptyMapWhenS3HasNoObject()", "full_signature": "@Test public void testThatGetCurrentlyBlockedIpsAndDateViolatedMapReturnsEmptyMapWhenS3HasNoObject()", "class_method_signature": "RateLimitingProcessorTest.testThatGetCurrentlyBlockedIpsAndDateViolatedMapReturnsEmptyMapWhenS3HasNoObject()", "testcase": true, "constructor": false, "invocations": ["thenReturn", "when", "getObject", "isA", "getCurrentlyBlockedIpsAndDateViolatedMap", "assertTrue", "size"]}, "focal_class": {"identifier": "RateLimitingProcessor", "superclass": "", "interfaces": "implements Processor", "fields": [{"original_string": "private final Logger log = Logger.getLogger(getClass());", "modifier": "private final", "type": "Logger", "declarator": "log = Logger.getLogger(getClass())", "var_name": "log"}, {"original_string": "protected static final String SERIALIZED_DATA_FILE_NAME = \"rate_limit_processor_blacklist_data.json\";", "modifier": "protected static final", "type": "String", "declarator": "SERIALIZED_DATA_FILE_NAME = \"rate_limit_processor_blacklist_data.json\"", "var_name": "SERIALIZED_DATA_FILE_NAME"}, {"original_string": "private static final int LIMIT_IP_ADDRESS_RANGES_PER_IP_MATCH_CONDITION = 1000;", "modifier": "private static final", "type": "int", "declarator": "LIMIT_IP_ADDRESS_RANGES_PER_IP_MATCH_CONDITION = 1000", "var_name": "LIMIT_IP_ADDRESS_RANGES_PER_IP_MATCH_CONDITION"}, {"original_string": "private static final String NETMASK_FOR_SINGLE_IP = \"255.255.255.255\";", "modifier": "private static final", "type": "String", "declarator": "NETMASK_FOR_SINGLE_IP = \"255.255.255.255\"", "var_name": "NETMASK_FOR_SINGLE_IP"}, {"original_string": "private final ObjectMapper objectMapper;", "modifier": "private final", "type": "ObjectMapper", "declarator": "objectMapper", "var_name": "objectMapper"}, {"original_string": "private final AWSWAFRegional awsWaf;", "modifier": "private final", "type": "AWSWAFRegional", "declarator": "awsWaf", "var_name": "awsWaf"}, {"original_string": "private final AmazonS3 amazonS3;", "modifier": "private final", "type": "AmazonS3", "declarator": "amazonS3", "var_name": "amazonS3"}, {"original_string": "private int cidrLimitForIpSet = LIMIT_IP_ADDRESS_RANGES_PER_IP_MATCH_CONDITION;", "modifier": "private", "type": "int", "declarator": "cidrLimitForIpSet = LIMIT_IP_ADDRESS_RANGES_PER_IP_MATCH_CONDITION", "var_name": "cidrLimitForIpSet"}], "methods": [{"identifier": "RateLimitingProcessor", "parameters": "(ObjectMapper objectMapper, AWSWAFRegional awsWaf, AmazonS3 amazonS3)", "modifiers": "public", "return": "", "signature": " RateLimitingProcessor(ObjectMapper objectMapper, AWSWAFRegional awsWaf, AmazonS3 amazonS3)", "full_signature": "public  RateLimitingProcessor(ObjectMapper objectMapper, AWSWAFRegional awsWaf, AmazonS3 amazonS3)", "class_method_signature": "RateLimitingProcessor.RateLimitingProcessor(ObjectMapper objectMapper, AWSWAFRegional awsWaf, AmazonS3 amazonS3)", "testcase": false, "constructor": true}, {"identifier": "setCidrLimitForIpSetOverride", "parameters": "(int limitOverride)", "modifiers": "public", "return": "void", "signature": "void setCidrLimitForIpSetOverride(int limitOverride)", "full_signature": "public void setCidrLimitForIpSetOverride(int limitOverride)", "class_method_signature": "RateLimitingProcessor.setCidrLimitForIpSetOverride(int limitOverride)", "testcase": false, "constructor": false}, {"identifier": "processLogEvents", "parameters": "(List<ALBAccessLogEvent> events, LogProcessorLambdaConfig config, String bucketName)", "modifiers": "@Override public", "return": "void", "signature": "void processLogEvents(List<ALBAccessLogEvent> events, LogProcessorLambdaConfig config, String bucketName)", "full_signature": "@Override public void processLogEvents(List<ALBAccessLogEvent> events, LogProcessorLambdaConfig config, String bucketName)", "class_method_signature": "RateLimitingProcessor.processLogEvents(List<ALBAccessLogEvent> events, LogProcessorLambdaConfig config, String bucketName)", "testcase": false, "constructor": false}, {"identifier": "logSummary", "parameters": "(Map<String, List<String>> summary, LogProcessorLambdaConfig config)", "modifiers": "protected", "return": "void", "signature": "void logSummary(Map<String, List<String>> summary, LogProcessorLambdaConfig config)", "full_signature": "protected void logSummary(Map<String, List<String>> summary, LogProcessorLambdaConfig config)", "class_method_signature": "RateLimitingProcessor.logSummary(Map<String, List<String>> summary, LogProcessorLambdaConfig config)", "testcase": false, "constructor": false}, {"identifier": "getHostnameForIp", "parameters": "(String ip)", "modifiers": "private", "return": "String", "signature": "String getHostnameForIp(String ip)", "full_signature": "private String getHostnameForIp(String ip)", "class_method_signature": "RateLimitingProcessor.getHostnameForIp(String ip)", "testcase": false, "constructor": false}, {"identifier": "getDoNotBlockRangeSet", "parameters": "(LogProcessorLambdaConfig config)", "modifiers": "protected", "return": "RangeSet<Integer>", "signature": "RangeSet<Integer> getDoNotBlockRangeSet(LogProcessorLambdaConfig config)", "full_signature": "protected RangeSet<Integer> getDoNotBlockRangeSet(LogProcessorLambdaConfig config)", "class_method_signature": "RateLimitingProcessor.getDoNotBlockRangeSet(LogProcessorLambdaConfig config)", "testcase": false, "constructor": false}, {"identifier": "filterAndTruncateViolators", "parameters": "(LogProcessorLambdaConfig params,\n                                                                        RangeSet<Integer> doNotAutoBlockIpRangeSet,\n                                                                        Map<String, ViolationMetaData> violators)", "modifiers": "protected", "return": "Map<String, ViolationMetaData>", "signature": "Map<String, ViolationMetaData> filterAndTruncateViolators(LogProcessorLambdaConfig params,\n                                                                        RangeSet<Integer> doNotAutoBlockIpRangeSet,\n                                                                        Map<String, ViolationMetaData> violators)", "full_signature": "protected Map<String, ViolationMetaData> filterAndTruncateViolators(LogProcessorLambdaConfig params,\n                                                                        RangeSet<Integer> doNotAutoBlockIpRangeSet,\n                                                                        Map<String, ViolationMetaData> violators)", "class_method_signature": "RateLimitingProcessor.filterAndTruncateViolators(LogProcessorLambdaConfig params,\n                                                                        RangeSet<Integer> doNotAutoBlockIpRangeSet,\n                                                                        Map<String, ViolationMetaData> violators)", "testcase": false, "constructor": false}, {"identifier": "processViolators", "parameters": "(LogProcessorLambdaConfig config, Map<String, ViolationMetaData> violators)", "modifiers": "protected", "return": "Map<String, List<String>>", "signature": "Map<String, List<String>> processViolators(LogProcessorLambdaConfig config, Map<String, ViolationMetaData> violators)", "full_signature": "protected Map<String, List<String>> processViolators(LogProcessorLambdaConfig config, Map<String, ViolationMetaData> violators)", "class_method_signature": "RateLimitingProcessor.processViolators(LogProcessorLambdaConfig config, Map<String, ViolationMetaData> violators)", "testcase": false, "constructor": false}, {"identifier": "getCurrentlyBlockedIpsAndDateViolatedMap", "parameters": "(String bucketName)", "modifiers": "protected", "return": "Map<String, ViolationMetaData>", "signature": "Map<String, ViolationMetaData> getCurrentlyBlockedIpsAndDateViolatedMap(String bucketName)", "full_signature": "protected Map<String, ViolationMetaData> getCurrentlyBlockedIpsAndDateViolatedMap(String bucketName)", "class_method_signature": "RateLimitingProcessor.getCurrentlyBlockedIpsAndDateViolatedMap(String bucketName)", "testcase": false, "constructor": false}, {"identifier": "saveCurrentViolators", "parameters": "(Map<String, ViolationMetaData> violators, String bucketName)", "modifiers": "protected", "return": "void", "signature": "void saveCurrentViolators(Map<String, ViolationMetaData> violators, String bucketName)", "full_signature": "protected void saveCurrentViolators(Map<String, ViolationMetaData> violators, String bucketName)", "class_method_signature": "RateLimitingProcessor.saveCurrentViolators(Map<String, ViolationMetaData> violators, String bucketName)", "testcase": false, "constructor": false}, {"identifier": "getIpSet", "parameters": "(String ipSetId, int retryCount)", "modifiers": "protected", "return": "List<SubnetUtils.SubnetInfo>", "signature": "List<SubnetUtils.SubnetInfo> getIpSet(String ipSetId, int retryCount)", "full_signature": "protected List<SubnetUtils.SubnetInfo> getIpSet(String ipSetId, int retryCount)", "class_method_signature": "RateLimitingProcessor.getIpSet(String ipSetId, int retryCount)", "testcase": false, "constructor": false}, {"identifier": "sleep", "parameters": "(int time, TimeUnit timeUnit)", "modifiers": "private", "return": "void", "signature": "void sleep(int time, TimeUnit timeUnit)", "full_signature": "private void sleep(int time, TimeUnit timeUnit)", "class_method_signature": "RateLimitingProcessor.sleep(int time, TimeUnit timeUnit)", "testcase": false, "constructor": false}, {"identifier": "processRequest", "parameters": "(ALBAccessLogEvent event, Map<String, Integer> reqIdCountMap)", "modifiers": "protected", "return": "void", "signature": "void processRequest(ALBAccessLogEvent event, Map<String, Integer> reqIdCountMap)", "full_signature": "protected void processRequest(ALBAccessLogEvent event, Map<String, Integer> reqIdCountMap)", "class_method_signature": "RateLimitingProcessor.processRequest(ALBAccessLogEvent event, Map<String, Integer> reqIdCountMap)", "testcase": false, "constructor": false}, {"identifier": "getCurrentViolators", "parameters": "(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "modifiers": "protected", "return": "Map<String, ViolationMetaData>", "signature": "Map<String, ViolationMetaData> getCurrentViolators(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "full_signature": "protected Map<String, ViolationMetaData> getCurrentViolators(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "class_method_signature": "RateLimitingProcessor.getCurrentViolators(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "testcase": false, "constructor": false}, {"identifier": "canAddToAutoBlackList", "parameters": "(RangeSet<Integer> doNotAutoBlockIpRangeSet, String ipFromAccessLog)", "modifiers": "protected", "return": "boolean", "signature": "boolean canAddToAutoBlackList(RangeSet<Integer> doNotAutoBlockIpRangeSet, String ipFromAccessLog)", "full_signature": "protected boolean canAddToAutoBlackList(RangeSet<Integer> doNotAutoBlockIpRangeSet, String ipFromAccessLog)", "class_method_signature": "RateLimitingProcessor.canAddToAutoBlackList(RangeSet<Integer> doNotAutoBlockIpRangeSet, String ipFromAccessLog)", "testcase": false, "constructor": false}], "file": "cerberus-log-processor-lambda/src/main/java/com/nike/cerberus/lambda/waf/processor/RateLimitingProcessor.java"}, "focal_method": {"identifier": "getCurrentlyBlockedIpsAndDateViolatedMap", "parameters": "(String bucketName)", "modifiers": "protected", "return": "Map<String, ViolationMetaData>", "body": "protected Map<String, ViolationMetaData> getCurrentlyBlockedIpsAndDateViolatedMap(String bucketName) {\n        S3Object s3Object = null;\n        try {\n             s3Object = amazonS3.getObject(new GetObjectRequest(bucketName, SERIALIZED_DATA_FILE_NAME));\n        } catch (AmazonS3Exception e) {\n            if (e.getErrorCode().equals(\"NoSuchKey\")) {\n                return new HashMap<>();\n            }\n        }\n\n        if (s3Object == null) {\n            return new HashMap<>();\n        }\n\n        try {\n            TypeReference<HashMap<String,ViolationMetaData>> typeRef = new TypeReference<HashMap<String,ViolationMetaData>>() {};\n            return objectMapper.readValue(s3Object.getObjectContent(), typeRef);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to deserialize json data from previous runs\", e);\n        }\n    }", "signature": "Map<String, ViolationMetaData> getCurrentlyBlockedIpsAndDateViolatedMap(String bucketName)", "full_signature": "protected Map<String, ViolationMetaData> getCurrentlyBlockedIpsAndDateViolatedMap(String bucketName)", "class_method_signature": "RateLimitingProcessor.getCurrentlyBlockedIpsAndDateViolatedMap(String bucketName)", "testcase": false, "constructor": false, "invocations": ["getObject", "equals", "getErrorCode", "readValue", "getObjectContent"]}, "repository": {"repo_id": 70515197, "url": "https://github.com/Nike-Inc/cerberus-serverless-components", "language": "Java", "is_fork": false, "fork_count": 5, "stargazer_count": 12, "size": 269, "license": "licensed"}}