{"test_class": {"identifier": "EmrPricingHelperTest", "superclass": "extends AbstractDaoTest", "interfaces": "", "fields": [{"original_string": "private static final BigDecimal ONE_POINT_ONE = new BigDecimal(\"1.1\");", "modifier": "private static final", "type": "BigDecimal", "declarator": "ONE_POINT_ONE = new BigDecimal(\"1.1\")", "var_name": "ONE_POINT_ONE"}, {"original_string": "private static final BigDecimal ONE_POINT_ONE_ONE = new BigDecimal(\"1.11\");", "modifier": "private static final", "type": "BigDecimal", "declarator": "ONE_POINT_ONE_ONE = new BigDecimal(\"1.11\")", "var_name": "ONE_POINT_ONE_ONE"}, {"original_string": "private static final BigDecimal ONE_UNIT = new BigDecimal(\"0.00001\");", "modifier": "private static final", "type": "BigDecimal", "declarator": "ONE_UNIT = new BigDecimal(\"0.00001\")", "var_name": "ONE_UNIT"}, {"original_string": "private static final BigDecimal FIVE_UNIT = new BigDecimal(\"0.00005\");", "modifier": "private static final", "type": "BigDecimal", "declarator": "FIVE_UNIT = new BigDecimal(\"0.00005\")", "var_name": "FIVE_UNIT"}, {"original_string": "private static final BigDecimal TEN_PERCENT = new BigDecimal(\"0.1\");", "modifier": "private static final", "type": "BigDecimal", "declarator": "TEN_PERCENT = new BigDecimal(\"0.1\")", "var_name": "TEN_PERCENT"}, {"original_string": "private static final BigDecimal ON_DEMAND = new BigDecimal(\"1.00\");", "modifier": "private static final", "type": "BigDecimal", "declarator": "ON_DEMAND = new BigDecimal(\"1.00\")", "var_name": "ON_DEMAND"}, {"original_string": "private static final BigDecimal ON_DEMAND_LESS_ONE = ON_DEMAND.subtract(ONE_UNIT);", "modifier": "private static final", "type": "BigDecimal", "declarator": "ON_DEMAND_LESS_ONE = ON_DEMAND.subtract(ONE_UNIT)", "var_name": "ON_DEMAND_LESS_ONE"}, {"original_string": "private static final BigDecimal SPOT_PRICE_LOW = new BigDecimal(MockEc2OperationsImpl.SPOT_PRICE_LOW);", "modifier": "private static final", "type": "BigDecimal", "declarator": "SPOT_PRICE_LOW = new BigDecimal(MockEc2OperationsImpl.SPOT_PRICE_LOW)", "var_name": "SPOT_PRICE_LOW"}, {"original_string": "private static final BigDecimal SPOT_PRICE_LOW_LESS_ONE = SPOT_PRICE_LOW.subtract(ONE_UNIT);", "modifier": "private static final", "type": "BigDecimal", "declarator": "SPOT_PRICE_LOW_LESS_ONE = SPOT_PRICE_LOW.subtract(ONE_UNIT)", "var_name": "SPOT_PRICE_LOW_LESS_ONE"}, {"original_string": "private static final BigDecimal SPOT_PRICE_LOW_PLUS_ONE = SPOT_PRICE_LOW.add(ONE_UNIT);", "modifier": "private static final", "type": "BigDecimal", "declarator": "SPOT_PRICE_LOW_PLUS_ONE = SPOT_PRICE_LOW.add(ONE_UNIT)", "var_name": "SPOT_PRICE_LOW_PLUS_ONE"}, {"original_string": "private static final BigDecimal SPOT_PRICE_VERY_HIGH = new BigDecimal(MockEc2OperationsImpl.SPOT_PRICE_VERY_HIGH);", "modifier": "private static final", "type": "BigDecimal", "declarator": "SPOT_PRICE_VERY_HIGH = new BigDecimal(MockEc2OperationsImpl.SPOT_PRICE_VERY_HIGH)", "var_name": "SPOT_PRICE_VERY_HIGH"}, {"original_string": "@Autowired\n    private EmrPricingHelper emrPricingHelper;", "modifier": "@Autowired\n    private", "type": "EmrPricingHelper", "declarator": "emrPricingHelper", "var_name": "emrPricingHelper"}], "file": "herd-code/herd-dao/src/test/java/org/finra/herd/dao/helper/EmrPricingHelperTest.java"}, "test_case": {"identifier": "testCoreInstanceNullSubnetInMultipleAzAssertSuccess", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCoreInstanceNullSubnetInMultipleAzAssertSuccess() throws Exception\n    {\n        String subnetId = SUBNET_1 + \",\" + SUBNET_3;\n\n        MasterInstanceDefinition masterInstanceDefinition = new MasterInstanceDefinition();\n        masterInstanceDefinition.setInstanceCount(1);\n        masterInstanceDefinition.setInstanceType(INSTANCE_TYPE_1);\n\n        InstanceDefinition coreInstanceDefinition = null;\n\n        InstanceDefinition taskInstanceDefinition = null;\n\n        EmrClusterDefinition emrClusterDefinition =\n            updateEmrClusterDefinitionWithBestPrice(subnetId, masterInstanceDefinition, coreInstanceDefinition, taskInstanceDefinition);\n\n        // we select the pricing randomly so either one can be chosen\n        assertTrue(Arrays.asList(SUBNET_1, SUBNET_3).contains(emrClusterDefinition.getSubnetId()));\n    }", "signature": "void testCoreInstanceNullSubnetInMultipleAzAssertSuccess()", "full_signature": "@Test public void testCoreInstanceNullSubnetInMultipleAzAssertSuccess()", "class_method_signature": "EmrPricingHelperTest.testCoreInstanceNullSubnetInMultipleAzAssertSuccess()", "testcase": true, "constructor": false, "invocations": ["setInstanceCount", "setInstanceType", "updateEmrClusterDefinitionWithBestPrice", "assertTrue", "contains", "asList", "getSubnetId"]}, "focal_class": {"identifier": "EmrPricingHelper", "superclass": "extends AwsHelper", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(EmrPricingHelper.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(EmrPricingHelper.class)", "var_name": "LOGGER"}, {"original_string": "@Autowired\n    private Ec2Dao ec2Dao;", "modifier": "@Autowired\n    private", "type": "Ec2Dao", "declarator": "ec2Dao", "var_name": "ec2Dao"}, {"original_string": "@Autowired\n    private EmrVpcPricingStateFormatter emrVpcPricingStateFormatter;", "modifier": "@Autowired\n    private", "type": "EmrVpcPricingStateFormatter", "declarator": "emrVpcPricingStateFormatter", "var_name": "emrVpcPricingStateFormatter"}, {"original_string": "@Autowired\n    private HerdStringHelper herdStringHelper;", "modifier": "@Autowired\n    private", "type": "HerdStringHelper", "declarator": "herdStringHelper", "var_name": "herdStringHelper"}, {"original_string": "@Autowired\n    private JsonHelper jsonHelper;", "modifier": "@Autowired\n    private", "type": "JsonHelper", "declarator": "jsonHelper", "var_name": "jsonHelper"}, {"original_string": "@Autowired\n    private ConfigurationHelper configurationHelper;", "modifier": "@Autowired\n    private", "type": "ConfigurationHelper", "declarator": "configurationHelper", "var_name": "configurationHelper"}], "methods": [{"identifier": "updateEmrClusterDefinitionWithBestPrice", "parameters": "(EmrClusterAlternateKeyDto emrClusterAlternateKeyDto, EmrClusterDefinition emrClusterDefinition,\n        AwsParamsDto awsParamsDto)", "modifiers": "public", "return": "void", "signature": "void updateEmrClusterDefinitionWithBestPrice(EmrClusterAlternateKeyDto emrClusterAlternateKeyDto, EmrClusterDefinition emrClusterDefinition,\n        AwsParamsDto awsParamsDto)", "full_signature": "public void updateEmrClusterDefinitionWithBestPrice(EmrClusterAlternateKeyDto emrClusterAlternateKeyDto, EmrClusterDefinition emrClusterDefinition,\n        AwsParamsDto awsParamsDto)", "class_method_signature": "EmrPricingHelper.updateEmrClusterDefinitionWithBestPrice(EmrClusterAlternateKeyDto emrClusterAlternateKeyDto, EmrClusterDefinition emrClusterDefinition,\n        AwsParamsDto awsParamsDto)", "testcase": false, "constructor": false}, {"identifier": "getTotalInstanceCount", "parameters": "(EmrClusterDefinition emrClusterDefinition)", "modifiers": "private", "return": "int", "signature": "int getTotalInstanceCount(EmrClusterDefinition emrClusterDefinition)", "full_signature": "private int getTotalInstanceCount(EmrClusterDefinition emrClusterDefinition)", "class_method_signature": "EmrPricingHelper.getTotalInstanceCount(EmrClusterDefinition emrClusterDefinition)", "testcase": false, "constructor": false}, {"identifier": "updateInstanceDefinitionsWithBestPrice", "parameters": "(EmrClusterDefinition emrClusterDefinition, Subnet bestEmrClusterSubnet,\n        EmrClusterPriceDto bestEmrClusterPrice)", "modifiers": "private", "return": "void", "signature": "void updateInstanceDefinitionsWithBestPrice(EmrClusterDefinition emrClusterDefinition, Subnet bestEmrClusterSubnet,\n        EmrClusterPriceDto bestEmrClusterPrice)", "full_signature": "private void updateInstanceDefinitionsWithBestPrice(EmrClusterDefinition emrClusterDefinition, Subnet bestEmrClusterSubnet,\n        EmrClusterPriceDto bestEmrClusterPrice)", "class_method_signature": "EmrPricingHelper.updateInstanceDefinitionsWithBestPrice(EmrClusterDefinition emrClusterDefinition, Subnet bestEmrClusterSubnet,\n        EmrClusterPriceDto bestEmrClusterPrice)", "testcase": false, "constructor": false}, {"identifier": "getSpotBidPrice", "parameters": "(Ec2PriceDto ec2Price)", "modifiers": "private", "return": "BigDecimal", "signature": "BigDecimal getSpotBidPrice(Ec2PriceDto ec2Price)", "full_signature": "private BigDecimal getSpotBidPrice(Ec2PriceDto ec2Price)", "class_method_signature": "EmrPricingHelper.getSpotBidPrice(Ec2PriceDto ec2Price)", "testcase": false, "constructor": false}, {"identifier": "getBestSubnetForAvailabilityZone", "parameters": "(String availabilityZone, List<Subnet> subnets)", "modifiers": "private", "return": "Subnet", "signature": "Subnet getBestSubnetForAvailabilityZone(String availabilityZone, List<Subnet> subnets)", "full_signature": "private Subnet getBestSubnetForAvailabilityZone(String availabilityZone, List<Subnet> subnets)", "class_method_signature": "EmrPricingHelper.getBestSubnetForAvailabilityZone(String availabilityZone, List<Subnet> subnets)", "testcase": false, "constructor": false}, {"identifier": "getTop", "parameters": "(List<T> list, Comparator<T> comparator)", "modifiers": "private", "return": "T", "signature": "T getTop(List<T> list, Comparator<T> comparator)", "full_signature": "private T getTop(List<T> list, Comparator<T> comparator)", "class_method_signature": "EmrPricingHelper.getTop(List<T> list, Comparator<T> comparator)", "testcase": false, "constructor": false}, {"identifier": "getEmrClusterPriceWithLowestCoreInstancePrice", "parameters": "(final List<EmrClusterPriceDto> emrClusterPrices)", "modifiers": "", "return": "EmrClusterPriceDto", "signature": "EmrClusterPriceDto getEmrClusterPriceWithLowestCoreInstancePrice(final List<EmrClusterPriceDto> emrClusterPrices)", "full_signature": " EmrClusterPriceDto getEmrClusterPriceWithLowestCoreInstancePrice(final List<EmrClusterPriceDto> emrClusterPrices)", "class_method_signature": "EmrPricingHelper.getEmrClusterPriceWithLowestCoreInstancePrice(final List<EmrClusterPriceDto> emrClusterPrices)", "testcase": false, "constructor": false}, {"identifier": "getEmrClusterPricesWithinLowestCoreInstancePriceThreshold", "parameters": "(final List<EmrClusterPriceDto> emrClusterPrices,\n        final BigDecimal lowestCoreInstancePriceThresholdPercentage)", "modifiers": "", "return": "List<EmrClusterPriceDto>", "signature": "List<EmrClusterPriceDto> getEmrClusterPricesWithinLowestCoreInstancePriceThreshold(final List<EmrClusterPriceDto> emrClusterPrices,\n        final BigDecimal lowestCoreInstancePriceThresholdPercentage)", "full_signature": " List<EmrClusterPriceDto> getEmrClusterPricesWithinLowestCoreInstancePriceThreshold(final List<EmrClusterPriceDto> emrClusterPrices,\n        final BigDecimal lowestCoreInstancePriceThresholdPercentage)", "class_method_signature": "EmrPricingHelper.getEmrClusterPricesWithinLowestCoreInstancePriceThreshold(final List<EmrClusterPriceDto> emrClusterPrices,\n        final BigDecimal lowestCoreInstancePriceThresholdPercentage)", "testcase": false, "constructor": false}, {"identifier": "getEmrClusterCoreInstancePrice", "parameters": "(EmrClusterPriceDto emrClusterPrice)", "modifiers": "private", "return": "BigDecimal", "signature": "BigDecimal getEmrClusterCoreInstancePrice(EmrClusterPriceDto emrClusterPrice)", "full_signature": "private BigDecimal getEmrClusterCoreInstancePrice(EmrClusterPriceDto emrClusterPrice)", "class_method_signature": "EmrPricingHelper.getEmrClusterCoreInstancePrice(EmrClusterPriceDto emrClusterPrice)", "testcase": false, "constructor": false}, {"identifier": "removeSubnetsWithAvailableIpsLessThan", "parameters": "(List<Subnet> subnets, int availableIps)", "modifiers": "private", "return": "void", "signature": "void removeSubnetsWithAvailableIpsLessThan(List<Subnet> subnets, int availableIps)", "full_signature": "private void removeSubnetsWithAvailableIpsLessThan(List<Subnet> subnets, int availableIps)", "class_method_signature": "EmrPricingHelper.removeSubnetsWithAvailableIpsLessThan(List<Subnet> subnets, int availableIps)", "testcase": false, "constructor": false}, {"identifier": "createEmrClusterPrice", "parameters": "(AvailabilityZone availabilityZone, Ec2PriceDto masterPrice, Ec2PriceDto corePrice, Ec2PriceDto taskPrice)", "modifiers": "private", "return": "EmrClusterPriceDto", "signature": "EmrClusterPriceDto createEmrClusterPrice(AvailabilityZone availabilityZone, Ec2PriceDto masterPrice, Ec2PriceDto corePrice, Ec2PriceDto taskPrice)", "full_signature": "private EmrClusterPriceDto createEmrClusterPrice(AvailabilityZone availabilityZone, Ec2PriceDto masterPrice, Ec2PriceDto corePrice, Ec2PriceDto taskPrice)", "class_method_signature": "EmrPricingHelper.createEmrClusterPrice(AvailabilityZone availabilityZone, Ec2PriceDto masterPrice, Ec2PriceDto corePrice, Ec2PriceDto taskPrice)", "testcase": false, "constructor": false}, {"identifier": "getBestInstancePrice", "parameters": "(BigDecimal spotPrice, InstanceDefinition instanceDefinition)", "modifiers": "private", "return": "Ec2PriceDto", "signature": "Ec2PriceDto getBestInstancePrice(BigDecimal spotPrice, InstanceDefinition instanceDefinition)", "full_signature": "private Ec2PriceDto getBestInstancePrice(BigDecimal spotPrice, InstanceDefinition instanceDefinition)", "class_method_signature": "EmrPricingHelper.getBestInstancePrice(BigDecimal spotPrice, InstanceDefinition instanceDefinition)", "testcase": false, "constructor": false}, {"identifier": "setBestPriceToSpotPricing", "parameters": "(BigDecimal spotPrice, BigDecimal bidPrice, int instanceCount)", "modifiers": "private", "return": "Ec2PriceDto", "signature": "Ec2PriceDto setBestPriceToSpotPricing(BigDecimal spotPrice, BigDecimal bidPrice, int instanceCount)", "full_signature": "private Ec2PriceDto setBestPriceToSpotPricing(BigDecimal spotPrice, BigDecimal bidPrice, int instanceCount)", "class_method_signature": "EmrPricingHelper.setBestPriceToSpotPricing(BigDecimal spotPrice, BigDecimal bidPrice, int instanceCount)", "testcase": false, "constructor": false}, {"identifier": "getCoreInstanceDefinition", "parameters": "(EmrClusterDefinition emrClusterDefinition)", "modifiers": "private", "return": "InstanceDefinition", "signature": "InstanceDefinition getCoreInstanceDefinition(EmrClusterDefinition emrClusterDefinition)", "full_signature": "private InstanceDefinition getCoreInstanceDefinition(EmrClusterDefinition emrClusterDefinition)", "class_method_signature": "EmrPricingHelper.getCoreInstanceDefinition(EmrClusterDefinition emrClusterDefinition)", "testcase": false, "constructor": false}, {"identifier": "getTaskInstanceDefinition", "parameters": "(EmrClusterDefinition emrClusterDefinition)", "modifiers": "private", "return": "InstanceDefinition", "signature": "InstanceDefinition getTaskInstanceDefinition(EmrClusterDefinition emrClusterDefinition)", "full_signature": "private InstanceDefinition getTaskInstanceDefinition(EmrClusterDefinition emrClusterDefinition)", "class_method_signature": "EmrPricingHelper.getTaskInstanceDefinition(EmrClusterDefinition emrClusterDefinition)", "testcase": false, "constructor": false}, {"identifier": "getMasterInstanceDefinition", "parameters": "(EmrClusterDefinition emrClusterDefinition)", "modifiers": "private", "return": "InstanceDefinition", "signature": "InstanceDefinition getMasterInstanceDefinition(EmrClusterDefinition emrClusterDefinition)", "full_signature": "private InstanceDefinition getMasterInstanceDefinition(EmrClusterDefinition emrClusterDefinition)", "class_method_signature": "EmrPricingHelper.getMasterInstanceDefinition(EmrClusterDefinition emrClusterDefinition)", "testcase": false, "constructor": false}, {"identifier": "getInstanceTypeSpotPrices", "parameters": "(AvailabilityZone availabilityZone, Set<String> instanceTypes, AwsParamsDto awsParamsDto)", "modifiers": "private", "return": "Map<String, BigDecimal>", "signature": "Map<String, BigDecimal> getInstanceTypeSpotPrices(AvailabilityZone availabilityZone, Set<String> instanceTypes, AwsParamsDto awsParamsDto)", "full_signature": "private Map<String, BigDecimal> getInstanceTypeSpotPrices(AvailabilityZone availabilityZone, Set<String> instanceTypes, AwsParamsDto awsParamsDto)", "class_method_signature": "EmrPricingHelper.getInstanceTypeSpotPrices(AvailabilityZone availabilityZone, Set<String> instanceTypes, AwsParamsDto awsParamsDto)", "testcase": false, "constructor": false}, {"identifier": "getAvailabilityZones", "parameters": "(List<Subnet> subnets, AwsParamsDto awsParamsDto)", "modifiers": "private", "return": "List<AvailabilityZone>", "signature": "List<AvailabilityZone> getAvailabilityZones(List<Subnet> subnets, AwsParamsDto awsParamsDto)", "full_signature": "private List<AvailabilityZone> getAvailabilityZones(List<Subnet> subnets, AwsParamsDto awsParamsDto)", "class_method_signature": "EmrPricingHelper.getAvailabilityZones(List<Subnet> subnets, AwsParamsDto awsParamsDto)", "testcase": false, "constructor": false}, {"identifier": "getSubnets", "parameters": "(EmrClusterDefinition emrClusterDefinition, AwsParamsDto awsParamsDto)", "modifiers": "public", "return": "List<Subnet>", "signature": "List<Subnet> getSubnets(EmrClusterDefinition emrClusterDefinition, AwsParamsDto awsParamsDto)", "full_signature": "public List<Subnet> getSubnets(EmrClusterDefinition emrClusterDefinition, AwsParamsDto awsParamsDto)", "class_method_signature": "EmrPricingHelper.getSubnets(EmrClusterDefinition emrClusterDefinition, AwsParamsDto awsParamsDto)", "testcase": false, "constructor": false}], "file": "herd-code/herd-dao/src/main/java/org/finra/herd/dao/helper/EmrPricingHelper.java"}, "focal_method": {"identifier": "updateEmrClusterDefinitionWithBestPrice", "parameters": "(EmrClusterAlternateKeyDto emrClusterAlternateKeyDto, EmrClusterDefinition emrClusterDefinition,\n        AwsParamsDto awsParamsDto)", "modifiers": "public", "return": "void", "body": "public void updateEmrClusterDefinitionWithBestPrice(EmrClusterAlternateKeyDto emrClusterAlternateKeyDto, EmrClusterDefinition emrClusterDefinition,\n        AwsParamsDto awsParamsDto)\n    {\n        EmrVpcPricingState emrVpcPricingState = new EmrVpcPricingState();\n\n        // Get total count of instances this definition will attempt to create\n        int totalInstanceCount = getTotalInstanceCount(emrClusterDefinition);\n\n        // Get the subnet information\n        List<Subnet> subnets = getSubnets(emrClusterDefinition, awsParamsDto);\n        for (Subnet subnet : subnets)\n        {\n            emrVpcPricingState.getSubnetAvailableIpAddressCounts().put(subnet.getSubnetId(), subnet.getAvailableIpAddressCount());\n        }\n        // Filter out subnets with not enough available IPs\n        removeSubnetsWithAvailableIpsLessThan(subnets, totalInstanceCount);\n\n        if (subnets.isEmpty())\n        {\n            LOGGER.info(String.format(\"Insufficient IP availability. namespace=\\\"%s\\\" emrClusterDefinitionName=\\\"%s\\\" emrClusterName=\\\"%s\\\" \" +\n                    \"totalRequestedInstanceCount=%s emrVpcPricingState=%s\", emrClusterAlternateKeyDto.getNamespace(),\n                emrClusterAlternateKeyDto.getEmrClusterDefinitionName(), emrClusterAlternateKeyDto.getEmrClusterName(), totalInstanceCount,\n                jsonHelper.objectToJson(emrVpcPricingState)));\n            throw new ObjectNotFoundException(String.format(\n                \"There are no subnets in the current VPC which have sufficient IP addresses available to run your \" +\n                    \"clusters. Try expanding the list of subnets or try again later. requestedInstanceCount=%s%n%s\", totalInstanceCount,\n                emrVpcPricingStateFormatter.format(emrVpcPricingState)));\n        }\n\n        // Best prices are accumulated in this list\n        List<EmrClusterPriceDto> emrClusterPrices = new ArrayList<>();\n\n        InstanceDefinition masterInstanceDefinition = getMasterInstanceDefinition(emrClusterDefinition);\n        InstanceDefinition coreInstanceDefinition = getCoreInstanceDefinition(emrClusterDefinition);\n        InstanceDefinition taskInstanceDefinition = getTaskInstanceDefinition(emrClusterDefinition);\n\n        Set<String> requestedInstanceTypes = new HashSet<>();\n\n        String masterInstanceType = masterInstanceDefinition.getInstanceType();\n        requestedInstanceTypes.add(masterInstanceType);\n\n        if (coreInstanceDefinition != null)\n        {\n            String coreInstanceType = coreInstanceDefinition.getInstanceType();\n            requestedInstanceTypes.add(coreInstanceType);\n        }\n\n        if (taskInstanceDefinition != null)\n        {\n            String taskInstanceType = taskInstanceDefinition.getInstanceType();\n            requestedInstanceTypes.add(taskInstanceType);\n        }\n\n        // Get AZs for the subnets\n        for (AvailabilityZone availabilityZone : getAvailabilityZones(subnets, awsParamsDto))\n        {\n            // Create a mapping of instance types to prices for more efficient, in-memory lookup\n            // When AWS does not return any spot price history for an instance type in an availability zone, the algorithm will not use that availability zone\n            // when selecting the lowest price.\n            Map<String, BigDecimal> instanceTypeSpotPrices = getInstanceTypeSpotPrices(availabilityZone, requestedInstanceTypes, awsParamsDto);\n\n            emrVpcPricingState.getSpotPricesPerAvailabilityZone().put(availabilityZone.getZoneName(), instanceTypeSpotPrices);\n\n            // Get and compare master price\n            BigDecimal masterSpotPrice = instanceTypeSpotPrices.get(masterInstanceType);\n            Ec2PriceDto masterPrice = getBestInstancePrice(masterSpotPrice, masterInstanceDefinition);\n\n            // Get and compare core price\n            Ec2PriceDto corePrice = null;\n            if (coreInstanceDefinition != null)\n            {\n                String coreInstanceType = coreInstanceDefinition.getInstanceType();\n                BigDecimal coreSpotPrice = instanceTypeSpotPrices.get(coreInstanceType);\n                corePrice = getBestInstancePrice(coreSpotPrice, coreInstanceDefinition);\n            }\n\n            // Get and compare task price\n            Ec2PriceDto taskPrice = null;\n            if (taskInstanceDefinition != null)\n            {\n                String taskInstanceType = taskInstanceDefinition.getInstanceType();\n                BigDecimal taskSpotPrice = instanceTypeSpotPrices.get(taskInstanceType);\n                taskPrice = getBestInstancePrice(taskSpotPrice, taskInstanceDefinition);\n            }\n\n            // If prices were found\n            if (masterPrice != null && (coreInstanceDefinition == null || corePrice != null) && (taskInstanceDefinition == null || taskPrice != null))\n            {\n                // Add the pricing result to the result list\n                emrClusterPrices.add(createEmrClusterPrice(availabilityZone, masterPrice, corePrice, taskPrice));\n            }\n\n            // If prices were not found for either master or core, this AZ cannot satisfy the search criteria. Ignore this AZ.\n        }\n\n        if (emrClusterPrices.isEmpty())\n        {\n            LOGGER.info(String.format(\"No subnets which satisfied the best price search criteria. namespace=\\\"%s\\\" emrClusterDefinitionName=\\\"%s\\\" \" +\n                    \"emrClusterName=\\\"%s\\\" emrVpcPricingState=%s\", emrClusterAlternateKeyDto.getNamespace(),\n                emrClusterAlternateKeyDto.getEmrClusterDefinitionName(), emrClusterAlternateKeyDto.getEmrClusterName(),\n                jsonHelper.objectToJson(emrVpcPricingState)));\n            throw new ObjectNotFoundException(String.format(\n                \"There were no subnets which satisfied your best price search criteria. If you explicitly opted to use spot EC2 instances, please confirm \" +\n                    \"that your instance types support spot pricing. Otherwise, try setting the max price or the on-demand threshold to a higher value.%n%s\",\n                emrVpcPricingStateFormatter.format(emrVpcPricingState)));\n        }\n\n        // Find the best prices from the result list\n        EmrClusterPriceDto bestEmrClusterPrice = getEmrClusterPriceWithLowestCoreInstancePrice(emrClusterPrices);\n\n        if (bestEmrClusterPrice != null)\n        {\n            // Find the best subnet among the best AZ's\n            Subnet bestEmrClusterSubnet = getBestSubnetForAvailabilityZone(bestEmrClusterPrice.getAvailabilityZone(), subnets);\n\n            // Update the definition with the new calculated values\n            updateInstanceDefinitionsWithBestPrice(emrClusterDefinition, bestEmrClusterSubnet, bestEmrClusterPrice);\n        }\n    }", "signature": "void updateEmrClusterDefinitionWithBestPrice(EmrClusterAlternateKeyDto emrClusterAlternateKeyDto, EmrClusterDefinition emrClusterDefinition,\n        AwsParamsDto awsParamsDto)", "full_signature": "public void updateEmrClusterDefinitionWithBestPrice(EmrClusterAlternateKeyDto emrClusterAlternateKeyDto, EmrClusterDefinition emrClusterDefinition,\n        AwsParamsDto awsParamsDto)", "class_method_signature": "EmrPricingHelper.updateEmrClusterDefinitionWithBestPrice(EmrClusterAlternateKeyDto emrClusterAlternateKeyDto, EmrClusterDefinition emrClusterDefinition,\n        AwsParamsDto awsParamsDto)", "testcase": false, "constructor": false, "invocations": ["getTotalInstanceCount", "getSubnets", "put", "getSubnetAvailableIpAddressCounts", "getSubnetId", "getAvailableIpAddressCount", "removeSubnetsWithAvailableIpsLessThan", "isEmpty", "info", "format", "getNamespace", "getEmrClusterDefinitionName", "getEmrClusterName", "objectToJson", "format", "format", "getMasterInstanceDefinition", "getCoreInstanceDefinition", "getTaskInstanceDefinition", "getInstanceType", "add", "getInstanceType", "add", "getInstanceType", "add", "getAvailabilityZones", "getInstanceTypeSpotPrices", "put", "getSpotPricesPerAvailabilityZone", "getZoneName", "get", "getBestInstancePrice", "getInstanceType", "get", "getBestInstancePrice", "getInstanceType", "get", "getBestInstancePrice", "add", "createEmrClusterPrice", "isEmpty", "info", "format", "getNamespace", "getEmrClusterDefinitionName", "getEmrClusterName", "objectToJson", "format", "format", "getEmrClusterPriceWithLowestCoreInstancePrice", "getBestSubnetForAvailabilityZone", "getAvailabilityZone", "updateInstanceDefinitionsWithBestPrice"]}, "repository": {"repo_id": 42949039, "url": "https://github.com/FINRAOS/herd", "language": "Java", "is_fork": false, "fork_count": 36, "stargazer_count": 120, "size": 205797, "license": "licensed"}}