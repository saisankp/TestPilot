{"test_class": {"identifier": "ConcurrentCacheTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ConcurrentCache<String, Object> cache;", "modifier": "private", "type": "ConcurrentCache<String, Object>", "declarator": "cache", "var_name": "cache"}], "file": "concurrency/src/test/java/com/baidu/unbiz/common/cache/ConcurrentCacheTest.java"}, "test_case": {"identifier": "testLogger", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testLogger() {\n        Object result = cache.get(\"logger\", new Callable<Object>() {\n\n            @Override\n            public Object call() throws Exception {\n                return LoggerFactory.getLogger(ConcurrentCacheTest.class);\n            }\n        });\n\n        assertEquals(LoggerFactory.getLogger(ConcurrentCacheTest.class), result);\n        assertTrue(LoggerFactory.getLogger(ConcurrentCacheTest.class) == result);\n    }", "signature": "void testLogger()", "full_signature": "@Test public void testLogger()", "class_method_signature": "ConcurrentCacheTest.testLogger()", "testcase": true, "constructor": false, "invocations": ["get", "getLogger", "assertEquals", "getLogger", "assertTrue", "getLogger"]}, "focal_class": {"identifier": "ConcurrentCache", "superclass": "", "interfaces": "implements Computable<K, V>", "fields": [{"original_string": "private final ConcurrentMap<K, Future<V>> concurrentMap;", "modifier": "private final", "type": "ConcurrentMap<K, Future<V>>", "declarator": "concurrentMap", "var_name": "concurrentMap"}], "methods": [{"identifier": "ConcurrentCache", "parameters": "()", "modifiers": "public", "return": "", "signature": " ConcurrentCache()", "full_signature": "public  ConcurrentCache()", "class_method_signature": "ConcurrentCache.ConcurrentCache()", "testcase": false, "constructor": true}, {"identifier": "createComputable", "parameters": "()", "modifiers": "public static", "return": "Computable<K, V>", "signature": "Computable<K, V> createComputable()", "full_signature": "public static Computable<K, V> createComputable()", "class_method_signature": "ConcurrentCache.createComputable()", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(K key, Callable<V> callable)", "modifiers": "public", "return": "V", "signature": "V get(K key, Callable<V> callable)", "full_signature": "public V get(K key, Callable<V> callable)", "class_method_signature": "ConcurrentCache.get(K key, Callable<V> callable)", "testcase": false, "constructor": false}], "file": "concurrency/src/main/java/com/baidu/unbiz/common/cache/ConcurrentCache.java"}, "focal_method": {"identifier": "get", "parameters": "(K key, Callable<V> callable)", "modifiers": "public", "return": "V", "body": "public V get(K key, Callable<V> callable) {\n        Future<V> future = concurrentMap.get(key);\n        if (future == null) {\n            FutureTask<V> futureTask = new FutureTask<V>(callable);\n            future = concurrentMap.putIfAbsent(key, futureTask);\n            if (future == null) {\n                future = futureTask;\n                futureTask.run();\n            }\n        }\n        try {\n            // \u6b64\u65f6\u963b\u585e\n            return future.get();\n        } catch (Exception e) {\n            concurrentMap.remove(key);\n            return null;\n        }\n    }", "signature": "V get(K key, Callable<V> callable)", "full_signature": "public V get(K key, Callable<V> callable)", "class_method_signature": "ConcurrentCache.get(K key, Callable<V> callable)", "testcase": false, "constructor": false, "invocations": ["get", "putIfAbsent", "run", "get", "remove"]}, "repository": {"repo_id": 33645537, "url": "https://github.com/zqhxuyuan/tutorials", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 5, "size": 35273, "license": "licensed"}}