{"test_class": {"identifier": "MulticastSocketListenerThreadTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String JOLOKIA_URL = \"http://localhost:8080/jolokia\";", "modifier": "public static final", "type": "String", "declarator": "JOLOKIA_URL = \"http://localhost:8080/jolokia\"", "var_name": "JOLOKIA_URL"}, {"original_string": "public static final String MULTICAST_GROUP = ConfigKey.MULTICAST_GROUP.getDefaultValue();", "modifier": "public static final", "type": "String", "declarator": "MULTICAST_GROUP = ConfigKey.MULTICAST_GROUP.getDefaultValue()", "var_name": "MULTICAST_GROUP"}, {"original_string": "public static final int MULTICAST_PORT = Integer.valueOf(ConfigKey.MULTICAST_PORT.getDefaultValue());", "modifier": "public static final", "type": "int", "declarator": "MULTICAST_PORT = Integer.valueOf(ConfigKey.MULTICAST_PORT.getDefaultValue())", "var_name": "MULTICAST_PORT"}, {"original_string": "private URL url;", "modifier": "private", "type": "URL", "declarator": "url", "var_name": "url"}, {"original_string": "private String id;", "modifier": "private", "type": "String", "declarator": "id", "var_name": "id"}], "file": "agent/core/src/test/java/org/jolokia/discovery/MulticastSocketListenerThreadTest.java"}, "test_case": {"identifier": "simple", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void simple() throws IOException, InterruptedException {\n        checkForMulticastSupport();\n\n        MulticastSocketListenerThread listenerThread = startSocketListener();\n\n        try {\n            DiscoveryOutgoingMessage out =\n                    new DiscoveryOutgoingMessage.Builder(QUERY)\n                            .agentId(UUID.randomUUID().toString())\n                            .build();\n            List<DiscoveryIncomingMessage> discovered = sendQueryAndCollectAnswers(out, 500, MULTICAST_GROUP, MULTICAST_PORT, new LogHandler.StdoutLogHandler(true));\n            int idCount = 0;\n            int urlCount = 0;\n            for (DiscoveryIncomingMessage in : discovered) {\n                AgentDetails agentDetails = in.getAgentDetails();\n                if (agentDetails.getAgentId().equals(id)) {\n                    idCount++;\n                }\n                if (JOLOKIA_URL.equals(in.getAgentDetails().toJSONObject().get(\"url\"))) {\n                    urlCount++;\n                }\n                assertFalse(in.isQuery());\n                JSONObject details = agentDetails.toJSONObject();\n                if (details.get(\"server_vendor\") != null && details.get(\"server_vendor\").equals(\"jolokia\")) {\n                    assertEquals(details.get(\"url\"), JOLOKIA_URL);\n                    assertEquals(details.get(\"agent_version\"), Version.getAgentVersion());\n                    return;\n                }\n            }\n            assertEquals(idCount,1,\"Exactly one in message with the send id should have been received\");\n            assertEquals(urlCount,1,\"Only one message with the url should be included\");\n            fail(\"No message found\");\n        } finally {\n            listenerThread.shutdown();\n        }\n    }", "signature": "void simple()", "full_signature": "@Test public void simple()", "class_method_signature": "MulticastSocketListenerThreadTest.simple()", "testcase": true, "constructor": false, "invocations": ["checkForMulticastSupport", "startSocketListener", "build", "agentId", "toString", "randomUUID", "sendQueryAndCollectAnswers", "getAgentDetails", "equals", "getAgentId", "equals", "get", "toJSONObject", "getAgentDetails", "assertFalse", "isQuery", "toJSONObject", "get", "equals", "get", "assertEquals", "get", "assertEquals", "get", "getAgentVersion", "assertEquals", "assertEquals", "fail", "shutdown"]}, "focal_class": {"identifier": "MulticastSocketListenerThread", "superclass": "extends Thread", "interfaces": "", "fields": [{"original_string": "private final AgentDetailsHolder agentDetailsHolder;", "modifier": "private final", "type": "AgentDetailsHolder", "declarator": "agentDetailsHolder", "var_name": "agentDetailsHolder"}, {"original_string": "private final Restrictor restrictor;", "modifier": "private final", "type": "Restrictor", "declarator": "restrictor", "var_name": "restrictor"}, {"original_string": "private final String multicastGroup;", "modifier": "private final", "type": "String", "declarator": "multicastGroup", "var_name": "multicastGroup"}, {"original_string": "private final int multicastPort;", "modifier": "private final", "type": "int", "declarator": "multicastPort", "var_name": "multicastPort"}, {"original_string": "private final LogHandler logHandler;", "modifier": "private final", "type": "LogHandler", "declarator": "logHandler", "var_name": "logHandler"}, {"original_string": "private final InetAddress address;", "modifier": "private final", "type": "InetAddress", "declarator": "address", "var_name": "address"}, {"original_string": "private boolean running;", "modifier": "private", "type": "boolean", "declarator": "running", "var_name": "running"}, {"original_string": "private MulticastSocket socket;", "modifier": "private", "type": "MulticastSocket", "declarator": "socket", "var_name": "socket"}], "methods": [{"identifier": "MulticastSocketListenerThread", "parameters": "(String name, InetAddress pHostAddress, AgentDetailsHolder pAgentDetailsHolder, Restrictor pRestrictor, String pMulticastGroup, int pMulticastPort, LogHandler pLogHandler)", "modifiers": "", "return": "", "signature": " MulticastSocketListenerThread(String name, InetAddress pHostAddress, AgentDetailsHolder pAgentDetailsHolder, Restrictor pRestrictor, String pMulticastGroup, int pMulticastPort, LogHandler pLogHandler)", "full_signature": "  MulticastSocketListenerThread(String name, InetAddress pHostAddress, AgentDetailsHolder pAgentDetailsHolder, Restrictor pRestrictor, String pMulticastGroup, int pMulticastPort, LogHandler pLogHandler)", "class_method_signature": "MulticastSocketListenerThread.MulticastSocketListenerThread(String name, InetAddress pHostAddress, AgentDetailsHolder pAgentDetailsHolder, Restrictor pRestrictor, String pMulticastGroup, int pMulticastPort, LogHandler pLogHandler)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void run()", "full_signature": "public void run()", "class_method_signature": "MulticastSocketListenerThread.run()", "testcase": false, "constructor": false}, {"identifier": "setRunning", "parameters": "(boolean pRunning)", "modifiers": "private synchronized", "return": "void", "signature": "void setRunning(boolean pRunning)", "full_signature": "private synchronized void setRunning(boolean pRunning)", "class_method_signature": "MulticastSocketListenerThread.setRunning(boolean pRunning)", "testcase": false, "constructor": false}, {"identifier": "isRunning", "parameters": "()", "modifiers": "public synchronized", "return": "boolean", "signature": "boolean isRunning()", "full_signature": "public synchronized boolean isRunning()", "class_method_signature": "MulticastSocketListenerThread.isRunning()", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "public synchronized", "return": "void", "signature": "void shutdown()", "full_signature": "public synchronized void shutdown()", "class_method_signature": "MulticastSocketListenerThread.shutdown()", "testcase": false, "constructor": false}, {"identifier": "shouldMessageBeProcessed", "parameters": "(DiscoveryIncomingMessage pMsg)", "modifiers": "private", "return": "boolean", "signature": "boolean shouldMessageBeProcessed(DiscoveryIncomingMessage pMsg)", "full_signature": "private boolean shouldMessageBeProcessed(DiscoveryIncomingMessage pMsg)", "class_method_signature": "MulticastSocketListenerThread.shouldMessageBeProcessed(DiscoveryIncomingMessage pMsg)", "testcase": false, "constructor": false}, {"identifier": "receiveMessage", "parameters": "()", "modifiers": "private", "return": "DiscoveryIncomingMessage", "signature": "DiscoveryIncomingMessage receiveMessage()", "full_signature": "private DiscoveryIncomingMessage receiveMessage()", "class_method_signature": "MulticastSocketListenerThread.receiveMessage()", "testcase": false, "constructor": false}, {"identifier": "refreshSocket", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void refreshSocket()", "full_signature": "private void refreshSocket()", "class_method_signature": "MulticastSocketListenerThread.refreshSocket()", "testcase": false, "constructor": false}, {"identifier": "handleQuery", "parameters": "(DiscoveryIncomingMessage pMsg)", "modifiers": "private", "return": "void", "signature": "void handleQuery(DiscoveryIncomingMessage pMsg)", "full_signature": "private void handleQuery(DiscoveryIncomingMessage pMsg)", "class_method_signature": "MulticastSocketListenerThread.handleQuery(DiscoveryIncomingMessage pMsg)", "testcase": false, "constructor": false}, {"identifier": "send", "parameters": "(DiscoveryOutgoingMessage pAnswer)", "modifiers": "private", "return": "void", "signature": "void send(DiscoveryOutgoingMessage pAnswer)", "full_signature": "private void send(DiscoveryOutgoingMessage pAnswer)", "class_method_signature": "MulticastSocketListenerThread.send(DiscoveryOutgoingMessage pAnswer)", "testcase": false, "constructor": false}], "file": "agent/core/src/main/java/org/jolokia/discovery/MulticastSocketListenerThread.java"}, "focal_method": {"identifier": "shutdown", "parameters": "()", "modifiers": "public synchronized", "return": "void", "body": "public synchronized void shutdown() {\n        setRunning(false);\n        interrupt();\n        socket.close();\n    }", "signature": "void shutdown()", "full_signature": "public synchronized void shutdown()", "class_method_signature": "MulticastSocketListenerThread.shutdown()", "testcase": false, "constructor": false, "invocations": ["setRunning", "interrupt", "close"]}, "repository": {"repo_id": 777444, "url": "https://github.com/rhuss/jolokia", "language": "Java", "is_fork": false, "fork_count": 187, "stargazer_count": 682, "size": 20451, "license": "licensed"}}