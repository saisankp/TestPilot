{"test_class": {"identifier": "Level0MergerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static String testDir = TestUtil.TEST_BASE_DIR + \"sdb/unit/level_0_merger_test\";", "modifier": "private static", "type": "String", "declarator": "testDir = TestUtil.TEST_BASE_DIR + \"sdb/unit/level_0_merger_test\"", "var_name": "testDir"}], "file": "zava/src/test/java/com/ctriposs/sdb/merge/Level0MergerTest.java"}, "test_case": {"identifier": "testCase01", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testCase01() throws IOException, ClassNotFoundException {\n\t\t\n\t\tString value = TestUtil.randomString(128);\n\t\t\n\t\tHashMapTable[] sourceTables = new HashMapTable[4];\n\t\tLevelQueue lq0 = new LevelQueue();\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tsourceTables[i] = new HashMapTable(testDir, SDB.LEVEL0, System.nanoTime() + i);\n\t\t\tsourceTables[i].setCompressionEnabled(true);\n\t\t\tlq0.addFirst(sourceTables[i]);\n\t\t\tassertTrue(sourceTables[i].isImmutable());\n\t\t}\n\t\t\n\t\tint totalCount = 0;\n\t\tint max = 0;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tint start = i;\n\t\t\tHashMapTable table = sourceTables[i];\n\t\t\twhile(table.put(String.valueOf(start).getBytes(), value.getBytes(), AbstractMapTable.NO_TIMEOUT, System.currentTimeMillis(), false)) {\n\t\t\t\ttotalCount++;\n\t\t\t\tif (start > max) max = start;\n\t\t\t\tstart = start + 4;\n\t\t\t}\n\t\t}\n\t\t\n\t\tLevelQueue lq1 = new LevelQueue();\n\t\t\n\t\tlong start = System.currentTimeMillis();\n\t\tLevel0Merger.mergeSort(lq0, lq1, 4, testDir, (short)1);\n\t\tlong end = System.currentTimeMillis();\n\t\tSystem.out.println(\"Time spent to merge \" + totalCount + \" items in 4 ways  is \" + (end - start) / 1000 + \"s\");\n\t\t\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tassertTrue(sourceTables[i].isImmutable());\n\t\t}\n\t\t\n\t\tassertTrue(lq1.size() == 1);\n\t\tMMFMapTable targetTable = (MMFMapTable) lq1.poll();\n\t\tassertTrue(targetTable.getLevel() == SDB.LEVEL1);\n\t\tassertTrue(targetTable.getAppendedSize() == totalCount);\n\t\t\n\t\tList<String> keyList = new ArrayList<String>();\n\t\tfor(long i = 0; i < totalCount; i++) {\n\t\t\tkeyList.add(String.valueOf(i));\n\t\t}\n\t\tCollections.sort(keyList, new Comparator<String>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(String arg0, String arg1) {\n\t\t\t\tint hash0 = Arrays.hashCode(arg0.getBytes());\n\t\t\t\tint hash1 = Arrays.hashCode(arg1.getBytes());\n\t\t\t\tif (hash0 < hash1) return -1;\n\t\t\t\telse if (hash0 > hash1) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tfor(int i = 0; i < totalCount; i++) {\n\t\t\tIMapEntry mapEntry = targetTable.getMapEntry(i);\n\t\t\tassertTrue(mapEntry.getIndex() == i);\n\t\t\tassertTrue(new String(mapEntry.getKey()).equals(keyList.get(i)));\n\t\t\tassertTrue(new String(Snappy.uncompress(mapEntry.getValue())).equals(value));\n\t\t}\n\t\t\n\t\tstart = System.currentTimeMillis();\n\t\tRandom random = new Random();\n\t\tfor(int i = 0; i < 1024; i++) {\n\t\t\tlong key = random.nextInt(totalCount);\n\t\t\tGetResult result = targetTable.get(String.valueOf(key).getBytes());\n\t\t\tassertTrue(result.isFound());\n\t\t}\n\t\tend = System.currentTimeMillis();\n\t\tSystem.out.println(\"Time to lookup 1024 random key in the target table is \" + (end - start) + \"ms\");\n\t\t\n\t\ttargetTable.close();\n\t\ttargetTable.delete();\n\t}", "signature": "void testCase01()", "full_signature": "@Test public void testCase01()", "class_method_signature": "Level0MergerTest.testCase01()", "testcase": true, "constructor": false, "invocations": ["randomString", "nanoTime", "setCompressionEnabled", "addFirst", "assertTrue", "isImmutable", "put", "getBytes", "valueOf", "getBytes", "currentTimeMillis", "currentTimeMillis", "mergeSort", "currentTimeMillis", "println", "assertTrue", "isImmutable", "assertTrue", "size", "poll", "assertTrue", "getLevel", "assertTrue", "getAppendedSize", "add", "valueOf", "sort", "hashCode", "getBytes", "hashCode", "getBytes", "getMapEntry", "assertTrue", "getIndex", "assertTrue", "equals", "getKey", "get", "assertTrue", "equals", "uncompress", "getValue", "currentTimeMillis", "nextInt", "get", "getBytes", "valueOf", "assertTrue", "isFound", "currentTimeMillis", "println", "close", "delete"]}, "focal_class": {"identifier": "Level0Merger", "superclass": "extends Thread", "interfaces": "", "fields": [{"original_string": "static final Logger log = LoggerFactory.getLogger(Level0Merger.class);", "modifier": "static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(Level0Merger.class)", "var_name": "log"}, {"original_string": "private static final int MAX_SLEEP_TIME = 2 * 1000;", "modifier": "private static final", "type": "int", "declarator": "MAX_SLEEP_TIME = 2 * 1000", "var_name": "MAX_SLEEP_TIME"}, {"original_string": "public static final int DEFAULT_MERGE_WAYS = 2;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_MERGE_WAYS = 2", "var_name": "DEFAULT_MERGE_WAYS"}, {"original_string": "private List<LevelQueue> levelQueueList;", "modifier": "private", "type": "List<LevelQueue>", "declarator": "levelQueueList", "var_name": "levelQueueList"}, {"original_string": "private SDB sdb;", "modifier": "private", "type": "SDB", "declarator": "sdb", "var_name": "sdb"}, {"original_string": "private final SDBStats stats;", "modifier": "private final", "type": "SDBStats", "declarator": "stats", "var_name": "stats"}, {"original_string": "private volatile boolean stop = false;", "modifier": "private volatile", "type": "boolean", "declarator": "stop = false", "var_name": "stop"}, {"original_string": "private CountDownLatch countDownLatch;", "modifier": "private", "type": "CountDownLatch", "declarator": "countDownLatch", "var_name": "countDownLatch"}, {"original_string": "private short shard;", "modifier": "private", "type": "short", "declarator": "shard", "var_name": "shard"}], "methods": [{"identifier": "Level0Merger", "parameters": "(SDB sdb, List<LevelQueue> levelQueueList, CountDownLatch countDownLatch, short shard,\n                        SDBStats stats)", "modifiers": "public", "return": "", "signature": " Level0Merger(SDB sdb, List<LevelQueue> levelQueueList, CountDownLatch countDownLatch, short shard,\n                        SDBStats stats)", "full_signature": "public  Level0Merger(SDB sdb, List<LevelQueue> levelQueueList, CountDownLatch countDownLatch, short shard,\n                        SDBStats stats)", "class_method_signature": "Level0Merger.Level0Merger(SDB sdb, List<LevelQueue> levelQueueList, CountDownLatch countDownLatch, short shard,\n                        SDBStats stats)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "Level0Merger.run()", "testcase": false, "constructor": false}, {"identifier": "mergeSort", "parameters": "(LevelQueue source, LevelQueue target, int ways, String dir, short shard)", "modifiers": "public static", "return": "void", "signature": "void mergeSort(LevelQueue source, LevelQueue target, int ways, String dir, short shard)", "full_signature": "public static void mergeSort(LevelQueue source, LevelQueue target, int ways, String dir, short shard)", "class_method_signature": "Level0Merger.mergeSort(LevelQueue source, LevelQueue target, int ways, String dir, short shard)", "testcase": false, "constructor": false}, {"identifier": "setStop", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void setStop()", "full_signature": "public void setStop()", "class_method_signature": "Level0Merger.setStop()", "testcase": false, "constructor": false}], "file": "zava/src/main/java/com/ctriposs/sdb/merge/Level0Merger.java"}, "focal_method": {"identifier": "mergeSort", "parameters": "(LevelQueue source, LevelQueue target, int ways, String dir, short shard)", "modifiers": "public static", "return": "void", "body": "public static void mergeSort(LevelQueue source, LevelQueue target, int ways, String dir, short shard) throws IOException, ClassNotFoundException {\n\t\tList<HashMapTable> tables = new ArrayList<HashMapTable>(ways);\n\t\tsource.getReadLock().lock();\n\t\ttry {\n\t\t\tIterator<AbstractMapTable> iter = source.descendingIterator();\n\t\t\tfor(int i = 0; i < ways; i++) {\n\t\t\t\ttables.add((HashMapTable) iter.next());\n\t\t\t}\n\t\t} finally {\n\t\t\tsource.getReadLock().unlock();\n\t\t}\n\n\t\tint expectedInsertions = 0;\n\t\tfor(HashMapTable table : tables) {\n\t\t\texpectedInsertions += table.getRealSize();\n\t\t}\n\t\t// target table\n\t\tMMFMapTable sortedMapTable = new MMFMapTable(dir, shard, SDB.LEVEL1, System.nanoTime(), expectedInsertions, ways);\n\n\t\tPriorityQueue<QueueElement> pq = new PriorityQueue<QueueElement>();\n\t\t// build initial heap\n\t\tfor(HashMapTable table : tables) {\n\t\t\tQueueElement qe = new QueueElement();\n\t\t\tfinal HashMapTable hmTable = table;\n\t\t\tqe.hashMapTable = hmTable;\n\t\t\tList<Map.Entry<ByteArrayWrapper, InMemIndex>> list = new ArrayList<Map.Entry<ByteArrayWrapper, InMemIndex>>(qe.hashMapTable.getEntrySet());\n\t\t\tCollections.sort(list, new Comparator<Map.Entry<ByteArrayWrapper, InMemIndex>>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(\n\t\t\t\t\t\tEntry<ByteArrayWrapper, InMemIndex> o1,\n\t\t\t\t\t\tEntry<ByteArrayWrapper, InMemIndex> o2) {\n\t\t\t\t\tIMapEntry mapEntry1 = hmTable.getMapEntry(o1.getValue().getIndex());\n\t\t\t\t\tIMapEntry mapEntry2 = hmTable.getMapEntry(o2.getValue().getIndex());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint hash1 = mapEntry1.getKeyHash();\n\t\t\t\t\t\tint hash2 = mapEntry2.getKeyHash();\n\t\t\t\t\t\tif (hash1 < hash2) return -1;\n\t\t\t\t\t\telse if (hash1 > hash2) return 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn o1.getKey().compareTo(o2.getKey());\n\t\t\t\t\t    }\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new RuntimeException(\"Fail to get hash code in map entry\", e);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t});\n\t\t\tqe.iterator = list.iterator();\n\t\t\tif (qe.iterator.hasNext()) {\n\t\t\t\tMap.Entry<ByteArrayWrapper, InMemIndex> me = qe.iterator.next();\n\t\t\t\tqe.key = me.getKey().getData();\n\t\t\t\tqe.inMemIndex = me.getValue();\n\t\t\t\tIMapEntry mapEntry = table.getMapEntry(qe.inMemIndex.getIndex());\n\t\t\t\tqe.keyHash = mapEntry.getKeyHash();\n\t\t\t\tpq.add(qe);\n\t\t\t}\n\t\t}\n\n\t\t// merge sort\n\t\twhile(pq.size() > 0) {\n\t\t\tQueueElement qe1 = pq.poll();\n\t\t\t// remove old/stale entries\n\t\t\twhile(pq.peek() != null && qe1.keyHash == pq.peek().keyHash && BytesUtil.compare(qe1.key, pq.peek().key) == 0) {\n\t\t\t\tQueueElement qe2 = pq.poll();\n\t\t\t\tif (qe2.iterator.hasNext()) {\n\t\t\t\t\tMap.Entry<ByteArrayWrapper, InMemIndex> me = qe2.iterator.next();\n\t\t\t\t\tqe2.key = me.getKey().getData();\n\t\t\t\t\tqe2.inMemIndex = me.getValue();\n\t\t\t\t\tIMapEntry mapEntry = qe2.hashMapTable.getMapEntry(qe2.inMemIndex.getIndex());\n\t\t\t\t\tqe2.keyHash = mapEntry.getKeyHash();\n\t\t\t\t\tpq.add(qe2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIMapEntry mapEntry = qe1.hashMapTable.getMapEntry(qe1.inMemIndex.getIndex());\n\t\t\tbyte[] value = mapEntry.getValue();\n\t\t\t// disk space optimization\n\t\t\tif (mapEntry.isDeleted() || mapEntry.isExpired()) {\n\t\t\t\tvalue = new byte[] {0};\n\t\t\t}\n\t\t\tsortedMapTable.appendNew(mapEntry.getKey(), mapEntry.getKeyHash(), value, mapEntry.getTimeToLive(), mapEntry.getCreatedTime(), mapEntry.isDeleted(), mapEntry.isCompressed());\n\n\t\t\tif (qe1.iterator.hasNext()) {\n\t\t\t\tMap.Entry<ByteArrayWrapper, InMemIndex> me = qe1.iterator.next();\n\t\t\t\tqe1.key = me.getKey().getData();\n\t\t\t\tqe1.inMemIndex = me.getValue();\n\t\t\t\tIMapEntry mEntry = qe1.hashMapTable.getMapEntry(qe1.inMemIndex.getIndex());\n\t\t\t\tqe1.keyHash = mEntry.getKeyHash();\n\t\t\t\tpq.add(qe1);\n\t\t\t}\n\t\t}\n\n\t\t// persist metadata\n\t\tsortedMapTable.reMap();\n\t\tsortedMapTable.saveMetadata();\n\n\t\t// dump to level 1\n\t\tsource.getWriteLock().lock();\n\t\ttarget.getWriteLock().lock();\n\t\ttry {\n\t\t\tfor(int i = 0; i < ways; i++) {\n\t\t\t\tsource.removeLast();\n\t\t\t}\n\t\t\tfor(HashMapTable table : tables) {\n\t\t\t\ttable.markUsable(false);\n\t\t\t}\n\n\t\t\tsortedMapTable.markUsable(true);\n\t\t\ttarget.addFirst(sortedMapTable);\n\n\t\t} finally {\n\t\t\ttarget.getWriteLock().unlock();\n\t\t\tsource.getWriteLock().unlock();\n\t\t}\n\n\t\tfor(HashMapTable table : tables) {\n\t\t\ttable.close();\n\t\t\ttable.delete();\n\t\t}\n\t}", "signature": "void mergeSort(LevelQueue source, LevelQueue target, int ways, String dir, short shard)", "full_signature": "public static void mergeSort(LevelQueue source, LevelQueue target, int ways, String dir, short shard)", "class_method_signature": "Level0Merger.mergeSort(LevelQueue source, LevelQueue target, int ways, String dir, short shard)", "testcase": false, "constructor": false, "invocations": ["lock", "getReadLock", "descendingIterator", "add", "next", "unlock", "getReadLock", "getRealSize", "nanoTime", "getEntrySet", "sort", "getMapEntry", "getIndex", "getValue", "getMapEntry", "getIndex", "getValue", "getKeyHash", "getKeyHash", "compareTo", "getKey", "getKey", "iterator", "hasNext", "next", "getData", "getKey", "getValue", "getMapEntry", "getIndex", "getKeyHash", "add", "size", "poll", "peek", "peek", "compare", "peek", "poll", "hasNext", "next", "getData", "getKey", "getValue", "getMapEntry", "getIndex", "getKeyHash", "add", "getMapEntry", "getIndex", "getValue", "isDeleted", "isExpired", "appendNew", "getKey", "getKeyHash", "getTimeToLive", "getCreatedTime", "isDeleted", "isCompressed", "hasNext", "next", "getData", "getKey", "getValue", "getMapEntry", "getIndex", "getKeyHash", "add", "reMap", "saveMetadata", "lock", "getWriteLock", "lock", "getWriteLock", "removeLast", "markUsable", "markUsable", "addFirst", "unlock", "getWriteLock", "unlock", "getWriteLock", "close", "delete"]}, "repository": {"repo_id": 33645537, "url": "https://github.com/zqhxuyuan/tutorials", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 5, "size": 35273, "license": "licensed"}}