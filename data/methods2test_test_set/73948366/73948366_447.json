{"test_class": {"identifier": "InstanceZTSProviderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private String servicePublicKeyStringK0 = null;", "modifier": "private", "type": "String", "declarator": "servicePublicKeyStringK0 = null", "var_name": "servicePublicKeyStringK0"}, {"original_string": "private String servicePrivateKeyStringK0 = null;", "modifier": "private", "type": "String", "declarator": "servicePrivateKeyStringK0 = null", "var_name": "servicePrivateKeyStringK0"}], "file": "libs/java/instance_provider/src/test/java/com/yahoo/athenz/instance/provider/impl/InstanceZTSProviderTest.java"}, "test_case": {"identifier": "testConfirmInstance", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testConfirmInstance() {\n\n        KeyStore keystore = Mockito.mock(KeyStore.class);\n        Mockito.when(keystore.getPublicKey(\"sports\", \"api\", \"v0\")).thenReturn(servicePublicKeyStringK0);\n\n        System.setProperty(InstanceZTSProvider.ZTS_PRINCIPAL_LIST, \"sports.api\");\n\n        InstanceZTSProvider provider = new InstanceZTSProvider();\n        provider.initialize(\"provider\", \"com.yahoo.athenz.instance.provider.impl.InstanceZTSProvider\", null, keystore);\n\n        PrincipalToken tokenToSign = new PrincipalToken.Builder(\"1\", \"sports\", \"api\")\n                .keyId(\"v0\").salt(\"salt\").issueTime(System.currentTimeMillis() / 1000)\n                .expirationWindow(3600).build();\n        tokenToSign.sign(servicePrivateKeyStringK0);\n\n        InstanceConfirmation confirmation = new InstanceConfirmation();\n        confirmation.setAttestationData(tokenToSign.getSignedToken());\n        confirmation.setDomain(\"sports\");\n        confirmation.setService(\"api\");\n        confirmation.setProvider(\"sys.auth.zts\");\n\n        Map<String, String> attributes = new HashMap<>();\n        attributes.put(InstanceProvider.ZTS_INSTANCE_SAN_DNS, \"api.sports.zts.athenz.cloud,inst1.instanceid.athenz.zts.athenz.cloud\");\n        attributes.put(InstanceProvider.ZTS_INSTANCE_CSR_PUBLIC_KEY, servicePublicKeyStringK0);\n        confirmation.setAttributes(attributes);\n\n        assertNotNull(provider.confirmInstance(confirmation));\n        provider.close();\n        System.clearProperty(InstanceZTSProvider.ZTS_PRINCIPAL_LIST);\n    }", "signature": "void testConfirmInstance()", "full_signature": "@Test public void testConfirmInstance()", "class_method_signature": "InstanceZTSProviderTest.testConfirmInstance()", "testcase": true, "constructor": false, "invocations": ["mock", "thenReturn", "when", "getPublicKey", "setProperty", "initialize", "build", "expirationWindow", "issueTime", "salt", "keyId", "currentTimeMillis", "sign", "setAttestationData", "getSignedToken", "setDomain", "setService", "setProvider", "put", "put", "setAttributes", "assertNotNull", "confirmInstance", "close", "clearProperty"]}, "focal_class": {"identifier": "InstanceZTSProvider", "superclass": "", "interfaces": "implements InstanceProvider", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(InstanceZTSProvider.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(InstanceZTSProvider.class)", "var_name": "LOGGER"}, {"original_string": "private static final Pattern WHITESPACE_PATTERN = Pattern.compile(\"\\\\s+\");", "modifier": "private static final", "type": "Pattern", "declarator": "WHITESPACE_PATTERN = Pattern.compile(\"\\\\s+\")", "var_name": "WHITESPACE_PATTERN"}, {"original_string": "private static final String URI_HOSTNAME_PREFIX = \"athenz://hostname/\";", "modifier": "private static final", "type": "String", "declarator": "URI_HOSTNAME_PREFIX = \"athenz://hostname/\"", "var_name": "URI_HOSTNAME_PREFIX"}, {"original_string": "static final String ZTS_PROVIDER_DNS_SUFFIX  = \"athenz.zts.provider_dns_suffix\";", "modifier": "static final", "type": "String", "declarator": "ZTS_PROVIDER_DNS_SUFFIX  = \"athenz.zts.provider_dns_suffix\"", "var_name": "ZTS_PROVIDER_DNS_SUFFIX"}, {"original_string": "static final String ZTS_PRINCIPAL_LIST       = \"athenz.zts.provider_service_list\";", "modifier": "static final", "type": "String", "declarator": "ZTS_PRINCIPAL_LIST       = \"athenz.zts.provider_service_list\"", "var_name": "ZTS_PRINCIPAL_LIST"}, {"original_string": "KeyStore keyStore = null;", "modifier": "", "type": "KeyStore", "declarator": "keyStore = null", "var_name": "keyStore"}, {"original_string": "String dnsSuffix = null;", "modifier": "", "type": "String", "declarator": "dnsSuffix = null", "var_name": "dnsSuffix"}, {"original_string": "Set<String> principals = null;", "modifier": "", "type": "Set<String>", "declarator": "principals = null", "var_name": "principals"}, {"original_string": "HostnameResolver hostnameResolver = null;", "modifier": "", "type": "HostnameResolver", "declarator": "hostnameResolver = null", "var_name": "hostnameResolver"}], "methods": [{"identifier": "getProviderScheme", "parameters": "()", "modifiers": "@Override public", "return": "Scheme", "signature": "Scheme getProviderScheme()", "full_signature": "@Override public Scheme getProviderScheme()", "class_method_signature": "InstanceZTSProvider.getProviderScheme()", "testcase": false, "constructor": false}, {"identifier": "initialize", "parameters": "(String provider, String providerEndpoint, SSLContext sslContext,\n            KeyStore keyStore)", "modifiers": "@Override public", "return": "void", "signature": "void initialize(String provider, String providerEndpoint, SSLContext sslContext,\n            KeyStore keyStore)", "full_signature": "@Override public void initialize(String provider, String providerEndpoint, SSLContext sslContext,\n            KeyStore keyStore)", "class_method_signature": "InstanceZTSProvider.initialize(String provider, String providerEndpoint, SSLContext sslContext,\n            KeyStore keyStore)", "testcase": false, "constructor": false}, {"identifier": "setHostnameResolver", "parameters": "(HostnameResolver hostnameResolver)", "modifiers": "@Override public", "return": "void", "signature": "void setHostnameResolver(HostnameResolver hostnameResolver)", "full_signature": "@Override public void setHostnameResolver(HostnameResolver hostnameResolver)", "class_method_signature": "InstanceZTSProvider.setHostnameResolver(HostnameResolver hostnameResolver)", "testcase": false, "constructor": false}, {"identifier": "forbiddenError", "parameters": "(String message)", "modifiers": "private", "return": "ResourceException", "signature": "ResourceException forbiddenError(String message)", "full_signature": "private ResourceException forbiddenError(String message)", "class_method_signature": "InstanceZTSProvider.forbiddenError(String message)", "testcase": false, "constructor": false}, {"identifier": "confirmInstance", "parameters": "(InstanceConfirmation confirmation)", "modifiers": "@Override public", "return": "InstanceConfirmation", "signature": "InstanceConfirmation confirmInstance(InstanceConfirmation confirmation)", "full_signature": "@Override public InstanceConfirmation confirmInstance(InstanceConfirmation confirmation)", "class_method_signature": "InstanceZTSProvider.confirmInstance(InstanceConfirmation confirmation)", "testcase": false, "constructor": false}, {"identifier": "refreshInstance", "parameters": "(InstanceConfirmation confirmation)", "modifiers": "@Override public", "return": "InstanceConfirmation", "signature": "InstanceConfirmation refreshInstance(InstanceConfirmation confirmation)", "full_signature": "@Override public InstanceConfirmation refreshInstance(InstanceConfirmation confirmation)", "class_method_signature": "InstanceZTSProvider.refreshInstance(InstanceConfirmation confirmation)", "testcase": false, "constructor": false}, {"identifier": "validateSanIp", "parameters": "(final String[] sanIps, final String clientIp)", "modifiers": "", "return": "boolean", "signature": "boolean validateSanIp(final String[] sanIps, final String clientIp)", "full_signature": " boolean validateSanIp(final String[] sanIps, final String clientIp)", "class_method_signature": "InstanceZTSProvider.validateSanIp(final String[] sanIps, final String clientIp)", "testcase": false, "constructor": false}, {"identifier": "validateHostname", "parameters": "(final String hostname, final String[] sanIps)", "modifiers": "", "return": "boolean", "signature": "boolean validateHostname(final String hostname, final String[] sanIps)", "full_signature": " boolean validateHostname(final String hostname, final String[] sanIps)", "class_method_signature": "InstanceZTSProvider.validateHostname(final String hostname, final String[] sanIps)", "testcase": false, "constructor": false}, {"identifier": "validateSanUri", "parameters": "(final String sanUri, final String hostname)", "modifiers": "", "return": "boolean", "signature": "boolean validateSanUri(final String sanUri, final String hostname)", "full_signature": " boolean validateSanUri(final String sanUri, final String hostname)", "class_method_signature": "InstanceZTSProvider.validateSanUri(final String sanUri, final String hostname)", "testcase": false, "constructor": false}, {"identifier": "validateToken", "parameters": "(final String signedToken, final String domainName,\n            final String serviceName, final String csrPublicKey, StringBuilder errMsg)", "modifiers": "", "return": "boolean", "signature": "boolean validateToken(final String signedToken, final String domainName,\n            final String serviceName, final String csrPublicKey, StringBuilder errMsg)", "full_signature": " boolean validateToken(final String signedToken, final String domainName,\n            final String serviceName, final String csrPublicKey, StringBuilder errMsg)", "class_method_signature": "InstanceZTSProvider.validateToken(final String signedToken, final String domainName,\n            final String serviceName, final String csrPublicKey, StringBuilder errMsg)", "testcase": false, "constructor": false}, {"identifier": "authenticate", "parameters": "(final String signedToken, KeyStore keyStore,\n            final String csrPublicKey, StringBuilder errMsg)", "modifiers": "", "return": "PrincipalToken", "signature": "PrincipalToken authenticate(final String signedToken, KeyStore keyStore,\n            final String csrPublicKey, StringBuilder errMsg)", "full_signature": " PrincipalToken authenticate(final String signedToken, KeyStore keyStore,\n            final String csrPublicKey, StringBuilder errMsg)", "class_method_signature": "InstanceZTSProvider.authenticate(final String signedToken, KeyStore keyStore,\n            final String csrPublicKey, StringBuilder errMsg)", "testcase": false, "constructor": false}, {"identifier": "validatePublicKeys", "parameters": "(final String athenzPublicKey, final String csrPublicKey)", "modifiers": "public", "return": "boolean", "signature": "boolean validatePublicKeys(final String athenzPublicKey, final String csrPublicKey)", "full_signature": "public boolean validatePublicKeys(final String athenzPublicKey, final String csrPublicKey)", "class_method_signature": "InstanceZTSProvider.validatePublicKeys(final String athenzPublicKey, final String csrPublicKey)", "testcase": false, "constructor": false}], "file": "libs/java/instance_provider/src/main/java/com/yahoo/athenz/instance/provider/impl/InstanceZTSProvider.java"}, "focal_method": {"identifier": "confirmInstance", "parameters": "(InstanceConfirmation confirmation)", "modifiers": "@Override public", "return": "InstanceConfirmation", "body": "@Override\n    public InstanceConfirmation confirmInstance(InstanceConfirmation confirmation) {\n\n        // we need to validate the token which is our attestation\n        // data for the service requesting a certificate\n\n        final String instanceDomain = confirmation.getDomain();\n        final String instanceService = confirmation.getService();\n\n        final Map<String, String> instanceAttributes = confirmation.getAttributes();\n        final String csrPublicKey = InstanceUtils.getInstanceProperty(instanceAttributes,\n                InstanceProvider.ZTS_INSTANCE_CSR_PUBLIC_KEY);\n\n        // make sure this service has been configured to be supported\n        // by this zts provider\n\n        if (principals != null && !principals.contains(instanceDomain + \".\" + instanceService)) {\n            throw forbiddenError(\"Service not supported to be launched by ZTS Provider\");\n        }\n\n        StringBuilder errMsg = new StringBuilder(256);\n        if (!validateToken(confirmation.getAttestationData(), instanceDomain,\n                instanceService, csrPublicKey, errMsg)) {\n            LOGGER.error(errMsg.toString());\n            throw forbiddenError(\"Unable to validate Certificate Request Auth Token\");\n        }\n\n        String clientIp = InstanceUtils.getInstanceProperty(instanceAttributes, InstanceProvider.ZTS_INSTANCE_CLIENT_IP);\n        String sanIpStr = InstanceUtils.getInstanceProperty(instanceAttributes, InstanceProvider.ZTS_INSTANCE_SAN_IP);\n        String hostname = InstanceUtils.getInstanceProperty(instanceAttributes, InstanceProvider.ZTS_INSTANCE_HOSTNAME);\n        String sanUri   = InstanceUtils.getInstanceProperty(instanceAttributes, InstanceProvider.ZTS_INSTANCE_SAN_URI);\n\n        // validate the IP address if one is provided\n\n        String[] sanIps = null;\n        if (sanIpStr != null && !sanIpStr.isEmpty()) {\n            sanIps = sanIpStr.split(\",\");\n        }\n\n        if (!validateSanIp(sanIps, clientIp)) {\n            throw forbiddenError(\"Unable to validate request IP address\");\n        }\n\n        // validate the hostname in payload\n        // IP in clientIP can be NATed. For validating hostname, rely on sanIPs, which come from the client, and are already matched with clientIp\n\n        if (!validateHostname(hostname, sanIps)) {\n            throw forbiddenError(\"Unable to validate certificate request hostname\");\n        }\n\n        // validate san URI\n        if (!validateSanUri(sanUri, hostname)) {\n            throw forbiddenError(\"Unable to validate certificate request URI hostname\");\n        }\n\n        // validate the certificate san DNS names\n\n        StringBuilder instanceId = new StringBuilder(256);\n        if (!InstanceUtils.validateCertRequestSanDnsNames(instanceAttributes, instanceDomain,\n                instanceService, dnsSuffix, instanceId)) {\n            throw forbiddenError(\"Unable to validate certificate request DNS\");\n        }\n\n        // set our cert attributes in the return object\n        // for ZTS we do not allow refresh of those certificates\n\n        Map<String, String> attributes = new HashMap<>();\n        attributes.put(InstanceProvider.ZTS_CERT_REFRESH, \"false\");\n\n        confirmation.setAttributes(attributes);\n        return confirmation;\n    }", "signature": "InstanceConfirmation confirmInstance(InstanceConfirmation confirmation)", "full_signature": "@Override public InstanceConfirmation confirmInstance(InstanceConfirmation confirmation)", "class_method_signature": "InstanceZTSProvider.confirmInstance(InstanceConfirmation confirmation)", "testcase": false, "constructor": false, "invocations": ["getDomain", "getService", "getAttributes", "getInstanceProperty", "contains", "forbiddenError", "validateToken", "getAttestationData", "error", "toString", "forbiddenError", "getInstanceProperty", "getInstanceProperty", "getInstanceProperty", "getInstanceProperty", "isEmpty", "split", "validateSanIp", "forbiddenError", "validateHostname", "forbiddenError", "validateSanUri", "forbiddenError", "validateCertRequestSanDnsNames", "forbiddenError", "put", "setAttributes"]}, "repository": {"repo_id": 73948366, "url": "https://github.com/yahoo/athenz", "stars": 394, "created": "11/16/2016 6:23:08 PM +00:00", "updates": "2020-01-27T15:36:13+00:00", "fork": "False", "license": "licensed"}}