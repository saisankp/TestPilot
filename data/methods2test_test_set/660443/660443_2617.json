{"test_class": {"identifier": "AbstractVFStateTest", "superclass": "", "interfaces": "", "fields": [], "file": "base/isomorphism/src/test/java/org/openscience/cdk/isomorphism/AbstractVFStateTest.java"}, "test_case": {"identifier": "nextNTerminal", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void nextNTerminal() {\n        AbstractVFState state = create(5, 10);\n        state.size = 2;\n        state.m1[0] = 1;\n        state.m1[1] = 0;\n        state.t1[4] = 1; // <- first terminal\n        assertThat(state.nextN(-1), is(4));\n    }", "signature": "void nextNTerminal()", "full_signature": "@Test public void nextNTerminal()", "class_method_signature": "AbstractVFStateTest.nextNTerminal()", "testcase": true, "constructor": false, "invocations": ["create", "assertThat", "nextN", "is"]}, "focal_class": {"identifier": "AbstractVFState", "superclass": "extends State", "interfaces": "", "fields": [{"original_string": "protected static final int UNMAPPED = -1;", "modifier": "protected static final", "type": "int", "declarator": "UNMAPPED = -1", "var_name": "UNMAPPED"}, {"original_string": "protected final int[][]    g1, g2;", "modifier": "protected final", "type": "int[][]", "declarator": "g1", "var_name": "g1"}, {"original_string": "protected final int[]      m1, m2;", "modifier": "protected final", "type": "int[]", "declarator": "m1", "var_name": "m1"}, {"original_string": "protected final int[]      t1, t2;", "modifier": "protected final", "type": "int[]", "declarator": "t1", "var_name": "t1"}, {"original_string": "protected int              size;", "modifier": "protected", "type": "int", "declarator": "size", "var_name": "size"}], "methods": [{"identifier": "AbstractVFState", "parameters": "(final int[][] g1, final int[][] g2)", "modifiers": "public", "return": "", "signature": " AbstractVFState(final int[][] g1, final int[][] g2)", "full_signature": "public  AbstractVFState(final int[][] g1, final int[][] g2)", "class_method_signature": "AbstractVFState.AbstractVFState(final int[][] g1, final int[][] g2)", "testcase": false, "constructor": true}, {"identifier": "nextN", "parameters": "(int n)", "modifiers": "@Override final", "return": "int", "signature": "int nextN(int n)", "full_signature": "@Override final int nextN(int n)", "class_method_signature": "AbstractVFState.nextN(int n)", "testcase": false, "constructor": false}, {"identifier": "nextM", "parameters": "(int n, int m)", "modifiers": "@Override final", "return": "int", "signature": "int nextM(int n, int m)", "full_signature": "@Override final int nextM(int n, int m)", "class_method_signature": "AbstractVFState.nextM(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "nMax", "parameters": "()", "modifiers": "@Override final", "return": "int", "signature": "int nMax()", "full_signature": "@Override final int nMax()", "class_method_signature": "AbstractVFState.nMax()", "testcase": false, "constructor": false}, {"identifier": "mMax", "parameters": "()", "modifiers": "@Override final", "return": "int", "signature": "int mMax()", "full_signature": "@Override final int mMax()", "class_method_signature": "AbstractVFState.mMax()", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(int n, int m)", "modifiers": "@Override final", "return": "boolean", "signature": "boolean add(int n, int m)", "full_signature": "@Override final boolean add(int n, int m)", "class_method_signature": "AbstractVFState.add(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(int n, int m)", "modifiers": "@Override final", "return": "void", "signature": "void remove(int n, int m)", "full_signature": "@Override final void remove(int n, int m)", "class_method_signature": "AbstractVFState.remove(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "feasible", "parameters": "(int n, int m)", "modifiers": "abstract", "return": "boolean", "signature": "boolean feasible(int n, int m)", "full_signature": "abstract boolean feasible(int n, int m)", "class_method_signature": "AbstractVFState.feasible(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "mapping", "parameters": "()", "modifiers": "@Override", "return": "int[]", "signature": "int[] mapping()", "full_signature": "@Override int[] mapping()", "class_method_signature": "AbstractVFState.mapping()", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "@Override", "return": "int", "signature": "int size()", "full_signature": "@Override int size()", "class_method_signature": "AbstractVFState.size()", "testcase": false, "constructor": false}], "file": "base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/AbstractVFState.java"}, "focal_method": {"identifier": "nextN", "parameters": "(int n)", "modifiers": "@Override final", "return": "int", "body": "@Override\n    final int nextN(int n) {\n        if (size == 0) return 0;\n        for (int i = n + 1; i < g1.length; i++)\n            if (m1[i] == UNMAPPED && t1[i] > 0) return i;\n        for (int i = n + 1; i < g1.length; i++)\n            if (m1[i] == UNMAPPED) return i;\n        return nMax();\n    }", "signature": "int nextN(int n)", "full_signature": "@Override final int nextN(int n)", "class_method_signature": "AbstractVFState.nextN(int n)", "testcase": false, "constructor": false, "invocations": ["nMax"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}