{"test_class": {"identifier": "RewindableReadableByteChannelTest", "superclass": "", "interfaces": "", "fields": [], "file": "java_src/src/test/java/com/google/crypto/tink/subtle/RewindableReadableByteChannelTest.java"}, "test_case": {"identifier": "testReadToLimit", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testReadToLimit() throws Exception {\n    byte[] inputData = \"The quick brown fox jumps over the lazy dog.\".getBytes(UTF_8);\n    ReadableByteChannel baseChannel = new ByteBufferChannel(inputData);\n    RewindableReadableByteChannel rewindableChannel =\n        new RewindableReadableByteChannel(baseChannel);\n\n    ByteBuffer buffer = ByteBuffer.allocate(40);\n    buffer.limit(10);\n    assertEquals(10, rewindableChannel.read(buffer));\n    buffer.limit(30);\n    assertEquals(20, rewindableChannel.read(buffer));\n    assertArrayEquals(Arrays.copyOf(buffer.array(), 30), Arrays.copyOf(inputData, 30));\n  }", "signature": "void testReadToLimit()", "full_signature": "@Test public void testReadToLimit()", "class_method_signature": "RewindableReadableByteChannelTest.testReadToLimit()", "testcase": true, "constructor": false, "invocations": ["getBytes", "allocate", "limit", "assertEquals", "read", "limit", "assertEquals", "read", "assertArrayEquals", "copyOf", "array", "copyOf"]}, "focal_class": {"identifier": "RewindableReadableByteChannel", "superclass": "", "interfaces": "implements ReadableByteChannel", "fields": [{"original_string": "@GuardedBy(\"this\")\n  final ReadableByteChannel baseChannel;", "modifier": "@GuardedBy(\"this\")\n  final", "type": "ReadableByteChannel", "declarator": "baseChannel", "var_name": "baseChannel"}, {"original_string": "@GuardedBy(\"this\")\n  ByteBuffer buffer;", "modifier": "@GuardedBy(\"this\")", "type": "ByteBuffer", "declarator": "buffer", "var_name": "buffer"}, {"original_string": "@GuardedBy(\"this\")\n  boolean canRewind;", "modifier": "@GuardedBy(\"this\")", "type": "boolean", "declarator": "canRewind", "var_name": "canRewind"}, {"original_string": "@GuardedBy(\"this\")\n  boolean directRead;", "modifier": "@GuardedBy(\"this\")", "type": "boolean", "declarator": "directRead", "var_name": "directRead"}], "methods": [{"identifier": "RewindableReadableByteChannel", "parameters": "(ReadableByteChannel baseChannel)", "modifiers": "public", "return": "", "signature": " RewindableReadableByteChannel(ReadableByteChannel baseChannel)", "full_signature": "public  RewindableReadableByteChannel(ReadableByteChannel baseChannel)", "class_method_signature": "RewindableReadableByteChannel.RewindableReadableByteChannel(ReadableByteChannel baseChannel)", "testcase": false, "constructor": true}, {"identifier": "disableRewinding", "parameters": "()", "modifiers": "public synchronized", "return": "void", "signature": "void disableRewinding()", "full_signature": "public synchronized void disableRewinding()", "class_method_signature": "RewindableReadableByteChannel.disableRewinding()", "testcase": false, "constructor": false}, {"identifier": "rewind", "parameters": "()", "modifiers": "public synchronized", "return": "void", "signature": "void rewind()", "full_signature": "public synchronized void rewind()", "class_method_signature": "RewindableReadableByteChannel.rewind()", "testcase": false, "constructor": false}, {"identifier": "setBufferLimit", "parameters": "(int newLimit)", "modifiers": "private synchronized", "return": "void", "signature": "void setBufferLimit(int newLimit)", "full_signature": "private synchronized void setBufferLimit(int newLimit)", "class_method_signature": "RewindableReadableByteChannel.setBufferLimit(int newLimit)", "testcase": false, "constructor": false}, {"identifier": "read", "parameters": "(ByteBuffer dst)", "modifiers": "@Override public synchronized", "return": "int", "signature": "int read(ByteBuffer dst)", "full_signature": "@Override public synchronized int read(ByteBuffer dst)", "class_method_signature": "RewindableReadableByteChannel.read(ByteBuffer dst)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void close()", "full_signature": "@Override public synchronized void close()", "class_method_signature": "RewindableReadableByteChannel.close()", "testcase": false, "constructor": false}, {"identifier": "isOpen", "parameters": "()", "modifiers": "@Override public synchronized", "return": "boolean", "signature": "boolean isOpen()", "full_signature": "@Override public synchronized boolean isOpen()", "class_method_signature": "RewindableReadableByteChannel.isOpen()", "testcase": false, "constructor": false}], "file": "java_src/src/main/java/com/google/crypto/tink/subtle/RewindableReadableByteChannel.java"}, "focal_method": {"identifier": "read", "parameters": "(ByteBuffer dst)", "modifiers": "@Override public synchronized", "return": "int", "body": "@Override\n  public synchronized int read(ByteBuffer dst) throws IOException {\n    if (directRead) {\n      return baseChannel.read(dst);\n    }\n    int bytesToReadCount = dst.remaining();\n    if (bytesToReadCount == 0) {\n      return 0;\n    }\n    if (buffer == null) {  // The first read, no cached data yet.\n      if (!canRewind) {\n        directRead = true;\n        return baseChannel.read(dst);\n      }\n      buffer = ByteBuffer.allocate(bytesToReadCount);\n      int baseReadResult = baseChannel.read(buffer);\n      // put buffer in draining mode\n      buffer.flip();\n      if (baseReadResult > 0) {\n        dst.put(buffer);\n      }\n      return baseReadResult;\n    }\n    // Subsequent read\n    if (buffer.remaining() >= bytesToReadCount) {\n      // buffer has all data needed.\n      // dst.put expects buffer.remaining() <= dst.remaining(). So we have to temporarily lower\n      // buffer.limit. Note that\n      // buffer.position() + bytesToReadCount <= buffer.position() + buffer.remaining()\n      // = buffer.position() + buffer.limit() - buffer.position() = buffer.limit().\n      int limit = buffer.limit();\n      buffer.limit(buffer.position() + bytesToReadCount);\n      dst.put(buffer);\n      buffer.limit(limit);\n      if (!canRewind && !buffer.hasRemaining()) {\n        buffer = null;\n        directRead = true;\n      }\n      return bytesToReadCount;\n    }\n    int bytesFromBufferCount = buffer.remaining();\n    int stillToReadCount = bytesToReadCount - bytesFromBufferCount;\n\n    // buffer is in draining mode.\n    int currentReadPos = buffer.position();\n    int contentLimit = buffer.limit();\n    // Put the buffer into into filling mode by hand. The filling should start right after the\n    // current limit, and at most stillToReadCount bytes should be written.\n    setBufferLimit(contentLimit + stillToReadCount);\n    buffer.position(contentLimit);\n    int baseReadResult = baseChannel.read(buffer);\n    // Put buffer in draining mode.\n    buffer.flip();\n    buffer.position(currentReadPos); // restore reading position.\n    dst.put(buffer);\n    if (bytesFromBufferCount == 0 && baseReadResult < 0) {\n      return -1;  // EOF\n    }\n    int bytesCount = buffer.position() - currentReadPos;\n    if (!canRewind && !buffer.hasRemaining()) {\n      buffer = null;\n      directRead = true;\n    }\n    return bytesCount;\n  }", "signature": "int read(ByteBuffer dst)", "full_signature": "@Override public synchronized int read(ByteBuffer dst)", "class_method_signature": "RewindableReadableByteChannel.read(ByteBuffer dst)", "testcase": false, "constructor": false, "invocations": ["read", "remaining", "read", "allocate", "read", "flip", "put", "remaining", "limit", "limit", "position", "put", "limit", "hasRemaining", "remaining", "position", "limit", "setBufferLimit", "position", "read", "flip", "position", "put", "position", "hasRemaining"]}, "repository": {"repo_id": 20570214, "url": "https://github.com/google/tink", "stars": 8884, "created": "6/6/2014 4:21:09 PM +00:00", "updates": "2020-01-27T11:52:16+00:00", "fork": "False", "license": "licensed"}}