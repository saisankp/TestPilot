{"test_class": {"identifier": "FileSystemBinaryStoreTest", "superclass": "extends AbstractBinaryStoreTest", "interfaces": "", "fields": [{"original_string": "protected static final int MIN_BINARY_SIZE = 20;", "modifier": "protected static final", "type": "int", "declarator": "MIN_BINARY_SIZE = 20", "var_name": "MIN_BINARY_SIZE"}, {"original_string": "public static final String[] CONTENT = new String[] {\n        \"Lorem ipsum\" + UUID.randomUUID().toString(),\n        \"Lorem ipsum pulvinar\" + UUID.randomUUID().toString(),\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent vel felis tellus, at pellentesque sem. \"\n        + UUID.randomUUID().toString(),\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec tortor nunc, blandit in tempor ut, venenatis ac magna. Vestibulum gravida.\"\n        + UUID.randomUUID().toString(),\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam volutpat tortor non eros bibendum vitae consectetur lacus eleifend. Mauris tempus.\"\n        + UUID.randomUUID().toString(),\n        \"Morbi pulvinar volutpat sem id sagittis. Vestibulum ornare urna at massa iaculis vitae tincidunt nisi volutpat. Suspendisse auctor gravida viverra.\"\n        + UUID.randomUUID().toString()};", "modifier": "public static final", "type": "String[]", "declarator": "CONTENT = new String[] {\n        \"Lorem ipsum\" + UUID.randomUUID().toString(),\n        \"Lorem ipsum pulvinar\" + UUID.randomUUID().toString(),\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent vel felis tellus, at pellentesque sem. \"\n        + UUID.randomUUID().toString(),\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec tortor nunc, blandit in tempor ut, venenatis ac magna. Vestibulum gravida.\"\n        + UUID.randomUUID().toString(),\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam volutpat tortor non eros bibendum vitae consectetur lacus eleifend. Mauris tempus.\"\n        + UUID.randomUUID().toString(),\n        \"Morbi pulvinar volutpat sem id sagittis. Vestibulum ornare urna at massa iaculis vitae tincidunt nisi volutpat. Suspendisse auctor gravida viverra.\"\n        + UUID.randomUUID().toString()}", "var_name": "CONTENT"}, {"original_string": "public static final String[] CONTENT_HASHES;", "modifier": "public static final", "type": "String[]", "declarator": "CONTENT_HASHES", "var_name": "CONTENT_HASHES"}, {"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(FileSystemBinaryStoreTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(FileSystemBinaryStoreTest.class)", "var_name": "LOGGER"}, {"original_string": "protected static File directory;", "modifier": "protected static", "type": "File", "declarator": "directory", "var_name": "directory"}, {"original_string": "protected static File trash;", "modifier": "protected static", "type": "File", "declarator": "trash", "var_name": "trash"}, {"original_string": "protected static FileSystemBinaryStore store;", "modifier": "protected static", "type": "FileSystemBinaryStore", "declarator": "store", "var_name": "store"}, {"original_string": "protected static boolean print = false;", "modifier": "protected static", "type": "boolean", "declarator": "print = false", "var_name": "print"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/value/binary/FileSystemBinaryStoreTest.java"}, "test_case": {"identifier": "multipleThreadsShouldReadTheSameFile", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void multipleThreadsShouldReadTheSameFile() throws Exception {\n        final String textBase = \"The quick brown fox jumps over the lazy dog\";\n        StringBuilder builder = new StringBuilder();\n        Random rand = new Random();\n        while (builder.length() <= MIN_BINARY_SIZE) {\n            builder.append(textBase.substring(0, rand.nextInt(textBase.length())));\n        }\n        final String text = builder.toString();\n        final Binary storedValue = store.storeValue(new ByteArrayInputStream(text.getBytes()), false);\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n        try {\n            Callable<String> readingTask = () -> {\n                File tempFile = File.createTempFile(\"test-binary-store\", \"bin\");\n                try {\n                    FileOutputStream fos = new FileOutputStream(tempFile);\n                    InputStream is = storedValue.getStream();\n                    byte[] buff = new byte[100];\n                    int available;\n                    while ((available = is.read(buff)) != -1) {\n                        fos.write(buff, 0, available);\n                    }\n                    fos.close();\n    \n                    return IoUtil.read(tempFile);\n                } finally {\n                    tempFile.delete();\n                }\n            };\n            List<Callable<String>> tasks = Arrays.asList(readingTask, readingTask, readingTask);\n            List<Future<String>> futures = executor.invokeAll(tasks, 5, TimeUnit.SECONDS);\n            for (Future<String> future : futures) {\n                assertEquals(text, future.get());\n            }\n        } finally {\n            executor.shutdownNow();\n        }\n    }", "signature": "void multipleThreadsShouldReadTheSameFile()", "full_signature": "@Test public void multipleThreadsShouldReadTheSameFile()", "class_method_signature": "FileSystemBinaryStoreTest.multipleThreadsShouldReadTheSameFile()", "testcase": true, "constructor": false, "invocations": ["length", "append", "substring", "nextInt", "length", "toString", "storeValue", "getBytes", "newFixedThreadPool", "createTempFile", "getStream", "read", "write", "close", "read", "delete", "asList", "invokeAll", "assertEquals", "get", "shutdownNow"]}, "focal_class": {"identifier": "FileSystemBinaryStore", "superclass": "extends AbstractBinaryStore", "interfaces": "", "fields": [{"original_string": "protected static final String TRASH_DIRECTORY_NAME = \"trash\";", "modifier": "protected static final", "type": "String", "declarator": "TRASH_DIRECTORY_NAME = \"trash\"", "var_name": "TRASH_DIRECTORY_NAME"}, {"original_string": "private static final String EXTRACTED_TEXT_SUFFIX = \"-extracted-text\";", "modifier": "private static final", "type": "String", "declarator": "EXTRACTED_TEXT_SUFFIX = \"-extracted-text\"", "var_name": "EXTRACTED_TEXT_SUFFIX"}, {"original_string": "private static final String MIME_TYPE_SUFFIX = \"-mime-type\";", "modifier": "private static final", "type": "String", "declarator": "MIME_TYPE_SUFFIX = \"-mime-type\"", "var_name": "MIME_TYPE_SUFFIX"}, {"original_string": "private static final String TEMP_FILE_PREFIX = \"ms-fs-binstore\";", "modifier": "private static final", "type": "String", "declarator": "TEMP_FILE_PREFIX = \"ms-fs-binstore\"", "var_name": "TEMP_FILE_PREFIX"}, {"original_string": "private static final String TEMP_FILE_SUFFIX = \"hashing\";", "modifier": "private static final", "type": "String", "declarator": "TEMP_FILE_SUFFIX = \"hashing\"", "var_name": "TEMP_FILE_SUFFIX"}, {"original_string": "private static final ConcurrentHashMap<String, FileSystemBinaryStore> INSTANCES = new ConcurrentHashMap<String, FileSystemBinaryStore>();", "modifier": "private static final", "type": "ConcurrentHashMap<String, FileSystemBinaryStore>", "declarator": "INSTANCES = new ConcurrentHashMap<String, FileSystemBinaryStore>()", "var_name": "INSTANCES"}, {"original_string": "private final File directory;", "modifier": "private final", "type": "File", "declarator": "directory", "var_name": "directory"}, {"original_string": "private final File trash;", "modifier": "private final", "type": "File", "declarator": "trash", "var_name": "trash"}, {"original_string": "private final NamedLocks locks = new NamedLocks();", "modifier": "private final", "type": "NamedLocks", "declarator": "locks = new NamedLocks()", "var_name": "locks"}, {"original_string": "private volatile boolean initialized = false;", "modifier": "private volatile", "type": "boolean", "declarator": "initialized = false", "var_name": "initialized"}], "methods": [{"identifier": "create", "parameters": "( File directory, File trash )", "modifiers": "public static", "return": "FileSystemBinaryStore", "signature": "FileSystemBinaryStore create( File directory, File trash )", "full_signature": "public static FileSystemBinaryStore create( File directory, File trash )", "class_method_signature": "FileSystemBinaryStore.create( File directory, File trash )", "testcase": false, "constructor": false}, {"identifier": "FileSystemBinaryStore", "parameters": "( File directory )", "modifiers": "protected", "return": "", "signature": " FileSystemBinaryStore( File directory )", "full_signature": "protected  FileSystemBinaryStore( File directory )", "class_method_signature": "FileSystemBinaryStore.FileSystemBinaryStore( File directory )", "testcase": false, "constructor": true}, {"identifier": "FileSystemBinaryStore", "parameters": "( File directory, File trash )", "modifiers": "protected", "return": "", "signature": " FileSystemBinaryStore( File directory, File trash )", "full_signature": "protected  FileSystemBinaryStore( File directory, File trash )", "class_method_signature": "FileSystemBinaryStore.FileSystemBinaryStore( File directory, File trash )", "testcase": false, "constructor": true}, {"identifier": "getDirectory", "parameters": "()", "modifiers": "public", "return": "File", "signature": "File getDirectory()", "full_signature": "public File getDirectory()", "class_method_signature": "FileSystemBinaryStore.getDirectory()", "testcase": false, "constructor": false}, {"identifier": "storeValue", "parameters": "( InputStream stream, boolean markAsUnused )", "modifiers": "@Override public", "return": "BinaryValue", "signature": "BinaryValue storeValue( InputStream stream, boolean markAsUnused )", "full_signature": "@Override public BinaryValue storeValue( InputStream stream, boolean markAsUnused )", "class_method_signature": "FileSystemBinaryStore.storeValue( InputStream stream, boolean markAsUnused )", "testcase": false, "constructor": false}, {"identifier": "saveTempFileToStore", "parameters": "( File tmpFile,\n                                             BinaryKey key,\n                                             long numberOfBytes )", "modifiers": "private", "return": "BinaryValue", "signature": "BinaryValue saveTempFileToStore( File tmpFile,\n                                             BinaryKey key,\n                                             long numberOfBytes )", "full_signature": "private BinaryValue saveTempFileToStore( File tmpFile,\n                                             BinaryKey key,\n                                             long numberOfBytes )", "class_method_signature": "FileSystemBinaryStore.saveTempFileToStore( File tmpFile,\n                                             BinaryKey key,\n                                             long numberOfBytes )", "testcase": false, "constructor": false}, {"identifier": "sleep", "parameters": "( long millis )", "modifiers": "private", "return": "void", "signature": "void sleep( long millis )", "full_signature": "private void sleep( long millis )", "class_method_signature": "FileSystemBinaryStore.sleep( long millis )", "testcase": false, "constructor": false}, {"identifier": "getTrashFile", "parameters": "( BinaryKey key, boolean createIfAbsent )", "modifiers": "private", "return": "File", "signature": "File getTrashFile( BinaryKey key, boolean createIfAbsent )", "full_signature": "private File getTrashFile( BinaryKey key, boolean createIfAbsent )", "class_method_signature": "FileSystemBinaryStore.getTrashFile( BinaryKey key, boolean createIfAbsent )", "testcase": false, "constructor": false}, {"identifier": "removeTrashFile", "parameters": "(BinaryKey key)", "modifiers": "private", "return": "boolean", "signature": "boolean removeTrashFile(BinaryKey key)", "full_signature": "private boolean removeTrashFile(BinaryKey key)", "class_method_signature": "FileSystemBinaryStore.removeTrashFile(BinaryKey key)", "testcase": false, "constructor": false}, {"identifier": "moveFileExclusively", "parameters": "( File original,\n                                        File destination,\n                                        BinaryKey key )", "modifiers": "protected", "return": "void", "signature": "void moveFileExclusively( File original,\n                                        File destination,\n                                        BinaryKey key )", "full_signature": "protected void moveFileExclusively( File original,\n                                        File destination,\n                                        BinaryKey key )", "class_method_signature": "FileSystemBinaryStore.moveFileExclusively( File original,\n                                        File destination,\n                                        BinaryKey key )", "testcase": false, "constructor": false}, {"identifier": "findFile", "parameters": "( File directory,\n                                   BinaryKey key,\n                                   boolean createParentDirsIfMissing )", "modifiers": "protected final", "return": "File", "signature": "File findFile( File directory,\n                                   BinaryKey key,\n                                   boolean createParentDirsIfMissing )", "full_signature": "protected final File findFile( File directory,\n                                   BinaryKey key,\n                                   boolean createParentDirsIfMissing )", "class_method_signature": "FileSystemBinaryStore.findFile( File directory,\n                                   BinaryKey key,\n                                   boolean createParentDirsIfMissing )", "testcase": false, "constructor": false}, {"identifier": "getInputStream", "parameters": "( BinaryKey key )", "modifiers": "@Override public", "return": "InputStream", "signature": "InputStream getInputStream( BinaryKey key )", "full_signature": "@Override public InputStream getInputStream( BinaryKey key )", "class_method_signature": "FileSystemBinaryStore.getInputStream( BinaryKey key )", "testcase": false, "constructor": false}, {"identifier": "initializeStorage", "parameters": "( File directory )", "modifiers": "@SuppressWarnings( \"unused\" ) protected", "return": "void", "signature": "void initializeStorage( File directory )", "full_signature": "@SuppressWarnings( \"unused\" ) protected void initializeStorage( File directory )", "class_method_signature": "FileSystemBinaryStore.initializeStorage( File directory )", "testcase": false, "constructor": false}, {"identifier": "markAsUsed", "parameters": "( Iterable<BinaryKey> keys )", "modifiers": "@Override public", "return": "void", "signature": "void markAsUsed( Iterable<BinaryKey> keys )", "full_signature": "@Override public void markAsUsed( Iterable<BinaryKey> keys )", "class_method_signature": "FileSystemBinaryStore.markAsUsed( Iterable<BinaryKey> keys )", "testcase": false, "constructor": false}, {"identifier": "upgradeTrashContentFormat", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void upgradeTrashContentFormat()", "full_signature": "public void upgradeTrashContentFormat()", "class_method_signature": "FileSystemBinaryStore.upgradeTrashContentFormat()", "testcase": false, "constructor": false}, {"identifier": "moveTrashFilesToMainStorage", "parameters": "( File trash )", "modifiers": "private", "return": "void", "signature": "void moveTrashFilesToMainStorage( File trash )", "full_signature": "private void moveTrashFilesToMainStorage( File trash )", "class_method_signature": "FileSystemBinaryStore.moveTrashFilesToMainStorage( File trash )", "testcase": false, "constructor": false}, {"identifier": "removeAllTrashFilesFor", "parameters": "( BinaryKey key )", "modifiers": "protected", "return": "boolean", "signature": "boolean removeAllTrashFilesFor( BinaryKey key )", "full_signature": "protected boolean removeAllTrashFilesFor( BinaryKey key )", "class_method_signature": "FileSystemBinaryStore.removeAllTrashFilesFor( BinaryKey key )", "testcase": false, "constructor": false}, {"identifier": "markAsUnused", "parameters": "( Iterable<BinaryKey> keys )", "modifiers": "@Override public", "return": "void", "signature": "void markAsUnused( Iterable<BinaryKey> keys )", "full_signature": "@Override public void markAsUnused( Iterable<BinaryKey> keys )", "class_method_signature": "FileSystemBinaryStore.markAsUnused( Iterable<BinaryKey> keys )", "testcase": false, "constructor": false}, {"identifier": "markAsUnused", "parameters": "( BinaryKey key )", "modifiers": "protected", "return": "void", "signature": "void markAsUnused( BinaryKey key )", "full_signature": "protected void markAsUnused( BinaryKey key )", "class_method_signature": "FileSystemBinaryStore.markAsUnused( BinaryKey key )", "testcase": false, "constructor": false}, {"identifier": "touch", "parameters": "( File file )", "modifiers": "protected", "return": "void", "signature": "void touch( File file )", "full_signature": "protected void touch( File file )", "class_method_signature": "FileSystemBinaryStore.touch( File file )", "testcase": false, "constructor": false}, {"identifier": "pruneEmptyDirectories", "parameters": "( File directory,\n                                          File removeable )", "modifiers": "protected", "return": "void", "signature": "void pruneEmptyDirectories( File directory,\n                                          File removeable )", "full_signature": "protected void pruneEmptyDirectories( File directory,\n                                          File removeable )", "class_method_signature": "FileSystemBinaryStore.pruneEmptyDirectories( File directory,\n                                          File removeable )", "testcase": false, "constructor": false}, {"identifier": "isAncestor", "parameters": "( File ancestor,\n                                File descendant )", "modifiers": "private", "return": "boolean", "signature": "boolean isAncestor( File ancestor,\n                                File descendant )", "full_signature": "private boolean isAncestor( File ancestor,\n                                File descendant )", "class_method_signature": "FileSystemBinaryStore.isAncestor( File ancestor,\n                                File descendant )", "testcase": false, "constructor": false}, {"identifier": "removeValuesUnusedLongerThan", "parameters": "( long minimumAge,\n                                              TimeUnit unit )", "modifiers": "@Override public", "return": "void", "signature": "void removeValuesUnusedLongerThan( long minimumAge,\n                                              TimeUnit unit )", "full_signature": "@Override public void removeValuesUnusedLongerThan( long minimumAge,\n                                              TimeUnit unit )", "class_method_signature": "FileSystemBinaryStore.removeValuesUnusedLongerThan( long minimumAge,\n                                              TimeUnit unit )", "testcase": false, "constructor": false}, {"identifier": "removeFilesOlderThan", "parameters": "( long oldestTimestamp,\n                                       File parentDirectory )", "modifiers": "private", "return": "void", "signature": "void removeFilesOlderThan( long oldestTimestamp,\n                                       File parentDirectory )", "full_signature": "private void removeFilesOlderThan( long oldestTimestamp,\n                                       File parentDirectory )", "class_method_signature": "FileSystemBinaryStore.removeFilesOlderThan( long oldestTimestamp,\n                                       File parentDirectory )", "testcase": false, "constructor": false}, {"identifier": "getExtractedText", "parameters": "( BinaryValue source )", "modifiers": "@Override public", "return": "String", "signature": "String getExtractedText( BinaryValue source )", "full_signature": "@Override public String getExtractedText( BinaryValue source )", "class_method_signature": "FileSystemBinaryStore.getExtractedText( BinaryValue source )", "testcase": false, "constructor": false}, {"identifier": "storedStringAtKey", "parameters": "( BinaryKey key )", "modifiers": "private", "return": "String", "signature": "String storedStringAtKey( BinaryKey key )", "full_signature": "private String storedStringAtKey( BinaryKey key )", "class_method_signature": "FileSystemBinaryStore.storedStringAtKey( BinaryKey key )", "testcase": false, "constructor": false}, {"identifier": "storeExtractedText", "parameters": "( BinaryValue source,\n                                       String extractedText )", "modifiers": "@Override public", "return": "void", "signature": "void storeExtractedText( BinaryValue source,\n                                       String extractedText )", "full_signature": "@Override public void storeExtractedText( BinaryValue source,\n                                       String extractedText )", "class_method_signature": "FileSystemBinaryStore.storeExtractedText( BinaryValue source,\n                                       String extractedText )", "testcase": false, "constructor": false}, {"identifier": "storeStringAtKey", "parameters": "( String string,\n                                   BinaryKey key)", "modifiers": "private", "return": "void", "signature": "void storeStringAtKey( String string,\n                                   BinaryKey key)", "full_signature": "private void storeStringAtKey( String string,\n                                   BinaryKey key)", "class_method_signature": "FileSystemBinaryStore.storeStringAtKey( String string,\n                                   BinaryKey key)", "testcase": false, "constructor": false}, {"identifier": "getStoredMimeType", "parameters": "( BinaryValue binaryValue )", "modifiers": "@Override protected", "return": "String", "signature": "String getStoredMimeType( BinaryValue binaryValue )", "full_signature": "@Override protected String getStoredMimeType( BinaryValue binaryValue )", "class_method_signature": "FileSystemBinaryStore.getStoredMimeType( BinaryValue binaryValue )", "testcase": false, "constructor": false}, {"identifier": "storeMimeType", "parameters": "( BinaryValue binaryValue,\n                                  String mimeType )", "modifiers": "@Override protected", "return": "void", "signature": "void storeMimeType( BinaryValue binaryValue,\n                                  String mimeType )", "full_signature": "@Override protected void storeMimeType( BinaryValue binaryValue,\n                                  String mimeType )", "class_method_signature": "FileSystemBinaryStore.storeMimeType( BinaryValue binaryValue,\n                                  String mimeType )", "testcase": false, "constructor": false}, {"identifier": "binaryValueExists", "parameters": "( BinaryValue binaryValue )", "modifiers": "private", "return": "boolean", "signature": "boolean binaryValueExists( BinaryValue binaryValue )", "full_signature": "private boolean binaryValueExists( BinaryValue binaryValue )", "class_method_signature": "FileSystemBinaryStore.binaryValueExists( BinaryValue binaryValue )", "testcase": false, "constructor": false}, {"identifier": "createKeyFromSourceWithSuffix", "parameters": "( BinaryKey sourceKey,\n                                                     String suffix )", "modifiers": "private", "return": "BinaryKey", "signature": "BinaryKey createKeyFromSourceWithSuffix( BinaryKey sourceKey,\n                                                     String suffix )", "full_signature": "private BinaryKey createKeyFromSourceWithSuffix( BinaryKey sourceKey,\n                                                     String suffix )", "class_method_signature": "FileSystemBinaryStore.createKeyFromSourceWithSuffix( BinaryKey sourceKey,\n                                                     String suffix )", "testcase": false, "constructor": false}, {"identifier": "getAllBinaryKeys", "parameters": "()", "modifiers": "@Override public", "return": "Iterable<BinaryKey>", "signature": "Iterable<BinaryKey> getAllBinaryKeys()", "full_signature": "@Override public Iterable<BinaryKey> getAllBinaryKeys()", "class_method_signature": "FileSystemBinaryStore.getAllBinaryKeys()", "testcase": false, "constructor": false}, {"identifier": "isReadableDir", "parameters": "( File dir )", "modifiers": "private", "return": "boolean", "signature": "boolean isReadableDir( File dir )", "full_signature": "private boolean isReadableDir( File dir )", "class_method_signature": "FileSystemBinaryStore.isReadableDir( File dir )", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/value/binary/FileSystemBinaryStore.java"}, "focal_method": {"identifier": "storeValue", "parameters": "( InputStream stream, boolean markAsUnused )", "modifiers": "@Override public", "return": "BinaryValue", "body": "@Override\n    public BinaryValue storeValue( InputStream stream, boolean markAsUnused ) throws BinaryStoreException {\n        File tmpFile = null;\n        BinaryValue value = null;\n        try {\n            // Write the contents to a temporary file, and while we do grab the SHA-1 hash and the length ...\n            HashingInputStream hashingStream = SecureHash.createHashingStream(Algorithm.SHA_1, stream);\n            tmpFile = File.createTempFile(TEMP_FILE_PREFIX, TEMP_FILE_SUFFIX);\n            IoUtil.write(hashingStream, new BufferedOutputStream(new FileOutputStream(tmpFile)),\n                         AbstractBinaryStore.MEDIUM_BUFFER_SIZE);\n            byte[] sha1 = hashingStream.getHash();\n            BinaryKey key = new BinaryKey(sha1);\n\n            final long numberOfBytes = tmpFile.length();\n            if (numberOfBytes < getMinimumBinarySizeInBytes()) {\n                // The content is small enough to just store in-memory ...\n                byte[] content = IoUtil.readBytes(tmpFile);\n                tmpFile.delete();\n                value = new InMemoryBinaryValue(this, key, content);\n            } else {\n                value = saveTempFileToStore(tmpFile, key, numberOfBytes);\n                if (markAsUnused) {\n                    markAsUnused(key);\n                }\n            }\n            return value;\n        } catch (IOException e) {\n            throw new BinaryStoreException(e);\n        } catch (NoSuchAlgorithmException e) {\n            throw new SystemFailureException(e);\n        } finally {\n            if (tmpFile != null) {\n                try {\n                    tmpFile.delete();\n                } catch (Throwable t) {\n                    Logger.getLogger(getClass()).warn(t, JcrI18n.unableToDeleteTemporaryFile, tmpFile.getAbsolutePath(),\n                                                      t.getMessage());\n                }\n            }\n        }\n    }", "signature": "BinaryValue storeValue( InputStream stream, boolean markAsUnused )", "full_signature": "@Override public BinaryValue storeValue( InputStream stream, boolean markAsUnused )", "class_method_signature": "FileSystemBinaryStore.storeValue( InputStream stream, boolean markAsUnused )", "testcase": false, "constructor": false, "invocations": ["createHashingStream", "createTempFile", "write", "getHash", "length", "getMinimumBinarySizeInBytes", "readBytes", "delete", "saveTempFileToStore", "markAsUnused", "delete", "warn", "getLogger", "getClass", "getAbsolutePath", "getMessage"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}