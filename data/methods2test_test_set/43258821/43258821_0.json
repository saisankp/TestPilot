{"test_class": {"identifier": "MerkleTreeTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(MerkleTreeTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(MerkleTreeTest.class)", "var_name": "log"}, {"original_string": "private Random random = new Random();", "modifier": "private", "type": "Random", "declarator": "random = new Random()", "var_name": "random"}], "file": "common/src/test/java/io/blobkeeper/common/util/MerkleTreeTest.java"}, "test_case": {"identifier": "difference", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void difference() throws InterruptedException {\n        IdGeneratorService service = new IdGeneratorService();\n\n        List<Block> originalBlocks = new ArrayList<>();\n\n        long min = 0, max = 0;\n\n        int offset = 0;\n        for (int i = 0; i < 10000; i++) {\n            long id = service.generate(1);\n            int length = random.nextInt(65536);\n            originalBlocks.add(new Block(id, Arrays.asList(new BlockElt(id, 0, offset, length, 42))));\n            offset += length;\n\n            if (min == 0) {\n                min = id;\n            }\n            max = id;\n\n            Thread.sleep(1);\n        }\n\n        SortedMap<Long, Block> blocks = originalBlocks.stream()\n                .collect(toMap(Block::getId, Function.<Block>identity(), Utils.throwingMerger(), TreeMap::new));\n\n        SortedMap<Long, Block> blocks2 = originalBlocks.stream()\n                .limit(9500)\n                .collect(toMap(Block::getId, Function.<Block>identity(), Utils.throwingMerger(), TreeMap::new));\n\n        Range<Long> ranges = Range.openClosed(min - 1, max);\n\n        MerkleTree tree = new MerkleTree(ranges, 64);\n        MerkleTree.fillTree(tree, blocks);\n\n        MerkleTree tree2 = new MerkleTree(ranges, 64);\n        MerkleTree.fillTree(tree2, blocks2);\n\n        assertEquals(\n                MerkleTree.difference(tree, tree2)\n                        .stream()\n                        .count(),\n                4);\n    }", "signature": "void difference()", "full_signature": "@Test public void difference()", "class_method_signature": "MerkleTreeTest.difference()", "testcase": true, "constructor": false, "invocations": ["generate", "nextInt", "add", "asList", "sleep", "collect", "stream", "toMap", "identity", "throwingMerger", "collect", "limit", "stream", "toMap", "identity", "throwingMerger", "openClosed", "fillTree", "fillTree", "assertEquals", "count", "stream", "difference"]}, "focal_class": {"identifier": "MerkleTree", "superclass": "", "interfaces": "implements Serializable", "fields": [{"original_string": "private static final long serialVersionUID = 5208542351647956821L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 5208542351647956821L", "var_name": "serialVersionUID"}, {"original_string": "private static final Logger log = LoggerFactory.getLogger(MerkleTree.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(MerkleTree.class)", "var_name": "log"}, {"original_string": "public static final int MAX_LEVEL = 64;", "modifier": "public static final", "type": "int", "declarator": "MAX_LEVEL = 64", "var_name": "MAX_LEVEL"}, {"original_string": "private int maxDepth;", "modifier": "private", "type": "int", "declarator": "maxDepth", "var_name": "maxDepth"}, {"original_string": "private Range<Long> fullRange;", "modifier": "private", "type": "Range<Long>", "declarator": "fullRange", "var_name": "fullRange"}, {"original_string": "private int size;", "modifier": "private", "type": "int", "declarator": "size", "var_name": "size"}, {"original_string": "private HashableNode root;", "modifier": "private", "type": "HashableNode", "declarator": "root", "var_name": "root"}], "methods": [{"identifier": "MerkleTree", "parameters": "(Range<Long> fullRange, int maxDepth)", "modifiers": "public", "return": "", "signature": " MerkleTree(Range<Long> fullRange, int maxDepth)", "full_signature": "public  MerkleTree(Range<Long> fullRange, int maxDepth)", "class_method_signature": "MerkleTree.MerkleTree(Range<Long> fullRange, int maxDepth)", "testcase": false, "constructor": true}, {"identifier": "calculate", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void calculate()", "full_signature": "public void calculate()", "class_method_signature": "MerkleTree.calculate()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "MerkleTree.toString()", "testcase": false, "constructor": false}, {"identifier": "getLeafNodes", "parameters": "()", "modifiers": "public", "return": "List<LeafNode>", "signature": "List<LeafNode> getLeafNodes()", "full_signature": "public List<LeafNode> getLeafNodes()", "class_method_signature": "MerkleTree.getLeafNodes()", "testcase": false, "constructor": false}, {"identifier": "fillTree", "parameters": "(@NotNull MerkleTree tree, @NotNull SortedMap<Long, Block> blocks)", "modifiers": "public static", "return": "void", "signature": "void fillTree(@NotNull MerkleTree tree, @NotNull SortedMap<Long, Block> blocks)", "full_signature": "public static void fillTree(@NotNull MerkleTree tree, @NotNull SortedMap<Long, Block> blocks)", "class_method_signature": "MerkleTree.fillTree(@NotNull MerkleTree tree, @NotNull SortedMap<Long, Block> blocks)", "testcase": false, "constructor": false}, {"identifier": "difference", "parameters": "(@NotNull MerkleTree one, @Nullable MerkleTree two)", "modifiers": "public static", "return": "List<LeafNode>", "signature": "List<LeafNode> difference(@NotNull MerkleTree one, @Nullable MerkleTree two)", "full_signature": "public static List<LeafNode> difference(@NotNull MerkleTree one, @Nullable MerkleTree two)", "class_method_signature": "MerkleTree.difference(@NotNull MerkleTree one, @Nullable MerkleTree two)", "testcase": false, "constructor": false}, {"identifier": "init", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void init()", "full_signature": "private void init()", "class_method_signature": "MerkleTree.init()", "testcase": false, "constructor": false}, {"identifier": "_init", "parameters": "(Long left, Long right, int depth, int max)", "modifiers": "private", "return": "HashableNode", "signature": "HashableNode _init(Long left, Long right, int depth, int max)", "full_signature": "private HashableNode _init(Long left, Long right, int depth, int max)", "class_method_signature": "MerkleTree._init(Long left, Long right, int depth, int max)", "testcase": false, "constructor": false}, {"identifier": "getRoot", "parameters": "()", "modifiers": "public", "return": "HashableNode", "signature": "HashableNode getRoot()", "full_signature": "public HashableNode getRoot()", "class_method_signature": "MerkleTree.getRoot()", "testcase": false, "constructor": false}], "file": "common/src/main/java/io/blobkeeper/common/util/MerkleTree.java"}, "focal_method": {"identifier": "difference", "parameters": "(@NotNull MerkleTree one, @Nullable MerkleTree two)", "modifiers": "public static", "return": "List<LeafNode>", "body": "public static List<LeafNode> difference(@NotNull MerkleTree one, @Nullable MerkleTree two) {\n        checkNotNull(one, \"Expected tree is required!\");\n\n        if (null == two) {\n            return one.getLeafNodes();\n        }\n\n        Deque<HashableNode> nodes1 = new ArrayDeque<>();\n        Deque<HashableNode> nodes2 = new ArrayDeque<>();\n\n        HashableNode current1 = one.root;\n        HashableNode current2 = two.root;\n\n        List<LeafNode> diff = new ArrayList<>();\n\n        while ((!nodes1.isEmpty() || current1 != null) && (!nodes2.isEmpty() || current2 != null)) {\n            if (current1 != null && current2 != null && current1 instanceof LeafNode && current2 instanceof LeafNode && !current1.equals(current2)) {\n                log.debug(\"Nodes are diff {} : {}\", current1, current2);\n                diff.add((LeafNode) current2);\n            }\n\n            if (current1 instanceof BranchNode) {\n                HashableNode rightNode = ((BranchNode) current1).getRight();\n                if (rightNode != null) {\n                    nodes1.push(rightNode);\n                }\n                current1 = ((BranchNode) current1).getLeft();\n            } else {\n                if (!nodes1.isEmpty()) {\n                    current1 = nodes1.pop();\n                } else {\n                    current1 = null;\n                }\n            }\n\n            if (current2 instanceof BranchNode) {\n                HashableNode rightNode = ((BranchNode) current2).getRight();\n                if (rightNode != null) {\n                    nodes2.push(rightNode);\n                }\n                current2 = ((BranchNode) current2).getLeft();\n            } else {\n                if (!nodes2.isEmpty()) {\n                    current2 = nodes2.pop();\n                } else {\n                    current2 = null;\n                }\n            }\n        }\n\n        return diff;\n    }", "signature": "List<LeafNode> difference(@NotNull MerkleTree one, @Nullable MerkleTree two)", "full_signature": "public static List<LeafNode> difference(@NotNull MerkleTree one, @Nullable MerkleTree two)", "class_method_signature": "MerkleTree.difference(@NotNull MerkleTree one, @Nullable MerkleTree two)", "testcase": false, "constructor": false, "invocations": ["checkNotNull", "getLeafNodes", "isEmpty", "isEmpty", "equals", "debug", "add", "getRight", "push", "getLeft", "isEmpty", "pop", "getRight", "push", "getLeft", "isEmpty", "pop"]}, "repository": {"repo_id": 43258821, "url": "https://github.com/sherman/blobkeeper", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 20, "size": 417, "license": "licensed"}}