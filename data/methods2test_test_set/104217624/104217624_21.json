{"test_class": {"identifier": "HappyEyeballsResolverTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private HappyEyeballsResolver subject = new HappyEyeballsResolver(new HttpClient());", "modifier": "private", "type": "HappyEyeballsResolver", "declarator": "subject = new HappyEyeballsResolver(new HttpClient())", "var_name": "subject"}], "file": "rpki-validator/src/test/java/net/ripe/rpki/validator3/util/HappyEyeballsResolverTest.java"}, "test_case": {"identifier": "should_not_recognise_ipv6_literal", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void should_not_recognise_ipv6_literal() {\n        assertThat(subject.isLiteralIpAddress(\"dbg::\")).isEmpty();\n        assertThat(subject.isLiteralIpAddress(\"db8:dead:beef::/26\")).isEmpty();\n        assertThat(subject.isLiteralIpAddress(\"127\")).isEmpty();\n        assertThat(subject.isLiteralIpAddress(\"\")).isEmpty();\n    }", "signature": "void should_not_recognise_ipv6_literal()", "full_signature": "@Test public void should_not_recognise_ipv6_literal()", "class_method_signature": "HappyEyeballsResolverTest.should_not_recognise_ipv6_literal()", "testcase": true, "constructor": false, "invocations": ["isEmpty", "assertThat", "isLiteralIpAddress", "isEmpty", "assertThat", "isLiteralIpAddress", "isEmpty", "assertThat", "isLiteralIpAddress", "isEmpty", "assertThat", "isLiteralIpAddress"]}, "focal_class": {"identifier": "HappyEyeballsResolver", "superclass": "", "interfaces": "implements SocketAddressResolver", "fields": [{"original_string": "private static final long RESOLUTION_DELAY_MILLIS = 50L;", "modifier": "private static final", "type": "long", "declarator": "RESOLUTION_DELAY_MILLIS = 50L", "var_name": "RESOLUTION_DELAY_MILLIS"}, {"original_string": "private static final long CONNECTION_ATTEMPT_DELAY_MILLIS = 250L;", "modifier": "private static final", "type": "long", "declarator": "CONNECTION_ATTEMPT_DELAY_MILLIS = 250L", "var_name": "CONNECTION_ATTEMPT_DELAY_MILLIS"}, {"original_string": "public static final long HAPPY_EYEBALLS_TOTAL_TIMEOUT_NANOS = TimeUnit.SECONDS.toNanos(10);", "modifier": "public static final", "type": "long", "declarator": "HAPPY_EYEBALLS_TOTAL_TIMEOUT_NANOS = TimeUnit.SECONDS.toNanos(10)", "var_name": "HAPPY_EYEBALLS_TOTAL_TIMEOUT_NANOS"}, {"original_string": "private static final Pattern IPV4_ADDRESS_PATTERN = Pattern.compile(\"\\\\d{1,3}(?:\\\\.\\\\d{1,3}){3}\");", "modifier": "private static final", "type": "Pattern", "declarator": "IPV4_ADDRESS_PATTERN = Pattern.compile(\"\\\\d{1,3}(?:\\\\.\\\\d{1,3}){3}\")", "var_name": "IPV4_ADDRESS_PATTERN"}, {"original_string": "private static final Pattern IPV6_ADDRESS_PATTERN =\n            Pattern.compile(\"( [0-9A-Fa-f:.]+ (?: % [0-9A-Za-z][-0-9A-Za-z_\\\\ ]*)? )\", Pattern.COMMENTS);", "modifier": "private static final", "type": "Pattern", "declarator": "IPV6_ADDRESS_PATTERN =\n            Pattern.compile(\"( [0-9A-Fa-f:.]+ (?: % [0-9A-Za-z][-0-9A-Za-z_\\\\ ]*)? )\", Pattern.COMMENTS)", "var_name": "IPV6_ADDRESS_PATTERN"}, {"original_string": "private final HttpClient httpClient;", "modifier": "private final", "type": "HttpClient", "declarator": "httpClient", "var_name": "httpClient"}], "methods": [{"identifier": "HappyEyeballsResolver", "parameters": "(HttpClient httpClient)", "modifiers": "public", "return": "", "signature": " HappyEyeballsResolver(HttpClient httpClient)", "full_signature": "public  HappyEyeballsResolver(HttpClient httpClient)", "class_method_signature": "HappyEyeballsResolver.HappyEyeballsResolver(HttpClient httpClient)", "testcase": false, "constructor": true}, {"identifier": "resolve", "parameters": "(String host, int port, Promise<List<InetSocketAddress>> promise)", "modifiers": "@Override public", "return": "void", "signature": "void resolve(String host, int port, Promise<List<InetSocketAddress>> promise)", "full_signature": "@Override public void resolve(String host, int port, Promise<List<InetSocketAddress>> promise)", "class_method_signature": "HappyEyeballsResolver.resolve(String host, int port, Promise<List<InetSocketAddress>> promise)", "testcase": false, "constructor": false}, {"identifier": "isLiteralIpAddress", "parameters": "(String host)", "modifiers": "", "return": "Optional<String>", "signature": "Optional<String> isLiteralIpAddress(String host)", "full_signature": " Optional<String> isLiteralIpAddress(String host)", "class_method_signature": "HappyEyeballsResolver.isLiteralIpAddress(String host)", "testcase": false, "constructor": false}, {"identifier": "isLiteralV4Address", "parameters": "(String host)", "modifiers": "private", "return": "boolean", "signature": "boolean isLiteralV4Address(String host)", "full_signature": "private boolean isLiteralV4Address(String host)", "class_method_signature": "HappyEyeballsResolver.isLiteralV4Address(String host)", "testcase": false, "constructor": false}, {"identifier": "completePromise", "parameters": "(String ipAddress, int port, Promise<List<InetSocketAddress>> promise)", "modifiers": "private", "return": "void", "signature": "void completePromise(String ipAddress, int port, Promise<List<InetSocketAddress>> promise)", "full_signature": "private void completePromise(String ipAddress, int port, Promise<List<InetSocketAddress>> promise)", "class_method_signature": "HappyEyeballsResolver.completePromise(String ipAddress, int port, Promise<List<InetSocketAddress>> promise)", "testcase": false, "constructor": false}, {"identifier": "resolveAsynchronously", "parameters": "(String host, int port, Promise<List<InetSocketAddress>> promise)", "modifiers": "private", "return": "void", "signature": "void resolveAsynchronously(String host, int port, Promise<List<InetSocketAddress>> promise)", "full_signature": "private void resolveAsynchronously(String host, int port, Promise<List<InetSocketAddress>> promise)", "class_method_signature": "HappyEyeballsResolver.resolveAsynchronously(String host, int port, Promise<List<InetSocketAddress>> promise)", "testcase": false, "constructor": false}, {"identifier": "closeAnyway", "parameters": "(Closeable closeable)", "modifiers": "private static", "return": "void", "signature": "void closeAnyway(Closeable closeable)", "full_signature": "private static void closeAnyway(Closeable closeable)", "class_method_signature": "HappyEyeballsResolver.closeAnyway(Closeable closeable)", "testcase": false, "constructor": false}, {"identifier": "joinAddresses", "parameters": "(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6)", "modifiers": "private", "return": "Object", "signature": "Object joinAddresses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6)", "full_signature": "private Object joinAddresses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6)", "class_method_signature": "HappyEyeballsResolver.joinAddresses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6)", "testcase": false, "constructor": false}, {"identifier": "awaitSuccessfulConnection", "parameters": "(Selector selector, long selectTimeout)", "modifiers": "private static", "return": "Optional<SocketAddress>", "signature": "Optional<SocketAddress> awaitSuccessfulConnection(Selector selector, long selectTimeout)", "full_signature": "private static Optional<SocketAddress> awaitSuccessfulConnection(Selector selector, long selectTimeout)", "class_method_signature": "HappyEyeballsResolver.awaitSuccessfulConnection(Selector selector, long selectTimeout)", "testcase": false, "constructor": false}, {"identifier": "awaitDnsResponses", "parameters": "(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6,\n                                          ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV4)", "modifiers": "private static", "return": "void", "signature": "void awaitDnsResponses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6,\n                                          ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV4)", "full_signature": "private static void awaitDnsResponses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6,\n                                          ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV4)", "class_method_signature": "HappyEyeballsResolver.awaitDnsResponses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6,\n                                          ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV4)", "testcase": false, "constructor": false}, {"identifier": "haveTime", "parameters": "(long nanoDeadline)", "modifiers": "private static", "return": "boolean", "signature": "boolean haveTime(long nanoDeadline)", "full_signature": "private static boolean haveTime(long nanoDeadline)", "class_method_signature": "HappyEyeballsResolver.haveTime(long nanoDeadline)", "testcase": false, "constructor": false}, {"identifier": "dnsLookupRunnable", "parameters": "(Name hostname, int queryType, Queue<Optional<InetAddress>> resolvedAddresses)", "modifiers": "private static", "return": "Runnable", "signature": "Runnable dnsLookupRunnable(Name hostname, int queryType, Queue<Optional<InetAddress>> resolvedAddresses)", "full_signature": "private static Runnable dnsLookupRunnable(Name hostname, int queryType, Queue<Optional<InetAddress>> resolvedAddresses)", "class_method_signature": "HappyEyeballsResolver.dnsLookupRunnable(Name hostname, int queryType, Queue<Optional<InetAddress>> resolvedAddresses)", "testcase": false, "constructor": false}, {"identifier": "findBestAddress", "parameters": "(final Queue<Optional<InetAddress>> firstAfAddresses,\n                                                           final Queue<Optional<InetAddress>> secondAfAddresses,\n                                                           final int port, final Selector selector)", "modifiers": "private static", "return": "Optional<SocketAddress>", "signature": "Optional<SocketAddress> findBestAddress(final Queue<Optional<InetAddress>> firstAfAddresses,\n                                                           final Queue<Optional<InetAddress>> secondAfAddresses,\n                                                           final int port, final Selector selector)", "full_signature": "private static Optional<SocketAddress> findBestAddress(final Queue<Optional<InetAddress>> firstAfAddresses,\n                                                           final Queue<Optional<InetAddress>> secondAfAddresses,\n                                                           final int port, final Selector selector)", "class_method_signature": "HappyEyeballsResolver.findBestAddress(final Queue<Optional<InetAddress>> firstAfAddresses,\n                                                           final Queue<Optional<InetAddress>> secondAfAddresses,\n                                                           final int port, final Selector selector)", "testcase": false, "constructor": false}, {"identifier": "openConnectionFromQueue", "parameters": "(Queue<Optional<InetAddress>> queue,\n                                                   int port,\n                                                   Selector selector)", "modifiers": "private static", "return": "boolean", "signature": "boolean openConnectionFromQueue(Queue<Optional<InetAddress>> queue,\n                                                   int port,\n                                                   Selector selector)", "full_signature": "private static boolean openConnectionFromQueue(Queue<Optional<InetAddress>> queue,\n                                                   int port,\n                                                   Selector selector)", "class_method_signature": "HappyEyeballsResolver.openConnectionFromQueue(Queue<Optional<InetAddress>> queue,\n                                                   int port,\n                                                   Selector selector)", "testcase": false, "constructor": false}], "file": "rpki-validator/src/main/java/net/ripe/rpki/validator3/util/HappyEyeballsResolver.java"}, "focal_method": {"identifier": "isLiteralIpAddress", "parameters": "(String host)", "modifiers": "", "return": "Optional<String>", "body": "Optional<String> isLiteralIpAddress(String host) {\n        if (isLiteralV4Address(host)) return Optional.of(host);\n        else if (host.contains(\":\")) {\n            final Matcher matcher = IPV6_ADDRESS_PATTERN.matcher(host);\n            if (matcher.matches()) return Optional.of(matcher.group(1));\n        }\n        return Optional.empty();\n    }", "signature": "Optional<String> isLiteralIpAddress(String host)", "full_signature": " Optional<String> isLiteralIpAddress(String host)", "class_method_signature": "HappyEyeballsResolver.isLiteralIpAddress(String host)", "testcase": false, "constructor": false, "invocations": ["isLiteralV4Address", "of", "contains", "matcher", "matches", "of", "group", "empty"]}, "repository": {"repo_id": 104217624, "url": "https://github.com/RIPE-NCC/rpki-validator-3", "stars": 32, "created": "9/20/2017 1:15:05 PM +00:00", "updates": "2020-01-27T10:48:38+00:00", "fork": "False", "license": "licensed"}}