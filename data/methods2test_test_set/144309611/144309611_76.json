{"test_class": {"identifier": "ServiceProxyTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static ServiceProxy proxy;", "modifier": "private static", "type": "ServiceProxy", "declarator": "proxy", "var_name": "proxy"}], "file": "bft-smart/src/test/java/bftsmart/tom/ServiceProxyTest.java"}, "test_case": {"identifier": "testReplyReceived", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testReplyReceived() {\n\t\t// Just to setup some variables\n\n\t\tField response;\n\t\tField receivedReplies;\n\t\tField reqId;\n\t\tField replyQuorum;\n\t\tField replies;\n\t\tField requestType;\n\n\t\ttry {\n\t\t\tresponse = ServiceProxy.class.getDeclaredField(\"response\");\n\t\t\tresponse.setAccessible(true);\n\t\t\treceivedReplies = ServiceProxy.class.getDeclaredField(\"receivedReplies\");\n\t\t\treceivedReplies.setAccessible(true);\n\t\t\treqId = ServiceProxy.class.getDeclaredField(\"reqId\");\n\t\t\treqId.setAccessible(true);\n\t\t\treplyQuorum = ServiceProxy.class.getDeclaredField(\"replyQuorum\");\n\t\t\treplyQuorum.setAccessible(true);\n\t\t\treplies = ServiceProxy.class.getDeclaredField(\"replies\");\n\t\t\treplies.setAccessible(true);\n\t\t\trequestType = ServiceProxy.class.getDeclaredField(\"requestType\");\n\t\t\trequestType.setAccessible(true);\n\n\t\t\ttry {\n\t\t\t\t// Test if a the method decides correctly when three correct\n\t\t\t\t// replies are received in sequence. The request are ordered\n\t\t\t\tTOMMessage[] initReplies = new TOMMessage[4];\n\t\t\t\treceivedReplies.set(proxy, 0);\n\t\t\t\treqId.setInt(proxy, 1);\n\t\t\t\treplyQuorum.setInt(proxy, 3);\n\t\t\t\treplies.set(proxy, initReplies);\n\t\t\t\trequestType.set(proxy, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tresponse.set(proxy, null);\n\n\t\t\t\tTOMMessage msg = new TOMMessage(0, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tmsg = new TOMMessage(1, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tmsg = new TOMMessage(2, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tTOMMessage reply = (TOMMessage) response.get(proxy);\n\n\t\t\t\tAssert.assertEquals(\"response1\", new String(reply.getContent()));\n\n\t\t\t\t// Test if a the method decides correctly when the replies are\n\t\t\t\t// correct, correct, wrong and correct, in that order. The requests\n\t\t\t\t// are ordered\n\t\t\t\tinitReplies = new TOMMessage[4];\n\t\t\t\treceivedReplies.set(proxy, 0);\n\t\t\t\treqId.setInt(proxy, 1);\n\t\t\t\treplyQuorum.setInt(proxy, 3);\n\t\t\t\treplies.set(proxy, initReplies);\n\t\t\t\trequestType.set(proxy, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tresponse.set(proxy, null);\n\n\t\t\t\tmsg = new TOMMessage(0, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tmsg = new TOMMessage(1, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tmsg = new TOMMessage(2, 1, 1, \"response2\".getBytes(), 0, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tmsg = new TOMMessage(3, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\treply = (TOMMessage) response.get(proxy);\n\n\t\t\t\tAssert.assertEquals(\"response1\", new String(reply.getContent()));\n\n\t\t\t\t// Negative test, to verify if the method doesn't decide when the values\n\t\t\t\t// doesn't match as a reply quorum. The values are 2 response1 and 2 response2\n\t\t\t\tinitReplies = new TOMMessage[4];\n\t\t\t\treceivedReplies.set(proxy, 0);\n\t\t\t\treqId.setInt(proxy, 1);\n\t\t\t\treplyQuorum.setInt(proxy, 3);\n\t\t\t\treplies.set(proxy, initReplies);\n\t\t\t\trequestType.set(proxy, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tresponse.set(proxy, null);\n\n\t\t\t\tmsg = new TOMMessage(0, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tmsg = new TOMMessage(1, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tmsg = new TOMMessage(2, 1, 1, \"response2\".getBytes(), 0, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tmsg = new TOMMessage(3, 1, 1, \"response2\".getBytes(), 0, TOMMessageType.ORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\treply = (TOMMessage) response.get(proxy);\n\n\t\t\t\tAssert.assertNull(reply);\n\t\t\t\tAssert.assertEquals(-1, reqId.get(proxy));\n\n\t\t\t\t// Test replyReceived for correct readonly messages\n\t\t\t\tinitReplies = new TOMMessage[4];\n\t\t\t\treceivedReplies.set(proxy, 0);\n\t\t\t\treqId.setInt(proxy, 1);\n\t\t\t\treplies.set(proxy, initReplies);\n\t\t\t\trequestType.set(proxy, TOMMessageType.UNORDERED_REQUEST);\n\t\t\t\tresponse.set(proxy, null);\n\n\t\t\t\tmsg = new TOMMessage(0, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.UNORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tmsg = new TOMMessage(1, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.UNORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tmsg = new TOMMessage(2, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.UNORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\n\t\t\t\treply = (TOMMessage) response.get(proxy);\n\t\t\t\tAssert.assertEquals(\"response1\", new String(reply.getContent()));\n\n\t\t\t\t// Test if the method fails for the first diverging readonly reply\n\t\t\t\treceivedReplies.set(proxy, 0);\n\t\t\t\treqId.setInt(proxy, 1);\n\t\t\t\treplies.set(proxy, initReplies);\n\t\t\t\trequestType.set(proxy, TOMMessageType.UNORDERED_REQUEST);\n\t\t\t\tresponse.set(proxy, null);\n\n\t\t\t\tmsg = new TOMMessage(0, 1, 1, \"response1\".getBytes(), 0, TOMMessageType.UNORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\t\t\t\tmsg = new TOMMessage(1, 1, 1, \"response2\".getBytes(), 0, TOMMessageType.UNORDERED_REQUEST);\n\t\t\t\tproxy.replyReceived(msg);\n\n\t\t\t\treply = (TOMMessage) response.get(proxy);\n\t\t\t\tAssert.assertEquals(-1, reqId.get(proxy));\n\n\t\t\t} catch (IllegalArgumentException | IllegalAccessException e) {\n\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} catch (NoSuchFieldException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (SecurityException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "signature": "void testReplyReceived()", "full_signature": "@Test public void testReplyReceived()", "class_method_signature": "ServiceProxyTest.testReplyReceived()", "testcase": true, "constructor": false, "invocations": ["getDeclaredField", "setAccessible", "getDeclaredField", "setAccessible", "getDeclaredField", "setAccessible", "getDeclaredField", "setAccessible", "getDeclaredField", "setAccessible", "getDeclaredField", "setAccessible", "set", "setInt", "setInt", "set", "set", "set", "getBytes", "replyReceived", "getBytes", "replyReceived", "getBytes", "replyReceived", "get", "assertEquals", "getContent", "set", "setInt", "setInt", "set", "set", "set", "getBytes", "replyReceived", "getBytes", "replyReceived", "getBytes", "replyReceived", "getBytes", "replyReceived", "get", "assertEquals", "getContent", "set", "setInt", "setInt", "set", "set", "set", "getBytes", "replyReceived", "getBytes", "replyReceived", "getBytes", "replyReceived", "getBytes", "replyReceived", "get", "assertNull", "assertEquals", "get", "set", "setInt", "set", "set", "set", "getBytes", "replyReceived", "getBytes", "replyReceived", "getBytes", "replyReceived", "get", "assertEquals", "getContent", "set", "setInt", "set", "set", "set", "getBytes", "replyReceived", "getBytes", "replyReceived", "get", "assertEquals", "get", "printStackTrace", "printStackTrace", "printStackTrace"]}, "focal_class": {"identifier": "ServiceProxy", "superclass": "extends TOMSender", "interfaces": "", "fields": [{"original_string": "protected ReentrantLock canReceiveLock = new ReentrantLock();", "modifier": "protected", "type": "ReentrantLock", "declarator": "canReceiveLock = new ReentrantLock()", "var_name": "canReceiveLock"}, {"original_string": "protected ReentrantLock canSendLock = new ReentrantLock();", "modifier": "protected", "type": "ReentrantLock", "declarator": "canSendLock = new ReentrantLock()", "var_name": "canSendLock"}, {"original_string": "private Semaphore sm = new Semaphore(0);", "modifier": "private", "type": "Semaphore", "declarator": "sm = new Semaphore(0)", "var_name": "sm"}, {"original_string": "private int reqId = -1;", "modifier": "private", "type": "int", "declarator": "reqId = -1", "var_name": "reqId"}, {"original_string": "private int operationId = -1;", "modifier": "private", "type": "int", "declarator": "operationId = -1", "var_name": "operationId"}, {"original_string": "private TOMMessageType requestType;", "modifier": "private", "type": "TOMMessageType", "declarator": "requestType", "var_name": "requestType"}, {"original_string": "private int replyQuorum = 0;", "modifier": "private", "type": "int", "declarator": "replyQuorum = 0", "var_name": "replyQuorum"}, {"original_string": "private TOMMessage replies[] = null;", "modifier": "private", "type": "TOMMessage", "declarator": "replies[] = null", "var_name": "replies"}, {"original_string": "private int receivedReplies = 0;", "modifier": "private", "type": "int", "declarator": "receivedReplies = 0", "var_name": "receivedReplies"}, {"original_string": "private TOMMessage response = null;", "modifier": "private", "type": "TOMMessage", "declarator": "response = null", "var_name": "response"}, {"original_string": "private int invokeTimeout = 40;", "modifier": "private", "type": "int", "declarator": "invokeTimeout = 40", "var_name": "invokeTimeout"}, {"original_string": "private Comparator<byte[]> comparator;", "modifier": "private", "type": "Comparator<byte[]>", "declarator": "comparator", "var_name": "comparator"}, {"original_string": "private Extractor extractor;", "modifier": "private", "type": "Extractor", "declarator": "extractor", "var_name": "extractor"}, {"original_string": "private Random rand = new Random(System.currentTimeMillis());", "modifier": "private", "type": "Random", "declarator": "rand = new Random(System.currentTimeMillis())", "var_name": "rand"}, {"original_string": "private int replyServer;", "modifier": "private", "type": "int", "declarator": "replyServer", "var_name": "replyServer"}, {"original_string": "private HashResponseController hashResponseController;", "modifier": "private", "type": "HashResponseController", "declarator": "hashResponseController", "var_name": "hashResponseController"}, {"original_string": "private int invokeUnorderedHashedTimeout = 10;", "modifier": "private", "type": "int", "declarator": "invokeUnorderedHashedTimeout = 10", "var_name": "invokeUnorderedHashedTimeout"}], "methods": [{"identifier": "ServiceProxy", "parameters": "(int processId)", "modifiers": "public", "return": "", "signature": " ServiceProxy(int processId)", "full_signature": "public  ServiceProxy(int processId)", "class_method_signature": "ServiceProxy.ServiceProxy(int processId)", "testcase": false, "constructor": true}, {"identifier": "ServiceProxy", "parameters": "(int processId, String configHome)", "modifiers": "public", "return": "", "signature": " ServiceProxy(int processId, String configHome)", "full_signature": "public  ServiceProxy(int processId, String configHome)", "class_method_signature": "ServiceProxy.ServiceProxy(int processId, String configHome)", "testcase": false, "constructor": true}, {"identifier": "ServiceProxy", "parameters": "(int processId, String configHome, Comparator<byte[]> replyComparator,\n\t\t\tExtractor replyExtractor)", "modifiers": "public", "return": "", "signature": " ServiceProxy(int processId, String configHome, Comparator<byte[]> replyComparator,\n\t\t\tExtractor replyExtractor)", "full_signature": "public  ServiceProxy(int processId, String configHome, Comparator<byte[]> replyComparator,\n\t\t\tExtractor replyExtractor)", "class_method_signature": "ServiceProxy.ServiceProxy(int processId, String configHome, Comparator<byte[]> replyComparator,\n\t\t\tExtractor replyExtractor)", "testcase": false, "constructor": true}, {"identifier": "getInvokeTimeout", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getInvokeTimeout()", "full_signature": "public int getInvokeTimeout()", "class_method_signature": "ServiceProxy.getInvokeTimeout()", "testcase": false, "constructor": false}, {"identifier": "getInvokeUnorderedHashedTimeout", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getInvokeUnorderedHashedTimeout()", "full_signature": "public int getInvokeUnorderedHashedTimeout()", "class_method_signature": "ServiceProxy.getInvokeUnorderedHashedTimeout()", "testcase": false, "constructor": false}, {"identifier": "setInvokeTimeout", "parameters": "(int invokeTimeout)", "modifiers": "public", "return": "void", "signature": "void setInvokeTimeout(int invokeTimeout)", "full_signature": "public void setInvokeTimeout(int invokeTimeout)", "class_method_signature": "ServiceProxy.setInvokeTimeout(int invokeTimeout)", "testcase": false, "constructor": false}, {"identifier": "setInvokeUnorderedHashedTimeout", "parameters": "(int timeout)", "modifiers": "public", "return": "void", "signature": "void setInvokeUnorderedHashedTimeout(int timeout)", "full_signature": "public void setInvokeUnorderedHashedTimeout(int timeout)", "class_method_signature": "ServiceProxy.setInvokeUnorderedHashedTimeout(int timeout)", "testcase": false, "constructor": false}, {"identifier": "invokeOrdered", "parameters": "(byte[] request)", "modifiers": "public", "return": "byte[]", "signature": "byte[] invokeOrdered(byte[] request)", "full_signature": "public byte[] invokeOrdered(byte[] request)", "class_method_signature": "ServiceProxy.invokeOrdered(byte[] request)", "testcase": false, "constructor": false}, {"identifier": "invokeUnordered", "parameters": "(byte[] request)", "modifiers": "public", "return": "byte[]", "signature": "byte[] invokeUnordered(byte[] request)", "full_signature": "public byte[] invokeUnordered(byte[] request)", "class_method_signature": "ServiceProxy.invokeUnordered(byte[] request)", "testcase": false, "constructor": false}, {"identifier": "invokeUnorderedHashed", "parameters": "(byte[] request)", "modifiers": "public", "return": "byte[]", "signature": "byte[] invokeUnorderedHashed(byte[] request)", "full_signature": "public byte[] invokeUnorderedHashed(byte[] request)", "class_method_signature": "ServiceProxy.invokeUnorderedHashed(byte[] request)", "testcase": false, "constructor": false}, {"identifier": "invoke", "parameters": "(byte[] request, TOMMessageType reqType)", "modifiers": "public", "return": "byte[]", "signature": "byte[] invoke(byte[] request, TOMMessageType reqType)", "full_signature": "public byte[] invoke(byte[] request, TOMMessageType reqType)", "class_method_signature": "ServiceProxy.invoke(byte[] request, TOMMessageType reqType)", "testcase": false, "constructor": false}, {"identifier": "reconfigureTo", "parameters": "(View v)", "modifiers": "protected", "return": "void", "signature": "void reconfigureTo(View v)", "full_signature": "protected void reconfigureTo(View v)", "class_method_signature": "ServiceProxy.reconfigureTo(View v)", "testcase": false, "constructor": false}, {"identifier": "replyReceived", "parameters": "(TOMMessage reply)", "modifiers": "@Override public", "return": "void", "signature": "void replyReceived(TOMMessage reply)", "full_signature": "@Override public void replyReceived(TOMMessage reply)", "class_method_signature": "ServiceProxy.replyReceived(TOMMessage reply)", "testcase": false, "constructor": false}, {"identifier": "getReplyQuorum", "parameters": "()", "modifiers": "protected", "return": "int", "signature": "int getReplyQuorum()", "full_signature": "protected int getReplyQuorum()", "class_method_signature": "ServiceProxy.getReplyQuorum()", "testcase": false, "constructor": false}, {"identifier": "getRandomlyServerId", "parameters": "()", "modifiers": "private", "return": "int", "signature": "int getRandomlyServerId()", "full_signature": "private int getRandomlyServerId()", "class_method_signature": "ServiceProxy.getRandomlyServerId()", "testcase": false, "constructor": false}], "file": "bft-smart/src/main/java/bftsmart/tom/ServiceProxy.java"}, "focal_method": {"identifier": "replyReceived", "parameters": "(TOMMessage reply)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void replyReceived(TOMMessage reply) {\n\t\tLogger.println(\"Synchronously received reply from \" + reply.getSender() + \" with sequence number \"\n\t\t\t\t+ reply.getSequence());\n\n\t\ttry {\n\t\t\tcanReceiveLock.lock();\n\t\t\tif (reqId == -1) {// no message being expected\n\t\t\t\tLogger.println(\"throwing out request: sender=\" + reply.getSender() + \" reqId=\" + reply.getSequence());\n\t\t\t\tcanReceiveLock.unlock();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint pos = getViewManager().getCurrentViewPos(reply.getSender());\n\n\t\t\tif (pos < 0) { // ignore messages that don't come from replicas\n\t\t\t\tcanReceiveLock.unlock();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint sameContent = 1;\n\t\t\tif (reply.getSequence() == reqId && reply.getReqType() == requestType) {\n\n\t\t\t\tLogger.println(\"Receiving reply from \" + reply.getSender() + \" with reqId:\" + reply.getSequence()\n\t\t\t\t\t\t+ \". Putting on pos=\" + pos);\n\n\t\t\t\tif (requestType == TOMMessageType.UNORDERED_HASHED_REQUEST) {\n\t\t\t\t\tresponse = hashResponseController.getResponse(pos, reply);\n\t\t\t\t\tif (response != null) {\n\t\t\t\t\t\treqId = -1;\n\t\t\t\t\t\tthis.sm.release(); // resumes the thread that is executing the \"invoke\" method\n\t\t\t\t\t\tcanReceiveLock.unlock();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tif (replies[pos] == null) {\n\t\t\t\t\t\treceivedReplies++;\n\t\t\t\t\t}\n\t\t\t\t\treplies[pos] = reply;\n\n\t\t\t\t\t// Compare the reply just received, to the others\n\n\t\t\t\t\tfor (int i = 0; i < replies.length; i++) {\n\n\t\t\t\t\t\tif ((i != pos || getViewManager().getCurrentViewN() == 1) && replies[i] != null\n\t\t\t\t\t\t\t\t&& (comparator.compare(replies[i].getContent(), reply.getContent()) == 0)) {\n\t\t\t\t\t\t\tsameContent++;\n\t\t\t\t\t\t\tif (sameContent >= replyQuorum) {\n\t\t\t\t\t\t\t\tresponse = extractor.extractResponse(replies, sameContent, pos);\n\t\t\t\t\t\t\t\treqId = -1;\n\t\t\t\t\t\t\t\tthis.sm.release(); // resumes the thread that is executing the \"invoke\" method\n\t\t\t\t\t\t\t\tcanReceiveLock.unlock();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (response == null) {\n\t\t\t\t\tif (requestType.equals(TOMMessageType.ORDERED_REQUEST)) {\n\t\t\t\t\t\tif (receivedReplies == getViewManager().getCurrentViewN()) {\n\t\t\t\t\t\t\treqId = -1;\n\t\t\t\t\t\t\tthis.sm.release(); // resumes the thread that is executing the \"invoke\" method\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (requestType.equals(TOMMessageType.UNORDERED_HASHED_REQUEST)) {\n\t\t\t\t\t\tif (hashResponseController.getNumberReplies() == getViewManager().getCurrentViewN()) {\n\t\t\t\t\t\t\treqId = -1;\n\t\t\t\t\t\t\tthis.sm.release(); // resumes the thread that is executing the \"invoke\" method\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // UNORDERED\n\t\t\t\t\t\tif (receivedReplies != sameContent) {\n\t\t\t\t\t\t\treqId = -1;\n\t\t\t\t\t\t\tthis.sm.release(); // resumes the thread that is executing the \"invoke\" method\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLogger.println(\"Ignoring reply from \" + reply.getSender() + \" with reqId:\" + reply.getSequence()\n\t\t\t\t\t\t+ \". Currently wait reqId= \" + reqId);\n\n\t\t\t}\n\n\t\t\t// Critical section ends here. The semaphore can be released\n\t\t\tcanReceiveLock.unlock();\n\t\t} catch (Exception ex) {\n\t\t\tSystem.out.println(\"Problem at ServiceProxy.ReplyReceived()\");\n\t\t\tex.printStackTrace();\n\t\t\tcanReceiveLock.unlock();\n\t\t}\n\t}", "signature": "void replyReceived(TOMMessage reply)", "full_signature": "@Override public void replyReceived(TOMMessage reply)", "class_method_signature": "ServiceProxy.replyReceived(TOMMessage reply)", "testcase": false, "constructor": false, "invocations": ["println", "getSender", "getSequence", "lock", "println", "getSender", "getSequence", "unlock", "getCurrentViewPos", "getViewManager", "getSender", "unlock", "getSequence", "getReqType", "println", "getSender", "getSequence", "getResponse", "release", "unlock", "getCurrentViewN", "getViewManager", "compare", "getContent", "getContent", "extractResponse", "release", "unlock", "equals", "getCurrentViewN", "getViewManager", "release", "equals", "getNumberReplies", "getCurrentViewN", "getViewManager", "release", "release", "println", "getSender", "getSequence", "unlock", "println", "printStackTrace", "unlock"]}, "repository": {"repo_id": 144309611, "url": "https://github.com/jasonkresch/protect", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 38, "size": 1932, "license": "licensed"}}