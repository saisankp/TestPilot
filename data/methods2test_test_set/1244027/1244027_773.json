{"test_class": {"identifier": "ReplaceViewsTest", "superclass": "extends AbstractQueryTest", "interfaces": "", "fields": [{"original_string": "private ReplaceViews rule;", "modifier": "private", "type": "ReplaceViews", "declarator": "rule", "var_name": "rule"}, {"original_string": "private QueryContext context;", "modifier": "private", "type": "QueryContext", "declarator": "context", "var_name": "context"}, {"original_string": "private Schemata schemata;", "modifier": "private", "type": "Schemata", "declarator": "schemata", "var_name": "schemata"}, {"original_string": "private ImmutableSchemata.Builder builder;", "modifier": "private", "type": "ImmutableSchemata.Builder", "declarator": "builder", "var_name": "builder"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/query/optimize/ReplaceViewsTest.java"}, "test_case": {"identifier": "shouldReplaceViewWithPlanForViewWithSingleTable", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldReplaceViewWithPlanForViewWithSingleTable() {\n        // Each of the PROJECT, SELECT, and SELECT nodes must have the names of the selectors that they apply to ...\n        PlanNode project = new PlanNode(Type.PROJECT, selector(\"v1\"));\n        PlanNode select1 = new PlanNode(Type.SELECT, project, selector(\"v1\"));\n        PlanNode select2 = new PlanNode(Type.SELECT, select1, selector(\"v1\"));\n        PlanNode select3 = new PlanNode(Type.SELECT, select2, selector(\"v1\"));\n        PlanNode source = new PlanNode(Type.SOURCE, select3, selector(\"v1\"));\n        source.setProperty(Property.SOURCE_NAME, selector(\"v1\"));\n\n        // Create the equivalent plan nodes for what should be created ...\n        PlanNode viewProject = new PlanNode(Type.PROJECT, selector(\"t1\"));\n        PlanNode viewSelect = new PlanNode(Type.SELECT, viewProject, selector(\"t1\"));\n        PlanNode viewSource = new PlanNode(Type.SOURCE, viewSelect, selector(\"t1\"));\n        viewProject.setProperty(Property.PROJECT_COLUMNS, columns(column(\"t1\", \"c11\"), column(\"t1\", \"c12\")));\n        viewSelect.setProperty(Property.SELECT_CRITERIA, new Comparison(new PropertyValue(selector(\"t1\"), \"c13\"),\n                                                                        Operator.LESS_THAN, new Literal(3L)));\n        viewSource.setProperty(Property.SOURCE_NAME, selector(\"t1\"));\n        viewSource.setProperty(Property.SOURCE_COLUMNS, schemata.getTable(selector(\"t1\")).getColumns());\n\n        // Execute the rule ...\n        PlanNode result = rule.execute(context, project, new LinkedList<OptimizerRule>());\n        // System.out.println(project);\n        // System.out.println(result);\n        assertThat(result.isSameAs(project), is(true));\n        assertChildren(project, select1);\n        assertChildren(select1, select2);\n        assertChildren(select2, select3);\n    }", "signature": "void shouldReplaceViewWithPlanForViewWithSingleTable()", "full_signature": "@Test public void shouldReplaceViewWithPlanForViewWithSingleTable()", "class_method_signature": "ReplaceViewsTest.shouldReplaceViewWithPlanForViewWithSingleTable()", "testcase": true, "constructor": false, "invocations": ["selector", "selector", "selector", "selector", "selector", "setProperty", "selector", "selector", "selector", "selector", "setProperty", "columns", "column", "column", "setProperty", "selector", "setProperty", "selector", "setProperty", "getColumns", "getTable", "selector", "execute", "assertThat", "isSameAs", "is", "assertChildren", "assertChildren", "assertChildren"]}, "focal_class": {"identifier": "ReplaceViews", "superclass": "", "interfaces": "implements OptimizerRule", "fields": [{"original_string": "public static final ReplaceViews INSTANCE = new ReplaceViews();", "modifier": "public static final", "type": "ReplaceViews", "declarator": "INSTANCE = new ReplaceViews()", "var_name": "INSTANCE"}], "methods": [{"identifier": "execute", "parameters": "( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "modifiers": "@Override public", "return": "PlanNode", "signature": "PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "full_signature": "@Override public PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "class_method_signature": "ReplaceViews.execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "ReplaceViews.toString()", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/query/optimize/ReplaceViews.java"}, "focal_method": {"identifier": "execute", "parameters": "( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "modifiers": "@Override public", "return": "PlanNode", "body": "@Override\n    public PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack ) {\n        CanonicalPlanner planner = new CanonicalPlanner();\n\n        // Prepare the maps that will record the old-to-new mappings from the old view SOURCE nodes to the table SOURCEs ...\n\n        // For each of the SOURCE nodes ...\n        Schemata schemata = context.getSchemata();\n        Set<PlanNode> processedSources = new HashSet<PlanNode>();\n        boolean foundViews = false;\n        do {\n            foundViews = false;\n            for (PlanNode sourceNode : plan.findAllAtOrBelow(Type.SOURCE)) {\n                if (processedSources.contains(sourceNode)) continue;\n                processedSources.add(sourceNode);\n\n                // Resolve the node to find the definition in the schemata ...\n                SelectorName tableName = sourceNode.getProperty(Property.SOURCE_NAME, SelectorName.class);\n                SelectorName tableAlias = sourceNode.getProperty(Property.SOURCE_ALIAS, SelectorName.class);\n                Table table = schemata.getTable(tableName);\n                if (table instanceof View) {\n                    View view = (View)table;\n                    PlanNode viewPlan = planner.createPlan(context, view.getDefinition());\n                    if (viewPlan == null) continue; // there were likely errors when creating the plan\n\n                    // If the view doesn't have an alias, or if the view's alias doesn't match the table's name/alias ...\n                    PlanNode viewProjectNode = viewPlan.findAtOrBelow(Type.PROJECT);\n                    if (viewProjectNode.getSelectors().size() == 1) {\n                        SelectorName tableAliasOrName = tableAlias != null ? tableAlias : tableName;\n                        SelectorName viewAlias = viewProjectNode.getSelectors().iterator().next();\n                        // Replace the view's alias ...\n                        Map<SelectorName, SelectorName> replacements = Collections.singletonMap(viewAlias, tableAliasOrName);\n                        PlanUtil.replaceReferencesToRemovedSource(context, viewPlan, replacements);\n\n                        if (!context.getHints().validateColumnExistance) {\n                            // Find the next highest PROJECT node above the source ...\n                            PlanNode project = sourceNode.findAncestor(Type.PROJECT);\n                            if (project != null) {\n                                List<Column> projectedColumns = project.getPropertyAsList(Property.PROJECT_COLUMNS, Column.class);\n                                // There may be columns that don't appear in the source, so make sure they are there ...\n                                viewPlan = PlanUtil.addMissingProjectColumns(context, viewProjectNode, projectedColumns);\n                                assert viewPlan != null;\n                            }\n                        }\n                    }\n\n                    // Insert the view plan under the parent SOURCE node ...\n                    sourceNode.addLastChild(viewPlan);\n\n                    // Remove the source node ...\n                    sourceNode.extractFromParent();\n\n                    // // Replace the original view's name with the name/alias ...\n                    PlanNode parent = viewPlan.getParent();\n                    if (parent != null) {\n                        PlanUtil.ColumnMapping aliasMappings = null;\n                        if (tableAlias != null) {\n                            aliasMappings = PlanUtil.createMappingForAliased(tableAlias, view, viewPlan);\n                            PlanUtil.replaceViewReferences(context, parent, aliasMappings);\n                        }\n                        PlanUtil.ColumnMapping viewMappings = PlanUtil.createMappingFor(view, viewPlan);\n                        PlanUtil.replaceViewReferences(context, parent, viewMappings);\n                    }\n\n                    if (viewPlan.is(Type.PROJECT)) {\n                        // The PROJECT from the plan may actually not be needed if there is another PROJECT above it ...\n                        PlanNode node = viewPlan.getParent();\n                        while (node != null) {\n                            if (node.isOneOf(Type.JOIN)) break;\n                            if (node.is(Type.PROJECT) && viewPlan.getSelectors().containsAll(node.getSelectors())) {\n                                viewPlan.extractFromParent();\n                                break;\n                            }\n                            node = node.getParent();\n                        }\n                    }\n                    foundViews = true;\n                }\n            }\n        } while (foundViews);\n\n        if (foundViews) {\n            // We'll need to try to push up criteria from the join, but we only should do this after this rule\n            // is completely done ...\n            if (!(ruleStack.getFirst() instanceof RaiseSelectCriteria)) {\n                ruleStack.addFirst(RaiseSelectCriteria.INSTANCE);\n                ruleStack.addFirst(PushSelectCriteria.INSTANCE);\n            }\n\n            // We re-wrote at least one SOURCE, but the resulting plan tree for the view could actually reference\n            // other views. Therefore, re-run this rule ...\n            ruleStack.addFirst(this);\n        }\n        return plan;\n    }", "signature": "PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "full_signature": "@Override public PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "class_method_signature": "ReplaceViews.execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "testcase": false, "constructor": false, "invocations": ["getSchemata", "findAllAtOrBelow", "contains", "add", "getProperty", "getProperty", "getTable", "createPlan", "getDefinition", "findAtOrBelow", "size", "getSelectors", "next", "iterator", "getSelectors", "singletonMap", "replaceReferencesToRemovedSource", "getHints", "findAncestor", "getPropertyAsList", "addMissingProjectColumns", "addLastChild", "extractFromParent", "getParent", "createMappingForAliased", "replaceViewReferences", "createMappingFor", "replaceViewReferences", "is", "getParent", "isOneOf", "is", "containsAll", "getSelectors", "getSelectors", "extractFromParent", "getParent", "getFirst", "addFirst", "addFirst", "addFirst"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}