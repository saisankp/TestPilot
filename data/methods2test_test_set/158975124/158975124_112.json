{"test_class": {"identifier": "ActiveTimeSeriesCounterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String TEST_SG_PREFIX = \"root.sg_\";", "modifier": "private static final", "type": "String", "declarator": "TEST_SG_PREFIX = \"root.sg_\"", "var_name": "TEST_SG_PREFIX"}, {"original_string": "private static int testStorageGroupNum = 10;", "modifier": "private static", "type": "int", "declarator": "testStorageGroupNum = 10", "var_name": "testStorageGroupNum"}, {"original_string": "private static String[] storageGroups = new String[testStorageGroupNum];", "modifier": "private static", "type": "String[]", "declarator": "storageGroups = new String[testStorageGroupNum]", "var_name": "storageGroups"}, {"original_string": "private static int[] measurementNum = new int[testStorageGroupNum];", "modifier": "private static", "type": "int[]", "declarator": "measurementNum = new int[testStorageGroupNum]", "var_name": "measurementNum"}, {"original_string": "private static double totalSeriesNum = 0;", "modifier": "private static", "type": "double", "declarator": "totalSeriesNum = 0", "var_name": "totalSeriesNum"}], "file": "server/src/test/java/org/apache/iotdb/db/conf/adapter/ActiveTimeSeriesCounterTest.java"}, "test_case": {"identifier": "testUpdateActiveRatio", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testUpdateActiveRatio() throws Exception {\n    ExecutorService service = Executors.newFixedThreadPool(storageGroups.length);\n    CountDownLatch finished = new CountDownLatch(storageGroups.length);\n    for (int i = 0; i < storageGroups.length; i++) {\n      service.submit(new OfferThreads(storageGroups[i], measurementNum[i], finished));\n    }\n    finished.await();\n    for (String storageGroup : storageGroups) {\n      ActiveTimeSeriesCounter.getInstance().updateActiveRatio(storageGroup);\n      double sum = 0;\n      for (String s : storageGroups) {\n        sum += ActiveTimeSeriesCounter.getInstance().getActiveRatio(s);\n      }\n      assertEquals(1.0, sum, 0.001);\n    }\n    for (int i = 0; i < storageGroups.length; i++) {\n      double r = ActiveTimeSeriesCounter.getInstance().getActiveRatio(storageGroups[i]);\n      assertEquals(measurementNum[i] / totalSeriesNum, r, 0.001);\n    }\n  }", "signature": "void testUpdateActiveRatio()", "full_signature": "@Test public void testUpdateActiveRatio()", "class_method_signature": "ActiveTimeSeriesCounterTest.testUpdateActiveRatio()", "testcase": true, "constructor": false, "invocations": ["newFixedThreadPool", "submit", "await", "updateActiveRatio", "getInstance", "getActiveRatio", "getInstance", "assertEquals", "getActiveRatio", "getInstance", "assertEquals"]}, "focal_class": {"identifier": "ActiveTimeSeriesCounter", "superclass": "", "interfaces": "implements IActiveTimeSeriesCounter", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ActiveTimeSeriesCounter.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ActiveTimeSeriesCounter.class)", "var_name": "LOGGER"}, {"original_string": "private static Map<String, HyperLogLog> storageGroupHllMap = new ConcurrentHashMap<>();", "modifier": "private static", "type": "Map<String, HyperLogLog>", "declarator": "storageGroupHllMap = new ConcurrentHashMap<>()", "var_name": "storageGroupHllMap"}, {"original_string": "private static Map<String, Double> activeRatioMap = new ConcurrentHashMap<>();", "modifier": "private static", "type": "Map<String, Double>", "declarator": "activeRatioMap = new ConcurrentHashMap<>()", "var_name": "activeRatioMap"}, {"original_string": "private static Map<String, Long> activeTimeSeriesNumMap = new ConcurrentHashMap<>();", "modifier": "private static", "type": "Map<String, Long>", "declarator": "activeTimeSeriesNumMap = new ConcurrentHashMap<>()", "var_name": "activeTimeSeriesNumMap"}, {"original_string": "static final int LOG2M = 13;", "modifier": "static final", "type": "int", "declarator": "LOG2M = 13", "var_name": "LOG2M"}, {"original_string": "private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();", "modifier": "private", "type": "ReentrantReadWriteLock", "declarator": "lock = new ReentrantReadWriteLock()", "var_name": "lock"}], "methods": [{"identifier": "init", "parameters": "(String storageGroup)", "modifiers": "@Override public", "return": "void", "signature": "void init(String storageGroup)", "full_signature": "@Override public void init(String storageGroup)", "class_method_signature": "ActiveTimeSeriesCounter.init(String storageGroup)", "testcase": false, "constructor": false}, {"identifier": "offer", "parameters": "(String storageGroup, String device, String measurement)", "modifiers": "@Override public", "return": "void", "signature": "void offer(String storageGroup, String device, String measurement)", "full_signature": "@Override public void offer(String storageGroup, String device, String measurement)", "class_method_signature": "ActiveTimeSeriesCounter.offer(String storageGroup, String device, String measurement)", "testcase": false, "constructor": false}, {"identifier": "updateActiveRatio", "parameters": "(String storageGroup)", "modifiers": "@Override public", "return": "void", "signature": "void updateActiveRatio(String storageGroup)", "full_signature": "@Override public void updateActiveRatio(String storageGroup)", "class_method_signature": "ActiveTimeSeriesCounter.updateActiveRatio(String storageGroup)", "testcase": false, "constructor": false}, {"identifier": "getActiveRatio", "parameters": "(String storageGroup)", "modifiers": "@Override public", "return": "double", "signature": "double getActiveRatio(String storageGroup)", "full_signature": "@Override public double getActiveRatio(String storageGroup)", "class_method_signature": "ActiveTimeSeriesCounter.getActiveRatio(String storageGroup)", "testcase": false, "constructor": false}, {"identifier": "delete", "parameters": "(String storageGroup)", "modifiers": "@Override public", "return": "void", "signature": "void delete(String storageGroup)", "full_signature": "@Override public void delete(String storageGroup)", "class_method_signature": "ActiveTimeSeriesCounter.delete(String storageGroup)", "testcase": false, "constructor": false}, {"identifier": "getInstance", "parameters": "()", "modifiers": "public static", "return": "ActiveTimeSeriesCounter", "signature": "ActiveTimeSeriesCounter getInstance()", "full_signature": "public static ActiveTimeSeriesCounter getInstance()", "class_method_signature": "ActiveTimeSeriesCounter.getInstance()", "testcase": false, "constructor": false}, {"identifier": "clear", "parameters": "()", "modifiers": "public static", "return": "void", "signature": "void clear()", "full_signature": "public static void clear()", "class_method_signature": "ActiveTimeSeriesCounter.clear()", "testcase": false, "constructor": false}], "file": "server/src/main/java/org/apache/iotdb/db/conf/adapter/ActiveTimeSeriesCounter.java"}, "focal_method": {"identifier": "updateActiveRatio", "parameters": "(String storageGroup)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void updateActiveRatio(String storageGroup) {\n    lock.writeLock().lock();\n    try {\n      HyperLogLog log = storageGroupHllMap.get(storageGroup);\n      if (log == null) {\n        LOGGER.warn(\n            \"Unknown SG {} is calling updateActiveRatio. It can be ignored the sg is deleted recently\",\n            storageGroup);\n        return;\n      }\n      long activeTimeSeriesNum = storageGroupHllMap.get(storageGroup).cardinality();\n      if (activeTimeSeriesNum != activeTimeSeriesNumMap.get(storageGroup)) {\n        // update the active time series number in the newest memtable to be flushed\n        activeTimeSeriesNumMap.put(storageGroup, activeTimeSeriesNum);\n\n        double totalActiveTsNum = 0;\n        LOGGER.debug(\"{}: updating active ratio\", Thread.currentThread().getName());\n        for (double number : activeTimeSeriesNumMap.values()) {\n          totalActiveTsNum += number;\n        }\n        for (Map.Entry<String, Long> entry : activeTimeSeriesNumMap.entrySet()) {\n          double activeRatio = 0;\n          if (totalActiveTsNum > 0) {\n            activeRatio = entry.getValue() / totalActiveTsNum;\n          }\n          activeRatioMap.put(entry.getKey(), activeRatio);\n          LOGGER.debug(\"{}: storage group {} has an active ratio: {}\",\n              Thread.currentThread().getName(),\n              entry.getKey(), activeRatio);\n        }\n      }\n      // initialize the HLL counter\n      storageGroupHllMap.put(storageGroup, new HyperLogLog(LOG2M));\n    } catch (Exception e) {\n      LOGGER.error(\"Update {} active ratio failed\", storageGroup, e);\n    } finally {\n      lock.writeLock().unlock();\n    }\n  }", "signature": "void updateActiveRatio(String storageGroup)", "full_signature": "@Override public void updateActiveRatio(String storageGroup)", "class_method_signature": "ActiveTimeSeriesCounter.updateActiveRatio(String storageGroup)", "testcase": false, "constructor": false, "invocations": ["lock", "writeLock", "get", "warn", "cardinality", "get", "get", "put", "debug", "getName", "currentThread", "values", "entrySet", "getValue", "put", "getKey", "debug", "getName", "currentThread", "getKey", "put", "error", "unlock", "writeLock"]}, "repository": {"repo_id": 158975124, "url": "https://github.com/apache/incubator-iotdb", "stars": 449, "created": "11/24/2018 9:29:17 PM +00:00", "updates": "2020-01-21T08:10:15+00:00", "fork": "False", "license": "licensed"}}