{"test_class": {"identifier": "DistributedHerderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Map<String, String> HERDER_CONFIG = new HashMap<>();", "modifier": "private static final", "type": "Map<String, String>", "declarator": "HERDER_CONFIG = new HashMap<>()", "var_name": "HERDER_CONFIG"}, {"original_string": "private static final String MEMBER_URL = \"memberUrl\";", "modifier": "private static final", "type": "String", "declarator": "MEMBER_URL = \"memberUrl\"", "var_name": "MEMBER_URL"}, {"original_string": "private static final String CONN1 = \"sourceA\";", "modifier": "private static final", "type": "String", "declarator": "CONN1 = \"sourceA\"", "var_name": "CONN1"}, {"original_string": "private static final String CONN2 = \"sourceB\";", "modifier": "private static final", "type": "String", "declarator": "CONN2 = \"sourceB\"", "var_name": "CONN2"}, {"original_string": "private static final ConnectorTaskId TASK0 = new ConnectorTaskId(CONN1, 0);", "modifier": "private static final", "type": "ConnectorTaskId", "declarator": "TASK0 = new ConnectorTaskId(CONN1, 0)", "var_name": "TASK0"}, {"original_string": "private static final ConnectorTaskId TASK1 = new ConnectorTaskId(CONN1, 1);", "modifier": "private static final", "type": "ConnectorTaskId", "declarator": "TASK1 = new ConnectorTaskId(CONN1, 1)", "var_name": "TASK1"}, {"original_string": "private static final ConnectorTaskId TASK2 = new ConnectorTaskId(CONN1, 2);", "modifier": "private static final", "type": "ConnectorTaskId", "declarator": "TASK2 = new ConnectorTaskId(CONN1, 2)", "var_name": "TASK2"}, {"original_string": "private static final Integer MAX_TASKS = 3;", "modifier": "private static final", "type": "Integer", "declarator": "MAX_TASKS = 3", "var_name": "MAX_TASKS"}, {"original_string": "private static final Map<String, String> CONN1_CONFIG = new HashMap<>();", "modifier": "private static final", "type": "Map<String, String>", "declarator": "CONN1_CONFIG = new HashMap<>()", "var_name": "CONN1_CONFIG"}, {"original_string": "private static final Map<String, String> CONN1_CONFIG_UPDATED = new HashMap<>(CONN1_CONFIG);", "modifier": "private static final", "type": "Map<String, String>", "declarator": "CONN1_CONFIG_UPDATED = new HashMap<>(CONN1_CONFIG)", "var_name": "CONN1_CONFIG_UPDATED"}, {"original_string": "private static final Map<String, String> CONN2_CONFIG = new HashMap<>();", "modifier": "private static final", "type": "Map<String, String>", "declarator": "CONN2_CONFIG = new HashMap<>()", "var_name": "CONN2_CONFIG"}, {"original_string": "private static final Map<String, String> TASK_CONFIG = new HashMap<>();", "modifier": "private static final", "type": "Map<String, String>", "declarator": "TASK_CONFIG = new HashMap<>()", "var_name": "TASK_CONFIG"}, {"original_string": "private static final List<Map<String, String>> TASK_CONFIGS = new ArrayList<>();", "modifier": "private static final", "type": "List<Map<String, String>>", "declarator": "TASK_CONFIGS = new ArrayList<>()", "var_name": "TASK_CONFIGS"}, {"original_string": "private static final HashMap<ConnectorTaskId, Map<String, String>> TASK_CONFIGS_MAP = new HashMap<>();", "modifier": "private static final", "type": "HashMap<ConnectorTaskId, Map<String, String>>", "declarator": "TASK_CONFIGS_MAP = new HashMap<>()", "var_name": "TASK_CONFIGS_MAP"}, {"original_string": "private static final ClusterConfigState SNAPSHOT = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG), Collections.singletonMap(CONN1, TargetState.STARTED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet());", "modifier": "private static final", "type": "ClusterConfigState", "declarator": "SNAPSHOT = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG), Collections.singletonMap(CONN1, TargetState.STARTED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet())", "var_name": "SNAPSHOT"}, {"original_string": "private static final ClusterConfigState SNAPSHOT_PAUSED_CONN1 = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG), Collections.singletonMap(CONN1, TargetState.PAUSED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet());", "modifier": "private static final", "type": "ClusterConfigState", "declarator": "SNAPSHOT_PAUSED_CONN1 = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG), Collections.singletonMap(CONN1, TargetState.PAUSED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet())", "var_name": "SNAPSHOT_PAUSED_CONN1"}, {"original_string": "private static final ClusterConfigState SNAPSHOT_UPDATED_CONN1_CONFIG = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG_UPDATED), Collections.singletonMap(CONN1, TargetState.STARTED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet());", "modifier": "private static final", "type": "ClusterConfigState", "declarator": "SNAPSHOT_UPDATED_CONN1_CONFIG = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG_UPDATED), Collections.singletonMap(CONN1, TargetState.STARTED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet())", "var_name": "SNAPSHOT_UPDATED_CONN1_CONFIG"}, {"original_string": "private static final String WORKER_ID = \"localhost:8083\";", "modifier": "private static final", "type": "String", "declarator": "WORKER_ID = \"localhost:8083\"", "var_name": "WORKER_ID"}, {"original_string": "@Mock private KafkaConfigBackingStore configStorage;", "modifier": "@Mock private", "type": "KafkaConfigBackingStore", "declarator": "configStorage", "var_name": "configStorage"}, {"original_string": "@Mock private StatusBackingStore statusBackingStore;", "modifier": "@Mock private", "type": "StatusBackingStore", "declarator": "statusBackingStore", "var_name": "statusBackingStore"}, {"original_string": "@Mock private WorkerGroupMember member;", "modifier": "@Mock private", "type": "WorkerGroupMember", "declarator": "member", "var_name": "member"}, {"original_string": "private MockTime time;", "modifier": "private", "type": "MockTime", "declarator": "time", "var_name": "time"}, {"original_string": "private DistributedHerder herder;", "modifier": "private", "type": "DistributedHerder", "declarator": "herder", "var_name": "herder"}, {"original_string": "@Mock private Worker worker;", "modifier": "@Mock private", "type": "Worker", "declarator": "worker", "var_name": "worker"}, {"original_string": "@Mock private Callback<Herder.Created<ConnectorInfo>> putConnectorCallback;", "modifier": "@Mock private", "type": "Callback<Herder.Created<ConnectorInfo>>", "declarator": "putConnectorCallback", "var_name": "putConnectorCallback"}, {"original_string": "private ConfigBackingStore.UpdateListener configUpdateListener;", "modifier": "private", "type": "ConfigBackingStore.UpdateListener", "declarator": "configUpdateListener", "var_name": "configUpdateListener"}, {"original_string": "private WorkerRebalanceListener rebalanceListener;", "modifier": "private", "type": "WorkerRebalanceListener", "declarator": "rebalanceListener", "var_name": "rebalanceListener"}], "file": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/distributed/DistributedHerderTest.java"}, "test_case": {"identifier": "testRestartTask", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRestartTask() throws Exception {\n        EasyMock.expect(worker.connectorTaskConfigs(CONN1, MAX_TASKS, null)).andStubReturn(TASK_CONFIGS);\n\n        // get the initial assignment\n        EasyMock.expect(member.memberId()).andStubReturn(\"leader\");\n        expectRebalance(1, Collections.<String>emptyList(), Collections.singletonList(TASK0));\n        expectPostRebalanceCatchup(SNAPSHOT);\n        member.poll(EasyMock.anyInt());\n        PowerMock.expectLastCall();\n        worker.startTask(EasyMock.eq(TASK0), EasyMock.<TaskConfig>anyObject(), EasyMock.eq(herder), EasyMock.eq(TargetState.STARTED));\n        PowerMock.expectLastCall();\n\n        // now handle the task restart\n        member.wakeup();\n        PowerMock.expectLastCall();\n        member.ensureActive();\n        PowerMock.expectLastCall();\n        member.poll(EasyMock.anyInt());\n        PowerMock.expectLastCall();\n\n        EasyMock.expect(worker.ownsTask(TASK0)).andReturn(true);\n\n        worker.stopAndAwaitTask(TASK0);\n        PowerMock.expectLastCall();\n        worker.startTask(EasyMock.eq(TASK0), EasyMock.<TaskConfig>anyObject(), EasyMock.eq(herder), EasyMock.eq(TargetState.STARTED));\n        PowerMock.expectLastCall();\n\n        PowerMock.replayAll();\n\n        herder.tick();\n        FutureCallback<Void> callback = new FutureCallback<>();\n        herder.restartTask(TASK0, callback);\n        herder.tick();\n        callback.get(1000L, TimeUnit.MILLISECONDS);\n\n        PowerMock.verifyAll();\n    }", "signature": "void testRestartTask()", "full_signature": "@Test public void testRestartTask()", "class_method_signature": "DistributedHerderTest.testRestartTask()", "testcase": true, "constructor": false, "invocations": ["andStubReturn", "expect", "connectorTaskConfigs", "andStubReturn", "expect", "memberId", "expectRebalance", "emptyList", "singletonList", "expectPostRebalanceCatchup", "poll", "anyInt", "expectLastCall", "startTask", "eq", "anyObject", "eq", "eq", "expectLastCall", "wakeup", "expectLastCall", "ensureActive", "expectLastCall", "poll", "anyInt", "expectLastCall", "andReturn", "expect", "ownsTask", "stopAndAwaitTask", "expectLastCall", "startTask", "eq", "anyObject", "eq", "eq", "expectLastCall", "replayAll", "tick", "restartTask", "tick", "get", "verifyAll"]}, "focal_class": {"identifier": "DistributedHerder", "superclass": "extends AbstractHerder", "interfaces": "implements Runnable", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(DistributedHerder.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(DistributedHerder.class)", "var_name": "log"}, {"original_string": "private static final long RECONFIGURE_CONNECTOR_TASKS_BACKOFF_MS = 250;", "modifier": "private static final", "type": "long", "declarator": "RECONFIGURE_CONNECTOR_TASKS_BACKOFF_MS = 250", "var_name": "RECONFIGURE_CONNECTOR_TASKS_BACKOFF_MS"}, {"original_string": "private final Time time;", "modifier": "private final", "type": "Time", "declarator": "time", "var_name": "time"}, {"original_string": "private final int workerSyncTimeoutMs;", "modifier": "private final", "type": "int", "declarator": "workerSyncTimeoutMs", "var_name": "workerSyncTimeoutMs"}, {"original_string": "private final int workerUnsyncBackoffMs;", "modifier": "private final", "type": "int", "declarator": "workerUnsyncBackoffMs", "var_name": "workerUnsyncBackoffMs"}, {"original_string": "private final ExecutorService forwardRequestExecutor;", "modifier": "private final", "type": "ExecutorService", "declarator": "forwardRequestExecutor", "var_name": "forwardRequestExecutor"}, {"original_string": "private final WorkerGroupMember member;", "modifier": "private final", "type": "WorkerGroupMember", "declarator": "member", "var_name": "member"}, {"original_string": "private final AtomicBoolean stopping;", "modifier": "private final", "type": "AtomicBoolean", "declarator": "stopping", "var_name": "stopping"}, {"original_string": "private final CountDownLatch stopLatch = new CountDownLatch(1);", "modifier": "private final", "type": "CountDownLatch", "declarator": "stopLatch = new CountDownLatch(1)", "var_name": "stopLatch"}, {"original_string": "private boolean rebalanceResolved;", "modifier": "private", "type": "boolean", "declarator": "rebalanceResolved", "var_name": "rebalanceResolved"}, {"original_string": "private ConnectProtocol.Assignment assignment;", "modifier": "private", "type": "ConnectProtocol.Assignment", "declarator": "assignment", "var_name": "assignment"}, {"original_string": "private boolean canReadConfigs;", "modifier": "private", "type": "boolean", "declarator": "canReadConfigs", "var_name": "canReadConfigs"}, {"original_string": "private ClusterConfigState configState;", "modifier": "private", "type": "ClusterConfigState", "declarator": "configState", "var_name": "configState"}, {"original_string": "private final Queue<HerderRequest> requests = new PriorityQueue<>();", "modifier": "private final", "type": "Queue<HerderRequest>", "declarator": "requests = new PriorityQueue<>()", "var_name": "requests"}, {"original_string": "private Set<String> connectorConfigUpdates = new HashSet<>();", "modifier": "private", "type": "Set<String>", "declarator": "connectorConfigUpdates = new HashSet<>()", "var_name": "connectorConfigUpdates"}, {"original_string": "private Set<String> connectorTargetStateChanges = new HashSet<>();", "modifier": "private", "type": "Set<String>", "declarator": "connectorTargetStateChanges = new HashSet<>()", "var_name": "connectorTargetStateChanges"}, {"original_string": "private boolean needsReconfigRebalance;", "modifier": "private", "type": "boolean", "declarator": "needsReconfigRebalance", "var_name": "needsReconfigRebalance"}, {"original_string": "private volatile int generation;", "modifier": "private volatile", "type": "int", "declarator": "generation", "var_name": "generation"}], "methods": [{"identifier": "DistributedHerder", "parameters": "(DistributedConfig config,\n                             Time time,\n                             Worker worker,\n                             StatusBackingStore statusBackingStore,\n                             ConfigBackingStore configBackingStore,\n                             String restUrl)", "modifiers": "public", "return": "", "signature": " DistributedHerder(DistributedConfig config,\n                             Time time,\n                             Worker worker,\n                             StatusBackingStore statusBackingStore,\n                             ConfigBackingStore configBackingStore,\n                             String restUrl)", "full_signature": "public  DistributedHerder(DistributedConfig config,\n                             Time time,\n                             Worker worker,\n                             StatusBackingStore statusBackingStore,\n                             ConfigBackingStore configBackingStore,\n                             String restUrl)", "class_method_signature": "DistributedHerder.DistributedHerder(DistributedConfig config,\n                             Time time,\n                             Worker worker,\n                             StatusBackingStore statusBackingStore,\n                             ConfigBackingStore configBackingStore,\n                             String restUrl)", "testcase": false, "constructor": true}, {"identifier": "DistributedHerder", "parameters": "(DistributedConfig config,\n                      Worker worker,\n                      String workerId,\n                      StatusBackingStore statusBackingStore,\n                      ConfigBackingStore configStorage,\n                      WorkerGroupMember member,\n                      String restUrl,\n                      Time time)", "modifiers": "", "return": "", "signature": " DistributedHerder(DistributedConfig config,\n                      Worker worker,\n                      String workerId,\n                      StatusBackingStore statusBackingStore,\n                      ConfigBackingStore configStorage,\n                      WorkerGroupMember member,\n                      String restUrl,\n                      Time time)", "full_signature": "  DistributedHerder(DistributedConfig config,\n                      Worker worker,\n                      String workerId,\n                      StatusBackingStore statusBackingStore,\n                      ConfigBackingStore configStorage,\n                      WorkerGroupMember member,\n                      String restUrl,\n                      Time time)", "class_method_signature": "DistributedHerder.DistributedHerder(DistributedConfig config,\n                      Worker worker,\n                      String workerId,\n                      StatusBackingStore statusBackingStore,\n                      ConfigBackingStore configStorage,\n                      WorkerGroupMember member,\n                      String restUrl,\n                      Time time)", "testcase": false, "constructor": true}, {"identifier": "start", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void start()", "full_signature": "@Override public void start()", "class_method_signature": "DistributedHerder.start()", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "DistributedHerder.run()", "testcase": false, "constructor": false}, {"identifier": "tick", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void tick()", "full_signature": "public void tick()", "class_method_signature": "DistributedHerder.tick()", "testcase": false, "constructor": false}, {"identifier": "processConnectorConfigUpdates", "parameters": "(Set<String> connectorConfigUpdates)", "modifiers": "private", "return": "void", "signature": "void processConnectorConfigUpdates(Set<String> connectorConfigUpdates)", "full_signature": "private void processConnectorConfigUpdates(Set<String> connectorConfigUpdates)", "class_method_signature": "DistributedHerder.processConnectorConfigUpdates(Set<String> connectorConfigUpdates)", "testcase": false, "constructor": false}, {"identifier": "processTargetStateChanges", "parameters": "(Set<String> connectorTargetStateChanges)", "modifiers": "private", "return": "void", "signature": "void processTargetStateChanges(Set<String> connectorTargetStateChanges)", "full_signature": "private void processTargetStateChanges(Set<String> connectorTargetStateChanges)", "class_method_signature": "DistributedHerder.processTargetStateChanges(Set<String> connectorTargetStateChanges)", "testcase": false, "constructor": false}, {"identifier": "halt", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void halt()", "full_signature": "public void halt()", "class_method_signature": "DistributedHerder.halt()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void stop()", "full_signature": "@Override public void stop()", "class_method_signature": "DistributedHerder.stop()", "testcase": false, "constructor": false}, {"identifier": "connectors", "parameters": "(final Callback<Collection<String>> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void connectors(final Callback<Collection<String>> callback)", "full_signature": "@Override public synchronized void connectors(final Callback<Collection<String>> callback)", "class_method_signature": "DistributedHerder.connectors(final Callback<Collection<String>> callback)", "testcase": false, "constructor": false}, {"identifier": "connectorInfo", "parameters": "(final String connName, final Callback<ConnectorInfo> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void connectorInfo(final String connName, final Callback<ConnectorInfo> callback)", "full_signature": "@Override public synchronized void connectorInfo(final String connName, final Callback<ConnectorInfo> callback)", "class_method_signature": "DistributedHerder.connectorInfo(final String connName, final Callback<ConnectorInfo> callback)", "testcase": false, "constructor": false}, {"identifier": "connectorConfig", "parameters": "(String connName, final Callback<Map<String, String>> callback)", "modifiers": "@Override public", "return": "void", "signature": "void connectorConfig(String connName, final Callback<Map<String, String>> callback)", "full_signature": "@Override public void connectorConfig(String connName, final Callback<Map<String, String>> callback)", "class_method_signature": "DistributedHerder.connectorConfig(String connName, final Callback<Map<String, String>> callback)", "testcase": false, "constructor": false}, {"identifier": "putConnectorConfig", "parameters": "(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "modifiers": "@Override public", "return": "void", "signature": "void putConnectorConfig(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "full_signature": "@Override public void putConnectorConfig(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "class_method_signature": "DistributedHerder.putConnectorConfig(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "testcase": false, "constructor": false}, {"identifier": "requestTaskReconfiguration", "parameters": "(final String connName)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void requestTaskReconfiguration(final String connName)", "full_signature": "@Override public synchronized void requestTaskReconfiguration(final String connName)", "class_method_signature": "DistributedHerder.requestTaskReconfiguration(final String connName)", "testcase": false, "constructor": false}, {"identifier": "taskConfigs", "parameters": "(final String connName, final Callback<List<TaskInfo>> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void taskConfigs(final String connName, final Callback<List<TaskInfo>> callback)", "full_signature": "@Override public synchronized void taskConfigs(final String connName, final Callback<List<TaskInfo>> callback)", "class_method_signature": "DistributedHerder.taskConfigs(final String connName, final Callback<List<TaskInfo>> callback)", "testcase": false, "constructor": false}, {"identifier": "putTaskConfigs", "parameters": "(final String connName, final List<Map<String, String>> configs, final Callback<Void> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void putTaskConfigs(final String connName, final List<Map<String, String>> configs, final Callback<Void> callback)", "full_signature": "@Override public synchronized void putTaskConfigs(final String connName, final List<Map<String, String>> configs, final Callback<Void> callback)", "class_method_signature": "DistributedHerder.putTaskConfigs(final String connName, final List<Map<String, String>> configs, final Callback<Void> callback)", "testcase": false, "constructor": false}, {"identifier": "restartConnector", "parameters": "(final String connName, final Callback<Void> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void restartConnector(final String connName, final Callback<Void> callback)", "full_signature": "@Override public synchronized void restartConnector(final String connName, final Callback<Void> callback)", "class_method_signature": "DistributedHerder.restartConnector(final String connName, final Callback<Void> callback)", "testcase": false, "constructor": false}, {"identifier": "restartTask", "parameters": "(final ConnectorTaskId id, final Callback<Void> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void restartTask(final ConnectorTaskId id, final Callback<Void> callback)", "full_signature": "@Override public synchronized void restartTask(final ConnectorTaskId id, final Callback<Void> callback)", "class_method_signature": "DistributedHerder.restartTask(final ConnectorTaskId id, final Callback<Void> callback)", "testcase": false, "constructor": false}, {"identifier": "generation", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int generation()", "full_signature": "@Override public int generation()", "class_method_signature": "DistributedHerder.generation()", "testcase": false, "constructor": false}, {"identifier": "isLeader", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean isLeader()", "full_signature": "private boolean isLeader()", "class_method_signature": "DistributedHerder.isLeader()", "testcase": false, "constructor": false}, {"identifier": "leaderUrl", "parameters": "()", "modifiers": "private", "return": "String", "signature": "String leaderUrl()", "full_signature": "private String leaderUrl()", "class_method_signature": "DistributedHerder.leaderUrl()", "testcase": false, "constructor": false}, {"identifier": "handleRebalanceCompleted", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean handleRebalanceCompleted()", "full_signature": "private boolean handleRebalanceCompleted()", "class_method_signature": "DistributedHerder.handleRebalanceCompleted()", "testcase": false, "constructor": false}, {"identifier": "readConfigToEnd", "parameters": "(long timeoutMs)", "modifiers": "private", "return": "boolean", "signature": "boolean readConfigToEnd(long timeoutMs)", "full_signature": "private boolean readConfigToEnd(long timeoutMs)", "class_method_signature": "DistributedHerder.readConfigToEnd(long timeoutMs)", "testcase": false, "constructor": false}, {"identifier": "backoff", "parameters": "(long ms)", "modifiers": "private", "return": "void", "signature": "void backoff(long ms)", "full_signature": "private void backoff(long ms)", "class_method_signature": "DistributedHerder.backoff(long ms)", "testcase": false, "constructor": false}, {"identifier": "startWork", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void startWork()", "full_signature": "private void startWork()", "class_method_signature": "DistributedHerder.startWork()", "testcase": false, "constructor": false}, {"identifier": "startTask", "parameters": "(ConnectorTaskId taskId)", "modifiers": "private", "return": "void", "signature": "void startTask(ConnectorTaskId taskId)", "full_signature": "private void startTask(ConnectorTaskId taskId)", "class_method_signature": "DistributedHerder.startTask(ConnectorTaskId taskId)", "testcase": false, "constructor": false}, {"identifier": "startConnector", "parameters": "(String connectorName)", "modifiers": "private", "return": "void", "signature": "void startConnector(String connectorName)", "full_signature": "private void startConnector(String connectorName)", "class_method_signature": "DistributedHerder.startConnector(String connectorName)", "testcase": false, "constructor": false}, {"identifier": "reconfigureConnectorTasksWithRetry", "parameters": "(final String connName)", "modifiers": "private", "return": "void", "signature": "void reconfigureConnectorTasksWithRetry(final String connName)", "full_signature": "private void reconfigureConnectorTasksWithRetry(final String connName)", "class_method_signature": "DistributedHerder.reconfigureConnectorTasksWithRetry(final String connName)", "testcase": false, "constructor": false}, {"identifier": "reconfigureConnector", "parameters": "(final String connName, final Callback<Void> cb)", "modifiers": "private", "return": "void", "signature": "void reconfigureConnector(final String connName, final Callback<Void> cb)", "full_signature": "private void reconfigureConnector(final String connName, final Callback<Void> cb)", "class_method_signature": "DistributedHerder.reconfigureConnector(final String connName, final Callback<Void> cb)", "testcase": false, "constructor": false}, {"identifier": "checkRebalanceNeeded", "parameters": "(Callback<?> callback)", "modifiers": "private", "return": "boolean", "signature": "boolean checkRebalanceNeeded(Callback<?> callback)", "full_signature": "private boolean checkRebalanceNeeded(Callback<?> callback)", "class_method_signature": "DistributedHerder.checkRebalanceNeeded(Callback<?> callback)", "testcase": false, "constructor": false}, {"identifier": "addRequest", "parameters": "(Callable<Void> action, Callback<Void> callback)", "modifiers": "private", "return": "void", "signature": "void addRequest(Callable<Void> action, Callback<Void> callback)", "full_signature": "private void addRequest(Callable<Void> action, Callback<Void> callback)", "class_method_signature": "DistributedHerder.addRequest(Callable<Void> action, Callback<Void> callback)", "testcase": false, "constructor": false}, {"identifier": "addRequest", "parameters": "(long delayMs, Callable<Void> action, Callback<Void> callback)", "modifiers": "private", "return": "void", "signature": "void addRequest(long delayMs, Callable<Void> action, Callback<Void> callback)", "full_signature": "private void addRequest(long delayMs, Callable<Void> action, Callback<Void> callback)", "class_method_signature": "DistributedHerder.addRequest(long delayMs, Callable<Void> action, Callback<Void> callback)", "testcase": false, "constructor": false}, {"identifier": "forwardErrorCallback", "parameters": "(final Callback<?> callback)", "modifiers": "private static final", "return": "Callback<Void>", "signature": "Callback<Void> forwardErrorCallback(final Callback<?> callback)", "full_signature": "private static final Callback<Void> forwardErrorCallback(final Callback<?> callback)", "class_method_signature": "DistributedHerder.forwardErrorCallback(final Callback<?> callback)", "testcase": false, "constructor": false}, {"identifier": "updateDeletedConnectorStatus", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void updateDeletedConnectorStatus()", "full_signature": "private void updateDeletedConnectorStatus()", "class_method_signature": "DistributedHerder.updateDeletedConnectorStatus()", "testcase": false, "constructor": false}], "file": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java"}, "focal_method": {"identifier": "restartTask", "parameters": "(final ConnectorTaskId id, final Callback<Void> callback)", "modifiers": "@Override public synchronized", "return": "void", "body": "@Override\n    public synchronized void restartTask(final ConnectorTaskId id, final Callback<Void> callback) {\n        addRequest(new Callable<Void>() {\n            @Override\n            public Void call() throws Exception {\n                if (checkRebalanceNeeded(callback))\n                    return null;\n\n                if (!configState.connectors().contains(id.connector())) {\n                    callback.onCompletion(new NotFoundException(\"Unknown connector: \" + id.connector()), null);\n                    return null;\n                }\n\n                if (configState.taskConfig(id) == null) {\n                    callback.onCompletion(new NotFoundException(\"Unknown task: \" + id), null);\n                    return null;\n                }\n\n                if (worker.ownsTask(id)) {\n                    try {\n                        worker.stopAndAwaitTask(id);\n                        startTask(id);\n                        callback.onCompletion(null, null);\n                    } catch (Throwable t) {\n                        callback.onCompletion(t, null);\n                    }\n                } else if (isLeader()) {\n                    callback.onCompletion(new NotAssignedException(\"Cannot restart task since it is not assigned to this member\", member.ownerUrl(id)), null);\n                } else {\n                    callback.onCompletion(new NotLeaderException(\"Cannot restart task since it is not assigned to this member\", leaderUrl()), null);\n                }\n                return null;\n            }\n        }, forwardErrorCallback(callback));\n    }", "signature": "void restartTask(final ConnectorTaskId id, final Callback<Void> callback)", "full_signature": "@Override public synchronized void restartTask(final ConnectorTaskId id, final Callback<Void> callback)", "class_method_signature": "DistributedHerder.restartTask(final ConnectorTaskId id, final Callback<Void> callback)", "testcase": false, "constructor": false, "invocations": ["addRequest", "checkRebalanceNeeded", "contains", "connectors", "connector", "onCompletion", "connector", "taskConfig", "onCompletion", "ownsTask", "stopAndAwaitTask", "startTask", "onCompletion", "onCompletion", "isLeader", "onCompletion", "ownerUrl", "onCompletion", "leaderUrl", "forwardErrorCallback"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}