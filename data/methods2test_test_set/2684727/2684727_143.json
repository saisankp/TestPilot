{"test_class": {"identifier": "ImageImportProcessorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String SAMPLE_JPG = \"sample.jpg\";", "modifier": "private static final", "type": "String", "declarator": "SAMPLE_JPG = \"sample.jpg\"", "var_name": "SAMPLE_JPG"}, {"original_string": "private static final String SAMPLE_JPG_BIG = \"sample_big.jpg\";", "modifier": "private static final", "type": "String", "declarator": "SAMPLE_JPG_BIG = \"sample_big.jpg\"", "var_name": "SAMPLE_JPG_BIG"}, {"original_string": "private static final String SAMPLE_JPG_WITH_EXIF = \"sample_with_exif_to_rotate.jpg\";", "modifier": "private static final", "type": "String", "declarator": "SAMPLE_JPG_WITH_EXIF = \"sample_with_exif_to_rotate.jpg\"", "var_name": "SAMPLE_JPG_WITH_EXIF"}, {"original_string": "ImageImportProcessor importProcessor;", "modifier": "", "type": "ImageImportProcessor", "declarator": "importProcessor", "var_name": "importProcessor"}, {"original_string": "Context context;", "modifier": "", "type": "Context", "declarator": "context", "var_name": "context"}, {"original_string": "File destination;", "modifier": "", "type": "File", "declarator": "destination", "var_name": "destination"}, {"original_string": "@Mock\n    Trip trip;", "modifier": "@Mock", "type": "Trip", "declarator": "trip", "var_name": "trip"}, {"original_string": "@Mock\n    StorageManager storageManager;", "modifier": "@Mock", "type": "StorageManager", "declarator": "storageManager", "var_name": "storageManager"}, {"original_string": "@Mock\n    UserPreferenceManager preferences;", "modifier": "@Mock", "type": "UserPreferenceManager", "declarator": "preferences", "var_name": "preferences"}, {"original_string": "@Mock\n    ContentResolver contentResolver;", "modifier": "@Mock", "type": "ContentResolver", "declarator": "contentResolver", "var_name": "contentResolver"}, {"original_string": "@Captor\n    ArgumentCaptor<Bitmap> bitmapCaptor;", "modifier": "@Captor", "type": "ArgumentCaptor<Bitmap>", "declarator": "bitmapCaptor", "var_name": "bitmapCaptor"}], "file": "app/src/test/java/co/smartreceipts/android/imports/ImageImportProcessorTest.java"}, "test_case": {"identifier": "importUriScalesDownSizes", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void importUriScalesDownSizes() throws Exception {\n        final Uri uri = Uri.fromFile(destination);\n        configureUriForStream(uri, SAMPLE_JPG_BIG);\n        when(preferences.get(UserPreference.Camera.AutomaticallyRotateImages)).thenReturn(false);\n        when(storageManager.writeBitmap(any(Uri.class), bitmapCaptor.capture(), eq(Bitmap.CompressFormat.JPEG), eq(ImageImportProcessor.COMPRESSION_QUALITY))).thenReturn(true);\n\n        importProcessor.process(uri)\n                .test()\n                .assertValue(destination)\n                .assertComplete();\n\n        // Note: we only scale down til one dimension is < 1024\n        final Bitmap bitmap = bitmapCaptor.getValue();\n        assertNotNull(bitmap);\n        assertEquals(1100, bitmap.getWidth());\n        assertEquals(800, bitmap.getHeight());\n    }", "signature": "void importUriScalesDownSizes()", "full_signature": "@Test public void importUriScalesDownSizes()", "class_method_signature": "ImageImportProcessorTest.importUriScalesDownSizes()", "testcase": true, "constructor": false, "invocations": ["fromFile", "configureUriForStream", "thenReturn", "when", "get", "thenReturn", "when", "writeBitmap", "any", "capture", "eq", "eq", "assertComplete", "assertValue", "test", "process", "getValue", "assertNotNull", "assertEquals", "getWidth", "assertEquals", "getHeight"]}, "focal_class": {"identifier": "ImageImportProcessor", "superclass": "", "interfaces": "implements FileImportProcessor", "fields": [{"original_string": "@VisibleForTesting\n    static final int COMPRESSION_QUALITY = 95;", "modifier": "@VisibleForTesting\n    static final", "type": "int", "declarator": "COMPRESSION_QUALITY = 95", "var_name": "COMPRESSION_QUALITY"}, {"original_string": "private static final int MAX_DIMENSION = 1024;", "modifier": "private static final", "type": "int", "declarator": "MAX_DIMENSION = 1024", "var_name": "MAX_DIMENSION"}, {"original_string": "private static final String READ_EXTERNAL_STORAGE = \"android.permission.READ_EXTERNAL_STORAGE\";", "modifier": "private static final", "type": "String", "declarator": "READ_EXTERNAL_STORAGE = \"android.permission.READ_EXTERNAL_STORAGE\"", "var_name": "READ_EXTERNAL_STORAGE"}, {"original_string": "private final Trip mTrip;", "modifier": "private final", "type": "Trip", "declarator": "mTrip", "var_name": "mTrip"}, {"original_string": "private final StorageManager mStorageManner;", "modifier": "private final", "type": "StorageManager", "declarator": "mStorageManner", "var_name": "mStorageManner"}, {"original_string": "private final UserPreferenceManager mPreferences;", "modifier": "private final", "type": "UserPreferenceManager", "declarator": "mPreferences", "var_name": "mPreferences"}, {"original_string": "private final Context mContext;", "modifier": "private final", "type": "Context", "declarator": "mContext", "var_name": "mContext"}, {"original_string": "private final ContentResolver mContentResolver;", "modifier": "private final", "type": "ContentResolver", "declarator": "mContentResolver", "var_name": "mContentResolver"}], "methods": [{"identifier": "ImageImportProcessor", "parameters": "(@NonNull Trip trip, @NonNull StorageManager storageManager, @NonNull UserPreferenceManager preferences, @NonNull Context context)", "modifiers": "public", "return": "", "signature": " ImageImportProcessor(@NonNull Trip trip, @NonNull StorageManager storageManager, @NonNull UserPreferenceManager preferences, @NonNull Context context)", "full_signature": "public  ImageImportProcessor(@NonNull Trip trip, @NonNull StorageManager storageManager, @NonNull UserPreferenceManager preferences, @NonNull Context context)", "class_method_signature": "ImageImportProcessor.ImageImportProcessor(@NonNull Trip trip, @NonNull StorageManager storageManager, @NonNull UserPreferenceManager preferences, @NonNull Context context)", "testcase": false, "constructor": true}, {"identifier": "ImageImportProcessor", "parameters": "(@NonNull Trip trip, @NonNull StorageManager storageManager, @NonNull UserPreferenceManager preferences, @NonNull Context context, @NonNull ContentResolver contentResolver)", "modifiers": "public", "return": "", "signature": " ImageImportProcessor(@NonNull Trip trip, @NonNull StorageManager storageManager, @NonNull UserPreferenceManager preferences, @NonNull Context context, @NonNull ContentResolver contentResolver)", "full_signature": "public  ImageImportProcessor(@NonNull Trip trip, @NonNull StorageManager storageManager, @NonNull UserPreferenceManager preferences, @NonNull Context context, @NonNull ContentResolver contentResolver)", "class_method_signature": "ImageImportProcessor.ImageImportProcessor(@NonNull Trip trip, @NonNull StorageManager storageManager, @NonNull UserPreferenceManager preferences, @NonNull Context context, @NonNull ContentResolver contentResolver)", "testcase": false, "constructor": true}, {"identifier": "process", "parameters": "(@NonNull final Uri uri)", "modifiers": "@NonNull @Override public", "return": "Single<File>", "signature": "Single<File> process(@NonNull final Uri uri)", "full_signature": "@NonNull @Override public Single<File> process(@NonNull final Uri uri)", "class_method_signature": "ImageImportProcessor.process(@NonNull final Uri uri)", "testcase": false, "constructor": false}, {"identifier": "getImageScaleFactor", "parameters": "(@NonNull Uri uri)", "modifiers": "private", "return": "int", "signature": "int getImageScaleFactor(@NonNull Uri uri)", "full_signature": "private int getImageScaleFactor(@NonNull Uri uri)", "class_method_signature": "ImageImportProcessor.getImageScaleFactor(@NonNull Uri uri)", "testcase": false, "constructor": false}, {"identifier": "getOrientationFromMediaStore", "parameters": "(@NonNull Uri externalUri)", "modifiers": "private", "return": "int", "signature": "int getOrientationFromMediaStore(@NonNull Uri externalUri)", "full_signature": "private int getOrientationFromMediaStore(@NonNull Uri externalUri)", "class_method_signature": "ImageImportProcessor.getOrientationFromMediaStore(@NonNull Uri externalUri)", "testcase": false, "constructor": false}], "file": "app/src/main/java/co/smartreceipts/android/imports/ImageImportProcessor.java"}, "focal_method": {"identifier": "process", "parameters": "(@NonNull final Uri uri)", "modifiers": "@NonNull @Override public", "return": "Single<File>", "body": "@NonNull\n    @Override\n    public Single<File> process(@NonNull final Uri uri) {\n        return Single.create(emitter -> {\n            InputStream inputStream = null;\n            try {\n                inputStream = mContentResolver.openInputStream(uri);\n                if (inputStream != null) {\n                    final int scale = getImageScaleFactor(uri);\n\n                    // Get scaled bitmap\n                    final BitmapFactory.Options smallerOpts = new BitmapFactory.Options();\n                    smallerOpts.inSampleSize = scale;\n                    Bitmap bitmap = BitmapFactory.decodeStream(inputStream, null, smallerOpts);\n\n                    // Checking if this file is actual image\n                    if (smallerOpts.outHeight <= 0 && smallerOpts.outWidth <= 0) {\n                        emitter.onError(new InvalidImageException(\"Looks like selected file is not an image\"));\n                        return;\n                    }\n\n                    // Perform image processing\n                    if (mPreferences.get(UserPreference.Camera.SaveImagesInGrayScale)) {\n                        bitmap = ImageUtils.convertToGrayScale(bitmap);\n                    }\n\n                    if (mPreferences.get(UserPreference.Camera.AutomaticallyRotateImages)) {\n                        Logger.debug(ImageImportProcessor.this, \"Configured for auto-rotation. Attempting to determine the orientation\");\n                        int orientation = getOrientationFromMediaStore(uri);\n\n                        if (orientation == ExifInterface.ORIENTATION_UNDEFINED) {\n                            Logger.warn(ImageImportProcessor.this, \"Failed to fetch orientation information from the content store. Trying from Exif.\");\n                            InputStream exifInputStream = null; // Note: Re-open to avoid issues with #reset()\n                            try {\n                                exifInputStream = mContentResolver.openInputStream(uri);\n                                if (exifInputStream != null) {\n                                    final ExifInterface exif = new ExifInterface(exifInputStream);\n                                    orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);\n                                    Logger.info(ImageImportProcessor.this, \"Read exif orientation as {}\", orientation);\n                                }\n                            } catch (IOException e) {\n                                Logger.error(ImageImportProcessor.this, \"An Exif parsing exception occurred\", e);\n                            } finally {\n                                StorageManager.closeQuietly(exifInputStream);\n                            }\n                        }\n\n                        if (orientation != ExifInterface.ORIENTATION_UNDEFINED) {\n                            Logger.info(ImageImportProcessor.this, \"Image orientation determined as {}. Rotating...\", orientation);\n                            bitmap = ImageUtils.rotateBitmap(bitmap, orientation);\n                        } else {\n                            Logger.warn(ImageImportProcessor.this, \"Indeterminate orientation. Skipping rotation\");\n                        }\n                    } else {\n                        Logger.info(ImageImportProcessor.this, \"Image import rotation is disabled. Ignoring...\");\n                    }\n\n                    if (bitmap != null) {\n                        final File destination = mStorageManner.getFile(mTrip.getDirectory(), System.currentTimeMillis() + \".jpg\");\n                        final Bitmap.CompressFormat compressFormat = Bitmap.CompressFormat.JPEG;\n\n                        if (!mStorageManner.writeBitmap(Uri.fromFile(destination), bitmap, compressFormat, COMPRESSION_QUALITY)) {\n                            Logger.error(ImageImportProcessor.this, \"Failed to write the image data. Aborting\");\n                            emitter.onError(new IOException(\"Failed to write the image data. Aborting\"));\n                        } else {\n                            Logger.info(ImageImportProcessor.this, \"Successfully saved the image to {}.\", destination);\n                            emitter.onSuccess(destination);\n                        }\n                    }\n                } else {\n                    emitter.onError(new FileNotFoundException());\n                }\n            } catch (IOException e) {\n                emitter.onError(e);\n            } finally {\n                StorageManager.closeQuietly(inputStream);\n            }\n        });\n    }", "signature": "Single<File> process(@NonNull final Uri uri)", "full_signature": "@NonNull @Override public Single<File> process(@NonNull final Uri uri)", "class_method_signature": "ImageImportProcessor.process(@NonNull final Uri uri)", "testcase": false, "constructor": false, "invocations": ["create", "openInputStream", "getImageScaleFactor", "decodeStream", "onError", "get", "convertToGrayScale", "get", "debug", "getOrientationFromMediaStore", "warn", "openInputStream", "getAttributeInt", "info", "error", "closeQuietly", "info", "rotateBitmap", "warn", "info", "getFile", "getDirectory", "currentTimeMillis", "writeBitmap", "fromFile", "error", "onError", "info", "onSuccess", "onError", "onError", "closeQuietly"]}, "repository": {"repo_id": 2684727, "url": "https://github.com/wbaumann/SmartReceiptsLibrary", "stars": 166, "created": "11/1/2011 12:32:39 AM +00:00", "updates": "2020-01-26T22:04:24+00:00", "fork": "False", "license": "licensed"}}