{"test_class": {"identifier": "EXPDPersistenceServiceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Logger log = LoggerFactory.getLogger(getClass());", "modifier": "private final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(getClass())", "var_name": "log"}, {"original_string": "DateFormat dateFormat;", "modifier": "", "type": "DateFormat", "declarator": "dateFormat", "var_name": "dateFormat"}, {"original_string": "ExternalDataPersistenceService dao;", "modifier": "", "type": "ExternalDataPersistenceService", "declarator": "dao", "var_name": "dao"}], "file": "vars-jpa/src/test/java/vars/EXPDPersistenceServiceTest.java"}, "test_case": {"identifier": "findTimecodeByDateTest01", "parameters": "()", "modifiers": "@Test @Ignore // Uncomment this to test in MBARI environment. public", "return": "void", "body": "@Test\n    @Ignore // Uncomment this to test in MBARI environment.\n    public void findTimecodeByDateTest01() {\n\n        int millisecTolerance = 1000 * 7;\n        double framerate = 29.97;\n\n        List<TimecodeBean> beans = new ArrayList<TimecodeBean>();\n        try {\n            beans.add(new TimecodeBean(new Timecode(\"04:28:08:03\", framerate),\n                    dateFormat.parse(\"2008-05-19T21:03:31Z\"), \"Ventana\"));\n            beans.add(new TimecodeBean(new Timecode(\"04:31:49:13\", framerate),\n                    dateFormat.parse(\"2007-12-20T20:34:08Z\"), \"Tiburon\"));\n            beans.add(new TimecodeBean(new Timecode(\"01:05:48:24\", framerate),\n                    dateFormat.parse(\"2008-04-09T17:16:35Z\"), \"Ventana\"));\n\n        }\n        catch (ParseException e) {\n            log.error(\"Failed to generate test data\", e);\n            Assert.fail(\"Failed to generate test data\");\n        }\n\n        for (TimecodeBean b : beans) {\n            VideoMoment videoMoment = dao.findTimecodeNearDate(b.platform, b.date, millisecTolerance);\n            Timecode tc = new Timecode(videoMoment.getAlternateTimecode(), framerate);\n            double dt = Math.abs(tc.diffFrames(b.timecode));\n            log.debug(\"EXPECTED: \" + b.timecode + \" FOUND: \" + tc);\n\n            /* This doesn't always work as expected because of the lag between the\n             * VXWorks clock used to write the utc time to the tape and all the\n             * other computers which are NTP'd\n             */\n            Assert.assertTrue(\"Timecode is wrong. EXPECTED: \" + b.timecode +\n                    \" FOUND: \" + tc, dt / framerate * 1000 <= millisecTolerance);\n        }\n\n    }", "signature": "void findTimecodeByDateTest01()", "full_signature": "@Test @Ignore // Uncomment this to test in MBARI environment. public void findTimecodeByDateTest01()", "class_method_signature": "EXPDPersistenceServiceTest.findTimecodeByDateTest01()", "testcase": true, "constructor": false, "invocations": ["add", "parse", "add", "parse", "add", "parse", "error", "fail", "findTimecodeNearDate", "getAlternateTimecode", "abs", "diffFrames", "debug", "assertTrue"]}, "focal_class": {"identifier": "EXPDPersistenceService", "superclass": "extends QueryableImpl", "interfaces": "implements ExternalDataPersistenceService", "fields": [{"original_string": "public static final int SAMPLERATE_MILLSEC = 15 * 1000;", "modifier": "public static final", "type": "int", "declarator": "SAMPLERATE_MILLSEC = 15 * 1000", "var_name": "SAMPLERATE_MILLSEC"}, {"original_string": "private static final Calendar CALENDAR = new GregorianCalendar(TimeZone.getTimeZone(\"UTC\"));", "modifier": "private static final", "type": "Calendar", "declarator": "CALENDAR = new GregorianCalendar(TimeZone.getTimeZone(\"UTC\"))", "var_name": "CALENDAR"}, {"original_string": "private final Logger log = LoggerFactory.getLogger(getClass());", "modifier": "private final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(getClass())", "var_name": "log"}, {"original_string": "private final DateFormat dateFormatUTC = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\") {{\n            setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n    }};", "modifier": "private final", "type": "DateFormat", "declarator": "dateFormatUTC = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\") {{\n            setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n    }}", "var_name": "dateFormatUTC"}, {"original_string": "private final Predicate<VideoMoment> nonNullTimecodePredicate = new Predicate<VideoMoment>() {\n        public boolean apply(VideoMoment arg0) {\n            return arg0.getTimecode() != null;\n        }\n    };", "modifier": "private final", "type": "Predicate<VideoMoment>", "declarator": "nonNullTimecodePredicate = new Predicate<VideoMoment>() {\n        public boolean apply(VideoMoment arg0) {\n            return arg0.getTimecode() != null;\n        }\n    }", "var_name": "nonNullTimecodePredicate"}, {"original_string": "private final Predicate<VideoMoment> nonNullAlternateTimecodePredicate = new Predicate<VideoMoment>() {\n        public boolean apply(VideoMoment arg0) {\n            return arg0.getAlternateTimecode() != null;\n        }\n    };", "modifier": "private final", "type": "Predicate<VideoMoment>", "declarator": "nonNullAlternateTimecodePredicate = new Predicate<VideoMoment>() {\n        public boolean apply(VideoMoment arg0) {\n            return arg0.getAlternateTimecode() != null;\n        }\n    }", "var_name": "nonNullAlternateTimecodePredicate"}, {"original_string": "private final ThreadLocal<Connection> connections = new ThreadLocal<Connection>();", "modifier": "private final", "type": "ThreadLocal<Connection>", "declarator": "connections = new ThreadLocal<Connection>()", "var_name": "connections"}, {"original_string": "private static final ResourceBundle bundle = ResourceBundle.getBundle(\"annotation-jdbc\", Locale.US);", "modifier": "private static final", "type": "ResourceBundle", "declarator": "bundle = ResourceBundle.getBundle(\"annotation-jdbc\", Locale.US)", "var_name": "bundle"}], "methods": [{"identifier": "EXPDPersistenceService", "parameters": "()", "modifiers": "public", "return": "", "signature": " EXPDPersistenceService()", "full_signature": "public  EXPDPersistenceService()", "class_method_signature": "EXPDPersistenceService.EXPDPersistenceService()", "testcase": false, "constructor": true}, {"identifier": "findTimecodeNearDate", "parameters": "(String platform, Date date, int millisecTolerance)", "modifiers": "public", "return": "VideoMoment", "signature": "VideoMoment findTimecodeNearDate(String platform, Date date, int millisecTolerance)", "full_signature": "public VideoMoment findTimecodeNearDate(String platform, Date date, int millisecTolerance)", "class_method_signature": "EXPDPersistenceService.findTimecodeNearDate(String platform, Date date, int millisecTolerance)", "testcase": false, "constructor": false}, {"identifier": "findTimecodesNearDate", "parameters": "(String platform, Date date, int millisecTolerance)", "modifiers": "public", "return": "List<VideoMoment>", "signature": "List<VideoMoment> findTimecodesNearDate(String platform, Date date, int millisecTolerance)", "full_signature": "public List<VideoMoment> findTimecodesNearDate(String platform, Date date, int millisecTolerance)", "class_method_signature": "EXPDPersistenceService.findTimecodesNearDate(String platform, Date date, int millisecTolerance)", "testcase": false, "constructor": false}, {"identifier": "interpolateTimecodeByDate", "parameters": "(String cameraIdentifier, Date date, int millisecTolerance,\n            double frameRate)", "modifiers": "public", "return": "VideoMoment", "signature": "VideoMoment interpolateTimecodeByDate(String cameraIdentifier, Date date, int millisecTolerance,\n            double frameRate)", "full_signature": "public VideoMoment interpolateTimecodeByDate(String cameraIdentifier, Date date, int millisecTolerance,\n            double frameRate)", "class_method_signature": "EXPDPersistenceService.interpolateTimecodeByDate(String cameraIdentifier, Date date, int millisecTolerance,\n            double frameRate)", "testcase": false, "constructor": false}], "file": "vars-jpa/src/main/java/vars/EXPDPersistenceService.java"}, "focal_method": {"identifier": "findTimecodeNearDate", "parameters": "(String platform, Date date, int millisecTolerance)", "modifiers": "public", "return": "VideoMoment", "body": "public VideoMoment findTimecodeNearDate(String platform, Date date, int millisecTolerance) {\n\n        List<VideoMoment> tapeTimes = findTimecodesNearDate(platform, date, millisecTolerance);\n\n        /*\n         * Find the nearest time to our date\n         */\n        VideoMoment nearestDateTimecode = null;\n        long dtMin = Long.MAX_VALUE;\n        for (VideoMoment tapeTime : tapeTimes) {\n            Date d = tapeTime.getRecordedDate();\n            long dt = Math.abs(d.getTime() - date.getTime());\n            if (dt < dtMin) {\n                dtMin = dt;\n                nearestDateTimecode = tapeTime;\n            }\n        }\n\n        return nearestDateTimecode;\n    }", "signature": "VideoMoment findTimecodeNearDate(String platform, Date date, int millisecTolerance)", "full_signature": "public VideoMoment findTimecodeNearDate(String platform, Date date, int millisecTolerance)", "class_method_signature": "EXPDPersistenceService.findTimecodeNearDate(String platform, Date date, int millisecTolerance)", "testcase": false, "constructor": false, "invocations": ["findTimecodesNearDate", "getRecordedDate", "abs", "getTime", "getTime"]}, "repository": {"repo_id": 13933675, "url": "https://github.com/hohonuuli/vars", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 9, "size": 18273, "license": "licensed"}}