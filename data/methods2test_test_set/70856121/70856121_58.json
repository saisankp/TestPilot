{"test_class": {"identifier": "SegmentGeneratorTest", "superclass": "", "interfaces": "", "fields": [], "file": "src/server/src/test/java/io/cassandrareaper/service/SegmentGeneratorTest.java"}, "test_case": {"identifier": "testDisorderedRing", "parameters": "()", "modifiers": "@Test(expected = ReaperException.class) public", "return": "void", "body": "@Test(expected = ReaperException.class)\n  public void testDisorderedRing() throws Exception {\n\n    List<String> tokenStrings = Lists.newArrayList(\n        \"0\",\n        \"113427455640312821154458202477256070485\",\n        \"1\",\n        \"56713727820156410577229101238628035242\",\n        \"56713727820156410577229101238628035243\",\n        \"113427455640312821154458202477256070484\");\n\n    List<BigInteger> tokens = Lists.transform(tokenStrings, (String string) -> new BigInteger(string));\n\n    SegmentGenerator generator = new SegmentGenerator(\"foo.bar.RandomPartitioner\");\n    generator.generateSegments(10, tokens, Boolean.FALSE, Maps.newHashMap(), \"2.2.10\");\n    // Will throw an exception when concluding that the repair segments don't add up.\n    // This is because the tokens were supplied out of order.\n  }", "signature": "void testDisorderedRing()", "full_signature": "@Test(expected = ReaperException.class) public void testDisorderedRing()", "class_method_signature": "SegmentGeneratorTest.testDisorderedRing()", "testcase": true, "constructor": false, "invocations": ["newArrayList", "transform", "generateSegments", "newHashMap"]}, "focal_class": {"identifier": "SegmentGenerator", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(SegmentGenerator.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(SegmentGenerator.class)", "var_name": "LOG"}, {"original_string": "private static final boolean COALESCING_DISABLED\n      = Boolean.getBoolean(SegmentGenerator.class.getName() + \".disable.tokenrange.coalescing\");", "modifier": "private static final", "type": "boolean", "declarator": "COALESCING_DISABLED\n      = Boolean.getBoolean(SegmentGenerator.class.getName() + \".disable.tokenrange.coalescing\")", "var_name": "COALESCING_DISABLED"}, {"original_string": "private final String partitioner;", "modifier": "private final", "type": "String", "declarator": "partitioner", "var_name": "partitioner"}, {"original_string": "private final BigInteger rangeMin;", "modifier": "private final", "type": "BigInteger", "declarator": "rangeMin", "var_name": "rangeMin"}, {"original_string": "private final BigInteger rangeMax;", "modifier": "private final", "type": "BigInteger", "declarator": "rangeMax", "var_name": "rangeMax"}, {"original_string": "private final BigInteger rangeSize;", "modifier": "private final", "type": "BigInteger", "declarator": "rangeSize", "var_name": "rangeSize"}], "methods": [{"identifier": "SegmentGenerator", "parameters": "(String partitioner)", "modifiers": "", "return": "", "signature": " SegmentGenerator(String partitioner)", "full_signature": "  SegmentGenerator(String partitioner)", "class_method_signature": "SegmentGenerator.SegmentGenerator(String partitioner)", "testcase": false, "constructor": true}, {"identifier": "SegmentGenerator", "parameters": "(BigInteger rangeMin, BigInteger rangeMax)", "modifiers": "", "return": "", "signature": " SegmentGenerator(BigInteger rangeMin, BigInteger rangeMax)", "full_signature": "  SegmentGenerator(BigInteger rangeMin, BigInteger rangeMax)", "class_method_signature": "SegmentGenerator.SegmentGenerator(BigInteger rangeMin, BigInteger rangeMax)", "testcase": false, "constructor": true}, {"identifier": "max", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "BigInteger", "signature": "BigInteger max(BigInteger big0, BigInteger big1)", "full_signature": "static BigInteger max(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.max(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "min", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "BigInteger", "signature": "BigInteger min(BigInteger big0, BigInteger big1)", "full_signature": "static BigInteger min(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.min(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "lowerThan", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "boolean", "signature": "boolean lowerThan(BigInteger big0, BigInteger big1)", "full_signature": "static boolean lowerThan(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.lowerThan(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "lowerThanOrEqual", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "boolean", "signature": "boolean lowerThanOrEqual(BigInteger big0, BigInteger big1)", "full_signature": "static boolean lowerThanOrEqual(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.lowerThanOrEqual(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "greaterThan", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "boolean", "signature": "boolean greaterThan(BigInteger big0, BigInteger big1)", "full_signature": "static boolean greaterThan(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.greaterThan(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "greaterThanOrEqual", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "boolean", "signature": "boolean greaterThanOrEqual(BigInteger big0, BigInteger big1)", "full_signature": "static boolean greaterThanOrEqual(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.greaterThanOrEqual(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "generateSegments", "parameters": "(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "modifiers": "", "return": "List<Segment>", "signature": "List<Segment> generateSegments(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "full_signature": " List<Segment> generateSegments(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "class_method_signature": "SegmentGenerator.generateSegments(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "testcase": false, "constructor": false}, {"identifier": "coalesceTokenRanges", "parameters": "(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "modifiers": "@VisibleForTesting", "return": "List<Segment>", "signature": "List<Segment> coalesceTokenRanges(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "full_signature": "@VisibleForTesting List<Segment> coalesceTokenRanges(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "class_method_signature": "SegmentGenerator.coalesceTokenRanges(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "testcase": false, "constructor": false}, {"identifier": "allTokensHaveBeenCoalesced", "parameters": "(\n      List<Segment> coalescedRepairSegments, Map<List<String>, List<RingRange>> replicasToRange)", "modifiers": "private static", "return": "boolean", "signature": "boolean allTokensHaveBeenCoalesced(\n      List<Segment> coalescedRepairSegments, Map<List<String>, List<RingRange>> replicasToRange)", "full_signature": "private static boolean allTokensHaveBeenCoalesced(\n      List<Segment> coalescedRepairSegments, Map<List<String>, List<RingRange>> replicasToRange)", "class_method_signature": "SegmentGenerator.allTokensHaveBeenCoalesced(\n      List<Segment> coalescedRepairSegments, Map<List<String>, List<RingRange>> replicasToRange)", "testcase": false, "constructor": false}, {"identifier": "getTargetSegmentSize", "parameters": "(int segmentCount)", "modifiers": "private", "return": "BigInteger", "signature": "BigInteger getTargetSegmentSize(int segmentCount)", "full_signature": "private BigInteger getTargetSegmentSize(int segmentCount)", "class_method_signature": "SegmentGenerator.getTargetSegmentSize(int segmentCount)", "testcase": false, "constructor": false}, {"identifier": "inRange", "parameters": "(BigInteger token)", "modifiers": "protected", "return": "boolean", "signature": "boolean inRange(BigInteger token)", "full_signature": "protected boolean inRange(BigInteger token)", "class_method_signature": "SegmentGenerator.inRange(BigInteger token)", "testcase": false, "constructor": false}, {"identifier": "supportsSegmentCoalescing", "parameters": "(String cassandraVersion)", "modifiers": "private", "return": "boolean", "signature": "boolean supportsSegmentCoalescing(String cassandraVersion)", "full_signature": "private boolean supportsSegmentCoalescing(String cassandraVersion)", "class_method_signature": "SegmentGenerator.supportsSegmentCoalescing(String cassandraVersion)", "testcase": false, "constructor": false}], "file": "src/server/src/main/java/io/cassandrareaper/service/SegmentGenerator.java"}, "focal_method": {"identifier": "generateSegments", "parameters": "(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "modifiers": "", "return": "List<Segment>", "body": "List<Segment> generateSegments(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)\n      throws ReaperException {\n\n    List<Segment> repairSegments = Lists.newArrayList();\n    int tokenRangeCount = ringTokens.size();\n\n    if (tokenRangeCount < totalSegmentCount || !supportsSegmentCoalescing(cassandraVersion)) {\n      // We want more segments than there are token ranges.\n      // Token ranges will be subdivided to match the requirements.\n      for (int i = 0; i < tokenRangeCount; i++) {\n        BigInteger start = ringTokens.get(i);\n        BigInteger stop = ringTokens.get((i + 1) % tokenRangeCount);\n\n        if (!inRange(start) || !inRange(stop)) {\n          throw new ReaperException(\n              String.format(\"Tokens (%s,%s) not in range of %s\", start, stop, partitioner));\n        }\n        if (start.equals(stop) && tokenRangeCount != 1) {\n          throw new ReaperException(\n              String.format(\"Tokens (%s,%s): two nodes have the same token\", start, stop));\n        }\n\n        BigInteger rs = stop.subtract(start);\n        if (lowerThanOrEqual(rs, BigInteger.ZERO)) {\n          // wrap around case\n          rs = rs.add(rangeSize);\n        }\n\n        // the below, in essence, does this:\n        // segmentCount = ceiling((rangeSize / RANGE_SIZE) * totalSegmentCount)\n        BigInteger[] segmentCountAndRemainder\n            = rs.multiply(BigInteger.valueOf(totalSegmentCount)).divideAndRemainder(rangeSize);\n\n        int segmentCount = segmentCountAndRemainder[0].intValue()\n                + (segmentCountAndRemainder[1].equals(BigInteger.ZERO) ? 0 : 1);\n\n        LOG.info(\"Dividing token range [{},{}) into {} segments\", start, stop, segmentCount);\n\n        // Make big0 list of all the endpoints for the repair segments, including both start and stop\n        List<BigInteger> endpointTokens = Lists.newArrayList();\n        for (int j = 0; j <= segmentCount; j++) {\n          BigInteger offset = rs.multiply(BigInteger.valueOf(j)).divide(BigInteger.valueOf(segmentCount));\n          BigInteger reaperToken = start.add(offset);\n          if (greaterThan(reaperToken, rangeMax)) {\n            reaperToken = reaperToken.subtract(rangeSize);\n          }\n          endpointTokens.add(reaperToken);\n        }\n\n        // Append the segments between the endpoints\n        for (int j = 0; j < segmentCount; j++) {\n          repairSegments.add(\n              Segment.builder()\n                  .withTokenRanges(\n                      Arrays.asList(\n                          new RingRange(endpointTokens.get(j), endpointTokens.get(j + 1))))\n                  .build());\n          LOG.debug(\n              \"Segment #{}: [{},{})\", j + 1, endpointTokens.get(j), endpointTokens.get(j + 1));\n        }\n      }\n\n      // verify that the whole range is repaired\n      BigInteger total = BigInteger.ZERO;\n      for (Segment segment : repairSegments) {\n        for (RingRange range : segment.getTokenRanges()) {\n          BigInteger size = range.span(rangeSize);\n          total = total.add(size);\n        }\n      }\n      if (!total.equals(rangeSize) && !incrementalRepair) {\n        throw new ReaperException(\"Not entire ring would get repaired\");\n      }\n    } else {\n      // We want less segments than there are token ranges.\n      // Token ranges will be grouped to match the requirements.\n      LOG.info(\"Less segments required than there are vnode. Coalescing eligible token ranges...\");\n      repairSegments = coalesceTokenRanges(getTargetSegmentSize(totalSegmentCount), replicasToRange);\n    }\n\n    return repairSegments;\n  }", "signature": "List<Segment> generateSegments(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "full_signature": " List<Segment> generateSegments(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "class_method_signature": "SegmentGenerator.generateSegments(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "testcase": false, "constructor": false, "invocations": ["newArrayList", "size", "supportsSegmentCoalescing", "get", "get", "inRange", "inRange", "format", "equals", "format", "subtract", "lowerThanOrEqual", "add", "divideAndRemainder", "multiply", "valueOf", "intValue", "equals", "info", "newArrayList", "divide", "multiply", "valueOf", "valueOf", "add", "greaterThan", "subtract", "add", "add", "build", "withTokenRanges", "builder", "asList", "get", "get", "debug", "get", "get", "getTokenRanges", "span", "add", "equals", "info", "coalesceTokenRanges", "getTargetSegmentSize"]}, "repository": {"repo_id": 70856121, "url": "https://github.com/thelastpickle/cassandra-reaper", "language": "Java", "is_fork": false, "fork_count": 156, "stargazer_count": 353, "size": 43662, "license": "licensed"}}