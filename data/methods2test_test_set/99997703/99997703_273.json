{"test_class": {"identifier": "NotificationBusTest", "superclass": "", "interfaces": "", "fields": [], "file": "OcavaCore/src/test/java/com/ocadotechnology/notification/NotificationBusTest.java"}, "test_case": {"identifier": "testWhenTwoThreadsBroadcast_thenTheFirstAlwaysSucceedsAndTheSecondAlwaysFails", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testWhenTwoThreadsBroadcast_thenTheFirstAlwaysSucceedsAndTheSecondAlwaysFails() throws InterruptedException {\n        WithinAppNotificationRouter router = WithinAppNotificationRouter.get();\n        NotificationBus<Notification> bus = new TestBus();\n        router.registerExecutionLayer(new NonExecutingEventScheduler(TestSchedulerType.TEST_SCHEDULER_TYPE, TimeProvider.NULL), bus);\n\n        OuterNotificationHandler outerHandler = new OuterNotificationHandler();\n        router.addHandler(outerHandler);\n\n        TwoThreadTestBroadcaster firstBroadcaster = new TwoThreadTestBroadcaster(router);\n        new Thread(firstBroadcaster::runExpectingSuccess).start();\n\n        firstBroadcaster.waitForCount(10);  // Ensure that thread 1 calls broadcast at least once *before* starting thread 2\n\n        TwoThreadTestBroadcaster secondBroadcaster = new TwoThreadTestBroadcaster(router);\n        new Thread(secondBroadcaster::runExpectingFailure).start();;\n\n        secondBroadcaster.waitForCount(100);  // Ensure thread 2 has called broadcast at least once\n        firstBroadcaster.waitForCount(firstBroadcaster.broadcastCount + 100);  // Make sure we're still running thread 1\n\n        firstBroadcaster.waitToStop();\n        secondBroadcaster.waitToStop();\n        Assertions.assertFalse(firstBroadcaster.failed, \"Should never throw as first caller\");\n        Assertions.assertFalse(secondBroadcaster.failed, \"Should never succeed as second caller\");\n    }", "signature": "void testWhenTwoThreadsBroadcast_thenTheFirstAlwaysSucceedsAndTheSecondAlwaysFails()", "full_signature": "@Test public void testWhenTwoThreadsBroadcast_thenTheFirstAlwaysSucceedsAndTheSecondAlwaysFails()", "class_method_signature": "NotificationBusTest.testWhenTwoThreadsBroadcast_thenTheFirstAlwaysSucceedsAndTheSecondAlwaysFails()", "testcase": true, "constructor": false, "invocations": ["get", "registerExecutionLayer", "addHandler", "start", "waitForCount", "start", "waitForCount", "waitForCount", "waitToStop", "waitToStop", "assertFalse", "assertFalse"]}, "focal_class": {"identifier": "NotificationBus", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String NOTIFICATION_BUS_ID = \"NOTIFICATION_BUS\";", "modifier": "public static final", "type": "String", "declarator": "NOTIFICATION_BUS_ID = \"NOTIFICATION_BUS\"", "var_name": "NOTIFICATION_BUS_ID"}, {"original_string": "private final Logger logger = LoggerFactory.getLogger(NOTIFICATION_BUS_ID);", "modifier": "private final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(NOTIFICATION_BUS_ID)", "var_name": "logger"}, {"original_string": "private final Class<N> notificationClass;", "modifier": "private final", "type": "Class<N>", "declarator": "notificationClass", "var_name": "notificationClass"}, {"original_string": "private final AtomicReference<Thread> thread = new AtomicReference<>(null);", "modifier": "private final", "type": "AtomicReference<Thread>", "declarator": "thread = new AtomicReference<>(null)", "var_name": "thread"}, {"original_string": "private final ReadWriteLock rwLock = new ReentrantReadWriteLock();", "modifier": "private final", "type": "ReadWriteLock", "declarator": "rwLock = new ReentrantReadWriteLock()", "var_name": "rwLock"}, {"original_string": "@GuardedBy(\"rwLock\")\n    private BlockingEventBus eventBus;", "modifier": "@GuardedBy(\"rwLock\")\n    private", "type": "BlockingEventBus", "declarator": "eventBus", "var_name": "eventBus"}, {"original_string": "@GuardedBy(\"rwLock\")\n    private final Map<Class<?>, Class<?>> registeredNotifications = new HashMap<>();", "modifier": "@GuardedBy(\"rwLock\")\n    private final", "type": "Map<Class<?>, Class<?>>", "declarator": "registeredNotifications = new HashMap<>()", "var_name": "registeredNotifications"}, {"original_string": "@GuardedBy(\"rwLock\")\n    private final Map<Class<?>, Boolean> cacheOfImpliedNotifications = new HashMap<>();", "modifier": "@GuardedBy(\"rwLock\")\n    private final", "type": "Map<Class<?>, Boolean>", "declarator": "cacheOfImpliedNotifications = new HashMap<>()", "var_name": "cacheOfImpliedNotifications"}, {"original_string": "private final PointToPointValidator pointToPointValidator = new PointToPointValidator();", "modifier": "private final", "type": "PointToPointValidator", "declarator": "pointToPointValidator = new PointToPointValidator()", "var_name": "pointToPointValidator"}], "methods": [{"identifier": "NotificationBus", "parameters": "(Class<N> notificationClass)", "modifiers": "protected", "return": "", "signature": " NotificationBus(Class<N> notificationClass)", "full_signature": "protected  NotificationBus(Class<N> notificationClass)", "class_method_signature": "NotificationBus.NotificationBus(Class<N> notificationClass)", "testcase": false, "constructor": true}, {"identifier": "addHandler", "parameters": "(Object handler)", "modifiers": "protected", "return": "void", "signature": "void addHandler(Object handler)", "full_signature": "protected void addHandler(Object handler)", "class_method_signature": "NotificationBus.addHandler(Object handler)", "testcase": false, "constructor": false}, {"identifier": "collectSubscribingTypes", "parameters": "(Object handler)", "modifiers": "private", "return": "List<Class<?>>", "signature": "List<Class<?>> collectSubscribingTypes(Object handler)", "full_signature": "private List<Class<?>> collectSubscribingTypes(Object handler)", "class_method_signature": "NotificationBus.collectSubscribingTypes(Object handler)", "testcase": false, "constructor": false}, {"identifier": "clearAllHandlers", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void clearAllHandlers()", "full_signature": "public void clearAllHandlers()", "class_method_signature": "NotificationBus.clearAllHandlers()", "testcase": false, "constructor": false}, {"identifier": "broadcast", "parameters": "(N notification)", "modifiers": "public", "return": "void", "signature": "void broadcast(N notification)", "full_signature": "public void broadcast(N notification)", "class_method_signature": "NotificationBus.broadcast(N notification)", "testcase": false, "constructor": false}, {"identifier": "clearThread", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void clearThread()", "full_signature": "public void clearThread()", "class_method_signature": "NotificationBus.clearThread()", "testcase": false, "constructor": false}, {"identifier": "replaceAllNotifications", "parameters": "(Collection<Class<?>> newNotifications)", "modifiers": "protected", "return": "void", "signature": "void replaceAllNotifications(Collection<Class<?>> newNotifications)", "full_signature": "protected void replaceAllNotifications(Collection<Class<?>> newNotifications)", "class_method_signature": "NotificationBus.replaceAllNotifications(Collection<Class<?>> newNotifications)", "testcase": false, "constructor": false}, {"identifier": "checkThatThisBusHasOnlyBeenUsedByOneThread", "parameters": "(N notification)", "modifiers": "protected", "return": "void", "signature": "void checkThatThisBusHasOnlyBeenUsedByOneThread(N notification)", "full_signature": "protected void checkThatThisBusHasOnlyBeenUsedByOneThread(N notification)", "class_method_signature": "NotificationBus.checkThatThisBusHasOnlyBeenUsedByOneThread(N notification)", "testcase": false, "constructor": false}, {"identifier": "isNotificationRegistered", "parameters": "(Class<?> notification)", "modifiers": "protected", "return": "boolean", "signature": "boolean isNotificationRegistered(Class<?> notification)", "full_signature": "protected boolean isNotificationRegistered(Class<?> notification)", "class_method_signature": "NotificationBus.isNotificationRegistered(Class<?> notification)", "testcase": false, "constructor": false}, {"identifier": "isParentOfNotificationRegistered", "parameters": "(Class<T> notification)", "modifiers": "private", "return": "boolean", "signature": "boolean isParentOfNotificationRegistered(Class<T> notification)", "full_signature": "private boolean isParentOfNotificationRegistered(Class<T> notification)", "class_method_signature": "NotificationBus.isParentOfNotificationRegistered(Class<T> notification)", "testcase": false, "constructor": false}, {"identifier": "clearCache", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void clearCache()", "full_signature": "private void clearCache()", "class_method_signature": "NotificationBus.clearCache()", "testcase": false, "constructor": false}, {"identifier": "canHandleNotification", "parameters": "(Class<?> notification)", "modifiers": "protected", "return": "boolean", "signature": "boolean canHandleNotification(Class<?> notification)", "full_signature": "protected boolean canHandleNotification(Class<?> notification)", "class_method_signature": "NotificationBus.canHandleNotification(Class<?> notification)", "testcase": false, "constructor": false}, {"identifier": "hasCorrectType", "parameters": "(Class<?> notification)", "modifiers": "protected abstract", "return": "boolean", "signature": "boolean hasCorrectType(Class<?> notification)", "full_signature": "protected abstract boolean hasCorrectType(Class<?> notification)", "class_method_signature": "NotificationBus.hasCorrectType(Class<?> notification)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "NotificationBus.toString()", "testcase": false, "constructor": false}], "file": "OcavaCore/src/main/java/com/ocadotechnology/notification/NotificationBus.java"}, "focal_method": {"identifier": "addHandler", "parameters": "(Object handler)", "modifiers": "protected", "return": "void", "body": "protected void addHandler(Object handler) {\n        List<Class<?>> newNotifications = collectSubscribingTypes(handler);\n        pointToPointValidator.validate(handler, newNotifications);\n        Lock lock = rwLock.writeLock();\n        try {\n            lock.lock();\n            newNotifications.forEach(type -> registeredNotifications.put(type, type));\n            clearCache();\n\n            // Not sure that eventBus is thread-safe, so we'll include it in our lock\n            eventBus.register(handler);\n        } finally {\n            lock.unlock();\n        }\n    }", "signature": "void addHandler(Object handler)", "full_signature": "protected void addHandler(Object handler)", "class_method_signature": "NotificationBus.addHandler(Object handler)", "testcase": false, "constructor": false, "invocations": ["collectSubscribingTypes", "validate", "writeLock", "lock", "forEach", "put", "clearCache", "register", "unlock"]}, "repository": {"repo_id": 99997703, "url": "https://github.com/ocadotechnology/Ocava", "language": "Java", "is_fork": false, "fork_count": 4, "stargazer_count": 16, "size": 1137, "license": "licensed"}}