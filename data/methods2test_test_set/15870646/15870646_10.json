{"test_class": {"identifier": "OsmNodeNamedTest", "superclass": "", "interfaces": "", "fields": [], "file": "brouter-core/src/test/java/btools/router/OsmNodeNamedTest.java"}, "test_case": {"identifier": "testDistanceWithinRadius", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testDistanceWithinRadius() {\n    // Segment ends\n    int lon1, lat1, lon2, lat2;\n    // Circle definition\n    OsmNodeNamed node = new OsmNodeNamed();\n    // Center\n    node.ilon = toOsmLon(2.334243);\n    node.ilat = toOsmLat(48.824017);\n    // Radius\n    node.radius = 30;\n\n    // Check distance within radius is correctly computed if the segment passes through the center\n    lon1 = toOsmLon(2.332559);\n    lat1 = toOsmLat(48.823822);\n    lon2 = toOsmLon(2.335018);\n    lat2 = toOsmLat(48.824105);\n    double totalSegmentLength = CheapRuler.distance(lon1, lat1, lon2, lat2);\n    assertEquals(\n      \"Works for segment aligned with the nogo center\",\n      2 * node.radius,\n      node.distanceWithinRadius(lon1, lat1, lon2, lat2, totalSegmentLength),\n      0.01 * (2 * node.radius)\n    );\n\n    // Check distance within radius is correctly computed for a given circle\n    node.ilon = toOsmLon(2.33438);\n    node.ilat = toOsmLat(48.824275);\n    assertEquals(\n      \"Works for a segment with no particular properties\",\n      27.5,\n      node.distanceWithinRadius(lon1, lat1, lon2, lat2, totalSegmentLength),\n      0.1 * 27.5\n    );\n\n    // Check distance within radius is the same if we reverse start and end point\n    assertEquals(\n      \"Works if we switch firs and last point\",\n      node.distanceWithinRadius(lon2, lat2, lon1, lat1, totalSegmentLength),\n      node.distanceWithinRadius(lon1, lat1, lon2, lat2, totalSegmentLength),\n      0.01\n    );\n\n    // Check distance within radius is correctly computed if a point is inside the circle\n    lon2 = toOsmLon(2.334495);\n    lat2 = toOsmLat(48.824045);\n    totalSegmentLength = CheapRuler.distance(lon1, lat1, lon2, lat2);\n    assertEquals(\n      \"Works if last point is within the circle\",\n      17,\n      node.distanceWithinRadius(lon1, lat1, lon2, lat2, totalSegmentLength),\n      0.1 * 17\n    );\n\n    lon1 = toOsmLon(2.334495);\n    lat1 = toOsmLat(48.824045);\n    lon2 = toOsmLon(2.335018);\n    lat2 = toOsmLat(48.824105);\n    totalSegmentLength = CheapRuler.distance(lon1, lat1, lon2, lat2);\n    assertEquals(\n      \"Works if first point is within the circle\",\n      9,\n      node.distanceWithinRadius(lon1, lat1, lon2, lat2, totalSegmentLength),\n      0.1 * 9\n    );\n\n    lon1 = toOsmLon(2.33427);\n    lat1 = toOsmLat(48.82402);\n    lon2 = toOsmLon(2.334587);\n    lat2 = toOsmLat(48.824061);\n    totalSegmentLength = CheapRuler.distance(lon1, lat1, lon2, lat2);\n    assertEquals(\n      \"Works if both points are within the circle\",\n      25,\n      node.distanceWithinRadius(lon1, lat1, lon2, lat2, totalSegmentLength),\n      0.1 * 25\n    );\n\n    // Check distance within radius is correctly computed if both points are on\n    // the same side of the center.\n    // Note: the only such case possible is with one point outside and one\n    // point within the circle, as we expect the segment to have a non-empty\n    // intersection with the circle.\n    lon1 = toOsmLon(2.332559);\n    lat1 = toOsmLat(48.823822);\n    lon2 = toOsmLon(2.33431);\n    lat2 = toOsmLat(48.824027);\n    totalSegmentLength = CheapRuler.distance(lon1, lat1, lon2, lat2);\n    assertEquals(\n      \"Works if both points are on the same side of the circle center\",\n      5,\n      node.distanceWithinRadius(lon1, lat1, lon2, lat2, totalSegmentLength),\n      0.1 * 5\n    );\n  }", "signature": "void testDistanceWithinRadius()", "full_signature": "@Test public void testDistanceWithinRadius()", "class_method_signature": "OsmNodeNamedTest.testDistanceWithinRadius()", "testcase": true, "constructor": false, "invocations": ["toOsmLon", "toOsmLat", "toOsmLon", "toOsmLat", "toOsmLon", "toOsmLat", "distance", "assertEquals", "distanceWithinRadius", "toOsmLon", "toOsmLat", "assertEquals", "distanceWithinRadius", "assertEquals", "distanceWithinRadius", "distanceWithinRadius", "toOsmLon", "toOsmLat", "distance", "assertEquals", "distanceWithinRadius", "toOsmLon", "toOsmLat", "toOsmLon", "toOsmLat", "distance", "assertEquals", "distanceWithinRadius", "toOsmLon", "toOsmLat", "toOsmLon", "toOsmLat", "distance", "assertEquals", "distanceWithinRadius", "toOsmLon", "toOsmLat", "toOsmLon", "toOsmLat", "distance", "assertEquals", "distanceWithinRadius"]}, "focal_class": {"identifier": "OsmNodeNamed", "superclass": "extends OsmNode", "interfaces": "", "fields": [{"original_string": "public String name;", "modifier": "public", "type": "String", "declarator": "name", "var_name": "name"}, {"original_string": "public double radius;", "modifier": "public", "type": "double", "declarator": "radius", "var_name": "radius"}, {"original_string": "public double nogoWeight;", "modifier": "public", "type": "double", "declarator": "nogoWeight", "var_name": "nogoWeight"}, {"original_string": "public boolean isNogo = false;", "modifier": "public", "type": "boolean", "declarator": "isNogo = false", "var_name": "isNogo"}], "methods": [{"identifier": "OsmNodeNamed", "parameters": "()", "modifiers": "public", "return": "", "signature": " OsmNodeNamed()", "full_signature": "public  OsmNodeNamed()", "class_method_signature": "OsmNodeNamed.OsmNodeNamed()", "testcase": false, "constructor": true}, {"identifier": "OsmNodeNamed", "parameters": "( OsmNode n)", "modifiers": "public", "return": "", "signature": " OsmNodeNamed( OsmNode n)", "full_signature": "public  OsmNodeNamed( OsmNode n)", "class_method_signature": "OsmNodeNamed.OsmNodeNamed( OsmNode n)", "testcase": false, "constructor": true}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "OsmNodeNamed.toString()", "testcase": false, "constructor": false}, {"identifier": "distanceWithinRadius", "parameters": "(int lon1, int lat1, int lon2, int lat2, double totalSegmentLength)", "modifiers": "public", "return": "double", "signature": "double distanceWithinRadius(int lon1, int lat1, int lon2, int lat2, double totalSegmentLength)", "full_signature": "public double distanceWithinRadius(int lon1, int lat1, int lon2, int lat2, double totalSegmentLength)", "class_method_signature": "OsmNodeNamed.distanceWithinRadius(int lon1, int lat1, int lon2, int lat2, double totalSegmentLength)", "testcase": false, "constructor": false}, {"identifier": "decodeNogo", "parameters": "( String s )", "modifiers": "public static", "return": "OsmNodeNamed", "signature": "OsmNodeNamed decodeNogo( String s )", "full_signature": "public static OsmNodeNamed decodeNogo( String s )", "class_method_signature": "OsmNodeNamed.decodeNogo( String s )", "testcase": false, "constructor": false}], "file": "brouter-core/src/main/java/btools/router/OsmNodeNamed.java"}, "focal_method": {"identifier": "distanceWithinRadius", "parameters": "(int lon1, int lat1, int lon2, int lat2, double totalSegmentLength)", "modifiers": "public", "return": "double", "body": "public double distanceWithinRadius(int lon1, int lat1, int lon2, int lat2, double totalSegmentLength) {\n    double[] lonlat2m = CheapRuler.getLonLatToMeterScales( (lat1 + lat2) >> 1 );\n\n    boolean isFirstPointWithinCircle = CheapRuler.distance(lon1, lat1, ilon, ilat) < radius;\n    boolean isLastPointWithinCircle = CheapRuler.distance(lon2, lat2, ilon, ilat) < radius;\n    // First point is within the circle\n    if (isFirstPointWithinCircle) {\n      // Last point is within the circle\n      if (isLastPointWithinCircle) {\n        return totalSegmentLength;\n      }\n      // Last point is not within the circle\n      // Just swap points and go on with first first point not within the\n      // circle now.\n      // Swap longitudes\n      int tmp = lon2;\n      lon2 = lon1;\n      lon1 = tmp;\n      // Swap latitudes\n      tmp = lat2;\n      lat2 = lat1;\n      lat1 = tmp;\n      // Fix boolean values\n      isLastPointWithinCircle = isFirstPointWithinCircle;\n      isFirstPointWithinCircle = false;\n    }\n    // Distance between the initial point and projection of center of\n    // the circle on the current segment.\n    double initialToProject = (\n      (lon2 - lon1) * (ilon - lon1) * lonlat2m[0] * lonlat2m[0]\n      + (lat2 - lat1) * (ilat - lat1) * lonlat2m[1] * lonlat2m[1]\n    ) / totalSegmentLength;\n    // Distance between the initial point and the center of the circle.\n    double initialToCenter = CheapRuler.distance(ilon, ilat, lon1, lat1);\n    // Half length of the segment within the circle\n    double halfDistanceWithin = Math.sqrt(\n      radius*radius - (\n        initialToCenter*initialToCenter -\n        initialToProject*initialToProject\n      )\n    );\n    // Last point is within the circle\n    if (isLastPointWithinCircle) {\n      return halfDistanceWithin + (totalSegmentLength - initialToProject);\n    }\n    return 2 * halfDistanceWithin;\n  }", "signature": "double distanceWithinRadius(int lon1, int lat1, int lon2, int lat2, double totalSegmentLength)", "full_signature": "public double distanceWithinRadius(int lon1, int lat1, int lon2, int lat2, double totalSegmentLength)", "class_method_signature": "OsmNodeNamed.distanceWithinRadius(int lon1, int lat1, int lon2, int lat2, double totalSegmentLength)", "testcase": false, "constructor": false, "invocations": ["getLonLatToMeterScales", "distance", "distance", "distance", "sqrt"]}, "repository": {"repo_id": 15870646, "url": "https://github.com/abrensch/brouter", "language": "Java", "is_fork": false, "fork_count": 65, "stargazer_count": 172, "size": 3569, "license": "licensed"}}