{"test_class": {"identifier": "ExcelParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String LAST_CELL_VALUE = \"last\";", "modifier": "private static final", "type": "String", "declarator": "LAST_CELL_VALUE = \"last\"", "var_name": "LAST_CELL_VALUE"}, {"original_string": "private static final String FIRST_CELL_CONTENT = \"first\";", "modifier": "private static final", "type": "String", "declarator": "FIRST_CELL_CONTENT = \"first\"", "var_name": "FIRST_CELL_CONTENT"}], "file": "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/xls/ExcelParserTest.java"}, "test_case": {"identifier": "testCellMerge", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCellMerge() throws Exception {\n        ExcelParser parser = new ExcelParser((Map<String, List<DataListener>>) null);\n\n        CellRangeAddress[] ranges = new CellRangeAddress[1];\n\n        Workbook workbook = new XSSFWorkbook();\n        Sheet sheet = workbook.createSheet();\n        Cell cell = sheet.createRow(2).createCell(2);\n        ranges[0] = new CellRangeAddress(2, 7, 2, 5);\n        cell.setCellValue(FIRST_CELL_CONTENT);\n\n        cell = sheet.createRow(7).createCell(5);\n        cell.setCellValue(LAST_CELL_VALUE);\n\n        cell = sheet.createRow(1).createCell(1);\n        assertNull(parser.getRangeIfMerged(cell, ranges));\n\n        cell = sheet.getRow(2).createCell(5);\n        cell.setCellValue(\"wrong\");\n\n        CellRangeAddress rangeIfMerged = parser.getRangeIfMerged(cell, ranges);\n        assertEquals(FIRST_CELL_CONTENT, sheet.getRow(rangeIfMerged.getFirstRow()).getCell(rangeIfMerged.getFirstColumn()).getStringCellValue());\n    }", "signature": "void testCellMerge()", "full_signature": "@Test public void testCellMerge()", "class_method_signature": "ExcelParserTest.testCellMerge()", "testcase": true, "constructor": false, "invocations": ["createSheet", "createCell", "createRow", "setCellValue", "createCell", "createRow", "setCellValue", "createCell", "createRow", "assertNull", "getRangeIfMerged", "createCell", "getRow", "setCellValue", "getRangeIfMerged", "assertEquals", "getStringCellValue", "getCell", "getRow", "getFirstRow", "getFirstColumn"]}, "focal_class": {"identifier": "ExcelParser", "superclass": "", "interfaces": "implements\n        DecisionTableParser", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger( ExcelParser.class );", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger( ExcelParser.class )", "var_name": "log"}, {"original_string": "public static final String DEFAULT_RULESHEET_NAME = \"Decision Tables\";", "modifier": "public static final", "type": "String", "declarator": "DEFAULT_RULESHEET_NAME = \"Decision Tables\"", "var_name": "DEFAULT_RULESHEET_NAME"}, {"original_string": "private Map<String, List<DataListener>> _listeners = new HashMap<String, List<DataListener>>();", "modifier": "private", "type": "Map<String, List<DataListener>>", "declarator": "_listeners = new HashMap<String, List<DataListener>>()", "var_name": "_listeners"}, {"original_string": "private boolean _useFirstSheet;", "modifier": "private", "type": "boolean", "declarator": "_useFirstSheet", "var_name": "_useFirstSheet"}], "methods": [{"identifier": "ExcelParser", "parameters": "( final Map<String, List<DataListener>> sheetListeners )", "modifiers": "public", "return": "", "signature": " ExcelParser( final Map<String, List<DataListener>> sheetListeners )", "full_signature": "public  ExcelParser( final Map<String, List<DataListener>> sheetListeners )", "class_method_signature": "ExcelParser.ExcelParser( final Map<String, List<DataListener>> sheetListeners )", "testcase": false, "constructor": true}, {"identifier": "ExcelParser", "parameters": "( final List<DataListener> sheetListeners )", "modifiers": "public", "return": "", "signature": " ExcelParser( final List<DataListener> sheetListeners )", "full_signature": "public  ExcelParser( final List<DataListener> sheetListeners )", "class_method_signature": "ExcelParser.ExcelParser( final List<DataListener> sheetListeners )", "testcase": false, "constructor": true}, {"identifier": "ExcelParser", "parameters": "( final DataListener listener )", "modifiers": "public", "return": "", "signature": " ExcelParser( final DataListener listener )", "full_signature": "public  ExcelParser( final DataListener listener )", "class_method_signature": "ExcelParser.ExcelParser( final DataListener listener )", "testcase": false, "constructor": true}, {"identifier": "parseFile", "parameters": "( InputStream inStream )", "modifiers": "public", "return": "void", "signature": "void parseFile( InputStream inStream )", "full_signature": "public void parseFile( InputStream inStream )", "class_method_signature": "ExcelParser.parseFile( InputStream inStream )", "testcase": false, "constructor": false}, {"identifier": "parseFile", "parameters": "( File file )", "modifiers": "public", "return": "void", "signature": "void parseFile( File file )", "full_signature": "public void parseFile( File file )", "class_method_signature": "ExcelParser.parseFile( File file )", "testcase": false, "constructor": false}, {"identifier": "parseWorkbook", "parameters": "( Workbook workbook )", "modifiers": "public", "return": "void", "signature": "void parseWorkbook( Workbook workbook )", "full_signature": "public void parseWorkbook( Workbook workbook )", "class_method_signature": "ExcelParser.parseWorkbook( Workbook workbook )", "testcase": false, "constructor": false}, {"identifier": "getMergedCells", "parameters": "( Sheet sheet )", "modifiers": "private", "return": "CellRangeAddress[]", "signature": "CellRangeAddress[] getMergedCells( Sheet sheet )", "full_signature": "private CellRangeAddress[] getMergedCells( Sheet sheet )", "class_method_signature": "ExcelParser.getMergedCells( Sheet sheet )", "testcase": false, "constructor": false}, {"identifier": "processSheet", "parameters": "( Sheet sheet,\n                               List<? extends DataListener> listeners )", "modifiers": "private", "return": "void", "signature": "void processSheet( Sheet sheet,\n                               List<? extends DataListener> listeners )", "full_signature": "private void processSheet( Sheet sheet,\n                               List<? extends DataListener> listeners )", "class_method_signature": "ExcelParser.processSheet( Sheet sheet,\n                               List<? extends DataListener> listeners )", "testcase": false, "constructor": false}, {"identifier": "getFormulaValue", "parameters": "( DataFormatter formatter, FormulaEvaluator formulaEvaluator, Cell cell )", "modifiers": "private", "return": "String", "signature": "String getFormulaValue( DataFormatter formatter, FormulaEvaluator formulaEvaluator, Cell cell )", "full_signature": "private String getFormulaValue( DataFormatter formatter, FormulaEvaluator formulaEvaluator, Cell cell )", "class_method_signature": "ExcelParser.getFormulaValue( DataFormatter formatter, FormulaEvaluator formulaEvaluator, Cell cell )", "testcase": false, "constructor": false}, {"identifier": "tryToReadCachedValue", "parameters": "( Cell cell )", "modifiers": "private", "return": "String", "signature": "String tryToReadCachedValue( Cell cell )", "full_signature": "private String tryToReadCachedValue( Cell cell )", "class_method_signature": "ExcelParser.tryToReadCachedValue( Cell cell )", "testcase": false, "constructor": false}, {"identifier": "getCellValue", "parameters": "( final CellValue cv )", "modifiers": "private", "return": "String", "signature": "String getCellValue( final CellValue cv )", "full_signature": "private String getCellValue( final CellValue cv )", "class_method_signature": "ExcelParser.getCellValue( final CellValue cv )", "testcase": false, "constructor": false}, {"identifier": "getRangeIfMerged", "parameters": "( Cell cell,\n                                       CellRangeAddress[] mergedRanges )", "modifiers": "", "return": "CellRangeAddress", "signature": "CellRangeAddress getRangeIfMerged( Cell cell,\n                                       CellRangeAddress[] mergedRanges )", "full_signature": " CellRangeAddress getRangeIfMerged( Cell cell,\n                                       CellRangeAddress[] mergedRanges )", "class_method_signature": "ExcelParser.getRangeIfMerged( Cell cell,\n                                       CellRangeAddress[] mergedRanges )", "testcase": false, "constructor": false}, {"identifier": "finishSheet", "parameters": "( List<? extends DataListener> listeners )", "modifiers": "private", "return": "void", "signature": "void finishSheet( List<? extends DataListener> listeners )", "full_signature": "private void finishSheet( List<? extends DataListener> listeners )", "class_method_signature": "ExcelParser.finishSheet( List<? extends DataListener> listeners )", "testcase": false, "constructor": false}, {"identifier": "newRow", "parameters": "( List<? extends DataListener> listeners,\n                         int row,\n                         int cols )", "modifiers": "private", "return": "void", "signature": "void newRow( List<? extends DataListener> listeners,\n                         int row,\n                         int cols )", "full_signature": "private void newRow( List<? extends DataListener> listeners,\n                         int row,\n                         int cols )", "class_method_signature": "ExcelParser.newRow( List<? extends DataListener> listeners,\n                         int row,\n                         int cols )", "testcase": false, "constructor": false}, {"identifier": "newCell", "parameters": "( List<? extends DataListener> listeners,\n                         int row,\n                         int column,\n                         String value,\n                         int mergedColStart )", "modifiers": "public", "return": "void", "signature": "void newCell( List<? extends DataListener> listeners,\n                         int row,\n                         int column,\n                         String value,\n                         int mergedColStart )", "full_signature": "public void newCell( List<? extends DataListener> listeners,\n                         int row,\n                         int column,\n                         String value,\n                         int mergedColStart )", "class_method_signature": "ExcelParser.newCell( List<? extends DataListener> listeners,\n                         int row,\n                         int column,\n                         String value,\n                         int mergedColStart )", "testcase": false, "constructor": false}, {"identifier": "isNumericDisabled", "parameters": "( List<? extends DataListener> listeners )", "modifiers": "private", "return": "boolean", "signature": "boolean isNumericDisabled( List<? extends DataListener> listeners )", "full_signature": "private boolean isNumericDisabled( List<? extends DataListener> listeners )", "class_method_signature": "ExcelParser.isNumericDisabled( List<? extends DataListener> listeners )", "testcase": false, "constructor": false}], "file": "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/xls/ExcelParser.java"}, "focal_method": {"identifier": "getRangeIfMerged", "parameters": "( Cell cell,\n                                       CellRangeAddress[] mergedRanges )", "modifiers": "", "return": "CellRangeAddress", "body": "CellRangeAddress getRangeIfMerged( Cell cell,\n                                       CellRangeAddress[] mergedRanges ) {\n        for ( int i = 0; i < mergedRanges.length; i++ ) {\n            CellRangeAddress r = mergedRanges[ i ];\n            if ( r.isInRange( cell.getRowIndex(), cell.getColumnIndex() ) ) {\n                return r;\n            }\n        }\n        return null;\n    }", "signature": "CellRangeAddress getRangeIfMerged( Cell cell,\n                                       CellRangeAddress[] mergedRanges )", "full_signature": " CellRangeAddress getRangeIfMerged( Cell cell,\n                                       CellRangeAddress[] mergedRanges )", "class_method_signature": "ExcelParser.getRangeIfMerged( Cell cell,\n                                       CellRangeAddress[] mergedRanges )", "testcase": false, "constructor": false, "invocations": ["isInRange", "getRowIndex", "getColumnIndex"]}, "repository": {"repo_id": 1381673, "url": "https://github.com/kiegroup/drools", "stars": 2733, "created": "2/18/2011 8:37:05 AM +00:00", "updates": "2020-01-27T13:12:15+00:00", "fork": "False", "license": "licensed"}}