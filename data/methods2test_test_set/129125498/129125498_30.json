{"test_class": {"identifier": "KafkaDetectorManagerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String METRIC_TOPIC = \"mapped-metrics\";", "modifier": "private static final", "type": "String", "declarator": "METRIC_TOPIC = \"mapped-metrics\"", "var_name": "METRIC_TOPIC"}, {"original_string": "private static final String STRING_DESER = \"org.apache.kafka.common.serialization.StringDeserializer\";", "modifier": "private static final", "type": "String", "declarator": "STRING_DESER = \"org.apache.kafka.common.serialization.StringDeserializer\"", "var_name": "STRING_DESER"}, {"original_string": "private static final String METRIC_DESER = \"com.expedia.adaptivealerting.kafka.serde.MappedMetricDataJsonSerde$Deser\";", "modifier": "private static final", "type": "String", "declarator": "METRIC_DESER = \"com.expedia.adaptivealerting.kafka.serde.MappedMetricDataJsonSerde$Deser\"", "var_name": "METRIC_DESER"}, {"original_string": "private static final String METRIC_SER = \"com.expedia.adaptivealerting.kafka.serde.MappedMetricDataJsonSerde$Ser\";", "modifier": "private static final", "type": "String", "declarator": "METRIC_SER = \"com.expedia.adaptivealerting.kafka.serde.MappedMetricDataJsonSerde$Ser\"", "var_name": "METRIC_SER"}, {"original_string": "private static final String TRACING_ENABLED = \"enabled\";", "modifier": "private static final", "type": "String", "declarator": "TRACING_ENABLED = \"enabled\"", "var_name": "TRACING_ENABLED"}, {"original_string": "private static final String OUTLIER_TOPIC = \"outliers\";", "modifier": "private static final", "type": "String", "declarator": "OUTLIER_TOPIC = \"outliers\"", "var_name": "OUTLIER_TOPIC"}, {"original_string": "private static final String BREAKOUT_TOPIC = \"breakouts\";", "modifier": "private static final", "type": "String", "declarator": "BREAKOUT_TOPIC = \"breakouts\"", "var_name": "BREAKOUT_TOPIC"}, {"original_string": "private static final String STRING_SER = \"org.apache.kafka.common.serialization.StringSerializer\";", "modifier": "private static final", "type": "String", "declarator": "STRING_SER = \"org.apache.kafka.common.serialization.StringSerializer\"", "var_name": "STRING_SER"}, {"original_string": "private static final String ANOMALY_SER = \"com.expedia.adaptivealerting.kafka.serde.MappedMetricDataJsonSerde$Ser\";", "modifier": "private static final", "type": "String", "declarator": "ANOMALY_SER = \"com.expedia.adaptivealerting.kafka.serde.MappedMetricDataJsonSerde$Ser\"", "var_name": "ANOMALY_SER"}, {"original_string": "private static final String ANOMALY_DESER = \"com.expedia.adaptivealerting.kafka.serde.MappedMetricDataJsonSerde$Deser\";", "modifier": "private static final", "type": "String", "declarator": "ANOMALY_DESER = \"com.expedia.adaptivealerting.kafka.serde.MappedMetricDataJsonSerde$Deser\"", "var_name": "ANOMALY_DESER"}, {"original_string": "private static final int NUM_OUTLIER_METRICS = 10;", "modifier": "private static final", "type": "int", "declarator": "NUM_OUTLIER_METRICS = 10", "var_name": "NUM_OUTLIER_METRICS"}, {"original_string": "private static final int NUM_BREAKOUT_METRICS = 5;", "modifier": "private static final", "type": "int", "declarator": "NUM_BREAKOUT_METRICS = 5", "var_name": "NUM_BREAKOUT_METRICS"}, {"original_string": "private static final long THREAD_JOIN_MILLIS = 5000L;", "modifier": "private static final", "type": "long", "declarator": "THREAD_JOIN_MILLIS = 5000L", "var_name": "THREAD_JOIN_MILLIS"}, {"original_string": "@ClassRule\n    public static KafkaJunitRule kafka = new KafkaJunitRule(EphemeralKafkaBroker.create()).waitForStartup();", "modifier": "@ClassRule\n    public static", "type": "KafkaJunitRule", "declarator": "kafka = new KafkaJunitRule(EphemeralKafkaBroker.create()).waitForStartup()", "var_name": "kafka"}, {"original_string": "private KafkaDetectorManager managerUnderTest;", "modifier": "private", "type": "KafkaDetectorManager", "declarator": "managerUnderTest", "var_name": "managerUnderTest"}, {"original_string": "private ObjectMapper objectMapper;", "modifier": "private", "type": "ObjectMapper", "declarator": "objectMapper", "var_name": "objectMapper"}, {"original_string": "@Mock\n    private DetectorManager detectorManager;", "modifier": "@Mock\n    private", "type": "DetectorManager", "declarator": "detectorManager", "var_name": "detectorManager"}, {"original_string": "private MappedMetricData outlierMMD;", "modifier": "private", "type": "MappedMetricData", "declarator": "outlierMMD", "var_name": "outlierMMD"}, {"original_string": "private MappedMetricData breakoutMMD;", "modifier": "private", "type": "MappedMetricData", "declarator": "breakoutMMD", "var_name": "breakoutMMD"}, {"original_string": "private OutlierDetectorResult outlierDetectorResult;", "modifier": "private", "type": "OutlierDetectorResult", "declarator": "outlierDetectorResult", "var_name": "outlierDetectorResult"}, {"original_string": "private BreakoutDetectorResult breakoutDetectorResult;", "modifier": "private", "type": "BreakoutDetectorResult", "declarator": "breakoutDetectorResult", "var_name": "breakoutDetectorResult"}], "file": "kafka/src/test/java/com/expedia/adaptivealerting/kafka/KafkaDetectorManagerTest.java"}, "test_case": {"identifier": "testRun", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRun() throws Exception {\n        val outlierMmdJson = objectMapper.writeValueAsString(outlierMMD);\n        val breakoutMmdJson = objectMapper.writeValueAsString(breakoutMMD);\n\n        for (int i = 0; i < NUM_OUTLIER_METRICS; i++) {\n            log.info(\"Writing mapped metric data: {}\", outlierMmdJson);\n            kafka.helper().produceStrings(METRIC_TOPIC, outlierMmdJson);\n        }\n\n        for (int i = 0; i < NUM_BREAKOUT_METRICS; i++) {\n            log.info(\"Writing mapped metric data: {}\", breakoutMmdJson);\n            kafka.helper().produceStrings(METRIC_TOPIC, breakoutMmdJson);\n        }\n\n        val managerThread = new Thread(managerUnderTest);\n        managerThread.start();\n        managerThread.join(THREAD_JOIN_MILLIS);\n        managerUnderTest.getMetricConsumer().wakeup();\n\n        // FIXME This hangs if there aren't enough messages to consume. Add a timeout?\n        val outliers = kafka.helper().consumeStrings(OUTLIER_TOPIC, NUM_OUTLIER_METRICS).get();\n        assertEquals(NUM_OUTLIER_METRICS, outliers.size());\n\n        val breakouts = kafka.helper().consumeStrings(BREAKOUT_TOPIC, NUM_BREAKOUT_METRICS).get();\n        assertEquals(NUM_BREAKOUT_METRICS, breakouts.size());\n\n        for (val outlier : outliers) {\n            log.info(\"outlierDetectorResult={}\", outlier);\n        }\n    }", "signature": "void testRun()", "full_signature": "@Test public void testRun()", "class_method_signature": "KafkaDetectorManagerTest.testRun()", "testcase": true, "constructor": false, "invocations": ["writeValueAsString", "writeValueAsString", "info", "produceStrings", "helper", "info", "produceStrings", "helper", "start", "join", "wakeup", "getMetricConsumer", "get", "consumeStrings", "helper", "assertEquals", "size", "get", "consumeStrings", "helper", "assertEquals", "size", "info"]}, "focal_class": {"identifier": "KafkaDetectorManager", "superclass": "", "interfaces": "implements Runnable", "fields": [{"original_string": "private static final String APP_ID = \"ad-manager\";", "modifier": "private static final", "type": "String", "declarator": "APP_ID = \"ad-manager\"", "var_name": "APP_ID"}, {"original_string": "private static final String METRIC_CONSUMER = \"metric-consumer\";", "modifier": "private static final", "type": "String", "declarator": "METRIC_CONSUMER = \"metric-consumer\"", "var_name": "METRIC_CONSUMER"}, {"original_string": "private static final String ANOMALY_PRODUCER = \"anomaly-producer\";", "modifier": "private static final", "type": "String", "declarator": "ANOMALY_PRODUCER = \"anomaly-producer\"", "var_name": "ANOMALY_PRODUCER"}, {"original_string": "private static final String TOPIC = \"topic\";", "modifier": "private static final", "type": "String", "declarator": "TOPIC = \"topic\"", "var_name": "TOPIC"}, {"original_string": "private static final String OUTLIER_TOPIC = \"outlier-topic\";", "modifier": "private static final", "type": "String", "declarator": "OUTLIER_TOPIC = \"outlier-topic\"", "var_name": "OUTLIER_TOPIC"}, {"original_string": "private static final String BREAKOUT_TOPIC = \"breakout-topic\";", "modifier": "private static final", "type": "String", "declarator": "BREAKOUT_TOPIC = \"breakout-topic\"", "var_name": "BREAKOUT_TOPIC"}, {"original_string": "private static final String DM_TRACING = \"tracing\";", "modifier": "private static final", "type": "String", "declarator": "DM_TRACING = \"tracing\"", "var_name": "DM_TRACING"}, {"original_string": "private static final String TRACING_STATUS_STRING = \"tracingStatus\";", "modifier": "private static final", "type": "String", "declarator": "TRACING_STATUS_STRING = \"tracingStatus\"", "var_name": "TRACING_STATUS_STRING"}, {"original_string": "private static final String TRACING_STATUS_CHECK_STRING = \"enabled\";", "modifier": "private static final", "type": "String", "declarator": "TRACING_STATUS_CHECK_STRING = \"enabled\"", "var_name": "TRACING_STATUS_CHECK_STRING"}, {"original_string": "private static final long POLL_PERIOD = 1000L;", "modifier": "private static final", "type": "long", "declarator": "POLL_PERIOD = 1000L", "var_name": "POLL_PERIOD"}, {"original_string": "@Getter\n    private final DetectorManager detectorManager;", "modifier": "@Getter\n    private final", "type": "DetectorManager", "declarator": "detectorManager", "var_name": "detectorManager"}, {"original_string": "@Getter\n    private final Consumer<String, MappedMetricData> metricConsumer;", "modifier": "@Getter\n    private final", "type": "Consumer<String, MappedMetricData>", "declarator": "metricConsumer", "var_name": "metricConsumer"}, {"original_string": "@Getter\n    private final Producer<String, MappedMetricData> anomalyProducer;", "modifier": "@Getter\n    private final", "type": "Producer<String, MappedMetricData>", "declarator": "anomalyProducer", "var_name": "anomalyProducer"}, {"original_string": "@Getter\n    private final String metricTopic;", "modifier": "@Getter\n    private final", "type": "String", "declarator": "metricTopic", "var_name": "metricTopic"}, {"original_string": "@Getter\n    private final String outlierTopic;", "modifier": "@Getter\n    private final", "type": "String", "declarator": "outlierTopic", "var_name": "outlierTopic"}, {"original_string": "@Getter\n    private final String breakoutTopic;", "modifier": "@Getter\n    private final", "type": "String", "declarator": "breakoutTopic", "var_name": "breakoutTopic"}, {"original_string": "@Getter\n    private final String tracingEnabled;", "modifier": "@Getter\n    private final", "type": "String", "declarator": "tracingEnabled", "var_name": "tracingEnabled"}], "methods": [{"identifier": "main", "parameters": "(String[] args)", "modifiers": "@Generated public static", "return": "void", "signature": "void main(String[] args)", "full_signature": "@Generated public static void main(String[] args)", "class_method_signature": "KafkaDetectorManager.main(String[] args)", "testcase": false, "constructor": false}, {"identifier": "buildManager", "parameters": "(Config config)", "modifiers": "static", "return": "KafkaDetectorManager", "signature": "KafkaDetectorManager buildManager(Config config)", "full_signature": "static KafkaDetectorManager buildManager(Config config)", "class_method_signature": "KafkaDetectorManager.buildManager(Config config)", "testcase": false, "constructor": false}, {"identifier": "getMetricRegistry", "parameters": "()", "modifiers": "private static", "return": "MetricRegistry", "signature": "MetricRegistry getMetricRegistry()", "full_signature": "private static MetricRegistry getMetricRegistry()", "class_method_signature": "KafkaDetectorManager.getMetricRegistry()", "testcase": false, "constructor": false}, {"identifier": "KafkaDetectorManager", "parameters": "(\n            DetectorManager detectorManager,\n            Consumer<String, MappedMetricData> metricConsumer,\n            Producer<String, MappedMetricData> anomalyProducer,\n            String metricTopic,\n            String outlierTopic,\n            String breakoutTopic,\n            String tracingEnabled)", "modifiers": "public", "return": "", "signature": " KafkaDetectorManager(\n            DetectorManager detectorManager,\n            Consumer<String, MappedMetricData> metricConsumer,\n            Producer<String, MappedMetricData> anomalyProducer,\n            String metricTopic,\n            String outlierTopic,\n            String breakoutTopic,\n            String tracingEnabled)", "full_signature": "public  KafkaDetectorManager(\n            DetectorManager detectorManager,\n            Consumer<String, MappedMetricData> metricConsumer,\n            Producer<String, MappedMetricData> anomalyProducer,\n            String metricTopic,\n            String outlierTopic,\n            String breakoutTopic,\n            String tracingEnabled)", "class_method_signature": "KafkaDetectorManager.KafkaDetectorManager(\n            DetectorManager detectorManager,\n            Consumer<String, MappedMetricData> metricConsumer,\n            Producer<String, MappedMetricData> anomalyProducer,\n            String metricTopic,\n            String outlierTopic,\n            String breakoutTopic,\n            String tracingEnabled)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "KafkaDetectorManager.run()", "testcase": false, "constructor": false}, {"identifier": "processMetrics", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void processMetrics()", "full_signature": "private void processMetrics()", "class_method_signature": "KafkaDetectorManager.processMetrics()", "testcase": false, "constructor": false}, {"identifier": "toAnomalyRecord", "parameters": "(\n            ConsumerRecord<String, MappedMetricData> metricRecord)", "modifiers": "private", "return": "ProducerRecord<String, MappedMetricData>", "signature": "ProducerRecord<String, MappedMetricData> toAnomalyRecord(\n            ConsumerRecord<String, MappedMetricData> metricRecord)", "full_signature": "private ProducerRecord<String, MappedMetricData> toAnomalyRecord(\n            ConsumerRecord<String, MappedMetricData> metricRecord)", "class_method_signature": "KafkaDetectorManager.toAnomalyRecord(\n            ConsumerRecord<String, MappedMetricData> metricRecord)", "testcase": false, "constructor": false}, {"identifier": "getOutputTopic", "parameters": "(DetectorResult result)", "modifiers": "private", "return": "String", "signature": "String getOutputTopic(DetectorResult result)", "full_signature": "private String getOutputTopic(DetectorResult result)", "class_method_signature": "KafkaDetectorManager.getOutputTopic(DetectorResult result)", "testcase": false, "constructor": false}, {"identifier": "detectorManagerExtractAndInjectSpan", "parameters": "(ConsumerRecord<String, MappedMetricData> metricRecord,\n                                                     ProducerRecord<String, MappedMetricData> anomalyRecord)", "modifiers": "private", "return": "void", "signature": "void detectorManagerExtractAndInjectSpan(ConsumerRecord<String, MappedMetricData> metricRecord,\n                                                     ProducerRecord<String, MappedMetricData> anomalyRecord)", "full_signature": "private void detectorManagerExtractAndInjectSpan(ConsumerRecord<String, MappedMetricData> metricRecord,\n                                                     ProducerRecord<String, MappedMetricData> anomalyRecord)", "class_method_signature": "KafkaDetectorManager.detectorManagerExtractAndInjectSpan(ConsumerRecord<String, MappedMetricData> metricRecord,\n                                                     ProducerRecord<String, MappedMetricData> anomalyRecord)", "testcase": false, "constructor": false}], "file": "kafka/src/main/java/com/expedia/adaptivealerting/kafka/KafkaDetectorManager.java"}, "focal_method": {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void run() {\n        log.info(\"Starting KafkaDetectorManager\");\n        metricConsumer.subscribe(Collections.singletonList(metricTopic));\n        boolean continueProcessing = true;\n\n        // See Kafka: The Definitive Guide, pp. 86 ff.\n        while (continueProcessing) {\n            try {\n                processMetrics();\n            } catch (WakeupException e) {\n                log.info(\"Stopping KafkaDetectorManager\");\n                metricConsumer.close();\n                anomalyProducer.flush();\n                anomalyProducer.close();\n                continueProcessing = false;\n            } catch (Exception e) {\n                log.error(\"Error processing records\", e);\n            }\n        }\n    }", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "KafkaDetectorManager.run()", "testcase": false, "constructor": false, "invocations": ["info", "subscribe", "singletonList", "processMetrics", "info", "close", "flush", "close", "error"]}, "repository": {"repo_id": 129125498, "url": "https://github.com/ExpediaDotCom/adaptive-alerting", "stars": 104, "created": "4/11/2018 4:51:18 PM +00:00", "updates": "2020-01-24T16:20:26+00:00", "fork": "False", "license": "licensed"}}