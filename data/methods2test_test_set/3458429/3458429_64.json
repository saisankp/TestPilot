{"test_class": {"identifier": "HpackDecoderTest", "superclass": "", "interfaces": "", "fields": [], "file": "firefly-net/src/test/java/com/fireflysource/net/http/common/v2/hpack/HpackDecoderTest.java"}, "test_case": {"identifier": "testHuffmanEncodedStandard", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n    void testHuffmanEncodedStandard() throws Exception {\n        HpackDecoder decoder = new HpackDecoder(4096, 8192);\n\n        String encoded = \"82868441\" + \"83\" + \"49509F\";\n        ByteBuffer buffer = ByteBuffer.wrap(TypeUtils.fromHexString(encoded));\n\n        MetaData.Request request = (MetaData.Request) decoder.decode(buffer);\n\n        assertEquals(\"GET\", request.getMethod());\n        assertEquals(HttpScheme.HTTP.getValue(), request.getURI().getScheme());\n        assertEquals(\"/\", request.getURI().getPath());\n        assertEquals(\"test\", request.getURI().getHost());\n        assertFalse(request.iterator().hasNext());\n    }", "signature": "void testHuffmanEncodedStandard()", "full_signature": "@Test void testHuffmanEncodedStandard()", "class_method_signature": "HpackDecoderTest.testHuffmanEncodedStandard()", "testcase": true, "constructor": false, "invocations": ["wrap", "fromHexString", "decode", "assertEquals", "getMethod", "assertEquals", "getValue", "getScheme", "getURI", "assertEquals", "getPath", "getURI", "assertEquals", "getHost", "getURI", "assertFalse", "hasNext", "iterator"]}, "focal_class": {"identifier": "HpackDecoder", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final Logger LOG = SystemLogger.create(HpackDecoder.class);", "modifier": "public static final", "type": "Logger", "declarator": "LOG = SystemLogger.create(HpackDecoder.class)", "var_name": "LOG"}, {"original_string": "public static final HttpField.LongValueHttpField CONTENT_LENGTH_0 =\n            new HttpField.LongValueHttpField(HttpHeader.CONTENT_LENGTH, 0L);", "modifier": "public static final", "type": "HttpField.LongValueHttpField", "declarator": "CONTENT_LENGTH_0 =\n            new HttpField.LongValueHttpField(HttpHeader.CONTENT_LENGTH, 0L)", "var_name": "CONTENT_LENGTH_0"}, {"original_string": "private final HpackContext context;", "modifier": "private final", "type": "HpackContext", "declarator": "context", "var_name": "context"}, {"original_string": "private final MetaDataBuilder builder;", "modifier": "private final", "type": "MetaDataBuilder", "declarator": "builder", "var_name": "builder"}, {"original_string": "private int localMaxDynamicTableSize;", "modifier": "private", "type": "int", "declarator": "localMaxDynamicTableSize", "var_name": "localMaxDynamicTableSize"}], "methods": [{"identifier": "HpackDecoder", "parameters": "(int localMaxDynamicTableSize, int maxHeaderSize)", "modifiers": "public", "return": "", "signature": " HpackDecoder(int localMaxDynamicTableSize, int maxHeaderSize)", "full_signature": "public  HpackDecoder(int localMaxDynamicTableSize, int maxHeaderSize)", "class_method_signature": "HpackDecoder.HpackDecoder(int localMaxDynamicTableSize, int maxHeaderSize)", "testcase": false, "constructor": true}, {"identifier": "getHpackContext", "parameters": "()", "modifiers": "public", "return": "HpackContext", "signature": "HpackContext getHpackContext()", "full_signature": "public HpackContext getHpackContext()", "class_method_signature": "HpackDecoder.getHpackContext()", "testcase": false, "constructor": false}, {"identifier": "setLocalMaxDynamicTableSize", "parameters": "(int localMaxdynamciTableSize)", "modifiers": "public", "return": "void", "signature": "void setLocalMaxDynamicTableSize(int localMaxdynamciTableSize)", "full_signature": "public void setLocalMaxDynamicTableSize(int localMaxdynamciTableSize)", "class_method_signature": "HpackDecoder.setLocalMaxDynamicTableSize(int localMaxdynamciTableSize)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(ByteBuffer buffer)", "modifiers": "public", "return": "MetaData", "signature": "MetaData decode(ByteBuffer buffer)", "full_signature": "public MetaData decode(ByteBuffer buffer)", "class_method_signature": "HpackDecoder.decode(ByteBuffer buffer)", "testcase": false, "constructor": false}, {"identifier": "toASCIIString", "parameters": "(ByteBuffer buffer, int length)", "modifiers": "public static", "return": "String", "signature": "String toASCIIString(ByteBuffer buffer, int length)", "full_signature": "public static String toASCIIString(ByteBuffer buffer, int length)", "class_method_signature": "HpackDecoder.toASCIIString(ByteBuffer buffer, int length)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "HpackDecoder.toString()", "testcase": false, "constructor": false}], "file": "firefly-net/src/main/java/com/fireflysource/net/http/common/v2/hpack/HpackDecoder.java"}, "focal_method": {"identifier": "decode", "parameters": "(ByteBuffer buffer)", "modifiers": "public", "return": "MetaData", "body": "public MetaData decode(ByteBuffer buffer) throws HpackException.SessionException, HpackException.StreamException {\n        if (LOG.isDebugEnabled())\n            LOG.debug(String.format(\"CtxTbl[%x] decoding %d octets\", context.hashCode(), buffer.remaining()));\n\n        // If the buffer is big, don't even think about decoding it\n        if (buffer.remaining() > builder.getMaxSize())\n            throw new HpackException.SessionException(\"431 Request Header Fields too large\");\n\n        boolean emitted = false;\n\n        while (buffer.hasRemaining()) {\n            if (LOG.isDebugEnabled() && buffer.hasArray()) {\n                int l = Math.min(buffer.remaining(), 32);\n                LOG.debug(\"decode {}{}\",\n                        TypeUtils.toHexString(buffer.array(), buffer.arrayOffset() + buffer.position(), l),\n                        l < buffer.remaining() ? \"...\" : \"\");\n            }\n\n            byte b = buffer.get();\n            if (b < 0) {\n                // 7.1 indexed if the high bit is set\n                int index = NBitInteger.decode(buffer, 7);\n                Entry entry = context.get(index);\n                if (entry == null)\n                    throw new HpackException.SessionException(\"Unknown index %d\", index);\n\n                if (entry.isStatic()) {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"decode IdxStatic {}\", entry);\n                    // emit field\n                    emitted = true;\n                    builder.emit(entry.getHttpField());\n\n                    // TODO copy and add to reference set if there is room\n                    // _context.add(entry.getHttpField());\n                } else {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"decode Idx {}\", entry);\n                    // emit\n                    emitted = true;\n                    builder.emit(entry.getHttpField());\n                }\n            } else {\n                // look at the first nibble in detail\n                byte f = (byte) ((b & 0xF0) >> 4);\n                String name;\n                HttpHeader header;\n                String value;\n\n                boolean indexed;\n                int nameIndex;\n\n                switch (f) {\n                    case 2: // 7.3\n                    case 3: // 7.3\n                        // change table size\n                        int size = NBitInteger.decode(buffer, 5);\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"decode resize=\" + size);\n                        if (size > localMaxDynamicTableSize)\n                            throw new IllegalArgumentException();\n                        if (emitted)\n                            throw new HpackException.CompressionException(\"Dynamic table resize after fields\");\n                        context.resize(size);\n                        continue;\n\n                    case 0: // 7.2.2\n                    case 1: // 7.2.3\n                        indexed = false;\n                        nameIndex = NBitInteger.decode(buffer, 4);\n                        break;\n\n                    case 4: // 7.2.1\n                    case 5: // 7.2.1\n                    case 6: // 7.2.1\n                    case 7: // 7.2.1\n                        indexed = true;\n                        nameIndex = NBitInteger.decode(buffer, 6);\n                        break;\n\n                    default:\n                        throw new IllegalStateException();\n                }\n\n                boolean huffmanName = false;\n\n                // decode the name\n                if (nameIndex > 0) {\n                    Entry nameEntry = context.get(nameIndex);\n                    name = nameEntry.getHttpField().getName();\n                    header = nameEntry.getHttpField().getHeader();\n                } else {\n                    huffmanName = (buffer.get() & 0x80) == 0x80;\n                    int length = NBitInteger.decode(buffer, 7);\n                    builder.checkSize(length, huffmanName);\n                    if (huffmanName)\n                        name = Huffman.decode(buffer, length);\n                    else\n                        name = toASCIIString(buffer, length);\n                    check:\n                    for (int i = name.length(); i-- > 0; ) {\n                        char c = name.charAt(i);\n                        if (c > 0xff) {\n                            builder.streamException(\"Illegal header name %s\", name);\n                            break;\n                        }\n                        HttpTokens.Token token = HttpTokens.TOKENS[0xFF & c];\n                        switch (token.getType()) {\n                            case ALPHA:\n                                if (c >= 'A' && c <= 'Z') {\n                                    builder.streamException(\"Uppercase header name %s\", name);\n                                    break check;\n                                }\n                                break;\n\n                            case COLON:\n                            case TCHAR:\n                            case DIGIT:\n                                break;\n\n                            default:\n                                builder.streamException(\"Illegal header name %s\", name);\n                                break check;\n                        }\n                    }\n                    header = HttpHeader.CACHE.get(name);\n                }\n\n                // decode the value\n                boolean huffmanValue = (buffer.get() & 0x80) == 0x80;\n                int length = NBitInteger.decode(buffer, 7);\n                builder.checkSize(length, huffmanValue);\n                if (huffmanValue)\n                    value = Huffman.decode(buffer, length);\n                else\n                    value = toASCIIString(buffer, length);\n\n                // Make the new field\n                HttpField field;\n                if (header == null) {\n                    // just make a normal field and bypass header name lookup\n                    field = new HttpField(null, name, value);\n                } else {\n                    // might be worthwhile to create a value HttpField if it is indexed\n                    // and/or of a type that may be looked up multiple times.\n                    switch (header) {\n                        case C_STATUS:\n                            if (indexed)\n                                field = new HttpField.IntValueHttpField(header, name, value);\n                            else\n                                field = new HttpField(header, name, value);\n                            break;\n\n                        case C_AUTHORITY:\n                            field = new AuthorityHttpField(value);\n                            break;\n\n                        case CONTENT_LENGTH:\n                            if (\"0\".equals(value))\n                                field = CONTENT_LENGTH_0;\n                            else\n                                field = new HttpField.LongValueHttpField(header, name, value);\n                            break;\n\n                        default:\n                            field = new HttpField(header, name, value);\n                            break;\n                    }\n                }\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"decoded '{}' by {}/{}/{}\",\n                            field,\n                            nameIndex > 0 ? \"IdxName\" : (huffmanName ? \"HuffName\" : \"LitName\"),\n                            huffmanValue ? \"HuffVal\" : \"LitVal\",\n                            indexed ? \"Idx\" : \"\");\n                }\n\n                // emit the field\n                emitted = true;\n                builder.emit(field);\n\n                // if indexed add to dynamic table\n                if (indexed)\n                    context.add(field);\n            }\n        }\n\n        return builder.build();\n    }", "signature": "MetaData decode(ByteBuffer buffer)", "full_signature": "public MetaData decode(ByteBuffer buffer)", "class_method_signature": "HpackDecoder.decode(ByteBuffer buffer)", "testcase": false, "constructor": false, "invocations": ["isDebugEnabled", "debug", "format", "hashCode", "remaining", "remaining", "getMaxSize", "hasRemaining", "isDebugEnabled", "hasArray", "min", "remaining", "debug", "toHexString", "array", "arrayOffset", "position", "remaining", "get", "decode", "get", "isStatic", "isDebugEnabled", "debug", "emit", "getHttpField", "isDebugEnabled", "debug", "emit", "getHttpField", "decode", "isDebugEnabled", "debug", "resize", "decode", "decode", "get", "getName", "getHttpField", "getHeader", "getHttpField", "get", "decode", "checkSize", "decode", "toASCIIString", "length", "charAt", "streamException", "getType", "streamException", "streamException", "get", "get", "decode", "checkSize", "decode", "toASCIIString", "equals", "isDebugEnabled", "debug", "emit", "add", "build"]}, "repository": {"repo_id": 3458429, "url": "https://github.com/hypercube1024/firefly", "language": "Java", "is_fork": false, "fork_count": 118, "stargazer_count": 271, "size": 29687, "license": "licensed"}}