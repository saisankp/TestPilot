{"test_class": {"identifier": "ModuleShardBackendResolverTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final MemberName MEMBER_NAME = MemberName.forName(\"member-1\");", "modifier": "private static final", "type": "MemberName", "declarator": "MEMBER_NAME = MemberName.forName(\"member-1\")", "var_name": "MEMBER_NAME"}, {"original_string": "private static final FrontendType FRONTEND_TYPE = FrontendType.forName(\"type-1\");", "modifier": "private static final", "type": "FrontendType", "declarator": "FRONTEND_TYPE = FrontendType.forName(\"type-1\")", "var_name": "FRONTEND_TYPE"}, {"original_string": "private static final FrontendIdentifier FRONTEND_ID = FrontendIdentifier.create(MEMBER_NAME, FRONTEND_TYPE);", "modifier": "private static final", "type": "FrontendIdentifier", "declarator": "FRONTEND_ID = FrontendIdentifier.create(MEMBER_NAME, FRONTEND_TYPE)", "var_name": "FRONTEND_ID"}, {"original_string": "private static final ClientIdentifier CLIENT_ID = ClientIdentifier.create(FRONTEND_ID, 0);", "modifier": "private static final", "type": "ClientIdentifier", "declarator": "CLIENT_ID = ClientIdentifier.create(FRONTEND_ID, 0)", "var_name": "CLIENT_ID"}, {"original_string": "private ActorSystem system;", "modifier": "private", "type": "ActorSystem", "declarator": "system", "var_name": "system"}, {"original_string": "private ModuleShardBackendResolver moduleShardBackendResolver;", "modifier": "private", "type": "ModuleShardBackendResolver", "declarator": "moduleShardBackendResolver", "var_name": "moduleShardBackendResolver"}, {"original_string": "private TestProbe contextProbe;", "modifier": "private", "type": "TestProbe", "declarator": "contextProbe", "var_name": "contextProbe"}, {"original_string": "private TestProbe shardManagerProbe;", "modifier": "private", "type": "TestProbe", "declarator": "shardManagerProbe", "var_name": "shardManagerProbe"}, {"original_string": "@Mock\n    private ShardStrategyFactory shardStrategyFactory;", "modifier": "@Mock\n    private", "type": "ShardStrategyFactory", "declarator": "shardStrategyFactory", "var_name": "shardStrategyFactory"}, {"original_string": "@Mock\n    private ShardStrategy shardStrategy;", "modifier": "@Mock\n    private", "type": "ShardStrategy", "declarator": "shardStrategy", "var_name": "shardStrategy"}, {"original_string": "@Mock\n    private DataTree dataTree;", "modifier": "@Mock\n    private", "type": "DataTree", "declarator": "dataTree", "var_name": "dataTree"}], "file": "opendaylight/md-sal/sal-distributed-datastore/src/test/java/org/opendaylight/controller/cluster/databroker/actors/dds/ModuleShardBackendResolverTest.java"}, "test_case": {"identifier": "testGetBackendInfo", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGetBackendInfo() throws Exception {\n        final CompletionStage<ShardBackendInfo> i = moduleShardBackendResolver.getBackendInfo(0L);\n        contextProbe.expectMsgClass(ConnectClientRequest.class);\n        final TestProbe backendProbe = new TestProbe(system, \"backend\");\n        final ConnectClientSuccess msg = new ConnectClientSuccess(CLIENT_ID, 0L, backendProbe.ref(),\n                Collections.emptyList(), dataTree, 3);\n        contextProbe.reply(msg);\n        final CompletionStage<ShardBackendInfo> stage = moduleShardBackendResolver.getBackendInfo(0L);\n        final ShardBackendInfo shardBackendInfo = TestUtils.getWithTimeout(stage.toCompletableFuture());\n        Assert.assertEquals(0L, shardBackendInfo.getCookie().longValue());\n        Assert.assertEquals(dataTree, shardBackendInfo.getDataTree().get());\n        Assert.assertEquals(DefaultShardStrategy.DEFAULT_SHARD, shardBackendInfo.getName());\n    }", "signature": "void testGetBackendInfo()", "full_signature": "@Test public void testGetBackendInfo()", "class_method_signature": "ModuleShardBackendResolverTest.testGetBackendInfo()", "testcase": true, "constructor": false, "invocations": ["getBackendInfo", "expectMsgClass", "ref", "emptyList", "reply", "getBackendInfo", "getWithTimeout", "toCompletableFuture", "assertEquals", "longValue", "getCookie", "assertEquals", "get", "getDataTree", "assertEquals", "getName"]}, "focal_class": {"identifier": "ModuleShardBackendResolver", "superclass": "extends AbstractShardBackendResolver", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(ModuleShardBackendResolver.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(ModuleShardBackendResolver.class)", "var_name": "LOG"}, {"original_string": "private final ConcurrentMap<Long, ShardState> backends = new ConcurrentHashMap<>();", "modifier": "private final", "type": "ConcurrentMap<Long, ShardState>", "declarator": "backends = new ConcurrentHashMap<>()", "var_name": "backends"}, {"original_string": "private final Future<Registration> shardAvailabilityChangesRegFuture;", "modifier": "private final", "type": "Future<Registration>", "declarator": "shardAvailabilityChangesRegFuture", "var_name": "shardAvailabilityChangesRegFuture"}, {"original_string": "@GuardedBy(\"this\")\n    private long nextShard = 1;", "modifier": "@GuardedBy(\"this\")\n    private", "type": "long", "declarator": "nextShard = 1", "var_name": "nextShard"}, {"original_string": "private volatile BiMap<String, Long> shards = ImmutableBiMap.of(DefaultShardStrategy.DEFAULT_SHARD, 0L);", "modifier": "private volatile", "type": "BiMap<String, Long>", "declarator": "shards = ImmutableBiMap.of(DefaultShardStrategy.DEFAULT_SHARD, 0L)", "var_name": "shards"}], "methods": [{"identifier": "ModuleShardBackendResolver", "parameters": "(final ClientIdentifier clientId, final ActorUtils actorUtils)", "modifiers": "", "return": "", "signature": " ModuleShardBackendResolver(final ClientIdentifier clientId, final ActorUtils actorUtils)", "full_signature": "  ModuleShardBackendResolver(final ClientIdentifier clientId, final ActorUtils actorUtils)", "class_method_signature": "ModuleShardBackendResolver.ModuleShardBackendResolver(final ClientIdentifier clientId, final ActorUtils actorUtils)", "testcase": false, "constructor": true}, {"identifier": "onShardAvailabilityChange", "parameters": "(String shardName)", "modifiers": "private", "return": "void", "signature": "void onShardAvailabilityChange(String shardName)", "full_signature": "private void onShardAvailabilityChange(String shardName)", "class_method_signature": "ModuleShardBackendResolver.onShardAvailabilityChange(String shardName)", "testcase": false, "constructor": false}, {"identifier": "resolveShardForPath", "parameters": "(final YangInstanceIdentifier path)", "modifiers": "", "return": "Long", "signature": "Long resolveShardForPath(final YangInstanceIdentifier path)", "full_signature": " Long resolveShardForPath(final YangInstanceIdentifier path)", "class_method_signature": "ModuleShardBackendResolver.resolveShardForPath(final YangInstanceIdentifier path)", "testcase": false, "constructor": false}, {"identifier": "getBackendInfo", "parameters": "(final Long cookie)", "modifiers": "@Override public", "return": "CompletionStage<ShardBackendInfo>", "signature": "CompletionStage<ShardBackendInfo> getBackendInfo(final Long cookie)", "full_signature": "@Override public CompletionStage<ShardBackendInfo> getBackendInfo(final Long cookie)", "class_method_signature": "ModuleShardBackendResolver.getBackendInfo(final Long cookie)", "testcase": false, "constructor": false}, {"identifier": "refreshBackendInfo", "parameters": "(final Long cookie,\n            final ShardBackendInfo staleInfo)", "modifiers": "@Override public", "return": "CompletionStage<ShardBackendInfo>", "signature": "CompletionStage<ShardBackendInfo> refreshBackendInfo(final Long cookie,\n            final ShardBackendInfo staleInfo)", "full_signature": "@Override public CompletionStage<ShardBackendInfo> refreshBackendInfo(final Long cookie,\n            final ShardBackendInfo staleInfo)", "class_method_signature": "ModuleShardBackendResolver.refreshBackendInfo(final Long cookie,\n            final ShardBackendInfo staleInfo)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "ModuleShardBackendResolver.close()", "testcase": false, "constructor": false}, {"identifier": "resolveCookieName", "parameters": "(Long cookie)", "modifiers": "@Override public", "return": "String", "signature": "String resolveCookieName(Long cookie)", "full_signature": "@Override public String resolveCookieName(Long cookie)", "class_method_signature": "ModuleShardBackendResolver.resolveCookieName(Long cookie)", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-distributed-datastore/src/main/java/org/opendaylight/controller/cluster/databroker/actors/dds/ModuleShardBackendResolver.java"}, "focal_method": {"identifier": "getBackendInfo", "parameters": "(final Long cookie)", "modifiers": "@Override public", "return": "CompletionStage<ShardBackendInfo>", "body": "@Override\n    public CompletionStage<ShardBackendInfo> getBackendInfo(final Long cookie) {\n        /*\n         * We cannot perform a simple computeIfAbsent() here because we need to control sequencing of when the state\n         * is inserted into the map and retired from it (based on the stage result).\n         *\n         * We do not want to hook another stage one processing completes and hooking a removal on failure from a compute\n         * method runs the inherent risk of stage completing before the insertion does (i.e. we have a removal of\n         * non-existent element.\n         */\n        final ShardState existing = backends.get(cookie);\n        if (existing != null) {\n            return existing.getStage();\n        }\n\n        final String shardName = shards.inverse().get(cookie);\n        if (shardName == null) {\n            LOG.warn(\"Failing request for non-existent cookie {}\", cookie);\n            throw new IllegalArgumentException(\"Cookie \" + cookie + \" does not have a shard assigned\");\n        }\n\n        LOG.debug(\"Resolving cookie {} to shard {}\", cookie, shardName);\n        final ShardState toInsert = resolveBackendInfo(shardName, cookie);\n\n        final ShardState raced = backends.putIfAbsent(cookie, toInsert);\n        if (raced != null) {\n            // We have had a concurrent insertion, return that\n            LOG.debug(\"Race during insertion of state for cookie {} shard {}\", cookie, shardName);\n            return raced.getStage();\n        }\n\n        // We have succeeded in populating the map, now we need to take care of pruning the entry if it fails to\n        // complete\n        final CompletionStage<ShardBackendInfo> stage = toInsert.getStage();\n        stage.whenComplete((info, failure) -> {\n            if (failure != null) {\n                LOG.debug(\"Resolution of cookie {} shard {} failed, removing state\", cookie, shardName, failure);\n                backends.remove(cookie, toInsert);\n\n                // Remove cache state in case someone else forgot to invalidate it\n                flushCache(shardName);\n            }\n        });\n\n        return stage;\n    }", "signature": "CompletionStage<ShardBackendInfo> getBackendInfo(final Long cookie)", "full_signature": "@Override public CompletionStage<ShardBackendInfo> getBackendInfo(final Long cookie)", "class_method_signature": "ModuleShardBackendResolver.getBackendInfo(final Long cookie)", "testcase": false, "constructor": false, "invocations": ["get", "getStage", "get", "inverse", "warn", "debug", "resolveBackendInfo", "putIfAbsent", "debug", "getStage", "getStage", "whenComplete", "debug", "remove", "flushCache"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}