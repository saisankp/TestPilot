{"test_class": {"identifier": "DistinctActionTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final ObjectMapper mapper = new ObjectMapper();", "modifier": "private final", "type": "ObjectMapper", "declarator": "mapper = new ObjectMapper()", "var_name": "mapper"}, {"original_string": "private QueryExecutor queryExecutor;", "modifier": "private", "type": "QueryExecutor", "declarator": "queryExecutor", "var_name": "queryExecutor"}, {"original_string": "private MockElasticsearchServer elasticsearchServer;", "modifier": "private", "type": "MockElasticsearchServer", "declarator": "elasticsearchServer", "var_name": "elasticsearchServer"}, {"original_string": "private HazelcastInstance hazelcastInstance;", "modifier": "private", "type": "HazelcastInstance", "declarator": "hazelcastInstance", "var_name": "hazelcastInstance"}], "file": "real-time/foxtrot/foxtrot-core/src/test/java/com/flipkart/foxtrot/core/querystore/actions/DistinctActionTest.java"}, "test_case": {"identifier": "testDistinctMultipleNestingAscDesc", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDistinctMultipleNestingAscDesc() throws QueryStoreException, JsonProcessingException {\n        DistinctRequest distinctRequest = new DistinctRequest();\n        distinctRequest.setTable(TestUtils.TEST_TABLE_NAME);\n\n        List<ResultSort> resultSorts = new ArrayList<ResultSort>();\n\n        ResultSort resultSort = new ResultSort();\n        resultSort.setField(\"version\");\n        resultSort.setOrder(ResultSort.Order.asc);\n        resultSorts.add(resultSort);\n\n        resultSort = new ResultSort();\n        resultSort.setField(\"os\");\n        resultSort.setOrder(ResultSort.Order.desc);\n        resultSorts.add(resultSort);\n\n        distinctRequest.setNesting(resultSorts);\n\n        DistinctResponse expectedResponse = new DistinctResponse();\n        expectedResponse.setHeaders(Arrays.asList(\"version\", \"os\"));\n\n        List<List<String>> listResponse = new ArrayList<List<String>>();\n        listResponse.add(Arrays.asList(\"1\", \"ios\"));\n        listResponse.add(Arrays.asList(\"1\", \"android\"));\n        listResponse.add(Arrays.asList(\"2\", \"ios\"));\n        listResponse.add(Arrays.asList(\"3\", \"android\"));\n        expectedResponse.setResult(listResponse);\n\n        DistinctResponse distinctResponse = DistinctResponse.class.cast(queryExecutor.execute(distinctRequest));\n        assertNotNull(distinctResponse);\n    }", "signature": "void testDistinctMultipleNestingAscDesc()", "full_signature": "@Test public void testDistinctMultipleNestingAscDesc()", "class_method_signature": "DistinctActionTest.testDistinctMultipleNestingAscDesc()", "testcase": true, "constructor": false, "invocations": ["setTable", "setField", "setOrder", "add", "setField", "setOrder", "add", "setNesting", "setHeaders", "asList", "add", "asList", "add", "asList", "add", "asList", "add", "asList", "setResult", "cast", "execute", "assertNotNull"]}, "focal_class": {"identifier": "DistinctAction", "superclass": "extends Action<DistinctRequest>", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(GroupAction.class.getSimpleName());", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(GroupAction.class.getSimpleName())", "var_name": "logger"}], "methods": [{"identifier": "DistinctAction", "parameters": "(DistinctRequest request,\n                          TableMetadataManager tableMetadataManager,\n                          DataStore dataStore,\n                          QueryStore queryStore,\n                          ElasticsearchConnection connection,\n                          String cacheToken)", "modifiers": "public", "return": "", "signature": " DistinctAction(DistinctRequest request,\n                          TableMetadataManager tableMetadataManager,\n                          DataStore dataStore,\n                          QueryStore queryStore,\n                          ElasticsearchConnection connection,\n                          String cacheToken)", "full_signature": "public  DistinctAction(DistinctRequest request,\n                          TableMetadataManager tableMetadataManager,\n                          DataStore dataStore,\n                          QueryStore queryStore,\n                          ElasticsearchConnection connection,\n                          String cacheToken)", "class_method_signature": "DistinctAction.DistinctAction(DistinctRequest request,\n                          TableMetadataManager tableMetadataManager,\n                          DataStore dataStore,\n                          QueryStore queryStore,\n                          ElasticsearchConnection connection,\n                          String cacheToken)", "testcase": false, "constructor": true}, {"identifier": "getRequestCacheKey", "parameters": "()", "modifiers": "@Override protected", "return": "String", "signature": "String getRequestCacheKey()", "full_signature": "@Override protected String getRequestCacheKey()", "class_method_signature": "DistinctAction.getRequestCacheKey()", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "(DistinctRequest request)", "modifiers": "@Override public", "return": "ActionResponse", "signature": "ActionResponse execute(DistinctRequest request)", "full_signature": "@Override public ActionResponse execute(DistinctRequest request)", "class_method_signature": "DistinctAction.execute(DistinctRequest request)", "testcase": false, "constructor": false}, {"identifier": "getDistinctResponse", "parameters": "(DistinctRequest request, Aggregations aggregations)", "modifiers": "private", "return": "DistinctResponse", "signature": "DistinctResponse getDistinctResponse(DistinctRequest request, Aggregations aggregations)", "full_signature": "private DistinctResponse getDistinctResponse(DistinctRequest request, Aggregations aggregations)", "class_method_signature": "DistinctAction.getDistinctResponse(DistinctRequest request, Aggregations aggregations)", "testcase": false, "constructor": false}, {"identifier": "flatten", "parameters": "(String parentKey, List<String> fields, List<List<String>> responseList, Aggregations aggregations)", "modifiers": "private", "return": "void", "signature": "void flatten(String parentKey, List<String> fields, List<List<String>> responseList, Aggregations aggregations)", "full_signature": "private void flatten(String parentKey, List<String> fields, List<List<String>> responseList, Aggregations aggregations)", "class_method_signature": "DistinctAction.flatten(String parentKey, List<String> fields, List<List<String>> responseList, Aggregations aggregations)", "testcase": false, "constructor": false}, {"identifier": "getProperKey", "parameters": "(String parentKey, String currentKey)", "modifiers": "private", "return": "String", "signature": "String getProperKey(String parentKey, String currentKey)", "full_signature": "private String getProperKey(String parentKey, String currentKey)", "class_method_signature": "DistinctAction.getProperKey(String parentKey, String currentKey)", "testcase": false, "constructor": false}, {"identifier": "getValueList", "parameters": "(String parentKey, String currentKey)", "modifiers": "private", "return": "List<String>", "signature": "List<String> getValueList(String parentKey, String currentKey)", "full_signature": "private List<String> getValueList(String parentKey, String currentKey)", "class_method_signature": "DistinctAction.getValueList(String parentKey, String currentKey)", "testcase": false, "constructor": false}], "file": "real-time/foxtrot/foxtrot-core/src/main/java/com/flipkart/foxtrot/core/querystore/actions/DistinctAction.java"}, "focal_method": {"identifier": "execute", "parameters": "(DistinctRequest request)", "modifiers": "@Override public", "return": "ActionResponse", "body": "@Override\n    public ActionResponse execute(DistinctRequest request) throws QueryStoreException {\n        request.setTable(ElasticsearchUtils.getValidTableName(request.getTable()));\n        if (null == request.getFilters()) {\n            request.setFilters(Lists.<Filter>newArrayList(new AnyFilter(request.getTable())));\n        }\n        if (request.getTable() == null) {\n            throw new QueryStoreException(QueryStoreException.ErrorCode.INVALID_REQUEST, \"Invalid Table\");\n        }\n        try {\n            SearchRequestBuilder query = getConnection().getClient().prepareSearch(ElasticsearchUtils.getIndices(\n                    request.getTable(), request));\n            TermsBuilder rootBuilder = null;\n            TermsBuilder termsBuilder = null;\n\n            for (ResultSort nestedField : request.getNesting()) {\n                if (nestedField.getField() == null || nestedField.getField().trim().isEmpty()) {\n                    throw new QueryStoreException(QueryStoreException.ErrorCode.INVALID_REQUEST, \"Illegal Nesting Parameters\");\n                }\n\n                String aggregationKey = Utils.sanitizeFieldForAggregation(nestedField.getField());\n                Terms.Order order = (nestedField.getOrder() == ResultSort.Order.desc) ? Terms.Order.term(false) : Terms.Order.term(true);\n\n                if (null == termsBuilder) {\n                    termsBuilder = AggregationBuilders.terms(aggregationKey).field(nestedField.getField()).order(order);\n                } else {\n                    TermsBuilder tempBuilder = AggregationBuilders.terms(aggregationKey).field(nestedField.getField()).order(order);\n                    termsBuilder.subAggregation(tempBuilder);\n                    termsBuilder = tempBuilder;\n                }\n                termsBuilder.size(0);\n                if (null == rootBuilder) {\n                    rootBuilder = termsBuilder;\n                }\n            }\n            query.setQuery(new ElasticSearchQueryGenerator(FilterCombinerType.and)\n                    .genFilter(request.getFilters()))\n                    .setSearchType(SearchType.COUNT)\n                    .addAggregation(rootBuilder);\n            SearchResponse response = query.execute().actionGet();\n            Aggregations aggregations = response.getAggregations();\n            // Check if any aggregation is present or not\n            if (aggregations == null) {\n                logger.error(\"Null response for Group. Request : \" + request.toString());\n                return new DistinctResponse(new ArrayList<String>(), new ArrayList<List<String>>());\n            }\n            return getDistinctResponse(request, aggregations);\n        } catch (QueryStoreException ex) {\n            throw ex;\n        } catch (Exception e) {\n            logger.error(\"Error running grouping: \", e);\n            throw new QueryStoreException(QueryStoreException.ErrorCode.QUERY_EXECUTION_ERROR,\n                    \"Error running group query.\", e);\n        }\n    }", "signature": "ActionResponse execute(DistinctRequest request)", "full_signature": "@Override public ActionResponse execute(DistinctRequest request)", "class_method_signature": "DistinctAction.execute(DistinctRequest request)", "testcase": false, "constructor": false, "invocations": ["setTable", "getValidTableName", "getTable", "getFilters", "setFilters", "newArrayList", "getTable", "getTable", "prepareSearch", "getClient", "getConnection", "getIndices", "getTable", "getNesting", "getField", "isEmpty", "trim", "getField", "sanitizeFieldForAggregation", "getField", "getOrder", "term", "term", "order", "field", "terms", "getField", "order", "field", "terms", "getField", "subAggregation", "size", "addAggregation", "setSearchType", "setQuery", "genFilter", "getFilters", "actionGet", "execute", "getAggregations", "error", "toString", "getDistinctResponse", "error"]}, "repository": {"repo_id": 44512524, "url": "https://github.com/zqhxuyuan/bigdata", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 8, "size": 91550, "license": "licensed"}}