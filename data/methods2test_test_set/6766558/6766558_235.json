{"test_class": {"identifier": "HystrixCommandTest", "superclass": "extends CommonHystrixCommandTests<TestHystrixCommand<Integer>>", "interfaces": "", "fields": [{"original_string": "@Rule\n    public HystrixRequestContextRule ctx = new HystrixRequestContextRule();", "modifier": "@Rule\n    public", "type": "HystrixRequestContextRule", "declarator": "ctx = new HystrixRequestContextRule()", "var_name": "ctx"}, {"original_string": "static AtomicInteger uniqueNameCounter = new AtomicInteger(1);", "modifier": "static", "type": "AtomicInteger", "declarator": "uniqueNameCounter = new AtomicInteger(1)", "var_name": "uniqueNameCounter"}], "file": "hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java"}, "test_case": {"identifier": "testSemaphorePermitsInUse", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSemaphorePermitsInUse() throws Exception {\n        final TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();\n\n        // this semaphore will be shared across multiple command instances\n        final TryableSemaphoreActual sharedSemaphore =\n                new TryableSemaphoreActual(HystrixProperty.Factory.asProperty(3));\n\n        // used to wait until all commands have started\n        final CountDownLatch startLatch = new CountDownLatch((sharedSemaphore.numberOfPermits.get() * 2) + 1);\n\n        // used to signal that all command can finish\n        final CountDownLatch sharedLatch = new CountDownLatch(1);\n\n        // tracks failures to obtain semaphores\n        final AtomicInteger failureCount = new AtomicInteger();\n\n        final Runnable sharedSemaphoreRunnable = new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {\n            public void run() {\n                try {\n                    new LatchedSemaphoreCommand(\"Command-Shared\", circuitBreaker, sharedSemaphore, startLatch, sharedLatch).execute();\n                } catch (Exception e) {\n                    startLatch.countDown();\n                    e.printStackTrace();\n                    failureCount.incrementAndGet();\n                }\n            }\n        });\n\n        // creates group of threads each using command sharing a single semaphore\n        // I create extra threads and commands so that I can verify that some of them fail to obtain a semaphore\n        final int sharedThreadCount = sharedSemaphore.numberOfPermits.get() * 2;\n        final Thread[] sharedSemaphoreThreads = new Thread[sharedThreadCount];\n        for (int i = 0; i < sharedThreadCount; i++) {\n            sharedSemaphoreThreads[i] = new Thread(sharedSemaphoreRunnable);\n        }\n\n        // creates thread using isolated semaphore\n        final TryableSemaphoreActual isolatedSemaphore =\n                new TryableSemaphoreActual(HystrixProperty.Factory.asProperty(1));\n\n        final CountDownLatch isolatedLatch = new CountDownLatch(1);\n\n        final Thread isolatedThread = new Thread(new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {\n            public void run() {\n                try {\n                    new LatchedSemaphoreCommand(\"Command-Isolated\", circuitBreaker, isolatedSemaphore, startLatch, isolatedLatch).execute();\n                } catch (Exception e) {\n                    startLatch.countDown();\n                    e.printStackTrace();\n                    failureCount.incrementAndGet();\n                }\n            }\n        }));\n\n        // verifies no permits in use before starting threads\n        assertEquals(\"before threads start, shared semaphore should be unused\", 0, sharedSemaphore.getNumberOfPermitsUsed());\n        assertEquals(\"before threads start, isolated semaphore should be unused\", 0, isolatedSemaphore.getNumberOfPermitsUsed());\n\n        for (int i = 0; i < sharedThreadCount; i++) {\n            sharedSemaphoreThreads[i].start();\n        }\n        isolatedThread.start();\n\n        // waits until all commands have started\n        startLatch.await(1000, TimeUnit.MILLISECONDS);\n\n        // verifies that all semaphores are in use\n        assertEquals(\"immediately after command start, all shared semaphores should be in-use\",\n                sharedSemaphore.numberOfPermits.get().longValue(), sharedSemaphore.getNumberOfPermitsUsed());\n        assertEquals(\"immediately after command start, isolated semaphore should be in-use\",\n                isolatedSemaphore.numberOfPermits.get().longValue(), isolatedSemaphore.getNumberOfPermitsUsed());\n\n        // signals commands to finish\n        sharedLatch.countDown();\n        isolatedLatch.countDown();\n\n        for (int i = 0; i < sharedThreadCount; i++) {\n            sharedSemaphoreThreads[i].join();\n        }\n        isolatedThread.join();\n\n        // verifies no permits in use after finishing threads\n        System.out.println(\"REQLOG : \" + HystrixRequestLog.getCurrentRequest().getExecutedCommandsAsString());\n\n        assertEquals(\"after all threads have finished, no shared semaphores should be in-use\", 0, sharedSemaphore.getNumberOfPermitsUsed());\n        assertEquals(\"after all threads have finished, isolated semaphore not in-use\", 0, isolatedSemaphore.getNumberOfPermitsUsed());\n\n        // verifies that some executions failed\n        assertEquals(\"expected some of shared semaphore commands to get rejected\", sharedSemaphore.numberOfPermits.get().longValue(), failureCount.get());\n        assertEquals(0, circuitBreaker.metrics.getCurrentConcurrentExecutionCount());\n    }", "signature": "void testSemaphorePermitsInUse()", "full_signature": "@Test public void testSemaphorePermitsInUse()", "class_method_signature": "HystrixCommandTest.testSemaphorePermitsInUse()", "testcase": true, "constructor": false, "invocations": ["asProperty", "get", "getConcurrencyStrategy", "getInstance", "execute", "countDown", "printStackTrace", "incrementAndGet", "get", "asProperty", "getConcurrencyStrategy", "getInstance", "execute", "countDown", "printStackTrace", "incrementAndGet", "assertEquals", "getNumberOfPermitsUsed", "assertEquals", "getNumberOfPermitsUsed", "start", "start", "await", "assertEquals", "longValue", "get", "getNumberOfPermitsUsed", "assertEquals", "longValue", "get", "getNumberOfPermitsUsed", "countDown", "countDown", "join", "join", "println", "getExecutedCommandsAsString", "getCurrentRequest", "assertEquals", "getNumberOfPermitsUsed", "assertEquals", "getNumberOfPermitsUsed", "assertEquals", "longValue", "get", "get", "assertEquals", "getCurrentConcurrentExecutionCount"]}, "focal_class": {"identifier": "HystrixCommand", "superclass": "extends AbstractCommand<R>", "interfaces": "implements HystrixExecutable<R>, HystrixInvokableInfo<R>, HystrixObservable<R>", "fields": [{"original_string": "private final AtomicReference<Thread> executionThread = new AtomicReference<Thread>();", "modifier": "private final", "type": "AtomicReference<Thread>", "declarator": "executionThread = new AtomicReference<Thread>()", "var_name": "executionThread"}, {"original_string": "private final AtomicBoolean interruptOnFutureCancel = new AtomicBoolean(false);", "modifier": "private final", "type": "AtomicBoolean", "declarator": "interruptOnFutureCancel = new AtomicBoolean(false)", "var_name": "interruptOnFutureCancel"}], "methods": [{"identifier": "HystrixCommand", "parameters": "(HystrixCommandGroupKey group)", "modifiers": "protected", "return": "", "signature": " HystrixCommand(HystrixCommandGroupKey group)", "full_signature": "protected  HystrixCommand(HystrixCommandGroupKey group)", "class_method_signature": "HystrixCommand.HystrixCommand(HystrixCommandGroupKey group)", "testcase": false, "constructor": true}, {"identifier": "HystrixCommand", "parameters": "(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool)", "modifiers": "protected", "return": "", "signature": " HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool)", "full_signature": "protected  HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool)", "class_method_signature": "HystrixCommand.HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool)", "testcase": false, "constructor": true}, {"identifier": "HystrixCommand", "parameters": "(HystrixCommandGroupKey group, int executionIsolationThreadTimeoutInMilliseconds)", "modifiers": "protected", "return": "", "signature": " HystrixCommand(HystrixCommandGroupKey group, int executionIsolationThreadTimeoutInMilliseconds)", "full_signature": "protected  HystrixCommand(HystrixCommandGroupKey group, int executionIsolationThreadTimeoutInMilliseconds)", "class_method_signature": "HystrixCommand.HystrixCommand(HystrixCommandGroupKey group, int executionIsolationThreadTimeoutInMilliseconds)", "testcase": false, "constructor": true}, {"identifier": "HystrixCommand", "parameters": "(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool, int executionIsolationThreadTimeoutInMilliseconds)", "modifiers": "protected", "return": "", "signature": " HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool, int executionIsolationThreadTimeoutInMilliseconds)", "full_signature": "protected  HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool, int executionIsolationThreadTimeoutInMilliseconds)", "class_method_signature": "HystrixCommand.HystrixCommand(HystrixCommandGroupKey group, HystrixThreadPoolKey threadPool, int executionIsolationThreadTimeoutInMilliseconds)", "testcase": false, "constructor": true}, {"identifier": "HystrixCommand", "parameters": "(Setter setter)", "modifiers": "protected", "return": "", "signature": " HystrixCommand(Setter setter)", "full_signature": "protected  HystrixCommand(Setter setter)", "class_method_signature": "HystrixCommand.HystrixCommand(Setter setter)", "testcase": false, "constructor": true}, {"identifier": "HystrixCommand", "parameters": "(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,\n            HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,\n            HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,\n            HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)", "modifiers": "", "return": "", "signature": " HystrixCommand(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,\n            HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,\n            HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,\n            HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)", "full_signature": "  HystrixCommand(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,\n            HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,\n            HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,\n            HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)", "class_method_signature": "HystrixCommand.HystrixCommand(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,\n            HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,\n            HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,\n            HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "protected abstract", "return": "R", "signature": "R run()", "full_signature": "protected abstract R run()", "class_method_signature": "HystrixCommand.run()", "testcase": false, "constructor": false}, {"identifier": "getFallback", "parameters": "()", "modifiers": "protected", "return": "R", "signature": "R getFallback()", "full_signature": "protected R getFallback()", "class_method_signature": "HystrixCommand.getFallback()", "testcase": false, "constructor": false}, {"identifier": "getExecutionObservable", "parameters": "()", "modifiers": "@Override final protected", "return": "Observable<R>", "signature": "Observable<R> getExecutionObservable()", "full_signature": "@Override final protected Observable<R> getExecutionObservable()", "class_method_signature": "HystrixCommand.getExecutionObservable()", "testcase": false, "constructor": false}, {"identifier": "getFallbackObservable", "parameters": "()", "modifiers": "@Override final protected", "return": "Observable<R>", "signature": "Observable<R> getFallbackObservable()", "full_signature": "@Override final protected Observable<R> getFallbackObservable()", "class_method_signature": "HystrixCommand.getFallbackObservable()", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "()", "modifiers": "public", "return": "R", "signature": "R execute()", "full_signature": "public R execute()", "class_method_signature": "HystrixCommand.execute()", "testcase": false, "constructor": false}, {"identifier": "queue", "parameters": "()", "modifiers": "public", "return": "Future<R>", "signature": "Future<R> queue()", "full_signature": "public Future<R> queue()", "class_method_signature": "HystrixCommand.queue()", "testcase": false, "constructor": false}, {"identifier": "getFallbackMethodName", "parameters": "()", "modifiers": "@Override protected", "return": "String", "signature": "String getFallbackMethodName()", "full_signature": "@Override protected String getFallbackMethodName()", "class_method_signature": "HystrixCommand.getFallbackMethodName()", "testcase": false, "constructor": false}, {"identifier": "isFallbackUserDefined", "parameters": "()", "modifiers": "@Override protected", "return": "boolean", "signature": "boolean isFallbackUserDefined()", "full_signature": "@Override protected boolean isFallbackUserDefined()", "class_method_signature": "HystrixCommand.isFallbackUserDefined()", "testcase": false, "constructor": false}, {"identifier": "commandIsScalar", "parameters": "()", "modifiers": "@Override protected", "return": "boolean", "signature": "boolean commandIsScalar()", "full_signature": "@Override protected boolean commandIsScalar()", "class_method_signature": "HystrixCommand.commandIsScalar()", "testcase": false, "constructor": false}], "file": "hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java"}, "focal_method": {"identifier": "execute", "parameters": "()", "modifiers": "public", "return": "R", "body": "public R execute() {\n        try {\n            return queue().get();\n        } catch (Exception e) {\n            throw Exceptions.sneakyThrow(decomposeException(e));\n        }\n    }", "signature": "R execute()", "full_signature": "public R execute()", "class_method_signature": "HystrixCommand.execute()", "testcase": false, "constructor": false, "invocations": ["get", "queue", "sneakyThrow", "decomposeException"]}, "repository": {"repo_id": 6766558, "url": "https://github.com/Netflix/Hystrix", "stars": 19028, "created": "11/19/2012 8:14:46 PM +00:00", "updates": "2020-01-27T17:55:28+00:00", "fork": "False", "license": "licensed"}}