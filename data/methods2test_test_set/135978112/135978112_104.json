{"test_class": {"identifier": "ConnectSchemaTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Schema MAP_INT_STRING_SCHEMA = SchemaBuilder.map(Schema.INT32_SCHEMA, Schema.STRING_SCHEMA).build();", "modifier": "private static final", "type": "Schema", "declarator": "MAP_INT_STRING_SCHEMA = SchemaBuilder.map(Schema.INT32_SCHEMA, Schema.STRING_SCHEMA).build()", "var_name": "MAP_INT_STRING_SCHEMA"}, {"original_string": "private static final Schema FLAT_STRUCT_SCHEMA = SchemaBuilder.struct()\n            .field(\"field\", Schema.INT32_SCHEMA)\n            .build();", "modifier": "private static final", "type": "Schema", "declarator": "FLAT_STRUCT_SCHEMA = SchemaBuilder.struct()\n            .field(\"field\", Schema.INT32_SCHEMA)\n            .build()", "var_name": "FLAT_STRUCT_SCHEMA"}, {"original_string": "private static final Schema STRUCT_SCHEMA = SchemaBuilder.struct()\n            .field(\"first\", Schema.INT32_SCHEMA)\n            .field(\"second\", Schema.STRING_SCHEMA)\n            .field(\"array\", SchemaBuilder.array(Schema.INT32_SCHEMA).build())\n            .field(\"map\", SchemaBuilder.map(Schema.INT32_SCHEMA, Schema.STRING_SCHEMA).build())\n            .field(\"nested\", FLAT_STRUCT_SCHEMA)\n            .build();", "modifier": "private static final", "type": "Schema", "declarator": "STRUCT_SCHEMA = SchemaBuilder.struct()\n            .field(\"first\", Schema.INT32_SCHEMA)\n            .field(\"second\", Schema.STRING_SCHEMA)\n            .field(\"array\", SchemaBuilder.array(Schema.INT32_SCHEMA).build())\n            .field(\"map\", SchemaBuilder.map(Schema.INT32_SCHEMA, Schema.STRING_SCHEMA).build())\n            .field(\"nested\", FLAT_STRUCT_SCHEMA)\n            .build()", "var_name": "STRUCT_SCHEMA"}, {"original_string": "private static final Schema PARENT_STRUCT_SCHEMA = SchemaBuilder.struct()\n            .field(\"nested\", FLAT_STRUCT_SCHEMA)\n            .build();", "modifier": "private static final", "type": "Schema", "declarator": "PARENT_STRUCT_SCHEMA = SchemaBuilder.struct()\n            .field(\"nested\", FLAT_STRUCT_SCHEMA)\n            .build()", "var_name": "PARENT_STRUCT_SCHEMA"}], "file": "connect/api/src/test/java/org/apache/kafka/connect/data/ConnectSchemaTest.java"}, "test_case": {"identifier": "testValidateValueMismatchFloat", "parameters": "()", "modifiers": "@Test(expected = DataException.class) public", "return": "void", "body": "@Test(expected = DataException.class)\n    public void testValidateValueMismatchFloat() {\n        ConnectSchema.validateValue(Schema.FLOAT32_SCHEMA, 1.0);\n    }", "signature": "void testValidateValueMismatchFloat()", "full_signature": "@Test(expected = DataException.class) public void testValidateValueMismatchFloat()", "class_method_signature": "ConnectSchemaTest.testValidateValueMismatchFloat()", "testcase": true, "constructor": false, "invocations": ["validateValue"]}, "focal_class": {"identifier": "ConnectSchema", "superclass": "", "interfaces": "implements Schema", "fields": [{"original_string": "private static final Map<Type, List<Class>> SCHEMA_TYPE_CLASSES = new HashMap<>();", "modifier": "private static final", "type": "Map<Type, List<Class>>", "declarator": "SCHEMA_TYPE_CLASSES = new HashMap<>()", "var_name": "SCHEMA_TYPE_CLASSES"}, {"original_string": "private static final Map<String, List<Class>> LOGICAL_TYPE_CLASSES = new HashMap<>();", "modifier": "private static final", "type": "Map<String, List<Class>>", "declarator": "LOGICAL_TYPE_CLASSES = new HashMap<>()", "var_name": "LOGICAL_TYPE_CLASSES"}, {"original_string": "private static final Map<Class<?>, Type> JAVA_CLASS_SCHEMA_TYPES = new HashMap<>();", "modifier": "private static final", "type": "Map<Class<?>, Type>", "declarator": "JAVA_CLASS_SCHEMA_TYPES = new HashMap<>()", "var_name": "JAVA_CLASS_SCHEMA_TYPES"}, {"original_string": "private final Type type;", "modifier": "private final", "type": "Type", "declarator": "type", "var_name": "type"}, {"original_string": "private final boolean optional;", "modifier": "private final", "type": "boolean", "declarator": "optional", "var_name": "optional"}, {"original_string": "private final Object defaultValue;", "modifier": "private final", "type": "Object", "declarator": "defaultValue", "var_name": "defaultValue"}, {"original_string": "private final List<Field> fields;", "modifier": "private final", "type": "List<Field>", "declarator": "fields", "var_name": "fields"}, {"original_string": "private final Map<String, Field> fieldsByName;", "modifier": "private final", "type": "Map<String, Field>", "declarator": "fieldsByName", "var_name": "fieldsByName"}, {"original_string": "private final Schema keySchema;", "modifier": "private final", "type": "Schema", "declarator": "keySchema", "var_name": "keySchema"}, {"original_string": "private final Schema valueSchema;", "modifier": "private final", "type": "Schema", "declarator": "valueSchema", "var_name": "valueSchema"}, {"original_string": "private final String name;", "modifier": "private final", "type": "String", "declarator": "name", "var_name": "name"}, {"original_string": "private final Integer version;", "modifier": "private final", "type": "Integer", "declarator": "version", "var_name": "version"}, {"original_string": "private final String doc;", "modifier": "private final", "type": "String", "declarator": "doc", "var_name": "doc"}, {"original_string": "private final Map<String, String> parameters;", "modifier": "private final", "type": "Map<String, String>", "declarator": "parameters", "var_name": "parameters"}], "methods": [{"identifier": "ConnectSchema", "parameters": "(Type type, boolean optional, Object defaultValue, String name, Integer version, String doc, Map<String, String> parameters, List<Field> fields, Schema keySchema, Schema valueSchema)", "modifiers": "public", "return": "", "signature": " ConnectSchema(Type type, boolean optional, Object defaultValue, String name, Integer version, String doc, Map<String, String> parameters, List<Field> fields, Schema keySchema, Schema valueSchema)", "full_signature": "public  ConnectSchema(Type type, boolean optional, Object defaultValue, String name, Integer version, String doc, Map<String, String> parameters, List<Field> fields, Schema keySchema, Schema valueSchema)", "class_method_signature": "ConnectSchema.ConnectSchema(Type type, boolean optional, Object defaultValue, String name, Integer version, String doc, Map<String, String> parameters, List<Field> fields, Schema keySchema, Schema valueSchema)", "testcase": false, "constructor": true}, {"identifier": "ConnectSchema", "parameters": "(Type type, boolean optional, Object defaultValue, String name, Integer version, String doc)", "modifiers": "public", "return": "", "signature": " ConnectSchema(Type type, boolean optional, Object defaultValue, String name, Integer version, String doc)", "full_signature": "public  ConnectSchema(Type type, boolean optional, Object defaultValue, String name, Integer version, String doc)", "class_method_signature": "ConnectSchema.ConnectSchema(Type type, boolean optional, Object defaultValue, String name, Integer version, String doc)", "testcase": false, "constructor": true}, {"identifier": "ConnectSchema", "parameters": "(Type type)", "modifiers": "public", "return": "", "signature": " ConnectSchema(Type type)", "full_signature": "public  ConnectSchema(Type type)", "class_method_signature": "ConnectSchema.ConnectSchema(Type type)", "testcase": false, "constructor": true}, {"identifier": "type", "parameters": "()", "modifiers": "@Override public", "return": "Type", "signature": "Type type()", "full_signature": "@Override public Type type()", "class_method_signature": "ConnectSchema.type()", "testcase": false, "constructor": false}, {"identifier": "isOptional", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isOptional()", "full_signature": "@Override public boolean isOptional()", "class_method_signature": "ConnectSchema.isOptional()", "testcase": false, "constructor": false}, {"identifier": "defaultValue", "parameters": "()", "modifiers": "@Override public", "return": "Object", "signature": "Object defaultValue()", "full_signature": "@Override public Object defaultValue()", "class_method_signature": "ConnectSchema.defaultValue()", "testcase": false, "constructor": false}, {"identifier": "name", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String name()", "full_signature": "@Override public String name()", "class_method_signature": "ConnectSchema.name()", "testcase": false, "constructor": false}, {"identifier": "version", "parameters": "()", "modifiers": "@Override public", "return": "Integer", "signature": "Integer version()", "full_signature": "@Override public Integer version()", "class_method_signature": "ConnectSchema.version()", "testcase": false, "constructor": false}, {"identifier": "doc", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String doc()", "full_signature": "@Override public String doc()", "class_method_signature": "ConnectSchema.doc()", "testcase": false, "constructor": false}, {"identifier": "parameters", "parameters": "()", "modifiers": "@Override public", "return": "Map<String, String>", "signature": "Map<String, String> parameters()", "full_signature": "@Override public Map<String, String> parameters()", "class_method_signature": "ConnectSchema.parameters()", "testcase": false, "constructor": false}, {"identifier": "fields", "parameters": "()", "modifiers": "@Override public", "return": "List<Field>", "signature": "List<Field> fields()", "full_signature": "@Override public List<Field> fields()", "class_method_signature": "ConnectSchema.fields()", "testcase": false, "constructor": false}, {"identifier": "field", "parameters": "(String fieldName)", "modifiers": "public", "return": "Field", "signature": "Field field(String fieldName)", "full_signature": "public Field field(String fieldName)", "class_method_signature": "ConnectSchema.field(String fieldName)", "testcase": false, "constructor": false}, {"identifier": "keySchema", "parameters": "()", "modifiers": "@Override public", "return": "Schema", "signature": "Schema keySchema()", "full_signature": "@Override public Schema keySchema()", "class_method_signature": "ConnectSchema.keySchema()", "testcase": false, "constructor": false}, {"identifier": "valueSchema", "parameters": "()", "modifiers": "@Override public", "return": "Schema", "signature": "Schema valueSchema()", "full_signature": "@Override public Schema valueSchema()", "class_method_signature": "ConnectSchema.valueSchema()", "testcase": false, "constructor": false}, {"identifier": "validateValue", "parameters": "(Schema schema, Object value)", "modifiers": "public static", "return": "void", "signature": "void validateValue(Schema schema, Object value)", "full_signature": "public static void validateValue(Schema schema, Object value)", "class_method_signature": "ConnectSchema.validateValue(Schema schema, Object value)", "testcase": false, "constructor": false}, {"identifier": "validateValue", "parameters": "(Object value)", "modifiers": "public", "return": "void", "signature": "void validateValue(Object value)", "full_signature": "public void validateValue(Object value)", "class_method_signature": "ConnectSchema.validateValue(Object value)", "testcase": false, "constructor": false}, {"identifier": "schema", "parameters": "()", "modifiers": "@Override public", "return": "ConnectSchema", "signature": "ConnectSchema schema()", "full_signature": "@Override public ConnectSchema schema()", "class_method_signature": "ConnectSchema.schema()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object o)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object o)", "full_signature": "@Override public boolean equals(Object o)", "class_method_signature": "ConnectSchema.equals(Object o)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "ConnectSchema.hashCode()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "ConnectSchema.toString()", "testcase": false, "constructor": false}, {"identifier": "schemaType", "parameters": "(Class<?> klass)", "modifiers": "public static", "return": "Type", "signature": "Type schemaType(Class<?> klass)", "full_signature": "public static Type schemaType(Class<?> klass)", "class_method_signature": "ConnectSchema.schemaType(Class<?> klass)", "testcase": false, "constructor": false}], "file": "connect/api/src/main/java/org/apache/kafka/connect/data/ConnectSchema.java"}, "focal_method": {"identifier": "validateValue", "parameters": "(Schema schema, Object value)", "modifiers": "public static", "return": "void", "body": "public static void validateValue(Schema schema, Object value) {\n        if (value == null) {\n            if (!schema.isOptional())\n                throw new DataException(\"Invalid value: null used for required field\");\n            else\n                return;\n        }\n\n        List<Class> expectedClasses = LOGICAL_TYPE_CLASSES.get(schema.name());\n\n        if (expectedClasses == null)\n                expectedClasses = SCHEMA_TYPE_CLASSES.get(schema.type());\n\n        if (expectedClasses == null)\n            throw new DataException(\"Invalid Java object for schema type \" + schema.type() + \": \" + value.getClass());\n\n        boolean foundMatch = false;\n        for (Class<?> expectedClass : expectedClasses) {\n            if (expectedClass.isInstance(value)) {\n                foundMatch = true;\n                break;\n            }\n        }\n        if (!foundMatch)\n            throw new DataException(\"Invalid Java object for schema type \" + schema.type() + \": \" + value.getClass());\n\n        switch (schema.type()) {\n            case STRUCT:\n                Struct struct = (Struct) value;\n                if (!struct.schema().equals(schema))\n                    throw new DataException(\"Struct schemas do not match.\");\n                struct.validate();\n                break;\n            case ARRAY:\n                List<?> array = (List<?>) value;\n                for (Object entry : array)\n                    validateValue(schema.valueSchema(), entry);\n                break;\n            case MAP:\n                Map<?, ?> map = (Map<?, ?>) value;\n                for (Map.Entry<?, ?> entry : map.entrySet()) {\n                    validateValue(schema.keySchema(), entry.getKey());\n                    validateValue(schema.valueSchema(), entry.getValue());\n                }\n                break;\n        }\n    }", "signature": "void validateValue(Schema schema, Object value)", "full_signature": "public static void validateValue(Schema schema, Object value)", "class_method_signature": "ConnectSchema.validateValue(Schema schema, Object value)", "testcase": false, "constructor": false, "invocations": ["isOptional", "get", "name", "get", "type", "type", "getClass", "isInstance", "type", "getClass", "type", "equals", "schema", "validate", "validateValue", "valueSchema", "entrySet", "validateValue", "keySchema", "getKey", "validateValue", "valueSchema", "getValue"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}