{"test_class": {"identifier": "TermBasedIndexTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final String indexTableName = \"termIndex\";", "modifier": "private final", "type": "String", "declarator": "indexTableName = \"termIndex\"", "var_name": "indexTableName"}, {"original_string": "private final String rowId = \"rowId\";", "modifier": "private final", "type": "String", "declarator": "rowId = \"rowId\"", "var_name": "rowId"}, {"original_string": "private final byte[] rowIdBytes = rowId.getBytes();", "modifier": "private final", "type": "byte[]", "declarator": "rowIdBytes = rowId.getBytes()", "var_name": "rowIdBytes"}, {"original_string": "private final String colFam1 = \"colFam_1\";", "modifier": "private final", "type": "String", "declarator": "colFam1 = \"colFam_1\"", "var_name": "colFam1"}, {"original_string": "private final String colQual1 = \"colQual_1\";", "modifier": "private final", "type": "String", "declarator": "colQual1 = \"colQual_1\"", "var_name": "colQual1"}, {"original_string": "private final String value1 = \"Steve vituperated Rodney\";", "modifier": "private final", "type": "String", "declarator": "value1 = \"Steve vituperated Rodney\"", "var_name": "value1"}, {"original_string": "private TermBasedIndex termIndex;", "modifier": "private", "type": "TermBasedIndex", "declarator": "termIndex", "var_name": "termIndex"}, {"original_string": "private Configuration conf;", "modifier": "private", "type": "Configuration", "declarator": "conf", "var_name": "conf"}], "file": "culvert-main/src/test/java/com/bah/culvert/data/index/TermBasedIndexTest.java"}, "test_case": {"identifier": "testGetSteve", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testGetSteve() {\n    // Get steve back\n    byte[] steveBytes = \"steve\".getBytes();\n\n    // The end byte object should look like: steve\\x01\n    // This represents the next possible value which is allowable\n    // since we pad the value with 6 null bytes.\n    byte[] end = new byte[steveBytes.length + 1];\n    System.arraycopy(steveBytes, 0, end, 0, steveBytes.length);\n    end[end.length - 1] = 0x01;\n\n    SeekingCurrentIterator indexIterator = termIndex.handleGet(steveBytes, end);\n\n    // Test the returned data\n    int count = 0;\n    while (indexIterator.hasNext()) {\n      Result result = indexIterator.next();\n      count++;\n\n      assertTrue(Bytes.compareTo(result.getRecordId(), rowIdBytes) == 0);\n    }\n\n    // Test if we have the expected number of results\n    assertTrue(count == 1);\n  }", "signature": "void testGetSteve()", "full_signature": "@Test public void testGetSteve()", "class_method_signature": "TermBasedIndexTest.testGetSteve()", "testcase": true, "constructor": false, "invocations": ["getBytes", "arraycopy", "handleGet", "hasNext", "next", "assertTrue", "compareTo", "getRecordId", "assertTrue"]}, "focal_class": {"identifier": "TermBasedIndex", "superclass": "extends Index", "interfaces": "", "fields": [{"original_string": "private static final Log LOG = LogFactory.getLog(TermBasedIndex.class);", "modifier": "private static final", "type": "Log", "declarator": "LOG = LogFactory.getLog(TermBasedIndex.class)", "var_name": "LOG"}, {"original_string": "private static final String TOKEN_REGEX_KEY = \"culvert.index.term.token\";", "modifier": "private static final", "type": "String", "declarator": "TOKEN_REGEX_KEY = \"culvert.index.term.token\"", "var_name": "TOKEN_REGEX_KEY"}, {"original_string": "private static final String SPLITABLE_TERM_KEY = \"culvert.index.term.splitable\";", "modifier": "private static final", "type": "String", "declarator": "SPLITABLE_TERM_KEY = \"culvert.index.term.splitable\"", "var_name": "SPLITABLE_TERM_KEY"}, {"original_string": "private static final String TO_LOWER_KEY = \"culvert.index.term.lower\";", "modifier": "private static final", "type": "String", "declarator": "TO_LOWER_KEY = \"culvert.index.term.lower\"", "var_name": "TO_LOWER_KEY"}, {"original_string": "public static final String DEFAULT_TOKEN_REGEX = \"[^A-Za-z0-9]+\";", "modifier": "public static final", "type": "String", "declarator": "DEFAULT_TOKEN_REGEX = \"[^A-Za-z0-9]+\"", "var_name": "DEFAULT_TOKEN_REGEX"}, {"original_string": "private static final boolean DEFAULT_IS_SPLITABLE = true;", "modifier": "private static final", "type": "boolean", "declarator": "DEFAULT_IS_SPLITABLE = true", "var_name": "DEFAULT_IS_SPLITABLE"}, {"original_string": "private static final boolean DEFAULT_IS_LOWER_CASED = true;", "modifier": "private static final", "type": "boolean", "declarator": "DEFAULT_IS_LOWER_CASED = true", "var_name": "DEFAULT_IS_LOWER_CASED"}, {"original_string": "public static final int NUM_RECORD_ID_LENGTH_BYTES = 4;", "modifier": "public static final", "type": "int", "declarator": "NUM_RECORD_ID_LENGTH_BYTES = 4", "var_name": "NUM_RECORD_ID_LENGTH_BYTES"}, {"original_string": "public static final int NUM_NULL_BYTES = 6;", "modifier": "public static final", "type": "int", "declarator": "NUM_NULL_BYTES = 6", "var_name": "NUM_NULL_BYTES"}, {"original_string": "public static final byte[] NULL_BYTES_PADDING = new byte[NUM_NULL_BYTES];", "modifier": "public static final", "type": "byte[]", "declarator": "NULL_BYTES_PADDING = new byte[NUM_NULL_BYTES]", "var_name": "NULL_BYTES_PADDING"}], "methods": [{"identifier": "TermBasedIndex", "parameters": "()", "modifiers": "public", "return": "", "signature": " TermBasedIndex()", "full_signature": "public  TermBasedIndex()", "class_method_signature": "TermBasedIndex.TermBasedIndex()", "testcase": false, "constructor": true}, {"identifier": "TermBasedIndex", "parameters": "(String name, DatabaseAdapter database,\n      String primaryTable, String indexTable, byte[] columnFamily,\n      byte[] columnQualifier)", "modifiers": "public", "return": "", "signature": " TermBasedIndex(String name, DatabaseAdapter database,\n      String primaryTable, String indexTable, byte[] columnFamily,\n      byte[] columnQualifier)", "full_signature": "public  TermBasedIndex(String name, DatabaseAdapter database,\n      String primaryTable, String indexTable, byte[] columnFamily,\n      byte[] columnQualifier)", "class_method_signature": "TermBasedIndex.TermBasedIndex(String name, DatabaseAdapter database,\n      String primaryTable, String indexTable, byte[] columnFamily,\n      byte[] columnQualifier)", "testcase": false, "constructor": true}, {"identifier": "TermBasedIndex", "parameters": "(String name, DatabaseAdapter database,\n      Configuration databaseConf, String primaryTable, String indexTable,\n      byte[] columnFamily, byte[] columnQualifier, boolean isSplittable,\n      String regex)", "modifiers": "public", "return": "", "signature": " TermBasedIndex(String name, DatabaseAdapter database,\n      Configuration databaseConf, String primaryTable, String indexTable,\n      byte[] columnFamily, byte[] columnQualifier, boolean isSplittable,\n      String regex)", "full_signature": "public  TermBasedIndex(String name, DatabaseAdapter database,\n      Configuration databaseConf, String primaryTable, String indexTable,\n      byte[] columnFamily, byte[] columnQualifier, boolean isSplittable,\n      String regex)", "class_method_signature": "TermBasedIndex.TermBasedIndex(String name, DatabaseAdapter database,\n      Configuration databaseConf, String primaryTable, String indexTable,\n      byte[] columnFamily, byte[] columnQualifier, boolean isSplittable,\n      String regex)", "testcase": false, "constructor": true}, {"identifier": "setTokenRegex", "parameters": "(String regex, Configuration conf)", "modifiers": "public static", "return": "void", "signature": "void setTokenRegex(String regex, Configuration conf)", "full_signature": "public static void setTokenRegex(String regex, Configuration conf)", "class_method_signature": "TermBasedIndex.setTokenRegex(String regex, Configuration conf)", "testcase": false, "constructor": false}, {"identifier": "setSplitable", "parameters": "(boolean isSplitable, Configuration conf)", "modifiers": "public static", "return": "void", "signature": "void setSplitable(boolean isSplitable, Configuration conf)", "full_signature": "public static void setSplitable(boolean isSplitable, Configuration conf)", "class_method_signature": "TermBasedIndex.setSplitable(boolean isSplitable, Configuration conf)", "testcase": false, "constructor": false}, {"identifier": "setToLower", "parameters": "(boolean isLowerable, Configuration conf)", "modifiers": "public static", "return": "void", "signature": "void setToLower(boolean isLowerable, Configuration conf)", "full_signature": "public static void setToLower(boolean isLowerable, Configuration conf)", "class_method_signature": "TermBasedIndex.setToLower(boolean isLowerable, Configuration conf)", "testcase": false, "constructor": false}, {"identifier": "getTokenRegex", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getTokenRegex()", "full_signature": "public String getTokenRegex()", "class_method_signature": "TermBasedIndex.getTokenRegex()", "testcase": false, "constructor": false}, {"identifier": "getSplitable", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean getSplitable()", "full_signature": "public boolean getSplitable()", "class_method_signature": "TermBasedIndex.getSplitable()", "testcase": false, "constructor": false}, {"identifier": "getToLower", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean getToLower()", "full_signature": "public boolean getToLower()", "class_method_signature": "TermBasedIndex.getToLower()", "testcase": false, "constructor": false}, {"identifier": "handlePut", "parameters": "(Put put)", "modifiers": "@Override public", "return": "void", "signature": "void handlePut(Put put)", "full_signature": "@Override public void handlePut(Put put)", "class_method_signature": "TermBasedIndex.handlePut(Put put)", "testcase": false, "constructor": false}, {"identifier": "handleGet", "parameters": "(byte[] indexRangeStart,\n      byte[] indexRangeEnd)", "modifiers": "@Override public", "return": "SeekingCurrentIterator", "signature": "SeekingCurrentIterator handleGet(byte[] indexRangeStart,\n      byte[] indexRangeEnd)", "full_signature": "@Override public SeekingCurrentIterator handleGet(byte[] indexRangeStart,\n      byte[] indexRangeEnd)", "class_method_signature": "TermBasedIndex.handleGet(byte[] indexRangeStart,\n      byte[] indexRangeEnd)", "testcase": false, "constructor": false}, {"identifier": "createTermList", "parameters": "(CKeyValue keyValue)", "modifiers": "private", "return": "List<CKeyValue>", "signature": "List<CKeyValue> createTermList(CKeyValue keyValue)", "full_signature": "private List<CKeyValue> createTermList(CKeyValue keyValue)", "class_method_signature": "TermBasedIndex.createTermList(CKeyValue keyValue)", "testcase": false, "constructor": false}, {"identifier": "createIndexRowId", "parameters": "(byte[] term, byte[] recordRowId)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] createIndexRowId(byte[] term, byte[] recordRowId)", "full_signature": "private static byte[] createIndexRowId(byte[] term, byte[] recordRowId)", "class_method_signature": "TermBasedIndex.createIndexRowId(byte[] term, byte[] recordRowId)", "testcase": false, "constructor": false}, {"identifier": "parseIndexRowGetId", "parameters": "(byte[] indexRowId)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] parseIndexRowGetId(byte[] indexRowId)", "full_signature": "private static byte[] parseIndexRowGetId(byte[] indexRowId)", "class_method_signature": "TermBasedIndex.parseIndexRowGetId(byte[] indexRowId)", "testcase": false, "constructor": false}], "file": "culvert-main/src/main/java/com/bah/culvert/data/index/TermBasedIndex.java"}, "focal_method": {"identifier": "handleGet", "parameters": "(byte[] indexRangeStart,\n      byte[] indexRangeEnd)", "modifiers": "@Override public", "return": "SeekingCurrentIterator", "body": "@Override\n  public SeekingCurrentIterator handleGet(byte[] indexRangeStart,\n      byte[] indexRangeEnd) {\n\n    // Get the table adapter for this index\n    TableAdapter indexTable = getIndexTable();\n\n    // update the end key to lookup the term properly (and inclusively)\n    byte[] end;\n    if (indexRangeEnd.length != 0) {\n      // need to increment the end so it is inclusive of the end of the range\n      end = Arrays.copyOf(indexRangeEnd, indexRangeEnd.length + 1);\n      end[end.length - 1] = 1;\n    }\n    // if it covers the entire range, then we don't need to do anything\n    else\n      end = indexRangeEnd;\n\n    // do the get\n    Get get = new Get(new CRange(indexRangeStart, end));\n    return new TermBasedIndexIterator(indexTable.get(get));\n  }", "signature": "SeekingCurrentIterator handleGet(byte[] indexRangeStart,\n      byte[] indexRangeEnd)", "full_signature": "@Override public SeekingCurrentIterator handleGet(byte[] indexRangeStart,\n      byte[] indexRangeEnd)", "class_method_signature": "TermBasedIndex.handleGet(byte[] indexRangeStart,\n      byte[] indexRangeEnd)", "testcase": false, "constructor": false, "invocations": ["getIndexTable", "copyOf", "get"]}, "repository": {"repo_id": 1973010, "url": "https://github.com/booz-allen-hamilton/culvert", "language": "Java", "is_fork": false, "fork_count": 14, "stargazer_count": 43, "size": 373, "license": "licensed"}}