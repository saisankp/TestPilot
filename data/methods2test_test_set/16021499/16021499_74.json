{"test_class": {"identifier": "AdvancedFilterValidatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private AdvancedFilterValidator validator;", "modifier": "private", "type": "AdvancedFilterValidator", "declarator": "validator", "var_name": "validator"}, {"original_string": "@Mock\n    private FilterValidator filterValidator1;", "modifier": "@Mock\n    private", "type": "FilterValidator", "declarator": "filterValidator1", "var_name": "filterValidator1"}, {"original_string": "@Mock\n    private FilterValidator filterValidator2;", "modifier": "@Mock\n    private", "type": "FilterValidator", "declarator": "filterValidator2", "var_name": "filterValidator2"}, {"original_string": "@Mock\n    private PackageProperties properties;", "modifier": "@Mock\n    private", "type": "PackageProperties", "declarator": "properties", "var_name": "properties"}, {"original_string": "@Mock\n    private WorkspaceFilter filter;", "modifier": "@Mock\n    private", "type": "WorkspaceFilter", "declarator": "filter", "var_name": "filter"}, {"original_string": "private Collection<PackageInfo> dependenciesMetaInfo;", "modifier": "private", "type": "Collection<PackageInfo>", "declarator": "dependenciesMetaInfo", "var_name": "dependenciesMetaInfo"}, {"original_string": "private Collection<String> validRoots;", "modifier": "private", "type": "Collection<String>", "declarator": "validRoots", "var_name": "validRoots"}, {"original_string": "private DocumentBuilderFactory factory;", "modifier": "private", "type": "DocumentBuilderFactory", "declarator": "factory", "var_name": "factory"}], "file": "vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidatorTest.java"}, "test_case": {"identifier": "testHasDanglingAncestors", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testHasDanglingAncestors() throws IOException, ConfigurationException {\n        DefaultWorkspaceFilter filter = new DefaultWorkspaceFilter();\n        try (InputStream input = this.getClass().getResourceAsStream(\"/test-filter.xml\")) {\n            filter.load(input);\n        }\n        validator = new AdvancedFilterValidator(\n                factory,\n                ValidationMessageSeverity.WARN,\n                AdvancedFilterValidatorFactory.DEFAULT_SEVERITY_FOR_UNCOVERED_ANCESTOR_NODES,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.ERROR,\n                false,\n                dependenciesMetaInfo,\n                filter, // this is per test\n                validRoots);\n        Assert.assertNull(validator.getDanglingAncestorNodePath(\"/var/acs-commons/on-deploy-scripts-status/README.txt\", filter));\n        Assert.assertEquals(\"/var/acs-commons/mcp\", validator.getDanglingAncestorNodePath(\"/var/acs-commons/mcp/rep:policy\", filter));\n        // https://issues.apache.org/jira/browse/JCRVLT-378\n        Assert.assertNull(validator.getDanglingAncestorNodePath(\"/var/acs-commons/on-deploy-scripts-status/rep:policy\", filter));\n        // make sure it is returned only once\n        Assert.assertNull(validator.getDanglingAncestorNodePath(\"/var/acs-commons/mcp/rep:policy/allow\", filter));\n    }", "signature": "void testHasDanglingAncestors()", "full_signature": "@Test public void testHasDanglingAncestors()", "class_method_signature": "AdvancedFilterValidatorTest.testHasDanglingAncestors()", "testcase": true, "constructor": false, "invocations": ["getResourceAsStream", "getClass", "load", "assertNull", "getDanglingAncestorNodePath", "assertEquals", "getDanglingAncestorNodePath", "assertNull", "getDanglingAncestorNodePath", "assertNull", "getDanglingAncestorNodePath"]}, "focal_class": {"identifier": "AdvancedFilterValidator", "superclass": "", "interfaces": "implements GenericMetaInfDataValidator, FilterValidator, DocumentViewXmlValidator, JcrPathValidator", "fields": [{"original_string": "protected static final String MESSAGE_ORPHANED_FILTER_ENTRIES = \"Found orphaned filter entries: %s\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_ORPHANED_FILTER_ENTRIES = \"Found orphaned filter entries: %s\"", "var_name": "MESSAGE_ORPHANED_FILTER_ENTRIES"}, {"original_string": "protected static final String MESSAGE_INVALID_PATTERN = \"Invalid pattern given ('%s') which will never match for any descendants of the root path '%s'.\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_INVALID_PATTERN = \"Invalid pattern given ('%s') which will never match for any descendants of the root path '%s'.\"", "var_name": "MESSAGE_INVALID_PATTERN"}, {"original_string": "protected static final String MESSAGE_ROOT_PATH_NOT_ABSOLUTE = \"Root path must be absolute, but does not start with a '/': '%s'.\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_ROOT_PATH_NOT_ABSOLUTE = \"Root path must be absolute, but does not start with a '/': '%s'.\"", "var_name": "MESSAGE_ROOT_PATH_NOT_ABSOLUTE"}, {"original_string": "protected static final String MESSAGE_INVALID_FILTER_XML = \"Invalid filter.xml\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_INVALID_FILTER_XML = \"Invalid filter.xml\"", "var_name": "MESSAGE_INVALID_FILTER_XML"}, {"original_string": "protected static final String MESSAGE_FILTER_ROOT_ANCESTOR_COVERED_BUT_EXCLUDED = \"Filter root's ancestor '%s' is covered by dependency '%s' but excluded by its patterns.\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_FILTER_ROOT_ANCESTOR_COVERED_BUT_EXCLUDED = \"Filter root's ancestor '%s' is covered by dependency '%s' but excluded by its patterns.\"", "var_name": "MESSAGE_FILTER_ROOT_ANCESTOR_COVERED_BUT_EXCLUDED"}, {"original_string": "protected static final String MESSAGE_FILTER_ROOT_ANCESTOR_UNCOVERED = \"Filter root's ancestor '%s' is not covered by any of the specified dependencies nor a valid root.\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_FILTER_ROOT_ANCESTOR_UNCOVERED = \"Filter root's ancestor '%s' is not covered by any of the specified dependencies nor a valid root.\"", "var_name": "MESSAGE_FILTER_ROOT_ANCESTOR_UNCOVERED"}, {"original_string": "protected static final String MESSAGE_NODE_NOT_CONTAINED = \"Node '%s' is not contained in any of the filter rules\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_NODE_NOT_CONTAINED = \"Node '%s' is not contained in any of the filter rules\"", "var_name": "MESSAGE_NODE_NOT_CONTAINED"}, {"original_string": "protected static final String MESSAGE_ANCESTOR_NODE_NOT_COVERED = \"Ancestor node '%s' is not covered by any of the filter rules. Preferably depend on a package that provides this node or include it in the filter rules!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_ANCESTOR_NODE_NOT_COVERED = \"Ancestor node '%s' is not covered by any of the filter rules. Preferably depend on a package that provides this node or include it in the filter rules!\"", "var_name": "MESSAGE_ANCESTOR_NODE_NOT_COVERED"}, {"original_string": "protected static final String MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT = \"Ancestor node '%s' is not covered by any of the filter rules but that node is a given root (either by a dependency or by the known roots). Remove that node!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT = \"Ancestor node '%s' is not covered by any of the filter rules but that node is a given root (either by a dependency or by the known roots). Remove that node!\"", "var_name": "MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT"}, {"original_string": "protected static final String MESSAGE_NODE_BELOW_CLEANUP_FILTER = \"Node '%s' is covered by a 'cleanup' filter rule. That filter type is only supposed to be used for removing nodes during import!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_NODE_BELOW_CLEANUP_FILTER = \"Node '%s' is covered by a 'cleanup' filter rule. That filter type is only supposed to be used for removing nodes during import!\"", "var_name": "MESSAGE_NODE_BELOW_CLEANUP_FILTER"}, {"original_string": "static final Path FILTER_XML_PATH = Paths.get(Constants.VAULT_DIR, Constants.FILTER_XML);", "modifier": "static final", "type": "Path", "declarator": "FILTER_XML_PATH = Paths.get(Constants.VAULT_DIR, Constants.FILTER_XML)", "var_name": "FILTER_XML_PATH"}, {"original_string": "private final DocumentBuilderFactory factory;", "modifier": "private final", "type": "DocumentBuilderFactory", "declarator": "factory", "var_name": "factory"}, {"original_string": "private final boolean isSubPackage;", "modifier": "private final", "type": "boolean", "declarator": "isSubPackage", "var_name": "isSubPackage"}, {"original_string": "private final Collection<String> validRoots;", "modifier": "private final", "type": "Collection<String>", "declarator": "validRoots", "var_name": "validRoots"}, {"original_string": "private final @NotNull ValidationMessageSeverity defaultSeverity;", "modifier": "private final @NotNull", "type": "ValidationMessageSeverity", "declarator": "defaultSeverity", "var_name": "defaultSeverity"}, {"original_string": "private final @NotNull ValidationMessageSeverity severityForUncoveredAncestorNode;", "modifier": "private final @NotNull", "type": "ValidationMessageSeverity", "declarator": "severityForUncoveredAncestorNode", "var_name": "severityForUncoveredAncestorNode"}, {"original_string": "private final @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors;", "modifier": "private final @NotNull", "type": "ValidationMessageSeverity", "declarator": "severityForUncoveredFilterRootAncestors", "var_name": "severityForUncoveredFilterRootAncestors"}, {"original_string": "private final @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries;", "modifier": "private final @NotNull", "type": "ValidationMessageSeverity", "declarator": "severityForOrphanedFilterEntries", "var_name": "severityForOrphanedFilterEntries"}, {"original_string": "private final Collection<PackageInfo> dependenciesMetaInfo;", "modifier": "private final", "type": "Collection<PackageInfo>", "declarator": "dependenciesMetaInfo", "var_name": "dependenciesMetaInfo"}, {"original_string": "private final WorkspaceFilter filter;", "modifier": "private final", "type": "WorkspaceFilter", "declarator": "filter", "var_name": "filter"}, {"original_string": "private Map<String, FilterValidator> filterValidators;", "modifier": "private", "type": "Map<String, FilterValidator>", "declarator": "filterValidators", "var_name": "filterValidators"}, {"original_string": "private final Collection<String> danglingNodePaths;", "modifier": "private final", "type": "Collection<String>", "declarator": "danglingNodePaths", "var_name": "danglingNodePaths"}, {"original_string": "private final Map<PathFilterSet, List<Entry<PathFilter>>> orphanedFilterSets;", "modifier": "private final", "type": "Map<PathFilterSet, List<Entry<PathFilter>>>", "declarator": "orphanedFilterSets", "var_name": "orphanedFilterSets"}], "methods": [{"identifier": "AdvancedFilterValidator", "parameters": "(@NotNull DocumentBuilderFactory factory, @NotNull ValidationMessageSeverity defaultSeverity, @NotNull ValidationMessageSeverity severityForUncoveredAncestorNodes, @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors, @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries, boolean isSubPackage, @NotNull Collection<PackageInfo> dependenciesMetaInfo, @NotNull WorkspaceFilter filter, @NotNull Collection<String> validRoots)", "modifiers": "public", "return": "", "signature": " AdvancedFilterValidator(@NotNull DocumentBuilderFactory factory, @NotNull ValidationMessageSeverity defaultSeverity, @NotNull ValidationMessageSeverity severityForUncoveredAncestorNodes, @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors, @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries, boolean isSubPackage, @NotNull Collection<PackageInfo> dependenciesMetaInfo, @NotNull WorkspaceFilter filter, @NotNull Collection<String> validRoots)", "full_signature": "public  AdvancedFilterValidator(@NotNull DocumentBuilderFactory factory, @NotNull ValidationMessageSeverity defaultSeverity, @NotNull ValidationMessageSeverity severityForUncoveredAncestorNodes, @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors, @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries, boolean isSubPackage, @NotNull Collection<PackageInfo> dependenciesMetaInfo, @NotNull WorkspaceFilter filter, @NotNull Collection<String> validRoots)", "class_method_signature": "AdvancedFilterValidator.AdvancedFilterValidator(@NotNull DocumentBuilderFactory factory, @NotNull ValidationMessageSeverity defaultSeverity, @NotNull ValidationMessageSeverity severityForUncoveredAncestorNodes, @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors, @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries, boolean isSubPackage, @NotNull Collection<PackageInfo> dependenciesMetaInfo, @NotNull WorkspaceFilter filter, @NotNull Collection<String> validRoots)", "testcase": false, "constructor": true}, {"identifier": "setFilterValidators", "parameters": "(Map<String, FilterValidator> filterValidators)", "modifiers": "public", "return": "void", "signature": "void setFilterValidators(Map<String, FilterValidator> filterValidators)", "full_signature": "public void setFilterValidators(Map<String, FilterValidator> filterValidators)", "class_method_signature": "AdvancedFilterValidator.setFilterValidators(Map<String, FilterValidator> filterValidators)", "testcase": false, "constructor": false}, {"identifier": "done", "parameters": "()", "modifiers": "@Override public", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> done()", "full_signature": "@Override public Collection<ValidationMessage> done()", "class_method_signature": "AdvancedFilterValidator.done()", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(@NotNull WorkspaceFilter filter)", "modifiers": "@Override public", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validate(@NotNull WorkspaceFilter filter)", "full_signature": "@Override public Collection<ValidationMessage> validate(@NotNull WorkspaceFilter filter)", "class_method_signature": "AdvancedFilterValidator.validate(@NotNull WorkspaceFilter filter)", "testcase": false, "constructor": false}, {"identifier": "validatePathFilterSets", "parameters": "(Collection<PathFilterSet> pathFilterSets, boolean checkRoots)", "modifiers": "private", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validatePathFilterSets(Collection<PathFilterSet> pathFilterSets, boolean checkRoots)", "full_signature": "private Collection<ValidationMessage> validatePathFilterSets(Collection<PathFilterSet> pathFilterSets, boolean checkRoots)", "class_method_signature": "AdvancedFilterValidator.validatePathFilterSets(Collection<PathFilterSet> pathFilterSets, boolean checkRoots)", "testcase": false, "constructor": false}, {"identifier": "validateFileNodePath", "parameters": "(@NotNull String nodePath)", "modifiers": "private", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validateFileNodePath(@NotNull String nodePath)", "full_signature": "private Collection<ValidationMessage> validateFileNodePath(@NotNull String nodePath)", "class_method_signature": "AdvancedFilterValidator.validateFileNodePath(@NotNull String nodePath)", "testcase": false, "constructor": false}, {"identifier": "validateJcrPath", "parameters": "(@NotNull NodeContext nodeContext,\n            boolean isFolder)", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext,\n            boolean isFolder)", "full_signature": "@Override public @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext,\n            boolean isFolder)", "class_method_signature": "AdvancedFilterValidator.validateJcrPath(@NotNull NodeContext nodeContext,\n            boolean isFolder)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "full_signature": "@Override public @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "class_method_signature": "AdvancedFilterValidator.validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "testcase": false, "constructor": false}, {"identifier": "isRegexValidForRootPath", "parameters": "(String regex, String rootPath)", "modifiers": "static", "return": "boolean", "signature": "boolean isRegexValidForRootPath(String regex, String rootPath)", "full_signature": "static boolean isRegexValidForRootPath(String regex, String rootPath)", "class_method_signature": "AdvancedFilterValidator.isRegexValidForRootPath(String regex, String rootPath)", "testcase": false, "constructor": false}, {"identifier": "validateMetaInfData", "parameters": "(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "modifiers": "@Override public", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "full_signature": "@Override public Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "class_method_signature": "AdvancedFilterValidator.validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "testcase": false, "constructor": false}, {"identifier": "shouldValidateMetaInfData", "parameters": "(@NotNull Path filePath)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean shouldValidateMetaInfData(@NotNull Path filePath)", "full_signature": "@Override public boolean shouldValidateMetaInfData(@NotNull Path filePath)", "class_method_signature": "AdvancedFilterValidator.shouldValidateMetaInfData(@NotNull Path filePath)", "testcase": false, "constructor": false}, {"identifier": "removeFromOrphanedFilterEntries", "parameters": "(@NotNull String nodePath)", "modifiers": "private", "return": "void", "signature": "void removeFromOrphanedFilterEntries(@NotNull String nodePath)", "full_signature": "private void removeFromOrphanedFilterEntries(@NotNull String nodePath)", "class_method_signature": "AdvancedFilterValidator.removeFromOrphanedFilterEntries(@NotNull String nodePath)", "testcase": false, "constructor": false}, {"identifier": "getDanglingAncestorNodePath", "parameters": "(String nodePath, WorkspaceFilter filter)", "modifiers": "@Nullable", "return": "String", "signature": "String getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter)", "full_signature": "@Nullable String getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter)", "class_method_signature": "AdvancedFilterValidator.getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter)", "testcase": false, "constructor": false}], "file": "vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java"}, "focal_method": {"identifier": "getDanglingAncestorNodePath", "parameters": "(String nodePath, WorkspaceFilter filter)", "modifiers": "@Nullable", "return": "String", "body": "@Nullable String getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter) {\n        // check cache first (in that case the issue has already been emitted)\n        if (danglingNodePaths.contains(nodePath)) {\n            return null;\n        }\n        // check that all ancestor nodes till the filter root node are contained as well\n        for (PathFilterSet pathFilterSet : filter.getFilterSets()) {\n            if (pathFilterSet.contains(nodePath)) {\n                String parentNodePath = Text.getRelativeParent(nodePath, 1);\n                // make sure that all ancestors till the root node are contained as well\n                if (!nodePath.equals(pathFilterSet.getRoot()) && !parentNodePath.equals(pathFilterSet.getRoot())) {\n                    // ancestor might also be contained in another filter\n                    return getDanglingAncestorNodePath(parentNodePath, filter);\n                } else {\n                    // once the root level is reached this node path is contained\n                    return null;\n                }\n            } \n        }\n        danglingNodePaths.add(nodePath);\n        return nodePath;\n    }", "signature": "String getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter)", "full_signature": "@Nullable String getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter)", "class_method_signature": "AdvancedFilterValidator.getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter)", "testcase": false, "constructor": false, "invocations": ["contains", "getFilterSets", "contains", "getRelativeParent", "equals", "getRoot", "equals", "getRoot", "getDanglingAncestorNodePath", "add"]}, "repository": {"repo_id": 16021499, "url": "https://github.com/apache/jackrabbit-filevault", "stars": 24, "created": "1/18/2014 8:00:07 AM +00:00", "updates": "2020-01-22T11:47:21+00:00", "fork": "False", "license": "licensed"}}