{"test_class": {"identifier": "BlockChainTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n    public ExpectedException thrown = ExpectedException.none();", "modifier": "@Rule\n    public", "type": "ExpectedException", "declarator": "thrown = ExpectedException.none()", "var_name": "thrown"}, {"original_string": "private BlockChain testNetChain;", "modifier": "private", "type": "BlockChain", "declarator": "testNetChain", "var_name": "testNetChain"}, {"original_string": "private Wallet wallet;", "modifier": "private", "type": "Wallet", "declarator": "wallet", "var_name": "wallet"}, {"original_string": "private BlockChain chain;", "modifier": "private", "type": "BlockChain", "declarator": "chain", "var_name": "chain"}, {"original_string": "private BlockStore blockStore;", "modifier": "private", "type": "BlockStore", "declarator": "blockStore", "var_name": "blockStore"}, {"original_string": "private Address coinbaseTo;", "modifier": "private", "type": "Address", "declarator": "coinbaseTo", "var_name": "coinbaseTo"}, {"original_string": "private final StoredBlock[] block = new StoredBlock[1];", "modifier": "private final", "type": "StoredBlock[]", "declarator": "block = new StoredBlock[1]", "var_name": "block"}, {"original_string": "private Transaction coinbaseTransaction;", "modifier": "private", "type": "Transaction", "declarator": "coinbaseTransaction", "var_name": "coinbaseTransaction"}, {"original_string": "private static final TweakableTestNet3Params TESTNET = new TweakableTestNet3Params();", "modifier": "private static final", "type": "TweakableTestNet3Params", "declarator": "TESTNET = new TweakableTestNet3Params()", "var_name": "TESTNET"}, {"original_string": "private static final NetworkParameters UNITTEST = UnitTestParams.get();", "modifier": "private static final", "type": "NetworkParameters", "declarator": "UNITTEST = UnitTestParams.get()", "var_name": "UNITTEST"}, {"original_string": "private static final NetworkParameters MAINNET = MainNetParams.get();", "modifier": "private static final", "type": "NetworkParameters", "declarator": "MAINNET = MainNetParams.get()", "var_name": "MAINNET"}], "file": "core/src/test/java/org/ulordj/core/BlockChainTest.java"}, "test_case": {"identifier": "coinbaseTransactionAvailability", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void coinbaseTransactionAvailability() throws Exception {\n        // Check that a coinbase transaction is only available to spend after NetworkParameters.getSpendableCoinbaseDepth() blocks.\n\n        // Create a second wallet to receive the coinbase spend.\n        Wallet wallet2 = new Wallet(UNITTEST);\n        ECKey receiveKey = wallet2.freshReceiveKey();\n        int height = 1;\n        chain.addWallet(wallet2);\n\n        Address addressToSendTo = LegacyAddress.fromKey(UNITTEST, receiveKey);\n\n        // Create a block, sending the coinbase to the coinbaseTo address (which is in the wallet).\n        Block b1 = UNITTEST.getGenesisBlock().createNextBlockWithCoinbase(Block.BLOCK_VERSION_GENESIS, wallet.currentReceiveKey().getPubKey(), height++);\n        chain.add(b1);\n\n        // Check a transaction has been received.\n        assertNotNull(coinbaseTransaction);\n\n        // The coinbase tx is not yet available to spend.\n        assertEquals(Coin.ZERO, wallet.getBalance());\n        assertEquals(wallet.getBalance(BalanceType.ESTIMATED), ONE_COIN);\n        assertTrue(!coinbaseTransaction.isMature());\n\n        // Attempt to spend the coinbase - this should fail as the coinbase is not mature yet.\n        try {\n            wallet.createSend(addressToSendTo, valueOf(49, 0));\n            fail();\n        } catch (InsufficientMoneyException e) {\n        }\n\n        // Check that the coinbase is unavailable to spend for the next spendableCoinbaseDepth - 2 blocks.\n        for (int i = 0; i < UNITTEST.getSpendableCoinbaseDepth() - 2; i++) {\n            // Non relevant tx - just for fake block creation.\n            Transaction tx2 = createFakeTx(UNITTEST, COIN, LegacyAddress.fromKey(UNITTEST, new ECKey()));\n\n            Block b2 = createFakeBlock(blockStore, height++, tx2).block;\n            chain.add(b2);\n\n            // Wallet still does not have the coinbase transaction available for spend.\n            assertEquals(Coin.ZERO, wallet.getBalance());\n            assertEquals(wallet.getBalance(BalanceType.ESTIMATED), ONE_COIN);\n\n            // The coinbase transaction is still not mature.\n            assertTrue(!coinbaseTransaction.isMature());\n\n            // Attempt to spend the coinbase - this should fail.\n            try {\n                wallet.createSend(addressToSendTo, valueOf(49, 0));\n                fail();\n            } catch (InsufficientMoneyException e) {\n            }\n        }\n\n        // Give it one more block - should now be able to spend coinbase transaction. Non relevant tx.\n        Transaction tx3 = createFakeTx(UNITTEST, COIN, LegacyAddress.fromKey(UNITTEST, new ECKey()));\n        Block b3 = createFakeBlock(blockStore, height++, tx3).block;\n        chain.add(b3);\n\n        // Wallet now has the coinbase transaction available for spend.\n        assertEquals(wallet.getBalance(), ONE_COIN);\n        assertEquals(wallet.getBalance(BalanceType.ESTIMATED), ONE_COIN);\n        assertTrue(coinbaseTransaction.isMature());\n\n        // Create a spend with the coinbase BTC to the address in the second wallet - this should now succeed.\n        Transaction coinbaseSend2 = wallet.createSend(addressToSendTo, valueOf(49, 0));\n        assertNotNull(coinbaseSend2);\n\n        // Commit the coinbaseSpend to the first wallet and check the balances decrement.\n        wallet.commitTx(coinbaseSend2);\n        assertEquals(wallet.getBalance(BalanceType.ESTIMATED), COIN);\n        // Available balance is zero as change has not been received from a block yet.\n        assertEquals(wallet.getBalance(BalanceType.AVAILABLE), ZERO);\n\n        // Give it one more block - change from coinbaseSpend should now be available in the first wallet.\n        Block b4 = createFakeBlock(blockStore, height++, coinbaseSend2).block;\n        chain.add(b4);\n        assertEquals(wallet.getBalance(BalanceType.AVAILABLE), COIN);\n\n        // Check the balances in the second wallet.\n        assertEquals(wallet2.getBalance(BalanceType.ESTIMATED), valueOf(49, 0));\n        assertEquals(wallet2.getBalance(BalanceType.AVAILABLE), valueOf(49, 0));\n    }", "signature": "void coinbaseTransactionAvailability()", "full_signature": "@Test public void coinbaseTransactionAvailability()", "class_method_signature": "BlockChainTest.coinbaseTransactionAvailability()", "testcase": true, "constructor": false, "invocations": ["freshReceiveKey", "addWallet", "fromKey", "createNextBlockWithCoinbase", "getGenesisBlock", "getPubKey", "currentReceiveKey", "add", "assertNotNull", "assertEquals", "getBalance", "assertEquals", "getBalance", "assertTrue", "isMature", "createSend", "valueOf", "fail", "getSpendableCoinbaseDepth", "createFakeTx", "fromKey", "createFakeBlock", "add", "assertEquals", "getBalance", "assertEquals", "getBalance", "assertTrue", "isMature", "createSend", "valueOf", "fail", "createFakeTx", "fromKey", "createFakeBlock", "add", "assertEquals", "getBalance", "assertEquals", "getBalance", "assertTrue", "isMature", "createSend", "valueOf", "assertNotNull", "commitTx", "assertEquals", "getBalance", "assertEquals", "getBalance", "createFakeBlock", "add", "assertEquals", "getBalance", "assertEquals", "getBalance", "valueOf", "assertEquals", "getBalance", "valueOf"]}, "focal_class": {"identifier": "BlockChain", "superclass": "extends AbstractBlockChain", "interfaces": "", "fields": [{"original_string": "protected final BlockStore blockStore;", "modifier": "protected final", "type": "BlockStore", "declarator": "blockStore", "var_name": "blockStore"}], "methods": [{"identifier": "BlockChain", "parameters": "(Context context, Wallet wallet, BlockStore blockStore)", "modifiers": "public", "return": "", "signature": " BlockChain(Context context, Wallet wallet, BlockStore blockStore)", "full_signature": "public  BlockChain(Context context, Wallet wallet, BlockStore blockStore)", "class_method_signature": "BlockChain.BlockChain(Context context, Wallet wallet, BlockStore blockStore)", "testcase": false, "constructor": true}, {"identifier": "BlockChain", "parameters": "(NetworkParameters params, Wallet wallet, BlockStore blockStore)", "modifiers": "public", "return": "", "signature": " BlockChain(NetworkParameters params, Wallet wallet, BlockStore blockStore)", "full_signature": "public  BlockChain(NetworkParameters params, Wallet wallet, BlockStore blockStore)", "class_method_signature": "BlockChain.BlockChain(NetworkParameters params, Wallet wallet, BlockStore blockStore)", "testcase": false, "constructor": true}, {"identifier": "BlockChain", "parameters": "(Context context, BlockStore blockStore)", "modifiers": "public", "return": "", "signature": " BlockChain(Context context, BlockStore blockStore)", "full_signature": "public  BlockChain(Context context, BlockStore blockStore)", "class_method_signature": "BlockChain.BlockChain(Context context, BlockStore blockStore)", "testcase": false, "constructor": true}, {"identifier": "BlockChain", "parameters": "(NetworkParameters params, BlockStore blockStore)", "modifiers": "public", "return": "", "signature": " BlockChain(NetworkParameters params, BlockStore blockStore)", "full_signature": "public  BlockChain(NetworkParameters params, BlockStore blockStore)", "class_method_signature": "BlockChain.BlockChain(NetworkParameters params, BlockStore blockStore)", "testcase": false, "constructor": true}, {"identifier": "BlockChain", "parameters": "(Context params, List<? extends Wallet> wallets, BlockStore blockStore)", "modifiers": "public", "return": "", "signature": " BlockChain(Context params, List<? extends Wallet> wallets, BlockStore blockStore)", "full_signature": "public  BlockChain(Context params, List<? extends Wallet> wallets, BlockStore blockStore)", "class_method_signature": "BlockChain.BlockChain(Context params, List<? extends Wallet> wallets, BlockStore blockStore)", "testcase": false, "constructor": true}, {"identifier": "BlockChain", "parameters": "(NetworkParameters params, List<? extends Wallet> wallets, BlockStore blockStore)", "modifiers": "public", "return": "", "signature": " BlockChain(NetworkParameters params, List<? extends Wallet> wallets, BlockStore blockStore)", "full_signature": "public  BlockChain(NetworkParameters params, List<? extends Wallet> wallets, BlockStore blockStore)", "class_method_signature": "BlockChain.BlockChain(NetworkParameters params, List<? extends Wallet> wallets, BlockStore blockStore)", "testcase": false, "constructor": true}, {"identifier": "addToBlockStore", "parameters": "(StoredBlock storedPrev, Block blockHeader, TransactionOutputChanges txOutChanges)", "modifiers": "@Override protected", "return": "StoredBlock", "signature": "StoredBlock addToBlockStore(StoredBlock storedPrev, Block blockHeader, TransactionOutputChanges txOutChanges)", "full_signature": "@Override protected StoredBlock addToBlockStore(StoredBlock storedPrev, Block blockHeader, TransactionOutputChanges txOutChanges)", "class_method_signature": "BlockChain.addToBlockStore(StoredBlock storedPrev, Block blockHeader, TransactionOutputChanges txOutChanges)", "testcase": false, "constructor": false}, {"identifier": "addToBlockStore", "parameters": "(StoredBlock storedPrev, Block blockHeader)", "modifiers": "@Override protected", "return": "StoredBlock", "signature": "StoredBlock addToBlockStore(StoredBlock storedPrev, Block blockHeader)", "full_signature": "@Override protected StoredBlock addToBlockStore(StoredBlock storedPrev, Block blockHeader)", "class_method_signature": "BlockChain.addToBlockStore(StoredBlock storedPrev, Block blockHeader)", "testcase": false, "constructor": false}, {"identifier": "rollbackBlockStore", "parameters": "(int height)", "modifiers": "@Override protected", "return": "void", "signature": "void rollbackBlockStore(int height)", "full_signature": "@Override protected void rollbackBlockStore(int height)", "class_method_signature": "BlockChain.rollbackBlockStore(int height)", "testcase": false, "constructor": false}, {"identifier": "shouldVerifyTransactions", "parameters": "()", "modifiers": "@Override protected", "return": "boolean", "signature": "boolean shouldVerifyTransactions()", "full_signature": "@Override protected boolean shouldVerifyTransactions()", "class_method_signature": "BlockChain.shouldVerifyTransactions()", "testcase": false, "constructor": false}, {"identifier": "connectTransactions", "parameters": "(int height, Block block)", "modifiers": "@Override protected", "return": "TransactionOutputChanges", "signature": "TransactionOutputChanges connectTransactions(int height, Block block)", "full_signature": "@Override protected TransactionOutputChanges connectTransactions(int height, Block block)", "class_method_signature": "BlockChain.connectTransactions(int height, Block block)", "testcase": false, "constructor": false}, {"identifier": "connectTransactions", "parameters": "(StoredBlock newBlock)", "modifiers": "@Override protected", "return": "TransactionOutputChanges", "signature": "TransactionOutputChanges connectTransactions(StoredBlock newBlock)", "full_signature": "@Override protected TransactionOutputChanges connectTransactions(StoredBlock newBlock)", "class_method_signature": "BlockChain.connectTransactions(StoredBlock newBlock)", "testcase": false, "constructor": false}, {"identifier": "disconnectTransactions", "parameters": "(StoredBlock block)", "modifiers": "@Override protected", "return": "void", "signature": "void disconnectTransactions(StoredBlock block)", "full_signature": "@Override protected void disconnectTransactions(StoredBlock block)", "class_method_signature": "BlockChain.disconnectTransactions(StoredBlock block)", "testcase": false, "constructor": false}, {"identifier": "doSetChainHead", "parameters": "(StoredBlock chainHead)", "modifiers": "@Override protected", "return": "void", "signature": "void doSetChainHead(StoredBlock chainHead)", "full_signature": "@Override protected void doSetChainHead(StoredBlock chainHead)", "class_method_signature": "BlockChain.doSetChainHead(StoredBlock chainHead)", "testcase": false, "constructor": false}, {"identifier": "notSettingChainHead", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void notSettingChainHead()", "full_signature": "@Override protected void notSettingChainHead()", "class_method_signature": "BlockChain.notSettingChainHead()", "testcase": false, "constructor": false}, {"identifier": "getStoredBlockInCurrentScope", "parameters": "(Sha256Hash hash)", "modifiers": "@Override protected", "return": "StoredBlock", "signature": "StoredBlock getStoredBlockInCurrentScope(Sha256Hash hash)", "full_signature": "@Override protected StoredBlock getStoredBlockInCurrentScope(Sha256Hash hash)", "class_method_signature": "BlockChain.getStoredBlockInCurrentScope(Sha256Hash hash)", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(FilteredBlock block)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean add(FilteredBlock block)", "full_signature": "@Override public boolean add(FilteredBlock block)", "class_method_signature": "BlockChain.add(FilteredBlock block)", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/ulordj/core/BlockChain.java"}, "focal_method": {"identifier": "add", "parameters": "(FilteredBlock block)", "modifiers": "@Override public", "return": "boolean", "body": "@Override\n    public boolean add(FilteredBlock block) throws VerificationException, PrunedException {\n        boolean success = super.add(block);\n        if (success) {\n            trackFilteredTransactions(block.getTransactionCount());\n        }\n        return success;\n    }", "signature": "boolean add(FilteredBlock block)", "full_signature": "@Override public boolean add(FilteredBlock block)", "class_method_signature": "BlockChain.add(FilteredBlock block)", "testcase": false, "constructor": false, "invocations": ["add", "trackFilteredTransactions", "getTransactionCount"]}, "repository": {"repo_id": 133357466, "url": "https://github.com/UlordChain/ulordj", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 23, "size": 7129, "license": "licensed"}}