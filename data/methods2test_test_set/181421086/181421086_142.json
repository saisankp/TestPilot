{"test_class": {"identifier": "ACLTest", "superclass": "extends FloodlightTestCase", "interfaces": "", "fields": [{"original_string": "protected FloodlightContext cntx;", "modifier": "protected", "type": "FloodlightContext", "declarator": "cntx", "var_name": "cntx"}, {"original_string": "protected IOFSwitch sw;", "modifier": "protected", "type": "IOFSwitch", "declarator": "sw", "var_name": "sw"}, {"original_string": "private MockDebugEventService debugEventService;", "modifier": "private", "type": "MockDebugEventService", "declarator": "debugEventService", "var_name": "debugEventService"}, {"original_string": "private DefaultEntityClassifier entityClassifier;", "modifier": "private", "type": "DefaultEntityClassifier", "declarator": "entityClassifier", "var_name": "entityClassifier"}, {"original_string": "private MockThreadPoolService tps;", "modifier": "private", "type": "MockThreadPoolService", "declarator": "tps", "var_name": "tps"}, {"original_string": "private ITopologyService topology;", "modifier": "private", "type": "ITopologyService", "declarator": "topology", "var_name": "topology"}, {"original_string": "private MockDeviceManager deviceManager;", "modifier": "private", "type": "MockDeviceManager", "declarator": "deviceManager", "var_name": "deviceManager"}, {"original_string": "private MockDebugCounterService debugCounterService;", "modifier": "private", "type": "MockDebugCounterService", "declarator": "debugCounterService", "var_name": "debugCounterService"}, {"original_string": "private MemoryStorageSource storageService;", "modifier": "private", "type": "MemoryStorageSource", "declarator": "storageService", "var_name": "storageService"}, {"original_string": "private RestApiServer restApi;", "modifier": "private", "type": "RestApiServer", "declarator": "restApi", "var_name": "restApi"}, {"original_string": "private ACL acl;", "modifier": "private", "type": "ACL", "declarator": "acl", "var_name": "acl"}, {"original_string": "public static String TestSwitch1DPID = \"00:00:00:00:00:00:00:01\";", "modifier": "public static", "type": "String", "declarator": "TestSwitch1DPID = \"00:00:00:00:00:00:00:01\"", "var_name": "TestSwitch1DPID"}], "file": "src/agents/apps/floodlight/floodlight-1.2/src/test/java/net/floodlightcontroller/accesscontrollist/ACLTest.java"}, "test_case": {"identifier": "testDeviceAdded", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testDeviceAdded() {\n\t\t\n\t\treset(topology);\n\t\texpect(topology.isAttachmentPointPort(DatapathId.of(1L), OFPort.of(1))).andReturn(true).anyTimes();\n\t\texpect(topology.isAttachmentPointPort(DatapathId.of(1L), OFPort.of(2))).andReturn(true).anyTimes();\n\t\texpect(topology.isAttachmentPointPort(DatapathId.of(2L), OFPort.of(1))).andReturn(true).anyTimes();\n\t\texpect(topology.isAttachmentPointPort(DatapathId.of(2L), OFPort.of(2))).andReturn(true).anyTimes();\n\t\treplay(topology);\n\t\t\n\t\tint[] cidr = new int[2];\n\t\tACLRule rule1, rule2;\n\t\tIResultSet resultSet;\n\t\tIterator<IResultSet> it;\n\t\tMap<String, Object> row;\n\n\t\t// rule1 indicates host(10.0.0.0/28) can not access TCP port 80 in host(10.0.0.254/32)\n\t\trule1 = new ACLRule();\n\t\trule1.setNw_src(\"10.0.0.0/28\");\n\t\tcidr = IPAddressUtil.parseCIDR(\"10.0.0.0/28\");\n\t\trule1.setNw_src_prefix(cidr[0]);\n\t\trule1.setNw_src_maskbits(cidr[1]);\n\t\trule1.setNw_dst(\"10.0.0.254/32\");\n\t\tcidr = IPAddressUtil.parseCIDR(\"10.0.0.254/32\");\n\t\trule1.setNw_dst_prefix(cidr[0]);\n\t\trule1.setNw_dst_maskbits(cidr[1]);\n\t\trule1.setNw_proto(6);\n\t\trule1.setTp_dst(80);\n\t\trule1.setAction(Action.DENY);\n\n\t\tassertEquals(acl.addRule(rule1), true);\n\t\tassertEquals(acl.getRules().size(), 1);\n\t\t\n\t\t// a new AP[dpid:00:00:00:00:00:00:00:01 port:1 ip:10.0.0.1] appears\n\t\tdeviceManager.learnEntity(MacAddress.of(\"00:00:00:00:00:01\"),\n\t\t\t\tVlanVid.ZERO, IPv4Address.of(\"10.0.0.1\"), IPv6Address.NONE, DatapathId.of(1), OFPort.of(1));\n\t\t\n\t\tresultSet = storageService.getRow(\n\t\t\t\tStaticFlowEntryPusher.TABLE_NAME, \"ACLRule_1_00:00:00:00:00:00:00:01\");\n\t\tit = resultSet.iterator();\n\t\twhile(it.hasNext()){\n\t\t\trow = it.next().getRow();\n\t\t\tassertEquals(row.get(\"switch\").toString(),\"00:00:00:00:00:00:00:01\");\n\t\t\tassertEquals(row.get(\"priority\").toString(),\"30000\");\n\t\t\tassertEquals(row.get(\"eth_type\").toString(),\"2048\");\n\t\t\tassertEquals(row.get(\"ipv4_src\").toString(),\"10.0.0.0/28\");\n\t\t\tassertEquals(row.get(\"ipv4_dst\").toString(),\"10.0.0.254/32\");\n\t\t\tassertEquals(row.get(\"ip_proto\").toString(),\"6\");\n\t\t\tassertEquals(row.get(\"tp_dst\").toString(),\"80\");\n\t\t\tassertEquals(row.get(\"actions\"), null);\n\t\t}\n\t\t\n\t\t// a new AP[dpid:00:00:00:00:00:00:00:01 port:2 ip:10.0.0.2] appears\n\t\tdeviceManager.learnEntity(MacAddress.of(\"00:00:00:00:00:02\"),\n\t\t\t\tVlanVid.ZERO, IPv4Address.of(\"10.0.0.2\"), IPv6Address.NONE, DatapathId.of(1), OFPort.of(2));\n\t\t\n\t\tresultSet = storageService.getRow(\n\t\t\t\tStaticFlowEntryPusher.TABLE_NAME, \"ACLRule_1_00:00:00:00:00:00:00:01\");\n\t\tit = resultSet.iterator();\n\t\tint count = 0;\n\t\twhile(it.hasNext()){\n\t\t\trow = it.next().getRow();\n\t\t\tcount++;\n\t\t}\n\t\t// there is no extra flow entry added\n\t\tassertEquals(count, 1);\n\t\t\n\t\t// rule2 indicates that no ICMP packets can reach host[10.0.0.3/32]\n\t\trule2 = new ACLRule();\n\t\trule2.setNw_dst(\"10.0.0.3/32\");\n\t\tcidr = IPAddressUtil.parseCIDR(\"10.0.0.3/32\");\n\t\trule2.setNw_dst_prefix(cidr[0]);\n\t\trule2.setNw_dst_maskbits(cidr[1]);\n\t\trule2.setNw_proto(1);\n\t\trule2.setAction(Action.DENY);\n\n\t\tassertEquals(acl.addRule(rule2), true);\n\t\tassertEquals(acl.getRules().size(), 2);\n\n\t\t// a new AP[dpid:00:00:00:00:00:00:00:02 port:1 ip:10.0.0.3] appears\n\t\tdeviceManager.learnEntity(MacAddress.of(\"00:00:00:00:00:03\"),\n\t\t\t\tVlanVid.ZERO, IPv4Address.of(\"10.0.0.3\"), IPv6Address.NONE, DatapathId.of(2), OFPort.of(1));\n\t\t\n\t\tresultSet = storageService.getRow(\n\t\t\t\tStaticFlowEntryPusher.TABLE_NAME, \"ACLRule_2_00:00:00:00:00:00:00:02\");\n\t\tit = resultSet.iterator();\n\t\twhile(it.hasNext()){\n\t\t\trow = it.next().getRow();\n\t\t\tassertEquals(row.get(\"switch\").toString(),\"00:00:00:00:00:00:00:02\");\n\t\t\tassertEquals(row.get(\"priority\").toString(),\"29999\");\n\t\t\tassertEquals(row.get(\"eth_type\").toString(),\"2048\");\n\t\t\tassertEquals(row.get(\"ipv4_src\"), null);\n\t\t\tassertEquals(row.get(\"ipv4_dst\").toString(),\"10.0.0.3/32\");\n\t\t\tassertEquals(row.get(\"ip_proto\").toString(),\"1\");\n\t\t\tassertEquals(row.get(\"tp_dst\"), null);\n\t\t\tassertEquals(row.get(\"actions\"), null);\n\t\t}\n\t}", "signature": "void testDeviceAdded()", "full_signature": "@Test public void testDeviceAdded()", "class_method_signature": "ACLTest.testDeviceAdded()", "testcase": true, "constructor": false, "invocations": ["reset", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "of", "of", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "of", "of", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "of", "of", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "of", "of", "replay", "setNw_src", "parseCIDR", "setNw_src_prefix", "setNw_src_maskbits", "setNw_dst", "parseCIDR", "setNw_dst_prefix", "setNw_dst_maskbits", "setNw_proto", "setTp_dst", "setAction", "assertEquals", "addRule", "assertEquals", "size", "getRules", "learnEntity", "of", "of", "of", "of", "getRow", "iterator", "hasNext", "getRow", "next", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "get", "learnEntity", "of", "of", "of", "of", "getRow", "iterator", "hasNext", "getRow", "next", "assertEquals", "setNw_dst", "parseCIDR", "setNw_dst_prefix", "setNw_dst_maskbits", "setNw_proto", "setAction", "assertEquals", "addRule", "assertEquals", "size", "getRules", "learnEntity", "of", "of", "of", "of", "getRow", "iterator", "hasNext", "getRow", "next", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "get", "assertEquals", "toString", "get", "assertEquals", "toString", "get", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "ACL", "superclass": "", "interfaces": "implements IACLService, IFloodlightModule, IDeviceListener", "fields": [{"original_string": "protected IRestApiService restApi;", "modifier": "protected", "type": "IRestApiService", "declarator": "restApi", "var_name": "restApi"}, {"original_string": "protected IDeviceService deviceManager;", "modifier": "protected", "type": "IDeviceService", "declarator": "deviceManager", "var_name": "deviceManager"}, {"original_string": "protected IStorageSourceService storageSource;", "modifier": "protected", "type": "IStorageSourceService", "declarator": "storageSource", "var_name": "storageSource"}, {"original_string": "protected static Logger logger;", "modifier": "protected static", "type": "Logger", "declarator": "logger", "var_name": "logger"}, {"original_string": "private APManager apManager;", "modifier": "private", "type": "APManager", "declarator": "apManager", "var_name": "apManager"}, {"original_string": "private int lastRuleId = 1;", "modifier": "private", "type": "int", "declarator": "lastRuleId = 1", "var_name": "lastRuleId"}, {"original_string": "private Map<Integer, ACLRule> aclRules;", "modifier": "private", "type": "Map<Integer, ACLRule>", "declarator": "aclRules", "var_name": "aclRules"}, {"original_string": "private Map<String, Integer> dpid2FlowPriority;", "modifier": "private", "type": "Map<String, Integer>", "declarator": "dpid2FlowPriority", "var_name": "dpid2FlowPriority"}, {"original_string": "private Map<Integer, Set<String>> ruleId2Dpid;", "modifier": "private", "type": "Map<Integer, Set<String>>", "declarator": "ruleId2Dpid", "var_name": "ruleId2Dpid"}, {"original_string": "private Map<Integer, Set<String>> ruleId2FlowName;", "modifier": "private", "type": "Map<Integer, Set<String>>", "declarator": "ruleId2FlowName", "var_name": "ruleId2FlowName"}, {"original_string": "private Map<Integer, List<Integer>> deny2Allow;", "modifier": "private", "type": "Map<Integer, List<Integer>>", "declarator": "deny2Allow", "var_name": "deny2Allow"}, {"original_string": "private final int DEFAULT_PRIORITY = 30000;", "modifier": "private final", "type": "int", "declarator": "DEFAULT_PRIORITY = 30000", "var_name": "DEFAULT_PRIORITY"}], "methods": [{"identifier": "checkIfRuleWorksInSwitch", "parameters": "(int ruleId, String dpid)", "modifiers": "private", "return": "boolean", "signature": "boolean checkIfRuleWorksInSwitch(int ruleId, String dpid)", "full_signature": "private boolean checkIfRuleWorksInSwitch(int ruleId, String dpid)", "class_method_signature": "ACL.checkIfRuleWorksInSwitch(int ruleId, String dpid)", "testcase": false, "constructor": false}, {"identifier": "addRuleToFlowMapping", "parameters": "(int ruleId, String flowName)", "modifiers": "private", "return": "void", "signature": "void addRuleToFlowMapping(int ruleId, String flowName)", "full_signature": "private void addRuleToFlowMapping(int ruleId, String flowName)", "class_method_signature": "ACL.addRuleToFlowMapping(int ruleId, String flowName)", "testcase": false, "constructor": false}, {"identifier": "addRuleToSwitchMapping", "parameters": "(int ruleId, String dpid)", "modifiers": "private", "return": "void", "signature": "void addRuleToSwitchMapping(int ruleId, String dpid)", "full_signature": "private void addRuleToSwitchMapping(int ruleId, String dpid)", "class_method_signature": "ACL.addRuleToSwitchMapping(int ruleId, String dpid)", "testcase": false, "constructor": false}, {"identifier": "getPriorityBySwitch", "parameters": "(String dpid)", "modifiers": "private", "return": "int", "signature": "int getPriorityBySwitch(String dpid)", "full_signature": "private int getPriorityBySwitch(String dpid)", "class_method_signature": "ACL.getPriorityBySwitch(String dpid)", "testcase": false, "constructor": false}, {"identifier": "getRules", "parameters": "()", "modifiers": "@Override public", "return": "List<ACLRule>", "signature": "List<ACLRule> getRules()", "full_signature": "@Override public List<ACLRule> getRules()", "class_method_signature": "ACL.getRules()", "testcase": false, "constructor": false}, {"identifier": "checkRuleMatch", "parameters": "(ACLRule newRule)", "modifiers": "private", "return": "boolean", "signature": "boolean checkRuleMatch(ACLRule newRule)", "full_signature": "private boolean checkRuleMatch(ACLRule newRule)", "class_method_signature": "ACL.checkRuleMatch(ACLRule newRule)", "testcase": false, "constructor": false}, {"identifier": "addRule", "parameters": "(ACLRule rule)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean addRule(ACLRule rule)", "full_signature": "@Override public boolean addRule(ACLRule rule)", "class_method_signature": "ACL.addRule(ACLRule rule)", "testcase": false, "constructor": false}, {"identifier": "removeRule", "parameters": "(int ruleId)", "modifiers": "@Override public", "return": "void", "signature": "void removeRule(int ruleId)", "full_signature": "@Override public void removeRule(int ruleId)", "class_method_signature": "ACL.removeRule(int ruleId)", "testcase": false, "constructor": false}, {"identifier": "removeAllRules", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void removeAllRules()", "full_signature": "@Override public void removeAllRules()", "class_method_signature": "ACL.removeAllRules()", "testcase": false, "constructor": false}, {"identifier": "enforceAddedRule", "parameters": "(ACLRule denyRule)", "modifiers": "private", "return": "void", "signature": "void enforceAddedRule(ACLRule denyRule)", "full_signature": "private void enforceAddedRule(ACLRule denyRule)", "class_method_signature": "ACL.enforceAddedRule(ACLRule denyRule)", "testcase": false, "constructor": false}, {"identifier": "enforceRemovedRule", "parameters": "(int ruleId)", "modifiers": "private", "return": "void", "signature": "void enforceRemovedRule(int ruleId)", "full_signature": "private void enforceRemovedRule(int ruleId)", "class_method_signature": "ACL.enforceRemovedRule(int ruleId)", "testcase": false, "constructor": false}, {"identifier": "generateFlow", "parameters": "(ACLRule rule, String dpid, String flowName)", "modifiers": "private", "return": "void", "signature": "void generateFlow(ACLRule rule, String dpid, String flowName)", "full_signature": "private void generateFlow(ACLRule rule, String dpid, String flowName)", "class_method_signature": "ACL.generateFlow(ACLRule rule, String dpid, String flowName)", "testcase": false, "constructor": false}, {"identifier": "getModuleServices", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleServices()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleServices()", "class_method_signature": "ACL.getModuleServices()", "testcase": false, "constructor": false}, {"identifier": "getServiceImpls", "parameters": "()", "modifiers": "@Override public", "return": "Map<Class<? extends IFloodlightService>, IFloodlightService>", "signature": "Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "full_signature": "@Override public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "class_method_signature": "ACL.getServiceImpls()", "testcase": false, "constructor": false}, {"identifier": "getModuleDependencies", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "class_method_signature": "ACL.getModuleDependencies()", "testcase": false, "constructor": false}, {"identifier": "init", "parameters": "(FloodlightModuleContext context)", "modifiers": "@Override public", "return": "void", "signature": "void init(FloodlightModuleContext context)", "full_signature": "@Override public void init(FloodlightModuleContext context)", "class_method_signature": "ACL.init(FloodlightModuleContext context)", "testcase": false, "constructor": false}, {"identifier": "startUp", "parameters": "(FloodlightModuleContext context)", "modifiers": "@Override public", "return": "void", "signature": "void startUp(FloodlightModuleContext context)", "full_signature": "@Override public void startUp(FloodlightModuleContext context)", "class_method_signature": "ACL.startUp(FloodlightModuleContext context)", "testcase": false, "constructor": false}, {"identifier": "deviceAdded", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "signature": "void deviceAdded(IDevice device)", "full_signature": "@Override public void deviceAdded(IDevice device)", "class_method_signature": "ACL.deviceAdded(IDevice device)", "testcase": false, "constructor": false}, {"identifier": "processAPAdded", "parameters": "(AP ap)", "modifiers": "private", "return": "void", "signature": "void processAPAdded(AP ap)", "full_signature": "private void processAPAdded(AP ap)", "class_method_signature": "ACL.processAPAdded(AP ap)", "testcase": false, "constructor": false}, {"identifier": "deviceRemoved", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "signature": "void deviceRemoved(IDevice device)", "full_signature": "@Override public void deviceRemoved(IDevice device)", "class_method_signature": "ACL.deviceRemoved(IDevice device)", "testcase": false, "constructor": false}, {"identifier": "deviceMoved", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "signature": "void deviceMoved(IDevice device)", "full_signature": "@Override public void deviceMoved(IDevice device)", "class_method_signature": "ACL.deviceMoved(IDevice device)", "testcase": false, "constructor": false}, {"identifier": "deviceIPV6AddrChanged", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "signature": "void deviceIPV6AddrChanged(IDevice device)", "full_signature": "@Override public void deviceIPV6AddrChanged(IDevice device)", "class_method_signature": "ACL.deviceIPV6AddrChanged(IDevice device)", "testcase": false, "constructor": false}, {"identifier": "deviceIPV4AddrChanged", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "signature": "void deviceIPV4AddrChanged(IDevice device)", "full_signature": "@Override public void deviceIPV4AddrChanged(IDevice device)", "class_method_signature": "ACL.deviceIPV4AddrChanged(IDevice device)", "testcase": false, "constructor": false}, {"identifier": "deviceVlanChanged", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "signature": "void deviceVlanChanged(IDevice device)", "full_signature": "@Override public void deviceVlanChanged(IDevice device)", "class_method_signature": "ACL.deviceVlanChanged(IDevice device)", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getName()", "full_signature": "@Override public String getName()", "class_method_signature": "ACL.getName()", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPrereq", "parameters": "(String type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPrereq(String type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPrereq(String type, String name)", "class_method_signature": "ACL.isCallbackOrderingPrereq(String type, String name)", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPostreq", "parameters": "(String type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPostreq(String type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPostreq(String type, String name)", "class_method_signature": "ACL.isCallbackOrderingPostreq(String type, String name)", "testcase": false, "constructor": false}], "file": "src/agents/apps/floodlight/floodlight-1.2/src/main/java/net/floodlightcontroller/accesscontrollist/ACL.java"}, "focal_method": {"identifier": "deviceAdded", "parameters": "(IDevice device)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void deviceAdded(IDevice device) {\n\t\tSwitchPort[] switchPort = device.getAttachmentPoints(); \n\t\tif (switchPort.length == 0) {\n                        //Device manager does not yet know an attachment point for a device (Bug Fix) \n                        return;\n                }\n\t\tIPv4Address[] ips = device.getIPv4Addresses();\n\t\tif (ips.length == 0) {\n\t\t\t// A new no-ip device added\n\t\t\treturn;\n\t\t}\n\n\t\tString dpid = HexString.toHexString(switchPort[0].getSwitchDPID()\n\t\t\t\t.getLong());\n\t\tString ip = IPv4.fromIPv4Address(ips[0].getInt());\n\t\tlogger.debug(\"AP(dpid:{},ip:{}) is added\", dpid, ip);\n\n\t\tAP ap = new AP(ip, dpid);\n\t\tapManager.addAP(ap);\n\t\tprocessAPAdded(ap);\n\t}", "signature": "void deviceAdded(IDevice device)", "full_signature": "@Override public void deviceAdded(IDevice device)", "class_method_signature": "ACL.deviceAdded(IDevice device)", "testcase": false, "constructor": false, "invocations": ["getAttachmentPoints", "getIPv4Addresses", "toHexString", "getLong", "getSwitchDPID", "fromIPv4Address", "getInt", "debug", "addAP", "processAPAdded"]}, "repository": {"repo_id": 181421086, "url": "https://github.com/seungsoo-lee/DELTA", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 35, "size": 99244, "license": "licensed"}}