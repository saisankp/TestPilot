{"test_class": {"identifier": "TransactionBroadcastTest", "superclass": "extends TestWithPeerGroup", "interfaces": "", "fields": [], "file": "core/src/test/java/org/ulordj/core/TransactionBroadcastTest.java"}, "test_case": {"identifier": "rejectHandling", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void rejectHandling() throws Exception {\n        InboundMessageQueuer[] channels = { connectPeer(0), connectPeer(1), connectPeer(2), connectPeer(3), connectPeer(4) };\n        Transaction tx = FakeTxBuilder.createFakeTx(UNITTEST);\n        TransactionBroadcast broadcast = new TransactionBroadcast(peerGroup, tx);\n        ListenableFuture<Transaction> future = broadcast.broadcast();\n        // 0 and 3 are randomly selected to receive the broadcast.\n        assertEquals(tx, outbound(channels[1]));\n        assertEquals(tx, outbound(channels[2]));\n        assertEquals(tx, outbound(channels[4]));\n        RejectMessage reject = new RejectMessage(UNITTEST, RejectMessage.RejectCode.DUST, tx.getHash(), \"tx\", \"dust\");\n        inbound(channels[1], reject);\n        inbound(channels[4], reject);\n        try {\n            future.get();\n            fail();\n        } catch (ExecutionException e) {\n            assertEquals(RejectedTransactionException.class, e.getCause().getClass());\n        }\n    }", "signature": "void rejectHandling()", "full_signature": "@Test public void rejectHandling()", "class_method_signature": "TransactionBroadcastTest.rejectHandling()", "testcase": true, "constructor": false, "invocations": ["connectPeer", "connectPeer", "connectPeer", "connectPeer", "connectPeer", "createFakeTx", "broadcast", "assertEquals", "outbound", "assertEquals", "outbound", "assertEquals", "outbound", "getHash", "inbound", "inbound", "get", "fail", "assertEquals", "getClass", "getCause"]}, "focal_class": {"identifier": "TransactionBroadcast", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(TransactionBroadcast.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(TransactionBroadcast.class)", "var_name": "log"}, {"original_string": "private final SettableFuture<Transaction> future = SettableFuture.create();", "modifier": "private final", "type": "SettableFuture<Transaction>", "declarator": "future = SettableFuture.create()", "var_name": "future"}, {"original_string": "private final PeerGroup peerGroup;", "modifier": "private final", "type": "PeerGroup", "declarator": "peerGroup", "var_name": "peerGroup"}, {"original_string": "private final Transaction tx;", "modifier": "private final", "type": "Transaction", "declarator": "tx", "var_name": "tx"}, {"original_string": "private int minConnections;", "modifier": "private", "type": "int", "declarator": "minConnections", "var_name": "minConnections"}, {"original_string": "private int numWaitingFor;", "modifier": "private", "type": "int", "declarator": "numWaitingFor", "var_name": "numWaitingFor"}, {"original_string": "@VisibleForTesting\n    public static Random random = new Random();", "modifier": "@VisibleForTesting\n    public static", "type": "Random", "declarator": "random = new Random()", "var_name": "random"}, {"original_string": "private Map<Peer, RejectMessage> rejects = Collections.synchronizedMap(new HashMap<Peer, RejectMessage>());", "modifier": "private", "type": "Map<Peer, RejectMessage>", "declarator": "rejects = Collections.synchronizedMap(new HashMap<Peer, RejectMessage>())", "var_name": "rejects"}, {"original_string": "private PreMessageReceivedEventListener rejectionListener = new PreMessageReceivedEventListener() {\n        @Override\n        public Message onPreMessageReceived(Peer peer, Message m) {\n            if (m instanceof RejectMessage) {\n                RejectMessage rejectMessage = (RejectMessage)m;\n                if (tx.getHash().equals(rejectMessage.getRejectedObjectHash())) {\n                    rejects.put(peer, rejectMessage);\n                    int size = rejects.size();\n                    long threshold = Math.round(numWaitingFor / 2.0);\n                    if (size > threshold) {\n                        log.warn(\"Threshold for considering broadcast rejected has been reached ({}/{})\", size, threshold);\n                        future.setException(new RejectedTransactionException(tx, rejectMessage));\n                        peerGroup.removePreMessageReceivedEventListener(this);\n                    }\n                }\n            }\n            return m;\n        }\n    };", "modifier": "private", "type": "PreMessageReceivedEventListener", "declarator": "rejectionListener = new PreMessageReceivedEventListener() {\n        @Override\n        public Message onPreMessageReceived(Peer peer, Message m) {\n            if (m instanceof RejectMessage) {\n                RejectMessage rejectMessage = (RejectMessage)m;\n                if (tx.getHash().equals(rejectMessage.getRejectedObjectHash())) {\n                    rejects.put(peer, rejectMessage);\n                    int size = rejects.size();\n                    long threshold = Math.round(numWaitingFor / 2.0);\n                    if (size > threshold) {\n                        log.warn(\"Threshold for considering broadcast rejected has been reached ({}/{})\", size, threshold);\n                        future.setException(new RejectedTransactionException(tx, rejectMessage));\n                        peerGroup.removePreMessageReceivedEventListener(this);\n                    }\n                }\n            }\n            return m;\n        }\n    }", "var_name": "rejectionListener"}, {"original_string": "private int numSeemPeers;", "modifier": "private", "type": "int", "declarator": "numSeemPeers", "var_name": "numSeemPeers"}, {"original_string": "private boolean mined;", "modifier": "private", "type": "boolean", "declarator": "mined", "var_name": "mined"}, {"original_string": "@Nullable private ProgressCallback callback;", "modifier": "@Nullable private", "type": "ProgressCallback", "declarator": "callback", "var_name": "callback"}, {"original_string": "@Nullable private Executor progressCallbackExecutor;", "modifier": "@Nullable private", "type": "Executor", "declarator": "progressCallbackExecutor", "var_name": "progressCallbackExecutor"}], "methods": [{"identifier": "TransactionBroadcast", "parameters": "(PeerGroup peerGroup, Transaction tx)", "modifiers": "", "return": "", "signature": " TransactionBroadcast(PeerGroup peerGroup, Transaction tx)", "full_signature": "  TransactionBroadcast(PeerGroup peerGroup, Transaction tx)", "class_method_signature": "TransactionBroadcast.TransactionBroadcast(PeerGroup peerGroup, Transaction tx)", "testcase": false, "constructor": true}, {"identifier": "TransactionBroadcast", "parameters": "(Transaction tx)", "modifiers": "private", "return": "", "signature": " TransactionBroadcast(Transaction tx)", "full_signature": "private  TransactionBroadcast(Transaction tx)", "class_method_signature": "TransactionBroadcast.TransactionBroadcast(Transaction tx)", "testcase": false, "constructor": true}, {"identifier": "createMockBroadcast", "parameters": "(Transaction tx, final SettableFuture<Transaction> future)", "modifiers": "@VisibleForTesting public static", "return": "TransactionBroadcast", "signature": "TransactionBroadcast createMockBroadcast(Transaction tx, final SettableFuture<Transaction> future)", "full_signature": "@VisibleForTesting public static TransactionBroadcast createMockBroadcast(Transaction tx, final SettableFuture<Transaction> future)", "class_method_signature": "TransactionBroadcast.createMockBroadcast(Transaction tx, final SettableFuture<Transaction> future)", "testcase": false, "constructor": false}, {"identifier": "future", "parameters": "()", "modifiers": "public", "return": "ListenableFuture<Transaction>", "signature": "ListenableFuture<Transaction> future()", "full_signature": "public ListenableFuture<Transaction> future()", "class_method_signature": "TransactionBroadcast.future()", "testcase": false, "constructor": false}, {"identifier": "setMinConnections", "parameters": "(int minConnections)", "modifiers": "public", "return": "void", "signature": "void setMinConnections(int minConnections)", "full_signature": "public void setMinConnections(int minConnections)", "class_method_signature": "TransactionBroadcast.setMinConnections(int minConnections)", "testcase": false, "constructor": false}, {"identifier": "broadcast", "parameters": "()", "modifiers": "public", "return": "ListenableFuture<Transaction>", "signature": "ListenableFuture<Transaction> broadcast()", "full_signature": "public ListenableFuture<Transaction> broadcast()", "class_method_signature": "TransactionBroadcast.broadcast()", "testcase": false, "constructor": false}, {"identifier": "invokeAndRecord", "parameters": "(int numSeenPeers, boolean mined)", "modifiers": "private", "return": "void", "signature": "void invokeAndRecord(int numSeenPeers, boolean mined)", "full_signature": "private void invokeAndRecord(int numSeenPeers, boolean mined)", "class_method_signature": "TransactionBroadcast.invokeAndRecord(int numSeenPeers, boolean mined)", "testcase": false, "constructor": false}, {"identifier": "invokeProgressCallback", "parameters": "(int numSeenPeers, boolean mined)", "modifiers": "private", "return": "void", "signature": "void invokeProgressCallback(int numSeenPeers, boolean mined)", "full_signature": "private void invokeProgressCallback(int numSeenPeers, boolean mined)", "class_method_signature": "TransactionBroadcast.invokeProgressCallback(int numSeenPeers, boolean mined)", "testcase": false, "constructor": false}, {"identifier": "setProgressCallback", "parameters": "(ProgressCallback callback)", "modifiers": "public", "return": "void", "signature": "void setProgressCallback(ProgressCallback callback)", "full_signature": "public void setProgressCallback(ProgressCallback callback)", "class_method_signature": "TransactionBroadcast.setProgressCallback(ProgressCallback callback)", "testcase": false, "constructor": false}, {"identifier": "setProgressCallback", "parameters": "(ProgressCallback callback, @Nullable Executor executor)", "modifiers": "public", "return": "void", "signature": "void setProgressCallback(ProgressCallback callback, @Nullable Executor executor)", "full_signature": "public void setProgressCallback(ProgressCallback callback, @Nullable Executor executor)", "class_method_signature": "TransactionBroadcast.setProgressCallback(ProgressCallback callback, @Nullable Executor executor)", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/ulordj/core/TransactionBroadcast.java"}, "focal_method": {"identifier": "broadcast", "parameters": "()", "modifiers": "public", "return": "ListenableFuture<Transaction>", "body": "public ListenableFuture<Transaction> broadcast() {\n        peerGroup.addPreMessageReceivedEventListener(Threading.SAME_THREAD, rejectionListener);\n        log.info(\"Waiting for {} peers required for broadcast, we have {} ...\", minConnections, peerGroup.getConnectedPeers().size());\n        peerGroup.waitForPeers(minConnections).addListener(new EnoughAvailablePeers(), Threading.SAME_THREAD);\n        return future;\n    }", "signature": "ListenableFuture<Transaction> broadcast()", "full_signature": "public ListenableFuture<Transaction> broadcast()", "class_method_signature": "TransactionBroadcast.broadcast()", "testcase": false, "constructor": false, "invocations": ["addPreMessageReceivedEventListener", "info", "size", "getConnectedPeers", "addListener", "waitForPeers"]}, "repository": {"repo_id": 133357466, "url": "https://github.com/UlordChain/ulordj", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 23, "size": 7129, "license": "licensed"}}