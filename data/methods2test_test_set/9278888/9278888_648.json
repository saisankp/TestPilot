{"test_class": {"identifier": "InjectorFactoryTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "TraceContext context = TraceContext.newBuilder().traceId(1L).spanId(2L).sampled(true).build();", "modifier": "", "type": "TraceContext", "declarator": "context = TraceContext.newBuilder().traceId(1L).spanId(2L).sampled(true).build()", "var_name": "context"}, {"original_string": "EnumSet<Kind> injectableKinds = EnumSet.of(Kind.CLIENT, Kind.PRODUCER, Kind.CONSUMER);", "modifier": "", "type": "EnumSet<Kind>", "declarator": "injectableKinds = EnumSet.of(Kind.CLIENT, Kind.PRODUCER, Kind.CONSUMER)", "var_name": "injectableKinds"}, {"original_string": "Object notRequest = new Object();", "modifier": "", "type": "Object", "declarator": "notRequest = new Object()", "var_name": "notRequest"}, {"original_string": "Setter<Object, String> setter = mock(Setter.class);", "modifier": "", "type": "Setter<Object, String>", "declarator": "setter = mock(Setter.class)", "var_name": "setter"}, {"original_string": "Request request = mock(Request.class);", "modifier": "", "type": "Request", "declarator": "request = mock(Request.class)", "var_name": "request"}, {"original_string": "RemoteSetter<Request> remoteSetter = mock(RemoteSetter.class);", "modifier": "", "type": "RemoteSetter<Request>", "declarator": "remoteSetter = mock(RemoteSetter.class)", "var_name": "remoteSetter"}, {"original_string": "AtomicInteger oneCount = new AtomicInteger();", "modifier": "", "type": "AtomicInteger", "declarator": "oneCount = new AtomicInteger()", "var_name": "oneCount"}, {"original_string": "InjectorFunction one = newInjectorFunction(\"one\", oneCount);", "modifier": "", "type": "InjectorFunction", "declarator": "one = newInjectorFunction(\"one\", oneCount)", "var_name": "one"}, {"original_string": "AtomicInteger twoCount = new AtomicInteger();", "modifier": "", "type": "AtomicInteger", "declarator": "twoCount = new AtomicInteger()", "var_name": "twoCount"}, {"original_string": "InjectorFunction two = newInjectorFunction(\"two\", twoCount);", "modifier": "", "type": "InjectorFunction", "declarator": "two = newInjectorFunction(\"two\", twoCount)", "var_name": "two"}, {"original_string": "AtomicInteger threeCount = new AtomicInteger();", "modifier": "", "type": "AtomicInteger", "declarator": "threeCount = new AtomicInteger()", "var_name": "threeCount"}, {"original_string": "InjectorFunction three = newInjectorFunction(\"three\", threeCount);", "modifier": "", "type": "InjectorFunction", "declarator": "three = newInjectorFunction(\"three\", threeCount)", "var_name": "three"}, {"original_string": "AtomicInteger fourCount = new AtomicInteger();", "modifier": "", "type": "AtomicInteger", "declarator": "fourCount = new AtomicInteger()", "var_name": "fourCount"}, {"original_string": "InjectorFunction four = newInjectorFunction(\"four\", fourCount);", "modifier": "", "type": "InjectorFunction", "declarator": "four = newInjectorFunction(\"four\", fourCount)", "var_name": "four"}, {"original_string": "List<AtomicInteger> allCounts = Arrays.asList(oneCount, twoCount, threeCount, fourCount);", "modifier": "", "type": "List<AtomicInteger>", "declarator": "allCounts = Arrays.asList(oneCount, twoCount, threeCount, fourCount)", "var_name": "allCounts"}, {"original_string": "InjectorFactory oneFunction = InjectorFactory.newBuilder(one).build();", "modifier": "", "type": "InjectorFactory", "declarator": "oneFunction = InjectorFactory.newBuilder(one).build()", "var_name": "oneFunction"}, {"original_string": "InjectorFactory twoFunctions = InjectorFactory.newBuilder(one)\n      .injectorFunctions(one, two)\n      .clientInjectorFunctions(one, two)\n      .producerInjectorFunctions(one, two)\n      .consumerInjectorFunctions(one, two)\n      .build();", "modifier": "", "type": "InjectorFactory", "declarator": "twoFunctions = InjectorFactory.newBuilder(one)\n      .injectorFunctions(one, two)\n      .clientInjectorFunctions(one, two)\n      .producerInjectorFunctions(one, two)\n      .consumerInjectorFunctions(one, two)\n      .build()", "var_name": "twoFunctions"}, {"original_string": "InjectorFactory kindBasedFunctions = InjectorFactory.newBuilder(one)\n      .injectorFunctions(one)\n      .clientInjectorFunctions(two)\n      .producerInjectorFunctions(three)\n      .consumerInjectorFunctions(four)\n      .build();", "modifier": "", "type": "InjectorFactory", "declarator": "kindBasedFunctions = InjectorFactory.newBuilder(one)\n      .injectorFunctions(one)\n      .clientInjectorFunctions(two)\n      .producerInjectorFunctions(three)\n      .consumerInjectorFunctions(four)\n      .build()", "var_name": "kindBasedFunctions"}], "file": "brave/src/test/java/brave/internal/propagation/InjectorFactoryTest.java"}, "test_case": {"identifier": "injectorFunction_null", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void injectorFunction_null() {\n    InjectorFunction existing = mock(InjectorFunction.class);\n    assertThatThrownBy(() -> injectorFunction(existing, null))\n        .hasMessage(\"injectorFunctions == null\");\n    assertThatThrownBy(() -> injectorFunction(existing, new InjectorFunction[] {null}))\n        .hasMessage(\"injectorFunction == null\");\n    assertThatThrownBy(() -> injectorFunction(existing, one, null))\n        .hasMessage(\"injectorFunction == null\");\n  }", "signature": "void injectorFunction_null()", "full_signature": "@Test public void injectorFunction_null()", "class_method_signature": "InjectorFactoryTest.injectorFunction_null()", "testcase": true, "constructor": false, "invocations": ["mock", "hasMessage", "assertThatThrownBy", "injectorFunction", "hasMessage", "assertThatThrownBy", "injectorFunction", "hasMessage", "assertThatThrownBy", "injectorFunction"]}, "focal_class": {"identifier": "InjectorFactory", "superclass": "", "interfaces": "", "fields": [{"original_string": "final InjectorFunction injectorFunction;", "modifier": "final", "type": "InjectorFunction", "declarator": "injectorFunction", "var_name": "injectorFunction"}, {"original_string": "final InjectorFunction clientInjectorFunction, producerInjectorFunction, consumerInjectorFunction;", "modifier": "final", "type": "InjectorFunction", "declarator": "clientInjectorFunction", "var_name": "clientInjectorFunction"}, {"original_string": "final List<String> keyNames;", "modifier": "final", "type": "List<String>", "declarator": "keyNames", "var_name": "keyNames"}], "methods": [{"identifier": "newBuilder", "parameters": "(InjectorFunction injectorFunction)", "modifiers": "public static", "return": "Builder", "signature": "Builder newBuilder(InjectorFunction injectorFunction)", "full_signature": "public static Builder newBuilder(InjectorFunction injectorFunction)", "class_method_signature": "InjectorFactory.newBuilder(InjectorFunction injectorFunction)", "testcase": false, "constructor": false}, {"identifier": "InjectorFactory", "parameters": "(Builder builder)", "modifiers": "", "return": "", "signature": " InjectorFactory(Builder builder)", "full_signature": "  InjectorFactory(Builder builder)", "class_method_signature": "InjectorFactory.InjectorFactory(Builder builder)", "testcase": false, "constructor": true}, {"identifier": "keyNames", "parameters": "()", "modifiers": "public", "return": "List<String>", "signature": "List<String> keyNames()", "full_signature": "public List<String> keyNames()", "class_method_signature": "InjectorFactory.keyNames()", "testcase": false, "constructor": false}, {"identifier": "newInjector", "parameters": "(Setter<R, String> setter)", "modifiers": "public", "return": "TraceContext.Injector<R>", "signature": "TraceContext.Injector<R> newInjector(Setter<R, String> setter)", "full_signature": "public TraceContext.Injector<R> newInjector(Setter<R, String> setter)", "class_method_signature": "InjectorFactory.newInjector(Setter<R, String> setter)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "InjectorFactory.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object o)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object o)", "full_signature": "@Override public boolean equals(Object o)", "class_method_signature": "InjectorFactory.equals(Object o)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "InjectorFactory.toString()", "testcase": false, "constructor": false}, {"identifier": "injectorFunction", "parameters": "(InjectorFunction existing, InjectorFunction... update)", "modifiers": "static", "return": "InjectorFunction", "signature": "InjectorFunction injectorFunction(InjectorFunction existing, InjectorFunction... update)", "full_signature": "static InjectorFunction injectorFunction(InjectorFunction existing, InjectorFunction... update)", "class_method_signature": "InjectorFactory.injectorFunction(InjectorFunction existing, InjectorFunction... update)", "testcase": false, "constructor": false}], "file": "brave/src/main/java/brave/internal/propagation/InjectorFactory.java"}, "focal_method": {"identifier": "injectorFunction", "parameters": "(InjectorFunction existing, InjectorFunction... update)", "modifiers": "static", "return": "InjectorFunction", "body": "static InjectorFunction injectorFunction(InjectorFunction existing, InjectorFunction... update) {\n    if (update == null) throw new NullPointerException(\"injectorFunctions == null\");\n    LinkedHashSet<InjectorFunction> injectorFunctionSet =\n        new LinkedHashSet<>(Arrays.asList(update));\n    if (injectorFunctionSet.contains(null)) {\n      throw new NullPointerException(\"injectorFunction == null\");\n    }\n    injectorFunctionSet.remove(InjectorFunction.NOOP);\n    if (injectorFunctionSet.isEmpty()) return existing;\n    if (injectorFunctionSet.size() == 1) return injectorFunctionSet.iterator().next();\n    return new CompositeInjectorFunction(injectorFunctionSet.toArray(new InjectorFunction[0]));\n  }", "signature": "InjectorFunction injectorFunction(InjectorFunction existing, InjectorFunction... update)", "full_signature": "static InjectorFunction injectorFunction(InjectorFunction existing, InjectorFunction... update)", "class_method_signature": "InjectorFactory.injectorFunction(InjectorFunction existing, InjectorFunction... update)", "testcase": false, "constructor": false, "invocations": ["asList", "contains", "remove", "isEmpty", "size", "next", "iterator", "toArray"]}, "repository": {"repo_id": 9278888, "url": "https://github.com/openzipkin/brave", "stars": 1754, "created": "4/7/2013 3:48:18 PM +00:00", "updates": "2020-01-26T11:52:41+00:00", "fork": "False", "license": "licensed"}}