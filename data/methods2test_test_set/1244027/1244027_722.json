{"test_class": {"identifier": "AbstractBinaryStoreTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n    public TestRule skipTestRule = new SkipTestRule();", "modifier": "@Rule\n    public", "type": "TestRule", "declarator": "skipTestRule = new SkipTestRule()", "var_name": "skipTestRule"}, {"original_string": "public static final int LARGE_BINARY_SIZE = (int) AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES * 4;", "modifier": "public static final", "type": "int", "declarator": "LARGE_BINARY_SIZE = (int) AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES * 4", "var_name": "LARGE_BINARY_SIZE"}, {"original_string": "public static final byte[] STORED_LARGE_BINARY = new byte[LARGE_BINARY_SIZE];", "modifier": "public static final", "type": "byte[]", "declarator": "STORED_LARGE_BINARY = new byte[LARGE_BINARY_SIZE]", "var_name": "STORED_LARGE_BINARY"}, {"original_string": "public static final BinaryKey STORED_LARGE_KEY;", "modifier": "public static final", "type": "BinaryKey", "declarator": "STORED_LARGE_KEY", "var_name": "STORED_LARGE_KEY"}, {"original_string": "public static final byte[] IN_MEMORY_BINARY = new byte[(int)(AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES / 2)];", "modifier": "public static final", "type": "byte[]", "declarator": "IN_MEMORY_BINARY = new byte[(int)(AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES / 2)]", "var_name": "IN_MEMORY_BINARY"}, {"original_string": "public static final BinaryKey IN_MEMORY_KEY;", "modifier": "public static final", "type": "BinaryKey", "declarator": "IN_MEMORY_KEY", "var_name": "IN_MEMORY_KEY"}, {"original_string": "public static final byte[] STORED_MEDIUM_BINARY = new byte[(int)(AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES * 2)];", "modifier": "public static final", "type": "byte[]", "declarator": "STORED_MEDIUM_BINARY = new byte[(int)(AbstractBinaryStore.DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES * 2)]", "var_name": "STORED_MEDIUM_BINARY"}, {"original_string": "public static final BinaryKey STORED_MEDIUM_KEY;", "modifier": "public static final", "type": "BinaryKey", "declarator": "STORED_MEDIUM_KEY", "var_name": "STORED_MEDIUM_KEY"}, {"original_string": "public static final byte[] EMPTY_BINARY = new byte[0];", "modifier": "public static final", "type": "byte[]", "declarator": "EMPTY_BINARY = new byte[0]", "var_name": "EMPTY_BINARY"}, {"original_string": "public static final BinaryKey EMPTY_BINARY_KEY;", "modifier": "public static final", "type": "BinaryKey", "declarator": "EMPTY_BINARY_KEY", "var_name": "EMPTY_BINARY_KEY"}, {"original_string": "public static final String TEXT_DATA;", "modifier": "public static final", "type": "String", "declarator": "TEXT_DATA", "var_name": "TEXT_DATA"}, {"original_string": "protected static final MimeTypeDetector DEFAULT_DETECTOR = new DefaultMimeTypeDetector();", "modifier": "protected static final", "type": "MimeTypeDetector", "declarator": "DEFAULT_DETECTOR = new DefaultMimeTypeDetector()", "var_name": "DEFAULT_DETECTOR"}, {"original_string": "private static final Random RANDOM = new Random();", "modifier": "private static final", "type": "Random", "declarator": "RANDOM = new Random()", "var_name": "RANDOM"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/value/binary/AbstractBinaryStoreTest.java"}, "test_case": {"identifier": "shouldFailWhenGettingTheTextOfBinaryWhichIsntStored", "parameters": "()", "modifiers": "@Test(expected = BinaryStoreException.class) public", "return": "void", "body": "@Test(expected = BinaryStoreException.class)\n    public void shouldFailWhenGettingTheTextOfBinaryWhichIsntStored() throws RepositoryException {\n        getBinaryStore().getText(new StoredBinaryValue(getBinaryStore(), invalidBinaryKey(), 0));\n    }", "signature": "void shouldFailWhenGettingTheTextOfBinaryWhichIsntStored()", "full_signature": "@Test(expected = BinaryStoreException.class) public void shouldFailWhenGettingTheTextOfBinaryWhichIsntStored()", "class_method_signature": "AbstractBinaryStoreTest.shouldFailWhenGettingTheTextOfBinaryWhichIsntStored()", "testcase": true, "constructor": false, "invocations": ["getText", "getBinaryStore", "getBinaryStore", "invalidBinaryKey"]}, "focal_class": {"identifier": "AbstractBinaryStore", "superclass": "", "interfaces": "implements BinaryStore", "fields": [{"original_string": "static final long DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES = 1024 * 4;", "modifier": "static final", "type": "long", "declarator": "DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES = 1024 * 4", "var_name": "DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES"}, {"original_string": "private static final long DEFAULT_LATCH_WAIT_IN_SECONDS = 10L;", "modifier": "private static final", "type": "long", "declarator": "DEFAULT_LATCH_WAIT_IN_SECONDS = 10L", "var_name": "DEFAULT_LATCH_WAIT_IN_SECONDS"}, {"original_string": "private static final long LARGE_SIZE = 1 << 25;", "modifier": "private static final", "type": "long", "declarator": "LARGE_SIZE = 1 << 25", "var_name": "LARGE_SIZE"}, {"original_string": "private static final long MEDIUM_FILE_SIZE = 1 << 20;", "modifier": "private static final", "type": "long", "declarator": "MEDIUM_FILE_SIZE = 1 << 20", "var_name": "MEDIUM_FILE_SIZE"}, {"original_string": "private static final long SMALL_FILE_SIZE = 1 << 15;", "modifier": "private static final", "type": "long", "declarator": "SMALL_FILE_SIZE = 1 << 15", "var_name": "SMALL_FILE_SIZE"}, {"original_string": "private static final long TINY_FILE_SIZE = 1 << 10;", "modifier": "private static final", "type": "long", "declarator": "TINY_FILE_SIZE = 1 << 10", "var_name": "TINY_FILE_SIZE"}, {"original_string": "private static final int LARGE_BUFFER_SIZE = 1 << 20;", "modifier": "private static final", "type": "int", "declarator": "LARGE_BUFFER_SIZE = 1 << 20", "var_name": "LARGE_BUFFER_SIZE"}, {"original_string": "protected static final int MEDIUM_BUFFER_SIZE = 1 << 16;", "modifier": "protected static final", "type": "int", "declarator": "MEDIUM_BUFFER_SIZE = 1 << 16", "var_name": "MEDIUM_BUFFER_SIZE"}, {"original_string": "private static final int SMALL_BUFFER_SIZE = 1 << 12;", "modifier": "private static final", "type": "int", "declarator": "SMALL_BUFFER_SIZE = 1 << 12", "var_name": "SMALL_BUFFER_SIZE"}, {"original_string": "private static final int TINY_BUFFER_SIZE = 1 << 11;", "modifier": "private static final", "type": "int", "declarator": "TINY_BUFFER_SIZE = 1 << 11", "var_name": "TINY_BUFFER_SIZE"}, {"original_string": "protected final Logger logger = Logger.getLogger(getClass());", "modifier": "protected final", "type": "Logger", "declarator": "logger = Logger.getLogger(getClass())", "var_name": "logger"}, {"original_string": "private final AtomicLong minBinarySizeInBytes = new AtomicLong(DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES);", "modifier": "private final", "type": "AtomicLong", "declarator": "minBinarySizeInBytes = new AtomicLong(DEFAULT_MINIMUM_BINARY_SIZE_IN_BYTES)", "var_name": "minBinarySizeInBytes"}, {"original_string": "private volatile TextExtractors extractors;", "modifier": "private volatile", "type": "TextExtractors", "declarator": "extractors", "var_name": "extractors"}, {"original_string": "private volatile MimeTypeDetector detector = NullMimeTypeDetector.INSTANCE;", "modifier": "private volatile", "type": "MimeTypeDetector", "declarator": "detector = NullMimeTypeDetector.INSTANCE", "var_name": "detector"}], "methods": [{"identifier": "bestBufferSize", "parameters": "( long fileSize )", "modifiers": "public static", "return": "int", "signature": "int bestBufferSize( long fileSize )", "full_signature": "public static int bestBufferSize( long fileSize )", "class_method_signature": "AbstractBinaryStore.bestBufferSize( long fileSize )", "testcase": false, "constructor": false}, {"identifier": "getMinimumBinarySizeInBytes", "parameters": "()", "modifiers": "@Override public", "return": "long", "signature": "long getMinimumBinarySizeInBytes()", "full_signature": "@Override public long getMinimumBinarySizeInBytes()", "class_method_signature": "AbstractBinaryStore.getMinimumBinarySizeInBytes()", "testcase": false, "constructor": false}, {"identifier": "setMinimumBinarySizeInBytes", "parameters": "( long minSizeInBytes )", "modifiers": "@Override public", "return": "void", "signature": "void setMinimumBinarySizeInBytes( long minSizeInBytes )", "full_signature": "@Override public void setMinimumBinarySizeInBytes( long minSizeInBytes )", "class_method_signature": "AbstractBinaryStore.setMinimumBinarySizeInBytes( long minSizeInBytes )", "testcase": false, "constructor": false}, {"identifier": "setTextExtractors", "parameters": "( TextExtractors textExtractors )", "modifiers": "@Override public", "return": "void", "signature": "void setTextExtractors( TextExtractors textExtractors )", "full_signature": "@Override public void setTextExtractors( TextExtractors textExtractors )", "class_method_signature": "AbstractBinaryStore.setTextExtractors( TextExtractors textExtractors )", "testcase": false, "constructor": false}, {"identifier": "setMimeTypeDetector", "parameters": "( MimeTypeDetector mimeTypeDetector )", "modifiers": "@Override public", "return": "void", "signature": "void setMimeTypeDetector( MimeTypeDetector mimeTypeDetector )", "full_signature": "@Override public void setMimeTypeDetector( MimeTypeDetector mimeTypeDetector )", "class_method_signature": "AbstractBinaryStore.setMimeTypeDetector( MimeTypeDetector mimeTypeDetector )", "testcase": false, "constructor": false}, {"identifier": "getText", "parameters": "( BinaryValue binary )", "modifiers": "@Override public final", "return": "String", "signature": "String getText( BinaryValue binary )", "full_signature": "@Override public final String getText( BinaryValue binary )", "class_method_signature": "AbstractBinaryStore.getText( BinaryValue binary )", "testcase": false, "constructor": false}, {"identifier": "getMimeType", "parameters": "( BinaryValue binary,\n                               String name )", "modifiers": "@Override public", "return": "String", "signature": "String getMimeType( BinaryValue binary,\n                               String name )", "full_signature": "@Override public String getMimeType( BinaryValue binary,\n                               String name )", "class_method_signature": "AbstractBinaryStore.getMimeType( BinaryValue binary,\n                               String name )", "testcase": false, "constructor": false}, {"identifier": "hasBinary", "parameters": "( BinaryKey key )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean hasBinary( BinaryKey key )", "full_signature": "@Override public boolean hasBinary( BinaryKey key )", "class_method_signature": "AbstractBinaryStore.hasBinary( BinaryKey key )", "testcase": false, "constructor": false}, {"identifier": "getStoredMimeType", "parameters": "( BinaryValue binaryValue )", "modifiers": "protected abstract", "return": "String", "signature": "String getStoredMimeType( BinaryValue binaryValue )", "full_signature": "protected abstract String getStoredMimeType( BinaryValue binaryValue )", "class_method_signature": "AbstractBinaryStore.getStoredMimeType( BinaryValue binaryValue )", "testcase": false, "constructor": false}, {"identifier": "storeMimeType", "parameters": "( BinaryValue binaryValue,\n                                           String mimeType )", "modifiers": "protected abstract", "return": "void", "signature": "void storeMimeType( BinaryValue binaryValue,\n                                           String mimeType )", "full_signature": "protected abstract void storeMimeType( BinaryValue binaryValue,\n                                           String mimeType )", "class_method_signature": "AbstractBinaryStore.storeMimeType( BinaryValue binaryValue,\n                                           String mimeType )", "testcase": false, "constructor": false}, {"identifier": "storeExtractedText", "parameters": "( BinaryValue source,\n                                             String extractedText )", "modifiers": "public abstract", "return": "void", "signature": "void storeExtractedText( BinaryValue source,\n                                             String extractedText )", "full_signature": "public abstract void storeExtractedText( BinaryValue source,\n                                             String extractedText )", "class_method_signature": "AbstractBinaryStore.storeExtractedText( BinaryValue source,\n                                             String extractedText )", "testcase": false, "constructor": false}, {"identifier": "getExtractedText", "parameters": "( BinaryValue source )", "modifiers": "public abstract", "return": "String", "signature": "String getExtractedText( BinaryValue source )", "full_signature": "public abstract String getExtractedText( BinaryValue source )", "class_method_signature": "AbstractBinaryStore.getExtractedText( BinaryValue source )", "testcase": false, "constructor": false}, {"identifier": "extractors", "parameters": "()", "modifiers": "protected final", "return": "TextExtractors", "signature": "TextExtractors extractors()", "full_signature": "protected final TextExtractors extractors()", "class_method_signature": "AbstractBinaryStore.extractors()", "testcase": false, "constructor": false}, {"identifier": "detector", "parameters": "()", "modifiers": "protected final", "return": "MimeTypeDetector", "signature": "MimeTypeDetector detector()", "full_signature": "protected final MimeTypeDetector detector()", "class_method_signature": "AbstractBinaryStore.detector()", "testcase": false, "constructor": false}, {"identifier": "storeValue", "parameters": "( InputStream stream, String hint, boolean markAsUnused )", "modifiers": "@Override public", "return": "BinaryValue", "signature": "BinaryValue storeValue( InputStream stream, String hint, boolean markAsUnused )", "full_signature": "@Override public BinaryValue storeValue( InputStream stream, String hint, boolean markAsUnused )", "class_method_signature": "AbstractBinaryStore.storeValue( InputStream stream, String hint, boolean markAsUnused )", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void start()", "full_signature": "@Override public void start()", "class_method_signature": "AbstractBinaryStore.start()", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void shutdown()", "full_signature": "@Override public void shutdown()", "class_method_signature": "AbstractBinaryStore.shutdown()", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/value/binary/AbstractBinaryStore.java"}, "focal_method": {"identifier": "getText", "parameters": "( BinaryValue binary )", "modifiers": "@Override public final", "return": "String", "body": "@Override\n    public final String getText( BinaryValue binary ) throws BinaryStoreException {\n        // try and locate an already extracted text from the store\n        if (binary instanceof StoredBinaryValue) {\n            String extractedText = getExtractedText(binary);\n            if (extractedText != null) {\n                return extractedText;\n            }\n        }\n\n        // there isn't extracted text stored, so try to extract text if extraction is enabled\n        if (extractors == null || !extractors.extractionEnabled()) {\n            return null;\n        }\n\n        if (binary instanceof InMemoryBinaryValue) {\n            // The extracted text will never be stored, so try directly using the text extractors ...\n            return extractors.extract((InMemoryBinaryValue)binary, new TextExtractorContext(detector()));\n        }\n\n        // there isn't any text available, so wait for a job to finish and then return the result\n        try {\n            CountDownLatch latch = extractors.getWorkerLatch(binary.getKey(), false);\n            if (latch == null) {\n                // There is no latch, so just compute the text here ...\n                latch = extractors.extract(this, binary, new TextExtractorContext(detector()));\n            }\n            // There was a latch, so wait till the work is done ...\n            if (latch != null && latch.await(DEFAULT_LATCH_WAIT_IN_SECONDS, TimeUnit.SECONDS)) {\n                return getExtractedText(binary);\n            }\n            // Stopped waiting ...\n            return null;\n        } catch (InterruptedException e) {\n            throw new BinaryStoreException(e);\n        }\n    }", "signature": "String getText( BinaryValue binary )", "full_signature": "@Override public final String getText( BinaryValue binary )", "class_method_signature": "AbstractBinaryStore.getText( BinaryValue binary )", "testcase": false, "constructor": false, "invocations": ["getExtractedText", "extractionEnabled", "extract", "detector", "getWorkerLatch", "getKey", "extract", "detector", "await", "getExtractedText"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}