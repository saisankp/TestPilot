{"test_class": {"identifier": "WebsterChecklistTargetTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "final File testOutDir = new File(\"target/test-out/WebsterChecklistTargetTest\");", "modifier": "final", "type": "File", "declarator": "testOutDir = new File(\"target/test-out/WebsterChecklistTargetTest\")", "var_name": "testOutDir"}], "file": "webster/src/test/java/net/adamcin/oakpal/webster/targets/WebsterChecklistTargetTest.java"}, "test_case": {"identifier": "testFromJson_nodeTypeFilters", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testFromJson_nodeTypeFilters() throws Exception {\n        final File targetFile = new File(testOutDir, \"testFromJson_nodeTypeFilters.json\");\n        if (targetFile.exists()) {\n            targetFile.delete();\n        }\n        final String fooMixin1 = \"foo:mixin1\";\n        final String fooMixin2 = \"foo:mixin2\";\n\n        final List<JcrNs> nsList = Collections.singletonList(JcrNs.create(\"foo\", \"http://foo.com\"));\n        OakMachine.Builder oak = TestUtil.fromPlan(obj()\n                .key(\"jcrNamespaces\", nsList)\n                .key(\"jcrNodetypes\", obj()\n                        .key(\"foo:folder\", key(\"extends\", arr(\"nt:folder\")))\n                        .key(fooMixin1, key(\"@\", arr(\"mixin\")))\n                        .key(fooMixin2, key(\"@\", arr(\"mixin\"))))\n                .key(\"forcedRoots\", arr()\n                        .val(new ForcedRoot().withPath(\"/foo1\").withPrimaryType(\"nt:folder\").withMixinTypes(\"mix:title\", fooMixin1))\n                        .val(new ForcedRoot().withPath(\"/foo2\").withPrimaryType(\"nt:unstructured\").withMixinTypes(fooMixin1))\n                )\n                .get());\n        WebsterChecklistTarget target = WebsterChecklistTarget.fromJson(targetFile, obj()\n                .key(\"jcrNamespaces\", nsList)\n                .key(\"selectors\", arr()\n                        .val(key(\"type\", \"nodetype\").key(\"args\", arr(\"mix:title\")))\n                        .val(key(\"type\", \"query\").key(\"args\", arr(\"select * from [nt:unstructured] as nun where issamenode([nun], '/foo2')\"))))\n                .key(\"nodeTypeFilters\", arr()\n                        .val(new Rule(RuleType.INCLUDE, Pattern.compile(\"foo:mixin.*\"))))\n                .key(\"exportNodeTypes\", arr(fooMixin2))\n                .get());\n        oak.build().adminInitAndInspect(target::perform);\n        assertJsonFile(targetFile, json -> {\n            final Checklist checklist = Checklist.fromJson(\"testFromJson\", null, json);\n            assertEquals(\"expect 2 roots\", 2, checklist.getForcedRoots().size());\n            assertEquals(\"expect root path\", \"/foo1\", checklist.getForcedRoots().get(0).getPath());\n            assertNull(\"expect no primary type\", checklist.getForcedRoots().get(0).getPrimaryType());\n            assertEquals(\"expect mixins\", Collections.singletonList(fooMixin1),\n                    checklist.getForcedRoots().get(0).getMixinTypes());\n            assertEquals(\"expect root path\", \"/foo2\", checklist.getForcedRoots().get(1).getPath());\n            assertNull(\"expect no primary type\", checklist.getForcedRoots().get(1).getPrimaryType());\n            assertEquals(\"expect mixins\", Collections.singletonList(fooMixin1),\n                    checklist.getForcedRoots().get(1).getMixinTypes());\n\n            assertEquals(\"two types were exported\", 2, checklist.getJcrNodetypes().size());\n            final NamePathResolver resolver = new DefaultNamePathResolver(JsonCnd.toNamespaceMapping(nsList));\n            assertEquals(\"foo:mixin1 node type was exported\", uncheck1(resolver::getQName).apply(fooMixin1),\n                    checklist.getJcrNodetypes().get(0).getName());\n            assertEquals(\"foo:mixin2 node type was exported\", uncheck1(resolver::getQName).apply(fooMixin2),\n                    checklist.getJcrNodetypes().get(1).getName());\n        });\n    }", "signature": "void testFromJson_nodeTypeFilters()", "full_signature": "@Test public void testFromJson_nodeTypeFilters()", "class_method_signature": "WebsterChecklistTargetTest.testFromJson_nodeTypeFilters()", "testcase": true, "constructor": false, "invocations": ["exists", "delete", "singletonList", "create", "fromPlan", "get", "key", "key", "key", "obj", "key", "key", "key", "obj", "key", "arr", "key", "arr", "key", "arr", "val", "val", "arr", "withMixinTypes", "withPrimaryType", "withPath", "withMixinTypes", "withPrimaryType", "withPath", "fromJson", "get", "key", "key", "key", "key", "obj", "val", "val", "arr", "key", "key", "arr", "key", "key", "arr", "val", "arr", "compile", "arr", "adminInitAndInspect", "build", "assertJsonFile", "fromJson", "assertEquals", "size", "getForcedRoots", "assertEquals", "getPath", "get", "getForcedRoots", "assertNull", "getPrimaryType", "get", "getForcedRoots", "assertEquals", "singletonList", "getMixinTypes", "get", "getForcedRoots", "assertEquals", "getPath", "get", "getForcedRoots", "assertNull", "getPrimaryType", "get", "getForcedRoots", "assertEquals", "singletonList", "getMixinTypes", "get", "getForcedRoots", "assertEquals", "size", "getJcrNodetypes", "toNamespaceMapping", "assertEquals", "apply", "uncheck1", "getName", "get", "getJcrNodetypes", "assertEquals", "apply", "uncheck1", "getName", "get", "getJcrNodetypes"]}, "focal_class": {"identifier": "WebsterChecklistTarget", "superclass": "", "interfaces": "implements WebsterTarget", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(WebsterChecklistTarget.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(WebsterChecklistTarget.class)", "var_name": "LOGGER"}, {"original_string": "static final String KEY_TYPE = \"type\";", "modifier": "static final", "type": "String", "declarator": "KEY_TYPE = \"type\"", "var_name": "KEY_TYPE"}, {"original_string": "static final String KEY_ARGS = \"args\";", "modifier": "static final", "type": "String", "declarator": "KEY_ARGS = \"args\"", "var_name": "KEY_ARGS"}, {"original_string": "static final String COMPACT_KEY_BY_NODETYPES = \"selectNodeTypes\";", "modifier": "static final", "type": "String", "declarator": "COMPACT_KEY_BY_NODETYPES = \"selectNodeTypes\"", "var_name": "COMPACT_KEY_BY_NODETYPES"}, {"original_string": "static final String COMPACT_KEY_BY_PATHS = \"selectPaths\";", "modifier": "static final", "type": "String", "declarator": "COMPACT_KEY_BY_PATHS = \"selectPaths\"", "var_name": "COMPACT_KEY_BY_PATHS"}, {"original_string": "static final String COMPACT_KEY_BY_QUERY = \"selectQuery\";", "modifier": "static final", "type": "String", "declarator": "COMPACT_KEY_BY_QUERY = \"selectQuery\"", "var_name": "COMPACT_KEY_BY_QUERY"}, {"original_string": "static final String KEY_SELECTORS = \"selectors\";", "modifier": "static final", "type": "String", "declarator": "KEY_SELECTORS = \"selectors\"", "var_name": "KEY_SELECTORS"}, {"original_string": "static final String KEY_SCOPE_PATHS = \"scopePaths\";", "modifier": "static final", "type": "String", "declarator": "KEY_SCOPE_PATHS = \"scopePaths\"", "var_name": "KEY_SCOPE_PATHS"}, {"original_string": "static final String KEY_NODE_TYPE_FILTERS = \"nodeTypeFilters\";", "modifier": "static final", "type": "String", "declarator": "KEY_NODE_TYPE_FILTERS = \"nodeTypeFilters\"", "var_name": "KEY_NODE_TYPE_FILTERS"}, {"original_string": "static final String KEY_JCR_NAMESPACES = \"jcrNamespaces\";", "modifier": "static final", "type": "String", "declarator": "KEY_JCR_NAMESPACES = \"jcrNamespaces\"", "var_name": "KEY_JCR_NAMESPACES"}, {"original_string": "static final String KEY_UPDATE_POLICY = \"updatePolicy\";", "modifier": "static final", "type": "String", "declarator": "KEY_UPDATE_POLICY = \"updatePolicy\"", "var_name": "KEY_UPDATE_POLICY"}, {"original_string": "static final String KEY_EXPORT_NODETYPES = \"exportNodeTypes\";", "modifier": "static final", "type": "String", "declarator": "KEY_EXPORT_NODETYPES = \"exportNodeTypes\"", "var_name": "KEY_EXPORT_NODETYPES"}, {"original_string": "private final File checklist;", "modifier": "private final", "type": "File", "declarator": "checklist", "var_name": "checklist"}, {"original_string": "private final ChecklistExporter exporter;", "modifier": "private final", "type": "ChecklistExporter", "declarator": "exporter", "var_name": "exporter"}, {"original_string": "private final ChecklistExporter.ForcedRootUpdatePolicy updatePolicy;", "modifier": "private final", "type": "ChecklistExporter.ForcedRootUpdatePolicy", "declarator": "updatePolicy", "var_name": "updatePolicy"}], "methods": [{"identifier": "selectorFromJson", "parameters": "(final JsonObject json)", "modifiers": "static", "return": "Selector", "signature": "Selector selectorFromJson(final JsonObject json)", "full_signature": "static Selector selectorFromJson(final JsonObject json)", "class_method_signature": "WebsterChecklistTarget.selectorFromJson(final JsonObject json)", "testcase": false, "constructor": false}, {"identifier": "selectorsFromConfigCompactForm", "parameters": "(final JsonObject json)", "modifiers": "static", "return": "List<Selector>", "signature": "List<Selector> selectorsFromConfigCompactForm(final JsonObject json)", "full_signature": "static List<Selector> selectorsFromConfigCompactForm(final JsonObject json)", "class_method_signature": "WebsterChecklistTarget.selectorsFromConfigCompactForm(final JsonObject json)", "testcase": false, "constructor": false}, {"identifier": "WebsterChecklistTarget", "parameters": "(final File checklist,\n                                   final ChecklistExporter exporter,\n                                   final ChecklistExporter.ForcedRootUpdatePolicy updatePolicy)", "modifiers": "private", "return": "", "signature": " WebsterChecklistTarget(final File checklist,\n                                   final ChecklistExporter exporter,\n                                   final ChecklistExporter.ForcedRootUpdatePolicy updatePolicy)", "full_signature": "private  WebsterChecklistTarget(final File checklist,\n                                   final ChecklistExporter exporter,\n                                   final ChecklistExporter.ForcedRootUpdatePolicy updatePolicy)", "class_method_signature": "WebsterChecklistTarget.WebsterChecklistTarget(final File checklist,\n                                   final ChecklistExporter exporter,\n                                   final ChecklistExporter.ForcedRootUpdatePolicy updatePolicy)", "testcase": false, "constructor": true}, {"identifier": "perform", "parameters": "(final Session session)", "modifiers": "@Override public", "return": "void", "signature": "void perform(final Session session)", "full_signature": "@Override public void perform(final Session session)", "class_method_signature": "WebsterChecklistTarget.perform(final Session session)", "testcase": false, "constructor": false}, {"identifier": "fromJson", "parameters": "(final File target, final JsonObject config)", "modifiers": "static", "return": "WebsterChecklistTarget", "signature": "WebsterChecklistTarget fromJson(final File target, final JsonObject config)", "full_signature": "static WebsterChecklistTarget fromJson(final File target, final JsonObject config)", "class_method_signature": "WebsterChecklistTarget.fromJson(final File target, final JsonObject config)", "testcase": false, "constructor": false}], "file": "webster/src/main/java/net/adamcin/oakpal/webster/targets/WebsterChecklistTarget.java"}, "focal_method": {"identifier": "fromJson", "parameters": "(final File target, final JsonObject config)", "modifiers": "static", "return": "WebsterChecklistTarget", "body": "static WebsterChecklistTarget fromJson(final File target, final JsonObject config) {\n        LOGGER.debug(\"[fromJson] fromJson: {}\", config.toString());\n        ChecklistExporter.Builder exporter = new ChecklistExporter.Builder();\n        WebsterChecklistTarget.selectorsFromConfigCompactForm(config)\n                .forEach(selector -> selector.selectOnExporter(exporter));\n        if (config.containsKey(KEY_SELECTORS)) {\n            JsonArray ops = config.getJsonArray(KEY_SELECTORS);\n            List<Selector> selectors = JavaxJson.mapArrayOfObjects(ops, WebsterChecklistTarget::selectorFromJson);\n            selectors.forEach(selector -> selector.selectOnExporter(exporter));\n        }\n        if (config.containsKey(KEY_SCOPE_PATHS)) {\n            List<Rule> scopePaths = Rules.fromJsonArray(config.getJsonArray(KEY_SCOPE_PATHS));\n            exporter.withScopePaths(scopePaths);\n        }\n        if (config.containsKey(KEY_NODE_TYPE_FILTERS)) {\n            List<Rule> nodeTypeFilters = Rules.fromJsonArray(config.getJsonArray(KEY_NODE_TYPE_FILTERS));\n            exporter.withNodeTypeFilters(nodeTypeFilters);\n        }\n        if (config.containsKey(KEY_JCR_NAMESPACES)) {\n            List<JcrNs> jcrNsList = JavaxJson.mapArrayOfObjects(config.getJsonArray(KEY_JCR_NAMESPACES),\n                    JcrNs::fromJson);\n            exporter.withJcrNamespaces(jcrNsList);\n        }\n        if (config.containsKey(KEY_EXPORT_NODETYPES)) {\n            List<String> ntList = JavaxJson.mapArrayOfStrings(config.getJsonArray(KEY_EXPORT_NODETYPES));\n            exporter.withExportNodeTypes(ntList);\n        }\n        ChecklistExporter.ForcedRootUpdatePolicy updatePolicy = null;\n        if (config.containsKey(KEY_UPDATE_POLICY)) {\n            updatePolicy = ChecklistExporter.ForcedRootUpdatePolicy.byName(config.getString(KEY_UPDATE_POLICY));\n        }\n        return new WebsterChecklistTarget(target, exporter.build(), updatePolicy);\n    }", "signature": "WebsterChecklistTarget fromJson(final File target, final JsonObject config)", "full_signature": "static WebsterChecklistTarget fromJson(final File target, final JsonObject config)", "class_method_signature": "WebsterChecklistTarget.fromJson(final File target, final JsonObject config)", "testcase": false, "constructor": false, "invocations": ["debug", "toString", "forEach", "selectorsFromConfigCompactForm", "selectOnExporter", "containsKey", "getJsonArray", "mapArrayOfObjects", "forEach", "selectOnExporter", "containsKey", "fromJsonArray", "getJsonArray", "withScopePaths", "containsKey", "fromJsonArray", "getJsonArray", "withNodeTypeFilters", "containsKey", "mapArrayOfObjects", "getJsonArray", "withJcrNamespaces", "containsKey", "mapArrayOfStrings", "getJsonArray", "withExportNodeTypes", "containsKey", "byName", "getString", "build"]}, "repository": {"repo_id": 155883728, "url": "https://github.com/adamcin/oakpal", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 6, "size": 13349, "license": "licensed"}}