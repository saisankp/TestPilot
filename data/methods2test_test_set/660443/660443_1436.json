{"test_class": {"identifier": "GasteigerPEPEPartialChargesTest", "superclass": "extends CDKTestCase", "interfaces": "", "fields": [{"original_string": "private IChemObjectBuilder      builder = SilentChemObjectBuilder.getInstance();", "modifier": "private", "type": "IChemObjectBuilder", "declarator": "builder = SilentChemObjectBuilder.getInstance()", "var_name": "builder"}, {"original_string": "private LonePairElectronChecker lpcheck = new LonePairElectronChecker();", "modifier": "private", "type": "LonePairElectronChecker", "declarator": "lpcheck = new LonePairElectronChecker()", "var_name": "lpcheck"}], "file": "tool/charges/src/test/java/org/openscience/cdk/charges/GasteigerPEPEPartialChargesTest.java"}, "test_case": {"identifier": "testAssignGasteigerPiPartialCharges_IAtomContainer_Boolean", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testAssignGasteigerPiPartialCharges_IAtomContainer_Boolean() throws Exception {\n        double[] testResult = {0.0, 0.0, 0.0, 0.0, 0.0};\n\n        GasteigerPEPEPartialCharges peoe = new GasteigerPEPEPartialCharges();\n\n        IAtomContainer molecule = builder.newInstance(IAtomContainer.class);\n        molecule.addAtom(new Atom(\"C\"));\n        molecule.addAtom(new Atom(\"F\"));\n        molecule.addBond(0, 1, IBond.Order.SINGLE);\n\n        addExplicitHydrogens(molecule);\n        AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(molecule);\n        lpcheck.saturate(molecule);\n\n        peoe.assignGasteigerPiPartialCharges(molecule, true);\n        for (int i = 0; i < molecule.getAtomCount(); i++) {\n            //logger.debug(\"Charge for atom:\"+i+\" S:\"+mol.getAtomAt(i).getSymbol()+\" Charge:\"+mol.getAtomAt(i).getCharge());\n            Assert.assertEquals(testResult[i], molecule.getAtom(i).getCharge(), 0.01);\n        }\n\n    }", "signature": "void testAssignGasteigerPiPartialCharges_IAtomContainer_Boolean()", "full_signature": "@Test public void testAssignGasteigerPiPartialCharges_IAtomContainer_Boolean()", "class_method_signature": "GasteigerPEPEPartialChargesTest.testAssignGasteigerPiPartialCharges_IAtomContainer_Boolean()", "testcase": true, "constructor": false, "invocations": ["newInstance", "addAtom", "addAtom", "addBond", "addExplicitHydrogens", "percieveAtomTypesAndConfigureAtoms", "saturate", "assignGasteigerPiPartialCharges", "getAtomCount", "assertEquals", "getCharge", "getAtom"]}, "focal_class": {"identifier": "GasteigerPEPEPartialCharges", "superclass": "", "interfaces": "implements IChargeCalculator", "fields": [{"original_string": "private int                 MX_ITERATIONS = 8;", "modifier": "private", "type": "int", "declarator": "MX_ITERATIONS = 8", "var_name": "MX_ITERATIONS"}, {"original_string": "private int                 MX_RESON      = 50;", "modifier": "private", "type": "int", "declarator": "MX_RESON      = 50", "var_name": "MX_RESON"}, {"original_string": "private int                 STEP_SIZE     = 5;", "modifier": "private", "type": "int", "declarator": "STEP_SIZE     = 5", "var_name": "STEP_SIZE"}, {"original_string": "private AtomTypeFactory     factory;", "modifier": "private", "type": "AtomTypeFactory", "declarator": "factory", "var_name": "factory"}, {"original_string": "private static int          ISCHANGEDFC   = 0x1;", "modifier": "private static", "type": "int", "declarator": "ISCHANGEDFC   = 0x1", "var_name": "ISCHANGEDFC"}, {"original_string": "private double              fE            = 1.1;", "modifier": "private", "type": "double", "declarator": "fE            = 1.1", "var_name": "fE"}, {"original_string": "private double              fS            = 0.37;", "modifier": "private", "type": "double", "declarator": "fS            = 0.37", "var_name": "fS"}, {"original_string": "private static ILoggingTool logger        = LoggingToolFactory.createLoggingTool(GasteigerPEPEPartialCharges.class);", "modifier": "private static", "type": "ILoggingTool", "declarator": "logger        = LoggingToolFactory.createLoggingTool(GasteigerPEPEPartialCharges.class)", "var_name": "logger"}], "methods": [{"identifier": "GasteigerPEPEPartialCharges", "parameters": "()", "modifiers": "public", "return": "", "signature": " GasteigerPEPEPartialCharges()", "full_signature": "public  GasteigerPEPEPartialCharges()", "class_method_signature": "GasteigerPEPEPartialCharges.GasteigerPEPEPartialCharges()", "testcase": false, "constructor": true}, {"identifier": "setMaxGasteigerIters", "parameters": "(int iters)", "modifiers": "public", "return": "void", "signature": "void setMaxGasteigerIters(int iters)", "full_signature": "public void setMaxGasteigerIters(int iters)", "class_method_signature": "GasteigerPEPEPartialCharges.setMaxGasteigerIters(int iters)", "testcase": false, "constructor": false}, {"identifier": "setMaxResoStruc", "parameters": "(int numbReson)", "modifiers": "public", "return": "void", "signature": "void setMaxResoStruc(int numbReson)", "full_signature": "public void setMaxResoStruc(int numbReson)", "class_method_signature": "GasteigerPEPEPartialCharges.setMaxResoStruc(int numbReson)", "testcase": false, "constructor": false}, {"identifier": "getMaxGasteigerIters", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMaxGasteigerIters()", "full_signature": "public int getMaxGasteigerIters()", "class_method_signature": "GasteigerPEPEPartialCharges.getMaxGasteigerIters()", "testcase": false, "constructor": false}, {"identifier": "getMaxResoStruc", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMaxResoStruc()", "full_signature": "public int getMaxResoStruc()", "class_method_signature": "GasteigerPEPEPartialCharges.getMaxResoStruc()", "testcase": false, "constructor": false}, {"identifier": "assignGasteigerPiPartialCharges", "parameters": "(IAtomContainer ac, boolean setCharge)", "modifiers": "public", "return": "IAtomContainer", "signature": "IAtomContainer assignGasteigerPiPartialCharges(IAtomContainer ac, boolean setCharge)", "full_signature": "public IAtomContainer assignGasteigerPiPartialCharges(IAtomContainer ac, boolean setCharge)", "class_method_signature": "GasteigerPEPEPartialCharges.assignGasteigerPiPartialCharges(IAtomContainer ac, boolean setCharge)", "testcase": false, "constructor": false}, {"identifier": "calculateCharges", "parameters": "(IAtomContainer container)", "modifiers": "@Override public", "return": "void", "signature": "void calculateCharges(IAtomContainer container)", "full_signature": "@Override public void calculateCharges(IAtomContainer container)", "class_method_signature": "GasteigerPEPEPartialCharges.calculateCharges(IAtomContainer container)", "testcase": false, "constructor": false}, {"identifier": "removingFlagsAromaticity", "parameters": "(IAtomContainer ac)", "modifiers": "private", "return": "IAtomContainer", "signature": "IAtomContainer removingFlagsAromaticity(IAtomContainer ac)", "full_signature": "private IAtomContainer removingFlagsAromaticity(IAtomContainer ac)", "class_method_signature": "GasteigerPEPEPartialCharges.removingFlagsAromaticity(IAtomContainer ac)", "testcase": false, "constructor": false}, {"identifier": "setFlags", "parameters": "(IAtomContainer container, IAtomContainer ac, boolean b)", "modifiers": "private", "return": "IAtomContainer", "signature": "IAtomContainer setFlags(IAtomContainer container, IAtomContainer ac, boolean b)", "full_signature": "private IAtomContainer setFlags(IAtomContainer container, IAtomContainer ac, boolean b)", "class_method_signature": "GasteigerPEPEPartialCharges.setFlags(IAtomContainer container, IAtomContainer ac, boolean b)", "testcase": false, "constructor": false}, {"identifier": "setAntiFlags", "parameters": "(IAtomContainer container, IAtomContainer ac, int number, boolean b)", "modifiers": "private", "return": "IAtomContainer", "signature": "IAtomContainer setAntiFlags(IAtomContainer container, IAtomContainer ac, int number, boolean b)", "full_signature": "private IAtomContainer setAntiFlags(IAtomContainer container, IAtomContainer ac, int number, boolean b)", "class_method_signature": "GasteigerPEPEPartialCharges.setAntiFlags(IAtomContainer container, IAtomContainer ac, int number, boolean b)", "testcase": false, "constructor": false}, {"identifier": "getHyperconjugationInteractions", "parameters": "(IAtomContainer ac, IAtomContainerSet iSet)", "modifiers": "private", "return": "IAtomContainerSet", "signature": "IAtomContainerSet getHyperconjugationInteractions(IAtomContainer ac, IAtomContainerSet iSet)", "full_signature": "private IAtomContainerSet getHyperconjugationInteractions(IAtomContainer ac, IAtomContainerSet iSet)", "class_method_signature": "GasteigerPEPEPartialCharges.getHyperconjugationInteractions(IAtomContainer ac, IAtomContainerSet iSet)", "testcase": false, "constructor": false}, {"identifier": "getElectrostaticPotentialN", "parameters": "(IAtomContainer ac, int atom1, double[] ds)", "modifiers": "private", "return": "double", "signature": "double getElectrostaticPotentialN(IAtomContainer ac, int atom1, double[] ds)", "full_signature": "private double getElectrostaticPotentialN(IAtomContainer ac, int atom1, double[] ds)", "class_method_signature": "GasteigerPEPEPartialCharges.getElectrostaticPotentialN(IAtomContainer ac, int atom1, double[] ds)", "testcase": false, "constructor": false}, {"identifier": "getTopologicalFactors", "parameters": "(IAtomContainer atomContainer, IAtomContainer ac)", "modifiers": "private", "return": "double", "signature": "double getTopologicalFactors(IAtomContainer atomContainer, IAtomContainer ac)", "full_signature": "private double getTopologicalFactors(IAtomContainer atomContainer, IAtomContainer ac)", "class_method_signature": "GasteigerPEPEPartialCharges.getTopologicalFactors(IAtomContainer atomContainer, IAtomContainer ac)", "testcase": false, "constructor": false}, {"identifier": "getStepSize", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getStepSize()", "full_signature": "public int getStepSize()", "class_method_signature": "GasteigerPEPEPartialCharges.getStepSize()", "testcase": false, "constructor": false}, {"identifier": "setStepSize", "parameters": "(int step)", "modifiers": "public", "return": "void", "signature": "void setStepSize(int step)", "full_signature": "public void setStepSize(int step)", "class_method_signature": "GasteigerPEPEPartialCharges.setStepSize(int step)", "testcase": false, "constructor": false}, {"identifier": "assignPiFactors", "parameters": "(IAtomContainerSet setAc)", "modifiers": "private", "return": "double[][]", "signature": "double[][] assignPiFactors(IAtomContainerSet setAc)", "full_signature": "private double[][] assignPiFactors(IAtomContainerSet setAc)", "class_method_signature": "GasteigerPEPEPartialCharges.assignPiFactors(IAtomContainerSet setAc)", "testcase": false, "constructor": false}, {"identifier": "assignrPiMarsilliFactors", "parameters": "(IAtomContainerSet setAc)", "modifiers": "public", "return": "double[][]", "signature": "double[][] assignrPiMarsilliFactors(IAtomContainerSet setAc)", "full_signature": "public double[][] assignrPiMarsilliFactors(IAtomContainerSet setAc)", "class_method_signature": "GasteigerPEPEPartialCharges.assignrPiMarsilliFactors(IAtomContainerSet setAc)", "testcase": false, "constructor": false}, {"identifier": "cleanFlagReactiveCenter", "parameters": "(IAtomContainer ac)", "modifiers": "private", "return": "void", "signature": "void cleanFlagReactiveCenter(IAtomContainer ac)", "full_signature": "private void cleanFlagReactiveCenter(IAtomContainer ac)", "class_method_signature": "GasteigerPEPEPartialCharges.cleanFlagReactiveCenter(IAtomContainer ac)", "testcase": false, "constructor": false}], "file": "tool/charges/src/main/java/org/openscience/cdk/charges/GasteigerPEPEPartialCharges.java"}, "focal_method": {"identifier": "assignGasteigerPiPartialCharges", "parameters": "(IAtomContainer ac, boolean setCharge)", "modifiers": "public", "return": "IAtomContainer", "body": "public IAtomContainer assignGasteigerPiPartialCharges(IAtomContainer ac, boolean setCharge) throws Exception {\n\n        // we save the aromaticity flags for the input molecule so that\n        // we can add them back before we return\n        boolean[] oldBondAromaticity = new boolean[ac.getBondCount()];\n        boolean[] oldAtomAromaticity = new boolean[ac.getAtomCount()];\n        for (int i = 0; i < ac.getAtomCount(); i++)\n            oldAtomAromaticity[i] = ac.getAtom(i).getFlag(CDKConstants.ISAROMATIC);\n        for (int i = 0; i < ac.getBondCount(); i++)\n            oldBondAromaticity[i] = ac.getBond(i).getFlag(CDKConstants.ISAROMATIC);\n\n        IAtomContainerSet setHI = null;\n\n        /* 0: remove charge, and possible flag ac */\n        for (int j = 0; j < ac.getAtomCount(); j++) {\n            ac.getAtom(j).setCharge(0.0);\n            ac.getAtom(j).setFlag(ISCHANGEDFC, false);\n        }\n        for (int j = 0; j < ac.getBondCount(); j++) {\n            ac.getBond(j).setFlag(ISCHANGEDFC, false);\n        }\n\n        /* 1: detect resonance structure */\n        StructureResonanceGenerator gR1 = new StructureResonanceGenerator();/*\n                                                                             * according\n                                                                             * G\n                                                                             * .\n                                                                             * should\n                                                                             * be\n                                                                             * integrated\n                                                                             * the\n                                                                             * breaking\n                                                                             * bonding\n                                                                             */\n        List<IReactionProcess> reactionList1 = gR1.getReactions();\n        List<IParameterReact> paramList1 = new ArrayList<IParameterReact>();\n        IParameterReact param = new SetReactionCenter();\n        param.setParameter(Boolean.TRUE);\n        paramList1.add(param);\n        HeterolyticCleavagePBReaction reactionHCPB = new HeterolyticCleavagePBReaction();\n        reactionHCPB.setParameterList(paramList1);\n        reactionList1.add(new SharingAnionReaction());\n        Iterator<IReactionProcess> itReaction = reactionList1.iterator();\n        while (itReaction.hasNext()) {\n            IReactionProcess reaction = itReaction.next();\n            reaction.setParameterList(paramList1);\n        }\n        gR1.setReactions(reactionList1);\n\n        StructureResonanceGenerator gR2 = new StructureResonanceGenerator();/*\n                                                                             * according\n                                                                             * G\n                                                                             * .\n                                                                             * should\n                                                                             * be\n                                                                             * integrated\n                                                                             * the\n                                                                             * breaking\n                                                                             * bonding\n                                                                             */\n        gR2.setMaximalStructures(MX_RESON);\n        List<IReactionProcess> reactionList2 = gR2.getReactions();\n        List<IParameterReact> paramList = new ArrayList<IParameterReact>();\n        IParameterReact paramA = new SetReactionCenter();\n        paramA.setParameter(Boolean.TRUE);\n        paramList.add(paramA);\n        reactionList2.add(new HeterolyticCleavagePBReaction());\n        reactionList2.add(new SharingAnionReaction());\n        itReaction = reactionList2.iterator();\n        while (itReaction.hasNext()) {\n            IReactionProcess reaction = itReaction.next();\n            reaction.setParameterList(paramList);\n        }\n        gR2.setReactions(reactionList2);\n\n        /* find resonance containers, which eliminates the repetitions */\n        StructureResonanceGenerator gRN = new StructureResonanceGenerator();/*\n                                                                             * according\n                                                                             * G\n                                                                             * .\n                                                                             * should\n                                                                             * be\n                                                                             * integrated\n                                                                             * the\n                                                                             * breaking\n                                                                             * bonding\n                                                                             */\n        IAtomContainerSet acSet = gRN.getContainers(removingFlagsAromaticity(ac));\n        //\t\tIAtomContainerSet acSet = ConjugatedPiSystemsDetector.detect(removingFlagsAromaticity(ac));\n\n        IAtomContainerSet iSet = ac.getBuilder().newInstance(IAtomContainerSet.class);\n        iSet.addAtomContainer(ac);\n\n        if (acSet != null) for (Iterator<IAtomContainer> it = acSet.atomContainers().iterator(); it.hasNext();) {\n            IAtomContainer container = it.next();\n            ac = setFlags(container, ac, true);\n\n            // Aromatic don't break its double bond homolytically\n            if (Aromaticity.cdkLegacy().apply(ac))\n                reactionList1.remove(reactionHCPB);\n            else\n                reactionList1.add(reactionHCPB);\n\n            IAtomContainerSet a = gR1.getStructures(removingFlagsAromaticity(ac));\n            if (a.getAtomContainerCount() > 1) {\n                for (int j = 1; j < a.getAtomContainerCount(); j++) { // the first is already added\n                    iSet.addAtomContainer(a.getAtomContainer(j));\n                }\n            }\n            ac = setFlags(container, ac, false);\n\n            /* processing for bonds which are not in resonance */\n            for (int number = 0; number < ac.getBondCount(); number++) {\n                IAtomContainer aa = setAntiFlags(container, ac, number, true);\n                if (aa != null) {\n                    IAtomContainerSet ab = gR2.getStructures(aa);\n                    if (ab.getAtomContainerCount() > 1) for (int j = 1; j < ab.getAtomContainerCount(); j++) { // the first is already added\n                            iSet.addAtomContainer(ab.getAtomContainer(j));\n                        }\n                    ac = setAntiFlags(container, aa, number, false);\n                }\n            }\n        }\n\n        /* detect hyperconjugation interactions */\n        setHI = getHyperconjugationInteractions(ac, iSet);\n\n        if (setHI != null) {\n            if (setHI.getAtomContainerCount() != 0) iSet.add(setHI);\n            logger.debug(\"setHI: \" + iSet.getAtomContainerCount());\n        }\n        if (iSet.getAtomContainerCount() < 2) {\n            for (int i = 0; i < ac.getAtomCount(); i++)\n                ac.getAtom(i).setFlag(CDKConstants.ISAROMATIC, oldAtomAromaticity[i]);\n            for (int i = 0; i < ac.getBondCount(); i++)\n                ac.getBond(i).setFlag(CDKConstants.ISAROMATIC, oldBondAromaticity[i]);\n            return ac;\n        }\n\n        /*\n         * 2: search whose atoms which don't keep their formal charge and set flags\n         */\n        double[][] sumCharges = new double[iSet.getAtomContainerCount()][ac.getAtomCount()];\n        for (int i = 1; i < iSet.getAtomContainerCount(); i++) {\n            IAtomContainer iac = iSet.getAtomContainer(i);\n            for (int j = 0; j < iac.getAtomCount(); j++)\n                sumCharges[i][j] = iac.getAtom(j).getFormalCharge();\n\n        }\n\n        for (int i = 1; i < iSet.getAtomContainerCount(); i++) {\n            IAtomContainer iac = iSet.getAtomContainer(i);\n            int count = 0;\n            for (int j = 0; j < ac.getAtomCount(); j++)\n                if (count < 2) if (sumCharges[i][j] != ac.getAtom(j).getFormalCharge()) {\n                    ac.getAtom(j).setFlag(ISCHANGEDFC, true);\n                    iac.getAtom(j).setFlag(ISCHANGEDFC, true);\n                    count++; /* TODO- error */\n                }\n        }\n\n        /* 3: set sigma charge (PEOE). Initial start point */\n        GasteigerMarsiliPartialCharges peoe = new GasteigerMarsiliPartialCharges();;\n        peoe.setMaxGasteigerIters(6);\n        IAtomContainer acCloned;\n\n        double[][] gasteigerFactors = assignPiFactors(iSet);//a,b,c,deoc,chi,q\n\n        /* 4: calculate topological weight factors Wt=fQ*fB*fA */\n        double[] Wt = new double[iSet.getAtomContainerCount() - 1];\n        for (int i = 1; i < iSet.getAtomContainerCount(); i++) {\n            Wt[i - 1] = getTopologicalFactors(iSet.getAtomContainer(i), ac);\n            logger.debug(\", W:\" + Wt[i - 1]);\n            try {\n                acCloned = (IAtomContainer) iSet.getAtomContainer(i).clone();\n\n                acCloned = peoe.assignGasteigerMarsiliSigmaPartialCharges(acCloned, true);\n                for (int j = 0; j < acCloned.getAtomCount(); j++)\n                    if (iSet.getAtomContainer(i).getAtom(j).getFlag(ISCHANGEDFC)) {\n                        gasteigerFactors[i][STEP_SIZE * j + j + 5] = acCloned.getAtom(j).getCharge();\n                    }\n            } catch (CloneNotSupportedException e) {\n                throw new CDKException(\"Could not clone ac\", e);\n            }\n        }\n\n        /*\n         * calculate electronegativity for changed atoms and make the difference\n         * between whose atoms which change their formal charge\n         */\n        for (int iter = 0; iter < MX_ITERATIONS; iter++) {\n            //\t\tfor (int iter = 0; iter < 1; iter++) {\n            for (int k = 1; k < iSet.getAtomContainerCount(); k++) {\n                IAtomContainer iac = iSet.getAtomContainer(k);\n                double[] electronegativity = new double[2];\n                int count = 0;\n                int atom1 = 0;\n                int atom2 = 0;\n                for (int j = 0; j < iac.getAtomCount(); j++) {\n                    if (count == 2) /*\n                                     * The change of sign is product of only two\n                                     * atoms, is not true\n                                     */\n                    break;\n                    if (iac.getAtom(j).getFlag(ISCHANGEDFC)) {\n                        logger.debug(\"Atom: \" + j + \", S:\" + iac.getAtom(j).getSymbol() + \", C:\"\n                                + iac.getAtom(j).getFormalCharge());\n                        if (count == 0)\n                            atom1 = j;\n                        else\n                            atom2 = j;\n\n                        double q1 = gasteigerFactors[k][STEP_SIZE * j + j + 5];\n                        electronegativity[count] = gasteigerFactors[k][STEP_SIZE * j + j + 2] * q1 * q1\n                                + gasteigerFactors[k][STEP_SIZE * j + j + 1] * q1\n                                + gasteigerFactors[k][STEP_SIZE * j + j];\n                        logger.debug(\"e:\" + electronegativity[count] + \",q1: \" + q1 + \", c:\"\n                                + gasteigerFactors[k][STEP_SIZE * j + j + 2] + \", b:\"\n                                + gasteigerFactors[k][STEP_SIZE * j + j + 1] + \", a:\"\n                                + gasteigerFactors[k][STEP_SIZE * j + j]);\n                        count++;\n                    }\n                }\n                logger.debug(\"Atom1:\" + atom1 + \",Atom2:\" + atom2);\n                /* difference of electronegativity 1 lower */\n                double max1 = Math.max(electronegativity[0], electronegativity[1]);\n                double min1 = Math.min(electronegativity[0], electronegativity[1]);\n                double DX = 1.0;\n                if (electronegativity[0] < electronegativity[1])\n                    DX = gasteigerFactors[k][STEP_SIZE * atom1 + atom1 + 3];\n                else\n                    DX = gasteigerFactors[k][STEP_SIZE * atom2 + atom2 + 3];\n\n                double Dq = (max1 - min1) / DX;\n                logger.debug(\"Dq : \" + Dq + \" = (\" + max1 + \"-\" + min1 + \")/\" + DX);\n                double epN1 = getElectrostaticPotentialN(iac, atom1, gasteigerFactors[k]);\n                double epN2 = getElectrostaticPotentialN(iac, atom2, gasteigerFactors[k]);\n                double SumQN = Math.abs(epN1 - epN2);\n                logger.debug(\"sum(\" + SumQN + \") = (\" + epN1 + \") - (\" + epN2 + \")\");\n\n                /* electronic weight */\n                double WE = Dq + fE * SumQN;\n                logger.debug(\"WE : \" + WE + \" = Dq(\" + Dq + \")+fE(\" + fE + \")*SumQN(\" + SumQN);\n                int iTE = iter + 1;\n\n                /* total topological */\n                double W = WE * Wt[k - 1] * fS / (iTE);\n                logger.debug(\"W : \" + W + \" = WE(\" + WE + \")*Wt(\" + Wt[k - 1] + \")*fS(\" + fS + \")/iter(\" + iTE\n                        + \"), atoms: \" + atom1 + \", \" + atom2);\n\n                /* iac == new structure, ac == old structure */\n                /* atom1 */\n                if (iac.getAtom(atom1).getFormalCharge() == 0) {\n                    if (ac.getAtom(atom1).getFormalCharge() < 0) {\n                        gasteigerFactors[k][STEP_SIZE * atom1 + atom1 + 5] = -1 * W;\n                    } else {\n                        gasteigerFactors[k][STEP_SIZE * atom1 + atom1 + 5] = W;\n                    }\n                } else if (iac.getAtom(atom1).getFormalCharge() > 0) {\n                    gasteigerFactors[k][STEP_SIZE * atom1 + atom1 + 5] = W;\n                } else {\n                    gasteigerFactors[k][STEP_SIZE * atom1 + atom1 + 5] = -1 * W;\n                }\n                /* atom2 */\n                if (iac.getAtom(atom2).getFormalCharge() == 0) {\n                    if (ac.getAtom(atom2).getFormalCharge() < 0) {\n                        gasteigerFactors[k][STEP_SIZE * atom2 + atom2 + 5] = -1 * W;\n                    } else {\n                        gasteigerFactors[k][STEP_SIZE * atom2 + atom2 + 5] = W;\n                    }\n                } else if (iac.getAtom(atom2).getFormalCharge() > 0) {\n                    gasteigerFactors[k][STEP_SIZE * atom2 + atom2 + 5] = W;\n                } else {\n                    gasteigerFactors[k][STEP_SIZE * atom2 + atom2 + 5] = -1 * W;\n                }\n\n            }\n            for (int k = 1; k < iSet.getAtomContainerCount(); k++) {\n\n                for (int i = 0; i < ac.getAtomCount(); i++)\n                    if (iSet.getAtomContainer(k).getAtom(i).getFlag(ISCHANGEDFC)) {\n                        double charge = ac.getAtom(i).getCharge();\n                        double chargeT = 0.0;\n                        chargeT = charge + gasteigerFactors[k][STEP_SIZE * i + i + 5];\n                        logger.debug(\"i<|\" + ac.getAtom(i).getSymbol() + \", \" + chargeT + \"=c:\" + charge + \"+g: \"\n                                + gasteigerFactors[k][STEP_SIZE * i + i + 5]);\n                        ac.getAtom(i).setCharge(chargeT);\n                    }\n            }\n\n        }// iterations\n        logger.debug(\"final\");\n\n        // before getting back we should set back the aromatic flags\n        for (int i = 0; i < ac.getAtomCount(); i++)\n            ac.getAtom(i).setFlag(CDKConstants.ISAROMATIC, oldAtomAromaticity[i]);\n        for (int i = 0; i < ac.getBondCount(); i++)\n            ac.getBond(i).setFlag(CDKConstants.ISAROMATIC, oldBondAromaticity[i]);\n\n        return ac;\n\n    }", "signature": "IAtomContainer assignGasteigerPiPartialCharges(IAtomContainer ac, boolean setCharge)", "full_signature": "public IAtomContainer assignGasteigerPiPartialCharges(IAtomContainer ac, boolean setCharge)", "class_method_signature": "GasteigerPEPEPartialCharges.assignGasteigerPiPartialCharges(IAtomContainer ac, boolean setCharge)", "testcase": false, "constructor": false, "invocations": ["getBondCount", "getAtomCount", "getAtomCount", "getFlag", "getAtom", "getBondCount", "getFlag", "getBond", "getAtomCount", "setCharge", "getAtom", "setFlag", "getAtom", "getBondCount", "setFlag", "getBond", "getReactions", "setParameter", "add", "setParameterList", "add", "iterator", "hasNext", "next", "setParameterList", "setReactions", "setMaximalStructures", "getReactions", "setParameter", "add", "add", "add", "iterator", "hasNext", "next", "setParameterList", "setReactions", "getContainers", "removingFlagsAromaticity", "newInstance", "getBuilder", "addAtomContainer", "iterator", "atomContainers", "hasNext", "next", "setFlags", "apply", "cdkLegacy", "remove", "add", "getStructures", "removingFlagsAromaticity", "getAtomContainerCount", "getAtomContainerCount", "addAtomContainer", "getAtomContainer", "setFlags", "getBondCount", "setAntiFlags", "getStructures", "getAtomContainerCount", "getAtomContainerCount", "addAtomContainer", "getAtomContainer", "setAntiFlags", "getHyperconjugationInteractions", "getAtomContainerCount", "add", "debug", "getAtomContainerCount", "getAtomContainerCount", "getAtomCount", "setFlag", "getAtom", "getBondCount", "setFlag", "getBond", "getAtomContainerCount", "getAtomCount", "getAtomContainerCount", "getAtomContainer", "getAtomCount", "getFormalCharge", "getAtom", "getAtomContainerCount", "getAtomContainer", "getAtomCount", "getFormalCharge", "getAtom", "setFlag", "getAtom", "setFlag", "getAtom", "setMaxGasteigerIters", "assignPiFactors", "getAtomContainerCount", "getAtomContainerCount", "getTopologicalFactors", "getAtomContainer", "debug", "clone", "getAtomContainer", "assignGasteigerMarsiliSigmaPartialCharges", "getAtomCount", "getFlag", "getAtom", "getAtomContainer", "getCharge", "getAtom", "getAtomContainerCount", "getAtomContainer", "getAtomCount", "getFlag", "getAtom", "debug", "getSymbol", "getAtom", "getFormalCharge", "getAtom", "debug", "debug", "max", "min", "debug", "getElectrostaticPotentialN", "getElectrostaticPotentialN", "abs", "debug", "debug", "debug", "getFormalCharge", "getAtom", "getFormalCharge", "getAtom", "getFormalCharge", "getAtom", "getFormalCharge", "getAtom", "getFormalCharge", "getAtom", "getFormalCharge", "getAtom", "getAtomContainerCount", "getAtomCount", "getFlag", "getAtom", "getAtomContainer", "getCharge", "getAtom", "debug", "getSymbol", "getAtom", "setCharge", "getAtom", "debug", "getAtomCount", "setFlag", "getAtom", "getBondCount", "setFlag", "getBond"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}