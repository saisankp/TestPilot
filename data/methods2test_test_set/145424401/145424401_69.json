{"test_class": {"identifier": "PipWrapperTest", "superclass": "", "interfaces": "", "fields": [], "file": "lang-python/src/test/java/org/eclipse/steady/python/pip/PipWrapperTest.java"}, "test_case": {"identifier": "testGetListPackages", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testGetListPackages() throws ProcessWrapperException, FileAnalysisException {\n    VulasConfiguration.getGlobal().setProperty(ThreadUtil.NO_OF_THREADS, \"AUTO\");\n    final PipWrapper pip = new PipWrapper();\n    Set<PipInstalledPackage> packs = null;\n    try {\n      packs = pip.getListPackages();\n    } catch (IOException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    } catch (InterruptedException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    }\n    assertTrue(packs.size() > 0);\n  }", "signature": "void testGetListPackages()", "full_signature": "@Test public void testGetListPackages()", "class_method_signature": "PipWrapperTest.testGetListPackages()", "testcase": true, "constructor": false, "invocations": ["setProperty", "getGlobal", "getListPackages", "printStackTrace", "printStackTrace", "assertTrue", "size"]}, "focal_class": {"identifier": "PipWrapper", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = org.apache.logging.log4j.LogManager.getLogger();", "modifier": "private static final", "type": "Logger", "declarator": "log = org.apache.logging.log4j.LogManager.getLogger()", "var_name": "log"}, {"original_string": "static final Pattern DOWNLOAD_PATTERN = Pattern.compile(\"^\\\\s*Downloading\\\\s*(http\\\\S*).*$\");", "modifier": "static final", "type": "Pattern", "declarator": "DOWNLOAD_PATTERN = Pattern.compile(\"^\\\\s*Downloading\\\\s*(http\\\\S*).*$\")", "var_name": "DOWNLOAD_PATTERN"}, {"original_string": "static final Pattern SAVED_PATTERN_1 =\n      Pattern.compile(\"^\\\\s*File was already downloaded\\\\s*(.*)$\");", "modifier": "static final", "type": "Pattern", "declarator": "SAVED_PATTERN_1 =\n      Pattern.compile(\"^\\\\s*File was already downloaded\\\\s*(.*)$\")", "var_name": "SAVED_PATTERN_1"}, {"original_string": "static final Pattern SAVED_PATTERN_2 = Pattern.compile(\"^\\\\s*Saved\\\\s*(.*)$\");", "modifier": "static final", "type": "Pattern", "declarator": "SAVED_PATTERN_2 = Pattern.compile(\"^\\\\s*Saved\\\\s*(.*)$\")", "var_name": "SAVED_PATTERN_2"}, {"original_string": "static final String PACK_PATTERN_REGEX = \".*<pack>-<version>.*\";", "modifier": "static final", "type": "String", "declarator": "PACK_PATTERN_REGEX = \".*<pack>-<version>.*\"", "var_name": "PACK_PATTERN_REGEX"}, {"original_string": "private Path pathToPip = null;", "modifier": "private", "type": "Path", "declarator": "pathToPip = null", "var_name": "pathToPip"}, {"original_string": "private Path logDir = null;", "modifier": "private", "type": "Path", "declarator": "logDir = null", "var_name": "logDir"}, {"original_string": "private StringList ignorePacks = new StringList();", "modifier": "private", "type": "StringList", "declarator": "ignorePacks = new StringList()", "var_name": "ignorePacks"}], "methods": [{"identifier": "PipWrapper", "parameters": "()", "modifiers": "public", "return": "", "signature": " PipWrapper()", "full_signature": "public  PipWrapper()", "class_method_signature": "PipWrapper.PipWrapper()", "testcase": false, "constructor": true}, {"identifier": "PipWrapper", "parameters": "(Path _path_to_pip, Path _log_dir)", "modifiers": "public", "return": "", "signature": " PipWrapper(Path _path_to_pip, Path _log_dir)", "full_signature": "public  PipWrapper(Path _path_to_pip, Path _log_dir)", "class_method_signature": "PipWrapper.PipWrapper(Path _path_to_pip, Path _log_dir)", "testcase": false, "constructor": true}, {"identifier": "ignorePackage", "parameters": "(String _p)", "modifiers": "private", "return": "boolean", "signature": "boolean ignorePackage(String _p)", "full_signature": "private boolean ignorePackage(String _p)", "class_method_signature": "PipWrapper.ignorePackage(String _p)", "testcase": false, "constructor": false}, {"identifier": "isAvailable", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isAvailable()", "full_signature": "public boolean isAvailable()", "class_method_signature": "PipWrapper.isAvailable()", "testcase": false, "constructor": false}, {"identifier": "installPackages", "parameters": "(Path _project)", "modifiers": "public", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> installPackages(Path _project)", "full_signature": "public Set<PipInstalledPackage> installPackages(Path _project)", "class_method_signature": "PipWrapper.installPackages(Path _project)", "testcase": false, "constructor": false}, {"identifier": "getFreezePackages", "parameters": "()", "modifiers": "public", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> getFreezePackages()", "full_signature": "public Set<PipInstalledPackage> getFreezePackages()", "class_method_signature": "PipWrapper.getFreezePackages()", "testcase": false, "constructor": false}, {"identifier": "parsePipFreezeOutput", "parameters": "(Path _file)", "modifiers": "private", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> parsePipFreezeOutput(Path _file)", "full_signature": "private Set<PipInstalledPackage> parsePipFreezeOutput(Path _file)", "class_method_signature": "PipWrapper.parsePipFreezeOutput(Path _file)", "testcase": false, "constructor": false}, {"identifier": "getListPackages", "parameters": "()", "modifiers": "public", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> getListPackages()", "full_signature": "public Set<PipInstalledPackage> getListPackages()", "class_method_signature": "PipWrapper.getListPackages()", "testcase": false, "constructor": false}, {"identifier": "parsePipListOutput", "parameters": "(Path _file)", "modifiers": "private", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> parsePipListOutput(Path _file)", "full_signature": "private Set<PipInstalledPackage> parsePipListOutput(Path _file)", "class_method_signature": "PipWrapper.parsePipListOutput(Path _file)", "testcase": false, "constructor": false}, {"identifier": "deserializePipListOutput", "parameters": "(Path _file)", "modifiers": "private", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> deserializePipListOutput(Path _file)", "full_signature": "private Set<PipInstalledPackage> deserializePipListOutput(Path _file)", "class_method_signature": "PipWrapper.deserializePipListOutput(Path _file)", "testcase": false, "constructor": false}, {"identifier": "parsePipShowOutput", "parameters": "(Path _file)", "modifiers": "private", "return": "Map<String, String>", "signature": "Map<String, String> parsePipShowOutput(Path _file)", "full_signature": "private Map<String, String> parsePipShowOutput(Path _file)", "class_method_signature": "PipWrapper.parsePipShowOutput(Path _file)", "testcase": false, "constructor": false}, {"identifier": "searchDownloadInfo", "parameters": "(Set<PipInstalledPackage> _packs, String _out)", "modifiers": "", "return": "void", "signature": "void searchDownloadInfo(Set<PipInstalledPackage> _packs, String _out)", "full_signature": " void searchDownloadInfo(Set<PipInstalledPackage> _packs, String _out)", "class_method_signature": "PipWrapper.searchDownloadInfo(Set<PipInstalledPackage> _packs, String _out)", "testcase": false, "constructor": false}, {"identifier": "searchDownloadInfo", "parameters": "(PipInstalledPackage _p, String _out)", "modifiers": "private", "return": "void", "signature": "void searchDownloadInfo(PipInstalledPackage _p, String _out)", "full_signature": "private void searchDownloadInfo(PipInstalledPackage _p, String _out)", "class_method_signature": "PipWrapper.searchDownloadInfo(PipInstalledPackage _p, String _out)", "testcase": false, "constructor": false}], "file": "lang-python/src/main/java/org/eclipse/steady/python/pip/PipWrapper.java"}, "focal_method": {"identifier": "getListPackages", "parameters": "()", "modifiers": "public", "return": "Set<PipInstalledPackage>", "body": "public Set<PipInstalledPackage> getListPackages()\n      throws ProcessWrapperException, IOException, InterruptedException {\n    final StopWatch sw = new StopWatch(\"pip list\").start();\n\n    // Try legacy format\n    ProcessWrapper pw =\n        new ProcessWrapper()\n            .setCommand(this.pathToPip, \"list\", \"--format\", \"legacy\")\n            .setPath(logDir);\n    Thread t = new Thread(pw, \"pip\");\n    t.start();\n    t.join();\n\n    Set<PipInstalledPackage> packages = null;\n    if (pw.terminatedWithSuccess()) {\n      packages = this.parsePipListOutput(pw.getOutFile());\n    }\n    // Try JSON format\n    else {\n      log.info(\"Legacy format did not work, trying JSON format...\");\n      pw =\n          new ProcessWrapper()\n              .setCommand(this.pathToPip, \"list\", \"--format\", \"json\")\n              .setPath(logDir);\n      t = new Thread(pw, \"pip\");\n      t.start();\n      t.join();\n      if (pw.terminatedWithSuccess()) packages = this.deserializePipListOutput(pw.getOutFile());\n    }\n\n    // Collect package details\n    if (packages != null) {\n      log.info(\"Found [\" + packages.size() + \"] pip packages:\");\n      for (PipInstalledPackage pack : packages) log.info(\"    \" + pack);\n\n      // Call pip show in separate threads\n      final ExecutorService pool =\n          Executors.newFixedThreadPool(ThreadUtil.getNoThreads(2)); // newSingleThreadExecutor();\n      final Set<Future<PipInstalledPackage>> futures = new HashSet<Future<PipInstalledPackage>>();\n      for (PipInstalledPackage pack : packages) {\n        futures.add(pool.submit(new PipShow(pack)));\n      }\n      pool.shutdown();\n      try {\n        while (!pool.awaitTermination(10, TimeUnit.SECONDS)) {\n          int done = 0;\n          for (Future<PipInstalledPackage> f : futures) {\n            if (f.isDone()) done++;\n          }\n          sw.lap(\"[\" + done + \"/\" + futures.size() + \"] pip jobs are done\");\n        }\n      } catch (InterruptedException e) {\n        PipWrapper.log.error(\"Interrupt exception\");\n      }\n    } else {\n      log.warn(\"No pip packages found with pip list\");\n    }\n\n    sw.stop();\n    return packages;\n  }", "signature": "Set<PipInstalledPackage> getListPackages()", "full_signature": "public Set<PipInstalledPackage> getListPackages()", "class_method_signature": "PipWrapper.getListPackages()", "testcase": false, "constructor": false, "invocations": ["start", "setPath", "setCommand", "start", "join", "terminatedWithSuccess", "parsePipListOutput", "getOutFile", "info", "setPath", "setCommand", "start", "join", "terminatedWithSuccess", "deserializePipListOutput", "getOutFile", "info", "size", "info", "newFixedThreadPool", "getNoThreads", "add", "submit", "shutdown", "awaitTermination", "isDone", "lap", "size", "error", "warn", "stop"]}, "repository": {"repo_id": 145424401, "url": "https://github.com/eclipse/steady", "stars": 353, "created": "8/20/2018 1:54:15 PM +00:00", "updates": "2020-01-25T08:37:00+00:00", "fork": "False", "license": "licensed"}}