{"test_class": {"identifier": "FromSubsetAtomsTest", "superclass": "", "interfaces": "", "fields": [], "file": "func/src/test/java/uk/ac/ebi/beam/FromSubsetAtomsTest.java"}, "test_case": {"identifier": "bracketAtom", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void bracketAtom() {\n        // should provide identity of bracket atom\n        Atom input = new AtomImpl.BracketAtom(Element.Carbon, 1, 0);\n        Atom output = FromSubsetAtoms.fromSubset(input, 0, 0);\n        Assert.assertThat(input, CoreMatchers.is(CoreMatchers\n                                                         .sameInstance(output)));\n    }", "signature": "void bracketAtom()", "full_signature": "@Test public void bracketAtom()", "class_method_signature": "FromSubsetAtomsTest.bracketAtom()", "testcase": true, "constructor": false, "invocations": ["fromSubset", "assertThat", "is", "sameInstance"]}, "focal_class": {"identifier": "FromSubsetAtoms", "superclass": "extends AbstractFunction<Graph, Graph>", "interfaces": "", "fields": [], "methods": [{"identifier": "apply", "parameters": "(Graph g)", "modifiers": "public", "return": "Graph", "signature": "Graph apply(Graph g)", "full_signature": "public Graph apply(Graph g)", "class_method_signature": "FromSubsetAtoms.apply(Graph g)", "testcase": false, "constructor": false}, {"identifier": "fromSubset", "parameters": "(Atom a, int sum, int deg)", "modifiers": "static", "return": "Atom", "signature": "Atom fromSubset(Atom a, int sum, int deg)", "full_signature": "static Atom fromSubset(Atom a, int sum, int deg)", "class_method_signature": "FromSubsetAtoms.fromSubset(Atom a, int sum, int deg)", "testcase": false, "constructor": false}], "file": "func/src/main/java/uk/ac/ebi/beam/FromSubsetAtoms.java"}, "focal_method": {"identifier": "fromSubset", "parameters": "(Atom a, int sum, int deg)", "modifiers": "static", "return": "Atom", "body": "static Atom fromSubset(Atom a, int sum, int deg) {\n\n        // atom is already a non-subset atom\n        if (!a.subset())\n            return a;\n\n        Element e = a.element();\n        if (a.aromatic() && deg <= sum)\n            sum++;\n        int hCount = a.aromatic() ? Element.implicitAromHydrogenCount(e, sum)\n                                  : Element.implicitHydrogenCount(e, sum);\n\n        // XXX: if there was an odd number of availableElectrons there was an odd number\n        // or aromatic bonds (usually 1 or 3) - if there was one it was\n        // only a single bond it's likely a spouting from a ring - otherwise\n        // someones making our life difficult (e.g. c1=cc=cc=c1) in which we\n        // 'give' back 2 free availableElectrons for use indeterminacy the hCount\n//        int hCount = (electrons & 0x1) == 1 ? deg > 1 ? (electrons + 2) / 2\n//                                                      : electrons / 2\n//                                            : electrons / 2;\n\n\n        return new AtomImpl.BracketAtom(-1,\n                                        a.element(),\n                                        hCount,\n                                        0,\n                                        0,\n                                        a.aromatic());\n    }", "signature": "Atom fromSubset(Atom a, int sum, int deg)", "full_signature": "static Atom fromSubset(Atom a, int sum, int deg)", "class_method_signature": "FromSubsetAtoms.fromSubset(Atom a, int sum, int deg)", "testcase": false, "constructor": false, "invocations": ["subset", "element", "aromatic", "aromatic", "implicitAromHydrogenCount", "implicitHydrogenCount", "element", "aromatic"]}, "repository": {"repo_id": 12061606, "url": "https://github.com/johnmay/beam", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 19, "size": 825, "license": "licensed"}}