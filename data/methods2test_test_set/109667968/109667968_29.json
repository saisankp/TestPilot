{"test_class": {"identifier": "TrackingServiceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Context context;", "modifier": "private", "type": "Context", "declarator": "context", "var_name": "context"}, {"original_string": "private ServiceController<TrackingService> controller;", "modifier": "private", "type": "ServiceController<TrackingService>", "declarator": "controller", "var_name": "controller"}, {"original_string": "private String connectionStatus = \"\";", "modifier": "private", "type": "String", "declarator": "connectionStatus = \"\"", "var_name": "connectionStatus"}, {"original_string": "private Location locationDeparture;", "modifier": "private", "type": "Location", "declarator": "locationDeparture", "var_name": "locationDeparture"}, {"original_string": "private Location location_1;", "modifier": "private", "type": "Location", "declarator": "location_1", "var_name": "location_1"}, {"original_string": "private Location location_2;", "modifier": "private", "type": "Location", "declarator": "location_2", "var_name": "location_2"}, {"original_string": "private Location location_3;", "modifier": "private", "type": "Location", "declarator": "location_3", "var_name": "location_3"}], "file": "library/src/test/java/io/ona/kujaku/services/TrackingServiceTest.java"}, "test_case": {"identifier": "testStartAndBindService", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testStartAndBindService() throws InterruptedException {\n        CountDownLatch latch1 = new CountDownLatch(1);\n        CountDownLatch latch2 = new CountDownLatch(1);\n\n        ServiceConnection connection = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                connectionStatus = \"connected\";\n                latch1.countDown();\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                connectionStatus = \"disconnected\";\n                latch2.countDown();\n            }\n        };\n\n        assertEquals(connectionStatus, \"\");\n        TrackingService.startAndBindService(context, MapActivity.class, connection, new TrackingServiceHighAccuracyOptions());\n        latch1.await();\n        assertEquals(connectionStatus, \"connected\");\n\n        TrackingService.stopAndUnbindService(context, connection);\n        latch2.await();\n        assertEquals(connectionStatus, \"disconnected\");\n    }", "signature": "void testStartAndBindService()", "full_signature": "@Test public void testStartAndBindService()", "class_method_signature": "TrackingServiceTest.testStartAndBindService()", "testcase": true, "constructor": false, "invocations": ["countDown", "countDown", "assertEquals", "startAndBindService", "await", "assertEquals", "stopAndUnbindService", "await", "assertEquals"]}, "focal_class": {"identifier": "TrackingService", "superclass": "extends Service", "interfaces": "", "fields": [{"original_string": "private final static String TAG = TrackingService.class.getSimpleName();", "modifier": "private final static", "type": "String", "declarator": "TAG = TrackingService.class.getSimpleName()", "var_name": "TAG"}, {"original_string": "private final static String PARTIAL_WAKE_LOCK_TAG = \"TrackingService:PartialWakeLock\";", "modifier": "private final static", "type": "String", "declarator": "PARTIAL_WAKE_LOCK_TAG = \"TrackingService:PartialWakeLock\"", "var_name": "PARTIAL_WAKE_LOCK_TAG"}, {"original_string": "private final static String ACTIVITY_EXTRA_NAME = \"launch_activity_class\";", "modifier": "private final static", "type": "String", "declarator": "ACTIVITY_EXTRA_NAME = \"launch_activity_class\"", "var_name": "ACTIVITY_EXTRA_NAME"}, {"original_string": "private final static String OPTIONS_EXTRA_NAME = \"tracking_service_options\";", "modifier": "private final static", "type": "String", "declarator": "OPTIONS_EXTRA_NAME = \"tracking_service_options\"", "var_name": "OPTIONS_EXTRA_NAME"}, {"original_string": "private final static long WAIT_TIME_SERVICE_THREAD = 400;", "modifier": "private final static", "type": "long", "declarator": "WAIT_TIME_SERVICE_THREAD = 400", "var_name": "WAIT_TIME_SERVICE_THREAD"}, {"original_string": "private static volatile CountDownLatch serviceThreadRunningLatch;", "modifier": "private static volatile", "type": "CountDownLatch", "declarator": "serviceThreadRunningLatch", "var_name": "serviceThreadRunningLatch"}, {"original_string": "private static volatile int serviceStatus = TrackingServiceStatus.STOPPED;", "modifier": "private static volatile", "type": "int", "declarator": "serviceStatus = TrackingServiceStatus.STOPPED", "var_name": "serviceStatus"}, {"original_string": "private volatile LocationManager locationManager;", "modifier": "private volatile", "type": "LocationManager", "declarator": "locationManager", "var_name": "locationManager"}, {"original_string": "private volatile Handler gpsHandler;", "modifier": "private volatile", "type": "Handler", "declarator": "gpsHandler", "var_name": "gpsHandler"}, {"original_string": "private Handler uiHandler;", "modifier": "private", "type": "Handler", "declarator": "uiHandler", "var_name": "uiHandler"}, {"original_string": "private volatile KujakuLocation lastRecordedKujakuLocation;", "modifier": "private volatile", "type": "KujakuLocation", "declarator": "lastRecordedKujakuLocation", "var_name": "lastRecordedKujakuLocation"}, {"original_string": "private volatile KujakuLocation pendingRecordingKujakuLocation;", "modifier": "private volatile", "type": "KujakuLocation", "declarator": "pendingRecordingKujakuLocation", "var_name": "pendingRecordingKujakuLocation"}, {"original_string": "private volatile KujakuLocation lastBestKujakuLocation;", "modifier": "private volatile", "type": "KujakuLocation", "declarator": "lastBestKujakuLocation", "var_name": "lastBestKujakuLocation"}, {"original_string": "private List<KujakuLocation> recordedKujakuLocations;", "modifier": "private", "type": "List<KujakuLocation>", "declarator": "recordedKujakuLocations", "var_name": "recordedKujakuLocations"}, {"original_string": "private volatile KujakuLocation firstKujakuLocationReceived = null;", "modifier": "private volatile", "type": "KujakuLocation", "declarator": "firstKujakuLocationReceived = null", "var_name": "firstKujakuLocationReceived"}, {"original_string": "private TrackingServiceOptions trackingServiceOptions;", "modifier": "private", "type": "TrackingServiceOptions", "declarator": "trackingServiceOptions", "var_name": "trackingServiceOptions"}, {"original_string": "private PendingIntent notificationPendingIntent;", "modifier": "private", "type": "PendingIntent", "declarator": "notificationPendingIntent", "var_name": "notificationPendingIntent"}, {"original_string": "private final IBinder binder = new LocalBinder();", "modifier": "private final", "type": "IBinder", "declarator": "binder = new LocalBinder()", "var_name": "binder"}, {"original_string": "private TrackingServiceListener trackingServiceListener = null;", "modifier": "private", "type": "TrackingServiceListener", "declarator": "trackingServiceListener = null", "var_name": "trackingServiceListener"}, {"original_string": "private PowerManager.WakeLock wakeLock;", "modifier": "private", "type": "PowerManager.WakeLock", "declarator": "wakeLock", "var_name": "wakeLock"}, {"original_string": "private PowerManager powerManager;", "modifier": "private", "type": "PowerManager", "declarator": "powerManager", "var_name": "powerManager"}, {"original_string": "private TrackingStorage storage;", "modifier": "private", "type": "TrackingStorage", "declarator": "storage", "var_name": "storage"}, {"original_string": "public static int NO_FORCED_TAG = -1;", "modifier": "public static", "type": "int", "declarator": "NO_FORCED_TAG = -1", "var_name": "NO_FORCED_TAG"}, {"original_string": "private volatile LocationListener locationListener = new LocationListener() {\n        @Override\n        public void onStatusChanged(String provider, int status, Bundle extras) {\n\n            switch (status) {\n                case LocationProvider.AVAILABLE:\n                    Log.d(TAG, \"GPS available.\");\n                    break;\n\n                case LocationProvider.TEMPORARILY_UNAVAILABLE:\n                    Log.d(TAG, \"GPS temporary unavailable.\");\n                    break;\n\n                case LocationProvider.OUT_OF_SERVICE:\n                    Log.d(TAG, \"GPS out of service.\");\n                    break;\n\n                default:\n                    break;\n            }\n        }\n\n        @Override\n        public void onProviderEnabled(String provider) {\n            // See GPS Broadcast receiver\n        }\n\n        @Override\n        public void onProviderDisabled(String provider) {\n            Log.i(TAG, \"GPS Provider has been disabled.\");\n            Log.i(TAG, \"Stopping tracking service.\");\n            // Stop the service\n            TrackingService.this.stopSelf();\n        }\n\n        @Override\n        public void onLocationChanged(Location location) {\n            Log.d(TAG, \"GPS position received\");\n            Log.d(TAG, \"GPS Location ThreadID: \" + android.os.Process.myTid());\n\n            // This should never happen, but just in case (we really don't\n            // want the service to crash):\n            if (location == null) {\n                Log.d(TAG, \"No location available.\");\n                return;\n            }\n\n            KujakuLocation kujakuLocation = new KujakuLocation(location, trackingServiceOptions.getTag());\n\n            // First Location received\n            informFirstLocationReceivedListener(kujakuLocation);\n\n            // Ignore if the accuracy is too bad:\n            if (kujakuLocation.getAccuracy() > trackingServiceOptions.getMinAccuracy()) {\n                Log.d(TAG, \"Track ignored because of accuracy.\");\n                return;\n            }\n\n            if (lastBestKujakuLocation == null) {\n                lastBestKujakuLocation = kujakuLocation;\n            } else {\n                if (kujakuLocation.getAccuracy() <= lastBestKujakuLocation.getAccuracy()) {\n                    // Remember this location is better than the previous one.\n                    // lastBestKujakuLocation is rebased in overwritePendingLocation but an\n                    // ignored location can have better accuracy\n                    // even if not recorded\n\n                    Log.d(TAG,\n                            \"New location is used as latest best accuracy location.\");\n                    lastBestKujakuLocation = kujakuLocation;\n                }\n            }\n\n            // process location received from GPS\n            processLocation(kujakuLocation);\n        }\n    };", "modifier": "private volatile", "type": "LocationListener", "declarator": "locationListener = new LocationListener() {\n        @Override\n        public void onStatusChanged(String provider, int status, Bundle extras) {\n\n            switch (status) {\n                case LocationProvider.AVAILABLE:\n                    Log.d(TAG, \"GPS available.\");\n                    break;\n\n                case LocationProvider.TEMPORARILY_UNAVAILABLE:\n                    Log.d(TAG, \"GPS temporary unavailable.\");\n                    break;\n\n                case LocationProvider.OUT_OF_SERVICE:\n                    Log.d(TAG, \"GPS out of service.\");\n                    break;\n\n                default:\n                    break;\n            }\n        }\n\n        @Override\n        public void onProviderEnabled(String provider) {\n            // See GPS Broadcast receiver\n        }\n\n        @Override\n        public void onProviderDisabled(String provider) {\n            Log.i(TAG, \"GPS Provider has been disabled.\");\n            Log.i(TAG, \"Stopping tracking service.\");\n            // Stop the service\n            TrackingService.this.stopSelf();\n        }\n\n        @Override\n        public void onLocationChanged(Location location) {\n            Log.d(TAG, \"GPS position received\");\n            Log.d(TAG, \"GPS Location ThreadID: \" + android.os.Process.myTid());\n\n            // This should never happen, but just in case (we really don't\n            // want the service to crash):\n            if (location == null) {\n                Log.d(TAG, \"No location available.\");\n                return;\n            }\n\n            KujakuLocation kujakuLocation = new KujakuLocation(location, trackingServiceOptions.getTag());\n\n            // First Location received\n            informFirstLocationReceivedListener(kujakuLocation);\n\n            // Ignore if the accuracy is too bad:\n            if (kujakuLocation.getAccuracy() > trackingServiceOptions.getMinAccuracy()) {\n                Log.d(TAG, \"Track ignored because of accuracy.\");\n                return;\n            }\n\n            if (lastBestKujakuLocation == null) {\n                lastBestKujakuLocation = kujakuLocation;\n            } else {\n                if (kujakuLocation.getAccuracy() <= lastBestKujakuLocation.getAccuracy()) {\n                    // Remember this location is better than the previous one.\n                    // lastBestKujakuLocation is rebased in overwritePendingLocation but an\n                    // ignored location can have better accuracy\n                    // even if not recorded\n\n                    Log.d(TAG,\n                            \"New location is used as latest best accuracy location.\");\n                    lastBestKujakuLocation = kujakuLocation;\n                }\n            }\n\n            // process location received from GPS\n            processLocation(kujakuLocation);\n        }\n    }", "var_name": "locationListener"}, {"original_string": "private volatile Thread serviceThread = new Thread(\"TrackingService\") {\n        public void run() {\n            Log.d(TAG, \"Tracking thread started.\");\n            // preparing a looper on current thread\n            // the current thread is being detected implicitly\n            Looper.prepare();\n\n            Log.d(TAG, \"Register GPS status listener.\");\n\n            // No need to do it in thread as the listener only logs\n            // which is fast\n            // locationManager.addGpsStatusListener(gpsListener);\n\n            // now, the handler will automatically bind to the\n            // Looper that is attached to the current thread\n            // You don't need to specify the Looper explicitly\n            gpsHandler = new Handler();\n\n            // Ui Handler\n            uiHandler = new Handler(Looper.getMainLooper());\n\n            // Register the Location listener\n            registerLocationListener();\n\n            // After the following line the thread will start\n            // running the message loop and will not normally\n            // exit the loop unless a problem happens or you\n            // quit() the looper (see below)\n            Looper.loop();\n\n            Log.d(TAG, \"Exiting looper.\");\n\n            if (pendingRecordingKujakuLocation != null) {\n\n                Log.d(TAG, \"Record last pending location.\");\n                recordPendingLocation();\n            }\n\n            // Mark to notify thread is exiting\n            serviceThreadRunningLatch.countDown();\n        }\n    };", "modifier": "private volatile", "type": "Thread", "declarator": "serviceThread = new Thread(\"TrackingService\") {\n        public void run() {\n            Log.d(TAG, \"Tracking thread started.\");\n            // preparing a looper on current thread\n            // the current thread is being detected implicitly\n            Looper.prepare();\n\n            Log.d(TAG, \"Register GPS status listener.\");\n\n            // No need to do it in thread as the listener only logs\n            // which is fast\n            // locationManager.addGpsStatusListener(gpsListener);\n\n            // now, the handler will automatically bind to the\n            // Looper that is attached to the current thread\n            // You don't need to specify the Looper explicitly\n            gpsHandler = new Handler();\n\n            // Ui Handler\n            uiHandler = new Handler(Looper.getMainLooper());\n\n            // Register the Location listener\n            registerLocationListener();\n\n            // After the following line the thread will start\n            // running the message loop and will not normally\n            // exit the loop unless a problem happens or you\n            // quit() the looper (see below)\n            Looper.loop();\n\n            Log.d(TAG, \"Exiting looper.\");\n\n            if (pendingRecordingKujakuLocation != null) {\n\n                Log.d(TAG, \"Record last pending location.\");\n                recordPendingLocation();\n            }\n\n            // Mark to notify thread is exiting\n            serviceThreadRunningLatch.countDown();\n        }\n    }", "var_name": "serviceThread"}, {"original_string": "private Runnable stopServiceThread = new Runnable() {\n        @Override\n        public void run() {\n            Looper looper = Looper.myLooper();\n            if (looper != null) {\n                looper.quit();\n            } else {\n                Log.e(TAG, \"Cannot stop service thread.\");\n            }\n        }\n    };", "modifier": "private", "type": "Runnable", "declarator": "stopServiceThread = new Runnable() {\n        @Override\n        public void run() {\n            Looper looper = Looper.myLooper();\n            if (looper != null) {\n                looper.quit();\n            } else {\n                Log.e(TAG, \"Cannot stop service thread.\");\n            }\n        }\n    }", "var_name": "stopServiceThread"}], "methods": [{"identifier": "onCreate", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void onCreate()", "full_signature": "@Override public void onCreate()", "class_method_signature": "TrackingService.onCreate()", "testcase": false, "constructor": false}, {"identifier": "initialize", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void initialize()", "full_signature": "private void initialize()", "class_method_signature": "TrackingService.initialize()", "testcase": false, "constructor": false}, {"identifier": "getTrackingServiceOptions", "parameters": "(Intent intent)", "modifiers": "private", "return": "void", "signature": "void getTrackingServiceOptions(Intent intent)", "full_signature": "private void getTrackingServiceOptions(Intent intent)", "class_method_signature": "TrackingService.getTrackingServiceOptions(Intent intent)", "testcase": false, "constructor": false}, {"identifier": "onStartCommand", "parameters": "(Intent intent, int flags, int startId)", "modifiers": "@Override public", "return": "int", "signature": "int onStartCommand(Intent intent, int flags, int startId)", "full_signature": "@Override public int onStartCommand(Intent intent, int flags, int startId)", "class_method_signature": "TrackingService.onStartCommand(Intent intent, int flags, int startId)", "testcase": false, "constructor": false}, {"identifier": "onDestroy", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void onDestroy()", "full_signature": "@Override public void onDestroy()", "class_method_signature": "TrackingService.onDestroy()", "testcase": false, "constructor": false}, {"identifier": "onBind", "parameters": "(Intent intent)", "modifiers": "@Override public", "return": "IBinder", "signature": "IBinder onBind(Intent intent)", "full_signature": "@Override public IBinder onBind(Intent intent)", "class_method_signature": "TrackingService.onBind(Intent intent)", "testcase": false, "constructor": false}, {"identifier": "createNotificationPendingIntent", "parameters": "(Intent intent)", "modifiers": "private", "return": "void", "signature": "void createNotificationPendingIntent(Intent intent)", "full_signature": "private void createNotificationPendingIntent(Intent intent)", "class_method_signature": "TrackingService.createNotificationPendingIntent(Intent intent)", "testcase": false, "constructor": false}, {"identifier": "getActivityClassFromCanonicalName", "parameters": "(Intent intent)", "modifiers": "private", "return": "Class<?>", "signature": "Class<?> getActivityClassFromCanonicalName(Intent intent)", "full_signature": "private Class<?> getActivityClassFromCanonicalName(Intent intent)", "class_method_signature": "TrackingService.getActivityClassFromCanonicalName(Intent intent)", "testcase": false, "constructor": false}, {"identifier": "registerLocationListener", "parameters": "()", "modifiers": "@SuppressWarnings({\"MissingPermission\"}) private", "return": "void", "signature": "void registerLocationListener()", "full_signature": "@SuppressWarnings({\"MissingPermission\"}) private void registerLocationListener()", "class_method_signature": "TrackingService.registerLocationListener()", "testcase": false, "constructor": false}, {"identifier": "setServiceStatus", "parameters": "(int status)", "modifiers": "private", "return": "void", "signature": "void setServiceStatus(int status)", "full_signature": "private void setServiceStatus(int status)", "class_method_signature": "TrackingService.setServiceStatus(int status)", "testcase": false, "constructor": false}, {"identifier": "processLocation", "parameters": "(KujakuLocation kujakuLocation)", "modifiers": "private synchronized", "return": "void", "signature": "void processLocation(KujakuLocation kujakuLocation)", "full_signature": "private synchronized void processLocation(KujakuLocation kujakuLocation)", "class_method_signature": "TrackingService.processLocation(KujakuLocation kujakuLocation)", "testcase": false, "constructor": false}, {"identifier": "selectLocation", "parameters": "(KujakuLocation newKujakuLocation, KujakuLocation oldKujakuLocation)", "modifiers": "private", "return": "boolean", "signature": "boolean selectLocation(KujakuLocation newKujakuLocation, KujakuLocation oldKujakuLocation)", "full_signature": "private boolean selectLocation(KujakuLocation newKujakuLocation, KujakuLocation oldKujakuLocation)", "class_method_signature": "TrackingService.selectLocation(KujakuLocation newKujakuLocation, KujakuLocation oldKujakuLocation)", "testcase": false, "constructor": false}, {"identifier": "overwritePendingLocation", "parameters": "(KujakuLocation kujakuLocation)", "modifiers": "private", "return": "void", "signature": "void overwritePendingLocation(KujakuLocation kujakuLocation)", "full_signature": "private void overwritePendingLocation(KujakuLocation kujakuLocation)", "class_method_signature": "TrackingService.overwritePendingLocation(KujakuLocation kujakuLocation)", "testcase": false, "constructor": false}, {"identifier": "recordPendingLocation", "parameters": "()", "modifiers": "private synchronized", "return": "void", "signature": "void recordPendingLocation()", "full_signature": "private synchronized void recordPendingLocation()", "class_method_signature": "TrackingService.recordPendingLocation()", "testcase": false, "constructor": false}, {"identifier": "getWakeLock", "parameters": "()", "modifiers": "private", "return": "PowerManager.WakeLock", "signature": "PowerManager.WakeLock getWakeLock()", "full_signature": "private PowerManager.WakeLock getWakeLock()", "class_method_signature": "TrackingService.getWakeLock()", "testcase": false, "constructor": false}, {"identifier": "startServiceForeground", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void startServiceForeground()", "full_signature": "protected void startServiceForeground()", "class_method_signature": "TrackingService.startServiceForeground()", "testcase": false, "constructor": false}, {"identifier": "createChannel", "parameters": "()", "modifiers": "@NonNull @TargetApi(26) private synchronized", "return": "String", "signature": "String createChannel()", "full_signature": "@NonNull @TargetApi(26) private synchronized String createChannel()", "class_method_signature": "TrackingService.createChannel()", "testcase": false, "constructor": false}, {"identifier": "registerTrackingServiceListener", "parameters": "(@NonNull TrackingServiceListener listener)", "modifiers": "public", "return": "void", "signature": "void registerTrackingServiceListener(@NonNull TrackingServiceListener listener)", "full_signature": "public void registerTrackingServiceListener(@NonNull TrackingServiceListener listener)", "class_method_signature": "TrackingService.registerTrackingServiceListener(@NonNull TrackingServiceListener listener)", "testcase": false, "constructor": false}, {"identifier": "unregisterTrackingServiceListener", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void unregisterTrackingServiceListener()", "full_signature": "public void unregisterTrackingServiceListener()", "class_method_signature": "TrackingService.unregisterTrackingServiceListener()", "testcase": false, "constructor": false}, {"identifier": "informFirstLocationReceivedListener", "parameters": "(KujakuLocation kujakuLocation)", "modifiers": "private", "return": "void", "signature": "void informFirstLocationReceivedListener(KujakuLocation kujakuLocation)", "full_signature": "private void informFirstLocationReceivedListener(KujakuLocation kujakuLocation)", "class_method_signature": "TrackingService.informFirstLocationReceivedListener(KujakuLocation kujakuLocation)", "testcase": false, "constructor": false}, {"identifier": "informNewTrackReceivedListener", "parameters": "(KujakuLocation kujakuLocation)", "modifiers": "private", "return": "void", "signature": "void informNewTrackReceivedListener(KujakuLocation kujakuLocation)", "full_signature": "private void informNewTrackReceivedListener(KujakuLocation kujakuLocation)", "class_method_signature": "TrackingService.informNewTrackReceivedListener(KujakuLocation kujakuLocation)", "testcase": false, "constructor": false}, {"identifier": "informCloseToDepartureLocationListener", "parameters": "(KujakuLocation kujakuLocation)", "modifiers": "private", "return": "void", "signature": "void informCloseToDepartureLocationListener(KujakuLocation kujakuLocation)", "full_signature": "private void informCloseToDepartureLocationListener(KujakuLocation kujakuLocation)", "class_method_signature": "TrackingService.informCloseToDepartureLocationListener(KujakuLocation kujakuLocation)", "testcase": false, "constructor": false}, {"identifier": "getFirstLocationRecorded", "parameters": "()", "modifiers": "private", "return": "Location", "signature": "Location getFirstLocationRecorded()", "full_signature": "private Location getFirstLocationRecorded()", "class_method_signature": "TrackingService.getFirstLocationRecorded()", "testcase": false, "constructor": false}, {"identifier": "getNumberOfLocationsRecorded", "parameters": "()", "modifiers": "private", "return": "int", "signature": "int getNumberOfLocationsRecorded()", "full_signature": "private int getNumberOfLocationsRecorded()", "class_method_signature": "TrackingService.getNumberOfLocationsRecorded()", "testcase": false, "constructor": false}, {"identifier": "getRecordedKujakuLocations", "parameters": "()", "modifiers": "public", "return": "List<KujakuLocation>", "signature": "List<KujakuLocation> getRecordedKujakuLocations()", "full_signature": "public List<KujakuLocation> getRecordedKujakuLocations()", "class_method_signature": "TrackingService.getRecordedKujakuLocations()", "testcase": false, "constructor": false}, {"identifier": "setTag", "parameters": "(long tag)", "modifiers": "public", "return": "void", "signature": "void setTag(long tag)", "full_signature": "public void setTag(long tag)", "class_method_signature": "TrackingService.setTag(long tag)", "testcase": false, "constructor": false}, {"identifier": "takeLocation", "parameters": "(long tag)", "modifiers": "public", "return": "void", "signature": "void takeLocation(long tag)", "full_signature": "public void takeLocation(long tag)", "class_method_signature": "TrackingService.takeLocation(long tag)", "testcase": false, "constructor": false}, {"identifier": "startAndBindService", "parameters": "(Context context, Class<?> cls, ServiceConnection connection, TrackingServiceOptions options)", "modifiers": "public static", "return": "void", "signature": "void startAndBindService(Context context, Class<?> cls, ServiceConnection connection, TrackingServiceOptions options)", "full_signature": "public static void startAndBindService(Context context, Class<?> cls, ServiceConnection connection, TrackingServiceOptions options)", "class_method_signature": "TrackingService.startAndBindService(Context context, Class<?> cls, ServiceConnection connection, TrackingServiceOptions options)", "testcase": false, "constructor": false}, {"identifier": "bindService", "parameters": "(Context context, Intent intent, ServiceConnection connection)", "modifiers": "public static", "return": "boolean", "signature": "boolean bindService(Context context, Intent intent, ServiceConnection connection)", "full_signature": "public static boolean bindService(Context context, Intent intent, ServiceConnection connection)", "class_method_signature": "TrackingService.bindService(Context context, Intent intent, ServiceConnection connection)", "testcase": false, "constructor": false}, {"identifier": "getIntent", "parameters": "(Context context, Class<?> cls, TrackingServiceOptions options)", "modifiers": "public static", "return": "Intent", "signature": "Intent getIntent(Context context, Class<?> cls, TrackingServiceOptions options)", "full_signature": "public static Intent getIntent(Context context, Class<?> cls, TrackingServiceOptions options)", "class_method_signature": "TrackingService.getIntent(Context context, Class<?> cls, TrackingServiceOptions options)", "testcase": false, "constructor": false}, {"identifier": "stopAndUnbindService", "parameters": "(Context context, ServiceConnection connection)", "modifiers": "public static", "return": "void", "signature": "void stopAndUnbindService(Context context, ServiceConnection connection)", "full_signature": "public static void stopAndUnbindService(Context context, ServiceConnection connection)", "class_method_signature": "TrackingService.stopAndUnbindService(Context context, ServiceConnection connection)", "testcase": false, "constructor": false}, {"identifier": "unBindService", "parameters": "(Context context, ServiceConnection connection)", "modifiers": "public static", "return": "void", "signature": "void unBindService(Context context, ServiceConnection connection)", "full_signature": "public static void unBindService(Context context, ServiceConnection connection)", "class_method_signature": "TrackingService.unBindService(Context context, ServiceConnection connection)", "testcase": false, "constructor": false}, {"identifier": "isRunning", "parameters": "()", "modifiers": "public static", "return": "boolean", "signature": "boolean isRunning()", "full_signature": "public static boolean isRunning()", "class_method_signature": "TrackingService.isRunning()", "testcase": false, "constructor": false}, {"identifier": "getTrackingServiceStatus", "parameters": "()", "modifiers": "public static", "return": "int", "signature": "int getTrackingServiceStatus()", "full_signature": "public static int getTrackingServiceStatus()", "class_method_signature": "TrackingService.getTrackingServiceStatus()", "testcase": false, "constructor": false}, {"identifier": "getCurrentRecordedKujakuLocations", "parameters": "()", "modifiers": "public static", "return": "List<KujakuLocation>", "signature": "List<KujakuLocation> getCurrentRecordedKujakuLocations()", "full_signature": "public static List<KujakuLocation> getCurrentRecordedKujakuLocations()", "class_method_signature": "TrackingService.getCurrentRecordedKujakuLocations()", "testcase": false, "constructor": false}, {"identifier": "getPreviousRecordedKujakuLocations", "parameters": "()", "modifiers": "public static", "return": "List<KujakuLocation>", "signature": "List<KujakuLocation> getPreviousRecordedKujakuLocations()", "full_signature": "public static List<KujakuLocation> getPreviousRecordedKujakuLocations()", "class_method_signature": "TrackingService.getPreviousRecordedKujakuLocations()", "testcase": false, "constructor": false}], "file": "library/src/main/java/io/ona/kujaku/services/TrackingService.java"}, "focal_method": {"identifier": "startAndBindService", "parameters": "(Context context, Class<?> cls, ServiceConnection connection, TrackingServiceOptions options)", "modifiers": "public static", "return": "void", "body": "public static void startAndBindService(Context context, Class<?> cls, ServiceConnection connection, TrackingServiceOptions options) {\n        Intent mIntent = TrackingService.getIntent(context, cls, options);\n        TrackingService.bindService(context, mIntent, connection);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            context.startForegroundService(mIntent);\n        } else {\n            context.startService(mIntent);\n        }\n    }", "signature": "void startAndBindService(Context context, Class<?> cls, ServiceConnection connection, TrackingServiceOptions options)", "full_signature": "public static void startAndBindService(Context context, Class<?> cls, ServiceConnection connection, TrackingServiceOptions options)", "class_method_signature": "TrackingService.startAndBindService(Context context, Class<?> cls, ServiceConnection connection, TrackingServiceOptions options)", "testcase": false, "constructor": false, "invocations": ["getIntent", "bindService", "startForegroundService", "startService"]}, "repository": {"repo_id": 109667968, "url": "https://github.com/onaio/kujaku", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 14, "size": 4778, "license": "licensed"}}