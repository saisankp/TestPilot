{"test_class": {"identifier": "TestDistCPBaseService", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Logger LOG = Logger.getLogger(TestDistCPBaseService.class);", "modifier": "private static", "type": "Logger", "declarator": "LOG = Logger.getLogger(TestDistCPBaseService.class)", "var_name": "LOG"}, {"original_string": "Path testRoot = new Path(\"/tmp/\", this.getClass().getName());", "modifier": "", "type": "Path", "declarator": "testRoot = new Path(\"/tmp/\", this.getClass().getName())", "var_name": "testRoot"}, {"original_string": "Path testRoot1=new Path(\"/tmp/\",\"sample-test\");", "modifier": "", "type": "Path", "declarator": "testRoot1=new Path(\"/tmp/\",\"sample-test\")", "var_name": "testRoot1"}, {"original_string": "FileSystem localFs;", "modifier": "", "type": "FileSystem", "declarator": "localFs", "var_name": "localFs"}, {"original_string": "Cluster cluster;", "modifier": "", "type": "Cluster", "declarator": "cluster", "var_name": "cluster"}, {"original_string": "MirrorStreamService mirrorService = null;", "modifier": "", "type": "MirrorStreamService", "declarator": "mirrorService = null", "var_name": "mirrorService"}, {"original_string": "MergedStreamService mergeService = null;", "modifier": "", "type": "MergedStreamService", "declarator": "mergeService = null", "var_name": "mergeService"}, {"original_string": "MergedStreamService mergedService1 = null;", "modifier": "", "type": "MergedStreamService", "declarator": "mergedService1 = null", "var_name": "mergedService1"}, {"original_string": "FileSystem srcFs = null;", "modifier": "", "type": "FileSystem", "declarator": "srcFs = null", "var_name": "srcFs"}, {"original_string": "String expectedFileName1 = \"/tmp/com.inmobi.conduit.distcp\"\n      + \".TestDistCPBaseService/data-file1\";", "modifier": "", "type": "String", "declarator": "expectedFileName1 = \"/tmp/com.inmobi.conduit.distcp\"\n      + \".TestDistCPBaseService/data-file1\"", "var_name": "expectedFileName1"}, {"original_string": "String expectedFileName2 = \"/tmp/com.inmobi.conduit.distcp\"\n      + \".TestDistCPBaseService/data-file2\";", "modifier": "", "type": "String", "declarator": "expectedFileName2 = \"/tmp/com.inmobi.conduit.distcp\"\n      + \".TestDistCPBaseService/data-file2\"", "var_name": "expectedFileName2"}, {"original_string": "String expectedFileName3 = \"/tmp/sample-test/data-file1\";", "modifier": "", "type": "String", "declarator": "expectedFileName3 = \"/tmp/sample-test/data-file1\"", "var_name": "expectedFileName3"}, {"original_string": "Set<String> expectedConsumePaths = new HashSet<String>();", "modifier": "", "type": "Set<String>", "declarator": "expectedConsumePaths = new HashSet<String>()", "var_name": "expectedConsumePaths"}], "file": "conduit-worker/src/test/java/com/inmobi/conduit/distcp/TestDistCPBaseService.java"}, "test_case": {"identifier": "testNegative", "parameters": "()", "modifiers": "@Test(priority = 2) public", "return": "void", "body": "@Test(priority = 2)\n  public void testNegative() throws Exception {\n    cleanUP();\n    createInvalidData();\n    Map<String, FileStatus> fileCopyListMap = mirrorService\n        .getDistCPInputFile();\n    // since all data is invalid\n    // output of this function should be null\n    assert fileCopyListMap.size() == 0;\n\n  }", "signature": "void testNegative()", "full_signature": "@Test(priority = 2) public void testNegative()", "class_method_signature": "TestDistCPBaseService.testNegative()", "testcase": true, "constructor": false, "invocations": ["cleanUP", "createInvalidData", "getDistCPInputFile", "size"]}, "focal_class": {"identifier": "DistcpBaseService", "superclass": "extends AbstractService", "interfaces": "", "fields": [{"original_string": "protected final Cluster srcCluster;", "modifier": "protected final", "type": "Cluster", "declarator": "srcCluster", "var_name": "srcCluster"}, {"original_string": "protected final Cluster destCluster;", "modifier": "protected final", "type": "Cluster", "declarator": "destCluster", "var_name": "destCluster"}, {"original_string": "protected final Cluster currentCluster;", "modifier": "protected final", "type": "Cluster", "declarator": "currentCluster", "var_name": "currentCluster"}, {"original_string": "private final FileSystem srcFs;", "modifier": "private final", "type": "FileSystem", "declarator": "srcFs", "var_name": "srcFs"}, {"original_string": "private final FileSystem destFs;", "modifier": "private final", "type": "FileSystem", "declarator": "destFs", "var_name": "destFs"}, {"original_string": "protected final CheckpointProvider provider;", "modifier": "protected final", "type": "CheckpointProvider", "declarator": "provider", "var_name": "provider"}, {"original_string": "protected Map<String, Path> checkPointPaths = new HashMap<String, Path>();", "modifier": "protected", "type": "Map<String, Path>", "declarator": "checkPointPaths = new HashMap<String, Path>()", "var_name": "checkPointPaths"}, {"original_string": "private static final int DEFAULT_NUM_DIR_PER_DISTCP_STREAM = 30;", "modifier": "private static final", "type": "int", "declarator": "DEFAULT_NUM_DIR_PER_DISTCP_STREAM = 30", "var_name": "DEFAULT_NUM_DIR_PER_DISTCP_STREAM"}, {"original_string": "protected static final Log LOG = LogFactory.getLog(DistcpBaseService.class);", "modifier": "protected static final", "type": "Log", "declarator": "LOG = LogFactory.getLog(DistcpBaseService.class)", "var_name": "LOG"}, {"original_string": "private final int numOfDirPerDistcpPerStream;", "modifier": "private final", "type": "int", "declarator": "numOfDirPerDistcpPerStream", "var_name": "numOfDirPerDistcpPerStream"}, {"original_string": "protected final Path jarsPath;", "modifier": "protected final", "type": "Path", "declarator": "jarsPath", "var_name": "jarsPath"}, {"original_string": "protected final Path auditUtilJarDestPath;", "modifier": "protected final", "type": "Path", "declarator": "auditUtilJarDestPath", "var_name": "auditUtilJarDestPath"}], "methods": [{"identifier": "DistcpBaseService", "parameters": "(ConduitConfig config, String name,\n      Cluster srcCluster, Cluster destCluster, Cluster currentCluster,\n      CheckpointProvider provider, Set<String> streamsToProcess)", "modifiers": "public", "return": "", "signature": " DistcpBaseService(ConduitConfig config, String name,\n      Cluster srcCluster, Cluster destCluster, Cluster currentCluster,\n      CheckpointProvider provider, Set<String> streamsToProcess)", "full_signature": "public  DistcpBaseService(ConduitConfig config, String name,\n      Cluster srcCluster, Cluster destCluster, Cluster currentCluster,\n      CheckpointProvider provider, Set<String> streamsToProcess)", "class_method_signature": "DistcpBaseService.DistcpBaseService(ConduitConfig config, String name,\n      Cluster srcCluster, Cluster destCluster, Cluster currentCluster,\n      CheckpointProvider provider, Set<String> streamsToProcess)", "testcase": false, "constructor": true}, {"identifier": "getSrcCluster", "parameters": "()", "modifiers": "protected", "return": "Cluster", "signature": "Cluster getSrcCluster()", "full_signature": "protected Cluster getSrcCluster()", "class_method_signature": "DistcpBaseService.getSrcCluster()", "testcase": false, "constructor": false}, {"identifier": "getDestCluster", "parameters": "()", "modifiers": "protected", "return": "Cluster", "signature": "Cluster getDestCluster()", "full_signature": "protected Cluster getDestCluster()", "class_method_signature": "DistcpBaseService.getDestCluster()", "testcase": false, "constructor": false}, {"identifier": "getSrcFs", "parameters": "()", "modifiers": "protected", "return": "FileSystem", "signature": "FileSystem getSrcFs()", "full_signature": "protected FileSystem getSrcFs()", "class_method_signature": "DistcpBaseService.getSrcFs()", "testcase": false, "constructor": false}, {"identifier": "getDestFs", "parameters": "()", "modifiers": "protected", "return": "FileSystem", "signature": "FileSystem getDestFs()", "full_signature": "protected FileSystem getDestFs()", "class_method_signature": "DistcpBaseService.getDestFs()", "testcase": false, "constructor": false}, {"identifier": "executeDistCp", "parameters": "(String serviceName, \n      Map<String, FileStatus> fileListingMap, Path targetPath)", "modifiers": "protected", "return": "Boolean", "signature": "Boolean executeDistCp(String serviceName, \n      Map<String, FileStatus> fileListingMap, Path targetPath)", "full_signature": "protected Boolean executeDistCp(String serviceName, \n      Map<String, FileStatus> fileListingMap, Path targetPath)", "class_method_signature": "DistcpBaseService.executeDistCp(String serviceName, \n      Map<String, FileStatus> fileListingMap, Path targetPath)", "testcase": false, "constructor": false}, {"identifier": "prepareStreamHcatEnableMap", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void prepareStreamHcatEnableMap()", "full_signature": "@Override protected void prepareStreamHcatEnableMap()", "class_method_signature": "DistcpBaseService.prepareStreamHcatEnableMap()", "testcase": false, "constructor": false}, {"identifier": "getTableName", "parameters": "(String streamName)", "modifiers": "protected", "return": "String", "signature": "String getTableName(String streamName)", "full_signature": "protected String getTableName(String streamName)", "class_method_signature": "DistcpBaseService.getTableName(String streamName)", "testcase": false, "constructor": false}, {"identifier": "getTimeStampFromHCatPartition", "parameters": "(String lastHcatPartitionLoc,\n      String stream)", "modifiers": "@Override protected", "return": "Date", "signature": "Date getTimeStampFromHCatPartition(String lastHcatPartitionLoc,\n      String stream)", "full_signature": "@Override protected Date getTimeStampFromHCatPartition(String lastHcatPartitionLoc,\n      String stream)", "class_method_signature": "DistcpBaseService.getTimeStampFromHCatPartition(String lastHcatPartitionLoc,\n      String stream)", "testcase": false, "constructor": false}, {"identifier": "getInputPath", "parameters": "()", "modifiers": "protected abstract", "return": "Path", "signature": "Path getInputPath()", "full_signature": "protected abstract Path getInputPath()", "class_method_signature": "DistcpBaseService.getInputPath()", "testcase": false, "constructor": false}, {"identifier": "getDistCpTargetPath", "parameters": "()", "modifiers": "protected abstract", "return": "Path", "signature": "Path getDistCpTargetPath()", "full_signature": "protected abstract Path getDistCpTargetPath()", "class_method_signature": "DistcpBaseService.getDistCpTargetPath()", "testcase": false, "constructor": false}, {"identifier": "getMSecondsTillNextRun", "parameters": "(long currentTime)", "modifiers": "@Override public", "return": "long", "signature": "long getMSecondsTillNextRun(long currentTime)", "full_signature": "@Override public long getMSecondsTillNextRun(long currentTime)", "class_method_signature": "DistcpBaseService.getMSecondsTillNextRun(long currentTime)", "testcase": false, "constructor": false}, {"identifier": "getStartingDirectory", "parameters": "(String stream,\n      List<FileStatus> filesToBeCopied)", "modifiers": "protected abstract", "return": "Path", "signature": "Path getStartingDirectory(String stream,\n      List<FileStatus> filesToBeCopied)", "full_signature": "protected abstract Path getStartingDirectory(String stream,\n      List<FileStatus> filesToBeCopied)", "class_method_signature": "DistcpBaseService.getStartingDirectory(String stream,\n      List<FileStatus> filesToBeCopied)", "testcase": false, "constructor": false}, {"identifier": "getDistCPInputFile", "parameters": "()", "modifiers": "protected", "return": "Map<String, FileStatus>", "signature": "Map<String, FileStatus> getDistCPInputFile()", "full_signature": "protected Map<String, FileStatus> getDistCPInputFile()", "class_method_signature": "DistcpBaseService.getDistCPInputFile()", "testcase": false, "constructor": false}, {"identifier": "fullyQualifyCheckPointWithReadURL", "parameters": "(Path lastCheckPointPath,\n      Cluster srcCluster)", "modifiers": "protected", "return": "Path", "signature": "Path fullyQualifyCheckPointWithReadURL(Path lastCheckPointPath,\n      Cluster srcCluster)", "full_signature": "protected Path fullyQualifyCheckPointWithReadURL(Path lastCheckPointPath,\n      Cluster srcCluster)", "class_method_signature": "DistcpBaseService.fullyQualifyCheckPointWithReadURL(Path lastCheckPointPath,\n      Cluster srcCluster)", "testcase": false, "constructor": false}, {"identifier": "getFinalDestinationPath", "parameters": "(FileStatus srcPath)", "modifiers": "protected abstract", "return": "String", "signature": "String getFinalDestinationPath(FileStatus srcPath)", "full_signature": "protected abstract String getFinalDestinationPath(FileStatus srcPath)", "class_method_signature": "DistcpBaseService.getFinalDestinationPath(FileStatus srcPath)", "testcase": false, "constructor": false}, {"identifier": "getCheckPointKey", "parameters": "(String stream)", "modifiers": "protected", "return": "String", "signature": "String getCheckPointKey(String stream)", "full_signature": "protected String getCheckPointKey(String stream)", "class_method_signature": "DistcpBaseService.getCheckPointKey(String stream)", "testcase": false, "constructor": false}, {"identifier": "finalizeCheckPoints", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void finalizeCheckPoints()", "full_signature": "protected void finalizeCheckPoints()", "class_method_signature": "DistcpBaseService.finalizeCheckPoints()", "testcase": false, "constructor": false}, {"identifier": "getCurrentCluster", "parameters": "()", "modifiers": "public", "return": "Cluster", "signature": "Cluster getCurrentCluster()", "full_signature": "public Cluster getCurrentCluster()", "class_method_signature": "DistcpBaseService.getCurrentCluster()", "testcase": false, "constructor": false}, {"identifier": "createListing", "parameters": "(FileSystem fs, FileStatus fileStatus,\n      List<FileStatus> results)", "modifiers": "public static", "return": "void", "signature": "void createListing(FileSystem fs, FileStatus fileStatus,\n      List<FileStatus> results)", "full_signature": "public static void createListing(FileSystem fs, FileStatus fileStatus,\n      List<FileStatus> results)", "class_method_signature": "DistcpBaseService.createListing(FileSystem fs, FileStatus fileStatus,\n      List<FileStatus> results)", "testcase": false, "constructor": false}, {"identifier": "getTopicNameFromDestnPath", "parameters": "(Path destnPath)", "modifiers": "protected", "return": "String", "signature": "String getTopicNameFromDestnPath(Path destnPath)", "full_signature": "protected String getTopicNameFromDestnPath(Path destnPath)", "class_method_signature": "DistcpBaseService.getTopicNameFromDestnPath(Path destnPath)", "testcase": false, "constructor": false}, {"identifier": "getFinalPath", "parameters": "(long time, String stream)", "modifiers": "@Override protected", "return": "Path", "signature": "Path getFinalPath(long time, String stream)", "full_signature": "@Override protected Path getFinalPath(long time, String stream)", "class_method_signature": "DistcpBaseService.getFinalPath(long time, String stream)", "testcase": false, "constructor": false}], "file": "conduit-worker/src/main/java/com/inmobi/conduit/distcp/DistcpBaseService.java"}, "focal_method": {"identifier": "getDistCPInputFile", "parameters": "()", "modifiers": "protected", "return": "Map<String, FileStatus>", "body": "protected Map<String, FileStatus> getDistCPInputFile()\n      throws Exception {\n    Map<String,FileStatus> result = new HashMap<String, FileStatus>();\n    for (String stream : streamsToProcess) {\n      int pathsAlreadyAdded = 0;\n      LOG.info(\"Processing stream \" + stream);\n      byte[] value = provider.read(getCheckPointKey(stream));\n      Path inputPath = new Path(getInputPath(), stream);\n      Path lastCheckPointPath = null;\n      Path nextPath = null;\n      List<FileStatus> filesLastCopiedDir;\n      if (value != null) {\n        String checkPointValue = new String(value);\n        // creating a path object from empty string throws exception;hence\n        // checking for it\n        if (!checkPointValue.trim().equals(\"\")) {\n          lastCheckPointPath = new Path(checkPointValue);\n        }\n        lastCheckPointPath = fullyQualifyCheckPointWithReadURL\n            (lastCheckPointPath, srcCluster);\n        if (lastCheckPointPath == null\n            || !getSrcFs().exists(lastCheckPointPath)) {\n          LOG.warn(\"Invalid checkpoint found [\" + lastCheckPointPath\n              + \"] for stream \" + stream + \";Ignoring it\");\n        } else {\n          Date lastDate = CalendarHelper.getDateFromStreamDir(inputPath,\n              lastCheckPointPath);\n          nextPath = CalendarHelper.getNextMinutePathFromDate(lastDate,\n              inputPath);\n        }\n\n      }\n      if (nextPath == null) {\n        filesLastCopiedDir = new ArrayList<FileStatus>();\n        LOG.info(\"Finding the starting directoryfor stream [\" + stream + \"]\");\n        nextPath = getStartingDirectory(stream, filesLastCopiedDir);\n        if (nextPath == null) {\n          LOG.debug(\"No start directory found,returning the empty result\");\n          continue;\n        }\n        LOG.debug(\"Uncopied Files from directory last copied are \"\n            + FileUtil.toStringOfFileStatus(filesLastCopiedDir));\n        for (FileStatus fileStatus : filesLastCopiedDir) {\n          String destnPath = getFinalDestinationPath(fileStatus);\n          if (destnPath != null) {\n            LOG.info(\"Adding to input of Distcp.Move [\" + fileStatus.getPath()\n                + \"] to \" + destnPath);\n            result.put(destnPath, fileStatus);\n          }\n        }\n      }\n      LOG.info(\"Starting directory for stream [\" + stream + \"]\" + \" is [\"\n          + nextPath + \"]\");\n      Date nextDate = CalendarHelper.getDateFromStreamDir(inputPath, nextPath);\n      // if next to next path exist than only add the next path so that the path\n      // being added to disctp input is not the current path\n      Path nextToNextPath = CalendarHelper.getNextMinutePathFromDate(nextDate,\n          inputPath);\n      Path lastPathAdded = null;\n      FileStatus[] nextPathFileStatus;\n      while (pathsAlreadyAdded <= numOfDirPerDistcpPerStream\n          && srcFs.exists(nextToNextPath)\n          && (nextPathFileStatus = FileUtil\n          .listStatusAsPerHDFS(srcFs, nextPath)) != null) {\n        if(nextPathFileStatus.length==0){\n          LOG.info(nextPath + \" is an empty directory\");\n          FileStatus srcFileStatus = srcFs.getFileStatus(nextPath); \n          String destnPath = getFinalDestinationPath(srcFileStatus);\n          if(destnPath!=null){\n            LOG.info(\"Adding to input of Distcp.Move [\"+nextPath+\"] to \"+destnPath);\n            result.put(destnPath,srcFileStatus);\n          }\n        }\n        else{\n          for(FileStatus fStatus:nextPathFileStatus){\n            String destnPath = getFinalDestinationPath(fStatus);\n            if(destnPath!=null){\n              LOG.info(\"Adding to input of Distcp.Move [\"+fStatus.getPath()+\"] to \"+destnPath);\n              result.put(destnPath,fStatus);\n            }\n          }\n        } \n        pathsAlreadyAdded++;\n        lastPathAdded = nextPath;\n        nextPath = nextToNextPath;\n        nextDate = CalendarHelper.addAMinute(nextDate);\n        nextToNextPath = CalendarHelper.getNextMinutePathFromDate(nextDate,\n            inputPath);\n      }\n      if (lastPathAdded != null) {\n        checkPointPaths.put(stream, lastPathAdded);\n        Date lastDateAdded = CalendarHelper.getDateFromStreamDir(inputPath,\n            lastPathAdded);\n        lastProcessedFile.put(stream, lastDateAdded.getTime());\n      }\n\n    }\n    return result;\n  }", "signature": "Map<String, FileStatus> getDistCPInputFile()", "full_signature": "protected Map<String, FileStatus> getDistCPInputFile()", "class_method_signature": "DistcpBaseService.getDistCPInputFile()", "testcase": false, "constructor": false, "invocations": ["info", "read", "getCheckPointKey", "getInputPath", "equals", "trim", "fullyQualifyCheckPointWithReadURL", "exists", "getSrcFs", "warn", "getDateFromStreamDir", "getNextMinutePathFromDate", "info", "getStartingDirectory", "debug", "debug", "toStringOfFileStatus", "getFinalDestinationPath", "info", "getPath", "put", "info", "getDateFromStreamDir", "getNextMinutePathFromDate", "exists", "listStatusAsPerHDFS", "info", "getFileStatus", "getFinalDestinationPath", "info", "put", "getFinalDestinationPath", "info", "getPath", "put", "addAMinute", "getNextMinutePathFromDate", "put", "getDateFromStreamDir", "put", "getTime"]}, "repository": {"repo_id": 7218024, "url": "https://github.com/InMobi/conduit", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 9, "size": 49400, "license": "licensed"}}