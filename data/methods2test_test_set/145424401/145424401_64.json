{"test_class": {"identifier": "PythonArchiveAnalyzerTest", "superclass": "", "interfaces": "", "fields": [], "file": "lang-python/src/test/java/org/eclipse/steady/python/PythonArchiveAnalyzerTest.java"}, "test_case": {"identifier": "testGunicorn", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testGunicorn() throws FileAnalysisException {\n    final FileAnalyzer f3 =\n        FileAnalyzerFactory.buildFileAnalyzer(\n            new File(\"src/test/resources/gunicorn-19.7.1-py2.py3-none-any.whl\"));\n    final Map<ConstructId, Construct> c3 = f3.getConstructs();\n\n    /*for(ConstructId cid: c3.keySet())\n    System.out.println(cid);*/\n\n    // 1. parse errors happen in the following method. Check it is nevertheless among the identified\n    // constructs\n    // PY METH [gunicorn.workers._gaiohttp.AiohttpWorker(base.Worker).run(self)]\n    final PythonId pack = new PythonId(null, PythonId.Type.PACKAGE, \"gunicorn.workers\");\n    PythonId modu = new PythonId(pack, PythonId.Type.MODULE, \"_gaiohttp\");\n    final PythonId clas = new PythonId(modu, PythonId.Type.CLASS, \"AiohttpWorker(base.Worker)\");\n    final PythonId meth = new PythonId(clas, PythonId.Type.METHOD, \"run(self)\");\n    assertTrue(c3.containsKey(pack));\n    assertTrue(c3.containsKey(modu));\n    assertTrue(c3.containsKey(clas));\n    assertTrue(c3.containsKey(meth));\n\n    // 2. parse errors happen in the following module. Check it is nevertheless among the identified\n    // constructs\n    //   PY MODU [gunicorn.workers.geventlet]\n    modu = new PythonId(pack, PythonId.Type.MODULE, \"geventlet\");\n    assertTrue(c3.containsKey(modu));\n\n    // 3. parse errors happen in the following module. Check it is nevertheless among the identified\n    // constructs\n    //   PY MODU [gunicorn.workers.ggevent]\n    modu = new PythonId(pack, PythonId.Type.MODULE, \"ggevent\");\n    assertTrue(c3.containsKey(modu));\n  }", "signature": "void testGunicorn()", "full_signature": "@Test public void testGunicorn()", "class_method_signature": "PythonArchiveAnalyzerTest.testGunicorn()", "testcase": true, "constructor": false, "invocations": ["buildFileAnalyzer", "getConstructs", "assertTrue", "containsKey", "assertTrue", "containsKey", "assertTrue", "containsKey", "assertTrue", "containsKey", "assertTrue", "containsKey", "assertTrue", "containsKey"]}, "focal_class": {"identifier": "PythonArchiveAnalyzer", "superclass": "", "interfaces": "implements FileAnalyzer", "fields": [{"original_string": "private static final Logger log = org.apache.logging.log4j.LogManager.getLogger();", "modifier": "private static final", "type": "Logger", "declarator": "log = org.apache.logging.log4j.LogManager.getLogger()", "var_name": "log"}, {"original_string": "Map<ConstructId, Construct> constructs = new TreeMap<ConstructId, Construct>();", "modifier": "", "type": "Map<ConstructId, Construct>", "declarator": "constructs = new TreeMap<ConstructId, Construct>()", "var_name": "constructs"}, {"original_string": "private File archive = null;", "modifier": "private", "type": "File", "declarator": "archive = null", "var_name": "archive"}, {"original_string": "private Set<FileAnalyzer> nestedAnalyzers = new HashSet<FileAnalyzer>();", "modifier": "private", "type": "Set<FileAnalyzer>", "declarator": "nestedAnalyzers = new HashSet<FileAnalyzer>()", "var_name": "nestedAnalyzers"}], "methods": [{"identifier": "getSupportedFileExtensions", "parameters": "()", "modifiers": "@Override public", "return": "String[]", "signature": "String[] getSupportedFileExtensions()", "full_signature": "@Override public String[] getSupportedFileExtensions()", "class_method_signature": "PythonArchiveAnalyzer.getSupportedFileExtensions()", "testcase": false, "constructor": false}, {"identifier": "canAnalyze", "parameters": "(File _file)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean canAnalyze(File _file)", "full_signature": "@Override public boolean canAnalyze(File _file)", "class_method_signature": "PythonArchiveAnalyzer.canAnalyze(File _file)", "testcase": false, "constructor": false}, {"identifier": "analyze", "parameters": "(final File _file)", "modifiers": "@Override public", "return": "void", "signature": "void analyze(final File _file)", "full_signature": "@Override public void analyze(final File _file)", "class_method_signature": "PythonArchiveAnalyzer.analyze(final File _file)", "testcase": false, "constructor": false}, {"identifier": "getArchivePath", "parameters": "()", "modifiers": "public", "return": "Path", "signature": "Path getArchivePath()", "full_signature": "public Path getArchivePath()", "class_method_signature": "PythonArchiveAnalyzer.getArchivePath()", "testcase": false, "constructor": false}, {"identifier": "getDigest", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getDigest()", "full_signature": "public String getDigest()", "class_method_signature": "PythonArchiveAnalyzer.getDigest()", "testcase": false, "constructor": false}, {"identifier": "getArchiveInputStream", "parameters": "()", "modifiers": "private", "return": "InputStream", "signature": "InputStream getArchiveInputStream()", "full_signature": "private InputStream getArchiveInputStream()", "class_method_signature": "PythonArchiveAnalyzer.getArchiveInputStream()", "testcase": false, "constructor": false}, {"identifier": "getModuleName", "parameters": "(String _name)", "modifiers": "private", "return": "String", "signature": "String getModuleName(String _name)", "full_signature": "private String getModuleName(String _name)", "class_method_signature": "PythonArchiveAnalyzer.getModuleName(String _name)", "testcase": false, "constructor": false}, {"identifier": "getPackageName", "parameters": "(String _name, List<String> _inits)", "modifiers": "private", "return": "List<String>", "signature": "List<String> getPackageName(String _name, List<String> _inits)", "full_signature": "private List<String> getPackageName(String _name, List<String> _inits)", "class_method_signature": "PythonArchiveAnalyzer.getPackageName(String _name, List<String> _inits)", "testcase": false, "constructor": false}, {"identifier": "isPackage", "parameters": "(String _en)", "modifiers": "private", "return": "Boolean", "signature": "Boolean isPackage(String _en)", "full_signature": "private Boolean isPackage(String _en)", "class_method_signature": "PythonArchiveAnalyzer.isPackage(String _en)", "testcase": false, "constructor": false}, {"identifier": "getConstructs", "parameters": "()", "modifiers": "@Override public", "return": "Map<ConstructId, Construct>", "signature": "Map<ConstructId, Construct> getConstructs()", "full_signature": "@Override public Map<ConstructId, Construct> getConstructs()", "class_method_signature": "PythonArchiveAnalyzer.getConstructs()", "testcase": false, "constructor": false}, {"identifier": "getLibrary", "parameters": "()", "modifiers": "public", "return": "Library", "signature": "Library getLibrary()", "full_signature": "public Library getLibrary()", "class_method_signature": "PythonArchiveAnalyzer.getLibrary()", "testcase": false, "constructor": false}, {"identifier": "containsConstruct", "parameters": "(ConstructId _id)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean containsConstruct(ConstructId _id)", "full_signature": "@Override public boolean containsConstruct(ConstructId _id)", "class_method_signature": "PythonArchiveAnalyzer.containsConstruct(ConstructId _id)", "testcase": false, "constructor": false}, {"identifier": "getConstruct", "parameters": "(ConstructId _id)", "modifiers": "@Override public", "return": "Construct", "signature": "Construct getConstruct(ConstructId _id)", "full_signature": "@Override public Construct getConstruct(ConstructId _id)", "class_method_signature": "PythonArchiveAnalyzer.getConstruct(ConstructId _id)", "testcase": false, "constructor": false}, {"identifier": "hasChilds", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean hasChilds()", "full_signature": "@Override public boolean hasChilds()", "class_method_signature": "PythonArchiveAnalyzer.hasChilds()", "testcase": false, "constructor": false}, {"identifier": "getChilds", "parameters": "(boolean _recursive)", "modifiers": "@Override public", "return": "Set<FileAnalyzer>", "signature": "Set<FileAnalyzer> getChilds(boolean _recursive)", "full_signature": "@Override public Set<FileAnalyzer> getChilds(boolean _recursive)", "class_method_signature": "PythonArchiveAnalyzer.getChilds(boolean _recursive)", "testcase": false, "constructor": false}, {"identifier": "getSharedConstructs", "parameters": "()", "modifiers": "public", "return": "List<org.eclipse.steady.shared.json.model.ConstructId>", "signature": "List<org.eclipse.steady.shared.json.model.ConstructId> getSharedConstructs()", "full_signature": "public List<org.eclipse.steady.shared.json.model.ConstructId> getSharedConstructs()", "class_method_signature": "PythonArchiveAnalyzer.getSharedConstructs()", "testcase": false, "constructor": false}], "file": "lang-python/src/main/java/org/eclipse/steady/python/PythonArchiveAnalyzer.java"}, "focal_method": {"identifier": "getConstructs", "parameters": "()", "modifiers": "@Override public", "return": "Map<ConstructId, Construct>", "body": "@Override\n  public Map<ConstructId, Construct> getConstructs() throws FileAnalysisException {\n    if (this.constructs.isEmpty()) {\n\n      // list of __init__.py files (to become packages)\n      final List<String> inits = new ArrayList<String>();\n      boolean pre_processed = false;\n      try (InputStream is = this.getArchiveInputStream()) {\n\n        // Read archive to look for __init__.py\n        if (is instanceof ZipInputStream) {\n          ZipEntry en = null;\n          while ((en = ((ZipInputStream) is).getNextEntry()) != null) {\n            // loop over the archive to understand which files has an __init__.py\n            if (!en.isDirectory()) {\n              if (this.isPackage(en.getName())) {\n                inits.add(en.getName());\n              }\n            }\n          }\n        } else if (is instanceof TarArchiveInputStream) {\n          ArchiveEntry en = null;\n          while ((en = ((TarArchiveInputStream) is).getNextEntry()) != null) {\n            // Loop over the archive to understand which files has an __init__.py\n            if (!en.isDirectory()) {\n              if (this.isPackage(en.getName())) {\n                inits.add(en.getName());\n              }\n            }\n          }\n        }\n        pre_processed = true;\n      } catch (IOException e) {\n        log.error(\n            \"IOException analyzing Python archive [\" + this.archive.getAbsolutePath() + \"]\", e);\n      }\n\n      // Re-read archive to create constructs\n      try (InputStream is = this.getArchiveInputStream()) {\n\n        if (is instanceof ZipInputStream && pre_processed) {\n          ZipEntry en = null;\n          while ((en = ((ZipInputStream) is).getNextEntry()) != null) {\n\n            if (!en.isDirectory()) {\n              // check if it is a tar (wheel egg), then extract and analyze it (here or where??) !!!\n              if (en.getName().endsWith(\".whl\")\n                  || en.getName().endsWith(\".egg\")\n                  || en.getName().endsWith(\".gz\")) {\n                final FileAnalyzer fa = DirAnalyzer.createAnalyzerForArchiveEntry(is, en.getName());\n                if (fa != null) this.nestedAnalyzers.add(fa);\n              } else if (en.getName().endsWith(\".py\")) {\n\n                // Create the package (if any)\n                final List<String> package_name = this.getPackageName(en.getName(), inits);\n                PythonId pack = null;\n                if (!package_name.isEmpty())\n                  pack =\n                      new PythonId(null, PythonId.Type.PACKAGE, StringUtil.join(package_name, \".\"));\n\n                // Create module\n                final String module_name = this.getModuleName(en.getName());\n                final PythonId module = new PythonId(pack, PythonId.Type.MODULE, module_name);\n\n                // We put everything into a byte[] to avoid that the stream gets closed when read by\n                // antlr\n                final byte[] py_bytes = FileUtil.readInputStream(is);\n\n                final FileAnalyzer fa =\n                    PythonFileAnalyzer.createAnalyzer(new ByteArrayInputStream(py_bytes));\n                if (fa instanceof Python3FileAnalyzer) {\n                  ((Python3FileAnalyzer) fa).setContext(module, pack);\n                  this.constructs.putAll(\n                      ((Python3FileAnalyzer) fa).getConstructs(new ByteArrayInputStream(py_bytes)));\n                } else if (fa instanceof Python335FileAnalyzer) {\n                  ((Python335FileAnalyzer) fa).setContext(module, pack);\n                  this.constructs.putAll(\n                      ((Python335FileAnalyzer) fa)\n                          .getConstructs(new ByteArrayInputStream(py_bytes)));\n                }\n              }\n            }\n          }\n        }\n        // almost duplicated code from the alternative above as we have another type for the entry\n        // (ArchiveEntry from commons compress instead of ZipEntry from java.util.zip)\n        else if (is instanceof TarArchiveInputStream) {\n          ArchiveEntry en = null;\n          while ((en = ((TarArchiveInputStream) is).getNextEntry()) != null) {\n            if (!en.isDirectory()) {\n              // check if it is a tar (wheel egg), then extract and analyze it (here or where??) !!!\n              if (en.getName().endsWith(\".whl\")\n                  || en.getName().endsWith(\".egg\")\n                  || en.getName().endsWith(\".gz\")) {\n                final FileAnalyzer fa = DirAnalyzer.createAnalyzerForArchiveEntry(is, en.getName());\n                if (fa != null) this.nestedAnalyzers.add(fa);\n              } else if (en.getName().endsWith(\".py\")) {\n\n                // Create the package (if any)\n                final List<String> package_name = this.getPackageName(en.getName(), inits);\n                PythonId pack = null;\n                if (!package_name.isEmpty())\n                  pack =\n                      new PythonId(null, PythonId.Type.PACKAGE, StringUtil.join(package_name, \".\"));\n\n                // Create module\n                final String module_name = this.getModuleName(en.getName());\n                final PythonId module = new PythonId(pack, PythonId.Type.MODULE, module_name);\n\n                // We put everything into a byte[] to avoid that the stream gets closed when read by\n                // antlr\n                final byte[] py_bytes = FileUtil.readInputStream(is);\n\n                final FileAnalyzer fa =\n                    PythonFileAnalyzer.createAnalyzer(new ByteArrayInputStream(py_bytes));\n                if (fa instanceof Python3FileAnalyzer) {\n                  ((Python3FileAnalyzer) fa).setContext(module, pack);\n                  this.constructs.putAll(\n                      ((Python3FileAnalyzer) fa).getConstructs(new ByteArrayInputStream(py_bytes)));\n                } else if (fa instanceof Python335FileAnalyzer) {\n                  ((Python335FileAnalyzer) fa).setContext(module, pack);\n                  this.constructs.putAll(\n                      ((Python335FileAnalyzer) fa)\n                          .getConstructs(new ByteArrayInputStream(py_bytes)));\n                }\n              }\n            }\n          }\n        }\n      } catch (IOException e) {\n        log.error(\n            \"IOException analyzing Python archive [\" + this.archive.getAbsolutePath() + \"]\", e);\n      }\n    }\n\n    return constructs;\n  }", "signature": "Map<ConstructId, Construct> getConstructs()", "full_signature": "@Override public Map<ConstructId, Construct> getConstructs()", "class_method_signature": "PythonArchiveAnalyzer.getConstructs()", "testcase": false, "constructor": false, "invocations": ["isEmpty", "getArchiveInputStream", "getNextEntry", "isDirectory", "isPackage", "getName", "add", "getName", "getNextEntry", "isDirectory", "isPackage", "getName", "add", "getName", "error", "getAbsolutePath", "getArchiveInputStream", "getNextEntry", "isDirectory", "endsWith", "getName", "endsWith", "getName", "endsWith", "getName", "createAnalyzerForArchiveEntry", "getName", "add", "endsWith", "getName", "getPackageName", "getName", "isEmpty", "join", "getModuleName", "getName", "readInputStream", "createAnalyzer", "setContext", "putAll", "getConstructs", "setContext", "putAll", "getConstructs", "getNextEntry", "isDirectory", "endsWith", "getName", "endsWith", "getName", "endsWith", "getName", "createAnalyzerForArchiveEntry", "getName", "add", "endsWith", "getName", "getPackageName", "getName", "isEmpty", "join", "getModuleName", "getName", "readInputStream", "createAnalyzer", "setContext", "putAll", "getConstructs", "setContext", "putAll", "getConstructs", "error", "getAbsolutePath"]}, "repository": {"repo_id": 145424401, "url": "https://github.com/eclipse/steady", "stars": 353, "created": "8/20/2018 1:54:15 PM +00:00", "updates": "2020-01-25T08:37:00+00:00", "fork": "False", "license": "licensed"}}