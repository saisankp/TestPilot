{"test_class": {"identifier": "MapProjectionTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double[] GEOGRAPHIC = {\n    \t47.0, -14.0,\n    \t48.38824840214492, -14.967538330290973,\n    };", "modifier": "private static final", "type": "double[]", "declarator": "GEOGRAPHIC = {\n    \t47.0, -14.0,\n    \t48.38824840214492, -14.967538330290973,\n    }", "var_name": "GEOGRAPHIC"}, {"original_string": "private static final double[] PROJECTED = {\n    \t5232016.067283858, -1574216.548161465,\n    \t5386555.1725052055, -1685459.3322153771,\n   };", "modifier": "private static final", "type": "double[]", "declarator": "PROJECTED = {\n    \t5232016.067283858, -1574216.548161465,\n    \t5386555.1725052055, -1685459.3322153771,\n   }", "var_name": "PROJECTED"}], "file": "modules/library/referencing/src/test/java/org/geotools/referencing/operation/projection/MapProjectionTest.java"}, "test_case": {"identifier": "testOrthodromicDistance", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testOrthodromicDistance() throws FactoryException {\n        MapProjection mt = createGoogleMercator();\n        \n        // Test some large distances\n\t\tassertEquals(111319.49079,\n\t\t\t\tmt.orthodromicDistance(new Point2D.Double(0.0, 0.0),\n\t\t\t\tnew Point2D.Double(0.0, 1.0)), 0.001);\n\t\tassertEquals(111319.49079,\n\t\t\t\tmt.orthodromicDistance(new Point2D.Double(0.0, 0.0),\n\t\t\t\tnew Point2D.Double(1.0, 0.0)), 0.001);\n\t\tassertEquals(111319.49079,\n\t\t\t\tmt.orthodromicDistance(new Point2D.Double(0.0, 89.0),\n\t\t\t\tnew Point2D.Double(0.0, 90.0)), 0.001);\n\t\tassertEquals(1942.76834,\n\t\t\t\tmt.orthodromicDistance(new Point2D.Double(0.0, 89.0),\n\t\t\t\tnew Point2D.Double(1.0, 89.0)), 0.001);\n\t\tassertEquals(10018754.17139,\n\t\t\t\tmt.orthodromicDistance(new Point2D.Double(0.0, 0.0),\n\t\t\t\tnew Point2D.Double(0.0, 90.0)), 0.001);\n\t\t\n    \t// Test some small distances.\n    \tPoint2D src = new Point2D.Double(48.38824840214492, -14.967538330290973);\n    \tassertEquals(0.0, mt.orthodromicDistance(src, src), 0.000000001);\n\n    \tPoint2D target = new Point2D.Double(src.getX(), src.getY()+0.0000001);\n    \tassertEquals(0.011131948840096939, mt.orthodromicDistance(src, target), 1E-12);\n    \t\n    \tPoint2D target2 = new Point2D.Double(src.getX(), src.getY()+0.000000000001);\n    \tassertEquals(1.1117412E-7, mt.orthodromicDistance(src, target2), 1E-12);\n    }", "signature": "void testOrthodromicDistance()", "full_signature": "@Test public void testOrthodromicDistance()", "class_method_signature": "MapProjectionTest.testOrthodromicDistance()", "testcase": true, "constructor": false, "invocations": ["createGoogleMercator", "assertEquals", "orthodromicDistance", "assertEquals", "orthodromicDistance", "assertEquals", "orthodromicDistance", "assertEquals", "orthodromicDistance", "assertEquals", "orthodromicDistance", "assertEquals", "orthodromicDistance", "getX", "getY", "assertEquals", "orthodromicDistance", "getX", "getY", "assertEquals", "orthodromicDistance"]}, "focal_class": {"identifier": "MapProjection", "superclass": "extends AbstractMathTransform", "interfaces": "implements MathTransform2D, Serializable", "fields": [{"original_string": "public static boolean SKIP_SANITY_CHECKS = false;", "modifier": "public static", "type": "boolean", "declarator": "SKIP_SANITY_CHECKS = false", "var_name": "SKIP_SANITY_CHECKS"}, {"original_string": "private static final long serialVersionUID = -406751619777246914L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = -406751619777246914L", "var_name": "serialVersionUID"}, {"original_string": "protected static final Logger LOGGER = Logging.getLogger(MapProjection.class);", "modifier": "protected static final", "type": "Logger", "declarator": "LOGGER = Logging.getLogger(MapProjection.class)", "var_name": "LOGGER"}, {"original_string": "private static final double EPSILON = 1E-6;", "modifier": "private static final", "type": "double", "declarator": "EPSILON = 1E-6", "var_name": "EPSILON"}, {"original_string": "private static final double ANGLE_TOLERANCE = 1E-4;", "modifier": "private static final", "type": "double", "declarator": "ANGLE_TOLERANCE = 1E-4", "var_name": "ANGLE_TOLERANCE"}, {"original_string": "private static final double ITERATION_TOLERANCE = 1E-10;", "modifier": "private static final", "type": "double", "declarator": "ITERATION_TOLERANCE = 1E-10", "var_name": "ITERATION_TOLERANCE"}, {"original_string": "private static final double MLFN_TOL = 1E-11;", "modifier": "private static final", "type": "double", "declarator": "MLFN_TOL = 1E-11", "var_name": "MLFN_TOL"}, {"original_string": "private static final int MAXIMUM_ITERATIONS = 15;", "modifier": "private static final", "type": "int", "declarator": "MAXIMUM_ITERATIONS = 15", "var_name": "MAXIMUM_ITERATIONS"}, {"original_string": "private static final double C00= 1.0,\n                                C02= 0.25,\n                                C04= 0.046875,\n                                C06= 0.01953125,\n                                C08= 0.01068115234375,\n                                C22= 0.75,\n                                C44= 0.46875,\n                                C46= 0.01302083333333333333,\n                                C48= 0.00712076822916666666,\n                                C66= 0.36458333333333333333,\n                                C68= 0.00569661458333333333,\n                                C88= 0.3076171875;", "modifier": "private static final", "type": "double", "declarator": "C00= 1.0", "var_name": "C00"}, {"original_string": "protected final double excentricity;", "modifier": "protected final", "type": "double", "declarator": "excentricity", "var_name": "excentricity"}, {"original_string": "protected final double excentricitySquared;", "modifier": "protected final", "type": "double", "declarator": "excentricitySquared", "var_name": "excentricitySquared"}, {"original_string": "protected final boolean isSpherical;", "modifier": "protected final", "type": "boolean", "declarator": "isSpherical", "var_name": "isSpherical"}, {"original_string": "protected final double semiMajor;", "modifier": "protected final", "type": "double", "declarator": "semiMajor", "var_name": "semiMajor"}, {"original_string": "protected final double semiMinor;", "modifier": "protected final", "type": "double", "declarator": "semiMinor", "var_name": "semiMinor"}, {"original_string": "protected double centralMeridian;", "modifier": "protected", "type": "double", "declarator": "centralMeridian", "var_name": "centralMeridian"}, {"original_string": "protected double latitudeOfOrigin;", "modifier": "protected", "type": "double", "declarator": "latitudeOfOrigin", "var_name": "latitudeOfOrigin"}, {"original_string": "protected double scaleFactor;", "modifier": "protected", "type": "double", "declarator": "scaleFactor", "var_name": "scaleFactor"}, {"original_string": "protected final double falseEasting;", "modifier": "protected final", "type": "double", "declarator": "falseEasting", "var_name": "falseEasting"}, {"original_string": "protected final double falseNorthing;", "modifier": "protected final", "type": "double", "declarator": "falseNorthing", "var_name": "falseNorthing"}, {"original_string": "protected double globalScale;", "modifier": "protected", "type": "double", "declarator": "globalScale", "var_name": "globalScale"}, {"original_string": "private transient MathTransform2D inverse;", "modifier": "private transient", "type": "MathTransform2D", "declarator": "inverse", "var_name": "inverse"}, {"original_string": "protected double en0,en1,en2,en3,en4;", "modifier": "protected", "type": "double", "declarator": "en0", "var_name": "en0"}, {"original_string": "private transient int rangeCheckSemaphore;", "modifier": "private transient", "type": "int", "declarator": "rangeCheckSemaphore", "var_name": "rangeCheckSemaphore"}, {"original_string": "private static int globalRangeCheckSemaphore = 1;", "modifier": "private static", "type": "int", "declarator": "globalRangeCheckSemaphore = 1", "var_name": "globalRangeCheckSemaphore"}, {"original_string": "protected boolean invertible = true;", "modifier": "protected", "type": "boolean", "declarator": "invertible = true", "var_name": "invertible"}], "methods": [{"identifier": "MapProjection", "parameters": "(final ParameterValueGroup values)", "modifiers": "protected", "return": "", "signature": " MapProjection(final ParameterValueGroup values)", "full_signature": "protected  MapProjection(final ParameterValueGroup values)", "class_method_signature": "MapProjection.MapProjection(final ParameterValueGroup values)", "testcase": false, "constructor": true}, {"identifier": "MapProjection", "parameters": "(final ParameterValueGroup values, Collection<GeneralParameterDescriptor> expected)", "modifiers": "", "return": "", "signature": " MapProjection(final ParameterValueGroup values, Collection<GeneralParameterDescriptor> expected)", "full_signature": "  MapProjection(final ParameterValueGroup values, Collection<GeneralParameterDescriptor> expected)", "class_method_signature": "MapProjection.MapProjection(final ParameterValueGroup values, Collection<GeneralParameterDescriptor> expected)", "testcase": false, "constructor": true}, {"identifier": "isExpectedParameter", "parameters": "(final Collection<GeneralParameterDescriptor> expected,\n                                final ParameterDescriptor param)", "modifiers": "", "return": "boolean", "signature": "boolean isExpectedParameter(final Collection<GeneralParameterDescriptor> expected,\n                                final ParameterDescriptor param)", "full_signature": " boolean isExpectedParameter(final Collection<GeneralParameterDescriptor> expected,\n                                final ParameterDescriptor param)", "class_method_signature": "MapProjection.isExpectedParameter(final Collection<GeneralParameterDescriptor> expected,\n                                final ParameterDescriptor param)", "testcase": false, "constructor": false}, {"identifier": "doubleValue", "parameters": "(final Collection<GeneralParameterDescriptor> expected,\n                             final ParameterDescriptor param,\n                             final ParameterValueGroup group)", "modifiers": "final", "return": "double", "signature": "double doubleValue(final Collection<GeneralParameterDescriptor> expected,\n                             final ParameterDescriptor param,\n                             final ParameterValueGroup group)", "full_signature": "final double doubleValue(final Collection<GeneralParameterDescriptor> expected,\n                             final ParameterDescriptor param,\n                             final ParameterValueGroup group)", "class_method_signature": "MapProjection.doubleValue(final Collection<GeneralParameterDescriptor> expected,\n                             final ParameterDescriptor param,\n                             final ParameterValueGroup group)", "testcase": false, "constructor": false}, {"identifier": "ensureSpherical", "parameters": "()", "modifiers": "final", "return": "void", "signature": "void ensureSpherical()", "full_signature": "final void ensureSpherical()", "class_method_signature": "MapProjection.ensureSpherical()", "testcase": false, "constructor": false}, {"identifier": "ensureLatitudeEquals", "parameters": "(final ParameterDescriptor name, double y, double expected)", "modifiers": "static", "return": "void", "signature": "void ensureLatitudeEquals(final ParameterDescriptor name, double y, double expected)", "full_signature": "static void ensureLatitudeEquals(final ParameterDescriptor name, double y, double expected)", "class_method_signature": "MapProjection.ensureLatitudeEquals(final ParameterDescriptor name, double y, double expected)", "testcase": false, "constructor": false}, {"identifier": "ensureLatitudeInRange", "parameters": "(final ParameterDescriptor name, double y, final boolean edge)", "modifiers": "static", "return": "void", "signature": "void ensureLatitudeInRange(final ParameterDescriptor name, double y, final boolean edge)", "full_signature": "static void ensureLatitudeInRange(final ParameterDescriptor name, double y, final boolean edge)", "class_method_signature": "MapProjection.ensureLatitudeInRange(final ParameterDescriptor name, double y, final boolean edge)", "testcase": false, "constructor": false}, {"identifier": "ensureLongitudeInRange", "parameters": "(final ParameterDescriptor name, double x, final boolean edge)", "modifiers": "static", "return": "void", "signature": "void ensureLongitudeInRange(final ParameterDescriptor name, double x, final boolean edge)", "full_signature": "static void ensureLongitudeInRange(final ParameterDescriptor name, double x, final boolean edge)", "class_method_signature": "MapProjection.ensureLongitudeInRange(final ParameterDescriptor name, double x, final boolean edge)", "testcase": false, "constructor": false}, {"identifier": "verifyGeographicRanges", "parameters": "(final AbstractMathTransform tr,\n                                                  final double x, final double y)", "modifiers": "private static", "return": "boolean", "signature": "boolean verifyGeographicRanges(final AbstractMathTransform tr,\n                                                  final double x, final double y)", "full_signature": "private static boolean verifyGeographicRanges(final AbstractMathTransform tr,\n                                                  final double x, final double y)", "class_method_signature": "MapProjection.verifyGeographicRanges(final AbstractMathTransform tr,\n                                                  final double x, final double y)", "testcase": false, "constructor": false}, {"identifier": "set", "parameters": "(final Collection<GeneralParameterDescriptor> expected,\n                   final ParameterDescriptor<?> param,\n                   final ParameterValueGroup group,\n                   double value)", "modifiers": "final", "return": "void", "signature": "void set(final Collection<GeneralParameterDescriptor> expected,\n                   final ParameterDescriptor<?> param,\n                   final ParameterValueGroup group,\n                   double value)", "full_signature": "final void set(final Collection<GeneralParameterDescriptor> expected,\n                   final ParameterDescriptor<?> param,\n                   final ParameterValueGroup group,\n                   double value)", "class_method_signature": "MapProjection.set(final Collection<GeneralParameterDescriptor> expected,\n                   final ParameterDescriptor<?> param,\n                   final ParameterValueGroup group,\n                   double value)", "testcase": false, "constructor": false}, {"identifier": "getParameterDescriptors", "parameters": "()", "modifiers": "@Override public abstract", "return": "ParameterDescriptorGroup", "signature": "ParameterDescriptorGroup getParameterDescriptors()", "full_signature": "@Override public abstract ParameterDescriptorGroup getParameterDescriptors()", "class_method_signature": "MapProjection.getParameterDescriptors()", "testcase": false, "constructor": false}, {"identifier": "getParameterValues", "parameters": "()", "modifiers": "@Override public", "return": "ParameterValueGroup", "signature": "ParameterValueGroup getParameterValues()", "full_signature": "@Override public ParameterValueGroup getParameterValues()", "class_method_signature": "MapProjection.getParameterValues()", "testcase": false, "constructor": false}, {"identifier": "getSourceDimensions", "parameters": "()", "modifiers": "public final", "return": "int", "signature": "int getSourceDimensions()", "full_signature": "public final int getSourceDimensions()", "class_method_signature": "MapProjection.getSourceDimensions()", "testcase": false, "constructor": false}, {"identifier": "getTargetDimensions", "parameters": "()", "modifiers": "public final", "return": "int", "signature": "int getTargetDimensions()", "full_signature": "public final int getTargetDimensions()", "class_method_signature": "MapProjection.getTargetDimensions()", "testcase": false, "constructor": false}, {"identifier": "orthodromicDistance", "parameters": "(final Point2D source, final Point2D target)", "modifiers": "protected", "return": "double", "signature": "double orthodromicDistance(final Point2D source, final Point2D target)", "full_signature": "protected double orthodromicDistance(final Point2D source, final Point2D target)", "class_method_signature": "MapProjection.orthodromicDistance(final Point2D source, final Point2D target)", "testcase": false, "constructor": false}, {"identifier": "checkReciprocal", "parameters": "(Point2D point, final Point2D target, final boolean inverse)", "modifiers": "protected", "return": "boolean", "signature": "boolean checkReciprocal(Point2D point, final Point2D target, final boolean inverse)", "full_signature": "protected boolean checkReciprocal(Point2D point, final Point2D target, final boolean inverse)", "class_method_signature": "MapProjection.checkReciprocal(Point2D point, final Point2D target, final boolean inverse)", "testcase": false, "constructor": false}, {"identifier": "checkTransform", "parameters": "(final double x, final double y,\n                                  final Point2D expected, final double tolerance)", "modifiers": "static", "return": "boolean", "signature": "boolean checkTransform(final double x, final double y,\n                                  final Point2D expected, final double tolerance)", "full_signature": "static boolean checkTransform(final double x, final double y,\n                                  final Point2D expected, final double tolerance)", "class_method_signature": "MapProjection.checkTransform(final double x, final double y,\n                                  final Point2D expected, final double tolerance)", "testcase": false, "constructor": false}, {"identifier": "checkTransform", "parameters": "(final double x, final double y, final Point2D expected)", "modifiers": "static", "return": "boolean", "signature": "boolean checkTransform(final double x, final double y, final Point2D expected)", "full_signature": "static boolean checkTransform(final double x, final double y, final Point2D expected)", "class_method_signature": "MapProjection.checkTransform(final double x, final double y, final Point2D expected)", "testcase": false, "constructor": false}, {"identifier": "checkInverseTransform", "parameters": "(final double longitude, final double latitude,\n                                         final Point2D expected, final double tolerance)", "modifiers": "static", "return": "boolean", "signature": "boolean checkInverseTransform(final double longitude, final double latitude,\n                                         final Point2D expected, final double tolerance)", "full_signature": "static boolean checkInverseTransform(final double longitude, final double latitude,\n                                         final Point2D expected, final double tolerance)", "class_method_signature": "MapProjection.checkInverseTransform(final double longitude, final double latitude,\n                                         final Point2D expected, final double tolerance)", "testcase": false, "constructor": false}, {"identifier": "checkInverseTransform", "parameters": "(double longitude, double latitude, Point2D expected)", "modifiers": "static", "return": "boolean", "signature": "boolean checkInverseTransform(double longitude, double latitude, Point2D expected)", "full_signature": "static boolean checkInverseTransform(double longitude, double latitude, Point2D expected)", "class_method_signature": "MapProjection.checkInverseTransform(double longitude, double latitude, Point2D expected)", "testcase": false, "constructor": false}, {"identifier": "compare", "parameters": "(String variable, double expected, double actual, double tolerance)", "modifiers": "private static", "return": "void", "signature": "void compare(String variable, double expected, double actual, double tolerance)", "full_signature": "private static void compare(String variable, double expected, double actual, double tolerance)", "class_method_signature": "MapProjection.compare(String variable, double expected, double actual, double tolerance)", "testcase": false, "constructor": false}, {"identifier": "inverseTransformNormalized", "parameters": "(double x, double y, final Point2D ptDst)", "modifiers": "protected abstract", "return": "Point2D", "signature": "Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)", "full_signature": "protected abstract Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)", "class_method_signature": "MapProjection.inverseTransformNormalized(double x, double y, final Point2D ptDst)", "testcase": false, "constructor": false}, {"identifier": "transformNormalized", "parameters": "(double lambda, double phi, final Point2D ptDst)", "modifiers": "protected abstract", "return": "Point2D", "signature": "Point2D transformNormalized(double lambda, double phi, final Point2D ptDst)", "full_signature": "protected abstract Point2D transformNormalized(double lambda, double phi, final Point2D ptDst)", "class_method_signature": "MapProjection.transformNormalized(double lambda, double phi, final Point2D ptDst)", "testcase": false, "constructor": false}, {"identifier": "transform", "parameters": "(final Point2D ptSrc, Point2D ptDst)", "modifiers": "@Override public final", "return": "Point2D", "signature": "Point2D transform(final Point2D ptSrc, Point2D ptDst)", "full_signature": "@Override public final Point2D transform(final Point2D ptSrc, Point2D ptDst)", "class_method_signature": "MapProjection.transform(final Point2D ptSrc, Point2D ptDst)", "testcase": false, "constructor": false}, {"identifier": "transform", "parameters": "(final double[] srcPts, int srcOff,\n                                final double[] dstPts, int dstOff, int numPts)", "modifiers": "public final", "return": "void", "signature": "void transform(final double[] srcPts, int srcOff,\n                                final double[] dstPts, int dstOff, int numPts)", "full_signature": "public final void transform(final double[] srcPts, int srcOff,\n                                final double[] dstPts, int dstOff, int numPts)", "class_method_signature": "MapProjection.transform(final double[] srcPts, int srcOff,\n                                final double[] dstPts, int dstOff, int numPts)", "testcase": false, "constructor": false}, {"identifier": "transform", "parameters": "(final float[] srcPts, int srcOff,\n                                final float[] dstPts, int dstOff, int numPts)", "modifiers": "@Override public final", "return": "void", "signature": "void transform(final float[] srcPts, int srcOff,\n                                final float[] dstPts, int dstOff, int numPts)", "full_signature": "@Override public final void transform(final float[] srcPts, int srcOff,\n                                final float[] dstPts, int dstOff, int numPts)", "class_method_signature": "MapProjection.transform(final float[] srcPts, int srcOff,\n                                final float[] dstPts, int dstOff, int numPts)", "testcase": false, "constructor": false}, {"identifier": "inverse", "parameters": "()", "modifiers": "@Override public final", "return": "MathTransform2D", "signature": "MathTransform2D inverse()", "full_signature": "@Override public final MathTransform2D inverse()", "class_method_signature": "MapProjection.inverse()", "testcase": false, "constructor": false}, {"identifier": "getToleranceForAssertions", "parameters": "(final double longitude, final double latitude)", "modifiers": "protected", "return": "double", "signature": "double getToleranceForAssertions(final double longitude, final double latitude)", "full_signature": "protected double getToleranceForAssertions(final double longitude, final double latitude)", "class_method_signature": "MapProjection.getToleranceForAssertions(final double longitude, final double latitude)", "testcase": false, "constructor": false}, {"identifier": "verifyCoordinateRanges", "parameters": "()", "modifiers": "final", "return": "boolean", "signature": "boolean verifyCoordinateRanges()", "full_signature": "final boolean verifyCoordinateRanges()", "class_method_signature": "MapProjection.verifyCoordinateRanges()", "testcase": false, "constructor": false}, {"identifier": "warningLogged", "parameters": "()", "modifiers": "final", "return": "void", "signature": "void warningLogged()", "full_signature": "final void warningLogged()", "class_method_signature": "MapProjection.warningLogged()", "testcase": false, "constructor": false}, {"identifier": "resetWarnings", "parameters": "()", "modifiers": "public static synchronized", "return": "void", "signature": "void resetWarnings()", "full_signature": "public static synchronized void resetWarnings()", "class_method_signature": "MapProjection.resetWarnings()", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "MapProjection.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(final Object object)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(final Object object)", "full_signature": "@Override public boolean equals(final Object object)", "class_method_signature": "MapProjection.equals(final Object object)", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(final double value1, final double value2)", "modifiers": "static", "return": "boolean", "signature": "boolean equals(final double value1, final double value2)", "full_signature": "static boolean equals(final double value1, final double value2)", "class_method_signature": "MapProjection.equals(final double value1, final double value2)", "testcase": false, "constructor": false}, {"identifier": "cphi2", "parameters": "(final double ts)", "modifiers": "final", "return": "double", "signature": "double cphi2(final double ts)", "full_signature": "final double cphi2(final double ts)", "class_method_signature": "MapProjection.cphi2(final double ts)", "testcase": false, "constructor": false}, {"identifier": "msfn", "parameters": "(final double s, final double c)", "modifiers": "final", "return": "double", "signature": "double msfn(final double s, final double c)", "full_signature": "final double msfn(final double s, final double c)", "class_method_signature": "MapProjection.msfn(final double s, final double c)", "testcase": false, "constructor": false}, {"identifier": "tsfn", "parameters": "(final double phi, double sinphi)", "modifiers": "final", "return": "double", "signature": "double tsfn(final double phi, double sinphi)", "full_signature": "final double tsfn(final double phi, double sinphi)", "class_method_signature": "MapProjection.tsfn(final double phi, double sinphi)", "testcase": false, "constructor": false}, {"identifier": "mlfn", "parameters": "(final double phi, double sphi, double cphi)", "modifiers": "protected final", "return": "double", "signature": "double mlfn(final double phi, double sphi, double cphi)", "full_signature": "protected final double mlfn(final double phi, double sphi, double cphi)", "class_method_signature": "MapProjection.mlfn(final double phi, double sphi, double cphi)", "testcase": false, "constructor": false}, {"identifier": "inv_mlfn", "parameters": "(double arg)", "modifiers": "protected final", "return": "double", "signature": "double inv_mlfn(double arg)", "full_signature": "protected final double inv_mlfn(double arg)", "class_method_signature": "MapProjection.inv_mlfn(double arg)", "testcase": false, "constructor": false}, {"identifier": "aasin", "parameters": "(double v)", "modifiers": "", "return": "double", "signature": "double aasin(double v)", "full_signature": " double aasin(double v)", "class_method_signature": "MapProjection.aasin(double v)", "testcase": false, "constructor": false}], "file": "modules/library/referencing/src/main/java/org/geotools/referencing/operation/projection/MapProjection.java"}, "focal_method": {"identifier": "orthodromicDistance", "parameters": "(final Point2D source, final Point2D target)", "modifiers": "protected", "return": "double", "body": "protected double orthodromicDistance(final Point2D source, final Point2D target) {\n        // The orthodromic distance calculation here does not work well over short \n        // distances, so we only use it if we believe the distance is significant.\n        if (source.distanceSq(target) > 1.0) {\n            final double y1 = toRadians(source.getY());\n            final double y2 = toRadians(target.getY());\n            final double dx = toRadians(abs(target.getX() - source.getX()) % 360);\n            double rho = sin(y1)*sin(y2) + cos(y1)*cos(y2)*cos(dx);\n            if (rho > +1) {assert rho <= +(1+EPSILON) : rho; rho = +1;}\n            if (rho < -1) {assert rho >= -(1+EPSILON) : rho; rho = -1;}\n            return acos(rho) * semiMajor;\n        } else {\n            // Otherwise we approximate using alternate means. This is based\n            // on the Haversine formula to compute the arc angle between the\n            // point (derived from S2LatLng.getDistance()) which is stable for\n            // small distances.\n            double lat1 = toRadians(source.getY());\n            double lat2 = toRadians(target.getY());\n            double lng1 = toRadians(source.getX());\n            double lng2 = toRadians(target.getX());\n            double dlat = Math.sin(0.5 * (lat2 - lat1));\n            double dlng = Math.sin(0.5 * (lng2 - lng1));\n            double x = dlat * dlat + dlng * dlng * Math.cos(lat1) * Math.cos(lat2);\n            double arcRadians = 2 * Math.atan2(Math.sqrt(x), Math.sqrt(Math.max(0.0, 1.0 - x)));\n            return arcRadians * semiMajor;\n        }\n    }", "signature": "double orthodromicDistance(final Point2D source, final Point2D target)", "full_signature": "protected double orthodromicDistance(final Point2D source, final Point2D target)", "class_method_signature": "MapProjection.orthodromicDistance(final Point2D source, final Point2D target)", "testcase": false, "constructor": false, "invocations": ["distanceSq", "toRadians", "getY", "toRadians", "getY", "toRadians", "abs", "getX", "getX", "sin", "sin", "cos", "cos", "cos", "acos", "toRadians", "getY", "toRadians", "getY", "toRadians", "getX", "toRadians", "getX", "sin", "sin", "cos", "cos", "atan2", "sqrt", "sqrt", "max"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}