{"test_class": {"identifier": "BLASTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double TOL = 1.0e-8;", "modifier": "private static final", "type": "double", "declarator": "TOL = 1.0e-8", "var_name": "TOL"}, {"original_string": "private DenseMatrix mat = new DenseMatrix(2, 3, new double[]{1, 4, 2, 5, 3, 6});", "modifier": "private", "type": "DenseMatrix", "declarator": "mat = new DenseMatrix(2, 3, new double[]{1, 4, 2, 5, 3, 6})", "var_name": "mat"}, {"original_string": "private DenseVector dv1 = new DenseVector(new double[]{1, 2});", "modifier": "private", "type": "DenseVector", "declarator": "dv1 = new DenseVector(new double[]{1, 2})", "var_name": "dv1"}, {"original_string": "private DenseVector dv2 = new DenseVector(new double[]{1, 2, 3});", "modifier": "private", "type": "DenseVector", "declarator": "dv2 = new DenseVector(new double[]{1, 2, 3})", "var_name": "dv2"}, {"original_string": "private SparseVector spv1 = new SparseVector(2, new int[]{0, 1}, new double[]{1, 2});", "modifier": "private", "type": "SparseVector", "declarator": "spv1 = new SparseVector(2, new int[]{0, 1}, new double[]{1, 2})", "var_name": "spv1"}, {"original_string": "private SparseVector spv2 = new SparseVector(3, new int[]{0, 2}, new double[]{1, 3});", "modifier": "private", "type": "SparseVector", "declarator": "spv2 = new SparseVector(3, new int[]{0, 2}, new double[]{1, 3})", "var_name": "spv2"}, {"original_string": "@Rule\n    public ExpectedException thrown = ExpectedException.none();", "modifier": "@Rule\n    public", "type": "ExpectedException", "declarator": "thrown = ExpectedException.none()", "var_name": "thrown"}], "file": "core/src/test/java/com/alibaba/alink/common/linalg/BLASTest.java"}, "test_case": {"identifier": "testGemm", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGemm() throws Exception {\n        DenseMatrix m32 = DenseMatrix.rand(3, 2);\n        DenseMatrix m24 = DenseMatrix.rand(2, 4);\n        DenseMatrix m34 = DenseMatrix.rand(3, 4);\n        DenseMatrix m42 = DenseMatrix.rand(4, 2);\n        DenseMatrix m43 = DenseMatrix.rand(4, 3);\n\n        DenseMatrix a34 = DenseMatrix.zeros(3, 4);\n        BLAS.gemm(1.0, m32, false, m24, false, 0., a34);\n        Assert.assertArrayEquals(a34.getData(), simpleMM(m32, m24).getData(), TOL);\n\n        BLAS.gemm(1.0, m32, false, m42, true, 0., a34);\n        Assert.assertArrayEquals(a34.getData(), simpleMM(m32, m42.transpose()).getData(), TOL);\n\n        DenseMatrix a24 = DenseMatrix.zeros(2, 4);\n        BLAS.gemm(1.0, m32, true, m34, false, 0., a24);\n        Assert.assertArrayEquals(a24.getData(), simpleMM(m32.transpose(), m34).getData(), TOL);\n\n        BLAS.gemm(1.0, m32, true, m43, true, 0., a24);\n        Assert.assertArrayEquals(a24.getData(), simpleMM(m32.transpose(), m43.transpose()).getData(), TOL);\n    }", "signature": "void testGemm()", "full_signature": "@Test public void testGemm()", "class_method_signature": "BLASTest.testGemm()", "testcase": true, "constructor": false, "invocations": ["rand", "rand", "rand", "rand", "rand", "zeros", "gemm", "assertArrayEquals", "getData", "getData", "simpleMM", "gemm", "assertArrayEquals", "getData", "getData", "simpleMM", "transpose", "zeros", "gemm", "assertArrayEquals", "getData", "getData", "simpleMM", "transpose", "gemm", "assertArrayEquals", "getData", "getData", "simpleMM", "transpose", "transpose"]}, "focal_class": {"identifier": "BLAS", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final com.github.fommil.netlib.BLAS F2J_BLAS = new F2jBLAS();", "modifier": "private static final", "type": "com.github.fommil.netlib.BLAS", "declarator": "F2J_BLAS = new F2jBLAS()", "var_name": "F2J_BLAS"}, {"original_string": "private static final com.github.fommil.netlib.BLAS NATIVE_BLAS = com.github.fommil.netlib.BLAS.getInstance();", "modifier": "private static final", "type": "com.github.fommil.netlib.BLAS", "declarator": "NATIVE_BLAS = com.github.fommil.netlib.BLAS.getInstance()", "var_name": "NATIVE_BLAS"}], "methods": [{"identifier": "asum", "parameters": "(int n, double[] x, int offset)", "modifiers": "public static", "return": "double", "signature": "double asum(int n, double[] x, int offset)", "full_signature": "public static double asum(int n, double[] x, int offset)", "class_method_signature": "BLAS.asum(int n, double[] x, int offset)", "testcase": false, "constructor": false}, {"identifier": "asum", "parameters": "(DenseVector x)", "modifiers": "public static", "return": "double", "signature": "double asum(DenseVector x)", "full_signature": "public static double asum(DenseVector x)", "class_method_signature": "BLAS.asum(DenseVector x)", "testcase": false, "constructor": false}, {"identifier": "asum", "parameters": "(SparseVector x)", "modifiers": "public static", "return": "double", "signature": "double asum(SparseVector x)", "full_signature": "public static double asum(SparseVector x)", "class_method_signature": "BLAS.asum(SparseVector x)", "testcase": false, "constructor": false}, {"identifier": "axpy", "parameters": "(double a, double[] x, double[] y)", "modifiers": "public static", "return": "void", "signature": "void axpy(double a, double[] x, double[] y)", "full_signature": "public static void axpy(double a, double[] x, double[] y)", "class_method_signature": "BLAS.axpy(double a, double[] x, double[] y)", "testcase": false, "constructor": false}, {"identifier": "axpy", "parameters": "(double a, DenseVector x, DenseVector y)", "modifiers": "public static", "return": "void", "signature": "void axpy(double a, DenseVector x, DenseVector y)", "full_signature": "public static void axpy(double a, DenseVector x, DenseVector y)", "class_method_signature": "BLAS.axpy(double a, DenseVector x, DenseVector y)", "testcase": false, "constructor": false}, {"identifier": "axpy", "parameters": "(double a, SparseVector x, DenseVector y)", "modifiers": "public static", "return": "void", "signature": "void axpy(double a, SparseVector x, DenseVector y)", "full_signature": "public static void axpy(double a, SparseVector x, DenseVector y)", "class_method_signature": "BLAS.axpy(double a, SparseVector x, DenseVector y)", "testcase": false, "constructor": false}, {"identifier": "axpy", "parameters": "(double a, Vector x, DenseVector y)", "modifiers": "public static", "return": "void", "signature": "void axpy(double a, Vector x, DenseVector y)", "full_signature": "public static void axpy(double a, Vector x, DenseVector y)", "class_method_signature": "BLAS.axpy(double a, Vector x, DenseVector y)", "testcase": false, "constructor": false}, {"identifier": "axpy", "parameters": "(double a, DenseMatrix x, DenseMatrix y)", "modifiers": "public static", "return": "void", "signature": "void axpy(double a, DenseMatrix x, DenseMatrix y)", "full_signature": "public static void axpy(double a, DenseMatrix x, DenseMatrix y)", "class_method_signature": "BLAS.axpy(double a, DenseMatrix x, DenseMatrix y)", "testcase": false, "constructor": false}, {"identifier": "axpy", "parameters": "(int n, double a, double[] x, int xOffset, double[] y, int yOffset)", "modifiers": "public static", "return": "void", "signature": "void axpy(int n, double a, double[] x, int xOffset, double[] y, int yOffset)", "full_signature": "public static void axpy(int n, double a, double[] x, int xOffset, double[] y, int yOffset)", "class_method_signature": "BLAS.axpy(int n, double a, double[] x, int xOffset, double[] y, int yOffset)", "testcase": false, "constructor": false}, {"identifier": "dot", "parameters": "(double[] x, double[] y)", "modifiers": "public static", "return": "double", "signature": "double dot(double[] x, double[] y)", "full_signature": "public static double dot(double[] x, double[] y)", "class_method_signature": "BLAS.dot(double[] x, double[] y)", "testcase": false, "constructor": false}, {"identifier": "dot", "parameters": "(DenseVector x, DenseVector y)", "modifiers": "public static", "return": "double", "signature": "double dot(DenseVector x, DenseVector y)", "full_signature": "public static double dot(DenseVector x, DenseVector y)", "class_method_signature": "BLAS.dot(DenseVector x, DenseVector y)", "testcase": false, "constructor": false}, {"identifier": "scal", "parameters": "(double a, double[] x)", "modifiers": "public static", "return": "void", "signature": "void scal(double a, double[] x)", "full_signature": "public static void scal(double a, double[] x)", "class_method_signature": "BLAS.scal(double a, double[] x)", "testcase": false, "constructor": false}, {"identifier": "scal", "parameters": "(double a, double[] x, int xOffset, int length)", "modifiers": "public static", "return": "void", "signature": "void scal(double a, double[] x, int xOffset, int length)", "full_signature": "public static void scal(double a, double[] x, int xOffset, int length)", "class_method_signature": "BLAS.scal(double a, double[] x, int xOffset, int length)", "testcase": false, "constructor": false}, {"identifier": "scal", "parameters": "(double a, DenseVector x)", "modifiers": "public static", "return": "void", "signature": "void scal(double a, DenseVector x)", "full_signature": "public static void scal(double a, DenseVector x)", "class_method_signature": "BLAS.scal(double a, DenseVector x)", "testcase": false, "constructor": false}, {"identifier": "scal", "parameters": "(double a, SparseVector x)", "modifiers": "public static", "return": "void", "signature": "void scal(double a, SparseVector x)", "full_signature": "public static void scal(double a, SparseVector x)", "class_method_signature": "BLAS.scal(double a, SparseVector x)", "testcase": false, "constructor": false}, {"identifier": "scal", "parameters": "(double a, DenseMatrix x)", "modifiers": "public static", "return": "void", "signature": "void scal(double a, DenseMatrix x)", "full_signature": "public static void scal(double a, DenseMatrix x)", "class_method_signature": "BLAS.scal(double a, DenseMatrix x)", "testcase": false, "constructor": false}, {"identifier": "gemm", "parameters": "(double alpha, DenseMatrix matA, boolean transA, DenseMatrix matB, boolean transB,\n                            double beta, DenseMatrix matC)", "modifiers": "public static", "return": "void", "signature": "void gemm(double alpha, DenseMatrix matA, boolean transA, DenseMatrix matB, boolean transB,\n                            double beta, DenseMatrix matC)", "full_signature": "public static void gemm(double alpha, DenseMatrix matA, boolean transA, DenseMatrix matB, boolean transB,\n                            double beta, DenseMatrix matC)", "class_method_signature": "BLAS.gemm(double alpha, DenseMatrix matA, boolean transA, DenseMatrix matB, boolean transB,\n                            double beta, DenseMatrix matC)", "testcase": false, "constructor": false}, {"identifier": "gemvDimensionCheck", "parameters": "(DenseMatrix matA, boolean transA, Vector x, Vector y)", "modifiers": "private static", "return": "void", "signature": "void gemvDimensionCheck(DenseMatrix matA, boolean transA, Vector x, Vector y)", "full_signature": "private static void gemvDimensionCheck(DenseMatrix matA, boolean transA, Vector x, Vector y)", "class_method_signature": "BLAS.gemvDimensionCheck(DenseMatrix matA, boolean transA, Vector x, Vector y)", "testcase": false, "constructor": false}, {"identifier": "gemv", "parameters": "(double alpha, DenseMatrix matA, boolean transA,\n                            Vector x, double beta, DenseVector y)", "modifiers": "public static", "return": "void", "signature": "void gemv(double alpha, DenseMatrix matA, boolean transA,\n                            Vector x, double beta, DenseVector y)", "full_signature": "public static void gemv(double alpha, DenseMatrix matA, boolean transA,\n                            Vector x, double beta, DenseVector y)", "class_method_signature": "BLAS.gemv(double alpha, DenseMatrix matA, boolean transA,\n                            Vector x, double beta, DenseVector y)", "testcase": false, "constructor": false}, {"identifier": "gemv", "parameters": "(double alpha, DenseMatrix matA, boolean transA,\n                            DenseVector x, double beta, DenseVector y)", "modifiers": "public static", "return": "void", "signature": "void gemv(double alpha, DenseMatrix matA, boolean transA,\n                            DenseVector x, double beta, DenseVector y)", "full_signature": "public static void gemv(double alpha, DenseMatrix matA, boolean transA,\n                            DenseVector x, double beta, DenseVector y)", "class_method_signature": "BLAS.gemv(double alpha, DenseMatrix matA, boolean transA,\n                            DenseVector x, double beta, DenseVector y)", "testcase": false, "constructor": false}, {"identifier": "gemv", "parameters": "(double alpha, DenseMatrix matA, boolean transA,\n                            SparseVector x, double beta, DenseVector y)", "modifiers": "public static", "return": "void", "signature": "void gemv(double alpha, DenseMatrix matA, boolean transA,\n                            SparseVector x, double beta, DenseVector y)", "full_signature": "public static void gemv(double alpha, DenseMatrix matA, boolean transA,\n                            SparseVector x, double beta, DenseVector y)", "class_method_signature": "BLAS.gemv(double alpha, DenseMatrix matA, boolean transA,\n                            SparseVector x, double beta, DenseVector y)", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/alibaba/alink/common/linalg/BLAS.java"}, "focal_method": {"identifier": "gemm", "parameters": "(double alpha, DenseMatrix matA, boolean transA, DenseMatrix matB, boolean transB,\n                            double beta, DenseMatrix matC)", "modifiers": "public static", "return": "void", "body": "public static void gemm(double alpha, DenseMatrix matA, boolean transA, DenseMatrix matB, boolean transB,\n                            double beta, DenseMatrix matC) {\n        int ma = transA ? matA.n : matA.m;\n        int na = transA ? matA.m : matA.n;\n        int mb = transB ? matB.n : matB.m;\n        int nb = transB ? matB.m : matB.n;\n        Preconditions.checkArgument(na == mb && ma == matC.m && nb == matC.n, \"matrix size mismatched.\");\n\n        final int m = matC.numRows();\n        final int n = matC.numCols();\n        final int k = transA ? matA.numRows() : matA.numCols();\n        final int lda = matA.numRows();\n        final int ldb = matB.numRows();\n        final int ldc = matC.numRows();\n        final String ta = transA ? \"T\" : \"N\";\n        final String tb = transB ? \"T\" : \"N\";\n        NATIVE_BLAS.dgemm(ta, tb, m, n, k, alpha, matA.getData(), lda, matB.getData(), ldb, beta, matC.getData(), ldc);\n    }", "signature": "void gemm(double alpha, DenseMatrix matA, boolean transA, DenseMatrix matB, boolean transB,\n                            double beta, DenseMatrix matC)", "full_signature": "public static void gemm(double alpha, DenseMatrix matA, boolean transA, DenseMatrix matB, boolean transB,\n                            double beta, DenseMatrix matC)", "class_method_signature": "BLAS.gemm(double alpha, DenseMatrix matA, boolean transA, DenseMatrix matB, boolean transB,\n                            double beta, DenseMatrix matC)", "testcase": false, "constructor": false, "invocations": ["checkArgument", "numRows", "numCols", "numRows", "numCols", "numRows", "numRows", "numRows", "dgemm", "getData", "getData", "getData"]}, "repository": {"repo_id": 150938406, "url": "https://github.com/alibaba/Alink", "stars": 1923, "created": "9/30/2018 6:36:11 AM +00:00", "updates": "2020-01-27T10:24:34+00:00", "fork": "False", "license": "licensed"}}