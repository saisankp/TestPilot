{"test_class": {"identifier": "IntersectionFeatureCollectionTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = Logger.getLogger(\"org.geotools.process.feature.gs.VectoralZonalStatisticalProcessTest\");", "modifier": "private static final", "type": "Logger", "declarator": "logger = Logger.getLogger(\"org.geotools.process.feature.gs.VectoralZonalStatisticalProcessTest\")", "var_name": "logger"}, {"original_string": "FilterFactory ff = CommonFactoryFinder.getFilterFactory(null);", "modifier": "", "type": "FilterFactory", "declarator": "ff = CommonFactoryFinder.getFilterFactory(null)", "var_name": "ff"}, {"original_string": "private DataStore data;", "modifier": "private", "type": "DataStore", "declarator": "data", "var_name": "data"}, {"original_string": "private SimpleFeatureCollection zonesCollection;", "modifier": "private", "type": "SimpleFeatureCollection", "declarator": "zonesCollection", "var_name": "zonesCollection"}, {"original_string": "private SimpleFeatureCollection featuresCollection;", "modifier": "private", "type": "SimpleFeatureCollection", "declarator": "featuresCollection", "var_name": "featuresCollection"}, {"original_string": "private SimpleFeatureCollection polylineCollection;", "modifier": "private", "type": "SimpleFeatureCollection", "declarator": "polylineCollection", "var_name": "polylineCollection"}, {"original_string": "private SimpleFeatureCollection multipointCollection;", "modifier": "private", "type": "SimpleFeatureCollection", "declarator": "multipointCollection", "var_name": "multipointCollection"}, {"original_string": "private IntersectionFeatureCollection process;", "modifier": "private", "type": "IntersectionFeatureCollection", "declarator": "process", "var_name": "process"}, {"original_string": "private static final double WORLDAREA = 510072000.0d;", "modifier": "private static final", "type": "double", "declarator": "WORLDAREA = 510072000.0d", "var_name": "WORLDAREA"}, {"original_string": "private static final double COLORADOAREA = 269837.0d;", "modifier": "private static final", "type": "double", "declarator": "COLORADOAREA = 269837.0d", "var_name": "COLORADOAREA"}], "file": "modules/unsupported/process-feature/src/test/java/org/geotools/process/vector/IntersectionFeatureCollectionTest.java"}, "test_case": {"identifier": "testGetIntersectionAreaRate", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGetIntersectionAreaRate()  {\n\n        logger.info(\"Running testGetIntersectionAreaRate ...\");\n        CoordinateReferenceSystem sourceCRS = org.geotools.referencing.crs.DefaultGeographicCRS.WGS84;\n\n        // creates the world state polygon\n        Polygon worldPolygon = createRectangularPolygonByCoords(-180,180,-90, 90, sourceCRS);\n\n        // creates the Colorado state polygon\n        Polygon coloradoPolygon = createRectangularPolygonByCoords(-102,-109,37, 41, sourceCRS);\n\n        // calculates the estimated value\n        double calculatedRate = IntersectionFeatureCollection.getIntersectionArea(worldPolygon, sourceCRS,coloradoPolygon , sourceCRS, true);\n\n        // calculates the expected value\n        double expectedRate = COLORADOAREA / WORLDAREA;\n        \n        // 0.01% error off the expected value\n        assertEquals(0, (expectedRate - calculatedRate) / expectedRate, 0.01);\n    }", "signature": "void testGetIntersectionAreaRate()", "full_signature": "@Test public void testGetIntersectionAreaRate()", "class_method_signature": "IntersectionFeatureCollectionTest.testGetIntersectionAreaRate()", "testcase": true, "constructor": false, "invocations": ["info", "createRectangularPolygonByCoords", "createRectangularPolygonByCoords", "getIntersectionArea", "assertEquals"]}, "focal_class": {"identifier": "IntersectionFeatureCollection", "superclass": "", "interfaces": "implements VectorProcess", "fields": [{"original_string": "private static final Logger logger = Logger\n            .getLogger(\"org.geotools.process.feature.gs.IntersectionFeatureCollection\");", "modifier": "private static final", "type": "Logger", "declarator": "logger = Logger\n            .getLogger(\"org.geotools.process.feature.gs.IntersectionFeatureCollection\")", "var_name": "logger"}, {"original_string": "static final String ECKERT_IV_WKT = \"PROJCS[\\\"World_Eckert_IV\\\",GEOGCS[\\\"GCS_WGS_1984\\\",DATUM[\\\"D_WGS_1984\\\",SPHEROID[\\\"WGS_1984\\\",6378137.0,298.257223563]],PRIMEM[\\\"Greenwich\\\",0.0],UNIT[\\\"Degree\\\",0.0174532925199433]],PROJECTION[\\\"Eckert_IV\\\"],PARAMETER[\\\"Central_Meridian\\\",0.0],UNIT[\\\"Meter\\\",1.0]]\";", "modifier": "static final", "type": "String", "declarator": "ECKERT_IV_WKT = \"PROJCS[\\\"World_Eckert_IV\\\",GEOGCS[\\\"GCS_WGS_1984\\\",DATUM[\\\"D_WGS_1984\\\",SPHEROID[\\\"WGS_1984\\\",6378137.0,298.257223563]],PRIMEM[\\\"Greenwich\\\",0.0],UNIT[\\\"Degree\\\",0.0174532925199433]],PROJECTION[\\\"Eckert_IV\\\"],PARAMETER[\\\"Central_Meridian\\\",0.0],UNIT[\\\"Meter\\\",1.0]]\"", "var_name": "ECKERT_IV_WKT"}], "methods": [{"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "modifiers": "@DescribeResult(description = \"Output feature collection\") public", "return": "SimpleFeatureCollection", "signature": "SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "full_signature": "@DescribeResult(description = \"Output feature collection\") public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "class_method_signature": "IntersectionFeatureCollection.execute(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "testcase": false, "constructor": false}, {"identifier": "isGeometryTypeIn", "parameters": "(Class test, Class... targets)", "modifiers": "static", "return": "boolean", "signature": "boolean isGeometryTypeIn(Class test, Class... targets)", "full_signature": "static boolean isGeometryTypeIn(Class test, Class... targets)", "class_method_signature": "IntersectionFeatureCollection.isGeometryTypeIn(Class test, Class... targets)", "testcase": false, "constructor": false}, {"identifier": "densify", "parameters": "(Geometry geom, CoordinateReferenceSystem crs, double maxAreaError)", "modifiers": "static", "return": "Geometry", "signature": "Geometry densify(Geometry geom, CoordinateReferenceSystem crs, double maxAreaError)", "full_signature": "static Geometry densify(Geometry geom, CoordinateReferenceSystem crs, double maxAreaError)", "class_method_signature": "IntersectionFeatureCollection.densify(Geometry geom, CoordinateReferenceSystem crs, double maxAreaError)", "testcase": false, "constructor": false}, {"identifier": "getIntersectionArea", "parameters": "(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "modifiers": "static", "return": "double", "signature": "double getIntersectionArea(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "full_signature": "static double getIntersectionArea(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "class_method_signature": "IntersectionFeatureCollection.getIntersectionArea(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "testcase": false, "constructor": false}, {"identifier": "reprojectAndDensify", "parameters": "(Geometry first, CoordinateReferenceSystem sourceCRS,\n            CoordinateReferenceSystem targetCRS)", "modifiers": "static", "return": "Geometry", "signature": "Geometry reprojectAndDensify(Geometry first, CoordinateReferenceSystem sourceCRS,\n            CoordinateReferenceSystem targetCRS)", "full_signature": "static Geometry reprojectAndDensify(Geometry first, CoordinateReferenceSystem sourceCRS,\n            CoordinateReferenceSystem targetCRS)", "class_method_signature": "IntersectionFeatureCollection.reprojectAndDensify(Geometry first, CoordinateReferenceSystem sourceCRS,\n            CoordinateReferenceSystem targetCRS)", "testcase": false, "constructor": false}, {"identifier": "getIntersectionType", "parameters": "(SimpleFeatureCollection first,\n            SimpleFeatureCollection second)", "modifiers": "static", "return": "AttributeDescriptor", "signature": "AttributeDescriptor getIntersectionType(SimpleFeatureCollection first,\n            SimpleFeatureCollection second)", "full_signature": "static AttributeDescriptor getIntersectionType(SimpleFeatureCollection first,\n            SimpleFeatureCollection second)", "class_method_signature": "IntersectionFeatureCollection.getIntersectionType(SimpleFeatureCollection first,\n            SimpleFeatureCollection second)", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/IntersectionFeatureCollection.java"}, "focal_method": {"identifier": "getIntersectionArea", "parameters": "(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "modifiers": "static", "return": "double", "body": "static double getIntersectionArea(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst) {\n        // basic checks\n        if (firstCRS == null || secondCRS == null)\n            throw new IllegalArgumentException(\"CRS cannot be set to null\");\n        if (!Polygon.class.isAssignableFrom(first.getClass())\n                && !MultiPolygon.class.isAssignableFrom(first.getClass()))\n            throw new IllegalArgumentException(\"first geometry must be poligonal\");\n        if (!Polygon.class.isAssignableFrom(second.getClass())\n                && !MultiPolygon.class.isAssignableFrom(second.getClass()))\n            throw new IllegalArgumentException(\"second geometry must be poligonal\");\n        try {\n            Geometry firstTargetGeometry = reprojectAndDensify(first, firstCRS, null);\n            Geometry secondTargetGeometry = reprojectAndDensify(second, firstCRS, null);\n            double numeratorArea = (double) (firstTargetGeometry.intersection(secondTargetGeometry))\n                    .getArea();\n            if (divideFirst) {\n                double denom = firstTargetGeometry.getArea();\n                if (denom!=0) return numeratorArea / denom;\n                return 0;\n            }\n            double denom = secondTargetGeometry.getArea();\n            if (denom!=0) return numeratorArea / denom;\n            return 0;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return -1;\n        }\n    }", "signature": "double getIntersectionArea(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "full_signature": "static double getIntersectionArea(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "class_method_signature": "IntersectionFeatureCollection.getIntersectionArea(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "testcase": false, "constructor": false, "invocations": ["isAssignableFrom", "getClass", "isAssignableFrom", "getClass", "isAssignableFrom", "getClass", "isAssignableFrom", "getClass", "reprojectAndDensify", "reprojectAndDensify", "getArea", "intersection", "getArea", "getArea", "printStackTrace"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}