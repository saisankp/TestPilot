{"test_class": {"identifier": "DnsPacketProxyTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private MockEventLoop mockEventLoop;", "modifier": "private", "type": "MockEventLoop", "declarator": "mockEventLoop", "var_name": "mockEventLoop"}, {"original_string": "private DnsPacketProxy dnsPacketProxy;", "modifier": "private", "type": "DnsPacketProxy", "declarator": "dnsPacketProxy", "var_name": "dnsPacketProxy"}, {"original_string": "private RuleDatabase ruleDatabase;", "modifier": "private", "type": "RuleDatabase", "declarator": "ruleDatabase", "var_name": "ruleDatabase"}], "file": "app/src/test/java/org/jak_linux/dns66/vpn/DnsPacketProxyTest.java"}, "test_case": {"identifier": "testBlockedInet6DnsQuery", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testBlockedInet6DnsQuery() throws Exception {\n        Message message = Message.newQuery(new ARecord(new Name(\"blocked.example.com.\"),\n                0x01,\n                3600,\n                Inet4Address.getByAddress(new byte[]{0, 0, 0, 0})\n        ));\n\n        UdpPacket.Builder payLoadBuilder = new UdpPacket.Builder()\n                .srcPort(UdpPort.DOMAIN)\n                .dstPort(UdpPort.DOMAIN)\n                .srcAddr((Inet6Address) Inet6Address.getByName(\"::0\"))\n                .dstAddr((Inet6Address) Inet6Address.getByName(\"::1\"))\n                .correctChecksumAtBuild(true)\n                .correctLengthAtBuild(true)\n                .payloadBuilder(\n                        new UnknownPacket.Builder()\n                                .rawData(message.toWire())\n                );\n\n        IpPacket ipOutPacket = new IpV6Packet.Builder()\n                .version(IpVersion.IPV6)\n                .trafficClass(IpV6SimpleTrafficClass.newInstance((byte) 0))\n                .flowLabel(IpV6SimpleFlowLabel.newInstance(0))\n                .nextHeader(IpNumber.UDP)\n                .srcAddr((Inet6Address) Inet6Address.getByName(\"::0\"))\n                .dstAddr((Inet6Address) Inet6Address.getByName(\"::1\"))\n                .correctLengthAtBuild(true)\n                .payloadBuilder(payLoadBuilder)\n                .build();\n\n        dnsPacketProxy.handleDnsRequest(ipOutPacket.getRawData());\n\n        assertNotNull(mockEventLoop.lastResponse);\n        assertNull(mockEventLoop.lastOutgoing);\n        assertTrue(mockEventLoop.lastResponse instanceof IpPacket);\n        assertTrue(mockEventLoop.lastResponse.getPayload() instanceof UdpPacket);\n\n        Message responseMsg = new Message(mockEventLoop.lastResponse.getPayload().getPayload().getRawData());\n        assertEquals(NOERROR, responseMsg.getHeader().getRcode());\n        assertArrayEquals(new Record[] {}, responseMsg.getSectionArray(Section.ANSWER));\n        assertNotEquals(0, responseMsg.getSectionArray(Section.AUTHORITY).length);\n        assertTrue(responseMsg.getSectionArray(Section.AUTHORITY)[0] instanceof SOARecord);\n        assertTrue(responseMsg.getSectionArray(Section.AUTHORITY)[0].getTTL() > 0);\n    }", "signature": "void testBlockedInet6DnsQuery()", "full_signature": "@Test public void testBlockedInet6DnsQuery()", "class_method_signature": "DnsPacketProxyTest.testBlockedInet6DnsQuery()", "testcase": true, "constructor": false, "invocations": ["newQuery", "getByAddress", "payloadBuilder", "correctLengthAtBuild", "correctChecksumAtBuild", "dstAddr", "srcAddr", "dstPort", "srcPort", "getByName", "getByName", "rawData", "toWire", "build", "payloadBuilder", "correctLengthAtBuild", "dstAddr", "srcAddr", "nextHeader", "flowLabel", "trafficClass", "version", "newInstance", "newInstance", "getByName", "getByName", "handleDnsRequest", "getRawData", "assertNotNull", "assertNull", "assertTrue", "assertTrue", "getPayload", "getRawData", "getPayload", "getPayload", "assertEquals", "getRcode", "getHeader", "assertArrayEquals", "getSectionArray", "assertNotEquals", "getSectionArray", "assertTrue", "getSectionArray", "assertTrue", "getTTL", "getSectionArray"]}, "focal_class": {"identifier": "DnsPacketProxy", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String TAG = \"DnsPacketProxy\";", "modifier": "private static final", "type": "String", "declarator": "TAG = \"DnsPacketProxy\"", "var_name": "TAG"}, {"original_string": "private static final int NEGATIVE_CACHE_TTL_SECONDS = 5;", "modifier": "private static final", "type": "int", "declarator": "NEGATIVE_CACHE_TTL_SECONDS = 5", "var_name": "NEGATIVE_CACHE_TTL_SECONDS"}, {"original_string": "private static final SOARecord NEGATIVE_CACHE_SOA_RECORD;", "modifier": "private static final", "type": "SOARecord", "declarator": "NEGATIVE_CACHE_SOA_RECORD", "var_name": "NEGATIVE_CACHE_SOA_RECORD"}, {"original_string": "final RuleDatabase ruleDatabase;", "modifier": "final", "type": "RuleDatabase", "declarator": "ruleDatabase", "var_name": "ruleDatabase"}, {"original_string": "private final EventLoop eventLoop;", "modifier": "private final", "type": "EventLoop", "declarator": "eventLoop", "var_name": "eventLoop"}, {"original_string": "ArrayList<InetAddress> upstreamDnsServers = new ArrayList<>();", "modifier": "", "type": "ArrayList<InetAddress>", "declarator": "upstreamDnsServers = new ArrayList<>()", "var_name": "upstreamDnsServers"}], "methods": [{"identifier": "DnsPacketProxy", "parameters": "(EventLoop eventLoop, RuleDatabase database)", "modifiers": "public", "return": "", "signature": " DnsPacketProxy(EventLoop eventLoop, RuleDatabase database)", "full_signature": "public  DnsPacketProxy(EventLoop eventLoop, RuleDatabase database)", "class_method_signature": "DnsPacketProxy.DnsPacketProxy(EventLoop eventLoop, RuleDatabase database)", "testcase": false, "constructor": true}, {"identifier": "DnsPacketProxy", "parameters": "(EventLoop eventLoop)", "modifiers": "public", "return": "", "signature": " DnsPacketProxy(EventLoop eventLoop)", "full_signature": "public  DnsPacketProxy(EventLoop eventLoop)", "class_method_signature": "DnsPacketProxy.DnsPacketProxy(EventLoop eventLoop)", "testcase": false, "constructor": true}, {"identifier": "initialize", "parameters": "(Context context, ArrayList<InetAddress> upstreamDnsServers)", "modifiers": "", "return": "void", "signature": "void initialize(Context context, ArrayList<InetAddress> upstreamDnsServers)", "full_signature": " void initialize(Context context, ArrayList<InetAddress> upstreamDnsServers)", "class_method_signature": "DnsPacketProxy.initialize(Context context, ArrayList<InetAddress> upstreamDnsServers)", "testcase": false, "constructor": false}, {"identifier": "handleDnsResponse", "parameters": "(IpPacket requestPacket, byte[] responsePayload)", "modifiers": "", "return": "void", "signature": "void handleDnsResponse(IpPacket requestPacket, byte[] responsePayload)", "full_signature": " void handleDnsResponse(IpPacket requestPacket, byte[] responsePayload)", "class_method_signature": "DnsPacketProxy.handleDnsResponse(IpPacket requestPacket, byte[] responsePayload)", "testcase": false, "constructor": false}, {"identifier": "handleDnsRequest", "parameters": "(byte[] packetData)", "modifiers": "", "return": "void", "signature": "void handleDnsRequest(byte[] packetData)", "full_signature": " void handleDnsRequest(byte[] packetData)", "class_method_signature": "DnsPacketProxy.handleDnsRequest(byte[] packetData)", "testcase": false, "constructor": false}, {"identifier": "translateDestinationAdress", "parameters": "(IpPacket parsedPacket)", "modifiers": "private", "return": "InetAddress", "signature": "InetAddress translateDestinationAdress(IpPacket parsedPacket)", "full_signature": "private InetAddress translateDestinationAdress(IpPacket parsedPacket)", "class_method_signature": "DnsPacketProxy.translateDestinationAdress(IpPacket parsedPacket)", "testcase": false, "constructor": false}], "file": "app/src/main/java/org/jak_linux/dns66/vpn/DnsPacketProxy.java"}, "focal_method": {"identifier": "handleDnsRequest", "parameters": "(byte[] packetData)", "modifiers": "", "return": "void", "body": "void handleDnsRequest(byte[] packetData) throws AdVpnThread.VpnNetworkException {\n\n        IpPacket parsedPacket = null;\n        try {\n            parsedPacket = (IpPacket) IpSelector.newPacket(packetData, 0, packetData.length);\n        } catch (Exception e) {\n            Log.i(TAG, \"handleDnsRequest: Discarding invalid IP packet\", e);\n            return;\n        }\n\n        UdpPacket parsedUdp;\n        Packet udpPayload;\n\n        try {\n            parsedUdp = (UdpPacket) parsedPacket.getPayload();\n            udpPayload = parsedUdp.getPayload();\n        } catch (Exception e) {\n            try {\n                Log.i(TAG, \"handleDnsRequest: Discarding unknown packet type \" + parsedPacket.getHeader(), e);\n            } catch (Exception e1) {\n                Log.i(TAG, \"handleDnsRequest: Discarding unknown packet type, could not log packet info\", e1);\n            }\n            return;\n        }\n\n        InetAddress destAddr = translateDestinationAdress(parsedPacket);\n        if (destAddr == null)\n            return;\n\n        if (udpPayload == null) {\n            try {\n                Log.i(TAG, \"handleDnsRequest: Sending UDP packet without payload: \" + parsedUdp);\n            } catch (Exception e1) {\n                Log.i(TAG, \"handleDnsRequest: Sending UDP packet without payload\");\n            }\n\n            // Let's be nice to Firefox. Firefox uses an empty UDP packet to\n            // the gateway to reduce the RTT. For further details, please see\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=888268\n            try {\n                DatagramPacket outPacket = new DatagramPacket(new byte[0], 0, 0 /* length */, destAddr, parsedUdp.getHeader().getDstPort().valueAsInt());\n                eventLoop.forwardPacket(outPacket, null);\n            } catch (Exception e) {\n                Log.i(TAG, \"handleDnsRequest: Could not send empty UDP packet\", e);\n            }\n            return;\n        }\n\n        byte[] dnsRawData = udpPayload.getRawData();\n        Message dnsMsg;\n        try {\n            dnsMsg = new Message(dnsRawData);\n        } catch (IOException e) {\n            Log.i(TAG, \"handleDnsRequest: Discarding non-DNS or invalid packet\", e);\n            return;\n        }\n        if (dnsMsg.getQuestion() == null) {\n            Log.i(TAG, \"handleDnsRequest: Discarding DNS packet with no query \" + dnsMsg);\n            return;\n        }\n        String dnsQueryName = dnsMsg.getQuestion().getName().toString(true);\n        if (!ruleDatabase.isBlocked(dnsQueryName.toLowerCase(Locale.ENGLISH))) {\n            Log.i(TAG, \"handleDnsRequest: DNS Name \" + dnsQueryName + \" Allowed, sending to \" + destAddr);\n            DatagramPacket outPacket = new DatagramPacket(dnsRawData, 0, dnsRawData.length, destAddr, parsedUdp.getHeader().getDstPort().valueAsInt());\n            eventLoop.forwardPacket(outPacket, parsedPacket);\n        } else {\n            Log.i(TAG, \"handleDnsRequest: DNS Name \" + dnsQueryName + \" Blocked!\");\n            dnsMsg.getHeader().setFlag(Flags.QR);\n            dnsMsg.getHeader().setRcode(Rcode.NOERROR);\n            dnsMsg.addRecord(NEGATIVE_CACHE_SOA_RECORD, Section.AUTHORITY);\n            handleDnsResponse(parsedPacket, dnsMsg.toWire());\n        }\n    }", "signature": "void handleDnsRequest(byte[] packetData)", "full_signature": " void handleDnsRequest(byte[] packetData)", "class_method_signature": "DnsPacketProxy.handleDnsRequest(byte[] packetData)", "testcase": false, "constructor": false, "invocations": ["newPacket", "i", "getPayload", "getPayload", "i", "getHeader", "i", "translateDestinationAdress", "i", "i", "valueAsInt", "getDstPort", "getHeader", "forwardPacket", "i", "getRawData", "i", "getQuestion", "i", "toString", "getName", "getQuestion", "isBlocked", "toLowerCase", "i", "valueAsInt", "getDstPort", "getHeader", "forwardPacket", "i", "setFlag", "getHeader", "setRcode", "getHeader", "addRecord", "handleDnsResponse", "toWire"]}, "repository": {"repo_id": 70996010, "url": "https://github.com/julian-klode/dns66", "stars": 1372, "created": "10/15/2016 3:27:17 PM +00:00", "updates": "2020-01-26T10:51:30+00:00", "fork": "False", "license": "licensed"}}