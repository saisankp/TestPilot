{"test_class": {"identifier": "ThreadPoolTest", "superclass": "", "interfaces": "", "fields": [], "file": "step-plans/step-plans-core/src/test/java/step/threadpool/ThreadPoolTest.java"}, "test_case": {"identifier": "testAutoMode", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testAutoMode() {\n\t\tExecutionContext context = newExecutionContext();\n\t\tReportNode rootReportNode = context.getReport();\n\t\tcontext.getVariablesManager().putVariable(rootReportNode, \"execution_threads_auto\", 2);\n\t\t\n\t\tThreadPool threadPool = new ThreadPool(context);\n\t\t\n\t\tList<String> itemList = new ArrayList<>();\n\t\tfor(int i=0; i<100; i++) {\n\t\t\titemList.add(\"Item\"+i);\n\t\t}\n\t\t\n\t\tList<String> itemList2 = new ArrayList<>();\n\t\tfor(int i=0; i<100; i++) {\n\t\t\titemList2.add(Integer.toString(i));\n\t\t}\n\t\t\n\t\tList<String> processedItems = new CopyOnWriteArrayList<>();\n\t\t\n\t\tCountDownLatch countDownLatch = new CountDownLatch(2);\n\t\t\n\t\tConcurrentHashMap<String,String> threadIdLevel1 = new ConcurrentHashMap<>();\n\t\tConcurrentHashMap<String,String> threadIdLevel2 = new ConcurrentHashMap<>();\n\t\tthreadPool.consumeWork(itemList.iterator(), new WorkerItemConsumerFactory<String>() {\n\t\t\t@Override\n\t\t\tpublic Consumer<String> createWorkItemConsumer(WorkerController<String> control) {\n\t\t\t\treturn item1 -> {\n\t\t\t\t\tcontext.setCurrentReportNode(rootReportNode);\n\t\t\t\t\tthreadIdLevel1.put(Thread.currentThread().getName(),\"\");\n\t\t\t\t\twaitForOtherWorkersToStart(countDownLatch);\n\t\t\t\t\tthreadPool.consumeWork(itemList2.iterator(), new WorkerItemConsumerFactory<String>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Consumer<String> createWorkItemConsumer(WorkerController<String> control) {\n\t\t\t\t\t\t\treturn item2 -> {\n\t\t\t\t\t\t\t\tthreadIdLevel2.put(Thread.currentThread().getName(),\"\");\n\t\t\t\t\t\t\t\tprocessedItems.add(item1+item2);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 4);\n\t\t\t\t};\n\t\t\t}\n\t\t}, 4);\n\t\t\n\t\tAssert.assertEquals(2, threadIdLevel1.size());\n\t\tAssert.assertEquals(2, threadIdLevel2.size());\n\t\tfor (String item : itemList) {\n\t\t\tfor (String item2 : itemList2) {\n\t\t\t\tString concatenatedItem = item+item2;\n\t\t\t\tif(!processedItems.contains(concatenatedItem)) {\n\t\t\t\t\tfail(\"The item \"+concatenatedItem+\" hasn't been processed\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}", "signature": "void testAutoMode()", "full_signature": "@Test public void testAutoMode()", "class_method_signature": "ThreadPoolTest.testAutoMode()", "testcase": true, "constructor": false, "invocations": ["newExecutionContext", "getReport", "putVariable", "getVariablesManager", "add", "add", "toString", "consumeWork", "iterator", "setCurrentReportNode", "put", "getName", "currentThread", "waitForOtherWorkersToStart", "consumeWork", "iterator", "put", "getName", "currentThread", "add", "assertEquals", "size", "assertEquals", "size", "contains", "fail"]}, "focal_class": {"identifier": "ThreadPool", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String EXECUTION_THREADS_AUTO = \"execution_threads_auto\";", "modifier": "private static final", "type": "String", "declarator": "EXECUTION_THREADS_AUTO = \"execution_threads_auto\"", "var_name": "EXECUTION_THREADS_AUTO"}, {"original_string": "private static final Logger logger = LoggerFactory.getLogger(ThreadPool.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(ThreadPool.class)", "var_name": "logger"}, {"original_string": "private final ExecutionContext executionContext;", "modifier": "private final", "type": "ExecutionContext", "declarator": "executionContext", "var_name": "executionContext"}, {"original_string": "private final ExecutorService executorService = Executors.newCachedThreadPool();", "modifier": "private final", "type": "ExecutorService", "declarator": "executorService = Executors.newCachedThreadPool()", "var_name": "executorService"}, {"original_string": "protected ThreadLocal<Stack<BatchContext>> batchContextStack = ThreadLocal.withInitial(()->new Stack<BatchContext>());", "modifier": "protected", "type": "ThreadLocal<Stack<BatchContext>>", "declarator": "batchContextStack = ThreadLocal.withInitial(()->new Stack<BatchContext>())", "var_name": "batchContextStack"}], "methods": [{"identifier": "ThreadPool", "parameters": "(ExecutionContext context)", "modifiers": "public", "return": "", "signature": " ThreadPool(ExecutionContext context)", "full_signature": "public  ThreadPool(ExecutionContext context)", "class_method_signature": "ThreadPool.ThreadPool(ExecutionContext context)", "testcase": false, "constructor": true}, {"identifier": "consumeWork", "parameters": "(Iterator<WORK_ITEM> workItemIterator,\n\t\t\tWorkerItemConsumerFactory<WORK_ITEM> workItemConsumerFactory, int numberOfThreads)", "modifiers": "public", "return": "void", "signature": "void consumeWork(Iterator<WORK_ITEM> workItemIterator,\n\t\t\tWorkerItemConsumerFactory<WORK_ITEM> workItemConsumerFactory, int numberOfThreads)", "full_signature": "public void consumeWork(Iterator<WORK_ITEM> workItemIterator,\n\t\t\tWorkerItemConsumerFactory<WORK_ITEM> workItemConsumerFactory, int numberOfThreads)", "class_method_signature": "ThreadPool.consumeWork(Iterator<WORK_ITEM> workItemIterator,\n\t\t\tWorkerItemConsumerFactory<WORK_ITEM> workItemConsumerFactory, int numberOfThreads)", "testcase": false, "constructor": false}, {"identifier": "isReentrantThread", "parameters": "()", "modifiers": "protected", "return": "boolean", "signature": "boolean isReentrantThread()", "full_signature": "protected boolean isReentrantThread()", "class_method_signature": "ThreadPool.isReentrantThread()", "testcase": false, "constructor": false}, {"identifier": "getAutoNumberOfThreads", "parameters": "()", "modifiers": "protected", "return": "Integer", "signature": "Integer getAutoNumberOfThreads()", "full_signature": "protected Integer getAutoNumberOfThreads()", "class_method_signature": "ThreadPool.getAutoNumberOfThreads()", "testcase": false, "constructor": false}, {"identifier": "createWorkerAndRun", "parameters": "(BatchContext batchContext, Consumer<WORK_ITEM> workItemConsumer, Iterator<WORK_ITEM> workItemIterator, int workerId)", "modifiers": "private", "return": "void", "signature": "void createWorkerAndRun(BatchContext batchContext, Consumer<WORK_ITEM> workItemConsumer, Iterator<WORK_ITEM> workItemIterator, int workerId)", "full_signature": "private void createWorkerAndRun(BatchContext batchContext, Consumer<WORK_ITEM> workItemConsumer, Iterator<WORK_ITEM> workItemIterator, int workerId)", "class_method_signature": "ThreadPool.createWorkerAndRun(BatchContext batchContext, Consumer<WORK_ITEM> workItemConsumer, Iterator<WORK_ITEM> workItemIterator, int workerId)", "testcase": false, "constructor": false}, {"identifier": "pushBatchContextToStack", "parameters": "(final BatchContext batchContext)", "modifiers": "protected", "return": "Stack<BatchContext>", "signature": "Stack<BatchContext> pushBatchContextToStack(final BatchContext batchContext)", "full_signature": "protected Stack<BatchContext> pushBatchContextToStack(final BatchContext batchContext)", "class_method_signature": "ThreadPool.pushBatchContextToStack(final BatchContext batchContext)", "testcase": false, "constructor": false}], "file": "step-plans/step-plans-core/src/main/java/step/threadpool/ThreadPool.java"}, "focal_method": {"identifier": "consumeWork", "parameters": "(Iterator<WORK_ITEM> workItemIterator,\n\t\t\tWorkerItemConsumerFactory<WORK_ITEM> workItemConsumerFactory, int numberOfThreads)", "modifiers": "public", "return": "void", "body": "public <WORK_ITEM> void consumeWork(Iterator<WORK_ITEM> workItemIterator,\n\t\t\tWorkerItemConsumerFactory<WORK_ITEM> workItemConsumerFactory, int numberOfThreads) {\n\t\t// Wrapping the iterator to avoid concurrency issues as iterators aren't ThreadSafe \n\t\tIterator<WORK_ITEM> threadSafeIterator = new Iterator<WORK_ITEM>() {\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tthrow new RuntimeException(\"This method shouldn't be called\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic WORK_ITEM next() {\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\treturn workItemIterator.next();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tInteger autoNumberOfThreads = getAutoNumberOfThreads();\n\t\tif (autoNumberOfThreads != null) {\n\t\t\tif(!isReentrantThread()) {\n\t\t\t\t// Forcing the number of threads to the required autoNumberOfThreads for the \n\t\t\t\t// first Artefact using the ThreadPool (Level = 1)\n\t\t\t\tnumberOfThreads = autoNumberOfThreads;\n\t\t\t} else {\n\t\t\t\t// Avoid parallelism for the artefacts that are children of an artefact \n\t\t\t\t// already using the ThreadPool (Level > 1)\n\t\t\t\tnumberOfThreads = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal BatchContext batchContext = new BatchContext(executionContext, numberOfThreads>1);\n\t\t\n\t\tWorkerController<WORK_ITEM> workerController = new WorkerController<>(batchContext);\n\t\tConsumer<WORK_ITEM> workItemConsumer = workItemConsumerFactory.createWorkItemConsumer(workerController);\n\t\t\n\t\tif(numberOfThreads == 1) {\n\t\t\t// No parallelism, run the worker in the current thread\n\t\t\tcreateWorkerAndRun(batchContext, workItemConsumer, threadSafeIterator, 0);\n\t\t} else {\n\t\t\tReportNode currentReportNode = executionContext.getCurrentReportNode();\n\t\t\tList<Future<?>> futures = new ArrayList<>();\n\t\t\tlong parentThreadId = Thread.currentThread().getId();\n\t\t\t// Create one worker for each \"thread\"\n\t\t\tfor (int i = 0; i < numberOfThreads; i++) {\n\t\t\t\tint workerId = i;\n\t\t\t\tfutures.add(executorService.submit(() -> {\n\t\t\t\t\texecutionContext.associateThread(parentThreadId, currentReportNode);\n\t\t\t\t\tcreateWorkerAndRun(batchContext, workItemConsumer, threadSafeIterator, workerId);\n\t\t\t\t}));\n\t\t\t}\n\t\t\t\n\t\t\t// Wait for the workers to complete\n\t\t\tfor (Future<?> future : futures) {\n\t\t\t\ttry {\n\t\t\t\t\tfuture.get();\n\t\t\t\t} catch (InterruptedException | ExecutionException e) {\n\t\t\t\t\tlogger.error(\"Error while waiting for worker execution to terminate. Execution ID: \"+executionContext.getExecutionId(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "signature": "void consumeWork(Iterator<WORK_ITEM> workItemIterator,\n\t\t\tWorkerItemConsumerFactory<WORK_ITEM> workItemConsumerFactory, int numberOfThreads)", "full_signature": "public void consumeWork(Iterator<WORK_ITEM> workItemIterator,\n\t\t\tWorkerItemConsumerFactory<WORK_ITEM> workItemConsumerFactory, int numberOfThreads)", "class_method_signature": "ThreadPool.consumeWork(Iterator<WORK_ITEM> workItemIterator,\n\t\t\tWorkerItemConsumerFactory<WORK_ITEM> workItemConsumerFactory, int numberOfThreads)", "testcase": false, "constructor": false, "invocations": ["next", "getAutoNumberOfThreads", "isReentrantThread", "createWorkItemConsumer", "createWorkerAndRun", "getCurrentReportNode", "getId", "currentThread", "add", "submit", "associateThread", "createWorkerAndRun", "get", "error", "getExecutionId"]}, "repository": {"repo_id": 62342369, "url": "https://github.com/exense/step", "stars": 12, "created": "6/30/2016 9:08:29 PM +00:00", "updates": "2020-01-24T17:13:24+00:00", "fork": "False", "license": "licensed"}}