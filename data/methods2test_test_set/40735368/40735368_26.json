{"test_class": {"identifier": "ShapefileDataStoreFactoryTest", "superclass": "extends TestCaseSupport", "interfaces": "", "fields": [{"original_string": "private ShapefileDataStore store = null;", "modifier": "private", "type": "ShapefileDataStore", "declarator": "store = null", "var_name": "store"}, {"original_string": "private ShapefileDataStoreFactory factory = new ShapefileDataStoreFactory();", "modifier": "private", "type": "ShapefileDataStoreFactory", "declarator": "factory = new ShapefileDataStoreFactory()", "var_name": "factory"}], "file": "modules/plugin/shapefile/src/test/java/org/geotools/data/shapefile/ShapefileDataStoreFactoryTest.java"}, "test_case": {"identifier": "testFSTypeParameter", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testFSTypeParameter() throws Exception {\n        URL url = TestData.url(STATE_POP);\n        \n        KVP params = new KVP( URLP.key,url );\n        \n        assertTrue( \"Sorting is optional\", factory.canProcess(params) );\n        \n        params.put( FSTYPE.key, \"shape-ng\" );\n        assertTrue( \"Shape NG supported\", factory.canProcess(params) );\n        \n        params.put(FSTYPE.key, \"shape\" );\n        assertTrue( \"Plain shape supported\", factory.canProcess(params) );\n        \n        params.put(FSTYPE.key, \"index\" );\n        assertTrue( \"Plain index supported\", factory.canProcess(params) );\n        \n        params.put( FSTYPE.key, \"smurf\" );\n        assertFalse( \"Feeling blue; don't try a smruf\", factory.canProcess(params) );\n    }", "signature": "void testFSTypeParameter()", "full_signature": "@Test public void testFSTypeParameter()", "class_method_signature": "ShapefileDataStoreFactoryTest.testFSTypeParameter()", "testcase": true, "constructor": false, "invocations": ["url", "assertTrue", "canProcess", "put", "assertTrue", "canProcess", "put", "assertTrue", "canProcess", "put", "assertTrue", "canProcess", "put", "assertFalse", "canProcess"]}, "focal_class": {"identifier": "ShapefileDataStoreFactory", "superclass": "", "interfaces": "implements FileDataStoreFactorySpi", "fields": [{"original_string": "static final Logger LOGGER = Logging.getLogger(\"org.geotools.data.shapefile\");", "modifier": "static final", "type": "Logger", "declarator": "LOGGER = Logging.getLogger(\"org.geotools.data.shapefile\")", "var_name": "LOGGER"}, {"original_string": "public static final Param URLP = new Param(\"url\", URL.class, \"url to a .shp file\", true, null,\n            new KVP(Param.EXT, \"shp\"));", "modifier": "public static final", "type": "Param", "declarator": "URLP = new Param(\"url\", URL.class, \"url to a .shp file\", true, null,\n            new KVP(Param.EXT, \"shp\"))", "var_name": "URLP"}, {"original_string": "public static final Param NAMESPACEP = new Param(\"namespace\", URI.class,\n            \"uri to a the namespace\", false, null, // not required\n            new KVP(Param.LEVEL, \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "NAMESPACEP = new Param(\"namespace\", URI.class,\n            \"uri to a the namespace\", false, null, // not required\n            new KVP(Param.LEVEL, \"advanced\"))", "var_name": "NAMESPACEP"}, {"original_string": "public static final Param MEMORY_MAPPED = new Param(\"memory mapped buffer\", Boolean.class,\n            \"enable/disable the use of memory-mapped io\", false, false, new KVP(Param.LEVEL,\n                    \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "MEMORY_MAPPED = new Param(\"memory mapped buffer\", Boolean.class,\n            \"enable/disable the use of memory-mapped io\", false, false, new KVP(Param.LEVEL,\n                    \"advanced\"))", "var_name": "MEMORY_MAPPED"}, {"original_string": "public static final Param CACHE_MEMORY_MAPS = new Param(\"cache and reuse memory maps\",\n            Boolean.class, \"only memory map a file one, then cache and reuse the map\", false, true,\n            new KVP(Param.LEVEL, \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "CACHE_MEMORY_MAPS = new Param(\"cache and reuse memory maps\",\n            Boolean.class, \"only memory map a file one, then cache and reuse the map\", false, true,\n            new KVP(Param.LEVEL, \"advanced\"))", "var_name": "CACHE_MEMORY_MAPS"}, {"original_string": "public static final Param FILE_TYPE = new Param(\"filetype\", String.class,\n            \"Discriminator for directory stores\", false, \"shapefile\", new KVP(Param.LEVEL,\n                    \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "FILE_TYPE = new Param(\"filetype\", String.class,\n            \"Discriminator for directory stores\", false, \"shapefile\", new KVP(Param.LEVEL,\n                    \"advanced\"))", "var_name": "FILE_TYPE"}, {"original_string": "public static final Param CREATE_SPATIAL_INDEX = new Param(\"create spatial index\",\n            Boolean.class, \"enable/disable the automatic creation of spatial index\", false, true,\n            new KVP(Param.LEVEL, \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "CREATE_SPATIAL_INDEX = new Param(\"create spatial index\",\n            Boolean.class, \"enable/disable the automatic creation of spatial index\", false, true,\n            new KVP(Param.LEVEL, \"advanced\"))", "var_name": "CREATE_SPATIAL_INDEX"}, {"original_string": "public static final Param DBFCHARSET = new Param(\"charset\", Charset.class,\n            \"character used to decode strings from the DBF file\", false,\n            Charset.forName(\"ISO-8859-1\"), new KVP(Param.LEVEL, \"advanced\")) {\n        /*\n         * This is an example of a non simple Param type where a custom parse method is required.\n         * \n         * @see org.geotools.data.DataStoreFactorySpi.Param#parse(java.lang.String)\n         */\n        public Object parse(String text) throws IOException {\n            return Charset.forName(text);\n        }\n\n        public String text(Object value) {\n            return ((Charset) value).name();\n        }\n    };", "modifier": "public static final", "type": "Param", "declarator": "DBFCHARSET = new Param(\"charset\", Charset.class,\n            \"character used to decode strings from the DBF file\", false,\n            Charset.forName(\"ISO-8859-1\"), new KVP(Param.LEVEL, \"advanced\")) {\n        /*\n         * This is an example of a non simple Param type where a custom parse method is required.\n         * \n         * @see org.geotools.data.DataStoreFactorySpi.Param#parse(java.lang.String)\n         */\n        public Object parse(String text) throws IOException {\n            return Charset.forName(text);\n        }\n\n        public String text(Object value) {\n            return ((Charset) value).name();\n        }\n    }", "var_name": "DBFCHARSET"}, {"original_string": "public static final Param FSTYPE = new Param(\"fstype\",\n            String.class, \"Enable using a setting of 'shape'.\", false, \"shape\",\n            new KVP(Param.LEVEL, \"advanced\", Param.OPTIONS,Arrays.asList(new String[]{\"shape-ng\", \"shape\", \"index\"})));", "modifier": "public static final", "type": "Param", "declarator": "FSTYPE = new Param(\"fstype\",\n            String.class, \"Enable using a setting of 'shape'.\", false, \"shape\",\n            new KVP(Param.LEVEL, \"advanced\", Param.OPTIONS,Arrays.asList(new String[]{\"shape-ng\", \"shape\", \"index\"})))", "var_name": "FSTYPE"}, {"original_string": "public static final Param DBFTIMEZONE = new Param(\"timezone\", TimeZone.class,\n            \"time zone used to read dates from the DBF file\", false, TimeZone.getDefault(),\n            new KVP(Param.LEVEL, \"advanced\")) {\n\n        public Object parse(String text) throws IOException {\n            return TimeZone.getTimeZone(text);\n        }\n\n        public String text(Object value) {\n            return ((TimeZone) value).getID();\n        }\n    };", "modifier": "public static final", "type": "Param", "declarator": "DBFTIMEZONE = new Param(\"timezone\", TimeZone.class,\n            \"time zone used to read dates from the DBF file\", false, TimeZone.getDefault(),\n            new KVP(Param.LEVEL, \"advanced\")) {\n\n        public Object parse(String text) throws IOException {\n            return TimeZone.getTimeZone(text);\n        }\n\n        public String text(Object value) {\n            return ((TimeZone) value).getID();\n        }\n    }", "var_name": "DBFTIMEZONE"}, {"original_string": "public static final Param ENABLE_SPATIAL_INDEX = new Param(\"enable spatial index\",\n            Boolean.class, \"enable/disable the use of spatial index for local shapefiles\", false,\n            true, new KVP(Param.LEVEL, \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "ENABLE_SPATIAL_INDEX = new Param(\"enable spatial index\",\n            Boolean.class, \"enable/disable the use of spatial index for local shapefiles\", false,\n            true, new KVP(Param.LEVEL, \"advanced\"))", "var_name": "ENABLE_SPATIAL_INDEX"}], "methods": [{"identifier": "getDisplayName", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getDisplayName()", "full_signature": "public String getDisplayName()", "class_method_signature": "ShapefileDataStoreFactory.getDisplayName()", "testcase": false, "constructor": false}, {"identifier": "getDescription", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getDescription()", "full_signature": "public String getDescription()", "class_method_signature": "ShapefileDataStoreFactory.getDescription()", "testcase": false, "constructor": false}, {"identifier": "getParametersInfo", "parameters": "()", "modifiers": "public", "return": "Param[]", "signature": "Param[] getParametersInfo()", "full_signature": "public Param[] getParametersInfo()", "class_method_signature": "ShapefileDataStoreFactory.getParametersInfo()", "testcase": false, "constructor": false}, {"identifier": "isAvailable", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isAvailable()", "full_signature": "public boolean isAvailable()", "class_method_signature": "ShapefileDataStoreFactory.isAvailable()", "testcase": false, "constructor": false}, {"identifier": "getImplementationHints", "parameters": "()", "modifiers": "public", "return": "Map<Key, ?>", "signature": "Map<Key, ?> getImplementationHints()", "full_signature": "public Map<Key, ?> getImplementationHints()", "class_method_signature": "ShapefileDataStoreFactory.getImplementationHints()", "testcase": false, "constructor": false}, {"identifier": "createDataStore", "parameters": "(Map<String, Serializable> params)", "modifiers": "public", "return": "DataStore", "signature": "DataStore createDataStore(Map<String, Serializable> params)", "full_signature": "public DataStore createDataStore(Map<String, Serializable> params)", "class_method_signature": "ShapefileDataStoreFactory.createDataStore(Map<String, Serializable> params)", "testcase": false, "constructor": false}, {"identifier": "createNewDataStore", "parameters": "(Map<String, Serializable> params)", "modifiers": "public", "return": "DataStore", "signature": "DataStore createNewDataStore(Map<String, Serializable> params)", "full_signature": "public DataStore createNewDataStore(Map<String, Serializable> params)", "class_method_signature": "ShapefileDataStoreFactory.createNewDataStore(Map<String, Serializable> params)", "testcase": false, "constructor": false}, {"identifier": "lookup", "parameters": "(Param param, Map<String, Serializable> params, Class<T> target)", "modifiers": "", "return": "T", "signature": "T lookup(Param param, Map<String, Serializable> params, Class<T> target)", "full_signature": " T lookup(Param param, Map<String, Serializable> params, Class<T> target)", "class_method_signature": "ShapefileDataStoreFactory.lookup(Param param, Map<String, Serializable> params, Class<T> target)", "testcase": false, "constructor": false}, {"identifier": "canProcess", "parameters": "(Map params)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean canProcess(Map params)", "full_signature": "@Override public boolean canProcess(Map params)", "class_method_signature": "ShapefileDataStoreFactory.canProcess(Map params)", "testcase": false, "constructor": false}, {"identifier": "canProcess", "parameters": "(URL f)", "modifiers": "public", "return": "boolean", "signature": "boolean canProcess(URL f)", "full_signature": "public boolean canProcess(URL f)", "class_method_signature": "ShapefileDataStoreFactory.canProcess(URL f)", "testcase": false, "constructor": false}, {"identifier": "getFileExtensions", "parameters": "()", "modifiers": "@Override public", "return": "String[]", "signature": "String[] getFileExtensions()", "full_signature": "@Override public String[] getFileExtensions()", "class_method_signature": "ShapefileDataStoreFactory.getFileExtensions()", "testcase": false, "constructor": false}, {"identifier": "createDataStore", "parameters": "(URL url)", "modifiers": "@Override public", "return": "FileDataStore", "signature": "FileDataStore createDataStore(URL url)", "full_signature": "@Override public FileDataStore createDataStore(URL url)", "class_method_signature": "ShapefileDataStoreFactory.createDataStore(URL url)", "testcase": false, "constructor": false}, {"identifier": "getTypeName", "parameters": "(URL url)", "modifiers": "@Override public", "return": "String", "signature": "String getTypeName(URL url)", "full_signature": "@Override public String getTypeName(URL url)", "class_method_signature": "ShapefileDataStoreFactory.getTypeName(URL url)", "testcase": false, "constructor": false}], "file": "modules/plugin/shapefile/src/main/java/org/geotools/data/shapefile/ShapefileDataStoreFactory.java"}, "focal_method": {"identifier": "canProcess", "parameters": "(Map params)", "modifiers": "@Override public", "return": "boolean", "body": "@Override\n    public boolean canProcess(Map params) {\n        if (!DataUtilities.canProcess(params, getParametersInfo())) {\n            return false; // fail basic param check\n        }\n        try {\n            URL url = (URL) URLP.lookUp(params);\n            if (canProcess(url)) {\n                return true;\n            } else {\n                // maybe it's a directory?\n                Object fileType = FILE_TYPE.lookUp(params);\n                File dir = DataUtilities.urlToFile(url);\n                // check for null fileType for backwards compatibility\n                return dir.isDirectory() && (fileType == null || \"shapefile\".equals(fileType));\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }", "signature": "boolean canProcess(Map params)", "full_signature": "@Override public boolean canProcess(Map params)", "class_method_signature": "ShapefileDataStoreFactory.canProcess(Map params)", "testcase": false, "constructor": false, "invocations": ["canProcess", "getParametersInfo", "lookUp", "canProcess", "lookUp", "urlToFile", "isDirectory", "equals"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}