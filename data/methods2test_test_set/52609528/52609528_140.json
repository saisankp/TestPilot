{"test_class": {"identifier": "KafkaMessageSenderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private KafkaProducer<String, String> producer;", "modifier": "private", "type": "KafkaProducer<String, String>", "declarator": "producer", "var_name": "producer"}, {"original_string": "private KafkaMessageSender kafkaMessageSender;", "modifier": "private", "type": "KafkaMessageSender", "declarator": "kafkaMessageSender", "var_name": "kafkaMessageSender"}], "file": "gateleen-kafka/src/test/java/org/swisspush/gateleen/kafka/KafkaMessageSenderTest.java"}, "test_case": {"identifier": "sendMultipleMessagesWithFailingMessageWrite", "parameters": "(TestContext context)", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void sendMultipleMessagesWithFailingMessageWrite(TestContext context) throws ValidationException {\n        Async async = context.async();\n        String topic = \"myTopic\";\n        final List<KafkaProducerRecord<String, String>> records =\n                buildRecords(topic, Buffer.buffer(buildThreeRecordsPayload(\"key_1\", \"key_2\", \"key_3\").encode()));\n\n        doAnswer(invocation -> {\n            Handler<AsyncResult<RecordMetadata>> handler = (Handler<AsyncResult<RecordMetadata>>) invocation.getArguments()[1];\n            handler.handle(Future.succeededFuture(new RecordMetadata(1,1,1,1, topic)));\n            return null;\n        }).when(producer).write(any(), any());\n        doAnswer(invocation -> {\n            Handler<AsyncResult<RecordMetadata>> handler = (Handler<AsyncResult<RecordMetadata>>) invocation.getArguments()[1];\n            handler.handle(Future.failedFuture(\"Message with key '\" + records.get(1).key() + \"' failed.\"));\n            return null;\n        }).when(producer).write(eq(records.get(1)), any());\n\n        kafkaMessageSender.sendMessages(producer, records).setHandler(event -> {\n            context.assertFalse(event.succeeded());\n            context.assertEquals(\"Message with key 'key_2' failed.\", event.cause().getMessage());\n            async.complete();\n        });\n\n        ArgumentCaptor<KafkaProducerRecord> recordCaptor = ArgumentCaptor.forClass(KafkaProducerRecord.class);\n        Mockito.verify(producer, times(2)).write(recordCaptor.capture(), any());\n\n        // verify only the first two messages was sent\n        context.assertEquals(2, recordCaptor.getAllValues().size());\n        context.assertEquals(records.get(0), recordCaptor.getAllValues().get(0));\n        context.assertEquals(records.get(1), recordCaptor.getAllValues().get(1));\n    }", "signature": "void sendMultipleMessagesWithFailingMessageWrite(TestContext context)", "full_signature": "@Test public void sendMultipleMessagesWithFailingMessageWrite(TestContext context)", "class_method_signature": "KafkaMessageSenderTest.sendMultipleMessagesWithFailingMessageWrite(TestContext context)", "testcase": true, "constructor": false, "invocations": ["async", "buildRecords", "buffer", "encode", "buildThreeRecordsPayload", "write", "when", "doAnswer", "getArguments", "handle", "succeededFuture", "any", "any", "write", "when", "doAnswer", "getArguments", "handle", "failedFuture", "key", "get", "eq", "get", "any", "setHandler", "sendMessages", "assertFalse", "succeeded", "assertEquals", "getMessage", "cause", "complete", "forClass", "write", "verify", "times", "capture", "any", "assertEquals", "size", "getAllValues", "assertEquals", "get", "get", "getAllValues", "assertEquals", "get", "get", "getAllValues"]}, "focal_class": {"identifier": "KafkaMessageSender", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(KafkaMessageSender.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(KafkaMessageSender.class)", "var_name": "log"}], "methods": [{"identifier": "sendMessages", "parameters": "(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "modifiers": "", "return": "Future<Void>", "signature": "Future<Void> sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "full_signature": " Future<Void> sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "class_method_signature": "KafkaMessageSender.sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "testcase": false, "constructor": false}, {"identifier": "sendMessage", "parameters": "(KafkaProducer<String, String> kafkaProducer, KafkaProducerRecord<String, String> message)", "modifiers": "private", "return": "Future<Void>", "signature": "Future<Void> sendMessage(KafkaProducer<String, String> kafkaProducer, KafkaProducerRecord<String, String> message)", "full_signature": "private Future<Void> sendMessage(KafkaProducer<String, String> kafkaProducer, KafkaProducerRecord<String, String> message)", "class_method_signature": "KafkaMessageSender.sendMessage(KafkaProducer<String, String> kafkaProducer, KafkaProducerRecord<String, String> message)", "testcase": false, "constructor": false}], "file": "gateleen-kafka/src/main/java/org/swisspush/gateleen/kafka/KafkaMessageSender.java"}, "focal_method": {"identifier": "sendMessages", "parameters": "(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "modifiers": "", "return": "Future<Void>", "body": "Future<Void> sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages){\n        Future<Void> future = Future.future();\n        Future<Void> f = Future.succeededFuture();\n\n        messages.stream().reduce(f,\n                (f1, message) -> f1.compose(ignore -> KafkaMessageSender.this.sendMessage(kafkaProducer, message)),\n                (voidFuture, voidFuture2) -> null\n        ).setHandler(res -> {\n            if(res.succeeded()) {\n                future.complete();\n            } else {\n                future.fail(res.cause());\n            }\n        });\n\n        return future;\n    }", "signature": "Future<Void> sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "full_signature": " Future<Void> sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "class_method_signature": "KafkaMessageSender.sendMessages(KafkaProducer<String, String> kafkaProducer,\n                                     List<KafkaProducerRecord<String, String>> messages)", "testcase": false, "constructor": false, "invocations": ["future", "succeededFuture", "setHandler", "reduce", "stream", "compose", "sendMessage", "succeeded", "complete", "fail", "cause"]}, "repository": {"repo_id": 52609528, "url": "https://github.com/swisspush/gateleen", "language": "Java", "is_fork": false, "fork_count": 28, "stargazer_count": 63, "size": 2919, "license": "licensed"}}