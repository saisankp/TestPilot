{"test_class": {"identifier": "RemoteYangTextSourceProviderImplTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final SourceIdentifier ID = RevisionSourceIdentifier.create(\"Test\", Revision.of(\"2015-10-30\"));", "modifier": "private static final", "type": "SourceIdentifier", "declarator": "ID = RevisionSourceIdentifier.create(\"Test\", Revision.of(\"2015-10-30\"))", "var_name": "ID"}, {"original_string": "private RemoteYangTextSourceProviderImpl remoteRepository;", "modifier": "private", "type": "RemoteYangTextSourceProviderImpl", "declarator": "remoteRepository", "var_name": "remoteRepository"}, {"original_string": "private SchemaRepository mockedLocalRepository;", "modifier": "private", "type": "SchemaRepository", "declarator": "mockedLocalRepository", "var_name": "mockedLocalRepository"}, {"original_string": "private final Set<SourceIdentifier> providedSources = Collections.singleton(ID);", "modifier": "private final", "type": "Set<SourceIdentifier>", "declarator": "providedSources = Collections.singleton(ID)", "var_name": "providedSources"}], "file": "opendaylight/md-sal/sal-clustering-commons/src/test/java/org/opendaylight/controller/cluster/schema/provider/impl/RemoteYangTextSourceProviderImplTest.java"}, "test_case": {"identifier": "testGetNonExistentYangTextSchemaSource", "parameters": "()", "modifiers": "@Test(expected = SchemaSourceException.class) public", "return": "void", "body": "@Test(expected = SchemaSourceException.class)\n    public void testGetNonExistentYangTextSchemaSource() throws Exception {\n        Mockito.when(mockedLocalRepository.getSchemaSource(ID, YangTextSchemaSource.class)).thenReturn(\n                Futures.immediateFailedFuture(new SchemaSourceException(\"Source is not provided\")));\n\n        Future<YangTextSchemaSourceSerializationProxy> retrievedSourceFuture =\n                remoteRepository.getYangTextSchemaSource(ID);\n        assertTrue(retrievedSourceFuture.isCompleted());\n        Await.result(retrievedSourceFuture, FiniteDuration.Zero());\n    }", "signature": "void testGetNonExistentYangTextSchemaSource()", "full_signature": "@Test(expected = SchemaSourceException.class) public void testGetNonExistentYangTextSchemaSource()", "class_method_signature": "RemoteYangTextSourceProviderImplTest.testGetNonExistentYangTextSchemaSource()", "testcase": true, "constructor": false, "invocations": ["thenReturn", "when", "getSchemaSource", "immediateFailedFuture", "getYangTextSchemaSource", "assertTrue", "isCompleted", "result", "Zero"]}, "focal_class": {"identifier": "RemoteYangTextSourceProviderImpl", "superclass": "", "interfaces": "implements RemoteYangTextSourceProvider", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(RemoteYangTextSourceProviderImpl.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(RemoteYangTextSourceProviderImpl.class)", "var_name": "LOG"}, {"original_string": "private final SchemaRepository repository;", "modifier": "private final", "type": "SchemaRepository", "declarator": "repository", "var_name": "repository"}, {"original_string": "private final Set<SourceIdentifier> providedSources;", "modifier": "private final", "type": "Set<SourceIdentifier>", "declarator": "providedSources", "var_name": "providedSources"}], "methods": [{"identifier": "RemoteYangTextSourceProviderImpl", "parameters": "(final SchemaRepository repository,\n            final Set<SourceIdentifier> providedSources)", "modifiers": "public", "return": "", "signature": " RemoteYangTextSourceProviderImpl(final SchemaRepository repository,\n            final Set<SourceIdentifier> providedSources)", "full_signature": "public  RemoteYangTextSourceProviderImpl(final SchemaRepository repository,\n            final Set<SourceIdentifier> providedSources)", "class_method_signature": "RemoteYangTextSourceProviderImpl.RemoteYangTextSourceProviderImpl(final SchemaRepository repository,\n            final Set<SourceIdentifier> providedSources)", "testcase": false, "constructor": true}, {"identifier": "getProvidedSources", "parameters": "()", "modifiers": "@Override public", "return": "Future<Set<SourceIdentifier>>", "signature": "Future<Set<SourceIdentifier>> getProvidedSources()", "full_signature": "@Override public Future<Set<SourceIdentifier>> getProvidedSources()", "class_method_signature": "RemoteYangTextSourceProviderImpl.getProvidedSources()", "testcase": false, "constructor": false}, {"identifier": "getYangTextSchemaSource", "parameters": "(final SourceIdentifier identifier)", "modifiers": "@Override public", "return": "Future<YangTextSchemaSourceSerializationProxy>", "signature": "Future<YangTextSchemaSourceSerializationProxy> getYangTextSchemaSource(final SourceIdentifier identifier)", "full_signature": "@Override public Future<YangTextSchemaSourceSerializationProxy> getYangTextSchemaSource(final SourceIdentifier identifier)", "class_method_signature": "RemoteYangTextSourceProviderImpl.getYangTextSchemaSource(final SourceIdentifier identifier)", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-clustering-commons/src/main/java/org/opendaylight/controller/cluster/schema/provider/impl/RemoteYangTextSourceProviderImpl.java"}, "focal_method": {"identifier": "getYangTextSchemaSource", "parameters": "(final SourceIdentifier identifier)", "modifiers": "@Override public", "return": "Future<YangTextSchemaSourceSerializationProxy>", "body": "@Override\n    public Future<YangTextSchemaSourceSerializationProxy> getYangTextSchemaSource(final SourceIdentifier identifier) {\n        LOG.trace(\"Sending yang schema source for {}\", identifier);\n\n        final Promise<YangTextSchemaSourceSerializationProxy> promise = akka.dispatch.Futures.promise();\n        ListenableFuture<YangTextSchemaSource> future =\n                repository.getSchemaSource(identifier, YangTextSchemaSource.class);\n\n        Futures.addCallback(future, new FutureCallback<YangTextSchemaSource>() {\n            @Override\n            public void onSuccess(final YangTextSchemaSource result) {\n                try {\n                    promise.success(new YangTextSchemaSourceSerializationProxy(result));\n                } catch (IOException e) {\n                    LOG.warn(\"Unable to read schema source for {}\", result.getIdentifier(), e);\n                    promise.failure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(final Throwable failure) {\n                LOG.warn(\"Unable to retrieve schema source from provider\", failure);\n                promise.failure(failure);\n            }\n        }, MoreExecutors.directExecutor());\n\n        return promise.future();\n    }", "signature": "Future<YangTextSchemaSourceSerializationProxy> getYangTextSchemaSource(final SourceIdentifier identifier)", "full_signature": "@Override public Future<YangTextSchemaSourceSerializationProxy> getYangTextSchemaSource(final SourceIdentifier identifier)", "class_method_signature": "RemoteYangTextSourceProviderImpl.getYangTextSchemaSource(final SourceIdentifier identifier)", "testcase": false, "constructor": false, "invocations": ["trace", "promise", "getSchemaSource", "addCallback", "success", "warn", "getIdentifier", "failure", "warn", "failure", "directExecutor", "future"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}