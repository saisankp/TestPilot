{"test_class": {"identifier": "PaymentSessionTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final NetworkParameters params = TestNet3Params.get();", "modifier": "private static final", "type": "NetworkParameters", "declarator": "params = TestNet3Params.get()", "var_name": "params"}, {"original_string": "private static final String simplePaymentUrl = \"http://a.simple.url.com/\";", "modifier": "private static final", "type": "String", "declarator": "simplePaymentUrl = \"http://a.simple.url.com/\"", "var_name": "simplePaymentUrl"}, {"original_string": "private static final String paymentRequestMemo = \"send coinz noa plz kthx\";", "modifier": "private static final", "type": "String", "declarator": "paymentRequestMemo = \"send coinz noa plz kthx\"", "var_name": "paymentRequestMemo"}, {"original_string": "private static final String paymentMemo = \"take ze coinz\";", "modifier": "private static final", "type": "String", "declarator": "paymentMemo = \"take ze coinz\"", "var_name": "paymentMemo"}, {"original_string": "private static final ByteString merchantData = ByteString.copyFromUtf8(\"merchant data\");", "modifier": "private static final", "type": "ByteString", "declarator": "merchantData = ByteString.copyFromUtf8(\"merchant data\")", "var_name": "merchantData"}, {"original_string": "private static final long time = System.currentTimeMillis() / 1000L;", "modifier": "private static final", "type": "long", "declarator": "time = System.currentTimeMillis() / 1000L", "var_name": "time"}, {"original_string": "private ECKey serverKey;", "modifier": "private", "type": "ECKey", "declarator": "serverKey", "var_name": "serverKey"}, {"original_string": "private Transaction tx;", "modifier": "private", "type": "Transaction", "declarator": "tx", "var_name": "tx"}, {"original_string": "private TransactionOutput outputToMe;", "modifier": "private", "type": "TransactionOutput", "declarator": "outputToMe", "var_name": "outputToMe"}, {"original_string": "BigInteger nanoCoins = Utils.toNanoCoins(1, 0);", "modifier": "", "type": "BigInteger", "declarator": "nanoCoins = Utils.toNanoCoins(1, 0)", "var_name": "nanoCoins"}], "file": "core/src/test/java/com/google/bitcoin/protocols/payments/PaymentSessionTest.java"}, "test_case": {"identifier": "testPkiVerification", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testPkiVerification() throws Exception {\n        InputStream in = getClass().getResourceAsStream(\"pki_test.bitcoinpaymentrequest\");\n        Protos.PaymentRequest paymentRequest = Protos.PaymentRequest.newBuilder().mergeFrom(in).build();\n        MockPaymentSession paymentSession = new MockPaymentSession(paymentRequest);\n        PaymentSession.PkiVerificationData pkiData = paymentSession.verifyPki();\n        assertEquals(\"www.bitcoincore.org\", pkiData.name);\n        assertEquals(\"The USERTRUST Network, Salt Lake City, US\", pkiData.rootAuthorityName);\n    }", "signature": "void testPkiVerification()", "full_signature": "@Test public void testPkiVerification()", "class_method_signature": "PaymentSessionTest.testPkiVerification()", "testcase": true, "constructor": false, "invocations": ["getResourceAsStream", "getClass", "build", "mergeFrom", "newBuilder", "verifyPki", "assertEquals", "assertEquals"]}, "focal_class": {"identifier": "PaymentSession", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static ListeningExecutorService executor = Threading.THREAD_POOL;", "modifier": "private static", "type": "ListeningExecutorService", "declarator": "executor = Threading.THREAD_POOL", "var_name": "executor"}, {"original_string": "private NetworkParameters params;", "modifier": "private", "type": "NetworkParameters", "declarator": "params", "var_name": "params"}, {"original_string": "private String trustStorePath;", "modifier": "private", "type": "String", "declarator": "trustStorePath", "var_name": "trustStorePath"}, {"original_string": "private Protos.PaymentRequest paymentRequest;", "modifier": "private", "type": "Protos.PaymentRequest", "declarator": "paymentRequest", "var_name": "paymentRequest"}, {"original_string": "private Protos.PaymentDetails paymentDetails;", "modifier": "private", "type": "Protos.PaymentDetails", "declarator": "paymentDetails", "var_name": "paymentDetails"}, {"original_string": "private BigInteger totalValue = BigInteger.ZERO;", "modifier": "private", "type": "BigInteger", "declarator": "totalValue = BigInteger.ZERO", "var_name": "totalValue"}, {"original_string": "public PkiVerificationData pkiVerificationData;", "modifier": "public", "type": "PkiVerificationData", "declarator": "pkiVerificationData", "var_name": "pkiVerificationData"}], "methods": [{"identifier": "createFromBitcoinUri", "parameters": "(final BitcoinURI uri)", "modifiers": "public static", "return": "ListenableFuture<PaymentSession>", "signature": "ListenableFuture<PaymentSession> createFromBitcoinUri(final BitcoinURI uri)", "full_signature": "public static ListenableFuture<PaymentSession> createFromBitcoinUri(final BitcoinURI uri)", "class_method_signature": "PaymentSession.createFromBitcoinUri(final BitcoinURI uri)", "testcase": false, "constructor": false}, {"identifier": "createFromBitcoinUri", "parameters": "(final BitcoinURI uri, final boolean verifyPki)", "modifiers": "public static", "return": "ListenableFuture<PaymentSession>", "signature": "ListenableFuture<PaymentSession> createFromBitcoinUri(final BitcoinURI uri, final boolean verifyPki)", "full_signature": "public static ListenableFuture<PaymentSession> createFromBitcoinUri(final BitcoinURI uri, final boolean verifyPki)", "class_method_signature": "PaymentSession.createFromBitcoinUri(final BitcoinURI uri, final boolean verifyPki)", "testcase": false, "constructor": false}, {"identifier": "createFromBitcoinUri", "parameters": "(final BitcoinURI uri, final boolean verifyPki, @Nullable final String trustStorePath)", "modifiers": "public static", "return": "ListenableFuture<PaymentSession>", "signature": "ListenableFuture<PaymentSession> createFromBitcoinUri(final BitcoinURI uri, final boolean verifyPki, @Nullable final String trustStorePath)", "full_signature": "public static ListenableFuture<PaymentSession> createFromBitcoinUri(final BitcoinURI uri, final boolean verifyPki, @Nullable final String trustStorePath)", "class_method_signature": "PaymentSession.createFromBitcoinUri(final BitcoinURI uri, final boolean verifyPki, @Nullable final String trustStorePath)", "testcase": false, "constructor": false}, {"identifier": "createFromUrl", "parameters": "(final String url)", "modifiers": "public static", "return": "ListenableFuture<PaymentSession>", "signature": "ListenableFuture<PaymentSession> createFromUrl(final String url)", "full_signature": "public static ListenableFuture<PaymentSession> createFromUrl(final String url)", "class_method_signature": "PaymentSession.createFromUrl(final String url)", "testcase": false, "constructor": false}, {"identifier": "createFromUrl", "parameters": "(final String url, final boolean verifyPki)", "modifiers": "public static", "return": "ListenableFuture<PaymentSession>", "signature": "ListenableFuture<PaymentSession> createFromUrl(final String url, final boolean verifyPki)", "full_signature": "public static ListenableFuture<PaymentSession> createFromUrl(final String url, final boolean verifyPki)", "class_method_signature": "PaymentSession.createFromUrl(final String url, final boolean verifyPki)", "testcase": false, "constructor": false}, {"identifier": "createFromUrl", "parameters": "(final String url, final boolean verifyPki, @Nullable final String trustStorePath)", "modifiers": "public static", "return": "ListenableFuture<PaymentSession>", "signature": "ListenableFuture<PaymentSession> createFromUrl(final String url, final boolean verifyPki, @Nullable final String trustStorePath)", "full_signature": "public static ListenableFuture<PaymentSession> createFromUrl(final String url, final boolean verifyPki, @Nullable final String trustStorePath)", "class_method_signature": "PaymentSession.createFromUrl(final String url, final boolean verifyPki, @Nullable final String trustStorePath)", "testcase": false, "constructor": false}, {"identifier": "fetchPaymentRequest", "parameters": "(final URI uri, final boolean verifyPki, @Nullable final String trustStorePath)", "modifiers": "private static", "return": "ListenableFuture<PaymentSession>", "signature": "ListenableFuture<PaymentSession> fetchPaymentRequest(final URI uri, final boolean verifyPki, @Nullable final String trustStorePath)", "full_signature": "private static ListenableFuture<PaymentSession> fetchPaymentRequest(final URI uri, final boolean verifyPki, @Nullable final String trustStorePath)", "class_method_signature": "PaymentSession.fetchPaymentRequest(final URI uri, final boolean verifyPki, @Nullable final String trustStorePath)", "testcase": false, "constructor": false}, {"identifier": "PaymentSession", "parameters": "(Protos.PaymentRequest request)", "modifiers": "public", "return": "", "signature": " PaymentSession(Protos.PaymentRequest request)", "full_signature": "public  PaymentSession(Protos.PaymentRequest request)", "class_method_signature": "PaymentSession.PaymentSession(Protos.PaymentRequest request)", "testcase": false, "constructor": true}, {"identifier": "PaymentSession", "parameters": "(Protos.PaymentRequest request, boolean verifyPki)", "modifiers": "public", "return": "", "signature": " PaymentSession(Protos.PaymentRequest request, boolean verifyPki)", "full_signature": "public  PaymentSession(Protos.PaymentRequest request, boolean verifyPki)", "class_method_signature": "PaymentSession.PaymentSession(Protos.PaymentRequest request, boolean verifyPki)", "testcase": false, "constructor": true}, {"identifier": "PaymentSession", "parameters": "(Protos.PaymentRequest request, boolean verifyPki, @Nullable final String trustStorePath)", "modifiers": "public", "return": "", "signature": " PaymentSession(Protos.PaymentRequest request, boolean verifyPki, @Nullable final String trustStorePath)", "full_signature": "public  PaymentSession(Protos.PaymentRequest request, boolean verifyPki, @Nullable final String trustStorePath)", "class_method_signature": "PaymentSession.PaymentSession(Protos.PaymentRequest request, boolean verifyPki, @Nullable final String trustStorePath)", "testcase": false, "constructor": true}, {"identifier": "getMemo", "parameters": "()", "modifiers": "@Nullable public", "return": "String", "signature": "String getMemo()", "full_signature": "@Nullable public String getMemo()", "class_method_signature": "PaymentSession.getMemo()", "testcase": false, "constructor": false}, {"identifier": "getValue", "parameters": "()", "modifiers": "public", "return": "BigInteger", "signature": "BigInteger getValue()", "full_signature": "public BigInteger getValue()", "class_method_signature": "PaymentSession.getValue()", "testcase": false, "constructor": false}, {"identifier": "getDate", "parameters": "()", "modifiers": "public", "return": "Date", "signature": "Date getDate()", "full_signature": "public Date getDate()", "class_method_signature": "PaymentSession.getDate()", "testcase": false, "constructor": false}, {"identifier": "isExpired", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isExpired()", "full_signature": "public boolean isExpired()", "class_method_signature": "PaymentSession.isExpired()", "testcase": false, "constructor": false}, {"identifier": "getPaymentUrl", "parameters": "()", "modifiers": "public @Nullable", "return": "String", "signature": "String getPaymentUrl()", "full_signature": "public @Nullable String getPaymentUrl()", "class_method_signature": "PaymentSession.getPaymentUrl()", "testcase": false, "constructor": false}, {"identifier": "getSendRequest", "parameters": "()", "modifiers": "public", "return": "Wallet.SendRequest", "signature": "Wallet.SendRequest getSendRequest()", "full_signature": "public Wallet.SendRequest getSendRequest()", "class_method_signature": "PaymentSession.getSendRequest()", "testcase": false, "constructor": false}, {"identifier": "sendPayment", "parameters": "(List<Transaction> txns, @Nullable Address refundAddr, @Nullable String memo)", "modifiers": "public @Nullable", "return": "ListenableFuture<Ack>", "signature": "ListenableFuture<Ack> sendPayment(List<Transaction> txns, @Nullable Address refundAddr, @Nullable String memo)", "full_signature": "public @Nullable ListenableFuture<Ack> sendPayment(List<Transaction> txns, @Nullable Address refundAddr, @Nullable String memo)", "class_method_signature": "PaymentSession.sendPayment(List<Transaction> txns, @Nullable Address refundAddr, @Nullable String memo)", "testcase": false, "constructor": false}, {"identifier": "getPayment", "parameters": "(List<Transaction> txns, @Nullable Address refundAddr, @Nullable String memo)", "modifiers": "public @Nullable", "return": "Protos.Payment", "signature": "Protos.Payment getPayment(List<Transaction> txns, @Nullable Address refundAddr, @Nullable String memo)", "full_signature": "public @Nullable Protos.Payment getPayment(List<Transaction> txns, @Nullable Address refundAddr, @Nullable String memo)", "class_method_signature": "PaymentSession.getPayment(List<Transaction> txns, @Nullable Address refundAddr, @Nullable String memo)", "testcase": false, "constructor": false}, {"identifier": "sendPayment", "parameters": "(final URL url, final Protos.Payment payment)", "modifiers": "@VisibleForTesting protected", "return": "ListenableFuture<Ack>", "signature": "ListenableFuture<Ack> sendPayment(final URL url, final Protos.Payment payment)", "full_signature": "@VisibleForTesting protected ListenableFuture<Ack> sendPayment(final URL url, final Protos.Payment payment)", "class_method_signature": "PaymentSession.sendPayment(final URL url, final Protos.Payment payment)", "testcase": false, "constructor": false}, {"identifier": "verifyPki", "parameters": "()", "modifiers": "public @Nullable", "return": "PkiVerificationData", "signature": "PkiVerificationData verifyPki()", "full_signature": "public @Nullable PkiVerificationData verifyPki()", "class_method_signature": "PaymentSession.verifyPki()", "testcase": false, "constructor": false}, {"identifier": "createKeyStore", "parameters": "(@Nullable String path)", "modifiers": "private", "return": "KeyStore", "signature": "KeyStore createKeyStore(@Nullable String path)", "full_signature": "private KeyStore createKeyStore(@Nullable String path)", "class_method_signature": "PaymentSession.createKeyStore(@Nullable String path)", "testcase": false, "constructor": false}, {"identifier": "parsePaymentRequest", "parameters": "(Protos.PaymentRequest request)", "modifiers": "private", "return": "void", "signature": "void parsePaymentRequest(Protos.PaymentRequest request)", "full_signature": "private void parsePaymentRequest(Protos.PaymentRequest request)", "class_method_signature": "PaymentSession.parsePaymentRequest(Protos.PaymentRequest request)", "testcase": false, "constructor": false}, {"identifier": "getPaymentRequest", "parameters": "()", "modifiers": "public", "return": "Protos.PaymentRequest", "signature": "Protos.PaymentRequest getPaymentRequest()", "full_signature": "public Protos.PaymentRequest getPaymentRequest()", "class_method_signature": "PaymentSession.getPaymentRequest()", "testcase": false, "constructor": false}, {"identifier": "getPaymentDetails", "parameters": "()", "modifiers": "public", "return": "Protos.PaymentDetails", "signature": "Protos.PaymentDetails getPaymentDetails()", "full_signature": "public Protos.PaymentDetails getPaymentDetails()", "class_method_signature": "PaymentSession.getPaymentDetails()", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/google/bitcoin/protocols/payments/PaymentSession.java"}, "focal_method": {"identifier": "verifyPki", "parameters": "()", "modifiers": "public @Nullable", "return": "PkiVerificationData", "body": "public @Nullable PkiVerificationData verifyPki() throws PaymentRequestException {\n        try {\n            if (pkiVerificationData != null)\n                return pkiVerificationData;\n            if (paymentRequest.getPkiType().equals(\"none\"))\n                // Nothing to verify. Everything is fine. Move along.\n                return null;\n\n            String algorithm;\n            if (paymentRequest.getPkiType().equals(\"x509+sha256\"))\n                algorithm = \"SHA256withRSA\";\n            else if (paymentRequest.getPkiType().equals(\"x509+sha1\"))\n                algorithm = \"SHA1withRSA\";\n            else\n                throw new PaymentRequestException.InvalidPkiType(\"Unsupported PKI type: \" + paymentRequest.getPkiType());\n\n            Protos.X509Certificates protoCerts = Protos.X509Certificates.parseFrom(paymentRequest.getPkiData());\n            if (protoCerts.getCertificateCount() == 0)\n                throw new PaymentRequestException.InvalidPkiData(\"No certificates provided in message: server config error\");\n\n            // Parse the certs and turn into a certificate chain object. Cert factories can parse both DER and base64.\n            // The ordering of certificates is defined by the payment protocol spec to be the same as what the Java\n            // crypto API requires - convenient!\n            CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n            List<X509Certificate> certs = Lists.newArrayList();\n            for (ByteString bytes : protoCerts.getCertificateList())\n                certs.add((X509Certificate) certificateFactory.generateCertificate(bytes.newInput()));\n            CertPath path = certificateFactory.generateCertPath(certs);\n\n            // Retrieves the most-trusted CAs from keystore.\n            PKIXParameters params = new PKIXParameters(createKeyStore(trustStorePath));\n            // Revocation not supported in the current version.\n            params.setRevocationEnabled(false);\n\n            // Now verify the certificate chain is correct and trusted. This let's us get an identity linked pubkey.\n            CertPathValidator validator = CertPathValidator.getInstance(\"PKIX\");\n            PKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult) validator.validate(path, params);\n            PublicKey publicKey = result.getPublicKey();\n            // OK, we got an identity, now check it was used to sign this message.\n            Signature signature = Signature.getInstance(algorithm);\n            // Note that we don't use signature.initVerify(certs.get(0)) here despite it being the most obvious\n            // way to set it up, because we don't care about the constraints specified on the certificates: any\n            // cert that links a key to a domain name or other identity will do for us.\n            signature.initVerify(publicKey);\n            Protos.PaymentRequest.Builder reqToCheck = paymentRequest.toBuilder();\n            reqToCheck.setSignature(ByteString.EMPTY);\n            signature.update(reqToCheck.build().toByteArray());\n            if (!signature.verify(paymentRequest.getSignature().toByteArray()))\n                throw new PaymentRequestException.PkiVerificationException(\"Invalid signature, this payment request is not valid.\");\n\n            // Signature verifies, get the names from the identity we just verified for presentation to the user.\n            X500Principal principal = certs.get(0).getSubjectX500Principal();\n            // At this point the Java crypto API falls flat on its face and dies - there's no clean way to get the\n            // different parts of the certificate name except for parsing the string. That's hard because of various\n            // custom escaping rules and the usual crap. So, use Bouncy Castle to re-parse the string into binary form\n            // again and then look for the names we want. Fail!\n            org.spongycastle.asn1.x500.X500Name name = new X500Name(principal.getName());\n            String entityName = null, orgName = null;\n            for (RDN rdn : name.getRDNs()) {\n                AttributeTypeAndValue pair = rdn.getFirst();\n                if (pair.getType().equals(RFC4519Style.cn))\n                    entityName = ((ASN1String)pair.getValue()).getString();\n                else if (pair.getType().equals(RFC4519Style.o))\n                    orgName = ((ASN1String)pair.getValue()).getString();\n            }\n            if (entityName == null && orgName == null)\n                throw new PaymentRequestException.PkiVerificationException(\"Invalid certificate, no CN or O fields\");\n            // Everything is peachy. Return some useful data to the caller.\n            PkiVerificationData data = new PkiVerificationData(entityName, orgName, publicKey, result.getTrustAnchor());\n            // Cache the result so we don't have to re-verify if this method is called again.\n            pkiVerificationData = data;\n            return data;\n        } catch (InvalidProtocolBufferException e) {\n            // Data structures are malformed.\n            throw new PaymentRequestException.InvalidPkiData(e);\n        } catch (CertificateException e) {\n            // The X.509 certificate data didn't parse correctly.\n            throw new PaymentRequestException.PkiVerificationException(e);\n        } catch (NoSuchAlgorithmException e) {\n            // Should never happen so don't make users have to think about it. PKIX is always present.\n            throw new RuntimeException(e);\n        } catch (InvalidAlgorithmParameterException e) {\n            throw new RuntimeException(e);\n        } catch (CertPathValidatorException e) {\n            // The certificate chain isn't known or trusted, probably, the server is using an SSL root we don't\n            // know about and the user needs to upgrade to a new version of the software (or import a root cert).\n            throw new PaymentRequestException.PkiVerificationException(e);\n        } catch (InvalidKeyException e) {\n            // Shouldn't happen if the certs verified correctly.\n            throw new PaymentRequestException.PkiVerificationException(e);\n        } catch (SignatureException e) {\n            // Something went wrong during hashing (yes, despite the name, this does not mean the sig was invalid).\n            throw new PaymentRequestException.PkiVerificationException(e);\n        } catch (IOException e) {\n            throw new PaymentRequestException.PkiVerificationException(e);\n        } catch (KeyStoreException e) {\n            throw new RuntimeException(e);\n        }\n    }", "signature": "PkiVerificationData verifyPki()", "full_signature": "public @Nullable PkiVerificationData verifyPki()", "class_method_signature": "PaymentSession.verifyPki()", "testcase": false, "constructor": false, "invocations": ["equals", "getPkiType", "equals", "getPkiType", "equals", "getPkiType", "getPkiType", "parseFrom", "getPkiData", "getCertificateCount", "getInstance", "newArrayList", "getCertificateList", "add", "generateCertificate", "newInput", "generateCertPath", "createKeyStore", "setRevocationEnabled", "getInstance", "validate", "getPublicKey", "getInstance", "initVerify", "toBuilder", "setSignature", "update", "toByteArray", "build", "verify", "toByteArray", "getSignature", "getSubjectX500Principal", "get", "getName", "getRDNs", "getFirst", "equals", "getType", "getString", "getValue", "equals", "getType", "getString", "getValue", "getTrustAnchor"]}, "repository": {"repo_id": 24363680, "url": "https://github.com/cannabiscoindev/cannabiscoinj", "language": "Java", "is_fork": false, "fork_count": 9, "stargazer_count": 5, "size": 10126, "license": "licensed"}}