{"test_class": {"identifier": "VanillaDataCacheTest", "superclass": "extends VanillaChronicleTestBase", "interfaces": "", "fields": [], "file": "chronicle/src/test/java/net/openhft/chronicle/VanillaDataCacheTest.java"}, "test_case": {"identifier": "testFindNextDataCount", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testFindNextDataCount() throws Exception {\n        final String baseDir = getTestPath();\n        assertNotNull(baseDir);\n\n        try {\n            final DateCache dateCache = new DateCache(\"yyyyMMddHHmmss\", 1000);\n            final VanillaDataCache cache = new VanillaDataCache(baseDir, 10 + 6, dateCache);\n\n            int cycle = (int) (System.currentTimeMillis() / 1000);\n            final int threadId = AffinitySupport.getThreadId();\n\n            // Check that the data file count starts at 0 when the data directory is empty\n            assertEquals(0, cache.findNextDataCount(cycle, threadId));\n\n            // Add some more data files into the directory - use discontinuous numbers to test reading\n            VanillaMappedBytes vanillaBuffer1 = cache.dataFor(cycle, threadId, 1, true);\n            vanillaBuffer1.release();\n\n            VanillaMappedBytes vanillaBuffer2 = cache.dataFor(cycle, threadId, 2, true);\n            vanillaBuffer2.release();\n\n            VanillaMappedBytes vanillaBuffer4 = cache.dataFor(cycle, threadId, 4, true);\n            vanillaBuffer4.release();\n\n            cache.checkCounts(1, 1);\n            cache.close();\n\n            // Open a new cache and check that it reads the existing data files that were created above\n            final VanillaDataCache cache2 = new VanillaDataCache(baseDir, 10 + 6, dateCache);\n\n            assertEquals(5, cache2.findNextDataCount(cycle, threadId));\n\n            cache.checkCounts(1, 1);\n            cache2.close();\n        } finally {\n            IOTools.deleteDir(baseDir);\n            assertFalse(new File(baseDir).exists());\n        }\n    }", "signature": "void testFindNextDataCount()", "full_signature": "@Test public void testFindNextDataCount()", "class_method_signature": "VanillaDataCacheTest.testFindNextDataCount()", "testcase": true, "constructor": false, "invocations": ["getTestPath", "assertNotNull", "currentTimeMillis", "getThreadId", "assertEquals", "findNextDataCount", "dataFor", "release", "dataFor", "release", "dataFor", "release", "checkCounts", "close", "assertEquals", "findNextDataCount", "checkCounts", "close", "deleteDir", "assertFalse", "exists"]}, "focal_class": {"identifier": "VanillaDataCache", "superclass": "", "interfaces": "implements Closeable", "fields": [{"original_string": "private static final String FILE_NAME_PREFIX = \"data-\";", "modifier": "private static final", "type": "String", "declarator": "FILE_NAME_PREFIX = \"data-\"", "var_name": "FILE_NAME_PREFIX"}, {"original_string": "private final String basePath;", "modifier": "private final", "type": "String", "declarator": "basePath", "var_name": "basePath"}, {"original_string": "private final DataKey key = new DataKey();", "modifier": "private final", "type": "DataKey", "declarator": "key = new DataKey()", "var_name": "key"}, {"original_string": "private final int blockBits;", "modifier": "private final", "type": "int", "declarator": "blockBits", "var_name": "blockBits"}, {"original_string": "private final DateCache dateCache;", "modifier": "private final", "type": "DateCache", "declarator": "dateCache", "var_name": "dateCache"}, {"original_string": "private final VanillaMappedCache<DataKey> cache;", "modifier": "private final", "type": "VanillaMappedCache<DataKey>", "declarator": "cache", "var_name": "cache"}], "methods": [{"identifier": "VanillaDataCache", "parameters": "(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache)", "modifiers": "public", "return": "", "signature": " VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache)", "full_signature": "public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache)", "class_method_signature": "VanillaDataCache.VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache)", "testcase": false, "constructor": true}, {"identifier": "VanillaDataCache", "parameters": "(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, @NotNull VanillaChronicleConfig config)", "modifiers": "public", "return": "", "signature": " VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, @NotNull VanillaChronicleConfig config)", "full_signature": "public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, @NotNull VanillaChronicleConfig config)", "class_method_signature": "VanillaDataCache.VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, @NotNull VanillaChronicleConfig config)", "testcase": false, "constructor": true}, {"identifier": "VanillaDataCache", "parameters": "(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity)", "modifiers": "public", "return": "", "signature": " VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity)", "full_signature": "public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity)", "class_method_signature": "VanillaDataCache.VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity)", "testcase": false, "constructor": true}, {"identifier": "VanillaDataCache", "parameters": "(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity, boolean cleanupOnClose)", "modifiers": "public", "return": "", "signature": " VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity, boolean cleanupOnClose)", "full_signature": "public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity, boolean cleanupOnClose)", "class_method_signature": "VanillaDataCache.VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity, boolean cleanupOnClose)", "testcase": false, "constructor": true}, {"identifier": "fileFor", "parameters": "(int cycle, int threadId, int dataCount, boolean forWrite)", "modifiers": "public", "return": "File", "signature": "File fileFor(int cycle, int threadId, int dataCount, boolean forWrite)", "full_signature": "public File fileFor(int cycle, int threadId, int dataCount, boolean forWrite)", "class_method_signature": "VanillaDataCache.fileFor(int cycle, int threadId, int dataCount, boolean forWrite)", "testcase": false, "constructor": false}, {"identifier": "fileFor", "parameters": "(int cycle, int threadId)", "modifiers": "public", "return": "File", "signature": "File fileFor(int cycle, int threadId)", "full_signature": "public File fileFor(int cycle, int threadId)", "class_method_signature": "VanillaDataCache.fileFor(int cycle, int threadId)", "testcase": false, "constructor": false}, {"identifier": "dataFor", "parameters": "(int cycle, int threadId, int dataCount, boolean forWrite)", "modifiers": "public synchronized", "return": "VanillaMappedBytes", "signature": "VanillaMappedBytes dataFor(int cycle, int threadId, int dataCount, boolean forWrite)", "full_signature": "public synchronized VanillaMappedBytes dataFor(int cycle, int threadId, int dataCount, boolean forWrite)", "class_method_signature": "VanillaDataCache.dataFor(int cycle, int threadId, int dataCount, boolean forWrite)", "testcase": false, "constructor": false}, {"identifier": "findEndOfData", "parameters": "(final VanillaMappedBytes buffer)", "modifiers": "private", "return": "void", "signature": "void findEndOfData(final VanillaMappedBytes buffer)", "full_signature": "private void findEndOfData(final VanillaMappedBytes buffer)", "class_method_signature": "VanillaDataCache.findEndOfData(final VanillaMappedBytes buffer)", "testcase": false, "constructor": false}, {"identifier": "nextWordAlignment", "parameters": "(int len)", "modifiers": "", "return": "int", "signature": "int nextWordAlignment(int len)", "full_signature": " int nextWordAlignment(int len)", "class_method_signature": "VanillaDataCache.nextWordAlignment(int len)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void close()", "full_signature": "@Override public synchronized void close()", "class_method_signature": "VanillaDataCache.close()", "testcase": false, "constructor": false}, {"identifier": "findNextDataCount", "parameters": "(int cycle, int threadId)", "modifiers": "public", "return": "int", "signature": "int findNextDataCount(int cycle, int threadId)", "full_signature": "public int findNextDataCount(int cycle, int threadId)", "class_method_signature": "VanillaDataCache.findNextDataCount(int cycle, int threadId)", "testcase": false, "constructor": false}, {"identifier": "checkCounts", "parameters": "(int min, int max)", "modifiers": "public", "return": "void", "signature": "void checkCounts(int min, int max)", "full_signature": "public void checkCounts(int min, int max)", "class_method_signature": "VanillaDataCache.checkCounts(int min, int max)", "testcase": false, "constructor": false}], "file": "chronicle/src/main/java/net/openhft/chronicle/VanillaDataCache.java"}, "focal_method": {"identifier": "findNextDataCount", "parameters": "(int cycle, int threadId)", "modifiers": "public", "return": "int", "body": "public int findNextDataCount(int cycle, int threadId) throws IOException {\n        final String cycleStr = dateCache.formatFor(cycle);\n        final String cyclePath = basePath + \"/\" + cycleStr;\n        final String dataPrefix = FILE_NAME_PREFIX + threadId + \"-\";\n\n        int maxCount = -1;\n        final File[] files = new File(cyclePath).listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.getName().startsWith(dataPrefix)) {\n                    final int count = Integer.parseInt(file.getName().substring(dataPrefix.length()));\n                    if (maxCount < count)\n                        maxCount = count;\n                }\n            }\n        }\n        // Move to the next data file\n        return maxCount + 1;\n    }", "signature": "int findNextDataCount(int cycle, int threadId)", "full_signature": "public int findNextDataCount(int cycle, int threadId)", "class_method_signature": "VanillaDataCache.findNextDataCount(int cycle, int threadId)", "testcase": false, "constructor": false, "invocations": ["formatFor", "listFiles", "startsWith", "getName", "parseInt", "substring", "getName", "length"]}, "repository": {"repo_id": 23783621, "url": "https://github.com/peter-lawrey/Java-Chronicle-OLD", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 33, "size": 1275, "license": "licensed"}}