{"test_class": {"identifier": "DbStateBackendTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static NetworkServerControl server;", "modifier": "private static", "type": "NetworkServerControl", "declarator": "server", "var_name": "server"}, {"original_string": "private static File tempDir;", "modifier": "private static", "type": "File", "declarator": "tempDir", "var_name": "tempDir"}, {"original_string": "private static DbBackendConfig conf;", "modifier": "private static", "type": "DbBackendConfig", "declarator": "conf", "var_name": "conf"}, {"original_string": "private static String url1;", "modifier": "private static", "type": "String", "declarator": "url1", "var_name": "url1"}, {"original_string": "private static String url2;", "modifier": "private static", "type": "String", "declarator": "url2", "var_name": "url2"}], "file": "flink-contrib/flink-streaming-contrib/src/test/java/org/apache/flink/contrib/streaming/state/DbStateBackendTest.java"}, "test_case": {"identifier": "testReducingState", "parameters": "()", "modifiers": "@Test @SuppressWarnings(\"unchecked,rawtypes\") public", "return": "void", "body": "@Test\n\t@SuppressWarnings(\"unchecked,rawtypes\")\n\tpublic void testReducingState() {\n\t\tFile tempDir = new File(ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH, UUID.randomUUID().toString());\n\t\ttry {\n\t\t\tFsStateBackend fileBackend = new FsStateBackend(localFileUri(tempDir));\n\n\t\t\tDbStateBackend backend = new DbStateBackend(conf, fileBackend);\n\n\t\t\tEnvironment env = new DummyEnvironment(\"test\", 2, 0);\n\n\t\t\tbackend.initializeForJob(env, \"dummy_test_kv_reduce\", IntSerializer.INSTANCE);\n\n\t\t\tReducingStateDescriptor<String> kvId = new ReducingStateDescriptor<>(\"id\",\n\t\t\t\tnew ReduceFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String reduce(String value1, String value2) throws Exception {\n\t\t\t\t\t\treturn value1 + \",\" + value2;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tStringSerializer.INSTANCE);\n\t\t\tReducingState<String> state = backend.getPartitionedState(null, VoidSerializer.INSTANCE, kvId);\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tKvState<Integer, Void, ReducingState<String>, ReducingStateDescriptor<String>, DbStateBackend> kv =\n\t\t\t\t(KvState<Integer, Void, ReducingState<String>, ReducingStateDescriptor<String>, DbStateBackend>) state;\n\n\t\t\tJoiner joiner = Joiner.on(\",\");\n\t\t\t// some modifications to the state\n\t\t\tkv.setCurrentKey(1);\n\t\t\tassertEquals(null, state.get());\n\t\t\tstate.add(\"1\");\n\t\t\tkv.setCurrentKey(2);\n\t\t\tassertEquals(null, state.get());\n\t\t\tstate.add(\"2\");\n\t\t\tkv.setCurrentKey(1);\n\t\t\tassertEquals(\"1\", state.get());\n\n\t\t\t// draw a snapshot\n\t\t\tKvStateSnapshot<Integer, Void, ReducingState<String>, ReducingStateDescriptor<String>, DbStateBackend> snapshot1 =\n\t\t\t\tkv.snapshot(682375462378L, 2);\n\n\t\t\t// make some more modifications\n\t\t\tkv.setCurrentKey(1);\n\t\t\tstate.add(\"u1\");\n\t\t\tkv.setCurrentKey(2);\n\t\t\tstate.add(\"u2\");\n\t\t\tkv.setCurrentKey(3);\n\t\t\tstate.add(\"u3\");\n\n\t\t\t// draw another snapshot\n\t\t\tKvStateSnapshot<Integer, Void, ReducingState<String>, ReducingStateDescriptor<String>, DbStateBackend> snapshot2 =\n\t\t\t\tkv.snapshot(682375462379L, 4);\n\n\t\t\t// validate the original state\n\t\t\tkv.setCurrentKey(1);\n\t\t\tassertEquals(\"1,u1\", state.get());\n\t\t\tkv.setCurrentKey(2);\n\t\t\tassertEquals(\"2,u2\", state.get());\n\t\t\tkv.setCurrentKey(3);\n\t\t\tassertEquals(\"u3\", state.get());\n\n\t\t\tkv.dispose();\n\n\t\t\t// restore the second snapshot and validate it\n\t\t\tKvState<Integer, Void, ReducingState<String>, ReducingStateDescriptor<String>, DbStateBackend> restored2 = snapshot2.restoreState(\n\t\t\t\tbackend,\n\t\t\t\tIntSerializer.INSTANCE,\n\t\t\t\tthis.getClass().getClassLoader(), 20);\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tReducingState<String> restored2State = (ReducingState<String>) restored2;\n\n\t\t\trestored2.setCurrentKey(1);\n\t\t\tassertEquals(\"1,u1\", restored2State.get());\n\t\t\trestored2.setCurrentKey(2);\n\t\t\tassertEquals(\"2,u2\", restored2State.get());\n\t\t\trestored2.setCurrentKey(3);\n\t\t\tassertEquals(\"u3\", restored2State.get());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}", "signature": "void testReducingState()", "full_signature": "@Test @SuppressWarnings(\"unchecked,rawtypes\") public void testReducingState()", "class_method_signature": "DbStateBackendTest.testReducingState()", "testcase": true, "constructor": false, "invocations": ["toString", "randomUUID", "localFileUri", "initializeForJob", "getPartitionedState", "on", "setCurrentKey", "assertEquals", "get", "add", "setCurrentKey", "assertEquals", "get", "add", "setCurrentKey", "assertEquals", "get", "snapshot", "setCurrentKey", "add", "setCurrentKey", "add", "setCurrentKey", "add", "snapshot", "setCurrentKey", "assertEquals", "get", "setCurrentKey", "assertEquals", "get", "setCurrentKey", "assertEquals", "get", "dispose", "restoreState", "getClassLoader", "getClass", "setCurrentKey", "assertEquals", "get", "setCurrentKey", "assertEquals", "get", "setCurrentKey", "assertEquals", "get", "printStackTrace", "fail", "getMessage"]}, "focal_class": {"identifier": "DbStateBackend", "superclass": "extends AbstractStateBackend", "interfaces": "", "fields": [{"original_string": "private static final long serialVersionUID = 1L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 1L", "var_name": "serialVersionUID"}, {"original_string": "private static final Logger LOG = LoggerFactory.getLogger(DbStateBackend.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(DbStateBackend.class)", "var_name": "LOG"}, {"original_string": "private Random rnd;", "modifier": "private", "type": "Random", "declarator": "rnd", "var_name": "rnd"}, {"original_string": "private transient Environment env;", "modifier": "private transient", "type": "Environment", "declarator": "env", "var_name": "env"}, {"original_string": "private transient String jobId;", "modifier": "private transient", "type": "String", "declarator": "jobId", "var_name": "jobId"}, {"original_string": "private final DbBackendConfig dbConfig;", "modifier": "private final", "type": "DbBackendConfig", "declarator": "dbConfig", "var_name": "dbConfig"}, {"original_string": "private final DbAdapter dbAdapter;", "modifier": "private final", "type": "DbAdapter", "declarator": "dbAdapter", "var_name": "dbAdapter"}, {"original_string": "private ShardedConnection connections;", "modifier": "private", "type": "ShardedConnection", "declarator": "connections", "var_name": "connections"}, {"original_string": "private final int numSqlRetries;", "modifier": "private final", "type": "int", "declarator": "numSqlRetries", "var_name": "numSqlRetries"}, {"original_string": "private final int sqlRetrySleep;", "modifier": "private final", "type": "int", "declarator": "sqlRetrySleep", "var_name": "sqlRetrySleep"}, {"original_string": "private transient PreparedStatement insertStatement;", "modifier": "private transient", "type": "PreparedStatement", "declarator": "insertStatement", "var_name": "insertStatement"}, {"original_string": "private String operatorIdentifier;", "modifier": "private", "type": "String", "declarator": "operatorIdentifier", "var_name": "operatorIdentifier"}, {"original_string": "private AbstractStateBackend nonPartitionedStateBackend = null;", "modifier": "private", "type": "AbstractStateBackend", "declarator": "nonPartitionedStateBackend = null", "var_name": "nonPartitionedStateBackend"}], "methods": [{"identifier": "DbStateBackend", "parameters": "(DbBackendConfig backendConfig)", "modifiers": "public", "return": "", "signature": " DbStateBackend(DbBackendConfig backendConfig)", "full_signature": "public  DbStateBackend(DbBackendConfig backendConfig)", "class_method_signature": "DbStateBackend.DbStateBackend(DbBackendConfig backendConfig)", "testcase": false, "constructor": true}, {"identifier": "DbStateBackend", "parameters": "(DbBackendConfig backendConfig, AbstractStateBackend backend)", "modifiers": "public", "return": "", "signature": " DbStateBackend(DbBackendConfig backendConfig, AbstractStateBackend backend)", "full_signature": "public  DbStateBackend(DbBackendConfig backendConfig, AbstractStateBackend backend)", "class_method_signature": "DbStateBackend.DbStateBackend(DbBackendConfig backendConfig, AbstractStateBackend backend)", "testcase": false, "constructor": true}, {"identifier": "getConnections", "parameters": "()", "modifiers": "public", "return": "ShardedConnection", "signature": "ShardedConnection getConnections()", "full_signature": "public ShardedConnection getConnections()", "class_method_signature": "DbStateBackend.getConnections()", "testcase": false, "constructor": false}, {"identifier": "isInitialized", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isInitialized()", "full_signature": "public boolean isInitialized()", "class_method_signature": "DbStateBackend.isInitialized()", "testcase": false, "constructor": false}, {"identifier": "getEnvironment", "parameters": "()", "modifiers": "public", "return": "Environment", "signature": "Environment getEnvironment()", "full_signature": "public Environment getEnvironment()", "class_method_signature": "DbStateBackend.getEnvironment()", "testcase": false, "constructor": false}, {"identifier": "getConfiguration", "parameters": "()", "modifiers": "public", "return": "DbBackendConfig", "signature": "DbBackendConfig getConfiguration()", "full_signature": "public DbBackendConfig getConfiguration()", "class_method_signature": "DbStateBackend.getConfiguration()", "testcase": false, "constructor": false}, {"identifier": "checkpointStateSerializable", "parameters": "(final S state, final long checkpointID,\n\t\t\tfinal long timestamp)", "modifiers": "@Override public", "return": "StateHandle<S>", "signature": "StateHandle<S> checkpointStateSerializable(final S state, final long checkpointID,\n\t\t\tfinal long timestamp)", "full_signature": "@Override public StateHandle<S> checkpointStateSerializable(final S state, final long checkpointID,\n\t\t\tfinal long timestamp)", "class_method_signature": "DbStateBackend.checkpointStateSerializable(final S state, final long checkpointID,\n\t\t\tfinal long timestamp)", "testcase": false, "constructor": false}, {"identifier": "createCheckpointStateOutputStream", "parameters": "(long checkpointID, long timestamp)", "modifiers": "@Override public", "return": "CheckpointStateOutputStream", "signature": "CheckpointStateOutputStream createCheckpointStateOutputStream(long checkpointID, long timestamp)", "full_signature": "@Override public CheckpointStateOutputStream createCheckpointStateOutputStream(long checkpointID, long timestamp)", "class_method_signature": "DbStateBackend.createCheckpointStateOutputStream(long checkpointID, long timestamp)", "testcase": false, "constructor": false}, {"identifier": "createValueState", "parameters": "(TypeSerializer<N> namespaceSerializer,\n\t\tValueStateDescriptor<T> stateDesc)", "modifiers": "@Override protected", "return": "ValueState<T>", "signature": "ValueState<T> createValueState(TypeSerializer<N> namespaceSerializer,\n\t\tValueStateDescriptor<T> stateDesc)", "full_signature": "@Override protected ValueState<T> createValueState(TypeSerializer<N> namespaceSerializer,\n\t\tValueStateDescriptor<T> stateDesc)", "class_method_signature": "DbStateBackend.createValueState(TypeSerializer<N> namespaceSerializer,\n\t\tValueStateDescriptor<T> stateDesc)", "testcase": false, "constructor": false}, {"identifier": "createListState", "parameters": "(TypeSerializer<N> namespaceSerializer,\n\t\tListStateDescriptor<T> stateDesc)", "modifiers": "@Override protected", "return": "ListState<T>", "signature": "ListState<T> createListState(TypeSerializer<N> namespaceSerializer,\n\t\tListStateDescriptor<T> stateDesc)", "full_signature": "@Override protected ListState<T> createListState(TypeSerializer<N> namespaceSerializer,\n\t\tListStateDescriptor<T> stateDesc)", "class_method_signature": "DbStateBackend.createListState(TypeSerializer<N> namespaceSerializer,\n\t\tListStateDescriptor<T> stateDesc)", "testcase": false, "constructor": false}, {"identifier": "createReducingState", "parameters": "(TypeSerializer<N> namespaceSerializer,\n\t\tReducingStateDescriptor<T> stateDesc)", "modifiers": "@Override @SuppressWarnings(\"unchecked\") protected", "return": "ReducingState<T>", "signature": "ReducingState<T> createReducingState(TypeSerializer<N> namespaceSerializer,\n\t\tReducingStateDescriptor<T> stateDesc)", "full_signature": "@Override @SuppressWarnings(\"unchecked\") protected ReducingState<T> createReducingState(TypeSerializer<N> namespaceSerializer,\n\t\tReducingStateDescriptor<T> stateDesc)", "class_method_signature": "DbStateBackend.createReducingState(TypeSerializer<N> namespaceSerializer,\n\t\tReducingStateDescriptor<T> stateDesc)", "testcase": false, "constructor": false}, {"identifier": "createFoldingState", "parameters": "(TypeSerializer<N> namespaceSerializer,\n\t\t\tFoldingStateDescriptor<T, ACC> stateDesc)", "modifiers": "@Override protected", "return": "FoldingState<T, ACC>", "signature": "FoldingState<T, ACC> createFoldingState(TypeSerializer<N> namespaceSerializer,\n\t\t\tFoldingStateDescriptor<T, ACC> stateDesc)", "full_signature": "@Override protected FoldingState<T, ACC> createFoldingState(TypeSerializer<N> namespaceSerializer,\n\t\t\tFoldingStateDescriptor<T, ACC> stateDesc)", "class_method_signature": "DbStateBackend.createFoldingState(TypeSerializer<N> namespaceSerializer,\n\t\t\tFoldingStateDescriptor<T, ACC> stateDesc)", "testcase": false, "constructor": false}, {"identifier": "initializeForJob", "parameters": "(final Environment env,\n\t\tString operatorIdentifier,\n\t\tTypeSerializer<?> keySerializer)", "modifiers": "@Override public", "return": "void", "signature": "void initializeForJob(final Environment env,\n\t\tString operatorIdentifier,\n\t\tTypeSerializer<?> keySerializer)", "full_signature": "@Override public void initializeForJob(final Environment env,\n\t\tString operatorIdentifier,\n\t\tTypeSerializer<?> keySerializer)", "class_method_signature": "DbStateBackend.initializeForJob(final Environment env,\n\t\tString operatorIdentifier,\n\t\tTypeSerializer<?> keySerializer)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "DbStateBackend.close()", "testcase": false, "constructor": false}, {"identifier": "disposeAllStateForCurrentJob", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void disposeAllStateForCurrentJob()", "full_signature": "@Override public void disposeAllStateForCurrentJob()", "class_method_signature": "DbStateBackend.disposeAllStateForCurrentJob()", "testcase": false, "constructor": false}], "file": "flink-contrib/flink-streaming-contrib/src/main/java/org/apache/flink/contrib/streaming/state/DbStateBackend.java"}, "focal_method": {"identifier": "initializeForJob", "parameters": "(final Environment env,\n\t\tString operatorIdentifier,\n\t\tTypeSerializer<?> keySerializer)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void initializeForJob(final Environment env,\n\t\tString operatorIdentifier,\n\t\tTypeSerializer<?> keySerializer) throws Exception {\n\t\tsuper.initializeForJob(env, operatorIdentifier, keySerializer);\n\n\t\tthis.operatorIdentifier = operatorIdentifier;\n\n\t\tthis.rnd = new Random();\n\t\tthis.env = env;\n\t\tthis.jobId = env.getJobID().toString().substring(0, 16);\n\n\t\tconnections = dbConfig.createShardedConnection();\n\n\t\t// We want the most light-weight transaction isolation level as we don't\n\t\t// have conflicting reads/writes. We just want to be able to roll back\n\t\t// batch inserts for k-v snapshots. This requirement might be removed in\n\t\t// the future.\n\t\tconnections.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n\n\t\t// If we have a different backend for non-partitioned states we\n\t\t// initialize that, otherwise create tables for storing the checkpoints.\n\t\t//\n\t\t// Currently all non-partitioned states are written to the first\n\t\t// database shard\n\t\tif (nonPartitionedStateBackend == null) {\n\t\t\tinsertStatement = retry(new Callable<PreparedStatement>() {\n\t\t\t\tpublic PreparedStatement call() throws SQLException {\n\t\t\t\t\tdbAdapter.createCheckpointsTable(jobId, getConnections().getFirst());\n\t\t\t\t\treturn dbAdapter.prepareCheckpointInsert(jobId,\n\t\t\t\t\t\t\tgetConnections().getFirst());\n\t\t\t\t}\n\t\t\t}, numSqlRetries, sqlRetrySleep);\n\t\t} else {\n\t\t\tnonPartitionedStateBackend.initializeForJob(env, operatorIdentifier, keySerializer);\n\t\t}\n\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"Database state backend successfully initialized\");\n\t\t}\n\t}", "signature": "void initializeForJob(final Environment env,\n\t\tString operatorIdentifier,\n\t\tTypeSerializer<?> keySerializer)", "full_signature": "@Override public void initializeForJob(final Environment env,\n\t\tString operatorIdentifier,\n\t\tTypeSerializer<?> keySerializer)", "class_method_signature": "DbStateBackend.initializeForJob(final Environment env,\n\t\tString operatorIdentifier,\n\t\tTypeSerializer<?> keySerializer)", "testcase": false, "constructor": false, "invocations": ["initializeForJob", "substring", "toString", "getJobID", "createShardedConnection", "setTransactionIsolation", "retry", "createCheckpointsTable", "getFirst", "getConnections", "prepareCheckpointInsert", "getFirst", "getConnections", "initializeForJob", "isDebugEnabled", "debug"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}