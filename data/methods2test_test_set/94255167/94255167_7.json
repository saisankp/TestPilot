{"test_class": {"identifier": "TextInstructionsTest", "superclass": "extends BaseTest", "interfaces": "", "fields": [{"original_string": "@Rule\n  public ExpectedException thrown = ExpectedException.none();", "modifier": "@Rule\n  public", "type": "ExpectedException", "declarator": "thrown = ExpectedException.none()", "var_name": "thrown"}], "file": "osrm-text-instructions/libjava-osrm-instructions/src/test/java/org/project_osrm/instructions/TextInstructionsTest.java"}, "test_case": {"identifier": "testFixturesMatchGeneratedInstructions", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testFixturesMatchGeneratedInstructions() throws IOException {\n    for (String fixture : TextInstructionsFixtures.FIXTURES) {\n      String body = loadJsonFixture(fixture);\n      FixtureModel model = new Gson().fromJson(body, FixtureModel.class);\n      for (Object entry : model.getInstructions().entrySet()) {\n        Map.Entry pair = (Map.Entry) entry;\n        String language = (String) pair.getKey();\n        String compiled = (String) pair.getValue();\n        assertEquals(compiled, new TextInstructions(language, \"v5\").compile(model.getStep()));\n      }\n    }\n  }", "signature": "void testFixturesMatchGeneratedInstructions()", "full_signature": "@Test public void testFixturesMatchGeneratedInstructions()", "class_method_signature": "TextInstructionsTest.testFixturesMatchGeneratedInstructions()", "testcase": true, "constructor": false, "invocations": ["loadJsonFixture", "fromJson", "entrySet", "getInstructions", "getKey", "getValue", "assertEquals", "compile", "getStep"]}, "focal_class": {"identifier": "TextInstructions", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = Logger.getLogger(TextInstructions.class.getSimpleName());", "modifier": "private static final", "type": "Logger", "declarator": "logger = Logger.getLogger(TextInstructions.class.getSimpleName())", "var_name": "logger"}, {"original_string": "private TokenizedInstructionHook tokenizedInstructionHook;", "modifier": "private", "type": "TokenizedInstructionHook", "declarator": "tokenizedInstructionHook", "var_name": "tokenizedInstructionHook"}, {"original_string": "private JsonObject rootObject;", "modifier": "private", "type": "JsonObject", "declarator": "rootObject", "var_name": "rootObject"}, {"original_string": "private JsonObject versionObject;", "modifier": "private", "type": "JsonObject", "declarator": "versionObject", "var_name": "versionObject"}], "methods": [{"identifier": "TextInstructions", "parameters": "(String language, String version)", "modifiers": "public", "return": "", "signature": " TextInstructions(String language, String version)", "full_signature": "public  TextInstructions(String language, String version)", "class_method_signature": "TextInstructions.TextInstructions(String language, String version)", "testcase": false, "constructor": true}, {"identifier": "getTokenizedInstructionHook", "parameters": "()", "modifiers": "public", "return": "TokenizedInstructionHook", "signature": "TokenizedInstructionHook getTokenizedInstructionHook()", "full_signature": "public TokenizedInstructionHook getTokenizedInstructionHook()", "class_method_signature": "TextInstructions.getTokenizedInstructionHook()", "testcase": false, "constructor": false}, {"identifier": "setTokenizedInstructionHook", "parameters": "(TokenizedInstructionHook tokenizedInstructionHook)", "modifiers": "public", "return": "void", "signature": "void setTokenizedInstructionHook(TokenizedInstructionHook tokenizedInstructionHook)", "full_signature": "public void setTokenizedInstructionHook(TokenizedInstructionHook tokenizedInstructionHook)", "class_method_signature": "TextInstructions.setTokenizedInstructionHook(TokenizedInstructionHook tokenizedInstructionHook)", "testcase": false, "constructor": false}, {"identifier": "getRootObject", "parameters": "()", "modifiers": "public", "return": "JsonObject", "signature": "JsonObject getRootObject()", "full_signature": "public JsonObject getRootObject()", "class_method_signature": "TextInstructions.getRootObject()", "testcase": false, "constructor": false}, {"identifier": "getVersionObject", "parameters": "()", "modifiers": "public", "return": "JsonObject", "signature": "JsonObject getVersionObject()", "full_signature": "public JsonObject getVersionObject()", "class_method_signature": "TextInstructions.getVersionObject()", "testcase": false, "constructor": false}, {"identifier": "capitalizeFirstLetter", "parameters": "(String text)", "modifiers": "public static", "return": "String", "signature": "String capitalizeFirstLetter(String text)", "full_signature": "public static String capitalizeFirstLetter(String text)", "class_method_signature": "TextInstructions.capitalizeFirstLetter(String text)", "testcase": false, "constructor": false}, {"identifier": "ordinalize", "parameters": "(Integer number)", "modifiers": "public", "return": "String", "signature": "String ordinalize(Integer number)", "full_signature": "public String ordinalize(Integer number)", "class_method_signature": "TextInstructions.ordinalize(Integer number)", "testcase": false, "constructor": false}, {"identifier": "directionFromDegree", "parameters": "(Double degree)", "modifiers": "public", "return": "String", "signature": "String directionFromDegree(Double degree)", "full_signature": "public String directionFromDegree(Double degree)", "class_method_signature": "TextInstructions.directionFromDegree(Double degree)", "testcase": false, "constructor": false}, {"identifier": "laneConfig", "parameters": "(LegStep step)", "modifiers": "public", "return": "String", "signature": "String laneConfig(LegStep step)", "full_signature": "public String laneConfig(LegStep step)", "class_method_signature": "TextInstructions.laneConfig(LegStep step)", "testcase": false, "constructor": false}, {"identifier": "compile", "parameters": "(LegStep step)", "modifiers": "public", "return": "String", "signature": "String compile(LegStep step)", "full_signature": "public String compile(LegStep step)", "class_method_signature": "TextInstructions.compile(LegStep step)", "testcase": false, "constructor": false}], "file": "osrm-text-instructions/libjava-osrm-instructions/src/main/java/org/project_osrm/instructions/TextInstructions.java"}, "focal_method": {"identifier": "compile", "parameters": "(LegStep step)", "modifiers": "public", "return": "String", "body": "public String compile(LegStep step) {\n    if (step.getManeuver() == null) {\n      throw new RuntimeException(\"No step maneuver provided.\");\n    }\n\n    String type = step.getManeuver().getType();\n    String modifier = step.getManeuver().getModifier();\n    String mode = step.getMode();\n\n    if (TextUtils.isEmpty(type)) {\n      throw new RuntimeException(\"Missing step maneuver type.\");\n    }\n\n    if (!type.equals(\"depart\") && !type.equals(\"arrive\") && TextUtils.isEmpty(modifier)) {\n      throw new RuntimeException(\"Missing step maneuver modifier.\");\n    }\n\n    if (getVersionObject().getAsJsonObject(type) == null) {\n      // Log for debugging\n      logger.log(Level.FINE, \"Encountered unknown instruction type: \" + type);\n\n      // OSRM specification assumes turn types can be added without\n      // major version changes. Unknown types are to be treated as\n      // type `turn` by clients\n      type = \"turn\";\n    }\n\n    // Use special instructions if available, otherwise `defaultinstruction`\n    JsonObject instructionObject;\n    JsonObject modeValue = getVersionObject().getAsJsonObject(\"modes\").getAsJsonObject(mode);\n    if (modeValue != null) {\n      instructionObject = modeValue;\n    } else {\n      JsonObject modifierValue = getVersionObject().getAsJsonObject(type).getAsJsonObject(modifier);\n      instructionObject = modifierValue == null\n        ? getVersionObject().getAsJsonObject(type).getAsJsonObject(\"default\")\n        : modifierValue;\n    }\n\n    // Special case handling\n    JsonPrimitive laneInstruction = null;\n    switch (type) {\n      case \"use lane\":\n        laneInstruction = getVersionObject().getAsJsonObject(\"constants\")\n          .getAsJsonObject(\"lanes\").getAsJsonPrimitive(laneConfig(step));\n        if (laneInstruction == null) {\n          // If the lane combination is not found, default to continue straight\n          instructionObject = getVersionObject().getAsJsonObject(\"use lane\")\n            .getAsJsonObject(\"no_lanes\");\n        }\n        break;\n      case \"rotary\":\n      case \"roundabout\":\n        if (!TextUtils.isEmpty(step.getRotaryName())\n          && step.getManeuver().getExit() != null\n          && instructionObject.getAsJsonObject(\"name_exit\") != null) {\n          instructionObject = instructionObject.getAsJsonObject(\"name_exit\");\n        } else if (step.getRotaryName() != null && instructionObject.getAsJsonObject(\"name\") != null) {\n          instructionObject = instructionObject.getAsJsonObject(\"name\");\n        } else if (step.getManeuver().getExit() != null && instructionObject.getAsJsonObject(\"exit\") != null) {\n          instructionObject = instructionObject.getAsJsonObject(\"exit\");\n        } else {\n          instructionObject = instructionObject.getAsJsonObject(\"default\");\n        }\n        break;\n      default:\n        // NOOP, since no special logic for that type\n    }\n\n    // Decide way_name with special handling for name and ref\n    String wayName;\n    String name = TextUtils.isEmpty(step.getName()) ? \"\" : step.getName();\n    String ref = TextUtils.isEmpty(step.getRef()) ? \"\" : step.getRef().split(\";\")[0];\n\n    // Remove hacks from Mapbox Directions mixing ref into name\n    if (name.equals(step.getRef())) {\n      // if both are the same we assume that there used to be an empty name, with the ref being filled in for it\n      // we only need to retain the ref then\n      name = \"\";\n    }\n    name = name.replace(\" (\" + step.getRef() + \")\", \"\");\n\n    if (!TextUtils.isEmpty(name) && !TextUtils.isEmpty(ref) && !name.equals(ref)) {\n      wayName = name + \" (\" + ref + \")\";\n    } else if (TextUtils.isEmpty(name) && !TextUtils.isEmpty(ref)) {\n      wayName = ref;\n    } else {\n      wayName = name;\n    }\n\n    // Decide which instruction string to use\n    // Destination takes precedence over name\n    String instruction;\n    if (!TextUtils.isEmpty(step.getDestinations())\n      && instructionObject.getAsJsonPrimitive(\"destination\") != null) {\n      instruction = instructionObject.getAsJsonPrimitive(\"destination\").getAsString();\n    } else if (!TextUtils.isEmpty(wayName)\n      && instructionObject.getAsJsonPrimitive(\"name\") != null) {\n      instruction = instructionObject.getAsJsonPrimitive(\"name\").getAsString();\n    } else {\n      instruction = instructionObject.getAsJsonPrimitive(\"default\").getAsString();\n    }\n\n    if (getTokenizedInstructionHook() != null) {\n      instruction = getTokenizedInstructionHook().change(instruction);\n    }\n\n    // Replace tokens\n    // NOOP if they don't exist\n    String nthWaypoint = \"\"; // TODO, add correct waypoint counting\n    JsonPrimitive modifierValue =\n      getVersionObject().getAsJsonObject(\"constants\").getAsJsonObject(\"modifier\").getAsJsonPrimitive(modifier);\n    instruction = instruction\n      .replace(\"{way_name}\", wayName)\n      .replace(\"{destination}\", TextUtils.isEmpty(step.getDestinations()) ? \"\" : step.getDestinations().split(\",\")[0])\n      .replace(\"{exit_number}\",\n        step.getManeuver().getExit() == null ? ordinalize(1) : ordinalize(step.getManeuver().getExit()))\n      .replace(\"{rotary_name}\", TextUtils.isEmpty(step.getRotaryName()) ? \"\" : step.getRotaryName())\n      .replace(\"{lane_instruction}\", laneInstruction == null ? \"\" : laneInstruction.getAsString())\n      .replace(\"{modifier}\", modifierValue == null ? \"\" : modifierValue.getAsString())\n      .replace(\"{direction}\", directionFromDegree(step.getManeuver().getBearingAfter()))\n      .replace(\"{nth}\", nthWaypoint)\n      .replaceAll(\"\\\\s+\", \" \"); // remove excess spaces\n\n    if (getRootObject().getAsJsonObject(\"meta\").getAsJsonPrimitive(\"capitalizeFirstLetter\").getAsBoolean()) {\n      instruction = capitalizeFirstLetter(instruction);\n    }\n\n    return instruction;\n  }", "signature": "String compile(LegStep step)", "full_signature": "public String compile(LegStep step)", "class_method_signature": "TextInstructions.compile(LegStep step)", "testcase": false, "constructor": false, "invocations": ["getManeuver", "getType", "getManeuver", "getModifier", "getManeuver", "getMode", "isEmpty", "equals", "equals", "isEmpty", "getAsJsonObject", "getVersionObject", "log", "getAsJsonObject", "getAsJsonObject", "getVersionObject", "getAsJsonObject", "getAsJsonObject", "getVersionObject", "getAsJsonObject", "getAsJsonObject", "getVersionObject", "getAsJsonPrimitive", "getAsJsonObject", "getAsJsonObject", "getVersionObject", "laneConfig", "getAsJsonObject", "getAsJsonObject", "getVersionObject", "isEmpty", "getRotaryName", "getExit", "getManeuver", "getAsJsonObject", "getAsJsonObject", "getRotaryName", "getAsJsonObject", "getAsJsonObject", "getExit", "getManeuver", "getAsJsonObject", "getAsJsonObject", "getAsJsonObject", "isEmpty", "getName", "getName", "isEmpty", "getRef", "split", "getRef", "equals", "getRef", "replace", "getRef", "isEmpty", "isEmpty", "equals", "isEmpty", "isEmpty", "isEmpty", "getDestinations", "getAsJsonPrimitive", "getAsString", "getAsJsonPrimitive", "isEmpty", "getAsJsonPrimitive", "getAsString", "getAsJsonPrimitive", "getAsString", "getAsJsonPrimitive", "getTokenizedInstructionHook", "change", "getTokenizedInstructionHook", "getAsJsonPrimitive", "getAsJsonObject", "getAsJsonObject", "getVersionObject", "replaceAll", "replace", "replace", "replace", "replace", "replace", "replace", "replace", "replace", "isEmpty", "getDestinations", "split", "getDestinations", "getExit", "getManeuver", "ordinalize", "ordinalize", "getExit", "getManeuver", "isEmpty", "getRotaryName", "getRotaryName", "getAsString", "getAsString", "directionFromDegree", "getBearingAfter", "getManeuver", "getAsBoolean", "getAsJsonPrimitive", "getAsJsonObject", "getRootObject", "capitalizeFirstLetter"]}, "repository": {"repo_id": 94255167, "url": "https://github.com/Project-OSRM/osrm-text-instructions.java", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 9, "size": 255, "license": "licensed"}}