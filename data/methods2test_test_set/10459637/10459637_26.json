{"test_class": {"identifier": "IPv4Test", "superclass": "", "interfaces": "", "fields": [], "file": "network-level/fl-ho-nl/src/test/java/net/floodlightcontroller/packet/IPv4Test.java"}, "test_case": {"identifier": "testDeserialize", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDeserialize() {\n        // A real TLSv1 packet\n        byte[] pktSerialized = new byte[] { 0x45, 0x00,\n                0x00, 0x2e, 0x41, (byte) 0xbe, 0x40, 0x00, 0x40, 0x06,\n                (byte) 0xd4, (byte) 0xf0, (byte) 0xc0, (byte) 0xa8, 0x02, (byte) 0xdb, (byte) 0xd0, 0x55,\n                (byte) 0x90, 0x42, (byte) 0xd5, 0x48, 0x01, (byte) 0xbb, (byte) 0xe3, 0x50,\n                (byte) 0xb2, 0x2f, (byte) 0xfc, (byte) 0xf8, (byte) 0xa8, 0x2c, 0x50, 0x18,\n                (byte) 0xff, (byte) 0xff, 0x24, 0x3c, 0x00, 0x00, 0x14, 0x03,\n                0x01, 0x00, 0x01, 0x01\n        };\n        IPv4 packet = new IPv4();\n        packet.deserialize(pktSerialized, 0, pktSerialized.length);\n        byte[] pktSerialized1 = packet.serialize();\n        assertTrue(Arrays.equals(pktSerialized, pktSerialized1));\n    }", "signature": "void testDeserialize()", "full_signature": "@Test public void testDeserialize()", "class_method_signature": "IPv4Test.testDeserialize()", "testcase": true, "constructor": false, "invocations": ["deserialize", "serialize", "assertTrue", "equals"]}, "focal_class": {"identifier": "IPv4", "superclass": "extends BasePacket", "interfaces": "", "fields": [{"original_string": "public static final byte PROTOCOL_ICMP = 0x1;", "modifier": "public static final", "type": "byte", "declarator": "PROTOCOL_ICMP = 0x1", "var_name": "PROTOCOL_ICMP"}, {"original_string": "public static final byte PROTOCOL_TCP = 0x6;", "modifier": "public static final", "type": "byte", "declarator": "PROTOCOL_TCP = 0x6", "var_name": "PROTOCOL_TCP"}, {"original_string": "public static final byte PROTOCOL_UDP = 0x11;", "modifier": "public static final", "type": "byte", "declarator": "PROTOCOL_UDP = 0x11", "var_name": "PROTOCOL_UDP"}, {"original_string": "public static Map<Byte, Class<? extends IPacket>> protocolClassMap;", "modifier": "public static", "type": "Map<Byte, Class<? extends IPacket>>", "declarator": "protocolClassMap", "var_name": "protocolClassMap"}, {"original_string": "protected byte version;", "modifier": "protected", "type": "byte", "declarator": "version", "var_name": "version"}, {"original_string": "protected byte headerLength;", "modifier": "protected", "type": "byte", "declarator": "headerLength", "var_name": "headerLength"}, {"original_string": "protected byte diffServ;", "modifier": "protected", "type": "byte", "declarator": "diffServ", "var_name": "diffServ"}, {"original_string": "protected short totalLength;", "modifier": "protected", "type": "short", "declarator": "totalLength", "var_name": "totalLength"}, {"original_string": "protected short identification;", "modifier": "protected", "type": "short", "declarator": "identification", "var_name": "identification"}, {"original_string": "protected byte flags;", "modifier": "protected", "type": "byte", "declarator": "flags", "var_name": "flags"}, {"original_string": "protected short fragmentOffset;", "modifier": "protected", "type": "short", "declarator": "fragmentOffset", "var_name": "fragmentOffset"}, {"original_string": "protected byte ttl;", "modifier": "protected", "type": "byte", "declarator": "ttl", "var_name": "ttl"}, {"original_string": "protected byte protocol;", "modifier": "protected", "type": "byte", "declarator": "protocol", "var_name": "protocol"}, {"original_string": "protected short checksum;", "modifier": "protected", "type": "short", "declarator": "checksum", "var_name": "checksum"}, {"original_string": "protected int sourceAddress;", "modifier": "protected", "type": "int", "declarator": "sourceAddress", "var_name": "sourceAddress"}, {"original_string": "protected int destinationAddress;", "modifier": "protected", "type": "int", "declarator": "destinationAddress", "var_name": "destinationAddress"}, {"original_string": "protected byte[] options;", "modifier": "protected", "type": "byte[]", "declarator": "options", "var_name": "options"}, {"original_string": "protected boolean isTruncated;", "modifier": "protected", "type": "boolean", "declarator": "isTruncated", "var_name": "isTruncated"}], "methods": [{"identifier": "IPv4", "parameters": "()", "modifiers": "public", "return": "", "signature": " IPv4()", "full_signature": "public  IPv4()", "class_method_signature": "IPv4.IPv4()", "testcase": false, "constructor": true}, {"identifier": "getVersion", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getVersion()", "full_signature": "public byte getVersion()", "class_method_signature": "IPv4.getVersion()", "testcase": false, "constructor": false}, {"identifier": "setVersion", "parameters": "(byte version)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setVersion(byte version)", "full_signature": "public IPv4 setVersion(byte version)", "class_method_signature": "IPv4.setVersion(byte version)", "testcase": false, "constructor": false}, {"identifier": "getHeaderLength", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getHeaderLength()", "full_signature": "public byte getHeaderLength()", "class_method_signature": "IPv4.getHeaderLength()", "testcase": false, "constructor": false}, {"identifier": "getDiffServ", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getDiffServ()", "full_signature": "public byte getDiffServ()", "class_method_signature": "IPv4.getDiffServ()", "testcase": false, "constructor": false}, {"identifier": "setDiffServ", "parameters": "(byte diffServ)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDiffServ(byte diffServ)", "full_signature": "public IPv4 setDiffServ(byte diffServ)", "class_method_signature": "IPv4.setDiffServ(byte diffServ)", "testcase": false, "constructor": false}, {"identifier": "getTotalLength", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getTotalLength()", "full_signature": "public short getTotalLength()", "class_method_signature": "IPv4.getTotalLength()", "testcase": false, "constructor": false}, {"identifier": "getIdentification", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getIdentification()", "full_signature": "public short getIdentification()", "class_method_signature": "IPv4.getIdentification()", "testcase": false, "constructor": false}, {"identifier": "isTruncated", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isTruncated()", "full_signature": "public boolean isTruncated()", "class_method_signature": "IPv4.isTruncated()", "testcase": false, "constructor": false}, {"identifier": "setTruncated", "parameters": "(boolean isTruncated)", "modifiers": "public", "return": "void", "signature": "void setTruncated(boolean isTruncated)", "full_signature": "public void setTruncated(boolean isTruncated)", "class_method_signature": "IPv4.setTruncated(boolean isTruncated)", "testcase": false, "constructor": false}, {"identifier": "setIdentification", "parameters": "(short identification)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setIdentification(short identification)", "full_signature": "public IPv4 setIdentification(short identification)", "class_method_signature": "IPv4.setIdentification(short identification)", "testcase": false, "constructor": false}, {"identifier": "getFlags", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getFlags()", "full_signature": "public byte getFlags()", "class_method_signature": "IPv4.getFlags()", "testcase": false, "constructor": false}, {"identifier": "setFlags", "parameters": "(byte flags)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setFlags(byte flags)", "full_signature": "public IPv4 setFlags(byte flags)", "class_method_signature": "IPv4.setFlags(byte flags)", "testcase": false, "constructor": false}, {"identifier": "getFragmentOffset", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getFragmentOffset()", "full_signature": "public short getFragmentOffset()", "class_method_signature": "IPv4.getFragmentOffset()", "testcase": false, "constructor": false}, {"identifier": "setFragmentOffset", "parameters": "(short fragmentOffset)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setFragmentOffset(short fragmentOffset)", "full_signature": "public IPv4 setFragmentOffset(short fragmentOffset)", "class_method_signature": "IPv4.setFragmentOffset(short fragmentOffset)", "testcase": false, "constructor": false}, {"identifier": "getTtl", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getTtl()", "full_signature": "public byte getTtl()", "class_method_signature": "IPv4.getTtl()", "testcase": false, "constructor": false}, {"identifier": "setTtl", "parameters": "(byte ttl)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setTtl(byte ttl)", "full_signature": "public IPv4 setTtl(byte ttl)", "class_method_signature": "IPv4.setTtl(byte ttl)", "testcase": false, "constructor": false}, {"identifier": "getProtocol", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getProtocol()", "full_signature": "public byte getProtocol()", "class_method_signature": "IPv4.getProtocol()", "testcase": false, "constructor": false}, {"identifier": "setProtocol", "parameters": "(byte protocol)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setProtocol(byte protocol)", "full_signature": "public IPv4 setProtocol(byte protocol)", "class_method_signature": "IPv4.setProtocol(byte protocol)", "testcase": false, "constructor": false}, {"identifier": "getChecksum", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getChecksum()", "full_signature": "public short getChecksum()", "class_method_signature": "IPv4.getChecksum()", "testcase": false, "constructor": false}, {"identifier": "setChecksum", "parameters": "(short checksum)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setChecksum(short checksum)", "full_signature": "public IPv4 setChecksum(short checksum)", "class_method_signature": "IPv4.setChecksum(short checksum)", "testcase": false, "constructor": false}, {"identifier": "resetChecksum", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void resetChecksum()", "full_signature": "@Override public void resetChecksum()", "class_method_signature": "IPv4.resetChecksum()", "testcase": false, "constructor": false}, {"identifier": "getSourceAddress", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getSourceAddress()", "full_signature": "public int getSourceAddress()", "class_method_signature": "IPv4.getSourceAddress()", "testcase": false, "constructor": false}, {"identifier": "setSourceAddress", "parameters": "(int sourceAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setSourceAddress(int sourceAddress)", "full_signature": "public IPv4 setSourceAddress(int sourceAddress)", "class_method_signature": "IPv4.setSourceAddress(int sourceAddress)", "testcase": false, "constructor": false}, {"identifier": "setSourceAddress", "parameters": "(String sourceAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setSourceAddress(String sourceAddress)", "full_signature": "public IPv4 setSourceAddress(String sourceAddress)", "class_method_signature": "IPv4.setSourceAddress(String sourceAddress)", "testcase": false, "constructor": false}, {"identifier": "getDestinationAddress", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getDestinationAddress()", "full_signature": "public int getDestinationAddress()", "class_method_signature": "IPv4.getDestinationAddress()", "testcase": false, "constructor": false}, {"identifier": "setDestinationAddress", "parameters": "(int destinationAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDestinationAddress(int destinationAddress)", "full_signature": "public IPv4 setDestinationAddress(int destinationAddress)", "class_method_signature": "IPv4.setDestinationAddress(int destinationAddress)", "testcase": false, "constructor": false}, {"identifier": "setDestinationAddress", "parameters": "(String destinationAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDestinationAddress(String destinationAddress)", "full_signature": "public IPv4 setDestinationAddress(String destinationAddress)", "class_method_signature": "IPv4.setDestinationAddress(String destinationAddress)", "testcase": false, "constructor": false}, {"identifier": "getOptions", "parameters": "()", "modifiers": "public", "return": "byte[]", "signature": "byte[] getOptions()", "full_signature": "public byte[] getOptions()", "class_method_signature": "IPv4.getOptions()", "testcase": false, "constructor": false}, {"identifier": "setOptions", "parameters": "(byte[] options)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setOptions(byte[] options)", "full_signature": "public IPv4 setOptions(byte[] options)", "class_method_signature": "IPv4.setOptions(byte[] options)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "()", "modifiers": "public", "return": "byte[]", "signature": "byte[] serialize()", "full_signature": "public byte[] serialize()", "class_method_signature": "IPv4.serialize()", "testcase": false, "constructor": false}, {"identifier": "deserialize", "parameters": "(byte[] data, int offset, int length)", "modifiers": "@Override public", "return": "IPacket", "signature": "IPacket deserialize(byte[] data, int offset, int length)", "full_signature": "@Override public IPacket deserialize(byte[] data, int offset, int length)", "class_method_signature": "IPv4.deserialize(byte[] data, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "toIPv4Address", "parameters": "(String ipAddress)", "modifiers": "public static", "return": "int", "signature": "int toIPv4Address(String ipAddress)", "full_signature": "public static int toIPv4Address(String ipAddress)", "class_method_signature": "IPv4.toIPv4Address(String ipAddress)", "testcase": false, "constructor": false}, {"identifier": "toIPv4Address", "parameters": "(byte[] ipAddress)", "modifiers": "public static", "return": "int", "signature": "int toIPv4Address(byte[] ipAddress)", "full_signature": "public static int toIPv4Address(byte[] ipAddress)", "class_method_signature": "IPv4.toIPv4Address(byte[] ipAddress)", "testcase": false, "constructor": false}, {"identifier": "fromIPv4Address", "parameters": "(int ipAddress)", "modifiers": "public static", "return": "String", "signature": "String fromIPv4Address(int ipAddress)", "full_signature": "public static String fromIPv4Address(int ipAddress)", "class_method_signature": "IPv4.fromIPv4Address(int ipAddress)", "testcase": false, "constructor": false}, {"identifier": "fromIPv4AddressCollection", "parameters": "(Collection<Integer> ipAddresses)", "modifiers": "public static", "return": "String", "signature": "String fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "full_signature": "public static String fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "class_method_signature": "IPv4.fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "testcase": false, "constructor": false}, {"identifier": "toIPv4AddressBytes", "parameters": "(String ipAddress)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] toIPv4AddressBytes(String ipAddress)", "full_signature": "public static byte[] toIPv4AddressBytes(String ipAddress)", "class_method_signature": "IPv4.toIPv4AddressBytes(String ipAddress)", "testcase": false, "constructor": false}, {"identifier": "toIPv4AddressBytes", "parameters": "(int ipAddress)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] toIPv4AddressBytes(int ipAddress)", "full_signature": "public static byte[] toIPv4AddressBytes(int ipAddress)", "class_method_signature": "IPv4.toIPv4AddressBytes(int ipAddress)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "IPv4.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "IPv4.equals(Object obj)", "testcase": false, "constructor": false}], "file": "network-level/fl-ho-nl/src/main/java/net/floodlightcontroller/packet/IPv4.java"}, "focal_method": {"identifier": "deserialize", "parameters": "(byte[] data, int offset, int length)", "modifiers": "@Override public", "return": "IPacket", "body": "@Override\n    public IPacket deserialize(byte[] data, int offset, int length) {\n        ByteBuffer bb = ByteBuffer.wrap(data, offset, length);\n        short sscratch;\n\n        this.version = bb.get();\n        this.headerLength = (byte) (this.version & 0xf);\n        this.version = (byte) ((this.version >> 4) & 0xf);\n        this.diffServ = bb.get();\n        this.totalLength = bb.getShort();\n        this.identification = bb.getShort();\n        sscratch = bb.getShort();\n        this.flags = (byte) ((sscratch >> 13) & 0x7);\n        this.fragmentOffset = (short) (sscratch & 0x1fff);\n        this.ttl = bb.get();\n        this.protocol = bb.get();\n        this.checksum = bb.getShort();\n        this.sourceAddress = bb.getInt();\n        this.destinationAddress = bb.getInt();\n\n        if (this.headerLength > 5) {\n            int optionsLength = (this.headerLength - 5) * 4;\n            this.options = new byte[optionsLength];\n            bb.get(this.options);\n        }\n\n        IPacket payload;\n        if (IPv4.protocolClassMap.containsKey(this.protocol)) {\n            Class<? extends IPacket> clazz = IPv4.protocolClassMap.get(this.protocol);\n            try {\n                payload = clazz.newInstance();\n            } catch (Exception e) {\n                throw new RuntimeException(\"Error parsing payload for IPv4 packet\", e);\n            }\n        } else {\n            payload = new Data();\n        }\n        this.payload = payload.deserialize(data, bb.position(), bb.limit()-bb.position());\n        this.payload.setParent(this);\n\n        if (this.totalLength != length)\n            this.isTruncated = true;\n        else\n            this.isTruncated = false;\n\n        return this;\n    }", "signature": "IPacket deserialize(byte[] data, int offset, int length)", "full_signature": "@Override public IPacket deserialize(byte[] data, int offset, int length)", "class_method_signature": "IPv4.deserialize(byte[] data, int offset, int length)", "testcase": false, "constructor": false, "invocations": ["wrap", "get", "get", "getShort", "getShort", "getShort", "get", "get", "getShort", "getInt", "getInt", "get", "containsKey", "get", "newInstance", "deserialize", "position", "limit", "position", "setParent"]}, "repository": {"repo_id": 10459637, "url": "https://github.com/rizard/geni-openflow-vertical-handover", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 7, "size": 33971, "license": "licensed"}}