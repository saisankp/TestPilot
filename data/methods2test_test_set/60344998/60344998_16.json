{"test_class": {"identifier": "NakadiReaderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String EVENT_NAME = \"some-event\";", "modifier": "private static final", "type": "String", "declarator": "EVENT_NAME = \"some-event\"", "var_name": "EVENT_NAME"}, {"original_string": "private final URI uri = java.net.URI.create(\"http://example.com/events\");", "modifier": "private final", "type": "URI", "declarator": "uri = java.net.URI.create(\"http://example.com/events\")", "var_name": "uri"}, {"original_string": "private final ObjectMapper objectMapper = new ObjectMapper();", "modifier": "private final", "type": "ObjectMapper", "declarator": "objectMapper = new ObjectMapper()", "var_name": "objectMapper"}, {"original_string": "private final CursorManager cursorManager = mock(CursorManager.class);", "modifier": "private final", "type": "CursorManager", "declarator": "cursorManager = mock(CursorManager.class)", "var_name": "cursorManager"}, {"original_string": "private final RequestFactory RequestFactory = mock(RequestFactory.class);", "modifier": "private final", "type": "RequestFactory", "declarator": "RequestFactory = mock(RequestFactory.class)", "var_name": "RequestFactory"}, {"original_string": "@SuppressWarnings(\"unchecked\")\n    private final Listener<SomeEvent> listener = (Listener<SomeEvent>)mock(Listener.class);", "modifier": "@SuppressWarnings(\"unchecked\")\n    private final", "type": "Listener<SomeEvent>", "declarator": "listener = (Listener<SomeEvent>)mock(Listener.class)", "var_name": "listener"}, {"original_string": "@Rule\n    public final ExpectedException expectedException = ExpectedException.none();", "modifier": "@Rule\n    public final", "type": "ExpectedException", "declarator": "expectedException = ExpectedException.none()", "var_name": "expectedException"}], "file": "fahrschein/src/test/java/org/zalando/fahrschein/NakadiReaderTest.java"}, "test_case": {"identifier": "shouldRetryConnectionAfterExceptionDuringReconnection", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldRetryConnectionAfterExceptionDuringReconnection() throws IOException, InterruptedException, BackoffException {\n        final Response response = mock(Response.class);\n        final ByteArrayInputStream initialInputStream = new ByteArrayInputStream(\"{\\\"cursor\\\":{\\\"partition\\\":\\\"0\\\",\\\"offset\\\":\\\"0\\\"}}\".getBytes(\"utf-8\"));\n        when(response.getBody()).thenReturn(initialInputStream);\n\n        final Request request = mock(Request.class);\n        when(request.execute()).thenReturn(response).thenThrow(new IOException(\"Reconnection failed\")).thenReturn(response).thenThrow(new IOException(\"Reconnection failed on second attempt\"));\n\n        when(RequestFactory.createRequest(uri, \"GET\")).thenReturn(request);\n\n        final ExponentialBackoffStrategy backoffStrategy = new EqualJitterBackoffStrategy(1, 1, 2, 4);\n        final NakadiReader<SomeEvent> nakadiReader = new NakadiReader<>(uri, RequestFactory, backoffStrategy, cursorManager, objectMapper, Collections.singleton(EVENT_NAME), Optional.empty(), Optional.empty(), SomeEvent.class, listener);\n\n        expectedException.expect(BackoffException.class);\n        expectedException.expect(ComposeMatchers.hasFeature(BackoffException::getRetries, equalTo(4)));\n        expectedException.expectCause(instanceOf(IOException.class));\n        expectedException.expectCause(ComposeMatchers.hasFeature(\"message\", Exception::getMessage, Matchers.containsString(\"Reconnection failed on second attempt\")));\n\n        nakadiReader.runInternal();\n    }", "signature": "void shouldRetryConnectionAfterExceptionDuringReconnection()", "full_signature": "@Test public void shouldRetryConnectionAfterExceptionDuringReconnection()", "class_method_signature": "NakadiReaderTest.shouldRetryConnectionAfterExceptionDuringReconnection()", "testcase": true, "constructor": false, "invocations": ["mock", "getBytes", "thenReturn", "when", "getBody", "mock", "thenThrow", "thenReturn", "thenThrow", "thenReturn", "when", "execute", "thenReturn", "when", "createRequest", "singleton", "empty", "empty", "expect", "expect", "hasFeature", "equalTo", "expectCause", "instanceOf", "expectCause", "hasFeature", "containsString", "runInternal"]}, "focal_class": {"identifier": "NakadiReader", "superclass": "", "interfaces": "implements IORunnable", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(NakadiReader.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(NakadiReader.class)", "var_name": "LOG"}, {"original_string": "private static final TypeReference<Collection<Cursor>> COLLECTION_OF_CURSORS = new TypeReference<Collection<Cursor>>() {\n    };", "modifier": "private static final", "type": "TypeReference<Collection<Cursor>>", "declarator": "COLLECTION_OF_CURSORS = new TypeReference<Collection<Cursor>>() {\n    }", "var_name": "COLLECTION_OF_CURSORS"}, {"original_string": "private final URI uri;", "modifier": "private final", "type": "URI", "declarator": "uri", "var_name": "uri"}, {"original_string": "private final RequestFactory requestFactory;", "modifier": "private final", "type": "RequestFactory", "declarator": "requestFactory", "var_name": "requestFactory"}, {"original_string": "private final BackoffStrategy backoffStrategy;", "modifier": "private final", "type": "BackoffStrategy", "declarator": "backoffStrategy", "var_name": "backoffStrategy"}, {"original_string": "private final CursorManager cursorManager;", "modifier": "private final", "type": "CursorManager", "declarator": "cursorManager", "var_name": "cursorManager"}, {"original_string": "private final Set<String> eventNames;", "modifier": "private final", "type": "Set<String>", "declarator": "eventNames", "var_name": "eventNames"}, {"original_string": "private final Optional<Subscription> subscription;", "modifier": "private final", "type": "Optional<Subscription>", "declarator": "subscription", "var_name": "subscription"}, {"original_string": "private final Optional<Lock> lock;", "modifier": "private final", "type": "Optional<Lock>", "declarator": "lock", "var_name": "lock"}, {"original_string": "private final EventReader<T> eventReader;", "modifier": "private final", "type": "EventReader<T>", "declarator": "eventReader", "var_name": "eventReader"}, {"original_string": "private final Listener<T> listener;", "modifier": "private final", "type": "Listener<T>", "declarator": "listener", "var_name": "listener"}, {"original_string": "private final BatchHandler batchHandler;", "modifier": "private final", "type": "BatchHandler", "declarator": "batchHandler", "var_name": "batchHandler"}, {"original_string": "private final JsonFactory jsonFactory;", "modifier": "private final", "type": "JsonFactory", "declarator": "jsonFactory", "var_name": "jsonFactory"}, {"original_string": "private final ObjectWriter cursorHeaderWriter;", "modifier": "private final", "type": "ObjectWriter", "declarator": "cursorHeaderWriter", "var_name": "cursorHeaderWriter"}, {"original_string": "private final MetricsCollector metricsCollector;", "modifier": "private final", "type": "MetricsCollector", "declarator": "metricsCollector", "var_name": "metricsCollector"}], "methods": [{"identifier": "NakadiReader", "parameters": "(URI uri, RequestFactory requestFactory, BackoffStrategy backoffStrategy, CursorManager cursorManager, ObjectMapper objectMapper, Set<String> eventNames, Optional<Subscription> subscription, Optional<Lock> lock, Class<T> eventClass, Listener<T> listener)", "modifiers": "", "return": "", "signature": " NakadiReader(URI uri, RequestFactory requestFactory, BackoffStrategy backoffStrategy, CursorManager cursorManager, ObjectMapper objectMapper, Set<String> eventNames, Optional<Subscription> subscription, Optional<Lock> lock, Class<T> eventClass, Listener<T> listener)", "full_signature": "  NakadiReader(URI uri, RequestFactory requestFactory, BackoffStrategy backoffStrategy, CursorManager cursorManager, ObjectMapper objectMapper, Set<String> eventNames, Optional<Subscription> subscription, Optional<Lock> lock, Class<T> eventClass, Listener<T> listener)", "class_method_signature": "NakadiReader.NakadiReader(URI uri, RequestFactory requestFactory, BackoffStrategy backoffStrategy, CursorManager cursorManager, ObjectMapper objectMapper, Set<String> eventNames, Optional<Subscription> subscription, Optional<Lock> lock, Class<T> eventClass, Listener<T> listener)", "testcase": false, "constructor": true}, {"identifier": "NakadiReader", "parameters": "(URI uri, RequestFactory requestFactory, BackoffStrategy backoffStrategy, CursorManager cursorManager, Set<String> eventNames, Optional<Subscription> subscription, Optional<Lock> lock, EventReader<T> eventReader, Listener<T> listener, BatchHandler batchHandler, final MetricsCollector metricsCollector)", "modifiers": "", "return": "", "signature": " NakadiReader(URI uri, RequestFactory requestFactory, BackoffStrategy backoffStrategy, CursorManager cursorManager, Set<String> eventNames, Optional<Subscription> subscription, Optional<Lock> lock, EventReader<T> eventReader, Listener<T> listener, BatchHandler batchHandler, final MetricsCollector metricsCollector)", "full_signature": "  NakadiReader(URI uri, RequestFactory requestFactory, BackoffStrategy backoffStrategy, CursorManager cursorManager, Set<String> eventNames, Optional<Subscription> subscription, Optional<Lock> lock, EventReader<T> eventReader, Listener<T> listener, BatchHandler batchHandler, final MetricsCollector metricsCollector)", "class_method_signature": "NakadiReader.NakadiReader(URI uri, RequestFactory requestFactory, BackoffStrategy backoffStrategy, CursorManager cursorManager, Set<String> eventNames, Optional<Subscription> subscription, Optional<Lock> lock, EventReader<T> eventReader, Listener<T> listener, BatchHandler batchHandler, final MetricsCollector metricsCollector)", "testcase": false, "constructor": true}, {"identifier": "getStreamId", "parameters": "(Response response)", "modifiers": "private static", "return": "Optional<String>", "signature": "Optional<String> getStreamId(Response response)", "full_signature": "private static Optional<String> getStreamId(Response response)", "class_method_signature": "NakadiReader.getStreamId(Response response)", "testcase": false, "constructor": false}, {"identifier": "openJsonInput", "parameters": "()", "modifiers": "private", "return": "JsonInput", "signature": "JsonInput openJsonInput()", "full_signature": "private JsonInput openJsonInput()", "class_method_signature": "NakadiReader.openJsonInput()", "testcase": false, "constructor": false}, {"identifier": "getCursorsHeader", "parameters": "()", "modifiers": "@Nullable private", "return": "String", "signature": "String getCursorsHeader()", "full_signature": "@Nullable private String getCursorsHeader()", "class_method_signature": "NakadiReader.getCursorsHeader()", "testcase": false, "constructor": false}, {"identifier": "getLockedCursors", "parameters": "()", "modifiers": "private", "return": "Collection<Cursor>", "signature": "Collection<Cursor> getLockedCursors()", "full_signature": "private Collection<Cursor> getLockedCursors()", "class_method_signature": "NakadiReader.getLockedCursors()", "testcase": false, "constructor": false}, {"identifier": "getCurrentEventName", "parameters": "(final Cursor cursor)", "modifiers": "private", "return": "String", "signature": "String getCurrentEventName(final Cursor cursor)", "full_signature": "private String getCurrentEventName(final Cursor cursor)", "class_method_signature": "NakadiReader.getCurrentEventName(final Cursor cursor)", "testcase": false, "constructor": false}, {"identifier": "processBatch", "parameters": "(final Batch<T> batch)", "modifiers": "private", "return": "void", "signature": "void processBatch(final Batch<T> batch)", "full_signature": "private void processBatch(final Batch<T> batch)", "class_method_signature": "NakadiReader.processBatch(final Batch<T> batch)", "testcase": false, "constructor": false}, {"identifier": "readCursor", "parameters": "(JsonParser jsonParser)", "modifiers": "private", "return": "Cursor", "signature": "Cursor readCursor(JsonParser jsonParser)", "full_signature": "private Cursor readCursor(JsonParser jsonParser)", "class_method_signature": "NakadiReader.readCursor(JsonParser jsonParser)", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "NakadiReader.run()", "testcase": false, "constructor": false}, {"identifier": "runInternal", "parameters": "()", "modifiers": "", "return": "void", "signature": "void runInternal()", "full_signature": " void runInternal()", "class_method_signature": "NakadiReader.runInternal()", "testcase": false, "constructor": false}, {"identifier": "readSingleBatch", "parameters": "()", "modifiers": "", "return": "void", "signature": "void readSingleBatch()", "full_signature": " void readSingleBatch()", "class_method_signature": "NakadiReader.readSingleBatch()", "testcase": false, "constructor": false}, {"identifier": "readBatch", "parameters": "(final JsonParser jsonParser)", "modifiers": "private", "return": "void", "signature": "void readBatch(final JsonParser jsonParser)", "full_signature": "private void readBatch(final JsonParser jsonParser)", "class_method_signature": "NakadiReader.readBatch(final JsonParser jsonParser)", "testcase": false, "constructor": false}], "file": "fahrschein/src/main/java/org/zalando/fahrschein/NakadiReader.java"}, "focal_method": {"identifier": "runInternal", "parameters": "()", "modifiers": "", "return": "void", "body": "void runInternal() throws IOException, BackoffException {\n        LOG.info(\"Starting to listen for events for {}\", eventNames);\n\n        JsonInput jsonInput = openJsonInput();\n\n        int errorCount = 0;\n\n        while (true) {\n            try {\n                final JsonParser jsonParser = jsonInput.getJsonParser();\n\n                if (Thread.currentThread().isInterrupted()) {\n                    throw new InterruptedIOException(\"Interrupted\");\n                }\n\n                readBatch(jsonParser);\n\n                errorCount = 0;\n            } catch (IOException e) {\n                // Remember interrupted flag in case it accidentally gets cleared before the break\n                final boolean wasInterrupted = Thread.currentThread().isInterrupted();\n\n                metricsCollector.markErrorWhileConsuming();\n\n                if (errorCount > 0) {\n                    LOG.warn(\"Got [{}] [{}] while reading events for {} after [{}] retries\", e.getClass().getSimpleName(), e.getMessage(), eventNames, errorCount, e);\n                } else {\n                    LOG.info(\"Got [{}] [{}] while reading events for {}\", e.getClass().getSimpleName(), e.getMessage(), eventNames, e);\n                }\n\n                jsonInput.close();\n\n                if (wasInterrupted || Thread.currentThread().isInterrupted()) {\n                    LOG.warn(\"Thread was interrupted\");\n                    break;\n                }\n\n                try {\n                    LOG.debug(\"Reconnecting after [{}] errors\", errorCount);\n                    jsonInput = backoffStrategy.call(errorCount, e, this::openJsonInput);\n                    LOG.info(\"Reconnected after [{}] errors\", errorCount);\n                    metricsCollector.markReconnection();\n                } catch (InterruptedException interruptedException) {\n                    LOG.warn(\"Interrupted during reconnection\", interruptedException);\n\n                    Thread.currentThread().interrupt();\n                    return;\n                }\n\n                errorCount++;\n            } catch (Throwable e) {\n                LOG.warn(\"Got [{}] [{}] while reading events for {}\", e.getClass().getSimpleName(), e.getMessage(), eventNames, e);\n\n                try {\n                    jsonInput.close();\n                } catch (Throwable suppressed) {\n                    e.addSuppressed(e);\n                }\n                throw e;\n            }\n        }\n    }", "signature": "void runInternal()", "full_signature": " void runInternal()", "class_method_signature": "NakadiReader.runInternal()", "testcase": false, "constructor": false, "invocations": ["info", "openJsonInput", "getJsonParser", "isInterrupted", "currentThread", "readBatch", "isInterrupted", "currentThread", "markErrorWhileConsuming", "warn", "getSimpleName", "getClass", "getMessage", "info", "getSimpleName", "getClass", "getMessage", "close", "isInterrupted", "currentThread", "warn", "debug", "call", "info", "markReconnection", "warn", "interrupt", "currentThread", "warn", "getSimpleName", "getClass", "getMessage", "close", "addSuppressed"]}, "repository": {"repo_id": 60344998, "url": "https://github.com/zalando-nakadi/fahrschein", "language": "Java", "is_fork": false, "fork_count": 26, "stargazer_count": 17, "size": 776, "license": "licensed"}}