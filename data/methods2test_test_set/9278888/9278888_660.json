{"test_class": {"identifier": "MapExtraTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "BasicMapExtra.Factory factory = new BasicMapExtra.FactoryBuilder()\n      .addInitialKey(\"1\")\n      .addInitialKey(\"2\")\n      .build();", "modifier": "", "type": "BasicMapExtra.Factory", "declarator": "factory = new BasicMapExtra.FactoryBuilder()\n      .addInitialKey(\"1\")\n      .addInitialKey(\"2\")\n      .build()", "var_name": "factory"}, {"original_string": "BasicMapExtra extra = factory.create(), extra2 = factory.create();", "modifier": "", "type": "BasicMapExtra", "declarator": "extra = factory.create()", "var_name": "extra"}], "file": "brave/src/test/java/brave/internal/extra/MapExtraTest.java"}, "test_case": {"identifier": "equalsAndHashCode", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void equalsAndHashCode() {\n    // empty extraction is equivalent\n    assertThat(factory.create())\n        .isEqualTo(factory.create());\n    assertThat(factory.create())\n        .hasSameHashCodeAs(factory.create());\n\n    extra.put(\"1\", \"one\");\n    extra.put(\"2\", \"two\");\n\n    BasicMapExtra extra2 = factory.create();\n    extra2.put(\"1\", \"one\");\n    extra2.put(\"2\", \"two\");\n\n    // same extra are equivalent\n    assertThat(extra).isEqualTo(extra2);\n    assertThat(extra).hasSameHashCodeAs(extra2);\n\n    // different values are not equivalent\n    extra2.put(\"2\", \"three\");\n    assertThat(extra).isNotEqualTo(extra2);\n    assertThat(extra.hashCode()).isNotEqualTo(extra2.hashCode());\n  }", "signature": "void equalsAndHashCode()", "full_signature": "@Test public void equalsAndHashCode()", "class_method_signature": "MapExtraTest.equalsAndHashCode()", "testcase": true, "constructor": false, "invocations": ["isEqualTo", "assertThat", "create", "create", "hasSameHashCodeAs", "assertThat", "create", "create", "put", "put", "create", "put", "put", "isEqualTo", "assertThat", "hasSameHashCodeAs", "assertThat", "put", "isNotEqualTo", "assertThat", "isNotEqualTo", "assertThat", "hashCode", "hashCode"]}, "focal_class": {"identifier": "MapExtra", "superclass": "extends Extra<A, F>", "interfaces": "", "fields": [], "methods": [{"identifier": "MapExtra", "parameters": "(F factory)", "modifiers": "protected", "return": "", "signature": " MapExtra(F factory)", "full_signature": "protected  MapExtra(F factory)", "class_method_signature": "MapExtra.MapExtra(F factory)", "testcase": false, "constructor": true}, {"identifier": "state", "parameters": "()", "modifiers": "", "return": "Object[]", "signature": "Object[] state()", "full_signature": " Object[] state()", "class_method_signature": "MapExtra.state()", "testcase": false, "constructor": false}, {"identifier": "isDynamic", "parameters": "()", "modifiers": "protected", "return": "boolean", "signature": "boolean isDynamic()", "full_signature": "protected boolean isDynamic()", "class_method_signature": "MapExtra.isDynamic()", "testcase": false, "constructor": false}, {"identifier": "isEmpty", "parameters": "()", "modifiers": "protected", "return": "boolean", "signature": "boolean isEmpty()", "full_signature": "protected boolean isEmpty()", "class_method_signature": "MapExtra.isEmpty()", "testcase": false, "constructor": false}, {"identifier": "keySet", "parameters": "()", "modifiers": "protected", "return": "Set<K>", "signature": "Set<K> keySet()", "full_signature": "protected Set<K> keySet()", "class_method_signature": "MapExtra.keySet()", "testcase": false, "constructor": false}, {"identifier": "asReadOnlyMap", "parameters": "()", "modifiers": "protected", "return": "Map<K, V>", "signature": "Map<K, V> asReadOnlyMap()", "full_signature": "protected Map<K, V> asReadOnlyMap()", "class_method_signature": "MapExtra.asReadOnlyMap()", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(K key)", "modifiers": "@Nullable protected", "return": "V", "signature": "V get(K key)", "full_signature": "@Nullable protected V get(K key)", "class_method_signature": "MapExtra.get(K key)", "testcase": false, "constructor": false}, {"identifier": "put", "parameters": "(K key, @Nullable V value)", "modifiers": "protected", "return": "boolean", "signature": "boolean put(K key, @Nullable V value)", "full_signature": "protected boolean put(K key, @Nullable V value)", "class_method_signature": "MapExtra.put(K key, @Nullable V value)", "testcase": false, "constructor": false}, {"identifier": "mergeStateKeepingOursOnConflict", "parameters": "(A theirFields)", "modifiers": "@Override protected", "return": "void", "signature": "void mergeStateKeepingOursOnConflict(A theirFields)", "full_signature": "@Override protected void mergeStateKeepingOursOnConflict(A theirFields)", "class_method_signature": "MapExtra.mergeStateKeepingOursOnConflict(A theirFields)", "testcase": false, "constructor": false}, {"identifier": "indexOfExistingKey", "parameters": "(Object[] state, K key)", "modifiers": "", "return": "int", "signature": "int indexOfExistingKey(Object[] state, K key)", "full_signature": " int indexOfExistingKey(Object[] state, K key)", "class_method_signature": "MapExtra.indexOfExistingKey(Object[] state, K key)", "testcase": false, "constructor": false}, {"identifier": "indexOfInitialKey", "parameters": "(K key)", "modifiers": "", "return": "int", "signature": "int indexOfInitialKey(K key)", "full_signature": " int indexOfInitialKey(K key)", "class_method_signature": "MapExtra.indexOfInitialKey(K key)", "testcase": false, "constructor": false}, {"identifier": "indexOfDynamicKey", "parameters": "(Object[] state, K key)", "modifiers": "", "return": "int", "signature": "int indexOfDynamicKey(Object[] state, K key)", "full_signature": " int indexOfDynamicKey(Object[] state, K key)", "class_method_signature": "MapExtra.indexOfDynamicKey(Object[] state, K key)", "testcase": false, "constructor": false}, {"identifier": "addNewEntry", "parameters": "(Object[] prior, K key, @Nullable V value)", "modifiers": "", "return": "boolean", "signature": "boolean addNewEntry(Object[] prior, K key, @Nullable V value)", "full_signature": " boolean addNewEntry(Object[] prior, K key, @Nullable V value)", "class_method_signature": "MapExtra.addNewEntry(Object[] prior, K key, @Nullable V value)", "testcase": false, "constructor": false}, {"identifier": "stateEquals", "parameters": "(Object thatState)", "modifiers": "@Override protected", "return": "boolean", "signature": "boolean stateEquals(Object thatState)", "full_signature": "@Override protected boolean stateEquals(Object thatState)", "class_method_signature": "MapExtra.stateEquals(Object thatState)", "testcase": false, "constructor": false}, {"identifier": "stateHashCode", "parameters": "()", "modifiers": "@Override protected", "return": "int", "signature": "int stateHashCode()", "full_signature": "@Override protected int stateHashCode()", "class_method_signature": "MapExtra.stateHashCode()", "testcase": false, "constructor": false}, {"identifier": "stateString", "parameters": "()", "modifiers": "@Override protected", "return": "String", "signature": "String stateString()", "full_signature": "@Override protected String stateString()", "class_method_signature": "MapExtra.stateString()", "testcase": false, "constructor": false}], "file": "brave/src/main/java/brave/internal/extra/MapExtra.java"}, "focal_method": {"identifier": "put", "parameters": "(K key, @Nullable V value)", "modifiers": "protected", "return": "boolean", "body": "protected boolean put(K key, @Nullable V value) {\n    if (key == null) return false;\n\n    int i = indexOfExistingKey(state(), key);\n    if (i == -1 && factory.maxDynamicEntries == 0) {\n      Platform.get().log(\"Ignoring request to add a dynamic key\", null);\n      return false;\n    }\n\n    synchronized (lock) {\n      Object[] prior = state();\n\n      // double-check lost race in dynamic case\n      if (i == -1) i = indexOfDynamicKey(prior, key);\n      if (i == -1) return addNewEntry(prior, key, value);\n\n      if (equal(value, prior[i + 1])) return false;\n\n      Object[] newState = Arrays.copyOf(prior, prior.length); // copy-on-write\n      newState[i + 1] = value;\n      this.state = newState;\n      return true;\n    }\n  }", "signature": "boolean put(K key, @Nullable V value)", "full_signature": "protected boolean put(K key, @Nullable V value)", "class_method_signature": "MapExtra.put(K key, @Nullable V value)", "testcase": false, "constructor": false, "invocations": ["indexOfExistingKey", "state", "log", "get", "state", "indexOfDynamicKey", "addNewEntry", "equal", "copyOf"]}, "repository": {"repo_id": 9278888, "url": "https://github.com/openzipkin/brave", "stars": 1754, "created": "4/7/2013 3:48:18 PM +00:00", "updates": "2020-01-26T11:52:41+00:00", "fork": "False", "license": "licensed"}}