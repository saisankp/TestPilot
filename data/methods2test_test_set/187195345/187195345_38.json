{"test_class": {"identifier": "RouteSearchTest", "superclass": "", "interfaces": "", "fields": [], "file": "encoder/src/test/java/openlr/encoder/routesearch/RouteSearchTest.java"}, "test_case": {"identifier": "testLowestFrcRouting", "parameters": "()", "modifiers": "@Test public final", "return": "void", "body": "@Test\n    public final void testLowestFrcRouting() {\n        try {\n            TestData td = TestData.getInstance();\n            MapDatabase mdb = td.getMapDatabase();\n            RouteSearch rs = new RouteSearch(Arrays.asList(mdb.getLine(1), mdb.getLine(3), mdb.getLine(5), mdb.getLine(8)));\n            RouteSearchResult result = rs.calculateRoute();\n            assertEquals(1, result.getIntermediatePos());\n        } catch (Exception e) {\n            fail(\"Wrong error detected: \" + e.getMessage());\n        }\n    }", "signature": "void testLowestFrcRouting()", "full_signature": "@Test public final void testLowestFrcRouting()", "class_method_signature": "RouteSearchTest.testLowestFrcRouting()", "testcase": true, "constructor": false, "invocations": ["getInstance", "getMapDatabase", "asList", "getLine", "getLine", "getLine", "getLine", "calculateRoute", "assertEquals", "getIntermediatePos", "fail", "getMessage"]}, "focal_class": {"identifier": "RouteSearch", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final FrcComparator FRC_COMPARATOR = new FunctionalRoadClass.FrcComparator();", "modifier": "private static final", "type": "FrcComparator", "declarator": "FRC_COMPARATOR = new FunctionalRoadClass.FrcComparator()", "var_name": "FRC_COMPARATOR"}, {"original_string": "private static final Logger LOG = Logger.getLogger(RouteSearch.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(RouteSearch.class)", "var_name": "LOG"}, {"original_string": "private final List<? extends Line> location;", "modifier": "private final", "type": "List<? extends Line>", "declarator": "location", "var_name": "location"}, {"original_string": "private final Line startLine;", "modifier": "private final", "type": "Line", "declarator": "startLine", "var_name": "startLine"}, {"original_string": "private final Line destLine;", "modifier": "private final", "type": "Line", "declarator": "destLine", "var_name": "destLine"}, {"original_string": "private final int startLoopIndex;", "modifier": "private final", "type": "int", "declarator": "startLoopIndex", "var_name": "startLoopIndex"}, {"original_string": "private final int endLoopIndex;", "modifier": "private final", "type": "int", "declarator": "endLoopIndex", "var_name": "endLoopIndex"}, {"original_string": "private double destX = 0;", "modifier": "private", "type": "double", "declarator": "destX = 0", "var_name": "destX"}, {"original_string": "private double destY = 0;", "modifier": "private", "type": "double", "declarator": "destY = 0", "var_name": "destY"}, {"original_string": "private int lengthBetweenStartAndEndLineAlongLocation = 0;", "modifier": "private", "type": "int", "declarator": "lengthBetweenStartAndEndLineAlongLocation = 0", "var_name": "lengthBetweenStartAndEndLineAlongLocation"}], "methods": [{"identifier": "RouteSearch", "parameters": "(final List<? extends Line> loc)", "modifiers": "public", "return": "", "signature": " RouteSearch(final List<? extends Line> loc)", "full_signature": "public  RouteSearch(final List<? extends Line> loc)", "class_method_signature": "RouteSearch.RouteSearch(final List<? extends Line> loc)", "testcase": false, "constructor": true}, {"identifier": "checkLoopAtStart", "parameters": "()", "modifiers": "private", "return": "int", "signature": "int checkLoopAtStart()", "full_signature": "private int checkLoopAtStart()", "class_method_signature": "RouteSearch.checkLoopAtStart()", "testcase": false, "constructor": false}, {"identifier": "checkLoopAtEnd", "parameters": "()", "modifiers": "private", "return": "int", "signature": "int checkLoopAtEnd()", "full_signature": "private int checkLoopAtEnd()", "class_method_signature": "RouteSearch.checkLoopAtEnd()", "testcase": false, "constructor": false}, {"identifier": "calculateRoute", "parameters": "()", "modifiers": "public final", "return": "RouteSearchResult", "signature": "RouteSearchResult calculateRoute()", "full_signature": "public final RouteSearchResult calculateRoute()", "class_method_signature": "RouteSearch.calculateRoute()", "testcase": false, "constructor": false}, {"identifier": "extractNextLines", "parameters": "(final PQElem actualElement,\n                                  final RouteSearchData data)", "modifiers": "private", "return": "void", "signature": "void extractNextLines(final PQElem actualElement,\n                                  final RouteSearchData data)", "full_signature": "private void extractNextLines(final PQElem actualElement,\n                                  final RouteSearchData data)", "class_method_signature": "RouteSearch.extractNextLines(final PQElem actualElement,\n                                  final RouteSearchData data)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public final", "return": "String", "signature": "String toString()", "full_signature": "@Override public final String toString()", "class_method_signature": "RouteSearch.toString()", "testcase": false, "constructor": false}], "file": "encoder/src/main/java/openlr/encoder/routesearch/RouteSearch.java"}, "focal_method": {"identifier": "calculateRoute", "parameters": "()", "modifiers": "public final", "return": "RouteSearchResult", "body": "public final RouteSearchResult calculateRoute()\n            throws OpenLREncoderProcessingException {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"route search between start (\" + startLine.getID()\n                    + \") and dest (\" + destLine.getID() + \")\");\n        }\n        RouteSearchResult result = null;\n\n        // start and end are equals but there is a path in between\n        // so skip the start and proceed with the next line in the location\n        if (startLine.getID() == destLine.getID() && location.size() > 1) {\n            List<Line> route = new ArrayList<Line>(1);\n            route.add(startLine);\n            result = new RouteSearchResult(\n                    RouteSearchReturnCode.INTERMEDIATE_FOUND, route, location\n                    .get(1), 1);\n        } else if (startLoopIndex == 0) {\n            // there is a loop of a single line in the location\n            List<Line> route = new ArrayList<Line>();\n            route.add(startLine);\n            result = new RouteSearchResult(RouteSearchReturnCode.INTERMEDIATE_FOUND, route, location.get(1), 1);\n        } else {\n            //we have to start a search\n            // global data structures\n            IntermediateHandler iHandler = new IntermediateHandler(location);\n            RouteSearchData data = new RouteSearchData();\n\n            // for the use of the heuristic\n            Node e = destLine.getEndNode();\n            destX = e.getLongitudeDeg();\n            destY = e.getLatitudeDeg();\n\n            // initialize the open list with the start element\n            int startLength = startLine.getLineLength();\n            PQElem startElem = new PQElem(startLine, 0/* HACK */, startLength,\n                    null);\n            data.addToOpen(startElem);\n            // open.add(startElem);\n            // bestValues.put(startLine.getID(), startLength);\n            OpenLongHashSet locationIDs = new OpenLongHashSet(location.size());\n            for (Line l : location) {\n                locationIDs.put(l.getID());\n            }\n\n            // main loop\n            while (!data.isOpenEmpty()) {\n                // stop if route or intermediate is found or if no further line\n                // is\n                // available\n\n                // get the top element of the open list\n                PQElem actualElement = data.pollElement();\n\n                // check the location being part of the shortest path tree and\n                // if not change the state to INTERMEDIATE_FOUND\n                if (locationIDs.containsKey(actualElement.getLine().getID())) {\n                    result = iHandler.checkIntermediate(actualElement, data);\n                    if (result != null) {\n                        break;\n                    }\n                }\n\n                // check if we have found the destination and if so then\n                // construct the route and stop calculation\n                if (actualElement.getLine().getID() == destLine.getID()) {\n                    if (endLoopIndex >= 0) {\n                        //route found until the end loop starts\n                        //break here and add intermediate\n                        List<Line> route = PathUtils\n                                .constructPath(actualElement.getPrevious());\n                        result = new RouteSearchResult(\n                                RouteSearchReturnCode.INTERMEDIATE_FOUND,\n                                route, destLine, endLoopIndex);\n                        break;\n                    } else {\n                        List<Line> route = PathUtils\n                                .constructPath(actualElement);\n                        if (route.isEmpty()) {\n                            // strange error\n                            throw new OpenLREncoderProcessingException(\n                                    EncoderProcessingError.ROUTE_CONSTRUCTION_ERROR);\n                        } else {\n                            // route found and constructed\n                            result = new RouteSearchResult(\n                                    RouteSearchResult.RouteSearchReturnCode.ROUTE_FOUND,\n                                    route);\n                            break;\n                        }\n                    }\n                }\n\n                //check for loops at start\n                if (startLoopIndex > 0\n                        && iHandler.getLastElemOnRoutePos() == startLoopIndex) {\n                    // the start loop is completed and route search needs to be\n                    // interrupted, add intermediate\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"loop is traversed, intermediate found\");\n                    }\n                    List<Line> route = PathUtils.constructPath(actualElement.getPrevious());\n                    result = new RouteSearchResult(\n                            RouteSearchReturnCode.INTERMEDIATE_FOUND, route,\n                            startLine, startLoopIndex);\n                    break;\n                }\n                //route search can continue so\n                // iterate over the successors, because we have not reached the\n                // end\n                extractNextLines(actualElement, data);\n            }\n            if (result == null) {\n                //no route found\n                result = new RouteSearchResult(RouteSearchReturnCode.NO_ROUTE_FOUND);\n            }\n        }\n        return result;\n    }", "signature": "RouteSearchResult calculateRoute()", "full_signature": "public final RouteSearchResult calculateRoute()", "class_method_signature": "RouteSearch.calculateRoute()", "testcase": false, "constructor": false, "invocations": ["isDebugEnabled", "debug", "getID", "getID", "getID", "getID", "size", "add", "get", "add", "get", "getEndNode", "getLongitudeDeg", "getLatitudeDeg", "getLineLength", "addToOpen", "size", "put", "getID", "isOpenEmpty", "pollElement", "containsKey", "getID", "getLine", "checkIntermediate", "getID", "getLine", "getID", "constructPath", "getPrevious", "constructPath", "isEmpty", "getLastElemOnRoutePos", "isDebugEnabled", "debug", "constructPath", "getPrevious", "extractNextLines"]}, "repository": {"repo_id": 187195345, "url": "https://github.com/tomtom-international/openlr", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 24, "size": 4809, "license": "licensed"}}