{"test_class": {"identifier": "AesCtrJceCipherTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String NIST_KEY = \"2b7e151628aed2a6abf7158809cf4f3c\";", "modifier": "private static final", "type": "String", "declarator": "NIST_KEY = \"2b7e151628aed2a6abf7158809cf4f3c\"", "var_name": "NIST_KEY"}, {"original_string": "private static final String NIST_PLAINTEXT =\n      \"6bc1bee22e409f96e93d7e117393172a\"\n          + \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n          + \"30c81c46a35ce411e5fbc1191a0a52ef\"\n          + \"f69f2445df4f9b17ad2b417be66c3710\";", "modifier": "private static final", "type": "String", "declarator": "NIST_PLAINTEXT =\n      \"6bc1bee22e409f96e93d7e117393172a\"\n          + \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n          + \"30c81c46a35ce411e5fbc1191a0a52ef\"\n          + \"f69f2445df4f9b17ad2b417be66c3710\"", "var_name": "NIST_PLAINTEXT"}, {"original_string": "private static final String NIST_CIPHERTEXT =\n      \"874d6191b620e3261bef6864990db6ce\"\n          + \"9806f66b7970fdff8617187bb9fffdff\"\n          + \"5ae4df3edbd5d35e5b4f09020db03eab\"\n          + \"1e031dda2fbe03d1792170a0f3009cee\";", "modifier": "private static final", "type": "String", "declarator": "NIST_CIPHERTEXT =\n      \"874d6191b620e3261bef6864990db6ce\"\n          + \"9806f66b7970fdff8617187bb9fffdff\"\n          + \"5ae4df3edbd5d35e5b4f09020db03eab\"\n          + \"1e031dda2fbe03d1792170a0f3009cee\"", "var_name": "NIST_CIPHERTEXT"}, {"original_string": "private static final String NIST_IV = \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";", "modifier": "private static final", "type": "String", "declarator": "NIST_IV = \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"", "var_name": "NIST_IV"}, {"original_string": "private static final String PLAINTEXT =\n      \"I'm counter mode and I'm not vulnerable to padding oracle attack like CBC mode\";", "modifier": "private static final", "type": "String", "declarator": "PLAINTEXT =\n      \"I'm counter mode and I'm not vulnerable to padding oracle attack like CBC mode\"", "var_name": "PLAINTEXT"}, {"original_string": "private byte[] msg;", "modifier": "private", "type": "byte[]", "declarator": "msg", "var_name": "msg"}], "file": "java_src/src/test/java/com/google/crypto/tink/subtle/AesCtrJceCipherTest.java"}, "test_case": {"identifier": "testMultipleEncrypts", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testMultipleEncrypts() throws Exception {\n    // Checks whether multiple encryptions result in different ciphertexts.\n    byte[] key = Random.randBytes(16);\n    int ivSize = 16;\n    AesCtrJceCipher cipher = new AesCtrJceCipher(key, ivSize);\n    byte[] c1 = cipher.encrypt(msg);\n    byte[] c2 = cipher.encrypt(msg);\n    assertEquals(c1.length, c2.length);\n    assertFalse(Arrays.equals(c1, c2));\n  }", "signature": "void testMultipleEncrypts()", "full_signature": "@Test public void testMultipleEncrypts()", "class_method_signature": "AesCtrJceCipherTest.testMultipleEncrypts()", "testcase": true, "constructor": false, "invocations": ["randBytes", "encrypt", "encrypt", "assertEquals", "assertFalse", "equals"]}, "focal_class": {"identifier": "AesCtrJceCipher", "superclass": "", "interfaces": "implements IndCpaCipher", "fields": [{"original_string": "private static final ThreadLocal<Cipher> localCipher =\n      new ThreadLocal<Cipher>() {\n        @Override\n        protected Cipher initialValue() {\n          try {\n            return EngineFactory.CIPHER.getInstance(CIPHER_ALGORITHM);\n          } catch (GeneralSecurityException ex) {\n            throw new IllegalStateException(ex);\n          }\n        }\n      };", "modifier": "private static final", "type": "ThreadLocal<Cipher>", "declarator": "localCipher =\n      new ThreadLocal<Cipher>() {\n        @Override\n        protected Cipher initialValue() {\n          try {\n            return EngineFactory.CIPHER.getInstance(CIPHER_ALGORITHM);\n          } catch (GeneralSecurityException ex) {\n            throw new IllegalStateException(ex);\n          }\n        }\n      }", "var_name": "localCipher"}, {"original_string": "private static final String KEY_ALGORITHM = \"AES\";", "modifier": "private static final", "type": "String", "declarator": "KEY_ALGORITHM = \"AES\"", "var_name": "KEY_ALGORITHM"}, {"original_string": "private static final String CIPHER_ALGORITHM = \"AES/CTR/NoPadding\";", "modifier": "private static final", "type": "String", "declarator": "CIPHER_ALGORITHM = \"AES/CTR/NoPadding\"", "var_name": "CIPHER_ALGORITHM"}, {"original_string": "private static final int MIN_IV_SIZE_IN_BYTES = 12;", "modifier": "private static final", "type": "int", "declarator": "MIN_IV_SIZE_IN_BYTES = 12", "var_name": "MIN_IV_SIZE_IN_BYTES"}, {"original_string": "private final SecretKeySpec keySpec;", "modifier": "private final", "type": "SecretKeySpec", "declarator": "keySpec", "var_name": "keySpec"}, {"original_string": "private final int ivSize;", "modifier": "private final", "type": "int", "declarator": "ivSize", "var_name": "ivSize"}, {"original_string": "private final int blockSize;", "modifier": "private final", "type": "int", "declarator": "blockSize", "var_name": "blockSize"}], "methods": [{"identifier": "AesCtrJceCipher", "parameters": "(final byte[] key, int ivSize)", "modifiers": "public", "return": "", "signature": " AesCtrJceCipher(final byte[] key, int ivSize)", "full_signature": "public  AesCtrJceCipher(final byte[] key, int ivSize)", "class_method_signature": "AesCtrJceCipher.AesCtrJceCipher(final byte[] key, int ivSize)", "testcase": false, "constructor": true}, {"identifier": "encrypt", "parameters": "(final byte[] plaintext)", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] encrypt(final byte[] plaintext)", "full_signature": "@Override public byte[] encrypt(final byte[] plaintext)", "class_method_signature": "AesCtrJceCipher.encrypt(final byte[] plaintext)", "testcase": false, "constructor": false}, {"identifier": "decrypt", "parameters": "(final byte[] ciphertext)", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] decrypt(final byte[] ciphertext)", "full_signature": "@Override public byte[] decrypt(final byte[] ciphertext)", "class_method_signature": "AesCtrJceCipher.decrypt(final byte[] ciphertext)", "testcase": false, "constructor": false}, {"identifier": "doCtr", "parameters": "(\n      final byte[] input,\n      int inputOffset,\n      int inputLen,\n      byte[] output,\n      int outputOffset,\n      final byte[] iv,\n      boolean encrypt)", "modifiers": "private", "return": "void", "signature": "void doCtr(\n      final byte[] input,\n      int inputOffset,\n      int inputLen,\n      byte[] output,\n      int outputOffset,\n      final byte[] iv,\n      boolean encrypt)", "full_signature": "private void doCtr(\n      final byte[] input,\n      int inputOffset,\n      int inputLen,\n      byte[] output,\n      int outputOffset,\n      final byte[] iv,\n      boolean encrypt)", "class_method_signature": "AesCtrJceCipher.doCtr(\n      final byte[] input,\n      int inputOffset,\n      int inputLen,\n      byte[] output,\n      int outputOffset,\n      final byte[] iv,\n      boolean encrypt)", "testcase": false, "constructor": false}], "file": "java_src/src/main/java/com/google/crypto/tink/subtle/AesCtrJceCipher.java"}, "focal_method": {"identifier": "encrypt", "parameters": "(final byte[] plaintext)", "modifiers": "@Override public", "return": "byte[]", "body": "@Override\n  public byte[] encrypt(final byte[] plaintext) throws GeneralSecurityException {\n    if (plaintext.length > Integer.MAX_VALUE - ivSize) {\n      throw new GeneralSecurityException(\n          \"plaintext length can not exceed \" + (Integer.MAX_VALUE - ivSize));\n    }\n    byte[] ciphertext = new byte[ivSize + plaintext.length];\n    byte[] iv = Random.randBytes(ivSize);\n    System.arraycopy(iv, 0, ciphertext, 0, ivSize);\n    doCtr(plaintext, 0, plaintext.length, ciphertext, ivSize, iv, true);\n    return ciphertext;\n  }", "signature": "byte[] encrypt(final byte[] plaintext)", "full_signature": "@Override public byte[] encrypt(final byte[] plaintext)", "class_method_signature": "AesCtrJceCipher.encrypt(final byte[] plaintext)", "testcase": false, "constructor": false, "invocations": ["randBytes", "arraycopy", "doCtr"]}, "repository": {"repo_id": 20570214, "url": "https://github.com/google/tink", "stars": 8884, "created": "6/6/2014 4:21:09 PM +00:00", "updates": "2020-01-27T11:52:16+00:00", "fork": "False", "license": "licensed"}}