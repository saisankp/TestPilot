{"test_class": {"identifier": "ForkOperationTest", "superclass": "", "interfaces": "", "fields": [], "file": "operations/src/test/java/com/nextdoor/bender/operation/fork/ForkOperationTest.java"}, "test_case": {"identifier": "testForkMonitoringSeries", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testForkMonitoringSeries() {\n    /*\n     * Setup the pipeline of operation processors\n     */\n    List<List<OperationProcessor>> forks = new ArrayList<List<OperationProcessor>>();\n\n    List<OperationProcessor> fork1 = new ArrayList<OperationProcessor>();\n    fork1.add(new OperationProcessor(new DummyThrottleOperationFactory()));\n    fork1.add(new OperationProcessor(new DummyOperationFactory()));\n    forks.add(fork1);\n\n\n    ForkOperation op = new ForkOperation(forks);\n\n    /*\n     * Create thread that supplies input events\n     */\n    Queue<InternalEvent> inputQueue = new Queue<InternalEvent>();\n    supply(10, inputQueue);\n\n    /*\n     * Process\n     */\n    Stream<InternalEvent> input = inputQueue.stream();\n    Stream<InternalEvent> output = op.getOutputStream(input);\n\n    List<String> outputEvents =\n        output.map(InternalEvent::getEventString).collect(Collectors.toList());\n\n    Monitor m = Monitor.getInstance();\n\n    List<Stat> stats = m.getStats();\n\n    Map<String, String> actual = new HashMap<String, String>();\n    for (Stat stat : stats) {\n      String key =\n          String.format(\"%s.%s\", stat.getTags().iterator().next().getValue(), stat.getName());\n      actual.put(key, \"\" + stat.getValue());\n    }\n\n    assertEquals(\"0\", actual\n        .get(\"com.nextdoor.bender.testutils.DummyOperationHelper.DummyOperation.error.count\"));\n    assertEquals(\"10\", actual\n        .get(\"com.nextdoor.bender.testutils.DummyOperationHelper.DummyOperation.success.count\"));\n    assertEquals(\"10\", actual.get(\n        \"com.nextdoor.bender.testutils.DummyThrottleOperationHelper.DummyThrottleOperation.success.count\"));\n    assertEquals(\"0\", actual.get(\n        \"com.nextdoor.bender.testutils.DummyThrottleOperationHelper.DummyThrottleOperation.error.count\"));\n  }", "signature": "void testForkMonitoringSeries()", "full_signature": "@Test public void testForkMonitoringSeries()", "class_method_signature": "ForkOperationTest.testForkMonitoringSeries()", "testcase": true, "constructor": false, "invocations": ["add", "add", "add", "supply", "stream", "getOutputStream", "collect", "map", "toList", "getInstance", "getStats", "format", "getValue", "next", "iterator", "getTags", "getName", "put", "getValue", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "ForkOperation", "superclass": "", "interfaces": "implements StreamOperation", "fields": [{"original_string": "private List<Queue<InternalEvent>> queues;", "modifier": "private", "type": "List<Queue<InternalEvent>>", "declarator": "queues", "var_name": "queues"}, {"original_string": "private final List<List<OperationProcessor>> opProcsInForks;", "modifier": "private final", "type": "List<List<OperationProcessor>>", "declarator": "opProcsInForks", "var_name": "opProcsInForks"}, {"original_string": "private final ExecutorService es;", "modifier": "private final", "type": "ExecutorService", "declarator": "es", "var_name": "es"}], "methods": [{"identifier": "ForkOperation", "parameters": "(List<List<OperationProcessor>> opProcsInForks)", "modifiers": "public", "return": "", "signature": " ForkOperation(List<List<OperationProcessor>> opProcsInForks)", "full_signature": "public  ForkOperation(List<List<OperationProcessor>> opProcsInForks)", "class_method_signature": "ForkOperation.ForkOperation(List<List<OperationProcessor>> opProcsInForks)", "testcase": false, "constructor": true}, {"identifier": "getOutputStream", "parameters": "(Stream<InternalEvent> input)", "modifiers": "public", "return": "Stream<InternalEvent>", "signature": "Stream<InternalEvent> getOutputStream(Stream<InternalEvent> input)", "full_signature": "public Stream<InternalEvent> getOutputStream(Stream<InternalEvent> input)", "class_method_signature": "ForkOperation.getOutputStream(Stream<InternalEvent> input)", "testcase": false, "constructor": false}], "file": "operations/src/main/java/com/nextdoor/bender/operation/fork/ForkOperation.java"}, "focal_method": {"identifier": "getOutputStream", "parameters": "(Stream<InternalEvent> input)", "modifiers": "public", "return": "Stream<InternalEvent>", "body": "public Stream<InternalEvent> getOutputStream(Stream<InternalEvent> input) {\n    /*\n     * forkOutputStreams keeps track of the output Stream of each fork.\n     */\n    List<Stream<InternalEvent>> forkOutputStreams =\n        new ArrayList<Stream<InternalEvent>>(opProcsInForks.size());\n\n    /*\n     * From a list of operation configurations in each fork construct queues and streams.\n     */\n    this.queues = new ArrayList<Queue<InternalEvent>>(opProcsInForks.size());\n    for (List<OperationProcessor> opProcsInFork : opProcsInForks) {\n      /*\n       * Construct a Queue for each fork. This is the input to each Fork.\n       */\n      Queue<InternalEvent> queue =\n          new Queue<InternalEvent>(new LinkedBlockingQueue<InternalEvent>(opProcsInFork.size()));\n      this.queues.add(queue);\n\n      /*\n       * Connect the fork's input Queue with operations. Each operation returns a stream with its\n       * operation concatenated on.\n       */\n      Stream<InternalEvent> forkInput = queue.jdkStream();\n      for (OperationProcessor opProcInFork : opProcsInFork) {\n        forkInput = opProcInFork.perform(forkInput);\n      }\n\n      /*\n       * Last input is the output.\n       */\n      forkOutputStreams.add(forkInput);\n    }\n\n    /*\n     * Fork Consumer Threads\n     * \n     * Combine each fork's output stream and write to the output Queue. When all data is consumed\n     * the last fork closes the output Queue.\n     */\n    Queue<InternalEvent> outputQueue =\n        new Queue<InternalEvent>(new LinkedBlockingQueue<InternalEvent>(this.queues.size()));\n    AtomicInteger lock = new AtomicInteger(forkOutputStreams.size());\n\n    forkOutputStreams.forEach(stream -> {\n      this.es.execute(new StreamToQueue(stream, outputQueue, lock));\n    });\n\n    /*\n     * Consume input Stream in a thread and publish to each fork's Queue.\n     */\n    new Thread(new Runnable() {\n      @Override\n      public void run() {\n        input.forEach(ievent -> {\n          queues.forEach(queue -> {\n            /*\n             * The original event is NOT sent to each fork. Rather a copy of the event is sent to\n             * each fork. This ensures that there is no contention between the operations performed\n             * on each event. Caveat is that when the forks join there will be two events produced.\n             */\n            queue.offer(ievent.copy());\n          });\n        });\n\n        for (Queue<InternalEvent> queue : queues) {\n          queue.close();\n        }\n      }\n    }).start();\n\n    return outputQueue.jdkStream();\n  }", "signature": "Stream<InternalEvent> getOutputStream(Stream<InternalEvent> input)", "full_signature": "public Stream<InternalEvent> getOutputStream(Stream<InternalEvent> input)", "class_method_signature": "ForkOperation.getOutputStream(Stream<InternalEvent> input)", "testcase": false, "constructor": false, "invocations": ["size", "size", "size", "add", "jdkStream", "perform", "add", "size", "size", "forEach", "execute", "start", "forEach", "forEach", "offer", "copy", "close", "jdkStream"]}, "repository": {"repo_id": 75955378, "url": "https://github.com/Nextdoor/bender", "language": "Java", "is_fork": false, "fork_count": 15, "stargazer_count": 163, "size": 1503, "license": "licensed"}}