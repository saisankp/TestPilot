{"test_class": {"identifier": "TestStandardFDConnectionService", "superclass": "extends BaseFDServiceTest", "interfaces": "", "fields": [{"original_string": "private VersionedConnection connectionConfig;", "modifier": "private", "type": "VersionedConnection", "declarator": "connectionConfig", "var_name": "connectionConfig"}, {"original_string": "private FDConnectionService connectionService;", "modifier": "private", "type": "FDConnectionService", "declarator": "connectionService", "var_name": "connectionService"}], "file": "efm/efm-flow-designer/efm-flow-designer-framework/src/test/java/com/cloudera/cem/efm/service/component/TestStandardFDConnectionService.java"}, "test_case": {"identifier": "testUpdateDestToInputPortInNonChildGroup", "parameters": "()", "modifiers": "@Test(expected = IllegalStateException.class) public", "return": "void", "body": "@Test(expected = IllegalStateException.class)\n    public void testUpdateDestToInputPortInNonChildGroup() {\n        final String flowId = flow.getFlowMetadata().getIdentifier();\n        when(flowManager.getFlow(flowId)).thenReturn(Optional.of(flow));\n\n        final ConnectableComponent newDest = ComponentUtils.createConnectableComponent(group1InputPort);\n\n        final VersionedConnection requestConnection = new VersionedConnection();\n        requestConnection.setIdentifier(connectionG2P2toG2P3.getIdentifier());\n        requestConnection.setDestination(newDest);\n\n        connectionService.update(flowId, requestConnection);\n    }", "signature": "void testUpdateDestToInputPortInNonChildGroup()", "full_signature": "@Test(expected = IllegalStateException.class) public void testUpdateDestToInputPortInNonChildGroup()", "class_method_signature": "TestStandardFDConnectionService.testUpdateDestToInputPortInNonChildGroup()", "testcase": true, "constructor": false, "invocations": ["getIdentifier", "getFlowMetadata", "thenReturn", "when", "getFlow", "of", "createConnectableComponent", "setIdentifier", "getIdentifier", "setDestination", "update"]}, "focal_class": {"identifier": "StandardFDConnectionService", "superclass": "extends BaseComponentService<VersionedConnection, FDConnection>", "interfaces": "implements com.cloudera.cem.efm.service.component.FDConnectionService", "fields": [{"original_string": "public static final String DEFAULT_BACK_PRESSURE_DATA_SIZE_THRESHOLD = \"10000 B\";", "modifier": "public static final", "type": "String", "declarator": "DEFAULT_BACK_PRESSURE_DATA_SIZE_THRESHOLD = \"10000 B\"", "var_name": "DEFAULT_BACK_PRESSURE_DATA_SIZE_THRESHOLD"}, {"original_string": "public static final long DEFAULT_BACK_PRESSURE_OBJECT_SIZE_THRESHOLD = 0;", "modifier": "public static final", "type": "long", "declarator": "DEFAULT_BACK_PRESSURE_OBJECT_SIZE_THRESHOLD = 0", "var_name": "DEFAULT_BACK_PRESSURE_OBJECT_SIZE_THRESHOLD"}, {"original_string": "public static final String DEFAULT_FLOW_FILE_EXPIRATION = \"60 seconds\";", "modifier": "public static final", "type": "String", "declarator": "DEFAULT_FLOW_FILE_EXPIRATION = \"60 seconds\"", "var_name": "DEFAULT_FLOW_FILE_EXPIRATION"}, {"original_string": "private static Map<ConnectableComponentType, Function<VersionedProcessGroup, Set<? extends VersionedComponent>>> componentTypeFunctionMap;", "modifier": "private static", "type": "Map<ConnectableComponentType, Function<VersionedProcessGroup, Set<? extends VersionedComponent>>>", "declarator": "componentTypeFunctionMap", "var_name": "componentTypeFunctionMap"}], "methods": [{"identifier": "StandardFDConnectionService", "parameters": "(final FDFlowManager flowManager, final ValidationService validationService)", "modifiers": "public", "return": "", "signature": " StandardFDConnectionService(final FDFlowManager flowManager, final ValidationService validationService)", "full_signature": "public  StandardFDConnectionService(final FDFlowManager flowManager, final ValidationService validationService)", "class_method_signature": "StandardFDConnectionService.StandardFDConnectionService(final FDFlowManager flowManager, final ValidationService validationService)", "testcase": false, "constructor": true}, {"identifier": "create", "parameters": "(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "modifiers": "@Override public", "return": "FDConnection", "signature": "FDConnection create(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "full_signature": "@Override public FDConnection create(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "class_method_signature": "StandardFDConnectionService.create(final String flowId, final String processGroupId, final VersionedConnection requestComponentConfig)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(final String flowId, final String componentId)", "modifiers": "@Override public", "return": "FDConnection", "signature": "FDConnection get(final String flowId, final String componentId)", "full_signature": "@Override public FDConnection get(final String flowId, final String componentId)", "class_method_signature": "StandardFDConnectionService.get(final String flowId, final String componentId)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(final String flowId, final VersionedConnection requestComponentConfig)", "modifiers": "@Override public", "return": "FDConnection", "signature": "FDConnection update(final String flowId, final VersionedConnection requestComponentConfig)", "full_signature": "@Override public FDConnection update(final String flowId, final VersionedConnection requestComponentConfig)", "class_method_signature": "StandardFDConnectionService.update(final String flowId, final VersionedConnection requestComponentConfig)", "testcase": false, "constructor": false}, {"identifier": "delete", "parameters": "(final String flowId, final String componentId)", "modifiers": "@Override public", "return": "void", "signature": "void delete(final String flowId, final String componentId)", "full_signature": "@Override public void delete(final String flowId, final String componentId)", "class_method_signature": "StandardFDConnectionService.delete(final String flowId, final String componentId)", "testcase": false, "constructor": false}, {"identifier": "instantiateComponent", "parameters": "(final VersionedConnection componentConfig)", "modifiers": "@Override protected", "return": "FDConnection", "signature": "FDConnection instantiateComponent(final VersionedConnection componentConfig)", "full_signature": "@Override protected FDConnection instantiateComponent(final VersionedConnection componentConfig)", "class_method_signature": "StandardFDConnectionService.instantiateComponent(final VersionedConnection componentConfig)", "testcase": false, "constructor": false}, {"identifier": "configureComponentSpecifics", "parameters": "(final VersionedConnection requestComponent,\n                                               final VersionedConnection resultComponent)", "modifiers": "@Override protected", "return": "void", "signature": "void configureComponentSpecifics(final VersionedConnection requestComponent,\n                                               final VersionedConnection resultComponent)", "full_signature": "@Override protected void configureComponentSpecifics(final VersionedConnection requestComponent,\n                                               final VersionedConnection resultComponent)", "class_method_signature": "StandardFDConnectionService.configureComponentSpecifics(final VersionedConnection requestComponent,\n                                               final VersionedConnection resultComponent)", "testcase": false, "constructor": false}, {"identifier": "containsChildGroup", "parameters": "(final VersionedProcessGroup parentGroup, final String childGroupId)", "modifiers": "private", "return": "boolean", "signature": "boolean containsChildGroup(final VersionedProcessGroup parentGroup, final String childGroupId)", "full_signature": "private boolean containsChildGroup(final VersionedProcessGroup parentGroup, final String childGroupId)", "class_method_signature": "StandardFDConnectionService.containsChildGroup(final VersionedProcessGroup parentGroup, final String childGroupId)", "testcase": false, "constructor": false}, {"identifier": "containsConnectable", "parameters": "(final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "modifiers": "private", "return": "boolean", "signature": "boolean containsConnectable(final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "full_signature": "private boolean containsConnectable(final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "class_method_signature": "StandardFDConnectionService.containsConnectable(final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "testcase": false, "constructor": false}, {"identifier": "getVersionedComponentConnectable", "parameters": "(\n            final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "modifiers": "private", "return": "Optional<VersionedComponent>", "signature": "Optional<VersionedComponent> getVersionedComponentConnectable(\n            final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "full_signature": "private Optional<VersionedComponent> getVersionedComponentConnectable(\n            final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "class_method_signature": "StandardFDConnectionService.getVersionedComponentConnectable(\n            final VersionedProcessGroup sourceGroup, final ConnectableComponent source)", "testcase": false, "constructor": false}, {"identifier": "isDestStillUsed", "parameters": "(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingDestination,\n                                    final VersionedProcessGroup connectionGroup)", "modifiers": "private", "return": "boolean", "signature": "boolean isDestStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingDestination,\n                                    final VersionedProcessGroup connectionGroup)", "full_signature": "private boolean isDestStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingDestination,\n                                    final VersionedProcessGroup connectionGroup)", "class_method_signature": "StandardFDConnectionService.isDestStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingDestination,\n                                    final VersionedProcessGroup connectionGroup)", "testcase": false, "constructor": false}, {"identifier": "isSourceStillUsed", "parameters": "(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingSource,\n                                    final VersionedProcessGroup connectionGroup)", "modifiers": "private", "return": "boolean", "signature": "boolean isSourceStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingSource,\n                                    final VersionedProcessGroup connectionGroup)", "full_signature": "private boolean isSourceStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingSource,\n                                    final VersionedProcessGroup connectionGroup)", "class_method_signature": "StandardFDConnectionService.isSourceStillUsed(final VersionedConnection existingConnection,\n                                    final ConnectableComponent existingSource,\n                                    final VersionedProcessGroup connectionGroup)", "testcase": false, "constructor": false}, {"identifier": "removeRemoteInputPort", "parameters": "(final VersionedProcessGroup connectionGroup, final ConnectableComponent remoteInputPort)", "modifiers": "private", "return": "void", "signature": "void removeRemoteInputPort(final VersionedProcessGroup connectionGroup, final ConnectableComponent remoteInputPort)", "full_signature": "private void removeRemoteInputPort(final VersionedProcessGroup connectionGroup, final ConnectableComponent remoteInputPort)", "class_method_signature": "StandardFDConnectionService.removeRemoteInputPort(final VersionedProcessGroup connectionGroup, final ConnectableComponent remoteInputPort)", "testcase": false, "constructor": false}, {"identifier": "removeRemoteOutputPort", "parameters": "(VersionedProcessGroup connectionGroup, ConnectableComponent remoteOutputPort)", "modifiers": "private", "return": "void", "signature": "void removeRemoteOutputPort(VersionedProcessGroup connectionGroup, ConnectableComponent remoteOutputPort)", "full_signature": "private void removeRemoteOutputPort(VersionedProcessGroup connectionGroup, ConnectableComponent remoteOutputPort)", "class_method_signature": "StandardFDConnectionService.removeRemoteOutputPort(VersionedProcessGroup connectionGroup, ConnectableComponent remoteOutputPort)", "testcase": false, "constructor": false}, {"identifier": "validateRequestConfig", "parameters": "(final VersionedConnection requestComponentConfig)", "modifiers": "private", "return": "void", "signature": "void validateRequestConfig(final VersionedConnection requestComponentConfig)", "full_signature": "private void validateRequestConfig(final VersionedConnection requestComponentConfig)", "class_method_signature": "StandardFDConnectionService.validateRequestConfig(final VersionedConnection requestComponentConfig)", "testcase": false, "constructor": false}], "file": "efm/efm-flow-designer/efm-flow-designer-framework/src/main/java/com/cloudera/cem/efm/service/component/StandardFDConnectionService.java"}, "focal_method": {"identifier": "update", "parameters": "(final String flowId, final VersionedConnection requestComponentConfig)", "modifiers": "@Override public", "return": "FDConnection", "body": "@Override\n    public FDConnection update(final String flowId, final VersionedConnection requestComponentConfig) {\n        final FDFlow currentFlow = getFlowOrNotFound(flowId);\n        final VersionedProcessGroup flowContents = currentFlow.getFlowContent();\n\n        // locate the connection component and ensure it exists\n        final String componentId = requestComponentConfig.getIdentifier();\n        final VersionedConnection existingConnection = ComponentUtils.getComponentOrNotFound(\n                componentId, flowContents, VersionedProcessGroup::getConnections);\n\n        // locate the connection group and ensure it exists\n        final String connectionGroupId = existingConnection.getGroupIdentifier();\n        final VersionedProcessGroup connectionGroup = ComponentUtils.getProcessGroupOrIllegalArgument(connectionGroupId, flowContents);\n\n        final ConnectableComponent requestSource = requestComponentConfig.getSource();\n        final ConnectableComponent existingSource = existingConnection.getSource();\n\n        // if a source was provided then ensure it is the same source as the existing connection\n        if (isNotNull(requestSource) && isNotNull(requestSource.getId()) && !requestSource.getId().equals(existingSource.getId())) {\n            throw new IllegalStateException(\"Connection with id \" + existingConnection.getIdentifier() + \" has conflicting source id\");\n        }\n\n        // If a processor specifies a non-null set of selected relationships, then it must not be empty\n        if (existingSource.getType() == ConnectableComponentType.PROCESSOR\n                && isNotNull(requestComponentConfig.getSelectedRelationships())\n                && requestComponentConfig.getSelectedRelationships().isEmpty()) {\n            throw new IllegalArgumentException(\"Selected relationships cannot be empty\");\n        }\n\n        // validate the common request fields for create/update\n        validateRequestConfig(requestComponentConfig);\n\n        // determine if the destination changed\n        final ConnectableComponent proposedDestination = requestComponentConfig.getDestination();\n        if (proposedDestination != null) {\n            if (proposedDestination.getId() == null) {\n                throw new IllegalArgumentException(\"Proposed destination must contain an id\");\n            }\n\n            if (proposedDestination.getType() == null) {\n                throw new IllegalArgumentException(\"Proposed destination must contain a type\");\n            }\n\n            if (proposedDestination.getType() == ConnectableComponentType.FUNNEL\n                    && proposedDestination.getId().equals(existingSource.getId())) {\n                throw new IllegalArgumentException(\"Connecting a funnel to itself is not allowed\");\n            }\n\n            final ConnectableComponent currentDestination = existingConnection.getDestination();\n\n            // handle remote input port differently\n            if (ConnectableComponentType.REMOTE_OUTPUT_PORT == proposedDestination.getType()) {\n                throw new IllegalArgumentException(\"Destination cannot be a remote output port\");\n            } else if (ConnectableComponentType.REMOTE_INPUT_PORT == proposedDestination.getType()) {\n\n                final String proposedDestinationId = proposedDestination.getId();\n                final String proposedDestinationGroupId = proposedDestination.getGroupId();\n\n                try {\n                    UUID.fromString(proposedDestinationId);\n                } catch (Exception  e) {\n                    throw new IllegalArgumentException(\"The ID of a remote input port must be a UUID\");\n                }\n\n                // the group id must be specified\n                if (proposedDestinationGroupId == null) {\n                    throw new IllegalArgumentException(\"When the destination is a remote input port its group id is required.\");\n                }\n\n                // if the current destination is a remote input port\n                boolean isDifferentRemoteProcessGroup = false;\n                if (currentDestination.getType() == ConnectableComponentType.REMOTE_INPUT_PORT) {\n                    if (!proposedDestinationGroupId.equals(currentDestination.getGroupId())) {\n                        isDifferentRemoteProcessGroup = true;\n                    }\n                }\n\n                // if the destination is changing or the previous destination was a different remote process group\n                if (!proposedDestinationId.equals(currentDestination.getId()) || isDifferentRemoteProcessGroup) {\n                    // locate the remote process group or throw exception if not found\n                    final VersionedRemoteProcessGroup proposedRemoteProcessGroup = connectionGroup.getRemoteProcessGroups().stream()\n                            .filter(rpg -> rpg.getIdentifier().equals(proposedDestinationGroupId))\n                            .findFirst()\n                            .orElseThrow(() -> new IllegalArgumentException(\"Unable to find the specified remote process group for the destination\"));\n\n                    // locate an existing remote input port with a target id that matches the proposed destination id\n                    final Optional<VersionedRemoteGroupPort> remoteInputPort = proposedRemoteProcessGroup.getInputPorts().stream()\n                            .filter(p -> p.getTargetId().equals(proposedDestinationId))\n                            .findFirst();\n\n                    // if an existing port wasn't found then create one\n                    final VersionedRemoteGroupPort newRemoteInputPort = new VersionedRemoteGroupPort();\n                    if (!remoteInputPort.isPresent()) {\n                        newRemoteInputPort.setIdentifier(UUID.randomUUID().toString());\n                        newRemoteInputPort.setGroupIdentifier(connectionGroup.getIdentifier());\n                        newRemoteInputPort.setRemoteGroupId(proposedDestinationGroupId);\n                        newRemoteInputPort.setTargetId(proposedDestinationId);\n                        newRemoteInputPort.setName(proposedDestinationId);\n                        newRemoteInputPort.setComponentType(ComponentType.REMOTE_INPUT_PORT);\n                    }\n\n                    // determine if any other connections are still using the original remote input port, and if not remove it\n                    if (!isDestStillUsed(existingConnection, currentDestination, connectionGroup)) {\n                        removeRemoteInputPort(connectionGroup, currentDestination);\n                    }\n\n                    // add the port and update destination on the existing connection\n                    proposedRemoteProcessGroup.getInputPorts().add(newRemoteInputPort);\n                    proposedDestination.setName(proposedDestinationId);\n                    existingConnection.setDestination(proposedDestination);\n                }\n\n            } else {\n\n                // if there is a different destination id\n                if (!proposedDestination.getId().equals(currentDestination.getId())) {\n                    // if the destination connectable's group id has not been set, its inferred to be the current group\n                    if (proposedDestination.getGroupId() == null) {\n                        proposedDestination.setGroupId(existingConnection.getGroupIdentifier());\n                    }\n\n                    // locate the destination group and ensure it exists\n                    final VersionedProcessGroup destinationGroup = ComponentUtils.getProcessGroupOrIllegalArgument(\n                            proposedDestination.getGroupId(), currentFlow.getFlowContent());\n\n                    // locate destination component in the destination group and ensure it exists\n                    final Optional<VersionedComponent> newDestination = getVersionedComponentConnectable(\n                            destinationGroup, proposedDestination);\n\n                    if (!newDestination.isPresent()) {\n                        throw new IllegalArgumentException(\"Unable to find the specified destination.\");\n                    }\n\n                    // if the group of the new dest component is not the group the connection is in, then ensure\n                    // the group is a child of the connection's group, and ensure the component is an input port\n\n                    final String existingConnectionGroupId = existingConnection.getGroupIdentifier();\n                    final String newDestinationGroupId = newDestination.get().getGroupIdentifier();\n\n                    if (!existingConnectionGroupId.equals(newDestinationGroupId)) {\n                        final ComponentType newDestinationComponentType = newDestination.get().getComponentType();\n                        if (newDestinationComponentType != ComponentType.INPUT_PORT) {\n                            throw new IllegalStateException(\"Cannot update connection because the destination is in \" +\n                                    \"a different process group and is not an input port\");\n                        }\n\n                        final boolean connectionGroupContainsDestGroup = containsChildGroup(connectionGroup, newDestinationGroupId);\n                        if (!connectionGroupContainsDestGroup) {\n                            throw new IllegalStateException(\"Cannot update connection because the new destination \" +\n                                    \"group is not a child group of the connection group\");\n                        }\n                    }\n\n                    // update the existing connection's destination\n                    existingConnection.setDestination(proposedDestination);\n                }\n            }\n        }\n\n        final FDConnection connection = updateComponent(currentFlow, requestComponentConfig, existingConnection, null);\n\n        getValidationService().clearValidationErrors(connection.getComponentConfiguration().getSource().getId());\n        getValidationService().clearValidationErrors(connection.getComponentConfiguration().getDestination().getId());\n\n        return connection;\n    }", "signature": "FDConnection update(final String flowId, final VersionedConnection requestComponentConfig)", "full_signature": "@Override public FDConnection update(final String flowId, final VersionedConnection requestComponentConfig)", "class_method_signature": "StandardFDConnectionService.update(final String flowId, final VersionedConnection requestComponentConfig)", "testcase": false, "constructor": false, "invocations": ["getFlowOrNotFound", "getFlowContent", "getIdentifier", "getComponentOrNotFound", "getGroupIdentifier", "getProcessGroupOrIllegalArgument", "getSource", "getSource", "isNotNull", "isNotNull", "getId", "equals", "getId", "getId", "getIdentifier", "getType", "isNotNull", "getSelectedRelationships", "isEmpty", "getSelectedRelationships", "validateRequestConfig", "getDestination", "getId", "getType", "getType", "equals", "getId", "getId", "getDestination", "getType", "getType", "getId", "getGroupId", "fromString", "getType", "equals", "getGroupId", "equals", "getId", "orElseThrow", "findFirst", "filter", "stream", "getRemoteProcessGroups", "equals", "getIdentifier", "findFirst", "filter", "stream", "getInputPorts", "equals", "getTargetId", "isPresent", "setIdentifier", "toString", "randomUUID", "setGroupIdentifier", "getIdentifier", "setRemoteGroupId", "setTargetId", "setName", "setComponentType", "isDestStillUsed", "removeRemoteInputPort", "add", "getInputPorts", "setName", "setDestination", "equals", "getId", "getId", "getGroupId", "setGroupId", "getGroupIdentifier", "getProcessGroupOrIllegalArgument", "getGroupId", "getFlowContent", "getVersionedComponentConnectable", "isPresent", "getGroupIdentifier", "getGroupIdentifier", "get", "equals", "getComponentType", "get", "containsChildGroup", "setDestination", "updateComponent", "clearValidationErrors", "getValidationService", "getId", "getSource", "getComponentConfiguration", "clearValidationErrors", "getValidationService", "getId", "getDestination", "getComponentConfiguration"]}, "repository": {"repo_id": 181071001, "url": "https://github.com/hortonworks/efm", "language": "Java", "is_fork": false, "fork_count": 5, "stargazer_count": 7, "size": 2003, "license": "licensed"}}