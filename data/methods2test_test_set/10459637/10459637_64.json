{"test_class": {"identifier": "RoleChangerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "public RoleChanger roleChanger;", "modifier": "public", "type": "RoleChanger", "declarator": "roleChanger", "var_name": "roleChanger"}], "file": "network-level/fl-ho-nl/src/test/java/net/floodlightcontroller/core/internal/RoleChangerTest.java"}, "test_case": {"identifier": "testSendRoleRequestSupported", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSendRoleRequestSupported() throws Exception {\n        LinkedList<OFSwitchImpl> switches = new LinkedList<OFSwitchImpl>();\n        \n        // a switch that supports role requests\n        OFSwitchImpl sw1 = EasyMock.createMock(OFSwitchImpl.class);\n        // No support for NX_ROLE\n        expect(sw1.getAttribute(IOFSwitch.SWITCH_SUPPORTS_NX_ROLE))\n                        .andReturn(true); \n        expect(sw1.sendNxRoleRequest(Role.MASTER, 123456)).andReturn(1).once();\n        switches.add(sw1);\n        \n        // a switch for which we don't have SUPPORTS_NX_ROLE yet\n        OFSwitchImpl sw2 = EasyMock.createMock(OFSwitchImpl.class);\n        // No support for NX_ROLE\n        expect(sw2.getAttribute(IOFSwitch.SWITCH_SUPPORTS_NX_ROLE))\n                        .andReturn(null); \n        expect(sw2.sendNxRoleRequest(Role.MASTER, 123456)).andReturn(1).once();\n        switches.add(sw2);\n        \n        \n        replay(sw1, sw2);\n        roleChanger.sendRoleRequest(switches, Role.MASTER, 123456);\n        verify(sw1, sw2);\n        \n        assertEquals(2, switches.size());\n    }", "signature": "void testSendRoleRequestSupported()", "full_signature": "@Test public void testSendRoleRequestSupported()", "class_method_signature": "RoleChangerTest.testSendRoleRequestSupported()", "testcase": true, "constructor": false, "invocations": ["createMock", "andReturn", "expect", "getAttribute", "once", "andReturn", "expect", "sendNxRoleRequest", "add", "createMock", "andReturn", "expect", "getAttribute", "once", "andReturn", "expect", "sendNxRoleRequest", "add", "replay", "sendRoleRequest", "verify", "assertEquals", "size"]}, "focal_class": {"identifier": "RoleChanger", "superclass": "", "interfaces": "", "fields": [{"original_string": "protected DelayQueue<RoleChangeTask> pendingTasks;", "modifier": "protected", "type": "DelayQueue<RoleChangeTask>", "declarator": "pendingTasks", "var_name": "pendingTasks"}, {"original_string": "protected long lastSubmitTime;", "modifier": "protected", "type": "long", "declarator": "lastSubmitTime", "var_name": "lastSubmitTime"}, {"original_string": "protected Thread workerThread;", "modifier": "protected", "type": "Thread", "declarator": "workerThread", "var_name": "workerThread"}, {"original_string": "protected long timeout;", "modifier": "protected", "type": "long", "declarator": "timeout", "var_name": "timeout"}, {"original_string": "protected static long DEFAULT_TIMEOUT = 15L*1000*1000*1000L;", "modifier": "protected static", "type": "long", "declarator": "DEFAULT_TIMEOUT = 15L*1000*1000*1000L", "var_name": "DEFAULT_TIMEOUT"}, {"original_string": "protected static Logger log = LoggerFactory.getLogger(RoleChanger.class);", "modifier": "protected static", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(RoleChanger.class)", "var_name": "log"}], "methods": [{"identifier": "RoleChanger", "parameters": "()", "modifiers": "public", "return": "", "signature": " RoleChanger()", "full_signature": "public  RoleChanger()", "class_method_signature": "RoleChanger.RoleChanger()", "testcase": false, "constructor": true}, {"identifier": "submitRequest", "parameters": "(Collection<OFSwitchImpl> switches, Role role)", "modifiers": "public synchronized", "return": "void", "signature": "void submitRequest(Collection<OFSwitchImpl> switches, Role role)", "full_signature": "public synchronized void submitRequest(Collection<OFSwitchImpl> switches, Role role)", "class_method_signature": "RoleChanger.submitRequest(Collection<OFSwitchImpl> switches, Role role)", "testcase": false, "constructor": false}, {"identifier": "sendRoleRequest", "parameters": "(Collection<OFSwitchImpl> switches,\n                                   Role role, long cookie)", "modifiers": "@LogMessageDoc(level=\"WARN\", message=\"Failed to send role request message \" + \"to switch {switch}: {message}. Disconnecting\", explanation=\"An I/O error occurred while attempting to change \" + \"the switch HA role.\", recommendation=LogMessageDoc.CHECK_SWITCH) protected", "return": "void", "signature": "void sendRoleRequest(Collection<OFSwitchImpl> switches,\n                                   Role role, long cookie)", "full_signature": "@LogMessageDoc(level=\"WARN\", message=\"Failed to send role request message \" + \"to switch {switch}: {message}. Disconnecting\", explanation=\"An I/O error occurred while attempting to change \" + \"the switch HA role.\", recommendation=LogMessageDoc.CHECK_SWITCH) protected void sendRoleRequest(Collection<OFSwitchImpl> switches,\n                                   Role role, long cookie)", "class_method_signature": "RoleChanger.sendRoleRequest(Collection<OFSwitchImpl> switches,\n                                   Role role, long cookie)", "testcase": false, "constructor": false}, {"identifier": "verifyRoleReplyReceived", "parameters": "(Collection<OFSwitchImpl> switches,\n                                   long cookie)", "modifiers": "@LogMessageDoc(level=\"WARN\", message=\"Timeout while waiting for role reply from switch {switch}.\" + \" Disconnecting\", explanation=\"Timed out waiting for the switch to respond to \" + \"a request to change the HA role.\", recommendation=LogMessageDoc.CHECK_SWITCH) protected", "return": "void", "signature": "void verifyRoleReplyReceived(Collection<OFSwitchImpl> switches,\n                                   long cookie)", "full_signature": "@LogMessageDoc(level=\"WARN\", message=\"Timeout while waiting for role reply from switch {switch}.\" + \" Disconnecting\", explanation=\"Timed out waiting for the switch to respond to \" + \"a request to change the HA role.\", recommendation=LogMessageDoc.CHECK_SWITCH) protected void verifyRoleReplyReceived(Collection<OFSwitchImpl> switches,\n                                   long cookie)", "class_method_signature": "RoleChanger.verifyRoleReplyReceived(Collection<OFSwitchImpl> switches,\n                                   long cookie)", "testcase": false, "constructor": false}], "file": "network-level/fl-ho-nl/src/main/java/net/floodlightcontroller/core/internal/RoleChanger.java"}, "focal_method": {"identifier": "sendRoleRequest", "parameters": "(Collection<OFSwitchImpl> switches,\n                                   Role role, long cookie)", "modifiers": "@LogMessageDoc(level=\"WARN\", message=\"Failed to send role request message \" + \"to switch {switch}: {message}. Disconnecting\", explanation=\"An I/O error occurred while attempting to change \" + \"the switch HA role.\", recommendation=LogMessageDoc.CHECK_SWITCH) protected", "return": "void", "body": "@LogMessageDoc(level=\"WARN\",\n            message=\"Failed to send role request message \" + \n                    \"to switch {switch}: {message}. Disconnecting\",\n            explanation=\"An I/O error occurred while attempting to change \" +\n            \t\t\"the switch HA role.\",\n            recommendation=LogMessageDoc.CHECK_SWITCH)                              \n    protected void sendRoleRequest(Collection<OFSwitchImpl> switches,\n                                   Role role, long cookie) {\n        // There are three cases to consider:\n        //\n        // 1) If the controller role at the point the switch connected was\n        //    null/disabled, then we never sent the role request probe to the\n        //    switch and therefore never set the SWITCH_SUPPORTS_NX_ROLE\n        //    attribute for the switch, so supportsNxRole is null. In that\n        //    case since we're now enabling role support for the controller\n        //    we should send out the role request probe/update to the switch.\n        //\n        // 2) If supportsNxRole == Boolean.TRUE then that means we've already\n        //    sent the role request probe to the switch and it replied with\n        //    a role reply message, so we know it supports role request\n        //    messages. Now we're changing the role and we want to send\n        //    it another role request message to inform it of the new role\n        //    for the controller.\n        //\n        // 3) If supportsNxRole == Boolean.FALSE, then that means we sent the\n        //    role request probe to the switch but it responded with an error\n        //    indicating that it didn't understand the role request message.\n        //    In that case we don't want to send it another role request that\n        //    it (still) doesn't understand. But if the new role of the\n        //    controller is SLAVE, then we don't want the switch to remain\n        //    connected to this controller. It might support the older serial\n        //    failover model for HA support, so we want to terminate the\n        //    connection and get it to initiate a connection with another\n        //    controller in its list of controllers. Eventually (hopefully, if\n        //    things are configured correctly) it will walk down its list of\n        //    controllers and connect to the current master controller.\n        Iterator<OFSwitchImpl> iter = switches.iterator();\n        while(iter.hasNext()) {\n            OFSwitchImpl sw = iter.next();\n            try {\n                Boolean supportsNxRole = (Boolean)\n                        sw.getAttribute(IOFSwitch.SWITCH_SUPPORTS_NX_ROLE);\n                if ((supportsNxRole == null) || supportsNxRole) {\n                    // Handle cases #1 and #2\n                    sw.sendNxRoleRequest(role, cookie);\n                } else {\n                    // Handle case #3\n                    if (role == Role.SLAVE) {\n                        log.debug(\"Disconnecting switch {} that doesn't support \" +\n                        \"role request messages from a controller that went to SLAVE mode\");\n                        // Closing the channel should result in a call to\n                        // channelDisconnect which updates all state \n                        sw.getChannel().close();\n                        iter.remove();\n                    }\n                }\n            } catch (IOException e) {\n                log.warn(\"Failed to send role request message \" + \n                         \"to switch {}: {}. Disconnecting\",\n                         sw, e);\n                sw.getChannel().close();\n                iter.remove();\n            }\n        }\n    }", "signature": "void sendRoleRequest(Collection<OFSwitchImpl> switches,\n                                   Role role, long cookie)", "full_signature": "@LogMessageDoc(level=\"WARN\", message=\"Failed to send role request message \" + \"to switch {switch}: {message}. Disconnecting\", explanation=\"An I/O error occurred while attempting to change \" + \"the switch HA role.\", recommendation=LogMessageDoc.CHECK_SWITCH) protected void sendRoleRequest(Collection<OFSwitchImpl> switches,\n                                   Role role, long cookie)", "class_method_signature": "RoleChanger.sendRoleRequest(Collection<OFSwitchImpl> switches,\n                                   Role role, long cookie)", "testcase": false, "constructor": false, "invocations": ["iterator", "hasNext", "next", "getAttribute", "sendNxRoleRequest", "debug", "close", "getChannel", "remove", "warn", "close", "getChannel", "remove"]}, "repository": {"repo_id": 10459637, "url": "https://github.com/rizard/geni-openflow-vertical-handover", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 7, "size": 33971, "license": "licensed"}}