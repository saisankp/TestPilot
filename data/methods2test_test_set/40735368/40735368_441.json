{"test_class": {"identifier": "PolygonExtractionProcessTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double TOL = 1.0e-6;", "modifier": "private static final", "type": "double", "declarator": "TOL = 1.0e-6", "var_name": "TOL"}, {"original_string": "private static final GridCoverageFactory covFactory = CoverageFactoryFinder.getGridCoverageFactory(null);", "modifier": "private static final", "type": "GridCoverageFactory", "declarator": "covFactory = CoverageFactoryFinder.getGridCoverageFactory(null)", "var_name": "covFactory"}, {"original_string": "private PolygonExtractionProcess process;", "modifier": "private", "type": "PolygonExtractionProcess", "declarator": "process", "var_name": "process"}], "file": "modules/unsupported/process-raster/src/test/java/org/geotools/process/raster/PolygonExtractionProcessTest.java"}, "test_case": {"identifier": "useROIToExcludeLeftAndRightImageCols", "parameters": "()", "modifiers": "@Ignore(\"See GEOT-3861\") @Test public", "return": "void", "body": "@Ignore(\"See GEOT-3861\")\n    @Test\n    public void useROIToExcludeLeftAndRightImageCols() {\n        final float[][] DATA = {\n            {0, 0, 0, 0, 0, 0, 0, 0},\n            {1, 1, 2, 2, 2, 2, 3, 3},\n            {1, 1, 2, 2, 2, 2, 3, 3},\n            {1, 1, 2, 2, 2, 2, 3, 3},\n            {1, 1, 2, 2, 2, 2, 3, 3},\n            {1, 1, 2, 2, 2, 2, 3, 3},\n            {0, 0, 0, 0, 0, 0, 0, 0}\n        };\n\n        final int width = DATA[0].length;\n        final int height = DATA.length;\n        final double cellSize = 1000;\n        \n        final double minX = 10000;\n        final double minY = 5000;\n        final double maxX = minX + width * cellSize;\n        final double maxY = minY + height * cellSize;\n        \n        final ReferencedEnvelope dataEnv = new ReferencedEnvelope(minX, maxX, minY, maxY, null);\n        \n        GridCoverage2D cov = covFactory.create(\"coverage\", DATA, dataEnv);\n\n        // Create an ROI that cuts off the left and right-most pixels\n        ReferencedEnvelope processEnv = new ReferencedEnvelope(\n                minX + cellSize, maxX - cellSize, minY, maxY, null);\n        \n        Polygon roiGeometry = JTS.toGeometry(processEnv);\n\n        SimpleFeatureCollection fc = process.execute(\n                cov, 0, Boolean.TRUE, roiGeometry, null, null, null);\n        \n        // Expected result is 3 polygons:\n        //   value == 1, area = 5 cells\n        //   value == 2, area = 20 cells\n        //   value == 3, area = 5 cells\n        assertEquals(3, fc.size());\n        \n        final double cellArea = cellSize * cellSize;\n        final double[] areas = { 5 * cellArea, 20 * cellArea, 5 * cellArea };\n        List<Integer> expectedValues = new ArrayList<Integer>();\n        expectedValues.addAll(Arrays.asList(1, 2, 3));\n        \n        SimpleFeatureIterator iter = fc.features();\n        try {\n            while (iter.hasNext()) {\n                SimpleFeature feature = iter.next();\n                Integer value = ((Number) feature.getAttribute(\"value\")).intValue();\n                System.out.println(value);\n                assertTrue(expectedValues.remove(value));\n                \n                Polygon poly = (Polygon) feature.getDefaultGeometry();\n                System.out.println(poly.toText());\n                assertEquals(areas[value - 1], poly.getArea(), TOL);\n            }\n        } finally {\n            iter.close();\n        }\n    }", "signature": "void useROIToExcludeLeftAndRightImageCols()", "full_signature": "@Ignore(\"See GEOT-3861\") @Test public void useROIToExcludeLeftAndRightImageCols()", "class_method_signature": "PolygonExtractionProcessTest.useROIToExcludeLeftAndRightImageCols()", "testcase": true, "constructor": false, "invocations": ["create", "toGeometry", "execute", "assertEquals", "size", "addAll", "asList", "features", "hasNext", "next", "intValue", "getAttribute", "println", "assertTrue", "remove", "getDefaultGeometry", "println", "toText", "assertEquals", "getArea", "close"]}, "focal_class": {"identifier": "PolygonExtractionProcess", "superclass": "", "interfaces": "implements RasterProcess", "fields": [], "methods": [{"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "modifiers": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public", "return": "SimpleFeatureCollection", "signature": "SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "full_signature": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "class_method_signature": "PolygonExtractionProcess.execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-raster/src/main/java/org/geotools/process/raster/PolygonExtractionProcess.java"}, "focal_method": {"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "modifiers": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public", "return": "SimpleFeatureCollection", "body": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\")\n    public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)\n            throws ProcessException {\n\n\n        //\n        // initial checks\n        //\n        if (coverage == null) {\n            throw new ProcessException(\"Invalid input, source grid coverage should be not null\");\n        }\n\n        if (band == null) {\n            band = 0;\n        } else if (band < 0 || band >= coverage.getNumSampleDimensions()) {\n            throw new ProcessException(\"Invalid input, invalid band number:\" + band);\n        }\n\n        // do we have classification ranges?\n        boolean hasClassificationRanges = classificationRanges != null && classificationRanges.size() > 0;\n\n        // apply the classification by setting 0 as the default value and using 1, ..., numClasses for the other classes.\n        // we use 0 also as the noData for the resulting coverage.\n        if (hasClassificationRanges) {\n\n            final RangeLookupProcess lookup = new RangeLookupProcess();\n            coverage = lookup.execute(\n                    coverage,\n                    band,\n                    classificationRanges,\n                    progressListener);\n        }\n\n        // Use noDataValues to set the \"outsideValues\" parameter of the Vectorize\n        // operation unless classificationRanges are in use, in which case the\n        // noDataValues arg is ignored.\n        List<Number> outsideValues = new ArrayList<Number>();\n        if (noDataValues != null && !hasClassificationRanges) {\n            outsideValues.addAll(noDataValues);\n        } else {\n            outsideValues.add(0);\n        }\n        \n        //\n        // GRID TO WORLD preparation\n        //\n        final AffineTransform mt2D = (AffineTransform) coverage.getGridGeometry().getGridToCRS2D(PixelOrientation.UPPER_LEFT);\n\n        // get the rendered image\n        final RenderedImage raster = coverage.getRenderedImage();\n\n        // perform jai operation\n        ParameterBlockJAI pb = new ParameterBlockJAI(\"Vectorize\");\n        pb.setSource(\"source0\", raster);\n\n        if (roi != null) {\n            pb.setParameter(\"roi\", CoverageUtilities.prepareROI(roi, mt2D));\n        }\n        pb.setParameter(\"band\", band);\n        pb.setParameter(\"outsideValues\", outsideValues);\n        if (insideEdges != null) {\n            pb.setParameter(\"insideEdges\", insideEdges);\n        }\n        // pb.setParameter(\"removeCollinear\", false);  \n\n        final RenderedOp dest = JAI.create(\"Vectorize\", pb);\n        @SuppressWarnings(\"unchecked\")\n        final Collection<Polygon> prop = (Collection<Polygon>) dest.getProperty(VectorizeDescriptor.VECTOR_PROPERTY_NAME);\n\n        // wrap as a feature collection and return\n        final SimpleFeatureType featureType = CoverageUtilities.createFeatureType(coverage, Polygon.class);\n        final SimpleFeatureBuilder builder = new SimpleFeatureBuilder(featureType);\n        int i = 0;\n        final ListFeatureCollection featureCollection = new ListFeatureCollection(featureType);\n        final AffineTransformation jtsTransformation = new AffineTransformation(\n                mt2D.getScaleX(),\n                mt2D.getShearX(),\n                mt2D.getTranslateX(),\n                mt2D.getShearY(),\n                mt2D.getScaleY(),\n                mt2D.getTranslateY());\n        for (Polygon polygon : prop) {\n            // get value\n            Double value = (Double) polygon.getUserData();\n            polygon.setUserData(null);\n            // filter coordinates in place\n            polygon.apply(jtsTransformation);\n\n            // create feature and add to list\n            builder.set(\"the_geom\", polygon);\n            builder.set(\"value\", value);\n\n            featureCollection.add(builder.buildFeature(String.valueOf(i++)));\n\n        }\n\n        //return value\n        return featureCollection;\n    }", "signature": "SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "full_signature": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "class_method_signature": "PolygonExtractionProcess.execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "testcase": false, "constructor": false, "invocations": ["getNumSampleDimensions", "size", "execute", "addAll", "add", "getGridToCRS2D", "getGridGeometry", "getRenderedImage", "setSource", "setParameter", "prepareROI", "setParameter", "setParameter", "setParameter", "create", "getProperty", "createFeatureType", "getScaleX", "getShearX", "getTranslateX", "getShearY", "getScaleY", "getTranslateY", "getUserData", "setUserData", "apply", "set", "set", "add", "buildFeature", "valueOf"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}