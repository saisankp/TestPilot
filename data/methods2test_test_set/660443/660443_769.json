{"test_class": {"identifier": "SimpleCycleBasisTest", "superclass": "extends CDKTestCase", "interfaces": "", "fields": [{"original_string": "private static SimpleGraph      g;", "modifier": "private static", "type": "SimpleGraph", "declarator": "g", "var_name": "g"}, {"original_string": "private static SimpleCycleBasis basis;", "modifier": "private static", "type": "SimpleCycleBasis", "declarator": "basis", "var_name": "basis"}], "file": "legacy/src/test/java/org/openscience/cdk/ringsearch/cyclebasis/SimpleCycleBasisTest.java"}, "test_case": {"identifier": "testEquivalenceClasses", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testEquivalenceClasses() {\n        Assert.assertEquals(4, basis.equivalenceClasses().size());\n    }", "signature": "void testEquivalenceClasses()", "full_signature": "@Test public void testEquivalenceClasses()", "class_method_signature": "SimpleCycleBasisTest.testEquivalenceClasses()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "size", "equivalenceClasses"]}, "focal_class": {"identifier": "SimpleCycleBasis", "superclass": "", "interfaces": "", "fields": [{"original_string": "private List              edgeList;", "modifier": "private", "type": "List", "declarator": "edgeList", "var_name": "edgeList"}, {"original_string": "private List<SimpleCycle> cycles;", "modifier": "private", "type": "List<SimpleCycle>", "declarator": "cycles", "var_name": "cycles"}, {"original_string": "private UndirectedGraph   graph;", "modifier": "private", "type": "UndirectedGraph", "declarator": "graph", "var_name": "graph"}, {"original_string": "private boolean           isMinimized = false;", "modifier": "private", "type": "boolean", "declarator": "isMinimized = false", "var_name": "isMinimized"}, {"original_string": "private HashMap           edgeIndexMap;", "modifier": "private", "type": "HashMap", "declarator": "edgeIndexMap", "var_name": "edgeIndexMap"}], "methods": [{"identifier": "SimpleCycleBasis", "parameters": "(List<SimpleCycle> cycles, List edgeList, UndirectedGraph graph)", "modifiers": "public", "return": "", "signature": " SimpleCycleBasis(List<SimpleCycle> cycles, List edgeList, UndirectedGraph graph)", "full_signature": "public  SimpleCycleBasis(List<SimpleCycle> cycles, List edgeList, UndirectedGraph graph)", "class_method_signature": "SimpleCycleBasis.SimpleCycleBasis(List<SimpleCycle> cycles, List edgeList, UndirectedGraph graph)", "testcase": false, "constructor": true}, {"identifier": "SimpleCycleBasis", "parameters": "(UndirectedGraph graph)", "modifiers": "public", "return": "", "signature": " SimpleCycleBasis(UndirectedGraph graph)", "full_signature": "public  SimpleCycleBasis(UndirectedGraph graph)", "class_method_signature": "SimpleCycleBasis.SimpleCycleBasis(UndirectedGraph graph)", "testcase": false, "constructor": true}, {"identifier": "createMinimumCycleBasis", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void createMinimumCycleBasis()", "full_signature": "private void createMinimumCycleBasis()", "class_method_signature": "SimpleCycleBasis.createMinimumCycleBasis()", "testcase": false, "constructor": false}, {"identifier": "getCycleEdgeIncidenceMatrix", "parameters": "()", "modifiers": "", "return": "boolean[][]", "signature": "boolean[][] getCycleEdgeIncidenceMatrix()", "full_signature": " boolean[][] getCycleEdgeIncidenceMatrix()", "class_method_signature": "SimpleCycleBasis.getCycleEdgeIncidenceMatrix()", "testcase": false, "constructor": false}, {"identifier": "getCycleEdgeIncidenceMatrix", "parameters": "(Object[] cycleArray)", "modifiers": "", "return": "boolean[][]", "signature": "boolean[][] getCycleEdgeIncidenceMatrix(Object[] cycleArray)", "full_signature": " boolean[][] getCycleEdgeIncidenceMatrix(Object[] cycleArray)", "class_method_signature": "SimpleCycleBasis.getCycleEdgeIncidenceMatrix(Object[] cycleArray)", "testcase": false, "constructor": false}, {"identifier": "minimize", "parameters": "(int startIndex)", "modifiers": "private", "return": "void", "signature": "void minimize(int startIndex)", "full_signature": "private void minimize(int startIndex)", "class_method_signature": "SimpleCycleBasis.minimize(int startIndex)", "testcase": false, "constructor": false}, {"identifier": "constructKernelVector", "parameters": "(int size, boolean[][] a, int i)", "modifiers": "static", "return": "boolean[]", "signature": "boolean[] constructKernelVector(int size, boolean[][] a, int i)", "full_signature": "static boolean[] constructKernelVector(int size, boolean[][] a, int i)", "class_method_signature": "SimpleCycleBasis.constructKernelVector(int size, boolean[][] a, int i)", "testcase": false, "constructor": false}, {"identifier": "weightVector", "parameters": "()", "modifiers": "public", "return": "int[]", "signature": "int[] weightVector()", "full_signature": "public int[] weightVector()", "class_method_signature": "SimpleCycleBasis.weightVector()", "testcase": false, "constructor": false}, {"identifier": "edges", "parameters": "()", "modifiers": "public", "return": "List", "signature": "List edges()", "full_signature": "public List edges()", "class_method_signature": "SimpleCycleBasis.edges()", "testcase": false, "constructor": false}, {"identifier": "cycles", "parameters": "()", "modifiers": "public", "return": "List", "signature": "List cycles()", "full_signature": "public List cycles()", "class_method_signature": "SimpleCycleBasis.cycles()", "testcase": false, "constructor": false}, {"identifier": "inverseBinaryMatrix", "parameters": "(boolean[][] m, int n)", "modifiers": "static", "return": "boolean[][]", "signature": "boolean[][] inverseBinaryMatrix(boolean[][] m, int n)", "full_signature": "static boolean[][] inverseBinaryMatrix(boolean[][] m, int n)", "class_method_signature": "SimpleCycleBasis.inverseBinaryMatrix(boolean[][] m, int n)", "testcase": false, "constructor": false}, {"identifier": "essentialCycles", "parameters": "()", "modifiers": "public", "return": "Collection", "signature": "Collection essentialCycles()", "full_signature": "public Collection essentialCycles()", "class_method_signature": "SimpleCycleBasis.essentialCycles()", "testcase": false, "constructor": false}, {"identifier": "relevantCycles", "parameters": "()", "modifiers": "public", "return": "Map", "signature": "Map relevantCycles()", "full_signature": "public Map relevantCycles()", "class_method_signature": "SimpleCycleBasis.relevantCycles()", "testcase": false, "constructor": false}, {"identifier": "equivalenceClasses", "parameters": "()", "modifiers": "public", "return": "List", "signature": "List equivalenceClasses()", "full_signature": "public List equivalenceClasses()", "class_method_signature": "SimpleCycleBasis.equivalenceClasses()", "testcase": false, "constructor": false}, {"identifier": "createEdgeIndexMap", "parameters": "(List edgeList)", "modifiers": "private", "return": "HashMap", "signature": "HashMap createEdgeIndexMap(List edgeList)", "full_signature": "private HashMap createEdgeIndexMap(List edgeList)", "class_method_signature": "SimpleCycleBasis.createEdgeIndexMap(List edgeList)", "testcase": false, "constructor": false}, {"identifier": "getEdgeIndex", "parameters": "(Edge edge)", "modifiers": "private", "return": "int", "signature": "int getEdgeIndex(Edge edge)", "full_signature": "private int getEdgeIndex(Edge edge)", "class_method_signature": "SimpleCycleBasis.getEdgeIndex(Edge edge)", "testcase": false, "constructor": false}, {"identifier": "printIncidenceMatrix", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void printIncidenceMatrix()", "full_signature": "public void printIncidenceMatrix()", "class_method_signature": "SimpleCycleBasis.printIncidenceMatrix()", "testcase": false, "constructor": false}], "file": "legacy/src/main/java/org/openscience/cdk/ringsearch/cyclebasis/SimpleCycleBasis.java"}, "focal_method": {"identifier": "equivalenceClasses", "parameters": "()", "modifiers": "public", "return": "List", "body": "public List equivalenceClasses() {\n        int[] weight = weightVector();\n\n        SimpleCycle[] cyclesArray = cycles.toArray(new SimpleCycle[cycles.size()]);\n        Arrays.sort(cyclesArray, new Comparator<SimpleCycle>() {\n\n            @Override\n            public int compare(SimpleCycle o1, SimpleCycle o2) {\n                if (o1.weight() > o2.weight()) return +1;\n                if (o1.weight() < o2.weight()) return -1;\n                return 0;\n            }\n        });\n\n        Collection essentialCycles = essentialCycles();\n\n        boolean[][] u = new boolean[cyclesArray.length][edgeList.size()];\n\n        boolean[][] a = getCycleEdgeIncidenceMatrix(cyclesArray);\n        boolean[][] ai = inverseBinaryMatrix(a, cyclesArray.length);\n\n        for (int i = 0; i < cyclesArray.length; i++) {\n            for (int j = 0; j < cyclesArray.length; j++) {\n                u[i][j] = ai[j][i];\n            }\n        }\n\n        UndirectedGraph h = new SimpleGraph();\n        h.addAllVertices(cycles);\n\n        ConnectivityInspector connectivityInspector = new ConnectivityInspector(h);\n\n        int left = 0;\n        for (int right = 0; right < weight.length; right++) {\n            if ((right < weight.length - 1) && (weight[right + 1] == weight[right])) continue;\n\n            // cyclesArray[left] to cyclesArray[right] have same weight\n\n            // First test (compute pre-classes):\n            // Check if there is a cycle that can replace a[i] as well as a[j] in a basis\n            // This is done by finding a cycle C with <C,u[i]>=1 and <C,u[j]>=1\n\n            for (int i = left; i <= right; i++) {\n                if (essentialCycles.contains((SimpleCycle) cyclesArray[i])) continue;\n\n                for (int j = i + 1; j <= right; j++) {\n                    if (essentialCycles.contains((SimpleCycle) cyclesArray[j])) continue;\n\n                    // check if cyclesArray[i] and cyclesArray[j] are already in the same class\n                    if (connectivityInspector.pathExists(cyclesArray[i], cyclesArray[j])) continue;\n\n                    boolean sameClass = false;\n\n                    AuxiliaryGraph2 auxGraph = new AuxiliaryGraph2(graph, u[i], u[j]);\n\n                    for (Iterator it = graph.vertexSet().iterator(); it.hasNext();) {\n                        Object vertex = it.next();\n\n                        // check if the vertex is incident to an edge with u[edge] == 1\n                        boolean shouldSearchCycle = false;\n\n                        Collection incidentEdges = graph.edgesOf(vertex);\n\n                        Iterator edgeIterator = incidentEdges.iterator();\n                        while (edgeIterator.hasNext()) {\n                            Edge edge = (Edge) edgeIterator.next();\n                            int index = getEdgeIndex(edge);\n                            if (u[i][index] || u[j][index]) {\n                                shouldSearchCycle = true;\n                                break;\n                            }\n                        }\n\n                        if (shouldSearchCycle) {\n\n                            Object auxVertex00 = auxGraph.auxVertex00(vertex);\n                            Object auxVertex11 = auxGraph.auxVertex11(vertex);\n\n                            List auxPath = BFSShortestPath.findPathBetween(auxGraph, auxVertex00, auxVertex11);\n\n                            double pathWeight = auxPath.size();\n\n                            if (pathWeight == weight[left]) {\n                                sameClass = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (sameClass) {\n                        h.addEdge(cyclesArray[i], cyclesArray[j]);\n                    }\n                }\n            }\n\n            // Second test (compute equivalence classes):\n            // Check if there are two cycle Ci, Cj that can replace a[i], a[j]\n            // and have a common cycle a[k] in their basis representation\n            // This is done by finding a cycle a[k] with <u[k],u[i]>=1 and <u[k],u[j]>=1\n\n            for (int i = left; i <= right; i++) {\n                if (essentialCycles.contains((SimpleCycle) cyclesArray[i])) continue;\n\n                for (int j = i + 1; j <= right; j++) {\n                    if (essentialCycles.contains((SimpleCycle) cyclesArray[j])) continue;\n\n                    // check if cyclesArray[i] and cyclesArray[j] are already in the same class\n                    if (connectivityInspector.pathExists(cyclesArray[i], cyclesArray[j])) continue;\n\n                    boolean sameClass = false;\n\n                    for (int k = 0; ((SimpleCycle) cyclesArray[k]).weight() < weight[left]; k++) {\n\n                        AuxiliaryGraph2 auxGraph = new AuxiliaryGraph2(graph, u[i], u[k]);\n\n                        boolean shortestPathFound = false;\n                        for (Iterator it = graph.vertexSet().iterator(); it.hasNext();) {\n                            Object vertex = it.next();\n\n                            Object auxVertex00 = auxGraph.auxVertex00(vertex);\n                            Object auxVertex11 = auxGraph.auxVertex11(vertex);\n\n                            List auxPath = BFSShortestPath.findPathBetween(auxGraph, auxVertex00, auxVertex11);\n\n                            double pathWeight = auxPath.size();\n\n                            if (pathWeight == weight[left]) {\n                                shortestPathFound = true;\n                                break;\n                            }\n                        }\n\n                        if (!shortestPathFound) continue;\n\n                        auxGraph = new AuxiliaryGraph2(graph, u[j], u[k]);\n\n                        for (Iterator it = graph.vertexSet().iterator(); it.hasNext();) {\n                            Object vertex = it.next();\n\n                            Object auxVertex00 = auxGraph.auxVertex00(vertex);\n                            Object auxVertex11 = auxGraph.auxVertex11(vertex);\n\n                            List auxPath = BFSShortestPath.findPathBetween(auxGraph, auxVertex00, auxVertex11);\n\n                            double pathWeight = auxPath.size();\n\n                            if (pathWeight == weight[left]) {\n                                sameClass = true;\n                                break;\n                            }\n                        }\n\n                        if (sameClass) break;\n                    }\n\n                    if (sameClass) {\n                        h.addEdge(cyclesArray[i], cyclesArray[j]);\n                    }\n                }\n            }\n\n            left = right + 1;\n        }\n\n        return connectivityInspector.connectedSets();\n    }", "signature": "List equivalenceClasses()", "full_signature": "public List equivalenceClasses()", "class_method_signature": "SimpleCycleBasis.equivalenceClasses()", "testcase": false, "constructor": false, "invocations": ["weightVector", "toArray", "size", "sort", "weight", "weight", "weight", "weight", "essentialCycles", "size", "getCycleEdgeIncidenceMatrix", "inverseBinaryMatrix", "addAllVertices", "contains", "contains", "pathExists", "iterator", "vertexSet", "hasNext", "next", "edgesOf", "iterator", "hasNext", "next", "getEdgeIndex", "auxVertex00", "auxVertex11", "findPathBetween", "size", "addEdge", "contains", "contains", "pathExists", "weight", "iterator", "vertexSet", "hasNext", "next", "auxVertex00", "auxVertex11", "findPathBetween", "size", "iterator", "vertexSet", "hasNext", "next", "auxVertex00", "auxVertex11", "findPathBetween", "size", "addEdge", "connectedSets"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}