{"test_class": {"identifier": "AbstractConditionStrategyTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static String SHARD_COL = \"SHARD_COL\";", "modifier": "private static", "type": "String", "declarator": "SHARD_COL = \"SHARD_COL\"", "var_name": "SHARD_COL"}, {"original_string": "private static String NORMAL_COL = \"NORMAL_COL\";", "modifier": "private static", "type": "String", "declarator": "NORMAL_COL = \"NORMAL_COL\"", "var_name": "NORMAL_COL"}, {"original_string": "private static String S0 = \"0\";", "modifier": "private static", "type": "String", "declarator": "S0 = \"0\"", "var_name": "S0"}, {"original_string": "private static String S1 = \"1\";", "modifier": "private static", "type": "String", "declarator": "S1 = \"1\"", "var_name": "S1"}, {"original_string": "private static String S2 = \"2\";", "modifier": "private static", "type": "String", "declarator": "S2 = \"2\"", "var_name": "S2"}, {"original_string": "private static String S3 = \"3\";", "modifier": "private static", "type": "String", "declarator": "S3 = \"3\"", "var_name": "S3"}, {"original_string": "private static String SX = \"X\";", "modifier": "private static", "type": "String", "declarator": "SX = \"X\"", "var_name": "SX"}, {"original_string": "private Object[][] data = new Object[][]{\n            //Single expression\n            {set(S0), exp(SHARD_COL, S0)},\n            {set(S1), exp(SHARD_COL, S1)},\n            {set(S2), exp(SHARD_COL, S2)},\n            {set(S3), exp(SHARD_COL, S3)},\n            \n            //For duplicate case\n            {set(S0), and(exp(SHARD_COL, S0), exp(SHARD_COL, S0))},\n            {set(S0), or(exp(SHARD_COL, S0), exp(SHARD_COL, S0))},\n            \n            //Base and or test\n            {non(), and(exp(SHARD_COL, S0), exp(SHARD_COL, S1))},\n            {set(S0, S1), or(exp(SHARD_COL, S0), exp(SHARD_COL, S1))},\n            \n            //For shard empty short-circuit case \n            {non(), and(exp(SHARD_COL, S0), exp(SHARD_COL, S1), exp(SHARD_COL, S1))},\n            {non(), and(exp(SHARD_COL, S0), exp(SHARD_COL, S1), exp(SHARD_COL, S2), exp(SHARD_COL, S3))},\n            \n            //For shard full short-circuit case\n            {all(), or(exp(SHARD_COL, S0), exp(SHARD_COL, S1), exp(SHARD_COL, S2), exp(SHARD_COL, S3))},\n\n            //For shard irrelevant column\n            {all(), exp(NORMAL_COL, S0)},\n            {set(S0), and(exp(SHARD_COL, S0), exp(NORMAL_COL, S0))},\n            {all(), or(exp(SHARD_COL, S0), exp(NORMAL_COL, S1))},\n            \n            //For nested case\n            {set(S1), and(exp(SHARD_COL, S1), and(exp(SHARD_COL, S1), and(exp(SHARD_COL, S1))))},\n            {set(S1), or(exp(SHARD_COL, S1), or(exp(SHARD_COL, S1), or(exp(SHARD_COL, S1))))},\n            \n            {non(), and(exp(SHARD_COL, S0), and(exp(SHARD_COL, S0), exp(SHARD_COL, S1)))},\n            {set(S0), and(exp(SHARD_COL, S0), or(exp(SHARD_COL, S0), exp(SHARD_COL, S1)))},\n            \n            //For deep nested case\n            {non(), and(exp(SHARD_COL, S0), and(exp(SHARD_COL, S0), exp(SHARD_COL, S1)))},\n            {set(S1), or(exp(SHARD_COL, S1), or(exp(SHARD_COL, S1), exp(SHARD_COL, S1)))},\n    };", "modifier": "private", "type": "Object[][]", "declarator": "data = new Object[][]{\n            //Single expression\n            {set(S0), exp(SHARD_COL, S0)},\n            {set(S1), exp(SHARD_COL, S1)},\n            {set(S2), exp(SHARD_COL, S2)},\n            {set(S3), exp(SHARD_COL, S3)},\n            \n            //For duplicate case\n            {set(S0), and(exp(SHARD_COL, S0), exp(SHARD_COL, S0))},\n            {set(S0), or(exp(SHARD_COL, S0), exp(SHARD_COL, S0))},\n            \n            //Base and or test\n            {non(), and(exp(SHARD_COL, S0), exp(SHARD_COL, S1))},\n            {set(S0, S1), or(exp(SHARD_COL, S0), exp(SHARD_COL, S1))},\n            \n            //For shard empty short-circuit case \n            {non(), and(exp(SHARD_COL, S0), exp(SHARD_COL, S1), exp(SHARD_COL, S1))},\n            {non(), and(exp(SHARD_COL, S0), exp(SHARD_COL, S1), exp(SHARD_COL, S2), exp(SHARD_COL, S3))},\n            \n            //For shard full short-circuit case\n            {all(), or(exp(SHARD_COL, S0), exp(SHARD_COL, S1), exp(SHARD_COL, S2), exp(SHARD_COL, S3))},\n\n            //For shard irrelevant column\n            {all(), exp(NORMAL_COL, S0)},\n            {set(S0), and(exp(SHARD_COL, S0), exp(NORMAL_COL, S0))},\n            {all(), or(exp(SHARD_COL, S0), exp(NORMAL_COL, S1))},\n            \n            //For nested case\n            {set(S1), and(exp(SHARD_COL, S1), and(exp(SHARD_COL, S1), and(exp(SHARD_COL, S1))))},\n            {set(S1), or(exp(SHARD_COL, S1), or(exp(SHARD_COL, S1), or(exp(SHARD_COL, S1))))},\n            \n            {non(), and(exp(SHARD_COL, S0), and(exp(SHARD_COL, S0), exp(SHARD_COL, S1)))},\n            {set(S0), and(exp(SHARD_COL, S0), or(exp(SHARD_COL, S0), exp(SHARD_COL, S1)))},\n            \n            //For deep nested case\n            {non(), and(exp(SHARD_COL, S0), and(exp(SHARD_COL, S0), exp(SHARD_COL, S1)))},\n            {set(S1), or(exp(SHARD_COL, S1), or(exp(SHARD_COL, S1), exp(SHARD_COL, S1)))},\n    }", "var_name": "data"}, {"original_string": "AbstractConditionStrategy test = new AbstractConditionStrategy() {\n\n        @Override\n        public boolean isDbShardingRelated(ConditionContext ctx) {\n            return ctx.getColumnName().equalsIgnoreCase(SHARD_COL);\n        }\n\n        @Override\n        public Set<String> locateDbShards(ConditionContext ctx) {\n            return set(ctx.getValue().toString());\n        }\n\n        @Override\n        public boolean isTableShardingRelated(TableConditionContext ctx) {\n            return ctx.getColumnName().equalsIgnoreCase(SHARD_COL);\n        }\n\n        @Override\n        public Set<String> locateTableShards(TableConditionContext ctx) {\n            return set(ctx.getValue().toString());\n        }\n\n        @Override\n        public Set<String> locateDbShardsByValue(ShardingContext ctx, Object shardValue) {\n            // TODO Auto-generated method stub\n            return null;\n        }\n\n        @Override\n        public Set<String> locateTableShardsByValue(TableShardingContext ctx, Object tableShardValue) {\n            // TODO Auto-generated method stub\n            return null;\n        }\n    };", "modifier": "", "type": "AbstractConditionStrategy", "declarator": "test = new AbstractConditionStrategy() {\n\n        @Override\n        public boolean isDbShardingRelated(ConditionContext ctx) {\n            return ctx.getColumnName().equalsIgnoreCase(SHARD_COL);\n        }\n\n        @Override\n        public Set<String> locateDbShards(ConditionContext ctx) {\n            return set(ctx.getValue().toString());\n        }\n\n        @Override\n        public boolean isTableShardingRelated(TableConditionContext ctx) {\n            return ctx.getColumnName().equalsIgnoreCase(SHARD_COL);\n        }\n\n        @Override\n        public Set<String> locateTableShards(TableConditionContext ctx) {\n            return set(ctx.getValue().toString());\n        }\n\n        @Override\n        public Set<String> locateDbShardsByValue(ShardingContext ctx, Object shardValue) {\n            // TODO Auto-generated method stub\n            return null;\n        }\n\n        @Override\n        public Set<String> locateTableShardsByValue(TableShardingContext ctx, Object tableShardValue) {\n            // TODO Auto-generated method stub\n            return null;\n        }\n    }", "var_name": "test"}], "file": "das-client/src/test/java/com/ppdai/das/strategy/AbstractConditionStrategyTest.java"}, "test_case": {"identifier": "testWrongDbTableConfig", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testWrongDbTableConfig() throws Exception {\n        Map<String, String> settings = new HashMap<>();\n        \n        try {\n            test.initialize(settings);\n            fail();\n        } catch (Exception e) {\n            assertEquals(e.getClass(), IllegalArgumentException.class);\n        }\n    }", "signature": "void testWrongDbTableConfig()", "full_signature": "@Test public void testWrongDbTableConfig()", "class_method_signature": "AbstractConditionStrategyTest.testWrongDbTableConfig()", "testcase": true, "constructor": false, "invocations": ["initialize", "fail", "assertEquals", "getClass"]}, "focal_class": {"identifier": "AbstractConditionStrategy", "superclass": "extends AbstractShardingStrategy", "interfaces": "", "fields": [{"original_string": "public static final String COLUMNS = \"columns\";", "modifier": "public static final", "type": "String", "declarator": "COLUMNS = \"columns\"", "var_name": "COLUMNS"}, {"original_string": "public static final String TABLE_COLUMNS = \"tableColumns\";", "modifier": "public static final", "type": "String", "declarator": "TABLE_COLUMNS = \"tableColumns\"", "var_name": "TABLE_COLUMNS"}, {"original_string": "private Set<String> dbShardColumns;", "modifier": "private", "type": "Set<String>", "declarator": "dbShardColumns", "var_name": "dbShardColumns"}, {"original_string": "private Set<String> tableShardColumns;", "modifier": "private", "type": "Set<String>", "declarator": "tableShardColumns", "var_name": "tableShardColumns"}], "methods": [{"identifier": "locateDbShardsByValue", "parameters": "(ShardingContext ctx, Object shardValue)", "modifiers": "public abstract", "return": "Set<String>", "signature": "Set<String> locateDbShardsByValue(ShardingContext ctx, Object shardValue)", "full_signature": "public abstract Set<String> locateDbShardsByValue(ShardingContext ctx, Object shardValue)", "class_method_signature": "AbstractConditionStrategy.locateDbShardsByValue(ShardingContext ctx, Object shardValue)", "testcase": false, "constructor": false}, {"identifier": "locateDbShards", "parameters": "(ConditionContext ctx)", "modifiers": "public abstract", "return": "Set<String>", "signature": "Set<String> locateDbShards(ConditionContext ctx)", "full_signature": "public abstract Set<String> locateDbShards(ConditionContext ctx)", "class_method_signature": "AbstractConditionStrategy.locateDbShards(ConditionContext ctx)", "testcase": false, "constructor": false}, {"identifier": "locateTableShardsByValue", "parameters": "(TableShardingContext ctx, Object tableShardValue)", "modifiers": "public abstract", "return": "Set<String>", "signature": "Set<String> locateTableShardsByValue(TableShardingContext ctx, Object tableShardValue)", "full_signature": "public abstract Set<String> locateTableShardsByValue(TableShardingContext ctx, Object tableShardValue)", "class_method_signature": "AbstractConditionStrategy.locateTableShardsByValue(TableShardingContext ctx, Object tableShardValue)", "testcase": false, "constructor": false}, {"identifier": "locateTableShards", "parameters": "(TableConditionContext ctx)", "modifiers": "public abstract", "return": "Set<String>", "signature": "Set<String> locateTableShards(TableConditionContext ctx)", "full_signature": "public abstract Set<String> locateTableShards(TableConditionContext ctx)", "class_method_signature": "AbstractConditionStrategy.locateTableShards(TableConditionContext ctx)", "testcase": false, "constructor": false}, {"identifier": "initialize", "parameters": "(Map<String, String> settings)", "modifiers": "@Override public", "return": "void", "signature": "void initialize(Map<String, String> settings)", "full_signature": "@Override public void initialize(Map<String, String> settings)", "class_method_signature": "AbstractConditionStrategy.initialize(Map<String, String> settings)", "testcase": false, "constructor": false}, {"identifier": "isDbShardingRelated", "parameters": "(ConditionContext ctx)", "modifiers": "protected", "return": "boolean", "signature": "boolean isDbShardingRelated(ConditionContext ctx)", "full_signature": "protected boolean isDbShardingRelated(ConditionContext ctx)", "class_method_signature": "AbstractConditionStrategy.isDbShardingRelated(ConditionContext ctx)", "testcase": false, "constructor": false}, {"identifier": "isTableShardingRelated", "parameters": "(TableConditionContext ctx)", "modifiers": "protected", "return": "boolean", "signature": "boolean isTableShardingRelated(TableConditionContext ctx)", "full_signature": "protected boolean isTableShardingRelated(TableConditionContext ctx)", "class_method_signature": "AbstractConditionStrategy.isTableShardingRelated(TableConditionContext ctx)", "testcase": false, "constructor": false}, {"identifier": "locateDbShards", "parameters": "(ShardingContext ctx)", "modifiers": "@Override public", "return": "Set<String>", "signature": "Set<String> locateDbShards(ShardingContext ctx)", "full_signature": "@Override public Set<String> locateDbShards(ShardingContext ctx)", "class_method_signature": "AbstractConditionStrategy.locateDbShards(ShardingContext ctx)", "testcase": false, "constructor": false}, {"identifier": "locateTableShards", "parameters": "(TableShardingContext ctx)", "modifiers": "@Override public", "return": "Set<String>", "signature": "Set<String> locateTableShards(TableShardingContext ctx)", "full_signature": "@Override public Set<String> locateTableShards(TableShardingContext ctx)", "class_method_signature": "AbstractConditionStrategy.locateTableShards(TableShardingContext ctx)", "testcase": false, "constructor": false}, {"identifier": "locateShards", "parameters": "(Predicate<ConditionContext> isRelated, Function<ConditionContext, Set<String>> locator, ShardingContext shardingContext, ConditionList conditions)", "modifiers": "private", "return": "Set<String>", "signature": "Set<String> locateShards(Predicate<ConditionContext> isRelated, Function<ConditionContext, Set<String>> locator, ShardingContext shardingContext, ConditionList conditions)", "full_signature": "private Set<String> locateShards(Predicate<ConditionContext> isRelated, Function<ConditionContext, Set<String>> locator, ShardingContext shardingContext, ConditionList conditions)", "class_method_signature": "AbstractConditionStrategy.locateShards(Predicate<ConditionContext> isRelated, Function<ConditionContext, Set<String>> locator, ShardingContext shardingContext, ConditionList conditions)", "testcase": false, "constructor": false}, {"identifier": "locateShards", "parameters": "(Predicate<ConditionContext> isRelated, Function<ConditionContext, Set<String>> locator, ShardingContext shardingContext, ColumnCondition condition)", "modifiers": "private", "return": "Set<String>", "signature": "Set<String> locateShards(Predicate<ConditionContext> isRelated, Function<ConditionContext, Set<String>> locator, ShardingContext shardingContext, ColumnCondition condition)", "full_signature": "private Set<String> locateShards(Predicate<ConditionContext> isRelated, Function<ConditionContext, Set<String>> locator, ShardingContext shardingContext, ColumnCondition condition)", "class_method_signature": "AbstractConditionStrategy.locateShards(Predicate<ConditionContext> isRelated, Function<ConditionContext, Set<String>> locator, ShardingContext shardingContext, ColumnCondition condition)", "testcase": false, "constructor": false}], "file": "das-client/src/main/java/com/ppdai/das/strategy/AbstractConditionStrategy.java"}, "focal_method": {"identifier": "initialize", "parameters": "(Map<String, String> settings)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void initialize(Map<String, String> settings) {\n        super.initialize(settings);\n        \n        if(settings.containsKey(COLUMNS)) {\n            dbShardColumns = parseNames(settings.get(COLUMNS));\n            setShardByDb(true);\n        }\n        \n        if(settings.containsKey(TABLE_COLUMNS)) {\n            tableShardColumns = parseNames(settings.get(TABLE_COLUMNS));\n            setShardByTable(true);\n        }\n\n        if(isShardByDb() == false && isShardByTable() == false) {\n            throw new IllegalArgumentException(\"Property \" + COLUMNS + \" or \" + TABLE_COLUMNS + \" is required for the strategy\");\n        }\n    }", "signature": "void initialize(Map<String, String> settings)", "full_signature": "@Override public void initialize(Map<String, String> settings)", "class_method_signature": "AbstractConditionStrategy.initialize(Map<String, String> settings)", "testcase": false, "constructor": false, "invocations": ["initialize", "containsKey", "parseNames", "get", "setShardByDb", "containsKey", "parseNames", "get", "setShardByTable", "isShardByDb", "isShardByTable"]}, "repository": {"repo_id": 214933909, "url": "https://github.com/ppdaicorp/das", "stars": 55, "created": "10/14/2019 2:49:17 AM +00:00", "updates": "2020-01-20T09:24:23+00:00", "fork": "False", "license": "licensed"}}