{"test_class": {"identifier": "StreamThreadTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final String clientId = \"clientId\";", "modifier": "private final", "type": "String", "declarator": "clientId = \"clientId\"", "var_name": "clientId"}, {"original_string": "private final String applicationId = \"stream-thread-test\";", "modifier": "private final", "type": "String", "declarator": "applicationId = \"stream-thread-test\"", "var_name": "applicationId"}, {"original_string": "private final UUID processId = UUID.randomUUID();", "modifier": "private final", "type": "UUID", "declarator": "processId = UUID.randomUUID()", "var_name": "processId"}, {"original_string": "private TopicPartition t1p1 = new TopicPartition(\"topic1\", 1);", "modifier": "private", "type": "TopicPartition", "declarator": "t1p1 = new TopicPartition(\"topic1\", 1)", "var_name": "t1p1"}, {"original_string": "private TopicPartition t1p2 = new TopicPartition(\"topic1\", 2);", "modifier": "private", "type": "TopicPartition", "declarator": "t1p2 = new TopicPartition(\"topic1\", 2)", "var_name": "t1p2"}, {"original_string": "private TopicPartition t2p1 = new TopicPartition(\"topic2\", 1);", "modifier": "private", "type": "TopicPartition", "declarator": "t2p1 = new TopicPartition(\"topic2\", 1)", "var_name": "t2p1"}, {"original_string": "private TopicPartition t2p2 = new TopicPartition(\"topic2\", 2);", "modifier": "private", "type": "TopicPartition", "declarator": "t2p2 = new TopicPartition(\"topic2\", 2)", "var_name": "t2p2"}, {"original_string": "private TopicPartition t3p1 = new TopicPartition(\"topic3\", 1);", "modifier": "private", "type": "TopicPartition", "declarator": "t3p1 = new TopicPartition(\"topic3\", 1)", "var_name": "t3p1"}, {"original_string": "private TopicPartition t3p2 = new TopicPartition(\"topic3\", 2);", "modifier": "private", "type": "TopicPartition", "declarator": "t3p2 = new TopicPartition(\"topic3\", 2)", "var_name": "t3p2"}, {"original_string": "private List<PartitionInfo> infos = Arrays.asList(\n            new PartitionInfo(\"topic1\", 0, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic1\", 1, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic1\", 2, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic2\", 0, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic2\", 1, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic2\", 2, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic3\", 0, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic3\", 1, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic3\", 2, Node.noNode(), new Node[0], new Node[0])\n    );", "modifier": "private", "type": "List<PartitionInfo>", "declarator": "infos = Arrays.asList(\n            new PartitionInfo(\"topic1\", 0, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic1\", 1, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic1\", 2, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic2\", 0, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic2\", 1, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic2\", 2, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic3\", 0, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic3\", 1, Node.noNode(), new Node[0], new Node[0]),\n            new PartitionInfo(\"topic3\", 2, Node.noNode(), new Node[0], new Node[0])\n    )", "var_name": "infos"}, {"original_string": "private Cluster metadata = new Cluster(Arrays.asList(Node.noNode()), infos, Collections.<String>emptySet());", "modifier": "private", "type": "Cluster", "declarator": "metadata = new Cluster(Arrays.asList(Node.noNode()), infos, Collections.<String>emptySet())", "var_name": "metadata"}, {"original_string": "private final PartitionAssignor.Subscription subscription =\n            new PartitionAssignor.Subscription(Arrays.asList(\"topic1\", \"topic2\", \"topic3\"), subscriptionUserData());", "modifier": "private final", "type": "PartitionAssignor.Subscription", "declarator": "subscription =\n            new PartitionAssignor.Subscription(Arrays.asList(\"topic1\", \"topic2\", \"topic3\"), subscriptionUserData())", "var_name": "subscription"}, {"original_string": "private final TaskId task1 = new TaskId(0, 1);", "modifier": "private final", "type": "TaskId", "declarator": "task1 = new TaskId(0, 1)", "var_name": "task1"}, {"original_string": "private final TaskId task2 = new TaskId(0, 2);", "modifier": "private final", "type": "TaskId", "declarator": "task2 = new TaskId(0, 2)", "var_name": "task2"}, {"original_string": "private final TaskId task3 = new TaskId(0, 3);", "modifier": "private final", "type": "TaskId", "declarator": "task3 = new TaskId(0, 3)", "var_name": "task3"}, {"original_string": "private final TaskId task4 = new TaskId(1, 1);", "modifier": "private final", "type": "TaskId", "declarator": "task4 = new TaskId(1, 1)", "var_name": "task4"}, {"original_string": "private final TaskId task5 = new TaskId(1, 2);", "modifier": "private final", "type": "TaskId", "declarator": "task5 = new TaskId(1, 2)", "var_name": "task5"}], "file": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java"}, "test_case": {"identifier": "testMaybeClean", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMaybeClean() throws Exception {\n        File baseDir = Files.createTempDirectory(\"test\").toFile();\n        try {\n            final long cleanupDelay = 1000L;\n            Properties props = configProps();\n            props.setProperty(StreamsConfig.STATE_CLEANUP_DELAY_MS_CONFIG, Long.toString(cleanupDelay));\n            props.setProperty(StreamsConfig.STATE_DIR_CONFIG, baseDir.getCanonicalPath());\n\n            StreamsConfig config = new StreamsConfig(props);\n\n            File applicationDir = new File(baseDir, applicationId);\n            applicationDir.mkdir();\n            File stateDir1 = new File(applicationDir, task1.toString());\n            File stateDir2 = new File(applicationDir, task2.toString());\n            File stateDir3 = new File(applicationDir, task3.toString());\n            File extraDir = new File(applicationDir, \"X\");\n            stateDir1.mkdir();\n            stateDir2.mkdir();\n            stateDir3.mkdir();\n            extraDir.mkdir();\n\n            MockTime mockTime = new MockTime();\n\n            TopologyBuilder builder = new TopologyBuilder();\n            builder.addSource(\"source1\", \"topic1\");\n\n            StreamThread thread = new StreamThread(builder, config, new MockClientSupplier(), applicationId, clientId,  processId, new Metrics(), mockTime) {\n                @Override\n                public void maybeClean() {\n                    super.maybeClean();\n                }\n\n                @Override\n                protected StreamTask createStreamTask(TaskId id, Collection<TopicPartition> partitionsForTask) {\n                    ProcessorTopology topology = builder.build(\"X\", id.topicGroupId);\n                    return new TestStreamTask(id, applicationId, partitionsForTask, topology, consumer, producer, restoreConsumer, config);\n                }\n            };\n\n            initPartitionGrouper(config, thread);\n\n            ConsumerRebalanceListener rebalanceListener = thread.rebalanceListener;\n\n            assertTrue(thread.tasks().isEmpty());\n            mockTime.sleep(cleanupDelay);\n\n            // all directories exist since an assignment didn't happen\n            assertTrue(stateDir1.exists());\n            assertTrue(stateDir2.exists());\n            assertTrue(stateDir3.exists());\n            assertTrue(extraDir.exists());\n\n            List<TopicPartition> revokedPartitions;\n            List<TopicPartition> assignedPartitions;\n            Map<Integer, StreamTask> prevTasks;\n\n            //\n            // Assign t1p1 and t1p2. This should create task1 & task2\n            //\n            revokedPartitions = Collections.emptyList();\n            assignedPartitions = Arrays.asList(t1p1, t1p2);\n            prevTasks = new HashMap(thread.tasks());\n\n            rebalanceListener.onPartitionsRevoked(revokedPartitions);\n            rebalanceListener.onPartitionsAssigned(assignedPartitions);\n\n            // there shouldn't be any previous task\n            assertTrue(prevTasks.isEmpty());\n\n            // task 1 & 2 are created\n            assertEquals(2, thread.tasks().size());\n\n            // all directories should still exit before the cleanup delay time\n            mockTime.sleep(cleanupDelay - 10L);\n            thread.maybeClean();\n            assertTrue(stateDir1.exists());\n            assertTrue(stateDir2.exists());\n            assertTrue(stateDir3.exists());\n            assertTrue(extraDir.exists());\n\n            // all state directories except for task task2 & task3 will be removed. the extra directory should still exists\n            mockTime.sleep(11L);\n            thread.maybeClean();\n            assertTrue(stateDir1.exists());\n            assertTrue(stateDir2.exists());\n            assertFalse(stateDir3.exists());\n            assertTrue(extraDir.exists());\n\n            //\n            // Revoke t1p1 and t1p2. This should remove task1 & task2\n            //\n            revokedPartitions = assignedPartitions;\n            assignedPartitions = Collections.emptyList();\n            prevTasks = new HashMap(thread.tasks());\n\n            rebalanceListener.onPartitionsRevoked(revokedPartitions);\n            rebalanceListener.onPartitionsAssigned(assignedPartitions);\n\n            // previous tasks should be committed\n            assertEquals(2, prevTasks.size());\n            for (StreamTask task : prevTasks.values()) {\n                assertTrue(((TestStreamTask) task).committed);\n                ((TestStreamTask) task).committed = false;\n            }\n\n            // no task\n            assertTrue(thread.tasks().isEmpty());\n\n            // all state directories for task task1 & task2 still exist before the cleanup delay time\n            mockTime.sleep(cleanupDelay - 10L);\n            thread.maybeClean();\n            assertTrue(stateDir1.exists());\n            assertTrue(stateDir2.exists());\n            assertFalse(stateDir3.exists());\n            assertTrue(extraDir.exists());\n\n            // all state directories for task task1 & task2 are removed\n            mockTime.sleep(11L);\n            thread.maybeClean();\n            assertFalse(stateDir1.exists());\n            assertFalse(stateDir2.exists());\n            assertFalse(stateDir3.exists());\n            assertTrue(extraDir.exists());\n\n        } finally {\n            Utils.delete(baseDir);\n        }\n    }", "signature": "void testMaybeClean()", "full_signature": "@Test public void testMaybeClean()", "class_method_signature": "StreamThreadTest.testMaybeClean()", "testcase": true, "constructor": false, "invocations": ["toFile", "createTempDirectory", "configProps", "setProperty", "toString", "setProperty", "getCanonicalPath", "mkdir", "toString", "toString", "toString", "mkdir", "mkdir", "mkdir", "mkdir", "addSource", "maybeClean", "build", "initPartitionGrouper", "assertTrue", "isEmpty", "tasks", "sleep", "assertTrue", "exists", "assertTrue", "exists", "assertTrue", "exists", "assertTrue", "exists", "emptyList", "asList", "tasks", "onPartitionsRevoked", "onPartitionsAssigned", "assertTrue", "isEmpty", "assertEquals", "size", "tasks", "sleep", "maybeClean", "assertTrue", "exists", "assertTrue", "exists", "assertTrue", "exists", "assertTrue", "exists", "sleep", "maybeClean", "assertTrue", "exists", "assertTrue", "exists", "assertFalse", "exists", "assertTrue", "exists", "emptyList", "tasks", "onPartitionsRevoked", "onPartitionsAssigned", "assertEquals", "size", "values", "assertTrue", "assertTrue", "isEmpty", "tasks", "sleep", "maybeClean", "assertTrue", "exists", "assertTrue", "exists", "assertFalse", "exists", "assertTrue", "exists", "sleep", "maybeClean", "assertFalse", "exists", "assertFalse", "exists", "assertFalse", "exists", "assertTrue", "exists", "delete"]}, "focal_class": {"identifier": "StreamThread", "superclass": "extends Thread", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(StreamThread.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(StreamThread.class)", "var_name": "log"}, {"original_string": "private static final AtomicInteger STREAM_THREAD_ID_SEQUENCE = new AtomicInteger(1);", "modifier": "private static final", "type": "AtomicInteger", "declarator": "STREAM_THREAD_ID_SEQUENCE = new AtomicInteger(1)", "var_name": "STREAM_THREAD_ID_SEQUENCE"}, {"original_string": "public final PartitionGrouper partitionGrouper;", "modifier": "public final", "type": "PartitionGrouper", "declarator": "partitionGrouper", "var_name": "partitionGrouper"}, {"original_string": "public final String applicationId;", "modifier": "public final", "type": "String", "declarator": "applicationId", "var_name": "applicationId"}, {"original_string": "public final String clientId;", "modifier": "public final", "type": "String", "declarator": "clientId", "var_name": "clientId"}, {"original_string": "public final UUID processId;", "modifier": "public final", "type": "UUID", "declarator": "processId", "var_name": "processId"}, {"original_string": "protected final StreamsConfig config;", "modifier": "protected final", "type": "StreamsConfig", "declarator": "config", "var_name": "config"}, {"original_string": "protected final TopologyBuilder builder;", "modifier": "protected final", "type": "TopologyBuilder", "declarator": "builder", "var_name": "builder"}, {"original_string": "protected final Set<String> sourceTopics;", "modifier": "protected final", "type": "Set<String>", "declarator": "sourceTopics", "var_name": "sourceTopics"}, {"original_string": "protected final Producer<byte[], byte[]> producer;", "modifier": "protected final", "type": "Producer<byte[], byte[]>", "declarator": "producer", "var_name": "producer"}, {"original_string": "protected final Consumer<byte[], byte[]> consumer;", "modifier": "protected final", "type": "Consumer<byte[], byte[]>", "declarator": "consumer", "var_name": "consumer"}, {"original_string": "protected final Consumer<byte[], byte[]> restoreConsumer;", "modifier": "protected final", "type": "Consumer<byte[], byte[]>", "declarator": "restoreConsumer", "var_name": "restoreConsumer"}, {"original_string": "private final AtomicBoolean running;", "modifier": "private final", "type": "AtomicBoolean", "declarator": "running", "var_name": "running"}, {"original_string": "private final Map<TaskId, StreamTask> activeTasks;", "modifier": "private final", "type": "Map<TaskId, StreamTask>", "declarator": "activeTasks", "var_name": "activeTasks"}, {"original_string": "private final Map<TaskId, StandbyTask> standbyTasks;", "modifier": "private final", "type": "Map<TaskId, StandbyTask>", "declarator": "standbyTasks", "var_name": "standbyTasks"}, {"original_string": "private final Map<TopicPartition, StreamTask> activeTasksByPartition;", "modifier": "private final", "type": "Map<TopicPartition, StreamTask>", "declarator": "activeTasksByPartition", "var_name": "activeTasksByPartition"}, {"original_string": "private final Map<TopicPartition, StandbyTask> standbyTasksByPartition;", "modifier": "private final", "type": "Map<TopicPartition, StandbyTask>", "declarator": "standbyTasksByPartition", "var_name": "standbyTasksByPartition"}, {"original_string": "private final Set<TaskId> prevTasks;", "modifier": "private final", "type": "Set<TaskId>", "declarator": "prevTasks", "var_name": "prevTasks"}, {"original_string": "private final Time time;", "modifier": "private final", "type": "Time", "declarator": "time", "var_name": "time"}, {"original_string": "private final File stateDir;", "modifier": "private final", "type": "File", "declarator": "stateDir", "var_name": "stateDir"}, {"original_string": "private final long pollTimeMs;", "modifier": "private final", "type": "long", "declarator": "pollTimeMs", "var_name": "pollTimeMs"}, {"original_string": "private final long cleanTimeMs;", "modifier": "private final", "type": "long", "declarator": "cleanTimeMs", "var_name": "cleanTimeMs"}, {"original_string": "private final long commitTimeMs;", "modifier": "private final", "type": "long", "declarator": "commitTimeMs", "var_name": "commitTimeMs"}, {"original_string": "private final StreamsMetricsImpl sensors;", "modifier": "private final", "type": "StreamsMetricsImpl", "declarator": "sensors", "var_name": "sensors"}, {"original_string": "private StreamPartitionAssignor partitionAssignor = null;", "modifier": "private", "type": "StreamPartitionAssignor", "declarator": "partitionAssignor = null", "var_name": "partitionAssignor"}, {"original_string": "private long lastClean;", "modifier": "private", "type": "long", "declarator": "lastClean", "var_name": "lastClean"}, {"original_string": "private long lastCommit;", "modifier": "private", "type": "long", "declarator": "lastCommit", "var_name": "lastCommit"}, {"original_string": "private Throwable rebalanceException = null;", "modifier": "private", "type": "Throwable", "declarator": "rebalanceException = null", "var_name": "rebalanceException"}, {"original_string": "private Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> standbyRecords;", "modifier": "private", "type": "Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>>", "declarator": "standbyRecords", "var_name": "standbyRecords"}, {"original_string": "private boolean processStandbyRecords = false;", "modifier": "private", "type": "boolean", "declarator": "processStandbyRecords = false", "var_name": "processStandbyRecords"}, {"original_string": "final ConsumerRebalanceListener rebalanceListener = new ConsumerRebalanceListener() {\n        @Override\n        public void onPartitionsAssigned(Collection<TopicPartition> assignment) {\n            try {\n                addStreamTasks(assignment);\n                addStandbyTasks();\n                lastClean = time.milliseconds(); // start the cleaning cycle\n            } catch (Throwable t) {\n                rebalanceException = t;\n                throw t;\n            }\n        }\n\n        @Override\n        public void onPartitionsRevoked(Collection<TopicPartition> assignment) {\n            try {\n                commitAll();\n                lastClean = Long.MAX_VALUE; // stop the cleaning cycle until partitions are assigned\n            } catch (Throwable t) {\n                rebalanceException = t;\n                throw t;\n            } finally {\n                // TODO: right now upon partition revocation, we always remove all the tasks;\n                // this behavior can be optimized to only remove affected tasks in the future\n                removeStreamTasks();\n                removeStandbyTasks();\n            }\n        }\n    };", "modifier": "final", "type": "ConsumerRebalanceListener", "declarator": "rebalanceListener = new ConsumerRebalanceListener() {\n        @Override\n        public void onPartitionsAssigned(Collection<TopicPartition> assignment) {\n            try {\n                addStreamTasks(assignment);\n                addStandbyTasks();\n                lastClean = time.milliseconds(); // start the cleaning cycle\n            } catch (Throwable t) {\n                rebalanceException = t;\n                throw t;\n            }\n        }\n\n        @Override\n        public void onPartitionsRevoked(Collection<TopicPartition> assignment) {\n            try {\n                commitAll();\n                lastClean = Long.MAX_VALUE; // stop the cleaning cycle until partitions are assigned\n            } catch (Throwable t) {\n                rebalanceException = t;\n                throw t;\n            } finally {\n                // TODO: right now upon partition revocation, we always remove all the tasks;\n                // this behavior can be optimized to only remove affected tasks in the future\n                removeStreamTasks();\n                removeStandbyTasks();\n            }\n        }\n    }", "var_name": "rebalanceListener"}], "methods": [{"identifier": "makeStateDir", "parameters": "(String applicationId, String baseDirName)", "modifiers": "static", "return": "File", "signature": "File makeStateDir(String applicationId, String baseDirName)", "full_signature": "static File makeStateDir(String applicationId, String baseDirName)", "class_method_signature": "StreamThread.makeStateDir(String applicationId, String baseDirName)", "testcase": false, "constructor": false}, {"identifier": "StreamThread", "parameters": "(TopologyBuilder builder,\n                        StreamsConfig config,\n                        KafkaClientSupplier clientSupplier,\n                        String applicationId,\n                        String clientId,\n                        UUID processId,\n                        Metrics metrics,\n                        Time time)", "modifiers": "public", "return": "", "signature": " StreamThread(TopologyBuilder builder,\n                        StreamsConfig config,\n                        KafkaClientSupplier clientSupplier,\n                        String applicationId,\n                        String clientId,\n                        UUID processId,\n                        Metrics metrics,\n                        Time time)", "full_signature": "public  StreamThread(TopologyBuilder builder,\n                        StreamsConfig config,\n                        KafkaClientSupplier clientSupplier,\n                        String applicationId,\n                        String clientId,\n                        UUID processId,\n                        Metrics metrics,\n                        Time time)", "class_method_signature": "StreamThread.StreamThread(TopologyBuilder builder,\n                        StreamsConfig config,\n                        KafkaClientSupplier clientSupplier,\n                        String applicationId,\n                        String clientId,\n                        UUID processId,\n                        Metrics metrics,\n                        Time time)", "testcase": false, "constructor": true}, {"identifier": "partitionAssignor", "parameters": "(StreamPartitionAssignor partitionAssignor)", "modifiers": "public", "return": "void", "signature": "void partitionAssignor(StreamPartitionAssignor partitionAssignor)", "full_signature": "public void partitionAssignor(StreamPartitionAssignor partitionAssignor)", "class_method_signature": "StreamThread.partitionAssignor(StreamPartitionAssignor partitionAssignor)", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "StreamThread.run()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "StreamThread.close()", "testcase": false, "constructor": false}, {"identifier": "tasks", "parameters": "()", "modifiers": "public", "return": "Map<TaskId, StreamTask>", "signature": "Map<TaskId, StreamTask> tasks()", "full_signature": "public Map<TaskId, StreamTask> tasks()", "class_method_signature": "StreamThread.tasks()", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void shutdown()", "full_signature": "private void shutdown()", "class_method_signature": "StreamThread.shutdown()", "testcase": false, "constructor": false}, {"identifier": "runLoop", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void runLoop()", "full_signature": "private void runLoop()", "class_method_signature": "StreamThread.runLoop()", "testcase": false, "constructor": false}, {"identifier": "maybeUpdateStandbyTasks", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void maybeUpdateStandbyTasks()", "full_signature": "private void maybeUpdateStandbyTasks()", "class_method_signature": "StreamThread.maybeUpdateStandbyTasks()", "testcase": false, "constructor": false}, {"identifier": "stillRunning", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean stillRunning()", "full_signature": "private boolean stillRunning()", "class_method_signature": "StreamThread.stillRunning()", "testcase": false, "constructor": false}, {"identifier": "maybePunctuate", "parameters": "(StreamTask task)", "modifiers": "private", "return": "void", "signature": "void maybePunctuate(StreamTask task)", "full_signature": "private void maybePunctuate(StreamTask task)", "class_method_signature": "StreamThread.maybePunctuate(StreamTask task)", "testcase": false, "constructor": false}, {"identifier": "maybeCommit", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void maybeCommit()", "full_signature": "protected void maybeCommit()", "class_method_signature": "StreamThread.maybeCommit()", "testcase": false, "constructor": false}, {"identifier": "commitAll", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void commitAll()", "full_signature": "private void commitAll()", "class_method_signature": "StreamThread.commitAll()", "testcase": false, "constructor": false}, {"identifier": "commitOne", "parameters": "(AbstractTask task, long now)", "modifiers": "private", "return": "void", "signature": "void commitOne(AbstractTask task, long now)", "full_signature": "private void commitOne(AbstractTask task, long now)", "class_method_signature": "StreamThread.commitOne(AbstractTask task, long now)", "testcase": false, "constructor": false}, {"identifier": "maybeClean", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void maybeClean()", "full_signature": "protected void maybeClean()", "class_method_signature": "StreamThread.maybeClean()", "testcase": false, "constructor": false}, {"identifier": "prevTasks", "parameters": "()", "modifiers": "public", "return": "Set<TaskId>", "signature": "Set<TaskId> prevTasks()", "full_signature": "public Set<TaskId> prevTasks()", "class_method_signature": "StreamThread.prevTasks()", "testcase": false, "constructor": false}, {"identifier": "cachedTasks", "parameters": "()", "modifiers": "public", "return": "Set<TaskId>", "signature": "Set<TaskId> cachedTasks()", "full_signature": "public Set<TaskId> cachedTasks()", "class_method_signature": "StreamThread.cachedTasks()", "testcase": false, "constructor": false}, {"identifier": "createStreamTask", "parameters": "(TaskId id, Collection<TopicPartition> partitions)", "modifiers": "protected", "return": "StreamTask", "signature": "StreamTask createStreamTask(TaskId id, Collection<TopicPartition> partitions)", "full_signature": "protected StreamTask createStreamTask(TaskId id, Collection<TopicPartition> partitions)", "class_method_signature": "StreamThread.createStreamTask(TaskId id, Collection<TopicPartition> partitions)", "testcase": false, "constructor": false}, {"identifier": "addStreamTasks", "parameters": "(Collection<TopicPartition> assignment)", "modifiers": "private", "return": "void", "signature": "void addStreamTasks(Collection<TopicPartition> assignment)", "full_signature": "private void addStreamTasks(Collection<TopicPartition> assignment)", "class_method_signature": "StreamThread.addStreamTasks(Collection<TopicPartition> assignment)", "testcase": false, "constructor": false}, {"identifier": "removeStreamTasks", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void removeStreamTasks()", "full_signature": "private void removeStreamTasks()", "class_method_signature": "StreamThread.removeStreamTasks()", "testcase": false, "constructor": false}, {"identifier": "closeOne", "parameters": "(AbstractTask task)", "modifiers": "private", "return": "void", "signature": "void closeOne(AbstractTask task)", "full_signature": "private void closeOne(AbstractTask task)", "class_method_signature": "StreamThread.closeOne(AbstractTask task)", "testcase": false, "constructor": false}, {"identifier": "createStandbyTask", "parameters": "(TaskId id, Collection<TopicPartition> partitions)", "modifiers": "protected", "return": "StandbyTask", "signature": "StandbyTask createStandbyTask(TaskId id, Collection<TopicPartition> partitions)", "full_signature": "protected StandbyTask createStandbyTask(TaskId id, Collection<TopicPartition> partitions)", "class_method_signature": "StreamThread.createStandbyTask(TaskId id, Collection<TopicPartition> partitions)", "testcase": false, "constructor": false}, {"identifier": "addStandbyTasks", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void addStandbyTasks()", "full_signature": "private void addStandbyTasks()", "class_method_signature": "StreamThread.addStandbyTasks()", "testcase": false, "constructor": false}, {"identifier": "removeStandbyTasks", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void removeStandbyTasks()", "full_signature": "private void removeStandbyTasks()", "class_method_signature": "StreamThread.removeStandbyTasks()", "testcase": false, "constructor": false}], "file": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java"}, "focal_method": {"identifier": "maybeClean", "parameters": "()", "modifiers": "protected", "return": "void", "body": "protected void maybeClean() {\n        long now = time.milliseconds();\n\n        if (now > lastClean + cleanTimeMs) {\n            File[] stateDirs = stateDir.listFiles();\n            if (stateDirs != null) {\n                for (File dir : stateDirs) {\n                    try {\n                        String dirName = dir.getName();\n                        TaskId id = TaskId.parse(dirName.substring(dirName.lastIndexOf(\"-\") + 1));\n\n                        // try to acquire the exclusive lock on the state directory\n                        if (dir.exists()) {\n                            FileLock directoryLock = null;\n                            try {\n                                directoryLock = ProcessorStateManager.lockStateDirectory(dir);\n                                if (directoryLock != null) {\n                                    log.info(\"Deleting obsolete state directory {} for task {} after delayed {} ms.\", dir.getAbsolutePath(), id, cleanTimeMs);\n                                    Utils.delete(dir);\n                                }\n                            } catch (FileNotFoundException e) {\n                                // the state directory may be deleted by another thread\n                            } catch (IOException e) {\n                                log.error(\"Failed to lock the state directory due to an unexpected exception\", e);\n                            } finally {\n                                if (directoryLock != null) {\n                                    try {\n                                        directoryLock.release();\n                                        directoryLock.channel().close();\n                                    } catch (IOException e) {\n                                        log.error(\"Failed to release the state directory lock\");\n                                    }\n                                }\n                            }\n                        }\n                    } catch (TaskIdFormatException e) {\n                        // there may be some unknown files that sits in the same directory,\n                        // we should ignore these files instead trying to delete them as well\n                    }\n                }\n            }\n\n            lastClean = now;\n        }\n    }", "signature": "void maybeClean()", "full_signature": "protected void maybeClean()", "class_method_signature": "StreamThread.maybeClean()", "testcase": false, "constructor": false, "invocations": ["milliseconds", "listFiles", "getName", "parse", "substring", "lastIndexOf", "exists", "lockStateDirectory", "info", "getAbsolutePath", "delete", "error", "release", "close", "channel", "error"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}