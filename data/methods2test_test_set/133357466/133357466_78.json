{"test_class": {"identifier": "MonetaryFormatTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final MonetaryFormat NO_CODE = MonetaryFormat.BTC.noCode();", "modifier": "private static final", "type": "MonetaryFormat", "declarator": "NO_CODE = MonetaryFormat.BTC.noCode()", "var_name": "NO_CODE"}, {"original_string": "private static final Fiat ONE_EURO = Fiat.parseFiat(\"EUR\", \"1\");", "modifier": "private static final", "type": "Fiat", "declarator": "ONE_EURO = Fiat.parseFiat(\"EUR\", \"1\")", "var_name": "ONE_EURO"}], "file": "core/src/test/java/org/ulordj/utils/MonetaryFormatTest.java"}, "test_case": {"identifier": "standardCodes", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void standardCodes() throws Exception {\n        assertEquals(\"BTC 0.00\", MonetaryFormat.BTC.format(Coin.ZERO).toString());\n        assertEquals(\"mBTC 0.00\", MonetaryFormat.MBTC.format(Coin.ZERO).toString());\n        assertEquals(\"\u00b5BTC 0\", MonetaryFormat.UBTC.format(Coin.ZERO).toString());\n    }", "signature": "void standardCodes()", "full_signature": "@Test public void standardCodes()", "class_method_signature": "MonetaryFormatTest.standardCodes()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "toString", "format", "assertEquals", "toString", "format", "assertEquals", "oString(", "ormat("]}, "focal_class": {"identifier": "MonetaryFormat", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final MonetaryFormat BTC = new MonetaryFormat().shift(0).minDecimals(2).repeatOptionalDecimals(2, 3);", "modifier": "public static final", "type": "MonetaryFormat", "declarator": "BTC = new MonetaryFormat().shift(0).minDecimals(2).repeatOptionalDecimals(2, 3)", "var_name": "BTC"}, {"original_string": "public static final MonetaryFormat MBTC = new MonetaryFormat().shift(3).minDecimals(2).optionalDecimals(2);", "modifier": "public static final", "type": "MonetaryFormat", "declarator": "MBTC = new MonetaryFormat().shift(3).minDecimals(2).optionalDecimals(2)", "var_name": "MBTC"}, {"original_string": "public static final MonetaryFormat UBTC = new MonetaryFormat().shift(6).minDecimals(0).optionalDecimals(2);", "modifier": "public static final", "type": "MonetaryFormat", "declarator": "UBTC = new MonetaryFormat().shift(6).minDecimals(0).optionalDecimals(2)", "var_name": "UBTC"}, {"original_string": "public static final MonetaryFormat FIAT = new MonetaryFormat().shift(0).minDecimals(2).repeatOptionalDecimals(2, 1);", "modifier": "public static final", "type": "MonetaryFormat", "declarator": "FIAT = new MonetaryFormat().shift(0).minDecimals(2).repeatOptionalDecimals(2, 1)", "var_name": "FIAT"}, {"original_string": "public static final String CODE_BTC = \"BTC\";", "modifier": "public static final", "type": "String", "declarator": "CODE_BTC = \"BTC\"", "var_name": "CODE_BTC"}, {"original_string": "public static final String CODE_MBTC = \"mBTC\";", "modifier": "public static final", "type": "String", "declarator": "CODE_MBTC = \"mBTC\"", "var_name": "CODE_MBTC"}, {"original_string": "public static final String CODE_UBTC = \"\u00b5BTC\";", "modifier": "public static final", "type": "String", "declarator": "CODE_UBTC = \"\u00b5BTC\";", "var_name": "CODE_UBTC"}, {"original_string": "public static final int MAX_DECIMALS = 8;", "modifier": "public static final", "type": "int", "declarator": "MAX_DECIMALS = 8", "var_name": "MAX_DECIMALS"}, {"original_string": "private final char negativeSign;", "modifier": "private final", "type": "char", "declarator": "negativeSign", "var_name": "negativeSign"}, {"original_string": "private final char positiveSign;", "modifier": "private final", "type": "char", "declarator": "positiveSign", "var_name": "positiveSign"}, {"original_string": "private final char zeroDigit;", "modifier": "private final", "type": "char", "declarator": "zeroDigit", "var_name": "zeroDigit"}, {"original_string": "private final char decimalMark;", "modifier": "private final", "type": "char", "declarator": "decimalMark", "var_name": "decimalMark"}, {"original_string": "private final int minDecimals;", "modifier": "private final", "type": "int", "declarator": "minDecimals", "var_name": "minDecimals"}, {"original_string": "private final List<Integer> decimalGroups;", "modifier": "private final", "type": "List<Integer>", "declarator": "decimalGroups", "var_name": "decimalGroups"}, {"original_string": "private final int shift;", "modifier": "private final", "type": "int", "declarator": "shift", "var_name": "shift"}, {"original_string": "private final RoundingMode roundingMode;", "modifier": "private final", "type": "RoundingMode", "declarator": "roundingMode", "var_name": "roundingMode"}, {"original_string": "private final String[] codes;", "modifier": "private final", "type": "String[]", "declarator": "codes", "var_name": "codes"}, {"original_string": "private final char codeSeparator;", "modifier": "private final", "type": "char", "declarator": "codeSeparator", "var_name": "codeSeparator"}, {"original_string": "private final boolean codePrefixed;", "modifier": "private final", "type": "boolean", "declarator": "codePrefixed", "var_name": "codePrefixed"}, {"original_string": "private static final String DECIMALS_PADDING = \"0000000000000000\";", "modifier": "private static final", "type": "String", "declarator": "DECIMALS_PADDING = \"0000000000000000\"", "var_name": "DECIMALS_PADDING"}], "methods": [{"identifier": "negativeSign", "parameters": "(char negativeSign)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat negativeSign(char negativeSign)", "full_signature": "public MonetaryFormat negativeSign(char negativeSign)", "class_method_signature": "MonetaryFormat.negativeSign(char negativeSign)", "testcase": false, "constructor": false}, {"identifier": "positiveSign", "parameters": "(char positiveSign)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat positiveSign(char positiveSign)", "full_signature": "public MonetaryFormat positiveSign(char positiveSign)", "class_method_signature": "MonetaryFormat.positiveSign(char positiveSign)", "testcase": false, "constructor": false}, {"identifier": "digits", "parameters": "(char zeroDigit)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat digits(char zeroDigit)", "full_signature": "public MonetaryFormat digits(char zeroDigit)", "class_method_signature": "MonetaryFormat.digits(char zeroDigit)", "testcase": false, "constructor": false}, {"identifier": "decimalMark", "parameters": "(char decimalMark)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat decimalMark(char decimalMark)", "full_signature": "public MonetaryFormat decimalMark(char decimalMark)", "class_method_signature": "MonetaryFormat.decimalMark(char decimalMark)", "testcase": false, "constructor": false}, {"identifier": "minDecimals", "parameters": "(int minDecimals)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat minDecimals(int minDecimals)", "full_signature": "public MonetaryFormat minDecimals(int minDecimals)", "class_method_signature": "MonetaryFormat.minDecimals(int minDecimals)", "testcase": false, "constructor": false}, {"identifier": "optionalDecimals", "parameters": "(int... groups)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat optionalDecimals(int... groups)", "full_signature": "public MonetaryFormat optionalDecimals(int... groups)", "class_method_signature": "MonetaryFormat.optionalDecimals(int... groups)", "testcase": false, "constructor": false}, {"identifier": "repeatOptionalDecimals", "parameters": "(int decimals, int repetitions)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat repeatOptionalDecimals(int decimals, int repetitions)", "full_signature": "public MonetaryFormat repeatOptionalDecimals(int decimals, int repetitions)", "class_method_signature": "MonetaryFormat.repeatOptionalDecimals(int decimals, int repetitions)", "testcase": false, "constructor": false}, {"identifier": "shift", "parameters": "(int shift)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat shift(int shift)", "full_signature": "public MonetaryFormat shift(int shift)", "class_method_signature": "MonetaryFormat.shift(int shift)", "testcase": false, "constructor": false}, {"identifier": "roundingMode", "parameters": "(RoundingMode roundingMode)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat roundingMode(RoundingMode roundingMode)", "full_signature": "public MonetaryFormat roundingMode(RoundingMode roundingMode)", "class_method_signature": "MonetaryFormat.roundingMode(RoundingMode roundingMode)", "testcase": false, "constructor": false}, {"identifier": "noCode", "parameters": "()", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat noCode()", "full_signature": "public MonetaryFormat noCode()", "class_method_signature": "MonetaryFormat.noCode()", "testcase": false, "constructor": false}, {"identifier": "code", "parameters": "(int codeShift, String code)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat code(int codeShift, String code)", "full_signature": "public MonetaryFormat code(int codeShift, String code)", "class_method_signature": "MonetaryFormat.code(int codeShift, String code)", "testcase": false, "constructor": false}, {"identifier": "codeSeparator", "parameters": "(char codeSeparator)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat codeSeparator(char codeSeparator)", "full_signature": "public MonetaryFormat codeSeparator(char codeSeparator)", "class_method_signature": "MonetaryFormat.codeSeparator(char codeSeparator)", "testcase": false, "constructor": false}, {"identifier": "prefixCode", "parameters": "()", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat prefixCode()", "full_signature": "public MonetaryFormat prefixCode()", "class_method_signature": "MonetaryFormat.prefixCode()", "testcase": false, "constructor": false}, {"identifier": "postfixCode", "parameters": "()", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat postfixCode()", "full_signature": "public MonetaryFormat postfixCode()", "class_method_signature": "MonetaryFormat.postfixCode()", "testcase": false, "constructor": false}, {"identifier": "withLocale", "parameters": "(Locale locale)", "modifiers": "public", "return": "MonetaryFormat", "signature": "MonetaryFormat withLocale(Locale locale)", "full_signature": "public MonetaryFormat withLocale(Locale locale)", "class_method_signature": "MonetaryFormat.withLocale(Locale locale)", "testcase": false, "constructor": false}, {"identifier": "MonetaryFormat", "parameters": "()", "modifiers": "public", "return": "", "signature": " MonetaryFormat()", "full_signature": "public  MonetaryFormat()", "class_method_signature": "MonetaryFormat.MonetaryFormat()", "testcase": false, "constructor": true}, {"identifier": "MonetaryFormat", "parameters": "(char negativeSign, char positiveSign, char zeroDigit, char decimalMark, int minDecimals,\n            List<Integer> decimalGroups, int shift, RoundingMode roundingMode, String[] codes,\n            char codeSeparator, boolean codePrefixed)", "modifiers": "private", "return": "", "signature": " MonetaryFormat(char negativeSign, char positiveSign, char zeroDigit, char decimalMark, int minDecimals,\n            List<Integer> decimalGroups, int shift, RoundingMode roundingMode, String[] codes,\n            char codeSeparator, boolean codePrefixed)", "full_signature": "private  MonetaryFormat(char negativeSign, char positiveSign, char zeroDigit, char decimalMark, int minDecimals,\n            List<Integer> decimalGroups, int shift, RoundingMode roundingMode, String[] codes,\n            char codeSeparator, boolean codePrefixed)", "class_method_signature": "MonetaryFormat.MonetaryFormat(char negativeSign, char positiveSign, char zeroDigit, char decimalMark, int minDecimals,\n            List<Integer> decimalGroups, int shift, RoundingMode roundingMode, String[] codes,\n            char codeSeparator, boolean codePrefixed)", "testcase": false, "constructor": true}, {"identifier": "format", "parameters": "(Monetary monetary)", "modifiers": "public", "return": "CharSequence", "signature": "CharSequence format(Monetary monetary)", "full_signature": "public CharSequence format(Monetary monetary)", "class_method_signature": "MonetaryFormat.format(Monetary monetary)", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "(String str)", "modifiers": "public", "return": "Coin", "signature": "Coin parse(String str)", "full_signature": "public Coin parse(String str)", "class_method_signature": "MonetaryFormat.parse(String str)", "testcase": false, "constructor": false}, {"identifier": "parseFiat", "parameters": "(String currencyCode, String str)", "modifiers": "public", "return": "Fiat", "signature": "Fiat parseFiat(String currencyCode, String str)", "full_signature": "public Fiat parseFiat(String currencyCode, String str)", "class_method_signature": "MonetaryFormat.parseFiat(String currencyCode, String str)", "testcase": false, "constructor": false}, {"identifier": "parseValue", "parameters": "(String str, int smallestUnitExponent)", "modifiers": "private", "return": "long", "signature": "long parseValue(String str, int smallestUnitExponent)", "full_signature": "private long parseValue(String str, int smallestUnitExponent)", "class_method_signature": "MonetaryFormat.parseValue(String str, int smallestUnitExponent)", "testcase": false, "constructor": false}, {"identifier": "code", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String code()", "full_signature": "public String code()", "class_method_signature": "MonetaryFormat.code()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(final Object o)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(final Object o)", "full_signature": "@Override public boolean equals(final Object o)", "class_method_signature": "MonetaryFormat.equals(final Object o)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "MonetaryFormat.hashCode()", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/ulordj/utils/MonetaryFormat.java"}, "focal_method": {"identifier": "format", "parameters": "(Monetary monetary)", "modifiers": "public", "return": "CharSequence", "body": "public CharSequence format(Monetary monetary) {\n        // preparation\n        int maxDecimals = minDecimals;\n        if (decimalGroups != null)\n            for (int group : decimalGroups)\n                maxDecimals += group;\n        int smallestUnitExponent = monetary.smallestUnitExponent();\n        checkState(maxDecimals <= smallestUnitExponent,\n                \"The maximum possible number of decimals (%s) cannot exceed %s.\", maxDecimals, smallestUnitExponent);\n\n        // rounding\n        long satoshis = Math.abs(monetary.getValue());\n        long precisionDivisor = checkedPow(10, smallestUnitExponent - shift - maxDecimals);\n        satoshis = checkedMultiply(divide(satoshis, precisionDivisor, roundingMode), precisionDivisor);\n\n        // shifting\n        long shiftDivisor = checkedPow(10, smallestUnitExponent - shift);\n        long numbers = satoshis / shiftDivisor;\n        long decimals = satoshis % shiftDivisor;\n\n        // formatting\n        String decimalsStr = String.format(Locale.US, \"%0\" + (smallestUnitExponent - shift) + \"d\", decimals);\n        StringBuilder str = new StringBuilder(decimalsStr);\n        while (str.length() > minDecimals && str.charAt(str.length() - 1) == '0')\n            str.setLength(str.length() - 1); // trim trailing zero\n        int i = minDecimals;\n        if (decimalGroups != null) {\n            for (int group : decimalGroups) {\n                if (str.length() > i && str.length() < i + group) {\n                    while (str.length() < i + group)\n                        str.append('0');\n                    break;\n                }\n                i += group;\n            }\n        }\n        if (str.length() > 0)\n            str.insert(0, decimalMark);\n        str.insert(0, numbers);\n        if (monetary.getValue() < 0)\n            str.insert(0, negativeSign);\n        else if (positiveSign != 0)\n            str.insert(0, positiveSign);\n        if (codes != null) {\n            if (codePrefixed) {\n                str.insert(0, codeSeparator);\n                str.insert(0, code());\n            } else {\n                str.append(codeSeparator);\n                str.append(code());\n            }\n        }\n\n        // Convert to non-arabic digits.\n        if (zeroDigit != '0') {\n            int offset = zeroDigit - '0';\n            for (int d = 0; d < str.length(); d++) {\n                char c = str.charAt(d);\n                if (Character.isDigit(c))\n                    str.setCharAt(d, (char) (c + offset));\n            }\n        }\n        return str;\n    }", "signature": "CharSequence format(Monetary monetary)", "full_signature": "public CharSequence format(Monetary monetary)", "class_method_signature": "MonetaryFormat.format(Monetary monetary)", "testcase": false, "constructor": false, "invocations": ["smallestUnitExponent", "checkState", "abs", "getValue", "checkedPow", "checkedMultiply", "divide", "checkedPow", "format", "length", "charAt", "length", "setLength", "length", "length", "length", "length", "append", "length", "insert", "insert", "getValue", "insert", "insert", "insert", "insert", "code", "append", "append", "code", "length", "charAt", "isDigit", "setCharAt"]}, "repository": {"repo_id": 133357466, "url": "https://github.com/UlordChain/ulordj", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 23, "size": 7129, "license": "licensed"}}