{"test_class": {"identifier": "StreamSerializerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final long CURRENT = System.currentTimeMillis();", "modifier": "private static final", "type": "long", "declarator": "CURRENT = System.currentTimeMillis()", "var_name": "CURRENT"}], "file": "core/src/test/java/org/apache/flink/streaming/siddhi/schema/StreamSerializerTest.java"}, "test_case": {"identifier": "testTupleType", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testTupleType() {\n        Tuple4 row = Tuple4.of(1, \"test\", 56.7, CURRENT);\n        StreamSchema<Tuple4> schema = new StreamSchema<>(new TupleTypeInfo<>(\n                TypeExtractor.createTypeInfo(Integer.class),\n                TypeExtractor.createTypeInfo(String.class),\n                TypeExtractor.createTypeInfo(Double.class),\n                TypeExtractor.createTypeInfo(Long.class))\n                , \"id\", \"name\", \"price\", \"timestamp\");\n        StreamSerializer<Tuple4> reader = new StreamSerializer<>(schema);\n        Assert.assertArrayEquals(new Object[]{1, \"test\", 56.7, CURRENT}, reader.getRow(row));\n    }", "signature": "void testTupleType()", "full_signature": "@Test public void testTupleType()", "class_method_signature": "StreamSerializerTest.testTupleType()", "testcase": true, "constructor": false, "invocations": ["of", "createTypeInfo", "createTypeInfo", "createTypeInfo", "createTypeInfo", "assertArrayEquals", "getRow"]}, "focal_class": {"identifier": "StreamSerializer", "superclass": "", "interfaces": "implements Serializable", "fields": [{"original_string": "private final StreamSchema<T> schema;", "modifier": "private final", "type": "StreamSchema<T>", "declarator": "schema", "var_name": "schema"}], "methods": [{"identifier": "StreamSerializer", "parameters": "(StreamSchema<T> schema)", "modifiers": "public", "return": "", "signature": " StreamSerializer(StreamSchema<T> schema)", "full_signature": "public  StreamSerializer(StreamSchema<T> schema)", "class_method_signature": "StreamSerializer.StreamSerializer(StreamSchema<T> schema)", "testcase": false, "constructor": true}, {"identifier": "getRow", "parameters": "(T input)", "modifiers": "public", "return": "Object[]", "signature": "Object[] getRow(T input)", "full_signature": "public Object[] getRow(T input)", "class_method_signature": "StreamSerializer.getRow(T input)", "testcase": false, "constructor": false}, {"identifier": "getFieldValue", "parameters": "(String fieldName, T input)", "modifiers": "private", "return": "Object", "signature": "Object getFieldValue(String fieldName, T input)", "full_signature": "private Object getFieldValue(String fieldName, T input)", "class_method_signature": "StreamSerializer.getFieldValue(String fieldName, T input)", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/apache/flink/streaming/siddhi/schema/StreamSerializer.java"}, "focal_method": {"identifier": "getRow", "parameters": "(T input)", "modifiers": "public", "return": "Object[]", "body": "public Object[] getRow(T input) {\n        Preconditions.checkArgument(input.getClass() == schema.getTypeInfo().getTypeClass(),\n            \"Invalid input type: \" + input + \", expected: \" + schema.getTypeInfo());\n\n        Object[] data;\n        if (schema.isAtomicType()) {\n            data = new Object[]{input};\n        } else if (schema.isTupleType()) {\n            Tuple tuple = (Tuple) input;\n            data = new Object[schema.getFieldIndexes().length];\n            for (int i = 0; i < schema.getFieldIndexes().length; i++) {\n                data[i] = tuple.getField(schema.getFieldIndexes()[i]);\n            }\n        } else if (schema.isRowType()) {\n            Row row = (Row) input;\n            data = new Object[schema.getFieldIndexes().length];\n            for (int i = 0; i < schema.getFieldIndexes().length; i++) {\n                data[i] = row.getField(schema.getFieldIndexes()[i]);\n            }\n        } else if (schema.isPojoType() || schema.isCaseClassType()) {\n            data = new Object[schema.getFieldIndexes().length];\n            for (int i = 0; i < schema.getFieldNames().length; i++) {\n                data[i] = getFieldValue(schema.getFieldNames()[i], input);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Failed to get field values from \" + schema.getTypeInfo());\n        }\n        return data;\n    }", "signature": "Object[] getRow(T input)", "full_signature": "public Object[] getRow(T input)", "class_method_signature": "StreamSerializer.getRow(T input)", "testcase": false, "constructor": false, "invocations": ["checkArgument", "getClass", "getTypeClass", "getTypeInfo", "getTypeInfo", "isAtomicType", "isTupleType", "getFieldIndexes", "getFieldIndexes", "getField", "getFieldIndexes", "isRowType", "getFieldIndexes", "getFieldIndexes", "getField", "getFieldIndexes", "isPojoType", "isCaseClassType", "getFieldIndexes", "getFieldNames", "getFieldValue", "getFieldNames", "getTypeInfo"]}, "repository": {"repo_id": 67913797, "url": "https://github.com/haoch/flink-siddhi", "language": "Java", "is_fork": false, "fork_count": 72, "stargazer_count": 148, "size": 635, "license": "licensed"}}