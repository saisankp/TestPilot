{"test_class": {"identifier": "AccessIntervalTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Mock\n    private User userMock;", "modifier": "@Mock\n    private", "type": "User", "declarator": "userMock", "var_name": "userMock"}, {"original_string": "@Mock\n    private User otherUserMock;", "modifier": "@Mock\n    private", "type": "User", "declarator": "otherUserMock", "var_name": "otherUserMock"}, {"original_string": "private Clock clock;", "modifier": "private", "type": "Clock", "declarator": "clock", "var_name": "clock"}], "file": "backend/project-board/src/test/java/de/adesso/projectboard/base/access/persistence/AccessIntervalTest.java"}, "test_case": {"identifier": "equalsReturnsFalseForDifferentUserIds", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void equalsReturnsFalseForDifferentUserIds() {\n        // given\n        var accessIntervalId = 1L;\n        var userId = \"user\";\n        var otherUserId = \"other-user\";\n        var startTime = LocalDateTime.now(clock);\n        var endTime = LocalDateTime.now(clock).plus(1L, ChronoUnit.DAYS);\n\n        given(userMock.getId()).willReturn(userId);\n        given(otherUserMock.getId()).willReturn(otherUserId);\n\n        var accessInterval = new AccessInterval(userMock, startTime, endTime);\n        accessInterval.id = accessIntervalId;\n\n        var otherAccessInterval = new AccessInterval(otherUserMock, startTime, endTime);\n        otherAccessInterval.id = accessIntervalId;\n\n        // when\n        boolean actualEquals = accessInterval.equals(otherAccessInterval);\n\n        // then\n        assertThat(actualEquals).isFalse();\n    }", "signature": "void equalsReturnsFalseForDifferentUserIds()", "full_signature": "@Test public void equalsReturnsFalseForDifferentUserIds()", "class_method_signature": "AccessIntervalTest.equalsReturnsFalseForDifferentUserIds()", "testcase": true, "constructor": false, "invocations": ["now", "plus", "now", "willReturn", "given", "getId", "willReturn", "given", "getId", "equals", "isFalse", "assertThat"]}, "focal_class": {"identifier": "AccessInterval", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    Long id;", "modifier": "@Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)", "type": "Long", "declarator": "id", "var_name": "id"}, {"original_string": "@ManyToOne\n    @JoinColumn(\n            name = \"USER_ID\",\n            nullable = false\n    )\n    User user;", "modifier": "@ManyToOne\n    @JoinColumn(\n            name = \"USER_ID\",\n            nullable = false\n    )", "type": "User", "declarator": "user", "var_name": "user"}, {"original_string": "@Column(\n            name = \"START_TIME\",\n            nullable = false\n    )\n    LocalDateTime startTime;", "modifier": "@Column(\n            name = \"START_TIME\",\n            nullable = false\n    )", "type": "LocalDateTime", "declarator": "startTime", "var_name": "startTime"}, {"original_string": "@Column(\n            name = \"END_TIME\",\n            nullable = false\n    )\n    LocalDateTime endTime;", "modifier": "@Column(\n            name = \"END_TIME\",\n            nullable = false\n    )", "type": "LocalDateTime", "declarator": "endTime", "var_name": "endTime"}], "methods": [{"identifier": "AccessInterval", "parameters": "(User user, LocalDateTime startTime, LocalDateTime endTime)", "modifiers": "public", "return": "", "signature": " AccessInterval(User user, LocalDateTime startTime, LocalDateTime endTime)", "full_signature": "public  AccessInterval(User user, LocalDateTime startTime, LocalDateTime endTime)", "class_method_signature": "AccessInterval.AccessInterval(User user, LocalDateTime startTime, LocalDateTime endTime)", "testcase": false, "constructor": true}, {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "AccessInterval.equals(Object obj)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "AccessInterval.hashCode()", "testcase": false, "constructor": false}], "file": "backend/project-board/src/main/java/de/adesso/projectboard/base/access/persistence/AccessInterval.java"}, "focal_method": {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "body": "@Override\n    public boolean equals(Object obj) {\n        if(this == obj) {\n            return true;\n        }\n\n        if(obj instanceof AccessInterval) {\n            AccessInterval other = (AccessInterval) obj;\n\n            // only compare the user IDs because of the cyclic reference: User <-> AccessInterval\n            boolean userEquals;\n            if(Objects.nonNull(this.user) && Objects.nonNull(other.user)) {\n                userEquals = Objects.equals(this.user.getId(), other.user.getId());\n            } else {\n                userEquals = Objects.isNull(this.user) && Objects.isNull(other.user);\n            }\n\n            return userEquals &&\n                    Objects.equals(this.id, other.id) &&\n                    Objects.equals(this.startTime, other.startTime) &&\n                    Objects.equals(this.endTime, other.endTime);\n        }\n\n        return false;\n    }", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "AccessInterval.equals(Object obj)", "testcase": false, "constructor": false, "invocations": ["nonNull", "nonNull", "equals", "getId", "getId", "isNull", "isNull", "equals", "equals", "equals"]}, "repository": {"repo_id": 144251992, "url": "https://github.com/adessoAG/project-board", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 8, "size": 2608, "license": "licensed"}}