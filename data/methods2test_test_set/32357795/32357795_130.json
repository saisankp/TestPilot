{"test_class": {"identifier": "CachedIndexTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private CachedIndex index;", "modifier": "private", "type": "CachedIndex", "declarator": "index", "var_name": "index"}], "file": "ontopia-engine/src/test/java/net/ontopia/utils/CachedIndexTest.java"}, "test_case": {"identifier": "testPrune", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testPrune() {\n    index = new CachedIndex(new SameIndex(), 250, 5, true);\n\n    for (int ix = 0; ix < 10000; ix++) {\n      String key = Integer.toString((int) (Math.random() * 500));\n      Assert.assertTrue(\"didn't find value\",\n             index.get(key).equals(key));\n    }\n\n    Assert.assertTrue(\"number of keys in index too high\",\n           index.getKeyNumber() <= 250);\n  }", "signature": "void testPrune()", "full_signature": "@Test public void testPrune()", "class_method_signature": "CachedIndexTest.testPrune()", "testcase": true, "constructor": false, "invocations": ["toString", "random", "assertTrue", "equals", "get", "assertTrue", "getKeyNumber"]}, "focal_class": {"identifier": "CachedIndex", "superclass": "", "interfaces": "implements LookupIndexIF<K, E>", "fields": [{"original_string": "private LookupIndexIF<K, E> fallback;", "modifier": "private", "type": "LookupIndexIF<K, E>", "declarator": "fallback", "var_name": "fallback"}, {"original_string": "private int           max;", "modifier": "private", "type": "int", "declarator": "max", "var_name": "max"}, {"original_string": "private int           entries;", "modifier": "private", "type": "int", "declarator": "entries", "var_name": "entries"}, {"original_string": "private int           decay;", "modifier": "private", "type": "int", "declarator": "decay", "var_name": "decay"}, {"original_string": "private Entry[]       data;", "modifier": "private", "type": "Entry[]", "declarator": "data", "var_name": "data"}, {"original_string": "private double        threshold;", "modifier": "private", "type": "double", "declarator": "threshold", "var_name": "threshold"}, {"original_string": "private boolean       nulls;", "modifier": "private", "type": "boolean", "declarator": "nulls", "var_name": "nulls"}, {"original_string": "private long          lookups;", "modifier": "private", "type": "long", "declarator": "lookups", "var_name": "lookups"}, {"original_string": "private long          hits;", "modifier": "private", "type": "long", "declarator": "hits", "var_name": "hits"}, {"original_string": "private long          rehashes;", "modifier": "private", "type": "long", "declarator": "rehashes", "var_name": "rehashes"}, {"original_string": "private long          prunings;", "modifier": "private", "type": "long", "declarator": "prunings", "var_name": "prunings"}], "methods": [{"identifier": "CachedIndex", "parameters": "(LookupIndexIF<K, E> fallback)", "modifiers": "public", "return": "", "signature": " CachedIndex(LookupIndexIF<K, E> fallback)", "full_signature": "public  CachedIndex(LookupIndexIF<K, E> fallback)", "class_method_signature": "CachedIndex.CachedIndex(LookupIndexIF<K, E> fallback)", "testcase": false, "constructor": true}, {"identifier": "CachedIndex", "parameters": "(LookupIndexIF<K, E> fallback, boolean nulls)", "modifiers": "public", "return": "", "signature": " CachedIndex(LookupIndexIF<K, E> fallback, boolean nulls)", "full_signature": "public  CachedIndex(LookupIndexIF<K, E> fallback, boolean nulls)", "class_method_signature": "CachedIndex.CachedIndex(LookupIndexIF<K, E> fallback, boolean nulls)", "testcase": false, "constructor": true}, {"identifier": "CachedIndex", "parameters": "(LookupIndexIF<K, E> fallback, int max, int size, boolean nulls)", "modifiers": "public", "return": "", "signature": " CachedIndex(LookupIndexIF<K, E> fallback, int max, int size, boolean nulls)", "full_signature": "public  CachedIndex(LookupIndexIF<K, E> fallback, int max, int size, boolean nulls)", "class_method_signature": "CachedIndex.CachedIndex(LookupIndexIF<K, E> fallback, int max, int size, boolean nulls)", "testcase": false, "constructor": true}, {"identifier": "get", "parameters": "(K key)", "modifiers": "@Override public", "return": "E", "signature": "E get(K key)", "full_signature": "@Override public E get(K key)", "class_method_signature": "CachedIndex.get(K key)", "testcase": false, "constructor": false}, {"identifier": "put", "parameters": "(K key, E value)", "modifiers": "@Override public", "return": "E", "signature": "E put(K key, E value)", "full_signature": "@Override public E put(K key, E value)", "class_method_signature": "CachedIndex.put(K key, E value)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(K key)", "modifiers": "@Override public", "return": "E", "signature": "E remove(K key)", "full_signature": "@Override public E remove(K key)", "class_method_signature": "CachedIndex.remove(K key)", "testcase": false, "constructor": false}, {"identifier": "getKeyNumber", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getKeyNumber()", "full_signature": "public int getKeyNumber()", "class_method_signature": "CachedIndex.getKeyNumber()", "testcase": false, "constructor": false}, {"identifier": "writeReport", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void writeReport()", "full_signature": "public void writeReport()", "class_method_signature": "CachedIndex.writeReport()", "testcase": false, "constructor": false}, {"identifier": "addEntry", "parameters": "(Entry<K, E> newEntry)", "modifiers": "private", "return": "Entry<K, E>", "signature": "Entry<K, E> addEntry(Entry<K, E> newEntry)", "full_signature": "private Entry<K, E> addEntry(Entry<K, E> newEntry)", "class_method_signature": "CachedIndex.addEntry(Entry<K, E> newEntry)", "testcase": false, "constructor": false}, {"identifier": "prune", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void prune()", "full_signature": "protected void prune()", "class_method_signature": "CachedIndex.prune()", "testcase": false, "constructor": false}, {"identifier": "rehash", "parameters": "(int size)", "modifiers": "private", "return": "void", "signature": "void rehash(int size)", "full_signature": "private void rehash(int size)", "class_method_signature": "CachedIndex.rehash(int size)", "testcase": false, "constructor": false}], "file": "ontopia-engine/src/main/java/net/ontopia/utils/CachedIndex.java"}, "focal_method": {"identifier": "prune", "parameters": "()", "modifiers": "protected", "return": "void", "body": "protected void prune() {\n    prunings++;\n//      System.out.println(\"PRUNING! Keys now: \" + entries);\n    for (int ix = 0; ix < data.length; ix++) {\n      Entry current = data[ix];\n      Entry previous = null;\n\n      while (current != null) {\n        if (current.hits < decay) {\n          if (previous == null)\n            data[ix] = current.next;\n          else\n            previous.next = current.next;\n          entries--;\n        } else\n          current.hits -= decay;\n        \n        current = current.next;\n      }\n    }\n//      System.out.println(\"Done. Keys now: \" + entries);\n  }", "signature": "void prune()", "full_signature": "protected void prune()", "class_method_signature": "CachedIndex.prune()", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 32357795, "url": "https://github.com/ontopia/ontopia", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 35, "size": 68637, "license": "licensed"}}