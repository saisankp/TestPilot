{"test_class": {"identifier": "CxSmilesParserTest", "superclass": "", "interfaces": "", "fields": [], "file": "storage/smiles/src/test/java/org/openscience/cdk/smiles/CxSmilesParserTest.java"}, "test_case": {"identifier": "skipCis", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void skipCis() {\n        CxSmilesState state = new CxSmilesState();\n        assertThat(CxSmilesParser.processCx(\"|c:1,4,5|\", state), is(not(-1)));\n    }", "signature": "void skipCis()", "full_signature": "@Test public void skipCis()", "class_method_signature": "CxSmilesParserTest.skipCis()", "testcase": true, "constructor": false, "invocations": ["assertThat", "processCx", "is", "not"]}, "focal_class": {"identifier": "CxSmilesParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final char COMMA_SEPARATOR = ',';", "modifier": "private static final", "type": "char", "declarator": "COMMA_SEPARATOR = ','", "var_name": "COMMA_SEPARATOR"}, {"original_string": "private static final char DOT_SEPARATOR   = '.';", "modifier": "private static final", "type": "char", "declarator": "DOT_SEPARATOR   = '.'", "var_name": "DOT_SEPARATOR"}], "methods": [{"identifier": "CxSmilesParser", "parameters": "()", "modifiers": "private", "return": "", "signature": " CxSmilesParser()", "full_signature": "private  CxSmilesParser()", "class_method_signature": "CxSmilesParser.CxSmilesParser()", "testcase": false, "constructor": true}, {"identifier": "processAtomLabels", "parameters": "(final CharIter iter, final Map<Integer, String> dest)", "modifiers": "private static", "return": "boolean", "signature": "boolean processAtomLabels(final CharIter iter, final Map<Integer, String> dest)", "full_signature": "private static boolean processAtomLabels(final CharIter iter, final Map<Integer, String> dest)", "class_method_signature": "CxSmilesParser.processAtomLabels(final CharIter iter, final Map<Integer, String> dest)", "testcase": false, "constructor": false}, {"identifier": "readDouble", "parameters": "(CharIter iter)", "modifiers": "private static", "return": "double", "signature": "double readDouble(CharIter iter)", "full_signature": "private static double readDouble(CharIter iter)", "class_method_signature": "CxSmilesParser.readDouble(CharIter iter)", "testcase": false, "constructor": false}, {"identifier": "processCoords", "parameters": "(CharIter iter, CxSmilesState state)", "modifiers": "private static", "return": "boolean", "signature": "boolean processCoords(CharIter iter, CxSmilesState state)", "full_signature": "private static boolean processCoords(CharIter iter, CxSmilesState state)", "class_method_signature": "CxSmilesParser.processCoords(CharIter iter, CxSmilesState state)", "testcase": false, "constructor": false}, {"identifier": "processFragmentGrouping", "parameters": "(final CharIter iter, final CxSmilesState state)", "modifiers": "private static", "return": "boolean", "signature": "boolean processFragmentGrouping(final CharIter iter, final CxSmilesState state)", "full_signature": "private static boolean processFragmentGrouping(final CharIter iter, final CxSmilesState state)", "class_method_signature": "CxSmilesParser.processFragmentGrouping(final CharIter iter, final CxSmilesState state)", "testcase": false, "constructor": false}, {"identifier": "isSgroupDelim", "parameters": "(char c)", "modifiers": "private static", "return": "boolean", "signature": "boolean isSgroupDelim(char c)", "full_signature": "private static boolean isSgroupDelim(char c)", "class_method_signature": "CxSmilesParser.isSgroupDelim(char c)", "testcase": false, "constructor": false}, {"identifier": "processDataSgroups", "parameters": "(CharIter iter, CxSmilesState state)", "modifiers": "private static", "return": "boolean", "signature": "boolean processDataSgroups(CharIter iter, CxSmilesState state)", "full_signature": "private static boolean processDataSgroups(CharIter iter, CxSmilesState state)", "class_method_signature": "CxSmilesParser.processDataSgroups(CharIter iter, CxSmilesState state)", "testcase": false, "constructor": false}, {"identifier": "processPolymerSgroups", "parameters": "(CharIter iter, CxSmilesState state)", "modifiers": "private static", "return": "boolean", "signature": "boolean processPolymerSgroups(CharIter iter, CxSmilesState state)", "full_signature": "private static boolean processPolymerSgroups(CharIter iter, CxSmilesState state)", "class_method_signature": "CxSmilesParser.processPolymerSgroups(CharIter iter, CxSmilesState state)", "testcase": false, "constructor": false}, {"identifier": "processIntListMap", "parameters": "(Map<Integer,List<Integer>> map, CharIter iter)", "modifiers": "private static", "return": "boolean", "signature": "boolean processIntListMap(Map<Integer,List<Integer>> map, CharIter iter)", "full_signature": "private static boolean processIntListMap(Map<Integer,List<Integer>> map, CharIter iter)", "class_method_signature": "CxSmilesParser.processIntListMap(Map<Integer,List<Integer>> map, CharIter iter)", "testcase": false, "constructor": false}, {"identifier": "processPositionalVariation", "parameters": "(CharIter iter, CxSmilesState state)", "modifiers": "private static", "return": "boolean", "signature": "boolean processPositionalVariation(CharIter iter, CxSmilesState state)", "full_signature": "private static boolean processPositionalVariation(CharIter iter, CxSmilesState state)", "class_method_signature": "CxSmilesParser.processPositionalVariation(CharIter iter, CxSmilesState state)", "testcase": false, "constructor": false}, {"identifier": "processLigandOrdering", "parameters": "(CharIter iter, CxSmilesState state)", "modifiers": "private static", "return": "boolean", "signature": "boolean processLigandOrdering(CharIter iter, CxSmilesState state)", "full_signature": "private static boolean processLigandOrdering(CharIter iter, CxSmilesState state)", "class_method_signature": "CxSmilesParser.processLigandOrdering(CharIter iter, CxSmilesState state)", "testcase": false, "constructor": false}, {"identifier": "processRadicals", "parameters": "(CharIter iter, CxSmilesState state)", "modifiers": "private static", "return": "boolean", "signature": "boolean processRadicals(CharIter iter, CxSmilesState state)", "full_signature": "private static boolean processRadicals(CharIter iter, CxSmilesState state)", "class_method_signature": "CxSmilesParser.processRadicals(CharIter iter, CxSmilesState state)", "testcase": false, "constructor": false}, {"identifier": "processCx", "parameters": "(final String str, final CxSmilesState state)", "modifiers": "static", "return": "int", "signature": "int processCx(final String str, final CxSmilesState state)", "full_signature": "static int processCx(final String str, final CxSmilesState state)", "class_method_signature": "CxSmilesParser.processCx(final String str, final CxSmilesState state)", "testcase": false, "constructor": false}, {"identifier": "processSgroupsHierarchy", "parameters": "(CharIter iter, CxSmilesState state)", "modifiers": "private static", "return": "boolean", "signature": "boolean processSgroupsHierarchy(CharIter iter, CxSmilesState state)", "full_signature": "private static boolean processSgroupsHierarchy(CharIter iter, CxSmilesState state)", "class_method_signature": "CxSmilesParser.processSgroupsHierarchy(CharIter iter, CxSmilesState state)", "testcase": false, "constructor": false}, {"identifier": "isDigit", "parameters": "(char c)", "modifiers": "private static", "return": "boolean", "signature": "boolean isDigit(char c)", "full_signature": "private static boolean isDigit(char c)", "class_method_signature": "CxSmilesParser.isDigit(char c)", "testcase": false, "constructor": false}, {"identifier": "skipIntList", "parameters": "(CharIter iter, char sep)", "modifiers": "private static", "return": "boolean", "signature": "boolean skipIntList(CharIter iter, char sep)", "full_signature": "private static boolean skipIntList(CharIter iter, char sep)", "class_method_signature": "CxSmilesParser.skipIntList(CharIter iter, char sep)", "testcase": false, "constructor": false}, {"identifier": "skipIntMap", "parameters": "(CharIter iter)", "modifiers": "private static", "return": "boolean", "signature": "boolean skipIntMap(CharIter iter)", "full_signature": "private static boolean skipIntMap(CharIter iter)", "class_method_signature": "CxSmilesParser.skipIntMap(CharIter iter)", "testcase": false, "constructor": false}, {"identifier": "processUnsignedInt", "parameters": "(CharIter iter)", "modifiers": "private static", "return": "int", "signature": "int processUnsignedInt(CharIter iter)", "full_signature": "private static int processUnsignedInt(CharIter iter)", "class_method_signature": "CxSmilesParser.processUnsignedInt(CharIter iter)", "testcase": false, "constructor": false}, {"identifier": "processIntList", "parameters": "(CharIter iter, char sep, List<Integer> dest)", "modifiers": "private static", "return": "boolean", "signature": "boolean processIntList(CharIter iter, char sep, List<Integer> dest)", "full_signature": "private static boolean processIntList(CharIter iter, char sep, List<Integer> dest)", "class_method_signature": "CxSmilesParser.processIntList(CharIter iter, char sep, List<Integer> dest)", "testcase": false, "constructor": false}, {"identifier": "unescape", "parameters": "(String str)", "modifiers": "static", "return": "String", "signature": "String unescape(String str)", "full_signature": "static String unescape(String str)", "class_method_signature": "CxSmilesParser.unescape(String str)", "testcase": false, "constructor": false}], "file": "storage/smiles/src/main/java/org/openscience/cdk/smiles/CxSmilesParser.java"}, "focal_method": {"identifier": "processCx", "parameters": "(final String str, final CxSmilesState state)", "modifiers": "static", "return": "int", "body": "static int processCx(final String str, final CxSmilesState state) {\n\n        final CharIter iter = new CharIter(str);\n\n        if (!iter.nextIf('|'))\n            return -1;\n\n        while (iter.hasNext()) {\n            switch (iter.next()) {\n                case '$': // atom labels and values\n                    // dest is atom labels by default\n                    Map<Integer, String> dest;\n\n                    // check for atom values\n                    if (iter.nextIf(\"_AV:\"))\n                        dest = state.atomValues = new TreeMap<>();\n                    else\n                        dest = state.atomLabels = new TreeMap<>();\n\n                    if (!processAtomLabels(iter, dest))\n                        return -1;\n                    break;\n                case '(': // coordinates\n                    if (!processCoords(iter, state))\n                        return -1;\n                    break;\n                case 'c': // cis/trans/unspec ignored\n                case 't':\n                    // c/t:\n                    if (iter.nextIf(':')) {\n                        if (!skipIntList(iter, COMMA_SEPARATOR))\n                            return -1;\n                    }\n                    // ctu:\n                    else if (iter.nextIf(\"tu:\")) {\n                        if (!skipIntList(iter, COMMA_SEPARATOR))\n                            return -1;\n                    }\n                    break;\n                case 'r': // relative stereochemistry ignored\n                    if (iter.nextIf(':')) {\n                        if (!skipIntList(iter, COMMA_SEPARATOR))\n                            return -1;\n                    } else {\n                        if (!iter.nextIf(',') && iter.curr() != '|')\n                            return -1;\n                    }\n                    break;\n                case 'l': // lone pairs ignored\n                    if (!iter.nextIf(\"p:\"))\n                        return -1;\n                    if (!skipIntMap(iter))\n                        return -1;\n                    break;\n                case 'f': // fragment grouping\n                    if (!iter.nextIf(':'))\n                        return -1;\n                    if (!processFragmentGrouping(iter, state))\n                        return -1;\n                    break;\n                case 'S': // Sgroup polymers\n                    if (iter.nextIf(\"g:\")) {\n                        if (!processPolymerSgroups(iter, state))\n                            return -1;\n                    }\n                    else if (iter.nextIf(\"gD:\")) {\n                        if (!processDataSgroups(iter, state))\n                            return -1;\n                        if (iter.nextIf(','))\n                            break;\n                    }\n                    else if (iter.nextIf(\"gH:\")) {\n                        if (!processSgroupsHierarchy(iter, state))\n                            return -1;\n                    }\n                    else {\n                        return -1;\n                    }\n                    break;\n                case 'm': // positional variation\n                    if (!iter.nextIf(':'))\n                        return -1;\n                    if (!processPositionalVariation(iter, state))\n                        return -1;\n                    break;\n                case '^': // Radicals\n                    if (!processRadicals(iter, state))\n                        return -1;\n                    break;\n                case 'C':\n                case 'H': // coordination and hydrogen bonding ignored\n                    if (!iter.nextIf(':'))\n                        return -1;\n                    while (iter.hasNext() && isDigit(iter.curr())) {\n                        if (!skipIntList(iter, DOT_SEPARATOR))\n                            return -1;\n                        iter.nextIf(',');\n                    }\n                    break;\n                case '|': // end of CX\n                    // consume optional separators\n                    if (!iter.nextIf(' ')) iter.nextIf('\\t');\n                    return iter.pos;\n                case 'L':\n                    // LO, Ligand Ordering\n                    if (iter.nextIf('O')) {\n                        if (!iter.nextIf(':'))\n                            return -1;\n                        if (!processLigandOrdering(iter, state))\n                            return -1;\n                    }\n                    else {\n                        // LP, bond connected lone pair?\n                        return -1;\n                    }\n                    break;\n                default:\n                    return -1;\n            }\n        }\n\n        return -1;\n    }", "signature": "int processCx(final String str, final CxSmilesState state)", "full_signature": "static int processCx(final String str, final CxSmilesState state)", "class_method_signature": "CxSmilesParser.processCx(final String str, final CxSmilesState state)", "testcase": false, "constructor": false, "invocations": ["nextIf", "hasNext", "next", "nextIf", "processAtomLabels", "processCoords", "nextIf", "skipIntList", "nextIf", "skipIntList", "nextIf", "skipIntList", "nextIf", "curr", "nextIf", "skipIntMap", "nextIf", "processFragmentGrouping", "nextIf", "processPolymerSgroups", "nextIf", "processDataSgroups", "nextIf", "nextIf", "processSgroupsHierarchy", "nextIf", "processPositionalVariation", "processRadicals", "nextIf", "hasNext", "isDigit", "curr", "skipIntList", "nextIf", "nextIf", "nextIf", "nextIf", "nextIf", "processLigandOrdering"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}