{"test_class": {"identifier": "TcpTaskTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private InetAddress loopback;", "modifier": "private", "type": "InetAddress", "declarator": "loopback", "var_name": "loopback"}, {"original_string": "private TestSettings testSettings;", "modifier": "private", "type": "TestSettings", "declarator": "testSettings", "var_name": "testSettings"}, {"original_string": "private RMBTClient clientHolder;", "modifier": "private", "type": "RMBTClient", "declarator": "clientHolder", "var_name": "clientHolder"}, {"original_string": "private QualityOfServiceTest qosTest;", "modifier": "private", "type": "QualityOfServiceTest", "declarator": "qosTest", "var_name": "qosTest"}, {"original_string": "private OutputStream testOutputStream;", "modifier": "private", "type": "OutputStream", "declarator": "testOutputStream", "var_name": "testOutputStream"}, {"original_string": "private TaskDesc incomingTaskDesc;", "modifier": "private", "type": "TaskDesc", "declarator": "incomingTaskDesc", "var_name": "incomingTaskDesc"}], "file": "RMBTClient/src/test/java/at/rtr/rmbt/client/v2/task/TcpTaskTest.java"}, "test_case": {"identifier": "testTcpOutgoingConnectionError", "parameters": "(@Mocked final QoSControlConnection controlConnection,\n                                        @Mocked final Socket socket)", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testTcpOutgoingConnectionError (@Mocked final QoSControlConnection controlConnection,\n                                        @Mocked final Socket socket) throws Exception {\n\n        new Expectations() {{\n\n            controlConnection.sendTaskCommand((AbstractQoSTask) any, withPrefix(\"TCPTEST OUT\"), (ControlConnectionResponseCallback) any);\n            result = new Delegate () {\n                public void delegateMethod (AbstractQoSTask qoSTask, String cmd, ControlConnectionResponseCallback callback) {\n                    callback.onResponse(\"OK\", cmd);\n                }\n            };\n\n            socket.getInputStream();\n            result = new ConnectException(\"Forcefully thrown exception\");\n\n        }};\n\n        final TcpTask tcpTask = new TcpTask(qosTest, clientHolder.getTaskDescList().get(0), 0);\n        tcpTask.setControlConnection(controlConnection);\n\n        final QoSTestResult res = tcpTask.call();\n\n        assertEquals(\"Result did not return ERROR\",\"ERROR\", res.getResultMap().get(TcpTask.RESULT_OUT));\n        assertEquals(\"Incorrect test out port\", 80, res.getResultMap().get(TcpTask.RESULT_PORT_OUT));\n    }", "signature": "void testTcpOutgoingConnectionError(@Mocked final QoSControlConnection controlConnection,\n                                        @Mocked final Socket socket)", "full_signature": "@Test public void testTcpOutgoingConnectionError(@Mocked final QoSControlConnection controlConnection,\n                                        @Mocked final Socket socket)", "class_method_signature": "TcpTaskTest.testTcpOutgoingConnectionError(@Mocked final QoSControlConnection controlConnection,\n                                        @Mocked final Socket socket)", "testcase": true, "constructor": false, "invocations": ["sendTaskCommand", "withPrefix", "onResponse", "getInputStream", "get", "getTaskDescList", "setControlConnection", "call", "assertEquals", "get", "getResultMap", "assertEquals", "get", "getResultMap"]}, "focal_class": {"identifier": "TcpTask", "superclass": "extends AbstractQoSTask", "interfaces": "", "fields": [{"original_string": "private final Integer testPortOut;", "modifier": "private final", "type": "Integer", "declarator": "testPortOut", "var_name": "testPortOut"}, {"original_string": "private final Integer testPortIn;", "modifier": "private final", "type": "Integer", "declarator": "testPortIn", "var_name": "testPortIn"}, {"original_string": "private final long timeout;", "modifier": "private final", "type": "long", "declarator": "timeout", "var_name": "timeout"}, {"original_string": "private final static long DEFAULT_TIMEOUT = 3000000000L;", "modifier": "private final static", "type": "long", "declarator": "DEFAULT_TIMEOUT = 3000000000L", "var_name": "DEFAULT_TIMEOUT"}, {"original_string": "public final static String PARAM_PORT_IN = \"in_port\";", "modifier": "public final static", "type": "String", "declarator": "PARAM_PORT_IN = \"in_port\"", "var_name": "PARAM_PORT_IN"}, {"original_string": "public final static String PARAM_PORT_OUT = \"out_port\";", "modifier": "public final static", "type": "String", "declarator": "PARAM_PORT_OUT = \"out_port\"", "var_name": "PARAM_PORT_OUT"}, {"original_string": "public final static String PARAM_TIMEOUT = \"timeout\";", "modifier": "public final static", "type": "String", "declarator": "PARAM_TIMEOUT = \"timeout\"", "var_name": "PARAM_TIMEOUT"}, {"original_string": "public final static String RESULT_PORT_IN = \"tcp_objective_in_port\";", "modifier": "public final static", "type": "String", "declarator": "RESULT_PORT_IN = \"tcp_objective_in_port\"", "var_name": "RESULT_PORT_IN"}, {"original_string": "public final static String RESULT_PORT_OUT = \"tcp_objective_out_port\";", "modifier": "public final static", "type": "String", "declarator": "RESULT_PORT_OUT = \"tcp_objective_out_port\"", "var_name": "RESULT_PORT_OUT"}, {"original_string": "public final static String RESULT_TIMEOUT = \"tcp_objective_timeout\";", "modifier": "public final static", "type": "String", "declarator": "RESULT_TIMEOUT = \"tcp_objective_timeout\"", "var_name": "RESULT_TIMEOUT"}, {"original_string": "public final static String RESULT_IN = \"tcp_result_in\";", "modifier": "public final static", "type": "String", "declarator": "RESULT_IN = \"tcp_result_in\"", "var_name": "RESULT_IN"}, {"original_string": "public final static String RESULT_OUT = \"tcp_result_out\";", "modifier": "public final static", "type": "String", "declarator": "RESULT_OUT = \"tcp_result_out\"", "var_name": "RESULT_OUT"}, {"original_string": "public final static String RESULT_RESPONSE_OUT = \"tcp_result_out_response\";", "modifier": "public final static", "type": "String", "declarator": "RESULT_RESPONSE_OUT = \"tcp_result_out_response\"", "var_name": "RESULT_RESPONSE_OUT"}, {"original_string": "public final static String RESULT_RESPONSE_IN = \"tcp_result_in_response\";", "modifier": "public final static", "type": "String", "declarator": "RESULT_RESPONSE_IN = \"tcp_result_in_response\"", "var_name": "RESULT_RESPONSE_IN"}], "methods": [{"identifier": "TcpTask", "parameters": "(QualityOfServiceTest nnTest, TaskDesc taskDesc, int threadId)", "modifiers": "public", "return": "", "signature": " TcpTask(QualityOfServiceTest nnTest, TaskDesc taskDesc, int threadId)", "full_signature": "public  TcpTask(QualityOfServiceTest nnTest, TaskDesc taskDesc, int threadId)", "class_method_signature": "TcpTask.TcpTask(QualityOfServiceTest nnTest, TaskDesc taskDesc, int threadId)", "testcase": false, "constructor": true}, {"identifier": "call", "parameters": "()", "modifiers": "public", "return": "QoSTestResult", "signature": "QoSTestResult call()", "full_signature": "public QoSTestResult call()", "class_method_signature": "TcpTask.call()", "testcase": false, "constructor": false}, {"identifier": "initTask", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void initTask()", "full_signature": "@Override public void initTask()", "class_method_signature": "TcpTask.initTask()", "testcase": false, "constructor": false}, {"identifier": "getTestType", "parameters": "()", "modifiers": "public", "return": "QosMeasurementType", "signature": "QosMeasurementType getTestType()", "full_signature": "public QosMeasurementType getTestType()", "class_method_signature": "TcpTask.getTestType()", "testcase": false, "constructor": false}, {"identifier": "needsQoSControlConnection", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean needsQoSControlConnection()", "full_signature": "public boolean needsQoSControlConnection()", "class_method_signature": "TcpTask.needsQoSControlConnection()", "testcase": false, "constructor": false}], "file": "RMBTClient/src/main/java/at/rtr/rmbt/client/v2/task/TcpTask.java"}, "focal_method": {"identifier": "call", "parameters": "()", "modifiers": "public", "return": "QoSTestResult", "body": "public QoSTestResult call() throws Exception {\n\t\tfinal QoSTestResult result = initQoSTestResult(QosMeasurementType.TCP);\n\t\ttry {\n\t\t\tonStart(result);\n\t\t\t\n\t\t\tif (this.testPortIn != null) {\n\t\t\t\tresult.getResultMap().put(RESULT_IN, \"FAILED\");\t\t\t\n\t\t\t}\n\t\t\tif (this.testPortOut != null) {\n\t\t\t\tresult.getResultMap().put(RESULT_OUT, \"FAILED\");\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tSocket socketIn = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tSystem.out.println(\"TCPTASK: \" + getTestServerAddr() + \":\" + getTestServerPort());\n\t\t    \t\n\t\t    \tString response = null;\n\t\t    \t\n\t\t    \tif (this.testPortOut != null) {\n\t\t    \t\t//needed for timeout:\n\t\t    \t\tfinal CountDownLatch latch = new CountDownLatch(1);\n\t\t    \t\t\n\t\t    \t\t//response handler\n\t\t    \t\tfinal ControlConnectionResponseCallback callback = new ControlConnectionResponseCallback() {\n\t\t\t\t\t\t\n\t\t\t\t\t\tpublic void onResponse(final String response, final String request) {\n\t\t\t\t    \t\tif (response != null && response.startsWith(\"OK\")) {\n\t\t\t\t    \t\t\tSystem.out.println(\"got response: \" + response);\n\t\t\t\t    \t\t\tSocket socketOut = null;\n\t\t\t\t    \t\t\t\n\t\t\t\t    \t\t\ttry {\n\t\t\t\t\t    \t\t\tsocketOut = getSocket(getTestServerAddr(), testPortOut, false, (int)(timeout/1000000));\n\t\t\t\t\t    \t\t\tsocketOut.setSoTimeout((int)(timeout/1000000));\n\t\t\t\t\t    \t\t\tsendMessage(socketOut, \"PING\\n\");\n\t\t\t\t\t    \t\t\tfinal String testResponse = readLine(socketOut);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t    \t\t\tSystem.out.println(\"TCP OUT TEST response: \" + testResponse);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t    \t\t\tresult.getResultMap().put(RESULT_RESPONSE_OUT, testResponse);\n\t\t\t\t\t    \t\t\tsocketOut.close();\n\t\t\t\t\t    \t\t\tresult.getResultMap().put(RESULT_OUT, \"OK\");\n\t\t\t\t    \t\t\t}\n\t\t\t\t    \t\t\tcatch (SocketTimeoutException e) {\n\t\t\t\t    \t\t\t\tresult.getResultMap().put(RESULT_OUT, \"TIMEOUT\");\n\t\t\t\t    \t\t\t}\n\t\t\t\t    \t\t\tcatch (Exception e) {\n\t\t\t\t    \t\t\t\tresult.getResultMap().put(RESULT_OUT, \"ERROR\");\n\t\t\t\t    \t\t\t}\n\t\t\t\t    \t\t\tfinally {\n\t\t\t\t\t    \t\t\tlatch.countDown();\n\t\t\t\t    \t\t\t}\n\t\t\t\t    \t\t} else {\n\t\t\t\t    \t\t\t// we don't need to await the timeout on wrong response (and it shouldn't be a timeout)\n\t\t\t\t\t\t\t\tresult.getResultMap().put(RESULT_OUT, \"ERROR\");\n\t\t\t\t\t\t\t\tlatch.countDown();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\t    \t\t\t\t\n\t\t    \t\t\n\t\t\t\t\tsendCommand(\"TCPTEST OUT \" + testPortOut, callback);\n\t\t\t\t\tif(!latch.await(timeout, TimeUnit.NANOSECONDS)) {\n\t\t\t\t\t\tresult.getResultMap().put(RESULT_OUT, \"TIMEOUT\");\n\t\t\t\t\t}\n\t\t    \t}\n\t\t\t\t\n\t\t    \tif (this.testPortIn != null) {\n\t\t    \t\ttry (ServerSocket serverSocket = new ServerSocket(testPortIn)) {\n\t\t\t\t\t\tsendCommand(\"TCPTEST IN \" + testPortIn, null);\n\n\t\t\t\t\t\tserverSocket.setSoTimeout((int)(timeout/1000000));\n\t\t\t\t\t\tsocketIn = serverSocket.accept();\n\t\t\t\t\t\tsocketIn.setSoTimeout((int)(timeout/1000000));\n\t\t\t\t\t\tresponse = readLine(socketIn);\n\t\t\t\t\t\tSystem.out.println(\"TCP IN TEST response: \" + response);\t\t\t\t\t\t\n\t\t\t\t\t\tresult.getResultMap().put(RESULT_RESPONSE_IN, response);\n\t\t\t\t\t\tsocketIn.close();\n\t\t\t\t\t\tresult.getResultMap().put(RESULT_IN, \"OK\");\t    \t\t\t\t    \t\t\t\n\t\t    \t\t}\n\t\t\t\t\tcatch (SocketTimeoutException e) {\n\t\t\t\t\t\tresult.getResultMap().put(RESULT_IN, \"TIMEOUT\");\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tresult.getResultMap().put(RESULT_IN, \"ERROR\");\n\t\t\t\t\t}\n\t\t    \t}\n\t\t\t\t\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tif (this.testPortIn != null) {\n\t\t\t\tresult.getResultMap().put(RESULT_PORT_IN, testPortIn);\t\t\t\n\t\t\t}\n\n\t\t\tif (this.testPortOut != null) {\n\t\t\t\tresult.getResultMap().put(RESULT_PORT_OUT, testPortOut);\t\n\t\t\t}\n\t\t\t\n\t\t\tresult.getResultMap().put(RESULT_TIMEOUT, timeout);\n\t\t\t\n\t\t\treturn result;\t\t\t\n\t\t}\n\t\tcatch (Exception e)  {\n\t\t\tthrow e;\n\t\t}\n\t\tfinally {\n\t\t\tonEnd(result);\n\t\t}\n\t}", "signature": "QoSTestResult call()", "full_signature": "public QoSTestResult call()", "class_method_signature": "TcpTask.call()", "testcase": false, "constructor": false, "invocations": ["initQoSTestResult", "onStart", "put", "getResultMap", "put", "getResultMap", "println", "getTestServerAddr", "getTestServerPort", "startsWith", "println", "getSocket", "getTestServerAddr", "setSoTimeout", "sendMessage", "readLine", "println", "put", "getResultMap", "close", "put", "getResultMap", "put", "getResultMap", "put", "getResultMap", "countDown", "put", "getResultMap", "countDown", "sendCommand", "await", "put", "getResultMap", "sendCommand", "setSoTimeout", "accept", "setSoTimeout", "readLine", "println", "put", "getResultMap", "close", "put", "getResultMap", "put", "getResultMap", "put", "getResultMap", "printStackTrace", "put", "getResultMap", "put", "getResultMap", "put", "getResultMap", "onEnd"]}, "repository": {"repo_id": 87583205, "url": "https://github.com/rtr-nettest/open-rmbt", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 15, "size": 21100, "license": "licensed"}}