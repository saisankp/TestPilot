{"test_class": {"identifier": "TestAvroSource", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory\n      .getLogger(TestAvroSource.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory\n      .getLogger(TestAvroSource.class)", "var_name": "logger"}, {"original_string": "private int selectedPort;", "modifier": "private", "type": "int", "declarator": "selectedPort", "var_name": "selectedPort"}, {"original_string": "private AvroSource source;", "modifier": "private", "type": "AvroSource", "declarator": "source", "var_name": "source"}, {"original_string": "private Channel channel;", "modifier": "private", "type": "Channel", "declarator": "channel", "var_name": "channel"}, {"original_string": "private InetAddress localhost;", "modifier": "private", "type": "InetAddress", "declarator": "localhost", "var_name": "localhost"}], "file": "flume-ng-core/src/test/java/org/apache/flume/source/TestAvroSource.java"}, "test_case": {"identifier": "testSslRequestWithGlobalKeystore", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testSslRequestWithGlobalKeystore() throws InterruptedException, IOException {\n\n    System.setProperty(\"javax.net.ssl.keyStore\", \"src/test/resources/server.p12\");\n    System.setProperty(\"javax.net.ssl.keyStorePassword\", \"password\");\n    System.setProperty(\"javax.net.ssl.keyStoreType\", \"PKCS12\");\n\n    Context context = new Context();\n\n    context.put(\"port\", String.valueOf(selectedPort = getFreePort()));\n    context.put(\"bind\", \"0.0.0.0\");\n    context.put(\"ssl\", \"true\");\n\n    Configurables.configure(source, context);\n\n    doSslRequest();\n\n    System.clearProperty(\"javax.net.ssl.keyStore\");\n    System.clearProperty(\"javax.net.ssl.keyStorePassword\");\n  }", "signature": "void testSslRequestWithGlobalKeystore()", "full_signature": "@Test public void testSslRequestWithGlobalKeystore()", "class_method_signature": "TestAvroSource.testSslRequestWithGlobalKeystore()", "testcase": true, "constructor": false, "invocations": ["setProperty", "setProperty", "setProperty", "put", "valueOf", "getFreePort", "put", "put", "configure", "doSslRequest", "clearProperty", "clearProperty"]}, "focal_class": {"identifier": "AvroSource", "superclass": "extends SslContextAwareAbstractSource", "interfaces": "implements EventDrivenSource,\n    Configurable, AvroSourceProtocol", "fields": [{"original_string": "private static final String THREADS = \"threads\";", "modifier": "private static final", "type": "String", "declarator": "THREADS = \"threads\"", "var_name": "THREADS"}, {"original_string": "private static final Logger logger = LoggerFactory\n      .getLogger(AvroSource.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory\n      .getLogger(AvroSource.class)", "var_name": "logger"}, {"original_string": "private static final String PORT_KEY = \"port\";", "modifier": "private static final", "type": "String", "declarator": "PORT_KEY = \"port\"", "var_name": "PORT_KEY"}, {"original_string": "private static final String BIND_KEY = \"bind\";", "modifier": "private static final", "type": "String", "declarator": "BIND_KEY = \"bind\"", "var_name": "BIND_KEY"}, {"original_string": "private static final String COMPRESSION_TYPE = \"compression-type\";", "modifier": "private static final", "type": "String", "declarator": "COMPRESSION_TYPE = \"compression-type\"", "var_name": "COMPRESSION_TYPE"}, {"original_string": "private static final String IP_FILTER_KEY = \"ipFilter\";", "modifier": "private static final", "type": "String", "declarator": "IP_FILTER_KEY = \"ipFilter\"", "var_name": "IP_FILTER_KEY"}, {"original_string": "private static final String IP_FILTER_RULES_KEY = \"ipFilterRules\";", "modifier": "private static final", "type": "String", "declarator": "IP_FILTER_RULES_KEY = \"ipFilterRules\"", "var_name": "IP_FILTER_RULES_KEY"}, {"original_string": "private int port;", "modifier": "private", "type": "int", "declarator": "port", "var_name": "port"}, {"original_string": "private String bindAddress;", "modifier": "private", "type": "String", "declarator": "bindAddress", "var_name": "bindAddress"}, {"original_string": "private String compressionType;", "modifier": "private", "type": "String", "declarator": "compressionType", "var_name": "compressionType"}, {"original_string": "private boolean enableIpFilter;", "modifier": "private", "type": "boolean", "declarator": "enableIpFilter", "var_name": "enableIpFilter"}, {"original_string": "private String patternRuleConfigDefinition;", "modifier": "private", "type": "String", "declarator": "patternRuleConfigDefinition", "var_name": "patternRuleConfigDefinition"}, {"original_string": "private NioServerSocketChannelFactory socketChannelFactory;", "modifier": "private", "type": "NioServerSocketChannelFactory", "declarator": "socketChannelFactory", "var_name": "socketChannelFactory"}, {"original_string": "private Server server;", "modifier": "private", "type": "Server", "declarator": "server", "var_name": "server"}, {"original_string": "private SourceCounter sourceCounter;", "modifier": "private", "type": "SourceCounter", "declarator": "sourceCounter", "var_name": "sourceCounter"}, {"original_string": "private int maxThreads;", "modifier": "private", "type": "int", "declarator": "maxThreads", "var_name": "maxThreads"}, {"original_string": "private ScheduledExecutorService connectionCountUpdater;", "modifier": "private", "type": "ScheduledExecutorService", "declarator": "connectionCountUpdater", "var_name": "connectionCountUpdater"}, {"original_string": "private List<IpFilterRule> rules;", "modifier": "private", "type": "List<IpFilterRule>", "declarator": "rules", "var_name": "rules"}], "methods": [{"identifier": "configure", "parameters": "(Context context)", "modifiers": "@Override public", "return": "void", "signature": "void configure(Context context)", "full_signature": "@Override public void configure(Context context)", "class_method_signature": "AvroSource.configure(Context context)", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void start()", "full_signature": "@Override public void start()", "class_method_signature": "AvroSource.start()", "testcase": false, "constructor": false}, {"identifier": "initSocketChannelFactory", "parameters": "()", "modifiers": "private", "return": "NioServerSocketChannelFactory", "signature": "NioServerSocketChannelFactory initSocketChannelFactory()", "full_signature": "private NioServerSocketChannelFactory initSocketChannelFactory()", "class_method_signature": "AvroSource.initSocketChannelFactory()", "testcase": false, "constructor": false}, {"identifier": "initChannelPipelineFactory", "parameters": "()", "modifiers": "private", "return": "ChannelPipelineFactory", "signature": "ChannelPipelineFactory initChannelPipelineFactory()", "full_signature": "private ChannelPipelineFactory initChannelPipelineFactory()", "class_method_signature": "AvroSource.initChannelPipelineFactory()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void stop()", "full_signature": "@Override public void stop()", "class_method_signature": "AvroSource.stop()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "AvroSource.toString()", "testcase": false, "constructor": false}, {"identifier": "toStringMap", "parameters": "(\n      Map<CharSequence, CharSequence> charSeqMap)", "modifiers": "private static", "return": "Map<String, String>", "signature": "Map<String, String> toStringMap(\n      Map<CharSequence, CharSequence> charSeqMap)", "full_signature": "private static Map<String, String> toStringMap(\n      Map<CharSequence, CharSequence> charSeqMap)", "class_method_signature": "AvroSource.toStringMap(\n      Map<CharSequence, CharSequence> charSeqMap)", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(AvroFlumeEvent avroEvent)", "modifiers": "@Override public", "return": "Status", "signature": "Status append(AvroFlumeEvent avroEvent)", "full_signature": "@Override public Status append(AvroFlumeEvent avroEvent)", "class_method_signature": "AvroSource.append(AvroFlumeEvent avroEvent)", "testcase": false, "constructor": false}, {"identifier": "appendBatch", "parameters": "(List<AvroFlumeEvent> events)", "modifiers": "@Override public", "return": "Status", "signature": "Status appendBatch(List<AvroFlumeEvent> events)", "full_signature": "@Override public Status appendBatch(List<AvroFlumeEvent> events)", "class_method_signature": "AvroSource.appendBatch(List<AvroFlumeEvent> events)", "testcase": false, "constructor": false}, {"identifier": "generateRule", "parameters": "(String patternRuleDefinition)", "modifiers": "private", "return": "PatternRule", "signature": "PatternRule generateRule(String patternRuleDefinition)", "full_signature": "private PatternRule generateRule(String patternRuleDefinition)", "class_method_signature": "AvroSource.generateRule(String patternRuleDefinition)", "testcase": false, "constructor": false}], "file": "flume-ng-core/src/main/java/org/apache/flume/source/AvroSource.java"}, "focal_method": {"identifier": "configure", "parameters": "(Context context)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void configure(Context context) {\n    configureSsl(context);\n    Configurables.ensureRequiredNonNull(context, PORT_KEY, BIND_KEY);\n\n    port = context.getInteger(PORT_KEY);\n    bindAddress = context.getString(BIND_KEY);\n    compressionType = context.getString(COMPRESSION_TYPE, \"none\");\n\n    try {\n      maxThreads = context.getInteger(THREADS, 0);\n    } catch (NumberFormatException e) {\n      logger.warn(\"AVRO source\\'s \\\"threads\\\" property must specify an integer value.\",\n              context.getString(THREADS));\n    }\n\n    enableIpFilter = context.getBoolean(IP_FILTER_KEY, false);\n    if (enableIpFilter) {\n      patternRuleConfigDefinition = context.getString(IP_FILTER_RULES_KEY);\n      if (patternRuleConfigDefinition == null ||\n          patternRuleConfigDefinition.trim().isEmpty()) {\n        throw new FlumeException(\n          \"ipFilter is configured with true but ipFilterRules is not defined:\" +\n            \" \");\n      }\n      String[] patternRuleDefinitions = patternRuleConfigDefinition.split(\n        \",\");\n      rules = new ArrayList<IpFilterRule>(patternRuleDefinitions.length);\n      for (String patternRuleDefinition : patternRuleDefinitions) {\n        rules.add(generateRule(patternRuleDefinition));\n      }\n    }\n\n    if (sourceCounter == null) {\n      sourceCounter = new SourceCounter(getName());\n    }\n  }", "signature": "void configure(Context context)", "full_signature": "@Override public void configure(Context context)", "class_method_signature": "AvroSource.configure(Context context)", "testcase": false, "constructor": false, "invocations": ["configureSsl", "ensureRequiredNonNull", "getInteger", "getString", "getString", "getInteger", "warn", "getString", "getBoolean", "getString", "isEmpty", "trim", "split", "add", "generateRule", "getName"]}, "repository": {"repo_id": 2198510, "url": "https://github.com/apache/flume", "language": "Java", "is_fork": false, "fork_count": 1372, "stargazer_count": 1971, "size": 44377, "license": "licensed"}}