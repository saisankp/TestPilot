{"test_class": {"identifier": "AbstractReaderTest", "superclass": "", "interfaces": "", "fields": [], "file": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/reader/AbstractReaderTest.java"}, "test_case": {"identifier": "testEndOfPartitionEvent", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testEndOfPartitionEvent() throws Exception {\n\t\tfinal AbstractReader reader = new MockReader(createInputGate(1));\n\n\t\tassertTrue(reader.handleEvent(EndOfPartitionEvent.INSTANCE));\n\t}", "signature": "void testEndOfPartitionEvent()", "full_signature": "@Test public void testEndOfPartitionEvent()", "class_method_signature": "AbstractReaderTest.testEndOfPartitionEvent()", "testcase": true, "constructor": false, "invocations": ["createInputGate", "assertTrue", "handleEvent"]}, "focal_class": {"identifier": "AbstractReader", "superclass": "", "interfaces": "implements ReaderBase", "fields": [{"original_string": "protected final InputGate inputGate;", "modifier": "protected final", "type": "InputGate", "declarator": "inputGate", "var_name": "inputGate"}, {"original_string": "private final TaskEventHandler taskEventHandler = new TaskEventHandler();", "modifier": "private final", "type": "TaskEventHandler", "declarator": "taskEventHandler = new TaskEventHandler()", "var_name": "taskEventHandler"}, {"original_string": "private boolean isIterative;", "modifier": "private", "type": "boolean", "declarator": "isIterative", "var_name": "isIterative"}, {"original_string": "private int currentNumberOfEndOfSuperstepEvents;", "modifier": "private", "type": "int", "declarator": "currentNumberOfEndOfSuperstepEvents", "var_name": "currentNumberOfEndOfSuperstepEvents"}], "methods": [{"identifier": "AbstractReader", "parameters": "(InputGate inputGate)", "modifiers": "protected", "return": "", "signature": " AbstractReader(InputGate inputGate)", "full_signature": "protected  AbstractReader(InputGate inputGate)", "class_method_signature": "AbstractReader.AbstractReader(InputGate inputGate)", "testcase": false, "constructor": true}, {"identifier": "isFinished", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isFinished()", "full_signature": "@Override public boolean isFinished()", "class_method_signature": "AbstractReader.isFinished()", "testcase": false, "constructor": false}, {"identifier": "registerTaskEventListener", "parameters": "(EventListener<TaskEvent> listener, Class<? extends TaskEvent> eventType)", "modifiers": "@Override public", "return": "void", "signature": "void registerTaskEventListener(EventListener<TaskEvent> listener, Class<? extends TaskEvent> eventType)", "full_signature": "@Override public void registerTaskEventListener(EventListener<TaskEvent> listener, Class<? extends TaskEvent> eventType)", "class_method_signature": "AbstractReader.registerTaskEventListener(EventListener<TaskEvent> listener, Class<? extends TaskEvent> eventType)", "testcase": false, "constructor": false}, {"identifier": "sendTaskEvent", "parameters": "(TaskEvent event)", "modifiers": "@Override public", "return": "void", "signature": "void sendTaskEvent(TaskEvent event)", "full_signature": "@Override public void sendTaskEvent(TaskEvent event)", "class_method_signature": "AbstractReader.sendTaskEvent(TaskEvent event)", "testcase": false, "constructor": false}, {"identifier": "handleEvent", "parameters": "(AbstractEvent event)", "modifiers": "protected", "return": "boolean", "signature": "boolean handleEvent(AbstractEvent event)", "full_signature": "protected boolean handleEvent(AbstractEvent event)", "class_method_signature": "AbstractReader.handleEvent(AbstractEvent event)", "testcase": false, "constructor": false}, {"identifier": "publish", "parameters": "(TaskEvent event)", "modifiers": "public", "return": "void", "signature": "void publish(TaskEvent event)", "full_signature": "public void publish(TaskEvent event)", "class_method_signature": "AbstractReader.publish(TaskEvent event)", "testcase": false, "constructor": false}, {"identifier": "setIterativeReader", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void setIterativeReader()", "full_signature": "@Override public void setIterativeReader()", "class_method_signature": "AbstractReader.setIterativeReader()", "testcase": false, "constructor": false}, {"identifier": "startNextSuperstep", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void startNextSuperstep()", "full_signature": "@Override public void startNextSuperstep()", "class_method_signature": "AbstractReader.startNextSuperstep()", "testcase": false, "constructor": false}, {"identifier": "hasReachedEndOfSuperstep", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean hasReachedEndOfSuperstep()", "full_signature": "@Override public boolean hasReachedEndOfSuperstep()", "class_method_signature": "AbstractReader.hasReachedEndOfSuperstep()", "testcase": false, "constructor": false}, {"identifier": "incrementEndOfSuperstepEventAndCheck", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean incrementEndOfSuperstepEventAndCheck()", "full_signature": "private boolean incrementEndOfSuperstepEventAndCheck()", "class_method_signature": "AbstractReader.incrementEndOfSuperstepEventAndCheck()", "testcase": false, "constructor": false}], "file": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/AbstractReader.java"}, "focal_method": {"identifier": "handleEvent", "parameters": "(AbstractEvent event)", "modifiers": "protected", "return": "boolean", "body": "protected boolean handleEvent(AbstractEvent event) throws IOException {\n\t\tfinal Class<?> eventType = event.getClass();\n\n\t\ttry {\n\t\t\t// ------------------------------------------------------------\n\t\t\t// Runtime events\n\t\t\t// ------------------------------------------------------------\n\n\t\t\t// This event is also checked at the (single) input gate to release the respective\n\t\t\t// channel, at which it was received.\n\t\t\tif (eventType == EndOfPartitionEvent.class) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (eventType == EndOfSuperstepEvent.class) {\n\t\t\t\treturn incrementEndOfSuperstepEventAndCheck();\n\t\t\t}\n\n\t\t\t// ------------------------------------------------------------\n\t\t\t// Task events (user)\n\t\t\t// ------------------------------------------------------------\n\t\t\telse if (event instanceof TaskEvent) {\n\t\t\t\ttaskEventHandler.publish((TaskEvent) event);\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"Received unexpected event of type \" + eventType + \" at reader.\");\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow new IOException(\"Error while handling event of type \" + eventType + \": \" + t.getMessage(), t);\n\t\t}\n\t}", "signature": "boolean handleEvent(AbstractEvent event)", "full_signature": "protected boolean handleEvent(AbstractEvent event)", "class_method_signature": "AbstractReader.handleEvent(AbstractEvent event)", "testcase": false, "constructor": false, "invocations": ["getClass", "incrementEndOfSuperstepEventAndCheck", "publish", "getMessage"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}