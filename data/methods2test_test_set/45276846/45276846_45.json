{"test_class": {"identifier": "TestProcessService", "superclass": "extends BasicTestCase", "interfaces": "", "fields": [], "file": "xenon-common/src/test/java/com/vmware/xenon/services/common/TestProcessService.java"}, "test_case": {"identifier": "startProcess", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void startProcess() throws Throwable {\n        final ProcessState[] state = { new ProcessState() };\n        if (host.getSystemInfo().osFamily == OsFamily.WINDOWS) {\n            state[0].arguments = new String[] { \"cmd.exe\", \"/C\", \"echo\" };\n        } else {\n            state[0].arguments = new String[] { \"echo\" };\n        }\n\n        this.host.testStart(1);\n\n        final URI[] processURI = { null };\n        URI uri = UriUtils.buildUri(this.host, ProcessFactoryService.SELF_LINK);\n        Operation op = Operation.createPost(uri)\n                .setBody(state[0])\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(e);\n                        return;\n                    }\n\n                    ProcessState newState = o.getBody(ProcessState.class);\n                    processURI[0] = UriUtils.buildUri(this.host, newState.documentSelfLink);\n                    this.host.completeIteration();\n                });\n\n        this.host.send(op);\n        this.host.testWait();\n\n        int startCount;\n        int startDelayMillis;\n\n        startCount = getStat(processURI[0], ProcessService.STAT_NAME_START_COUNT);\n        assertTrue(startCount >= 1);\n\n        Date expiration = this.host.getTestExpiration();\n        while (new Date().before(expiration)) {\n            startCount = getStat(processURI[0], ProcessService.STAT_NAME_START_COUNT);\n            if (startCount >= 3) {\n                // The process was restarted at least twice.\n                // Test that the back-off kicked in after the first restart.\n                startDelayMillis = getStat(processURI[0],\n                        ProcessService.STAT_NAME_START_DELAY_MILLIS);\n                assertTrue(startDelayMillis > 0);\n                return;\n            }\n\n            Thread.sleep(TimeUnit.MICROSECONDS.toMillis(this.host.getMaintenanceIntervalMicros()));\n        }\n    }", "signature": "void startProcess()", "full_signature": "@Test public void startProcess()", "class_method_signature": "TestProcessService.startProcess()", "testcase": true, "constructor": false, "invocations": ["getSystemInfo", "testStart", "buildUri", "setCompletion", "setBody", "createPost", "failIteration", "getBody", "buildUri", "completeIteration", "send", "testWait", "getStat", "assertTrue", "getTestExpiration", "before", "getStat", "getStat", "assertTrue", "sleep", "toMillis", "getMaintenanceIntervalMicros"]}, "focal_class": {"identifier": "ProcessService", "superclass": "extends StatefulService", "interfaces": "", "fields": [{"original_string": "static final String STAT_NAME_START_COUNT = \"startCount\";", "modifier": "static final", "type": "String", "declarator": "STAT_NAME_START_COUNT = \"startCount\"", "var_name": "STAT_NAME_START_COUNT"}, {"original_string": "static final String STAT_NAME_START_DELAY_MILLIS = \"startDelayMillis\";", "modifier": "static final", "type": "String", "declarator": "STAT_NAME_START_DELAY_MILLIS = \"startDelayMillis\"", "var_name": "STAT_NAME_START_DELAY_MILLIS"}, {"original_string": "static final long MAX_START_DELAY_MILLIS = TimeUnit.SECONDS.toMillis(120);", "modifier": "static final", "type": "long", "declarator": "MAX_START_DELAY_MILLIS = TimeUnit.SECONDS.toMillis(120)", "var_name": "MAX_START_DELAY_MILLIS"}, {"original_string": "static final long STABLE_THRESHOLD_MILLIS = TimeUnit.SECONDS.toMillis(60);", "modifier": "static final", "type": "long", "declarator": "STABLE_THRESHOLD_MILLIS = TimeUnit.SECONDS.toMillis(60)", "var_name": "STABLE_THRESHOLD_MILLIS"}, {"original_string": "static final int LINES = 100;", "modifier": "static final", "type": "int", "declarator": "LINES = 100", "var_name": "LINES"}, {"original_string": "private long startDelayExp = 0;", "modifier": "private", "type": "long", "declarator": "startDelayExp = 0", "var_name": "startDelayExp"}, {"original_string": "private long startDelayMillis = 0;", "modifier": "private", "type": "long", "declarator": "startDelayMillis = 0", "var_name": "startDelayMillis"}, {"original_string": "private Process process;", "modifier": "private", "type": "Process", "declarator": "process", "var_name": "process"}, {"original_string": "private int processExitStatus;", "modifier": "private", "type": "int", "declarator": "processExitStatus", "var_name": "processExitStatus"}, {"original_string": "private long processStartTimeMillis;", "modifier": "private", "type": "long", "declarator": "processStartTimeMillis", "var_name": "processStartTimeMillis"}, {"original_string": "private long processStopTimeMillis;", "modifier": "private", "type": "long", "declarator": "processStopTimeMillis", "var_name": "processStopTimeMillis"}], "methods": [{"identifier": "ProcessService", "parameters": "()", "modifiers": "public", "return": "", "signature": " ProcessService()", "full_signature": "public  ProcessService()", "class_method_signature": "ProcessService.ProcessService()", "testcase": false, "constructor": true}, {"identifier": "stopProcess", "parameters": "()", "modifiers": "protected", "return": "boolean", "signature": "boolean stopProcess()", "full_signature": "protected boolean stopProcess()", "class_method_signature": "ProcessService.stopProcess()", "testcase": false, "constructor": false}, {"identifier": "startProcess", "parameters": "(Operation op, ProcessState state)", "modifiers": "protected", "return": "void", "signature": "void startProcess(Operation op, ProcessState state)", "full_signature": "protected void startProcess(Operation op, ProcessState state)", "class_method_signature": "ProcessService.startProcess(Operation op, ProcessState state)", "testcase": false, "constructor": false}, {"identifier": "handleStart", "parameters": "(Operation op)", "modifiers": "@Override public", "return": "void", "signature": "void handleStart(Operation op)", "full_signature": "@Override public void handleStart(Operation op)", "class_method_signature": "ProcessService.handleStart(Operation op)", "testcase": false, "constructor": false}, {"identifier": "handleStop", "parameters": "(Operation op)", "modifiers": "@Override public", "return": "void", "signature": "void handleStop(Operation op)", "full_signature": "@Override public void handleStop(Operation op)", "class_method_signature": "ProcessService.handleStop(Operation op)", "testcase": false, "constructor": false}, {"identifier": "handleMaintenance", "parameters": "(Operation op)", "modifiers": "@Override public", "return": "void", "signature": "void handleMaintenance(Operation op)", "full_signature": "@Override public void handleMaintenance(Operation op)", "class_method_signature": "ProcessService.handleMaintenance(Operation op)", "testcase": false, "constructor": false}], "file": "xenon-common/src/main/java/com/vmware/xenon/services/common/ProcessService.java"}, "focal_method": {"identifier": "startProcess", "parameters": "(Operation op, ProcessState state)", "modifiers": "protected", "return": "void", "body": "protected void startProcess(Operation op, ProcessState state) {\n        if (this.stopProcess()) {\n            // Reset back-off if the process was alive longer than STABLE_THRESHOLD_MILLIS.\n            // This threshold determines when we no longer see a process as flapping.\n            if ((this.processStopTimeMillis - this.processStartTimeMillis) >= STABLE_THRESHOLD_MILLIS) {\n                this.startDelayExp = 0;\n            }\n\n            this.startDelayMillis = TimeUnit.SECONDS\n                    .toMillis((int) Math.pow(2, this.startDelayExp) - 1);\n            if (this.startDelayMillis < MAX_START_DELAY_MILLIS) {\n                this.startDelayExp++;\n            } else {\n                this.startDelayMillis = MAX_START_DELAY_MILLIS;\n            }\n\n            // print the log before restarting\n            if (state.logLink != null && !state.logLink.isEmpty()) {\n                Operation getLog = Operation.createGet(UriUtils.buildUri(this.getHost(),\n                        state.logLink, \"lineCount=\" + LINES))\n                        .setCompletion((o, e) -> {\n                            if (e != null) {\n                                logWarning(\"Unable to get logs: %s\", e.getMessage());\n                                return;\n                            }\n                            String json = Utils.toJsonHtml(o.getBodyRaw());\n                            logInfo(\"%s\", json);\n                        });\n                sendRequest(getLog);\n            }\n\n            setStat(STAT_NAME_START_DELAY_MILLIS, this.startDelayMillis);\n            logWarning(\"Process %s exited with status %d, restarting in %ds\",\n                    state.arguments[0],\n                    this.processExitStatus,\n                    TimeUnit.MILLISECONDS.toSeconds(this.startDelayMillis));\n        }\n\n        // Check if we need to wait longer before starting the process again.\n        if ((new Date()).getTime() < this.processStopTimeMillis + this.startDelayMillis) {\n            op.complete();\n            return;\n        }\n\n        logInfo(\"Starting %s\", state.arguments[0]);\n        adjustStat(STAT_NAME_START_COUNT, 1);\n\n        ProcessBuilder pb = new ProcessBuilder(state.arguments);\n        if (state.logFile != null) {\n            File file = new File(state.logFile);\n            pb.redirectErrorStream(true);\n            pb.redirectOutput(Redirect.appendTo(file));\n        }\n\n        try {\n            this.process = pb.start();\n            this.processStartTimeMillis = (new Date()).getTime();\n        } catch (Exception e) {\n            logWarning(\"Failure starting %s (%s)\",\n                    state.arguments[0],\n                    e.toString());\n            op.fail(e);\n            return;\n        }\n\n        op.complete();\n    }", "signature": "void startProcess(Operation op, ProcessState state)", "full_signature": "protected void startProcess(Operation op, ProcessState state)", "class_method_signature": "ProcessService.startProcess(Operation op, ProcessState state)", "testcase": false, "constructor": false, "invocations": ["stopProcess", "toMillis", "pow", "isEmpty", "setCompletion", "createGet", "buildUri", "getHost", "logWarning", "getMessage", "toJsonHtml", "getBodyRaw", "logInfo", "sendRequest", "setStat", "logWarning", "toSeconds", "getTime", "complete", "logInfo", "adjustStat", "redirectErrorStream", "redirectOutput", "appendTo", "start", "getTime", "logWarning", "toString", "fail", "complete"]}, "repository": {"repo_id": 45276846, "url": "https://github.com/vmware-archive/xenon", "language": "Java", "is_fork": false, "fork_count": 97, "stargazer_count": 226, "size": 52010, "license": "licensed"}}