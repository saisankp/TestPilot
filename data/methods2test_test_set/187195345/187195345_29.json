{"test_class": {"identifier": "LocationCheckTest", "superclass": "", "interfaces": "", "fields": [], "file": "binary/src/test/java/openlr/binary/LocationCheckTest.java"}, "test_case": {"identifier": "testLocationCheck", "parameters": "()", "modifiers": "@Test public final", "return": "void", "body": "@Test\n    public final void testLocationCheck() {\n        Mockery context = new Mockery();\n        final Line l1 = context.mock(Line.class, \"l1\");\n        final Node sl1 = context.mock(Node.class, \"sl1)\");\n        final Node el1 = context.mock(Node.class, \"el1)\");\n\n        final Line l2 = context.mock(Line.class, \"l2\");\n        final Node sl2 = context.mock(Node.class, \"sl2)\");\n        final Node el2 = context.mock(Node.class, \"el2)\");\n\n        final Line l3 = context.mock(Line.class, \"l3\");\n        final Node sl3 = context.mock(Node.class, \"sl3)\");\n        final Node el3 = context.mock(Node.class, \"el3)\");\n\n\n        context.checking(new Expectations() {\n            {\n                allowing(l1).getStartNode();\n                will(returnValue(sl1));\n            }\n\n            {\n                allowing(l1).getEndNode();\n                will(returnValue(el1));\n            }\n\n            {\n                allowing(sl1).getLatitudeDeg();\n                will(returnValue(65.69));\n            }\n\n            {\n                allowing(el1).getLatitudeDeg();\n                will(returnValue(64.69));\n            }\n        });\n\n        context.checking(new Expectations() {\n            {\n                allowing(l2).getStartNode();\n                will(returnValue(sl2));\n            }\n\n            {\n                allowing(l2).getEndNode();\n                will(returnValue(el2));\n            }\n\n            {\n                allowing(sl2).getLatitudeDeg();\n                will(returnValue(66.00));\n            }\n\n            {\n                allowing(el2).getLatitudeDeg();\n                will(returnValue(64.69));\n            }\n        });\n\n        context.checking(new Expectations() {\n            {\n                allowing(l3).getStartNode();\n                will(returnValue(sl3));\n            }\n\n            {\n                allowing(l3).getEndNode();\n                will(returnValue(el3));\n            }\n\n            {\n                allowing(sl3).getLatitudeDeg();\n                will(returnValue(66.00));\n            }\n\n            {\n                allowing(el3).getLatitudeDeg();\n                will(returnValue(70.0));\n            }\n        });\n\n        List<Line> lines1 = new ArrayList<Line>();\n        lines1.add(l1);\n        int value1 = LocationCheck.calculateMaxDistanceFromPath(lines1);\n        assertEquals(value1, 15000);\n\n        List<Line> lines2 = new ArrayList<Line>();\n        lines2.add(l2);\n        int value2 = LocationCheck.calculateMaxDistanceFromPath(lines2);\n        assertEquals(value2, 14820);\n\n        List<Line> lines3 = new ArrayList<Line>();\n        lines3.add(l3);\n        int value3 = LocationCheck.calculateMaxDistanceFromPath(lines3);\n        assertEquals(value3, 12462);\n\n        List<Line> lines4 = new ArrayList<Line>();\n        lines4.add(l2);\n        lines4.add(l3);\n        int value4 = LocationCheck.calculateMaxDistanceFromPath(lines4);\n        assertEquals(value4, 12462);\n    }", "signature": "void testLocationCheck()", "full_signature": "@Test public final void testLocationCheck()", "class_method_signature": "LocationCheckTest.testLocationCheck()", "testcase": true, "constructor": false, "invocations": ["mock", "mock", "mock", "mock", "mock", "mock", "mock", "mock", "mock", "checking", "getStartNode", "allowing", "will", "returnValue", "getEndNode", "allowing", "will", "returnValue", "getLatitudeDeg", "allowing", "will", "returnValue", "getLatitudeDeg", "allowing", "will", "returnValue", "checking", "getStartNode", "allowing", "will", "returnValue", "getEndNode", "allowing", "will", "returnValue", "getLatitudeDeg", "allowing", "will", "returnValue", "getLatitudeDeg", "allowing", "will", "returnValue", "checking", "getStartNode", "allowing", "will", "returnValue", "getEndNode", "allowing", "will", "returnValue", "getLatitudeDeg", "allowing", "will", "returnValue", "getLatitudeDeg", "allowing", "will", "returnValue", "add", "calculateMaxDistanceFromPath", "assertEquals", "add", "calculateMaxDistanceFromPath", "assertEquals", "add", "calculateMaxDistanceFromPath", "assertEquals", "add", "add", "calculateMaxDistanceFromPath", "assertEquals"]}, "focal_class": {"identifier": "LocationCheck", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int METER_PER_KM = 1000;", "modifier": "private static final", "type": "int", "declarator": "METER_PER_KM = 1000", "var_name": "METER_PER_KM"}, {"original_string": "private static final double LAT_LON_BORDER = 65.69;", "modifier": "private static final", "type": "double", "declarator": "LAT_LON_BORDER = 65.69", "var_name": "LAT_LON_BORDER"}, {"original_string": "private static final int EARTH = 6371;", "modifier": "private static final", "type": "int", "declarator": "EARTH = 6371", "var_name": "EARTH"}, {"original_string": "private static final double MAX_LON_DIFF = 0.999983647;", "modifier": "private static final", "type": "double", "declarator": "MAX_LON_DIFF = 0.999983647", "var_name": "MAX_LON_DIFF"}, {"original_string": "private static final int DEFAULT_DISTANCE = 15000;", "modifier": "private static final", "type": "int", "declarator": "DEFAULT_DISTANCE = 15000", "var_name": "DEFAULT_DISTANCE"}, {"original_string": "private static final double RADIANS_FACTOR = 0.0174532925;", "modifier": "private static final", "type": "double", "declarator": "RADIANS_FACTOR = 0.0174532925", "var_name": "RADIANS_FACTOR"}], "methods": [{"identifier": "LocationCheck", "parameters": "()", "modifiers": "private", "return": "", "signature": " LocationCheck()", "full_signature": "private  LocationCheck()", "class_method_signature": "LocationCheck.LocationCheck()", "testcase": false, "constructor": true}, {"identifier": "calculateMaxDistanceFromPath", "parameters": "(final List<? extends Line> lines)", "modifiers": "public static", "return": "int", "signature": "int calculateMaxDistanceFromPath(final List<? extends Line> lines)", "full_signature": "public static int calculateMaxDistanceFromPath(final List<? extends Line> lines)", "class_method_signature": "LocationCheck.calculateMaxDistanceFromPath(final List<? extends Line> lines)", "testcase": false, "constructor": false}, {"identifier": "calculateMaxDistanceFromCoordinates", "parameters": "(final List<? extends GeoCoordinates> coords)", "modifiers": "public static", "return": "int", "signature": "int calculateMaxDistanceFromCoordinates(final List<? extends GeoCoordinates> coords)", "full_signature": "public static int calculateMaxDistanceFromCoordinates(final List<? extends GeoCoordinates> coords)", "class_method_signature": "LocationCheck.calculateMaxDistanceFromCoordinates(final List<? extends GeoCoordinates> coords)", "testcase": false, "constructor": false}, {"identifier": "calculateDist", "parameters": "(final double maxLat)", "modifiers": "private static", "return": "int", "signature": "int calculateDist(final double maxLat)", "full_signature": "private static int calculateDist(final double maxLat)", "class_method_signature": "LocationCheck.calculateDist(final double maxLat)", "testcase": false, "constructor": false}, {"identifier": "resolveMaximumLatitudeFromPath", "parameters": "(final List<? extends Line> lines)", "modifiers": "private static", "return": "double", "signature": "double resolveMaximumLatitudeFromPath(final List<? extends Line> lines)", "full_signature": "private static double resolveMaximumLatitudeFromPath(final List<? extends Line> lines)", "class_method_signature": "LocationCheck.resolveMaximumLatitudeFromPath(final List<? extends Line> lines)", "testcase": false, "constructor": false}, {"identifier": "resolveMaximumLatitudeFromCoordinates", "parameters": "(final List<? extends GeoCoordinates> coords)", "modifiers": "private static", "return": "double", "signature": "double resolveMaximumLatitudeFromCoordinates(final List<? extends GeoCoordinates> coords)", "full_signature": "private static double resolveMaximumLatitudeFromCoordinates(final List<? extends GeoCoordinates> coords)", "class_method_signature": "LocationCheck.resolveMaximumLatitudeFromCoordinates(final List<? extends GeoCoordinates> coords)", "testcase": false, "constructor": false}], "file": "binary/src/main/java/openlr/binary/LocationCheck.java"}, "focal_method": {"identifier": "LocationCheck", "parameters": "()", "modifiers": "private", "return": "", "body": "private LocationCheck() {\n        throw new UnsupportedOperationException();\n    }", "signature": " LocationCheck()", "full_signature": "private  LocationCheck()", "class_method_signature": "LocationCheck.LocationCheck()", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 187195345, "url": "https://github.com/tomtom-international/openlr", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 24, "size": 4809, "license": "licensed"}}