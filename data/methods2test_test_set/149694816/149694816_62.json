{"test_class": {"identifier": "CreateProjectTest", "superclass": "extends AbstractTestCase", "interfaces": "", "fields": [], "file": "core/src/test/java/ship/command/CreateProjectTest.java"}, "test_case": {"identifier": "testExecute", "parameters": "()", "modifiers": "@Test @PrepareForTest({CreateProject.class, File.class}) @SuppressWarnings(\"unchecked\") public", "return": "void", "body": "@Test\n  @PrepareForTest({CreateProject.class, File.class})\n  @SuppressWarnings(\"unchecked\")\n  public void testExecute() throws Exception {\n    // Given\n    final ProjectFile projectFile = new ProjectFile();\n    final WriteProjectFile writeProjectFile = mock(WriteProjectFile.class);\n    final CreateProject command = spy(new CreateProject());\n\n    whenNew(ProjectFile.class).withAnyArguments().thenReturn(projectFile);\n    whenNew(WriteProjectFile.class).withAnyArguments().thenReturn(writeProjectFile);\n    mockStatic(Files.class);\n    when(Files.list(any())).thenReturn(EMPTY_LIST.stream());\n    when(Files.newInputStream(any()))\n        .thenReturn(new ByteArrayInputStream(\"hello, world\".getBytes()));\n    doNothing().when(command).prepare(any());\n\n    // When\n    command.setPrinter(mock(MessagePrinter.class));\n    command.execute();\n\n    // Then\n    verify(writeProjectFile).execute();\n  }", "signature": "void testExecute()", "full_signature": "@Test @PrepareForTest({CreateProject.class, File.class}) @SuppressWarnings(\"unchecked\") public void testExecute()", "class_method_signature": "CreateProjectTest.testExecute()", "testcase": true, "constructor": false, "invocations": ["mock", "spy", "thenReturn", "withAnyArguments", "whenNew", "thenReturn", "withAnyArguments", "whenNew", "mockStatic", "thenReturn", "when", "list", "any", "stream", "thenReturn", "when", "newInputStream", "any", "getBytes", "prepare", "when", "doNothing", "any", "setPrinter", "mock", "execute", "execute", "verify"]}, "focal_class": {"identifier": "CreateProject", "superclass": "extends AbstractCommand", "interfaces": "implements Command", "fields": [{"original_string": "protected static final String NL_0 = CreateProject.class.getName() + \".0\";", "modifier": "protected static final", "type": "String", "declarator": "NL_0 = CreateProject.class.getName() + \".0\"", "var_name": "NL_0"}, {"original_string": "protected static final String NL_1 = CreateProject.class.getName() + \".1\";", "modifier": "protected static final", "type": "String", "declarator": "NL_1 = CreateProject.class.getName() + \".1\"", "var_name": "NL_1"}, {"original_string": "protected static final String NL_2 = CreateProject.class.getName() + \".2\";", "modifier": "protected static final", "type": "String", "declarator": "NL_2 = CreateProject.class.getName() + \".2\"", "var_name": "NL_2"}], "methods": [{"identifier": "newProjectFile", "parameters": "(final String projectName)", "modifiers": "protected", "return": "ProjectFile", "signature": "ProjectFile newProjectFile(final String projectName)", "full_signature": "protected ProjectFile newProjectFile(final String projectName)", "class_method_signature": "CreateProject.newProjectFile(final String projectName)", "testcase": false, "constructor": false}, {"identifier": "prepare", "parameters": "(final ProjectFile projectFile)", "modifiers": "protected", "return": "void", "signature": "void prepare(final ProjectFile projectFile)", "full_signature": "protected void prepare(final ProjectFile projectFile)", "class_method_signature": "CreateProject.prepare(final ProjectFile projectFile)", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void execute()", "full_signature": "@Override public void execute()", "class_method_signature": "CreateProject.execute()", "testcase": false, "constructor": false}], "file": "core/src/main/java/ship/command/CreateProject.java"}, "focal_method": {"identifier": "execute", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void execute() throws Exception {\n    logger.debug(\"Starting {} with {}...\", this, arguments);\n\n    final Options options = parse(new Options());\n    final Path projectPath = getProjectHome();\n    final String projectPathStr = getProjectHomePath();\n    final Path projectFilePath = getProjectFile();\n    final String projectFilePathStr = getProjectFilePath();\n\n    final WriteProjectFile writeProjectFile = new WriteProjectFile();\n    final String projectDirectoryName = getFilename(projectPathStr);\n    if (!options.isForce() && 0 < Files.list(projectPath).count()) {\n      logger.trace(\"Force: {}\", options.isForce());\n      throw new DirectoryNotEmptyException(projectPath);\n    }\n    final String projectName = System.getProperty(\"user.name\") + \"/\" + projectDirectoryName;\n    final ProjectFile newProjectFile = newProjectFile(projectName);\n    prepare(newProjectFile);\n    writeProjectFile.setProject(newProjectFile);\n    writeProjectFile.setArguments(singletonList(projectFilePathStr));\n    writeProjectFile.execute();\n\n    printer.println(bind(NL_0, projectPathStr));\n    try (\n        final InputStream in = Files.newInputStream(projectFilePath);\n        final Reader reader = new InputStreamReader(in)) {\n      printer.println(bind(NL_1, projectFilePathStr));\n      printer.println(IoUtils.from(reader));\n    }\n  }", "signature": "void execute()", "full_signature": "@Override public void execute()", "class_method_signature": "CreateProject.execute()", "testcase": false, "constructor": false, "invocations": ["debug", "parse", "getProjectHome", "getProjectHomePath", "getProjectFile", "getProjectFilePath", "getFilename", "isForce", "count", "list", "trace", "isForce", "getProperty", "newProjectFile", "prepare", "setProject", "setArguments", "singletonList", "execute", "println", "bind", "newInputStream", "println", "bind", "println", "from"]}, "repository": {"repo_id": 149694816, "url": "https://github.com/aergoio/ship", "language": "Java", "is_fork": false, "fork_count": 4, "stargazer_count": 11, "size": 1743, "license": "licensed"}}