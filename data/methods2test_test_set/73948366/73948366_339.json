{"test_class": {"identifier": "KeyStoreJwkKeyResolverTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final ClassLoader classLoader = this.getClass().getClassLoader();", "modifier": "private final", "type": "ClassLoader", "declarator": "classLoader = this.getClass().getClassLoader()", "var_name": "classLoader"}, {"original_string": "private final DefaultJwsHeader baseJwsHeader = new DefaultJwsHeader();", "modifier": "private final", "type": "DefaultJwsHeader", "declarator": "baseJwsHeader = new DefaultJwsHeader()", "var_name": "baseJwsHeader"}, {"original_string": "private final KeyStore baseKeyStore = new KeyStore() {\n        public String getPublicKey(String domain, String service, String keyId) {\n            return null;\n        }\n    };", "modifier": "private final", "type": "KeyStore", "declarator": "baseKeyStore = new KeyStore() {\n        public String getPublicKey(String domain, String service, String keyId) {\n            return null;\n        }\n    }", "var_name": "baseKeyStore"}, {"original_string": "private final SigningKeyResolver basejwksResolver = new SigningKeyResolver() {\n        public Key resolveSigningKey(JwsHeader header, Claims claims) { return null; }\n        public Key resolveSigningKey(JwsHeader header, String plaintext) { return null; }\n    };", "modifier": "private final", "type": "SigningKeyResolver", "declarator": "basejwksResolver = new SigningKeyResolver() {\n        public Key resolveSigningKey(JwsHeader header, Claims claims) { return null; }\n        public Key resolveSigningKey(JwsHeader header, String plaintext) { return null; }\n    }", "var_name": "basejwksResolver"}, {"original_string": "private final PublicKey basePublicKey = new PublicKey() {\n        private static final long serialVersionUID = 1L;\n        public String getFormat() { return null; }\n        public byte[] getEncoded() { return null; }\n        public String getAlgorithm() { return null; }\n    };", "modifier": "private final", "type": "PublicKey", "declarator": "basePublicKey = new PublicKey() {\n        private static final long serialVersionUID = 1L;\n        public String getFormat() { return null; }\n        public byte[] getEncoded() { return null; }\n        public String getAlgorithm() { return null; }\n    }", "var_name": "basePublicKey"}], "file": "libs/java/auth_core/src/test/java/com/yahoo/athenz/auth/oauth/parser/KeyStoreJwkKeyResolverTest.java"}, "test_case": {"identifier": "testResolveSigningKey", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testResolveSigningKey() throws Exception {\n        // mocks\n        KeyStore keyStoreMock = Mockito.spy(baseKeyStore);\n        SigningKeyResolver jwksResolverMock = Mockito.spy(basejwksResolver);\n\n        // instance\n        KeyStoreJwkKeyResolver resolver = new KeyStoreJwkKeyResolver(null, \"file:///\", null);\n        Field keyStoreField = resolver.getClass().getDeclaredField(\"keyStore\");\n        keyStoreField.setAccessible(true);\n        Field providerField = resolver.getClass().getDeclaredField(\"jwksResolver\");\n        providerField.setAccessible(true);\n        providerField.set(resolver, jwksResolverMock);\n\n        // args\n        DefaultJwsHeader jwsHeader = new DefaultJwsHeader();\n        DefaultClaims claims = new DefaultClaims();\n\n        // 1. null key store, find in JWKS\n        PublicKey pk11 = Mockito.spy(basePublicKey);\n        Mockito.when(jwksResolverMock.resolveSigningKey(jwsHeader, claims)).thenReturn(pk11);\n        jwsHeader.setKeyId(\"11\");\n        claims.setIssuer(null);\n        assertSame(resolver.resolveSigningKey(jwsHeader, claims), pk11);\n\n        // set key store mock\n        keyStoreField.set(resolver, keyStoreMock);\n\n        // 2. invalid issuer, find in JWKS\n        PublicKey pk21 = Mockito.spy(basePublicKey);\n        Mockito.when(jwksResolverMock.resolveSigningKey(jwsHeader, claims)).thenReturn(pk21);\n        jwsHeader.setKeyId(\"21\");\n        claims.setIssuer(null);\n        assertSame(resolver.resolveSigningKey(jwsHeader, claims), pk21);\n        PublicKey pk22 = Mockito.spy(basePublicKey);\n        Mockito.when(jwksResolverMock.resolveSigningKey(jwsHeader, claims)).thenReturn(pk22);\n        jwsHeader.setKeyId(\"22\");\n        claims.setIssuer(\"\");\n        assertSame(resolver.resolveSigningKey(jwsHeader, claims), pk22);\n        PublicKey pk23 = Mockito.spy(basePublicKey);\n        Mockito.when(jwksResolverMock.resolveSigningKey(jwsHeader, claims)).thenReturn(pk23);\n        jwsHeader.setKeyId(\"23\");\n        claims.setIssuer(\"domain23-----service23\");\n        assertSame(resolver.resolveSigningKey(jwsHeader, claims), pk23);\n        // 2. invalid domain, find in JWKS\n        PublicKey pk24 = Mockito.spy(basePublicKey);\n        Mockito.when(jwksResolverMock.resolveSigningKey(jwsHeader, claims)).thenReturn(pk24);\n        jwsHeader.setKeyId(\"24\");\n        claims.setIssuer(\"domain24.service24\");\n        assertSame(resolver.resolveSigningKey(jwsHeader, claims), pk24);\n\n        // 3. found in key store, skip JWKS\n        PublicKey pk31 = null;\n\n        try (PemReader reader = new PemReader(new FileReader(this.classLoader.getResource(\"jwt_public.key\").getFile()))) {\n            pk31 = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(reader.readPemObject().getContent()));\n        }\n        Mockito.when(jwksResolverMock.resolveSigningKey(jwsHeader, claims)).thenReturn(pk31);\n        Mockito.when(keyStoreMock.getPublicKey(\"sys.auth\", \"service31\", \"31\")).thenReturn(\"-----BEGIN PUBLIC KEY-----\\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAy3c3TEePZZPaxqNU2xV4\\nortsXrw1EXTNQj2QUgL8UOPaQS0lbHJtD1cbcCFnzfXRXTOGqh8l+XWTRIOlt4yU\\n+mEhgR0/JKILTPwmS0fj3D1PT6IjZShuNyd4USVdcjfCRBRb9ExIptJyeTTUu0Uu\\njWNEcGOWAkUZcsonmiEz7bIMVkGy5uYnWGbsKP51Zf/PFMb96RcHeE0ZUitIB4YK\\n1bgHLyAEBJIka5mRC/jWq/mlq3jiP5RaVWbzQiJbrjuYWd1Vps/xnrABx6/4Ft/M\\n0AnSQN0SYjc/nWT1yGPpCwtWmWUU5NNHd+w6TdgOjdu00wownwblovtEYED+rncb\\n913qfBM98kNHyj357BSzlvhiwEH5Ayo9DTnx1j9HuJGZXzymVypuQXLu/tkHMEt+\\nc4kytKJNi6MLiauy9xtXGLXgOvZUM8V0Z27Z6CTfCzWZ0nwnEWDdH+NJyusL6pJg\\nEGUBh6E9fdJInV7YOCF+P9/19imPHrZ0blTXK1TDfKS/pCLOXO/OmmH+p+UxQ77O\\npeP5wlt5Jem0ErSisl/Qxhh1OtJcLwFdA7uC7rOTMrSEGLO++5+CatsXj7BEK2l+\\n3As8fJEkoWXd1+4KOUMfV/fnT/z6U8+bcsYn0nvWPl8XuMbwNWjqHYgqhl1RLA7M\\n17HCydWCF50HI2XojtGgRN0CAwEAAQ==\\n-----END PUBLIC KEY-----\\n\");\n        jwsHeader.setKeyId(\"31\");\n        claims.setIssuer(\"sys.auth.service31\");\n        assertEquals(resolver.resolveSigningKey(jwsHeader, claims), pk31);\n        // 3. NOT found in key store, find in JWKS\n        PublicKey pk32 = Mockito.spy(basePublicKey);\n        Mockito.when(jwksResolverMock.resolveSigningKey(jwsHeader, claims)).thenReturn(pk32);\n        Mockito.when(keyStoreMock.getPublicKey(\"sys.auth\", \"service32\", \"32\")).thenReturn(null);\n        jwsHeader.setKeyId(\"32\");\n        claims.setIssuer(\"sys.auth.service32\");\n        assertSame(resolver.resolveSigningKey(jwsHeader, claims), pk32);\n        // 3. found in key store but public key invalid, find in JWKS\n        PublicKey pk33 = Mockito.spy(basePublicKey);\n        Mockito.when(jwksResolverMock.resolveSigningKey(jwsHeader, claims)).thenReturn(pk33);\n        Mockito.when(keyStoreMock.getPublicKey(\"sys.auth\", \"service33\", \"33\")).thenReturn(\"\");\n        jwsHeader.setKeyId(\"33\");\n        claims.setIssuer(\"sys.auth.service33\");\n        assertSame(resolver.resolveSigningKey(jwsHeader, claims), pk33);\n        PublicKey pk34 = Mockito.spy(basePublicKey);\n        Mockito.when(jwksResolverMock.resolveSigningKey(jwsHeader, claims)).thenReturn(pk34);\n        Mockito.when(keyStoreMock.getPublicKey(\"sys.auth\", \"service34\", \"34\")).thenReturn(\"-----BEGIN PUBLIC KEY-----\\ninvalid\\n-----END PUBLIC KEY-----\\n\");\n        jwsHeader.setKeyId(\"34\");\n        claims.setIssuer(\"sys.auth.service34\");\n        assertSame(resolver.resolveSigningKey(jwsHeader, claims), pk34);\n\n        // 4. both NOT found\n        jwsHeader.setKeyId(\"41\");\n        claims.setIssuer(\"sys.auth.service41\");\n        Mockito.when(jwksResolverMock.resolveSigningKey(jwsHeader, claims)).thenReturn(null);\n        Mockito.when(keyStoreMock.getPublicKey(\"sys.auth\", \"service41\", \"41\")).thenReturn(null);\n        assertNull(resolver.resolveSigningKey(jwsHeader, claims));\n\n        // 5. skip, empty key ID\n        jwsHeader.setKeyId(null);\n        claims.setIssuer(null);\n        assertNull(resolver.resolveSigningKey(jwsHeader, claims));\n        jwsHeader.setKeyId(\"\");\n        claims.setIssuer(null);\n        assertNull(resolver.resolveSigningKey(jwsHeader, claims));\n    }", "signature": "void testResolveSigningKey()", "full_signature": "@Test public void testResolveSigningKey()", "class_method_signature": "KeyStoreJwkKeyResolverTest.testResolveSigningKey()", "testcase": true, "constructor": false, "invocations": ["spy", "spy", "getDeclaredField", "getClass", "setAccessible", "getDeclaredField", "getClass", "setAccessible", "set", "spy", "thenReturn", "when", "resolveSigningKey", "setKeyId", "setIssuer", "assertSame", "resolveSigningKey", "set", "spy", "thenReturn", "when", "resolveSigningKey", "setKeyId", "setIssuer", "assertSame", "resolveSigningKey", "spy", "thenReturn", "when", "resolveSigningKey", "setKeyId", "setIssuer", "assertSame", "resolveSigningKey", "spy", "thenReturn", "when", "resolveSigningKey", "setKeyId", "setIssuer", "assertSame", "resolveSigningKey", "spy", "thenReturn", "when", "resolveSigningKey", "setKeyId", "setIssuer", "assertSame", "resolveSigningKey", "getFile", "getResource", "generatePublic", "getInstance", "getContent", "readPemObject", "thenReturn", "when", "resolveSigningKey", "thenReturn", "when", "getPublicKey", "setKeyId", "setIssuer", "assertEquals", "resolveSigningKey", "spy", "thenReturn", "when", "resolveSigningKey", "thenReturn", "when", "getPublicKey", "setKeyId", "setIssuer", "assertSame", "resolveSigningKey", "spy", "thenReturn", "when", "resolveSigningKey", "thenReturn", "when", "getPublicKey", "setKeyId", "setIssuer", "assertSame", "resolveSigningKey", "spy", "thenReturn", "when", "resolveSigningKey", "thenReturn", "when", "getPublicKey", "setKeyId", "setIssuer", "assertSame", "resolveSigningKey", "setKeyId", "setIssuer", "thenReturn", "when", "resolveSigningKey", "thenReturn", "when", "getPublicKey", "assertNull", "resolveSigningKey", "setKeyId", "setIssuer", "assertNull", "resolveSigningKey", "setKeyId", "setIssuer", "assertNull", "resolveSigningKey"]}, "focal_class": {"identifier": "KeyStoreJwkKeyResolver", "superclass": "", "interfaces": "implements SigningKeyResolver", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(KeyStoreJwkKeyResolver.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(KeyStoreJwkKeyResolver.class)", "var_name": "LOG"}, {"original_string": "private static final String SYS_AUTH_DOMAIN = \"sys.auth\";", "modifier": "private static final", "type": "String", "declarator": "SYS_AUTH_DOMAIN = \"sys.auth\"", "var_name": "SYS_AUTH_DOMAIN"}, {"original_string": "private KeyStore keyStore = null;", "modifier": "private", "type": "KeyStore", "declarator": "keyStore = null", "var_name": "keyStore"}, {"original_string": "private SigningKeyResolver jwksResolver = null;", "modifier": "private", "type": "SigningKeyResolver", "declarator": "jwksResolver = null", "var_name": "jwksResolver"}], "methods": [{"identifier": "KeyStoreJwkKeyResolver", "parameters": "(KeyStore keyStore, String url, SSLContext sslContext)", "modifiers": "public", "return": "", "signature": " KeyStoreJwkKeyResolver(KeyStore keyStore, String url, SSLContext sslContext)", "full_signature": "public  KeyStoreJwkKeyResolver(KeyStore keyStore, String url, SSLContext sslContext)", "class_method_signature": "KeyStoreJwkKeyResolver.KeyStoreJwkKeyResolver(KeyStore keyStore, String url, SSLContext sslContext)", "testcase": false, "constructor": true}, {"identifier": "resolveSigningKey", "parameters": "(JwsHeader header, Claims claims)", "modifiers": "@Override @SuppressWarnings(\"rawtypes\") public", "return": "Key", "signature": "Key resolveSigningKey(JwsHeader header, Claims claims)", "full_signature": "@Override @SuppressWarnings(\"rawtypes\") public Key resolveSigningKey(JwsHeader header, Claims claims)", "class_method_signature": "KeyStoreJwkKeyResolver.resolveSigningKey(JwsHeader header, Claims claims)", "testcase": false, "constructor": false}, {"identifier": "resolveSigningKey", "parameters": "(JwsHeader header, String plaintext)", "modifiers": "@Override @SuppressWarnings(\"rawtypes\") public", "return": "Key", "signature": "Key resolveSigningKey(JwsHeader header, String plaintext)", "full_signature": "@Override @SuppressWarnings(\"rawtypes\") public Key resolveSigningKey(JwsHeader header, String plaintext)", "class_method_signature": "KeyStoreJwkKeyResolver.resolveSigningKey(JwsHeader header, String plaintext)", "testcase": false, "constructor": false}], "file": "libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/oauth/parser/KeyStoreJwkKeyResolver.java"}, "focal_method": {"identifier": "resolveSigningKey", "parameters": "(JwsHeader header, Claims claims)", "modifiers": "@Override @SuppressWarnings(\"rawtypes\") public", "return": "Key", "body": "@Override\n    @SuppressWarnings(\"rawtypes\")\n    public Key resolveSigningKey(JwsHeader header, Claims claims) {\n        String keyId = header.getKeyId();\n        if (keyId == null || keyId.isEmpty()) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"KeyStoreJwkKeyResolver:resolveSigningKey: invalid key ID \" + keyId);\n            }\n            return null;\n        }\n\n        // 1. find in key store\n        String issuer = claims.getIssuer();\n        if (this.keyStore != null && issuer != null && !issuer.isEmpty()) {\n            String[] ds = AthenzUtils.splitPrincipalName(issuer);\n            if (ds == null) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"KeyStoreJwkKeyResolver:resolveSigningKey: skip using KeyStore, invalid issuer \" + issuer);\n                }\n            } else {\n                String domain = ds[0];\n                String service = ds[1];\n\n                if (!SYS_AUTH_DOMAIN.equals(domain)) {\n                    LOG.debug(\"KeyStoreJwkKeyResolver:resolveSigningKey: skip using KeyStore, invalid domain \" + domain);\n                } else {\n                    String publicKey = this.keyStore.getPublicKey(domain, service, keyId);\n                    if (publicKey != null && !publicKey.isEmpty()) {\n                        try {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"KeyStoreJwkKeyResolver:resolveSigningKey: will use public key from key store: ({}, {}, {})\", domain, service, keyId);\n                            }\n                            return Crypto.loadPublicKey(publicKey);\n                        } catch (Throwable t) {\n                            LOG.warn(\"KeyStoreJwkKeyResolver:resolveSigningKey: invalid public key format\", t);\n                        }\n                    }\n                }\n            }\n        }\n\n        // 2. find in JWKS\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"KeyStoreJwkKeyResolver:resolveSigningKey: will use public key from JWKS: ({})\", keyId);\n        }\n        return this.jwksResolver.resolveSigningKey(header, claims);\n    }", "signature": "Key resolveSigningKey(JwsHeader header, Claims claims)", "full_signature": "@Override @SuppressWarnings(\"rawtypes\") public Key resolveSigningKey(JwsHeader header, Claims claims)", "class_method_signature": "KeyStoreJwkKeyResolver.resolveSigningKey(JwsHeader header, Claims claims)", "testcase": false, "constructor": false, "invocations": ["getKeyId", "isEmpty", "isDebugEnabled", "debug", "getIssuer", "isEmpty", "splitPrincipalName", "isDebugEnabled", "debug", "equals", "debug", "getPublicKey", "isEmpty", "isDebugEnabled", "debug", "loadPublicKey", "warn", "isDebugEnabled", "debug", "resolveSigningKey"]}, "repository": {"repo_id": 73948366, "url": "https://github.com/yahoo/athenz", "stars": 394, "created": "11/16/2016 6:23:08 PM +00:00", "updates": "2020-01-27T15:36:13+00:00", "fork": "False", "license": "licensed"}}