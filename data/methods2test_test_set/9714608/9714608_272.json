{"test_class": {"identifier": "TextUtilTest", "superclass": "extends AbstractTestCase", "interfaces": "", "fields": [], "file": "core/text/src/test/java/org/arakhne/afc/text/TextUtilTest.java"}, "test_case": {"identifier": "getLevenshteinDistance", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void getLevenshteinDistance() {\n\t\tassertEquals(0, TextUtil.getLevenshteinDistance(null, null));\n\t\tassertEquals(0, TextUtil.getLevenshteinDistance(null, \"\")); //$NON-NLS-1$\n\t\tassertEquals(0, TextUtil.getLevenshteinDistance(\"\", null)); //$NON-NLS-1$\n\t\tassertEquals(0, TextUtil.getLevenshteinDistance(\"\", \"\")); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tassertEquals(1, TextUtil.getLevenshteinDistance(\"\", \"a\")); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tassertEquals(3, TextUtil.getLevenshteinDistance(\"a\", \"abcd\")); //$NON-NLS-1$ //$NON-NLS-2$\n\t}", "signature": "void getLevenshteinDistance()", "full_signature": "@Test public void getLevenshteinDistance()", "class_method_signature": "TextUtilTest.getLevenshteinDistance()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "getLevenshteinDistance", "assertEquals", "getLevenshteinDistance", "assertEquals", "getLevenshteinDistance", "assertEquals", "getLevenshteinDistance", "assertEquals", "getLevenshteinDistance", "assertEquals", "getLevenshteinDistance"]}, "focal_class": {"identifier": "TextUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final ReentrantLock LOCK = new ReentrantLock();", "modifier": "private static final", "type": "ReentrantLock", "declarator": "LOCK = new ReentrantLock()", "var_name": "LOCK"}, {"original_string": "private static SoftReference<Map<Character, String>> accentTransTbl;", "modifier": "private static", "type": "SoftReference<Map<Character, String>>", "declarator": "accentTransTbl", "var_name": "accentTransTbl"}, {"original_string": "private static SoftReference<Map<String, Integer>> htmlToJavaTransTbl;", "modifier": "private static", "type": "SoftReference<Map<String, Integer>>", "declarator": "htmlToJavaTransTbl", "var_name": "htmlToJavaTransTbl"}, {"original_string": "private static SoftReference<Map<Character, String>> javaToHtmlTransTbl;", "modifier": "private static", "type": "SoftReference<Map<Character, String>>", "declarator": "javaToHtmlTransTbl", "var_name": "javaToHtmlTransTbl"}], "methods": [{"identifier": "TextUtil", "parameters": "()", "modifiers": "private", "return": "", "signature": " TextUtil()", "full_signature": "private  TextUtil()", "class_method_signature": "TextUtil.TextUtil()", "testcase": false, "constructor": true}, {"identifier": "equalsIgnoreCase", "parameters": "(String firstText, String secondText, boolean isNullEmptyEquivalence)", "modifiers": "@Pure public static", "return": "boolean", "signature": "boolean equalsIgnoreCase(String firstText, String secondText, boolean isNullEmptyEquivalence)", "full_signature": "@Pure public static boolean equalsIgnoreCase(String firstText, String secondText, boolean isNullEmptyEquivalence)", "class_method_signature": "TextUtil.equalsIgnoreCase(String firstText, String secondText, boolean isNullEmptyEquivalence)", "testcase": false, "constructor": false}, {"identifier": "encodeBase26", "parameters": "(int number)", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:magicnumber\") public static", "return": "String", "signature": "String encodeBase26(int number)", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:magicnumber\") public static String encodeBase26(int number)", "class_method_signature": "TextUtil.encodeBase26(int number)", "testcase": false, "constructor": false}, {"identifier": "getHtmlToJavaTranslationTable", "parameters": "()", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static", "return": "Map<String, Integer>", "signature": "Map<String, Integer> getHtmlToJavaTranslationTable()", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static Map<String, Integer> getHtmlToJavaTranslationTable()", "class_method_signature": "TextUtil.getHtmlToJavaTranslationTable()", "testcase": false, "constructor": false}, {"identifier": "getJavaToHTMLTranslationTable", "parameters": "()", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static", "return": "Map<Character, String>", "signature": "Map<Character, String> getJavaToHTMLTranslationTable()", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static Map<Character, String> getJavaToHTMLTranslationTable()", "class_method_signature": "TextUtil.getJavaToHTMLTranslationTable()", "testcase": false, "constructor": false}, {"identifier": "parseHTML", "parameters": "(String html)", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:magicnumber\") public static", "return": "String", "signature": "String parseHTML(String html)", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:magicnumber\") public static String parseHTML(String html)", "class_method_signature": "TextUtil.parseHTML(String html)", "testcase": false, "constructor": false}, {"identifier": "toHTML", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String toHTML(String text)", "full_signature": "@Pure public static String toHTML(String text)", "class_method_signature": "TextUtil.toHTML(String text)", "testcase": false, "constructor": false}, {"identifier": "cutString", "parameters": "(String text, int column)", "modifiers": "@Pure public static", "return": "String", "signature": "String cutString(String text, int column)", "full_signature": "@Pure public static String cutString(String text, int column)", "class_method_signature": "TextUtil.cutString(String text, int column)", "testcase": false, "constructor": false}, {"identifier": "cutStringAsArray", "parameters": "(String text, int column)", "modifiers": "@Pure public static", "return": "String[]", "signature": "String[] cutStringAsArray(String text, int column)", "full_signature": "@Pure public static String[] cutStringAsArray(String text, int column)", "class_method_signature": "TextUtil.cutStringAsArray(String text, int column)", "testcase": false, "constructor": false}, {"identifier": "cutStringAsArray", "parameters": "(String text, CutStringCritera critera, List<String> output)", "modifiers": "public static", "return": "void", "signature": "void cutStringAsArray(String text, CutStringCritera critera, List<String> output)", "full_signature": "public static void cutStringAsArray(String text, CutStringCritera critera, List<String> output)", "class_method_signature": "TextUtil.cutStringAsArray(String text, CutStringCritera critera, List<String> output)", "testcase": false, "constructor": false}, {"identifier": "cutStringAlgo", "parameters": "(String text, CutStringCritera critera, CutStringAlgorithm algo)", "modifiers": "private static", "return": "void", "signature": "void cutStringAlgo(String text, CutStringCritera critera, CutStringAlgorithm algo)", "full_signature": "private static void cutStringAlgo(String text, CutStringCritera critera, CutStringAlgorithm algo)", "class_method_signature": "TextUtil.cutStringAlgo(String text, CutStringCritera critera, CutStringAlgorithm algo)", "testcase": false, "constructor": false}, {"identifier": "getMnemonicChar", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "char", "signature": "char getMnemonicChar(String text)", "full_signature": "@Pure public static char getMnemonicChar(String text)", "class_method_signature": "TextUtil.getMnemonicChar(String text)", "testcase": false, "constructor": false}, {"identifier": "removeMnemonicChar", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String removeMnemonicChar(String text)", "full_signature": "@Pure public static String removeMnemonicChar(String text)", "class_method_signature": "TextUtil.removeMnemonicChar(String text)", "testcase": false, "constructor": false}, {"identifier": "getAccentTranslationTable", "parameters": "()", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static", "return": "Map<Character, String>", "signature": "Map<Character, String> getAccentTranslationTable()", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:npathcomplexity\") public static Map<Character, String> getAccentTranslationTable()", "class_method_signature": "TextUtil.getAccentTranslationTable()", "testcase": false, "constructor": false}, {"identifier": "removeAccents", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String removeAccents(String text)", "full_signature": "@Pure public static String removeAccents(String text)", "class_method_signature": "TextUtil.removeAccents(String text)", "testcase": false, "constructor": false}, {"identifier": "removeAccents", "parameters": "(String text, Map<Character, String> map)", "modifiers": "@Pure public static", "return": "String", "signature": "String removeAccents(String text, Map<Character, String> map)", "full_signature": "@Pure public static String removeAccents(String text, Map<Character, String> map)", "class_method_signature": "TextUtil.removeAccents(String text, Map<Character, String> map)", "testcase": false, "constructor": false}, {"identifier": "splitBrackets", "parameters": "(String str)", "modifiers": "@Pure @Inline(value = \"textUtil.split('{', '}', $1)\", imported = {TextUtil.class}) public static", "return": "String[]", "signature": "String[] splitBrackets(String str)", "full_signature": "@Pure @Inline(value = \"textUtil.split('{', '}', $1)\", imported = {TextUtil.class}) public static String[] splitBrackets(String str)", "class_method_signature": "TextUtil.splitBrackets(String str)", "testcase": false, "constructor": false}, {"identifier": "split", "parameters": "(char leftSeparator, char rightSeparator, String str)", "modifiers": "@Pure public static", "return": "String[]", "signature": "String[] split(char leftSeparator, char rightSeparator, String str)", "full_signature": "@Pure public static String[] split(char leftSeparator, char rightSeparator, String str)", "class_method_signature": "TextUtil.split(char leftSeparator, char rightSeparator, String str)", "testcase": false, "constructor": false}, {"identifier": "splitBracketsAsList", "parameters": "(String str)", "modifiers": "@Pure @Inline(value = \"textUtil.splitAsList('{', '}', $1)\", imported = {TextUtil.class}) public static", "return": "List<String>", "signature": "List<String> splitBracketsAsList(String str)", "full_signature": "@Pure @Inline(value = \"textUtil.splitAsList('{', '}', $1)\", imported = {TextUtil.class}) public static List<String> splitBracketsAsList(String str)", "class_method_signature": "TextUtil.splitBracketsAsList(String str)", "testcase": false, "constructor": false}, {"identifier": "splitAsList", "parameters": "(char leftSeparator, char rightSeparator, String str)", "modifiers": "@Pure public static", "return": "List<String>", "signature": "List<String> splitAsList(char leftSeparator, char rightSeparator, String str)", "full_signature": "@Pure public static List<String> splitAsList(char leftSeparator, char rightSeparator, String str)", "class_method_signature": "TextUtil.splitAsList(char leftSeparator, char rightSeparator, String str)", "testcase": false, "constructor": false}, {"identifier": "splitSeparatorAlgorithm", "parameters": "(\n\t\t\tchar leftSeparator, char rightSeparator,\n\t\t\tString str, SplitSeparatorAlgorithm buffer)", "modifiers": "@SuppressWarnings({\"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\"}) private static", "return": "void", "signature": "void splitSeparatorAlgorithm(\n\t\t\tchar leftSeparator, char rightSeparator,\n\t\t\tString str, SplitSeparatorAlgorithm buffer)", "full_signature": "@SuppressWarnings({\"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\"}) private static void splitSeparatorAlgorithm(\n\t\t\tchar leftSeparator, char rightSeparator,\n\t\t\tString str, SplitSeparatorAlgorithm buffer)", "class_method_signature": "TextUtil.splitSeparatorAlgorithm(\n\t\t\tchar leftSeparator, char rightSeparator,\n\t\t\tString str, SplitSeparatorAlgorithm buffer)", "testcase": false, "constructor": false}, {"identifier": "splitBracketsAsUUIDs", "parameters": "(String str)", "modifiers": "@Pure @Inline(value = \"textUtil.splitAsUUIDs('{', '}', $1)\", imported = {TextUtil.class}) public static", "return": "List<UUID>", "signature": "List<UUID> splitBracketsAsUUIDs(String str)", "full_signature": "@Pure @Inline(value = \"textUtil.splitAsUUIDs('{', '}', $1)\", imported = {TextUtil.class}) public static List<UUID> splitBracketsAsUUIDs(String str)", "class_method_signature": "TextUtil.splitBracketsAsUUIDs(String str)", "testcase": false, "constructor": false}, {"identifier": "splitAsUUIDs", "parameters": "(char leftSeparator, char rightSeparator, String str)", "modifiers": "@Pure public static", "return": "List<UUID>", "signature": "List<UUID> splitAsUUIDs(char leftSeparator, char rightSeparator, String str)", "full_signature": "@Pure public static List<UUID> splitAsUUIDs(char leftSeparator, char rightSeparator, String str)", "class_method_signature": "TextUtil.splitAsUUIDs(char leftSeparator, char rightSeparator, String str)", "testcase": false, "constructor": false}, {"identifier": "mergeBrackets", "parameters": "(@SuppressWarnings(\"unchecked\") T... strs)", "modifiers": "@Pure @Inline(value = \"TextUtil.join('{', '}', $1)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String mergeBrackets(@SuppressWarnings(\"unchecked\") T... strs)", "full_signature": "@Pure @Inline(value = \"TextUtil.join('{', '}', $1)\", imported = {TextUtil.class}) public static String mergeBrackets(@SuppressWarnings(\"unchecked\") T... strs)", "class_method_signature": "TextUtil.mergeBrackets(@SuppressWarnings(\"unchecked\") T... strs)", "testcase": false, "constructor": false}, {"identifier": "mergeBrackets", "parameters": "(Iterable<?> strs)", "modifiers": "@Pure @Inline(value = \"TextUtil.join('{', '}', $1)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String mergeBrackets(Iterable<?> strs)", "full_signature": "@Pure @Inline(value = \"TextUtil.join('{', '}', $1)\", imported = {TextUtil.class}) public static String mergeBrackets(Iterable<?> strs)", "class_method_signature": "TextUtil.mergeBrackets(Iterable<?> strs)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(char leftSeparator, char rightSeparator, @SuppressWarnings(\"unchecked\") T... strs)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(char leftSeparator, char rightSeparator, @SuppressWarnings(\"unchecked\") T... strs)", "full_signature": "@Pure public static String join(char leftSeparator, char rightSeparator, @SuppressWarnings(\"unchecked\") T... strs)", "class_method_signature": "TextUtil.join(char leftSeparator, char rightSeparator, @SuppressWarnings(\"unchecked\") T... strs)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(char leftSeparator, char rightSeparator, Iterable<?> strs)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(char leftSeparator, char rightSeparator, Iterable<?> strs)", "full_signature": "@Pure public static String join(char leftSeparator, char rightSeparator, Iterable<?> strs)", "class_method_signature": "TextUtil.join(char leftSeparator, char rightSeparator, Iterable<?> strs)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, @SuppressWarnings(\"unchecked\") T... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, Arrays.asList($2))\", imported = {TextUtil.class, Arrays.class}) public static", "return": "String", "signature": "String join(String joinText, @SuppressWarnings(\"unchecked\") T... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, Arrays.asList($2))\", imported = {TextUtil.class, Arrays.class}) public static String join(String joinText, @SuppressWarnings(\"unchecked\") T... elements)", "class_method_signature": "TextUtil.join(String joinText, @SuppressWarnings(\"unchecked\") T... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, boolean... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, boolean... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, boolean... elements)", "class_method_signature": "TextUtil.join(String joinText, boolean... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, byte... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, byte... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, byte... elements)", "class_method_signature": "TextUtil.join(String joinText, byte... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, char... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, char... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, char... elements)", "class_method_signature": "TextUtil.join(String joinText, char... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, short... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, short... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, short... elements)", "class_method_signature": "TextUtil.join(String joinText, short... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, int... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, int... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, int... elements)", "class_method_signature": "TextUtil.join(String joinText, int... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, long... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, long... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, long... elements)", "class_method_signature": "TextUtil.join(String joinText, long... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, float... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, float... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, float... elements)", "class_method_signature": "TextUtil.join(String joinText, float... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, double... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, double... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, double... elements)", "class_method_signature": "TextUtil.join(String joinText, double... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, Iterable<?> elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static", "return": "String", "signature": "String join(String joinText, Iterable<?> elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, null, null, $2)\", imported = {TextUtil.class}) public static String join(String joinText, Iterable<?> elements)", "class_method_signature": "TextUtil.join(String joinText, Iterable<?> elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, @SuppressWarnings(\"unchecked\") T... elements)", "modifiers": "@Pure @Inline(value = \"TextUtil.join($1, $2, $3, Arrays.asList($4))\", imported = {TextUtil.class, Arrays.class}) public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, @SuppressWarnings(\"unchecked\") T... elements)", "full_signature": "@Pure @Inline(value = \"TextUtil.join($1, $2, $3, Arrays.asList($4))\", imported = {TextUtil.class, Arrays.class}) public static String join(String joinText, String prefix, String postfix, @SuppressWarnings(\"unchecked\") T... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, @SuppressWarnings(\"unchecked\") T... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, Iterable<?> elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, Iterable<?> elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, Iterable<?> elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, Iterable<?> elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, boolean... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, boolean... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, boolean... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, boolean... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, byte... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, byte... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, byte... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, byte... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, char... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, char... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, char... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, char... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, short... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, short... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, short... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, short... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, int... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, int... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, int... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, int... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, long... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, long... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, long... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, long... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, float... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, float... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, float... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, float... elements)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(String joinText, String prefix, String postfix, double... elements)", "modifiers": "@Pure public static", "return": "String", "signature": "String join(String joinText, String prefix, String postfix, double... elements)", "full_signature": "@Pure public static String join(String joinText, String prefix, String postfix, double... elements)", "class_method_signature": "TextUtil.join(String joinText, String prefix, String postfix, double... elements)", "testcase": false, "constructor": false}, {"identifier": "equalsIgnoreAccents", "parameters": "(String s1, String s2, Map<Character, String> map)", "modifiers": "@Pure @Inline(value = \"TextUtil.removeAccents($1, $3).equals(TextUtil.removeAccents($2, $3))\", imported = {TextUtil.class}) public static", "return": "boolean", "signature": "boolean equalsIgnoreAccents(String s1, String s2, Map<Character, String> map)", "full_signature": "@Pure @Inline(value = \"TextUtil.removeAccents($1, $3).equals(TextUtil.removeAccents($2, $3))\", imported = {TextUtil.class}) public static boolean equalsIgnoreAccents(String s1, String s2, Map<Character, String> map)", "class_method_signature": "TextUtil.equalsIgnoreAccents(String s1, String s2, Map<Character, String> map)", "testcase": false, "constructor": false}, {"identifier": "equalsIgnoreCaseAccents", "parameters": "(String s1, String s2, Map<Character, String> map)", "modifiers": "@Pure @Inline(value = \"TextUtil.removeAccents($1, $3).equalsIgnoreCase(TextUtil.removeAccents($2, $3))\", imported = {TextUtil.class}) public static", "return": "boolean", "signature": "boolean equalsIgnoreCaseAccents(String s1, String s2, Map<Character, String> map)", "full_signature": "@Pure @Inline(value = \"TextUtil.removeAccents($1, $3).equalsIgnoreCase(TextUtil.removeAccents($2, $3))\", imported = {TextUtil.class}) public static boolean equalsIgnoreCaseAccents(String s1, String s2, Map<Character, String> map)", "class_method_signature": "TextUtil.equalsIgnoreCaseAccents(String s1, String s2, Map<Character, String> map)", "testcase": false, "constructor": false}, {"identifier": "toLowerCaseWithoutAccent", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String toLowerCaseWithoutAccent(String text)", "full_signature": "@Pure public static String toLowerCaseWithoutAccent(String text)", "class_method_signature": "TextUtil.toLowerCaseWithoutAccent(String text)", "testcase": false, "constructor": false}, {"identifier": "toLowerCaseWithoutAccent", "parameters": "(String text, Map<Character, String> map)", "modifiers": "@Pure public static", "return": "String", "signature": "String toLowerCaseWithoutAccent(String text, Map<Character, String> map)", "full_signature": "@Pure public static String toLowerCaseWithoutAccent(String text, Map<Character, String> map)", "class_method_signature": "TextUtil.toLowerCaseWithoutAccent(String text, Map<Character, String> map)", "testcase": false, "constructor": false}, {"identifier": "toUpperCaseWithoutAccent", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String toUpperCaseWithoutAccent(String text)", "full_signature": "@Pure public static String toUpperCaseWithoutAccent(String text)", "class_method_signature": "TextUtil.toUpperCaseWithoutAccent(String text)", "testcase": false, "constructor": false}, {"identifier": "toUpperCaseWithoutAccent", "parameters": "(String text, Map<Character, String> map)", "modifiers": "@Pure public static", "return": "String", "signature": "String toUpperCaseWithoutAccent(String text, Map<Character, String> map)", "full_signature": "@Pure public static String toUpperCaseWithoutAccent(String text, Map<Character, String> map)", "class_method_signature": "TextUtil.toUpperCaseWithoutAccent(String text, Map<Character, String> map)", "testcase": false, "constructor": false}, {"identifier": "formatTime", "parameters": "(double amount, TimeUnit unit)", "modifiers": "@Pure @SuppressWarnings({\"checkstyle:magicnumber\", \"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\"}) public static", "return": "String", "signature": "String formatTime(double amount, TimeUnit unit)", "full_signature": "@Pure @SuppressWarnings({\"checkstyle:magicnumber\", \"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\"}) public static String formatTime(double amount, TimeUnit unit)", "class_method_signature": "TextUtil.formatTime(double amount, TimeUnit unit)", "testcase": false, "constructor": false}, {"identifier": "formatHex", "parameters": "(int amount, int digits)", "modifiers": "@Pure @Inline(value = \"$3.formatHex($1, $2)\", imported = {StringEscaper.class}) public static", "return": "String", "signature": "String formatHex(int amount, int digits)", "full_signature": "@Pure @Inline(value = \"$3.formatHex($1, $2)\", imported = {StringEscaper.class}) public static String formatHex(int amount, int digits)", "class_method_signature": "TextUtil.formatHex(int amount, int digits)", "testcase": false, "constructor": false}, {"identifier": "formatDouble", "parameters": "(double amount, int decimalCount)", "modifiers": "@Pure public static", "return": "String", "signature": "String formatDouble(double amount, int decimalCount)", "full_signature": "@Pure public static String formatDouble(double amount, int decimalCount)", "class_method_signature": "TextUtil.formatDouble(double amount, int decimalCount)", "testcase": false, "constructor": false}, {"identifier": "formatFloat", "parameters": "(float amount, int decimalCount)", "modifiers": "@Pure public static", "return": "String", "signature": "String formatFloat(float amount, int decimalCount)", "full_signature": "@Pure public static String formatFloat(float amount, int decimalCount)", "class_method_signature": "TextUtil.formatFloat(float amount, int decimalCount)", "testcase": false, "constructor": false}, {"identifier": "getLevenshteinDistance", "parameters": "(String firstString, String secondString)", "modifiers": "public static", "return": "int", "signature": "int getLevenshteinDistance(String firstString, String secondString)", "full_signature": "public static int getLevenshteinDistance(String firstString, String secondString)", "class_method_signature": "TextUtil.getLevenshteinDistance(String firstString, String secondString)", "testcase": false, "constructor": false}, {"identifier": "toJavaString", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String toJavaString(String text)", "full_signature": "@Pure public static String toJavaString(String text)", "class_method_signature": "TextUtil.toJavaString(String text)", "testcase": false, "constructor": false}, {"identifier": "toJsonString", "parameters": "(String text)", "modifiers": "@Pure public static", "return": "String", "signature": "String toJsonString(String text)", "full_signature": "@Pure public static String toJsonString(String text)", "class_method_signature": "TextUtil.toJsonString(String text)", "testcase": false, "constructor": false}], "file": "core/text/src/main/java/org/arakhne/afc/text/TextUtil.java"}, "focal_method": {"identifier": "getLevenshteinDistance", "parameters": "(String firstString, String secondString)", "modifiers": "public static", "return": "int", "body": "public static int getLevenshteinDistance(String firstString, String secondString) {\n\t\tfinal String s0 = firstString == null ? \"\" : firstString; //$NON-NLS-1$\n\t\tfinal String s1 = secondString == null ? \"\" : secondString; //$NON-NLS-1$\n\n\t\tfinal int len0 = s0.length() + 1;\n\t\tfinal int len1 = s1.length() + 1;\n\n\t\t// the array of distances\n\t\tint[] cost = new int[len0];\n\t\tint[] newcost = new int[len0];\n\n\t\t// initial cost of skipping prefix in String s0\n\t\tfor (int i = 0; i < len0; ++i) {\n\t\t\tcost[i] = i;\n\t\t}\n\n\t\t// dynamically computing the array of distances\n\n\t\t// transformation cost for each letter in s1\n\t\tfor (int j = 1; j < len1; ++j) {\n\t\t\t// initial cost of skipping prefix in String s1\n\t\t\tnewcost[0] = j;\n\n\t\t\t// transformation cost for each letter in s0\n\t\t\tfor (int i = 1; i < len0; ++i) {\n\t\t\t\t// matching current letters in both strings\n\t\t\t\tfinal int match = (s0.charAt(i - 1) == s1.charAt(j - 1)) ? 0 : 1;\n\n\t\t\t\t// computing cost for each transformation\n\t\t\t\tfinal int costReplace = cost[i - 1] + match;\n\t\t\t\tfinal int costInsert  = cost[i] + 1;\n\t\t\t\tfinal int costDelete  = newcost[i - 1] + 1;\n\n\t\t\t\t// keep minimum cost\n\t\t\t\tnewcost[i] = Math.min(Math.min(costInsert, costDelete), costReplace);\n\t\t\t}\n\n\t\t\t// swap cost/newcost arrays\n\t\t\tfinal int[] swap = cost;\n\t\t\tcost = newcost;\n\t\t\tnewcost = swap;\n\t\t}\n\n\t\t// the distance is the cost for transforming all letters in both strings\n\t\treturn cost[len0 - 1];\n\t}", "signature": "int getLevenshteinDistance(String firstString, String secondString)", "full_signature": "public static int getLevenshteinDistance(String firstString, String secondString)", "class_method_signature": "TextUtil.getLevenshteinDistance(String firstString, String secondString)", "testcase": false, "constructor": false, "invocations": ["length", "length", "charAt", "charAt", "min", "min"]}, "repository": {"repo_id": 9714608, "url": "https://github.com/gallandarakhneorg/afc", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 12, "size": 19091, "license": "licensed"}}