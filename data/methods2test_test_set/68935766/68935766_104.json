{"test_class": {"identifier": "LiteralTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final Command<String> ARGUMENT = val -> 0;", "modifier": "static final", "type": "Command<String>", "declarator": "ARGUMENT = val -> 0", "var_name": "ARGUMENT"}, {"original_string": "static final Command<String> COMMAND = val -> 0;", "modifier": "static final", "type": "Command<String>", "declarator": "COMMAND = val -> 0", "var_name": "COMMAND"}, {"original_string": "Literal<String> literal = Literal.<String>builder(\"literal\").alias(\"alias\").build();", "modifier": "", "type": "Literal<String>", "declarator": "literal = Literal.<String>builder(\"literal\").alias(\"alias\").build()", "var_name": "literal"}, {"original_string": "Literal<String> child = Literal.<String>builder(\"child\").alias(\"child_alias\").executes(COMMAND).build();", "modifier": "", "type": "Literal<String>", "declarator": "child = Literal.<String>builder(\"child\").alias(\"child_alias\").executes(COMMAND).build()", "var_name": "child"}, {"original_string": "Literal<String> grandchild = Literal.<String>builder(\"grandchild\").alias(\"grandchild_alias\").executes(COMMAND).build();", "modifier": "", "type": "Literal<String>", "declarator": "grandchild = Literal.<String>builder(\"grandchild\").alias(\"grandchild_alias\").executes(COMMAND).build()", "var_name": "grandchild"}, {"original_string": "Literal<String> extensive = Literal.<String>builder(\"child\").alias(\"child_alias\", \"child_alias_other\").then(grandchild).executes(COMMAND).build();", "modifier": "", "type": "Literal<String>", "declarator": "extensive = Literal.<String>builder(\"child\").alias(\"child_alias\", \"child_alias_other\").then(grandchild).executes(COMMAND).build()", "var_name": "extensive"}, {"original_string": "Argument<String, String> argument = Argument.<String, String>builder(\"child\", StringArgumentType.string()).then(Literal.<String>builder(\"a\").build()).executes(ARGUMENT).build();", "modifier": "", "type": "Argument<String, String>", "declarator": "argument = Argument.<String, String>builder(\"child\", StringArgumentType.string()).then(Literal.<String>builder(\"a\").build()).executes(ARGUMENT).build()", "var_name": "argument"}], "file": "commons/src/test/java/com/karuslabs/commons/command/tree/nodes/LiteralTest.java"}, "test_case": {"identifier": "alias", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n    void alias() {\n        literal.addChild(argument);\n        \n        var alias = Literal.alias(literal, \"alias\");\n        \n        assertEquals(\"alias\", alias.getName());\n        assertTrue(alias.isAlias());\n        assertEquals(literal.getCommand(), alias.getCommand());\n        assertEquals(1, alias.getChildren().size());\n        assertTrue(literal.aliases().contains(alias));\n    }", "signature": "void alias()", "full_signature": "@Test void alias()", "class_method_signature": "LiteralTest.alias()", "testcase": true, "constructor": false, "invocations": ["addChild", "alias", "assertEquals", "getName", "assertTrue", "isAlias", "assertEquals", "getCommand", "getCommand", "assertEquals", "size", "getChildren", "assertTrue", "contains", "aliases"]}, "focal_class": {"identifier": "Literal", "superclass": "extends LiteralCommandNode<T>", "interfaces": "implements Aliasable<T>, Mutable<T>", "fields": [{"original_string": "private CommandNode<T> destination;", "modifier": "private", "type": "CommandNode<T>", "declarator": "destination", "var_name": "destination"}, {"original_string": "private Consumer<CommandNode<T>> addition;", "modifier": "private", "type": "Consumer<CommandNode<T>>", "declarator": "addition", "var_name": "addition"}, {"original_string": "private List<LiteralCommandNode<T>> aliases;", "modifier": "private", "type": "List<LiteralCommandNode<T>>", "declarator": "aliases", "var_name": "aliases"}, {"original_string": "private boolean alias;", "modifier": "private", "type": "boolean", "declarator": "alias", "var_name": "alias"}], "methods": [{"identifier": "alias", "parameters": "(LiteralCommandNode<T> command, String alias)", "modifiers": "public static", "return": "Literal<T>", "signature": "Literal<T> alias(LiteralCommandNode<T> command, String alias)", "full_signature": "public static Literal<T> alias(LiteralCommandNode<T> command, String alias)", "class_method_signature": "Literal.alias(LiteralCommandNode<T> command, String alias)", "testcase": false, "constructor": false}, {"identifier": "builder", "parameters": "(String name)", "modifiers": "public static", "return": "Builder<T>", "signature": "Builder<T> builder(String name)", "full_signature": "public static Builder<T> builder(String name)", "class_method_signature": "Literal.builder(String name)", "testcase": false, "constructor": false}, {"identifier": "of", "parameters": "(String name)", "modifiers": "public static", "return": "Builder<CommandSender>", "signature": "Builder<CommandSender> of(String name)", "full_signature": "public static Builder<CommandSender> of(String name)", "class_method_signature": "Literal.of(String name)", "testcase": false, "constructor": false}, {"identifier": "Literal", "parameters": "(String name, Command<T> command, Predicate<T> requirement)", "modifiers": "public", "return": "", "signature": " Literal(String name, Command<T> command, Predicate<T> requirement)", "full_signature": "public  Literal(String name, Command<T> command, Predicate<T> requirement)", "class_method_signature": "Literal.Literal(String name, Command<T> command, Predicate<T> requirement)", "testcase": false, "constructor": true}, {"identifier": "Literal", "parameters": "(String name, Execution<T> execution, Predicate<T> requirement)", "modifiers": "public", "return": "", "signature": " Literal(String name, Execution<T> execution, Predicate<T> requirement)", "full_signature": "public  Literal(String name, Execution<T> execution, Predicate<T> requirement)", "class_method_signature": "Literal.Literal(String name, Execution<T> execution, Predicate<T> requirement)", "testcase": false, "constructor": true}, {"identifier": "Literal", "parameters": "(String name, Command<T> command, Predicate<T> requirement, @Nullable CommandNode<T> destination, RedirectModifier<T> modifier, boolean fork)", "modifiers": "public", "return": "", "signature": " Literal(String name, Command<T> command, Predicate<T> requirement, @Nullable CommandNode<T> destination, RedirectModifier<T> modifier, boolean fork)", "full_signature": "public  Literal(String name, Command<T> command, Predicate<T> requirement, @Nullable CommandNode<T> destination, RedirectModifier<T> modifier, boolean fork)", "class_method_signature": "Literal.Literal(String name, Command<T> command, Predicate<T> requirement, @Nullable CommandNode<T> destination, RedirectModifier<T> modifier, boolean fork)", "testcase": false, "constructor": true}, {"identifier": "Literal", "parameters": "(String name, List<LiteralCommandNode<T>> aliases, boolean alias, Command<T> command, Predicate<T> requirement, @Nullable CommandNode<T> destination, RedirectModifier<T> modifier, boolean fork)", "modifiers": "public", "return": "", "signature": " Literal(String name, List<LiteralCommandNode<T>> aliases, boolean alias, Command<T> command, Predicate<T> requirement, @Nullable CommandNode<T> destination, RedirectModifier<T> modifier, boolean fork)", "full_signature": "public  Literal(String name, List<LiteralCommandNode<T>> aliases, boolean alias, Command<T> command, Predicate<T> requirement, @Nullable CommandNode<T> destination, RedirectModifier<T> modifier, boolean fork)", "class_method_signature": "Literal.Literal(String name, List<LiteralCommandNode<T>> aliases, boolean alias, Command<T> command, Predicate<T> requirement, @Nullable CommandNode<T> destination, RedirectModifier<T> modifier, boolean fork)", "testcase": false, "constructor": true}, {"identifier": "addChild", "parameters": "(CommandNode<T> child)", "modifiers": "@Override public", "return": "void", "signature": "void addChild(CommandNode<T> child)", "full_signature": "@Override public void addChild(CommandNode<T> child)", "class_method_signature": "Literal.addChild(CommandNode<T> child)", "testcase": false, "constructor": false}, {"identifier": "removeChild", "parameters": "(String child)", "modifiers": "@Override public", "return": "CommandNode<T>", "signature": "CommandNode<T> removeChild(String child)", "full_signature": "@Override public CommandNode<T> removeChild(String child)", "class_method_signature": "Literal.removeChild(String child)", "testcase": false, "constructor": false}, {"identifier": "aliases", "parameters": "()", "modifiers": "@Override public", "return": "List<LiteralCommandNode<T>>", "signature": "List<LiteralCommandNode<T>> aliases()", "full_signature": "@Override public List<LiteralCommandNode<T>> aliases()", "class_method_signature": "Literal.aliases()", "testcase": false, "constructor": false}, {"identifier": "isAlias", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isAlias()", "full_signature": "@Override public boolean isAlias()", "class_method_signature": "Literal.isAlias()", "testcase": false, "constructor": false}, {"identifier": "setCommand", "parameters": "(Command<T> command)", "modifiers": "@Override public", "return": "void", "signature": "void setCommand(Command<T> command)", "full_signature": "@Override public void setCommand(Command<T> command)", "class_method_signature": "Literal.setCommand(Command<T> command)", "testcase": false, "constructor": false}, {"identifier": "getRedirect", "parameters": "()", "modifiers": "@Override public @Nullable", "return": "CommandNode<T>", "signature": "CommandNode<T> getRedirect()", "full_signature": "@Override public @Nullable CommandNode<T> getRedirect()", "class_method_signature": "Literal.getRedirect()", "testcase": false, "constructor": false}, {"identifier": "setRedirect", "parameters": "(CommandNode<T> destination)", "modifiers": "@Override public", "return": "void", "signature": "void setRedirect(CommandNode<T> destination)", "full_signature": "@Override public void setRedirect(CommandNode<T> destination)", "class_method_signature": "Literal.setRedirect(CommandNode<T> destination)", "testcase": false, "constructor": false}], "file": "commons/src/main/java/com/karuslabs/commons/command/tree/nodes/Literal.java"}, "focal_method": {"identifier": "alias", "parameters": "(LiteralCommandNode<T> command, String alias)", "modifiers": "public static", "return": "Literal<T>", "body": "public static <T> Literal<T> alias(LiteralCommandNode<T> command, String alias) {\n        var literal = new Literal<>(alias, new ArrayList<>(0), true, command.getCommand(), command.getRequirement(), command.getRedirect(), command.getRedirectModifier(), command.isFork());\n \n        for (var child : command.getChildren()) {\n            literal.addChild(child);\n        }\n        \n        if (command instanceof Aliasable<?>) {\n            ((Aliasable<T>) command).aliases().add(literal);\n        }\n        \n        return literal;\n    }", "signature": "Literal<T> alias(LiteralCommandNode<T> command, String alias)", "full_signature": "public static Literal<T> alias(LiteralCommandNode<T> command, String alias)", "class_method_signature": "Literal.alias(LiteralCommandNode<T> command, String alias)", "testcase": false, "constructor": false, "invocations": ["getCommand", "getRequirement", "getRedirect", "getRedirectModifier", "isFork", "getChildren", "addChild", "add", "aliases"]}, "repository": {"repo_id": 68935766, "url": "https://github.com/Pante/Chimera", "stars": 13, "created": "9/22/2016 3:36:39 PM +00:00", "updates": "2020-01-27T21:22:29+00:00", "fork": "False", "license": "licensed"}}