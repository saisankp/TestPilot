{"test_class": {"identifier": "AddressTemplateTest", "superclass": "", "interfaces": "", "fields": [], "file": "meta/src/test/java/org/jboss/hal/meta/AddressTemplateTest.java"}, "test_case": {"identifier": "resolve", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void resolve() {\n        AddressTemplate at = AddressTemplate.of(\"{a}/b={c}\");\n        ResourceAddress resolved = at.resolve(StatementContext.NOOP);\n        assertResolved(new String[][]{{\"a\", \"a\"}, {\"b\", \"c\"}}, resolved);\n    }", "signature": "void resolve()", "full_signature": "@Test public void resolve()", "class_method_signature": "AddressTemplateTest.resolve()", "testcase": true, "constructor": false, "invocations": ["of", "resolve", "assertResolved"]}, "focal_class": {"identifier": "AddressTemplate", "superclass": "", "interfaces": "implements Iterable<String>", "fields": [{"original_string": "public static final AddressTemplate ROOT = AddressTemplate.of(\"/\");", "modifier": "public static final", "type": "AddressTemplate", "declarator": "ROOT = AddressTemplate.of(\"/\")", "var_name": "ROOT"}, {"original_string": "public static final String EQUALS = \"=\";", "modifier": "public static final", "type": "String", "declarator": "EQUALS = \"=\"", "var_name": "EQUALS"}, {"original_string": "@JsIgnore public static final String OPTIONAL = \"opt://\";", "modifier": "@JsIgnore public static final", "type": "String", "declarator": "OPTIONAL = \"opt://\"", "var_name": "OPTIONAL"}, {"original_string": "private static final String BLANK = \"_blank\";", "modifier": "private static final", "type": "String", "declarator": "BLANK = \"_blank\"", "var_name": "BLANK"}, {"original_string": "private final String template;", "modifier": "private final", "type": "String", "declarator": "template", "var_name": "template"}, {"original_string": "private final LinkedList<Token> tokens;", "modifier": "private final", "type": "LinkedList<Token>", "declarator": "tokens", "var_name": "tokens"}, {"original_string": "private final boolean optional;", "modifier": "private final", "type": "boolean", "declarator": "optional", "var_name": "optional"}], "methods": [{"identifier": "of", "parameters": "(StatementContext.Expression placeholder)", "modifiers": "@JsIgnore public static", "return": "AddressTemplate", "signature": "AddressTemplate of(StatementContext.Expression placeholder)", "full_signature": "@JsIgnore public static AddressTemplate of(StatementContext.Expression placeholder)", "class_method_signature": "AddressTemplate.of(StatementContext.Expression placeholder)", "testcase": false, "constructor": false}, {"identifier": "of", "parameters": "(StatementContext.Expression placeholder, String template)", "modifiers": "@JsIgnore public static", "return": "AddressTemplate", "signature": "AddressTemplate of(StatementContext.Expression placeholder, String template)", "full_signature": "@JsIgnore public static AddressTemplate of(StatementContext.Expression placeholder, String template)", "class_method_signature": "AddressTemplate.of(StatementContext.Expression placeholder, String template)", "testcase": false, "constructor": false}, {"identifier": "of", "parameters": "(StatementContext.Expression placeholder1,\n            StatementContext.Expression placeholder2)", "modifiers": "@JsIgnore public static", "return": "AddressTemplate", "signature": "AddressTemplate of(StatementContext.Expression placeholder1,\n            StatementContext.Expression placeholder2)", "full_signature": "@JsIgnore public static AddressTemplate of(StatementContext.Expression placeholder1,\n            StatementContext.Expression placeholder2)", "class_method_signature": "AddressTemplate.of(StatementContext.Expression placeholder1,\n            StatementContext.Expression placeholder2)", "testcase": false, "constructor": false}, {"identifier": "of", "parameters": "(StatementContext.Expression placeholder1, StatementContext.Expression placeholder2,\n            String template)", "modifiers": "@JsIgnore public static", "return": "AddressTemplate", "signature": "AddressTemplate of(StatementContext.Expression placeholder1, StatementContext.Expression placeholder2,\n            String template)", "full_signature": "@JsIgnore public static AddressTemplate of(StatementContext.Expression placeholder1, StatementContext.Expression placeholder2,\n            String template)", "class_method_signature": "AddressTemplate.of(StatementContext.Expression placeholder1, StatementContext.Expression placeholder2,\n            String template)", "testcase": false, "constructor": false}, {"identifier": "of", "parameters": "(String template)", "modifiers": "public static", "return": "AddressTemplate", "signature": "AddressTemplate of(String template)", "full_signature": "public static AddressTemplate of(String template)", "class_method_signature": "AddressTemplate.of(String template)", "testcase": false, "constructor": false}, {"identifier": "of", "parameters": "(ResourceAddress address)", "modifiers": "@JsIgnore public static", "return": "AddressTemplate", "signature": "AddressTemplate of(ResourceAddress address)", "full_signature": "@JsIgnore public static AddressTemplate of(ResourceAddress address)", "class_method_signature": "AddressTemplate.of(ResourceAddress address)", "testcase": false, "constructor": false}, {"identifier": "of", "parameters": "(ResourceAddress address, Unresolver unresolver)", "modifiers": "@JsIgnore public static", "return": "AddressTemplate", "signature": "AddressTemplate of(ResourceAddress address, Unresolver unresolver)", "full_signature": "@JsIgnore public static AddressTemplate of(ResourceAddress address, Unresolver unresolver)", "class_method_signature": "AddressTemplate.of(ResourceAddress address, Unresolver unresolver)", "testcase": false, "constructor": false}, {"identifier": "withoutSlash", "parameters": "(String template)", "modifiers": "private static", "return": "String", "signature": "String withoutSlash(String template)", "full_signature": "private static String withoutSlash(String template)", "class_method_signature": "AddressTemplate.withoutSlash(String template)", "testcase": false, "constructor": false}, {"identifier": "withSlash", "parameters": "(String template)", "modifiers": "private static", "return": "String", "signature": "String withSlash(String template)", "full_signature": "private static String withSlash(String template)", "class_method_signature": "AddressTemplate.withSlash(String template)", "testcase": false, "constructor": false}, {"identifier": "AddressTemplate", "parameters": "(String template)", "modifiers": "private", "return": "", "signature": " AddressTemplate(String template)", "full_signature": "private  AddressTemplate(String template)", "class_method_signature": "AddressTemplate.AddressTemplate(String template)", "testcase": false, "constructor": true}, {"identifier": "parse", "parameters": "(String template)", "modifiers": "private", "return": "LinkedList<Token>", "signature": "LinkedList<Token> parse(String template)", "full_signature": "private LinkedList<Token> parse(String template)", "class_method_signature": "AddressTemplate.parse(String template)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(boolean optional, List<Token> tokens)", "modifiers": "private", "return": "String", "signature": "String join(boolean optional, List<Token> tokens)", "full_signature": "private String join(boolean optional, List<Token> tokens)", "class_method_signature": "AddressTemplate.join(boolean optional, List<Token> tokens)", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object o)", "modifiers": "@Override @JsIgnore public", "return": "boolean", "signature": "boolean equals(Object o)", "full_signature": "@Override @JsIgnore public boolean equals(Object o)", "class_method_signature": "AddressTemplate.equals(Object o)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override @JsIgnore public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override @JsIgnore public int hashCode()", "class_method_signature": "AddressTemplate.hashCode()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "AddressTemplate.toString()", "testcase": false, "constructor": false}, {"identifier": "isEmpty", "parameters": "()", "modifiers": "@JsProperty public", "return": "boolean", "signature": "boolean isEmpty()", "full_signature": "@JsProperty public boolean isEmpty()", "class_method_signature": "AddressTemplate.isEmpty()", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "@JsProperty(name = \"size\") public", "return": "int", "signature": "int size()", "full_signature": "@JsProperty(name = \"size\") public int size()", "class_method_signature": "AddressTemplate.size()", "testcase": false, "constructor": false}, {"identifier": "iterator", "parameters": "()", "modifiers": "@Override @JsIgnore public", "return": "Iterator<String>", "signature": "Iterator<String> iterator()", "full_signature": "@Override @JsIgnore public Iterator<String> iterator()", "class_method_signature": "AddressTemplate.iterator()", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(String template)", "modifiers": "@JsIgnore public", "return": "AddressTemplate", "signature": "AddressTemplate append(String template)", "full_signature": "@JsIgnore public AddressTemplate append(String template)", "class_method_signature": "AddressTemplate.append(String template)", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(AddressTemplate template)", "modifiers": "@JsIgnore public", "return": "AddressTemplate", "signature": "AddressTemplate append(AddressTemplate template)", "full_signature": "@JsIgnore public AddressTemplate append(AddressTemplate template)", "class_method_signature": "AddressTemplate.append(AddressTemplate template)", "testcase": false, "constructor": false}, {"identifier": "subTemplate", "parameters": "(int fromIndex, int toIndex)", "modifiers": "@JsIgnore public", "return": "AddressTemplate", "signature": "AddressTemplate subTemplate(int fromIndex, int toIndex)", "full_signature": "@JsIgnore public AddressTemplate subTemplate(int fromIndex, int toIndex)", "class_method_signature": "AddressTemplate.subTemplate(int fromIndex, int toIndex)", "testcase": false, "constructor": false}, {"identifier": "getParent", "parameters": "()", "modifiers": "@JsProperty public", "return": "AddressTemplate", "signature": "AddressTemplate getParent()", "full_signature": "@JsProperty public AddressTemplate getParent()", "class_method_signature": "AddressTemplate.getParent()", "testcase": false, "constructor": false}, {"identifier": "replaceWildcards", "parameters": "(String wildcard, String... wildcards)", "modifiers": "@JsIgnore public", "return": "AddressTemplate", "signature": "AddressTemplate replaceWildcards(String wildcard, String... wildcards)", "full_signature": "@JsIgnore public AddressTemplate replaceWildcards(String wildcard, String... wildcards)", "class_method_signature": "AddressTemplate.replaceWildcards(String wildcard, String... wildcards)", "testcase": false, "constructor": false}, {"identifier": "firstName", "parameters": "()", "modifiers": "@JsProperty(name = \"firstName\") public", "return": "String", "signature": "String firstName()", "full_signature": "@JsProperty(name = \"firstName\") public String firstName()", "class_method_signature": "AddressTemplate.firstName()", "testcase": false, "constructor": false}, {"identifier": "firstValue", "parameters": "()", "modifiers": "@JsProperty(name = \"firstValue\") public", "return": "String", "signature": "String firstValue()", "full_signature": "@JsProperty(name = \"firstValue\") public String firstValue()", "class_method_signature": "AddressTemplate.firstValue()", "testcase": false, "constructor": false}, {"identifier": "lastName", "parameters": "()", "modifiers": "@JsProperty(name = \"lastName\") public", "return": "String", "signature": "String lastName()", "full_signature": "@JsProperty(name = \"lastName\") public String lastName()", "class_method_signature": "AddressTemplate.lastName()", "testcase": false, "constructor": false}, {"identifier": "lastValue", "parameters": "()", "modifiers": "@JsProperty(name = \"lastValue\") public", "return": "String", "signature": "String lastValue()", "full_signature": "@JsProperty(name = \"lastValue\") public String lastValue()", "class_method_signature": "AddressTemplate.lastValue()", "testcase": false, "constructor": false}, {"identifier": "isOptional", "parameters": "()", "modifiers": "@JsIgnore public", "return": "boolean", "signature": "boolean isOptional()", "full_signature": "@JsIgnore public boolean isOptional()", "class_method_signature": "AddressTemplate.isOptional()", "testcase": false, "constructor": false}, {"identifier": "getTemplate", "parameters": "()", "modifiers": "@JsProperty", "return": "String", "signature": "String getTemplate()", "full_signature": "@JsProperty String getTemplate()", "class_method_signature": "AddressTemplate.getTemplate()", "testcase": false, "constructor": false}, {"identifier": "resolve", "parameters": "(StatementContext context, @EsParam(\"...string\") String... wildcards)", "modifiers": "public", "return": "ResourceAddress", "signature": "ResourceAddress resolve(StatementContext context, @EsParam(\"...string\") String... wildcards)", "full_signature": "public ResourceAddress resolve(StatementContext context, @EsParam(\"...string\") String... wildcards)", "class_method_signature": "AddressTemplate.resolve(StatementContext context, @EsParam(\"...string\") String... wildcards)", "testcase": false, "constructor": false}, {"identifier": "resolveSome", "parameters": "(StatementContext context, Memory<String> memory, String input)", "modifiers": "private", "return": "String", "signature": "String resolveSome(StatementContext context, Memory<String> memory, String input)", "full_signature": "private String resolveSome(StatementContext context, Memory<String> memory, String input)", "class_method_signature": "AddressTemplate.resolveSome(StatementContext context, Memory<String> memory, String input)", "testcase": false, "constructor": false}, {"identifier": "jsAppend", "parameters": "(@EsParam(\"string|AddressTemplate\") Object address)", "modifiers": "@JsMethod(name = \"append\") public", "return": "AddressTemplate", "signature": "AddressTemplate jsAppend(@EsParam(\"string|AddressTemplate\") Object address)", "full_signature": "@JsMethod(name = \"append\") public AddressTemplate jsAppend(@EsParam(\"string|AddressTemplate\") Object address)", "class_method_signature": "AddressTemplate.jsAppend(@EsParam(\"string|AddressTemplate\") Object address)", "testcase": false, "constructor": false}], "file": "meta/src/main/java/org/jboss/hal/meta/AddressTemplate.java"}, "focal_method": {"identifier": "resolve", "parameters": "(StatementContext context, @EsParam(\"...string\") String... wildcards)", "modifiers": "public", "return": "ResourceAddress", "body": "public ResourceAddress resolve(StatementContext context, @EsParam(\"...string\") String... wildcards) {\n        if (isEmpty()) {\n            return ResourceAddress.root();\n        }\n\n        int wildcardCount = 0;\n        ModelNode model = new ModelNode();\n        Memory<String[]> tupleMemory = new Memory<>();\n        Memory<String> valueMemory = new Memory<>();\n\n        for (Token token : tokens) {\n            if (!token.hasKey()) {\n                // a single token, something like \"{foo}\" of \"bar\"\n                String value = token.getValue();\n                String[] resolvedValue;\n\n                if (value.startsWith(\"{\")) {\n                    String variable = value.substring(1, value.length() - 1);\n                    value = variable;\n                    if (!tupleMemory.contains(variable)) {\n                        String[] resolvedTuple = context.resolveTuple(variable, this);\n                        if (resolvedTuple != null) {\n                            tupleMemory.memorize(variable, singletonList(resolvedTuple));\n                        }\n                    }\n                    resolvedValue = tupleMemory.next(value);\n                } else {\n                    assert value.contains(EQUALS) : \"Invalid token expression \" + value;\n                    resolvedValue = value.split(EQUALS);\n                }\n\n                if (resolvedValue != null) {\n                    model.add(resolvedValue[0], ModelNodeHelper.decodeValue(resolvedValue[1]));\n                }\n\n            } else {\n                // a key/value token, something like \"foo=bar\", \"foo=*\", \"{foo}=bar\" or \"foo={bar}\"\n                String keyRef = token.getKey();\n                String valueRef = token.getValue();\n\n                String resolvedKey = resolveSome(context, valueMemory, keyRef);\n                String resolvedValue = resolveSome(context, valueMemory, valueRef);\n\n                if (resolvedKey == null) {\n                    resolvedKey = BLANK;\n                }\n                if (resolvedValue == null) {\n                    resolvedValue = BLANK;\n                }\n\n                // wildcards\n                String addressValue = resolvedValue;\n                if (\"*\".equals(\n                        resolvedValue) && wildcards != null && wildcards.length > 0 && wildcardCount < wildcards.length) {\n                    addressValue = wildcards[wildcardCount];\n                    wildcardCount++;\n                }\n                model.add(resolvedKey, ModelNodeHelper.decodeValue(addressValue));\n            }\n        }\n        return new ResourceAddress(model);\n    }", "signature": "ResourceAddress resolve(StatementContext context, @EsParam(\"...string\") String... wildcards)", "full_signature": "public ResourceAddress resolve(StatementContext context, @EsParam(\"...string\") String... wildcards)", "class_method_signature": "AddressTemplate.resolve(StatementContext context, @EsParam(\"...string\") String... wildcards)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "root", "hasKey", "getValue", "startsWith", "substring", "length", "contains", "resolveTuple", "memorize", "singletonList", "next", "contains", "split", "add", "decodeValue", "getKey", "getValue", "resolveSome", "resolveSome", "equals", "add", "decodeValue"]}, "repository": {"repo_id": 38317187, "url": "https://github.com/hal/console", "stars": 34, "created": "6/30/2015 3:26:19 PM +00:00", "updates": "2020-01-26T16:25:43+00:00", "fork": "False", "license": "licensed"}}