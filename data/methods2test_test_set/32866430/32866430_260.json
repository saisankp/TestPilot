{"test_class": {"identifier": "DeleteActionTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final ApiDate NOW = ApiDate.now();", "modifier": "private static final", "type": "ApiDate", "declarator": "NOW = ApiDate.now()", "var_name": "NOW"}, {"original_string": "@Rule public MockitoRule mockito = MockitoJUnit.rule();", "modifier": "@Rule public", "type": "MockitoRule", "declarator": "mockito = MockitoJUnit.rule()", "var_name": "mockito"}, {"original_string": "@Mock KeywhizClient keywhizClient;", "modifier": "@Mock", "type": "KeywhizClient", "declarator": "keywhizClient", "var_name": "keywhizClient"}, {"original_string": "DeleteActionConfig deleteActionConfig;", "modifier": "", "type": "DeleteActionConfig", "declarator": "deleteActionConfig", "var_name": "deleteActionConfig"}, {"original_string": "DeleteAction deleteAction;", "modifier": "", "type": "DeleteAction", "declarator": "deleteAction", "var_name": "deleteAction"}, {"original_string": "Secret secret = new Secret(0, \"secret\", null, () -> \"c2VjcmV0MQ==\", \"checksum\", NOW, null, NOW, null, null, null,\n      ImmutableMap.of(), 0, 1L, NOW, null);", "modifier": "", "type": "Secret", "declarator": "secret = new Secret(0, \"secret\", null, () -> \"c2VjcmV0MQ==\", \"checksum\", NOW, null, NOW, null, null, null,\n      ImmutableMap.of(), 0, 1L, NOW, null)", "var_name": "secret"}, {"original_string": "SanitizedSecret sanitizedSecret = SanitizedSecret.fromSecret(secret);", "modifier": "", "type": "SanitizedSecret", "declarator": "sanitizedSecret = SanitizedSecret.fromSecret(secret)", "var_name": "sanitizedSecret"}, {"original_string": "ByteArrayInputStream yes;", "modifier": "", "type": "ByteArrayInputStream", "declarator": "yes", "var_name": "yes"}, {"original_string": "ByteArrayInputStream no;", "modifier": "", "type": "ByteArrayInputStream", "declarator": "no", "var_name": "no"}], "file": "cli/src/test/java/keywhiz/cli/commands/DeleteActionTest.java"}, "test_case": {"identifier": "deleteCallsDeleteForSecret", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void deleteCallsDeleteForSecret() throws Exception {\n    deleteAction.inputStream = yes;\n    deleteActionConfig.deleteType = Arrays.asList(\"secret\");\n    deleteActionConfig.name = secret.getDisplayName();\n    when(keywhizClient.getSanitizedSecretByName(secret.getName())).thenReturn(sanitizedSecret);\n\n    deleteAction.run();\n    verify(keywhizClient).deleteSecretWithId(sanitizedSecret.id());\n  }", "signature": "void deleteCallsDeleteForSecret()", "full_signature": "@Test public void deleteCallsDeleteForSecret()", "class_method_signature": "DeleteActionTest.deleteCallsDeleteForSecret()", "testcase": true, "constructor": false, "invocations": ["asList", "getDisplayName", "thenReturn", "when", "getSanitizedSecretByName", "getName", "run", "deleteSecretWithId", "verify", "id"]}, "focal_class": {"identifier": "DeleteAction", "superclass": "", "interfaces": "implements Runnable", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(DeleteAction.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(DeleteAction.class)", "var_name": "logger"}, {"original_string": "private final DeleteActionConfig deleteActionConfig;", "modifier": "private final", "type": "DeleteActionConfig", "declarator": "deleteActionConfig", "var_name": "deleteActionConfig"}, {"original_string": "private final KeywhizClient keywhizClient;", "modifier": "private final", "type": "KeywhizClient", "declarator": "keywhizClient", "var_name": "keywhizClient"}, {"original_string": "@VisibleForTesting\n  InputStream inputStream = System.in;", "modifier": "@VisibleForTesting", "type": "InputStream", "declarator": "inputStream = System.in", "var_name": "inputStream"}], "methods": [{"identifier": "DeleteAction", "parameters": "(DeleteActionConfig deleteActionConfig, KeywhizClient client)", "modifiers": "public", "return": "", "signature": " DeleteAction(DeleteActionConfig deleteActionConfig, KeywhizClient client)", "full_signature": "public  DeleteAction(DeleteActionConfig deleteActionConfig, KeywhizClient client)", "class_method_signature": "DeleteAction.DeleteAction(DeleteActionConfig deleteActionConfig, KeywhizClient client)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "DeleteAction.run()", "testcase": false, "constructor": false}], "file": "cli/src/main/java/keywhiz/cli/commands/DeleteAction.java"}, "focal_method": {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override public void run() {\n    List<String> type = deleteActionConfig.deleteType;\n\n    if (type == null || type.isEmpty()) {\n      throw new IllegalArgumentException(\"Must specify a single type to delete.\");\n    }\n\n    if (deleteActionConfig.name == null || !validName(deleteActionConfig.name)) {\n      throw new IllegalArgumentException(format(\"Invalid name, must match %s\", VALID_NAME_PATTERN));\n    }\n\n    String firstType = type.get(0).toLowerCase().trim();\n    switch (firstType) {\n      case \"group\":\n        try {\n          Group group = keywhizClient.getGroupByName(deleteActionConfig.name);\n          logger.info(\"Deleting group '{}'.\", group.getName());\n          keywhizClient.deleteGroupWithId(group.getId());\n        } catch (NotFoundException e) {\n          throw new AssertionError(\"Group does not exist.\");\n        } catch (IOException e) {\n          throw Throwables.propagate(e);\n        }\n        break;\n\n      case \"client\":\n        try {\n          Client client = keywhizClient.getClientByName(deleteActionConfig.name);\n          logger.info(\"Deleting client '{}'.\", client.getName());\n          keywhizClient.deleteClientWithId(client.getId());\n        } catch (NotFoundException e) {\n          throw new AssertionError(\"Client does not exist.\");\n        } catch (IOException e) {\n          throw Throwables.propagate(e);\n        }\n        break;\n\n      case \"secret\":\n        try {\n          SanitizedSecret sanitizedSecret =\n              keywhizClient.getSanitizedSecretByName(deleteActionConfig.name);\n          BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, UTF_8));\n          while (true) {\n            System.out.println(\n                format(\"Please confirm deletion of secret '%s': Y/N\", sanitizedSecret.name()));\n            String line = reader.readLine();\n\n            if (line == null /* EOF */ || line.toUpperCase().startsWith(\"N\")) {\n              return;\n            } else if (line.toUpperCase().startsWith(\"Y\")) {\n              logger.info(\"Deleting secret '{}'.\", sanitizedSecret.name());\n              keywhizClient.deleteSecretWithId(sanitizedSecret.id());\n              return;\n            } // else loop again\n          }\n        } catch (NotFoundException e) {\n          throw new AssertionError(\"Secret does not exist: \" + deleteActionConfig.name);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n\n      default:\n        throw new IllegalArgumentException(\"Invalid delete type specified: \" + type);\n    }\n  }", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "DeleteAction.run()", "testcase": false, "constructor": false, "invocations": ["isEmpty", "validName", "format", "trim", "toLowerCase", "get", "getGroupByName", "info", "getName", "deleteGroupWithId", "getId", "propagate", "getClientByName", "info", "getName", "deleteClientWithId", "getId", "propagate", "getSanitizedSecretByName", "println", "format", "name", "readLine", "startsWith", "toUpperCase", "startsWith", "toUpperCase", "info", "name", "deleteSecretWithId", "id"]}, "repository": {"repo_id": 32866430, "url": "https://github.com/square/keywhiz", "stars": 2186, "created": "3/25/2015 1:31:39 PM +00:00", "updates": "2020-01-24T18:57:02+00:00", "fork": "False", "license": "licensed"}}