{"test_class": {"identifier": "GeoTiffWriterTest", "superclass": "extends Assert", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = org.geotools.util.logging.Logging\n            .getLogger(GeoTiffWriterTest.class.toString());", "modifier": "private static final", "type": "Logger", "declarator": "logger = org.geotools.util.logging.Logging\n            .getLogger(GeoTiffWriterTest.class.toString())", "var_name": "logger"}], "file": "modules/unsupported/geotiff_new/src/test/java/org/geotools/gce/geotiff/GeoTiffWriterTest.java"}, "test_case": {"identifier": "testWriteCroppedCoverage", "parameters": "()", "modifiers": "@Test @Ignore public", "return": "void", "body": "@Test\n    @Ignore\n    public void testWriteCroppedCoverage() throws IllegalArgumentException, IOException,\n            UnsupportedOperationException, ParseException, FactoryException, TransformException {\n\n        // /////////////////////////////////////////////////////////////////////\n        //\n        //\n        // READ\n        //\n        //\n        // /////////////////////////////////////////////////////////////////////\n        // /////////////////////////////////////////////////////////////////////\n        //\n        // Look for the original coverage that wew want to crop.\n        //\n        // /////////////////////////////////////////////////////////////////////\n        final File readdir = TestData.file(GeoTiffWriterTest.class, \"\");\n        final File writedir = new File(new StringBuilder(readdir.getAbsolutePath()).append(\n                \"/testWriter/\").toString());\n        writedir.mkdir();\n        final File tiff = new File(readdir, \"latlon.tiff\");\n        assert tiff.exists() && tiff.canRead() && tiff.isFile();\n        if (TestData.isInteractiveTest())\n            logger.info(tiff.getAbsolutePath());\n\n        // /////////////////////////////////////////////////////////////////////\n        //\n        // Create format and reader\n        //\n        // /////////////////////////////////////////////////////////////////////\n        final GeoTiffFormat format = new GeoTiffFormat();\n        // getting a reader\n        GridCoverageReader reader = format.getReader(tiff);\n        assertNotNull(reader);\n\n        // /////////////////////////////////////////////////////////////////////\n        //\n        // Read the original coverage.\n        //\n        // /////////////////////////////////////////////////////////////////////\n        GridCoverage2D gc = (GridCoverage2D) reader.read(null);\n        if (TestData.isInteractiveTest()) {\n            logger.info(new StringBuilder(\"Coverage before: \").append(\"\\n\")\n                    .append(gc.getCoordinateReferenceSystem().toWKT())\n                    .append(gc.getEnvelope().toString()).toString());\n        }\n        final CoordinateReferenceSystem sourceCRS = gc.getCoordinateReferenceSystem2D();\n        final GeneralEnvelope sourceEnvelope = (GeneralEnvelope) gc.getEnvelope();\n        final GridGeometry2D sourcedGG = (GridGeometry2D) gc.getGridGeometry();\n        final MathTransform sourceG2W = sourcedGG.getGridToCRS(PixelInCell.CELL_CENTER);\n\n        // /////////////////////////////////////////////////////////////////////\n        //\n        //\n        // CROP\n        //\n        //\n        // /////////////////////////////////////////////////////////////////////\n\n        // /////////////////////////////////////////////////////////////////////\n        //\n        // Crop the original coverage.\n        //\n        // /////////////////////////////////////////////////////////////////////\n        double xc = sourceEnvelope.getMedian(0);\n        double yc = sourceEnvelope.getMedian(1);\n        double xl = sourceEnvelope.getSpan(0);\n        double yl = sourceEnvelope.getSpan(1);\n        final GeneralEnvelope cropEnvelope = new GeneralEnvelope(new double[] { xc - xl / 4.0,\n                yc - yl / 4.0 }, new double[] { xc + xl / 4.0, yc + yl / 4.0 });\n        final CoverageProcessor processor = new CoverageProcessor();\n        final ParameterValueGroup param = processor.getOperation(\"CoverageCrop\").getParameters();\n        param.parameter(\"Source\").setValue(gc);\n        param.parameter(\"Envelope\").setValue(cropEnvelope);\n        final GridCoverage2D cropped = (GridCoverage2D) processor.doOperation(param);\n\n        // /////////////////////////////////////////////////////////////////////\n        //\n        // Check that we got everything correctly after the crop.\n        //\n        // /////////////////////////////////////////////////////////////////////\n        // checking the ranges of the output image.\n        final GridGeometry2D croppedGG = (GridGeometry2D) cropped.getGridGeometry();\n        final GridEnvelope2D croppedGR = (GridEnvelope2D) croppedGG.getGridRange();\n        final MathTransform croppedG2W = croppedGG.getGridToCRS(PixelInCell.CELL_CENTER);\n        final GeneralEnvelope croppedEnvelope = (GeneralEnvelope) cropped.getEnvelope();\n        assertTrue(\"min x do not match after crop\", 29 == croppedGR.x);\n        assertTrue(\"min y do not match after crop\", 30 == croppedGR.y);\n        assertTrue(\"max x do not match after crop\", 90 == croppedGR.getMaxX());\n        assertTrue(\"max y do not match after crop\", 91 == croppedGR.getMaxY());\n        // check that the affine transform are the same thing\n        assertTrue(\"The Grdi2World tranformations of the original and the cropped covearage do not match\",\n                sourceG2W.equals(croppedG2W));\n        // check that the envelope is correct\n        final GeneralEnvelope expectedEnvelope = new GeneralEnvelope(croppedGR,\n                PixelInCell.CELL_CENTER, croppedG2W, cropped.getCoordinateReferenceSystem2D());\n        assertTrue(\"Expected envelope is different from the computed one\",\n                expectedEnvelope.equals(croppedEnvelope,\n                        XAffineTransform.getScale((AffineTransform) croppedG2W) / 2.0, false));\n\n        // /////////////////////////////////////////////////////////////////////\n        //\n        //\n        // WRITING AND TESTING\n        //\n        //\n        // /////////////////////////////////////////////////////////////////////\n        final File writeFile = new File(writedir.getAbsolutePath() + File.separatorChar \n                + cropped.getName().toString() + \".tiff\");\n        final GridCoverageWriter writer = format.getWriter(writeFile);\n        // /////////////////////////////////////////////////////////////////////\n        //\n        // Create the writing params\n        //\n        // /////////////////////////////////////////////////////////////////////\n        try {\n            writer.write(cropped, null);\n        } catch (IOException e) {\n        } finally {\n            try {\n                writer.dispose();\n            } catch (Throwable e) {\n            }\n        }\n        \n        // release things\n        cropped.dispose(true);\n        gc.dispose(true);\n        if (reader != null) {\n            try {\n\n                reader.dispose();\n            } catch (Throwable e) {\n            }\n        }\n        \n        try {\n            reader = new GeoTiffReader(writeFile, null);\n            assertNotNull(reader);\n            gc = (GridCoverage2D) reader.read(null);\n            assertNotNull(gc);\n            final CoordinateReferenceSystem targetCRS = gc.getCoordinateReferenceSystem2D();\n            assertTrue(\"Source and Target coordinate reference systems do not match\",\n                    CRS.equalsIgnoreMetadata(sourceCRS, targetCRS));\n            assertEquals(\"Read-back and Cropped envelopes do not match\", cropped.getEnvelope(),\n                    croppedEnvelope);\n\n            if (TestData.isInteractiveTest()) {\n                logger.info(new StringBuilder(\"Coverage after: \").append(\"\\n\")\n                        .append(gc.getCoordinateReferenceSystem().toWKT())\n                        .append(gc.getEnvelope().toString()).toString());\n                gc.show();\n            } else {\n                gc.getRenderedImage().getData();\n            }\n\n        } finally {\n            if (reader != null) {\n                try {\n\n                    reader.dispose();\n                } catch (Throwable e) {\n                }\n            }\n            if (!TestData.isInteractiveTest()) {\n                gc.dispose(true);\n            }\n        }\n    }", "signature": "void testWriteCroppedCoverage()", "full_signature": "@Test @Ignore public void testWriteCroppedCoverage()", "class_method_signature": "GeoTiffWriterTest.testWriteCroppedCoverage()", "testcase": true, "constructor": false, "invocations": ["file", "toString", "append", "getAbsolutePath", "mkdir", "exists", "canRead", "isFile", "isInteractiveTest", "info", "getAbsolutePath", "getReader", "assertNotNull", "read", "isInteractiveTest", "info", "toString", "append", "append", "append", "toWKT", "getCoordinateReferenceSystem", "toString", "getEnvelope", "getCoordinateReferenceSystem2D", "getEnvelope", "getGridGeometry", "getGridToCRS", "getMedian", "getMedian", "getSpan", "getSpan", "getParameters", "getOperation", "setValue", "parameter", "setValue", "parameter", "doOperation", "getGridGeometry", "getGridRange", "getGridToCRS", "getEnvelope", "assertTrue", "assertTrue", "assertTrue", "getMaxX", "assertTrue", "getMaxY", "assertTrue", "equals", "getCoordinateReferenceSystem2D", "assertTrue", "equals", "getScale", "getAbsolutePath", "toString", "getName", "getWriter", "write", "dispose", "dispose", "dispose", "dispose", "assertNotNull", "read", "assertNotNull", "getCoordinateReferenceSystem2D", "assertTrue", "equalsIgnoreMetadata", "assertEquals", "getEnvelope", "isInteractiveTest", "info", "toString", "append", "append", "append", "toWKT", "getCoordinateReferenceSystem", "toString", "getEnvelope", "show", "getData", "getRenderedImage", "dispose", "isInteractiveTest", "dispose"]}, "focal_class": {"identifier": "GeoTiffWriter", "superclass": "extends AbstractGridCoverageWriter", "interfaces": "implements\n\t\tGridCoverageWriter", "fields": [{"original_string": "private final static Logger LOGGER = org.geotools.util.logging.Logging.getLogger(GeoTiffWriter.class.toString());", "modifier": "private final static", "type": "Logger", "declarator": "LOGGER = org.geotools.util.logging.Logging.getLogger(GeoTiffWriter.class.toString())", "var_name": "LOGGER"}, {"original_string": "private final Map<String, String> metadataKeyValue = new HashMap<String, String>();", "modifier": "private final", "type": "Map<String, String>", "declarator": "metadataKeyValue = new HashMap<String, String>()", "var_name": "metadataKeyValue"}], "methods": [{"identifier": "GeoTiffWriter", "parameters": "(Object destination)", "modifiers": "public", "return": "", "signature": " GeoTiffWriter(Object destination)", "full_signature": "public  GeoTiffWriter(Object destination)", "class_method_signature": "GeoTiffWriter.GeoTiffWriter(Object destination)", "testcase": false, "constructor": true}, {"identifier": "setMetadataValue", "parameters": "(String name, String value)", "modifiers": "@Override public", "return": "void", "signature": "void setMetadataValue(String name, String value)", "full_signature": "@Override public void setMetadataValue(String name, String value)", "class_method_signature": "GeoTiffWriter.setMetadataValue(String name, String value)", "testcase": false, "constructor": false}, {"identifier": "GeoTiffWriter", "parameters": "(Object destination, Hints hints)", "modifiers": "public", "return": "", "signature": " GeoTiffWriter(Object destination, Hints hints)", "full_signature": "public  GeoTiffWriter(Object destination, Hints hints)", "class_method_signature": "GeoTiffWriter.GeoTiffWriter(Object destination, Hints hints)", "testcase": false, "constructor": true}, {"identifier": "getFormat", "parameters": "()", "modifiers": "public", "return": "Format", "signature": "Format getFormat()", "full_signature": "public Format getFormat()", "class_method_signature": "GeoTiffWriter.getFormat()", "testcase": false, "constructor": false}, {"identifier": "write", "parameters": "(final GridCoverage gc, final GeneralParameterValue[] params)", "modifiers": "public", "return": "void", "signature": "void write(final GridCoverage gc, final GeneralParameterValue[] params)", "full_signature": "public void write(final GridCoverage gc, final GeneralParameterValue[] params)", "class_method_signature": "GeoTiffWriter.write(final GridCoverage gc, final GeneralParameterValue[] params)", "testcase": false, "constructor": false}, {"identifier": "setGeoReference", "parameters": "(final CoordinateReferenceSystem crs,\n            final GeoTiffIIOMetadataEncoder metadata, final AffineTransform rasterToModel,\n            GridEnvelope2D range)", "modifiers": "private static", "return": "void", "signature": "void setGeoReference(final CoordinateReferenceSystem crs,\n            final GeoTiffIIOMetadataEncoder metadata, final AffineTransform rasterToModel,\n            GridEnvelope2D range)", "full_signature": "private static void setGeoReference(final CoordinateReferenceSystem crs,\n            final GeoTiffIIOMetadataEncoder metadata, final AffineTransform rasterToModel,\n            GridEnvelope2D range)", "class_method_signature": "GeoTiffWriter.setGeoReference(final CoordinateReferenceSystem crs,\n            final GeoTiffIIOMetadataEncoder metadata, final AffineTransform rasterToModel,\n            GridEnvelope2D range)", "testcase": false, "constructor": false}, {"identifier": "writeImage", "parameters": "(final RenderedImage image, final ImageOutputStream outputStream,\n            final GeoTiffIIOMetadataEncoder geoTIFFMetadata, GeoToolsWriteParams gtParams)", "modifiers": "private", "return": "boolean", "signature": "boolean writeImage(final RenderedImage image, final ImageOutputStream outputStream,\n            final GeoTiffIIOMetadataEncoder geoTIFFMetadata, GeoToolsWriteParams gtParams)", "full_signature": "private boolean writeImage(final RenderedImage image, final ImageOutputStream outputStream,\n            final GeoTiffIIOMetadataEncoder geoTIFFMetadata, GeoToolsWriteParams gtParams)", "class_method_signature": "GeoTiffWriter.writeImage(final RenderedImage image, final ImageOutputStream outputStream,\n            final GeoTiffIIOMetadataEncoder geoTIFFMetadata, GeoToolsWriteParams gtParams)", "testcase": false, "constructor": false}, {"identifier": "getCandidateNoData", "parameters": "(GridCoverage gc)", "modifiers": "static", "return": "double", "signature": "double getCandidateNoData(GridCoverage gc)", "full_signature": "static double getCandidateNoData(GridCoverage gc)", "class_method_signature": "GeoTiffWriter.getCandidateNoData(GridCoverage gc)", "testcase": false, "constructor": false}], "file": "modules/unsupported/geotiff_new/src/main/java/org/geotools/gce/geotiff/GeoTiffWriter.java"}, "focal_method": {"identifier": "write", "parameters": "(final GridCoverage gc, final GeneralParameterValue[] params)", "modifiers": "public", "return": "void", "body": "public void write(final GridCoverage gc, final GeneralParameterValue[] params)\n            throws IllegalArgumentException, IOException, IndexOutOfBoundsException {\n\n        GeoToolsWriteParams gtParams = null;\n        boolean writeTfw = GeoTiffFormat.WRITE_TFW.getDefaultValue();\n        if (params != null) {\n            // /////////////////////////////////////////////////////////////////////\n            //\n            // Checking params\n            //\n            // /////////////////////////////////////////////////////////////////////\n            if (params != null) {\n                Parameter param;\n                final int length = params.length;\n                for (int i = 0; i < length; i++) {\n                    param = (Parameter) params[i];\n                    final ReferenceIdentifier name = param.getDescriptor().getName();\n                    if (name.equals(AbstractGridFormat.GEOTOOLS_WRITE_PARAMS.getName())) {\n                        gtParams = (GeoToolsWriteParams) param.getValue();\n                    }\n                    if (name.equals(GeoTiffFormat.WRITE_TFW.getName())) {\n                        writeTfw = (Boolean) param.getValue();\n                    }\n                }\n            }\n        }\n        if (gtParams == null)\n            gtParams = new GeoTiffWriteParams();\n\n        // /////////////////////////////////////////////////////////////////////\n        //\n        // getting the coordinate reference system\n        //\n        // /////////////////////////////////////////////////////////////////////\n        final GridGeometry2D gg = (GridGeometry2D) gc.getGridGeometry();\n        GridEnvelope2D range = gg.getGridRange2D();\n        final Rectangle sourceRegion = gtParams.getSourceRegion();\n        if (sourceRegion != null)\n            range = new GridEnvelope2D(sourceRegion);\n        final AffineTransform tr = (AffineTransform) gg.getGridToCRS2D();\n        final CoordinateReferenceSystem crs = gg.getCoordinateReferenceSystem2D();\n        final double inNoData = getCandidateNoData(gc);\n\n        // /////////////////////////////////////////////////////////////////////\n        //\n        // we handle just projected and geographic crs\n        //\n        // /////////////////////////////////////////////////////////////////////\n        if (crs instanceof ProjectedCRS || crs instanceof GeographicCRS) {\n\n            // creating geotiff metadata\n            final CRS2GeoTiffMetadataAdapter adapter = new CRS2GeoTiffMetadataAdapter(crs);\n            final GeoTiffIIOMetadataEncoder metadata = adapter.parseCoordinateReferenceSystem();\n            if (!Double.isNaN(inNoData))\n                metadata.setNoData(inNoData);\n            if (metadataKeyValue != null && !metadataKeyValue.isEmpty()) {\n                metadata.setTiffTagsMetadata(metadataKeyValue);\n            }\n\n            // setting georeferencing\n            setGeoReference(crs, metadata, tr, range);\n\n            // writing ALWAYS the geophysics vew of the data\n            writeImage(((GridCoverage2D) gc).geophysics(true).getRenderedImage(), this.outStream,\n                    metadata, gtParams);\n\n            // write tfw\n            if (writeTfw && (destination instanceof File)) {\n                final File destFile = (File) this.destination;\n                final File tfw = new File(destFile.getParentFile(), destFile.getName().replace(\n                        \"tif\", \"tfw\"));\n                final BufferedWriter outW = new BufferedWriter(new FileWriter(tfw));\n                try {\n                    outW.write(gc.getCoordinateReferenceSystem().toWKT());\n                } finally {\n                    try {\n                        outW.close();\n                    } catch (Exception e) {\n                        // ssshhh :)\n                    }\n                }\n            }\n\n        } else {\n            throw new GeoTiffException(\n                    null, \"The supplied grid coverage uses an unsupported crs! You are allowed to\"\n                    + \" use only projected and geographic coordinate reference systems\", null);\n        }\n    }", "signature": "void write(final GridCoverage gc, final GeneralParameterValue[] params)", "full_signature": "public void write(final GridCoverage gc, final GeneralParameterValue[] params)", "class_method_signature": "GeoTiffWriter.write(final GridCoverage gc, final GeneralParameterValue[] params)", "testcase": false, "constructor": false, "invocations": ["getDefaultValue", "getName", "getDescriptor", "equals", "getName", "getValue", "equals", "getName", "getValue", "getGridGeometry", "getGridRange2D", "getSourceRegion", "getGridToCRS2D", "getCoordinateReferenceSystem2D", "getCandidateNoData", "parseCoordinateReferenceSystem", "isNaN", "setNoData", "isEmpty", "setTiffTagsMetadata", "setGeoReference", "writeImage", "getRenderedImage", "geophysics", "getParentFile", "replace", "getName", "write", "toWKT", "getCoordinateReferenceSystem", "close"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}