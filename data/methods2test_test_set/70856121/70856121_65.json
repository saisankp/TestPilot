{"test_class": {"identifier": "SegmentGeneratorTest", "superclass": "", "interfaces": "", "fields": [], "file": "src/server/src/test/java/io/cassandrareaper/service/SegmentGeneratorTest.java"}, "test_case": {"identifier": "coalesceTokenRangesBy200TokensPerSegmentTests", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void coalesceTokenRangesBy200TokensPerSegmentTests() throws ReaperException {\n    SegmentGenerator sg = new SegmentGenerator(BigInteger.valueOf(1), BigInteger.valueOf(1500));\n    Map<List<String>, List<String>> rangeToEndpoint = Maps.newHashMap();\n    rangeToEndpoint.put(Arrays.asList(\"1\", \"200\"), Arrays.asList(\"node1\", \"node2\", \"node3\"));\n    rangeToEndpoint.put(Arrays.asList(\"200\", \"400\"), Arrays.asList(\"node1\", \"node2\", \"node3\"));\n    rangeToEndpoint.put(Arrays.asList(\"400\", \"600\"), Arrays.asList(\"node1\", \"node2\", \"node3\"));\n    rangeToEndpoint.put(Arrays.asList(\"600\", \"800\"), Arrays.asList(\"node1\", \"node2\", \"node3\"));\n    rangeToEndpoint.put(Arrays.asList(\"800\", \"1000\"), Arrays.asList(\"node1\", \"node2\", \"node3\"));\n    rangeToEndpoint.put(Arrays.asList(\"1100\", \"1200\"), Arrays.asList(\"node1\", \"node2\", \"node3\"));\n    rangeToEndpoint.put(Arrays.asList(\"1200\", \"1300\"), Arrays.asList(\"node1\", \"node2\", \"node3\"));\n    rangeToEndpoint.put(Arrays.asList(\"1300\", \"1400\"), Arrays.asList(\"node1\", \"node2\", \"node3\"));\n    rangeToEndpoint.put(Arrays.asList(\"1400\", \"1500\"), Arrays.asList(\"node1\", \"node2\", \"node3\"));\n\n    Map<List<String>, List<RingRange>> replicasToRangeMap\n        = RepairRunService.buildReplicasToRangeMap(rangeToEndpoint);\n\n    List<Segment> segments = sg.coalesceTokenRanges(BigInteger.valueOf(200), replicasToRangeMap);\n\n    // Ranges with 100 tokens will get coalesced two by two\n    assertEquals(7, segments.size());\n  }", "signature": "void coalesceTokenRangesBy200TokensPerSegmentTests()", "full_signature": "@Test public void coalesceTokenRangesBy200TokensPerSegmentTests()", "class_method_signature": "SegmentGeneratorTest.coalesceTokenRangesBy200TokensPerSegmentTests()", "testcase": true, "constructor": false, "invocations": ["valueOf", "valueOf", "newHashMap", "put", "asList", "asList", "put", "asList", "asList", "put", "asList", "asList", "put", "asList", "asList", "put", "asList", "asList", "put", "asList", "asList", "put", "asList", "asList", "put", "asList", "asList", "put", "asList", "asList", "buildReplicasToRangeMap", "coalesceTokenRanges", "valueOf", "assertEquals", "size"]}, "focal_class": {"identifier": "SegmentGenerator", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(SegmentGenerator.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(SegmentGenerator.class)", "var_name": "LOG"}, {"original_string": "private static final boolean COALESCING_DISABLED\n      = Boolean.getBoolean(SegmentGenerator.class.getName() + \".disable.tokenrange.coalescing\");", "modifier": "private static final", "type": "boolean", "declarator": "COALESCING_DISABLED\n      = Boolean.getBoolean(SegmentGenerator.class.getName() + \".disable.tokenrange.coalescing\")", "var_name": "COALESCING_DISABLED"}, {"original_string": "private final String partitioner;", "modifier": "private final", "type": "String", "declarator": "partitioner", "var_name": "partitioner"}, {"original_string": "private final BigInteger rangeMin;", "modifier": "private final", "type": "BigInteger", "declarator": "rangeMin", "var_name": "rangeMin"}, {"original_string": "private final BigInteger rangeMax;", "modifier": "private final", "type": "BigInteger", "declarator": "rangeMax", "var_name": "rangeMax"}, {"original_string": "private final BigInteger rangeSize;", "modifier": "private final", "type": "BigInteger", "declarator": "rangeSize", "var_name": "rangeSize"}], "methods": [{"identifier": "SegmentGenerator", "parameters": "(String partitioner)", "modifiers": "", "return": "", "signature": " SegmentGenerator(String partitioner)", "full_signature": "  SegmentGenerator(String partitioner)", "class_method_signature": "SegmentGenerator.SegmentGenerator(String partitioner)", "testcase": false, "constructor": true}, {"identifier": "SegmentGenerator", "parameters": "(BigInteger rangeMin, BigInteger rangeMax)", "modifiers": "", "return": "", "signature": " SegmentGenerator(BigInteger rangeMin, BigInteger rangeMax)", "full_signature": "  SegmentGenerator(BigInteger rangeMin, BigInteger rangeMax)", "class_method_signature": "SegmentGenerator.SegmentGenerator(BigInteger rangeMin, BigInteger rangeMax)", "testcase": false, "constructor": true}, {"identifier": "max", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "BigInteger", "signature": "BigInteger max(BigInteger big0, BigInteger big1)", "full_signature": "static BigInteger max(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.max(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "min", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "BigInteger", "signature": "BigInteger min(BigInteger big0, BigInteger big1)", "full_signature": "static BigInteger min(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.min(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "lowerThan", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "boolean", "signature": "boolean lowerThan(BigInteger big0, BigInteger big1)", "full_signature": "static boolean lowerThan(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.lowerThan(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "lowerThanOrEqual", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "boolean", "signature": "boolean lowerThanOrEqual(BigInteger big0, BigInteger big1)", "full_signature": "static boolean lowerThanOrEqual(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.lowerThanOrEqual(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "greaterThan", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "boolean", "signature": "boolean greaterThan(BigInteger big0, BigInteger big1)", "full_signature": "static boolean greaterThan(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.greaterThan(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "greaterThanOrEqual", "parameters": "(BigInteger big0, BigInteger big1)", "modifiers": "static", "return": "boolean", "signature": "boolean greaterThanOrEqual(BigInteger big0, BigInteger big1)", "full_signature": "static boolean greaterThanOrEqual(BigInteger big0, BigInteger big1)", "class_method_signature": "SegmentGenerator.greaterThanOrEqual(BigInteger big0, BigInteger big1)", "testcase": false, "constructor": false}, {"identifier": "generateSegments", "parameters": "(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "modifiers": "", "return": "List<Segment>", "signature": "List<Segment> generateSegments(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "full_signature": " List<Segment> generateSegments(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "class_method_signature": "SegmentGenerator.generateSegments(\n      int totalSegmentCount,\n      List<BigInteger> ringTokens,\n      Boolean incrementalRepair,\n      Map<List<String>, List<RingRange>> replicasToRange,\n      String cassandraVersion)", "testcase": false, "constructor": false}, {"identifier": "coalesceTokenRanges", "parameters": "(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "modifiers": "@VisibleForTesting", "return": "List<Segment>", "signature": "List<Segment> coalesceTokenRanges(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "full_signature": "@VisibleForTesting List<Segment> coalesceTokenRanges(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "class_method_signature": "SegmentGenerator.coalesceTokenRanges(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "testcase": false, "constructor": false}, {"identifier": "allTokensHaveBeenCoalesced", "parameters": "(\n      List<Segment> coalescedRepairSegments, Map<List<String>, List<RingRange>> replicasToRange)", "modifiers": "private static", "return": "boolean", "signature": "boolean allTokensHaveBeenCoalesced(\n      List<Segment> coalescedRepairSegments, Map<List<String>, List<RingRange>> replicasToRange)", "full_signature": "private static boolean allTokensHaveBeenCoalesced(\n      List<Segment> coalescedRepairSegments, Map<List<String>, List<RingRange>> replicasToRange)", "class_method_signature": "SegmentGenerator.allTokensHaveBeenCoalesced(\n      List<Segment> coalescedRepairSegments, Map<List<String>, List<RingRange>> replicasToRange)", "testcase": false, "constructor": false}, {"identifier": "getTargetSegmentSize", "parameters": "(int segmentCount)", "modifiers": "private", "return": "BigInteger", "signature": "BigInteger getTargetSegmentSize(int segmentCount)", "full_signature": "private BigInteger getTargetSegmentSize(int segmentCount)", "class_method_signature": "SegmentGenerator.getTargetSegmentSize(int segmentCount)", "testcase": false, "constructor": false}, {"identifier": "inRange", "parameters": "(BigInteger token)", "modifiers": "protected", "return": "boolean", "signature": "boolean inRange(BigInteger token)", "full_signature": "protected boolean inRange(BigInteger token)", "class_method_signature": "SegmentGenerator.inRange(BigInteger token)", "testcase": false, "constructor": false}, {"identifier": "supportsSegmentCoalescing", "parameters": "(String cassandraVersion)", "modifiers": "private", "return": "boolean", "signature": "boolean supportsSegmentCoalescing(String cassandraVersion)", "full_signature": "private boolean supportsSegmentCoalescing(String cassandraVersion)", "class_method_signature": "SegmentGenerator.supportsSegmentCoalescing(String cassandraVersion)", "testcase": false, "constructor": false}], "file": "src/server/src/main/java/io/cassandrareaper/service/SegmentGenerator.java"}, "focal_method": {"identifier": "coalesceTokenRanges", "parameters": "(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "modifiers": "@VisibleForTesting", "return": "List<Segment>", "body": "@VisibleForTesting\n  List<Segment> coalesceTokenRanges(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange) {\n\n    List<Segment> coalescedRepairSegments = Lists.newArrayList();\n    List<RingRange> tokenRangesForCurrentSegment = Lists.newArrayList();\n    BigInteger tokenCount = BigInteger.ZERO;\n\n    for (Entry<List<String>, List<RingRange>> tokenRangesByReplica : replicasToRange.entrySet()) {\n      LOG.info(\"Coalescing segments for nodes {}\", tokenRangesByReplica.getKey());\n      for (RingRange tokenRange : tokenRangesByReplica.getValue()) {\n        if (tokenRange.span(rangeSize).add(tokenCount).compareTo(targetSegmentSize) > 0\n            && !tokenRangesForCurrentSegment.isEmpty()) {\n          // enough tokens in that segment\n          LOG.info(\n              \"Got enough tokens for one segment ({}) : {}\",\n              tokenCount,\n              tokenRangesForCurrentSegment);\n          coalescedRepairSegments.add(\n              Segment.builder().withTokenRanges(tokenRangesForCurrentSegment).build());\n          tokenRangesForCurrentSegment = Lists.newArrayList();\n          tokenCount = BigInteger.ZERO;\n        }\n\n        tokenCount = tokenCount.add(tokenRange.span(rangeSize));\n        tokenRangesForCurrentSegment.add(tokenRange);\n\n      }\n\n      if (!tokenRangesForCurrentSegment.isEmpty()) {\n        coalescedRepairSegments.add(\n            Segment.builder().withTokenRanges(tokenRangesForCurrentSegment).build());\n        tokenRangesForCurrentSegment = Lists.newArrayList();\n      }\n    }\n\n\n    // Check that we haven't left any token range outside of the resulting segments\n    Preconditions.checkState(\n        allTokensHaveBeenCoalesced(coalescedRepairSegments, replicasToRange),\n        \"Number of coalesced tokens doesn't match with the total number of tokens\");\n\n    return coalescedRepairSegments;\n  }", "signature": "List<Segment> coalesceTokenRanges(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "full_signature": "@VisibleForTesting List<Segment> coalesceTokenRanges(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "class_method_signature": "SegmentGenerator.coalesceTokenRanges(\n      BigInteger targetSegmentSize, Map<List<String>, List<RingRange>> replicasToRange)", "testcase": false, "constructor": false, "invocations": ["newArrayList", "newArrayList", "entrySet", "info", "getKey", "getValue", "compareTo", "add", "span", "isEmpty", "info", "add", "build", "withTokenRanges", "builder", "newArrayList", "add", "span", "add", "isEmpty", "add", "build", "withTokenRanges", "builder", "newArrayList", "checkState", "allTokensHaveBeenCoalesced"]}, "repository": {"repo_id": 70856121, "url": "https://github.com/thelastpickle/cassandra-reaper", "language": "Java", "is_fork": false, "fork_count": 156, "stargazer_count": 353, "size": 43662, "license": "licensed"}}