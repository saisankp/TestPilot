{"test_class": {"identifier": "MessageSlicerTest", "superclass": "extends AbstractMessagingTest", "interfaces": "", "fields": [{"original_string": "@Mock\n    private Consumer<Throwable> mockOnFailureCallback;", "modifier": "@Mock\n    private", "type": "Consumer<Throwable>", "declarator": "mockOnFailureCallback", "var_name": "mockOnFailureCallback"}], "file": "opendaylight/md-sal/sal-clustering-commons/src/test/java/org/opendaylight/controller/cluster/messaging/MessageSlicerTest.java"}, "test_case": {"identifier": "testSliceWithInputStreamFailure", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSliceWithInputStreamFailure() throws IOException {\n        doReturn(0).when(mockInputStream).read(any(byte[].class));\n\n        try (MessageSlicer slicer = newMessageSlicer(\"testSliceWithInputStreamFailure\", 2)) {\n            final boolean wasSliced = slice(slicer, IDENTIFIER, new BytesMessage(new byte[]{}), testProbe.ref(),\n                    testProbe.ref(), mockOnFailureCallback);\n            assertFalse(wasSliced);\n\n            assertFailureCallback(IOException.class);\n            verify(mockFiledBackedStream).cleanup();\n        }\n    }", "signature": "void testSliceWithInputStreamFailure()", "full_signature": "@Test public void testSliceWithInputStreamFailure()", "class_method_signature": "MessageSlicerTest.testSliceWithInputStreamFailure()", "testcase": true, "constructor": false, "invocations": ["read", "when", "doReturn", "any", "newMessageSlicer", "slice", "ref", "ref", "assertFalse", "assertFailureCallback", "cleanup", "verify"]}, "focal_class": {"identifier": "MessageSlicer", "superclass": "", "interfaces": "implements AutoCloseable", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(MessageSlicer.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(MessageSlicer.class)", "var_name": "LOG"}, {"original_string": "private static final AtomicLong SLICER_ID_COUNTER = new AtomicLong(1);", "modifier": "private static final", "type": "AtomicLong", "declarator": "SLICER_ID_COUNTER = new AtomicLong(1)", "var_name": "SLICER_ID_COUNTER"}, {"original_string": "public static final int DEFAULT_MAX_SLICING_TRIES = 3;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_MAX_SLICING_TRIES = 3", "var_name": "DEFAULT_MAX_SLICING_TRIES"}, {"original_string": "private final Cache<MessageSliceIdentifier, SlicedMessageState<ActorRef>> stateCache;", "modifier": "private final", "type": "Cache<MessageSliceIdentifier, SlicedMessageState<ActorRef>>", "declarator": "stateCache", "var_name": "stateCache"}, {"original_string": "private final FileBackedOutputStreamFactory fileBackedStreamFactory;", "modifier": "private final", "type": "FileBackedOutputStreamFactory", "declarator": "fileBackedStreamFactory", "var_name": "fileBackedStreamFactory"}, {"original_string": "private final int messageSliceSize;", "modifier": "private final", "type": "int", "declarator": "messageSliceSize", "var_name": "messageSliceSize"}, {"original_string": "private final int maxSlicingTries;", "modifier": "private final", "type": "int", "declarator": "maxSlicingTries", "var_name": "maxSlicingTries"}, {"original_string": "private final String logContext;", "modifier": "private final", "type": "String", "declarator": "logContext", "var_name": "logContext"}, {"original_string": "private final long id;", "modifier": "private final", "type": "long", "declarator": "id", "var_name": "id"}], "methods": [{"identifier": "MessageSlicer", "parameters": "(final Builder builder)", "modifiers": "", "return": "", "signature": " MessageSlicer(final Builder builder)", "full_signature": "  MessageSlicer(final Builder builder)", "class_method_signature": "MessageSlicer.MessageSlicer(final Builder builder)", "testcase": false, "constructor": true}, {"identifier": "getId", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "long", "signature": "long getId()", "full_signature": "@VisibleForTesting long getId()", "class_method_signature": "MessageSlicer.getId()", "testcase": false, "constructor": false}, {"identifier": "builder", "parameters": "()", "modifiers": "public static", "return": "Builder", "signature": "Builder builder()", "full_signature": "public static Builder builder()", "class_method_signature": "MessageSlicer.builder()", "testcase": false, "constructor": false}, {"identifier": "isHandledMessage", "parameters": "(final Object message)", "modifiers": "public static", "return": "boolean", "signature": "boolean isHandledMessage(final Object message)", "full_signature": "public static boolean isHandledMessage(final Object message)", "class_method_signature": "MessageSlicer.isHandledMessage(final Object message)", "testcase": false, "constructor": false}, {"identifier": "slice", "parameters": "(final SliceOptions options)", "modifiers": "public", "return": "boolean", "signature": "boolean slice(final SliceOptions options)", "full_signature": "public boolean slice(final SliceOptions options)", "class_method_signature": "MessageSlicer.slice(final SliceOptions options)", "testcase": false, "constructor": false}, {"identifier": "initializeSlicing", "parameters": "(final SliceOptions options, final FileBackedOutputStream fileBackedStream)", "modifiers": "private", "return": "boolean", "signature": "boolean initializeSlicing(final SliceOptions options, final FileBackedOutputStream fileBackedStream)", "full_signature": "private boolean initializeSlicing(final SliceOptions options, final FileBackedOutputStream fileBackedStream)", "class_method_signature": "MessageSlicer.initializeSlicing(final SliceOptions options, final FileBackedOutputStream fileBackedStream)", "testcase": false, "constructor": false}, {"identifier": "sendTo", "parameters": "(final SliceOptions options, final Object message, final ActorRef sender)", "modifiers": "private static", "return": "void", "signature": "void sendTo(final SliceOptions options, final Object message, final ActorRef sender)", "full_signature": "private static void sendTo(final SliceOptions options, final Object message, final ActorRef sender)", "class_method_signature": "MessageSlicer.sendTo(final SliceOptions options, final Object message, final ActorRef sender)", "testcase": false, "constructor": false}, {"identifier": "handleMessage", "parameters": "(final Object message)", "modifiers": "public", "return": "boolean", "signature": "boolean handleMessage(final Object message)", "full_signature": "public boolean handleMessage(final Object message)", "class_method_signature": "MessageSlicer.handleMessage(final Object message)", "testcase": false, "constructor": false}, {"identifier": "checkExpiredSlicedMessageState", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void checkExpiredSlicedMessageState()", "full_signature": "public void checkExpiredSlicedMessageState()", "class_method_signature": "MessageSlicer.checkExpiredSlicedMessageState()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "MessageSlicer.close()", "testcase": false, "constructor": false}, {"identifier": "cancelSlicing", "parameters": "(final @NonNull Predicate<Identifier> filter)", "modifiers": "public", "return": "void", "signature": "void cancelSlicing(final @NonNull Predicate<Identifier> filter)", "full_signature": "public void cancelSlicing(final @NonNull Predicate<Identifier> filter)", "class_method_signature": "MessageSlicer.cancelSlicing(final @NonNull Predicate<Identifier> filter)", "testcase": false, "constructor": false}, {"identifier": "getNextSliceMessage", "parameters": "(final SlicedMessageState<ActorRef> state)", "modifiers": "private static", "return": "MessageSlice", "signature": "MessageSlice getNextSliceMessage(final SlicedMessageState<ActorRef> state)", "full_signature": "private static MessageSlice getNextSliceMessage(final SlicedMessageState<ActorRef> state)", "class_method_signature": "MessageSlicer.getNextSliceMessage(final SlicedMessageState<ActorRef> state)", "testcase": false, "constructor": false}, {"identifier": "onMessageSliceReply", "parameters": "(final MessageSliceReply reply)", "modifiers": "private", "return": "boolean", "signature": "boolean onMessageSliceReply(final MessageSliceReply reply)", "full_signature": "private boolean onMessageSliceReply(final MessageSliceReply reply)", "class_method_signature": "MessageSlicer.onMessageSliceReply(final MessageSliceReply reply)", "testcase": false, "constructor": false}, {"identifier": "processMessageSliceException", "parameters": "(final MessageSliceException exception,\n            final SlicedMessageState<ActorRef> state, final ActorRef sendTo)", "modifiers": "private", "return": "void", "signature": "void processMessageSliceException(final MessageSliceException exception,\n            final SlicedMessageState<ActorRef> state, final ActorRef sendTo)", "full_signature": "private void processMessageSliceException(final MessageSliceException exception,\n            final SlicedMessageState<ActorRef> state, final ActorRef sendTo)", "class_method_signature": "MessageSlicer.processMessageSliceException(final MessageSliceException exception,\n            final SlicedMessageState<ActorRef> state, final ActorRef sendTo)", "testcase": false, "constructor": false}, {"identifier": "possiblyRetrySlicing", "parameters": "(final SlicedMessageState<ActorRef> state, final ActorRef sendTo)", "modifiers": "private", "return": "void", "signature": "void possiblyRetrySlicing(final SlicedMessageState<ActorRef> state, final ActorRef sendTo)", "full_signature": "private void possiblyRetrySlicing(final SlicedMessageState<ActorRef> state, final ActorRef sendTo)", "class_method_signature": "MessageSlicer.possiblyRetrySlicing(final SlicedMessageState<ActorRef> state, final ActorRef sendTo)", "testcase": false, "constructor": false}, {"identifier": "removeState", "parameters": "(final Identifier identifier)", "modifiers": "private", "return": "void", "signature": "void removeState(final Identifier identifier)", "full_signature": "private void removeState(final Identifier identifier)", "class_method_signature": "MessageSlicer.removeState(final Identifier identifier)", "testcase": false, "constructor": false}, {"identifier": "stateRemoved", "parameters": "(final RemovalNotification<Identifier, SlicedMessageState<ActorRef>> notification)", "modifiers": "private", "return": "void", "signature": "void stateRemoved(final RemovalNotification<Identifier, SlicedMessageState<ActorRef>> notification)", "full_signature": "private void stateRemoved(final RemovalNotification<Identifier, SlicedMessageState<ActorRef>> notification)", "class_method_signature": "MessageSlicer.stateRemoved(final RemovalNotification<Identifier, SlicedMessageState<ActorRef>> notification)", "testcase": false, "constructor": false}, {"identifier": "fail", "parameters": "(final SlicedMessageState<ActorRef> state, final Throwable failure)", "modifiers": "private", "return": "void", "signature": "void fail(final SlicedMessageState<ActorRef> state, final Throwable failure)", "full_signature": "private void fail(final SlicedMessageState<ActorRef> state, final Throwable failure)", "class_method_signature": "MessageSlicer.fail(final SlicedMessageState<ActorRef> state, final Throwable failure)", "testcase": false, "constructor": false}, {"identifier": "hasState", "parameters": "(final Identifier forIdentifier)", "modifiers": "@VisibleForTesting", "return": "boolean", "signature": "boolean hasState(final Identifier forIdentifier)", "full_signature": "@VisibleForTesting boolean hasState(final Identifier forIdentifier)", "class_method_signature": "MessageSlicer.hasState(final Identifier forIdentifier)", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-clustering-commons/src/main/java/org/opendaylight/controller/cluster/messaging/MessageSlicer.java"}, "focal_method": {"identifier": "slice", "parameters": "(final SliceOptions options)", "modifiers": "public", "return": "boolean", "body": "public boolean slice(final SliceOptions options) {\n        final Identifier identifier = options.getIdentifier();\n        final Serializable message = options.getMessage();\n        final FileBackedOutputStream fileBackedStream;\n        if (message != null) {\n            LOG.debug(\"{}: slice: identifier: {}, message: {}\", logContext, identifier, message);\n\n            requireNonNull(fileBackedStreamFactory,\n                    \"The FiledBackedStreamFactory must be set in order to call this slice method\");\n\n            // Serialize the message to a FileBackedOutputStream.\n            fileBackedStream = fileBackedStreamFactory.newInstance();\n            try (ObjectOutputStream out = new ObjectOutputStream(fileBackedStream)) {\n                out.writeObject(message);\n            } catch (IOException e) {\n                LOG.debug(\"{}: Error serializing message for {}\", logContext, identifier, e);\n                fileBackedStream.cleanup();\n                options.getOnFailureCallback().accept(e);\n                return false;\n            }\n        } else {\n            fileBackedStream = options.getFileBackedStream();\n        }\n\n        return initializeSlicing(options, fileBackedStream);\n    }", "signature": "boolean slice(final SliceOptions options)", "full_signature": "public boolean slice(final SliceOptions options)", "class_method_signature": "MessageSlicer.slice(final SliceOptions options)", "testcase": false, "constructor": false, "invocations": ["getIdentifier", "getMessage", "debug", "requireNonNull", "newInstance", "writeObject", "debug", "cleanup", "accept", "getOnFailureCallback", "getFileBackedStream", "initializeSlicing"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}