{"test_class": {"identifier": "TotalRecompressionLimiterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final File OLD_FILE = null;", "modifier": "private static final", "type": "File", "declarator": "OLD_FILE = null", "var_name": "OLD_FILE"}, {"original_string": "private static final File NEW_FILE = null;", "modifier": "private static final", "type": "File", "declarator": "NEW_FILE = null", "var_name": "NEW_FILE"}, {"original_string": "private static final MinimalZipEntry UNIMPORTANT = makeFakeEntry(\"/unimportant\", 1337);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "UNIMPORTANT = makeFakeEntry(\"/unimportant\", 1337)", "var_name": "UNIMPORTANT"}, {"original_string": "private static final MinimalZipEntry ENTRY_A_100K = makeFakeEntry(\"/a/100k\", 100 * 1024);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "ENTRY_A_100K = makeFakeEntry(\"/a/100k\", 100 * 1024)", "var_name": "ENTRY_A_100K"}, {"original_string": "private static final MinimalZipEntry ENTRY_B_200K = makeFakeEntry(\"/b/200k\", 200 * 1024);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "ENTRY_B_200K = makeFakeEntry(\"/b/200k\", 200 * 1024)", "var_name": "ENTRY_B_200K"}, {"original_string": "private static final MinimalZipEntry ENTRY_C_300K = makeFakeEntry(\"/c/300k\", 300 * 1024);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "ENTRY_C_300K = makeFakeEntry(\"/c/300k\", 300 * 1024)", "var_name": "ENTRY_C_300K"}, {"original_string": "private static final MinimalZipEntry ENTRY_D_400K = makeFakeEntry(\"/d/400k\", 400 * 1024);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "ENTRY_D_400K = makeFakeEntry(\"/d/400k\", 400 * 1024)", "var_name": "ENTRY_D_400K"}, {"original_string": "private static final MinimalZipEntry IGNORED_A = makeFakeEntry(\"/ignored/a\", 1234);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "IGNORED_A = makeFakeEntry(\"/ignored/a\", 1234)", "var_name": "IGNORED_A"}, {"original_string": "private static final MinimalZipEntry IGNORED_B = makeFakeEntry(\"/ignored/b\", 5678);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "IGNORED_B = makeFakeEntry(\"/ignored/b\", 5678)", "var_name": "IGNORED_B"}, {"original_string": "private static final MinimalZipEntry IGNORED_C = makeFakeEntry(\"/ignored/c\", 9101112);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "IGNORED_C = makeFakeEntry(\"/ignored/c\", 9101112)", "var_name": "IGNORED_C"}, {"original_string": "private static final MinimalZipEntry IGNORED_D = makeFakeEntry(\"/ignored/d\", 13141516);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "IGNORED_D = makeFakeEntry(\"/ignored/d\", 13141516)", "var_name": "IGNORED_D"}, {"original_string": "private static final QualifiedRecommendation REC_A_100K =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          ENTRY_A_100K,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_BYTES_CHANGED);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_A_100K =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          ENTRY_A_100K,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_BYTES_CHANGED)", "var_name": "REC_A_100K"}, {"original_string": "private static final QualifiedRecommendation REC_B_200K =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          ENTRY_B_200K,\n          Recommendation.UNCOMPRESS_NEW,\n          RecommendationReason.UNCOMPRESSED_CHANGED_TO_COMPRESSED);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_B_200K =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          ENTRY_B_200K,\n          Recommendation.UNCOMPRESS_NEW,\n          RecommendationReason.UNCOMPRESSED_CHANGED_TO_COMPRESSED)", "var_name": "REC_B_200K"}, {"original_string": "private static final QualifiedRecommendation REC_C_300K =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          ENTRY_C_300K,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_BYTES_CHANGED);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_C_300K =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          ENTRY_C_300K,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_BYTES_CHANGED)", "var_name": "REC_C_300K"}, {"original_string": "private static final QualifiedRecommendation REC_D_400K =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          ENTRY_D_400K,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_BYTES_CHANGED);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_D_400K =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          ENTRY_D_400K,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_BYTES_CHANGED)", "var_name": "REC_D_400K"}, {"original_string": "private static final QualifiedRecommendation REC_IGNORED_A_UNCHANGED =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          IGNORED_A,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.COMPRESSED_BYTES_IDENTICAL);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_IGNORED_A_UNCHANGED =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          IGNORED_A,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.COMPRESSED_BYTES_IDENTICAL)", "var_name": "REC_IGNORED_A_UNCHANGED"}, {"original_string": "private static final QualifiedRecommendation REC_IGNORED_B_BOTH_UNCOMPRESSED =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          IGNORED_B,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.BOTH_ENTRIES_UNCOMPRESSED);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_IGNORED_B_BOTH_UNCOMPRESSED =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          IGNORED_B,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.BOTH_ENTRIES_UNCOMPRESSED)", "var_name": "REC_IGNORED_B_BOTH_UNCOMPRESSED"}, {"original_string": "private static final QualifiedRecommendation REC_IGNORED_C_UNSUITABLE =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          IGNORED_C,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.UNSUITABLE);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_IGNORED_C_UNSUITABLE =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          IGNORED_C,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.UNSUITABLE)", "var_name": "REC_IGNORED_C_UNSUITABLE"}, {"original_string": "private static final QualifiedRecommendation REC_IGNORED_D_CHANGED_TO_UNCOMPRESSED =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          IGNORED_D,\n          Recommendation.UNCOMPRESS_OLD,\n          RecommendationReason.COMPRESSED_CHANGED_TO_UNCOMPRESSED);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_IGNORED_D_CHANGED_TO_UNCOMPRESSED =\n      new QualifiedRecommendation(\n          UNIMPORTANT,\n          IGNORED_D,\n          Recommendation.UNCOMPRESS_OLD,\n          RecommendationReason.COMPRESSED_CHANGED_TO_UNCOMPRESSED)", "var_name": "REC_IGNORED_D_CHANGED_TO_UNCOMPRESSED"}, {"original_string": "private static final List<QualifiedRecommendation> ALL_IGNORED_RECS =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              REC_IGNORED_A_UNCHANGED,\n              REC_IGNORED_B_BOTH_UNCOMPRESSED,\n              REC_IGNORED_C_UNSUITABLE,\n              REC_IGNORED_D_CHANGED_TO_UNCOMPRESSED));", "modifier": "private static final", "type": "List<QualifiedRecommendation>", "declarator": "ALL_IGNORED_RECS =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              REC_IGNORED_A_UNCHANGED,\n              REC_IGNORED_B_BOTH_UNCOMPRESSED,\n              REC_IGNORED_C_UNSUITABLE,\n              REC_IGNORED_D_CHANGED_TO_UNCOMPRESSED))", "var_name": "ALL_IGNORED_RECS"}, {"original_string": "private static final List<QualifiedRecommendation> ALL_RECS =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              REC_IGNORED_A_UNCHANGED,\n              REC_A_100K,\n              REC_IGNORED_B_BOTH_UNCOMPRESSED,\n              REC_D_400K,\n              REC_IGNORED_C_UNSUITABLE,\n              REC_B_200K,\n              REC_IGNORED_D_CHANGED_TO_UNCOMPRESSED,\n              REC_C_300K));", "modifier": "private static final", "type": "List<QualifiedRecommendation>", "declarator": "ALL_RECS =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              REC_IGNORED_A_UNCHANGED,\n              REC_A_100K,\n              REC_IGNORED_B_BOTH_UNCOMPRESSED,\n              REC_D_400K,\n              REC_IGNORED_C_UNSUITABLE,\n              REC_B_200K,\n              REC_IGNORED_D_CHANGED_TO_UNCOMPRESSED,\n              REC_C_300K))", "var_name": "ALL_RECS"}], "file": "feya/libraries/archive_diff/diff.generator/src/test/java/com/google/archivepatcher/generator/TotalRecompressionLimiterTest.java"}, "test_case": {"identifier": "testLimit_EdgeOverLargest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testLimit_EdgeOverLargest() {\n    long limit = REC_D_400K.getNewEntry().getUncompressedSize() + 1; // 1 byte extra room\n    TotalRecompressionLimiter limiter = new TotalRecompressionLimiter(limit);\n    List<QualifiedRecommendation> expected = new ArrayList<QualifiedRecommendation>();\n    expected.add(REC_D_400K);\n    expected.addAll(suppressed(REC_A_100K, REC_B_200K, REC_C_300K));\n    expected.addAll(ALL_IGNORED_RECS);\n    assertEquivalence(expected, limiter.getModifiedRecommendations(OLD_FILE, NEW_FILE, ALL_RECS));\n  }", "signature": "void testLimit_EdgeOverLargest()", "full_signature": "@Test public void testLimit_EdgeOverLargest()", "class_method_signature": "TotalRecompressionLimiterTest.testLimit_EdgeOverLargest()", "testcase": true, "constructor": false, "invocations": ["getUncompressedSize", "getNewEntry", "add", "addAll", "suppressed", "addAll", "assertEquivalence", "getModifiedRecommendations"]}, "focal_class": {"identifier": "TotalRecompressionLimiter", "superclass": "", "interfaces": "implements RecommendationModifier", "fields": [{"original_string": "private final long maxBytesToRecompress;", "modifier": "private final", "type": "long", "declarator": "maxBytesToRecompress", "var_name": "maxBytesToRecompress"}, {"original_string": "private static final Comparator<QualifiedRecommendation> COMPARATOR =\n      new UncompressedNewEntrySizeComparator();", "modifier": "private static final", "type": "Comparator<QualifiedRecommendation>", "declarator": "COMPARATOR =\n      new UncompressedNewEntrySizeComparator()", "var_name": "COMPARATOR"}], "methods": [{"identifier": "TotalRecompressionLimiter", "parameters": "(long maxBytesToRecompress)", "modifiers": "public", "return": "", "signature": " TotalRecompressionLimiter(long maxBytesToRecompress)", "full_signature": "public  TotalRecompressionLimiter(long maxBytesToRecompress)", "class_method_signature": "TotalRecompressionLimiter.TotalRecompressionLimiter(long maxBytesToRecompress)", "testcase": false, "constructor": true}, {"identifier": "getModifiedRecommendations", "parameters": "(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "modifiers": "@Override public", "return": "List<QualifiedRecommendation>", "signature": "List<QualifiedRecommendation> getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "full_signature": "@Override public List<QualifiedRecommendation> getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "class_method_signature": "TotalRecompressionLimiter.getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "testcase": false, "constructor": false}], "file": "feya/libraries/archive_diff/diff.generator/src/main/java/com/google/archivepatcher/generator/TotalRecompressionLimiter.java"}, "focal_method": {"identifier": "getModifiedRecommendations", "parameters": "(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "modifiers": "@Override public", "return": "List<QualifiedRecommendation>", "body": "@Override\n  public List<QualifiedRecommendation> getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations) {\n\n    List<QualifiedRecommendation> sorted =\n        new ArrayList<QualifiedRecommendation>(originalRecommendations);\n    Collections.sort(sorted, COMPARATOR);\n    Collections.reverse(sorted);\n\n    List<QualifiedRecommendation> result = new ArrayList<>(sorted.size());\n    long recompressibleBytesRemaining = maxBytesToRecompress;\n    for (QualifiedRecommendation originalRecommendation : sorted) {\n      if (!originalRecommendation.getRecommendation().uncompressNewEntry) {\n        // Keep the original recommendation, no need to track size since it won't be uncompressed.\n        result.add(originalRecommendation);\n      } else {\n        long bytesToRecompress = originalRecommendation.getNewEntry().getUncompressedSize();\n        if (recompressibleBytesRemaining - bytesToRecompress >= 0) {\n          // Keep the original recommendation, but also subtract from the remaining space.\n          result.add(originalRecommendation);\n          recompressibleBytesRemaining -= bytesToRecompress;\n        } else {\n          // Update the recommendation to prevent uncompressing this tuple.\n          result.add(\n              new QualifiedRecommendation(\n                  originalRecommendation.getOldEntry(),\n                  originalRecommendation.getNewEntry(),\n                  Recommendation.UNCOMPRESS_NEITHER,\n                  RecommendationReason.RESOURCE_CONSTRAINED));\n        }\n      }\n    }\n    return result;\n  }", "signature": "List<QualifiedRecommendation> getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "full_signature": "@Override public List<QualifiedRecommendation> getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "class_method_signature": "TotalRecompressionLimiter.getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "testcase": false, "constructor": false, "invocations": ["sort", "reverse", "size", "getRecommendation", "add", "getUncompressedSize", "getNewEntry", "add", "add", "getOldEntry", "getNewEntry"]}, "repository": {"repo_id": 20126854, "url": "https://github.com/kaedea/Feya", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 12, "size": 7798, "license": "licensed"}}