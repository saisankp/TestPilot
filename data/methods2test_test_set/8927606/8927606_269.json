{"test_class": {"identifier": "TimeoutGuardPipeTest", "superclass": "extends PipeTestBase<TimeoutGuardPipe>", "interfaces": "", "fields": [{"original_string": "private final static String SUCCESS_MESSAGE = \"did not timeout!\";", "modifier": "private final static", "type": "String", "declarator": "SUCCESS_MESSAGE = \"did not timeout!\"", "var_name": "SUCCESS_MESSAGE"}], "file": "core/src/test/java/nl/nn/adapterframework/pipes/TimeoutGuardPipeTest.java"}, "test_case": {"identifier": "doesTimeoutWithException", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void doesTimeoutWithException() throws Exception {\n\t\tconfigureAndStartPipe();\n\t\tMessage input = new Message(\"1500\");\n\t\ttry {\n\t\t\tdoPipe(input);\n\n\t\t\tfail(\"an exception should occur!\");\n\t\t} catch(PipeRunException e) {\n\t\t\tassertTrue(e.getCause() instanceof TimeOutException);\n\t\t}\n\t}", "signature": "void doesTimeoutWithException()", "full_signature": "@Test public void doesTimeoutWithException()", "class_method_signature": "TimeoutGuardPipeTest.doesTimeoutWithException()", "testcase": true, "constructor": false, "invocations": ["configureAndStartPipe", "doPipe", "fail", "assertTrue", "getCause"]}, "focal_class": {"identifier": "TimeoutGuardPipe", "superclass": "extends FixedForwardPipe", "interfaces": "", "fields": [{"original_string": "private boolean throwException = true;", "modifier": "private", "type": "boolean", "declarator": "throwException = true", "var_name": "throwException"}, {"original_string": "private int timeout = 30;", "modifier": "private", "type": "int", "declarator": "timeout = 30", "var_name": "timeout"}], "methods": [{"identifier": "doPipe", "parameters": "(Message message, IPipeLineSession session)", "modifiers": "@Override public", "return": "PipeRunResult", "signature": "PipeRunResult doPipe(Message message, IPipeLineSession session)", "full_signature": "@Override public PipeRunResult doPipe(Message message, IPipeLineSession session)", "class_method_signature": "TimeoutGuardPipe.doPipe(Message message, IPipeLineSession session)", "testcase": false, "constructor": false}, {"identifier": "doPipeWithTimeoutGuarded", "parameters": "(Message input, IPipeLineSession session)", "modifiers": "public abstract", "return": "PipeRunResult", "signature": "PipeRunResult doPipeWithTimeoutGuarded(Message input, IPipeLineSession session)", "full_signature": "public abstract PipeRunResult doPipeWithTimeoutGuarded(Message input, IPipeLineSession session)", "class_method_signature": "TimeoutGuardPipe.doPipeWithTimeoutGuarded(Message input, IPipeLineSession session)", "testcase": false, "constructor": false}, {"identifier": "killPipe", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void killPipe()", "full_signature": "protected void killPipe()", "class_method_signature": "TimeoutGuardPipe.killPipe()", "testcase": false, "constructor": false}, {"identifier": "setThrowException", "parameters": "(boolean b)", "modifiers": "@IbisDoc({\"when <code>true</code>, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags)\", \"true\"}) public", "return": "void", "signature": "void setThrowException(boolean b)", "full_signature": "@IbisDoc({\"when <code>true</code>, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags)\", \"true\"}) public void setThrowException(boolean b)", "class_method_signature": "TimeoutGuardPipe.setThrowException(boolean b)", "testcase": false, "constructor": false}, {"identifier": "isThrowException", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isThrowException()", "full_signature": "public boolean isThrowException()", "class_method_signature": "TimeoutGuardPipe.isThrowException()", "testcase": false, "constructor": false}, {"identifier": "getTimeout", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getTimeout()", "full_signature": "public int getTimeout()", "class_method_signature": "TimeoutGuardPipe.getTimeout()", "testcase": false, "constructor": false}, {"identifier": "setTimeout", "parameters": "(int i)", "modifiers": "@IbisDoc({\"timeout in seconds of obtaining a result\", \"30\"}) public", "return": "void", "signature": "void setTimeout(int i)", "full_signature": "@IbisDoc({\"timeout in seconds of obtaining a result\", \"30\"}) public void setTimeout(int i)", "class_method_signature": "TimeoutGuardPipe.setTimeout(int i)", "testcase": false, "constructor": false}], "file": "core/src/main/java/nl/nn/adapterframework/pipes/TimeoutGuardPipe.java"}, "focal_method": {"identifier": "doPipe", "parameters": "(Message message, IPipeLineSession session)", "modifiers": "@Override public", "return": "PipeRunResult", "body": "@Override\n\tpublic PipeRunResult doPipe(Message message, IPipeLineSession session) throws PipeRunException {\n\t\tParameterValueList pvl = null;\n\t\tif (getParameterList() != null) {\n\t\t\ttry {\n\t\t\t\tpvl = getParameterList().getValues(message, session);\n\t\t\t} catch (ParameterException e) {\n\t\t\t\tthrow new PipeRunException(this, getLogPrefix(session) + \"exception on extracting parameters\", e);\n\t\t\t}\n\t\t}\n\t\tint timeout_work;\n\t\tString timeout_work_str = getParameterValue(pvl, \"timeout\");\n\t\tif (timeout_work_str == null) {\n\t\t\ttimeout_work = getTimeout();\n\t\t} else {\n\t\t\ttimeout_work = Integer.valueOf(timeout_work_str);\n\t\t}\n\n\t\tlog.debug(getLogPrefix(session) + \"setting timeout of [\" + timeout_work + \"] s\");\n\t\tTimeoutGuard tg = new TimeoutGuard(timeout_work, getName()) {\n\t\t\t@Override\n\t\t\tprotected void kill() {\n\t\t\t\t//The guard automatically kills the current thread, additional threads maybe 'killed' by implementing killPipe.\n\t\t\t\tkillPipe();\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\treturn doPipeWithTimeoutGuarded(message, session);\n\t\t} catch (Exception e) {\n\t\t\tString msg = e.getClass().getName();\n\n\t\t\tif (isThrowException()) {\n\t\t\t\tthrow new PipeRunException(this, msg, e);\n\t\t\t} else {\n\t\t\t\tString msgString = msg + \": \" + e.getMessage();\n\t\t\t\tlog.error(msgString, e);\n\t\t\t\tString msgCdataString = \"<![CDATA[\" + msgString + \"]]>\";\n\t\t\t\tMessage errorMessage = new Message(\"<error>\" + msgCdataString + \"</error>\");\n\t\t\t\treturn new PipeRunResult(getForward(), errorMessage);\n\t\t\t}\n\t\t} finally {\n\t\t\tif(tg.cancel()) {\n\t\t\t\t//Throw a TimeOutException\n\t\t\t\tString msgString = \"TimeOutException\";\n\t\t\t\tException e = new TimeOutException(\"exceeds timeout of [\" + timeout_work + \"] s, interupting\");\n\t\t\t\tif (isThrowException()) {\n\t\t\t\t\tthrow new PipeRunException(this, msgString, e);\n\t\t\t\t} else {\n\t\t\t\t\t//This is used for the old console, where a message is displayed\n\t\t\t\t\tlog.error(msgString, e);\n\t\t\t\t\tString msgCdataString = \"<![CDATA[\" + msgString + \": \"+ e.getMessage() + \"]]>\";\n\t\t\t\t\tMessage errorMessage = new Message(\"<error>\" + msgCdataString + \"</error>\");\n\t\t\t\t\treturn new PipeRunResult(getForward(), errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "signature": "PipeRunResult doPipe(Message message, IPipeLineSession session)", "full_signature": "@Override public PipeRunResult doPipe(Message message, IPipeLineSession session)", "class_method_signature": "TimeoutGuardPipe.doPipe(Message message, IPipeLineSession session)", "testcase": false, "constructor": false, "invocations": ["getParameterList", "getValues", "getParameterList", "getLogPrefix", "getParameterValue", "getTimeout", "valueOf", "debug", "getLogPrefix", "getName", "killPipe", "doPipeWithTimeoutGuarded", "getName", "getClass", "isThrowException", "getMessage", "error", "getForward", "cancel", "isThrowException", "error", "getMessage", "getForward"]}, "repository": {"repo_id": 8927606, "url": "https://github.com/ibissource/iaf", "stars": 17, "created": "3/21/2013 11:48:24 AM +00:00", "updates": "2020-01-27T15:25:21+00:00", "fork": "False", "license": "licensed"}}