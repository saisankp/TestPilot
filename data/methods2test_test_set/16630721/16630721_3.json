{"test_class": {"identifier": "SampleDaoTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Mock\n  private DatabaseMock db;", "modifier": "@Mock\n  private", "type": "DatabaseMock", "declarator": "db", "var_name": "db"}, {"original_string": "private Date now = new Date();", "modifier": "private", "type": "Date", "declarator": "now = new Date()", "var_name": "now"}, {"original_string": "private SampleDao sampleDao;", "modifier": "private", "type": "SampleDao", "declarator": "sampleDao", "var_name": "sampleDao"}], "file": "demo/src/test/java/SampleDaoTest.java"}, "test_case": {"identifier": "testUpdate", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testUpdate() throws Exception {\n    // Configure the mock because our class under test expects values to be returned from the db\n    when(db.query(anyString(), anyString())).thenReturn(new RowStub()\n        .withColumnNames(\"sample_name\", \"update_sequence\", \"update_time\")\n        .addRow(\"Foo\", 3, now));\n    Date before = new Date(now.getTime() - 5000);\n\n    Sample sample = new Sample();\n    sample.setSampleId(100L);\n    sample.setName(\"Foo\");\n    sample.setUpdateSequence(13);\n    sample.setUpdateTime(before);\n    sampleDao.updateSample(sample, 23L);\n\n    // Verify object in memory is updated properly\n    assertEquals(new Long(100L), sample.getSampleId());\n    assertEquals(\"Foo\", sample.getName());\n    assertEquals(new Integer(14), sample.getUpdateSequence());\n    assertEquals(now, sample.getUpdateTime());\n\n    // Verify database queries against golden copies\n    verify(db).update(eq(\"update sample set sample_name=?, update_sequence=?, update_time=? where sample_id=?\"), anyString());\n    verify(db).insert(eq(\"insert into sample_history (sample_id, sample_name, update_sequence, update_time, update_user_id, is_deleted) values (?,?,?,?,?,'N')\"), anyString());\n    verifyNoMoreInteractions(db);\n  }", "signature": "void testUpdate()", "full_signature": "@Test public void testUpdate()", "class_method_signature": "SampleDaoTest.testUpdate()", "testcase": true, "constructor": false, "invocations": ["thenReturn", "when", "query", "anyString", "anyString", "addRow", "withColumnNames", "getTime", "setSampleId", "setName", "setUpdateSequence", "setUpdateTime", "updateSample", "assertEquals", "getSampleId", "assertEquals", "getName", "assertEquals", "getUpdateSequence", "assertEquals", "getUpdateTime", "update", "verify", "eq", "anyString", "insert", "verify", "eq", "anyString", "verifyNoMoreInteractions"]}, "focal_class": {"identifier": "SampleDao", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Supplier<Database> dbp;", "modifier": "private final", "type": "Supplier<Database>", "declarator": "dbp", "var_name": "dbp"}], "methods": [{"identifier": "SampleDao", "parameters": "(Supplier<Database> dbp)", "modifiers": "public", "return": "", "signature": " SampleDao(Supplier<Database> dbp)", "full_signature": "public  SampleDao(Supplier<Database> dbp)", "class_method_signature": "SampleDao.SampleDao(Supplier<Database> dbp)", "testcase": false, "constructor": true}, {"identifier": "createSample", "parameters": "(final Sample sample, Long userIdMakingChange)", "modifiers": "public", "return": "void", "signature": "void createSample(final Sample sample, Long userIdMakingChange)", "full_signature": "public void createSample(final Sample sample, Long userIdMakingChange)", "class_method_signature": "SampleDao.createSample(final Sample sample, Long userIdMakingChange)", "testcase": false, "constructor": false}, {"identifier": "findSampleById", "parameters": "(final Long sampleId, boolean lockRow)", "modifiers": "public", "return": "Sample", "signature": "Sample findSampleById(final Long sampleId, boolean lockRow)", "full_signature": "public Sample findSampleById(final Long sampleId, boolean lockRow)", "class_method_signature": "SampleDao.findSampleById(final Long sampleId, boolean lockRow)", "testcase": false, "constructor": false}, {"identifier": "updateSample", "parameters": "(Sample sample, Long userIdMakingChange)", "modifiers": "public", "return": "void", "signature": "void updateSample(Sample sample, Long userIdMakingChange)", "full_signature": "public void updateSample(Sample sample, Long userIdMakingChange)", "class_method_signature": "SampleDao.updateSample(Sample sample, Long userIdMakingChange)", "testcase": false, "constructor": false}, {"identifier": "deleteSample", "parameters": "(Sample sample, Long userIdMakingChange)", "modifiers": "public", "return": "void", "signature": "void deleteSample(Sample sample, Long userIdMakingChange)", "full_signature": "public void deleteSample(Sample sample, Long userIdMakingChange)", "class_method_signature": "SampleDao.deleteSample(Sample sample, Long userIdMakingChange)", "testcase": false, "constructor": false}], "file": "demo/src/main/java/SampleDao.java"}, "focal_method": {"identifier": "updateSample", "parameters": "(Sample sample, Long userIdMakingChange)", "modifiers": "public", "return": "void", "body": "public void updateSample(Sample sample, Long userIdMakingChange) {\n    Database db = dbp.get();\n\n    // Insert the history row first, so it will fail (non-unique sample_id + update_sequence)\n    // if someone else modified the row. This is an optimistic locking strategy.\n    int newUpdateSequence = sample.getUpdateSequence() + 1;\n    Date newUpdateTime = db.nowPerApp();\n    db.toInsert(\"insert into sample_history (sample_id, sample_name, update_sequence, update_time, update_user_id,\"\n        + \" is_deleted) values (?,?,?,?,?,'N')\")\n        .argLong(sample.getSampleId())\n        .argString(sample.getName())\n        .argInteger(newUpdateSequence)\n        .argDate(newUpdateTime)\n        .argLong(userIdMakingChange)\n        .insert(1);\n\n    db.toUpdate(\"update sample set sample_name=?, update_sequence=?, update_time=? where sample_id=?\")\n        .argString(sample.getName())\n        .argInteger(newUpdateSequence)\n        .argDate(newUpdateTime)\n        .argLong(sample.getSampleId())\n        .update(1);\n\n    // Make sure the object in memory matches the database.\n    sample.setUpdateSequence(newUpdateSequence);\n    sample.setUpdateTime(newUpdateTime);\n  }", "signature": "void updateSample(Sample sample, Long userIdMakingChange)", "full_signature": "public void updateSample(Sample sample, Long userIdMakingChange)", "class_method_signature": "SampleDao.updateSample(Sample sample, Long userIdMakingChange)", "testcase": false, "constructor": false, "invocations": ["get", "getUpdateSequence", "nowPerApp", "insert", "argLong", "argDate", "argInteger", "argString", "argLong", "toInsert", "getSampleId", "getName", "update", "argLong", "argDate", "argInteger", "argString", "toUpdate", "getName", "getSampleId", "setUpdateSequence", "setUpdateTime"]}, "repository": {"repo_id": 16630721, "url": "https://github.com/susom/database", "stars": 32, "created": "2/7/2014 11:25:13 PM +00:00", "updates": "2019-12-26T21:46:30+00:00", "fork": "False", "license": "licensed"}}