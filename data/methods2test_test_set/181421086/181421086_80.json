{"test_class": {"identifier": "FirewallTest", "superclass": "extends FloodlightTestCase", "interfaces": "", "fields": [{"original_string": "protected FloodlightContext cntx;", "modifier": "protected", "type": "FloodlightContext", "declarator": "cntx", "var_name": "cntx"}, {"original_string": "protected OFPacketIn packetIn;", "modifier": "protected", "type": "OFPacketIn", "declarator": "packetIn", "var_name": "packetIn"}, {"original_string": "protected IOFSwitch sw;", "modifier": "protected", "type": "IOFSwitch", "declarator": "sw", "var_name": "sw"}, {"original_string": "protected IPacket tcpPacket;", "modifier": "protected", "type": "IPacket", "declarator": "tcpPacket", "var_name": "tcpPacket"}, {"original_string": "protected IPacket broadcastARPPacket;", "modifier": "protected", "type": "IPacket", "declarator": "broadcastARPPacket", "var_name": "broadcastARPPacket"}, {"original_string": "protected IPacket ARPReplyPacket;", "modifier": "protected", "type": "IPacket", "declarator": "ARPReplyPacket", "var_name": "ARPReplyPacket"}, {"original_string": "protected IPacket broadcastIPPacket;", "modifier": "protected", "type": "IPacket", "declarator": "broadcastIPPacket", "var_name": "broadcastIPPacket"}, {"original_string": "protected IPacket tcpPacketReply;", "modifier": "protected", "type": "IPacket", "declarator": "tcpPacketReply", "var_name": "tcpPacketReply"}, {"original_string": "protected IPacket broadcastMalformedPacket;", "modifier": "protected", "type": "IPacket", "declarator": "broadcastMalformedPacket", "var_name": "broadcastMalformedPacket"}, {"original_string": "private Firewall firewall;", "modifier": "private", "type": "Firewall", "declarator": "firewall", "var_name": "firewall"}, {"original_string": "private MockDebugCounterService debugCounterService;", "modifier": "private", "type": "MockDebugCounterService", "declarator": "debugCounterService", "var_name": "debugCounterService"}, {"original_string": "public static String TestSwitch1DPID = \"00:00:00:00:00:00:00:01\";", "modifier": "public static", "type": "String", "declarator": "TestSwitch1DPID = \"00:00:00:00:00:00:00:01\"", "var_name": "TestSwitch1DPID"}], "file": "src/agents/apps/floodlight/floodlight-1.0/src/test/java/net/floodlightcontroller/firewall/FirewallTest.java"}, "test_case": {"identifier": "testReadRulesFromStorage", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testReadRulesFromStorage() throws Exception {\n        // add 2 rules first\n        FirewallRule rule = new FirewallRule();\n        rule.in_port = OFPort.of(2);\n        rule.dl_src = MacAddress.of(\"00:00:00:00:00:01\");\n        rule.dl_dst = MacAddress.of(\"00:00:00:00:00:02\");\n        rule.priority = 1;\n        rule.action = FirewallRule.FirewallAction.DROP;\n        firewall.addRule(rule);\n        rule = new FirewallRule();\n        rule.in_port = OFPort.of(3);\n        rule.dl_src = MacAddress.of(\"00:00:00:00:00:02\");\n        rule.dl_dst = MacAddress.of(\"00:00:00:00:00:01\");\n        rule.nw_proto = IpProtocol.TCP;\n        rule.any_nw_proto = false;\n        rule.tp_dst = TransportPort.of(80);\n        rule.priority = 2;\n        rule.action = FirewallRule.FirewallAction.ALLOW;\n        firewall.addRule(rule);\n\n        List<FirewallRule> rules = firewall.readRulesFromStorage();\n        // verify rule 1\n        FirewallRule r = rules.get(0);\n        assertEquals(r.in_port, OFPort.of(2));\n        assertEquals(r.priority, 1);\n        assertEquals(r.dl_src, MacAddress.of(\"00:00:00:00:00:01\"));\n        assertEquals(r.dl_dst, MacAddress.of(\"00:00:00:00:00:02\"));\n        assertEquals(r.action, FirewallRule.FirewallAction.DROP);\n        // verify rule 2\n        r = rules.get(1);\n        assertEquals(r.in_port, OFPort.of(3));\n        assertEquals(r.priority, 2);\n        assertEquals(r.dl_src, MacAddress.of(\"00:00:00:00:00:02\"));\n        assertEquals(r.dl_dst, MacAddress.of(\"00:00:00:00:00:01\"));\n        assertEquals(r.nw_proto, IpProtocol.TCP);\n        assertEquals(r.tp_dst, TransportPort.of(80));\n        assertEquals(r.any_nw_proto, false);\n        assertEquals(r.action, FirewallRule.FirewallAction.ALLOW);\n    }", "signature": "void testReadRulesFromStorage()", "full_signature": "@Test public void testReadRulesFromStorage()", "class_method_signature": "FirewallTest.testReadRulesFromStorage()", "testcase": true, "constructor": false, "invocations": ["of", "of", "of", "addRule", "of", "of", "of", "of", "addRule", "readRulesFromStorage", "get", "assertEquals", "of", "assertEquals", "assertEquals", "of", "assertEquals", "of", "assertEquals", "get", "assertEquals", "of", "assertEquals", "assertEquals", "of", "assertEquals", "of", "assertEquals", "assertEquals", "of", "assertEquals", "assertEquals"]}, "focal_class": {"identifier": "Firewall", "superclass": "", "interfaces": "implements IFirewallService, IOFMessageListener,\n        IFloodlightModule", "fields": [{"original_string": "protected IFloodlightProviderService floodlightProvider;", "modifier": "protected", "type": "IFloodlightProviderService", "declarator": "floodlightProvider", "var_name": "floodlightProvider"}, {"original_string": "protected IStorageSourceService storageSource;", "modifier": "protected", "type": "IStorageSourceService", "declarator": "storageSource", "var_name": "storageSource"}, {"original_string": "protected IRestApiService restApi;", "modifier": "protected", "type": "IRestApiService", "declarator": "restApi", "var_name": "restApi"}, {"original_string": "protected static Logger logger;", "modifier": "protected static", "type": "Logger", "declarator": "logger", "var_name": "logger"}, {"original_string": "protected List<FirewallRule> rules;", "modifier": "protected", "type": "List<FirewallRule>", "declarator": "rules", "var_name": "rules"}, {"original_string": "protected boolean enabled;", "modifier": "protected", "type": "boolean", "declarator": "enabled", "var_name": "enabled"}, {"original_string": "protected IPv4Address subnet_mask = IPv4Address.of(\"255.255.255.0\");", "modifier": "protected", "type": "IPv4Address", "declarator": "subnet_mask = IPv4Address.of(\"255.255.255.0\")", "var_name": "subnet_mask"}, {"original_string": "public static final String TABLE_NAME = \"controller_firewallrules\";", "modifier": "public static final", "type": "String", "declarator": "TABLE_NAME = \"controller_firewallrules\"", "var_name": "TABLE_NAME"}, {"original_string": "public static final String COLUMN_RULEID = \"ruleid\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_RULEID = \"ruleid\"", "var_name": "COLUMN_RULEID"}, {"original_string": "public static final String COLUMN_DPID = \"dpid\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_DPID = \"dpid\"", "var_name": "COLUMN_DPID"}, {"original_string": "public static final String COLUMN_IN_PORT = \"in_port\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_IN_PORT = \"in_port\"", "var_name": "COLUMN_IN_PORT"}, {"original_string": "public static final String COLUMN_DL_SRC = \"dl_src\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_DL_SRC = \"dl_src\"", "var_name": "COLUMN_DL_SRC"}, {"original_string": "public static final String COLUMN_DL_DST = \"dl_dst\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_DL_DST = \"dl_dst\"", "var_name": "COLUMN_DL_DST"}, {"original_string": "public static final String COLUMN_DL_TYPE = \"dl_type\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_DL_TYPE = \"dl_type\"", "var_name": "COLUMN_DL_TYPE"}, {"original_string": "public static final String COLUMN_NW_SRC_PREFIX = \"nw_src_prefix\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_NW_SRC_PREFIX = \"nw_src_prefix\"", "var_name": "COLUMN_NW_SRC_PREFIX"}, {"original_string": "public static final String COLUMN_NW_SRC_MASKBITS = \"nw_src_maskbits\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_NW_SRC_MASKBITS = \"nw_src_maskbits\"", "var_name": "COLUMN_NW_SRC_MASKBITS"}, {"original_string": "public static final String COLUMN_NW_DST_PREFIX = \"nw_dst_prefix\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_NW_DST_PREFIX = \"nw_dst_prefix\"", "var_name": "COLUMN_NW_DST_PREFIX"}, {"original_string": "public static final String COLUMN_NW_DST_MASKBITS = \"nw_dst_maskbits\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_NW_DST_MASKBITS = \"nw_dst_maskbits\"", "var_name": "COLUMN_NW_DST_MASKBITS"}, {"original_string": "public static final String COLUMN_NW_PROTO = \"nw_proto\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_NW_PROTO = \"nw_proto\"", "var_name": "COLUMN_NW_PROTO"}, {"original_string": "public static final String COLUMN_TP_SRC = \"tp_src\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_TP_SRC = \"tp_src\"", "var_name": "COLUMN_TP_SRC"}, {"original_string": "public static final String COLUMN_TP_DST = \"tp_dst\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_TP_DST = \"tp_dst\"", "var_name": "COLUMN_TP_DST"}, {"original_string": "public static final String COLUMN_WILDCARD_DPID = \"wildcard_dpid\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_WILDCARD_DPID = \"wildcard_dpid\"", "var_name": "COLUMN_WILDCARD_DPID"}, {"original_string": "public static final String COLUMN_WILDCARD_IN_PORT = \"any_in_port\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_WILDCARD_IN_PORT = \"any_in_port\"", "var_name": "COLUMN_WILDCARD_IN_PORT"}, {"original_string": "public static final String COLUMN_WILDCARD_DL_SRC = \"any_dl_src\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_WILDCARD_DL_SRC = \"any_dl_src\"", "var_name": "COLUMN_WILDCARD_DL_SRC"}, {"original_string": "public static final String COLUMN_WILDCARD_DL_DST = \"any_dl_dst\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_WILDCARD_DL_DST = \"any_dl_dst\"", "var_name": "COLUMN_WILDCARD_DL_DST"}, {"original_string": "public static final String COLUMN_WILDCARD_DL_TYPE = \"any_dl_type\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_WILDCARD_DL_TYPE = \"any_dl_type\"", "var_name": "COLUMN_WILDCARD_DL_TYPE"}, {"original_string": "public static final String COLUMN_WILDCARD_NW_SRC = \"any_nw_src\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_WILDCARD_NW_SRC = \"any_nw_src\"", "var_name": "COLUMN_WILDCARD_NW_SRC"}, {"original_string": "public static final String COLUMN_WILDCARD_NW_DST = \"any_nw_dst\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_WILDCARD_NW_DST = \"any_nw_dst\"", "var_name": "COLUMN_WILDCARD_NW_DST"}, {"original_string": "public static final String COLUMN_WILDCARD_NW_PROTO = \"any_nw_proto\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_WILDCARD_NW_PROTO = \"any_nw_proto\"", "var_name": "COLUMN_WILDCARD_NW_PROTO"}, {"original_string": "public static final String COLUMN_WILDCARD_TP_SRC = \"any_tp_src\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_WILDCARD_TP_SRC = \"any_tp_src\"", "var_name": "COLUMN_WILDCARD_TP_SRC"}, {"original_string": "public static final String COLUMN_WILDCARD_TP_DST = \"any_tp_dst\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_WILDCARD_TP_DST = \"any_tp_dst\"", "var_name": "COLUMN_WILDCARD_TP_DST"}, {"original_string": "public static final String COLUMN_PRIORITY = \"priority\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_PRIORITY = \"priority\"", "var_name": "COLUMN_PRIORITY"}, {"original_string": "public static final String COLUMN_ACTION = \"action\";", "modifier": "public static final", "type": "String", "declarator": "COLUMN_ACTION = \"action\"", "var_name": "COLUMN_ACTION"}, {"original_string": "public static String ColumnNames[] = { COLUMN_RULEID, COLUMN_DPID,\n            COLUMN_IN_PORT, COLUMN_DL_SRC, COLUMN_DL_DST, COLUMN_DL_TYPE,\n            COLUMN_NW_SRC_PREFIX, COLUMN_NW_SRC_MASKBITS, COLUMN_NW_DST_PREFIX,\n            COLUMN_NW_DST_MASKBITS, COLUMN_NW_PROTO, COLUMN_TP_SRC,\n            COLUMN_TP_DST, COLUMN_WILDCARD_DPID, COLUMN_WILDCARD_IN_PORT,\n            COLUMN_WILDCARD_DL_SRC, COLUMN_WILDCARD_DL_DST,\n            COLUMN_WILDCARD_DL_TYPE, COLUMN_WILDCARD_NW_SRC,\n            COLUMN_WILDCARD_NW_DST, COLUMN_WILDCARD_NW_PROTO, COLUMN_PRIORITY,\n            COLUMN_ACTION };", "modifier": "public static", "type": "String", "declarator": "ColumnNames[] = { COLUMN_RULEID, COLUMN_DPID,\n            COLUMN_IN_PORT, COLUMN_DL_SRC, COLUMN_DL_DST, COLUMN_DL_TYPE,\n            COLUMN_NW_SRC_PREFIX, COLUMN_NW_SRC_MASKBITS, COLUMN_NW_DST_PREFIX,\n            COLUMN_NW_DST_MASKBITS, COLUMN_NW_PROTO, COLUMN_TP_SRC,\n            COLUMN_TP_DST, COLUMN_WILDCARD_DPID, COLUMN_WILDCARD_IN_PORT,\n            COLUMN_WILDCARD_DL_SRC, COLUMN_WILDCARD_DL_DST,\n            COLUMN_WILDCARD_DL_TYPE, COLUMN_WILDCARD_NW_SRC,\n            COLUMN_WILDCARD_NW_DST, COLUMN_WILDCARD_NW_PROTO, COLUMN_PRIORITY,\n            COLUMN_ACTION }", "var_name": "ColumnNames"}], "methods": [{"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getName()", "full_signature": "@Override public String getName()", "class_method_signature": "Firewall.getName()", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPrereq", "parameters": "(OFType type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPrereq(OFType type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPrereq(OFType type, String name)", "class_method_signature": "Firewall.isCallbackOrderingPrereq(OFType type, String name)", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPostreq", "parameters": "(OFType type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPostreq(OFType type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPostreq(OFType type, String name)", "class_method_signature": "Firewall.isCallbackOrderingPostreq(OFType type, String name)", "testcase": false, "constructor": false}, {"identifier": "getModuleServices", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleServices()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleServices()", "class_method_signature": "Firewall.getModuleServices()", "testcase": false, "constructor": false}, {"identifier": "getServiceImpls", "parameters": "()", "modifiers": "@Override public", "return": "Map<Class<? extends IFloodlightService>, IFloodlightService>", "signature": "Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "full_signature": "@Override public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "class_method_signature": "Firewall.getServiceImpls()", "testcase": false, "constructor": false}, {"identifier": "getModuleDependencies", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "class_method_signature": "Firewall.getModuleDependencies()", "testcase": false, "constructor": false}, {"identifier": "readRulesFromStorage", "parameters": "()", "modifiers": "protected", "return": "ArrayList<FirewallRule>", "signature": "ArrayList<FirewallRule> readRulesFromStorage()", "full_signature": "protected ArrayList<FirewallRule> readRulesFromStorage()", "class_method_signature": "Firewall.readRulesFromStorage()", "testcase": false, "constructor": false}, {"identifier": "init", "parameters": "(FloodlightModuleContext context)", "modifiers": "@Override public", "return": "void", "signature": "void init(FloodlightModuleContext context)", "full_signature": "@Override public void init(FloodlightModuleContext context)", "class_method_signature": "Firewall.init(FloodlightModuleContext context)", "testcase": false, "constructor": false}, {"identifier": "startUp", "parameters": "(FloodlightModuleContext context)", "modifiers": "@Override public", "return": "void", "signature": "void startUp(FloodlightModuleContext context)", "full_signature": "@Override public void startUp(FloodlightModuleContext context)", "class_method_signature": "Firewall.startUp(FloodlightModuleContext context)", "testcase": false, "constructor": false}, {"identifier": "receive", "parameters": "(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "modifiers": "@Override public", "return": "Command", "signature": "Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "full_signature": "@Override public Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "class_method_signature": "Firewall.receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx)", "testcase": false, "constructor": false}, {"identifier": "enableFirewall", "parameters": "(boolean enabled)", "modifiers": "@Override public", "return": "void", "signature": "void enableFirewall(boolean enabled)", "full_signature": "@Override public void enableFirewall(boolean enabled)", "class_method_signature": "Firewall.enableFirewall(boolean enabled)", "testcase": false, "constructor": false}, {"identifier": "getRules", "parameters": "()", "modifiers": "@Override public", "return": "List<FirewallRule>", "signature": "List<FirewallRule> getRules()", "full_signature": "@Override public List<FirewallRule> getRules()", "class_method_signature": "Firewall.getRules()", "testcase": false, "constructor": false}, {"identifier": "getStorageRules", "parameters": "()", "modifiers": "@Override public", "return": "List<Map<String, Object>>", "signature": "List<Map<String, Object>> getStorageRules()", "full_signature": "@Override public List<Map<String, Object>> getStorageRules()", "class_method_signature": "Firewall.getStorageRules()", "testcase": false, "constructor": false}, {"identifier": "getSubnetMask", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getSubnetMask()", "full_signature": "@Override public String getSubnetMask()", "class_method_signature": "Firewall.getSubnetMask()", "testcase": false, "constructor": false}, {"identifier": "setSubnetMask", "parameters": "(String newMask)", "modifiers": "@Override public", "return": "void", "signature": "void setSubnetMask(String newMask)", "full_signature": "@Override public void setSubnetMask(String newMask)", "class_method_signature": "Firewall.setSubnetMask(String newMask)", "testcase": false, "constructor": false}, {"identifier": "addRule", "parameters": "(FirewallRule rule)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void addRule(FirewallRule rule)", "full_signature": "@Override public synchronized void addRule(FirewallRule rule)", "class_method_signature": "Firewall.addRule(FirewallRule rule)", "testcase": false, "constructor": false}, {"identifier": "deleteRule", "parameters": "(int ruleid)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void deleteRule(int ruleid)", "full_signature": "@Override public synchronized void deleteRule(int ruleid)", "class_method_signature": "Firewall.deleteRule(int ruleid)", "testcase": false, "constructor": false}, {"identifier": "matchWithRule", "parameters": "(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "modifiers": "protected", "return": "RuleMatchPair", "signature": "RuleMatchPair matchWithRule(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "full_signature": "protected RuleMatchPair matchWithRule(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "class_method_signature": "Firewall.matchWithRule(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx)", "testcase": false, "constructor": false}, {"identifier": "isIPBroadcast", "parameters": "(IPv4Address ip)", "modifiers": "protected", "return": "boolean", "signature": "boolean isIPBroadcast(IPv4Address ip)", "full_signature": "protected boolean isIPBroadcast(IPv4Address ip)", "class_method_signature": "Firewall.isIPBroadcast(IPv4Address ip)", "testcase": false, "constructor": false}, {"identifier": "processPacketInMessage", "parameters": "(IOFSwitch sw, OFPacketIn pi, IRoutingDecision decision, FloodlightContext cntx)", "modifiers": "public", "return": "Command", "signature": "Command processPacketInMessage(IOFSwitch sw, OFPacketIn pi, IRoutingDecision decision, FloodlightContext cntx)", "full_signature": "public Command processPacketInMessage(IOFSwitch sw, OFPacketIn pi, IRoutingDecision decision, FloodlightContext cntx)", "class_method_signature": "Firewall.processPacketInMessage(IOFSwitch sw, OFPacketIn pi, IRoutingDecision decision, FloodlightContext cntx)", "testcase": false, "constructor": false}, {"identifier": "isEnabled", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isEnabled()", "full_signature": "@Override public boolean isEnabled()", "class_method_signature": "Firewall.isEnabled()", "testcase": false, "constructor": false}], "file": "src/agents/apps/floodlight/floodlight-1.0/src/main/java/net/floodlightcontroller/firewall/Firewall.java"}, "focal_method": {"identifier": "readRulesFromStorage", "parameters": "()", "modifiers": "protected", "return": "ArrayList<FirewallRule>", "body": "protected ArrayList<FirewallRule> readRulesFromStorage() {\n        ArrayList<FirewallRule> l = new ArrayList<FirewallRule>();\n\n        try {\n            Map<String, Object> row;\n\n            // (..., null, null) for no predicate, no ordering\n            IResultSet resultSet = storageSource.executeQuery(TABLE_NAME, ColumnNames, null, null);\n\n            // put retrieved rows into FirewallRules\n            for (Iterator<IResultSet> it = resultSet.iterator(); it.hasNext();) {\n                row = it.next().getRow();\n                // now, parse row\n                FirewallRule r = new FirewallRule();\n                if (!row.containsKey(COLUMN_RULEID) || !row.containsKey(COLUMN_DPID)) {\n                    logger.error( \"skipping entry with missing required 'ruleid' or 'switchid' entry: {}\", row);\n                    return l;\n                }\n                try {\n                    r.ruleid = Integer\n                            .parseInt((String) row.get(COLUMN_RULEID));\n                    r.dpid = DatapathId.of((String) row.get(COLUMN_DPID));\n\n                    for (String key : row.keySet()) {\n                        if (row.get(key) == null) {\n                            continue;\n                        }\n                        if (key.equals(COLUMN_RULEID) || key.equals(COLUMN_DPID) || key.equals(\"id\")) {\n                            continue; // already handled\n                        } else if (key.equals(COLUMN_IN_PORT)) {\n                            r.in_port = OFPort.of(Integer.parseInt((String) row.get(COLUMN_IN_PORT)));\n                        } else if (key.equals(COLUMN_DL_SRC)) {\n                            r.dl_src = MacAddress.of(Long.parseLong((String) row.get(COLUMN_DL_SRC)));\n                        }  else if (key.equals(COLUMN_DL_DST)) {\n                            r.dl_dst = MacAddress.of(Long.parseLong((String) row.get(COLUMN_DL_DST)));\n                        } else if (key.equals(COLUMN_DL_TYPE)) {\n                            r.dl_type = EthType.of(Integer.parseInt((String) row.get(COLUMN_DL_TYPE)));\n                        } else if (key.equals(COLUMN_NW_SRC_PREFIX)) {\n                            r.nw_src_prefix_and_mask = IPv4AddressWithMask.of(IPv4Address.of(Integer.parseInt((String) row.get(COLUMN_NW_SRC_PREFIX))), r.nw_src_prefix_and_mask.getMask());\n                        } else if (key.equals(COLUMN_NW_SRC_MASKBITS)) {\n                            r.nw_src_prefix_and_mask = IPv4AddressWithMask.of(r.nw_src_prefix_and_mask.getValue(), IPv4Address.of(Integer.parseInt((String) row.get(COLUMN_NW_SRC_MASKBITS))));\n                        } else if (key.equals(COLUMN_NW_DST_PREFIX)) {\n                            r.nw_dst_prefix_and_mask = IPv4AddressWithMask.of(IPv4Address.of(Integer.parseInt((String) row.get(COLUMN_NW_DST_PREFIX))), r.nw_dst_prefix_and_mask.getMask());\n                        } else if (key.equals(COLUMN_NW_DST_MASKBITS)) {\n                            r.nw_dst_prefix_and_mask = IPv4AddressWithMask.of(r.nw_dst_prefix_and_mask.getValue(), IPv4Address.of(Integer.parseInt((String) row.get(COLUMN_NW_DST_MASKBITS))));\n                        } else if (key.equals(COLUMN_NW_PROTO)) {\n                            r.nw_proto = IpProtocol.of(Short.parseShort((String) row.get(COLUMN_NW_PROTO)));\n                        } else if (key.equals(COLUMN_TP_SRC)) {\n                            r.tp_src = TransportPort.of(Integer.parseInt((String) row.get(COLUMN_TP_SRC)));\n                        } else if (key.equals(COLUMN_TP_DST)) {\n                            r.tp_dst = TransportPort.of(Integer.parseInt((String) row.get(COLUMN_TP_DST)));\n                        } else if (key.equals(COLUMN_WILDCARD_DPID)) {\n                            r.any_dpid = Boolean.parseBoolean((String) row.get(COLUMN_WILDCARD_DPID));\n                        } else if (key.equals(COLUMN_WILDCARD_IN_PORT)) {\n                            r.any_in_port = Boolean.parseBoolean((String) row.get(COLUMN_WILDCARD_IN_PORT));\n                        } else if (key.equals(COLUMN_WILDCARD_DL_SRC)) {\n                            r.any_dl_src = Boolean.parseBoolean((String) row.get(COLUMN_WILDCARD_DL_SRC));\n                        } else if (key.equals(COLUMN_WILDCARD_DL_DST)) {\n                            r.any_dl_dst = Boolean.parseBoolean((String) row.get(COLUMN_WILDCARD_DL_DST));\n                        } else if (key.equals(COLUMN_WILDCARD_DL_TYPE)) {\n                            r.any_dl_type = Boolean.parseBoolean((String) row.get(COLUMN_WILDCARD_DL_TYPE));\n                        } else if (key.equals(COLUMN_WILDCARD_NW_SRC)) {\n                            r.any_nw_src = Boolean.parseBoolean((String) row.get(COLUMN_WILDCARD_NW_SRC));\n                        } else if (key.equals(COLUMN_WILDCARD_NW_DST)) {\n                            r.any_nw_dst = Boolean.parseBoolean((String) row.get(COLUMN_WILDCARD_NW_DST));\n                        } else if (key.equals(COLUMN_WILDCARD_NW_PROTO)) {\n                            r.any_nw_proto = Boolean.parseBoolean((String) row.get(COLUMN_WILDCARD_NW_PROTO));\n                        } else if (key.equals(COLUMN_PRIORITY)) {\n                            r.priority = Integer.parseInt((String) row.get(COLUMN_PRIORITY));\n                        } else if (key.equals(COLUMN_ACTION)) {\n                            int tmp = Integer.parseInt((String) row.get(COLUMN_ACTION));\n                            if (tmp == FirewallRule.FirewallAction.DROP.ordinal()) {\n                                r.action = FirewallRule.FirewallAction.DROP;\n                            } else if (tmp == FirewallRule.FirewallAction.ALLOW.ordinal()) {\n                                r.action = FirewallRule.FirewallAction.ALLOW;\n                            } else {\n                                r.action = null;\n                                logger.error(\"action not recognized\");\n                            }\n                        }\n                    }\n                } catch (ClassCastException e) {\n                    logger.error(\"skipping rule {} with bad data : \" + e.getMessage(), r.ruleid);\n                }\n                if (r.action != null) {\n                    l.add(r);\n                }\n            }\n        } catch (StorageException e) {\n            logger.error(\"failed to access storage: {}\", e.getMessage());\n            // if the table doesn't exist, then wait to populate later via\n            // setStorageSource()\n        }\n\n        // now, sort the list based on priorities\n        Collections.sort(l);\n\n        return l;\n    }", "signature": "ArrayList<FirewallRule> readRulesFromStorage()", "full_signature": "protected ArrayList<FirewallRule> readRulesFromStorage()", "class_method_signature": "Firewall.readRulesFromStorage()", "testcase": false, "constructor": false, "invocations": ["executeQuery", "iterator", "hasNext", "getRow", "next", "containsKey", "containsKey", "error", "parseInt", "get", "of", "get", "keySet", "get", "equals", "equals", "equals", "equals", "of", "parseInt", "get", "equals", "of", "parseLong", "get", "equals", "of", "parseLong", "get", "equals", "of", "parseInt", "get", "equals", "of", "of", "parseInt", "get", "getMask", "equals", "of", "getValue", "of", "parseInt", "get", "equals", "of", "of", "parseInt", "get", "getMask", "equals", "of", "getValue", "of", "parseInt", "get", "equals", "of", "parseShort", "get", "equals", "of", "parseInt", "get", "equals", "of", "parseInt", "get", "equals", "parseBoolean", "get", "equals", "parseBoolean", "get", "equals", "parseBoolean", "get", "equals", "parseBoolean", "get", "equals", "parseBoolean", "get", "equals", "parseBoolean", "get", "equals", "parseBoolean", "get", "equals", "parseBoolean", "get", "equals", "parseInt", "get", "equals", "parseInt", "get", "ordinal", "ordinal", "error", "error", "getMessage", "add", "error", "getMessage", "sort"]}, "repository": {"repo_id": 181421086, "url": "https://github.com/seungsoo-lee/DELTA", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 35, "size": 99244, "license": "licensed"}}