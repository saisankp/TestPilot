{"test_class": {"identifier": "OsmNogoPolygonTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final int OFFSET_X = 11000000;", "modifier": "static final", "type": "int", "declarator": "OFFSET_X = 11000000", "var_name": "OFFSET_X"}, {"original_string": "static final int OFFSET_Y = 50000000;", "modifier": "static final", "type": "int", "declarator": "OFFSET_Y = 50000000", "var_name": "OFFSET_Y"}, {"original_string": "static OsmNogoPolygon polygon;", "modifier": "static", "type": "OsmNogoPolygon", "declarator": "polygon", "var_name": "polygon"}, {"original_string": "static OsmNogoPolygon polyline;", "modifier": "static", "type": "OsmNogoPolygon", "declarator": "polyline", "var_name": "polyline"}, {"original_string": "static final double[] lons = {  1.0,  1.0,  0.5, 0.5, 1.0, 1.0, -1.1, -1.0 };", "modifier": "static final", "type": "double[]", "declarator": "lons = {  1.0,  1.0,  0.5, 0.5, 1.0, 1.0, -1.1, -1.0 }", "var_name": "lons"}, {"original_string": "static final double[] lats = { -1.0, -0.1, -0.1, 0.1, 0.1, 1.0,  1.1, -1.0 };", "modifier": "static final", "type": "double[]", "declarator": "lats = { -1.0, -0.1, -0.1, 0.1, 0.1, 1.0,  1.1, -1.0 }", "var_name": "lats"}], "file": "brouter-core/src/test/java/btools/router/OsmNogoPolygonTest.java"}, "test_case": {"identifier": "testCalcBoundingCircle", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testCalcBoundingCircle() {\n    double[] lonlat2m = CheapRuler.getLonLatToMeterScales( polygon.ilat );\n    double dlon2m = lonlat2m[0];\n    double dlat2m = lonlat2m[1];\n\n    polygon.calcBoundingCircle();\n    double r = polygon.radius;\n    for (int i=0; i<lons.length; i++) {\n      double dpx = (toOsmLon(lons[i], OFFSET_X) - polygon.ilon) * dlon2m;\n      double dpy = (toOsmLat(lats[i], OFFSET_Y) - polygon.ilat) * dlat2m;\n      double r1 = Math.sqrt(dpx * dpx + dpy * dpy);\n      double diff = r-r1;\n      assertTrue(\"i: \"+i+\" r(\"+r+\") >= r1(\"+r1+\")\", diff >= 0);\n    }\n    polyline.calcBoundingCircle();\n    r = polyline.radius;\n    for (int i=0; i<lons.length; i++) {\n      double dpx = (toOsmLon(lons[i], OFFSET_X) - polyline.ilon) * dlon2m;\n      double dpy = (toOsmLat(lats[i], OFFSET_Y) - polyline.ilat) * dlat2m;\n      double r1 = Math.sqrt(dpx * dpx + dpy * dpy);\n      double diff = r-r1;\n      assertTrue(\"i: \"+i+\" r(\"+r+\") >= r1(\"+r1+\")\", diff >= 0);\n    }\n  }", "signature": "void testCalcBoundingCircle()", "full_signature": "@Test public void testCalcBoundingCircle()", "class_method_signature": "OsmNogoPolygonTest.testCalcBoundingCircle()", "testcase": true, "constructor": false, "invocations": ["getLonLatToMeterScales", "calcBoundingCircle", "toOsmLon", "toOsmLat", "sqrt", "assertTrue", "calcBoundingCircle", "toOsmLon", "toOsmLat", "sqrt", "assertTrue"]}, "focal_class": {"identifier": "OsmNogoPolygon", "superclass": "extends OsmNodeNamed", "interfaces": "", "fields": [{"original_string": "public final List<Point> points = new ArrayList<Point>();", "modifier": "public final", "type": "List<Point>", "declarator": "points = new ArrayList<Point>()", "var_name": "points"}, {"original_string": "public final boolean isClosed;", "modifier": "public final", "type": "boolean", "declarator": "isClosed", "var_name": "isClosed"}], "methods": [{"identifier": "OsmNogoPolygon", "parameters": "(boolean closed)", "modifiers": "public", "return": "", "signature": " OsmNogoPolygon(boolean closed)", "full_signature": "public  OsmNogoPolygon(boolean closed)", "class_method_signature": "OsmNogoPolygon.OsmNogoPolygon(boolean closed)", "testcase": false, "constructor": true}, {"identifier": "addVertex", "parameters": "(int lon, int lat)", "modifiers": "public final", "return": "void", "signature": "void addVertex(int lon, int lat)", "full_signature": "public final void addVertex(int lon, int lat)", "class_method_signature": "OsmNogoPolygon.addVertex(int lon, int lat)", "testcase": false, "constructor": false}, {"identifier": "calcBoundingCircle", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void calcBoundingCircle()", "full_signature": "public void calcBoundingCircle()", "class_method_signature": "OsmNogoPolygon.calcBoundingCircle()", "testcase": false, "constructor": false}, {"identifier": "intersects", "parameters": "(int lon0, int lat0, int lon1, int lat1)", "modifiers": "public", "return": "boolean", "signature": "boolean intersects(int lon0, int lat0, int lon1, int lat1)", "full_signature": "public boolean intersects(int lon0, int lat0, int lon1, int lat1)", "class_method_signature": "OsmNogoPolygon.intersects(int lon0, int lat0, int lon1, int lat1)", "testcase": false, "constructor": false}, {"identifier": "isOnPolyline", "parameters": "( long px, long py )", "modifiers": "public", "return": "boolean", "signature": "boolean isOnPolyline( long px, long py )", "full_signature": "public boolean isOnPolyline( long px, long py )", "class_method_signature": "OsmNogoPolygon.isOnPolyline( long px, long py )", "testcase": false, "constructor": false}, {"identifier": "isOnLine", "parameters": "( long px, long py, long p0x, long p0y, long p1x, long p1y )", "modifiers": "public static", "return": "boolean", "signature": "boolean isOnLine( long px, long py, long p0x, long p0y, long p1x, long p1y )", "full_signature": "public static boolean isOnLine( long px, long py, long p0x, long p0y, long p1x, long p1y )", "class_method_signature": "OsmNogoPolygon.isOnLine( long px, long py, long p0x, long p0y, long p1x, long p1y )", "testcase": false, "constructor": false}, {"identifier": "isWithin", "parameters": "(final long px, final long py)", "modifiers": "public", "return": "boolean", "signature": "boolean isWithin(final long px, final long py)", "full_signature": "public boolean isWithin(final long px, final long py)", "class_method_signature": "OsmNogoPolygon.isWithin(final long px, final long py)", "testcase": false, "constructor": false}, {"identifier": "distanceWithinPolygon", "parameters": "(int lon1, int lat1, int lon2, int lat2)", "modifiers": "public", "return": "double", "signature": "double distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "full_signature": "public double distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "class_method_signature": "OsmNogoPolygon.distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "testcase": false, "constructor": false}, {"identifier": "inSegment", "parameters": "( final Point p, final Point seg_p0, final Point seg_p1)", "modifiers": "private static", "return": "boolean", "signature": "boolean inSegment( final Point p, final Point seg_p0, final Point seg_p1)", "full_signature": "private static boolean inSegment( final Point p, final Point seg_p0, final Point seg_p1)", "class_method_signature": "OsmNogoPolygon.inSegment( final Point p, final Point seg_p0, final Point seg_p1)", "testcase": false, "constructor": false}, {"identifier": "intersect2D_2Segments", "parameters": "( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "modifiers": "private static", "return": "int", "signature": "int intersect2D_2Segments( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "full_signature": "private static int intersect2D_2Segments( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "class_method_signature": "OsmNogoPolygon.intersect2D_2Segments( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "testcase": false, "constructor": false}], "file": "brouter-core/src/main/java/btools/router/OsmNogoPolygon.java"}, "focal_method": {"identifier": "calcBoundingCircle", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void calcBoundingCircle()\n  {\n    int cxmin, cxmax, cymin, cymax;\n    cxmin = cymin = Integer.MAX_VALUE;\n    cxmax = cymax = Integer.MIN_VALUE;\n\n    // first calculate a starting center point as center of boundingbox\n    for (int i = 0; i < points.size(); i++)\n    {\n      final Point p = points.get(i);\n      if (p.x < cxmin)\n      {\n        cxmin = p.x;\n      }\n      if (p.x > cxmax)\n      {\n        cxmax = p.x;\n      }\n      if (p.y < cymin)\n      {\n        cymin = p.y;\n      }\n      if (p.y > cymax)\n      {\n        cymax = p.y;\n      }\n    }\n\n    int cx = (cxmax+cxmin) / 2; // center of circle\n    int cy = (cymax+cymin) / 2;\n\n    double[] lonlat2m = CheapRuler.getLonLatToMeterScales( cy );\n    double dlon2m = lonlat2m[0];\n    double dlat2m = lonlat2m[1];\n\n    double rad = 0;  // radius\n\n    double dmax = 0; // length of vector from center to point\n    int i_max = -1;\n\n    do\n    {\n      // now identify the point outside of the circle that has the greatest distance\n      for (int i = 0; i < points.size(); i++)\n      {\n        final Point p = points.get(i);\n        final double dist = CheapRuler.distance(p.x, p.y, (int) cx, (int) cy);\n        if (dist <= rad)\n        {\n          continue;\n        }\n        if (dist > dmax)\n        {\n          // new maximum distance found\n          dmax = dist;\n          i_max = i;\n        }\n      }\n      if (i_max < 0)\n      {\n    \t  break; // leave loop when no point outside the circle is found any more.\n      }\n      final double dd = 0.5 * (1 - rad / dmax);\n\n      final Point p = points.get(i_max); // calculate new radius to just include this point\n      cx += (int)(dd * (p.x - cx) + 0.5); // shift center toward point\n      cy += (int)(dd * (p.y - cy) + 0.5);\n\n      dmax = rad = CheapRuler.distance(p.x, p.y, (int) cx, (int) cy);\n      i_max = -1;\n    }\n    while (true);\n\n    ilon = cx;\n    ilat = cy;\n    radius = rad;\n    return;\n  }", "signature": "void calcBoundingCircle()", "full_signature": "public void calcBoundingCircle()", "class_method_signature": "OsmNogoPolygon.calcBoundingCircle()", "testcase": false, "constructor": false, "invocations": ["size", "get", "getLonLatToMeterScales", "size", "get", "distance", "get", "distance"]}, "repository": {"repo_id": 15870646, "url": "https://github.com/abrensch/brouter", "language": "Java", "is_fork": false, "fork_count": 65, "stargazer_count": 172, "size": 3569, "license": "licensed"}}