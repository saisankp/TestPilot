{"test_class": {"identifier": "DecimalUtilTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(DecimalUtilTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(DecimalUtilTest.class)", "var_name": "logger"}], "file": "ch-commons-util/src/test/java/com/cloudhopper/commons/util/DecimalUtilTest.java"}, "test_case": {"identifier": "toStringWithPrecision", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void toStringWithPrecision() {\n        String result = null;\n        result = DecimalUtil.toString(0, 0);\n        Assert.assertEquals(\"0\", result);\n\n        result = DecimalUtil.toString(1.12, 0);\n        Assert.assertEquals(\"1\", result);\n\n        result = DecimalUtil.toString(1.1, 0);\n        Assert.assertEquals(\"1\", result);\n\n        result = DecimalUtil.toString(1.12, 1);\n        Assert.assertEquals(\"1.1\", result);\n\n        result = DecimalUtil.toString(1.12, 2);\n        Assert.assertEquals(\"1.12\", result);\n\n        result = DecimalUtil.toString(1.12, 3);\n        Assert.assertEquals(\"1.120\", result);\n\n        result = DecimalUtil.toString(1, 4);\n        Assert.assertEquals(\"1.0000\", result);\n\n        // this causes an Exponent to be used in string representation\n        double d0 = (double)1/(double)818393434343431121L;\n        result = DecimalUtil.toString(d0, 2);\n        Assert.assertEquals(\"0.00\", result);\n    }", "signature": "void toStringWithPrecision()", "full_signature": "@Test public void toStringWithPrecision()", "class_method_signature": "DecimalUtilTest.toStringWithPrecision()", "testcase": true, "constructor": false, "invocations": ["toString", "assertEquals", "toString", "assertEquals", "toString", "assertEquals", "toString", "assertEquals", "toString", "assertEquals", "toString", "assertEquals", "toString", "assertEquals", "toString", "assertEquals"]}, "focal_class": {"identifier": "DecimalUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Logger logger = LoggerFactory.getLogger(DecimalUtil.class);", "modifier": "private static", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(DecimalUtil.class)", "var_name": "logger"}], "methods": [{"identifier": "toString", "parameters": "(double value, int precision)", "modifiers": "public static", "return": "String", "signature": "String toString(double value, int precision)", "full_signature": "public static String toString(double value, int precision)", "class_method_signature": "DecimalUtil.toString(double value, int precision)", "testcase": false, "constructor": false}], "file": "ch-commons-util/src/main/java/com/cloudhopper/commons/util/DecimalUtil.java"}, "focal_method": {"identifier": "toString", "parameters": "(double value, int precision)", "modifiers": "public static", "return": "String", "body": "public static String toString(double value, int precision) {\n        // create decimal format string\n        StringBuilder buf = new StringBuilder(\"0\");\n        if (precision > 0) {\n            buf.append(\".\");\n        }\n        for (int i = 0; i < precision; i++) {\n            buf.append(\"0\");\n        }\n        // create a decimal format\n        DecimalFormat format = new DecimalFormat(buf.toString());\n        return format.format(value);\n        \n        /**\n        String temp = Double.toString(value);\n        StringBuffer buf = new StringBuffer(temp.length()+precision);\n        buf.append(temp);\n        // find the '.' char\n        int pos = buf.indexOf(\".\");\n        // was the . found, if not, add it so we can use the same logic below\n        if (pos < 0) {\n            // if we want precision, add . and set the position correctly\n            if (precision > 0) {\n                buf.append('.');\n                pos = buf.length()-1;   // set pos to last char\n            } else {\n                return buf.toString();\n            }\n        }\n        // number of digits after\n        int digitsAfter = buf.length() - pos - 1;\n\n        // if precision is zero, then fake getting rid of the period by incrementing this\n        if (precision == 0)\n            digitsAfter++;\n\n        // do we need to add, delete, or keep it?\n        if (digitsAfter < precision) {\n            // add zeoes\n            int count = precision - digitsAfter;\n            for (int i = 0; i < count; i++) {\n                buf.append('0');\n            }\n        } else if (digitsAfter > precision) {\n            // trim digits\n            int count = digitsAfter - precision;\n            buf.delete(buf.length()-count, buf.length());\n        }\n        return buf.toString();\n         */\n    }", "signature": "String toString(double value, int precision)", "full_signature": "public static String toString(double value, int precision)", "class_method_signature": "DecimalUtil.toString(double value, int precision)", "testcase": false, "constructor": false, "invocations": ["append", "append", "toString", "format"]}, "repository": {"repo_id": 14960307, "url": "https://github.com/twitter/cloudhopper-commons", "language": "Java", "is_fork": false, "fork_count": 40, "stargazer_count": 36, "size": 6452, "license": "licensed"}}