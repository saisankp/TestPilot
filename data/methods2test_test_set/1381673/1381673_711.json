{"test_class": {"identifier": "FEELParserTest", "superclass": "", "interfaces": "", "fields": [], "file": "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/parser/feel11/FEELParserTest.java"}, "test_case": {"identifier": "testContextWithMultipleEntries", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testContextWithMultipleEntries() {\n        String inputExpression = \"{ \\\"a string key\\\" : 10,\"\n                       + \" a non-string key : foo+bar,\"\n                       + \" a key.with + /' odd chars : [10..50] }\";\n        BaseNode ctxbase = parse( inputExpression, mapOf(entry(\"foo\", BuiltInType.NUMBER), entry(\"bar\", BuiltInType.NUMBER)) );\n\n        assertThat( ctxbase, is( instanceOf( ContextNode.class ) ) );\n        assertThat( ctxbase.getText(), is( inputExpression ) );\n\n        ContextNode ctx = (ContextNode) ctxbase;\n        assertThat( ctx.getEntries().size(), is( 3 ) );\n\n        ContextEntryNode entry = ctx.getEntries().get( 0 );\n        assertThat(entry.getName(), is(instanceOf(StringNode.class)));\n        StringNode nameNode = (StringNode) entry.getName();\n        assertThat(nameNode.getText(), is(notNullValue()));\n        assertThat(nameNode.getText(), is(\"\\\"a string key\\\"\")); // Reference String literal test, BaseNode#getText() return the FEEL equivalent expression, in this case quoted.\n        assertThat( entry.getValue(), is( instanceOf( NumberNode.class ) ) );\n        assertThat( entry.getResultType(), is( BuiltInType.NUMBER ) );\n        assertThat( entry.getValue().getText(), is(\"10\") );\n\n        entry = ctx.getEntries().get( 1 );\n        assertThat( entry.getName(), is( instanceOf( NameDefNode.class ) ) );\n        NameDefNode name = (NameDefNode) entry.getName();\n        assertThat( name.getParts(), is( notNullValue() ) );\n        assertThat( name.getParts().size(), is( 5 ) );\n        assertThat( entry.getName().getText(), is(\"a non-string key\") );\n        assertThat( entry.getValue(), is( instanceOf( InfixOpNode.class ) ) );\n        assertThat( entry.getResultType(), is( BuiltInType.NUMBER ) );\n        assertThat( entry.getValue().getText(), is( \"foo+bar\" ) );\n\n        entry = ctx.getEntries().get( 2 );\n        assertThat( entry.getName(), is( instanceOf( NameDefNode.class ) ) );\n        name = (NameDefNode) entry.getName();\n        assertThat( name.getParts(), is( notNullValue() ) );\n        assertThat( name.getParts().size(), is( 9 ) );\n        assertThat( entry.getName().getText(), is(\"a key.with + /' odd chars\") );\n        assertThat( entry.getValue(), is( instanceOf( RangeNode.class ) ) );\n        assertThat( entry.getResultType(), is( BuiltInType.RANGE ) );\n        assertThat( entry.getValue().getText(), is( \"[10..50]\" ) );\n    }", "signature": "void testContextWithMultipleEntries()", "full_signature": "@Test public void testContextWithMultipleEntries()", "class_method_signature": "FEELParserTest.testContextWithMultipleEntries()", "testcase": true, "constructor": false, "invocations": ["parse", "mapOf", "entry", "entry", "assertThat", "is", "instanceOf", "assertThat", "getText", "is", "assertThat", "size", "getEntries", "is", "get", "getEntries", "assertThat", "getName", "is", "instanceOf", "getName", "assertThat", "getText", "is", "notNullValue", "assertThat", "getText", "is", "assertThat", "getValue", "is", "instanceOf", "assertThat", "getResultType", "is", "assertThat", "getText", "getValue", "is", "get", "getEntries", "assertThat", "getName", "is", "instanceOf", "getName", "assertThat", "getParts", "is", "notNullValue", "assertThat", "size", "getParts", "is", "assertThat", "getText", "getName", "is", "assertThat", "getValue", "is", "instanceOf", "assertThat", "getResultType", "is", "assertThat", "getText", "getValue", "is", "get", "getEntries", "assertThat", "getName", "is", "instanceOf", "getName", "assertThat", "getParts", "is", "notNullValue", "assertThat", "size", "getParts", "is", "assertThat", "getText", "getName", "is", "assertThat", "getValue", "is", "instanceOf", "assertThat", "getResultType", "is", "assertThat", "getText", "getValue", "is"]}, "focal_class": {"identifier": "FEELParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final List<String> REUSABLE_KEYWORDS = Arrays.asList(\n            \"for\", \"return\", \"if\", \"then\", \"else\", \"some\", \"every\", \"satisfies\", \"instance\", \"of\",\n            \"function\", \"external\", \"or\", \"and\", \"between\", \"not\", \"null\", \"true\", \"false\"\n    );", "modifier": "private static final", "type": "List<String>", "declarator": "REUSABLE_KEYWORDS = Arrays.asList(\n            \"for\", \"return\", \"if\", \"then\", \"else\", \"some\", \"every\", \"satisfies\", \"instance\", \"of\",\n            \"function\", \"external\", \"or\", \"and\", \"between\", \"not\", \"null\", \"true\", \"false\"\n    )", "var_name": "REUSABLE_KEYWORDS"}, {"original_string": "private static final Pattern DIGITS_PATTERN = Pattern.compile( \"[0-9]*\" );", "modifier": "private static final", "type": "Pattern", "declarator": "DIGITS_PATTERN = Pattern.compile( \"[0-9]*\" )", "var_name": "DIGITS_PATTERN"}], "methods": [{"identifier": "parse", "parameters": "(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "modifiers": "public static", "return": "FEEL_1_1Parser", "signature": "FEEL_1_1Parser parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "full_signature": "public static FEEL_1_1Parser parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "class_method_signature": "FEELParser.parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "testcase": false, "constructor": false}, {"identifier": "isVariableNamePartValid", "parameters": "( String namePart, Scope scope )", "modifiers": "public static", "return": "boolean", "signature": "boolean isVariableNamePartValid( String namePart, Scope scope )", "full_signature": "public static boolean isVariableNamePartValid( String namePart, Scope scope )", "class_method_signature": "FEELParser.isVariableNamePartValid( String namePart, Scope scope )", "testcase": false, "constructor": false}, {"identifier": "isVariableNameValid", "parameters": "( String source )", "modifiers": "public static", "return": "boolean", "signature": "boolean isVariableNameValid( String source )", "full_signature": "public static boolean isVariableNameValid( String source )", "class_method_signature": "FEELParser.isVariableNameValid( String source )", "testcase": false, "constructor": false}, {"identifier": "checkVariableName", "parameters": "( String source )", "modifiers": "public static", "return": "List<FEELEvent>", "signature": "List<FEELEvent> checkVariableName( String source )", "full_signature": "public static List<FEELEvent> checkVariableName( String source )", "class_method_signature": "FEELParser.checkVariableName( String source )", "testcase": false, "constructor": false}, {"identifier": "defineVariables", "parameters": "(Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, FEEL_1_1Parser parser)", "modifiers": "public static", "return": "void", "signature": "void defineVariables(Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, FEEL_1_1Parser parser)", "full_signature": "public static void defineVariables(Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, FEEL_1_1Parser parser)", "class_method_signature": "FEELParser.defineVariables(Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, FEEL_1_1Parser parser)", "testcase": false, "constructor": false}, {"identifier": "toList", "parameters": "(IntervalSet intervals, Vocabulary vocabulary)", "modifiers": "private static", "return": "List<String>", "signature": "List<String> toList(IntervalSet intervals, Vocabulary vocabulary)", "full_signature": "private static List<String> toList(IntervalSet intervals, Vocabulary vocabulary)", "class_method_signature": "FEELParser.toList(IntervalSet intervals, Vocabulary vocabulary)", "testcase": false, "constructor": false}, {"identifier": "elementName", "parameters": "(Vocabulary vocabulary, int a)", "modifiers": "private static", "return": "String", "signature": "String elementName(Vocabulary vocabulary, int a)", "full_signature": "private static String elementName(Vocabulary vocabulary, int a)", "class_method_signature": "FEELParser.elementName(Vocabulary vocabulary, int a)", "testcase": false, "constructor": false}, {"identifier": "generateInvalidVariableError", "parameters": "(Object offendingSymbol, int line, int charPositionInLine, RecognitionException e, CommonToken token)", "modifiers": "private static", "return": "SyntaxErrorEvent", "signature": "SyntaxErrorEvent generateInvalidVariableError(Object offendingSymbol, int line, int charPositionInLine, RecognitionException e, CommonToken token)", "full_signature": "private static SyntaxErrorEvent generateInvalidVariableError(Object offendingSymbol, int line, int charPositionInLine, RecognitionException e, CommonToken token)", "class_method_signature": "FEELParser.generateInvalidVariableError(Object offendingSymbol, int line, int charPositionInLine, RecognitionException e, CommonToken token)", "testcase": false, "constructor": false}], "file": "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/parser/feel11/FEELParser.java"}, "focal_method": {"identifier": "parse", "parameters": "(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "modifiers": "public static", "return": "FEEL_1_1Parser", "body": "public static FEEL_1_1Parser parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry) {\n        CharStream input = CharStreams.fromString(source);\n        FEEL_1_1Lexer lexer = new FEEL_1_1Lexer( input );\n        CommonTokenStream tokens = new CommonTokenStream( lexer );\n        FEEL_1_1Parser parser = new FEEL_1_1Parser( tokens );\n\n        ParserHelper parserHelper = new ParserHelper(eventsManager);\n        additionalFunctions.forEach(f -> parserHelper.getSymbolTable().getBuiltInScope().define(f.getSymbol()));\n        parser.setHelper(parserHelper);\n        parser.setErrorHandler( new FEELErrorHandler() );\n        parser.removeErrorListeners(); // removes the error listener that prints to the console\n        parser.addErrorListener( new FEELParserErrorListener( eventsManager ) );\n\n        // pre-loads the parser with symbols\n        defineVariables( inputVariableTypes, inputVariables, parser );\n        \n        if (typeRegistry != null) {\n            parserHelper.setTypeRegistry(typeRegistry);\n        }\n\n        return parser;\n    }", "signature": "FEEL_1_1Parser parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "full_signature": "public static FEEL_1_1Parser parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "class_method_signature": "FEELParser.parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "testcase": false, "constructor": false, "invocations": ["fromString", "forEach", "define", "getBuiltInScope", "getSymbolTable", "getSymbol", "setHelper", "setErrorHandler", "removeErrorListeners", "addErrorListener", "defineVariables", "setTypeRegistry"]}, "repository": {"repo_id": 1381673, "url": "https://github.com/kiegroup/drools", "stars": 2733, "created": "2/18/2011 8:37:05 AM +00:00", "updates": "2020-01-27T13:12:15+00:00", "fork": "False", "license": "licensed"}}