{"test_class": {"identifier": "PartitionWorkerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final byte[] SERIALIZED_JOB_DATA = {0, 0, 0, 0};", "modifier": "private static final", "type": "byte[]", "declarator": "SERIALIZED_JOB_DATA = {0, 0, 0, 0}", "var_name": "SERIALIZED_JOB_DATA"}, {"original_string": "@Mock private AsyncSqsClient asyncClient;", "modifier": "@Mock private", "type": "AsyncSqsClient", "declarator": "asyncClient", "var_name": "asyncClient"}, {"original_string": "private TokenManager tokenManager;", "modifier": "private", "type": "TokenManager", "declarator": "tokenManager", "var_name": "tokenManager"}, {"original_string": "private Clock clock;", "modifier": "private", "type": "Clock", "declarator": "clock", "var_name": "clock"}, {"original_string": "private JobSpecTransformer transformer;", "modifier": "private", "type": "JobSpecTransformer", "declarator": "transformer", "var_name": "transformer"}, {"original_string": "private PartitionWorker worker;", "modifier": "private", "type": "PartitionWorker", "declarator": "worker", "var_name": "worker"}, {"original_string": "private String validToken;", "modifier": "private", "type": "String", "declarator": "validToken", "var_name": "validToken"}, {"original_string": "@Mock private ScheduleManager scheduleManager;", "modifier": "@Mock private", "type": "ScheduleManager", "declarator": "scheduleManager", "var_name": "scheduleManager"}], "file": "dynein/src/test/java/com/airbnb/dynein/scheduler/worker/PartitionWorkerTest.java"}, "test_case": {"identifier": "testDispatchOverdue_SetAcquiredPartialFailure", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testDispatchOverdue_SetAcquiredPartialFailure() throws Exception {\n    DyneinJobSpec jobSpec_1 = getTestJobSpec(validToken, \"test9\");\n    Schedule schedule_1 = getSchedule(jobSpec_1, false);\n    DyneinJobSpec jobSpec_2 = getTestJobSpec(validToken, \"test9\");\n    Schedule schedule_2 = getSchedule(jobSpec_2, true);\n\n    String partition = \"failure2\";\n    CompletableFuture<Schedule> updateResponse = new CompletableFuture<>();\n    updateResponse.completeExceptionally(new Exception());\n\n    when(scheduleManager.getOverdueJobs(partition))\n        .thenReturn(\n            CompletableFuture.completedFuture(\n                SchedulesQueryResponse.of(asList(schedule_1, schedule_2), false)));\n    when(scheduleManager.updateStatus(schedule_2, JobStatus.SCHEDULED, JobStatus.ACQUIRED))\n        .thenReturn(updateResponse);\n    when(asyncClient.add(schedule_1.getJobSpec(), \"test9\"))\n        .thenReturn(CompletableFuture.completedFuture(null));\n\n    CompletableFuture<Boolean> ret = worker.dispatchOverdue(\"failure2\");\n\n    ret.get(1000, TimeUnit.MILLISECONDS);\n\n    verify(scheduleManager, times(1)).getOverdueJobs(partition);\n    verify(scheduleManager, times(1))\n        .updateStatus(schedule_1, JobStatus.SCHEDULED, JobStatus.ACQUIRED);\n    verify(scheduleManager, times(1))\n        .updateStatus(schedule_2, JobStatus.SCHEDULED, JobStatus.ACQUIRED);\n    verify(asyncClient, times(1)).add(schedule_1.getJobSpec(), \"test9\");\n    verify(scheduleManager, times(1))\n        .deleteDispatchedJob(schedule_1.withStatus(JobStatus.ACQUIRED));\n    verifyNoMoreInteractions(scheduleManager, asyncClient);\n  }", "signature": "void testDispatchOverdue_SetAcquiredPartialFailure()", "full_signature": "@Test public void testDispatchOverdue_SetAcquiredPartialFailure()", "class_method_signature": "PartitionWorkerTest.testDispatchOverdue_SetAcquiredPartialFailure()", "testcase": true, "constructor": false, "invocations": ["getTestJobSpec", "getSchedule", "getTestJobSpec", "getSchedule", "completeExceptionally", "thenReturn", "when", "getOverdueJobs", "completedFuture", "of", "asList", "thenReturn", "when", "updateStatus", "thenReturn", "when", "add", "getJobSpec", "completedFuture", "dispatchOverdue", "get", "getOverdueJobs", "verify", "times", "updateStatus", "verify", "times", "updateStatus", "verify", "times", "add", "verify", "times", "getJobSpec", "deleteDispatchedJob", "verify", "times", "withStatus", "verifyNoMoreInteractions"]}, "focal_class": {"identifier": "PartitionWorker", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final long EXECUTOR_TIMEOUT_SECONDS = 5;", "modifier": "private static final", "type": "long", "declarator": "EXECUTOR_TIMEOUT_SECONDS = 5", "var_name": "EXECUTOR_TIMEOUT_SECONDS"}, {"original_string": "private final int index;", "modifier": "private final", "type": "int", "declarator": "index", "var_name": "index"}, {"original_string": "@Named(Constants.SQS_PRODUCER)\n  private final AsyncSqsClient asyncSqsClient;", "modifier": "@Named(Constants.SQS_PRODUCER)\n  private final", "type": "AsyncSqsClient", "declarator": "asyncSqsClient", "var_name": "asyncSqsClient"}, {"original_string": "private final EventBus eventBus;", "modifier": "private final", "type": "EventBus", "declarator": "eventBus", "var_name": "eventBus"}, {"original_string": "private final Clock clock;", "modifier": "private final", "type": "Clock", "declarator": "clock", "var_name": "clock"}, {"original_string": "private final ScheduleManager scheduleManager;", "modifier": "private final", "type": "ScheduleManager", "declarator": "scheduleManager", "var_name": "scheduleManager"}, {"original_string": "private final JobSpecTransformer jobSpecTransformer;", "modifier": "private final", "type": "JobSpecTransformer", "declarator": "jobSpecTransformer", "var_name": "jobSpecTransformer"}, {"original_string": "private final WorkersConfiguration workersConfiguration;", "modifier": "private final", "type": "WorkersConfiguration", "declarator": "workersConfiguration", "var_name": "workersConfiguration"}, {"original_string": "private final Metrics metrics;", "modifier": "private final", "type": "Metrics", "declarator": "metrics", "var_name": "metrics"}, {"original_string": "private ScheduledExecutorService executorService = null;", "modifier": "private", "type": "ScheduledExecutorService", "declarator": "executorService = null", "var_name": "executorService"}, {"original_string": "private ConcurrentHashMap<Integer, Long> scanTimes = null;", "modifier": "private", "type": "ConcurrentHashMap<Integer, Long>", "declarator": "scanTimes = null", "var_name": "scanTimes"}], "methods": [{"identifier": "dispatchToDestination", "parameters": "(Schedule schedule)", "modifiers": "", "return": "CompletableFuture<Void>", "signature": "CompletableFuture<Void> dispatchToDestination(Schedule schedule)", "full_signature": " CompletableFuture<Void> dispatchToDestination(Schedule schedule)", "class_method_signature": "PartitionWorker.dispatchToDestination(Schedule schedule)", "testcase": false, "constructor": false}, {"identifier": "dispatchOverdue", "parameters": "(String partition)", "modifiers": "", "return": "CompletableFuture<Boolean>", "signature": "CompletableFuture<Boolean> dispatchOverdue(String partition)", "full_signature": " CompletableFuture<Boolean> dispatchOverdue(String partition)", "class_method_signature": "PartitionWorker.dispatchOverdue(String partition)", "testcase": false, "constructor": false}, {"identifier": "scanGroup", "parameters": "(List<Integer> partitions)", "modifiers": "private", "return": "void", "signature": "void scanGroup(List<Integer> partitions)", "full_signature": "private void scanGroup(List<Integer> partitions)", "class_method_signature": "PartitionWorker.scanGroup(List<Integer> partitions)", "testcase": false, "constructor": false}, {"identifier": "recoverStuckJobs", "parameters": "(List<Integer> partitions, long lookAheadMs)", "modifiers": "", "return": "CompletableFuture<Void>", "signature": "CompletableFuture<Void> recoverStuckJobs(List<Integer> partitions, long lookAheadMs)", "full_signature": " CompletableFuture<Void> recoverStuckJobs(List<Integer> partitions, long lookAheadMs)", "class_method_signature": "PartitionWorker.recoverStuckJobs(List<Integer> partitions, long lookAheadMs)", "testcase": false, "constructor": false}, {"identifier": "recoverStuckJobs", "parameters": "(List<Integer> partitions)", "modifiers": "", "return": "CompletableFuture<Void>", "signature": "CompletableFuture<Void> recoverStuckJobs(List<Integer> partitions)", "full_signature": " CompletableFuture<Void> recoverStuckJobs(List<Integer> partitions)", "class_method_signature": "PartitionWorker.recoverStuckJobs(List<Integer> partitions)", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "(List<Integer> partitions)", "modifiers": "", "return": "void", "signature": "void start(List<Integer> partitions)", "full_signature": " void start(List<Integer> partitions)", "class_method_signature": "PartitionWorker.start(List<Integer> partitions)", "testcase": false, "constructor": false}, {"identifier": "shutdownExecutor", "parameters": "()", "modifiers": "", "return": "void", "signature": "void shutdownExecutor()", "full_signature": " void shutdownExecutor()", "class_method_signature": "PartitionWorker.shutdownExecutor()", "testcase": false, "constructor": false}, {"identifier": "startExecutor", "parameters": "()", "modifiers": "", "return": "void", "signature": "void startExecutor()", "full_signature": " void startExecutor()", "class_method_signature": "PartitionWorker.startExecutor()", "testcase": false, "constructor": false}], "file": "dynein/src/main/java/com/airbnb/dynein/scheduler/worker/PartitionWorker.java"}, "focal_method": {"identifier": "dispatchOverdue", "parameters": "(String partition)", "modifiers": "", "return": "CompletableFuture<Boolean>", "body": "CompletableFuture<Boolean> dispatchOverdue(String partition) {\n    Stopwatch stopwatch = Stopwatch.createStarted();\n    CompletableFuture<Boolean> ret = new CompletableFuture<>();\n    scheduleManager\n        .getOverdueJobs(partition)\n        .whenCompleteAsync(\n            (res, ex) -> {\n              if (ex != null) {\n                log.error(\"Error querying overdue jobs for partition {}\", partition, ex);\n                metrics.queryOverdueError(ex, partition);\n                ret.complete(true);\n              } else {\n                metrics.queryOverdue(partition);\n                CompletableFuture.allOf(\n                        res.getSchedules()\n                            .stream()\n                            .map(\n                                schedule ->\n                                    scheduleManager\n                                        .updateStatus(\n                                            schedule,\n                                            Schedule.JobStatus.SCHEDULED,\n                                            Schedule.JobStatus.ACQUIRED)\n                                        .thenCompose(this::dispatchToDestination))\n                            .toArray(CompletableFuture[]::new))\n                    .whenCompleteAsync(\n                        (it, exception) -> {\n                          // explicitly don't handle any exceptions here because:\n                          // - acquire errors are harmless,\n                          //   either CAS exception or will be picked up by the next iteration\n                          // - dispatch errors are harmless,\n                          //   - dispatch to SQS failures will be set back to ACQUIRED\n                          //   - set back to ACQUIRED failures will be picked up by fix stuck jobs\n                          ret.complete(res.isShouldImmediatelyQueryAgain());\n                          long time = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n                          log.debug(\"Dispatched overdue jobs for partition {}\", partition);\n                          metrics.dispatchOverdue(time, partition);\n                        },\n                        executorService);\n              }\n            },\n            executorService);\n    return ret;\n  }", "signature": "CompletableFuture<Boolean> dispatchOverdue(String partition)", "full_signature": " CompletableFuture<Boolean> dispatchOverdue(String partition)", "class_method_signature": "PartitionWorker.dispatchOverdue(String partition)", "testcase": false, "constructor": false, "invocations": ["createStarted", "whenCompleteAsync", "getOverdueJobs", "error", "queryOverdueError", "complete", "queryOverdue", "whenCompleteAsync", "allOf", "toArray", "map", "stream", "getSchedules", "thenCompose", "updateStatus", "complete", "isShouldImmediatelyQueryAgain", "elapsed", "debug", "dispatchOverdue"]}, "repository": {"repo_id": 208320365, "url": "https://github.com/airbnb/dynein", "language": "Java", "is_fork": false, "fork_count": 9, "stargazer_count": 247, "size": 71, "license": "licensed"}}