{"test_class": {"identifier": "ComputationTaskInvokerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final long TASK_DELAY_MS = 30;", "modifier": "private static final", "type": "long", "declarator": "TASK_DELAY_MS = 30", "var_name": "TASK_DELAY_MS"}, {"original_string": "private final TestScheduler testScheduler = Schedulers.test();", "modifier": "private final", "type": "TestScheduler", "declarator": "testScheduler = Schedulers.test()", "var_name": "testScheduler"}, {"original_string": "private final AtomicInteger invocationCounter = new AtomicInteger();", "modifier": "private final", "type": "AtomicInteger", "declarator": "invocationCounter = new AtomicInteger()", "var_name": "invocationCounter"}, {"original_string": "private final ComputationTaskInvoker<String> invoker = new ComputationTaskInvoker<>(\n            Observable.timer(TASK_DELAY_MS, TimeUnit.MILLISECONDS, testScheduler).map(tick -> \"Done round \" + invocationCounter.getAndIncrement()), testScheduler\n    );", "modifier": "private final", "type": "ComputationTaskInvoker<String>", "declarator": "invoker = new ComputationTaskInvoker<>(\n            Observable.timer(TASK_DELAY_MS, TimeUnit.MILLISECONDS, testScheduler).map(tick -> \"Done round \" + invocationCounter.getAndIncrement()), testScheduler\n    )", "var_name": "invoker"}], "file": "titus-common/src/test/java/com/netflix/titus/common/util/rx/ComputationTaskInvokerTest.java"}, "test_case": {"identifier": "testContentedComputation", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testContentedComputation() throws Exception {\n        ExtTestSubscriber<String> testSubscriber1 = new ExtTestSubscriber<>();\n        ExtTestSubscriber<String> testSubscriber2 = new ExtTestSubscriber<>();\n        ExtTestSubscriber<String> testSubscriber3 = new ExtTestSubscriber<>();\n\n        invoker.recompute().subscribe(testSubscriber1);\n\n        // Advance time to start computation\n        testScheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);\n\n        // Now subscriber again. The new subscriptions should wait for their turn.\n        invoker.recompute().subscribe(testSubscriber2);\n        invoker.recompute().subscribe(testSubscriber3);\n\n        testScheduler.advanceTimeBy(TASK_DELAY_MS - 1, TimeUnit.MILLISECONDS);\n\n        assertThat(testSubscriber1.takeNext()).isEqualTo(\"Done round 0\");\n        assertThat(testSubscriber1.isUnsubscribed()).isTrue();\n\n        assertThat(testSubscriber2.takeNext()).isNull();\n        assertThat(testSubscriber3.takeNext()).isNull();\n\n        assertThat(invocationCounter.get()).isEqualTo(1);\n\n        // Now trigger next computation\n        testScheduler.advanceTimeBy(TASK_DELAY_MS, TimeUnit.MILLISECONDS);\n        assertThat(testSubscriber2.takeNext()).isEqualTo(\"Done round 1\");\n        assertThat(testSubscriber3.takeNext()).isEqualTo(\"Done round 1\");\n\n        assertThat(invocationCounter.get()).isEqualTo(2);\n    }", "signature": "void testContentedComputation()", "full_signature": "@Test public void testContentedComputation()", "class_method_signature": "ComputationTaskInvokerTest.testContentedComputation()", "testcase": true, "constructor": false, "invocations": ["subscribe", "recompute", "advanceTimeBy", "subscribe", "recompute", "subscribe", "recompute", "advanceTimeBy", "isEqualTo", "assertThat", "takeNext", "isTrue", "assertThat", "isUnsubscribed", "isNull", "assertThat", "takeNext", "isNull", "assertThat", "takeNext", "isEqualTo", "assertThat", "get", "advanceTimeBy", "isEqualTo", "assertThat", "takeNext", "isEqualTo", "assertThat", "takeNext", "isEqualTo", "assertThat", "get"]}, "focal_class": {"identifier": "ComputationTaskInvoker", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(ComputationTaskInvoker.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(ComputationTaskInvoker.class)", "var_name": "logger"}, {"original_string": "private final Scheduler.Worker worker;", "modifier": "private final", "type": "Scheduler.Worker", "declarator": "worker", "var_name": "worker"}, {"original_string": "private final Observable<O> computation;", "modifier": "private final", "type": "Observable<O>", "declarator": "computation", "var_name": "computation"}, {"original_string": "private final BlockingQueue<Observer<? super O>> waitingObservers = new LinkedBlockingDeque<>();", "modifier": "private final", "type": "BlockingQueue<Observer<? super O>>", "declarator": "waitingObservers = new LinkedBlockingDeque<>()", "var_name": "waitingObservers"}, {"original_string": "private final AtomicReference<Observable<Void>> pendingComputation = new AtomicReference<>();", "modifier": "private final", "type": "AtomicReference<Observable<Void>>", "declarator": "pendingComputation = new AtomicReference<>()", "var_name": "pendingComputation"}], "methods": [{"identifier": "ComputationTaskInvoker", "parameters": "(Observable<O> computation, Scheduler scheduler)", "modifiers": "public", "return": "", "signature": " ComputationTaskInvoker(Observable<O> computation, Scheduler scheduler)", "full_signature": "public  ComputationTaskInvoker(Observable<O> computation, Scheduler scheduler)", "class_method_signature": "ComputationTaskInvoker.ComputationTaskInvoker(Observable<O> computation, Scheduler scheduler)", "testcase": false, "constructor": true}, {"identifier": "recompute", "parameters": "()", "modifiers": "public", "return": "Observable<O>", "signature": "Observable<O> recompute()", "full_signature": "public Observable<O> recompute()", "class_method_signature": "ComputationTaskInvoker.recompute()", "testcase": false, "constructor": false}, {"identifier": "drain", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void drain()", "full_signature": "private void drain()", "class_method_signature": "ComputationTaskInvoker.drain()", "testcase": false, "constructor": false}, {"identifier": "doSafely", "parameters": "(List<Observer<? super O>> observers, Action1<Observer<? super O>> action)", "modifiers": "private", "return": "void", "signature": "void doSafely(List<Observer<? super O>> observers, Action1<Observer<? super O>> action)", "full_signature": "private void doSafely(List<Observer<? super O>> observers, Action1<Observer<? super O>> action)", "class_method_signature": "ComputationTaskInvoker.doSafely(List<Observer<? super O>> observers, Action1<Observer<? super O>> action)", "testcase": false, "constructor": false}], "file": "titus-common/src/main/java/com/netflix/titus/common/util/rx/ComputationTaskInvoker.java"}, "focal_method": {"identifier": "recompute", "parameters": "()", "modifiers": "public", "return": "Observable<O>", "body": "public Observable<O> recompute() {\n        return Observable.create(subscriber -> {\n            waitingObservers.add(subscriber);\n            worker.schedule(this::drain);\n        });\n    }", "signature": "Observable<O> recompute()", "full_signature": "public Observable<O> recompute()", "class_method_signature": "ComputationTaskInvoker.recompute()", "testcase": false, "constructor": false, "invocations": ["create", "add", "schedule"]}, "repository": {"repo_id": 107330274, "url": "https://github.com/Netflix/titus-control-plane", "stars": 241, "created": "10/17/2017 10:20:55 PM +00:00", "updates": "2020-01-25T13:01:05+00:00", "fork": "False", "license": "licensed"}}