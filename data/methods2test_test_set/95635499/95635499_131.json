{"test_class": {"identifier": "ShotgunDistanceTest", "superclass": "", "interfaces": "", "fields": [], "file": "JAICore/jaicore-basic/src/test/java/ai/libs/jaicore/basic/metric/ShotgunDistanceTest.java"}, "test_case": {"identifier": "testCorrectnessForDistanceCalculation2", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testCorrectnessForDistanceCalculation2() {\n\t\t// Input.\n\t\tdouble[] queryTimeSeries = { 1, 1, 2, 2, 3, 5, 3 };\n\t\tdouble[] sampleTimeSeries = { 1, 2, 3, 5, 5, 7 };\n\t\t// Expected output.\n\t\tdouble expectation = .635109;\n\n\t\tint windowLength = 3;\n\t\tboolean meanNormalization = false;\n\t\tShotgunDistance shotgunDistance = new ShotgunDistance(windowLength, meanNormalization);\n\t\tdouble distance = shotgunDistance.distance(queryTimeSeries, sampleTimeSeries);\n\n\t\tassertEquals(expectation, distance, 1e-5);\n\t}", "signature": "void testCorrectnessForDistanceCalculation2()", "full_signature": "@Test public void testCorrectnessForDistanceCalculation2()", "class_method_signature": "ShotgunDistanceTest.testCorrectnessForDistanceCalculation2()", "testcase": true, "constructor": false, "invocations": ["distance", "assertEquals"]}, "focal_class": {"identifier": "ShotgunDistance", "superclass": "", "interfaces": "implements IDistanceMetric", "fields": [{"original_string": "private int windowLength;", "modifier": "private", "type": "int", "declarator": "windowLength", "var_name": "windowLength"}, {"original_string": "private boolean meanNormalization;", "modifier": "private", "type": "boolean", "declarator": "meanNormalization", "var_name": "meanNormalization"}, {"original_string": "private EuclideanDistance euclideanDistance = new EuclideanDistance();", "modifier": "private", "type": "EuclideanDistance", "declarator": "euclideanDistance = new EuclideanDistance()", "var_name": "euclideanDistance"}], "methods": [{"identifier": "ShotgunDistance", "parameters": "(final int windowLength, final boolean meanNormalization)", "modifiers": "public", "return": "", "signature": " ShotgunDistance(final int windowLength, final boolean meanNormalization)", "full_signature": "public  ShotgunDistance(final int windowLength, final boolean meanNormalization)", "class_method_signature": "ShotgunDistance.ShotgunDistance(final int windowLength, final boolean meanNormalization)", "testcase": false, "constructor": true}, {"identifier": "distance", "parameters": "(final double[] a, final double[] b)", "modifiers": "@Override public", "return": "double", "signature": "double distance(final double[] a, final double[] b)", "full_signature": "@Override public double distance(final double[] a, final double[] b)", "class_method_signature": "ShotgunDistance.distance(final double[] a, final double[] b)", "testcase": false, "constructor": false}, {"identifier": "setWindowLength", "parameters": "(final int windowLength)", "modifiers": "public", "return": "void", "signature": "void setWindowLength(final int windowLength)", "full_signature": "public void setWindowLength(final int windowLength)", "class_method_signature": "ShotgunDistance.setWindowLength(final int windowLength)", "testcase": false, "constructor": false}], "file": "JAICore/jaicore-basic/src/main/java/ai/libs/jaicore/basic/metric/ShotgunDistance.java"}, "focal_method": {"identifier": "distance", "parameters": "(final double[] a, final double[] b)", "modifiers": "@Override public", "return": "double", "body": "@Override\n\tpublic double distance(final double[] a, final double[] b) {\n\t\t// Assure that max(A.length, B.length) <= windowLength, otherwise\n\t\t// the result is undefined.\n\n\t\tdouble totalDistance = 0;\n\t\tIVectorTransform transform;\n\t\tif (this.meanNormalization) {\n\t\t\ttransform = new ZTransform();\n\t\t} else {\n\t\t\ttransform = new NormalizeByStdTransform();\n\t\t}\n\n\t\t// For each disjoint query window with lenth this.windowLength.\n\t\tint numberOfDisjointWindows = a.length / this.windowLength;\n\t\tfor (int i = 0; i < numberOfDisjointWindows; i++) {\n\t\t\tint startOfDisjointWindow = i * this.windowLength;\n\t\t\tdouble[] disjointWindow = Arrays.copyOfRange(a, startOfDisjointWindow, startOfDisjointWindow + this.windowLength);\n\n\t\t\t// Vertical alignment.\n\t\t\tdisjointWindow = transform.transform(disjointWindow);\n\n\t\t\t// Holds the minumum distance between the current disjoint window and all\n\t\t\t// sliding windows.\n\t\t\tdouble windowDistance = Double.MAX_VALUE;\n\n\t\t\t// Slide window with length windowLength and stride 1 over the time series B.\n\t\t\tint numberOfSlidingWindows = b.length - this.windowLength + 1;\n\t\t\tfor (int j = 0; j < numberOfSlidingWindows; j++) {\n\t\t\t\tint startOfSlidingWindow = j;\n\t\t\t\tdouble[] slidingWindow = Arrays.copyOfRange(b, startOfSlidingWindow, startOfSlidingWindow + this.windowLength);\n\n\t\t\t\t// Vertical alignment.\n\t\t\t\tslidingWindow = transform.transform(slidingWindow);\n\n\t\t\t\t// Calculate distance between disjoint and sliding window. For each disjoint\n\t\t\t\t// window, keep the minumum distance to all sliding windows.\n\t\t\t\tdouble distanceDisjointSliding = this.euclideanDistance.distance(disjointWindow, slidingWindow);\n\t\t\t\tif (distanceDisjointSliding < windowDistance) {\n\t\t\t\t\twindowDistance = distanceDisjointSliding;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Aggregate the distance for all disjoint windows to the total distance.\n\t\t\ttotalDistance += windowDistance;\n\t\t}\n\n\t\treturn totalDistance;\n\t}", "signature": "double distance(final double[] a, final double[] b)", "full_signature": "@Override public double distance(final double[] a, final double[] b)", "class_method_signature": "ShotgunDistance.distance(final double[] a, final double[] b)", "testcase": false, "constructor": false, "invocations": ["copyOfRange", "transform", "copyOfRange", "transform", "distance"]}, "repository": {"repo_id": 95635499, "url": "https://github.com/fmohr/AILibs", "language": "Java", "is_fork": false, "fork_count": 26, "stargazer_count": 25, "size": 155873, "license": "licensed"}}