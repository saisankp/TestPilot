{"test_class": {"identifier": "CachedGaugeTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(CachedGaugeTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(CachedGaugeTest.class)", "var_name": "LOGGER"}, {"original_string": "private static final int THREAD_COUNT = 10;", "modifier": "private static final", "type": "int", "declarator": "THREAD_COUNT = 10", "var_name": "THREAD_COUNT"}, {"original_string": "private static final long RUNNING_TIME_MILLIS = TimeUnit.SECONDS.toMillis(10);", "modifier": "private static final", "type": "long", "declarator": "RUNNING_TIME_MILLIS = TimeUnit.SECONDS.toMillis(10)", "var_name": "RUNNING_TIME_MILLIS"}, {"original_string": "private final AtomicInteger value = new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "value = new AtomicInteger(0)", "var_name": "value"}, {"original_string": "private final Gauge<Integer> gauge = new CachedGauge<Integer>(100, TimeUnit.MILLISECONDS) {\n        @Override\n        protected Integer loadValue() {\n            return value.incrementAndGet();\n        }\n    };", "modifier": "private final", "type": "Gauge<Integer>", "declarator": "gauge = new CachedGauge<Integer>(100, TimeUnit.MILLISECONDS) {\n        @Override\n        protected Integer loadValue() {\n            return value.incrementAndGet();\n        }\n    }", "var_name": "gauge"}, {"original_string": "private final Gauge<Integer> shortTimeoutGauge = new CachedGauge<Integer>(1, TimeUnit.MILLISECONDS) {\n        @Override\n        protected Integer loadValue() {\n            try {\n                Thread.sleep(5);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"Thread was interrupted\", e);\n            }\n            return value.incrementAndGet();\n        }\n    };", "modifier": "private final", "type": "Gauge<Integer>", "declarator": "shortTimeoutGauge = new CachedGauge<Integer>(1, TimeUnit.MILLISECONDS) {\n        @Override\n        protected Integer loadValue() {\n            try {\n                Thread.sleep(5);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"Thread was interrupted\", e);\n            }\n            return value.incrementAndGet();\n        }\n    }", "var_name": "shortTimeoutGauge"}, {"original_string": "private final ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);", "modifier": "private final", "type": "ExecutorService", "declarator": "executor = Executors.newFixedThreadPool(THREAD_COUNT)", "var_name": "executor"}], "file": "metrics-core/src/test/java/com/codahale/metrics/CachedGaugeTest.java"}, "test_case": {"identifier": "multipleThreadAccessReturnsConsistentResults", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void multipleThreadAccessReturnsConsistentResults() throws Exception {\n        List<Future<Boolean>> futures = new ArrayList<>(THREAD_COUNT);\n\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            Future<Boolean> future = executor.submit(() -> {\n                long startTime = System.currentTimeMillis();\n                int lastValue = 0;\n\n                do {\n                    Integer newValue = shortTimeoutGauge.getValue();\n\n                    if (newValue == null) {\n                        LOGGER.warn(\"Cached gauge returned null value\");\n                        return false;\n                    }\n\n                    if (newValue < lastValue) {\n                        LOGGER.error(\"Cached gauge returned stale value, last: {}, new: {}\", lastValue, newValue);\n                        return false;\n                    }\n\n                    lastValue = newValue;\n                } while (System.currentTimeMillis() - startTime <= RUNNING_TIME_MILLIS);\n\n                return true;\n            });\n\n            futures.add(future);\n        }\n\n        for (int i = 0; i < futures.size(); i++) {\n            assertTrue(\"Future \" + i + \" failed\", futures.get(i).get());\n        }\n\n        executor.shutdown();\n    }", "signature": "void multipleThreadAccessReturnsConsistentResults()", "full_signature": "@Test public void multipleThreadAccessReturnsConsistentResults()", "class_method_signature": "CachedGaugeTest.multipleThreadAccessReturnsConsistentResults()", "testcase": true, "constructor": false, "invocations": ["submit", "currentTimeMillis", "getValue", "warn", "error", "currentTimeMillis", "add", "size", "assertTrue", "get", "get", "shutdown"]}, "focal_class": {"identifier": "CachedGauge", "superclass": "", "interfaces": "implements Gauge<T>", "fields": [{"original_string": "private final Clock clock;", "modifier": "private final", "type": "Clock", "declarator": "clock", "var_name": "clock"}, {"original_string": "private final AtomicLong reloadAt;", "modifier": "private final", "type": "AtomicLong", "declarator": "reloadAt", "var_name": "reloadAt"}, {"original_string": "private final long timeoutNS;", "modifier": "private final", "type": "long", "declarator": "timeoutNS", "var_name": "timeoutNS"}, {"original_string": "private final AtomicReference<T> value;", "modifier": "private final", "type": "AtomicReference<T>", "declarator": "value", "var_name": "value"}], "methods": [{"identifier": "CachedGauge", "parameters": "(long timeout, TimeUnit timeoutUnit)", "modifiers": "protected", "return": "", "signature": " CachedGauge(long timeout, TimeUnit timeoutUnit)", "full_signature": "protected  CachedGauge(long timeout, TimeUnit timeoutUnit)", "class_method_signature": "CachedGauge.CachedGauge(long timeout, TimeUnit timeoutUnit)", "testcase": false, "constructor": true}, {"identifier": "CachedGauge", "parameters": "(Clock clock, long timeout, TimeUnit timeoutUnit)", "modifiers": "protected", "return": "", "signature": " CachedGauge(Clock clock, long timeout, TimeUnit timeoutUnit)", "full_signature": "protected  CachedGauge(Clock clock, long timeout, TimeUnit timeoutUnit)", "class_method_signature": "CachedGauge.CachedGauge(Clock clock, long timeout, TimeUnit timeoutUnit)", "testcase": false, "constructor": true}, {"identifier": "loadValue", "parameters": "()", "modifiers": "protected abstract", "return": "T", "signature": "T loadValue()", "full_signature": "protected abstract T loadValue()", "class_method_signature": "CachedGauge.loadValue()", "testcase": false, "constructor": false}, {"identifier": "getValue", "parameters": "()", "modifiers": "@Override public", "return": "T", "signature": "T getValue()", "full_signature": "@Override public T getValue()", "class_method_signature": "CachedGauge.getValue()", "testcase": false, "constructor": false}, {"identifier": "shouldLoad", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean shouldLoad()", "full_signature": "private boolean shouldLoad()", "class_method_signature": "CachedGauge.shouldLoad()", "testcase": false, "constructor": false}], "file": "metrics-core/src/main/java/com/codahale/metrics/CachedGauge.java"}, "focal_method": {"identifier": "getValue", "parameters": "()", "modifiers": "@Override public", "return": "T", "body": "@Override\n    public T getValue() {\n        T currentValue = this.value.get();\n        if (shouldLoad() || currentValue == null) {\n            T newValue = loadValue();\n            if (!this.value.compareAndSet(currentValue, newValue)) {\n                return this.value.get();\n            }\n            return newValue;\n        }\n        return currentValue;\n    }", "signature": "T getValue()", "full_signature": "@Override public T getValue()", "class_method_signature": "CachedGauge.getValue()", "testcase": false, "constructor": false, "invocations": ["get", "shouldLoad", "loadValue", "compareAndSet", "get"]}, "repository": {"repo_id": 537800, "url": "https://github.com/dropwizard/metrics", "stars": 6879, "created": "2/26/2010 7:44:42 PM +00:00", "updates": "2020-01-26T22:33:14+00:00", "fork": "False", "license": "licensed"}}