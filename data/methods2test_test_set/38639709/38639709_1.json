{"test_class": {"identifier": "RepositoryBuildLauncherTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final RepositoryBuildService repositoryBuildService = mock(RepositoryBuildService.class);", "modifier": "private final", "type": "RepositoryBuildService", "declarator": "repositoryBuildService = mock(RepositoryBuildService.class)", "var_name": "repositoryBuildService"}, {"original_string": "private final BranchService branchService = mock(BranchService.class);", "modifier": "private final", "type": "BranchService", "declarator": "branchService = mock(BranchService.class)", "var_name": "branchService"}, {"original_string": "private final ModuleService moduleService = mock(ModuleService.class);", "modifier": "private final", "type": "ModuleService", "declarator": "moduleService = mock(ModuleService.class)", "var_name": "moduleService"}, {"original_string": "private final DependenciesService dependenciesService = mock(DependenciesService.class);", "modifier": "private final", "type": "DependenciesService", "declarator": "dependenciesService = mock(DependenciesService.class)", "var_name": "dependenciesService"}, {"original_string": "private final ModuleDiscoveryService moduleDiscoveryService = mock(ModuleDiscoveryService.class);", "modifier": "private final", "type": "ModuleDiscoveryService", "declarator": "moduleDiscoveryService = mock(ModuleDiscoveryService.class)", "var_name": "moduleDiscoveryService"}, {"original_string": "private final ModuleDiscoveryHandler moduleDiscoveryHandler = mock(ModuleDiscoveryHandler.class);", "modifier": "private final", "type": "ModuleDiscoveryHandler", "declarator": "moduleDiscoveryHandler = mock(ModuleDiscoveryHandler.class)", "var_name": "moduleDiscoveryHandler"}, {"original_string": "private final GitHubHelper gitHubHelper = mock(GitHubHelper.class);", "modifier": "private final", "type": "GitHubHelper", "declarator": "gitHubHelper = mock(GitHubHelper.class)", "var_name": "gitHubHelper"}], "file": "BlazarService/src/test/java/com/hubspot/blazar/util/RepositoryBuildLauncherTest.java"}, "test_case": {"identifier": "itUsesNewCommitWhenBranchBuildIsNotPartOfAInterProjectBuild", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void itUsesNewCommitWhenBranchBuildIsNotPartOfAInterProjectBuild() throws Exception {\n    GitInfo branch = new GitInfo(Optional.of(1), \"git.example.com\", \"example\", \"repository\", 1, \"master\", true, 0L, 1L);\n\n    String initialCommitSha = \"0000000000000000000000000000000000000000\";\n    String secondCommitSha = \"1111111111111111111111111111111111111111\";\n\n    Commit initialCommit = Commit.newBuilder().setId(initialCommitSha).build();\n    Commit secondCommit = Commit.newBuilder().setId(secondCommitSha).build();\n\n    CommitInfo previousCommitInfo = new CommitInfo(initialCommit, Optional.absent(), Collections.emptyList(), false);\n    RepositoryBuild previousBuild = RepositoryBuild.newBuilder(1, 1, RepositoryBuild.State.SUCCEEDED, BuildTrigger.forCommit(initialCommitSha), BuildOptions.defaultOptions())\n        .setCommitInfo(Optional.of(previousCommitInfo))\n        .build();\n    Optional<RepositoryBuild> previousBuildOptional = Optional.of(previousBuild);\n\n\n    RepositoryBuild currentBuild = RepositoryBuild.queuedBuild(branch, BuildTrigger.forCommit(secondCommitSha), 2, BuildOptions.defaultOptions());\n    RepositoryBuildLauncher launcher = new RepositoryBuildLauncher(repositoryBuildService, branchService, moduleService, dependenciesService, moduleDiscoveryService, moduleDiscoveryHandler, gitHubHelper);\n\n    GHRepository repository = mock(GHRepository.class);\n\n    when(gitHubHelper.shaFor(any(), any())).thenReturn(Optional.of(secondCommitSha));\n    when(gitHubHelper.repositoryFor(any())).thenReturn(repository);\n\n    doAnswer(invocation -> {\n      String sha = (String) invocation.getArguments()[0];\n      return new GHCommit() {\n        @Override\n        public String getSHA1() {\n          return sha;\n        }\n      };\n    }).when(repository).getCommit(anyString());\n\n    doAnswer(invocation -> {\n      GHCommit commit = (GHCommit) invocation.getArguments()[0];\n      return Commit.newBuilder().setId(commit.getSHA1()).build();\n    }).when(gitHubHelper).toCommit(any());\n\n    // Test that the method was called with the expected arguments.\n    doAnswer(invocation -> {\n      Commit currentCommit = (Commit) invocation.getArguments()[1];\n      Optional<Commit> previousCommit = (Optional<Commit>) invocation.getArguments()[2];\n      return new CommitInfo(currentCommit, previousCommit, ImmutableList.of(currentCommit), false);\n    }).when(gitHubHelper).commitInfoFor(any(), any(), any());\n\n    CommitInfo result = launcher.calculateCommitInfoForBuild(branch, currentBuild, previousBuildOptional);\n    assertThat(result.getCurrent().getId()).isEqualTo(secondCommitSha);\n    assertThat(result.getPrevious().isPresent()).isTrue();\n    assertThat(result.getPrevious().get().getId()).isEqualTo(initialCommitSha);\n    assertThat(result.getNewCommits().isEmpty()).isFalse();\n    assertThat(result.getNewCommits()).isEqualTo(ImmutableList.of(secondCommit));\n  }", "signature": "void itUsesNewCommitWhenBranchBuildIsNotPartOfAInterProjectBuild()", "full_signature": "@Test public void itUsesNewCommitWhenBranchBuildIsNotPartOfAInterProjectBuild()", "class_method_signature": "RepositoryBuildLauncherTest.itUsesNewCommitWhenBranchBuildIsNotPartOfAInterProjectBuild()", "testcase": true, "constructor": false, "invocations": ["of", "build", "setId", "newBuilder", "build", "setId", "newBuilder", "absent", "emptyList", "build", "setCommitInfo", "newBuilder", "forCommit", "defaultOptions", "of", "of", "queuedBuild", "forCommit", "defaultOptions", "mock", "thenReturn", "when", "shaFor", "any", "any", "of", "thenReturn", "when", "repositoryFor", "any", "getCommit", "when", "doAnswer", "getArguments", "anyString", "toCommit", "when", "doAnswer", "getArguments", "build", "setId", "newBuilder", "getSHA1", "any", "commitInfoFor", "when", "doAnswer", "getArguments", "getArguments", "of", "any", "any", "any", "calculateCommitInfoForBuild", "isEqualTo", "assertThat", "getId", "getCurrent", "isTrue", "assertThat", "isPresent", "getPrevious", "isEqualTo", "assertThat", "getId", "get", "getPrevious", "isFalse", "assertThat", "isEmpty", "getNewCommits", "isEqualTo", "assertThat", "getNewCommits", "of"]}, "focal_class": {"identifier": "RepositoryBuildLauncher", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(RepositoryBuildLauncher.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(RepositoryBuildLauncher.class)", "var_name": "LOG"}, {"original_string": "private final RepositoryBuildService repositoryBuildService;", "modifier": "private final", "type": "RepositoryBuildService", "declarator": "repositoryBuildService", "var_name": "repositoryBuildService"}, {"original_string": "private final BranchService branchService;", "modifier": "private final", "type": "BranchService", "declarator": "branchService", "var_name": "branchService"}, {"original_string": "private final ModuleService moduleService;", "modifier": "private final", "type": "ModuleService", "declarator": "moduleService", "var_name": "moduleService"}, {"original_string": "private final DependenciesService dependenciesService;", "modifier": "private final", "type": "DependenciesService", "declarator": "dependenciesService", "var_name": "dependenciesService"}, {"original_string": "private final ModuleDiscoveryService moduleDiscoveryService;", "modifier": "private final", "type": "ModuleDiscoveryService", "declarator": "moduleDiscoveryService", "var_name": "moduleDiscoveryService"}, {"original_string": "private final ModuleDiscoveryHandler moduleDiscoveryHandler;", "modifier": "private final", "type": "ModuleDiscoveryHandler", "declarator": "moduleDiscoveryHandler", "var_name": "moduleDiscoveryHandler"}, {"original_string": "private final GitHubHelper gitHubHelper;", "modifier": "private final", "type": "GitHubHelper", "declarator": "gitHubHelper", "var_name": "gitHubHelper"}], "methods": [{"identifier": "RepositoryBuildLauncher", "parameters": "(RepositoryBuildService repositoryBuildService,\n                                 BranchService branchService,\n                                 ModuleService moduleService,\n                                 DependenciesService dependenciesService,\n                                 ModuleDiscoveryService moduleDiscoveryService,\n                                 ModuleDiscoveryHandler moduleDiscoveryHandler,\n                                 GitHubHelper gitHubHelper)", "modifiers": "@Inject public", "return": "", "signature": " RepositoryBuildLauncher(RepositoryBuildService repositoryBuildService,\n                                 BranchService branchService,\n                                 ModuleService moduleService,\n                                 DependenciesService dependenciesService,\n                                 ModuleDiscoveryService moduleDiscoveryService,\n                                 ModuleDiscoveryHandler moduleDiscoveryHandler,\n                                 GitHubHelper gitHubHelper)", "full_signature": "@Inject public  RepositoryBuildLauncher(RepositoryBuildService repositoryBuildService,\n                                 BranchService branchService,\n                                 ModuleService moduleService,\n                                 DependenciesService dependenciesService,\n                                 ModuleDiscoveryService moduleDiscoveryService,\n                                 ModuleDiscoveryHandler moduleDiscoveryHandler,\n                                 GitHubHelper gitHubHelper)", "class_method_signature": "RepositoryBuildLauncher.RepositoryBuildLauncher(RepositoryBuildService repositoryBuildService,\n                                 BranchService branchService,\n                                 ModuleService moduleService,\n                                 DependenciesService dependenciesService,\n                                 ModuleDiscoveryService moduleDiscoveryService,\n                                 ModuleDiscoveryHandler moduleDiscoveryHandler,\n                                 GitHubHelper gitHubHelper)", "testcase": false, "constructor": true}, {"identifier": "launch", "parameters": "(RepositoryBuild queued, Optional<RepositoryBuild> previous)", "modifiers": "public", "return": "void", "signature": "void launch(RepositoryBuild queued, Optional<RepositoryBuild> previous)", "full_signature": "public void launch(RepositoryBuild queued, Optional<RepositoryBuild> previous)", "class_method_signature": "RepositoryBuildLauncher.launch(RepositoryBuild queued, Optional<RepositoryBuild> previous)", "testcase": false, "constructor": false}, {"identifier": "calculateCommitInfoForBuild", "parameters": "(\n      GitInfo gitInfo,\n      RepositoryBuild queuedBuild,\n      Optional<RepositoryBuild> previousBuild)", "modifiers": "@VisibleForTesting", "return": "CommitInfo", "signature": "CommitInfo calculateCommitInfoForBuild(\n      GitInfo gitInfo,\n      RepositoryBuild queuedBuild,\n      Optional<RepositoryBuild> previousBuild)", "full_signature": "@VisibleForTesting CommitInfo calculateCommitInfoForBuild(\n      GitInfo gitInfo,\n      RepositoryBuild queuedBuild,\n      Optional<RepositoryBuild> previousBuild)", "class_method_signature": "RepositoryBuildLauncher.calculateCommitInfoForBuild(\n      GitInfo gitInfo,\n      RepositoryBuild queuedBuild,\n      Optional<RepositoryBuild> previousBuild)", "testcase": false, "constructor": false}, {"identifier": "getCommitFromRepositoryBuild", "parameters": "(Optional<RepositoryBuild> build)", "modifiers": "private static", "return": "Optional<Commit>", "signature": "Optional<Commit> getCommitFromRepositoryBuild(Optional<RepositoryBuild> build)", "full_signature": "private static Optional<Commit> getCommitFromRepositoryBuild(Optional<RepositoryBuild> build)", "class_method_signature": "RepositoryBuildLauncher.getCommitFromRepositoryBuild(Optional<RepositoryBuild> build)", "testcase": false, "constructor": false}], "file": "BlazarService/src/main/java/com/hubspot/blazar/util/RepositoryBuildLauncher.java"}, "focal_method": {"identifier": "calculateCommitInfoForBuild", "parameters": "(\n      GitInfo gitInfo,\n      RepositoryBuild queuedBuild,\n      Optional<RepositoryBuild> previousBuild)", "modifiers": "@VisibleForTesting", "return": "CommitInfo", "body": "@VisibleForTesting\n  CommitInfo calculateCommitInfoForBuild(\n      GitInfo gitInfo,\n      RepositoryBuild queuedBuild,\n      Optional<RepositoryBuild> previousBuild) throws IOException, NonRetryableBuildException {\n    LOG.info(\"Trying to fetch current sha for branch {}/{}\", gitInfo.getRepository(), gitInfo.getBranch());\n\n    final GHRepository repository;\n    try {\n      repository = gitHubHelper.repositoryFor(gitInfo);\n    } catch (FileNotFoundException e) {\n      throw new NonRetryableBuildException(\"Couldn't find repository \" + gitInfo.getFullRepositoryName(), e);\n    }\n\n    Optional<Commit> lastCommitInPreviousBuild = getCommitFromRepositoryBuild(previousBuild);\n\n    // Inter project builds re-build the project using the commit of the last build if available\n    // otherwise we fall back to using the newest commit available\n    if (queuedBuild.getBuildTrigger().getType() == INTER_PROJECT && lastCommitInPreviousBuild.isPresent()) {\n      return new CommitInfo(lastCommitInPreviousBuild.get(), lastCommitInPreviousBuild, ImmutableList.of(), false);\n    }\n\n    // Resolve newest sha\n    Optional<String> sha = gitHubHelper.shaFor(repository, gitInfo);\n    if (!sha.isPresent()) {\n      String message = String.format(\"Couldn't find branch %s for repository %s\", gitInfo.getBranch(), gitInfo.getFullRepositoryName());\n      throw new NonRetryableBuildException(message);\n    } else {\n      LOG.info(\"Found sha {} for branch {}/{}\", sha.get(), gitInfo.getRepository(), gitInfo.getBranch());\n\n      Commit currentCommit = gitHubHelper.toCommit(repository.getCommit(sha.get()));\n      return gitHubHelper.commitInfoFor(repository, currentCommit, lastCommitInPreviousBuild);\n    }\n  }", "signature": "CommitInfo calculateCommitInfoForBuild(\n      GitInfo gitInfo,\n      RepositoryBuild queuedBuild,\n      Optional<RepositoryBuild> previousBuild)", "full_signature": "@VisibleForTesting CommitInfo calculateCommitInfoForBuild(\n      GitInfo gitInfo,\n      RepositoryBuild queuedBuild,\n      Optional<RepositoryBuild> previousBuild)", "class_method_signature": "RepositoryBuildLauncher.calculateCommitInfoForBuild(\n      GitInfo gitInfo,\n      RepositoryBuild queuedBuild,\n      Optional<RepositoryBuild> previousBuild)", "testcase": false, "constructor": false, "invocations": ["info", "getRepository", "getBranch", "repositoryFor", "getFullRepositoryName", "getCommitFromRepositoryBuild", "getType", "getBuildTrigger", "isPresent", "get", "of", "shaFor", "isPresent", "format", "getBranch", "getFullRepositoryName", "info", "get", "getRepository", "getBranch", "toCommit", "getCommit", "get", "commitInfoFor"]}, "repository": {"repo_id": 38639709, "url": "https://github.com/HubSpot/Blazar-Archive", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 66, "size": 4209, "license": "licensed"}}