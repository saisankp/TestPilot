{"test_class": {"identifier": "ChannelInitializerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Transport transport;", "modifier": "private", "type": "Transport", "declarator": "transport", "var_name": "transport"}, {"original_string": "private Mockery mockery;", "modifier": "private", "type": "Mockery", "declarator": "mockery", "var_name": "mockery"}, {"original_string": "private ByteChannelReader byteChannelReader;", "modifier": "private", "type": "ByteChannelReader", "declarator": "byteChannelReader", "var_name": "byteChannelReader"}, {"original_string": "private OutboundMessageHandler outboundMessageHandler;", "modifier": "private", "type": "OutboundMessageHandler", "declarator": "outboundMessageHandler", "var_name": "outboundMessageHandler"}, {"original_string": "private DeterministicExecutor deterministicExecutor;", "modifier": "private", "type": "DeterministicExecutor", "declarator": "deterministicExecutor", "var_name": "deterministicExecutor"}, {"original_string": "private WritableByteChannel writableByteChannel;", "modifier": "private", "type": "WritableByteChannel", "declarator": "writableByteChannel", "var_name": "writableByteChannel"}, {"original_string": "private ReadableByteChannel readableByteChannel;", "modifier": "private", "type": "ReadableByteChannel", "declarator": "readableByteChannel", "var_name": "readableByteChannel"}], "file": "nanofix-client/src/test/java/com/lmax/nanofix/ChannelInitializerTest.java"}, "test_case": {"identifier": "shouldStartByteChannelReaderOnConnectionEstablished", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldStartByteChannelReaderOnConnectionEstablished() throws Exception\n    {\n        deterministicExecutor = new DeterministicExecutor();\n        final ChannelInitializer channelInitializer = new ChannelInitializer(transport, byteChannelReader, outboundMessageHandler, deterministicExecutor);\n\n        mockery.checking(new Expectations()\n        {\n            {\n                one(transport).getWritableByteChannel();\n                will(returnValue(writableByteChannel));\n\n                one(outboundMessageHandler).initialiseOutboundChannel(writableByteChannel);\n            }\n        });\n        channelInitializer.connectionEstablished();\n\n        mockery.checking(new Expectations()\n        {\n            {\n                one(transport).getReadableByteChannel();\n                will(returnValue(readableByteChannel));\n\n                one(byteChannelReader).blockingStart(readableByteChannel);\n            }\n        });\n        deterministicExecutor.runPendingCommands();\n\n    }", "signature": "void shouldStartByteChannelReaderOnConnectionEstablished()", "full_signature": "@Test public void shouldStartByteChannelReaderOnConnectionEstablished()", "class_method_signature": "ChannelInitializerTest.shouldStartByteChannelReaderOnConnectionEstablished()", "testcase": true, "constructor": false, "invocations": ["checking", "getWritableByteChannel", "one", "will", "returnValue", "initialiseOutboundChannel", "one", "connectionEstablished", "checking", "getReadableByteChannel", "one", "will", "returnValue", "blockingStart", "one", "runPendingCommands"]}, "focal_class": {"identifier": "ChannelInitializer", "superclass": "", "interfaces": "implements ConnectionObserver", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ChannelInitializer.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ChannelInitializer.class)", "var_name": "LOGGER"}, {"original_string": "private final Transport transport;", "modifier": "private final", "type": "Transport", "declarator": "transport", "var_name": "transport"}, {"original_string": "private final ByteChannelReader inputStreamReader;", "modifier": "private final", "type": "ByteChannelReader", "declarator": "inputStreamReader", "var_name": "inputStreamReader"}, {"original_string": "private final OutboundMessageHandler outboundMessageSender;", "modifier": "private final", "type": "OutboundMessageHandler", "declarator": "outboundMessageSender", "var_name": "outboundMessageSender"}, {"original_string": "private final Executor channelReaderExecutorService;", "modifier": "private final", "type": "Executor", "declarator": "channelReaderExecutorService", "var_name": "channelReaderExecutorService"}, {"original_string": "private volatile CountDownLatch countDownLatch = new CountDownLatch(1);", "modifier": "private volatile", "type": "CountDownLatch", "declarator": "countDownLatch = new CountDownLatch(1)", "var_name": "countDownLatch"}], "methods": [{"identifier": "ChannelInitializer", "parameters": "(final Transport transport, final ByteChannelReader inputStreamReader, final OutboundMessageHandler outboundMessageSender, Executor channelReaderExecutorService)", "modifiers": "public", "return": "", "signature": " ChannelInitializer(final Transport transport, final ByteChannelReader inputStreamReader, final OutboundMessageHandler outboundMessageSender, Executor channelReaderExecutorService)", "full_signature": "public  ChannelInitializer(final Transport transport, final ByteChannelReader inputStreamReader, final OutboundMessageHandler outboundMessageSender, Executor channelReaderExecutorService)", "class_method_signature": "ChannelInitializer.ChannelInitializer(final Transport transport, final ByteChannelReader inputStreamReader, final OutboundMessageHandler outboundMessageSender, Executor channelReaderExecutorService)", "testcase": false, "constructor": true}, {"identifier": "connectionEstablished", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void connectionEstablished()", "full_signature": "@Override public void connectionEstablished()", "class_method_signature": "ChannelInitializer.connectionEstablished()", "testcase": false, "constructor": false}, {"identifier": "awaitConnection", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void awaitConnection()", "full_signature": "public void awaitConnection()", "class_method_signature": "ChannelInitializer.awaitConnection()", "testcase": false, "constructor": false}, {"identifier": "connectionClosed", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void connectionClosed()", "full_signature": "@Override public void connectionClosed()", "class_method_signature": "ChannelInitializer.connectionClosed()", "testcase": false, "constructor": false}], "file": "nanofix-client/src/main/java/com/lmax/nanofix/ChannelInitializer.java"}, "focal_method": {"identifier": "connectionEstablished", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void connectionEstablished()\n    {\n        outboundMessageSender.initialiseOutboundChannel(transport.getWritableByteChannel());\n        channelReaderExecutorService.execute(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                final ReadableByteChannel readableByteChannel = transport.getReadableByteChannel();\n                try\n                {\n                    inputStreamReader.blockingStart(readableByteChannel);\n                }\n                catch (RuntimeException e)\n                {\n                    LOGGER.error(\"Exception thrown while reading from stream, channel: \" + readableByteChannel, e);\n                }\n            }\n        });\n        countDownLatch.countDown();\n    }", "signature": "void connectionEstablished()", "full_signature": "@Override public void connectionEstablished()", "class_method_signature": "ChannelInitializer.connectionEstablished()", "testcase": false, "constructor": false, "invocations": ["initialiseOutboundChannel", "getWritableByteChannel", "execute", "getReadableByteChannel", "blockingStart", "error", "countDown"]}, "repository": {"repo_id": 30593072, "url": "https://github.com/LMAX-Exchange/nanofix", "language": "Java", "is_fork": false, "fork_count": 18, "stargazer_count": 24, "size": 193, "license": "licensed"}}