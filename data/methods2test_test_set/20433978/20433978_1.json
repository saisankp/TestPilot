{"test_class": {"identifier": "DiskLoggerTest", "superclass": "extends TestCase", "interfaces": "", "fields": [{"original_string": "public static final String testdir = \"/tmp/xtfs-dbtest/dbl/\";", "modifier": "public static final", "type": "String", "declarator": "testdir = \"/tmp/xtfs-dbtest/dbl/\"", "var_name": "testdir"}, {"original_string": "private DiskLogger         l;", "modifier": "private", "type": "DiskLogger", "declarator": "l", "var_name": "l"}], "file": "java/babudb-core/src/test/java/org/xtreemfs/babudb/log/DiskLoggerTest.java"}, "test_case": {"identifier": "testSwitchLogFile", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSwitchLogFile() throws Exception {\n        \n        final AtomicInteger count = new AtomicInteger(0);\n        \n        SyncListener sl = new SyncListener() {\n            \n            public void synced(LSN lsn) {\n                synchronized (count) {\n                    count.incrementAndGet();\n                    count.notifyAll();\n                }\n            }\n            \n            public void failed(Exception ex) {\n                synchronized (count) {\n                    count.incrementAndGet();\n                    count.notifyAll();\n                }\n            }\n        };\n        \n        for (int i = 0; i < 100; i++) {\n            String pl = \"Entry \" + (i + 1);\n            ReusableBuffer plb = ReusableBuffer.wrap(pl.getBytes());\n            l.append(new LogEntry(plb, sl, LogEntry.PAYLOAD_TYPE_INSERT));\n        }\n        synchronized (count) {\n            if (count.get() < 100)\n                count.wait(1000);\n        }\n        \n        try {\n            l.lock();\n            l.switchLogFile(false);\n        } finally {\n            l.unlock();\n        }\n        \n        for (int i = 0; i < 100; i++) {\n            String pl = \"Entry \" + (i + 100 + 1);\n            ReusableBuffer plb = ReusableBuffer.wrap(pl.getBytes());\n            l.append(new LogEntry(plb, sl, LogEntry.PAYLOAD_TYPE_INSERT));\n        }\n        \n        synchronized (count) {\n            if (count.get() < 200)\n                count.wait(1000);\n        }\n    }", "signature": "void testSwitchLogFile()", "full_signature": "@Test public void testSwitchLogFile()", "class_method_signature": "DiskLoggerTest.testSwitchLogFile()", "testcase": true, "constructor": false, "invocations": ["incrementAndGet", "notifyAll", "incrementAndGet", "notifyAll", "wrap", "getBytes", "append", "get", "wait", "lock", "switchLogFile", "unlock", "wrap", "getBytes", "append", "get", "wait"]}, "focal_class": {"identifier": "DiskLogger", "superclass": "extends LifeCycleThread", "interfaces": "", "fields": [{"original_string": "public static final int            MAX_ENTRIES_PER_BLOCK             = 250;", "modifier": "public static final", "type": "int", "declarator": "MAX_ENTRIES_PER_BLOCK             = 250", "var_name": "MAX_ENTRIES_PER_BLOCK"}, {"original_string": "private static final String        RUNTIME_STATE_PROCESSEDLOGENTRIES = \"diskLogger.processedLogEntryCount\";", "modifier": "private static final", "type": "String", "declarator": "RUNTIME_STATE_PROCESSEDLOGENTRIES = \"diskLogger.processedLogEntryCount\"", "var_name": "RUNTIME_STATE_PROCESSEDLOGENTRIES"}, {"original_string": "private FileChannel                channel;", "modifier": "private", "type": "FileChannel", "declarator": "channel", "var_name": "channel"}, {"original_string": "private RandomAccessFile           fos;", "modifier": "private", "type": "RandomAccessFile", "declarator": "fos", "var_name": "fos"}, {"original_string": "private FileDescriptor             fdes;", "modifier": "private", "type": "FileDescriptor", "declarator": "fdes", "var_name": "fdes"}, {"original_string": "private final LinkedList<LogEntry> entries                           = new LinkedList<LogEntry>();", "modifier": "private final", "type": "LinkedList<LogEntry>", "declarator": "entries                           = new LinkedList<LogEntry>()", "var_name": "entries"}, {"original_string": "private volatile boolean           quit                              = true;", "modifier": "private volatile", "type": "boolean", "declarator": "quit                              = true", "var_name": "quit"}, {"original_string": "private boolean                    graceful;", "modifier": "private", "type": "boolean", "declarator": "graceful", "var_name": "graceful"}, {"original_string": "private final String               logfileDir;", "modifier": "private final", "type": "String", "declarator": "logfileDir", "var_name": "logfileDir"}, {"original_string": "private final AtomicLong           nextLogSequenceNo                 = new AtomicLong();", "modifier": "private final", "type": "AtomicLong", "declarator": "nextLogSequenceNo                 = new AtomicLong()", "var_name": "nextLogSequenceNo"}, {"original_string": "private final AtomicInteger        currentViewId                     = new AtomicInteger();", "modifier": "private final", "type": "AtomicInteger", "declarator": "currentViewId                     = new AtomicInteger()", "var_name": "currentViewId"}, {"original_string": "private volatile String            currentLogFileName;", "modifier": "private volatile", "type": "String", "declarator": "currentLogFileName", "var_name": "currentLogFileName"}, {"original_string": "private final ReentrantLock        sync                              = new ReentrantLock();", "modifier": "private final", "type": "ReentrantLock", "declarator": "sync                              = new ReentrantLock()", "var_name": "sync"}, {"original_string": "private final SyncMode             syncMode;", "modifier": "private final", "type": "SyncMode", "declarator": "syncMode", "var_name": "syncMode"}, {"original_string": "private final int                  pseudoSyncWait;", "modifier": "private final", "type": "int", "declarator": "pseudoSyncWait", "var_name": "pseudoSyncWait"}, {"original_string": "private final Object               pseudoSyncWaitMonitor             = new Object();", "modifier": "private final", "type": "Object", "declarator": "pseudoSyncWaitMonitor             = new Object()", "var_name": "pseudoSyncWaitMonitor"}, {"original_string": "private final CRC32                csumAlgo                          = new CRC32();", "modifier": "private final", "type": "CRC32", "declarator": "csumAlgo                          = new CRC32()", "var_name": "csumAlgo"}, {"original_string": "private final int                  maxQ;", "modifier": "private final", "type": "int", "declarator": "maxQ", "var_name": "maxQ"}, {"original_string": "private AtomicInteger              _processedLogEntries              = new AtomicInteger();", "modifier": "private", "type": "AtomicInteger", "declarator": "_processedLogEntries              = new AtomicInteger()", "var_name": "_processedLogEntries"}], "methods": [{"identifier": "DiskLogger", "parameters": "(String logfileDir, LSN initLSN, SyncMode syncMode, int pseudoSyncWait, int maxQ)", "modifiers": "public", "return": "", "signature": " DiskLogger(String logfileDir, LSN initLSN, SyncMode syncMode, int pseudoSyncWait, int maxQ)", "full_signature": "public  DiskLogger(String logfileDir, LSN initLSN, SyncMode syncMode, int pseudoSyncWait, int maxQ)", "class_method_signature": "DiskLogger.DiskLogger(String logfileDir, LSN initLSN, SyncMode syncMode, int pseudoSyncWait, int maxQ)", "testcase": false, "constructor": true}, {"identifier": "dropLogFile", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void dropLogFile()", "full_signature": "public void dropLogFile()", "class_method_signature": "DiskLogger.dropLogFile()", "testcase": false, "constructor": false}, {"identifier": "loadLogFile", "parameters": "(LSN initLSN)", "modifiers": "public", "return": "void", "signature": "void loadLogFile(LSN initLSN)", "full_signature": "public void loadLogFile(LSN initLSN)", "class_method_signature": "DiskLogger.loadLogFile(LSN initLSN)", "testcase": false, "constructor": false}, {"identifier": "getLogFileSize", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getLogFileSize()", "full_signature": "public long getLogFileSize()", "class_method_signature": "DiskLogger.getLogFileSize()", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(LogEntry entry)", "modifiers": "public synchronized", "return": "void", "signature": "void append(LogEntry entry)", "full_signature": "public synchronized void append(LogEntry entry)", "class_method_signature": "DiskLogger.append(LogEntry entry)", "testcase": false, "constructor": false}, {"identifier": "lock", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void lock()", "full_signature": "public void lock()", "class_method_signature": "DiskLogger.lock()", "testcase": false, "constructor": false}, {"identifier": "hasLock", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean hasLock()", "full_signature": "public boolean hasLock()", "class_method_signature": "DiskLogger.hasLock()", "testcase": false, "constructor": false}, {"identifier": "unlock", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void unlock()", "full_signature": "public void unlock()", "class_method_signature": "DiskLogger.unlock()", "testcase": false, "constructor": false}, {"identifier": "switchLogFile", "parameters": "(boolean incrementViewId)", "modifiers": "public", "return": "LSN", "signature": "LSN switchLogFile(boolean incrementViewId)", "full_signature": "public LSN switchLogFile(boolean incrementViewId)", "class_method_signature": "DiskLogger.switchLogFile(boolean incrementViewId)", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void start()", "full_signature": "@Override public synchronized void start()", "class_method_signature": "DiskLogger.start()", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void run()", "full_signature": "public void run()", "class_method_signature": "DiskLogger.run()", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "DiskLogger.shutdown()", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "(boolean graceful)", "modifiers": "public synchronized", "return": "void", "signature": "void shutdown(boolean graceful)", "full_signature": "public synchronized void shutdown(boolean graceful)", "class_method_signature": "DiskLogger.shutdown(boolean graceful)", "testcase": false, "constructor": false}, {"identifier": "destroy", "parameters": "()", "modifiers": "@Deprecated public", "return": "void", "signature": "void destroy()", "full_signature": "@Deprecated public void destroy()", "class_method_signature": "DiskLogger.destroy()", "testcase": false, "constructor": false}, {"identifier": "getLatestLSN", "parameters": "()", "modifiers": "public", "return": "LSN", "signature": "LSN getLatestLSN()", "full_signature": "public LSN getLatestLSN()", "class_method_signature": "DiskLogger.getLatestLSN()", "testcase": false, "constructor": false}, {"identifier": "getRuntimeState", "parameters": "(String property)", "modifiers": "public", "return": "Object", "signature": "Object getRuntimeState(String property)", "full_signature": "public Object getRuntimeState(String property)", "class_method_signature": "DiskLogger.getRuntimeState(String property)", "testcase": false, "constructor": false}, {"identifier": "getRuntimeState", "parameters": "()", "modifiers": "public", "return": "Map<String, Object>", "signature": "Map<String, Object> getRuntimeState()", "full_signature": "public Map<String, Object> getRuntimeState()", "class_method_signature": "DiskLogger.getRuntimeState()", "testcase": false, "constructor": false}, {"identifier": "createLogFileName", "parameters": "()", "modifiers": "private", "return": "String", "signature": "String createLogFileName()", "full_signature": "private String createLogFileName()", "class_method_signature": "DiskLogger.createLogFileName()", "testcase": false, "constructor": false}, {"identifier": "cleanUp", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void cleanUp()", "full_signature": "private void cleanUp()", "class_method_signature": "DiskLogger.cleanUp()", "testcase": false, "constructor": false}, {"identifier": "processLogEntries", "parameters": "(List<LogEntry> entries)", "modifiers": "private final", "return": "void", "signature": "void processLogEntries(List<LogEntry> entries)", "full_signature": "private final void processLogEntries(List<LogEntry> entries)", "class_method_signature": "DiskLogger.processLogEntries(List<LogEntry> entries)", "testcase": false, "constructor": false}, {"identifier": "createLogFileName", "parameters": "(int viewId, long sequenceNo)", "modifiers": "final static", "return": "String", "signature": "String createLogFileName(int viewId, long sequenceNo)", "full_signature": "final static String createLogFileName(int viewId, long sequenceNo)", "class_method_signature": "DiskLogger.createLogFileName(int viewId, long sequenceNo)", "testcase": false, "constructor": false}, {"identifier": "disassembleLogFileName", "parameters": "(String name)", "modifiers": "final static", "return": "LSN", "signature": "LSN disassembleLogFileName(String name)", "full_signature": "final static LSN disassembleLogFileName(String name)", "class_method_signature": "DiskLogger.disassembleLogFileName(String name)", "testcase": false, "constructor": false}, {"identifier": "loadLogFile", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void loadLogFile()", "full_signature": "private void loadLogFile()", "class_method_signature": "DiskLogger.loadLogFile()", "testcase": false, "constructor": false}], "file": "java/babudb-core/src/main/java/org/xtreemfs/babudb/log/DiskLogger.java"}, "focal_method": {"identifier": "switchLogFile", "parameters": "(boolean incrementViewId)", "modifiers": "public", "return": "LSN", "body": "public LSN switchLogFile(boolean incrementViewId) throws IOException {\n        if (!hasLock()) {\n            throw new IllegalStateException(\"the lock is held by another thread or the logger is not locked.\");\n        }\n\n        // get last synchronized LSN and increment the viewId if needed\n        LSN lastSyncedLSN = null;\n        if (incrementViewId) {\n            int view = currentViewId.getAndIncrement();\n            long seq = nextLogSequenceNo.getAndSet(1L) - 1L;\n\n            assert (seq != 0) : \"Checkpoint after checkpoint is not allowed!\";\n\n            lastSyncedLSN = new LSN(view, seq);\n        } else {\n            lastSyncedLSN = new LSN(currentViewId.get(), nextLogSequenceNo.get() - 1L);\n        }\n\n        dropLogFile();\n        loadLogFile();\n\n        return lastSyncedLSN;\n    }", "signature": "LSN switchLogFile(boolean incrementViewId)", "full_signature": "public LSN switchLogFile(boolean incrementViewId)", "class_method_signature": "DiskLogger.switchLogFile(boolean incrementViewId)", "testcase": false, "constructor": false, "invocations": ["hasLock", "getAndIncrement", "getAndSet", "get", "get", "dropLogFile", "loadLogFile"]}, "repository": {"repo_id": 20433978, "url": "https://github.com/xtreemfs/babudb", "language": "Java", "is_fork": false, "fork_count": 12, "stargazer_count": 37, "size": 19631, "license": "licensed"}}