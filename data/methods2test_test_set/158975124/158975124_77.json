{"test_class": {"identifier": "LogReplayerTest", "superclass": "", "interfaces": "", "fields": [], "file": "server/src/test/java/org/apache/iotdb/db/writelog/recover/LogReplayerTest.java"}, "test_case": {"identifier": "test", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void test()\n      throws IOException, StorageGroupProcessorException, QueryProcessException, MetadataException {\n    String logNodePrefix = \"testLogNode\";\n    File tsFile = SystemFileFactory.INSTANCE.getFile(\"temp\", \"1-1-1.tsfile\");\n    File modF = SystemFileFactory.INSTANCE.getFile(\"test.mod\");\n    ModificationFile modFile = new ModificationFile(modF.getPath());\n    VersionController versionController = new VersionController() {\n      @Override\n      public long nextVersion() {\n        return 5;\n      }\n\n      @Override\n      public long currVersion() {\n        return 5;\n      }\n    };\n    TsFileResource tsFileResource = new TsFileResource(tsFile);\n    IMemTable memTable = new PrimitiveMemTable();\n\n    IoTDB.metaManager.setStorageGroup(new PartialPath(\"root.sg\"));\n    try {\n      for (int i = 0; i <= 5; i++) {\n        for (int j = 0; j <= 5; j++) {\n          IoTDB.metaManager\n              .createTimeseries(new PartialPath(\"root.sg.device\" + i + \".sensor\" + j), TSDataType.INT64,\n                  TSEncoding.PLAIN, TSFileDescriptor.getInstance().getConfig().getCompressor(),\n                  Collections.emptyMap());\n        }\n      }\n\n      LogReplayer replayer = new LogReplayer(logNodePrefix, tsFile.getPath(), modFile,\n          versionController, tsFileResource, memTable, false);\n\n      WriteLogNode node =\n          MultiFileLogNodeManager.getInstance().getNode(logNodePrefix + tsFile.getName());\n      node.write(\n          new InsertRowPlan(new PartialPath(\"root.sg.device0\"), 100, \"sensor0\", TSDataType.INT64,\n              String.valueOf(0)));\n      node.write(\n          new InsertRowPlan(new PartialPath(\"root.sg.device0\"), 2, \"sensor1\", TSDataType.INT64, String.valueOf(0)));\n      for (int i = 1; i < 5; i++) {\n        node.write(new InsertRowPlan(new PartialPath(\"root.sg.device\" + i), i, \"sensor\" + i, TSDataType.INT64,\n            String.valueOf(i)));\n      }\n      node.write(insertTablePlan());\n      DeletePlan deletePlan = new DeletePlan(0, 200, new PartialPath(\"root.sg.device0.sensor0\"));\n      node.write(deletePlan);\n      node.close();\n\n      replayer.replayLogs();\n\n      for (int i = 0; i < 5; i++) {\n        ReadOnlyMemChunk memChunk = memTable\n            .query(\"root.sg.device\" + i, \"sensor\" + i, TSDataType.INT64,\n                TSEncoding.RLE, Collections.emptyMap(), Long.MIN_VALUE);\n        IPointReader iterator = memChunk.getPointReader();\n        if (i == 0) {\n          assertFalse(iterator.hasNextTimeValuePair());\n        } else {\n          assertTrue(iterator.hasNextTimeValuePair());\n          TimeValuePair timeValuePair = iterator.nextTimeValuePair();\n          assertEquals(i, timeValuePair.getTimestamp());\n          assertEquals(i, timeValuePair.getValue().getLong());\n          assertFalse(iterator.hasNextTimeValuePair());\n        }\n      }\n\n      Modification[] mods = modFile.getModifications().toArray(new Modification[0]);\n      assertEquals(1, mods.length);\n      assertEquals(\"root.sg.device0.sensor0\", mods[0].getPathString());\n      assertEquals(5, mods[0].getVersionNum());\n      assertEquals(((Deletion) mods[0]).getEndTime(), 200);\n\n      assertEquals(2, tsFileResource.getStartTime(\"root.sg.device0\"));\n      assertEquals(100, tsFileResource.getEndTime(\"root.sg.device0\"));\n      for (int i = 1; i < 5; i++) {\n        assertEquals(i, tsFileResource.getStartTime(\"root.sg.device\" + i));\n        assertEquals(i, tsFileResource.getEndTime(\"root.sg.device\" + i));\n      }\n\n      //test insert tablet\n      for (int i = 0; i < 2 ; i++) {\n        ReadOnlyMemChunk memChunk = memTable\n            .query(\"root.sg.device5\", \"sensor\" + i, TSDataType.INT64,\n                TSEncoding.PLAIN, Collections.emptyMap(), Long.MIN_VALUE);\n        //s0 has datatype boolean, but required INT64, will return null\n        if (i == 0) {\n          assertNull(memChunk);\n        } else {\n          IPointReader iterator = memChunk.getPointReader();\n          iterator.hasNextTimeValuePair();\n          for (int time = 0; time < 100; time++) {\n            TimeValuePair timeValuePair = iterator.nextTimeValuePair();\n            assertEquals(time, timeValuePair.getTimestamp());\n            assertEquals(time, timeValuePair.getValue().getLong());\n          }\n        }\n      }\n    } finally {\n      modFile.close();\n      MultiFileLogNodeManager.getInstance().deleteNode(logNodePrefix + tsFile.getName());\n      modF.delete();\n      tsFile.delete();\n      tsFile.getParentFile().delete();\n    }\n  }", "signature": "void test()", "full_signature": "@Test public void test()", "class_method_signature": "LogReplayerTest.test()", "testcase": true, "constructor": false, "invocations": ["getFile", "getFile", "getPath", "setStorageGroup", "createTimeseries", "getCompressor", "getConfig", "getInstance", "emptyMap", "getPath", "getNode", "getInstance", "getName", "write", "valueOf", "write", "valueOf", "write", "valueOf", "write", "insertTablePlan", "write", "close", "replayLogs", "query", "emptyMap", "getPointReader", "assertFalse", "hasNextTimeValuePair", "assertTrue", "hasNextTimeValuePair", "nextTimeValuePair", "assertEquals", "getTimestamp", "assertEquals", "getLong", "getValue", "assertFalse", "hasNextTimeValuePair", "toArray", "getModifications", "assertEquals", "assertEquals", "getPathString", "assertEquals", "getVersionNum", "assertEquals", "getEndTime", "assertEquals", "getStartTime", "assertEquals", "getEndTime", "assertEquals", "getStartTime", "assertEquals", "getEndTime", "query", "emptyMap", "assertNull", "getPointReader", "hasNextTimeValuePair", "nextTimeValuePair", "assertEquals", "getTimestamp", "assertEquals", "getLong", "getValue", "close", "deleteNode", "getInstance", "getName", "delete", "delete", "delete", "getParentFile"]}, "focal_class": {"identifier": "LogReplayer", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Logger logger = LoggerFactory.getLogger(LogReplayer.class);", "modifier": "private", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(LogReplayer.class)", "var_name": "logger"}, {"original_string": "private String logNodePrefix;", "modifier": "private", "type": "String", "declarator": "logNodePrefix", "var_name": "logNodePrefix"}, {"original_string": "private String insertFilePath;", "modifier": "private", "type": "String", "declarator": "insertFilePath", "var_name": "insertFilePath"}, {"original_string": "private ModificationFile modFile;", "modifier": "private", "type": "ModificationFile", "declarator": "modFile", "var_name": "modFile"}, {"original_string": "private VersionController versionController;", "modifier": "private", "type": "VersionController", "declarator": "versionController", "var_name": "versionController"}, {"original_string": "private TsFileResource currentTsFileResource;", "modifier": "private", "type": "TsFileResource", "declarator": "currentTsFileResource", "var_name": "currentTsFileResource"}, {"original_string": "private IMemTable recoverMemTable;", "modifier": "private", "type": "IMemTable", "declarator": "recoverMemTable", "var_name": "recoverMemTable"}, {"original_string": "private boolean sequence;", "modifier": "private", "type": "boolean", "declarator": "sequence", "var_name": "sequence"}, {"original_string": "private Map<String, Long> tempStartTimeMap = new HashMap<>();", "modifier": "private", "type": "Map<String, Long>", "declarator": "tempStartTimeMap = new HashMap<>()", "var_name": "tempStartTimeMap"}, {"original_string": "private Map<String, Long> tempEndTimeMap = new HashMap<>();", "modifier": "private", "type": "Map<String, Long>", "declarator": "tempEndTimeMap = new HashMap<>()", "var_name": "tempEndTimeMap"}], "methods": [{"identifier": "LogReplayer", "parameters": "(String logNodePrefix, String insertFilePath, ModificationFile modFile,\n      VersionController versionController, TsFileResource currentTsFileResource,\n      IMemTable memTable, boolean sequence)", "modifiers": "public", "return": "", "signature": " LogReplayer(String logNodePrefix, String insertFilePath, ModificationFile modFile,\n      VersionController versionController, TsFileResource currentTsFileResource,\n      IMemTable memTable, boolean sequence)", "full_signature": "public  LogReplayer(String logNodePrefix, String insertFilePath, ModificationFile modFile,\n      VersionController versionController, TsFileResource currentTsFileResource,\n      IMemTable memTable, boolean sequence)", "class_method_signature": "LogReplayer.LogReplayer(String logNodePrefix, String insertFilePath, ModificationFile modFile,\n      VersionController versionController, TsFileResource currentTsFileResource,\n      IMemTable memTable, boolean sequence)", "testcase": false, "constructor": true}, {"identifier": "replayLogs", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void replayLogs()", "full_signature": "public void replayLogs()", "class_method_signature": "LogReplayer.replayLogs()", "testcase": false, "constructor": false}, {"identifier": "replayDelete", "parameters": "(DeletePlan deletePlan)", "modifiers": "private", "return": "void", "signature": "void replayDelete(DeletePlan deletePlan)", "full_signature": "private void replayDelete(DeletePlan deletePlan)", "class_method_signature": "LogReplayer.replayDelete(DeletePlan deletePlan)", "testcase": false, "constructor": false}, {"identifier": "replayInsert", "parameters": "(InsertPlan plan)", "modifiers": "@SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning private", "return": "void", "signature": "void replayInsert(InsertPlan plan)", "full_signature": "@SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning private void replayInsert(InsertPlan plan)", "class_method_signature": "LogReplayer.replayInsert(InsertPlan plan)", "testcase": false, "constructor": false}, {"identifier": "replayUpdate", "parameters": "(UpdatePlan updatePlan)", "modifiers": "@SuppressWarnings(\"unused\") private", "return": "void", "signature": "void replayUpdate(UpdatePlan updatePlan)", "full_signature": "@SuppressWarnings(\"unused\") private void replayUpdate(UpdatePlan updatePlan)", "class_method_signature": "LogReplayer.replayUpdate(UpdatePlan updatePlan)", "testcase": false, "constructor": false}, {"identifier": "checkDataTypeAndMarkFailed", "parameters": "(final MeasurementMNode[] mNodes, InsertPlan tPlan)", "modifiers": "private", "return": "void", "signature": "void checkDataTypeAndMarkFailed(final MeasurementMNode[] mNodes, InsertPlan tPlan)", "full_signature": "private void checkDataTypeAndMarkFailed(final MeasurementMNode[] mNodes, InsertPlan tPlan)", "class_method_signature": "LogReplayer.checkDataTypeAndMarkFailed(final MeasurementMNode[] mNodes, InsertPlan tPlan)", "testcase": false, "constructor": false}], "file": "server/src/main/java/org/apache/iotdb/db/writelog/recover/LogReplayer.java"}, "focal_method": {"identifier": "replayLogs", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void replayLogs() {\n    WriteLogNode logNode = MultiFileLogNodeManager.getInstance().getNode(\n        logNodePrefix + FSFactoryProducer.getFSFactory().getFile(insertFilePath).getName());\n\n    ILogReader logReader = logNode.getLogReader();\n    try {\n      while (logReader.hasNext()) {\n        try {\n          PhysicalPlan plan = logReader.next();\n          if (plan instanceof InsertPlan) {\n            replayInsert((InsertPlan) plan);\n          } else if (plan instanceof DeletePlan) {\n            replayDelete((DeletePlan) plan);\n          } else if (plan instanceof UpdatePlan) {\n            replayUpdate((UpdatePlan) plan);\n          }\n        } catch (Exception e) {\n          logger.error(\"recover wal of {} failed\", insertFilePath, e);\n        }\n      }\n    } catch (IOException e) {\n      logger.error(\"meet error when redo wal of {}\", insertFilePath, e);\n    } finally {\n      logReader.close();\n      try {\n        modFile.close();\n      } catch (IOException e) {\n        logger.error(\"Canno close the modifications file {}\", modFile.getFilePath(), e);\n      }\n    }\n    tempStartTimeMap.forEach((k, v) -> currentTsFileResource.updateStartTime(k, v));\n    tempEndTimeMap.forEach((k, v) -> currentTsFileResource.updateEndTime(k, v));\n  }", "signature": "void replayLogs()", "full_signature": "public void replayLogs()", "class_method_signature": "LogReplayer.replayLogs()", "testcase": false, "constructor": false, "invocations": ["getNode", "getInstance", "getName", "getFile", "getFSFactory", "getLogReader", "hasNext", "next", "replayInsert", "replayDelete", "replayUpdate", "error", "error", "close", "close", "error", "getFilePath", "forEach", "updateStartTime", "forEach", "updateEndTime"]}, "repository": {"repo_id": 158975124, "url": "https://github.com/apache/incubator-iotdb", "stars": 449, "created": "11/24/2018 9:29:17 PM +00:00", "updates": "2020-01-21T08:10:15+00:00", "fork": "False", "license": "licensed"}}