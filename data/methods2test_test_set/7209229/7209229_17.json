{"test_class": {"identifier": "TestNettyHttpDatabusBootstrapConnection", "superclass": "", "interfaces": "", "fields": [{"original_string": "static NettyHttpConnectionFactory CONN_FACTORY;", "modifier": "static", "type": "NettyHttpConnectionFactory", "declarator": "CONN_FACTORY", "var_name": "CONN_FACTORY"}, {"original_string": "static SimpleTestServerConnection _dummyServer;", "modifier": "static", "type": "SimpleTestServerConnection", "declarator": "_dummyServer", "var_name": "_dummyServer"}, {"original_string": "static final int SERVER_ADDRESS_ID = 15466;", "modifier": "static final", "type": "int", "declarator": "SERVER_ADDRESS_ID = 15466", "var_name": "SERVER_ADDRESS_ID"}, {"original_string": "static final long DEFAULT_READ_TIMEOUT_MS = 10000;", "modifier": "static final", "type": "long", "declarator": "DEFAULT_READ_TIMEOUT_MS = 10000", "var_name": "DEFAULT_READ_TIMEOUT_MS"}, {"original_string": "static final long DEFAULT_WRITE_TIMEOUT_MS = 10000;", "modifier": "static final", "type": "long", "declarator": "DEFAULT_WRITE_TIMEOUT_MS = 10000", "var_name": "DEFAULT_WRITE_TIMEOUT_MS"}, {"original_string": "static final ExecutorService BOSS_POOL = Executors.newCachedThreadPool();", "modifier": "static final", "type": "ExecutorService", "declarator": "BOSS_POOL = Executors.newCachedThreadPool()", "var_name": "BOSS_POOL"}, {"original_string": "static final ExecutorService IO_POOL = Executors.newCachedThreadPool();", "modifier": "static final", "type": "ExecutorService", "declarator": "IO_POOL = Executors.newCachedThreadPool()", "var_name": "IO_POOL"}, {"original_string": "static final Timer NETWORK_TIMER = new HashedWheelTimer(10, TimeUnit.MILLISECONDS);", "modifier": "static final", "type": "Timer", "declarator": "NETWORK_TIMER = new HashedWheelTimer(10, TimeUnit.MILLISECONDS)", "var_name": "NETWORK_TIMER"}, {"original_string": "static int MAX_EVENT_VERSION = DbusEventFactory.DBUS_EVENT_V2;", "modifier": "static", "type": "int", "declarator": "MAX_EVENT_VERSION = DbusEventFactory.DBUS_EVENT_V2", "var_name": "MAX_EVENT_VERSION"}, {"original_string": "static final ChannelGroup TEST_CHANNELS_GROUP = new DefaultChannelGroup();", "modifier": "static final", "type": "ChannelGroup", "declarator": "TEST_CHANNELS_GROUP = new DefaultChannelGroup()", "var_name": "TEST_CHANNELS_GROUP"}, {"original_string": "static final String SOURCE1_NAME = \"test.source1\";", "modifier": "static final", "type": "String", "declarator": "SOURCE1_NAME = \"test.source1\"", "var_name": "SOURCE1_NAME"}, {"original_string": "static final ServerInfo BOOTSTRAP_SERVER_INFO =\n      new ServerInfo(\"testBootstrap\", \"master\", new InetSocketAddress(SERVER_ADDRESS_ID), SOURCE1_NAME);", "modifier": "static final", "type": "ServerInfo", "declarator": "BOOTSTRAP_SERVER_INFO =\n      new ServerInfo(\"testBootstrap\", \"master\", new InetSocketAddress(SERVER_ADDRESS_ID), SOURCE1_NAME)", "var_name": "BOOTSTRAP_SERVER_INFO"}], "file": "databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/netty/TestNettyHttpDatabusBootstrapConnection.java"}, "test_case": {"identifier": "testServerBootstrapDisconnect", "parameters": "()", "modifiers": "@Test /** * This is a unit test for DDSDBUS-3537. There is a lag between a network channel disconnect and the * state change in AbstractNettyHttpConnection. This can cause a race condition in various requestXXX objects which * check the state of the connection using the network channel. As a result, they may attempt to reconnect while * AbstractNettyHttpConnection is still in CONNECTED state which causes an error for an incorrect transition * CONNECTED -> CONNECTING. * * The test simulates the above condition by injecting a handler in the client pipeline which artificially holds up * the channelClosed message. As a result we can inject a request while the netty channel is disconnected but the * AbstractNettyHttpConnection object has not detected this yet. */ public", "return": "void", "body": "@Test\n  /**\n   * This is a unit test for DDSDBUS-3537. There is a lag between a network channel disconnect and the\n   * state change in AbstractNettyHttpConnection. This can cause a race condition in various requestXXX objects which\n   * check the state of the connection using the network channel. As a result, they may attempt to reconnect while\n   * AbstractNettyHttpConnection is still in CONNECTED state which causes an error for an incorrect transition\n   * CONNECTED -> CONNECTING.\n   *\n   *  The test simulates the above condition by injecting a handler in the client pipeline which artificially holds up\n   *  the channelClosed message. As a result we can inject a request while the netty channel is disconnected but the\n   *  AbstractNettyHttpConnection object has not detected this yet.\n   */\n  public void testServerBootstrapDisconnect() throws Exception\n  {\n    final Logger log = Logger.getLogger(\"TestNettyHttpDatabusBootstrapConnection.testServerBootstrapDisconnect\");\n    log.info(\"starting\");\n\n    log.info(\"setup the client\");\n    TestingConnectionCallback callback = TestingConnectionCallback.createAndStart(\"testServerSourcesDisconnect\");\n    DummyRemoteExceptionHandler remoteExceptionHandler = new DummyRemoteExceptionHandler();\n    final NettyHttpDatabusBootstrapConnection conn =\n        (NettyHttpDatabusBootstrapConnection)\n        CONN_FACTORY.createConnection(BOOTSTRAP_SERVER_INFO, callback, remoteExceptionHandler);\n    try\n    {\n      log.info(\"initial setup\");\n      final List<String> sourceNamesList = Arrays.asList(SOURCE1_NAME);\n      final Checkpoint cp = Checkpoint.createOnlineConsumptionCheckpoint(0);\n      BootstrapCheckpointHandler cpHandler = new BootstrapCheckpointHandler(sourceNamesList);\n      cpHandler.createInitialBootstrapCheckpoint(cp, 0L);\n      final DummyDatabusBootstrapConnectionStateMessage bstCallback =\n          new DummyDatabusBootstrapConnectionStateMessage(log);\n\n      log.info(\"process a normal startSCN which should establish the connection\");\n      sendStartScnHappyPath(conn, cp, bstCallback, SOURCE1_NAME, 100L, log);\n      Assert.assertTrue(conn.isConnected());\n\n      //wait for the response\n      TestUtil.assertWithBackoff(new ConditionCheck()\n      {\n        @Override\n        public boolean check()\n        {\n          return null != bstCallback.getCheckpoint();\n        }\n      }, \"wait for /startSCN response\", 100, log);\n\n      log.info(\"verify /startSCN response\");\n      final Checkpoint startScnCp = bstCallback.getCheckpoint();\n      Assert.assertNotNull(startScnCp);\n      Assert.assertEquals(100L, startScnCp.getBootstrapStartScn().longValue());\n\n      log.info(\"instrument the client pipeline so that we can intercept and delay the channelClosed message\");\n      final Semaphore passMessage = new Semaphore(1);\n      final CountDownLatch closeSent = new CountDownLatch(1);\n      passMessage.acquire();\n      conn._channel.getPipeline().addBefore(\"handler\", \"closeChannelDelay\",\n          new SimpleChannelHandler(){\n            @Override\n            public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n              closeSent.countDown();\n              passMessage.acquire();\n              try\n              {\n                super.channelClosed(ctx, e);\n              }\n              finally\n              {\n                passMessage.release();\n              }\n            }\n      });\n\n      final Channel serverChannel = getServerChannelForClientConn(conn);\n      Thread asyncChannelClose = new Thread(new Runnable()\n      {\n        @Override\n        public void run()\n        {\n          log.info(\"closing server channel\");\n          serverChannel.close();\n          log.info(\"server channel: closed\");\n          closeSent.countDown();\n        }\n      }, \"asyncChannelCloseThread\");\n      asyncChannelClose.setDaemon(true);\n\n      Thread asyncBootstrapReq = new Thread(new Runnable()\n      {\n        @Override\n        public void run()\n        {\n          conn.requestStream(\"1\", null, 10000, startScnCp, bstCallback);\n        }\n      }, \"asyncBootstrapReqThread\");\n      asyncBootstrapReq.setDaemon(true);\n\n      log.info(\"simultaneously closing connection and sending /bootstrap request\");\n      bstCallback.reset();\n      asyncChannelClose.start();\n      Assert.assertTrue(closeSent.await(1000, TimeUnit.MILLISECONDS));\n      TestUtil.assertWithBackoff(new ConditionCheck()\n      {\n        @Override\n        public boolean check()\n        {\n          return !conn._channel.isConnected();\n        }\n      }, \"waiting for disconnect on the client side\", 1000, log);\n      Assert.assertEquals(AbstractNettyHttpConnection.State.CONNECTED, conn.getNetworkState());\n      log.info(\"asynchronously sending /bootstrap\");\n      asyncBootstrapReq.start();\n\n      log.info(\"letting channelClose get through\");\n      TestUtil.assertWithBackoff(new ConditionCheck()\n      {\n        @Override\n        public boolean check()\n        {\n          return bstCallback.isStreamRequestError();\n        }\n      }, \"wait for streamRequestError callback\", 1000, log);\n      passMessage.release();\n      log.info(\"finished\");\n    }\n    finally\n    {\n      conn.close();\n      callback.shutdown();\n      log.info(\"cleaned\");\n    }\n  }", "signature": "void testServerBootstrapDisconnect()", "full_signature": "@Test /** * This is a unit test for DDSDBUS-3537. There is a lag between a network channel disconnect and the * state change in AbstractNettyHttpConnection. This can cause a race condition in various requestXXX objects which * check the state of the connection using the network channel. As a result, they may attempt to reconnect while * AbstractNettyHttpConnection is still in CONNECTED state which causes an error for an incorrect transition * CONNECTED -> CONNECTING. * * The test simulates the above condition by injecting a handler in the client pipeline which artificially holds up * the channelClosed message. As a result we can inject a request while the netty channel is disconnected but the * AbstractNettyHttpConnection object has not detected this yet. */ public void testServerBootstrapDisconnect()", "class_method_signature": "TestNettyHttpDatabusBootstrapConnection.testServerBootstrapDisconnect()", "testcase": true, "constructor": false, "invocations": ["getLogger", "info", "info", "createAndStart", "createConnection", "info", "asList", "createOnlineConsumptionCheckpoint", "createInitialBootstrapCheckpoint", "info", "sendStartScnHappyPath", "assertTrue", "isConnected", "assertWithBackoff", "getCheckpoint", "info", "getCheckpoint", "assertNotNull", "assertEquals", "longValue", "getBootstrapStartScn", "info", "acquire", "addBefore", "getPipeline", "countDown", "acquire", "channelClosed", "release", "getServerChannelForClientConn", "info", "close", "info", "countDown", "setDaemon", "requestStream", "setDaemon", "info", "reset", "start", "assertTrue", "await", "assertWithBackoff", "isConnected", "assertEquals", "getNetworkState", "info", "start", "info", "assertWithBackoff", "isStreamRequestError", "release", "info", "close", "shutdown", "info"]}, "focal_class": {"identifier": "NettyHttpDatabusBootstrapConnection", "superclass": "extends AbstractNettyHttpConnection", "interfaces": "implements DatabusBootstrapConnection", "fields": [{"original_string": "public static final String MODULE = NettyHttpDatabusBootstrapConnection.class.getName();", "modifier": "public static final", "type": "String", "declarator": "MODULE = NettyHttpDatabusBootstrapConnection.class.getName()", "var_name": "MODULE"}, {"original_string": "public static final Logger LOG = Logger.getLogger(MODULE);", "modifier": "public static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(MODULE)", "var_name": "LOG"}, {"original_string": "private final ActorMessageQueue _callback;", "modifier": "private final", "type": "ActorMessageQueue", "declarator": "_callback", "var_name": "_callback"}, {"original_string": "private DatabusBootstrapConnectionStateMessage _callbackStateReuse;", "modifier": "private", "type": "DatabusBootstrapConnectionStateMessage", "declarator": "_callbackStateReuse", "var_name": "_callbackStateReuse"}, {"original_string": "private ExtendedReadTimeoutHandler _readTimeOutHandler;", "modifier": "private", "type": "ExtendedReadTimeoutHandler", "declarator": "_readTimeOutHandler", "var_name": "_readTimeOutHandler"}, {"original_string": "private State _curState;", "modifier": "private", "type": "State", "declarator": "_curState", "var_name": "_curState"}, {"original_string": "private Checkpoint _checkpoint;", "modifier": "private", "type": "Checkpoint", "declarator": "_checkpoint", "var_name": "_checkpoint"}, {"original_string": "private String _sourcesIdList;", "modifier": "private", "type": "String", "declarator": "_sourcesIdList", "var_name": "_sourcesIdList"}, {"original_string": "private String _sourcesNameList;", "modifier": "private", "type": "String", "declarator": "_sourcesNameList", "var_name": "_sourcesNameList"}, {"original_string": "private int _freeBufferSpace;", "modifier": "private", "type": "int", "declarator": "_freeBufferSpace", "var_name": "_freeBufferSpace"}, {"original_string": "private final RemoteExceptionHandler _remoteExceptionHandler;", "modifier": "private final", "type": "RemoteExceptionHandler", "declarator": "_remoteExceptionHandler", "var_name": "_remoteExceptionHandler"}, {"original_string": "private DbusKeyFilter _filter;", "modifier": "private", "type": "DbusKeyFilter", "declarator": "_filter", "var_name": "_filter"}, {"original_string": "private GenericHttpResponseHandler _handler;", "modifier": "private", "type": "GenericHttpResponseHandler", "declarator": "_handler", "var_name": "_handler"}], "methods": [{"identifier": "NettyHttpDatabusBootstrapConnection", "parameters": "(ServerInfo server,\n                                         ActorMessageQueue callback,\n                                         ClientBootstrap bootstrap,\n                                         ContainerStatisticsCollector containerStatsCollector,\n                                         RemoteExceptionHandler remoteExceptionHandler,\n                                         Timer timeoutTimer,\n                                         long writeTimeoutMs,\n                                         long readTimeoutMs,\n                                         int protocolVersion,\n                                         ChannelGroup channelGroup)", "modifiers": "public", "return": "", "signature": " NettyHttpDatabusBootstrapConnection(ServerInfo server,\n                                         ActorMessageQueue callback,\n                                         ClientBootstrap bootstrap,\n                                         ContainerStatisticsCollector containerStatsCollector,\n                                         RemoteExceptionHandler remoteExceptionHandler,\n                                         Timer timeoutTimer,\n                                         long writeTimeoutMs,\n                                         long readTimeoutMs,\n                                         int protocolVersion,\n                                         ChannelGroup channelGroup)", "full_signature": "public  NettyHttpDatabusBootstrapConnection(ServerInfo server,\n                                         ActorMessageQueue callback,\n                                         ClientBootstrap bootstrap,\n                                         ContainerStatisticsCollector containerStatsCollector,\n                                         RemoteExceptionHandler remoteExceptionHandler,\n                                         Timer timeoutTimer,\n                                         long writeTimeoutMs,\n                                         long readTimeoutMs,\n                                         int protocolVersion,\n                                         ChannelGroup channelGroup)", "class_method_signature": "NettyHttpDatabusBootstrapConnection.NettyHttpDatabusBootstrapConnection(ServerInfo server,\n                                         ActorMessageQueue callback,\n                                         ClientBootstrap bootstrap,\n                                         ContainerStatisticsCollector containerStatsCollector,\n                                         RemoteExceptionHandler remoteExceptionHandler,\n                                         Timer timeoutTimer,\n                                         long writeTimeoutMs,\n                                         long readTimeoutMs,\n                                         int protocolVersion,\n                                         ChannelGroup channelGroup)", "testcase": false, "constructor": true}, {"identifier": "NettyHttpDatabusBootstrapConnection", "parameters": "(ServerInfo relay,\n                                             ActorMessageQueue callback,\n                                             ChannelFactory channelFactory,\n                                             ContainerStatisticsCollector containerStatsCollector,\n                                             RemoteExceptionHandler remoteExceptionHandler,\n                                             Timer timeoutTimer,\n                                             long writeTimeoutMs,\n                                             long readTimeoutMs,\n                                             int protocolVersion,\n                                             ChannelGroup channelGroup)", "modifiers": "public", "return": "", "signature": " NettyHttpDatabusBootstrapConnection(ServerInfo relay,\n                                             ActorMessageQueue callback,\n                                             ChannelFactory channelFactory,\n                                             ContainerStatisticsCollector containerStatsCollector,\n                                             RemoteExceptionHandler remoteExceptionHandler,\n                                             Timer timeoutTimer,\n                                             long writeTimeoutMs,\n                                             long readTimeoutMs,\n                                             int protocolVersion,\n                                             ChannelGroup channelGroup)", "full_signature": "public  NettyHttpDatabusBootstrapConnection(ServerInfo relay,\n                                             ActorMessageQueue callback,\n                                             ChannelFactory channelFactory,\n                                             ContainerStatisticsCollector containerStatsCollector,\n                                             RemoteExceptionHandler remoteExceptionHandler,\n                                             Timer timeoutTimer,\n                                             long writeTimeoutMs,\n                                             long readTimeoutMs,\n                                             int protocolVersion,\n                                             ChannelGroup channelGroup)", "class_method_signature": "NettyHttpDatabusBootstrapConnection.NettyHttpDatabusBootstrapConnection(ServerInfo relay,\n                                             ActorMessageQueue callback,\n                                             ChannelFactory channelFactory,\n                                             ContainerStatisticsCollector containerStatsCollector,\n                                             RemoteExceptionHandler remoteExceptionHandler,\n                                             Timer timeoutTimer,\n                                             long writeTimeoutMs,\n                                             long readTimeoutMs,\n                                             int protocolVersion,\n                                             ChannelGroup channelGroup)", "testcase": false, "constructor": true}, {"identifier": "requestTargetScn", "parameters": "(Checkpoint checkpoint, DatabusBootstrapConnectionStateMessage stateReuse)", "modifiers": "@Override public", "return": "void", "signature": "void requestTargetScn(Checkpoint checkpoint, DatabusBootstrapConnectionStateMessage stateReuse)", "full_signature": "@Override public void requestTargetScn(Checkpoint checkpoint, DatabusBootstrapConnectionStateMessage stateReuse)", "class_method_signature": "NettyHttpDatabusBootstrapConnection.requestTargetScn(Checkpoint checkpoint, DatabusBootstrapConnectionStateMessage stateReuse)", "testcase": false, "constructor": false}, {"identifier": "onTargetScnConnectSuccess", "parameters": "()", "modifiers": "", "return": "void", "signature": "void onTargetScnConnectSuccess()", "full_signature": " void onTargetScnConnectSuccess()", "class_method_signature": "NettyHttpDatabusBootstrapConnection.onTargetScnConnectSuccess()", "testcase": false, "constructor": false}, {"identifier": "createTargetScnRequestUrl", "parameters": "()", "modifiers": "private", "return": "String", "signature": "String createTargetScnRequestUrl()", "full_signature": "private String createTargetScnRequestUrl()", "class_method_signature": "NettyHttpDatabusBootstrapConnection.createTargetScnRequestUrl()", "testcase": false, "constructor": false}, {"identifier": "requestStartScn", "parameters": "(Checkpoint checkpoint, DatabusBootstrapConnectionStateMessage stateReuse, String sourceNamesList)", "modifiers": "@Override public", "return": "void", "signature": "void requestStartScn(Checkpoint checkpoint, DatabusBootstrapConnectionStateMessage stateReuse, String sourceNamesList)", "full_signature": "@Override public void requestStartScn(Checkpoint checkpoint, DatabusBootstrapConnectionStateMessage stateReuse, String sourceNamesList)", "class_method_signature": "NettyHttpDatabusBootstrapConnection.requestStartScn(Checkpoint checkpoint, DatabusBootstrapConnectionStateMessage stateReuse, String sourceNamesList)", "testcase": false, "constructor": false}, {"identifier": "onStartScnConnectSuccess", "parameters": "()", "modifiers": "", "return": "void", "signature": "void onStartScnConnectSuccess()", "full_signature": " void onStartScnConnectSuccess()", "class_method_signature": "NettyHttpDatabusBootstrapConnection.onStartScnConnectSuccess()", "testcase": false, "constructor": false}, {"identifier": "createStartScnRequestUrl", "parameters": "()", "modifiers": "private", "return": "String", "signature": "String createStartScnRequestUrl()", "full_signature": "private String createStartScnRequestUrl()", "class_method_signature": "NettyHttpDatabusBootstrapConnection.createStartScnRequestUrl()", "testcase": false, "constructor": false}, {"identifier": "requestStream", "parameters": "(String sourcesIdList, DbusKeyFilter filter,\n\t\t  \t\t\t\t\tint freeBufferSpace, Checkpoint cp,\n                            DatabusBootstrapConnectionStateMessage stateReuse)", "modifiers": "@Override public", "return": "void", "signature": "void requestStream(String sourcesIdList, DbusKeyFilter filter,\n\t\t  \t\t\t\t\tint freeBufferSpace, Checkpoint cp,\n                            DatabusBootstrapConnectionStateMessage stateReuse)", "full_signature": "@Override public void requestStream(String sourcesIdList, DbusKeyFilter filter,\n\t\t  \t\t\t\t\tint freeBufferSpace, Checkpoint cp,\n                            DatabusBootstrapConnectionStateMessage stateReuse)", "class_method_signature": "NettyHttpDatabusBootstrapConnection.requestStream(String sourcesIdList, DbusKeyFilter filter,\n\t\t  \t\t\t\t\tint freeBufferSpace, Checkpoint cp,\n                            DatabusBootstrapConnectionStateMessage stateReuse)", "testcase": false, "constructor": false}, {"identifier": "onStreamConnectSuccess", "parameters": "()", "modifiers": "", "return": "void", "signature": "void onStreamConnectSuccess()", "full_signature": " void onStreamConnectSuccess()", "class_method_signature": "NettyHttpDatabusBootstrapConnection.onStreamConnectSuccess()", "testcase": false, "constructor": false}, {"identifier": "populateBootstrapRequestUrl", "parameters": "(StringBuilder uriString)", "modifiers": "private", "return": "boolean", "signature": "boolean populateBootstrapRequestUrl(StringBuilder uriString)", "full_signature": "private boolean populateBootstrapRequestUrl(StringBuilder uriString)", "class_method_signature": "NettyHttpDatabusBootstrapConnection.populateBootstrapRequestUrl(StringBuilder uriString)", "testcase": false, "constructor": false}, {"identifier": "connect", "parameters": "(State connectState)", "modifiers": "private", "return": "void", "signature": "void connect(State connectState)", "full_signature": "private void connect(State connectState)", "class_method_signature": "NettyHttpDatabusBootstrapConnection.connect(State connectState)", "testcase": false, "constructor": false}, {"identifier": "onConnectSuccess", "parameters": "(Channel channel)", "modifiers": "private", "return": "void", "signature": "void onConnectSuccess(Channel channel)", "full_signature": "private void onConnectSuccess(Channel channel)", "class_method_signature": "NettyHttpDatabusBootstrapConnection.onConnectSuccess(Channel channel)", "testcase": false, "constructor": false}, {"identifier": "getHandler", "parameters": "()", "modifiers": "@Override protected", "return": "GenericHttpResponseHandler", "signature": "GenericHttpResponseHandler getHandler()", "full_signature": "@Override protected GenericHttpResponseHandler getHandler()", "class_method_signature": "NettyHttpDatabusBootstrapConnection.getHandler()", "testcase": false, "constructor": false}, {"identifier": "onRequestFailure", "parameters": "(HttpRequest req, Throwable cause)", "modifiers": "private", "return": "void", "signature": "void onRequestFailure(HttpRequest req, Throwable cause)", "full_signature": "private void onRequestFailure(HttpRequest req, Throwable cause)", "class_method_signature": "NettyHttpDatabusBootstrapConnection.onRequestFailure(HttpRequest req, Throwable cause)", "testcase": false, "constructor": false}, {"identifier": "onRequestFailure", "parameters": "(String req, Throwable cause)", "modifiers": "private", "return": "void", "signature": "void onRequestFailure(String req, Throwable cause)", "full_signature": "private void onRequestFailure(String req, Throwable cause)", "class_method_signature": "NettyHttpDatabusBootstrapConnection.onRequestFailure(String req, Throwable cause)", "testcase": false, "constructor": false}], "file": "databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/NettyHttpDatabusBootstrapConnection.java"}, "focal_method": {"identifier": "requestStream", "parameters": "(String sourcesIdList, DbusKeyFilter filter,\n\t\t  \t\t\t\t\tint freeBufferSpace, Checkpoint cp,\n                            DatabusBootstrapConnectionStateMessage stateReuse)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void requestStream(String sourcesIdList, DbusKeyFilter filter,\n\t\t  \t\t\t\t\tint freeBufferSpace, Checkpoint cp,\n                            DatabusBootstrapConnectionStateMessage stateReuse)\n  {\n    _checkpoint = cp;\n    _callbackStateReuse = stateReuse;\n    _sourcesIdList = sourcesIdList;\n    _freeBufferSpace = freeBufferSpace;\n    _filter = filter;\n    _handler = null;\n\n    if (!hasConnection())\n    {\n      connect(State.STREAM_REQUEST_CONNECT);\n    }\n    else\n    {\n      onStreamConnectSuccess();\n    }\n  }", "signature": "void requestStream(String sourcesIdList, DbusKeyFilter filter,\n\t\t  \t\t\t\t\tint freeBufferSpace, Checkpoint cp,\n                            DatabusBootstrapConnectionStateMessage stateReuse)", "full_signature": "@Override public void requestStream(String sourcesIdList, DbusKeyFilter filter,\n\t\t  \t\t\t\t\tint freeBufferSpace, Checkpoint cp,\n                            DatabusBootstrapConnectionStateMessage stateReuse)", "class_method_signature": "NettyHttpDatabusBootstrapConnection.requestStream(String sourcesIdList, DbusKeyFilter filter,\n\t\t  \t\t\t\t\tint freeBufferSpace, Checkpoint cp,\n                            DatabusBootstrapConnectionStateMessage stateReuse)", "testcase": false, "constructor": false, "invocations": ["hasConnection", "connect", "onStreamConnectSuccess"]}, "repository": {"repo_id": 7209229, "url": "https://github.com/linkedin/databus", "language": "Java", "is_fork": false, "fork_count": 653, "stargazer_count": 2899, "size": 51191, "license": "licensed"}}