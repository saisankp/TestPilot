{"test_class": {"identifier": "TestLocalResourcesTrackerImpl", "superclass": "", "interfaces": "", "fields": [], "file": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/test/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/TestLocalResourcesTrackerImpl.java"}, "test_case": {"identifier": "testLocalResourceCache", "parameters": "()", "modifiers": "@Test(timeout = 1000) @SuppressWarnings(\"unchecked\") public", "return": "void", "body": "@Test(timeout = 1000)\n  @SuppressWarnings(\"unchecked\")\n  public void testLocalResourceCache() {\n    String user = \"testuser\";\n    DrainDispatcher dispatcher = null;\n    try {\n      Configuration conf = new Configuration();\n      dispatcher = createDispatcher(conf);\n\n      EventHandler<LocalizerEvent> localizerEventHandler =\n          mock(EventHandler.class);\n      EventHandler<ContainerEvent> containerEventHandler =\n          mock(EventHandler.class);\n\n      // Registering event handlers.\n      dispatcher.register(LocalizerEventType.class, localizerEventHandler);\n      dispatcher.register(ContainerEventType.class, containerEventHandler);\n\n      ConcurrentMap<LocalResourceRequest, LocalizedResource> localrsrc =\n          new ConcurrentHashMap<LocalResourceRequest, LocalizedResource>();\n      LocalResourcesTracker tracker =\n          new LocalResourcesTrackerImpl(user, null, dispatcher, localrsrc,\n              true, conf, new NMNullStateStoreService());\n\n      LocalResourceRequest lr =\n          createLocalResourceRequest(user, 1, 1, LocalResourceVisibility.PUBLIC);\n\n      // Creating 2 containers for same application which will be requesting\n      // same local resource.\n      // Container 1 requesting local resource.\n      ContainerId cId1 = BuilderUtils.newContainerId(1, 1, 1, 1);\n      LocalizerContext lc1 = new LocalizerContext(user, cId1, null);\n      ResourceEvent reqEvent1 =\n          new ResourceRequestEvent(lr, LocalResourceVisibility.PRIVATE, lc1);\n\n      // No resource request is initially present in local cache\n      Assert.assertEquals(0, localrsrc.size());\n\n      // Container-1 requesting local resource.\n      tracker.handle(reqEvent1);\n      dispatcher.await();\n\n      // New localized Resource should have been added to local resource map\n      // and the requesting container will be added to its waiting queue.\n      Assert.assertEquals(1, localrsrc.size());\n      Assert.assertTrue(localrsrc.containsKey(lr));\n      Assert.assertEquals(1, localrsrc.get(lr).getRefCount());\n      Assert.assertTrue(localrsrc.get(lr).ref.contains(cId1));\n      Assert.assertEquals(ResourceState.DOWNLOADING, localrsrc.get(lr)\n        .getState());\n\n      // Container 2 requesting the resource\n      ContainerId cId2 = BuilderUtils.newContainerId(1, 1, 1, 2);\n      LocalizerContext lc2 = new LocalizerContext(user, cId2, null);\n      ResourceEvent reqEvent2 =\n          new ResourceRequestEvent(lr, LocalResourceVisibility.PRIVATE, lc2);\n      tracker.handle(reqEvent2);\n      dispatcher.await();\n\n      // Container 2 should have been added to the waiting queue of the local\n      // resource\n      Assert.assertEquals(2, localrsrc.get(lr).getRefCount());\n      Assert.assertTrue(localrsrc.get(lr).ref.contains(cId2));\n\n      // Failing resource localization\n      ResourceEvent resourceFailedEvent = new ResourceFailedLocalizationEvent(\n          lr,(new Exception(\"test\").getMessage()));\n      \n      // Backing up the resource to track its state change as it will be\n      // removed after the failed event.\n      LocalizedResource localizedResource = localrsrc.get(lr);\n      \n      tracker.handle(resourceFailedEvent);\n      dispatcher.await();\n\n      // After receiving failed resource event; all waiting containers will be\n      // notified with Container Resource Failed Event.\n      Assert.assertEquals(0, localrsrc.size());\n      verify(containerEventHandler, timeout(1000).times(2)).handle(\n        isA(ContainerResourceFailedEvent.class));\n      Assert.assertEquals(ResourceState.FAILED, localizedResource.getState());\n\n      // Container 1 trying to release the resource (This resource is already\n      // deleted from the cache. This call should return silently without\n      // exception.\n      ResourceReleaseEvent relEvent1 = new ResourceReleaseEvent(lr, cId1);\n      tracker.handle(relEvent1);\n      dispatcher.await();\n\n      // Container-3 now requests for the same resource. This request call\n      // is coming prior to Container-2's release call.\n      ContainerId cId3 = BuilderUtils.newContainerId(1, 1, 1, 3);\n      LocalizerContext lc3 = new LocalizerContext(user, cId3, null);\n      ResourceEvent reqEvent3 =\n          new ResourceRequestEvent(lr, LocalResourceVisibility.PRIVATE, lc3);\n      tracker.handle(reqEvent3);\n      dispatcher.await();\n\n      // Local resource cache now should have the requested resource and the\n      // number of waiting containers should be 1.\n      Assert.assertEquals(1, localrsrc.size());\n      Assert.assertTrue(localrsrc.containsKey(lr));\n      Assert.assertEquals(1, localrsrc.get(lr).getRefCount());\n      Assert.assertTrue(localrsrc.get(lr).ref.contains(cId3));\n\n      // Container-2 Releases the resource\n      ResourceReleaseEvent relEvent2 = new ResourceReleaseEvent(lr, cId2);\n      tracker.handle(relEvent2);\n      dispatcher.await();\n\n      // Making sure that there is no change in the cache after the release.\n      Assert.assertEquals(1, localrsrc.size());\n      Assert.assertTrue(localrsrc.containsKey(lr));\n      Assert.assertEquals(1, localrsrc.get(lr).getRefCount());\n      Assert.assertTrue(localrsrc.get(lr).ref.contains(cId3));\n      \n      // Sending ResourceLocalizedEvent to tracker. In turn resource should\n      // send Container Resource Localized Event to waiting containers.\n      Path localizedPath = new Path(\"/tmp/file1\");\n      ResourceLocalizedEvent localizedEvent =\n          new ResourceLocalizedEvent(lr, localizedPath, 123L);\n      tracker.handle(localizedEvent);\n      dispatcher.await();\n      \n      // Verifying ContainerResourceLocalizedEvent .\n      verify(containerEventHandler, timeout(1000).times(1)).handle(\n        isA(ContainerResourceLocalizedEvent.class));\n      Assert.assertEquals(ResourceState.LOCALIZED, localrsrc.get(lr)\n        .getState());\n      Assert.assertEquals(1, localrsrc.get(lr).getRefCount());\n      \n      // Container-3 releasing the resource.\n      ResourceReleaseEvent relEvent3 = new ResourceReleaseEvent(lr, cId3);\n      tracker.handle(relEvent3);\n      dispatcher.await();\n      \n      Assert.assertEquals(0, localrsrc.get(lr).getRefCount());\n      \n    } finally {\n      if (dispatcher != null) {\n        dispatcher.stop();\n      }\n    }\n  }", "signature": "void testLocalResourceCache()", "full_signature": "@Test(timeout = 1000) @SuppressWarnings(\"unchecked\") public void testLocalResourceCache()", "class_method_signature": "TestLocalResourcesTrackerImpl.testLocalResourceCache()", "testcase": true, "constructor": false, "invocations": ["createDispatcher", "mock", "mock", "register", "register", "createLocalResourceRequest", "newContainerId", "assertEquals", "size", "handle", "await", "assertEquals", "size", "assertTrue", "containsKey", "assertEquals", "getRefCount", "get", "assertTrue", "contains", "get", "assertEquals", "getState", "get", "newContainerId", "handle", "await", "assertEquals", "getRefCount", "get", "assertTrue", "contains", "get", "getMessage", "get", "handle", "await", "assertEquals", "size", "handle", "verify", "times", "timeout", "isA", "assertEquals", "getState", "handle", "await", "newContainerId", "handle", "await", "assertEquals", "size", "assertTrue", "containsKey", "assertEquals", "getRefCount", "get", "assertTrue", "contains", "get", "handle", "await", "assertEquals", "size", "assertTrue", "containsKey", "assertEquals", "getRefCount", "get", "assertTrue", "contains", "get", "handle", "await", "handle", "verify", "times", "timeout", "isA", "assertEquals", "getState", "get", "assertEquals", "getRefCount", "get", "handle", "await", "assertEquals", "getRefCount", "get", "stop"]}, "focal_class": {"identifier": "LocalResourcesTrackerImpl", "superclass": "", "interfaces": "implements LocalResourcesTracker", "fields": [{"original_string": "static final Log LOG = LogFactory.getLog(LocalResourcesTrackerImpl.class);", "modifier": "static final", "type": "Log", "declarator": "LOG = LogFactory.getLog(LocalResourcesTrackerImpl.class)", "var_name": "LOG"}, {"original_string": "private static final String RANDOM_DIR_REGEX = \"-?\\\\d+\";", "modifier": "private static final", "type": "String", "declarator": "RANDOM_DIR_REGEX = \"-?\\\\d+\"", "var_name": "RANDOM_DIR_REGEX"}, {"original_string": "private static final Pattern RANDOM_DIR_PATTERN = Pattern\n      .compile(RANDOM_DIR_REGEX);", "modifier": "private static final", "type": "Pattern", "declarator": "RANDOM_DIR_PATTERN = Pattern\n      .compile(RANDOM_DIR_REGEX)", "var_name": "RANDOM_DIR_PATTERN"}, {"original_string": "private final String user;", "modifier": "private final", "type": "String", "declarator": "user", "var_name": "user"}, {"original_string": "private final ApplicationId appId;", "modifier": "private final", "type": "ApplicationId", "declarator": "appId", "var_name": "appId"}, {"original_string": "private final Dispatcher dispatcher;", "modifier": "private final", "type": "Dispatcher", "declarator": "dispatcher", "var_name": "dispatcher"}, {"original_string": "private final ConcurrentMap<LocalResourceRequest,LocalizedResource> localrsrc;", "modifier": "private final", "type": "ConcurrentMap<LocalResourceRequest,LocalizedResource>", "declarator": "localrsrc", "var_name": "localrsrc"}, {"original_string": "private Configuration conf;", "modifier": "private", "type": "Configuration", "declarator": "conf", "var_name": "conf"}, {"original_string": "private final boolean useLocalCacheDirectoryManager;", "modifier": "private final", "type": "boolean", "declarator": "useLocalCacheDirectoryManager", "var_name": "useLocalCacheDirectoryManager"}, {"original_string": "private ConcurrentHashMap<Path, LocalCacheDirectoryManager> directoryManagers;", "modifier": "private", "type": "ConcurrentHashMap<Path, LocalCacheDirectoryManager>", "declarator": "directoryManagers", "var_name": "directoryManagers"}, {"original_string": "private ConcurrentHashMap<LocalResourceRequest, Path>\n    inProgressLocalResourcesMap;", "modifier": "private", "type": "ConcurrentHashMap<LocalResourceRequest, Path>", "declarator": "inProgressLocalResourcesMap", "var_name": "inProgressLocalResourcesMap"}, {"original_string": "private AtomicLong uniqueNumberGenerator = new AtomicLong(9);", "modifier": "private", "type": "AtomicLong", "declarator": "uniqueNumberGenerator = new AtomicLong(9)", "var_name": "uniqueNumberGenerator"}, {"original_string": "private NMStateStoreService stateStore;", "modifier": "private", "type": "NMStateStoreService", "declarator": "stateStore", "var_name": "stateStore"}], "methods": [{"identifier": "LocalResourcesTrackerImpl", "parameters": "(String user, ApplicationId appId,\n      Dispatcher dispatcher, boolean useLocalCacheDirectoryManager,\n      Configuration conf, NMStateStoreService stateStore)", "modifiers": "public", "return": "", "signature": " LocalResourcesTrackerImpl(String user, ApplicationId appId,\n      Dispatcher dispatcher, boolean useLocalCacheDirectoryManager,\n      Configuration conf, NMStateStoreService stateStore)", "full_signature": "public  LocalResourcesTrackerImpl(String user, ApplicationId appId,\n      Dispatcher dispatcher, boolean useLocalCacheDirectoryManager,\n      Configuration conf, NMStateStoreService stateStore)", "class_method_signature": "LocalResourcesTrackerImpl.LocalResourcesTrackerImpl(String user, ApplicationId appId,\n      Dispatcher dispatcher, boolean useLocalCacheDirectoryManager,\n      Configuration conf, NMStateStoreService stateStore)", "testcase": false, "constructor": true}, {"identifier": "LocalResourcesTrackerImpl", "parameters": "(String user, ApplicationId appId,\n      Dispatcher dispatcher,\n      ConcurrentMap<LocalResourceRequest,LocalizedResource> localrsrc,\n      boolean useLocalCacheDirectoryManager, Configuration conf,\n      NMStateStoreService stateStore)", "modifiers": "", "return": "", "signature": " LocalResourcesTrackerImpl(String user, ApplicationId appId,\n      Dispatcher dispatcher,\n      ConcurrentMap<LocalResourceRequest,LocalizedResource> localrsrc,\n      boolean useLocalCacheDirectoryManager, Configuration conf,\n      NMStateStoreService stateStore)", "full_signature": "  LocalResourcesTrackerImpl(String user, ApplicationId appId,\n      Dispatcher dispatcher,\n      ConcurrentMap<LocalResourceRequest,LocalizedResource> localrsrc,\n      boolean useLocalCacheDirectoryManager, Configuration conf,\n      NMStateStoreService stateStore)", "class_method_signature": "LocalResourcesTrackerImpl.LocalResourcesTrackerImpl(String user, ApplicationId appId,\n      Dispatcher dispatcher,\n      ConcurrentMap<LocalResourceRequest,LocalizedResource> localrsrc,\n      boolean useLocalCacheDirectoryManager, Configuration conf,\n      NMStateStoreService stateStore)", "testcase": false, "constructor": true}, {"identifier": "handle", "parameters": "(ResourceEvent event)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void handle(ResourceEvent event)", "full_signature": "@Override public synchronized void handle(ResourceEvent event)", "class_method_signature": "LocalResourcesTrackerImpl.handle(ResourceEvent event)", "testcase": false, "constructor": false}, {"identifier": "recoverResource", "parameters": "(LocalResourceRequest req,\n      ResourceRecoveredEvent event)", "modifiers": "private", "return": "LocalizedResource", "signature": "LocalizedResource recoverResource(LocalResourceRequest req,\n      ResourceRecoveredEvent event)", "full_signature": "private LocalizedResource recoverResource(LocalResourceRequest req,\n      ResourceRecoveredEvent event)", "class_method_signature": "LocalResourcesTrackerImpl.recoverResource(LocalResourceRequest req,\n      ResourceRecoveredEvent event)", "testcase": false, "constructor": false}, {"identifier": "buildLocalizedResourceProto", "parameters": "(\n      LocalizedResource rsrc)", "modifiers": "private", "return": "LocalizedResourceProto", "signature": "LocalizedResourceProto buildLocalizedResourceProto(\n      LocalizedResource rsrc)", "full_signature": "private LocalizedResourceProto buildLocalizedResourceProto(\n      LocalizedResource rsrc)", "class_method_signature": "LocalResourcesTrackerImpl.buildLocalizedResourceProto(\n      LocalizedResource rsrc)", "testcase": false, "constructor": false}, {"identifier": "buildLocalResourceProto", "parameters": "(LocalResource lr)", "modifiers": "private", "return": "LocalResourceProto", "signature": "LocalResourceProto buildLocalResourceProto(LocalResource lr)", "full_signature": "private LocalResourceProto buildLocalResourceProto(LocalResource lr)", "class_method_signature": "LocalResourcesTrackerImpl.buildLocalResourceProto(LocalResource lr)", "testcase": false, "constructor": false}, {"identifier": "incrementFileCountForLocalCacheDirectory", "parameters": "(Path cacheDir)", "modifiers": "public", "return": "void", "signature": "void incrementFileCountForLocalCacheDirectory(Path cacheDir)", "full_signature": "public void incrementFileCountForLocalCacheDirectory(Path cacheDir)", "class_method_signature": "LocalResourcesTrackerImpl.incrementFileCountForLocalCacheDirectory(Path cacheDir)", "testcase": false, "constructor": false}, {"identifier": "decrementFileCountForLocalCacheDirectory", "parameters": "(LocalResourceRequest req,\n      LocalizedResource rsrc)", "modifiers": "private", "return": "void", "signature": "void decrementFileCountForLocalCacheDirectory(LocalResourceRequest req,\n      LocalizedResource rsrc)", "full_signature": "private void decrementFileCountForLocalCacheDirectory(LocalResourceRequest req,\n      LocalizedResource rsrc)", "class_method_signature": "LocalResourcesTrackerImpl.decrementFileCountForLocalCacheDirectory(LocalResourceRequest req,\n      LocalizedResource rsrc)", "testcase": false, "constructor": false}, {"identifier": "isResourcePresent", "parameters": "(LocalizedResource rsrc)", "modifiers": "public", "return": "boolean", "signature": "boolean isResourcePresent(LocalizedResource rsrc)", "full_signature": "public boolean isResourcePresent(LocalizedResource rsrc)", "class_method_signature": "LocalResourcesTrackerImpl.isResourcePresent(LocalizedResource rsrc)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(LocalizedResource rem, DeletionService delService)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean remove(LocalizedResource rem, DeletionService delService)", "full_signature": "@Override public boolean remove(LocalizedResource rem, DeletionService delService)", "class_method_signature": "LocalResourcesTrackerImpl.remove(LocalizedResource rem, DeletionService delService)", "testcase": false, "constructor": false}, {"identifier": "removeResource", "parameters": "(LocalResourceRequest req)", "modifiers": "private", "return": "void", "signature": "void removeResource(LocalResourceRequest req)", "full_signature": "private void removeResource(LocalResourceRequest req)", "class_method_signature": "LocalResourcesTrackerImpl.removeResource(LocalResourceRequest req)", "testcase": false, "constructor": false}, {"identifier": "getPathToDelete", "parameters": "(Path localPath)", "modifiers": "private", "return": "Path", "signature": "Path getPathToDelete(Path localPath)", "full_signature": "private Path getPathToDelete(Path localPath)", "class_method_signature": "LocalResourcesTrackerImpl.getPathToDelete(Path localPath)", "testcase": false, "constructor": false}, {"identifier": "getUser", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getUser()", "full_signature": "@Override public String getUser()", "class_method_signature": "LocalResourcesTrackerImpl.getUser()", "testcase": false, "constructor": false}, {"identifier": "iterator", "parameters": "()", "modifiers": "@Override public", "return": "Iterator<LocalizedResource>", "signature": "Iterator<LocalizedResource> iterator()", "full_signature": "@Override public Iterator<LocalizedResource> iterator()", "class_method_signature": "LocalResourcesTrackerImpl.iterator()", "testcase": false, "constructor": false}, {"identifier": "getPathForLocalization", "parameters": "(LocalResourceRequest req,\n      Path localDirPath, DeletionService delService)", "modifiers": "@Override public", "return": "Path", "signature": "Path getPathForLocalization(LocalResourceRequest req,\n      Path localDirPath, DeletionService delService)", "full_signature": "@Override public Path getPathForLocalization(LocalResourceRequest req,\n      Path localDirPath, DeletionService delService)", "class_method_signature": "LocalResourcesTrackerImpl.getPathForLocalization(LocalResourceRequest req,\n      Path localDirPath, DeletionService delService)", "testcase": false, "constructor": false}, {"identifier": "getLocalizedResource", "parameters": "(LocalResourceRequest request)", "modifiers": "@Override public", "return": "LocalizedResource", "signature": "LocalizedResource getLocalizedResource(LocalResourceRequest request)", "full_signature": "@Override public LocalizedResource getLocalizedResource(LocalResourceRequest request)", "class_method_signature": "LocalResourcesTrackerImpl.getLocalizedResource(LocalResourceRequest request)", "testcase": false, "constructor": false}, {"identifier": "getDirectoryManager", "parameters": "(Path localDirPath)", "modifiers": "@VisibleForTesting", "return": "LocalCacheDirectoryManager", "signature": "LocalCacheDirectoryManager getDirectoryManager(Path localDirPath)", "full_signature": "@VisibleForTesting LocalCacheDirectoryManager getDirectoryManager(Path localDirPath)", "class_method_signature": "LocalResourcesTrackerImpl.getDirectoryManager(Path localDirPath)", "testcase": false, "constructor": false}], "file": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/LocalResourcesTrackerImpl.java"}, "focal_method": {"identifier": "handle", "parameters": "(ResourceEvent event)", "modifiers": "@Override public synchronized", "return": "void", "body": "@Override\n  public synchronized void handle(ResourceEvent event) {\n    LocalResourceRequest req = event.getLocalResourceRequest();\n    LocalizedResource rsrc = localrsrc.get(req);\n    switch (event.getType()) {\n    case LOCALIZED:\n      if (useLocalCacheDirectoryManager) {\n        inProgressLocalResourcesMap.remove(req);\n      }\n      break;\n    case REQUEST:\n      if (rsrc != null && (!isResourcePresent(rsrc))) {\n        LOG.info(\"Resource \" + rsrc.getLocalPath()\n            + \" is missing, localizing it again\");\n        removeResource(req);\n        rsrc = null;\n      }\n      if (null == rsrc) {\n        rsrc = new LocalizedResource(req, dispatcher);\n        localrsrc.put(req, rsrc);\n      }\n      break;\n    case RELEASE:\n      if (null == rsrc) {\n        // The container sent a release event on a resource which \n        // 1) Failed\n        // 2) Removed for some reason (ex. disk is no longer accessible)\n        ResourceReleaseEvent relEvent = (ResourceReleaseEvent) event;\n        LOG.info(\"Container \" + relEvent.getContainer()\n            + \" sent RELEASE event on a resource request \" + req\n            + \" not present in cache.\");\n        return;\n      }\n      break;\n    case LOCALIZATION_FAILED:\n      /*\n       * If resource localization fails then Localized resource will be\n       * removed from local cache.\n       */\n      removeResource(req);\n      break;\n    case RECOVERED:\n      if (rsrc != null) {\n        LOG.warn(\"Ignoring attempt to recover existing resource \" + rsrc);\n        return;\n      }\n      rsrc = recoverResource(req, (ResourceRecoveredEvent) event);\n      localrsrc.put(req, rsrc);\n      break;\n    }\n\n    if (rsrc == null) {\n      LOG.warn(\"Received \" + event.getType() + \" event for request \" + req\n          + \" but localized resource is missing\");\n      return;\n    }\n    rsrc.handle(event);\n\n    // Remove the resource if its downloading and its reference count has\n    // become 0 after RELEASE. This maybe because a container was killed while\n    // localizing and no other container is referring to the resource.\n    // NOTE: This should NOT be done for public resources since the\n    //       download is not associated with a container-specific localizer.\n    if (event.getType() == ResourceEventType.RELEASE) {\n      if (rsrc.getState() == ResourceState.DOWNLOADING &&\n          rsrc.getRefCount() <= 0 &&\n          rsrc.getRequest().getVisibility() != LocalResourceVisibility.PUBLIC) {\n        removeResource(req);\n      }\n    }\n\n    if (event.getType() == ResourceEventType.LOCALIZED) {\n      if (rsrc.getLocalPath() != null) {\n        try {\n          stateStore.finishResourceLocalization(user, appId,\n              buildLocalizedResourceProto(rsrc));\n        } catch (IOException ioe) {\n          LOG.error(\"Error storing resource state for \" + rsrc, ioe);\n        }\n      } else {\n        LOG.warn(\"Resource \" + rsrc + \" localized without a location\");\n      }\n    }\n  }", "signature": "void handle(ResourceEvent event)", "full_signature": "@Override public synchronized void handle(ResourceEvent event)", "class_method_signature": "LocalResourcesTrackerImpl.handle(ResourceEvent event)", "testcase": false, "constructor": false, "invocations": ["getLocalResourceRequest", "get", "getType", "remove", "isResourcePresent", "info", "getLocalPath", "removeResource", "put", "info", "getContainer", "removeResource", "warn", "recoverResource", "put", "warn", "getType", "handle", "getType", "getState", "getRefCount", "getVisibility", "getRequest", "removeResource", "getType", "getLocalPath", "finishResourceLocalization", "buildLocalizedResourceProto", "error", "warn"]}, "repository": {"repo_id": 195808004, "url": "https://github.com/mouzwang/hadoop-2.7.2", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 5, "size": 24927, "license": "licensed"}}