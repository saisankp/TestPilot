{"test_class": {"identifier": "MergeableClusterInvokerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Directory directory = mock(Directory.class);", "modifier": "private", "type": "Directory", "declarator": "directory = mock(Directory.class)", "var_name": "directory"}, {"original_string": "private Invoker firstInvoker = mock(Invoker.class);", "modifier": "private", "type": "Invoker", "declarator": "firstInvoker = mock(Invoker.class)", "var_name": "firstInvoker"}, {"original_string": "private Invoker secondInvoker = mock(Invoker.class);", "modifier": "private", "type": "Invoker", "declarator": "secondInvoker = mock(Invoker.class)", "var_name": "secondInvoker"}, {"original_string": "private Invocation invocation = mock(Invocation.class);", "modifier": "private", "type": "Invocation", "declarator": "invocation = mock(Invocation.class)", "var_name": "invocation"}, {"original_string": "private MergeableClusterInvoker<MenuService> mergeableClusterInvoker;", "modifier": "private", "type": "MergeableClusterInvoker<MenuService>", "declarator": "mergeableClusterInvoker", "var_name": "mergeableClusterInvoker"}, {"original_string": "private String[] list1 = {\"10\", \"11\", \"12\"};", "modifier": "private", "type": "String[]", "declarator": "list1 = {\"10\", \"11\", \"12\"}", "var_name": "list1"}, {"original_string": "private String[] list2 = {\"20\", \"21\", \"22\"};", "modifier": "private", "type": "String[]", "declarator": "list2 = {\"20\", \"21\", \"22\"}", "var_name": "list2"}, {"original_string": "private String[] list3 = {\"23\", \"24\", \"25\"};", "modifier": "private", "type": "String[]", "declarator": "list3 = {\"23\", \"24\", \"25\"}", "var_name": "list3"}, {"original_string": "private String[] list4 = {\"30\", \"31\", \"32\"};", "modifier": "private", "type": "String[]", "declarator": "list4 = {\"30\", \"31\", \"32\"}", "var_name": "list4"}, {"original_string": "private Map<String, List<String>> firstMenuMap = new HashMap<String, List<String>>() {\n        {\n            put(\"1\", Arrays.asList(list1));\n            put(\"2\", Arrays.asList(list2));\n        }\n    };", "modifier": "private", "type": "Map<String, List<String>>", "declarator": "firstMenuMap = new HashMap<String, List<String>>() {\n        {\n            put(\"1\", Arrays.asList(list1));\n            put(\"2\", Arrays.asList(list2));\n        }\n    }", "var_name": "firstMenuMap"}, {"original_string": "private Map<String, List<String>> secondMenuMap = new HashMap<String, List<String>>() {\n        {\n            put(\"2\", Arrays.asList(list3));\n            put(\"3\", Arrays.asList(list4));\n        }\n    };", "modifier": "private", "type": "Map<String, List<String>>", "declarator": "secondMenuMap = new HashMap<String, List<String>>() {\n        {\n            put(\"2\", Arrays.asList(list3));\n            put(\"3\", Arrays.asList(list4));\n        }\n    }", "var_name": "secondMenuMap"}, {"original_string": "private Menu firstMenu = new Menu(firstMenuMap);", "modifier": "private", "type": "Menu", "declarator": "firstMenu = new Menu(firstMenuMap)", "var_name": "firstMenu"}, {"original_string": "private Menu secondMenu = new Menu(secondMenuMap);", "modifier": "private", "type": "Menu", "declarator": "secondMenu = new Menu(secondMenuMap)", "var_name": "secondMenu"}, {"original_string": "private URL url = URL.valueOf(\"test://test/\" + MenuService.class.getName());", "modifier": "private", "type": "URL", "declarator": "url = URL.valueOf(\"test://test/\" + MenuService.class.getName())", "var_name": "url"}], "file": "dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvokerTest.java"}, "test_case": {"identifier": "testGetMenuSuccessfully", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGetMenuSuccessfully() throws Exception {\n\n        // setup\n        url = url.addParameter(MERGER_KEY, \".merge\");\n\n        given(invocation.getMethodName()).willReturn(\"getMenu\");\n        given(invocation.getParameterTypes()).willReturn(new Class<?>[]{});\n        given(invocation.getArguments()).willReturn(new Object[]{});\n        given(invocation.getObjectAttachments()).willReturn(new HashMap<>())\n                ;\n        given(invocation.getInvoker()).willReturn(firstInvoker);\n\n        firstInvoker = (Invoker) Proxy.newProxyInstance(getClass().getClassLoader(), new Class<?>[]{Invoker.class}, (proxy, method, args) -> {\n            if (\"getUrl\".equals(method.getName())) {\n                return url.addParameter(GROUP_KEY, \"first\");\n            }\n            if (\"getInterface\".equals(method.getName())) {\n                return MenuService.class;\n            }\n            if (\"invoke\".equals(method.getName())) {\n                return AsyncRpcResult.newDefaultAsyncResult(firstMenu, invocation);\n            }\n            return null;\n        });\n\n        secondInvoker = (Invoker) Proxy.newProxyInstance(getClass().getClassLoader(), new Class<?>[]{Invoker.class}, (proxy, method, args) -> {\n            if (\"getUrl\".equals(method.getName())) {\n                return url.addParameter(GROUP_KEY, \"second\");\n            }\n            if (\"getInterface\".equals(method.getName())) {\n                return MenuService.class;\n            }\n            if (\"invoke\".equals(method.getName())) {\n                return AsyncRpcResult.newDefaultAsyncResult(secondMenu, invocation);\n            }\n            return null;\n        });\n\n        given(directory.list(invocation)).willReturn(new ArrayList() {\n\n            {\n                add(firstInvoker);\n                add(secondInvoker);\n            }\n        });\n        given(directory.getUrl()).willReturn(url);\n        given(directory.getConsumerUrl()).willReturn(url);\n        given(directory.getConsumerUrl()).willReturn(url);\n        given(directory.getInterface()).willReturn(MenuService.class);\n\n        mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);\n\n        // invoke\n        Result result = mergeableClusterInvoker.invoke(invocation);\n        Assertions.assertTrue(result.getValue() instanceof Menu);\n        Menu menu = (Menu) result.getValue();\n        Map<String, List<String>> expected = new HashMap<String, List<String>>();\n        merge(expected, firstMenuMap);\n        merge(expected, secondMenuMap);\n        assertEquals(expected.keySet(), menu.getMenus().keySet());\n        for (Map.Entry<String, List<String>> entry : expected.entrySet()) {\n            // FIXME: cannot guarantee the sequence of the merge result, check implementation in\n            // MergeableClusterInvoker#invoke\n            List<String> values1 = new ArrayList<String>(entry.getValue());\n            List<String> values2 = new ArrayList<String>(menu.getMenus().get(entry.getKey()));\n            Collections.sort(values1);\n            Collections.sort(values2);\n            assertEquals(values1, values2);\n        }\n    }", "signature": "void testGetMenuSuccessfully()", "full_signature": "@Test public void testGetMenuSuccessfully()", "class_method_signature": "MergeableClusterInvokerTest.testGetMenuSuccessfully()", "testcase": true, "constructor": false, "invocations": ["addParameter", "willReturn", "given", "getMethodName", "willReturn", "given", "getParameterTypes", "willReturn", "given", "getArguments", "willReturn", "given", "getObjectAttachments", "willReturn", "given", "getInvoker", "newProxyInstance", "getClassLoader", "getClass", "equals", "getName", "addParameter", "equals", "getName", "equals", "getName", "newDefaultAsyncResult", "newProxyInstance", "getClassLoader", "getClass", "equals", "getName", "addParameter", "equals", "getName", "equals", "getName", "newDefaultAsyncResult", "willReturn", "given", "list", "add", "add", "willReturn", "given", "getUrl", "willReturn", "given", "getConsumerUrl", "willReturn", "given", "getConsumerUrl", "willReturn", "given", "getInterface", "invoke", "assertTrue", "getValue", "getValue", "merge", "merge", "assertEquals", "keySet", "keySet", "getMenus", "entrySet", "getValue", "get", "getMenus", "getKey", "sort", "sort", "assertEquals"]}, "focal_class": {"identifier": "MergeableClusterInvoker", "superclass": "extends AbstractClusterInvoker<T>", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(MergeableClusterInvoker.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(MergeableClusterInvoker.class)", "var_name": "log"}], "methods": [{"identifier": "MergeableClusterInvoker", "parameters": "(Directory<T> directory)", "modifiers": "public", "return": "", "signature": " MergeableClusterInvoker(Directory<T> directory)", "full_signature": "public  MergeableClusterInvoker(Directory<T> directory)", "class_method_signature": "MergeableClusterInvoker.MergeableClusterInvoker(Directory<T> directory)", "testcase": false, "constructor": true}, {"identifier": "doInvoke", "parameters": "(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance)", "modifiers": "@Override protected", "return": "Result", "signature": "Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance)", "full_signature": "@Override protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance)", "class_method_signature": "MergeableClusterInvoker.doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance)", "testcase": false, "constructor": false}, {"identifier": "getInterface", "parameters": "()", "modifiers": "@Override public", "return": "Class<T>", "signature": "Class<T> getInterface()", "full_signature": "@Override public Class<T> getInterface()", "class_method_signature": "MergeableClusterInvoker.getInterface()", "testcase": false, "constructor": false}, {"identifier": "isAvailable", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isAvailable()", "full_signature": "@Override public boolean isAvailable()", "class_method_signature": "MergeableClusterInvoker.isAvailable()", "testcase": false, "constructor": false}, {"identifier": "destroy", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void destroy()", "full_signature": "@Override public void destroy()", "class_method_signature": "MergeableClusterInvoker.destroy()", "testcase": false, "constructor": false}, {"identifier": "getGroupDescFromServiceKey", "parameters": "(String key)", "modifiers": "private", "return": "String", "signature": "String getGroupDescFromServiceKey(String key)", "full_signature": "private String getGroupDescFromServiceKey(String key)", "class_method_signature": "MergeableClusterInvoker.getGroupDescFromServiceKey(String key)", "testcase": false, "constructor": false}], "file": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java"}, "focal_method": {"identifier": "getInterface", "parameters": "()", "modifiers": "@Override public", "return": "Class<T>", "body": "@Override\n    public Class<T> getInterface() {\n        return directory.getInterface();\n    }", "signature": "Class<T> getInterface()", "full_signature": "@Override public Class<T> getInterface()", "class_method_signature": "MergeableClusterInvoker.getInterface()", "testcase": false, "constructor": false, "invocations": ["getInterface"]}, "repository": {"repo_id": 4710920, "url": "https://github.com/apache/dubbo", "stars": 30960, "created": "6/19/2012 7:56:02 AM +00:00", "updates": "2020-01-27T14:21:03+00:00", "fork": "False", "license": "licensed"}}