{"test_class": {"identifier": "CompatibleTypeUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "core/common/src/test/java/com/alipay/sofa/rpc/common/utils/CompatibleTypeUtilsTest.java"}, "test_case": {"identifier": "convert", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void convert() throws Exception {\n        Assert.assertEquals('x', CompatibleTypeUtils.convert(\"x\", char.class));\n        Assert.assertEquals('x', CompatibleTypeUtils.convert(\"x\", Character.class));\n        boolean error = false;\n        try {\n            CompatibleTypeUtils.convert(\"xx\", Character.class);\n        } catch (Exception e) {\n            error = true;\n        }\n        Assert.assertTrue(error);\n\n        Assert.assertEquals(TestEnum.A, CompatibleTypeUtils.convert(\"A\", TestEnum.class));\n        Assert.assertEquals(new BigInteger(\"123\"), CompatibleTypeUtils.convert(\"123\", BigInteger.class));\n        Assert.assertEquals(new BigDecimal(\"123.12\"), CompatibleTypeUtils.convert(\"123.12\", BigDecimal.class));\n        Assert.assertEquals(new Short(\"123\"), CompatibleTypeUtils.convert(\"123\", Short.class));\n        Assert.assertEquals(new Short(\"123\"), CompatibleTypeUtils.convert(\"123\", short.class));\n        Assert.assertEquals(new Integer(\"123\"), CompatibleTypeUtils.convert(\"123\", Integer.class));\n        Assert.assertEquals(new Integer(\"123\"), CompatibleTypeUtils.convert(\"123\", int.class));\n        Assert.assertEquals(new Long(\"123\"), CompatibleTypeUtils.convert(\"123\", Long.class));\n        Assert.assertEquals(new Long(\"123\"), CompatibleTypeUtils.convert(\"123\", long.class));\n        Assert.assertEquals(new Double(\"123.1\"), CompatibleTypeUtils.convert(\"123.1\", Double.class));\n        Assert.assertEquals(new Double(\"123.1\"), CompatibleTypeUtils.convert(\"123.1\", double.class));\n        Assert.assertEquals(new Byte(\"123\"), CompatibleTypeUtils.convert(\"123\", Byte.class));\n        Assert.assertEquals(new Byte(\"123\"), CompatibleTypeUtils.convert(\"123\", byte.class));\n        Assert.assertEquals(new Float(\"123.1\"), CompatibleTypeUtils.convert(\"123.1\", Float.class));\n        Assert.assertEquals(new Float(\"123.1\"), CompatibleTypeUtils.convert(\"123.1\", float.class));\n        Assert.assertEquals(Boolean.TRUE, CompatibleTypeUtils.convert(\"true\", Boolean.class));\n        Assert.assertEquals(Boolean.TRUE, CompatibleTypeUtils.convert(\"true\", boolean.class));\n\n        Date dataTime = DateUtils.strToDate(\"2018-1-1 11:22:33\");\n        Assert.assertEquals(dataTime, CompatibleTypeUtils.convert(\"2018-1-1 11:22:33\", Date.class));\n        Long timeLong = DateUtils.strToLong(\"2018-1-1 11:22:33\");\n        java.sql.Date sqlDate = new java.sql.Date(timeLong);\n        Object timeResult = CompatibleTypeUtils.convert(\"2018-1-1 11:22:33\", java.sql.Date.class);\n        Assert.assertEquals(sqlDate, timeResult);\n        timeResult = CompatibleTypeUtils.convert(timeLong, java.sql.Date.class);\n        Assert.assertEquals(sqlDate, timeResult);\n        timeResult = CompatibleTypeUtils.convert(\"2018-1-1 11:22:33\", java.sql.Timestamp.class);\n        java.sql.Timestamp timestamp = new java.sql.Timestamp(timeLong);\n        Assert.assertEquals(timestamp, timeResult);\n        timeResult = CompatibleTypeUtils.convert(\"2018-1-1 11:22:33\", java.sql.Time.class);\n        java.sql.Time time = new java.sql.Time(timeLong);\n        Assert.assertEquals(time, timeResult);\n\n        Assert.assertEquals(new Short(\"123\"), CompatibleTypeUtils.convert(123, Short.class));\n        Assert.assertEquals(new Short(\"123\"), CompatibleTypeUtils.convert(123, short.class));\n        Assert.assertEquals(new Integer(\"123\"), CompatibleTypeUtils.convert(123, Integer.class));\n        Assert.assertEquals(new Integer(\"123\"), CompatibleTypeUtils.convert(123, int.class));\n        Assert.assertEquals(new Long(\"123\"), CompatibleTypeUtils.convert(123, Long.class));\n        Assert.assertEquals(new Long(\"123\"), CompatibleTypeUtils.convert(123, long.class));\n        Assert.assertEquals(new Double(\"123.1\"), CompatibleTypeUtils.convert(123.1, Double.class));\n        Assert.assertEquals(new Double(\"123.1\"), CompatibleTypeUtils.convert(123.1, double.class));\n        Assert.assertEquals(new Byte(\"123\"), CompatibleTypeUtils.convert(123, Byte.class));\n        Assert.assertEquals(new Byte(\"123\"), CompatibleTypeUtils.convert(123, byte.class));\n        Assert.assertEquals(new Float(\"123.1\"), CompatibleTypeUtils.convert(123.1, Float.class));\n        Assert.assertEquals(new Float(\"123.1\"), CompatibleTypeUtils.convert(123.1, float.class));\n        Assert.assertEquals(Boolean.TRUE, CompatibleTypeUtils.convert(\"true\", Boolean.class));\n        Assert.assertEquals(Boolean.TRUE, CompatibleTypeUtils.convert(\"true\", boolean.class));\n\n        String[] ss = (String[]) CompatibleTypeUtils.convert(Collections.singletonList(\"x\"), String[].class);\n        Assert.assertEquals(\"x\", ss[0]);\n        List list = (List) CompatibleTypeUtils.convert(Collections.singleton(\"x\"), List.class);\n        Assert.assertEquals(\"x\", list.get(0));\n        list = (List) CompatibleTypeUtils.convert(Collections.singletonList(\"x\"), ArrayList.class);\n        Assert.assertEquals(\"x\", list.get(0));\n        Set set = (Set) CompatibleTypeUtils.convert(Collections.singletonList(\"x\"), Set.class);\n        Assert.assertEquals(\"x\", set.iterator().next());\n\n        list = (List) CompatibleTypeUtils.convert(new String[] { \"x\" }, List.class);\n        Assert.assertEquals(\"x\", list.get(0));\n        list = (List) CompatibleTypeUtils.convert(new String[] { \"x\" }, ArrayList.class);\n        Assert.assertEquals(\"x\", list.get(0));\n        set = (Set) CompatibleTypeUtils.convert(new String[] { \"x\" }, Set.class);\n        Assert.assertEquals(\"x\", set.iterator().next());\n    }", "signature": "void convert()", "full_signature": "@Test public void convert()", "class_method_signature": "CompatibleTypeUtilsTest.convert()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "convert", "assertEquals", "convert", "convert", "assertTrue", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "strToDate", "assertEquals", "convert", "strToLong", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "assertEquals", "convert", "convert", "singletonList", "assertEquals", "convert", "singleton", "assertEquals", "get", "convert", "singletonList", "assertEquals", "get", "convert", "singletonList", "assertEquals", "next", "iterator", "convert", "assertEquals", "get", "convert", "assertEquals", "get", "convert", "assertEquals", "next", "iterator"]}, "focal_class": {"identifier": "CompatibleTypeUtils", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "CompatibleTypeUtils", "parameters": "()", "modifiers": "private", "return": "", "signature": " CompatibleTypeUtils()", "full_signature": "private  CompatibleTypeUtils()", "class_method_signature": "CompatibleTypeUtils.CompatibleTypeUtils()", "testcase": false, "constructor": true}, {"identifier": "convert", "parameters": "(Object value, Class<?> type)", "modifiers": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public static", "return": "Object", "signature": "Object convert(Object value, Class<?> type)", "full_signature": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public static Object convert(Object value, Class<?> type)", "class_method_signature": "CompatibleTypeUtils.convert(Object value, Class<?> type)", "testcase": false, "constructor": false}], "file": "core/common/src/main/java/com/alipay/sofa/rpc/common/utils/CompatibleTypeUtils.java"}, "focal_method": {"identifier": "convert", "parameters": "(Object value, Class<?> type)", "modifiers": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public static", "return": "Object", "body": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static Object convert(Object value, Class<?> type) {\n        if (value == null || type == null || type.isAssignableFrom(value.getClass())) {\n            return value;\n        }\n        if (value instanceof String) {\n            String string = (String) value;\n            if (char.class.equals(type) || Character.class.equals(type)) {\n                if (string.length() != 1) {\n                    throw new IllegalArgumentException(String.format(\"can not convert String(%s) to char!\" +\n                        \" when convert String to char, the String must only 1 char.\", string));\n                }\n                return string.charAt(0);\n            } else if (type.isEnum()) {\n                return Enum.valueOf((Class<Enum>) type, string);\n            } else if (type == BigInteger.class) {\n                return new BigInteger(string);\n            } else if (type == BigDecimal.class) {\n                return new BigDecimal(string);\n            } else if (type == Short.class || type == short.class) {\n                return Short.valueOf(string);\n            } else if (type == Integer.class || type == int.class) {\n                return Integer.valueOf(string);\n            } else if (type == Long.class || type == long.class) {\n                return Long.valueOf(string);\n            } else if (type == Double.class || type == double.class) {\n                return new Double(string);\n            } else if (type == Float.class || type == float.class) {\n                return new Float(string);\n            } else if (type == Byte.class || type == byte.class) {\n                return Byte.valueOf(string);\n            } else if (type == Boolean.class || type == boolean.class) {\n                return Boolean.valueOf(string);\n            } else if (type == Date.class || type == java.sql.Date.class || type == java.sql.Time.class ||\n                type == java.sql.Timestamp.class) {\n                try {\n                    if (type == Date.class) {\n                        return DateUtils.strToDate(string, DateUtils.DATE_FORMAT_TIME);\n                    } else if (type == java.sql.Date.class) {\n                        return new java.sql.Date(DateUtils.strToLong(string));\n                    } else if (type == java.sql.Timestamp.class) {\n                        return new java.sql.Timestamp(DateUtils.strToLong(string));\n                    } else {\n                        return new java.sql.Time(DateUtils.strToLong(string));\n                    }\n                } catch (ParseException e) {\n                    throw new IllegalStateException(\"Failed to parse date \" + value + \" by format \" +\n                        DateUtils.DATE_FORMAT_TIME + \", cause: \" + e.getMessage(), e);\n                }\n            } else if (type == Class.class) {\n                return ClassTypeUtils.getClass((String) value);\n            }\n        } else if (value instanceof Number) {\n            Number number = (Number) value;\n            if (type == byte.class || type == Byte.class) {\n                return number.byteValue();\n            } else if (type == short.class || type == Short.class) {\n                return number.shortValue();\n            } else if (type == int.class || type == Integer.class) {\n                return number.intValue();\n            } else if (type == long.class || type == Long.class) {\n                return number.longValue();\n            } else if (type == float.class || type == Float.class) {\n                return number.floatValue();\n            } else if (type == double.class || type == Double.class) {\n                return number.doubleValue();\n            } else if (type == BigInteger.class) {\n                return BigInteger.valueOf(number.longValue());\n            } else if (type == BigDecimal.class) {\n                return BigDecimal.valueOf(number.doubleValue());\n            } else if (type == Date.class) {\n                return new Date(number.longValue());\n            } else if (type == java.sql.Date.class) {\n                return new java.sql.Date(number.longValue());\n            } else if (type == java.sql.Time.class) {\n                return new java.sql.Time(number.longValue());\n            } else if (type == java.sql.Timestamp.class) {\n                return new java.sql.Timestamp(number.longValue());\n            }\n        } else if (value instanceof Collection) {\n            Collection collection = (Collection) value;\n            if (type.isArray()) {\n                int length = collection.size();\n                Object array = Array.newInstance(type.getComponentType(), length);\n                int i = 0;\n                for (Object item : collection) {\n                    Array.set(array, i++, item);\n                }\n                return array;\n            } else if (!type.isInterface()) {\n                try {\n                    Collection result = (Collection) type.newInstance();\n                    result.addAll(collection);\n                    return result;\n                } catch (Throwable ignore) { // NOPMD\n                }\n            } else if (type == List.class) {\n                return new ArrayList<Object>(collection);\n            } else if (type == Set.class) {\n                return new HashSet<Object>(collection);\n            }\n        } else if (value.getClass().isArray() && Collection.class.isAssignableFrom(type)) {\n            Collection collection;\n            if (!type.isInterface()) {\n                try {\n                    collection = (Collection) type.newInstance();\n                } catch (Throwable e) {\n                    collection = new ArrayList<Object>();\n                }\n            } else if (type == Set.class) {\n                collection = new HashSet<Object>();\n            } else {\n                collection = new ArrayList<Object>();\n            }\n            int length = Array.getLength(value);\n            for (int i = 0; i < length; i++) {\n                collection.add(Array.get(value, i));\n            }\n            return collection;\n        }\n        return value;\n    }", "signature": "Object convert(Object value, Class<?> type)", "full_signature": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public static Object convert(Object value, Class<?> type)", "class_method_signature": "CompatibleTypeUtils.convert(Object value, Class<?> type)", "testcase": false, "constructor": false, "invocations": ["isAssignableFrom", "getClass", "equals", "equals", "length", "format", "charAt", "isEnum", "valueOf", "valueOf", "valueOf", "valueOf", "valueOf", "valueOf", "strToDate", "strToLong", "strToLong", "strToLong", "getMessage", "getClass", "byteValue", "shortValue", "intValue", "longValue", "floatValue", "doubleValue", "valueOf", "longValue", "valueOf", "doubleValue", "longValue", "longValue", "longValue", "longValue", "isArray", "size", "newInstance", "getComponentType", "set", "isInterface", "newInstance", "addAll", "isArray", "getClass", "isAssignableFrom", "isInterface", "newInstance", "getLength", "add", "get"]}, "repository": {"repo_id": 128709824, "url": "https://github.com/sofastack/sofa-rpc", "stars": 3001, "created": "4/9/2018 3:32:04 AM +00:00", "updates": "2020-01-22T02:08:51+00:00", "fork": "False", "license": "licensed"}}