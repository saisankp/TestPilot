{"test_class": {"identifier": "RunSQLComponentTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "RunSqlEntity runSqlEntity = new RunSqlEntity();", "modifier": "", "type": "RunSqlEntity", "declarator": "runSqlEntity = new RunSqlEntity()", "var_name": "runSqlEntity"}, {"original_string": "Properties properties = new Properties();", "modifier": "", "type": "Properties", "declarator": "properties = new Properties()", "var_name": "properties"}], "file": "hydrograph.engine/hydrograph.engine.spark/src/test/scala/hydrograph/engine/spark/components/RunSQLComponentTest.java"}, "test_case": {"identifier": "throwException_IfDatabaseConnectionNameIsEmpty", "parameters": "()", "modifiers": "@Test(expected = DatabaseConnectionException.class) public", "return": "void", "body": "@Test(expected = DatabaseConnectionException.class)\n    public void throwException_IfDatabaseConnectionNameIsEmpty() throws IOException {\n        runSqlEntity.setBatch(\"0\");\n        runSqlEntity.setComponentId(\"1\");\n        runSqlEntity.setComponentName(\"RunSQLComponent\");\n        runSqlEntity.setDatabaseConnectionName(\"\");\n        runSqlEntity.setDatabaseName(\"PRACTICE\");\n        runSqlEntity.setDbPwd(\"Bitwise2017\");\n        runSqlEntity.setPortNumber(\"1521\");\n        runSqlEntity.setQueryCommand(\"insert into testsp values(1,1,1,1)\");\n        runSqlEntity.setDbUserName(\"htcd\");\n        runSqlEntity.setServerName(\"DBDEVSRV\");\n        RunSQLComponent runSQLComponent = new RunSQLComponent(runSqlEntity);\n        runSQLComponent.execute();\n\n    }", "signature": "void throwException_IfDatabaseConnectionNameIsEmpty()", "full_signature": "@Test(expected = DatabaseConnectionException.class) public void throwException_IfDatabaseConnectionNameIsEmpty()", "class_method_signature": "RunSQLComponentTest.throwException_IfDatabaseConnectionNameIsEmpty()", "testcase": true, "constructor": false, "invocations": ["setBatch", "setComponentId", "setComponentName", "setDatabaseConnectionName", "setDatabaseName", "setDbPwd", "setPortNumber", "setQueryCommand", "setDbUserName", "setServerName", "execute"]}, "focal_class": {"identifier": "RunSQLComponent", "superclass": "extends CommandComponentSparkFlow", "interfaces": "implements Serializable", "fields": [{"original_string": "static final Logger log = Logger.getLogger(RunSQLComponent.class.getName());", "modifier": "static final", "type": "Logger", "declarator": "log = Logger.getLogger(RunSQLComponent.class.getName())", "var_name": "log"}, {"original_string": "File tempFile = File.createTempFile(\"query\", \".txt\", new File(\".\"));", "modifier": "", "type": "File", "declarator": "tempFile = File.createTempFile(\"query\", \".txt\", new File(\".\"))", "var_name": "tempFile"}, {"original_string": "private AssemblyEntityBase assemblyEntityBase;", "modifier": "private", "type": "AssemblyEntityBase", "declarator": "assemblyEntityBase", "var_name": "assemblyEntityBase"}, {"original_string": "private RunSqlEntity runSqlEntity;", "modifier": "private", "type": "RunSqlEntity", "declarator": "runSqlEntity", "var_name": "runSqlEntity"}], "methods": [{"identifier": "RunSQLComponent", "parameters": "(AssemblyEntityBase assemblyEntityBase)", "modifiers": "public", "return": "", "signature": " RunSQLComponent(AssemblyEntityBase assemblyEntityBase)", "full_signature": "public  RunSQLComponent(AssemblyEntityBase assemblyEntityBase)", "class_method_signature": "RunSQLComponent.RunSQLComponent(AssemblyEntityBase assemblyEntityBase)", "testcase": false, "constructor": true}, {"identifier": "execute", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void execute()", "full_signature": "@Override public void execute()", "class_method_signature": "RunSQLComponent.execute()", "testcase": false, "constructor": false}, {"identifier": "scriptBuilder", "parameters": "(String statement)", "modifiers": "private", "return": "void", "signature": "void scriptBuilder(String statement)", "full_signature": "private void scriptBuilder(String statement)", "class_method_signature": "RunSQLComponent.scriptBuilder(String statement)", "testcase": false, "constructor": false}], "file": "hydrograph.engine/hydrograph.engine.spark/src/main/scala/hydrograph/engine/spark/components/RunSQLComponent.java"}, "focal_method": {"identifier": "execute", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void execute() {\n        Properties properties = new Properties();\n        Connection conn = null;\n        Reader reader = null;\n\n        if (((null != runSqlEntity.getDatabaseConnectionName()) && !(runSqlEntity.getDatabaseConnectionName().trim().isEmpty()))\n                && ((null != runSqlEntity.getQueryCommand()) && !(runSqlEntity.getQueryCommand().trim().isEmpty()))) {\n            if (runSqlEntity.getDatabaseConnectionName().equalsIgnoreCase(\"MYSQL\")) {\n                log.debug(\"Request received test connection \" + runSqlEntity.getDatabaseConnectionName());\n                try {\n                    properties.setProperty(\"className\", \"com.mysql.jdbc.Driver\");\n                    conn = DriverManager.getConnection(\"jdbc:mysql://\" + runSqlEntity.getServerName() + \":\" + runSqlEntity.getPortNumber() + \"/\" + runSqlEntity.getDatabaseName() + \"?allowMultiQueries=true\", runSqlEntity.getDbUserName(), runSqlEntity.getDbPwd());\n                    conn.setAutoCommit(false);\n                    scriptBuilder(runSqlEntity.getQueryCommand());\n                    ScriptRunner sr = new ScriptRunner(conn, false, true);\n                    reader = new BufferedReader(new FileReader(tempFile));\n                    sr.runScript(reader);\n                } catch (SQLException | IOException | ClassNotFoundException e) {\n                    log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                    throw new RuntimeException(e);\n                } finally {\n                    Exception ex = null;\n                    try {\n                        SafeResourceClose.safeReaderClose(reader);\n                    } catch (IOException e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                        ex = e;\n                    }\n                    try {\n                        tempFile.deleteOnExit();\n                    } catch (Exception e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                        ex = e;\n                    }\n                    try {\n                        SafeResourceClose.safeConnectionClose(conn);\n                    } catch (SQLException e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                        ex = e;\n                    }\n\n                    if(ex != null) {\n                        throw new RuntimeException(ex);\n                    }\n                }\n            } else if (runSqlEntity.getDatabaseConnectionName().equalsIgnoreCase(\"Oracle\")) {\n                log.debug(\"Request received test connection \" + runSqlEntity.getDatabaseConnectionName());\n                try {\n                    properties.setProperty(\"className\", \"oracle.jdbc.driver.OracleDriver\");\n                    conn = DriverManager.getConnection(\"jdbc:oracle:thin://@\" + runSqlEntity.getServerName() + \":\" + runSqlEntity.getPortNumber() + \"/\" + runSqlEntity.getDatabaseName(), runSqlEntity.getDbUserName(), runSqlEntity.getDbPwd());\n                    conn.setAutoCommit(false);\n                    scriptBuilder(runSqlEntity.getQueryCommand());\n                    ScriptRunner sr = new ScriptRunner(conn, false, true);\n                    reader = new BufferedReader(new FileReader(tempFile));\n                    sr.runScript(reader);\n                } catch (SQLException | IOException | ClassNotFoundException e) {\n                    log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                    throw new RuntimeException(e);\n                } finally {\n                    Exception ex = null;\n                    try {\n                        SafeResourceClose.safeReaderClose(reader);\n                    } catch (IOException e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                        ex = e;\n                    }\n                    try {\n                        tempFile.deleteOnExit();\n                    } catch (Exception e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                        ex = e;\n                    }\n                    try {\n                        SafeResourceClose.safeConnectionClose(conn);\n                    } catch (SQLException e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                        ex = e;\n                    }\n\n                    if(ex != null) {\n                        throw new RuntimeException(ex);\n                    }\n                }\n            } else if (runSqlEntity.getDatabaseConnectionName().equalsIgnoreCase(\"Teradata\")) {\n                log.debug(\"Request received test connection \" + runSqlEntity.getDatabaseConnectionName());\n                try {\n                    properties.setProperty(\"className\", \"com.teradata.jdbc.TeraDriver\");\n                    conn = DriverManager.getConnection(\"jdbc:teradata://\" + runSqlEntity.getServerName() + \"/DATABASE=\" + runSqlEntity.getDatabaseName() + \",USER=\" + runSqlEntity.getDbUserName() + \", \" + Constants.TERADATA_PWD + \"=\" + runSqlEntity.getDbPwd() + \",TMODE=ANSI,CHARSET=UTF8\");\n                    conn.setAutoCommit(false);\n                    scriptBuilder(runSqlEntity.getQueryCommand());\n                    ScriptRunner sr = new ScriptRunner(conn, false, true);\n                    reader = new BufferedReader(new FileReader(tempFile));\n                    sr.runScript(reader);\n                } catch (SQLException | IOException | ClassNotFoundException e) {\n                    log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                    throw new RuntimeException(e);\n                } finally {\n                    Exception ex = null;\n                    try {\n                        SafeResourceClose.safeReaderClose(reader);\n                    } catch (IOException e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                        ex = e;\n                    }\n                    try {\n                        tempFile.deleteOnExit();\n                    } catch (Exception e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                        ex = e;\n                    }\n                    try {\n                        SafeResourceClose.safeConnectionClose(conn);\n                    } catch (SQLException e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                        ex = e;\n                    }\n\n                    if(ex != null) {\n                        throw new RuntimeException(ex);\n                    }\n                }\n            } else if (runSqlEntity.getDatabaseConnectionName().equalsIgnoreCase(\"Redshift\")) {\n                log.debug(\"Request received test connection \" + runSqlEntity.getDatabaseConnectionName());\n                try {\n                    properties.setProperty(\"className\", \"com.amazon.redshift.jdbc42.Driver\");\n                    conn = DriverManager.getConnection(\"jdbc:redshift://\" + runSqlEntity.getServerName() + \":\" + runSqlEntity.getPortNumber() + \"/\" + runSqlEntity.getDatabaseName(), runSqlEntity.getDbUserName(), runSqlEntity.getDbPwd());\n                    conn.setAutoCommit(false);\n                    scriptBuilder(runSqlEntity.getQueryCommand());\n                    ScriptRunner sr = new ScriptRunner(conn, false, true);\n                    reader = new BufferedReader(new FileReader(tempFile));\n                    sr.runScript(reader);\n                } catch (SQLException | IOException | ClassNotFoundException e) {\n                    log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                    throw new RuntimeException(e);\n                } finally {\n                    try {\n                        SafeResourceClose.safeReaderClose(reader);\n                    } catch (IOException e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                    }\n                    try {\n                        tempFile.deleteOnExit();\n                    } catch (Exception e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                    }\n                    try {\n                        SafeResourceClose.safeConnectionClose(conn);\n                    } catch (SQLException e) {\n                        log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \" The error is \" + e.getMessage());\n                    }\n                }\n            }\n        } else {\n            log.debug(\"Failed to Execute\" + runSqlEntity.getQueryCommand() + \"Required field is empty.\");\n            throw new DatabaseConnectionException(\"Required field is empty.\",null);\n        }\n    }", "signature": "void execute()", "full_signature": "@Override public void execute()", "class_method_signature": "RunSQLComponent.execute()", "testcase": false, "constructor": false, "invocations": ["getDatabaseConnectionName", "isEmpty", "trim", "getDatabaseConnectionName", "getQueryCommand", "isEmpty", "trim", "getQueryCommand", "equalsIgnoreCase", "getDatabaseConnectionName", "debug", "getDatabaseConnectionName", "setProperty", "getConnection", "getServerName", "getPortNumber", "getDatabaseName", "getDbUserName", "getDbPwd", "setAutoCommit", "scriptBuilder", "getQueryCommand", "runScript", "debug", "getQueryCommand", "getMessage", "safeReaderClose", "debug", "getQueryCommand", "getMessage", "deleteOnExit", "debug", "getQueryCommand", "getMessage", "safeConnectionClose", "debug", "getQueryCommand", "getMessage", "equalsIgnoreCase", "getDatabaseConnectionName", "debug", "getDatabaseConnectionName", "setProperty", "getConnection", "getServerName", "getPortNumber", "getDatabaseName", "getDbUserName", "getDbPwd", "setAutoCommit", "scriptBuilder", "getQueryCommand", "runScript", "debug", "getQueryCommand", "getMessage", "safeReaderClose", "debug", "getQueryCommand", "getMessage", "deleteOnExit", "debug", "getQueryCommand", "getMessage", "safeConnectionClose", "debug", "getQueryCommand", "getMessage", "equalsIgnoreCase", "getDatabaseConnectionName", "debug", "getDatabaseConnectionName", "setProperty", "getConnection", "getServerName", "getDatabaseName", "getDbUserName", "getDbPwd", "setAutoCommit", "scriptBuilder", "getQueryCommand", "runScript", "debug", "getQueryCommand", "getMessage", "safeReaderClose", "debug", "getQueryCommand", "getMessage", "deleteOnExit", "debug", "getQueryCommand", "getMessage", "safeConnectionClose", "debug", "getQueryCommand", "getMessage", "equalsIgnoreCase", "getDatabaseConnectionName", "debug", "getDatabaseConnectionName", "setProperty", "getConnection", "getServerName", "getPortNumber", "getDatabaseName", "getDbUserName", "getDbPwd", "setAutoCommit", "scriptBuilder", "getQueryCommand", "runScript", "debug", "getQueryCommand", "getMessage", "safeReaderClose", "debug", "getQueryCommand", "getMessage", "deleteOnExit", "debug", "getQueryCommand", "getMessage", "safeConnectionClose", "debug", "getQueryCommand", "getMessage", "debug", "getQueryCommand"]}, "repository": {"repo_id": 84487370, "url": "https://github.com/BitwiseInc/Hydrograph", "language": "Java", "is_fork": false, "fork_count": 104, "stargazer_count": 139, "size": 35089, "license": "licensed"}}