{"test_class": {"identifier": "MassToFormulaToolTest", "superclass": "extends CDKTestCase", "interfaces": "", "fields": [{"original_string": "private final static IChemObjectBuilder builder = SilentChemObjectBuilder.getInstance();", "modifier": "private final static", "type": "IChemObjectBuilder", "declarator": "builder = SilentChemObjectBuilder.getInstance()", "var_name": "builder"}, {"original_string": "private IsotopeFactory                  ifac;", "modifier": "private", "type": "IsotopeFactory", "declarator": "ifac", "var_name": "ifac"}], "file": "legacy/src/test/java/org/openscience/cdk/formula/MassToFormulaToolTest.java"}, "test_case": {"identifier": "testMass_0Null", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMass_0Null() {\n\n        Assert.assertNull(new MassToFormulaTool(builder).generate(0.0));\n    }", "signature": "void testMass_0Null()", "full_signature": "@Test public void testMass_0Null()", "class_method_signature": "MassToFormulaToolTest.testMass_0Null()", "testcase": true, "constructor": false, "invocations": ["assertNull", "generate"]}, "focal_class": {"identifier": "MassToFormulaTool", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ILoggingTool          logger = LoggingToolFactory.createLoggingTool(MassToFormulaTool.class);", "modifier": "private", "type": "ILoggingTool", "declarator": "logger = LoggingToolFactory.createLoggingTool(MassToFormulaTool.class)", "var_name": "logger"}, {"original_string": "private IChemObjectBuilder    builder;", "modifier": "private", "type": "IChemObjectBuilder", "declarator": "builder", "var_name": "builder"}, {"original_string": "AtomTypeFactory               factory;", "modifier": "", "type": "AtomTypeFactory", "declarator": "factory", "var_name": "factory"}, {"original_string": "private int[][]               matrix_Base;", "modifier": "private", "type": "int[][]", "declarator": "matrix_Base", "var_name": "matrix_Base"}, {"original_string": "private String[]              orderElements;", "modifier": "private", "type": "String[]", "declarator": "orderElements", "var_name": "orderElements"}, {"original_string": "private List<IRule>           rules;", "modifier": "private", "type": "List<IRule>", "declarator": "rules", "var_name": "rules"}, {"original_string": "private MolecularFormulaRange mfRange;", "modifier": "private", "type": "MolecularFormulaRange", "declarator": "mfRange", "var_name": "mfRange"}, {"original_string": "private Double                charge;", "modifier": "private", "type": "Double", "declarator": "charge", "var_name": "charge"}, {"original_string": "private Double                tolerance;", "modifier": "private", "type": "Double", "declarator": "tolerance", "var_name": "tolerance"}], "methods": [{"identifier": "MassToFormulaTool", "parameters": "(IChemObjectBuilder builder)", "modifiers": "public", "return": "", "signature": " MassToFormulaTool(IChemObjectBuilder builder)", "full_signature": "public  MassToFormulaTool(IChemObjectBuilder builder)", "class_method_signature": "MassToFormulaTool.MassToFormulaTool(IChemObjectBuilder builder)", "testcase": false, "constructor": true}, {"identifier": "setRestrictions", "parameters": "(List<IRule> rulesNew)", "modifiers": "public", "return": "void", "signature": "void setRestrictions(List<IRule> rulesNew)", "full_signature": "public void setRestrictions(List<IRule> rulesNew)", "class_method_signature": "MassToFormulaTool.setRestrictions(List<IRule> rulesNew)", "testcase": false, "constructor": false}, {"identifier": "getRestrictions", "parameters": "()", "modifiers": "public", "return": "List<IRule>", "signature": "List<IRule> getRestrictions()", "full_signature": "public List<IRule> getRestrictions()", "class_method_signature": "MassToFormulaTool.getRestrictions()", "testcase": false, "constructor": false}, {"identifier": "setDefaultRestrictions", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void setDefaultRestrictions()", "full_signature": "public void setDefaultRestrictions()", "class_method_signature": "MassToFormulaTool.setDefaultRestrictions()", "testcase": false, "constructor": false}, {"identifier": "callDefaultRestrictions", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void callDefaultRestrictions()", "full_signature": "private void callDefaultRestrictions()", "class_method_signature": "MassToFormulaTool.callDefaultRestrictions()", "testcase": false, "constructor": false}, {"identifier": "generate", "parameters": "(double mass)", "modifiers": "public", "return": "IMolecularFormulaSet", "signature": "IMolecularFormulaSet generate(double mass)", "full_signature": "public IMolecularFormulaSet generate(double mass)", "class_method_signature": "MassToFormulaTool.generate(double mass)", "testcase": false, "constructor": false}, {"identifier": "orderList", "parameters": "(List<IIsotope> isotopes_TO)", "modifiers": "private", "return": "List<IIsotope>", "signature": "List<IIsotope> orderList(List<IIsotope> isotopes_TO)", "full_signature": "private List<IIsotope> orderList(List<IIsotope> isotopes_TO)", "class_method_signature": "MassToFormulaTool.orderList(List<IIsotope> isotopes_TO)", "testcase": false, "constructor": false}, {"identifier": "generateOrderE", "parameters": "()", "modifiers": "private", "return": "String[]", "signature": "String[] generateOrderE()", "full_signature": "private String[] generateOrderE()", "class_method_signature": "MassToFormulaTool.generateOrderE()", "testcase": false, "constructor": false}, {"identifier": "getMaxOccurence", "parameters": "(double massTo, int element_pos, int[] matrix, List<IIsotope> isoToCond_new)", "modifiers": "private", "return": "int", "signature": "int getMaxOccurence(double massTo, int element_pos, int[] matrix, List<IIsotope> isoToCond_new)", "full_signature": "private int getMaxOccurence(double massTo, int element_pos, int[] matrix, List<IIsotope> isoToCond_new)", "class_method_signature": "MassToFormulaTool.getMaxOccurence(double massTo, int element_pos, int[] matrix, List<IIsotope> isoToCond_new)", "testcase": false, "constructor": false}, {"identifier": "getFormula", "parameters": "(List<IIsotope> isoToCond_new, int[] value_In)", "modifiers": "private", "return": "IMolecularFormula", "signature": "IMolecularFormula getFormula(List<IIsotope> isoToCond_new, int[] value_In)", "full_signature": "private IMolecularFormula getFormula(List<IIsotope> isoToCond_new, int[] value_In)", "class_method_signature": "MassToFormulaTool.getFormula(List<IIsotope> isoToCond_new, int[] value_In)", "testcase": false, "constructor": false}, {"identifier": "putInOrder", "parameters": "(IMolecularFormula formula)", "modifiers": "private", "return": "IMolecularFormula", "signature": "IMolecularFormula putInOrder(IMolecularFormula formula)", "full_signature": "private IMolecularFormula putInOrder(IMolecularFormula formula)", "class_method_signature": "MassToFormulaTool.putInOrder(IMolecularFormula formula)", "testcase": false, "constructor": false}, {"identifier": "calculateMassT", "parameters": "(List<IIsotope> isoToCond_new, int[] value_In)", "modifiers": "private", "return": "double", "signature": "double calculateMassT(List<IIsotope> isoToCond_new, int[] value_In)", "full_signature": "private double calculateMassT(List<IIsotope> isoToCond_new, int[] value_In)", "class_method_signature": "MassToFormulaTool.calculateMassT(List<IIsotope> isoToCond_new, int[] value_In)", "testcase": false, "constructor": false}, {"identifier": "returnOrdered", "parameters": "(double mass, IMolecularFormulaSet formulaSet)", "modifiers": "private", "return": "IMolecularFormulaSet", "signature": "IMolecularFormulaSet returnOrdered(double mass, IMolecularFormulaSet formulaSet)", "full_signature": "private IMolecularFormulaSet returnOrdered(double mass, IMolecularFormulaSet formulaSet)", "class_method_signature": "MassToFormulaTool.returnOrdered(double mass, IMolecularFormulaSet formulaSet)", "testcase": false, "constructor": false}, {"identifier": "getMatrix", "parameters": "(int size)", "modifiers": "private", "return": "int[][]", "signature": "int[][] getMatrix(int size)", "full_signature": "private int[][] getMatrix(int size)", "class_method_signature": "MassToFormulaTool.getMatrix(int size)", "testcase": false, "constructor": false}], "file": "legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java"}, "focal_method": {"identifier": "generate", "parameters": "(double mass)", "modifiers": "public", "return": "IMolecularFormulaSet", "body": "public IMolecularFormulaSet generate(double mass) {\n\n        if (mass <= 0.0) {\n            logger.error(\"Proposed mass is not valid: \", mass);\n            return null;\n        }\n        IMolecularFormula minimalMF = MolecularFormulaRangeManipulator.getMinimalFormula(mfRange, builder);\n        IMolecularFormula maximalMF = MolecularFormulaRangeManipulator.getMaximalFormula(mfRange, builder);\n        double massMim = MolecularFormulaManipulator.getTotalExactMass(minimalMF) - tolerance;\n        double massMap = MolecularFormulaManipulator.getTotalExactMass(maximalMF) + tolerance;\n        if (massMim > mass || massMap < mass) {\n            logger.error(\"Proposed mass is out of the range: \", mass);\n            return null;\n        }\n\n        IMolecularFormulaSet molecularFormulaSet = builder.newInstance(IMolecularFormulaSet.class);\n\n        int[][] matrix = this.matrix_Base;\n        int numberElements = mfRange.getIsotopeCount();\n\n        // put IIsotope into a list\n        List<IIsotope> isotopes_TO = new ArrayList<IIsotope>();\n        Iterator<IIsotope> isIt = mfRange.isotopes().iterator();\n        while (isIt.hasNext())\n            isotopes_TO.add(isIt.next());\n\n        isotopes_TO = orderList(isotopes_TO);\n\n        for (int i = 0; i < matrix.length; i++) {\n\n            /* constructing initial combinations */\n            int[] value_In = new int[numberElements];\n            for (int j = 0; j < numberElements; j++) {\n                if (matrix[i][j] == 0)\n                    value_In[j] = 0;\n                else\n                    value_In[j] = 1;\n            }\n\n            /* find number of element to combine */\n            int count_E = 0;\n            ArrayList<Integer> elem_Pos = new ArrayList<Integer>();\n            for (int j = 0; j < matrix[1].length; j++)\n                if (value_In[j] != 0) {\n                    count_E++;\n                    elem_Pos.add(j);\n                }\n\n            boolean flag = true;\n            /* first position those first starting at the left */\n            int possChan = 0;\n            String lastMFString = \"\";\n            while (flag) {\n\n                //\t\t\t\t// print all combinations --------------------------------------------------\n                //\t\t\t\tSystem.out.print(elem_Pos.get(possChan).intValue()+\">\");\n                //\t\t\t\tfor(int j= 0 ; j< matrix[1].length; j++)\n                //\t\t\t\t\tSystem.out.print(isotopes_TO.get(j).getSymbol()+value_In[j]+\"-\");\n                //\t\t\t\tSystem.out.println();\n                //\t\t\t\t// print all combinations --------------------------------------------------\n\n                // control if some of the element is contained. E.g. C(1-3)H(1-3)\n                // the matrix 01 or 10 can not exist\n                boolean flagBreak = false;\n                for (int j = 0; j < matrix[1].length; j++) {\n                    int min = mfRange.getIsotopeCountMin(isotopes_TO.get(j));\n                    if (value_In[j] == 0) if (min != 0) flagBreak = true;\n                }\n                if (flagBreak) break;\n\n                /*\n                 * Find max occurence given a mass for a element with minimal\n                 * elements\n                 */\n                int occurence = getMaxOccurence(mass, elem_Pos.get(possChan).intValue(), value_In, isotopes_TO);\n\n                /* at least one */\n                if (occurence == 0) break;\n\n                int maxx = mfRange.getIsotopeCountMax(isotopes_TO.get(elem_Pos.get(possChan).intValue()));\n                int minn = mfRange.getIsotopeCountMin(isotopes_TO.get(elem_Pos.get(possChan).intValue()));\n\n                /* restriction of the number of max and min number for a element */\n                if (occurence < minn | maxx < occurence) {\n                    /*\n                     * when is not in the occurrence that means that we have to\n                     * restart one value to the predecessor.\n                     */\n\n                    if (possChan < elem_Pos.size() - 1) {\n                        /* Means that is possible to fit the next */\n                        if (maxx < occurence) value_In[elem_Pos.get(possChan).intValue()] = maxx;\n                        possChan++;\n\n                    } else {\n                        boolean foundZ = false;\n                        for (int z = possChan - 1; z >= 0; z--) {\n                            if (value_In[elem_Pos.get(z).intValue()] != 1) {\n                                possChan = z;\n                                foundZ = true;\n                                int newValue = value_In[elem_Pos.get(possChan).intValue()] - 1;\n\n                                value_In[elem_Pos.get(possChan).intValue()] = newValue;\n                                for (int j = possChan + 1; j < elem_Pos.size(); j++) {\n                                    int p = elem_Pos.get(j).intValue();\n                                    value_In[p] = 1;\n                                }\n                                possChan++;\n                                break;\n                            }\n                        }\n                        if (!foundZ) break;\n\n                    }\n\n                    continue;\n                } /* final not occurrence */\n\n                /* set the occurrence into the matrix */\n                value_In[elem_Pos.get(possChan).intValue()] = occurence;\n\n                double massT = calculateMassT(isotopes_TO, value_In);\n                double diff_new = Math.abs(mass - (massT));\n\n                if (diff_new < tolerance) {\n                    IMolecularFormula myMF = getFormula(isotopes_TO, value_In);\n                    String newMFString = MolecularFormulaManipulator.getString(myMF);\n\n                    if (!newMFString.equals(lastMFString)) {\n                        molecularFormulaSet.addMolecularFormula(myMF);\n                        lastMFString = newMFString;\n                    }\n                }\n\n                if (count_E == 1) /* only valid for the first random 1000 */\n                break;\n\n                if (possChan < elem_Pos.size() - 1) {\n                    /* Means that is possible to fit the next */\n                    //\t\t\t\t\tvalue_In[elem_Pos.get(possChan).intValue()] = maxx;\n                    possChan++;\n\n                } else {\n                    boolean foundZ = false;\n                    for (int z = possChan - 1; z >= 0; z--) {\n                        if (value_In[elem_Pos.get(z).intValue()] != 1) {\n                            possChan = z;\n                            foundZ = true;\n                            int newValue = value_In[elem_Pos.get(possChan).intValue()] - 1;\n\n                            value_In[elem_Pos.get(possChan).intValue()] = newValue;\n                            for (int j = possChan + 1; j < elem_Pos.size(); j++) {\n                                int p = elem_Pos.get(j).intValue();\n                                value_In[p] = 1;\n                            }\n                            possChan++;\n                            break;\n                        }\n                    }\n                    if (!foundZ) break;\n\n                }\n            }\n\n        }\n\n        return returnOrdered(mass, molecularFormulaSet);\n    }", "signature": "IMolecularFormulaSet generate(double mass)", "full_signature": "public IMolecularFormulaSet generate(double mass)", "class_method_signature": "MassToFormulaTool.generate(double mass)", "testcase": false, "constructor": false, "invocations": ["error", "getMinimalFormula", "getMaximalFormula", "getTotalExactMass", "getTotalExactMass", "error", "newInstance", "getIsotopeCount", "iterator", "isotopes", "hasNext", "add", "next", "orderList", "add", "getIsotopeCountMin", "get", "getMaxOccurence", "intValue", "get", "getIsotopeCountMax", "get", "intValue", "get", "getIsotopeCountMin", "get", "intValue", "get", "size", "intValue", "get", "intValue", "get", "intValue", "get", "intValue", "get", "size", "intValue", "get", "intValue", "get", "calculateMassT", "abs", "getFormula", "getString", "equals", "addMolecularFormula", "size", "intValue", "get", "intValue", "get", "intValue", "get", "size", "intValue", "get", "returnOrdered"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}