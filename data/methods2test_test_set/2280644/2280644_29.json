{"test_class": {"identifier": "MapCommandTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Key completeChar = Key.CTRL_I;", "modifier": "private final", "type": "Key", "declarator": "completeChar = Key.CTRL_I", "var_name": "completeChar"}], "file": "aesh/src/test/java/org/aesh/command/map/MapCommandTest.java"}, "test_case": {"identifier": "testExecution", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testExecution() throws Exception {\n        TestConnection connection = new TestConnection(false);\n\n        // Build dynamic command.\n        DynCommand1 cmd = new DynCommand1();\n        DynamicOptionsProvider provider = new DynamicOptionsProvider();\n\n        MapProcessedCommandBuilder builder = MapProcessedCommandBuilder.builder();\n        builder.command(cmd);\n        // Retrieve dynamic options at execution time too, required to check for required option.\n        builder.lookupAtCompletionOnly(false);\n        builder.name(\"dyn1\");\n\n        {\n            ProcessedOptionBuilder optBuilder = ProcessedOptionBuilder.builder();\n            optBuilder.name(\"verbose\");\n            optBuilder.hasValue(false);\n            optBuilder.type(Boolean.class);\n            builder.addOption(optBuilder.build());\n        }\n\n        {\n            ProcessedOptionBuilder optBuilder = ProcessedOptionBuilder.builder();\n            optBuilder.name(\"dir\");\n            optBuilder.hasValue(true);\n            optBuilder.type(String.class);\n            builder.addOption(optBuilder.build());\n        }\n        builder.optionProvider(provider);\n\n        CommandRegistry registry = AeshCommandRegistryBuilder.builder()\n                .command(builder.create())\n                .create();\n\n        Settings settings = SettingsBuilder.builder()\n                .logging(true)\n                .connection(connection)\n                .commandRegistry(registry)\n                .build();\n\n        ReadlineConsole console = new ReadlineConsole(settings);\n        console.setPrompt(new Prompt(\"\"));\n        console.start();\n\n        // First test without any dynamic option provided.\n        connection.clearOutputBuffer();\n        connection.read(\"dyn1\");\n        // Execute command.\n        connection.read(Config.getLineSeparator());\n        connection.clearOutputBuffer();\n        Thread.sleep(200);\n        assertFalse(cmd.contains(\"verbose\"));\n        assertFalse(cmd.contains(\"dir\"));\n\n        connection.read(\"dyn1 --verbose\");\n        // Execute command.\n        connection.read(Config.getLineSeparator());\n        connection.clearOutputBuffer();\n        Thread.sleep(200);\n        assertTrue(cmd.contains(\"verbose\"));\n        assertFalse(cmd.contains(\"dir\"));\n\n        connection.read(\"dyn1 --dir=toto\");\n        // Execute command.\n        connection.read(Config.getLineSeparator());\n        connection.clearOutputBuffer();\n        Thread.sleep(200);\n        assertFalse(cmd.contains(\"verbose\"));\n        assertTrue(cmd.contains(\"dir\"));\n        assertFalse(cmd.contains(\"opt-dyn1-withvalue\"));\n\n        // add dynamic options\n        provider.options = getOptions();\n\n        connection.read(\"dyn1 --opt-dyn1-withvalue=foo\");\n        // Execute command.\n        connection.read(Config.getLineSeparator());\n        connection.clearOutputBuffer();\n        Thread.sleep(200);\n        assertFalse(cmd.contains(\"verbose\"));\n        assertFalse(cmd.contains(\"dir\"));\n        assertTrue(cmd.contains(\"opt-dyn1-withvalue\"));\n        assertFalse(cmd.contains(\"opt-dyn2-withvalue\"));\n        assertFalse(cmd.contains(\"opt-dyn3-novalue\"));\n\n        // Update to a new set if options.\n        provider.options = getOptionsRequired();\n        connection.read(\"dyn1\");\n        // Execute command.\n        connection.read(Config.getLineSeparator());\n        Thread.sleep(200);\n        assertTrue(connection.getOutputBuffer().contains(\"Option: --opt-dyn1-required is required for this command\"));\n        connection.clearOutputBuffer();\n\n        connection.read(\"dyn1 --opt-dyn1-required=xxx\");\n        // Execute command.\n        connection.read(Config.getLineSeparator());\n        Thread.sleep(200);\n        assertTrue(connection.getOutputBuffer().contains(\"Option: --opt-dyn2-required is required for this command\"));\n        connection.clearOutputBuffer();\n\n        connection.read(\"dyn1 --opt-dyn1-required=xxx --opt-dyn2-required=yyy\");\n        // Execute command.\n        connection.read(Config.getLineSeparator());\n        connection.clearOutputBuffer();\n        Thread.sleep(200);\n        assertTrue(connection.getOutputBuffer(), cmd.contains(\"opt-dyn1-required\"));\n        assertTrue(connection.getOutputBuffer(), cmd.contains(\"opt-dyn2-required\"));\n        assertFalse(cmd.contains(\"opt-dyn1-withvalue\"));\n        assertFalse(cmd.contains(\"opt-dyn2-withvalue\"));\n        assertFalse(cmd.contains(\"opt-dyn3-novalue\"));\n    }", "signature": "void testExecution()", "full_signature": "@Test public void testExecution()", "class_method_signature": "MapCommandTest.testExecution()", "testcase": true, "constructor": false, "invocations": ["builder", "command", "lookupAtCompletionOnly", "name", "builder", "name", "hasValue", "type", "addOption", "build", "builder", "name", "hasValue", "type", "addOption", "build", "optionProvider", "create", "command", "builder", "create", "build", "commandRegistry", "connection", "logging", "builder", "setPrompt", "start", "clearOutputBuffer", "read", "read", "getLineSeparator", "clearOutputBuffer", "sleep", "assertFalse", "contains", "assertFalse", "contains", "read", "read", "getLineSeparator", "clearOutputBuffer", "sleep", "assertTrue", "contains", "assertFalse", "contains", "read", "read", "getLineSeparator", "clearOutputBuffer", "sleep", "assertFalse", "contains", "assertTrue", "contains", "assertFalse", "contains", "getOptions", "read", "read", "getLineSeparator", "clearOutputBuffer", "sleep", "assertFalse", "contains", "assertFalse", "contains", "assertTrue", "contains", "assertFalse", "contains", "assertFalse", "contains", "getOptionsRequired", "read", "read", "getLineSeparator", "sleep", "assertTrue", "contains", "getOutputBuffer", "clearOutputBuffer", "read", "read", "getLineSeparator", "sleep", "assertTrue", "contains", "getOutputBuffer", "clearOutputBuffer", "read", "read", "getLineSeparator", "clearOutputBuffer", "sleep", "assertTrue", "getOutputBuffer", "contains", "assertTrue", "getOutputBuffer", "contains", "assertFalse", "contains", "assertFalse", "contains", "assertFalse", "contains"]}, "focal_class": {"identifier": "MapCommand", "superclass": "", "interfaces": "implements Command<T>", "fields": [{"original_string": "private final Map<String, Object> values = new HashMap<>();", "modifier": "private final", "type": "Map<String, Object>", "declarator": "values = new HashMap<>()", "var_name": "values"}], "methods": [{"identifier": "getValue", "parameters": "(String name)", "modifiers": "public", "return": "Object", "signature": "Object getValue(String name)", "full_signature": "public Object getValue(String name)", "class_method_signature": "MapCommand.getValue(String name)", "testcase": false, "constructor": false}, {"identifier": "setValue", "parameters": "(String name, Object value)", "modifiers": "public", "return": "void", "signature": "void setValue(String name, Object value)", "full_signature": "public void setValue(String name, Object value)", "class_method_signature": "MapCommand.setValue(String name, Object value)", "testcase": false, "constructor": false}, {"identifier": "resetValue", "parameters": "(String name)", "modifiers": "public", "return": "void", "signature": "void resetValue(String name)", "full_signature": "public void resetValue(String name)", "class_method_signature": "MapCommand.resetValue(String name)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(String name)", "modifiers": "public", "return": "boolean", "signature": "boolean contains(String name)", "full_signature": "public boolean contains(String name)", "class_method_signature": "MapCommand.contains(String name)", "testcase": false, "constructor": false}, {"identifier": "getValues", "parameters": "()", "modifiers": "public", "return": "Map<String, Object>", "signature": "Map<String, Object> getValues()", "full_signature": "public Map<String, Object> getValues()", "class_method_signature": "MapCommand.getValues()", "testcase": false, "constructor": false}, {"identifier": "checkForRequiredOptions", "parameters": "(ParsedLine pl)", "modifiers": "public", "return": "boolean", "signature": "boolean checkForRequiredOptions(ParsedLine pl)", "full_signature": "public boolean checkForRequiredOptions(ParsedLine pl)", "class_method_signature": "MapCommand.checkForRequiredOptions(ParsedLine pl)", "testcase": false, "constructor": false}, {"identifier": "resetAll", "parameters": "()", "modifiers": "", "return": "void", "signature": "void resetAll()", "full_signature": " void resetAll()", "class_method_signature": "MapCommand.resetAll()", "testcase": false, "constructor": false}], "file": "aesh/src/main/java/org/aesh/command/map/MapCommand.java"}, "focal_method": {"identifier": "contains", "parameters": "(String name)", "modifiers": "public", "return": "boolean", "body": "public boolean contains(String name) {\n        return values.containsKey(name);\n    }", "signature": "boolean contains(String name)", "full_signature": "public boolean contains(String name)", "class_method_signature": "MapCommand.contains(String name)", "testcase": false, "constructor": false, "invocations": ["containsKey"]}, "repository": {"repo_id": 2280644, "url": "https://github.com/aeshell/aesh", "language": "Java", "is_fork": false, "fork_count": 62, "stargazer_count": 83, "size": 6068, "license": "licensed"}}