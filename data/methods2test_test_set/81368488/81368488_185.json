{"test_class": {"identifier": "WhereIsItTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Mock(answer = Answers.RETURNS_DEEP_STUBS)\n    IGameContext mockGameContext;", "modifier": "@Mock(answer = Answers.RETURNS_DEEP_STUBS)", "type": "IGameContext", "declarator": "mockGameContext", "var_name": "mockGameContext"}, {"original_string": "@Mock\n    Stats mockStats;", "modifier": "@Mock", "type": "Stats", "declarator": "mockStats", "var_name": "mockStats"}, {"original_string": "@Mock\n    Configuration mockConfig;", "modifier": "@Mock", "type": "Configuration", "declarator": "mockConfig", "var_name": "mockConfig"}, {"original_string": "private static final String FILESEPARATOR = File.separator;", "modifier": "private static final", "type": "String", "declarator": "FILESEPARATOR = File.separator", "var_name": "FILESEPARATOR"}], "file": "gazeplay-games/src/test/java/net/gazeplay/games/whereisit/WhereIsItTest.java"}, "test_case": {"identifier": "shouldPickAndBuildRandomCustomPictures", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n    void shouldPickAndBuildRandomCustomPictures() {\n        final WhereIsIt whereIsIt = new WhereIsIt(WhereIsItGameType.CUSTOMIZED, 2, 2, false, mockGameContext, mockStats);\n        when(mockConfig.getLanguage()).thenReturn(\"eng\");\n        final String currentDir = System.getProperty(\"user.dir\") +\n            FILESEPARATOR + \"src\" +\n            FILESEPARATOR + \"test\" +\n            FILESEPARATOR + \"resources\";\n        when(mockConfig.getWhereIsItDir()).thenReturn(currentDir);\n\n        final Dimension2D mockDimension = new Dimension2D(20, 20);\n        when(mockGameContext.getGamePanelDimensionProvider().getDimension2D()).thenReturn(mockDimension);\n        when(mockGameContext.getConfiguration()).thenReturn(mockConfig);\n\n        final ReplayablePseudoRandom random = new ReplayablePseudoRandom();\n        final RoundDetails randomPictures = whereIsIt.pickAndBuildRandomPictures(4, random, 0);\n        assert randomPictures.getPictureCardList().size() == 4;\n    }", "signature": "void shouldPickAndBuildRandomCustomPictures()", "full_signature": "@Test void shouldPickAndBuildRandomCustomPictures()", "class_method_signature": "WhereIsItTest.shouldPickAndBuildRandomCustomPictures()", "testcase": true, "constructor": false, "invocations": ["thenReturn", "when", "getLanguage", "getProperty", "thenReturn", "when", "getWhereIsItDir", "thenReturn", "when", "getDimension2D", "getGamePanelDimensionProvider", "thenReturn", "when", "getConfiguration", "pickAndBuildRandomPictures", "size", "getPictureCardList"]}, "focal_class": {"identifier": "WhereIsIt", "superclass": "", "interfaces": "implements GameLifeCycle", "fields": [{"original_string": "private static final int NBMAXPICTO = 10;", "modifier": "private static final", "type": "int", "declarator": "NBMAXPICTO = 10", "var_name": "NBMAXPICTO"}, {"original_string": "private static final double MAXSIZEPICTO = 250;", "modifier": "private static final", "type": "double", "declarator": "MAXSIZEPICTO = 250", "var_name": "MAXSIZEPICTO"}, {"original_string": "private Text questionText;", "modifier": "private", "type": "Text", "declarator": "questionText", "var_name": "questionText"}, {"original_string": "@Getter\n    private final WhereIsItGameType gameType;", "modifier": "@Getter\n    private final", "type": "WhereIsItGameType", "declarator": "gameType", "var_name": "gameType"}, {"original_string": "private final int nbLines;", "modifier": "private final", "type": "int", "declarator": "nbLines", "var_name": "nbLines"}, {"original_string": "private final int nbColumns;", "modifier": "private final", "type": "int", "declarator": "nbColumns", "var_name": "nbColumns"}, {"original_string": "private final boolean fourThree;", "modifier": "private final", "type": "boolean", "declarator": "fourThree", "var_name": "fourThree"}, {"original_string": "private final IGameContext gameContext;", "modifier": "private final", "type": "IGameContext", "declarator": "gameContext", "var_name": "gameContext"}, {"original_string": "private final Stats stats;", "modifier": "private final", "type": "Stats", "declarator": "stats", "var_name": "stats"}, {"original_string": "private RoundDetails currentRoundDetails;", "modifier": "private", "type": "RoundDetails", "declarator": "currentRoundDetails", "var_name": "currentRoundDetails"}, {"original_string": "private final ArrayList<TargetAOI> targetAOIList;", "modifier": "private final", "type": "ArrayList<TargetAOI>", "declarator": "targetAOIList", "var_name": "targetAOIList"}], "methods": [{"identifier": "WhereIsIt", "parameters": "(final WhereIsItGameType gameType, final int nbLines, final int nbColumns, final boolean fourThree,\n                     final IGameContext gameContext, final Stats stats)", "modifiers": "public", "return": "", "signature": " WhereIsIt(final WhereIsItGameType gameType, final int nbLines, final int nbColumns, final boolean fourThree,\n                     final IGameContext gameContext, final Stats stats)", "full_signature": "public  WhereIsIt(final WhereIsItGameType gameType, final int nbLines, final int nbColumns, final boolean fourThree,\n                     final IGameContext gameContext, final Stats stats)", "class_method_signature": "WhereIsIt.WhereIsIt(final WhereIsItGameType gameType, final int nbLines, final int nbColumns, final boolean fourThree,\n                     final IGameContext gameContext, final Stats stats)", "testcase": false, "constructor": true}, {"identifier": "launch", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void launch()", "full_signature": "@Override public void launch()", "class_method_signature": "WhereIsIt.launch()", "testcase": false, "constructor": false}, {"identifier": "createQuestionTransition", "parameters": "(final String question, final List<Image> listOfPictos)", "modifiers": "private", "return": "Transition", "signature": "Transition createQuestionTransition(final String question, final List<Image> listOfPictos)", "full_signature": "private Transition createQuestionTransition(final String question, final List<Image> listOfPictos)", "class_method_signature": "WhereIsIt.createQuestionTransition(final String question, final List<Image> listOfPictos)", "testcase": false, "constructor": false}, {"identifier": "playQuestionSound", "parameters": "()", "modifiers": "", "return": "void", "signature": "void playQuestionSound()", "full_signature": " void playQuestionSound()", "class_method_signature": "WhereIsIt.playQuestionSound()", "testcase": false, "constructor": false}, {"identifier": "dispose", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void dispose()", "full_signature": "@Override public void dispose()", "class_method_signature": "WhereIsIt.dispose()", "testcase": false, "constructor": false}, {"identifier": "removeAllIncorrectPictureCards", "parameters": "()", "modifiers": "", "return": "void", "signature": "void removeAllIncorrectPictureCards()", "full_signature": " void removeAllIncorrectPictureCards()", "class_method_signature": "WhereIsIt.removeAllIncorrectPictureCards()", "testcase": false, "constructor": false}, {"identifier": "fileIsImageFile", "parameters": "(File file)", "modifiers": "static", "return": "boolean", "signature": "boolean fileIsImageFile(File file)", "full_signature": "static boolean fileIsImageFile(File file)", "class_method_signature": "WhereIsIt.fileIsImageFile(File file)", "testcase": false, "constructor": false}, {"identifier": "pickAndBuildRandomPictures", "parameters": "(final int numberOfImagesToDisplayPerRound, final ReplayablePseudoRandom random,\n                                            final int winnerImageIndexAmongDisplayedImages)", "modifiers": "", "return": "RoundDetails", "signature": "RoundDetails pickAndBuildRandomPictures(final int numberOfImagesToDisplayPerRound, final ReplayablePseudoRandom random,\n                                            final int winnerImageIndexAmongDisplayedImages)", "full_signature": " RoundDetails pickAndBuildRandomPictures(final int numberOfImagesToDisplayPerRound, final ReplayablePseudoRandom random,\n                                            final int winnerImageIndexAmongDisplayedImages)", "class_method_signature": "WhereIsIt.pickAndBuildRandomPictures(final int numberOfImagesToDisplayPerRound, final ReplayablePseudoRandom random,\n                                            final int winnerImageIndexAmongDisplayedImages)", "testcase": false, "constructor": false}, {"identifier": "getFiles", "parameters": "(final File folder)", "modifiers": "private", "return": "File[]", "signature": "File[] getFiles(final File folder)", "full_signature": "private File[] getFiles(final File folder)", "class_method_signature": "WhereIsIt.getFiles(final File folder)", "testcase": false, "constructor": false}, {"identifier": "error", "parameters": "(final String language)", "modifiers": "private", "return": "void", "signature": "void error(final String language)", "full_signature": "private void error(final String language)", "class_method_signature": "WhereIsIt.error(final String language)", "testcase": false, "constructor": false}, {"identifier": "getPathSound", "parameters": "(final String folder, final String language)", "modifiers": "private", "return": "String", "signature": "String getPathSound(final String folder, final String language)", "full_signature": "private String getPathSound(final String folder, final String language)", "class_method_signature": "WhereIsIt.getPathSound(final String folder, final String language)", "testcase": false, "constructor": false}, {"identifier": "getQuestionText", "parameters": "(final String folder, final String language)", "modifiers": "private", "return": "String", "signature": "String getQuestionText(final String folder, final String language)", "full_signature": "private String getQuestionText(final String folder, final String language)", "class_method_signature": "WhereIsIt.getQuestionText(final String folder, final String language)", "testcase": false, "constructor": false}, {"identifier": "getPictogramms", "parameters": "(final String folder)", "modifiers": "private", "return": "List<Image>", "signature": "List<Image> getPictogramms(final String folder)", "full_signature": "private List<Image> getPictogramms(final String folder)", "class_method_signature": "WhereIsIt.getPictogramms(final String folder)", "testcase": false, "constructor": false}], "file": "gazeplay-games/src/main/java/net/gazeplay/games/whereisit/WhereIsIt.java"}, "focal_method": {"identifier": "pickAndBuildRandomPictures", "parameters": "(final int numberOfImagesToDisplayPerRound, final ReplayablePseudoRandom random,\n                                            final int winnerImageIndexAmongDisplayedImages)", "modifiers": "", "return": "RoundDetails", "body": "RoundDetails pickAndBuildRandomPictures(final int numberOfImagesToDisplayPerRound, final ReplayablePseudoRandom random,\n                                            final int winnerImageIndexAmongDisplayedImages) {\n\n        final Configuration config = gameContext.getConfiguration();\n\n        int filesCount;\n        final String directoryName;\n        List<File> imagesFolders = new LinkedList<>();\n        List<String> resourcesFolders = new LinkedList<>();\n\n        if (this.gameType == CUSTOMIZED) {\n            final File imagesDirectory = new File(config.getWhereIsItDir() + \"/images/\");\n            directoryName = imagesDirectory.getPath();\n            filesCount = 0;\n            File[] listOfTheFiles = imagesDirectory.listFiles();\n            if(listOfTheFiles!=null) {\n                for (File f : listOfTheFiles) {\n                    File[] filesInf = f.listFiles();\n                    if(filesInf != null) {\n                        if (f.isDirectory() && filesInf.length > 0){\n                            boolean containsImage = false;\n                            int i = 0;\n                            while( !containsImage && i < filesInf.length) {\n                                File file = filesInf[i];\n                                containsImage = fileIsImageFile(file);\n                                i++;\n                            }\n                            if(containsImage) {\n                                imagesFolders.add(f);\n                                filesCount++;\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            final String resourcesDirectory = \"data/\" + this.gameType.getResourcesDirectoryName();\n            final String imagesDirectory = resourcesDirectory + \"/images/\";\n            directoryName = imagesDirectory;\n\n            // Here we filter out any unwanted resource folders, based on the difficulty JSON file\n            Set<String> difficultySet;\n            try {\n                SourceSet sourceSet = new SourceSet(resourcesDirectory + \"/difficulties.json\");\n                difficultySet = (sourceSet.getResources(this.gameType.getDifficulty()));\n            } catch (FileNotFoundException fe) {\n                log.info(\"No difficulty file found; Reading from all directories\");\n                difficultySet = Collections.emptySet();\n            }\n\n            Set<String> tempResourcesFolders = ResourceFileManager.getResourceFolders(imagesDirectory);\n\n            // If nothing can be found we take the entire folder contents.\n            if (!difficultySet.isEmpty()) {\n                Set<String> finalDifficultySet = difficultySet;\n                tempResourcesFolders = tempResourcesFolders\n                    .parallelStream()\n                    .filter(s ->\n                        finalDifficultySet.parallelStream().anyMatch(s::contains)\n                    )\n                    .collect(Collectors.toSet());\n            }\n\n            resourcesFolders.addAll(tempResourcesFolders);\n\n            filesCount = resourcesFolders.size();\n        }\n\n        final String language = config.getLanguage();\n\n        if (filesCount == 0) {\n            log.warn(\"No images found in Directory \" + directoryName);\n            error(language);\n            return null;\n        }\n\n        int posX = 0;\n        int posY = 0;\n\n        final GameSizing gameSizing = new GameSizingComputer(nbLines, nbColumns, fourThree)\n            .computeGameSizing(gameContext.getGamePanelDimensionProvider().getDimension2D());\n\n        final List<PictureCard> pictureCardList = new ArrayList<>();\n        String questionSoundPath = null;\n        String question = null;\n        List<Image> pictograms = null;\n        if (this.gameType == FIND_ODD) {\n\n            int index = random.nextInt(resourcesFolders.size());\n            final String folder = resourcesFolders.remove((index) % filesCount);\n\n            index = random.nextInt(resourcesFolders.size());\n            final String winnerFolder = resourcesFolders.remove((index) % filesCount);\n            final String folderName = (new File(winnerFolder)).getName();\n\n            for (int i = 0; i < numberOfImagesToDisplayPerRound; i++) {\n                final Set<String> files;\n                if (i == winnerImageIndexAmongDisplayedImages) {\n                    files = ResourceFileManager.getResourcePaths(winnerFolder);\n                } else {\n                    files = ResourceFileManager.getResourcePaths(folder);\n                }\n\n                final int numFile = random.nextInt(files.size());\n\n                final String randomImageFile = (String) files.toArray()[numFile];\n\n                if (winnerImageIndexAmongDisplayedImages == i) {\n\n                    // TODO for now the line under is commented to avoid freeze\n                    //questionSoundPath = getPathSound(imagesFolders[(index) % filesCount].getName(), language);\n\n                    question = MultilinguismFactory.getSingleton().getTranslation(\"findodd\", config.getLanguage());\n\n                    pictograms = getPictogramms(folderName);\n\n                }\n\n                final PictureCard pictureCard = new PictureCard(gameSizing.width * posX + gameSizing.shift,\n                    gameSizing.height * posY, gameSizing.width, gameSizing.height, gameContext, winnerImageIndexAmongDisplayedImages == i,\n                    randomImageFile + \"\", stats, this);\n\n                final TargetAOI targetAOI = new TargetAOI(gameSizing.width * (posX + 0.25), gameSizing.height * (posY+1), (int)gameSizing.height,\n                    System.currentTimeMillis());\n                targetAOIList.add(targetAOI);\n\n                pictureCardList.add(pictureCard);\n\n                if ((i + 1) % nbColumns != 0) {\n                    posX++;\n                } else {\n                    posY++;\n                    posX = 0;\n                }\n            }\n\n        } else if (this.gameType == CUSTOMIZED) {\n\n            for (int i = 0; i < numberOfImagesToDisplayPerRound; i++) {\n\n                int index = random.nextInt(imagesFolders.size());\n\n                final File folder = imagesFolders.remove((index) % filesCount);\n\n                final File[] files = getFiles(folder);\n\n                List<File> validImageFiles = new ArrayList<>();\n\n                for ( File file: files){\n                    if(fileIsImageFile(file)){\n                        validImageFiles.add(file);\n                    }\n                }\n\n                final int numFile = random.nextInt(validImageFiles.size());\n\n                final File randomImageFile = validImageFiles.get(numFile);\n\n                if (winnerImageIndexAmongDisplayedImages == i) {\n\n                    questionSoundPath = getPathSound(folder.getName(), language);\n\n                    question = getQuestionText(folder.getName(), language);\n\n                    pictograms = getPictogramms(folder.getName());\n\n                }\n\n                // The image file needs 'file:' prepended as this will get images from a local source, not resources.\n                final PictureCard pictureCard = new PictureCard(gameSizing.width * posX + gameSizing.shift,\n                    gameSizing.height * posY, gameSizing.width, gameSizing.height, gameContext,\n                    winnerImageIndexAmongDisplayedImages == i, \"file:\" + randomImageFile, stats, this);\n\n                final TargetAOI targetAOI = new TargetAOI(gameSizing.width * (posX + 0.25), gameSizing.height * (posY+1), (int)gameSizing.height,\n                    System.currentTimeMillis());\n                targetAOIList.add(targetAOI);\n\n                pictureCardList.add(pictureCard);\n\n\n                if ((i + 1) % nbColumns != 0) {\n                    posX++;\n                } else {\n                    posY++;\n                    posX = 0;\n                }\n            }\n        } else {\n            for (int i = 0; i < numberOfImagesToDisplayPerRound; i++) {\n                int index = random.nextInt(resourcesFolders.size());\n\n                final String folder = resourcesFolders.remove((index) % filesCount);\n                final String folderName = (new File(folder)).getName();\n\n                final Set<String> files = ResourceFileManager.getResourcePaths(folder);\n\n                final int numFile = random.nextInt(files.size());\n\n                final String randomImageFile = (String) files.toArray()[numFile];\n\n                if (winnerImageIndexAmongDisplayedImages == i) {\n\n                    questionSoundPath = getPathSound(folderName, language);\n\n                    question = getQuestionText(folderName, language);\n\n                    pictograms = getPictogramms(folderName);\n\n                }\n\n                final PictureCard pictureCard = new PictureCard(gameSizing.width * posX + gameSizing.shift,\n                    gameSizing.height * posY, gameSizing.width, gameSizing.height, gameContext,\n                    winnerImageIndexAmongDisplayedImages == i, randomImageFile + \"\", stats, this);\n\n                pictureCardList.add(pictureCard);\n\n                final TargetAOI targetAOI = new TargetAOI(gameSizing.width * (posX + 0.25), gameSizing.height * (posY+1), (int)gameSizing.height,\n                    System.currentTimeMillis());\n                targetAOIList.add(targetAOI);\n\n\n                if ((i + 1) % nbColumns != 0) {\n                    posX++;\n                } else {\n                    posY++;\n                    posX = 0;\n                }\n            }\n        }\n        return new RoundDetails(pictureCardList, winnerImageIndexAmongDisplayedImages, questionSoundPath, question,\n            pictograms);\n    }", "signature": "RoundDetails pickAndBuildRandomPictures(final int numberOfImagesToDisplayPerRound, final ReplayablePseudoRandom random,\n                                            final int winnerImageIndexAmongDisplayedImages)", "full_signature": " RoundDetails pickAndBuildRandomPictures(final int numberOfImagesToDisplayPerRound, final ReplayablePseudoRandom random,\n                                            final int winnerImageIndexAmongDisplayedImages)", "class_method_signature": "WhereIsIt.pickAndBuildRandomPictures(final int numberOfImagesToDisplayPerRound, final ReplayablePseudoRandom random,\n                                            final int winnerImageIndexAmongDisplayedImages)", "testcase": false, "constructor": false, "invocations": ["getConfiguration", "getWhereIsItDir", "getPath", "listFiles", "listFiles", "isDirectory", "fileIsImageFile", "add", "getResourcesDirectoryName", "getResources", "getDifficulty", "info", "emptySet", "getResourceFolders", "isEmpty", "collect", "filter", "parallelStream", "anyMatch", "parallelStream", "toSet", "addAll", "size", "getLanguage", "warn", "error", "computeGameSizing", "getDimension2D", "getGamePanelDimensionProvider", "nextInt", "size", "remove", "nextInt", "size", "remove", "getName", "getResourcePaths", "getResourcePaths", "nextInt", "size", "toArray", "getTranslation", "getSingleton", "getLanguage", "getPictogramms", "currentTimeMillis", "add", "add", "nextInt", "size", "remove", "getFiles", "fileIsImageFile", "add", "nextInt", "size", "get", "getPathSound", "getName", "getQuestionText", "getName", "getPictogramms", "getName", "currentTimeMillis", "add", "add", "nextInt", "size", "remove", "getName", "getResourcePaths", "nextInt", "size", "toArray", "getPathSound", "getQuestionText", "getPictogramms", "add", "currentTimeMillis", "add"]}, "repository": {"repo_id": 81368488, "url": "https://github.com/GazePlay/GazePlay", "stars": 15, "created": "2/8/2017 7:39:08 PM +00:00", "updates": "2020-01-26T16:45:47+00:00", "fork": "False", "license": "licensed"}}