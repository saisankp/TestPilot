{"test_class": {"identifier": "DeviceManagerImplTest", "superclass": "extends FloodlightTestCase", "interfaces": "", "fields": [{"original_string": "protected static Logger logger =\n            LoggerFactory.getLogger(DeviceManagerImplTest.class);", "modifier": "protected static", "type": "Logger", "declarator": "logger =\n            LoggerFactory.getLogger(DeviceManagerImplTest.class)", "var_name": "logger"}, {"original_string": "protected OFPacketIn packetIn_1, packetIn_2, packetIn_3;", "modifier": "protected", "type": "OFPacketIn", "declarator": "packetIn_1", "var_name": "packetIn_1"}, {"original_string": "protected IPacket testARPReplyPacket_1, testARPReplyPacket_2,\n    testARPReplyPacket_3;", "modifier": "protected", "type": "IPacket", "declarator": "testARPReplyPacket_1", "var_name": "testARPReplyPacket_1"}, {"original_string": "protected IPacket testARPReqPacket_1, testARPReqPacket_2;", "modifier": "protected", "type": "IPacket", "declarator": "testARPReqPacket_1", "var_name": "testARPReqPacket_1"}, {"original_string": "protected byte[] testARPReplyPacket_1_Srld, testARPReplyPacket_2_Srld;", "modifier": "protected", "type": "byte[]", "declarator": "testARPReplyPacket_1_Srld", "var_name": "testARPReplyPacket_1_Srld"}, {"original_string": "private byte[] testARPReplyPacket_3_Serialized;", "modifier": "private", "type": "byte[]", "declarator": "testARPReplyPacket_3_Serialized", "var_name": "testARPReplyPacket_3_Serialized"}, {"original_string": "MockFloodlightProvider mockFloodlightProvider;", "modifier": "", "type": "MockFloodlightProvider", "declarator": "mockFloodlightProvider", "var_name": "mockFloodlightProvider"}, {"original_string": "DeviceManagerImpl deviceManager;", "modifier": "", "type": "DeviceManagerImpl", "declarator": "deviceManager", "var_name": "deviceManager"}, {"original_string": "MemoryStorageSource storageSource;", "modifier": "", "type": "MemoryStorageSource", "declarator": "storageSource", "var_name": "storageSource"}, {"original_string": "FlowReconcileManager flowReconcileMgr;", "modifier": "", "type": "FlowReconcileManager", "declarator": "flowReconcileMgr", "var_name": "flowReconcileMgr"}], "file": "network-level/fl-ho-nl/src/test/java/net/floodlightcontroller/devicemanager/internal/DeviceManagerImplTest.java"}, "test_case": {"identifier": "testAttachmentPointFlapping", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testAttachmentPointFlapping() throws Exception {\n        Calendar c = Calendar.getInstance();\n\n        ITopologyService mockTopology = createMock(ITopologyService.class);\n        expect(mockTopology.isAttachmentPointPort(anyLong(),\n                                                  anyShort())).andReturn(true).anyTimes();\n        expect(mockTopology.isBroadcastDomainPort(anyLong(),\n                                                  anyShort())).\n                                                  andReturn(false).anyTimes();\n        expect(mockTopology.isInSameBroadcastDomain(anyLong(), anyShort(),\n                                                    anyLong(), anyShort())).andReturn(false).anyTimes();\n        expect(mockTopology.getL2DomainId(anyLong())).\n        andReturn(1L).anyTimes();\n        expect(mockTopology.isConsistent(1L, (short)1, 1L, (short)1)).\n        andReturn(true).anyTimes();\n        expect(mockTopology.isConsistent(1L, (short)1, 5L, (short)1)).\n        andReturn(false).anyTimes();\n        expect(mockTopology.isConsistent(1L, (short)1, 10L, (short)1)).\n        andReturn(false).anyTimes();\n        expect(mockTopology.isConsistent(5L, (short)1, 10L, (short)1)).\n        andReturn(false).anyTimes();\n        expect(mockTopology.isConsistent(10L, (short)1, 1L, (short)1)).\n        andReturn(false).anyTimes();\n        expect(mockTopology.isConsistent(5L, (short)1, 1L, (short)1)).\n        andReturn(false).anyTimes();\n        expect(mockTopology.isConsistent(10L, (short)1, 5L, (short)1)).\n        andReturn(false).anyTimes();\n\n        Date topologyUpdateTime = new Date();\n        expect(mockTopology.getLastUpdateTime()).andReturn(topologyUpdateTime).\n        anyTimes();\n\n\n        replay(mockTopology);\n        deviceManager.topology = mockTopology;\n\n        Entity entity1 = new Entity(1L, null, null, 1L, 1, c.getTime());\n        Entity entity1a = new Entity(1L, null, 1, 1L, 1, c.getTime());\n        Entity entity2 = new Entity(1L, null, null, 5L, 1, c.getTime());\n        Entity entity3 = new Entity(1L, null, null, 10L, 1, c.getTime());\n        entity1.setLastSeenTimestamp(c.getTime());\n        c.add(Calendar.MILLISECOND, Entity.ACTIVITY_TIMEOUT/2);\n        entity1a.setLastSeenTimestamp(c.getTime());\n        c.add(Calendar.MILLISECOND, 1);\n        entity2.setLastSeenTimestamp(c.getTime());\n        c.add(Calendar.MILLISECOND, 1);\n        entity3.setLastSeenTimestamp(c.getTime());\n\n\n\n        IDevice d;\n        d = deviceManager.learnDeviceByEntity(entity1);\n        d = deviceManager.learnDeviceByEntity(entity1a);\n        d = deviceManager.learnDeviceByEntity(entity2);\n        d = deviceManager.learnDeviceByEntity(entity3);\n\n        // all entities are active, so entity3 should win\n        assertArrayEquals(new SwitchPort[] { new SwitchPort(10L, 1) },\n                          d.getAttachmentPoints());\n\n        assertArrayEquals(new SwitchPort[] { new SwitchPort(10L, 1),},\n                              d.getAttachmentPoints(true));\n\n        c.add(Calendar.MILLISECOND, Entity.ACTIVITY_TIMEOUT/4);\n        entity1.setLastSeenTimestamp(c.getTime());\n        d = deviceManager.learnDeviceByEntity(entity1);\n\n        // all are still active; entity3 should still win\n        assertArrayEquals(new SwitchPort[] { new SwitchPort(1L, 1) },\n                          d.getAttachmentPoints());\n        assertArrayEquals(new SwitchPort[] { new SwitchPort(1L, 1),\n                                             new SwitchPort(5L, 1,\n                                                            ErrorStatus.DUPLICATE_DEVICE),\n                                                            new SwitchPort(10L, 1,\n                                                                           ErrorStatus.DUPLICATE_DEVICE) },\n                                                                           d.getAttachmentPoints(true));\n\n        c.add(Calendar.MILLISECOND, Entity.ACTIVITY_TIMEOUT+2000);\n        entity1.setLastSeenTimestamp(c.getTime());\n        d = deviceManager.learnDeviceByEntity(entity1);\n\n        assertEquals(entity1.getActiveSince(), entity1.getLastSeenTimestamp());\n        // entity1 should now be the only active entity\n        assertArrayEquals(new SwitchPort[] { new SwitchPort(1L, 1) },\n                          d.getAttachmentPoints());\n        assertArrayEquals(new SwitchPort[] { new SwitchPort(1L, 1) },\n                          d.getAttachmentPoints(true));\n    }", "signature": "void testAttachmentPointFlapping()", "full_signature": "@Test public void testAttachmentPointFlapping()", "class_method_signature": "DeviceManagerImplTest.testAttachmentPointFlapping()", "testcase": true, "constructor": false, "invocations": ["getInstance", "createMock", "anyTimes", "andReturn", "expect", "isAttachmentPointPort", "anyLong", "anyShort", "anyTimes", "andReturn", "expect", "isBroadcastDomainPort", "anyLong", "anyShort", "anyTimes", "andReturn", "expect", "isInSameBroadcastDomain", "anyLong", "anyShort", "anyLong", "anyShort", "anyTimes", "andReturn", "expect", "getL2DomainId", "anyLong", "anyTimes", "andReturn", "expect", "isConsistent", "anyTimes", "andReturn", "expect", "isConsistent", "anyTimes", "andReturn", "expect", "isConsistent", "anyTimes", "andReturn", "expect", "isConsistent", "anyTimes", "andReturn", "expect", "isConsistent", "anyTimes", "andReturn", "expect", "isConsistent", "anyTimes", "andReturn", "expect", "isConsistent", "anyTimes", "andReturn", "expect", "getLastUpdateTime", "replay", "getTime", "getTime", "getTime", "getTime", "setLastSeenTimestamp", "getTime", "add", "setLastSeenTimestamp", "getTime", "add", "setLastSeenTimestamp", "getTime", "add", "setLastSeenTimestamp", "getTime", "learnDeviceByEntity", "learnDeviceByEntity", "learnDeviceByEntity", "learnDeviceByEntity", "assertArrayEquals", "getAttachmentPoints", "assertArrayEquals", "getAttachmentPoints", "add", "setLastSeenTimestamp", "getTime", "learnDeviceByEntity", "assertArrayEquals", "getAttachmentPoints", "assertArrayEquals", "getAttachmentPoints", "add", "setLastSeenTimestamp", "getTime", "learnDeviceByEntity", "assertEquals", "getActiveSince", "getLastSeenTimestamp", "assertArrayEquals", "getAttachmentPoints", "assertArrayEquals", "getAttachmentPoints"]}, "focal_class": {"identifier": "DeviceManagerImpl", "superclass": "", "interfaces": "implements\nIDeviceService, IOFMessageListener, ITopologyListener,\nIFloodlightModule, IEntityClassListener,\nIFlowReconcileListener, IInfoProvider, IHAListener", "fields": [{"original_string": "protected static Logger logger =\n            LoggerFactory.getLogger(DeviceManagerImpl.class);", "modifier": "protected static", "type": "Logger", "declarator": "logger =\n            LoggerFactory.getLogger(DeviceManagerImpl.class)", "var_name": "logger"}, {"original_string": "protected IFloodlightProviderService floodlightProvider;", "modifier": "protected", "type": "IFloodlightProviderService", "declarator": "floodlightProvider", "var_name": "floodlightProvider"}, {"original_string": "protected ITopologyService topology;", "modifier": "protected", "type": "ITopologyService", "declarator": "topology", "var_name": "topology"}, {"original_string": "protected IStorageSourceService storageSource;", "modifier": "protected", "type": "IStorageSourceService", "declarator": "storageSource", "var_name": "storageSource"}, {"original_string": "protected IRestApiService restApi;", "modifier": "protected", "type": "IRestApiService", "declarator": "restApi", "var_name": "restApi"}, {"original_string": "protected IThreadPoolService threadPool;", "modifier": "protected", "type": "IThreadPoolService", "declarator": "threadPool", "var_name": "threadPool"}, {"original_string": "protected IFlowReconcileService flowReconcileMgr;", "modifier": "protected", "type": "IFlowReconcileService", "declarator": "flowReconcileMgr", "var_name": "flowReconcileMgr"}, {"original_string": "protected static final int ENTITY_TIMEOUT = 60*60*1000;", "modifier": "protected static final", "type": "int", "declarator": "ENTITY_TIMEOUT = 60*60*1000", "var_name": "ENTITY_TIMEOUT"}, {"original_string": "protected static final int ENTITY_CLEANUP_INTERVAL = 60*60;", "modifier": "protected static final", "type": "int", "declarator": "ENTITY_CLEANUP_INTERVAL = 60*60", "var_name": "ENTITY_CLEANUP_INTERVAL"}, {"original_string": "protected ConcurrentHashMap<Long, Device> deviceMap;", "modifier": "protected", "type": "ConcurrentHashMap<Long, Device>", "declarator": "deviceMap", "var_name": "deviceMap"}, {"original_string": "protected long deviceKeyCounter = 0;", "modifier": "protected", "type": "long", "declarator": "deviceKeyCounter = 0", "var_name": "deviceKeyCounter"}, {"original_string": "protected Object deviceKeyLock = new Object();", "modifier": "protected", "type": "Object", "declarator": "deviceKeyLock = new Object()", "var_name": "deviceKeyLock"}, {"original_string": "protected DeviceUniqueIndex primaryIndex;", "modifier": "protected", "type": "DeviceUniqueIndex", "declarator": "primaryIndex", "var_name": "primaryIndex"}, {"original_string": "protected Map<EnumSet<DeviceField>, DeviceIndex> secondaryIndexMap;", "modifier": "protected", "type": "Map<EnumSet<DeviceField>, DeviceIndex>", "declarator": "secondaryIndexMap", "var_name": "secondaryIndexMap"}, {"original_string": "protected ConcurrentHashMap<String, ClassState> classStateMap;", "modifier": "protected", "type": "ConcurrentHashMap<String, ClassState>", "declarator": "classStateMap", "var_name": "classStateMap"}, {"original_string": "protected Set<EnumSet<DeviceField>> perClassIndices;", "modifier": "protected", "type": "Set<EnumSet<DeviceField>>", "declarator": "perClassIndices", "var_name": "perClassIndices"}, {"original_string": "protected IEntityClassifierService entityClassifier;", "modifier": "protected", "type": "IEntityClassifierService", "declarator": "entityClassifier", "var_name": "entityClassifier"}, {"original_string": "protected Set<IDeviceListener> deviceListeners;", "modifier": "protected", "type": "Set<IDeviceListener>", "declarator": "deviceListeners", "var_name": "deviceListeners"}, {"original_string": "public AttachmentPointComparator apComparator;", "modifier": "public", "type": "AttachmentPointComparator", "declarator": "apComparator", "var_name": "apComparator"}, {"original_string": "private Set<SwitchPort> suppressAPs;", "modifier": "private", "type": "Set<SwitchPort>", "declarator": "suppressAPs", "var_name": "suppressAPs"}, {"original_string": "public SingletonTask entityCleanupTask;", "modifier": "public", "type": "SingletonTask", "declarator": "entityCleanupTask", "var_name": "entityCleanupTask"}], "methods": [{"identifier": "getDevice", "parameters": "(Long deviceKey)", "modifiers": "@Override public", "return": "IDevice", "signature": "IDevice getDevice(Long deviceKey)", "full_signature": "@Override public IDevice getDevice(Long deviceKey)", "class_method_signature": "DeviceManagerImpl.getDevice(Long deviceKey)", "testcase": false, "constructor": false}, {"identifier": "findDevice", "parameters": "(long macAddress, Short vlan,\n                              Integer ipv4Address, Long switchDPID,\n                              Integer switchPort)", "modifiers": "@Override public", "return": "IDevice", "signature": "IDevice findDevice(long macAddress, Short vlan,\n                              Integer ipv4Address, Long switchDPID,\n                              Integer switchPort)", "full_signature": "@Override public IDevice findDevice(long macAddress, Short vlan,\n                              Integer ipv4Address, Long switchDPID,\n                              Integer switchPort)", "class_method_signature": "DeviceManagerImpl.findDevice(long macAddress, Short vlan,\n                              Integer ipv4Address, Long switchDPID,\n                              Integer switchPort)", "testcase": false, "constructor": false}, {"identifier": "findDestDevice", "parameters": "(IDevice source, long macAddress,\n                                  Short vlan, Integer ipv4Address)", "modifiers": "@Override public", "return": "IDevice", "signature": "IDevice findDestDevice(IDevice source, long macAddress,\n                                  Short vlan, Integer ipv4Address)", "full_signature": "@Override public IDevice findDestDevice(IDevice source, long macAddress,\n                                  Short vlan, Integer ipv4Address)", "class_method_signature": "DeviceManagerImpl.findDestDevice(IDevice source, long macAddress,\n                                  Short vlan, Integer ipv4Address)", "testcase": false, "constructor": false}, {"identifier": "getAllDevices", "parameters": "()", "modifiers": "@Override public", "return": "Collection<? extends IDevice>", "signature": "Collection<? extends IDevice> getAllDevices()", "full_signature": "@Override public Collection<? extends IDevice> getAllDevices()", "class_method_signature": "DeviceManagerImpl.getAllDevices()", "testcase": false, "constructor": false}, {"identifier": "addIndex", "parameters": "(boolean perClass,\n                         EnumSet<DeviceField> keyFields)", "modifiers": "@Override public", "return": "void", "signature": "void addIndex(boolean perClass,\n                         EnumSet<DeviceField> keyFields)", "full_signature": "@Override public void addIndex(boolean perClass,\n                         EnumSet<DeviceField> keyFields)", "class_method_signature": "DeviceManagerImpl.addIndex(boolean perClass,\n                         EnumSet<DeviceField> keyFields)", "testcase": false, "constructor": false}, {"identifier": "queryDevices", "parameters": "(Long macAddress,\n                                                    Short vlan,\n                                                    Integer ipv4Address,\n                                                    Long switchDPID,\n                                                    Integer switchPort)", "modifiers": "@Override public", "return": "Iterator<? extends IDevice>", "signature": "Iterator<? extends IDevice> queryDevices(Long macAddress,\n                                                    Short vlan,\n                                                    Integer ipv4Address,\n                                                    Long switchDPID,\n                                                    Integer switchPort)", "full_signature": "@Override public Iterator<? extends IDevice> queryDevices(Long macAddress,\n                                                    Short vlan,\n                                                    Integer ipv4Address,\n                                                    Long switchDPID,\n                                                    Integer switchPort)", "class_method_signature": "DeviceManagerImpl.queryDevices(Long macAddress,\n                                                    Short vlan,\n                                                    Integer ipv4Address,\n                                                    Long switchDPID,\n                                                    Integer switchPort)", "testcase": false, "constructor": false}, {"identifier": "queryClassDevices", "parameters": "(IDevice reference,\n                                                         Long macAddress,\n                                                         Short vlan,\n                                                         Integer ipv4Address,\n                                                         Long switchDPID,\n                                                         Integer switchPort)", "modifiers": "@Override public", "return": "Iterator<? extends IDevice>", "signature": "Iterator<? extends IDevice> queryClassDevices(IDevice reference,\n                                                         Long macAddress,\n                                                         Short vlan,\n                                                         Integer ipv4Address,\n                                                         Long switchDPID,\n                                                         Integer switchPort)", "full_signature": "@Override public Iterator<? extends IDevice> queryClassDevices(IDevice reference,\n                                                         Long macAddress,\n                                                         Short vlan,\n                                                         Integer ipv4Address,\n                                                         Long switchDPID,\n                                                         Integer switchPort)", "class_method_signature": "DeviceManagerImpl.queryClassDevices(IDevice reference,\n                                                         Long macAddress,\n                                                         Short vlan,\n                                                         Integer ipv4Address,\n                                                         Long switchDPID,\n                                                         Integer switchPort)", "testcase": false, "constructor": false}, {"identifier": "getDeviceIteratorForQuery", "parameters": "(Long macAddress,\n                                                        Short vlan,\n                                                        Integer ipv4Address,\n                                                        Long switchDPID,\n                                                        Integer switchPort)", "modifiers": "protected", "return": "Iterator<Device>", "signature": "Iterator<Device> getDeviceIteratorForQuery(Long macAddress,\n                                                        Short vlan,\n                                                        Integer ipv4Address,\n                                                        Long switchDPID,\n                                                        Integer switchPort)", "full_signature": "protected Iterator<Device> getDeviceIteratorForQuery(Long macAddress,\n                                                        Short vlan,\n                                                        Integer ipv4Address,\n                                                        Long switchDPID,\n                                                        Integer switchPort)", "class_method_signature": "DeviceManagerImpl.getDeviceIteratorForQuery(Long macAddress,\n                                                        Short vlan,\n                                                        Integer ipv4Address,\n                                                        Long switchDPID,\n                                                        Integer switchPort)", "testcase": false, "constructor": false}, {"identifier": "addListener", "parameters": "(IDeviceListener listener)", "modifiers": "@Override public", "return": "void", "signature": "void addListener(IDeviceListener listener)", "full_signature": "@Override public void addListener(IDeviceListener listener)", "class_method_signature": "DeviceManagerImpl.addListener(IDeviceListener listener)", "testcase": false, "constructor": false}, {"identifier": "getInfo", "parameters": "(String type)", "modifiers": "@Override public", "return": "Map<String, Object>", "signature": "Map<String, Object> getInfo(String type)", "full_signature": "@Override public Map<String, Object> getInfo(String type)", "class_method_signature": "DeviceManagerImpl.getInfo(String type)", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getName()", "full_signature": "@Override public String getName()", "class_method_signature": "DeviceManagerImpl.getName()", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPrereq", "parameters": "(OFType type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPrereq(OFType type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPrereq(OFType type, String name)", "class_method_signature": "DeviceManagerImpl.isCallbackOrderingPrereq(OFType type, String name)", "testcase": false, "constructor": false}, {"identifier": "isCallbackOrderingPostreq", "parameters": "(OFType type, String name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCallbackOrderingPostreq(OFType type, String name)", "full_signature": "@Override public boolean isCallbackOrderingPostreq(OFType type, String name)", "class_method_signature": "DeviceManagerImpl.isCallbackOrderingPostreq(OFType type, String name)", "testcase": false, "constructor": false}, {"identifier": "receive", "parameters": "(IOFSwitch sw, OFMessage msg,\n                           FloodlightContext cntx)", "modifiers": "@Override public", "return": "Command", "signature": "Command receive(IOFSwitch sw, OFMessage msg,\n                           FloodlightContext cntx)", "full_signature": "@Override public Command receive(IOFSwitch sw, OFMessage msg,\n                           FloodlightContext cntx)", "class_method_signature": "DeviceManagerImpl.receive(IOFSwitch sw, OFMessage msg,\n                           FloodlightContext cntx)", "testcase": false, "constructor": false}, {"identifier": "reconcileFlows", "parameters": "(ArrayList<OFMatchReconcile> ofmRcList)", "modifiers": "@Override public", "return": "Command", "signature": "Command reconcileFlows(ArrayList<OFMatchReconcile> ofmRcList)", "full_signature": "@Override public Command reconcileFlows(ArrayList<OFMatchReconcile> ofmRcList)", "class_method_signature": "DeviceManagerImpl.reconcileFlows(ArrayList<OFMatchReconcile> ofmRcList)", "testcase": false, "constructor": false}, {"identifier": "reconcileFlow", "parameters": "(OFMatchReconcile ofm)", "modifiers": "protected", "return": "Command", "signature": "Command reconcileFlow(OFMatchReconcile ofm)", "full_signature": "protected Command reconcileFlow(OFMatchReconcile ofm)", "class_method_signature": "DeviceManagerImpl.reconcileFlow(OFMatchReconcile ofm)", "testcase": false, "constructor": false}, {"identifier": "getModuleServices", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleServices()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleServices()", "class_method_signature": "DeviceManagerImpl.getModuleServices()", "testcase": false, "constructor": false}, {"identifier": "getServiceImpls", "parameters": "()", "modifiers": "@Override public", "return": "Map<Class<? extends IFloodlightService>, IFloodlightService>", "signature": "Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "full_signature": "@Override public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls()", "class_method_signature": "DeviceManagerImpl.getServiceImpls()", "testcase": false, "constructor": false}, {"identifier": "getModuleDependencies", "parameters": "()", "modifiers": "@Override public", "return": "Collection<Class<? extends IFloodlightService>>", "signature": "Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "full_signature": "@Override public Collection<Class<? extends IFloodlightService>> getModuleDependencies()", "class_method_signature": "DeviceManagerImpl.getModuleDependencies()", "testcase": false, "constructor": false}, {"identifier": "init", "parameters": "(FloodlightModuleContext fmc)", "modifiers": "@Override public", "return": "void", "signature": "void init(FloodlightModuleContext fmc)", "full_signature": "@Override public void init(FloodlightModuleContext fmc)", "class_method_signature": "DeviceManagerImpl.init(FloodlightModuleContext fmc)", "testcase": false, "constructor": false}, {"identifier": "startUp", "parameters": "(FloodlightModuleContext fmc)", "modifiers": "@Override public", "return": "void", "signature": "void startUp(FloodlightModuleContext fmc)", "full_signature": "@Override public void startUp(FloodlightModuleContext fmc)", "class_method_signature": "DeviceManagerImpl.startUp(FloodlightModuleContext fmc)", "testcase": false, "constructor": false}, {"identifier": "roleChanged", "parameters": "(Role oldRole, Role newRole)", "modifiers": "@Override public", "return": "void", "signature": "void roleChanged(Role oldRole, Role newRole)", "full_signature": "@Override public void roleChanged(Role oldRole, Role newRole)", "class_method_signature": "DeviceManagerImpl.roleChanged(Role oldRole, Role newRole)", "testcase": false, "constructor": false}, {"identifier": "controllerNodeIPsChanged", "parameters": "(\n                                         Map<String, String> curControllerNodeIPs,\n                                         Map<String, String> addedControllerNodeIPs,\n                                         Map<String, String> removedControllerNodeIPs)", "modifiers": "@Override public", "return": "void", "signature": "void controllerNodeIPsChanged(\n                                         Map<String, String> curControllerNodeIPs,\n                                         Map<String, String> addedControllerNodeIPs,\n                                         Map<String, String> removedControllerNodeIPs)", "full_signature": "@Override public void controllerNodeIPsChanged(\n                                         Map<String, String> curControllerNodeIPs,\n                                         Map<String, String> addedControllerNodeIPs,\n                                         Map<String, String> removedControllerNodeIPs)", "class_method_signature": "DeviceManagerImpl.controllerNodeIPsChanged(\n                                         Map<String, String> curControllerNodeIPs,\n                                         Map<String, String> addedControllerNodeIPs,\n                                         Map<String, String> removedControllerNodeIPs)", "testcase": false, "constructor": false}, {"identifier": "processPacketInMessage", "parameters": "(IOFSwitch sw, OFPacketIn pi,\n                                             FloodlightContext cntx)", "modifiers": "protected", "return": "Command", "signature": "Command processPacketInMessage(IOFSwitch sw, OFPacketIn pi,\n                                             FloodlightContext cntx)", "full_signature": "protected Command processPacketInMessage(IOFSwitch sw, OFPacketIn pi,\n                                             FloodlightContext cntx)", "class_method_signature": "DeviceManagerImpl.processPacketInMessage(IOFSwitch sw, OFPacketIn pi,\n                                             FloodlightContext cntx)", "testcase": false, "constructor": false}, {"identifier": "isValidAttachmentPoint", "parameters": "(long switchDPID,\n                                             int switchPort)", "modifiers": "public", "return": "boolean", "signature": "boolean isValidAttachmentPoint(long switchDPID,\n                                             int switchPort)", "full_signature": "public boolean isValidAttachmentPoint(long switchDPID,\n                                             int switchPort)", "class_method_signature": "DeviceManagerImpl.isValidAttachmentPoint(long switchDPID,\n                                             int switchPort)", "testcase": false, "constructor": false}, {"identifier": "getSrcNwAddr", "parameters": "(Ethernet eth, long dlAddr)", "modifiers": "private", "return": "int", "signature": "int getSrcNwAddr(Ethernet eth, long dlAddr)", "full_signature": "private int getSrcNwAddr(Ethernet eth, long dlAddr)", "class_method_signature": "DeviceManagerImpl.getSrcNwAddr(Ethernet eth, long dlAddr)", "testcase": false, "constructor": false}, {"identifier": "getSourceEntityFromPacket", "parameters": "(Ethernet eth,\n                                             long swdpid,\n                                             int port)", "modifiers": "protected", "return": "Entity", "signature": "Entity getSourceEntityFromPacket(Ethernet eth,\n                                             long swdpid,\n                                             int port)", "full_signature": "protected Entity getSourceEntityFromPacket(Ethernet eth,\n                                             long swdpid,\n                                             int port)", "class_method_signature": "DeviceManagerImpl.getSourceEntityFromPacket(Ethernet eth,\n                                             long swdpid,\n                                             int port)", "testcase": false, "constructor": false}, {"identifier": "getDestEntityFromPacket", "parameters": "(Ethernet eth)", "modifiers": "protected", "return": "Entity", "signature": "Entity getDestEntityFromPacket(Ethernet eth)", "full_signature": "protected Entity getDestEntityFromPacket(Ethernet eth)", "class_method_signature": "DeviceManagerImpl.getDestEntityFromPacket(Ethernet eth)", "testcase": false, "constructor": false}, {"identifier": "getEntityFromFlowMod", "parameters": "(OFMatchWithSwDpid ofmWithSwDpid,\n                boolean isSource)", "modifiers": "private", "return": "Entity", "signature": "Entity getEntityFromFlowMod(OFMatchWithSwDpid ofmWithSwDpid,\n                boolean isSource)", "full_signature": "private Entity getEntityFromFlowMod(OFMatchWithSwDpid ofmWithSwDpid,\n                boolean isSource)", "class_method_signature": "DeviceManagerImpl.getEntityFromFlowMod(OFMatchWithSwDpid ofmWithSwDpid,\n                boolean isSource)", "testcase": false, "constructor": false}, {"identifier": "findDeviceByEntity", "parameters": "(Entity entity)", "modifiers": "protected", "return": "Device", "signature": "Device findDeviceByEntity(Entity entity)", "full_signature": "protected Device findDeviceByEntity(Entity entity)", "class_method_signature": "DeviceManagerImpl.findDeviceByEntity(Entity entity)", "testcase": false, "constructor": false}, {"identifier": "findDestByEntity", "parameters": "(IDevice source,\n                                      Entity dstEntity)", "modifiers": "protected", "return": "Device", "signature": "Device findDestByEntity(IDevice source,\n                                      Entity dstEntity)", "full_signature": "protected Device findDestByEntity(IDevice source,\n                                      Entity dstEntity)", "class_method_signature": "DeviceManagerImpl.findDestByEntity(IDevice source,\n                                      Entity dstEntity)", "testcase": false, "constructor": false}, {"identifier": "learnDeviceByEntity", "parameters": "(Entity entity)", "modifiers": "protected", "return": "Device", "signature": "Device learnDeviceByEntity(Entity entity)", "full_signature": "protected Device learnDeviceByEntity(Entity entity)", "class_method_signature": "DeviceManagerImpl.learnDeviceByEntity(Entity entity)", "testcase": false, "constructor": false}, {"identifier": "isEntityAllowed", "parameters": "(Entity entity, IEntityClass entityClass)", "modifiers": "protected", "return": "boolean", "signature": "boolean isEntityAllowed(Entity entity, IEntityClass entityClass)", "full_signature": "protected boolean isEntityAllowed(Entity entity, IEntityClass entityClass)", "class_method_signature": "DeviceManagerImpl.isEntityAllowed(Entity entity, IEntityClass entityClass)", "testcase": false, "constructor": false}, {"identifier": "findChangedFields", "parameters": "(Device device,\n                                                     Entity newEntity)", "modifiers": "protected", "return": "EnumSet<DeviceField>", "signature": "EnumSet<DeviceField> findChangedFields(Device device,\n                                                     Entity newEntity)", "full_signature": "protected EnumSet<DeviceField> findChangedFields(Device device,\n                                                     Entity newEntity)", "class_method_signature": "DeviceManagerImpl.findChangedFields(Device device,\n                                                     Entity newEntity)", "testcase": false, "constructor": false}, {"identifier": "processUpdates", "parameters": "(Queue<DeviceUpdate> updates)", "modifiers": "protected", "return": "void", "signature": "void processUpdates(Queue<DeviceUpdate> updates)", "full_signature": "protected void processUpdates(Queue<DeviceUpdate> updates)", "class_method_signature": "DeviceManagerImpl.processUpdates(Queue<DeviceUpdate> updates)", "testcase": false, "constructor": false}, {"identifier": "allKeyFieldsPresent", "parameters": "(Entity e, EnumSet<DeviceField> keyFields)", "modifiers": "protected", "return": "boolean", "signature": "boolean allKeyFieldsPresent(Entity e, EnumSet<DeviceField> keyFields)", "full_signature": "protected boolean allKeyFieldsPresent(Entity e, EnumSet<DeviceField> keyFields)", "class_method_signature": "DeviceManagerImpl.allKeyFieldsPresent(Entity e, EnumSet<DeviceField> keyFields)", "testcase": false, "constructor": false}, {"identifier": "updateUpdates", "parameters": "(LinkedList<DeviceUpdate> list, DeviceUpdate update)", "modifiers": "private", "return": "LinkedList<DeviceUpdate>", "signature": "LinkedList<DeviceUpdate> updateUpdates(LinkedList<DeviceUpdate> list, DeviceUpdate update)", "full_signature": "private LinkedList<DeviceUpdate> updateUpdates(LinkedList<DeviceUpdate> list, DeviceUpdate update)", "class_method_signature": "DeviceManagerImpl.updateUpdates(LinkedList<DeviceUpdate> list, DeviceUpdate update)", "testcase": false, "constructor": false}, {"identifier": "getClassState", "parameters": "(IEntityClass clazz)", "modifiers": "private", "return": "ClassState", "signature": "ClassState getClassState(IEntityClass clazz)", "full_signature": "private ClassState getClassState(IEntityClass clazz)", "class_method_signature": "DeviceManagerImpl.getClassState(IEntityClass clazz)", "testcase": false, "constructor": false}, {"identifier": "updateIndices", "parameters": "(Device device, Long deviceKey)", "modifiers": "private", "return": "boolean", "signature": "boolean updateIndices(Device device, Long deviceKey)", "full_signature": "private boolean updateIndices(Device device, Long deviceKey)", "class_method_signature": "DeviceManagerImpl.updateIndices(Device device, Long deviceKey)", "testcase": false, "constructor": false}, {"identifier": "updateSecondaryIndices", "parameters": "(Entity entity,\n                                        IEntityClass entityClass,\n                                        Long deviceKey)", "modifiers": "private", "return": "void", "signature": "void updateSecondaryIndices(Entity entity,\n                                        IEntityClass entityClass,\n                                        Long deviceKey)", "full_signature": "private void updateSecondaryIndices(Entity entity,\n                                        IEntityClass entityClass,\n                                        Long deviceKey)", "class_method_signature": "DeviceManagerImpl.updateSecondaryIndices(Entity entity,\n                                        IEntityClass entityClass,\n                                        Long deviceKey)", "testcase": false, "constructor": false}, {"identifier": "entityClassChanged", "parameters": "(Set<String> entityClassNames)", "modifiers": "@Override public", "return": "void", "signature": "void entityClassChanged(Set<String> entityClassNames)", "full_signature": "@Override public void entityClassChanged(Set<String> entityClassNames)", "class_method_signature": "DeviceManagerImpl.entityClassChanged(Set<String> entityClassNames)", "testcase": false, "constructor": false}, {"identifier": "cleanupEntities", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void cleanupEntities()", "full_signature": "protected void cleanupEntities()", "class_method_signature": "DeviceManagerImpl.cleanupEntities()", "testcase": false, "constructor": false}, {"identifier": "removeEntity", "parameters": "(Entity removed,\n                              IEntityClass entityClass,\n                              Long deviceKey,\n                              Collection<Entity> others)", "modifiers": "protected", "return": "void", "signature": "void removeEntity(Entity removed,\n                              IEntityClass entityClass,\n                              Long deviceKey,\n                              Collection<Entity> others)", "full_signature": "protected void removeEntity(Entity removed,\n                              IEntityClass entityClass,\n                              Long deviceKey,\n                              Collection<Entity> others)", "class_method_signature": "DeviceManagerImpl.removeEntity(Entity removed,\n                              IEntityClass entityClass,\n                              Long deviceKey,\n                              Collection<Entity> others)", "testcase": false, "constructor": false}, {"identifier": "deleteDevice", "parameters": "(Device device)", "modifiers": "protected", "return": "void", "signature": "void deleteDevice(Device device)", "full_signature": "protected void deleteDevice(Device device)", "class_method_signature": "DeviceManagerImpl.deleteDevice(Device device)", "testcase": false, "constructor": false}, {"identifier": "getEntityKeys", "parameters": "(Long macAddress,\n                                               Short vlan,\n                                               Integer ipv4Address,\n                                               Long switchDPID,\n                                               Integer switchPort)", "modifiers": "private", "return": "EnumSet<DeviceField>", "signature": "EnumSet<DeviceField> getEntityKeys(Long macAddress,\n                                               Short vlan,\n                                               Integer ipv4Address,\n                                               Long switchDPID,\n                                               Integer switchPort)", "full_signature": "private EnumSet<DeviceField> getEntityKeys(Long macAddress,\n                                               Short vlan,\n                                               Integer ipv4Address,\n                                               Long switchDPID,\n                                               Integer switchPort)", "class_method_signature": "DeviceManagerImpl.getEntityKeys(Long macAddress,\n                                               Short vlan,\n                                               Integer ipv4Address,\n                                               Long switchDPID,\n                                               Integer switchPort)", "testcase": false, "constructor": false}, {"identifier": "queryClassByEntity", "parameters": "(IEntityClass clazz,\n                                                  EnumSet<DeviceField> keyFields,\n                                                  Entity entity)", "modifiers": "protected", "return": "Iterator<Device>", "signature": "Iterator<Device> queryClassByEntity(IEntityClass clazz,\n                                                  EnumSet<DeviceField> keyFields,\n                                                  Entity entity)", "full_signature": "protected Iterator<Device> queryClassByEntity(IEntityClass clazz,\n                                                  EnumSet<DeviceField> keyFields,\n                                                  Entity entity)", "class_method_signature": "DeviceManagerImpl.queryClassByEntity(IEntityClass clazz,\n                                                  EnumSet<DeviceField> keyFields,\n                                                  Entity entity)", "testcase": false, "constructor": false}, {"identifier": "allocateDevice", "parameters": "(Long deviceKey,\n                                    Entity entity,\n                                    IEntityClass entityClass)", "modifiers": "protected", "return": "Device", "signature": "Device allocateDevice(Long deviceKey,\n                                    Entity entity,\n                                    IEntityClass entityClass)", "full_signature": "protected Device allocateDevice(Long deviceKey,\n                                    Entity entity,\n                                    IEntityClass entityClass)", "class_method_signature": "DeviceManagerImpl.allocateDevice(Long deviceKey,\n                                    Entity entity,\n                                    IEntityClass entityClass)", "testcase": false, "constructor": false}, {"identifier": "allocateDevice", "parameters": "(Long deviceKey,\n                                    List<AttachmentPoint> aps,\n                                    List<AttachmentPoint> trueAPs,\n                                    Collection<Entity> entities,\n                                    IEntityClass entityClass)", "modifiers": "protected", "return": "Device", "signature": "Device allocateDevice(Long deviceKey,\n                                    List<AttachmentPoint> aps,\n                                    List<AttachmentPoint> trueAPs,\n                                    Collection<Entity> entities,\n                                    IEntityClass entityClass)", "full_signature": "protected Device allocateDevice(Long deviceKey,\n                                    List<AttachmentPoint> aps,\n                                    List<AttachmentPoint> trueAPs,\n                                    Collection<Entity> entities,\n                                    IEntityClass entityClass)", "class_method_signature": "DeviceManagerImpl.allocateDevice(Long deviceKey,\n                                    List<AttachmentPoint> aps,\n                                    List<AttachmentPoint> trueAPs,\n                                    Collection<Entity> entities,\n                                    IEntityClass entityClass)", "testcase": false, "constructor": false}, {"identifier": "allocateDevice", "parameters": "(Device device,\n                                    Entity entity)", "modifiers": "protected", "return": "Device", "signature": "Device allocateDevice(Device device,\n                                    Entity entity)", "full_signature": "protected Device allocateDevice(Device device,\n                                    Entity entity)", "class_method_signature": "DeviceManagerImpl.allocateDevice(Device device,\n                                    Entity entity)", "testcase": false, "constructor": false}, {"identifier": "allocateDevice", "parameters": "(Device device, Set <Entity> entities)", "modifiers": "protected", "return": "Device", "signature": "Device allocateDevice(Device device, Set <Entity> entities)", "full_signature": "protected Device allocateDevice(Device device, Set <Entity> entities)", "class_method_signature": "DeviceManagerImpl.allocateDevice(Device device, Set <Entity> entities)", "testcase": false, "constructor": false}, {"identifier": "addSuppressAPs", "parameters": "(long swId, short port)", "modifiers": "@Override public", "return": "void", "signature": "void addSuppressAPs(long swId, short port)", "full_signature": "@Override public void addSuppressAPs(long swId, short port)", "class_method_signature": "DeviceManagerImpl.addSuppressAPs(long swId, short port)", "testcase": false, "constructor": false}, {"identifier": "removeSuppressAPs", "parameters": "(long swId, short port)", "modifiers": "@Override public", "return": "void", "signature": "void removeSuppressAPs(long swId, short port)", "full_signature": "@Override public void removeSuppressAPs(long swId, short port)", "class_method_signature": "DeviceManagerImpl.removeSuppressAPs(long swId, short port)", "testcase": false, "constructor": false}, {"identifier": "topologyChanged", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void topologyChanged()", "full_signature": "@Override public void topologyChanged()", "class_method_signature": "DeviceManagerImpl.topologyChanged()", "testcase": false, "constructor": false}, {"identifier": "sendDeviceMovedNotification", "parameters": "(Device d)", "modifiers": "protected", "return": "void", "signature": "void sendDeviceMovedNotification(Device d)", "full_signature": "protected void sendDeviceMovedNotification(Device d)", "class_method_signature": "DeviceManagerImpl.sendDeviceMovedNotification(Device d)", "testcase": false, "constructor": false}, {"identifier": "reclassifyDevice", "parameters": "(Device device)", "modifiers": "protected", "return": "boolean", "signature": "boolean reclassifyDevice(Device device)", "full_signature": "protected boolean reclassifyDevice(Device device)", "class_method_signature": "DeviceManagerImpl.reclassifyDevice(Device device)", "testcase": false, "constructor": false}], "file": "network-level/fl-ho-nl/src/main/java/net/floodlightcontroller/devicemanager/internal/DeviceManagerImpl.java"}, "focal_method": {"identifier": "learnDeviceByEntity", "parameters": "(Entity entity)", "modifiers": "protected", "return": "Device", "body": "protected Device learnDeviceByEntity(Entity entity) {\n        ArrayList<Long> deleteQueue = null;\n        LinkedList<DeviceUpdate> deviceUpdates = null;\n        Device device = null;\n\n        // we may need to restart the learning process if we detect\n        // concurrent modification.  Note that we ensure that at least\n        // one thread should always succeed so we don't get into infinite\n        // starvation loops\n        while (true) {\n            deviceUpdates = null;\n\n            // Look up the fully-qualified entity to see if it already\n            // exists in the primary entity index.\n            Long deviceKey = primaryIndex.findByEntity(entity);\n            IEntityClass entityClass = null;\n\n            if (deviceKey == null) {\n                // If the entity does not exist in the primary entity index,\n                // use the entity classifier for find the classes for the\n                // entity. Look up the entity in the returned class'\n                // class entity index.\n                entityClass = entityClassifier.classifyEntity(entity);\n                if (entityClass == null) {\n                    // could not classify entity. No device\n                    return null;\n                }\n                ClassState classState = getClassState(entityClass);\n\n                if (classState.classIndex != null) {\n                    deviceKey =\n                            classState.classIndex.findByEntity(entity);\n                }\n            }\n            if (deviceKey != null) {\n                // If the primary or secondary index contains the entity\n                // use resulting device key to look up the device in the\n                // device map, and use the referenced Device below.\n                device = deviceMap.get(deviceKey);\n                if (device == null)\n                    throw new IllegalStateException(\"Corrupted device index\");\n            } else {\n                // If the secondary index does not contain the entity,\n                // create a new Device object containing the entity, and\n                // generate a new device ID. However, we first check if \n                // the entity is allowed (e.g., for spoofing protection)\n                if (!isEntityAllowed(entity, entityClass)) {\n                    logger.info(\"PacketIn is not allowed {} {}\", \n                                entityClass.getName(), entity);\n                    return null;\n                }\n                synchronized (deviceKeyLock) {\n                    deviceKey = Long.valueOf(deviceKeyCounter++);\n                }\n                device = allocateDevice(deviceKey, entity, entityClass);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"New device created: {} deviceKey={}, entity={}\",\n                                 new Object[]{device, deviceKey, entity});\n                }\n\n                // Add the new device to the primary map with a simple put\n                deviceMap.put(deviceKey, device);\n\n                // update indices\n                if (!updateIndices(device, deviceKey)) {\n                    if (deleteQueue == null)\n                        deleteQueue = new ArrayList<Long>();\n                    deleteQueue.add(deviceKey);\n                    continue;\n                }\n\n                updateSecondaryIndices(entity, entityClass, deviceKey);\n\n                // generate new device update\n                deviceUpdates =\n                        updateUpdates(deviceUpdates,\n                                      new DeviceUpdate(device, ADD, null));\n\n                break;\n            }\n\n            if (!isEntityAllowed(entity, device.getEntityClass())) {\n                logger.info(\"PacketIn is not allowed {} {}\", \n                            device.getEntityClass().getName(), entity);\n                return null;\n            }\n            int entityindex = -1;\n            if ((entityindex = device.entityIndex(entity)) >= 0) {\n                // update timestamp on the found entity\n                Date lastSeen = entity.getLastSeenTimestamp();\n                if (lastSeen == null) lastSeen = new Date();\n                device.entities[entityindex].setLastSeenTimestamp(lastSeen);\n                if (device.entities[entityindex].getSwitchDPID() != null &&\n                        device.entities[entityindex].getSwitchPort() != null) {\n                    long sw = device.entities[entityindex].getSwitchDPID();\n                    short port = device.entities[entityindex].getSwitchPort().shortValue();\n\n                    boolean moved =\n                            device.updateAttachmentPoint(sw,\n                                                         port,\n                                                         lastSeen.getTime());\n\n                    if (moved) {\n                        sendDeviceMovedNotification(device);\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"Device moved: attachment points {},\" +\n                                    \"entities {}\", device.attachmentPoints,\n                                    device.entities);\n                        }\n                    } else {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"Device attachment point NOT updated: \" +\n                                         \"attachment points {},\" +\n                                         \"entities {}\", device.attachmentPoints,\n                                         device.entities);\n                        }\n                    }\n                }\n                break;\n            } else {\n                boolean moved = false;\n                Device newDevice = allocateDevice(device, entity);\n                if (entity.getSwitchDPID() != null && entity.getSwitchPort() != null) {\n                    moved = newDevice.updateAttachmentPoint(entity.getSwitchDPID(),\n                                                            entity.getSwitchPort().shortValue(),\n                                                            entity.getLastSeenTimestamp().getTime());\n                }\n\n                // generate updates\n                EnumSet<DeviceField> changedFields =\n                        findChangedFields(device, entity);\n                if (changedFields.size() > 0)\n                    deviceUpdates =\n                    updateUpdates(deviceUpdates,\n                                  new DeviceUpdate(newDevice, CHANGE,\n                                                   changedFields));\n\n                // update the device map with a replace call\n                boolean res = deviceMap.replace(deviceKey, device, newDevice);\n                // If replace returns false, restart the process from the\n                // beginning (this implies another thread concurrently\n                // modified this Device).\n                if (!res)\n                    continue;\n\n                device = newDevice;\n\n                // update indices\n                if (!updateIndices(device, deviceKey)) {\n                    continue;\n                }\n                updateSecondaryIndices(entity,\n                                       device.getEntityClass(),\n                                       deviceKey);\n\n                if (moved) {\n                    sendDeviceMovedNotification(device);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Device moved: attachment points {},\" +\n                                \"entities {}\", device.attachmentPoints,\n                                device.entities);\n                    }\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Device attachment point updated: \" +\n                                     \"attachment points {},\" +\n                                     \"entities {}\", device.attachmentPoints,\n                                     device.entities);\n                    }\n                }\n                break;\n            }\n        }\n\n        if (deleteQueue != null) {\n            for (Long l : deleteQueue) {\n                Device dev = deviceMap.get(l);\n                this.deleteDevice(dev);\n                \n\n                // generate new device update\n                deviceUpdates =\n                        updateUpdates(deviceUpdates,\n                                      new DeviceUpdate(dev, DELETE, null));\n            }\n        }\n\n        processUpdates(deviceUpdates);\n\n        return device;\n    }", "signature": "Device learnDeviceByEntity(Entity entity)", "full_signature": "protected Device learnDeviceByEntity(Entity entity)", "class_method_signature": "DeviceManagerImpl.learnDeviceByEntity(Entity entity)", "testcase": false, "constructor": false, "invocations": ["findByEntity", "classifyEntity", "getClassState", "findByEntity", "get", "isEntityAllowed", "info", "getName", "valueOf", "allocateDevice", "isDebugEnabled", "debug", "put", "updateIndices", "add", "updateSecondaryIndices", "updateUpdates", "isEntityAllowed", "getEntityClass", "info", "getName", "getEntityClass", "entityIndex", "getLastSeenTimestamp", "setLastSeenTimestamp", "getSwitchDPID", "getSwitchPort", "getSwitchDPID", "shortValue", "getSwitchPort", "updateAttachmentPoint", "getTime", "sendDeviceMovedNotification", "isTraceEnabled", "trace", "isTraceEnabled", "trace", "allocateDevice", "getSwitchDPID", "getSwitchPort", "updateAttachmentPoint", "getSwitchDPID", "shortValue", "getSwitchPort", "getTime", "getLastSeenTimestamp", "findChangedFields", "size", "updateUpdates", "replace", "updateIndices", "updateSecondaryIndices", "getEntityClass", "sendDeviceMovedNotification", "isDebugEnabled", "debug", "isDebugEnabled", "debug", "get", "deleteDevice", "updateUpdates", "processUpdates"]}, "repository": {"repo_id": 10459637, "url": "https://github.com/rizard/geni-openflow-vertical-handover", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 7, "size": 33971, "license": "licensed"}}