{"test_class": {"identifier": "BitBufferHelperTest", "superclass": "", "interfaces": "", "fields": [], "file": "packethandler/implementation/src/test/java/org/opendaylight/l2switch/packethandler/decoders/utils/BitBufferHelperTest.java"}, "test_case": {"identifier": "testToByteArray", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testToByteArray() {\n        short sh = Short.MAX_VALUE;\n        byte[] dataShort = new byte[Byte.SIZE / 8];\n        dataShort = BitBufferHelper.toByteArray(sh);\n        Assert.assertTrue(dataShort[0] == 127);\n        Assert.assertTrue(dataShort[1] == -1);\n\n        short sh2 = Short.MIN_VALUE;\n        byte[] dataShort2 = new byte[Byte.SIZE / 8];\n        dataShort2 = BitBufferHelper.toByteArray(sh2);\n        Assert.assertTrue(dataShort2[0] == -128);\n        Assert.assertTrue(dataShort2[1] == 0);\n\n        short sh3 = 16384;\n        byte[] dataShort3 = new byte[Byte.SIZE / 8];\n        dataShort3 = BitBufferHelper.toByteArray(sh3);\n        Assert.assertTrue(dataShort3[0] == 64);\n        Assert.assertTrue(dataShort3[1] == 0);\n\n        short sh4 = 146; // TCP headerlenflags - startoffset = 103\n        byte[] dataShort4 = new byte[Byte.SIZE / 8];\n        dataShort4 = BitBufferHelper.toByteArray(sh4);\n        Assert.assertTrue(dataShort4[0] == 0);\n        Assert.assertTrue(dataShort4[1] == -110);\n\n        short sh5 = 5000; // IPv4 Offset - startOffset = 51 (to 63)\n        byte[] dataShort5 = new byte[Byte.SIZE / 8];\n        dataShort5 = BitBufferHelper.toByteArray(sh5);\n        Assert.assertTrue(dataShort5[0] == 19);\n        Assert.assertTrue(dataShort5[1] == -120);\n\n        short sh6 = 5312; // numEndRestBits < numBitstoShiftBy\n        byte[] dataShort6 = new byte[Byte.SIZE / 8];\n        dataShort6 = BitBufferHelper.toByteArray(sh6);\n        Assert.assertTrue(dataShort6[0] == 20);\n        Assert.assertTrue(dataShort6[1] == -64);\n\n        int int1 = Integer.MAX_VALUE;\n        byte[] dataInt1 = new byte[Integer.SIZE / 8];\n        dataInt1 = BitBufferHelper.toByteArray(int1);\n        Assert.assertTrue(dataInt1[0] == 127);\n        Assert.assertTrue(dataInt1[1] == -1);\n        Assert.assertTrue(dataInt1[2] == -1);\n        Assert.assertTrue(dataInt1[3] == -1);\n\n        int int2 = Integer.MIN_VALUE;\n        byte[] dataInt2 = new byte[Integer.SIZE / 8];\n        dataInt2 = BitBufferHelper.toByteArray(int2);\n        Assert.assertTrue(dataInt2[0] == -128);\n        Assert.assertTrue(dataInt2[1] == 0);\n        Assert.assertTrue(dataInt2[2] == 0);\n        Assert.assertTrue(dataInt2[3] == 0);\n\n        int int3 = 1077952576;\n        byte[] dataInt3 = new byte[Integer.SIZE / 8];\n        dataInt3 = BitBufferHelper.toByteArray(int3);\n        Assert.assertTrue(dataInt3[0] == 64);\n        Assert.assertTrue(dataInt3[1] == 64);\n        Assert.assertTrue(dataInt3[2] == 64);\n        Assert.assertTrue(dataInt3[3] == 64);\n\n        long long1 = Long.MAX_VALUE;\n        byte[] dataLong1 = new byte[Long.SIZE / 8];\n        dataLong1 = BitBufferHelper.toByteArray(long1);\n        Assert.assertTrue(dataLong1[0] == 127);\n        Assert.assertTrue(dataLong1[1] == -1);\n        Assert.assertTrue(dataLong1[2] == -1);\n        Assert.assertTrue(dataLong1[3] == -1);\n        Assert.assertTrue(dataLong1[4] == -1);\n        Assert.assertTrue(dataLong1[5] == -1);\n        Assert.assertTrue(dataLong1[6] == -1);\n        Assert.assertTrue(dataLong1[7] == -1);\n\n        long long2 = Long.MIN_VALUE;\n        byte[] dataLong2 = new byte[Long.SIZE / 8];\n        dataLong2 = BitBufferHelper.toByteArray(long2);\n        Assert.assertTrue(dataLong2[0] == -128);\n        Assert.assertTrue(dataLong2[1] == 0);\n        Assert.assertTrue(dataLong2[2] == 0);\n        Assert.assertTrue(dataLong2[3] == 0);\n        Assert.assertTrue(dataLong2[4] == 0);\n        Assert.assertTrue(dataLong2[5] == 0);\n        Assert.assertTrue(dataLong2[6] == 0);\n        Assert.assertTrue(dataLong2[7] == 0);\n\n        byte byte1 = Byte.MAX_VALUE;\n        byte[] dataByte1 = new byte[Byte.SIZE / 8];\n        dataByte1 = BitBufferHelper.toByteArray(byte1);\n        Assert.assertTrue(dataByte1[0] == 127);\n\n        byte byte2 = Byte.MIN_VALUE;\n        byte[] dataByte2 = new byte[Byte.SIZE / 8];\n        dataByte2 = BitBufferHelper.toByteArray(byte2);\n        Assert.assertTrue(dataByte2[0] == -128);\n\n        byte byte3 = 64;\n        byte[] dataByte3 = new byte[Byte.SIZE / 8];\n        dataByte3 = BitBufferHelper.toByteArray(byte3);\n        Assert.assertTrue(dataByte3[0] == 64);\n\n        byte byte4 = 32;\n        byte[] dataByte4 = new byte[Byte.SIZE / 8];\n        dataByte4 = BitBufferHelper.toByteArray(byte4);\n        Assert.assertTrue(dataByte4[0] == 32);\n\n    }", "signature": "void testToByteArray()", "full_signature": "@Test public void testToByteArray()", "class_method_signature": "BitBufferHelperTest.testToByteArray()", "testcase": true, "constructor": false, "invocations": ["toByteArray", "assertTrue", "assertTrue", "toByteArray", "assertTrue", "assertTrue", "toByteArray", "assertTrue", "assertTrue", "toByteArray", "assertTrue", "assertTrue", "toByteArray", "assertTrue", "assertTrue", "toByteArray", "assertTrue", "assertTrue", "toByteArray", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "toByteArray", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "toByteArray", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "toByteArray", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "toByteArray", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "toByteArray", "assertTrue", "toByteArray", "assertTrue", "toByteArray", "assertTrue", "toByteArray", "assertTrue"]}, "focal_class": {"identifier": "BitBufferHelper", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(BitBufferHelper.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(BitBufferHelper.class)", "var_name": "LOG"}, {"original_string": "public static final long BYTE_MASK = 0xFF;", "modifier": "public static final", "type": "long", "declarator": "BYTE_MASK = 0xFF", "var_name": "BYTE_MASK"}], "methods": [{"identifier": "BitBufferHelper", "parameters": "()", "modifiers": "private", "return": "", "signature": " BitBufferHelper()", "full_signature": "private  BitBufferHelper()", "class_method_signature": "BitBufferHelper.BitBufferHelper()", "testcase": false, "constructor": true}, {"identifier": "getByte", "parameters": "(byte[] data)", "modifiers": "public static", "return": "byte", "signature": "byte getByte(byte[] data)", "full_signature": "public static byte getByte(byte[] data)", "class_method_signature": "BitBufferHelper.getByte(byte[] data)", "testcase": false, "constructor": false}, {"identifier": "getShort", "parameters": "(byte[] data, int numBits)", "modifiers": "public static", "return": "short", "signature": "short getShort(byte[] data, int numBits)", "full_signature": "public static short getShort(byte[] data, int numBits)", "class_method_signature": "BitBufferHelper.getShort(byte[] data, int numBits)", "testcase": false, "constructor": false}, {"identifier": "getShort", "parameters": "(byte[] data)", "modifiers": "public static", "return": "short", "signature": "short getShort(byte[] data)", "full_signature": "public static short getShort(byte[] data)", "class_method_signature": "BitBufferHelper.getShort(byte[] data)", "testcase": false, "constructor": false}, {"identifier": "getInt", "parameters": "(byte[] data, int numBits)", "modifiers": "public static", "return": "int", "signature": "int getInt(byte[] data, int numBits)", "full_signature": "public static int getInt(byte[] data, int numBits)", "class_method_signature": "BitBufferHelper.getInt(byte[] data, int numBits)", "testcase": false, "constructor": false}, {"identifier": "getInt", "parameters": "(byte[] data)", "modifiers": "public static", "return": "int", "signature": "int getInt(byte[] data)", "full_signature": "public static int getInt(byte[] data)", "class_method_signature": "BitBufferHelper.getInt(byte[] data)", "testcase": false, "constructor": false}, {"identifier": "getLong", "parameters": "(byte[] data, int numBits)", "modifiers": "public static", "return": "long", "signature": "long getLong(byte[] data, int numBits)", "full_signature": "public static long getLong(byte[] data, int numBits)", "class_method_signature": "BitBufferHelper.getLong(byte[] data, int numBits)", "testcase": false, "constructor": false}, {"identifier": "getLong", "parameters": "(byte[] data)", "modifiers": "public static", "return": "long", "signature": "long getLong(byte[] data)", "full_signature": "public static long getLong(byte[] data)", "class_method_signature": "BitBufferHelper.getLong(byte[] data)", "testcase": false, "constructor": false}, {"identifier": "getBits", "parameters": "(byte[] data, int startOffset, int numBits)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] getBits(byte[] data, int startOffset, int numBits)", "full_signature": "public static byte[] getBits(byte[] data, int startOffset, int numBits)", "class_method_signature": "BitBufferHelper.getBits(byte[] data, int startOffset, int numBits)", "testcase": false, "constructor": false}, {"identifier": "setByte", "parameters": "(byte[] data, byte input, int startOffset, int numBits)", "modifiers": "public static", "return": "void", "signature": "void setByte(byte[] data, byte input, int startOffset, int numBits)", "full_signature": "public static void setByte(byte[] data, byte input, int startOffset, int numBits)", "class_method_signature": "BitBufferHelper.setByte(byte[] data, byte input, int startOffset, int numBits)", "testcase": false, "constructor": false}, {"identifier": "setBytes", "parameters": "(byte[] data, byte[] input, int startOffset, int numBits)", "modifiers": "public static", "return": "void", "signature": "void setBytes(byte[] data, byte[] input, int startOffset, int numBits)", "full_signature": "public static void setBytes(byte[] data, byte[] input, int startOffset, int numBits)", "class_method_signature": "BitBufferHelper.setBytes(byte[] data, byte[] input, int startOffset, int numBits)", "testcase": false, "constructor": false}, {"identifier": "getMSBMask", "parameters": "(int numBits)", "modifiers": "public static", "return": "int", "signature": "int getMSBMask(int numBits)", "full_signature": "public static int getMSBMask(int numBits)", "class_method_signature": "BitBufferHelper.getMSBMask(int numBits)", "testcase": false, "constructor": false}, {"identifier": "getLSBMask", "parameters": "(int numBits)", "modifiers": "public static", "return": "int", "signature": "int getLSBMask(int numBits)", "full_signature": "public static int getLSBMask(int numBits)", "class_method_signature": "BitBufferHelper.getLSBMask(int numBits)", "testcase": false, "constructor": false}, {"identifier": "toNumber", "parameters": "(byte[] array)", "modifiers": "public static", "return": "long", "signature": "long toNumber(byte[] array)", "full_signature": "public static long toNumber(byte[] array)", "class_method_signature": "BitBufferHelper.toNumber(byte[] array)", "testcase": false, "constructor": false}, {"identifier": "toNumber", "parameters": "(@Nonnull byte[] array, int numBits)", "modifiers": "public static", "return": "long", "signature": "long toNumber(@Nonnull byte[] array, int numBits)", "full_signature": "public static long toNumber(@Nonnull byte[] array, int numBits)", "class_method_signature": "BitBufferHelper.toNumber(@Nonnull byte[] array, int numBits)", "testcase": false, "constructor": false}, {"identifier": "toByteArray", "parameters": "(Number input)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] toByteArray(Number input)", "full_signature": "public static byte[] toByteArray(Number input)", "class_method_signature": "BitBufferHelper.toByteArray(Number input)", "testcase": false, "constructor": false}, {"identifier": "toByteArray", "parameters": "(Number input, int numBits)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] toByteArray(Number input, int numBits)", "full_signature": "public static byte[] toByteArray(Number input, int numBits)", "class_method_signature": "BitBufferHelper.toByteArray(Number input, int numBits)", "testcase": false, "constructor": false}, {"identifier": "shiftBitsToMSB", "parameters": "(byte[] inputBytes, int numBits)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] shiftBitsToMSB(byte[] inputBytes, int numBits)", "full_signature": "public static byte[] shiftBitsToMSB(byte[] inputBytes, int numBits)", "class_method_signature": "BitBufferHelper.shiftBitsToMSB(byte[] inputBytes, int numBits)", "testcase": false, "constructor": false}, {"identifier": "shiftBitsToLSB", "parameters": "(byte[] inputBytes, int numBits)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] shiftBitsToLSB(byte[] inputBytes, int numBits)", "full_signature": "public static byte[] shiftBitsToLSB(byte[] inputBytes, int numBits)", "class_method_signature": "BitBufferHelper.shiftBitsToLSB(byte[] inputBytes, int numBits)", "testcase": false, "constructor": false}, {"identifier": "insertBits", "parameters": "(byte[] data, byte[] inputdataLSB, int startOffset, int numBits)", "modifiers": "public static", "return": "void", "signature": "void insertBits(byte[] data, byte[] inputdataLSB, int startOffset, int numBits)", "full_signature": "public static void insertBits(byte[] data, byte[] inputdataLSB, int startOffset, int numBits)", "class_method_signature": "BitBufferHelper.insertBits(byte[] data, byte[] inputdataLSB, int startOffset, int numBits)", "testcase": false, "constructor": false}, {"identifier": "checkExceptions", "parameters": "(byte[] data, int startOffset, int numBits)", "modifiers": "public static", "return": "void", "signature": "void checkExceptions(byte[] data, int startOffset, int numBits)", "full_signature": "public static void checkExceptions(byte[] data, int startOffset, int numBits)", "class_method_signature": "BitBufferHelper.checkExceptions(byte[] data, int startOffset, int numBits)", "testcase": false, "constructor": false}], "file": "packethandler/implementation/src/main/java/org/opendaylight/l2switch/packethandler/decoders/utils/BitBufferHelper.java"}, "focal_method": {"identifier": "toByteArray", "parameters": "(Number input)", "modifiers": "public static", "return": "byte[]", "body": "public static byte[] toByteArray(Number input) {\n        Class<? extends Number> dataType = input.getClass();\n        short size = 0;\n        long longValue = input.longValue();\n\n        if (dataType == Byte.class || dataType == byte.class) {\n            size = Byte.SIZE;\n        } else if (dataType == Short.class || dataType == short.class) {\n            size = Short.SIZE;\n        } else if (dataType == Integer.class || dataType == int.class) {\n            size = Integer.SIZE;\n        } else if (dataType == Long.class || dataType == long.class) {\n            size = Long.SIZE;\n        } else {\n            throw new IllegalArgumentException(\"Parameter must one of the following: Short/Int/Long\\n\");\n        }\n\n        int length = size / NetUtils.NUM_BITS_IN_A_BYTE;\n        byte[] bytes = new byte[length];\n\n        // Getting the bytes from input value\n        for (int i = 0; i < length; i++) {\n            bytes[i] = (byte) (longValue >> NetUtils.NUM_BITS_IN_A_BYTE * (length - i - 1) & BYTE_MASK);\n        }\n        return bytes;\n    }", "signature": "byte[] toByteArray(Number input)", "full_signature": "public static byte[] toByteArray(Number input)", "class_method_signature": "BitBufferHelper.toByteArray(Number input)", "testcase": false, "constructor": false, "invocations": ["getClass", "longValue"]}, "repository": {"repo_id": 20701467, "url": "https://github.com/opendaylight/l2switch", "language": "Java", "is_fork": false, "fork_count": 30, "stargazer_count": 25, "size": 4178, "license": "licensed"}}