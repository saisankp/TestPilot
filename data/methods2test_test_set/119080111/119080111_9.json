{"test_class": {"identifier": "NonDominatedFrontsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "protected static final Objective firstObj = new Objective(\"first\", Sign.MAX);", "modifier": "protected static final", "type": "Objective", "declarator": "firstObj = new Objective(\"first\", Sign.MAX)", "var_name": "firstObj"}, {"original_string": "protected static final Objective secondObj = new Objective(\"second\", Sign.MAX);", "modifier": "protected static final", "type": "Objective", "declarator": "secondObj = new Objective(\"second\", Sign.MAX)", "var_name": "secondObj"}, {"original_string": "protected static Individual first = mock(Individual.class);", "modifier": "protected static", "type": "Individual", "declarator": "first = mock(Individual.class)", "var_name": "first"}, {"original_string": "protected static Individual second = mock(Individual.class);", "modifier": "protected static", "type": "Individual", "declarator": "second = mock(Individual.class)", "var_name": "second"}, {"original_string": "protected static Individual third = mock(Individual.class);", "modifier": "protected static", "type": "Individual", "declarator": "third = mock(Individual.class)", "var_name": "third"}, {"original_string": "protected static Individual fourth = mock(Individual.class);", "modifier": "protected static", "type": "Individual", "declarator": "fourth = mock(Individual.class)", "var_name": "fourth"}, {"original_string": "protected static Individual fifth = mock(Individual.class);", "modifier": "protected static", "type": "Individual", "declarator": "fifth = mock(Individual.class)", "var_name": "fifth"}, {"original_string": "protected static Individual infeasible = mock(Individual.class);", "modifier": "protected static", "type": "Individual", "declarator": "infeasible = mock(Individual.class)", "var_name": "infeasible"}], "file": "opt4j-optimizers/src/test/java/org/opt4j/optimizers/ea/NonDominatedFrontsTest.java"}, "test_case": {"identifier": "testGenerateFronts", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testGenerateFronts() {\n\t\tNonDominatedFronts fronts = new NonDominatedFronts(getIndividualSet());\n\t\tassertEquals(4, fronts.getFrontNumber());\n\n\t\tassertEquals(3, fronts.getFrontAtIndex(0).size());\n\t\tassertTrue(fronts.getFrontAtIndex(0).contains(first));\n\t\tassertTrue(fronts.getFrontAtIndex(0).contains(second));\n\t\tassertTrue(fronts.getFrontAtIndex(0).contains(third));\n\n\t\tassertEquals(1, fronts.getFrontAtIndex(1).size());\n\t\tassertTrue(fronts.getFrontAtIndex(1).contains(fourth));\n\n\t\tassertEquals(1, fronts.getFrontAtIndex(2).size());\n\t\tassertTrue(fronts.getFrontAtIndex(2).contains(fifth));\n\t}", "signature": "void testGenerateFronts()", "full_signature": "@Test public void testGenerateFronts()", "class_method_signature": "NonDominatedFrontsTest.testGenerateFronts()", "testcase": true, "constructor": false, "invocations": ["getIndividualSet", "assertEquals", "getFrontNumber", "assertEquals", "size", "getFrontAtIndex", "assertTrue", "contains", "getFrontAtIndex", "assertTrue", "contains", "getFrontAtIndex", "assertTrue", "contains", "getFrontAtIndex", "assertEquals", "size", "getFrontAtIndex", "assertTrue", "contains", "getFrontAtIndex", "assertEquals", "size", "getFrontAtIndex", "assertTrue", "contains", "getFrontAtIndex"]}, "focal_class": {"identifier": "NonDominatedFronts", "superclass": "", "interfaces": "", "fields": [{"original_string": "protected final List<Collection<Individual>> fronts;", "modifier": "protected final", "type": "List<Collection<Individual>>", "declarator": "fronts", "var_name": "fronts"}], "methods": [{"identifier": "NonDominatedFronts", "parameters": "(Collection<Individual> individuals)", "modifiers": "public", "return": "", "signature": " NonDominatedFronts(Collection<Individual> individuals)", "full_signature": "public  NonDominatedFronts(Collection<Individual> individuals)", "class_method_signature": "NonDominatedFronts.NonDominatedFronts(Collection<Individual> individuals)", "testcase": false, "constructor": true}, {"identifier": "generateFronts", "parameters": "(Collection<Individual> individuals)", "modifiers": "protected", "return": "List<Collection<Individual>>", "signature": "List<Collection<Individual>> generateFronts(Collection<Individual> individuals)", "full_signature": "protected List<Collection<Individual>> generateFronts(Collection<Individual> individuals)", "class_method_signature": "NonDominatedFronts.generateFronts(Collection<Individual> individuals)", "testcase": false, "constructor": false}, {"identifier": "getFrontAtIndex", "parameters": "(int index)", "modifiers": "public", "return": "Collection<Individual>", "signature": "Collection<Individual> getFrontAtIndex(int index)", "full_signature": "public Collection<Individual> getFrontAtIndex(int index)", "class_method_signature": "NonDominatedFronts.getFrontAtIndex(int index)", "testcase": false, "constructor": false}, {"identifier": "getFrontNumber", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getFrontNumber()", "full_signature": "public int getFrontNumber()", "class_method_signature": "NonDominatedFronts.getFrontNumber()", "testcase": false, "constructor": false}, {"identifier": "getNextFront", "parameters": "(List<Individual> currentFront,\n\t\t\tMap<Individual, List<Individual>> dominatedIndividualsMap, int[] dominatingIndividualNumber,\n\t\t\tMap<Individual, Integer> individual2IndexMap)", "modifiers": "protected", "return": "List<Individual>", "signature": "List<Individual> getNextFront(List<Individual> currentFront,\n\t\t\tMap<Individual, List<Individual>> dominatedIndividualsMap, int[] dominatingIndividualNumber,\n\t\t\tMap<Individual, Integer> individual2IndexMap)", "full_signature": "protected List<Individual> getNextFront(List<Individual> currentFront,\n\t\t\tMap<Individual, List<Individual>> dominatedIndividualsMap, int[] dominatingIndividualNumber,\n\t\t\tMap<Individual, Integer> individual2IndexMap)", "class_method_signature": "NonDominatedFronts.getNextFront(List<Individual> currentFront,\n\t\t\tMap<Individual, List<Individual>> dominatedIndividualsMap, int[] dominatingIndividualNumber,\n\t\t\tMap<Individual, Integer> individual2IndexMap)", "testcase": false, "constructor": false}, {"identifier": "determineDomination", "parameters": "(Collection<Individual> individuals,\n\t\t\tMap<Individual, List<Individual>> dominatedIndividualsMap, int[] dominatingIndividualNumber,\n\t\t\tMap<Individual, Integer> individual2IndexMap)", "modifiers": "protected", "return": "void", "signature": "void determineDomination(Collection<Individual> individuals,\n\t\t\tMap<Individual, List<Individual>> dominatedIndividualsMap, int[] dominatingIndividualNumber,\n\t\t\tMap<Individual, Integer> individual2IndexMap)", "full_signature": "protected void determineDomination(Collection<Individual> individuals,\n\t\t\tMap<Individual, List<Individual>> dominatedIndividualsMap, int[] dominatingIndividualNumber,\n\t\t\tMap<Individual, Integer> individual2IndexMap)", "class_method_signature": "NonDominatedFronts.determineDomination(Collection<Individual> individuals,\n\t\t\tMap<Individual, List<Individual>> dominatedIndividualsMap, int[] dominatingIndividualNumber,\n\t\t\tMap<Individual, Integer> individual2IndexMap)", "testcase": false, "constructor": false}], "file": "opt4j-optimizers/src/main/java/org/opt4j/optimizers/ea/NonDominatedFronts.java"}, "focal_method": {"identifier": "generateFronts", "parameters": "(Collection<Individual> individuals)", "modifiers": "protected", "return": "List<Collection<Individual>>", "body": "protected List<Collection<Individual>> generateFronts(Collection<Individual> individuals) {\n\t\tList<Collection<Individual>> fronts = new ArrayList<>();\n\t\t// Assigns an id to each individual that corresponds to its index in an\n\t\t// array.\n\t\tMap<Individual, Integer> indexMap = new HashMap<>();\n\t\tint index = 0;\n\t\tfor (Individual individual : individuals) {\n\t\t\tindexMap.put(individual, index++);\n\t\t}\n\t\t// Initializes a map where an individual is assigned to the individuals\n\t\t// that it dominates.\n\t\tMap<Individual, List<Individual>> dominatedIndividualsMap = new HashMap<>();\n\t\t// Creates an array where for each individual, the number of individuals\n\t\t// that dominate it is stored.\n\t\tint[] dominatingIndividualNumber = new int[individuals.size()];\n\t\tfor (Individual e : individuals) {\n\t\t\tdominatedIndividualsMap.put(e, new ArrayList<>());\n\t\t\tdominatingIndividualNumber[indexMap.get(e)] = 0;\n\t\t}\n\t\tdetermineDomination(individuals, dominatedIndividualsMap, dominatingIndividualNumber, indexMap);\n\t\t// The first front consists of individuals that are dominated by zero\n\t\t// other individuals.\n\t\tList<Individual> f1 = new ArrayList<>();\n\t\tfor (Individual i : individuals) {\n\t\t\tif (dominatingIndividualNumber[indexMap.get(i)] == 0) {\n\t\t\t\tf1.add(i);\n\t\t\t}\n\t\t}\n\t\tfronts.add(f1);\n\t\tList<Individual> currentFront = f1;\n\t\t// Creates the subsequent fronts. Front f_i is made up by individuals\n\t\t// that\n\t\t// are not dominated if all individuals from fronts f_j with j < i are\n\t\t// removed.\n\t\twhile (!currentFront.isEmpty()) {\n\t\t\tList<Individual> nextFront = getNextFront(currentFront, dominatedIndividualsMap, dominatingIndividualNumber,\n\t\t\t\t\tindexMap);\n\t\t\tif (!nextFront.isEmpty()) {\n\t\t\t\tfronts.add(nextFront);\n\t\t\t}\n\t\t\tcurrentFront = nextFront;\n\t\t}\n\t\treturn fronts;\n\t}", "signature": "List<Collection<Individual>> generateFronts(Collection<Individual> individuals)", "full_signature": "protected List<Collection<Individual>> generateFronts(Collection<Individual> individuals)", "class_method_signature": "NonDominatedFronts.generateFronts(Collection<Individual> individuals)", "testcase": false, "constructor": false, "invocations": ["put", "size", "put", "get", "determineDomination", "get", "add", "add", "isEmpty", "getNextFront", "isEmpty", "add"]}, "repository": {"repo_id": 119080111, "url": "https://github.com/felixreimann/opt4j", "language": "Java", "is_fork": false, "fork_count": 12, "stargazer_count": 11, "size": 8771, "license": "licensed"}}