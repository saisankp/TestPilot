{"test_class": {"identifier": "SerializedSubscriberTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "Subscriber<String> observer;", "modifier": "", "type": "Subscriber<String>", "declarator": "observer", "var_name": "observer"}], "file": "rxjava/src/test/java/io/reactivex/subscribers/SerializedSubscriberTest.java"}, "test_case": {"identifier": "runOutOfOrderConcurrencyTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void runOutOfOrderConcurrencyTest() {\n        ExecutorService tp = Executors.newFixedThreadPool(20);\n        try {\n            TestConcurrencySubscriber tw = new TestConcurrencySubscriber();\n            // we need Synchronized + SafeSubscriber to handle synchronization plus life-cycle\n            Subscriber<String> w = serializedSubscriber(new SafeSubscriber<String>(tw));\n\n            Future<?> f1 = tp.submit(new OnNextThread(w, 12000));\n            Future<?> f2 = tp.submit(new OnNextThread(w, 5000));\n            Future<?> f3 = tp.submit(new OnNextThread(w, 75000));\n            Future<?> f4 = tp.submit(new OnNextThread(w, 13500));\n            Future<?> f5 = tp.submit(new OnNextThread(w, 22000));\n            Future<?> f6 = tp.submit(new OnNextThread(w, 15000));\n            Future<?> f7 = tp.submit(new OnNextThread(w, 7500));\n            Future<?> f8 = tp.submit(new OnNextThread(w, 23500));\n\n            Future<?> f10 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f1, f2, f3, f4));\n            try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {\n                // ignore\n            }\n            Future<?> f11 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));\n            Future<?> f12 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));\n            Future<?> f13 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));\n            Future<?> f14 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));\n            // // the next 4 onError events should wait on same as f10\n            Future<?> f15 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));\n            Future<?> f16 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));\n            Future<?> f17 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));\n            Future<?> f18 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));\n\n            waitOnThreads(f1, f2, f3, f4, f5, f6, f7, f8, f10, f11, f12, f13, f14, f15, f16, f17, f18);\n            @SuppressWarnings(\"unused\")\n            int numNextEvents = tw.assertEvents(null); // no check of type since we don't want to test barging results here, just interleaving behavior\n            //            System.out.println(\"Number of events executed: \" + numNextEvents);\n        } catch (Throwable e) {\n            fail(\"Concurrency test failed: \" + e.getMessage());\n            e.printStackTrace();\n        } finally {\n            tp.shutdown();\n            try {\n                tp.awaitTermination(5000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }", "signature": "void runOutOfOrderConcurrencyTest()", "full_signature": "@Test public void runOutOfOrderConcurrencyTest()", "class_method_signature": "SerializedSubscriberTest.runOutOfOrderConcurrencyTest()", "testcase": true, "constructor": false, "invocations": ["newFixedThreadPool", "serializedSubscriber", "submit", "submit", "submit", "submit", "submit", "submit", "submit", "submit", "submit", "sleep", "submit", "submit", "submit", "submit", "submit", "submit", "submit", "submit", "waitOnThreads", "assertEvents", "fail", "getMessage", "printStackTrace", "shutdown", "awaitTermination", "printStackTrace"]}, "focal_class": {"identifier": "SerializedSubscriber", "superclass": "", "interfaces": "implements FlowableSubscriber<T>, Subscription", "fields": [{"original_string": "final Subscriber<? super T> actual;", "modifier": "final", "type": "Subscriber<? super T>", "declarator": "actual", "var_name": "actual"}, {"original_string": "final boolean delayError;", "modifier": "final", "type": "boolean", "declarator": "delayError", "var_name": "delayError"}, {"original_string": "static final int QUEUE_LINK_SIZE = 4;", "modifier": "static final", "type": "int", "declarator": "QUEUE_LINK_SIZE = 4", "var_name": "QUEUE_LINK_SIZE"}, {"original_string": "Subscription subscription;", "modifier": "", "type": "Subscription", "declarator": "subscription", "var_name": "subscription"}, {"original_string": "boolean emitting;", "modifier": "", "type": "boolean", "declarator": "emitting", "var_name": "emitting"}, {"original_string": "AppendOnlyLinkedArrayList<Object> queue;", "modifier": "", "type": "AppendOnlyLinkedArrayList<Object>", "declarator": "queue", "var_name": "queue"}, {"original_string": "volatile boolean done;", "modifier": "volatile", "type": "boolean", "declarator": "done", "var_name": "done"}], "methods": [{"identifier": "SerializedSubscriber", "parameters": "(Subscriber<? super T> actual)", "modifiers": "public", "return": "", "signature": " SerializedSubscriber(Subscriber<? super T> actual)", "full_signature": "public  SerializedSubscriber(Subscriber<? super T> actual)", "class_method_signature": "SerializedSubscriber.SerializedSubscriber(Subscriber<? super T> actual)", "testcase": false, "constructor": true}, {"identifier": "SerializedSubscriber", "parameters": "(Subscriber<? super T> actual, boolean delayError)", "modifiers": "public", "return": "", "signature": " SerializedSubscriber(Subscriber<? super T> actual, boolean delayError)", "full_signature": "public  SerializedSubscriber(Subscriber<? super T> actual, boolean delayError)", "class_method_signature": "SerializedSubscriber.SerializedSubscriber(Subscriber<? super T> actual, boolean delayError)", "testcase": false, "constructor": true}, {"identifier": "onSubscribe", "parameters": "(Subscription s)", "modifiers": "@Override public", "return": "void", "signature": "void onSubscribe(Subscription s)", "full_signature": "@Override public void onSubscribe(Subscription s)", "class_method_signature": "SerializedSubscriber.onSubscribe(Subscription s)", "testcase": false, "constructor": false}, {"identifier": "onNext", "parameters": "(T t)", "modifiers": "@Override public", "return": "void", "signature": "void onNext(T t)", "full_signature": "@Override public void onNext(T t)", "class_method_signature": "SerializedSubscriber.onNext(T t)", "testcase": false, "constructor": false}, {"identifier": "onError", "parameters": "(Throwable t)", "modifiers": "@Override public", "return": "void", "signature": "void onError(Throwable t)", "full_signature": "@Override public void onError(Throwable t)", "class_method_signature": "SerializedSubscriber.onError(Throwable t)", "testcase": false, "constructor": false}, {"identifier": "onComplete", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void onComplete()", "full_signature": "@Override public void onComplete()", "class_method_signature": "SerializedSubscriber.onComplete()", "testcase": false, "constructor": false}, {"identifier": "emitLoop", "parameters": "()", "modifiers": "", "return": "void", "signature": "void emitLoop()", "full_signature": " void emitLoop()", "class_method_signature": "SerializedSubscriber.emitLoop()", "testcase": false, "constructor": false}, {"identifier": "request", "parameters": "(long n)", "modifiers": "@Override public", "return": "void", "signature": "void request(long n)", "full_signature": "@Override public void request(long n)", "class_method_signature": "SerializedSubscriber.request(long n)", "testcase": false, "constructor": false}, {"identifier": "cancel", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void cancel()", "full_signature": "@Override public void cancel()", "class_method_signature": "SerializedSubscriber.cancel()", "testcase": false, "constructor": false}], "file": "rxjava/src/main/java/io/reactivex/subscribers/SerializedSubscriber.java"}, "focal_method": {"identifier": "SerializedSubscriber", "parameters": "(Subscriber<? super T> actual)", "modifiers": "public", "return": "", "body": "public SerializedSubscriber(Subscriber<? super T> actual) {\n        this(actual, false);\n    }", "signature": " SerializedSubscriber(Subscriber<? super T> actual)", "full_signature": "public  SerializedSubscriber(Subscriber<? super T> actual)", "class_method_signature": "SerializedSubscriber.SerializedSubscriber(Subscriber<? super T> actual)", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 128274093, "url": "https://github.com/artem-zinnatullin/error-prone-performance", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 13, "size": 22484, "license": "licensed"}}