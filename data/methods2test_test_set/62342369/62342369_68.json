{"test_class": {"identifier": "JUnit4ReportWriterTest", "superclass": "", "interfaces": "", "fields": [], "file": "step-plans/step-plans-base-artefacts/src/test/java/step/reporting/JUnit4ReportWriterTest.java"}, "test_case": {"identifier": "testTestset", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testTestset() throws IOException {\n\t\tPlan plan = PlanBuilder.create()\n\t\t\t\t.startBlock(testSet(\"TS01\"))\n\t\t\t\t\t.startBlock(testCase(\"TC01 - PASSED\"))\n\t\t\t\t\t\t.add(checkArtefact(ReportNodeStatus.PASSED))\n\t\t\t\t\t.endBlock()\n\t\t\t\t\t.startBlock(testCase(\"TC02 - PASSED in Sequence\"))\n\t\t\t\t\t\t.startBlock(sequence())\n\t\t\t\t\t\t\t.add(checkArtefact(ReportNodeStatus.PASSED))\n\t\t\t\t\t\t\t.add(checkArtefact(ReportNodeStatus.PASSED))\n\t\t\t\t\t\t.endBlock()\n\t\t\t\t\t.endBlock()\n\t\t\t\t\t.startBlock(testCase(\"TC03 - FAILED without error message\"))\n\t\t\t\t\t\t.add(checkArtefact(ReportNodeStatus.PASSED))\n\t\t\t\t\t\t.add(checkArtefact(ReportNodeStatus.FAILED))\n\t\t\t\t\t.endBlock()\n\t\t\t\t\t.startBlock(testCase(\"TC04 - FAILED with error message\"))\n\t\t\t\t\t\t.startBlock(for_())\n\t\t\t\t\t\t\t.add(checkArtefact(ReportNodeStatus.FAILED, \"my message\"))\n\t\t\t\t\t\t.endBlock()\n\t\t\t\t\t.endBlock()\n\t\t\t\t\t.startBlock(testCase(\"TC05 - TECH_ERROR\"))\n\t\t\t\t\t\t.add(checkArtefact(ReportNodeStatus.TECHNICAL_ERROR))\n\t\t\t\t\t.endBlock()\n\t\t\t\t\t.startBlock(testCase(\"TC06 - TECH_ERROR with message\"))\n\t\t\t\t\t\t.add(checkArtefact(ReportNodeStatus.TECHNICAL_ERROR, \"My error message\"))\n\t\t\t\t\t.endBlock()\n\t\t\t\t\t.startBlock(testCase(\"TC07 - SKIPPED\"))\n\t\t\t\t\t\t.add(checkArtefact(ReportNodeStatus.SKIPPED))\n\t\t\t\t\t.endBlock()\n\t\t\t\t\t.startBlock(testCase(\"TC08 - NORUN\"))\n\t\t\t\t\t\t.add(checkArtefact(ReportNodeStatus.NORUN))\n\t\t\t\t\t.endBlock()\n\t\t\t\t.endBlock().build();\n\t\t\n\t\tFile report = new File(\"TEST-JUnit4ReportWriterTest-testTestset.xml\");\n\t\treport.deleteOnExit();\n\t\t\n\t\tExecutionEngine engine = ExecutionEngine.builder().withPlugin(new ThreadPoolPlugin()).withPlugin(new BaseArtefactPlugin()).build();\n\t\tengine.execute(plan).writeReport(new JUnit4ReportWriter(), report);\n\t\t\n\t\tPlanRunnerResultAssert.assertEquals(this.getClass(), \"TEST-JUnit4ReportWriterTest-testTestset-expected.xml\", report, \"time=\\\".+?\\\"\");\n\t}", "signature": "void testTestset()", "full_signature": "@Test public void testTestset()", "class_method_signature": "JUnit4ReportWriterTest.testTestset()", "testcase": true, "constructor": false, "invocations": ["build", "endBlock", "endBlock", "add", "startBlock", "endBlock", "add", "startBlock", "endBlock", "add", "startBlock", "endBlock", "add", "startBlock", "endBlock", "endBlock", "add", "startBlock", "startBlock", "endBlock", "add", "add", "startBlock", "endBlock", "endBlock", "add", "add", "startBlock", "startBlock", "endBlock", "add", "startBlock", "startBlock", "create", "testSet", "testCase", "checkArtefact", "testCase", "sequence", "checkArtefact", "checkArtefact", "testCase", "checkArtefact", "checkArtefact", "testCase", "for_", "checkArtefact", "testCase", "checkArtefact", "testCase", "checkArtefact", "testCase", "checkArtefact", "testCase", "checkArtefact", "deleteOnExit", "build", "withPlugin", "withPlugin", "builder", "writeReport", "execute", "assertEquals", "getClass"]}, "focal_class": {"identifier": "JUnit4ReportWriter", "superclass": "", "interfaces": "implements ReportWriter", "fields": [], "methods": [{"identifier": "writeReport", "parameters": "(ReportTreeAccessor reportTreeAccessor, String executionId, File outputFile)", "modifiers": "@Override public", "return": "void", "signature": "void writeReport(ReportTreeAccessor reportTreeAccessor, String executionId, File outputFile)", "full_signature": "@Override public void writeReport(ReportTreeAccessor reportTreeAccessor, String executionId, File outputFile)", "class_method_signature": "JUnit4ReportWriter.writeReport(ReportTreeAccessor reportTreeAccessor, String executionId, File outputFile)", "testcase": false, "constructor": false}, {"identifier": "writeErrorOrFailure", "parameters": "(BufferedWriter writer, ReportNode node, AtomicBoolean errorWritten)", "modifiers": "protected", "return": "void", "signature": "void writeErrorOrFailure(BufferedWriter writer, ReportNode node, AtomicBoolean errorWritten)", "full_signature": "protected void writeErrorOrFailure(BufferedWriter writer, ReportNode node, AtomicBoolean errorWritten)", "class_method_signature": "JUnit4ReportWriter.writeErrorOrFailure(BufferedWriter writer, ReportNode node, AtomicBoolean errorWritten)", "testcase": false, "constructor": false}, {"identifier": "formatTime", "parameters": "(long duration)", "modifiers": "protected", "return": "String", "signature": "String formatTime(long duration)", "full_signature": "protected String formatTime(long duration)", "class_method_signature": "JUnit4ReportWriter.formatTime(long duration)", "testcase": false, "constructor": false}], "file": "step-plans/step-plans-base-artefacts/src/main/java/step/reporting/JUnit4ReportWriter.java"}, "focal_method": {"identifier": "writeReport", "parameters": "(ReportTreeAccessor reportTreeAccessor, String executionId, File outputFile)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void writeReport(ReportTreeAccessor reportTreeAccessor, String executionId, File outputFile) throws IOException {\n\t\tReportTreeVisitor visitor = new ReportTreeVisitor(reportTreeAccessor);\n\t\t\n\t\ttry(BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile))) {\n\t\t\t// Using AtomicInteger and StringBuilder because of the \"final limitation\" in lambdas...\n\t\t\tAtomicInteger numberOfTests = new AtomicInteger(0);\n\t\t\tAtomicInteger numberOfFailures = new AtomicInteger(0);\n\t\t\tAtomicInteger numberOfErrors = new AtomicInteger(0);\n\t\t\tAtomicInteger numberOfSkipped = new AtomicInteger(0);\n\t\t\tAtomicLong duration = new AtomicLong();\n\t\t\tStringBuilder name = new StringBuilder();\n\t\t\t\n\t\t\t// First visit the report tree to get the root node informations and the different counts\n\t\t\tvisitor.visit(executionId, e->{\n\t\t\t\tif(e.getStack().size()==0) {\n\t\t\t\t\tname.append(e.getNode().getName());\n\t\t\t\t\tduration.set(e.getNode().getDuration());\n\t\t\t\t}\n\t\t\t\tif(e.getStack().size()==1) {\n\t\t\t\t\tnumberOfTests.incrementAndGet();\n\t\t\t\t\tReportNode node = e.getNode();\n\t\t\t\t\tif(node.getStatus() == ReportNodeStatus.FAILED) {\n\t\t\t\t\t\tnumberOfFailures.incrementAndGet();\n\t\t\t\t\t} else if(node.getStatus() == ReportNodeStatus.TECHNICAL_ERROR) {\n\t\t\t\t\t\tnumberOfErrors.incrementAndGet();\n\t\t\t\t\t} else if(node.getStatus() == ReportNodeStatus.SKIPPED) {\n\t\t\t\t\t\tnumberOfSkipped.incrementAndGet();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t\twriter.write(\"<testsuite name=\\\"\"+name.toString()+\"\\\" time=\\\"\"+formatTime(duration.get())+\"\\\" tests=\\\"\"+numberOfTests.get()+\"\\\" skipped=\\\"\"+numberOfSkipped.get()+\"\\\" failures=\\\"\"+numberOfFailures.get()+\"\\\" errors=\\\"\"+numberOfErrors.get()+\"\\\">\");\n\t\t\twriter.newLine();\n\t\t\t\n\t\t\tAtomicBoolean errorWritten = new AtomicBoolean(false);\n\t\t\t// visit the tree again and write the <testcase> blocks\n\t\t\tvisitor.visit(executionId, new ReportNodeVisitorEventHandler() {\n\t\t\t\t@Override\n\t\t\t\tpublic void startReportNode(ReportNodeEvent event) {\n\t\t\t\t\tReportNode node = event.getNode();\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// as a convention report the children of the first level as testcases\n\t\t\t\t\t\tif(event.getStack().size()==1) {\n\t\t\t\t\t\t\tif(!skipReportNode(node)) {\n\t\t\t\t\t\t\t\twriter.write(\"<testcase classname=\\\"\"+node.getClass().getName()+\"\\\" name=\\\"\"+node.getName()+\"\\\" time=\\\"\"+formatTime(node.getDuration())+\"\\\">\");\n\t\t\t\t\t\t\t\terrorWritten.set(false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (event.getStack().size()>1) {\n\t\t\t\t\t\t\t// report all the errors of the sub nodes (level > 1)\n\t\t\t\t\t\t\tif(node.getError() != null) {\n\t\t\t\t\t\t\t\twriteErrorOrFailure(writer, node, errorWritten);\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\tthrow new RuntimeException(e1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void endReportNode(ReportNodeEvent event) {\n\t\t\t\t\tif(event.getStack().size()==1) {\n\t\t\t\t\t\tReportNode node = event.getNode();\n\t\t\t\t\t\tif(!skipReportNode(node)) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// if no error has been found in the sub-nodes, report the error for this node\n\t\t\t\t\t\t\t\tif(node.getStatus()!=ReportNodeStatus.PASSED && !errorWritten.get()) {\n\t\t\t\t\t\t\t\t\twriteErrorOrFailure(writer, node, errorWritten);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// close the <testcase> block\n\t\t\t\t\t\t\t\twriter.write(\"</testcase>\");\n\t\t\t\t\t\t\t\twriter.newLine();\n\t\t\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\t\t\tthrow new RuntimeException(e1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprotected boolean skipReportNode(ReportNode node) {\n\t\t\t\t\treturn node.getStatus()==ReportNodeStatus.SKIPPED || node.getStatus()==ReportNodeStatus.NORUN;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\twriter.write(\"</testsuite>\");\n\t\t\twriter.newLine();\n\t\t\t\n\t\t\twriter.flush();\n\t\t}\n\t}", "signature": "void writeReport(ReportTreeAccessor reportTreeAccessor, String executionId, File outputFile)", "full_signature": "@Override public void writeReport(ReportTreeAccessor reportTreeAccessor, String executionId, File outputFile)", "class_method_signature": "JUnit4ReportWriter.writeReport(ReportTreeAccessor reportTreeAccessor, String executionId, File outputFile)", "testcase": false, "constructor": false, "invocations": ["visit", "size", "getStack", "append", "getName", "getNode", "set", "getDuration", "getNode", "size", "getStack", "incrementAndGet", "getNode", "getStatus", "incrementAndGet", "getStatus", "incrementAndGet", "getStatus", "incrementAndGet", "write", "toString", "formatTime", "get", "get", "get", "get", "get", "newLine", "visit", "getNode", "size", "getStack", "skipReportNode", "write", "getName", "getClass", "getName", "formatTime", "getDuration", "set", "size", "getStack", "getError", "writeErrorOrFailure", "size", "getStack", "getNode", "skipReportNode", "getStatus", "get", "writeErrorOrFailure", "write", "newLine", "getStatus", "getStatus", "write", "newLine", "flush"]}, "repository": {"repo_id": 62342369, "url": "https://github.com/exense/step", "stars": 12, "created": "6/30/2016 9:08:29 PM +00:00", "updates": "2020-01-24T17:13:24+00:00", "fork": "False", "license": "licensed"}}