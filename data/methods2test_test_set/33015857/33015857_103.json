{"test_class": {"identifier": "ByteScannerTest", "superclass": "", "interfaces": "", "fields": [], "file": "reflekt/src/test/java/io/advantageous/boon/primitive/ByteScannerTest.java"}, "test_case": {"identifier": "autoSplitThisEndsInSpace", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void autoSplitThisEndsInSpace() {\n\n        byte[] letters =\n                bytes( \"This is a string \" );\n\n\n        byte[][] splitted = ByteScanner.split(letters, ' ');\n\n\n        assertEquals(\n                4,\n                splitted.length\n        );\n\n        assertArrayEquals(\n                bytes( \"This\" ),\n                splitted[ 0 ]\n        );\n\n\n        assertArrayEquals(\n                bytes( \"is\" ),\n                splitted[ 1 ]\n        );\n\n\n        assertArrayEquals(\n                bytes( \"a\" ),\n                splitted[ 2 ]\n        );\n\n\n        assertArrayEquals(\n                bytes( \"string\" ),\n                splitted[ 3 ]\n        );\n\n        assertArrayEquals(\n                new byte[][]{ bytes( \"This\" ), bytes( \"is\" ), bytes( \"a\" ), bytes( \"string\" ) },\n                splitted\n        );\n\n\n    }", "signature": "void autoSplitThisEndsInSpace()", "full_signature": "@Test public void autoSplitThisEndsInSpace()", "class_method_signature": "ByteScannerTest.autoSplitThisEndsInSpace()", "testcase": true, "constructor": false, "invocations": ["bytes", "split", "assertEquals", "assertArrayEquals", "bytes", "assertArrayEquals", "bytes", "assertArrayEquals", "bytes", "assertArrayEquals", "bytes", "assertArrayEquals", "bytes", "bytes", "bytes", "bytes"]}, "focal_class": {"identifier": "ByteScanner", "superclass": "", "interfaces": "", "fields": [{"original_string": "final static String MIN_INT_STR_NO_SIGN = String.valueOf( Integer.MIN_VALUE ).substring( 1 );", "modifier": "final static", "type": "String", "declarator": "MIN_INT_STR_NO_SIGN = String.valueOf( Integer.MIN_VALUE ).substring( 1 )", "var_name": "MIN_INT_STR_NO_SIGN"}, {"original_string": "final static String MAX_INT_STR = String.valueOf( Integer.MAX_VALUE );", "modifier": "final static", "type": "String", "declarator": "MAX_INT_STR = String.valueOf( Integer.MAX_VALUE )", "var_name": "MAX_INT_STR"}, {"original_string": "final static String MIN_LONG_STR_NO_SIGN = String.valueOf( Long.MIN_VALUE ).substring( 1 );", "modifier": "final static", "type": "String", "declarator": "MIN_LONG_STR_NO_SIGN = String.valueOf( Long.MIN_VALUE ).substring( 1 )", "var_name": "MIN_LONG_STR_NO_SIGN"}, {"original_string": "final static String MAX_LONG_STR = String.valueOf( Long.MAX_VALUE );", "modifier": "final static", "type": "String", "declarator": "MAX_LONG_STR = String.valueOf( Long.MAX_VALUE )", "var_name": "MAX_LONG_STR"}, {"original_string": "private final static long L_BILLION = 1000000000;", "modifier": "private final static", "type": "long", "declarator": "L_BILLION = 1000000000", "var_name": "L_BILLION"}, {"original_string": "private static double powersOf10[] = {\n            1.0,\n            10.0,\n            100.0,\n            1_000.0,\n            10_000.0,\n            100_000.0,\n            1_000_000.0,\n            10_000_000.0,\n            100_000_000.0,\n            1_000_000_000.0,\n            10_000_000_000.0,\n            100_000_000_000.0,\n            1_000_000_000_000.0,\n            10_000_000_000_000.0,\n            100_000_000_000_000.0,\n            1_000_000_000_000_000.0,\n            10_000_000_000_000_000.0,\n            100_000_000_000_000_000.0,\n            1_000_000_000_000_000_000.0,\n\n    };", "modifier": "private static", "type": "double", "declarator": "powersOf10[] = {\n            1.0,\n            10.0,\n            100.0,\n            1_000.0,\n            10_000.0,\n            100_000.0,\n            1_000_000.0,\n            10_000_000.0,\n            100_000_000.0,\n            1_000_000_000.0,\n            10_000_000_000.0,\n            100_000_000_000.0,\n            1_000_000_000_000.0,\n            10_000_000_000_000.0,\n            100_000_000_000_000.0,\n            1_000_000_000_000_000.0,\n            10_000_000_000_000_000.0,\n            100_000_000_000_000_000.0,\n            1_000_000_000_000_000_000.0,\n\n    }", "var_name": "powersOf10"}], "methods": [{"identifier": "isDigits", "parameters": "( final char[] inputArray )", "modifiers": "public static", "return": "boolean", "signature": "boolean isDigits( final char[] inputArray )", "full_signature": "public static boolean isDigits( final char[] inputArray )", "class_method_signature": "ByteScanner.isDigits( final char[] inputArray )", "testcase": false, "constructor": false}, {"identifier": "hasDecimalChar", "parameters": "( byte[] chars, boolean negative )", "modifiers": "public static", "return": "boolean", "signature": "boolean hasDecimalChar( byte[] chars, boolean negative )", "full_signature": "public static boolean hasDecimalChar( byte[] chars, boolean negative )", "class_method_signature": "ByteScanner.hasDecimalChar( byte[] chars, boolean negative )", "testcase": false, "constructor": false}, {"identifier": "splitExact", "parameters": "( final byte[] inputArray,\n                                       final int split, final int resultsArrayLength )", "modifiers": "public static", "return": "byte[][]", "signature": "byte[][] splitExact( final byte[] inputArray,\n                                       final int split, final int resultsArrayLength )", "full_signature": "public static byte[][] splitExact( final byte[] inputArray,\n                                       final int split, final int resultsArrayLength )", "class_method_signature": "ByteScanner.splitExact( final byte[] inputArray,\n                                       final int split, final int resultsArrayLength )", "testcase": false, "constructor": false}, {"identifier": "splitExact", "parameters": "( final byte[] inputArray,\n                                       final int resultsArrayLength, int... delims )", "modifiers": "public static", "return": "byte[][]", "signature": "byte[][] splitExact( final byte[] inputArray,\n                                       final int resultsArrayLength, int... delims )", "full_signature": "public static byte[][] splitExact( final byte[] inputArray,\n                                       final int resultsArrayLength, int... delims )", "class_method_signature": "ByteScanner.splitExact( final byte[] inputArray,\n                                       final int resultsArrayLength, int... delims )", "testcase": false, "constructor": false}, {"identifier": "split", "parameters": "( final byte[] inputArray,\n                                  final int split )", "modifiers": "public static", "return": "byte[][]", "signature": "byte[][] split( final byte[] inputArray,\n                                  final int split )", "full_signature": "public static byte[][] split( final byte[] inputArray,\n                                  final int split )", "class_method_signature": "ByteScanner.split( final byte[] inputArray,\n                                  final int split )", "testcase": false, "constructor": false}, {"identifier": "splitByChars", "parameters": "( final byte[] inputArray,\n                                         char... delims )", "modifiers": "public static", "return": "byte[][]", "signature": "byte[][] splitByChars( final byte[] inputArray,\n                                         char... delims )", "full_signature": "public static byte[][] splitByChars( final byte[] inputArray,\n                                         char... delims )", "class_method_signature": "ByteScanner.splitByChars( final byte[] inputArray,\n                                         char... delims )", "testcase": false, "constructor": false}, {"identifier": "splitByCharsFromToDelims", "parameters": "( final byte[] inputArray, int from, int to,\n                                                     final byte... delims )", "modifiers": "public static", "return": "byte[][]", "signature": "byte[][] splitByCharsFromToDelims( final byte[] inputArray, int from, int to,\n                                                     final byte... delims )", "full_signature": "public static byte[][] splitByCharsFromToDelims( final byte[] inputArray, int from, int to,\n                                                     final byte... delims )", "class_method_signature": "ByteScanner.splitByCharsFromToDelims( final byte[] inputArray, int from, int to,\n                                                     final byte... delims )", "testcase": false, "constructor": false}, {"identifier": "splitByCharsNoneEmpty", "parameters": "( byte[] inputArray,\n                                                  char... delims )", "modifiers": "public static", "return": "byte[][]", "signature": "byte[][] splitByCharsNoneEmpty( byte[] inputArray,\n                                                  char... delims )", "full_signature": "public static byte[][] splitByCharsNoneEmpty( byte[] inputArray,\n                                                  char... delims )", "class_method_signature": "ByteScanner.splitByCharsNoneEmpty( byte[] inputArray,\n                                                  char... delims )", "testcase": false, "constructor": false}, {"identifier": "splitByCharsNoneEmpty", "parameters": "( final byte[] inputArray, int from, int to,\n                                                  final byte... delims )", "modifiers": "public static", "return": "byte[][]", "signature": "byte[][] splitByCharsNoneEmpty( final byte[] inputArray, int from, int to,\n                                                  final byte... delims )", "full_signature": "public static byte[][] splitByCharsNoneEmpty( final byte[] inputArray, int from, int to,\n                                                  final byte... delims )", "class_method_signature": "ByteScanner.splitByCharsNoneEmpty( final byte[] inputArray, int from, int to,\n                                                  final byte... delims )", "testcase": false, "constructor": false}, {"identifier": "compact", "parameters": "( byte[][] array )", "modifiers": "public static", "return": "byte[][]", "signature": "byte[][] compact( byte[][] array )", "full_signature": "public static byte[][] compact( byte[][] array )", "class_method_signature": "ByteScanner.compact( byte[][] array )", "testcase": false, "constructor": false}, {"identifier": "_grow", "parameters": "( byte[][] array )", "modifiers": "private static", "return": "byte[][]", "signature": "byte[][] _grow( byte[][] array )", "full_signature": "private static byte[][] _grow( byte[][] array )", "class_method_signature": "ByteScanner._grow( byte[][] array )", "testcase": false, "constructor": false}, {"identifier": "__shrink", "parameters": "( byte[][] array, int size )", "modifiers": "private static", "return": "byte[][]", "signature": "byte[][] __shrink( byte[][] array, int size )", "full_signature": "private static byte[][] __shrink( byte[][] array, int size )", "class_method_signature": "ByteScanner.__shrink( byte[][] array, int size )", "testcase": false, "constructor": false}, {"identifier": "isInteger", "parameters": "( byte[] digitChars, int offset, int len\n                                      )", "modifiers": "public static", "return": "boolean", "signature": "boolean isInteger( byte[] digitChars, int offset, int len\n                                      )", "full_signature": "public static boolean isInteger( byte[] digitChars, int offset, int len\n                                      )", "class_method_signature": "ByteScanner.isInteger( byte[] digitChars, int offset, int len\n                                      )", "testcase": false, "constructor": false}, {"identifier": "isLong", "parameters": "( byte[] digitChars, int offset, int len\n                                   )", "modifiers": "public static", "return": "boolean", "signature": "boolean isLong( byte[] digitChars, int offset, int len\n                                   )", "full_signature": "public static boolean isLong( byte[] digitChars, int offset, int len\n                                   )", "class_method_signature": "ByteScanner.isLong( byte[] digitChars, int offset, int len\n                                   )", "testcase": false, "constructor": false}, {"identifier": "parseInt", "parameters": "( byte[] digitChars )", "modifiers": "public static", "return": "int", "signature": "int parseInt( byte[] digitChars )", "full_signature": "public static int parseInt( byte[] digitChars )", "class_method_signature": "ByteScanner.parseInt( byte[] digitChars )", "testcase": false, "constructor": false}, {"identifier": "parseIntFromTo", "parameters": "( byte[] digitChars, int offset, int to )", "modifiers": "public static", "return": "int", "signature": "int parseIntFromTo( byte[] digitChars, int offset, int to )", "full_signature": "public static int parseIntFromTo( byte[] digitChars, int offset, int to )", "class_method_signature": "ByteScanner.parseIntFromTo( byte[] digitChars, int offset, int to )", "testcase": false, "constructor": false}, {"identifier": "parseIntIgnoreDot", "parameters": "( byte[] digitChars, int offset, int len )", "modifiers": "public static", "return": "int", "signature": "int parseIntIgnoreDot( byte[] digitChars, int offset, int len )", "full_signature": "public static int parseIntIgnoreDot( byte[] digitChars, int offset, int len )", "class_method_signature": "ByteScanner.parseIntIgnoreDot( byte[] digitChars, int offset, int len )", "testcase": false, "constructor": false}, {"identifier": "parseLong", "parameters": "( byte[] digitChars, int offset, int len )", "modifiers": "public static", "return": "long", "signature": "long parseLong( byte[] digitChars, int offset, int len )", "full_signature": "public static long parseLong( byte[] digitChars, int offset, int len )", "class_method_signature": "ByteScanner.parseLong( byte[] digitChars, int offset, int len )", "testcase": false, "constructor": false}, {"identifier": "parseLongIgnoreDot", "parameters": "( byte[] digitChars, int offset, int len )", "modifiers": "public static", "return": "long", "signature": "long parseLongIgnoreDot( byte[] digitChars, int offset, int len )", "full_signature": "public static long parseLongIgnoreDot( byte[] digitChars, int offset, int len )", "class_method_signature": "ByteScanner.parseLongIgnoreDot( byte[] digitChars, int offset, int len )", "testcase": false, "constructor": false}, {"identifier": "parseJsonNumber", "parameters": "( byte[] buffer )", "modifiers": "public static", "return": "Number", "signature": "Number parseJsonNumber( byte[] buffer )", "full_signature": "public static Number parseJsonNumber( byte[] buffer )", "class_method_signature": "ByteScanner.parseJsonNumber( byte[] buffer )", "testcase": false, "constructor": false}, {"identifier": "parseJsonNumber", "parameters": "( byte[] buffer, int from, int to )", "modifiers": "public static", "return": "Number", "signature": "Number parseJsonNumber( byte[] buffer, int from, int to )", "full_signature": "public static Number parseJsonNumber( byte[] buffer, int from, int to )", "class_method_signature": "ByteScanner.parseJsonNumber( byte[] buffer, int from, int to )", "testcase": false, "constructor": false}, {"identifier": "parseJsonNumber", "parameters": "( byte[] buffer, int from, int max, int size[] )", "modifiers": "public static", "return": "Number", "signature": "Number parseJsonNumber( byte[] buffer, int from, int max, int size[] )", "full_signature": "public static Number parseJsonNumber( byte[] buffer, int from, int max, int size[] )", "class_method_signature": "ByteScanner.parseJsonNumber( byte[] buffer, int from, int max, int size[] )", "testcase": false, "constructor": false}, {"identifier": "parseLongFromTo", "parameters": "( byte[] digitChars, int offset, int to )", "modifiers": "public static", "return": "long", "signature": "long parseLongFromTo( byte[] digitChars, int offset, int to )", "full_signature": "public static long parseLongFromTo( byte[] digitChars, int offset, int to )", "class_method_signature": "ByteScanner.parseLongFromTo( byte[] digitChars, int offset, int to )", "testcase": false, "constructor": false}, {"identifier": "parseIntFromToIgnoreDot", "parameters": "( byte[] digitChars, int offset, int to )", "modifiers": "public static", "return": "int", "signature": "int parseIntFromToIgnoreDot( byte[] digitChars, int offset, int to )", "full_signature": "public static int parseIntFromToIgnoreDot( byte[] digitChars, int offset, int to )", "class_method_signature": "ByteScanner.parseIntFromToIgnoreDot( byte[] digitChars, int offset, int to )", "testcase": false, "constructor": false}, {"identifier": "parseLongFromToIgnoreDot", "parameters": "( byte[] digitChars, int offset, int to )", "modifiers": "public static", "return": "long", "signature": "long parseLongFromToIgnoreDot( byte[] digitChars, int offset, int to )", "full_signature": "public static long parseLongFromToIgnoreDot( byte[] digitChars, int offset, int to )", "class_method_signature": "ByteScanner.parseLongFromToIgnoreDot( byte[] digitChars, int offset, int to )", "testcase": false, "constructor": false}, {"identifier": "parseFloat", "parameters": "( byte[] buffer, int from, int to )", "modifiers": "public static", "return": "float", "signature": "float parseFloat( byte[] buffer, int from, int to )", "full_signature": "public static float parseFloat( byte[] buffer, int from, int to )", "class_method_signature": "ByteScanner.parseFloat( byte[] buffer, int from, int to )", "testcase": false, "constructor": false}, {"identifier": "parseDouble", "parameters": "( byte[] buffer )", "modifiers": "public static", "return": "double", "signature": "double parseDouble( byte[] buffer )", "full_signature": "public static double parseDouble( byte[] buffer )", "class_method_signature": "ByteScanner.parseDouble( byte[] buffer )", "testcase": false, "constructor": false}, {"identifier": "parseDouble", "parameters": "( byte[] buffer, int from, int to )", "modifiers": "public static", "return": "double", "signature": "double parseDouble( byte[] buffer, int from, int to )", "full_signature": "public static double parseDouble( byte[] buffer, int from, int to )", "class_method_signature": "ByteScanner.parseDouble( byte[] buffer, int from, int to )", "testcase": false, "constructor": false}, {"identifier": "simpleDouble", "parameters": "( byte[] buffer, boolean simple,  int digitsPastPoint, int startIndex, int endIndex )", "modifiers": "public static", "return": "double", "signature": "double simpleDouble( byte[] buffer, boolean simple,  int digitsPastPoint, int startIndex, int endIndex )", "full_signature": "public static double simpleDouble( byte[] buffer, boolean simple,  int digitsPastPoint, int startIndex, int endIndex )", "class_method_signature": "ByteScanner.simpleDouble( byte[] buffer, boolean simple,  int digitsPastPoint, int startIndex, int endIndex )", "testcase": false, "constructor": false}, {"identifier": "skipWhiteSpace", "parameters": "( byte [] array, int index )", "modifiers": "public static", "return": "int", "signature": "int skipWhiteSpace( byte [] array, int index )", "full_signature": "public static int skipWhiteSpace( byte [] array, int index )", "class_method_signature": "ByteScanner.skipWhiteSpace( byte [] array, int index )", "testcase": false, "constructor": false}, {"identifier": "skipWhiteSpace", "parameters": "( byte [] array, int index, final int length )", "modifiers": "public static", "return": "int", "signature": "int skipWhiteSpace( byte [] array, int index, final int length )", "full_signature": "public static int skipWhiteSpace( byte [] array, int index, final int length )", "class_method_signature": "ByteScanner.skipWhiteSpace( byte [] array, int index, final int length )", "testcase": false, "constructor": false}, {"identifier": "readNumber", "parameters": "( byte[] array, int idx )", "modifiers": "public static", "return": "byte[]", "signature": "byte[] readNumber( byte[] array, int idx )", "full_signature": "public static byte[] readNumber( byte[] array, int idx )", "class_method_signature": "ByteScanner.readNumber( byte[] array, int idx )", "testcase": false, "constructor": false}, {"identifier": "readNumber", "parameters": "( byte[] array, int idx, final int len )", "modifiers": "public static", "return": "byte[]", "signature": "byte[] readNumber( byte[] array, int idx, final int len )", "full_signature": "public static byte[] readNumber( byte[] array, int idx, final int len )", "class_method_signature": "ByteScanner.readNumber( byte[] array, int idx, final int len )", "testcase": false, "constructor": false}, {"identifier": "skipWhiteSpaceFast", "parameters": "( byte [] array )", "modifiers": "public static", "return": "int", "signature": "int skipWhiteSpaceFast( byte [] array )", "full_signature": "public static int skipWhiteSpaceFast( byte [] array )", "class_method_signature": "ByteScanner.skipWhiteSpaceFast( byte [] array )", "testcase": false, "constructor": false}, {"identifier": "skipWhiteSpaceFast", "parameters": "( byte [] array, int index )", "modifiers": "public static", "return": "int", "signature": "int skipWhiteSpaceFast( byte [] array, int index )", "full_signature": "public static int skipWhiteSpaceFast( byte [] array, int index )", "class_method_signature": "ByteScanner.skipWhiteSpaceFast( byte [] array, int index )", "testcase": false, "constructor": false}, {"identifier": "encodeNibbleToHexAsciiCharByte", "parameters": "( final int nibble )", "modifiers": "protected static", "return": "int", "signature": "int encodeNibbleToHexAsciiCharByte( final int nibble )", "full_signature": "protected static int encodeNibbleToHexAsciiCharByte( final int nibble )", "class_method_signature": "ByteScanner.encodeNibbleToHexAsciiCharByte( final int nibble )", "testcase": false, "constructor": false}, {"identifier": "encodeByteIntoTwoAsciiCharBytes", "parameters": "( final int decoded, final byte[] encoded )", "modifiers": "public static", "return": "void", "signature": "void encodeByteIntoTwoAsciiCharBytes( final int decoded, final byte[] encoded )", "full_signature": "public static void encodeByteIntoTwoAsciiCharBytes( final int decoded, final byte[] encoded )", "class_method_signature": "ByteScanner.encodeByteIntoTwoAsciiCharBytes( final int decoded, final byte[] encoded )", "testcase": false, "constructor": false}, {"identifier": "errorDetails", "parameters": "( String message, byte[] array, int index, int ch )", "modifiers": "public static", "return": "String", "signature": "String errorDetails( String message, byte[] array, int index, int ch )", "full_signature": "public static String errorDetails( String message, byte[] array, int index, int ch )", "class_method_signature": "ByteScanner.errorDetails( String message, byte[] array, int index, int ch )", "testcase": false, "constructor": false}, {"identifier": "hasEscapeChar", "parameters": "(byte []array, int index, int[] indexHolder)", "modifiers": "public static", "return": "boolean", "signature": "boolean hasEscapeChar(byte []array, int index, int[] indexHolder)", "full_signature": "public static boolean hasEscapeChar(byte []array, int index, int[] indexHolder)", "class_method_signature": "ByteScanner.hasEscapeChar(byte []array, int index, int[] indexHolder)", "testcase": false, "constructor": false}, {"identifier": "findEndQuote", "parameters": "(final byte[] array,  int index)", "modifiers": "public static", "return": "int", "signature": "int findEndQuote(final byte[] array,  int index)", "full_signature": "public static int findEndQuote(final byte[] array,  int index)", "class_method_signature": "ByteScanner.findEndQuote(final byte[] array,  int index)", "testcase": false, "constructor": false}, {"identifier": "findEndQuoteUTF8", "parameters": "(final byte[] array,  int index)", "modifiers": "public static", "return": "int", "signature": "int findEndQuoteUTF8(final byte[] array,  int index)", "full_signature": "public static int findEndQuoteUTF8(final byte[] array,  int index)", "class_method_signature": "ByteScanner.findEndQuoteUTF8(final byte[] array,  int index)", "testcase": false, "constructor": false}, {"identifier": "skipUTF8NonCharOrLongChar", "parameters": "(final int c, int index)", "modifiers": "private static", "return": "int", "signature": "int skipUTF8NonCharOrLongChar(final int c, int index)", "full_signature": "private static int skipUTF8NonCharOrLongChar(final int c, int index)", "class_method_signature": "ByteScanner.skipUTF8NonCharOrLongChar(final int c, int index)", "testcase": false, "constructor": false}, {"identifier": "hasEscapeCharUTF8", "parameters": "(byte []array, int index, int[] indexHolder)", "modifiers": "public static", "return": "boolean", "signature": "boolean hasEscapeCharUTF8(byte []array, int index, int[] indexHolder)", "full_signature": "public static boolean hasEscapeCharUTF8(byte []array, int index, int[] indexHolder)", "class_method_signature": "ByteScanner.hasEscapeCharUTF8(byte []array, int index, int[] indexHolder)", "testcase": false, "constructor": false}], "file": "reflekt/src/main/java/io/advantageous/boon/primitive/ByteScanner.java"}, "focal_method": {"identifier": "split", "parameters": "( final byte[] inputArray,\n                                  final int split )", "modifiers": "public static", "return": "byte[][]", "body": "public static byte[][] split( final byte[] inputArray,\n                                  final int split ) {\n        /** Holds the results. */\n        byte[][] results = new byte[ 16 ][];\n\n        int resultIndex = 0;\n        int startCurrentLineIndex = 0;\n        int currentLineLength = 1;\n\n\n        byte c = '\\u0000';\n        int index = 0;\n\n        for (; index < inputArray.length; index++, currentLineLength++ ) {\n            c = inputArray[ index ];\n            if ( c == split ) {\n\n                if ( resultIndex == results.length ) {\n\n                    results = _grow( results );\n                }\n\n\n                results[ resultIndex ] = Byt.copy(\n                        inputArray, startCurrentLineIndex, currentLineLength - 1 );\n                startCurrentLineIndex = index + 1; //skip the byte\n\n                currentLineLength = 0;\n                resultIndex++;\n            }\n        }\n\n        if ( c != split ) {\n\n            results[ resultIndex ] = Byt.copy(\n                    inputArray, startCurrentLineIndex, currentLineLength - 1 );\n            resultIndex++;\n        }\n\n        int actualLength = resultIndex;\n        if ( actualLength < results.length ) {\n            final int newSize = results.length - actualLength;\n            results = __shrink( results, newSize );\n        }\n        return results;\n    }", "signature": "byte[][] split( final byte[] inputArray,\n                                  final int split )", "full_signature": "public static byte[][] split( final byte[] inputArray,\n                                  final int split )", "class_method_signature": "ByteScanner.split( final byte[] inputArray,\n                                  final int split )", "testcase": false, "constructor": false, "invocations": ["_grow", "copy", "copy", "__shrink"]}, "repository": {"repo_id": 33015857, "url": "https://github.com/advantageous/boon", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 18, "size": 6174, "license": "licensed"}}