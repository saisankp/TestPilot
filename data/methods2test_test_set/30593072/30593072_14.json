{"test_class": {"identifier": "ByteUtilTest", "superclass": "", "interfaces": "", "fields": [], "file": "nanofix-client/src/test/java/com/lmax/nanofix/byteoperations/ByteUtilTest.java"}, "test_case": {"identifier": "shouldOnlyAllowUsAscii", "parameters": "()", "modifiers": "@Test(expected = IllegalArgumentException.class) public", "return": "void", "body": "@Test(expected = IllegalArgumentException.class)\n        public void shouldOnlyAllowUsAscii()\n        {\n            final String testSequence = \"The \u00a3 symbol is not allowed in US-ASCII\";\n\n            final byte[] result = new byte[testSequence.length()];\n\n            ByteUtil.asciiEncode(testSequence, 0, result, 0, result.length);\n        }", "signature": "void shouldOnlyAllowUsAscii()", "full_signature": "@Test(expected = IllegalArgumentException.class) public void shouldOnlyAllowUsAscii()", "class_method_signature": "ByteUtilTest.shouldOnlyAllowUsAscii()", "testcase": true, "constructor": false, "invocations": ["length", "asciiEncode"]}, "focal_class": {"identifier": "ByteUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int MAX_UNSIGNED_SHORT = (1 << 16) - 1;", "modifier": "public static final", "type": "int", "declarator": "MAX_UNSIGNED_SHORT = (1 << 16) - 1", "var_name": "MAX_UNSIGNED_SHORT"}], "methods": [{"identifier": "writeLongAsAscii", "parameters": "(final byte[] outputBuffer, final int offset, final long valueParam)", "modifiers": "public static", "return": "void", "signature": "void writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam)", "full_signature": "public static void writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam)", "class_method_signature": "ByteUtil.writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam)", "testcase": false, "constructor": false}, {"identifier": "isAsciiDigit", "parameters": "(final byte asciiCharacter)", "modifiers": "public static", "return": "boolean", "signature": "boolean isAsciiDigit(final byte asciiCharacter)", "full_signature": "public static boolean isAsciiDigit(final byte asciiCharacter)", "class_method_signature": "ByteUtil.isAsciiDigit(final byte asciiCharacter)", "testcase": false, "constructor": false}, {"identifier": "formatIntAsIpAddress", "parameters": "(final int address)", "modifiers": "public static", "return": "String", "signature": "String formatIntAsIpAddress(final int address)", "full_signature": "public static String formatIntAsIpAddress(final int address)", "class_method_signature": "ByteUtil.formatIntAsIpAddress(final int address)", "testcase": false, "constructor": false}, {"identifier": "formatIntAsIpAddress", "parameters": "(final StringBuilder buffer, final int address)", "modifiers": "public static", "return": "void", "signature": "void formatIntAsIpAddress(final StringBuilder buffer, final int address)", "full_signature": "public static void formatIntAsIpAddress(final StringBuilder buffer, final int address)", "class_method_signature": "ByteUtil.formatIntAsIpAddress(final StringBuilder buffer, final int address)", "testcase": false, "constructor": false}, {"identifier": "packLongWithUnsignedShortInts", "parameters": "(final int int1, final int int2, final int int3, final int int4)", "modifiers": "public static", "return": "long", "signature": "long packLongWithUnsignedShortInts(final int int1, final int int2, final int int3, final int int4)", "full_signature": "public static long packLongWithUnsignedShortInts(final int int1, final int int2, final int int3, final int int4)", "class_method_signature": "ByteUtil.packLongWithUnsignedShortInts(final int int1, final int int2, final int int3, final int int4)", "testcase": false, "constructor": false}, {"identifier": "isEqual", "parameters": "(final byte[] lhs, final int lhsOffset, final byte[] rhs, final int rhsOffset, final int length)", "modifiers": "public static", "return": "boolean", "signature": "boolean isEqual(final byte[] lhs, final int lhsOffset, final byte[] rhs, final int rhsOffset, final int length)", "full_signature": "public static boolean isEqual(final byte[] lhs, final int lhsOffset, final byte[] rhs, final int rhsOffset, final int length)", "class_method_signature": "ByteUtil.isEqual(final byte[] lhs, final int lhsOffset, final byte[] rhs, final int rhsOffset, final int length)", "testcase": false, "constructor": false}, {"identifier": "readIntFromAscii", "parameters": "(final byte[] asciiBuffer, final int offset, final int length)", "modifiers": "public static", "return": "int", "signature": "int readIntFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "full_signature": "public static int readIntFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "class_method_signature": "ByteUtil.readIntFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "testcase": false, "constructor": false}, {"identifier": "readLongFromAscii", "parameters": "(final byte[] asciiBuffer, final int offset, final int length)", "modifiers": "public static", "return": "long", "signature": "long readLongFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "full_signature": "public static long readLongFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "class_method_signature": "ByteUtil.readLongFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "testcase": false, "constructor": false}, {"identifier": "isInteger", "parameters": "(final byte[] asciiBuffer, final int offset, final int length)", "modifiers": "public static", "return": "boolean", "signature": "boolean isInteger(final byte[] asciiBuffer, final int offset, final int length)", "full_signature": "public static boolean isInteger(final byte[] asciiBuffer, final int offset, final int length)", "class_method_signature": "ByteUtil.isInteger(final byte[] asciiBuffer, final int offset, final int length)", "testcase": false, "constructor": false}, {"identifier": "replace", "parameters": "(final byte[] buffer, final int offset, final int length,\n                               final byte target, final byte replacement)", "modifiers": "public static", "return": "void", "signature": "void replace(final byte[] buffer, final int offset, final int length,\n                               final byte target, final byte replacement)", "full_signature": "public static void replace(final byte[] buffer, final int offset, final int length,\n                               final byte target, final byte replacement)", "class_method_signature": "ByteUtil.replace(final byte[] buffer, final int offset, final int length,\n                               final byte target, final byte replacement)", "testcase": false, "constructor": false}, {"identifier": "asciiEncode", "parameters": "(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "modifiers": "public static", "return": "void", "signature": "void asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "full_signature": "public static void asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "class_method_signature": "ByteUtil.asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "testcase": false, "constructor": false}, {"identifier": "checkUnsignedShort", "parameters": "(final int value)", "modifiers": "private static", "return": "void", "signature": "void checkUnsignedShort(final int value)", "full_signature": "private static void checkUnsignedShort(final int value)", "class_method_signature": "ByteUtil.checkUnsignedShort(final int value)", "testcase": false, "constructor": false}], "file": "nanofix-client/src/main/java/com/lmax/nanofix/byteoperations/ByteUtil.java"}, "focal_method": {"identifier": "asciiEncode", "parameters": "(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "modifiers": "public static", "return": "void", "body": "public static void asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)\n    {\n        for (int i = 0; i < length; i++)\n        {\n            int charValue = chars.charAt(i + charOffset);\n\n            if (charValue > 127)\n            {\n                throw new IllegalArgumentException(\"Character \" + chars.charAt(i + charOffset) + \" is not \" + StandardCharsets.US_ASCII);\n            }\n\n            buffer[i + bufferOffset] = (byte) charValue;\n        }\n    }", "signature": "void asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "full_signature": "public static void asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "class_method_signature": "ByteUtil.asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "testcase": false, "constructor": false, "invocations": ["charAt", "charAt"]}, "repository": {"repo_id": 30593072, "url": "https://github.com/LMAX-Exchange/nanofix", "language": "Java", "is_fork": false, "fork_count": 18, "stargazer_count": 24, "size": 193, "license": "licensed"}}