{"test_class": {"identifier": "MesosClientTest", "superclass": "", "interfaces": "", "fields": [], "file": "mesos-rxjava-client/src/test/java/com/mesosphere/mesos/rx/java/MesosClientTest.java"}, "test_case": {"identifier": "testMesosStreamIdIsNotSavedForUnsuccessfulSubscribeCall", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMesosStreamIdIsNotSavedForUnsuccessfulSubscribeCall() throws Exception {\n        final AtomicReference<String> mesosStreamId = new AtomicReference<>(null);\n\n        final Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>> f = MesosClient.verifyResponseOk(\n            \"Subscribe\",\n            mesosStreamId,\n            StringMessageCodec.UTF8_STRING.mediaType()\n        );\n\n        final DefaultHttpResponse nettyResponse = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST);\n        nettyResponse.headers().add(\"Mesos-Stream-Id\", \"streamId\");\n        nettyResponse.headers().add(\"Content-Type\", StringMessageCodec.UTF8_STRING.mediaType());\n        final HttpClientResponse<ByteBuf> response = new HttpClientResponse<>(\n            nettyResponse,\n            UnicastContentSubject.create(1000, TimeUnit.MILLISECONDS)\n        );\n\n        try {\n            f.call(response);\n        } catch (Mesos4xxException e) {\n            // expected\n        }\n\n        assertThat(mesosStreamId.get()).isEqualTo(null);\n    }", "signature": "void testMesosStreamIdIsNotSavedForUnsuccessfulSubscribeCall()", "full_signature": "@Test public void testMesosStreamIdIsNotSavedForUnsuccessfulSubscribeCall()", "class_method_signature": "MesosClientTest.testMesosStreamIdIsNotSavedForUnsuccessfulSubscribeCall()", "testcase": true, "constructor": false, "invocations": ["verifyResponseOk", "mediaType", "add", "headers", "add", "headers", "mediaType", "create", "call", "isEqualTo", "assertThat", "get"]}, "focal_class": {"identifier": "MesosClient", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(MesosClient.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(MesosClient.class)", "var_name": "LOGGER"}, {"original_string": "private static final String MESOS_STREAM_ID = \"Mesos-Stream-Id\";", "modifier": "private static final", "type": "String", "declarator": "MESOS_STREAM_ID = \"Mesos-Stream-Id\"", "var_name": "MESOS_STREAM_ID"}, {"original_string": "@NotNull\n    private final ExecutorService exec = Executors.newSingleThreadExecutor(\n        new DefaultThreadFactory(\"stream-monitor-thread\", true)\n    );", "modifier": "@NotNull\n    private final", "type": "ExecutorService", "declarator": "exec = Executors.newSingleThreadExecutor(\n        new DefaultThreadFactory(\"stream-monitor-thread\", true)\n    )", "var_name": "exec"}, {"original_string": "@NotNull\n    private final URI mesosUri;", "modifier": "@NotNull\n    private final", "type": "URI", "declarator": "mesosUri", "var_name": "mesosUri"}, {"original_string": "@NotNull\n    private final MessageCodec<Receive> receiveCodec;", "modifier": "@NotNull\n    private final", "type": "MessageCodec<Receive>", "declarator": "receiveCodec", "var_name": "receiveCodec"}, {"original_string": "@NotNull\n    private final Send subscribe;", "modifier": "@NotNull\n    private final", "type": "Send", "declarator": "subscribe", "var_name": "subscribe"}, {"original_string": "@NotNull\n    private final Function<Observable<Receive>, Observable<Optional<SinkOperation<Send>>>> streamProcessor;", "modifier": "@NotNull\n    private final", "type": "Function<Observable<Receive>, Observable<Optional<SinkOperation<Send>>>>", "declarator": "streamProcessor", "var_name": "streamProcessor"}, {"original_string": "@NotNull\n    // @VisibleForTesting\n    final Func1<Send, Observable<HttpClientRequest<ByteBuf>>> createPost;", "modifier": "@NotNull\n    // @VisibleForTesting\n    final", "type": "Func1<Send, Observable<HttpClientRequest<ByteBuf>>>", "declarator": "createPost", "var_name": "createPost"}, {"original_string": "@NotNull\n    private final UserAgent userAgent;", "modifier": "@NotNull\n    private final", "type": "UserAgent", "declarator": "userAgent", "var_name": "userAgent"}, {"original_string": "@NotNull\n    private final AtomicReference<String> mesosStreamId = new AtomicReference<>(null);", "modifier": "@NotNull\n    private final", "type": "AtomicReference<String>", "declarator": "mesosStreamId = new AtomicReference<>(null)", "var_name": "mesosStreamId"}, {"original_string": "@NotNull\n    private final Observable.Transformer<byte[], byte[]> backpressureTransformer;", "modifier": "@NotNull\n    private final", "type": "Observable.Transformer<byte[], byte[]>", "declarator": "backpressureTransformer", "var_name": "backpressureTransformer"}], "methods": [{"identifier": "MesosClient", "parameters": "(\n        @NotNull final URI mesosUri,\n        @NotNull final Function<Class<?>, UserAgentEntry> applicationUserAgentEntry,\n        @NotNull final MessageCodec<Send> sendCodec,\n        @NotNull final MessageCodec<Receive> receiveCodec,\n        @NotNull final Send subscribe,\n        @NotNull final Function<Observable<Receive>, Observable<Optional<SinkOperation<Send>>>> streamProcessor,\n        @NotNull final  Observable.Transformer<byte[], byte[]> backpressureTransformer\n    )", "modifiers": "", "return": "", "signature": " MesosClient(\n        @NotNull final URI mesosUri,\n        @NotNull final Function<Class<?>, UserAgentEntry> applicationUserAgentEntry,\n        @NotNull final MessageCodec<Send> sendCodec,\n        @NotNull final MessageCodec<Receive> receiveCodec,\n        @NotNull final Send subscribe,\n        @NotNull final Function<Observable<Receive>, Observable<Optional<SinkOperation<Send>>>> streamProcessor,\n        @NotNull final  Observable.Transformer<byte[], byte[]> backpressureTransformer\n    )", "full_signature": "  MesosClient(\n        @NotNull final URI mesosUri,\n        @NotNull final Function<Class<?>, UserAgentEntry> applicationUserAgentEntry,\n        @NotNull final MessageCodec<Send> sendCodec,\n        @NotNull final MessageCodec<Receive> receiveCodec,\n        @NotNull final Send subscribe,\n        @NotNull final Function<Observable<Receive>, Observable<Optional<SinkOperation<Send>>>> streamProcessor,\n        @NotNull final  Observable.Transformer<byte[], byte[]> backpressureTransformer\n    )", "class_method_signature": "MesosClient.MesosClient(\n        @NotNull final URI mesosUri,\n        @NotNull final Function<Class<?>, UserAgentEntry> applicationUserAgentEntry,\n        @NotNull final MessageCodec<Send> sendCodec,\n        @NotNull final MessageCodec<Receive> receiveCodec,\n        @NotNull final Send subscribe,\n        @NotNull final Function<Observable<Receive>, Observable<Optional<SinkOperation<Send>>>> streamProcessor,\n        @NotNull final  Observable.Transformer<byte[], byte[]> backpressureTransformer\n    )", "testcase": false, "constructor": true}, {"identifier": "openStream", "parameters": "()", "modifiers": "@NotNull public", "return": "AwaitableSubscription", "signature": "AwaitableSubscription openStream()", "full_signature": "@NotNull public AwaitableSubscription openStream()", "class_method_signature": "MesosClient.openStream()", "testcase": false, "constructor": false}, {"identifier": "resolveMesosUri", "parameters": "(final @NotNull URI mesosUri)", "modifiers": "@NotNull private static", "return": "URI", "signature": "URI resolveMesosUri(final @NotNull URI mesosUri)", "full_signature": "@NotNull private static URI resolveMesosUri(final @NotNull URI mesosUri)", "class_method_signature": "MesosClient.resolveMesosUri(final @NotNull URI mesosUri)", "testcase": false, "constructor": false}, {"identifier": "getUriFromRedirectResponse", "parameters": "(final @NotNull URI mesosUri, @NotNull final HttpClientResponse<ByteBuf> redirectResponse)", "modifiers": "@NotNull // @VisibleForTesting static", "return": "URI", "signature": "URI getUriFromRedirectResponse(final @NotNull URI mesosUri, @NotNull final HttpClientResponse<ByteBuf> redirectResponse)", "full_signature": "@NotNull // @VisibleForTesting static URI getUriFromRedirectResponse(final @NotNull URI mesosUri, @NotNull final HttpClientResponse<ByteBuf> redirectResponse)", "class_method_signature": "MesosClient.getUriFromRedirectResponse(final @NotNull URI mesosUri, @NotNull final HttpClientResponse<ByteBuf> redirectResponse)", "testcase": false, "constructor": false}, {"identifier": "resolveRelativeUri", "parameters": "(final @NotNull URI mesosUri, final String location)", "modifiers": "@NotNull // @VisibleForTesting static", "return": "URI", "signature": "URI resolveRelativeUri(final @NotNull URI mesosUri, final String location)", "full_signature": "@NotNull // @VisibleForTesting static URI resolveRelativeUri(final @NotNull URI mesosUri, final String location)", "class_method_signature": "MesosClient.resolveRelativeUri(final @NotNull URI mesosUri, final String location)", "testcase": false, "constructor": false}, {"identifier": "createRedirectUri", "parameters": "(@NotNull final URI uri)", "modifiers": "@NotNull // @VisibleForTesting static", "return": "String", "signature": "String createRedirectUri(@NotNull final URI uri)", "full_signature": "@NotNull // @VisibleForTesting static String createRedirectUri(@NotNull final URI uri)", "class_method_signature": "MesosClient.createRedirectUri(@NotNull final URI uri)", "testcase": false, "constructor": false}, {"identifier": "verifyResponseOk", "parameters": "(\n        @NotNull final Send subscription,\n        @NotNull final AtomicReference<String> mesosStreamId,\n        @NotNull final String receiveMediaType\n    )", "modifiers": "@NotNull // @VisibleForTesting static", "return": "Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>>", "signature": "Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>> verifyResponseOk(\n        @NotNull final Send subscription,\n        @NotNull final AtomicReference<String> mesosStreamId,\n        @NotNull final String receiveMediaType\n    )", "full_signature": "@NotNull // @VisibleForTesting static Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>> verifyResponseOk(\n        @NotNull final Send subscription,\n        @NotNull final AtomicReference<String> mesosStreamId,\n        @NotNull final String receiveMediaType\n    )", "class_method_signature": "MesosClient.verifyResponseOk(\n        @NotNull final Send subscription,\n        @NotNull final AtomicReference<String> mesosStreamId,\n        @NotNull final String receiveMediaType\n    )", "testcase": false, "constructor": false}, {"identifier": "getPort", "parameters": "(@NotNull final URI uri)", "modifiers": "static", "return": "int", "signature": "int getPort(@NotNull final URI uri)", "full_signature": "static int getPort(@NotNull final URI uri)", "class_method_signature": "MesosClient.getPort(@NotNull final URI uri)", "testcase": false, "constructor": false}, {"identifier": "curryCreatePost", "parameters": "(\n        @NotNull final URI mesosUri,\n        @NotNull final MessageCodec<Send> sendCodec,\n        @NotNull final MessageCodec<Receive> receiveCodec,\n        @NotNull final UserAgent userAgent,\n        @NotNull final AtomicReference<String> mesosStreamId\n    )", "modifiers": "@NotNull // @VisibleForTesting static", "return": "Func1<Send, Observable<HttpClientRequest<ByteBuf>>>", "signature": "Func1<Send, Observable<HttpClientRequest<ByteBuf>>> curryCreatePost(\n        @NotNull final URI mesosUri,\n        @NotNull final MessageCodec<Send> sendCodec,\n        @NotNull final MessageCodec<Receive> receiveCodec,\n        @NotNull final UserAgent userAgent,\n        @NotNull final AtomicReference<String> mesosStreamId\n    )", "full_signature": "@NotNull // @VisibleForTesting static Func1<Send, Observable<HttpClientRequest<ByteBuf>>> curryCreatePost(\n        @NotNull final URI mesosUri,\n        @NotNull final MessageCodec<Send> sendCodec,\n        @NotNull final MessageCodec<Receive> receiveCodec,\n        @NotNull final UserAgent userAgent,\n        @NotNull final AtomicReference<String> mesosStreamId\n    )", "class_method_signature": "MesosClient.curryCreatePost(\n        @NotNull final URI mesosUri,\n        @NotNull final MessageCodec<Send> sendCodec,\n        @NotNull final MessageCodec<Receive> receiveCodec,\n        @NotNull final UserAgent userAgent,\n        @NotNull final AtomicReference<String> mesosStreamId\n    )", "testcase": false, "constructor": false}], "file": "mesos-rxjava-client/src/main/java/com/mesosphere/mesos/rx/java/MesosClient.java"}, "focal_method": {"identifier": "verifyResponseOk", "parameters": "(\n        @NotNull final Send subscription,\n        @NotNull final AtomicReference<String> mesosStreamId,\n        @NotNull final String receiveMediaType\n    )", "modifiers": "@NotNull // @VisibleForTesting static", "return": "Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>>", "body": "@NotNull\n    // @VisibleForTesting\n    static <Send> Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>> verifyResponseOk(\n        @NotNull final Send subscription,\n        @NotNull final AtomicReference<String> mesosStreamId,\n        @NotNull final String receiveMediaType\n    ) {\n        return resp -> {\n            final HttpResponseStatus status = resp.getStatus();\n            final int code = status.code();\n\n            final String contentType = resp.getHeaders().get(HttpHeaderNames.CONTENT_TYPE);\n            if (code == 200 && receiveMediaType.equals(contentType)) {\n                if (resp.getHeaders().contains(MESOS_STREAM_ID)) {\n                    final String streamId = resp.getHeaders().get(MESOS_STREAM_ID);\n                    mesosStreamId.compareAndSet(null, streamId);\n                }\n                return resp.getContent();\n            } else {\n                final HttpResponseHeaders headers = resp.getHeaders();\n                return ResponseUtils.attemptToReadErrorResponse(resp).flatMap(msg -> {\n                    final List<Map.Entry<String, String>> entries = headers.entries();\n                    final MesosClientErrorContext context = new MesosClientErrorContext(code, msg, entries);\n                    if (code == 200) {\n                        // this means that even though we got back a 200 it's not the sort of response we were expecting\n                        // For example hitting an endpoint that returns an html document instead of a document of type\n                        // `receiveMediaType`\n                        throw new MesosException(\n                            subscription,\n                            context.withMessage(\n                                String.format(\n                                    \"Response had Content-Type \\\"%s\\\" expected \\\"%s\\\"\",\n                                    contentType,\n                                    receiveMediaType\n                                )\n                            )\n                        );\n                    } else if (400 <= code && code < 500) {\n                        throw new Mesos4xxException(subscription, context);\n                    } else if (500 <= code && code < 600) {\n                        throw new Mesos5xxException(subscription, context);\n                    } else {\n                        LOGGER.warn(\"Unhandled error: context = {}\", context);\n                        // This shouldn't actually ever happen, but it's here for completeness of the if-else tree\n                        // that always has to result in an exception being thrown so the compiler is okay with this\n                        // lambda\n                        throw new IllegalStateException(\"Unhandled error\");\n                    }\n                });\n            }\n        };\n    }", "signature": "Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>> verifyResponseOk(\n        @NotNull final Send subscription,\n        @NotNull final AtomicReference<String> mesosStreamId,\n        @NotNull final String receiveMediaType\n    )", "full_signature": "@NotNull // @VisibleForTesting static Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>> verifyResponseOk(\n        @NotNull final Send subscription,\n        @NotNull final AtomicReference<String> mesosStreamId,\n        @NotNull final String receiveMediaType\n    )", "class_method_signature": "MesosClient.verifyResponseOk(\n        @NotNull final Send subscription,\n        @NotNull final AtomicReference<String> mesosStreamId,\n        @NotNull final String receiveMediaType\n    )", "testcase": false, "constructor": false, "invocations": ["getStatus", "code", "get", "getHeaders", "equals", "contains", "getHeaders", "get", "getHeaders", "compareAndSet", "getContent", "getHeaders", "flatMap", "attemptToReadErrorResponse", "entries", "withMessage", "format", "warn"]}, "repository": {"repo_id": 44835755, "url": "https://github.com/mesosphere/mesos-rxjava", "language": "Java", "is_fork": false, "fork_count": 25, "stargazer_count": 40, "size": 666, "license": "licensed"}}