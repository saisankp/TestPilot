{"test_class": {"identifier": "TestSchemaMetaDataManager", "superclass": "", "interfaces": "", "fields": [], "file": "databus-util-cmdline/databus-util-cmdline-impl/src/test/java/com/linkedin/databus/util/TestSchemaMetaDataManager.java"}, "test_case": {"identifier": "testSchemaMetaDataManager", "parameters": "()", "modifiers": "@Test /** * Steps: * 1. Construct a Schema-registry directory with expected meta-files for some example sources and have a backup. * 2. Instantiate a SchemaMetaDataManager * 3. Call public getter APIs to fetch srcIds and sourceNames and validate they are expected. * 4. Call store() and ensure the persisted matches with the backup. * 5. Add a new source. Validate the new sourceId is expected. * 6. Call public getter APIs to fetch srcIds and sourceNames and validate they are expected. * * @throws Exception */ public", "return": "void", "body": "@Test\n  /**\n   * Steps:\n   * 1. Construct a Schema-registry directory with expected meta-files for some example sources and have a backup.\n   * 2. Instantiate a SchemaMetaDataManager\n   * 3. Call public getter APIs to fetch srcIds and sourceNames and validate they are expected.\n   * 4. Call store() and ensure the persisted matches with the backup.\n   * 5. Add a new source. Validate the new sourceId is expected.\n   * 6. Call public getter APIs to fetch srcIds and sourceNames and validate they are expected.\n   *\n   * @throws Exception\n   */\n  public void testSchemaMetaDataManager() throws Exception\n  {\n    File schema_dir = FileUtils.createTempDir(\"dir_testSchemaMetaDataManager\");\n\n    // Input contents\n    String[] idNameMapContents = {\n                                  \"1:com.linkedin.events.example.person\",\n                                  \"2:com.linkedin.events.example.address\",\n                                  \"3:com.linkedin.events.example.date\",\n                                  \"10:com.linkedin.events.another_example.zipcode\",\n                                 };\n\n    String[] dbToSrcMapContents = { \"{\",\n                                   \"  \\\"another_example\\\" : [ \\\"com.linkedin.events.another_example.zipcode\\\" ],\",\n                                   \"  \\\"example\\\" : [ \\\"com.linkedin.events.example.address\\\", \\\"com.linkedin.events.example.date\\\", \\\"com.linkedin.events.example.person\\\" ]\",\n                                   \"}\"\n                                 };\n\n    String dbToSrcFile1 = schema_dir.getAbsolutePath() + \"/physical_logical_src_map.json\";\n    String idNameMapFile1 = schema_dir.getAbsolutePath() + \"/idToName.map\";\n    FileUtils.storeLinesToTempFile(dbToSrcFile1,dbToSrcMapContents);\n    FileUtils.storeLinesToTempFile(idNameMapFile1, idNameMapContents);\n\n    File newSchemaDir = FileUtils.createTempDir(\"dir_testSchemaMetaDataManager_backup\");\n    String dbToSrcFile2 = newSchemaDir.getAbsolutePath() + \"/physical_logical_src_map.json\";\n    String idNameMapFile2 = newSchemaDir.getAbsolutePath() + \"/idToName.map\";\n    Runtime.getRuntime().exec(\"cp \" + dbToSrcFile1 + \" \" + dbToSrcFile2 );\n    Runtime.getRuntime().exec(\"cp \" + idNameMapFile1 + \" \" + idNameMapFile2 );\n    SchemaMetaDataManager mgr = new SchemaMetaDataManager(schema_dir.getAbsolutePath());\n\n    //Validate Managed Sources\n    List<String> sources = mgr.getManagedSourcesForDB(\"another_example\");\n    Assert.assertEquals( sources.size(), 1, \"Number of Sources\");\n    Assert.assertEquals(sources.get(0),\"com.linkedin.events.another_example.zipcode\",\"Number of Sources\");\n    sources = mgr.getManagedSourcesForDB(\"example\");\n    Assert.assertEquals(sources.size(),3, \"Number of Sources\");\n    Assert.assertEquals( sources.get(0), \"com.linkedin.events.example.person\", \"Source 1\");\n    Assert.assertEquals( sources.get(1), \"com.linkedin.events.example.address\", \"Source 2\");\n    Assert.assertEquals( sources.get(2), \"com.linkedin.events.example.date\",\"Source 3\");\n    Assert.assertNull(mgr.getManagedSourcesForDB(\"unknown_source\"),\"Unknown Source\");\n\n    //Validate getSrcId\n    Assert.assertEquals( mgr.getSrcId(\"com.linkedin.events.another_example.zipcode\"),10,\"ZipCode SrcId\");\n    Assert.assertEquals( mgr.getSrcId(\"com.linkedin.events.example.person\"),1, \"Person SrcId\");\n    Assert.assertEquals( mgr.getSrcId(\"com.linkedin.events.example.address\"), 2, \"Address SrcId\");\n    Assert.assertEquals( mgr.getSrcId(\"com.linkedin.events.example.date\"),3, \"Date SrcId\");\n\n    //unknown SrcName\n    boolean exception = false;\n    try\n    {\n      mgr.getSrcId(\"Unknown SrcId\");\n    } catch (RuntimeException re) {\n      exception = true;\n    }\n    Assert.assertTrue(exception, \"Got exception ?\");\n\n    //Store to meta-files and compare to expected files.\n    mgr.store();\n    FileUtils.compareTwoTextFiles(dbToSrcFile1, dbToSrcFile2);\n    FileUtils.compareTwoTextFiles(idNameMapFile1, idNameMapFile2);\n\n    // Adding new source\n    short srcId = mgr.updateAndGetNewSrcId(\"another_example\", \"com.linkedin.events.another_example.city\");\n    Assert.assertEquals(srcId,11,\"New SrcId \");\n    sources = mgr.getManagedSourcesForDB(\"another_example\");\n    Assert.assertEquals( sources.size(), 2, \"Number of Sources\");\n    Assert.assertEquals(sources.get(0),\"com.linkedin.events.another_example.zipcode\",\"Zipcode Sources\");\n    Assert.assertEquals(sources.get(1),\"com.linkedin.events.another_example.city\",\"City Source \");\n    Assert.assertEquals( mgr.getSrcId(\"com.linkedin.events.another_example.city\"),11,\"City SrcId\");\n    sources = mgr.getManagedSourcesForDB(\"example\");\n    Assert.assertEquals(sources.size(),3, \"Number of Sources\");\n    Assert.assertEquals( sources.get(0), \"com.linkedin.events.example.person\", \"Source 1\");\n    Assert.assertEquals( sources.get(1), \"com.linkedin.events.example.address\", \"Source 2\");\n    Assert.assertEquals( sources.get(2), \"com.linkedin.events.example.date\",\"Source 3\");\n    Assert.assertNull(mgr.getManagedSourcesForDB(\"unknown_source\"),\"Unknown Source\");\n\n    System.out.println(mgr.getDbToSrcMap());\n  }", "signature": "void testSchemaMetaDataManager()", "full_signature": "@Test /** * Steps: * 1. Construct a Schema-registry directory with expected meta-files for some example sources and have a backup. * 2. Instantiate a SchemaMetaDataManager * 3. Call public getter APIs to fetch srcIds and sourceNames and validate they are expected. * 4. Call store() and ensure the persisted matches with the backup. * 5. Add a new source. Validate the new sourceId is expected. * 6. Call public getter APIs to fetch srcIds and sourceNames and validate they are expected. * * @throws Exception */ public void testSchemaMetaDataManager()", "class_method_signature": "TestSchemaMetaDataManager.testSchemaMetaDataManager()", "testcase": true, "constructor": false, "invocations": ["createTempDir", "getAbsolutePath", "getAbsolutePath", "storeLinesToTempFile", "storeLinesToTempFile", "createTempDir", "getAbsolutePath", "getAbsolutePath", "exec", "getRuntime", "exec", "getRuntime", "getAbsolutePath", "getManagedSourcesForDB", "assertEquals", "size", "assertEquals", "get", "getManagedSourcesForDB", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertNull", "getManagedSourcesForDB", "assertEquals", "getSrcId", "assertEquals", "getSrcId", "assertEquals", "getSrcId", "assertEquals", "getSrcId", "getSrcId", "assertTrue", "store", "compareTwoTextFiles", "compareTwoTextFiles", "updateAndGetNewSrcId", "assertEquals", "getManagedSourcesForDB", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "assertEquals", "getSrcId", "getManagedSourcesForDB", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertNull", "getManagedSourcesForDB", "println", "getDbToSrcMap"]}, "focal_class": {"identifier": "SchemaMetaDataManager", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Short _maxSrcId = -1;", "modifier": "private", "type": "Short", "declarator": "_maxSrcId = -1", "var_name": "_maxSrcId"}, {"original_string": "private SourceIdNameRegistry _idNameRegistry = new SourceIdNameRegistry();", "modifier": "private", "type": "SourceIdNameRegistry", "declarator": "_idNameRegistry = new SourceIdNameRegistry()", "var_name": "_idNameRegistry"}, {"original_string": "private Map<String, TreeSet<String>> _physicalToLogicalSrcMap = null;", "modifier": "private", "type": "Map<String, TreeSet<String>>", "declarator": "_physicalToLogicalSrcMap = null", "var_name": "_physicalToLogicalSrcMap"}, {"original_string": "private final String _idNameMapFile;", "modifier": "private final", "type": "String", "declarator": "_idNameMapFile", "var_name": "_idNameMapFile"}, {"original_string": "private final String _physicalToLogicalSrcMapFile;", "modifier": "private final", "type": "String", "declarator": "_physicalToLogicalSrcMapFile", "var_name": "_physicalToLogicalSrcMapFile"}, {"original_string": "public static final String SRC_ID_NAME_MAP_FILE =  \"idToName.map\";", "modifier": "public static final", "type": "String", "declarator": "SRC_ID_NAME_MAP_FILE =  \"idToName.map\"", "var_name": "SRC_ID_NAME_MAP_FILE"}, {"original_string": "public static final String PHYSICAL_TO_LOGICAL_SRC_MAP_FILE =  \"physical_logical_src_map.json\";", "modifier": "public static final", "type": "String", "declarator": "PHYSICAL_TO_LOGICAL_SRC_MAP_FILE =  \"physical_logical_src_map.json\"", "var_name": "PHYSICAL_TO_LOGICAL_SRC_MAP_FILE"}], "methods": [{"identifier": "SchemaMetaDataManager", "parameters": "(String schemaRegistryLocation)", "modifiers": "public", "return": "", "signature": " SchemaMetaDataManager(String schemaRegistryLocation)", "full_signature": "public  SchemaMetaDataManager(String schemaRegistryLocation)", "class_method_signature": "SchemaMetaDataManager.SchemaMetaDataManager(String schemaRegistryLocation)", "testcase": false, "constructor": true}, {"identifier": "store", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void store()", "full_signature": "public void store()", "class_method_signature": "SchemaMetaDataManager.store()", "testcase": false, "constructor": false}, {"identifier": "populatePhysicalToLogicalSrcMap", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void populatePhysicalToLogicalSrcMap()", "full_signature": "private void populatePhysicalToLogicalSrcMap()", "class_method_signature": "SchemaMetaDataManager.populatePhysicalToLogicalSrcMap()", "testcase": false, "constructor": false}, {"identifier": "persistPhysicalToLogicalSrcMap", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void persistPhysicalToLogicalSrcMap()", "full_signature": "private void persistPhysicalToLogicalSrcMap()", "class_method_signature": "SchemaMetaDataManager.persistPhysicalToLogicalSrcMap()", "testcase": false, "constructor": false}, {"identifier": "populateSrcNameIdMap", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void populateSrcNameIdMap()", "full_signature": "private void populateSrcNameIdMap()", "class_method_signature": "SchemaMetaDataManager.populateSrcNameIdMap()", "testcase": false, "constructor": false}, {"identifier": "persistSrcNameIdMap", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void persistSrcNameIdMap()", "full_signature": "private void persistSrcNameIdMap()", "class_method_signature": "SchemaMetaDataManager.persistSrcNameIdMap()", "testcase": false, "constructor": false}, {"identifier": "updateAndGetNewSrcId", "parameters": "(String dbName, String srcName)", "modifiers": "public", "return": "short", "signature": "short updateAndGetNewSrcId(String dbName, String srcName)", "full_signature": "public short updateAndGetNewSrcId(String dbName, String srcName)", "class_method_signature": "SchemaMetaDataManager.updateAndGetNewSrcId(String dbName, String srcName)", "testcase": false, "constructor": false}, {"identifier": "getManagedSourcesForDB", "parameters": "(String db)", "modifiers": "public", "return": "List<String>", "signature": "List<String> getManagedSourcesForDB(String db)", "full_signature": "public List<String> getManagedSourcesForDB(String db)", "class_method_signature": "SchemaMetaDataManager.getManagedSourcesForDB(String db)", "testcase": false, "constructor": false}, {"identifier": "getSrcId", "parameters": "(String srcName)", "modifiers": "public", "return": "short", "signature": "short getSrcId(String srcName)", "full_signature": "public short getSrcId(String srcName)", "class_method_signature": "SchemaMetaDataManager.getSrcId(String srcName)", "testcase": false, "constructor": false}, {"identifier": "getDbToSrcMap", "parameters": "()", "modifiers": "public", "return": "Map<String, TreeSet<String>>", "signature": "Map<String, TreeSet<String>> getDbToSrcMap()", "full_signature": "public Map<String, TreeSet<String>> getDbToSrcMap()", "class_method_signature": "SchemaMetaDataManager.getDbToSrcMap()", "testcase": false, "constructor": false}], "file": "databus-util-cmdline/databus-util-cmdline-impl/src/main/java/com/linkedin/databus/util/SchemaMetaDataManager.java"}, "focal_method": {"identifier": "SchemaMetaDataManager", "parameters": "(String schemaRegistryLocation)", "modifiers": "public", "return": "", "body": "public SchemaMetaDataManager(String schemaRegistryLocation) throws IOException\n  {\n    _idNameMapFile = schemaRegistryLocation + \"/\" +  SRC_ID_NAME_MAP_FILE;\n    _physicalToLogicalSrcMapFile = schemaRegistryLocation + \"/\" + PHYSICAL_TO_LOGICAL_SRC_MAP_FILE;\n    populatePhysicalToLogicalSrcMap();\n    populateSrcNameIdMap();\n  }", "signature": " SchemaMetaDataManager(String schemaRegistryLocation)", "full_signature": "public  SchemaMetaDataManager(String schemaRegistryLocation)", "class_method_signature": "SchemaMetaDataManager.SchemaMetaDataManager(String schemaRegistryLocation)", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 7209229, "url": "https://github.com/linkedin/databus", "language": "Java", "is_fork": false, "fork_count": 653, "stargazer_count": 2899, "size": 51191, "license": "licensed"}}