{"test_class": {"identifier": "PathResolverTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Path tempDir;", "modifier": "private", "type": "Path", "declarator": "tempDir", "var_name": "tempDir"}, {"original_string": "private static final FileAttribute fileAttribute = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwxr-x---\"));", "modifier": "private static final", "type": "FileAttribute", "declarator": "fileAttribute = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwxr-x---\"))", "var_name": "fileAttribute"}], "file": "aesh/src/test/java/org/aesh/io/PathResolverTest.java"}, "test_case": {"identifier": "testWildcards", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testWildcards() throws IOException {\n        File tmp = tempDir.toFile();\n        File child1 = new File(tempDir + Config.getPathSeparator()+\"child1\");\n        File child2 = new File(tempDir + Config.getPathSeparator()+\"child2\");\n        File child3 = new File(tempDir + Config.getPathSeparator()+\"child3\");\n\n        if(Config.isOSPOSIXCompatible()) {\n            Files.createDirectory(child1.toPath(), fileAttribute).toFile().deleteOnExit();\n            Files.createDirectory(child2.toPath(), fileAttribute).toFile().deleteOnExit();\n            Files.createDirectory(child3.toPath(), fileAttribute).toFile().deleteOnExit();\n        }\n        else {\n            Files.createDirectory(child1.toPath()).toFile().deleteOnExit();\n            Files.createDirectory(child2.toPath()).toFile().deleteOnExit();\n            Files.createDirectory(child3.toPath()).toFile().deleteOnExit();\n        }\n\n        List<File> files = PathResolver.resolvePath(new File(\"*\"), tmp);\n\n        assertEquals(1, files.size());\n    }", "signature": "void testWildcards()", "full_signature": "@Test public void testWildcards()", "class_method_signature": "PathResolverTest.testWildcards()", "testcase": true, "constructor": false, "invocations": ["toFile", "getPathSeparator", "getPathSeparator", "getPathSeparator", "isOSPOSIXCompatible", "deleteOnExit", "toFile", "createDirectory", "toPath", "deleteOnExit", "toFile", "createDirectory", "toPath", "deleteOnExit", "toFile", "createDirectory", "toPath", "deleteOnExit", "toFile", "createDirectory", "toPath", "deleteOnExit", "toFile", "createDirectory", "toPath", "deleteOnExit", "toFile", "createDirectory", "toPath", "resolvePath", "assertEquals", "size"]}, "focal_class": {"identifier": "PathResolver", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final char SEPARATOR = Config.getPathSeparator().charAt(0);", "modifier": "private static final", "type": "char", "declarator": "SEPARATOR = Config.getPathSeparator().charAt(0)", "var_name": "SEPARATOR"}, {"original_string": "private static final char TILDE = '~';", "modifier": "private static final", "type": "char", "declarator": "TILDE = '~'", "var_name": "TILDE"}, {"original_string": "private static final String TILDE_WITH_SEPARATOR = \"~\"+Config.getPathSeparator();", "modifier": "private static final", "type": "String", "declarator": "TILDE_WITH_SEPARATOR = \"~\"+Config.getPathSeparator()", "var_name": "TILDE_WITH_SEPARATOR"}, {"original_string": "private static final char STAR = '*';", "modifier": "private static final", "type": "char", "declarator": "STAR = '*'", "var_name": "STAR"}, {"original_string": "private static final char WILDCARD = '?';", "modifier": "private static final", "type": "char", "declarator": "WILDCARD = '?'", "var_name": "WILDCARD"}, {"original_string": "private static final String PARENT = \"..\";", "modifier": "private static final", "type": "String", "declarator": "PARENT = \"..\"", "var_name": "PARENT"}, {"original_string": "private static final String PARENT_WITH_SEPARATOR = \"..\"+ Config.getPathSeparator();", "modifier": "private static final", "type": "String", "declarator": "PARENT_WITH_SEPARATOR = \"..\"+ Config.getPathSeparator()", "var_name": "PARENT_WITH_SEPARATOR"}, {"original_string": "private static final String ROOT = Config.getPathSeparator();", "modifier": "private static final", "type": "String", "declarator": "ROOT = Config.getPathSeparator()", "var_name": "ROOT"}, {"original_string": "private static final String DRIVER_SEPARATOR = \":\";", "modifier": "private static final", "type": "String", "declarator": "DRIVER_SEPARATOR = \":\"", "var_name": "DRIVER_SEPARATOR"}, {"original_string": "private static final String CURRENT_WITH_SEPARATOR = \".\"+Config.getPathSeparator();", "modifier": "private static final", "type": "String", "declarator": "CURRENT_WITH_SEPARATOR = \".\"+Config.getPathSeparator()", "var_name": "CURRENT_WITH_SEPARATOR"}, {"original_string": "private static final String SEPARATOR_WITH_CURRENT = Config.getPathSeparator()+\".\";", "modifier": "private static final", "type": "String", "declarator": "SEPARATOR_WITH_CURRENT = Config.getPathSeparator()+\".\"", "var_name": "SEPARATOR_WITH_CURRENT"}, {"original_string": "private static final String SEPARATOR_CURRENT_SEPARATOR = Config.getPathSeparator()+\".\"+Config.getPathSeparator();", "modifier": "private static final", "type": "String", "declarator": "SEPARATOR_CURRENT_SEPARATOR = Config.getPathSeparator()+\".\"+Config.getPathSeparator()", "var_name": "SEPARATOR_CURRENT_SEPARATOR"}, {"original_string": "private static final String CURRENT = \".\";", "modifier": "private static final", "type": "String", "declarator": "CURRENT = \".\"", "var_name": "CURRENT"}, {"original_string": "private static final Pattern starPattern = Pattern.compile(\"[\\\\*]+\");", "modifier": "private static final", "type": "Pattern", "declarator": "starPattern = Pattern.compile(\"[\\\\*]+\")", "var_name": "starPattern"}], "methods": [{"identifier": "resolvePath", "parameters": "(File incPath, File cwd)", "modifiers": "@SuppressWarnings(\"IndexOfReplaceableByContains\") public static", "return": "List<File>", "signature": "List<File> resolvePath(File incPath, File cwd)", "full_signature": "@SuppressWarnings(\"IndexOfReplaceableByContains\") public static List<File> resolvePath(File incPath, File cwd)", "class_method_signature": "PathResolver.resolvePath(File incPath, File cwd)", "testcase": false, "constructor": false}, {"identifier": "parseWildcard", "parameters": "(File incPath)", "modifiers": "private static", "return": "List<File>", "signature": "List<File> parseWildcard(File incPath)", "full_signature": "private static List<File> parseWildcard(File incPath)", "class_method_signature": "PathResolver.parseWildcard(File incPath)", "testcase": false, "constructor": false}, {"identifier": "findFiles", "parameters": "(File incPath, String searchArgument, boolean findDirectory)", "modifiers": "private static", "return": "List<File>", "signature": "List<File> findFiles(File incPath, String searchArgument, boolean findDirectory)", "full_signature": "private static List<File> findFiles(File incPath, String searchArgument, boolean findDirectory)", "class_method_signature": "PathResolver.findFiles(File incPath, String searchArgument, boolean findDirectory)", "testcase": false, "constructor": false}, {"identifier": "parsePath", "parameters": "(File path)", "modifiers": "private static", "return": "PathCriteria", "signature": "PathCriteria parsePath(File path)", "full_signature": "private static PathCriteria parsePath(File path)", "class_method_signature": "PathResolver.parsePath(File path)", "testcase": false, "constructor": false}], "file": "aesh/src/main/java/org/aesh/io/PathResolver.java"}, "focal_method": {"identifier": "resolvePath", "parameters": "(File incPath, File cwd)", "modifiers": "@SuppressWarnings(\"IndexOfReplaceableByContains\") public static", "return": "List<File>", "body": "@SuppressWarnings(\"IndexOfReplaceableByContains\")\n    public static List<File> resolvePath(File incPath, File cwd) {\n        if(cwd == null)\n            cwd = new File(Config.getHomeDir());\n\n        //if incPath start with eg: ./, remove it\n        if(incPath.toString().startsWith(CURRENT_WITH_SEPARATOR)) {\n            incPath = new File(incPath.toString().substring(CURRENT_WITH_SEPARATOR.length()));\n        }\n\n        if(incPath.toString().startsWith(TILDE_WITH_SEPARATOR)) {\n            if(Config.getHomeDir().endsWith(Config.getPathSeparator()))\n                incPath = new File(Config.getHomeDir()+incPath.toString().substring(2));\n            else\n                incPath = new File(Config.getHomeDir()+incPath.toString().substring(1));\n        }\n\n        if(incPath.toString().indexOf(TILDE) == 0) {\n            if(incPath.toString().length() > 1) {\n                // directories which name starts with tilde\n                incPath = new File(cwd.toString() + Config.getPathSeparator() + incPath.toString());\n            } else {\n                incPath = new File(Config.getHomeDir());\n            }\n        }\n\n        //  foo1/./foo2 is changed to foo1/foo2\n        if(incPath.toString().indexOf(SEPARATOR_CURRENT_SEPARATOR) > -1) {\n            int index = incPath.toString().indexOf(SEPARATOR_CURRENT_SEPARATOR);\n            if(index == 0) {\n                incPath = new File(incPath.toString().substring(SEPARATOR_CURRENT_SEPARATOR.length()-1));\n            }\n            else {\n                incPath = new File(incPath.toString().substring(0, index) +\n                        incPath.toString().substring(index+2, incPath.toString().length()));\n            }\n        }\n\n        //parentPath do not start with / or by a windows driver letter and cwd is not / either\n        if( incPath.toString().indexOf(ROOT) != 0 && incPath.toString().indexOf(DRIVER_SEPARATOR) == -1 && !cwd.toString().equals(ROOT)) {\n            if(cwd.toString().endsWith(Config.getPathSeparator()))\n                incPath = new File(cwd.toString() + incPath.toString());\n            else\n                incPath = new File(cwd.toString() + Config.getPathSeparator() + incPath.toString());\n        }\n\n        if(incPath.toString().indexOf(PARENT_WITH_SEPARATOR) > -1) {\n            String tmp = incPath.toString();\n            while(tmp.indexOf(PARENT_WITH_SEPARATOR) > -1) {\n                int index = tmp.indexOf(PARENT_WITH_SEPARATOR);\n                if(index == 0) {\n                    tmp = tmp.substring(PARENT_WITH_SEPARATOR.length());\n                }\n                else {\n                    File tmpFile = new File(tmp.substring(0, index));\n                    tmpFile = tmpFile.getParentFile();\n                    if(tmpFile == null)\n                        tmpFile = new File(Config.getPathSeparator());\n                    tmpFile = new File(tmpFile.toString() + tmp.substring(index+ PARENT_WITH_SEPARATOR.length()-1));\n                    //tmp = tmp.substring(0, index) + tmp.substring(index+PARENT_WITH_SEPARATOR.length());\n                    tmp = tmpFile.toString();\n                }\n            }\n            incPath = new File(tmp);\n        }\n\n        if(incPath.toString().endsWith(PARENT)) {\n            incPath = new File(incPath.toString().substring(0, incPath.toString().length()-PARENT.length()));\n            incPath = incPath.getParentFile();\n            if(incPath == null)\n                incPath = new File(Config.getPathSeparator());\n        }\n\n        if( incPath.toString().indexOf(STAR) > -1 || incPath.toString().indexOf(WILDCARD) > -1) {\n            PathCriteria pathCriteria = parsePath(incPath);\n            if(incPath.toString().indexOf(SEPARATOR) > -1) {\n                List<File> foundFiles  = null;\n                if(pathCriteria.getCriteria().equals(String.valueOf(STAR))) {\n                    foundFiles = new ArrayList<>();\n                    foundFiles.add(new File(pathCriteria.getParentPath()));\n                }\n                else\n                    foundFiles = findFiles(new File(pathCriteria.parentPath), pathCriteria.getCriteria(), false);\n                if(pathCriteria.childPath.length() == 0)\n                    return foundFiles;\n                else {\n                    List<File> outFiles = new ArrayList<>();\n                    for(File f : foundFiles)\n                        if(new File(f+Config.getPathSeparator()+pathCriteria.childPath).exists())\n                            outFiles.add(new File(f+Config.getPathSeparator()+pathCriteria.childPath));\n\n                    return outFiles;\n                }\n            }\n            //just wildcard without separators\n            else {\n                if(incPath.toString().length() == 1) {\n                    List<File> foundFiles = findFiles(new File(pathCriteria.parentPath), pathCriteria.getCriteria(), false);\n                    if(pathCriteria.childPath.length() == 0)\n                        return foundFiles;\n                }\n\n                return new ArrayList<File>();\n            }\n        }\n        else {\n            //no wildcards\n            ArrayList<File> fileList = new ArrayList<>(1);\n            fileList.add(incPath);\n            return fileList;\n        }\n    }", "signature": "List<File> resolvePath(File incPath, File cwd)", "full_signature": "@SuppressWarnings(\"IndexOfReplaceableByContains\") public static List<File> resolvePath(File incPath, File cwd)", "class_method_signature": "PathResolver.resolvePath(File incPath, File cwd)", "testcase": false, "constructor": false, "invocations": ["getHomeDir", "startsWith", "toString", "substring", "toString", "length", "startsWith", "toString", "endsWith", "getHomeDir", "getPathSeparator", "getHomeDir", "substring", "toString", "getHomeDir", "substring", "toString", "indexOf", "toString", "length", "toString", "toString", "getPathSeparator", "toString", "getHomeDir", "indexOf", "toString", "indexOf", "toString", "substring", "toString", "length", "substring", "toString", "substring", "toString", "length", "toString", "indexOf", "toString", "indexOf", "toString", "equals", "toString", "endsWith", "toString", "getPathSeparator", "toString", "toString", "toString", "getPathSeparator", "toString", "indexOf", "toString", "toString", "indexOf", "indexOf", "substring", "length", "substring", "getParentFile", "getPathSeparator", "toString", "substring", "length", "toString", "endsWith", "toString", "substring", "toString", "length", "toString", "length", "getParentFile", "getPathSeparator", "indexOf", "toString", "indexOf", "toString", "parsePath", "indexOf", "toString", "equals", "getCriteria", "valueOf", "add", "getParentPath", "findFiles", "getCriteria", "length", "exists", "getPathSeparator", "add", "getPathSeparator", "length", "toString", "findFiles", "getCriteria", "length", "add"]}, "repository": {"repo_id": 2280644, "url": "https://github.com/aeshell/aesh", "language": "Java", "is_fork": false, "fork_count": 62, "stargazer_count": 83, "size": 6068, "license": "licensed"}}