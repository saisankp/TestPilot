{"test_class": {"identifier": "TimestampsAndPunctuatedWatermarksOperatorTest", "superclass": "", "interfaces": "", "fields": [], "file": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/TimestampsAndPunctuatedWatermarksOperatorTest.java"}, "test_case": {"identifier": "testZeroOnNegativeTimestamps", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testZeroOnNegativeTimestamps() throws Exception {\n\n\t\tfinal AssignerWithPunctuatedWatermarks<Long> assigner = new NeverWatermarkExtractor();\n\n\t\tfinal TimestampsAndPunctuatedWatermarksOperator<Long> operator =\n\t\t\t\tnew TimestampsAndPunctuatedWatermarksOperator<Long>(assigner);\n\n\t\tOneInputStreamOperatorTestHarness<Long, Long> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<Long, Long>(operator);\n\n\t\ttestHarness.open();\n\n\t\tlong[] values = { Long.MIN_VALUE, -1L, 0L, 1L, 2L, 3L, Long.MAX_VALUE };\n\n\t\tfor (long value : values) {\n\t\t\ttestHarness.processElement(new StreamRecord<>(value));\n\t\t}\n\n\t\tConcurrentLinkedQueue<Object> output = testHarness.getOutput();\n\n\t\tfor (long value: values) {\n\t\t\tassertEquals(value, ((StreamRecord<?>) output.poll()).getTimestamp());\n\t\t}\n\t}", "signature": "void testZeroOnNegativeTimestamps()", "full_signature": "@Test public void testZeroOnNegativeTimestamps()", "class_method_signature": "TimestampsAndPunctuatedWatermarksOperatorTest.testZeroOnNegativeTimestamps()", "testcase": true, "constructor": false, "invocations": ["open", "processElement", "getOutput", "assertEquals", "getTimestamp", "poll"]}, "focal_class": {"identifier": "TimestampsAndPunctuatedWatermarksOperator", "superclass": "extends AbstractUdfStreamOperator<T, AssignerWithPunctuatedWatermarks<T>>", "interfaces": "implements OneInputStreamOperator<T, T>", "fields": [{"original_string": "private static final long serialVersionUID = 1L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 1L", "var_name": "serialVersionUID"}, {"original_string": "private long currentWatermark = Long.MIN_VALUE;", "modifier": "private", "type": "long", "declarator": "currentWatermark = Long.MIN_VALUE", "var_name": "currentWatermark"}], "methods": [{"identifier": "TimestampsAndPunctuatedWatermarksOperator", "parameters": "(AssignerWithPunctuatedWatermarks<T> assigner)", "modifiers": "public", "return": "", "signature": " TimestampsAndPunctuatedWatermarksOperator(AssignerWithPunctuatedWatermarks<T> assigner)", "full_signature": "public  TimestampsAndPunctuatedWatermarksOperator(AssignerWithPunctuatedWatermarks<T> assigner)", "class_method_signature": "TimestampsAndPunctuatedWatermarksOperator.TimestampsAndPunctuatedWatermarksOperator(AssignerWithPunctuatedWatermarks<T> assigner)", "testcase": false, "constructor": true}, {"identifier": "processElement", "parameters": "(StreamRecord<T> element)", "modifiers": "@Override public", "return": "void", "signature": "void processElement(StreamRecord<T> element)", "full_signature": "@Override public void processElement(StreamRecord<T> element)", "class_method_signature": "TimestampsAndPunctuatedWatermarksOperator.processElement(StreamRecord<T> element)", "testcase": false, "constructor": false}, {"identifier": "processWatermark", "parameters": "(Watermark mark)", "modifiers": "@Override public", "return": "void", "signature": "void processWatermark(Watermark mark)", "full_signature": "@Override public void processWatermark(Watermark mark)", "class_method_signature": "TimestampsAndPunctuatedWatermarksOperator.processWatermark(Watermark mark)", "testcase": false, "constructor": false}], "file": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/TimestampsAndPunctuatedWatermarksOperator.java"}, "focal_method": {"identifier": "processElement", "parameters": "(StreamRecord<T> element)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void processElement(StreamRecord<T> element) throws Exception {\n\t\tfinal T value = element.getValue();\n\t\tfinal long newTimestamp = userFunction.extractTimestamp(value, \n\t\t\t\telement.hasTimestamp() ? element.getTimestamp() : Long.MIN_VALUE);\n\n\t\toutput.collect(element.replace(element.getValue(), newTimestamp));\n\n\t\tfinal Watermark nextWatermark = userFunction.checkAndGetNextWatermark(value, newTimestamp);\n\t\tif (nextWatermark != null && nextWatermark.getTimestamp() > currentWatermark) {\n\t\t\tcurrentWatermark = nextWatermark.getTimestamp();\n\t\t\toutput.emitWatermark(nextWatermark);\n\t\t}\n\t}", "signature": "void processElement(StreamRecord<T> element)", "full_signature": "@Override public void processElement(StreamRecord<T> element)", "class_method_signature": "TimestampsAndPunctuatedWatermarksOperator.processElement(StreamRecord<T> element)", "testcase": false, "constructor": false, "invocations": ["getValue", "extractTimestamp", "hasTimestamp", "getTimestamp", "collect", "replace", "getValue", "checkAndGetNextWatermark", "getTimestamp", "getTimestamp", "emitWatermark"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}