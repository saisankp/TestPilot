{"test_class": {"identifier": "FilterRecordInputStreamTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final GuavaBloomFilterFactory factory = new GuavaBloomFilterFactory();", "modifier": "private final", "type": "GuavaBloomFilterFactory", "declarator": "factory = new GuavaBloomFilterFactory()", "var_name": "factory"}, {"original_string": "private FileChannel writeRecordChannel;", "modifier": "private", "type": "FileChannel", "declarator": "writeRecordChannel", "var_name": "writeRecordChannel"}, {"original_string": "private File tempFile;", "modifier": "private", "type": "File", "declarator": "tempFile", "var_name": "tempFile"}, {"original_string": "private String tempDir;", "modifier": "private", "type": "String", "declarator": "tempDir", "var_name": "tempDir"}], "file": "filter-service-core/src/test/java/cn/leancloud/filter/service/FilterRecordInputStreamTest.java"}, "test_case": {"identifier": "testReadWriteMultiFilterRecord", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testReadWriteMultiFilterRecord() throws Exception {\n        final List<FilterRecord<BloomFilter>> records = generateFilterRecords(100);\n        for (FilterRecord<BloomFilter> record : records) {\n            record.writeFullyTo(writeRecordChannel);\n        }\n\n        try (FilterRecordInputStream<GuavaBloomFilter> stream = new FilterRecordInputStream<>(tempFile.toPath(), factory)) {\n            for (FilterRecord<BloomFilter> expectRecord : records) {\n                assertThat(stream.nextFilterRecord()).isEqualTo(expectRecord);\n            }\n\n            assertThat(stream.nextFilterRecord()).isNull();\n        }\n    }", "signature": "void testReadWriteMultiFilterRecord()", "full_signature": "@Test public void testReadWriteMultiFilterRecord()", "class_method_signature": "FilterRecordInputStreamTest.testReadWriteMultiFilterRecord()", "testcase": true, "constructor": false, "invocations": ["generateFilterRecords", "writeFullyTo", "toPath", "isEqualTo", "assertThat", "nextFilterRecord", "isNull", "assertThat", "nextFilterRecord"]}, "focal_class": {"identifier": "FilterRecordInputStream", "superclass": "", "interfaces": "implements Closeable", "fields": [{"original_string": "private final FileChannel channel;", "modifier": "private final", "type": "FileChannel", "declarator": "channel", "var_name": "channel"}, {"original_string": "private final Path recordFilePath;", "modifier": "private final", "type": "Path", "declarator": "recordFilePath", "var_name": "recordFilePath"}, {"original_string": "private final long end;", "modifier": "private final", "type": "long", "declarator": "end", "var_name": "end"}, {"original_string": "private final ByteBuffer headerBuffer;", "modifier": "private final", "type": "ByteBuffer", "declarator": "headerBuffer", "var_name": "headerBuffer"}, {"original_string": "private final BloomFilterFactory<F, ?> factory;", "modifier": "private final", "type": "BloomFilterFactory<F, ?>", "declarator": "factory", "var_name": "factory"}, {"original_string": "private long position;", "modifier": "private", "type": "long", "declarator": "position", "var_name": "position"}], "methods": [{"identifier": "readFully", "parameters": "(FileChannel channel, ByteBuffer destinationBuffer, long position)", "modifiers": "private static", "return": "void", "signature": "void readFully(FileChannel channel, ByteBuffer destinationBuffer, long position)", "full_signature": "private static void readFully(FileChannel channel, ByteBuffer destinationBuffer, long position)", "class_method_signature": "FilterRecordInputStream.readFully(FileChannel channel, ByteBuffer destinationBuffer, long position)", "testcase": false, "constructor": false}, {"identifier": "readFullyOrFail", "parameters": "(FileChannel channel, ByteBuffer destinationBuffer, long position)", "modifiers": "static", "return": "void", "signature": "void readFullyOrFail(FileChannel channel, ByteBuffer destinationBuffer, long position)", "full_signature": "static void readFullyOrFail(FileChannel channel, ByteBuffer destinationBuffer, long position)", "class_method_signature": "FilterRecordInputStream.readFullyOrFail(FileChannel channel, ByteBuffer destinationBuffer, long position)", "testcase": false, "constructor": false}, {"identifier": "FilterRecordInputStream", "parameters": "(Path recordFilePath, BloomFilterFactory<F, ?> factory)", "modifiers": "public", "return": "", "signature": " FilterRecordInputStream(Path recordFilePath, BloomFilterFactory<F, ?> factory)", "full_signature": "public  FilterRecordInputStream(Path recordFilePath, BloomFilterFactory<F, ?> factory)", "class_method_signature": "FilterRecordInputStream.FilterRecordInputStream(Path recordFilePath, BloomFilterFactory<F, ?> factory)", "testcase": false, "constructor": true}, {"identifier": "nextFilterRecord", "parameters": "()", "modifiers": "@Nullable public", "return": "FilterRecord<? extends F>", "signature": "FilterRecord<? extends F> nextFilterRecord()", "full_signature": "@Nullable public FilterRecord<? extends F> nextFilterRecord()", "class_method_signature": "FilterRecordInputStream.nextFilterRecord()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "FilterRecordInputStream.close()", "testcase": false, "constructor": false}, {"identifier": "checkMagic", "parameters": "(ByteBuffer headerBuffer)", "modifiers": "private", "return": "void", "signature": "void checkMagic(ByteBuffer headerBuffer)", "full_signature": "private void checkMagic(ByteBuffer headerBuffer)", "class_method_signature": "FilterRecordInputStream.checkMagic(ByteBuffer headerBuffer)", "testcase": false, "constructor": false}, {"identifier": "checkCrc", "parameters": "(ByteBuffer headerBuffer, ByteBuffer bodyBuffer)", "modifiers": "private", "return": "void", "signature": "void checkCrc(ByteBuffer headerBuffer, ByteBuffer bodyBuffer)", "full_signature": "private void checkCrc(ByteBuffer headerBuffer, ByteBuffer bodyBuffer)", "class_method_signature": "FilterRecordInputStream.checkCrc(ByteBuffer headerBuffer, ByteBuffer bodyBuffer)", "testcase": false, "constructor": false}, {"identifier": "readFilterNameBuffer", "parameters": "(ByteBuffer bodyBuffer)", "modifiers": "private", "return": "ByteBuffer", "signature": "ByteBuffer readFilterNameBuffer(ByteBuffer bodyBuffer)", "full_signature": "private ByteBuffer readFilterNameBuffer(ByteBuffer bodyBuffer)", "class_method_signature": "FilterRecordInputStream.readFilterNameBuffer(ByteBuffer bodyBuffer)", "testcase": false, "constructor": false}, {"identifier": "readCrc", "parameters": "(ByteBuffer headerBuffer)", "modifiers": "private", "return": "long", "signature": "long readCrc(ByteBuffer headerBuffer)", "full_signature": "private long readCrc(ByteBuffer headerBuffer)", "class_method_signature": "FilterRecordInputStream.readCrc(ByteBuffer headerBuffer)", "testcase": false, "constructor": false}], "file": "filter-service-core/src/main/java/cn/leancloud/filter/service/FilterRecordInputStream.java"}, "focal_method": {"identifier": "nextFilterRecord", "parameters": "()", "modifiers": "@Nullable public", "return": "FilterRecord<? extends F>", "body": "@Nullable\n    public FilterRecord<? extends F> nextFilterRecord() throws IOException {\n        if (end - position <= HEADER_OVERHEAD) {\n            if (end == position) {\n                return null;\n            }\n\n            throw shortReadFilterHeader(recordFilePath.toString(), (int) (HEADER_OVERHEAD - (end - position)));\n        }\n\n        headerBuffer.rewind();\n        readFullyOrFail(channel, headerBuffer, position);\n        headerBuffer.rewind();\n\n        final int bodyLen = headerBuffer.getInt(BODY_LENGTH_OFFSET);\n        if (end - position < HEADER_OVERHEAD + bodyLen) {\n            throw shortReadFilterBody(recordFilePath.toString(), (int) ((bodyLen + HEADER_OVERHEAD) - (end - position)));\n        }\n\n        checkMagic(headerBuffer);\n\n        final ByteBuffer bodyBuffer = ByteBuffer.allocate(bodyLen);\n        readFullyOrFail(channel, bodyBuffer, position + HEADER_OVERHEAD);\n        bodyBuffer.flip();\n\n        checkCrc(headerBuffer, bodyBuffer);\n\n        final ByteBuffer filterNameBuffer = readFilterNameBuffer(bodyBuffer);\n        final String name = StandardCharsets.UTF_8.decode(filterNameBuffer).toString();\n        final F filter = factory.readFrom(new ByteArrayInputStream(bodyBuffer.array(),\n                bodyBuffer.position() + filterNameBuffer.limit(), bodyBuffer.remaining()));\n\n        // every thing is fine, we move position forward\n        position += bodyLen + HEADER_OVERHEAD;\n        return new FilterRecord<>(name, filter);\n    }", "signature": "FilterRecord<? extends F> nextFilterRecord()", "full_signature": "@Nullable public FilterRecord<? extends F> nextFilterRecord()", "class_method_signature": "FilterRecordInputStream.nextFilterRecord()", "testcase": false, "constructor": false, "invocations": ["shortReadFilterHeader", "toString", "rewind", "readFullyOrFail", "rewind", "getInt", "shortReadFilterBody", "toString", "checkMagic", "allocate", "readFullyOrFail", "flip", "checkCrc", "readFilterNameBuffer", "toString", "decode", "readFrom", "array", "position", "limit", "remaining"]}, "repository": {"repo_id": 217849614, "url": "https://github.com/leancloud/filter-service", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 14, "size": 2797, "license": "licensed"}}