{"test_class": {"identifier": "MongoDataConverterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private String record;", "modifier": "private", "type": "String", "declarator": "record", "var_name": "record"}, {"original_string": "private BsonDocument val;", "modifier": "private", "type": "BsonDocument", "declarator": "val", "var_name": "val"}, {"original_string": "private SchemaBuilder builder;", "modifier": "private", "type": "SchemaBuilder", "declarator": "builder", "var_name": "builder"}, {"original_string": "private MongoDataConverter converter;", "modifier": "private", "type": "MongoDataConverter", "declarator": "converter", "var_name": "converter"}], "file": "debezium-connector-mongodb/src/test/java/io/debezium/connector/mongodb/transforms/MongoDataConverterTest.java"}, "test_case": {"identifier": "shouldCreateCorrectSchemaFromInsertJson", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldCreateCorrectSchemaFromInsertJson() {\n        for (Entry<String, BsonValue> entry : val.entrySet()) {\n            converter.addFieldSchema(entry, builder);\n        }\n        Schema finalSchema = builder.build();\n\n        assertThat(finalSchema).isEqualTo(\n                SchemaBuilder.struct().name(\"pub\")\n                        .field(\"address\", SchemaBuilder.struct().name(\"pub.address\").optional()\n                                .field(\"building\", Schema.OPTIONAL_STRING_SCHEMA)\n                                .field(\"floor\", SchemaBuilder.struct().name(\"pub.address.floor\").optional()\n                                        .field(\"level\", Schema.OPTIONAL_INT32_SCHEMA)\n                                        .field(\"description\", Schema.OPTIONAL_STRING_SCHEMA)\n                                        .build())\n                                .field(\"coord\", SchemaBuilder.array(Schema.OPTIONAL_FLOAT64_SCHEMA).optional().build())\n                                .field(\"street\", Schema.OPTIONAL_STRING_SCHEMA)\n                                .field(\"zipcode\", Schema.OPTIONAL_STRING_SCHEMA)\n                                .build())\n                        .field(\"borough\", Schema.OPTIONAL_STRING_SCHEMA)\n                        .field(\"cuisine\", Schema.OPTIONAL_STRING_SCHEMA)\n                        .field(\"grades\", SchemaBuilder.array(SchemaBuilder.struct().name(\"pub.grades\").optional()\n                                .field(\"date\", Timestamp.builder().optional().build())\n                                .field(\"grade\", Schema.OPTIONAL_STRING_SCHEMA)\n                                .field(\"score\", Schema.OPTIONAL_INT32_SCHEMA)\n                                .build())\n                                .optional()\n                                .build())\n                        .field(\"name\", Schema.OPTIONAL_STRING_SCHEMA)\n                        .field(\"restaurant_id\", Schema.OPTIONAL_STRING_SCHEMA)\n                        .build());\n    }", "signature": "void shouldCreateCorrectSchemaFromInsertJson()", "full_signature": "@Test public void shouldCreateCorrectSchemaFromInsertJson()", "class_method_signature": "MongoDataConverterTest.shouldCreateCorrectSchemaFromInsertJson()", "testcase": true, "constructor": false, "invocations": ["entrySet", "addFieldSchema", "build", "isEqualTo", "assertThat", "build", "field", "field", "field", "field", "field", "field", "name", "struct", "build", "field", "field", "field", "field", "field", "optional", "name", "struct", "build", "field", "field", "optional", "name", "struct", "build", "optional", "array", "build", "optional", "array", "build", "field", "field", "field", "optional", "name", "struct", "build", "optional", "builder"]}, "focal_class": {"identifier": "MongoDataConverter", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String SCHEMA_NAME_REGEX = \"io.debezium.mongodb.regex\";", "modifier": "public static final", "type": "String", "declarator": "SCHEMA_NAME_REGEX = \"io.debezium.mongodb.regex\"", "var_name": "SCHEMA_NAME_REGEX"}, {"original_string": "private final ArrayEncoding arrayEncoding;", "modifier": "private final", "type": "ArrayEncoding", "declarator": "arrayEncoding", "var_name": "arrayEncoding"}, {"original_string": "private final FieldNamer<String> fieldNamer;", "modifier": "private final", "type": "FieldNamer<String>", "declarator": "fieldNamer", "var_name": "fieldNamer"}, {"original_string": "private final boolean sanitizeValue;", "modifier": "private final", "type": "boolean", "declarator": "sanitizeValue", "var_name": "sanitizeValue"}], "methods": [{"identifier": "MongoDataConverter", "parameters": "(ArrayEncoding arrayEncoding, FieldNamer<String> fieldNamer, boolean sanitizeValue)", "modifiers": "public", "return": "", "signature": " MongoDataConverter(ArrayEncoding arrayEncoding, FieldNamer<String> fieldNamer, boolean sanitizeValue)", "full_signature": "public  MongoDataConverter(ArrayEncoding arrayEncoding, FieldNamer<String> fieldNamer, boolean sanitizeValue)", "class_method_signature": "MongoDataConverter.MongoDataConverter(ArrayEncoding arrayEncoding, FieldNamer<String> fieldNamer, boolean sanitizeValue)", "testcase": false, "constructor": true}, {"identifier": "MongoDataConverter", "parameters": "(ArrayEncoding arrayEncoding)", "modifiers": "public", "return": "", "signature": " MongoDataConverter(ArrayEncoding arrayEncoding)", "full_signature": "public  MongoDataConverter(ArrayEncoding arrayEncoding)", "class_method_signature": "MongoDataConverter.MongoDataConverter(ArrayEncoding arrayEncoding)", "testcase": false, "constructor": true}, {"identifier": "convertRecord", "parameters": "(Entry<String, BsonValue> keyvalueforStruct, Schema schema, Struct struct)", "modifiers": "public", "return": "Struct", "signature": "Struct convertRecord(Entry<String, BsonValue> keyvalueforStruct, Schema schema, Struct struct)", "full_signature": "public Struct convertRecord(Entry<String, BsonValue> keyvalueforStruct, Schema schema, Struct struct)", "class_method_signature": "MongoDataConverter.convertRecord(Entry<String, BsonValue> keyvalueforStruct, Schema schema, Struct struct)", "testcase": false, "constructor": false}, {"identifier": "convertFieldValue", "parameters": "(Entry<String, BsonValue> keyvalueforStruct, Struct struct, Schema schema)", "modifiers": "public", "return": "void", "signature": "void convertFieldValue(Entry<String, BsonValue> keyvalueforStruct, Struct struct, Schema schema)", "full_signature": "public void convertFieldValue(Entry<String, BsonValue> keyvalueforStruct, Struct struct, Schema schema)", "class_method_signature": "MongoDataConverter.convertFieldValue(Entry<String, BsonValue> keyvalueforStruct, Struct struct, Schema schema)", "testcase": false, "constructor": false}, {"identifier": "convertFieldValue", "parameters": "(Schema valueSchema, BsonType valueType, BsonValue arrValue, ArrayList<Object> list)", "modifiers": "private", "return": "void", "signature": "void convertFieldValue(Schema valueSchema, BsonType valueType, BsonValue arrValue, ArrayList<Object> list)", "full_signature": "private void convertFieldValue(Schema valueSchema, BsonType valueType, BsonValue arrValue, ArrayList<Object> list)", "class_method_signature": "MongoDataConverter.convertFieldValue(Schema valueSchema, BsonType valueType, BsonValue arrValue, ArrayList<Object> list)", "testcase": false, "constructor": false}, {"identifier": "arrayElementStructName", "parameters": "(int i)", "modifiers": "protected", "return": "String", "signature": "String arrayElementStructName(int i)", "full_signature": "protected String arrayElementStructName(int i)", "class_method_signature": "MongoDataConverter.arrayElementStructName(int i)", "testcase": false, "constructor": false}, {"identifier": "addFieldSchema", "parameters": "(Entry<String, BsonValue> keyValuesforSchema, SchemaBuilder builder)", "modifiers": "public", "return": "void", "signature": "void addFieldSchema(Entry<String, BsonValue> keyValuesforSchema, SchemaBuilder builder)", "full_signature": "public void addFieldSchema(Entry<String, BsonValue> keyValuesforSchema, SchemaBuilder builder)", "class_method_signature": "MongoDataConverter.addFieldSchema(Entry<String, BsonValue> keyValuesforSchema, SchemaBuilder builder)", "testcase": false, "constructor": false}, {"identifier": "subSchema", "parameters": "(SchemaBuilder builder, String key, BsonType valueType, BsonValue value)", "modifiers": "private", "return": "Schema", "signature": "Schema subSchema(SchemaBuilder builder, String key, BsonType valueType, BsonValue value)", "full_signature": "private Schema subSchema(SchemaBuilder builder, String key, BsonType valueType, BsonValue value)", "class_method_signature": "MongoDataConverter.subSchema(SchemaBuilder builder, String key, BsonType valueType, BsonValue value)", "testcase": false, "constructor": false}, {"identifier": "subSchema", "parameters": "(SchemaBuilder documentSchemaBuilder, Map<String, BsonType> union, BsonDocument arrayDocs)", "modifiers": "private", "return": "void", "signature": "void subSchema(SchemaBuilder documentSchemaBuilder, Map<String, BsonType> union, BsonDocument arrayDocs)", "full_signature": "private void subSchema(SchemaBuilder documentSchemaBuilder, Map<String, BsonType> union, BsonDocument arrayDocs)", "class_method_signature": "MongoDataConverter.subSchema(SchemaBuilder documentSchemaBuilder, Map<String, BsonType> union, BsonDocument arrayDocs)", "testcase": false, "constructor": false}, {"identifier": "testType", "parameters": "(SchemaBuilder builder, String key, BsonValue value, BsonType valueType)", "modifiers": "private", "return": "void", "signature": "void testType(SchemaBuilder builder, String key, BsonValue value, BsonType valueType)", "full_signature": "private void testType(SchemaBuilder builder, String key, BsonValue value, BsonType valueType)", "class_method_signature": "MongoDataConverter.testType(SchemaBuilder builder, String key, BsonValue value, BsonType valueType)", "testcase": false, "constructor": false}], "file": "debezium-connector-mongodb/src/main/java/io/debezium/connector/mongodb/transforms/MongoDataConverter.java"}, "focal_method": {"identifier": "addFieldSchema", "parameters": "(Entry<String, BsonValue> keyValuesforSchema, SchemaBuilder builder)", "modifiers": "public", "return": "void", "body": "public void addFieldSchema(Entry<String, BsonValue> keyValuesforSchema, SchemaBuilder builder) {\n        String key = fieldNamer.fieldNameFor(keyValuesforSchema.getKey());\n        BsonType type = keyValuesforSchema.getValue().getBsonType();\n\n        switch (type) {\n\n            case NULL:\n            case STRING:\n            case JAVASCRIPT:\n            case OBJECT_ID:\n            case DECIMAL128:\n                builder.field(key, Schema.OPTIONAL_STRING_SCHEMA);\n                break;\n\n            case DOUBLE:\n                builder.field(key, Schema.OPTIONAL_FLOAT64_SCHEMA);\n                break;\n\n            case BINARY:\n                builder.field(key, Schema.OPTIONAL_BYTES_SCHEMA);\n                break;\n\n            case INT32:\n                builder.field(key, Schema.OPTIONAL_INT32_SCHEMA);\n                break;\n\n            case INT64:\n                builder.field(key, Schema.OPTIONAL_INT64_SCHEMA);\n                break;\n\n            case DATE_TIME:\n            case TIMESTAMP:\n                builder.field(key, org.apache.kafka.connect.data.Timestamp.builder().optional().build());\n                break;\n\n            case BOOLEAN:\n                builder.field(key, Schema.OPTIONAL_BOOLEAN_SCHEMA);\n                break;\n\n            case JAVASCRIPT_WITH_SCOPE:\n                SchemaBuilder jswithscope = SchemaBuilder.struct().name(builder.name() + \".\" + key);\n                jswithscope.field(\"code\", Schema.OPTIONAL_STRING_SCHEMA);\n                SchemaBuilder scope = SchemaBuilder.struct().name(jswithscope.name() + \".scope\").optional();\n                BsonDocument jwsDocument = keyValuesforSchema.getValue().asJavaScriptWithScope().getScope().asDocument();\n\n                for (Entry<String, BsonValue> jwsDocumentKey : jwsDocument.entrySet()) {\n                    addFieldSchema(jwsDocumentKey, scope);\n                }\n\n                Schema scopeBuild = scope.build();\n                jswithscope.field(\"scope\", scopeBuild).build();\n                builder.field(key, jswithscope);\n                break;\n\n            case REGULAR_EXPRESSION:\n                SchemaBuilder regexwop = SchemaBuilder.struct().name(SCHEMA_NAME_REGEX).optional();\n                regexwop.field(\"regex\", Schema.OPTIONAL_STRING_SCHEMA);\n                regexwop.field(\"options\", Schema.OPTIONAL_STRING_SCHEMA);\n                builder.field(key, regexwop.build());\n                break;\n\n            case DOCUMENT:\n                SchemaBuilder builderDoc = SchemaBuilder.struct().name(builder.name() + \".\" + key).optional();\n                BsonDocument docs = keyValuesforSchema.getValue().asDocument();\n\n                for (Entry<String, BsonValue> doc : docs.entrySet()) {\n                    addFieldSchema(doc, builderDoc);\n                }\n                builder.field(key, builderDoc.build());\n                break;\n\n            case ARRAY:\n                if (keyValuesforSchema.getValue().asArray().isEmpty()) {\n                    // ignore empty arrays; currently only for Avro, but might be worth doing in general as we\n                    // cannot conclude an element type in any meaningful way\n                    if (sanitizeValue) {\n                        return;\n                    }\n                    switch (arrayEncoding) {\n                        case ARRAY:\n                            builder.field(key, SchemaBuilder.array(Schema.OPTIONAL_STRING_SCHEMA).optional().build());\n                            break;\n                        case DOCUMENT:\n                            builder.field(key, SchemaBuilder.struct().name(builder.name() + \".\" + key).optional().build());\n                            break;\n                    }\n                }\n                else {\n                    switch (arrayEncoding) {\n                        case ARRAY:\n                            BsonArray value = keyValuesforSchema.getValue().asArray();\n                            BsonType valueType = value.get(0).getBsonType();\n                            testType(builder, key, keyValuesforSchema.getValue(), valueType);\n                            builder.field(key, SchemaBuilder.array(subSchema(builder, key, valueType, value)).optional().build());\n                            break;\n                        case DOCUMENT:\n                            final BsonArray array = keyValuesforSchema.getValue().asArray();\n                            final SchemaBuilder arrayStructBuilder = SchemaBuilder.struct().name(builder.name() + \".\" + key).optional();\n                            final Map<String, BsonValue> convertedArray = new HashMap<>();\n                            for (int i = 0; i < array.size(); i++) {\n                                convertedArray.put(arrayElementStructName(i), array.get(i));\n                            }\n                            convertedArray.entrySet().forEach(x -> addFieldSchema(x, arrayStructBuilder));\n                            builder.field(key, arrayStructBuilder.build());\n                            break;\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }", "signature": "void addFieldSchema(Entry<String, BsonValue> keyValuesforSchema, SchemaBuilder builder)", "full_signature": "public void addFieldSchema(Entry<String, BsonValue> keyValuesforSchema, SchemaBuilder builder)", "class_method_signature": "MongoDataConverter.addFieldSchema(Entry<String, BsonValue> keyValuesforSchema, SchemaBuilder builder)", "testcase": false, "constructor": false, "invocations": ["fieldNameFor", "getKey", "getBsonType", "getValue", "field", "field", "field", "field", "field", "field", "build", "optional", "builder", "field", "name", "struct", "name", "field", "optional", "name", "struct", "name", "asDocument", "getScope", "asJavaScriptWithScope", "getValue", "entrySet", "addFieldSchema", "build", "build", "field", "field", "optional", "name", "struct", "field", "field", "field", "build", "optional", "name", "struct", "name", "asDocument", "getValue", "entrySet", "addFieldSchema", "field", "build", "isEmpty", "asArray", "getValue", "field", "build", "optional", "array", "field", "build", "optional", "name", "struct", "name", "asArray", "getValue", "getBsonType", "get", "testType", "getValue", "field", "build", "optional", "array", "subSchema", "asArray", "getValue", "optional", "name", "struct", "name", "size", "put", "arrayElementStructName", "get", "forEach", "entrySet", "addFieldSchema", "field", "build"]}, "repository": {"repo_id": 50205233, "url": "https://github.com/debezium/debezium", "stars": 2686, "created": "1/22/2016 8:17:05 PM +00:00", "updates": "2020-01-27T20:48:54+00:00", "fork": "False", "license": "licensed"}}