{"test_class": {"identifier": "LiveDataReactiveStreamsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Lifecycle sLifecycle = new Lifecycle() {\n        @Override\n        public void addObserver(LifecycleObserver observer) {\n        }\n\n        @Override\n        public void removeObserver(LifecycleObserver observer) {\n        }\n\n        @Override\n        public State getCurrentState() {\n            return RESUMED;\n        }\n    };", "modifier": "private static final", "type": "Lifecycle", "declarator": "sLifecycle = new Lifecycle() {\n        @Override\n        public void addObserver(LifecycleObserver observer) {\n        }\n\n        @Override\n        public void removeObserver(LifecycleObserver observer) {\n        }\n\n        @Override\n        public State getCurrentState() {\n            return RESUMED;\n        }\n    }", "var_name": "sLifecycle"}, {"original_string": "private static final LifecycleOwner S_LIFECYCLE_OWNER = new LifecycleOwner() {\n\n        @Override\n        public Lifecycle getLifecycle() {\n            return sLifecycle;\n        }\n\n    };", "modifier": "private static final", "type": "LifecycleOwner", "declarator": "S_LIFECYCLE_OWNER = new LifecycleOwner() {\n\n        @Override\n        public Lifecycle getLifecycle() {\n            return sLifecycle;\n        }\n\n    }", "var_name": "S_LIFECYCLE_OWNER"}, {"original_string": "private final List<String> mLiveDataOutput = new ArrayList<>();", "modifier": "private final", "type": "List<String>", "declarator": "mLiveDataOutput = new ArrayList<>()", "var_name": "mLiveDataOutput"}, {"original_string": "private final Observer<String> mObserver = new Observer<String>() {\n        @Override\n        public void onChanged(@Nullable String s) {\n            mLiveDataOutput.add(s);\n        }\n    };", "modifier": "private final", "type": "Observer<String>", "declarator": "mObserver = new Observer<String>() {\n        @Override\n        public void onChanged(@Nullable String s) {\n            mLiveDataOutput.add(s);\n        }\n    }", "var_name": "mObserver"}, {"original_string": "private final ReplayProcessor<String> mOutputProcessor = ReplayProcessor.create();", "modifier": "private final", "type": "ReplayProcessor<String>", "declarator": "mOutputProcessor = ReplayProcessor.create()", "var_name": "mOutputProcessor"}, {"original_string": "private static final TestScheduler sBackgroundScheduler = new TestScheduler();", "modifier": "private static final", "type": "TestScheduler", "declarator": "sBackgroundScheduler = new TestScheduler()", "var_name": "sBackgroundScheduler"}, {"original_string": "private Thread mTestThread;", "modifier": "private", "type": "Thread", "declarator": "mTestThread", "var_name": "mTestThread"}], "file": "lifecycle/reactivestreams/src/test/java/android/arch/lifecycle/LiveDataReactiveStreamsTest.java"}, "test_case": {"identifier": "convertsFromPublisher", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void convertsFromPublisher() {\n        PublishProcessor<String> processor = PublishProcessor.create();\n        LiveData<String> liveData = LiveDataReactiveStreams.fromPublisher(processor);\n\n        liveData.observe(S_LIFECYCLE_OWNER, mObserver);\n\n        processor.onNext(\"foo\");\n        processor.onNext(\"bar\");\n        processor.onNext(\"baz\");\n\n        assertThat(mLiveDataOutput, is(Arrays.asList(\"foo\", \"bar\", \"baz\")));\n    }", "signature": "void convertsFromPublisher()", "full_signature": "@Test public void convertsFromPublisher()", "class_method_signature": "LiveDataReactiveStreamsTest.convertsFromPublisher()", "testcase": true, "constructor": false, "invocations": ["create", "fromPublisher", "observe", "onNext", "onNext", "onNext", "assertThat", "is", "asList"]}, "focal_class": {"identifier": "LiveDataReactiveStreams", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "LiveDataReactiveStreams", "parameters": "()", "modifiers": "private", "return": "", "signature": " LiveDataReactiveStreams()", "full_signature": "private  LiveDataReactiveStreams()", "class_method_signature": "LiveDataReactiveStreams.LiveDataReactiveStreams()", "testcase": false, "constructor": true}, {"identifier": "toPublisher", "parameters": "(\n            final LifecycleOwner lifecycle, final LiveData<T> liveData)", "modifiers": "public static", "return": "Publisher<T>", "signature": "Publisher<T> toPublisher(\n            final LifecycleOwner lifecycle, final LiveData<T> liveData)", "full_signature": "public static Publisher<T> toPublisher(\n            final LifecycleOwner lifecycle, final LiveData<T> liveData)", "class_method_signature": "LiveDataReactiveStreams.toPublisher(\n            final LifecycleOwner lifecycle, final LiveData<T> liveData)", "testcase": false, "constructor": false}, {"identifier": "fromPublisher", "parameters": "(final Publisher<T> publisher)", "modifiers": "public static", "return": "LiveData<T>", "signature": "LiveData<T> fromPublisher(final Publisher<T> publisher)", "full_signature": "public static LiveData<T> fromPublisher(final Publisher<T> publisher)", "class_method_signature": "LiveDataReactiveStreams.fromPublisher(final Publisher<T> publisher)", "testcase": false, "constructor": false}], "file": "lifecycle/reactivestreams/src/main/java/android/arch/lifecycle/LiveDataReactiveStreams.java"}, "focal_method": {"identifier": "fromPublisher", "parameters": "(final Publisher<T> publisher)", "modifiers": "public static", "return": "LiveData<T>", "body": "public static <T> LiveData<T> fromPublisher(final Publisher<T> publisher) {\n        MutableLiveData<T> liveData = new MutableLiveData<>();\n        // Since we don't have a way to directly observe cancels, weakly hold the live data.\n        final WeakReference<MutableLiveData<T>> liveDataRef = new WeakReference<>(liveData);\n\n        publisher.subscribe(new Subscriber<T>() {\n            @Override\n            public void onSubscribe(Subscription s) {\n                // Don't worry about backpressure. If the stream is too noisy then backpressure can\n                // be handled upstream.\n                s.request(Long.MAX_VALUE);\n            }\n\n            @Override\n            public void onNext(final T t) {\n                final LiveData<T> liveData = liveDataRef.get();\n                if (liveData != null) {\n                    liveData.postValue(t);\n                }\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                // Errors should be handled upstream, so propagate as a crash.\n                throw new RuntimeException(t);\n            }\n\n            @Override\n            public void onComplete() {\n            }\n        });\n\n        return liveData;\n    }", "signature": "LiveData<T> fromPublisher(final Publisher<T> publisher)", "full_signature": "public static LiveData<T> fromPublisher(final Publisher<T> publisher)", "class_method_signature": "LiveDataReactiveStreams.fromPublisher(final Publisher<T> publisher)", "testcase": false, "constructor": false, "invocations": ["subscribe", "request", "get", "postValue"]}, "repository": {"repo_id": 104025215, "url": "https://github.com/Rayduh/support", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 8, "size": 253405, "license": "licensed"}}