{"test_class": {"identifier": "CndTokenizerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private CndTokenizer tokenizer;", "modifier": "private", "type": "CndTokenizer", "declarator": "tokenizer", "var_name": "tokenizer"}, {"original_string": "private Tokens tokenFactory;", "modifier": "private", "type": "Tokens", "declarator": "tokenFactory", "var_name": "tokenFactory"}, {"original_string": "private LinkedList<int[]> tokenValues;", "modifier": "private", "type": "LinkedList<int[]>", "declarator": "tokenValues", "var_name": "tokenValues"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/CndTokenizerTest.java"}, "test_case": {"identifier": "shouldNotCreateVendorExtensionTokenIfTokenizerIsNotUsingThem", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldNotCreateVendorExtensionTokenIfTokenizerIsNotUsingThem() {\n        tokenizer = new CndTokenizer(true, false);\n        String content = \"{vendor extension}\";\n        tokenize(content);\n        assertNoMoreTokens();\n    }", "signature": "void shouldNotCreateVendorExtensionTokenIfTokenizerIsNotUsingThem()", "full_signature": "@Test public void shouldNotCreateVendorExtensionTokenIfTokenizerIsNotUsingThem()", "class_method_signature": "CndTokenizerTest.shouldNotCreateVendorExtensionTokenIfTokenizerIsNotUsingThem()", "testcase": true, "constructor": false, "invocations": ["tokenize", "assertNoMoreTokens"]}, "focal_class": {"identifier": "CndTokenizer", "superclass": "", "interfaces": "implements Tokenizer", "fields": [{"original_string": "public static final int WORD = 1;", "modifier": "public static final", "type": "int", "declarator": "WORD = 1", "var_name": "WORD"}, {"original_string": "public static final int SYMBOL = 2;", "modifier": "public static final", "type": "int", "declarator": "SYMBOL = 2", "var_name": "SYMBOL"}, {"original_string": "public static final int DECIMAL = 3;", "modifier": "public static final", "type": "int", "declarator": "DECIMAL = 3", "var_name": "DECIMAL"}, {"original_string": "public static final int SINGLE_QUOTED_STRING = 4;", "modifier": "public static final", "type": "int", "declarator": "SINGLE_QUOTED_STRING = 4", "var_name": "SINGLE_QUOTED_STRING"}, {"original_string": "public static final int DOUBLE_QUOTED_STRING = 5;", "modifier": "public static final", "type": "int", "declarator": "DOUBLE_QUOTED_STRING = 5", "var_name": "DOUBLE_QUOTED_STRING"}, {"original_string": "public static final int COMMENT = 6;", "modifier": "public static final", "type": "int", "declarator": "COMMENT = 6", "var_name": "COMMENT"}, {"original_string": "public static final int VENDOR_EXTENSION = 7;", "modifier": "public static final", "type": "int", "declarator": "VENDOR_EXTENSION = 7", "var_name": "VENDOR_EXTENSION"}, {"original_string": "private final boolean useComments;", "modifier": "private final", "type": "boolean", "declarator": "useComments", "var_name": "useComments"}, {"original_string": "private final boolean useVendorExtensions;", "modifier": "private final", "type": "boolean", "declarator": "useVendorExtensions", "var_name": "useVendorExtensions"}], "methods": [{"identifier": "CndTokenizer", "parameters": "( boolean useComments,\n                         boolean useVendorExtensions )", "modifiers": "public", "return": "", "signature": " CndTokenizer( boolean useComments,\n                         boolean useVendorExtensions )", "full_signature": "public  CndTokenizer( boolean useComments,\n                         boolean useVendorExtensions )", "class_method_signature": "CndTokenizer.CndTokenizer( boolean useComments,\n                         boolean useVendorExtensions )", "testcase": false, "constructor": true}, {"identifier": "tokenize", "parameters": "( CharacterStream input,\n                          Tokens tokens )", "modifiers": "@Override public", "return": "void", "signature": "void tokenize( CharacterStream input,\n                          Tokens tokens )", "full_signature": "@Override public void tokenize( CharacterStream input,\n                          Tokens tokens )", "class_method_signature": "CndTokenizer.tokenize( CharacterStream input,\n                          Tokens tokens )", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/CndTokenizer.java"}, "focal_method": {"identifier": "tokenize", "parameters": "( CharacterStream input,\n                          Tokens tokens )", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void tokenize( CharacterStream input,\n                          Tokens tokens ) throws ParsingException {\n        while (input.hasNext()) {\n            char c = input.next();\n            switch (c) {\n                case ' ':\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                    // Just skip these whitespace characters ...\n                    break;\n                case '[':\n                case ']':\n                case '<':\n                case '>':\n                case '=':\n                case '-':\n                case '+':\n                case '(':\n                case ')':\n                case ',':\n                    tokens.addToken(input.position(input.index()), input.index(), input.index() + 1, SYMBOL);\n                    break;\n                // case '.':\n                // tokens.addToken(input.position(), input.index(), input.index() + 1, DECIMAL);\n                // break;\n                case '{':\n                    // Vendor extension, meant to be excluded\n                    int startIndex = input.index();\n                    Position startingPosition = input.position(startIndex);\n                    boolean foundClosingBrace = false;\n                    while (input.hasNext()) {\n                        c = input.next();\n                        if (c == '\\\\' && input.isNext('}')) {\n                            c = input.next(); // consume the '}' character since it is escaped\n                        } else if (c == '}') {\n                            foundClosingBrace = true;\n                            break;\n                        }\n                    }\n                    if (!foundClosingBrace) {\n                        String msg = CndI18n.vendorBlockWasNotClosed.text(startingPosition.getLine(),\n                                                                          startingPosition.getColumn());\n                        throw new ParsingException(startingPosition, msg);\n                    }\n                    int endIndex = input.index() + 1; // beyond last character read\n                    if (useVendorExtensions) {\n                        tokens.addToken(startingPosition, startIndex, endIndex, VENDOR_EXTENSION);\n                    }\n                    break;\n                case '\\\"':\n                    startIndex = input.index();\n                    startingPosition = input.position(startIndex);\n                    boolean foundClosingQuote = false;\n                    while (input.hasNext()) {\n                        c = input.next();\n                        if (c == '\\\\' && input.isNext('\"')) {\n                            c = input.next(); // consume the ' character since it is escaped\n                        } else if (c == '\"') {\n                            foundClosingQuote = true;\n                            break;\n                        }\n                    }\n                    if (!foundClosingQuote) {\n                        String msg = CommonI18n.noMatchingDoubleQuoteFound.text(startingPosition.getLine(),\n                                                                                startingPosition.getColumn());\n                        throw new ParsingException(startingPosition, msg);\n                    }\n                    endIndex = input.index() + 1; // beyond last character read\n                    tokens.addToken(startingPosition, startIndex, endIndex, DOUBLE_QUOTED_STRING);\n                    break;\n                case '\\'':\n                    startIndex = input.index();\n                    startingPosition = input.position(startIndex);\n                    foundClosingQuote = false;\n                    while (input.hasNext()) {\n                        c = input.next();\n                        if (c == '\\\\' && input.isNext('\\'')) {\n                            c = input.next(); // consume the ' character since it is escaped\n                        } else if (c == '\\'') {\n                            foundClosingQuote = true;\n                            break;\n                        }\n                    }\n                    if (!foundClosingQuote) {\n                        String msg = CommonI18n.noMatchingSingleQuoteFound.text(startingPosition.getLine(),\n                                                                                startingPosition.getColumn());\n                        throw new ParsingException(startingPosition, msg);\n                    }\n                    endIndex = input.index() + 1; // beyond last character read\n                    tokens.addToken(startingPosition, startIndex, endIndex, SINGLE_QUOTED_STRING);\n                    break;\n                case '/':\n                    startIndex = input.index();\n                    startingPosition = input.position(startIndex);\n                    if (input.isNext('/')) {\n                        // End-of-line comment ...\n                        boolean foundLineTerminator = false;\n                        while (input.hasNext()) {\n                            c = input.next();\n                            if (c == '\\n' || c == '\\r') {\n                                foundLineTerminator = true;\n                                break;\n                            }\n                        }\n                        endIndex = input.index(); // the token won't include the '\\n' or '\\r' character(s)\n                        if (!foundLineTerminator) ++endIndex; // must point beyond last char\n                        if (c == '\\r' && input.isNext('\\n')) input.next();\n                        if (useComments) {\n                            tokens.addToken(startingPosition, startIndex, endIndex, COMMENT);\n                        }\n                    } else if (input.isNext('*')) {\n                        // Multi-line comment ...\n                        while (input.hasNext() && !input.isNext('*', '/')) {\n                            c = input.next();\n                        }\n                        if (input.hasNext()) input.next(); // consume the '*'\n                        if (input.hasNext()) input.next(); // consume the '/'\n                        if (useComments) {\n                            endIndex = input.index() + 1; // the token will include the '/' and '*' characters\n                            tokens.addToken(startingPosition, startIndex, endIndex, COMMENT);\n                        }\n                    } else {\n                        continue;\n                    }\n                    break;\n                default:\n                    // The JCR 2.0 Public Final Draft is very unclear about what exactly a string is defined to be,\n                    // and in fact the reference implementation (all versions) basically just treat an unquoted string\n                    // to be defined as\n                    // - unquoted_string ::= [A-Za-z0-9:_]+\n                    // But this doesn't really seem to align very well with the spec, which alludes to any number\n                    // of XmlChar:\n                    // - unquoted_string ::= XmlChar { XmlChar }\n                    // - XmlChar ::= /* see \u00a73.2.2 Local Names */\n                    // Then in Section 3.2.2, there is this rule:\n                    // - XmlChar ::= /* Any character that matches the Char production at http://www.w3.org/TR/xml/#NT-Char */\n                    // This doesn't really make sense, because even whitespace is valid in Char.\n                    //\n                    // Could the CND grammar instead reference 3.2.5.2 (rather than 3.2.2)? This refers to qualified\n                    // names, and appears to be much closer to the examples and reference implementation.\n                    //\n                    // What we're doing is basically reading all subsequent characters until we find a whitespace,\n                    // one of the SYMBOL characters, a single- or double-quote character, a slash, or an open brace\n                    // (since these are all the basis for other tokenization rules above). Also, the '*' and '|'\n                    // characters terminate a WORD token, since these cannot appear unescaped within local names;\n                    // since these do not appear in other rules above, they will result in one-character tokens.\n                    //\n                    startIndex = input.index();\n                    startingPosition = input.position(startIndex);\n                    // Read as long as there is a valid XML character ...\n                    while (input.hasNext() && !(input.isNextWhitespace() || input.isNextAnyOf(\"[]<>=-+(),\\\"'/{*|\"))) {\n                        c = input.next();\n                    }\n                    endIndex = input.index() + 1; // beyond last character that was included\n                    tokens.addToken(startingPosition, startIndex, endIndex, WORD);\n            }\n        }\n    }", "signature": "void tokenize( CharacterStream input,\n                          Tokens tokens )", "full_signature": "@Override public void tokenize( CharacterStream input,\n                          Tokens tokens )", "class_method_signature": "CndTokenizer.tokenize( CharacterStream input,\n                          Tokens tokens )", "testcase": false, "constructor": false, "invocations": ["hasNext", "next", "addToken", "position", "index", "index", "index", "index", "position", "hasNext", "next", "isNext", "next", "text", "getLine", "getColumn", "index", "addToken", "index", "position", "hasNext", "next", "isNext", "next", "text", "getLine", "getColumn", "index", "addToken", "index", "position", "hasNext", "next", "isNext", "next", "text", "getLine", "getColumn", "index", "addToken", "index", "position", "isNext", "hasNext", "next", "index", "isNext", "next", "addToken", "isNext", "hasNext", "isNext", "next", "hasNext", "next", "hasNext", "next", "index", "addToken", "index", "position", "hasNext", "isNextWhitespace", "isNextAnyOf", "next", "index", "addToken"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}