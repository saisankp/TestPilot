{"test_class": {"identifier": "PackageTypeValidatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Mock\n    ValidationContext parentContainerContext;", "modifier": "@Mock", "type": "ValidationContext", "declarator": "parentContainerContext", "var_name": "parentContainerContext"}, {"original_string": "@Mock\n    PackageProperties parentContainerProperties;", "modifier": "@Mock", "type": "PackageProperties", "declarator": "parentContainerProperties", "var_name": "parentContainerProperties"}, {"original_string": "@Mock\n    WorkspaceFilter filter;", "modifier": "@Mock", "type": "WorkspaceFilter", "declarator": "filter", "var_name": "filter"}, {"original_string": "@Mock\n    PackageProperties properties;", "modifier": "@Mock", "type": "PackageProperties", "declarator": "properties", "var_name": "properties"}, {"original_string": "private PackageTypeValidator validator;", "modifier": "private", "type": "PackageTypeValidator", "declarator": "validator", "var_name": "validator"}], "file": "vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorTest.java"}, "test_case": {"identifier": "testApplicationPackageType", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testApplicationPackageType() throws IOException, ConfigurationException {\n        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);\n        Assert.assertThat(validator.validate(new NodeContextImpl(\"/apps/some/script\", Paths.get(\"\"), Paths.get(\"\"))), AnyValidationMessageMatcher.noValidationInCollection());\n        Assert.assertThat(validator.validate(new NodeContextImpl(\"/libs\",  Paths.get(\"\"), Paths.get(\"\"))), AnyValidationMessageMatcher.noValidationInCollection());\n        \n        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl(\"/content/some/node\",  Paths.get(\"\"), Paths.get(\"\"))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_APP_CONTENT_FOUND, PackageType.APPLICATION, \"/content/some/node\")));\n        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl(\"/etc/something\",  Paths.get(\"\"), Paths.get(\"\"))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_APP_CONTENT_FOUND, PackageType.APPLICATION, \"/etc/something\")));\n        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl(\"/conf/something\",  Paths.get(\"\"), Paths.get(\"\"))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_APP_CONTENT_FOUND, PackageType.APPLICATION, \"/conf/something\")));\n        \n        // no bundles/sub packages\n        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl(\"/apps/install/mybundle.jar\", Paths.get(\"\"), Paths.get(\"\"))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_OSGI_BUNDLE_OR_CONFIG, PackageType.APPLICATION, \"/apps/install/mybundle.jar\")));\n        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl(\"/apps/install/config.cfg\", Paths.get(\"\"), Paths.get(\"\"))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_OSGI_BUNDLE_OR_CONFIG, PackageType.APPLICATION, \"/apps/install/config.cfg\")));\n        \n        // no hooks\n        Mockito.when(properties.getPackageType()).thenReturn(PackageType.APPLICATION);\n        Assert.assertThat(validator.validate(properties), AnyValidationMessageMatcher.noValidationInCollection());\n        // with hooks\n        Map<String, String> hooks = Collections.singletonMap(\"key\", \"com.example.ExtenalHook\");\n        Mockito.when(properties.getExternalHooks()).thenReturn(hooks);\n        ValidationExecutorTest.assertViolation(validator.validate(properties), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_PACKAGE_HOOKS, PackageType.APPLICATION, hooks)));\n        \n        // with regular filter\n        DefaultWorkspaceFilter filter = new DefaultWorkspaceFilter();\n        try (InputStream input = this.getClass().getResourceAsStream(\"/simple-filter.xml\")) {\n            filter.load(input);\n        }\n        Assert.assertThat(validator.validate(filter), AnyValidationMessageMatcher.noValidationInCollection());\n        // with filters with include/exclude\n        try (InputStream input = this.getClass().getResourceAsStream(\"/filter.xml\")) {\n            filter.load(input);\n        }\n        ValidationExecutorTest.assertViolation(validator.validate(filter), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_FILTER_HAS_INCLUDE_EXCLUDES, PackageType.APPLICATION)));\n        \n        // validate sling:OsgiConfig node\n        DocViewNode node = new DocViewNode(\"someconfigpid\", \"someconfigpid\", null, Collections.emptyMap(), null, \"sling:OsgiConfig\");\n        Assert.assertThat(validator.validate(new NodeContextImpl(\"/apps/config/someconfigpid\", Paths.get(\"\"), Paths.get(\"\"))), AnyValidationMessageMatcher.noValidationInCollection());\n        ValidationExecutorTest.assertViolation(\n                validator.validate(node, \"/apps/config/someconfigpid\", Paths.get(\"\"), true),\n                new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_OSGI_BUNDLE_OR_CONFIG, PackageType.APPLICATION, \"/apps/config/someconfigpid\")));\n        \n        // validate sub packages of type Content\n        Mockito.when(parentContainerProperties.getPackageType()).thenReturn(PackageType.APPLICATION);\n        Mockito.when(properties.getPackageType()).thenReturn(PackageType.CONTENT);\n        PackageTypeValidator subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);\n        ValidationExecutorTest.assertViolation(subPackageValidator.validate(properties), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_UNSUPPORTED_SUB_PACKAGE, PackageType.APPLICATION)));\n        // validate sub packages of type Application\n        subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);\n        Mockito.when(properties.getPackageType()).thenReturn(PackageType.APPLICATION);\n        Mockito.when(properties.getExternalHooks()).thenReturn(Collections.emptyMap());\n        ValidationExecutorTest.assertViolation(subPackageValidator.validate(properties), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_UNSUPPORTED_SUB_PACKAGE, PackageType.APPLICATION)));\n    }", "signature": "void testApplicationPackageType()", "full_signature": "@Test public void testApplicationPackageType()", "class_method_signature": "PackageTypeValidatorTest.testApplicationPackageType()", "testcase": true, "constructor": false, "invocations": ["assertThat", "validate", "get", "get", "noValidationInCollection", "assertThat", "validate", "get", "get", "noValidationInCollection", "assertViolation", "validate", "get", "get", "format", "assertViolation", "validate", "get", "get", "format", "assertViolation", "validate", "get", "get", "format", "assertViolation", "validate", "get", "get", "format", "assertViolation", "validate", "get", "get", "format", "thenReturn", "when", "getPackageType", "assertThat", "validate", "noValidationInCollection", "singletonMap", "thenReturn", "when", "getExternalHooks", "assertViolation", "validate", "format", "getResourceAsStream", "getClass", "load", "assertThat", "validate", "noValidationInCollection", "getResourceAsStream", "getClass", "load", "assertViolation", "validate", "format", "emptyMap", "assertThat", "validate", "get", "get", "noValidationInCollection", "assertViolation", "validate", "get", "format", "thenReturn", "when", "getPackageType", "thenReturn", "when", "getPackageType", "assertViolation", "validate", "format", "thenReturn", "when", "getPackageType", "thenReturn", "when", "getExternalHooks", "emptyMap", "assertViolation", "validate", "format"]}, "focal_class": {"identifier": "PackageTypeValidator", "superclass": "", "interfaces": "implements NodePathValidator, FilterValidator, PropertiesValidator, MetaInfPathValidator, DocumentViewXmlValidator", "fields": [{"original_string": "protected static final String MESSAGE_FILTER_HAS_INCLUDE_EXCLUDES = \"Package of type '%s' is not supposed to contain includes/excludes below any of its filters!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_FILTER_HAS_INCLUDE_EXCLUDES = \"Package of type '%s' is not supposed to contain includes/excludes below any of its filters!\"", "var_name": "MESSAGE_FILTER_HAS_INCLUDE_EXCLUDES"}, {"original_string": "protected static final String MESSAGE_UNSUPPORTED_SUB_PACKAGE_OF_TYPE = \"Package of type '%s' must only contain sub packages of type '%s' but found sub package of type '%s'!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_UNSUPPORTED_SUB_PACKAGE_OF_TYPE = \"Package of type '%s' must only contain sub packages of type '%s' but found sub package of type '%s'!\"", "var_name": "MESSAGE_UNSUPPORTED_SUB_PACKAGE_OF_TYPE"}, {"original_string": "protected static final String MESSAGE_UNSUPPORTED_SUB_PACKAGE = \"Package of type '%s' is not supposed to contain any sub packages!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_UNSUPPORTED_SUB_PACKAGE = \"Package of type '%s' is not supposed to contain any sub packages!\"", "var_name": "MESSAGE_UNSUPPORTED_SUB_PACKAGE"}, {"original_string": "protected static final String MESSAGE_DEPENDENCY = \"Package of type '%s' must not have package dependencies but found dependencies '%s'!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_DEPENDENCY = \"Package of type '%s' must not have package dependencies but found dependencies '%s'!\"", "var_name": "MESSAGE_DEPENDENCY"}, {"original_string": "protected static final String MESSAGE_LEGACY_TYPE = \"Package of type '%s' is legacy. Use one of the other types instead!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_LEGACY_TYPE = \"Package of type '%s' is legacy. Use one of the other types instead!\"", "var_name": "MESSAGE_LEGACY_TYPE"}, {"original_string": "protected static final String MESSAGE_PACKAGE_HOOKS = \"Package of type '%s' must not contain package hooks but has '%s'!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_PACKAGE_HOOKS = \"Package of type '%s' must not contain package hooks but has '%s'!\"", "var_name": "MESSAGE_PACKAGE_HOOKS"}, {"original_string": "protected static final String MESSAGE_NO_PACKAGE_TYPE_SET = \"No package type set, make sure that property 'packageType' is set in the properties.xml!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_NO_PACKAGE_TYPE_SET = \"No package type set, make sure that property 'packageType' is set in the properties.xml!\"", "var_name": "MESSAGE_NO_PACKAGE_TYPE_SET"}, {"original_string": "protected static final String MESSAGE_OSGI_BUNDLE_OR_CONFIG = \"Package of type '%s' is not supposed to contain OSGi bundles or configurations!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_OSGI_BUNDLE_OR_CONFIG = \"Package of type '%s' is not supposed to contain OSGi bundles or configurations!\"", "var_name": "MESSAGE_OSGI_BUNDLE_OR_CONFIG"}, {"original_string": "protected static final String MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE = \"Package of type '%s' is not supposed to contain anything but OSGi bundles/configurations and sub packages!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE = \"Package of type '%s' is not supposed to contain anything but OSGi bundles/configurations and sub packages!\"", "var_name": "MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE"}, {"original_string": "protected static final String MESSAGE_APP_CONTENT = \"Package of type '%s' is not supposed to contain content inside '/libs' and '/apps'!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_APP_CONTENT = \"Package of type '%s' is not supposed to contain content inside '/libs' and '/apps'!\"", "var_name": "MESSAGE_APP_CONTENT"}, {"original_string": "protected static final String MESSAGE_NO_APP_CONTENT_FOUND = \"Package of type '%s' is not supposed to contain content outside '/libs' and '/apps'!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_NO_APP_CONTENT_FOUND = \"Package of type '%s' is not supposed to contain content outside '/libs' and '/apps'!\"", "var_name": "MESSAGE_NO_APP_CONTENT_FOUND"}, {"original_string": "protected static final String MESSAGE_INDEX_DEFINITIONS = \"Package of type '%s' is not supposed to contain Oak index definitions but has 'allowIndexDefinitions' set to true.\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_INDEX_DEFINITIONS = \"Package of type '%s' is not supposed to contain Oak index definitions but has 'allowIndexDefinitions' set to true.\"", "var_name": "MESSAGE_INDEX_DEFINITIONS"}, {"original_string": "protected static final String MESSAGE_PROHIBITED_MUTABLE_PACKAGE_TYPE = \"All mutable package types are prohibited and this package is of mutable type '%s'\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_PROHIBITED_MUTABLE_PACKAGE_TYPE = \"All mutable package types are prohibited and this package is of mutable type '%s'\"", "var_name": "MESSAGE_PROHIBITED_MUTABLE_PACKAGE_TYPE"}, {"original_string": "protected static final String MESSAGE_PROHIBITED_IMMUTABLE_PACKAGE_TYPE = \"All mutable package types are prohibited and this package is of mutable type '%s'\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_PROHIBITED_IMMUTABLE_PACKAGE_TYPE = \"All mutable package types are prohibited and this package is of mutable type '%s'\"", "var_name": "MESSAGE_PROHIBITED_IMMUTABLE_PACKAGE_TYPE"}, {"original_string": "protected static final String SLING_OSGI_CONFIG = \"sling:OsgiConfig\";", "modifier": "protected static final", "type": "String", "declarator": "SLING_OSGI_CONFIG = \"sling:OsgiConfig\"", "var_name": "SLING_OSGI_CONFIG"}, {"original_string": "protected static final Path PATH_HOOKS = Paths.get(Constants.VAULT_DIR, Constants.HOOKS_DIR);", "modifier": "protected static final", "type": "Path", "declarator": "PATH_HOOKS = Paths.get(Constants.VAULT_DIR, Constants.HOOKS_DIR)", "var_name": "PATH_HOOKS"}, {"original_string": "private final @NotNull PackageType type;", "modifier": "private final @NotNull", "type": "PackageType", "declarator": "type", "var_name": "type"}, {"original_string": "private final @NotNull ValidationMessageSeverity severity;", "modifier": "private final @NotNull", "type": "ValidationMessageSeverity", "declarator": "severity", "var_name": "severity"}, {"original_string": "private final @NotNull ValidationMessageSeverity severityForLegacyType;", "modifier": "private final @NotNull", "type": "ValidationMessageSeverity", "declarator": "severityForLegacyType", "var_name": "severityForLegacyType"}, {"original_string": "private final @NotNull Pattern jcrInstallerNodePathRegex;", "modifier": "private final @NotNull", "type": "Pattern", "declarator": "jcrInstallerNodePathRegex", "var_name": "jcrInstallerNodePathRegex"}, {"original_string": "private final @NotNull Pattern additionalJcrInstallerFileNodePathRegex;", "modifier": "private final @NotNull", "type": "Pattern", "declarator": "additionalJcrInstallerFileNodePathRegex", "var_name": "additionalJcrInstallerFileNodePathRegex"}, {"original_string": "private final @Nullable ValidationContext containerValidationContext;", "modifier": "private final @Nullable", "type": "ValidationContext", "declarator": "containerValidationContext", "var_name": "containerValidationContext"}, {"original_string": "private final ValidationMessageSeverity severityForNoPackageType;", "modifier": "private final", "type": "ValidationMessageSeverity", "declarator": "severityForNoPackageType", "var_name": "severityForNoPackageType"}, {"original_string": "private final boolean prohibitMutableContent;", "modifier": "private final", "type": "boolean", "declarator": "prohibitMutableContent", "var_name": "prohibitMutableContent"}, {"original_string": "private final boolean prohibitImmutableContent;", "modifier": "private final", "type": "boolean", "declarator": "prohibitImmutableContent", "var_name": "prohibitImmutableContent"}, {"original_string": "private final boolean allowComplexFilterRulesInApplicationPackages;", "modifier": "private final", "type": "boolean", "declarator": "allowComplexFilterRulesInApplicationPackages", "var_name": "allowComplexFilterRulesInApplicationPackages"}, {"original_string": "private final @NotNull WorkspaceFilter filter;", "modifier": "private final @NotNull", "type": "WorkspaceFilter", "declarator": "filter", "var_name": "filter"}, {"original_string": "private List<String> validContainerNodePaths;", "modifier": "private", "type": "List<String>", "declarator": "validContainerNodePaths", "var_name": "validContainerNodePaths"}, {"original_string": "private List<NodeContext> potentiallyDisallowedContainerNodes;", "modifier": "private", "type": "List<NodeContext>", "declarator": "potentiallyDisallowedContainerNodes", "var_name": "potentiallyDisallowedContainerNodes"}], "methods": [{"identifier": "PackageTypeValidator", "parameters": "(@NotNull WorkspaceFilter workspaceFilter, @NotNull ValidationMessageSeverity severity,\n            @NotNull ValidationMessageSeverity severityForNoPackageType, @NotNull ValidationMessageSeverity severityForLegacyType,\n            boolean prohibitMutableContent, boolean prohibitImmutableContent, boolean allowComplexFilterRulesInApplicationPackages,\n            @NotNull PackageType type, @NotNull Pattern jcrInstallerNodePathRegex, @NotNull Pattern additionalJcrInstallerFileNodePathRegex,\n            @Nullable ValidationContext containerValidationContext)", "modifiers": "public", "return": "", "signature": " PackageTypeValidator(@NotNull WorkspaceFilter workspaceFilter, @NotNull ValidationMessageSeverity severity,\n            @NotNull ValidationMessageSeverity severityForNoPackageType, @NotNull ValidationMessageSeverity severityForLegacyType,\n            boolean prohibitMutableContent, boolean prohibitImmutableContent, boolean allowComplexFilterRulesInApplicationPackages,\n            @NotNull PackageType type, @NotNull Pattern jcrInstallerNodePathRegex, @NotNull Pattern additionalJcrInstallerFileNodePathRegex,\n            @Nullable ValidationContext containerValidationContext)", "full_signature": "public  PackageTypeValidator(@NotNull WorkspaceFilter workspaceFilter, @NotNull ValidationMessageSeverity severity,\n            @NotNull ValidationMessageSeverity severityForNoPackageType, @NotNull ValidationMessageSeverity severityForLegacyType,\n            boolean prohibitMutableContent, boolean prohibitImmutableContent, boolean allowComplexFilterRulesInApplicationPackages,\n            @NotNull PackageType type, @NotNull Pattern jcrInstallerNodePathRegex, @NotNull Pattern additionalJcrInstallerFileNodePathRegex,\n            @Nullable ValidationContext containerValidationContext)", "class_method_signature": "PackageTypeValidator.PackageTypeValidator(@NotNull WorkspaceFilter workspaceFilter, @NotNull ValidationMessageSeverity severity,\n            @NotNull ValidationMessageSeverity severityForNoPackageType, @NotNull ValidationMessageSeverity severityForLegacyType,\n            boolean prohibitMutableContent, boolean prohibitImmutableContent, boolean allowComplexFilterRulesInApplicationPackages,\n            @NotNull PackageType type, @NotNull Pattern jcrInstallerNodePathRegex, @NotNull Pattern additionalJcrInstallerFileNodePathRegex,\n            @Nullable ValidationContext containerValidationContext)", "testcase": false, "constructor": true}, {"identifier": "isOsgiBundleOrConfiguration", "parameters": "(String nodePath, boolean onlyFile)", "modifiers": "", "return": "boolean", "signature": "boolean isOsgiBundleOrConfiguration(String nodePath, boolean onlyFile)", "full_signature": " boolean isOsgiBundleOrConfiguration(String nodePath, boolean onlyFile)", "class_method_signature": "PackageTypeValidator.isOsgiBundleOrConfiguration(String nodePath, boolean onlyFile)", "testcase": false, "constructor": false}, {"identifier": "isSubPackage", "parameters": "(String nodePath)", "modifiers": "static", "return": "boolean", "signature": "boolean isSubPackage(String nodePath)", "full_signature": "static boolean isSubPackage(String nodePath)", "class_method_signature": "PackageTypeValidator.isSubPackage(String nodePath)", "testcase": false, "constructor": false}, {"identifier": "isAppContent", "parameters": "(String nodePath)", "modifiers": "static", "return": "boolean", "signature": "boolean isAppContent(String nodePath)", "full_signature": "static boolean isAppContent(String nodePath)", "class_method_signature": "PackageTypeValidator.isAppContent(String nodePath)", "testcase": false, "constructor": false}, {"identifier": "done", "parameters": "()", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> done()", "full_signature": "@Override public @Nullable Collection<ValidationMessage> done()", "class_method_signature": "PackageTypeValidator.done()", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(@NotNull NodeContext nodeContext)", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validate(@NotNull NodeContext nodeContext)", "full_signature": "@Override public @Nullable Collection<ValidationMessage> validate(@NotNull NodeContext nodeContext)", "class_method_signature": "PackageTypeValidator.validate(@NotNull NodeContext nodeContext)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(@NotNull WorkspaceFilter filter)", "modifiers": "@Override public", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validate(@NotNull WorkspaceFilter filter)", "full_signature": "@Override public Collection<ValidationMessage> validate(@NotNull WorkspaceFilter filter)", "class_method_signature": "PackageTypeValidator.validate(@NotNull WorkspaceFilter filter)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(@NotNull PackageProperties properties)", "modifiers": "@Override public", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validate(@NotNull PackageProperties properties)", "full_signature": "@Override public Collection<ValidationMessage> validate(@NotNull PackageProperties properties)", "class_method_signature": "PackageTypeValidator.validate(@NotNull PackageProperties properties)", "testcase": false, "constructor": false}, {"identifier": "hasIncludesOrExcludes", "parameters": "(WorkspaceFilter filter)", "modifiers": "static", "return": "boolean", "signature": "boolean hasIncludesOrExcludes(WorkspaceFilter filter)", "full_signature": "static boolean hasIncludesOrExcludes(WorkspaceFilter filter)", "class_method_signature": "PackageTypeValidator.hasIncludesOrExcludes(WorkspaceFilter filter)", "testcase": false, "constructor": false}, {"identifier": "validateSubPackageType", "parameters": "(PackageType packageType, @Nullable PackageType containerPackageType)", "modifiers": "private", "return": "ValidationMessage", "signature": "ValidationMessage validateSubPackageType(PackageType packageType, @Nullable PackageType containerPackageType)", "full_signature": "private ValidationMessage validateSubPackageType(PackageType packageType, @Nullable PackageType containerPackageType)", "class_method_signature": "PackageTypeValidator.validateSubPackageType(PackageType packageType, @Nullable PackageType containerPackageType)", "testcase": false, "constructor": false}, {"identifier": "validateMetaInfPath", "parameters": "(@NotNull Path filePath, @NotNull Path basePath, boolean isFolder)", "modifiers": "@Override public", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validateMetaInfPath(@NotNull Path filePath, @NotNull Path basePath, boolean isFolder)", "full_signature": "@Override public Collection<ValidationMessage> validateMetaInfPath(@NotNull Path filePath, @NotNull Path basePath, boolean isFolder)", "class_method_signature": "PackageTypeValidator.validateMetaInfPath(@NotNull Path filePath, @NotNull Path basePath, boolean isFolder)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(@NotNull DocViewNode node, @NotNull String nodePath,\n            @NotNull Path filePath, boolean isRoot)", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull String nodePath,\n            @NotNull Path filePath, boolean isRoot)", "full_signature": "@Override public @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull String nodePath,\n            @NotNull Path filePath, boolean isRoot)", "class_method_signature": "PackageTypeValidator.validate(@NotNull DocViewNode node, @NotNull String nodePath,\n            @NotNull Path filePath, boolean isRoot)", "testcase": false, "constructor": false}], "file": "vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidator.java"}, "focal_method": {"identifier": "validate", "parameters": "(@NotNull NodeContext nodeContext)", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "body": "@Override\n    public @Nullable Collection<ValidationMessage> validate(@NotNull NodeContext nodeContext) {\n        // ignore uncovered nodePaths\n        if (!filter.covers(nodeContext.getNodePath())) {\n            return null;\n        }\n        Collection<ValidationMessage> messages = new LinkedList<>();\n        switch (type) {\n        case CONTENT:\n            if (isAppContent(nodeContext.getNodePath())) {\n                messages.add(new ValidationMessage(severity, String.format(MESSAGE_APP_CONTENT, type)));\n            }\n            if (isOsgiBundleOrConfiguration(nodeContext.getNodePath(), true)) {\n                messages.add(new ValidationMessage(severity, String.format(MESSAGE_OSGI_BUNDLE_OR_CONFIG, type)));\n            }\n            break;\n        case APPLICATION:\n            if (!isAppContent(nodeContext.getNodePath())) {\n                messages.add(new ValidationMessage(severity, String.format(MESSAGE_NO_APP_CONTENT_FOUND, type)));\n            }\n            if (isOsgiBundleOrConfiguration(nodeContext.getNodePath(), true)) {\n                messages.add(new ValidationMessage(severity, String.format(MESSAGE_OSGI_BUNDLE_OR_CONFIG, type)));\n            }\n            // sub packages are detected via validate(Properties) on the sub package\n            break;\n        case CONTAINER:\n            // sling:OsgiConfig\n            if (isOsgiBundleOrConfiguration(nodeContext.getNodePath(), false)) {\n                validContainerNodePaths.add(nodeContext.getNodePath());\n            }\n            else if (isSubPackage(nodeContext.getNodePath())) {\n                validContainerNodePaths.add(nodeContext.getNodePath());\n            } else {\n                // only potentially disallowed, as the node may be a parent of a sub package or osgi bundle, which is allowed as well\n                potentiallyDisallowedContainerNodes.add(nodeContext);\n            }\n            break;\n        case MIXED:\n            // no validations currently as most relaxed type\n            break;\n        }\n        return messages;\n    }", "signature": "Collection<ValidationMessage> validate(@NotNull NodeContext nodeContext)", "full_signature": "@Override public @Nullable Collection<ValidationMessage> validate(@NotNull NodeContext nodeContext)", "class_method_signature": "PackageTypeValidator.validate(@NotNull NodeContext nodeContext)", "testcase": false, "constructor": false, "invocations": ["covers", "getNodePath", "isAppContent", "getNodePath", "add", "format", "isOsgiBundleOrConfiguration", "getNodePath", "add", "format", "isAppContent", "getNodePath", "add", "format", "isOsgiBundleOrConfiguration", "getNodePath", "add", "format", "isOsgiBundleOrConfiguration", "getNodePath", "add", "getNodePath", "isSubPackage", "getNodePath", "add", "getNodePath", "add"]}, "repository": {"repo_id": 16021499, "url": "https://github.com/apache/jackrabbit-filevault", "stars": 24, "created": "1/18/2014 8:00:07 AM +00:00", "updates": "2020-01-22T11:47:21+00:00", "fork": "False", "license": "licensed"}}