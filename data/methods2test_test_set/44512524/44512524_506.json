{"test_class": {"identifier": "NaiveBayesTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static Logger log = LoggerFactory.getLogger( NaiveBayesTest.class );", "modifier": "static", "type": "Logger", "declarator": "log = LoggerFactory.getLogger( NaiveBayesTest.class )", "var_name": "log"}], "file": "ml/streaminer/src/test/java/org/streaminer/stream/classifier/bayes/NaiveBayesTest.java"}, "test_case": {"identifier": "testLearn", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testLearn() throws Exception {\n            List<Data> dataset = new ArrayList<Data>();\n            \n            ICsvListReader listReader = new CsvListReader(\n                    new FileReader(\"src/test/resources/golf.csv\"), \n                    CsvPreference.EXCEL_NORTH_EUROPE_PREFERENCE);\n            \n            listReader.getHeader(true);\n            \n            List<String> list;\n            while( (list = listReader.read()) != null ) {\n                Data data = new DataImpl();\n                data.put(\"outlook\", list.get(0));\n                data.put(\"temperature\", Integer.parseInt(list.get(1)));\n                data.put(\"humidity\", Integer.parseInt(list.get(2)));\n                data.put(\"wind\", Boolean.parseBoolean(list.get(3)));\n                data.put(\"play\", list.get(4));\n                \n                dataset.add(data);\n            }\n\t\t\n            NaiveBayes nb = new NaiveBayes();\n            nb.setLabelAttribute( \"play\" );\n            \n            \n            for (Data data : dataset) {\n                nb.learn( data );\n            }\n\n\n            Data test = new DataImpl();\n            test.put( \"outlook\", \"sunny\" );\n            test.put( \"temperature\", \"cool\" );\n            test.put( \"humidity\", \"high\" );\n            test.put( \"windy\", \"TRUE\" );\n\n            String prediction = nb.predict( test );\n            log.info( \"item is: {}\", test );\n            log.info( \"Prediction is: {}\", prediction );\n\n            test.put( \"outlook\", \"overcast\" );\n            test.put( \"temperature\", \"mild\" );\n            test.put( \"humidity\", \"normal\" );\n            test.put( \"windy\", \"FALSE\" );\n\n            prediction = nb.predict( test );\n            log.info( \"item is: {}\", test );\n            log.info( \"Prediction is: {}\", prediction );\n\n            //  Ein Trainingsbeispiel:  \"overcast\";\"hot\";\"normal\";\"FALSE\";\"yes\"\n            test.put( \"outlook\", \"overcast\" );\n            test.put( \"temperature\", \"hot\" );\n            test.put( \"humidity\", \"normal\" );\n            test.put( \"windy\", \"FALSE\" );\n\n            prediction = nb.predict( test );\n            log.info( \"item is: {}\", test );\n            log.info( \"Prediction is: {}\", prediction );\n            Assert.assertEquals( \"yes\", prediction );\n\t}", "signature": "void testLearn()", "full_signature": "@Test public void testLearn()", "class_method_signature": "NaiveBayesTest.testLearn()", "testcase": true, "constructor": false, "invocations": ["getHeader", "read", "put", "get", "put", "parseInt", "get", "put", "parseInt", "get", "put", "parseBoolean", "get", "put", "get", "add", "setLabelAttribute", "learn", "put", "put", "put", "put", "predict", "info", "info", "put", "put", "put", "put", "predict", "info", "info", "put", "put", "put", "put", "predict", "info", "info", "assertEquals"]}, "focal_class": {"identifier": "NaiveBayes", "superclass": "extends AbstractClassifier<Data,String>", "interfaces": "", "fields": [{"original_string": "private static final long serialVersionUID = 1095437834368310484L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 1095437834368310484L", "var_name": "serialVersionUID"}, {"original_string": "static Logger log = LoggerFactory.getLogger( NaiveBayes.class );", "modifier": "static", "type": "Logger", "declarator": "log = LoggerFactory.getLogger( NaiveBayes.class )", "var_name": "log"}, {"original_string": "String labelAttribute = null;", "modifier": "", "type": "String", "declarator": "labelAttribute = null", "var_name": "labelAttribute"}, {"original_string": "Double laplaceCorrection = 0.0001;", "modifier": "", "type": "Double", "declarator": "laplaceCorrection = 0.0001", "var_name": "laplaceCorrection"}, {"original_string": "Double confidenceGap = new Double( 0.0d );", "modifier": "", "type": "Double", "declarator": "confidenceGap = new Double( 0.0d )", "var_name": "confidenceGap"}, {"original_string": "Boolean wop = false;", "modifier": "", "type": "Boolean", "declarator": "wop = false", "var_name": "wop"}, {"original_string": "Distribution<String> classDistribution = null;", "modifier": "", "type": "Distribution<String>", "declarator": "classDistribution = null", "var_name": "classDistribution"}, {"original_string": "Map<String,Distribution<?>> distributions = new HashMap<String,Distribution<?>>();", "modifier": "", "type": "Map<String,Distribution<?>>", "declarator": "distributions = new HashMap<String,Distribution<?>>()", "var_name": "distributions"}], "methods": [{"identifier": "NaiveBayes", "parameters": "()", "modifiers": "public", "return": "", "signature": " NaiveBayes()", "full_signature": "public  NaiveBayes()", "class_method_signature": "NaiveBayes.NaiveBayes()", "testcase": false, "constructor": true}, {"identifier": "NaiveBayes", "parameters": "( String labelAttribute )", "modifiers": "public", "return": "", "signature": " NaiveBayes( String labelAttribute )", "full_signature": "public  NaiveBayes( String labelAttribute )", "class_method_signature": "NaiveBayes.NaiveBayes( String labelAttribute )", "testcase": false, "constructor": true}, {"identifier": "getLabelAttribute", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getLabelAttribute()", "full_signature": "public String getLabelAttribute()", "class_method_signature": "NaiveBayes.getLabelAttribute()", "testcase": false, "constructor": false}, {"identifier": "setLabelAttribute", "parameters": "(String labelAttribute)", "modifiers": "public", "return": "void", "signature": "void setLabelAttribute(String labelAttribute)", "full_signature": "public void setLabelAttribute(String labelAttribute)", "class_method_signature": "NaiveBayes.setLabelAttribute(String labelAttribute)", "testcase": false, "constructor": false}, {"identifier": "getLaplaceCorrection", "parameters": "()", "modifiers": "public", "return": "Double", "signature": "Double getLaplaceCorrection()", "full_signature": "public Double getLaplaceCorrection()", "class_method_signature": "NaiveBayes.getLaplaceCorrection()", "testcase": false, "constructor": false}, {"identifier": "setLaplaceCorrection", "parameters": "(Double laplaceCorrection)", "modifiers": "public", "return": "void", "signature": "void setLaplaceCorrection(Double laplaceCorrection)", "full_signature": "public void setLaplaceCorrection(Double laplaceCorrection)", "class_method_signature": "NaiveBayes.setLaplaceCorrection(Double laplaceCorrection)", "testcase": false, "constructor": false}, {"identifier": "getConfidenceGap", "parameters": "()", "modifiers": "public", "return": "Double", "signature": "Double getConfidenceGap()", "full_signature": "public Double getConfidenceGap()", "class_method_signature": "NaiveBayes.getConfidenceGap()", "testcase": false, "constructor": false}, {"identifier": "setConfidenceGap", "parameters": "(Double confidenceGap)", "modifiers": "public", "return": "void", "signature": "void setConfidenceGap(Double confidenceGap)", "full_signature": "public void setConfidenceGap(Double confidenceGap)", "class_method_signature": "NaiveBayes.setConfidenceGap(Double confidenceGap)", "testcase": false, "constructor": false}, {"identifier": "getWop", "parameters": "()", "modifiers": "public", "return": "Boolean", "signature": "Boolean getWop()", "full_signature": "public Boolean getWop()", "class_method_signature": "NaiveBayes.getWop()", "testcase": false, "constructor": false}, {"identifier": "setWop", "parameters": "(Boolean wop)", "modifiers": "public", "return": "void", "signature": "void setWop(Boolean wop)", "full_signature": "public void setWop(Boolean wop)", "class_method_signature": "NaiveBayes.setWop(Boolean wop)", "testcase": false, "constructor": false}, {"identifier": "vote", "parameters": "(Data item)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "Map<String,Double>", "signature": "Map<String,Double> vote(Data item)", "full_signature": "@SuppressWarnings(\"unchecked\") public Map<String,Double> vote(Data item)", "class_method_signature": "NaiveBayes.vote(Data item)", "testcase": false, "constructor": false}, {"identifier": "predict", "parameters": "( Data item )", "modifiers": "@Override public", "return": "String", "signature": "String predict( Data item )", "full_signature": "@Override public String predict( Data item )", "class_method_signature": "NaiveBayes.predict( Data item )", "testcase": false, "constructor": false}, {"identifier": "getNominalCondition", "parameters": "( String attribute, Data item )", "modifiers": "public", "return": "String", "signature": "String getNominalCondition( String attribute, Data item )", "full_signature": "public String getNominalCondition( String attribute, Data item )", "class_method_signature": "NaiveBayes.getNominalCondition( String attribute, Data item )", "testcase": false, "constructor": false}, {"identifier": "learn", "parameters": "(Data item)", "modifiers": "@SuppressWarnings(\"unchecked\") @Override public", "return": "void", "signature": "void learn(Data item)", "full_signature": "@SuppressWarnings(\"unchecked\") @Override public void learn(Data item)", "class_method_signature": "NaiveBayes.learn(Data item)", "testcase": false, "constructor": false}, {"identifier": "getClassDistribution", "parameters": "()", "modifiers": "public", "return": "Distribution<String>", "signature": "Distribution<String> getClassDistribution()", "full_signature": "public Distribution<String> getClassDistribution()", "class_method_signature": "NaiveBayes.getClassDistribution()", "testcase": false, "constructor": false}, {"identifier": "getNumericalDistributions", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "List<Distribution<Double>>", "signature": "List<Distribution<Double>> getNumericalDistributions()", "full_signature": "@SuppressWarnings(\"unchecked\") public List<Distribution<Double>> getNumericalDistributions()", "class_method_signature": "NaiveBayes.getNumericalDistributions()", "testcase": false, "constructor": false}, {"identifier": "createNominalDistribution", "parameters": "()", "modifiers": "public", "return": "Distribution<String>", "signature": "Distribution<String> createNominalDistribution()", "full_signature": "public Distribution<String> createNominalDistribution()", "class_method_signature": "NaiveBayes.createNominalDistribution()", "testcase": false, "constructor": false}, {"identifier": "createNumericalDistribution", "parameters": "()", "modifiers": "public", "return": "Distribution<Double>", "signature": "Distribution<Double> createNumericalDistribution()", "full_signature": "public Distribution<Double> createNumericalDistribution()", "class_method_signature": "NaiveBayes.createNumericalDistribution()", "testcase": false, "constructor": false}], "file": "ml/streaminer/src/main/java/org/streaminer/stream/classifier/bayes/NaiveBayes.java"}, "focal_method": {"identifier": "learn", "parameters": "(Data item)", "modifiers": "@SuppressWarnings(\"unchecked\") @Override public", "return": "void", "body": "@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void learn(Data item) {\n\n\t\t//\n\t\t// determine the label attribute, if not already set\n\t\t//\n\t\tif( labelAttribute == null ){\n\t\t\tfor( String name : item.keySet() )\n\t\t\t\tif( name.startsWith( \"_class\" ) ){\n\t\t\t\t\tlabelAttribute = name;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\n\n\t\tif( item.get( labelAttribute ) == null ){\n\t\t\tlog.warn( \"Not processing unlabeled data item {}\", item );\n\t\t\treturn;\n\t\t}\n\n\t\tString clazz = item.get( labelAttribute ).toString();\n\t\tlog.debug( \"Learning from example with label={}\", clazz );\n\t\tif( this.classDistribution == null )\n\t\t\tthis.classDistribution = new NominalDistributionModel<String>(); //this.createNominalDistribution();\n\n\n\t\tif( log.isDebugEnabled() ){\n\t\t\tlog.debug( \"Classes: {}\", classDistribution.getElements() );\n\t\t\tfor( String t : classDistribution.getElements() )\n\t\t\t\tlog.debug( \"    {}:  {}\", t, classDistribution.getCount( t ) );\n\t\t}\n\t\t//\n\t\t// For learning we update the distributions of each attribute\n\t\t//\n\t\tfor( String attribute : item.keySet() ){\n\n\t\t\tif( attribute.equalsIgnoreCase( labelAttribute ) ){\n\t\t\t\t//\n\t\t\t\t// adjust the class label distribution\n\t\t\t\t//\n\t\t\t\tclassDistribution.update( clazz );\n\n\t\t\t} else {\n\n\t\t\t\tObject obj = item.get( attribute );\n\n\t\t\t\tif( obj.getClass().equals( Double.class ) ){\n\t\t\t\t\tDouble value = (Double) obj;\n\t\t\t\t\tlog.debug( \"Handling numerical case ({}) with value  {}\", obj, value );\n\t\t\t\t\t//\n\t\t\t\t\t// manage the case of an numerical attribute\n\t\t\t\t\t//\n\t\t\t\t\tDistribution<Double> numDist = (Distribution<Double>) distributions.get( attribute );\n\t\t\t\t\tif( numDist == null ){\n\t\t\t\t\t\tnumDist = this.createNumericalDistribution();\n\t\t\t\t\t\tlog.debug( \"Creating new numerical distribution model for attribute {}\", attribute );\n\t\t\t\t\t\tdistributions.put( attribute, numDist );\n\t\t\t\t\t}\n\t\t\t\t\tnumDist.update( value );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tString value = this.getNominalCondition( attribute, item );\n\t\t\t\t\tlog.debug( \"Handling nominal case for [ {} | {} ]\", value, \"class=\" + clazz );\n\n\t\t\t\t\t//\n\t\t\t\t\t// adapt the nominal distribution for this attribute\n\t\t\t\t\t//\n\t\t\t\t\tDistribution<String> nomDist = (Distribution<String>) distributions.get( clazz );\n\t\t\t\t\tif( nomDist == null ){\n\t\t\t\t\t\tnomDist = this.createNominalDistribution();\n\t\t\t\t\t\tlog.debug( \"Creating new nominal distribution model for attribute {}, {}\", attribute, \"class=\" + clazz );\n\t\t\t\t\t\tdistributions.put( clazz, nomDist );\n\t\t\t\t\t}\n\t\t\t\t\tnomDist.update( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "signature": "void learn(Data item)", "full_signature": "@SuppressWarnings(\"unchecked\") @Override public void learn(Data item)", "class_method_signature": "NaiveBayes.learn(Data item)", "testcase": false, "constructor": false, "invocations": ["keySet", "startsWith", "get", "warn", "toString", "get", "debug", "isDebugEnabled", "debug", "getElements", "getElements", "debug", "getCount", "keySet", "equalsIgnoreCase", "update", "get", "equals", "getClass", "debug", "get", "createNumericalDistribution", "debug", "put", "update", "getNominalCondition", "debug", "get", "createNominalDistribution", "debug", "put", "update"]}, "repository": {"repo_id": 44512524, "url": "https://github.com/zqhxuyuan/bigdata", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 8, "size": 91550, "license": "licensed"}}