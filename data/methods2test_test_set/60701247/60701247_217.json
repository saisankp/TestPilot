{"test_class": {"identifier": "PatchInstallerFactoryTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private PatchInstallerFactory myInstallerFactory;", "modifier": "private", "type": "PatchInstallerFactory", "declarator": "myInstallerFactory", "var_name": "myInstallerFactory"}, {"original_string": "private RepoManager myRepoManager;", "modifier": "private", "type": "RepoManager", "declarator": "myRepoManager", "var_name": "myRepoManager"}, {"original_string": "private RepositoryPackages myRepositoryPackages;", "modifier": "private", "type": "RepositoryPackages", "declarator": "myRepositoryPackages", "var_name": "myRepositoryPackages"}, {"original_string": "private MockFileOp myFileOp;", "modifier": "private", "type": "MockFileOp", "declarator": "myFileOp", "var_name": "myFileOp"}, {"original_string": "private static final LocalPackage PATCHER_4 = new FakeLocalPackage(\"patcher;v4\");", "modifier": "private static final", "type": "LocalPackage", "declarator": "PATCHER_4 = new FakeLocalPackage(\"patcher;v4\")", "var_name": "PATCHER_4"}, {"original_string": "private static final LocalPackage PATCHER_2 = new FakeLocalPackage(\"patcher;v2\");", "modifier": "private static final", "type": "LocalPackage", "declarator": "PATCHER_2 = new FakeLocalPackage(\"patcher;v2\")", "var_name": "PATCHER_2"}], "file": "android/testSrc/com/android/tools/idea/sdk/install/patch/PatchInstallerFactoryTest.java"}, "test_case": {"identifier": "cantHandleNoSrcOnWindows", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void cantHandleNoSrcOnWindows() {\n    myFileOp.setIsWindows(true);\n    FakeRemotePackage remote = new FakeRemotePackage(\"foo\");\n    remote.setRevision(new Revision(2));\n    remote.setDependencies(ImmutableList.of(new FakeDependency(PATCHER_4.getPath())));\n    remote.setCompleteUrl(\"http://example.com\");\n    myRepositoryPackages.setLocalPkgInfos(ImmutableList.of(PATCHER_4));\n    myRepositoryPackages.setRemotePkgInfos(ImmutableList.of(remote));\n    assertFalse(myInstallerFactory.canHandlePackage(remote, myRepoManager, myFileOp));\n  }", "signature": "void cantHandleNoSrcOnWindows()", "full_signature": "@Test public void cantHandleNoSrcOnWindows()", "class_method_signature": "PatchInstallerFactoryTest.cantHandleNoSrcOnWindows()", "testcase": true, "constructor": false, "invocations": ["setIsWindows", "setRevision", "setDependencies", "of", "getPath", "setCompleteUrl", "setLocalPkgInfos", "of", "setRemotePkgInfos", "of", "assertFalse", "canHandlePackage"]}, "focal_class": {"identifier": "PatchInstallerFactory", "superclass": "extends AbstractInstallerFactory", "interfaces": "", "fields": [{"original_string": "private static final String KNOWN_GOOD_VERSION = PatchInstallerUtil.PATCHER_PATH_PREFIX + RepoPackage.PATH_SEPARATOR + \"v4\";", "modifier": "private static final", "type": "String", "declarator": "KNOWN_GOOD_VERSION = PatchInstallerUtil.PATCHER_PATH_PREFIX + RepoPackage.PATH_SEPARATOR + \"v4\"", "var_name": "KNOWN_GOOD_VERSION"}, {"original_string": "private static final long PSEUDO_PATCH_CUTOFF = 1024 * 1024 * 100;", "modifier": "private static final", "type": "long", "declarator": "PSEUDO_PATCH_CUTOFF = 1024 * 1024 * 100", "var_name": "PSEUDO_PATCH_CUTOFF"}, {"original_string": "private final PatchRunner.Factory myPatchRunnerFactory;", "modifier": "private final", "type": "PatchRunner.Factory", "declarator": "myPatchRunnerFactory", "var_name": "myPatchRunnerFactory"}], "methods": [{"identifier": "PatchInstallerFactory", "parameters": "()", "modifiers": "public", "return": "", "signature": " PatchInstallerFactory()", "full_signature": "public  PatchInstallerFactory()", "class_method_signature": "PatchInstallerFactory.PatchInstallerFactory()", "testcase": false, "constructor": true}, {"identifier": "PatchInstallerFactory", "parameters": "(@NotNull PatchRunner.Factory runnerFactory)", "modifiers": "@VisibleForTesting", "return": "", "signature": " PatchInstallerFactory(@NotNull PatchRunner.Factory runnerFactory)", "full_signature": "@VisibleForTesting  PatchInstallerFactory(@NotNull PatchRunner.Factory runnerFactory)", "class_method_signature": "PatchInstallerFactory.PatchInstallerFactory(@NotNull PatchRunner.Factory runnerFactory)", "testcase": false, "constructor": true}, {"identifier": "doCreateInstaller", "parameters": "(@NotNull RemotePackage remote,\n                                        @NotNull RepoManager mgr,\n                                        @NotNull Downloader downloader,\n                                        @NotNull FileOp fop)", "modifiers": "@NotNull @Override protected", "return": "Installer", "signature": "Installer doCreateInstaller(@NotNull RemotePackage remote,\n                                        @NotNull RepoManager mgr,\n                                        @NotNull Downloader downloader,\n                                        @NotNull FileOp fop)", "full_signature": "@NotNull @Override protected Installer doCreateInstaller(@NotNull RemotePackage remote,\n                                        @NotNull RepoManager mgr,\n                                        @NotNull Downloader downloader,\n                                        @NotNull FileOp fop)", "class_method_signature": "PatchInstallerFactory.doCreateInstaller(@NotNull RemotePackage remote,\n                                        @NotNull RepoManager mgr,\n                                        @NotNull Downloader downloader,\n                                        @NotNull FileOp fop)", "testcase": false, "constructor": false}, {"identifier": "hasPatch", "parameters": "(@Nullable LocalPackage local, @NotNull RemotePackage remote)", "modifiers": "private static", "return": "boolean", "signature": "boolean hasPatch(@Nullable LocalPackage local, @NotNull RemotePackage remote)", "full_signature": "private static boolean hasPatch(@Nullable LocalPackage local, @NotNull RemotePackage remote)", "class_method_signature": "PatchInstallerFactory.hasPatch(@Nullable LocalPackage local, @NotNull RemotePackage remote)", "testcase": false, "constructor": false}, {"identifier": "doCreateUninstaller", "parameters": "(@NotNull LocalPackage local, @NotNull RepoManager mgr, @NotNull FileOp fop)", "modifiers": "@NotNull @Override protected", "return": "Uninstaller", "signature": "Uninstaller doCreateUninstaller(@NotNull LocalPackage local, @NotNull RepoManager mgr, @NotNull FileOp fop)", "full_signature": "@NotNull @Override protected Uninstaller doCreateUninstaller(@NotNull LocalPackage local, @NotNull RepoManager mgr, @NotNull FileOp fop)", "class_method_signature": "PatchInstallerFactory.doCreateUninstaller(@NotNull LocalPackage local, @NotNull RepoManager mgr, @NotNull FileOp fop)", "testcase": false, "constructor": false}, {"identifier": "canHandlePackage", "parameters": "(@NotNull RepoPackage p, @NotNull RepoManager manager, @NotNull FileOp fop)", "modifiers": "@Override protected", "return": "boolean", "signature": "boolean canHandlePackage(@NotNull RepoPackage p, @NotNull RepoManager manager, @NotNull FileOp fop)", "full_signature": "@Override protected boolean canHandlePackage(@NotNull RepoPackage p, @NotNull RepoManager manager, @NotNull FileOp fop)", "class_method_signature": "PatchInstallerFactory.canHandlePackage(@NotNull RepoPackage p, @NotNull RepoManager manager, @NotNull FileOp fop)", "testcase": false, "constructor": false}], "file": "android/src/com/android/tools/idea/sdk/install/patch/PatchInstallerFactory.java"}, "focal_method": {"identifier": "canHandlePackage", "parameters": "(@NotNull RepoPackage p, @NotNull RepoManager manager, @NotNull FileOp fop)", "modifiers": "@Override protected", "return": "boolean", "body": "@Override\n  protected boolean canHandlePackage(@NotNull RepoPackage p, @NotNull RepoManager manager, @NotNull FileOp fop) {\n    ProgressIndicator progress = new StudioLoggerProgressIndicator(PatchInstallerFactory.class);\n    if (p instanceof LocalPackage) {\n      // Uninstall case. Only useful on windows, since it locks in-use files.\n      if (fop.isWindows()) {\n        try {\n          if (FileUtilKt.recursiveSize(fop.toPath(((LocalPackage)p).getLocation())) >= PSEUDO_PATCH_CUTOFF) {\n            // Don't pseudo-patch if the file is too big.\n            return false;\n          }\n        }\n        catch (IOException e) {\n          // ignore\n        }\n        // Any patcher will do: just see if we have any patcher available.\n        LocalPackage latestPatcher = PatchInstallerUtil.getLatestPatcher(manager);\n        // don't try to use the patcher to uninstall itself\n        return latestPatcher != null && !latestPatcher.equals(p);\n      }\n      else {\n        // Don't use patcher on non-windows.\n        return false;\n      }\n    }\n\n    LocalPackage local = manager.getPackages().getLocalPackages().get(p.getPath());\n    RemotePackage remote = (RemotePackage)p;\n    if (local == null || (!fop.isWindows() && !hasPatch(local, remote))) {\n      // If this isn't an update, or if we're not on windows and there's no patch, there's no reason to use the patcher.\n      return false;\n    }\n\n    if (hasPatch(local, remote)) {\n      // If a patch is available, make sure we can get the patcher itself\n      LocalPackage patcher = PatchInstallerUtil.getDependantPatcher((RemotePackage)p, manager);\n      if (patcher != null && myPatchRunnerFactory.getPatchRunner(patcher, progress, fop) != null) {\n        return true;\n      }\n\n      // Maybe it's not installed yet, but is being installed right now as part of the same operation.\n      if (PatchInstallerUtil.getInProgressDependantPatcherInstall((RemotePackage)p, manager) != null) {\n        return true;\n      }\n\n      // We don't have the right patcher. Give up unless we're on Windows.\n      if (!fop.isWindows()) {\n        return false;\n      }\n    }\n\n    // At this point we must be on Windows.\n    if (((RemotePackage)p).getArchive().getComplete().getSize() >= PSEUDO_PATCH_CUTOFF) {\n      // Don't pseudo-patch if the file is too big.\n      return false;\n    }\n    // There's no patch available, but if a patch installer is installed and better than KNOWN_GOOD_VERSION we can still use it.\n    LocalPackage patcher = PatchInstallerUtil.getLatestPatcher(manager);\n    return patcher != null && PatchInstallerUtil.comparePatcherPaths(patcher.getPath(), KNOWN_GOOD_VERSION) >= 0;\n  }", "signature": "boolean canHandlePackage(@NotNull RepoPackage p, @NotNull RepoManager manager, @NotNull FileOp fop)", "full_signature": "@Override protected boolean canHandlePackage(@NotNull RepoPackage p, @NotNull RepoManager manager, @NotNull FileOp fop)", "class_method_signature": "PatchInstallerFactory.canHandlePackage(@NotNull RepoPackage p, @NotNull RepoManager manager, @NotNull FileOp fop)", "testcase": false, "constructor": false, "invocations": ["isWindows", "recursiveSize", "toPath", "getLocation", "getLatestPatcher", "equals", "get", "getLocalPackages", "getPackages", "getPath", "isWindows", "hasPatch", "hasPatch", "getDependantPatcher", "getPatchRunner", "getInProgressDependantPatcherInstall", "isWindows", "getSize", "getComplete", "getArchive", "getLatestPatcher", "comparePatcherPaths", "getPath"]}, "repository": {"repo_id": 60701247, "url": "https://github.com/JetBrains/android", "stars": 486, "created": "6/8/2016 1:46:48 PM +00:00", "updates": "2020-01-27T16:45:40+00:00", "fork": "False", "license": "licensed"}}