{"test_class": {"identifier": "StringResolverTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "Properties properties;", "modifier": "", "type": "Properties", "declarator": "properties", "var_name": "properties"}], "file": "core/src/test/java/nl/nn/adapterframework/util/StringResolverTest.java"}, "test_case": {"identifier": "resolveComplexProperty", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void resolveComplexProperty() {\n\t\tString result = StringResolver.substVars(properties.getProperty(\"testMultiResolve\"), properties);\n\t\tassertEquals(\"one,two,three_value1value1,my_value2.value1,StageSpecifics_value1.value2.value1\", result);\n\t}", "signature": "void resolveComplexProperty()", "full_signature": "@Test public void resolveComplexProperty()", "class_method_signature": "StringResolverTest.resolveComplexProperty()", "testcase": true, "constructor": false, "invocations": ["substVars", "getProperty", "assertEquals"]}, "focal_class": {"identifier": "StringResolver", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String DELIM_START = \"${\";", "modifier": "private static final", "type": "String", "declarator": "DELIM_START = \"${\"", "var_name": "DELIM_START"}, {"original_string": "private static final char DELIM_STOP = '}';", "modifier": "private static final", "type": "char", "declarator": "DELIM_STOP = '}'", "var_name": "DELIM_STOP"}, {"original_string": "private static final int DELIM_START_LEN = 2;", "modifier": "private static final", "type": "int", "declarator": "DELIM_START_LEN = 2", "var_name": "DELIM_START_LEN"}, {"original_string": "private static final int DELIM_STOP_LEN = 1;", "modifier": "private static final", "type": "int", "declarator": "DELIM_STOP_LEN = 1", "var_name": "DELIM_STOP_LEN"}], "methods": [{"identifier": "StringResolver", "parameters": "()", "modifiers": "public", "return": "", "signature": " StringResolver()", "full_signature": "public  StringResolver()", "class_method_signature": "StringResolver.StringResolver()", "testcase": false, "constructor": true}, {"identifier": "getSystemProperty", "parameters": "(String key, String def)", "modifiers": "public static", "return": "String", "signature": "String getSystemProperty(String key, String def)", "full_signature": "public static String getSystemProperty(String key, String def)", "class_method_signature": "StringResolver.getSystemProperty(String key, String def)", "testcase": false, "constructor": false}, {"identifier": "substVars", "parameters": "(String val, Map props1, Map props2, List<String> propsToHide)", "modifiers": "public static", "return": "String", "signature": "String substVars(String val, Map props1, Map props2, List<String> propsToHide)", "full_signature": "public static String substVars(String val, Map props1, Map props2, List<String> propsToHide)", "class_method_signature": "StringResolver.substVars(String val, Map props1, Map props2, List<String> propsToHide)", "testcase": false, "constructor": false}, {"identifier": "substVars", "parameters": "(String val, Map props1, Map props2)", "modifiers": "public static", "return": "String", "signature": "String substVars(String val, Map props1, Map props2)", "full_signature": "public static String substVars(String val, Map props1, Map props2)", "class_method_signature": "StringResolver.substVars(String val, Map props1, Map props2)", "testcase": false, "constructor": false}, {"identifier": "substVars", "parameters": "(String val, Map props)", "modifiers": "public static", "return": "String", "signature": "String substVars(String val, Map props)", "full_signature": "public static String substVars(String val, Map props)", "class_method_signature": "StringResolver.substVars(String val, Map props)", "testcase": false, "constructor": false}, {"identifier": "needsResolution", "parameters": "(String string)", "modifiers": "public static", "return": "boolean", "signature": "boolean needsResolution(String string)", "full_signature": "public static boolean needsResolution(String string)", "class_method_signature": "StringResolver.needsResolution(String string)", "testcase": false, "constructor": false}, {"identifier": "indexOfDelimStop", "parameters": "(String val, int startPos)", "modifiers": "private static", "return": "int", "signature": "int indexOfDelimStop(String val, int startPos)", "full_signature": "private static int indexOfDelimStop(String val, int startPos)", "class_method_signature": "StringResolver.indexOfDelimStop(String val, int startPos)", "testcase": false, "constructor": false}], "file": "core/src/main/java/nl/nn/adapterframework/util/StringResolver.java"}, "focal_method": {"identifier": "substVars", "parameters": "(String val, Map props1, Map props2, List<String> propsToHide)", "modifiers": "public static", "return": "String", "body": "public static String substVars(String val, Map props1, Map props2, List<String> propsToHide) throws IllegalArgumentException {\n\n\t\tStringBuffer sbuf = new StringBuffer();\n\n\t\tint i = 0;\n\t\tint j, k;\n\n\t\twhile (true) {\n\t\t\tj = val.indexOf(DELIM_START, i);\n\t\t\tif (j == -1) {\n\t\t\t\t// no more variables\n\t\t\t\tif (i == 0) { // this is a simple string\n\t\t\t\t\treturn val;\n\t\t\t\t} else { // add the tail string which contains no variables and return the result.\n\t\t\t\t\tsbuf.append(val.substring(i, val.length()));\n\t\t\t\t\treturn sbuf.toString();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsbuf.append(val.substring(i, j));\n\t\t\t\tk = indexOfDelimStop(val, j);\n\t\t\t\tif (k == -1) {\n\t\t\t\t\tthrow new IllegalArgumentException('[' + val + \"] has no closing brace. Opening brace at position [\" + j + \"]\");\n\t\t\t\t} else {\n\t\t\t\t\tString expression = val.substring(j, k + DELIM_STOP_LEN);\n\t\t\t\t\tj += DELIM_START_LEN;\n\t\t\t\t\tString key = val.substring(j, k);\n\t\t\t\t\tif (key.contains(DELIM_START)) {\n\t\t\t\t\t\tkey = substVars(key, props1, props2);\n\t\t\t\t\t}\n\t\t\t\t\t// first try in System properties\n\t\t\t\t\tString replacement = getSystemProperty(key, null);\n\t\t\t\t\t// then try props parameter\n\t\t\t\t\tif (replacement == null && props1 != null) {\n\t\t\t\t\t\tif (props1 instanceof Properties) {\n\t\t\t\t\t\t\treplacement = ((Properties) props1).getProperty(key);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tObject replacementSource = props1.get(key);\n\t\t\t\t\t\t\tif (replacementSource != null) {\n\t\t\t\t\t\t\t\treplacement = replacementSource.toString();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement == null && props2 != null) {\n\t\t\t\t\t\tif (props2 instanceof Properties) {\n\t\t\t\t\t\t\treplacement = ((Properties) props2).getProperty(key);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tObject replacementSource = props2.get(key);\n\t\t\t\t\t\t\tif (replacementSource != null) {\n\t\t\t\t\t\t\t\treplacement = replacementSource.toString();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (replacement != null) {\n\t\t\t\t\t\tif (propsToHide != null && propsToHide.contains(key)) {\n\t\t\t\t\t\t\treplacement = Misc.hide(replacement);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Do variable substitution on the replacement string\n\t\t\t\t\t\t// such that we can solve \"Hello ${x1}\" as \"Hello p2\"\n\t\t\t\t\t\t// the where the properties are\n\t\t\t\t\t\t// x1=${x2}\n\t\t\t\t\t\t// x2=p2\n\t\t\t\t\t\tif (!replacement.equals(expression)) {\n\t\t\t\t\t\t\tString recursiveReplacement = substVars(replacement, props1, props2);\n\t\t\t\t\t\t\tsbuf.append(recursiveReplacement);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsbuf.append(replacement);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = k + DELIM_STOP_LEN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "signature": "String substVars(String val, Map props1, Map props2, List<String> propsToHide)", "full_signature": "public static String substVars(String val, Map props1, Map props2, List<String> propsToHide)", "class_method_signature": "StringResolver.substVars(String val, Map props1, Map props2, List<String> propsToHide)", "testcase": false, "constructor": false, "invocations": ["indexOf", "append", "substring", "length", "toString", "append", "substring", "indexOfDelimStop", "substring", "substring", "contains", "substVars", "getSystemProperty", "getProperty", "get", "toString", "getProperty", "get", "toString", "contains", "hide", "equals", "substVars", "append", "append"]}, "repository": {"repo_id": 8927606, "url": "https://github.com/ibissource/iaf", "stars": 17, "created": "3/21/2013 11:48:24 AM +00:00", "updates": "2020-01-27T15:25:21+00:00", "fork": "False", "license": "licensed"}}