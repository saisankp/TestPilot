{"test_class": {"identifier": "ComparisonExecutorTest", "superclass": "", "interfaces": "", "fields": [], "file": "spark-job/src/test/java/org/apache/cassandra/diff/ComparisonExecutorTest.java"}, "test_case": {"identifier": "submitBlocksWhenMaxTasksExceeded", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void submitBlocksWhenMaxTasksExceeded() throws Exception {\n        // submit maxTasks, then assert that further submission blocks until tasks are processed\n        int maxTasks = 3;\n        MetricRegistry metrics = metrics();\n        final ComparisonExecutor executor = new ComparisonExecutor(executor(1), maxTasks, metrics);\n        Gauge waitingToSubmit = metrics.getGauges().get(\"BlockedTasks\");\n        assertEquals(0, waitingToSubmit.getValue());\n\n        final AtomicInteger successful = new AtomicInteger(0);\n        final Consumer<Integer> onSuccess = (i) -> successful.incrementAndGet();\n        final AtomicInteger failed = new AtomicInteger(0);\n        final Consumer<Throwable> onError = (t) -> failed.incrementAndGet();\n        final Phaser phaser = new Phaser(1);\n\n        BlockingTask[] tasks = new BlockingTask[5];\n        for (int i=0; i<5; i++)\n            tasks[i] = new BlockingTask(i);\n\n        // Ensure that the submission itself does not block before the max number of tasks are submitted\n        executor.submit(tasks[0], onSuccess, onError, phaser);\n        executor.submit(tasks[1], onSuccess, onError, phaser);\n        executor.submit(tasks[2], onSuccess, onError, phaser);\n        assertEquals(0, waitingToSubmit.getValue());\n\n        // Now submit another pair of tasks which should block as the executor is fully occupied\n        final CountDownLatch latch = new CountDownLatch(2);\n        Thread t1 = new Thread(() -> { latch.countDown(); executor.submit(tasks[3], onSuccess, onError, phaser);});\n        Thread t2 = new Thread(() -> { latch.countDown(); executor.submit(tasks[4], onSuccess, onError, phaser);});\n        t1.start();\n        t2.start();\n        // wait for both to attempt submission\n        latch.await();\n        assertThreadWaits(t1);\n        assertThreadWaits(t2);\n        assertEquals(2, waitingToSubmit.getValue());\n\n        // Let the first waiting task complete, which should allow t1 to complete its submission\n        tasks[0].latch.countDown();\n        t1.join();\n        // the second submission should still be waiting on a slot\n        assertThreadWaits(t2);\n        assertEquals(1, waitingToSubmit.getValue());\n\n        // Let another task complete, allowing t2 to complete its submission\n        tasks[1].latch.countDown();\n        t2.join();\n        assertEquals(0, waitingToSubmit.getValue());\n\n        // Let all tasks complete, wait for them to do so then verify counters\n        for (int i=2; i<=4; i++)\n            tasks[i].latch.countDown();\n\n        phaser.arriveAndAwaitAdvance();\n        assertEquals(5, successful.get());\n        assertEquals(0, failed.get());\n    }", "signature": "void submitBlocksWhenMaxTasksExceeded()", "full_signature": "@Test public void submitBlocksWhenMaxTasksExceeded()", "class_method_signature": "ComparisonExecutorTest.submitBlocksWhenMaxTasksExceeded()", "testcase": true, "constructor": false, "invocations": ["metrics", "executor", "get", "getGauges", "assertEquals", "getValue", "incrementAndGet", "incrementAndGet", "submit", "submit", "submit", "assertEquals", "getValue", "countDown", "submit", "countDown", "submit", "start", "start", "await", "assertThreadWaits", "assertThreadWaits", "assertEquals", "getValue", "countDown", "join", "assertThreadWaits", "assertEquals", "getValue", "countDown", "join", "assertEquals", "getValue", "countDown", "arriveAndAwaitAdvance", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "ComparisonExecutor", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final ListeningExecutorService executor;", "modifier": "private final", "type": "ListeningExecutorService", "declarator": "executor", "var_name": "executor"}, {"original_string": "private final Semaphore semaphore;", "modifier": "private final", "type": "Semaphore", "declarator": "semaphore", "var_name": "semaphore"}], "methods": [{"identifier": "newExecutor", "parameters": "(int maxConcurrentTasks, MetricRegistry metricRegistry)", "modifiers": "static", "return": "ComparisonExecutor", "signature": "ComparisonExecutor newExecutor(int maxConcurrentTasks, MetricRegistry metricRegistry)", "full_signature": "static ComparisonExecutor newExecutor(int maxConcurrentTasks, MetricRegistry metricRegistry)", "class_method_signature": "ComparisonExecutor.newExecutor(int maxConcurrentTasks, MetricRegistry metricRegistry)", "testcase": false, "constructor": false}, {"identifier": "ComparisonExecutor", "parameters": "(ListeningExecutorService executor, int maxTasks, MetricRegistry metrics)", "modifiers": "@VisibleForTesting", "return": "", "signature": " ComparisonExecutor(ListeningExecutorService executor, int maxTasks, MetricRegistry metrics)", "full_signature": "@VisibleForTesting  ComparisonExecutor(ListeningExecutorService executor, int maxTasks, MetricRegistry metrics)", "class_method_signature": "ComparisonExecutor.ComparisonExecutor(ListeningExecutorService executor, int maxTasks, MetricRegistry metrics)", "testcase": false, "constructor": true}, {"identifier": "submit", "parameters": "(final Callable<T> callable,\n                           final Consumer<T> onSuccess,\n                           final Consumer<Throwable> onError,\n                           final Phaser phaser)", "modifiers": "public", "return": "void", "signature": "void submit(final Callable<T> callable,\n                           final Consumer<T> onSuccess,\n                           final Consumer<Throwable> onError,\n                           final Phaser phaser)", "full_signature": "public void submit(final Callable<T> callable,\n                           final Consumer<T> onSuccess,\n                           final Consumer<Throwable> onError,\n                           final Phaser phaser)", "class_method_signature": "ComparisonExecutor.submit(final Callable<T> callable,\n                           final Consumer<T> onSuccess,\n                           final Consumer<Throwable> onError,\n                           final Phaser phaser)", "testcase": false, "constructor": false}, {"identifier": "fireThenReleaseAndArrive", "parameters": "(Consumer<T> callback, T argument, Phaser phaser)", "modifiers": "private", "return": "void", "signature": "void fireThenReleaseAndArrive(Consumer<T> callback, T argument, Phaser phaser)", "full_signature": "private void fireThenReleaseAndArrive(Consumer<T> callback, T argument, Phaser phaser)", "class_method_signature": "ComparisonExecutor.fireThenReleaseAndArrive(Consumer<T> callback, T argument, Phaser phaser)", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "ComparisonExecutor.shutdown()", "testcase": false, "constructor": false}], "file": "spark-job/src/main/java/org/apache/cassandra/diff/ComparisonExecutor.java"}, "focal_method": {"identifier": "submit", "parameters": "(final Callable<T> callable,\n                           final Consumer<T> onSuccess,\n                           final Consumer<Throwable> onError,\n                           final Phaser phaser)", "modifiers": "public", "return": "void", "body": "public <T> void submit(final Callable<T> callable,\n                           final Consumer<T> onSuccess,\n                           final Consumer<Throwable> onError,\n                           final Phaser phaser) {\n\n        phaser.register();\n        semaphore.acquireUninterruptibly();\n        try {\n            Futures.addCallback(executor.submit(callable), new FutureCallback<T>() {\n                public void onSuccess(T result) {\n                    fireThenReleaseAndArrive(onSuccess, result, phaser);\n                }\n\n                public void onFailure(Throwable t) {\n                    fireThenReleaseAndArrive(onError, t, phaser);\n                }\n            }, MoreExecutors.directExecutor());\n\n        } catch (RejectedExecutionException e) {\n            fireThenReleaseAndArrive(onError, e, phaser);\n        }\n\n    }", "signature": "void submit(final Callable<T> callable,\n                           final Consumer<T> onSuccess,\n                           final Consumer<Throwable> onError,\n                           final Phaser phaser)", "full_signature": "public void submit(final Callable<T> callable,\n                           final Consumer<T> onSuccess,\n                           final Consumer<Throwable> onError,\n                           final Phaser phaser)", "class_method_signature": "ComparisonExecutor.submit(final Callable<T> callable,\n                           final Consumer<T> onSuccess,\n                           final Consumer<Throwable> onError,\n                           final Phaser phaser)", "testcase": false, "constructor": false, "invocations": ["register", "acquireUninterruptibly", "addCallback", "submit", "fireThenReleaseAndArrive", "fireThenReleaseAndArrive", "directExecutor", "fireThenReleaseAndArrive"]}, "repository": {"repo_id": 204657216, "url": "https://github.com/apache/cassandra-diff", "language": "Java", "is_fork": false, "fork_count": 9, "stargazer_count": 5, "size": 112, "license": "licensed"}}