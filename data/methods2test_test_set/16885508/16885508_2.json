{"test_class": {"identifier": "CSVWrapperTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final String CSV_FILE_NAME =  \"test.csv.csv\";", "modifier": "private final", "type": "String", "declarator": "CSV_FILE_NAME =  \"test.csv.csv\"", "var_name": "CSV_FILE_NAME"}, {"original_string": "private final String CHECK_POINT_DIR = \"csv-check-points.csv\";", "modifier": "private final", "type": "String", "declarator": "CHECK_POINT_DIR = \"csv-check-points.csv\"", "var_name": "CHECK_POINT_DIR"}], "file": "gsn-core/src/test/java/ch/epfl/gsn/wrappers/general/CSVWrapperTest.java"}, "test_case": {"identifier": "testCheckpoints", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testCheckpoints() throws IOException {\n\t\tString fields = \"TIMED, air_temp , TIMEd , AiR_TeMp2, comments\";\n\t\tString formats = \"Timestamp(d.M.y ) , Numeric , timestamp(k:m) , numeric ,String   \";\n\t\tString data = \"01.01.2009,1,10:10,10,\\\"Ali Salehi\\\"\\n\"+\n\t\t\"01.01.2009,2,10:11,11,\\\"Ali Salehi\\\"\\n\"+\n\t\t\"01.01.2009,3,10:12,12,\\\"Ali Salehi\\\"\\n\";\n\t\tCSVHandler wrapper = new CSVHandler();\n\t\tassertEquals(true,wrapper.initialize(\"test.csv.csv\", fields,formats,',','\\\"',0,\"NaN,-1234,4321\"));\n\t\tArrayList<TreeMap<String, Serializable>> parsed = wrapper.parseValues(new StringReader(data), -1);\n\t\tassertEquals(3, parsed.size());\n\t\tassertEquals(wrapper.work(new StringReader(data), CHECK_POINT_DIR).size(), parsed.size());\n\t\tassertEquals(true,((Long)parsed.get(0).get(\"timed\"))<((Long)parsed.get(1).get(\"timed\")));\n\t\tlong recentTimestamp = ((Long)parsed.get(parsed.size()-1).get(\"timed\"));\n\t\tdata+=\"01.01.2009,3,10:12,12,\\\"Ali Salehi\\\"\\n\";\n\t\tassertEquals(0,wrapper.parseValues(new StringReader(data), recentTimestamp).size());\n\t\tassertEquals(0,wrapper.work(new StringReader(data), CHECK_POINT_DIR).size());\n\t\t\n\t\tdata+=\"01.01.2009,3,10:12,12,\\\"Ali Salehi\\\"\\n\";\n\t\tdata+=\"01.01.2009,3,10:11,12,\\\"Ali Salehi\\\"\\n\";\n\t\tdata+=\"01.01.2009,3,10:10,12,\\\"Ali Salehi\\\"\\n\";\n\t\tassertEquals(0,wrapper.parseValues(new StringReader(data), recentTimestamp).size());\n\t\tassertEquals(0,wrapper.work(new StringReader(data), CHECK_POINT_DIR).size());\n\t\tdata+=\"01.01.2009,3,10:13,13,\\\"Ali Salehi\\\"\\n\";\n\t\tassertEquals(1,wrapper.parseValues(new StringReader(data), recentTimestamp).size());\n\t\tassertEquals(1,wrapper.work(new StringReader(data), CHECK_POINT_DIR).size());\n\t\tdata=\"###########################\\n\\n\\n\\n,,,,,,,,,\\n\\n\\n\"; // Empty File.\n\t\twrapper.setSkipFirstXLines(1);\n\t\tassertEquals(0,wrapper.parseValues(new StringReader(data), recentTimestamp).size());\n\t\tassertEquals(0,wrapper.work(new StringReader(data), CHECK_POINT_DIR).size());\n\t\t\n\t}", "signature": "void testCheckpoints()", "full_signature": "@Test public void testCheckpoints()", "class_method_signature": "CSVWrapperTest.testCheckpoints()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "initialize", "parseValues", "assertEquals", "size", "assertEquals", "size", "work", "size", "assertEquals", "get", "get", "get", "get", "get", "get", "size", "assertEquals", "size", "parseValues", "assertEquals", "size", "work", "assertEquals", "size", "parseValues", "assertEquals", "size", "work", "assertEquals", "size", "parseValues", "assertEquals", "size", "work", "setSkipFirstXLines", "assertEquals", "size", "parseValues", "assertEquals", "size", "work"]}, "focal_class": {"identifier": "CSVWrapper", "superclass": "extends AbstractWrapper", "interfaces": "", "fields": [{"original_string": "private final transient Logger logger = LoggerFactory.getLogger(CSVWrapper.class);", "modifier": "private final transient", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(CSVWrapper.class)", "var_name": "logger"}, {"original_string": "private static int threadCounter = 0;", "modifier": "private static", "type": "int", "declarator": "threadCounter = 0", "var_name": "threadCounter"}, {"original_string": "private DataField[] dataField;", "modifier": "private", "type": "DataField[]", "declarator": "dataField", "var_name": "dataField"}, {"original_string": "private CSVHandler handler = new CSVHandler();", "modifier": "private", "type": "CSVHandler", "declarator": "handler = new CSVHandler()", "var_name": "handler"}, {"original_string": "private int samplingPeriodInMsc;", "modifier": "private", "type": "int", "declarator": "samplingPeriodInMsc", "var_name": "samplingPeriodInMsc"}, {"original_string": "private String checkPointDir;", "modifier": "private", "type": "String", "declarator": "checkPointDir", "var_name": "checkPointDir"}, {"original_string": "private String dataFile;", "modifier": "private", "type": "String", "declarator": "dataFile", "var_name": "dataFile"}, {"original_string": "boolean useCounterForCheckPoint = false;", "modifier": "", "type": "boolean", "declarator": "useCounterForCheckPoint = false", "var_name": "useCounterForCheckPoint"}, {"original_string": "long processedLineCounter = 0;", "modifier": "", "type": "long", "declarator": "processedLineCounter = 0", "var_name": "processedLineCounter"}], "methods": [{"identifier": "initialize", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean initialize()", "full_signature": "public boolean initialize()", "class_method_signature": "CSVWrapper.initialize()", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void run()", "full_signature": "public void run()", "class_method_signature": "CSVWrapper.run()", "testcase": false, "constructor": false}, {"identifier": "getOutputFormat", "parameters": "()", "modifiers": "public", "return": "DataField[]", "signature": "DataField[] getOutputFormat()", "full_signature": "public DataField[] getOutputFormat()", "class_method_signature": "CSVWrapper.getOutputFormat()", "testcase": false, "constructor": false}, {"identifier": "getWrapperName", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getWrapperName()", "full_signature": "public String getWrapperName()", "class_method_signature": "CSVWrapper.getWrapperName()", "testcase": false, "constructor": false}, {"identifier": "dispose", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void dispose()", "full_signature": "public void dispose()", "class_method_signature": "CSVWrapper.dispose()", "testcase": false, "constructor": false}, {"identifier": "DEBUG_INFO", "parameters": "(String s)", "modifiers": "public", "return": "void", "signature": "void DEBUG_INFO(String s)", "full_signature": "public void DEBUG_INFO(String s)", "class_method_signature": "CSVWrapper.DEBUG_INFO(String s)", "testcase": false, "constructor": false}, {"identifier": "list", "parameters": "(String name, long value)", "modifiers": "", "return": "String", "signature": "String list(String name, long value)", "full_signature": " String list(String name, long value)", "class_method_signature": "CSVWrapper.list(String name, long value)", "testcase": false, "constructor": false}], "file": "gsn-core/src/main/java/ch/epfl/gsn/wrappers/general/CSVWrapper.java"}, "focal_method": {"identifier": "initialize", "parameters": "()", "modifiers": "public", "return": "boolean", "body": "public boolean initialize() {\n        AddressBean addressBean = getActiveAddressBean();\n        dataFile = addressBean.getPredicateValueWithException(\"file\");\n        String csvFields = addressBean.getPredicateValueWithException(\"fields\");\n        String csvFormats = addressBean.getPredicateValueWithException(\"formats\");\n        //String csvSeparator = addressBean.getPredicateValueWithDefault(\"separator\",\",\");\n        String value = addressBean.getPredicateValue(\"separator\");\n        String csvSeparator = (value == null || value.length() == 0) ? \",\" : value;\n        checkPointDir = addressBean.getPredicateValueWithDefault(\"check-point-directory\", \"./csv-check-points\");\n        String csvStringQuote = addressBean.getPredicateValueWithDefault(\"quote\", \"\\\"\");\n        int skipFirstXLine = addressBean.getPredicateValueAsInt(\"skip-first-lines\", 0);\n        String timezone = addressBean.getPredicateValueWithDefault(\"timezone\", handler.LOCAL_TIMEZONE_ID);\n        String nullValues = addressBean.getPredicateValueWithDefault(\"bad-values\", \"\");\n        String strUseCounterForCheckPoint = addressBean.getPredicateValueWithDefault(\"use-counter-for-check-point\", \"false\");\n        samplingPeriodInMsc = addressBean.getPredicateValueAsInt(\"sampling\", 10000);\n\n        /*\n        DEBUG_INFO(dataFile);\n        */\n\n        if (csvSeparator != null && csvSeparator.length() != 1) {\n            logger.warn(\"The provided CSV separator:>\" + csvSeparator + \"< should only have  1 character, thus ignored and instead \\\",\\\" is used.\");\n            csvSeparator = \",\";\n        }\n\n        if (csvStringQuote.length() != 1) {\n            logger.warn(\"The provided CSV quote:>\" + csvSeparator + \"< should only have 1 character, thus ignored and instead '\\\"' is used.\");\n            csvStringQuote = \"\\\"\";\n        }\n\n        try {\n            if (strUseCounterForCheckPoint.equalsIgnoreCase(\"true\")) {\n                useCounterForCheckPoint = true;\n                logger.warn(\"Using counter-based check points\");\n            }\n            //String checkPointFile = new File(checkPointDir).getAbsolutePath()+\"/\"+(new File(dataFile).getName())+\"-\"+addressBean.hashCode();\n            StringBuilder checkPointFile = new StringBuilder()\n                    .append(new File(checkPointDir).getAbsolutePath())\n                    .append(\"/\")\n                    .append(addressBean.getVirtualSensorName())\n                    .append(\"_\")\n                    .append(addressBean.getInputStreamName())\n                    .append(\"_\")\n                    .append(addressBean.getWrapper())\n                    .append(\"_\")\n                    .append(new File(dataFile).getName());\n            if (!handler.initialize(dataFile.trim(), csvFields, csvFormats, csvSeparator.toCharArray()[0], csvStringQuote.toCharArray()[0], skipFirstXLine, nullValues, timezone, checkPointFile.toString()))\n                return false;\n\n            String val = FileUtils.readFileToString(new File(checkPointFile.toString()), \"UTF-8\");\n            long lastItem = 0;\n            if (val != null && val.trim().length() > 0)\n                lastItem = Long.parseLong(val.trim());\n            logger.warn(\"Latest item: \"+lastItem);\n\n            if (useCounterForCheckPoint) {\n                processedLineCounter = lastItem;\n            }\n\n        } catch (Exception e) {\n            logger.error(\"Loading the csv-wrapper failed:\" + e.getMessage(), e);\n            return false;\n        }\n\n        dataField = handler.getDataFields();\n\n        logger.warn(\"Reading from: \" + dataFile);\n\n        return true;\n    }", "signature": "boolean initialize()", "full_signature": "public boolean initialize()", "class_method_signature": "CSVWrapper.initialize()", "testcase": false, "constructor": false, "invocations": ["getActiveAddressBean", "getPredicateValueWithException", "getPredicateValueWithException", "getPredicateValueWithException", "getPredicateValue", "length", "getPredicateValueWithDefault", "getPredicateValueWithDefault", "getPredicateValueAsInt", "getPredicateValueWithDefault", "getPredicateValueWithDefault", "getPredicateValueWithDefault", "getPredicateValueAsInt", "length", "warn", "length", "warn", "equalsIgnoreCase", "warn", "append", "append", "append", "append", "append", "append", "append", "append", "append", "getAbsolutePath", "getVirtualSensorName", "getInputStreamName", "getWrapper", "getName", "initialize", "trim", "toCharArray", "toCharArray", "toString", "readFileToString", "toString", "length", "trim", "parseLong", "trim", "warn", "error", "getMessage", "getDataFields", "warn"]}, "repository": {"repo_id": 16885508, "url": "https://github.com/LSIR/gsn", "language": "Java", "is_fork": false, "fork_count": 41, "stargazer_count": 51, "size": 375887, "license": "licensed"}}