{"test_class": {"identifier": "TestJMSCore", "superclass": "extends TestJMSBase", "interfaces": "", "fields": [{"original_string": "NoSendJMSCore core;", "modifier": "", "type": "NoSendJMSCore", "declarator": "core", "var_name": "core"}, {"original_string": "String sourceName;", "modifier": "", "type": "String", "declarator": "sourceName", "var_name": "sourceName"}, {"original_string": "String authToken;", "modifier": "", "type": "String", "declarator": "authToken", "var_name": "authToken"}, {"original_string": "String targetVantiqServer;", "modifier": "", "type": "String", "declarator": "targetVantiqServer", "var_name": "targetVantiqServer"}, {"original_string": "JMS jms;", "modifier": "", "type": "JMS", "declarator": "jms", "var_name": "jms"}], "file": "jmsSource/src/test/java/io/vantiq/extsrc/jmsSource/TestJMSCore.java"}, "test_case": {"identifier": "testIncorrectQueryRequests", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testIncorrectQueryRequests() {        \n        Map<String, Object> request;\n        ExtensionServiceMessage msg = new ExtensionServiceMessage(\"\");\n        Map<String, String> header = new LinkedHashMap<>();\n        header.put(ExtensionServiceMessage.ORIGIN_ADDRESS_HEADER, \"queryAddress\");\n        msg.messageHeaders = header;\n        \n        // Sending empty query request\n        request = new LinkedHashMap<>();\n        msg.object = request;\n        core.readQueueMessage(msg);\n        assertFalse(\"Core should not be closed\", core.isClosed());\n        \n        // Sending jibberish as query request\n        request = new LinkedHashMap<>();\n        request.put(\"query\", \"jibberish\");\n        msg.object = request;\n        core.readQueueMessage(msg);\n        assertFalse(\"Core should not be closed\", core.isClosed());\n    }", "signature": "void testIncorrectQueryRequests()", "full_signature": "@Test public void testIncorrectQueryRequests()", "class_method_signature": "TestJMSCore.testIncorrectQueryRequests()", "testcase": true, "constructor": false, "invocations": ["put", "readQueueMessage", "assertFalse", "isClosed", "put", "readQueueMessage", "assertFalse", "isClosed"]}, "focal_class": {"identifier": "JMSCore", "superclass": "", "interfaces": "", "fields": [{"original_string": "String initialContextCheck = null;", "modifier": "", "type": "String", "declarator": "initialContextCheck = null", "var_name": "initialContextCheck"}, {"original_string": "String sourceName;", "modifier": "", "type": "String", "declarator": "sourceName", "var_name": "sourceName"}, {"original_string": "String authToken;", "modifier": "", "type": "String", "declarator": "authToken", "var_name": "authToken"}, {"original_string": "String targetVantiqServer;", "modifier": "", "type": "String", "declarator": "targetVantiqServer", "var_name": "targetVantiqServer"}, {"original_string": "JMSHandleConfiguration jmsConfigHandler;", "modifier": "", "type": "JMSHandleConfiguration", "declarator": "jmsConfigHandler", "var_name": "jmsConfigHandler"}, {"original_string": "ExtensionWebSocketClient client = null;", "modifier": "", "type": "ExtensionWebSocketClient", "declarator": "client = null", "var_name": "client"}, {"original_string": "JMS jms = null;", "modifier": "", "type": "JMS", "declarator": "jms = null", "var_name": "jms"}, {"original_string": "final Logger log;", "modifier": "final", "type": "Logger", "declarator": "log", "var_name": "log"}, {"original_string": "final static int RECONNECT_INTERVAL = 5000;", "modifier": "final static", "type": "int", "declarator": "RECONNECT_INTERVAL = 5000", "var_name": "RECONNECT_INTERVAL"}, {"original_string": "final static int CONNECTION_TIMEOUT = 10;", "modifier": "final static", "type": "int", "declarator": "CONNECTION_TIMEOUT = 10", "var_name": "CONNECTION_TIMEOUT"}, {"original_string": "private static final String SYNCH_LOCK = \"synchLock\";", "modifier": "private static final", "type": "String", "declarator": "SYNCH_LOCK = \"synchLock\"", "var_name": "SYNCH_LOCK"}, {"original_string": "public final Handler<ExtensionServiceMessage> reconnectHandler = new Handler<ExtensionServiceMessage>() {\n        @Override\n        public void handleMessage(ExtensionServiceMessage message) {\n            log.trace(\"Reconnect message received. Reinitializing configuration\");\n\n            jmsConfigHandler.configComplete = false;\n\n            CompletableFuture<Boolean> success = client.connectToSource();\n\n            try {\n                if ( !success.get(CONNECTION_TIMEOUT, TimeUnit.SECONDS) ) {\n                    if (!client.isOpen()) {\n                        log.error(\"Failed to connect to server url '\" + targetVantiqServer + \"'.\");\n                    } else if (!client.isAuthed()) {\n                        log.error(\"Failed to authenticate within 10 seconds using the given authentication data.\");\n                    } else {\n                        log.error(\"Failed to connect within 10 seconds\");\n                    }\n                    close();\n                }\n            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                log.error(\"Could not reconnect to source within 10 seconds: \", e);\n                close();\n            }\n        }\n    };", "modifier": "public final", "type": "Handler<ExtensionServiceMessage>", "declarator": "reconnectHandler = new Handler<ExtensionServiceMessage>() {\n        @Override\n        public void handleMessage(ExtensionServiceMessage message) {\n            log.trace(\"Reconnect message received. Reinitializing configuration\");\n\n            jmsConfigHandler.configComplete = false;\n\n            CompletableFuture<Boolean> success = client.connectToSource();\n\n            try {\n                if ( !success.get(CONNECTION_TIMEOUT, TimeUnit.SECONDS) ) {\n                    if (!client.isOpen()) {\n                        log.error(\"Failed to connect to server url '\" + targetVantiqServer + \"'.\");\n                    } else if (!client.isAuthed()) {\n                        log.error(\"Failed to authenticate within 10 seconds using the given authentication data.\");\n                    } else {\n                        log.error(\"Failed to connect within 10 seconds\");\n                    }\n                    close();\n                }\n            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                log.error(\"Could not reconnect to source within 10 seconds: \", e);\n                close();\n            }\n        }\n    }", "var_name": "reconnectHandler"}, {"original_string": "public final Handler<ExtensionWebSocketClient> closeHandler = new Handler<ExtensionWebSocketClient>() {\n        @Override\n        public void handleMessage(ExtensionWebSocketClient message) {\n            log.trace(\"WebSocket closed unexpectedly. Attempting to reconnect\");\n\n            jmsConfigHandler.configComplete = false;\n\n            boolean sourcesSucceeded = false;\n            while (!sourcesSucceeded) {\n                client.initiateFullConnection(targetVantiqServer, authToken);\n                sourcesSucceeded = exitIfConnectionFails(client, CONNECTION_TIMEOUT);\n                if (!sourcesSucceeded) {\n                    try {\n                        Thread.sleep(RECONNECT_INTERVAL);\n                    } catch (InterruptedException e) {\n                        log.error(\"An error occurred when trying to sleep the current thread. Error Message: \", e);\n                    }\n                }\n            }\n        }\n    };", "modifier": "public final", "type": "Handler<ExtensionWebSocketClient>", "declarator": "closeHandler = new Handler<ExtensionWebSocketClient>() {\n        @Override\n        public void handleMessage(ExtensionWebSocketClient message) {\n            log.trace(\"WebSocket closed unexpectedly. Attempting to reconnect\");\n\n            jmsConfigHandler.configComplete = false;\n\n            boolean sourcesSucceeded = false;\n            while (!sourcesSucceeded) {\n                client.initiateFullConnection(targetVantiqServer, authToken);\n                sourcesSucceeded = exitIfConnectionFails(client, CONNECTION_TIMEOUT);\n                if (!sourcesSucceeded) {\n                    try {\n                        Thread.sleep(RECONNECT_INTERVAL);\n                    } catch (InterruptedException e) {\n                        log.error(\"An error occurred when trying to sleep the current thread. Error Message: \", e);\n                    }\n                }\n            }\n        }\n    }", "var_name": "closeHandler"}], "methods": [{"identifier": "JMSCore", "parameters": "(String sourceName, String authToken, String targetVantiqServer)", "modifiers": "public", "return": "", "signature": " JMSCore(String sourceName, String authToken, String targetVantiqServer)", "full_signature": "public  JMSCore(String sourceName, String authToken, String targetVantiqServer)", "class_method_signature": "JMSCore.JMSCore(String sourceName, String authToken, String targetVantiqServer)", "testcase": false, "constructor": true}, {"identifier": "getSourceName", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getSourceName()", "full_signature": "public String getSourceName()", "class_method_signature": "JMSCore.getSourceName()", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "(int timeout)", "modifiers": "public", "return": "boolean", "signature": "boolean start(int timeout)", "full_signature": "public boolean start(int timeout)", "class_method_signature": "JMSCore.start(int timeout)", "testcase": false, "constructor": false}, {"identifier": "sendJMSMessage", "parameters": "(ExtensionServiceMessage message)", "modifiers": "public", "return": "void", "signature": "void sendJMSMessage(ExtensionServiceMessage message)", "full_signature": "public void sendJMSMessage(ExtensionServiceMessage message)", "class_method_signature": "JMSCore.sendJMSMessage(ExtensionServiceMessage message)", "testcase": false, "constructor": false}, {"identifier": "readQueueMessage", "parameters": "(ExtensionServiceMessage message)", "modifiers": "public", "return": "void", "signature": "void readQueueMessage(ExtensionServiceMessage message)", "full_signature": "public void readQueueMessage(ExtensionServiceMessage message)", "class_method_signature": "JMSCore.readQueueMessage(ExtensionServiceMessage message)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "JMSCore.close()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void stop()", "full_signature": "public void stop()", "class_method_signature": "JMSCore.stop()", "testcase": false, "constructor": false}, {"identifier": "exitIfConnectionFails", "parameters": "(ExtensionWebSocketClient client, int timeout)", "modifiers": "public", "return": "boolean", "signature": "boolean exitIfConnectionFails(ExtensionWebSocketClient client, int timeout)", "full_signature": "public boolean exitIfConnectionFails(ExtensionWebSocketClient client, int timeout)", "class_method_signature": "JMSCore.exitIfConnectionFails(ExtensionWebSocketClient client, int timeout)", "testcase": false, "constructor": false}], "file": "jmsSource/src/main/java/io/vantiq/extsrc/jmsSource/JMSCore.java"}, "focal_method": {"identifier": "readQueueMessage", "parameters": "(ExtensionServiceMessage message)", "modifiers": "public", "return": "void", "body": "public void readQueueMessage(ExtensionServiceMessage message) {\n      Map<String, ?> request = (Map<String, ?>) message.getObject();\n      String replyAddress = ExtensionServiceMessage.extractReplyAddress(message);\n      \n      // Get local copy of JMS\n      JMS localJMS;\n      synchronized (SYNCH_LOCK) {\n          localJMS = jms;\n      }\n      \n      // Make sure JMS is safe to use (has not been closed)\n      if (localJMS == null) {\n          if (client != null) {\n              client.sendQueryError(replyAddress, this.getClass().getName() + \".closed\",\n                      \"JMS connection closed before operation could complete.\", null);\n          } else {\n              log.error(\"JMS connection closed before operation could complete.\");\n          }\n      } else {\n          // Retrieve most recent message from specified queue. If no queue name is specified, or if exception is thrown, return query error.\n          if (request.get(\"queue\") instanceof String) {\n              String queue = (String) request.get(\"queue\");\n              int timeout = -1;\n              if (request.get(\"timeout\") instanceof Integer && (Integer) request.get(\"timeout\") > 0) {\n                  timeout = (Integer) request.get(\"timeout\");\n              }\n              try {\n                  Map<String, Object> messageMap = localJMS.consumeMessage(queue, timeout);\n                  if (messageMap == null) {\n                      client.sendQueryError(replyAddress, this.getClass().getName() + \".invalidMessage\", \n                              \"The returned message was invalid. This is most likely because the MessageHandler did not format \"\n                              + \"the returned message, headers, properties, and queue name correctly.\", null);\n                  } else {\n                      client.sendQueryResponse(200, replyAddress, messageMap);\n                  }\n              } catch (JMSException e) {\n                  client.sendQueryError(replyAddress, JMSException.class.getCanonicalName(), \n                          \"Failed to read message from the queue: \" + queue + \". Error message was: \" + e.getMessage(), null);\n              } catch (DestinationNotConfiguredException e) {\n                  client.sendQueryError(replyAddress, DestinationNotConfiguredException.class.getCanonicalName(), \n                          \"Failed to read message from the queue: \" + queue + \". The source was not configured to read from \"\n                                  + \"this queue.\", null);\n              } catch(UnsupportedJMSMessageTypeException e) {\n                  client.sendQueryError(replyAddress, UnsupportedJMSMessageTypeException.class.getCanonicalName(), \n                          \"Failed to read message from the queue: \" + queue + \". The incoming JMS Message Type was: \" + e.getMessage()\n                                  + \", which is not currently supported.\", null);\n              } catch (Exception e) {\n                  client.sendQueryError(replyAddress, Exception.class.getCanonicalName(), \n                          \"An unexpected error occured when reading message from queue: \" + queue + \". Error message was: \" \n                          + e.getMessage(), null);\n              }\n          } else {\n              client.sendQueryError(replyAddress, this.getClass().getName() + \".noQueue\", \n                      \"No queue was specified as a query parameter. Query cannot be completed.\", null);\n          }\n      }\n    }", "signature": "void readQueueMessage(ExtensionServiceMessage message)", "full_signature": "public void readQueueMessage(ExtensionServiceMessage message)", "class_method_signature": "JMSCore.readQueueMessage(ExtensionServiceMessage message)", "testcase": false, "constructor": false, "invocations": ["getObject", "extractReplyAddress", "sendQueryError", "getName", "getClass", "error", "get", "get", "get", "get", "get", "consumeMessage", "sendQueryError", "getName", "getClass", "sendQueryResponse", "sendQueryError", "getCanonicalName", "getMessage", "sendQueryError", "getCanonicalName", "sendQueryError", "getCanonicalName", "getMessage", "sendQueryError", "getCanonicalName", "getMessage", "sendQueryError", "getName", "getClass"]}, "repository": {"repo_id": 141492069, "url": "https://github.com/Vantiq/vantiq-extension-sources", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 9, "size": 16261, "license": "licensed"}}