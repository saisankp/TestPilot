{"test_class": {"identifier": "LocalSnapshotStoreTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String PERSISTENCE_ID = \"member-1-shard-default-config\";", "modifier": "private static final", "type": "String", "declarator": "PERSISTENCE_ID = \"member-1-shard-default-config\"", "var_name": "PERSISTENCE_ID"}, {"original_string": "private static final String PREFIX_BASED_SHARD_PERSISTENCE_ID = \"member-1-shard-id-ints!-config\";", "modifier": "private static final", "type": "String", "declarator": "PREFIX_BASED_SHARD_PERSISTENCE_ID = \"member-1-shard-id-ints!-config\"", "var_name": "PREFIX_BASED_SHARD_PERSISTENCE_ID"}, {"original_string": "private static ActorSystem system;", "modifier": "private static", "type": "ActorSystem", "declarator": "system", "var_name": "system"}, {"original_string": "private static ActorRef snapshotStore;", "modifier": "private static", "type": "ActorRef", "declarator": "snapshotStore", "var_name": "snapshotStore"}], "file": "opendaylight/md-sal/sal-clustering-commons/src/test/java/org/opendaylight/controller/cluster/persistence/LocalSnapshotStoreTest.java"}, "test_case": {"identifier": "testDoLoadAsync", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDoLoadAsync() throws IOException {\n        createSnapshotFile(PERSISTENCE_ID, \"one\", 0, 1000);\n        createSnapshotFile(PERSISTENCE_ID, \"two\", 1, 2000);\n        createSnapshotFile(PERSISTENCE_ID, \"three\", 1, 3000);\n\n        createSnapshotFile(PREFIX_BASED_SHARD_PERSISTENCE_ID, \"foo\", 0, 1000);\n        createSnapshotFile(PREFIX_BASED_SHARD_PERSISTENCE_ID, \"bar\", 1, 2000);\n        createSnapshotFile(PREFIX_BASED_SHARD_PERSISTENCE_ID, \"foobar\", 1, 3000);\n\n        createSnapshotFile(\"member-1-shard-default-oper\", \"foo\", 0, 1000);\n        createSnapshotFile(\"member-1-shard-toaster-oper\", \"foo\", 0, 1000);\n        new File(SNAPSHOT_DIR, \"other\").createNewFile();\n        new File(SNAPSHOT_DIR, \"other-1485349217290\").createNewFile();\n\n        SnapshotMetadata metadata3 = new SnapshotMetadata(PERSISTENCE_ID, 1, 3000);\n\n        TestKit probe = new TestKit(system);\n        snapshotStore.tell(new LoadSnapshot(PERSISTENCE_ID,\n                SnapshotSelectionCriteria.latest(), Long.MAX_VALUE), probe.getRef());\n        LoadSnapshotResult result = probe.expectMsgClass(LoadSnapshotResult.class);\n        Option<SelectedSnapshot> possibleSnapshot = result.snapshot();\n\n        assertEquals(\"SelectedSnapshot present\", TRUE, possibleSnapshot.nonEmpty());\n        assertEquals(\"SelectedSnapshot metadata\", metadata3, possibleSnapshot.get().metadata());\n        assertEquals(\"SelectedSnapshot snapshot\", \"three\", possibleSnapshot.get().snapshot());\n\n        snapshotStore.tell(new LoadSnapshot(PREFIX_BASED_SHARD_PERSISTENCE_ID,\n                SnapshotSelectionCriteria.latest(), Long.MAX_VALUE), probe.getRef());\n        result = probe.expectMsgClass(LoadSnapshotResult.class);\n        possibleSnapshot = result.snapshot();\n\n        SnapshotMetadata prefixBasedShardMetada3 = new SnapshotMetadata(PREFIX_BASED_SHARD_PERSISTENCE_ID, 1, 3000);\n\n        assertEquals(\"SelectedSnapshot present\", TRUE, possibleSnapshot.nonEmpty());\n        assertEquals(\"SelectedSnapshot metadata\", prefixBasedShardMetada3, possibleSnapshot.get().metadata());\n        assertEquals(\"SelectedSnapshot snapshot\", \"foobar\", possibleSnapshot.get().snapshot());\n    }", "signature": "void testDoLoadAsync()", "full_signature": "@Test public void testDoLoadAsync()", "class_method_signature": "LocalSnapshotStoreTest.testDoLoadAsync()", "testcase": true, "constructor": false, "invocations": ["createSnapshotFile", "createSnapshotFile", "createSnapshotFile", "createSnapshotFile", "createSnapshotFile", "createSnapshotFile", "createSnapshotFile", "createSnapshotFile", "createNewFile", "createNewFile", "tell", "latest", "getRef", "expectMsgClass", "snapshot", "assertEquals", "nonEmpty", "assertEquals", "metadata", "get", "assertEquals", "snapshot", "get", "tell", "latest", "getRef", "expectMsgClass", "snapshot", "assertEquals", "nonEmpty", "assertEquals", "metadata", "get", "assertEquals", "snapshot", "get"]}, "focal_class": {"identifier": "LocalSnapshotStore", "superclass": "extends SnapshotStore", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(LocalSnapshotStore.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(LocalSnapshotStore.class)", "var_name": "LOG"}, {"original_string": "private static final int PERSISTENCE_ID_START_INDEX = \"snapshot-\".length();", "modifier": "private static final", "type": "int", "declarator": "PERSISTENCE_ID_START_INDEX = \"snapshot-\".length()", "var_name": "PERSISTENCE_ID_START_INDEX"}, {"original_string": "private final InputOutputStreamFactory streamFactory;", "modifier": "private final", "type": "InputOutputStreamFactory", "declarator": "streamFactory", "var_name": "streamFactory"}, {"original_string": "private final ExecutionContext executionContext;", "modifier": "private final", "type": "ExecutionContext", "declarator": "executionContext", "var_name": "executionContext"}, {"original_string": "private final int maxLoadAttempts;", "modifier": "private final", "type": "int", "declarator": "maxLoadAttempts", "var_name": "maxLoadAttempts"}, {"original_string": "private final File snapshotDir;", "modifier": "private final", "type": "File", "declarator": "snapshotDir", "var_name": "snapshotDir"}], "methods": [{"identifier": "LocalSnapshotStore", "parameters": "(final Config config)", "modifiers": "public", "return": "", "signature": " LocalSnapshotStore(final Config config)", "full_signature": "public  LocalSnapshotStore(final Config config)", "class_method_signature": "LocalSnapshotStore.LocalSnapshotStore(final Config config)", "testcase": false, "constructor": true}, {"identifier": "preStart", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void preStart()", "full_signature": "@Override public void preStart()", "class_method_signature": "LocalSnapshotStore.preStart()", "testcase": false, "constructor": false}, {"identifier": "doLoadAsync", "parameters": "(final String persistenceId,\n                                                          final SnapshotSelectionCriteria criteria)", "modifiers": "@Override public", "return": "Future<Optional<SelectedSnapshot>>", "signature": "Future<Optional<SelectedSnapshot>> doLoadAsync(final String persistenceId,\n                                                          final SnapshotSelectionCriteria criteria)", "full_signature": "@Override public Future<Optional<SelectedSnapshot>> doLoadAsync(final String persistenceId,\n                                                          final SnapshotSelectionCriteria criteria)", "class_method_signature": "LocalSnapshotStore.doLoadAsync(final String persistenceId,\n                                                          final SnapshotSelectionCriteria criteria)", "testcase": false, "constructor": false}, {"identifier": "doLoad", "parameters": "(final Deque<SnapshotMetadata> metadatas)", "modifiers": "private", "return": "Optional<SelectedSnapshot>", "signature": "Optional<SelectedSnapshot> doLoad(final Deque<SnapshotMetadata> metadatas)", "full_signature": "private Optional<SelectedSnapshot> doLoad(final Deque<SnapshotMetadata> metadatas)", "class_method_signature": "LocalSnapshotStore.doLoad(final Deque<SnapshotMetadata> metadatas)", "testcase": false, "constructor": false}, {"identifier": "deserialize", "parameters": "(final File file)", "modifiers": "private", "return": "Object", "signature": "Object deserialize(final File file)", "full_signature": "private Object deserialize(final File file)", "class_method_signature": "LocalSnapshotStore.deserialize(final File file)", "testcase": false, "constructor": false}, {"identifier": "tryDeserializeAkkaSnapshot", "parameters": "(final File file)", "modifiers": "private", "return": "Object", "signature": "Object tryDeserializeAkkaSnapshot(final File file)", "full_signature": "private Object tryDeserializeAkkaSnapshot(final File file)", "class_method_signature": "LocalSnapshotStore.tryDeserializeAkkaSnapshot(final File file)", "testcase": false, "constructor": false}, {"identifier": "doSaveAsync", "parameters": "(final SnapshotMetadata metadata, final Object snapshot)", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> doSaveAsync(final SnapshotMetadata metadata, final Object snapshot)", "full_signature": "@Override public Future<Void> doSaveAsync(final SnapshotMetadata metadata, final Object snapshot)", "class_method_signature": "LocalSnapshotStore.doSaveAsync(final SnapshotMetadata metadata, final Object snapshot)", "testcase": false, "constructor": false}, {"identifier": "doSave", "parameters": "(final SnapshotMetadata metadata, final Object snapshot)", "modifiers": "private", "return": "Void", "signature": "Void doSave(final SnapshotMetadata metadata, final Object snapshot)", "full_signature": "private Void doSave(final SnapshotMetadata metadata, final Object snapshot)", "class_method_signature": "LocalSnapshotStore.doSave(final SnapshotMetadata metadata, final Object snapshot)", "testcase": false, "constructor": false}, {"identifier": "doDeleteAsync", "parameters": "(final SnapshotMetadata metadata)", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> doDeleteAsync(final SnapshotMetadata metadata)", "full_signature": "@Override public Future<Void> doDeleteAsync(final SnapshotMetadata metadata)", "class_method_signature": "LocalSnapshotStore.doDeleteAsync(final SnapshotMetadata metadata)", "testcase": false, "constructor": false}, {"identifier": "doDeleteAsync", "parameters": "(final String persistenceId, final SnapshotSelectionCriteria criteria)", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> doDeleteAsync(final String persistenceId, final SnapshotSelectionCriteria criteria)", "full_signature": "@Override public Future<Void> doDeleteAsync(final String persistenceId, final SnapshotSelectionCriteria criteria)", "class_method_signature": "LocalSnapshotStore.doDeleteAsync(final String persistenceId, final SnapshotSelectionCriteria criteria)", "testcase": false, "constructor": false}, {"identifier": "doDelete", "parameters": "(final String persistenceId, final SnapshotSelectionCriteria criteria)", "modifiers": "private", "return": "Void", "signature": "Void doDelete(final String persistenceId, final SnapshotSelectionCriteria criteria)", "full_signature": "private Void doDelete(final String persistenceId, final SnapshotSelectionCriteria criteria)", "class_method_signature": "LocalSnapshotStore.doDelete(final String persistenceId, final SnapshotSelectionCriteria criteria)", "testcase": false, "constructor": false}, {"identifier": "doDelete", "parameters": "(final SnapshotMetadata metadata)", "modifiers": "private", "return": "Void", "signature": "Void doDelete(final SnapshotMetadata metadata)", "full_signature": "private Void doDelete(final SnapshotMetadata metadata)", "class_method_signature": "LocalSnapshotStore.doDelete(final SnapshotMetadata metadata)", "testcase": false, "constructor": false}, {"identifier": "getSnapshotFiles", "parameters": "(final String persistenceId)", "modifiers": "private", "return": "Collection<File>", "signature": "Collection<File> getSnapshotFiles(final String persistenceId)", "full_signature": "private Collection<File> getSnapshotFiles(final String persistenceId)", "class_method_signature": "LocalSnapshotStore.getSnapshotFiles(final String persistenceId)", "testcase": false, "constructor": false}, {"identifier": "getSnapshotFiles", "parameters": "(final SnapshotMetadata metadata)", "modifiers": "private", "return": "Collection<File>", "signature": "Collection<File> getSnapshotFiles(final SnapshotMetadata metadata)", "full_signature": "private Collection<File> getSnapshotFiles(final SnapshotMetadata metadata)", "class_method_signature": "LocalSnapshotStore.getSnapshotFiles(final SnapshotMetadata metadata)", "testcase": false, "constructor": false}, {"identifier": "getSnapshotMetadatas", "parameters": "(final String persistenceId,\n            final SnapshotSelectionCriteria criteria)", "modifiers": "private", "return": "Collection<SnapshotMetadata>", "signature": "Collection<SnapshotMetadata> getSnapshotMetadatas(final String persistenceId,\n            final SnapshotSelectionCriteria criteria)", "full_signature": "private Collection<SnapshotMetadata> getSnapshotMetadatas(final String persistenceId,\n            final SnapshotSelectionCriteria criteria)", "class_method_signature": "LocalSnapshotStore.getSnapshotMetadatas(final String persistenceId,\n            final SnapshotSelectionCriteria criteria)", "testcase": false, "constructor": false}, {"identifier": "toStream", "parameters": "(final @Nullable SnapshotMetadata md)", "modifiers": "private static", "return": "Stream<SnapshotMetadata>", "signature": "Stream<SnapshotMetadata> toStream(final @Nullable SnapshotMetadata md)", "full_signature": "private static Stream<SnapshotMetadata> toStream(final @Nullable SnapshotMetadata md)", "class_method_signature": "LocalSnapshotStore.toStream(final @Nullable SnapshotMetadata md)", "testcase": false, "constructor": false}, {"identifier": "extractMetadata", "parameters": "(final File file)", "modifiers": "private static @Nullable", "return": "SnapshotMetadata", "signature": "SnapshotMetadata extractMetadata(final File file)", "full_signature": "private static @Nullable SnapshotMetadata extractMetadata(final File file)", "class_method_signature": "LocalSnapshotStore.extractMetadata(final File file)", "testcase": false, "constructor": false}, {"identifier": "toSnapshotFile", "parameters": "(final SnapshotMetadata metadata)", "modifiers": "private", "return": "File", "signature": "File toSnapshotFile(final SnapshotMetadata metadata)", "full_signature": "private File toSnapshotFile(final SnapshotMetadata metadata)", "class_method_signature": "LocalSnapshotStore.toSnapshotFile(final SnapshotMetadata metadata)", "testcase": false, "constructor": false}, {"identifier": "reverse", "parameters": "()", "modifiers": "private static", "return": "Collector<T, ?, List<T>>", "signature": "Collector<T, ?, List<T>> reverse()", "full_signature": "private static Collector<T, ?, List<T>> reverse()", "class_method_signature": "LocalSnapshotStore.reverse()", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(final String str)", "modifiers": "private static", "return": "String", "signature": "String encode(final String str)", "full_signature": "private static String encode(final String str)", "class_method_signature": "LocalSnapshotStore.encode(final String str)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(final String str)", "modifiers": "private static", "return": "String", "signature": "String decode(final String str)", "full_signature": "private static String decode(final String str)", "class_method_signature": "LocalSnapshotStore.decode(final String str)", "testcase": false, "constructor": false}, {"identifier": "compare", "parameters": "(final SnapshotMetadata m1, final SnapshotMetadata m2)", "modifiers": "@VisibleForTesting static", "return": "int", "signature": "int compare(final SnapshotMetadata m1, final SnapshotMetadata m2)", "full_signature": "@VisibleForTesting static int compare(final SnapshotMetadata m1, final SnapshotMetadata m2)", "class_method_signature": "LocalSnapshotStore.compare(final SnapshotMetadata m1, final SnapshotMetadata m2)", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-clustering-commons/src/main/java/org/opendaylight/controller/cluster/persistence/LocalSnapshotStore.java"}, "focal_method": {"identifier": "doLoadAsync", "parameters": "(final String persistenceId,\n                                                          final SnapshotSelectionCriteria criteria)", "modifiers": "@Override public", "return": "Future<Optional<SelectedSnapshot>>", "body": "@Override\n    public Future<Optional<SelectedSnapshot>> doLoadAsync(final String persistenceId,\n                                                          final SnapshotSelectionCriteria criteria) {\n        LOG.debug(\"In doLoadAsync - persistenceId: {}, criteria: {}\", persistenceId, criteria);\n\n        // Select the youngest 'maxLoadAttempts' snapshots that match the criteria. This may help in situations where\n        // saving of a snapshot could not be completed because of a JVM crash. Hence, an attempt to load that snapshot\n        // will fail but loading an older snapshot may succeed.\n\n        Deque<SnapshotMetadata> metadatas = getSnapshotMetadatas(persistenceId, criteria).stream()\n                .sorted(LocalSnapshotStore::compare).collect(reverse()).stream().limit(maxLoadAttempts)\n                    .collect(Collectors.toCollection(ArrayDeque::new));\n\n        if (metadatas.isEmpty()) {\n            return Futures.successful(Optional.empty());\n        }\n\n        LOG.debug(\"doLoadAsync - found: {}\", metadatas);\n\n        return Futures.future(() -> doLoad(metadatas), executionContext);\n    }", "signature": "Future<Optional<SelectedSnapshot>> doLoadAsync(final String persistenceId,\n                                                          final SnapshotSelectionCriteria criteria)", "full_signature": "@Override public Future<Optional<SelectedSnapshot>> doLoadAsync(final String persistenceId,\n                                                          final SnapshotSelectionCriteria criteria)", "class_method_signature": "LocalSnapshotStore.doLoadAsync(final String persistenceId,\n                                                          final SnapshotSelectionCriteria criteria)", "testcase": false, "constructor": false, "invocations": ["debug", "collect", "limit", "stream", "collect", "sorted", "stream", "getSnapshotMetadatas", "reverse", "toCollection", "isEmpty", "successful", "empty", "debug", "future", "doLoad"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}