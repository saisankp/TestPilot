{"test_class": {"identifier": "EasterVariableTest", "superclass": "", "interfaces": "", "fields": [], "file": "jtstoolkit/src/test/java/ec/tstoolkit/timeseries/regression/EasterVariableTest.java"}, "test_case": {"identifier": "testShort", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testShort() {\n        EasterVariable var = new EasterVariable();\n        DataBlock x = new DataBlock(12), y = new DataBlock(12);\n        TsPeriod start = new TsPeriod(TsFrequency.Monthly, 1980, 0);\n        var.data(start, x);\n\n        for (int i = 0; i < 12; ++i) {\n            DataBlock yc = y.range(i, i+1);\n            var.data(start, yc);\n            start.move(1);\n        }\n        assertTrue(x.distance(y)==0);\n    }", "signature": "void testShort()", "full_signature": "@Test public void testShort()", "class_method_signature": "EasterVariableTest.testShort()", "testcase": true, "constructor": false, "invocations": ["data", "range", "data", "move", "assertTrue", "distance"]}, "focal_class": {"identifier": "EasterVariable", "superclass": "extends AbstractSingleTsVariable", "interfaces": "implements IEasterVariable", "fields": [{"original_string": "private static final double[] EMeans_Feb = new double[]{0.00368E0, 0.002083333E0, 0.001130435E0, 0.0002727273E0, 0E0,\n        0E0, 0E0, 0E0, 0E0, 0E0,\n        0E0, 0E0, 0E0, 0E0, 0E0,\n        0E0, 0E0, 0E0, 0E0, 0E0,\n        0E0, 0E0, 0E0, 0E0, 0E0};", "modifier": "private static final", "type": "double[]", "declarator": "EMeans_Feb = new double[]{0.00368E0, 0.002083333E0, 0.001130435E0, 0.0002727273E0, 0E0,\n        0E0, 0E0, 0E0, 0E0, 0E0,\n        0E0, 0E0, 0E0, 0E0, 0E0,\n        0E0, 0E0, 0E0, 0E0, 0E0,\n        0E0, 0E0, 0E0, 0E0, 0E0}", "var_name": "EMeans_Feb"}, {"original_string": "private static final double[] EMeans_Mar = new double[]{0.6576E0, 0.6450833E0, 0.6311304E0, 0.6162727E0, 0.5999048E0,\n        0.583E0, 0.5661053E0, 0.549E0, 0.5318824E0, 0.514625E0,\n        0.4973333E0, 0.4807143E0, 0.4643077E0, 0.4476667E0, 0.4305455E0,\n        0.4136E0, 0.3975556E0, 0.382E0, 0.3654286E0, 0.3483333E0,\n        0.3304E0, 0.3125E0, 0.2966667E0, 0.281E0, 0.266E0};", "modifier": "private static final", "type": "double[]", "declarator": "EMeans_Mar = new double[]{0.6576E0, 0.6450833E0, 0.6311304E0, 0.6162727E0, 0.5999048E0,\n        0.583E0, 0.5661053E0, 0.549E0, 0.5318824E0, 0.514625E0,\n        0.4973333E0, 0.4807143E0, 0.4643077E0, 0.4476667E0, 0.4305455E0,\n        0.4136E0, 0.3975556E0, 0.382E0, 0.3654286E0, 0.3483333E0,\n        0.3304E0, 0.3125E0, 0.2966667E0, 0.281E0, 0.266E0}", "var_name": "EMeans_Mar"}, {"original_string": "private static final double[] EMeans_Apr = new double[]{0.33872E0, 0.3528333E0, 0.3677391E0, 0.3834545E0, 0.4000952E0,\n        0.417E0, 0.4338947E0, 0.451E0, 0.4681176E0, 0.485375E0,\n        0.5026667E0, 0.5192857E0, 0.5356923E0, 0.5523333E0, 0.5694545E0,\n        0.5864E0, 0.6024444E0, 0.618E0, 0.6345714E0, 0.6516667E0,\n        0.6696E0, 0.6875E0, 0.7033333E0, 0.719E0, 0.734E0};", "modifier": "private static final", "type": "double[]", "declarator": "EMeans_Apr = new double[]{0.33872E0, 0.3528333E0, 0.3677391E0, 0.3834545E0, 0.4000952E0,\n        0.417E0, 0.4338947E0, 0.451E0, 0.4681176E0, 0.485375E0,\n        0.5026667E0, 0.5192857E0, 0.5356923E0, 0.5523333E0, 0.5694545E0,\n        0.5864E0, 0.6024444E0, 0.618E0, 0.6345714E0, 0.6516667E0,\n        0.6696E0, 0.6875E0, 0.7033333E0, 0.719E0, 0.734E0}", "var_name": "EMeans_Apr"}, {"original_string": "private int dur_ = 6;", "modifier": "private", "type": "int", "declarator": "dur_ = 6", "var_name": "dur_"}, {"original_string": "private Correction type_ = Correction.Simple;", "modifier": "private", "type": "Correction", "declarator": "type_ = Correction.Simple", "var_name": "type_"}, {"original_string": "private boolean m_e, m_m;", "modifier": "private", "type": "boolean", "declarator": "m_e", "var_name": "m_e"}], "methods": [{"identifier": "EasterVariable", "parameters": "()", "modifiers": "public", "return": "", "signature": " EasterVariable()", "full_signature": "public  EasterVariable()", "class_method_signature": "EasterVariable.EasterVariable()", "testcase": false, "constructor": true}, {"identifier": "getDuration", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getDuration()", "full_signature": "@Override public int getDuration()", "class_method_signature": "EasterVariable.getDuration()", "testcase": false, "constructor": false}, {"identifier": "setDuration", "parameters": "(int value)", "modifiers": "@Override public", "return": "void", "signature": "void setDuration(int value)", "full_signature": "@Override public void setDuration(int value)", "class_method_signature": "EasterVariable.setDuration(int value)", "testcase": false, "constructor": false}, {"identifier": "getType", "parameters": "()", "modifiers": "public", "return": "Correction", "signature": "Correction getType()", "full_signature": "public Correction getType()", "class_method_signature": "EasterVariable.getType()", "testcase": false, "constructor": false}, {"identifier": "setType", "parameters": "(Correction value)", "modifiers": "public", "return": "void", "signature": "void setType(Correction value)", "full_signature": "public void setType(Correction value)", "class_method_signature": "EasterVariable.setType(Correction value)", "testcase": false, "constructor": false}, {"identifier": "hasEaster", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean hasEaster()", "full_signature": "public boolean hasEaster()", "class_method_signature": "EasterVariable.hasEaster()", "testcase": false, "constructor": false}, {"identifier": "hasEasterMonday", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean hasEasterMonday()", "full_signature": "public boolean hasEasterMonday()", "class_method_signature": "EasterVariable.hasEasterMonday()", "testcase": false, "constructor": false}, {"identifier": "includeEaster", "parameters": "(boolean included)", "modifiers": "public", "return": "void", "signature": "void includeEaster(boolean included)", "full_signature": "public void includeEaster(boolean included)", "class_method_signature": "EasterVariable.includeEaster(boolean included)", "testcase": false, "constructor": false}, {"identifier": "includeEasterMonday", "parameters": "(boolean included)", "modifiers": "public", "return": "void", "signature": "void includeEasterMonday(boolean included)", "full_signature": "public void includeEasterMonday(boolean included)", "class_method_signature": "EasterVariable.includeEasterMonday(boolean included)", "testcase": false, "constructor": false}, {"identifier": "getDescription", "parameters": "(TsFrequency context)", "modifiers": "@Override public", "return": "String", "signature": "String getDescription(TsFrequency context)", "full_signature": "@Override public String getDescription(TsFrequency context)", "class_method_signature": "EasterVariable.getDescription(TsFrequency context)", "testcase": false, "constructor": false}, {"identifier": "data", "parameters": "(TsPeriod start, DataBlock data)", "modifiers": "@Override public", "return": "void", "signature": "void data(TsPeriod start, DataBlock data)", "full_signature": "@Override public void data(TsPeriod start, DataBlock data)", "class_method_signature": "EasterVariable.data(TsPeriod start, DataBlock data)", "testcase": false, "constructor": false}, {"identifier": "isSignificant", "parameters": "(TsDomain domain)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isSignificant(TsDomain domain)", "full_signature": "@Override public boolean isSignificant(TsDomain domain)", "class_method_signature": "EasterVariable.isSignificant(TsDomain domain)", "testcase": false, "constructor": false}], "file": "jtstoolkit/src/main/java/ec/tstoolkit/timeseries/regression/EasterVariable.java"}, "focal_method": {"identifier": "data", "parameters": "(TsPeriod start, DataBlock data)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void data(TsPeriod start, DataBlock data) {\n        data.set(0);\n        int freq = start.getFrequency().intValue();\n        if ((freq != 12 && freq != 4) || dur_ < 1 || dur_ > 25) {\n            return;\n        }\n        int n = data.getLength();\n        int c = 12 / freq;\n        int y0 = start.getYear();\n        int p0 = start.getPosition() * c;\n        if (p0 > 3) {\n            p0 -= 12;\n            ++y0;\n        }\n        // first april\n        int idx = (3 - p0) / c;\n        if (idx > n) {\n            return;\n        }\n\n        double dur = dur_;\n\n\n        GregorianCalendar easter = new GregorianCalendar();\n        for (int y = y0; idx <= n; ++y, idx += freq) {\n            easter.setTime(Utilities.easter(y).getTime());\n            // DAY_OF_MONTH is 1-based\n            int day = easter.get(GregorianCalendar.DAY_OF_MONTH);\n            int month = easter.get(GregorianCalendar.MONTH);\n            if (!m_e) {\n                --day;\n            } else if (m_m) {\n                if (day == 31) {\n                    day = 1;\n                    ++month;\n                } else {\n                    ++day;\n                }\n            }\n\n            // MONTH is 0-based\n            double m = 0, a = 0;\n            if (type_ == Correction.Simple) {\n                if (month == 2 || day == 0) {\n                    m = .5;\n                    a = -.5;\n                } else if (day >= dur_) {\n                    m = -.5;\n                    a = .5;\n                } else {\n                    m = (dur - day) / dur - .5;\n                    a = -m;\n                }\n            } else // use long mean correction. Mean correction should be adapted\n            // to take into account the new solution proposed in tramo (easter, easter monday)\n            // included in the holiday\n            {\n                double m_av = 0, a_av = 0;\n                if (type_ == Correction.PreComputed) {\n                    m_av = EMeans_Mar[25 - dur_]; //(21 + dur) / 70.0;\n                    a_av = EMeans_Apr[25 - dur_];//(49 - dur) / 70.0;\n                } else {\n                    /*\n                     * Raw estimation of the probability to get Easter at a specific date is defined below:\n                     * 22/3 (1/7)*1/LUNARY\n                     * 23/3 (2/7)*1/LUNARY\n                     * ...\n                     * 27/3 (6/7)*1/LUNARY\n                     * 28/3 1/LUNARY\n                     * ...\n                     * 18/4 1/LUNARY\n                     * 19/4 1/LUNARY + (1/7) * DEC_LUNARY/LUNARY = (7 + DEC_LUNARY)/(7 * LUNARY)\n                     * 20/4 (6/7)*1/LUNARY + (1/7) * DEC_LUNARY/LUNARY = (6 + DEC_LUNARY)/(7 * LUNARY)\n                     * 21/4 (5/7)*1/LUNARY + (1/7) * DEC_LUNARY/LUNARY\n                     * 22/4 (4/7)*1/LUNARY + (1/7) * DEC_LUNARY/LUNARY\n                     * 23/4 (3/7)*1/LUNARY + (1/7) * DEC_LUNARY/LUNARY\n                     * 24/4 (2/7)*1/LUNARY + (1/7) * DEC_LUNARY/LUNARY\n                     * 25/4 (1/7)*1/LUNARY + (1/7) * DEC_LUNARY/LUNARY\n                     * \n                     * In comparison with long term (5700000 years) computations based on several algorithms,\n                     * the error is small (< 0.0025)\n                     * \n                     * The average number in march, folliwng dur (<= 15 !!!) is computed as follow:\n                     * + for period 22/3 to 27/3: always in march\n                     *    dur * (1/7 + ... + 6/7)/LUNARY = dur * 3 / LUNARY \n                     * + for period 28/3 to 1/4: always in march\n                     *    dur * 5 / LUNARY\n                     * + for period 2/4 to dur/4\n                     *    (dur-1 + dur-2 + 1) / LUNARY = dur * (dur-1) / (2 * LUNARY)\n                     * + for other dates: 0\n                     * \n                     * Total:\n                     *   dur * (6+10+dur-1)/ (2* LUNARY) = dur * 15 / (2 * LUNARY)\n                     * Relative part:\n                     *   15 / (2* LUNARY)\n                     */\n                    m_av = (15 + dur) / (2 * Utilities.LUNARY);\n                    a_av = 1 - m_av;\n                }\n                if (month == 2) {\n                    m = 1 - m_av;\n                    a = -a_av;\n                } else if (day >= dur_) {\n                    m = -m_av;\n                    a = 1 - a_av;\n                } else {\n                    m = (dur - day) / dur - m_av;\n                    a = day / dur - a_av;\n                }\n            }\n\n            if (idx - 1 >= 0) {\n                data.set(idx - 1, m);\n            }\n            if (idx < n) {\n                data.set(idx, a);\n            }\n        }\n    }", "signature": "void data(TsPeriod start, DataBlock data)", "full_signature": "@Override public void data(TsPeriod start, DataBlock data)", "class_method_signature": "EasterVariable.data(TsPeriod start, DataBlock data)", "testcase": false, "constructor": false, "invocations": ["set", "intValue", "getFrequency", "getLength", "getYear", "getPosition", "setTime", "getTime", "easter", "get", "get", "set", "set"]}, "repository": {"repo_id": 28178086, "url": "https://github.com/jdemetra/jdemetra-core", "stars": 24, "created": "12/18/2014 10:00:58 AM +00:00", "updates": "2020-01-17T15:50:24+00:00", "fork": "False", "license": "licensed"}}