{"test_class": {"identifier": "InnerJoinOperatorBaseTest", "superclass": "", "interfaces": "implements Serializable", "fields": [], "file": "flink-core/src/test/java/org/apache/flink/api/common/operators/base/InnerJoinOperatorBaseTest.java"}, "test_case": {"identifier": "testJoinPlain", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testJoinPlain(){\n\t\tfinal FlatJoinFunction<String, String, Integer> joiner = new FlatJoinFunction<String, String, Integer>() {\n\n\t\t\t@Override\n\t\t\tpublic void join(String first, String second, Collector<Integer> out) throws Exception {\n\t\t\t\tout.collect(first.length());\n\t\t\t\tout.collect(second.length());\n\t\t\t}\n\t\t};\n\n\t\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\t\tInnerJoinOperatorBase<String, String, Integer,\n\t\t\t\t\t\tFlatJoinFunction<String, String,Integer> > base = new InnerJoinOperatorBase(joiner,\n\t\t\t\tnew BinaryOperatorInformation(BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO,\n\t\t\t\t\t\tBasicTypeInfo.INT_TYPE_INFO), new int[0], new int[0], \"TestJoiner\");\n\n\t\tList<String> inputData1 = new ArrayList<String>(Arrays.asList(\"foo\", \"bar\", \"foobar\"));\n\t\tList<String> inputData2 = new ArrayList<String>(Arrays.asList(\"foobar\", \"foo\"));\n\t\tList<Integer> expected = new ArrayList<Integer>(Arrays.asList(3, 3, 6 ,6));\n\n\t\ttry {\n\t\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\t\texecutionConfig.disableObjectReuse();\n\t\t\tList<Integer> resultSafe = base.executeOnCollections(inputData1, inputData2, null, executionConfig);\n\t\t\texecutionConfig.enableObjectReuse();\n\t\t\tList<Integer> resultRegular = base.executeOnCollections(inputData1, inputData2, null, executionConfig);\n\n\t\t\tassertEquals(expected, resultSafe);\n\t\t\tassertEquals(expected, resultRegular);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}", "signature": "void testJoinPlain()", "full_signature": "@Test public void testJoinPlain()", "class_method_signature": "InnerJoinOperatorBaseTest.testJoinPlain()", "testcase": true, "constructor": false, "invocations": ["collect", "length", "collect", "length", "asList", "asList", "asList", "disableObjectReuse", "executeOnCollections", "enableObjectReuse", "executeOnCollections", "assertEquals", "assertEquals", "printStackTrace", "fail", "getMessage"]}, "focal_class": {"identifier": "InnerJoinOperatorBase", "superclass": "extends JoinOperatorBase<IN1, IN2, OUT, FT>", "interfaces": "", "fields": [], "methods": [{"identifier": "InnerJoinOperatorBase", "parameters": "(UserCodeWrapper<FT> udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo,\n\t\t\tint[] keyPositions1, int[] keyPositions2, String name)", "modifiers": "public", "return": "", "signature": " InnerJoinOperatorBase(UserCodeWrapper<FT> udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo,\n\t\t\tint[] keyPositions1, int[] keyPositions2, String name)", "full_signature": "public  InnerJoinOperatorBase(UserCodeWrapper<FT> udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo,\n\t\t\tint[] keyPositions1, int[] keyPositions2, String name)", "class_method_signature": "InnerJoinOperatorBase.InnerJoinOperatorBase(UserCodeWrapper<FT> udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo,\n\t\t\tint[] keyPositions1, int[] keyPositions2, String name)", "testcase": false, "constructor": true}, {"identifier": "InnerJoinOperatorBase", "parameters": "(FT udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo, int[] keyPositions1,\n\t\t\tint[] keyPositions2, String name)", "modifiers": "public", "return": "", "signature": " InnerJoinOperatorBase(FT udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo, int[] keyPositions1,\n\t\t\tint[] keyPositions2, String name)", "full_signature": "public  InnerJoinOperatorBase(FT udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo, int[] keyPositions1,\n\t\t\tint[] keyPositions2, String name)", "class_method_signature": "InnerJoinOperatorBase.InnerJoinOperatorBase(FT udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo, int[] keyPositions1,\n\t\t\tint[] keyPositions2, String name)", "testcase": false, "constructor": true}, {"identifier": "InnerJoinOperatorBase", "parameters": "(Class<? extends FT> udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo,\n\t\t\tint[] keyPositions1, int[] keyPositions2, String name)", "modifiers": "public", "return": "", "signature": " InnerJoinOperatorBase(Class<? extends FT> udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo,\n\t\t\tint[] keyPositions1, int[] keyPositions2, String name)", "full_signature": "public  InnerJoinOperatorBase(Class<? extends FT> udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo,\n\t\t\tint[] keyPositions1, int[] keyPositions2, String name)", "class_method_signature": "InnerJoinOperatorBase.InnerJoinOperatorBase(Class<? extends FT> udf, BinaryOperatorInformation<IN1, IN2, OUT> operatorInfo,\n\t\t\tint[] keyPositions1, int[] keyPositions2, String name)", "testcase": false, "constructor": true}, {"identifier": "executeOnCollections", "parameters": "(List<IN1> inputData1, List<IN2> inputData2, RuntimeContext runtimeContext,\n\t\t\tExecutionConfig executionConfig)", "modifiers": "@SuppressWarnings(\"unchecked\") @Override protected", "return": "List<OUT>", "signature": "List<OUT> executeOnCollections(List<IN1> inputData1, List<IN2> inputData2, RuntimeContext runtimeContext,\n\t\t\tExecutionConfig executionConfig)", "full_signature": "@SuppressWarnings(\"unchecked\") @Override protected List<OUT> executeOnCollections(List<IN1> inputData1, List<IN2> inputData2, RuntimeContext runtimeContext,\n\t\t\tExecutionConfig executionConfig)", "class_method_signature": "InnerJoinOperatorBase.executeOnCollections(List<IN1> inputData1, List<IN2> inputData2, RuntimeContext runtimeContext,\n\t\t\tExecutionConfig executionConfig)", "testcase": false, "constructor": false}], "file": "flink-core/src/main/java/org/apache/flink/api/common/operators/base/InnerJoinOperatorBase.java"}, "focal_method": {"identifier": "executeOnCollections", "parameters": "(List<IN1> inputData1, List<IN2> inputData2, RuntimeContext runtimeContext,\n\t\t\tExecutionConfig executionConfig)", "modifiers": "@SuppressWarnings(\"unchecked\") @Override protected", "return": "List<OUT>", "body": "@SuppressWarnings(\"unchecked\")\n\t@Override\n\tprotected List<OUT> executeOnCollections(List<IN1> inputData1, List<IN2> inputData2, RuntimeContext runtimeContext,\n\t\t\tExecutionConfig executionConfig) throws Exception {\n\t\tFlatJoinFunction<IN1, IN2, OUT> function = userFunction.getUserCodeObject();\n\n\t\tFunctionUtils.setFunctionRuntimeContext(function, runtimeContext);\n\t\tFunctionUtils.openFunction(function, this.parameters);\n\n\t\tTypeInformation<IN1> leftInformation = getOperatorInfo().getFirstInputType();\n\t\tTypeInformation<IN2> rightInformation = getOperatorInfo().getSecondInputType();\n\t\tTypeInformation<OUT> outInformation = getOperatorInfo().getOutputType();\n\n\t\tTypeSerializer<IN1> leftSerializer = leftInformation.createSerializer(executionConfig);\n\t\tTypeSerializer<IN2> rightSerializer = rightInformation.createSerializer(executionConfig);\n\n\t\tTypeComparator<IN1> leftComparator;\n\t\tTypeComparator<IN2> rightComparator;\n\n\t\tif (leftInformation instanceof AtomicType) {\n\t\t\tleftComparator = ((AtomicType<IN1>) leftInformation).createComparator(true, executionConfig);\n\t\t} else if (leftInformation instanceof CompositeType) {\n\t\t\tint[] keyPositions = getKeyColumns(0);\n\t\t\tboolean[] orders = new boolean[keyPositions.length];\n\t\t\tArrays.fill(orders, true);\n\n\t\t\tleftComparator = ((CompositeType<IN1>) leftInformation).createComparator(keyPositions, orders, 0, executionConfig);\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Type information for left input of type \" + leftInformation.getClass()\n\t\t\t\t\t.getCanonicalName() + \" is not supported. Could not generate a comparator.\");\n\t\t}\n\n\t\tif (rightInformation instanceof AtomicType) {\n\t\t\trightComparator = ((AtomicType<IN2>) rightInformation).createComparator(true, executionConfig);\n\t\t} else if (rightInformation instanceof CompositeType) {\n\t\t\tint[] keyPositions = getKeyColumns(1);\n\t\t\tboolean[] orders = new boolean[keyPositions.length];\n\t\t\tArrays.fill(orders, true);\n\n\t\t\trightComparator = ((CompositeType<IN2>) rightInformation).createComparator(keyPositions, orders, 0, executionConfig);\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Type information for right input of type \" + rightInformation.getClass()\n\t\t\t\t\t.getCanonicalName() + \" is not supported. Could not generate a comparator.\");\n\t\t}\n\n\t\tTypePairComparator<IN1, IN2> pairComparator = new GenericPairComparator<IN1, IN2>(leftComparator, rightComparator);\n\n\t\tList<OUT> result = new ArrayList<OUT>();\n\t\tCollector<OUT> collector = new CopyingListCollector<OUT>(result, outInformation.createSerializer(executionConfig));\n\n\t\tMap<Integer, List<IN2>> probeTable = new HashMap<Integer, List<IN2>>();\n\n\t\t//Build hash table\n\t\tfor (IN2 element : inputData2) {\n\t\t\tList<IN2> list = probeTable.get(rightComparator.hash(element));\n\t\t\tif (list == null) {\n\t\t\t\tlist = new ArrayList<IN2>();\n\t\t\t\tprobeTable.put(rightComparator.hash(element), list);\n\t\t\t}\n\n\t\t\tlist.add(element);\n\t\t}\n\n\t\t//Probing\n\t\tfor (IN1 left : inputData1) {\n\t\t\tList<IN2> matchingHashes = probeTable.get(leftComparator.hash(left));\n\n\t\t\tif (matchingHashes != null) {\n\t\t\t\tpairComparator.setReference(left);\n\t\t\t\tfor (IN2 right : matchingHashes) {\n\t\t\t\t\tif (pairComparator.equalToReference(right)) {\n\t\t\t\t\t\tfunction.join(leftSerializer.copy(left), rightSerializer.copy(right), collector);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tFunctionUtils.closeFunction(function);\n\n\t\treturn result;\n\t}", "signature": "List<OUT> executeOnCollections(List<IN1> inputData1, List<IN2> inputData2, RuntimeContext runtimeContext,\n\t\t\tExecutionConfig executionConfig)", "full_signature": "@SuppressWarnings(\"unchecked\") @Override protected List<OUT> executeOnCollections(List<IN1> inputData1, List<IN2> inputData2, RuntimeContext runtimeContext,\n\t\t\tExecutionConfig executionConfig)", "class_method_signature": "InnerJoinOperatorBase.executeOnCollections(List<IN1> inputData1, List<IN2> inputData2, RuntimeContext runtimeContext,\n\t\t\tExecutionConfig executionConfig)", "testcase": false, "constructor": false, "invocations": ["getUserCodeObject", "setFunctionRuntimeContext", "openFunction", "getFirstInputType", "getOperatorInfo", "getSecondInputType", "getOperatorInfo", "getOutputType", "getOperatorInfo", "createSerializer", "createSerializer", "createComparator", "getKeyColumns", "fill", "createComparator", "getCanonicalName", "getClass", "createComparator", "getKeyColumns", "fill", "createComparator", "getCanonicalName", "getClass", "createSerializer", "get", "hash", "put", "hash", "add", "get", "hash", "setReference", "equalToReference", "join", "copy", "copy", "closeFunction"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}