{"test_class": {"identifier": "MultiRedisLockTest", "superclass": "", "interfaces": "implements InitializingBean", "fields": [{"original_string": "@Autowired\n  @SuppressWarnings(\"SpringJavaInjectionPointsAutowiringInspection\") // false IntelliJ warning\n  private StringRedisTemplate redisTemplate;", "modifier": "@Autowired\n  @SuppressWarnings(\"SpringJavaInjectionPointsAutowiringInspection\") // false IntelliJ warning\n  private", "type": "StringRedisTemplate", "declarator": "redisTemplate", "var_name": "redisTemplate"}, {"original_string": "private Lock lock;", "modifier": "private", "type": "Lock", "declarator": "lock", "var_name": "lock"}], "file": "distributed-lock-redis/src/test/java/com/github/alturkovic/lock/redis/impl/MultiRedisLockTest.java"}, "test_case": {"identifier": "shouldLockSingleKey", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void shouldLockSingleKey() {\n    final var token = lock.acquire(Collections.singletonList(\"1\"), \"locks\", 1000);\n    assertThat(token).isEqualTo(\"abc\");\n    assertThat(redisTemplate.opsForValue().get(\"locks:1\")).isEqualTo(\"abc\");\n    assertThat(redisTemplate.getExpire(\"locks:1\", TimeUnit.MILLISECONDS)).isCloseTo(1000, Offset.offset(100L));\n  }", "signature": "void shouldLockSingleKey()", "full_signature": "@Test public void shouldLockSingleKey()", "class_method_signature": "MultiRedisLockTest.shouldLockSingleKey()", "testcase": true, "constructor": false, "invocations": ["acquire", "singletonList", "isEqualTo", "assertThat", "isEqualTo", "assertThat", "get", "opsForValue", "isCloseTo", "assertThat", "getExpire", "offset"]}, "focal_class": {"identifier": "MultiRedisLock", "superclass": "", "interfaces": "implements Lock", "fields": [{"original_string": "private static final String LOCK_SCRIPT = \"local msetnx_keys_with_tokens = {}\\n\" +\n    \"for _, key in ipairs(KEYS) do\\n\" +\n    \"    msetnx_keys_with_tokens[#msetnx_keys_with_tokens + 1] = key\\n\" +\n    \"    msetnx_keys_with_tokens[#msetnx_keys_with_tokens + 1] = ARGV[1]\\n\" +\n    \"end\\n\" +\n    \"local keys_successfully_set = redis.call('MSETNX', unpack(msetnx_keys_with_tokens))\\n\" +\n    \"if (keys_successfully_set == 0) then\\n\" +\n    \"    return false\\n\" +\n    \"end\\n\" +\n    \"local expiration = tonumber(ARGV[2])\\n\" +\n    \"for _, key in ipairs(KEYS) do\\n\" +\n    \"    redis.call('PEXPIRE', key, expiration)\\n\" +\n    \"end\\n\" +\n    \"return true\\n\";", "modifier": "private static final", "type": "String", "declarator": "LOCK_SCRIPT = \"local msetnx_keys_with_tokens = {}\\n\" +\n    \"for _, key in ipairs(KEYS) do\\n\" +\n    \"    msetnx_keys_with_tokens[#msetnx_keys_with_tokens + 1] = key\\n\" +\n    \"    msetnx_keys_with_tokens[#msetnx_keys_with_tokens + 1] = ARGV[1]\\n\" +\n    \"end\\n\" +\n    \"local keys_successfully_set = redis.call('MSETNX', unpack(msetnx_keys_with_tokens))\\n\" +\n    \"if (keys_successfully_set == 0) then\\n\" +\n    \"    return false\\n\" +\n    \"end\\n\" +\n    \"local expiration = tonumber(ARGV[2])\\n\" +\n    \"for _, key in ipairs(KEYS) do\\n\" +\n    \"    redis.call('PEXPIRE', key, expiration)\\n\" +\n    \"end\\n\" +\n    \"return true\\n\"", "var_name": "LOCK_SCRIPT"}, {"original_string": "private static final String LOCK_RELEASE_SCRIPT = \"for _, key in pairs(KEYS) do\\n\" +\n    \"    if redis.call('GET', key) ~= ARGV[1] then\\n\" +\n    \"        return false\\n\" +\n    \"    end\\n\" +\n    \"end\\n\" +\n    \"redis.call('DEL', unpack(KEYS))\\n\" +\n    \"return true\\n\";", "modifier": "private static final", "type": "String", "declarator": "LOCK_RELEASE_SCRIPT = \"for _, key in pairs(KEYS) do\\n\" +\n    \"    if redis.call('GET', key) ~= ARGV[1] then\\n\" +\n    \"        return false\\n\" +\n    \"    end\\n\" +\n    \"end\\n\" +\n    \"redis.call('DEL', unpack(KEYS))\\n\" +\n    \"return true\\n\"", "var_name": "LOCK_RELEASE_SCRIPT"}, {"original_string": "private static final String LOCK_REFRESH_SCRIPT = \"for _, key in pairs(KEYS) do\\n\" +\n    \"    local value = redis.call('GET', key)\\n\" +\n    \"    if (value == nil or value ~= ARGV[1]) then\\n\" +\n    \"        return false\\n\" +\n    \"    end\\n\" +\n    \"end\\n\" +\n    \"for _, key in pairs(KEYS) do\\n\" +\n    \"    redis.call('PEXPIRE', key, ARGV[2])\\n\" +\n    \"end\\n\" +\n    \"return true\";", "modifier": "private static final", "type": "String", "declarator": "LOCK_REFRESH_SCRIPT = \"for _, key in pairs(KEYS) do\\n\" +\n    \"    local value = redis.call('GET', key)\\n\" +\n    \"    if (value == nil or value ~= ARGV[1]) then\\n\" +\n    \"        return false\\n\" +\n    \"    end\\n\" +\n    \"end\\n\" +\n    \"for _, key in pairs(KEYS) do\\n\" +\n    \"    redis.call('PEXPIRE', key, ARGV[2])\\n\" +\n    \"end\\n\" +\n    \"return true\"", "var_name": "LOCK_REFRESH_SCRIPT"}, {"original_string": "private final RedisScript<Boolean> lockScript = new DefaultRedisScript<>(LOCK_SCRIPT, Boolean.class);", "modifier": "private final", "type": "RedisScript<Boolean>", "declarator": "lockScript = new DefaultRedisScript<>(LOCK_SCRIPT, Boolean.class)", "var_name": "lockScript"}, {"original_string": "private final RedisScript<Boolean> lockReleaseScript = new DefaultRedisScript<>(LOCK_RELEASE_SCRIPT, Boolean.class);", "modifier": "private final", "type": "RedisScript<Boolean>", "declarator": "lockReleaseScript = new DefaultRedisScript<>(LOCK_RELEASE_SCRIPT, Boolean.class)", "var_name": "lockReleaseScript"}, {"original_string": "private final RedisScript<Boolean> lockRefreshScript = new DefaultRedisScript<>(LOCK_REFRESH_SCRIPT, Boolean.class);", "modifier": "private final", "type": "RedisScript<Boolean>", "declarator": "lockRefreshScript = new DefaultRedisScript<>(LOCK_REFRESH_SCRIPT, Boolean.class)", "var_name": "lockRefreshScript"}, {"original_string": "private final StringRedisTemplate stringRedisTemplate;", "modifier": "private final", "type": "StringRedisTemplate", "declarator": "stringRedisTemplate", "var_name": "stringRedisTemplate"}, {"original_string": "private final Supplier<String> tokenSupplier;", "modifier": "private final", "type": "Supplier<String>", "declarator": "tokenSupplier", "var_name": "tokenSupplier"}], "methods": [{"identifier": "MultiRedisLock", "parameters": "(final StringRedisTemplate stringRedisTemplate)", "modifiers": "public", "return": "", "signature": " MultiRedisLock(final StringRedisTemplate stringRedisTemplate)", "full_signature": "public  MultiRedisLock(final StringRedisTemplate stringRedisTemplate)", "class_method_signature": "MultiRedisLock.MultiRedisLock(final StringRedisTemplate stringRedisTemplate)", "testcase": false, "constructor": true}, {"identifier": "acquire", "parameters": "(final List<String> keys, final String storeId, final long expiration)", "modifiers": "@Override public", "return": "String", "signature": "String acquire(final List<String> keys, final String storeId, final long expiration)", "full_signature": "@Override public String acquire(final List<String> keys, final String storeId, final long expiration)", "class_method_signature": "MultiRedisLock.acquire(final List<String> keys, final String storeId, final long expiration)", "testcase": false, "constructor": false}, {"identifier": "release", "parameters": "(final List<String> keys, final String storeId, final String token)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean release(final List<String> keys, final String storeId, final String token)", "full_signature": "@Override public boolean release(final List<String> keys, final String storeId, final String token)", "class_method_signature": "MultiRedisLock.release(final List<String> keys, final String storeId, final String token)", "testcase": false, "constructor": false}, {"identifier": "refresh", "parameters": "(final List<String> keys, final String storeId, final String token, final long expiration)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean refresh(final List<String> keys, final String storeId, final String token, final long expiration)", "full_signature": "@Override public boolean refresh(final List<String> keys, final String storeId, final String token, final long expiration)", "class_method_signature": "MultiRedisLock.refresh(final List<String> keys, final String storeId, final String token, final long expiration)", "testcase": false, "constructor": false}], "file": "distributed-lock-redis/src/main/java/com/github/alturkovic/lock/redis/impl/MultiRedisLock.java"}, "focal_method": {"identifier": "acquire", "parameters": "(final List<String> keys, final String storeId, final long expiration)", "modifiers": "@Override public", "return": "String", "body": "@Override\n  public String acquire(final List<String> keys, final String storeId, final long expiration) {\n    final var keysWithStoreIdPrefix = keys.stream().map(key -> storeId + \":\" + key).collect(Collectors.toList());\n    final var token = tokenSupplier.get();\n\n    if (StringUtils.isEmpty(token)) {\n      throw new IllegalStateException(\"Cannot lock with empty token\");\n    }\n\n    final var locked = stringRedisTemplate.execute(lockScript, keysWithStoreIdPrefix, token, String.valueOf(expiration));\n    log.debug(\"Tried to acquire lock for keys {} in store {} with token {}. Locked: {}\", keys, storeId, token, locked);\n    return locked ? token : null;\n  }", "signature": "String acquire(final List<String> keys, final String storeId, final long expiration)", "full_signature": "@Override public String acquire(final List<String> keys, final String storeId, final long expiration)", "class_method_signature": "MultiRedisLock.acquire(final List<String> keys, final String storeId, final long expiration)", "testcase": false, "constructor": false, "invocations": ["collect", "map", "stream", "toList", "get", "isEmpty", "execute", "valueOf", "debug"]}, "repository": {"repo_id": 93310060, "url": "https://github.com/alturkovic/distributed-lock", "language": "Java", "is_fork": false, "fork_count": 26, "stargazer_count": 77, "size": 282, "license": "licensed"}}