{"test_class": {"identifier": "AveragingProgressTrackerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final long CHECKER = TimeUnit.MILLISECONDS.toNanos(500);", "modifier": "private static final", "type": "long", "declarator": "CHECKER = TimeUnit.MILLISECONDS.toNanos(500)", "var_name": "CHECKER"}, {"original_string": "private static final long TICKER_STEP = 100;", "modifier": "private static final", "type": "long", "declarator": "TICKER_STEP = 100", "var_name": "TICKER_STEP"}, {"original_string": "private FakeTicker ticker;", "modifier": "private", "type": "FakeTicker", "declarator": "ticker", "var_name": "ticker"}, {"original_string": "private AveragingProgressTracker averagingProgressTracker;", "modifier": "private", "type": "AveragingProgressTracker", "declarator": "averagingProgressTracker", "var_name": "averagingProgressTracker"}], "file": "opendaylight/md-sal/cds-access-client/src/test/java/org/opendaylight/controller/cluster/access/client/AveragingProgressTrackerTest.java"}, "test_case": {"identifier": "estimateIsolatedDelayTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void estimateIsolatedDelayTest() {\n        long time = ticker.read();\n        assertEquals(0, averagingProgressTracker.estimateIsolatedDelay(time));\n\n        // less than half\n        time = ticker.read();\n        assertTrue(averagingProgressTracker.openTask(time) <= CHECKER);\n        assertEquals(0, averagingProgressTracker.estimateIsolatedDelay(time));\n\n        // more than half but less than limit\n        time = ticker.read();\n        assertTrue(averagingProgressTracker.openTask(time) <= CHECKER);\n        assertTrue(averagingProgressTracker.estimateIsolatedDelay(time) < CHECKER);\n\n        // limit reached\n        time = ticker.read();\n        assertTrue(averagingProgressTracker.openTask(time) >= CHECKER);\n        assertEquals(CHECKER, averagingProgressTracker.estimateIsolatedDelay(time));\n\n        // above limit, no higher isolated delays than CHECKER\n        time = ticker.read();\n        assertTrue(averagingProgressTracker.openTask(time) >= CHECKER);\n        assertEquals(CHECKER, averagingProgressTracker.estimateIsolatedDelay(time));\n\n        // close tasks to get under the half\n        averagingProgressTracker.closeTask(ticker.read(), 0, 0, 0);\n        averagingProgressTracker.closeTask(ticker.read(), 0, 0, 0);\n        averagingProgressTracker.closeTask(ticker.read(), 0, 0, 0);\n\n        assertEquals(0, averagingProgressTracker.estimateIsolatedDelay(ticker.read()));\n    }", "signature": "void estimateIsolatedDelayTest()", "full_signature": "@Test public void estimateIsolatedDelayTest()", "class_method_signature": "AveragingProgressTrackerTest.estimateIsolatedDelayTest()", "testcase": true, "constructor": false, "invocations": ["read", "assertEquals", "estimateIsolatedDelay", "read", "assertTrue", "openTask", "assertEquals", "estimateIsolatedDelay", "read", "assertTrue", "openTask", "assertTrue", "estimateIsolatedDelay", "read", "assertTrue", "openTask", "assertEquals", "estimateIsolatedDelay", "read", "assertTrue", "openTask", "assertEquals", "estimateIsolatedDelay", "closeTask", "read", "closeTask", "read", "closeTask", "read", "assertEquals", "estimateIsolatedDelay", "read"]}, "focal_class": {"identifier": "AveragingProgressTracker", "superclass": "extends ProgressTracker", "interfaces": "", "fields": [{"original_string": "private static final long DEFAULT_TICKS_PER_TASK = TimeUnit.MILLISECONDS.toNanos(500);", "modifier": "private static final", "type": "long", "declarator": "DEFAULT_TICKS_PER_TASK = TimeUnit.MILLISECONDS.toNanos(500)", "var_name": "DEFAULT_TICKS_PER_TASK"}, {"original_string": "private final long tasksOpenLimit;", "modifier": "private final", "type": "long", "declarator": "tasksOpenLimit", "var_name": "tasksOpenLimit"}, {"original_string": "private final long noDelayThreshold;", "modifier": "private final", "type": "long", "declarator": "noDelayThreshold", "var_name": "noDelayThreshold"}], "methods": [{"identifier": "AveragingProgressTracker", "parameters": "(final long limit, final long ticksPerTask)", "modifiers": "private", "return": "", "signature": " AveragingProgressTracker(final long limit, final long ticksPerTask)", "full_signature": "private  AveragingProgressTracker(final long limit, final long ticksPerTask)", "class_method_signature": "AveragingProgressTracker.AveragingProgressTracker(final long limit, final long ticksPerTask)", "testcase": false, "constructor": true}, {"identifier": "AveragingProgressTracker", "parameters": "(final long limit)", "modifiers": "", "return": "", "signature": " AveragingProgressTracker(final long limit)", "full_signature": "  AveragingProgressTracker(final long limit)", "class_method_signature": "AveragingProgressTracker.AveragingProgressTracker(final long limit)", "testcase": false, "constructor": true}, {"identifier": "AveragingProgressTracker", "parameters": "(final ProgressTracker oldTracker, final long limit, final long now)", "modifiers": "", "return": "", "signature": " AveragingProgressTracker(final ProgressTracker oldTracker, final long limit, final long now)", "full_signature": "  AveragingProgressTracker(final ProgressTracker oldTracker, final long limit, final long now)", "class_method_signature": "AveragingProgressTracker.AveragingProgressTracker(final ProgressTracker oldTracker, final long limit, final long now)", "testcase": false, "constructor": true}, {"identifier": "AveragingProgressTracker", "parameters": "(final AveragingProgressTracker oldTracker, final long now)", "modifiers": "", "return": "", "signature": " AveragingProgressTracker(final AveragingProgressTracker oldTracker, final long now)", "full_signature": "  AveragingProgressTracker(final AveragingProgressTracker oldTracker, final long now)", "class_method_signature": "AveragingProgressTracker.AveragingProgressTracker(final AveragingProgressTracker oldTracker, final long now)", "testcase": false, "constructor": true}, {"identifier": "estimateIsolatedDelay", "parameters": "(final long now)", "modifiers": "@Override protected", "return": "long", "signature": "long estimateIsolatedDelay(final long now)", "full_signature": "@Override protected long estimateIsolatedDelay(final long now)", "class_method_signature": "AveragingProgressTracker.estimateIsolatedDelay(final long now)", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/cds-access-client/src/main/java/org/opendaylight/controller/cluster/access/client/AveragingProgressTracker.java"}, "focal_method": {"identifier": "estimateIsolatedDelay", "parameters": "(final long now)", "modifiers": "@Override protected", "return": "long", "body": "@Override\n    protected long estimateIsolatedDelay(final long now) {\n        final long open = tasksOpen();\n        if (open <= noDelayThreshold) {\n            return 0L;\n        }\n        if (open >= tasksOpenLimit) {\n            return defaultTicksPerTask();\n        }\n\n        /*\n         * Calculate the task capacity relative to the limit on open tasks. In real terms this value can be\n         * in the open interval (0.0, 0.5).\n         */\n        final double relativeRemainingCapacity = 1.0 - (double) open / tasksOpenLimit;\n\n        /*\n         * Calculate delay coefficient. It increases in inverse proportion to relative remaining capacity, approaching\n         * infinity as remaining capacity approaches 0.0.\n         */\n        final double delayCoefficient = (0.5 - relativeRemainingCapacity) / relativeRemainingCapacity;\n        final long delay = (long) (ticksWorkedPerClosedTask(now) * delayCoefficient);\n\n        /*\n         * Cap the result to defaultTicksPerTask, since the calculated delay may overstep it.\n         */\n        return Math.min(delay, defaultTicksPerTask());\n    }", "signature": "long estimateIsolatedDelay(final long now)", "full_signature": "@Override protected long estimateIsolatedDelay(final long now)", "class_method_signature": "AveragingProgressTracker.estimateIsolatedDelay(final long now)", "testcase": false, "constructor": false, "invocations": ["tasksOpen", "defaultTicksPerTask", "ticksWorkedPerClosedTask", "min", "defaultTicksPerTask"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}