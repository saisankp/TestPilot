{"test_class": {"identifier": "TestLogFileHandler", "superclass": "", "interfaces": "", "fields": [{"original_string": "byte[] testUnescaped = new byte[]{0x00, 0x55, -27, 0x00, 0x56, 0x10, -128, 0x55, 0x54};", "modifier": "", "type": "byte[]", "declarator": "testUnescaped = new byte[]{0x00, 0x55, -27, 0x00, 0x56, 0x10, -128, 0x55, 0x54}", "var_name": "testUnescaped"}, {"original_string": "byte[] expectedEscaped = new byte[]{0x55, 0x00, 0x00, 0x00, 0x09, 0x00, 0x56, 0x00, -27, 0x00, 0x56, 0x01, 0x10, -128, 0x56, 0x00, 0x54};", "modifier": "", "type": "byte[]", "declarator": "expectedEscaped = new byte[]{0x55, 0x00, 0x00, 0x00, 0x09, 0x00, 0x56, 0x00, -27, 0x00, 0x56, 0x01, 0x10, -128, 0x56, 0x00, 0x54}", "var_name": "expectedEscaped"}, {"original_string": "private TestingLogFileHandler lfh;", "modifier": "private", "type": "TestingLogFileHandler", "declarator": "lfh", "var_name": "lfh"}], "file": "main/src/test/java/de/blinkt/openvpn/core/TestLogFileHandler.java"}, "test_case": {"identifier": "readByteArray", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void readByteArray() throws IOException {\n\n        ByteArrayInputStream in = new ByteArrayInputStream(expectedEscaped);\n\n        lfh.readCacheContents(in);\n\n        Assert.assertTrue(Arrays.equals(testUnescaped, lfh.mRestoredByteArray));\n\n    }", "signature": "void readByteArray()", "full_signature": "@Test public void readByteArray()", "class_method_signature": "TestLogFileHandler.readByteArray()", "testcase": true, "constructor": false, "invocations": ["readCacheContents", "assertTrue", "equals"]}, "focal_class": {"identifier": "LogFileHandler", "superclass": "extends Handler", "interfaces": "", "fields": [{"original_string": "static final int TRIM_LOG_FILE = 100;", "modifier": "static final", "type": "int", "declarator": "TRIM_LOG_FILE = 100", "var_name": "TRIM_LOG_FILE"}, {"original_string": "static final int FLUSH_TO_DISK = 101;", "modifier": "static final", "type": "int", "declarator": "FLUSH_TO_DISK = 101", "var_name": "FLUSH_TO_DISK"}, {"original_string": "static final int LOG_INIT = 102;", "modifier": "static final", "type": "int", "declarator": "LOG_INIT = 102", "var_name": "LOG_INIT"}, {"original_string": "public static final int LOG_MESSAGE = 103;", "modifier": "public static final", "type": "int", "declarator": "LOG_MESSAGE = 103", "var_name": "LOG_MESSAGE"}, {"original_string": "public static final int MAGIC_BYTE = 0x55;", "modifier": "public static final", "type": "int", "declarator": "MAGIC_BYTE = 0x55", "var_name": "MAGIC_BYTE"}, {"original_string": "protected OutputStream mLogFile;", "modifier": "protected", "type": "OutputStream", "declarator": "mLogFile", "var_name": "mLogFile"}, {"original_string": "public static final String LOGFILE_NAME = \"logcache.dat\";", "modifier": "public static final", "type": "String", "declarator": "LOGFILE_NAME = \"logcache.dat\"", "var_name": "LOGFILE_NAME"}, {"original_string": "private final static char[] hexArray = \"0123456789ABCDEF\".toCharArray();", "modifier": "private final static", "type": "char[]", "declarator": "hexArray = \"0123456789ABCDEF\".toCharArray()", "var_name": "hexArray"}], "methods": [{"identifier": "LogFileHandler", "parameters": "(Looper looper)", "modifiers": "public", "return": "", "signature": " LogFileHandler(Looper looper)", "full_signature": "public  LogFileHandler(Looper looper)", "class_method_signature": "LogFileHandler.LogFileHandler(Looper looper)", "testcase": false, "constructor": true}, {"identifier": "handleMessage", "parameters": "(Message msg)", "modifiers": "@Override public", "return": "void", "signature": "void handleMessage(Message msg)", "full_signature": "@Override public void handleMessage(Message msg)", "class_method_signature": "LogFileHandler.handleMessage(Message msg)", "testcase": false, "constructor": false}, {"identifier": "flushToDisk", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void flushToDisk()", "full_signature": "private void flushToDisk()", "class_method_signature": "LogFileHandler.flushToDisk()", "testcase": false, "constructor": false}, {"identifier": "trimLogFile", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void trimLogFile()", "full_signature": "private void trimLogFile()", "class_method_signature": "LogFileHandler.trimLogFile()", "testcase": false, "constructor": false}, {"identifier": "writeLogItemToDisk", "parameters": "(LogItem li)", "modifiers": "private", "return": "void", "signature": "void writeLogItemToDisk(LogItem li)", "full_signature": "private void writeLogItemToDisk(LogItem li)", "class_method_signature": "LogFileHandler.writeLogItemToDisk(LogItem li)", "testcase": false, "constructor": false}, {"identifier": "writeEscapedBytes", "parameters": "(byte[] bytes)", "modifiers": "public", "return": "void", "signature": "void writeEscapedBytes(byte[] bytes)", "full_signature": "public void writeEscapedBytes(byte[] bytes)", "class_method_signature": "LogFileHandler.writeEscapedBytes(byte[] bytes)", "testcase": false, "constructor": false}, {"identifier": "openLogFile", "parameters": "(File cacheDir)", "modifiers": "private", "return": "void", "signature": "void openLogFile(File cacheDir)", "full_signature": "private void openLogFile(File cacheDir)", "class_method_signature": "LogFileHandler.openLogFile(File cacheDir)", "testcase": false, "constructor": false}, {"identifier": "readLogCache", "parameters": "(File cacheDir)", "modifiers": "private", "return": "void", "signature": "void readLogCache(File cacheDir)", "full_signature": "private void readLogCache(File cacheDir)", "class_method_signature": "LogFileHandler.readLogCache(File cacheDir)", "testcase": false, "constructor": false}, {"identifier": "readCacheContents", "parameters": "(InputStream in)", "modifiers": "protected", "return": "void", "signature": "void readCacheContents(InputStream in)", "full_signature": "protected void readCacheContents(InputStream in)", "class_method_signature": "LogFileHandler.readCacheContents(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "restoreLogItem", "parameters": "(byte[] buf, int len)", "modifiers": "protected", "return": "void", "signature": "void restoreLogItem(byte[] buf, int len)", "full_signature": "protected void restoreLogItem(byte[] buf, int len)", "class_method_signature": "LogFileHandler.restoreLogItem(byte[] buf, int len)", "testcase": false, "constructor": false}, {"identifier": "bytesToHex", "parameters": "(byte[] bytes, int len)", "modifiers": "public static", "return": "String", "signature": "String bytesToHex(byte[] bytes, int len)", "full_signature": "public static String bytesToHex(byte[] bytes, int len)", "class_method_signature": "LogFileHandler.bytesToHex(byte[] bytes, int len)", "testcase": false, "constructor": false}], "file": "main/src/main/java/de/blinkt/openvpn/core/LogFileHandler.java"}, "focal_method": {"identifier": "readCacheContents", "parameters": "(InputStream in)", "modifiers": "protected", "return": "void", "body": "protected void readCacheContents(InputStream in) throws IOException {\n        BufferedInputStream logFile = new BufferedInputStream(in);\n\n        byte[] buf = new byte[16384];\n        int read = logFile.read(buf, 0, 5);\n        int itemsRead = 0;\n\n\n        readloop:\n        while (read >= 5) {\n            int skipped = 0;\n            while (buf[skipped] != MAGIC_BYTE) {\n                skipped++;\n                if (!(logFile.read(buf, skipped + 4, 1) == 1) || skipped + 10 > buf.length) {\n                    VpnStatus.logDebug(String.format(Locale.US, \"Skipped %d bytes and no a magic byte found\", skipped));\n                    break readloop;\n                }\n            }\n            if (skipped > 0)\n                VpnStatus.logDebug(String.format(Locale.US, \"Skipped %d bytes before finding a magic byte\", skipped));\n\n            int len = ByteBuffer.wrap(buf, skipped + 1, 4).asIntBuffer().get();\n\n            // Marshalled LogItem\n            int pos = 0;\n            byte buf2[] = new byte[buf.length];\n\n            while (pos < len) {\n                byte b = (byte) logFile.read();\n                if (b == MAGIC_BYTE) {\n                    VpnStatus.logDebug(String.format(Locale.US, \"Unexpected magic byte found at pos %d, abort current log item\", pos));\n                    read = logFile.read(buf, 1, 4) + 1;\n                    continue readloop;\n                } else if (b == MAGIC_BYTE + 1) {\n                    b = (byte) logFile.read();\n                    if (b == 0)\n                        b = MAGIC_BYTE;\n                    else if (b == 1)\n                        b = MAGIC_BYTE + 1;\n                    else {\n                        VpnStatus.logDebug(String.format(Locale.US, \"Escaped byte not 0 or 1: %d\", b));\n                        read = logFile.read(buf, 1, 4) + 1;\n                        continue readloop;\n                    }\n                }\n                buf2[pos++] = b;\n            }\n\n            restoreLogItem(buf2, len);\n\n            //Next item\n            read = logFile.read(buf, 0, 5);\n            itemsRead++;\n            if (itemsRead > 2 * VpnStatus.MAXLOGENTRIES) {\n                VpnStatus.logError(\"Too many logentries read from cache, aborting.\");\n                read = 0;\n            }\n\n        }\n        VpnStatus.logDebug(R.string.reread_log, itemsRead);\n    }", "signature": "void readCacheContents(InputStream in)", "full_signature": "protected void readCacheContents(InputStream in)", "class_method_signature": "LogFileHandler.readCacheContents(InputStream in)", "testcase": false, "constructor": false, "invocations": ["read", "read", "logDebug", "format", "logDebug", "format", "get", "asIntBuffer", "wrap", "read", "logDebug", "format", "read", "read", "logDebug", "format", "read", "restoreLogItem", "read", "logError", "logDebug"]}, "repository": {"repo_id": 136678045, "url": "https://github.com/jessaofraksss/OpenVPN-Connect-for-Android", "language": "Java", "is_fork": false, "fork_count": 5, "stargazer_count": 5, "size": 34560, "license": "licensed"}}