{"test_class": {"identifier": "_MapsTest", "superclass": "", "interfaces": "", "fields": [], "file": "commons/src/test/java/org/apache/isis/commons/internal/collections/_MapsTest.java"}, "test_case": {"identifier": "aliasMap_shouldHonorRemoval", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n    void aliasMap_shouldHonorRemoval() {\n        \n        val aliasMap = _Maps.<String, String>newAliasMap(HashMap::new);\n        \n        aliasMap.put(\"key1\", \"value1\");\n        aliasMap.put(\"key2\", Can.ofArray(new String[] {\"alias2a\", \"alias2b\"}), \"value2\");\n        aliasMap.put(\"key3\", Can.empty(), \"value3\");\n        \n        aliasMap.remove(\"key1\");\n        aliasMap.remove(\"key2\");\n        aliasMap.remove(\"key3\");\n        \n        assertFalse(aliasMap.containsKey(\"key1\"));\n        assertNull(aliasMap.get(\"key1\"));\n        \n        assertFalse(aliasMap.containsKey(\"key2\"));\n        assertNull(aliasMap.get(\"key2\"));\n        assertNull(aliasMap.get(\"alias2a\"));\n        assertNull(aliasMap.get(\"alias2b\"));\n        \n        assertFalse(aliasMap.containsKey(\"key3\"));\n        assertNull(aliasMap.get(\"key3\"));\n        \n        // re-adding previously removed should not throw\n        aliasMap.put(\"key2\", Can.ofArray(new String[] {\"alias2a\", \"alias2b\"}), \"value2\");\n        \n    }", "signature": "void aliasMap_shouldHonorRemoval()", "full_signature": "@Test void aliasMap_shouldHonorRemoval()", "class_method_signature": "_MapsTest.aliasMap_shouldHonorRemoval()", "testcase": true, "constructor": false, "invocations": ["newAliasMap", "put", "put", "ofArray", "put", "empty", "remove", "remove", "remove", "assertFalse", "containsKey", "assertNull", "get", "assertFalse", "containsKey", "assertNull", "get", "assertNull", "get", "assertNull", "get", "assertFalse", "containsKey", "assertNull", "get", "put", "ofArray"]}, "focal_class": {"identifier": "_Maps", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "_Maps", "parameters": "()", "modifiers": "private", "return": "", "signature": " _Maps()", "full_signature": "private  _Maps()", "class_method_signature": "_Maps._Maps()", "testcase": false, "constructor": true}, {"identifier": "unmodifiable", "parameters": "(K k1, V v1)", "modifiers": "public static", "return": "Map<K, V>", "signature": "Map<K, V> unmodifiable(K k1, V v1)", "full_signature": "public static Map<K, V> unmodifiable(K k1, V v1)", "class_method_signature": "_Maps.unmodifiable(K k1, V v1)", "testcase": false, "constructor": false}, {"identifier": "unmodifiable", "parameters": "(K k1, V v1, K k2, V v2)", "modifiers": "public static", "return": "Map<K, V>", "signature": "Map<K, V> unmodifiable(K k1, V v1, K k2, V v2)", "full_signature": "public static Map<K, V> unmodifiable(K k1, V v1, K k2, V v2)", "class_method_signature": "_Maps.unmodifiable(K k1, V v1, K k2, V v2)", "testcase": false, "constructor": false}, {"identifier": "unmodifiable", "parameters": "(K k1, V v1, K k2, V v2, K k3, V v3)", "modifiers": "public static", "return": "Map<K, V>", "signature": "Map<K, V> unmodifiable(K k1, V v1, K k2, V v2, K k3, V v3)", "full_signature": "public static Map<K, V> unmodifiable(K k1, V v1, K k2, V v2, K k3, V v3)", "class_method_signature": "_Maps.unmodifiable(K k1, V v1, K k2, V v2, K k3, V v3)", "testcase": false, "constructor": false}, {"identifier": "unmodifiable", "parameters": "(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)", "modifiers": "public static", "return": "Map<K, V>", "signature": "Map<K, V> unmodifiable(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)", "full_signature": "public static Map<K, V> unmodifiable(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)", "class_method_signature": "_Maps.unmodifiable(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)", "testcase": false, "constructor": false}, {"identifier": "unmodifiableEntries", "parameters": "(Map.Entry<? extends K,? extends V>... entries)", "modifiers": "@SafeVarargs public static", "return": "Map<K, V>", "signature": "Map<K, V> unmodifiableEntries(Map.Entry<? extends K,? extends V>... entries)", "full_signature": "@SafeVarargs public static Map<K, V> unmodifiableEntries(Map.Entry<? extends K,? extends V>... entries)", "class_method_signature": "_Maps.unmodifiableEntries(Map.Entry<? extends K,? extends V>... entries)", "testcase": false, "constructor": false}, {"identifier": "entry", "parameters": "(K k, V v)", "modifiers": "public static", "return": "Map.Entry<K, V>", "signature": "Map.Entry<K, V> entry(K k, V v)", "full_signature": "public static Map.Entry<K, V> entry(K k, V v)", "class_method_signature": "_Maps.entry(K k, V v)", "testcase": false, "constructor": false}, {"identifier": "toggleElement", "parameters": "(\n            @NonNull Map<K, V> map, \n            @NonNull K key, \n            @NonNull V value)", "modifiers": "public static", "return": "boolean", "signature": "boolean toggleElement(\n            @NonNull Map<K, V> map, \n            @NonNull K key, \n            @NonNull V value)", "full_signature": "public static boolean toggleElement(\n            @NonNull Map<K, V> map, \n            @NonNull K key, \n            @NonNull V value)", "class_method_signature": "_Maps.toggleElement(\n            @NonNull Map<K, V> map, \n            @NonNull K key, \n            @NonNull V value)", "testcase": false, "constructor": false}, {"identifier": "filterKeys", "parameters": "(\n            @Nullable Map<K, V> input,\n            Predicate<K> keyFilter, \n            Supplier<Map<K, V>> factory)", "modifiers": "public static", "return": "Map<K, V>", "signature": "Map<K, V> filterKeys(\n            @Nullable Map<K, V> input,\n            Predicate<K> keyFilter, \n            Supplier<Map<K, V>> factory)", "full_signature": "public static Map<K, V> filterKeys(\n            @Nullable Map<K, V> input,\n            Predicate<K> keyFilter, \n            Supplier<Map<K, V>> factory)", "class_method_signature": "_Maps.filterKeys(\n            @Nullable Map<K, V> input,\n            Predicate<K> keyFilter, \n            Supplier<Map<K, V>> factory)", "testcase": false, "constructor": false}, {"identifier": "invertToListMultimap", "parameters": "(Map<K, V> input)", "modifiers": "public static", "return": "ListMultimap<V, K>", "signature": "ListMultimap<V, K> invertToListMultimap(Map<K, V> input)", "full_signature": "public static ListMultimap<V, K> invertToListMultimap(Map<K, V> input)", "class_method_signature": "_Maps.invertToListMultimap(Map<K, V> input)", "testcase": false, "constructor": false}, {"identifier": "newHashMap", "parameters": "()", "modifiers": "public static", "return": "HashMap<K, V>", "signature": "HashMap<K, V> newHashMap()", "full_signature": "public static HashMap<K, V> newHashMap()", "class_method_signature": "_Maps.newHashMap()", "testcase": false, "constructor": false}, {"identifier": "newLinkedHashMap", "parameters": "()", "modifiers": "public static", "return": "LinkedHashMap<K, V>", "signature": "LinkedHashMap<K, V> newLinkedHashMap()", "full_signature": "public static LinkedHashMap<K, V> newLinkedHashMap()", "class_method_signature": "_Maps.newLinkedHashMap()", "testcase": false, "constructor": false}, {"identifier": "newConcurrentHashMap", "parameters": "()", "modifiers": "public static", "return": "ConcurrentHashMap<K, V>", "signature": "ConcurrentHashMap<K, V> newConcurrentHashMap()", "full_signature": "public static ConcurrentHashMap<K, V> newConcurrentHashMap()", "class_method_signature": "_Maps.newConcurrentHashMap()", "testcase": false, "constructor": false}, {"identifier": "newTreeMap", "parameters": "()", "modifiers": "public static", "return": "TreeMap<K, V>", "signature": "TreeMap<K, V> newTreeMap()", "full_signature": "public static TreeMap<K, V> newTreeMap()", "class_method_signature": "_Maps.newTreeMap()", "testcase": false, "constructor": false}, {"identifier": "newTreeMap", "parameters": "(Comparator<? super K> comparator)", "modifiers": "public static", "return": "TreeMap<K, V>", "signature": "TreeMap<K, V> newTreeMap(Comparator<? super K> comparator)", "full_signature": "public static TreeMap<K, V> newTreeMap(Comparator<? super K> comparator)", "class_method_signature": "_Maps.newTreeMap(Comparator<? super K> comparator)", "testcase": false, "constructor": false}, {"identifier": "newAliasMap", "parameters": "(\n            final Supplier<Map<K, V>> mapFactory)", "modifiers": "public static", "return": "AliasMap<K, V>", "signature": "AliasMap<K, V> newAliasMap(\n            final Supplier<Map<K, V>> mapFactory)", "full_signature": "public static AliasMap<K, V> newAliasMap(\n            final Supplier<Map<K, V>> mapFactory)", "class_method_signature": "_Maps.newAliasMap(\n            final Supplier<Map<K, V>> mapFactory)", "testcase": false, "constructor": false}], "file": "commons/src/main/java/org/apache/isis/commons/internal/collections/_Maps.java"}, "focal_method": {"identifier": "newAliasMap", "parameters": "(\n            final Supplier<Map<K, V>> mapFactory)", "modifiers": "public static", "return": "AliasMap<K, V>", "body": "public static <K, V> AliasMap<K, V> newAliasMap(\n            final Supplier<Map<K, V>> mapFactory){\n        \n        _With.requires(mapFactory, \"mapFactory\");\n\n        return new AliasMap<K, V>() {\n\n            final Map<K, V> delegate = mapFactory.get();\n\n            @Override public int size() { return delegate.size(); }\n            @Override public boolean isEmpty() { return delegate.isEmpty(); }\n            @Override public boolean containsValue(Object value) { return delegate.containsValue(value); }\n            @Override public Set<K> keySet() { return delegate.keySet(); }\n            @Override public Collection<V> values() { return delegate.values();   }\n            @Override public Set<Entry<K, V>> entrySet() { return delegate.entrySet(); }\n            \n            @Override \n            public V put(K key, V value) { \n                return this.put(key, Can.empty(), value); \n            }\n            \n            @Override \n            public void putAll(Map<? extends K, ? extends V> other) { \n                if(!_NullSafe.isEmpty(other)) {\n                    other.forEach((k, v)->this.put(k, v)); \n                }\n            }\n            \n            @Override\n            public V put(K key, Can<K> aliases, V value) {\n                putAliasKeys(key, aliases, /*re-map*/ false);\n                return delegate.put(key, value);\n            }\n            \n            @Override\n            public V remap(K key, Can<K> aliases, V value) {\n                putAliasKeys(key, aliases, /*re-map*/ true);\n                return delegate.put(key, value);\n            }\n            \n            @Override\n            public boolean containsKey(Object keyOrAliasKey) {\n                return delegate.containsKey(keyOrAliasKey) ||\n                    containsAliasKey(keyOrAliasKey);\n            }\n            \n\n            @Override\n            public V get(Object keyOrAliasKey) {\n                val v = delegate.get(keyOrAliasKey);\n                if(v!=null) {\n                    return v;\n                }\n                return getByAliasKey(keyOrAliasKey);\n            }\n            \n            @Override \n            public V remove(Object key) { \n                removeAliasKeysOf(key);\n                return delegate.remove(key); \n            }\n            \n            @Override \n            public void clear() {\n                delegate.clear(); \n                clearAliasKeys();\n            }\n            \n            // -- HELPER\n            \n            private final Map<K, KeyPair<K>> pairByAliasKey = _Maps.newHashMap();\n            \n            private void putAliasKeys(K key, Can<K> aliasKeys, boolean remap) {\n                if(aliasKeys.isNotEmpty()) {\n                    val keyPair = KeyPair.of(key, aliasKeys);\n                    for(val aliasKey : aliasKeys) {\n                        \n                        val existingKeyPair = pairByAliasKey.put(aliasKey, keyPair);\n                        if(existingKeyPair!=null && !remap) {\n                            \n                            throw _Exceptions.illegalArgument(\n                                    \"alias key collision on alias %s: existing-key=%s, new-key=%s\", \n                                    aliasKey, existingKeyPair.key, keyPair.key);\n                        }\n                    }\n                }\n            }\n            \n            private V getByAliasKey(Object aliasKey) {\n                val keyPair = pairByAliasKey.get(aliasKey);\n                if(keyPair!=null) {\n                    return delegate.get(keyPair.getKey()); \n                }\n                return null;\n            }\n\n            private boolean containsAliasKey(Object aliasKey) {\n                return pairByAliasKey.containsKey(aliasKey);\n            }\n            \n            private void removeAliasKeysOf(final Object key) {\n                //XXX this implementation is slow for large alias maps, since we traverse the entire map\n                pairByAliasKey.entrySet()\n                .removeIf(entry->{\n                    val keyPair = entry.getValue();\n                    return keyPair.getKey().equals(key);\n                });\n                \n            }\n            \n            private void clearAliasKeys() {\n                pairByAliasKey.clear();\n            }\n            \n\n        };\n    }", "signature": "AliasMap<K, V> newAliasMap(\n            final Supplier<Map<K, V>> mapFactory)", "full_signature": "public static AliasMap<K, V> newAliasMap(\n            final Supplier<Map<K, V>> mapFactory)", "class_method_signature": "_Maps.newAliasMap(\n            final Supplier<Map<K, V>> mapFactory)", "testcase": false, "constructor": false, "invocations": ["requires", "get", "size", "isEmpty", "containsValue", "keySet", "values", "entrySet", "put", "empty", "isEmpty", "forEach", "put", "putAliasKeys", "put", "putAliasKeys", "put", "containsKey", "containsAliasKey", "get", "getByAliasKey", "removeAliasKeysOf", "remove", "clear", "clearAliasKeys", "newHashMap", "isNotEmpty", "of", "put", "illegalArgument", "get", "get", "getKey", "containsKey", "removeIf", "entrySet", "getValue", "equals", "getKey", "clear"]}, "repository": {"repo_id": 6935442, "url": "https://github.com/apache/isis", "stars": 516, "created": "11/30/2012 8:00:24 AM +00:00", "updates": "2020-01-27T13:28:09+00:00", "fork": "False", "license": "licensed"}}