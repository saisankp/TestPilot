{"test_class": {"identifier": "TrackFileReaderTest", "superclass": "", "interfaces": "", "fields": [], "file": "app/src/test/java/com/platypii/baseline/tracks/TrackFileReaderTest.java"}, "test_case": {"identifier": "corrupted", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void corrupted() throws IOException {\n        assertEquals(1, parse(\"millis,sensor,lat,lon,alt\\n1,gps,2,3,4\\n5,\").size());\n        assertEquals(1, parse(\"millis,sensor,lat,lon,alt\\n1,gps,2,3,NOPE\").size());\n        assertEquals(0, parse(\"millis,sensor,lat,lon,alt\\n1,gps,2,NOPE\").size());\n        assertEquals(0, parse(\"time,lat,lon,alt\\nNOPE,2,3,4\").size());\n    }", "signature": "void corrupted()", "full_signature": "@Test public void corrupted()", "class_method_signature": "TrackFileReaderTest.corrupted()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "size", "parse", "assertEquals", "size", "parse", "assertEquals", "size", "parse", "assertEquals", "size", "parse"]}, "focal_class": {"identifier": "TrackFileReader", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String TAG = \"TrackFileReader\";", "modifier": "private static final", "type": "String", "declarator": "TAG = \"TrackFileReader\"", "var_name": "TAG"}, {"original_string": "@NonNull\n    private final File trackFile;", "modifier": "@NonNull\n    private final", "type": "File", "declarator": "trackFile", "var_name": "trackFile"}], "methods": [{"identifier": "TrackFileReader", "parameters": "(@NonNull File trackFile)", "modifiers": "", "return": "", "signature": " TrackFileReader(@NonNull File trackFile)", "full_signature": "  TrackFileReader(@NonNull File trackFile)", "class_method_signature": "TrackFileReader.TrackFileReader(@NonNull File trackFile)", "testcase": false, "constructor": true}, {"identifier": "read", "parameters": "()", "modifiers": "@NonNull", "return": "List<MLocation>", "signature": "List<MLocation> read()", "full_signature": "@NonNull List<MLocation> read()", "class_method_signature": "TrackFileReader.read()", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "(@NonNull BufferedReader br)", "modifiers": "@NonNull private", "return": "List<MLocation>", "signature": "List<MLocation> parse(@NonNull BufferedReader br)", "full_signature": "@NonNull private List<MLocation> parse(@NonNull BufferedReader br)", "class_method_signature": "TrackFileReader.parse(@NonNull BufferedReader br)", "testcase": false, "constructor": false}], "file": "app/src/main/java/com/platypii/baseline/tracks/TrackFileReader.java"}, "focal_method": {"identifier": "parse", "parameters": "(@NonNull BufferedReader br)", "modifiers": "@NonNull private", "return": "List<MLocation>", "body": "@NonNull\n    private List<MLocation> parse(@NonNull BufferedReader br) throws IOException {\n        // Reset initial state\n        // State used while scanning track file\n        final Filter baroAltitudeFilter = new FilterKalman();\n        final Filter gpsAltitudeFilter = new FilterKalman();\n        long baroLastNano = -1L;\n        long gpsLastMillis = -1L;\n        boolean initAltGps = false;\n        boolean initAltBaro = false;\n        double baroOffset = 0; // gps altitude - pressure altitude\n\n        final List<MLocation> data = new ArrayList<>();\n\n        // Parse header column\n        String line = br.readLine();\n        final CSVHeader columns = new CSVHeader(line);\n        // Add column aliases\n        columns.addMapping(\"timeMillis\", \"millis\");\n        // Handle old files that were not FlySight compatible\n        columns.addMapping(\"latitude\", \"lat\");\n        columns.addMapping(\"longitude\", \"lon\");\n        columns.addMapping(\"altitude_gps\", \"hMSL\");\n\n        // Parse data rows\n        while ((line = br.readLine()) != null) {\n            final String[] row = line.split(\",\");\n            final Integer sensorIndex = columns.get(\"sensor\");\n            if (sensorIndex == null || sensorIndex >= row.length) {\n                // FlySight\n                final long millis = getColumnDate(row, columns, \"time\");\n                if (millis > 0) {\n                    final double lat = getColumnDouble(row, columns, \"lat\");\n                    final double lon = getColumnDouble(row, columns, \"lon\");\n                    final double alt_gps = getColumnDouble(row, columns, \"hMSL\");\n                    final double climb = -getColumnDouble(row, columns, \"velD\");\n                    final double vN = getColumnDouble(row, columns, \"velN\");\n                    final double vE = getColumnDouble(row, columns, \"velE\");\n                    if (!Double.isNaN(lat) && !Double.isNaN(lon)) {\n                        final MLocation loc = new MLocation(millis, lat, lon, alt_gps, climb, vN, vE, Float.NaN, Float.NaN, Float.NaN, Float.NaN, 0, 0);\n                        data.add(loc);\n                    }\n                }\n            } else if (row[sensorIndex].equals(\"gps\")) {\n                // BASEline GPS measurement\n                final long millis = getColumnLong(row, columns, \"millis\");\n                final double lat = getColumnDouble(row, columns, \"lat\");\n                final double lon = getColumnDouble(row, columns, \"lon\");\n                final double alt_gps = getColumnDouble(row, columns, \"hMSL\");\n                final double vN = getColumnDouble(row, columns, \"velN\");\n                final double vE = getColumnDouble(row, columns, \"velE\");\n                // Update gps altitude filter\n                if (gpsLastMillis < 0) {\n                    gpsAltitudeFilter.update(alt_gps, 0);\n                } else {\n                    final double dt = (millis - gpsLastMillis) * 0.001;\n                    gpsAltitudeFilter.update(alt_gps, dt);\n                }\n                // Integrate baro altitude\n                if (!Double.isNaN(alt_gps)) {\n                    if (initAltBaro && !initAltGps) {\n                        // Set the initial altitude offset\n                        baroOffset = alt_gps - baroAltitudeFilter.x();\n                    }\n                }\n                double integratedAlt;\n                if (initAltBaro && initAltGps) {\n                    integratedAlt = baroAltitudeFilter.x() + baroOffset;\n                } else {\n                    integratedAlt = alt_gps;\n                }\n                // Climb rate from baro or gps\n                double climb = baroAltitudeFilter.v();\n                if (baroLastNano < 0 || Double.isNaN(climb)) {\n                    climb = gpsAltitudeFilter.v();\n                }\n                if (!Double.isNaN(lat) && !Double.isNaN(lon)) {\n                    final MLocation loc = new MLocation(millis, lat, lon, integratedAlt, climb, vN, vE, Float.NaN, Float.NaN, Float.NaN, Float.NaN, 0, 0);\n                    data.add(loc);\n                }\n                gpsLastMillis = millis;\n                initAltGps = true;\n            } else if (row[sensorIndex].equals(\"alt\")) {\n                // BASEline alti measurement\n                final long nano = getColumnLong(row, columns, \"nano\");\n                final double pressure = getColumnDouble(row, columns, \"pressure\");\n                final double pressureAltitude = BaroAltimeter.pressureToAltitude(pressure);\n                if (baroLastNano < 0) {\n                    baroAltitudeFilter.update(pressureAltitude, 0);\n                } else {\n                    final double dt = (nano - baroLastNano) * 1E-9;\n                    baroAltitudeFilter.update(pressureAltitude, dt);\n                }\n                // Integrate GPS altitude\n                if (!initAltBaro && initAltGps) {\n                    // Set the initial altitude offset\n                    baroOffset = gpsAltitudeFilter.x() - baroAltitudeFilter.x();\n                }\n                baroLastNano = nano;\n                initAltBaro = true;\n            }\n        }\n\n        return data;\n    }", "signature": "List<MLocation> parse(@NonNull BufferedReader br)", "full_signature": "@NonNull private List<MLocation> parse(@NonNull BufferedReader br)", "class_method_signature": "TrackFileReader.parse(@NonNull BufferedReader br)", "testcase": false, "constructor": false, "invocations": ["readLine", "addMapping", "addMapping", "addMapping", "addMapping", "readLine", "split", "get", "getColumnDate", "getColumnDouble", "getColumnDouble", "getColumnDouble", "getColumnDouble", "getColumnDouble", "getColumnDouble", "isNaN", "isNaN", "add", "equals", "getColumnLong", "getColumnDouble", "getColumnDouble", "getColumnDouble", "getColumnDouble", "getColumnDouble", "update", "update", "isNaN", "x", "x", "v", "isNaN", "v", "isNaN", "isNaN", "add", "equals", "getColumnLong", "getColumnDouble", "pressureToAltitude", "update", "update", "x", "x"]}, "repository": {"repo_id": 4671935, "url": "https://github.com/platypii/BASElineFlightComputer", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 18, "size": 6949, "license": "licensed"}}