{"test_class": {"identifier": "TraceContextBinaryFormatTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "TraceContext context = TraceContext.newBuilder()\n    .traceIdHigh(Long.MAX_VALUE).traceId(Long.MIN_VALUE)\n    .spanId(-1)\n    .sampled(true)\n    .build();", "modifier": "", "type": "TraceContext", "declarator": "context = TraceContext.newBuilder()\n    .traceIdHigh(Long.MAX_VALUE).traceId(Long.MIN_VALUE)\n    .spanId(-1)\n    .sampled(true)\n    .build()", "var_name": "context"}, {"original_string": "byte[] contextBytes = {\n    0, // version\n    0, 127, -1, -1, -1, -1, -1, -1, -1, -128, 0, 0, 0, 0, 0, 0, 0, // trace ID\n    1, -1, -1, -1, -1, -1, -1, -1, -1, // span ID\n    2, 1 // sampled\n  };", "modifier": "", "type": "byte[]", "declarator": "contextBytes = {\n    0, // version\n    0, 127, -1, -1, -1, -1, -1, -1, -1, -128, 0, 0, 0, 0, 0, 0, 0, // trace ID\n    1, -1, -1, -1, -1, -1, -1, -1, -1, // span ID\n    2, 1 // sampled\n  }", "var_name": "contextBytes"}, {"original_string": "byte[] tagsBytes = {\n    0, // version\n    0, // field number\n    6, 'm', 'e', 't', 'h', 'o', 'd', //\n    3, 'f', 'o', 'o', //\n    0, // field number\n    4, 'u', 's', 'e', 'r', //\n    5, 'r', 'o', 'm', 'e', 'o' //\n  };", "modifier": "", "type": "byte[]", "declarator": "tagsBytes = {\n    0, // version\n    0, // field number\n    6, 'm', 'e', 't', 'h', 'o', 'd', //\n    3, 'f', 'o', 'o', //\n    0, // field number\n    4, 'u', 's', 'e', 'r', //\n    5, 'r', 'o', 'm', 'e', 'o' //\n  }", "var_name": "tagsBytes"}], "file": "instrumentation/grpc/src/test/java/brave/grpc/TraceContextBinaryFormatTest.java"}, "test_case": {"identifier": "parseBytes_unsupportedVersionId_toNull", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void parseBytes_unsupportedVersionId_toNull() {\n    assertThat(TraceContextBinaryFormat.parseBytes(new byte[] {\n      1, // bad version\n      0, 127, -1, -1, -1, -1, -1, -1, -1, -128, 0, 0, 0, 0, 0, 0, 0,\n      1, -1, -1, -1, -1, -1, -1, -1, -1,\n      2, 1\n    }, null)).isNull();\n  }", "signature": "void parseBytes_unsupportedVersionId_toNull()", "full_signature": "@Test public void parseBytes_unsupportedVersionId_toNull()", "class_method_signature": "TraceContextBinaryFormatTest.parseBytes_unsupportedVersionId_toNull()", "testcase": true, "constructor": false, "invocations": ["isNull", "assertThat", "parseBytes"]}, "focal_class": {"identifier": "TraceContextBinaryFormat", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final byte VERSION = 0,\n    TRACE_ID_FIELD_ID = 0,\n    SPAN_ID_FIELD_ID = 1,\n    TRACE_OPTION_FIELD_ID = 2;", "modifier": "static final", "type": "byte", "declarator": "VERSION = 0", "var_name": "VERSION"}, {"original_string": "static final int FORMAT_LENGTH =\n    4 /* version + 3 fields */ + 16 /* trace ID */ + 8 /* span ID */ + 1 /* sampled bit */;", "modifier": "static final", "type": "int", "declarator": "FORMAT_LENGTH =\n    4 /* version + 3 fields */ + 16 /* trace ID */ + 8 /* span ID */ + 1", "var_name": "FORMAT_LENGTH"}], "methods": [{"identifier": "toBytes", "parameters": "(TraceContext traceContext)", "modifiers": "static", "return": "byte[]", "signature": "byte[] toBytes(TraceContext traceContext)", "full_signature": "static byte[] toBytes(TraceContext traceContext)", "class_method_signature": "TraceContextBinaryFormat.toBytes(TraceContext traceContext)", "testcase": false, "constructor": false}, {"identifier": "parseBytes", "parameters": "(byte[] bytes, @Nullable TagsBin tags)", "modifiers": "@Nullable static", "return": "TraceContext", "signature": "TraceContext parseBytes(byte[] bytes, @Nullable TagsBin tags)", "full_signature": "@Nullable static TraceContext parseBytes(byte[] bytes, @Nullable TagsBin tags)", "class_method_signature": "TraceContextBinaryFormat.parseBytes(byte[] bytes, @Nullable TagsBin tags)", "testcase": false, "constructor": false}, {"identifier": "writeLong", "parameters": "(byte[] data, int pos, long v)", "modifiers": "static", "return": "void", "signature": "void writeLong(byte[] data, int pos, long v)", "full_signature": "static void writeLong(byte[] data, int pos, long v)", "class_method_signature": "TraceContextBinaryFormat.writeLong(byte[] data, int pos, long v)", "testcase": false, "constructor": false}, {"identifier": "readLong", "parameters": "(byte[] data, int pos)", "modifiers": "static", "return": "long", "signature": "long readLong(byte[] data, int pos)", "full_signature": "static long readLong(byte[] data, int pos)", "class_method_signature": "TraceContextBinaryFormat.readLong(byte[] data, int pos)", "testcase": false, "constructor": false}], "file": "instrumentation/grpc/src/main/java/brave/grpc/TraceContextBinaryFormat.java"}, "focal_method": {"identifier": "parseBytes", "parameters": "(byte[] bytes, @Nullable TagsBin tags)", "modifiers": "@Nullable static", "return": "TraceContext", "body": "@Nullable static TraceContext parseBytes(byte[] bytes, @Nullable TagsBin tags) {\n    if (bytes == null) throw new NullPointerException(\"bytes == null\"); // programming error\n    if (bytes.length == 0) return null;\n    if (bytes[0] != VERSION) {\n      Platform.get().log(\"Invalid input: unsupported version {0}\", bytes[0], null);\n      return null;\n    }\n    if (bytes.length < FORMAT_LENGTH - 2 /* sampled field + bit is optional */) {\n      Platform.get().log(\"Invalid input: truncated\", null);\n      return null;\n    }\n    long traceIdHigh, traceId, spanId;\n    int pos = 1;\n    if (bytes[pos] == TRACE_ID_FIELD_ID) {\n      pos++;\n      traceIdHigh = readLong(bytes, pos);\n      traceId = readLong(bytes, pos + 8);\n      pos += 16;\n    } else {\n      Platform.get().log(\"Invalid input: expected trace ID at offset {0}\", pos, null);\n      return null;\n    }\n    if (bytes[pos] == SPAN_ID_FIELD_ID) {\n      pos++;\n      spanId = readLong(bytes, pos);\n      pos += 8;\n    } else {\n      Platform.get().log(\"Invalid input: expected span ID at offset {0}\", pos, null);\n      return null;\n    }\n    // The trace options field is optional. However, when present, it should be valid.\n    Boolean sampled = null;\n    if (bytes.length > pos && bytes[pos] == TRACE_OPTION_FIELD_ID) {\n      pos++;\n      if (bytes.length < pos + 1) {\n        Platform.get().log(\"Invalid input: truncated\", null);\n        return null;\n      }\n      sampled = bytes[pos] == 1;\n    }\n    TraceContext.Builder builder = TraceContext.newBuilder()\n      .traceIdHigh(traceIdHigh)\n      .traceId(traceId)\n      .spanId(spanId);\n    if (sampled != null) builder.sampled(sampled.booleanValue());\n    if (tags != null) builder.extra(Collections.singletonList(tags));\n    return builder.build();\n  }", "signature": "TraceContext parseBytes(byte[] bytes, @Nullable TagsBin tags)", "full_signature": "@Nullable static TraceContext parseBytes(byte[] bytes, @Nullable TagsBin tags)", "class_method_signature": "TraceContextBinaryFormat.parseBytes(byte[] bytes, @Nullable TagsBin tags)", "testcase": false, "constructor": false, "invocations": ["log", "get", "log", "get", "readLong", "readLong", "log", "get", "readLong", "log", "get", "log", "get", "spanId", "traceId", "traceIdHigh", "newBuilder", "sampled", "booleanValue", "extra", "singletonList", "build"]}, "repository": {"repo_id": 9278888, "url": "https://github.com/openzipkin/brave", "stars": 1754, "created": "4/7/2013 3:48:18 PM +00:00", "updates": "2020-01-26T11:52:41+00:00", "fork": "False", "license": "licensed"}}