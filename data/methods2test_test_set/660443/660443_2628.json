{"test_class": {"identifier": "UllmannStateTest", "superclass": "", "interfaces": "", "fields": [], "file": "base/isomorphism/src/test/java/org/openscience/cdk/isomorphism/UllmannStateTest.java"}, "test_case": {"identifier": "add", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void add() throws Exception {\n        UllmannState state = createBenzeneToNaphthalene(AtomMatcher.forAny(), BondMatcher.forAny());\n        assertThat(state.matrix.fix(), is(new int[][]{{1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\n                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\n                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}}));\n        assertTrue(state.add(0, 0));\n        assertThat(state.matrix.fix(), is(new int[][]{{1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\n                {-1, 1, -1, -1, -1, -1, -1, -1, -1, 1}, {1, -1, 1, -1, -1, -1, -1, -1, 1, -1},\n                {-1, 1, -1, 1, -1, -1, -1, 1, -1, 1}, {1, -1, 1, -1, -1, -1, -1, -1, 1, -1},\n                {-1, 1, -1, -1, -1, -1, -1, -1, -1, 1}}));\n        assertTrue(state.add(1, 9));\n        assertThat(state.matrix.fix(), is(new int[][]{{1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\n                {-1, -2, -1, -1, -1, -1, -1, -1, -1, 1}, {1, -1, -2, -1, -1, -1, -1, -1, 1, -1},\n                {-1, 1, -1, -2, -1, -1, -1, 1, -1, 1}, {1, -1, 1, -1, -1, -1, -1, -1, 1, -1},\n                {-1, 1, -1, -1, -1, -1, -1, -1, -1, 1}}));\n        assertTrue(state.add(2, 8));\n        assertThat(state.matrix.fix(), is(new int[][]{{1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\n                {-1, -2, -1, -1, -1, -1, -1, -1, -1, 1}, {-3, -1, -2, -1, -1, -1, -1, -1, 1, -1},\n                {-1, -3, -1, -2, -1, -1, -1, 1, -1, 1}, {1, -1, 1, -1, -1, -1, -1, -1, 1, -1},\n                {-1, 1, -1, -1, -1, -1, -1, -1, -1, 1}}));\n        assertTrue(state.add(3, 7));\n        assertThat(state.matrix.fix(), is(new int[][]{{1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\n                {-1, -2, -1, -1, -1, -1, -1, -1, -1, 1}, {-3, -1, -2, -1, -1, -1, -1, -1, 1, -1},\n                {-1, -3, -1, -2, -1, -1, -1, 1, -1, -4}, {-4, -1, 1, -1, -1, -1, -1, -1, 1, -1},\n                {-1, 1, -1, -1, -1, -1, -1, -1, -1, 1}}));\n        assertTrue(state.add(4, 2));\n        assertThat(state.matrix.fix(), is(new int[][]{{1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\n                {-1, -2, -1, -1, -1, -1, -1, -1, -1, 1}, {-3, -1, -2, -1, -1, -1, -1, -1, 1, -1},\n                {-1, -3, -1, -2, -1, -1, -1, 1, -1, -4}, {-4, -1, 1, -1, -1, -1, -1, -1, -5, -1},\n                {-1, 1, -1, -1, -1, -1, -1, -1, -1, -5}}));\n        assertTrue(state.add(5, 1));\n        assertThat(state.matrix.fix(), is(new int[][]{{1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\n                {-1, -2, -1, -1, -1, -1, -1, -1, -1, 1}, {-3, -1, -2, -1, -1, -1, -1, -1, 1, -1},\n                {-1, -3, -1, -2, -1, -1, -1, 1, -1, -4}, {-4, -1, 1, -1, -1, -1, -1, -1, -5, -1},\n                {-1, 1, -1, -1, -1, -1, -1, -1, -1, -5}}));\n    }", "signature": "void add()", "full_signature": "@Test public void add()", "class_method_signature": "UllmannStateTest.add()", "testcase": true, "constructor": false, "invocations": ["createBenzeneToNaphthalene", "forAny", "forAny", "assertThat", "fix", "is", "assertTrue", "add", "assertThat", "fix", "is", "assertTrue", "add", "assertThat", "fix", "is", "assertTrue", "add", "assertThat", "fix", "is", "assertTrue", "add", "assertThat", "fix", "is", "assertTrue", "add", "assertThat", "fix", "is", "assertTrue", "add", "assertThat", "fix", "is"]}, "focal_class": {"identifier": "UllmannState", "superclass": "extends State", "interfaces": "", "fields": [{"original_string": "final int[][]               g1, g2;", "modifier": "final", "type": "int[][]", "declarator": "g1", "var_name": "g1"}, {"original_string": "private final EdgeToBondMap bond1, bonds2;", "modifier": "private final", "type": "EdgeToBondMap", "declarator": "bond1", "var_name": "bond1"}, {"original_string": "final CompatibilityMatrix   matrix;", "modifier": "final", "type": "CompatibilityMatrix", "declarator": "matrix", "var_name": "matrix"}, {"original_string": "final int[]                 m1, m2;", "modifier": "final", "type": "int[]", "declarator": "m1", "var_name": "m1"}, {"original_string": "int                         size     = 0;", "modifier": "", "type": "int", "declarator": "size     = 0", "var_name": "size"}, {"original_string": "private final BondMatcher   bondMatcher;", "modifier": "private final", "type": "BondMatcher", "declarator": "bondMatcher", "var_name": "bondMatcher"}, {"original_string": "private static int          UNMAPPED = -1;", "modifier": "private static", "type": "int", "declarator": "UNMAPPED = -1", "var_name": "UNMAPPED"}], "methods": [{"identifier": "UllmannState", "parameters": "(IAtomContainer container1, IAtomContainer container2, int[][] g1, int[][] g2,\n            EdgeToBondMap bonds1, EdgeToBondMap bonds2, AtomMatcher atomMatcher, BondMatcher bondMatcher)", "modifiers": "public", "return": "", "signature": " UllmannState(IAtomContainer container1, IAtomContainer container2, int[][] g1, int[][] g2,\n            EdgeToBondMap bonds1, EdgeToBondMap bonds2, AtomMatcher atomMatcher, BondMatcher bondMatcher)", "full_signature": "public  UllmannState(IAtomContainer container1, IAtomContainer container2, int[][] g1, int[][] g2,\n            EdgeToBondMap bonds1, EdgeToBondMap bonds2, AtomMatcher atomMatcher, BondMatcher bondMatcher)", "class_method_signature": "UllmannState.UllmannState(IAtomContainer container1, IAtomContainer container2, int[][] g1, int[][] g2,\n            EdgeToBondMap bonds1, EdgeToBondMap bonds2, AtomMatcher atomMatcher, BondMatcher bondMatcher)", "testcase": false, "constructor": true}, {"identifier": "nextN", "parameters": "(int n)", "modifiers": "@Override", "return": "int", "signature": "int nextN(int n)", "full_signature": "@Override int nextN(int n)", "class_method_signature": "UllmannState.nextN(int n)", "testcase": false, "constructor": false}, {"identifier": "nextM", "parameters": "(int n, int m)", "modifiers": "@Override", "return": "int", "signature": "int nextM(int n, int m)", "full_signature": "@Override int nextM(int n, int m)", "class_method_signature": "UllmannState.nextM(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "nMax", "parameters": "()", "modifiers": "@Override", "return": "int", "signature": "int nMax()", "full_signature": "@Override int nMax()", "class_method_signature": "UllmannState.nMax()", "testcase": false, "constructor": false}, {"identifier": "mMax", "parameters": "()", "modifiers": "@Override", "return": "int", "signature": "int mMax()", "full_signature": "@Override int mMax()", "class_method_signature": "UllmannState.mMax()", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(int n, int m)", "modifiers": "@Override", "return": "boolean", "signature": "boolean add(int n, int m)", "full_signature": "@Override boolean add(int n, int m)", "class_method_signature": "UllmannState.add(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(int n, int m)", "modifiers": "@Override", "return": "void", "signature": "void remove(int n, int m)", "full_signature": "@Override void remove(int n, int m)", "class_method_signature": "UllmannState.remove(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "refine", "parameters": "(int row)", "modifiers": "private", "return": "boolean", "signature": "boolean refine(int row)", "full_signature": "private boolean refine(int row)", "class_method_signature": "UllmannState.refine(int row)", "testcase": false, "constructor": false}, {"identifier": "verify", "parameters": "(int n, int m)", "modifiers": "private", "return": "boolean", "signature": "boolean verify(int n, int m)", "full_signature": "private boolean verify(int n, int m)", "class_method_signature": "UllmannState.verify(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "hasCandidate", "parameters": "(int n)", "modifiers": "private", "return": "boolean", "signature": "boolean hasCandidate(int n)", "full_signature": "private boolean hasCandidate(int n)", "class_method_signature": "UllmannState.hasCandidate(int n)", "testcase": false, "constructor": false}, {"identifier": "mapping", "parameters": "()", "modifiers": "@Override", "return": "int[]", "signature": "int[] mapping()", "full_signature": "@Override int[] mapping()", "class_method_signature": "UllmannState.mapping()", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "@Override", "return": "int", "signature": "int size()", "full_signature": "@Override int size()", "class_method_signature": "UllmannState.size()", "testcase": false, "constructor": false}], "file": "base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/UllmannState.java"}, "focal_method": {"identifier": "add", "parameters": "(int n, int m)", "modifiers": "@Override", "return": "boolean", "body": "@Override\n    boolean add(int n, int m) {\n\n        if (!matrix.get(n, m)) return false;\n\n        // fix the mapping\n        matrix.markRow(n, -(n + 1));\n        matrix.set(n, m);\n\n        // attempt to refine the mapping\n        if (refine(n)) {\n            size = size + 1;\n            m1[n] = m;\n            m2[m] = n;\n            return true;\n        } else {\n            // mapping became invalid - unfix mapping\n            matrix.resetRows(n, -(n + 1));\n            return false;\n        }\n    }", "signature": "boolean add(int n, int m)", "full_signature": "@Override boolean add(int n, int m)", "class_method_signature": "UllmannState.add(int n, int m)", "testcase": false, "constructor": false, "invocations": ["get", "markRow", "set", "refine", "resetRows"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}