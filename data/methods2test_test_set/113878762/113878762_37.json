{"test_class": {"identifier": "StorageDirectTest", "superclass": "extends StorageTestCase", "interfaces": "", "fields": [{"original_string": "StorageDirect engine = (StorageDirect) super.engine;", "modifier": "", "type": "StorageDirect", "declarator": "engine = (StorageDirect) super.engine", "var_name": "engine"}, {"original_string": "static final long TEST_LS_RECID = StorageDirect.RECID_FREE_PHYS_RECORDS_START+1 ;", "modifier": "static final", "type": "long", "declarator": "TEST_LS_RECID = StorageDirect.RECID_FREE_PHYS_RECORDS_START+1", "var_name": "TEST_LS_RECID"}], "file": "migration/third-party/org.mapdb/src/test/java/org/mapdb/StorageDirectTest.java"}, "test_case": {"identifier": "compact", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void compact(){\n        Map<Long,Long> recids = new HashMap<Long, Long>();\n        for(Long l=0L;l<1000;l++){\n            recids.put(l,\n                    engine.put(l, Serializer.LONG_SERIALIZER));\n        }\n\n        engine.commit();\n        engine.compact();\n\n        for(Map.Entry<Long,Long> e:recids.entrySet()){\n            Long recid= e.getValue();\n            Long value = e.getKey();\n            assertEquals(value, engine.get(recid, Serializer.LONG_SERIALIZER));\n        }\n\n\n    }", "signature": "void compact()", "full_signature": "@Test public void compact()", "class_method_signature": "StorageDirectTest.compact()", "testcase": true, "constructor": false, "invocations": ["put", "put", "commit", "compact", "entrySet", "getValue", "getKey", "assertEquals", "get"]}, "focal_class": {"identifier": "StorageDirect", "superclass": "", "interfaces": "implements Engine", "fields": [{"original_string": "static final long PHYS_OFFSET_MASK = 0x0000FFFFFFFFFFFFL;", "modifier": "static final", "type": "long", "declarator": "PHYS_OFFSET_MASK = 0x0000FFFFFFFFFFFFL", "var_name": "PHYS_OFFSET_MASK"}, {"original_string": "static final long HEADER = 5646556656456456L;", "modifier": "static final", "type": "long", "declarator": "HEADER = 5646556656456456L", "var_name": "HEADER"}, {"original_string": "static final int RECID_CURRENT_PHYS_FILE_SIZE = 1;", "modifier": "static final", "type": "int", "declarator": "RECID_CURRENT_PHYS_FILE_SIZE = 1", "var_name": "RECID_CURRENT_PHYS_FILE_SIZE"}, {"original_string": "static final int RECID_CURRENT_INDEX_FILE_SIZE = 2;", "modifier": "static final", "type": "int", "declarator": "RECID_CURRENT_INDEX_FILE_SIZE = 2", "var_name": "RECID_CURRENT_INDEX_FILE_SIZE"}, {"original_string": "static final int RECID_FREE_INDEX_SLOTS = 3;", "modifier": "static final", "type": "int", "declarator": "RECID_FREE_INDEX_SLOTS = 3", "var_name": "RECID_FREE_INDEX_SLOTS"}, {"original_string": "static final int RECID_FREE_PHYS_RECORDS_START = 20;", "modifier": "static final", "type": "int", "declarator": "RECID_FREE_PHYS_RECORDS_START = 20", "var_name": "RECID_FREE_PHYS_RECORDS_START"}, {"original_string": "static final int NUMBER_OF_PHYS_FREE_SLOT =1000 + 1535;", "modifier": "static final", "type": "int", "declarator": "NUMBER_OF_PHYS_FREE_SLOT =1000 + 1535", "var_name": "NUMBER_OF_PHYS_FREE_SLOT"}, {"original_string": "static final int MAX_RECORD_SIZE = 65535;", "modifier": "static final", "type": "int", "declarator": "MAX_RECORD_SIZE = 65535", "var_name": "MAX_RECORD_SIZE"}, {"original_string": "static final byte LONG_STACK_NUM_OF_RECORDS_PER_PAGE = 100;", "modifier": "static final", "type": "byte", "declarator": "LONG_STACK_NUM_OF_RECORDS_PER_PAGE = 100", "var_name": "LONG_STACK_NUM_OF_RECORDS_PER_PAGE"}, {"original_string": "static final int LONG_STACK_PAGE_SIZE =   8 + LONG_STACK_NUM_OF_RECORDS_PER_PAGE * 8;", "modifier": "static final", "type": "int", "declarator": "LONG_STACK_PAGE_SIZE =   8 + LONG_STACK_NUM_OF_RECORDS_PER_PAGE * 8", "var_name": "LONG_STACK_PAGE_SIZE"}, {"original_string": "static final int INDEX_OFFSET_START = RECID_FREE_PHYS_RECORDS_START +NUMBER_OF_PHYS_FREE_SLOT;", "modifier": "static final", "type": "int", "declarator": "INDEX_OFFSET_START = RECID_FREE_PHYS_RECORDS_START +NUMBER_OF_PHYS_FREE_SLOT", "var_name": "INDEX_OFFSET_START"}, {"original_string": "public static final String DATA_FILE_EXT = \".p\";", "modifier": "public static final", "type": "String", "declarator": "DATA_FILE_EXT = \".p\"", "var_name": "DATA_FILE_EXT"}, {"original_string": "protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();", "modifier": "protected final", "type": "ReentrantReadWriteLock", "declarator": "lock = new ReentrantReadWriteLock()", "var_name": "lock"}, {"original_string": "protected final boolean appendOnly;", "modifier": "protected final", "type": "boolean", "declarator": "appendOnly", "var_name": "appendOnly"}, {"original_string": "protected final boolean deleteFilesOnExit;", "modifier": "protected final", "type": "boolean", "declarator": "deleteFilesOnExit", "var_name": "deleteFilesOnExit"}, {"original_string": "protected final boolean failOnWrongHeader;", "modifier": "protected final", "type": "boolean", "declarator": "failOnWrongHeader", "var_name": "failOnWrongHeader"}, {"original_string": "protected final boolean readOnly;", "modifier": "protected final", "type": "boolean", "declarator": "readOnly", "var_name": "readOnly"}, {"original_string": "volatile protected Volume phys;", "modifier": "volatile protected", "type": "Volume", "declarator": "phys", "var_name": "phys"}, {"original_string": "volatile protected Volume index;", "modifier": "volatile protected", "type": "Volume", "declarator": "index", "var_name": "index"}], "methods": [{"identifier": "StorageDirect", "parameters": "(Volume.Factory volFac, boolean appendOnly,\n                   boolean deleteFilesOnExit, boolean failOnWrongHeader, boolean readOnly)", "modifiers": "public", "return": "", "signature": " StorageDirect(Volume.Factory volFac, boolean appendOnly,\n                   boolean deleteFilesOnExit, boolean failOnWrongHeader, boolean readOnly)", "full_signature": "public  StorageDirect(Volume.Factory volFac, boolean appendOnly,\n                   boolean deleteFilesOnExit, boolean failOnWrongHeader, boolean readOnly)", "class_method_signature": "StorageDirect.StorageDirect(Volume.Factory volFac, boolean appendOnly,\n                   boolean deleteFilesOnExit, boolean failOnWrongHeader, boolean readOnly)", "testcase": false, "constructor": true}, {"identifier": "StorageDirect", "parameters": "(Volume.Factory volFac)", "modifiers": "public", "return": "", "signature": " StorageDirect(Volume.Factory volFac)", "full_signature": "public  StorageDirect(Volume.Factory volFac)", "class_method_signature": "StorageDirect.StorageDirect(Volume.Factory volFac)", "testcase": false, "constructor": true}, {"identifier": "put", "parameters": "(A value, Serializer<A> serializer)", "modifiers": "@Override public", "return": "long", "signature": "long put(A value, Serializer<A> serializer)", "full_signature": "@Override public long put(A value, Serializer<A> serializer)", "class_method_signature": "StorageDirect.put(A value, Serializer<A> serializer)", "testcase": false, "constructor": false}, {"identifier": "putLargeLinkedRecord", "parameters": "(DataOutput2 out, long recid)", "modifiers": "private", "return": "void", "signature": "void putLargeLinkedRecord(DataOutput2 out, long recid)", "full_signature": "private void putLargeLinkedRecord(DataOutput2 out, long recid)", "class_method_signature": "StorageDirect.putLargeLinkedRecord(DataOutput2 out, long recid)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(long recid, Serializer<A> serializer)", "modifiers": "@Override public", "return": "A", "signature": "A get(long recid, Serializer<A> serializer)", "full_signature": "@Override public A get(long recid, Serializer<A> serializer)", "class_method_signature": "StorageDirect.get(long recid, Serializer<A> serializer)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(long recid, A value, Serializer<A> serializer)", "modifiers": "@Override public", "return": "void", "signature": "void update(long recid, A value, Serializer<A> serializer)", "full_signature": "@Override public void update(long recid, A value, Serializer<A> serializer)", "class_method_signature": "StorageDirect.update(long recid, A value, Serializer<A> serializer)", "testcase": false, "constructor": false}, {"identifier": "delete", "parameters": "(long recid, Serializer<A> serializer)", "modifiers": "@Override public", "return": "void", "signature": "void delete(long recid, Serializer<A> serializer)", "full_signature": "@Override public void delete(long recid, Serializer<A> serializer)", "class_method_signature": "StorageDirect.delete(long recid, Serializer<A> serializer)", "testcase": false, "constructor": false}, {"identifier": "commit", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void commit()", "full_signature": "@Override public void commit()", "class_method_signature": "StorageDirect.commit()", "testcase": false, "constructor": false}, {"identifier": "rollback", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void rollback()", "full_signature": "@Override public void rollback()", "class_method_signature": "StorageDirect.rollback()", "testcase": false, "constructor": false}, {"identifier": "longStackTake", "parameters": "(final long listRecid)", "modifiers": "protected", "return": "long", "signature": "long longStackTake(final long listRecid)", "full_signature": "protected long longStackTake(final long listRecid)", "class_method_signature": "StorageDirect.longStackTake(final long listRecid)", "testcase": false, "constructor": false}, {"identifier": "longStackPut", "parameters": "(final long listRecid, final long offset)", "modifiers": "protected", "return": "void", "signature": "void longStackPut(final long listRecid, final long offset)", "full_signature": "protected void longStackPut(final long listRecid, final long offset)", "class_method_signature": "StorageDirect.longStackPut(final long listRecid, final long offset)", "testcase": false, "constructor": false}, {"identifier": "freePhysRecTake", "parameters": "(final int requiredSize)", "modifiers": "protected", "return": "long", "signature": "long freePhysRecTake(final int requiredSize)", "full_signature": "protected long freePhysRecTake(final int requiredSize)", "class_method_signature": "StorageDirect.freePhysRecTake(final int requiredSize)", "testcase": false, "constructor": false}, {"identifier": "writeInitValues", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void writeInitValues()", "full_signature": "private void writeInitValues()", "class_method_signature": "StorageDirect.writeInitValues()", "testcase": false, "constructor": false}, {"identifier": "writeLock_checkLocked", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void writeLock_checkLocked()", "full_signature": "protected void writeLock_checkLocked()", "class_method_signature": "StorageDirect.writeLock_checkLocked()", "testcase": false, "constructor": false}, {"identifier": "freePhysRecSize2FreeSlot", "parameters": "(final int size)", "modifiers": "final", "return": "int", "signature": "int freePhysRecSize2FreeSlot(final int size)", "full_signature": "final int freePhysRecSize2FreeSlot(final int size)", "class_method_signature": "StorageDirect.freePhysRecSize2FreeSlot(final int size)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "StorageDirect.close()", "testcase": false, "constructor": false}, {"identifier": "isClosed", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isClosed()", "full_signature": "@Override public boolean isClosed()", "class_method_signature": "StorageDirect.isClosed()", "testcase": false, "constructor": false}, {"identifier": "recordGet2", "parameters": "(long indexValue, Volume data, Serializer<A> serializer)", "modifiers": "protected", "return": "A", "signature": "A recordGet2(long indexValue, Volume data, Serializer<A> serializer)", "full_signature": "protected A recordGet2(long indexValue, Volume data, Serializer<A> serializer)", "class_method_signature": "StorageDirect.recordGet2(long indexValue, Volume data, Serializer<A> serializer)", "testcase": false, "constructor": false}, {"identifier": "freePhysRecPut", "parameters": "(final long indexValue)", "modifiers": "protected", "return": "void", "signature": "void freePhysRecPut(final long indexValue)", "full_signature": "protected void freePhysRecPut(final long indexValue)", "class_method_signature": "StorageDirect.freePhysRecPut(final long indexValue)", "testcase": false, "constructor": false}, {"identifier": "findFreePhysSlot", "parameters": "(int requiredSize)", "modifiers": "protected", "return": "long", "signature": "long findFreePhysSlot(int requiredSize)", "full_signature": "protected long findFreePhysSlot(int requiredSize)", "class_method_signature": "StorageDirect.findFreePhysSlot(int requiredSize)", "testcase": false, "constructor": false}, {"identifier": "compareAndSwap", "parameters": "(long recid, A expectedOldValue, A newValue, Serializer<A> serializer)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Serializer<A> serializer)", "full_signature": "@Override public boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Serializer<A> serializer)", "class_method_signature": "StorageDirect.compareAndSwap(long recid, A expectedOldValue, A newValue, Serializer<A> serializer)", "testcase": false, "constructor": false}, {"identifier": "isReadOnly", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isReadOnly()", "full_signature": "@Override public boolean isReadOnly()", "class_method_signature": "StorageDirect.isReadOnly()", "testcase": false, "constructor": false}, {"identifier": "unlinkPhysRecord", "parameters": "(long indexVal, long recid)", "modifiers": "protected", "return": "void", "signature": "void unlinkPhysRecord(long indexVal, long recid)", "full_signature": "protected void unlinkPhysRecord(long indexVal, long recid)", "class_method_signature": "StorageDirect.unlinkPhysRecord(long indexVal, long recid)", "testcase": false, "constructor": false}, {"identifier": "compact", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void compact()", "full_signature": "@Override public void compact()", "class_method_signature": "StorageDirect.compact()", "testcase": false, "constructor": false}], "file": "migration/third-party/org.mapdb/src/main/java/org/mapdb/StorageDirect.java"}, "focal_method": {"identifier": "compact", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void compact(){\n        if(readOnly) throw new IllegalAccessError();\n        if(index.getFile()==null) throw new UnsupportedOperationException(\"compact not supported for memory storage yet\");\n        lock.writeLock().lock();\n        try{\n            //create secondary files for compaction\n            //TODO RAF\n            //TODO memory based stores\n            final File indexFile = index.getFile();\n            final File physFile = phys.getFile();\n            final boolean isRaf = index instanceof Volume.RandomAccessFileVol;\n            Volume.Factory fab = Volume.fileFactory(false, isRaf, new File(indexFile+\".compact\"));\n            StorageDirect store2 = new StorageDirect(fab);\n\n            //transfer stack of free recids\n            for(long recid =longStackTake(RECID_FREE_INDEX_SLOTS);\n                recid!=0; recid=longStackTake(RECID_FREE_INDEX_SLOTS)){\n                store2.longStackPut(recid, RECID_FREE_INDEX_SLOTS);\n            }\n\n            //iterate over recids and transfer physical records\n            final long indexSize = index.getLong(RECID_CURRENT_INDEX_FILE_SIZE*8)/8;\n\n\n            store2.lock.writeLock().lock();\n            for(long recid = INDEX_OFFSET_START; recid<indexSize;recid++){\n                //read data from first store\n                long physOffset = index.getLong(recid*8);\n                long physSize = physOffset >>> 48;\n                //TODO linked records larger then 64KB\n                physOffset = physOffset & PHYS_OFFSET_MASK;\n\n                //write index value into second storage\n                store2.index.ensureAvailable(recid*8+8);\n\n                //get free place in second store, and write data there\n                if(physSize!=0){\n                    DataInput2 in = phys.getDataInput(physOffset, (int)physSize);\n                    long physOffset2 =\n                            store2.freePhysRecTake((int)physSize) & PHYS_OFFSET_MASK;\n\n                    store2.phys.ensureAvailable((physOffset2 & PHYS_OFFSET_MASK)+physSize);\n                    synchronized (in.buf){\n                        //copy directly from buffer\n                        in.buf.limit((int) (in.pos+physSize));\n                        in.buf.position(in.pos);\n                        store2.phys.putData(physOffset2, in.buf);\n                    }\n                    store2.index.putLong(recid*8, (physSize<<48)|physOffset2);\n                }else{\n                    //just write zeroes\n                    store2.index.putLong(recid*8, 0);\n                }\n            }\n\n            store2.index.putLong(RECID_CURRENT_INDEX_FILE_SIZE*8, indexSize*8);\n\n            File indexFile2 = store2.index.getFile();\n            File physFile2 = store2.phys.getFile();\n            store2.lock.writeLock().unlock();\n            store2.close();\n\n            long time = System.currentTimeMillis();\n            File indexFile_ = new File(indexFile.getPath()+\"_\"+time+\"_orig\");\n            File physFile_ = new File(physFile.getPath()+\"_\"+time+\"_orig\");\n\n            index.close();\n            phys.close();\n            if(!indexFile.renameTo(indexFile_))throw new InternalError();\n            if(!physFile.renameTo(physFile_))throw new InternalError();\n\n            if(!indexFile2.renameTo(indexFile))throw new InternalError();\n            //TODO process may fail in middle of rename, analyze sequence and add recovery\n            if(!physFile2.renameTo(physFile))throw new InternalError();\n\n            indexFile_.delete();\n            physFile_.delete();\n\n            Volume.Factory fac2 = Volume.fileFactory(false, isRaf, indexFile);\n            index = fac2.createIndexVolume();\n            phys = fac2.createPhysVolume();\n\n        }catch(IOException e){\n            throw new IOError(e);\n        }finally {\n            lock.writeLock().unlock();\n        }\n    }", "signature": "void compact()", "full_signature": "@Override public void compact()", "class_method_signature": "StorageDirect.compact()", "testcase": false, "constructor": false, "invocations": ["getFile", "lock", "writeLock", "getFile", "getFile", "fileFactory", "longStackTake", "longStackTake", "longStackPut", "getLong", "lock", "writeLock", "getLong", "ensureAvailable", "getDataInput", "freePhysRecTake", "ensureAvailable", "limit", "position", "putData", "putLong", "putLong", "putLong", "getFile", "getFile", "unlock", "writeLock", "close", "currentTimeMillis", "getPath", "getPath", "close", "close", "renameTo", "renameTo", "renameTo", "renameTo", "delete", "delete", "fileFactory", "createIndexVolume", "createPhysVolume", "unlock", "writeLock"]}, "repository": {"repo_id": 113878762, "url": "https://github.com/crossminer/scava", "language": "Java", "is_fork": false, "fork_count": 12, "stargazer_count": 16, "size": 1903904, "license": "licensed"}}