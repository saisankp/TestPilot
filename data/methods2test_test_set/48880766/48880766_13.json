{"test_class": {"identifier": "XlsxReaderTest", "superclass": "", "interfaces": "", "fields": [], "file": "excel/src/test/java/tech/tablesaw/io/xlsx/XlsxReaderTest.java"}, "test_case": {"identifier": "testSheetIndex", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testSheetIndex() throws IOException {\n    Table table =\n        new XlsxReader()\n            .read(XlsxReadOptions.builder(\"../data/multiplesheets.xlsx\").sheetIndex(1).build());\n    assertNotNull(table, \"No table read from multiplesheets.xlsx\");\n    assertColumnValues(table.stringColumn(\"stringcol\"), \"John\", \"Doe\");\n    assertEquals(\"multiplesheets.xlsx#Sheet2\", table.name(), \"table name is different\");\n\n    Table tableImplicit =\n        new XlsxReader().read(XlsxReadOptions.builder(\"../data/multiplesheets.xlsx\").build());\n    // the table from the 2nd sheet should be picked up\n    assertNotNull(tableImplicit, \"No table read from multiplesheets.xlsx\");\n\n    try {\n      new XlsxReader()\n          .read(XlsxReadOptions.builder(\"../data/multiplesheets.xlsx\").sheetIndex(0).build());\n      fail(\"First sheet is empty, no table should be found\");\n    } catch (IllegalArgumentException iae) {\n      // expected\n    }\n\n    try {\n      new XlsxReader()\n          .read(XlsxReadOptions.builder(\"../data/multiplesheets.xlsx\").sheetIndex(5).build());\n      fail(\"Only 2 sheets exist, no sheet 5\");\n    } catch (IndexOutOfBoundsException iobe) {\n      // expected\n    }\n  }", "signature": "void testSheetIndex()", "full_signature": "@Test public void testSheetIndex()", "class_method_signature": "XlsxReaderTest.testSheetIndex()", "testcase": true, "constructor": false, "invocations": ["read", "build", "sheetIndex", "builder", "assertNotNull", "assertColumnValues", "stringColumn", "assertEquals", "name", "read", "build", "builder", "assertNotNull", "read", "build", "sheetIndex", "builder", "fail", "read", "build", "sheetIndex", "builder", "fail"]}, "focal_class": {"identifier": "XlsxReader", "superclass": "", "interfaces": "implements DataReader<XlsxReadOptions>", "fields": [{"original_string": "private static final XlsxReader INSTANCE = new XlsxReader();", "modifier": "private static final", "type": "XlsxReader", "declarator": "INSTANCE = new XlsxReader()", "var_name": "INSTANCE"}], "methods": [{"identifier": "register", "parameters": "(ReaderRegistry registry)", "modifiers": "public static", "return": "void", "signature": "void register(ReaderRegistry registry)", "full_signature": "public static void register(ReaderRegistry registry)", "class_method_signature": "XlsxReader.register(ReaderRegistry registry)", "testcase": false, "constructor": false}, {"identifier": "read", "parameters": "(XlsxReadOptions options)", "modifiers": "@Override public", "return": "Table", "signature": "Table read(XlsxReadOptions options)", "full_signature": "@Override public Table read(XlsxReadOptions options)", "class_method_signature": "XlsxReader.read(XlsxReadOptions options)", "testcase": false, "constructor": false}, {"identifier": "readMultiple", "parameters": "(XlsxReadOptions options)", "modifiers": "public", "return": "List<Table>", "signature": "List<Table> readMultiple(XlsxReadOptions options)", "full_signature": "public List<Table> readMultiple(XlsxReadOptions options)", "class_method_signature": "XlsxReader.readMultiple(XlsxReadOptions options)", "testcase": false, "constructor": false}, {"identifier": "readMultiple", "parameters": "(XlsxReadOptions options, boolean includeNulls)", "modifiers": "protected", "return": "List<Table>", "signature": "List<Table> readMultiple(XlsxReadOptions options, boolean includeNulls)", "full_signature": "protected List<Table> readMultiple(XlsxReadOptions options, boolean includeNulls)", "class_method_signature": "XlsxReader.readMultiple(XlsxReadOptions options, boolean includeNulls)", "testcase": false, "constructor": false}, {"identifier": "isBlank", "parameters": "(Cell cell)", "modifiers": "private", "return": "Boolean", "signature": "Boolean isBlank(Cell cell)", "full_signature": "private Boolean isBlank(Cell cell)", "class_method_signature": "XlsxReader.isBlank(Cell cell)", "testcase": false, "constructor": false}, {"identifier": "getColumnType", "parameters": "(Cell cell)", "modifiers": "private", "return": "ColumnType", "signature": "ColumnType getColumnType(Cell cell)", "full_signature": "private ColumnType getColumnType(Cell cell)", "class_method_signature": "XlsxReader.getColumnType(Cell cell)", "testcase": false, "constructor": false}, {"identifier": "findTableArea", "parameters": "(Sheet sheet)", "modifiers": "private", "return": "TableRange", "signature": "TableRange findTableArea(Sheet sheet)", "full_signature": "private TableRange findTableArea(Sheet sheet)", "class_method_signature": "XlsxReader.findTableArea(Sheet sheet)", "testcase": false, "constructor": false}, {"identifier": "findRowArea", "parameters": "(Row row)", "modifiers": "private", "return": "TableRange", "signature": "TableRange findRowArea(Row row)", "full_signature": "private TableRange findRowArea(Row row)", "class_method_signature": "XlsxReader.findRowArea(Row row)", "testcase": false, "constructor": false}, {"identifier": "getInputStream", "parameters": "(XlsxReadOptions options, byte[] bytes)", "modifiers": "private", "return": "InputStream", "signature": "InputStream getInputStream(XlsxReadOptions options, byte[] bytes)", "full_signature": "private InputStream getInputStream(XlsxReadOptions options, byte[] bytes)", "class_method_signature": "XlsxReader.getInputStream(XlsxReadOptions options, byte[] bytes)", "testcase": false, "constructor": false}, {"identifier": "createTable", "parameters": "(Sheet sheet, TableRange tableArea, XlsxReadOptions options)", "modifiers": "private", "return": "Table", "signature": "Table createTable(Sheet sheet, TableRange tableArea, XlsxReadOptions options)", "full_signature": "private Table createTable(Sheet sheet, TableRange tableArea, XlsxReadOptions options)", "class_method_signature": "XlsxReader.createTable(Sheet sheet, TableRange tableArea, XlsxReadOptions options)", "testcase": false, "constructor": false}, {"identifier": "appendValue", "parameters": "(Column<?> column, Cell cell)", "modifiers": "@SuppressWarnings(\"unchecked\") private", "return": "Column<?>", "signature": "Column<?> appendValue(Column<?> column, Cell cell)", "full_signature": "@SuppressWarnings(\"unchecked\") private Column<?> appendValue(Column<?> column, Cell cell)", "class_method_signature": "XlsxReader.appendValue(Column<?> column, Cell cell)", "testcase": false, "constructor": false}, {"identifier": "createColumn", "parameters": "(String name, Cell cell)", "modifiers": "private", "return": "Column<?>", "signature": "Column<?> createColumn(String name, Cell cell)", "full_signature": "private Column<?> createColumn(String name, Cell cell)", "class_method_signature": "XlsxReader.createColumn(String name, Cell cell)", "testcase": false, "constructor": false}, {"identifier": "read", "parameters": "(Source source)", "modifiers": "@Override public", "return": "Table", "signature": "Table read(Source source)", "full_signature": "@Override public Table read(Source source)", "class_method_signature": "XlsxReader.read(Source source)", "testcase": false, "constructor": false}], "file": "excel/src/main/java/tech/tablesaw/io/xlsx/XlsxReader.java"}, "focal_method": {"identifier": "read", "parameters": "(XlsxReadOptions options)", "modifiers": "@Override public", "return": "Table", "body": "@Override\n  public Table read(XlsxReadOptions options) throws IOException {\n    List<Table> tables = readMultiple(options, true);\n    if (options.sheetIndex() != null) {\n      int index = options.sheetIndex();\n      if (index < 0 || index >= tables.size()) {\n        throw new IndexOutOfBoundsException(\n            String.format(\"Sheet index %d outside bounds. %d sheets found.\", index, tables.size()));\n      }\n\n      Table table = tables.get(index);\n      if (table == null) {\n        throw new IllegalArgumentException(\n            String.format(\"No table found at sheet index %d.\", index));\n      }\n      return table;\n    }\n    // since no specific sheetIndex asked, return first table\n    return tables.stream()\n        .filter(t -> t != null)\n        .findFirst()\n        .orElseThrow(() -> new IllegalArgumentException(\"No tables found.\"));\n  }", "signature": "Table read(XlsxReadOptions options)", "full_signature": "@Override public Table read(XlsxReadOptions options)", "class_method_signature": "XlsxReader.read(XlsxReadOptions options)", "testcase": false, "constructor": false, "invocations": ["readMultiple", "sheetIndex", "sheetIndex", "size", "format", "size", "get", "format", "orElseThrow", "findFirst", "filter", "stream"]}, "repository": {"repo_id": 48880766, "url": "https://github.com/jtablesaw/tablesaw", "stars": 2021, "created": "1/1/2016 2:58:28 PM +00:00", "updates": "2020-01-24T23:26:07+00:00", "fork": "False", "license": "licensed"}}