{"test_class": {"identifier": "WarAnalyzerTest", "superclass": "", "interfaces": "", "fields": [], "file": "lang-java/src/test/java/org/eclipse/steady/java/WarAnalyzerTest.java"}, "test_case": {"identifier": "testAnalyze", "parameters": "()", "modifiers": "@Test @Category(Slow.class) public", "return": "void", "body": "@Test\n  @Category(Slow.class)\n  public void testAnalyze() {\n    try {\n      final WarAnalyzer wa = new WarAnalyzer();\n      wa.analyze(new File(\"./src/test/resources/examples.war\"));\n      wa.setWorkDir(Paths.get(\"./target\"));\n      wa.setRename(true);\n      WarAnalyzer.setAppContext(new Application(\"dummy-group\", \"dummy-artifact\", \"0.0.1-SNAPSHOT\"));\n      wa.call();\n\n      // 15 archives in WEB-INF/lib\n      final Set<FileAnalyzer> fas = wa.getChilds(true);\n      assertEquals(15, fas.size());\n\n      // 15 constructs in classes in WEB-INF/classes\n      final Set<ConstructId> cids = wa.getConstructIds();\n      assertEquals(15, cids.size());\n    } catch (Exception e) {\n      e.printStackTrace();\n      assertTrue(false);\n    }\n  }", "signature": "void testAnalyze()", "full_signature": "@Test @Category(Slow.class) public void testAnalyze()", "class_method_signature": "WarAnalyzerTest.testAnalyze()", "testcase": true, "constructor": false, "invocations": ["analyze", "setWorkDir", "get", "setRename", "setAppContext", "call", "getChilds", "assertEquals", "size", "getConstructIds", "assertEquals", "size", "printStackTrace", "assertTrue"]}, "focal_class": {"identifier": "WarAnalyzer", "superclass": "extends JarAnalyzer", "interfaces": "", "fields": [{"original_string": "private static final Logger log = org.apache.logging.log4j.LogManager.getLogger();", "modifier": "private static final", "type": "Logger", "declarator": "log = org.apache.logging.log4j.LogManager.getLogger()", "var_name": "log"}, {"original_string": "private static final String INCL_SPACE = \"vulas.core.instr.static.inclSpace\";", "modifier": "private static final", "type": "String", "declarator": "INCL_SPACE = \"vulas.core.instr.static.inclSpace\"", "var_name": "INCL_SPACE"}, {"original_string": "private static final String INCL_BACKEND_URL = \"vulas.core.instr.static.inclBackendUrl\";", "modifier": "private static final", "type": "String", "declarator": "INCL_BACKEND_URL = \"vulas.core.instr.static.inclBackendUrl\"", "var_name": "INCL_BACKEND_URL"}, {"original_string": "private Map<JavaId, ClassVisitor> instrumentedClasses = new HashMap<JavaId, ClassVisitor>();", "modifier": "private", "type": "Map<JavaId, ClassVisitor>", "declarator": "instrumentedClasses = new HashMap<JavaId, ClassVisitor>()", "var_name": "instrumentedClasses"}, {"original_string": "private Path tmpDir = null;", "modifier": "private", "type": "Path", "declarator": "tmpDir = null", "var_name": "tmpDir"}, {"original_string": "private Path inclDir = null;", "modifier": "private", "type": "Path", "declarator": "inclDir = null", "var_name": "inclDir"}, {"original_string": "private ArchiveAnalysisManager mgr = null;", "modifier": "private", "type": "ArchiveAnalysisManager", "declarator": "mgr = null", "var_name": "mgr"}, {"original_string": "private Set<FileAnalyzer> nestedAnalyzers = null;", "modifier": "private", "type": "Set<FileAnalyzer>", "declarator": "nestedAnalyzers = null", "var_name": "nestedAnalyzers"}, {"original_string": "private Set<Path> ignoredIncludes = new HashSet<Path>();", "modifier": "private", "type": "Set<Path>", "declarator": "ignoredIncludes = new HashSet<Path>()", "var_name": "ignoredIncludes"}], "methods": [{"identifier": "getSupportedFileExtensions", "parameters": "()", "modifiers": "@Override public", "return": "String[]", "signature": "String[] getSupportedFileExtensions()", "full_signature": "@Override public String[] getSupportedFileExtensions()", "class_method_signature": "WarAnalyzer.getSupportedFileExtensions()", "testcase": false, "constructor": false}, {"identifier": "analyze", "parameters": "(final File _file)", "modifiers": "@Override public", "return": "void", "signature": "void analyze(final File _file)", "full_signature": "@Override public void analyze(final File _file)", "class_method_signature": "WarAnalyzer.analyze(final File _file)", "testcase": false, "constructor": false}, {"identifier": "setIncludeDir", "parameters": "(Path _p)", "modifiers": "public", "return": "void", "signature": "void setIncludeDir(Path _p)", "full_signature": "public void setIncludeDir(Path _p)", "class_method_signature": "WarAnalyzer.setIncludeDir(Path _p)", "testcase": false, "constructor": false}, {"identifier": "setRename", "parameters": "(boolean _b)", "modifiers": "public", "return": "void", "signature": "void setRename(boolean _b)", "full_signature": "public void setRename(boolean _b)", "class_method_signature": "WarAnalyzer.setRename(boolean _b)", "testcase": false, "constructor": false}, {"identifier": "createInstrumentedArchive", "parameters": "()", "modifiers": "@Override protected synchronized", "return": "void", "signature": "void createInstrumentedArchive()", "full_signature": "@Override protected synchronized void createInstrumentedArchive()", "class_method_signature": "WarAnalyzer.createInstrumentedArchive()", "testcase": false, "constructor": false}, {"identifier": "hasChilds", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean hasChilds()", "full_signature": "@Override public boolean hasChilds()", "class_method_signature": "WarAnalyzer.hasChilds()", "testcase": false, "constructor": false}, {"identifier": "getChilds", "parameters": "(boolean _recursive)", "modifiers": "@Override public", "return": "Set<FileAnalyzer>", "signature": "Set<FileAnalyzer> getChilds(boolean _recursive)", "full_signature": "@Override public Set<FileAnalyzer> getChilds(boolean _recursive)", "class_method_signature": "WarAnalyzer.getChilds(boolean _recursive)", "testcase": false, "constructor": false}, {"identifier": "getConstructIds", "parameters": "()", "modifiers": "@Override public synchronized", "return": "Set<ConstructId>", "signature": "Set<ConstructId> getConstructIds()", "full_signature": "@Override public synchronized Set<ConstructId> getConstructIds()", "class_method_signature": "WarAnalyzer.getConstructIds()", "testcase": false, "constructor": false}, {"identifier": "getInputStream", "parameters": "(String _regex, JarEntry _entry)", "modifiers": "@Override public", "return": "InputStream", "signature": "InputStream getInputStream(String _regex, JarEntry _entry)", "full_signature": "@Override public InputStream getInputStream(String _regex, JarEntry _entry)", "class_method_signature": "WarAnalyzer.getInputStream(String _regex, JarEntry _entry)", "testcase": false, "constructor": false}], "file": "lang-java/src/main/java/org/eclipse/steady/java/WarAnalyzer.java"}, "focal_method": {"identifier": "analyze", "parameters": "(final File _file)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void analyze(final File _file) throws FileAnalysisException {\n    try {\n      super.analyze(_file);\n\n      // Extract the WAR\n      if (this.workDir != null) this.tmpDir = Paths.get(this.workDir.toString(), \"war_analysis\");\n      else {\n        try {\n          this.tmpDir = java.nio.file.Files.createTempDirectory(\"war_analysis_\");\n        } catch (IOException e) {\n          throw new IllegalStateException(\"Unable to create temp directory\", e);\n        }\n      }\n      this.jarWriter.extract(this.tmpDir);\n\n      // Add WEB-INF/classes to the classpath\n      try {\n        JarAnalyzer.insertClasspath(\n            Paths.get(this.tmpDir.toString(), \"WEB-INF\", \"classes\").toString());\n      } catch (Exception e) {\n        // No problem at all if instrumentation is not requested.\n        // If instrumentation is requested, however, some classes may not compile\n        WarAnalyzer.log.error(\n            this.toString() + \": Error while updating the classpath: \" + e.getMessage());\n      }\n    } catch (IllegalStateException e) {\n      log.error(\"IllegalStateException when analyzing file [\" + _file + \"]: \" + e.getMessage());\n      throw new FileAnalysisException(\n          \"Error when analyzing file [\" + _file + \"]: \" + e.getMessage(), e);\n    } catch (IOException e) {\n      log.error(\"IOException when analyzing file [\" + _file + \"]: \" + e.getMessage());\n      throw new FileAnalysisException(\n          \"Error when analyzing file [\" + _file + \"]: \" + e.getMessage(), e);\n    } catch (Exception e) {\n      log.error(\"Exception when analyzing file [\" + _file + \"]: \" + e.getMessage());\n      throw new FileAnalysisException(\n          \"Error when analyzing file [\" + _file + \"]: \" + e.getMessage(), e);\n    }\n  }", "signature": "void analyze(final File _file)", "full_signature": "@Override public void analyze(final File _file)", "class_method_signature": "WarAnalyzer.analyze(final File _file)", "testcase": false, "constructor": false, "invocations": ["analyze", "get", "toString", "createTempDirectory", "extract", "insertClasspath", "toString", "get", "toString", "error", "toString", "getMessage", "error", "getMessage", "getMessage", "error", "getMessage", "getMessage", "error", "getMessage", "getMessage"]}, "repository": {"repo_id": 145424401, "url": "https://github.com/eclipse/steady", "stars": 353, "created": "8/20/2018 1:54:15 PM +00:00", "updates": "2020-01-25T08:37:00+00:00", "fork": "False", "license": "licensed"}}