{"test_class": {"identifier": "RedisQueueCircuitBreakerStorageTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Vertx vertx;", "modifier": "private static", "type": "Vertx", "declarator": "vertx", "var_name": "vertx"}, {"original_string": "private Jedis jedis;", "modifier": "private", "type": "Jedis", "declarator": "jedis", "var_name": "jedis"}, {"original_string": "private static RedisQueueCircuitBreakerStorage storage;", "modifier": "private static", "type": "RedisQueueCircuitBreakerStorage", "declarator": "storage", "var_name": "storage"}, {"original_string": "@org.junit.Rule\n    public Timeout rule = Timeout.seconds(5);", "modifier": "@org.junit.Rule\n    public", "type": "Timeout", "declarator": "rule = Timeout.seconds(5)", "var_name": "rule"}], "file": "gateleen-queue/src/test/java/org/swisspush/gateleen/queue/queuing/circuitbreaker/impl/RedisQueueCircuitBreakerStorageTest.java"}, "test_case": {"identifier": "testCloseAndRemoveCircuit", "parameters": "(TestContext context)", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCloseAndRemoveCircuit(TestContext context){\n        Async async = context.async();\n        String circuitHash = \"anotherCircuitHash\";\n\n        context.assertFalse(jedis.exists(key(circuitHash, QueueResponseType.SUCCESS)));\n        context.assertFalse(jedis.exists(key(circuitHash, QueueResponseType.FAILURE)));\n        context.assertFalse(jedis.exists(queuesKey(circuitHash)));\n\n        context.assertFalse(jedis.exists(STORAGE_ALL_CIRCUITS));\n        context.assertFalse(jedis.exists(STORAGE_HALFOPEN_CIRCUITS));\n        context.assertFalse(jedis.exists(STORAGE_OPEN_CIRCUITS));\n        context.assertFalse(jedis.exists(STORAGE_QUEUES_TO_UNLOCK));\n\n        // prepare some test data\n        writeQueueCircuitStateToDatabase(circuitHash, HALF_OPEN);\n        writeQueueCircuitFailPercentageToDatabase(circuitHash, 50);\n\n        jedis.zadd(key(circuitHash, QueueResponseType.SUCCESS), 1, \"req-1\");\n        jedis.zadd(key(circuitHash, QueueResponseType.SUCCESS), 2, \"req-2\");\n        jedis.zadd(key(circuitHash, QueueResponseType.SUCCESS), 3, \"req-3\");\n        jedis.zadd(key(circuitHash, QueueResponseType.FAILURE), 4, \"req-4\");\n        jedis.zadd(key(circuitHash, QueueResponseType.FAILURE), 5, \"req-5\");\n        jedis.zadd(key(circuitHash, QueueResponseType.FAILURE), 6, \"req-6\");\n\n        jedis.zadd(queuesKey(circuitHash), 1, \"queue_1\");\n        jedis.zadd(queuesKey(circuitHash), 2, \"queue_2\");\n        jedis.zadd(queuesKey(circuitHash), 3, \"queue_3\");\n\n        addToCircuitsSets(HALF_OPEN, \"a\");\n        addToCircuitsSets(HALF_OPEN, circuitHash);\n        addToCircuitsSets(HALF_OPEN, \"b\");\n        addToCircuitsSets(HALF_OPEN, \"c\");\n\n        jedis.sadd(STORAGE_OPEN_CIRCUITS, \"x\");\n\n        context.assertEquals(3L, jedis.zcard(key(circuitHash, QueueResponseType.SUCCESS)));\n        context.assertEquals(3L, jedis.zcard(key(circuitHash, QueueResponseType.FAILURE)));\n        context.assertEquals(3L, jedis.zcard(queuesKey(circuitHash)));\n        context.assertEquals(4L, jedis.scard(STORAGE_HALFOPEN_CIRCUITS));\n        context.assertEquals(4L, jedis.scard(STORAGE_ALL_CIRCUITS));\n        context.assertEquals(1L, jedis.scard(STORAGE_OPEN_CIRCUITS));\n        context.assertEquals(0L, jedis.llen(STORAGE_QUEUES_TO_UNLOCK));\n\n        PatternAndCircuitHash patternAndCircuitHash = buildPatternAndCircuitHash(\"/anotherCircuit\", circuitHash);\n        storage.closeAndRemoveCircuit(patternAndCircuitHash).setHandler(event -> {\n            context.assertTrue(event.succeeded());\n\n            context.assertFalse(jedis.exists(key(circuitHash, QueueResponseType.SUCCESS)));\n            context.assertFalse(jedis.exists(key(circuitHash, QueueResponseType.FAILURE)));\n            context.assertFalse(jedis.exists(queuesKey(circuitHash)));\n\n            context.assertTrue(jedis.exists(STORAGE_HALFOPEN_CIRCUITS));\n            context.assertTrue(jedis.exists(STORAGE_ALL_CIRCUITS));\n            context.assertTrue(jedis.exists(STORAGE_QUEUES_TO_UNLOCK));\n\n            context.assertEquals(3L, jedis.llen(STORAGE_QUEUES_TO_UNLOCK));\n            context.assertEquals(\"queue_1\", jedis.lpop(STORAGE_QUEUES_TO_UNLOCK));\n            context.assertEquals(\"queue_2\", jedis.lpop(STORAGE_QUEUES_TO_UNLOCK));\n            context.assertEquals(\"queue_3\", jedis.lpop(STORAGE_QUEUES_TO_UNLOCK));\n\n            context.assertFalse(jedis.exists(infosKey(circuitHash)));\n            context.assertFalse(jedis.exists(key(circuitHash, QueueResponseType.SUCCESS)));\n            context.assertFalse(jedis.exists(key(circuitHash, QueueResponseType.FAILURE)));\n            context.assertFalse(jedis.exists(queuesKey(circuitHash)));\n\n            context.assertEquals(3L, jedis.scard(STORAGE_HALFOPEN_CIRCUITS));\n            context.assertEquals(3L, jedis.scard(STORAGE_ALL_CIRCUITS));\n            Set<String> halfOpenCircuits = jedis.smembers(STORAGE_HALFOPEN_CIRCUITS);\n            context.assertTrue(halfOpenCircuits.contains(\"a\"));\n            context.assertTrue(halfOpenCircuits.contains(\"b\"));\n            context.assertTrue(halfOpenCircuits.contains(\"c\"));\n            context.assertFalse(halfOpenCircuits.contains(circuitHash));\n\n            Set<String> allCircuits = jedis.smembers(STORAGE_ALL_CIRCUITS);\n            context.assertTrue(allCircuits.contains(\"a\"));\n            context.assertTrue(allCircuits.contains(\"b\"));\n            context.assertTrue(allCircuits.contains(\"c\"));\n            context.assertFalse(allCircuits.contains(circuitHash));\n\n            context.assertEquals(1L, jedis.scard(STORAGE_OPEN_CIRCUITS));\n            Set<String> openCircuits = jedis.smembers(STORAGE_OPEN_CIRCUITS);\n            context.assertTrue(openCircuits.contains(\"x\"));\n            async.complete();\n        });\n    }", "signature": "void testCloseAndRemoveCircuit(TestContext context)", "full_signature": "@Test public void testCloseAndRemoveCircuit(TestContext context)", "class_method_signature": "RedisQueueCircuitBreakerStorageTest.testCloseAndRemoveCircuit(TestContext context)", "testcase": true, "constructor": false, "invocations": ["async", "assertFalse", "exists", "key", "assertFalse", "exists", "key", "assertFalse", "exists", "queuesKey", "assertFalse", "exists", "assertFalse", "exists", "assertFalse", "exists", "assertFalse", "exists", "writeQueueCircuitStateToDatabase", "writeQueueCircuitFailPercentageToDatabase", "zadd", "key", "zadd", "key", "zadd", "key", "zadd", "key", "zadd", "key", "zadd", "key", "zadd", "queuesKey", "zadd", "queuesKey", "zadd", "queuesKey", "addToCircuitsSets", "addToCircuitsSets", "addToCircuitsSets", "addToCircuitsSets", "sadd", "assertEquals", "zcard", "key", "assertEquals", "zcard", "key", "assertEquals", "zcard", "queuesKey", "assertEquals", "scard", "assertEquals", "scard", "assertEquals", "scard", "assertEquals", "llen", "buildPatternAndCircuitHash", "setHandler", "closeAndRemoveCircuit", "assertTrue", "succeeded", "assertFalse", "exists", "key", "assertFalse", "exists", "key", "assertFalse", "exists", "queuesKey", "assertTrue", "exists", "assertTrue", "exists", "assertTrue", "exists", "assertEquals", "llen", "assertEquals", "lpop", "assertEquals", "lpop", "assertEquals", "lpop", "assertFalse", "exists", "infosKey", "assertFalse", "exists", "key", "assertFalse", "exists", "key", "assertFalse", "exists", "queuesKey", "assertEquals", "scard", "assertEquals", "scard", "smembers", "assertTrue", "contains", "assertTrue", "contains", "assertTrue", "contains", "assertFalse", "contains", "smembers", "assertTrue", "contains", "assertTrue", "contains", "assertTrue", "contains", "assertFalse", "contains", "assertEquals", "scard", "smembers", "assertTrue", "contains", "complete"]}, "focal_class": {"identifier": "RedisQueueCircuitBreakerStorage", "superclass": "", "interfaces": "implements QueueCircuitBreakerStorage", "fields": [{"original_string": "private RedisClient redisClient;", "modifier": "private", "type": "RedisClient", "declarator": "redisClient", "var_name": "redisClient"}, {"original_string": "private Logger log = LoggerFactory.getLogger(RedisQueueCircuitBreakerStorage.class);", "modifier": "private", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(RedisQueueCircuitBreakerStorage.class)", "var_name": "log"}, {"original_string": "public static final String STORAGE_PREFIX = \"gateleen.queue-circuit-breaker:\";", "modifier": "public static final", "type": "String", "declarator": "STORAGE_PREFIX = \"gateleen.queue-circuit-breaker:\"", "var_name": "STORAGE_PREFIX"}, {"original_string": "public static final String STORAGE_INFOS_SUFFIX = \":infos\";", "modifier": "public static final", "type": "String", "declarator": "STORAGE_INFOS_SUFFIX = \":infos\"", "var_name": "STORAGE_INFOS_SUFFIX"}, {"original_string": "public static final String STORAGE_QUEUES_SUFFIX = \":queues\";", "modifier": "public static final", "type": "String", "declarator": "STORAGE_QUEUES_SUFFIX = \":queues\"", "var_name": "STORAGE_QUEUES_SUFFIX"}, {"original_string": "public static final String STORAGE_ALL_CIRCUITS = STORAGE_PREFIX + \"all-circuits\";", "modifier": "public static final", "type": "String", "declarator": "STORAGE_ALL_CIRCUITS = STORAGE_PREFIX + \"all-circuits\"", "var_name": "STORAGE_ALL_CIRCUITS"}, {"original_string": "public static final String STORAGE_HALFOPEN_CIRCUITS = STORAGE_PREFIX + \"half-open-circuits\";", "modifier": "public static final", "type": "String", "declarator": "STORAGE_HALFOPEN_CIRCUITS = STORAGE_PREFIX + \"half-open-circuits\"", "var_name": "STORAGE_HALFOPEN_CIRCUITS"}, {"original_string": "public static final String STORAGE_OPEN_CIRCUITS = STORAGE_PREFIX + \"open-circuits\";", "modifier": "public static final", "type": "String", "declarator": "STORAGE_OPEN_CIRCUITS = STORAGE_PREFIX + \"open-circuits\"", "var_name": "STORAGE_OPEN_CIRCUITS"}, {"original_string": "public static final String STORAGE_QUEUES_TO_UNLOCK = STORAGE_PREFIX + \"queues-to-unlock\";", "modifier": "public static final", "type": "String", "declarator": "STORAGE_QUEUES_TO_UNLOCK = STORAGE_PREFIX + \"queues-to-unlock\"", "var_name": "STORAGE_QUEUES_TO_UNLOCK"}, {"original_string": "public static final String FIELD_STATE = \"state\";", "modifier": "public static final", "type": "String", "declarator": "FIELD_STATE = \"state\"", "var_name": "FIELD_STATE"}, {"original_string": "public static final String FIELD_FAILRATIO = \"failRatio\";", "modifier": "public static final", "type": "String", "declarator": "FIELD_FAILRATIO = \"failRatio\"", "var_name": "FIELD_FAILRATIO"}, {"original_string": "public static final String FIELD_CIRCUIT = \"circuit\";", "modifier": "public static final", "type": "String", "declarator": "FIELD_CIRCUIT = \"circuit\"", "var_name": "FIELD_CIRCUIT"}, {"original_string": "private LuaScriptState openCircuitLuaScriptState;", "modifier": "private", "type": "LuaScriptState", "declarator": "openCircuitLuaScriptState", "var_name": "openCircuitLuaScriptState"}, {"original_string": "private LuaScriptState closeCircuitLuaScriptState;", "modifier": "private", "type": "LuaScriptState", "declarator": "closeCircuitLuaScriptState", "var_name": "closeCircuitLuaScriptState"}, {"original_string": "private LuaScriptState reOpenCircuitLuaScriptState;", "modifier": "private", "type": "LuaScriptState", "declarator": "reOpenCircuitLuaScriptState", "var_name": "reOpenCircuitLuaScriptState"}, {"original_string": "private LuaScriptState halfOpenCircuitLuaScriptState;", "modifier": "private", "type": "LuaScriptState", "declarator": "halfOpenCircuitLuaScriptState", "var_name": "halfOpenCircuitLuaScriptState"}, {"original_string": "private LuaScriptState unlockSampleQueuesLuaScriptState;", "modifier": "private", "type": "LuaScriptState", "declarator": "unlockSampleQueuesLuaScriptState", "var_name": "unlockSampleQueuesLuaScriptState"}, {"original_string": "private LuaScriptState getAllCircuitsLuaScriptState;", "modifier": "private", "type": "LuaScriptState", "declarator": "getAllCircuitsLuaScriptState", "var_name": "getAllCircuitsLuaScriptState"}], "methods": [{"identifier": "RedisQueueCircuitBreakerStorage", "parameters": "(RedisClient redisClient)", "modifiers": "public", "return": "", "signature": " RedisQueueCircuitBreakerStorage(RedisClient redisClient)", "full_signature": "public  RedisQueueCircuitBreakerStorage(RedisClient redisClient)", "class_method_signature": "RedisQueueCircuitBreakerStorage.RedisQueueCircuitBreakerStorage(RedisClient redisClient)", "testcase": false, "constructor": true}, {"identifier": "getQueueCircuitState", "parameters": "(PatternAndCircuitHash patternAndCircuitHash)", "modifiers": "@Override public", "return": "Future<QueueCircuitState>", "signature": "Future<QueueCircuitState> getQueueCircuitState(PatternAndCircuitHash patternAndCircuitHash)", "full_signature": "@Override public Future<QueueCircuitState> getQueueCircuitState(PatternAndCircuitHash patternAndCircuitHash)", "class_method_signature": "RedisQueueCircuitBreakerStorage.getQueueCircuitState(PatternAndCircuitHash patternAndCircuitHash)", "testcase": false, "constructor": false}, {"identifier": "getQueueCircuitState", "parameters": "(String circuitHash)", "modifiers": "@Override public", "return": "Future<QueueCircuitState>", "signature": "Future<QueueCircuitState> getQueueCircuitState(String circuitHash)", "full_signature": "@Override public Future<QueueCircuitState> getQueueCircuitState(String circuitHash)", "class_method_signature": "RedisQueueCircuitBreakerStorage.getQueueCircuitState(String circuitHash)", "testcase": false, "constructor": false}, {"identifier": "getQueueCircuitInformation", "parameters": "(String circuitHash)", "modifiers": "@Override public", "return": "Future<JsonObject>", "signature": "Future<JsonObject> getQueueCircuitInformation(String circuitHash)", "full_signature": "@Override public Future<JsonObject> getQueueCircuitInformation(String circuitHash)", "class_method_signature": "RedisQueueCircuitBreakerStorage.getQueueCircuitInformation(String circuitHash)", "testcase": false, "constructor": false}, {"identifier": "getAllCircuits", "parameters": "()", "modifiers": "@Override public", "return": "Future<JsonObject>", "signature": "Future<JsonObject> getAllCircuits()", "full_signature": "@Override public Future<JsonObject> getAllCircuits()", "class_method_signature": "RedisQueueCircuitBreakerStorage.getAllCircuits()", "testcase": false, "constructor": false}, {"identifier": "updateStatistics", "parameters": "(PatternAndCircuitHash patternAndCircuitHash, String uniqueRequestID, long timestamp,\n                                                           int errorThresholdPercentage, long entriesMaxAgeMS, long minQueueSampleCount,\n                                                           long maxQueueSampleCount, QueueResponseType queueResponseType)", "modifiers": "@Override public", "return": "Future<UpdateStatisticsResult>", "signature": "Future<UpdateStatisticsResult> updateStatistics(PatternAndCircuitHash patternAndCircuitHash, String uniqueRequestID, long timestamp,\n                                                           int errorThresholdPercentage, long entriesMaxAgeMS, long minQueueSampleCount,\n                                                           long maxQueueSampleCount, QueueResponseType queueResponseType)", "full_signature": "@Override public Future<UpdateStatisticsResult> updateStatistics(PatternAndCircuitHash patternAndCircuitHash, String uniqueRequestID, long timestamp,\n                                                           int errorThresholdPercentage, long entriesMaxAgeMS, long minQueueSampleCount,\n                                                           long maxQueueSampleCount, QueueResponseType queueResponseType)", "class_method_signature": "RedisQueueCircuitBreakerStorage.updateStatistics(PatternAndCircuitHash patternAndCircuitHash, String uniqueRequestID, long timestamp,\n                                                           int errorThresholdPercentage, long entriesMaxAgeMS, long minQueueSampleCount,\n                                                           long maxQueueSampleCount, QueueResponseType queueResponseType)", "testcase": false, "constructor": false}, {"identifier": "lockQueue", "parameters": "(String queueName, PatternAndCircuitHash patternAndCircuitHash)", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> lockQueue(String queueName, PatternAndCircuitHash patternAndCircuitHash)", "full_signature": "@Override public Future<Void> lockQueue(String queueName, PatternAndCircuitHash patternAndCircuitHash)", "class_method_signature": "RedisQueueCircuitBreakerStorage.lockQueue(String queueName, PatternAndCircuitHash patternAndCircuitHash)", "testcase": false, "constructor": false}, {"identifier": "popQueueToUnlock", "parameters": "()", "modifiers": "@Override public", "return": "Future<String>", "signature": "Future<String> popQueueToUnlock()", "full_signature": "@Override public Future<String> popQueueToUnlock()", "class_method_signature": "RedisQueueCircuitBreakerStorage.popQueueToUnlock()", "testcase": false, "constructor": false}, {"identifier": "closeCircuit", "parameters": "(PatternAndCircuitHash patternAndCircuitHash)", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> closeCircuit(PatternAndCircuitHash patternAndCircuitHash)", "full_signature": "@Override public Future<Void> closeCircuit(PatternAndCircuitHash patternAndCircuitHash)", "class_method_signature": "RedisQueueCircuitBreakerStorage.closeCircuit(PatternAndCircuitHash patternAndCircuitHash)", "testcase": false, "constructor": false}, {"identifier": "closeAndRemoveCircuit", "parameters": "(PatternAndCircuitHash patternAndCircuitHash)", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> closeAndRemoveCircuit(PatternAndCircuitHash patternAndCircuitHash)", "full_signature": "@Override public Future<Void> closeAndRemoveCircuit(PatternAndCircuitHash patternAndCircuitHash)", "class_method_signature": "RedisQueueCircuitBreakerStorage.closeAndRemoveCircuit(PatternAndCircuitHash patternAndCircuitHash)", "testcase": false, "constructor": false}, {"identifier": "closeCircuit", "parameters": "(String circuitHash, boolean circuitRemoved)", "modifiers": "private", "return": "Future<Void>", "signature": "Future<Void> closeCircuit(String circuitHash, boolean circuitRemoved)", "full_signature": "private Future<Void> closeCircuit(String circuitHash, boolean circuitRemoved)", "class_method_signature": "RedisQueueCircuitBreakerStorage.closeCircuit(String circuitHash, boolean circuitRemoved)", "testcase": false, "constructor": false}, {"identifier": "closeAllCircuits", "parameters": "()", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> closeAllCircuits()", "full_signature": "@Override public Future<Void> closeAllCircuits()", "class_method_signature": "RedisQueueCircuitBreakerStorage.closeAllCircuits()", "testcase": false, "constructor": false}, {"identifier": "closeCircuitsByKey", "parameters": "(String key)", "modifiers": "private", "return": "Future<Void>", "signature": "Future<Void> closeCircuitsByKey(String key)", "full_signature": "private Future<Void> closeCircuitsByKey(String key)", "class_method_signature": "RedisQueueCircuitBreakerStorage.closeCircuitsByKey(String key)", "testcase": false, "constructor": false}, {"identifier": "reOpenCircuit", "parameters": "(PatternAndCircuitHash patternAndCircuitHash)", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> reOpenCircuit(PatternAndCircuitHash patternAndCircuitHash)", "full_signature": "@Override public Future<Void> reOpenCircuit(PatternAndCircuitHash patternAndCircuitHash)", "class_method_signature": "RedisQueueCircuitBreakerStorage.reOpenCircuit(PatternAndCircuitHash patternAndCircuitHash)", "testcase": false, "constructor": false}, {"identifier": "setOpenCircuitsToHalfOpen", "parameters": "()", "modifiers": "@Override public", "return": "Future<Long>", "signature": "Future<Long> setOpenCircuitsToHalfOpen()", "full_signature": "@Override public Future<Long> setOpenCircuitsToHalfOpen()", "class_method_signature": "RedisQueueCircuitBreakerStorage.setOpenCircuitsToHalfOpen()", "testcase": false, "constructor": false}, {"identifier": "unlockSampleQueues", "parameters": "()", "modifiers": "@Override public", "return": "Future<List<String>>", "signature": "Future<List<String>> unlockSampleQueues()", "full_signature": "@Override public Future<List<String>> unlockSampleQueues()", "class_method_signature": "RedisQueueCircuitBreakerStorage.unlockSampleQueues()", "testcase": false, "constructor": false}, {"identifier": "buildInfosKey", "parameters": "(String circuitHash)", "modifiers": "private", "return": "String", "signature": "String buildInfosKey(String circuitHash)", "full_signature": "private String buildInfosKey(String circuitHash)", "class_method_signature": "RedisQueueCircuitBreakerStorage.buildInfosKey(String circuitHash)", "testcase": false, "constructor": false}, {"identifier": "buildQueuesKey", "parameters": "(String circuitHash)", "modifiers": "private", "return": "String", "signature": "String buildQueuesKey(String circuitHash)", "full_signature": "private String buildQueuesKey(String circuitHash)", "class_method_signature": "RedisQueueCircuitBreakerStorage.buildQueuesKey(String circuitHash)", "testcase": false, "constructor": false}, {"identifier": "buildStatsKey", "parameters": "(String circuitHash, QueueResponseType queueResponseType)", "modifiers": "private", "return": "String", "signature": "String buildStatsKey(String circuitHash, QueueResponseType queueResponseType)", "full_signature": "private String buildStatsKey(String circuitHash, QueueResponseType queueResponseType)", "class_method_signature": "RedisQueueCircuitBreakerStorage.buildStatsKey(String circuitHash, QueueResponseType queueResponseType)", "testcase": false, "constructor": false}], "file": "gateleen-queue/src/main/java/org/swisspush/gateleen/queue/queuing/circuitbreaker/impl/RedisQueueCircuitBreakerStorage.java"}, "focal_method": {"identifier": "closeAndRemoveCircuit", "parameters": "(PatternAndCircuitHash patternAndCircuitHash)", "modifiers": "@Override public", "return": "Future<Void>", "body": "@Override\n    public Future<Void> closeAndRemoveCircuit(PatternAndCircuitHash patternAndCircuitHash) {\n        return closeCircuit(patternAndCircuitHash.getCircuitHash(), true);\n    }", "signature": "Future<Void> closeAndRemoveCircuit(PatternAndCircuitHash patternAndCircuitHash)", "full_signature": "@Override public Future<Void> closeAndRemoveCircuit(PatternAndCircuitHash patternAndCircuitHash)", "class_method_signature": "RedisQueueCircuitBreakerStorage.closeAndRemoveCircuit(PatternAndCircuitHash patternAndCircuitHash)", "testcase": false, "constructor": false, "invocations": ["closeCircuit", "getCircuitHash"]}, "repository": {"repo_id": 52609528, "url": "https://github.com/swisspush/gateleen", "language": "Java", "is_fork": false, "fork_count": 28, "stargazer_count": 63, "size": 2919, "license": "licensed"}}