{"test_class": {"identifier": "BatchSecretDeliveryResourceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final ApiDate NOW = ApiDate.now();", "modifier": "private static final", "type": "ApiDate", "declarator": "NOW = ApiDate.now()", "var_name": "NOW"}, {"original_string": "@Rule\n    public MockitoRule mockito = MockitoJUnit.rule();", "modifier": "@Rule\n    public", "type": "MockitoRule", "declarator": "mockito = MockitoJUnit.rule()", "var_name": "mockito"}, {"original_string": "@Mock\n    SecretController secretController;", "modifier": "@Mock", "type": "SecretController", "declarator": "secretController", "var_name": "secretController"}, {"original_string": "@Mock\n    AclDAO aclDAO;", "modifier": "@Mock", "type": "AclDAO", "declarator": "aclDAO", "var_name": "aclDAO"}, {"original_string": "@Mock\n    ClientDAO clientDAO;", "modifier": "@Mock", "type": "ClientDAO", "declarator": "clientDAO", "var_name": "clientDAO"}, {"original_string": "BatchSecretDeliveryResource batchSecretDeliveryResource;", "modifier": "", "type": "BatchSecretDeliveryResource", "declarator": "batchSecretDeliveryResource", "var_name": "batchSecretDeliveryResource"}, {"original_string": "final Client client = new Client(0, \"principal\", null, null, null, null, null, null, null, null, false,\n            false);", "modifier": "final", "type": "Client", "declarator": "client = new Client(0, \"principal\", null, null, null, null, null, null, null, null, false,\n            false)", "var_name": "client"}, {"original_string": "final Secret secret = new Secret(0, \"secret_name\", null, () -> \"secret_value\", \"checksum\", NOW, null, NOW, null,\n            null, null, null, 0, 1L, NOW, null);", "modifier": "final", "type": "Secret", "declarator": "secret = new Secret(0, \"secret_name\", null, () -> \"secret_value\", \"checksum\", NOW, null, NOW, null,\n            null, null, null, 0, 1L, NOW, null)", "var_name": "secret"}, {"original_string": "final Secret secretBase64 = new Secret(1, \"Base64With=\", null, () -> \"SGVsbG8=\", \"checksum\", NOW, null, NOW,\n            null, null, null, null, 0, 1L, NOW, null);", "modifier": "final", "type": "Secret", "declarator": "secretBase64 = new Secret(1, \"Base64With=\", null, () -> \"SGVsbG8=\", \"checksum\", NOW, null, NOW,\n            null, null, null, null, 0, 1L, NOW, null)", "var_name": "secretBase64"}, {"original_string": "final Secret secret2 = new Secret(2, \"secret2_name\", null, () -> \"secret_value2\", \"checksum2\", NOW, null, NOW, null,\n            null, null, null, 0, 1L, NOW, null);", "modifier": "final", "type": "Secret", "declarator": "secret2 = new Secret(2, \"secret2_name\", null, () -> \"secret_value2\", \"checksum2\", NOW, null, NOW, null,\n            null, null, null, 0, 1L, NOW, null)", "var_name": "secret2"}], "file": "server/src/test/java/keywhiz/service/resources/BatchSecretDeliveryResourceTest.java"}, "test_case": {"identifier": "returnsNotFoundWhenSecretDoesNotExist", "parameters": "()", "modifiers": "@Test(expected = NotFoundException.class) public", "return": "void", "body": "@Test(expected = NotFoundException.class)\n    public void returnsNotFoundWhenSecretDoesNotExist() throws Exception {\n        when(aclDAO.getBatchSanitizedSecretsFor(client, ImmutableList.of(\"secret_name\"))).thenReturn(ImmutableList.of());\n        when(clientDAO.getClientByName(client.getName())).thenReturn(Optional.of(client));\n        when(secretController.getSecretsByName(ImmutableList.of(\"secret_name\")))\n                .thenReturn(ImmutableList.of());\n\n        batchSecretDeliveryResource.getBatchSecret(client, BatchSecretRequest.create(ImmutableList.of(\"secret_name\")));\n    }", "signature": "void returnsNotFoundWhenSecretDoesNotExist()", "full_signature": "@Test(expected = NotFoundException.class) public void returnsNotFoundWhenSecretDoesNotExist()", "class_method_signature": "BatchSecretDeliveryResourceTest.returnsNotFoundWhenSecretDoesNotExist()", "testcase": true, "constructor": false, "invocations": ["thenReturn", "when", "getBatchSanitizedSecretsFor", "of", "of", "thenReturn", "when", "getClientByName", "getName", "of", "thenReturn", "when", "getSecretsByName", "of", "of", "getBatchSecret", "create", "of"]}, "focal_class": {"identifier": "BatchSecretDeliveryResource", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(BatchSecretDeliveryResource.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(BatchSecretDeliveryResource.class)", "var_name": "logger"}, {"original_string": "private final SecretController secretController;", "modifier": "private final", "type": "SecretController", "declarator": "secretController", "var_name": "secretController"}, {"original_string": "private final AclDAO aclDAO;", "modifier": "private final", "type": "AclDAO", "declarator": "aclDAO", "var_name": "aclDAO"}, {"original_string": "private final ClientDAO clientDAO;", "modifier": "private final", "type": "ClientDAO", "declarator": "clientDAO", "var_name": "clientDAO"}], "methods": [{"identifier": "BatchSecretDeliveryResource", "parameters": "(@Readonly SecretController secretController,\n                                     AclDAOFactory aclDAOFactory, ClientDAOFactory clientDAOFactory)", "modifiers": "@Inject public", "return": "", "signature": " BatchSecretDeliveryResource(@Readonly SecretController secretController,\n                                     AclDAOFactory aclDAOFactory, ClientDAOFactory clientDAOFactory)", "full_signature": "@Inject public  BatchSecretDeliveryResource(@Readonly SecretController secretController,\n                                     AclDAOFactory aclDAOFactory, ClientDAOFactory clientDAOFactory)", "class_method_signature": "BatchSecretDeliveryResource.BatchSecretDeliveryResource(@Readonly SecretController secretController,\n                                     AclDAOFactory aclDAOFactory, ClientDAOFactory clientDAOFactory)", "testcase": false, "constructor": true}, {"identifier": "BatchSecretDeliveryResource", "parameters": "(SecretController secretController, AclDAO aclDAO,\n                              ClientDAO clientDAO)", "modifiers": "@VisibleForTesting", "return": "", "signature": " BatchSecretDeliveryResource(SecretController secretController, AclDAO aclDAO,\n                              ClientDAO clientDAO)", "full_signature": "@VisibleForTesting  BatchSecretDeliveryResource(SecretController secretController, AclDAO aclDAO,\n                              ClientDAO clientDAO)", "class_method_signature": "BatchSecretDeliveryResource.BatchSecretDeliveryResource(SecretController secretController, AclDAO aclDAO,\n                              ClientDAO clientDAO)", "testcase": false, "constructor": true}, {"identifier": "getBatchSecret", "parameters": "(@Auth Client client, @Valid BatchSecretRequest request)", "modifiers": "@Timed @ExceptionMetered @POST @Consumes(APPLICATION_JSON) public", "return": "List<SecretDeliveryResponse>", "signature": "List<SecretDeliveryResponse> getBatchSecret(@Auth Client client, @Valid BatchSecretRequest request)", "full_signature": "@Timed @ExceptionMetered @POST @Consumes(APPLICATION_JSON) public List<SecretDeliveryResponse> getBatchSecret(@Auth Client client, @Valid BatchSecretRequest request)", "class_method_signature": "BatchSecretDeliveryResource.getBatchSecret(@Auth Client client, @Valid BatchSecretRequest request)", "testcase": false, "constructor": false}], "file": "server/src/main/java/keywhiz/service/resources/BatchSecretDeliveryResource.java"}, "focal_method": {"identifier": "getBatchSecret", "parameters": "(@Auth Client client, @Valid BatchSecretRequest request)", "modifiers": "@Timed @ExceptionMetered @POST @Consumes(APPLICATION_JSON) public", "return": "List<SecretDeliveryResponse>", "body": "@Timed\n  @ExceptionMetered\n  @POST\n  @Consumes(APPLICATION_JSON)\n  public List<SecretDeliveryResponse> getBatchSecret(@Auth Client client, @Valid BatchSecretRequest request) {\n\n\n    List<SanitizedSecret> clientAccessibleSecrets = aclDAO.getBatchSanitizedSecretsFor(client, request.secrets());\n    List<Secret> existingSecrets = secretController.getSecretsByName(request.secrets());\n\n    boolean clientExists = clientDAO.getClientByName(client.getName()).isPresent();\n\n    List<String> forbiddenSecrets = new ArrayList<>();\n\n    // The request fails whenever a single secret is requested that is not accessible\n    // The client is responsible for only requesting secrets they have permission for\n    for (String secretname : request.secrets()) {\n      boolean secretExists = existingSecrets.stream().anyMatch(s -> s.getName().equals(secretname));\n      boolean secretAccessible = clientAccessibleSecrets.stream().anyMatch(s -> s.name().equals(secretname));\n\n      if (!(clientExists && secretExists)) {\n        logger.warn(\"Client {} or secret {} does not exist (client exists={}, secret exists={})\", client.getName(), secretname, clientExists, secretExists);\n        throw new NotFoundException();\n      }\n      if (!secretAccessible) {\n        // at this point we know the client and secret both exist\n        forbiddenSecrets.add(secretname);\n      }\n    }\n\n    // If *any* of the secrets is forbidden\n    if (!forbiddenSecrets.isEmpty()) {\n      throw new ForbiddenException(format(\"Access denied: %s to secret(s) '%s'\", client.getName(), forbiddenSecrets));\n    }\n\n    logger.info(\"Client {} granted access to {}.\", client.getName(), clientAccessibleSecrets.stream().map(s -> s.name()).collect(toList()));\n    try {\n      // This is only possible if all secrets are both existing AND accessible to the client\n      return existingSecrets.stream()\n              .map(SecretDeliveryResponse::fromSecret)\n              .collect(toList());\n    } catch (IllegalArgumentException e) {\n      logger.error(format(\"Failed creating batch response for secrets %s\", existingSecrets.stream().map(s -> s.getName()).collect(toList())), e);\n      throw new InternalServerErrorException();\n    }\n  }", "signature": "List<SecretDeliveryResponse> getBatchSecret(@Auth Client client, @Valid BatchSecretRequest request)", "full_signature": "@Timed @ExceptionMetered @POST @Consumes(APPLICATION_JSON) public List<SecretDeliveryResponse> getBatchSecret(@Auth Client client, @Valid BatchSecretRequest request)", "class_method_signature": "BatchSecretDeliveryResource.getBatchSecret(@Auth Client client, @Valid BatchSecretRequest request)", "testcase": false, "constructor": false, "invocations": ["getBatchSanitizedSecretsFor", "secrets", "getSecretsByName", "secrets", "isPresent", "getClientByName", "getName", "secrets", "anyMatch", "stream", "equals", "getName", "anyMatch", "stream", "equals", "name", "warn", "getName", "add", "isEmpty", "format", "getName", "info", "getName", "collect", "map", "stream", "name", "toList", "collect", "map", "stream", "toList", "error", "format", "collect", "map", "stream", "getName", "toList"]}, "repository": {"repo_id": 32866430, "url": "https://github.com/square/keywhiz", "stars": 2186, "created": "3/25/2015 1:31:39 PM +00:00", "updates": "2020-01-24T18:57:02+00:00", "fork": "False", "license": "licensed"}}