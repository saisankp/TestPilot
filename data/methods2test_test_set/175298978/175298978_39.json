{"test_class": {"identifier": "BranchAwareSmellTypeAnalysisTest", "superclass": "extends SmellTypeAnalysisTestCase", "interfaces": "", "fields": [], "file": "SmellTracker/src/test/java/fr/inria/sniffer/tracker/analysis/query/smell/BranchAwareSmellTypeAnalysisTest.java"}, "test_case": {"identifier": "testMergeCommitRefactorAndIntroduces", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMergeCommitRefactorAndIntroduces() throws QueryException {\n        Commit A = new Commit(\"0-A\", 0);\n        Commit B = new Commit(\"1-B\", 1);\n        Commit C = new Commit(\"0-C\", 2);\n        Smell fourthSmell = new Smell(smellType, \"fourthSmellInstance\", \"fourthSmellFile\");\n        mockSmellId(fourthSmell);\n\n        // This define the input order\n        mockCommitSmells(A, firstSmell, secondSmell);\n        mockCommitSmells(B, firstSmell, thirdSmell);\n        mockCommitSmells(C, thirdSmell, fourthSmell);\n\n        mockCommitBranch(A, 0, 0);\n        mockCommitBranch(B, 1, 0);\n        mockCommitBranch(C, 0, 1);\n        mockLastBranchCommit(0, C);\n        mockLastBranchCommit(1, B);\n\n        mockMergeCommit(C, B);\n        mockBranchParentCommitSmells(1, firstSmell, secondSmell);\n\n        getAnalysis().query();\n\n\n        verify(persistence, times(4)).execute(any());\n        verify(smellQueries).smellInsertionStatement(projectId, firstSmell);\n        verify(smellQueries).smellInsertionStatement(projectId, secondSmell);\n        verify(smellQueries).smellInsertionStatement(projectId, thirdSmell);\n        verify(smellQueries).smellInsertionStatement(projectId, fourthSmell);\n\n\n        verify(persistence, times(12)).addStatements(any());\n        // Initial branch\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, A.sha, firstSmell, SmellCategory.PRESENCE);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, A.sha, firstSmell, SmellCategory.INTRODUCTION);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, A.sha, secondSmell, SmellCategory.PRESENCE);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, A.sha, secondSmell, SmellCategory.INTRODUCTION);\n\n        // First Branch\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, B.sha, firstSmell, SmellCategory.PRESENCE);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, B.sha, secondSmell, SmellCategory.REFACTOR);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, B.sha, thirdSmell, SmellCategory.PRESENCE);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, B.sha, thirdSmell, SmellCategory.INTRODUCTION);\n\n        // Merge\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, C.sha, firstSmell, SmellCategory.REFACTOR);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, C.sha, thirdSmell, SmellCategory.PRESENCE);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, C.sha, fourthSmell, SmellCategory.PRESENCE);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, C.sha, fourthSmell, SmellCategory.INTRODUCTION);\n    }", "signature": "void testMergeCommitRefactorAndIntroduces()", "full_signature": "@Test public void testMergeCommitRefactorAndIntroduces()", "class_method_signature": "BranchAwareSmellTypeAnalysisTest.testMergeCommitRefactorAndIntroduces()", "testcase": true, "constructor": false, "invocations": ["mockSmellId", "mockCommitSmells", "mockCommitSmells", "mockCommitSmells", "mockCommitBranch", "mockCommitBranch", "mockCommitBranch", "mockLastBranchCommit", "mockLastBranchCommit", "mockMergeCommit", "mockBranchParentCommitSmells", "query", "getAnalysis", "execute", "verify", "times", "any", "smellInsertionStatement", "verify", "smellInsertionStatement", "verify", "smellInsertionStatement", "verify", "smellInsertionStatement", "verify", "addStatements", "verify", "times", "any", "smellCategoryInsertionStatement", "verify", "smellCategoryInsertionStatement", "verify", "smellCategoryInsertionStatement", "verify", "smellCategoryInsertionStatement", "verify", "smellCategoryInsertionStatement", "verify", "smellCategoryInsertionStatement", "verify", "smellCategoryInsertionStatement", "verify", "smellCategoryInsertionStatement", "verify", "smellCategoryInsertionStatement", "verify", "smellCategoryInsertionStatement", "verify", "smellCategoryInsertionStatement", "verify", "smellCategoryInsertionStatement", "verify"]}, "focal_class": {"identifier": "BranchAwareSmellTypeAnalysis", "superclass": "", "interfaces": "implements Query", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(BranchAwareSmellTypeAnalysis.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(BranchAwareSmellTypeAnalysis.class.getName())", "var_name": "logger"}, {"original_string": "private final int projectId;", "modifier": "private final", "type": "int", "declarator": "projectId", "var_name": "projectId"}, {"original_string": "private final String smellType;", "modifier": "private final", "type": "String", "declarator": "smellType", "var_name": "smellType"}, {"original_string": "private final Persistence persistence;", "modifier": "private final", "type": "Persistence", "declarator": "persistence", "var_name": "persistence"}, {"original_string": "private final CommitQueries commitQueries;", "modifier": "private final", "type": "CommitQueries", "declarator": "commitQueries", "var_name": "commitQueries"}, {"original_string": "private final SmellQueries smellQueries;", "modifier": "private final", "type": "SmellQueries", "declarator": "smellQueries", "var_name": "smellQueries"}, {"original_string": "private final BranchQueries branchQueries;", "modifier": "private final", "type": "BranchQueries", "declarator": "branchQueries", "var_name": "branchQueries"}, {"original_string": "private final SmellDuplicationChecker duplicationChecker;", "modifier": "private final", "type": "SmellDuplicationChecker", "declarator": "duplicationChecker", "var_name": "duplicationChecker"}, {"original_string": "private final Iterator<Map<String, Object>> smells;", "modifier": "private final", "type": "Iterator<Map<String, Object>>", "declarator": "smells", "var_name": "smells"}, {"original_string": "private final Map<Integer, BranchAnalyzer> branchAnalyzers;", "modifier": "private final", "type": "Map<Integer, BranchAnalyzer>", "declarator": "branchAnalyzers", "var_name": "branchAnalyzers"}, {"original_string": "private final Map<Integer, String> branchLastCommitSha;", "modifier": "private final", "type": "Map<Integer, String>", "declarator": "branchLastCommitSha", "var_name": "branchLastCommitSha"}], "methods": [{"identifier": "BranchAwareSmellTypeAnalysis", "parameters": "(int projectId, Persistence persistence, Iterator<Map<String, Object>> smells,\n                                 String smellType, SmellDuplicationChecker duplicationChecker,\n                                 CommitQueries commitQueries, SmellQueries smellQueries, BranchQueries branchQueries)", "modifiers": "", "return": "", "signature": " BranchAwareSmellTypeAnalysis(int projectId, Persistence persistence, Iterator<Map<String, Object>> smells,\n                                 String smellType, SmellDuplicationChecker duplicationChecker,\n                                 CommitQueries commitQueries, SmellQueries smellQueries, BranchQueries branchQueries)", "full_signature": "  BranchAwareSmellTypeAnalysis(int projectId, Persistence persistence, Iterator<Map<String, Object>> smells,\n                                 String smellType, SmellDuplicationChecker duplicationChecker,\n                                 CommitQueries commitQueries, SmellQueries smellQueries, BranchQueries branchQueries)", "class_method_signature": "BranchAwareSmellTypeAnalysis.BranchAwareSmellTypeAnalysis(int projectId, Persistence persistence, Iterator<Map<String, Object>> smells,\n                                 String smellType, SmellDuplicationChecker duplicationChecker,\n                                 CommitQueries commitQueries, SmellQueries smellQueries, BranchQueries branchQueries)", "testcase": false, "constructor": true}, {"identifier": "query", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void query()", "full_signature": "@Override public void query()", "class_method_signature": "BranchAwareSmellTypeAnalysis.query()", "testcase": false, "constructor": false}, {"identifier": "synchronizeMergeSmells", "parameters": "(Commit commit, Integer currentBranch)", "modifiers": "private", "return": "void", "signature": "void synchronizeMergeSmells(Commit commit, Integer currentBranch)", "full_signature": "private void synchronizeMergeSmells(Commit commit, Integer currentBranch)", "class_method_signature": "BranchAwareSmellTypeAnalysis.synchronizeMergeSmells(Commit commit, Integer currentBranch)", "testcase": false, "constructor": false}, {"identifier": "fetchCommitOrdinal", "parameters": "(int branchId, Commit commit)", "modifiers": "private", "return": "int", "signature": "int fetchCommitOrdinal(int branchId, Commit commit)", "full_signature": "private int fetchCommitOrdinal(int branchId, Commit commit)", "class_method_signature": "BranchAwareSmellTypeAnalysis.fetchCommitOrdinal(int branchId, Commit commit)", "testcase": false, "constructor": false}, {"identifier": "addSmellsToMergeCommit", "parameters": "(int mergedCommitId, int currentBranch)", "modifiers": "private", "return": "void", "signature": "void addSmellsToMergeCommit(int mergedCommitId, int currentBranch)", "full_signature": "private void addSmellsToMergeCommit(int mergedCommitId, int currentBranch)", "class_method_signature": "BranchAwareSmellTypeAnalysis.addSmellsToMergeCommit(int mergedCommitId, int currentBranch)", "testcase": false, "constructor": false}, {"identifier": "initializeBranch", "parameters": "(int currentBranch)", "modifiers": "private", "return": "void", "signature": "void initializeBranch(int currentBranch)", "full_signature": "private void initializeBranch(int currentBranch)", "class_method_signature": "BranchAwareSmellTypeAnalysis.initializeBranch(int currentBranch)", "testcase": false, "constructor": false}, {"identifier": "retrieveBranchParentSha", "parameters": "(int currentBranch)", "modifiers": "private", "return": "String", "signature": "String retrieveBranchParentSha(int currentBranch)", "full_signature": "private String retrieveBranchParentSha(int currentBranch)", "class_method_signature": "BranchAwareSmellTypeAnalysis.retrieveBranchParentSha(int currentBranch)", "testcase": false, "constructor": false}, {"identifier": "getLastBranchCommit", "parameters": "(int branchId)", "modifiers": "private", "return": "String", "signature": "String getLastBranchCommit(int branchId)", "full_signature": "private String getLastBranchCommit(int branchId)", "class_method_signature": "BranchAwareSmellTypeAnalysis.getLastBranchCommit(int branchId)", "testcase": false, "constructor": false}, {"identifier": "finalizeBranch", "parameters": "(int branchId)", "modifiers": "private", "return": "void", "signature": "void finalizeBranch(int branchId)", "full_signature": "private void finalizeBranch(int branchId)", "class_method_signature": "BranchAwareSmellTypeAnalysis.finalizeBranch(int branchId)", "testcase": false, "constructor": false}, {"identifier": "retrieveBranchParentSmells", "parameters": "(int branchId)", "modifiers": "private", "return": "List<Smell>", "signature": "List<Smell> retrieveBranchParentSmells(int branchId)", "full_signature": "private List<Smell> retrieveBranchParentSmells(int branchId)", "class_method_signature": "BranchAwareSmellTypeAnalysis.retrieveBranchParentSmells(int branchId)", "testcase": false, "constructor": false}, {"identifier": "retrieveMergedCommitSmells", "parameters": "(int mergedCommitId)", "modifiers": "private", "return": "List<Smell>", "signature": "List<Smell> retrieveMergedCommitSmells(int mergedCommitId)", "full_signature": "private List<Smell> retrieveMergedCommitSmells(int mergedCommitId)", "class_method_signature": "BranchAwareSmellTypeAnalysis.retrieveMergedCommitSmells(int mergedCommitId)", "testcase": false, "constructor": false}, {"identifier": "toSmells", "parameters": "(List<Map<String, Object>> results)", "modifiers": "private static", "return": "List<Smell>", "signature": "List<Smell> toSmells(List<Map<String, Object>> results)", "full_signature": "private static List<Smell> toSmells(List<Map<String, Object>> results)", "class_method_signature": "BranchAwareSmellTypeAnalysis.toSmells(List<Map<String, Object>> results)", "testcase": false, "constructor": false}, {"identifier": "getMergedCommitId", "parameters": "(Commit commit)", "modifiers": "private", "return": "Integer", "signature": "Integer getMergedCommitId(Commit commit)", "full_signature": "private Integer getMergedCommitId(Commit commit)", "class_method_signature": "BranchAwareSmellTypeAnalysis.getMergedCommitId(Commit commit)", "testcase": false, "constructor": false}, {"identifier": "isLastBranchCommit", "parameters": "(Commit commit, int currentBranch)", "modifiers": "private", "return": "boolean", "signature": "boolean isLastBranchCommit(Commit commit, int currentBranch)", "full_signature": "private boolean isLastBranchCommit(Commit commit, int currentBranch)", "class_method_signature": "BranchAwareSmellTypeAnalysis.isLastBranchCommit(Commit commit, int currentBranch)", "testcase": false, "constructor": false}, {"identifier": "fetchCommitBranch", "parameters": "(Commit commit)", "modifiers": "private", "return": "int", "signature": "int fetchCommitBranch(Commit commit)", "full_signature": "private int fetchCommitBranch(Commit commit)", "class_method_signature": "BranchAwareSmellTypeAnalysis.fetchCommitBranch(Commit commit)", "testcase": false, "constructor": false}], "file": "SmellTracker/src/main/java/fr/inria/sniffer/tracker/analysis/query/smell/BranchAwareSmellTypeAnalysis.java"}, "focal_method": {"identifier": "query", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void query() throws QueryException {\n        Smell smell;\n        Commit previousCommit;\n        Commit commit = Commit.empty();\n        Integer previousBranch;\n        Integer currentBranch = -1;\n\n        Map<String, Object> instance;\n        while (smells.hasNext()) {\n            instance = smells.next();\n            previousCommit = commit;\n            previousBranch = currentBranch;\n            commit = Commit.fromInstance(instance);\n            smell = Smell.fromPaprikaInstance(instance, smellType);\n            try {\n                currentBranch = fetchCommitBranch(commit);\n            } catch (BranchNotFoundException e) {\n                logger.warn(\"[\" + projectId + \"] ==> Unable to guess branch for commit (\" + commit.sha + \"), skipping\", e.getMessage());\n                continue;\n            }\n\n            // We create the new BranchAnalyzer if needed.\n            if (!branchAnalyzers.containsKey(currentBranch)) {\n                logger.debug(\"[\" + projectId + \"] => Initializing new branch: \" + currentBranch);\n                initializeBranch(currentBranch);\n            }\n\n            // We set the commit ordinal, branch-wise to enable our BranchAnalyzer\n            // to correctly handle gaps.\n            commit.setBranchOrdinal(fetchCommitOrdinal(currentBranch, commit));\n            branchAnalyzers.get(currentBranch).notifyCommit(commit);\n\n            // On commit change, we ensure to merge SmellPresence from the merged commit if necessary.\n            if (!previousCommit.equals(commit)) {\n                synchronizeMergeSmells(commit, currentBranch);\n            }\n\n            // Once the previous Smells are all set, notify our newly found smell.\n            branchAnalyzers.get(currentBranch).notifySmell(smell);\n\n            // When we are sure that we passed the last branch commit, we will finalize the branch analysis,\n            // i.e. setting introductions and refactoring for the last branch commit.\n            if (!previousCommit.equals(commit) && isLastBranchCommit(previousCommit, previousBranch)) {\n                finalizeBranch(previousBranch);\n                branchAnalyzers.remove(previousBranch);\n            }\n        }\n\n        // We should only perform operations for branch 0 since all other commits are looped around.\n        // On top of that, we may have missed some branch finalization because of lost commits.\n        for (int branchId : branchAnalyzers.keySet()) {\n            finalizeBranch(branchId);\n        }\n    }", "signature": "void query()", "full_signature": "@Override public void query()", "class_method_signature": "BranchAwareSmellTypeAnalysis.query()", "testcase": false, "constructor": false, "invocations": ["empty", "hasNext", "next", "fromInstance", "fromPaprikaInstance", "fetchCommitBranch", "warn", "getMessage", "containsKey", "debug", "initializeBranch", "setBranchOrdinal", "fetchCommitOrdinal", "notifyCommit", "get", "equals", "synchronizeMergeSmells", "notifySmell", "get", "equals", "isLastBranchCommit", "finalizeBranch", "remove", "keySet", "finalizeBranch"]}, "repository": {"repo_id": 175298978, "url": "https://github.com/HabchiSarra/Sniffer", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 10, "size": 587, "license": "licensed"}}