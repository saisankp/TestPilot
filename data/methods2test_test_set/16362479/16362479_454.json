{"test_class": {"identifier": "TransactionContextWrapperTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Mock\n    private ActorUtils actorUtils;", "modifier": "@Mock\n    private", "type": "ActorUtils", "declarator": "actorUtils", "var_name": "actorUtils"}, {"original_string": "@Mock\n    private TransactionContext transactionContext;", "modifier": "@Mock\n    private", "type": "TransactionContext", "declarator": "transactionContext", "var_name": "transactionContext"}, {"original_string": "private TransactionContextWrapper transactionContextWrapper;", "modifier": "private", "type": "TransactionContextWrapper", "declarator": "transactionContextWrapper", "var_name": "transactionContextWrapper"}], "file": "opendaylight/md-sal/sal-distributed-datastore/src/test/java/org/opendaylight/controller/cluster/datastore/TransactionContextWrapperTest.java"}, "test_case": {"identifier": "testExecutePriorTransactionOperations", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testExecutePriorTransactionOperations() {\n        for (int i = 0; i < 100; i++) {\n            transactionContextWrapper.maybeExecuteTransactionOperation(mock(TransactionOperation.class));\n        }\n        assertEquals(901, transactionContextWrapper.getLimiter().availablePermits());\n\n        transactionContextWrapper.executePriorTransactionOperations(transactionContext);\n\n        assertEquals(1001, transactionContextWrapper.getLimiter().availablePermits());\n    }", "signature": "void testExecutePriorTransactionOperations()", "full_signature": "@Test public void testExecutePriorTransactionOperations()", "class_method_signature": "TransactionContextWrapperTest.testExecutePriorTransactionOperations()", "testcase": true, "constructor": false, "invocations": ["maybeExecuteTransactionOperation", "mock", "assertEquals", "availablePermits", "getLimiter", "executePriorTransactionOperations", "assertEquals", "availablePermits", "getLimiter"]}, "focal_class": {"identifier": "TransactionContextWrapper", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(TransactionContextWrapper.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(TransactionContextWrapper.class)", "var_name": "LOG"}, {"original_string": "@GuardedBy(\"queuedTxOperations\")\n    private final List<Entry<TransactionOperation, Boolean>> queuedTxOperations = new ArrayList<>();", "modifier": "@GuardedBy(\"queuedTxOperations\")\n    private final", "type": "List<Entry<TransactionOperation, Boolean>>", "declarator": "queuedTxOperations = new ArrayList<>()", "var_name": "queuedTxOperations"}, {"original_string": "private final TransactionIdentifier identifier;", "modifier": "private final", "type": "TransactionIdentifier", "declarator": "identifier", "var_name": "identifier"}, {"original_string": "private final OperationLimiter limiter;", "modifier": "private final", "type": "OperationLimiter", "declarator": "limiter", "var_name": "limiter"}, {"original_string": "private final String shardName;", "modifier": "private final", "type": "String", "declarator": "shardName", "var_name": "shardName"}, {"original_string": "private volatile TransactionContext transactionContext;", "modifier": "private volatile", "type": "TransactionContext", "declarator": "transactionContext", "var_name": "transactionContext"}, {"original_string": "@GuardedBy(\"queuedTxOperations\")\n    private TransactionContext deferredTransactionContext;", "modifier": "@GuardedBy(\"queuedTxOperations\")\n    private", "type": "TransactionContext", "declarator": "deferredTransactionContext", "var_name": "deferredTransactionContext"}, {"original_string": "@GuardedBy(\"queuedTxOperations\")\n    private boolean pendingEnqueue;", "modifier": "@GuardedBy(\"queuedTxOperations\")\n    private", "type": "boolean", "declarator": "pendingEnqueue", "var_name": "pendingEnqueue"}], "methods": [{"identifier": "TransactionContextWrapper", "parameters": "(final TransactionIdentifier identifier, final ActorUtils actorUtils,\n            final String shardName)", "modifiers": "", "return": "", "signature": " TransactionContextWrapper(final TransactionIdentifier identifier, final ActorUtils actorUtils,\n            final String shardName)", "full_signature": "  TransactionContextWrapper(final TransactionIdentifier identifier, final ActorUtils actorUtils,\n            final String shardName)", "class_method_signature": "TransactionContextWrapper.TransactionContextWrapper(final TransactionIdentifier identifier, final ActorUtils actorUtils,\n            final String shardName)", "testcase": false, "constructor": true}, {"identifier": "getTransactionContext", "parameters": "()", "modifiers": "", "return": "TransactionContext", "signature": "TransactionContext getTransactionContext()", "full_signature": " TransactionContext getTransactionContext()", "class_method_signature": "TransactionContextWrapper.getTransactionContext()", "testcase": false, "constructor": false}, {"identifier": "getIdentifier", "parameters": "()", "modifiers": "", "return": "TransactionIdentifier", "signature": "TransactionIdentifier getIdentifier()", "full_signature": " TransactionIdentifier getIdentifier()", "class_method_signature": "TransactionContextWrapper.getIdentifier()", "testcase": false, "constructor": false}, {"identifier": "enqueueTransactionOperation", "parameters": "(final TransactionOperation operation)", "modifiers": "private", "return": "void", "signature": "void enqueueTransactionOperation(final TransactionOperation operation)", "full_signature": "private void enqueueTransactionOperation(final TransactionOperation operation)", "class_method_signature": "TransactionContextWrapper.enqueueTransactionOperation(final TransactionOperation operation)", "testcase": false, "constructor": false}, {"identifier": "maybeExecuteTransactionOperation", "parameters": "(final TransactionOperation op)", "modifiers": "", "return": "void", "signature": "void maybeExecuteTransactionOperation(final TransactionOperation op)", "full_signature": " void maybeExecuteTransactionOperation(final TransactionOperation op)", "class_method_signature": "TransactionContextWrapper.maybeExecuteTransactionOperation(final TransactionOperation op)", "testcase": false, "constructor": false}, {"identifier": "executePriorTransactionOperations", "parameters": "(final TransactionContext localTransactionContext)", "modifiers": "", "return": "void", "signature": "void executePriorTransactionOperations(final TransactionContext localTransactionContext)", "full_signature": " void executePriorTransactionOperations(final TransactionContext localTransactionContext)", "class_method_signature": "TransactionContextWrapper.executePriorTransactionOperations(final TransactionContext localTransactionContext)", "testcase": false, "constructor": false}, {"identifier": "readyTransaction", "parameters": "(Optional<SortedSet<String>> participatingShardNames)", "modifiers": "", "return": "Future<ActorSelection>", "signature": "Future<ActorSelection> readyTransaction(Optional<SortedSet<String>> participatingShardNames)", "full_signature": " Future<ActorSelection> readyTransaction(Optional<SortedSet<String>> participatingShardNames)", "class_method_signature": "TransactionContextWrapper.readyTransaction(Optional<SortedSet<String>> participatingShardNames)", "testcase": false, "constructor": false}, {"identifier": "getLimiter", "parameters": "()", "modifiers": "", "return": "OperationLimiter", "signature": "OperationLimiter getLimiter()", "full_signature": " OperationLimiter getLimiter()", "class_method_signature": "TransactionContextWrapper.getLimiter()", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-distributed-datastore/src/main/java/org/opendaylight/controller/cluster/datastore/TransactionContextWrapper.java"}, "focal_method": {"identifier": "executePriorTransactionOperations", "parameters": "(final TransactionContext localTransactionContext)", "modifiers": "", "return": "void", "body": "void executePriorTransactionOperations(final TransactionContext localTransactionContext) {\n        while (true) {\n            // Access to queuedTxOperations and transactionContext must be protected and atomic\n            // (ie synchronized) with respect to #addTxOperationOnComplete to handle timing\n            // issues and ensure no TransactionOperation is missed and that they are processed\n            // in the order they occurred.\n\n            // We'll make a local copy of the queuedTxOperations list to handle re-entrancy\n            // in case a TransactionOperation results in another transaction operation being\n            // queued (eg a put operation from a client read Future callback that is notified\n            // synchronously).\n            final Collection<Entry<TransactionOperation, Boolean>> operationsBatch;\n            synchronized (queuedTxOperations) {\n                if (queuedTxOperations.isEmpty()) {\n                    if (!pendingEnqueue) {\n                        // We're done invoking the TransactionOperations so we can now publish the TransactionContext.\n                        localTransactionContext.operationHandOffComplete();\n\n                        // This is null-to-non-null transition after which we are releasing the lock and not doing\n                        // any further processing.\n                        transactionContext = localTransactionContext;\n                    } else {\n                        deferredTransactionContext = localTransactionContext;\n                    }\n                    return;\n                }\n\n                operationsBatch = new ArrayList<>(queuedTxOperations);\n                queuedTxOperations.clear();\n            }\n\n            // Invoke TransactionOperations outside the sync block to avoid unnecessary blocking. A slight down-side is\n            // that we need to re-acquire the lock below but this should be negligible.\n            for (Entry<TransactionOperation, Boolean> oper : operationsBatch) {\n                final Boolean permit = oper.getValue();\n                if (permit.booleanValue() && !localTransactionContext.usesOperationLimiting()) {\n                    // If the context is not using limiting we need to release operations as we are queueing them, so\n                    // user threads are not charged for them.\n                    limiter.release();\n                }\n                oper.getKey().invoke(localTransactionContext, permit);\n            }\n        }\n    }", "signature": "void executePriorTransactionOperations(final TransactionContext localTransactionContext)", "full_signature": " void executePriorTransactionOperations(final TransactionContext localTransactionContext)", "class_method_signature": "TransactionContextWrapper.executePriorTransactionOperations(final TransactionContext localTransactionContext)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "operationHandOffComplete", "clear", "getValue", "booleanValue", "usesOperationLimiting", "release", "invoke", "getKey"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}