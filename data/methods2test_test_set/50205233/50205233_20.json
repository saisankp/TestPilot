{"test_class": {"identifier": "ExtractNewDocumentStateTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String SERVER_NAME = \"serverX\";", "modifier": "private static final", "type": "String", "declarator": "SERVER_NAME = \"serverX\"", "var_name": "SERVER_NAME"}, {"original_string": "private Filters filters;", "modifier": "private", "type": "Filters", "declarator": "filters", "var_name": "filters"}, {"original_string": "private SourceInfo source;", "modifier": "private", "type": "SourceInfo", "declarator": "source", "var_name": "source"}, {"original_string": "private TopicSelector<CollectionId> topicSelector;", "modifier": "private", "type": "TopicSelector<CollectionId>", "declarator": "topicSelector", "var_name": "topicSelector"}, {"original_string": "private List<SourceRecord> produced;", "modifier": "private", "type": "List<SourceRecord>", "declarator": "produced", "var_name": "produced"}, {"original_string": "private ExtractNewDocumentState<SourceRecord> transformation;", "modifier": "private", "type": "ExtractNewDocumentState<SourceRecord>", "declarator": "transformation", "var_name": "transformation"}, {"original_string": "@Rule\n    public TestRule skipTestRule = new SkipTestRule();", "modifier": "@Rule\n    public", "type": "TestRule", "declarator": "skipTestRule = new SkipTestRule()", "var_name": "skipTestRule"}, {"original_string": "@Rule\n    public ExpectedException exceptionRule = ExpectedException.none();", "modifier": "@Rule\n    public", "type": "ExpectedException", "declarator": "exceptionRule = ExpectedException.none()", "var_name": "exceptionRule"}], "file": "debezium-connector-mongodb/src/test/java/io/debezium/connector/mongodb/transforms/ExtractNewDocumentStateTest.java"}, "test_case": {"identifier": "shouldSkipMessagesWithoutDebeziumCdcEnvelopeDueToMissingSchemaName", "parameters": "()", "modifiers": "@Test @FixFor(\"DBZ-1430\") public", "return": "void", "body": "@Test\n    @FixFor(\"DBZ-1430\")\n    public void shouldSkipMessagesWithoutDebeziumCdcEnvelopeDueToMissingSchemaName() {\n        Schema valueSchema = SchemaBuilder.struct()\n                .field(AbstractSourceInfo.TIMESTAMP_KEY, Schema.INT64_SCHEMA)\n                .build();\n\n        Struct value = new Struct(valueSchema);\n\n        Schema keySchema = SchemaBuilder.struct()\n                .name(\"op.with.heartbeat.Key\")\n                .field(\"id\", Schema.STRING_SCHEMA)\n                .build();\n\n        Struct key = new Struct(keySchema).put(\"id\", \"123\");\n\n        final SourceRecord eventRecord = new SourceRecord(\n                new HashMap<>(),\n                new HashMap<>(),\n                \"op.with.heartbeat\",\n                keySchema,\n                key,\n                valueSchema,\n                value);\n\n        // when\n        SourceRecord transformed = transformation.apply(eventRecord);\n\n        assertThat(transformed).isSameAs(eventRecord);\n    }", "signature": "void shouldSkipMessagesWithoutDebeziumCdcEnvelopeDueToMissingSchemaName()", "full_signature": "@Test @FixFor(\"DBZ-1430\") public void shouldSkipMessagesWithoutDebeziumCdcEnvelopeDueToMissingSchemaName()", "class_method_signature": "ExtractNewDocumentStateTest.shouldSkipMessagesWithoutDebeziumCdcEnvelopeDueToMissingSchemaName()", "testcase": true, "constructor": false, "invocations": ["build", "field", "struct", "build", "field", "name", "struct", "put", "apply", "isSameAs", "assertThat"]}, "focal_class": {"identifier": "ExtractNewDocumentState", "superclass": "", "interfaces": "implements Transformation<R>", "fields": [{"original_string": "private String addFieldsPrefix;", "modifier": "private", "type": "String", "declarator": "addFieldsPrefix", "var_name": "addFieldsPrefix"}, {"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ExtractNewDocumentState.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ExtractNewDocumentState.class)", "var_name": "LOGGER"}, {"original_string": "private static final Pattern FIELD_SEPARATOR = Pattern.compile(\"\\\\.\");", "modifier": "private static final", "type": "Pattern", "declarator": "FIELD_SEPARATOR = Pattern.compile(\"\\\\.\")", "var_name": "FIELD_SEPARATOR"}, {"original_string": "private static final Field ARRAY_ENCODING = Field.create(\"array.encoding\")\n            .withDisplayName(\"Array encoding\")\n            .withEnum(ArrayEncoding.class, ArrayEncoding.ARRAY)\n            .withWidth(ConfigDef.Width.SHORT)\n            .withImportance(ConfigDef.Importance.MEDIUM)\n            .withDescription(\"The arrays can be encoded using 'array' schema type (the default) or as a 'document' (similar to how BSON encodes arrays). \"\n                    + \"'array' is easier to consume but requires all elements in the array to be of the same type. \"\n                    + \"Use 'document' if the arrays in data source mix different types together.\");", "modifier": "private static final", "type": "Field", "declarator": "ARRAY_ENCODING = Field.create(\"array.encoding\")\n            .withDisplayName(\"Array encoding\")\n            .withEnum(ArrayEncoding.class, ArrayEncoding.ARRAY)\n            .withWidth(ConfigDef.Width.SHORT)\n            .withImportance(ConfigDef.Importance.MEDIUM)\n            .withDescription(\"The arrays can be encoded using 'array' schema type (the default) or as a 'document' (similar to how BSON encodes arrays). \"\n                    + \"'array' is easier to consume but requires all elements in the array to be of the same type. \"\n                    + \"Use 'document' if the arrays in data source mix different types together.\")", "var_name": "ARRAY_ENCODING"}, {"original_string": "private static final Field FLATTEN_STRUCT = Field.create(\"flatten.struct\")\n            .withDisplayName(\"Flatten struct\")\n            .withType(ConfigDef.Type.BOOLEAN)\n            .withWidth(ConfigDef.Width.SHORT)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withDefault(false)\n            .withDescription(\"Flattening structs by concatenating the fields into plain properties, using a \"\n                    + \"(configurable) delimiter.\");", "modifier": "private static final", "type": "Field", "declarator": "FLATTEN_STRUCT = Field.create(\"flatten.struct\")\n            .withDisplayName(\"Flatten struct\")\n            .withType(ConfigDef.Type.BOOLEAN)\n            .withWidth(ConfigDef.Width.SHORT)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withDefault(false)\n            .withDescription(\"Flattening structs by concatenating the fields into plain properties, using a \"\n                    + \"(configurable) delimiter.\")", "var_name": "FLATTEN_STRUCT"}, {"original_string": "private static final Field DELIMITER = Field.create(\"flatten.struct.delimiter\")\n            .withDisplayName(\"Delimiter for flattened struct\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.SHORT)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withDefault(\"_\")\n            .withDescription(\"Delimiter to concat between field names from the input record when generating field names for the\"\n                    + \"output record.\");", "modifier": "private static final", "type": "Field", "declarator": "DELIMITER = Field.create(\"flatten.struct.delimiter\")\n            .withDisplayName(\"Delimiter for flattened struct\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.SHORT)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withDefault(\"_\")\n            .withDescription(\"Delimiter to concat between field names from the input record when generating field names for the\"\n                    + \"output record.\")", "var_name": "DELIMITER"}, {"original_string": "public static final Field SANITIZE_FIELD_NAMES = Field.create(\"sanitize.field.names\")\n            .withDisplayName(\"Sanitize field names to adhere to Avro naming conventions\")\n            .withType(Type.BOOLEAN)\n            .withWidth(Width.SHORT)\n            .withImportance(Importance.LOW)\n            .withDescription(\"Whether field names will be sanitized to Avro naming conventions\")\n            .withDefault(Boolean.FALSE);", "modifier": "public static final", "type": "Field", "declarator": "SANITIZE_FIELD_NAMES = Field.create(\"sanitize.field.names\")\n            .withDisplayName(\"Sanitize field names to adhere to Avro naming conventions\")\n            .withType(Type.BOOLEAN)\n            .withWidth(Width.SHORT)\n            .withImportance(Importance.LOW)\n            .withDescription(\"Whether field names will be sanitized to Avro naming conventions\")\n            .withDefault(Boolean.FALSE)", "var_name": "SANITIZE_FIELD_NAMES"}, {"original_string": "public static final Field ADD_SOURCE_FIELDS = Field.create(\"add.source.fields\")\n            .withDisplayName(\"Adds the specified fields from the 'source' field from the payload if they exist.\")\n            .withType(ConfigDef.Type.LIST)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withDefault(\"\")\n            .withDescription(\"DEPRECATED. Please use the 'add.fields' option instead. \"\n                    + \"Adds each field listed from the 'source' element of the payload, prefixed with __ \"\n                    + \"Example: 'version,connector' would add __version and __connector fields\");", "modifier": "public static final", "type": "Field", "declarator": "ADD_SOURCE_FIELDS = Field.create(\"add.source.fields\")\n            .withDisplayName(\"Adds the specified fields from the 'source' field from the payload if they exist.\")\n            .withType(ConfigDef.Type.LIST)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withDefault(\"\")\n            .withDescription(\"DEPRECATED. Please use the 'add.fields' option instead. \"\n                    + \"Adds each field listed from the 'source' element of the payload, prefixed with __ \"\n                    + \"Example: 'version,connector' would add __version and __connector fields\")", "var_name": "ADD_SOURCE_FIELDS"}, {"original_string": "public static final Field OPERATION_HEADER = Field.create(\"operation.header\")\n            .withDisplayName(\"Adds a message header representing the applied operation\")\n            .withType(Type.BOOLEAN)\n            .withWidth(Width.SHORT)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withDefault(false)\n            .withDescription(\"DEPRECATED. Please use the 'add.fields' option instead. \"\n                    + \"Adds the operation type of the change event as a header.\"\n                    + \"Its key is '\" + ExtractNewRecordStateConfigDefinition.DEBEZIUM_OPERATION_HEADER_KEY + \"'\");", "modifier": "public static final", "type": "Field", "declarator": "OPERATION_HEADER = Field.create(\"operation.header\")\n            .withDisplayName(\"Adds a message header representing the applied operation\")\n            .withType(Type.BOOLEAN)\n            .withWidth(Width.SHORT)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withDefault(false)\n            .withDescription(\"DEPRECATED. Please use the 'add.fields' option instead. \"\n                    + \"Adds the operation type of the change event as a header.\"\n                    + \"Its key is '\" + ExtractNewRecordStateConfigDefinition.DEBEZIUM_OPERATION_HEADER_KEY + \"'\")", "var_name": "OPERATION_HEADER"}, {"original_string": "private final ExtractField<R> afterExtractor = new ExtractField.Value<>();", "modifier": "private final", "type": "ExtractField<R>", "declarator": "afterExtractor = new ExtractField.Value<>()", "var_name": "afterExtractor"}, {"original_string": "private final ExtractField<R> patchExtractor = new ExtractField.Value<>();", "modifier": "private final", "type": "ExtractField<R>", "declarator": "patchExtractor = new ExtractField.Value<>()", "var_name": "patchExtractor"}, {"original_string": "private final ExtractField<R> keyExtractor = new ExtractField.Key<>();", "modifier": "private final", "type": "ExtractField<R>", "declarator": "keyExtractor = new ExtractField.Key<>()", "var_name": "keyExtractor"}, {"original_string": "private MongoDataConverter converter;", "modifier": "private", "type": "MongoDataConverter", "declarator": "converter", "var_name": "converter"}, {"original_string": "private final Flatten<R> recordFlattener = new Flatten.Value<>();", "modifier": "private final", "type": "Flatten<R>", "declarator": "recordFlattener = new Flatten.Value<>()", "var_name": "recordFlattener"}, {"original_string": "private boolean addOperationHeader;", "modifier": "private", "type": "boolean", "declarator": "addOperationHeader", "var_name": "addOperationHeader"}, {"original_string": "private List<String> addSourceFields;", "modifier": "private", "type": "List<String>", "declarator": "addSourceFields", "var_name": "addSourceFields"}, {"original_string": "private List<FieldReference> additionalHeaders;", "modifier": "private", "type": "List<FieldReference>", "declarator": "additionalHeaders", "var_name": "additionalHeaders"}, {"original_string": "private List<FieldReference> additionalFields;", "modifier": "private", "type": "List<FieldReference>", "declarator": "additionalFields", "var_name": "additionalFields"}, {"original_string": "private boolean flattenStruct;", "modifier": "private", "type": "boolean", "declarator": "flattenStruct", "var_name": "flattenStruct"}, {"original_string": "private String delimiter;", "modifier": "private", "type": "String", "declarator": "delimiter", "var_name": "delimiter"}, {"original_string": "private boolean dropTombstones;", "modifier": "private", "type": "boolean", "declarator": "dropTombstones", "var_name": "dropTombstones"}, {"original_string": "private DeleteHandling handleDeletes;", "modifier": "private", "type": "DeleteHandling", "declarator": "handleDeletes", "var_name": "handleDeletes"}, {"original_string": "private SmtManager<R> smtManager;", "modifier": "private", "type": "SmtManager<R>", "declarator": "smtManager", "var_name": "smtManager"}], "methods": [{"identifier": "apply", "parameters": "(R record)", "modifiers": "@Override public", "return": "R", "signature": "R apply(R record)", "full_signature": "@Override public R apply(R record)", "class_method_signature": "ExtractNewDocumentState.apply(R record)", "testcase": false, "constructor": false}, {"identifier": "newRecord", "parameters": "(R record, BsonDocument keyDocument, BsonDocument valueDocument)", "modifiers": "private", "return": "R", "signature": "R newRecord(R record, BsonDocument keyDocument, BsonDocument valueDocument)", "full_signature": "private R newRecord(R record, BsonDocument keyDocument, BsonDocument valueDocument)", "class_method_signature": "ExtractNewDocumentState.newRecord(R record, BsonDocument keyDocument, BsonDocument valueDocument)", "testcase": false, "constructor": false}, {"identifier": "addSourceFieldsSchema", "parameters": "(String fieldPrefix, List<String> addSourceFields, R originalRecord, SchemaBuilder valueSchemaBuilder)", "modifiers": "private", "return": "void", "signature": "void addSourceFieldsSchema(String fieldPrefix, List<String> addSourceFields, R originalRecord, SchemaBuilder valueSchemaBuilder)", "full_signature": "private void addSourceFieldsSchema(String fieldPrefix, List<String> addSourceFields, R originalRecord, SchemaBuilder valueSchemaBuilder)", "class_method_signature": "ExtractNewDocumentState.addSourceFieldsSchema(String fieldPrefix, List<String> addSourceFields, R originalRecord, SchemaBuilder valueSchemaBuilder)", "testcase": false, "constructor": false}, {"identifier": "addAdditionalFieldsSchema", "parameters": "(List<FieldReference> additionalFields, R originalRecord, SchemaBuilder valueSchemaBuilder)", "modifiers": "private", "return": "void", "signature": "void addAdditionalFieldsSchema(List<FieldReference> additionalFields, R originalRecord, SchemaBuilder valueSchemaBuilder)", "full_signature": "private void addAdditionalFieldsSchema(List<FieldReference> additionalFields, R originalRecord, SchemaBuilder valueSchemaBuilder)", "class_method_signature": "ExtractNewDocumentState.addAdditionalFieldsSchema(List<FieldReference> additionalFields, R originalRecord, SchemaBuilder valueSchemaBuilder)", "testcase": false, "constructor": false}, {"identifier": "addSourceFieldsValue", "parameters": "(List<String> addSourceFields, R originalRecord, Struct valueStruct)", "modifiers": "private", "return": "void", "signature": "void addSourceFieldsValue(List<String> addSourceFields, R originalRecord, Struct valueStruct)", "full_signature": "private void addSourceFieldsValue(List<String> addSourceFields, R originalRecord, Struct valueStruct)", "class_method_signature": "ExtractNewDocumentState.addSourceFieldsValue(List<String> addSourceFields, R originalRecord, Struct valueStruct)", "testcase": false, "constructor": false}, {"identifier": "addFields", "parameters": "(List<FieldReference> additionalFields, R originalRecord, Struct value)", "modifiers": "private", "return": "void", "signature": "void addFields(List<FieldReference> additionalFields, R originalRecord, Struct value)", "full_signature": "private void addFields(List<FieldReference> additionalFields, R originalRecord, Struct value)", "class_method_signature": "ExtractNewDocumentState.addFields(List<FieldReference> additionalFields, R originalRecord, Struct value)", "testcase": false, "constructor": false}, {"identifier": "getUpdateDocument", "parameters": "(R patchRecord, BsonDocument keyDocument)", "modifiers": "private", "return": "BsonDocument", "signature": "BsonDocument getUpdateDocument(R patchRecord, BsonDocument keyDocument)", "full_signature": "private BsonDocument getUpdateDocument(R patchRecord, BsonDocument keyDocument)", "class_method_signature": "ExtractNewDocumentState.getUpdateDocument(R patchRecord, BsonDocument keyDocument)", "testcase": false, "constructor": false}, {"identifier": "getInsertDocument", "parameters": "(R record, BsonDocument key)", "modifiers": "private", "return": "BsonDocument", "signature": "BsonDocument getInsertDocument(R record, BsonDocument key)", "full_signature": "private BsonDocument getInsertDocument(R record, BsonDocument key)", "class_method_signature": "ExtractNewDocumentState.getInsertDocument(R record, BsonDocument key)", "testcase": false, "constructor": false}, {"identifier": "makeHeaders", "parameters": "(List<FieldReference> additionalHeaders, Struct originalRecordValue)", "modifiers": "private", "return": "Headers", "signature": "Headers makeHeaders(List<FieldReference> additionalHeaders, Struct originalRecordValue)", "full_signature": "private Headers makeHeaders(List<FieldReference> additionalHeaders, Struct originalRecordValue)", "class_method_signature": "ExtractNewDocumentState.makeHeaders(List<FieldReference> additionalHeaders, Struct originalRecordValue)", "testcase": false, "constructor": false}, {"identifier": "config", "parameters": "()", "modifiers": "@Override public", "return": "ConfigDef", "signature": "ConfigDef config()", "full_signature": "@Override public ConfigDef config()", "class_method_signature": "ExtractNewDocumentState.config()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "ExtractNewDocumentState.close()", "testcase": false, "constructor": false}, {"identifier": "configure", "parameters": "(final Map<String, ?> map)", "modifiers": "@Override public", "return": "void", "signature": "void configure(final Map<String, ?> map)", "full_signature": "@Override public void configure(final Map<String, ?> map)", "class_method_signature": "ExtractNewDocumentState.configure(final Map<String, ?> map)", "testcase": false, "constructor": false}, {"identifier": "determineAdditionalSourceField", "parameters": "(String addSourceFieldsConfig)", "modifiers": "private static", "return": "List<String>", "signature": "List<String> determineAdditionalSourceField(String addSourceFieldsConfig)", "full_signature": "private static List<String> determineAdditionalSourceField(String addSourceFieldsConfig)", "class_method_signature": "ExtractNewDocumentState.determineAdditionalSourceField(String addSourceFieldsConfig)", "testcase": false, "constructor": false}], "file": "debezium-connector-mongodb/src/main/java/io/debezium/connector/mongodb/transforms/ExtractNewDocumentState.java"}, "focal_method": {"identifier": "apply", "parameters": "(R record)", "modifiers": "@Override public", "return": "R", "body": "@Override\n    public R apply(R record) {\n        if (!smtManager.isValidKey(record)) {\n            return record;\n        }\n\n        final R keyRecord = keyExtractor.apply(record);\n\n        BsonDocument keyDocument = BsonDocument.parse(\"{ \\\"id\\\" : \" + keyRecord.key().toString() + \"}\");\n        BsonDocument valueDocument = new BsonDocument();\n\n        // Tombstone message\n        if (record.value() == null) {\n            if (dropTombstones) {\n                LOGGER.trace(\"Tombstone {} arrived and requested to be dropped\", record.key());\n                return null;\n            }\n            if (!additionalHeaders.isEmpty()) {\n                Headers headersToAdd = makeHeaders(additionalHeaders, (Struct) record.value());\n                headersToAdd.forEach(h -> record.headers().add(h));\n            }\n            else if (addOperationHeader) {\n                LOGGER.warn(\"operation.header has been deprecated and is scheduled for removal.  Use add.headers instead.\");\n                record.headers().addString(ExtractNewRecordStateConfigDefinition.DEBEZIUM_OPERATION_HEADER_KEY, Operation.DELETE.code());\n            }\n            return newRecord(record, keyDocument, valueDocument);\n        }\n\n        if (!smtManager.isValidEnvelope(record)) {\n            return record;\n        }\n\n        final R afterRecord = afterExtractor.apply(record);\n        final R patchRecord = patchExtractor.apply(record);\n\n        if (!additionalHeaders.isEmpty()) {\n            Headers headersToAdd = makeHeaders(additionalHeaders, (Struct) record.value());\n            headersToAdd.forEach(h -> record.headers().add(h));\n        }\n        else if (addOperationHeader) {\n            LOGGER.warn(\"operation.header has been deprecated and is scheduled for removal.  Use add.headers instead.\");\n            record.headers().addString(ExtractNewRecordStateConfigDefinition.DEBEZIUM_OPERATION_HEADER_KEY, ((Struct) record.value()).get(\"op\").toString());\n        }\n\n        // insert\n        if (afterRecord.value() != null) {\n            valueDocument = getInsertDocument(afterRecord, keyDocument);\n        }\n\n        // update\n        if (afterRecord.value() == null && patchRecord.value() != null) {\n            valueDocument = getUpdateDocument(patchRecord, keyDocument);\n        }\n\n        boolean isDeletion = false;\n        // delete\n        if (afterRecord.value() == null && patchRecord.value() == null) {\n            if (handleDeletes.equals(DeleteHandling.DROP)) {\n                LOGGER.trace(\"Delete {} arrived and requested to be dropped\", record.key());\n                return null;\n            }\n\n            isDeletion = true;\n        }\n\n        if (handleDeletes.equals(DeleteHandling.REWRITE)) {\n            valueDocument.append(ExtractNewRecordStateConfigDefinition.DELETED_FIELD, new BsonBoolean(isDeletion));\n        }\n\n        return newRecord(record, keyDocument, valueDocument);\n    }", "signature": "R apply(R record)", "full_signature": "@Override public R apply(R record)", "class_method_signature": "ExtractNewDocumentState.apply(R record)", "testcase": false, "constructor": false, "invocations": ["isValidKey", "apply", "parse", "toString", "key", "value", "trace", "key", "isEmpty", "makeHeaders", "value", "forEach", "add", "headers", "warn", "addString", "headers", "code", "newRecord", "isValidEnvelope", "apply", "apply", "isEmpty", "makeHeaders", "value", "forEach", "add", "headers", "warn", "addString", "headers", "toString", "get", "value", "value", "getInsertDocument", "value", "value", "getUpdateDocument", "value", "value", "equals", "trace", "key", "equals", "append", "newRecord"]}, "repository": {"repo_id": 50205233, "url": "https://github.com/debezium/debezium", "stars": 2686, "created": "1/22/2016 8:17:05 PM +00:00", "updates": "2020-01-27T20:48:54+00:00", "fork": "False", "license": "licensed"}}