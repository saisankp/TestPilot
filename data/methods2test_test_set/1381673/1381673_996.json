{"test_class": {"identifier": "BuildUtilsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private BuildUtils utils;", "modifier": "private", "type": "BuildUtils", "declarator": "utils", "var_name": "utils"}], "file": "drools-core/src/test/java/org/drools/core/reteoo/builder/BuildUtilsTest.java"}, "test_case": {"identifier": "testCalculateTemporalDistance", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCalculateTemporalDistance() {\n        // input is here just for \"documentation\" purposes\n        Interval[][] input = new Interval[][] {\n                                                { new Interval(0,0), new Interval(-2,2), new Interval(-3, 4), new Interval(MIN, MAX), new Interval(MIN, MAX) },\n                                                { new Interval(-2,2), new Interval(0,0), new Interval(MIN, MAX), new Interval(1,2), new Interval(MIN, MAX) },\n                                                { new Interval(-4,3), new Interval(MIN,MAX), new Interval(0, 0), new Interval(2, 3), new Interval(MIN, MAX) },\n                                                { new Interval(MIN,MAX), new Interval(-2,-1), new Interval(-3, -2), new Interval(0, 0), new Interval(1, 10) },\n                                                { new Interval(MIN,MAX), new Interval(MIN,MAX), new Interval(MIN,MAX), new Interval(-10, -1), new Interval(0,0) }\n                                        };\n        Interval[][] expected = new Interval[][] {\n                                                { new Interval(0,0), new Interval(-2,2), new Interval(-3, 2), new Interval(-1, 4), new Interval(0, 14) },\n                                                { new Interval(-2,2), new Interval(0,0), new Interval(-2, 0), new Interval(1,2), new Interval(2, 12) },\n                                                { new Interval(-2,3), new Interval(0,2), new Interval(0, 0), new Interval(2, 3), new Interval(3, 13) },\n                                                { new Interval(-4,1), new Interval(-2,-1), new Interval(-3, -2), new Interval(0, 0), new Interval(1, 10) },\n                                                { new Interval(-14,0), new Interval(-12,-2), new Interval(-13,-3), new Interval(-10, -1), new Interval(0,0) }\n                                        };\n\n        AfterEvaluatorDefinition evals = new AfterEvaluatorDefinition();\n        ClassObjectType ot = new ClassObjectType(StockTick.class, true);\n        \n        Pattern a = new Pattern( 0, ot, \"$a\" );\n        Pattern b = new Pattern( 1, ot, \"$b\" );\n\n        b.addConstraint( new EvaluatorConstraint( new Declaration[] { a.getDeclaration() },\n                                                  evals.getEvaluator( ValueType.OBJECT_TYPE,\n                                                                      AfterEvaluatorDefinition.AFTER,\n                                                                      \"-2,2\"),\n                                                  new SelfReferenceClassFieldReader( StockTick.class ) ) );\n\n        Pattern c = new Pattern( 2, ot, \"$c\" );\n        c.addConstraint( new EvaluatorConstraint( new Declaration[] { a.getDeclaration() },\n                                                  evals.getEvaluator( ValueType.OBJECT_TYPE,\n                                                                      AfterEvaluatorDefinition.AFTER,\n                                                                      \"-3,4\"),\n                                                  new SelfReferenceClassFieldReader( StockTick.class ) ) );\n\n        Pattern d = new Pattern( 3, ot, \"$d\" );\n        d.addConstraint( new EvaluatorConstraint( new Declaration[] { b.getDeclaration() },\n                                                  evals.getEvaluator( ValueType.OBJECT_TYPE,\n                                                                      AfterEvaluatorDefinition.AFTER,\n                                                                      \"1,2\"),\n                                                  new SelfReferenceClassFieldReader( StockTick.class ) ) );\n\n        d.addConstraint( new EvaluatorConstraint( new Declaration[] { c.getDeclaration() },\n                                                  evals.getEvaluator( ValueType.OBJECT_TYPE,\n                                                                      AfterEvaluatorDefinition.AFTER,\n                                                                      \"2,3\"),\n                                                  new SelfReferenceClassFieldReader( StockTick.class ) ) );\n\n        Pattern e = new Pattern( 4, ot, \"$e\" );\n        e.addConstraint(new EvaluatorConstraint(new Declaration[]{d.getDeclaration()},\n                evals.getEvaluator(ValueType.OBJECT_TYPE,\n                        AfterEvaluatorDefinition.AFTER,\n                        \"1,10\"),\n                new SelfReferenceClassFieldReader(StockTick.class)));\n\n        GroupElement not = new GroupElement( Type.NOT );\n        not.addChild( e );\n        GroupElement and = new GroupElement( Type.AND );\n        and.addChild( a );\n        and.addChild( b );\n        and.addChild( c );\n        and.addChild( d );\n        and.addChild( not );\n        \n        TemporalDependencyMatrix matrix = utils.calculateTemporalDistance( and );\n        //printMatrix( matrix.getMatrix() );\n        assertEqualsMatrix( expected, matrix.getMatrix() );\n        \n        assertEquals( 15, matrix.getExpirationOffset( a ) );\n        assertEquals( 11, matrix.getExpirationOffset( d ) );\n        assertEquals( 1, matrix.getExpirationOffset( e ) );\n        \n    }", "signature": "void testCalculateTemporalDistance()", "full_signature": "@Test public void testCalculateTemporalDistance()", "class_method_signature": "BuildUtilsTest.testCalculateTemporalDistance()", "testcase": true, "constructor": false, "invocations": ["addConstraint", "getDeclaration", "getEvaluator", "addConstraint", "getDeclaration", "getEvaluator", "addConstraint", "getDeclaration", "getEvaluator", "addConstraint", "getDeclaration", "getEvaluator", "addConstraint", "getDeclaration", "getEvaluator", "addChild", "addChild", "addChild", "addChild", "addChild", "addChild", "calculateTemporalDistance", "assertEqualsMatrix", "getMatrix", "assertEquals", "getExpirationOffset", "assertEquals", "getExpirationOffset", "assertEquals", "getExpirationOffset"]}, "focal_class": {"identifier": "BuildUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Map<Class< ? >, ReteooComponentBuilder> componentBuilders = new HashMap<Class< ? >, ReteooComponentBuilder>();", "modifier": "private final", "type": "Map<Class< ? >, ReteooComponentBuilder>", "declarator": "componentBuilders = new HashMap<Class< ? >, ReteooComponentBuilder>()", "var_name": "componentBuilders"}], "methods": [{"identifier": "addBuilder", "parameters": "(final Class< ? > target,\n                           final ReteooComponentBuilder builder)", "modifiers": "public", "return": "void", "signature": "void addBuilder(final Class< ? > target,\n                           final ReteooComponentBuilder builder)", "full_signature": "public void addBuilder(final Class< ? > target,\n                           final ReteooComponentBuilder builder)", "class_method_signature": "BuildUtils.addBuilder(final Class< ? > target,\n                           final ReteooComponentBuilder builder)", "testcase": false, "constructor": false}, {"identifier": "getBuilderFor", "parameters": "(final RuleConditionElement target)", "modifiers": "public", "return": "ReteooComponentBuilder", "signature": "ReteooComponentBuilder getBuilderFor(final RuleConditionElement target)", "full_signature": "public ReteooComponentBuilder getBuilderFor(final RuleConditionElement target)", "class_method_signature": "BuildUtils.getBuilderFor(final RuleConditionElement target)", "testcase": false, "constructor": false}, {"identifier": "getBuilderFor", "parameters": "(final Class cls)", "modifiers": "public", "return": "ReteooComponentBuilder", "signature": "ReteooComponentBuilder getBuilderFor(final Class cls)", "full_signature": "public ReteooComponentBuilder getBuilderFor(final Class cls)", "class_method_signature": "BuildUtils.getBuilderFor(final Class cls)", "testcase": false, "constructor": false}, {"identifier": "attachNode", "parameters": "(BuildContext context, T candidate)", "modifiers": "public", "return": "T", "signature": "T attachNode(BuildContext context, T candidate)", "full_signature": "public T attachNode(BuildContext context, T candidate)", "class_method_signature": "BuildUtils.attachNode(BuildContext context, T candidate)", "testcase": false, "constructor": false}, {"identifier": "mergeNodes", "parameters": "(BaseNode node, BaseNode duplicate)", "modifiers": "private", "return": "void", "signature": "void mergeNodes(BaseNode node, BaseNode duplicate)", "full_signature": "private void mergeNodes(BaseNode node, BaseNode duplicate)", "class_method_signature": "BuildUtils.mergeNodes(BaseNode node, BaseNode duplicate)", "testcase": false, "constructor": false}, {"identifier": "isSharingEnabledForNode", "parameters": "(BuildContext context, BaseNode node)", "modifiers": "private", "return": "boolean", "signature": "boolean isSharingEnabledForNode(BuildContext context, BaseNode node)", "full_signature": "private boolean isSharingEnabledForNode(BuildContext context, BaseNode node)", "class_method_signature": "BuildUtils.isSharingEnabledForNode(BuildContext context, BaseNode node)", "testcase": false, "constructor": false}, {"identifier": "areNodesCompatibleForSharing", "parameters": "(BuildContext context, BaseNode node)", "modifiers": "private", "return": "boolean", "signature": "boolean areNodesCompatibleForSharing(BuildContext context, BaseNode node)", "full_signature": "private boolean areNodesCompatibleForSharing(BuildContext context, BaseNode node)", "class_method_signature": "BuildUtils.areNodesCompatibleForSharing(BuildContext context, BaseNode node)", "testcase": false, "constructor": false}, {"identifier": "createBetaNodeConstraint", "parameters": "(final BuildContext context,\n                                                    final List<BetaNodeFieldConstraint> list,\n                                                    final boolean disableIndexing)", "modifiers": "public", "return": "BetaConstraints", "signature": "BetaConstraints createBetaNodeConstraint(final BuildContext context,\n                                                    final List<BetaNodeFieldConstraint> list,\n                                                    final boolean disableIndexing)", "full_signature": "public BetaConstraints createBetaNodeConstraint(final BuildContext context,\n                                                    final List<BetaNodeFieldConstraint> list,\n                                                    final boolean disableIndexing)", "class_method_signature": "BuildUtils.createBetaNodeConstraint(final BuildContext context,\n                                                    final List<BetaNodeFieldConstraint> list,\n                                                    final boolean disableIndexing)", "testcase": false, "constructor": false}, {"identifier": "calculateTemporalDistance", "parameters": "(GroupElement groupElement)", "modifiers": "public", "return": "TemporalDependencyMatrix", "signature": "TemporalDependencyMatrix calculateTemporalDistance(GroupElement groupElement)", "full_signature": "public TemporalDependencyMatrix calculateTemporalDistance(GroupElement groupElement)", "class_method_signature": "BuildUtils.calculateTemporalDistance(GroupElement groupElement)", "testcase": false, "constructor": false}, {"identifier": "gatherTemporalRelationships", "parameters": "(List< ? > constraints,\n                                             Map<Declaration, Interval> temporal)", "modifiers": "private", "return": "void", "signature": "void gatherTemporalRelationships(List< ? > constraints,\n                                             Map<Declaration, Interval> temporal)", "full_signature": "private void gatherTemporalRelationships(List< ? > constraints,\n                                             Map<Declaration, Interval> temporal)", "class_method_signature": "BuildUtils.gatherTemporalRelationships(List< ? > constraints,\n                                             Map<Declaration, Interval> temporal)", "testcase": false, "constructor": false}, {"identifier": "selectAllEventPatterns", "parameters": "(List<Pattern> events,\n                                        RuleConditionElement rce)", "modifiers": "private", "return": "void", "signature": "void selectAllEventPatterns(List<Pattern> events,\n                                        RuleConditionElement rce)", "full_signature": "private void selectAllEventPatterns(List<Pattern> events,\n                                        RuleConditionElement rce)", "class_method_signature": "BuildUtils.selectAllEventPatterns(List<Pattern> events,\n                                        RuleConditionElement rce)", "testcase": false, "constructor": false}], "file": "drools-core/src/main/java/org/drools/core/reteoo/builder/BuildUtils.java"}, "focal_method": {"identifier": "calculateTemporalDistance", "parameters": "(GroupElement groupElement)", "modifiers": "public", "return": "TemporalDependencyMatrix", "body": "public TemporalDependencyMatrix calculateTemporalDistance(GroupElement groupElement) {\n        // find the events\n        List<Pattern> events = new ArrayList<Pattern>();\n        selectAllEventPatterns( events,\n                                groupElement );\n\n        final int size = events.size();\n        if ( size >= 1 ) {\n            // create the matrix\n            Interval[][] source = new Interval[size][];\n            for ( int row = 0; row < size; row++ ) {\n                source[row] = new Interval[size];\n                for ( int col = 0; col < size; col++ ) {\n                    if ( row == col ) {\n                        source[row][col] = new Interval( 0,\n                                                         0 );\n                    } else {\n                        source[row][col] = new Interval( Interval.MIN,\n                                                         Interval.MAX );\n                    }\n                }\n            }\n\n            Interval[][] result;\n            if ( size > 1 ) {\n                List<Declaration> declarations = new ArrayList<>();\n                int eventIndex = 0;\n                // populate the matrix\n                for ( Pattern event : events ) {\n                    // references to other events are always backward references, so we can build the list as we go\n                    declarations.add( event.getDeclaration() );\n                    Map<Declaration, Interval> temporal = new HashMap<>();\n                    gatherTemporalRelationships( event.getConstraints(),\n                                                 temporal );\n                    // intersects default values with the actual constrained intervals\n                    for ( Map.Entry<Declaration, Interval> entry : temporal.entrySet() ) {\n                        int targetIndex = declarations.indexOf( entry.getKey() );\n                        Interval interval = entry.getValue();\n                        source[targetIndex][eventIndex].intersect( interval );\n                        Interval reverse = new Interval( interval.getUpperBound() == Long.MAX_VALUE ? Long.MIN_VALUE : -interval.getUpperBound(), \n                                                         interval.getLowerBound() == Long.MIN_VALUE ? Long.MAX_VALUE : -interval.getLowerBound() );\n                        source[eventIndex][targetIndex].intersect( reverse );\n                    }\n                    eventIndex++;\n                }\n                result = TimeUtils.calculateTemporalDistance( source );\n            } else {\n                result = source;\n            }\n            return new TemporalDependencyMatrix( result, events );\n        }\n        return null;\n    }", "signature": "TemporalDependencyMatrix calculateTemporalDistance(GroupElement groupElement)", "full_signature": "public TemporalDependencyMatrix calculateTemporalDistance(GroupElement groupElement)", "class_method_signature": "BuildUtils.calculateTemporalDistance(GroupElement groupElement)", "testcase": false, "constructor": false, "invocations": ["selectAllEventPatterns", "size", "add", "getDeclaration", "gatherTemporalRelationships", "getConstraints", "entrySet", "indexOf", "getKey", "getValue", "intersect", "getUpperBound", "getUpperBound", "getLowerBound", "getLowerBound", "intersect", "calculateTemporalDistance"]}, "repository": {"repo_id": 1381673, "url": "https://github.com/kiegroup/drools", "stars": 2733, "created": "2/18/2011 8:37:05 AM +00:00", "updates": "2020-01-27T13:12:15+00:00", "fork": "False", "license": "licensed"}}