{"test_class": {"identifier": "CarteTopoTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "public final static Logger logger = Logger\n\t\t      .getLogger(SwingingArmNonConvexHull.class.getName());", "modifier": "public final static", "type": "Logger", "declarator": "logger = Logger\n\t\t      .getLogger(SwingingArmNonConvexHull.class.getName())", "var_name": "logger"}, {"original_string": "CarteTopo carte;", "modifier": "", "type": "CarteTopo", "declarator": "carte", "var_name": "carte"}, {"original_string": "Noeud n1;", "modifier": "", "type": "Noeud", "declarator": "n1", "var_name": "n1"}, {"original_string": "Noeud n2;", "modifier": "", "type": "Noeud", "declarator": "n2", "var_name": "n2"}, {"original_string": "Noeud n3;", "modifier": "", "type": "Noeud", "declarator": "n3", "var_name": "n3"}, {"original_string": "Noeud n4;", "modifier": "", "type": "Noeud", "declarator": "n4", "var_name": "n4"}, {"original_string": "Noeud n5;", "modifier": "", "type": "Noeud", "declarator": "n5", "var_name": "n5"}, {"original_string": "Noeud n6;", "modifier": "", "type": "Noeud", "declarator": "n6", "var_name": "n6"}, {"original_string": "Noeud n7;", "modifier": "", "type": "Noeud", "declarator": "n7", "var_name": "n7"}, {"original_string": "Arc a12;", "modifier": "", "type": "Arc", "declarator": "a12", "var_name": "a12"}, {"original_string": "Arc a23;", "modifier": "", "type": "Arc", "declarator": "a23", "var_name": "a23"}, {"original_string": "Arc a14;", "modifier": "", "type": "Arc", "declarator": "a14", "var_name": "a14"}, {"original_string": "Arc a45;", "modifier": "", "type": "Arc", "declarator": "a45", "var_name": "a45"}, {"original_string": "Arc a16;", "modifier": "", "type": "Arc", "declarator": "a16", "var_name": "a16"}, {"original_string": "Arc a67;", "modifier": "", "type": "Arc", "declarator": "a67", "var_name": "a67"}], "file": "geoxygene-contrib/src/test/java/fr/ign/cogit/geoxygene/contrib/cartetopo/CarteTopoTest.java"}, "test_case": {"identifier": "testCreeTopologieFaces", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testCreeTopologieFaces() {\n    CarteTopo carte = new CarteTopo(\"test\"); //$NON-NLS-1$\n    IPopulation<Noeud> noeuds = carte.getPopNoeuds();\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(0, 0)));// n0\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(5, 0)));// n1\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(5, 2)));// n2\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(5, 5)));// n3\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(0, 5)));// n4\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(1, 1)));// n5\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(3, 1)));// n6\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(4, 1)));// n7\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(4, 4)));// n8\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(1, 4)));// n9\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(1, 3)));// n10\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(3, 3)));// n11\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(2, 3)));// n12\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(2, 2)));// n13\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(6, 2)));// n14\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(7, 2)));// n15\n    noeuds.nouvelElement(new GM_Point(new DirectPosition(6, 3)));// n16\n\n    IPopulation<Arc> arcs = carte.getPopArcs();\n    Class<?>[] signaturea = { carte.getPopNoeuds().getClasse(),\n        carte.getPopNoeuds().getClasse() };\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(0), noeuds.get(1) });// a0\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(1), noeuds.get(2) });// a1\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(2), noeuds.get(3) });// a2\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(3), noeuds.get(4) });// a3\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(4), noeuds.get(0) });// a4\n\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(2), noeuds.get(14) });// a5\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(14), noeuds.get(15) });// a6\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(14), noeuds.get(16) });// a7\n\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(5), noeuds.get(6) });// a8\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(6), noeuds.get(7) });// a9\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(7), noeuds.get(8) });// a10\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(8), noeuds.get(9) });// a11\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(9), noeuds.get(10) });// a12\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(10), noeuds.get(5) });// a13\n\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(6), noeuds.get(11) });// a14\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(11), noeuds.get(12) });// a15\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(12), noeuds.get(10) });// a16\n    arcs.nouvelElement(signaturea,\n        new Object[] { noeuds.get(12), noeuds.get(13) });// a17\n\n    carte.creeTopologieFaces();\n    for (Face face : carte.getListeFaces()) {\n      logger.debug(face);\n      logger.debug(\"arcs directs : \"); //$NON-NLS-1$\n      for (Arc arc : face.getArcsDirects()) {\n        logger.debug(arc);\n      }\n      logger.debug(\"arcs indirects : \"); //$NON-NLS-1$\n      for (Arc arc : face.getArcsIndirects()) {\n        logger.debug(arc);\n      }\n      logger.debug(\"arcs pendants : \"); //$NON-NLS-1$\n      for (Arc arc : face.getArcsPendants()) {\n        logger.debug(arc);\n      }\n    }\n    assert (carte.getListeFaces().size() == 4);\n  }", "signature": "void testCreeTopologieFaces()", "full_signature": "@Test public void testCreeTopologieFaces()", "class_method_signature": "CarteTopoTest.testCreeTopologieFaces()", "testcase": true, "constructor": false, "invocations": ["getPopNoeuds", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "nouvelElement", "getPopArcs", "getClasse", "getPopNoeuds", "getClasse", "getPopNoeuds", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "nouvelElement", "get", "get", "creeTopologieFaces", "getListeFaces", "debug", "debug", "getArcsDirects", "debug", "debug", "getArcsIndirects", "debug", "debug", "getArcsPendants", "debug", "size", "getListeFaces"]}, "focal_class": {"identifier": "CarteTopo", "superclass": "extends DataSet", "interfaces": "", "fields": [{"original_string": "protected final static Logger logger = Logger\n      .getLogger(CarteTopo.class.getName());", "modifier": "protected final static", "type": "Logger", "declarator": "logger = Logger\n      .getLogger(CarteTopo.class.getName())", "var_name": "logger"}, {"original_string": "protected EventListenerList listenerList = new EventListenerList();", "modifier": "protected", "type": "EventListenerList", "declarator": "listenerList = new EventListenerList()", "var_name": "listenerList"}, {"original_string": "private boolean buildInfiniteFace = true;", "modifier": "private", "type": "boolean", "declarator": "buildInfiniteFace = true", "var_name": "buildInfiniteFace"}, {"original_string": "public static final int SPAGHETTI = 0;", "modifier": "public static final", "type": "int", "declarator": "SPAGHETTI = 0", "var_name": "SPAGHETTI"}, {"original_string": "public static final int NETWORK = 1;", "modifier": "public static final", "type": "int", "declarator": "NETWORK = 1", "var_name": "NETWORK"}, {"original_string": "public static final int MAP = 2;", "modifier": "public static final", "type": "int", "declarator": "MAP = 2", "var_name": "MAP"}, {"original_string": "private int type = CarteTopo.MAP;", "modifier": "private", "type": "int", "declarator": "type = CarteTopo.MAP", "var_name": "type"}], "methods": [{"identifier": "addActionListener", "parameters": "(ActionListener l)", "modifiers": "public", "return": "void", "signature": "void addActionListener(ActionListener l)", "full_signature": "public void addActionListener(ActionListener l)", "class_method_signature": "CarteTopo.addActionListener(ActionListener l)", "testcase": false, "constructor": false}, {"identifier": "setActionListeners", "parameters": "(EventListenerList listenerList)", "modifiers": "public", "return": "void", "signature": "void setActionListeners(EventListenerList listenerList)", "full_signature": "public void setActionListeners(EventListenerList listenerList)", "class_method_signature": "CarteTopo.setActionListeners(EventListenerList listenerList)", "testcase": false, "constructor": false}, {"identifier": "fireActionPerformed", "parameters": "(ActionEvent event)", "modifiers": "protected", "return": "void", "signature": "void fireActionPerformed(ActionEvent event)", "full_signature": "protected void fireActionPerformed(ActionEvent event)", "class_method_signature": "CarteTopo.fireActionPerformed(ActionEvent event)", "testcase": false, "constructor": false}, {"identifier": "getPopArcs", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "IPopulation<Arc>", "signature": "IPopulation<Arc> getPopArcs()", "full_signature": "@SuppressWarnings(\"unchecked\") public IPopulation<Arc> getPopArcs()", "class_method_signature": "CarteTopo.getPopArcs()", "testcase": false, "constructor": false}, {"identifier": "getPopNoeuds", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "IPopulation<Noeud>", "signature": "IPopulation<Noeud> getPopNoeuds()", "full_signature": "@SuppressWarnings(\"unchecked\") public IPopulation<Noeud> getPopNoeuds()", "class_method_signature": "CarteTopo.getPopNoeuds()", "testcase": false, "constructor": false}, {"identifier": "getPopFaces", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "IPopulation<Face>", "signature": "IPopulation<Face> getPopFaces()", "full_signature": "@SuppressWarnings(\"unchecked\") public IPopulation<Face> getPopFaces()", "class_method_signature": "CarteTopo.getPopFaces()", "testcase": false, "constructor": false}, {"identifier": "getPopGroupes", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "IPopulation<Groupe>", "signature": "IPopulation<Groupe> getPopGroupes()", "full_signature": "@SuppressWarnings(\"unchecked\") public IPopulation<Groupe> getPopGroupes()", "class_method_signature": "CarteTopo.getPopGroupes()", "testcase": false, "constructor": false}, {"identifier": "getListeNoeuds", "parameters": "()", "modifiers": "public", "return": "List<Noeud>", "signature": "List<Noeud> getListeNoeuds()", "full_signature": "public List<Noeud> getListeNoeuds()", "class_method_signature": "CarteTopo.getListeNoeuds()", "testcase": false, "constructor": false}, {"identifier": "getListeArcs", "parameters": "()", "modifiers": "public", "return": "List<Arc>", "signature": "List<Arc> getListeArcs()", "full_signature": "public List<Arc> getListeArcs()", "class_method_signature": "CarteTopo.getListeArcs()", "testcase": false, "constructor": false}, {"identifier": "getListeFaces", "parameters": "()", "modifiers": "public", "return": "List<Face>", "signature": "List<Face> getListeFaces()", "full_signature": "public List<Face> getListeFaces()", "class_method_signature": "CarteTopo.getListeFaces()", "testcase": false, "constructor": false}, {"identifier": "getListeGroupes", "parameters": "()", "modifiers": "public", "return": "List<Groupe>", "signature": "List<Groupe> getListeGroupes()", "full_signature": "public List<Groupe> getListeGroupes()", "class_method_signature": "CarteTopo.getListeGroupes()", "testcase": false, "constructor": false}, {"identifier": "addNoeud", "parameters": "(Noeud noeud)", "modifiers": "public", "return": "void", "signature": "void addNoeud(Noeud noeud)", "full_signature": "public void addNoeud(Noeud noeud)", "class_method_signature": "CarteTopo.addNoeud(Noeud noeud)", "testcase": false, "constructor": false}, {"identifier": "addArc", "parameters": "(Arc arc)", "modifiers": "public", "return": "void", "signature": "void addArc(Arc arc)", "full_signature": "public void addArc(Arc arc)", "class_method_signature": "CarteTopo.addArc(Arc arc)", "testcase": false, "constructor": false}, {"identifier": "addFace", "parameters": "(Face face)", "modifiers": "public", "return": "void", "signature": "void addFace(Face face)", "full_signature": "public void addFace(Face face)", "class_method_signature": "CarteTopo.addFace(Face face)", "testcase": false, "constructor": false}, {"identifier": "addGroupe", "parameters": "(Groupe groupe)", "modifiers": "public", "return": "void", "signature": "void addGroupe(Groupe groupe)", "full_signature": "public void addGroupe(Groupe groupe)", "class_method_signature": "CarteTopo.addGroupe(Groupe groupe)", "testcase": false, "constructor": false}, {"identifier": "isBuildInfiniteFace", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isBuildInfiniteFace()", "full_signature": "public boolean isBuildInfiniteFace()", "class_method_signature": "CarteTopo.isBuildInfiniteFace()", "testcase": false, "constructor": false}, {"identifier": "setBuildInfiniteFace", "parameters": "(boolean buildInfiniteFace)", "modifiers": "public", "return": "void", "signature": "void setBuildInfiniteFace(boolean buildInfiniteFace)", "full_signature": "public void setBuildInfiniteFace(boolean buildInfiniteFace)", "class_method_signature": "CarteTopo.setBuildInfiniteFace(boolean buildInfiniteFace)", "testcase": false, "constructor": false}, {"identifier": "CarteTopo", "parameters": "()", "modifiers": "public", "return": "", "signature": " CarteTopo()", "full_signature": "public  CarteTopo()", "class_method_signature": "CarteTopo.CarteTopo()", "testcase": false, "constructor": true}, {"identifier": "CarteTopo", "parameters": "(String nomLogique)", "modifiers": "public", "return": "", "signature": " CarteTopo(String nomLogique)", "full_signature": "public  CarteTopo(String nomLogique)", "class_method_signature": "CarteTopo.CarteTopo(String nomLogique)", "testcase": false, "constructor": true}, {"identifier": "getType", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getType()", "full_signature": "public int getType()", "class_method_signature": "CarteTopo.getType()", "testcase": false, "constructor": false}, {"identifier": "setType", "parameters": "(int i)", "modifiers": "public", "return": "void", "signature": "void setType(int i)", "full_signature": "public void setType(int i)", "class_method_signature": "CarteTopo.setType(int i)", "testcase": false, "constructor": false}, {"identifier": "copie", "parameters": "(String nomLogique)", "modifiers": "public", "return": "CarteTopo", "signature": "CarteTopo copie(String nomLogique)", "full_signature": "public CarteTopo copie(String nomLogique)", "class_method_signature": "CarteTopo.copie(String nomLogique)", "testcase": false, "constructor": false}, {"identifier": "enleveArcs", "parameters": "(Collection<Arc> arcsAEnlever)", "modifiers": "public", "return": "void", "signature": "void enleveArcs(Collection<Arc> arcsAEnlever)", "full_signature": "public void enleveArcs(Collection<Arc> arcsAEnlever)", "class_method_signature": "CarteTopo.enleveArcs(Collection<Arc> arcsAEnlever)", "testcase": false, "constructor": false}, {"identifier": "enleveArc", "parameters": "(Arc arcAEnlever)", "modifiers": "public", "return": "void", "signature": "void enleveArc(Arc arcAEnlever)", "full_signature": "public void enleveArc(Arc arcAEnlever)", "class_method_signature": "CarteTopo.enleveArc(Arc arcAEnlever)", "testcase": false, "constructor": false}, {"identifier": "enleveArcsBoucles", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void enleveArcsBoucles()", "full_signature": "public void enleveArcsBoucles()", "class_method_signature": "CarteTopo.enleveArcsBoucles()", "testcase": false, "constructor": false}, {"identifier": "enleveNoeuds", "parameters": "(Collection<Noeud> noeudsAEnlever)", "modifiers": "public", "return": "void", "signature": "void enleveNoeuds(Collection<Noeud> noeudsAEnlever)", "full_signature": "public void enleveNoeuds(Collection<Noeud> noeudsAEnlever)", "class_method_signature": "CarteTopo.enleveNoeuds(Collection<Noeud> noeudsAEnlever)", "testcase": false, "constructor": false}, {"identifier": "enleveFaces", "parameters": "(Collection<Face> facesAEnlever)", "modifiers": "public", "return": "void", "signature": "void enleveFaces(Collection<Face> facesAEnlever)", "full_signature": "public void enleveFaces(Collection<Face> facesAEnlever)", "class_method_signature": "CarteTopo.enleveFaces(Collection<Face> facesAEnlever)", "testcase": false, "constructor": false}, {"identifier": "creeTopologieArcsNoeuds", "parameters": "(double tolerance)", "modifiers": "public", "return": "void", "signature": "void creeTopologieArcsNoeuds(double tolerance)", "full_signature": "public void creeTopologieArcsNoeuds(double tolerance)", "class_method_signature": "CarteTopo.creeTopologieArcsNoeuds(double tolerance)", "testcase": false, "constructor": false}, {"identifier": "creeNoeudsManquants", "parameters": "(double tolerance)", "modifiers": "public", "return": "void", "signature": "void creeNoeudsManquants(double tolerance)", "full_signature": "public void creeNoeudsManquants(double tolerance)", "class_method_signature": "CarteTopo.creeNoeudsManquants(double tolerance)", "testcase": false, "constructor": false}, {"identifier": "filtreNoeudsIsoles", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void filtreNoeudsIsoles()", "full_signature": "public void filtreNoeudsIsoles()", "class_method_signature": "CarteTopo.filtreNoeudsIsoles()", "testcase": false, "constructor": false}, {"identifier": "filtreArcsNull", "parameters": "(double tolerance)", "modifiers": "public", "return": "void", "signature": "void filtreArcsNull(double tolerance)", "full_signature": "public void filtreArcsNull(double tolerance)", "class_method_signature": "CarteTopo.filtreArcsNull(double tolerance)", "testcase": false, "constructor": false}, {"identifier": "filtreDoublons", "parameters": "(double tolerance)", "modifiers": "public", "return": "void", "signature": "void filtreDoublons(double tolerance)", "full_signature": "public void filtreDoublons(double tolerance)", "class_method_signature": "CarteTopo.filtreDoublons(double tolerance)", "testcase": false, "constructor": false}, {"identifier": "filtreNoeudsSimples", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void filtreNoeudsSimples()", "full_signature": "public void filtreNoeudsSimples()", "class_method_signature": "CarteTopo.filtreNoeudsSimples()", "testcase": false, "constructor": false}, {"identifier": "filtreNoeudsSimples", "parameters": "(boolean useWeight, IGeometry filteredArea)", "modifiers": "public", "return": "void", "signature": "void filtreNoeudsSimples(boolean useWeight, IGeometry filteredArea)", "full_signature": "public void filtreNoeudsSimples(boolean useWeight, IGeometry filteredArea)", "class_method_signature": "CarteTopo.filtreNoeudsSimples(boolean useWeight, IGeometry filteredArea)", "testcase": false, "constructor": false}, {"identifier": "filtreNoeudsSimples", "parameters": "(boolean useWeight, IGeometry filteredArea,\n      boolean checkEqualCorrespondants)", "modifiers": "public", "return": "void", "signature": "void filtreNoeudsSimples(boolean useWeight, IGeometry filteredArea,\n      boolean checkEqualCorrespondants)", "full_signature": "public void filtreNoeudsSimples(boolean useWeight, IGeometry filteredArea,\n      boolean checkEqualCorrespondants)", "class_method_signature": "CarteTopo.filtreNoeudsSimples(boolean useWeight, IGeometry filteredArea,\n      boolean checkEqualCorrespondants)", "testcase": false, "constructor": false}, {"identifier": "filtreArcsDoublons", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void filtreArcsDoublons()", "full_signature": "public void filtreArcsDoublons()", "class_method_signature": "CarteTopo.filtreArcsDoublons()", "testcase": false, "constructor": false}, {"identifier": "filtreArcsDoublons", "parameters": "(double toleranceHaussdorf)", "modifiers": "public", "return": "void", "signature": "void filtreArcsDoublons(double toleranceHaussdorf)", "full_signature": "public void filtreArcsDoublons(double toleranceHaussdorf)", "class_method_signature": "CarteTopo.filtreArcsDoublons(double toleranceHaussdorf)", "testcase": false, "constructor": false}, {"identifier": "cleanEdges", "parameters": "(double tolerance)", "modifiers": "public", "return": "void", "signature": "void cleanEdges(double tolerance)", "full_signature": "public void cleanEdges(double tolerance)", "class_method_signature": "CarteTopo.cleanEdges(double tolerance)", "testcase": false, "constructor": false}, {"identifier": "cleanLineString", "parameters": "(ILineString line, double tolerance)", "modifiers": "public static", "return": "void", "signature": "void cleanLineString(ILineString line, double tolerance)", "full_signature": "public static void cleanLineString(ILineString line, double tolerance)", "class_method_signature": "CarteTopo.cleanLineString(ILineString line, double tolerance)", "testcase": false, "constructor": false}, {"identifier": "rendPlanaire", "parameters": "(double tolerance)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "void", "signature": "void rendPlanaire(double tolerance)", "full_signature": "@SuppressWarnings(\"unchecked\") public void rendPlanaire(double tolerance)", "class_method_signature": "CarteTopo.rendPlanaire(double tolerance)", "testcase": false, "constructor": false}, {"identifier": "fusionNoeuds", "parameters": "(double tolerance)", "modifiers": "public", "return": "void", "signature": "void fusionNoeuds(double tolerance)", "full_signature": "public void fusionNoeuds(double tolerance)", "class_method_signature": "CarteTopo.fusionNoeuds(double tolerance)", "testcase": false, "constructor": false}, {"identifier": "fusionNoeuds", "parameters": "(IPopulation<? extends IFeature> popSurfaces)", "modifiers": "public", "return": "void", "signature": "void fusionNoeuds(IPopulation<? extends IFeature> popSurfaces)", "full_signature": "public void fusionNoeuds(IPopulation<? extends IFeature> popSurfaces)", "class_method_signature": "CarteTopo.fusionNoeuds(IPopulation<? extends IFeature> popSurfaces)", "testcase": false, "constructor": false}, {"identifier": "projete", "parameters": "(CarteTopo ct, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud, boolean impassesSeulement)", "modifiers": "public", "return": "void", "signature": "void projete(CarteTopo ct, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud, boolean impassesSeulement)", "full_signature": "public void projete(CarteTopo ct, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud, boolean impassesSeulement)", "class_method_signature": "CarteTopo.projete(CarteTopo ct, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud, boolean impassesSeulement)", "testcase": false, "constructor": false}, {"identifier": "projeteTousLesPoints", "parameters": "(CarteTopo ct, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud)", "modifiers": "public", "return": "void", "signature": "void projeteTousLesPoints(CarteTopo ct, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud)", "full_signature": "public void projeteTousLesPoints(CarteTopo ct, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud)", "class_method_signature": "CarteTopo.projeteTousLesPoints(CarteTopo ct, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud)", "testcase": false, "constructor": false}, {"identifier": "projete", "parameters": "(List<IPoint> pts, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud)", "modifiers": "public", "return": "void", "signature": "void projete(List<IPoint> pts, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud)", "full_signature": "public void projete(List<IPoint> pts, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud)", "class_method_signature": "CarteTopo.projete(List<IPoint> pts, double distanceMaxNoeudArc,\n      double distanceMaxProjectionNoeud)", "testcase": false, "constructor": false}, {"identifier": "creeTopologieFaces", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "void", "signature": "void creeTopologieFaces()", "full_signature": "@SuppressWarnings(\"unchecked\") public void creeTopologieFaces()", "class_method_signature": "CarteTopo.creeTopologieFaces()", "testcase": false, "constructor": false}, {"identifier": "construireGeometrieCycleExterieur", "parameters": "(Arc arcInitial,\n      boolean aGauche)", "modifiers": "public static", "return": "List<Cycle>", "signature": "List<Cycle> construireGeometrieCycleExterieur(Arc arcInitial,\n      boolean aGauche)", "full_signature": "public static List<Cycle> construireGeometrieCycleExterieur(Arc arcInitial,\n      boolean aGauche)", "class_method_signature": "CarteTopo.construireGeometrieCycleExterieur(Arc arcInitial,\n      boolean aGauche)", "testcase": false, "constructor": false}, {"identifier": "videTopologieFace", "parameters": "(Face face)", "modifiers": "public", "return": "void", "signature": "void videTopologieFace(Face face)", "full_signature": "public void videTopologieFace(Face face)", "class_method_signature": "CarteTopo.videTopologieFace(Face face)", "testcase": false, "constructor": false}, {"identifier": "ajouteArcsEtNoeudsAuxFaces", "parameters": "(boolean filtrageNoeudsSimples)", "modifiers": "public", "return": "void", "signature": "void ajouteArcsEtNoeudsAuxFaces(boolean filtrageNoeudsSimples)", "full_signature": "public void ajouteArcsEtNoeudsAuxFaces(boolean filtrageNoeudsSimples)", "class_method_signature": "CarteTopo.ajouteArcsEtNoeudsAuxFaces(boolean filtrageNoeudsSimples)", "testcase": false, "constructor": false}, {"identifier": "addMissingEdges", "parameters": "(double threshold)", "modifiers": "public", "return": "void", "signature": "void addMissingEdges(double threshold)", "full_signature": "public void addMissingEdges(double threshold)", "class_method_signature": "CarteTopo.addMissingEdges(double threshold)", "testcase": false, "constructor": false}, {"identifier": "insertOrSelectNode", "parameters": "(IDirectPosition p, double threshold)", "modifiers": "private", "return": "Noeud", "signature": "Noeud insertOrSelectNode(IDirectPosition p, double threshold)", "full_signature": "private Noeud insertOrSelectNode(IDirectPosition p, double threshold)", "class_method_signature": "CarteTopo.insertOrSelectNode(IDirectPosition p, double threshold)", "testcase": false, "constructor": false}, {"identifier": "initialisePoids", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void initialisePoids()", "full_signature": "public void initialisePoids()", "class_method_signature": "CarteTopo.initialisePoids()", "testcase": false, "constructor": false}, {"identifier": "importClasseGeo", "parameters": "(String nomClasseGeo)", "modifiers": "public", "return": "void", "signature": "void importClasseGeo(String nomClasseGeo)", "full_signature": "public void importClasseGeo(String nomClasseGeo)", "class_method_signature": "CarteTopo.importClasseGeo(String nomClasseGeo)", "testcase": false, "constructor": false}, {"identifier": "importClasseGeo", "parameters": "(IFeatureCollection<?> listeFeatures)", "modifiers": "public", "return": "void", "signature": "void importClasseGeo(IFeatureCollection<?> listeFeatures)", "full_signature": "public void importClasseGeo(IFeatureCollection<?> listeFeatures)", "class_method_signature": "CarteTopo.importClasseGeo(IFeatureCollection<?> listeFeatures)", "testcase": false, "constructor": false}, {"identifier": "importClasseGeo", "parameters": "(IFeatureCollection<?> listeFeatures,\n      boolean is2d)", "modifiers": "public", "return": "void", "signature": "void importClasseGeo(IFeatureCollection<?> listeFeatures,\n      boolean is2d)", "full_signature": "public void importClasseGeo(IFeatureCollection<?> listeFeatures,\n      boolean is2d)", "class_method_signature": "CarteTopo.importClasseGeo(IFeatureCollection<?> listeFeatures,\n      boolean is2d)", "testcase": false, "constructor": false}, {"identifier": "importAsNodes", "parameters": "(Collection<? extends IFeature> listeFeatures)", "modifiers": "public", "return": "void", "signature": "void importAsNodes(Collection<? extends IFeature> listeFeatures)", "full_signature": "public void importAsNodes(Collection<? extends IFeature> listeFeatures)", "class_method_signature": "CarteTopo.importAsNodes(Collection<? extends IFeature> listeFeatures)", "testcase": false, "constructor": false}, {"identifier": "importAsNodes", "parameters": "(IFeatureCollection<?> listeFeatures)", "modifiers": "public", "return": "void", "signature": "void importAsNodes(IFeatureCollection<?> listeFeatures)", "full_signature": "public void importAsNodes(IFeatureCollection<?> listeFeatures)", "class_method_signature": "CarteTopo.importAsNodes(IFeatureCollection<?> listeFeatures)", "testcase": false, "constructor": false}, {"identifier": "marquerCycle", "parameters": "(Cycle cycle, Face face)", "modifiers": "public", "return": "void", "signature": "void marquerCycle(Cycle cycle, Face face)", "full_signature": "public void marquerCycle(Cycle cycle, Face face)", "class_method_signature": "CarteTopo.marquerCycle(Cycle cycle, Face face)", "testcase": false, "constructor": false}, {"identifier": "marquerCycle", "parameters": "(List<Arc> arcs, List<Boolean> orientations,\n      boolean aGauche, Face face, List<Arc> arcsDejaTraitesAGauche,\n      List<Arc> arcsDejaTraitesADroite)", "modifiers": "public", "return": "void", "signature": "void marquerCycle(List<Arc> arcs, List<Boolean> orientations,\n      boolean aGauche, Face face, List<Arc> arcsDejaTraitesAGauche,\n      List<Arc> arcsDejaTraitesADroite)", "full_signature": "public void marquerCycle(List<Arc> arcs, List<Boolean> orientations,\n      boolean aGauche, Face face, List<Arc> arcsDejaTraitesAGauche,\n      List<Arc> arcsDejaTraitesADroite)", "class_method_signature": "CarteTopo.marquerCycle(List<Arc> arcs, List<Boolean> orientations,\n      boolean aGauche, Face face, List<Arc> arcsDejaTraitesAGauche,\n      List<Arc> arcsDejaTraitesADroite)", "testcase": false, "constructor": false}, {"identifier": "nettoyer", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void nettoyer()", "full_signature": "public void nettoyer()", "class_method_signature": "CarteTopo.nettoyer()", "testcase": false, "constructor": false}, {"identifier": "enleveNoeud", "parameters": "(Noeud n)", "modifiers": "public", "return": "void", "signature": "void enleveNoeud(Noeud n)", "full_signature": "public void enleveNoeud(Noeud n)", "class_method_signature": "CarteTopo.enleveNoeud(Noeud n)", "testcase": false, "constructor": false}, {"identifier": "decoupeArcs", "parameters": "(double distance)", "modifiers": "public", "return": "void", "signature": "void decoupeArcs(double distance)", "full_signature": "public void decoupeArcs(double distance)", "class_method_signature": "CarteTopo.decoupeArcs(double distance)", "testcase": false, "constructor": false}, {"identifier": "splitEdgesWithPoints", "parameters": "(double distance)", "modifiers": "public", "return": "void", "signature": "void splitEdgesWithPoints(double distance)", "full_signature": "public void splitEdgesWithPoints(double distance)", "class_method_signature": "CarteTopo.splitEdgesWithPoints(double distance)", "testcase": false, "constructor": false}, {"identifier": "mergeNode", "parameters": "(Arc a1, Arc a2, Arc a, Noeud n)", "modifiers": "private", "return": "Arc", "signature": "Arc mergeNode(Arc a1, Arc a2, Arc a, Noeud n)", "full_signature": "private Arc mergeNode(Arc a1, Arc a2, Arc a, Noeud n)", "class_method_signature": "CarteTopo.mergeNode(Arc a1, Arc a2, Arc a, Noeud n)", "testcase": false, "constructor": false}, {"identifier": "splitEdge", "parameters": "(Arc a, IDirectPosition p)", "modifiers": "public", "return": "Noeud", "signature": "Noeud splitEdge(Arc a, IDirectPosition p)", "full_signature": "public Noeud splitEdge(Arc a, IDirectPosition p)", "class_method_signature": "CarteTopo.splitEdge(Arc a, IDirectPosition p)", "testcase": false, "constructor": false}, {"identifier": "splitEdge", "parameters": "(Arc a, List<Integer> indices)", "modifiers": "private", "return": "void", "signature": "void splitEdge(Arc a, List<Integer> indices)", "full_signature": "private void splitEdge(Arc a, List<Integer> indices)", "class_method_signature": "CarteTopo.splitEdge(Arc a, List<Integer> indices)", "testcase": false, "constructor": false}, {"identifier": "shortestPath", "parameters": "(IDirectPosition x1, IDirectPosition x2, Arc a1,\n      Arc a2, double max)", "modifiers": "public", "return": "Groupe", "signature": "Groupe shortestPath(IDirectPosition x1, IDirectPosition x2, Arc a1,\n      Arc a2, double max)", "full_signature": "public Groupe shortestPath(IDirectPosition x1, IDirectPosition x2, Arc a1,\n      Arc a2, double max)", "class_method_signature": "CarteTopo.shortestPath(IDirectPosition x1, IDirectPosition x2, Arc a1,\n      Arc a2, double max)", "testcase": false, "constructor": false}], "file": "geoxygene-contrib/src/main/java/fr/ign/cogit/geoxygene/contrib/cartetopo/CarteTopo.java"}, "focal_method": {"identifier": "creeTopologieFaces", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "void", "body": "@SuppressWarnings(\"unchecked\")\n  public void creeTopologieFaces() {\n    List<Arc> arcsDejaTraitesADroite = new ArrayList<Arc>();\n    List<Arc> arcsDejaTraitesAGauche = new ArrayList<Arc>();\n    List<Arc> arcsDuCycle;\n    List<Boolean> orientationsArcsDuCycle;\n    ILineString geometrieDuCycle;\n    IPopulation<Face> popFaces = this.getPopFaces();\n    List<Cycle> cycles = new ArrayList<Cycle>();\n    this.fireActionPerformed(\n        new ActionEvent(this, 0, I18N.getString(\"CarteTopo.FaceTopologyEdges\"), //$NON-NLS-1$\n            this.getPopArcs().size()));\n    int iteration = 0;\n    /*\n     * Parcours de tous les arcs du graphe. Puis, pour chaque arc: - recherche\n     * du cycle \u00e0 droite et du cycle \u00e0 gauche - creation des faces\n     * correspondantes - on note les arcs par lesquels on est d\u00e9j\u00e0 pass\u00e9 pour ne\n     * pas refaire le travail TODO Regrouper le traitement \u00e0 droite et \u00e0 gauche\n     * des arcs.\n     */\n    for (Arc arc : this.getPopArcs()) {\n      Face face = null;\n      // a droite\n      if (!arcsDejaTraitesADroite.contains(arc)) {\n        Cycle cycle = arc.cycle(false);\n        // face = null;\n        if (cycle == null) {\n          CarteTopo.logger\n              .error(I18N.getString(\"CarteTopo.RightNullCycle\") + arc.getId()); //$NON-NLS-1$\n          continue;\n        }\n        arcsDuCycle = cycle.getArcs();\n        orientationsArcsDuCycle = cycle.getOrientationsArcs();\n        geometrieDuCycle = cycle.getGeometrie();\n        boolean multiGeometrie = false;\n        boolean simple = geometrieDuCycle.isSimple();\n        if (!simple) {\n          List<Cycle> cyclesGeometrieNonSimple = CarteTopo\n              .construireGeometrieCycleExterieur(arc, false);\n          // la g\u00e9om\u00e9trie est corrig\u00e9e\n          if (cyclesGeometrieNonSimple.size() == 1) {\n            geometrieDuCycle = cyclesGeometrieNonSimple.get(0).getGeometrie();\n          } else {\n            for (Cycle cycleCourant : cyclesGeometrieNonSimple) {\n              boolean ccw = JtsAlgorithms.isCCW(cycleCourant.getGeometrie());\n              if (ccw) {\n                cycles.add(cycleCourant);\n              } else {\n                face = popFaces\n                    .nouvelElement(new GM_Polygon(cycleCourant.getGeometrie()));\n                CarteTopo.logger.debug(\"NEW FACE = \" + face.getGeometrie());\n              }\n            }\n            multiGeometrie = true;\n          }\n        }\n        if (!multiGeometrie) {\n          if (geometrieDuCycle.sizeControlPoint() > 3) {\n            boolean ccw = JtsAlgorithms.isCCW(geometrieDuCycle);\n            if (ccw) {\n              cycles.add(new Cycle(arcsDuCycle, orientationsArcsDuCycle,\n                  geometrieDuCycle, false));\n            } else {\n              face = popFaces.nouvelElement(new GM_Polygon(geometrieDuCycle));\n              CarteTopo.logger.debug(\"NEW FACE = \" + face.getGeometrie());\n            }\n          }\n        }\n        // if ( persistant ) JeuDeDonnees.db.makePersistent(face);\n        this.marquerCycle(arcsDuCycle, orientationsArcsDuCycle, false, face,\n            arcsDejaTraitesAGauche, arcsDejaTraitesADroite);\n      }\n      // a gauche\n      if (!arcsDejaTraitesAGauche.contains(arc)) {\n        Cycle cycle = arc.cycle(true);\n        face = null;\n        if (cycle == null) {\n          if (CarteTopo.logger.isDebugEnabled()) {\n            CarteTopo.logger\n                .debug(I18N.getString(\"CarteTopo.LeftNullCycle\") + arc.getId());\n          }\n          continue;\n        }\n        arcsDuCycle = cycle.getArcs();\n        orientationsArcsDuCycle = cycle.getOrientationsArcs();\n        geometrieDuCycle = cycle.getGeometrie();\n        boolean multiGeometrie = false;\n        boolean simple = geometrieDuCycle.isSimple();\n        if (!simple) {\n          List<Cycle> cyclesGeometrieNonSimple = CarteTopo\n              .construireGeometrieCycleExterieur(arc, true);\n          // la g\u00e9om\u00e9trie est corrig\u00e9e\n          if (cyclesGeometrieNonSimple.size() == 1) {\n            geometrieDuCycle = cyclesGeometrieNonSimple.get(0).getGeometrie();\n          } else {\n            for (Cycle cycleCourant : cyclesGeometrieNonSimple) {\n              boolean ccw = JtsAlgorithms.isCCW(cycleCourant.getGeometrie());\n              if (!ccw) {\n                cycles.add(cycleCourant);\n              } else {\n                face = popFaces\n                    .nouvelElement(new GM_Polygon(cycleCourant.getGeometrie()));\n                CarteTopo.logger.debug(\"NEW FACE = \" + face.getGeometrie());\n              }\n            }\n            multiGeometrie = true;\n          }\n        }\n        if (!multiGeometrie && geometrieDuCycle.sizeControlPoint() > 3) {\n          boolean ccw = JtsAlgorithms.isCCW(geometrieDuCycle);\n          if (!ccw) {\n            cycles.add(new Cycle(arcsDuCycle, orientationsArcsDuCycle,\n                geometrieDuCycle, true));\n          } else {\n            face = popFaces.nouvelElement(new GM_Polygon(geometrieDuCycle));\n            if (CarteTopo.logger.isDebugEnabled()) {\n              CarteTopo.logger.debug(\"NEW FACE = \" + face.getGeometrie());\n            }\n          }\n        }\n        // if ( persistant ) JeuDeDonnees.db.makePersistent(face);\n        this.marquerCycle(arcsDuCycle, orientationsArcsDuCycle, true, face,\n            arcsDejaTraitesAGauche, arcsDejaTraitesADroite);\n      }\n      this.fireActionPerformed(new ActionEvent(this, 1,\n          I18N.getString(\"CarteTopo.FaceTopologyEdge\"), iteration++)); //$NON-NLS-1$\n    }\n    // d\u00e9tection des arcs pendants ie des culs-de-sac\n    for (Arc arcCourant : this.getPopArcs()) {\n      if ((arcCourant.getFaceDroite() == null)\n          || (arcCourant.getFaceGauche() == null)) {\n        continue;\n      }\n      if (arcCourant.getFaceDroite() == arcCourant.getFaceGauche()) {\n        arcCourant.setPendant(true);\n      }\n    }\n    /*\n     * cr\u00e9ation de l'index spatial. On n'active pas la mise \u00e0 jour automatique\n     * afin que, lorsque l'on ajoute la face infinie, elle n'apparaisse pas dans\n     * chaque requ\u00eate select.\n     */\n    this.getPopFaces().initSpatialIndex(Tiling.class, false);\n    Face faceInfinie = null;\n    if (this.buildInfiniteFace) {\n      IEnvelope envelope = this.getPopArcs().envelope();\n      if (envelope != null) {\n        faceInfinie = this.getPopFaces()\n            .nouvelElement(new GM_Polygon(\n                new GM_Envelope(envelope.minX() - 1, envelope.maxX() + 1,\n                    envelope.minY() - 1, envelope.maxY() + 1)));\n        faceInfinie.setInfinite(true);\n      }\n      // CarteTopo.logger.debug(\"INFINITE FACE = \" +\n      // faceInfinie.getGeometrie());\n    }\n    this.fireActionPerformed(new ActionEvent(this, 2,\n        I18N.getString(\"CarteTopo.FaceTopologyCycles\"), cycles.size())); //$NON-NLS-1$\n    iteration = 0;\n    for (Cycle cycle : cycles) {\n      Face face = ((cycle.isAGauche()\n          && cycle.getOrientationsArcs().get(0).booleanValue())\n          || (!cycle.isAGauche()\n              && !cycle.getOrientationsArcs().get(0).booleanValue()))\n                  ? cycle.getArcs().get(0).getFaceGauche()\n                  : cycle.getArcs().get(0).getFaceDroite();\n      if (face == null) {\n        ILineString geom = cycle.getGeometrie();\n        // logger.debug(\"NULL Face for \" + cycle);\n        if (geom == null || geom.numPoints() < 2 || !geom.isValid()) {\n          logger.error(\"PB WITH \" + cycle);\n          face = faceInfinie;\n        } else {\n          Collection<Face> selection = this.getPopFaces().select(geom);\n          if (selection.isEmpty()) {\n            face = faceInfinie;\n          } else {\n            selection.removeAll(cycle.getListeFacesInterieuresDuCycle());\n            Iterator<Face> it = selection.iterator();\n            while (it.hasNext()) {\n              if (!it.next().getGeometrie().contains(geom)) {\n                it.remove();\n              }\n            }\n            if (selection.isEmpty()) {\n              face = faceInfinie;\n            } else {\n              it = selection.iterator();\n              face = it.next();\n              // s'il y a plus d'une face qui contient celle-ci\n              while (it.hasNext()) {\n                Face f = it.next();\n                // on s\u00e9lectionne la plus petite\n                if (f.getGeometrie().area() < face.getGeometrie().area()) {\n                  face = f;\n                }\n              }\n            }\n          }\n        }\n      }\n      this.marquerCycle(cycle, face);\n      // on ajoute un trou \u00e0 la g\u00e9om\u00e9trie de la face infinie\n      if (this.buildInfiniteFace && faceInfinie != null) {\n        // CarteTopo.logger.debug(\"faceInfinie \" + face.getGeometrie());\n        if (cycle.getGeometrie().sizeControlPoint() > 3) {\n          // FIXME That does not look very efficient...\n          IPolygon holePolygon = (IPolygon) new GM_Polygon(cycle.getGeometrie())\n              .buffer(0);\n          // CarteTopo.logger.debug(\"hole \" + holePolygon);\n          if (!holePolygon.coord().isEmpty() && holePolygon.coord().size() > 3\n              && holePolygon.isValid()) {\n            // if (face.getGeometrie().getInterior().isEmpty()) {\n            // face.getGeometrie().addInterior(new\n            // GM_Ring(cycle.getGeometrie()));\n            // CarteTopo.logger.debug(\"Added as interior\");\n            // } else {\n\n            // Correction Mickael\n            IGeometry geom = faceInfinie.getGeometrie().difference(holePolygon);\n            faceInfinie.setGeometrie((IPolygon) geom);\n\n            // Former code :\n            // IGeometry geom = face.getGeometrie().difference(holePolygon);\n            // faceInfinie.setGeometrie((IPolygon) geom);\n\n            // CarteTopo.logger.debug(\"Removed from infinite face \"\n            // + newPolygon);\n            // }\n          }\n          /*\n           * IRing trou = new GM_Ring(cycle.getGeometrie()); if\n           * (!trou.coord().isEmpty() && trou.coord().size() > 3 &&\n           * trou.isValid()) { if (face.getGeometrie().getInterior().isEmpty())\n           * { face.getGeometrie().addInterior(trou); } else { // union des\n           * trous IPolygon polygonHole = new GM_Polygon(trou); List<IPolygon>\n           * trous = new ArrayList<IPolygon>(); for (IRing ring :\n           * face.getGeometrie().getInterior()) { trous.add(new\n           * GM_Polygon(ring)); } // ajout du nouveau trou \u00e0 la liste\n           * trous.add(polygonHole); if (CarteTopo.logger.isDebugEnabled()) {\n           * CarteTopo.logger.debug(\"Union de \" + trous.size() + \" trous\"); if\n           * (CarteTopo.logger.isDebugEnabled()) { for (IPolygon t : trous) {\n           * CarteTopo.logger.debug(\"trou \" + t); } } } try { IGeometry union =\n           * JtsAlgorithms.union(trous); if (union.isPolygon()) { GM_Polygon\n           * polygon = (GM_Polygon) union; // suppression des trous existants\n           * face.getGeometrie().getInterior().clear();\n           * face.getGeometrie().addInterior(polygon.getExterior()); } else { if\n           * (union.isMultiSurface()) { IMultiSurface<IPolygon> multipolygon =\n           * (IMultiSurface<IPolygon>) union; // suppression des trous existants\n           * face.getGeometrie().getInterior().clear(); for (IPolygon polygon :\n           * multipolygon) {\n           * face.getGeometrie().addInterior(polygon.getExterior()); } } else {\n           * CarteTopo.logger.error(union); } } } catch (Exception e) {\n           * CarteTopo.logger.debug(\"Cycle \" + cycle.getGeometrie());\n           * CarteTopo.logger.debug(cycle.getArcs().size() + \" arcs\"); for (Arc\n           * arc : cycle.getArcs()) { CarteTopo.logger.debug(\"arc \" + arc); }\n           * CarteTopo.logger.debug(\"face \" + face); } } }\n           */\n        }\n      }\n      this.fireActionPerformed(new ActionEvent(this, 3,\n          I18N.getString(\"CarteTopo.FaceTopologyCycle\"), iteration++)); //$NON-NLS-1$\n    }\n    // d\u00e9tection des arcs pendants ie des culs-de-sac de la face Infinie\n    if (this.buildInfiniteFace && faceInfinie != null) {\n      for (Arc arcCourant : faceInfinie.arcs()) {\n        if ((arcCourant.getFaceDroite() == null)\n            || (arcCourant.getFaceGauche() == null)) {\n          continue;\n        }\n        if (arcCourant.getFaceDroite() == arcCourant.getFaceGauche()) {\n          arcCourant.setPendant(true);\n        }\n      }\n    }\n    this.fireActionPerformed(\n        new ActionEvent(this, 4, I18N.getString(\"CarteTopo.FaceTopologyEnd\"))); //$NON-NLS-1$\n    // d\u00e9tection des arcs pendants ie des culs-de-sac de la face Infinie\n    for (Arc arcCourant : this.getPopArcs()) {\n      if (arcCourant.getFaceDroite() == null) {\n        arcCourant.setFaceDroite(faceInfinie);\n        if (arcCourant.getFaceGauche() == faceInfinie) {\n          arcCourant.setPendant(true);\n        }\n      }\n      if (arcCourant.getFaceGauche() == null) {\n        arcCourant.setFaceGauche(faceInfinie);\n        if (arcCourant.getFaceDroite() == faceInfinie) {\n          arcCourant.setPendant(true);\n        }\n      }\n    }\n  }", "signature": "void creeTopologieFaces()", "full_signature": "@SuppressWarnings(\"unchecked\") public void creeTopologieFaces()", "class_method_signature": "CarteTopo.creeTopologieFaces()", "testcase": false, "constructor": false, "invocations": ["getPopFaces", "fireActionPerformed", "getString", "size", "getPopArcs", "getPopArcs", "contains", "cycle", "error", "getString", "getId", "getArcs", "getOrientationsArcs", "getGeometrie", "isSimple", "construireGeometrieCycleExterieur", "size", "getGeometrie", "get", "isCCW", "getGeometrie", "add", "nouvelElement", "getGeometrie", "debug", "getGeometrie", "sizeControlPoint", "isCCW", "add", "nouvelElement", "debug", "getGeometrie", "marquerCycle", "contains", "cycle", "isDebugEnabled", "debug", "getString", "getId", "getArcs", "getOrientationsArcs", "getGeometrie", "isSimple", "construireGeometrieCycleExterieur", "size", "getGeometrie", "get", "isCCW", "getGeometrie", "add", "nouvelElement", "getGeometrie", "debug", "getGeometrie", "sizeControlPoint", "isCCW", "add", "nouvelElement", "isDebugEnabled", "debug", "getGeometrie", "marquerCycle", "fireActionPerformed", "getString", "getPopArcs", "getFaceDroite", "getFaceGauche", "getFaceDroite", "getFaceGauche", "setPendant", "initSpatialIndex", "getPopFaces", "envelope", "getPopArcs", "nouvelElement", "getPopFaces", "minX", "maxX", "minY", "maxY", "setInfinite", "fireActionPerformed", "getString", "size", "isAGauche", "booleanValue", "get", "getOrientationsArcs", "isAGauche", "booleanValue", "get", "getOrientationsArcs", "getFaceGauche", "get", "getArcs", "getFaceDroite", "get", "getArcs", "getGeometrie", "numPoints", "isValid", "error", "select", "getPopFaces", "isEmpty", "removeAll", "getListeFacesInterieuresDuCycle", "iterator", "hasNext", "contains", "getGeometrie", "next", "remove", "isEmpty", "iterator", "next", "hasNext", "next", "area", "getGeometrie", "area", "getGeometrie", "marquerCycle", "sizeControlPoint", "getGeometrie", "buffer", "getGeometrie", "isEmpty", "coord", "size", "coord", "isValid", "difference", "getGeometrie", "setGeometrie", "fireActionPerformed", "getString", "arcs", "getFaceDroite", "getFaceGauche", "getFaceDroite", "getFaceGauche", "setPendant", "fireActionPerformed", "getString", "getPopArcs", "getFaceDroite", "setFaceDroite", "getFaceGauche", "setPendant", "getFaceGauche", "setFaceGauche", "getFaceDroite", "setPendant"]}, "repository": {"repo_id": 56582318, "url": "https://github.com/IGNF/geoxygene", "language": "Java", "is_fork": false, "fork_count": 14, "stargazer_count": 22, "size": 323511, "license": "licensed"}}