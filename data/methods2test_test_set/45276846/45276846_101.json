{"test_class": {"identifier": "NettyHttpServiceClientTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static VerificationHost HOST;", "modifier": "private static", "type": "VerificationHost", "declarator": "HOST", "var_name": "HOST"}, {"original_string": "private static final boolean ENABLE_AUTH = false;", "modifier": "private static final", "type": "boolean", "declarator": "ENABLE_AUTH = false", "var_name": "ENABLE_AUTH"}, {"original_string": "private static final String SAMPLE_EMAIL = \"sample@vmware.com\";", "modifier": "private static final", "type": "String", "declarator": "SAMPLE_EMAIL = \"sample@vmware.com\"", "var_name": "SAMPLE_EMAIL"}, {"original_string": "private static final String SAMPLE_PASSWORD = \"password\";", "modifier": "private static final", "type": "String", "declarator": "SAMPLE_PASSWORD = \"password\"", "var_name": "SAMPLE_PASSWORD"}, {"original_string": "private VerificationHost host;", "modifier": "private", "type": "VerificationHost", "declarator": "host", "var_name": "host"}, {"original_string": "public String testURI;", "modifier": "public", "type": "String", "declarator": "testURI", "var_name": "testURI"}, {"original_string": "public int requestCount = 16;", "modifier": "public", "type": "int", "declarator": "requestCount = 16", "var_name": "requestCount"}, {"original_string": "public int serviceCount = 32;", "modifier": "public", "type": "int", "declarator": "serviceCount = 32", "var_name": "serviceCount"}, {"original_string": "public int connectionCount = 32;", "modifier": "public", "type": "int", "declarator": "connectionCount = 32", "var_name": "connectionCount"}, {"original_string": "public int operationTimeout = 0;", "modifier": "public", "type": "int", "declarator": "operationTimeout = 0", "var_name": "operationTimeout"}, {"original_string": "public int iterationCount = 1;", "modifier": "public", "type": "int", "declarator": "iterationCount = 1", "var_name": "iterationCount"}, {"original_string": "@Rule\n    public TestResults testResults = new TestResults();", "modifier": "@Rule\n    public", "type": "TestResults", "declarator": "testResults = new TestResults()", "var_name": "testResults"}], "file": "xenon-common/src/test/java/com/vmware/xenon/common/http/netty/NettyHttpServiceClientTest.java"}, "test_case": {"identifier": "throughputPostRemote", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void throughputPostRemote() throws Throwable {\n        if (this.testURI == null) {\n            return;\n        }\n        this.host.setOperationTimeOutMicros(TimeUnit.SECONDS.toMicros(120));\n        this.host.setTimeoutSeconds(120);\n        this.host.log(\n                \"Starting HTTP POST stress test against %s, request count: %d, connection limit: %d\",\n                this.testURI, this.requestCount, this.connectionCount);\n\n        long start = System.nanoTime();\n        ExampleServiceState body = new ExampleServiceState();\n        body.name = UUID.randomUUID().toString();\n        this.host.sendHttpRequest(this.host.getClient(), this.testURI, Utils.toJson(body),\n                this.requestCount);\n        long end = System.nanoTime();\n        double thpt = this.requestCount / ((end - start) / (double) TimeUnit.SECONDS.toNanos(1));\n        this.host.log(\"Connection limit: %d, Request count: %d, Requests per second:%f\",\n                this.connectionCount, this.requestCount, thpt);\n    }", "signature": "void throughputPostRemote()", "full_signature": "@Test public void throughputPostRemote()", "class_method_signature": "NettyHttpServiceClientTest.throughputPostRemote()", "testcase": true, "constructor": false, "invocations": ["setOperationTimeOutMicros", "toMicros", "setTimeoutSeconds", "log", "nanoTime", "toString", "randomUUID", "sendHttpRequest", "getClient", "toJson", "nanoTime", "toNanos", "log"]}, "focal_class": {"identifier": "NettyHttpServiceClient", "superclass": "", "interfaces": "implements ServiceClient", "fields": [{"original_string": "public static final int DEFAULT_CONNECTIONS_PER_HOST = ServiceClient.DEFAULT_CONNECTION_LIMIT_PER_HOST;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_CONNECTIONS_PER_HOST = ServiceClient.DEFAULT_CONNECTION_LIMIT_PER_HOST", "var_name": "DEFAULT_CONNECTIONS_PER_HOST"}, {"original_string": "public static final Logger LOGGER = Logger.getLogger(ServiceClient.class\n            .getName());", "modifier": "public static final", "type": "Logger", "declarator": "LOGGER = Logger.getLogger(ServiceClient.class\n            .getName())", "var_name": "LOGGER"}, {"original_string": "private static final String ENV_VAR_NAME_HTTP_PROXY = \"http_proxy\";", "modifier": "private static final", "type": "String", "declarator": "ENV_VAR_NAME_HTTP_PROXY = \"http_proxy\"", "var_name": "ENV_VAR_NAME_HTTP_PROXY"}, {"original_string": "static final AsciiString TRANSACTION_ID_HEADER_ASCII = new AsciiString(\n            Operation.TRANSACTION_ID_HEADER);", "modifier": "static final", "type": "AsciiString", "declarator": "TRANSACTION_ID_HEADER_ASCII = new AsciiString(\n            Operation.TRANSACTION_ID_HEADER)", "var_name": "TRANSACTION_ID_HEADER_ASCII"}, {"original_string": "static final AsciiString CONTEXT_ID_HEADER_ASCII = new AsciiString(\n            Operation.CONTEXT_ID_HEADER);", "modifier": "static final", "type": "AsciiString", "declarator": "CONTEXT_ID_HEADER_ASCII = new AsciiString(\n            Operation.CONTEXT_ID_HEADER)", "var_name": "CONTEXT_ID_HEADER_ASCII"}, {"original_string": "static final AsciiString AUTH_TOKEN_HEADER_ASCII = new AsciiString(\n            Operation.REQUEST_AUTH_TOKEN_HEADER);", "modifier": "static final", "type": "AsciiString", "declarator": "AUTH_TOKEN_HEADER_ASCII = new AsciiString(\n            Operation.REQUEST_AUTH_TOKEN_HEADER)", "var_name": "AUTH_TOKEN_HEADER_ASCII"}, {"original_string": "static final AsciiString DEFAULT_MEDIA_TYPE_ASCII = new AsciiString(\n            Operation.MEDIA_TYPE_EVERYTHING_WILDCARDS);", "modifier": "static final", "type": "AsciiString", "declarator": "DEFAULT_MEDIA_TYPE_ASCII = new AsciiString(\n            Operation.MEDIA_TYPE_EVERYTHING_WILDCARDS)", "var_name": "DEFAULT_MEDIA_TYPE_ASCII"}, {"original_string": "static final AsciiString PRAGMA_DIRECTIVE_REPLICATED_ASCII = new AsciiString(\n            Operation.PRAGMA_DIRECTIVE_REPLICATED);", "modifier": "static final", "type": "AsciiString", "declarator": "PRAGMA_DIRECTIVE_REPLICATED_ASCII = new AsciiString(\n            Operation.PRAGMA_DIRECTIVE_REPLICATED)", "var_name": "PRAGMA_DIRECTIVE_REPLICATED_ASCII"}, {"original_string": "static final AsciiString MEDIA_TYPE_JSON_ASCII = new AsciiString(\n            Operation.MEDIA_TYPE_APPLICATION_JSON);", "modifier": "static final", "type": "AsciiString", "declarator": "MEDIA_TYPE_JSON_ASCII = new AsciiString(\n            Operation.MEDIA_TYPE_APPLICATION_JSON)", "var_name": "MEDIA_TYPE_JSON_ASCII"}, {"original_string": "static final AsciiString MEDIA_TYPE_KRYO_OCTET_STREAM_ASCII = new AsciiString(\n            Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM);", "modifier": "static final", "type": "AsciiString", "declarator": "MEDIA_TYPE_KRYO_OCTET_STREAM_ASCII = new AsciiString(\n            Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)", "var_name": "MEDIA_TYPE_KRYO_OCTET_STREAM_ASCII"}, {"original_string": "private static final int MEDIA_TYPE_APPLICATION_PREFIX_LENGTH = 12;", "modifier": "private static final", "type": "int", "declarator": "MEDIA_TYPE_APPLICATION_PREFIX_LENGTH = 12", "var_name": "MEDIA_TYPE_APPLICATION_PREFIX_LENGTH"}, {"original_string": "private URI httpProxy;", "modifier": "private", "type": "URI", "declarator": "httpProxy", "var_name": "httpProxy"}, {"original_string": "private AsciiString userAgentAscii;", "modifier": "private", "type": "AsciiString", "declarator": "userAgentAscii", "var_name": "userAgentAscii"}, {"original_string": "private NettyChannelPool sslChannelPool;", "modifier": "private", "type": "NettyChannelPool", "declarator": "sslChannelPool", "var_name": "sslChannelPool"}, {"original_string": "private NettyChannelPool channelPool;", "modifier": "private", "type": "NettyChannelPool", "declarator": "channelPool", "var_name": "channelPool"}, {"original_string": "private NettyChannelPool http2SslChannelPool;", "modifier": "private", "type": "NettyChannelPool", "declarator": "http2SslChannelPool", "var_name": "http2SslChannelPool"}, {"original_string": "private NettyChannelPool http2ChannelPool;", "modifier": "private", "type": "NettyChannelPool", "declarator": "http2ChannelPool", "var_name": "http2ChannelPool"}, {"original_string": "private SortedMap<Long, Operation> pendingRequests = new ConcurrentSkipListMap<>();", "modifier": "private", "type": "SortedMap<Long, Operation>", "declarator": "pendingRequests = new ConcurrentSkipListMap<>()", "var_name": "pendingRequests"}, {"original_string": "private ScheduledExecutorService scheduledExecutor;", "modifier": "private", "type": "ScheduledExecutorService", "declarator": "scheduledExecutor", "var_name": "scheduledExecutor"}, {"original_string": "private ExecutorService executor;", "modifier": "private", "type": "ExecutorService", "declarator": "executor", "var_name": "executor"}, {"original_string": "private SslContext http2SslContext;", "modifier": "private", "type": "SslContext", "declarator": "http2SslContext", "var_name": "http2SslContext"}, {"original_string": "private SSLContext sslContext;", "modifier": "private", "type": "SSLContext", "declarator": "sslContext", "var_name": "sslContext"}, {"original_string": "private ServiceHost host;", "modifier": "private", "type": "ServiceHost", "declarator": "host", "var_name": "host"}, {"original_string": "private CookieJar cookieJar = new CookieJar();", "modifier": "private", "type": "CookieJar", "declarator": "cookieJar = new CookieJar()", "var_name": "cookieJar"}, {"original_string": "private boolean isStarted;", "modifier": "private", "type": "boolean", "declarator": "isStarted", "var_name": "isStarted"}, {"original_string": "private boolean warnHttp2DisablingConnectionSharing = false;", "modifier": "private", "type": "boolean", "declarator": "warnHttp2DisablingConnectionSharing = false", "var_name": "warnHttp2DisablingConnectionSharing"}, {"original_string": "private final Object startSync = new Object();", "modifier": "private final", "type": "Object", "declarator": "startSync = new Object()", "var_name": "startSync"}], "methods": [{"identifier": "create", "parameters": "(String userAgent,\n            ExecutorService executor,\n            ScheduledExecutorService scheduledExecutor)", "modifiers": "public static", "return": "ServiceClient", "signature": "ServiceClient create(String userAgent,\n            ExecutorService executor,\n            ScheduledExecutorService scheduledExecutor)", "full_signature": "public static ServiceClient create(String userAgent,\n            ExecutorService executor,\n            ScheduledExecutorService scheduledExecutor)", "class_method_signature": "NettyHttpServiceClient.create(String userAgent,\n            ExecutorService executor,\n            ScheduledExecutorService scheduledExecutor)", "testcase": false, "constructor": false}, {"identifier": "create", "parameters": "(String userAgent,\n            ExecutorService executor,\n            ScheduledExecutorService scheduledExecutor,\n            ServiceHost host)", "modifiers": "public static", "return": "ServiceClient", "signature": "ServiceClient create(String userAgent,\n            ExecutorService executor,\n            ScheduledExecutorService scheduledExecutor,\n            ServiceHost host)", "full_signature": "public static ServiceClient create(String userAgent,\n            ExecutorService executor,\n            ScheduledExecutorService scheduledExecutor,\n            ServiceHost host)", "class_method_signature": "NettyHttpServiceClient.create(String userAgent,\n            ExecutorService executor,\n            ScheduledExecutorService scheduledExecutor,\n            ServiceHost host)", "testcase": false, "constructor": false}, {"identifier": "buildThreadTag", "parameters": "()", "modifiers": "private", "return": "String", "signature": "String buildThreadTag()", "full_signature": "private String buildThreadTag()", "class_method_signature": "NettyHttpServiceClient.buildThreadTag()", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void start()", "full_signature": "@Override public void start()", "class_method_signature": "NettyHttpServiceClient.start()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void stop()", "full_signature": "@Override public void stop()", "class_method_signature": "NettyHttpServiceClient.stop()", "testcase": false, "constructor": false}, {"identifier": "setHttpProxy", "parameters": "(URI proxy)", "modifiers": "public", "return": "ServiceClient", "signature": "ServiceClient setHttpProxy(URI proxy)", "full_signature": "public ServiceClient setHttpProxy(URI proxy)", "class_method_signature": "NettyHttpServiceClient.setHttpProxy(URI proxy)", "testcase": false, "constructor": false}, {"identifier": "send", "parameters": "(Operation op)", "modifiers": "@Override public", "return": "void", "signature": "void send(Operation op)", "full_signature": "@Override public void send(Operation op)", "class_method_signature": "NettyHttpServiceClient.send(Operation op)", "testcase": false, "constructor": false}, {"identifier": "sendRequest", "parameters": "(Operation op)", "modifiers": "@Override public", "return": "void", "signature": "void sendRequest(Operation op)", "full_signature": "@Override public void sendRequest(Operation op)", "class_method_signature": "NettyHttpServiceClient.sendRequest(Operation op)", "testcase": false, "constructor": false}, {"identifier": "setExpiration", "parameters": "(Operation op)", "modifiers": "private", "return": "void", "signature": "void setExpiration(Operation op)", "full_signature": "private void setExpiration(Operation op)", "class_method_signature": "NettyHttpServiceClient.setExpiration(Operation op)", "testcase": false, "constructor": false}, {"identifier": "setCookies", "parameters": "(Operation clone)", "modifiers": "private", "return": "void", "signature": "void setCookies(Operation clone)", "full_signature": "private void setCookies(Operation clone)", "class_method_signature": "NettyHttpServiceClient.setCookies(Operation clone)", "testcase": false, "constructor": false}, {"identifier": "startTracking", "parameters": "(Operation op)", "modifiers": "private", "return": "void", "signature": "void startTracking(Operation op)", "full_signature": "private void startTracking(Operation op)", "class_method_signature": "NettyHttpServiceClient.startTracking(Operation op)", "testcase": false, "constructor": false}, {"identifier": "stopTracking", "parameters": "(Operation op)", "modifiers": "", "return": "void", "signature": "void stopTracking(Operation op)", "full_signature": " void stopTracking(Operation op)", "class_method_signature": "NettyHttpServiceClient.stopTracking(Operation op)", "testcase": false, "constructor": false}, {"identifier": "updateCookieJarFromResponseHeaders", "parameters": "(Operation op)", "modifiers": "private", "return": "void", "signature": "void updateCookieJarFromResponseHeaders(Operation op)", "full_signature": "private void updateCookieJarFromResponseHeaders(Operation op)", "class_method_signature": "NettyHttpServiceClient.updateCookieJarFromResponseHeaders(Operation op)", "testcase": false, "constructor": false}, {"identifier": "sendRemote", "parameters": "(Operation op)", "modifiers": "private", "return": "void", "signature": "void sendRemote(Operation op)", "full_signature": "private void sendRemote(Operation op)", "class_method_signature": "NettyHttpServiceClient.sendRemote(Operation op)", "testcase": false, "constructor": false}, {"identifier": "connectChannel", "parameters": "(NettyChannelPool pool, Operation op,\n            String remoteHost, int port)", "modifiers": "private", "return": "void", "signature": "void connectChannel(NettyChannelPool pool, Operation op,\n            String remoteHost, int port)", "full_signature": "private void connectChannel(NettyChannelPool pool, Operation op,\n            String remoteHost, int port)", "class_method_signature": "NettyHttpServiceClient.connectChannel(NettyChannelPool pool, Operation op,\n            String remoteHost, int port)", "testcase": false, "constructor": false}, {"identifier": "sendHttpRequest", "parameters": "(Operation op)", "modifiers": "private", "return": "void", "signature": "void sendHttpRequest(Operation op)", "full_signature": "private void sendHttpRequest(Operation op)", "class_method_signature": "NettyHttpServiceClient.sendHttpRequest(Operation op)", "testcase": false, "constructor": false}, {"identifier": "setAsciiContentType", "parameters": "(Operation op, HttpHeaders httpHeaders)", "modifiers": "private", "return": "void", "signature": "void setAsciiContentType(Operation op, HttpHeaders httpHeaders)", "full_signature": "private void setAsciiContentType(Operation op, HttpHeaders httpHeaders)", "class_method_signature": "NettyHttpServiceClient.setAsciiContentType(Operation op, HttpHeaders httpHeaders)", "testcase": false, "constructor": false}, {"identifier": "logRequestFraming", "parameters": "(Operation op, NettyFullHttpRequest request)", "modifiers": "private", "return": "void", "signature": "void logRequestFraming(Operation op, NettyFullHttpRequest request)", "full_signature": "private void logRequestFraming(Operation op, NettyFullHttpRequest request)", "class_method_signature": "NettyHttpServiceClient.logRequestFraming(Operation op, NettyFullHttpRequest request)", "testcase": false, "constructor": false}, {"identifier": "toHttpMethod", "parameters": "(Action a)", "modifiers": "private static", "return": "HttpMethod", "signature": "HttpMethod toHttpMethod(Action a)", "full_signature": "private static HttpMethod toHttpMethod(Action a)", "class_method_signature": "NettyHttpServiceClient.toHttpMethod(Action a)", "testcase": false, "constructor": false}, {"identifier": "failWithTimeout", "parameters": "(Operation op, Object originalBody)", "modifiers": "private", "return": "void", "signature": "void failWithTimeout(Operation op, Object originalBody)", "full_signature": "private void failWithTimeout(Operation op, Object originalBody)", "class_method_signature": "NettyHttpServiceClient.failWithTimeout(Operation op, Object originalBody)", "testcase": false, "constructor": false}, {"identifier": "fail", "parameters": "(Throwable e, Operation op, Object originalBody)", "modifiers": "private", "return": "void", "signature": "void fail(Throwable e, Operation op, Object originalBody)", "full_signature": "private void fail(Throwable e, Operation op, Object originalBody)", "class_method_signature": "NettyHttpServiceClient.fail(Throwable e, Operation op, Object originalBody)", "testcase": false, "constructor": false}, {"identifier": "validateOperation", "parameters": "(Operation op)", "modifiers": "private static", "return": "boolean", "signature": "boolean validateOperation(Operation op)", "full_signature": "private static boolean validateOperation(Operation op)", "class_method_signature": "NettyHttpServiceClient.validateOperation(Operation op)", "testcase": false, "constructor": false}, {"identifier": "handleMaintenance", "parameters": "(Operation op)", "modifiers": "@Override public", "return": "void", "signature": "void handleMaintenance(Operation op)", "full_signature": "@Override public void handleMaintenance(Operation op)", "class_method_signature": "NettyHttpServiceClient.handleMaintenance(Operation op)", "testcase": false, "constructor": false}, {"identifier": "failExpiredRequests", "parameters": "(long now)", "modifiers": "private", "return": "void", "signature": "void failExpiredRequests(long now)", "full_signature": "private void failExpiredRequests(long now)", "class_method_signature": "NettyHttpServiceClient.failExpiredRequests(long now)", "testcase": false, "constructor": false}, {"identifier": "setPendingRequestQueueLimit", "parameters": "(int limit)", "modifiers": "@Override public", "return": "ServiceClient", "signature": "ServiceClient setPendingRequestQueueLimit(int limit)", "full_signature": "@Override public ServiceClient setPendingRequestQueueLimit(int limit)", "class_method_signature": "NettyHttpServiceClient.setPendingRequestQueueLimit(int limit)", "testcase": false, "constructor": false}, {"identifier": "getPendingRequestQueueLimit", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getPendingRequestQueueLimit()", "full_signature": "@Override public int getPendingRequestQueueLimit()", "class_method_signature": "NettyHttpServiceClient.getPendingRequestQueueLimit()", "testcase": false, "constructor": false}, {"identifier": "setConnectionLimitPerTag", "parameters": "(String tag, int limit)", "modifiers": "@Override public", "return": "ServiceClient", "signature": "ServiceClient setConnectionLimitPerTag(String tag, int limit)", "full_signature": "@Override public ServiceClient setConnectionLimitPerTag(String tag, int limit)", "class_method_signature": "NettyHttpServiceClient.setConnectionLimitPerTag(String tag, int limit)", "testcase": false, "constructor": false}, {"identifier": "getConnectionLimitPerTag", "parameters": "(String tag)", "modifiers": "@Override public", "return": "int", "signature": "int getConnectionLimitPerTag(String tag)", "full_signature": "@Override public int getConnectionLimitPerTag(String tag)", "class_method_signature": "NettyHttpServiceClient.getConnectionLimitPerTag(String tag)", "testcase": false, "constructor": false}, {"identifier": "setHttp2SslContext", "parameters": "(SslContext context)", "modifiers": "public", "return": "ServiceClient", "signature": "ServiceClient setHttp2SslContext(SslContext context)", "full_signature": "public ServiceClient setHttp2SslContext(SslContext context)", "class_method_signature": "NettyHttpServiceClient.setHttp2SslContext(SslContext context)", "testcase": false, "constructor": false}, {"identifier": "getHttp2SslContext", "parameters": "()", "modifiers": "public", "return": "SslContext", "signature": "SslContext getHttp2SslContext()", "full_signature": "public SslContext getHttp2SslContext()", "class_method_signature": "NettyHttpServiceClient.getHttp2SslContext()", "testcase": false, "constructor": false}, {"identifier": "setSSLContext", "parameters": "(SSLContext context)", "modifiers": "@Override public", "return": "ServiceClient", "signature": "ServiceClient setSSLContext(SSLContext context)", "full_signature": "@Override public ServiceClient setSSLContext(SSLContext context)", "class_method_signature": "NettyHttpServiceClient.setSSLContext(SSLContext context)", "testcase": false, "constructor": false}, {"identifier": "getSSLContext", "parameters": "()", "modifiers": "@Override public", "return": "SSLContext", "signature": "SSLContext getSSLContext()", "full_signature": "@Override public SSLContext getSSLContext()", "class_method_signature": "NettyHttpServiceClient.getSSLContext()", "testcase": false, "constructor": false}, {"identifier": "getChannelPool", "parameters": "()", "modifiers": "public", "return": "NettyChannelPool", "signature": "NettyChannelPool getChannelPool()", "full_signature": "public NettyChannelPool getChannelPool()", "class_method_signature": "NettyHttpServiceClient.getChannelPool()", "testcase": false, "constructor": false}, {"identifier": "getHttp2ChannelPool", "parameters": "()", "modifiers": "public", "return": "NettyChannelPool", "signature": "NettyChannelPool getHttp2ChannelPool()", "full_signature": "public NettyChannelPool getHttp2ChannelPool()", "class_method_signature": "NettyHttpServiceClient.getHttp2ChannelPool()", "testcase": false, "constructor": false}, {"identifier": "getSslChannelPool", "parameters": "()", "modifiers": "public", "return": "NettyChannelPool", "signature": "NettyChannelPool getSslChannelPool()", "full_signature": "public NettyChannelPool getSslChannelPool()", "class_method_signature": "NettyHttpServiceClient.getSslChannelPool()", "testcase": false, "constructor": false}, {"identifier": "getInUseHttp2SslContext", "parameters": "(String tag, String host, int port)", "modifiers": "public", "return": "NettyChannelContext", "signature": "NettyChannelContext getInUseHttp2SslContext(String tag, String host, int port)", "full_signature": "public NettyChannelContext getInUseHttp2SslContext(String tag, String host, int port)", "class_method_signature": "NettyHttpServiceClient.getInUseHttp2SslContext(String tag, String host, int port)", "testcase": false, "constructor": false}, {"identifier": "getInUseHttp2Context", "parameters": "(String tag, String host, int port)", "modifiers": "public", "return": "NettyChannelContext", "signature": "NettyChannelContext getInUseHttp2Context(String tag, String host, int port)", "full_signature": "public NettyChannelContext getInUseHttp2Context(String tag, String host, int port)", "class_method_signature": "NettyHttpServiceClient.getInUseHttp2Context(String tag, String host, int port)", "testcase": false, "constructor": false}, {"identifier": "getConnectionPoolMetrics", "parameters": "(boolean http2)", "modifiers": "@Override public", "return": "ConnectionPoolMetrics", "signature": "ConnectionPoolMetrics getConnectionPoolMetrics(boolean http2)", "full_signature": "@Override public ConnectionPoolMetrics getConnectionPoolMetrics(boolean http2)", "class_method_signature": "NettyHttpServiceClient.getConnectionPoolMetrics(boolean http2)", "testcase": false, "constructor": false}, {"identifier": "getPoolMetrics", "parameters": "(NettyChannelPool p1, NettyChannelPool p2)", "modifiers": "private", "return": "ConnectionPoolMetrics", "signature": "ConnectionPoolMetrics getPoolMetrics(NettyChannelPool p1, NettyChannelPool p2)", "full_signature": "private ConnectionPoolMetrics getPoolMetrics(NettyChannelPool p1, NettyChannelPool p2)", "class_method_signature": "NettyHttpServiceClient.getPoolMetrics(NettyChannelPool p1, NettyChannelPool p2)", "testcase": false, "constructor": false}, {"identifier": "getConnectionPoolMetricsPerTag", "parameters": "(String tag)", "modifiers": "@Override public", "return": "ConnectionPoolMetrics", "signature": "ConnectionPoolMetrics getConnectionPoolMetricsPerTag(String tag)", "full_signature": "@Override public ConnectionPoolMetrics getConnectionPoolMetricsPerTag(String tag)", "class_method_signature": "NettyHttpServiceClient.getConnectionPoolMetricsPerTag(String tag)", "testcase": false, "constructor": false}, {"identifier": "getInUseContextCount", "parameters": "(String tag, String host, int port)", "modifiers": "public", "return": "int", "signature": "int getInUseContextCount(String tag, String host, int port)", "full_signature": "public int getInUseContextCount(String tag, String host, int port)", "class_method_signature": "NettyHttpServiceClient.getInUseContextCount(String tag, String host, int port)", "testcase": false, "constructor": false}, {"identifier": "clearCookieJar", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void clearCookieJar()", "full_signature": "public void clearCookieJar()", "class_method_signature": "NettyHttpServiceClient.clearCookieJar()", "testcase": false, "constructor": false}, {"identifier": "getRequestPayloadSizeLimit", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getRequestPayloadSizeLimit()", "full_signature": "@Override public int getRequestPayloadSizeLimit()", "class_method_signature": "NettyHttpServiceClient.getRequestPayloadSizeLimit()", "testcase": false, "constructor": false}, {"identifier": "setRequestPayloadSizeLimit", "parameters": "(int limit)", "modifiers": "@Override public", "return": "ServiceClient", "signature": "ServiceClient setRequestPayloadSizeLimit(int limit)", "full_signature": "@Override public ServiceClient setRequestPayloadSizeLimit(int limit)", "class_method_signature": "NettyHttpServiceClient.setRequestPayloadSizeLimit(int limit)", "testcase": false, "constructor": false}], "file": "xenon-common/src/main/java/com/vmware/xenon/common/http/netty/NettyHttpServiceClient.java"}, "focal_method": {"identifier": "sendHttpRequest", "parameters": "(Operation op)", "modifiers": "private", "return": "void", "body": "private void sendHttpRequest(Operation op) {\n        final Object originalBody = op.getBodyRaw();\n        try {\n            byte[] body = Utils.encodeBody(op, true);\n            if (op.getContentLength() > getRequestPayloadSizeLimit()) {\n                String error = String.format(\"Content length %d, limit is %d\",\n                        op.getContentLength(), getRequestPayloadSizeLimit());\n                Exception e = new IllegalArgumentException(error);\n                op.setBody(ServiceErrorResponse.create(e, Operation.STATUS_CODE_BAD_REQUEST));\n                fail(e, op, originalBody);\n                return;\n            }\n\n            String pathAndQuery;\n            String path = op.getUri().getPath();\n            String query = op.getUri().getRawQuery();\n            String userInfo = op.getUri().getRawUserInfo();\n            path = path == null || path.isEmpty() ? \"/\" : path;\n            if (query != null) {\n                pathAndQuery = path + \"?\" + query;\n            } else {\n                pathAndQuery = path;\n            }\n\n            boolean useHttp2 = op.isConnectionSharing();\n            if (this.httpProxy != null || useHttp2 || userInfo != null) {\n                pathAndQuery = op.getUri().toString();\n            }\n\n            NettyFullHttpRequest request = null;\n            HttpMethod method = toHttpMethod(op.getAction());\n            if (body == null || body.length == 0) {\n                request = new NettyFullHttpRequest(HttpVersion.HTTP_1_1, method, pathAndQuery,\n                        Unpooled.EMPTY_BUFFER, false);\n            } else {\n                ByteBuf content = Unpooled.wrappedBuffer(body, 0, (int) op.getContentLength());\n                request = new NettyFullHttpRequest(HttpVersion.HTTP_1_1, method, pathAndQuery,\n                        content, false);\n            }\n\n            HttpHeaders httpHeaders = request.headers();\n\n            /*\n             * NOTE: Pay close attention to calls that access the operation request headers, since\n             * they will cause a memory allocation. We avoid the allocation by first checking if\n             * the operation has any custom headers to begin with, then we check for the specific\n             * header\n             */\n            boolean hasRequestHeaders = op.hasRequestHeaders();\n\n            if (useHttp2) {\n                // when operation is cloned, it may contain original streamId header. remove it.\n                if (hasRequestHeaders) {\n                    op.getAndRemoveRequestHeaderAsIs(Operation.STREAM_ID_HEADER);\n                }\n                // We set the operation so that once a streamId is assigned, we can record\n                // the correspondence between the streamId and operation: this will let us\n                // handle responses properly later.\n                request.setOperation(op);\n            }\n\n            String pragmaValue = op.getAndRemoveRequestHeaderAsIs(Operation.PRAGMA_HEADER);\n            String acceptValue = op.getAndRemoveRequestHeaderAsIs(Operation.ACCEPT_HEADER);\n            String authTokenValue = op\n                    .getAndRemoveRequestHeaderAsIs(Operation.REQUEST_AUTH_TOKEN_HEADER);\n\n            if (op.isFromReplication() && pragmaValue == null) {\n                httpHeaders.add(HttpHeaderNames.PRAGMA, PRAGMA_DIRECTIVE_REPLICATED_ASCII);\n            } else if (pragmaValue != null) {\n                httpHeaders.add(HttpHeaderNames.PRAGMA, pragmaValue);\n            }\n\n            if (op.getTransactionId() != null) {\n                httpHeaders.add(TRANSACTION_ID_HEADER_ASCII, op.getTransactionId());\n            }\n\n            if (op.getContextId() != null) {\n                httpHeaders.add(CONTEXT_ID_HEADER_ASCII, op.getContextId());\n            }\n\n            hasRequestHeaders = op.hasRequestHeaders();\n\n            String connectionHeaderValue = op.getRequestHeaderAsIs(Operation.CONNECTION_HEADER);\n\n            boolean isXenonToXenon = op.isFromReplication() || op.isForwarded();\n            if (hasRequestHeaders) {\n                // remove all headers that we will set explicitly\n                op.getAndRemoveRequestHeaderAsIs(Operation.CONTENT_LENGTH_HEADER);\n                op.getAndRemoveRequestHeaderAsIs(Operation.CONTENT_TYPE_HEADER);\n                op.getAndRemoveRequestHeaderAsIs(Operation.CONNECTION_HEADER);\n                op.getAndRemoveRequestHeaderAsIs(Operation.REFERER_HEADER);\n                op.getAndRemoveRequestHeaderAsIs(Operation.HOST_HEADER);\n                op.getAndRemoveRequestHeaderAsIs(Operation.USER_AGENT_HEADER);\n                hasRequestHeaders = op.hasRequestHeaders();\n            }\n\n            if (hasRequestHeaders) {\n                for (Entry<String, String> nameValue : op.getRequestHeaders().entrySet()) {\n                    httpHeaders.add(nameValue.getKey(), nameValue.getValue());\n                }\n            }\n\n            if (authTokenValue != null) {\n                httpHeaders.add(AUTH_TOKEN_HEADER_ASCII, authTokenValue);\n            } else {\n                AuthorizationContext ctx = op.getAuthorizationContext();\n                if (ctx != null && ctx.getToken() != null) {\n                    httpHeaders.add(AUTH_TOKEN_HEADER_ASCII, ctx.getToken());\n                }\n            }\n\n            setAsciiContentType(op, httpHeaders);\n\n            httpHeaders.add(HttpHeaderNames.CONTENT_LENGTH,\n                    Long.toString(op.getContentLength()));\n\n            if (op.isKeepAlive()) {\n                httpHeaders.add(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n            } else if (connectionHeaderValue != null) {\n                // If connection header is specified and keep-alive is not enabled, put back original value\n                httpHeaders.add(HttpHeaderNames.CONNECTION, connectionHeaderValue);\n            }\n\n            if (op.hasReferer() && !op.isFromReplication()) {\n                httpHeaders.add(HttpHeaderNames.REFERER, op.getRefererAsString());\n            }\n\n            if (!isXenonToXenon) {\n                if (op.getCookies() != null) {\n                    String header = CookieJar.encodeCookies(op.getCookies());\n                    httpHeaders.set(HttpHeaderNames.COOKIE, header);\n                }\n\n                request.headers().set(HttpHeaderNames.USER_AGENT, this.userAgentAscii);\n                if (acceptValue == null) {\n                    httpHeaders.add(HttpHeaderNames.ACCEPT, DEFAULT_MEDIA_TYPE_ASCII);\n                } else {\n                    httpHeaders.add(HttpHeaderNames.ACCEPT, acceptValue);\n                }\n\n                httpHeaders.add(HttpHeaderNames.HOST, op.getUri().getHost());\n            } else {\n                if (acceptValue != null) {\n                    httpHeaders.add(HttpHeaderNames.ACCEPT, acceptValue);\n                }\n            }\n\n            if (LOGGER.isLoggable(Level.FINEST)) {\n                logRequestFraming(op, request);\n            }\n\n            boolean doCookieJarUpdate = !isXenonToXenon;\n            op.nestCompletion((o, e) -> {\n                if (e != null) {\n                    fail(e, op, originalBody);\n                    return;\n                }\n\n                stopTracking(op);\n\n                if (doCookieJarUpdate) {\n                    updateCookieJarFromResponseHeaders(o);\n                }\n\n                // After request is sent control is transferred to the\n                // NettyHttpServerResponseHandler. The response handler will nest completions\n                // and call complete() when response is received, which will invoke this completion\n                op.complete();\n            });\n\n            op.toggleOption(OperationOption.SOCKET_ACTIVE, true);\n            op.getSocketContext().writeHttpRequest(request);\n        } catch (Exception e) {\n            op.setBody(ServiceErrorResponse.create(e, Operation.STATUS_CODE_BAD_REQUEST,\n                    EnumSet.of(ErrorDetail.SHOULD_RETRY)));\n            fail(e, op, originalBody);\n        }\n    }", "signature": "void sendHttpRequest(Operation op)", "full_signature": "private void sendHttpRequest(Operation op)", "class_method_signature": "NettyHttpServiceClient.sendHttpRequest(Operation op)", "testcase": false, "constructor": false, "invocations": ["getBodyRaw", "encodeBody", "getContentLength", "getRequestPayloadSizeLimit", "format", "getContentLength", "getRequestPayloadSizeLimit", "setBody", "create", "fail", "getPath", "getUri", "getRawQuery", "getUri", "getRawUserInfo", "getUri", "isEmpty", "isConnectionSharing", "toString", "getUri", "toHttpMethod", "getAction", "wrappedBuffer", "getContentLength", "headers", "hasRequestHeaders", "getAndRemoveRequestHeaderAsIs", "setOperation", "getAndRemoveRequestHeaderAsIs", "getAndRemoveRequestHeaderAsIs", "getAndRemoveRequestHeaderAsIs", "isFromReplication", "add", "add", "getTransactionId", "add", "getTransactionId", "getContextId", "add", "getContextId", "hasRequestHeaders", "getRequestHeaderAsIs", "isFromReplication", "isForwarded", "getAndRemoveRequestHeaderAsIs", "getAndRemoveRequestHeaderAsIs", "getAndRemoveRequestHeaderAsIs", "getAndRemoveRequestHeaderAsIs", "getAndRemoveRequestHeaderAsIs", "getAndRemoveRequestHeaderAsIs", "hasRequestHeaders", "entrySet", "getRequestHeaders", "add", "getKey", "getValue", "add", "getAuthorizationContext", "getToken", "add", "getToken", "setAsciiContentType", "add", "toString", "getContentLength", "isKeepAlive", "add", "add", "hasReferer", "isFromReplication", "add", "getRefererAsString", "getCookies", "encodeCookies", "getCookies", "set", "set", "headers", "add", "add", "add", "getHost", "getUri", "add", "isLoggable", "logRequestFraming", "nestCompletion", "fail", "stopTracking", "updateCookieJarFromResponseHeaders", "complete", "toggleOption", "writeHttpRequest", "getSocketContext", "setBody", "create", "of", "fail"]}, "repository": {"repo_id": 45276846, "url": "https://github.com/vmware-archive/xenon", "language": "Java", "is_fork": false, "fork_count": 97, "stargazer_count": 226, "size": 52010, "license": "licensed"}}