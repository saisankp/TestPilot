{"test_class": {"identifier": "MessageFileTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static File dir = new File(\"build/test-data\");", "modifier": "private static", "type": "File", "declarator": "dir = new File(\"build/test-data\")", "var_name": "dir"}], "file": "src/main/java/io/qdb/buffer/MessageFileTest.java"}, "test_case": {"identifier": "testAppend", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testAppend() throws IOException {\n        File file = new File(dir, \"append-from-channel.qdb\");\n        file.delete();\n\n        MessageFile mf = new MessageFile(file, 1000L, 1000000);\n\n        long ts0 = System.currentTimeMillis();\n        String key0 = \"foo\";\n        byte[] payload0 = \"piggy\".getBytes(\"UTF8\");\n        int length0 = 1/*type*/ + 8/*timestamp*/ + 2/*key size*/ + 4/* payload size*/ + key0.length() + payload0.length;\n\n        long ts1 = ts0 + 1;\n        String key1 = \"foobar\";\n        byte[] payload1 = \"oink\".getBytes(\"UTF8\");\n        int length1 = 1/*type*/ + 8/*timestamp*/ + 2/*key size*/ + 4/* payload size*/ + key1.length() + payload1.length;\n\n        assertEquals(1000L, mf.append(ts0, key0, toChannel(payload0), payload0.length));\n        assertEquals(1000L + length0, mf.append(ts1, key1, toChannel(payload1), payload1.length));\n\n        int expectedLength = 4096/*file header*/ + length0 + length1;\n        assertEquals(expectedLength, mf.length());\n        mf.close();\n        assertEquals(expectedLength, file.length());\n\n        DataInputStream ins = new DataInputStream(new FileInputStream(file));\n\n        assertEquals((short)0xBE01, ins.readShort());   // magic\n        assertEquals((short)0, ins.readShort());        // reserved\n        assertEquals(1000000, ins.readInt());           // max file size\n        assertEquals(expectedLength, ins.readInt());    // checkpoint\n        assertEquals(0, ins.readInt());                 // reserved\n\n        assertEquals(0, ins.readInt());                 // bucket first message id (relative to file)\n        assertEquals(ts0, ins.readLong());              // bucket timestamp\n        assertEquals(2, ins.readInt());                 // bucket count\n\n        for (int i = 16 + 16; i < 4096; i += 16) {\n            assertEquals(-1, ins.readInt());\n            assertEquals(0L, ins.readLong());\n            assertEquals(0, ins.readInt());\n        }\n\n        assertEquals((byte)0xA1, ins.readByte());   // type\n        assertEquals(ts0, ins.readLong());\n        assertEquals(key0.length(), (int)ins.readShort());\n        assertEquals(payload0.length, ins.readInt());\n        assertEquals(key0, readUTF8(ins, key0.length()));\n        assertEquals(new String(payload0, \"UTF8\"), readUTF8(ins, payload0.length));\n\n        assertEquals((byte)0xA1, ins.readByte());   // type\n        assertEquals(ts1, ins.readLong());\n        assertEquals(key1.length(), (int)ins.readShort());\n        assertEquals(payload1.length, ins.readInt());\n        assertEquals(key1, readUTF8(ins, key1.length()));\n        assertEquals(new String(payload1, \"UTF8\"), readUTF8(ins, payload1.length));\n\n        ins.close();\n    }", "signature": "void testAppend()", "full_signature": "@Test public void testAppend()", "class_method_signature": "MessageFileTest.testAppend()", "testcase": true, "constructor": false, "invocations": ["delete", "currentTimeMillis", "getBytes", "length", "getBytes", "length", "assertEquals", "append", "toChannel", "assertEquals", "append", "toChannel", "assertEquals", "length", "close", "assertEquals", "length", "assertEquals", "readShort", "assertEquals", "readShort", "assertEquals", "readInt", "assertEquals", "readInt", "assertEquals", "readInt", "assertEquals", "readInt", "assertEquals", "readLong", "assertEquals", "readInt", "assertEquals", "readInt", "assertEquals", "readLong", "assertEquals", "readInt", "assertEquals", "readByte", "assertEquals", "readLong", "assertEquals", "length", "readShort", "assertEquals", "readInt", "assertEquals", "readUTF8", "length", "assertEquals", "readUTF8", "assertEquals", "readByte", "assertEquals", "readLong", "assertEquals", "length", "readShort", "assertEquals", "readInt", "assertEquals", "readUTF8", "length", "assertEquals", "readUTF8", "close"]}, "focal_class": {"identifier": "MessageFile", "superclass": "", "interfaces": "implements Closeable", "fields": [{"original_string": "private final File file;", "modifier": "private final", "type": "File", "declarator": "file", "var_name": "file"}, {"original_string": "private final long firstMessageId;", "modifier": "private final", "type": "long", "declarator": "firstMessageId", "var_name": "firstMessageId"}, {"original_string": "private final int maxFileSize;", "modifier": "private final", "type": "int", "declarator": "maxFileSize", "var_name": "maxFileSize"}, {"original_string": "private final RandomAccessFile raf;", "modifier": "private final", "type": "RandomAccessFile", "declarator": "raf", "var_name": "raf"}, {"original_string": "private final FileChannel channel;", "modifier": "private final", "type": "FileChannel", "declarator": "channel", "var_name": "channel"}, {"original_string": "private final ByteBuffer fileHeader;", "modifier": "private final", "type": "ByteBuffer", "declarator": "fileHeader", "var_name": "fileHeader"}, {"original_string": "private final ByteBuffer header;", "modifier": "private final", "type": "ByteBuffer", "declarator": "header", "var_name": "header"}, {"original_string": "private int usageCounter = 1;", "modifier": "private", "type": "int", "declarator": "usageCounter = 1", "var_name": "usageCounter"}, {"original_string": "private int length;", "modifier": "private", "type": "int", "declarator": "length", "var_name": "length"}, {"original_string": "private int lastCheckpointLength;", "modifier": "private", "type": "int", "declarator": "lastCheckpointLength", "var_name": "lastCheckpointLength"}, {"original_string": "private long mostRecentTimestamp;", "modifier": "private", "type": "long", "declarator": "mostRecentTimestamp", "var_name": "mostRecentTimestamp"}, {"original_string": "private final int bytesPerBucket;", "modifier": "private final", "type": "int", "declarator": "bytesPerBucket", "var_name": "bytesPerBucket"}, {"original_string": "private int bucketIndex;", "modifier": "private", "type": "int", "declarator": "bucketIndex", "var_name": "bucketIndex"}, {"original_string": "private long bucketTimestamp;", "modifier": "private", "type": "long", "declarator": "bucketTimestamp", "var_name": "bucketTimestamp"}, {"original_string": "private int bucketMessageId;", "modifier": "private", "type": "int", "declarator": "bucketMessageId", "var_name": "bucketMessageId"}, {"original_string": "private int bucketCount;", "modifier": "private", "type": "int", "declarator": "bucketCount", "var_name": "bucketCount"}, {"original_string": "public static final int FILE_HEADER_SIZE = 4096;", "modifier": "public static final", "type": "int", "declarator": "FILE_HEADER_SIZE = 4096", "var_name": "FILE_HEADER_SIZE"}, {"original_string": "private static final int FILE_HEADER_FIXED_SIZE = 16;", "modifier": "private static final", "type": "int", "declarator": "FILE_HEADER_FIXED_SIZE = 16", "var_name": "FILE_HEADER_FIXED_SIZE"}, {"original_string": "private static final int BUCKET_RECORD_SIZE = 16;", "modifier": "private static final", "type": "int", "declarator": "BUCKET_RECORD_SIZE = 16", "var_name": "BUCKET_RECORD_SIZE"}, {"original_string": "private static final int MAX_BUCKETS = (FILE_HEADER_SIZE - FILE_HEADER_FIXED_SIZE) / BUCKET_RECORD_SIZE;", "modifier": "private static final", "type": "int", "declarator": "MAX_BUCKETS = (FILE_HEADER_SIZE - FILE_HEADER_FIXED_SIZE) / BUCKET_RECORD_SIZE", "var_name": "MAX_BUCKETS"}, {"original_string": "private static final short FILE_MAGIC = (short)0xBE01;", "modifier": "private static final", "type": "short", "declarator": "FILE_MAGIC = (short)0xBE01", "var_name": "FILE_MAGIC"}, {"original_string": "private static final byte TYPE_MESSAGE = (byte)0xA1;", "modifier": "private static final", "type": "byte", "declarator": "TYPE_MESSAGE = (byte)0xA1", "var_name": "TYPE_MESSAGE"}, {"original_string": "private static final int MESSAGE_HEADER_SIZE = 1 + 8 + 2 + 4;", "modifier": "private static final", "type": "int", "declarator": "MESSAGE_HEADER_SIZE = 1 + 8 + 2 + 4", "var_name": "MESSAGE_HEADER_SIZE"}, {"original_string": "private static final Charset UTF8 = Charset.forName(\"UTF8\");", "modifier": "private static final", "type": "Charset", "declarator": "UTF8 = Charset.forName(\"UTF8\")", "var_name": "UTF8"}], "methods": [{"identifier": "MessageFile", "parameters": "(File file, long firstMessageId)", "modifiers": "@SuppressWarnings(\"StatementWithEmptyBody\") public", "return": "", "signature": " MessageFile(File file, long firstMessageId)", "full_signature": "@SuppressWarnings(\"StatementWithEmptyBody\") public  MessageFile(File file, long firstMessageId)", "class_method_signature": "MessageFile.MessageFile(File file, long firstMessageId)", "testcase": false, "constructor": true}, {"identifier": "MessageFile", "parameters": "(File file, long firstMessageId, int maxFileSize)", "modifiers": "@SuppressWarnings(\"StatementWithEmptyBody\") public", "return": "", "signature": " MessageFile(File file, long firstMessageId, int maxFileSize)", "full_signature": "@SuppressWarnings(\"StatementWithEmptyBody\") public  MessageFile(File file, long firstMessageId, int maxFileSize)", "class_method_signature": "MessageFile.MessageFile(File file, long firstMessageId, int maxFileSize)", "testcase": false, "constructor": true}, {"identifier": "bucketPosition", "parameters": "(int i)", "modifiers": "private", "return": "int", "signature": "int bucketPosition(int i)", "full_signature": "private int bucketPosition(int i)", "class_method_signature": "MessageFile.bucketPosition(int i)", "testcase": false, "constructor": false}, {"identifier": "getFile", "parameters": "()", "modifiers": "public", "return": "File", "signature": "File getFile()", "full_signature": "public File getFile()", "class_method_signature": "MessageFile.getFile()", "testcase": false, "constructor": false}, {"identifier": "getFirstMessageId", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getFirstMessageId()", "full_signature": "public long getFirstMessageId()", "class_method_signature": "MessageFile.getFirstMessageId()", "testcase": false, "constructor": false}, {"identifier": "getNextMessageId", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getNextMessageId()", "full_signature": "public long getNextMessageId()", "class_method_signature": "MessageFile.getNextMessageId()", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(long timestamp, String routingKey, ReadableByteChannel payload, int payloadSize)", "modifiers": "public", "return": "long", "signature": "long append(long timestamp, String routingKey, ReadableByteChannel payload, int payloadSize)", "full_signature": "public long append(long timestamp, String routingKey, ReadableByteChannel payload, int payloadSize)", "class_method_signature": "MessageFile.append(long timestamp, String routingKey, ReadableByteChannel payload, int payloadSize)", "testcase": false, "constructor": false}, {"identifier": "putBucketDataInFileHeader", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void putBucketDataInFileHeader()", "full_signature": "private void putBucketDataInFileHeader()", "class_method_signature": "MessageFile.putBucketDataInFileHeader()", "testcase": false, "constructor": false}, {"identifier": "getMessageSize", "parameters": "(String routingKey, int payloadSize)", "modifiers": "public static", "return": "int", "signature": "int getMessageSize(String routingKey, int payloadSize)", "full_signature": "public static int getMessageSize(String routingKey, int payloadSize)", "class_method_signature": "MessageFile.getMessageSize(String routingKey, int payloadSize)", "testcase": false, "constructor": false}, {"identifier": "length", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int length()", "full_signature": "public int length()", "class_method_signature": "MessageFile.length()", "testcase": false, "constructor": false}, {"identifier": "checkpoint", "parameters": "(boolean force)", "modifiers": "public", "return": "void", "signature": "void checkpoint(boolean force)", "full_signature": "public void checkpoint(boolean force)", "class_method_signature": "MessageFile.checkpoint(boolean force)", "testcase": false, "constructor": false}, {"identifier": "use", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void use()", "full_signature": "public void use()", "class_method_signature": "MessageFile.use()", "testcase": false, "constructor": false}, {"identifier": "closeIfUnused", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void closeIfUnused()", "full_signature": "public void closeIfUnused()", "class_method_signature": "MessageFile.closeIfUnused()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "MessageFile.close()", "testcase": false, "constructor": false}, {"identifier": "isOpen", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isOpen()", "full_signature": "public boolean isOpen()", "class_method_signature": "MessageFile.isOpen()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "MessageFile.toString()", "testcase": false, "constructor": false}, {"identifier": "getMostRecentTimestamp", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getMostRecentTimestamp()", "full_signature": "public long getMostRecentTimestamp()", "class_method_signature": "MessageFile.getMostRecentTimestamp()", "testcase": false, "constructor": false}, {"identifier": "getMessageCount", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMessageCount()", "full_signature": "public int getMessageCount()", "class_method_signature": "MessageFile.getMessageCount()", "testcase": false, "constructor": false}, {"identifier": "getTimeline", "parameters": "()", "modifiers": "public", "return": "Timeline", "signature": "Timeline getTimeline()", "full_signature": "public Timeline getTimeline()", "class_method_signature": "MessageFile.getTimeline()", "testcase": false, "constructor": false}, {"identifier": "getBucketCount", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getBucketCount()", "full_signature": "public int getBucketCount()", "class_method_signature": "MessageFile.getBucketCount()", "testcase": false, "constructor": false}, {"identifier": "getBucket", "parameters": "(int i)", "modifiers": "public", "return": "Bucket", "signature": "Bucket getBucket(int i)", "full_signature": "public Bucket getBucket(int i)", "class_method_signature": "MessageFile.getBucket(int i)", "testcase": false, "constructor": false}, {"identifier": "findBucket", "parameters": "(long messageId)", "modifiers": "public", "return": "int", "signature": "int findBucket(long messageId)", "full_signature": "public int findBucket(long messageId)", "class_method_signature": "MessageFile.findBucket(long messageId)", "testcase": false, "constructor": false}, {"identifier": "findBucketByTimestamp", "parameters": "(long timestamp)", "modifiers": "public", "return": "int", "signature": "int findBucketByTimestamp(long timestamp)", "full_signature": "public int findBucketByTimestamp(long timestamp)", "class_method_signature": "MessageFile.findBucketByTimestamp(long timestamp)", "testcase": false, "constructor": false}, {"identifier": "cursor", "parameters": "(long messageId)", "modifiers": "@SuppressWarnings(\"StatementWithEmptyBody\") public", "return": "MessageCursor", "signature": "MessageCursor cursor(long messageId)", "full_signature": "@SuppressWarnings(\"StatementWithEmptyBody\") public MessageCursor cursor(long messageId)", "class_method_signature": "MessageFile.cursor(long messageId)", "testcase": false, "constructor": false}, {"identifier": "cursorByTimestamp", "parameters": "(long timestamp)", "modifiers": "@SuppressWarnings(\"StatementWithEmptyBody\") public", "return": "MessageCursor", "signature": "MessageCursor cursorByTimestamp(long timestamp)", "full_signature": "@SuppressWarnings(\"StatementWithEmptyBody\") public MessageCursor cursorByTimestamp(long timestamp)", "class_method_signature": "MessageFile.cursorByTimestamp(long timestamp)", "testcase": false, "constructor": false}], "file": "src/main/java/io/qdb/buffer/MessageFile.java"}, "focal_method": {"identifier": "append", "parameters": "(long timestamp, String routingKey, ReadableByteChannel payload, int payloadSize)", "modifiers": "public", "return": "long", "body": "public long append(long timestamp, String routingKey, ReadableByteChannel payload, int payloadSize) throws IOException {\n        int n = routingKey.length();\n        if (n > 255) throw new IllegalArgumentException(\"Routing key length \" + n + \" > 255 characters\");\n\n        byte[] routingKeyBytes = routingKey.getBytes(UTF8);\n\n        synchronized (channel) {\n            if (length + MESSAGE_HEADER_SIZE + routingKeyBytes.length + payloadSize > maxFileSize) return -1;\n\n            header.clear();\n            channel.position(length);\n            header.put(TYPE_MESSAGE);\n            header.putLong(timestamp);\n            header.putShort((short)routingKeyBytes.length);\n            header.putInt(payloadSize);\n            header.put(routingKeyBytes);\n            header.flip();\n\n            int id = length - FILE_HEADER_SIZE;\n            channel.write(header);\n            long sz = channel.transferFrom(payload, channel.position(), payloadSize);\n            if (sz != payloadSize) {\n                throw new IOException(\"Only read \" + sz + \" bytes from payload channel instead of \" + payloadSize);\n            }\n            length = (int)channel.position() + payloadSize; // update after write so a partial write won't corrupt file\n\n            // see if we need to start a new histogram bucket\n            if (bucketIndex < 0 || ((id - bucketMessageId >= bytesPerBucket) && bucketIndex < MAX_BUCKETS - 1)) {\n                if (bucketIndex >= 0) {\n                    putBucketDataInFileHeader();\n                    ++bucketIndex;\n                } else {\n                    bucketIndex = 0;\n                }\n                bucketMessageId = id;\n                bucketTimestamp = timestamp;\n                bucketCount = 1;\n            } else {\n                ++bucketCount;\n            }\n\n            mostRecentTimestamp = timestamp;\n            return firstMessageId + id;\n        }\n    }", "signature": "long append(long timestamp, String routingKey, ReadableByteChannel payload, int payloadSize)", "full_signature": "public long append(long timestamp, String routingKey, ReadableByteChannel payload, int payloadSize)", "class_method_signature": "MessageFile.append(long timestamp, String routingKey, ReadableByteChannel payload, int payloadSize)", "testcase": false, "constructor": false, "invocations": ["length", "getBytes", "clear", "position", "put", "putLong", "putShort", "putInt", "put", "flip", "write", "transferFrom", "position", "position", "putBucketDataInFileHeader"]}, "repository": {"repo_id": 31758882, "url": "https://github.com/zqhxuyuan/zava", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 12, "size": 10325, "license": "licensed"}}