{"test_class": {"identifier": "KeyIndexesBuilderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final KeyIndexesBuilder builder = new KeyIndexesBuilder();", "modifier": "private final", "type": "KeyIndexesBuilder", "declarator": "builder = new KeyIndexesBuilder()", "var_name": "builder"}, {"original_string": "private AnnotationData data;", "modifier": "private", "type": "AnnotationData", "declarator": "data", "var_name": "data"}], "file": "simple-spring-memcached/src/test/java/com/google/code/ssm/aop/support/builder/KeyIndexesBuilderTest.java"}, "test_case": {"identifier": "shouldPopulateReturnKeyAnnotation", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldPopulateReturnKeyAnnotation() throws Exception {\n        final Class<? extends Annotation> expected = InvalidateSingleCache.class;\n        final Method targetMethod = new Mirror().on(AnnotationDataDummy.class).reflect().method(\"populateKeyProvider02\")\n                .withArgs(String.class);\n\n        builder.populate(data, null, expected, targetMethod);\n\n        assertTrue(data.getKeyIndexes().isEmpty());\n        assertTrue(data.isReturnKeyIndex());\n    }", "signature": "void shouldPopulateReturnKeyAnnotation()", "full_signature": "@Test public void shouldPopulateReturnKeyAnnotation()", "class_method_signature": "KeyIndexesBuilderTest.shouldPopulateReturnKeyAnnotation()", "testcase": true, "constructor": false, "invocations": ["withArgs", "method", "reflect", "on", "populate", "assertTrue", "isEmpty", "getKeyIndexes", "assertTrue", "isReturnKeyIndex"]}, "focal_class": {"identifier": "KeyIndexesBuilder", "superclass": "extends AbstractDataBuilder", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(KeyIndexesBuilder.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(KeyIndexesBuilder.class)", "var_name": "LOG"}, {"original_string": "private static final Comparator<ParameterValueKeyProvider> COMPARATOR = new ParameterValueKeyProviderComparator();", "modifier": "private static final", "type": "Comparator<ParameterValueKeyProvider>", "declarator": "COMPARATOR = new ParameterValueKeyProviderComparator()", "var_name": "COMPARATOR"}], "methods": [{"identifier": "build", "parameters": "(final AnnotationData data, final Annotation annotation, final Class<? extends Annotation> expectedAnnotationClass,\n            final Method targetMethod)", "modifiers": "@Override protected", "return": "void", "signature": "void build(final AnnotationData data, final Annotation annotation, final Class<? extends Annotation> expectedAnnotationClass,\n            final Method targetMethod)", "full_signature": "@Override protected void build(final AnnotationData data, final Annotation annotation, final Class<? extends Annotation> expectedAnnotationClass,\n            final Method targetMethod)", "class_method_signature": "KeyIndexesBuilder.build(final AnnotationData data, final Annotation annotation, final Class<? extends Annotation> expectedAnnotationClass,\n            final Method targetMethod)", "testcase": false, "constructor": false}, {"identifier": "support", "parameters": "(Class<? extends Annotation> expectedAnnotationClass)", "modifiers": "@Override protected", "return": "boolean", "signature": "boolean support(Class<? extends Annotation> expectedAnnotationClass)", "full_signature": "@Override protected boolean support(Class<? extends Annotation> expectedAnnotationClass)", "class_method_signature": "KeyIndexesBuilder.support(Class<? extends Annotation> expectedAnnotationClass)", "testcase": false, "constructor": false}, {"identifier": "getKeyIndexes", "parameters": "(final Method targetMethod, final boolean isMulti)", "modifiers": "private", "return": "Collection<Integer>", "signature": "Collection<Integer> getKeyIndexes(final Method targetMethod, final boolean isMulti)", "full_signature": "private Collection<Integer> getKeyIndexes(final Method targetMethod, final boolean isMulti)", "class_method_signature": "KeyIndexesBuilder.getKeyIndexes(final Method targetMethod, final boolean isMulti)", "testcase": false, "constructor": false}], "file": "simple-spring-memcached/src/main/java/com/google/code/ssm/aop/support/builder/KeyIndexesBuilder.java"}, "focal_method": {"identifier": "getKeyIndexes", "parameters": "(final Method targetMethod, final boolean isMulti)", "modifiers": "private", "return": "Collection<Integer>", "body": "private Collection<Integer> getKeyIndexes(final Method targetMethod, final boolean isMulti) {\n        final Annotation[][] paramAnnotationArrays = targetMethod.getParameterAnnotations();\n        final SortedMap<ParameterValueKeyProvider, Integer> keyProviders = new TreeMap<ParameterValueKeyProvider, Integer>(COMPARATOR);\n        final Set<Integer> order = new HashSet<Integer>();\n\n        if (paramAnnotationArrays == null || paramAnnotationArrays.length < 1) {\n            return Collections.emptyList();\n        }\n\n        for (int ix = 0; ix < paramAnnotationArrays.length; ix++) {\n            final ParameterValueKeyProvider keyProviderAnnotation = getAnnotation(ParameterValueKeyProvider.class,\n                    paramAnnotationArrays[ix]);\n            if (keyProviderAnnotation == null) {\n                continue;\n            }\n\n            // throw if order below 0\n            if (keyProviderAnnotation.order() < 0) {\n                throw new InvalidParameterException(String.format(\n                        \"No valid order [%d] defined in annotation [%s] on method [%s], only no negative integers are allowed.\",\n                        keyProviderAnnotation.order(), ParameterValueKeyProvider.class.getName(), targetMethod.getName()));\n            }\n            // throw exception if there are two annotations with the same value of order\n            if (!order.add(keyProviderAnnotation.order())) {\n                throwException(\n                        \"No valid order defined in annotation [%s] on method [%s]. There are two annotations with the same order.\",\n                        ParameterValueKeyProvider.class, targetMethod);\n            }\n            // log warn if for non multi annotation one of Collection parameter is annotated as a ParameterValueKeyProvider\n            if (!isMulti && Collection.class.isAssignableFrom(targetMethod.getParameterTypes()[ix])) {\n                LOG.warn(\"ParameterValueKeyProvider is used on a list parameter {} in method {} with non multi cache annotation.\"\n                        + \"Consider changing to *MultiCache annotation or use another parameter for key. Using collections in such case \"\n                        + \"may lead to unexpected consequences: key can exceed allowed memcached key length, key will be varied \"\n                        + \"when order or size are changed.\" , targetMethod.getParameterTypes()[ix], targetMethod.getName());\n            }\n\n            keyProviders.put(keyProviderAnnotation, ix);\n        }\n\n        return keyProviders.values();\n    }", "signature": "Collection<Integer> getKeyIndexes(final Method targetMethod, final boolean isMulti)", "full_signature": "private Collection<Integer> getKeyIndexes(final Method targetMethod, final boolean isMulti)", "class_method_signature": "KeyIndexesBuilder.getKeyIndexes(final Method targetMethod, final boolean isMulti)", "testcase": false, "constructor": false, "invocations": ["getParameterAnnotations", "emptyList", "getAnnotation", "order", "format", "order", "getName", "getName", "add", "order", "throwException", "isAssignableFrom", "getParameterTypes", "warn", "getParameterTypes", "getName", "put", "values"]}, "repository": {"repo_id": 16611556, "url": "https://github.com/ragnor/simple-spring-memcached", "language": "Java", "is_fork": false, "fork_count": 86, "stargazer_count": 181, "size": 3625, "license": "licensed"}}