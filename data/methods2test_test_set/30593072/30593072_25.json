{"test_class": {"identifier": "FixTagParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private FixTagHandler fixTagHandler;", "modifier": "private", "type": "FixTagHandler", "declarator": "fixTagHandler", "var_name": "fixTagHandler"}], "file": "nanofix-client/src/test/java/com/lmax/nanofix/incoming/FixTagParserTest.java"}, "test_case": {"identifier": "shouldCountTagsCorrectlyInMessage", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldCountTagsCorrectlyInMessage()\n    {\n\n        given(fixTagHandler.isFinished()).willReturn(false);\n\n        final byte[] logonMsg = FixMessageUtil.getLogonMessage();\n\n        final FixTagParser parser = new FixTagParser(fixTagHandler);\n\n        parser.parse(logonMsg, 0, logonMsg.length, true);\n\n        verify(fixTagHandler).messageStart();\n        verify(fixTagHandler, times(13)).onTag(any(int.class), any(byte[].class), any(int.class), any(int.class));\n        verify(fixTagHandler, times(13)).isFinished();\n        verify(fixTagHandler).messageEnd();\n\n        verifyNoMoreInteractions(fixTagHandler);\n    }", "signature": "void shouldCountTagsCorrectlyInMessage()", "full_signature": "@Test public void shouldCountTagsCorrectlyInMessage()", "class_method_signature": "FixTagParserTest.shouldCountTagsCorrectlyInMessage()", "testcase": true, "constructor": false, "invocations": ["willReturn", "given", "isFinished", "getLogonMessage", "parse", "messageStart", "verify", "onTag", "verify", "times", "any", "any", "any", "any", "isFinished", "verify", "times", "messageEnd", "verify", "verifyNoMoreInteractions"]}, "focal_class": {"identifier": "FixTagParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final byte SOH = 1;", "modifier": "public static final", "type": "byte", "declarator": "SOH = 1", "var_name": "SOH"}, {"original_string": "private static final byte ASCII_EQUALS = (byte)61;", "modifier": "private static final", "type": "byte", "declarator": "ASCII_EQUALS = (byte)61", "var_name": "ASCII_EQUALS"}, {"original_string": "private final FixTagHandler fixTagHandler;", "modifier": "private final", "type": "FixTagHandler", "declarator": "fixTagHandler", "var_name": "fixTagHandler"}, {"original_string": "private final byte[] lineSeparators;", "modifier": "private final", "type": "byte[]", "declarator": "lineSeparators", "var_name": "lineSeparators"}], "methods": [{"identifier": "FixTagParser", "parameters": "(final FixTagHandler fixTagHandler)", "modifiers": "public", "return": "", "signature": " FixTagParser(final FixTagHandler fixTagHandler)", "full_signature": "public  FixTagParser(final FixTagHandler fixTagHandler)", "class_method_signature": "FixTagParser.FixTagParser(final FixTagHandler fixTagHandler)", "testcase": false, "constructor": true}, {"identifier": "FixTagParser", "parameters": "(final FixTagHandler fixTagHandler, final byte[] lineSeparators)", "modifiers": "public", "return": "", "signature": " FixTagParser(final FixTagHandler fixTagHandler, final byte[] lineSeparators)", "full_signature": "public  FixTagParser(final FixTagHandler fixTagHandler, final byte[] lineSeparators)", "class_method_signature": "FixTagParser.FixTagParser(final FixTagHandler fixTagHandler, final byte[] lineSeparators)", "testcase": false, "constructor": true}, {"identifier": "parse", "parameters": "(final byte[] message, final int offset, final int length, final boolean throwExceptionOnParseFailure)", "modifiers": "public", "return": "boolean", "signature": "boolean parse(final byte[] message, final int offset, final int length, final boolean throwExceptionOnParseFailure)", "full_signature": "public boolean parse(final byte[] message, final int offset, final int length, final boolean throwExceptionOnParseFailure)", "class_method_signature": "FixTagParser.parse(final byte[] message, final int offset, final int length, final boolean throwExceptionOnParseFailure)", "testcase": false, "constructor": false}, {"identifier": "containsLineSeparator", "parameters": "(final byte separator)", "modifiers": "private", "return": "boolean", "signature": "boolean containsLineSeparator(final byte separator)", "full_signature": "private boolean containsLineSeparator(final byte separator)", "class_method_signature": "FixTagParser.containsLineSeparator(final byte separator)", "testcase": false, "constructor": false}, {"identifier": "raiseException", "parameters": "(final String reason,\n                                       final byte[] message,\n                                       final int offset,\n                                       final int length,\n                                       final int tagStart,\n                                       final int equalsIndex)", "modifiers": "private static", "return": "void", "signature": "void raiseException(final String reason,\n                                       final byte[] message,\n                                       final int offset,\n                                       final int length,\n                                       final int tagStart,\n                                       final int equalsIndex)", "full_signature": "private static void raiseException(final String reason,\n                                       final byte[] message,\n                                       final int offset,\n                                       final int length,\n                                       final int tagStart,\n                                       final int equalsIndex)", "class_method_signature": "FixTagParser.raiseException(final String reason,\n                                       final byte[] message,\n                                       final int offset,\n                                       final int length,\n                                       final int tagStart,\n                                       final int equalsIndex)", "testcase": false, "constructor": false}], "file": "nanofix-client/src/main/java/com/lmax/nanofix/incoming/FixTagParser.java"}, "focal_method": {"identifier": "parse", "parameters": "(final byte[] message, final int offset, final int length, final boolean throwExceptionOnParseFailure)", "modifiers": "public", "return": "boolean", "body": "public boolean parse(final byte[] message, final int offset, final int length, final boolean throwExceptionOnParseFailure)\n    {\n        fixTagHandler.messageStart();\n\n        int tagStart = offset;\n        int equalsIndex = -1;\n\n        for (int i = 0; i < length; i++)\n        {\n            int index = i + offset;\n            if (ASCII_EQUALS == message[index])\n            {\n                equalsIndex = index;\n            }\n\n            if (containsLineSeparator(message[index]))\n            {\n                if (-1 != equalsIndex)\n                {\n                    if (!ByteUtil.isInteger(message, tagStart, equalsIndex - tagStart))\n                    {\n                        if (throwExceptionOnParseFailure)\n                        {\n                            raiseException(\"Invalid tag id\", message, offset, length, tagStart, equalsIndex);\n                        }\n                        return false;\n                    }\n\n                    int tagIdentity = ByteUtil.readIntFromAscii(message, tagStart, equalsIndex - tagStart);\n\n                    final int tagValueOffset = equalsIndex + 1;\n                    final int tagValueLength = index - tagValueOffset;\n\n                    fixTagHandler.onTag(tagIdentity, message, tagValueOffset, tagValueLength);\n\n                    if (fixTagHandler.isFinished())\n                    {\n                        break;\n                    }\n                }\n\n                tagStart = index + 1;\n                equalsIndex = -1;\n            }\n        }\n\n        fixTagHandler.messageEnd();\n\n        return true;\n    }", "signature": "boolean parse(final byte[] message, final int offset, final int length, final boolean throwExceptionOnParseFailure)", "full_signature": "public boolean parse(final byte[] message, final int offset, final int length, final boolean throwExceptionOnParseFailure)", "class_method_signature": "FixTagParser.parse(final byte[] message, final int offset, final int length, final boolean throwExceptionOnParseFailure)", "testcase": false, "constructor": false, "invocations": ["messageStart", "containsLineSeparator", "isInteger", "raiseException", "readIntFromAscii", "onTag", "isFinished", "messageEnd"]}, "repository": {"repo_id": 30593072, "url": "https://github.com/LMAX-Exchange/nanofix", "language": "Java", "is_fork": false, "fork_count": 18, "stargazer_count": 24, "size": 193, "license": "licensed"}}