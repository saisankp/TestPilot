{"test_class": {"identifier": "URLParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(URLParserTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(URLParserTest.class)", "var_name": "logger"}], "file": "ch-commons-util/src/test/java/com/cloudhopper/commons/util/URLParserTest.java"}, "test_case": {"identifier": "parse1", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void parse1() throws Exception {\n        URL url0 = URLParser.parse(\"file:///\");\n        Assert.assertEquals(\"file\", url0.getProtocol());\n        Assert.assertEquals(null, url0.getUsername());\n        Assert.assertEquals(null, url0.getPassword());\n        Assert.assertEquals(null, url0.getHost());\n        Assert.assertEquals(null, url0.getPort());\n        Assert.assertEquals(\"/\", url0.getPath());\n    }", "signature": "void parse1()", "full_signature": "@Test public void parse1()", "class_method_signature": "URLParserTest.parse1()", "testcase": true, "constructor": false, "invocations": ["parse", "assertEquals", "getProtocol", "assertEquals", "getUsername", "assertEquals", "getPassword", "assertEquals", "getHost", "assertEquals", "getPort", "assertEquals", "getPath"]}, "focal_class": {"identifier": "URLParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(URLParser.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(URLParser.class)", "var_name": "logger"}], "methods": [{"identifier": "URLParser", "parameters": "()", "modifiers": "private", "return": "", "signature": " URLParser()", "full_signature": "private  URLParser()", "class_method_signature": "URLParser.URLParser()", "testcase": false, "constructor": true}, {"identifier": "decode", "parameters": "(String str0)", "modifiers": "static private", "return": "String", "signature": "String decode(String str0)", "full_signature": "static private String decode(String str0)", "class_method_signature": "URLParser.decode(String str0)", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "(String url)", "modifiers": "static public", "return": "URL", "signature": "URL parse(String url)", "full_signature": "static public URL parse(String url)", "class_method_signature": "URLParser.parse(String url)", "testcase": false, "constructor": false}], "file": "ch-commons-util/src/main/java/com/cloudhopper/commons/util/URLParser.java"}, "focal_method": {"identifier": "parse", "parameters": "(String url)", "modifiers": "static public", "return": "URL", "body": "static public URL parse(String url) throws MalformedURLException {\n\n        int pos = 0;\n\n//        logger.debug(\"parsing URL: \" + url);\n\n        //\n        // parse protocol\n        //\n        int i = url.indexOf(\"://\");\n        if (i < 0) {\n            throw new MalformedURLException(\"Invalid URL [\" + url + \"]: no protocol specified\");\n        }\n\n        // the url we'll be returning\n        URL r = new URL();\n        \n        String protocol = url.substring(0, i);\n        r.setProtocol(protocol);\n//        logger.debug(\"parsed protocol: \" + protocol);\n\n        // skip :// part\n        pos = i + 3;\n\n        // username[:password]\n        i = url.indexOf('@', pos);\n        if (i >= 0) {\n            // found url to contain a username and possibly a password\n//            logger.debug(\"found @ char to indicate username:password\");\n            String userPass = url.substring(pos, i);\n            int atPos = userPass.indexOf(':');\n            if (atPos >= 0) {\n                // password exists in this string\n                String username = userPass.substring(0, atPos);\n                String password = userPass.substring(atPos+1);\n                if (username != null && username.length() > 0) {\n                    r.setUsername(decode(username));\n                }\n                if (password != null && password.length() > 0) {\n                    r.setPassword(decode(password));\n                }\n            } else {\n//                logger.debug(\"userPass part only includes a username\");\n                if (userPass.length() > 0) {\n                    r.setUsername(decode(userPass));\n                }\n            }\n            // update the position for the next parsing section\n            pos = i + 1;\n        }\n\n        //\n        // host[:port]\n        //\n        i = url.indexOf('/', pos);\n        if (i < 0) {\n            // maybe to the query string then\n            i = url.indexOf('?', pos);\n            if (i < 0) {\n                // host:port is to the complete end of this string\n                i = url.length();\n            }\n        }\n\n        // extract entire host and/or port\n        String hostPort = url.substring(pos, i);\n\n        // did a host actually exist?\n        if (hostPort != null && hostPort.length() > 0) {\n            // does this hostPort contain a port?\n            int colPos = hostPort.indexOf(':');\n            if (colPos >= 0) {\n                String host = hostPort.substring(0, colPos);\n                r.setHost(host);\n//                logger.debug(\"parsed host: \" + host);\n\n                String tempPort = hostPort.substring(colPos+1);\n                try {\n                    Integer port = Integer.valueOf(tempPort);\n                    r.setPort(port);\n//                    logger.debug(\"parsed port: \" + port);\n                } catch (NumberFormatException e) {\n                    throw new MalformedURLException(\"Invalid URL [\" + url + \"]: port '\" + tempPort + \"' was not an integer\");\n                }\n            } else {\n                // entire string is the host\n                r.setHost(hostPort);\n//                logger.debug(\"parsed host: \" + hostPort);\n            }\n        } else {\n//            logger.debug(\"no host parsed\");\n        }\n\n        // next position we'll start parsing from actually starts next\n        pos = i;\n\n        // we may be done\n        if (pos >= url.length()) {\n//            logger.debug(\"early parsing exist after host:port section\");\n            return r;\n        }\n\n        // if we get here, then we know there is more data in the url to parse\n        // the next character will either be / or ?\n        if (url.charAt(pos) == '/') {\n            // we either will read to end of string or till ?\n            i = url.indexOf('?');\n            if (i < 0) {\n                // read till end of string\n                i = url.length();\n            }\n            String path = url.substring(pos, i);\n            r.setPath(decode(path));\n//            logger.debug(\"parsed path: \" + path);\n        }\n\n        pos = i;\n\n        // we may be done\n        if (pos >= url.length()) {\n//            logger.debug(\"early parsing exist after path section\");\n            return r;\n        }\n\n        // we may have parsed the path above, now parse the query string\n        if (url.charAt(pos) == '?') {\n            String query = url.substring(pos+1);\n            if (query != null && query.length() > 0) {\n                r.setQuery(query);\n            }\n        }\n\n        return r;\n    }", "signature": "URL parse(String url)", "full_signature": "static public URL parse(String url)", "class_method_signature": "URLParser.parse(String url)", "testcase": false, "constructor": false, "invocations": ["indexOf", "substring", "setProtocol", "indexOf", "substring", "indexOf", "substring", "substring", "length", "setUsername", "decode", "length", "setPassword", "decode", "length", "setUsername", "decode", "indexOf", "indexOf", "length", "substring", "length", "indexOf", "substring", "setHost", "substring", "valueOf", "setPort", "setHost", "length", "charAt", "indexOf", "length", "substring", "setPath", "decode", "length", "charAt", "substring", "length", "setQuery"]}, "repository": {"repo_id": 14960307, "url": "https://github.com/twitter/cloudhopper-commons", "language": "Java", "is_fork": false, "fork_count": 40, "stargazer_count": 36, "size": 6452, "license": "licensed"}}