{"test_class": {"identifier": "TestMemoryChannel", "superclass": "", "interfaces": "", "fields": [{"original_string": "private MemoryChannel channel;", "modifier": "private", "type": "MemoryChannel", "declarator": "channel", "var_name": "channel"}], "file": "flume-ng-core/src/test/java/org/apache/flume/channel/TestMemoryChannel.java"}, "test_case": {"identifier": "testByteCapacityBufferEmptyingAfterRollback", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testByteCapacityBufferEmptyingAfterRollback() {\n    Context context = new Context();\n    Map<String, String> parms = new HashMap<String, String>();\n    parms.put(\"byteCapacity\", \"2000\");\n    parms.put(\"byteCapacityBufferPercentage\", \"20\");\n    context.putAll(parms);\n    Configurables.configure(channel,  context);\n\n    byte[] eventBody = new byte[405];\n\n    Transaction tx = channel.getTransaction();\n    tx.begin();\n    channel.put(EventBuilder.withBody(eventBody));\n    channel.put(EventBuilder.withBody(eventBody));\n    channel.put(EventBuilder.withBody(eventBody));\n    tx.rollback();\n    tx.close();\n\n    tx = channel.getTransaction();\n    tx.begin();\n    channel.put(EventBuilder.withBody(eventBody));\n    channel.put(EventBuilder.withBody(eventBody));\n    channel.put(EventBuilder.withBody(eventBody));\n    tx.commit();\n    tx.close();\n  }", "signature": "void testByteCapacityBufferEmptyingAfterRollback()", "full_signature": "@Test public void testByteCapacityBufferEmptyingAfterRollback()", "class_method_signature": "TestMemoryChannel.testByteCapacityBufferEmptyingAfterRollback()", "testcase": true, "constructor": false, "invocations": ["put", "put", "putAll", "configure", "getTransaction", "begin", "put", "withBody", "put", "withBody", "put", "withBody", "rollback", "close", "getTransaction", "begin", "put", "withBody", "put", "withBody", "put", "withBody", "commit", "close"]}, "focal_class": {"identifier": "MemoryChannel", "superclass": "extends BasicChannelSemantics", "interfaces": "implements TransactionCapacitySupported", "fields": [{"original_string": "private static Logger LOGGER = LoggerFactory.getLogger(MemoryChannel.class);", "modifier": "private static", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(MemoryChannel.class)", "var_name": "LOGGER"}, {"original_string": "private static final Integer defaultCapacity = 100;", "modifier": "private static final", "type": "Integer", "declarator": "defaultCapacity = 100", "var_name": "defaultCapacity"}, {"original_string": "private static final Integer defaultTransCapacity = 100;", "modifier": "private static final", "type": "Integer", "declarator": "defaultTransCapacity = 100", "var_name": "defaultTransCapacity"}, {"original_string": "private static final double byteCapacitySlotSize = 100;", "modifier": "private static final", "type": "double", "declarator": "byteCapacitySlotSize = 100", "var_name": "byteCapacitySlotSize"}, {"original_string": "private static final Long defaultByteCapacity = (long)(Runtime.getRuntime().maxMemory() * .80);", "modifier": "private static final", "type": "Long", "declarator": "defaultByteCapacity = (long)(Runtime.getRuntime().maxMemory() * .80)", "var_name": "defaultByteCapacity"}, {"original_string": "private static final Integer defaultByteCapacityBufferPercentage = 20;", "modifier": "private static final", "type": "Integer", "declarator": "defaultByteCapacityBufferPercentage = 20", "var_name": "defaultByteCapacityBufferPercentage"}, {"original_string": "private static final Integer defaultKeepAlive = 3;", "modifier": "private static final", "type": "Integer", "declarator": "defaultKeepAlive = 3", "var_name": "defaultKeepAlive"}, {"original_string": "private Object queueLock = new Object();", "modifier": "private", "type": "Object", "declarator": "queueLock = new Object()", "var_name": "queueLock"}, {"original_string": "@GuardedBy(value = \"queueLock\")\n  private LinkedBlockingDeque<Event> queue;", "modifier": "@GuardedBy(value = \"queueLock\")\n  private", "type": "LinkedBlockingDeque<Event>", "declarator": "queue", "var_name": "queue"}, {"original_string": "private Semaphore queueRemaining;", "modifier": "private", "type": "Semaphore", "declarator": "queueRemaining", "var_name": "queueRemaining"}, {"original_string": "private Semaphore queueStored;", "modifier": "private", "type": "Semaphore", "declarator": "queueStored", "var_name": "queueStored"}, {"original_string": "private volatile Integer transCapacity;", "modifier": "private volatile", "type": "Integer", "declarator": "transCapacity", "var_name": "transCapacity"}, {"original_string": "private volatile int keepAlive;", "modifier": "private volatile", "type": "int", "declarator": "keepAlive", "var_name": "keepAlive"}, {"original_string": "private volatile int byteCapacity;", "modifier": "private volatile", "type": "int", "declarator": "byteCapacity", "var_name": "byteCapacity"}, {"original_string": "private volatile int lastByteCapacity;", "modifier": "private volatile", "type": "int", "declarator": "lastByteCapacity", "var_name": "lastByteCapacity"}, {"original_string": "private volatile int byteCapacityBufferPercentage;", "modifier": "private volatile", "type": "int", "declarator": "byteCapacityBufferPercentage", "var_name": "byteCapacityBufferPercentage"}, {"original_string": "private Semaphore bytesRemaining;", "modifier": "private", "type": "Semaphore", "declarator": "bytesRemaining", "var_name": "bytesRemaining"}, {"original_string": "private ChannelCounter channelCounter;", "modifier": "private", "type": "ChannelCounter", "declarator": "channelCounter", "var_name": "channelCounter"}], "methods": [{"identifier": "MemoryChannel", "parameters": "()", "modifiers": "public", "return": "", "signature": " MemoryChannel()", "full_signature": "public  MemoryChannel()", "class_method_signature": "MemoryChannel.MemoryChannel()", "testcase": false, "constructor": true}, {"identifier": "configure", "parameters": "(Context context)", "modifiers": "@Override public", "return": "void", "signature": "void configure(Context context)", "full_signature": "@Override public void configure(Context context)", "class_method_signature": "MemoryChannel.configure(Context context)", "testcase": false, "constructor": false}, {"identifier": "resizeQueue", "parameters": "(int capacity)", "modifiers": "private", "return": "void", "signature": "void resizeQueue(int capacity)", "full_signature": "private void resizeQueue(int capacity)", "class_method_signature": "MemoryChannel.resizeQueue(int capacity)", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void start()", "full_signature": "@Override public synchronized void start()", "class_method_signature": "MemoryChannel.start()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void stop()", "full_signature": "@Override public synchronized void stop()", "class_method_signature": "MemoryChannel.stop()", "testcase": false, "constructor": false}, {"identifier": "createTransaction", "parameters": "()", "modifiers": "@Override protected", "return": "BasicTransactionSemantics", "signature": "BasicTransactionSemantics createTransaction()", "full_signature": "@Override protected BasicTransactionSemantics createTransaction()", "class_method_signature": "MemoryChannel.createTransaction()", "testcase": false, "constructor": false}, {"identifier": "estimateEventSize", "parameters": "(Event event)", "modifiers": "private", "return": "long", "signature": "long estimateEventSize(Event event)", "full_signature": "private long estimateEventSize(Event event)", "class_method_signature": "MemoryChannel.estimateEventSize(Event event)", "testcase": false, "constructor": false}, {"identifier": "getBytesRemainingValue", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "int", "signature": "int getBytesRemainingValue()", "full_signature": "@VisibleForTesting int getBytesRemainingValue()", "class_method_signature": "MemoryChannel.getBytesRemainingValue()", "testcase": false, "constructor": false}, {"identifier": "getTransactionCapacity", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getTransactionCapacity()", "full_signature": "public long getTransactionCapacity()", "class_method_signature": "MemoryChannel.getTransactionCapacity()", "testcase": false, "constructor": false}], "file": "flume-ng-core/src/main/java/org/apache/flume/channel/MemoryChannel.java"}, "focal_method": {"identifier": "configure", "parameters": "(Context context)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void configure(Context context) {\n    Integer capacity = null;\n    try {\n      capacity = context.getInteger(\"capacity\", defaultCapacity);\n    } catch (NumberFormatException e) {\n      capacity = defaultCapacity;\n      LOGGER.warn(\"Invalid capacity specified, initializing channel to \"\n          + \"default capacity of {}\", defaultCapacity);\n    }\n\n    if (capacity <= 0) {\n      capacity = defaultCapacity;\n      LOGGER.warn(\"Invalid capacity specified, initializing channel to \"\n          + \"default capacity of {}\", defaultCapacity);\n    }\n    try {\n      transCapacity = context.getInteger(\"transactionCapacity\", defaultTransCapacity);\n    } catch (NumberFormatException e) {\n      transCapacity = defaultTransCapacity;\n      LOGGER.warn(\"Invalid transation capacity specified, initializing channel\"\n          + \" to default capacity of {}\", defaultTransCapacity);\n    }\n\n    if (transCapacity <= 0) {\n      transCapacity = defaultTransCapacity;\n      LOGGER.warn(\"Invalid transation capacity specified, initializing channel\"\n          + \" to default capacity of {}\", defaultTransCapacity);\n    }\n    Preconditions.checkState(transCapacity <= capacity,\n        \"Transaction Capacity of Memory Channel cannot be higher than \" +\n            \"the capacity.\");\n\n    try {\n      byteCapacityBufferPercentage = context.getInteger(\"byteCapacityBufferPercentage\",\n                                                        defaultByteCapacityBufferPercentage);\n    } catch (NumberFormatException e) {\n      byteCapacityBufferPercentage = defaultByteCapacityBufferPercentage;\n    }\n\n    try {\n      byteCapacity = (int) ((context.getLong(\"byteCapacity\", defaultByteCapacity).longValue() *\n          (1 - byteCapacityBufferPercentage * .01)) / byteCapacitySlotSize);\n      if (byteCapacity < 1) {\n        byteCapacity = Integer.MAX_VALUE;\n      }\n    } catch (NumberFormatException e) {\n      byteCapacity = (int) ((defaultByteCapacity * (1 - byteCapacityBufferPercentage * .01)) /\n          byteCapacitySlotSize);\n    }\n\n    try {\n      keepAlive = context.getInteger(\"keep-alive\", defaultKeepAlive);\n    } catch (NumberFormatException e) {\n      keepAlive = defaultKeepAlive;\n    }\n\n    if (queue != null) {\n      try {\n        resizeQueue(capacity);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    } else {\n      synchronized (queueLock) {\n        queue = new LinkedBlockingDeque<Event>(capacity);\n        queueRemaining = new Semaphore(capacity);\n        queueStored = new Semaphore(0);\n      }\n    }\n\n    if (bytesRemaining == null) {\n      bytesRemaining = new Semaphore(byteCapacity);\n      lastByteCapacity = byteCapacity;\n    } else {\n      if (byteCapacity > lastByteCapacity) {\n        bytesRemaining.release(byteCapacity - lastByteCapacity);\n        lastByteCapacity = byteCapacity;\n      } else {\n        try {\n          if (!bytesRemaining.tryAcquire(lastByteCapacity - byteCapacity, keepAlive,\n                                         TimeUnit.SECONDS)) {\n            LOGGER.warn(\"Couldn't acquire permits to downsize the byte capacity, resizing has been aborted\");\n          } else {\n            lastByteCapacity = byteCapacity;\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n    if (channelCounter == null) {\n      channelCounter = new ChannelCounter(getName());\n    }\n  }", "signature": "void configure(Context context)", "full_signature": "@Override public void configure(Context context)", "class_method_signature": "MemoryChannel.configure(Context context)", "testcase": false, "constructor": false, "invocations": ["getInteger", "warn", "warn", "getInteger", "warn", "warn", "checkState", "getInteger", "longValue", "getLong", "getInteger", "resizeQueue", "interrupt", "currentThread", "release", "tryAcquire", "warn", "interrupt", "currentThread", "getName"]}, "repository": {"repo_id": 2198510, "url": "https://github.com/apache/flume", "language": "Java", "is_fork": false, "fork_count": 1372, "stargazer_count": 1971, "size": 44377, "license": "licensed"}}