{"test_class": {"identifier": "InstanceZTSProviderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private String servicePublicKeyStringK0 = null;", "modifier": "private", "type": "String", "declarator": "servicePublicKeyStringK0 = null", "var_name": "servicePublicKeyStringK0"}, {"original_string": "private String servicePrivateKeyStringK0 = null;", "modifier": "private", "type": "String", "declarator": "servicePrivateKeyStringK0 = null", "var_name": "servicePrivateKeyStringK0"}], "file": "libs/java/instance_provider/src/test/java/com/yahoo/athenz/instance/provider/impl/InstanceZTSProviderTest.java"}, "test_case": {"identifier": "testValidateHostname", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testValidateHostname() {\n        HostnameResolver hostnameResolver = Mockito.mock(HostnameResolver.class);\n        Mockito.when(hostnameResolver.getAllByName(\"abc.athenz.com\"))\n               .thenReturn(new HashSet<String>(Arrays.asList(\"10.1.1.1\", \"2001:db8:a0b:12f0:0:0:0:1\")));\n\n        InstanceZTSProvider provider = new InstanceZTSProvider();\n        provider.initialize(\"provider\", \"com.yahoo.athenz.instance.provider.impl.InstanceZTSProvider\", null, null);\n        provider.setHostnameResolver(hostnameResolver);\n\n        assertTrue(provider.validateHostname(\"abc.athenz.com\", new String[]{\"10.1.1.1\"}));\n        assertTrue(provider.validateHostname(\"abc.athenz.com\", new String[]{\"10.1.1.1\", \"2001:db8:a0b:12f0:0:0:0:1\"}));\n        assertFalse(provider.validateHostname(\"abc.athenz.com\", new String[]{\"10.1.1.2\"}));\n        assertFalse(provider.validateHostname(\"abc.athenz.com\", new String[]{\"10.1.1.1\", \"1:2:3:4:5:6:7:8\"}));\n        assertFalse(provider.validateHostname(\"abc.athenz.com\", new String[]{\"10.1.1.2\", \"1:2:3:4:5:6:7:8\"}));\n\n        // If hostname is passed, sanIp must be non empty\n        assertFalse(provider.validateHostname(\"abc.athenz.com\", null));\n        assertFalse(provider.validateHostname(\"abc.athenz.com\", new String[]{}));\n        assertFalse(provider.validateHostname(\"abc.athenz.com\", new String[]{\"\"}));\n\n        // It's possible client didn't set Hostname payload. One sanIp be optionally set, and would have been matched with clientIp upstream\n        assertTrue(provider.validateHostname(\"\", new String[]{\"10.1.1.1\"}));\n        assertTrue(provider.validateHostname(null, new String[]{\"10.1.1.1\"}));\n\n        // If more than one sanIp is passed, hostname must be non empty\n        assertFalse(provider.validateHostname(null, new String[]{\"10.1.1.1\", \"2001:db8:a0b:12f0:0:0:0:1\"}));\n        assertFalse(provider.validateHostname(\"\", new String[]{\"10.1.1.1\", \"2001:db8:a0b:12f0:0:0:0:1\"}));\n\n        provider.close();\n    }", "signature": "void testValidateHostname()", "full_signature": "@Test public void testValidateHostname()", "class_method_signature": "InstanceZTSProviderTest.testValidateHostname()", "testcase": true, "constructor": false, "invocations": ["mock", "thenReturn", "when", "getAllByName", "asList", "initialize", "setHostnameResolver", "assertTrue", "validateHostname", "assertTrue", "validateHostname", "assertFalse", "validateHostname", "assertFalse", "validateHostname", "assertFalse", "validateHostname", "assertFalse", "validateHostname", "assertFalse", "validateHostname", "assertFalse", "validateHostname", "assertTrue", "validateHostname", "assertTrue", "validateHostname", "assertFalse", "validateHostname", "assertFalse", "validateHostname", "close"]}, "focal_class": {"identifier": "InstanceZTSProvider", "superclass": "", "interfaces": "implements InstanceProvider", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(InstanceZTSProvider.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(InstanceZTSProvider.class)", "var_name": "LOGGER"}, {"original_string": "private static final Pattern WHITESPACE_PATTERN = Pattern.compile(\"\\\\s+\");", "modifier": "private static final", "type": "Pattern", "declarator": "WHITESPACE_PATTERN = Pattern.compile(\"\\\\s+\")", "var_name": "WHITESPACE_PATTERN"}, {"original_string": "private static final String URI_HOSTNAME_PREFIX = \"athenz://hostname/\";", "modifier": "private static final", "type": "String", "declarator": "URI_HOSTNAME_PREFIX = \"athenz://hostname/\"", "var_name": "URI_HOSTNAME_PREFIX"}, {"original_string": "static final String ZTS_PROVIDER_DNS_SUFFIX  = \"athenz.zts.provider_dns_suffix\";", "modifier": "static final", "type": "String", "declarator": "ZTS_PROVIDER_DNS_SUFFIX  = \"athenz.zts.provider_dns_suffix\"", "var_name": "ZTS_PROVIDER_DNS_SUFFIX"}, {"original_string": "static final String ZTS_PRINCIPAL_LIST       = \"athenz.zts.provider_service_list\";", "modifier": "static final", "type": "String", "declarator": "ZTS_PRINCIPAL_LIST       = \"athenz.zts.provider_service_list\"", "var_name": "ZTS_PRINCIPAL_LIST"}, {"original_string": "KeyStore keyStore = null;", "modifier": "", "type": "KeyStore", "declarator": "keyStore = null", "var_name": "keyStore"}, {"original_string": "String dnsSuffix = null;", "modifier": "", "type": "String", "declarator": "dnsSuffix = null", "var_name": "dnsSuffix"}, {"original_string": "Set<String> principals = null;", "modifier": "", "type": "Set<String>", "declarator": "principals = null", "var_name": "principals"}, {"original_string": "HostnameResolver hostnameResolver = null;", "modifier": "", "type": "HostnameResolver", "declarator": "hostnameResolver = null", "var_name": "hostnameResolver"}], "methods": [{"identifier": "getProviderScheme", "parameters": "()", "modifiers": "@Override public", "return": "Scheme", "signature": "Scheme getProviderScheme()", "full_signature": "@Override public Scheme getProviderScheme()", "class_method_signature": "InstanceZTSProvider.getProviderScheme()", "testcase": false, "constructor": false}, {"identifier": "initialize", "parameters": "(String provider, String providerEndpoint, SSLContext sslContext,\n            KeyStore keyStore)", "modifiers": "@Override public", "return": "void", "signature": "void initialize(String provider, String providerEndpoint, SSLContext sslContext,\n            KeyStore keyStore)", "full_signature": "@Override public void initialize(String provider, String providerEndpoint, SSLContext sslContext,\n            KeyStore keyStore)", "class_method_signature": "InstanceZTSProvider.initialize(String provider, String providerEndpoint, SSLContext sslContext,\n            KeyStore keyStore)", "testcase": false, "constructor": false}, {"identifier": "setHostnameResolver", "parameters": "(HostnameResolver hostnameResolver)", "modifiers": "@Override public", "return": "void", "signature": "void setHostnameResolver(HostnameResolver hostnameResolver)", "full_signature": "@Override public void setHostnameResolver(HostnameResolver hostnameResolver)", "class_method_signature": "InstanceZTSProvider.setHostnameResolver(HostnameResolver hostnameResolver)", "testcase": false, "constructor": false}, {"identifier": "forbiddenError", "parameters": "(String message)", "modifiers": "private", "return": "ResourceException", "signature": "ResourceException forbiddenError(String message)", "full_signature": "private ResourceException forbiddenError(String message)", "class_method_signature": "InstanceZTSProvider.forbiddenError(String message)", "testcase": false, "constructor": false}, {"identifier": "confirmInstance", "parameters": "(InstanceConfirmation confirmation)", "modifiers": "@Override public", "return": "InstanceConfirmation", "signature": "InstanceConfirmation confirmInstance(InstanceConfirmation confirmation)", "full_signature": "@Override public InstanceConfirmation confirmInstance(InstanceConfirmation confirmation)", "class_method_signature": "InstanceZTSProvider.confirmInstance(InstanceConfirmation confirmation)", "testcase": false, "constructor": false}, {"identifier": "refreshInstance", "parameters": "(InstanceConfirmation confirmation)", "modifiers": "@Override public", "return": "InstanceConfirmation", "signature": "InstanceConfirmation refreshInstance(InstanceConfirmation confirmation)", "full_signature": "@Override public InstanceConfirmation refreshInstance(InstanceConfirmation confirmation)", "class_method_signature": "InstanceZTSProvider.refreshInstance(InstanceConfirmation confirmation)", "testcase": false, "constructor": false}, {"identifier": "validateSanIp", "parameters": "(final String[] sanIps, final String clientIp)", "modifiers": "", "return": "boolean", "signature": "boolean validateSanIp(final String[] sanIps, final String clientIp)", "full_signature": " boolean validateSanIp(final String[] sanIps, final String clientIp)", "class_method_signature": "InstanceZTSProvider.validateSanIp(final String[] sanIps, final String clientIp)", "testcase": false, "constructor": false}, {"identifier": "validateHostname", "parameters": "(final String hostname, final String[] sanIps)", "modifiers": "", "return": "boolean", "signature": "boolean validateHostname(final String hostname, final String[] sanIps)", "full_signature": " boolean validateHostname(final String hostname, final String[] sanIps)", "class_method_signature": "InstanceZTSProvider.validateHostname(final String hostname, final String[] sanIps)", "testcase": false, "constructor": false}, {"identifier": "validateSanUri", "parameters": "(final String sanUri, final String hostname)", "modifiers": "", "return": "boolean", "signature": "boolean validateSanUri(final String sanUri, final String hostname)", "full_signature": " boolean validateSanUri(final String sanUri, final String hostname)", "class_method_signature": "InstanceZTSProvider.validateSanUri(final String sanUri, final String hostname)", "testcase": false, "constructor": false}, {"identifier": "validateToken", "parameters": "(final String signedToken, final String domainName,\n            final String serviceName, final String csrPublicKey, StringBuilder errMsg)", "modifiers": "", "return": "boolean", "signature": "boolean validateToken(final String signedToken, final String domainName,\n            final String serviceName, final String csrPublicKey, StringBuilder errMsg)", "full_signature": " boolean validateToken(final String signedToken, final String domainName,\n            final String serviceName, final String csrPublicKey, StringBuilder errMsg)", "class_method_signature": "InstanceZTSProvider.validateToken(final String signedToken, final String domainName,\n            final String serviceName, final String csrPublicKey, StringBuilder errMsg)", "testcase": false, "constructor": false}, {"identifier": "authenticate", "parameters": "(final String signedToken, KeyStore keyStore,\n            final String csrPublicKey, StringBuilder errMsg)", "modifiers": "", "return": "PrincipalToken", "signature": "PrincipalToken authenticate(final String signedToken, KeyStore keyStore,\n            final String csrPublicKey, StringBuilder errMsg)", "full_signature": " PrincipalToken authenticate(final String signedToken, KeyStore keyStore,\n            final String csrPublicKey, StringBuilder errMsg)", "class_method_signature": "InstanceZTSProvider.authenticate(final String signedToken, KeyStore keyStore,\n            final String csrPublicKey, StringBuilder errMsg)", "testcase": false, "constructor": false}, {"identifier": "validatePublicKeys", "parameters": "(final String athenzPublicKey, final String csrPublicKey)", "modifiers": "public", "return": "boolean", "signature": "boolean validatePublicKeys(final String athenzPublicKey, final String csrPublicKey)", "full_signature": "public boolean validatePublicKeys(final String athenzPublicKey, final String csrPublicKey)", "class_method_signature": "InstanceZTSProvider.validatePublicKeys(final String athenzPublicKey, final String csrPublicKey)", "testcase": false, "constructor": false}], "file": "libs/java/instance_provider/src/main/java/com/yahoo/athenz/instance/provider/impl/InstanceZTSProvider.java"}, "focal_method": {"identifier": "validateHostname", "parameters": "(final String hostname, final String[] sanIps)", "modifiers": "", "return": "boolean", "body": "boolean validateHostname(final String hostname, final String[] sanIps) {\n\n        LOGGER.debug(\"Validating hostname: {}, sanIps: {}\", hostname, sanIps);\n\n        if (hostname == null || hostname.isEmpty()) {\n            LOGGER.info(\"Request contains no hostname entry for validation\");\n            // if more than one sanIp is passed, all sanIPs must map to hostname, and hostname is a must\n            if (sanIps != null && sanIps.length > 1) {\n                LOGGER.error(\"SanIps:{} > 1, and hostname is empty\", sanIps);\n                return false;\n            }\n            return true;\n        }\n\n        // IP in clientIp can be NATed. Rely on sanIp, which comes from the client, and is already matched with clientIp\n        // sanIp should be non-empty\n        if (sanIps == null || sanIps.length == 0) {\n            LOGGER.error(\"Request contains no sanIp entry for hostname:{} validation\", hostname);\n            return false;\n        }\n\n        // All entries in sanIP must be one of the IPs that hostname resolves\n        Set<String>  hostIps = hostnameResolver.getAllByName(hostname);\n        for (String sanIp: sanIps) {\n            if (!hostIps.contains(sanIp)) {\n                LOGGER.error(\"One of sanIp: {} is not present in HostIps: {}\", hostIps, sanIps);\n                return false;\n            }\n        }\n\n        return true;\n    }", "signature": "boolean validateHostname(final String hostname, final String[] sanIps)", "full_signature": " boolean validateHostname(final String hostname, final String[] sanIps)", "class_method_signature": "InstanceZTSProvider.validateHostname(final String hostname, final String[] sanIps)", "testcase": false, "constructor": false, "invocations": ["debug", "isEmpty", "info", "error", "error", "getAllByName", "contains", "error"]}, "repository": {"repo_id": 73948366, "url": "https://github.com/yahoo/athenz", "stars": 394, "created": "11/16/2016 6:23:08 PM +00:00", "updates": "2020-01-27T15:36:13+00:00", "fork": "False", "license": "licensed"}}