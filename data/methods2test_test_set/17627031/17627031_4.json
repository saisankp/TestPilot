{"test_class": {"identifier": "PngModuleTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String ITXTCHUNK_PNG_FILEPATH = \"src/test/resources/png/FileWithiTXtChunks.png\";", "modifier": "private static final", "type": "String", "declarator": "ITXTCHUNK_PNG_FILEPATH = \"src/test/resources/png/FileWithiTXtChunks.png\"", "var_name": "ITXTCHUNK_PNG_FILEPATH"}, {"original_string": "private static final String PNG_MIMETYPE = \"image/png\";", "modifier": "private static final", "type": "String", "declarator": "PNG_MIMETYPE = \"image/png\"", "var_name": "PNG_MIMETYPE"}], "file": "jhove-ext-modules/src/test/java/com/mcgath/jhove/module/PngModuleTest.java"}, "test_case": {"identifier": "parsePngWithItxtChunk", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void parsePngWithItxtChunk() throws Exception {\n        final String EXPECTED_ITXTTITLE_VALUE = \"PngSuite\";\n        final String EXPECTED_ITXTDISCLAIMER_VALUE = \"Freeware.\";\n        final String PROP_KEYWORDS = \"Keywords\";\n        final String PROP_VALUE = \"Value\";\n\n        File pngFile = new File(ITXTCHUNK_PNG_FILEPATH);\n\n        RepInfo info = new RepInfo(pngFile.getAbsolutePath());\n        PngModule pngMod = new PngModule();\n        pngMod.parse(new FileInputStream(pngFile), info, 0);\n\n        int wellformed = info.getWellFormed();\n        int valid = info.getValid();\n        String type = info.getMimeType();\n\n        // General checks\n        assertEquals(1, wellformed);\n        assertEquals(1, valid);\n        assertEquals(PNG_MIMETYPE, type);\n\n        // Check the value of the first iTXt is as expected\n        Set<String> keywordValues = new HashSet<String>();\n        @SuppressWarnings(\"unchecked\")\n        LinkedList<Property> iTxtKeywordProperties = (LinkedList<Property>) info.getByName(PROP_KEYWORDS).getValue();\n        for (Property prop : iTxtKeywordProperties) {\n            keywordValues.add(prop.getByName(PROP_VALUE).getValue().toString());\n        }\n\n        assertEquals(6, keywordValues.size());\n        assertTrue(keywordValues.contains(EXPECTED_ITXTTITLE_VALUE));\n        assertTrue(keywordValues.contains(EXPECTED_ITXTDISCLAIMER_VALUE));\n    }", "signature": "void parsePngWithItxtChunk()", "full_signature": "@Test public void parsePngWithItxtChunk()", "class_method_signature": "PngModuleTest.parsePngWithItxtChunk()", "testcase": true, "constructor": false, "invocations": ["getAbsolutePath", "parse", "getWellFormed", "getValid", "getMimeType", "assertEquals", "assertEquals", "assertEquals", "getValue", "getByName", "add", "toString", "getValue", "getByName", "assertEquals", "size", "assertTrue", "contains", "assertTrue", "contains"]}, "focal_class": {"identifier": "PngModule", "superclass": "extends ModuleBase", "interfaces": "", "fields": [{"original_string": "private static final String NAME = \"PNG-gdm\";", "modifier": "private static final", "type": "String", "declarator": "NAME = \"PNG-gdm\"", "var_name": "NAME"}, {"original_string": "private static final String RELEASE = \"1.0\";", "modifier": "private static final", "type": "String", "declarator": "RELEASE = \"1.0\"", "var_name": "RELEASE"}, {"original_string": "private static final int [] DATE = {2016, 2, 25};", "modifier": "private static final", "type": "int []", "declarator": "DATE = {2016, 2, 25}", "var_name": "DATE"}, {"original_string": "private static final String [] FORMAT = {\n    \t\"PNG\", \" ISO/IEC 15948:2003\", \"Portable Network Graphics\"\n    };", "modifier": "private static final", "type": "String []", "declarator": "FORMAT = {\n    \t\"PNG\", \" ISO/IEC 15948:2003\", \"Portable Network Graphics\"\n    }", "var_name": "FORMAT"}, {"original_string": "private static final String COVERAGE = \n    \t\"PNG (ISO/IEC 15948:2003)\";", "modifier": "private static final", "type": "String", "declarator": "COVERAGE = \n    \t\"PNG (ISO/IEC 15948:2003)\"", "var_name": "COVERAGE"}, {"original_string": "private static final String [] MIMETYPE = {\"image/png\"};", "modifier": "private static final", "type": "String []", "declarator": "MIMETYPE = {\"image/png\"}", "var_name": "MIMETYPE"}, {"original_string": "private static final String WELLFORMED = \"Put well-formedness criteria here\";", "modifier": "private static final", "type": "String", "declarator": "WELLFORMED = \"Put well-formedness criteria here\"", "var_name": "WELLFORMED"}, {"original_string": "private static final String VALIDITY = \"Put validity criteria here\";", "modifier": "private static final", "type": "String", "declarator": "VALIDITY = \"Put validity criteria here\"", "var_name": "VALIDITY"}, {"original_string": "private static final String REPINFO = \"Put repinfo note here\";", "modifier": "private static final", "type": "String", "declarator": "REPINFO = \"Put repinfo note here\"", "var_name": "REPINFO"}, {"original_string": "private static final String NOTE = null;", "modifier": "private static final", "type": "String", "declarator": "NOTE = null", "var_name": "NOTE"}, {"original_string": "private static final String RIGHTS = \"Copyright 2016 by Gary McGath. \" +\n\t\t\t\"Released under the GNU Lesser General Public License.\";", "modifier": "private static final", "type": "String", "declarator": "RIGHTS = \"Copyright 2016 by Gary McGath. \" +\n\t\t\t\"Released under the GNU Lesser General Public License.\"", "var_name": "RIGHTS"}, {"original_string": "private static final String NISO_IMAGE_MD = \"NisoImageMetadata\";", "modifier": "private static final", "type": "String", "declarator": "NISO_IMAGE_MD = \"NisoImageMetadata\"", "var_name": "NISO_IMAGE_MD"}, {"original_string": "protected Checksummer _ckSummer;", "modifier": "protected", "type": "Checksummer", "declarator": "_ckSummer", "var_name": "_ckSummer"}, {"original_string": "protected List<Property> _propList;", "modifier": "protected", "type": "List<Property>", "declarator": "_propList", "var_name": "_propList"}, {"original_string": "protected List<Property> _keywordPropList;", "modifier": "protected", "type": "List<Property>", "declarator": "_keywordPropList", "var_name": "_keywordPropList"}, {"original_string": "protected List<Property> _spltList;", "modifier": "protected", "type": "List<Property>", "declarator": "_spltList", "var_name": "_spltList"}, {"original_string": "protected ChecksumInputStream _cstream;", "modifier": "protected", "type": "ChecksumInputStream", "declarator": "_cstream", "var_name": "_cstream"}, {"original_string": "protected DataInputStream _dstream;", "modifier": "protected", "type": "DataInputStream", "declarator": "_dstream", "var_name": "_dstream"}, {"original_string": "protected Property _metadata;", "modifier": "protected", "type": "Property", "declarator": "_metadata", "var_name": "_metadata"}, {"original_string": "NisoImageMetadata _nisoData;", "modifier": "", "type": "NisoImageMetadata", "declarator": "_nisoData", "var_name": "_nisoData"}, {"original_string": "protected int _colorType;", "modifier": "protected", "type": "int", "declarator": "_colorType", "var_name": "_colorType"}, {"original_string": "private Set<Integer> _ancillaryChunks;", "modifier": "private", "type": "Set<Integer>", "declarator": "_ancillaryChunks", "var_name": "_ancillaryChunks"}, {"original_string": "private boolean ihdrSeen;", "modifier": "private", "type": "boolean", "declarator": "ihdrSeen", "var_name": "ihdrSeen"}, {"original_string": "private boolean plteSeen;", "modifier": "private", "type": "boolean", "declarator": "plteSeen", "var_name": "plteSeen"}, {"original_string": "private boolean idatSeen;", "modifier": "private", "type": "boolean", "declarator": "idatSeen", "var_name": "idatSeen"}, {"original_string": "private boolean idatFinished;", "modifier": "private", "type": "boolean", "declarator": "idatFinished", "var_name": "idatFinished"}, {"original_string": "private boolean iendSeen;", "modifier": "private", "type": "boolean", "declarator": "iendSeen", "var_name": "iendSeen"}, {"original_string": "private final static int _sigBytes[] = { 137, 80, 78, 71, 13, 10, 26, 10 };", "modifier": "private final static", "type": "int", "declarator": "_sigBytes[] = { 137, 80, 78, 71, 13, 10, 26, 10 }", "var_name": "_sigBytes"}], "methods": [{"identifier": "PngModule", "parameters": "()", "modifiers": "public", "return": "", "signature": " PngModule()", "full_signature": "public  PngModule()", "class_method_signature": "PngModule.PngModule()", "testcase": false, "constructor": true}, {"identifier": "checkSignatures", "parameters": "(File file, InputStream stream, RepInfo info)", "modifiers": "@Override public", "return": "void", "signature": "void checkSignatures(File file, InputStream stream, RepInfo info)", "full_signature": "@Override public void checkSignatures(File file, InputStream stream, RepInfo info)", "class_method_signature": "PngModule.checkSignatures(File file, InputStream stream, RepInfo info)", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "(InputStream stream, RepInfo info, int parseIndex)", "modifiers": "@Override public", "return": "int", "signature": "int parse(InputStream stream, RepInfo info, int parseIndex)", "full_signature": "@Override public int parse(InputStream stream, RepInfo info, int parseIndex)", "class_method_signature": "PngModule.parse(InputStream stream, RepInfo info, int parseIndex)", "testcase": false, "constructor": false}, {"identifier": "eatChunk", "parameters": "(PNGChunk chnk)", "modifiers": "public", "return": "void", "signature": "void eatChunk(PNGChunk chnk)", "full_signature": "public void eatChunk(PNGChunk chnk)", "class_method_signature": "PngModule.eatChunk(PNGChunk chnk)", "testcase": false, "constructor": false}, {"identifier": "addKeyword", "parameters": "(String keywd, String val)", "modifiers": "public", "return": "void", "signature": "void addKeyword(String keywd, String val)", "full_signature": "public void addKeyword(String keywd, String val)", "class_method_signature": "PngModule.addKeyword(String keywd, String val)", "testcase": false, "constructor": false}, {"identifier": "addKeyword", "parameters": "(String keywd, String translatedKeywd, String val, String language)", "modifiers": "public", "return": "void", "signature": "void addKeyword(String keywd, String translatedKeywd, String val, String language)", "full_signature": "public void addKeyword(String keywd, String translatedKeywd, String val, String language)", "class_method_signature": "PngModule.addKeyword(String keywd, String translatedKeywd, String val, String language)", "testcase": false, "constructor": false}, {"identifier": "addSplt", "parameters": "(String name, int sampleDepth, int numSamples)", "modifiers": "public", "return": "void", "signature": "void addSplt(String name, int sampleDepth, int numSamples)", "full_signature": "public void addSplt(String name, int sampleDepth, int numSamples)", "class_method_signature": "PngModule.addSplt(String name, int sampleDepth, int numSamples)", "testcase": false, "constructor": false}, {"identifier": "initParse", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void initParse()", "full_signature": "@Override protected void initParse()", "class_method_signature": "PngModule.initParse()", "testcase": false, "constructor": false}, {"identifier": "readChunkHead", "parameters": "(DataInputStream dstrm)", "modifiers": "private", "return": "PNGChunk", "signature": "PNGChunk readChunkHead(DataInputStream dstrm)", "full_signature": "private PNGChunk readChunkHead(DataInputStream dstrm)", "class_method_signature": "PngModule.readChunkHead(DataInputStream dstrm)", "testcase": false, "constructor": false}, {"identifier": "setIhdrSeen", "parameters": "(boolean b)", "modifiers": "public", "return": "void", "signature": "void setIhdrSeen(boolean b)", "full_signature": "public void setIhdrSeen(boolean b)", "class_method_signature": "PngModule.setIhdrSeen(boolean b)", "testcase": false, "constructor": false}, {"identifier": "isIhdrSeen", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isIhdrSeen()", "full_signature": "public boolean isIhdrSeen()", "class_method_signature": "PngModule.isIhdrSeen()", "testcase": false, "constructor": false}, {"identifier": "setIdatSeen", "parameters": "(boolean b)", "modifiers": "public", "return": "void", "signature": "void setIdatSeen(boolean b)", "full_signature": "public void setIdatSeen(boolean b)", "class_method_signature": "PngModule.setIdatSeen(boolean b)", "testcase": false, "constructor": false}, {"identifier": "setPlteSeen", "parameters": "(boolean b)", "modifiers": "public", "return": "void", "signature": "void setPlteSeen(boolean b)", "full_signature": "public void setPlteSeen(boolean b)", "class_method_signature": "PngModule.setPlteSeen(boolean b)", "testcase": false, "constructor": false}, {"identifier": "setIendSeen", "parameters": "(boolean b)", "modifiers": "public", "return": "void", "signature": "void setIendSeen(boolean b)", "full_signature": "public void setIendSeen(boolean b)", "class_method_signature": "PngModule.setIendSeen(boolean b)", "testcase": false, "constructor": false}, {"identifier": "isIdatSeen", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isIdatSeen()", "full_signature": "public boolean isIdatSeen()", "class_method_signature": "PngModule.isIdatSeen()", "testcase": false, "constructor": false}, {"identifier": "isIdatFinished", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isIdatFinished()", "full_signature": "public boolean isIdatFinished()", "class_method_signature": "PngModule.isIdatFinished()", "testcase": false, "constructor": false}, {"identifier": "isPlteSeen", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isPlteSeen()", "full_signature": "public boolean isPlteSeen()", "class_method_signature": "PngModule.isPlteSeen()", "testcase": false, "constructor": false}, {"identifier": "setChunkSeen", "parameters": "(int chunkType)", "modifiers": "public", "return": "void", "signature": "void setChunkSeen(int chunkType)", "full_signature": "public void setChunkSeen(int chunkType)", "class_method_signature": "PngModule.setChunkSeen(int chunkType)", "testcase": false, "constructor": false}, {"identifier": "isChunkSeen", "parameters": "(int chunkType)", "modifiers": "public", "return": "boolean", "signature": "boolean isChunkSeen(int chunkType)", "full_signature": "public boolean isChunkSeen(int chunkType)", "class_method_signature": "PngModule.isChunkSeen(int chunkType)", "testcase": false, "constructor": false}, {"identifier": "setColorType", "parameters": "(int ct)", "modifiers": "public", "return": "void", "signature": "void setColorType(int ct)", "full_signature": "public void setColorType(int ct)", "class_method_signature": "PngModule.setColorType(int ct)", "testcase": false, "constructor": false}, {"identifier": "getColorType", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getColorType()", "full_signature": "public int getColorType()", "class_method_signature": "PngModule.getColorType()", "testcase": false, "constructor": false}], "file": "jhove-ext-modules/src/main/java/com/mcgath/jhove/module/PngModule.java"}, "focal_method": {"identifier": "parse", "parameters": "(InputStream stream, RepInfo info, int parseIndex)", "modifiers": "@Override public", "return": "int", "body": "@Override\n\tpublic int parse (InputStream stream, RepInfo info, int parseIndex)\n        throws IOException\n    {\n        initParse ();\n        info.setFormat (_format[0]);\n        info.setMimeType (_mimeType[0]);\n        info.setModule (this);\n        /* We may have already done the checksums while converting a\n        temporary file. */\n        _ckSummer = null;\n        if (_je != null && _je.getChecksumFlag () &&\n        \t\tinfo.getChecksum ().size () == 0) {\n        \t_ckSummer = new Checksummer ();\n        \t_cstream = new ChecksumInputStream (stream, _ckSummer);\n        \t_dstream = getBufferedDataStream (_cstream, _je != null ?\n                 _je.getBufferSize () : 0);\n        }\n        else {\n        \t_dstream = getBufferedDataStream (stream, _je != null ?\n                 _je.getBufferSize () : 0);\n        }\n        _propList = new LinkedList<> ();\n        _metadata = new Property (\"PNGMetadata\",\n             PropertyType.PROPERTY,\n             PropertyArity.LIST,\n             _propList);\n        _nisoData = new NisoImageMetadata();\n        Property nisoProp = new Property(NISO_IMAGE_MD,\n                PropertyType.NISOIMAGEMETADATA, _nisoData);\n        _propList.add(nisoProp);\n        _keywordPropList = new LinkedList<> ();\n        _spltList = new LinkedList<> ();\n        ErrorMessage msg;\n        \n        // Check that the file header matching the PNG magic numbers\n        for (int i = 0; i < _sigBytes.length; i++) {\n        \tint byt = readUnsignedByte (_dstream);\n        \tif (byt != _sigBytes[i]) {\n        \t\tmsg = new ErrorMessage(MessageConstants.PNG_GDM_66);\n        \t\tinfo.setMessage(msg);\n        \t\tinfo.setWellFormed(false);\n        \t\treturn 0;\n        \t}\n        }\n        \n        // Loop through the chunks\n        try {\n        \tfor (;;) {\n        \t\tPNGChunk chunk = readChunkHead(_dstream);\n        \t\tif (chunk == null) {\n        \t\t\tbreak;\n        \t\t}\n        \t\tif (iendSeen) {\n        \t\t\tmsg = new ErrorMessage (MessageConstants.PNG_GDM_67);\n        \t\t\tinfo.setMessage (msg);\n        \t\t\tinfo.setWellFormed (false);\n        \t\t\treturn 0;\n        \t\t}\n        \t\tif (idatSeen && !(chunk instanceof IdatChunk)) {\n        \t\t\tidatFinished = true;\n        \t\t}\n        \t\tchunk.setModule(this);\n        \t\tchunk.setInputStream(_dstream);\n        \t\tchunk.setNisoMetadata(_nisoData);\n        \t\tchunk.setPropertyList(_propList);\n        \t\tchunk.processChunk(info);\n        \t\tlong storedCRC = chunk.readCRC();\n        \t\tlong calculatedCRC = chunk.getCRC();\n        \t\tif (storedCRC != calculatedCRC) {\n        \t\t\tmsg = new ErrorMessage(String.format (\n\t\t\t\t\t\t\tMessageConstants.PNG_GDM_68.getMessage() , \n\t\t\t\t\t\t\tchunk.chunkTypeString()));\n        \t\t\tinfo.setMessage(msg);\n        \t\t\tinfo.setWellFormed(false);\n        \t\t\treturn 0;\n        \t\t}\n        \t}\n        }\n        catch (PNGException e) {\n        \t// We've already reported a problem, so we just clean up here.\n        \treturn 0;\n        }\n        catch (EOFException e) {\n        \tmsg = new ErrorMessage (\n        \t\t\tString.format (\n        \t\t\t\t\tMessageConstants.PNG_GDM_69.getMessage(),\n        \t\t\t\t\t_nByte));\n        \tinfo.setMessage (msg);\n        \tinfo.setWellFormed (false);\n        \treturn 0;\n        }\n        catch (Exception e) {\n        \t// Miscellaneous exceptions really shouldn't come here.\n        \t// But it's better to catch them than let them fall through.\n        \t// Treat them as bugs.\n        \tmsg = new ErrorMessage (\n        \t\t\tString.format (\n        \t\t\t\t\tMessageConstants.PNG_GDM_70.getMessage() , \n        \t\t\t\t\te.getClass().getName()));\n        \tinfo.setMessage (msg);\n        \tinfo.setWellFormed (false);\n        \treturn 0;\n        }\n        \n        /* Check for required chunks. */\n        boolean criticalMissing = false;\n        if (!ihdrSeen) {\n        \tmsg = new ErrorMessage(MessageConstants.PNG_GDM_71);\n        \tinfo.setMessage (msg);\n        \tcriticalMissing = true;\n        }\n        if (!idatSeen) {\n        \tmsg = new ErrorMessage(MessageConstants.PNG_GDM_72);\n        \tinfo.setMessage (msg);\n        \tcriticalMissing = true;\n        }\n        if (!iendSeen) {\n        \tmsg = new ErrorMessage(MessageConstants.PNG_GDM_73);\n        \tinfo.setMessage (msg);\n        \tcriticalMissing = true;\n        }\n        if (criticalMissing) {\n        \tinfo.setWellFormed (false);\n        \treturn 0;\n\t\t}\n        \n        /** PLTE is required with color type 3 and forbidden with types 0 and 4 */\n        if (_colorType == 3 && !plteSeen) {\n        \tmsg = new ErrorMessage (MessageConstants.PNG_GDM_74);\n\t\t\tinfo.setMessage (msg);\n        \tinfo.setWellFormed (false);\n\t\t\treturn 0;\n        }\n        \n        if ((_colorType == 0 || _colorType == 4) && plteSeen) {\n\t\t\tmsg = new ErrorMessage (MessageConstants.PNG_GDM_75);\n\t\t\tinfo.setMessage (msg);\n        \tinfo.setWellFormed (false);\n\t\t\treturn 0;\n        }\n\n        // Add the keyword property list if it isn't empty.\n        if (!_keywordPropList.isEmpty()) {\n        \t_propList.add(new Property (\"Keywords\",\n        \t\t\tPropertyType.PROPERTY,\n        \t\t\tPropertyArity.LIST,\n        \t\t\t_keywordPropList));\n        \t\t\t\n        }\n        \n        // Add the splat property list if it isn't empty.\n        if (!_spltList.isEmpty()) {\n        \t_propList.add(new Property (\"Suggested palettes\",\n        \t\t\tPropertyType.PROPERTY,\n        \t\t\tPropertyArity.LIST,\n        \t\t\t_spltList));\n        }\n        info.setProperty (_metadata);\n        return 0;\n    }", "signature": "int parse(InputStream stream, RepInfo info, int parseIndex)", "full_signature": "@Override public int parse(InputStream stream, RepInfo info, int parseIndex)", "class_method_signature": "PngModule.parse(InputStream stream, RepInfo info, int parseIndex)", "testcase": false, "constructor": false, "invocations": ["initParse", "setFormat", "setMimeType", "setModule", "getChecksumFlag", "size", "getChecksum", "getBufferedDataStream", "getBufferSize", "getBufferedDataStream", "getBufferSize", "add", "readUnsignedByte", "setMessage", "setWellFormed", "readChunkHead", "setMessage", "setWellFormed", "setModule", "setInputStream", "setNisoMetadata", "setPropertyList", "processChunk", "readCRC", "getCRC", "format", "getMessage", "chunkTypeString", "setMessage", "setWellFormed", "format", "getMessage", "setMessage", "setWellFormed", "format", "getMessage", "getName", "getClass", "setMessage", "setWellFormed", "setMessage", "setMessage", "setMessage", "setWellFormed", "setMessage", "setWellFormed", "setMessage", "setWellFormed", "isEmpty", "add", "isEmpty", "add", "setProperty"]}, "repository": {"repo_id": 17627031, "url": "https://github.com/openpreserve/jhove", "stars": 91, "created": "3/11/2014 10:47:10 AM +00:00", "updates": "2020-01-24T19:19:11+00:00", "fork": "False", "license": "licensed"}}