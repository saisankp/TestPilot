{"test_class": {"identifier": "TableTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final List<Element> cells1 = new ArrayList<Element>();", "modifier": "private final", "type": "List<Element>", "declarator": "cells1 = new ArrayList<Element>()", "var_name": "cells1"}, {"original_string": "private final List<Element> cells2 = new ArrayList<Element>();", "modifier": "private final", "type": "List<Element>", "declarator": "cells2 = new ArrayList<Element>()", "var_name": "cells2"}, {"original_string": "private final List<Element> rows = new ArrayList<Element>();", "modifier": "private final", "type": "List<Element>", "declarator": "rows = new ArrayList<Element>()", "var_name": "rows"}, {"original_string": "Tag tag = new Tag(null, new HashMap<String, String>());", "modifier": "", "type": "Tag", "declarator": "tag = new Tag(null, new HashMap<String, String>())", "var_name": "tag"}, {"original_string": "private final NoNewLineParagraph basicPara = new NoNewLineParagraph();", "modifier": "private final", "type": "NoNewLineParagraph", "declarator": "basicPara = new NoNewLineParagraph()", "var_name": "basicPara"}, {"original_string": "private final NoNewLineParagraph extraPara = new NoNewLineParagraph();", "modifier": "private final", "type": "NoNewLineParagraph", "declarator": "extraPara = new NoNewLineParagraph()", "var_name": "extraPara"}, {"original_string": "private final Chunk basic = new Chunk(\"content\");", "modifier": "private final", "type": "Chunk", "declarator": "basic = new Chunk(\"content\")", "var_name": "basic"}, {"original_string": "private final Chunk extra = new Chunk(\"extra content\");", "modifier": "private final", "type": "Chunk", "declarator": "extra = new Chunk(\"extra content\")", "var_name": "extra"}, {"original_string": "private TableRowElement row1;", "modifier": "private", "type": "TableRowElement", "declarator": "row1", "var_name": "row1"}, {"original_string": "private final HtmlCell cell1Row1 = new HtmlCell();", "modifier": "private final", "type": "HtmlCell", "declarator": "cell1Row1 = new HtmlCell()", "var_name": "cell1Row1"}, {"original_string": "private final HtmlCell cell2Row1 = new HtmlCell();", "modifier": "private final", "type": "HtmlCell", "declarator": "cell2Row1 = new HtmlCell()", "var_name": "cell2Row1"}, {"original_string": "private final HtmlCell cell3Row1 = new HtmlCell();", "modifier": "private final", "type": "HtmlCell", "declarator": "cell3Row1 = new HtmlCell()", "var_name": "cell3Row1"}, {"original_string": "private final HtmlCell cell4Row1 = new HtmlCell();", "modifier": "private final", "type": "HtmlCell", "declarator": "cell4Row1 = new HtmlCell()", "var_name": "cell4Row1"}, {"original_string": "private TableRowElement row2;", "modifier": "private", "type": "TableRowElement", "declarator": "row2", "var_name": "row2"}, {"original_string": "private final HtmlCell cell1Row2 = new HtmlCell();", "modifier": "private final", "type": "HtmlCell", "declarator": "cell1Row2 = new HtmlCell()", "var_name": "cell1Row2"}, {"original_string": "private final HtmlCell cell2Row2 = new HtmlCell();", "modifier": "private final", "type": "HtmlCell", "declarator": "cell2Row2 = new HtmlCell()", "var_name": "cell2Row2"}, {"original_string": "private final HtmlCell cell3Row2 = new HtmlCell();", "modifier": "private final", "type": "HtmlCell", "declarator": "cell3Row2 = new HtmlCell()", "var_name": "cell3Row2"}], "file": "xmlworker/src/test/java/com/itextpdf/tool/xml/html/table/TableTest.java"}, "test_case": {"identifier": "resolveBuild", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void resolveBuild() {\n\t\tAbstractTagProcessor table2 = new Table();\n        table2.setCssAppliers(new CssAppliersImpl());\n\t\tWorkerContextImpl context = new WorkerContextImpl();\n\t\tcontext.put(HtmlPipeline.class.getName(), new HtmlPipelineContext(null));\n\t\tPdfPTable table = (PdfPTable) (table2.end(context, tag, rows).get(0));\n\t\tassertEquals(4, table.getRow(0).getCells().length);\n\t\tassertEquals(4, table.getNumberOfColumns());\n\t}", "signature": "void resolveBuild()", "full_signature": "@Test public void resolveBuild()", "class_method_signature": "TableTest.resolveBuild()", "testcase": true, "constructor": false, "invocations": ["setCssAppliers", "put", "getName", "get", "end", "assertEquals", "getCells", "getRow", "assertEquals", "getNumberOfColumns"]}, "focal_class": {"identifier": "Table", "superclass": "extends AbstractTagProcessor", "interfaces": "", "fields": [{"original_string": "public static final float DEFAULT_CELL_BORDER_WIDTH = 0.75f;", "modifier": "public static final", "type": "float", "declarator": "DEFAULT_CELL_BORDER_WIDTH = 0.75f", "var_name": "DEFAULT_CELL_BORDER_WIDTH"}, {"original_string": "private static final Logger LOG = LoggerFactory.getLogger(Table.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(Table.class)", "var_name": "LOG"}, {"original_string": "private static final CssUtils utils = CssUtils.getInstance();", "modifier": "private static final", "type": "CssUtils", "declarator": "utils = CssUtils.getInstance()", "var_name": "utils"}, {"original_string": "private static final FontSizeTranslator fst = FontSizeTranslator.getInstance();", "modifier": "private static final", "type": "FontSizeTranslator", "declarator": "fst = FontSizeTranslator.getInstance()", "var_name": "fst"}], "methods": [{"identifier": "Table", "parameters": "()", "modifiers": "public", "return": "", "signature": " Table()", "full_signature": "public  Table()", "class_method_signature": "Table.Table()", "testcase": false, "constructor": true}, {"identifier": "end", "parameters": "(final WorkerContext ctx, final Tag tag, final List<Element> currentContent)", "modifiers": "@Override public", "return": "List<Element>", "signature": "List<Element> end(final WorkerContext ctx, final Tag tag, final List<Element> currentContent)", "full_signature": "@Override public List<Element> end(final WorkerContext ctx, final Tag tag, final List<Element> currentContent)", "class_method_signature": "Table.end(final WorkerContext ctx, final Tag tag, final List<Element> currentContent)", "testcase": false, "constructor": false}, {"identifier": "intPdfPTable", "parameters": "(int numberOfColumn)", "modifiers": "protected", "return": "PdfPTable", "signature": "PdfPTable intPdfPTable(int numberOfColumn)", "full_signature": "protected PdfPTable intPdfPTable(int numberOfColumn)", "class_method_signature": "Table.intPdfPTable(int numberOfColumn)", "testcase": false, "constructor": false}, {"identifier": "calculateTargetWidth", "parameters": "(final Tag tag, final float[] columnWidths, final float outerWidth,\n\t\t\tfinal WorkerContext ctx)", "modifiers": "@SuppressWarnings(\"unused\") private", "return": "float", "signature": "float calculateTargetWidth(final Tag tag, final float[] columnWidths, final float outerWidth,\n\t\t\tfinal WorkerContext ctx)", "full_signature": "@SuppressWarnings(\"unused\") private float calculateTargetWidth(final Tag tag, final float[] columnWidths, final float outerWidth,\n\t\t\tfinal WorkerContext ctx)", "class_method_signature": "Table.calculateTargetWidth(final Tag tag, final float[] columnWidths, final float outerWidth,\n\t\t\tfinal WorkerContext ctx)", "testcase": false, "constructor": false}, {"identifier": "widenLastCell", "parameters": "(final List<TableRowElement> tableRows, final float horBorderSpacing)", "modifiers": "private", "return": "void", "signature": "void widenLastCell(final List<TableRowElement> tableRows, final float horBorderSpacing)", "full_signature": "private void widenLastCell(final List<TableRowElement> tableRows, final float horBorderSpacing)", "class_method_signature": "Table.widenLastCell(final List<TableRowElement> tableRows, final float horBorderSpacing)", "testcase": false, "constructor": false}, {"identifier": "setStyleValues", "parameters": "(final Tag tag)", "modifiers": "public static", "return": "TableStyleValues", "signature": "TableStyleValues setStyleValues(final Tag tag)", "full_signature": "public static TableStyleValues setStyleValues(final Tag tag)", "class_method_signature": "Table.setStyleValues(final Tag tag)", "testcase": false, "constructor": false}, {"identifier": "setBorderAttributeForCell", "parameters": "(final Tag tag)", "modifiers": "public static", "return": "TableStyleValues", "signature": "TableStyleValues setBorderAttributeForCell(final Tag tag)", "full_signature": "public static TableStyleValues setBorderAttributeForCell(final Tag tag)", "class_method_signature": "Table.setBorderAttributeForCell(final Tag tag)", "testcase": false, "constructor": false}, {"identifier": "getBorderOrCellSpacing", "parameters": "(final boolean getHor, final Map<String, String> css,\n\t\t\tfinal Map<String, String> attributes)", "modifiers": "static public", "return": "float", "signature": "float getBorderOrCellSpacing(final boolean getHor, final Map<String, String> css,\n\t\t\tfinal Map<String, String> attributes)", "full_signature": "static public float getBorderOrCellSpacing(final boolean getHor, final Map<String, String> css,\n\t\t\tfinal Map<String, String> attributes)", "class_method_signature": "Table.getBorderOrCellSpacing(final boolean getHor, final Map<String, String> css,\n\t\t\tfinal Map<String, String> attributes)", "testcase": false, "constructor": false}, {"identifier": "setCellWidthAndWidestWord", "parameters": "(final HtmlCell cell)", "modifiers": "private", "return": "float[]", "signature": "float[] setCellWidthAndWidestWord(final HtmlCell cell)", "full_signature": "private float[] setCellWidthAndWidestWord(final HtmlCell cell)", "class_method_signature": "Table.setCellWidthAndWidestWord(final HtmlCell cell)", "testcase": false, "constructor": false}, {"identifier": "calculateDivWidestElementWidth", "parameters": "(ArrayList<Element> divContent)", "modifiers": "private", "return": "float", "signature": "float calculateDivWidestElementWidth(ArrayList<Element> divContent)", "full_signature": "private float calculateDivWidestElementWidth(ArrayList<Element> divContent)", "class_method_signature": "Table.calculateDivWidestElementWidth(ArrayList<Element> divContent)", "testcase": false, "constructor": false}, {"identifier": "getTableWidth", "parameters": "(final float[] widths, final float outerWidth)", "modifiers": "private", "return": "float", "signature": "float getTableWidth(final float[] widths, final float outerWidth)", "full_signature": "private float getTableWidth(final float[] widths, final float outerWidth)", "class_method_signature": "Table.getTableWidth(final float[] widths, final float outerWidth)", "testcase": false, "constructor": false}, {"identifier": "getTableOuterWidth", "parameters": "(final Tag tag, final float horBorderSpacing, final WorkerContext ctx)", "modifiers": "private", "return": "float", "signature": "float getTableOuterWidth(final Tag tag, final float horBorderSpacing, final WorkerContext ctx)", "full_signature": "private float getTableOuterWidth(final Tag tag, final float horBorderSpacing, final WorkerContext ctx)", "class_method_signature": "Table.getTableOuterWidth(final Tag tag, final float horBorderSpacing, final WorkerContext ctx)", "testcase": false, "constructor": false}, {"identifier": "getCellStartWidth", "parameters": "(final HtmlCell cell)", "modifiers": "private", "return": "float", "signature": "float getCellStartWidth(final HtmlCell cell)", "full_signature": "private float getCellStartWidth(final HtmlCell cell)", "class_method_signature": "Table.getCellStartWidth(final HtmlCell cell)", "testcase": false, "constructor": false}, {"identifier": "setVerticalMargin", "parameters": "(final PdfPTable table, final Tag t, final TableStyleValues values,\n\t\t\tfinal WorkerContext ctx)", "modifiers": "private", "return": "void", "signature": "void setVerticalMargin(final PdfPTable table, final Tag t, final TableStyleValues values,\n\t\t\tfinal WorkerContext ctx)", "full_signature": "private void setVerticalMargin(final PdfPTable table, final Tag t, final TableStyleValues values,\n\t\t\tfinal WorkerContext ctx)", "class_method_signature": "Table.setVerticalMargin(final PdfPTable table, final Tag t, final TableStyleValues values,\n\t\t\tfinal WorkerContext ctx)", "testcase": false, "constructor": false}, {"identifier": "isStackOwner", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isStackOwner()", "full_signature": "@Override public boolean isStackOwner()", "class_method_signature": "Table.isStackOwner()", "testcase": false, "constructor": false}], "file": "xmlworker/src/main/java/com/itextpdf/tool/xml/html/table/Table.java"}, "focal_method": {"identifier": "end", "parameters": "(final WorkerContext ctx, final Tag tag, final List<Element> currentContent)", "modifiers": "@Override public", "return": "List<Element>", "body": "@Override\n\tpublic List<Element> end(final WorkerContext ctx, final Tag tag, final List<Element> currentContent) {\n\t\ttry {\n\t\t\tboolean percentage = false;\n\t\t\tString widthValue = tag.getCSS().get(HTML.Attribute.WIDTH);\n\t\t\tif(widthValue == null) {\n\t\t\t\twidthValue = tag.getAttributes().get(HTML.Attribute.WIDTH);\n\t\t\t}\n\t\t\tif(widthValue != null && widthValue.trim().endsWith(\"%\")) {\n\t\t\t\tpercentage = true;\n\t\t\t}\n\n\t\t\tint numberOfColumns = 0;\n\t\t\tList<TableRowElement> tableRows = new ArrayList<TableRowElement>(currentContent.size());\n\t\t\tList<Element> invalidRowElements = new ArrayList<Element>(1);\n\t\t\tString repeatHeader = tag.getCSS().get(CSS.Property.REPEAT_HEADER);\n\t\t\tString repeatFooter = tag.getCSS().get(CSS.Property.REPEAT_FOOTER);\n\t\t\tint headerRows = 0;\n\t\t\tint footerRows = 0;\n\t\t\tfor (Element e : currentContent) {\n\t\t\t\tint localNumCols = 0;\n\t\t\t\tif (e instanceof TableRowElement) {\n\t\t\t\t\tTableRowElement tableRowElement = (TableRowElement) e;\n\t\t\t\t\tfor (HtmlCell cell : tableRowElement.getContent()) {\n\t\t\t\t\t\tlocalNumCols += cell.getColspan();\n\t\t\t\t\t}\n\t\t\t\t\tif (localNumCols > numberOfColumns) {\n\t\t\t\t\t\tnumberOfColumns = localNumCols;\n\t\t\t\t\t}\n\t\t\t\t\ttableRows.add(tableRowElement);\n\t\t\t\t\tif (repeatHeader != null && repeatHeader.equalsIgnoreCase(\"yes\")\n\t\t\t\t\t\t\t&& tableRowElement.getPlace().equals(TableRowElement.Place.HEADER)) {\n\t\t\t\t\t\theaderRows++;\n\t\t\t\t\t}\n\t\t\t\t\tif (repeatFooter != null && repeatFooter.equalsIgnoreCase(\"yes\")\n\t\t\t\t\t\t\t&& tableRowElement.getPlace().equals(TableRowElement.Place.FOOTER)) {\n\t\t\t\t\t\tfooterRows++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinvalidRowElements.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (repeatFooter == null || !repeatFooter.equalsIgnoreCase(\"yes\")) {\n\t\t\t\tCollections.sort(tableRows, new NormalRowComparator());\n\t\t\t} else {\n\t\t\t\tCollections.sort(tableRows, new RepeatedRowComparator());\n\t\t\t}\n            PdfPTable table = intPdfPTable(numberOfColumns);\n            table.setHeaderRows(headerRows + footerRows);\n            table.setFooterRows(footerRows);\n            \n            if ( tag.getAttributes().containsKey(HTML.Attribute.ALIGN)) {\n                String value = tag.getAttributes().get(HTML.Attribute.ALIGN);\n\t\t\t\t// TODO this property is inverted when RTL. so we should counter-invert here, probably.\n                table.setHorizontalAlignment(CSS.getElementAlignment(value));\n            }\n            \n            int direction = getRunDirection(tag);\n//            if (direction != PdfWriter.RUN_DIRECTION_DEFAULT) {\n                table.setRunDirection(direction);\n//            }\n\t\t\tfor (Entry<String, String> entry : tag.getCSS().entrySet()) {\n\t\t\t\tif (entry.getKey().equalsIgnoreCase(CSS.Property.PAGE_BREAK_INSIDE)) {\n\t\t\t\t\tif (entry.getValue().equalsIgnoreCase(CSS.Value.AVOID)) {\n\t\t\t\t\t\ttable.setKeepTogether(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            TableStyleValues styleValues = setStyleValues(tag);\n            table.setTableEvent(new TableBorderEvent(styleValues));\n            setVerticalMargin(table, tag, styleValues, ctx);\n            widenLastCell(tableRows, styleValues.getHorBorderSpacing());\n\t\t\tfloat[] columnWidths = new float[numberOfColumns];\n\t\t\tfloat[] widestWords = new float[numberOfColumns];\n\t\t\tfloat[] fixedWidths = new float[numberOfColumns];\n            float[] colspanWidestWords = new float[numberOfColumns];\n\t\t\tint[] rowspanValue = new int[numberOfColumns];\n\t\t\tfloat largestColumn = 0;\n            float largestColspanColumn = 0;\n\t\t\tint indexOfLargestColumn = -1;\n            int indexOfLargestColspanColumn = -1;\n\t\t\t// Initial fill of the widths arrays\n\t\t\tfor (TableRowElement row : tableRows) {\n\t\t\t\tint column = 0;\n\t\t\t\tfor (HtmlCell cell : row.getContent()) {\n\t\t\t\t\t// check whether the current column should be skipped due to a\n\t\t\t\t\t// rowspan value of higher cell in this column.\n                    // Contribution made by Arnost Havelka (Asseco): added while condition\n                    while ((column < numberOfColumns) && (rowspanValue[column] > 0)) {\n                        rowspanValue[column] = rowspanValue[column] - 1;\n                        ++column;\n                    }\n\t\t\t\t\t// sets a rowspan counter for current column (counter not\n\t\t\t\t\t// needed for last column).\n\t\t\t\t\tif (cell.getRowspan() > 1 && column != numberOfColumns - 1 && column < rowspanValue.length) {\n\t\t\t\t\t\trowspanValue[column] = cell.getRowspan() - 1;\n\t\t\t\t\t}\n\t\t\t\t\tint colspan = cell.getColspan();\n\t\t\t\t\tif (cell.getFixedWidth() != 0) {\n\t\t\t\t\t\tfloat fixedWidth = cell.getFixedWidth() + getCellStartWidth(cell);\n\t\t\t\t\t\tfloat colSpanWidthSum = 0;\n\t\t\t\t\t\tint nonZeroColspanCols = 0;\n\t\t\t\t\t\t// Contribution made by Arnost Havelka (Asseco) (modified)\n\t\t\t\t\t\tfor (int c = column; c < column + colspan && c < numberOfColumns; c++) {\n\t\t\t\t\t\t\tcolSpanWidthSum += fixedWidths[c];\n\t\t\t\t\t\t\tif (fixedWidths[c] != 0)\n\t\t\t\t\t\t\t\tnonZeroColspanCols++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int c = column; c < column + colspan && c < numberOfColumns; c++) {\n\t\t\t\t\t\t\tif (fixedWidths[c] == 0) {\n\t\t\t\t\t\t\t\tfixedWidths[c] = (fixedWidth - colSpanWidthSum) / (colspan - nonZeroColspanCols);\n\t\t\t\t\t\t\t\tcolumnWidths[c] = (fixedWidth - colSpanWidthSum) / (colspan - nonZeroColspanCols);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cell.getCompositeElements() != null) {\n\t\t\t\t\t\tfloat[] widthValues = setCellWidthAndWidestWord(cell);\n\t\t\t\t\t\tfloat cellWidth = widthValues[0] / colspan;\n\t\t\t\t\t\tfloat widestWordOfCell = widthValues[1] / colspan;\n\t\t\t\t\t\tfor (int i = 0; i < colspan; i++) {\n\t\t\t\t\t\t\tint c = column + i;\n                            // Contribution made by Arnost Havelka (Asseco)\n                            if (c >= numberOfColumns) {\n                                continue;\n                            }\n\t\t\t\t\t\t\tif (fixedWidths[c] == 0 && cellWidth > columnWidths[c]) {\n\t\t\t\t\t\t\t\tcolumnWidths[c] = cellWidth;\n                                if (colspan == 1) {\n                                    if (cellWidth > largestColumn) {\n                                        largestColumn = cellWidth;\n                                        indexOfLargestColumn = c;\n                                    }\n                                } else {\n                                    if (cellWidth > largestColspanColumn) {\n                                        largestColspanColumn = cellWidth;\n                                        indexOfLargestColspanColumn = c;\n                                    }\n                                }\n\t\t\t\t\t\t\t}\n                            if (colspan == 1) {\n                                if (widestWordOfCell > widestWords[c]) {\n                                    widestWords[c] = widestWordOfCell;\n                                }\n                            } else {\n                                if (widestWordOfCell > colspanWidestWords[c]) {\n                                    colspanWidestWords[c] = widestWordOfCell;\n                                }\n                            }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (colspan > 1) {\n\t\t\t\t\t\tif (LOG.isLogging(Level.TRACE)) {\n\t\t\t\t\t\t\tLOG.trace(String.format(LocaleMessages.getInstance().getMessage(LocaleMessages.COLSPAN),\n\t\t\t\t\t\t\t\t\tcolspan));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolumn += colspan - 1;\n\t\t\t\t\t}\n\t\t\t\t\tcolumn++;\n\t\t\t\t}\n\t\t\t}\n            if (indexOfLargestColumn == -1) {\n                indexOfLargestColumn = indexOfLargestColspanColumn;\n                if (indexOfLargestColumn == -1) {\n                    indexOfLargestColumn = 0;\n                }\n\n                for (int column = 0; column < numberOfColumns; column++) {\n                    widestWords[column] = colspanWidestWords[column];\n                }\n            }\n\t\t\tfloat outerWidth = getTableOuterWidth(tag, styleValues.getHorBorderSpacing(), ctx);\n\t\t\tfloat initialTotalWidth = getTableWidth(columnWidths, 0);\n//\t\t\tfloat targetWidth = calculateTargetWidth(tag, columnWidths, outerWidth, ctx);\n\t\t\tfloat targetWidth = 0;\n\t\t\tHtmlPipelineContext htmlPipelineContext = getHtmlPipelineContext(ctx);\n\t\t\tfloat max = htmlPipelineContext.getPageSize().getWidth() - outerWidth;\n\t\t\tboolean tableWidthFixed = false;\n\t\t\tif (tag.getAttributes().get(CSS.Property.WIDTH) != null || tag.getCSS().get(CSS.Property.WIDTH) != null) {\n\t\t\t\ttargetWidth = new WidthCalculator().getWidth(tag, htmlPipelineContext.getRootTags(), htmlPipelineContext.getPageSize().getWidth(), initialTotalWidth);\n\t\t\t\tif (targetWidth > max) {\n\t\t\t\t\ttargetWidth = max;\n\t\t\t\t}\n\t\t\t\ttableWidthFixed = true;\n\t\t\t} else if (initialTotalWidth <= max) {\n\t\t\t\ttargetWidth = initialTotalWidth;\n\t\t\t} else if (null == tag.getParent() || (null != tag.getParent() && htmlPipelineContext.getRootTags().contains(tag.getParent().getName()))) {\n\t\t\t\ttargetWidth = max;\n\t\t\t} else /* this table is an inner table and width adjustment is done in outer table */{\n\t\t\t\ttargetWidth = getTableWidth(columnWidths, outerWidth);\n\t\t\t}\n\t\t\tfloat totalFixedColumnWidth = getTableWidth(fixedWidths, 0);\n\t\t\tfloat targetPercentage = 0;\n\t\t\tif (totalFixedColumnWidth == initialTotalWidth) { // all column widths are fixed\n\t\t\t\ttargetPercentage = targetWidth / initialTotalWidth;\n\t\t\t\tif (initialTotalWidth > targetWidth) {\n\t\t\t\t\tfor (int column = 0; column < columnWidths.length; column++) {\n\t\t\t\t\t\tcolumnWidths[column] *= targetPercentage;\n\t\t\t\t\t}\n\t\t\t\t} else if(tableWidthFixed && targetPercentage != 1){\n\t\t\t\t\tfor (int column = 0; column < columnWidths.length; column++) {\n\t\t\t\t\t\tcolumnWidths[column] *= targetPercentage;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttargetPercentage = (targetWidth - totalFixedColumnWidth) / (initialTotalWidth - totalFixedColumnWidth);\n\t\t\t\t// Reduce width of columns if the columnWidth array + borders +\n\t\t\t\t// paddings\n\t\t\t\t// is too large for the given targetWidth.\n\t\t\t\tif (initialTotalWidth > targetWidth) {\n\t\t\t\t\tfloat leftToReduce = 0;\n\t\t\t\t\tfor (int column = 0; column < columnWidths.length; column++) {\n\t\t\t\t\t\tif (fixedWidths[column] == 0) {\n\t\t\t\t\t\t\t// Reduce width of the column to its targetWidth, if\n\t\t\t\t\t\t\t// widestWord of column still fits in the\n\t\t\t\t\t\t\t// targetWidth of\n\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t// column.\n\t\t\t\t\t\t\tif (widestWords[column] <= columnWidths[column] * targetPercentage) {\n\t\t\t\t\t\t\t\tcolumnWidths[column] *= targetPercentage;\n\t\t\t\t\t\t\t\t// else take the widest word and calculate space\n\t\t\t\t\t\t\t\t// left to\n\t\t\t\t\t\t\t\t// reduce.\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcolumnWidths[column] = widestWords[column];\n\t\t\t\t\t\t\t\tleftToReduce += widestWords[column] - columnWidths[column] * targetPercentage;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// if widestWord of a column does not fit in the\n\t\t\t\t\t\t\t// fixedWidth,\n\t\t\t\t\t\t\t// set the column width to the widestWord.\n\t\t\t\t\t\t} else if (fixedWidths[column] < widestWords[column]) {\n\t\t\t\t\t\t\tcolumnWidths[column] = widestWords[column];\n\t\t\t\t\t\t\tleftToReduce += widestWords[column] - fixedWidths[column];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (leftToReduce != 0) {\n\t\t\t\t\t\t// Reduce width of the column with the most text, if its\n\t\t\t\t\t\t// widestWord still fits in the reduced column.\n\t\t\t\t\t\tif (widestWords[indexOfLargestColumn] <= columnWidths[indexOfLargestColumn] - leftToReduce) {\n\t\t\t\t\t\t\tcolumnWidths[indexOfLargestColumn] -= leftToReduce;\n\t\t\t\t\t\t} else { // set all none fixed columns to their minimum, with the\n\t\t\t\t\t\t\t// widestWord array.\n\t\t\t\t\t\t\tfor (int column = 0; leftToReduce != 0 && column < columnWidths.length; column++) {\n\t\t\t\t\t\t\t\tif (fixedWidths[column] == 0 && columnWidths[column] > widestWords[column]) {\n\t\t\t\t\t\t\t\t\tfloat difference = columnWidths[column] - widestWords[column];\n\t\t\t\t\t\t\t\t\tif (difference <= leftToReduce) {\n\t\t\t\t\t\t\t\t\t\tleftToReduce -= difference;\n\t\t\t\t\t\t\t\t\t\tcolumnWidths[column] = widestWords[column];\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcolumnWidths[column] -= leftToReduce;\n\t\t\t\t\t\t\t\t\t\tleftToReduce = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (leftToReduce != 0) {\n\t\t\t\t\t\t\t\t// If the table has an insufficient fixed width\n\t\t\t\t\t\t\t\t// by\n\t\t\t\t\t\t\t\t// an\n\t\t\t\t\t\t\t\t// attribute or style, try to enlarge the table\n\t\t\t\t\t\t\t\t// to\n\t\t\t\t\t\t\t\t// its\n\t\t\t\t\t\t\t\t// minimum width (= widestWords array).\n\t\t\t\t\t\t\t\tfloat pageWidth = getHtmlPipelineContext(ctx).getPageSize().getWidth();\n\t\t\t\t\t\t\t\tif (getTableWidth(widestWords, outerWidth) < pageWidth) {\n\t\t\t\t\t\t\t\t\ttargetWidth = getTableWidth(widestWords, outerWidth);\n\t\t\t\t\t\t\t\t\tleftToReduce = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// If all columnWidths are set to the\n\t\t\t\t\t\t\t\t\t// widestWordWidths and the table is still\n\t\t\t\t\t\t\t\t\t// to\n\t\t\t\t\t\t\t\t\t// wide\n\t\t\t\t\t\t\t\t\t// content will fall off the edge of a page,\n\t\t\t\t\t\t\t\t\t// which\n\t\t\t\t\t\t\t\t\t// is similar to HTML.\n\t\t\t\t\t\t\t\t\ttargetWidth = pageWidth - outerWidth;\n\t\t\t\t\t\t\t\t\tleftToReduce = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Enlarge width of columns to fit the targetWidth.\n\t\t\t\t} else if (initialTotalWidth < targetWidth) {\n\t\t\t\t\tfor (int column = 0; column < columnWidths.length; column++) {\n\t\t\t\t\t\tif (fixedWidths[column] == 0) {\n\t\t\t\t\t\t\tcolumnWidths[column] *= targetPercentage;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\ttable.setTotalWidth(columnWidths);\n\t\t\t\ttable.setLockedWidth(true);\n\t\t\t\ttable.getDefaultCell().setBorder(Rectangle.NO_BORDER);\n\t\t\t} catch (DocumentException e) {\n\t\t\t\tthrow new RuntimeWorkerException(LocaleMessages.getInstance().getMessage(\n\t\t\t\t\t\tLocaleMessages.NO_CUSTOM_CONTEXT), e);\n\t\t\t}\n\n            Float tableHeight = new HeightCalculator().getHeight(tag, getHtmlPipelineContext(ctx).getPageSize().getHeight());\n            Float tableRowHeight = null;\n            if (tableHeight != null && tableHeight > 0) tableRowHeight = tableHeight/tableRows.size();\n            int rowNumber = 0;\n\t\t\tfor (TableRowElement row : tableRows) {\n\t\t\t\tint columnNumber = -1;\n                Float computedRowHeight = null;\n                /*if (tableHeight != null &&  tableRows.indexOf(row) == tableRows.size() - 1) {\n                    float computedTableHeigt = table.calculateHeights();\n                    computedRowHeight = tableHeight - computedTableHeigt;\n                }*/\n                List<HtmlCell> rowContent = row.getContent();\n                if (rowContent.size() < 1)\n                    continue;\n                for (HtmlCell cell : rowContent) {\n\t\t\t\t\tList<Element> compositeElements = cell.getCompositeElements();\n\t\t\t\t\tif (compositeElements != null) {\n\t\t\t\t\t\tfor (Element baseLevel : compositeElements) {\n\t\t\t\t\t\t\tif (baseLevel instanceof PdfPTable) {\n\t\t\t\t\t\t\t\tTableStyleValues cellValues = cell.getCellValues();\n\t\t\t\t\t\t\t\tfloat totalBordersWidth = cellValues.isLastInRow() ? styleValues\n\t\t\t\t\t\t\t\t\t\t.getHorBorderSpacing() * 2\n\t\t\t\t\t\t\t\t\t\t: styleValues.getHorBorderSpacing();\n\t\t\t\t\t\t\t\ttotalBordersWidth += cellValues.getBorderWidthLeft()\n\t\t\t\t\t\t\t\t\t\t+ cellValues.getBorderWidthRight();\n\t\t\t\t\t\t\t\tfloat columnWidth = 0;\n                                for (int currentColumnNumber = columnNumber + 1 ;currentColumnNumber <= columnNumber + cell.getColspan(); currentColumnNumber++ ) {\n                                    columnWidth += columnWidths[currentColumnNumber];\n                                }\n                                PdfPTableEvent tableEvent = ((PdfPTable) baseLevel).getTableEvent();\n\t\t\t\t\t\t\t\tTableStyleValues innerStyleValues = ((TableBorderEvent) tableEvent)\n\t\t\t\t\t\t\t\t\t\t.getTableStyleValues();\n\t\t\t\t\t\t\t\ttotalBordersWidth += innerStyleValues.getBorderWidthLeft();\n\t\t\t\t\t\t\t\ttotalBordersWidth += innerStyleValues.getBorderWidthRight();\n\t\t\t\t\t\t\t\t((PdfPTable) baseLevel).setTotalWidth(columnWidth - totalBordersWidth);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                    columnNumber += cell.getColspan();\n\n\t\t\t\t\ttable.addCell(cell);\n\t\t\t\t}\n\t\t\t\ttable.completeRow();\n                if ((computedRowHeight == null || computedRowHeight <= 0) && tableRowHeight != null)\n                    computedRowHeight = tableRowHeight;\n                if (computedRowHeight != null && computedRowHeight > 0) {\n                    float rowHeight = table.getRow(rowNumber).getMaxHeights();\n                    if (rowHeight < computedRowHeight) {\n                        table.getRow(rowNumber).setMaxHeights(computedRowHeight);\n                    } else if (tableRowHeight != null && tableRowHeight < rowHeight){\n                        tableRowHeight = (tableHeight - rowHeight - rowNumber*tableRowHeight)\n                                /(tableRows.size() - rowNumber - 1);\n                    }\n                }\n                rowNumber++;\n\t\t\t}\n\t\t\tif (percentage) {\n\t\t\t\ttable.setWidthPercentage(utils.parsePxInCmMmPcToPt(widthValue));\n\t\t\t\ttable.setLockedWidth(false);\n\t\t\t}\n\t\t\tList<Element> elems = new ArrayList<Element>();\n\t\t\tif (invalidRowElements.size() > 0) {\n\t\t\t\t// all invalid row elements taken as caption\n\t\t\t\tint i = 0;\n\t\t\t\tTag captionTag = tag.getChildren().get(i++);\n\t\t\t\twhile (!captionTag.getName().equalsIgnoreCase(HTML.Tag.CAPTION) && i < tag.getChildren().size()) {\n\t\t\t\t\tcaptionTag = tag.getChildren().get(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tString captionSideValue = captionTag.getCSS().get(CSS.Property.CAPTION_SIDE);\n\t\t\t\tif (captionSideValue != null && captionSideValue.equalsIgnoreCase(CSS.Value.BOTTOM)) {\n\t\t\t\t\telems.add(table);\n\t\t\t\t\telems.addAll(invalidRowElements);\n\t\t\t\t} else {\n\t\t\t\t\telems.addAll(invalidRowElements);\n\t\t\t\t\telems.add(table);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telems.add(table);\n\t\t\t}\n\t\t\treturn elems;\n\t\t} catch (NoCustomContextException e) {\n\t\t\tthrow new RuntimeWorkerException(LocaleMessages.getInstance().getMessage(LocaleMessages.NO_CUSTOM_CONTEXT), e);\n\t\t}\n\t}", "signature": "List<Element> end(final WorkerContext ctx, final Tag tag, final List<Element> currentContent)", "full_signature": "@Override public List<Element> end(final WorkerContext ctx, final Tag tag, final List<Element> currentContent)", "class_method_signature": "Table.end(final WorkerContext ctx, final Tag tag, final List<Element> currentContent)", "testcase": false, "constructor": false, "invocations": ["get", "getCSS", "get", "getAttributes", "endsWith", "trim", "size", "get", "getCSS", "get", "getCSS", "getContent", "getColspan", "add", "equalsIgnoreCase", "equals", "getPlace", "equalsIgnoreCase", "equals", "getPlace", "add", "equalsIgnoreCase", "sort", "sort", "intPdfPTable", "setHeaderRows", "setFooterRows", "containsKey", "getAttributes", "get", "getAttributes", "setHorizontalAlignment", "getElementAlignment", "getRunDirection", "setRunDirection", "entrySet", "getCSS", "equalsIgnoreCase", "getKey", "equalsIgnoreCase", "getValue", "setKeepTogether", "setStyleValues", "setTableEvent", "setVerticalMargin", "widenLastCell", "getHorBorderSpacing", "getContent", "getRowspan", "getRowspan", "getColspan", "getFixedWidth", "getFixedWidth", "getCellStartWidth", "getCompositeElements", "setCellWidthAndWidestWord", "isLogging", "trace", "format", "getMessage", "getInstance", "getTableOuterWidth", "getHorBorderSpacing", "getTableWidth", "getHtmlPipelineContext", "getWidth", "getPageSize", "get", "getAttributes", "get", "getCSS", "getWidth", "getRootTags", "getWidth", "getPageSize", "getParent", "getParent", "contains", "getRootTags", "getName", "getParent", "getTableWidth", "getTableWidth", "getWidth", "getPageSize", "getHtmlPipelineContext", "getTableWidth", "getTableWidth", "setTotalWidth", "setLockedWidth", "setBorder", "getDefaultCell", "getMessage", "getInstance", "getHeight", "getHeight", "getPageSize", "getHtmlPipelineContext", "size", "getContent", "size", "getCompositeElements", "getCellValues", "isLastInRow", "getHorBorderSpacing", "getHorBorderSpacing", "getBorderWidthLeft", "getBorderWidthRight", "getColspan", "getTableEvent", "getTableStyleValues", "getBorderWidthLeft", "getBorderWidthRight", "setTotalWidth", "getColspan", "addCell", "completeRow", "getMaxHeights", "getRow", "setMaxHeights", "getRow", "size", "setWidthPercentage", "parsePxInCmMmPcToPt", "setLockedWidth", "size", "get", "getChildren", "equalsIgnoreCase", "getName", "size", "getChildren", "get", "getChildren", "get", "getCSS", "equalsIgnoreCase", "add", "addAll", "addAll", "add", "add", "getMessage", "getInstance"]}, "repository": {"repo_id": 14892248, "url": "https://github.com/itext/itextpdf", "language": "Java", "is_fork": false, "fork_count": 400, "stargazer_count": 1164, "size": 115070, "license": "licensed"}}