{"test_class": {"identifier": "FunTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "final String sentinel = \"sentinel\";", "modifier": "final", "type": "String", "declarator": "sentinel = \"sentinel\"", "var_name": "sentinel"}], "file": "api/src/test/java/net/adamcin/oakpal/api/FunTest.java"}, "test_case": {"identifier": "testOnValue", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testOnValue() {\n        final AtomicInteger latch = new AtomicInteger(0);\n        final Map<String, Integer> refMap = new LinkedHashMap<>();\n        refMap.put(\"one\", 1);\n        refMap.put(\"two\", 2);\n        refMap.put(\"three\", 3);\n        refMap.entrySet().forEach(onValue(latch::addAndGet));\n        assertEquals(\"onValue should add 1, 2, and 3 (6) to latch\", 6, latch.get());\n    }", "signature": "void testOnValue()", "full_signature": "@Test public void testOnValue()", "class_method_signature": "FunTest.testOnValue()", "testcase": true, "constructor": false, "invocations": ["put", "put", "put", "forEach", "entrySet", "onValue", "assertEquals", "get"]}, "focal_class": {"identifier": "Fun", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "Fun", "parameters": "()", "modifiers": "private", "return": "", "signature": " Fun()", "full_signature": "private  Fun()", "class_method_signature": "Fun.Fun()", "testcase": false, "constructor": true}, {"identifier": "streamIt", "parameters": "(final @Nullable T element)", "modifiers": "public static", "return": "Stream<T>", "signature": "Stream<T> streamIt(final @Nullable T element)", "full_signature": "public static Stream<T> streamIt(final @Nullable T element)", "class_method_signature": "Fun.streamIt(final @Nullable T element)", "testcase": false, "constructor": false}, {"identifier": "streamOpt", "parameters": "(final @NotNull Optional<T> element)", "modifiers": "@SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\") public static", "return": "Stream<T>", "signature": "Stream<T> streamOpt(final @NotNull Optional<T> element)", "full_signature": "@SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\") public static Stream<T> streamOpt(final @NotNull Optional<T> element)", "class_method_signature": "Fun.streamOpt(final @NotNull Optional<T> element)", "testcase": false, "constructor": false}, {"identifier": "tee", "parameters": "(final @NotNull Consumer<? super T> consumer)", "modifiers": "public static", "return": "Function<T, T>", "signature": "Function<T, T> tee(final @NotNull Consumer<? super T> consumer)", "full_signature": "public static Function<T, T> tee(final @NotNull Consumer<? super T> consumer)", "class_method_signature": "Fun.tee(final @NotNull Consumer<? super T> consumer)", "testcase": false, "constructor": false}, {"identifier": "constantly1", "parameters": "(final @NotNull Supplier<? extends R> supplier)", "modifiers": "public static", "return": "Function<T, R>", "signature": "Function<T, R> constantly1(final @NotNull Supplier<? extends R> supplier)", "full_signature": "public static Function<T, R> constantly1(final @NotNull Supplier<? extends R> supplier)", "class_method_signature": "Fun.constantly1(final @NotNull Supplier<? extends R> supplier)", "testcase": false, "constructor": false}, {"identifier": "constantly2", "parameters": "(final @NotNull Supplier<? extends R> supplier)", "modifiers": "public static", "return": "BiFunction<K, V, R>", "signature": "BiFunction<K, V, R> constantly2(final @NotNull Supplier<? extends R> supplier)", "full_signature": "public static BiFunction<K, V, R> constantly2(final @NotNull Supplier<? extends R> supplier)", "class_method_signature": "Fun.constantly2(final @NotNull Supplier<? extends R> supplier)", "testcase": false, "constructor": false}, {"identifier": "compose1", "parameters": "(final @NotNull Function<T, ? extends I> before, final @NotNull Function<? super I, ? extends R> after)", "modifiers": "public static", "return": "Function<T, R>", "signature": "Function<T, R> compose1(final @NotNull Function<T, ? extends I> before, final @NotNull Function<? super I, ? extends R> after)", "full_signature": "public static Function<T, R> compose1(final @NotNull Function<T, ? extends I> before, final @NotNull Function<? super I, ? extends R> after)", "class_method_signature": "Fun.compose1(final @NotNull Function<T, ? extends I> before, final @NotNull Function<? super I, ? extends R> after)", "testcase": false, "constructor": false}, {"identifier": "compose0", "parameters": "(final @NotNull Supplier<? extends R> before, final @NotNull Function<? super R, ? extends S> after)", "modifiers": "public static", "return": "Supplier<S>", "signature": "Supplier<S> compose0(final @NotNull Supplier<? extends R> before, final @NotNull Function<? super R, ? extends S> after)", "full_signature": "public static Supplier<S> compose0(final @NotNull Supplier<? extends R> before, final @NotNull Function<? super R, ? extends S> after)", "class_method_signature": "Fun.compose0(final @NotNull Supplier<? extends R> before, final @NotNull Function<? super R, ? extends S> after)", "testcase": false, "constructor": false}, {"identifier": "compose2", "parameters": "(final @NotNull BiFunction<K, V, ? extends I> before, final @NotNull Function<? super I, ? extends R> after)", "modifiers": "public static", "return": "BiFunction<K, V, R>", "signature": "BiFunction<K, V, R> compose2(final @NotNull BiFunction<K, V, ? extends I> before, final @NotNull Function<? super I, ? extends R> after)", "full_signature": "public static BiFunction<K, V, R> compose2(final @NotNull BiFunction<K, V, ? extends I> before, final @NotNull Function<? super I, ? extends R> after)", "class_method_signature": "Fun.compose2(final @NotNull BiFunction<K, V, ? extends I> before, final @NotNull Function<? super I, ? extends R> after)", "testcase": false, "constructor": false}, {"identifier": "composeTest1", "parameters": "(final @NotNull Function<? super T, ? extends P> inputFunction,\n                 final @NotNull Predicate<? super P> testResult)", "modifiers": "public static", "return": "Predicate<T>", "signature": "Predicate<T> composeTest1(final @NotNull Function<? super T, ? extends P> inputFunction,\n                 final @NotNull Predicate<? super P> testResult)", "full_signature": "public static Predicate<T> composeTest1(final @NotNull Function<? super T, ? extends P> inputFunction,\n                 final @NotNull Predicate<? super P> testResult)", "class_method_signature": "Fun.composeTest1(final @NotNull Function<? super T, ? extends P> inputFunction,\n                 final @NotNull Predicate<? super P> testResult)", "testcase": false, "constructor": false}, {"identifier": "composeTest2", "parameters": "(final @NotNull Function<? super K, ? extends P> inputTFunction,\n                 final @NotNull Function<? super V, ? extends Q> inputUFunction,\n                 final @NotNull BiPredicate<? super P, ? super Q> testResult)", "modifiers": "public static", "return": "BiPredicate<K, V>", "signature": "BiPredicate<K, V> composeTest2(final @NotNull Function<? super K, ? extends P> inputTFunction,\n                 final @NotNull Function<? super V, ? extends Q> inputUFunction,\n                 final @NotNull BiPredicate<? super P, ? super Q> testResult)", "full_signature": "public static BiPredicate<K, V> composeTest2(final @NotNull Function<? super K, ? extends P> inputTFunction,\n                 final @NotNull Function<? super V, ? extends Q> inputUFunction,\n                 final @NotNull BiPredicate<? super P, ? super Q> testResult)", "class_method_signature": "Fun.composeTest2(final @NotNull Function<? super K, ? extends P> inputTFunction,\n                 final @NotNull Function<? super V, ? extends Q> inputUFunction,\n                 final @NotNull BiPredicate<? super P, ? super Q> testResult)", "testcase": false, "constructor": false}, {"identifier": "composeTest2", "parameters": "(final @NotNull BiFunction<? super K, ? super V, ? extends P> inputFunction,\n                 final @NotNull Predicate<? super P> testResult)", "modifiers": "public static", "return": "BiPredicate<K, V>", "signature": "BiPredicate<K, V> composeTest2(final @NotNull BiFunction<? super K, ? super V, ? extends P> inputFunction,\n                 final @NotNull Predicate<? super P> testResult)", "full_signature": "public static BiPredicate<K, V> composeTest2(final @NotNull BiFunction<? super K, ? super V, ? extends P> inputFunction,\n                 final @NotNull Predicate<? super P> testResult)", "class_method_signature": "Fun.composeTest2(final @NotNull BiFunction<? super K, ? super V, ? extends P> inputFunction,\n                 final @NotNull Predicate<? super P> testResult)", "testcase": false, "constructor": false}, {"identifier": "toVoid1", "parameters": "(final @NotNull Function<? super T, ?> inputFunction)", "modifiers": "public static", "return": "Consumer<T>", "signature": "Consumer<T> toVoid1(final @NotNull Function<? super T, ?> inputFunction)", "full_signature": "public static Consumer<T> toVoid1(final @NotNull Function<? super T, ?> inputFunction)", "class_method_signature": "Fun.toVoid1(final @NotNull Function<? super T, ?> inputFunction)", "testcase": false, "constructor": false}, {"identifier": "toVoid2", "parameters": "(final @NotNull BiFunction<? super K, ? super V, ?> inputFunction)", "modifiers": "public static", "return": "BiConsumer<K, V>", "signature": "BiConsumer<K, V> toVoid2(final @NotNull BiFunction<? super K, ? super V, ?> inputFunction)", "full_signature": "public static BiConsumer<K, V> toVoid2(final @NotNull BiFunction<? super K, ? super V, ?> inputFunction)", "class_method_signature": "Fun.toVoid2(final @NotNull BiFunction<? super K, ? super V, ?> inputFunction)", "testcase": false, "constructor": false}, {"identifier": "infer1", "parameters": "(final @NotNull Function<? super T, ? extends R> methodRef)", "modifiers": "public static", "return": "Function<T, R>", "signature": "Function<T, R> infer1(final @NotNull Function<? super T, ? extends R> methodRef)", "full_signature": "public static Function<T, R> infer1(final @NotNull Function<? super T, ? extends R> methodRef)", "class_method_signature": "Fun.infer1(final @NotNull Function<? super T, ? extends R> methodRef)", "testcase": false, "constructor": false}, {"identifier": "infer2", "parameters": "(final @NotNull BiFunction<? super K, ? super V, ? extends R> methodRef)", "modifiers": "public static", "return": "BiFunction<K, V, R>", "signature": "BiFunction<K, V, R> infer2(final @NotNull BiFunction<? super K, ? super V, ? extends R> methodRef)", "full_signature": "public static BiFunction<K, V, R> infer2(final @NotNull BiFunction<? super K, ? super V, ? extends R> methodRef)", "class_method_signature": "Fun.infer2(final @NotNull BiFunction<? super K, ? super V, ? extends R> methodRef)", "testcase": false, "constructor": false}, {"identifier": "infer0", "parameters": "(final @NotNull Supplier<? extends T> methodRef)", "modifiers": "public static", "return": "Supplier<T>", "signature": "Supplier<T> infer0(final @NotNull Supplier<? extends T> methodRef)", "full_signature": "public static Supplier<T> infer0(final @NotNull Supplier<? extends T> methodRef)", "class_method_signature": "Fun.infer0(final @NotNull Supplier<? extends T> methodRef)", "testcase": false, "constructor": false}, {"identifier": "inferTest1", "parameters": "(final @NotNull Predicate<? super T> methodRef)", "modifiers": "public static", "return": "Predicate<T>", "signature": "Predicate<T> inferTest1(final @NotNull Predicate<? super T> methodRef)", "full_signature": "public static Predicate<T> inferTest1(final @NotNull Predicate<? super T> methodRef)", "class_method_signature": "Fun.inferTest1(final @NotNull Predicate<? super T> methodRef)", "testcase": false, "constructor": false}, {"identifier": "inferTest2", "parameters": "(final @NotNull BiPredicate<? super K, ? super V> methodRef)", "modifiers": "public static", "return": "BiPredicate<K, V>", "signature": "BiPredicate<K, V> inferTest2(final @NotNull BiPredicate<? super K, ? super V> methodRef)", "full_signature": "public static BiPredicate<K, V> inferTest2(final @NotNull BiPredicate<? super K, ? super V> methodRef)", "class_method_signature": "Fun.inferTest2(final @NotNull BiPredicate<? super K, ? super V> methodRef)", "testcase": false, "constructor": false}, {"identifier": "throwingVoidToNothing1", "parameters": "(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "modifiers": "public static", "return": "ThrowingFunction<T, Nothing>", "signature": "ThrowingFunction<T, Nothing> throwingVoidToNothing1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "full_signature": "public static ThrowingFunction<T, Nothing> throwingVoidToNothing1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "class_method_signature": "Fun.throwingVoidToNothing1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "testcase": false, "constructor": false}, {"identifier": "throwingVoidToNothing2", "parameters": "(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "modifiers": "public static", "return": "ThrowingBiFunction<K, V, Nothing>", "signature": "ThrowingBiFunction<K, V, Nothing> throwingVoidToNothing2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "full_signature": "public static ThrowingBiFunction<K, V, Nothing> throwingVoidToNothing2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "class_method_signature": "Fun.throwingVoidToNothing2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "testcase": false, "constructor": false}, {"identifier": "entryTee", "parameters": "(final @NotNull BiConsumer<? super K, ? super V> consumer)", "modifiers": "public static", "return": "Function<Map.Entry<K, V>, Map.Entry<K, V>>", "signature": "Function<Map.Entry<K, V>, Map.Entry<K, V>> entryTee(final @NotNull BiConsumer<? super K, ? super V> consumer)", "full_signature": "public static Function<Map.Entry<K, V>, Map.Entry<K, V>> entryTee(final @NotNull BiConsumer<? super K, ? super V> consumer)", "class_method_signature": "Fun.entryTee(final @NotNull BiConsumer<? super K, ? super V> consumer)", "testcase": false, "constructor": false}, {"identifier": "zipKeysWithValueFunc", "parameters": "(final @NotNull Function<? super K, ? extends V> valueFunc)", "modifiers": "public static", "return": "Function<K, Map.Entry<K, V>>", "signature": "Function<K, Map.Entry<K, V>> zipKeysWithValueFunc(final @NotNull Function<? super K, ? extends V> valueFunc)", "full_signature": "public static Function<K, Map.Entry<K, V>> zipKeysWithValueFunc(final @NotNull Function<? super K, ? extends V> valueFunc)", "class_method_signature": "Fun.zipKeysWithValueFunc(final @NotNull Function<? super K, ? extends V> valueFunc)", "testcase": false, "constructor": false}, {"identifier": "zipValuesWithKeyFunc", "parameters": "(final @NotNull Function<? super V, ? extends K> keyFunction)", "modifiers": "public static", "return": "Function<V, Map.Entry<K, V>>", "signature": "Function<V, Map.Entry<K, V>> zipValuesWithKeyFunc(final @NotNull Function<? super V, ? extends K> keyFunction)", "full_signature": "public static Function<V, Map.Entry<K, V>> zipValuesWithKeyFunc(final @NotNull Function<? super V, ? extends K> keyFunction)", "class_method_signature": "Fun.zipValuesWithKeyFunc(final @NotNull Function<? super V, ? extends K> keyFunction)", "testcase": false, "constructor": false}, {"identifier": "toEntry", "parameters": "(final @Nullable K key, final @Nullable V value)", "modifiers": "public static", "return": "Map.Entry<K, V>", "signature": "Map.Entry<K, V> toEntry(final @Nullable K key, final @Nullable V value)", "full_signature": "public static Map.Entry<K, V> toEntry(final @Nullable K key, final @Nullable V value)", "class_method_signature": "Fun.toEntry(final @Nullable K key, final @Nullable V value)", "testcase": false, "constructor": false}, {"identifier": "keepFirstMerger", "parameters": "()", "modifiers": "public static", "return": "BinaryOperator<V>", "signature": "BinaryOperator<V> keepFirstMerger()", "full_signature": "public static BinaryOperator<V> keepFirstMerger()", "class_method_signature": "Fun.keepFirstMerger()", "testcase": false, "constructor": false}, {"identifier": "keepLastMerger", "parameters": "()", "modifiers": "public static", "return": "BinaryOperator<V>", "signature": "BinaryOperator<V> keepLastMerger()", "full_signature": "public static BinaryOperator<V> keepLastMerger()", "class_method_signature": "Fun.keepLastMerger()", "testcase": false, "constructor": false}, {"identifier": "throwingMerger", "parameters": "()", "modifiers": "public static", "return": "BinaryOperator<V>", "signature": "BinaryOperator<V> throwingMerger()", "full_signature": "public static BinaryOperator<V> throwingMerger()", "class_method_signature": "Fun.throwingMerger()", "testcase": false, "constructor": false}, {"identifier": "entriesToMap", "parameters": "()", "modifiers": "public static", "return": "Collector<Map.Entry<K, V>, ?, Map<K, V>>", "signature": "Collector<Map.Entry<K, V>, ?, Map<K, V>> entriesToMap()", "full_signature": "public static Collector<Map.Entry<K, V>, ?, Map<K, V>> entriesToMap()", "class_method_signature": "Fun.entriesToMap()", "testcase": false, "constructor": false}, {"identifier": "entriesToMapOfType", "parameters": "(final @NotNull Supplier<Map<K, V>> mapSupplier)", "modifiers": "public static", "return": "Collector<Map.Entry<K, V>, ?, Map<K, V>>", "signature": "Collector<Map.Entry<K, V>, ?, Map<K, V>> entriesToMapOfType(final @NotNull Supplier<Map<K, V>> mapSupplier)", "full_signature": "public static Collector<Map.Entry<K, V>, ?, Map<K, V>> entriesToMapOfType(final @NotNull Supplier<Map<K, V>> mapSupplier)", "class_method_signature": "Fun.entriesToMapOfType(final @NotNull Supplier<Map<K, V>> mapSupplier)", "testcase": false, "constructor": false}, {"identifier": "entriesToMap", "parameters": "(final @NotNull BinaryOperator<V> mergeFunction)", "modifiers": "public static", "return": "Collector<Map.Entry<K, V>, ?, Map<K, V>>", "signature": "Collector<Map.Entry<K, V>, ?, Map<K, V>> entriesToMap(final @NotNull BinaryOperator<V> mergeFunction)", "full_signature": "public static Collector<Map.Entry<K, V>, ?, Map<K, V>> entriesToMap(final @NotNull BinaryOperator<V> mergeFunction)", "class_method_signature": "Fun.entriesToMap(final @NotNull BinaryOperator<V> mergeFunction)", "testcase": false, "constructor": false}, {"identifier": "entriesToMapOfType", "parameters": "(final @NotNull Supplier<Map<K, V>> mapSupplier, final @NotNull BinaryOperator<V> mergeFunction)", "modifiers": "public static", "return": "Collector<Map.Entry<K, V>, ?, Map<K, V>>", "signature": "Collector<Map.Entry<K, V>, ?, Map<K, V>> entriesToMapOfType(final @NotNull Supplier<Map<K, V>> mapSupplier, final @NotNull BinaryOperator<V> mergeFunction)", "full_signature": "public static Collector<Map.Entry<K, V>, ?, Map<K, V>> entriesToMapOfType(final @NotNull Supplier<Map<K, V>> mapSupplier, final @NotNull BinaryOperator<V> mergeFunction)", "class_method_signature": "Fun.entriesToMapOfType(final @NotNull Supplier<Map<K, V>> mapSupplier, final @NotNull BinaryOperator<V> mergeFunction)", "testcase": false, "constructor": false}, {"identifier": "mapEntry", "parameters": "(final @NotNull BiFunction<? super K, ? super V, ? extends R> biMapFunction)", "modifiers": "public static", "return": "Function<Map.Entry<K, V>, R>", "signature": "Function<Map.Entry<K, V>, R> mapEntry(final @NotNull BiFunction<? super K, ? super V, ? extends R> biMapFunction)", "full_signature": "public static Function<Map.Entry<K, V>, R> mapEntry(final @NotNull BiFunction<? super K, ? super V, ? extends R> biMapFunction)", "class_method_signature": "Fun.mapEntry(final @NotNull BiFunction<? super K, ? super V, ? extends R> biMapFunction)", "testcase": false, "constructor": false}, {"identifier": "mapValue", "parameters": "(final @NotNull BiFunction<? super K, ? super V, ? extends W> valueBiFunction)", "modifiers": "public static", "return": "Function<Map.Entry<K, V>, Map.Entry<K, W>>", "signature": "Function<Map.Entry<K, V>, Map.Entry<K, W>> mapValue(final @NotNull BiFunction<? super K, ? super V, ? extends W> valueBiFunction)", "full_signature": "public static Function<Map.Entry<K, V>, Map.Entry<K, W>> mapValue(final @NotNull BiFunction<? super K, ? super V, ? extends W> valueBiFunction)", "class_method_signature": "Fun.mapValue(final @NotNull BiFunction<? super K, ? super V, ? extends W> valueBiFunction)", "testcase": false, "constructor": false}, {"identifier": "mapValue", "parameters": "(final @NotNull Function<? super V, ? extends W> valueFunction)", "modifiers": "public static", "return": "Function<Map.Entry<K, V>, Map.Entry<K, W>>", "signature": "Function<Map.Entry<K, V>, Map.Entry<K, W>> mapValue(final @NotNull Function<? super V, ? extends W> valueFunction)", "full_signature": "public static Function<Map.Entry<K, V>, Map.Entry<K, W>> mapValue(final @NotNull Function<? super V, ? extends W> valueFunction)", "class_method_signature": "Fun.mapValue(final @NotNull Function<? super V, ? extends W> valueFunction)", "testcase": false, "constructor": false}, {"identifier": "mapKey", "parameters": "(final @NotNull BiFunction<? super K, ? super V, ? extends L> keyBiFunction)", "modifiers": "public static", "return": "Function<Map.Entry<K, V>, Map.Entry<L, V>>", "signature": "Function<Map.Entry<K, V>, Map.Entry<L, V>> mapKey(final @NotNull BiFunction<? super K, ? super V, ? extends L> keyBiFunction)", "full_signature": "public static Function<Map.Entry<K, V>, Map.Entry<L, V>> mapKey(final @NotNull BiFunction<? super K, ? super V, ? extends L> keyBiFunction)", "class_method_signature": "Fun.mapKey(final @NotNull BiFunction<? super K, ? super V, ? extends L> keyBiFunction)", "testcase": false, "constructor": false}, {"identifier": "mapKey", "parameters": "(final @NotNull Function<? super K, ? extends L> keyFunction)", "modifiers": "public static", "return": "Function<Map.Entry<K, V>, Map.Entry<L, V>>", "signature": "Function<Map.Entry<K, V>, Map.Entry<L, V>> mapKey(final @NotNull Function<? super K, ? extends L> keyFunction)", "full_signature": "public static Function<Map.Entry<K, V>, Map.Entry<L, V>> mapKey(final @NotNull Function<? super K, ? extends L> keyFunction)", "class_method_signature": "Fun.mapKey(final @NotNull Function<? super K, ? extends L> keyFunction)", "testcase": false, "constructor": false}, {"identifier": "onEntry", "parameters": "(final @NotNull BiConsumer<? super K, ? super V> biConsumer)", "modifiers": "public static", "return": "Consumer<Map.Entry<K, V>>", "signature": "Consumer<Map.Entry<K, V>> onEntry(final @NotNull BiConsumer<? super K, ? super V> biConsumer)", "full_signature": "public static Consumer<Map.Entry<K, V>> onEntry(final @NotNull BiConsumer<? super K, ? super V> biConsumer)", "class_method_signature": "Fun.onEntry(final @NotNull BiConsumer<? super K, ? super V> biConsumer)", "testcase": false, "constructor": false}, {"identifier": "onKey", "parameters": "(final @NotNull Consumer<? super K> consumer)", "modifiers": "public static", "return": "Consumer<Map.Entry<K, V>>", "signature": "Consumer<Map.Entry<K, V>> onKey(final @NotNull Consumer<? super K> consumer)", "full_signature": "public static Consumer<Map.Entry<K, V>> onKey(final @NotNull Consumer<? super K> consumer)", "class_method_signature": "Fun.onKey(final @NotNull Consumer<? super K> consumer)", "testcase": false, "constructor": false}, {"identifier": "onValue", "parameters": "(final @NotNull Consumer<? super V> consumer)", "modifiers": "public static", "return": "Consumer<Map.Entry<K, V>>", "signature": "Consumer<Map.Entry<K, V>> onValue(final @NotNull Consumer<? super V> consumer)", "full_signature": "public static Consumer<Map.Entry<K, V>> onValue(final @NotNull Consumer<? super V> consumer)", "class_method_signature": "Fun.onValue(final @NotNull Consumer<? super V> consumer)", "testcase": false, "constructor": false}, {"identifier": "testEntry", "parameters": "(final @NotNull BiPredicate<? super K, ? super V> biPredicate)", "modifiers": "public static", "return": "Predicate<? super Map.Entry<K, V>>", "signature": "Predicate<? super Map.Entry<K, V>> testEntry(final @NotNull BiPredicate<? super K, ? super V> biPredicate)", "full_signature": "public static Predicate<? super Map.Entry<K, V>> testEntry(final @NotNull BiPredicate<? super K, ? super V> biPredicate)", "class_method_signature": "Fun.testEntry(final @NotNull BiPredicate<? super K, ? super V> biPredicate)", "testcase": false, "constructor": false}, {"identifier": "testValue", "parameters": "(final @NotNull Predicate<? super V> valuePredicate)", "modifiers": "public static", "return": "Predicate<? super Map.Entry<K, V>>", "signature": "Predicate<? super Map.Entry<K, V>> testValue(final @NotNull Predicate<? super V> valuePredicate)", "full_signature": "public static Predicate<? super Map.Entry<K, V>> testValue(final @NotNull Predicate<? super V> valuePredicate)", "class_method_signature": "Fun.testValue(final @NotNull Predicate<? super V> valuePredicate)", "testcase": false, "constructor": false}, {"identifier": "testKey", "parameters": "(final @NotNull Predicate<? super K> keyPredicate)", "modifiers": "public static", "return": "Predicate<? super Map.Entry<K, V>>", "signature": "Predicate<? super Map.Entry<K, V>> testKey(final @NotNull Predicate<? super K> keyPredicate)", "full_signature": "public static Predicate<? super Map.Entry<K, V>> testKey(final @NotNull Predicate<? super K> keyPredicate)", "class_method_signature": "Fun.testKey(final @NotNull Predicate<? super K> keyPredicate)", "testcase": false, "constructor": false}, {"identifier": "inSet", "parameters": "(final @NotNull S haystack)", "modifiers": "public static", "return": "Predicate<T>", "signature": "Predicate<T> inSet(final @NotNull S haystack)", "full_signature": "public static Predicate<T> inSet(final @NotNull S haystack)", "class_method_signature": "Fun.inSet(final @NotNull S haystack)", "testcase": false, "constructor": false}, {"identifier": "isKeyIn", "parameters": "(final @NotNull M haystack)", "modifiers": "public static", "return": "Predicate<K>", "signature": "Predicate<K> isKeyIn(final @NotNull M haystack)", "full_signature": "public static Predicate<K> isKeyIn(final @NotNull M haystack)", "class_method_signature": "Fun.isKeyIn(final @NotNull M haystack)", "testcase": false, "constructor": false}, {"identifier": "isValueIn", "parameters": "(final @NotNull M haystack)", "modifiers": "public static", "return": "Predicate<V>", "signature": "Predicate<V> isValueIn(final @NotNull M haystack)", "full_signature": "public static Predicate<V> isValueIn(final @NotNull M haystack)", "class_method_signature": "Fun.isValueIn(final @NotNull M haystack)", "testcase": false, "constructor": false}, {"identifier": "composeTry1", "parameters": "(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply,\n                final @Nullable BiConsumer<? super T, ? super Exception> onError)", "modifiers": "public static", "return": "Function<T, M>", "signature": "Function<T, M> composeTry1(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply,\n                final @Nullable BiConsumer<? super T, ? super Exception> onError)", "full_signature": "public static Function<T, M> composeTry1(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply,\n                final @Nullable BiConsumer<? super T, ? super Exception> onError)", "class_method_signature": "Fun.composeTry1(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply,\n                final @Nullable BiConsumer<? super T, ? super Exception> onError)", "testcase": false, "constructor": false}, {"identifier": "composeTry1", "parameters": "(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "modifiers": "public static", "return": "Function<T, M>", "signature": "Function<T, M> composeTry1(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "full_signature": "public static Function<T, M> composeTry1(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "class_method_signature": "Fun.composeTry1(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "testcase": false, "constructor": false}, {"identifier": "composeTry0", "parameters": "(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet,\n                final @Nullable Consumer<? super Exception> onError)", "modifiers": "public static", "return": "Supplier<M>", "signature": "Supplier<M> composeTry0(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet,\n                final @Nullable Consumer<? super Exception> onError)", "full_signature": "public static Supplier<M> composeTry0(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet,\n                final @Nullable Consumer<? super Exception> onError)", "class_method_signature": "Fun.composeTry0(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet,\n                final @Nullable Consumer<? super Exception> onError)", "testcase": false, "constructor": false}, {"identifier": "composeTry0", "parameters": "(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "modifiers": "public static", "return": "Supplier<M>", "signature": "Supplier<M> composeTry0(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "full_signature": "public static Supplier<M> composeTry0(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "class_method_signature": "Fun.composeTry0(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "testcase": false, "constructor": false}, {"identifier": "composeTry2", "parameters": "(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply,\n                final @Nullable BiConsumer<? super Map.Entry<? super K, ? super V>, ? super Exception> onError)", "modifiers": "public static", "return": "BiFunction<K, V, M>", "signature": "BiFunction<K, V, M> composeTry2(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply,\n                final @Nullable BiConsumer<? super Map.Entry<? super K, ? super V>, ? super Exception> onError)", "full_signature": "public static BiFunction<K, V, M> composeTry2(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply,\n                final @Nullable BiConsumer<? super Map.Entry<? super K, ? super V>, ? super Exception> onError)", "class_method_signature": "Fun.composeTry2(final @NotNull Function<? super R, ? extends M> monadUnit,\n                final @NotNull Supplier<? extends M> monadZero,\n                final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply,\n                final @Nullable BiConsumer<? super Map.Entry<? super K, ? super V>, ? super Exception> onError)", "testcase": false, "constructor": false}, {"identifier": "composeTry2", "parameters": "(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "modifiers": "public static", "return": "BiFunction<K, V, M>", "signature": "BiFunction<K, V, M> composeTry2(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "full_signature": "public static BiFunction<K, V, M> composeTry2(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "class_method_signature": "Fun.composeTry2(final @NotNull Function<? super R, ? extends M> monoidSuccess,\n                final @NotNull Function<? super Exception, ? extends M> monoidError,\n                final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "testcase": false, "constructor": false}, {"identifier": "uncheck0", "parameters": "(final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "modifiers": "public static", "return": "Supplier<R>", "signature": "Supplier<R> uncheck0(final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "full_signature": "public static Supplier<R> uncheck0(final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "class_method_signature": "Fun.uncheck0(final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "testcase": false, "constructor": false}, {"identifier": "result0", "parameters": "(final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "modifiers": "public static", "return": "Supplier<Result<R>>", "signature": "Supplier<Result<R>> result0(final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "full_signature": "public static Supplier<Result<R>> result0(final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "class_method_signature": "Fun.result0(final @NotNull ThrowingSupplier<? extends R> mayThrowOnGet)", "testcase": false, "constructor": false}, {"identifier": "uncheck1", "parameters": "(final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "modifiers": "public static", "return": "Function<T, R>", "signature": "Function<T, R> uncheck1(final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "full_signature": "public static Function<T, R> uncheck1(final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "class_method_signature": "Fun.uncheck1(final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "testcase": false, "constructor": false}, {"identifier": "result1", "parameters": "(final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "modifiers": "public static", "return": "Function<T, Result<R>>", "signature": "Function<T, Result<R>> result1(final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "full_signature": "public static Function<T, Result<R>> result1(final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "class_method_signature": "Fun.result1(final @NotNull ThrowingFunction<? super T, ? extends R> mayThrowOnApply)", "testcase": false, "constructor": false}, {"identifier": "uncheck2", "parameters": "(final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "modifiers": "public static", "return": "BiFunction<K, V, R>", "signature": "BiFunction<K, V, R> uncheck2(final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "full_signature": "public static BiFunction<K, V, R> uncheck2(final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "class_method_signature": "Fun.uncheck2(final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "testcase": false, "constructor": false}, {"identifier": "result2", "parameters": "(final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "modifiers": "public static", "return": "BiFunction<K, V, Result<R>>", "signature": "BiFunction<K, V, Result<R>> result2(final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "full_signature": "public static BiFunction<K, V, Result<R>> result2(final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "class_method_signature": "Fun.result2(final @NotNull ThrowingBiFunction<? super K, ? super V, ? extends R> mayThrowOnApply)", "testcase": false, "constructor": false}, {"identifier": "uncheckTest1", "parameters": "(final @NotNull ThrowingPredicate<? super T> mayThrowOnTest)", "modifiers": "public static", "return": "Predicate<T>", "signature": "Predicate<T> uncheckTest1(final @NotNull ThrowingPredicate<? super T> mayThrowOnTest)", "full_signature": "public static Predicate<T> uncheckTest1(final @NotNull ThrowingPredicate<? super T> mayThrowOnTest)", "class_method_signature": "Fun.uncheckTest1(final @NotNull ThrowingPredicate<? super T> mayThrowOnTest)", "testcase": false, "constructor": false}, {"identifier": "uncheckTest2", "parameters": "(final @NotNull ThrowingBiPredicate<? super K, ? super V> mayThrowOnTest)", "modifiers": "public static", "return": "BiPredicate<K, V>", "signature": "BiPredicate<K, V> uncheckTest2(final @NotNull ThrowingBiPredicate<? super K, ? super V> mayThrowOnTest)", "full_signature": "public static BiPredicate<K, V> uncheckTest2(final @NotNull ThrowingBiPredicate<? super K, ? super V> mayThrowOnTest)", "class_method_signature": "Fun.uncheckTest2(final @NotNull ThrowingBiPredicate<? super K, ? super V> mayThrowOnTest)", "testcase": false, "constructor": false}, {"identifier": "uncheckVoid1", "parameters": "(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "modifiers": "public static", "return": "Consumer<T>", "signature": "Consumer<T> uncheckVoid1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "full_signature": "public static Consumer<T> uncheckVoid1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "class_method_signature": "Fun.uncheckVoid1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "testcase": false, "constructor": false}, {"identifier": "resultNothing1", "parameters": "(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "modifiers": "public static", "return": "Function<T, Result<Nothing>>", "signature": "Function<T, Result<Nothing>> resultNothing1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "full_signature": "public static Function<T, Result<Nothing>> resultNothing1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "class_method_signature": "Fun.resultNothing1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "testcase": false, "constructor": false}, {"identifier": "uncheckVoid2", "parameters": "(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "modifiers": "public static", "return": "BiConsumer<K, V>", "signature": "BiConsumer<K, V> uncheckVoid2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "full_signature": "public static BiConsumer<K, V> uncheckVoid2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "class_method_signature": "Fun.uncheckVoid2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "testcase": false, "constructor": false}, {"identifier": "resultNothing2", "parameters": "(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "modifiers": "public static", "return": "BiFunction<K, V, Result<Nothing>>", "signature": "BiFunction<K, V, Result<Nothing>> resultNothing2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "full_signature": "public static BiFunction<K, V, Result<Nothing>> resultNothing2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "class_method_signature": "Fun.resultNothing2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "testcase": false, "constructor": false}, {"identifier": "testOrDefault1", "parameters": "(final @NotNull ThrowingPredicate<? super T> mayThrowOnTest, boolean defaultValue)", "modifiers": "public static", "return": "Predicate<T>", "signature": "Predicate<T> testOrDefault1(final @NotNull ThrowingPredicate<? super T> mayThrowOnTest, boolean defaultValue)", "full_signature": "public static Predicate<T> testOrDefault1(final @NotNull ThrowingPredicate<? super T> mayThrowOnTest, boolean defaultValue)", "class_method_signature": "Fun.testOrDefault1(final @NotNull ThrowingPredicate<? super T> mayThrowOnTest, boolean defaultValue)", "testcase": false, "constructor": false}, {"identifier": "testOrDefault2", "parameters": "(final @NotNull ThrowingBiPredicate<? super K, ? super V> mayThrowOnTest, boolean defaultValue)", "modifiers": "public static", "return": "BiPredicate<K, V>", "signature": "BiPredicate<K, V> testOrDefault2(final @NotNull ThrowingBiPredicate<? super K, ? super V> mayThrowOnTest, boolean defaultValue)", "full_signature": "public static BiPredicate<K, V> testOrDefault2(final @NotNull ThrowingBiPredicate<? super K, ? super V> mayThrowOnTest, boolean defaultValue)", "class_method_signature": "Fun.testOrDefault2(final @NotNull ThrowingBiPredicate<? super K, ? super V> mayThrowOnTest, boolean defaultValue)", "testcase": false, "constructor": false}, {"identifier": "tryOrDefault0", "parameters": "(final @NotNull ThrowingSupplier<R> mayThrowOnGet, @Nullable R defaultValue)", "modifiers": "public static", "return": "Supplier<R>", "signature": "Supplier<R> tryOrDefault0(final @NotNull ThrowingSupplier<R> mayThrowOnGet, @Nullable R defaultValue)", "full_signature": "public static Supplier<R> tryOrDefault0(final @NotNull ThrowingSupplier<R> mayThrowOnGet, @Nullable R defaultValue)", "class_method_signature": "Fun.tryOrDefault0(final @NotNull ThrowingSupplier<R> mayThrowOnGet, @Nullable R defaultValue)", "testcase": false, "constructor": false}, {"identifier": "tryOrDefault1", "parameters": "(final @NotNull ThrowingFunction<? super T, R> mayThrowOnApply, @Nullable R defaultValue)", "modifiers": "public static", "return": "Function<T, R>", "signature": "Function<T, R> tryOrDefault1(final @NotNull ThrowingFunction<? super T, R> mayThrowOnApply, @Nullable R defaultValue)", "full_signature": "public static Function<T, R> tryOrDefault1(final @NotNull ThrowingFunction<? super T, R> mayThrowOnApply, @Nullable R defaultValue)", "class_method_signature": "Fun.tryOrDefault1(final @NotNull ThrowingFunction<? super T, R> mayThrowOnApply, @Nullable R defaultValue)", "testcase": false, "constructor": false}, {"identifier": "tryOrDefault2", "parameters": "(final @NotNull ThrowingBiFunction<? super K, ? super V, R> mayThrowOnApply, @Nullable R defaultValue)", "modifiers": "public static", "return": "BiFunction<K, V, R>", "signature": "BiFunction<K, V, R> tryOrDefault2(final @NotNull ThrowingBiFunction<? super K, ? super V, R> mayThrowOnApply, @Nullable R defaultValue)", "full_signature": "public static BiFunction<K, V, R> tryOrDefault2(final @NotNull ThrowingBiFunction<? super K, ? super V, R> mayThrowOnApply, @Nullable R defaultValue)", "class_method_signature": "Fun.tryOrDefault2(final @NotNull ThrowingBiFunction<? super K, ? super V, R> mayThrowOnApply, @Nullable R defaultValue)", "testcase": false, "constructor": false}, {"identifier": "tryOrOptional0", "parameters": "(final @NotNull ThrowingSupplier<R> mayThrowOnGet)", "modifiers": "public static", "return": "Supplier<Optional<R>>", "signature": "Supplier<Optional<R>> tryOrOptional0(final @NotNull ThrowingSupplier<R> mayThrowOnGet)", "full_signature": "public static Supplier<Optional<R>> tryOrOptional0(final @NotNull ThrowingSupplier<R> mayThrowOnGet)", "class_method_signature": "Fun.tryOrOptional0(final @NotNull ThrowingSupplier<R> mayThrowOnGet)", "testcase": false, "constructor": false}, {"identifier": "tryOrOptional1", "parameters": "(final @NotNull ThrowingFunction<? super T, R> mayThrowOnApply)", "modifiers": "public static", "return": "Function<T, Optional<R>>", "signature": "Function<T, Optional<R>> tryOrOptional1(final @NotNull ThrowingFunction<? super T, R> mayThrowOnApply)", "full_signature": "public static Function<T, Optional<R>> tryOrOptional1(final @NotNull ThrowingFunction<? super T, R> mayThrowOnApply)", "class_method_signature": "Fun.tryOrOptional1(final @NotNull ThrowingFunction<? super T, R> mayThrowOnApply)", "testcase": false, "constructor": false}, {"identifier": "tryOrOptional2", "parameters": "(final @NotNull ThrowingBiFunction<? super K, ? super V, R> mayThrowOnApply)", "modifiers": "public static", "return": "BiFunction<K, V, Optional<R>>", "signature": "BiFunction<K, V, Optional<R>> tryOrOptional2(final @NotNull ThrowingBiFunction<? super K, ? super V, R> mayThrowOnApply)", "full_signature": "public static BiFunction<K, V, Optional<R>> tryOrOptional2(final @NotNull ThrowingBiFunction<? super K, ? super V, R> mayThrowOnApply)", "class_method_signature": "Fun.tryOrOptional2(final @NotNull ThrowingBiFunction<? super K, ? super V, R> mayThrowOnApply)", "testcase": false, "constructor": false}, {"identifier": "tryOrVoid1", "parameters": "(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "modifiers": "public static", "return": "Consumer<T>", "signature": "Consumer<T> tryOrVoid1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "full_signature": "public static Consumer<T> tryOrVoid1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "class_method_signature": "Fun.tryOrVoid1(final @NotNull ThrowingConsumer<? super T> mayThrowOnAccept)", "testcase": false, "constructor": false}, {"identifier": "tryOrVoid2", "parameters": "(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "modifiers": "public static", "return": "BiConsumer<K, V>", "signature": "BiConsumer<K, V> tryOrVoid2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "full_signature": "public static BiConsumer<K, V> tryOrVoid2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "class_method_signature": "Fun.tryOrVoid2(final @NotNull ThrowingBiConsumer<? super K, ? super V> mayThrowOnAccept)", "testcase": false, "constructor": false}], "file": "api/src/main/java/net/adamcin/oakpal/api/Fun.java"}, "focal_method": {"identifier": "onValue", "parameters": "(final @NotNull Consumer<? super V> consumer)", "modifiers": "public static", "return": "Consumer<Map.Entry<K, V>>", "body": "public static <K, V> Consumer<Map.Entry<K, V>>\n    onValue(final @NotNull Consumer<? super V> consumer) {\n        return entry -> consumer.accept(entry.getValue());\n    }", "signature": "Consumer<Map.Entry<K, V>> onValue(final @NotNull Consumer<? super V> consumer)", "full_signature": "public static Consumer<Map.Entry<K, V>> onValue(final @NotNull Consumer<? super V> consumer)", "class_method_signature": "Fun.onValue(final @NotNull Consumer<? super V> consumer)", "testcase": false, "constructor": false, "invocations": ["accept", "getValue"]}, "repository": {"repo_id": 155883728, "url": "https://github.com/adamcin/oakpal", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 6, "size": 13349, "license": "licensed"}}