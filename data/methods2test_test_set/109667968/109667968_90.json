{"test_class": {"identifier": "LayerUtilTest", "superclass": "extends BaseTest", "interfaces": "", "fields": [{"original_string": "private Context context;", "modifier": "private", "type": "Context", "declarator": "context", "var_name": "context"}, {"original_string": "private LayerUtil layerUtil;", "modifier": "private", "type": "LayerUtil", "declarator": "layerUtil", "var_name": "layerUtil"}], "file": "library/src/test/java/io/ona/kujaku/utils/LayerUtilTest.java"}, "test_case": {"identifier": "getLayerShouldParseBackgroundLayer", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void getLayerShouldParseBackgroundLayer() throws JSONException, IOException {\n            JSONArray jsonArray = new JSONArray(\n                    IOUtil.readInputStreamAsString(context.getAssets().open(\"streets-base-layers.json\"))\n            );\n\n        Layer backgroundLayer = layerUtil.getLayer(jsonArray.get(0).toString());\n\n        Assert.assertTrue(backgroundLayer instanceof BackgroundLayer);\n        ShadowLayer shadowLayer = (ShadowLayer) Shadow.extract(backgroundLayer);\n        Assert.assertTrue(shadowLayer.getPropertyValues().containsKey(\"background-color\"));\n    }", "signature": "void getLayerShouldParseBackgroundLayer()", "full_signature": "@Test public void getLayerShouldParseBackgroundLayer()", "class_method_signature": "LayerUtilTest.getLayerShouldParseBackgroundLayer()", "testcase": true, "constructor": false, "invocations": ["readInputStreamAsString", "open", "getAssets", "getLayer", "toString", "get", "assertTrue", "extract", "assertTrue", "containsKey", "getPropertyValues"]}, "focal_class": {"identifier": "LayerUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String TYPE = \"type\";", "modifier": "public static final", "type": "String", "declarator": "TYPE = \"type\"", "var_name": "TYPE"}, {"original_string": "public static final String ID = \"id\";", "modifier": "public static final", "type": "String", "declarator": "ID = \"id\"", "var_name": "ID"}, {"original_string": "public static final String SOURCE = \"source\";", "modifier": "public static final", "type": "String", "declarator": "SOURCE = \"source\"", "var_name": "SOURCE"}, {"original_string": "public static final String SOURCE_LAYER = \"source-layer\";", "modifier": "public static final", "type": "String", "declarator": "SOURCE_LAYER = \"source-layer\"", "var_name": "SOURCE_LAYER"}, {"original_string": "public static final String MINZOOM = \"minzoom\";", "modifier": "public static final", "type": "String", "declarator": "MINZOOM = \"minzoom\"", "var_name": "MINZOOM"}, {"original_string": "public static final String MAXZOOM = \"maxzoom\";", "modifier": "public static final", "type": "String", "declarator": "MAXZOOM = \"maxzoom\"", "var_name": "MAXZOOM"}, {"original_string": "public static final String FILTER = \"filter\";", "modifier": "public static final", "type": "String", "declarator": "FILTER = \"filter\"", "var_name": "FILTER"}, {"original_string": "public static final String LAYOUT = \"layout\";", "modifier": "public static final", "type": "String", "declarator": "LAYOUT = \"layout\"", "var_name": "LAYOUT"}, {"original_string": "public static final String PAINT = \"paint\";", "modifier": "public static final", "type": "String", "declarator": "PAINT = \"paint\"", "var_name": "PAINT"}, {"original_string": "public static final String URL = \"url\";", "modifier": "public static final", "type": "String", "declarator": "URL = \"url\"", "var_name": "URL"}], "methods": [{"identifier": "getLayer", "parameters": "(@NonNull String layerJSON)", "modifiers": "@Nullable public", "return": "Layer", "signature": "Layer getLayer(@NonNull String layerJSON)", "full_signature": "@Nullable public Layer getLayer(@NonNull String layerJSON)", "class_method_signature": "LayerUtil.getLayer(@NonNull String layerJSON)", "testcase": false, "constructor": false}, {"identifier": "getFloatArray", "parameters": "(JSONArray jsonArray)", "modifiers": "@VisibleForTesting @NonNull protected", "return": "Float[]", "signature": "Float[] getFloatArray(JSONArray jsonArray)", "full_signature": "@VisibleForTesting @NonNull protected Float[] getFloatArray(JSONArray jsonArray)", "class_method_signature": "LayerUtil.getFloatArray(JSONArray jsonArray)", "testcase": false, "constructor": false}, {"identifier": "isJSONArrayOfNumbers", "parameters": "(@NonNull JSONArray jsonArray)", "modifiers": "private", "return": "boolean", "signature": "boolean isJSONArrayOfNumbers(@NonNull JSONArray jsonArray)", "full_signature": "private boolean isJSONArrayOfNumbers(@NonNull JSONArray jsonArray)", "class_method_signature": "LayerUtil.isJSONArrayOfNumbers(@NonNull JSONArray jsonArray)", "testcase": false, "constructor": false}], "file": "library/src/main/java/io/ona/kujaku/utils/LayerUtil.java"}, "focal_method": {"identifier": "getLayer", "parameters": "(@NonNull String layerJSON)", "modifiers": "@Nullable public", "return": "Layer", "body": "@Nullable\n    public Layer getLayer(@NonNull String layerJSON) {\n        Layer layer = null;\n        try {\n            JSONObject jsonObject = new JSONObject(layerJSON);\n            String layerType = jsonObject.getString(TYPE);\n            String layerId = jsonObject.getString(ID);\n            String source = jsonObject.optString(SOURCE);\n            String sourceLayer = jsonObject.optString(SOURCE_LAYER);\n            String filter = jsonObject.optString(FILTER);\n            Expression filterExpression = null;\n\n            ArrayList<PropertyValue> propertyValues = new ArrayList<>();\n\n            if (!jsonObject.optString(LAYOUT).equals(\"\")) {\n                JSONObject layoutObject = jsonObject.optJSONObject(LAYOUT);\n\n                Iterator<String> keys = layoutObject.keys();\n                while (keys.hasNext()) {\n                    String key = keys.next();\n                    Object value = layoutObject.opt(key);\n\n                    if (value instanceof JSONArray) {\n                        // Check if this is an array of numbers\n                        JSONArray jsonArray = (JSONArray) value;\n\n                        if (isJSONArrayOfNumbers(jsonArray)) {\n                            if (\"text-offset\".equals(key)) {\n                                value = getFloatArray(jsonArray);\n                            }\n                        } else {\n                            value = Expression.raw(value.toString());\n                        }\n                    } else if (value instanceof JSONObject) {\n                        value = value.toString();\n                    }\n\n                    if (value != null) {\n                        propertyValues.add(new ExposedLayoutPropertyValue<>(key, value));\n                    }\n\n                }\n            }\n\n            if (!jsonObject.optString(PAINT).equals(\"\")) {\n                JSONObject paintObject = jsonObject.optJSONObject(PAINT);\n\n                Iterator<String> keys = paintObject.keys();\n                while (keys.hasNext()) {\n                    String key = keys.next();\n                    Object value = paintObject.opt(key);\n\n                    if (value instanceof JSONArray) {\n                        // Check if this is an array of numbers\n                        JSONArray jsonArray = (JSONArray) value;\n\n                        if (isJSONArrayOfNumbers(jsonArray)) {\n                            if (\"line-dasharray\".equals(key) || \"line-translate\".equals(key) || \"text-translate\".equals(key)) {\n                                value = getFloatArray(jsonArray);\n                            }\n                        } else {\n                            value = Expression.raw(value.toString());\n                        }\n                    } else if (value instanceof JSONObject) {\n                        value = value.toString();\n                    }\n\n                    if (value != null) {\n                        propertyValues.add(new ExposedPaintPropertyValue<>(key, value));\n                    }\n\n                }\n            }\n\n            if (!TextUtils.isEmpty(filter)) {\n                filterExpression = Expression.raw(filter);\n            }\n\n            if (layerType.equals(LAYER_TYPE.RASTER)) {\n                layer = new RasterLayer(layerId, source);\n                if (!TextUtils.isEmpty(sourceLayer)) {\n                    ((RasterLayer) layer).setSourceLayer(sourceLayer);\n                }\n            } else if (layerType.equals(LAYER_TYPE.FILL)) {\n                layer = new FillLayer(layerId, source);\n                if (!TextUtils.isEmpty(sourceLayer)) {\n                    ((FillLayer) layer).setSourceLayer(sourceLayer);\n                }\n\n                if (filterExpression != null) {\n                    ((FillLayer) layer).setFilter(filterExpression);\n                }\n            } else if (layerType.equals(LAYER_TYPE.LINE)) {\n                layer = new LineLayer(layerId, source);\n                if (!TextUtils.isEmpty(sourceLayer)) {\n                    ((LineLayer) layer).setSourceLayer(sourceLayer);\n                }\n\n                if (filterExpression != null) {\n                    ((LineLayer) layer).setFilter(filterExpression);\n                }\n            } else if (layerType.equals(LAYER_TYPE.SYMBOL)) {\n                layer = new SymbolLayer(layerId, source);\n                if (!TextUtils.isEmpty(sourceLayer)) {\n                    ((SymbolLayer) layer).setSourceLayer(sourceLayer);\n                }\n\n                if (filterExpression != null) {\n                    ((SymbolLayer) layer).setFilter(filterExpression);\n                }\n            } else if (layerType.equals(LAYER_TYPE.CIRCLE)) {\n                layer = new CircleLayer(layerId, source);\n                if (!TextUtils.isEmpty(sourceLayer)) {\n                    ((CircleLayer) layer).setSourceLayer(sourceLayer);\n                }\n\n                if (filterExpression != null) {\n                    ((CircleLayer) layer).setFilter(filterExpression);\n                }\n            } else if (layerType.equals(LAYER_TYPE.HEATMAP)) {\n                layer = new HeatmapLayer(layerId, source);\n                if (!TextUtils.isEmpty(sourceLayer)) {\n                    ((HeatmapLayer) layer).setSourceLayer(sourceLayer);\n                }\n\n                if (filterExpression != null) {\n                    ((HeatmapLayer) layer).setFilter(filterExpression);\n                }\n            } else if (layerType.equals(LAYER_TYPE.FILL_EXTRUSION)) {\n                layer = new FillExtrusionLayer(layerId, source);\n                if (!TextUtils.isEmpty(sourceLayer)) {\n                    ((FillExtrusionLayer) layer).setSourceLayer(sourceLayer);\n                }\n\n                if (filterExpression != null) {\n                    ((FillExtrusionLayer) layer).setFilter(filterExpression);\n                }\n            } else if (layerType.equals(LAYER_TYPE.HILLSHADE)) {\n                layer = new HillshadeLayer(layerId, source);\n                if (!TextUtils.isEmpty(sourceLayer)) {\n                    ((HillshadeLayer) layer).setSourceLayer(sourceLayer);\n                }\n            } else if (layerType.equals(LAYER_TYPE.BACKGROUND)) {\n                layer = new BackgroundLayer(layerId);\n            }\n\n            if (layer != null) {\n                layer.setProperties(propertyValues.toArray(new PropertyValue[0]));\n\n                if (jsonObject.has(MINZOOM)) {\n                    layer.setMinZoom(((Double) jsonObject.getDouble(MINZOOM)).floatValue());\n                }\n\n                if (jsonObject.has(MAXZOOM)) {\n                    layer.setMaxZoom(((Double) jsonObject.getDouble(MAXZOOM)).floatValue());\n                }\n            }\n        } catch (JSONException e) {\n            Timber.e(e);\n            return null;\n        }\n\n        return layer;\n    }", "signature": "Layer getLayer(@NonNull String layerJSON)", "full_signature": "@Nullable public Layer getLayer(@NonNull String layerJSON)", "class_method_signature": "LayerUtil.getLayer(@NonNull String layerJSON)", "testcase": false, "constructor": false, "invocations": ["getString", "getString", "optString", "optString", "optString", "equals", "optString", "optJSONObject", "keys", "hasNext", "next", "opt", "isJSONArrayOfNumbers", "equals", "getFloatArray", "raw", "toString", "toString", "add", "equals", "optString", "optJSONObject", "keys", "hasNext", "next", "opt", "isJSONArrayOfNumbers", "equals", "equals", "equals", "getFloatArray", "raw", "toString", "toString", "add", "isEmpty", "raw", "equals", "isEmpty", "setSourceLayer", "equals", "isEmpty", "setSourceLayer", "setFilter", "equals", "isEmpty", "setSourceLayer", "setFilter", "equals", "isEmpty", "setSourceLayer", "setFilter", "equals", "isEmpty", "setSourceLayer", "setFilter", "equals", "isEmpty", "setSourceLayer", "setFilter", "equals", "isEmpty", "setSourceLayer", "setFilter", "equals", "isEmpty", "setSourceLayer", "equals", "setProperties", "toArray", "has", "setMinZoom", "floatValue", "getDouble", "has", "setMaxZoom", "floatValue", "getDouble", "e"]}, "repository": {"repo_id": 109667968, "url": "https://github.com/onaio/kujaku", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 14, "size": 4778, "license": "licensed"}}