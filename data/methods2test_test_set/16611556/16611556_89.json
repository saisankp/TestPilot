{"test_class": {"identifier": "ReadThroughMultiCacheAdviceTest", "superclass": "extends AbstractCacheTest<ReadThroughMultiCacheAdvice>", "interfaces": "", "fields": [{"original_string": "private static final String NS = \"ABC_NS\";", "modifier": "private static final", "type": "String", "declarator": "NS = \"ABC_NS\"", "var_name": "NS"}, {"original_string": "private static final int EXPIRATION = 321;", "modifier": "private static final", "type": "int", "declarator": "EXPIRATION = 321", "var_name": "EXPIRATION"}, {"original_string": "private final List<?> expectedValue;", "modifier": "private final", "type": "List<?>", "declarator": "expectedValue", "var_name": "expectedValue"}, {"original_string": "private final String[] cacheKeys;", "modifier": "private final", "type": "String[]", "declarator": "cacheKeys", "var_name": "cacheKeys"}], "file": "simple-spring-memcached/src/test/java/com/google/code/ssm/aop/ReadThroughMultiCacheAdviceTest.java"}, "test_case": {"identifier": "validCacheHit", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void validCacheHit() throws Throwable {\n        Assume.assumeTrue(isValid);\n        Map<String, Object> map = new HashMap<String, Object>();\n        for (int i = 0; i < cacheKeys.length; i++) {\n            map.put(cacheKeys[i], expectedValue.get(i));\n        }\n\n        when(cache.getBulk(eq(new HashSet<String>(Arrays.asList(cacheKeys))), any(SerializationType.class))).thenReturn(map);\n\n        assertEquals(expectedValue, advice.cacheMulti(pjp));\n\n        verify(cache).getBulk(eq(new HashSet<String>(Arrays.asList(cacheKeys))), any(SerializationType.class));\n        verify(cache, never()).setSilently(anyString(), anyInt(), any(), any(SerializationType.class));\n        verify(pjp, never()).proceed(params);\n    }", "signature": "void validCacheHit()", "full_signature": "@Test public void validCacheHit()", "class_method_signature": "ReadThroughMultiCacheAdviceTest.validCacheHit()", "testcase": true, "constructor": false, "invocations": ["assumeTrue", "put", "get", "thenReturn", "when", "getBulk", "eq", "asList", "any", "assertEquals", "cacheMulti", "getBulk", "verify", "eq", "asList", "any", "setSilently", "verify", "never", "anyString", "anyInt", "any", "any", "proceed", "verify", "never"]}, "focal_class": {"identifier": "ReadThroughMultiCacheAdvice", "superclass": "extends MultiCacheAdvice", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(ReadThroughMultiCacheAdvice.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(ReadThroughMultiCacheAdvice.class)", "var_name": "LOG"}], "methods": [{"identifier": "getMulti", "parameters": "()", "modifiers": "@Pointcut(\"@annotation(com.google.code.ssm.api.ReadThroughMultiCache)\") public", "return": "void", "signature": "void getMulti()", "full_signature": "@Pointcut(\"@annotation(com.google.code.ssm.api.ReadThroughMultiCache)\") public void getMulti()", "class_method_signature": "ReadThroughMultiCacheAdvice.getMulti()", "testcase": false, "constructor": false}, {"identifier": "cacheMulti", "parameters": "(final ProceedingJoinPoint pjp)", "modifiers": "@Around(\"getMulti()\") @SuppressWarnings(\"unchecked\") public", "return": "Object", "signature": "Object cacheMulti(final ProceedingJoinPoint pjp)", "full_signature": "@Around(\"getMulti()\") @SuppressWarnings(\"unchecked\") public Object cacheMulti(final ProceedingJoinPoint pjp)", "class_method_signature": "ReadThroughMultiCacheAdvice.cacheMulti(final ProceedingJoinPoint pjp)", "testcase": false, "constructor": false}, {"identifier": "setMultiCacheOptions", "parameters": "(final MultiCacheCoordinator coord, final ReadThroughMultiCacheOption options)", "modifiers": "private", "return": "void", "signature": "void setMultiCacheOptions(final MultiCacheCoordinator coord, final ReadThroughMultiCacheOption options)", "full_signature": "private void setMultiCacheOptions(final MultiCacheCoordinator coord, final ReadThroughMultiCacheOption options)", "class_method_signature": "ReadThroughMultiCacheAdvice.setMultiCacheOptions(final MultiCacheCoordinator coord, final ReadThroughMultiCacheOption options)", "testcase": false, "constructor": false}, {"identifier": "generateByKeysFromResult", "parameters": "(final List<Object> results, final MultiCacheCoordinator coord,\n            final SerializationType serializationType)", "modifiers": "private", "return": "List<?>", "signature": "List<?> generateByKeysFromResult(final List<Object> results, final MultiCacheCoordinator coord,\n            final SerializationType serializationType)", "full_signature": "private List<?> generateByKeysFromResult(final List<Object> results, final MultiCacheCoordinator coord,\n            final SerializationType serializationType)", "class_method_signature": "ReadThroughMultiCacheAdvice.generateByKeysFromResult(final List<Object> results, final MultiCacheCoordinator coord,\n            final SerializationType serializationType)", "testcase": false, "constructor": false}, {"identifier": "generateByKeysProviders", "parameters": "(final List<Object> results, final MultiCacheCoordinator coord,\n            final SerializationType serializationType)", "modifiers": "private", "return": "List<?>", "signature": "List<?> generateByKeysProviders(final List<Object> results, final MultiCacheCoordinator coord,\n            final SerializationType serializationType)", "full_signature": "private List<?> generateByKeysProviders(final List<Object> results, final MultiCacheCoordinator coord,\n            final SerializationType serializationType)", "class_method_signature": "ReadThroughMultiCacheAdvice.generateByKeysProviders(final List<Object> results, final MultiCacheCoordinator coord,\n            final SerializationType serializationType)", "testcase": false, "constructor": false}, {"identifier": "getLogger", "parameters": "()", "modifiers": "@Override protected", "return": "Logger", "signature": "Logger getLogger()", "full_signature": "@Override protected Logger getLogger()", "class_method_signature": "ReadThroughMultiCacheAdvice.getLogger()", "testcase": false, "constructor": false}], "file": "simple-spring-memcached/src/main/java/com/google/code/ssm/aop/ReadThroughMultiCacheAdvice.java"}, "focal_method": {"identifier": "cacheMulti", "parameters": "(final ProceedingJoinPoint pjp)", "modifiers": "@Around(\"getMulti()\") @SuppressWarnings(\"unchecked\") public", "return": "Object", "body": "@Around(\"getMulti()\")\n    @SuppressWarnings(\"unchecked\")\n    public Object cacheMulti(final ProceedingJoinPoint pjp) throws Throwable {\n        if (isDisabled()) {\n            getLogger().info(\"Cache disabled\");\n            return pjp.proceed();\n        }\n\n        // This is injected caching. If anything goes wrong in the caching, LOG\n        // the crap outta it, but do not let it surface up past the AOP injection itself.\n        final ReadThroughMultiCache annotation;\n        final MultiCacheCoordinator coord;\n        final AnnotationData data;\n        final SerializationType serializationType;\n\n        Object[] args = pjp.getArgs();\n        try {\n            // Get the target method being invoked, and make sure it returns the correct info.\n            final Method methodToCache = getCacheBase().getMethodToCache(pjp, ReadThroughMultiCache.class);\n            getCacheBase().verifyReturnTypeIsList(methodToCache, ReadThroughMultiCache.class);\n\n            // Get the annotation associated with this method, and make sure the values are valid.\n            annotation = methodToCache.getAnnotation(ReadThroughMultiCache.class);\n            serializationType = getCacheBase().getSerializationType(methodToCache);\n\n            data = AnnotationDataBuilder.buildAnnotationData(annotation, ReadThroughMultiCache.class, methodToCache);\n            coord = new MultiCacheCoordinator(methodToCache, data);\n            setMultiCacheOptions(coord, annotation.option());\n\n            // Create key->object and object->key mappings.\n            coord.setHolder(createObjectIdCacheKeyMapping(data, args, coord.getMethod()));\n\n            List<Object> listKeyObjects = (List<Object>) Utils.getMethodArg(data.getListIndexInMethodArgs(), args, coord.getMethod()\n                    .toString());\n            coord.setListKeyObjects(listKeyObjects);\n\n            // Get the full list of cache keys and ask the cache for the corresponding values.\n            coord.setInitialKey2Result(getCacheBase().getCache(data).getBulk(coord.getKey2Obj().keySet(), serializationType));\n\n            // We've gotten all positive cache results back, so build up a results list and return it.\n            if (coord.getMissedObjects().isEmpty()) {\n                return coord.generateResultList();\n            }\n\n            // Create the new list of arguments with a subset of the key objects that aren't in the cache. Do not modify\n            // directly argument array from join point!\n            args = coord.createModifiedArgumentList(args);\n        } catch (Exception ex) {\n            warn(ex, \"Caching on %s aborted due to an error.\", pjp.toShortString());\n            return pjp.proceed();\n        }\n\n        /*\n         * Call the target method with the new subset of arguments. We are calling this outside of the try/catch block\n         * in case there are some 'not our fault' problems with the target method. (Connection issues, etc...) Though,\n         * this decision could go either way, really.\n         */\n        final List<Object> results = (List<Object>) pjp.proceed(args);\n\n        try {\n            // there are no results\n            if (results == null || results.isEmpty()) {\n                if (coord.isAddNullsToCache()) {\n                    addNullValues(coord.getMissedObjects(), coord, serializationType);\n                }\n                return coord.generatePartialResultList();\n            }\n\n            if (coord.isGenerateKeysFromResult()) {\n                return generateByKeysFromResult(results, coord, serializationType);\n            } else {\n                return generateByKeysProviders(results, coord, serializationType);\n            }\n        } catch (Exception ex) {\n            warn(ex, \"Caching on %s aborted due to an error. The underlying method will be called twice.\", pjp.toShortString());\n            // invoke underlying method again using unmodified arguments array\n            return pjp.proceed(pjp.getArgs());\n        }\n    }", "signature": "Object cacheMulti(final ProceedingJoinPoint pjp)", "full_signature": "@Around(\"getMulti()\") @SuppressWarnings(\"unchecked\") public Object cacheMulti(final ProceedingJoinPoint pjp)", "class_method_signature": "ReadThroughMultiCacheAdvice.cacheMulti(final ProceedingJoinPoint pjp)", "testcase": false, "constructor": false, "invocations": ["isDisabled", "info", "getLogger", "proceed", "getArgs", "getMethodToCache", "getCacheBase", "verifyReturnTypeIsList", "getCacheBase", "getAnnotation", "getSerializationType", "getCacheBase", "buildAnnotationData", "setMultiCacheOptions", "option", "setHolder", "createObjectIdCacheKeyMapping", "getMethod", "getMethodArg", "getListIndexInMethodArgs", "toString", "getMethod", "setListKeyObjects", "setInitialKey2Result", "getBulk", "getCache", "getCacheBase", "keySet", "getKey2Obj", "isEmpty", "getMissedObjects", "generateResultList", "createModifiedArgumentList", "warn", "toShortString", "proceed", "proceed", "isEmpty", "isAddNullsToCache", "addNullValues", "getMissedObjects", "generatePartialResultList", "isGenerateKeysFromResult", "generateByKeysFromResult", "generateByKeysProviders", "warn", "toShortString", "proceed", "getArgs"]}, "repository": {"repo_id": 16611556, "url": "https://github.com/ragnor/simple-spring-memcached", "language": "Java", "is_fork": false, "fork_count": 86, "stargazer_count": 181, "size": 3625, "license": "licensed"}}