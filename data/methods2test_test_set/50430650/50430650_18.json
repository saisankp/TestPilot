{"test_class": {"identifier": "ExecutionNodeRunnerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ExecutionNodeRunner runner = null;", "modifier": "private", "type": "ExecutionNodeRunner", "declarator": "runner = null", "var_name": "runner"}], "file": "core/src/test/java/com/technophobia/substeps/runner/ExecutionNodeRunnerTest.java"}, "test_case": {"identifier": "testExecutionNodeTreeBuildingWithScenarioName", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testExecutionNodeTreeBuildingWithScenarioName() {\n\n        // this failure used to be more dramatic - now the parameter name is\n        // passed instead - not such a big failure\n\n        final String feature = \"./target/test-classes/features/allFeatures.feature\";\n        final String scenarioName = \"Simple top level scenario\";\n        final String substeps = \"./target/test-classes/substeps/simple.substeps\";\n        final IExecutionListener notifier = mock(IExecutionListener.class);\n\n        final List<SubstepExecutionFailure> failures = new ArrayList<>();\n\n\n        final List<Class<?>> stepImplementationClasses = new ArrayList<>();\n        stepImplementationClasses.add(MockStepImplementations.class);\n\n        final SubstepsExecutionConfig executionConfig = new SubstepsExecutionConfig();\n\n        Assert.assertTrue(failures.isEmpty());\n\n        executionConfig.setScenarioName(scenarioName);\n        executionConfig.setFeatureFile(feature);\n        executionConfig.setSubStepsFileName(substeps);\n        executionConfig.setDescription(\"ExecutionNodeRunner Test feature set\");\n\n        executionConfig.setStepImplementationClasses(stepImplementationClasses);\n\n        executionConfig.setStrict(false);\n        executionConfig.setNonStrictKeywordPrecedence(new String[]{\"Given\", \"And\"});\n\n        executionConfig.setFastFailParseErrors(false);\n\n        Config masterConfig = NewSubstepsExecutionConfig.toConfig(executionConfig);\n        Config cfg = SubstepsConfigLoader.splitMasterConfig(masterConfig).get(0);\n\n        NewSubstepsExecutionConfig.setThreadLocalConfig(cfg);\n\n        final RootNode rootNode = runner.prepareExecutionConfig(cfg);\n\n        Assert.assertThat(rootNode.getChildren().size(), is(1));\n\n        Assert.assertThat(rootNode.getChildren().get(0).getChildren().size(), is(1));\n    }", "signature": "void testExecutionNodeTreeBuildingWithScenarioName()", "full_signature": "@Test public void testExecutionNodeTreeBuildingWithScenarioName()", "class_method_signature": "ExecutionNodeRunnerTest.testExecutionNodeTreeBuildingWithScenarioName()", "testcase": true, "constructor": false, "invocations": ["mock", "add", "assertTrue", "isEmpty", "setScenarioName", "setFeatureFile", "setSubStepsFileName", "setDescription", "setStepImplementationClasses", "setStrict", "setNonStrictKeywordPrecedence", "setFastFailParseErrors", "toConfig", "get", "splitMasterConfig", "setThreadLocalConfig", "prepareExecutionConfig", "assertThat", "size", "getChildren", "is", "assertThat", "size", "getChildren", "get", "getChildren", "is"]}, "focal_class": {"identifier": "ExecutionNodeRunner", "superclass": "", "interfaces": "implements SubstepsRunner", "fields": [{"original_string": "private static final String DRY_RUN_KEY = \"dryRun\";", "modifier": "private static final", "type": "String", "declarator": "DRY_RUN_KEY = \"dryRun\"", "var_name": "DRY_RUN_KEY"}, {"original_string": "private static final Logger log = LoggerFactory.getLogger(ExecutionNodeRunner.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(ExecutionNodeRunner.class)", "var_name": "log"}, {"original_string": "private RootNode rootNode;", "modifier": "private", "type": "RootNode", "declarator": "rootNode", "var_name": "rootNode"}, {"original_string": "private final INotificationDistributor notificationDistributor = new NotificationDistributor();", "modifier": "private final", "type": "INotificationDistributor", "declarator": "notificationDistributor = new NotificationDistributor()", "var_name": "notificationDistributor"}, {"original_string": "private RootNodeExecutionContext nodeExecutionContext;", "modifier": "private", "type": "RootNodeExecutionContext", "declarator": "nodeExecutionContext", "var_name": "nodeExecutionContext"}, {"original_string": "private final MethodExecutor methodExecutor = new ImplementationCache();", "modifier": "private final", "type": "MethodExecutor", "declarator": "methodExecutor = new ImplementationCache()", "var_name": "methodExecutor"}, {"original_string": "private final RootNodeRunner rootNodeRunner = new RootNodeRunner();", "modifier": "private final", "type": "RootNodeRunner", "declarator": "rootNodeRunner = new RootNodeRunner()", "var_name": "rootNodeRunner"}, {"original_string": "private List<SubstepExecutionFailure> failures;", "modifier": "private", "type": "List<SubstepExecutionFailure>", "declarator": "failures", "var_name": "failures"}, {"original_string": "private final ReportingUtil reportingUtil = new ReportingUtil();", "modifier": "private final", "type": "ReportingUtil", "declarator": "reportingUtil = new ReportingUtil()", "var_name": "reportingUtil"}, {"original_string": "private final Map<ExecutionNodeUsage, List<ExecutionNodeUsage>> callerHierarchy = new HashMap<ExecutionNodeUsage, List<ExecutionNodeUsage>>();", "modifier": "private final", "type": "Map<ExecutionNodeUsage, List<ExecutionNodeUsage>>", "declarator": "callerHierarchy = new HashMap<ExecutionNodeUsage, List<ExecutionNodeUsage>>()", "var_name": "callerHierarchy"}], "methods": [{"identifier": "addNotifier", "parameters": "(final IExecutionListener notifier)", "modifiers": "@Override public", "return": "void", "signature": "void addNotifier(final IExecutionListener notifier)", "full_signature": "@Override public void addNotifier(final IExecutionListener notifier)", "class_method_signature": "ExecutionNodeRunner.addNotifier(final IExecutionListener notifier)", "testcase": false, "constructor": false}, {"identifier": "prepareExecutionConfig", "parameters": "(final Config config , final Syntax syntax, final TestParameters parameters,\n                                           final SetupAndTearDown setupAndTearDown ,\n                                           final MethodExecutor methodExecutorToUse,\n                                           TagManager nonFatalTagmanager )", "modifiers": "public", "return": "RootNode", "signature": "RootNode prepareExecutionConfig(final Config config , final Syntax syntax, final TestParameters parameters,\n                                           final SetupAndTearDown setupAndTearDown ,\n                                           final MethodExecutor methodExecutorToUse,\n                                           TagManager nonFatalTagmanager )", "full_signature": "public RootNode prepareExecutionConfig(final Config config , final Syntax syntax, final TestParameters parameters,\n                                           final SetupAndTearDown setupAndTearDown ,\n                                           final MethodExecutor methodExecutorToUse,\n                                           TagManager nonFatalTagmanager )", "class_method_signature": "ExecutionNodeRunner.prepareExecutionConfig(final Config config , final Syntax syntax, final TestParameters parameters,\n                                           final SetupAndTearDown setupAndTearDown ,\n                                           final MethodExecutor methodExecutorToUse,\n                                           TagManager nonFatalTagmanager )", "testcase": false, "constructor": false}, {"identifier": "buildInitialisationClassList", "parameters": "(List<Class<?>> stepImplClassList, List<Class<?>> initialisationClassList)", "modifiers": "public static", "return": "Class<?>[]", "signature": "Class<?>[] buildInitialisationClassList(List<Class<?>> stepImplClassList, List<Class<?>> initialisationClassList)", "full_signature": "public static Class<?>[] buildInitialisationClassList(List<Class<?>> stepImplClassList, List<Class<?>> initialisationClassList)", "class_method_signature": "ExecutionNodeRunner.buildInitialisationClassList(List<Class<?>> stepImplClassList, List<Class<?>> initialisationClassList)", "testcase": false, "constructor": false}, {"identifier": "prepareExecutionConfig", "parameters": "(Config cfg)", "modifiers": "@Override public", "return": "RootNode", "signature": "RootNode prepareExecutionConfig(Config cfg)", "full_signature": "@Override public RootNode prepareExecutionConfig(Config cfg)", "class_method_signature": "ExecutionNodeRunner.prepareExecutionConfig(Config cfg)", "testcase": false, "constructor": false}, {"identifier": "setupExecutionListeners", "parameters": "( final List<Class<? extends IExecutionListener>> executionListenerClasses)", "modifiers": "private", "return": "void", "signature": "void setupExecutionListeners( final List<Class<? extends IExecutionListener>> executionListenerClasses)", "full_signature": "private void setupExecutionListeners( final List<Class<? extends IExecutionListener>> executionListenerClasses)", "class_method_signature": "ExecutionNodeRunner.setupExecutionListeners( final List<Class<? extends IExecutionListener>> executionListenerClasses)", "testcase": false, "constructor": false}, {"identifier": "processUncalledAndUnused", "parameters": "(final Syntax syntax, final File dataOutputDir)", "modifiers": "private", "return": "void", "signature": "void processUncalledAndUnused(final Syntax syntax, final File dataOutputDir)", "full_signature": "private void processUncalledAndUnused(final Syntax syntax, final File dataOutputDir)", "class_method_signature": "ExecutionNodeRunner.processUncalledAndUnused(final Syntax syntax, final File dataOutputDir)", "testcase": false, "constructor": false}, {"identifier": "checkForUncalledParentSteps", "parameters": "(final Syntax syntax, File outputDir)", "modifiers": "private", "return": "void", "signature": "void checkForUncalledParentSteps(final Syntax syntax, File outputDir)", "full_signature": "private void checkForUncalledParentSteps(final Syntax syntax, File outputDir)", "class_method_signature": "ExecutionNodeRunner.checkForUncalledParentSteps(final Syntax syntax, File outputDir)", "testcase": false, "constructor": false}, {"identifier": "thereIsNotAStepThatMatchesThisPattern", "parameters": "(final String stepPattern, final Set<ExecutionNodeUsage> calledExecutionNodes)", "modifiers": "private", "return": "boolean", "signature": "boolean thereIsNotAStepThatMatchesThisPattern(final String stepPattern, final Set<ExecutionNodeUsage> calledExecutionNodes)", "full_signature": "private boolean thereIsNotAStepThatMatchesThisPattern(final String stepPattern, final Set<ExecutionNodeUsage> calledExecutionNodes)", "class_method_signature": "ExecutionNodeRunner.thereIsNotAStepThatMatchesThisPattern(final String stepPattern, final Set<ExecutionNodeUsage> calledExecutionNodes)", "testcase": false, "constructor": false}, {"identifier": "buildCallHierarchy", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void buildCallHierarchy()", "full_signature": "private void buildCallHierarchy()", "class_method_signature": "ExecutionNodeRunner.buildCallHierarchy()", "testcase": false, "constructor": false}, {"identifier": "processChildrenForCallHierarchy", "parameters": "(final List children)", "modifiers": "private", "return": "void", "signature": "void processChildrenForCallHierarchy(final List children)", "full_signature": "private void processChildrenForCallHierarchy(final List children)", "class_method_signature": "ExecutionNodeRunner.processChildrenForCallHierarchy(final List children)", "testcase": false, "constructor": false}, {"identifier": "addToCallHierarchy", "parameters": "(final IExecutionNode node)", "modifiers": "private", "return": "void", "signature": "void addToCallHierarchy(final IExecutionNode node)", "full_signature": "private void addToCallHierarchy(final IExecutionNode node)", "class_method_signature": "ExecutionNodeRunner.addToCallHierarchy(final IExecutionNode node)", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "RootNode", "signature": "RootNode run()", "full_signature": "@Override public RootNode run()", "class_method_signature": "ExecutionNodeRunner.run()", "testcase": false, "constructor": false}, {"identifier": "getFailures", "parameters": "()", "modifiers": "@Override public", "return": "List<SubstepExecutionFailure>", "signature": "List<SubstepExecutionFailure> getFailures()", "full_signature": "@Override public List<SubstepExecutionFailure> getFailures()", "class_method_signature": "ExecutionNodeRunner.getFailures()", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/technophobia/substeps/runner/ExecutionNodeRunner.java"}, "focal_method": {"identifier": "prepareExecutionConfig", "parameters": "(final Config config , final Syntax syntax, final TestParameters parameters,\n                                           final SetupAndTearDown setupAndTearDown ,\n                                           final MethodExecutor methodExecutorToUse,\n                                           TagManager nonFatalTagmanager )", "modifiers": "public", "return": "RootNode", "body": "public RootNode prepareExecutionConfig(final Config config , final Syntax syntax, final TestParameters parameters,\n                                           final SetupAndTearDown setupAndTearDown ,\n                                           final MethodExecutor methodExecutorToUse,\n                                           TagManager nonFatalTagmanager ) {\n\n\n        final ExecutionNodeTreeBuilder nodeTreeBuilder = new ExecutionNodeTreeBuilder(parameters, config);\n\n        // building the tree can throw critical failures if exceptions are found\n        this.rootNode = nodeTreeBuilder.buildExecutionNodeTree(NewSubstepsExecutionConfig.getDescription(config));\n\n        setupExecutionListeners(NewSubstepsExecutionConfig.getExecutionListenerClasses(config));\n\n\n\n        if (NewSubstepsExecutionConfig.isCheckForUncalledAndUnused(config)) {\n            processUncalledAndUnused(syntax, NewSubstepsExecutionConfig.getDataOutputDirectory(config));\n        }\n\n        ExecutionContext.put(Scope.SUITE, INotificationDistributor.NOTIFIER_DISTRIBUTOR_KEY,\n                this.notificationDistributor);\n\n\n        this.nodeExecutionContext = new RootNodeExecutionContext(this.notificationDistributor,\n                Lists.<SubstepExecutionFailure>newArrayList(), setupAndTearDown, nonFatalTagmanager,\n                methodExecutorToUse);\n\n        return this.rootNode;\n\n    }", "signature": "RootNode prepareExecutionConfig(final Config config , final Syntax syntax, final TestParameters parameters,\n                                           final SetupAndTearDown setupAndTearDown ,\n                                           final MethodExecutor methodExecutorToUse,\n                                           TagManager nonFatalTagmanager )", "full_signature": "public RootNode prepareExecutionConfig(final Config config , final Syntax syntax, final TestParameters parameters,\n                                           final SetupAndTearDown setupAndTearDown ,\n                                           final MethodExecutor methodExecutorToUse,\n                                           TagManager nonFatalTagmanager )", "class_method_signature": "ExecutionNodeRunner.prepareExecutionConfig(final Config config , final Syntax syntax, final TestParameters parameters,\n                                           final SetupAndTearDown setupAndTearDown ,\n                                           final MethodExecutor methodExecutorToUse,\n                                           TagManager nonFatalTagmanager )", "testcase": false, "constructor": false, "invocations": ["buildExecutionNodeTree", "getDescription", "setupExecutionListeners", "getExecutionListenerClasses", "isCheckForUncalledAndUnused", "processUncalledAndUnused", "getDataOutputDirectory", "put", "newArrayList"]}, "repository": {"repo_id": 50430650, "url": "https://github.com/Substeps/substeps-framework", "language": "Java", "is_fork": false, "fork_count": 5, "stargazer_count": 5, "size": 2783, "license": "licensed"}}