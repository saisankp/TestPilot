{"test_class": {"identifier": "StreamUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "dubbo-common/src/test/java/org/apache/dubbo/common/io/StreamUtilsTest.java"}, "test_case": {"identifier": "testLimitedInputStream", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testLimitedInputStream() throws Exception {\n        InputStream is = StreamUtilsTest.class.getResourceAsStream(\"/StreamUtilsTest.txt\");\n        assertThat(10, is(is.available()));\n\n        is = StreamUtils.limitedInputStream(is, 2);\n        assertThat(2, is(is.available()));\n        assertThat(is.markSupported(), is(true));\n\n        is.mark(0);\n        assertEquals((int) '0', is.read());\n        assertEquals((int) '1', is.read());\n        assertEquals(-1, is.read());\n\n        is.reset();\n        is.skip(1);\n        assertEquals((int) '1', is.read());\n\n        is.reset();\n        is.skip(-1);\n        assertEquals((int) '0', is.read());\n\n        is.reset();\n        byte[] bytes = new byte[2];\n        int read = is.read(bytes, 1, 1);\n        assertThat(read, is(1));\n\n        is.reset();\n        StreamUtils.skipUnusedStream(is);\n        assertEquals(-1, is.read());\n\n        is.close();\n    }", "signature": "void testLimitedInputStream()", "full_signature": "@Test public void testLimitedInputStream()", "class_method_signature": "StreamUtilsTest.testLimitedInputStream()", "testcase": true, "constructor": false, "invocations": ["getResourceAsStream", "assertThat", "is", "available", "limitedInputStream", "assertThat", "is", "available", "assertThat", "markSupported", "is", "mark", "assertEquals", "read", "assertEquals", "read", "assertEquals", "read", "reset", "skip", "assertEquals", "read", "reset", "skip", "assertEquals", "read", "reset", "read", "assertThat", "is", "reset", "skipUnusedStream", "assertEquals", "read", "close"]}, "focal_class": {"identifier": "StreamUtils", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "StreamUtils", "parameters": "()", "modifiers": "private", "return": "", "signature": " StreamUtils()", "full_signature": "private  StreamUtils()", "class_method_signature": "StreamUtils.StreamUtils()", "testcase": false, "constructor": true}, {"identifier": "limitedInputStream", "parameters": "(final InputStream is, final int limit)", "modifiers": "public static", "return": "InputStream", "signature": "InputStream limitedInputStream(final InputStream is, final int limit)", "full_signature": "public static InputStream limitedInputStream(final InputStream is, final int limit)", "class_method_signature": "StreamUtils.limitedInputStream(final InputStream is, final int limit)", "testcase": false, "constructor": false}, {"identifier": "markSupportedInputStream", "parameters": "(final InputStream is, final int markBufferSize)", "modifiers": "public static", "return": "InputStream", "signature": "InputStream markSupportedInputStream(final InputStream is, final int markBufferSize)", "full_signature": "public static InputStream markSupportedInputStream(final InputStream is, final int markBufferSize)", "class_method_signature": "StreamUtils.markSupportedInputStream(final InputStream is, final int markBufferSize)", "testcase": false, "constructor": false}, {"identifier": "markSupportedInputStream", "parameters": "(final InputStream is)", "modifiers": "public static", "return": "InputStream", "signature": "InputStream markSupportedInputStream(final InputStream is)", "full_signature": "public static InputStream markSupportedInputStream(final InputStream is)", "class_method_signature": "StreamUtils.markSupportedInputStream(final InputStream is)", "testcase": false, "constructor": false}, {"identifier": "skipUnusedStream", "parameters": "(InputStream is)", "modifiers": "public static", "return": "void", "signature": "void skipUnusedStream(InputStream is)", "full_signature": "public static void skipUnusedStream(InputStream is)", "class_method_signature": "StreamUtils.skipUnusedStream(InputStream is)", "testcase": false, "constructor": false}], "file": "dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java"}, "focal_method": {"identifier": "limitedInputStream", "parameters": "(final InputStream is, final int limit)", "modifiers": "public static", "return": "InputStream", "body": "public static InputStream limitedInputStream(final InputStream is, final int limit) throws IOException {\n        return new InputStream() {\n            private int mPosition = 0, mMark = 0, mLimit = Math.min(limit, is.available());\n\n            @Override\n            public int read() throws IOException {\n                if (mPosition < mLimit) {\n                    mPosition++;\n                    return is.read();\n                }\n                return -1;\n            }\n\n            @Override\n            public int read(byte[] b, int off, int len) throws IOException {\n                if (b == null) {\n                    throw new NullPointerException();\n                }\n\n                if (off < 0 || len < 0 || len > b.length - off) {\n                    throw new IndexOutOfBoundsException();\n                }\n\n                if (mPosition >= mLimit) {\n                    return -1;\n                }\n\n                if (mPosition + len > mLimit) {\n                    len = mLimit - mPosition;\n                }\n\n                if (len <= 0) {\n                    return 0;\n                }\n\n                is.read(b, off, len);\n                mPosition += len;\n                return len;\n            }\n\n            @Override\n            public long skip(long len) throws IOException {\n                if (mPosition + len > mLimit) {\n                    len = mLimit - mPosition;\n                }\n\n                if (len <= 0) {\n                    return 0;\n                }\n\n                is.skip(len);\n                mPosition += len;\n                return len;\n            }\n\n            @Override\n            public int available() {\n                return mLimit - mPosition;\n            }\n\n            @Override\n            public boolean markSupported() {\n                return is.markSupported();\n            }\n\n            @Override\n            public void mark(int readlimit) {\n                is.mark(readlimit);\n                mMark = mPosition;\n            }\n\n            @Override\n            public void reset() throws IOException {\n                is.reset();\n                mPosition = mMark;\n            }\n\n            @Override\n            public void close() throws IOException {\n                is.close();\n            }\n        };\n    }", "signature": "InputStream limitedInputStream(final InputStream is, final int limit)", "full_signature": "public static InputStream limitedInputStream(final InputStream is, final int limit)", "class_method_signature": "StreamUtils.limitedInputStream(final InputStream is, final int limit)", "testcase": false, "constructor": false, "invocations": ["min", "available", "read", "read", "skip", "markSupported", "mark", "reset", "close"]}, "repository": {"repo_id": 4710920, "url": "https://github.com/apache/dubbo", "stars": 30960, "created": "6/19/2012 7:56:02 AM +00:00", "updates": "2020-01-27T14:21:03+00:00", "fork": "False", "license": "licensed"}}