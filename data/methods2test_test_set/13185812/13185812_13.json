{"test_class": {"identifier": "TestResponseReader", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Mock\n  SerialPort serialPort;", "modifier": "@Mock", "type": "SerialPort", "declarator": "serialPort", "var_name": "serialPort"}], "file": "dexcom-receiver/src/test/java/org/glukit/dexcom/sync/TestResponseReader.java"}, "test_case": {"identifier": "readPageRangeResponseShouldMatchExample", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void readPageRangeResponseShouldMatchExample() throws Exception {\n    when(serialPort.readBytes(HEADER_SIZE)).thenReturn(fromHexString(\"01 0E 00 01\"));\n    when(serialPort.readBytes(14 - HEADER_SIZE - TRAILER_SIZE)).thenReturn(fromHexString(\"01 00 00 00 02 00 00 00\"));\n    when(serialPort.readBytes(TRAILER_SIZE)).thenReturn(fromHexString(\"97 11\"));\n\n    ResponseReader responseReader = new ResponseReader(new LittleEndianDataInputFactory());\n    PageRangeResponse pageRangeResponse = responseReader.read(PageRangeResponse.class, this.serialPort);\n\n    assertThat(pageRangeResponse, not(nullValue()));\n    assertThat(pageRangeResponse.getFirstPage(), is(1L));\n    assertThat(pageRangeResponse.getLastPage(), is(2L));\n  }", "signature": "void readPageRangeResponseShouldMatchExample()", "full_signature": "@Test public void readPageRangeResponseShouldMatchExample()", "class_method_signature": "TestResponseReader.readPageRangeResponseShouldMatchExample()", "testcase": true, "constructor": false, "invocations": ["thenReturn", "when", "readBytes", "fromHexString", "thenReturn", "when", "readBytes", "fromHexString", "thenReturn", "when", "readBytes", "fromHexString", "read", "assertThat", "not", "nullValue", "assertThat", "getFirstPage", "is", "assertThat", "getLastPage", "is"]}, "focal_class": {"identifier": "ResponseReader", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Logger LOGGER = LoggerFactory.getLogger(ResponseReader.class);", "modifier": "private static", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ResponseReader.class)", "var_name": "LOGGER"}, {"original_string": "static final int HEADER_SIZE = 4;", "modifier": "static final", "type": "int", "declarator": "HEADER_SIZE = 4", "var_name": "HEADER_SIZE"}, {"original_string": "public static final int TRAILER_SIZE = 2;", "modifier": "public static final", "type": "int", "declarator": "TRAILER_SIZE = 2", "var_name": "TRAILER_SIZE"}, {"original_string": "private DataInputFactory dataInputFactory;", "modifier": "private", "type": "DataInputFactory", "declarator": "dataInputFactory", "var_name": "dataInputFactory"}], "methods": [{"identifier": "ResponseReader", "parameters": "(DataInputFactory dataInputFactory)", "modifiers": "@Inject public", "return": "", "signature": " ResponseReader(DataInputFactory dataInputFactory)", "full_signature": "@Inject public  ResponseReader(DataInputFactory dataInputFactory)", "class_method_signature": "ResponseReader.ResponseReader(DataInputFactory dataInputFactory)", "testcase": false, "constructor": true}, {"identifier": "read", "parameters": "(Class<T> type, SerialPort serialPort)", "modifiers": "public", "return": "T", "signature": "T read(Class<T> type, SerialPort serialPort)", "full_signature": "public T read(Class<T> type, SerialPort serialPort)", "class_method_signature": "ResponseReader.read(Class<T> type, SerialPort serialPort)", "testcase": false, "constructor": false}, {"identifier": "validateCrc", "parameters": "(byte[] packet, byte[] crcBytes)", "modifiers": "private", "return": "void", "signature": "void validateCrc(byte[] packet, byte[] crcBytes)", "full_signature": "private void validateCrc(byte[] packet, byte[] crcBytes)", "class_method_signature": "ResponseReader.validateCrc(byte[] packet, byte[] crcBytes)", "testcase": false, "constructor": false}, {"identifier": "readHeader", "parameters": "(byte[] headerBytes)", "modifiers": "private", "return": "ResponseHeader", "signature": "ResponseHeader readHeader(byte[] headerBytes)", "full_signature": "private ResponseHeader readHeader(byte[] headerBytes)", "class_method_signature": "ResponseReader.readHeader(byte[] headerBytes)", "testcase": false, "constructor": false}], "file": "dexcom-receiver/src/main/java/org/glukit/dexcom/sync/ResponseReader.java"}, "focal_method": {"identifier": "read", "parameters": "(Class<T> type, SerialPort serialPort)", "modifiers": "public", "return": "T", "body": "public <T extends Response> T read(Class<T> type, SerialPort serialPort) {\n    try {\n      T response = type.getConstructor(DataInputFactory.class).newInstance(this.dataInputFactory);\n      byte[] header = serialPort.readBytes(HEADER_SIZE);\n      LOGGER.debug(format(\"Read header from port: %s\", toHexString(header)));\n      ResponseHeader responseHeader = readHeader(header);\n\n      int expectedPayloadSize = responseHeader.getPacketSize() - (HEADER_SIZE + TRAILER_SIZE);\n      LOGGER.debug(format(\"Expected payload of [%d] bytes\", expectedPayloadSize));\n\n      byte[] payload = new byte[0];\n      if (expectedPayloadSize > 0) {\n        payload = serialPort.readBytes(expectedPayloadSize);\n        LOGGER.debug(format(\"Read payload from port: %s\", toHexString(payload)));\n        response.fromBytes(payload);\n      } else {\n        LOGGER.debug(\"No payload expected, skipping to trailer...\");\n      }\n\n      byte[] crc16 = serialPort.readBytes(TRAILER_SIZE);\n      LOGGER.debug(format(\"Read crc16 from port: %s\", toHexString(crc16)));\n      validateCrc(Bytes.concat(header, payload, crc16), crc16);\n\n      return response;\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }", "signature": "T read(Class<T> type, SerialPort serialPort)", "full_signature": "public T read(Class<T> type, SerialPort serialPort)", "class_method_signature": "ResponseReader.read(Class<T> type, SerialPort serialPort)", "testcase": false, "constructor": false, "invocations": ["newInstance", "getConstructor", "readBytes", "debug", "format", "toHexString", "readHeader", "getPacketSize", "debug", "format", "readBytes", "debug", "format", "toHexString", "fromBytes", "debug", "readBytes", "debug", "format", "toHexString", "validateCrc", "concat", "propagate"]}, "repository": {"repo_id": 13185812, "url": "https://github.com/alexandre-normand/blood-shepherd", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 7, "size": 408, "license": "licensed"}}