{"test_class": {"identifier": "NumberUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "beanmother-core/src/test/java/io/beanmother/core/util/NumberUtilsTest.java"}, "test_case": {"identifier": "testConvertNumberToTargetClass", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testConvertNumberToTargetClass() throws Exception {\n        assertEquals(new Integer(1), NumberUtils.convertNumberToTargetClass(1.1, Integer.class));\n        assertEquals(new Byte(\"1\"), NumberUtils.convertNumberToTargetClass(1.1, Byte.class));\n        assertEquals(new Float(1.1), NumberUtils.convertNumberToTargetClass(1.1, Float.class));\n        assertEquals(new Double(1.1), NumberUtils.convertNumberToTargetClass(1.1, Double.class));\n        assertEquals(new Long(1), NumberUtils.convertNumberToTargetClass(1.1, Long.class));\n        assertEquals(new Short(\"1\"), NumberUtils.convertNumberToTargetClass(1.1, Short.class));\n        assertEquals(new BigInteger(\"1\"), NumberUtils.convertNumberToTargetClass(1, BigInteger.class));\n    }", "signature": "void testConvertNumberToTargetClass()", "full_signature": "@Test public void testConvertNumberToTargetClass()", "class_method_signature": "NumberUtilsTest.testConvertNumberToTargetClass()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "convertNumberToTargetClass", "assertEquals", "convertNumberToTargetClass", "assertEquals", "convertNumberToTargetClass", "assertEquals", "convertNumberToTargetClass", "assertEquals", "convertNumberToTargetClass", "assertEquals", "convertNumberToTargetClass", "assertEquals", "convertNumberToTargetClass"]}, "focal_class": {"identifier": "NumberUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final BigInteger LONG_MIN = BigInteger.valueOf(Long.MIN_VALUE);", "modifier": "private static final", "type": "BigInteger", "declarator": "LONG_MIN = BigInteger.valueOf(Long.MIN_VALUE)", "var_name": "LONG_MIN"}, {"original_string": "private static final BigInteger LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);", "modifier": "private static final", "type": "BigInteger", "declarator": "LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE)", "var_name": "LONG_MAX"}, {"original_string": "public static final Set<Class<?>> STANDARD_NUMBER_TYPES;", "modifier": "public static final", "type": "Set<Class<?>>", "declarator": "STANDARD_NUMBER_TYPES", "var_name": "STANDARD_NUMBER_TYPES"}], "methods": [{"identifier": "convertNumberToTargetClass", "parameters": "(Number number, Class<T> targetClass)", "modifiers": "@SuppressWarnings(\"unchecked\") public static", "return": "T", "signature": "T convertNumberToTargetClass(Number number, Class<T> targetClass)", "full_signature": "@SuppressWarnings(\"unchecked\") public static T convertNumberToTargetClass(Number number, Class<T> targetClass)", "class_method_signature": "NumberUtils.convertNumberToTargetClass(Number number, Class<T> targetClass)", "testcase": false, "constructor": false}, {"identifier": "checkedLongValue", "parameters": "(Number number, Class<? extends Number> targetClass)", "modifiers": "private static", "return": "long", "signature": "long checkedLongValue(Number number, Class<? extends Number> targetClass)", "full_signature": "private static long checkedLongValue(Number number, Class<? extends Number> targetClass)", "class_method_signature": "NumberUtils.checkedLongValue(Number number, Class<? extends Number> targetClass)", "testcase": false, "constructor": false}, {"identifier": "raiseOverflowException", "parameters": "(Number number, Class<?> targetClass)", "modifiers": "private static", "return": "void", "signature": "void raiseOverflowException(Number number, Class<?> targetClass)", "full_signature": "private static void raiseOverflowException(Number number, Class<?> targetClass)", "class_method_signature": "NumberUtils.raiseOverflowException(Number number, Class<?> targetClass)", "testcase": false, "constructor": false}, {"identifier": "parseNumber", "parameters": "(String text, Class<T> targetClass)", "modifiers": "@SuppressWarnings(\"unchecked\") public static", "return": "T", "signature": "T parseNumber(String text, Class<T> targetClass)", "full_signature": "@SuppressWarnings(\"unchecked\") public static T parseNumber(String text, Class<T> targetClass)", "class_method_signature": "NumberUtils.parseNumber(String text, Class<T> targetClass)", "testcase": false, "constructor": false}, {"identifier": "isHexNumber", "parameters": "(String value)", "modifiers": "private static", "return": "boolean", "signature": "boolean isHexNumber(String value)", "full_signature": "private static boolean isHexNumber(String value)", "class_method_signature": "NumberUtils.isHexNumber(String value)", "testcase": false, "constructor": false}, {"identifier": "decodeBigInteger", "parameters": "(String value)", "modifiers": "private static", "return": "BigInteger", "signature": "BigInteger decodeBigInteger(String value)", "full_signature": "private static BigInteger decodeBigInteger(String value)", "class_method_signature": "NumberUtils.decodeBigInteger(String value)", "testcase": false, "constructor": false}, {"identifier": "trimAllWhitespace", "parameters": "(String str)", "modifiers": "public static", "return": "String", "signature": "String trimAllWhitespace(String str)", "full_signature": "public static String trimAllWhitespace(String str)", "class_method_signature": "NumberUtils.trimAllWhitespace(String str)", "testcase": false, "constructor": false}], "file": "beanmother-core/src/main/java/io/beanmother/core/util/NumberUtils.java"}, "focal_method": {"identifier": "convertNumberToTargetClass", "parameters": "(Number number, Class<T> targetClass)", "modifiers": "@SuppressWarnings(\"unchecked\") public static", "return": "T", "body": "@SuppressWarnings(\"unchecked\")\n    public static <T extends Number> T convertNumberToTargetClass(Number number, Class<T> targetClass)\n            throws IllegalArgumentException {\n\n        if (targetClass.isInstance(number)) {\n            return (T) number;\n        }\n        else if (Byte.class == targetClass) {\n            long value = checkedLongValue(number, targetClass);\n            if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n                raiseOverflowException(number, targetClass);\n            }\n            return (T) Byte.valueOf(number.byteValue());\n        }\n        else if (Short.class == targetClass) {\n            long value = checkedLongValue(number, targetClass);\n            if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n                raiseOverflowException(number, targetClass);\n            }\n            return (T) Short.valueOf(number.shortValue());\n        }\n        else if (Integer.class == targetClass) {\n            long value = checkedLongValue(number, targetClass);\n            if (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE) {\n                raiseOverflowException(number, targetClass);\n            }\n            return (T) Integer.valueOf(number.intValue());\n        }\n        else if (Long.class == targetClass) {\n            long value = checkedLongValue(number, targetClass);\n            return (T) Long.valueOf(value);\n        }\n        else if (BigInteger.class == targetClass) {\n            if (number instanceof BigDecimal) {\n                // do not lose precision - use BigDecimal's own conversion\n                return (T) ((BigDecimal) number).toBigInteger();\n            }\n            else {\n                // original value is not a Big* number - use standard long conversion\n                return (T) BigInteger.valueOf(number.longValue());\n            }\n        }\n        else if (Float.class == targetClass) {\n            return (T) Float.valueOf(number.floatValue());\n        }\n        else if (Double.class == targetClass) {\n            return (T) Double.valueOf(number.doubleValue());\n        }\n        else if (BigDecimal.class == targetClass) {\n            // always use BigDecimal(String) here to avoid unpredictability of BigDecimal(double)\n            // (see BigDecimal javadoc for details)\n            return (T) new BigDecimal(number.toString());\n        }\n        else if (AtomicInteger.class == targetClass) {\n            return (T) new AtomicInteger(number.intValue());\n        }\n        else if (AtomicLong.class == targetClass) {\n            return (T) new AtomicLong(number.longValue());\n        }\n        else {\n            throw new IllegalArgumentException(\"Could not convert number [\" + number + \"] of type [\" +\n                    number.getClass().getName() + \"] to unsupported target class [\" + targetClass.getName() + \"]\");\n        }\n    }", "signature": "T convertNumberToTargetClass(Number number, Class<T> targetClass)", "full_signature": "@SuppressWarnings(\"unchecked\") public static T convertNumberToTargetClass(Number number, Class<T> targetClass)", "class_method_signature": "NumberUtils.convertNumberToTargetClass(Number number, Class<T> targetClass)", "testcase": false, "constructor": false, "invocations": ["isInstance", "checkedLongValue", "raiseOverflowException", "valueOf", "byteValue", "checkedLongValue", "raiseOverflowException", "valueOf", "shortValue", "checkedLongValue", "raiseOverflowException", "valueOf", "intValue", "checkedLongValue", "valueOf", "toBigInteger", "valueOf", "longValue", "valueOf", "floatValue", "valueOf", "doubleValue", "toString", "intValue", "longValue", "getName", "getClass", "getName"]}, "repository": {"repo_id": 100366560, "url": "https://github.com/keepcosmos/beanmother", "language": "Java", "is_fork": false, "fork_count": 19, "stargazer_count": 95, "size": 688, "license": "licensed"}}