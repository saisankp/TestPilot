{"test_class": {"identifier": "HappyEyeballsResolverTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private HappyEyeballsResolver subject = new HappyEyeballsResolver(new HttpClient());", "modifier": "private", "type": "HappyEyeballsResolver", "declarator": "subject = new HappyEyeballsResolver(new HttpClient())", "var_name": "subject"}], "file": "rpki-validator/src/test/java/net/ripe/rpki/validator3/util/HappyEyeballsResolverTest.java"}, "test_case": {"identifier": "connectToRealAddress", "parameters": "()", "modifiers": "@Test @Ignore(\"intended for manual run only\") public", "return": "void", "body": "@Test\n    @Ignore(\"intended for manual run only\")\n    public void connectToRealAddress() throws ExecutionException, InterruptedException {\n        final SslContextFactory sslContextFactory = new SslContextFactory.Client(false);\n        HttpClient httpClient = new HttpClient(sslContextFactory);\n        httpClient.setExecutor(Executors.newCachedThreadPool());\n\n        final CompletableFuture<List<InetSocketAddress>> future = new CompletableFuture<>();\n        final Promise<List<InetSocketAddress>> promise = Promise.from(future);\n        final HappyEyeballsResolver happyEyeballsResolver = new HappyEyeballsResolver(httpClient);\n        final long startTime = System.nanoTime();\n        happyEyeballsResolver.resolve(\"www.google.com\", 80, promise);\n        final List<InetSocketAddress> inetSocketAddresses = future.get();\n        final long elapsed = System.nanoTime() - startTime;\n        System.out.printf(\"Connected to: %s in %1.3fs %n\",\n                inetSocketAddresses.get(0).getAddress().getHostAddress(), elapsed/1e9);\n        assertThat(inetSocketAddresses).isNotEmpty();\n    }", "signature": "void connectToRealAddress()", "full_signature": "@Test @Ignore(\"intended for manual run only\") public void connectToRealAddress()", "class_method_signature": "HappyEyeballsResolverTest.connectToRealAddress()", "testcase": true, "constructor": false, "invocations": ["setExecutor", "newCachedThreadPool", "from", "nanoTime", "resolve", "get", "nanoTime", "printf", "getHostAddress", "getAddress", "get", "isNotEmpty", "assertThat"]}, "focal_class": {"identifier": "HappyEyeballsResolver", "superclass": "", "interfaces": "implements SocketAddressResolver", "fields": [{"original_string": "private static final long RESOLUTION_DELAY_MILLIS = 50L;", "modifier": "private static final", "type": "long", "declarator": "RESOLUTION_DELAY_MILLIS = 50L", "var_name": "RESOLUTION_DELAY_MILLIS"}, {"original_string": "private static final long CONNECTION_ATTEMPT_DELAY_MILLIS = 250L;", "modifier": "private static final", "type": "long", "declarator": "CONNECTION_ATTEMPT_DELAY_MILLIS = 250L", "var_name": "CONNECTION_ATTEMPT_DELAY_MILLIS"}, {"original_string": "public static final long HAPPY_EYEBALLS_TOTAL_TIMEOUT_NANOS = TimeUnit.SECONDS.toNanos(10);", "modifier": "public static final", "type": "long", "declarator": "HAPPY_EYEBALLS_TOTAL_TIMEOUT_NANOS = TimeUnit.SECONDS.toNanos(10)", "var_name": "HAPPY_EYEBALLS_TOTAL_TIMEOUT_NANOS"}, {"original_string": "private static final Pattern IPV4_ADDRESS_PATTERN = Pattern.compile(\"\\\\d{1,3}(?:\\\\.\\\\d{1,3}){3}\");", "modifier": "private static final", "type": "Pattern", "declarator": "IPV4_ADDRESS_PATTERN = Pattern.compile(\"\\\\d{1,3}(?:\\\\.\\\\d{1,3}){3}\")", "var_name": "IPV4_ADDRESS_PATTERN"}, {"original_string": "private static final Pattern IPV6_ADDRESS_PATTERN =\n            Pattern.compile(\"( [0-9A-Fa-f:.]+ (?: % [0-9A-Za-z][-0-9A-Za-z_\\\\ ]*)? )\", Pattern.COMMENTS);", "modifier": "private static final", "type": "Pattern", "declarator": "IPV6_ADDRESS_PATTERN =\n            Pattern.compile(\"( [0-9A-Fa-f:.]+ (?: % [0-9A-Za-z][-0-9A-Za-z_\\\\ ]*)? )\", Pattern.COMMENTS)", "var_name": "IPV6_ADDRESS_PATTERN"}, {"original_string": "private final HttpClient httpClient;", "modifier": "private final", "type": "HttpClient", "declarator": "httpClient", "var_name": "httpClient"}], "methods": [{"identifier": "HappyEyeballsResolver", "parameters": "(HttpClient httpClient)", "modifiers": "public", "return": "", "signature": " HappyEyeballsResolver(HttpClient httpClient)", "full_signature": "public  HappyEyeballsResolver(HttpClient httpClient)", "class_method_signature": "HappyEyeballsResolver.HappyEyeballsResolver(HttpClient httpClient)", "testcase": false, "constructor": true}, {"identifier": "resolve", "parameters": "(String host, int port, Promise<List<InetSocketAddress>> promise)", "modifiers": "@Override public", "return": "void", "signature": "void resolve(String host, int port, Promise<List<InetSocketAddress>> promise)", "full_signature": "@Override public void resolve(String host, int port, Promise<List<InetSocketAddress>> promise)", "class_method_signature": "HappyEyeballsResolver.resolve(String host, int port, Promise<List<InetSocketAddress>> promise)", "testcase": false, "constructor": false}, {"identifier": "isLiteralIpAddress", "parameters": "(String host)", "modifiers": "", "return": "Optional<String>", "signature": "Optional<String> isLiteralIpAddress(String host)", "full_signature": " Optional<String> isLiteralIpAddress(String host)", "class_method_signature": "HappyEyeballsResolver.isLiteralIpAddress(String host)", "testcase": false, "constructor": false}, {"identifier": "isLiteralV4Address", "parameters": "(String host)", "modifiers": "private", "return": "boolean", "signature": "boolean isLiteralV4Address(String host)", "full_signature": "private boolean isLiteralV4Address(String host)", "class_method_signature": "HappyEyeballsResolver.isLiteralV4Address(String host)", "testcase": false, "constructor": false}, {"identifier": "completePromise", "parameters": "(String ipAddress, int port, Promise<List<InetSocketAddress>> promise)", "modifiers": "private", "return": "void", "signature": "void completePromise(String ipAddress, int port, Promise<List<InetSocketAddress>> promise)", "full_signature": "private void completePromise(String ipAddress, int port, Promise<List<InetSocketAddress>> promise)", "class_method_signature": "HappyEyeballsResolver.completePromise(String ipAddress, int port, Promise<List<InetSocketAddress>> promise)", "testcase": false, "constructor": false}, {"identifier": "resolveAsynchronously", "parameters": "(String host, int port, Promise<List<InetSocketAddress>> promise)", "modifiers": "private", "return": "void", "signature": "void resolveAsynchronously(String host, int port, Promise<List<InetSocketAddress>> promise)", "full_signature": "private void resolveAsynchronously(String host, int port, Promise<List<InetSocketAddress>> promise)", "class_method_signature": "HappyEyeballsResolver.resolveAsynchronously(String host, int port, Promise<List<InetSocketAddress>> promise)", "testcase": false, "constructor": false}, {"identifier": "closeAnyway", "parameters": "(Closeable closeable)", "modifiers": "private static", "return": "void", "signature": "void closeAnyway(Closeable closeable)", "full_signature": "private static void closeAnyway(Closeable closeable)", "class_method_signature": "HappyEyeballsResolver.closeAnyway(Closeable closeable)", "testcase": false, "constructor": false}, {"identifier": "joinAddresses", "parameters": "(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6)", "modifiers": "private", "return": "Object", "signature": "Object joinAddresses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6)", "full_signature": "private Object joinAddresses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6)", "class_method_signature": "HappyEyeballsResolver.joinAddresses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6)", "testcase": false, "constructor": false}, {"identifier": "awaitSuccessfulConnection", "parameters": "(Selector selector, long selectTimeout)", "modifiers": "private static", "return": "Optional<SocketAddress>", "signature": "Optional<SocketAddress> awaitSuccessfulConnection(Selector selector, long selectTimeout)", "full_signature": "private static Optional<SocketAddress> awaitSuccessfulConnection(Selector selector, long selectTimeout)", "class_method_signature": "HappyEyeballsResolver.awaitSuccessfulConnection(Selector selector, long selectTimeout)", "testcase": false, "constructor": false}, {"identifier": "awaitDnsResponses", "parameters": "(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6,\n                                          ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV4)", "modifiers": "private static", "return": "void", "signature": "void awaitDnsResponses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6,\n                                          ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV4)", "full_signature": "private static void awaitDnsResponses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6,\n                                          ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV4)", "class_method_signature": "HappyEyeballsResolver.awaitDnsResponses(ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV6,\n                                          ConcurrentLinkedQueue<Optional<InetAddress>> resolvedAddressesV4)", "testcase": false, "constructor": false}, {"identifier": "haveTime", "parameters": "(long nanoDeadline)", "modifiers": "private static", "return": "boolean", "signature": "boolean haveTime(long nanoDeadline)", "full_signature": "private static boolean haveTime(long nanoDeadline)", "class_method_signature": "HappyEyeballsResolver.haveTime(long nanoDeadline)", "testcase": false, "constructor": false}, {"identifier": "dnsLookupRunnable", "parameters": "(Name hostname, int queryType, Queue<Optional<InetAddress>> resolvedAddresses)", "modifiers": "private static", "return": "Runnable", "signature": "Runnable dnsLookupRunnable(Name hostname, int queryType, Queue<Optional<InetAddress>> resolvedAddresses)", "full_signature": "private static Runnable dnsLookupRunnable(Name hostname, int queryType, Queue<Optional<InetAddress>> resolvedAddresses)", "class_method_signature": "HappyEyeballsResolver.dnsLookupRunnable(Name hostname, int queryType, Queue<Optional<InetAddress>> resolvedAddresses)", "testcase": false, "constructor": false}, {"identifier": "findBestAddress", "parameters": "(final Queue<Optional<InetAddress>> firstAfAddresses,\n                                                           final Queue<Optional<InetAddress>> secondAfAddresses,\n                                                           final int port, final Selector selector)", "modifiers": "private static", "return": "Optional<SocketAddress>", "signature": "Optional<SocketAddress> findBestAddress(final Queue<Optional<InetAddress>> firstAfAddresses,\n                                                           final Queue<Optional<InetAddress>> secondAfAddresses,\n                                                           final int port, final Selector selector)", "full_signature": "private static Optional<SocketAddress> findBestAddress(final Queue<Optional<InetAddress>> firstAfAddresses,\n                                                           final Queue<Optional<InetAddress>> secondAfAddresses,\n                                                           final int port, final Selector selector)", "class_method_signature": "HappyEyeballsResolver.findBestAddress(final Queue<Optional<InetAddress>> firstAfAddresses,\n                                                           final Queue<Optional<InetAddress>> secondAfAddresses,\n                                                           final int port, final Selector selector)", "testcase": false, "constructor": false}, {"identifier": "openConnectionFromQueue", "parameters": "(Queue<Optional<InetAddress>> queue,\n                                                   int port,\n                                                   Selector selector)", "modifiers": "private static", "return": "boolean", "signature": "boolean openConnectionFromQueue(Queue<Optional<InetAddress>> queue,\n                                                   int port,\n                                                   Selector selector)", "full_signature": "private static boolean openConnectionFromQueue(Queue<Optional<InetAddress>> queue,\n                                                   int port,\n                                                   Selector selector)", "class_method_signature": "HappyEyeballsResolver.openConnectionFromQueue(Queue<Optional<InetAddress>> queue,\n                                                   int port,\n                                                   Selector selector)", "testcase": false, "constructor": false}], "file": "rpki-validator/src/main/java/net/ripe/rpki/validator3/util/HappyEyeballsResolver.java"}, "focal_method": {"identifier": "resolve", "parameters": "(String host, int port, Promise<List<InetSocketAddress>> promise)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void resolve(String host, int port, Promise<List<InetSocketAddress>> promise) {\n        final Optional<String> literalIpAddress = isLiteralIpAddress(host);\n        if (literalIpAddress.isPresent()) {\n            completePromise(literalIpAddress.get(), port, promise);\n        } else {\n            resolveAsynchronously(host, port, promise);\n        }\n    }", "signature": "void resolve(String host, int port, Promise<List<InetSocketAddress>> promise)", "full_signature": "@Override public void resolve(String host, int port, Promise<List<InetSocketAddress>> promise)", "class_method_signature": "HappyEyeballsResolver.resolve(String host, int port, Promise<List<InetSocketAddress>> promise)", "testcase": false, "constructor": false, "invocations": ["isLiteralIpAddress", "isPresent", "completePromise", "get", "resolveAsynchronously"]}, "repository": {"repo_id": 104217624, "url": "https://github.com/RIPE-NCC/rpki-validator-3", "stars": 32, "created": "9/20/2017 1:15:05 PM +00:00", "updates": "2020-01-27T10:48:38+00:00", "fork": "False", "license": "licensed"}}