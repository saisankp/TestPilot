{"test_class": {"identifier": "HttpPathValidatorTest", "superclass": "", "interfaces": "", "fields": [], "file": "conjure-core/src/test/java/com/palantir/conjure/defs/validator/HttpPathValidatorTest.java"}, "test_case": {"identifier": "testPathSegmentsMustObeySyntax", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testPathSegmentsMustObeySyntax() {\n        for (PathSegmentTestCase currCase : new PathSegmentTestCase[] {\n            new PathSegmentTestCase(\"/123\", \"123\"),\n            new PathSegmentTestCase(\"/abc/$%^\", \"$%^\"),\n            new PathSegmentTestCase(\"/abc/{123}\", \"{123}\"),\n        }) {\n            assertThatThrownBy(() -> validate(currCase.path))\n                    .isInstanceOf(IllegalArgumentException.class)\n                    .hasMessage(String.format(\n                            \"Segment %s of path %s did not match required segment patterns \"\n                                    + \"^[a-zA-Z][a-zA-Z0-9._-]*$ or parameter name patterns \"\n                                    + \"^\\\\{[a-z][a-z0-9]*([A-Z0-9][a-z0-9]+)*}$ or \"\n                                    + \"^\\\\{[a-z][a-z0-9]*([A-Z0-9][a-z0-9]+)*\"\n                                    + \"(\" + Pattern.quote(\":.+\") + \"|\" + Pattern.quote(\":.*\") + \")\"\n                                    + \"}$\",\n                            currCase.invalidSegment,\n                            currCase.path));\n        }\n    }", "signature": "void testPathSegmentsMustObeySyntax()", "full_signature": "@Test public void testPathSegmentsMustObeySyntax()", "class_method_signature": "HttpPathValidatorTest.testPathSegmentsMustObeySyntax()", "testcase": true, "constructor": false, "invocations": ["hasMessage", "isInstanceOf", "assertThatThrownBy", "validate", "format", "quote", "quote"]}, "focal_class": {"identifier": "HttpPathValidator", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String PATTERN = \"[a-z][a-z0-9]*([A-Z0-9][a-z0-9]+)*\";", "modifier": "public static final", "type": "String", "declarator": "PATTERN = \"[a-z][a-z0-9]*([A-Z0-9][a-z0-9]+)*\"", "var_name": "PATTERN"}, {"original_string": "private static final Pattern SEGMENT_PATTERN = Pattern.compile(\"^[a-zA-Z][a-zA-Z0-9._-]*$\");", "modifier": "private static final", "type": "Pattern", "declarator": "SEGMENT_PATTERN = Pattern.compile(\"^[a-zA-Z][a-zA-Z0-9._-]*$\")", "var_name": "SEGMENT_PATTERN"}, {"original_string": "private static final Pattern PARAM_SEGMENT_PATTERN = Pattern.compile(\"^\\\\{\" + PATTERN + \"}$\");", "modifier": "private static final", "type": "Pattern", "declarator": "PARAM_SEGMENT_PATTERN = Pattern.compile(\"^\\\\{\" + PATTERN + \"}$\")", "var_name": "PARAM_SEGMENT_PATTERN"}, {"original_string": "private static final Pattern PARAM_REGEX_SEGMENT_PATTERN =\n            Pattern.compile(\"^\\\\{\" + PATTERN + \"(\" + Pattern.quote(\":.+\") + \"|\" + Pattern.quote(\":.*\") + \")\" + \"}$\");", "modifier": "private static final", "type": "Pattern", "declarator": "PARAM_REGEX_SEGMENT_PATTERN =\n            Pattern.compile(\"^\\\\{\" + PATTERN + \"(\" + Pattern.quote(\":.+\") + \"|\" + Pattern.quote(\":.*\") + \")\" + \"}$\")", "var_name": "PARAM_REGEX_SEGMENT_PATTERN"}], "methods": [{"identifier": "HttpPathValidator", "parameters": "()", "modifiers": "private", "return": "", "signature": " HttpPathValidator()", "full_signature": "private  HttpPathValidator()", "class_method_signature": "HttpPathValidator.HttpPathValidator()", "testcase": false, "constructor": true}, {"identifier": "pathArgs", "parameters": "(String httpPath)", "modifiers": "public static", "return": "Set<ArgumentName>", "signature": "Set<ArgumentName> pathArgs(String httpPath)", "full_signature": "public static Set<ArgumentName> pathArgs(String httpPath)", "class_method_signature": "HttpPathValidator.pathArgs(String httpPath)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(HttpPath httpPath)", "modifiers": "public static", "return": "void", "signature": "void validate(HttpPath httpPath)", "full_signature": "public static void validate(HttpPath httpPath)", "class_method_signature": "HttpPathValidator.validate(HttpPath httpPath)", "testcase": false, "constructor": false}, {"identifier": "withoutLeadingSlash", "parameters": "(String httpPath)", "modifiers": "public static", "return": "String", "signature": "String withoutLeadingSlash(String httpPath)", "full_signature": "public static String withoutLeadingSlash(String httpPath)", "class_method_signature": "HttpPathValidator.withoutLeadingSlash(String httpPath)", "testcase": false, "constructor": false}], "file": "conjure-core/src/main/java/com/palantir/conjure/defs/validator/HttpPathValidator.java"}, "focal_method": {"identifier": "validate", "parameters": "(HttpPath httpPath)", "modifiers": "public static", "return": "void", "body": "public static void validate(HttpPath httpPath) {\n        Path path = Paths.get(httpPath.get());\n        Preconditions.checkArgument(\n                path.isAbsolute(), \"Conjure paths must be absolute, i.e., start with '/': %s\", path);\n        Preconditions.checkArgument(\n                path.getSegments().isEmpty() || !path.isFolder(), \"Conjure paths must not end with a '/': %s\", path);\n\n        for (String segment : path.getSegments()) {\n            Preconditions.checkArgument(\n                    SEGMENT_PATTERN.matcher(segment).matches()\n                            || PARAM_SEGMENT_PATTERN.matcher(segment).matches()\n                            || PARAM_REGEX_SEGMENT_PATTERN.matcher(segment).matches(),\n                    \"Segment %s of path %s did not match required segment patterns %s or parameter name \"\n                            + \"patterns %s or %s\",\n                    segment,\n                    path,\n                    SEGMENT_PATTERN,\n                    PARAM_SEGMENT_PATTERN,\n                    PARAM_REGEX_SEGMENT_PATTERN);\n        }\n\n        // verify that path template variables are unique\n        Set<String> templateVars = new HashSet<>();\n        new UriTemplate(path.toString()).getTemplateVariables().forEach(var -> {\n            Preconditions.checkState(\n                    !templateVars.contains(var), \"Path parameter %s appears more than once in path %s\", var, path);\n            templateVars.add(var);\n        });\n\n        UriTemplateParser uriTemplateParser = new UriTemplateParser(path.toString());\n        Map<String, Pattern> nameToPattern = uriTemplateParser.getNameToPattern();\n        List<String> segments = Splitter.on('/').splitToList(uriTemplateParser.getNormalizedTemplate());\n        for (int i = 0; i < segments.size(); i++) {\n            String segment = segments.get(i);\n            if (!(segment.startsWith(\"{\") && segment.endsWith(\"}\"))) {\n                // path literal\n                continue;\n            }\n\n            // variable\n            Pattern varPattern = nameToPattern.get(segment.substring(1, segment.length() - 1));\n            if (varPattern.equals(UriTemplateParser.TEMPLATE_VALUE_PATTERN)) {\n                // no regular expression specified -- OK\n                continue;\n            }\n\n            // if regular expression was specified, it must be \".+\" or \".*\" based on invariant previously enforced\n            Preconditions.checkState(\n                    i == segments.size() - 1 || !varPattern.pattern().equals(\".*\"),\n                    \"Path parameter %s in path %s specifies regular expression %s, but this regular \"\n                            + \"expression is only permitted if the path parameter is the last segment\",\n                    segment,\n                    path,\n                    varPattern);\n        }\n    }", "signature": "void validate(HttpPath httpPath)", "full_signature": "public static void validate(HttpPath httpPath)", "class_method_signature": "HttpPathValidator.validate(HttpPath httpPath)", "testcase": false, "constructor": false, "invocations": ["get", "get", "checkArgument", "isAbsolute", "checkArgument", "isEmpty", "getSegments", "isFolder", "getSegments", "checkArgument", "matches", "matcher", "matches", "matcher", "matches", "matcher", "forEach", "getTemplateVariables", "toString", "checkState", "contains", "add", "toString", "getNameToPattern", "splitToList", "on", "getNormalizedTemplate", "size", "get", "startsWith", "endsWith", "get", "substring", "length", "equals", "checkState", "size", "equals", "pattern"]}, "repository": {"repo_id": 134616422, "url": "https://github.com/palantir/conjure", "stars": 211, "created": "5/23/2018 7:28:43 PM +00:00", "updates": "2020-01-24T17:51:52+00:00", "fork": "False", "license": "licensed"}}