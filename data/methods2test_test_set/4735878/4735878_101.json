{"test_class": {"identifier": "SQLCompletionProviderTest", "superclass": "", "interfaces": "", "fields": [], "file": "bundles/sqlconsole-parser/src/test/java/org/orbisgis/scp/SQLCompletionProviderTest.java"}, "test_case": {"identifier": "testBounds", "parameters": "()", "modifiers": "@Test //(timeout = 500) public", "return": "void", "body": "@Test //(timeout = 500)\n    public void testBounds() throws Exception {\n        assumeTrue(!GraphicsEnvironment.isHeadless());\n        // Create H2 DataSource\n        org.h2.Driver driver = org.h2.Driver.load();\n        OsgiDataSourceFactory dataSourceFactory = new OsgiDataSourceFactory(driver);\n        Properties properties = new Properties();\n        properties.setProperty(OsgiDataSourceFactory.JDBC_URL, RSyntaxSQLParserTest.DATABASE_PATH);\n\n        // Create document\n        RSyntaxDocument document = new RSyntaxDocument(\"sql\");\n        RSyntaxTextArea rSyntaxTextArea = new RSyntaxTextArea(document);\n        rSyntaxTextArea.setText(\"alte\");\n        rSyntaxTextArea.setSize(new Dimension(420, 240));\n        rSyntaxTextArea.setCaretPosition(4);\n        SQLCompletionProvider autoComplete = new SQLCompletionProvider(dataSourceFactory.createDataSource(properties), true);\n\n        List completions = autoComplete.getCompletionsAtIndex(rSyntaxTextArea, 4);\n        assertEquals(1, completions.size());\n        assertEquals(\"ALTER\", ((Completion)completions.get(0)).getReplacementText());\n    }", "signature": "void testBounds()", "full_signature": "@Test //(timeout = 500) public void testBounds()", "class_method_signature": "SQLCompletionProviderTest.testBounds()", "testcase": true, "constructor": false, "invocations": ["assumeTrue", "isHeadless", "load", "setProperty", "setText", "setSize", "setCaretPosition", "createDataSource", "getCompletionsAtIndex", "assertEquals", "size", "assertEquals", "getReplacementText", "get"]}, "focal_class": {"identifier": "SQLCompletionProvider", "superclass": "extends CompletionProviderBase", "interfaces": "", "fields": [{"original_string": "private DataSource dataSource;", "modifier": "private", "type": "DataSource", "declarator": "dataSource", "var_name": "dataSource"}, {"original_string": "private Bnf parser;", "modifier": "private", "type": "Bnf", "declarator": "parser", "var_name": "parser"}, {"original_string": "private Logger log = LoggerFactory.getLogger(SQLCompletionProvider.class);", "modifier": "private", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(SQLCompletionProvider.class)", "var_name": "log"}, {"original_string": "private static final int UPDATE_INTERVAL = 30000;", "modifier": "private static final", "type": "int", "declarator": "UPDATE_INTERVAL = 30000", "var_name": "UPDATE_INTERVAL"}, {"original_string": "private static final int UPDATE_TIMEOUT = 1000;", "modifier": "private static final", "type": "int", "declarator": "UPDATE_TIMEOUT = 1000", "var_name": "UPDATE_TIMEOUT"}, {"original_string": "private long lastUpdate = 0;", "modifier": "private", "type": "long", "declarator": "lastUpdate = 0", "var_name": "lastUpdate"}, {"original_string": "private UpdateParserThread fetchingParser = null;", "modifier": "private", "type": "UpdateParserThread", "declarator": "fetchingParser = null", "var_name": "fetchingParser"}, {"original_string": "private final static Pattern LTRIM = Pattern.compile(\"^\\\\s+\");", "modifier": "private final static", "type": "Pattern", "declarator": "LTRIM = Pattern.compile(\"^\\\\s+\")", "var_name": "LTRIM"}], "methods": [{"identifier": "SQLCompletionProvider", "parameters": "(DataSource dataSource, boolean immediateInit)", "modifiers": "public", "return": "", "signature": " SQLCompletionProvider(DataSource dataSource, boolean immediateInit)", "full_signature": "public  SQLCompletionProvider(DataSource dataSource, boolean immediateInit)", "class_method_signature": "SQLCompletionProvider.SQLCompletionProvider(DataSource dataSource, boolean immediateInit)", "testcase": false, "constructor": true}, {"identifier": "setDataSource", "parameters": "(DataSource ds)", "modifiers": "public", "return": "void", "signature": "void setDataSource(DataSource ds)", "full_signature": "public void setDataSource(DataSource ds)", "class_method_signature": "SQLCompletionProvider.setDataSource(DataSource ds)", "testcase": false, "constructor": false}, {"identifier": "updateParser", "parameters": "(DataSource dataSource, boolean immediateInit)", "modifiers": "public", "return": "void", "signature": "void updateParser(DataSource dataSource, boolean immediateInit)", "full_signature": "public void updateParser(DataSource dataSource, boolean immediateInit)", "class_method_signature": "SQLCompletionProvider.updateParser(DataSource dataSource, boolean immediateInit)", "testcase": false, "constructor": false}, {"identifier": "getCompletionsImpl", "parameters": "(JTextComponent comp)", "modifiers": "@Override protected", "return": "List", "signature": "List getCompletionsImpl(JTextComponent comp)", "full_signature": "@Override protected List getCompletionsImpl(JTextComponent comp)", "class_method_signature": "SQLCompletionProvider.getCompletionsImpl(JTextComponent comp)", "testcase": false, "constructor": false}, {"identifier": "getAlreadyEnteredText", "parameters": "(JTextComponent jTextComponent)", "modifiers": "@Override public", "return": "String", "signature": "String getAlreadyEnteredText(JTextComponent jTextComponent)", "full_signature": "@Override public String getAlreadyEnteredText(JTextComponent jTextComponent)", "class_method_signature": "SQLCompletionProvider.getAlreadyEnteredText(JTextComponent jTextComponent)", "testcase": false, "constructor": false}, {"identifier": "getCompletionsAtIndex", "parameters": "(JTextComponent jTextComponent, int charIndex)", "modifiers": "public", "return": "List<Completion>", "signature": "List<Completion> getCompletionsAtIndex(JTextComponent jTextComponent, int charIndex)", "full_signature": "public List<Completion> getCompletionsAtIndex(JTextComponent jTextComponent, int charIndex)", "class_method_signature": "SQLCompletionProvider.getCompletionsAtIndex(JTextComponent jTextComponent, int charIndex)", "testcase": false, "constructor": false}, {"identifier": "getCompletionsAt", "parameters": "(JTextComponent jTextComponent, Point point)", "modifiers": "@Override public", "return": "List", "signature": "List getCompletionsAt(JTextComponent jTextComponent, Point point)", "full_signature": "@Override public List getCompletionsAt(JTextComponent jTextComponent, Point point)", "class_method_signature": "SQLCompletionProvider.getCompletionsAt(JTextComponent jTextComponent, Point point)", "testcase": false, "constructor": false}, {"identifier": "getParameterizedCompletions", "parameters": "(JTextComponent jTextComponent)", "modifiers": "@Override public", "return": "List", "signature": "List getParameterizedCompletions(JTextComponent jTextComponent)", "full_signature": "@Override public List getParameterizedCompletions(JTextComponent jTextComponent)", "class_method_signature": "SQLCompletionProvider.getParameterizedCompletions(JTextComponent jTextComponent)", "testcase": false, "constructor": false}], "file": "bundles/sqlconsole-parser/src/main/java/org/orbisgis/scp/SQLCompletionProvider.java"}, "focal_method": {"identifier": "getCompletionsAtIndex", "parameters": "(JTextComponent jTextComponent, int charIndex)", "modifiers": "public", "return": "List<Completion>", "body": "public List<Completion> getCompletionsAtIndex(JTextComponent jTextComponent, int charIndex) {\n        UpdateParserThread fetchingParserTmp = fetchingParser;\n        if(fetchingParserTmp != null) {\n            if(!fetchingParserTmp.isDone()) {\n                try {\n                    // Wait until update is done\n                    fetchingParserTmp.get(UPDATE_TIMEOUT, TimeUnit.MILLISECONDS);\n                } catch (Exception ex) {\n                    return new ArrayList<>();\n                }\n            } else {\n                parser = fetchingParserTmp.getParser();\n            }\n        } if(parser == null) {\n            return new ArrayList<>();\n        }\n        //Completion completion = new BasicCompletion(this, token);\n        List<Completion> completionList = new LinkedList<Completion>();\n\n        // Extract the statement at this position\n        DocumentSQLReader documentReader = new DocumentSQLReader(jTextComponent.getDocument(), true);\n        String statement = \"\";\n        while(documentReader.hasNext() && documentReader.getPosition() + statement.length() < charIndex) {\n            statement = documentReader.next();\n        }\n        // Last word for filtering results\n        int completionPosition = charIndex - documentReader.getPosition();\n        String partialStatement = LTRIM.matcher(statement.substring(0, completionPosition)).replaceAll(\"\");\n        // Ask parser for completion list\n        // Left trim the string\n        Map<String,String> autoComplete = parser.getNextTokenList(partialStatement);\n        for(Map.Entry<String, String> entry : autoComplete.entrySet()) {\n            String token =  entry.getKey().substring(entry.getKey().indexOf(\"#\") + 1);\n            Completion completion = new BnfAutoCompletion(this, token, entry.getValue());\n            completionList.add(completion);\n        }\n\n        // Update table list if it has not be done more than UPDATE_INTERVAL ms ago\n        long now = System.currentTimeMillis();\n        if(lastUpdate + UPDATE_INTERVAL < now) {\n            try {\n                updateParser(dataSource, false);\n            } catch (Exception ex) {\n                log.warn(\"Could not update auto-completion engine\", ex);\n            }\n        }\n        return completionList;\n    }", "signature": "List<Completion> getCompletionsAtIndex(JTextComponent jTextComponent, int charIndex)", "full_signature": "public List<Completion> getCompletionsAtIndex(JTextComponent jTextComponent, int charIndex)", "class_method_signature": "SQLCompletionProvider.getCompletionsAtIndex(JTextComponent jTextComponent, int charIndex)", "testcase": false, "constructor": false, "invocations": ["isDone", "get", "getParser", "getDocument", "hasNext", "getPosition", "length", "next", "getPosition", "replaceAll", "matcher", "substring", "getNextTokenList", "entrySet", "substring", "getKey", "indexOf", "getKey", "getValue", "add", "currentTimeMillis", "updateParser", "warn"]}, "repository": {"repo_id": 4735878, "url": "https://github.com/orbisgis/orbisgis", "language": "Java", "is_fork": false, "fork_count": 37, "stargazer_count": 63, "size": 76463, "license": "licensed"}}