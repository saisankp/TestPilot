{"test_class": {"identifier": "OsmNogoPolygonTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final int OFFSET_X = 11000000;", "modifier": "static final", "type": "int", "declarator": "OFFSET_X = 11000000", "var_name": "OFFSET_X"}, {"original_string": "static final int OFFSET_Y = 50000000;", "modifier": "static final", "type": "int", "declarator": "OFFSET_Y = 50000000", "var_name": "OFFSET_Y"}, {"original_string": "static OsmNogoPolygon polygon;", "modifier": "static", "type": "OsmNogoPolygon", "declarator": "polygon", "var_name": "polygon"}, {"original_string": "static OsmNogoPolygon polyline;", "modifier": "static", "type": "OsmNogoPolygon", "declarator": "polyline", "var_name": "polyline"}, {"original_string": "static final double[] lons = {  1.0,  1.0,  0.5, 0.5, 1.0, 1.0, -1.1, -1.0 };", "modifier": "static final", "type": "double[]", "declarator": "lons = {  1.0,  1.0,  0.5, 0.5, 1.0, 1.0, -1.1, -1.0 }", "var_name": "lons"}, {"original_string": "static final double[] lats = { -1.0, -0.1, -0.1, 0.1, 0.1, 1.0,  1.1, -1.0 };", "modifier": "static final", "type": "double[]", "declarator": "lats = { -1.0, -0.1, -0.1, 0.1, 0.1, 1.0,  1.1, -1.0 }", "var_name": "lats"}], "file": "brouter-core/src/test/java/btools/router/OsmNogoPolygonTest.java"}, "test_case": {"identifier": "testIsWithin", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testIsWithin() {\n    double[] plons   = {  0.0,   0.5,   1.0,  -1.5,  -0.5,  1.0,  1.0,  0.5,  0.5,  0.5, };\n    double[] plats   = {  0.0,   1.5,   0.0,   0.5,  -1.5, -1.0, -0.1, -0.1,  0.0,  0.1, };\n    boolean[] within = { true, false, false, false, false, true, true, true, true, true, };\n\n    for (int i=0; i<plons.length; i++) {\n      assertEquals(\"(\"+plons[i]+\",\"+plats[i]+\")\",within[i],polygon.isWithin(toOsmLon(plons[i], OFFSET_X), toOsmLat(plats[i], OFFSET_Y)));\n    }\n  }", "signature": "void testIsWithin()", "full_signature": "@Test public void testIsWithin()", "class_method_signature": "OsmNogoPolygonTest.testIsWithin()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "isWithin", "toOsmLon", "toOsmLat"]}, "focal_class": {"identifier": "OsmNogoPolygon", "superclass": "extends OsmNodeNamed", "interfaces": "", "fields": [{"original_string": "public final List<Point> points = new ArrayList<Point>();", "modifier": "public final", "type": "List<Point>", "declarator": "points = new ArrayList<Point>()", "var_name": "points"}, {"original_string": "public final boolean isClosed;", "modifier": "public final", "type": "boolean", "declarator": "isClosed", "var_name": "isClosed"}], "methods": [{"identifier": "OsmNogoPolygon", "parameters": "(boolean closed)", "modifiers": "public", "return": "", "signature": " OsmNogoPolygon(boolean closed)", "full_signature": "public  OsmNogoPolygon(boolean closed)", "class_method_signature": "OsmNogoPolygon.OsmNogoPolygon(boolean closed)", "testcase": false, "constructor": true}, {"identifier": "addVertex", "parameters": "(int lon, int lat)", "modifiers": "public final", "return": "void", "signature": "void addVertex(int lon, int lat)", "full_signature": "public final void addVertex(int lon, int lat)", "class_method_signature": "OsmNogoPolygon.addVertex(int lon, int lat)", "testcase": false, "constructor": false}, {"identifier": "calcBoundingCircle", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void calcBoundingCircle()", "full_signature": "public void calcBoundingCircle()", "class_method_signature": "OsmNogoPolygon.calcBoundingCircle()", "testcase": false, "constructor": false}, {"identifier": "intersects", "parameters": "(int lon0, int lat0, int lon1, int lat1)", "modifiers": "public", "return": "boolean", "signature": "boolean intersects(int lon0, int lat0, int lon1, int lat1)", "full_signature": "public boolean intersects(int lon0, int lat0, int lon1, int lat1)", "class_method_signature": "OsmNogoPolygon.intersects(int lon0, int lat0, int lon1, int lat1)", "testcase": false, "constructor": false}, {"identifier": "isOnPolyline", "parameters": "( long px, long py )", "modifiers": "public", "return": "boolean", "signature": "boolean isOnPolyline( long px, long py )", "full_signature": "public boolean isOnPolyline( long px, long py )", "class_method_signature": "OsmNogoPolygon.isOnPolyline( long px, long py )", "testcase": false, "constructor": false}, {"identifier": "isOnLine", "parameters": "( long px, long py, long p0x, long p0y, long p1x, long p1y )", "modifiers": "public static", "return": "boolean", "signature": "boolean isOnLine( long px, long py, long p0x, long p0y, long p1x, long p1y )", "full_signature": "public static boolean isOnLine( long px, long py, long p0x, long p0y, long p1x, long p1y )", "class_method_signature": "OsmNogoPolygon.isOnLine( long px, long py, long p0x, long p0y, long p1x, long p1y )", "testcase": false, "constructor": false}, {"identifier": "isWithin", "parameters": "(final long px, final long py)", "modifiers": "public", "return": "boolean", "signature": "boolean isWithin(final long px, final long py)", "full_signature": "public boolean isWithin(final long px, final long py)", "class_method_signature": "OsmNogoPolygon.isWithin(final long px, final long py)", "testcase": false, "constructor": false}, {"identifier": "distanceWithinPolygon", "parameters": "(int lon1, int lat1, int lon2, int lat2)", "modifiers": "public", "return": "double", "signature": "double distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "full_signature": "public double distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "class_method_signature": "OsmNogoPolygon.distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2)", "testcase": false, "constructor": false}, {"identifier": "inSegment", "parameters": "( final Point p, final Point seg_p0, final Point seg_p1)", "modifiers": "private static", "return": "boolean", "signature": "boolean inSegment( final Point p, final Point seg_p0, final Point seg_p1)", "full_signature": "private static boolean inSegment( final Point p, final Point seg_p0, final Point seg_p1)", "class_method_signature": "OsmNogoPolygon.inSegment( final Point p, final Point seg_p0, final Point seg_p1)", "testcase": false, "constructor": false}, {"identifier": "intersect2D_2Segments", "parameters": "( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "modifiers": "private static", "return": "int", "signature": "int intersect2D_2Segments( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "full_signature": "private static int intersect2D_2Segments( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "class_method_signature": "OsmNogoPolygon.intersect2D_2Segments( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 )", "testcase": false, "constructor": false}], "file": "brouter-core/src/main/java/btools/router/OsmNogoPolygon.java"}, "focal_method": {"identifier": "isWithin", "parameters": "(final long px, final long py)", "modifiers": "public", "return": "boolean", "body": "public boolean isWithin(final long px, final long py)\n  {\n    int wn = 0; // the winding number counter\n\n    // loop through all edges of the polygon\n    final int i_last = points.size()-1;\n    final Point p0 = points.get(isClosed ? i_last : 0);\n    long p0x = p0.x; // need to use long to avoid overflow in products\n    long p0y = p0.y;\n\n    for (int i = isClosed ? 0 : 1; i <= i_last; i++) // edge from v[i] to v[i+1]\n    {\n      final Point p1 = points.get(i);\n\n      final long p1x = p1.x;\n      final long p1y = p1.y;\n\n      if (OsmNogoPolygon.isOnLine(px, py, p0x, p0y, p1x, p1y))\n      {\n        return true;\n      }\n\n      if (p0y <= py)  // start y <= p.y\n      {\n        if (p1y > py) // an upward crossing\n        {             // p left of edge\n          if (((p1x - p0x) * (py - p0y) - (px - p0x) * (p1y - p0y)) > 0)\n          {\n            ++wn;     // have a valid up intersect\n          }\n        }\n      }\n      else // start y > p.y (no test needed)\n      {\n        if (p1y <= py) // a downward crossing\n        {              // p right of edge\n          if (((p1x - p0x) * (py - p0y) - (px - p0x) * (p1y - p0y)) < 0)\n          {\n            --wn;      // have a valid down intersect\n          }\n        }\n      }\n      p0x = p1x;\n      p0y = p1y;\n    }\n    return wn != 0;\n  }", "signature": "boolean isWithin(final long px, final long py)", "full_signature": "public boolean isWithin(final long px, final long py)", "class_method_signature": "OsmNogoPolygon.isWithin(final long px, final long py)", "testcase": false, "constructor": false, "invocations": ["size", "get", "get", "isOnLine"]}, "repository": {"repo_id": 15870646, "url": "https://github.com/abrensch/brouter", "language": "Java", "is_fork": false, "fork_count": 65, "stargazer_count": 172, "size": 3569, "license": "licensed"}}