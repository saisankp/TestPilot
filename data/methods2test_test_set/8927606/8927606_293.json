{"test_class": {"identifier": "CleanupOldFilesPipeTest", "superclass": "extends PipeTestBase<CleanupOldFilesPipe>", "interfaces": "", "fields": [{"original_string": "private IPipeLineSession session = new PipeLineSessionBase();", "modifier": "private", "type": "IPipeLineSession", "declarator": "session = new PipeLineSessionBase()", "var_name": "session"}], "file": "core/src/test/java/nl/nn/adapterframework/pipes/CleanupOldFilesPipeTest.java"}, "test_case": {"identifier": "emptyInput", "parameters": "()", "modifiers": "@Test(expected = PipeRunException.class) public", "return": "void", "body": "@Test(expected = PipeRunException.class)\n\tpublic void emptyInput() throws PipeRunException {\n\t\tdoPipe(pipe, \"\", session);\n\t}", "signature": "void emptyInput()", "full_signature": "@Test(expected = PipeRunException.class) public void emptyInput()", "class_method_signature": "CleanupOldFilesPipeTest.emptyInput()", "testcase": true, "constructor": false, "invocations": ["doPipe"]}, "focal_class": {"identifier": "CleanupOldFilesPipe", "superclass": "extends FixedForwardPipe", "interfaces": "", "fields": [{"original_string": "private String filePattern;", "modifier": "private", "type": "String", "declarator": "filePattern", "var_name": "filePattern"}, {"original_string": "private String filePatternSessionKey;", "modifier": "private", "type": "String", "declarator": "filePatternSessionKey", "var_name": "filePatternSessionKey"}, {"original_string": "private boolean subdirectories=false;", "modifier": "private", "type": "boolean", "declarator": "subdirectories=false", "var_name": "subdirectories"}, {"original_string": "private long lastModifiedDelta=0;", "modifier": "private", "type": "long", "declarator": "lastModifiedDelta=0", "var_name": "lastModifiedDelta"}, {"original_string": "private boolean deleteEmptySubdirectories=false;", "modifier": "private", "type": "boolean", "declarator": "deleteEmptySubdirectories=false", "var_name": "deleteEmptySubdirectories"}, {"original_string": "private String wildcard;", "modifier": "private", "type": "String", "declarator": "wildcard", "var_name": "wildcard"}, {"original_string": "private String excludeWildcard;", "modifier": "private", "type": "String", "declarator": "excludeWildcard", "var_name": "excludeWildcard"}, {"original_string": "private long minStableTime = 1000;", "modifier": "private", "type": "long", "declarator": "minStableTime = 1000", "var_name": "minStableTime"}, {"original_string": "private _FileFilter fileFilter = new _FileFilter();", "modifier": "private", "type": "_FileFilter", "declarator": "fileFilter = new _FileFilter()", "var_name": "fileFilter"}, {"original_string": "private _DirFilter dirFilter = new _DirFilter();", "modifier": "private", "type": "_DirFilter", "declarator": "dirFilter = new _DirFilter()", "var_name": "dirFilter"}], "methods": [{"identifier": "doPipe", "parameters": "(Message message, IPipeLineSession session)", "modifiers": "@Override public", "return": "PipeRunResult", "signature": "PipeRunResult doPipe(Message message, IPipeLineSession session)", "full_signature": "@Override public PipeRunResult doPipe(Message message, IPipeLineSession session)", "class_method_signature": "CleanupOldFilesPipe.doPipe(Message message, IPipeLineSession session)", "testcase": false, "constructor": false}, {"identifier": "getFilesForDeletion", "parameters": "(String filename)", "modifiers": "private", "return": "List", "signature": "List getFilesForDeletion(String filename)", "full_signature": "private List getFilesForDeletion(String filename)", "class_method_signature": "CleanupOldFilesPipe.getFilesForDeletion(String filename)", "testcase": false, "constructor": false}, {"identifier": "getFilesForDeletion", "parameters": "(List result, File directory)", "modifiers": "private", "return": "void", "signature": "void getFilesForDeletion(List result, File directory)", "full_signature": "private void getFilesForDeletion(List result, File directory)", "class_method_signature": "CleanupOldFilesPipe.getFilesForDeletion(List result, File directory)", "testcase": false, "constructor": false}, {"identifier": "deleteEmptySubdirectories", "parameters": "(String logPrefix, File directory, int level)", "modifiers": "private", "return": "void", "signature": "void deleteEmptySubdirectories(String logPrefix, File directory, int level)", "full_signature": "private void deleteEmptySubdirectories(String logPrefix, File directory, int level)", "class_method_signature": "CleanupOldFilesPipe.deleteEmptySubdirectories(String logPrefix, File directory, int level)", "testcase": false, "constructor": false}, {"identifier": "setFilePattern", "parameters": "(String string)", "modifiers": "@IbisDoc({\"files that match this pattern will be deleted. parameters of the pipe are applied to this pattern. if this attribute is not set, the input of the pipe is interpreted as the file to be removed\", \"\"}) public", "return": "void", "signature": "void setFilePattern(String string)", "full_signature": "@IbisDoc({\"files that match this pattern will be deleted. parameters of the pipe are applied to this pattern. if this attribute is not set, the input of the pipe is interpreted as the file to be removed\", \"\"}) public void setFilePattern(String string)", "class_method_signature": "CleanupOldFilesPipe.setFilePattern(String string)", "testcase": false, "constructor": false}, {"identifier": "getFilePattern", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getFilePattern()", "full_signature": "public String getFilePattern()", "class_method_signature": "CleanupOldFilesPipe.getFilePattern()", "testcase": false, "constructor": false}, {"identifier": "setFilePatternSessionKey", "parameters": "(String string)", "modifiers": "@IbisDoc({\"\", \" \"}) public", "return": "void", "signature": "void setFilePatternSessionKey(String string)", "full_signature": "@IbisDoc({\"\", \" \"}) public void setFilePatternSessionKey(String string)", "class_method_signature": "CleanupOldFilesPipe.setFilePatternSessionKey(String string)", "testcase": false, "constructor": false}, {"identifier": "getFilePatternSessionKey", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getFilePatternSessionKey()", "full_signature": "public String getFilePatternSessionKey()", "class_method_signature": "CleanupOldFilesPipe.getFilePatternSessionKey()", "testcase": false, "constructor": false}, {"identifier": "setLastModifiedDelta", "parameters": "(long l)", "modifiers": "@IbisDoc({\"time in milliseconds after last modification that must have passed at least before a file will be deleted (set to negative value to disable)\", \"0\"}) public", "return": "void", "signature": "void setLastModifiedDelta(long l)", "full_signature": "@IbisDoc({\"time in milliseconds after last modification that must have passed at least before a file will be deleted (set to negative value to disable)\", \"0\"}) public void setLastModifiedDelta(long l)", "class_method_signature": "CleanupOldFilesPipe.setLastModifiedDelta(long l)", "testcase": false, "constructor": false}, {"identifier": "getLastModifiedDelta", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getLastModifiedDelta()", "full_signature": "public long getLastModifiedDelta()", "class_method_signature": "CleanupOldFilesPipe.getLastModifiedDelta()", "testcase": false, "constructor": false}, {"identifier": "setSubdirectories", "parameters": "(boolean b)", "modifiers": "@IbisDoc({\"when <code>true</code>, files in subdirectories will be deleted, too\", \"false\"}) public", "return": "void", "signature": "void setSubdirectories(boolean b)", "full_signature": "@IbisDoc({\"when <code>true</code>, files in subdirectories will be deleted, too\", \"false\"}) public void setSubdirectories(boolean b)", "class_method_signature": "CleanupOldFilesPipe.setSubdirectories(boolean b)", "testcase": false, "constructor": false}, {"identifier": "isSubdirectories", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isSubdirectories()", "full_signature": "public boolean isSubdirectories()", "class_method_signature": "CleanupOldFilesPipe.isSubdirectories()", "testcase": false, "constructor": false}, {"identifier": "setDeleteEmptySubdirectories", "parameters": "(boolean b)", "modifiers": "@IbisDoc({\"when <code>true</code>, empty subdirectories will be deleted, too\", \"false\"}) public", "return": "void", "signature": "void setDeleteEmptySubdirectories(boolean b)", "full_signature": "@IbisDoc({\"when <code>true</code>, empty subdirectories will be deleted, too\", \"false\"}) public void setDeleteEmptySubdirectories(boolean b)", "class_method_signature": "CleanupOldFilesPipe.setDeleteEmptySubdirectories(boolean b)", "testcase": false, "constructor": false}, {"identifier": "isDeleteEmptySubdirectories", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isDeleteEmptySubdirectories()", "full_signature": "public boolean isDeleteEmptySubdirectories()", "class_method_signature": "CleanupOldFilesPipe.isDeleteEmptySubdirectories()", "testcase": false, "constructor": false}, {"identifier": "setWildcard", "parameters": "(String string)", "modifiers": "@IbisDoc({\"filter of files to delete. if not set and a directory is specified, all files in the directory are interpreted to be deleted\", \"\"}) public", "return": "void", "signature": "void setWildcard(String string)", "full_signature": "@IbisDoc({\"filter of files to delete. if not set and a directory is specified, all files in the directory are interpreted to be deleted\", \"\"}) public void setWildcard(String string)", "class_method_signature": "CleanupOldFilesPipe.setWildcard(String string)", "testcase": false, "constructor": false}, {"identifier": "getWildcard", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getWildcard()", "full_signature": "public String getWildcard()", "class_method_signature": "CleanupOldFilesPipe.getWildcard()", "testcase": false, "constructor": false}, {"identifier": "setExcludeWildcard", "parameters": "(String excludeWildcard)", "modifiers": "@IbisDoc({\"filter of files to be excluded for deletion\", \"\"}) public", "return": "void", "signature": "void setExcludeWildcard(String excludeWildcard)", "full_signature": "@IbisDoc({\"filter of files to be excluded for deletion\", \"\"}) public void setExcludeWildcard(String excludeWildcard)", "class_method_signature": "CleanupOldFilesPipe.setExcludeWildcard(String excludeWildcard)", "testcase": false, "constructor": false}, {"identifier": "getExcludeWildcard", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getExcludeWildcard()", "full_signature": "public String getExcludeWildcard()", "class_method_signature": "CleanupOldFilesPipe.getExcludeWildcard()", "testcase": false, "constructor": false}, {"identifier": "setMinStableTime", "parameters": "(long minStableTime)", "modifiers": "@IbisDoc({\"minimal age of file in milliseconds, to avoid deleting a file while it is still being written (only used when wildcard is set) (set to 0 or negative value to disable)\", \"1000 [ms]\"}) public", "return": "void", "signature": "void setMinStableTime(long minStableTime)", "full_signature": "@IbisDoc({\"minimal age of file in milliseconds, to avoid deleting a file while it is still being written (only used when wildcard is set) (set to 0 or negative value to disable)\", \"1000 [ms]\"}) public void setMinStableTime(long minStableTime)", "class_method_signature": "CleanupOldFilesPipe.setMinStableTime(long minStableTime)", "testcase": false, "constructor": false}, {"identifier": "getMinStableTime", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getMinStableTime()", "full_signature": "public long getMinStableTime()", "class_method_signature": "CleanupOldFilesPipe.getMinStableTime()", "testcase": false, "constructor": false}], "file": "core/src/main/java/nl/nn/adapterframework/pipes/CleanupOldFilesPipe.java"}, "focal_method": {"identifier": "doPipe", "parameters": "(Message message, IPipeLineSession session)", "modifiers": "@Override public", "return": "PipeRunResult", "body": "@Override\n\tpublic PipeRunResult doPipe(Message message, IPipeLineSession session) throws PipeRunException {\n\t\ttry {\n\t\t\tString filename;\n\t\t\tif (StringUtils.isNotEmpty(getFilePattern())) {\n\t\t\t\tfilename = FileUtils.getFilename(getParameterList(), session, \"\", getFilePattern());\n\t\t\t} else {\n\t\t\t\tif (StringUtils.isNotEmpty(getFilePatternSessionKey())) {\n\t\t\t\t\tfilename = FileUtils.getFilename(getParameterList(), session, \"\", (String)session.get(getFilePatternSessionKey()));\n\t\t\t\t} else {\n\t\t\t\t\tif (StringUtils.isEmpty(message.asString())) {\n\t\t\t\t\t\tthrow new PipeRunException(this, \"input empty, but should contain filename to delete\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFile in = new File(message.asString());\n\t\t\t\t\t\tfilename = in.getName();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tList delFiles = getFilesForDeletion(filename);\n\t\t\tif (delFiles != null && delFiles.size() > 0) {\n\t\t\t\tfor (Iterator fileIt = delFiles.iterator(); fileIt.hasNext();) {\n\t\t\t\t\tFile file = (File)fileIt.next();\n\t\t\t\t\tString curfilename=file.getName();\n\t\t\t\t\tif (file.delete()) {\n\t\t\t\t\t\tlog.info(getLogPrefix(session)+\"deleted file [\"+file.getAbsolutePath()+\"]\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.warn(getLogPrefix(session)+\"could not delete file [\"+file.getAbsolutePath()+\"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.info(getLogPrefix(session)+\"no files match pattern [\"+filename+\"]\");\n\t\t\t}\n\n\t\t\tif (isDeleteEmptySubdirectories()) {\n\t\t\t\tFile file = new File(filename);\n\t\t\t\tif (file.exists()) {\n\t\t\t\t\tdeleteEmptySubdirectories(getLogPrefix(session), file, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn new PipeRunResult(getForward(), message);\n\t\t}\n\t\tcatch(Exception e) {\n\t\t\tthrow new PipeRunException(this, \"Error while deleting file(s)\", e); \n\t\t}\n\t}", "signature": "PipeRunResult doPipe(Message message, IPipeLineSession session)", "full_signature": "@Override public PipeRunResult doPipe(Message message, IPipeLineSession session)", "class_method_signature": "CleanupOldFilesPipe.doPipe(Message message, IPipeLineSession session)", "testcase": false, "constructor": false, "invocations": ["isNotEmpty", "getFilePattern", "getFilename", "getParameterList", "getFilePattern", "isNotEmpty", "getFilePatternSessionKey", "getFilename", "getParameterList", "get", "getFilePatternSessionKey", "isEmpty", "asString", "asString", "getName", "getFilesForDeletion", "size", "iterator", "hasNext", "next", "getName", "delete", "info", "getLogPrefix", "getAbsolutePath", "warn", "getLogPrefix", "getAbsolutePath", "info", "getLogPrefix", "isDeleteEmptySubdirectories", "exists", "deleteEmptySubdirectories", "getLogPrefix", "getForward"]}, "repository": {"repo_id": 8927606, "url": "https://github.com/ibissource/iaf", "stars": 17, "created": "3/21/2013 11:48:24 AM +00:00", "updates": "2020-01-27T15:25:21+00:00", "fork": "False", "license": "licensed"}}