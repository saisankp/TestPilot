{"test_class": {"identifier": "PagedChannelRandomAccessSourceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "byte[] data;", "modifier": "", "type": "byte[]", "declarator": "data", "var_name": "data"}, {"original_string": "File f;", "modifier": "", "type": "File", "declarator": "f", "var_name": "f"}, {"original_string": "FileChannel channel;", "modifier": "", "type": "FileChannel", "declarator": "channel", "var_name": "channel"}], "file": "itext/src/test/java/com/itextpdf/text/io/PagedChannelRandomAccessSourceTest.java"}, "test_case": {"identifier": "testGetArrayMultiPages", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testGetArrayMultiPages() throws Exception {\n\t\tbyte[] chunk = new byte[257];\n\t\tPagedChannelRandomAccessSource s = new PagedChannelRandomAccessSource(channel, data.length/10, 7);\n\t\ttry{\n\t\t\tint pos = 0;\n\t\t\tint count = s.get(pos, chunk, 0, chunk.length-1);\n\t\t\twhile (count != -1){\n\t\t\t\tassertArrayEqual(data, pos, chunk, 0, count);\n\t\t\t\tpos += count;\n\t\t\t\tcount = s.get(pos, chunk, 0, chunk.length-1);\n\t\t\t}\n\t\t\t\n\t\t\tAssert.assertEquals(-1, s.get(pos, chunk, 0, chunk.length));\n\t\t} finally {\n\t\t\ts.close();\n\t\t}\n\t}", "signature": "void testGetArrayMultiPages()", "full_signature": "@Test public void testGetArrayMultiPages()", "class_method_signature": "PagedChannelRandomAccessSourceTest.testGetArrayMultiPages()", "testcase": true, "constructor": false, "invocations": ["get", "assertArrayEqual", "get", "assertEquals", "get", "close"]}, "focal_class": {"identifier": "PagedChannelRandomAccessSource", "superclass": "extends GroupedRandomAccessSource", "interfaces": "implements RandomAccessSource", "fields": [{"original_string": "public static final int DEFAULT_TOTAL_BUFSIZE = 1 << 26;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_TOTAL_BUFSIZE = 1 << 26", "var_name": "DEFAULT_TOTAL_BUFSIZE"}, {"original_string": "public static final int DEFAULT_MAX_OPEN_BUFFERS = 16;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_MAX_OPEN_BUFFERS = 16", "var_name": "DEFAULT_MAX_OPEN_BUFFERS"}, {"original_string": "private final int bufferSize;", "modifier": "private final", "type": "int", "declarator": "bufferSize", "var_name": "bufferSize"}, {"original_string": "private final FileChannel channel;", "modifier": "private final", "type": "FileChannel", "declarator": "channel", "var_name": "channel"}, {"original_string": "private final MRU<RandomAccessSource> mru;", "modifier": "private final", "type": "MRU<RandomAccessSource>", "declarator": "mru", "var_name": "mru"}], "methods": [{"identifier": "PagedChannelRandomAccessSource", "parameters": "(FileChannel channel)", "modifiers": "public", "return": "", "signature": " PagedChannelRandomAccessSource(FileChannel channel)", "full_signature": "public  PagedChannelRandomAccessSource(FileChannel channel)", "class_method_signature": "PagedChannelRandomAccessSource.PagedChannelRandomAccessSource(FileChannel channel)", "testcase": false, "constructor": true}, {"identifier": "PagedChannelRandomAccessSource", "parameters": "(final FileChannel channel, final int totalBufferSize, final int maxOpenBuffers)", "modifiers": "public", "return": "", "signature": " PagedChannelRandomAccessSource(final FileChannel channel, final int totalBufferSize, final int maxOpenBuffers)", "full_signature": "public  PagedChannelRandomAccessSource(final FileChannel channel, final int totalBufferSize, final int maxOpenBuffers)", "class_method_signature": "PagedChannelRandomAccessSource.PagedChannelRandomAccessSource(final FileChannel channel, final int totalBufferSize, final int maxOpenBuffers)", "testcase": false, "constructor": true}, {"identifier": "buildSources", "parameters": "(final FileChannel channel, final int bufferSize)", "modifiers": "private static", "return": "RandomAccessSource[]", "signature": "RandomAccessSource[] buildSources(final FileChannel channel, final int bufferSize)", "full_signature": "private static RandomAccessSource[] buildSources(final FileChannel channel, final int bufferSize)", "class_method_signature": "PagedChannelRandomAccessSource.buildSources(final FileChannel channel, final int bufferSize)", "testcase": false, "constructor": false}, {"identifier": "getStartingSourceIndex", "parameters": "(long offset)", "modifiers": "@Override /** * {@inheritDoc} */ protected", "return": "int", "signature": "int getStartingSourceIndex(long offset)", "full_signature": "@Override /** * {@inheritDoc} */ protected int getStartingSourceIndex(long offset)", "class_method_signature": "PagedChannelRandomAccessSource.getStartingSourceIndex(long offset)", "testcase": false, "constructor": false}, {"identifier": "sourceReleased", "parameters": "(RandomAccessSource source)", "modifiers": "@Override /** * {@inheritDoc} * For now, close the source that is no longer being used. In the future, we may implement an MRU that allows multiple pages to be opened at a time */ protected", "return": "void", "signature": "void sourceReleased(RandomAccessSource source)", "full_signature": "@Override /** * {@inheritDoc} * For now, close the source that is no longer being used. In the future, we may implement an MRU that allows multiple pages to be opened at a time */ protected void sourceReleased(RandomAccessSource source)", "class_method_signature": "PagedChannelRandomAccessSource.sourceReleased(RandomAccessSource source)", "testcase": false, "constructor": false}, {"identifier": "sourceInUse", "parameters": "(RandomAccessSource source)", "modifiers": "@Override /** * {@inheritDoc} * Ensure that the source is mapped. In the future, we may implement an MRU that allows multiple pages to be opened at a time */ protected", "return": "void", "signature": "void sourceInUse(RandomAccessSource source)", "full_signature": "@Override /** * {@inheritDoc} * Ensure that the source is mapped. In the future, we may implement an MRU that allows multiple pages to be opened at a time */ protected void sourceInUse(RandomAccessSource source)", "class_method_signature": "PagedChannelRandomAccessSource.sourceInUse(RandomAccessSource source)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override /** * {@inheritDoc} * Cleans the mapped bytebuffers and closes the channel */ public", "return": "void", "signature": "void close()", "full_signature": "@Override /** * {@inheritDoc} * Cleans the mapped bytebuffers and closes the channel */ public void close()", "class_method_signature": "PagedChannelRandomAccessSource.close()", "testcase": false, "constructor": false}], "file": "itext/src/main/java/com/itextpdf/text/io/PagedChannelRandomAccessSource.java"}, "focal_method": {"identifier": "close", "parameters": "()", "modifiers": "@Override /** * {@inheritDoc} * Cleans the mapped bytebuffers and closes the channel */ public", "return": "void", "body": "@Override\n    /**\n     * {@inheritDoc}\n     * Cleans the mapped bytebuffers and closes the channel\n     */\n    public void close() throws IOException {\n    \tsuper.close();\n        channel.close();\n    }", "signature": "void close()", "full_signature": "@Override /** * {@inheritDoc} * Cleans the mapped bytebuffers and closes the channel */ public void close()", "class_method_signature": "PagedChannelRandomAccessSource.close()", "testcase": false, "constructor": false, "invocations": ["close", "close"]}, "repository": {"repo_id": 14892248, "url": "https://github.com/itext/itextpdf", "language": "Java", "is_fork": false, "fork_count": 400, "stargazer_count": 1164, "size": 115070, "license": "licensed"}}