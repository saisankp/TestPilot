{"test_class": {"identifier": "SearchByLocationCommandTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String LAYER_ID = \"countries\";", "modifier": "private static final", "type": "String", "declarator": "LAYER_ID = \"countries\"", "var_name": "LAYER_ID"}, {"original_string": "@Autowired\n\tprivate CommandDispatcher dispatcher;", "modifier": "@Autowired\n\tprivate", "type": "CommandDispatcher", "declarator": "dispatcher", "var_name": "dispatcher"}, {"original_string": "@Autowired\n\tprivate DtoConverterService converter;", "modifier": "@Autowired\n\tprivate", "type": "DtoConverterService", "declarator": "converter", "var_name": "converter"}], "file": "command/src/test/java/org/geomajas/command/feature/SearchByLocationCommandTest.java"}, "test_case": {"identifier": "intersectCountriesOnEquatorWithFilter", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void intersectCountriesOnEquatorWithFilter() throws Exception {\n\t\t// prepare command\n\t\tSearchByLocationRequest request = new SearchByLocationRequest();\n\t\trequest.setCrs(\"EPSG:4326\");\n\t\trequest.setQueryType(SearchByLocationRequest.QUERY_INTERSECTS);\n\t\trequest.setSearchType(SearchByLocationRequest.SEARCH_ALL_LAYERS);\n\t\trequest.setLayerIds(new String[] {LAYER_ID});\n\t\t//note that setting a global filter on the SearchByLocationRequest will only work if the filter is applicable\n\t\t//to all layers! In this test case there is only one layer.\n\t\trequest.setFilter(\"region='Region 1'\");\n\n\t\tGeometryFactory factory = new GeometryFactory();\n\t\tLineString equator = factory.createLineString(new Coordinate[] {new Coordinate(0, 0),\n\t\t\t\tnew Coordinate(-180, 180)});\n\t\trequest.setLocation(converter.toDto(equator));\n\n\t\t// execute\n\t\tSearchByLocationResponse response = (SearchByLocationResponse) dispatcher.execute(\n\t\t\t\tSearchByLocationRequest.COMMAND, request, null, \"en\");\n\n\t\t// test\n\t\tAssert.assertFalse(response.isError());\n\t\tList<Feature> features = response.getFeatureMap().get(LAYER_ID);\n\t\tAssert.assertNotNull(features);\n\t\tAssert.assertEquals(2, features.size());\n\t\tList<String> actual = new ArrayList<String>();\n\t\tfor (Feature feature : features) {\n\t\t\tactual.add(feature.getLabel());\n\t\t}\n\t\tAssert.assertTrue(actual.contains(\"Country 2\"));\n\t\tAssert.assertTrue(actual.contains(\"Country 1\"));\n\t}", "signature": "void intersectCountriesOnEquatorWithFilter()", "full_signature": "@Test public void intersectCountriesOnEquatorWithFilter()", "class_method_signature": "SearchByLocationCommandTest.intersectCountriesOnEquatorWithFilter()", "testcase": true, "constructor": false, "invocations": ["setCrs", "setQueryType", "setSearchType", "setLayerIds", "setFilter", "createLineString", "setLocation", "toDto", "execute", "assertFalse", "isError", "get", "getFeatureMap", "assertNotNull", "assertEquals", "size", "add", "getLabel", "assertTrue", "contains", "assertTrue", "contains"]}, "focal_class": {"identifier": "SearchByLocationCommand", "superclass": "", "interfaces": "implements CommandHasRequest<SearchByLocationRequest, SearchByLocationResponse>", "fields": [{"original_string": "private final Logger log = LoggerFactory.getLogger(SearchByLocationCommand.class);", "modifier": "private final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(SearchByLocationCommand.class)", "var_name": "log"}, {"original_string": "@Autowired\n\tprivate ConfigurationService configurationService;", "modifier": "@Autowired\n\tprivate", "type": "ConfigurationService", "declarator": "configurationService", "var_name": "configurationService"}, {"original_string": "@Autowired\n\tprivate GeoService geoService;", "modifier": "@Autowired\n\tprivate", "type": "GeoService", "declarator": "geoService", "var_name": "geoService"}, {"original_string": "@Autowired\n\tprivate DtoConverterService converter;", "modifier": "@Autowired\n\tprivate", "type": "DtoConverterService", "declarator": "converter", "var_name": "converter"}, {"original_string": "@Autowired\n\tprivate FilterService filterCreator;", "modifier": "@Autowired\n\tprivate", "type": "FilterService", "declarator": "filterCreator", "var_name": "filterCreator"}, {"original_string": "@Autowired\n\tprivate VectorLayerService layerService;", "modifier": "@Autowired\n\tprivate", "type": "VectorLayerService", "declarator": "layerService", "var_name": "layerService"}, {"original_string": "@Autowired\n\tprivate SecurityContext securityContext;", "modifier": "@Autowired\n\tprivate", "type": "SecurityContext", "declarator": "securityContext", "var_name": "securityContext"}], "methods": [{"identifier": "getEmptyCommandRequest", "parameters": "()", "modifiers": "@Override public", "return": "SearchByLocationRequest", "signature": "SearchByLocationRequest getEmptyCommandRequest()", "full_signature": "@Override public SearchByLocationRequest getEmptyCommandRequest()", "class_method_signature": "SearchByLocationCommand.getEmptyCommandRequest()", "testcase": false, "constructor": false}, {"identifier": "getEmptyCommandResponse", "parameters": "()", "modifiers": "@Override public", "return": "SearchByLocationResponse", "signature": "SearchByLocationResponse getEmptyCommandResponse()", "full_signature": "@Override public SearchByLocationResponse getEmptyCommandResponse()", "class_method_signature": "SearchByLocationCommand.getEmptyCommandResponse()", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "(SearchByLocationRequest request, SearchByLocationResponse response)", "modifiers": "@Override public", "return": "void", "signature": "void execute(SearchByLocationRequest request, SearchByLocationResponse response)", "full_signature": "@Override public void execute(SearchByLocationRequest request, SearchByLocationResponse response)", "class_method_signature": "SearchByLocationCommand.execute(SearchByLocationRequest request, SearchByLocationResponse response)", "testcase": false, "constructor": false}], "file": "command/src/main/java/org/geomajas/command/feature/SearchByLocationCommand.java"}, "focal_method": {"identifier": "execute", "parameters": "(SearchByLocationRequest request, SearchByLocationResponse response)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void execute(SearchByLocationRequest request, SearchByLocationResponse response) throws Exception {\n\t\tif (null == request.getLayerIds()) {\n\t\t\tthrow new GeomajasException(ExceptionCode.PARAMETER_MISSING, \"layerIds\");\n\t\t}\n\t\tString crsCode = request.getCrs();\n\t\tif (null == crsCode) {\n\t\t\tthrow new GeomajasException(ExceptionCode.PARAMETER_MISSING, \"crs\");\n\t\t}\n\t\tGeometry location = converter.toInternal(request.getLocation());\n\t\tint queryType = request.getQueryType();\n\t\tdouble ratio = request.getRatio();\n\t\tint searchType = request.getSearchType();\n\t\tCrs crs = geoService.getCrs2(request.getCrs());\n\n\t\t// Check if a buffer should be added around the location:\n\t\tGeometry geometry = location;\n\t\tif (request.getBuffer() > 0) {\n\t\t\tgeometry = location.buffer(request.getBuffer());\n\t\t}\n\t\tlog.debug(\"search by location \" + geometry);\n\n\t\tfor (String clientLayerId : request.getLayerIds()) {\n\t\t\tString serverLayerId = request.getServerLayerId(clientLayerId);\n\t\t\tif (null == serverLayerId) {\n\t\t\t\tthrow new GeomajasException(ExceptionCode.PARAMETER_MISSING, \n\t\t\t\t\t\t\t\t\"serverLayerId for clientLayerId \" + clientLayerId);\n\t\t\t}\n\t\t\tif (securityContext.isLayerVisible(serverLayerId)) {\n\t\t\t\tVectorLayer vectorLayer = configurationService.getVectorLayer(serverLayerId);\n\t\t\t\tif (vectorLayer != null) {\n\t\t\t\t\tString geomName = vectorLayer.getLayerInfo().getFeatureInfo().getGeometryType().getName();\n\n\t\t\t\t\t// Transform geometry to layer CRS:\n\t\t\t\t\tGeometry layerGeometry = geoService.transform(geometry, crs, layerService.getCrs(vectorLayer));\n\t\t\t\t\tlog.trace(\"on layer \" + serverLayerId + \" use \" + layerGeometry);\n\n\t\t\t\t\t// Create the correct Filter object:\n\t\t\t\t\tFilter f = null;\n\t\t\t\t\tswitch (queryType) {\n\t\t\t\t\t\tcase SearchByLocationRequest.QUERY_INTERSECTS:\n\t\t\t\t\t\t\tf = filterCreator.createIntersectsFilter(layerGeometry, geomName);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SearchByLocationRequest.QUERY_CONTAINS:\n\t\t\t\t\t\t\tf = filterCreator.createContainsFilter(layerGeometry, geomName);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SearchByLocationRequest.QUERY_TOUCHES:\n\t\t\t\t\t\t\tf = filterCreator.createTouchesFilter(layerGeometry, geomName);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SearchByLocationRequest.QUERY_WITHIN:\n\t\t\t\t\t\t\tf = filterCreator.createWithinFilter(layerGeometry, geomName);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Unknown query type \" + queryType);\n\t\t\t\t\t}\n\t\t\t\t\t//Set the per layer filter\n\t\t\t\t\tif (null != request.getFilter(clientLayerId)) {\n\t\t\t\t\t\tif (null == f) {\n\t\t\t\t\t\t\tf = filterCreator.parseFilter(request.getFilter(clientLayerId));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tf = filterCreator.createAndFilter(\n\t\t\t\t\t\t\t\t\tfilterCreator.parseFilter(request.getFilter(clientLayerId)), f);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//Set the global filter\n\t\t\t\t\tif (null != request.getFilter()) {\n\t\t\t\t\t\tif (null == f) {\n\t\t\t\t\t\t\tf = filterCreator.parseFilter(request.getFilter());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tf = filterCreator.createAndFilter(filterCreator.parseFilter(request.getFilter()), f);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the features:\n\t\t\t\t\tList<InternalFeature> temp = layerService.getFeatures(serverLayerId, crs, f, null, request\n\t\t\t\t\t\t\t.getFeatureIncludes());\n\t\t\t\t\tif (temp.size() > 0) {\n\t\t\t\t\t\tList<Feature> features = new ArrayList<Feature>();\n\n\t\t\t\t\t\t// Calculate overlap ratio in case of intersects:\n\t\t\t\t\t\tif (queryType == SearchByLocationRequest.QUERY_INTERSECTS && ratio >= 0 && ratio < 1) {\n\t\t\t\t\t\t\tfor (InternalFeature feature : temp) {\n\t\t\t\t\t\t\t\tdouble minimalOverlap = feature.getGeometry().getArea() * ratio;\n\t\t\t\t\t\t\t\tGeometry overlap = geometry.intersection(feature.getGeometry());\n\t\t\t\t\t\t\t\tdouble effectiveOverlap = overlap.getArea();\n\t\t\t\t\t\t\t\tif (minimalOverlap <= effectiveOverlap) {\n\t\t\t\t\t\t\t\t\tlog.trace(\"found \" + feature);\n\t\t\t\t\t\t\t\t\tFeature dto = converter.toDto(feature);\n\t\t\t\t\t\t\t\t\tdto.setCrs(crsCode);\n\t\t\t\t\t\t\t\t\tfeatures.add(dto);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (InternalFeature feature : temp) {\n\t\t\t\t\t\t\t\tlog.trace(\"found \" + feature);\n\t\t\t\t\t\t\t\tFeature dto = converter.toDto(feature);\n\t\t\t\t\t\t\t\tdto.setCrs(crsCode);\n\t\t\t\t\t\t\t\tfeatures.add(dto);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// features.size can again be 0... so check:\n\t\t\t\t\t\tif (features.size() > 0) {\n\t\t\t\t\t\t\t// We have a response for this layer!\n\t\t\t\t\t\t\tresponse.addLayer(clientLayerId, features);\n\n\t\t\t\t\t\t\t// If searchType == SEARCH_FIRST_LAYER, we should search no further:\n\t\t\t\t\t\t\tif (searchType == SearchByLocationRequest.SEARCH_FIRST_LAYER) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "signature": "void execute(SearchByLocationRequest request, SearchByLocationResponse response)", "full_signature": "@Override public void execute(SearchByLocationRequest request, SearchByLocationResponse response)", "class_method_signature": "SearchByLocationCommand.execute(SearchByLocationRequest request, SearchByLocationResponse response)", "testcase": false, "constructor": false, "invocations": ["getLayerIds", "getCrs", "toInternal", "getLocation", "getQueryType", "getRatio", "getSearchType", "getCrs2", "getCrs", "getBuffer", "buffer", "getBuffer", "debug", "getLayerIds", "getServerLayerId", "isLayerVisible", "getVectorLayer", "getName", "getGeometryType", "getFeatureInfo", "getLayerInfo", "transform", "getCrs", "trace", "createIntersectsFilter", "createContainsFilter", "createTouchesFilter", "createWithinFilter", "getFilter", "parseFilter", "getFilter", "createAndFilter", "parseFilter", "getFilter", "getFilter", "parseFilter", "getFilter", "createAndFilter", "parseFilter", "getFilter", "getFeatures", "getFeatureIncludes", "size", "getArea", "getGeometry", "intersection", "getGeometry", "getArea", "trace", "toDto", "setCrs", "add", "trace", "toDto", "setCrs", "add", "size", "addLayer"]}, "repository": {"repo_id": 14505280, "url": "https://github.com/geomajas/geomajas-project-server", "language": "Java", "is_fork": false, "fork_count": 15, "stargazer_count": 13, "size": 124882, "license": "licensed"}}