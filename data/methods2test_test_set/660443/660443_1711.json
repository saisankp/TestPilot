{"test_class": {"identifier": "MACCSFingerprinterTest", "superclass": "extends AbstractFixedLengthFingerprinterTest", "interfaces": "", "fields": [{"original_string": "private static ILoggingTool logger = LoggingToolFactory.createLoggingTool(MACCSFingerprinterTest.class);", "modifier": "private static", "type": "ILoggingTool", "declarator": "logger = LoggingToolFactory.createLoggingTool(MACCSFingerprinterTest.class)", "var_name": "logger"}], "file": "descriptor/fingerprint/src/test/java/org/openscience/cdk/fingerprint/MACCSFingerprinterTest.java"}, "test_case": {"identifier": "testBug706786", "parameters": "()", "modifiers": "@Test @Override public", "return": "void", "body": "@Test\n    @Override\n    public void testBug706786() throws Exception {\n\n        IAtomContainer superStructure = bug706786_1();\n        IAtomContainer subStructure = bug706786_2();\n\n        AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(superStructure);\n        AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(subStructure);\n        addImplicitHydrogens(superStructure);\n        addImplicitHydrogens(subStructure);\n\n        IFingerprinter fpr = new MACCSFingerprinter();\n        IBitFingerprint superBits = fpr.getBitFingerprint(superStructure);\n        IBitFingerprint subBits = fpr.getBitFingerprint(subStructure);\n\n        assertThat(\n                superBits.asBitSet(),\n                is(asBitSet(53, 56, 65, 71, 73, 88, 97, 104, 111, 112, 126, 130, 136, 138, 139, 140, 142, 143,\n                        144, 145, 148, 149, 151, 153, 156, 158, 159, 161, 162, 163, 164)));\n        assertThat(\n                subBits.asBitSet(),\n                is(asBitSet(56, 97, 104, 108, 112, 117, 131, 136, 143, 144, 146, 151, 152, 156, 161, 162, 163, 164)));\n    }", "signature": "void testBug706786()", "full_signature": "@Test @Override public void testBug706786()", "class_method_signature": "MACCSFingerprinterTest.testBug706786()", "testcase": true, "constructor": false, "invocations": ["bug706786_1", "bug706786_2", "percieveAtomTypesAndConfigureAtoms", "percieveAtomTypesAndConfigureAtoms", "addImplicitHydrogens", "addImplicitHydrogens", "getBitFingerprint", "getBitFingerprint", "assertThat", "asBitSet", "is", "asBitSet", "assertThat", "asBitSet", "is", "asBitSet"]}, "focal_class": {"identifier": "MACCSFingerprinter", "superclass": "extends AbstractFingerprinter", "interfaces": "implements IFingerprinter", "fields": [{"original_string": "private static ILoggingTool logger          = LoggingToolFactory.createLoggingTool(MACCSFingerprinter.class);", "modifier": "private static", "type": "ILoggingTool", "declarator": "logger          = LoggingToolFactory.createLoggingTool(MACCSFingerprinter.class)", "var_name": "logger"}, {"original_string": "private static final String KEY_DEFINITIONS = \"data/maccs.txt\";", "modifier": "private static final", "type": "String", "declarator": "KEY_DEFINITIONS = \"data/maccs.txt\"", "var_name": "KEY_DEFINITIONS"}, {"original_string": "private volatile MaccsKey[] keys            = null;", "modifier": "private volatile", "type": "MaccsKey[]", "declarator": "keys            = null", "var_name": "keys"}, {"original_string": "private final Object lock = new Object();", "modifier": "private final", "type": "Object", "declarator": "lock = new Object()", "var_name": "lock"}], "methods": [{"identifier": "MACCSFingerprinter", "parameters": "()", "modifiers": "public", "return": "", "signature": " MACCSFingerprinter()", "full_signature": "public  MACCSFingerprinter()", "class_method_signature": "MACCSFingerprinter.MACCSFingerprinter()", "testcase": false, "constructor": true}, {"identifier": "MACCSFingerprinter", "parameters": "(IChemObjectBuilder builder)", "modifiers": "public", "return": "", "signature": " MACCSFingerprinter(IChemObjectBuilder builder)", "full_signature": "public  MACCSFingerprinter(IChemObjectBuilder builder)", "class_method_signature": "MACCSFingerprinter.MACCSFingerprinter(IChemObjectBuilder builder)", "testcase": false, "constructor": true}, {"identifier": "getBitFingerprint", "parameters": "(IAtomContainer container)", "modifiers": "@Override public", "return": "IBitFingerprint", "signature": "IBitFingerprint getBitFingerprint(IAtomContainer container)", "full_signature": "@Override public IBitFingerprint getBitFingerprint(IAtomContainer container)", "class_method_signature": "MACCSFingerprinter.getBitFingerprint(IAtomContainer container)", "testcase": false, "constructor": false}, {"identifier": "visitPart", "parameters": "(boolean[] visit, int[][] g, int beg, int prev)", "modifiers": "private static", "return": "int", "signature": "int visitPart(boolean[] visit, int[][] g, int beg, int prev)", "full_signature": "private static int visitPart(boolean[] visit, int[][] g, int beg, int prev)", "class_method_signature": "MACCSFingerprinter.visitPart(boolean[] visit, int[][] g, int beg, int prev)", "testcase": false, "constructor": false}, {"identifier": "isAromPath", "parameters": "(int[] path, GraphUtil.EdgeToBondMap bmap)", "modifiers": "private static", "return": "boolean", "signature": "boolean isAromPath(int[] path, GraphUtil.EdgeToBondMap bmap)", "full_signature": "private static boolean isAromPath(int[] path, GraphUtil.EdgeToBondMap bmap)", "class_method_signature": "MACCSFingerprinter.isAromPath(int[] path, GraphUtil.EdgeToBondMap bmap)", "testcase": false, "constructor": false}, {"identifier": "getRawFingerprint", "parameters": "(IAtomContainer iAtomContainer)", "modifiers": "@Override public", "return": "Map<String, Integer>", "signature": "Map<String, Integer> getRawFingerprint(IAtomContainer iAtomContainer)", "full_signature": "@Override public Map<String, Integer> getRawFingerprint(IAtomContainer iAtomContainer)", "class_method_signature": "MACCSFingerprinter.getRawFingerprint(IAtomContainer iAtomContainer)", "testcase": false, "constructor": false}, {"identifier": "getSize", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getSize()", "full_signature": "@Override public int getSize()", "class_method_signature": "MACCSFingerprinter.getSize()", "testcase": false, "constructor": false}, {"identifier": "readKeyDef", "parameters": "(final IChemObjectBuilder builder)", "modifiers": "private", "return": "MaccsKey[]", "signature": "MaccsKey[] readKeyDef(final IChemObjectBuilder builder)", "full_signature": "private MaccsKey[] readKeyDef(final IChemObjectBuilder builder)", "class_method_signature": "MACCSFingerprinter.readKeyDef(final IChemObjectBuilder builder)", "testcase": false, "constructor": false}, {"identifier": "getCountFingerprint", "parameters": "(IAtomContainer container)", "modifiers": "@Override public", "return": "ICountFingerprint", "signature": "ICountFingerprint getCountFingerprint(IAtomContainer container)", "full_signature": "@Override public ICountFingerprint getCountFingerprint(IAtomContainer container)", "class_method_signature": "MACCSFingerprinter.getCountFingerprint(IAtomContainer container)", "testcase": false, "constructor": false}, {"identifier": "keys", "parameters": "(final IChemObjectBuilder builder)", "modifiers": "private", "return": "MaccsKey[]", "signature": "MaccsKey[] keys(final IChemObjectBuilder builder)", "full_signature": "private MaccsKey[] keys(final IChemObjectBuilder builder)", "class_method_signature": "MACCSFingerprinter.keys(final IChemObjectBuilder builder)", "testcase": false, "constructor": false}, {"identifier": "createPattern", "parameters": "(String smarts, IChemObjectBuilder builder)", "modifiers": "private", "return": "Pattern", "signature": "Pattern createPattern(String smarts, IChemObjectBuilder builder)", "full_signature": "private Pattern createPattern(String smarts, IChemObjectBuilder builder)", "class_method_signature": "MACCSFingerprinter.createPattern(String smarts, IChemObjectBuilder builder)", "testcase": false, "constructor": false}], "file": "descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/MACCSFingerprinter.java"}, "focal_method": {"identifier": "getBitFingerprint", "parameters": "(IAtomContainer container)", "modifiers": "@Override public", "return": "IBitFingerprint", "body": "@Override\n    public IBitFingerprint getBitFingerprint(IAtomContainer container) throws CDKException {\n\n        MaccsKey[] keys = keys(container.getBuilder());\n        BitSet fp = new BitSet(keys.length);\n\n        // init SMARTS invariants (connectivity, degree, etc)\n        SmartsPattern.prepare(container);\n\n        final int numAtoms = container.getAtomCount();\n\n\n        final GraphUtil.EdgeToBondMap bmap    = GraphUtil.EdgeToBondMap.withSpaceFor(container);\n        final int[][]                 adjlist = GraphUtil.toAdjList(container, bmap);\n\n        for (int i = 0; i < keys.length; i++) {\n            final MaccsKey key     = keys[i];\n            final Pattern  pattern = key.pattern;\n\n            switch (key.smarts) {\n                case \"[!*]\":\n                    break;\n                case \"[!0]\":\n                    for (IAtom atom : container.atoms()) {\n                        if (atom.getMassNumber() != null) {\n                            fp.set(i);\n                            break;\n                        }\n                    }\n                    break;\n\n                // ring bits\n                case \"[R]1@*@*@1\": // 3M RING bit22\n                case \"[R]1@*@*@*@1\": // 4M RING bit11\n                case \"[R]1@*@*@*@*@1\": // 5M RING bit96\n                case \"[R]1@*@*@*@*@*@1\": // 6M RING bit163, x2=bit145\n                case \"[R]1@*@*@*@*@*@*@1\": // 7M RING, bit19\n                case \"[R]1@*@*@*@*@*@*@*@1\": // 8M RING, bit101\n                    // handled separately\n                    break;\n\n                case \"(*).(*)\":\n                    // bit 166 (*).(*) we can match this in SMARTS but it's faster to just\n                    // count the number of components or in this case try to traverse the\n                    // component, iff there are some atoms not visited we have more than\n                    // one component\n                    boolean[] visit = new boolean[numAtoms];\n                    if (numAtoms > 1 && visitPart(visit, adjlist, 0, -1) < numAtoms)\n                        fp.set(165);\n                    break;\n\n                default:\n                    if (key.count == 0) {\n                        if (pattern.matches(container))\n                            fp.set(i);\n                    } else {\n                        // check if there are at least 'count' unique hits, key.count = 0\n                        // means find at least one match hence we add 1 to out limit\n                        if (pattern.matchAll(container).uniqueAtoms().atLeast(key.count + 1))\n                            fp.set(i);\n                    }\n                    break;\n            }\n        }\n\n        // Ring Bits\n\n        // threshold=126, see AllRingsFinder.Threshold.PubChem_97\n        if (numAtoms > 2) {\n            AllCycles allcycles = new AllCycles(adjlist,\n                                                Math.min(8, numAtoms),\n                                                126);\n            int numArom = 0;\n            for (int[] path : allcycles.paths()) {\n                // length is +1 as we repeat the closure vertex\n                switch (path.length) {\n                    case 4: // 3M bit22\n                        fp.set(21);\n                        break;\n                    case 5: // 4M bit11\n                        fp.set(10);\n                        break;\n                    case 6: // 5M bit96\n                        fp.set(95);\n                        break;\n                    case 7: // 6M bit163->bit145, bit124 numArom > 1\n\n                        if (numArom < 2) {\n                            if (isAromPath(path, bmap)) {\n                                numArom++;\n                                if (numArom == 2)\n                                    fp.set(124);\n                            }\n                        }\n\n                        if (fp.get(162)) {\n                            fp.set(144); // >0\n                        } else {\n                            fp.set(162); // >1\n                        }\n                        break;\n                    case 8: // 7M bit19\n                        fp.set(18);\n                        break;\n                    case 9: // 8M bit101\n                        fp.set(100);\n                        break;\n                }\n            }\n        }\n\n        return new BitSetFingerprint(fp);\n    }", "signature": "IBitFingerprint getBitFingerprint(IAtomContainer container)", "full_signature": "@Override public IBitFingerprint getBitFingerprint(IAtomContainer container)", "class_method_signature": "MACCSFingerprinter.getBitFingerprint(IAtomContainer container)", "testcase": false, "constructor": false, "invocations": ["keys", "getBuilder", "prepare", "getAtomCount", "withSpaceFor", "toAdjList", "atoms", "getMassNumber", "set", "visitPart", "set", "matches", "set", "atLeast", "uniqueAtoms", "matchAll", "set", "min", "paths", "set", "set", "set", "isAromPath", "set", "get", "set", "set", "set", "set"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}