{"test_class": {"identifier": "DijkstraTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static HierarchyMapGraph test3;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "test3", "var_name": "test3"}, {"original_string": "private static HierarchyMapGraph test5;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "test5", "var_name": "test5"}, {"original_string": "private static HierarchyMapGraph test8;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "test8", "var_name": "test8"}, {"original_string": "private static HierarchyMapGraph testGraph1;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph1", "var_name": "testGraph1"}, {"original_string": "private static HierarchyMapGraph testGraph2;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph2", "var_name": "testGraph2"}, {"original_string": "private static HierarchyMapGraph testGraph3;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph3", "var_name": "testGraph3"}, {"original_string": "private static HierarchyMapGraph testGraph4;", "modifier": "private static", "type": "HierarchyMapGraph", "declarator": "testGraph4", "var_name": "testGraph4"}, {"original_string": "private static boolean fastBackup;", "modifier": "private static", "type": "boolean", "declarator": "fastBackup", "var_name": "fastBackup"}], "file": "SoftwarePraktikum/src/algorithmen/DijkstraTest.java"}, "test_case": {"identifier": "testWeight", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testWeight() throws Exception {\n\t\t\n\t\tConfig.fastestPathMode = true;\n\t\t\n\t\t//Hier wird ein Graph erstellt, wo die kuerzeste Route nicht der schnellsten entspricht.\n\t\tint gr = 4;\n\t\tMapGraph weightGraph = GitterWeightGraph(gr);\n\t\t\n\t\tLogger.getInstance().log(\"DijkstraTest\",\"Starte WeightGitter-Test (n=\"+gr+\")\");\n\n\t\tArrayList<MapNode> liste = Dijkstra.bidirectional(weightGraph, 1, gr*gr);\n\t\tLogger.getInstance().log(\"DijkstraTest\",\"Weglaenge (soll: \"+((2*gr)-2)*3+\"): \"+weglaengeStrict(liste));\n\t\tLogger.getInstance().log(\"DijkstraTest\", \"WegGewicht: \"+weglaenge(liste));\n\t\tLogger.getInstance().log(\"DijkstraTest\",\"Pfad: \"+Pfad(liste));\n\t\t\n\t\t//Pruefe auf krrekte Weglaenge - nicht dauer!\n\t\tif (weglaenge(liste) == ((2*gr)-2)*2)\n\t\t\tfail(\"Der berechnete Weg ist nciht der schnellste, sondern der kuerzeste\");\n\t\t\n\t\tif (weglaengeStrict(liste) != ((2*gr)-2)*3)\n\t\t\tfail(\"Der berechnete Weg ist nciht der schnellste. Soll:\"+((2*gr)-2)*3+\" Ist:\"+weglaengeStrict(liste));\n\t\t\n\t\t\n\t}", "signature": "void testWeight()", "full_signature": "@Test public void testWeight()", "class_method_signature": "DijkstraTest.testWeight()", "testcase": true, "constructor": false, "invocations": ["GitterWeightGraph", "log", "getInstance", "bidirectional", "log", "getInstance", "weglaengeStrict", "log", "getInstance", "weglaenge", "log", "getInstance", "Pfad", "weglaenge", "fail", "weglaengeStrict", "fail", "weglaengeStrict"]}, "focal_class": {"identifier": "Dijkstra", "superclass": "", "interfaces": "", "fields": [{"original_string": "static boolean debug = false;", "modifier": "static", "type": "boolean", "declarator": "debug = false", "var_name": "debug"}, {"original_string": "private static Logger logger = Logger.getInstance();", "modifier": "private static", "type": "Logger", "declarator": "logger = Logger.getInstance()", "var_name": "logger"}], "methods": [{"identifier": "updateNeighbours", "parameters": "(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "modifiers": "private static", "return": "void", "signature": "void updateNeighbours(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "full_signature": "private static void updateNeighbours(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "class_method_signature": "Dijkstra.updateNeighbours(HashMap<Integer,Vertex> nodes, PrQueue queue, HierarchyMapEdge newEdge, Vertex node, boolean mode)", "testcase": false, "constructor": false}, {"identifier": "neighbourhood", "parameters": "(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "modifiers": "public static", "return": "long", "signature": "long neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "full_signature": "public static long neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "class_method_signature": "Dijkstra.neighbourhood(HierarchyMapGraph graph, int startnode, byte level, boolean forward)", "testcase": false, "constructor": false}, {"identifier": "handleQueues", "parameters": "(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "modifiers": "private static", "return": "boolean", "signature": "boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "full_signature": "private static boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "class_method_signature": "Dijkstra.handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, MapGraph graph, \n\t\t\t\t\t\t\t\t\tHashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "testcase": false, "constructor": false}, {"identifier": "bidirectional", "parameters": "(MapGraph graph, int startnode, int endnode)", "modifiers": "public static", "return": "ArrayList<MapNode>", "signature": "ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode)", "full_signature": "public static ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode)", "class_method_signature": "Dijkstra.bidirectional(MapGraph graph, int startnode, int endnode)", "testcase": false, "constructor": false}, {"identifier": "handleQueues", "parameters": "(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "modifiers": "private static", "return": "boolean", "signature": "boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "full_signature": "private static boolean handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "class_method_signature": "Dijkstra.handleQueues(HashMap<Integer,Vertex> nodes1, PrQueue forward, \n\t\t\t\t\t\t\t\t\t    HashMap<Integer,Vertex> nodes2, PrQueue backward, boolean mode)", "testcase": false, "constructor": false}, {"identifier": "bidirectional", "parameters": "(HierarchyMapGraph graph, int startnode, int endnode)", "modifiers": "public static", "return": "Path", "signature": "Path bidirectional(HierarchyMapGraph graph, int startnode, int endnode)", "full_signature": "public static Path bidirectional(HierarchyMapGraph graph, int startnode, int endnode)", "class_method_signature": "Dijkstra.bidirectional(HierarchyMapGraph graph, int startnode, int endnode)", "testcase": false, "constructor": false}], "file": "SoftwarePraktikum/src/algorithmen/Dijkstra.java"}, "focal_method": {"identifier": "bidirectional", "parameters": "(MapGraph graph, int startnode, int endnode)", "modifiers": "public static", "return": "ArrayList<MapNode>", "body": "public static ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode) throws Exception{\n\t\t\n\t\tif (graph == null) throw new EmptyInputException(\"Leerer Graph uebergeben\");\n\t\t//Hier breche ich immer wieder ab, was echt bloed ist und mich nervt das langsam echt!\n\t\tif (graph.getNode(startnode) == null || graph.getNode(endnode) == null || startnode == endnode) return new ArrayList<MapNode>();\n\t\t\n\t\tHashMap<Integer,Vertex> nodes1 = new HashMap<Integer,Vertex>(); // In einzelnen Listen wird gespeichert welcher Knoten.\n\t\tHashMap<Integer,Vertex> nodes2 = new HashMap<Integer,Vertex>(); //von welcher Richtung aus schon besucht worden ist.\n\t\t\n\t\tPrQueue forward = new PrQueue(); //Priority Queue, die alle erreichbaren Knoten enthaelt\n\t\tPrQueue backward = new PrQueue(); //Priority Queue, die alle erreichbaren Knoten enthaelt\n\t\t\n\t\tVertex start = new Vertex(graph.getNode(startnode),0,0); //Vertex ist die Hilfsklasse, in der zusaetzliche Infos ueber Knoten gespeichert werden.\n\t\tVertex end = new Vertex(graph.getNode(endnode),0,0); //Vertex ist die Hilfsklasse, in der zusaetzliche Infos ueber Knoten gespeichert werden.\n\t\t\n\t\tnodes1.put(startnode,start); \n\t\tnodes2.put(endnode,end);\n\t\t\n\t\tforward.insert(start);\n\t\tbackward.insert(end);\n        \n\t\twhile (forward.getSize() != 0 && backward.getSize() != 0){ //Wenn beide Queues leer, Abbruch\n\t\t\tboolean abort;\n\t\t\tabort = handleQueues(nodes1,forward,graph,nodes2,backward,true); //Berechne vorwaerts\n\t\t\tif(abort) break;\n\t\t\tabort = handleQueues(nodes1,forward,graph,nodes2,backward,false); //Berechne rueckwaerts\n\t\t\tif(abort) break;\n\t\t}\n\t\t\n\t\tlong distance = -1;\n\t\tVertex meet = null;\n\t\t\n\t\t\n\t\t//Wir suchen den Punkt ueber den der kuerzeste Weg verlueuft\n\t\tfor (Vertex currentNode : nodes1.values()){\n\t\t\t\n\t\t\t//ueber pruefe ob Node in beiden Listen vorhanden ist\n\t\t\t\n\t\t\tint ID = currentNode.node.getUID();\n\t\t\tif (nodes2.containsKey(ID) == false){\n\t\t\t\tcontinue;  //node noch nicht von anderer Seite ueberprueft => liegt nicht auf kuerzestem Weg\n\t\t\t}\n\t\t\t\n\t\t\tif (distance == -1) {\n\t\t\t\tdistance = nodes1.get(ID).getDist() + nodes2.get(ID).getDist();\n\t\t\t\tmeet = nodes1.get(ID);\n\t\t\t\t\n\n\t\t\t}else{\n\t\t\t\tlong newDist = nodes1.get(ID).getDist() + nodes2.get(ID).getDist();\n\t\t\t\tif (distance > newDist){\n\t\t\t\t\tdistance = nodes1.get(ID).getDist() + nodes2.get(ID).getDist();\n\t\t\t\t\tmeet = nodes1.get(ID);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif (meet == null) return new ArrayList<MapNode>();\n\t\t\n\t\tArrayList<MapNode> route = new ArrayList<MapNode>();\n\n\t\troute.add(graph.getNode(meet.node.getUID() ) );\n\t\tVertex pos = meet;\n\t\t\n\t\twhile (pos.getPredecessor() != 0){ //Ermittle alle Knoten, die vor meet besucht wurden\n\t\t\tVertex parent = nodes1.get(pos.getPredecessor());\n\t\t\troute.add(0, graph.getNode(parent.node.getUID()));\n\t\t\tpos = parent;\n\t\t}\n\t\t\n\t\tpos = nodes2.get( meet.node.getUID());\n\t\t\n\t\twhile (pos.getPredecessor() != 0){ //Ermittle alle Knoten die nach meet besucht wurden \n\t\t\tVertex parent = nodes2.get(pos.getPredecessor());\n\t\t\troute.add(graph.getNode(parent.node.getUID()));\n\t\t\tpos = parent;\n\t\t}\t\t\n\t\t\n\t\tif(debug){ \n\t\t\tlogger.log(\"Dijkstra.biderectional\",\"Vom Startknoten aus evaluiert: \"+nodes1.values().size());\n\t\t\tlogger.log(\"Dijkstra.biderectional\",\"Vom Zielknoten aus evaluiert: \"+nodes2.values().size());\n\t\t\tlogger.log(\"Dijkstra.biderectional\",\"Knoten auf der Route: \"+route.size());\n\t\t}\n\t\t\n\t\treturn route; //gib die Liste zurueck\n\t}", "signature": "ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode)", "full_signature": "public static ArrayList<MapNode> bidirectional(MapGraph graph, int startnode, int endnode)", "class_method_signature": "Dijkstra.bidirectional(MapGraph graph, int startnode, int endnode)", "testcase": false, "constructor": false, "invocations": ["getNode", "getNode", "getNode", "getNode", "put", "put", "insert", "insert", "getSize", "getSize", "handleQueues", "handleQueues", "values", "getUID", "containsKey", "getDist", "get", "getDist", "get", "get", "getDist", "get", "getDist", "get", "getDist", "get", "getDist", "get", "get", "add", "getNode", "getUID", "getPredecessor", "get", "getPredecessor", "add", "getNode", "getUID", "get", "getUID", "getPredecessor", "get", "getPredecessor", "add", "getNode", "getUID", "log", "size", "values", "log", "size", "values", "log", "size"]}, "repository": {"repo_id": 3716960, "url": "https://github.com/auxua/SWP-Routenplaner", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 5, "size": 13806, "license": "licensed"}}