{"test_class": {"identifier": "DSpaceControlledVocabularyTest", "superclass": "extends AbstractDSpaceTest", "interfaces": "", "fields": [], "file": "dspace-api/src/test/java/org/dspace/content/authority/DSpaceControlledVocabularyTest.java"}, "test_case": {"identifier": "testGetMatches", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGetMatches() throws IOException, ClassNotFoundException\n    {\n        System.out.println(\"getMatches\");\n\n        final String PLUGIN_INTERFACE = \"org.dspace.content.authority.ChoiceAuthority\";\n\n        // Ensure that 'id' attribute is optional\n        String field = null; // not used\n        String text = \"north 40\";\n        Collection collection = null;\n        int start = 0;\n        int limit = 0;\n        String locale = null;\n        // This \"farm\" Controlled Vocab is included in TestEnvironment data \n        // (under /src/test/data/dspaceFolder/) and it should be auto-loaded\n        // by test configs in /src/test/data/dspaceFolder/config/local.cfg\n        DSpaceControlledVocabulary instance = (DSpaceControlledVocabulary)\n                CoreServiceFactory.getInstance().getPluginService().getNamedPlugin(Class.forName(PLUGIN_INTERFACE), \"farm\");\n        assertNotNull(instance);\n        Choices result = instance.getMatches(field, text, collection, start,\n                limit, locale);\n        assertEquals(\"the farm::north 40\", result.values[0].value);\n    }", "signature": "void testGetMatches()", "full_signature": "@Test public void testGetMatches()", "class_method_signature": "DSpaceControlledVocabularyTest.testGetMatches()", "testcase": true, "constructor": false, "invocations": ["println", "getNamedPlugin", "getPluginService", "getInstance", "forName", "assertNotNull", "getMatches", "assertEquals"]}, "focal_class": {"identifier": "DSpaceControlledVocabulary", "superclass": "extends SelfNamedPlugin", "interfaces": "implements ChoiceAuthority", "fields": [{"original_string": "private static Logger log = Logger.getLogger(DSpaceControlledVocabulary.class);", "modifier": "private static", "type": "Logger", "declarator": "log = Logger.getLogger(DSpaceControlledVocabulary.class)", "var_name": "log"}, {"original_string": "protected static String xpathTemplate = \"//node[contains(translate(@label,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'%s')]\";", "modifier": "protected static", "type": "String", "declarator": "xpathTemplate = \"//node[contains(translate(@label,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'%s')]\"", "var_name": "xpathTemplate"}, {"original_string": "protected static String idTemplate = \"//node[@id = '%s']\";", "modifier": "protected static", "type": "String", "declarator": "idTemplate = \"//node[@id = '%s']\"", "var_name": "idTemplate"}, {"original_string": "protected static String pluginNames[] = null;", "modifier": "protected static", "type": "String", "declarator": "pluginNames[] = null", "var_name": "pluginNames"}, {"original_string": "protected String vocabularyName = null;", "modifier": "protected", "type": "String", "declarator": "vocabularyName = null", "var_name": "vocabularyName"}, {"original_string": "protected InputSource vocabulary = null;", "modifier": "protected", "type": "InputSource", "declarator": "vocabulary = null", "var_name": "vocabulary"}, {"original_string": "protected Boolean suggestHierarchy = true;", "modifier": "protected", "type": "Boolean", "declarator": "suggestHierarchy = true", "var_name": "suggestHierarchy"}, {"original_string": "protected Boolean storeHierarchy = true;", "modifier": "protected", "type": "Boolean", "declarator": "storeHierarchy = true", "var_name": "storeHierarchy"}, {"original_string": "protected String hierarchyDelimiter = \"::\";", "modifier": "protected", "type": "String", "declarator": "hierarchyDelimiter = \"::\"", "var_name": "hierarchyDelimiter"}], "methods": [{"identifier": "DSpaceControlledVocabulary", "parameters": "()", "modifiers": "public", "return": "", "signature": " DSpaceControlledVocabulary()", "full_signature": "public  DSpaceControlledVocabulary()", "class_method_signature": "DSpaceControlledVocabulary.DSpaceControlledVocabulary()", "testcase": false, "constructor": true}, {"identifier": "getPluginNames", "parameters": "()", "modifiers": "public static", "return": "String[]", "signature": "String[] getPluginNames()", "full_signature": "public static String[] getPluginNames()", "class_method_signature": "DSpaceControlledVocabulary.getPluginNames()", "testcase": false, "constructor": false}, {"identifier": "initPluginNames", "parameters": "()", "modifiers": "private static synchronized", "return": "void", "signature": "void initPluginNames()", "full_signature": "private static synchronized void initPluginNames()", "class_method_signature": "DSpaceControlledVocabulary.initPluginNames()", "testcase": false, "constructor": false}, {"identifier": "init", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void init()", "full_signature": "protected void init()", "class_method_signature": "DSpaceControlledVocabulary.init()", "testcase": false, "constructor": false}, {"identifier": "buildString", "parameters": "(Node node)", "modifiers": "protected", "return": "String", "signature": "String buildString(Node node)", "full_signature": "protected String buildString(Node node)", "class_method_signature": "DSpaceControlledVocabulary.buildString(Node node)", "testcase": false, "constructor": false}, {"identifier": "getMatches", "parameters": "(String field, String text, Collection collection, int start, int limit, String locale)", "modifiers": "@Override public", "return": "Choices", "signature": "Choices getMatches(String field, String text, Collection collection, int start, int limit, String locale)", "full_signature": "@Override public Choices getMatches(String field, String text, Collection collection, int start, int limit, String locale)", "class_method_signature": "DSpaceControlledVocabulary.getMatches(String field, String text, Collection collection, int start, int limit, String locale)", "testcase": false, "constructor": false}, {"identifier": "getBestMatch", "parameters": "(String field, String text, Collection collection, String locale)", "modifiers": "@Override public", "return": "Choices", "signature": "Choices getBestMatch(String field, String text, Collection collection, String locale)", "full_signature": "@Override public Choices getBestMatch(String field, String text, Collection collection, String locale)", "class_method_signature": "DSpaceControlledVocabulary.getBestMatch(String field, String text, Collection collection, String locale)", "testcase": false, "constructor": false}, {"identifier": "getLabel", "parameters": "(String field, String key, String locale)", "modifiers": "@Override public", "return": "String", "signature": "String getLabel(String field, String key, String locale)", "full_signature": "@Override public String getLabel(String field, String key, String locale)", "class_method_signature": "DSpaceControlledVocabulary.getLabel(String field, String key, String locale)", "testcase": false, "constructor": false}], "file": "dspace-api/src/main/java/org/dspace/content/authority/DSpaceControlledVocabulary.java"}, "focal_method": {"identifier": "getMatches", "parameters": "(String field, String text, Collection collection, int start, int limit, String locale)", "modifiers": "@Override public", "return": "Choices", "body": "@Override\n    public Choices getMatches(String field, String text, Collection collection, int start, int limit, String locale)\n    {\n    \tinit();\n    \tlog.debug(\"Getting matches for '\" + text + \"'\");\n        String xpathExpression = \"\";\n        String[] textHierarchy = text.split(hierarchyDelimiter, -1);\n        for (int i = 0; i < textHierarchy.length; i++) {\n            xpathExpression += String.format(xpathTemplate, textHierarchy[i].replaceAll(\"'\", \"&apos;\").toLowerCase());\n        }\n    \tXPath xpath = XPathFactory.newInstance().newXPath();\n    \tChoice[] choices;\n    \ttry {\n            NodeList results = (NodeList) xpath.evaluate(xpathExpression,\n                    vocabulary, XPathConstants.NODESET);\n            String[] authorities = new String[results.getLength()];\n            String[] values = new String[results.getLength()];\n            String[] labels = new String[results.getLength()];\n            for (int i = 0; i < results.getLength(); i++)\n            {\n                Node node = results.item(i);\n                String hierarchy = this.buildString(node);\n                if (this.suggestHierarchy)\n                {\n                    labels[i] = hierarchy;\n                }\n                else\n                {\n                    labels[i] = node.getAttributes().getNamedItem(\"label\").getNodeValue();\n                }\n                if (this.storeHierarchy)\n                {\n                    values[i] = hierarchy;\n                }\n                else\n                {\n                    values[i] = node.getAttributes().getNamedItem(\"label\").getNodeValue();\n                }\n                Node idAttr = node.getAttributes().getNamedItem(\"id\");\n                if (null != idAttr) // 'id' is optional\n                    authorities[i] = idAttr.getNodeValue();\n            }\n            int resultCount = labels.length - start;\n            if ((limit > 0) && (resultCount > limit)) // limit = 0 means no limit\n                resultCount = limit;\n            choices = new Choice[resultCount];\n            if (resultCount > 0)\n            {\n                for (int i = 0; i < resultCount; i++)\n                {\n                    choices[i] = new Choice(authorities[start + i], values[start\n                            + i], labels[start + i]);\n                }\n            }\n    \t} catch(XPathExpressionException e) {\n    \t\tchoices = new Choice[0];\n    \t}\n    \treturn new Choices(choices, 0, choices.length, Choices.CF_AMBIGUOUS, false);\n    }", "signature": "Choices getMatches(String field, String text, Collection collection, int start, int limit, String locale)", "full_signature": "@Override public Choices getMatches(String field, String text, Collection collection, int start, int limit, String locale)", "class_method_signature": "DSpaceControlledVocabulary.getMatches(String field, String text, Collection collection, int start, int limit, String locale)", "testcase": false, "constructor": false, "invocations": ["init", "debug", "split", "format", "toLowerCase", "replaceAll", "newXPath", "newInstance", "evaluate", "getLength", "getLength", "getLength", "getLength", "item", "buildString", "getNodeValue", "getNamedItem", "getAttributes", "getNodeValue", "getNamedItem", "getAttributes", "getNamedItem", "getAttributes", "getNodeValue"]}, "repository": {"repo_id": 39038703, "url": "https://github.com/VTUL/vtechworks", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 6, "size": 112021, "license": "licensed"}}