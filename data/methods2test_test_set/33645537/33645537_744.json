{"test_class": {"identifier": "SerializedObserverTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Mock\n    Subscriber<String> observer;", "modifier": "@Mock", "type": "Subscriber<String>", "declarator": "observer", "var_name": "observer"}], "file": "zava/src/test/java/rx/observers/SerializedObserverTest.java"}, "test_case": {"identifier": "runOutOfOrderConcurrencyTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void runOutOfOrderConcurrencyTest() {\n        ExecutorService tp = Executors.newFixedThreadPool(20);\n        try {\n            TestConcurrencyObserver tw = new TestConcurrencyObserver();\n            // we need Synchronized + SafeSubscriber to handle synchronization plus life-cycle\n            Observer<String> w = serializedObserver(new SafeSubscriber<String>(tw));\n\n            Future<?> f1 = tp.submit(new OnNextThread(w, 12000));\n            Future<?> f2 = tp.submit(new OnNextThread(w, 5000));\n            Future<?> f3 = tp.submit(new OnNextThread(w, 75000));\n            Future<?> f4 = tp.submit(new OnNextThread(w, 13500));\n            Future<?> f5 = tp.submit(new OnNextThread(w, 22000));\n            Future<?> f6 = tp.submit(new OnNextThread(w, 15000));\n            Future<?> f7 = tp.submit(new OnNextThread(w, 7500));\n            Future<?> f8 = tp.submit(new OnNextThread(w, 23500));\n\n            Future<?> f10 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onCompleted, f1, f2, f3, f4));\n            try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {\n                // ignore\n            }\n            Future<?> f11 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onCompleted, f4, f6, f7));\n            Future<?> f12 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onCompleted, f4, f6, f7));\n            Future<?> f13 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onCompleted, f4, f6, f7));\n            Future<?> f14 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onCompleted, f4, f6, f7));\n            // // the next 4 onError events should wait on same as f10\n            Future<?> f15 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onError, f1, f2, f3, f4));\n            Future<?> f16 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onError, f1, f2, f3, f4));\n            Future<?> f17 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onError, f1, f2, f3, f4));\n            Future<?> f18 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onError, f1, f2, f3, f4));\n\n            waitOnThreads(f1, f2, f3, f4, f5, f6, f7, f8, f10, f11, f12, f13, f14, f15, f16, f17, f18);\n            @SuppressWarnings(\"unused\")\n            int numNextEvents = tw.assertEvents(null); // no check of type since we don't want to test barging results here, just interleaving behavior\n            //            System.out.println(\"Number of events executed: \" + numNextEvents);\n        } catch (Throwable e) {\n            fail(\"Concurrency test failed: \" + e.getMessage());\n            e.printStackTrace();\n        } finally {\n            tp.shutdown();\n            try {\n                tp.awaitTermination(5000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }", "signature": "void runOutOfOrderConcurrencyTest()", "full_signature": "@Test public void runOutOfOrderConcurrencyTest()", "class_method_signature": "SerializedObserverTest.runOutOfOrderConcurrencyTest()", "testcase": true, "constructor": false, "invocations": ["newFixedThreadPool", "serializedObserver", "submit", "submit", "submit", "submit", "submit", "submit", "submit", "submit", "submit", "sleep", "submit", "submit", "submit", "submit", "submit", "submit", "submit", "submit", "waitOnThreads", "assertEvents", "fail", "getMessage", "printStackTrace", "shutdown", "awaitTermination", "printStackTrace"]}, "focal_class": {"identifier": "SerializedObserver", "superclass": "", "interfaces": "implements Observer<T>", "fields": [{"original_string": "private final Observer<? super T> actual;", "modifier": "private final", "type": "Observer<? super T>", "declarator": "actual", "var_name": "actual"}, {"original_string": "private boolean emitting = false;", "modifier": "private", "type": "boolean", "declarator": "emitting = false", "var_name": "emitting"}, {"original_string": "private boolean terminated = false;", "modifier": "private", "type": "boolean", "declarator": "terminated = false", "var_name": "terminated"}, {"original_string": "private FastList queue;", "modifier": "private", "type": "FastList", "declarator": "queue", "var_name": "queue"}, {"original_string": "private static final int MAX_DRAIN_ITERATION = Integer.MAX_VALUE;", "modifier": "private static final", "type": "int", "declarator": "MAX_DRAIN_ITERATION = Integer.MAX_VALUE", "var_name": "MAX_DRAIN_ITERATION"}, {"original_string": "private static final Object NULL_SENTINEL = new Object();", "modifier": "private static final", "type": "Object", "declarator": "NULL_SENTINEL = new Object()", "var_name": "NULL_SENTINEL"}, {"original_string": "private static final Object COMPLETE_SENTINEL = new Object();", "modifier": "private static final", "type": "Object", "declarator": "COMPLETE_SENTINEL = new Object()", "var_name": "COMPLETE_SENTINEL"}], "methods": [{"identifier": "SerializedObserver", "parameters": "(Observer<? super T> s)", "modifiers": "public", "return": "", "signature": " SerializedObserver(Observer<? super T> s)", "full_signature": "public  SerializedObserver(Observer<? super T> s)", "class_method_signature": "SerializedObserver.SerializedObserver(Observer<? super T> s)", "testcase": false, "constructor": true}, {"identifier": "onCompleted", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void onCompleted()", "full_signature": "@Override public void onCompleted()", "class_method_signature": "SerializedObserver.onCompleted()", "testcase": false, "constructor": false}, {"identifier": "onError", "parameters": "(final Throwable e)", "modifiers": "@Override public", "return": "void", "signature": "void onError(final Throwable e)", "full_signature": "@Override public void onError(final Throwable e)", "class_method_signature": "SerializedObserver.onError(final Throwable e)", "testcase": false, "constructor": false}, {"identifier": "onNext", "parameters": "(T t)", "modifiers": "@Override public", "return": "void", "signature": "void onNext(T t)", "full_signature": "@Override public void onNext(T t)", "class_method_signature": "SerializedObserver.onNext(T t)", "testcase": false, "constructor": false}, {"identifier": "drainQueue", "parameters": "(FastList list)", "modifiers": "", "return": "void", "signature": "void drainQueue(FastList list)", "full_signature": " void drainQueue(FastList list)", "class_method_signature": "SerializedObserver.drainQueue(FastList list)", "testcase": false, "constructor": false}], "file": "zava/src/main/java/rx/observers/SerializedObserver.java"}, "focal_method": {"identifier": "SerializedObserver", "parameters": "(Observer<? super T> s)", "modifiers": "public", "return": "", "body": "public SerializedObserver(Observer<? super T> s) {\n        this.actual = s;\n    }", "signature": " SerializedObserver(Observer<? super T> s)", "full_signature": "public  SerializedObserver(Observer<? super T> s)", "class_method_signature": "SerializedObserver.SerializedObserver(Observer<? super T> s)", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 33645537, "url": "https://github.com/zqhxuyuan/tutorials", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 5, "size": 35273, "license": "licensed"}}