{"test_class": {"identifier": "LRSSegmentProcessTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private DataStore featureSource;", "modifier": "private", "type": "DataStore", "declarator": "featureSource", "var_name": "featureSource"}], "file": "modules/unsupported/process-feature/src/test/java/org/geotools/process/vector/LRSSegmentProcessTest.java"}, "test_case": {"identifier": "testBadParamToLrs", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testBadParamToLrs() throws Exception {\n        SimpleFeatureSource source = featureSource.getFeatureSource(\"lrssimple\");\n        LRSSegmentProcess process = new LRSSegmentProcess();\n        SimpleFeatureCollection origional = source.getFeatures();\n\n        try {\n            FeatureCollection result = process.execute(origional, \"from_lrs\", \"to_lrs_bad\", 1.0,\n                    2.0);\n            Assert.fail(\"Expected error from bad to_lrs name\");\n        } catch (ProcessException e) {\n            // Successful\n        }\n    }", "signature": "void testBadParamToLrs()", "full_signature": "@Test public void testBadParamToLrs()", "class_method_signature": "LRSSegmentProcessTest.testBadParamToLrs()", "testcase": true, "constructor": false, "invocations": ["getFeatureSource", "getFeatures", "execute", "fail"]}, "focal_class": {"identifier": "LRSSegmentProcess", "superclass": "", "interfaces": "implements VectorProcess", "fields": [{"original_string": "private static final Logger LOGGER = Logging.getLogger(LRSSegmentProcess.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = Logging.getLogger(LRSSegmentProcess.class)", "var_name": "LOGGER"}, {"original_string": "private final GeometryFactory geometryFactory = new GeometryFactory();", "modifier": "private final", "type": "GeometryFactory", "declarator": "geometryFactory = new GeometryFactory()", "var_name": "geometryFactory"}], "methods": [{"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"from_measure\", description = \"Measure for start of segment to extract\") Double fromMeasure,\n            @DescribeParameter(name = \"to_measure\", description = \"Measure for end of segment to extract\") Double toMeasure)", "modifiers": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public", "return": "FeatureCollection", "signature": "FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"from_measure\", description = \"Measure for start of segment to extract\") Double fromMeasure,\n            @DescribeParameter(name = \"to_measure\", description = \"Measure for end of segment to extract\") Double toMeasure)", "full_signature": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"from_measure\", description = \"Measure for start of segment to extract\") Double fromMeasure,\n            @DescribeParameter(name = \"to_measure\", description = \"Measure for end of segment to extract\") Double toMeasure)", "class_method_signature": "LRSSegmentProcess.execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"from_measure\", description = \"Measure for start of segment to extract\") Double fromMeasure,\n            @DescribeParameter(name = \"to_measure\", description = \"Measure for end of segment to extract\") Double toMeasure)", "testcase": false, "constructor": false}, {"identifier": "createTargetFeature", "parameters": "(Feature feature, SimpleFeatureType targetFeatureType,\n            MultiLineString multiLineString)", "modifiers": "private", "return": "SimpleFeature", "signature": "SimpleFeature createTargetFeature(Feature feature, SimpleFeatureType targetFeatureType,\n            MultiLineString multiLineString)", "full_signature": "private SimpleFeature createTargetFeature(Feature feature, SimpleFeatureType targetFeatureType,\n            MultiLineString multiLineString)", "class_method_signature": "LRSSegmentProcess.createTargetFeature(Feature feature, SimpleFeatureType targetFeatureType,\n            MultiLineString multiLineString)", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/LRSSegmentProcess.java"}, "focal_method": {"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"from_measure\", description = \"Measure for start of segment to extract\") Double fromMeasure,\n            @DescribeParameter(name = \"to_measure\", description = \"Measure for end of segment to extract\") Double toMeasure)", "modifiers": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public", "return": "FeatureCollection", "body": "@DescribeResult(name = \"result\", description = \"Output feature collection\")\n    public FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"from_measure\", description = \"Measure for start of segment to extract\") Double fromMeasure,\n            @DescribeParameter(name = \"to_measure\", description = \"Measure for end of segment to extract\") Double toMeasure)\n            throws ProcessException {\n        DefaultFeatureCollection results = new DefaultFeatureCollection();\n        try {\n            if (featureCollection == null || featureCollection.size() == 0) {\n                LOGGER.info(\"No features provided in request\");\n                return results;\n            }\n            if (fromMeasureAttb == null\n                    || featureCollection.getSchema().getDescriptor(fromMeasureAttb) == null) {\n                throw new ProcessException(\n                        \"The from_measure_attb parameter was not provided or not defined in schema\");\n            }\n            if (toMeasureAttb == null\n                    || featureCollection.getSchema().getDescriptor(toMeasureAttb) == null) {\n                throw new ProcessException(\"The to_measure_attb parameter was not provided\");\n            }\n            if (fromMeasure == null) {\n                throw new ProcessException(\"The from_measure parameter was not provided\");\n            }\n            if (toMeasure == null) {\n                throw new ProcessException(\"The to_measure parameter was not provided\");\n            }\n            if (fromMeasure.doubleValue() == toMeasure.doubleValue()) {\n                LOGGER.info(\"Zero length segment requested\");\n                return results;\n            }\n\n            FeatureIterator<Feature> featureIterator = null;\n            Feature firstFeature = null;\n            try {\n                LineMerger lineMerger = new LineMerger();\n                if (toMeasure.doubleValue() > fromMeasure.doubleValue()) {\n                    featureIterator = featureCollection.features();\n                    while (featureIterator.hasNext()) {\n                        Feature feature = featureIterator.next();\n                        if (firstFeature == null)\n                            firstFeature = feature;\n                        Double featureFromMeasure = (Double) feature.getProperty(fromMeasureAttb)\n                                .getValue();\n                        Double featureToMeasure = (Double) feature.getProperty(toMeasureAttb)\n                                .getValue();\n\n                        if (fromMeasure < featureToMeasure && toMeasure > featureFromMeasure) {\n                            try {\n                                if (fromMeasure <= featureFromMeasure\n                                        && toMeasure >= featureToMeasure) {\n                                    lineMerger.add((Geometry) feature.getDefaultGeometryProperty()\n                                            .getValue());\n                                } else if (fromMeasure > featureFromMeasure\n                                        && toMeasure < featureToMeasure) {\n                                    LengthIndexedLine lengthIndexedLine = new LengthIndexedLine(\n                                            (Geometry) feature.getDefaultGeometryProperty()\n                                                    .getValue());\n                                    double featureLength = featureToMeasure - featureFromMeasure;\n                                    double startOffset = fromMeasure - featureFromMeasure;\n                                    double stopOffset = toMeasure - featureFromMeasure;\n                                    double calcLength = ((Geometry) feature\n                                            .getDefaultGeometryProperty().getValue()).getLength();\n                                    if (calcLength == 0 || featureLength == 0)\n                                        continue;\n                                    Geometry extracted = lengthIndexedLine.extractLine(startOffset\n                                            * calcLength / featureLength, stopOffset * calcLength\n                                            / featureLength);\n                                    if (!extracted.isEmpty())\n                                        lineMerger.add(extracted);\n                                } else if (fromMeasure > featureFromMeasure) {\n                                    LengthIndexedLine lengthIndexedLine = new LengthIndexedLine(\n                                            (Geometry) feature.getDefaultGeometryProperty()\n                                                    .getValue());\n                                    double featureLength = featureToMeasure - featureFromMeasure;\n                                    double startOffset = fromMeasure - featureFromMeasure;\n                                    double calcLength = ((Geometry) feature\n                                            .getDefaultGeometryProperty().getValue()).getLength();\n                                    if (calcLength == 0 || featureLength == 0)\n                                        continue;\n                                    Geometry extracted = lengthIndexedLine.extractLine(startOffset\n                                            * calcLength / featureLength, calcLength);\n                                    if (!extracted.isEmpty())\n                                        lineMerger.add(extracted);\n                                } else {\n                                    LengthIndexedLine lengthIndexedLine = new LengthIndexedLine(\n                                            (Geometry) feature.getDefaultGeometryProperty()\n                                                    .getValue());\n                                    double featureLength = featureToMeasure - featureFromMeasure;\n                                    double stopOffset = toMeasure - featureFromMeasure;\n                                    double calcLength = ((Geometry) feature\n                                            .getDefaultGeometryProperty().getValue()).getLength();\n                                    if (calcLength == 0 || featureLength == 0)\n                                        continue;\n                                    Geometry extracted = lengthIndexedLine.extractLine(0,\n                                            stopOffset * calcLength / featureLength);\n                                    if (extracted.isEmpty() || extracted.getLength() == 0.0) {\n                                        LOGGER.info(\"Empty segment: featureFromMeasure=\"\n                                                + featureFromMeasure + \" featureToMeasure:\"\n                                                + featureToMeasure + \" toMeasure:\" + toMeasure\n                                                + \" fromMeasure:\" + fromMeasure);\n                                    } else {\n                                        lineMerger.add(extracted);\n                                    }\n                                }\n                            } catch (Exception e) {\n                                LOGGER.warning(\"Error merging line strings: \" + e\n                                        + \" featureFromMeasure=\" + featureFromMeasure\n                                        + \" featureToMeasure:\" + featureToMeasure + \" toMeasure:\"\n                                        + toMeasure + \" fromMeasure:\" + fromMeasure);\n                            }\n                        }\n                    }\n                    results.add(createTargetFeature(firstFeature, (SimpleFeatureType) firstFeature\n                            .getType(), new MultiLineString((LineString[]) lineMerger\n                            .getMergedLineStrings().toArray(new LineString[0]), geometryFactory)));\n                }\n            } finally {\n                if (featureIterator != null)\n                    featureIterator.close();\n            }\n            return results;\n        } catch (ProcessException e) {\n            throw e;\n        } catch (Throwable e) {\n            LOGGER.warning(\"Error executing method: \" + e);\n            throw new ProcessException(\"Error executing method: \" + e, e);\n        }\n    }", "signature": "FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"from_measure\", description = \"Measure for start of segment to extract\") Double fromMeasure,\n            @DescribeParameter(name = \"to_measure\", description = \"Measure for end of segment to extract\") Double toMeasure)", "full_signature": "@DescribeResult(name = \"result\", description = \"Output feature collection\") public FeatureCollection execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"from_measure\", description = \"Measure for start of segment to extract\") Double fromMeasure,\n            @DescribeParameter(name = \"to_measure\", description = \"Measure for end of segment to extract\") Double toMeasure)", "class_method_signature": "LRSSegmentProcess.execute(\n            @DescribeParameter(name = \"features\", description = \"Input feature collection\") FeatureCollection featureCollection,\n            @DescribeParameter(name = \"from_measure_attb\", description = \"Attribute providing start measure of feature\") String fromMeasureAttb,\n            @DescribeParameter(name = \"to_measure_attb\", description = \"Attribute providing end measure of feature\") String toMeasureAttb,\n            @DescribeParameter(name = \"from_measure\", description = \"Measure for start of segment to extract\") Double fromMeasure,\n            @DescribeParameter(name = \"to_measure\", description = \"Measure for end of segment to extract\") Double toMeasure)", "testcase": false, "constructor": false, "invocations": ["size", "info", "getDescriptor", "getSchema", "getDescriptor", "getSchema", "doubleValue", "doubleValue", "info", "doubleValue", "doubleValue", "features", "hasNext", "next", "getValue", "getProperty", "getValue", "getProperty", "add", "getValue", "getDefaultGeometryProperty", "getValue", "getDefaultGeometryProperty", "getLength", "getValue", "getDefaultGeometryProperty", "extractLine", "isEmpty", "add", "getValue", "getDefaultGeometryProperty", "getLength", "getValue", "getDefaultGeometryProperty", "extractLine", "isEmpty", "add", "getValue", "getDefaultGeometryProperty", "getLength", "getValue", "getDefaultGeometryProperty", "extractLine", "isEmpty", "getLength", "info", "add", "warning", "add", "createTargetFeature", "getType", "toArray", "getMergedLineStrings", "close", "warning"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}