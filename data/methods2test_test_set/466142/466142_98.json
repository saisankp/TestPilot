{"test_class": {"identifier": "TestPoolWatchThread", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ConnectionPartition mockPartition;", "modifier": "private", "type": "ConnectionPartition", "declarator": "mockPartition", "var_name": "mockPartition"}, {"original_string": "private BoneCP mockPool;", "modifier": "private", "type": "BoneCP", "declarator": "mockPool", "var_name": "mockPool"}, {"original_string": "static PoolWatchThread testClass;", "modifier": "static", "type": "PoolWatchThread", "declarator": "testClass", "var_name": "testClass"}, {"original_string": "private Logger mockLogger;", "modifier": "private", "type": "Logger", "declarator": "mockLogger", "var_name": "mockLogger"}, {"original_string": "static boolean first = true;", "modifier": "static", "type": "boolean", "declarator": "first = true", "var_name": "first"}, {"original_string": "private BoneCPConfig mockConfig;", "modifier": "private", "type": "BoneCPConfig", "declarator": "mockConfig", "var_name": "mockConfig"}, {"original_string": "private MockJDBCDriver driver;", "modifier": "private", "type": "MockJDBCDriver", "declarator": "driver", "var_name": "driver"}], "file": "bonecp/src/test/java/com/jolbox/bonecp/TestPoolWatchThread.java"}, "test_case": {"identifier": "testRunLazyInit", "parameters": "()", "modifiers": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) @Test public", "return": "void", "body": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\t@Test\n\tpublic void testRunLazyInit() throws InterruptedException{\n\t\tBlockingQueue<Object> bq = new ArrayBlockingQueue<Object>(1);\n\t\tbq.add(new Object());\n\t\texpect(mockPartition.getPoolWatchThreadSignalQueue()).andReturn(bq);\n\t\texpect(mockPartition.getMaxConnections()).andReturn(5).once();\n\t\texpect(mockPartition.getCreatedConnections()).andReturn(5).once();\n\n\t\tmockPartition.setUnableToCreateMoreTransactions(true);\n\t\texpectLastCall().once();\n\n\t\t// just to break out of the loop\n\t\tBlockingQueue<?> mockQueue = EasyMock.createNiceMock(BlockingQueue.class);\n\t\texpect(mockPartition.getPoolWatchThreadSignalQueue()).andReturn((BlockingQueue) mockQueue);\n\t\texpect(mockQueue.take()).andThrow(new InterruptedException());\n\n\t\treplay(mockPartition, mockPool, mockLogger, mockQueue);\n\t\ttestClass.lazyInit = true;\n\t\ttestClass.run();\n\t\tEasyMock.verify(mockPartition);\n\n\n\t}", "signature": "void testRunLazyInit()", "full_signature": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) @Test public void testRunLazyInit()", "class_method_signature": "TestPoolWatchThread.testRunLazyInit()", "testcase": true, "constructor": false, "invocations": ["add", "andReturn", "expect", "getPoolWatchThreadSignalQueue", "once", "andReturn", "expect", "getMaxConnections", "once", "andReturn", "expect", "getCreatedConnections", "setUnableToCreateMoreTransactions", "once", "expectLastCall", "createNiceMock", "andReturn", "expect", "getPoolWatchThreadSignalQueue", "andThrow", "expect", "take", "replay", "run", "verify"]}, "focal_class": {"identifier": "PoolWatchThread", "superclass": "", "interfaces": "implements Runnable", "fields": [{"original_string": "private ConnectionPartition partition;", "modifier": "private", "type": "ConnectionPartition", "declarator": "partition", "var_name": "partition"}, {"original_string": "private BoneCP pool;", "modifier": "private", "type": "BoneCP", "declarator": "pool", "var_name": "pool"}, {"original_string": "private boolean signalled;", "modifier": "private", "type": "boolean", "declarator": "signalled", "var_name": "signalled"}, {"original_string": "private long acquireRetryDelayInMs = 1000L;", "modifier": "private", "type": "long", "declarator": "acquireRetryDelayInMs = 1000L", "var_name": "acquireRetryDelayInMs"}, {"original_string": "protected boolean lazyInit;", "modifier": "protected", "type": "boolean", "declarator": "lazyInit", "var_name": "lazyInit"}, {"original_string": "private int poolAvailabilityThreshold;", "modifier": "private", "type": "int", "declarator": "poolAvailabilityThreshold", "var_name": "poolAvailabilityThreshold"}, {"original_string": "private static final Logger logger = LoggerFactory.getLogger(PoolWatchThread.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(PoolWatchThread.class)", "var_name": "logger"}], "methods": [{"identifier": "PoolWatchThread", "parameters": "(ConnectionPartition connectionPartition, BoneCP pool)", "modifiers": "public", "return": "", "signature": " PoolWatchThread(ConnectionPartition connectionPartition, BoneCP pool)", "full_signature": "public  PoolWatchThread(ConnectionPartition connectionPartition, BoneCP pool)", "class_method_signature": "PoolWatchThread.PoolWatchThread(ConnectionPartition connectionPartition, BoneCP pool)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void run()", "full_signature": "public void run()", "class_method_signature": "PoolWatchThread.run()", "testcase": false, "constructor": false}, {"identifier": "fillConnections", "parameters": "(int connectionsToCreate)", "modifiers": "private", "return": "void", "signature": "void fillConnections(int connectionsToCreate)", "full_signature": "private void fillConnections(int connectionsToCreate)", "class_method_signature": "PoolWatchThread.fillConnections(int connectionsToCreate)", "testcase": false, "constructor": false}], "file": "bonecp/src/main/java/com/jolbox/bonecp/PoolWatchThread.java"}, "focal_method": {"identifier": "run", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void run() {\n\t\tint maxNewConnections;\n\t\twhile (!this.signalled){\n\t\t\tmaxNewConnections=0;\n\n\t\t\ttry{\n\t\t\t\tif (this.lazyInit){ // block the first time if this is on.\n\t\t\t\t\tthis.partition.getPoolWatchThreadSignalQueue().take();\n\t\t\t\t}\n \n\n\t\t\t\tmaxNewConnections = this.partition.getMaxConnections()-this.partition.getCreatedConnections();\n\t\t\t\t// loop for spurious interrupt\n\t\t\t\twhile (maxNewConnections == 0 || (this.partition.getAvailableConnections() *100/this.partition.getMaxConnections() > this.poolAvailabilityThreshold)){\n\t\t\t\t\tif (maxNewConnections == 0){\n\t\t\t\t\t\tthis.partition.setUnableToCreateMoreTransactions(true);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.partition.getPoolWatchThreadSignalQueue().take();\n\t\t\t\t\tmaxNewConnections = this.partition.getMaxConnections()-this.partition.getCreatedConnections();\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tif (maxNewConnections > 0 \n\t\t\t\t\t\t&& !this.pool.poolShuttingDown){\n\t\t\t\t\tfillConnections(Math.min(maxNewConnections, this.partition.getAcquireIncrement()));\n\t\t\t\t\t// for the case where we have killed off all our connections due to network/db error\n\t\t\t\t\tif (this.partition.getCreatedConnections() < this.partition.getMinConnections()){\n\t\t\t\t\t\tfillConnections(this.partition.getMinConnections() - this.partition.getCreatedConnections() );\n\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.pool.poolShuttingDown){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlogger.debug(\"Terminating pool watch thread\");\n\t\t\t\treturn; // we've been asked to terminate.\n\t\t\t}\n\t\t}\n\t}", "signature": "void run()", "full_signature": "public void run()", "class_method_signature": "PoolWatchThread.run()", "testcase": false, "constructor": false, "invocations": ["take", "getPoolWatchThreadSignalQueue", "getMaxConnections", "getCreatedConnections", "getAvailableConnections", "getMaxConnections", "setUnableToCreateMoreTransactions", "take", "getPoolWatchThreadSignalQueue", "getMaxConnections", "getCreatedConnections", "fillConnections", "min", "getAcquireIncrement", "getCreatedConnections", "getMinConnections", "fillConnections", "getMinConnections", "getCreatedConnections", "debug"]}, "repository": {"repo_id": 466142, "url": "https://github.com/wwadge/bonecp", "language": "Java", "is_fork": false, "fork_count": 161, "stargazer_count": 544, "size": 3833, "license": "licensed"}}