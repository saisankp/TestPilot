{"test_class": {"identifier": "TestLogLog", "superclass": "", "interfaces": "", "fields": [], "file": "ml/streaminer/src/test/java/org/streaminer/stream/cardinality/TestLogLog.java"}, "test_case": {"identifier": "testMerge", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMerge() throws CardinalityMergeException\n    {\n        int numToMerge = 5;\n        int bits = 16;\n        int cardinality = 1000000;\n\n        LogLog[] loglogs = new LogLog[numToMerge];\n        LogLog baseline = new LogLog(bits);\n        for (int i = 0; i < numToMerge; i++)\n        {\n            loglogs[i] = new LogLog(bits);\n            for (int j = 0; j < cardinality; j++)\n            {\n                double val = Math.random();\n                loglogs[i].offer(val);\n                baseline.offer(val);\n            }\n        }\n\n\n        LogLog hll = loglogs[0];\n        loglogs = Arrays.asList(loglogs).subList(1, loglogs.length).toArray(new LogLog[0]);\n        long mergedEstimate = hll.merge(loglogs).cardinality();\n        long baselineEstimate = baseline.cardinality();\n\n        System.out.println(\"Baseline estimate: \" + baselineEstimate);\n\n        assertEquals(mergedEstimate, baselineEstimate);\n    }", "signature": "void testMerge()", "full_signature": "@Test public void testMerge()", "class_method_signature": "TestLogLog.testMerge()", "testcase": true, "constructor": false, "invocations": ["random", "offer", "offer", "toArray", "subList", "asList", "cardinality", "merge", "cardinality", "println", "assertEquals"]}, "focal_class": {"identifier": "LogLog", "superclass": "", "interfaces": "implements IRichCardinality", "fields": [{"original_string": "protected static final double[] mAlpha = {\n            0,\n            0.44567926005415,\n            1.2480639342271,\n            2.8391255240079,\n            6.0165231584811,\n            12.369319965552,\n            25.073991603109,\n            50.482891762521,\n            101.30047482549,\n            202.93553337953,\n            406.20559693552,\n            812.74569741657,\n            1625.8258887309,\n            3251.9862249084,\n            6504.3071471860,\n            13008.949929672,\n            26018.222470181,\n            52036.684135280,\n            104073.41696276,\n            208139.24771523,\n            416265.57100022,\n            832478.53851627,\n            1669443.2499579,\n            3356902.8702907,\n            6863377.8429508,\n            11978069.823687,\n            31333767.455026,\n            52114301.457757,\n            72080129.928986,\n            68945006.880409,\n            31538957.552704,\n            3299942.4347441\n    };", "modifier": "protected static final", "type": "double[]", "declarator": "mAlpha = {\n            0,\n            0.44567926005415,\n            1.2480639342271,\n            2.8391255240079,\n            6.0165231584811,\n            12.369319965552,\n            25.073991603109,\n            50.482891762521,\n            101.30047482549,\n            202.93553337953,\n            406.20559693552,\n            812.74569741657,\n            1625.8258887309,\n            3251.9862249084,\n            6504.3071471860,\n            13008.949929672,\n            26018.222470181,\n            52036.684135280,\n            104073.41696276,\n            208139.24771523,\n            416265.57100022,\n            832478.53851627,\n            1669443.2499579,\n            3356902.8702907,\n            6863377.8429508,\n            11978069.823687,\n            31333767.455026,\n            52114301.457757,\n            72080129.928986,\n            68945006.880409,\n            31538957.552704,\n            3299942.4347441\n    }", "var_name": "mAlpha"}, {"original_string": "protected final int k;", "modifier": "protected final", "type": "int", "declarator": "k", "var_name": "k"}, {"original_string": "protected int m;", "modifier": "protected", "type": "int", "declarator": "m", "var_name": "m"}, {"original_string": "protected double Ca;", "modifier": "protected", "type": "double", "declarator": "Ca", "var_name": "Ca"}, {"original_string": "protected byte[] M;", "modifier": "protected", "type": "byte[]", "declarator": "M", "var_name": "M"}, {"original_string": "protected int Rsum = 0;", "modifier": "protected", "type": "int", "declarator": "Rsum = 0", "var_name": "Rsum"}], "methods": [{"identifier": "LogLog", "parameters": "(int k)", "modifiers": "public", "return": "", "signature": " LogLog(int k)", "full_signature": "public  LogLog(int k)", "class_method_signature": "LogLog.LogLog(int k)", "testcase": false, "constructor": true}, {"identifier": "LogLog", "parameters": "(byte[] M)", "modifiers": "public", "return": "", "signature": " LogLog(byte[] M)", "full_signature": "public  LogLog(byte[] M)", "class_method_signature": "LogLog.LogLog(byte[] M)", "testcase": false, "constructor": true}, {"identifier": "getBytes", "parameters": "()", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] getBytes()", "full_signature": "@Override public byte[] getBytes()", "class_method_signature": "LogLog.getBytes()", "testcase": false, "constructor": false}, {"identifier": "sizeof", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int sizeof()", "full_signature": "public int sizeof()", "class_method_signature": "LogLog.sizeof()", "testcase": false, "constructor": false}, {"identifier": "cardinality", "parameters": "()", "modifiers": "@Override public", "return": "long", "signature": "long cardinality()", "full_signature": "@Override public long cardinality()", "class_method_signature": "LogLog.cardinality()", "testcase": false, "constructor": false}, {"identifier": "offerHashed", "parameters": "(long hashedLong)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean offerHashed(long hashedLong)", "full_signature": "@Override public boolean offerHashed(long hashedLong)", "class_method_signature": "LogLog.offerHashed(long hashedLong)", "testcase": false, "constructor": false}, {"identifier": "offerHashed", "parameters": "(int hashedInt)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean offerHashed(int hashedInt)", "full_signature": "@Override public boolean offerHashed(int hashedInt)", "class_method_signature": "LogLog.offerHashed(int hashedInt)", "testcase": false, "constructor": false}, {"identifier": "offer", "parameters": "(Object o)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean offer(Object o)", "full_signature": "@Override public boolean offer(Object o)", "class_method_signature": "LogLog.offer(Object o)", "testcase": false, "constructor": false}, {"identifier": "rho", "parameters": "(int x, int k)", "modifiers": "protected static", "return": "int", "signature": "int rho(int x, int k)", "full_signature": "protected static int rho(int x, int k)", "class_method_signature": "LogLog.rho(int x, int k)", "testcase": false, "constructor": false}, {"identifier": "merge", "parameters": "(IRichCardinality... estimators)", "modifiers": "@Override public", "return": "IRichCardinality", "signature": "IRichCardinality merge(IRichCardinality... estimators)", "full_signature": "@Override public IRichCardinality merge(IRichCardinality... estimators)", "class_method_signature": "LogLog.merge(IRichCardinality... estimators)", "testcase": false, "constructor": false}, {"identifier": "mergeEstimators", "parameters": "(LogLog... estimators)", "modifiers": "public static", "return": "LogLog", "signature": "LogLog mergeEstimators(LogLog... estimators)", "full_signature": "public static LogLog mergeEstimators(LogLog... estimators)", "class_method_signature": "LogLog.mergeEstimators(LogLog... estimators)", "testcase": false, "constructor": false}], "file": "ml/streaminer/src/main/java/org/streaminer/stream/cardinality/LogLog.java"}, "focal_method": {"identifier": "merge", "parameters": "(IRichCardinality... estimators)", "modifiers": "@Override public", "return": "IRichCardinality", "body": "@Override\n    public IRichCardinality merge(IRichCardinality... estimators) throws LogLogMergeException\n    {\n        if (estimators == null)\n        {\n            return new LogLog(M);\n        }\n        \n        byte[] mergedBytes = Arrays.copyOf(this.M, this.M.length);\n        for (IRichCardinality estimator : estimators)\n        {\n            if (!(this.getClass().isInstance(estimator)))\n            {\n                throw new LogLogMergeException(\"Cannot merge estimators of different class\");\n            }\n            if (estimator.sizeof() != this.sizeof())\n            {\n                throw new LogLogMergeException(\"Cannot merge estimators of different sizes\");\n            }\n            LogLog ll = (LogLog) estimator;\n            for (int i = 0; i < mergedBytes.length; ++i)\n            {\n                mergedBytes[i] = (byte) Math.max(mergedBytes[i], ll.M[i]);\n            }\n        }\n\n        return new LogLog(mergedBytes);\n    }", "signature": "IRichCardinality merge(IRichCardinality... estimators)", "full_signature": "@Override public IRichCardinality merge(IRichCardinality... estimators)", "class_method_signature": "LogLog.merge(IRichCardinality... estimators)", "testcase": false, "constructor": false, "invocations": ["copyOf", "isInstance", "getClass", "sizeof", "sizeof", "max"]}, "repository": {"repo_id": 44512524, "url": "https://github.com/zqhxuyuan/bigdata", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 8, "size": 91550, "license": "licensed"}}