{"test_class": {"identifier": "FEELParserTest", "superclass": "", "interfaces": "", "fields": [], "file": "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/parser/feel11/FEELParserTest.java"}, "test_case": {"identifier": "testInstanceOfExpressionAnd", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testInstanceOfExpressionAnd() {\n        String inputExpression = \"\\\"foo\\\" instance of string and 10 instance of number\";\n        BaseNode andExpr = parse( inputExpression );\n\n        assertThat( andExpr, is( instanceOf( InfixOpNode.class ) ) );\n        assertThat( andExpr.getText(), is( inputExpression ) );\n        assertThat( andExpr.getResultType(), is( BuiltInType.BOOLEAN ) );\n\n        InfixOpNode and = (InfixOpNode) andExpr;\n        assertThat( and.getOperator(), is( InfixOpNode.InfixOperator.AND ) );\n        assertThat( and.getLeft(), is( instanceOf( InstanceOfNode.class ) ) );\n        assertThat( and.getRight(), is( instanceOf( InstanceOfNode.class ) ) );\n        assertThat( and.getLeft().getText(), is( \"\\\"foo\\\" instance of string\" ) );\n        assertThat( and.getRight().getText(), is( \"10 instance of number\" ) );\n        assertThat( and.getLeft().getResultType(), is( BuiltInType.BOOLEAN ) );\n        assertThat( and.getRight().getResultType(), is( BuiltInType.BOOLEAN ) );\n\n        InstanceOfNode ioExpr = (InstanceOfNode) and.getLeft();\n        assertThat( ioExpr.getExpression(), is( instanceOf( StringNode.class ) ) );\n        assertThat( ioExpr.getExpression().getText(), is( \"\\\"foo\\\"\" ) );\n        assertThat( ioExpr.getType(), is( instanceOf( TypeNode.class ) ) );\n        assertThat( ioExpr.getType().getText(), is( \"string\" ) );\n\n        ioExpr = (InstanceOfNode) and.getRight();\n        assertThat( ioExpr.getExpression(), is( instanceOf( NumberNode.class ) ) );\n        assertThat( ioExpr.getExpression().getText(), is( \"10\" ) );\n        assertThat( ioExpr.getType(), is( instanceOf( TypeNode.class ) ) );\n        assertThat( ioExpr.getType().getText(), is( \"number\" ) );\n    }", "signature": "void testInstanceOfExpressionAnd()", "full_signature": "@Test public void testInstanceOfExpressionAnd()", "class_method_signature": "FEELParserTest.testInstanceOfExpressionAnd()", "testcase": true, "constructor": false, "invocations": ["parse", "assertThat", "is", "instanceOf", "assertThat", "getText", "is", "assertThat", "getResultType", "is", "assertThat", "getOperator", "is", "assertThat", "getLeft", "is", "instanceOf", "assertThat", "getRight", "is", "instanceOf", "assertThat", "getText", "getLeft", "is", "assertThat", "getText", "getRight", "is", "assertThat", "getResultType", "getLeft", "is", "assertThat", "getResultType", "getRight", "is", "getLeft", "assertThat", "getExpression", "is", "instanceOf", "assertThat", "getText", "getExpression", "is", "assertThat", "getType", "is", "instanceOf", "assertThat", "getText", "getType", "is", "getRight", "assertThat", "getExpression", "is", "instanceOf", "assertThat", "getText", "getExpression", "is", "assertThat", "getType", "is", "instanceOf", "assertThat", "getText", "getType", "is"]}, "focal_class": {"identifier": "FEELParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final List<String> REUSABLE_KEYWORDS = Arrays.asList(\n            \"for\", \"return\", \"if\", \"then\", \"else\", \"some\", \"every\", \"satisfies\", \"instance\", \"of\",\n            \"function\", \"external\", \"or\", \"and\", \"between\", \"not\", \"null\", \"true\", \"false\"\n    );", "modifier": "private static final", "type": "List<String>", "declarator": "REUSABLE_KEYWORDS = Arrays.asList(\n            \"for\", \"return\", \"if\", \"then\", \"else\", \"some\", \"every\", \"satisfies\", \"instance\", \"of\",\n            \"function\", \"external\", \"or\", \"and\", \"between\", \"not\", \"null\", \"true\", \"false\"\n    )", "var_name": "REUSABLE_KEYWORDS"}, {"original_string": "private static final Pattern DIGITS_PATTERN = Pattern.compile( \"[0-9]*\" );", "modifier": "private static final", "type": "Pattern", "declarator": "DIGITS_PATTERN = Pattern.compile( \"[0-9]*\" )", "var_name": "DIGITS_PATTERN"}], "methods": [{"identifier": "parse", "parameters": "(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "modifiers": "public static", "return": "FEEL_1_1Parser", "signature": "FEEL_1_1Parser parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "full_signature": "public static FEEL_1_1Parser parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "class_method_signature": "FEELParser.parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "testcase": false, "constructor": false}, {"identifier": "isVariableNamePartValid", "parameters": "( String namePart, Scope scope )", "modifiers": "public static", "return": "boolean", "signature": "boolean isVariableNamePartValid( String namePart, Scope scope )", "full_signature": "public static boolean isVariableNamePartValid( String namePart, Scope scope )", "class_method_signature": "FEELParser.isVariableNamePartValid( String namePart, Scope scope )", "testcase": false, "constructor": false}, {"identifier": "isVariableNameValid", "parameters": "( String source )", "modifiers": "public static", "return": "boolean", "signature": "boolean isVariableNameValid( String source )", "full_signature": "public static boolean isVariableNameValid( String source )", "class_method_signature": "FEELParser.isVariableNameValid( String source )", "testcase": false, "constructor": false}, {"identifier": "checkVariableName", "parameters": "( String source )", "modifiers": "public static", "return": "List<FEELEvent>", "signature": "List<FEELEvent> checkVariableName( String source )", "full_signature": "public static List<FEELEvent> checkVariableName( String source )", "class_method_signature": "FEELParser.checkVariableName( String source )", "testcase": false, "constructor": false}, {"identifier": "defineVariables", "parameters": "(Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, FEEL_1_1Parser parser)", "modifiers": "public static", "return": "void", "signature": "void defineVariables(Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, FEEL_1_1Parser parser)", "full_signature": "public static void defineVariables(Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, FEEL_1_1Parser parser)", "class_method_signature": "FEELParser.defineVariables(Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, FEEL_1_1Parser parser)", "testcase": false, "constructor": false}, {"identifier": "toList", "parameters": "(IntervalSet intervals, Vocabulary vocabulary)", "modifiers": "private static", "return": "List<String>", "signature": "List<String> toList(IntervalSet intervals, Vocabulary vocabulary)", "full_signature": "private static List<String> toList(IntervalSet intervals, Vocabulary vocabulary)", "class_method_signature": "FEELParser.toList(IntervalSet intervals, Vocabulary vocabulary)", "testcase": false, "constructor": false}, {"identifier": "elementName", "parameters": "(Vocabulary vocabulary, int a)", "modifiers": "private static", "return": "String", "signature": "String elementName(Vocabulary vocabulary, int a)", "full_signature": "private static String elementName(Vocabulary vocabulary, int a)", "class_method_signature": "FEELParser.elementName(Vocabulary vocabulary, int a)", "testcase": false, "constructor": false}, {"identifier": "generateInvalidVariableError", "parameters": "(Object offendingSymbol, int line, int charPositionInLine, RecognitionException e, CommonToken token)", "modifiers": "private static", "return": "SyntaxErrorEvent", "signature": "SyntaxErrorEvent generateInvalidVariableError(Object offendingSymbol, int line, int charPositionInLine, RecognitionException e, CommonToken token)", "full_signature": "private static SyntaxErrorEvent generateInvalidVariableError(Object offendingSymbol, int line, int charPositionInLine, RecognitionException e, CommonToken token)", "class_method_signature": "FEELParser.generateInvalidVariableError(Object offendingSymbol, int line, int charPositionInLine, RecognitionException e, CommonToken token)", "testcase": false, "constructor": false}], "file": "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/parser/feel11/FEELParser.java"}, "focal_method": {"identifier": "parse", "parameters": "(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "modifiers": "public static", "return": "FEEL_1_1Parser", "body": "public static FEEL_1_1Parser parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry) {\n        CharStream input = CharStreams.fromString(source);\n        FEEL_1_1Lexer lexer = new FEEL_1_1Lexer( input );\n        CommonTokenStream tokens = new CommonTokenStream( lexer );\n        FEEL_1_1Parser parser = new FEEL_1_1Parser( tokens );\n\n        ParserHelper parserHelper = new ParserHelper(eventsManager);\n        additionalFunctions.forEach(f -> parserHelper.getSymbolTable().getBuiltInScope().define(f.getSymbol()));\n        parser.setHelper(parserHelper);\n        parser.setErrorHandler( new FEELErrorHandler() );\n        parser.removeErrorListeners(); // removes the error listener that prints to the console\n        parser.addErrorListener( new FEELParserErrorListener( eventsManager ) );\n\n        // pre-loads the parser with symbols\n        defineVariables( inputVariableTypes, inputVariables, parser );\n        \n        if (typeRegistry != null) {\n            parserHelper.setTypeRegistry(typeRegistry);\n        }\n\n        return parser;\n    }", "signature": "FEEL_1_1Parser parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "full_signature": "public static FEEL_1_1Parser parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "class_method_signature": "FEELParser.parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry)", "testcase": false, "constructor": false, "invocations": ["fromString", "forEach", "define", "getBuiltInScope", "getSymbolTable", "getSymbol", "setHelper", "setErrorHandler", "removeErrorListeners", "addErrorListener", "defineVariables", "setTypeRegistry"]}, "repository": {"repo_id": 1381673, "url": "https://github.com/kiegroup/drools", "stars": 2733, "created": "2/18/2011 8:37:05 AM +00:00", "updates": "2020-01-27T13:12:15+00:00", "fork": "False", "license": "licensed"}}