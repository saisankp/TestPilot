{"test_class": {"identifier": "StoragePolicyProcessorJmsMessageListenerTest", "superclass": "extends AbstractServiceTest", "interfaces": "", "fields": [{"original_string": "@Autowired\n    private StorageFileHelper storageFileHelper;", "modifier": "@Autowired\n    private", "type": "StorageFileHelper", "declarator": "storageFileHelper", "var_name": "storageFileHelper"}, {"original_string": "@Autowired\n    StoragePolicyProcessorJmsMessageListener storagePolicyProcessorJmsMessageListener;", "modifier": "@Autowired", "type": "StoragePolicyProcessorJmsMessageListener", "declarator": "storagePolicyProcessorJmsMessageListener", "var_name": "storagePolicyProcessorJmsMessageListener"}], "file": "herd-code/herd-service/src/test/java/org/finra/herd/service/helper/StoragePolicyProcessorJmsMessageListenerTest.java"}, "test_case": {"identifier": "testProcessMessage", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testProcessMessage() throws Exception\n    {\n        // Build the expected S3 key prefix for test business object data.\n        String s3KeyPrefix =\n            getExpectedS3KeyPrefix(BDEF_NAMESPACE, DATA_PROVIDER_NAME, BDEF_NAME, FORMAT_USAGE_CODE, FORMAT_FILE_TYPE_CODE, FORMAT_VERSION, PARTITION_KEY,\n                PARTITION_VALUE, null, null, DATA_VERSION);\n\n        // Create S3FileTransferRequestParamsDto to access the source S3 bucket location.\n        // Since test S3 key prefix represents a directory, we add a trailing '/' character to it.\n        S3FileTransferRequestParamsDto sourceS3FileTransferRequestParamsDto =\n            S3FileTransferRequestParamsDto.builder().withS3BucketName(S3_BUCKET_NAME).withS3KeyPrefix(s3KeyPrefix + \"/\").build();\n\n        // Create and persist the relative database entities.\n        storagePolicyServiceTestHelper\n            .createDatabaseEntitiesForStoragePolicyTesting(STORAGE_POLICY_NAMESPACE_CD, Arrays.asList(STORAGE_POLICY_RULE_TYPE), BDEF_NAMESPACE, BDEF_NAME,\n                Arrays.asList(FORMAT_FILE_TYPE_CODE), Arrays.asList(STORAGE_NAME), Arrays.asList(StoragePolicyTransitionTypeEntity.GLACIER));\n\n        // Create a business object data key.\n        BusinessObjectDataKey businessObjectDataKey =\n            new BusinessObjectDataKey(BDEF_NAMESPACE, BDEF_NAME, FORMAT_USAGE_CODE, FORMAT_FILE_TYPE_CODE, FORMAT_VERSION, PARTITION_VALUE,\n                NO_SUBPARTITION_VALUES, DATA_VERSION);\n\n        // Create and persist an ENABLED storage unit in the source storage.\n        StorageUnitEntity sourceStorageUnitEntity = storageUnitDaoTestHelper\n            .createStorageUnitEntity(STORAGE_NAME, businessObjectDataKey, LATEST_VERSION_FLAG_SET, BusinessObjectDataStatusEntity.VALID,\n                StorageUnitStatusEntity.ENABLED, NO_STORAGE_DIRECTORY_PATH);\n\n        // Add storage files to the source storage unit.\n        for (String filePath : LOCAL_FILES)\n        {\n            storageFileDaoTestHelper.createStorageFileEntity(sourceStorageUnitEntity, s3KeyPrefix + \"/\" + filePath, FILE_SIZE_1_KB, ROW_COUNT_1000);\n        }\n\n        // Get the source storage files.\n        List<StorageFile> sourceStorageFiles = storageFileHelper.createStorageFilesFromEntities(sourceStorageUnitEntity.getStorageFiles());\n\n        // Create a storage policy key.\n        StoragePolicyKey storagePolicyKey = new StoragePolicyKey(STORAGE_POLICY_NAMESPACE_CD, STORAGE_POLICY_NAME);\n\n        // Create and persist a storage policy entity.\n        storagePolicyDaoTestHelper\n            .createStoragePolicyEntity(storagePolicyKey, STORAGE_POLICY_RULE_TYPE, STORAGE_POLICY_RULE_VALUE, BDEF_NAMESPACE, BDEF_NAME, FORMAT_USAGE_CODE,\n                FORMAT_FILE_TYPE_CODE, STORAGE_NAME, StoragePolicyTransitionTypeEntity.GLACIER, StoragePolicyStatusEntity.ENABLED, INITIAL_VERSION,\n                LATEST_VERSION_FLAG_SET);\n\n        // Override configuration to specify some settings required for testing.\n        Map<String, Object> overrideMap = new HashMap<>();\n        overrideMap.put(ConfigurationValue.S3_ARCHIVE_TO_GLACIER_ROLE_ARN.getKey(), S3_OBJECT_TAGGER_ROLE_ARN);\n        overrideMap.put(ConfigurationValue.S3_ARCHIVE_TO_GLACIER_ROLE_SESSION_NAME.getKey(), S3_OBJECT_TAGGER_ROLE_SESSION_NAME);\n        modifyPropertySourceInEnvironment(overrideMap);\n\n        try\n        {\n            // Put relative S3 files into the source S3 bucket.\n            for (StorageFile storageFile : sourceStorageFiles)\n            {\n                s3Operations.putObject(new PutObjectRequest(S3_BUCKET_NAME, storageFile.getFilePath(),\n                    new ByteArrayInputStream(new byte[storageFile.getFileSizeBytes().intValue()]), null), null);\n            }\n\n            // Perform a storage policy transition.\n            storagePolicyProcessorJmsMessageListener\n                .processMessage(jsonHelper.objectToJson(new StoragePolicySelection(businessObjectDataKey, storagePolicyKey, INITIAL_VERSION)), null);\n\n            // Validate the status of the source storage unit.\n            assertEquals(StorageUnitStatusEntity.ARCHIVED, sourceStorageUnitEntity.getStatus().getCode());\n        }\n        finally\n        {\n            // Delete test files from S3 storage.\n            if (!s3Dao.listDirectory(sourceS3FileTransferRequestParamsDto).isEmpty())\n            {\n                s3Dao.deleteDirectory(sourceS3FileTransferRequestParamsDto);\n            }\n            s3Operations.rollback();\n\n            // Restore the property sources so we don't affect other tests.\n            restorePropertySourceInEnvironment();\n        }\n    }", "signature": "void testProcessMessage()", "full_signature": "@Test public void testProcessMessage()", "class_method_signature": "StoragePolicyProcessorJmsMessageListenerTest.testProcessMessage()", "testcase": true, "constructor": false, "invocations": ["getExpectedS3KeyPrefix", "build", "withS3KeyPrefix", "withS3BucketName", "builder", "createDatabaseEntitiesForStoragePolicyTesting", "asList", "asList", "asList", "asList", "createStorageUnitEntity", "createStorageFileEntity", "createStorageFilesFromEntities", "getStorageFiles", "createStoragePolicyEntity", "put", "getKey", "put", "getKey", "modifyPropertySourceInEnvironment", "putObject", "getFilePath", "intValue", "getFileSizeBytes", "processMessage", "objectToJson", "assertEquals", "getCode", "getStatus", "isEmpty", "listDirectory", "deleteDirectory", "rollback", "restorePropertySourceInEnvironment"]}, "focal_class": {"identifier": "StoragePolicyProcessorJmsMessageListener", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(StoragePolicyProcessorJmsMessageListener.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(StoragePolicyProcessorJmsMessageListener.class)", "var_name": "LOGGER"}, {"original_string": "@Autowired\n    private ConfigurationHelper configurationHelper;", "modifier": "@Autowired\n    private", "type": "ConfigurationHelper", "declarator": "configurationHelper", "var_name": "configurationHelper"}, {"original_string": "@Autowired\n    private JsonHelper jsonHelper;", "modifier": "@Autowired\n    private", "type": "JsonHelper", "declarator": "jsonHelper", "var_name": "jsonHelper"}, {"original_string": "@Autowired\n    private StoragePolicyProcessorService storagePolicyProcessorService;", "modifier": "@Autowired\n    private", "type": "StoragePolicyProcessorService", "declarator": "storagePolicyProcessorService", "var_name": "storagePolicyProcessorService"}], "methods": [{"identifier": "controlStoragePolicyProcessorJmsMessageListener", "parameters": "()", "modifiers": "@Scheduled(fixedDelay = 60000) public", "return": "void", "signature": "void controlStoragePolicyProcessorJmsMessageListener()", "full_signature": "@Scheduled(fixedDelay = 60000) public void controlStoragePolicyProcessorJmsMessageListener()", "class_method_signature": "StoragePolicyProcessorJmsMessageListener.controlStoragePolicyProcessorJmsMessageListener()", "testcase": false, "constructor": false}, {"identifier": "processMessage", "parameters": "(String payload, @Headers Map<Object, Object> allHeaders)", "modifiers": "@JmsListener(id = HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE, containerFactory = \"storagePolicyProcessorJmsListenerContainerFactory\", destination = HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE) public", "return": "void", "signature": "void processMessage(String payload, @Headers Map<Object, Object> allHeaders)", "full_signature": "@JmsListener(id = HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE, containerFactory = \"storagePolicyProcessorJmsListenerContainerFactory\", destination = HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE) public void processMessage(String payload, @Headers Map<Object, Object> allHeaders)", "class_method_signature": "StoragePolicyProcessorJmsMessageListener.processMessage(String payload, @Headers Map<Object, Object> allHeaders)", "testcase": false, "constructor": false}], "file": "herd-code/herd-service/src/main/java/org/finra/herd/service/helper/StoragePolicyProcessorJmsMessageListener.java"}, "focal_method": {"identifier": "processMessage", "parameters": "(String payload, @Headers Map<Object, Object> allHeaders)", "modifiers": "@JmsListener(id = HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE, containerFactory = \"storagePolicyProcessorJmsListenerContainerFactory\", destination = HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE) public", "return": "void", "body": "@JmsListener(id = HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE,\n        containerFactory = \"storagePolicyProcessorJmsListenerContainerFactory\",\n        destination = HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE)\n    public void processMessage(String payload, @Headers Map<Object, Object> allHeaders)\n    {\n        LOGGER.info(\"Message received from the JMS queue. jmsQueueName=\\\"{}\\\" jmsMessageHeaders=\\\"{}\\\" jmsMessagePayload={}\",\n            HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE, allHeaders, payload);\n\n        // Process the message as storage policy selection message.\n        try\n        {\n            // Process messages coming from the storage policy selector job.\n            StoragePolicySelection storagePolicySelection = jsonHelper.unmarshallJsonToObject(StoragePolicySelection.class, payload);\n\n            LOGGER.debug(\"Received storage policy selection message: businessObjectDataKey={} storagePolicyKey={} storagePolicyVersion={}\",\n                jsonHelper.objectToJson(storagePolicySelection.getBusinessObjectDataKey()),\n                jsonHelper.objectToJson(storagePolicySelection.getStoragePolicyKey()), storagePolicySelection.getStoragePolicyVersion());\n\n            // Process the storage policy selection message.\n            storagePolicyProcessorService.processStoragePolicySelectionMessage(storagePolicySelection);\n        }\n        catch (RuntimeException | IOException e)\n        {\n            // Log a warning message if storage unit status is already ARCHIVED. Such error case is typically caused by a duplicate SQS message.\n            if (e instanceof IllegalArgumentException &&\n                e.getMessage().startsWith(String.format(\"Storage unit status is \\\"%s\\\"\", StorageUnitStatusEntity.ARCHIVED)))\n            {\n                LOGGER.warn(\"Failed to process message from the JMS queue. jmsQueueName=\\\"{}\\\" jmsMessagePayload={}\",\n                    HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE, payload, e);\n            }\n            // Otherwise, log an error.\n            else\n            {\n                LOGGER.error(\"Failed to process message from the JMS queue. jmsQueueName=\\\"{}\\\" jmsMessagePayload={}\",\n                    HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE, payload, e);\n            }\n        }\n    }", "signature": "void processMessage(String payload, @Headers Map<Object, Object> allHeaders)", "full_signature": "@JmsListener(id = HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE, containerFactory = \"storagePolicyProcessorJmsListenerContainerFactory\", destination = HerdJmsDestinationResolver.SQS_DESTINATION_STORAGE_POLICY_SELECTOR_JOB_SQS_QUEUE) public void processMessage(String payload, @Headers Map<Object, Object> allHeaders)", "class_method_signature": "StoragePolicyProcessorJmsMessageListener.processMessage(String payload, @Headers Map<Object, Object> allHeaders)", "testcase": false, "constructor": false, "invocations": ["info", "unmarshallJsonToObject", "debug", "objectToJson", "getBusinessObjectDataKey", "objectToJson", "getStoragePolicyKey", "getStoragePolicyVersion", "processStoragePolicySelectionMessage", "startsWith", "getMessage", "format", "warn", "error"]}, "repository": {"repo_id": 42949039, "url": "https://github.com/FINRAOS/herd", "language": "Java", "is_fork": false, "fork_count": 36, "stargazer_count": 120, "size": 205797, "license": "licensed"}}