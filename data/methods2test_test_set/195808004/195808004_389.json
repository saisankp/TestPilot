{"test_class": {"identifier": "TestDockerContainerExecutor", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Log LOG = LogFactory\n      .getLog(TestDockerContainerExecutor.class);", "modifier": "private static final", "type": "Log", "declarator": "LOG = LogFactory\n      .getLog(TestDockerContainerExecutor.class)", "var_name": "LOG"}, {"original_string": "private static File workSpace = null;", "modifier": "private static", "type": "File", "declarator": "workSpace = null", "var_name": "workSpace"}, {"original_string": "private DockerContainerExecutor exec = null;", "modifier": "private", "type": "DockerContainerExecutor", "declarator": "exec = null", "var_name": "exec"}, {"original_string": "private LocalDirsHandlerService dirsHandler;", "modifier": "private", "type": "LocalDirsHandlerService", "declarator": "dirsHandler", "var_name": "dirsHandler"}, {"original_string": "private Path workDir;", "modifier": "private", "type": "Path", "declarator": "workDir", "var_name": "workDir"}, {"original_string": "private FileContext lfs;", "modifier": "private", "type": "FileContext", "declarator": "lfs", "var_name": "lfs"}, {"original_string": "private String yarnImage;", "modifier": "private", "type": "String", "declarator": "yarnImage", "var_name": "yarnImage"}, {"original_string": "private int id = 0;", "modifier": "private", "type": "int", "declarator": "id = 0", "var_name": "id"}, {"original_string": "private String appSubmitter;", "modifier": "private", "type": "String", "declarator": "appSubmitter", "var_name": "appSubmitter"}, {"original_string": "private String dockerUrl;", "modifier": "private", "type": "String", "declarator": "dockerUrl", "var_name": "dockerUrl"}, {"original_string": "private String testImage = \"centos\";", "modifier": "private", "type": "String", "declarator": "testImage = \"centos\"", "var_name": "testImage"}, {"original_string": "private String dockerExec;", "modifier": "private", "type": "String", "declarator": "dockerExec", "var_name": "dockerExec"}, {"original_string": "private String containerIdStr;", "modifier": "private", "type": "String", "declarator": "containerIdStr", "var_name": "containerIdStr"}], "file": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/test/java/org/apache/hadoop/yarn/server/nodemanager/TestDockerContainerExecutor.java"}, "test_case": {"identifier": "testLaunchContainer", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testLaunchContainer() throws IOException {\n    if (!shouldRun()) {\n      LOG.warn(\"Docker not installed, aborting test.\");\n      return;\n    }\n\n    Map<String, String> env = new HashMap<String, String>();\n    env.put(YarnConfiguration.NM_DOCKER_CONTAINER_EXECUTOR_IMAGE_NAME, testImage);\n    String touchFileName = \"touch-file-\" + System.currentTimeMillis();\n    File touchFile = new File(dirsHandler.getLocalDirs().get(0), touchFileName);\n    ContainerId cId = getNextContainerId();\n    int ret = runAndBlock(\n        cId, env, \"touch\", touchFile.getAbsolutePath(), \"&&\", \"cp\", touchFile.getAbsolutePath(), \"/\");\n\n    assertEquals(0, ret);\n  }", "signature": "void testLaunchContainer()", "full_signature": "@Test public void testLaunchContainer()", "class_method_signature": "TestDockerContainerExecutor.testLaunchContainer()", "testcase": true, "constructor": false, "invocations": ["shouldRun", "warn", "put", "currentTimeMillis", "get", "getLocalDirs", "getNextContainerId", "runAndBlock", "getAbsolutePath", "getAbsolutePath", "assertEquals"]}, "focal_class": {"identifier": "DockerContainerExecutor", "superclass": "extends ContainerExecutor", "interfaces": "", "fields": [{"original_string": "private static final Log LOG = LogFactory\n      .getLog(DockerContainerExecutor.class);", "modifier": "private static final", "type": "Log", "declarator": "LOG = LogFactory\n      .getLog(DockerContainerExecutor.class)", "var_name": "LOG"}, {"original_string": "public static final String DOCKER_CONTAINER_EXECUTOR_SCRIPT = \"docker_container_executor\";", "modifier": "public static final", "type": "String", "declarator": "DOCKER_CONTAINER_EXECUTOR_SCRIPT = \"docker_container_executor\"", "var_name": "DOCKER_CONTAINER_EXECUTOR_SCRIPT"}, {"original_string": "public static final String DOCKER_CONTAINER_EXECUTOR_SESSION_SCRIPT = \"docker_container_executor_session\";", "modifier": "public static final", "type": "String", "declarator": "DOCKER_CONTAINER_EXECUTOR_SESSION_SCRIPT = \"docker_container_executor_session\"", "var_name": "DOCKER_CONTAINER_EXECUTOR_SESSION_SCRIPT"}, {"original_string": "public static final String DOCKER_IMAGE_PATTERN = \"^(([\\\\w\\\\.-]+)(:\\\\d+)*\\\\/)?[\\\\w\\\\.:-]+$\";", "modifier": "public static final", "type": "String", "declarator": "DOCKER_IMAGE_PATTERN = \"^(([\\\\w\\\\.-]+)(:\\\\d+)*\\\\/)?[\\\\w\\\\.:-]+$\"", "var_name": "DOCKER_IMAGE_PATTERN"}, {"original_string": "private final FileContext lfs;", "modifier": "private final", "type": "FileContext", "declarator": "lfs", "var_name": "lfs"}, {"original_string": "private final Pattern dockerImagePattern;", "modifier": "private final", "type": "Pattern", "declarator": "dockerImagePattern", "var_name": "dockerImagePattern"}, {"original_string": "static final short USER_PERM = (short) 0750;", "modifier": "static final", "type": "short", "declarator": "USER_PERM = (short) 0750", "var_name": "USER_PERM"}, {"original_string": "static final short APPCACHE_PERM = (short) 0710;", "modifier": "static final", "type": "short", "declarator": "APPCACHE_PERM = (short) 0710", "var_name": "APPCACHE_PERM"}, {"original_string": "static final short FILECACHE_PERM = (short) 0710;", "modifier": "static final", "type": "short", "declarator": "FILECACHE_PERM = (short) 0710", "var_name": "FILECACHE_PERM"}, {"original_string": "static final short APPDIR_PERM = (short) 0710;", "modifier": "static final", "type": "short", "declarator": "APPDIR_PERM = (short) 0710", "var_name": "APPDIR_PERM"}, {"original_string": "static final short LOGDIR_PERM = (short) 0710;", "modifier": "static final", "type": "short", "declarator": "LOGDIR_PERM = (short) 0710", "var_name": "LOGDIR_PERM"}], "methods": [{"identifier": "DockerContainerExecutor", "parameters": "()", "modifiers": "public", "return": "", "signature": " DockerContainerExecutor()", "full_signature": "public  DockerContainerExecutor()", "class_method_signature": "DockerContainerExecutor.DockerContainerExecutor()", "testcase": false, "constructor": true}, {"identifier": "copyFile", "parameters": "(Path src, Path dst, String owner)", "modifiers": "protected", "return": "void", "signature": "void copyFile(Path src, Path dst, String owner)", "full_signature": "protected void copyFile(Path src, Path dst, String owner)", "class_method_signature": "DockerContainerExecutor.copyFile(Path src, Path dst, String owner)", "testcase": false, "constructor": false}, {"identifier": "init", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void init()", "full_signature": "@Override public void init()", "class_method_signature": "DockerContainerExecutor.init()", "testcase": false, "constructor": false}, {"identifier": "startLocalizer", "parameters": "(Path nmPrivateContainerTokensPath,\n                                          InetSocketAddress nmAddr, String user, String appId, String locId,\n                                          LocalDirsHandlerService dirsHandler)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void startLocalizer(Path nmPrivateContainerTokensPath,\n                                          InetSocketAddress nmAddr, String user, String appId, String locId,\n                                          LocalDirsHandlerService dirsHandler)", "full_signature": "@Override public synchronized void startLocalizer(Path nmPrivateContainerTokensPath,\n                                          InetSocketAddress nmAddr, String user, String appId, String locId,\n                                          LocalDirsHandlerService dirsHandler)", "class_method_signature": "DockerContainerExecutor.startLocalizer(Path nmPrivateContainerTokensPath,\n                                          InetSocketAddress nmAddr, String user, String appId, String locId,\n                                          LocalDirsHandlerService dirsHandler)", "testcase": false, "constructor": false}, {"identifier": "launchContainer", "parameters": "(Container container,\n                             Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n                             String userName, String appId, Path containerWorkDir,\n                             List<String> localDirs, List<String> logDirs)", "modifiers": "@Override public", "return": "int", "signature": "int launchContainer(Container container,\n                             Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n                             String userName, String appId, Path containerWorkDir,\n                             List<String> localDirs, List<String> logDirs)", "full_signature": "@Override public int launchContainer(Container container,\n                             Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n                             String userName, String appId, Path containerWorkDir,\n                             List<String> localDirs, List<String> logDirs)", "class_method_signature": "DockerContainerExecutor.launchContainer(Container container,\n                             Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n                             String userName, String appId, Path containerWorkDir,\n                             List<String> localDirs, List<String> logDirs)", "testcase": false, "constructor": false}, {"identifier": "writeLaunchEnv", "parameters": "(OutputStream out, Map<String, String> environment, Map<Path, List<String>> resources, List<String> command)", "modifiers": "@Override public", "return": "void", "signature": "void writeLaunchEnv(OutputStream out, Map<String, String> environment, Map<Path, List<String>> resources, List<String> command)", "full_signature": "@Override public void writeLaunchEnv(OutputStream out, Map<String, String> environment, Map<Path, List<String>> resources, List<String> command)", "class_method_signature": "DockerContainerExecutor.writeLaunchEnv(OutputStream out, Map<String, String> environment, Map<Path, List<String>> resources, List<String> command)", "testcase": false, "constructor": false}, {"identifier": "saneDockerImage", "parameters": "(String containerImageName)", "modifiers": "private", "return": "boolean", "signature": "boolean saneDockerImage(String containerImageName)", "full_signature": "private boolean saneDockerImage(String containerImageName)", "class_method_signature": "DockerContainerExecutor.saneDockerImage(String containerImageName)", "testcase": false, "constructor": false}, {"identifier": "signalContainer", "parameters": "(String user, String pid, Signal signal)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean signalContainer(String user, String pid, Signal signal)", "full_signature": "@Override public boolean signalContainer(String user, String pid, Signal signal)", "class_method_signature": "DockerContainerExecutor.signalContainer(String user, String pid, Signal signal)", "testcase": false, "constructor": false}, {"identifier": "isContainerProcessAlive", "parameters": "(String user, String pid)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isContainerProcessAlive(String user, String pid)", "full_signature": "@Override public boolean isContainerProcessAlive(String user, String pid)", "class_method_signature": "DockerContainerExecutor.isContainerProcessAlive(String user, String pid)", "testcase": false, "constructor": false}, {"identifier": "containerIsAlive", "parameters": "(String pid)", "modifiers": "@VisibleForTesting public static", "return": "boolean", "signature": "boolean containerIsAlive(String pid)", "full_signature": "@VisibleForTesting public static boolean containerIsAlive(String pid)", "class_method_signature": "DockerContainerExecutor.containerIsAlive(String pid)", "testcase": false, "constructor": false}, {"identifier": "killContainer", "parameters": "(String pid, Signal signal)", "modifiers": "protected", "return": "void", "signature": "void killContainer(String pid, Signal signal)", "full_signature": "protected void killContainer(String pid, Signal signal)", "class_method_signature": "DockerContainerExecutor.killContainer(String pid, Signal signal)", "testcase": false, "constructor": false}, {"identifier": "deleteAsUser", "parameters": "(String user, Path subDir, Path... baseDirs)", "modifiers": "@Override public", "return": "void", "signature": "void deleteAsUser(String user, Path subDir, Path... baseDirs)", "full_signature": "@Override public void deleteAsUser(String user, Path subDir, Path... baseDirs)", "class_method_signature": "DockerContainerExecutor.deleteAsUser(String user, Path subDir, Path... baseDirs)", "testcase": false, "constructor": false}, {"identifier": "toMount", "parameters": "(List<String> dirs)", "modifiers": "private", "return": "String", "signature": "String toMount(List<String> dirs)", "full_signature": "private String toMount(List<String> dirs)", "class_method_signature": "DockerContainerExecutor.toMount(List<String> dirs)", "testcase": false, "constructor": false}, {"identifier": "createDir", "parameters": "(Path dirPath, FsPermission perms,\n                           boolean createParent, String user)", "modifiers": "protected", "return": "void", "signature": "void createDir(Path dirPath, FsPermission perms,\n                           boolean createParent, String user)", "full_signature": "protected void createDir(Path dirPath, FsPermission perms,\n                           boolean createParent, String user)", "class_method_signature": "DockerContainerExecutor.createDir(Path dirPath, FsPermission perms,\n                           boolean createParent, String user)", "testcase": false, "constructor": false}, {"identifier": "createUserLocalDirs", "parameters": "(List<String> localDirs, String user)", "modifiers": "", "return": "void", "signature": "void createUserLocalDirs(List<String> localDirs, String user)", "full_signature": " void createUserLocalDirs(List<String> localDirs, String user)", "class_method_signature": "DockerContainerExecutor.createUserLocalDirs(List<String> localDirs, String user)", "testcase": false, "constructor": false}, {"identifier": "createUserCacheDirs", "parameters": "(List<String> localDirs, String user)", "modifiers": "", "return": "void", "signature": "void createUserCacheDirs(List<String> localDirs, String user)", "full_signature": " void createUserCacheDirs(List<String> localDirs, String user)", "class_method_signature": "DockerContainerExecutor.createUserCacheDirs(List<String> localDirs, String user)", "testcase": false, "constructor": false}, {"identifier": "createAppDirs", "parameters": "(List<String> localDirs, String user, String appId)", "modifiers": "", "return": "void", "signature": "void createAppDirs(List<String> localDirs, String user, String appId)", "full_signature": " void createAppDirs(List<String> localDirs, String user, String appId)", "class_method_signature": "DockerContainerExecutor.createAppDirs(List<String> localDirs, String user, String appId)", "testcase": false, "constructor": false}, {"identifier": "createContainerLogDirs", "parameters": "(String appId, String containerId,\n                              List<String> logDirs, String user)", "modifiers": "", "return": "void", "signature": "void createContainerLogDirs(String appId, String containerId,\n                              List<String> logDirs, String user)", "full_signature": " void createContainerLogDirs(String appId, String containerId,\n                              List<String> logDirs, String user)", "class_method_signature": "DockerContainerExecutor.createContainerLogDirs(String appId, String containerId,\n                              List<String> logDirs, String user)", "testcase": false, "constructor": false}, {"identifier": "getDiskFreeSpace", "parameters": "(Path base)", "modifiers": "private", "return": "long", "signature": "long getDiskFreeSpace(Path base)", "full_signature": "private long getDiskFreeSpace(Path base)", "class_method_signature": "DockerContainerExecutor.getDiskFreeSpace(Path base)", "testcase": false, "constructor": false}, {"identifier": "getApplicationDir", "parameters": "(Path base, String user, String appId)", "modifiers": "private", "return": "Path", "signature": "Path getApplicationDir(Path base, String user, String appId)", "full_signature": "private Path getApplicationDir(Path base, String user, String appId)", "class_method_signature": "DockerContainerExecutor.getApplicationDir(Path base, String user, String appId)", "testcase": false, "constructor": false}, {"identifier": "getUserCacheDir", "parameters": "(Path base, String user)", "modifiers": "private", "return": "Path", "signature": "Path getUserCacheDir(Path base, String user)", "full_signature": "private Path getUserCacheDir(Path base, String user)", "class_method_signature": "DockerContainerExecutor.getUserCacheDir(Path base, String user)", "testcase": false, "constructor": false}, {"identifier": "getAppcacheDir", "parameters": "(Path base, String user)", "modifiers": "private", "return": "Path", "signature": "Path getAppcacheDir(Path base, String user)", "full_signature": "private Path getAppcacheDir(Path base, String user)", "class_method_signature": "DockerContainerExecutor.getAppcacheDir(Path base, String user)", "testcase": false, "constructor": false}, {"identifier": "getFileCacheDir", "parameters": "(Path base, String user)", "modifiers": "private", "return": "Path", "signature": "Path getFileCacheDir(Path base, String user)", "full_signature": "private Path getFileCacheDir(Path base, String user)", "class_method_signature": "DockerContainerExecutor.getFileCacheDir(Path base, String user)", "testcase": false, "constructor": false}, {"identifier": "getWorkingDir", "parameters": "(List<String> localDirs, String user,\n                               String appId)", "modifiers": "protected", "return": "Path", "signature": "Path getWorkingDir(List<String> localDirs, String user,\n                               String appId)", "full_signature": "protected Path getWorkingDir(List<String> localDirs, String user,\n                               String appId)", "class_method_signature": "DockerContainerExecutor.getWorkingDir(List<String> localDirs, String user,\n                               String appId)", "testcase": false, "constructor": false}, {"identifier": "createAppLogDirs", "parameters": "(String appId, List<String> logDirs, String user)", "modifiers": "", "return": "void", "signature": "void createAppLogDirs(String appId, List<String> logDirs, String user)", "full_signature": " void createAppLogDirs(String appId, List<String> logDirs, String user)", "class_method_signature": "DockerContainerExecutor.createAppLogDirs(String appId, List<String> logDirs, String user)", "testcase": false, "constructor": false}, {"identifier": "getPaths", "parameters": "(List<String> dirs)", "modifiers": "private static", "return": "List<Path>", "signature": "List<Path> getPaths(List<String> dirs)", "full_signature": "private static List<Path> getPaths(List<String> dirs)", "class_method_signature": "DockerContainerExecutor.getPaths(List<String> dirs)", "testcase": false, "constructor": false}], "file": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/DockerContainerExecutor.java"}, "focal_method": {"identifier": "launchContainer", "parameters": "(Container container,\n                             Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n                             String userName, String appId, Path containerWorkDir,\n                             List<String> localDirs, List<String> logDirs)", "modifiers": "@Override public", "return": "int", "body": "@Override\n  public int launchContainer(Container container,\n                             Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n                             String userName, String appId, Path containerWorkDir,\n                             List<String> localDirs, List<String> logDirs) throws IOException {\n    String containerImageName = container.getLaunchContext().getEnvironment()\n        .get(YarnConfiguration.NM_DOCKER_CONTAINER_EXECUTOR_IMAGE_NAME);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"containerImageName from launchContext: \" + containerImageName);\n    }\n    Preconditions.checkArgument(!Strings.isNullOrEmpty(containerImageName), \"Container image must not be null\");\n    containerImageName = containerImageName.replaceAll(\"['\\\"]\", \"\");\n\n    Preconditions.checkArgument(saneDockerImage(containerImageName), \"Image: \" + containerImageName + \" is not a proper docker image\");\n    String dockerExecutor = getConf().get(YarnConfiguration.NM_DOCKER_CONTAINER_EXECUTOR_EXEC_NAME,\n        YarnConfiguration.NM_DEFAULT_DOCKER_CONTAINER_EXECUTOR_EXEC_NAME);\n\n    FsPermission dirPerm = new FsPermission(APPDIR_PERM);\n    ContainerId containerId = container.getContainerId();\n\n    // create container dirs on all disks\n    String containerIdStr = ConverterUtils.toString(containerId);\n    String appIdStr =\n        ConverterUtils.toString(\n            containerId.getApplicationAttemptId().\n                getApplicationId());\n    for (String sLocalDir : localDirs) {\n      Path usersdir = new Path(sLocalDir, ContainerLocalizer.USERCACHE);\n      Path userdir = new Path(usersdir, userName);\n      Path appCacheDir = new Path(userdir, ContainerLocalizer.APPCACHE);\n      Path appDir = new Path(appCacheDir, appIdStr);\n      Path containerDir = new Path(appDir, containerIdStr);\n      createDir(containerDir, dirPerm, true, userName);\n    }\n\n    // Create the container log-dirs on all disks\n    createContainerLogDirs(appIdStr, containerIdStr, logDirs, userName);\n\n    Path tmpDir = new Path(containerWorkDir,\n        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);\n    createDir(tmpDir, dirPerm, false, userName);\n\n    // copy launch script to work dir\n    Path launchDst =\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n    lfs.util().copy(nmPrivateContainerScriptPath, launchDst);\n\n    // copy container tokens to work dir\n    Path tokenDst =\n        new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);\n    lfs.util().copy(nmPrivateTokensPath, tokenDst);\n\n\n\n    String localDirMount = toMount(localDirs);\n    String logDirMount = toMount(logDirs);\n    String containerWorkDirMount = toMount(Collections.singletonList(containerWorkDir.toUri().getPath()));\n    StringBuilder commands = new StringBuilder();\n    String commandStr = commands.append(dockerExecutor)\n        .append(\" \")\n        .append(\"run\")\n        .append(\" \")\n        .append(\"--rm --net=host\")\n        .append(\" \")\n        .append(\" --name \" + containerIdStr)\n        .append(localDirMount)\n        .append(logDirMount)\n        .append(containerWorkDirMount)\n        .append(\" \")\n        .append(containerImageName)\n        .toString();\n    String dockerPidScript = \"`\" + dockerExecutor + \" inspect --format {{.State.Pid}} \" + containerIdStr + \"`\";\n    // Create new local launch wrapper script\n    LocalWrapperScriptBuilder sb =\n      new UnixLocalWrapperScriptBuilder(containerWorkDir, commandStr, dockerPidScript);\n    Path pidFile = getPidFilePath(containerId);\n    if (pidFile != null) {\n      sb.writeLocalWrapperScript(launchDst, pidFile);\n    } else {\n      LOG.info(\"Container \" + containerIdStr\n          + \" was marked as inactive. Returning terminated error\");\n      return ExitCode.TERMINATED.getExitCode();\n    }\n    \n    ShellCommandExecutor shExec = null;\n    try {\n      lfs.setPermission(launchDst,\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n      lfs.setPermission(sb.getWrapperScriptPath(),\n          ContainerExecutor.TASK_LAUNCH_SCRIPT_PERMISSION);\n\n      // Setup command to run\n      String[] command = getRunCommand(sb.getWrapperScriptPath().toString(),\n        containerIdStr, userName, pidFile, this.getConf());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"launchContainer: \" + commandStr + \" \" + Joiner.on(\" \").join(command));\n      }\n      shExec = new ShellCommandExecutor(\n          command,\n          new File(containerWorkDir.toUri().getPath()),\n          container.getLaunchContext().getEnvironment());      // sanitized env\n      if (isContainerActive(containerId)) {\n        shExec.execute();\n      } else {\n        LOG.info(\"Container \" + containerIdStr +\n            \" was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (IOException e) {\n      if (null == shExec) {\n        return -1;\n      }\n      int exitCode = shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor's output\n      if (exitCode != ExitCode.FORCE_KILLED.getExitCode()\n          && exitCode != ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n        logOutput(shExec.getOutput());\n        String diagnostics = \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      if (shExec != null) {\n        shExec.close();\n      }\n    }\n    return 0;\n  }", "signature": "int launchContainer(Container container,\n                             Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n                             String userName, String appId, Path containerWorkDir,\n                             List<String> localDirs, List<String> logDirs)", "full_signature": "@Override public int launchContainer(Container container,\n                             Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n                             String userName, String appId, Path containerWorkDir,\n                             List<String> localDirs, List<String> logDirs)", "class_method_signature": "DockerContainerExecutor.launchContainer(Container container,\n                             Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,\n                             String userName, String appId, Path containerWorkDir,\n                             List<String> localDirs, List<String> logDirs)", "testcase": false, "constructor": false, "invocations": ["get", "getEnvironment", "getLaunchContext", "isDebugEnabled", "debug", "checkArgument", "isNullOrEmpty", "replaceAll", "checkArgument", "saneDockerImage", "get", "getConf", "getContainerId", "toString", "toString", "getApplicationId", "getApplicationAttemptId", "createDir", "createContainerLogDirs", "createDir", "copy", "util", "copy", "util", "toMount", "toMount", "toMount", "singletonList", "getPath", "toUri", "toString", "append", "append", "append", "append", "append", "append", "append", "append", "append", "append", "append", "append", "getPidFilePath", "writeLocalWrapperScript", "info", "getExitCode", "setPermission", "setPermission", "getWrapperScriptPath", "getRunCommand", "toString", "getWrapperScriptPath", "getConf", "isDebugEnabled", "debug", "join", "on", "getPath", "toUri", "getEnvironment", "getLaunchContext", "isContainerActive", "execute", "info", "getExitCode", "getExitCode", "warn", "getExitCode", "getExitCode", "warn", "logOutput", "getOutput", "stringifyException", "getOutput", "handle", "handle", "close"]}, "repository": {"repo_id": 195808004, "url": "https://github.com/mouzwang/hadoop-2.7.2", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 5, "size": 24927, "license": "licensed"}}