{"test_class": {"identifier": "TestOptionsParser", "superclass": "", "interfaces": "", "fields": [], "file": "conduit-distcp/src/test/java/com/inmobi/conduit/distcp/tools/TestOptionsParser.java"}, "test_case": {"identifier": "testInvalidArgs", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testInvalidArgs() {\n    try {\n      OptionsParser.parse(new String[] {\n          \"-m\", \"-f\", \"hdfs://localhost:8020/source\"});\n      Assert.fail(\"Missing map value\");\n    } catch (IllegalArgumentException ignore) {}\n  }", "signature": "void testInvalidArgs()", "full_signature": "@Test public void testInvalidArgs()", "class_method_signature": "TestOptionsParser.testInvalidArgs()", "testcase": true, "constructor": false, "invocations": ["parse", "fail"]}, "focal_class": {"identifier": "OptionsParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Log LOG = LogFactory.getLog(OptionsParser.class);", "modifier": "private static final", "type": "Log", "declarator": "LOG = LogFactory.getLog(OptionsParser.class)", "var_name": "LOG"}, {"original_string": "private static final Options cliOptions = new Options();", "modifier": "private static final", "type": "Options", "declarator": "cliOptions = new Options()", "var_name": "cliOptions"}], "methods": [{"identifier": "parse", "parameters": "(String args[])", "modifiers": "public static", "return": "DistCpOptions", "signature": "DistCpOptions parse(String args[])", "full_signature": "public static DistCpOptions parse(String args[])", "class_method_signature": "OptionsParser.parse(String args[])", "testcase": false, "constructor": false}, {"identifier": "getVal", "parameters": "(CommandLine command, String swtch)", "modifiers": "private static", "return": "String", "signature": "String getVal(CommandLine command, String swtch)", "full_signature": "private static String getVal(CommandLine command, String swtch)", "class_method_signature": "OptionsParser.getVal(CommandLine command, String swtch)", "testcase": false, "constructor": false}, {"identifier": "usage", "parameters": "()", "modifiers": "public static", "return": "void", "signature": "void usage()", "full_signature": "public static void usage()", "class_method_signature": "OptionsParser.usage()", "testcase": false, "constructor": false}], "file": "conduit-distcp/src/main/java/com/inmobi/conduit/distcp/tools/OptionsParser.java"}, "focal_method": {"identifier": "parse", "parameters": "(String args[])", "modifiers": "public static", "return": "DistCpOptions", "body": "public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n\n    CommandLineParser parser = new CustomParser();\n\n    CommandLine command;\n    try {\n      command = parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option;\n    Path targetPath;\n    List<Path> sourcePaths = new ArrayList<Path>();\n\n    String leftOverArgs[] = command.getArgs();\n    if (leftOverArgs == null || leftOverArgs.length < 1) {\n      throw new IllegalArgumentException(\"Target path not specified\");\n    }\n\n    //Last Argument is the target path\n    targetPath = new Path(leftOverArgs[leftOverArgs.length -1].trim());\n\n    //Copy any source paths in the arguments to the list\n    for (int index = 0; index < leftOverArgs.length - 1; index++) {\n      sourcePaths.add(new Path(leftOverArgs[index].trim()));\n    }\n\n    /* If command has source file listing, use it else, fall back on source paths in args\n       If both are present, throw exception and bail */\n    if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n      if (!sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n      }\n      option = new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n              SOURCE_FILE_LISTING.getSwitch())), targetPath);\n    } else {\n      if (sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n      }\n      option = new DistCpOptions(sourcePaths, targetPath);\n    }\n\n    //Process all the other option switches and set options appropriately\n    if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n      option.setIgnoreFailures(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_SRC_PATH.getSwitch())) {\n      option.setPreserveSrcPath(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n      option.setAtomicCommit(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) &&\n        option.shouldAtomicCommit()) {\n      String workPath = getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath != null && !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");      \n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n      option.setSyncFolder(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n      option.setOverwrite(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n      option.setDeleteMissing(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n      option.setSkipCRC(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        Integer mapBandwidth = Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n        option.setMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH_KB.getSwitch())) {\n      try {\n        Integer mapBandwidth = Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH_KB.getSwitch()).trim());\n        option.setMapBandwidthKB(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH_KB.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n      option.setSslConfigurationFile(command.\n          getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        Integer maps = Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n        option.setMaxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      String attributes =\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n      if (attributes == null || attributes.isEmpty()) {\n        for (FileAttribute attribute : FileAttribute.values()) {\n          option.preserve(attribute);\n        }\n      } else {\n        for (int index = 0; index < attributes.length(); index++) {\n          option.preserve(FileAttribute.\n              getAttribute(attributes.charAt(index)));\n        }\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      String fileLimitString = getVal(command,\n                              DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n      try {\n        Integer.parseInt(fileLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"File-limit is invalid: \"\n                                            + fileLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      String sizeLimitString = getVal(command,\n                              DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n      try {\n        Long.parseLong(sizeLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Size-limit is invalid: \"\n                                            + sizeLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    return option;\n  }", "signature": "DistCpOptions parse(String args[])", "full_signature": "public static DistCpOptions parse(String args[])", "class_method_signature": "OptionsParser.parse(String args[])", "testcase": false, "constructor": false, "invocations": ["parse", "toString", "getArgs", "trim", "add", "trim", "hasOption", "getSwitch", "isEmpty", "getVal", "getSwitch", "isEmpty", "hasOption", "getSwitch", "setIgnoreFailures", "hasOption", "getSwitch", "setPreserveSrcPath", "hasOption", "getSwitch", "setAtomicCommit", "hasOption", "getSwitch", "shouldAtomicCommit", "getVal", "getSwitch", "isEmpty", "setAtomicWorkPath", "hasOption", "getSwitch", "hasOption", "getSwitch", "setLogPath", "getVal", "getSwitch", "hasOption", "getSwitch", "setSyncFolder", "hasOption", "getSwitch", "setOverwrite", "hasOption", "getSwitch", "setDeleteMissing", "hasOption", "getSwitch", "setSkipCRC", "hasOption", "getSwitch", "setBlocking", "hasOption", "getSwitch", "parseInt", "trim", "getVal", "getSwitch", "setMapBandwidth", "getVal", "getSwitch", "hasOption", "getSwitch", "parseInt", "trim", "getVal", "getSwitch", "setMapBandwidthKB", "getVal", "getSwitch", "hasOption", "getSwitch", "setSslConfigurationFile", "getOptionValue", "getSwitch", "hasOption", "getSwitch", "parseInt", "trim", "getVal", "getSwitch", "setMaxMaps", "getVal", "getSwitch", "hasOption", "getSwitch", "setCopyStrategy", "getVal", "getSwitch", "hasOption", "getSwitch", "getVal", "getSwitch", "isEmpty", "values", "preserve", "length", "preserve", "getAttribute", "charAt", "hasOption", "getSwitch", "getVal", "trim", "getSwitch", "parseInt", "warn", "getSwitch", "hasOption", "getSwitch", "getVal", "trim", "getSwitch", "parseLong", "warn", "getSwitch"]}, "repository": {"repo_id": 7218024, "url": "https://github.com/InMobi/conduit", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 9, "size": 49400, "license": "licensed"}}