{"test_class": {"identifier": "FailbackRegistryTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static String service;", "modifier": "static", "type": "String", "declarator": "service", "var_name": "service"}, {"original_string": "static URL serviceUrl;", "modifier": "static", "type": "URL", "declarator": "serviceUrl", "var_name": "serviceUrl"}, {"original_string": "static URL registryUrl;", "modifier": "static", "type": "URL", "declarator": "registryUrl", "var_name": "registryUrl"}, {"original_string": "MockRegistry registry;", "modifier": "", "type": "MockRegistry", "declarator": "registry", "var_name": "registry"}, {"original_string": "private int FAILED_PERIOD = 200;", "modifier": "private", "type": "int", "declarator": "FAILED_PERIOD = 200", "var_name": "FAILED_PERIOD"}, {"original_string": "private int sleeptime = 100;", "modifier": "private", "type": "int", "declarator": "sleeptime = 100", "var_name": "sleeptime"}, {"original_string": "private int trytimes = 5;", "modifier": "private", "type": "int", "declarator": "trytimes = 5", "var_name": "trytimes"}], "file": "dubbo-registry/dubbo-registry-api/src/test/java/com/alibaba/dubbo/registry/support/FailbackRegistryTest.java"}, "test_case": {"identifier": "testDoRetry_nofify", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDoRetry_nofify() throws Exception {\n\n        //Initial value 0\n        final AtomicInteger count = new AtomicInteger(0);\n\n        NotifyListener listner = new NotifyListener() {\n            @Override\n            public void notify(List<URL> urls) {\n                count.incrementAndGet();\n                //The exception is thrown for the first time to see if the back will be called again to incrementAndGet\n                if (count.get() == 1l) {\n                    throw new RuntimeException(\"test exception please ignore\");\n                }\n            }\n        };\n        registry = new MockRegistry(registryUrl, new CountDownLatch(0));\n        registry.subscribe(serviceUrl.setProtocol(Constants.CONSUMER_PROTOCOL).addParameters(CollectionUtils.toStringMap(\"check\", \"false\")), listner);\n\n        assertEquals(1, count.get()); //Make sure that the subscribe call has just been called once count.incrementAndGet after the call is completed\n        //Wait for the timer.\n        for (int i = 0; i < trytimes; i++) {\n            System.out.println(\"failback notify retry ,times:\" + i);\n            if (count.get() == 2)\n                break;\n            Thread.sleep(sleeptime);\n        }\n        assertEquals(2, count.get());\n    }", "signature": "void testDoRetry_nofify()", "full_signature": "@Test public void testDoRetry_nofify()", "class_method_signature": "FailbackRegistryTest.testDoRetry_nofify()", "testcase": true, "constructor": false, "invocations": ["incrementAndGet", "get", "subscribe", "addParameters", "setProtocol", "toStringMap", "assertEquals", "get", "println", "get", "sleep", "assertEquals", "get"]}, "focal_class": {"identifier": "FailbackRegistry", "superclass": "extends AbstractRegistry", "interfaces": "", "fields": [{"original_string": "private final ScheduledExecutorService retryExecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"DubboRegistryFailedRetryTimer\", true));", "modifier": "private final", "type": "ScheduledExecutorService", "declarator": "retryExecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"DubboRegistryFailedRetryTimer\", true))", "var_name": "retryExecutor"}, {"original_string": "private final ScheduledFuture<?> retryFuture;", "modifier": "private final", "type": "ScheduledFuture<?>", "declarator": "retryFuture", "var_name": "retryFuture"}, {"original_string": "private final Set<URL> failedRegistered = new ConcurrentHashSet<URL>();", "modifier": "private final", "type": "Set<URL>", "declarator": "failedRegistered = new ConcurrentHashSet<URL>()", "var_name": "failedRegistered"}, {"original_string": "private final Set<URL> failedUnregistered = new ConcurrentHashSet<URL>();", "modifier": "private final", "type": "Set<URL>", "declarator": "failedUnregistered = new ConcurrentHashSet<URL>()", "var_name": "failedUnregistered"}, {"original_string": "private final ConcurrentMap<URL, Set<NotifyListener>> failedSubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();", "modifier": "private final", "type": "ConcurrentMap<URL, Set<NotifyListener>>", "declarator": "failedSubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>()", "var_name": "failedSubscribed"}, {"original_string": "private final ConcurrentMap<URL, Set<NotifyListener>> failedUnsubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();", "modifier": "private final", "type": "ConcurrentMap<URL, Set<NotifyListener>>", "declarator": "failedUnsubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>()", "var_name": "failedUnsubscribed"}, {"original_string": "private final ConcurrentMap<URL, Map<NotifyListener, List<URL>>> failedNotified = new ConcurrentHashMap<URL, Map<NotifyListener, List<URL>>>();", "modifier": "private final", "type": "ConcurrentMap<URL, Map<NotifyListener, List<URL>>>", "declarator": "failedNotified = new ConcurrentHashMap<URL, Map<NotifyListener, List<URL>>>()", "var_name": "failedNotified"}, {"original_string": "private final int retryPeriod;", "modifier": "private final", "type": "int", "declarator": "retryPeriod", "var_name": "retryPeriod"}], "methods": [{"identifier": "FailbackRegistry", "parameters": "(URL url)", "modifiers": "public", "return": "", "signature": " FailbackRegistry(URL url)", "full_signature": "public  FailbackRegistry(URL url)", "class_method_signature": "FailbackRegistry.FailbackRegistry(URL url)", "testcase": false, "constructor": true}, {"identifier": "getRetryFuture", "parameters": "()", "modifiers": "public", "return": "Future<?>", "signature": "Future<?> getRetryFuture()", "full_signature": "public Future<?> getRetryFuture()", "class_method_signature": "FailbackRegistry.getRetryFuture()", "testcase": false, "constructor": false}, {"identifier": "getFailedRegistered", "parameters": "()", "modifiers": "public", "return": "Set<URL>", "signature": "Set<URL> getFailedRegistered()", "full_signature": "public Set<URL> getFailedRegistered()", "class_method_signature": "FailbackRegistry.getFailedRegistered()", "testcase": false, "constructor": false}, {"identifier": "getFailedUnregistered", "parameters": "()", "modifiers": "public", "return": "Set<URL>", "signature": "Set<URL> getFailedUnregistered()", "full_signature": "public Set<URL> getFailedUnregistered()", "class_method_signature": "FailbackRegistry.getFailedUnregistered()", "testcase": false, "constructor": false}, {"identifier": "getFailedSubscribed", "parameters": "()", "modifiers": "public", "return": "Map<URL, Set<NotifyListener>>", "signature": "Map<URL, Set<NotifyListener>> getFailedSubscribed()", "full_signature": "public Map<URL, Set<NotifyListener>> getFailedSubscribed()", "class_method_signature": "FailbackRegistry.getFailedSubscribed()", "testcase": false, "constructor": false}, {"identifier": "getFailedUnsubscribed", "parameters": "()", "modifiers": "public", "return": "Map<URL, Set<NotifyListener>>", "signature": "Map<URL, Set<NotifyListener>> getFailedUnsubscribed()", "full_signature": "public Map<URL, Set<NotifyListener>> getFailedUnsubscribed()", "class_method_signature": "FailbackRegistry.getFailedUnsubscribed()", "testcase": false, "constructor": false}, {"identifier": "getFailedNotified", "parameters": "()", "modifiers": "public", "return": "Map<URL, Map<NotifyListener, List<URL>>>", "signature": "Map<URL, Map<NotifyListener, List<URL>>> getFailedNotified()", "full_signature": "public Map<URL, Map<NotifyListener, List<URL>>> getFailedNotified()", "class_method_signature": "FailbackRegistry.getFailedNotified()", "testcase": false, "constructor": false}, {"identifier": "addFailedSubscribed", "parameters": "(URL url, NotifyListener listener)", "modifiers": "private", "return": "void", "signature": "void addFailedSubscribed(URL url, NotifyListener listener)", "full_signature": "private void addFailedSubscribed(URL url, NotifyListener listener)", "class_method_signature": "FailbackRegistry.addFailedSubscribed(URL url, NotifyListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeFailedSubscribed", "parameters": "(URL url, NotifyListener listener)", "modifiers": "private", "return": "void", "signature": "void removeFailedSubscribed(URL url, NotifyListener listener)", "full_signature": "private void removeFailedSubscribed(URL url, NotifyListener listener)", "class_method_signature": "FailbackRegistry.removeFailedSubscribed(URL url, NotifyListener listener)", "testcase": false, "constructor": false}, {"identifier": "register", "parameters": "(URL url)", "modifiers": "@Override public", "return": "void", "signature": "void register(URL url)", "full_signature": "@Override public void register(URL url)", "class_method_signature": "FailbackRegistry.register(URL url)", "testcase": false, "constructor": false}, {"identifier": "unregister", "parameters": "(URL url)", "modifiers": "@Override public", "return": "void", "signature": "void unregister(URL url)", "full_signature": "@Override public void unregister(URL url)", "class_method_signature": "FailbackRegistry.unregister(URL url)", "testcase": false, "constructor": false}, {"identifier": "subscribe", "parameters": "(URL url, NotifyListener listener)", "modifiers": "@Override public", "return": "void", "signature": "void subscribe(URL url, NotifyListener listener)", "full_signature": "@Override public void subscribe(URL url, NotifyListener listener)", "class_method_signature": "FailbackRegistry.subscribe(URL url, NotifyListener listener)", "testcase": false, "constructor": false}, {"identifier": "unsubscribe", "parameters": "(URL url, NotifyListener listener)", "modifiers": "@Override public", "return": "void", "signature": "void unsubscribe(URL url, NotifyListener listener)", "full_signature": "@Override public void unsubscribe(URL url, NotifyListener listener)", "class_method_signature": "FailbackRegistry.unsubscribe(URL url, NotifyListener listener)", "testcase": false, "constructor": false}, {"identifier": "notify", "parameters": "(URL url, NotifyListener listener, List<URL> urls)", "modifiers": "@Override protected", "return": "void", "signature": "void notify(URL url, NotifyListener listener, List<URL> urls)", "full_signature": "@Override protected void notify(URL url, NotifyListener listener, List<URL> urls)", "class_method_signature": "FailbackRegistry.notify(URL url, NotifyListener listener, List<URL> urls)", "testcase": false, "constructor": false}, {"identifier": "doNotify", "parameters": "(URL url, NotifyListener listener, List<URL> urls)", "modifiers": "protected", "return": "void", "signature": "void doNotify(URL url, NotifyListener listener, List<URL> urls)", "full_signature": "protected void doNotify(URL url, NotifyListener listener, List<URL> urls)", "class_method_signature": "FailbackRegistry.doNotify(URL url, NotifyListener listener, List<URL> urls)", "testcase": false, "constructor": false}, {"identifier": "recover", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void recover()", "full_signature": "@Override protected void recover()", "class_method_signature": "FailbackRegistry.recover()", "testcase": false, "constructor": false}, {"identifier": "retry", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void retry()", "full_signature": "protected void retry()", "class_method_signature": "FailbackRegistry.retry()", "testcase": false, "constructor": false}, {"identifier": "destroy", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void destroy()", "full_signature": "@Override public void destroy()", "class_method_signature": "FailbackRegistry.destroy()", "testcase": false, "constructor": false}, {"identifier": "doRegister", "parameters": "(URL url)", "modifiers": "protected abstract", "return": "void", "signature": "void doRegister(URL url)", "full_signature": "protected abstract void doRegister(URL url)", "class_method_signature": "FailbackRegistry.doRegister(URL url)", "testcase": false, "constructor": false}, {"identifier": "doUnregister", "parameters": "(URL url)", "modifiers": "protected abstract", "return": "void", "signature": "void doUnregister(URL url)", "full_signature": "protected abstract void doUnregister(URL url)", "class_method_signature": "FailbackRegistry.doUnregister(URL url)", "testcase": false, "constructor": false}, {"identifier": "doSubscribe", "parameters": "(URL url, NotifyListener listener)", "modifiers": "protected abstract", "return": "void", "signature": "void doSubscribe(URL url, NotifyListener listener)", "full_signature": "protected abstract void doSubscribe(URL url, NotifyListener listener)", "class_method_signature": "FailbackRegistry.doSubscribe(URL url, NotifyListener listener)", "testcase": false, "constructor": false}, {"identifier": "doUnsubscribe", "parameters": "(URL url, NotifyListener listener)", "modifiers": "protected abstract", "return": "void", "signature": "void doUnsubscribe(URL url, NotifyListener listener)", "full_signature": "protected abstract void doUnsubscribe(URL url, NotifyListener listener)", "class_method_signature": "FailbackRegistry.doUnsubscribe(URL url, NotifyListener listener)", "testcase": false, "constructor": false}], "file": "dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/FailbackRegistry.java"}, "focal_method": {"identifier": "subscribe", "parameters": "(URL url, NotifyListener listener)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void subscribe(URL url, NotifyListener listener) {\n        super.subscribe(url, listener);\n        removeFailedSubscribed(url, listener);\n        try {\n            // \u5411\u670d\u52a1\u5668\u7aef\u53d1\u9001\u8ba2\u9605\u8bf7\u6c42\n            doSubscribe(url, listener);\n        } catch (Exception e) {\n            Throwable t = e;\n\n            List<URL> urls = getCacheUrls(url);\n            if (urls != null && !urls.isEmpty()) {\n                notify(url, listener, urls);\n                logger.error(\"Failed to subscribe \" + url + \", Using cached list: \" + urls + \" from cache file: \" + getUrl().getParameter(Constants.FILE_KEY, System.getProperty(\"user.home\") + \"/dubbo-registry-\" + url.getHost() + \".cache\") + \", cause: \" + t.getMessage(), t);\n            } else {\n                // If the startup detection is opened, the Exception is thrown directly.\n                boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                        && url.getParameter(Constants.CHECK_KEY, true);\n                boolean skipFailback = t instanceof SkipFailbackWrapperException;\n                if (check || skipFailback) {\n                    if (skipFailback) {\n                        t = t.getCause();\n                    }\n                    throw new IllegalStateException(\"Failed to subscribe \" + url + \", cause: \" + t.getMessage(), t);\n                } else {\n                    logger.error(\"Failed to subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n                }\n            }\n\n            // Record a failed registration request to a failed list, retry regularly\n            addFailedSubscribed(url, listener);\n        }\n    }", "signature": "void subscribe(URL url, NotifyListener listener)", "full_signature": "@Override public void subscribe(URL url, NotifyListener listener)", "class_method_signature": "FailbackRegistry.subscribe(URL url, NotifyListener listener)", "testcase": false, "constructor": false, "invocations": ["subscribe", "removeFailedSubscribed", "doSubscribe", "getCacheUrls", "isEmpty", "notify", "error", "getParameter", "getUrl", "getProperty", "getHost", "getMessage", "getParameter", "getUrl", "getParameter", "getCause", "getMessage", "error", "getMessage", "addFailedSubscribed"]}, "repository": {"repo_id": 189562861, "url": "https://github.com/smallFive55/dubbo-dubbo-2.6.6", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 8, "size": 1428, "license": "licensed"}}