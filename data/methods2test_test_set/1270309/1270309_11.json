{"test_class": {"identifier": "OverlayUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "apps/dcm4che/dcm4che-2.0.25-src/dcm4che-image/src/test/java/org/dcm4che2/image/OverlayUtilsTest.java"}, "test_case": {"identifier": "padToFixRowByteBoundary_WhenInputIs5BytesRows5Cols7_ShouldPadCorrectly", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void padToFixRowByteBoundary_WhenInputIs5BytesRows5Cols7_ShouldPadCorrectly() {\n        byte[] inputArray = new byte[] { (byte) 0xAB, (byte)0xCD, (byte) 0xEF, (byte) 0xBA, (byte) 0xDC}; \n        byte[] expectedArray = new byte[] { (byte) 0xAB, (byte)0x9B, (byte) 0xBF, (byte) 0xD7, (byte) 0xCB}; \n        byte[] actualArray = OverlayUtils.padToFixRowByteBoundary(inputArray, 5, 7);\n        \n        checkArrays(expectedArray, actualArray);\n    }", "signature": "void padToFixRowByteBoundary_WhenInputIs5BytesRows5Cols7_ShouldPadCorrectly()", "full_signature": "@Test public void padToFixRowByteBoundary_WhenInputIs5BytesRows5Cols7_ShouldPadCorrectly()", "class_method_signature": "OverlayUtilsTest.padToFixRowByteBoundary_WhenInputIs5BytesRows5Cols7_ShouldPadCorrectly()", "testcase": true, "constructor": false, "invocations": ["padToFixRowByteBoundary", "checkArrays"]}, "focal_class": {"identifier": "OverlayUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int BITS_PER_BYTE = 8;", "modifier": "private static final", "type": "int", "declarator": "BITS_PER_BYTE = 8", "var_name": "BITS_PER_BYTE"}, {"original_string": "private static LookupTable reorderBytes;", "modifier": "private static", "type": "LookupTable", "declarator": "reorderBytes", "var_name": "reorderBytes"}, {"original_string": "private static byte[] rgbArr = new byte[] { (byte) 0xFF, 0 };", "modifier": "private static", "type": "byte[]", "declarator": "rgbArr = new byte[] { (byte) 0xFF, 0 }", "var_name": "rgbArr"}, {"original_string": "private static byte[] aArr = new byte[] { (byte) 0x00, (byte) 0xFF };", "modifier": "private static", "type": "byte[]", "declarator": "aArr = new byte[] { (byte) 0x00, (byte) 0xFF }", "var_name": "aArr"}], "methods": [{"identifier": "isOverlay", "parameters": "(int imageIndex)", "modifiers": "public static", "return": "boolean", "signature": "boolean isOverlay(int imageIndex)", "full_signature": "public static boolean isOverlay(int imageIndex)", "class_method_signature": "OverlayUtils.isOverlay(int imageIndex)", "testcase": false, "constructor": false}, {"identifier": "extractFrameNumber", "parameters": "(int imageIndex)", "modifiers": "public static", "return": "int", "signature": "int extractFrameNumber(int imageIndex)", "full_signature": "public static int extractFrameNumber(int imageIndex)", "class_method_signature": "OverlayUtils.extractFrameNumber(int imageIndex)", "testcase": false, "constructor": false}, {"identifier": "extractOverlay", "parameters": "(DicomObject ds,\n            int overlayNumber, ImageReader reader, String rgbs)", "modifiers": "public static", "return": "BufferedImage", "signature": "BufferedImage extractOverlay(DicomObject ds,\n            int overlayNumber, ImageReader reader, String rgbs)", "full_signature": "public static BufferedImage extractOverlay(DicomObject ds,\n            int overlayNumber, ImageReader reader, String rgbs)", "class_method_signature": "OverlayUtils.extractOverlay(DicomObject ds,\n            int overlayNumber, ImageReader reader, String rgbs)", "testcase": false, "constructor": false}, {"identifier": "padToFixRowByteBoundary", "parameters": "(byte[] unpaddedData, int rows, int cols)", "modifiers": "protected static", "return": "byte[]", "signature": "byte[] padToFixRowByteBoundary(byte[] unpaddedData, int rows, int cols)", "full_signature": "protected static byte[] padToFixRowByteBoundary(byte[] unpaddedData, int rows, int cols)", "class_method_signature": "OverlayUtils.padToFixRowByteBoundary(byte[] unpaddedData, int rows, int cols)", "testcase": false, "constructor": false}, {"identifier": "getOverlayWidth", "parameters": "(DicomObject ds, int overlayNumber)", "modifiers": "public static", "return": "int", "signature": "int getOverlayWidth(DicomObject ds, int overlayNumber)", "full_signature": "public static int getOverlayWidth(DicomObject ds, int overlayNumber)", "class_method_signature": "OverlayUtils.getOverlayWidth(DicomObject ds, int overlayNumber)", "testcase": false, "constructor": false}, {"identifier": "getOverlayHeight", "parameters": "(DicomObject ds, int overlayNumber)", "modifiers": "public static", "return": "int", "signature": "int getOverlayHeight(DicomObject ds, int overlayNumber)", "full_signature": "public static int getOverlayHeight(DicomObject ds, int overlayNumber)", "class_method_signature": "OverlayUtils.getOverlayHeight(DicomObject ds, int overlayNumber)", "testcase": false, "constructor": false}], "file": "apps/dcm4che/dcm4che-2.0.25-src/dcm4che-image/src/main/java/org/dcm4che2/image/OverlayUtils.java"}, "focal_method": {"identifier": "padToFixRowByteBoundary", "parameters": "(byte[] unpaddedData, int rows, int cols)", "modifiers": "protected static", "return": "byte[]", "body": "protected static byte[] padToFixRowByteBoundary(byte[] unpaddedData, int rows, int cols) {\n        int numRowBytes = (cols+7)/8;\n        int paddedLength = rows * numRowBytes;\n        if( (unpaddedData.length == paddedLength ) && (cols%8)==0 ) return unpaddedData;\n        \n        byte[] data = new byte[paddedLength];\n        \n        for(int y=0; y<rows; y++) {\n            int posnPad = y*numRowBytes;\n            int posnUnpad = y*cols;\n            // Bits from the current byte needed\n            int bits = posnUnpad % 8;\n            posnUnpad /= 8;\n            int prevBits = 8-bits;\n            if( bits==0 ) {\n                // Not only an optimization for performance - also prevents an exception if the last pixel doesn't need \n                // to overflow from the next unpadded byte...\n                System.arraycopy(unpaddedData,posnUnpad,data, posnPad, numRowBytes);\n                continue;\n            }\n            int mask = (0xFF << bits) & 0xFF;\n            int nextMask = (0xFF >> prevBits) & 0xFF;\n            for(int x=0; x<numRowBytes; x++) {\n                try {\n                    byte firstByte = (byte) ((unpaddedData[posnUnpad+x] & mask)>>bits);\n                    byte secondByte = 0;\n                    // The very last byte can use nothing from the next byte if there are unused bits in it\n                    if( posnUnpad+x+1 < unpaddedData.length ) secondByte = (byte) ((unpaddedData[posnUnpad+x+1] & nextMask) << prevBits);\n                    data[posnPad+x] = (byte) (firstByte | secondByte);\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    ArrayIndexOutOfBoundsException newEx = new ArrayIndexOutOfBoundsException(\n                            \"Did not find enough source data (\"+unpaddedData.length+\") in overlay to pad data for \" \n                            + rows + \" rows, \" \n                            + cols + \"columns\");\n                    newEx.initCause(e);\n                    throw newEx;\n                }\n            }\n        }\n        \n        return data;\n    }", "signature": "byte[] padToFixRowByteBoundary(byte[] unpaddedData, int rows, int cols)", "full_signature": "protected static byte[] padToFixRowByteBoundary(byte[] unpaddedData, int rows, int cols)", "class_method_signature": "OverlayUtils.padToFixRowByteBoundary(byte[] unpaddedData, int rows, int cols)", "testcase": false, "constructor": false, "invocations": ["arraycopy", "initCause"]}, "repository": {"repo_id": 1270309, "url": "https://github.com/curasystems/externals", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 5, "size": 87603, "license": "licensed"}}