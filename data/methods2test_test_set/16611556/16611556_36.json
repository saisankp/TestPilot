{"test_class": {"identifier": "JsonTranscoderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private JsonTranscoder transcoder;", "modifier": "private", "type": "JsonTranscoder", "declarator": "transcoder", "var_name": "transcoder"}], "file": "simple-spring-memcached/src/test/java/com/google/code/ssm/transcoders/JsonTranscoderTest.java"}, "test_case": {"identifier": "testEncodeAndDecodeWithCustomSerializer", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testEncodeAndDecodeWithCustomSerializer() {\n        JsonObjectMapper mapper = new JsonObjectMapper();\n\n        Map<Class<?>, JsonSerializer<?>> serializers = new HashMap<Class<?>, JsonSerializer<?>>();\n        serializers.put(Point.class, new PointSerializer());\n        mapper.setSerializers(serializers);\n\n        transcoder = new JsonTranscoder(mapper);\n\n        Point p = new Point(40, 50);\n\n        // it won't be possible to deserialize it because no custom deserializer is registered and serialized data\n        // doesn't contain info about class (type of serialized object), so the Jackson cannot figure out what\n        // deserializer should be used\n        CachedObject co = transcoder.encode(p);\n        assertNotNull(co);\n        assertNotNull(co.getData());\n        assertEquals(\"{\\\"v\\\":\\\"40x50\\\"}\", new String(co.getData()));\n    }", "signature": "void testEncodeAndDecodeWithCustomSerializer()", "full_signature": "@Test public void testEncodeAndDecodeWithCustomSerializer()", "class_method_signature": "JsonTranscoderTest.testEncodeAndDecodeWithCustomSerializer()", "testcase": true, "constructor": false, "invocations": ["put", "setSerializers", "encode", "assertNotNull", "assertNotNull", "getData", "assertEquals", "getData"]}, "focal_class": {"identifier": "JsonTranscoder", "superclass": "", "interfaces": "implements CacheTranscoder", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(JsonTranscoder.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(JsonTranscoder.class)", "var_name": "LOGGER"}, {"original_string": "private static final int JSON_SERIALIZED = 8;", "modifier": "private static final", "type": "int", "declarator": "JSON_SERIALIZED = 8", "var_name": "JSON_SERIALIZED"}, {"original_string": "@Getter\n    private final ObjectMapper mapper;", "modifier": "@Getter\n    private final", "type": "ObjectMapper", "declarator": "mapper", "var_name": "mapper"}], "methods": [{"identifier": "JsonTranscoder", "parameters": "(final ObjectMapper mapper)", "modifiers": "public", "return": "", "signature": " JsonTranscoder(final ObjectMapper mapper)", "full_signature": "public  JsonTranscoder(final ObjectMapper mapper)", "class_method_signature": "JsonTranscoder.JsonTranscoder(final ObjectMapper mapper)", "testcase": false, "constructor": true}, {"identifier": "asyncDecode", "parameters": "(final CachedObject data)", "modifiers": "public", "return": "boolean", "signature": "boolean asyncDecode(final CachedObject data)", "full_signature": "public boolean asyncDecode(final CachedObject data)", "class_method_signature": "JsonTranscoder.asyncDecode(final CachedObject data)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(final CachedObject data)", "modifiers": "@Override public", "return": "Object", "signature": "Object decode(final CachedObject data)", "full_signature": "@Override public Object decode(final CachedObject data)", "class_method_signature": "JsonTranscoder.decode(final CachedObject data)", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(final Object o)", "modifiers": "@Override public", "return": "CachedObject", "signature": "CachedObject encode(final Object o)", "full_signature": "@Override public CachedObject encode(final Object o)", "class_method_signature": "JsonTranscoder.encode(final Object o)", "testcase": false, "constructor": false}, {"identifier": "getMaxSize", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMaxSize()", "full_signature": "public int getMaxSize()", "class_method_signature": "JsonTranscoder.getMaxSize()", "testcase": false, "constructor": false}], "file": "simple-spring-memcached/src/main/java/com/google/code/ssm/transcoders/JsonTranscoder.java"}, "focal_method": {"identifier": "encode", "parameters": "(final Object o)", "modifiers": "@Override public", "return": "CachedObject", "body": "@Override\n    public CachedObject encode(final Object o) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        try {\n            mapper.writeValue(baos, new Holder(o));\n            return new CachedObjectImpl(JSON_SERIALIZED, baos.toByteArray());\n        } catch (IOException e) {\n            LOGGER.warn(String.format(\"Error serializing object %s\", o), e);\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                baos.close();\n            } catch (IOException e) {\n                LOGGER.warn(\"Error while closing stream\", e);\n            }\n        }\n    }", "signature": "CachedObject encode(final Object o)", "full_signature": "@Override public CachedObject encode(final Object o)", "class_method_signature": "JsonTranscoder.encode(final Object o)", "testcase": false, "constructor": false, "invocations": ["writeValue", "toByteArray", "warn", "format", "close", "warn"]}, "repository": {"repo_id": 16611556, "url": "https://github.com/ragnor/simple-spring-memcached", "language": "Java", "is_fork": false, "fork_count": 86, "stargazer_count": 181, "size": 3625, "license": "licensed"}}