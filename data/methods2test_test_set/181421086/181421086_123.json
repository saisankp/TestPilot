{"test_class": {"identifier": "IPv6Test", "superclass": "", "interfaces": "", "fields": [], "file": "src/agents/apps/floodlight/floodlight-1.2/src/test/java/net/floodlightcontroller/packet/IPv6Test.java"}, "test_case": {"identifier": "testDeserialize", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDeserialize() throws PacketParsingException {\n        byte[] spudPacket = {\n                0x64, 0x2B, 0x16, (byte) 0x95, 0x00, 0x15,\n                0x11, (byte) 0xE1, (byte) 0xFE, (byte) 0x80,\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x7A, (byte) 0xC5, (byte) 0xFF, (byte) 0xFE,\n                0x2E, 0x77, 0x35, (byte) 0xFE, (byte) 0x80,\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x77, 0x5D, (byte) 0xFF, (byte) 0xFE,\n                (byte) 0xC2, 0x30, (byte) 0xFD, (byte) 0xD2,\n                0x01, 0x05, 0x7A, 0x00, 0x15, (byte) 0xF6,\n                (byte) 0xC8, (byte) 0xD8, 0x00, 0x00,\n                (byte) 0xD8, 0x4A, (byte) 0xC3, (byte) 0xF2,\n                0x02, 0x44, 0x75, (byte) 0x97, 0x69, 0x40\n        };\n        IPv6 packet = new IPv6();\n        packet.deserialize(spudPacket, 0, spudPacket.length);\n        byte[] packetSerialized = packet.serialize();\n        assertTrue(Arrays.equals(spudPacket, packetSerialized));\n    }", "signature": "void testDeserialize()", "full_signature": "@Test public void testDeserialize()", "class_method_signature": "IPv6Test.testDeserialize()", "testcase": true, "constructor": false, "invocations": ["deserialize", "serialize", "assertTrue", "equals"]}, "focal_class": {"identifier": "IPv6", "superclass": "extends BasePacket", "interfaces": "", "fields": [{"original_string": "public static Map<IpProtocol, Class<? extends IPacket>> nextHeaderClassMap;", "modifier": "public static", "type": "Map<IpProtocol, Class<? extends IPacket>>", "declarator": "nextHeaderClassMap", "var_name": "nextHeaderClassMap"}, {"original_string": "public static final int HEADER_LENGTH = 40;", "modifier": "public static final", "type": "int", "declarator": "HEADER_LENGTH = 40", "var_name": "HEADER_LENGTH"}, {"original_string": "protected byte version;", "modifier": "protected", "type": "byte", "declarator": "version", "var_name": "version"}, {"original_string": "protected byte trafficClass;", "modifier": "protected", "type": "byte", "declarator": "trafficClass", "var_name": "trafficClass"}, {"original_string": "protected int flowLabel;", "modifier": "protected", "type": "int", "declarator": "flowLabel", "var_name": "flowLabel"}, {"original_string": "protected short payloadLength;", "modifier": "protected", "type": "short", "declarator": "payloadLength", "var_name": "payloadLength"}, {"original_string": "protected IpProtocol nextHeader;", "modifier": "protected", "type": "IpProtocol", "declarator": "nextHeader", "var_name": "nextHeader"}, {"original_string": "protected byte hopLimit;", "modifier": "protected", "type": "byte", "declarator": "hopLimit", "var_name": "hopLimit"}, {"original_string": "protected IPv6Address sourceAddress;", "modifier": "protected", "type": "IPv6Address", "declarator": "sourceAddress", "var_name": "sourceAddress"}, {"original_string": "protected IPv6Address destinationAddress;", "modifier": "protected", "type": "IPv6Address", "declarator": "destinationAddress", "var_name": "destinationAddress"}], "methods": [{"identifier": "IPv6", "parameters": "()", "modifiers": "public", "return": "", "signature": " IPv6()", "full_signature": "public  IPv6()", "class_method_signature": "IPv6.IPv6()", "testcase": false, "constructor": true}, {"identifier": "getVersion", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getVersion()", "full_signature": "public byte getVersion()", "class_method_signature": "IPv6.getVersion()", "testcase": false, "constructor": false}, {"identifier": "setVersion", "parameters": "(byte version)", "modifiers": "public", "return": "IPv6", "signature": "IPv6 setVersion(byte version)", "full_signature": "public IPv6 setVersion(byte version)", "class_method_signature": "IPv6.setVersion(byte version)", "testcase": false, "constructor": false}, {"identifier": "getTrafficClass", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getTrafficClass()", "full_signature": "public byte getTrafficClass()", "class_method_signature": "IPv6.getTrafficClass()", "testcase": false, "constructor": false}, {"identifier": "setTrafficClass", "parameters": "(byte trafficClass)", "modifiers": "public", "return": "IPv6", "signature": "IPv6 setTrafficClass(byte trafficClass)", "full_signature": "public IPv6 setTrafficClass(byte trafficClass)", "class_method_signature": "IPv6.setTrafficClass(byte trafficClass)", "testcase": false, "constructor": false}, {"identifier": "getFlowLabel", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getFlowLabel()", "full_signature": "public int getFlowLabel()", "class_method_signature": "IPv6.getFlowLabel()", "testcase": false, "constructor": false}, {"identifier": "setFlowLabel", "parameters": "(int flowLabel)", "modifiers": "public", "return": "IPv6", "signature": "IPv6 setFlowLabel(int flowLabel)", "full_signature": "public IPv6 setFlowLabel(int flowLabel)", "class_method_signature": "IPv6.setFlowLabel(int flowLabel)", "testcase": false, "constructor": false}, {"identifier": "getPayloadLength", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getPayloadLength()", "full_signature": "public short getPayloadLength()", "class_method_signature": "IPv6.getPayloadLength()", "testcase": false, "constructor": false}, {"identifier": "setPayloadLength", "parameters": "(short payloadLength)", "modifiers": "public", "return": "IPv6", "signature": "IPv6 setPayloadLength(short payloadLength)", "full_signature": "public IPv6 setPayloadLength(short payloadLength)", "class_method_signature": "IPv6.setPayloadLength(short payloadLength)", "testcase": false, "constructor": false}, {"identifier": "getNextHeader", "parameters": "()", "modifiers": "public", "return": "IpProtocol", "signature": "IpProtocol getNextHeader()", "full_signature": "public IpProtocol getNextHeader()", "class_method_signature": "IPv6.getNextHeader()", "testcase": false, "constructor": false}, {"identifier": "setNextHeader", "parameters": "(IpProtocol nextHeader)", "modifiers": "public", "return": "IPv6", "signature": "IPv6 setNextHeader(IpProtocol nextHeader)", "full_signature": "public IPv6 setNextHeader(IpProtocol nextHeader)", "class_method_signature": "IPv6.setNextHeader(IpProtocol nextHeader)", "testcase": false, "constructor": false}, {"identifier": "getHopLimit", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getHopLimit()", "full_signature": "public byte getHopLimit()", "class_method_signature": "IPv6.getHopLimit()", "testcase": false, "constructor": false}, {"identifier": "setHopLimit", "parameters": "(byte hopLimit)", "modifiers": "public", "return": "IPv6", "signature": "IPv6 setHopLimit(byte hopLimit)", "full_signature": "public IPv6 setHopLimit(byte hopLimit)", "class_method_signature": "IPv6.setHopLimit(byte hopLimit)", "testcase": false, "constructor": false}, {"identifier": "getSourceAddress", "parameters": "()", "modifiers": "public", "return": "IPv6Address", "signature": "IPv6Address getSourceAddress()", "full_signature": "public IPv6Address getSourceAddress()", "class_method_signature": "IPv6.getSourceAddress()", "testcase": false, "constructor": false}, {"identifier": "setSourceAddress", "parameters": "(IPv6Address sourceAddress)", "modifiers": "public", "return": "IPv6", "signature": "IPv6 setSourceAddress(IPv6Address sourceAddress)", "full_signature": "public IPv6 setSourceAddress(IPv6Address sourceAddress)", "class_method_signature": "IPv6.setSourceAddress(IPv6Address sourceAddress)", "testcase": false, "constructor": false}, {"identifier": "getDestinationAddress", "parameters": "()", "modifiers": "public", "return": "IPv6Address", "signature": "IPv6Address getDestinationAddress()", "full_signature": "public IPv6Address getDestinationAddress()", "class_method_signature": "IPv6.getDestinationAddress()", "testcase": false, "constructor": false}, {"identifier": "setDestinationAddress", "parameters": "(IPv6Address destinationAddress)", "modifiers": "public", "return": "IPv6", "signature": "IPv6 setDestinationAddress(IPv6Address destinationAddress)", "full_signature": "public IPv6 setDestinationAddress(IPv6Address destinationAddress)", "class_method_signature": "IPv6.setDestinationAddress(IPv6Address destinationAddress)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "()", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] serialize()", "full_signature": "@Override public byte[] serialize()", "class_method_signature": "IPv6.serialize()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "IPv6.toString()", "testcase": false, "constructor": false}, {"identifier": "deserialize", "parameters": "(byte[] data, int offset, int length)", "modifiers": "@Override public", "return": "IPacket", "signature": "IPacket deserialize(byte[] data, int offset, int length)", "full_signature": "@Override public IPacket deserialize(byte[] data, int offset, int length)", "class_method_signature": "IPv6.deserialize(byte[] data, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "IPv6.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "IPv6.equals(Object obj)", "testcase": false, "constructor": false}], "file": "src/agents/apps/floodlight/floodlight-1.2/src/main/java/net/floodlightcontroller/packet/IPv6.java"}, "focal_method": {"identifier": "deserialize", "parameters": "(byte[] data, int offset, int length)", "modifiers": "@Override public", "return": "IPacket", "body": "@Override\n\tpublic IPacket deserialize(byte[] data, int offset, int length)\n\t\t\tthrows PacketParsingException {\n\t\t// Wrap the data in a byte buffer for easier retrieval.\n\t\tByteBuffer bb = ByteBuffer.wrap(data, offset, length);\n\t\t// Retrieve values from IPv6 header.\n\t\tbyte firstByte = bb.get();\n\t\tbyte secondByte = bb.get();\n\t\tthis.version = (byte) ((firstByte & 0xF0) >>> 4);\n\t\tif (this.version != 6) {\n\t\t\tthrow new PacketParsingException(\n\t\t\t\t\t\"Invalid version for IPv6 packet: \" +\n\t\t\t\t\t\t\tthis.version);\n\t\t}\n\t\tthis.trafficClass = (byte) (((firstByte & 0xF) << 4) |\n\t\t\t\t((secondByte & 0xF0) >>> 4));\n\t\tthis.flowLabel = ((secondByte & 0xF) << 16) |\n\t\t\t\t(bb.getShort() & 0xFFFF);\n\t\tthis.payloadLength = bb.getShort();\n\t\tthis.nextHeader = IpProtocol.of(bb.get());\n\t\tthis.hopLimit = bb.get();\n\t\tbyte[] sourceAddress = new byte[16];\n\t\tbb.get(sourceAddress, 0, 16);\n\t\tbyte[] destinationAddress = new byte[16];\n\t\tbb.get(destinationAddress, 0, 16);\n\t\tthis.sourceAddress = IPv6Address.of(sourceAddress);\n\t\tthis.destinationAddress = IPv6Address.of(destinationAddress);\n\t\t// Retrieve the payload, if possible.\n\t\tIPacket payload;\n\t\tif (IPv6.nextHeaderClassMap.containsKey(this.nextHeader)) {\n\t\t\tClass<? extends IPacket> clazz = IPv6.nextHeaderClassMap.get(this.nextHeader);\n\t\t\ttry {\n\t\t\t\tpayload = clazz.newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException(\"Error parsing payload for IPv6 packet\", e);\n\t\t\t}\n\t\t} else {\n\t\t\tpayload = new Data();\n\t\t}\n\t\t// Deserialize as much of the payload as we can (hopefully all of it).\n\t\tthis.payload = payload.deserialize(data, bb.position(),\n\t\t\t\tMath.min(this.payloadLength, bb.limit() - bb.position()));\n\t\tthis.payload.setParent(this);\n\t\t// We're done!\n\t\treturn this;\n\t}", "signature": "IPacket deserialize(byte[] data, int offset, int length)", "full_signature": "@Override public IPacket deserialize(byte[] data, int offset, int length)", "class_method_signature": "IPv6.deserialize(byte[] data, int offset, int length)", "testcase": false, "constructor": false, "invocations": ["wrap", "get", "get", "getShort", "getShort", "of", "get", "get", "get", "get", "of", "of", "containsKey", "get", "newInstance", "deserialize", "position", "min", "limit", "position", "setParent"]}, "repository": {"repo_id": 181421086, "url": "https://github.com/seungsoo-lee/DELTA", "language": "Java", "is_fork": false, "fork_count": 10, "stargazer_count": 35, "size": 99244, "license": "licensed"}}