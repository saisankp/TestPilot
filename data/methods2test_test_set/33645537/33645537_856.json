{"test_class": {"identifier": "Level1MergerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static String testDir = TestUtil.TEST_BASE_DIR + \"sdb/unit/level_1_merger_test\";", "modifier": "private static", "type": "String", "declarator": "testDir = TestUtil.TEST_BASE_DIR + \"sdb/unit/level_1_merger_test\"", "var_name": "testDir"}], "file": "zava/src/test/java/com/ctriposs/sdb/merge/Level1MergerTest.java"}, "test_case": {"identifier": "testCase02", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testCase02() throws IOException, ClassNotFoundException {\n\t\tint maxSize = AbstractMapTable.INIT_INDEX_ITEMS_PER_TABLE * 4 * 4;\n\t\t//int maxSize = 1024;\n\t\t\n\t\tMMFMapTable[] sourceTables = new MMFMapTable[3];\n\t\tLevelQueue lq1 = new LevelQueue();\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tsourceTables[i] = new MMFMapTable(testDir, SDB.LEVEL1, System.nanoTime() + i, maxSize / 4, 4);\n\t\t\tlq1.addFirst(sourceTables[i]);\n\t\t}\n\t\t\n\t\t// delete\n\t\tMMFMapTable table3 = sourceTables[2];\n\t\tint start = 0;\n\t\tList<String> keyList = new ArrayList<String>();\n\t\twhile(start < maxSize) {\n\t\t\tkeyList.add(String.valueOf(start));\n\t\t\tstart = start + 4;\n\t\t}\n\t\tCollections.sort(keyList, new Comparator<String>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(String arg0, String arg1) {\n\t\t\t\tint hash0 = Arrays.hashCode(arg0.getBytes());\n\t\t\t\tint hash1 = Arrays.hashCode(arg1.getBytes());\n\t\t\t\tif (hash0 < hash1) return -1;\n\t\t\t\telse if (hash0 > hash1) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tfor(String key : keyList) {\n\t\t\ttable3.appendNew(key.getBytes(), Arrays.hashCode(key.getBytes()), key.getBytes(), AbstractMapTable.NO_TIMEOUT, System.currentTimeMillis(), true, false);\n\t\t}\n\t\t\n\t\t// expiration\n\t\tMMFMapTable table2 = sourceTables[1];\n\t\tstart = 1;\n\t\tkeyList = new ArrayList<String>();\n\t\twhile(start < maxSize) {\n\t\t\tkeyList.add(String.valueOf(start));\n\t\t\tstart = start + 4;\n\t\t}\n\t\t\n\t\tCollections.sort(keyList, new Comparator<String>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(String arg0, String arg1) {\n\t\t\t\tint hash0 = Arrays.hashCode(arg0.getBytes());\n\t\t\t\tint hash1 = Arrays.hashCode(arg1.getBytes());\n\t\t\t\tif (hash0 < hash1) return -1;\n\t\t\t\telse if (hash0 > hash1) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tfor(String key : keyList) {\n\t\t\ttable2.appendNew(key.getBytes(), Arrays.hashCode(key.getBytes()), key.getBytes(), 200, System.currentTimeMillis(), false, false);\n\t\t}\n\t\t\n\t\t// expire table2\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\t// ignore\n\t\t}\n\t\t\n\t\t\n\t\t// time to live 60 sec\n\t\tMMFMapTable table1 = sourceTables[0];\n\t\tstart = 2;\n\t\tkeyList = new ArrayList<String>();\n\t\twhile(start < maxSize) {\n\t\t\tkeyList.add(String.valueOf(start));\n\t\t\tstart = start + 4;\n\t\t}\n\t\t\n\t\tCollections.sort(keyList, new Comparator<String>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(String arg0, String arg1) {\n\t\t\t\tint hash0 = Arrays.hashCode(arg0.getBytes());\n\t\t\t\tint hash1 = Arrays.hashCode(arg1.getBytes());\n\t\t\t\tif (hash0 < hash1) return -1;\n\t\t\t\telse if (hash0 > hash1) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tfor(String key : keyList) {\n\t\t\ttable1.appendNew(key.getBytes(), Arrays.hashCode(key.getBytes()), key.getBytes(), 600 * 1000, System.currentTimeMillis(), false, false);\n\t\t}\n\t\t\n\t\t//int expectedInserts = (int)(table1.getAppendedSize() + table2.getAppendedSize() + table3.getAppendedSize());\n\t\tFCMapTable table4 = new FCMapTable(testDir, SDB.LEVEL2, System.nanoTime() + 3, maxSize);\n\t\t\n\t\tstart = 0;\n\t\tkeyList = new ArrayList<String>();\n\t\twhile(start < maxSize) {\n\t\t\tkeyList.add(String.valueOf(start));\n\t\t\tstart = start + 1;\n\t\t}\n\t\t\n\t\tCollections.sort(keyList, new Comparator<String>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(String arg0, String arg1) {\n\t\t\t\tint hash0 = Arrays.hashCode(arg0.getBytes());\n\t\t\t\tint hash1 = Arrays.hashCode(arg1.getBytes());\n\t\t\t\tif (hash0 < hash1) return -1;\n\t\t\t\telse if (hash0 > hash1) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tfor(String key : keyList) {\n\t\t\ttable4.appendNew(key.getBytes(), Arrays.hashCode(key.getBytes()), key.getBytes(), 1200 * 1000, System.currentTimeMillis(), false, false);\n\t\t}\n\t\t\n\t\tLevelQueue lq2 = new LevelQueue();\n\t\tlq2.add(table4);\n\t\t\n\t\tLevel1Merger.mergeSort(lq1, lq2, 4, testDir, (short)2);\n\t\t\n\t\tassertTrue(lq1.size() == 0);\n\t\tassertTrue(lq2.size() == 1);\n\t\tFCMapTable targetTable = (FCMapTable) lq2.poll();\n\n\t\tSystem.out.println(targetTable.getAppendedSize() + \"==\" + maxSize / 2);\n\t\tassertTrue(targetTable.getAppendedSize() == maxSize / 2);\n\t\t\n\t\t/*\n\t\t// validate delete\n\t\tstart = 0;\n\t\twhile(start < maxSize) {\n\t\t\tGetResult result = targetTable.get(String.valueOf(start).getBytes());\n\t\t\tassertFalse(result.isFound());\n\t\t\tstart += 4;\n\t\t}\n\t\t\n\t\t// validate expiration\n\t\tstart = 1;\n\t\twhile(start < maxSize) {\n\t\t\tGetResult result = targetTable.get(String.valueOf(start).getBytes());\n\t\t\tassertFalse(result.isFound());\n\t\t\tstart += 4;\n\t\t}\n\t\t\n\t\t// validate ttl 60s\n\t\tstart = 2;\n\t\twhile(start < maxSize) {\n\t\t\tGetResult result = targetTable.get(String.valueOf(start).getBytes());\n\t\t\tassertTrue(result.isFound());\n\t\t\tassertTrue(result.getTimeToLive() == 600 * 1000);\n\t\t\tstart += 4;\n\t\t}\n\t\t\n\t\t// validate ttl 120s\n\t\tstart = 3;\n\t\twhile(start < maxSize) {\n\t\t\tGetResult result = targetTable.get(String.valueOf(start).getBytes());\n\t\t\tassertTrue(result.isFound());\n\t\t\tassertTrue(result.getTimeToLive() == 1200 * 1000);\n\t\t\tstart += 4;\n\t\t}*/\n\t\t\n\t\tkeyList = new ArrayList<String>();\n\t\tfor(long i = 0; i < maxSize; i++) {\n\t\t\tif (i % 4 == 0 || i % 4 == 1) continue;\n\t\t\tkeyList.add(String.valueOf(i));\n\t\t}\n\t\tCollections.sort(keyList, new Comparator<String>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(String arg0, String arg1) {\n\t\t\t\tint hash0 = Arrays.hashCode(arg0.getBytes());\n\t\t\t\tint hash1 = Arrays.hashCode(arg1.getBytes());\n\t\t\t\tif (hash0 < hash1) return -1;\n\t\t\t\telse if (hash0 > hash1) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tint index = 0;\n\t\tfor(int i = 0; i < maxSize; i++) {\n\t\t\t// ignore deleted & expired\n\t\t\tif (i % 4 == 0 || i % 4 == 1) continue;\n\t\t\tIMapEntry mapEntry = targetTable.getMapEntry(index);\n\t\t\tassertTrue(mapEntry.getIndex() == index);\n\t\t\tassertTrue(new String(mapEntry.getKey()).equals(keyList.get(index)));\n\t\t\tassertTrue(new String(mapEntry.getValue()).equals(keyList.get(index)));\n\t\t\tindex++;\n\t\t}\n\t\t\n\t\tRandom random = new Random();\n\t\tfor(int i = 0; i < 1024; i++) {\n\t\t\tint key = random.nextInt(maxSize);\n\t\t\t// ignore deleted & expired\n\t\t\tif (key % 4 == 0 || key % 4 == 1) continue;\n\t\t\tGetResult result = targetTable.get(String.valueOf(key).getBytes());\n\t\t\tassertTrue(result.isFound());\n\t\t}\n\t\t\n\t\ttargetTable.close();\n\t\ttargetTable.delete();\n\t}", "signature": "void testCase02()", "full_signature": "@Test public void testCase02()", "class_method_signature": "Level1MergerTest.testCase02()", "testcase": true, "constructor": false, "invocations": ["nanoTime", "addFirst", "add", "valueOf", "sort", "hashCode", "getBytes", "hashCode", "getBytes", "appendNew", "getBytes", "hashCode", "getBytes", "getBytes", "currentTimeMillis", "add", "valueOf", "sort", "hashCode", "getBytes", "hashCode", "getBytes", "appendNew", "getBytes", "hashCode", "getBytes", "getBytes", "currentTimeMillis", "sleep", "add", "valueOf", "sort", "hashCode", "getBytes", "hashCode", "getBytes", "appendNew", "getBytes", "hashCode", "getBytes", "getBytes", "currentTimeMillis", "nanoTime", "add", "valueOf", "sort", "hashCode", "getBytes", "hashCode", "getBytes", "appendNew", "getBytes", "hashCode", "getBytes", "getBytes", "currentTimeMillis", "add", "mergeSort", "assertTrue", "size", "assertTrue", "size", "poll", "println", "getAppendedSize", "assertTrue", "getAppendedSize", "add", "valueOf", "sort", "hashCode", "getBytes", "hashCode", "getBytes", "getMapEntry", "assertTrue", "getIndex", "assertTrue", "equals", "getKey", "get", "assertTrue", "equals", "getValue", "get", "nextInt", "get", "getBytes", "valueOf", "assertTrue", "isFound", "close", "delete"]}, "focal_class": {"identifier": "Level1Merger", "superclass": "extends Thread", "interfaces": "", "fields": [{"original_string": "static final Logger log = LoggerFactory.getLogger(Level1Merger.class);", "modifier": "static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(Level1Merger.class)", "var_name": "log"}, {"original_string": "private static final int MAX_SLEEP_TIME = 5 * 1000;", "modifier": "private static final", "type": "int", "declarator": "MAX_SLEEP_TIME = 5 * 1000", "var_name": "MAX_SLEEP_TIME"}, {"original_string": "private static final int DEFAULT_MERGE_WAYS = 4;", "modifier": "private static final", "type": "int", "declarator": "DEFAULT_MERGE_WAYS = 4", "var_name": "DEFAULT_MERGE_WAYS"}, {"original_string": "private static final int CACHED_MAP_ENTRIES = 32;", "modifier": "private static final", "type": "int", "declarator": "CACHED_MAP_ENTRIES = 32", "var_name": "CACHED_MAP_ENTRIES"}, {"original_string": "private List<LevelQueue> levelQueueList;", "modifier": "private", "type": "List<LevelQueue>", "declarator": "levelQueueList", "var_name": "levelQueueList"}, {"original_string": "private SDB sdb;", "modifier": "private", "type": "SDB", "declarator": "sdb", "var_name": "sdb"}, {"original_string": "private final SDBStats stats;", "modifier": "private final", "type": "SDBStats", "declarator": "stats", "var_name": "stats"}, {"original_string": "private volatile boolean stop = false;", "modifier": "private volatile", "type": "boolean", "declarator": "stop = false", "var_name": "stop"}, {"original_string": "private CountDownLatch countDownLatch;", "modifier": "private", "type": "CountDownLatch", "declarator": "countDownLatch", "var_name": "countDownLatch"}, {"original_string": "private short shard;", "modifier": "private", "type": "short", "declarator": "shard", "var_name": "shard"}], "methods": [{"identifier": "Level1Merger", "parameters": "(SDB sdb, List<LevelQueue> levelQueueList, CountDownLatch countDownLatch, short shard,\n                        SDBStats stats)", "modifiers": "public", "return": "", "signature": " Level1Merger(SDB sdb, List<LevelQueue> levelQueueList, CountDownLatch countDownLatch, short shard,\n                        SDBStats stats)", "full_signature": "public  Level1Merger(SDB sdb, List<LevelQueue> levelQueueList, CountDownLatch countDownLatch, short shard,\n                        SDBStats stats)", "class_method_signature": "Level1Merger.Level1Merger(SDB sdb, List<LevelQueue> levelQueueList, CountDownLatch countDownLatch, short shard,\n                        SDBStats stats)", "testcase": false, "constructor": true}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "Level1Merger.run()", "testcase": false, "constructor": false}, {"identifier": "mergeSort", "parameters": "(LevelQueue lq1, LevelQueue lq2, int ways, String dir, short shard)", "modifiers": "public static", "return": "void", "signature": "void mergeSort(LevelQueue lq1, LevelQueue lq2, int ways, String dir, short shard)", "full_signature": "public static void mergeSort(LevelQueue lq1, LevelQueue lq2, int ways, String dir, short shard)", "class_method_signature": "Level1Merger.mergeSort(LevelQueue lq1, LevelQueue lq2, int ways, String dir, short shard)", "testcase": false, "constructor": false}, {"identifier": "setStop", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void setStop()", "full_signature": "public void setStop()", "class_method_signature": "Level1Merger.setStop()", "testcase": false, "constructor": false}], "file": "zava/src/main/java/com/ctriposs/sdb/merge/Level1Merger.java"}, "focal_method": {"identifier": "mergeSort", "parameters": "(LevelQueue lq1, LevelQueue lq2, int ways, String dir, short shard)", "modifiers": "public static", "return": "void", "body": "public static void mergeSort(LevelQueue lq1, LevelQueue lq2, int ways, String dir, short shard)\n\t\t\tthrows IOException, ClassNotFoundException {\n\t\tboolean hasLevel2MapTable = lq2.size() > 0;\n\t\tList<AbstractMapTable> tables = new ArrayList<AbstractMapTable>(ways);\n\t\tlq1.getReadLock().lock();\n\t\ttry {\n\t\t\tIterator<AbstractMapTable> iter = lq1.descendingIterator();\n\t\t\tfor(int i = 0; i < ways - 1; i++) {\n\t\t\t\ttables.add(iter.next());\n\t\t\t}\n\t\t\tif (hasLevel2MapTable) {\n\t\t\t\ttables.add(lq2.get(0));\n\t\t\t} else {\n\t\t\t\ttables.add(iter.next());\n\t\t\t}\n\t\t} finally {\n\t\t\tlq1.getReadLock().unlock();\n\t\t}\n\n\t\tlong expectedInsertions = 0;\n\t\tfor(AbstractMapTable table : tables) {\n\t\t\texpectedInsertions += table.getAppendedSize();\n\t\t}\n\t\tif (expectedInsertions > Integer.MAX_VALUE) expectedInsertions = Integer.MAX_VALUE;\n\t\t// target table\n\t\tAbstractSortedMapTable sortedMapTable = new FCMapTable(dir, shard, SDB.LEVEL2, System.nanoTime(), (int)expectedInsertions);\n\n\t\tPriorityQueue<QueueElement> pq = new PriorityQueue<QueueElement>();\n\t\t// build initial heap\n\t\tfor(AbstractMapTable table : tables) {\n\t\t\tQueueElement qe = new QueueElement();\n\t\t\tqe.sortedMapTable = table;\n\t\t\tqe.size = qe.sortedMapTable.getAppendedSize();\n\t\t\tqe.index = 0;\n\t\t\tqe.queue = new LinkedList<IMapEntry>();\n\t\t\tIMapEntry me = qe.getNextMapEntry();\n\t\t\tif (me != null) {\n\t\t\t\tqe.key = me.getKey();\n\t\t\t\tqe.mapEntry = me;\n\t\t\t\tqe.keyHash = me.getKeyHash();\n\t\t\t\tpq.add(qe);\n\t\t\t}\n\t\t}\n\n\t\tLinkedList<IMapEntry> targetCacheQueue = new LinkedList<IMapEntry>();\n\t\t// merge sort\n\t\twhile(pq.size() > 0) {\n\t\t\tQueueElement qe1 = pq.poll();\n\t\t\t// remove old/stale entries\n\t\t\twhile(pq.peek() != null && qe1.keyHash == pq.peek().keyHash && BytesUtil.compare(qe1.key, pq.peek().key) == 0) {\n\t\t\t\tQueueElement qe2 = pq.poll();\n\t\t\t\tIMapEntry me = qe2.getNextMapEntry();\n\t\t\t\tif (me != null) {\n\t\t\t\t\tqe2.key = me.getKey();\n\t\t\t\t\tqe2.mapEntry = me;\n\t\t\t\t\tqe2.keyHash = me.getKeyHash();\n\t\t\t\t\tpq.add(qe2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// remove deleted or expired entries in final merge sorting\n\t\t\tif (!qe1.mapEntry.isDeleted() && !qe1.mapEntry.isExpired()) {\n\t\t\t\ttargetCacheQueue.add(qe1.mapEntry);\n\t\t\t}\n\t\t\tif (targetCacheQueue.size() >= CACHED_MAP_ENTRIES * DEFAULT_MERGE_WAYS) {\n\t\t\t\twhile(targetCacheQueue.size() > 0) {\n\t\t\t\t\tIMapEntry mapEntry = targetCacheQueue.poll();\n\t\t\t\t\tbyte[] value = mapEntry.getValue();\n\t\t\t\t\t// disk space optimization\n\t\t\t\t\tif (mapEntry.isExpired()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tsortedMapTable.appendNew(mapEntry.getKey(), mapEntry.getKeyHash(), value, mapEntry.getTimeToLive(),\n\t\t\t\t\t\t\tmapEntry.getCreatedTime(), mapEntry.isDeleted(), mapEntry.isCompressed());\n\t\t\t\t}\n\t\t\t}\n\t\t\tIMapEntry me = qe1.getNextMapEntry();\n\t\t\tif (me != null) {\n\t\t\t\tqe1.key = me.getKey();\n\t\t\t\tqe1.mapEntry = me;\n\t\t\t\tqe1.keyHash = me.getKeyHash();\n\t\t\t\tpq.add(qe1);\n\t\t\t}\n\t\t}\n\n\t\t// remaining cached entries\n\t\twhile(targetCacheQueue.size() > 0) {\n\t\t\tIMapEntry mapEntry = targetCacheQueue.poll();\n\t\t\tbyte[] value = mapEntry.getValue();\n\t\t\t// disk space optimization\n\t\t\tif (mapEntry.isExpired()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsortedMapTable.appendNew(mapEntry.getKey(), mapEntry.getKeyHash(), value, mapEntry.getTimeToLive(),\n\t\t\t\t\tmapEntry.getCreatedTime(), mapEntry.isDeleted(), mapEntry.isCompressed());\n\t\t}\n\n\t\t// persist metadata\n\t\tsortedMapTable.reMap();\n\t\tsortedMapTable.saveMetadata();\n\n\t\t// switching\n\t\tlq1.getWriteLock().lock();\n\t\tlq2.getWriteLock().lock();\n\t\ttry {\n\t\t\tfor(int i = 0; i < ways - 1; i++) {\n\t\t\t\tlq1.removeLast();\n\t\t\t}\n\t\t\tif (hasLevel2MapTable) {\n\t\t\t\tlq2.removeLast();\n\t\t\t} else {\n\t\t\t\tlq1.removeLast();\n\t\t\t}\n\t\t\tfor(AbstractMapTable table : tables) {\n\t\t\t\ttable.markUsable(false);\n\t\t\t}\n\n\t\t\tsortedMapTable.markUsable(true);\n\t\t\tlq2.addFirst(sortedMapTable);\n\t\t} finally {\n\t\t\tlq2.getWriteLock().unlock();\n\t\t\tlq1.getWriteLock().unlock();\n\t\t}\n\n\t\tfor(AbstractMapTable table : tables) {\n\t\t\ttable.close();\n\t\t\ttable.delete();\n\t\t}\n\t}", "signature": "void mergeSort(LevelQueue lq1, LevelQueue lq2, int ways, String dir, short shard)", "full_signature": "public static void mergeSort(LevelQueue lq1, LevelQueue lq2, int ways, String dir, short shard)", "class_method_signature": "Level1Merger.mergeSort(LevelQueue lq1, LevelQueue lq2, int ways, String dir, short shard)", "testcase": false, "constructor": false, "invocations": ["size", "lock", "getReadLock", "descendingIterator", "add", "next", "add", "get", "add", "next", "unlock", "getReadLock", "getAppendedSize", "nanoTime", "getAppendedSize", "getNextMapEntry", "getKey", "getKeyHash", "add", "size", "poll", "peek", "peek", "compare", "peek", "poll", "getNextMapEntry", "getKey", "getKeyHash", "add", "isDeleted", "isExpired", "add", "size", "size", "poll", "getValue", "isExpired", "appendNew", "getKey", "getKeyHash", "getTimeToLive", "getCreatedTime", "isDeleted", "isCompressed", "getNextMapEntry", "getKey", "getKeyHash", "add", "size", "poll", "getValue", "isExpired", "appendNew", "getKey", "getKeyHash", "getTimeToLive", "getCreatedTime", "isDeleted", "isCompressed", "reMap", "saveMetadata", "lock", "getWriteLock", "lock", "getWriteLock", "removeLast", "removeLast", "removeLast", "markUsable", "markUsable", "addFirst", "unlock", "getWriteLock", "unlock", "getWriteLock", "close", "delete"]}, "repository": {"repo_id": 33645537, "url": "https://github.com/zqhxuyuan/tutorials", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 5, "size": 35273, "license": "licensed"}}