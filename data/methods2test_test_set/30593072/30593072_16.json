{"test_class": {"identifier": "ByteChannelReaderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ByteChannelReader inputStreamReader;", "modifier": "private", "type": "ByteChannelReader", "declarator": "inputStreamReader", "var_name": "inputStreamReader"}, {"original_string": "private Mockery mockery = new Mockery();", "modifier": "private", "type": "Mockery", "declarator": "mockery = new Mockery()", "var_name": "mockery"}, {"original_string": "private ReadableByteChannel readableByteChannel;", "modifier": "private", "type": "ReadableByteChannel", "declarator": "readableByteChannel", "var_name": "readableByteChannel"}, {"original_string": "private ByteStreamMessageParser byteStreamMessageParser;", "modifier": "private", "type": "ByteStreamMessageParser", "declarator": "byteStreamMessageParser", "var_name": "byteStreamMessageParser"}, {"original_string": "private ConnectionObserver connectionObserver;", "modifier": "private", "type": "ConnectionObserver", "declarator": "connectionObserver", "var_name": "connectionObserver"}], "file": "nanofix-client/src/test/java/com/lmax/nanofix/incoming/ByteChannelReaderTest.java"}, "test_case": {"identifier": "shouldCloseInputStreamIfExceptionIsThrownAndInputStreamIsStillOpen", "parameters": "()", "modifiers": "@Test(expected = RuntimeException.class) public", "return": "void", "body": "@Test(expected = RuntimeException.class)\n    public void shouldCloseInputStreamIfExceptionIsThrownAndInputStreamIsStillOpen() throws Exception\n    {\n        mockery.checking(new Expectations()\n        {\n            {\n                ignoring(connectionObserver).connectionClosed();\n                allowing(byteStreamMessageParser).parse(with(any(ByteBuffer.class)));\n\n                //when\n                one(readableByteChannel).read(with(any(ByteBuffer.class)));\n                will(throwException(new RuntimeException(\"boom!\")));\n\n\n                //then\n                one(readableByteChannel).isOpen();\n                will(returnValue(true));\n                one(readableByteChannel).close();\n\n            }\n        });\n\n        //when\n        inputStreamReader.blockingStart(readableByteChannel);\n    }", "signature": "void shouldCloseInputStreamIfExceptionIsThrownAndInputStreamIsStillOpen()", "full_signature": "@Test(expected = RuntimeException.class) public void shouldCloseInputStreamIfExceptionIsThrownAndInputStreamIsStillOpen()", "class_method_signature": "ByteChannelReaderTest.shouldCloseInputStreamIfExceptionIsThrownAndInputStreamIsStillOpen()", "testcase": true, "constructor": false, "invocations": ["checking", "connectionClosed", "ignoring", "parse", "allowing", "with", "any", "read", "one", "with", "any", "will", "throwException", "isOpen", "one", "will", "returnValue", "close", "one", "blockingStart"]}, "focal_class": {"identifier": "ByteChannelReader", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ByteChannelReader.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ByteChannelReader.class)", "var_name": "LOGGER"}, {"original_string": "private static final int BUFFER_SIZE = 1024;", "modifier": "private static final", "type": "int", "declarator": "BUFFER_SIZE = 1024", "var_name": "BUFFER_SIZE"}, {"original_string": "private final ByteStreamMessageParser byteStreamMessageParser;", "modifier": "private final", "type": "ByteStreamMessageParser", "declarator": "byteStreamMessageParser", "var_name": "byteStreamMessageParser"}, {"original_string": "private final Blocker blocker;", "modifier": "private final", "type": "Blocker", "declarator": "blocker", "var_name": "blocker"}, {"original_string": "private final ConnectionObserver connectionObserver;", "modifier": "private final", "type": "ConnectionObserver", "declarator": "connectionObserver", "var_name": "connectionObserver"}, {"original_string": "private final ByteBuffer buffer;", "modifier": "private final", "type": "ByteBuffer", "declarator": "buffer", "var_name": "buffer"}], "methods": [{"identifier": "ByteChannelReader", "parameters": "(final ByteStreamMessageParser byteStreamMessageParser, final Blocker blocker, final ConnectionObserver connectionObserver)", "modifiers": "public", "return": "", "signature": " ByteChannelReader(final ByteStreamMessageParser byteStreamMessageParser, final Blocker blocker, final ConnectionObserver connectionObserver)", "full_signature": "public  ByteChannelReader(final ByteStreamMessageParser byteStreamMessageParser, final Blocker blocker, final ConnectionObserver connectionObserver)", "class_method_signature": "ByteChannelReader.ByteChannelReader(final ByteStreamMessageParser byteStreamMessageParser, final Blocker blocker, final ConnectionObserver connectionObserver)", "testcase": false, "constructor": true}, {"identifier": "blockingStart", "parameters": "(final ReadableByteChannel readableByteChannel)", "modifiers": "public", "return": "void", "signature": "void blockingStart(final ReadableByteChannel readableByteChannel)", "full_signature": "public void blockingStart(final ReadableByteChannel readableByteChannel)", "class_method_signature": "ByteChannelReader.blockingStart(final ReadableByteChannel readableByteChannel)", "testcase": false, "constructor": false}], "file": "nanofix-client/src/main/java/com/lmax/nanofix/incoming/ByteChannelReader.java"}, "focal_method": {"identifier": "blockingStart", "parameters": "(final ReadableByteChannel readableByteChannel)", "modifiers": "public", "return": "void", "body": "public void blockingStart(final ReadableByteChannel readableByteChannel)\n    {\n        try\n        {\n            while ((readableByteChannel.read(buffer)) != -1)\n            {\n                blocker.mayWait();\n                buffer.flip();\n                byteStreamMessageParser.parse(buffer);\n                buffer.clear();\n            }\n\n        }\n        catch (final ClosedChannelException e)\n        {\n            //Yes closed.\n        }\n        catch (final IOException e)\n        {\n            LOGGER.error(\"An error occurred trying to read from the socket\", e);\n        }\n        finally\n        {\n            if (readableByteChannel != null)\n            {\n                try\n                {\n                    if (readableByteChannel.isOpen())\n                    {\n                        readableByteChannel.close();\n                    }\n                }\n                catch (IOException e)\n                {\n                    //I don't care\n                }\n                connectionObserver.connectionClosed();\n            }\n        }\n    }", "signature": "void blockingStart(final ReadableByteChannel readableByteChannel)", "full_signature": "public void blockingStart(final ReadableByteChannel readableByteChannel)", "class_method_signature": "ByteChannelReader.blockingStart(final ReadableByteChannel readableByteChannel)", "testcase": false, "constructor": false, "invocations": ["read", "mayWait", "flip", "parse", "clear", "error", "isOpen", "close", "connectionClosed"]}, "repository": {"repo_id": 30593072, "url": "https://github.com/LMAX-Exchange/nanofix", "language": "Java", "is_fork": false, "fork_count": 18, "stargazer_count": 24, "size": 193, "license": "licensed"}}