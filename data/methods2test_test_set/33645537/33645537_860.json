{"test_class": {"identifier": "BigCacheTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double STRESS_FACTOR = Double.parseDouble(System.getProperty(\"STRESS_FACTOR\", \"1.0\"));", "modifier": "private static final", "type": "double", "declarator": "STRESS_FACTOR = Double.parseDouble(System.getProperty(\"STRESS_FACTOR\", \"1.0\"))", "var_name": "STRESS_FACTOR"}, {"original_string": "private static final String TEST_DIR = TestUtil.TEST_BASE_DIR + \"function/bigcache/\";", "modifier": "private static final", "type": "String", "declarator": "TEST_DIR = TestUtil.TEST_BASE_DIR + \"function/bigcache/\"", "var_name": "TEST_DIR"}, {"original_string": "private BigCache<String> cache;", "modifier": "private", "type": "BigCache<String>", "declarator": "cache", "var_name": "cache"}, {"original_string": "@Parameter(value = 0)\n\tpublic StorageMode storageMode;", "modifier": "@Parameter(value = 0)\n\tpublic", "type": "StorageMode", "declarator": "storageMode", "var_name": "storageMode"}], "file": "zava/src/test/java/com/ctriposs/bigcache/BigCacheTest.java"}, "test_case": {"identifier": "testBigCache", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testBigCache() throws IOException {\n\t\tCacheConfig config = new CacheConfig();\n\t\tconfig.setStorageMode(storageMode);\n\t\tcache = new BigCache<String>(TEST_DIR, config);\n\t\tSet<String> rndStringSet = new HashSet<String>();\n\t\tfor (int i = 0; i < 2000000 * STRESS_FACTOR; i++) {\n\t\t\tString rndString = TestUtil.randomString(64);\n\t\t\trndStringSet.add(rndString);\n\t\t\tcache.put(rndString, rndString.getBytes());\n\t\t\tif ((i % 50000) == 0 && i != 0) {\n\t\t\t\tSystem.out.println(i + \" rows written\");\n\t\t\t}\n\t\t}\n\n\t\tfor (String rndString : rndStringSet) {\n\t\t\tbyte[] value = cache.get(rndString);\n\t\t\tassertNotNull(value);\n\t\t\tassertEquals(rndString, new String(value));\n\t\t}\n\n\t\t// delete\n\t\tfor (String rndString : rndStringSet) {\n\t\t\tcache.delete(rndString);\n\t\t}\n\n\t\tfor (String rndString : rndStringSet) {\n\t\t\tbyte[] value = cache.get(rndString);\n\t\t\tassertNull(value);\n\t\t}\n\t}", "signature": "void testBigCache()", "full_signature": "@Test public void testBigCache()", "class_method_signature": "BigCacheTest.testBigCache()", "testcase": true, "constructor": false, "invocations": ["setStorageMode", "randomString", "add", "put", "getBytes", "println", "get", "assertNotNull", "assertEquals", "delete", "get", "assertNull"]}, "focal_class": {"identifier": "BigCache", "superclass": "", "interfaces": "implements ICache<K>", "fields": [{"original_string": "public static final long DEFAULT_PURGE_INTERVAL = 5 * 60 * 1000;", "modifier": "public static final", "type": "long", "declarator": "DEFAULT_PURGE_INTERVAL = 5 * 60 * 1000", "var_name": "DEFAULT_PURGE_INTERVAL"}, {"original_string": "public static final long DEFAULT_MERGE_INTERVAL = 10 * 60 * 1000;", "modifier": "public static final", "type": "long", "declarator": "DEFAULT_MERGE_INTERVAL = 10 * 60 * 1000", "var_name": "DEFAULT_MERGE_INTERVAL"}, {"original_string": "public static final double DEFAULT_DIRTY_RATIO_THRESHOLD = 0.5;", "modifier": "public static final", "type": "double", "declarator": "DEFAULT_DIRTY_RATIO_THRESHOLD = 0.5", "var_name": "DEFAULT_DIRTY_RATIO_THRESHOLD"}, {"original_string": "public static final int DEFAULT_CONCURRENCY_LEVEL = 8;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_CONCURRENCY_LEVEL = 8", "var_name": "DEFAULT_CONCURRENCY_LEVEL"}, {"original_string": "public static final int MAX_VALUE_LENGTH = 4 * 1024 * 1024;", "modifier": "public static final", "type": "int", "declarator": "MAX_VALUE_LENGTH = 4 * 1024 * 1024", "var_name": "MAX_VALUE_LENGTH"}, {"original_string": "protected AtomicLong hitCounter = new AtomicLong();", "modifier": "protected", "type": "AtomicLong", "declarator": "hitCounter = new AtomicLong()", "var_name": "hitCounter"}, {"original_string": "protected AtomicLong missCounter = new AtomicLong();", "modifier": "protected", "type": "AtomicLong", "declarator": "missCounter = new AtomicLong()", "var_name": "missCounter"}, {"original_string": "protected AtomicLong getCounter = new AtomicLong();", "modifier": "protected", "type": "AtomicLong", "declarator": "getCounter = new AtomicLong()", "var_name": "getCounter"}, {"original_string": "protected AtomicLong putCounter = new AtomicLong();", "modifier": "protected", "type": "AtomicLong", "declarator": "putCounter = new AtomicLong()", "var_name": "putCounter"}, {"original_string": "protected AtomicLong deleteCounter = new AtomicLong();", "modifier": "protected", "type": "AtomicLong", "declarator": "deleteCounter = new AtomicLong()", "var_name": "deleteCounter"}, {"original_string": "protected AtomicLong purgeCounter = new AtomicLong();", "modifier": "protected", "type": "AtomicLong", "declarator": "purgeCounter = new AtomicLong()", "var_name": "purgeCounter"}, {"original_string": "protected AtomicLong moveCounter = new AtomicLong();", "modifier": "protected", "type": "AtomicLong", "declarator": "moveCounter = new AtomicLong()", "var_name": "moveCounter"}, {"original_string": "protected AtomicLong usedSize = new AtomicLong();", "modifier": "protected", "type": "AtomicLong", "declarator": "usedSize = new AtomicLong()", "var_name": "usedSize"}, {"original_string": "protected final ConcurrentMap<K, CacheValueWrapper> pointerMap = new ConcurrentHashMap<K, CacheValueWrapper>();", "modifier": "protected final", "type": "ConcurrentMap<K, CacheValueWrapper>", "declarator": "pointerMap = new ConcurrentHashMap<K, CacheValueWrapper>()", "var_name": "pointerMap"}, {"original_string": "final StorageManager storageManager;", "modifier": "final", "type": "StorageManager", "declarator": "storageManager", "var_name": "storageManager"}, {"original_string": "private final StripedReadWriteLock readWriteLock;", "modifier": "private final", "type": "StripedReadWriteLock", "declarator": "readWriteLock", "var_name": "readWriteLock"}, {"original_string": "private final AtomicLong NO_OF_MERGE_RUN = new AtomicLong();", "modifier": "private final", "type": "AtomicLong", "declarator": "NO_OF_MERGE_RUN = new AtomicLong()", "var_name": "NO_OF_MERGE_RUN"}, {"original_string": "private final AtomicLong NO_OF_PURGE_RUN = new AtomicLong();", "modifier": "private final", "type": "AtomicLong", "declarator": "NO_OF_PURGE_RUN = new AtomicLong()", "var_name": "NO_OF_PURGE_RUN"}, {"original_string": "private String cacheDir;", "modifier": "private", "type": "String", "declarator": "cacheDir", "var_name": "cacheDir"}, {"original_string": "private ScheduledExecutorService ses;", "modifier": "private", "type": "ScheduledExecutorService", "declarator": "ses", "var_name": "ses"}, {"original_string": "private final double dirtyRatioThreshold;", "modifier": "private final", "type": "double", "declarator": "dirtyRatioThreshold", "var_name": "dirtyRatioThreshold"}], "methods": [{"identifier": "BigCache", "parameters": "(String dir, CacheConfig config)", "modifiers": "public", "return": "", "signature": " BigCache(String dir, CacheConfig config)", "full_signature": "public  BigCache(String dir, CacheConfig config)", "class_method_signature": "BigCache.BigCache(String dir, CacheConfig config)", "testcase": false, "constructor": true}, {"identifier": "put", "parameters": "(K key, byte[] value)", "modifiers": "@Override public", "return": "void", "signature": "void put(K key, byte[] value)", "full_signature": "@Override public void put(K key, byte[] value)", "class_method_signature": "BigCache.put(K key, byte[] value)", "testcase": false, "constructor": false}, {"identifier": "put", "parameters": "(K key, byte[] value, long tti)", "modifiers": "@Override public", "return": "void", "signature": "void put(K key, byte[] value, long tti)", "full_signature": "@Override public void put(K key, byte[] value, long tti)", "class_method_signature": "BigCache.put(K key, byte[] value, long tti)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(K key)", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] get(K key)", "full_signature": "@Override public byte[] get(K key)", "class_method_signature": "BigCache.get(K key)", "testcase": false, "constructor": false}, {"identifier": "delete", "parameters": "(K key)", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] delete(K key)", "full_signature": "@Override public byte[] delete(K key)", "class_method_signature": "BigCache.delete(K key)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(K key)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean contains(K key)", "full_signature": "@Override public boolean contains(K key)", "class_method_signature": "BigCache.contains(K key)", "testcase": false, "constructor": false}, {"identifier": "clear", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void clear()", "full_signature": "@Override public void clear()", "class_method_signature": "BigCache.clear()", "testcase": false, "constructor": false}, {"identifier": "hitRatio", "parameters": "()", "modifiers": "@Override public", "return": "double", "signature": "double hitRatio()", "full_signature": "@Override public double hitRatio()", "class_method_signature": "BigCache.hitRatio()", "testcase": false, "constructor": false}, {"identifier": "readLock", "parameters": "(K key)", "modifiers": "protected", "return": "void", "signature": "void readLock(K key)", "full_signature": "protected void readLock(K key)", "class_method_signature": "BigCache.readLock(K key)", "testcase": false, "constructor": false}, {"identifier": "readUnlock", "parameters": "(K key)", "modifiers": "protected", "return": "void", "signature": "void readUnlock(K key)", "full_signature": "protected void readUnlock(K key)", "class_method_signature": "BigCache.readUnlock(K key)", "testcase": false, "constructor": false}, {"identifier": "writeLock", "parameters": "(K key)", "modifiers": "protected", "return": "void", "signature": "void writeLock(K key)", "full_signature": "protected void writeLock(K key)", "class_method_signature": "BigCache.writeLock(K key)", "testcase": false, "constructor": false}, {"identifier": "writeUnlock", "parameters": "(K key)", "modifiers": "protected", "return": "void", "signature": "void writeUnlock(K key)", "full_signature": "protected void writeUnlock(K key)", "class_method_signature": "BigCache.writeUnlock(K key)", "testcase": false, "constructor": false}, {"identifier": "getLock", "parameters": "(K key)", "modifiers": "protected", "return": "ReadWriteLock", "signature": "ReadWriteLock getLock(K key)", "full_signature": "protected ReadWriteLock getLock(K key)", "class_method_signature": "BigCache.getLock(K key)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "BigCache.close()", "testcase": false, "constructor": false}, {"identifier": "count", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long count()", "full_signature": "public long count()", "class_method_signature": "BigCache.count()", "testcase": false, "constructor": false}, {"identifier": "getStats", "parameters": "()", "modifiers": "public", "return": "BigCacheStats", "signature": "BigCacheStats getStats()", "full_signature": "public BigCacheStats getStats()", "class_method_signature": "BigCache.getStats()", "testcase": false, "constructor": false}], "file": "zava/src/main/java/com/ctriposs/bigcache/BigCache.java"}, "focal_method": {"identifier": "BigCache", "parameters": "(String dir, CacheConfig config)", "modifiers": "public", "return": "", "body": "public BigCache(String dir, CacheConfig config) throws IOException {\n\t\tthis.cacheDir = dir;\n\t\tif (!this.cacheDir.endsWith(File.separator)) {\n\t\t\tthis.cacheDir += File.separator;\n\t\t}\n\t\t// validate directory\n\t\tif (!FileUtil.isFilenameValid(this.cacheDir)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid cache data directory : \" + this.cacheDir);\n\t\t}\n\t\t\n\t\t// clean up old cache data if exists\n\t\tFileUtil.deleteDirectory(new File(this.cacheDir));\n\t\t\n\t\tthis.storageManager = new StorageManager(this.cacheDir, config.getCapacityPerBlock(),\n\t\t\t\tconfig.getInitialNumberOfBlocks(), config.getStorageMode(), config.getMaxOffHeapMemorySize());\n\t\tthis.readWriteLock = new StripedReadWriteLock(config.getConcurrencyLevel());\n\n        ses = new ScheduledThreadPoolExecutor(2);\n        ses.scheduleWithFixedDelay(new CacheCleaner(this), config.getPurgeInterval(), config.getPurgeInterval(), TimeUnit.MILLISECONDS);\n        ses.scheduleWithFixedDelay(new CacheMerger(this), config.getMergeInterval(), config.getMergeInterval(), TimeUnit.MILLISECONDS);\n        dirtyRatioThreshold = config.getDirtyRatioThreshold();\n\t}", "signature": " BigCache(String dir, CacheConfig config)", "full_signature": "public  BigCache(String dir, CacheConfig config)", "class_method_signature": "BigCache.BigCache(String dir, CacheConfig config)", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 33645537, "url": "https://github.com/zqhxuyuan/tutorials", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 5, "size": 35273, "license": "licensed"}}