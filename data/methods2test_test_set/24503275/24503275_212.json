{"test_class": {"identifier": "VMTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ProgramInvoke invoke;", "modifier": "private", "type": "ProgramInvoke", "declarator": "invoke", "var_name": "invoke"}, {"original_string": "private Program program;", "modifier": "private", "type": "Program", "declarator": "program", "var_name": "program"}], "file": "ethereumj-core/src/test/java/org/ethereum/vm/VMTest.java"}, "test_case": {"identifier": "testSDIV_4", "parameters": "()", "modifiers": "@Test(expected=StackTooSmallException.class) // SDIV OP mal public", "return": "void", "body": "@Test(expected=StackTooSmallException.class) // SDIV OP mal\n    public void testSDIV_4() {\n\n        VM vm = new VM();\n        program =  new Program(Hex.decode(\"60FF05\"), invoke);\n\n        try {\n            vm.step(program);\n            vm.step(program);\n        } finally {\n        \tassertTrue(program.isStopped());\n        }\n    }", "signature": "void testSDIV_4()", "full_signature": "@Test(expected=StackTooSmallException.class) // SDIV OP mal public void testSDIV_4()", "class_method_signature": "VMTest.testSDIV_4()", "testcase": true, "constructor": false, "invocations": ["decode", "step", "step", "assertTrue", "isStopped"]}, "focal_class": {"identifier": "VM", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(\"VM\");", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(\"VM\")", "var_name": "logger"}, {"original_string": "private static final Logger dumpLogger = LoggerFactory.getLogger(\"dump\");", "modifier": "private static final", "type": "Logger", "declarator": "dumpLogger = LoggerFactory.getLogger(\"dump\")", "var_name": "dumpLogger"}, {"original_string": "private static BigInteger _32_ = BigInteger.valueOf(32);", "modifier": "private static", "type": "BigInteger", "declarator": "_32_ = BigInteger.valueOf(32)", "var_name": "_32_"}, {"original_string": "private static String logString = \"[{}]\\t Op: [{}]  Gas: [{}] Deep: [{}]  Hint: [{}]\";", "modifier": "private static", "type": "String", "declarator": "logString = \"[{}]\\t Op: [{}]  Gas: [{}] Deep: [{}]  Hint: [{}]\"", "var_name": "logString"}, {"original_string": "private static BigInteger MAX_GAS = BigInteger.valueOf(Long.MAX_VALUE);", "modifier": "private static", "type": "BigInteger", "declarator": "MAX_GAS = BigInteger.valueOf(Long.MAX_VALUE)", "var_name": "MAX_GAS"}, {"original_string": "private int vmCounter = 0;", "modifier": "private", "type": "int", "declarator": "vmCounter = 0", "var_name": "vmCounter"}], "methods": [{"identifier": "step", "parameters": "(Program program)", "modifiers": "public", "return": "void", "signature": "void step(Program program)", "full_signature": "public void step(Program program)", "class_method_signature": "VM.step(Program program)", "testcase": false, "constructor": false}, {"identifier": "play", "parameters": "(Program program)", "modifiers": "public", "return": "void", "signature": "void play(Program program)", "full_signature": "public void play(Program program)", "class_method_signature": "VM.play(Program program)", "testcase": false, "constructor": false}, {"identifier": "memNeeded", "parameters": "(DataWord offset, DataWord size)", "modifiers": "private", "return": "BigInteger", "signature": "BigInteger memNeeded(DataWord offset, DataWord size)", "full_signature": "private BigInteger memNeeded(DataWord offset, DataWord size)", "class_method_signature": "VM.memNeeded(DataWord offset, DataWord size)", "testcase": false, "constructor": false}, {"identifier": "dumpLine", "parameters": "(OpCode op, long gasBefore, long gasCost, long memWords, Program program)", "modifiers": "private", "return": "void", "signature": "void dumpLine(OpCode op, long gasBefore, long gasCost, long memWords, Program program)", "full_signature": "private void dumpLine(OpCode op, long gasBefore, long gasCost, long memWords, Program program)", "class_method_signature": "VM.dumpLine(OpCode op, long gasBefore, long gasCost, long memWords, Program program)", "testcase": false, "constructor": false}], "file": "ethereumj-core/src/main/java/org/ethereum/vm/VM.java"}, "focal_method": {"identifier": "step", "parameters": "(Program program)", "modifiers": "public", "return": "void", "body": "public void step(Program program) {\n\n        program.fullTrace();\n\n        if (CONFIG.vmTrace())\n            program.saveOpTrace();\n    \t\n        try {\n            OpCode op = OpCode.code(program.getCurrentOp());\n            \n            if (op == null)\n            \tthrow program.new IllegalOperationException();\n            \n            program.setLastOp(op.val());\n\n            long oldMemSize = program.getMemSize();\n            BigInteger newMemSize = BigInteger.ZERO;\n            Stack<DataWord> stack = program.getStack();\n\n            String hint = \"\";\n            long callGas = 0, memWords = 0; // parameters for logging\n            long gasCost = GasCost.STEP;\n            long gasBefore = program.getGas().longValue();\n            int stepBefore = program.getPC();\n            \n            program.stackRequire(op.require());\n            \n    \t\t// Calculate fees and spend gas\n            switch (op) {\n                case STOP: case SUICIDE:\n                    // The ops that don't charge by step\n                \tgasCost = GasCost.STOP;\n                    break;\n        \t\tcase SSTORE:\n        \t\t\tDataWord newValue = stack.get(stack.size()-2);\n                    DataWord oldValue =  program.storageLoad(stack.peek());\n                    if (oldValue == null && !newValue.isZero())\n                    \tgasCost = GasCost.SSTORE * 2;\n                    else if (oldValue != null && newValue.isZero())\n                        gasCost = GasCost.SSTORE * 0;\n                    else\n                        gasCost = GasCost.SSTORE;\n        \t\t\tbreak;\n                case SLOAD:\n                    gasCost = GasCost.SLOAD;\n                    break;\n                case BALANCE:\n                    gasCost = GasCost.BALANCE;\n                    break;\n                    \n        \t\t// These all operate on memory and therefore potentially expand it:\n        \t\tcase MSTORE:\n        \t\t\tnewMemSize = memNeeded(stack.peek(), new DataWord(32));\n        \t\t\tbreak;\n        \t\tcase MSTORE8:\n        \t\t\tnewMemSize = memNeeded(stack.peek(), new DataWord(1));\n        \t\t\tbreak;\n        \t\tcase MLOAD:\n        \t\t\tnewMemSize = memNeeded(stack.peek(), new DataWord(32));\n        \t\t\tbreak;\n        \t\tcase RETURN:\n        \t\t\tnewMemSize = memNeeded(stack.peek(), stack.get(stack.size()-2));\n        \t\t\tbreak;\n        \t\tcase SHA3:\n        \t\t\tgasCost = GasCost.SHA3;\n        \t\t\tnewMemSize = memNeeded(stack.peek(), stack.get(stack.size()-2));\n        \t\t\tbreak;\n        \t\tcase CALLDATACOPY:\n        \t\t\tnewMemSize = memNeeded(stack.peek(), stack.get(stack.size()-3));\n        \t\t\tbreak;\n        \t\tcase CODECOPY:\n        \t\t\tnewMemSize = memNeeded(stack.peek(), stack.get(stack.size()-3));\n        \t\t\tbreak;\n        \t\tcase EXTCODECOPY:\n        \t\t\tnewMemSize = memNeeded(stack.get(stack.size()-2), stack.get(stack.size()-4));\n        \t\t\tbreak;\n        \t\tcase CALL: case CALLCODE:\n        \t\t\tgasCost = GasCost.CALL;\n        \t\t\tDataWord callGasWord = stack.get(stack.size()-1);\n        \t\t\tif(callGasWord.compareTo(program.getGas()) == 1) {\n        \t\t\t\tthrow program.new OutOfGasException();\n                    }\n        \t\t\tcallGas = callGasWord.longValue();\n        \t\t\tBigInteger in = memNeeded(stack.get(stack.size()-4), stack.get(stack.size()-5)); // in offset+size\n    \t\t\t\tBigInteger out = memNeeded(stack.get(stack.size()-6), stack.get(stack.size()-7)); // out offset+size\n        \t\t\tnewMemSize = in.max(out);\n        \t\t\tbreak;\n        \t\tcase CREATE:\n        \t\t\tgasCost = GasCost.CREATE;\n        \t\t\tnewMemSize = memNeeded(stack.get(stack.size()-2), stack.get(stack.size()-3));\n        \t\t\tbreak;\n                default:\n                    break;\n            }\n            program.spendGas(gasCost, op.name());\n            \n            // Avoid overflows\n            if(newMemSize.compareTo(MAX_GAS) == 1) {\n            \tthrow program.new OutOfGasException();\n            }\n            \n            // memory gas calc\n            long memoryUsage = (newMemSize.longValue() + 31) / 32 * 32;            \n\t        if (memoryUsage > oldMemSize) {\n\t        \tmemWords = (memoryUsage - oldMemSize) / 32;\n\t        \tlong memGas = GasCost.MEMORY * memWords;\n\t\t\t\tprogram.spendGas(memGas, op.name() + \" (memory usage)\");\n\t\t\t\tgasCost += memGas;\n\t        }\n\n\t\t\t// Log debugging line for VM\n    \t\tif(program.getNumber().intValue() == CONFIG.dumpBlock())\n    \t\t\tthis.dumpLine(op, gasBefore, gasCost+callGas, memWords, program);\n\t    \t\t\n            // Execute operation\n            switch (op) {\n                /**\n                 * Stop and Arithmetic Operations\n                 */\n                case STOP:{\n                    program.setHReturn(ByteBuffer.allocate(0));\n                    program.stop();\n                }\tbreak;\n                case ADD:{\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" + \" + word2.value();\n\n                    word1.add(word2);\n                    program.stackPush(word1);\n                    program.step();\n\n                }\tbreak;\n                case MUL:{\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" * \" + word2.value();\n\n                    word1.mul(word2);\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case SUB:{\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" - \" + word2.value();\n\n                    word1.sub(word2);\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case DIV:{\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" / \" + word2.value();\n\n                    word1.div(word2);\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case SDIV:{\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.sValue() + \" / \" + word2.sValue();\n\n                    word1.sDiv(word2);\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case MOD:{\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" % \" + word2.value();\n\n                    word1.mod(word2);\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case SMOD:{\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.sValue() + \" #% \" + word2.sValue();\n\n                    word1.sMod(word2);\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case EXP:{\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" ** \" + word2.value();\n\n                    word1.exp(word2);\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case NEG:{\n                \tDataWord word1 = program.stackPop();\n                    word1.negate();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"\" + word1.value();\n\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case LT:{\n                \t// TODO: can be improved by not using BigInteger\n                    DataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" < \" + word2.value();\n\n                    if (word1.value().compareTo(word2.value()) == -1) {\n                        word1.and(DataWord.ZERO);\n                        word1.getData()[31] = 1;\n                    } else {\n                        word1.and(DataWord.ZERO);\n                    }\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case SLT:{\n                \t// TODO: can be improved by not using BigInteger\n                    DataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.sValue() + \" < \" + word2.sValue();\n\n                    if (word1.sValue().compareTo(word2.sValue()) == -1) {\n                        word1.and(DataWord.ZERO);\n                        word1.getData()[31] = 1;\n                    } else {\n                        word1.and(DataWord.ZERO);\n                    }\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case SGT:{\n                \t// TODO: can be improved by not using BigInteger\n                    DataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.sValue() + \" > \" + word2.sValue();\n\n                    if (word1.sValue().compareTo(word2.sValue()) == 1) {\n                        word1.and(DataWord.ZERO);\n                        word1.getData()[31] = 1;\n                    } else {\n                        word1.and(DataWord.ZERO);\n                    }\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case GT:{\n                \t// TODO: can be improved by not using BigInteger\n                    DataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" > \" + word2.value();\n\n                    if (word1.value().compareTo(word2.value()) == 1) {\n                        word1.and(DataWord.ZERO);\n                        word1.getData()[31] = 1;\n                    } else {\n                        word1.and(DataWord.ZERO);\n                    }\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case EQ:{\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" == \" + word2.value();\n\n                    if (word1.xor(word2).isZero()) {\n                        word1.and(DataWord.ZERO);\n                        word1.getData()[31] = 1;\n                    } else {\n                        word1.and(DataWord.ZERO);\n                    }\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case NOT: {\n                \tDataWord word1 = program.stackPop();\n                    if (word1.isZero()) {\n                        word1.getData()[31] = 1;\n                    } else {\n                        word1.and(DataWord.ZERO);\n                    }\n\n                    if (logger.isInfoEnabled())\n                        hint = \"\" + word1.value();\n\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n\n                /**\n                 * Bitwise Logic Operations\n                 */\n                case AND:{              \t\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" && \" + word2.value();\n\n                    word1.and(word2);\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case OR: {             \t\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" || \" + word2.value();\n\n                    word1.or(word2);\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case XOR: {              \t\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = word1.value() + \" ^ \" + word2.value();\n\n                    word1.xor(word2);\n                    program.stackPush(word1);\n                    program.step();\n                }\tbreak;\n                case BYTE:{              \t\n                \tDataWord word1 = program.stackPop();\n                    DataWord word2 = program.stackPop();\n                    DataWord result = null;\n                    if (word1.value().compareTo(_32_) == -1) {\n                        byte tmp = word2.getData()[word1.intValue()];\n                        word2.and(DataWord.ZERO);\n                        word2.getData()[31] = tmp;\n                        result = word2;\n                    } else {\n                        result = new DataWord();\n                    }\n\n                    if (logger.isInfoEnabled())\n                        hint = \"\" + result.value();\n\n                    program.stackPush(result);\n                    program.step();\n                }\tbreak;\n\t\t\t\tcase ADDMOD:{\n                \tDataWord word1 = program.stackPop();\n                \tDataWord word2 = program.stackPop();\n                \tDataWord word3 = program.stackPop();\n                \tword1.addmod(word2, word3);\n                \tprogram.stackPush(word1);\n                \tprogram.step();\n\t\t\t\t}\tbreak;\n\t\t\t\tcase MULMOD:{\n                \tDataWord word1 = program.stackPop();\n                \tDataWord word2 = program.stackPop();\n                \tDataWord word3 = program.stackPop();\n                \tword1.mulmod(word2, word3);\n                \tprogram.stackPush(word1);\n                \tprogram.step();\n\t\t\t\t}\tbreak;\n\n                /**\n                 * SHA3\n                 */\n                case SHA3:{               \t\n                \tDataWord memOffsetData  = program.stackPop();\n                    DataWord lengthData     = program.stackPop();\n                    ByteBuffer buffer = program.memoryChunk(memOffsetData, lengthData);\n\n                    byte[] encoded = HashUtil.sha3(buffer.array());\n                    DataWord word = new DataWord(encoded);\n\n                    if (logger.isInfoEnabled())\n                        hint = word.toString();\n\n                    program.stackPush(word);\n                    program.step();\n                }\tbreak;\n\n                /**\n                 * Environmental Information\n                 */\n                case ADDRESS:{\n                    DataWord address = program.getOwnerAddress();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"address: \" + Hex.toHexString(address.getLast20Bytes());\n\n                    program.stackPush(address);\n                    program.step();\n                }\tbreak;\n                case BALANCE:{\n                \tDataWord address = program.stackPop();\n                    DataWord balance = program.getBalance(address);\n\n                    if (logger.isInfoEnabled())\n\t\t\t\t\t\thint = \"address: \"\n\t\t\t\t\t\t\t\t+ Hex.toHexString(address.getLast20Bytes())\n\t\t\t\t\t\t\t\t+ \" balance: \" + balance.longValue();\n\n                    program.stackPush(balance);\n                    program.step();\n                }\tbreak;\n                case ORIGIN:{\n                    DataWord originAddress = program.getOriginAddress();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"address: \" + Hex.toHexString(originAddress.getLast20Bytes());\n\n                    program.stackPush(originAddress);\n                    program.step();\n                }\tbreak;\n                case CALLER:{\n                    DataWord callerAddress = program.getCallerAddress();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"address: \" + Hex.toHexString(callerAddress.getLast20Bytes());\n\n                    program.stackPush(callerAddress);\n                    program.step();\n                }\tbreak;\n                case CALLVALUE:{\n                    DataWord callValue = program.getCallValue();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"value: \" + callValue;\n\n                    program.stackPush(callValue);\n                    program.step();\n                }\tbreak;\n                case CALLDATALOAD:{         \t\n                \tDataWord dataOffs  = program.stackPop();\n                    DataWord value = program.getDataValue(dataOffs);\n\n                    if (logger.isInfoEnabled())\n                        hint = \"data: \" + value;\n\n                    program.stackPush(value);\n                    program.step();\n                }\tbreak;\n                case CALLDATASIZE:{\n                    DataWord dataSize = program.getDataSize();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"size: \" + dataSize.value();\n\n                    program.stackPush(dataSize);\n                    program.step();\n                }\tbreak;\n                case CALLDATACOPY:{             \t\n                    DataWord memOffsetData  = program.stackPop();\n                    DataWord dataOffsetData = program.stackPop();\n                    DataWord lengthData     = program.stackPop();\n                    \n                    byte[] msgData = program.getDataCopy(dataOffsetData, lengthData);\n\n                    if (logger.isInfoEnabled())\n                        hint = \"data: \" + Hex.toHexString(msgData);\n\n                    program.memorySave(memOffsetData.intValue(), msgData);\n                    program.step();\n                }\tbreak;\n                case CODESIZE: case EXTCODESIZE: {\n                \t\n                \tint length;\n                \tif (op == OpCode.CODESIZE)\n                \t\tlength = program.getCode().length;\n                \telse {\n                \t\tDataWord address = program.stackPop();\n                \t\tlength = program.getCodeAt(address).length;\n                \t}\n                    DataWord codeLength = new DataWord(length);\n\n                    if (logger.isInfoEnabled())\n                        hint = \"size: \" + length;\n\n                    program.stackPush(codeLength);\n                    program.step();\n                }\tbreak;              \n                case CODECOPY: case EXTCODECOPY: {\n                    byte[] fullCode;\n                    if (op == OpCode.CODECOPY)\n                \t\tfullCode = program.getCode();\n                \telse {\n                    \tDataWord address = program.stackPop();\n                    \tfullCode = program.getCodeAt(address);\n                \t}\n\n                \tDataWord memOffsetData    = program.stackPop();\n                \tBigInteger codeOffsetData = program.stackPop().value();\n                \tBigInteger lengthData     = program.stackPop().value();\n\n                \tif (fullCode == null\n\t\t\t\t\t\t\t|| BigInteger.valueOf(fullCode.length).compareTo(\n\t\t\t\t\t\t\t\t\tcodeOffsetData.add(lengthData)) < 0) {\n                        program.stop();\n                        break;\n                    }\n\n                    int length     = lengthData.intValue();\n                    int codeOffset = codeOffsetData.intValue();\n\n                    byte[] codeCopy = new byte[length];\n                    System.arraycopy(fullCode, codeOffset, codeCopy, 0, length);\n\n                    if (logger.isInfoEnabled())\n                        hint = \"code: \" + Hex.toHexString(codeCopy);\n\n                    program.memorySave(memOffsetData.intValue(), codeCopy);\n                    program.step();\n                }\tbreak;\n                case GASPRICE:{\n                    DataWord gasPrice = program.getGasPrice();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"price: \" + gasPrice.toString();\n\n                    program.stackPush(gasPrice);\n                    program.step();\n                }   break;\n\n                /**\n                 * Block Information\n                 */\n                case PREVHASH: {\n                    DataWord prevHash = program.getPrevHash();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"prevHash: \" + prevHash;\n\n                    program.stackPush(prevHash);\n                    program.step();\n                }   break;\n                case COINBASE: {\n                    DataWord coinbase = program.getCoinbase();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"coinbase: \" + Hex.toHexString(coinbase.getLast20Bytes());\n\n                    program.stackPush(coinbase);\n                    program.step();\n                }   break;\n                case TIMESTAMP:{\n                    DataWord timestamp = program.getTimestamp();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"timestamp: \" + timestamp.value();\n\n                    program.stackPush(timestamp);\n                    program.step();\n                }   break;\n                case NUMBER:{\n                    DataWord number = program.getNumber();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"number: \" + number.value();\n\n                    program.stackPush(number);\n                    program.step();\n                }   break;\n                case DIFFICULTY:{\n                    DataWord difficulty = program.getDifficulty();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"difficulty: \" + difficulty;\n\n                    program.stackPush(difficulty);\n                    program.step();\n                }   break;\n                case GASLIMIT:{\n                    DataWord gaslimit = program.getGaslimit();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"gaslimit: \" + gaslimit;\n\n                    program.stackPush(gaslimit);\n                    program.step();\n                }   break;\n                case POP:{\n                \tprogram.stackPop();\n                    program.step();\n                }\tbreak;\n                case DUP1: case DUP2: case DUP3: case DUP4:\n                case DUP5: case DUP6: case DUP7: case DUP8: \n                case DUP9: case DUP10: case DUP11: case DUP12: \n                case DUP13: case DUP14: case DUP15: case DUP16:{\n\n\t\t\t\t\tint n = op.val() - OpCode.DUP1.val() + 1;\n\t\t\t\t\tDataWord word_1 = stack.get(stack.size() - n);\n\t\t\t\t\tprogram.stackPush(word_1.clone());\n\t\t\t\t\tprogram.step();\n\t\t\t\t\t\n                }\tbreak;\n                case SWAP1: case SWAP2: case SWAP3: case SWAP4:\n                case SWAP5: case SWAP6: case SWAP7: case SWAP8: \n                case SWAP9: case SWAP10: case SWAP11: case SWAP12: \n                case SWAP13: case SWAP14: case SWAP15: case SWAP16:{\n\n        \t\t\tint n = op.val() - OpCode.SWAP1.val() + 2;\n                \tDataWord word_1 = stack.peek();\n        \t\t\tstack.set(stack.size() - 1, stack.get(stack.size() - n));\n        \t\t\tstack.set(stack.size() - n, word_1);\n        \t\t\tprogram.step();\n\n                }\tbreak;\n                case MLOAD:{\n                \tDataWord addr =  program.stackPop();\n                    DataWord data =  program.memoryLoad(addr);\n\n                    if (logger.isInfoEnabled())\n                        hint = \"data: \" + data;\n\n                    program.stackPush(data);\n                    program.step();\n                }\tbreak;\n                case MSTORE:{\n                \tDataWord addr  =  program.stackPop();\n                    DataWord value =  program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"addr: \" + addr + \" value: \" + value;\n\n                    program.memorySave(addr, value);\n                    program.step();\n                }\tbreak;\n                case MSTORE8:{\n                \tDataWord addr  =  program.stackPop();\n                    DataWord value =  program.stackPop();\n                    byte[] byteVal = {value.getData()[31]};\n                    program.memorySave(addr.intValue(), byteVal);\n                    program.step();\n                }\tbreak;\n                case SLOAD:{\n                \tDataWord key =  program.stackPop();\n                    DataWord val = program.storageLoad(key);\n\n                    if (logger.isInfoEnabled())\n\t\t\t\t\thint = \"key: \" + key + \" value: \" + val;\n\n                    if (val == null) {\n                        val = key.and(DataWord.ZERO);\n                    }\n                    program.stackPush(val);\n                    program.step();\n                }\tbreak;\n                case SSTORE:{\n                \tDataWord addr  =  program.stackPop();\n                    DataWord value =  program.stackPop();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"addr: \" + addr + \" value: \" + value;\n\n                    program.storageSave(addr, value);\n                    program.step();\n                }\tbreak;\n                case JUMP:{\n                \tDataWord pos  =  program.stackPop();\n                \tint nextPC = pos.intValue(); // possible overflow\n                \tif (nextPC != 0 && program.getOp(nextPC-1) != OpCode.JUMPDEST.val())\n        \t\t\t\tthrow new BadJumpDestinationException();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"~> \" + nextPC;\n\n        \t\t\tprogram.setPC(nextPC);\n\n                }\tbreak;\n                case JUMPI:{\n                \tDataWord pos   =  program.stackPop();\n                    DataWord cond  =  program.stackPop();\n                    \n                    if (!cond.isZero()) {\n                    \tint nextPC = pos.intValue(); // possible overflow\n                    \tif (nextPC != 0 && program.getOp(nextPC-1) != OpCode.JUMPDEST.val())\n            \t\t\t\tthrow new BadJumpDestinationException();\n\n                        if (logger.isInfoEnabled())\n                            hint = \"~> \" + nextPC;\n\n                        program.setPC(nextPC);\n                    } else {\n                        program.step();\n                    }\n                \t\n                }\tbreak;\n                case PC:{\n                    int pc = program.getPC();\n                    DataWord pcWord = new DataWord(pc);\n\n                    if (logger.isInfoEnabled())\n                        hint = pcWord.toString();\n\n                    program.stackPush(pcWord);\n                    program.step();\n                }\tbreak;\n                case MSIZE:{\n                    int memSize = program.getMemSize();\n                    DataWord wordMemSize = new DataWord(memSize);\n\n                    if (logger.isInfoEnabled())\n                        hint = \"\" + memSize;\n\n                    program.stackPush(wordMemSize);\n                    program.step();\n                }\tbreak;\n                case GAS:{\n                    DataWord gas = program.getGas();\n\n                    if (logger.isInfoEnabled())\n                        hint = \"\" + gas;\n\n                    program.stackPush(gas);\n                    program.step();\n                }   break;\n\n                case PUSH1:  case PUSH2:  case PUSH3:  case PUSH4:  case PUSH5:  case PUSH6:  case PUSH7:  case PUSH8:\n                case PUSH9:  case PUSH10: case PUSH11: case PUSH12: case PUSH13: case PUSH14: case PUSH15: case PUSH16:\n                case PUSH17: case PUSH18: case PUSH19: case PUSH20: case PUSH21: case PUSH22: case PUSH23: case PUSH24:\n                case PUSH25: case PUSH26: case PUSH27: case PUSH28: case PUSH29: case PUSH30: case PUSH31: case PUSH32:{\n                    program.step();\n                    int nPush = op.val() - PUSH1.val() + 1;\n\n                    byte[] data = program.sweep(nPush);\n                    hint = \"\" + Hex.toHexString(data);\n\n                    program.stackPush(data);\n                }\tbreak;\n                case JUMPDEST:{\n                \tprogram.step();\n                }\tbreak;\n                case CREATE:{\n                \tDataWord value      =  program.stackPop();\n                    DataWord inOffset   =  program.stackPop();\n                    DataWord inSize     =  program.stackPop();\n\n                    if (logger.isInfoEnabled())\n\t\t\t\t\t\tlogger.info(logString, program.getPC(),\n\t\t\t\t\t\t\t\tString.format(\"%-12s\", op.name()),\n\t\t\t\t\t\t\t\tprogram.getGas().value(),\n\t\t\t\t\t\t\t\tprogram.invokeData.getCallDeep(), hint);\n                    \n                    program.createContract(value, inOffset, inSize);\n\n                    program.step();\n                }\tbreak;\n                case CALL: case CALLCODE: {\n                \tDataWord gas        =  program.stackPop();\n                    DataWord codeAddress =  program.stackPop();\n                    DataWord value      =  program.stackPop();\n\n                    DataWord inDataOffs =  program.stackPop();\n                    DataWord inDataSize =  program.stackPop();\n\n                    DataWord outDataOffs =  program.stackPop();\n                    DataWord outDataSize =  program.stackPop();\n                    \n                    if (logger.isInfoEnabled()) {\n                    \thint = \"addr: \" + Hex.toHexString(codeAddress.getLast20Bytes()) \n                    \t\t\t+ \" gas: \" + gas.shortHex()\n                    \t\t\t+ \" inOff: \" + inDataOffs.shortHex()\n                    \t\t\t+ \" inSize: \" + inDataSize.shortHex();\n\t\t\t\t\t\tlogger.info(logString, program.getPC(),\n\t\t\t\t\t\t\t\tString.format(\"%-12s\", op.name()),\n\t\t\t\t\t\t\t\tprogram.getGas().value(),\n\t\t\t\t\t\t\t\tprogram.invokeData.getCallDeep(), hint);\n                    }\n\n\t\t\t\t\tMessageCall msg = new MessageCall(\n\t\t\t\t\t\t\top.equals(CALL) ? MsgType.CALL : MsgType.STATELESS,\n\t\t\t\t\t\t\tgas, codeAddress, value, inDataOffs, inDataSize,\n\t\t\t\t\t\t\toutDataOffs, outDataSize);\n                    program.callToAddress(msg);\n\n                    program.step();\n                }\tbreak;\n                case RETURN:{\n                \tDataWord offset   =  program.stackPop();\n                    DataWord size     =  program.stackPop();\n\n                    ByteBuffer hReturn = program.memoryChunk(offset, size);\n                    program.setHReturn(hReturn);\n\n                    if (logger.isInfoEnabled())\n                        hint = \"data: \" + Hex.toHexString(hReturn.array())\n                        \t\t+ \" offset: \" + offset.value()\n                        \t\t+ \" size: \" + size.value();\n\n                    program.step();\n                    program.stop();\n                }\tbreak;\n                case SUICIDE:{\n                \tDataWord address =  program.stackPop();\n                    program.suicide(address);\n                    \n                    if (logger.isInfoEnabled())\n                        hint = \"address: \" + Hex.toHexString(program.getOwnerAddress().getLast20Bytes());\n                    \n                    program.stop();\n                }\tbreak;\n                default:\n                \tbreak;\n            }\n            \n\t\t\tif (logger.isInfoEnabled() && !op.equals(CALL)\n\t\t\t\t\t&& !op.equals(CREATE))\n\t\t\t\tlogger.info(logString, stepBefore, String.format(\"%-12s\",\n\t\t\t\t\t\top.name()), program.getGas().longValue(),\n\t\t\t\t\t\tprogram.invokeData.getCallDeep(), hint);\n\t\t\t\n\t\t\tvmCounter++;\n        } catch (RuntimeException e) {\n        \tif(e instanceof OutOfGasException)\n               \tprogram.spendAllGas();\n            logger.warn(\"VM halted\", e.getMessage());\n           \tprogram.stop();\n           \tthrow e;\n        } finally {\n            program.fullTrace();\n        }\n    }", "signature": "void step(Program program)", "full_signature": "public void step(Program program)", "class_method_signature": "VM.step(Program program)", "testcase": false, "constructor": false, "invocations": ["fullTrace", "vmTrace", "saveOpTrace", "code", "getCurrentOp", "setLastOp", "val", "getMemSize", "getStack", "longValue", "getGas", "getPC", "stackRequire", "require", "get", "size", "storageLoad", "peek", "isZero", "isZero", "memNeeded", "peek", "memNeeded", "peek", "memNeeded", "peek", "memNeeded", "peek", "get", "size", "memNeeded", "peek", "get", "size", "memNeeded", "peek", "get", "size", "memNeeded", "peek", "get", "size", "memNeeded", "get", "size", "get", "size", "get", "size", "compareTo", "getGas", "longValue", "memNeeded", "get", "size", "get", "size", "memNeeded", "get", "size", "get", "size", "max", "memNeeded", "get", "size", "get", "size", "spendGas", "name", "compareTo", "longValue", "spendGas", "name", "intValue", "getNumber", "dumpBlock", "dumpLine", "setHReturn", "allocate", "stop", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "add", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "mul", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "sub", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "div", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "sValue", "sValue", "sDiv", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "mod", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "sValue", "sValue", "sMod", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "exp", "stackPush", "step", "stackPop", "negate", "isInfoEnabled", "value", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "compareTo", "value", "value", "and", "getData", "and", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "sValue", "sValue", "compareTo", "sValue", "sValue", "and", "getData", "and", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "sValue", "sValue", "compareTo", "sValue", "sValue", "and", "getData", "and", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "compareTo", "value", "value", "and", "getData", "and", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "isZero", "xor", "and", "getData", "and", "stackPush", "step", "stackPop", "isZero", "getData", "and", "isInfoEnabled", "value", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "and", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "or", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "value", "value", "xor", "stackPush", "step", "stackPop", "stackPop", "compareTo", "value", "getData", "intValue", "and", "getData", "isInfoEnabled", "value", "stackPush", "step", "stackPop", "stackPop", "stackPop", "addmod", "stackPush", "step", "stackPop", "stackPop", "stackPop", "mulmod", "stackPush", "step", "stackPop", "stackPop", "memoryChunk", "sha3", "array", "isInfoEnabled", "toString", "stackPush", "step", "getOwnerAddress", "isInfoEnabled", "toHexString", "getLast20Bytes", "stackPush", "step", "stackPop", "getBalance", "isInfoEnabled", "toHexString", "getLast20Bytes", "longValue", "stackPush", "step", "getOriginAddress", "isInfoEnabled", "toHexString", "getLast20Bytes", "stackPush", "step", "getCallerAddress", "isInfoEnabled", "toHexString", "getLast20Bytes", "stackPush", "step", "getCallValue", "isInfoEnabled", "stackPush", "step", "stackPop", "getDataValue", "isInfoEnabled", "stackPush", "step", "getDataSize", "isInfoEnabled", "value", "stackPush", "step", "stackPop", "stackPop", "stackPop", "getDataCopy", "isInfoEnabled", "toHexString", "memorySave", "intValue", "step", "getCode", "stackPop", "getCodeAt", "isInfoEnabled", "stackPush", "step", "getCode", "stackPop", "getCodeAt", "stackPop", "value", "stackPop", "value", "stackPop", "compareTo", "valueOf", "add", "stop", "intValue", "intValue", "arraycopy", "isInfoEnabled", "toHexString", "memorySave", "intValue", "step", "getGasPrice", "isInfoEnabled", "toString", "stackPush", "step", "getPrevHash", "isInfoEnabled", "stackPush", "step", "getCoinbase", "isInfoEnabled", "toHexString", "getLast20Bytes", "stackPush", "step", "getTimestamp", "isInfoEnabled", "value", "stackPush", "step", "getNumber", "isInfoEnabled", "value", "stackPush", "step", "getDifficulty", "isInfoEnabled", "stackPush", "step", "getGaslimit", "isInfoEnabled", "stackPush", "step", "stackPop", "step", "val", "val", "get", "size", "stackPush", "clone", "step", "val", "val", "peek", "set", "size", "get", "size", "set", "size", "step", "stackPop", "memoryLoad", "isInfoEnabled", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "memorySave", "step", "stackPop", "stackPop", "getData", "memorySave", "intValue", "step", "stackPop", "storageLoad", "isInfoEnabled", "and", "stackPush", "step", "stackPop", "stackPop", "isInfoEnabled", "storageSave", "step", "stackPop", "intValue", "getOp", "val", "isInfoEnabled", "setPC", "stackPop", "stackPop", "isZero", "intValue", "getOp", "val", "isInfoEnabled", "setPC", "step", "getPC", "isInfoEnabled", "toString", "stackPush", "step", "getMemSize", "isInfoEnabled", "stackPush", "step", "getGas", "isInfoEnabled", "stackPush", "step", "step", "val", "val", "sweep", "toHexString", "stackPush", "step", "stackPop", "stackPop", "stackPop", "isInfoEnabled", "info", "getPC", "format", "name", "value", "getGas", "getCallDeep", "createContract", "step", "stackPop", "stackPop", "stackPop", "stackPop", "stackPop", "stackPop", "stackPop", "isInfoEnabled", "toHexString", "getLast20Bytes", "shortHex", "shortHex", "shortHex", "info", "getPC", "format", "name", "value", "getGas", "getCallDeep", "equals", "callToAddress", "step", "stackPop", "stackPop", "memoryChunk", "setHReturn", "isInfoEnabled", "toHexString", "array", "value", "value", "step", "stop", "stackPop", "suicide", "isInfoEnabled", "toHexString", "getLast20Bytes", "getOwnerAddress", "stop", "isInfoEnabled", "equals", "equals", "info", "format", "name", "longValue", "getGas", "getCallDeep", "spendAllGas", "warn", "getMessage", "stop", "fullTrace"]}, "repository": {"repo_id": 24503275, "url": "https://github.com/ethereumj/ethereumj", "language": "Java", "is_fork": false, "fork_count": 22, "stargazer_count": 27, "size": 13884, "license": "licensed"}}