{"test_class": {"identifier": "NodeCollectionWatcherTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static TestingCluster zkServer;", "modifier": "private static", "type": "TestingCluster", "declarator": "zkServer", "var_name": "zkServer"}, {"original_string": "private static CuratorFramework curator;", "modifier": "private static", "type": "CuratorFramework", "declarator": "curator", "var_name": "curator"}, {"original_string": "private static ZooKeeper zooKeeper;", "modifier": "private static", "type": "ZooKeeper", "declarator": "zooKeeper", "var_name": "zooKeeper"}, {"original_string": "private final AtomicInteger counter = new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "counter = new AtomicInteger(0)", "var_name": "counter"}], "file": "cn-zookeeper/src/test/java/org/cloudname/backends/zookeeper/NodeCollectionWatcherTest.java"}, "test_case": {"identifier": "rapidChanges", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void rapidChanges() throws Exception {\n        final int maxPropagationTime = 100;\n\n        final String pathPrefix = \"/foo/rapido\";\n\n        curator.create().creatingParentsIfNeeded().forPath(pathPrefix);\n\n        final int numNodes = 50;\n        final ListenerCounter listener = new ListenerCounter(numNodes, 0, numNodes);\n\n        final NodeCollectionWatcher nodeCollectionWatcher = new NodeCollectionWatcher(zooKeeper, pathPrefix, listener);\n        // Create all of the nodes at once\n        for (int i = 0; i < numNodes; i++) {\n            curator.create().forPath(pathPrefix + \"/node\" + i, getData());\n        }\n        assertTrue(listener.createLatch.await(maxPropagationTime, TimeUnit.MILLISECONDS));\n        assertThat(listener.createCount.get(), is(numNodes));\n        assertThat(listener.dataCount.get(), is(0));\n        assertThat(listener.removeCount.get(), is(0));\n\n        // Repeat data test multiple times to ensure data changes are detected\n        // repeatedly on the same nodes\n        int total = 0;\n        for (int j = 0; j < 5; j++) {\n            listener.dataLatch = new CountDownLatch(numNodes);\n            // Since there's a watch for every node all of the data changes should be detected\n            for (int i = 0; i < numNodes; i++) {\n                curator.setData().forPath(pathPrefix + \"/node\" + i, getData());\n            }\n            total += numNodes;\n            assertTrue(listener.dataLatch.await(maxPropagationTime, TimeUnit.MILLISECONDS));\n            assertThat(listener.createCount.get(), is(numNodes));\n            assertThat(listener.dataCount.get(), is(total));\n            assertThat(listener.removeCount.get(), is(0));\n        }\n\n        // Finally, remove everything in rapid succession\n        // Create all of the nodes at once\n        for (int i = 0; i < numNodes; i++) {\n            curator.delete().forPath(pathPrefix + \"/node\" + i);\n        }\n\n        assertTrue(listener.removeLatch.await(maxPropagationTime, TimeUnit.MILLISECONDS));\n        assertThat(listener.createCount.get(), is(numNodes));\n        assertThat(listener.dataCount.get(), is(total));\n        assertThat(listener.removeCount.get(), is(numNodes));\n\n        nodeCollectionWatcher.shutdown();\n    }", "signature": "void rapidChanges()", "full_signature": "@Test public void rapidChanges()", "class_method_signature": "NodeCollectionWatcherTest.rapidChanges()", "testcase": true, "constructor": false, "invocations": ["forPath", "creatingParentsIfNeeded", "create", "forPath", "create", "getData", "assertTrue", "await", "assertThat", "get", "is", "assertThat", "get", "is", "assertThat", "get", "is", "forPath", "setData", "getData", "assertTrue", "await", "assertThat", "get", "is", "assertThat", "get", "is", "assertThat", "get", "is", "forPath", "delete", "assertTrue", "await", "assertThat", "get", "is", "assertThat", "get", "is", "assertThat", "get", "is", "shutdown"]}, "focal_class": {"identifier": "NodeCollectionWatcher", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = Logger.getLogger(NodeCollectionWatcher.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(NodeCollectionWatcher.class.getName())", "var_name": "LOG"}, {"original_string": "private final Map<String, Long> childMzxid = new HashMap<>();", "modifier": "private final", "type": "Map<String, Long>", "declarator": "childMzxid = new HashMap<>()", "var_name": "childMzxid"}, {"original_string": "private final Object syncObject = new Object();", "modifier": "private final", "type": "Object", "declarator": "syncObject = new Object()", "var_name": "syncObject"}, {"original_string": "private final ZooKeeper zk;", "modifier": "private final", "type": "ZooKeeper", "declarator": "zk", "var_name": "zk"}, {"original_string": "private final String pathToWatch;", "modifier": "private final", "type": "String", "declarator": "pathToWatch", "var_name": "pathToWatch"}, {"original_string": "private final AtomicBoolean shuttingDown = new AtomicBoolean(false);", "modifier": "private final", "type": "AtomicBoolean", "declarator": "shuttingDown = new AtomicBoolean(false)", "var_name": "shuttingDown"}, {"original_string": "private final NodeWatcherListener listener;", "modifier": "private final", "type": "NodeWatcherListener", "declarator": "listener", "var_name": "listener"}, {"original_string": "private final Watcher nodeCollectionWatcher = (watchedEvent) -> {\n        switch (watchedEvent.getType()) {\n            case NodeChildrenChanged:\n                // Child values have changed, read children, generate events\n                readChildNodes();\n                break;\n            case None:\n                // Some zookeeper event. Watches might not apply anymore. Reapply.\n                switch (watchedEvent.getState()) {\n                    case ConnectedReadOnly:\n                        LOG.severe(\"Connected to readonly cluster\");\n                        // Connected to a cluster without quorum. Nodes might not be\n                        // correct but re-read the nodes.\n                        readChildNodes();\n                        break;\n                    case SyncConnected:\n                        LOG.info(\"Connected to cluster\");\n                        // (re-)Connected to the cluster. Nodes must be re-read. Discard\n                        // those that aren't found, keep unchanged ones.\n                        readChildNodes();\n                        break;\n                    case Disconnected:\n                        // Disconnected from the cluster. The nodes might not be\n                        // up to date (but a reconnect might solve the issue)\n                        LOG.log(Level.WARNING, \"Disconnected from zk cluster\");\n                        break;\n                    case Expired:\n                        // Session has expired. Nodes are no longer available\n                        removeAllChildNodes();\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            default:\n                break;\n        }\n    };", "modifier": "private final", "type": "Watcher", "declarator": "nodeCollectionWatcher = (watchedEvent) -> {\n        switch (watchedEvent.getType()) {\n            case NodeChildrenChanged:\n                // Child values have changed, read children, generate events\n                readChildNodes();\n                break;\n            case None:\n                // Some zookeeper event. Watches might not apply anymore. Reapply.\n                switch (watchedEvent.getState()) {\n                    case ConnectedReadOnly:\n                        LOG.severe(\"Connected to readonly cluster\");\n                        // Connected to a cluster without quorum. Nodes might not be\n                        // correct but re-read the nodes.\n                        readChildNodes();\n                        break;\n                    case SyncConnected:\n                        LOG.info(\"Connected to cluster\");\n                        // (re-)Connected to the cluster. Nodes must be re-read. Discard\n                        // those that aren't found, keep unchanged ones.\n                        readChildNodes();\n                        break;\n                    case Disconnected:\n                        // Disconnected from the cluster. The nodes might not be\n                        // up to date (but a reconnect might solve the issue)\n                        LOG.log(Level.WARNING, \"Disconnected from zk cluster\");\n                        break;\n                    case Expired:\n                        // Session has expired. Nodes are no longer available\n                        removeAllChildNodes();\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            default:\n                break;\n        }\n    }", "var_name": "nodeCollectionWatcher"}, {"original_string": "private final Watcher changeWatcher = (watchedEvent) -> {\n        if (shuttingDown.get()) {\n            return;\n        }\n        switch (watchedEvent.getType()) {\n            case NodeDeleted:\n                removeChildNode(watchedEvent.getPath());\n                break;\n            case NodeDataChanged:\n                processNode(watchedEvent.getPath());\n                break;\n            default:\n                break;\n        }\n    };", "modifier": "private final", "type": "Watcher", "declarator": "changeWatcher = (watchedEvent) -> {\n        if (shuttingDown.get()) {\n            return;\n        }\n        switch (watchedEvent.getType()) {\n            case NodeDeleted:\n                removeChildNode(watchedEvent.getPath());\n                break;\n            case NodeDataChanged:\n                processNode(watchedEvent.getPath());\n                break;\n            default:\n                break;\n        }\n    }", "var_name": "changeWatcher"}], "methods": [{"identifier": "NodeCollectionWatcher", "parameters": "(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "modifiers": "public", "return": "", "signature": " NodeCollectionWatcher(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "full_signature": "public  NodeCollectionWatcher(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "class_method_signature": "NodeCollectionWatcher.NodeCollectionWatcher(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "testcase": false, "constructor": true}, {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "NodeCollectionWatcher.shutdown()", "testcase": false, "constructor": false}, {"identifier": "removeAllChildNodes", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void removeAllChildNodes()", "full_signature": "private void removeAllChildNodes()", "class_method_signature": "NodeCollectionWatcher.removeAllChildNodes()", "testcase": false, "constructor": false}, {"identifier": "readChildNodes", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void readChildNodes()", "full_signature": "private void readChildNodes()", "class_method_signature": "NodeCollectionWatcher.readChildNodes()", "testcase": false, "constructor": false}, {"identifier": "processNode", "parameters": "(final String nodePath)", "modifiers": "private", "return": "void", "signature": "void processNode(final String nodePath)", "full_signature": "private void processNode(final String nodePath)", "class_method_signature": "NodeCollectionWatcher.processNode(final String nodePath)", "testcase": false, "constructor": false}, {"identifier": "removeChildNode", "parameters": "(final String nodePath)", "modifiers": "private", "return": "void", "signature": "void removeChildNode(final String nodePath)", "full_signature": "private void removeChildNode(final String nodePath)", "class_method_signature": "NodeCollectionWatcher.removeChildNode(final String nodePath)", "testcase": false, "constructor": false}, {"identifier": "generateCreateEvent", "parameters": "(final String nodePath, final String data)", "modifiers": "private", "return": "void", "signature": "void generateCreateEvent(final String nodePath, final String data)", "full_signature": "private void generateCreateEvent(final String nodePath, final String data)", "class_method_signature": "NodeCollectionWatcher.generateCreateEvent(final String nodePath, final String data)", "testcase": false, "constructor": false}, {"identifier": "generateDataChangeEvent", "parameters": "(final String nodePath, final String data)", "modifiers": "private", "return": "void", "signature": "void generateDataChangeEvent(final String nodePath, final String data)", "full_signature": "private void generateDataChangeEvent(final String nodePath, final String data)", "class_method_signature": "NodeCollectionWatcher.generateDataChangeEvent(final String nodePath, final String data)", "testcase": false, "constructor": false}, {"identifier": "generateRemoveEvent", "parameters": "(final String nodePath)", "modifiers": "private", "return": "void", "signature": "void generateRemoveEvent(final String nodePath)", "full_signature": "private void generateRemoveEvent(final String nodePath)", "class_method_signature": "NodeCollectionWatcher.generateRemoveEvent(final String nodePath)", "testcase": false, "constructor": false}], "file": "cn-zookeeper/src/main/java/org/cloudname/backends/zookeeper/NodeCollectionWatcher.java"}, "focal_method": {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void shutdown() {\n        shuttingDown.set(true);\n    }", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "NodeCollectionWatcher.shutdown()", "testcase": false, "constructor": false, "invocations": ["set"]}, "repository": {"repo_id": 2329961, "url": "https://github.com/Cloudname/cloudname", "language": "Java", "is_fork": false, "fork_count": 23, "stargazer_count": 21, "size": 26031, "license": "licensed"}}