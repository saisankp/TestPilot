{"test_class": {"identifier": "PushSelectCriteriaTest", "superclass": "extends AbstractQueryTest", "interfaces": "", "fields": [{"original_string": "private PushSelectCriteria rule;", "modifier": "private", "type": "PushSelectCriteria", "declarator": "rule", "var_name": "rule"}, {"original_string": "private QueryContext context;", "modifier": "private", "type": "QueryContext", "declarator": "context", "var_name": "context"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/query/optimize/PushSelectCriteriaTest.java"}, "test_case": {"identifier": "shouldPushDownAllSelectNodesThatApplyToOneSelectorToBelowAccessNodeForThatSelector", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldPushDownAllSelectNodesThatApplyToOneSelectorToBelowAccessNodeForThatSelector() {\n        // Each of the PROJECT, SELECT, and SELECT nodes must have the names of the selectors that they apply to ...\n        PlanNode project = new PlanNode(Type.PROJECT, selector(\"Selector1\"), selector(\"Selector2\"));\n        PlanNode select1 = new PlanNode(Type.SELECT, project, selector(\"Selector1\"));\n        PlanNode select2 = new PlanNode(Type.SELECT, select1, selector(\"Selector2\"));\n        PlanNode select3 = new PlanNode(Type.SELECT, select2, selector(\"Selector1\"), selector(\"Selector2\"));\n        PlanNode select4 = new PlanNode(Type.SELECT, select3, selector(\"Selector1\"));\n        PlanNode join = new PlanNode(Type.JOIN, select4, selector(\"Selector1\"), selector(\"Selector2\"));\n        PlanNode s1Access = new PlanNode(Type.ACCESS, join, selector(\"Selector1\"));\n        PlanNode s1Source = new PlanNode(Type.SOURCE, s1Access, selector(\"Selector1\"));\n        PlanNode s2Access = new PlanNode(Type.ACCESS, join, selector(\"Selector2\"));\n        PlanNode s2Source = new PlanNode(Type.SOURCE, s2Access, selector(\"Selector2\"));\n        // Set the join type ...\n        join.setProperty(Property.JOIN_TYPE, JoinType.INNER);\n\n        // Execute the rule ...\n        PlanNode result = rule.execute(context, project, new LinkedList<OptimizerRule>());\n\n        // System.out.println(result);\n\n        assertThat(result, is(sameInstance(project)));\n        assertChildren(project, select3);\n        assertChildren(select3, join);\n        assertChildren(join, s1Access, s2Access);\n        assertChildren(s1Access, select1);\n        assertChildren(select1, select4);\n        assertChildren(select4, s1Source);\n        assertChildren(s2Access, select2);\n        assertChildren(select2, s2Source);\n        assertChildren(s2Source);\n        assertChildren(s1Source);\n    }", "signature": "void shouldPushDownAllSelectNodesThatApplyToOneSelectorToBelowAccessNodeForThatSelector()", "full_signature": "@Test public void shouldPushDownAllSelectNodesThatApplyToOneSelectorToBelowAccessNodeForThatSelector()", "class_method_signature": "PushSelectCriteriaTest.shouldPushDownAllSelectNodesThatApplyToOneSelectorToBelowAccessNodeForThatSelector()", "testcase": true, "constructor": false, "invocations": ["selector", "selector", "selector", "selector", "selector", "selector", "selector", "selector", "selector", "selector", "selector", "selector", "selector", "setProperty", "execute", "assertThat", "is", "sameInstance", "assertChildren", "assertChildren", "assertChildren", "assertChildren", "assertChildren", "assertChildren", "assertChildren", "assertChildren", "assertChildren", "assertChildren"]}, "focal_class": {"identifier": "PushSelectCriteria", "superclass": "", "interfaces": "implements OptimizerRule", "fields": [{"original_string": "public static final PushSelectCriteria INSTANCE = new PushSelectCriteria();", "modifier": "public static final", "type": "PushSelectCriteria", "declarator": "INSTANCE = new PushSelectCriteria()", "var_name": "INSTANCE"}, {"original_string": "private static final Set<Type> ORIGINATING_TYPES = Collections.unmodifiableSet(EnumSet.of(Type.NULL,\n                                                                                              Type.SOURCE,\n                                                                                              Type.JOIN,\n                                                                                              Type.SET_OPERATION));", "modifier": "private static final", "type": "Set<Type>", "declarator": "ORIGINATING_TYPES = Collections.unmodifiableSet(EnumSet.of(Type.NULL,\n                                                                                              Type.SOURCE,\n                                                                                              Type.JOIN,\n                                                                                              Type.SET_OPERATION))", "var_name": "ORIGINATING_TYPES"}], "methods": [{"identifier": "execute", "parameters": "( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "modifiers": "@Override public", "return": "PlanNode", "signature": "PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "full_signature": "@Override public PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "class_method_signature": "PushSelectCriteria.execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "testcase": false, "constructor": false}, {"identifier": "pushDownJoinCriteria", "parameters": "( PlanNode criteriaNode,\n                                            PlanNode joinNode )", "modifiers": "protected", "return": "boolean", "signature": "boolean pushDownJoinCriteria( PlanNode criteriaNode,\n                                            PlanNode joinNode )", "full_signature": "protected boolean pushDownJoinCriteria( PlanNode criteriaNode,\n                                            PlanNode joinNode )", "class_method_signature": "PushSelectCriteria.pushDownJoinCriteria( PlanNode criteriaNode,\n                                            PlanNode joinNode )", "testcase": false, "constructor": false}, {"identifier": "moveCriteriaIntoOnClause", "parameters": "( PlanNode criteriaNode,\n                                           PlanNode joinNode )", "modifiers": "private", "return": "void", "signature": "void moveCriteriaIntoOnClause( PlanNode criteriaNode,\n                                           PlanNode joinNode )", "full_signature": "private void moveCriteriaIntoOnClause( PlanNode criteriaNode,\n                                           PlanNode joinNode )", "class_method_signature": "PushSelectCriteria.moveCriteriaIntoOnClause( PlanNode criteriaNode,\n                                           PlanNode joinNode )", "testcase": false, "constructor": false}, {"identifier": "findOriginatingNode", "parameters": "( PlanNode criteriaNode,\n                                            List<PlanNode> originatingNodes )", "modifiers": "protected", "return": "PlanNode", "signature": "PlanNode findOriginatingNode( PlanNode criteriaNode,\n                                            List<PlanNode> originatingNodes )", "full_signature": "protected PlanNode findOriginatingNode( PlanNode criteriaNode,\n                                            List<PlanNode> originatingNodes )", "class_method_signature": "PushSelectCriteria.findOriginatingNode( PlanNode criteriaNode,\n                                            List<PlanNode> originatingNodes )", "testcase": false, "constructor": false}, {"identifier": "pushTowardsOriginatingNode", "parameters": "( PlanNode criteriaNode,\n                                                  PlanNode originatingNode )", "modifiers": "protected", "return": "boolean", "signature": "boolean pushTowardsOriginatingNode( PlanNode criteriaNode,\n                                                  PlanNode originatingNode )", "full_signature": "protected boolean pushTowardsOriginatingNode( PlanNode criteriaNode,\n                                                  PlanNode originatingNode )", "class_method_signature": "PushSelectCriteria.pushTowardsOriginatingNode( PlanNode criteriaNode,\n                                                  PlanNode originatingNode )", "testcase": false, "constructor": false}, {"identifier": "findBestChildForCriteria", "parameters": "( PlanNode criteriaNode,\n                                                 PlanNode originatingNode )", "modifiers": "protected", "return": "PlanNode", "signature": "PlanNode findBestChildForCriteria( PlanNode criteriaNode,\n                                                 PlanNode originatingNode )", "full_signature": "protected PlanNode findBestChildForCriteria( PlanNode criteriaNode,\n                                                 PlanNode originatingNode )", "class_method_signature": "PushSelectCriteria.findBestChildForCriteria( PlanNode criteriaNode,\n                                                 PlanNode originatingNode )", "testcase": false, "constructor": false}, {"identifier": "atBoundary", "parameters": "( PlanNode criteriaNode,\n                                  PlanNode originatingNode )", "modifiers": "protected", "return": "boolean", "signature": "boolean atBoundary( PlanNode criteriaNode,\n                                  PlanNode originatingNode )", "full_signature": "protected boolean atBoundary( PlanNode criteriaNode,\n                                  PlanNode originatingNode )", "class_method_signature": "PushSelectCriteria.atBoundary( PlanNode criteriaNode,\n                                  PlanNode originatingNode )", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "PushSelectCriteria.toString()", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/query/optimize/PushSelectCriteria.java"}, "focal_method": {"identifier": "execute", "parameters": "( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "modifiers": "@Override public", "return": "PlanNode", "body": "@Override\n    public PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack ) {\n        // Create set of nodes that no longer need to be considered\n        Set<PlanNode> deadNodes = new HashSet<PlanNode>();\n\n        // Loop while criteria nodes are still being moved ...\n        boolean movedSomeNode = true;\n        while (movedSomeNode) {\n\n            // Reset flag to false for this iteration\n            movedSomeNode = false;\n\n            // Find all of the criteria (SELECT) nodes that can be pushed ...\n            List<PlanNode> criteriaNodes = plan.findAllAtOrBelow(Type.SELECT);\n\n            // Find all of the NULL, SOURCE, SET_OPERATION or JOIN nodes, ordered correctly; we'll use this\n            // to look for the node on which each criteria can apply ...\n            List<PlanNode> originatingNodes = plan.findAllAtOrBelow(ORIGINATING_TYPES);\n\n            // Starting with the lowest one first ...\n            Collections.reverse(criteriaNodes);\n            for (PlanNode criteriaNode : criteriaNodes) {\n                // Skip any node we've already tried and failed to move ...\n                if (deadNodes.contains(criteriaNode)) continue;\n\n                // Find the first originating node that has all of the required selectors for this criteria ...\n                PlanNode originatingNode = findOriginatingNode(criteriaNode, originatingNodes);\n                if (originatingNode == null || originatingNode == criteriaNode) {\n                    deadNodes.add(criteriaNode);\n                    continue;\n                }\n\n                // Try to push the criteria node down ...\n                if (!pushTowardsOriginatingNode(criteriaNode, originatingNode)) {\n                    // criteria node could not be moved ...\n                    deadNodes.add(criteriaNode);\n                    continue;\n                }\n\n                // The criteria node was indeed moved, but it may need to be adjusted ...\n                boolean adjusted = false;\n                switch (originatingNode.getType()) {\n                    case SOURCE:\n\n                        break;\n                    case JOIN:\n                        if (!criteriaNode.hasAncestorOfType(Type.ACCESS)) {\n                            // Try to push down the join criteria (only when above ACCESS nodes) ...\n                            adjusted = pushDownJoinCriteria(criteriaNode, originatingNode);\n                        }\n                        break;\n                    default:\n                        // Nothing to change ...\n                }\n                if (adjusted) {\n                    // We changed something, so make sure we go through the loop again ...\n                    movedSomeNode = true;\n                } else {\n                    // Nothing was changed from the push-down, so consider this criteria node as processed ...\n                    deadNodes.add(criteriaNode);\n                }\n            }\n        }\n        return plan;\n    }", "signature": "PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "full_signature": "@Override public PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "class_method_signature": "PushSelectCriteria.execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "testcase": false, "constructor": false, "invocations": ["findAllAtOrBelow", "findAllAtOrBelow", "reverse", "contains", "findOriginatingNode", "add", "pushTowardsOriginatingNode", "add", "getType", "hasAncestorOfType", "pushDownJoinCriteria", "add"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}