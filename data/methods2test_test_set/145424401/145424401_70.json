{"test_class": {"identifier": "PipWrapperTest", "superclass": "", "interfaces": "", "fields": [], "file": "lang-python/src/test/java/org/eclipse/steady/python/pip/PipWrapperTest.java"}, "test_case": {"identifier": "testGetFreezePackages", "parameters": "()", "modifiers": "@Test @Category(Slow.class) public", "return": "void", "body": "@Test\n  @Category(Slow.class)\n  public void testGetFreezePackages() throws ProcessWrapperException, FileAnalysisException {\n    VulasConfiguration.getGlobal().setProperty(ThreadUtil.NO_OF_THREADS, \"AUTO\");\n    final PipWrapper pip = new PipWrapper();\n    Set<PipInstalledPackage> packs = null;\n    try {\n      packs = pip.getFreezePackages();\n    } catch (IOException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    } catch (InterruptedException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    }\n    assertTrue(packs.size() > 0);\n\n    // Compute the digests\n    for (PipInstalledPackage p : packs) {\n      System.out.println(p);\n      /*if(p.getName().equals(\"setuptools\")) {\n      \tfinal String sha1 = p.getSha1();\n      \tassertTrue(sha1!=null && sha1.length()>0);\n      \tassertTrue(p.getConstructs().size()>0);\n      }*/\n    }\n  }", "signature": "void testGetFreezePackages()", "full_signature": "@Test @Category(Slow.class) public void testGetFreezePackages()", "class_method_signature": "PipWrapperTest.testGetFreezePackages()", "testcase": true, "constructor": false, "invocations": ["setProperty", "getGlobal", "getFreezePackages", "printStackTrace", "printStackTrace", "assertTrue", "size", "println"]}, "focal_class": {"identifier": "PipWrapper", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = org.apache.logging.log4j.LogManager.getLogger();", "modifier": "private static final", "type": "Logger", "declarator": "log = org.apache.logging.log4j.LogManager.getLogger()", "var_name": "log"}, {"original_string": "static final Pattern DOWNLOAD_PATTERN = Pattern.compile(\"^\\\\s*Downloading\\\\s*(http\\\\S*).*$\");", "modifier": "static final", "type": "Pattern", "declarator": "DOWNLOAD_PATTERN = Pattern.compile(\"^\\\\s*Downloading\\\\s*(http\\\\S*).*$\")", "var_name": "DOWNLOAD_PATTERN"}, {"original_string": "static final Pattern SAVED_PATTERN_1 =\n      Pattern.compile(\"^\\\\s*File was already downloaded\\\\s*(.*)$\");", "modifier": "static final", "type": "Pattern", "declarator": "SAVED_PATTERN_1 =\n      Pattern.compile(\"^\\\\s*File was already downloaded\\\\s*(.*)$\")", "var_name": "SAVED_PATTERN_1"}, {"original_string": "static final Pattern SAVED_PATTERN_2 = Pattern.compile(\"^\\\\s*Saved\\\\s*(.*)$\");", "modifier": "static final", "type": "Pattern", "declarator": "SAVED_PATTERN_2 = Pattern.compile(\"^\\\\s*Saved\\\\s*(.*)$\")", "var_name": "SAVED_PATTERN_2"}, {"original_string": "static final String PACK_PATTERN_REGEX = \".*<pack>-<version>.*\";", "modifier": "static final", "type": "String", "declarator": "PACK_PATTERN_REGEX = \".*<pack>-<version>.*\"", "var_name": "PACK_PATTERN_REGEX"}, {"original_string": "private Path pathToPip = null;", "modifier": "private", "type": "Path", "declarator": "pathToPip = null", "var_name": "pathToPip"}, {"original_string": "private Path logDir = null;", "modifier": "private", "type": "Path", "declarator": "logDir = null", "var_name": "logDir"}, {"original_string": "private StringList ignorePacks = new StringList();", "modifier": "private", "type": "StringList", "declarator": "ignorePacks = new StringList()", "var_name": "ignorePacks"}], "methods": [{"identifier": "PipWrapper", "parameters": "()", "modifiers": "public", "return": "", "signature": " PipWrapper()", "full_signature": "public  PipWrapper()", "class_method_signature": "PipWrapper.PipWrapper()", "testcase": false, "constructor": true}, {"identifier": "PipWrapper", "parameters": "(Path _path_to_pip, Path _log_dir)", "modifiers": "public", "return": "", "signature": " PipWrapper(Path _path_to_pip, Path _log_dir)", "full_signature": "public  PipWrapper(Path _path_to_pip, Path _log_dir)", "class_method_signature": "PipWrapper.PipWrapper(Path _path_to_pip, Path _log_dir)", "testcase": false, "constructor": true}, {"identifier": "ignorePackage", "parameters": "(String _p)", "modifiers": "private", "return": "boolean", "signature": "boolean ignorePackage(String _p)", "full_signature": "private boolean ignorePackage(String _p)", "class_method_signature": "PipWrapper.ignorePackage(String _p)", "testcase": false, "constructor": false}, {"identifier": "isAvailable", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isAvailable()", "full_signature": "public boolean isAvailable()", "class_method_signature": "PipWrapper.isAvailable()", "testcase": false, "constructor": false}, {"identifier": "installPackages", "parameters": "(Path _project)", "modifiers": "public", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> installPackages(Path _project)", "full_signature": "public Set<PipInstalledPackage> installPackages(Path _project)", "class_method_signature": "PipWrapper.installPackages(Path _project)", "testcase": false, "constructor": false}, {"identifier": "getFreezePackages", "parameters": "()", "modifiers": "public", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> getFreezePackages()", "full_signature": "public Set<PipInstalledPackage> getFreezePackages()", "class_method_signature": "PipWrapper.getFreezePackages()", "testcase": false, "constructor": false}, {"identifier": "parsePipFreezeOutput", "parameters": "(Path _file)", "modifiers": "private", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> parsePipFreezeOutput(Path _file)", "full_signature": "private Set<PipInstalledPackage> parsePipFreezeOutput(Path _file)", "class_method_signature": "PipWrapper.parsePipFreezeOutput(Path _file)", "testcase": false, "constructor": false}, {"identifier": "getListPackages", "parameters": "()", "modifiers": "public", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> getListPackages()", "full_signature": "public Set<PipInstalledPackage> getListPackages()", "class_method_signature": "PipWrapper.getListPackages()", "testcase": false, "constructor": false}, {"identifier": "parsePipListOutput", "parameters": "(Path _file)", "modifiers": "private", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> parsePipListOutput(Path _file)", "full_signature": "private Set<PipInstalledPackage> parsePipListOutput(Path _file)", "class_method_signature": "PipWrapper.parsePipListOutput(Path _file)", "testcase": false, "constructor": false}, {"identifier": "deserializePipListOutput", "parameters": "(Path _file)", "modifiers": "private", "return": "Set<PipInstalledPackage>", "signature": "Set<PipInstalledPackage> deserializePipListOutput(Path _file)", "full_signature": "private Set<PipInstalledPackage> deserializePipListOutput(Path _file)", "class_method_signature": "PipWrapper.deserializePipListOutput(Path _file)", "testcase": false, "constructor": false}, {"identifier": "parsePipShowOutput", "parameters": "(Path _file)", "modifiers": "private", "return": "Map<String, String>", "signature": "Map<String, String> parsePipShowOutput(Path _file)", "full_signature": "private Map<String, String> parsePipShowOutput(Path _file)", "class_method_signature": "PipWrapper.parsePipShowOutput(Path _file)", "testcase": false, "constructor": false}, {"identifier": "searchDownloadInfo", "parameters": "(Set<PipInstalledPackage> _packs, String _out)", "modifiers": "", "return": "void", "signature": "void searchDownloadInfo(Set<PipInstalledPackage> _packs, String _out)", "full_signature": " void searchDownloadInfo(Set<PipInstalledPackage> _packs, String _out)", "class_method_signature": "PipWrapper.searchDownloadInfo(Set<PipInstalledPackage> _packs, String _out)", "testcase": false, "constructor": false}, {"identifier": "searchDownloadInfo", "parameters": "(PipInstalledPackage _p, String _out)", "modifiers": "private", "return": "void", "signature": "void searchDownloadInfo(PipInstalledPackage _p, String _out)", "full_signature": "private void searchDownloadInfo(PipInstalledPackage _p, String _out)", "class_method_signature": "PipWrapper.searchDownloadInfo(PipInstalledPackage _p, String _out)", "testcase": false, "constructor": false}], "file": "lang-python/src/main/java/org/eclipse/steady/python/pip/PipWrapper.java"}, "focal_method": {"identifier": "getFreezePackages", "parameters": "()", "modifiers": "public", "return": "Set<PipInstalledPackage>", "body": "public Set<PipInstalledPackage> getFreezePackages()\n      throws ProcessWrapperException, IOException, InterruptedException {\n    final StopWatch sw = new StopWatch(\"pip freeze\").start();\n    Set<PipInstalledPackage> packages = null;\n    ProcessWrapper pw = new ProcessWrapper().setCommand(this.pathToPip, \"freeze\").setPath(logDir);\n    final Thread t = new Thread(pw, \"pip\");\n    t.start();\n    t.join();\n    if (pw.terminatedWithSuccess()) {\n      // Create packages\n      packages = this.parsePipFreezeOutput(pw.getOutFile());\n\n      // Log\n      log.info(\"Found [\" + packages.size() + \"] pip packages:\");\n      for (PipInstalledPackage pack : packages) log.info(\"    \" + pack);\n\n      // Call pip show and pip download in separate threads\n      final ExecutorService pool =\n          Executors.newFixedThreadPool(ThreadUtil.getNoThreads(2)); // newSingleThreadExecutor();\n      final Set<Future<PipInstalledPackage>> futures = new HashSet<Future<PipInstalledPackage>>();\n      for (PipInstalledPackage pack : packages) {\n        futures.add(pool.submit(new PipShow(pack)));\n        futures.add(pool.submit(new PipDownload(pack)));\n      }\n      pool.shutdown();\n      try {\n        while (!pool.awaitTermination(10, TimeUnit.SECONDS)) {\n          int done = 0;\n          for (Future<PipInstalledPackage> f : futures) {\n            if (f.isDone()) done++;\n          }\n          sw.lap(\"[\" + done + \"/\" + futures.size() + \"] pip jobs are done\");\n        }\n      } catch (InterruptedException e) {\n        PipWrapper.log.error(\"Interrupt exception\");\n      }\n    }\n    sw.stop();\n    return packages;\n  }", "signature": "Set<PipInstalledPackage> getFreezePackages()", "full_signature": "public Set<PipInstalledPackage> getFreezePackages()", "class_method_signature": "PipWrapper.getFreezePackages()", "testcase": false, "constructor": false, "invocations": ["start", "setPath", "setCommand", "start", "join", "terminatedWithSuccess", "parsePipFreezeOutput", "getOutFile", "info", "size", "info", "newFixedThreadPool", "getNoThreads", "add", "submit", "add", "submit", "shutdown", "awaitTermination", "isDone", "lap", "size", "error", "stop"]}, "repository": {"repo_id": 145424401, "url": "https://github.com/eclipse/steady", "stars": 353, "created": "8/20/2018 1:54:15 PM +00:00", "updates": "2020-01-25T08:37:00+00:00", "fork": "False", "license": "licensed"}}