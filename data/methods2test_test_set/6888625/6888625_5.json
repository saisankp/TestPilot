{"test_class": {"identifier": "FetchAndUnzipProcessTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private FetchAndUnzipProcess instance;", "modifier": "private", "type": "FetchAndUnzipProcess", "declarator": "instance", "var_name": "instance"}, {"original_string": "private static final String TEST_TOKEN = \"ASDFQWER\";", "modifier": "private static final", "type": "String", "declarator": "TEST_TOKEN = \"ASDFQWER\"", "var_name": "TEST_TOKEN"}, {"original_string": "private Path tempDir;", "modifier": "private", "type": "Path", "declarator": "tempDir", "var_name": "tempDir"}], "file": "coastal-hazards-wps/src/test/java/gov/usgs/cida/coastalhazards/wps/FetchAndUnzipProcessTest.java"}, "test_case": {"identifier": "testMakeSafeFileName", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMakeSafeFileName(){\n            /*\n             * UUIDs have some structure, but according to the RFC (Sec 4.4 \n             * https://www.ietf.org/rfc/rfc4122.txt), and this empirical test \n             * (https://repl.it/EeqN/6), the first hex digit is randomly generated.\n             * \n             * Since the first digit is randomly generated, we can focus only on\n             * the first digit and determine how many iterations are acceptable \n             * using the classic probability problem of colored marble drawing \n             * with replacement. Slide one of this presentation has an example:\n             * http://homepages.math.uic.edu/~bpower6/stat101/probability%20examples.pdf\n             * In our case, our jar has 10 blue marbles (digits '0' through '9') and \n             * 6 red marbles (digits 'a' through 'f'). The probability of generating\n             * 'N' UUIDs without a single one beginning with a digit 'a' through\n             * 'f' is the same as the probability of drawing 'N' marbles from \n             * our jar without selecting a single red marble. For a single event,\n             * P(not red) = 10/16. For 'N' events, \n             * P(not red 'N' times) = P(not red)^N = (10/16)^N\n             * \n             * Accordingly, P(not red 1000 times) = (10/16)^1000 = 7.586E-205\n             * \n             * This is an acceptably small probability.\n             */\n        for(int i = 0; i < 1000; i++){\n                String fileName = instance.makeSafeFileName();\n                assertTrue(\"'\" + fileName +\"' is not a valid XML elment name\", isValidXmlElementName(fileName));\n        }\n    }", "signature": "void testMakeSafeFileName()", "full_signature": "@Test public void testMakeSafeFileName()", "class_method_signature": "FetchAndUnzipProcessTest.testMakeSafeFileName()", "testcase": true, "constructor": false, "invocations": ["makeSafeFileName", "assertTrue", "isValidXmlElementName"]}, "focal_class": {"identifier": "FetchAndUnzipProcess", "superclass": "", "interfaces": "implements GeoServerProcess", "fields": [{"original_string": "static final Logger LOGGER = Logging.getLogger(FetchAndUnzipProcess.class);", "modifier": "static final", "type": "Logger", "declarator": "LOGGER = Logging.getLogger(FetchAndUnzipProcess.class)", "var_name": "LOGGER"}, {"original_string": "static final String TOKEN_PROPERTY_NAME = \"gov.usgs.cida.coastalhazards.wps.fetch.and.unzip.process.token\";", "modifier": "static final", "type": "String", "declarator": "TOKEN_PROPERTY_NAME = \"gov.usgs.cida.coastalhazards.wps.fetch.and.unzip.process.token\"", "var_name": "TOKEN_PROPERTY_NAME"}, {"original_string": "static final String UNZIP_BASE_PROPERTY_NAME = \"gov.usgs.cida.coastalhazards.wps.fetch.and.unzip.process.unzip.base\";", "modifier": "static final", "type": "String", "declarator": "UNZIP_BASE_PROPERTY_NAME = \"gov.usgs.cida.coastalhazards.wps.fetch.and.unzip.process.unzip.base\"", "var_name": "UNZIP_BASE_PROPERTY_NAME"}, {"original_string": "private DynamicReadOnlyProperties properties;", "modifier": "private", "type": "DynamicReadOnlyProperties", "declarator": "properties", "var_name": "properties"}, {"original_string": "private HttpClient httpClient;", "modifier": "private", "type": "HttpClient", "declarator": "httpClient", "var_name": "httpClient"}, {"original_string": "public static final String FILE_NAME_PREFIX = \"_\";", "modifier": "public static final", "type": "String", "declarator": "FILE_NAME_PREFIX = \"_\"", "var_name": "FILE_NAME_PREFIX"}], "methods": [{"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"zipUrl\", min = 1, max = 1, description = \"URL to the zipped file to retrieve\") String zipUrl,\n            @DescribeParameter(name = \"token\", min = 1, max = 1, description = \"Token for authorizing the upload\") String token\n            )", "modifiers": "@DescribeResult(name = \"filePath\", description = \"path to the unzipped file\") public", "return": "String", "signature": "String execute(\n            @DescribeParameter(name = \"zipUrl\", min = 1, max = 1, description = \"URL to the zipped file to retrieve\") String zipUrl,\n            @DescribeParameter(name = \"token\", min = 1, max = 1, description = \"Token for authorizing the upload\") String token\n            )", "full_signature": "@DescribeResult(name = \"filePath\", description = \"path to the unzipped file\") public String execute(\n            @DescribeParameter(name = \"zipUrl\", min = 1, max = 1, description = \"URL to the zipped file to retrieve\") String zipUrl,\n            @DescribeParameter(name = \"token\", min = 1, max = 1, description = \"Token for authorizing the upload\") String token\n            )", "class_method_signature": "FetchAndUnzipProcess.execute(\n            @DescribeParameter(name = \"zipUrl\", min = 1, max = 1, description = \"URL to the zipped file to retrieve\") String zipUrl,\n            @DescribeParameter(name = \"token\", min = 1, max = 1, description = \"Token for authorizing the upload\") String token\n            )", "testcase": false, "constructor": false}, {"identifier": "isAuthorized", "parameters": "(String token)", "modifiers": "", "return": "boolean", "signature": "boolean isAuthorized(String token)", "full_signature": " boolean isAuthorized(String token)", "class_method_signature": "FetchAndUnzipProcess.isAuthorized(String token)", "testcase": false, "constructor": false}, {"identifier": "getNewZipDestination", "parameters": "()", "modifiers": "", "return": "File", "signature": "File getNewZipDestination()", "full_signature": " File getNewZipDestination()", "class_method_signature": "FetchAndUnzipProcess.getNewZipDestination()", "testcase": false, "constructor": false}, {"identifier": "getNewZipDestination", "parameters": "(String unzipBase)", "modifiers": "", "return": "File", "signature": "File getNewZipDestination(String unzipBase)", "full_signature": " File getNewZipDestination(String unzipBase)", "class_method_signature": "FetchAndUnzipProcess.getNewZipDestination(String unzipBase)", "testcase": false, "constructor": false}, {"identifier": "getZipFromUrl", "parameters": "(String zipUrl, HttpClient client)", "modifiers": "", "return": "ZipInputStream", "signature": "ZipInputStream getZipFromUrl(String zipUrl, HttpClient client)", "full_signature": " ZipInputStream getZipFromUrl(String zipUrl, HttpClient client)", "class_method_signature": "FetchAndUnzipProcess.getZipFromUrl(String zipUrl, HttpClient client)", "testcase": false, "constructor": false}, {"identifier": "makeSafeFileName", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String makeSafeFileName()", "full_signature": "public String makeSafeFileName()", "class_method_signature": "FetchAndUnzipProcess.makeSafeFileName()", "testcase": false, "constructor": false}, {"identifier": "unzipToDir", "parameters": "(ZipInputStream zipStream, File zipDir)", "modifiers": "", "return": "File", "signature": "File unzipToDir(ZipInputStream zipStream, File zipDir)", "full_signature": " File unzipToDir(ZipInputStream zipStream, File zipDir)", "class_method_signature": "FetchAndUnzipProcess.unzipToDir(ZipInputStream zipStream, File zipDir)", "testcase": false, "constructor": false}, {"identifier": "getProperties", "parameters": "()", "modifiers": "", "return": "DynamicReadOnlyProperties", "signature": "DynamicReadOnlyProperties getProperties()", "full_signature": " DynamicReadOnlyProperties getProperties()", "class_method_signature": "FetchAndUnzipProcess.getProperties()", "testcase": false, "constructor": false}, {"identifier": "setProperties", "parameters": "(DynamicReadOnlyProperties properties)", "modifiers": "", "return": "void", "signature": "void setProperties(DynamicReadOnlyProperties properties)", "full_signature": " void setProperties(DynamicReadOnlyProperties properties)", "class_method_signature": "FetchAndUnzipProcess.setProperties(DynamicReadOnlyProperties properties)", "testcase": false, "constructor": false}, {"identifier": "getHttpClient", "parameters": "()", "modifiers": "", "return": "HttpClient", "signature": "HttpClient getHttpClient()", "full_signature": " HttpClient getHttpClient()", "class_method_signature": "FetchAndUnzipProcess.getHttpClient()", "testcase": false, "constructor": false}, {"identifier": "setHttpClient", "parameters": "(HttpClient httpClient)", "modifiers": "", "return": "void", "signature": "void setHttpClient(HttpClient httpClient)", "full_signature": " void setHttpClient(HttpClient httpClient)", "class_method_signature": "FetchAndUnzipProcess.setHttpClient(HttpClient httpClient)", "testcase": false, "constructor": false}], "file": "coastal-hazards-wps/src/main/java/gov/usgs/cida/coastalhazards/wps/FetchAndUnzipProcess.java"}, "focal_method": {"identifier": "makeSafeFileName", "parameters": "()", "modifiers": "public", "return": "String", "body": "public String makeSafeFileName(){\n                /*\n                 * Why prefix the file name?\n                 * UUIDs sometimes begin with numbers. Sometimes the file \n                 * names are used as XML element names. XML element names\n                 * cannot begin with numbers. To ensure that an unzipped\n                 * file name could be used as an XML elment name, prefix it\n                 * with a valid character for the start of an XML element name\n                 */\n            return FILE_NAME_PREFIX + UUID.randomUUID().toString();\n        }", "signature": "String makeSafeFileName()", "full_signature": "public String makeSafeFileName()", "class_method_signature": "FetchAndUnzipProcess.makeSafeFileName()", "testcase": false, "constructor": false, "invocations": ["toString", "randomUUID"]}, "repository": {"repo_id": 6888625, "url": "https://github.com/USGS-CIDA/coastal-hazards", "language": "Java", "is_fork": false, "fork_count": 28, "stargazer_count": 5, "size": 37212, "license": "licensed"}}