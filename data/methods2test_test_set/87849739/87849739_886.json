{"test_class": {"identifier": "ImmutableConnectionTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final ConnectionType TYPE = ConnectionType.AMQP_10;", "modifier": "private static final", "type": "ConnectionType", "declarator": "TYPE = ConnectionType.AMQP_10", "var_name": "TYPE"}, {"original_string": "private static final ConnectivityStatus STATUS = ConnectivityStatus.OPEN;", "modifier": "private static final", "type": "ConnectivityStatus", "declarator": "STATUS = ConnectivityStatus.OPEN", "var_name": "STATUS"}, {"original_string": "private static final ConnectionId ID = ConnectionId.of(\"myConnectionId\");", "modifier": "private static final", "type": "ConnectionId", "declarator": "ID = ConnectionId.of(\"myConnectionId\")", "var_name": "ID"}, {"original_string": "private static final String NAME = \"myConnection\";", "modifier": "private static final", "type": "String", "declarator": "NAME = \"myConnection\"", "var_name": "NAME"}, {"original_string": "private static final String URI = \"amqps://foo:bar@example.com:443\";", "modifier": "private static final", "type": "String", "declarator": "URI = \"amqps://foo:bar@example.com:443\"", "var_name": "URI"}, {"original_string": "private static final Credentials CREDENTIALS = ClientCertificateCredentials.newBuilder().build();", "modifier": "private static final", "type": "Credentials", "declarator": "CREDENTIALS = ClientCertificateCredentials.newBuilder().build()", "var_name": "CREDENTIALS"}, {"original_string": "private static final AuthorizationContext AUTHORIZATION_CONTEXT =\n            AuthorizationContext.newInstance(DittoAuthorizationContextType.PRE_AUTHENTICATED_CONNECTION,\n                    AuthorizationSubject.newInstance(\"myIssuer:mySubject\"));", "modifier": "private static final", "type": "AuthorizationContext", "declarator": "AUTHORIZATION_CONTEXT =\n            AuthorizationContext.newInstance(DittoAuthorizationContextType.PRE_AUTHENTICATED_CONNECTION,\n                    AuthorizationSubject.newInstance(\"myIssuer:mySubject\"))", "var_name": "AUTHORIZATION_CONTEXT"}, {"original_string": "private static final String STATUS_MAPPING = \"ConnectionStatus\";", "modifier": "private static final", "type": "String", "declarator": "STATUS_MAPPING = \"ConnectionStatus\"", "var_name": "STATUS_MAPPING"}, {"original_string": "private static final String JAVA_SCRIPT_MAPPING = \"JavaScript\";", "modifier": "private static final", "type": "String", "declarator": "JAVA_SCRIPT_MAPPING = \"JavaScript\"", "var_name": "JAVA_SCRIPT_MAPPING"}, {"original_string": "private static final String MIGRATED_MAPPER_ID = \"javascript\";", "modifier": "private static final", "type": "String", "declarator": "MIGRATED_MAPPER_ID = \"javascript\"", "var_name": "MIGRATED_MAPPER_ID"}, {"original_string": "private static final Source SOURCE1 = ConnectivityModelFactory.newSource(AUTHORIZATION_CONTEXT, \"amqp/source1\");", "modifier": "private static final", "type": "Source", "declarator": "SOURCE1 = ConnectivityModelFactory.newSource(AUTHORIZATION_CONTEXT, \"amqp/source1\")", "var_name": "SOURCE1"}, {"original_string": "private static final Source SOURCE2 = ConnectivityModelFactory.newSource(AUTHORIZATION_CONTEXT, \"amqp/source2\", 1);", "modifier": "private static final", "type": "Source", "declarator": "SOURCE2 = ConnectivityModelFactory.newSource(AUTHORIZATION_CONTEXT, \"amqp/source2\", 1)", "var_name": "SOURCE2"}, {"original_string": "private static final List<Source> SOURCES = Arrays.asList(SOURCE1, SOURCE2);", "modifier": "private static final", "type": "List<Source>", "declarator": "SOURCES = Arrays.asList(SOURCE1, SOURCE2)", "var_name": "SOURCES"}, {"original_string": "private static final List<Source> SOURCES_WITH_REPLY_TARGET_DISABLED = SOURCES.stream()\n            .map(s -> ConnectivityModelFactory.newSourceBuilder(s).replyTargetEnabled(false).build())\n            .collect(Collectors.toList());", "modifier": "private static final", "type": "List<Source>", "declarator": "SOURCES_WITH_REPLY_TARGET_DISABLED = SOURCES.stream()\n            .map(s -> ConnectivityModelFactory.newSourceBuilder(s).replyTargetEnabled(false).build())\n            .collect(Collectors.toList())", "var_name": "SOURCES_WITH_REPLY_TARGET_DISABLED"}, {"original_string": "private static final HeaderMapping HEADER_MAPPING = null;", "modifier": "private static final", "type": "HeaderMapping", "declarator": "HEADER_MAPPING = null", "var_name": "HEADER_MAPPING"}, {"original_string": "private static final Target TARGET1 = ConnectivityModelFactory.newTargetBuilder()\n            .address(\"amqp/target1\")\n            .authorizationContext(AUTHORIZATION_CONTEXT)\n            .headerMapping(HEADER_MAPPING)\n            .topics(Topic.TWIN_EVENTS, Topic.LIVE_EVENTS)\n            .build();", "modifier": "private static final", "type": "Target", "declarator": "TARGET1 = ConnectivityModelFactory.newTargetBuilder()\n            .address(\"amqp/target1\")\n            .authorizationContext(AUTHORIZATION_CONTEXT)\n            .headerMapping(HEADER_MAPPING)\n            .topics(Topic.TWIN_EVENTS, Topic.LIVE_EVENTS)\n            .build()", "var_name": "TARGET1"}, {"original_string": "private static final Target TARGET2 = ConnectivityModelFactory.newTargetBuilder()\n            .address(\"amqp/target2\")\n            .authorizationContext(AUTHORIZATION_CONTEXT)\n            .headerMapping(HEADER_MAPPING)\n            .topics(Topic.LIVE_MESSAGES, Topic.LIVE_MESSAGES, Topic.LIVE_EVENTS)\n            .build();", "modifier": "private static final", "type": "Target", "declarator": "TARGET2 = ConnectivityModelFactory.newTargetBuilder()\n            .address(\"amqp/target2\")\n            .authorizationContext(AUTHORIZATION_CONTEXT)\n            .headerMapping(HEADER_MAPPING)\n            .topics(Topic.LIVE_MESSAGES, Topic.LIVE_MESSAGES, Topic.LIVE_EVENTS)\n            .build()", "var_name": "TARGET2"}, {"original_string": "private static final Target TARGET3 = ConnectivityModelFactory.newTargetBuilder()\n            .address(\"amqp/target3\")\n            .authorizationContext(AUTHORIZATION_CONTEXT)\n            .headerMapping(HEADER_MAPPING)\n            .topics(Topic.LIVE_MESSAGES, Topic.LIVE_MESSAGES, Topic.LIVE_COMMANDS)\n            .build();", "modifier": "private static final", "type": "Target", "declarator": "TARGET3 = ConnectivityModelFactory.newTargetBuilder()\n            .address(\"amqp/target3\")\n            .authorizationContext(AUTHORIZATION_CONTEXT)\n            .headerMapping(HEADER_MAPPING)\n            .topics(Topic.LIVE_MESSAGES, Topic.LIVE_MESSAGES, Topic.LIVE_COMMANDS)\n            .build()", "var_name": "TARGET3"}, {"original_string": "private static final List<Target> TARGETS = Arrays.asList(TARGET1, TARGET2, TARGET3);", "modifier": "private static final", "type": "List<Target>", "declarator": "TARGETS = Arrays.asList(TARGET1, TARGET2, TARGET3)", "var_name": "TARGETS"}, {"original_string": "private static final JsonArray KNOWN_SOURCES_JSON =\n            SOURCES.stream().map(Source::toJson).collect(JsonCollectors.valuesToArray());", "modifier": "private static final", "type": "JsonArray", "declarator": "KNOWN_SOURCES_JSON =\n            SOURCES.stream().map(Source::toJson).collect(JsonCollectors.valuesToArray())", "var_name": "KNOWN_SOURCES_JSON"}, {"original_string": "private static final JsonArray KNOWN_TARGETS_JSON =\n            TARGETS.stream().map(Target::toJson).collect(JsonCollectors.valuesToArray());", "modifier": "private static final", "type": "JsonArray", "declarator": "KNOWN_TARGETS_JSON =\n            TARGETS.stream().map(Target::toJson).collect(JsonCollectors.valuesToArray())", "var_name": "KNOWN_TARGETS_JSON"}, {"original_string": "private static final JsonArray KNOWN_SOURCES_WITH_MAPPING_JSON =\n            KNOWN_SOURCES_JSON.stream()\n                    .map(JsonValue::asObject)\n                    .map(o -> o.set(Source.JsonFields.PAYLOAD_MAPPING, JsonArray.of(JsonValue.of(JAVA_SCRIPT_MAPPING))))\n                    .collect(JsonCollectors.valuesToArray());", "modifier": "private static final", "type": "JsonArray", "declarator": "KNOWN_SOURCES_WITH_MAPPING_JSON =\n            KNOWN_SOURCES_JSON.stream()\n                    .map(JsonValue::asObject)\n                    .map(o -> o.set(Source.JsonFields.PAYLOAD_MAPPING, JsonArray.of(JsonValue.of(JAVA_SCRIPT_MAPPING))))\n                    .collect(JsonCollectors.valuesToArray())", "var_name": "KNOWN_SOURCES_WITH_MAPPING_JSON"}, {"original_string": "private static final JsonArray KNOWN_TARGETS_WITH_MAPPING_JSON =\n            KNOWN_TARGETS_JSON.stream()\n                    .map(JsonValue::asObject)\n                    .map(o -> o.set(Source.JsonFields.PAYLOAD_MAPPING, JsonArray.of(JsonValue.of(STATUS_MAPPING))))\n                    .collect(JsonCollectors.valuesToArray());", "modifier": "private static final", "type": "JsonArray", "declarator": "KNOWN_TARGETS_WITH_MAPPING_JSON =\n            KNOWN_TARGETS_JSON.stream()\n                    .map(JsonValue::asObject)\n                    .map(o -> o.set(Source.JsonFields.PAYLOAD_MAPPING, JsonArray.of(JsonValue.of(STATUS_MAPPING))))\n                    .collect(JsonCollectors.valuesToArray())", "var_name": "KNOWN_TARGETS_WITH_MAPPING_JSON"}, {"original_string": "private static final JsonArray KNOWN_SOURCES_WITH_REPLY_TARGET =\n            KNOWN_SOURCES_WITH_MAPPING_JSON.stream()\n                    .map(o -> o.asObject().toBuilder()\n                            .set(Source.JsonFields.HEADER_MAPPING.getPointer(),\n                                    ImmutableSource.DEFAULT_SOURCE_HEADER_MAPPING.toJson())\n                            .set(Source.JsonFields.REPLY_TARGET.getPointer(),\n                                    ReplyTarget.newBuilder().address(ImmutableSource.DEFAULT_REPLY_TARGET_ADDRESS)\n                                            .headerMapping(ImmutableSource.DEFAULT_REPLY_TARGET_HEADER_MAPPING)\n                                            .build()\n                                            .toJson())\n                            .set(Source.JsonFields.REPLY_TARGET_ENABLED, true)\n                            .build())\n                    .collect(JsonCollectors.valuesToArray());", "modifier": "private static final", "type": "JsonArray", "declarator": "KNOWN_SOURCES_WITH_REPLY_TARGET =\n            KNOWN_SOURCES_WITH_MAPPING_JSON.stream()\n                    .map(o -> o.asObject().toBuilder()\n                            .set(Source.JsonFields.HEADER_MAPPING.getPointer(),\n                                    ImmutableSource.DEFAULT_SOURCE_HEADER_MAPPING.toJson())\n                            .set(Source.JsonFields.REPLY_TARGET.getPointer(),\n                                    ReplyTarget.newBuilder().address(ImmutableSource.DEFAULT_REPLY_TARGET_ADDRESS)\n                                            .headerMapping(ImmutableSource.DEFAULT_REPLY_TARGET_HEADER_MAPPING)\n                                            .build()\n                                            .toJson())\n                            .set(Source.JsonFields.REPLY_TARGET_ENABLED, true)\n                            .build())\n                    .collect(JsonCollectors.valuesToArray())", "var_name": "KNOWN_SOURCES_WITH_REPLY_TARGET"}, {"original_string": "private static final JsonArray KNOWN_TARGETS_WITH_HEADER_MAPPING =\n            KNOWN_TARGETS_WITH_MAPPING_JSON.stream()\n                    .map(o -> o.asObject().toBuilder()\n                            .set(Target.JsonFields.HEADER_MAPPING, o.asObject()\n                                    .getValue(Target.JsonFields.HEADER_MAPPING)\n                                    .orElseGet(ImmutableTarget.DEFAULT_HEADER_MAPPING::toJson))\n                            .build())\n                    .collect(JsonCollectors.valuesToArray());", "modifier": "private static final", "type": "JsonArray", "declarator": "KNOWN_TARGETS_WITH_HEADER_MAPPING =\n            KNOWN_TARGETS_WITH_MAPPING_JSON.stream()\n                    .map(o -> o.asObject().toBuilder()\n                            .set(Target.JsonFields.HEADER_MAPPING, o.asObject()\n                                    .getValue(Target.JsonFields.HEADER_MAPPING)\n                                    .orElseGet(ImmutableTarget.DEFAULT_HEADER_MAPPING::toJson))\n                            .build())\n                    .collect(JsonCollectors.valuesToArray())", "var_name": "KNOWN_TARGETS_WITH_HEADER_MAPPING"}, {"original_string": "private static final MappingContext KNOWN_MAPPING_CONTEXT = ConnectivityModelFactory.newMappingContext(\n            JAVA_SCRIPT_MAPPING,\n            Collections.singletonMap(\"incomingScript\",\n                    \"function mapToDittoProtocolMsg(\\n\" +\n                            \"    headers,\\n\" +\n                            \"    textPayload,\\n\" +\n                            \"    bytePayload,\\n\" +\n                            \"    contentType\\n\" +\n                            \") {\\n\" +\n                            \"\\n\" +\n                            \"    // ###\\n\" +\n                            \"    // Insert your mapping logic here\\n\" +\n                            \"    let namespace = \\\"org.eclipse.ditto\\\";\\n\" +\n                            \"    let id = \\\"foo-bar\\\";\\n\" +\n                            \"    let group = \\\"things\\\";\\n\" +\n                            \"    let channel = \\\"twin\\\";\\n\" +\n                            \"    let criterion = \\\"commands\\\";\\n\" +\n                            \"    let action = \\\"modify\\\";\\n\" +\n                            \"    let path = \\\"/attributes/foo\\\";\\n\" +\n                            \"    let dittoHeaders = headers;\\n\" +\n                            \"    let value = textPayload;\\n\" +\n                            \"    // ###\\n\" +\n                            \"\\n\" +\n                            \"    return Ditto.buildDittoProtocolMsg(\\n\" +\n                            \"        namespace,\\n\" +\n                            \"        id,\\n\" +\n                            \"        group,\\n\" +\n                            \"        channel,\\n\" +\n                            \"        criterion,\\n\" +\n                            \"        action,\\n\" +\n                            \"        path,\\n\" +\n                            \"        dittoHeaders,\\n\" +\n                            \"        value\\n\" +\n                            \"    );\\n\" +\n                            \"}\"));", "modifier": "private static final", "type": "MappingContext", "declarator": "KNOWN_MAPPING_CONTEXT = ConnectivityModelFactory.newMappingContext(\n            JAVA_SCRIPT_MAPPING,\n            Collections.singletonMap(\"incomingScript\",\n                    \"function mapToDittoProtocolMsg(\\n\" +\n                            \"    headers,\\n\" +\n                            \"    textPayload,\\n\" +\n                            \"    bytePayload,\\n\" +\n                            \"    contentType\\n\" +\n                            \") {\\n\" +\n                            \"\\n\" +\n                            \"    // ###\\n\" +\n                            \"    // Insert your mapping logic here\\n\" +\n                            \"    let namespace = \\\"org.eclipse.ditto\\\";\\n\" +\n                            \"    let id = \\\"foo-bar\\\";\\n\" +\n                            \"    let group = \\\"things\\\";\\n\" +\n                            \"    let channel = \\\"twin\\\";\\n\" +\n                            \"    let criterion = \\\"commands\\\";\\n\" +\n                            \"    let action = \\\"modify\\\";\\n\" +\n                            \"    let path = \\\"/attributes/foo\\\";\\n\" +\n                            \"    let dittoHeaders = headers;\\n\" +\n                            \"    let value = textPayload;\\n\" +\n                            \"    // ###\\n\" +\n                            \"\\n\" +\n                            \"    return Ditto.buildDittoProtocolMsg(\\n\" +\n                            \"        namespace,\\n\" +\n                            \"        id,\\n\" +\n                            \"        group,\\n\" +\n                            \"        channel,\\n\" +\n                            \"        criterion,\\n\" +\n                            \"        action,\\n\" +\n                            \"        path,\\n\" +\n                            \"        dittoHeaders,\\n\" +\n                            \"        value\\n\" +\n                            \"    );\\n\" +\n                            \"}\"))", "var_name": "KNOWN_MAPPING_CONTEXT"}, {"original_string": "private static final MappingContext KNOWN_JAVA_MAPPING_CONTEXT = ConnectivityModelFactory.newMappingContext(\n            STATUS_MAPPING, new HashMap<>());", "modifier": "private static final", "type": "MappingContext", "declarator": "KNOWN_JAVA_MAPPING_CONTEXT = ConnectivityModelFactory.newMappingContext(\n            STATUS_MAPPING, new HashMap<>())", "var_name": "KNOWN_JAVA_MAPPING_CONTEXT"}, {"original_string": "private static final PayloadMappingDefinition KNOWN_MAPPING_DEFINITIONS =\n            ConnectivityModelFactory.newPayloadMappingDefinition(\n                    Stream.of(KNOWN_MAPPING_CONTEXT, KNOWN_JAVA_MAPPING_CONTEXT)\n                            .collect(Collectors.toMap(MappingContext::getMappingEngine, ctx -> ctx)));", "modifier": "private static final", "type": "PayloadMappingDefinition", "declarator": "KNOWN_MAPPING_DEFINITIONS =\n            ConnectivityModelFactory.newPayloadMappingDefinition(\n                    Stream.of(KNOWN_MAPPING_CONTEXT, KNOWN_JAVA_MAPPING_CONTEXT)\n                            .collect(Collectors.toMap(MappingContext::getMappingEngine, ctx -> ctx)))", "var_name": "KNOWN_MAPPING_DEFINITIONS"}, {"original_string": "private static final PayloadMappingDefinition LEGACY_MAPPINGS =\n            ConnectivityModelFactory.newPayloadMappingDefinition(\n                    Stream.of(KNOWN_MAPPING_CONTEXT).collect(Collectors.toMap(ctx -> MIGRATED_MAPPER_ID, ctx -> ctx)));", "modifier": "private static final", "type": "PayloadMappingDefinition", "declarator": "LEGACY_MAPPINGS =\n            ConnectivityModelFactory.newPayloadMappingDefinition(\n                    Stream.of(KNOWN_MAPPING_CONTEXT).collect(Collectors.toMap(ctx -> MIGRATED_MAPPER_ID, ctx -> ctx)))", "var_name": "LEGACY_MAPPINGS"}, {"original_string": "private static final Set<String> KNOWN_TAGS = Collections.singleton(\"HONO\");", "modifier": "private static final", "type": "Set<String>", "declarator": "KNOWN_TAGS = Collections.singleton(\"HONO\")", "var_name": "KNOWN_TAGS"}, {"original_string": "private static final JsonObject KNOWN_JSON = JsonObject.newBuilder()\n            .set(Connection.JsonFields.ID, ID.toString())\n            .set(Connection.JsonFields.NAME, NAME)\n            .set(Connection.JsonFields.CONNECTION_TYPE, TYPE.getName())\n            .set(Connection.JsonFields.CONNECTION_STATUS, STATUS.getName())\n            .set(Connection.JsonFields.CREDENTIALS, CREDENTIALS.toJson())\n            .set(Connection.JsonFields.URI, URI)\n            .set(Connection.JsonFields.SOURCES, KNOWN_SOURCES_WITH_MAPPING_JSON)\n            .set(Connection.JsonFields.TARGETS, KNOWN_TARGETS_WITH_MAPPING_JSON)\n            .set(Connection.JsonFields.CLIENT_COUNT, 2)\n            .set(Connection.JsonFields.FAILOVER_ENABLED, true)\n            .set(Connection.JsonFields.VALIDATE_CERTIFICATES, true)\n            .set(Connection.JsonFields.PROCESSOR_POOL_SIZE, 5)\n            .set(Connection.JsonFields.MAPPING_DEFINITIONS,\n                    JsonObject.newBuilder()\n                            .set(JAVA_SCRIPT_MAPPING, KNOWN_MAPPING_CONTEXT.toJson())\n                            .set(STATUS_MAPPING, KNOWN_JAVA_MAPPING_CONTEXT.toJson())\n                            .build())\n            .set(Connection.JsonFields.TAGS, KNOWN_TAGS.stream()\n                    .map(JsonFactory::newValue)\n                    .collect(JsonCollectors.valuesToArray()))\n            .build();", "modifier": "private static final", "type": "JsonObject", "declarator": "KNOWN_JSON = JsonObject.newBuilder()\n            .set(Connection.JsonFields.ID, ID.toString())\n            .set(Connection.JsonFields.NAME, NAME)\n            .set(Connection.JsonFields.CONNECTION_TYPE, TYPE.getName())\n            .set(Connection.JsonFields.CONNECTION_STATUS, STATUS.getName())\n            .set(Connection.JsonFields.CREDENTIALS, CREDENTIALS.toJson())\n            .set(Connection.JsonFields.URI, URI)\n            .set(Connection.JsonFields.SOURCES, KNOWN_SOURCES_WITH_MAPPING_JSON)\n            .set(Connection.JsonFields.TARGETS, KNOWN_TARGETS_WITH_MAPPING_JSON)\n            .set(Connection.JsonFields.CLIENT_COUNT, 2)\n            .set(Connection.JsonFields.FAILOVER_ENABLED, true)\n            .set(Connection.JsonFields.VALIDATE_CERTIFICATES, true)\n            .set(Connection.JsonFields.PROCESSOR_POOL_SIZE, 5)\n            .set(Connection.JsonFields.MAPPING_DEFINITIONS,\n                    JsonObject.newBuilder()\n                            .set(JAVA_SCRIPT_MAPPING, KNOWN_MAPPING_CONTEXT.toJson())\n                            .set(STATUS_MAPPING, KNOWN_JAVA_MAPPING_CONTEXT.toJson())\n                            .build())\n            .set(Connection.JsonFields.TAGS, KNOWN_TAGS.stream()\n                    .map(JsonFactory::newValue)\n                    .collect(JsonCollectors.valuesToArray()))\n            .build()", "var_name": "KNOWN_JSON"}, {"original_string": "private static final JsonObject KNOWN_JSON_WITH_REPLY_TARGET = KNOWN_JSON\n            .set(Connection.JsonFields.SOURCES, KNOWN_SOURCES_WITH_REPLY_TARGET)\n            .set(Connection.JsonFields.TARGETS, KNOWN_TARGETS_WITH_HEADER_MAPPING);", "modifier": "private static final", "type": "JsonObject", "declarator": "KNOWN_JSON_WITH_REPLY_TARGET = KNOWN_JSON\n            .set(Connection.JsonFields.SOURCES, KNOWN_SOURCES_WITH_REPLY_TARGET)\n            .set(Connection.JsonFields.TARGETS, KNOWN_TARGETS_WITH_HEADER_MAPPING)", "var_name": "KNOWN_JSON_WITH_REPLY_TARGET"}, {"original_string": "private static final JsonObject KNOWN_LEGACY_JSON = KNOWN_JSON\n            .set(Connection.JsonFields.MAPPING_CONTEXT, KNOWN_MAPPING_CONTEXT.toJson());", "modifier": "private static final", "type": "JsonObject", "declarator": "KNOWN_LEGACY_JSON = KNOWN_JSON\n            .set(Connection.JsonFields.MAPPING_CONTEXT, KNOWN_MAPPING_CONTEXT.toJson())", "var_name": "KNOWN_LEGACY_JSON"}], "file": "model/connectivity/src/test/java/org/eclipse/ditto/model/connectivity/ImmutableConnectionTest.java"}, "test_case": {"identifier": "createInstanceWithNullEventTarget", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void createInstanceWithNullEventTarget() {\n        final ConnectionBuilder builder = ImmutableConnection.getBuilder(ID, TYPE, STATUS, URI);\n\n        assertThatExceptionOfType(NullPointerException.class)\n                .isThrownBy(() -> builder.targets(null))\n                .withMessage(\"The %s must not be null!\", \"targets\")\n                .withNoCause();\n    }", "signature": "void createInstanceWithNullEventTarget()", "full_signature": "@Test public void createInstanceWithNullEventTarget()", "class_method_signature": "ImmutableConnectionTest.createInstanceWithNullEventTarget()", "testcase": true, "constructor": false, "invocations": ["getBuilder", "withNoCause", "withMessage", "isThrownBy", "assertThatExceptionOfType", "targets"]}, "focal_class": {"identifier": "ImmutableConnection", "superclass": "", "interfaces": "implements Connection", "fields": [{"original_string": "private final ConnectionId id;", "modifier": "private final", "type": "ConnectionId", "declarator": "id", "var_name": "id"}, {"original_string": "@Nullable private final String name;", "modifier": "@Nullable private final", "type": "String", "declarator": "name", "var_name": "name"}, {"original_string": "private final ConnectionType connectionType;", "modifier": "private final", "type": "ConnectionType", "declarator": "connectionType", "var_name": "connectionType"}, {"original_string": "private final ConnectivityStatus connectionStatus;", "modifier": "private final", "type": "ConnectivityStatus", "declarator": "connectionStatus", "var_name": "connectionStatus"}, {"original_string": "private final ConnectionUri uri;", "modifier": "private final", "type": "ConnectionUri", "declarator": "uri", "var_name": "uri"}, {"original_string": "@Nullable private final Credentials credentials;", "modifier": "@Nullable private final", "type": "Credentials", "declarator": "credentials", "var_name": "credentials"}, {"original_string": "@Nullable private final String trustedCertificates;", "modifier": "@Nullable private final", "type": "String", "declarator": "trustedCertificates", "var_name": "trustedCertificates"}, {"original_string": "@Nullable private final ConnectionLifecycle lifecycle;", "modifier": "@Nullable private final", "type": "ConnectionLifecycle", "declarator": "lifecycle", "var_name": "lifecycle"}, {"original_string": "private final List<Source> sources;", "modifier": "private final", "type": "List<Source>", "declarator": "sources", "var_name": "sources"}, {"original_string": "private final List<Target> targets;", "modifier": "private final", "type": "List<Target>", "declarator": "targets", "var_name": "targets"}, {"original_string": "private final int clientCount;", "modifier": "private final", "type": "int", "declarator": "clientCount", "var_name": "clientCount"}, {"original_string": "private final boolean failOverEnabled;", "modifier": "private final", "type": "boolean", "declarator": "failOverEnabled", "var_name": "failOverEnabled"}, {"original_string": "private final boolean validateCertificate;", "modifier": "private final", "type": "boolean", "declarator": "validateCertificate", "var_name": "validateCertificate"}, {"original_string": "private final int processorPoolSize;", "modifier": "private final", "type": "int", "declarator": "processorPoolSize", "var_name": "processorPoolSize"}, {"original_string": "private final Map<String, String> specificConfig;", "modifier": "private final", "type": "Map<String, String>", "declarator": "specificConfig", "var_name": "specificConfig"}, {"original_string": "private final PayloadMappingDefinition payloadMappingDefinition;", "modifier": "private final", "type": "PayloadMappingDefinition", "declarator": "payloadMappingDefinition", "var_name": "payloadMappingDefinition"}, {"original_string": "private final Set<String> tags;", "modifier": "private final", "type": "Set<String>", "declarator": "tags", "var_name": "tags"}], "methods": [{"identifier": "ImmutableConnection", "parameters": "(final Builder builder)", "modifiers": "private", "return": "", "signature": " ImmutableConnection(final Builder builder)", "full_signature": "private  ImmutableConnection(final Builder builder)", "class_method_signature": "ImmutableConnection.ImmutableConnection(final Builder builder)", "testcase": false, "constructor": true}, {"identifier": "getBuilder", "parameters": "(final ConnectionId id,\n            final ConnectionType connectionType,\n            final ConnectivityStatus connectionStatus,\n            final String uri)", "modifiers": "public static", "return": "ConnectionBuilder", "signature": "ConnectionBuilder getBuilder(final ConnectionId id,\n            final ConnectionType connectionType,\n            final ConnectivityStatus connectionStatus,\n            final String uri)", "full_signature": "public static ConnectionBuilder getBuilder(final ConnectionId id,\n            final ConnectionType connectionType,\n            final ConnectivityStatus connectionStatus,\n            final String uri)", "class_method_signature": "ImmutableConnection.getBuilder(final ConnectionId id,\n            final ConnectionType connectionType,\n            final ConnectivityStatus connectionStatus,\n            final String uri)", "testcase": false, "constructor": false}, {"identifier": "getBuilder", "parameters": "(final Connection connection)", "modifiers": "public static", "return": "ConnectionBuilder", "signature": "ConnectionBuilder getBuilder(final Connection connection)", "full_signature": "public static ConnectionBuilder getBuilder(final Connection connection)", "class_method_signature": "ImmutableConnection.getBuilder(final Connection connection)", "testcase": false, "constructor": false}, {"identifier": "fromJson", "parameters": "(final JsonObject jsonObject)", "modifiers": "public static", "return": "Connection", "signature": "Connection fromJson(final JsonObject jsonObject)", "full_signature": "public static Connection fromJson(final JsonObject jsonObject)", "class_method_signature": "ImmutableConnection.fromJson(final JsonObject jsonObject)", "testcase": false, "constructor": false}, {"identifier": "getConnectionTypeOrThrow", "parameters": "(final JsonObject jsonObject)", "modifiers": "private static", "return": "ConnectionType", "signature": "ConnectionType getConnectionTypeOrThrow(final JsonObject jsonObject)", "full_signature": "private static ConnectionType getConnectionTypeOrThrow(final JsonObject jsonObject)", "class_method_signature": "ImmutableConnection.getConnectionTypeOrThrow(final JsonObject jsonObject)", "testcase": false, "constructor": false}, {"identifier": "getConnectionStatusOrThrow", "parameters": "(final JsonObject jsonObject)", "modifiers": "private static", "return": "ConnectivityStatus", "signature": "ConnectivityStatus getConnectionStatusOrThrow(final JsonObject jsonObject)", "full_signature": "private static ConnectivityStatus getConnectionStatusOrThrow(final JsonObject jsonObject)", "class_method_signature": "ImmutableConnection.getConnectionStatusOrThrow(final JsonObject jsonObject)", "testcase": false, "constructor": false}, {"identifier": "getSources", "parameters": "(final JsonObject jsonObject)", "modifiers": "private static", "return": "List<Source>", "signature": "List<Source> getSources(final JsonObject jsonObject)", "full_signature": "private static List<Source> getSources(final JsonObject jsonObject)", "class_method_signature": "ImmutableConnection.getSources(final JsonObject jsonObject)", "testcase": false, "constructor": false}, {"identifier": "getTargets", "parameters": "(final JsonObject jsonObject)", "modifiers": "private static", "return": "List<Target>", "signature": "List<Target> getTargets(final JsonObject jsonObject)", "full_signature": "private static List<Target> getTargets(final JsonObject jsonObject)", "class_method_signature": "ImmutableConnection.getTargets(final JsonObject jsonObject)", "testcase": false, "constructor": false}, {"identifier": "getSpecificConfiguration", "parameters": "(final JsonObject jsonObject)", "modifiers": "private static", "return": "Map<String, String>", "signature": "Map<String, String> getSpecificConfiguration(final JsonObject jsonObject)", "full_signature": "private static Map<String, String> getSpecificConfiguration(final JsonObject jsonObject)", "class_method_signature": "ImmutableConnection.getSpecificConfiguration(final JsonObject jsonObject)", "testcase": false, "constructor": false}, {"identifier": "getTags", "parameters": "(final JsonObject jsonObject)", "modifiers": "private static", "return": "Set<String>", "signature": "Set<String> getTags(final JsonObject jsonObject)", "full_signature": "private static Set<String> getTags(final JsonObject jsonObject)", "class_method_signature": "ImmutableConnection.getTags(final JsonObject jsonObject)", "testcase": false, "constructor": false}, {"identifier": "getId", "parameters": "()", "modifiers": "@Override public", "return": "ConnectionId", "signature": "ConnectionId getId()", "full_signature": "@Override public ConnectionId getId()", "class_method_signature": "ImmutableConnection.getId()", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "Optional<String>", "signature": "Optional<String> getName()", "full_signature": "@Override public Optional<String> getName()", "class_method_signature": "ImmutableConnection.getName()", "testcase": false, "constructor": false}, {"identifier": "getConnectionType", "parameters": "()", "modifiers": "@Override public", "return": "ConnectionType", "signature": "ConnectionType getConnectionType()", "full_signature": "@Override public ConnectionType getConnectionType()", "class_method_signature": "ImmutableConnection.getConnectionType()", "testcase": false, "constructor": false}, {"identifier": "getConnectionStatus", "parameters": "()", "modifiers": "@Override public", "return": "ConnectivityStatus", "signature": "ConnectivityStatus getConnectionStatus()", "full_signature": "@Override public ConnectivityStatus getConnectionStatus()", "class_method_signature": "ImmutableConnection.getConnectionStatus()", "testcase": false, "constructor": false}, {"identifier": "getSources", "parameters": "()", "modifiers": "@Override public", "return": "List<Source>", "signature": "List<Source> getSources()", "full_signature": "@Override public List<Source> getSources()", "class_method_signature": "ImmutableConnection.getSources()", "testcase": false, "constructor": false}, {"identifier": "getTargets", "parameters": "()", "modifiers": "@Override public", "return": "List<Target>", "signature": "List<Target> getTargets()", "full_signature": "@Override public List<Target> getTargets()", "class_method_signature": "ImmutableConnection.getTargets()", "testcase": false, "constructor": false}, {"identifier": "getClientCount", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getClientCount()", "full_signature": "@Override public int getClientCount()", "class_method_signature": "ImmutableConnection.getClientCount()", "testcase": false, "constructor": false}, {"identifier": "isFailoverEnabled", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isFailoverEnabled()", "full_signature": "@Override public boolean isFailoverEnabled()", "class_method_signature": "ImmutableConnection.isFailoverEnabled()", "testcase": false, "constructor": false}, {"identifier": "getCredentials", "parameters": "()", "modifiers": "@Override public", "return": "Optional<Credentials>", "signature": "Optional<Credentials> getCredentials()", "full_signature": "@Override public Optional<Credentials> getCredentials()", "class_method_signature": "ImmutableConnection.getCredentials()", "testcase": false, "constructor": false}, {"identifier": "getTrustedCertificates", "parameters": "()", "modifiers": "@Override public", "return": "Optional<String>", "signature": "Optional<String> getTrustedCertificates()", "full_signature": "@Override public Optional<String> getTrustedCertificates()", "class_method_signature": "ImmutableConnection.getTrustedCertificates()", "testcase": false, "constructor": false}, {"identifier": "getUri", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getUri()", "full_signature": "@Override public String getUri()", "class_method_signature": "ImmutableConnection.getUri()", "testcase": false, "constructor": false}, {"identifier": "getProtocol", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getProtocol()", "full_signature": "@Override public String getProtocol()", "class_method_signature": "ImmutableConnection.getProtocol()", "testcase": false, "constructor": false}, {"identifier": "getUsername", "parameters": "()", "modifiers": "@Override public", "return": "Optional<String>", "signature": "Optional<String> getUsername()", "full_signature": "@Override public Optional<String> getUsername()", "class_method_signature": "ImmutableConnection.getUsername()", "testcase": false, "constructor": false}, {"identifier": "getPassword", "parameters": "()", "modifiers": "@Override public", "return": "Optional<String>", "signature": "Optional<String> getPassword()", "full_signature": "@Override public Optional<String> getPassword()", "class_method_signature": "ImmutableConnection.getPassword()", "testcase": false, "constructor": false}, {"identifier": "getHostname", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getHostname()", "full_signature": "@Override public String getHostname()", "class_method_signature": "ImmutableConnection.getHostname()", "testcase": false, "constructor": false}, {"identifier": "getPort", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getPort()", "full_signature": "@Override public int getPort()", "class_method_signature": "ImmutableConnection.getPort()", "testcase": false, "constructor": false}, {"identifier": "getPath", "parameters": "()", "modifiers": "@Override public", "return": "Optional<String>", "signature": "Optional<String> getPath()", "full_signature": "@Override public Optional<String> getPath()", "class_method_signature": "ImmutableConnection.getPath()", "testcase": false, "constructor": false}, {"identifier": "isValidateCertificates", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isValidateCertificates()", "full_signature": "@Override public boolean isValidateCertificates()", "class_method_signature": "ImmutableConnection.isValidateCertificates()", "testcase": false, "constructor": false}, {"identifier": "getProcessorPoolSize", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getProcessorPoolSize()", "full_signature": "@Override public int getProcessorPoolSize()", "class_method_signature": "ImmutableConnection.getProcessorPoolSize()", "testcase": false, "constructor": false}, {"identifier": "getSpecificConfig", "parameters": "()", "modifiers": "@Override public", "return": "Map<String, String>", "signature": "Map<String, String> getSpecificConfig()", "full_signature": "@Override public Map<String, String> getSpecificConfig()", "class_method_signature": "ImmutableConnection.getSpecificConfig()", "testcase": false, "constructor": false}, {"identifier": "getPayloadMappingDefinition", "parameters": "()", "modifiers": "@Override public", "return": "PayloadMappingDefinition", "signature": "PayloadMappingDefinition getPayloadMappingDefinition()", "full_signature": "@Override public PayloadMappingDefinition getPayloadMappingDefinition()", "class_method_signature": "ImmutableConnection.getPayloadMappingDefinition()", "testcase": false, "constructor": false}, {"identifier": "getTags", "parameters": "()", "modifiers": "@Override public", "return": "Set<String>", "signature": "Set<String> getTags()", "full_signature": "@Override public Set<String> getTags()", "class_method_signature": "ImmutableConnection.getTags()", "testcase": false, "constructor": false}, {"identifier": "getLifecycle", "parameters": "()", "modifiers": "@Override public", "return": "Optional<ConnectionLifecycle>", "signature": "Optional<ConnectionLifecycle> getLifecycle()", "full_signature": "@Override public Optional<ConnectionLifecycle> getLifecycle()", "class_method_signature": "ImmutableConnection.getLifecycle()", "testcase": false, "constructor": false}, {"identifier": "toJson", "parameters": "(final JsonSchemaVersion schemaVersion, final Predicate<JsonField> thePredicate)", "modifiers": "@Override public", "return": "JsonObject", "signature": "JsonObject toJson(final JsonSchemaVersion schemaVersion, final Predicate<JsonField> thePredicate)", "full_signature": "@Override public JsonObject toJson(final JsonSchemaVersion schemaVersion, final Predicate<JsonField> thePredicate)", "class_method_signature": "ImmutableConnection.toJson(final JsonSchemaVersion schemaVersion, final Predicate<JsonField> thePredicate)", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(@Nullable final Object o)", "modifiers": "@SuppressWarnings(\"OverlyComplexMethod\") @Override public", "return": "boolean", "signature": "boolean equals(@Nullable final Object o)", "full_signature": "@SuppressWarnings(\"OverlyComplexMethod\") @Override public boolean equals(@Nullable final Object o)", "class_method_signature": "ImmutableConnection.equals(@Nullable final Object o)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "ImmutableConnection.hashCode()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "ImmutableConnection.toString()", "testcase": false, "constructor": false}], "file": "model/connectivity/src/main/java/org/eclipse/ditto/model/connectivity/ImmutableConnection.java"}, "focal_method": {"identifier": "getBuilder", "parameters": "(final ConnectionId id,\n            final ConnectionType connectionType,\n            final ConnectivityStatus connectionStatus,\n            final String uri)", "modifiers": "public static", "return": "ConnectionBuilder", "body": "public static ConnectionBuilder getBuilder(final ConnectionId id,\n            final ConnectionType connectionType,\n            final ConnectivityStatus connectionStatus,\n            final String uri) {\n\n        return new Builder(connectionType)\n                .id(id)\n                .connectionStatus(connectionStatus)\n                .uri(uri);\n    }", "signature": "ConnectionBuilder getBuilder(final ConnectionId id,\n            final ConnectionType connectionType,\n            final ConnectivityStatus connectionStatus,\n            final String uri)", "full_signature": "public static ConnectionBuilder getBuilder(final ConnectionId id,\n            final ConnectionType connectionType,\n            final ConnectivityStatus connectionStatus,\n            final String uri)", "class_method_signature": "ImmutableConnection.getBuilder(final ConnectionId id,\n            final ConnectionType connectionType,\n            final ConnectivityStatus connectionStatus,\n            final String uri)", "testcase": false, "constructor": false, "invocations": ["uri", "connectionStatus", "id"]}, "repository": {"repo_id": 87849739, "url": "https://github.com/eclipse/ditto", "stars": 139, "created": "4/10/2017 7:29:57 PM +00:00", "updates": "2020-01-27T14:02:39+00:00", "fork": "False", "license": "licensed"}}