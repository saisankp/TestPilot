{"test_class": {"identifier": "StabilizationChargesTest", "superclass": "extends CDKTestCase", "interfaces": "", "fields": [{"original_string": "private IChemObjectBuilder      builder = SilentChemObjectBuilder.getInstance();", "modifier": "private", "type": "IChemObjectBuilder", "declarator": "builder = SilentChemObjectBuilder.getInstance()", "var_name": "builder"}, {"original_string": "private LonePairElectronChecker lpcheck = new LonePairElectronChecker();", "modifier": "private", "type": "LonePairElectronChecker", "declarator": "lpcheck = new LonePairElectronChecker()", "var_name": "lpcheck"}], "file": "tool/charges/src/test/java/org/openscience/cdk/charges/StabilizationChargesTest.java"}, "test_case": {"identifier": "testCalculatePositive_IAtomContainer_IAtom", "parameters": "()", "modifiers": "@Test @Category(SlowTest.class) public", "return": "void", "body": "@Test\n    @Category(SlowTest.class)\n    public void testCalculatePositive_IAtomContainer_IAtom() throws Exception {\n\n        StabilizationCharges sc = new StabilizationCharges();\n\n        IAtomContainer molecule = builder.newInstance(IAtomContainer.class);\n        molecule.addAtom(new Atom(\"C\"));\n        molecule.addAtom(new Atom(\"C\"));\n        molecule.addBond(0, 1, IBond.Order.SINGLE);\n        molecule.getAtom(1).setFormalCharge(+1);\n        molecule.addAtom(new Atom(\"C\"));\n        molecule.addBond(1, 2, IBond.Order.SINGLE);\n        molecule.addAtom(new Atom(\"C\"));\n        molecule.addBond(2, 3, IBond.Order.DOUBLE);\n\n        addExplicitHydrogens(molecule);\n        AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(molecule);\n        lpcheck.saturate(molecule);\n\n        for (int i = 0; i < molecule.getAtomCount(); i++) {\n            if (i == 1)\n                Assert.assertNotSame(0.0, sc.calculatePositive(molecule, molecule.getAtom(i)));\n            else\n                Assert.assertEquals(0.0, sc.calculatePositive(molecule, molecule.getAtom(i)), 0.001);\n\n        }\n    }", "signature": "void testCalculatePositive_IAtomContainer_IAtom()", "full_signature": "@Test @Category(SlowTest.class) public void testCalculatePositive_IAtomContainer_IAtom()", "class_method_signature": "StabilizationChargesTest.testCalculatePositive_IAtomContainer_IAtom()", "testcase": true, "constructor": false, "invocations": ["newInstance", "addAtom", "addAtom", "addBond", "setFormalCharge", "getAtom", "addAtom", "addBond", "addAtom", "addBond", "addExplicitHydrogens", "percieveAtomTypesAndConfigureAtoms", "saturate", "getAtomCount", "assertNotSame", "calculatePositive", "getAtom", "assertEquals", "calculatePositive", "getAtom"]}, "focal_class": {"identifier": "StabilizationCharges", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "StabilizationCharges", "parameters": "()", "modifiers": "public", "return": "", "signature": " StabilizationCharges()", "full_signature": "public  StabilizationCharges()", "class_method_signature": "StabilizationCharges.StabilizationCharges()", "testcase": false, "constructor": true}, {"identifier": "calculatePositive", "parameters": "(IAtomContainer atomContainer, IAtom atom)", "modifiers": "public", "return": "double", "signature": "double calculatePositive(IAtomContainer atomContainer, IAtom atom)", "full_signature": "public double calculatePositive(IAtomContainer atomContainer, IAtom atom)", "class_method_signature": "StabilizationCharges.calculatePositive(IAtomContainer atomContainer, IAtom atom)", "testcase": false, "constructor": false}], "file": "tool/charges/src/main/java/org/openscience/cdk/charges/StabilizationCharges.java"}, "focal_method": {"identifier": "calculatePositive", "parameters": "(IAtomContainer atomContainer, IAtom atom)", "modifiers": "public", "return": "double", "body": "public double calculatePositive(IAtomContainer atomContainer, IAtom atom) {\n        /* restrictions */\n        //    \tif(atomContainer.getConnectedSingleElectronsCount(atom) > 0 || atom.getFormalCharge() != 1){\n        if (atom.getFormalCharge() != 1) {\n            return 0.0;\n        }\n\n        // only must be generated all structures which stabilize the atom in question.\n        StructureResonanceGenerator gRI = new StructureResonanceGenerator();\n        List<IReactionProcess> reactionList = gRI.getReactions();\n        reactionList.add(new HyperconjugationReaction());\n        gRI.setReactions(reactionList);\n        IAtomContainerSet resonanceS = gRI.getStructures(atomContainer);\n        IAtomContainerSet containerS = gRI.getContainers(atomContainer);\n        if (resonanceS.getAtomContainerCount() < 2) // meaning it was not find any resonance structure\n            return 0.0;\n\n        final int positionStart = atomContainer.indexOf(atom);\n\n        List<Double> result1 = new ArrayList<Double>();\n        List<Integer> distance1 = new ArrayList<Integer>();\n\n        resonanceS.removeAtomContainer(0);// the first is the initial structure\n        for (Iterator<IAtomContainer> itA = resonanceS.atomContainers().iterator(); itA.hasNext();) {\n            final IAtomContainer resonance = itA.next();\n\n            if (resonance.getAtomCount() < 2) // resonance with only one atom donnot have resonance\n                continue;\n\n            final ShortestPaths shortestPaths = new ShortestPaths(resonance, resonance.getAtom(positionStart));\n\n            /* search positive charge */\n\n            PiElectronegativity electronegativity = new PiElectronegativity();\n\n            for (Iterator<IAtom> itAtoms = resonance.atoms().iterator(); itAtoms.hasNext();) {\n                IAtom atomP = itAtoms.next();\n                IAtom atomR = atomContainer.getAtom(resonance.indexOf(atomP));\n                if (containerS.getAtomContainer(0).contains(atomR)) {\n\n                    electronegativity.setMaxIterations(6);\n                    double result = electronegativity.calculatePiElectronegativity(resonance, atomP);\n                    result1.add(result);\n\n                    int dis = shortestPaths.distanceTo(atomP);\n                    distance1.add(dis);\n                }\n\n            }\n        }\n        /* logarithm */\n        double value = 0.0;\n        double sum = 0.0;\n        Iterator<Integer> itDist = distance1.iterator();\n        for (Iterator<Double> itElec = result1.iterator(); itElec.hasNext();) {\n            double suM = itElec.next();\n            if (suM < 0) suM = -1 * suM;\n            sum += suM * Math.pow(0.67, itDist.next().intValue());\n        }\n        value = sum;\n\n        return value;\n    }", "signature": "double calculatePositive(IAtomContainer atomContainer, IAtom atom)", "full_signature": "public double calculatePositive(IAtomContainer atomContainer, IAtom atom)", "class_method_signature": "StabilizationCharges.calculatePositive(IAtomContainer atomContainer, IAtom atom)", "testcase": false, "constructor": false, "invocations": ["getFormalCharge", "getReactions", "add", "setReactions", "getStructures", "getContainers", "getAtomContainerCount", "indexOf", "removeAtomContainer", "iterator", "atomContainers", "hasNext", "next", "getAtomCount", "getAtom", "iterator", "atoms", "hasNext", "next", "getAtom", "indexOf", "contains", "getAtomContainer", "setMaxIterations", "calculatePiElectronegativity", "add", "distanceTo", "add", "iterator", "iterator", "hasNext", "next", "pow", "intValue", "next"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}