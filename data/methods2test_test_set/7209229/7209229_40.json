{"test_class": {"identifier": "TestRateControl", "superclass": "", "interfaces": "", "fields": [], "file": "databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/util/TestRateControl.java"}, "test_case": {"identifier": "testIncrementEventCount", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testIncrementEventCount() throws Exception\n  {\n    RateControl rc = new RateControl(2,1);\n    MockRateMonitor mrm = new MockRateMonitor(\"mock\");\n    mrm.setNanoTime(0L);\n    mrm.start();\n\n    Field field = rc.getClass().getDeclaredField(\"_ra\");\n    field.setAccessible(true);\n    field.set(rc, mrm);\n\n    // #events=1, #time=2ns. Event accepted, rate exceeded\n    long expWakeupTime = DbusConstants.NUM_NSECS_IN_SEC /2;\n    long tc = rc.incrementEventCount();\n    Assert.assertEquals(tc, 1L);\n    Assert.assertEquals(rc.getNumSleeps(),1);\n    Assert.assertEquals(mrm.getNanoTime(),expWakeupTime);\n\n    // #events=1, #time=0.5s + 1. Event accepted, rate not exceeded\n    long curTime = expWakeupTime + 1;\n    mrm.setNanoTime(curTime);\n    tc = rc.incrementEventCount();\n    Assert.assertEquals(tc, 2L);\n    Assert.assertEquals(rc.getNumSleeps(),2);\n    \n    // it is DbusConstants.NUM_NSECS_IN_SEC+1, instead of DbusConstants.NUM_NSECS_IN_SEC because of approximating sleeps to a ms\n    Assert.assertEquals(DbusConstants.NUM_NSECS_IN_SEC+1, mrm.getNanoTime());\n  }", "signature": "void testIncrementEventCount()", "full_signature": "@Test public void testIncrementEventCount()", "class_method_signature": "TestRateControl.testIncrementEventCount()", "testcase": true, "constructor": false, "invocations": ["setNanoTime", "start", "getDeclaredField", "getClass", "setAccessible", "set", "incrementEventCount", "assertEquals", "assertEquals", "getNumSleeps", "assertEquals", "getNanoTime", "setNanoTime", "incrementEventCount", "assertEquals", "assertEquals", "getNumSleeps", "assertEquals", "getNanoTime"]}, "focal_class": {"identifier": "RateControl", "superclass": "", "interfaces": "", "fields": [{"original_string": "private RateMonitor _ra = null;", "modifier": "private", "type": "RateMonitor", "declarator": "_ra = null", "var_name": "_ra"}, {"original_string": "private long _maxEventsPerSec = Long.MIN_VALUE, _maxthrottleDurationInSecs = Long.MIN_VALUE;", "modifier": "private", "type": "long", "declarator": "_maxEventsPerSec = Long.MIN_VALUE", "var_name": "_maxEventsPerSec"}, {"original_string": "final private boolean _enabled;", "modifier": "final private", "type": "boolean", "declarator": "_enabled", "var_name": "_enabled"}, {"original_string": "private boolean _expired = false;", "modifier": "private", "type": "boolean", "declarator": "_expired = false", "var_name": "_expired"}, {"original_string": "private long _numSleeps = 0;", "modifier": "private", "type": "long", "declarator": "_numSleeps = 0", "var_name": "_numSleeps"}, {"original_string": "public static final String MODULE = RateControl.class.getName();", "modifier": "public static final", "type": "String", "declarator": "MODULE = RateControl.class.getName()", "var_name": "MODULE"}, {"original_string": "public static final Logger LOG = Logger.getLogger(MODULE);", "modifier": "public static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(MODULE)", "var_name": "LOG"}], "methods": [{"identifier": "RateControl", "parameters": "(long numEventsPerSec, long throttleDurationInSecs)", "modifiers": "public", "return": "", "signature": " RateControl(long numEventsPerSec, long throttleDurationInSecs)", "full_signature": "public  RateControl(long numEventsPerSec, long throttleDurationInSecs)", "class_method_signature": "RateControl.RateControl(long numEventsPerSec, long throttleDurationInSecs)", "testcase": false, "constructor": true}, {"identifier": "incrementEventCount", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long incrementEventCount()", "full_signature": "public long incrementEventCount()", "class_method_signature": "RateControl.incrementEventCount()", "testcase": false, "constructor": false}, {"identifier": "isEnabled", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isEnabled()", "full_signature": "public boolean isEnabled()", "class_method_signature": "RateControl.isEnabled()", "testcase": false, "constructor": false}, {"identifier": "sleepToMaintainRate", "parameters": "(long duration)", "modifiers": "protected", "return": "long", "signature": "long sleepToMaintainRate(long duration)", "full_signature": "protected long sleepToMaintainRate(long duration)", "class_method_signature": "RateControl.sleepToMaintainRate(long duration)", "testcase": false, "constructor": false}, {"identifier": "checkExpired", "parameters": "()", "modifiers": "protected", "return": "boolean", "signature": "boolean checkExpired()", "full_signature": "protected boolean checkExpired()", "class_method_signature": "RateControl.checkExpired()", "testcase": false, "constructor": false}, {"identifier": "checkRateExceeded", "parameters": "()", "modifiers": "protected", "return": "boolean", "signature": "boolean checkRateExceeded()", "full_signature": "protected boolean checkRateExceeded()", "class_method_signature": "RateControl.checkRateExceeded()", "testcase": false, "constructor": false}, {"identifier": "computeSleepDuration", "parameters": "()", "modifiers": "protected", "return": "long", "signature": "long computeSleepDuration()", "full_signature": "protected long computeSleepDuration()", "class_method_signature": "RateControl.computeSleepDuration()", "testcase": false, "constructor": false}, {"identifier": "getNumSleeps", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getNumSleeps()", "full_signature": "public long getNumSleeps()", "class_method_signature": "RateControl.getNumSleeps()", "testcase": false, "constructor": false}, {"identifier": "resetNumSleeps", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void resetNumSleeps()", "full_signature": "public void resetNumSleeps()", "class_method_signature": "RateControl.resetNumSleeps()", "testcase": false, "constructor": false}], "file": "databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/util/RateControl.java"}, "focal_method": {"identifier": "incrementEventCount", "parameters": "()", "modifiers": "public", "return": "long", "body": "public long incrementEventCount() throws DatabusException\n  {\n    // If throttle is not enabled, this is a no-op ( rate metrics need not be maintained )\n    if (! isEnabled())\n    {\n      return Long.MIN_VALUE;\n    }\n\n    // Enabled, but has expired, this is a no-op ( rate metrics need not be maintained )\n    if ( checkExpired())\n    {\n      if (LOG.isDebugEnabled())\n      {\n        LOG.debug(\"Throttle duration has expired. Accepting events without rate control\");\n      }\n\n      return Long.MIN_VALUE;\n    }\n\n    // Enabled, not expired; add the event and compute if we need to throttle\n    _ra.tick();\n    if (! checkRateExceeded())\n    {\n      // This event can be accepted without sleeping. Return number of events received so far\n      return _ra.getNumTicks();\n    }\n\n    try\n    {\n      // Compute how long we need to sleep\n      long duration = computeSleepDuration();\n      sleepToMaintainRate(duration);\n    }\n    catch (InterruptedException ie){}\n    return _ra.getNumTicks();\n  }", "signature": "long incrementEventCount()", "full_signature": "public long incrementEventCount()", "class_method_signature": "RateControl.incrementEventCount()", "testcase": false, "constructor": false, "invocations": ["isEnabled", "checkExpired", "isDebugEnabled", "debug", "tick", "checkRateExceeded", "getNumTicks", "computeSleepDuration", "sleepToMaintainRate", "getNumTicks"]}, "repository": {"repo_id": 7209229, "url": "https://github.com/linkedin/databus", "language": "Java", "is_fork": false, "fork_count": 653, "stargazer_count": 2899, "size": 51191, "license": "licensed"}}