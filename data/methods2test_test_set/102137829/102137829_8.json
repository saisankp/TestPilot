{"test_class": {"identifier": "AesTest", "superclass": "", "interfaces": "", "fields": [], "file": "src/de/slackspace/openkeepass/crypto/AesTest.java"}, "test_case": {"identifier": "shouldTransformKeyWith6000Rounds", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldTransformKeyWith6000Rounds() {\n        byte[] key = ByteUtils.hexStringToByteArray(\"3ecaacce890184af4fe7d6f6369dd14eb4a8a9641fefe346c9fbacb03c82a7c4\");\n        byte[] data = ByteUtils.hexStringToByteArray(\"2e99758548972a8e8822ad47fa1017ff72f06f3ff6a016851f45c398732bc50c\");\n\n        byte[] transformedKey = Aes.transformKey(key, data, 6000);\n\n        Assert.assertTrue(\"Hash must be 8ad8a3addb033449fbee13c3fbf1ad74b9760d6c21048f08027b2ddc8adef20a\",\n                Arrays.equals(ByteUtils.hexStringToByteArray(\"8ad8a3addb033449fbee13c3fbf1ad74b9760d6c21048f08027b2ddc8adef20a\"), transformedKey));\n    }", "signature": "void shouldTransformKeyWith6000Rounds()", "full_signature": "@Test public void shouldTransformKeyWith6000Rounds()", "class_method_signature": "AesTest.shouldTransformKeyWith6000Rounds()", "testcase": true, "constructor": false, "invocations": ["hexStringToByteArray", "hexStringToByteArray", "transformKey", "assertTrue", "equals", "hexStringToByteArray"]}, "focal_class": {"identifier": "Aes", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String MSG_KEY_MUST_NOT_BE_NULL = \"Key must not be null\";", "modifier": "private static final", "type": "String", "declarator": "MSG_KEY_MUST_NOT_BE_NULL = \"Key must not be null\"", "var_name": "MSG_KEY_MUST_NOT_BE_NULL"}, {"original_string": "private static final String MSG_IV_MUST_NOT_BE_NULL = \"IV must not be null\";", "modifier": "private static final", "type": "String", "declarator": "MSG_IV_MUST_NOT_BE_NULL = \"IV must not be null\"", "var_name": "MSG_IV_MUST_NOT_BE_NULL"}, {"original_string": "private static final String MSG_DATA_MUST_NOT_BE_NULL = \"Data must not be null\";", "modifier": "private static final", "type": "String", "declarator": "MSG_DATA_MUST_NOT_BE_NULL = \"Data must not be null\"", "var_name": "MSG_DATA_MUST_NOT_BE_NULL"}, {"original_string": "private static final String KEY_TRANSFORMATION = \"AES/ECB/NoPadding\";", "modifier": "private static final", "type": "String", "declarator": "KEY_TRANSFORMATION = \"AES/ECB/NoPadding\"", "var_name": "KEY_TRANSFORMATION"}, {"original_string": "private static final String DATA_TRANSFORMATION = \"AES/CBC/PKCS5Padding\";", "modifier": "private static final", "type": "String", "declarator": "DATA_TRANSFORMATION = \"AES/CBC/PKCS5Padding\"", "var_name": "DATA_TRANSFORMATION"}, {"original_string": "private static final String KEY_ALGORITHM = \"AES\";", "modifier": "private static final", "type": "String", "declarator": "KEY_ALGORITHM = \"AES\"", "var_name": "KEY_ALGORITHM"}], "methods": [{"identifier": "Aes", "parameters": "()", "modifiers": "private", "return": "", "signature": " Aes()", "full_signature": "private  Aes()", "class_method_signature": "Aes.Aes()", "testcase": false, "constructor": true}, {"identifier": "decrypt", "parameters": "(byte[] key, byte[] ivRaw, byte[] data)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] decrypt(byte[] key, byte[] ivRaw, byte[] data)", "full_signature": "public static byte[] decrypt(byte[] key, byte[] ivRaw, byte[] data)", "class_method_signature": "Aes.decrypt(byte[] key, byte[] ivRaw, byte[] data)", "testcase": false, "constructor": false}, {"identifier": "encrypt", "parameters": "(byte[] key, byte[] ivRaw, byte[] data)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encrypt(byte[] key, byte[] ivRaw, byte[] data)", "full_signature": "public static byte[] encrypt(byte[] key, byte[] ivRaw, byte[] data)", "class_method_signature": "Aes.encrypt(byte[] key, byte[] ivRaw, byte[] data)", "testcase": false, "constructor": false}, {"identifier": "transformData", "parameters": "(byte[] key, byte[] ivRaw, byte[] encryptedData, int operationMode)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] transformData(byte[] key, byte[] ivRaw, byte[] encryptedData, int operationMode)", "full_signature": "private static byte[] transformData(byte[] key, byte[] ivRaw, byte[] encryptedData, int operationMode)", "class_method_signature": "Aes.transformData(byte[] key, byte[] ivRaw, byte[] encryptedData, int operationMode)", "testcase": false, "constructor": false}, {"identifier": "transformKey", "parameters": "(byte[] key, byte[] data, long rounds)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] transformKey(byte[] key, byte[] data, long rounds)", "full_signature": "public static byte[] transformKey(byte[] key, byte[] data, long rounds)", "class_method_signature": "Aes.transformKey(byte[] key, byte[] data, long rounds)", "testcase": false, "constructor": false}, {"identifier": "createCryptoException", "parameters": "(Throwable e)", "modifiers": "private static", "return": "KeePassDatabaseUnreadableException", "signature": "KeePassDatabaseUnreadableException createCryptoException(Throwable e)", "full_signature": "private static KeePassDatabaseUnreadableException createCryptoException(Throwable e)", "class_method_signature": "Aes.createCryptoException(Throwable e)", "testcase": false, "constructor": false}], "file": "src/de/slackspace/openkeepass/crypto/Aes.java"}, "focal_method": {"identifier": "transformKey", "parameters": "(byte[] key, byte[] data, long rounds)", "modifiers": "public static", "return": "byte[]", "body": "public static byte[] transformKey(byte[] key, byte[] data, long rounds) {\n        if (key == null) {\n            throw new IllegalArgumentException(MSG_KEY_MUST_NOT_BE_NULL);\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(MSG_DATA_MUST_NOT_BE_NULL);\n        }\n        if (rounds < 1) {\n            throw new IllegalArgumentException(\"Rounds must be > 1\");\n        }\n\n        try {\n            Cipher c = Cipher.getInstance(KEY_TRANSFORMATION);\n            Key aesKey = new SecretKeySpec(key, KEY_ALGORITHM);\n            c.init(Cipher.ENCRYPT_MODE, aesKey);\n\n            for (long i = 0; i < rounds; ++i) {\n                c.update(data, 0, 16, data, 0);\n                c.update(data, 16, 16, data, 16);\n            }\n\n            return data;\n        } catch (NoSuchAlgorithmException e) {\n            throw new UnsupportedOperationException(\"The specified algorithm is unknown\", e);\n        } catch (NoSuchPaddingException e) {\n            throw new UnsupportedOperationException(\"The specified padding is unknown\", e);\n        } catch (InvalidKeyException e) {\n            throw new KeePassDatabaseUnreadableException(\n                    \"The key has the wrong size. Have you installed Java Cryptography Extension (JCE)? Is the master key correct?\", e);\n        } catch (ShortBufferException e) {\n            throw new AssertionError(e);\n        }\n    }", "signature": "byte[] transformKey(byte[] key, byte[] data, long rounds)", "full_signature": "public static byte[] transformKey(byte[] key, byte[] data, long rounds)", "class_method_signature": "Aes.transformKey(byte[] key, byte[] data, long rounds)", "testcase": false, "constructor": false, "invocations": ["getInstance", "init", "update", "update"]}, "repository": {"repo_id": 102137829, "url": "https://github.com/privacyint/ThornSec", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 10, "size": 20604, "license": "licensed"}}