{"test_class": {"identifier": "SymbolLookupTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n    public JenkinsRule rule = new JenkinsRule();", "modifier": "@Rule\n    public", "type": "JenkinsRule", "declarator": "rule = new JenkinsRule()", "var_name": "rule"}, {"original_string": "@Rule public ErrorCollector errors = new ErrorCollector();", "modifier": "@Rule public", "type": "ErrorCollector", "declarator": "errors = new ErrorCollector()", "var_name": "errors"}, {"original_string": "@Inject\n    SymbolLookup lookup;", "modifier": "@Inject", "type": "SymbolLookup", "declarator": "lookup", "var_name": "lookup"}, {"original_string": "@Inject\n    Foo foo;", "modifier": "@Inject", "type": "Foo", "declarator": "foo", "var_name": "foo"}, {"original_string": "@Inject\n    Bar bar;", "modifier": "@Inject", "type": "Bar", "declarator": "bar", "var_name": "bar"}, {"original_string": "@Inject\n    FishingNet.DescriptorImpl fishingNetDescriptor;", "modifier": "@Inject", "type": "FishingNet.DescriptorImpl", "declarator": "fishingNetDescriptor", "var_name": "fishingNetDescriptor"}, {"original_string": "@Inject\n    Internet.DescriptorImpl internetDescriptor;", "modifier": "@Inject", "type": "Internet.DescriptorImpl", "declarator": "internetDescriptor", "var_name": "internetDescriptor"}], "file": "plugin/src/test/java/org/jenkinsci/plugins/structs/SymbolLookupTest.java"}, "test_case": {"identifier": "descriptorLookup", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void descriptorLookup() {\n        assertThat(lookup.findDescriptor(Fishing.class, \"net\"), is(sameInstance((Descriptor)fishingNetDescriptor)));\n        assertThat(lookup.findDescriptor(Tech.class, \"net\"),    is(sameInstance((Descriptor)internetDescriptor)));\n    }", "signature": "void descriptorLookup()", "full_signature": "@Test public void descriptorLookup()", "class_method_signature": "SymbolLookupTest.descriptorLookup()", "testcase": true, "constructor": false, "invocations": ["assertThat", "findDescriptor", "is", "sameInstance", "assertThat", "findDescriptor", "is", "sameInstance"]}, "focal_class": {"identifier": "SymbolLookup", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final ConcurrentMap<Key,Object> cache = new ConcurrentHashMap<Key, Object>();", "modifier": "private final", "type": "ConcurrentMap<Key,Object>", "declarator": "cache = new ConcurrentHashMap<Key, Object>()", "var_name": "cache"}, {"original_string": "private final ConcurrentMap<Key,Object> noHitCache = new ConcurrentHashMap<Key, Object>();", "modifier": "private final", "type": "ConcurrentMap<Key,Object>", "declarator": "noHitCache = new ConcurrentHashMap<Key, Object>()", "var_name": "noHitCache"}, {"original_string": "static final Object NO_HIT = new Object();", "modifier": "static final", "type": "Object", "declarator": "NO_HIT = new Object()", "var_name": "NO_HIT"}, {"original_string": "@Inject\n    PluginManager pluginManager;", "modifier": "@Inject", "type": "PluginManager", "declarator": "pluginManager", "var_name": "pluginManager"}, {"original_string": "@Inject\n    Jenkins jenkins;", "modifier": "@Inject", "type": "Jenkins", "declarator": "jenkins", "var_name": "jenkins"}, {"original_string": "Set<String> pluginNames = Collections.EMPTY_SET;", "modifier": "", "type": "Set<String>", "declarator": "pluginNames = Collections.EMPTY_SET", "var_name": "pluginNames"}, {"original_string": "private static final Logger LOGGER = Logger.getLogger(SymbolLookup.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = Logger.getLogger(SymbolLookup.class.getName())", "var_name": "LOGGER"}], "methods": [{"identifier": "pluginsToNames", "parameters": "(List<PluginWrapper> plugins)", "modifiers": "private static", "return": "HashSet<String>", "signature": "HashSet<String> pluginsToNames(List<PluginWrapper> plugins)", "full_signature": "private static HashSet<String> pluginsToNames(List<PluginWrapper> plugins)", "class_method_signature": "SymbolLookup.pluginsToNames(List<PluginWrapper> plugins)", "testcase": false, "constructor": false}, {"identifier": "checkPluginsForChangeAndRefresh", "parameters": "()", "modifiers": "private synchronized", "return": "void", "signature": "void checkPluginsForChangeAndRefresh()", "full_signature": "private synchronized void checkPluginsForChangeAndRefresh()", "class_method_signature": "SymbolLookup.checkPluginsForChangeAndRefresh()", "testcase": false, "constructor": false}, {"identifier": "find", "parameters": "(Class<T> type, String symbol)", "modifiers": "public", "return": "T", "signature": "T find(Class<T> type, String symbol)", "full_signature": "public T find(Class<T> type, String symbol)", "class_method_signature": "SymbolLookup.find(Class<T> type, String symbol)", "testcase": false, "constructor": false}, {"identifier": "findDescriptor", "parameters": "(Class<?> type, String symbol)", "modifiers": "public", "return": "Descriptor<?>", "signature": "Descriptor<?> findDescriptor(Class<?> type, String symbol)", "full_signature": "public Descriptor<?> findDescriptor(Class<?> type, String symbol)", "class_method_signature": "SymbolLookup.findDescriptor(Class<?> type, String symbol)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "()", "modifiers": "public static", "return": "SymbolLookup", "signature": "SymbolLookup get()", "full_signature": "public static SymbolLookup get()", "class_method_signature": "SymbolLookup.get()", "testcase": false, "constructor": false}, {"identifier": "getSymbolValue", "parameters": "(@Nonnull Object o)", "modifiers": "@Nonnull public static", "return": "Set<String>", "signature": "Set<String> getSymbolValue(@Nonnull Object o)", "full_signature": "@Nonnull public static Set<String> getSymbolValue(@Nonnull Object o)", "class_method_signature": "SymbolLookup.getSymbolValue(@Nonnull Object o)", "testcase": false, "constructor": false}, {"identifier": "getSymbolValue", "parameters": "(@Nonnull Class<?> c)", "modifiers": "@SuppressFBWarnings(value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\", justification = \"Jenkins.getInstance() can return null in theory.\") @Nonnull public static", "return": "Set<String>", "signature": "Set<String> getSymbolValue(@Nonnull Class<?> c)", "full_signature": "@SuppressFBWarnings(value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\", justification = \"Jenkins.getInstance() can return null in theory.\") @Nonnull public static Set<String> getSymbolValue(@Nonnull Class<?> c)", "class_method_signature": "SymbolLookup.getSymbolValue(@Nonnull Class<?> c)", "testcase": false, "constructor": false}], "file": "plugin/src/main/java/org/jenkinsci/plugins/structs/SymbolLookup.java"}, "focal_method": {"identifier": "findDescriptor", "parameters": "(Class<?> type, String symbol)", "modifiers": "public", "return": "Descriptor<?>", "body": "public Descriptor<?> findDescriptor(Class<?> type, String symbol) {\n        try {\n            Key k = new Key(\"findDescriptor\",type,symbol);\n            Object i = cache.get(k);\n            if (i!=null)    return (Descriptor)i;\n\n            // not allowing @Symbol to use an invalid identifier.\n            // TODO: compile time check\n            if (!Utilities.isJavaIdentifier(symbol))\n                return null;\n\n            // Check for an explicit no-response with the plugin, after confirming no new plugins\n            checkPluginsForChangeAndRefresh();\n            Object miss = noHitCache.get(k);\n            if (miss == NO_HIT) {\n                return null;\n            }\n\n            for (Class<?> e : Index.list(Symbol.class, pluginManager.uberClassLoader, Class.class)) {\n                if (Descriptor.class.isAssignableFrom(e)) {\n                    Descriptor<?> d = jenkins.getDescriptorByType(e.asSubclass(Descriptor.class));\n                    if (d == null) {\n                        LOGGER.fine(() -> e.getName() + \" is not registered as an extension, so will be ignored\");\n                        continue;\n                    }\n                    Symbol s = e.getAnnotation(Symbol.class);\n                    if (s != null) {\n                        for (String t : s.value()) {\n                            if (t.equals(symbol)) {\n                                if (type.isAssignableFrom(d.clazz)) {\n                                    cache.put(k, d);\n                                    return d;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            noHitCache.put(k, NO_HIT);\n            return null;\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Unable to find @Symbol\",e);\n            return null;\n        }\n    }", "signature": "Descriptor<?> findDescriptor(Class<?> type, String symbol)", "full_signature": "public Descriptor<?> findDescriptor(Class<?> type, String symbol)", "class_method_signature": "SymbolLookup.findDescriptor(Class<?> type, String symbol)", "testcase": false, "constructor": false, "invocations": ["get", "isJavaIdentifier", "checkPluginsForChangeAndRefresh", "get", "list", "isAssignableFrom", "getDescriptorByType", "asSubclass", "fine", "getName", "getAnnotation", "value", "equals", "isAssignableFrom", "put", "put", "log"]}, "repository": {"repo_id": 48337544, "url": "https://github.com/jenkinsci/structs-plugin", "language": "Java", "is_fork": false, "fork_count": 28, "stargazer_count": 8, "size": 421, "license": "licensed"}}