{"test_class": {"identifier": "DecoderUtilsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Mockery context = new Mockery();", "modifier": "private static final", "type": "Mockery", "declarator": "context = new Mockery()", "var_name": "context"}], "file": "decoder/src/test/java/openlr/decoder/worker/DecoderUtilsTest.java"}, "test_case": {"identifier": "testCandidatePairOrder", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCandidatePairOrder() {\n        final Line l24 = context.mock(Line.class, \"l24\");\n        context.checking(new Expectations() {\n            {\n                allowing(l24).getID();\n                will(returnValue(24l));\n            }\n        });\n        final Line l21 = context.mock(Line.class, \"l21\");\n        context.checking(new Expectations() {\n            {\n                allowing(l21).getID();\n                will(returnValue(21l));\n            }\n        });\n        final Line l33 = context.mock(Line.class, \"l33\");\n        context.checking(new Expectations() {\n            {\n                allowing(l33).getID();\n                will(returnValue(33l));\n            }\n        });\n        final LocationReferencePoint lrp1 = context\n                .mock(LocationReferencePoint.class, \"lrp1\");\n        context.checking(new Expectations() {\n            {\n                allowing(lrp1).getSequenceNumber();\n                will(returnValue(1));\n            }\n        });\n        List<CandidateLine> candidates1 = new ArrayList<CandidateLine>();\n        candidates1.add(new CandidateLine(l24, 1197));\n        candidates1.add(new CandidateLine(l21, 1110));\n        candidates1.add(new CandidateLine(l33, 855));\n        CandidateLinesResultSet clrs = new CandidateLinesResultSet();\n        clrs.putCandidateLines(lrp1, candidates1);\n\n        final LocationReferencePoint lrp2 = context\n                .mock(LocationReferencePoint.class, \"lrp2\");\n        context.checking(new Expectations() {\n            {\n                allowing(lrp2).getSequenceNumber();\n                will(returnValue(2));\n            }\n        });\n        context.checking(new Expectations() {\n            {\n                allowing(lrp2).isLastLRP();\n                will(returnValue(false));\n            }\n        });\n        List<CandidateLine> candidates2 = new ArrayList<CandidateLine>();\n        candidates2.add(new CandidateLine(l24, 1164));\n        candidates2.add(new CandidateLine(l21, 1149));\n        candidates2.add(new CandidateLine(l33, 821));\n        clrs.putCandidateLines(lrp2, candidates2);\n\n        final LocationReferencePoint lrp3 = context\n                .mock(LocationReferencePoint.class, \"lrp3\");\n        context.checking(new Expectations() {\n            {\n                allowing(lrp3).getSequenceNumber();\n                will(returnValue(3));\n            }\n        });\n        context.checking(new Expectations() {\n            {\n                allowing(lrp3).isLastLRP();\n                will(returnValue(true));\n            }\n        });\n        List<CandidateLine> candidates3 = new ArrayList<CandidateLine>();\n        candidates3.add(new CandidateLine(l24, 1194));\n        candidates3.add(new CandidateLine(l33, 821));\n        clrs.putCandidateLines(lrp3, candidates3);\n\n        try {\n            List<CandidateLinePair> order = DecoderUtils\n                    .resolveCandidatesOrder(lrp1, lrp2, clrs, null,\n                            new OpenLRDecoderProperties(null),\n                            LocationType.LINE_LOCATION);\n            //System.out.println(order);\n        } catch (OpenLRProcessingException e) {\n            e.printStackTrace();\n            Assert.fail(\"Unexpected exception\");\n        }\n\n    }", "signature": "void testCandidatePairOrder()", "full_signature": "@Test public void testCandidatePairOrder()", "class_method_signature": "DecoderUtilsTest.testCandidatePairOrder()", "testcase": true, "constructor": false, "invocations": ["mock", "checking", "getID", "allowing", "will", "returnValue", "mock", "checking", "getID", "allowing", "will", "returnValue", "mock", "checking", "getID", "allowing", "will", "returnValue", "mock", "checking", "getSequenceNumber", "allowing", "will", "returnValue", "add", "add", "add", "putCandidateLines", "mock", "checking", "getSequenceNumber", "allowing", "will", "returnValue", "checking", "isLastLRP", "allowing", "will", "returnValue", "add", "add", "add", "putCandidateLines", "mock", "checking", "getSequenceNumber", "allowing", "will", "returnValue", "checking", "isLastLRP", "allowing", "will", "returnValue", "add", "add", "putCandidateLines", "resolveCandidatesOrder", "printStackTrace", "fail"]}, "focal_class": {"identifier": "DecoderUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = Logger.getLogger(DecoderUtils.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(DecoderUtils.class)", "var_name": "LOG"}], "methods": [{"identifier": "DecoderUtils", "parameters": "()", "modifiers": "private", "return": "", "signature": " DecoderUtils()", "full_signature": "private  DecoderUtils()", "class_method_signature": "DecoderUtils.DecoderUtils()", "testcase": false, "constructor": true}, {"identifier": "resolveCandidatesOrder", "parameters": "(\n            final LocationReferencePoint p1, final LocationReferencePoint p2,\n            final CandidateLinesResultSet candidateLines,\n            final CandidateLine lastUsed,\n            final OpenLRDecoderProperties properties, final LocationType locType)", "modifiers": "public static", "return": "List<CandidateLinePair>", "signature": "List<CandidateLinePair> resolveCandidatesOrder(\n            final LocationReferencePoint p1, final LocationReferencePoint p2,\n            final CandidateLinesResultSet candidateLines,\n            final CandidateLine lastUsed,\n            final OpenLRDecoderProperties properties, final LocationType locType)", "full_signature": "public static List<CandidateLinePair> resolveCandidatesOrder(\n            final LocationReferencePoint p1, final LocationReferencePoint p2,\n            final CandidateLinesResultSet candidateLines,\n            final CandidateLine lastUsed,\n            final OpenLRDecoderProperties properties, final LocationType locType)", "class_method_signature": "DecoderUtils.resolveCandidatesOrder(\n            final LocationReferencePoint p1, final LocationReferencePoint p2,\n            final CandidateLinesResultSet candidateLines,\n            final CandidateLine lastUsed,\n            final OpenLRDecoderProperties properties, final LocationType locType)", "testcase": false, "constructor": false}, {"identifier": "determineRouteLength", "parameters": "(final RouteSearch rs,\n                                           final CandidateLine destCandidate)", "modifiers": "public static", "return": "int", "signature": "int determineRouteLength(final RouteSearch rs,\n                                           final CandidateLine destCandidate)", "full_signature": "public static int determineRouteLength(final RouteSearch rs,\n                                           final CandidateLine destCandidate)", "class_method_signature": "DecoderUtils.determineRouteLength(final RouteSearch rs,\n                                           final CandidateLine destCandidate)", "testcase": false, "constructor": false}, {"identifier": "calculateMaxLength", "parameters": "(final LocationReferencePoint p,\n                                         final CandidateLine candP, final CandidateLine candNext,\n                                         final OpenLRDecoderProperties properties)", "modifiers": "public static", "return": "int", "signature": "int calculateMaxLength(final LocationReferencePoint p,\n                                         final CandidateLine candP, final CandidateLine candNext,\n                                         final OpenLRDecoderProperties properties)", "full_signature": "public static int calculateMaxLength(final LocationReferencePoint p,\n                                         final CandidateLine candP, final CandidateLine candNext,\n                                         final OpenLRDecoderProperties properties)", "class_method_signature": "DecoderUtils.calculateMaxLength(final LocationReferencePoint p,\n                                         final CandidateLine candP, final CandidateLine candNext,\n                                         final OpenLRDecoderProperties properties)", "testcase": false, "constructor": false}, {"identifier": "getMaxDistanceNP", "parameters": "(final LocationReferencePoint lrp,\n                                       final OpenLRDecoderProperties properties)", "modifiers": "public static", "return": "int", "signature": "int getMaxDistanceNP(final LocationReferencePoint lrp,\n                                       final OpenLRDecoderProperties properties)", "full_signature": "public static int getMaxDistanceNP(final LocationReferencePoint lrp,\n                                       final OpenLRDecoderProperties properties)", "class_method_signature": "DecoderUtils.getMaxDistanceNP(final LocationReferencePoint lrp,\n                                       final OpenLRDecoderProperties properties)", "testcase": false, "constructor": false}, {"identifier": "getMinDistanceNP", "parameters": "(final LocationReferencePoint lrp,\n                                       final OpenLRDecoderProperties properties)", "modifiers": "public static", "return": "int", "signature": "int getMinDistanceNP(final LocationReferencePoint lrp,\n                                       final OpenLRDecoderProperties properties)", "full_signature": "public static int getMinDistanceNP(final LocationReferencePoint lrp,\n                                       final OpenLRDecoderProperties properties)", "class_method_signature": "DecoderUtils.getMinDistanceNP(final LocationReferencePoint lrp,\n                                       final OpenLRDecoderProperties properties)", "testcase": false, "constructor": false}], "file": "decoder/src/main/java/openlr/decoder/worker/DecoderUtils.java"}, "focal_method": {"identifier": "resolveCandidatesOrder", "parameters": "(\n            final LocationReferencePoint p1, final LocationReferencePoint p2,\n            final CandidateLinesResultSet candidateLines,\n            final CandidateLine lastUsed,\n            final OpenLRDecoderProperties properties, final LocationType locType)", "modifiers": "public static", "return": "List<CandidateLinePair>", "body": "public static List<CandidateLinePair> resolveCandidatesOrder(\n            final LocationReferencePoint p1, final LocationReferencePoint p2,\n            final CandidateLinesResultSet candidateLines,\n            final CandidateLine lastUsed,\n            final OpenLRDecoderProperties properties, final LocationType locType)\n            throws OpenLRProcessingException {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"resolve candidates order with ConnectedRouteIncrease: \"\n                    + properties.getConnectedRouteIncrease()\n                    + \" and MaxNrRetries: \" + properties.getMaxNumberRetries());\n        }\n        List<CandidateLinePair> pairs = new ArrayList<CandidateLinePair>();\n        List<CandidateLine> p1List = candidateLines.getCandidateLines(p1);\n        List<CandidateLine> p2List = candidateLines.getCandidateLines(p2);\n        for (int i = 0; i < p1List.size(); ++i) {\n            int p1Score = p1List.get(i).getRating();\n            CandidateLine cl = p1List.get(i);\n            // check connection with previously calculated path\n            if (lastUsed != null && cl.hasSameLine(lastUsed)) {\n                p1Score += (properties.getConnectedRouteIncrease() * p1Score);\n            }\n            for (int j = 0; j < p2List.size(); ++j) {\n                int p2Score = p2List.get(j).getRating();\n                CandidateLinePair candidate = new CandidateLinePair(i, j,\n                        p1Score * p2Score);\n                pairs.add(candidate);\n            }\n        }\n        Collections.sort(pairs,\n                new CandidateLinePair.CandidateLinePairComparator());\n        int returnSize = Math.min(properties.getMaxNumberRetries() + 1,\n                pairs.size());\n        List<CandidateLinePair> subList = pairs.subList(0, returnSize);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Candidate pair list for \" + p1.getSequenceNumber()\n                    + \" and \" + p2.getSequenceNumber());\n            for (CandidateLinePair clp : subList) {\n                LOG.debug(\"startIdx[\" + clp.getStartIndex() + \"] - destIdx[\"\n                        + clp.getDestIndex() + \"], score: \" + clp.getScore());\n            }\n        }\n        return subList;\n    }", "signature": "List<CandidateLinePair> resolveCandidatesOrder(\n            final LocationReferencePoint p1, final LocationReferencePoint p2,\n            final CandidateLinesResultSet candidateLines,\n            final CandidateLine lastUsed,\n            final OpenLRDecoderProperties properties, final LocationType locType)", "full_signature": "public static List<CandidateLinePair> resolveCandidatesOrder(\n            final LocationReferencePoint p1, final LocationReferencePoint p2,\n            final CandidateLinesResultSet candidateLines,\n            final CandidateLine lastUsed,\n            final OpenLRDecoderProperties properties, final LocationType locType)", "class_method_signature": "DecoderUtils.resolveCandidatesOrder(\n            final LocationReferencePoint p1, final LocationReferencePoint p2,\n            final CandidateLinesResultSet candidateLines,\n            final CandidateLine lastUsed,\n            final OpenLRDecoderProperties properties, final LocationType locType)", "testcase": false, "constructor": false, "invocations": ["isDebugEnabled", "debug", "getConnectedRouteIncrease", "getMaxNumberRetries", "getCandidateLines", "getCandidateLines", "size", "getRating", "get", "get", "hasSameLine", "getConnectedRouteIncrease", "size", "getRating", "get", "add", "sort", "min", "getMaxNumberRetries", "size", "subList", "isDebugEnabled", "debug", "getSequenceNumber", "getSequenceNumber", "debug", "getStartIndex", "getDestIndex", "getScore"]}, "repository": {"repo_id": 187195345, "url": "https://github.com/tomtom-international/openlr", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 24, "size": 4809, "license": "licensed"}}