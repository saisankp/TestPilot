{"test_class": {"identifier": "ClassLoaderClassInformationRepositoryTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ClassLoaderClassInformationRepository repo;", "modifier": "private", "type": "ClassLoaderClassInformationRepository", "declarator": "repo", "var_name": "repo"}], "file": "instrumenter/src/test/java/com/offbynull/coroutines/instrumenter/asm/ClassLoaderClassInformationRepositoryTest.java"}, "test_case": {"identifier": "mustGetClassInformationForObject", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void mustGetClassInformationForObject() {\n        ClassInformation info = repo.getInformation(\"java/lang/Object\");\n        \n        assertNull(info.getSuperClassName());\n        assertTrue(info.getInterfaces().isEmpty());\n        assertFalse(info.isInterface());\n    }", "signature": "void mustGetClassInformationForObject()", "full_signature": "@Test public void mustGetClassInformationForObject()", "class_method_signature": "ClassLoaderClassInformationRepositoryTest.mustGetClassInformationForObject()", "testcase": true, "constructor": false, "invocations": ["getInformation", "assertNull", "getSuperClassName", "assertTrue", "isEmpty", "getInterfaces", "assertFalse", "isInterface"]}, "focal_class": {"identifier": "ClassLoaderClassInformationRepository", "superclass": "", "interfaces": "implements ClassInformationRepository", "fields": [{"original_string": "private final ClassLoader classLoader;", "modifier": "private final", "type": "ClassLoader", "declarator": "classLoader", "var_name": "classLoader"}], "methods": [{"identifier": "ClassLoaderClassInformationRepository", "parameters": "(ClassLoader classLoader)", "modifiers": "public", "return": "", "signature": " ClassLoaderClassInformationRepository(ClassLoader classLoader)", "full_signature": "public  ClassLoaderClassInformationRepository(ClassLoader classLoader)", "class_method_signature": "ClassLoaderClassInformationRepository.ClassLoaderClassInformationRepository(ClassLoader classLoader)", "testcase": false, "constructor": true}, {"identifier": "getInformation", "parameters": "(String internalClassName)", "modifiers": "@Override public", "return": "ClassInformation", "signature": "ClassInformation getInformation(String internalClassName)", "full_signature": "@Override public ClassInformation getInformation(String internalClassName)", "class_method_signature": "ClassLoaderClassInformationRepository.getInformation(String internalClassName)", "testcase": false, "constructor": false}], "file": "instrumenter/src/main/java/com/offbynull/coroutines/instrumenter/asm/ClassLoaderClassInformationRepository.java"}, "focal_method": {"identifier": "getInformation", "parameters": "(String internalClassName)", "modifiers": "@Override public", "return": "ClassInformation", "body": "@Override\n    public ClassInformation getInformation(String internalClassName) {\n        Validate.notNull(internalClassName);\n        \n        String className = Type.getObjectType(internalClassName).getClassName();\n        Class<?> cls;\n        try {\n            cls = Class.forName(className, false, classLoader);\n        } catch (ClassNotFoundException cfne) {\n            return null;\n        }\n        \n        \n        boolean interfaceMarker = cls.isInterface();\n        \n        Class<?>[] interfaceClses = cls.getInterfaces();\n        List<String> internalInterfaceNames = new ArrayList<>(interfaceClses.length);\n        for (Class<?> interfaceCls : interfaceClses) {\n            internalInterfaceNames.add(Type.getInternalName(interfaceCls));\n        }\n        \n        String internalSuperClassName;\n        if (interfaceMarker) {\n            // If this is an interface, it needs to mimic how class files are structured. Normally a class file will have its super class\n            // set to java/lang/Object if it's an interface. This isn't exposed through the classloader. Not sure why this is like this but\n            // if we encounter an interface as the class being accessed through the classloader, always override it to have a \"superclass\"\n            // of java/lang/Object. The classloader itself would return null in this case.\n            //\n            // This is what ASM does internally as well when it loads info from a classloader.\n            internalSuperClassName = Type.getInternalName(Object.class);\n        } else {\n            Class<?> superCls = cls.getSuperclass();\n            internalSuperClassName = superCls == null ? null : Type.getInternalName(superCls);\n        }\n\n        return new ClassInformation(internalClassName, internalSuperClassName, internalInterfaceNames, interfaceMarker);\n    }", "signature": "ClassInformation getInformation(String internalClassName)", "full_signature": "@Override public ClassInformation getInformation(String internalClassName)", "class_method_signature": "ClassLoaderClassInformationRepository.getInformation(String internalClassName)", "testcase": false, "constructor": false, "invocations": ["notNull", "getClassName", "getObjectType", "forName", "isInterface", "getInterfaces", "add", "getInternalName", "getInternalName", "getSuperclass", "getInternalName"]}, "repository": {"repo_id": 31940141, "url": "https://github.com/offbynull/coroutines", "language": "Java", "is_fork": false, "fork_count": 45, "stargazer_count": 287, "size": 841, "license": "licensed"}}