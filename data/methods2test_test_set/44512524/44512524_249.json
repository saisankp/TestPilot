{"test_class": {"identifier": "ElasticsearchQueryStoreTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private MockElasticsearchServer elasticsearchServer;", "modifier": "private", "type": "MockElasticsearchServer", "declarator": "elasticsearchServer", "var_name": "elasticsearchServer"}, {"original_string": "private DataStore dataStore;", "modifier": "private", "type": "DataStore", "declarator": "dataStore", "var_name": "dataStore"}, {"original_string": "private ElasticsearchQueryStore queryStore;", "modifier": "private", "type": "ElasticsearchQueryStore", "declarator": "queryStore", "var_name": "queryStore"}, {"original_string": "private ObjectMapper mapper;", "modifier": "private", "type": "ObjectMapper", "declarator": "mapper", "var_name": "mapper"}], "file": "real-time/foxtrot/foxtrot-core/src/test/java/com/flipkart/foxtrot/core/querystore/impl/ElasticsearchQueryStoreTest.java"}, "test_case": {"identifier": "testSaveSingle", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSaveSingle() throws Exception {\n        Document expectedDocument = new Document();\n        expectedDocument.setId(UUID.randomUUID().toString());\n        expectedDocument.setTimestamp(System.currentTimeMillis());\n        JsonNode data = mapper.valueToTree(Collections.singletonMap(\"TEST_NAME\", \"SINGLE_SAVE_TEST\"));\n        expectedDocument.setData(data);\n        queryStore.save(TestUtils.TEST_TABLE_NAME, expectedDocument);\n\n        GetResponse getResponse = elasticsearchServer\n                .getClient()\n                .prepareGet(ElasticsearchUtils.getCurrentIndex(TestUtils.TEST_TABLE_NAME, expectedDocument.getTimestamp()),\n                        ElasticsearchUtils.TYPE_NAME,\n                        expectedDocument.getId())\n                .setFields(\"_timestamp\").execute().actionGet();\n        assertTrue(\"Id should exist in ES\", getResponse.isExists());\n        assertEquals(\"Id should match requestId\", expectedDocument.getId(), getResponse.getId());\n        assertEquals(\"Timestamp should match request timestamp\", expectedDocument.getTimestamp(), getResponse.getField(\"_timestamp\").getValue());\n    }", "signature": "void testSaveSingle()", "full_signature": "@Test public void testSaveSingle()", "class_method_signature": "ElasticsearchQueryStoreTest.testSaveSingle()", "testcase": true, "constructor": false, "invocations": ["setId", "toString", "randomUUID", "setTimestamp", "currentTimeMillis", "valueToTree", "singletonMap", "setData", "save", "actionGet", "execute", "setFields", "prepareGet", "getClient", "getCurrentIndex", "getTimestamp", "getId", "assertTrue", "isExists", "assertEquals", "getId", "getId", "assertEquals", "getTimestamp", "getValue", "getField"]}, "focal_class": {"identifier": "ElasticsearchQueryStore", "superclass": "", "interfaces": "implements QueryStore", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(ElasticsearchQueryStore.class.getSimpleName());", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(ElasticsearchQueryStore.class.getSimpleName())", "var_name": "logger"}, {"original_string": "private final TableMetadataManager tableMetadataManager;", "modifier": "private final", "type": "TableMetadataManager", "declarator": "tableMetadataManager", "var_name": "tableMetadataManager"}, {"original_string": "private final ElasticsearchConnection connection;", "modifier": "private final", "type": "ElasticsearchConnection", "declarator": "connection", "var_name": "connection"}, {"original_string": "private final DataStore dataStore;", "modifier": "private final", "type": "DataStore", "declarator": "dataStore", "var_name": "dataStore"}, {"original_string": "private final ObjectMapper mapper;", "modifier": "private final", "type": "ObjectMapper", "declarator": "mapper", "var_name": "mapper"}], "methods": [{"identifier": "ElasticsearchQueryStore", "parameters": "(TableMetadataManager tableMetadataManager,\n                                   ElasticsearchConnection connection,\n                                   DataStore dataStore)", "modifiers": "public", "return": "", "signature": " ElasticsearchQueryStore(TableMetadataManager tableMetadataManager,\n                                   ElasticsearchConnection connection,\n                                   DataStore dataStore)", "full_signature": "public  ElasticsearchQueryStore(TableMetadataManager tableMetadataManager,\n                                   ElasticsearchConnection connection,\n                                   DataStore dataStore)", "class_method_signature": "ElasticsearchQueryStore.ElasticsearchQueryStore(TableMetadataManager tableMetadataManager,\n                                   ElasticsearchConnection connection,\n                                   DataStore dataStore)", "testcase": false, "constructor": true}, {"identifier": "save", "parameters": "(String table, Document document)", "modifiers": "@Override public", "return": "void", "signature": "void save(String table, Document document)", "full_signature": "@Override public void save(String table, Document document)", "class_method_signature": "ElasticsearchQueryStore.save(String table, Document document)", "testcase": false, "constructor": false}, {"identifier": "save", "parameters": "(String table, List<Document> documents)", "modifiers": "@Override public", "return": "void", "signature": "void save(String table, List<Document> documents)", "full_signature": "@Override public void save(String table, List<Document> documents)", "class_method_signature": "ElasticsearchQueryStore.save(String table, List<Document> documents)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(String table, String id)", "modifiers": "@Override public", "return": "Document", "signature": "Document get(String table, String id)", "full_signature": "@Override public Document get(String table, String id)", "class_method_signature": "ElasticsearchQueryStore.get(String table, String id)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(String table, List<String> ids)", "modifiers": "@Override public", "return": "List<Document>", "signature": "List<Document> get(String table, List<String> ids)", "full_signature": "@Override public List<Document> get(String table, List<String> ids)", "class_method_signature": "ElasticsearchQueryStore.get(String table, List<String> ids)", "testcase": false, "constructor": false}, {"identifier": "getFieldMappings", "parameters": "(String table)", "modifiers": "@Override public", "return": "TableFieldMapping", "signature": "TableFieldMapping getFieldMappings(String table)", "full_signature": "@Override public TableFieldMapping getFieldMappings(String table)", "class_method_signature": "ElasticsearchQueryStore.getFieldMappings(String table)", "testcase": false, "constructor": false}, {"identifier": "cleanupAll", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void cleanupAll()", "full_signature": "@Override public void cleanupAll()", "class_method_signature": "ElasticsearchQueryStore.cleanupAll()", "testcase": false, "constructor": false}, {"identifier": "cleanup", "parameters": "(final String table)", "modifiers": "@Override public", "return": "void", "signature": "void cleanup(final String table)", "full_signature": "@Override public void cleanup(final String table)", "class_method_signature": "ElasticsearchQueryStore.cleanup(final String table)", "testcase": false, "constructor": false}, {"identifier": "cleanup", "parameters": "(Set<String> tables)", "modifiers": "@Override public", "return": "void", "signature": "void cleanup(Set<String> tables)", "full_signature": "@Override public void cleanup(Set<String> tables)", "class_method_signature": "ElasticsearchQueryStore.cleanup(Set<String> tables)", "testcase": false, "constructor": false}], "file": "real-time/foxtrot/foxtrot-core/src/main/java/com/flipkart/foxtrot/core/querystore/impl/ElasticsearchQueryStore.java"}, "focal_method": {"identifier": "save", "parameters": "(String table, Document document)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void save(String table, Document document) throws QueryStoreException {\n        table = ElasticsearchUtils.getValidTableName(table);\n        try {\n            if (!tableMetadataManager.exists(table)) {\n                throw new QueryStoreException(QueryStoreException.ErrorCode.NO_SUCH_TABLE,\n                        \"No table exists with the name: \" + table);\n            }\n            if (new DateTime().plusDays(1).minus(document.getTimestamp()).getMillis() <  0) {\n                return;\n            }\n            dataStore.save(tableMetadataManager.get(table), document);\n            long timestamp = document.getTimestamp();\n            Stopwatch stopwatch = new Stopwatch();\n            stopwatch.start();\n            connection.getClient()\n                    .prepareIndex()\n                    .setIndex(ElasticsearchUtils.getCurrentIndex(table, timestamp))\n                    .setType(ElasticsearchUtils.TYPE_NAME)\n                    .setId(document.getId())\n                    .setTimestamp(Long.toString(timestamp))\n                    .setSource(mapper.writeValueAsBytes(document.getData()))\n                    .setConsistencyLevel(WriteConsistencyLevel.QUORUM)\n                    .execute()\n                    .get(2, TimeUnit.SECONDS);\n            logger.info(String.format(\"ES took : %d table : %s\", stopwatch.elapsedMillis(), table));\n        } catch (QueryStoreException ex) {\n            throw ex;\n        } catch (DataStoreException ex) {\n            DataStoreException.ErrorCode code = ex.getErrorCode();\n            if (code.equals(DataStoreException.ErrorCode.STORE_INVALID_REQUEST)\n                    || code.equals(DataStoreException.ErrorCode.STORE_INVALID_DOCUMENT)) {\n                throw new QueryStoreException(QueryStoreException.ErrorCode.INVALID_REQUEST,\n                        ex.getMessage(), ex);\n            } else {\n                throw new QueryStoreException(QueryStoreException.ErrorCode.DOCUMENT_SAVE_ERROR,\n                        ex.getMessage(), ex);\n            }\n        } catch (JsonProcessingException ex) {\n            throw new QueryStoreException(QueryStoreException.ErrorCode.INVALID_REQUEST,\n                    ex.getMessage(), ex);\n        } catch (Exception ex) {\n            throw new QueryStoreException(QueryStoreException.ErrorCode.DOCUMENT_SAVE_ERROR,\n                    ex.getMessage(), ex);\n        }\n    }", "signature": "void save(String table, Document document)", "full_signature": "@Override public void save(String table, Document document)", "class_method_signature": "ElasticsearchQueryStore.save(String table, Document document)", "testcase": false, "constructor": false, "invocations": ["getValidTableName", "exists", "getMillis", "minus", "plusDays", "getTimestamp", "save", "get", "getTimestamp", "start", "get", "execute", "setConsistencyLevel", "setSource", "setTimestamp", "setId", "setType", "setIndex", "prepareIndex", "getClient", "getCurrentIndex", "getId", "toString", "writeValueAsBytes", "getData", "info", "format", "elapsedMillis", "getErrorCode", "equals", "equals", "getMessage", "getMessage", "getMessage", "getMessage"]}, "repository": {"repo_id": 44512524, "url": "https://github.com/zqhxuyuan/bigdata", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 8, "size": 91550, "license": "licensed"}}