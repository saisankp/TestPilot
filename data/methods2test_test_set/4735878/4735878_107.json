{"test_class": {"identifier": "ShapeHelperTest", "superclass": "", "interfaces": "", "fields": [], "file": "bundles/core-map/src/test/java/org/orbisgis/coremap/renderer/se/common/ShapeHelperTest.java"}, "test_case": {"identifier": "testSplitLine_Shape_double", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n        public void testSplitLine_Shape_double() {\n\t\tSystem.out.println(\"splitLine\");\n\n\t\tPath2D.Double line = new Path2D.Double() {};\n\t\tline.moveTo(0,0);\n\t\tline.lineTo(10, 10);\n\t\tline.lineTo(0, 20);\n\t\tline.lineTo(10, 30);\n\t\tline.lineTo(0, 40);\n\n\t\tdouble coords[] = new double[6];\n\t\tList<Shape> result1 = ShapeHelper.splitLine(line, 28.28);\n\n\n\t\tfor (Shape shp : result1){\n\t\t\tPathIterator it = shp.getPathIterator(null);\n\t\t\tSystem.out.println (\"Shape: \");\n\n\t\t\twhile (!it.isDone()){\n\t\t\t\tit.currentSegment(coords);\n\t\t\t\tSystem.out.println (\"(\" + coords[0] + \";\" + \" \" + coords[1] + \")\");\n\t\t\t\tit.next();\n\t\t\t}\n\t\t};\n\n\t\tresult1 = ShapeHelper.splitLine(line, 35.0);\n\n\t\tfor (Shape shp : result1){\n\t\t\tPathIterator it = shp.getPathIterator(null);\n\t\t\tSystem.out.println (\"Shape: \");\n\n\t\t\twhile (!it.isDone()){\n\t\t\t\tit.currentSegment(coords);\n\t\t\t\tSystem.out.println (\"(\" + coords[0] + \";\" + \" \" + coords[1] + \")\");\n\t\t\t\tit.next();\n\t\t\t}\n\t\t}\n\n\n\t\tresult1 = ShapeHelper.splitLine(line, 70.0);\n\n\t\tfor (Shape shp : result1){\n\t\t\tPathIterator it = shp.getPathIterator(null);\n\t\t\tSystem.out.println (\"Shape: \");\n\n\t\t\twhile (!it.isDone()){\n\t\t\t\tit.currentSegment(coords);\n\t\t\t\tSystem.out.println (\"(\" + coords[0] + \";\" + \" \" + coords[1] + \")\");\n\t\t\t\tit.next();\n\t\t\t}\n\t\t}\n\t}", "signature": "void testSplitLine_Shape_double()", "full_signature": "@Test public void testSplitLine_Shape_double()", "class_method_signature": "ShapeHelperTest.testSplitLine_Shape_double()", "testcase": true, "constructor": false, "invocations": ["println", "moveTo", "lineTo", "lineTo", "lineTo", "lineTo", "splitLine", "getPathIterator", "println", "isDone", "currentSegment", "println", "next", "splitLine", "getPathIterator", "println", "isDone", "currentSegment", "println", "next", "splitLine", "getPathIterator", "println", "isDone", "currentSegment", "println", "next"]}, "focal_class": {"identifier": "ShapeHelper", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final double ONE_DEG_IN_RAD = Math.PI / 180.0;", "modifier": "public static final", "type": "double", "declarator": "ONE_DEG_IN_RAD = Math.PI / 180.0", "var_name": "ONE_DEG_IN_RAD"}, {"original_string": "private static final boolean ENABLE_QUAD = true;", "modifier": "private static final", "type": "boolean", "declarator": "ENABLE_QUAD = true", "var_name": "ENABLE_QUAD"}, {"original_string": "private static final double FLATNESS = 1e-5;", "modifier": "private static final", "type": "double", "declarator": "FLATNESS = 1e-5", "var_name": "FLATNESS"}, {"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ShapeHelper.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ShapeHelper.class)", "var_name": "LOGGER"}, {"original_string": "private static final I18n I18N = I18nFactory.getI18n(ShapeHelper.class);", "modifier": "private static final", "type": "I18n", "declarator": "I18N = I18nFactory.getI18n(ShapeHelper.class)", "var_name": "I18N"}], "methods": [{"identifier": "ShapeHelper", "parameters": "()", "modifiers": "private", "return": "", "signature": " ShapeHelper()", "full_signature": "private  ShapeHelper()", "class_method_signature": "ShapeHelper.ShapeHelper()", "testcase": false, "constructor": true}, {"identifier": "getAreaPerimeterLength", "parameters": "(Shape area)", "modifiers": "public static", "return": "double", "signature": "double getAreaPerimeterLength(Shape area)", "full_signature": "public static double getAreaPerimeterLength(Shape area)", "class_method_signature": "ShapeHelper.getAreaPerimeterLength(Shape area)", "testcase": false, "constructor": false}, {"identifier": "getLineLength", "parameters": "(Shape line)", "modifiers": "public static", "return": "double", "signature": "double getLineLength(Shape line)", "full_signature": "public static double getLineLength(Shape line)", "class_method_signature": "ShapeHelper.getLineLength(Shape line)", "testcase": false, "constructor": false}, {"identifier": "printvertices", "parameters": "(Shape shp)", "modifiers": "public static", "return": "void", "signature": "void printvertices(Shape shp)", "full_signature": "public static void printvertices(Shape shp)", "class_method_signature": "ShapeHelper.printvertices(Shape shp)", "testcase": false, "constructor": false}, {"identifier": "splitLine", "parameters": "(Shape line, double firstLineLength)", "modifiers": "public static", "return": "List<Shape>", "signature": "List<Shape> splitLine(Shape line, double firstLineLength)", "full_signature": "public static List<Shape> splitLine(Shape line, double firstLineLength)", "class_method_signature": "ShapeHelper.splitLine(Shape line, double firstLineLength)", "testcase": false, "constructor": false}, {"identifier": "splitLineInSeg", "parameters": "(Shape line, double segLength)", "modifiers": "public static", "return": "List<Shape>", "signature": "List<Shape> splitLineInSeg(Shape line, double segLength)", "full_signature": "public static List<Shape> splitLineInSeg(Shape line, double segLength)", "class_method_signature": "ShapeHelper.splitLineInSeg(Shape line, double segLength)", "testcase": false, "constructor": false}, {"identifier": "splitLine", "parameters": "(Shape line, int nbPart)", "modifiers": "public static", "return": "List<Shape>", "signature": "List<Shape> splitLine(Shape line, int nbPart)", "full_signature": "public static List<Shape> splitLine(Shape line, int nbPart)", "class_method_signature": "ShapeHelper.splitLine(Shape line, int nbPart)", "testcase": false, "constructor": false}, {"identifier": "getPointAt", "parameters": "(double x1, double y1, double x2, double y2, double distance)", "modifiers": "private static", "return": "Point2D.Double", "signature": "Point2D.Double getPointAt(double x1, double y1, double x2, double y2, double distance)", "full_signature": "private static Point2D.Double getPointAt(double x1, double y1, double x2, double y2, double distance)", "class_method_signature": "ShapeHelper.getPointAt(double x1, double y1, double x2, double y2, double distance)", "testcase": false, "constructor": false}, {"identifier": "getPointAt", "parameters": "(Shape shp, double distance)", "modifiers": "public static", "return": "Point2D.Double", "signature": "Point2D.Double getPointAt(Shape shp, double distance)", "full_signature": "public static Point2D.Double getPointAt(Shape shp, double distance)", "class_method_signature": "ShapeHelper.getPointAt(Shape shp, double distance)", "testcase": false, "constructor": false}, {"identifier": "getVertexes", "parameters": "(Shape shp)", "modifiers": "private static", "return": "List<ArrayList<Vertex>>", "signature": "List<ArrayList<Vertex>> getVertexes(Shape shp)", "full_signature": "private static List<ArrayList<Vertex>> getVertexes(Shape shp)", "class_method_signature": "ShapeHelper.getVertexes(Shape shp)", "testcase": false, "constructor": false}, {"identifier": "removeUselessVertex", "parameters": "(List<Vertex> vertexes)", "modifiers": "private static", "return": "void", "signature": "void removeUselessVertex(List<Vertex> vertexes)", "full_signature": "private static void removeUselessVertex(List<Vertex> vertexes)", "class_method_signature": "ShapeHelper.removeUselessVertex(List<Vertex> vertexes)", "testcase": false, "constructor": false}, {"identifier": "createOffsetVertexes", "parameters": "(List<Vertex> vertexes, double offset, boolean closed)", "modifiers": "private static", "return": "List<Vertex>", "signature": "List<Vertex> createOffsetVertexes(List<Vertex> vertexes, double offset, boolean closed)", "full_signature": "private static List<Vertex> createOffsetVertexes(List<Vertex> vertexes, double offset, boolean closed)", "class_method_signature": "ShapeHelper.createOffsetVertexes(List<Vertex> vertexes, double offset, boolean closed)", "testcase": false, "constructor": false}, {"identifier": "getDistanceFromSegment", "parameters": "(double x1, double y1, double x2, double y2, double x3, double y3)", "modifiers": "private static", "return": "double", "signature": "double getDistanceFromSegment(double x1, double y1, double x2, double y2, double x3, double y3)", "full_signature": "private static double getDistanceFromSegment(double x1, double y1, double x2, double y2, double x3, double y3)", "class_method_signature": "ShapeHelper.getDistanceFromSegment(double x1, double y1, double x2, double y2, double x3, double y3)", "testcase": false, "constructor": false}, {"identifier": "computeEdges", "parameters": "(List<Vertex> vertexes, List<Vertex> offsetVertexes, double offset, boolean closed)", "modifiers": "private static", "return": "List<Edge>", "signature": "List<Edge> computeEdges(List<Vertex> vertexes, List<Vertex> offsetVertexes, double offset, boolean closed)", "full_signature": "private static List<Edge> computeEdges(List<Vertex> vertexes, List<Vertex> offsetVertexes, double offset, boolean closed)", "class_method_signature": "ShapeHelper.computeEdges(List<Vertex> vertexes, List<Vertex> offsetVertexes, double offset, boolean closed)", "testcase": false, "constructor": false}, {"identifier": "createShapeFromVertexes", "parameters": "(List<Vertex> vertexes, boolean closed)", "modifiers": "private static", "return": "Shape", "signature": "Shape createShapeFromVertexes(List<Vertex> vertexes, boolean closed)", "full_signature": "private static Shape createShapeFromVertexes(List<Vertex> vertexes, boolean closed)", "class_method_signature": "ShapeHelper.createShapeFromVertexes(List<Vertex> vertexes, boolean closed)", "testcase": false, "constructor": false}, {"identifier": "computeRawLink", "parameters": "(List<Edge> edges, List<Vertex> vertexes, boolean closed)", "modifiers": "private static", "return": "List<Vertex>", "signature": "List<Vertex> computeRawLink(List<Edge> edges, List<Vertex> vertexes, boolean closed)", "full_signature": "private static List<Vertex> computeRawLink(List<Edge> edges, List<Vertex> vertexes, boolean closed)", "class_method_signature": "ShapeHelper.computeRawLink(List<Edge> edges, List<Vertex> vertexes, boolean closed)", "testcase": false, "constructor": false}, {"identifier": "isPointOnSegement", "parameters": "(double x1, double y1, double x2, double y2, double x3, double y3)", "modifiers": "private static", "return": "boolean", "signature": "boolean isPointOnSegement(double x1, double y1, double x2, double y2, double x3, double y3)", "full_signature": "private static boolean isPointOnSegement(double x1, double y1, double x2, double y2, double x3, double y3)", "class_method_signature": "ShapeHelper.isPointOnSegement(double x1, double y1, double x2, double y2, double x3, double y3)", "testcase": false, "constructor": false}, {"identifier": "isClosed", "parameters": "(List<Vertex> vertexes)", "modifiers": "private static", "return": "boolean", "signature": "boolean isClosed(List<Vertex> vertexes)", "full_signature": "private static boolean isClosed(List<Vertex> vertexes)", "class_method_signature": "ShapeHelper.isClosed(List<Vertex> vertexes)", "testcase": false, "constructor": false}, {"identifier": "contourParallelShape", "parameters": "(Shape shp, double offset)", "modifiers": "private static", "return": "List<Shape>", "signature": "List<Shape> contourParallelShape(Shape shp, double offset)", "full_signature": "private static List<Shape> contourParallelShape(Shape shp, double offset)", "class_method_signature": "ShapeHelper.contourParallelShape(Shape shp, double offset)", "testcase": false, "constructor": false}, {"identifier": "crossProduct", "parameters": "(double x1, double y1, double x2, double y2, double x3, double y3)", "modifiers": "static", "return": "double", "signature": "double crossProduct(double x1, double y1, double x2, double y2, double x3, double y3)", "full_signature": "static double crossProduct(double x1, double y1, double x2, double y2, double x3, double y3)", "class_method_signature": "ShapeHelper.crossProduct(double x1, double y1, double x2, double y2, double x3, double y3)", "testcase": false, "constructor": false}, {"identifier": "isSegIntersect", "parameters": "(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "modifiers": "private static", "return": "boolean", "signature": "boolean isSegIntersect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "full_signature": "private static boolean isSegIntersect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "class_method_signature": "ShapeHelper.isSegIntersect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "testcase": false, "constructor": false}, {"identifier": "computeSegmentIntersection", "parameters": "(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "modifiers": "private static", "return": "Point2D.Double", "signature": "Point2D.Double computeSegmentIntersection(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "full_signature": "private static Point2D.Double computeSegmentIntersection(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "class_method_signature": "ShapeHelper.computeSegmentIntersection(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "testcase": false, "constructor": false}, {"identifier": "getLineIntersection", "parameters": "(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "modifiers": "private static", "return": "Point2D.Double", "signature": "Point2D.Double getLineIntersection(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "full_signature": "private static Point2D.Double getLineIntersection(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "class_method_signature": "ShapeHelper.getLineIntersection(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)", "testcase": false, "constructor": false}, {"identifier": "perpendicularOffset", "parameters": "(Shape shp, double offset)", "modifiers": "public static", "return": "List<Shape>", "signature": "List<Shape> perpendicularOffset(Shape shp, double offset)", "full_signature": "public static List<Shape> perpendicularOffset(Shape shp, double offset)", "class_method_signature": "ShapeHelper.perpendicularOffset(Shape shp, double offset)", "testcase": false, "constructor": false}, {"identifier": "intersection", "parameters": "(Line2D.Double line, Rectangle2D.Double bounds)", "modifiers": "public static", "return": "Line2D.Double", "signature": "Line2D.Double intersection(Line2D.Double line, Rectangle2D.Double bounds)", "full_signature": "public static Line2D.Double intersection(Line2D.Double line, Rectangle2D.Double bounds)", "class_method_signature": "ShapeHelper.intersection(Line2D.Double line, Rectangle2D.Double bounds)", "testcase": false, "constructor": false}, {"identifier": "clipToExtent", "parameters": "(Geometry theGeom, Envelope extent)", "modifiers": "public static", "return": "Geometry", "signature": "Geometry clipToExtent(Geometry theGeom, Envelope extent)", "full_signature": "public static Geometry clipToExtent(Geometry theGeom, Envelope extent)", "class_method_signature": "ShapeHelper.clipToExtent(Geometry theGeom, Envelope extent)", "testcase": false, "constructor": false}], "file": "bundles/core-map/src/main/java/org/orbisgis/coremap/renderer/se/common/ShapeHelper.java"}, "focal_method": {"identifier": "splitLine", "parameters": "(Shape line, double firstLineLength)", "modifiers": "public static", "return": "List<Shape>", "body": "public static List<Shape> splitLine(Shape line, double firstLineLength) {\n\n        ArrayList<Shape> shapes = new ArrayList<Shape>();\n\n        if (ShapeHelper.getLineLength(line) < firstLineLength) {\n            shapes.add(line);\n            return shapes;\n        }\n\n        PathIterator it = line.getPathIterator(null, FLATNESS);\n        double coords[] = new double[6];\n        Path2D.Double segment = new Path2D.Double();\n        double p = 0.0;\n        double p1;\n\n        it.currentSegment(coords);\n\n        double x1 = coords[0];\n        double y1 = coords[1];\n        segment.moveTo(x1, y1);\n\n        double xFirst = x1;\n        double yFirst = y1;\n\n        it.next();\n\n        double x2;\n        double y2;\n\n        boolean first = true;\n\n        while (!it.isDone()) {\n            int type = it.currentSegment(coords);\n\n            if (type == PathIterator.SEG_CLOSE) {\n                x2 = xFirst;\n                y2 = yFirst;\n            } else {\n                x2 = coords[0];\n                y2 = coords[1];\n            }\n\n            double xx, yy;\n            xx = x2 - x1;\n            yy = y2 - y1;\n            p1 = Math.sqrt(xx * xx + yy * yy);\n            p += p1;\n\n            if (first && p > firstLineLength) {\n                first = false;\n                // Le point courant d\u00e9passe la limite de longueur\n                double delta = (p - firstLineLength);\n\n                // Obtenir le point qui est exactement \u00e0 la limite\n                Point2D.Double pt = getPointAt(x1, y1, x2, y2, p1 - delta);\n\n                x1 = pt.x;\n                y1 = pt.y;\n\n                // On termine le segment, l'ajoute \u00e0 la liste de shapes\n                segment.lineTo(x1, y1);\n                p = 0;\n                shapes.add(segment);\n\n                // Et commence le nouveau segment \u00e0\n                segment = new Path2D.Double();\n                segment.moveTo(x1, y1);\n\n            } else {\n                // Le point courant d\u00e9passe la limite de longueur\n                segment.lineTo(x2, y2);\n                x1 = x2;\n                y1 = y2;\n                it.next();\n            }\n        }\n        //last segment end with last point\n\n        shapes.add(segment);\n\n        return shapes;\n    }", "signature": "List<Shape> splitLine(Shape line, double firstLineLength)", "full_signature": "public static List<Shape> splitLine(Shape line, double firstLineLength)", "class_method_signature": "ShapeHelper.splitLine(Shape line, double firstLineLength)", "testcase": false, "constructor": false, "invocations": ["getLineLength", "add", "getPathIterator", "currentSegment", "moveTo", "next", "isDone", "currentSegment", "sqrt", "getPointAt", "lineTo", "add", "moveTo", "lineTo", "next", "add"]}, "repository": {"repo_id": 4735878, "url": "https://github.com/orbisgis/orbisgis", "language": "Java", "is_fork": false, "fork_count": 37, "stargazer_count": 63, "size": 76463, "license": "licensed"}}