{"test_class": {"identifier": "DistributedHerderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Map<String, String> HERDER_CONFIG = new HashMap<>();", "modifier": "private static final", "type": "Map<String, String>", "declarator": "HERDER_CONFIG = new HashMap<>()", "var_name": "HERDER_CONFIG"}, {"original_string": "private static final String MEMBER_URL = \"memberUrl\";", "modifier": "private static final", "type": "String", "declarator": "MEMBER_URL = \"memberUrl\"", "var_name": "MEMBER_URL"}, {"original_string": "private static final String CONN1 = \"sourceA\";", "modifier": "private static final", "type": "String", "declarator": "CONN1 = \"sourceA\"", "var_name": "CONN1"}, {"original_string": "private static final String CONN2 = \"sourceB\";", "modifier": "private static final", "type": "String", "declarator": "CONN2 = \"sourceB\"", "var_name": "CONN2"}, {"original_string": "private static final ConnectorTaskId TASK0 = new ConnectorTaskId(CONN1, 0);", "modifier": "private static final", "type": "ConnectorTaskId", "declarator": "TASK0 = new ConnectorTaskId(CONN1, 0)", "var_name": "TASK0"}, {"original_string": "private static final ConnectorTaskId TASK1 = new ConnectorTaskId(CONN1, 1);", "modifier": "private static final", "type": "ConnectorTaskId", "declarator": "TASK1 = new ConnectorTaskId(CONN1, 1)", "var_name": "TASK1"}, {"original_string": "private static final ConnectorTaskId TASK2 = new ConnectorTaskId(CONN1, 2);", "modifier": "private static final", "type": "ConnectorTaskId", "declarator": "TASK2 = new ConnectorTaskId(CONN1, 2)", "var_name": "TASK2"}, {"original_string": "private static final Integer MAX_TASKS = 3;", "modifier": "private static final", "type": "Integer", "declarator": "MAX_TASKS = 3", "var_name": "MAX_TASKS"}, {"original_string": "private static final Map<String, String> CONN1_CONFIG = new HashMap<>();", "modifier": "private static final", "type": "Map<String, String>", "declarator": "CONN1_CONFIG = new HashMap<>()", "var_name": "CONN1_CONFIG"}, {"original_string": "private static final Map<String, String> CONN1_CONFIG_UPDATED = new HashMap<>(CONN1_CONFIG);", "modifier": "private static final", "type": "Map<String, String>", "declarator": "CONN1_CONFIG_UPDATED = new HashMap<>(CONN1_CONFIG)", "var_name": "CONN1_CONFIG_UPDATED"}, {"original_string": "private static final Map<String, String> CONN2_CONFIG = new HashMap<>();", "modifier": "private static final", "type": "Map<String, String>", "declarator": "CONN2_CONFIG = new HashMap<>()", "var_name": "CONN2_CONFIG"}, {"original_string": "private static final Map<String, String> TASK_CONFIG = new HashMap<>();", "modifier": "private static final", "type": "Map<String, String>", "declarator": "TASK_CONFIG = new HashMap<>()", "var_name": "TASK_CONFIG"}, {"original_string": "private static final List<Map<String, String>> TASK_CONFIGS = new ArrayList<>();", "modifier": "private static final", "type": "List<Map<String, String>>", "declarator": "TASK_CONFIGS = new ArrayList<>()", "var_name": "TASK_CONFIGS"}, {"original_string": "private static final HashMap<ConnectorTaskId, Map<String, String>> TASK_CONFIGS_MAP = new HashMap<>();", "modifier": "private static final", "type": "HashMap<ConnectorTaskId, Map<String, String>>", "declarator": "TASK_CONFIGS_MAP = new HashMap<>()", "var_name": "TASK_CONFIGS_MAP"}, {"original_string": "private static final ClusterConfigState SNAPSHOT = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG), Collections.singletonMap(CONN1, TargetState.STARTED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet());", "modifier": "private static final", "type": "ClusterConfigState", "declarator": "SNAPSHOT = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG), Collections.singletonMap(CONN1, TargetState.STARTED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet())", "var_name": "SNAPSHOT"}, {"original_string": "private static final ClusterConfigState SNAPSHOT_PAUSED_CONN1 = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG), Collections.singletonMap(CONN1, TargetState.PAUSED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet());", "modifier": "private static final", "type": "ClusterConfigState", "declarator": "SNAPSHOT_PAUSED_CONN1 = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG), Collections.singletonMap(CONN1, TargetState.PAUSED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet())", "var_name": "SNAPSHOT_PAUSED_CONN1"}, {"original_string": "private static final ClusterConfigState SNAPSHOT_UPDATED_CONN1_CONFIG = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG_UPDATED), Collections.singletonMap(CONN1, TargetState.STARTED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet());", "modifier": "private static final", "type": "ClusterConfigState", "declarator": "SNAPSHOT_UPDATED_CONN1_CONFIG = new ClusterConfigState(1, Collections.singletonMap(CONN1, 3),\n            Collections.singletonMap(CONN1, CONN1_CONFIG_UPDATED), Collections.singletonMap(CONN1, TargetState.STARTED),\n            TASK_CONFIGS_MAP, Collections.<String>emptySet())", "var_name": "SNAPSHOT_UPDATED_CONN1_CONFIG"}, {"original_string": "private static final String WORKER_ID = \"localhost:8083\";", "modifier": "private static final", "type": "String", "declarator": "WORKER_ID = \"localhost:8083\"", "var_name": "WORKER_ID"}, {"original_string": "@Mock private KafkaConfigBackingStore configStorage;", "modifier": "@Mock private", "type": "KafkaConfigBackingStore", "declarator": "configStorage", "var_name": "configStorage"}, {"original_string": "@Mock private StatusBackingStore statusBackingStore;", "modifier": "@Mock private", "type": "StatusBackingStore", "declarator": "statusBackingStore", "var_name": "statusBackingStore"}, {"original_string": "@Mock private WorkerGroupMember member;", "modifier": "@Mock private", "type": "WorkerGroupMember", "declarator": "member", "var_name": "member"}, {"original_string": "private MockTime time;", "modifier": "private", "type": "MockTime", "declarator": "time", "var_name": "time"}, {"original_string": "private DistributedHerder herder;", "modifier": "private", "type": "DistributedHerder", "declarator": "herder", "var_name": "herder"}, {"original_string": "@Mock private Worker worker;", "modifier": "@Mock private", "type": "Worker", "declarator": "worker", "var_name": "worker"}, {"original_string": "@Mock private Callback<Herder.Created<ConnectorInfo>> putConnectorCallback;", "modifier": "@Mock private", "type": "Callback<Herder.Created<ConnectorInfo>>", "declarator": "putConnectorCallback", "var_name": "putConnectorCallback"}, {"original_string": "private ConfigBackingStore.UpdateListener configUpdateListener;", "modifier": "private", "type": "ConfigBackingStore.UpdateListener", "declarator": "configUpdateListener", "var_name": "configUpdateListener"}, {"original_string": "private WorkerRebalanceListener rebalanceListener;", "modifier": "private", "type": "WorkerRebalanceListener", "declarator": "rebalanceListener", "var_name": "rebalanceListener"}], "file": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/distributed/DistributedHerderTest.java"}, "test_case": {"identifier": "testPutConnectorConfig", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testPutConnectorConfig() throws Exception {\n        EasyMock.expect(member.memberId()).andStubReturn(\"leader\");\n        expectRebalance(1, Arrays.asList(CONN1), Collections.<ConnectorTaskId>emptyList());\n        expectPostRebalanceCatchup(SNAPSHOT);\n        worker.startConnector(EasyMock.<ConnectorConfig>anyObject(), EasyMock.<ConnectorContext>anyObject(),\n                EasyMock.eq(herder), EasyMock.eq(TargetState.STARTED));\n        PowerMock.expectLastCall();\n        EasyMock.expect(worker.isRunning(CONN1)).andReturn(true);\n        EasyMock.expect(worker.connectorTaskConfigs(CONN1, MAX_TASKS, null)).andReturn(TASK_CONFIGS);\n\n        // list connectors, get connector info, get connector config, get task configs\n        member.wakeup();\n        PowerMock.expectLastCall().anyTimes();\n        member.poll(EasyMock.anyInt());\n        PowerMock.expectLastCall();\n\n        // Poll loop for second round of calls\n        member.ensureActive();\n        PowerMock.expectLastCall();\n        configStorage.putConnectorConfig(CONN1, CONN1_CONFIG_UPDATED);\n        PowerMock.expectLastCall().andAnswer(new IAnswer<Object>() {\n            @Override\n            public Object answer() throws Throwable {\n                // Simulate response to writing config + waiting until end of log to be read\n                configUpdateListener.onConnectorConfigUpdate(CONN1);\n                return null;\n            }\n        });\n        // As a result of reconfig, should need to update snapshot. With only connector updates, we'll just restart\n        // connector without rebalance\n        EasyMock.expect(configStorage.snapshot()).andReturn(SNAPSHOT_UPDATED_CONN1_CONFIG);\n        worker.stopConnector(CONN1);\n        PowerMock.expectLastCall();\n        Capture<ConnectorConfig> capturedUpdatedConfig = EasyMock.newCapture();\n        worker.startConnector(EasyMock.capture(capturedUpdatedConfig), EasyMock.<ConnectorContext>anyObject(),\n                EasyMock.eq(herder), EasyMock.eq(TargetState.STARTED));\n        PowerMock.expectLastCall();\n        EasyMock.expect(worker.isRunning(CONN1)).andReturn(true);\n        EasyMock.expect(worker.connectorTaskConfigs(CONN1, MAX_TASKS, null)).andReturn(TASK_CONFIGS);\n\n        member.poll(EasyMock.anyInt());\n        PowerMock.expectLastCall();\n\n        // Third tick just to read the config\n        member.ensureActive();\n        PowerMock.expectLastCall();\n        member.poll(EasyMock.anyInt());\n        PowerMock.expectLastCall();\n\n        PowerMock.replayAll();\n\n        // Should pick up original config\n        FutureCallback<Map<String, String>> connectorConfigCb = new FutureCallback<>();\n        herder.connectorConfig(CONN1, connectorConfigCb);\n        herder.tick();\n        assertTrue(connectorConfigCb.isDone());\n        assertEquals(CONN1_CONFIG, connectorConfigCb.get());\n\n        // Apply new config.\n        FutureCallback<Herder.Created<ConnectorInfo>> putConfigCb = new FutureCallback<>();\n        herder.putConnectorConfig(CONN1, CONN1_CONFIG_UPDATED, true, putConfigCb);\n        herder.tick();\n        assertTrue(putConfigCb.isDone());\n        ConnectorInfo updatedInfo = new ConnectorInfo(CONN1, CONN1_CONFIG_UPDATED, Arrays.asList(TASK0, TASK1, TASK2));\n        assertEquals(new Herder.Created<>(false, updatedInfo), putConfigCb.get());\n\n        // Check config again to validate change\n        connectorConfigCb = new FutureCallback<>();\n        herder.connectorConfig(CONN1, connectorConfigCb);\n        herder.tick();\n        assertTrue(connectorConfigCb.isDone());\n        assertEquals(CONN1_CONFIG_UPDATED, connectorConfigCb.get());\n        PowerMock.verifyAll();\n    }", "signature": "void testPutConnectorConfig()", "full_signature": "@Test public void testPutConnectorConfig()", "class_method_signature": "DistributedHerderTest.testPutConnectorConfig()", "testcase": true, "constructor": false, "invocations": ["andStubReturn", "expect", "memberId", "expectRebalance", "asList", "emptyList", "expectPostRebalanceCatchup", "startConnector", "anyObject", "anyObject", "eq", "eq", "expectLastCall", "andReturn", "expect", "isRunning", "andReturn", "expect", "connectorTaskConfigs", "wakeup", "anyTimes", "expectLastCall", "poll", "anyInt", "expectLastCall", "ensureActive", "expectLastCall", "putConnectorConfig", "andAnswer", "expectLastCall", "onConnectorConfigUpdate", "andReturn", "expect", "snapshot", "stopConnector", "expectLastCall", "newCapture", "startConnector", "capture", "anyObject", "eq", "eq", "expectLastCall", "andReturn", "expect", "isRunning", "andReturn", "expect", "connectorTaskConfigs", "poll", "anyInt", "expectLastCall", "ensureActive", "expectLastCall", "poll", "anyInt", "expectLastCall", "replayAll", "connectorConfig", "tick", "assertTrue", "isDone", "assertEquals", "get", "putConnectorConfig", "tick", "assertTrue", "isDone", "asList", "assertEquals", "get", "connectorConfig", "tick", "assertTrue", "isDone", "assertEquals", "get", "verifyAll"]}, "focal_class": {"identifier": "DistributedHerder", "superclass": "extends AbstractHerder", "interfaces": "implements Runnable", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(DistributedHerder.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(DistributedHerder.class)", "var_name": "log"}, {"original_string": "private static final long RECONFIGURE_CONNECTOR_TASKS_BACKOFF_MS = 250;", "modifier": "private static final", "type": "long", "declarator": "RECONFIGURE_CONNECTOR_TASKS_BACKOFF_MS = 250", "var_name": "RECONFIGURE_CONNECTOR_TASKS_BACKOFF_MS"}, {"original_string": "private final Time time;", "modifier": "private final", "type": "Time", "declarator": "time", "var_name": "time"}, {"original_string": "private final int workerSyncTimeoutMs;", "modifier": "private final", "type": "int", "declarator": "workerSyncTimeoutMs", "var_name": "workerSyncTimeoutMs"}, {"original_string": "private final int workerUnsyncBackoffMs;", "modifier": "private final", "type": "int", "declarator": "workerUnsyncBackoffMs", "var_name": "workerUnsyncBackoffMs"}, {"original_string": "private final ExecutorService forwardRequestExecutor;", "modifier": "private final", "type": "ExecutorService", "declarator": "forwardRequestExecutor", "var_name": "forwardRequestExecutor"}, {"original_string": "private final WorkerGroupMember member;", "modifier": "private final", "type": "WorkerGroupMember", "declarator": "member", "var_name": "member"}, {"original_string": "private final AtomicBoolean stopping;", "modifier": "private final", "type": "AtomicBoolean", "declarator": "stopping", "var_name": "stopping"}, {"original_string": "private final CountDownLatch stopLatch = new CountDownLatch(1);", "modifier": "private final", "type": "CountDownLatch", "declarator": "stopLatch = new CountDownLatch(1)", "var_name": "stopLatch"}, {"original_string": "private boolean rebalanceResolved;", "modifier": "private", "type": "boolean", "declarator": "rebalanceResolved", "var_name": "rebalanceResolved"}, {"original_string": "private ConnectProtocol.Assignment assignment;", "modifier": "private", "type": "ConnectProtocol.Assignment", "declarator": "assignment", "var_name": "assignment"}, {"original_string": "private boolean canReadConfigs;", "modifier": "private", "type": "boolean", "declarator": "canReadConfigs", "var_name": "canReadConfigs"}, {"original_string": "private ClusterConfigState configState;", "modifier": "private", "type": "ClusterConfigState", "declarator": "configState", "var_name": "configState"}, {"original_string": "private final Queue<HerderRequest> requests = new PriorityQueue<>();", "modifier": "private final", "type": "Queue<HerderRequest>", "declarator": "requests = new PriorityQueue<>()", "var_name": "requests"}, {"original_string": "private Set<String> connectorConfigUpdates = new HashSet<>();", "modifier": "private", "type": "Set<String>", "declarator": "connectorConfigUpdates = new HashSet<>()", "var_name": "connectorConfigUpdates"}, {"original_string": "private Set<String> connectorTargetStateChanges = new HashSet<>();", "modifier": "private", "type": "Set<String>", "declarator": "connectorTargetStateChanges = new HashSet<>()", "var_name": "connectorTargetStateChanges"}, {"original_string": "private boolean needsReconfigRebalance;", "modifier": "private", "type": "boolean", "declarator": "needsReconfigRebalance", "var_name": "needsReconfigRebalance"}, {"original_string": "private volatile int generation;", "modifier": "private volatile", "type": "int", "declarator": "generation", "var_name": "generation"}], "methods": [{"identifier": "DistributedHerder", "parameters": "(DistributedConfig config,\n                             Time time,\n                             Worker worker,\n                             StatusBackingStore statusBackingStore,\n                             ConfigBackingStore configBackingStore,\n                             String restUrl)", "modifiers": "public", "return": "", "signature": " DistributedHerder(DistributedConfig config,\n                             Time time,\n                             Worker worker,\n                             StatusBackingStore statusBackingStore,\n                             ConfigBackingStore configBackingStore,\n                             String restUrl)", "full_signature": "public  DistributedHerder(DistributedConfig config,\n                             Time time,\n                             Worker worker,\n                             StatusBackingStore statusBackingStore,\n                             ConfigBackingStore configBackingStore,\n                             String restUrl)", "class_method_signature": "DistributedHerder.DistributedHerder(DistributedConfig config,\n                             Time time,\n                             Worker worker,\n                             StatusBackingStore statusBackingStore,\n                             ConfigBackingStore configBackingStore,\n                             String restUrl)", "testcase": false, "constructor": true}, {"identifier": "DistributedHerder", "parameters": "(DistributedConfig config,\n                      Worker worker,\n                      String workerId,\n                      StatusBackingStore statusBackingStore,\n                      ConfigBackingStore configStorage,\n                      WorkerGroupMember member,\n                      String restUrl,\n                      Time time)", "modifiers": "", "return": "", "signature": " DistributedHerder(DistributedConfig config,\n                      Worker worker,\n                      String workerId,\n                      StatusBackingStore statusBackingStore,\n                      ConfigBackingStore configStorage,\n                      WorkerGroupMember member,\n                      String restUrl,\n                      Time time)", "full_signature": "  DistributedHerder(DistributedConfig config,\n                      Worker worker,\n                      String workerId,\n                      StatusBackingStore statusBackingStore,\n                      ConfigBackingStore configStorage,\n                      WorkerGroupMember member,\n                      String restUrl,\n                      Time time)", "class_method_signature": "DistributedHerder.DistributedHerder(DistributedConfig config,\n                      Worker worker,\n                      String workerId,\n                      StatusBackingStore statusBackingStore,\n                      ConfigBackingStore configStorage,\n                      WorkerGroupMember member,\n                      String restUrl,\n                      Time time)", "testcase": false, "constructor": true}, {"identifier": "start", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void start()", "full_signature": "@Override public void start()", "class_method_signature": "DistributedHerder.start()", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void run()", "full_signature": "@Override public void run()", "class_method_signature": "DistributedHerder.run()", "testcase": false, "constructor": false}, {"identifier": "tick", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void tick()", "full_signature": "public void tick()", "class_method_signature": "DistributedHerder.tick()", "testcase": false, "constructor": false}, {"identifier": "processConnectorConfigUpdates", "parameters": "(Set<String> connectorConfigUpdates)", "modifiers": "private", "return": "void", "signature": "void processConnectorConfigUpdates(Set<String> connectorConfigUpdates)", "full_signature": "private void processConnectorConfigUpdates(Set<String> connectorConfigUpdates)", "class_method_signature": "DistributedHerder.processConnectorConfigUpdates(Set<String> connectorConfigUpdates)", "testcase": false, "constructor": false}, {"identifier": "processTargetStateChanges", "parameters": "(Set<String> connectorTargetStateChanges)", "modifiers": "private", "return": "void", "signature": "void processTargetStateChanges(Set<String> connectorTargetStateChanges)", "full_signature": "private void processTargetStateChanges(Set<String> connectorTargetStateChanges)", "class_method_signature": "DistributedHerder.processTargetStateChanges(Set<String> connectorTargetStateChanges)", "testcase": false, "constructor": false}, {"identifier": "halt", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void halt()", "full_signature": "public void halt()", "class_method_signature": "DistributedHerder.halt()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void stop()", "full_signature": "@Override public void stop()", "class_method_signature": "DistributedHerder.stop()", "testcase": false, "constructor": false}, {"identifier": "connectors", "parameters": "(final Callback<Collection<String>> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void connectors(final Callback<Collection<String>> callback)", "full_signature": "@Override public synchronized void connectors(final Callback<Collection<String>> callback)", "class_method_signature": "DistributedHerder.connectors(final Callback<Collection<String>> callback)", "testcase": false, "constructor": false}, {"identifier": "connectorInfo", "parameters": "(final String connName, final Callback<ConnectorInfo> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void connectorInfo(final String connName, final Callback<ConnectorInfo> callback)", "full_signature": "@Override public synchronized void connectorInfo(final String connName, final Callback<ConnectorInfo> callback)", "class_method_signature": "DistributedHerder.connectorInfo(final String connName, final Callback<ConnectorInfo> callback)", "testcase": false, "constructor": false}, {"identifier": "connectorConfig", "parameters": "(String connName, final Callback<Map<String, String>> callback)", "modifiers": "@Override public", "return": "void", "signature": "void connectorConfig(String connName, final Callback<Map<String, String>> callback)", "full_signature": "@Override public void connectorConfig(String connName, final Callback<Map<String, String>> callback)", "class_method_signature": "DistributedHerder.connectorConfig(String connName, final Callback<Map<String, String>> callback)", "testcase": false, "constructor": false}, {"identifier": "putConnectorConfig", "parameters": "(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "modifiers": "@Override public", "return": "void", "signature": "void putConnectorConfig(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "full_signature": "@Override public void putConnectorConfig(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "class_method_signature": "DistributedHerder.putConnectorConfig(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "testcase": false, "constructor": false}, {"identifier": "requestTaskReconfiguration", "parameters": "(final String connName)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void requestTaskReconfiguration(final String connName)", "full_signature": "@Override public synchronized void requestTaskReconfiguration(final String connName)", "class_method_signature": "DistributedHerder.requestTaskReconfiguration(final String connName)", "testcase": false, "constructor": false}, {"identifier": "taskConfigs", "parameters": "(final String connName, final Callback<List<TaskInfo>> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void taskConfigs(final String connName, final Callback<List<TaskInfo>> callback)", "full_signature": "@Override public synchronized void taskConfigs(final String connName, final Callback<List<TaskInfo>> callback)", "class_method_signature": "DistributedHerder.taskConfigs(final String connName, final Callback<List<TaskInfo>> callback)", "testcase": false, "constructor": false}, {"identifier": "putTaskConfigs", "parameters": "(final String connName, final List<Map<String, String>> configs, final Callback<Void> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void putTaskConfigs(final String connName, final List<Map<String, String>> configs, final Callback<Void> callback)", "full_signature": "@Override public synchronized void putTaskConfigs(final String connName, final List<Map<String, String>> configs, final Callback<Void> callback)", "class_method_signature": "DistributedHerder.putTaskConfigs(final String connName, final List<Map<String, String>> configs, final Callback<Void> callback)", "testcase": false, "constructor": false}, {"identifier": "restartConnector", "parameters": "(final String connName, final Callback<Void> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void restartConnector(final String connName, final Callback<Void> callback)", "full_signature": "@Override public synchronized void restartConnector(final String connName, final Callback<Void> callback)", "class_method_signature": "DistributedHerder.restartConnector(final String connName, final Callback<Void> callback)", "testcase": false, "constructor": false}, {"identifier": "restartTask", "parameters": "(final ConnectorTaskId id, final Callback<Void> callback)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void restartTask(final ConnectorTaskId id, final Callback<Void> callback)", "full_signature": "@Override public synchronized void restartTask(final ConnectorTaskId id, final Callback<Void> callback)", "class_method_signature": "DistributedHerder.restartTask(final ConnectorTaskId id, final Callback<Void> callback)", "testcase": false, "constructor": false}, {"identifier": "generation", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int generation()", "full_signature": "@Override public int generation()", "class_method_signature": "DistributedHerder.generation()", "testcase": false, "constructor": false}, {"identifier": "isLeader", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean isLeader()", "full_signature": "private boolean isLeader()", "class_method_signature": "DistributedHerder.isLeader()", "testcase": false, "constructor": false}, {"identifier": "leaderUrl", "parameters": "()", "modifiers": "private", "return": "String", "signature": "String leaderUrl()", "full_signature": "private String leaderUrl()", "class_method_signature": "DistributedHerder.leaderUrl()", "testcase": false, "constructor": false}, {"identifier": "handleRebalanceCompleted", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean handleRebalanceCompleted()", "full_signature": "private boolean handleRebalanceCompleted()", "class_method_signature": "DistributedHerder.handleRebalanceCompleted()", "testcase": false, "constructor": false}, {"identifier": "readConfigToEnd", "parameters": "(long timeoutMs)", "modifiers": "private", "return": "boolean", "signature": "boolean readConfigToEnd(long timeoutMs)", "full_signature": "private boolean readConfigToEnd(long timeoutMs)", "class_method_signature": "DistributedHerder.readConfigToEnd(long timeoutMs)", "testcase": false, "constructor": false}, {"identifier": "backoff", "parameters": "(long ms)", "modifiers": "private", "return": "void", "signature": "void backoff(long ms)", "full_signature": "private void backoff(long ms)", "class_method_signature": "DistributedHerder.backoff(long ms)", "testcase": false, "constructor": false}, {"identifier": "startWork", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void startWork()", "full_signature": "private void startWork()", "class_method_signature": "DistributedHerder.startWork()", "testcase": false, "constructor": false}, {"identifier": "startTask", "parameters": "(ConnectorTaskId taskId)", "modifiers": "private", "return": "void", "signature": "void startTask(ConnectorTaskId taskId)", "full_signature": "private void startTask(ConnectorTaskId taskId)", "class_method_signature": "DistributedHerder.startTask(ConnectorTaskId taskId)", "testcase": false, "constructor": false}, {"identifier": "startConnector", "parameters": "(String connectorName)", "modifiers": "private", "return": "void", "signature": "void startConnector(String connectorName)", "full_signature": "private void startConnector(String connectorName)", "class_method_signature": "DistributedHerder.startConnector(String connectorName)", "testcase": false, "constructor": false}, {"identifier": "reconfigureConnectorTasksWithRetry", "parameters": "(final String connName)", "modifiers": "private", "return": "void", "signature": "void reconfigureConnectorTasksWithRetry(final String connName)", "full_signature": "private void reconfigureConnectorTasksWithRetry(final String connName)", "class_method_signature": "DistributedHerder.reconfigureConnectorTasksWithRetry(final String connName)", "testcase": false, "constructor": false}, {"identifier": "reconfigureConnector", "parameters": "(final String connName, final Callback<Void> cb)", "modifiers": "private", "return": "void", "signature": "void reconfigureConnector(final String connName, final Callback<Void> cb)", "full_signature": "private void reconfigureConnector(final String connName, final Callback<Void> cb)", "class_method_signature": "DistributedHerder.reconfigureConnector(final String connName, final Callback<Void> cb)", "testcase": false, "constructor": false}, {"identifier": "checkRebalanceNeeded", "parameters": "(Callback<?> callback)", "modifiers": "private", "return": "boolean", "signature": "boolean checkRebalanceNeeded(Callback<?> callback)", "full_signature": "private boolean checkRebalanceNeeded(Callback<?> callback)", "class_method_signature": "DistributedHerder.checkRebalanceNeeded(Callback<?> callback)", "testcase": false, "constructor": false}, {"identifier": "addRequest", "parameters": "(Callable<Void> action, Callback<Void> callback)", "modifiers": "private", "return": "void", "signature": "void addRequest(Callable<Void> action, Callback<Void> callback)", "full_signature": "private void addRequest(Callable<Void> action, Callback<Void> callback)", "class_method_signature": "DistributedHerder.addRequest(Callable<Void> action, Callback<Void> callback)", "testcase": false, "constructor": false}, {"identifier": "addRequest", "parameters": "(long delayMs, Callable<Void> action, Callback<Void> callback)", "modifiers": "private", "return": "void", "signature": "void addRequest(long delayMs, Callable<Void> action, Callback<Void> callback)", "full_signature": "private void addRequest(long delayMs, Callable<Void> action, Callback<Void> callback)", "class_method_signature": "DistributedHerder.addRequest(long delayMs, Callable<Void> action, Callback<Void> callback)", "testcase": false, "constructor": false}, {"identifier": "forwardErrorCallback", "parameters": "(final Callback<?> callback)", "modifiers": "private static final", "return": "Callback<Void>", "signature": "Callback<Void> forwardErrorCallback(final Callback<?> callback)", "full_signature": "private static final Callback<Void> forwardErrorCallback(final Callback<?> callback)", "class_method_signature": "DistributedHerder.forwardErrorCallback(final Callback<?> callback)", "testcase": false, "constructor": false}, {"identifier": "updateDeletedConnectorStatus", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void updateDeletedConnectorStatus()", "full_signature": "private void updateDeletedConnectorStatus()", "class_method_signature": "DistributedHerder.updateDeletedConnectorStatus()", "testcase": false, "constructor": false}], "file": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java"}, "focal_method": {"identifier": "putConnectorConfig", "parameters": "(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void putConnectorConfig(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback) {\n        log.trace(\"Submitting connector config write request {}\", connName);\n\n        addRequest(\n                new Callable<Void>() {\n                    @Override\n                    public Void call() throws Exception {\n                        log.trace(\"Handling connector config request {}\", connName);\n                        if (!isLeader()) {\n                            callback.onCompletion(new NotLeaderException(\"Only the leader can set connector configs.\", leaderUrl()), null);\n                            return null;\n                        }\n\n                        boolean exists = configState.contains(connName);\n                        if (!allowReplace && exists) {\n                            callback.onCompletion(new AlreadyExistsException(\"Connector \" + connName + \" already exists\"), null);\n                            return null;\n                        }\n\n                        if (config == null) {\n                            if (!exists) {\n                                callback.onCompletion(new NotFoundException(\"Connector \" + connName + \" not found\"), null);\n                            } else {\n                                log.trace(\"Removing connector config {} {} {}\", connName, allowReplace, configState.connectors());\n                                configBackingStore.removeConnectorConfig(connName);\n                                callback.onCompletion(null, new Created<ConnectorInfo>(false, null));\n                            }\n                            return null;\n                        }\n\n                        log.trace(\"Submitting connector config {} {} {}\", connName, allowReplace, configState.connectors());\n                        configBackingStore.putConnectorConfig(connName, config);\n\n                        // Note that we use the updated connector config despite the fact that we don't have an updated\n                        // snapshot yet. The existing task info should still be accurate.\n                        ConnectorInfo info = new ConnectorInfo(connName, config, configState.tasks(connName));\n                        callback.onCompletion(null, new Created<>(!exists, info));\n                        return null;\n                    }\n                },\n                forwardErrorCallback(callback)\n        );\n    }", "signature": "void putConnectorConfig(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "full_signature": "@Override public void putConnectorConfig(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "class_method_signature": "DistributedHerder.putConnectorConfig(final String connName, final Map<String, String> config, final boolean allowReplace,\n                                   final Callback<Created<ConnectorInfo>> callback)", "testcase": false, "constructor": false, "invocations": ["trace", "addRequest", "trace", "isLeader", "onCompletion", "leaderUrl", "contains", "onCompletion", "onCompletion", "trace", "connectors", "removeConnectorConfig", "onCompletion", "trace", "connectors", "putConnectorConfig", "tasks", "onCompletion", "forwardErrorCallback"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}