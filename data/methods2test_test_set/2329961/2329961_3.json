{"test_class": {"identifier": "NodeCollectionWatcherTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static TestingCluster zkServer;", "modifier": "private static", "type": "TestingCluster", "declarator": "zkServer", "var_name": "zkServer"}, {"original_string": "private static CuratorFramework curator;", "modifier": "private static", "type": "CuratorFramework", "declarator": "curator", "var_name": "curator"}, {"original_string": "private static ZooKeeper zooKeeper;", "modifier": "private static", "type": "ZooKeeper", "declarator": "zooKeeper", "var_name": "zooKeeper"}, {"original_string": "private final AtomicInteger counter = new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "counter = new AtomicInteger(0)", "var_name": "counter"}], "file": "cn-zookeeper/src/test/java/org/cloudname/backends/zookeeper/NodeCollectionWatcherTest.java"}, "test_case": {"identifier": "misbehavingClient", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void misbehavingClient() throws Exception {\n        final int propagationTime = 5;\n\n        final AtomicBoolean triggerExceptions = new AtomicBoolean(false);\n        final CountDownLatch createLatch = new CountDownLatch(1);\n        final CountDownLatch dataLatch = new CountDownLatch(1);\n        final CountDownLatch removeLatch = new CountDownLatch(1);\n\n        final NodeWatcherListener listener = new NodeWatcherListener() {\n            @Override\n            public void nodeCreated(String zkPath, String data) {\n                if (triggerExceptions.get()) {\n                    throw new RuntimeException(\"boo!\");\n                }\n                createLatch.countDown();\n            }\n\n            @Override\n            public void dataChanged(String zkPath, String data) {\n                if (triggerExceptions.get()) {\n                    throw new RuntimeException(\"boo!\");\n                }\n                dataLatch.countDown();\n            }\n\n            @Override\n            public void nodeRemoved(String zkPath) {\n                if (triggerExceptions.get()) {\n                    throw new RuntimeException(\"boo!\");\n                }\n                removeLatch.countDown();\n            }\n        };\n\n        final String pathPrefix = \"/foo/misbehaving\";\n\n        curator.create().creatingParentsIfNeeded().forPath(pathPrefix);\n\n        final NodeCollectionWatcher nodeCollectionWatcher = new NodeCollectionWatcher(zooKeeper, pathPrefix, listener);\n\n        triggerExceptions.set(true);\n        curator.create().forPath(pathPrefix + \"/first\", getData());\n        Thread.sleep(propagationTime);\n        curator.setData().forPath(pathPrefix + \"/first\", getData());\n        Thread.sleep(propagationTime);\n        curator.delete().forPath(pathPrefix + \"/first\");\n        Thread.sleep(propagationTime);\n\n        // Now create a node but without setting the data field.\n        triggerExceptions.set(false);\n        curator.create().forPath(pathPrefix + \"/second\");\n        assertTrue(createLatch.await(propagationTime, TimeUnit.MILLISECONDS));\n        curator.setData().forPath(pathPrefix + \"/second\", getData());\n        assertTrue(dataLatch.await(propagationTime, TimeUnit.MILLISECONDS));\n        curator.delete().forPath(pathPrefix + \"/second\");\n        assertTrue(removeLatch.await(propagationTime, TimeUnit.MILLISECONDS));\n\n        nodeCollectionWatcher.shutdown();\n    }", "signature": "void misbehavingClient()", "full_signature": "@Test public void misbehavingClient()", "class_method_signature": "NodeCollectionWatcherTest.misbehavingClient()", "testcase": true, "constructor": false, "invocations": ["get", "countDown", "get", "countDown", "get", "countDown", "forPath", "creatingParentsIfNeeded", "create", "set", "forPath", "create", "getData", "sleep", "forPath", "setData", "getData", "sleep", "forPath", "delete", "sleep", "set", "forPath", "create", "assertTrue", "await", "forPath", "setData", "getData", "assertTrue", "await", "forPath", "delete", "assertTrue", "await", "shutdown"]}, "focal_class": {"identifier": "NodeCollectionWatcher", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = Logger.getLogger(NodeCollectionWatcher.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(NodeCollectionWatcher.class.getName())", "var_name": "LOG"}, {"original_string": "private final Map<String, Long> childMzxid = new HashMap<>();", "modifier": "private final", "type": "Map<String, Long>", "declarator": "childMzxid = new HashMap<>()", "var_name": "childMzxid"}, {"original_string": "private final Object syncObject = new Object();", "modifier": "private final", "type": "Object", "declarator": "syncObject = new Object()", "var_name": "syncObject"}, {"original_string": "private final ZooKeeper zk;", "modifier": "private final", "type": "ZooKeeper", "declarator": "zk", "var_name": "zk"}, {"original_string": "private final String pathToWatch;", "modifier": "private final", "type": "String", "declarator": "pathToWatch", "var_name": "pathToWatch"}, {"original_string": "private final AtomicBoolean shuttingDown = new AtomicBoolean(false);", "modifier": "private final", "type": "AtomicBoolean", "declarator": "shuttingDown = new AtomicBoolean(false)", "var_name": "shuttingDown"}, {"original_string": "private final NodeWatcherListener listener;", "modifier": "private final", "type": "NodeWatcherListener", "declarator": "listener", "var_name": "listener"}, {"original_string": "private final Watcher nodeCollectionWatcher = (watchedEvent) -> {\n        switch (watchedEvent.getType()) {\n            case NodeChildrenChanged:\n                // Child values have changed, read children, generate events\n                readChildNodes();\n                break;\n            case None:\n                // Some zookeeper event. Watches might not apply anymore. Reapply.\n                switch (watchedEvent.getState()) {\n                    case ConnectedReadOnly:\n                        LOG.severe(\"Connected to readonly cluster\");\n                        // Connected to a cluster without quorum. Nodes might not be\n                        // correct but re-read the nodes.\n                        readChildNodes();\n                        break;\n                    case SyncConnected:\n                        LOG.info(\"Connected to cluster\");\n                        // (re-)Connected to the cluster. Nodes must be re-read. Discard\n                        // those that aren't found, keep unchanged ones.\n                        readChildNodes();\n                        break;\n                    case Disconnected:\n                        // Disconnected from the cluster. The nodes might not be\n                        // up to date (but a reconnect might solve the issue)\n                        LOG.log(Level.WARNING, \"Disconnected from zk cluster\");\n                        break;\n                    case Expired:\n                        // Session has expired. Nodes are no longer available\n                        removeAllChildNodes();\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            default:\n                break;\n        }\n    };", "modifier": "private final", "type": "Watcher", "declarator": "nodeCollectionWatcher = (watchedEvent) -> {\n        switch (watchedEvent.getType()) {\n            case NodeChildrenChanged:\n                // Child values have changed, read children, generate events\n                readChildNodes();\n                break;\n            case None:\n                // Some zookeeper event. Watches might not apply anymore. Reapply.\n                switch (watchedEvent.getState()) {\n                    case ConnectedReadOnly:\n                        LOG.severe(\"Connected to readonly cluster\");\n                        // Connected to a cluster without quorum. Nodes might not be\n                        // correct but re-read the nodes.\n                        readChildNodes();\n                        break;\n                    case SyncConnected:\n                        LOG.info(\"Connected to cluster\");\n                        // (re-)Connected to the cluster. Nodes must be re-read. Discard\n                        // those that aren't found, keep unchanged ones.\n                        readChildNodes();\n                        break;\n                    case Disconnected:\n                        // Disconnected from the cluster. The nodes might not be\n                        // up to date (but a reconnect might solve the issue)\n                        LOG.log(Level.WARNING, \"Disconnected from zk cluster\");\n                        break;\n                    case Expired:\n                        // Session has expired. Nodes are no longer available\n                        removeAllChildNodes();\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            default:\n                break;\n        }\n    }", "var_name": "nodeCollectionWatcher"}, {"original_string": "private final Watcher changeWatcher = (watchedEvent) -> {\n        if (shuttingDown.get()) {\n            return;\n        }\n        switch (watchedEvent.getType()) {\n            case NodeDeleted:\n                removeChildNode(watchedEvent.getPath());\n                break;\n            case NodeDataChanged:\n                processNode(watchedEvent.getPath());\n                break;\n            default:\n                break;\n        }\n    };", "modifier": "private final", "type": "Watcher", "declarator": "changeWatcher = (watchedEvent) -> {\n        if (shuttingDown.get()) {\n            return;\n        }\n        switch (watchedEvent.getType()) {\n            case NodeDeleted:\n                removeChildNode(watchedEvent.getPath());\n                break;\n            case NodeDataChanged:\n                processNode(watchedEvent.getPath());\n                break;\n            default:\n                break;\n        }\n    }", "var_name": "changeWatcher"}], "methods": [{"identifier": "NodeCollectionWatcher", "parameters": "(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "modifiers": "public", "return": "", "signature": " NodeCollectionWatcher(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "full_signature": "public  NodeCollectionWatcher(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "class_method_signature": "NodeCollectionWatcher.NodeCollectionWatcher(\n            final ZooKeeper zk, final String pathToWatch, final NodeWatcherListener listener)", "testcase": false, "constructor": true}, {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "NodeCollectionWatcher.shutdown()", "testcase": false, "constructor": false}, {"identifier": "removeAllChildNodes", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void removeAllChildNodes()", "full_signature": "private void removeAllChildNodes()", "class_method_signature": "NodeCollectionWatcher.removeAllChildNodes()", "testcase": false, "constructor": false}, {"identifier": "readChildNodes", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void readChildNodes()", "full_signature": "private void readChildNodes()", "class_method_signature": "NodeCollectionWatcher.readChildNodes()", "testcase": false, "constructor": false}, {"identifier": "processNode", "parameters": "(final String nodePath)", "modifiers": "private", "return": "void", "signature": "void processNode(final String nodePath)", "full_signature": "private void processNode(final String nodePath)", "class_method_signature": "NodeCollectionWatcher.processNode(final String nodePath)", "testcase": false, "constructor": false}, {"identifier": "removeChildNode", "parameters": "(final String nodePath)", "modifiers": "private", "return": "void", "signature": "void removeChildNode(final String nodePath)", "full_signature": "private void removeChildNode(final String nodePath)", "class_method_signature": "NodeCollectionWatcher.removeChildNode(final String nodePath)", "testcase": false, "constructor": false}, {"identifier": "generateCreateEvent", "parameters": "(final String nodePath, final String data)", "modifiers": "private", "return": "void", "signature": "void generateCreateEvent(final String nodePath, final String data)", "full_signature": "private void generateCreateEvent(final String nodePath, final String data)", "class_method_signature": "NodeCollectionWatcher.generateCreateEvent(final String nodePath, final String data)", "testcase": false, "constructor": false}, {"identifier": "generateDataChangeEvent", "parameters": "(final String nodePath, final String data)", "modifiers": "private", "return": "void", "signature": "void generateDataChangeEvent(final String nodePath, final String data)", "full_signature": "private void generateDataChangeEvent(final String nodePath, final String data)", "class_method_signature": "NodeCollectionWatcher.generateDataChangeEvent(final String nodePath, final String data)", "testcase": false, "constructor": false}, {"identifier": "generateRemoveEvent", "parameters": "(final String nodePath)", "modifiers": "private", "return": "void", "signature": "void generateRemoveEvent(final String nodePath)", "full_signature": "private void generateRemoveEvent(final String nodePath)", "class_method_signature": "NodeCollectionWatcher.generateRemoveEvent(final String nodePath)", "testcase": false, "constructor": false}], "file": "cn-zookeeper/src/main/java/org/cloudname/backends/zookeeper/NodeCollectionWatcher.java"}, "focal_method": {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void shutdown() {\n        shuttingDown.set(true);\n    }", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "NodeCollectionWatcher.shutdown()", "testcase": false, "constructor": false, "invocations": ["set"]}, "repository": {"repo_id": 2329961, "url": "https://github.com/Cloudname/cloudname", "language": "Java", "is_fork": false, "fork_count": 23, "stargazer_count": 21, "size": 26031, "license": "licensed"}}