{"test_class": {"identifier": "OAuthCertBoundJwtAccessTokenAuthorityTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final ClassLoader classLoader = this.getClass().getClassLoader();", "modifier": "private final", "type": "ClassLoader", "declarator": "classLoader = this.getClass().getClassLoader()", "var_name": "classLoader"}, {"original_string": "private X509Certificate[] clientCertChain = null;", "modifier": "private", "type": "X509Certificate[]", "declarator": "clientCertChain = null", "var_name": "clientCertChain"}, {"original_string": "private String jwtPublicKey = null;", "modifier": "private", "type": "String", "declarator": "jwtPublicKey = null", "var_name": "jwtPublicKey"}, {"original_string": "private final KeyStore baseKeyStore = new KeyStore() {\n        public String getPublicKey(String domain, String service, String keyId) {\n            return jwtPublicKey;\n        }\n    };", "modifier": "private final", "type": "KeyStore", "declarator": "baseKeyStore = new KeyStore() {\n        public String getPublicKey(String domain, String service, String keyId) {\n            return jwtPublicKey;\n        }\n    }", "var_name": "baseKeyStore"}], "file": "libs/java/auth_core/src/test/java/com/yahoo/athenz/auth/oauth/OAuthCertBoundJwtAccessTokenAuthorityTest.java"}, "test_case": {"identifier": "testAuthenticate", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testAuthenticate() {\n        String expiredJwt = \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImtleUlkIn0.eyJzdWIiOiJ1c2VyLmFkbWluIiwiaXNzIjoic3lzLmF1dGgudGVzdElkUCIsImF1ZCI6Imh0dHBzOi8vem1zLmF0aGVuei5pbyIsInNjb3BlIjoic3lzLmF1dGg6cm9sZS5hZG1pbiIsImNsaWVudF9pZCI6InVpLmF0aGVuei5pbyIsImlhdCI6MTUxNjIzOTAyMiwiZXhwIjoxNTE2MjM5MDIyfQ.cMbo1Ogwz3HTGdfncjBn3H99ehe_yT1Zhlb8vmDqvPnbjuZUnuFl3aZEIE_JyLQrGADZf9PFlqxMNQcd_AlrZ-SePW8u4kIe1mFBr6oSTzuBkLzpwlff_vWaoOGlXrjlai64ISaDXYaYFPxnNMhjFSpod6D_anaQqs3XXEqrlwHHG7zk99UvPZehtXntKcAv0it8K5_7-vtQiEqHIvy14oxLNhQa801bhaUvjgnSVhnQzfXTCYzM4B1QfF1Cp7k9ktw3tsOShZGYHYr-XOvO_199z0ZJfWkdqk_FA3Mdo_Nw_r9ghh2kCx5YhmNpaqN9BANmwv3PbREcfIt1o4V7ZTHSzBq2cuCjEmU59Nl530tUMe31npw-8i6MIGzE_Ifg4k5ea1L1JBzQkbtWeIVd8SV3j_D0TNhYmeeAYgK8UikkFIw3Uza6ZvfZKTe8cffomzzfeB5fjL9GUsqj6LpIL1R2CgCQARqlZDGl9d73j81G7r7qZPZuBW5U3c3cPrdChw1-AwgDT27-Hu3yAzxZyJmsfIkUj5VZZfb1loIsovcRr_h9VUeNEqMimKfwxRBr7EP7fw7eRQoAJIthdeMGS6hfh-ZPM85N2YN34aQ0YJKWJUgdLudCGpkmfYBBd28D1VGNTUlfEuwHXosVP1GoYLXlz8zgwWIoXuk_bj4QH-g\";\n        String noExpJwt = \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImtleUlkIn0.eyJzdWIiOiJ1c2VyLmFkbWluIiwiaXNzIjoic3lzLmF1dGgudGVzdElkUCIsImF1ZCI6Imh0dHBzOi8vem1zLmF0aGVuei5pbyIsInNjb3BlIjoic3lzLmF1dGg6cm9sZS5hZG1pbiIsImNsaWVudF9pZCI6InVpLmF0aGVuei5pbyIsImlhdCI6MTUxNjIzOTAyMn0.I8da4Q_SysUJ3O4VZQQb7v0tQHNaAWk7WGkC3AImhd6FK_g6wAFe4Nw7K5ofOCdJKjHGUmqgBpnt1vbOqia8UJhcKkByBXywVnbK655MQ3ogkBmi3tUPx6Dmq1dwiaxsVZMAnxFQeACcTEz_Q_BWiXJqSpUP0vBy2sOFTus_xmvcooewu7n-EgdrO26oYwCMp0IARaSZq6hRmF5Le4wyz8d8CEzIArjEBOBpbONsX3NOvPSox3whDvIk91Zy4ZsORAMoLgGSQTqrEYBLSsFwng01V_OW4JVfM2p9f3U2gpqF6Ja7FFXrxnrgXEjvLvcMQYgv21eTT7ELMMFFQaYLPcCXNDoGwPOOU0dxngqw9B9qqhZV-gTJ7w5ADH2knwqNN5EJxnflVU_D-dUZFNJ0ruMc3bfsLzXQhhHqdhY6h6vkqQ2IGUiGilS4hgVWa26QOstj1twf4Dj1xaHro5800evW886pwJyK3FSfULrvpiJ6Q_DkzSEG1sGRj4RTwl8Opgh27Mot5m2x-qESwbEMeazz2saIdHpt6lcH1VY2baazy322mCRXzA9SdQD-u2bjjI4Fu-AJQRbL51pvzNceXJdz9xwnbX5RgY99E6AYOlzQ5zVl7PDsxLwdJr8UppYGQmrTBZ7DBjtNXGGMelZ0M1SBJVa0JZ3K61MWnYzPL5M\";\n        String noCnfJwt = \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImtleUlkIn0.eyJzdWIiOiJ1c2VyLmFkbWluIiwiaXNzIjoic3lzLmF1dGgudGVzdElkUCIsImF1ZCI6Imh0dHBzOi8vem1zLmF0aGVuei5pbyIsInNjb3BlIjoic3lzLmF1dGg6cm9sZS5hZG1pbiIsImNsaWVudF9pZCI6InVpLmF0aGVuei5pbyIsImlhdCI6MTUxNjIzOTAyMiwiZXhwIjo5OTkwMDA5OTk5fQ.uE-SsyDGb0a1QU1Clv0WmwZqIm1HXc0pJy_rGofpIeo5jOsz3wj1ZVjGslgLV56hW9zvnwOh5ur8ChgQrYfDN1meM6loiu4py9mAU9bfaiPkecqGA5zmWQjhl9206MbVKxFXbVlt5FrQJaM5corSkIH4MIpxS4vU2dZBC4Emtc8hZXRg5BOKr6xRA-vTLbWNa3FTh8dhehTXngQ_bnJfU5MxoTMlrBCrajKjnzSYzZ6vutJKDZKGdbmRrM982wjuDyEzhViKVDBsNqUa0LUblBoUtVx2FnPCUlBWnyqm4aaf6FtqV8z2KolcH1DA_3PaWv1R_txFD0B4pRm1GA77LGCgAdNzZ4KMBN300K0DzBhbYS4fmbr0faAIUtYWRTI3PwkSQGUwZTS4FZbK6RQ-kUkx68BhLP3R33E06EGsb7qvdcPELFjMh8HtbUPUZdJnq0z5Q6EJrWE4h3_7c6JDCm5IIJ9GDN8u20l0BFQe1SCmcYAVutuuGX_79B73r2sQdm8-6LVoOZXtDFLlbadcXUHybUgZYYSlehKD1Vdt4JQqeVStdUM0q7Otfe9dhfrDHwJrEN9iGNWVItxlP86K8SrTRzaa8b1Qs6E-qXx_6XFF3taFU9jWS3I571WrXo1qkJp6QQknqEFa1JJkh28UDjonkgRSzeProQxbF_7T5VE\";\n        String invalidSubjectJwt = \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImtleUlkIn0.eyJzdWIiOiJ1c2VyYWRtaW4iLCJpc3MiOiJzeXMuYXV0aC50ZXN0SWRQIiwiYXVkIjoiaHR0cHM6Ly96bXMuYXRoZW56LmlvIiwic2NvcGUiOiJzeXMuYXV0aDpyb2xlLmFkbWluIiwiY2xpZW50X2lkIjoidWkuYXRoZW56LmlvIiwiaWF0IjoxNTE2MjM5MDIyLCJjbmYiOnsieDV0I1MyNTYiOiJ6bGt4eW9YOTVsZS1OdjdPSTBCeGNqVE9vZ3Z5OVBHSC12X0NCcl9Ec0VrIn0sImV4cCI6OTk5MDAwOTk5OX0.HhCeOzNcDtR6GmPvlARwn5NSNPK3QhLw_LSsyg8LIq35vu8BoBsgX-Dw8GuFXc84e9gFdV5LTPOpOM78Ktc_L-eQ27j3u_UggCGwxkZHknRprLzBDx8A-bM3VyPyxTpokNFyrmrDbUn7pE8QwDRuPxOHjZUG1Wca2kY9YtgxnvYmh8w6TRH_uKdCPlbdo6FgQFbpSXZWbm0_UOQXpsSLH-q9vwz52D2wuDM_kGigLf1GKueshj-4Rzmrgh1nT-Zb6JQtBKdsnJRjQi9O9gQFwAdUcFFLVXd8IQKpgJc6ZvesGBwJmEOrE-THFHaGPdiRbqgMc8ha_0uknVeOwgiIflQfXi2Tid6aXBWBLDnABJuzlpSs7cXto3Fu-RAQLCQ16YJnFfeaCpmRkkjqTIupgRUy3_rqBNDUgg62kGjb6Sz_Q9lC1rdvx19i2lZqlvxgX1Q0_tbkqfCXm4mgU8b70OJ2oVGE6fq4hXDIKl-v7YAtDQdfqz3OmN6epRdOXCi3ZdgE5QzJS1TVbu-IgGrNgkfl8QzS02mSoIUpJAWZfE_21oYvLNjtYuOC2r9q3CSTwUHQJu45HupZnr0dLq7dIV-y_PAanHpz2IRJrhbZBicbR2P0sBsx-FxPUIGCK4II3Gsx5LehYNWYHSNnzdaGZC56x41VTzo2g7KNqLNYUBk\";\n        String customJwt = \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImtleUlkIn0.eyJzdWIiOiJ1c2VyLmFkbWluIiwiaXNzIjoic3lzLmF1dGgudGVzdElkUCIsImF1ZCI6WyJjdXN0b21fYXVkXzEiLCJjdXN0b21fYXVkXzIiXSwic2NvcGUiOiJjdXN0b21fc2NvcGVfMSBjdXN0b21fc2NvcGVfMiIsImNsaWVudF9pZCI6InVpLmF0aGVuei5pbyIsImlhdCI6MTUxNjIzOTAyMiwiY25mIjp7Ing1dCNTMjU2IjoiemxreHlvWDk1bGUtTnY3T0kwQnhjalRPb2d2eTlQR0gtdl9DQnJfRHNFayJ9LCJleHAiOjk5OTAwMDk5OTl9.HCc0RCeV06gtgUKPoSDGhFySDxsCujmpzbge-oe1YQv43sRBTJfvJ4JIDnuPCosPugw8R9l9Bj3VM_sKSLHpJGhDRcQPamlawdes7bHSSL8VDoQIPLIzTdQUXc81OJqKSTMBjChdPzHSKF3VpwnrMpuFuBLvPs7PyN7xXxzDlEANPYx6-9pnd_z_eB4hABj0Q_fyX9pcm9wyXPyW3eEDo0m_R80fa6CUaEGt6FseVyZp7WimCXF-IongjXJLy3BLppVIUHg5U_rVmvoe81pE7-tJe7NiS5suUWLq-kMBNhmGBulGNLbH8VT4jOVDTpzS8a3jHL18xtHlij9Zbg4zpBbo4Z8O0Az37SS1vrGwTMPAW9uhjVRqAJB1MM5YZ5Rr8XRy6hduF-FbDmOP27jE_n0Hk2oQ2yfaB2oAY0wjpSLukV_CNzaDWrBBu_j25ld1OsvKeHXTBtf8EhjIcWrktu48SJvoDNQZZskeDXAt7gabFv7y2Gbe4JG4AF43-ewRuFzoMBJsLgzjvd7f1v71leTV519AD4ScjJNp17PakSc8BFu3E9--yr2jLFsJ1cC3VtezdOV2Jssh00WiklsB-mdcHi2WOXr3XONuix6ZvS2DehQCKEFtGEQcWe3oLjZmE5QDJNvuCbU1GbtAXiAbbEuqKaUKUf9HZW2KVfUSgqI\";\n        HttpServletRequest requestMock = null;\n        StringBuilder errMsg = new StringBuilder();\n        OAuthCertBoundJwtAccessTokenAuthority authority = new OAuthCertBoundJwtAccessTokenAuthority();\n        System.setProperty(\"athenz.auth.oauth.jwt.claim.iss\", \"sys.auth.testIdP\");\n        authority.initialize();\n        System.clearProperty(\"athenz.auth.oauth.jwt.claim.iss\");\n        KeyStore jwtKeyStore = Mockito.spy(baseKeyStore);\n        Mockito.when(jwtKeyStore.getPublicKey(\"sys.auth\", \"testidp\", \"keyId\")).thenReturn(this.jwtPublicKey);\n        authority.setKeyStore(jwtKeyStore);\n        Principal principal = null;\n\n        // empty token, skip\n        requestMock = Mockito.mock(HttpServletRequestWrapper.class);\n        Mockito.when(requestMock.getHeaders(\"Authorization\")).thenReturn(Collections.enumeration(Arrays.asList()));\n        errMsg.setLength(0);\n        assertEquals(authority.authenticate(requestMock, errMsg), null);\n        assertEquals(errMsg.length(), 0);\n\n        // no certificate error\n        requestMock = Mockito.mock(HttpServletRequestWrapper.class);\n        Mockito.when(requestMock.getHeaders(\"Authorization\")).thenReturn(Collections.enumeration(Arrays.asList(\"Bearer dummy_access_token\")));\n        errMsg.setLength(0);\n        assertEquals(authority.authenticate(requestMock, errMsg), null);\n        assertEquals(errMsg.toString(), \"OAuthCertBoundJwtAccessTokenAuthority:authenticate: invalid certificate: No certificate available in request\");\n\n        // null errMsg, no errors\n        requestMock = Mockito.mock(HttpServletRequestWrapper.class);\n        Mockito.when(requestMock.getHeaders(\"Authorization\")).thenReturn(Collections.enumeration(Arrays.asList(\"Bearer dummy_access_token_1\")));\n        assertEquals(authority.authenticate(requestMock, null), null);\n\n        // parse JWT error\n        requestMock = Mockito.mock(HttpServletRequestWrapper.class);\n        Mockito.when(requestMock.getHeaders(\"Authorization\")).thenReturn(Collections.enumeration(Arrays.asList(\"Bearer invalid_access_token\")));\n        Mockito.when(requestMock.getAttribute(\"javax.servlet.request.X509Certificate\")).thenReturn(clientCertChain);\n        errMsg.setLength(0);\n        assertEquals(authority.authenticate(requestMock, errMsg), null);\n        assertEquals(errMsg.toString(), \"OAuthCertBoundJwtAccessTokenAuthority:authenticate: invalid JWT: io.jsonwebtoken.MalformedJwtException: JWT strings must contain exactly 2 period characters. Found: 0\");\n        requestMock = Mockito.mock(HttpServletRequestWrapper.class);\n        Mockito.when(requestMock.getHeaders(\"Authorization\")).thenReturn(Collections.enumeration(Arrays.asList(\"Bearer \" + expiredJwt)));\n        Mockito.when(requestMock.getAttribute(\"javax.servlet.request.X509Certificate\")).thenReturn(clientCertChain);\n        errMsg.setLength(0);\n        assertEquals(authority.authenticate(requestMock, errMsg), null);\n        assertTrue(errMsg.toString().startsWith(\"OAuthCertBoundJwtAccessTokenAuthority:authenticate: invalid JWT: io.jsonwebtoken.ExpiredJwtException: JWT expired at 2018-01-18T01:30:22Z. Current time: \"));\n\n        // invalid JWT\n        requestMock = Mockito.mock(HttpServletRequestWrapper.class);\n        Mockito.when(requestMock.getHeaders(\"Authorization\")).thenReturn(Collections.enumeration(Arrays.asList(\"Bearer \" + noExpJwt)));\n        Mockito.when(requestMock.getAttribute(\"javax.servlet.request.X509Certificate\")).thenReturn(clientCertChain);\n        errMsg.setLength(0);\n        assertEquals(authority.authenticate(requestMock, errMsg), null);\n        assertEquals(errMsg.toString(), \"OAuthCertBoundJwtAccessTokenAuthority:authenticate: invalid JWT: exp is empty\");\n        requestMock = Mockito.mock(HttpServletRequestWrapper.class);\n        Mockito.when(requestMock.getHeaders(\"Authorization\")).thenReturn(Collections.enumeration(Arrays.asList(\"Bearer \" + noCnfJwt)));\n        Mockito.when(requestMock.getAttribute(\"javax.servlet.request.X509Certificate\")).thenReturn(clientCertChain);\n        errMsg.setLength(0);\n        assertEquals(authority.authenticate(requestMock, errMsg), null);\n        assertEquals(errMsg.toString(), \"OAuthCertBoundJwtAccessTokenAuthority:authenticate: invalid JWT: NO mapping of authorized client IDs for certificate principal (ui.athenz.io)\");\n\n        // skip cert thumbprint verification\n        System.setProperty(\"athenz.auth.oauth.jwt.authorized_client_ids_path\", this.classLoader.getResource(\"authorized_client_ids.single.txt\").getPath());\n        System.setProperty(\"athenz.auth.oauth.jwt.verify_cert_thumbprint\", \"false\");\n        System.setProperty(\"athenz.auth.oauth.jwt.claim.iss\", \"sys.auth.testIdP\");\n        authority.initialize();\n        System.clearProperty(\"athenz.auth.oauth.jwt.claim.iss\");\n        System.clearProperty(\"athenz.auth.oauth.jwt.authorized_client_ids_path\");\n        System.clearProperty(\"athenz.auth.oauth.jwt.verify_cert_thumbprint\");\n        requestMock = Mockito.mock(HttpServletRequestWrapper.class);\n        Mockito.when(requestMock.getHeaders(\"Authorization\")).thenReturn(Collections.enumeration(Arrays.asList(\"Bearer \" + noCnfJwt)));\n        Mockito.when(requestMock.getAttribute(\"javax.servlet.request.X509Certificate\")).thenReturn(clientCertChain);\n        errMsg.setLength(0);\n        principal = authority.authenticate(requestMock, errMsg);\n        assertNotNull(principal);\n        assertEquals(errMsg.toString(), \"\");\n        assertEquals(principal.getDomain(), \"user\");\n        assertEquals(principal.getName(), \"admin\");\n        assertEquals(principal.getCredentials(), noCnfJwt);\n        assertEquals(principal.getIssueTime(), 1516239022L);\n        assertEquals(principal.getX509Certificate(), clientCertChain[0]);\n        assertEquals(principal.getRoles(), null);\n        assertEquals(principal.getApplicationId(), \"ui.athenz.io\");\n        assertEquals(principal.getAuthorizedService(), \"sys.auth.ui\");\n        System.setProperty(\"athenz.auth.oauth.jwt.claim.iss\", \"sys.auth.testIdP\");\n        authority.initialize(); // reset\n        System.clearProperty(\"athenz.auth.oauth.jwt.claim.iss\");\n\n        // invalid subject JWT\n        System.setProperty(\"athenz.auth.oauth.jwt.authorized_client_ids_path\", this.classLoader.getResource(\"authorized_client_ids.single.txt\").getPath());\n        System.setProperty(\"athenz.auth.oauth.jwt.claim.iss\", \"sys.auth.testIdP\");\n        authority.initialize();\n        System.clearProperty(\"athenz.auth.oauth.jwt.claim.iss\");\n        System.clearProperty(\"athenz.auth.oauth.jwt.authorized_client_ids_path\");\n        requestMock = Mockito.mock(HttpServletRequestWrapper.class);\n        Mockito.when(requestMock.getHeaders(\"Authorization\")).thenReturn(Collections.enumeration(Arrays.asList(\"Bearer \" + invalidSubjectJwt)));\n        Mockito.when(requestMock.getAttribute(\"javax.servlet.request.X509Certificate\")).thenReturn(clientCertChain);\n        errMsg.setLength(0);\n        assertEquals(authority.authenticate(requestMock, errMsg), null);\n        assertEquals(errMsg.toString(), \"OAuthCertBoundJwtAccessTokenAuthority:authenticate: sub is not a valid service identity: got=useradmin\");\n\n        // verify non-default JWT\n        System.setProperty(\"athenz.auth.oauth.jwt.authorized_client_ids_path\", this.classLoader.getResource(\"authorized_client_ids.single.txt\").getPath());\n        System.setProperty(\"athenz.auth.oauth.jwt.claim.iss\", \"custom.iss\");\n        System.setProperty(\"athenz.auth.oauth.jwt.claim.aud\", \"custom_aud_1,custom_aud_2\");\n        System.setProperty(\"athenz.auth.oauth.jwt.claim.scope\", \"custom_scope_1 custom_scope_2\");\n        System.setProperty(\"athenz.auth.oauth.jwt.claim.iss\", \"sys.auth.testIdP\");\n        authority.initialize();\n        System.clearProperty(\"athenz.auth.oauth.jwt.claim.iss\");\n        System.clearProperty(\"athenz.auth.oauth.jwt.authorized_client_ids_path\");\n        System.clearProperty(\"athenz.auth.oauth.jwt.claim.iss\");\n        System.clearProperty(\"athenz.auth.oauth.jwt.claim.aud\");\n        System.clearProperty(\"athenz.auth.oauth.jwt.claim.scope\");\n        requestMock = Mockito.mock(HttpServletRequestWrapper.class);\n        Mockito.when(requestMock.getHeaders(\"Authorization\")).thenReturn(Collections.enumeration(Arrays.asList(\"Bearer \" + customJwt)));\n        Mockito.when(requestMock.getAttribute(\"javax.servlet.request.X509Certificate\")).thenReturn(clientCertChain);\n        errMsg.setLength(0);\n        principal = authority.authenticate(requestMock, errMsg);\n        assertNotNull(principal);\n        assertEquals(errMsg.toString(), \"\");\n        assertEquals(principal.getDomain(), \"user\");\n        assertEquals(principal.getName(), \"admin\");\n        assertEquals(principal.getCredentials(), customJwt);\n        assertEquals(principal.getIssueTime(), 1516239022L);\n        assertEquals(principal.getX509Certificate(), clientCertChain[0]);\n        assertEquals(principal.getRoles(), null);\n        assertEquals(principal.getApplicationId(), \"ui.athenz.io\");\n        assertEquals(principal.getAuthorizedService(), \"sys.auth.ui\");\n        System.setProperty(\"athenz.auth.oauth.jwt.claim.iss\", \"sys.auth.testIdP\");\n        authority.initialize(); // reset\n        System.clearProperty(\"athenz.auth.oauth.jwt.claim.iss\");\n\n    }", "signature": "void testAuthenticate()", "full_signature": "@Test public void testAuthenticate()", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthorityTest.testAuthenticate()", "testcase": true, "constructor": false, "invocations": ["setProperty", "initialize", "clearProperty", "spy", "thenReturn", "when", "getPublicKey", "setKeyStore", "mock", "thenReturn", "when", "getHeaders", "enumeration", "asList", "setLength", "assertEquals", "authenticate", "assertEquals", "length", "mock", "thenReturn", "when", "getHeaders", "enumeration", "asList", "setLength", "assertEquals", "authenticate", "assertEquals", "toString", "mock", "thenReturn", "when", "getHeaders", "enumeration", "asList", "assertEquals", "authenticate", "mock", "thenReturn", "when", "getHeaders", "enumeration", "asList", "thenReturn", "when", "getAttribute", "setLength", "assertEquals", "authenticate", "assertEquals", "toString", "mock", "thenReturn", "when", "getHeaders", "enumeration", "asList", "thenReturn", "when", "getAttribute", "setLength", "assertEquals", "authenticate", "assertTrue", "startsWith", "toString", "mock", "thenReturn", "when", "getHeaders", "enumeration", "asList", "thenReturn", "when", "getAttribute", "setLength", "assertEquals", "authenticate", "assertEquals", "toString", "mock", "thenReturn", "when", "getHeaders", "enumeration", "asList", "thenReturn", "when", "getAttribute", "setLength", "assertEquals", "authenticate", "assertEquals", "toString", "setProperty", "getPath", "getResource", "setProperty", "setProperty", "initialize", "clearProperty", "clearProperty", "clearProperty", "mock", "thenReturn", "when", "getHeaders", "enumeration", "asList", "thenReturn", "when", "getAttribute", "setLength", "authenticate", "assertNotNull", "assertEquals", "toString", "assertEquals", "getDomain", "assertEquals", "getName", "assertEquals", "getCredentials", "assertEquals", "getIssueTime", "assertEquals", "getX509Certificate", "assertEquals", "getRoles", "assertEquals", "getApplicationId", "assertEquals", "getAuthorizedService", "setProperty", "initialize", "clearProperty", "setProperty", "getPath", "getResource", "setProperty", "initialize", "clearProperty", "clearProperty", "mock", "thenReturn", "when", "getHeaders", "enumeration", "asList", "thenReturn", "when", "getAttribute", "setLength", "assertEquals", "authenticate", "assertEquals", "toString", "setProperty", "getPath", "getResource", "setProperty", "setProperty", "setProperty", "setProperty", "initialize", "clearProperty", "clearProperty", "clearProperty", "clearProperty", "clearProperty", "mock", "thenReturn", "when", "getHeaders", "enumeration", "asList", "thenReturn", "when", "getAttribute", "setLength", "authenticate", "assertNotNull", "assertEquals", "toString", "assertEquals", "getDomain", "assertEquals", "getName", "assertEquals", "getCredentials", "assertEquals", "getIssueTime", "assertEquals", "getX509Certificate", "assertEquals", "getRoles", "assertEquals", "getApplicationId", "assertEquals", "getAuthorizedService", "setProperty", "initialize", "clearProperty"]}, "focal_class": {"identifier": "OAuthCertBoundJwtAccessTokenAuthority", "superclass": "", "interfaces": "implements Authority, AuthorityKeyStore, KeyStore", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(OAuthCertBoundJwtAccessTokenAuthority.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(OAuthCertBoundJwtAccessTokenAuthority.class)", "var_name": "LOG"}, {"original_string": "private String authenticateChallenge = \"Bearer realm=\\\"athenz.io\\\"\";", "modifier": "private", "type": "String", "declarator": "authenticateChallenge = \"Bearer realm=\\\"athenz.io\\\"\"", "var_name": "authenticateChallenge"}, {"original_string": "private KeyStore keyStore = null;", "modifier": "private", "type": "KeyStore", "declarator": "keyStore = null", "var_name": "keyStore"}, {"original_string": "private CertificateIdentityParser certificateIdentityParser = null;", "modifier": "private", "type": "CertificateIdentityParser", "declarator": "certificateIdentityParser = null", "var_name": "certificateIdentityParser"}, {"original_string": "private OAuthJwtAccessTokenParser parser = null;", "modifier": "private", "type": "OAuthJwtAccessTokenParser", "declarator": "parser = null", "var_name": "parser"}, {"original_string": "private OAuthJwtAccessTokenValidator validator = null;", "modifier": "private", "type": "OAuthJwtAccessTokenValidator", "declarator": "validator = null", "var_name": "validator"}, {"original_string": "Map<String, String> authorizedServices = null;", "modifier": "", "type": "Map<String, String>", "declarator": "authorizedServices = null", "var_name": "authorizedServices"}, {"original_string": "private boolean shouldVerifyCertThumbprint = true;", "modifier": "private", "type": "boolean", "declarator": "shouldVerifyCertThumbprint = true", "var_name": "shouldVerifyCertThumbprint"}], "methods": [{"identifier": "setKeyStore", "parameters": "(KeyStore keyStore)", "modifiers": "@Override public", "return": "void", "signature": "void setKeyStore(KeyStore keyStore)", "full_signature": "@Override public void setKeyStore(KeyStore keyStore)", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.setKeyStore(KeyStore keyStore)", "testcase": false, "constructor": false}, {"identifier": "getPublicKey", "parameters": "(String domain, String service, String keyId)", "modifiers": "@Override public", "return": "String", "signature": "String getPublicKey(String domain, String service, String keyId)", "full_signature": "@Override public String getPublicKey(String domain, String service, String keyId)", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.getPublicKey(String domain, String service, String keyId)", "testcase": false, "constructor": false}, {"identifier": "getCredSource", "parameters": "()", "modifiers": "@Override public", "return": "CredSource", "signature": "CredSource getCredSource()", "full_signature": "@Override public CredSource getCredSource()", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.getCredSource()", "testcase": false, "constructor": false}, {"identifier": "getAuthenticateChallenge", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getAuthenticateChallenge()", "full_signature": "@Override public String getAuthenticateChallenge()", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.getAuthenticateChallenge()", "testcase": false, "constructor": false}, {"identifier": "getDomain", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getDomain()", "full_signature": "@Override public String getDomain()", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.getDomain()", "testcase": false, "constructor": false}, {"identifier": "getHeader", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getHeader()", "full_signature": "@Override public String getHeader()", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.getHeader()", "testcase": false, "constructor": false}, {"identifier": "authenticate", "parameters": "(String credentials, String remoteAddr, String httpMethod, StringBuilder errMsg)", "modifiers": "@Override public", "return": "Principal", "signature": "Principal authenticate(String credentials, String remoteAddr, String httpMethod, StringBuilder errMsg)", "full_signature": "@Override public Principal authenticate(String credentials, String remoteAddr, String httpMethod, StringBuilder errMsg)", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.authenticate(String credentials, String remoteAddr, String httpMethod, StringBuilder errMsg)", "testcase": false, "constructor": false}, {"identifier": "reportError", "parameters": "(final String message, StringBuilder errMsg)", "modifiers": "private", "return": "void", "signature": "void reportError(final String message, StringBuilder errMsg)", "full_signature": "private void reportError(final String message, StringBuilder errMsg)", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.reportError(final String message, StringBuilder errMsg)", "testcase": false, "constructor": false}, {"identifier": "processAuthorizedClientIds", "parameters": "(String authorizedClientIdsPath, Map<String, Set<String>> authorizedClientIds, Map<String, String> authorizedServices)", "modifiers": "private", "return": "void", "signature": "void processAuthorizedClientIds(String authorizedClientIdsPath, Map<String, Set<String>> authorizedClientIds, Map<String, String> authorizedServices)", "full_signature": "private void processAuthorizedClientIds(String authorizedClientIdsPath, Map<String, Set<String>> authorizedClientIds, Map<String, String> authorizedServices)", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.processAuthorizedClientIds(String authorizedClientIdsPath, Map<String, Set<String>> authorizedClientIds, Map<String, String> authorizedServices)", "testcase": false, "constructor": false}, {"identifier": "initialize", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void initialize()", "full_signature": "@Override public void initialize()", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.initialize()", "testcase": false, "constructor": false}, {"identifier": "authenticate", "parameters": "(HttpServletRequest request, StringBuilder errMsg)", "modifiers": "@Override public", "return": "Principal", "signature": "Principal authenticate(HttpServletRequest request, StringBuilder errMsg)", "full_signature": "@Override public Principal authenticate(HttpServletRequest request, StringBuilder errMsg)", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.authenticate(HttpServletRequest request, StringBuilder errMsg)", "testcase": false, "constructor": false}], "file": "libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/oauth/OAuthCertBoundJwtAccessTokenAuthority.java"}, "focal_method": {"identifier": "authenticate", "parameters": "(String credentials, String remoteAddr, String httpMethod, StringBuilder errMsg)", "modifiers": "@Override public", "return": "Principal", "body": "@Override\n    public Principal authenticate(String credentials, String remoteAddr, String httpMethod, StringBuilder errMsg) {\n        // disable authenticate using header mode\n        return null;\n    }", "signature": "Principal authenticate(String credentials, String remoteAddr, String httpMethod, StringBuilder errMsg)", "full_signature": "@Override public Principal authenticate(String credentials, String remoteAddr, String httpMethod, StringBuilder errMsg)", "class_method_signature": "OAuthCertBoundJwtAccessTokenAuthority.authenticate(String credentials, String remoteAddr, String httpMethod, StringBuilder errMsg)", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 73948366, "url": "https://github.com/yahoo/athenz", "stars": 394, "created": "11/16/2016 6:23:08 PM +00:00", "updates": "2020-01-27T15:36:13+00:00", "fork": "False", "license": "licensed"}}