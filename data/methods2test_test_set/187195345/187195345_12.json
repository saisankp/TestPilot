{"test_class": {"identifier": "OpenLRDecoderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int EXPECTED_NODE_NO_OFFSETS = 5;", "modifier": "private static final", "type": "int", "declarator": "EXPECTED_NODE_NO_OFFSETS = 5", "var_name": "EXPECTED_NODE_NO_OFFSETS"}, {"original_string": "private final Mockery mockery = new Mockery();", "modifier": "private final", "type": "Mockery", "declarator": "mockery = new Mockery()", "var_name": "mockery"}, {"original_string": "private TestData td = TestData.getInstance();", "modifier": "private", "type": "TestData", "declarator": "td = TestData.getInstance()", "var_name": "td"}, {"original_string": "private RawLocationReference mockedLocRefPoiWithAccess;", "modifier": "private", "type": "RawLocationReference", "declarator": "mockedLocRefPoiWithAccess", "var_name": "mockedLocRefPoiWithAccess"}, {"original_string": "private MapDatabase mockedMapDB;", "modifier": "private", "type": "MapDatabase", "declarator": "mockedMapDB", "var_name": "mockedMapDB"}], "file": "decoder/src/test/java/openlr/decoder/OpenLRDecoderTest.java"}, "test_case": {"identifier": "testResolvePhysicalDecoder", "parameters": "()", "modifiers": "@Test(dependsOnMethods = {\"testPOIWithAccesNoOffsets\"}) public final", "return": "void", "body": "@Test(dependsOnMethods = {\"testPOIWithAccesNoOffsets\"})\n    public final void testResolvePhysicalDecoder() {\n\n        final LocationReference mockedLocRef = mockery.mock(\n                LocationReference.class, \"locRefDummy\");\n        mockery.checking(new Expectations() {\n            {\n                allowing(mockedLocRef).getDataClass();\n                will(returnValue(Object.class));\n            }\n        });\n        mockery.checking(new Expectations() {\n            {\n                allowing(mockedLocRef).getDataIdentifier();\n                will(returnValue(DummyPhysicalDecoderImpl.DATA_IDENTIFIER));\n            }\n        });\n        mockery.checking(new Expectations() {\n            {\n                allowing(mockedLocRef).getLocationReferenceData();\n                will(returnValue(null));\n            }\n        });\n        mockery.checking(new Expectations() {\n            {\n                allowing(mockedLocRef).getID();\n                will(returnValue(mockedLocRefPoiWithAccess.getID()));\n            }\n        });\n\n        assertNotNull(mockedLocRefPoiWithAccess,\n                \"Required input object is null!\");\n        DummyPhysicalDecoderImpl.setRawLocToReturn(mockedLocRefPoiWithAccess);\n\n        try {\n            InputStream properties = new FileInputStream(DECODER_PROPERTIES);\n            Configuration conf = OpenLRPropertiesReader\n                    .loadPropertiesFromStream(properties, true);\n            OpenLRDecoder decoder = new OpenLRDecoder();\n            // Test two possible methods, the one with the single object ...\n            OpenLRDecoderParameter parameter = new OpenLRDecoderParameter.Builder()\n                    .with(mockedMapDB)\n                    .with(conf).buildParameter();\n            Location decLocRef = decoder.decode(parameter, mockedLocRef);\n            assertEquals(decLocRef.getID(), mockedLocRefPoiWithAccess.getID());\n\n            // ... and the one with the list.\n            properties = new FileInputStream(DECODER_PROPERTIES);\n            List<Location> decLocRefs = decoder.decode(parameter,\n                    Arrays.asList(mockedLocRef));\n            assertEquals(decLocRefs.get(0).getID(),\n                    mockedLocRefPoiWithAccess.getID());\n\n        } catch (OpenLRProcessingException e) {\n            fail(\"Decoding location failed with exception: \" + e.getErrorCode(),\n                    e);\n        } catch (IOException e) {\n            fail(\"Error creating properties stream.\", e);\n        } finally {\n            DummyPhysicalDecoderImpl.setRawLocToReturn(null);\n        }\n    }", "signature": "void testResolvePhysicalDecoder()", "full_signature": "@Test(dependsOnMethods = {\"testPOIWithAccesNoOffsets\"}) public final void testResolvePhysicalDecoder()", "class_method_signature": "OpenLRDecoderTest.testResolvePhysicalDecoder()", "testcase": true, "constructor": false, "invocations": ["mock", "checking", "getDataClass", "allowing", "will", "returnValue", "checking", "getDataIdentifier", "allowing", "will", "returnValue", "checking", "getLocationReferenceData", "allowing", "will", "returnValue", "checking", "getID", "allowing", "will", "returnValue", "getID", "assertNotNull", "setRawLocToReturn", "loadPropertiesFromStream", "buildParameter", "with", "with", "decode", "assertEquals", "getID", "getID", "decode", "asList", "assertEquals", "getID", "get", "getID", "fail", "getErrorCode", "fail", "setRawLocToReturn"]}, "focal_class": {"identifier": "OpenLRDecoder", "superclass": "", "interfaces": "implements openlr.OpenLRDecoder", "fields": [{"original_string": "private static final Logger LOG = Logger.getLogger(OpenLRDecoder.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(OpenLRDecoder.class)", "var_name": "LOG"}, {"original_string": "private final Version VERSION = VersionHelper.getVersion(\"decoder\");", "modifier": "private final", "type": "Version", "declarator": "VERSION = VersionHelper.getVersion(\"decoder\")", "var_name": "VERSION"}], "methods": [{"identifier": "resolvePhysicalDecoder", "parameters": "()", "modifiers": "public static", "return": "List<PhysicalDecoder>", "signature": "List<PhysicalDecoder> resolvePhysicalDecoder()", "full_signature": "public static List<PhysicalDecoder> resolvePhysicalDecoder()", "class_method_signature": "OpenLRDecoder.resolvePhysicalDecoder()", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(final OpenLRDecoderParameter parameter,\n                           final LocationReference locRef)", "modifiers": "@Override public", "return": "Location", "signature": "Location decode(final OpenLRDecoderParameter parameter,\n                           final LocationReference locRef)", "full_signature": "@Override public Location decode(final OpenLRDecoderParameter parameter,\n                           final LocationReference locRef)", "class_method_signature": "OpenLRDecoder.decode(final OpenLRDecoderParameter parameter,\n                           final LocationReference locRef)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(final OpenLRDecoderParameter parameter, final OpenLRDecoderProperties properties,\n                            final LocationReference locRef)", "modifiers": "private", "return": "Location", "signature": "Location decode(final OpenLRDecoderParameter parameter, final OpenLRDecoderProperties properties,\n                            final LocationReference locRef)", "full_signature": "private Location decode(final OpenLRDecoderParameter parameter, final OpenLRDecoderProperties properties,\n                            final LocationReference locRef)", "class_method_signature": "OpenLRDecoder.decode(final OpenLRDecoderParameter parameter, final OpenLRDecoderProperties properties,\n                            final LocationReference locRef)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(final OpenLRDecoderParameter parameter,\n                                 final List<LocationReference> locRefs)", "modifiers": "@Override public", "return": "List<Location>", "signature": "List<Location> decode(final OpenLRDecoderParameter parameter,\n                                 final List<LocationReference> locRefs)", "full_signature": "@Override public List<Location> decode(final OpenLRDecoderParameter parameter,\n                                 final List<LocationReference> locRefs)", "class_method_signature": "OpenLRDecoder.decode(final OpenLRDecoderParameter parameter,\n                                 final List<LocationReference> locRefs)", "testcase": false, "constructor": false}, {"identifier": "decodeRaw", "parameters": "(final OpenLRDecoderParameter parameter,\n                                    final List<RawLocationReference> locRefs)", "modifiers": "@Override public", "return": "List<Location>", "signature": "List<Location> decodeRaw(final OpenLRDecoderParameter parameter,\n                                    final List<RawLocationReference> locRefs)", "full_signature": "@Override public List<Location> decodeRaw(final OpenLRDecoderParameter parameter,\n                                    final List<RawLocationReference> locRefs)", "class_method_signature": "OpenLRDecoder.decodeRaw(final OpenLRDecoderParameter parameter,\n                                    final List<RawLocationReference> locRefs)", "testcase": false, "constructor": false}, {"identifier": "decodeRaw", "parameters": "(final OpenLRDecoderParameter parameter,\n                              final RawLocationReference rawLocRef)", "modifiers": "@Override public", "return": "Location", "signature": "Location decodeRaw(final OpenLRDecoderParameter parameter,\n                              final RawLocationReference rawLocRef)", "full_signature": "@Override public Location decodeRaw(final OpenLRDecoderParameter parameter,\n                              final RawLocationReference rawLocRef)", "class_method_signature": "OpenLRDecoder.decodeRaw(final OpenLRDecoderParameter parameter,\n                              final RawLocationReference rawLocRef)", "testcase": false, "constructor": false}, {"identifier": "decodeRaw", "parameters": "(final OpenLRDecoderParameter parameter, final OpenLRDecoderProperties properties,\n                               final RawLocationReference rawLocRef)", "modifiers": "private", "return": "Location", "signature": "Location decodeRaw(final OpenLRDecoderParameter parameter, final OpenLRDecoderProperties properties,\n                               final RawLocationReference rawLocRef)", "full_signature": "private Location decodeRaw(final OpenLRDecoderParameter parameter, final OpenLRDecoderProperties properties,\n                               final RawLocationReference rawLocRef)", "class_method_signature": "OpenLRDecoder.decodeRaw(final OpenLRDecoderParameter parameter, final OpenLRDecoderProperties properties,\n                               final RawLocationReference rawLocRef)", "testcase": false, "constructor": false}, {"identifier": "resolveRawFormat", "parameters": "(\n            final LocationReference locRef, final List<PhysicalDecoder> decoders)", "modifiers": "private", "return": "RawLocationReference", "signature": "RawLocationReference resolveRawFormat(\n            final LocationReference locRef, final List<PhysicalDecoder> decoders)", "full_signature": "private RawLocationReference resolveRawFormat(\n            final LocationReference locRef, final List<PhysicalDecoder> decoders)", "class_method_signature": "OpenLRDecoder.resolveRawFormat(\n            final LocationReference locRef, final List<PhysicalDecoder> decoders)", "testcase": false, "constructor": false}, {"identifier": "getMajorVersion", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getMajorVersion()", "full_signature": "@Override public String getMajorVersion()", "class_method_signature": "OpenLRDecoder.getMajorVersion()", "testcase": false, "constructor": false}, {"identifier": "getMinorVersion", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getMinorVersion()", "full_signature": "@Override public String getMinorVersion()", "class_method_signature": "OpenLRDecoder.getMinorVersion()", "testcase": false, "constructor": false}, {"identifier": "getPatchVersion", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getPatchVersion()", "full_signature": "@Override public String getPatchVersion()", "class_method_signature": "OpenLRDecoder.getPatchVersion()", "testcase": false, "constructor": false}, {"identifier": "getVersion", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getVersion()", "full_signature": "@Override public String getVersion()", "class_method_signature": "OpenLRDecoder.getVersion()", "testcase": false, "constructor": false}], "file": "decoder/src/main/java/openlr/decoder/OpenLRDecoder.java"}, "focal_method": {"identifier": "resolvePhysicalDecoder", "parameters": "()", "modifiers": "public static", "return": "List<PhysicalDecoder>", "body": "public static List<PhysicalDecoder> resolvePhysicalDecoder() {\n        ServiceLoader<PhysicalDecoder> decoderServices = ServiceLoader\n                .load(PhysicalDecoder.class);\n        List<PhysicalDecoder> decoders = new ArrayList<PhysicalDecoder>();\n        for (PhysicalDecoder pd : decoderServices) {\n            decoders.add(pd);\n        }\n        return decoders;\n    }", "signature": "List<PhysicalDecoder> resolvePhysicalDecoder()", "full_signature": "public static List<PhysicalDecoder> resolvePhysicalDecoder()", "class_method_signature": "OpenLRDecoder.resolvePhysicalDecoder()", "testcase": false, "constructor": false, "invocations": ["load", "add"]}, "repository": {"repo_id": 187195345, "url": "https://github.com/tomtom-international/openlr", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 24, "size": 4809, "license": "licensed"}}