{"test_class": {"identifier": "RingRangeTest", "superclass": "", "interfaces": "", "fields": [], "file": "src/server/src/test/java/io/cassandrareaper/service/RingRangeTest.java"}, "test_case": {"identifier": "testEncloses", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testEncloses() throws Exception {\n    RingRange r0To20 = new RingRange(BigInteger.valueOf(0L), BigInteger.valueOf(20L));\n\n    RingRange r5To15 = new RingRange(BigInteger.valueOf(5L), BigInteger.valueOf(15L));\n    assertTrue(r0To20.encloses(r5To15));\n\n    RingRange r5To25 = new RingRange(BigInteger.valueOf(5L), BigInteger.valueOf(25L));\n    assertFalse(r0To20.encloses(r5To25));\n\n    RingRange r190To25 = new RingRange(BigInteger.valueOf(190L), BigInteger.valueOf(25L));\n    assertFalse(r0To20.encloses(r190To25));\n\n    RingRange r0To15 = new RingRange(BigInteger.valueOf(0L), BigInteger.valueOf(15L));\n    assertTrue(r0To20.encloses(r0To15));\n\n    RingRange r190To15 = new RingRange(BigInteger.valueOf(190L), BigInteger.valueOf(15L));\n    assertFalse(r0To20.encloses(r190To15));\n\n    RingRange r190To0 = new RingRange(BigInteger.valueOf(190L), BigInteger.valueOf(0L));\n    assertFalse(r0To20.encloses(r190To0));\n\n    RingRange r15To20 = new RingRange(BigInteger.valueOf(15L), BigInteger.valueOf(20L));\n    assertTrue(r0To20.encloses(r15To20));\n\n    assertTrue(r0To20.encloses(r0To20));\n\n    RingRange r20To25 = new RingRange(BigInteger.valueOf(20L), BigInteger.valueOf(25L));\n    assertFalse(r0To20.encloses(r20To25));\n\n    RingRange r190To20 = new RingRange(BigInteger.valueOf(190L), BigInteger.valueOf(20L));\n    assertFalse(r190To20.encloses(r5To25));\n\n    RingRange r200To10 = new RingRange(BigInteger.valueOf(200L), BigInteger.valueOf(10L));\n    assertTrue(r190To20.encloses(r200To10));\n\n    RingRange r0To2 = new RingRange(BigInteger.valueOf(0L), BigInteger.valueOf(2L));\n    RingRange r5To190 = new RingRange(BigInteger.valueOf(5L), BigInteger.valueOf(190L));\n    assertFalse(r0To2.encloses(r5To190));\n\n    // 0_0 should enclose almost everything, but is not enclosed by anything\n    RingRange r15To5 = new RingRange(BigInteger.valueOf(15L), BigInteger.valueOf(5L));\n    RingRange r0To0 = new RingRange(BigInteger.valueOf(0L), BigInteger.valueOf(0L));\n    assertTrue(r0To0.encloses(r0To20));\n    assertTrue(r0To0.encloses(r15To20));\n    // the exception is that 0_0 does not enclose 15_5\n    // this is because 0_0 range means one node in the cluster, and that node can't become\n    // a repair coordinator for segment 15_5. This is not a biggie though, because we\n    // generate the segments carefully, and prevent situation like this\n    assertFalse(r0To0.encloses(r15To5));\n    assertTrue(r0To0.encloses(r190To0));\n\n    assertFalse(r0To20.encloses(r0To0));\n    assertFalse(r15To20.encloses(r0To0));\n    assertFalse(r5To15.encloses(r0To0));\n    assertFalse(r190To0.encloses(r0To0));\n  }", "signature": "void testEncloses()", "full_signature": "@Test public void testEncloses()", "class_method_signature": "RingRangeTest.testEncloses()", "testcase": true, "constructor": false, "invocations": ["valueOf", "valueOf", "valueOf", "valueOf", "assertTrue", "encloses", "valueOf", "valueOf", "assertFalse", "encloses", "valueOf", "valueOf", "assertFalse", "encloses", "valueOf", "valueOf", "assertTrue", "encloses", "valueOf", "valueOf", "assertFalse", "encloses", "valueOf", "valueOf", "assertFalse", "encloses", "valueOf", "valueOf", "assertTrue", "encloses", "assertTrue", "encloses", "valueOf", "valueOf", "assertFalse", "encloses", "valueOf", "valueOf", "assertFalse", "encloses", "valueOf", "valueOf", "assertTrue", "encloses", "valueOf", "valueOf", "valueOf", "valueOf", "assertFalse", "encloses", "valueOf", "valueOf", "valueOf", "valueOf", "assertTrue", "encloses", "assertTrue", "encloses", "assertFalse", "encloses", "assertTrue", "encloses", "assertFalse", "encloses", "assertFalse", "encloses", "assertFalse", "encloses", "assertFalse", "encloses"]}, "focal_class": {"identifier": "RingRange", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final Comparator<RingRange> START_COMPARATOR\n      = (RingRange o1, RingRange o2) -> o1.start.compareTo(o2.start);", "modifier": "public static final", "type": "Comparator<RingRange>", "declarator": "START_COMPARATOR\n      = (RingRange o1, RingRange o2) -> o1.start.compareTo(o2.start)", "var_name": "START_COMPARATOR"}, {"original_string": "private final BigInteger start;", "modifier": "private final", "type": "BigInteger", "declarator": "start", "var_name": "start"}, {"original_string": "private final BigInteger end;", "modifier": "private final", "type": "BigInteger", "declarator": "end", "var_name": "end"}], "methods": [{"identifier": "RingRange", "parameters": "(BigInteger start, BigInteger end)", "modifiers": "public", "return": "", "signature": " RingRange(BigInteger start, BigInteger end)", "full_signature": "public  RingRange(BigInteger start, BigInteger end)", "class_method_signature": "RingRange.RingRange(BigInteger start, BigInteger end)", "testcase": false, "constructor": true}, {"identifier": "RingRange", "parameters": "(String... range)", "modifiers": "public", "return": "", "signature": " RingRange(String... range)", "full_signature": "public  RingRange(String... range)", "class_method_signature": "RingRange.RingRange(String... range)", "testcase": false, "constructor": true}, {"identifier": "getStart", "parameters": "()", "modifiers": "public", "return": "BigInteger", "signature": "BigInteger getStart()", "full_signature": "public BigInteger getStart()", "class_method_signature": "RingRange.getStart()", "testcase": false, "constructor": false}, {"identifier": "getEnd", "parameters": "()", "modifiers": "public", "return": "BigInteger", "signature": "BigInteger getEnd()", "full_signature": "public BigInteger getEnd()", "class_method_signature": "RingRange.getEnd()", "testcase": false, "constructor": false}, {"identifier": "span", "parameters": "(BigInteger ringSize)", "modifiers": "public", "return": "BigInteger", "signature": "BigInteger span(BigInteger ringSize)", "full_signature": "public BigInteger span(BigInteger ringSize)", "class_method_signature": "RingRange.span(BigInteger ringSize)", "testcase": false, "constructor": false}, {"identifier": "encloses", "parameters": "(RingRange other)", "modifiers": "public", "return": "boolean", "signature": "boolean encloses(RingRange other)", "full_signature": "public boolean encloses(RingRange other)", "class_method_signature": "RingRange.encloses(RingRange other)", "testcase": false, "constructor": false}, {"identifier": "isWrapping", "parameters": "()", "modifiers": "@JsonIgnore public", "return": "boolean", "signature": "boolean isWrapping()", "full_signature": "@JsonIgnore public boolean isWrapping()", "class_method_signature": "RingRange.isWrapping()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "RingRange.toString()", "testcase": false, "constructor": false}, {"identifier": "merge", "parameters": "(List<RingRange> ranges)", "modifiers": "public static", "return": "RingRange", "signature": "RingRange merge(List<RingRange> ranges)", "full_signature": "public static RingRange merge(List<RingRange> ranges)", "class_method_signature": "RingRange.merge(List<RingRange> ranges)", "testcase": false, "constructor": false}], "file": "src/server/src/main/java/io/cassandrareaper/service/RingRange.java"}, "focal_method": {"identifier": "encloses", "parameters": "(RingRange other)", "modifiers": "public", "return": "boolean", "body": "public boolean encloses(RingRange other) {\n    if (!isWrapping()) {\n      return !other.isWrapping()\n          && SegmentGenerator.greaterThanOrEqual(other.start, start)\n          && SegmentGenerator.lowerThanOrEqual(other.end, end);\n    } else {\n      return (!other.isWrapping()\n          && (SegmentGenerator.greaterThanOrEqual(other.start, start)\n          || SegmentGenerator.lowerThanOrEqual(other.end, end)))\n          || (SegmentGenerator.greaterThanOrEqual(other.start, start)\n          && SegmentGenerator.lowerThanOrEqual(other.end, end));\n    }\n  }", "signature": "boolean encloses(RingRange other)", "full_signature": "public boolean encloses(RingRange other)", "class_method_signature": "RingRange.encloses(RingRange other)", "testcase": false, "constructor": false, "invocations": ["isWrapping", "isWrapping", "greaterThanOrEqual", "lowerThanOrEqual", "isWrapping", "greaterThanOrEqual", "lowerThanOrEqual", "greaterThanOrEqual", "lowerThanOrEqual"]}, "repository": {"repo_id": 70856121, "url": "https://github.com/thelastpickle/cassandra-reaper", "language": "Java", "is_fork": false, "fork_count": 156, "stargazer_count": 353, "size": 43662, "license": "licensed"}}