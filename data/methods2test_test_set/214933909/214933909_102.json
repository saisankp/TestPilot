{"test_class": {"identifier": "KeyHolderTest", "superclass": "", "interfaces": "", "fields": [], "file": "das-client/src/test/java/com/ppdai/das/core/KeyHolderTest.java"}, "test_case": {"identifier": "testSetGeneratedKeyBack", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSetGeneratedKeyBack () throws SQLException {\n        MyTask myTask = new MyTask();\n        Entity entity = new Entity();\n        entity.setValue(new Gson().toJson(ImmutableMap.of(\"keyC\", 1)));\n        EntityMeta meta = new EntityMeta();\n        meta.setPrimaryKeyNames(Lists.newArrayList(\"keyC\"));\n        meta.setColumnNames(Lists.newArrayList(\"keyC\"));\n        meta.setColumnTypes(Lists.newArrayList(\"INTEGER\"));\n        ColumnMeta columnMeta = new ColumnMeta();\n        columnMeta.setType(JDBCType.INTEGER.getName());\n        meta.setMetaMap(ImmutableMap.of(\"keyC\", columnMeta));\n        entity.setEntityMeta(meta);\n        Hints hints = Hints.hints().setIdBack().setSize(Lists.newArrayList(entity));\n        hints.getKeyHolder().addKey(ImmutableMap.of(\"keyC\", 2));\n        KeyHolder.setGeneratedKeyBack(myTask, hints, Lists.newArrayList(entity));\n        Assert.assertTrue(Double.parseDouble(new Gson().fromJson(entity.getValue(), Map.class).get(\"keyC\").toString()) > 1);\n    }", "signature": "void testSetGeneratedKeyBack()", "full_signature": "@Test public void testSetGeneratedKeyBack()", "class_method_signature": "KeyHolderTest.testSetGeneratedKeyBack()", "testcase": true, "constructor": false, "invocations": ["setValue", "toJson", "of", "setPrimaryKeyNames", "newArrayList", "setColumnNames", "newArrayList", "setColumnTypes", "newArrayList", "setType", "getName", "setMetaMap", "of", "setEntityMeta", "setSize", "setIdBack", "hints", "newArrayList", "addKey", "getKeyHolder", "of", "setGeneratedKeyBack", "newArrayList", "assertTrue", "parseDouble", "toString", "get", "fromJson", "getValue"]}, "focal_class": {"identifier": "KeyHolder", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String NOT_SET = \"NOT SET!!!\";", "modifier": "public static final", "type": "String", "declarator": "NOT_SET = \"NOT SET!!!\"", "var_name": "NOT_SET"}, {"original_string": "private static final Map<String, Object> emptyMap = new HashMap<>();", "modifier": "private static final", "type": "Map<String, Object>", "declarator": "emptyMap = new HashMap<>()", "var_name": "emptyMap"}, {"original_string": "private volatile boolean requireMerge = false;", "modifier": "private volatile", "type": "boolean", "declarator": "requireMerge = false", "var_name": "requireMerge"}, {"original_string": "private AtomicInteger currentPos = new AtomicInteger();", "modifier": "private", "type": "AtomicInteger", "declarator": "currentPos = new AtomicInteger()", "var_name": "currentPos"}, {"original_string": "private AtomicInteger remainSize = new AtomicInteger();", "modifier": "private", "type": "AtomicInteger", "declarator": "remainSize = new AtomicInteger()", "var_name": "remainSize"}, {"original_string": "private final Map<Integer, Map<String, Object>> allKeys = new ConcurrentHashMap<>();", "modifier": "private final", "type": "Map<Integer, Map<String, Object>>", "declarator": "allKeys = new ConcurrentHashMap<>()", "var_name": "allKeys"}, {"original_string": "private AtomicBoolean merged = new AtomicBoolean(false);", "modifier": "private", "type": "AtomicBoolean", "declarator": "merged = new AtomicBoolean(false)", "var_name": "merged"}, {"original_string": "private DasLogger logger;", "modifier": "private", "type": "DasLogger", "declarator": "logger", "var_name": "logger"}], "methods": [{"identifier": "KeyHolder", "parameters": "()", "modifiers": "public", "return": "", "signature": " KeyHolder()", "full_signature": "public  KeyHolder()", "class_method_signature": "KeyHolder.KeyHolder()", "testcase": false, "constructor": true}, {"identifier": "initialize", "parameters": "(int size)", "modifiers": "public", "return": "void", "signature": "void initialize(int size)", "full_signature": "public void initialize(int size)", "class_method_signature": "KeyHolder.initialize(int size)", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int size()", "full_signature": "public int size()", "class_method_signature": "KeyHolder.size()", "testcase": false, "constructor": false}, {"identifier": "requireMerge", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void requireMerge()", "full_signature": "public void requireMerge()", "class_method_signature": "KeyHolder.requireMerge()", "testcase": false, "constructor": false}, {"identifier": "isRequireMerge", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isRequireMerge()", "full_signature": "public boolean isRequireMerge()", "class_method_signature": "KeyHolder.isRequireMerge()", "testcase": false, "constructor": false}, {"identifier": "isMerged", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isMerged()", "full_signature": "public boolean isMerged()", "class_method_signature": "KeyHolder.isMerged()", "testcase": false, "constructor": false}, {"identifier": "waitForMerge", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void waitForMerge()", "full_signature": "public void waitForMerge()", "class_method_signature": "KeyHolder.waitForMerge()", "testcase": false, "constructor": false}, {"identifier": "waitForMerge", "parameters": "(int timeout)", "modifiers": "public", "return": "void", "signature": "void waitForMerge(int timeout)", "full_signature": "public void waitForMerge(int timeout)", "class_method_signature": "KeyHolder.waitForMerge(int timeout)", "testcase": false, "constructor": false}, {"identifier": "getKey", "parameters": "()", "modifiers": "public", "return": "Number", "signature": "Number getKey()", "full_signature": "public Number getKey()", "class_method_signature": "KeyHolder.getKey()", "testcase": false, "constructor": false}, {"identifier": "getKey", "parameters": "(int index)", "modifiers": "public", "return": "Number", "signature": "Number getKey(int index)", "full_signature": "public Number getKey(int index)", "class_method_signature": "KeyHolder.getKey(int index)", "testcase": false, "constructor": false}, {"identifier": "getKeys", "parameters": "()", "modifiers": "@Deprecated public", "return": "Map<String, Object>", "signature": "Map<String, Object> getKeys()", "full_signature": "@Deprecated public Map<String, Object> getKeys()", "class_method_signature": "KeyHolder.getKeys()", "testcase": false, "constructor": false}, {"identifier": "getUniqueKey", "parameters": "()", "modifiers": "public", "return": "Map<String, Object>", "signature": "Map<String, Object> getUniqueKey()", "full_signature": "public Map<String, Object> getUniqueKey()", "class_method_signature": "KeyHolder.getUniqueKey()", "testcase": false, "constructor": false}, {"identifier": "getKeyList", "parameters": "()", "modifiers": "public", "return": "List<Map<String, Object>>", "signature": "List<Map<String, Object>> getKeyList()", "full_signature": "public List<Map<String, Object>> getKeyList()", "class_method_signature": "KeyHolder.getKeyList()", "testcase": false, "constructor": false}, {"identifier": "getIdList", "parameters": "()", "modifiers": "public", "return": "List<Number>", "signature": "List<Number> getIdList()", "full_signature": "public List<Number> getIdList()", "class_method_signature": "KeyHolder.getIdList()", "testcase": false, "constructor": false}, {"identifier": "getId", "parameters": "(Map<String, Object> key)", "modifiers": "private", "return": "Number", "signature": "Number getId(Map<String, Object> key)", "full_signature": "private Number getId(Map<String, Object> key)", "class_method_signature": "KeyHolder.getId(Map<String, Object> key)", "testcase": false, "constructor": false}, {"identifier": "isKeyHolderRequired", "parameters": "(DaoTask<?> task, KeyHolder holder)", "modifiers": "private static", "return": "boolean", "signature": "boolean isKeyHolderRequired(DaoTask<?> task, KeyHolder holder)", "full_signature": "private static boolean isKeyHolderRequired(DaoTask<?> task, KeyHolder holder)", "class_method_signature": "KeyHolder.isKeyHolderRequired(DaoTask<?> task, KeyHolder holder)", "testcase": false, "constructor": false}, {"identifier": "addKeys", "parameters": "(List<Map<String, Object>> keys)", "modifiers": "public", "return": "void", "signature": "void addKeys(List<Map<String, Object>> keys)", "full_signature": "public void addKeys(List<Map<String, Object>> keys)", "class_method_signature": "KeyHolder.addKeys(List<Map<String, Object>> keys)", "testcase": false, "constructor": false}, {"identifier": "addKey", "parameters": "(Map<String, Object> key)", "modifiers": "public", "return": "void", "signature": "void addKey(Map<String, Object> key)", "full_signature": "public void addKey(Map<String, Object> key)", "class_method_signature": "KeyHolder.addKey(Map<String, Object> key)", "testcase": false, "constructor": false}, {"identifier": "prepareLocalHints", "parameters": "(DaoTask<?> task, Hints hints)", "modifiers": "public static", "return": "Hints", "signature": "Hints prepareLocalHints(DaoTask<?> task, Hints hints)", "full_signature": "public static Hints prepareLocalHints(DaoTask<?> task, Hints hints)", "class_method_signature": "KeyHolder.prepareLocalHints(DaoTask<?> task, Hints hints)", "testcase": false, "constructor": false}, {"identifier": "mergePartial", "parameters": "(DaoTask<?> task, KeyHolder originalHolder, Integer[] indexList,\n                                    KeyHolder localHolder, Throwable error)", "modifiers": "public static", "return": "void", "signature": "void mergePartial(DaoTask<?> task, KeyHolder originalHolder, Integer[] indexList,\n                                    KeyHolder localHolder, Throwable error)", "full_signature": "public static void mergePartial(DaoTask<?> task, KeyHolder originalHolder, Integer[] indexList,\n                                    KeyHolder localHolder, Throwable error)", "class_method_signature": "KeyHolder.mergePartial(DaoTask<?> task, KeyHolder originalHolder, Integer[] indexList,\n                                    KeyHolder localHolder, Throwable error)", "testcase": false, "constructor": false}, {"identifier": "mergePartial", "parameters": "(DaoTask<?> task, KeyHolder originalHolder, KeyHolder localHolder, Throwable error)", "modifiers": "public static", "return": "void", "signature": "void mergePartial(DaoTask<?> task, KeyHolder originalHolder, KeyHolder localHolder, Throwable error)", "full_signature": "public static void mergePartial(DaoTask<?> task, KeyHolder originalHolder, KeyHolder localHolder, Throwable error)", "class_method_signature": "KeyHolder.mergePartial(DaoTask<?> task, KeyHolder originalHolder, KeyHolder localHolder, Throwable error)", "testcase": false, "constructor": false}, {"identifier": "singleFail", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void singleFail()", "full_signature": "private void singleFail()", "class_method_signature": "KeyHolder.singleFail()", "testcase": false, "constructor": false}, {"identifier": "addEmptyKeys", "parameters": "(int count)", "modifiers": "public", "return": "void", "signature": "void addEmptyKeys(int count)", "full_signature": "public void addEmptyKeys(int count)", "class_method_signature": "KeyHolder.addEmptyKeys(int count)", "testcase": false, "constructor": false}, {"identifier": "createEmptyKeys", "parameters": "()", "modifiers": "private", "return": "Map<String, Object>", "signature": "Map<String, Object> createEmptyKeys()", "full_signature": "private Map<String, Object> createEmptyKeys()", "class_method_signature": "KeyHolder.createEmptyKeys()", "testcase": false, "constructor": false}, {"identifier": "patialFailed", "parameters": "(int partialSize)", "modifiers": "private", "return": "void", "signature": "void patialFailed(int partialSize)", "full_signature": "private void patialFailed(int partialSize)", "class_method_signature": "KeyHolder.patialFailed(int partialSize)", "testcase": false, "constructor": false}, {"identifier": "addPatial", "parameters": "(Integer[] indexList, KeyHolder tmpHolder)", "modifiers": "public", "return": "void", "signature": "void addPatial(Integer[] indexList, KeyHolder tmpHolder)", "full_signature": "public void addPatial(Integer[] indexList, KeyHolder tmpHolder)", "class_method_signature": "KeyHolder.addPatial(Integer[] indexList, KeyHolder tmpHolder)", "testcase": false, "constructor": false}, {"identifier": "deduct", "parameters": "(int size)", "modifiers": "private", "return": "void", "signature": "void deduct(int size)", "full_signature": "private void deduct(int size)", "class_method_signature": "KeyHolder.deduct(int size)", "testcase": false, "constructor": false}, {"identifier": "merge", "parameters": "()", "modifiers": "private synchronized", "return": "void", "signature": "void merge()", "full_signature": "private synchronized void merge()", "class_method_signature": "KeyHolder.merge()", "testcase": false, "constructor": false}, {"identifier": "setGeneratedKeyBack", "parameters": "(DaoTask<?> task, Hints hints, List<?> rawPojos)", "modifiers": "public static", "return": "void", "signature": "void setGeneratedKeyBack(DaoTask<?> task, Hints hints, List<?> rawPojos)", "full_signature": "public static void setGeneratedKeyBack(DaoTask<?> task, Hints hints, List<?> rawPojos)", "class_method_signature": "KeyHolder.setGeneratedKeyBack(DaoTask<?> task, Hints hints, List<?> rawPojos)", "testcase": false, "constructor": false}, {"identifier": "isEmptyKey", "parameters": "(KeyHolder keyHolder, int index)", "modifiers": "private static", "return": "boolean", "signature": "boolean isEmptyKey(KeyHolder keyHolder, int index)", "full_signature": "private static boolean isEmptyKey(KeyHolder keyHolder, int index)", "class_method_signature": "KeyHolder.isEmptyKey(KeyHolder keyHolder, int index)", "testcase": false, "constructor": false}, {"identifier": "setPrimaryKey", "parameters": "(Field pkFlield, Object entity, Number val)", "modifiers": "static", "return": "void", "signature": "void setPrimaryKey(Field pkFlield, Object entity, Number val)", "full_signature": "static void setPrimaryKey(Field pkFlield, Object entity, Number val)", "class_method_signature": "KeyHolder.setPrimaryKey(Field pkFlield, Object entity, Number val)", "testcase": false, "constructor": false}, {"identifier": "setPrimaryKey", "parameters": "(String type, String key, Map entity, Number val)", "modifiers": "static", "return": "void", "signature": "void setPrimaryKey(String type, String key, Map entity, Number val)", "full_signature": "static void setPrimaryKey(String type, String key, Map entity, Number val)", "class_method_signature": "KeyHolder.setPrimaryKey(String type, String key, Map entity, Number val)", "testcase": false, "constructor": false}], "file": "das-client/src/main/java/com/ppdai/das/core/KeyHolder.java"}, "focal_method": {"identifier": "setGeneratedKeyBack", "parameters": "(DaoTask<?> task, Hints hints, List<?> rawPojos)", "modifiers": "public static", "return": "void", "body": "public static void setGeneratedKeyBack(DaoTask<?> task, Hints hints, List<?> rawPojos) throws SQLException {\n        if (!(task instanceof KeyHolderAwaredTask)) {\n            return;\n        }\n\n        KeyHolder keyHolder = hints.getKeyHolder();\n\n        if (keyHolder == null || rawPojos == null || rawPojos.isEmpty()) {\n            return;\n        }\n\n        if (!(hints.is(HintEnum.setIdentityBack) && hints.isIdentityInsertDisabled())) {\n            return;\n        }\n\n        //Handle remote Entities\n        Object obj = rawPojos.get(0);\n        if(obj.getClass() == Entity.class) {\n            Entity entity = (Entity) obj;\n            com.ppdai.das.service.EntityMeta meta = entity.getEntityMeta();\n\n            List<Map<String, Object>> maps = ConvertUtils.entity2POJOs((List<Entity>)rawPojos, meta, Map.class);\n            String key = meta.getPrimaryKeyNames().get(0);\n            String type = meta.getMetaMap().get(key).getType();\n            for (int i = 0; i < rawPojos.size(); i++){\n                if (!isEmptyKey(keyHolder, i)) {\n                    setPrimaryKey(type, key, maps.get(i), keyHolder.getKey(i));\n                    Entity newEntity = ConvertUtils.pojo2Entity(maps.get(i), meta);\n                    ((Entity)rawPojos.get(i)).setValue(newEntity.getValue());\n                }\n            }\n            return;\n        }\n\n        EntityMeta em = EntityMetaManager.extract(rawPojos.get(0).getClass());\n        if (em.getPrimaryKeyNames().length == 0) {\n            throw new IllegalArgumentException(\n                    \"insertIdentityBack only support JPA POJO. Please use code gen to regenerate your POJO\");\n        }\n\n        Field pkFlield = em.getFieldMap().get(em.getPrimaryKeyNames()[0]);\n\n        if (pkFlield == null) {\n            throw new IllegalArgumentException(\n                    \"insertIdentityBack only support JPA POJO. Please use code gen to regenerate your POJO\");\n        }\n\n        for (int i = 0; i < rawPojos.size(); i++) {\n            if (!isEmptyKey(keyHolder, i)) {\n                setPrimaryKey(pkFlield, rawPojos.get(i), keyHolder.getKey(i));\n            }\n        }\n    }", "signature": "void setGeneratedKeyBack(DaoTask<?> task, Hints hints, List<?> rawPojos)", "full_signature": "public static void setGeneratedKeyBack(DaoTask<?> task, Hints hints, List<?> rawPojos)", "class_method_signature": "KeyHolder.setGeneratedKeyBack(DaoTask<?> task, Hints hints, List<?> rawPojos)", "testcase": false, "constructor": false, "invocations": ["getKeyHolder", "isEmpty", "is", "isIdentityInsertDisabled", "get", "getClass", "getEntityMeta", "entity2POJOs", "get", "getPrimaryKeyNames", "getType", "get", "getMetaMap", "size", "isEmptyKey", "setPrimaryKey", "get", "getKey", "pojo2Entity", "get", "setValue", "get", "getValue", "extract", "getClass", "get", "getPrimaryKeyNames", "get", "getFieldMap", "getPrimaryKeyNames", "size", "isEmptyKey", "setPrimaryKey", "get", "getKey"]}, "repository": {"repo_id": 214933909, "url": "https://github.com/ppdaicorp/das", "stars": 55, "created": "10/14/2019 2:49:17 AM +00:00", "updates": "2020-01-20T09:24:23+00:00", "fork": "False", "license": "licensed"}}