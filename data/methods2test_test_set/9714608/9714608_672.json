{"test_class": {"identifier": "DrawersTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static List<Drawer<?>> drawers;", "modifier": "private static", "type": "List<Drawer<?>>", "declarator": "drawers", "var_name": "drawers"}, {"original_string": "public static Class<Drawer<?>>[] DRAWERS = new Class[] {\n\t\t\tContDrawer1.class,\n\t\t\tMyDrawer1.class,\n\t\t\tMyDrawer2.class,\n\t\t\tMyDrawer3.class,\n\t\t\tMyDrawer4.class,\n\t};", "modifier": "public static", "type": "Class<Drawer<?>>[]", "declarator": "DRAWERS = new Class[] {\n\t\t\tContDrawer1.class,\n\t\t\tMyDrawer1.class,\n\t\t\tMyDrawer2.class,\n\t\t\tMyDrawer3.class,\n\t\t\tMyDrawer4.class,\n\t}", "var_name": "DRAWERS"}], "file": "advanced/nodefx/src/test/java/org/arakhne/afc/nodefx/DrawersTest.java"}, "test_case": {"identifier": "getDrawerForClass_01", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void getDrawerForClass_01() {\n\t\tDrawer<String> d1 = Drawers.getDrawerFor(String.class);\n\t\tassertNotNull(d1);\n\t\tassertTrue(d1 instanceof MyDrawer1);\n\t}", "signature": "void getDrawerForClass_01()", "full_signature": "@Test public void getDrawerForClass_01()", "class_method_signature": "DrawersTest.getDrawerForClass_01()", "testcase": true, "constructor": false, "invocations": ["getDrawerFor", "assertNotNull", "assertTrue"]}, "focal_class": {"identifier": "Drawers", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static ServiceLoader<Drawer<?>> services;", "modifier": "private static", "type": "ServiceLoader<Drawer<?>>", "declarator": "services", "var_name": "services"}, {"original_string": "private static Iterable<Drawer<?>> iterable;", "modifier": "private static", "type": "Iterable<Drawer<?>>", "declarator": "iterable", "var_name": "iterable"}, {"original_string": "private static SoftValueTreeMap<Class<?>, Drawer<?>> buffer = new SoftValueTreeMap<>(ClassComparator.SINGLETON);", "modifier": "private static", "type": "SoftValueTreeMap<Class<?>, Drawer<?>>", "declarator": "buffer = new SoftValueTreeMap<>(ClassComparator.SINGLETON)", "var_name": "buffer"}, {"original_string": "private static final AtomicBoolean LOCK = new AtomicBoolean();", "modifier": "private static final", "type": "AtomicBoolean", "declarator": "LOCK = new AtomicBoolean()", "var_name": "LOCK"}], "methods": [{"identifier": "Drawers", "parameters": "()", "modifiers": "private", "return": "", "signature": " Drawers()", "full_signature": "private  Drawers()", "class_method_signature": "Drawers.Drawers()", "testcase": false, "constructor": true}, {"identifier": "getLock", "parameters": "()", "modifiers": "private static", "return": "boolean", "signature": "boolean getLock()", "full_signature": "private static boolean getLock()", "class_method_signature": "Drawers.getLock()", "testcase": false, "constructor": false}, {"identifier": "releaseLock", "parameters": "()", "modifiers": "private static", "return": "boolean", "signature": "boolean releaseLock()", "full_signature": "private static boolean releaseLock()", "class_method_signature": "Drawers.releaseLock()", "testcase": false, "constructor": false}, {"identifier": "reload", "parameters": "()", "modifiers": "public static synchronized", "return": "void", "signature": "void reload()", "full_signature": "public static synchronized void reload()", "class_method_signature": "Drawers.reload()", "testcase": false, "constructor": false}, {"identifier": "getAllDrawers", "parameters": "()", "modifiers": "@Pure public static synchronized", "return": "Iterator<Drawer<?>>", "signature": "Iterator<Drawer<?>> getAllDrawers()", "full_signature": "@Pure public static synchronized Iterator<Drawer<?>> getAllDrawers()", "class_method_signature": "Drawers.getAllDrawers()", "testcase": false, "constructor": false}, {"identifier": "setBackedDrawers", "parameters": "(Iterable<Drawer<?>> drawers)", "modifiers": "public static synchronized", "return": "void", "signature": "void setBackedDrawers(Iterable<Drawer<?>> drawers)", "full_signature": "public static synchronized void setBackedDrawers(Iterable<Drawer<?>> drawers)", "class_method_signature": "Drawers.setBackedDrawers(Iterable<Drawer<?>> drawers)", "testcase": false, "constructor": false}, {"identifier": "getDrawerProvidingService", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") @Pure public static synchronized", "return": "ServiceLoader<Drawer<?>>", "signature": "ServiceLoader<Drawer<?>> getDrawerProvidingService()", "full_signature": "@SuppressWarnings(\"unchecked\") @Pure public static synchronized ServiceLoader<Drawer<?>> getDrawerProvidingService()", "class_method_signature": "Drawers.getDrawerProvidingService()", "testcase": false, "constructor": false}, {"identifier": "getDrawerFor", "parameters": "(Class<? extends T> type)", "modifiers": "@SuppressWarnings(\"unchecked\") @Pure public static synchronized", "return": "Drawer<T>", "signature": "Drawer<T> getDrawerFor(Class<? extends T> type)", "full_signature": "@SuppressWarnings(\"unchecked\") @Pure public static synchronized Drawer<T> getDrawerFor(Class<? extends T> type)", "class_method_signature": "Drawers.getDrawerFor(Class<? extends T> type)", "testcase": false, "constructor": false}, {"identifier": "getDrawerFor", "parameters": "(T instance)", "modifiers": "@Pure @SuppressWarnings(\"unchecked\") public static synchronized", "return": "Drawer<? super T>", "signature": "Drawer<? super T> getDrawerFor(T instance)", "full_signature": "@Pure @SuppressWarnings(\"unchecked\") public static synchronized Drawer<? super T> getDrawerFor(T instance)", "class_method_signature": "Drawers.getDrawerFor(T instance)", "testcase": false, "constructor": false}], "file": "advanced/nodefx/src/main/java/org/arakhne/afc/nodefx/Drawers.java"}, "focal_method": {"identifier": "getDrawerFor", "parameters": "(Class<? extends T> type)", "modifiers": "@SuppressWarnings(\"unchecked\") @Pure public static synchronized", "return": "Drawer<T>", "body": "@SuppressWarnings(\"unchecked\")\n\t@Pure\n\tpublic static synchronized <T> Drawer<T> getDrawerFor(Class<? extends T> type) {\n\t\tassert type != null : AssertMessages.notNullParameter();\n\t\ttry {\n\t\t\tassert getLock();\n\t\t\tfinal Drawer<?> bufferedType = buffer.get(type);\n\t\t\tDrawer<T> choice = null;\n\t\t\tif (bufferedType != null) {\n\t\t\t\tchoice = (Drawer<T>) bufferedType;\n\t\t\t} else {\n\t\t\t\tfinal Iterator<Drawer<?>> iterator = getAllDrawers();\n\t\t\t\tDrawer<?> exactMatcherDrawer = null;\n\t\t\t\tDrawer<?> superMatcherDrawer = null;\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tfinal Drawer<?> drawer = iterator.next();\n\t\t\t\t\tfinal Class<?> drawerType = drawer.getPrimitiveType();\n\t\t\t\t\tif (exactMatcherDrawer != null) {\n\t\t\t\t\t\t// Drawer that is exactly matching the element type is already found.\n\t\t\t\t\t\t// If the new drawer is a subtype of the previous one, the new drawer is used.\n\t\t\t\t\t\tif (drawerType.equals(type)\n\t\t\t\t\t\t\t&& exactMatcherDrawer.getClass().isAssignableFrom(drawer.getClass())) {\n\t\t\t\t\t\t\texactMatcherDrawer = drawer;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (drawerType.equals(type)) {\n\t\t\t\t\t\t// First time a drawer that is exactly matching the element type was found.\n\t\t\t\t\t\texactMatcherDrawer = drawer;\n\t\t\t\t\t} else if (drawerType.isAssignableFrom(type)) {\n\t\t\t\t\t\t// The new drawer is able to support the element type because it could\n\t\t\t\t\t\t// draw elements with a super type of the expected element type.\n\t\t\t\t\t\t// The best choice is the drawer that supports the lowest type into the type hierarchy.\n\t\t\t\t\t\tif (superMatcherDrawer == null\n\t\t\t\t\t\t\t|| (superMatcherDrawer.getPrimitiveType().isAssignableFrom(drawerType))) {\n\t\t\t\t\t\t\tsuperMatcherDrawer = drawer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (exactMatcherDrawer != null) {\n\t\t\t\t\tchoice = (Drawer<T>) exactMatcherDrawer;\n\t\t\t\t} else if (superMatcherDrawer != null) {\n\t\t\t\t\tchoice = (Drawer<T>) superMatcherDrawer;\n\t\t\t\t}\n\t\t\t\t// Memorize for further use.\n\t\t\t\tif (choice != null) {\n\t\t\t\t\tbuffer.put(type, choice);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn choice;\n\t\t} finally {\n\t\t\tassert releaseLock();\n\t\t}\n\t}", "signature": "Drawer<T> getDrawerFor(Class<? extends T> type)", "full_signature": "@SuppressWarnings(\"unchecked\") @Pure public static synchronized Drawer<T> getDrawerFor(Class<? extends T> type)", "class_method_signature": "Drawers.getDrawerFor(Class<? extends T> type)", "testcase": false, "constructor": false, "invocations": ["notNullParameter", "getLock", "get", "getAllDrawers", "hasNext", "next", "getPrimitiveType", "equals", "isAssignableFrom", "getClass", "getClass", "equals", "isAssignableFrom", "isAssignableFrom", "getPrimitiveType", "put", "releaseLock"]}, "repository": {"repo_id": 9714608, "url": "https://github.com/gallandarakhneorg/afc", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 12, "size": 19091, "license": "licensed"}}