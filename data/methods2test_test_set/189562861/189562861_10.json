{"test_class": {"identifier": "ConditionRouterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private URL SCRIPT_URL = URL.valueOf(\"condition://0.0.0.0/com.foo.BarService\");", "modifier": "private", "type": "URL", "declarator": "SCRIPT_URL = URL.valueOf(\"condition://0.0.0.0/com.foo.BarService\")", "var_name": "SCRIPT_URL"}], "file": "dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/router/condition/ConditionRouterTest.java"}, "test_case": {"identifier": "testRoute_Force", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRoute_Force() {\n        Router router = new ConditionRouterFactory().getRouter(getRouteUrl(\"host = \" + NetUtils.getLocalHost() + \" => \" + \" host = 1.2.3.4\").addParameter(Constants.FORCE_KEY, String.valueOf(true)));\n        List<Invoker<String>> invokers = new ArrayList<Invoker<String>>();\n        Invoker<String> invoker1 = new MockInvoker<String>(URL.valueOf(\"dubbo://10.20.3.3:20880/com.foo.BarService\"));\n        Invoker<String> invoker2 = new MockInvoker<String>(URL.valueOf(\"dubbo://\" + NetUtils.getLocalHost() + \":20880/com.foo.BarService\"));\n        Invoker<String> invoker3 = new MockInvoker<String>(URL.valueOf(\"dubbo://\" + NetUtils.getLocalHost() + \":20880/com.foo.BarService\"));\n        invokers.add(invoker1);\n        invokers.add(invoker2);\n        invokers.add(invoker3);\n        List<Invoker<String>> fileredInvokers = router.route(invokers, URL.valueOf(\"consumer://\" + NetUtils.getLocalHost() + \"/com.foo.BarService\"), new RpcInvocation());\n        Assert.assertEquals(0, fileredInvokers.size());\n    }", "signature": "void testRoute_Force()", "full_signature": "@Test public void testRoute_Force()", "class_method_signature": "ConditionRouterTest.testRoute_Force()", "testcase": true, "constructor": false, "invocations": ["getRouter", "addParameter", "getRouteUrl", "getLocalHost", "valueOf", "valueOf", "valueOf", "getLocalHost", "valueOf", "getLocalHost", "add", "add", "add", "route", "valueOf", "getLocalHost", "assertEquals", "size"]}, "focal_class": {"identifier": "ConditionRouter", "superclass": "extends AbstractRouter", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(ConditionRouter.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(ConditionRouter.class)", "var_name": "logger"}, {"original_string": "private static final int DEFAULT_PRIORITY = 2;", "modifier": "private static final", "type": "int", "declarator": "DEFAULT_PRIORITY = 2", "var_name": "DEFAULT_PRIORITY"}, {"original_string": "private static Pattern ROUTE_PATTERN = Pattern.compile(\"([&!=,]*)\\\\s*([^&!=,\\\\s]+)\");", "modifier": "private static", "type": "Pattern", "declarator": "ROUTE_PATTERN = Pattern.compile(\"([&!=,]*)\\\\s*([^&!=,\\\\s]+)\")", "var_name": "ROUTE_PATTERN"}, {"original_string": "private final boolean force;", "modifier": "private final", "type": "boolean", "declarator": "force", "var_name": "force"}, {"original_string": "private final Map<String, MatchPair> whenCondition;", "modifier": "private final", "type": "Map<String, MatchPair>", "declarator": "whenCondition", "var_name": "whenCondition"}, {"original_string": "private final Map<String, MatchPair> thenCondition;", "modifier": "private final", "type": "Map<String, MatchPair>", "declarator": "thenCondition", "var_name": "thenCondition"}], "methods": [{"identifier": "ConditionRouter", "parameters": "(URL url)", "modifiers": "public", "return": "", "signature": " ConditionRouter(URL url)", "full_signature": "public  ConditionRouter(URL url)", "class_method_signature": "ConditionRouter.ConditionRouter(URL url)", "testcase": false, "constructor": true}, {"identifier": "parseRule", "parameters": "(String rule)", "modifiers": "private static", "return": "Map<String, MatchPair>", "signature": "Map<String, MatchPair> parseRule(String rule)", "full_signature": "private static Map<String, MatchPair> parseRule(String rule)", "class_method_signature": "ConditionRouter.parseRule(String rule)", "testcase": false, "constructor": false}, {"identifier": "route", "parameters": "(List<Invoker<T>> invokers, URL url, Invocation invocation)", "modifiers": "@Override public", "return": "List<Invoker<T>>", "signature": "List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)", "full_signature": "@Override public List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)", "class_method_signature": "ConditionRouter.route(List<Invoker<T>> invokers, URL url, Invocation invocation)", "testcase": false, "constructor": false}, {"identifier": "getUrl", "parameters": "()", "modifiers": "@Override public", "return": "URL", "signature": "URL getUrl()", "full_signature": "@Override public URL getUrl()", "class_method_signature": "ConditionRouter.getUrl()", "testcase": false, "constructor": false}, {"identifier": "compareTo", "parameters": "(Router o)", "modifiers": "@Override public", "return": "int", "signature": "int compareTo(Router o)", "full_signature": "@Override public int compareTo(Router o)", "class_method_signature": "ConditionRouter.compareTo(Router o)", "testcase": false, "constructor": false}, {"identifier": "matchWhen", "parameters": "(URL url, Invocation invocation)", "modifiers": "", "return": "boolean", "signature": "boolean matchWhen(URL url, Invocation invocation)", "full_signature": " boolean matchWhen(URL url, Invocation invocation)", "class_method_signature": "ConditionRouter.matchWhen(URL url, Invocation invocation)", "testcase": false, "constructor": false}, {"identifier": "matchThen", "parameters": "(URL url, URL param)", "modifiers": "private", "return": "boolean", "signature": "boolean matchThen(URL url, URL param)", "full_signature": "private boolean matchThen(URL url, URL param)", "class_method_signature": "ConditionRouter.matchThen(URL url, URL param)", "testcase": false, "constructor": false}, {"identifier": "matchCondition", "parameters": "(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation)", "modifiers": "private", "return": "boolean", "signature": "boolean matchCondition(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation)", "full_signature": "private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation)", "class_method_signature": "ConditionRouter.matchCondition(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation)", "testcase": false, "constructor": false}], "file": "dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/router/condition/ConditionRouter.java"}, "focal_method": {"identifier": "route", "parameters": "(List<Invoker<T>> invokers, URL url, Invocation invocation)", "modifiers": "@Override public", "return": "List<Invoker<T>>", "body": "@Override\n    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)\n            throws RpcException {\n        if (invokers == null || invokers.isEmpty()) {\n            return invokers;\n        }\n        try {\n            if (!matchWhen(url, invocation)) {\n                return invokers;\n            }\n            List<Invoker<T>> result = new ArrayList<Invoker<T>>();\n            if (thenCondition == null) {\n                logger.warn(\"The current consumer in the service blacklist. consumer: \" + NetUtils.getLocalHost() + \", service: \" + url.getServiceKey());\n                return result;\n            }\n            for (Invoker<T> invoker : invokers) {\n                if (matchThen(invoker.getUrl(), url)) {\n                    result.add(invoker);\n                }\n            }\n            if (!result.isEmpty()) {\n                return result;\n            } else if (force) {\n                logger.warn(\"The route result is empty and force execute. consumer: \" + NetUtils.getLocalHost() + \", service: \" + url.getServiceKey() + \", router: \" + url.getParameterAndDecoded(Constants.RULE_KEY));\n                return result;\n            }\n        } catch (Throwable t) {\n            logger.error(\"Failed to execute condition router rule: \" + getUrl() + \", invokers: \" + invokers + \", cause: \" + t.getMessage(), t);\n        }\n        return invokers;\n    }", "signature": "List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)", "full_signature": "@Override public List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)", "class_method_signature": "ConditionRouter.route(List<Invoker<T>> invokers, URL url, Invocation invocation)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "matchWhen", "warn", "getLocalHost", "getServiceKey", "matchThen", "getUrl", "add", "isEmpty", "warn", "getLocalHost", "getServiceKey", "getParameterAndDecoded", "error", "getUrl", "getMessage"]}, "repository": {"repo_id": 189562861, "url": "https://github.com/smallFive55/dubbo-dubbo-2.6.6", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 8, "size": 1428, "license": "licensed"}}