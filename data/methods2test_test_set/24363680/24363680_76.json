{"test_class": {"identifier": "UtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "core/src/test/java/com/google/bitcoin/core/UtilsTest.java"}, "test_case": {"identifier": "testToNanoCoins", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testToNanoCoins() {\n        // String version\n        assertEquals(CENT, toNanoCoins(\"0.01\"));\n        assertEquals(CENT, toNanoCoins(\"1E-2\"));\n        assertEquals(COIN.add(Utils.CENT), toNanoCoins(\"1.01\"));\n        try {\n            toNanoCoins(\"2E-20\");\n            org.junit.Assert.fail(\"should not have accepted fractional nanocoins\");\n        } catch (ArithmeticException e) {\n        }\n\n        // int version\n        assertEquals(CENT, toNanoCoins(0, 1));\n\n        try {\n            toNanoCoins(1, -1);\n            fail();\n        } catch (IllegalArgumentException e) {}\n        try {\n            toNanoCoins(-1, 0);\n            fail();\n        } catch (IllegalArgumentException e) {}\n        try {\n            toNanoCoins(\"-1\");\n            fail();\n        } catch (ArithmeticException e) {}\n    }", "signature": "void testToNanoCoins()", "full_signature": "@Test public void testToNanoCoins()", "class_method_signature": "UtilsTest.testToNanoCoins()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "toNanoCoins", "assertEquals", "toNanoCoins", "assertEquals", "add", "toNanoCoins", "toNanoCoins", "fail", "assertEquals", "toNanoCoins", "toNanoCoins", "fail", "toNanoCoins", "fail", "toNanoCoins", "fail"]}, "focal_class": {"identifier": "Utils", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final BigInteger NEGATIVE_ONE = BigInteger.valueOf(-1);", "modifier": "public static final", "type": "BigInteger", "declarator": "NEGATIVE_ONE = BigInteger.valueOf(-1)", "var_name": "NEGATIVE_ONE"}, {"original_string": "private static final MessageDigest digest;", "modifier": "private static final", "type": "MessageDigest", "declarator": "digest", "var_name": "digest"}, {"original_string": "public static final String BITCOIN_SIGNED_MESSAGE_HEADER = CoinDefinition.coinName + \" Signed Message:\\n\";", "modifier": "public static final", "type": "String", "declarator": "BITCOIN_SIGNED_MESSAGE_HEADER = CoinDefinition.coinName + \" Signed Message:\\n\"", "var_name": "BITCOIN_SIGNED_MESSAGE_HEADER"}, {"original_string": "public static final byte[] BITCOIN_SIGNED_MESSAGE_HEADER_BYTES = BITCOIN_SIGNED_MESSAGE_HEADER.getBytes(Charsets.UTF_8);", "modifier": "public static final", "type": "byte[]", "declarator": "BITCOIN_SIGNED_MESSAGE_HEADER_BYTES = BITCOIN_SIGNED_MESSAGE_HEADER.getBytes(Charsets.UTF_8)", "var_name": "BITCOIN_SIGNED_MESSAGE_HEADER_BYTES"}, {"original_string": "public static final BigInteger COIN = new BigInteger(\"100000000\", 10);", "modifier": "public static final", "type": "BigInteger", "declarator": "COIN = new BigInteger(\"100000000\", 10)", "var_name": "COIN"}, {"original_string": "public static final BigInteger CENT = new BigInteger(\"1000000\", 10);", "modifier": "public static final", "type": "BigInteger", "declarator": "CENT = new BigInteger(\"1000000\", 10)", "var_name": "CENT"}, {"original_string": "private static BlockingQueue<Boolean> mockSleepQueue;", "modifier": "private static", "type": "BlockingQueue<Boolean>", "declarator": "mockSleepQueue", "var_name": "mockSleepQueue"}, {"original_string": "public static volatile Date mockTime;", "modifier": "public static volatile", "type": "Date", "declarator": "mockTime", "var_name": "mockTime"}, {"original_string": "private static final int bitMask[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};", "modifier": "private static final", "type": "int", "declarator": "bitMask[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80}", "var_name": "bitMask"}], "methods": [{"identifier": "toNanoCoins", "parameters": "(int coins, int cents)", "modifiers": "public static", "return": "BigInteger", "signature": "BigInteger toNanoCoins(int coins, int cents)", "full_signature": "public static BigInteger toNanoCoins(int coins, int cents)", "class_method_signature": "Utils.toNanoCoins(int coins, int cents)", "testcase": false, "constructor": false}, {"identifier": "bigIntegerToBytes", "parameters": "(BigInteger b, int numBytes)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] bigIntegerToBytes(BigInteger b, int numBytes)", "full_signature": "public static byte[] bigIntegerToBytes(BigInteger b, int numBytes)", "class_method_signature": "Utils.bigIntegerToBytes(BigInteger b, int numBytes)", "testcase": false, "constructor": false}, {"identifier": "toNanoCoins", "parameters": "(String coins)", "modifiers": "public static", "return": "BigInteger", "signature": "BigInteger toNanoCoins(String coins)", "full_signature": "public static BigInteger toNanoCoins(String coins)", "class_method_signature": "Utils.toNanoCoins(String coins)", "testcase": false, "constructor": false}, {"identifier": "uint32ToByteArrayBE", "parameters": "(long val, byte[] out, int offset)", "modifiers": "public static", "return": "void", "signature": "void uint32ToByteArrayBE(long val, byte[] out, int offset)", "full_signature": "public static void uint32ToByteArrayBE(long val, byte[] out, int offset)", "class_method_signature": "Utils.uint32ToByteArrayBE(long val, byte[] out, int offset)", "testcase": false, "constructor": false}, {"identifier": "uint32ToByteArrayLE", "parameters": "(long val, byte[] out, int offset)", "modifiers": "public static", "return": "void", "signature": "void uint32ToByteArrayLE(long val, byte[] out, int offset)", "full_signature": "public static void uint32ToByteArrayLE(long val, byte[] out, int offset)", "class_method_signature": "Utils.uint32ToByteArrayLE(long val, byte[] out, int offset)", "testcase": false, "constructor": false}, {"identifier": "uint64ToByteArrayLE", "parameters": "(long val, byte[] out, int offset)", "modifiers": "public static", "return": "void", "signature": "void uint64ToByteArrayLE(long val, byte[] out, int offset)", "full_signature": "public static void uint64ToByteArrayLE(long val, byte[] out, int offset)", "class_method_signature": "Utils.uint64ToByteArrayLE(long val, byte[] out, int offset)", "testcase": false, "constructor": false}, {"identifier": "uint32ToByteStreamLE", "parameters": "(long val, OutputStream stream)", "modifiers": "public static", "return": "void", "signature": "void uint32ToByteStreamLE(long val, OutputStream stream)", "full_signature": "public static void uint32ToByteStreamLE(long val, OutputStream stream)", "class_method_signature": "Utils.uint32ToByteStreamLE(long val, OutputStream stream)", "testcase": false, "constructor": false}, {"identifier": "int64ToByteStreamLE", "parameters": "(long val, OutputStream stream)", "modifiers": "public static", "return": "void", "signature": "void int64ToByteStreamLE(long val, OutputStream stream)", "full_signature": "public static void int64ToByteStreamLE(long val, OutputStream stream)", "class_method_signature": "Utils.int64ToByteStreamLE(long val, OutputStream stream)", "testcase": false, "constructor": false}, {"identifier": "uint64ToByteStreamLE", "parameters": "(BigInteger val, OutputStream stream)", "modifiers": "public static", "return": "void", "signature": "void uint64ToByteStreamLE(BigInteger val, OutputStream stream)", "full_signature": "public static void uint64ToByteStreamLE(BigInteger val, OutputStream stream)", "class_method_signature": "Utils.uint64ToByteStreamLE(BigInteger val, OutputStream stream)", "testcase": false, "constructor": false}, {"identifier": "doubleDigest", "parameters": "(byte[] input)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] doubleDigest(byte[] input)", "full_signature": "public static byte[] doubleDigest(byte[] input)", "class_method_signature": "Utils.doubleDigest(byte[] input)", "testcase": false, "constructor": false}, {"identifier": "scryptDigest", "parameters": "(byte[] input)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] scryptDigest(byte[] input)", "full_signature": "public static byte[] scryptDigest(byte[] input)", "class_method_signature": "Utils.scryptDigest(byte[] input)", "testcase": false, "constructor": false}, {"identifier": "doubleDigest", "parameters": "(byte[] input, int offset, int length)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] doubleDigest(byte[] input, int offset, int length)", "full_signature": "public static byte[] doubleDigest(byte[] input, int offset, int length)", "class_method_signature": "Utils.doubleDigest(byte[] input, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "singleDigest", "parameters": "(byte[] input, int offset, int length)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] singleDigest(byte[] input, int offset, int length)", "full_signature": "public static byte[] singleDigest(byte[] input, int offset, int length)", "class_method_signature": "Utils.singleDigest(byte[] input, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "doubleDigestTwoBuffers", "parameters": "(byte[] input1, int offset1, int length1,\n                                                byte[] input2, int offset2, int length2)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] doubleDigestTwoBuffers(byte[] input1, int offset1, int length1,\n                                                byte[] input2, int offset2, int length2)", "full_signature": "public static byte[] doubleDigestTwoBuffers(byte[] input1, int offset1, int length1,\n                                                byte[] input2, int offset2, int length2)", "class_method_signature": "Utils.doubleDigestTwoBuffers(byte[] input1, int offset1, int length1,\n                                                byte[] input2, int offset2, int length2)", "testcase": false, "constructor": false}, {"identifier": "isLessThanUnsigned", "parameters": "(long n1, long n2)", "modifiers": "public static", "return": "boolean", "signature": "boolean isLessThanUnsigned(long n1, long n2)", "full_signature": "public static boolean isLessThanUnsigned(long n1, long n2)", "class_method_signature": "Utils.isLessThanUnsigned(long n1, long n2)", "testcase": false, "constructor": false}, {"identifier": "bytesToHexString", "parameters": "(byte[] bytes)", "modifiers": "public static", "return": "String", "signature": "String bytesToHexString(byte[] bytes)", "full_signature": "public static String bytesToHexString(byte[] bytes)", "class_method_signature": "Utils.bytesToHexString(byte[] bytes)", "testcase": false, "constructor": false}, {"identifier": "reverseBytes", "parameters": "(byte[] bytes)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] reverseBytes(byte[] bytes)", "full_signature": "public static byte[] reverseBytes(byte[] bytes)", "class_method_signature": "Utils.reverseBytes(byte[] bytes)", "testcase": false, "constructor": false}, {"identifier": "reverseDwordBytes", "parameters": "(byte[] bytes, int trimLength)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] reverseDwordBytes(byte[] bytes, int trimLength)", "full_signature": "public static byte[] reverseDwordBytes(byte[] bytes, int trimLength)", "class_method_signature": "Utils.reverseDwordBytes(byte[] bytes, int trimLength)", "testcase": false, "constructor": false}, {"identifier": "readUint32", "parameters": "(byte[] bytes, int offset)", "modifiers": "public static", "return": "long", "signature": "long readUint32(byte[] bytes, int offset)", "full_signature": "public static long readUint32(byte[] bytes, int offset)", "class_method_signature": "Utils.readUint32(byte[] bytes, int offset)", "testcase": false, "constructor": false}, {"identifier": "readInt64", "parameters": "(byte[] bytes, int offset)", "modifiers": "public static", "return": "long", "signature": "long readInt64(byte[] bytes, int offset)", "full_signature": "public static long readInt64(byte[] bytes, int offset)", "class_method_signature": "Utils.readInt64(byte[] bytes, int offset)", "testcase": false, "constructor": false}, {"identifier": "readUint32BE", "parameters": "(byte[] bytes, int offset)", "modifiers": "public static", "return": "long", "signature": "long readUint32BE(byte[] bytes, int offset)", "full_signature": "public static long readUint32BE(byte[] bytes, int offset)", "class_method_signature": "Utils.readUint32BE(byte[] bytes, int offset)", "testcase": false, "constructor": false}, {"identifier": "readUint16BE", "parameters": "(byte[] bytes, int offset)", "modifiers": "public static", "return": "int", "signature": "int readUint16BE(byte[] bytes, int offset)", "full_signature": "public static int readUint16BE(byte[] bytes, int offset)", "class_method_signature": "Utils.readUint16BE(byte[] bytes, int offset)", "testcase": false, "constructor": false}, {"identifier": "sha256hash160", "parameters": "(byte[] input)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] sha256hash160(byte[] input)", "full_signature": "public static byte[] sha256hash160(byte[] input)", "class_method_signature": "Utils.sha256hash160(byte[] input)", "testcase": false, "constructor": false}, {"identifier": "bitcoinValueToFriendlyString", "parameters": "(BigInteger value)", "modifiers": "public static", "return": "String", "signature": "String bitcoinValueToFriendlyString(BigInteger value)", "full_signature": "public static String bitcoinValueToFriendlyString(BigInteger value)", "class_method_signature": "Utils.bitcoinValueToFriendlyString(BigInteger value)", "testcase": false, "constructor": false}, {"identifier": "bitcoinValueToPlainString", "parameters": "(BigInteger value)", "modifiers": "public static", "return": "String", "signature": "String bitcoinValueToPlainString(BigInteger value)", "full_signature": "public static String bitcoinValueToPlainString(BigInteger value)", "class_method_signature": "Utils.bitcoinValueToPlainString(BigInteger value)", "testcase": false, "constructor": false}, {"identifier": "decodeMPI", "parameters": "(byte[] mpi, boolean hasLength)", "modifiers": "public static", "return": "BigInteger", "signature": "BigInteger decodeMPI(byte[] mpi, boolean hasLength)", "full_signature": "public static BigInteger decodeMPI(byte[] mpi, boolean hasLength)", "class_method_signature": "Utils.decodeMPI(byte[] mpi, boolean hasLength)", "testcase": false, "constructor": false}, {"identifier": "encodeMPI", "parameters": "(BigInteger value, boolean includeLength)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeMPI(BigInteger value, boolean includeLength)", "full_signature": "public static byte[] encodeMPI(BigInteger value, boolean includeLength)", "class_method_signature": "Utils.encodeMPI(BigInteger value, boolean includeLength)", "testcase": false, "constructor": false}, {"identifier": "decodeCompactBits", "parameters": "(long compact)", "modifiers": "public static", "return": "BigInteger", "signature": "BigInteger decodeCompactBits(long compact)", "full_signature": "public static BigInteger decodeCompactBits(long compact)", "class_method_signature": "Utils.decodeCompactBits(long compact)", "testcase": false, "constructor": false}, {"identifier": "rollMockClock", "parameters": "(int seconds)", "modifiers": "public static", "return": "Date", "signature": "Date rollMockClock(int seconds)", "full_signature": "public static Date rollMockClock(int seconds)", "class_method_signature": "Utils.rollMockClock(int seconds)", "testcase": false, "constructor": false}, {"identifier": "rollMockClockMillis", "parameters": "(long millis)", "modifiers": "public static", "return": "Date", "signature": "Date rollMockClockMillis(long millis)", "full_signature": "public static Date rollMockClockMillis(long millis)", "class_method_signature": "Utils.rollMockClockMillis(long millis)", "testcase": false, "constructor": false}, {"identifier": "setMockClock", "parameters": "(long mockClock)", "modifiers": "public static", "return": "void", "signature": "void setMockClock(long mockClock)", "full_signature": "public static void setMockClock(long mockClock)", "class_method_signature": "Utils.setMockClock(long mockClock)", "testcase": false, "constructor": false}, {"identifier": "now", "parameters": "()", "modifiers": "public static", "return": "Date", "signature": "Date now()", "full_signature": "public static Date now()", "class_method_signature": "Utils.now()", "testcase": false, "constructor": false}, {"identifier": "currentTimeMillis", "parameters": "()", "modifiers": "public static", "return": "long", "signature": "long currentTimeMillis()", "full_signature": "public static long currentTimeMillis()", "class_method_signature": "Utils.currentTimeMillis()", "testcase": false, "constructor": false}, {"identifier": "copyOf", "parameters": "(byte[] in, int length)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] copyOf(byte[] in, int length)", "full_signature": "public static byte[] copyOf(byte[] in, int length)", "class_method_signature": "Utils.copyOf(byte[] in, int length)", "testcase": false, "constructor": false}, {"identifier": "appendByte", "parameters": "(byte[] bytes, byte b)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] appendByte(byte[] bytes, byte b)", "full_signature": "public static byte[] appendByte(byte[] bytes, byte b)", "class_method_signature": "Utils.appendByte(byte[] bytes, byte b)", "testcase": false, "constructor": false}, {"identifier": "parseAsHexOrBase58", "parameters": "(String data)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] parseAsHexOrBase58(String data)", "full_signature": "public static byte[] parseAsHexOrBase58(String data)", "class_method_signature": "Utils.parseAsHexOrBase58(String data)", "testcase": false, "constructor": false}, {"identifier": "isWindows", "parameters": "()", "modifiers": "public static", "return": "boolean", "signature": "boolean isWindows()", "full_signature": "public static boolean isWindows()", "class_method_signature": "Utils.isWindows()", "testcase": false, "constructor": false}, {"identifier": "formatMessageForSigning", "parameters": "(String message)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] formatMessageForSigning(String message)", "full_signature": "public static byte[] formatMessageForSigning(String message)", "class_method_signature": "Utils.formatMessageForSigning(String message)", "testcase": false, "constructor": false}, {"identifier": "checkBitLE", "parameters": "(byte[] data, int index)", "modifiers": "public static", "return": "boolean", "signature": "boolean checkBitLE(byte[] data, int index)", "full_signature": "public static boolean checkBitLE(byte[] data, int index)", "class_method_signature": "Utils.checkBitLE(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "setBitLE", "parameters": "(byte[] data, int index)", "modifiers": "public static", "return": "void", "signature": "void setBitLE(byte[] data, int index)", "full_signature": "public static void setBitLE(byte[] data, int index)", "class_method_signature": "Utils.setBitLE(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "sleep", "parameters": "(long millis)", "modifiers": "public static", "return": "void", "signature": "void sleep(long millis)", "full_signature": "public static void sleep(long millis)", "class_method_signature": "Utils.sleep(long millis)", "testcase": false, "constructor": false}, {"identifier": "setMockSleep", "parameters": "(boolean isEnable)", "modifiers": "public static", "return": "void", "signature": "void setMockSleep(boolean isEnable)", "full_signature": "public static void setMockSleep(boolean isEnable)", "class_method_signature": "Utils.setMockSleep(boolean isEnable)", "testcase": false, "constructor": false}, {"identifier": "passMockSleep", "parameters": "()", "modifiers": "public static", "return": "void", "signature": "void passMockSleep()", "full_signature": "public static void passMockSleep()", "class_method_signature": "Utils.passMockSleep()", "testcase": false, "constructor": false}, {"identifier": "finishMockSleep", "parameters": "()", "modifiers": "public static", "return": "void", "signature": "void finishMockSleep()", "full_signature": "public static void finishMockSleep()", "class_method_signature": "Utils.finishMockSleep()", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/google/bitcoin/core/Utils.java"}, "focal_method": {"identifier": "toNanoCoins", "parameters": "(int coins, int cents)", "modifiers": "public static", "return": "BigInteger", "body": "public static BigInteger toNanoCoins(int coins, int cents) {\n        checkArgument(cents < 100);\n        checkArgument(cents >= 0);\n        checkArgument(coins >= 0);\n        checkArgument(coins < NetworkParameters.MAX_MONEY.divide(Utils.COIN).longValue());\n        BigInteger bi = BigInteger.valueOf(coins).multiply(COIN);\n        bi = bi.add(BigInteger.valueOf(cents).multiply(CENT));\n        return bi;\n    }", "signature": "BigInteger toNanoCoins(int coins, int cents)", "full_signature": "public static BigInteger toNanoCoins(int coins, int cents)", "class_method_signature": "Utils.toNanoCoins(int coins, int cents)", "testcase": false, "constructor": false, "invocations": ["checkArgument", "checkArgument", "checkArgument", "checkArgument", "longValue", "divide", "multiply", "valueOf", "add", "multiply", "valueOf"]}, "repository": {"repo_id": 24363680, "url": "https://github.com/cannabiscoindev/cannabiscoinj", "language": "Java", "is_fork": false, "fork_count": 9, "stargazer_count": 5, "size": 10126, "license": "licensed"}}