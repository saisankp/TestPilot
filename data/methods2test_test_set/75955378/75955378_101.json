{"test_class": {"identifier": "OperationProcessorTest", "superclass": "", "interfaces": "", "fields": [], "file": "core/src/test/java/com/nextdoor/bender/operation/OperationProcessorTest.java"}, "test_case": {"identifier": "testNullDeserializedEventFiltering", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testNullDeserializedEventFiltering()\n      throws JsonSyntaxException, UnsupportedEncodingException, IOException, OperationException {\n    /*\n     * Setup mocks for test\n     */\n    DummyOperation op = spy(new DummyOperation());\n    InternalEvent retEvent = new InternalEvent(\"foo\", null, 1);\n    retEvent.setEventObj(null);\n    when(op.perform(any(InternalEvent.class))).thenReturn(retEvent);\n    DummyOperationFactory operationFactory = new DummyOperationFactory(op);\n    OperationProcessor processor = new OperationProcessor(operationFactory);\n\n    /*\n     * Do call\n     */\n    Stream<InternalEvent> stream = processor.perform(Stream.of(new InternalEvent(\"foo\", null, 1)));\n    List<InternalEvent> output = stream.collect(Collectors.toList());\n\n    /*\n     * Verify nothing came out\n     */\n    assertEquals(0, output.size());\n  }", "signature": "void testNullDeserializedEventFiltering()", "full_signature": "@Test public void testNullDeserializedEventFiltering()", "class_method_signature": "OperationProcessorTest.testNullDeserializedEventFiltering()", "testcase": true, "constructor": false, "invocations": ["spy", "setEventObj", "thenReturn", "when", "perform", "any", "perform", "of", "collect", "toList", "assertEquals", "size"]}, "focal_class": {"identifier": "OperationProcessor", "superclass": "extends MonitoredProcess", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = Logger.getLogger(OperationProcessor.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = Logger.getLogger(OperationProcessor.class)", "var_name": "logger"}, {"original_string": "private BaseOperation op;", "modifier": "private", "type": "BaseOperation", "declarator": "op", "var_name": "op"}], "methods": [{"identifier": "OperationProcessor", "parameters": "(OperationFactory operationFactory)", "modifiers": "public", "return": "", "signature": " OperationProcessor(OperationFactory operationFactory)", "full_signature": "public  OperationProcessor(OperationFactory operationFactory)", "class_method_signature": "OperationProcessor.OperationProcessor(OperationFactory operationFactory)", "testcase": false, "constructor": true}, {"identifier": "perform", "parameters": "(Stream<InternalEvent> input)", "modifiers": "public", "return": "Stream<InternalEvent>", "signature": "Stream<InternalEvent> perform(Stream<InternalEvent> input)", "full_signature": "public Stream<InternalEvent> perform(Stream<InternalEvent> input)", "class_method_signature": "OperationProcessor.perform(Stream<InternalEvent> input)", "testcase": false, "constructor": false}, {"identifier": "getOperation", "parameters": "()", "modifiers": "public", "return": "BaseOperation", "signature": "BaseOperation getOperation()", "full_signature": "public BaseOperation getOperation()", "class_method_signature": "OperationProcessor.getOperation()", "testcase": false, "constructor": false}, {"identifier": "setOperation", "parameters": "(EventOperation operation)", "modifiers": "public", "return": "void", "signature": "void setOperation(EventOperation operation)", "full_signature": "public void setOperation(EventOperation operation)", "class_method_signature": "OperationProcessor.setOperation(EventOperation operation)", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/nextdoor/bender/operation/OperationProcessor.java"}, "focal_method": {"identifier": "perform", "parameters": "(Stream<InternalEvent> input)", "modifiers": "public", "return": "Stream<InternalEvent>", "body": "public Stream<InternalEvent> perform(Stream<InternalEvent> input) {\n    Stream<InternalEvent> output = null;\n\n    if (this.op instanceof EventOperation) {\n      output = input.map(ievent -> {\n        this.getRuntimeStat().start();\n        try {\n          InternalEvent i = ((EventOperation) op).perform(ievent);\n          this.getSuccessCountStat().increment();\n          return i;\n        } catch (OperationException e) {\n          this.getErrorCountStat().increment();\n          logger.warn(e);\n          return null;\n        } finally {\n          this.getRuntimeStat().stop();\n        }\n      });\n    } else if (this.op instanceof MultiplexOperation) {\n      /*\n       * MultiplexOperations require the use of flatmap which allows a single stream item to produce\n       * multiple results.\n       */\n      output = input.flatMap(ievent -> {\n        this.getRuntimeStat().start();\n        try {\n          Stream<InternalEvent> s = ((MultiplexOperation) op).perform(ievent).stream();\n          this.getSuccessCountStat().increment();\n          return s;\n        } catch (OperationException e) {\n          this.getErrorCountStat().increment();\n          logger.warn(e);\n          return Stream.empty();\n        } finally {\n          this.getRuntimeStat().stop();\n        }\n      });\n    } else if (this.op instanceof StreamOperation) {\n      StreamOperation forkOp = (StreamOperation) this.op;\n      output = forkOp.getOutputStream(input);\n    } else if (this.op instanceof FilterOperation) {\n      output = input.filter(ievent -> {\n        try {\n          return ((FilterOperation) this.op).test(ievent);\n        } catch (OperationException e) {\n          this.getErrorCountStat().increment();\n          logger.warn(e);\n          return false;\n        } finally {\n          this.getRuntimeStat().stop();\n        }\n      });\n    } else {\n      throw new OperationException(\"Invalid type of operation\");\n    }\n\n    /*\n     * Filter out events if an operation did something that resulted in a null event or payload.\n     * This protects future operations from running on invalid data.\n     */\n    return output.filter(ievent -> {\n      if (ievent == null) {\n        logger.warn(op.getClass().getName() + \" produced a null InternalEvent\");\n        return false;\n      }\n      if (ievent.getEventObj() == null) {\n        logger.warn(op.getClass().getName() + \" produced a null DeserializedEvent\");\n        return false;\n      }\n      if (ievent.getEventObj().getPayload() == null) {\n        logger.warn(op.getClass().getName() + \" produced a null DeserializedEvent payload\");\n        return false;\n      }\n\n      return true;\n    });\n  }", "signature": "Stream<InternalEvent> perform(Stream<InternalEvent> input)", "full_signature": "public Stream<InternalEvent> perform(Stream<InternalEvent> input)", "class_method_signature": "OperationProcessor.perform(Stream<InternalEvent> input)", "testcase": false, "constructor": false, "invocations": ["map", "start", "getRuntimeStat", "perform", "increment", "getSuccessCountStat", "increment", "getErrorCountStat", "warn", "stop", "getRuntimeStat", "flatMap", "start", "getRuntimeStat", "stream", "perform", "increment", "getSuccessCountStat", "increment", "getErrorCountStat", "warn", "empty", "stop", "getRuntimeStat", "getOutputStream", "filter", "test", "increment", "getErrorCountStat", "warn", "stop", "getRuntimeStat", "filter", "warn", "getName", "getClass", "getEventObj", "warn", "getName", "getClass", "getPayload", "getEventObj", "warn", "getName", "getClass"]}, "repository": {"repo_id": 75955378, "url": "https://github.com/Nextdoor/bender", "language": "Java", "is_fork": false, "fork_count": 15, "stargazer_count": 163, "size": 1503, "license": "licensed"}}