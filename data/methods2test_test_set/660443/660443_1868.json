{"test_class": {"identifier": "AbbreviationsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static SmilesParser smipar = new SmilesParser(SilentChemObjectBuilder.getInstance());", "modifier": "private static", "type": "SmilesParser", "declarator": "smipar = new SmilesParser(SilentChemObjectBuilder.getInstance())", "var_name": "smipar"}], "file": "app/depict/src/test/java/org/openscience/cdk/depict/AbbreviationsTest.java"}, "test_case": {"identifier": "HOOH", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void HOOH() throws Exception {\n        Abbreviations factory = new Abbreviations();\n        IAtomContainer mol = smi(\"OO\");\n        List<Sgroup> sgroups = factory.generate(mol);\n        assertThat(sgroups.size(), is(1));\n        assertThat(sgroups.get(0).getSubscript(), is(\"HOOH\"));\n    }", "signature": "void HOOH()", "full_signature": "@Test public void HOOH()", "class_method_signature": "AbbreviationsTest.HOOH()", "testcase": true, "constructor": false, "invocations": ["smi", "generate", "assertThat", "size", "is", "assertThat", "getSubscript", "get", "is"]}, "focal_class": {"identifier": "Abbreviations", "superclass": "", "interfaces": "implements Iterable<String>", "fields": [{"original_string": "private static final int MAX_FRAG = 50;", "modifier": "private static final", "type": "int", "declarator": "MAX_FRAG = 50", "var_name": "MAX_FRAG"}, {"original_string": "private static final String INTERPUNCT = \"\u00b7\";", "modifier": "private static final", "type": "String", "declarator": "INTERPUNCT = \"\u00b7\";", "var_name": "INTERPUNCT"}, {"original_string": "private final Map<String, String> connectedAbbreviations    = new LinkedHashMap<>();", "modifier": "private final", "type": "Map<String, String>", "declarator": "connectedAbbreviations    = new LinkedHashMap<>()", "var_name": "connectedAbbreviations"}, {"original_string": "private final Map<String, String> disconnectedAbbreviations = new LinkedHashMap<>();", "modifier": "private final", "type": "Map<String, String>", "declarator": "disconnectedAbbreviations = new LinkedHashMap<>()", "var_name": "disconnectedAbbreviations"}, {"original_string": "private final Set<String>         labels                    = new LinkedHashSet<>();", "modifier": "private final", "type": "Set<String>", "declarator": "labels                    = new LinkedHashSet<>()", "var_name": "labels"}, {"original_string": "private final Set<String>         disabled                  = new HashSet<>();", "modifier": "private final", "type": "Set<String>", "declarator": "disabled                  = new HashSet<>()", "var_name": "disabled"}, {"original_string": "private final SmilesGenerator     usmigen                   = SmilesGenerator.unique();", "modifier": "private final", "type": "SmilesGenerator", "declarator": "usmigen                   = SmilesGenerator.unique()", "var_name": "usmigen"}, {"original_string": "private final SmilesParser smipar = new SmilesParser(SilentChemObjectBuilder.getInstance());", "modifier": "private final", "type": "SmilesParser", "declarator": "smipar = new SmilesParser(SilentChemObjectBuilder.getInstance())", "var_name": "smipar"}, {"original_string": "private boolean contractOnHetero = true;", "modifier": "private", "type": "boolean", "declarator": "contractOnHetero = true", "var_name": "contractOnHetero"}, {"original_string": "private boolean contractSingleFragments = false;", "modifier": "private", "type": "boolean", "declarator": "contractSingleFragments = false", "var_name": "contractSingleFragments"}, {"original_string": "private static final String CUT_BOND = \"cutbond\";", "modifier": "private static final", "type": "String", "declarator": "CUT_BOND = \"cutbond\"", "var_name": "CUT_BOND"}], "methods": [{"identifier": "Abbreviations", "parameters": "()", "modifiers": "public", "return": "", "signature": " Abbreviations()", "full_signature": "public  Abbreviations()", "class_method_signature": "Abbreviations.Abbreviations()", "testcase": false, "constructor": true}, {"identifier": "iterator", "parameters": "()", "modifiers": "@Override public", "return": "Iterator<String>", "signature": "Iterator<String> iterator()", "full_signature": "@Override public Iterator<String> iterator()", "class_method_signature": "Abbreviations.iterator()", "testcase": false, "constructor": false}, {"identifier": "isEnabled", "parameters": "(final String label)", "modifiers": "public", "return": "boolean", "signature": "boolean isEnabled(final String label)", "full_signature": "public boolean isEnabled(final String label)", "class_method_signature": "Abbreviations.isEnabled(final String label)", "testcase": false, "constructor": false}, {"identifier": "setEnabled", "parameters": "(String label, boolean enabled)", "modifiers": "public", "return": "boolean", "signature": "boolean setEnabled(String label, boolean enabled)", "full_signature": "public boolean setEnabled(String label, boolean enabled)", "class_method_signature": "Abbreviations.setEnabled(String label, boolean enabled)", "testcase": false, "constructor": false}, {"identifier": "setContractOnHetero", "parameters": "(boolean val)", "modifiers": "public", "return": "void", "signature": "void setContractOnHetero(boolean val)", "full_signature": "public void setContractOnHetero(boolean val)", "class_method_signature": "Abbreviations.setContractOnHetero(boolean val)", "testcase": false, "constructor": false}, {"identifier": "setContractToSingleLabel", "parameters": "(boolean val)", "modifiers": "public", "return": "void", "signature": "void setContractToSingleLabel(boolean val)", "full_signature": "public void setContractToSingleLabel(boolean val)", "class_method_signature": "Abbreviations.setContractToSingleLabel(boolean val)", "testcase": false, "constructor": false}, {"identifier": "findCutBonds", "parameters": "(IAtomContainer mol, EdgeToBondMap bmap, int[][] adjlist)", "modifiers": "private static", "return": "Set<IBond>", "signature": "Set<IBond> findCutBonds(IAtomContainer mol, EdgeToBondMap bmap, int[][] adjlist)", "full_signature": "private static Set<IBond> findCutBonds(IAtomContainer mol, EdgeToBondMap bmap, int[][] adjlist)", "class_method_signature": "Abbreviations.findCutBonds(IAtomContainer mol, EdgeToBondMap bmap, int[][] adjlist)", "testcase": false, "constructor": false}, {"identifier": "makeCut", "parameters": "(IBond cut, IAtomContainer mol, Map<IAtom, Integer> idx,\n                                                int[][] adjlist)", "modifiers": "private static", "return": "List<IAtomContainer>", "signature": "List<IAtomContainer> makeCut(IBond cut, IAtomContainer mol, Map<IAtom, Integer> idx,\n                                                int[][] adjlist)", "full_signature": "private static List<IAtomContainer> makeCut(IBond cut, IAtomContainer mol, Map<IAtom, Integer> idx,\n                                                int[][] adjlist)", "class_method_signature": "Abbreviations.makeCut(IBond cut, IAtomContainer mol, Map<IAtom, Integer> idx,\n                                                int[][] adjlist)", "testcase": false, "constructor": false}, {"identifier": "generateFragments", "parameters": "(IAtomContainer mol)", "modifiers": "private static", "return": "List<IAtomContainer>", "signature": "List<IAtomContainer> generateFragments(IAtomContainer mol)", "full_signature": "private static List<IAtomContainer> generateFragments(IAtomContainer mol)", "class_method_signature": "Abbreviations.generateFragments(IAtomContainer mol)", "testcase": false, "constructor": false}, {"identifier": "generate", "parameters": "(final IAtomContainer mol)", "modifiers": "public", "return": "List<Sgroup>", "signature": "List<Sgroup> generate(final IAtomContainer mol)", "full_signature": "public List<Sgroup> generate(final IAtomContainer mol)", "class_method_signature": "Abbreviations.generate(final IAtomContainer mol)", "testcase": false, "constructor": false}, {"identifier": "getAbbr", "parameters": "(IAtomContainer part)", "modifiers": "private", "return": "Sgroup", "signature": "Sgroup getAbbr(IAtomContainer part)", "full_signature": "private Sgroup getAbbr(IAtomContainer part)", "class_method_signature": "Abbreviations.getAbbr(IAtomContainer part)", "testcase": false, "constructor": false}, {"identifier": "countUpper", "parameters": "(String str)", "modifiers": "private", "return": "int", "signature": "int countUpper(String str)", "full_signature": "private int countUpper(String str)", "class_method_signature": "Abbreviations.countUpper(String str)", "testcase": false, "constructor": false}, {"identifier": "containsChargeChar", "parameters": "(String str)", "modifiers": "private", "return": "boolean", "signature": "boolean containsChargeChar(String str)", "full_signature": "private boolean containsChargeChar(String str)", "class_method_signature": "Abbreviations.containsChargeChar(String str)", "testcase": false, "constructor": false}, {"identifier": "digitAtEnd", "parameters": "(String str)", "modifiers": "private", "return": "boolean", "signature": "boolean digitAtEnd(String str)", "full_signature": "private boolean digitAtEnd(String str)", "class_method_signature": "Abbreviations.digitAtEnd(String str)", "testcase": false, "constructor": false}, {"identifier": "newSymbol", "parameters": "(int atomnum, int hcount, boolean prefix)", "modifiers": "private", "return": "String", "signature": "String newSymbol(int atomnum, int hcount, boolean prefix)", "full_signature": "private String newSymbol(int atomnum, int hcount, boolean prefix)", "class_method_signature": "Abbreviations.newSymbol(int atomnum, int hcount, boolean prefix)", "testcase": false, "constructor": false}, {"identifier": "appendGroup", "parameters": "(StringBuilder sb, String group, int coef, boolean useParen)", "modifiers": "private", "return": "void", "signature": "void appendGroup(StringBuilder sb, String group, int coef, boolean useParen)", "full_signature": "private void appendGroup(StringBuilder sb, String group, int coef, boolean useParen)", "class_method_signature": "Abbreviations.appendGroup(StringBuilder sb, String group, int coef, boolean useParen)", "testcase": false, "constructor": false}, {"identifier": "apply", "parameters": "(final IAtomContainer mol)", "modifiers": "public", "return": "int", "signature": "int apply(final IAtomContainer mol)", "full_signature": "public int apply(final IAtomContainer mol)", "class_method_signature": "Abbreviations.apply(final IAtomContainer mol)", "testcase": false, "constructor": false}, {"identifier": "matchExact", "parameters": "(final IAtomContainer mol, final IAtom atom)", "modifiers": "private", "return": "IQueryAtom", "signature": "IQueryAtom matchExact(final IAtomContainer mol, final IAtom atom)", "full_signature": "private IQueryAtom matchExact(final IAtomContainer mol, final IAtom atom)", "class_method_signature": "Abbreviations.matchExact(final IAtomContainer mol, final IAtom atom)", "testcase": false, "constructor": false}, {"identifier": "matchExact", "parameters": "(IAtomContainer mol)", "modifiers": "private", "return": "IQueryAtomContainer", "signature": "IQueryAtomContainer matchExact(IAtomContainer mol)", "full_signature": "private IQueryAtomContainer matchExact(IAtomContainer mol)", "class_method_signature": "Abbreviations.matchExact(IAtomContainer mol)", "testcase": false, "constructor": false}, {"identifier": "addDisconnectedAbbreviation", "parameters": "(IAtomContainer mol, String label)", "modifiers": "private", "return": "boolean", "signature": "boolean addDisconnectedAbbreviation(IAtomContainer mol, String label)", "full_signature": "private boolean addDisconnectedAbbreviation(IAtomContainer mol, String label)", "class_method_signature": "Abbreviations.addDisconnectedAbbreviation(IAtomContainer mol, String label)", "testcase": false, "constructor": false}, {"identifier": "addConnectedAbbreviation", "parameters": "(IAtomContainer mol, String label)", "modifiers": "private", "return": "boolean", "signature": "boolean addConnectedAbbreviation(IAtomContainer mol, String label)", "full_signature": "private boolean addConnectedAbbreviation(IAtomContainer mol, String label)", "class_method_signature": "Abbreviations.addConnectedAbbreviation(IAtomContainer mol, String label)", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(String line)", "modifiers": "public", "return": "boolean", "signature": "boolean add(String line)", "full_signature": "public boolean add(String line)", "class_method_signature": "Abbreviations.add(String line)", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(IAtomContainer mol, String label)", "modifiers": "public", "return": "boolean", "signature": "boolean add(IAtomContainer mol, String label)", "full_signature": "public boolean add(IAtomContainer mol, String label)", "class_method_signature": "Abbreviations.add(IAtomContainer mol, String label)", "testcase": false, "constructor": false}, {"identifier": "getSmilesSuffix", "parameters": "(String line)", "modifiers": "private static", "return": "String", "signature": "String getSmilesSuffix(String line)", "full_signature": "private static String getSmilesSuffix(String line)", "class_method_signature": "Abbreviations.getSmilesSuffix(String line)", "testcase": false, "constructor": false}, {"identifier": "getBasicElementSymbol", "parameters": "(IAtom atom)", "modifiers": "private static", "return": "String", "signature": "String getBasicElementSymbol(IAtom atom)", "full_signature": "private static String getBasicElementSymbol(IAtom atom)", "class_method_signature": "Abbreviations.getBasicElementSymbol(IAtom atom)", "testcase": false, "constructor": false}, {"identifier": "loadSmiles", "parameters": "(final InputStream in)", "modifiers": "private", "return": "int", "signature": "int loadSmiles(final InputStream in)", "full_signature": "private int loadSmiles(final InputStream in)", "class_method_signature": "Abbreviations.loadSmiles(final InputStream in)", "testcase": false, "constructor": false}, {"identifier": "loadFromFile", "parameters": "(final String path)", "modifiers": "public", "return": "int", "signature": "int loadFromFile(final String path)", "full_signature": "public int loadFromFile(final String path)", "class_method_signature": "Abbreviations.loadFromFile(final String path)", "testcase": false, "constructor": false}], "file": "app/depict/src/main/java/org/openscience/cdk/depict/Abbreviations.java"}, "focal_method": {"identifier": "generate", "parameters": "(final IAtomContainer mol)", "modifiers": "public", "return": "List<Sgroup>", "body": "public List<Sgroup> generate(final IAtomContainer mol) {\n\n        // mark which atoms have already been abbreviated or are\n        // part of an existing Sgroup\n        Set<IAtom> usedAtoms = new HashSet<>();\n        List<Sgroup> sgroups = mol.getProperty(CDKConstants.CTAB_SGROUPS);\n        if (sgroups != null) {\n            for (Sgroup sgroup : sgroups)\n                usedAtoms.addAll(sgroup.getAtoms());\n        }\n\n        final List<Sgroup> newSgroups = new ArrayList<>();\n\n        // disconnected abbreviations, salts, common reagents, large compounds\n        if (usedAtoms.isEmpty()) {\n            try {\n                IAtomContainer copy = AtomContainerManipulator.copyAndSuppressedHydrogens(mol);\n                String cansmi = usmigen.create(copy);\n                String label = disconnectedAbbreviations.get(cansmi);\n\n                if (label != null && !disabled.contains(label) && contractSingleFragments) {\n                    Sgroup sgroup = new Sgroup();\n                    sgroup.setType(SgroupType.CtabAbbreviation);\n                    sgroup.setSubscript(label);\n                    for (IAtom atom : mol.atoms())\n                        sgroup.addAtom(atom);\n                    return Collections.singletonList(sgroup);\n                } else if (cansmi.contains(\".\")) {\n                    IAtomContainerSet parts = ConnectivityChecker.partitionIntoMolecules(mol);\n\n\n                    // leave one out\n                    Sgroup best = null;\n                    for (int i = 0; i < parts.getAtomContainerCount(); i++) {\n                        IAtomContainer a = parts.getAtomContainer(i);\n                        IAtomContainer b = a.getBuilder().newAtomContainer();\n                        for (int j = 0; j < parts.getAtomContainerCount(); j++)\n                            if (j != i)\n                                b.add(parts.getAtomContainer(j));\n                        Sgroup sgroup1 = getAbbr(a);\n                        Sgroup sgroup2 = getAbbr(b);\n                        if (sgroup1 != null && sgroup2 != null && contractSingleFragments) {\n                            Sgroup combined = new Sgroup();\n                            label = null;\n                            for (IAtom atom : sgroup1.getAtoms())\n                                combined.addAtom(atom);\n                            for (IAtom atom : sgroup2.getAtoms())\n                                combined.addAtom(atom);\n                            if (sgroup1.getSubscript().length() > sgroup2.getSubscript().length())\n                                combined.setSubscript(sgroup1.getSubscript() + INTERPUNCT + sgroup2.getSubscript());\n                            else\n                                combined.setSubscript(sgroup2.getSubscript() + INTERPUNCT + sgroup1.getSubscript());\n                            combined.setType(SgroupType.CtabAbbreviation);\n                            return Collections.singletonList(combined);\n                        }\n                        if (sgroup1 != null && (best == null || sgroup1.getAtoms().size() > best.getAtoms().size()))\n                            best = sgroup1;\n                        if (sgroup2 != null && (best == null || sgroup2.getAtoms().size() < best.getAtoms().size()))\n                            best = sgroup2;\n                    }\n\n                    if (best != null) {\n                        newSgroups.add(best);\n                        usedAtoms.addAll(best.getAtoms());\n                    }\n                }\n\n            } catch (CDKException ignored) {\n            }\n        }\n\n        List<IAtomContainer> fragments = generateFragments(mol);\n        Multimap<IAtom, Sgroup> sgroupAdjs = ArrayListMultimap.create();\n\n        for (IAtomContainer frag : fragments) {\n            try {\n                final String smi = usmigen.create(AtomContainerManipulator.copyAndSuppressedHydrogens(frag));\n                final String label = connectedAbbreviations.get(smi);\n\n                if (label == null || disabled.contains(label))\n                    continue;\n\n                boolean overlap = false;\n\n                // note: first atom is '*'\n                int numAtoms = frag.getAtomCount();\n                int numBonds = frag.getBondCount();\n                for (int i = 1; i < numAtoms; i++) {\n                    if (usedAtoms.contains(frag.getAtom(i))) {\n                        overlap = true;\n                        break;\n                    }\n                }\n\n                // overlaps with previous assignment\n                if (overlap)\n                    continue;\n\n                // create new abbreviation SGroup\n                Sgroup sgroup = new Sgroup();\n                sgroup.setType(SgroupType.CtabAbbreviation);\n                sgroup.setSubscript(label);\n\n                IBond attachBond = frag.getBond(0).getProperty(CUT_BOND, IBond.class);\n                IAtom attachAtom = null;\n                sgroup.addBond(attachBond);\n                for (int i = 1; i < numAtoms; i++) {\n                    IAtom atom = frag.getAtom(i);\n                    usedAtoms.add(atom);\n                    sgroup.addAtom(atom);\n                    if (attachBond.getBegin().equals(atom))\n                        attachAtom = attachBond.getEnd();\n                    else if (attachBond.getEnd().equals(atom))\n                        attachAtom = attachBond.getBegin();\n                }\n\n                if (attachAtom != null)\n                    sgroupAdjs.put(attachAtom, sgroup);\n                newSgroups.add(sgroup);\n\n             } catch (CDKException e) {\n                // ignore\n            }\n        }\n\n        if (!contractOnHetero)\n            return newSgroups;\n\n        // now collapse\n        collapse:\n        for (IAtom attach : mol.atoms()) {\n            if (usedAtoms.contains(attach))\n                continue;\n\n            // skip charged or isotopic labelled, C or R/*, H, He\n            if ((attach.getFormalCharge() != null && attach.getFormalCharge() != 0)\n                || attach.getMassNumber() != null\n                || attach.getAtomicNumber() == 6\n                || attach.getAtomicNumber() < 2)\n                continue;\n\n            int hcount = attach.getImplicitHydrogenCount();\n            Set<IAtom> xatoms   = new HashSet<>();\n            Set<IBond> xbonds   = new HashSet<>();\n            Set<IBond> newbonds = new HashSet<>();\n            xatoms.add(attach);\n\n            List<String> nbrSymbols = new ArrayList<>();\n            Set<Sgroup> todelete = new HashSet<>();\n            for (Sgroup sgroup : sgroupAdjs.get(attach)) {\n                if (containsChargeChar(sgroup.getSubscript()))\n                    continue;\n                if (sgroup.getBonds().size() != 1)\n                    continue;\n                IBond xbond = sgroup.getBonds().iterator().next();\n                xbonds.add(xbond);\n                xatoms.addAll(sgroup.getAtoms());\n                if (attach.getSymbol().length() == 1 &&\n                    Character.isLowerCase(sgroup.getSubscript().charAt(0))) {\n                    if (Elements.ofString(attach.getSymbol() + sgroup.getSubscript().charAt(0)) != Elements.Unknown)\n                        continue collapse;\n                }\n                nbrSymbols.add(sgroup.getSubscript());\n                todelete.add(sgroup);\n            }\n            int numSGrpNbrs = nbrSymbols.size();\n            for (IBond bond : mol.getConnectedBondsList(attach)) {\n                if (!xbonds.contains(bond)) {\n                    IAtom nbr = bond.getOther(attach);\n                    // contract terminal bonds\n                    if (mol.getConnectedBondsCount(nbr) == 1) {\n                        if (nbr.getMassNumber() != null ||\n                            (nbr.getFormalCharge() != null && nbr.getFormalCharge() != 0)) {\n                            newbonds.add(bond);\n                        } else if (nbr.getAtomicNumber() == 1) {\n                            hcount++;\n                            xatoms.add(nbr);\n                        } else if (nbr.getAtomicNumber() > 0){\n                            nbrSymbols.add(newSymbol(nbr.getAtomicNumber(), nbr.getImplicitHydrogenCount(), false));\n                            xatoms.add(nbr);\n                        }\n                    } else {\n                        newbonds.add(bond);\n                    }\n                }\n            }\n\n            // reject if no symbols\n            // reject if no bonds (<1), except if all symbols are identical... (HashSet.size==1)\n            // reject if more that 2 bonds\n            if (nbrSymbols.isEmpty() ||\n                newbonds.size() < 1 && (new HashSet<>(nbrSymbols).size() != 1) ||\n                newbonds.size() > 2)\n                continue;\n\n            // create the symbol\n            StringBuilder sb = new StringBuilder();\n            sb.append(newSymbol(attach.getAtomicNumber(), hcount, newbonds.size() == 0));\n            String prev  = null;\n            int    count = 0;\n            Collections.sort(nbrSymbols, new Comparator<String>() {\n                @Override\n                public int compare(String o1, String o2) {\n                    int cmp = Integer.compare(o1.length(), o2.length());\n                    if (cmp != 0) return cmp;\n                    return o1.compareTo(o2);\n                }\n            });\n            for (String nbrSymbol : nbrSymbols) {\n                if (nbrSymbol.equals(prev)) {\n                    count++;\n                } else {\n                    boolean useParen = count == 0 || countUpper(prev) > 1 || (prev != null && nbrSymbol.startsWith(prev));\n                    appendGroup(sb, prev, count, useParen);\n                    prev = nbrSymbol;\n                    count = 1;\n                }\n            }\n            appendGroup(sb, prev, count, false);\n\n            // remove existing\n            newSgroups.removeAll(todelete);\n\n            // create new\n            Sgroup newSgroup = new Sgroup();\n            newSgroup.setType(SgroupType.CtabAbbreviation);\n            newSgroup.setSubscript(sb.toString());\n            for (IBond bond : newbonds)\n                newSgroup.addBond(bond);\n            for (IAtom atom : xatoms)\n                newSgroup.addAtom(atom);\n\n            newSgroups.add(newSgroup);\n            usedAtoms.addAll(xatoms);\n        }\n\n        return newSgroups;\n    }", "signature": "List<Sgroup> generate(final IAtomContainer mol)", "full_signature": "public List<Sgroup> generate(final IAtomContainer mol)", "class_method_signature": "Abbreviations.generate(final IAtomContainer mol)", "testcase": false, "constructor": false, "invocations": ["getProperty", "addAll", "getAtoms", "isEmpty", "copyAndSuppressedHydrogens", "create", "get", "contains", "setType", "setSubscript", "atoms", "addAtom", "singletonList", "contains", "partitionIntoMolecules", "getAtomContainerCount", "getAtomContainer", "newAtomContainer", "getBuilder", "getAtomContainerCount", "add", "getAtomContainer", "getAbbr", "getAbbr", "getAtoms", "addAtom", "getAtoms", "addAtom", "length", "getSubscript", "length", "getSubscript", "setSubscript", "getSubscript", "getSubscript", "setSubscript", "getSubscript", "getSubscript", "setType", "singletonList", "size", "getAtoms", "size", "getAtoms", "size", "getAtoms", "size", "getAtoms", "add", "addAll", "getAtoms", "generateFragments", "create", "create", "copyAndSuppressedHydrogens", "get", "contains", "getAtomCount", "getBondCount", "contains", "getAtom", "setType", "setSubscript", "getProperty", "getBond", "addBond", "getAtom", "add", "addAtom", "equals", "getBegin", "getEnd", "equals", "getEnd", "getBegin", "put", "add", "atoms", "contains", "getFormalCharge", "getFormalCharge", "getMassNumber", "getAtomicNumber", "getAtomicNumber", "getImplicitHydrogenCount", "add", "get", "containsChargeChar", "getSubscript", "size", "getBonds", "next", "iterator", "getBonds", "add", "addAll", "getAtoms", "length", "getSymbol", "isLowerCase", "charAt", "getSubscript", "ofString", "getSymbol", "charAt", "getSubscript", "add", "getSubscript", "add", "size", "getConnectedBondsList", "contains", "getOther", "getConnectedBondsCount", "getMassNumber", "getFormalCharge", "getFormalCharge", "add", "getAtomicNumber", "add", "getAtomicNumber", "add", "newSymbol", "getAtomicNumber", "getImplicitHydrogenCount", "add", "add", "isEmpty", "size", "size", "size", "append", "newSymbol", "getAtomicNumber", "size", "sort", "compare", "length", "length", "compareTo", "equals", "countUpper", "startsWith", "appendGroup", "appendGroup", "removeAll", "setType", "setSubscript", "toString", "addBond", "addAtom", "add", "addAll"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}