{"test_class": {"identifier": "FitnessProportionateSelectionOperatorTest", "superclass": "extends TestCase", "interfaces": "", "fields": [{"original_string": "protected FitnessProportionateSelectionOperator operator;", "modifier": "protected", "type": "FitnessProportionateSelectionOperator", "declarator": "operator", "var_name": "operator"}], "file": "jcool/benchmark/src/test/java/cz/cvut/felk/cig/jcool/benchmark/method/evolutionary/operators/selection/FitnessProportionateSelectionOperatorTest.java"}, "test_case": {"identifier": "testMakeAccumulatedProbabilities", "parameters": "()", "modifiers": "@Test // test only makeAccumulatedProbabilities public", "return": "void", "body": "@Test\n    // test only makeAccumulatedProbabilities\n    public void testMakeAccumulatedProbabilities() throws Exception{\n        Individual[] inputIndividuals = new Individual[5];\n        double[] fitness = new double[]{2.0, 4.0, 1.0, 5.0, 3.0};\n        for (int i = 0; i < 5; i++){\n            inputIndividuals[i] = new SimpleIndividual(1, 1.0, new SimplePhenotypeRepresentation());\n            inputIndividuals[i].setFitness(fitness[i]);\n        }\n        double[] accumulatedProbabilities = this.operator.makeAccumulatedProbabilities(inputIndividuals);\n\n        assertTrue(accumulatedProbabilities.length == 5);\n        assertTrue(accumulatedProbabilities[0] == (2.0/15));\n        assertTrue(accumulatedProbabilities[1] == (6.0/15));\n        assertTrue(accumulatedProbabilities[2] == (7.0/15));\n        assertTrue(accumulatedProbabilities[3] == (12.0/15));\n        assertTrue(accumulatedProbabilities[4] == 1.0);\n    }", "signature": "void testMakeAccumulatedProbabilities()", "full_signature": "@Test // test only makeAccumulatedProbabilities public void testMakeAccumulatedProbabilities()", "class_method_signature": "FitnessProportionateSelectionOperatorTest.testMakeAccumulatedProbabilities()", "testcase": true, "constructor": false, "invocations": ["setFitness", "makeAccumulatedProbabilities", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue", "assertTrue"]}, "focal_class": {"identifier": "FitnessProportionateSelectionOperator", "superclass": "extends AbstractProportionateSelectionOperator", "interfaces": "", "fields": [], "methods": [{"identifier": "makeAccumulatedProbabilities", "parameters": "(Individual[] inputIndividuals)", "modifiers": "protected", "return": "double[]", "signature": "double[] makeAccumulatedProbabilities(Individual[] inputIndividuals)", "full_signature": "protected double[] makeAccumulatedProbabilities(Individual[] inputIndividuals)", "class_method_signature": "FitnessProportionateSelectionOperator.makeAccumulatedProbabilities(Individual[] inputIndividuals)", "testcase": false, "constructor": false}, {"identifier": "selectWinners", "parameters": "(Individual[] inputIndividuals, double[] accumulatedProbabilities)", "modifiers": "protected", "return": "List<Individual>", "signature": "List<Individual> selectWinners(Individual[] inputIndividuals, double[] accumulatedProbabilities)", "full_signature": "protected List<Individual> selectWinners(Individual[] inputIndividuals, double[] accumulatedProbabilities)", "class_method_signature": "FitnessProportionateSelectionOperator.selectWinners(Individual[] inputIndividuals, double[] accumulatedProbabilities)", "testcase": false, "constructor": false}], "file": "jcool/benchmark/src/main/java/cz/cvut/felk/cig/jcool/benchmark/method/evolutionary/operators/selection/FitnessProportionateSelectionOperator.java"}, "focal_method": {"identifier": "makeAccumulatedProbabilities", "parameters": "(Individual[] inputIndividuals)", "modifiers": "protected", "return": "double[]", "body": "protected double[] makeAccumulatedProbabilities(Individual[] inputIndividuals){\n        double[] accumulatedFitnessValues = new double[inputIndividuals.length];\n        double[] accumulatedProbabilities = new double[inputIndividuals.length];\n        double totalFitness = 0.0; // actual accumulated fitness value\n        // make accumulated fitness values\n        for (int i = 0; i < inputIndividuals.length; i++){\n            if (inputIndividuals[i].getFitness() >= 0.0){\n                accumulatedFitnessValues[i] = totalFitness + inputIndividuals[i].getFitness();\n                totalFitness = accumulatedFitnessValues[i];\n            } else {\n                throw new OptimizationException(this.getClass().getSimpleName() + \": individual fitness value cannot be negative but found value of \" + inputIndividuals[i].getFitness());\n            }\n        }\n        // make accumulated probabilities\n        for (int i = 0; i < inputIndividuals.length; i++){\n            accumulatedProbabilities[i] = accumulatedFitnessValues[i] / totalFitness;\n        }\n        accumulatedProbabilities[inputIndividuals.length-1] = 1.0; // make sure that roulette selection always selects an Individual\n        \n        return accumulatedProbabilities;\n    }", "signature": "double[] makeAccumulatedProbabilities(Individual[] inputIndividuals)", "full_signature": "protected double[] makeAccumulatedProbabilities(Individual[] inputIndividuals)", "class_method_signature": "FitnessProportionateSelectionOperator.makeAccumulatedProbabilities(Individual[] inputIndividuals)", "testcase": false, "constructor": false, "invocations": ["getFitness", "getFitness", "getSimpleName", "getClass", "getFitness"]}, "repository": {"repo_id": 3865446, "url": "https://github.com/dhonza/JCOOL", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 12, "size": 415, "license": "licensed"}}