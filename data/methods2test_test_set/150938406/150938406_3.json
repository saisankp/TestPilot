{"test_class": {"identifier": "PipelineTest", "superclass": "", "interfaces": "", "fields": [], "file": "core/src/test/java/com/alibaba/alink/pipeline/PipelineTest.java"}, "test_case": {"identifier": "testFit", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testFit() {\n        BatchOperator data = new MemSourceBatchOp(new Object[]{1}, \"colName\");\n\n        TransformerBase stage1 = mockTransformer(\"stage1\");\n        TransformerBase stage2 = mockTransformer(\"stage2\");\n        Pair<EstimatorBase, ModelBase> stage3 = mockEstimator(\"stage3\");\n        TransformerBase stage4 = mockTransformer(\"stage4\");\n        Pair<EstimatorBase, ModelBase> stage5 = mockEstimator(\"stage5\");\n        TransformerBase stage6 = mockTransformer(\"stage6\");\n\n        Pipeline pipe = new Pipeline().add(stage1).add(stage2).add(stage3.getLeft())\n            .add(stage4).add(stage5.getLeft()).add(stage6);\n        pipe.fit(data);\n\n        // The transform methods of the first 2 transformers should be invoked.\n        // because they are expected transform input data to fit estimators.\n        verify(stage1, times(1)).transform(any(BatchOperator.class));\n        verify(stage2, times(1)).transform(any(BatchOperator.class));\n\n        // Verify that estimator of stage 3 is fitted.\n        verify(stage3.getLeft(), times(1)).fit(any(BatchOperator.class));\n        // And the generated model is used to transform data for estimator on stage 5.\n        verify(stage3.getRight(), times(1)).transform(any(BatchOperator.class));\n\n        verify(stage4, times(1)).transform(any(BatchOperator.class));\n\n        // Verify that estimator of stage 5 is fitted.\n        verify(stage5.getLeft(), times(1)).fit(any(BatchOperator.class));\n        // But we don't have to transform data with the generated model.\n        verify(stage5.getRight(), never()).transform(any(BatchOperator.class));\n\n        verify(stage6, never()).transform(any(BatchOperator.class));\n    }", "signature": "void testFit()", "full_signature": "@Test public void testFit()", "class_method_signature": "PipelineTest.testFit()", "testcase": true, "constructor": false, "invocations": ["mockTransformer", "mockTransformer", "mockEstimator", "mockTransformer", "mockEstimator", "mockTransformer", "add", "add", "add", "add", "add", "add", "getLeft", "getLeft", "fit", "transform", "verify", "times", "any", "transform", "verify", "times", "any", "fit", "verify", "getLeft", "times", "any", "transform", "verify", "getRight", "times", "any", "transform", "verify", "times", "any", "fit", "verify", "getLeft", "times", "any", "transform", "verify", "getRight", "never", "any", "transform", "verify", "never", "any"]}, "focal_class": {"identifier": "Pipeline", "superclass": "extends EstimatorBase<Pipeline, PipelineModel>", "interfaces": "", "fields": [{"original_string": "private ArrayList<PipelineStageBase> stages = new ArrayList<>();", "modifier": "private", "type": "ArrayList<PipelineStageBase>", "declarator": "stages = new ArrayList<>()", "var_name": "stages"}], "methods": [{"identifier": "Pipeline", "parameters": "()", "modifiers": "public", "return": "", "signature": " Pipeline()", "full_signature": "public  Pipeline()", "class_method_signature": "Pipeline.Pipeline()", "testcase": false, "constructor": true}, {"identifier": "Pipeline", "parameters": "(Params params)", "modifiers": "public", "return": "", "signature": " Pipeline(Params params)", "full_signature": "public  Pipeline(Params params)", "class_method_signature": "Pipeline.Pipeline(Params params)", "testcase": false, "constructor": true}, {"identifier": "Pipeline", "parameters": "(PipelineStageBase<?>... stages)", "modifiers": "public", "return": "", "signature": " Pipeline(PipelineStageBase<?>... stages)", "full_signature": "public  Pipeline(PipelineStageBase<?>... stages)", "class_method_signature": "Pipeline.Pipeline(PipelineStageBase<?>... stages)", "testcase": false, "constructor": true}, {"identifier": "clone", "parameters": "()", "modifiers": "@Override public", "return": "Pipeline", "signature": "Pipeline clone()", "full_signature": "@Override public Pipeline clone()", "class_method_signature": "Pipeline.clone()", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(PipelineStageBase stage)", "modifiers": "public", "return": "Pipeline", "signature": "Pipeline add(PipelineStageBase stage)", "full_signature": "public Pipeline add(PipelineStageBase stage)", "class_method_signature": "Pipeline.add(PipelineStageBase stage)", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(int index, PipelineStageBase stage)", "modifiers": "public", "return": "Pipeline", "signature": "Pipeline add(int index, PipelineStageBase stage)", "full_signature": "public Pipeline add(int index, PipelineStageBase stage)", "class_method_signature": "Pipeline.add(int index, PipelineStageBase stage)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(int index)", "modifiers": "public", "return": "Pipeline", "signature": "Pipeline remove(int index)", "full_signature": "public Pipeline remove(int index)", "class_method_signature": "Pipeline.remove(int index)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(int index)", "modifiers": "public", "return": "PipelineStageBase", "signature": "PipelineStageBase get(int index)", "full_signature": "public PipelineStageBase get(int index)", "class_method_signature": "Pipeline.get(int index)", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int size()", "full_signature": "public int size()", "class_method_signature": "Pipeline.size()", "testcase": false, "constructor": false}, {"identifier": "fit", "parameters": "(BatchOperator input)", "modifiers": "@Override public", "return": "PipelineModel", "signature": "PipelineModel fit(BatchOperator input)", "full_signature": "@Override public PipelineModel fit(BatchOperator input)", "class_method_signature": "Pipeline.fit(BatchOperator input)", "testcase": false, "constructor": false}, {"identifier": "fit", "parameters": "(StreamOperator input)", "modifiers": "@Override public", "return": "PipelineModel", "signature": "PipelineModel fit(StreamOperator input)", "full_signature": "@Override public PipelineModel fit(StreamOperator input)", "class_method_signature": "Pipeline.fit(StreamOperator input)", "testcase": false, "constructor": false}, {"identifier": "getIndexOfLastEstimator", "parameters": "()", "modifiers": "private", "return": "int", "signature": "int getIndexOfLastEstimator()", "full_signature": "private int getIndexOfLastEstimator()", "class_method_signature": "Pipeline.getIndexOfLastEstimator()", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/alibaba/alink/pipeline/Pipeline.java"}, "focal_method": {"identifier": "fit", "parameters": "(BatchOperator input)", "modifiers": "@Override public", "return": "PipelineModel", "body": "@Override\n\tpublic PipelineModel fit(BatchOperator input) {\n\t\tint lastEstimatorIdx = getIndexOfLastEstimator();\n\t\tTransformerBase[] transformers = new TransformerBase[stages.size()];\n\t\tfor (int i = 0; i < stages.size(); i++) {\n\t\t\tPipelineStageBase stage = stages.get(i);\n\t\t\tif (i <= lastEstimatorIdx) {\n\t\t\t\tif (stage instanceof EstimatorBase) {\n\t\t\t\t\ttransformers[i] = ((EstimatorBase) stage).fit(input);\n\t\t\t\t} else if (stage instanceof TransformerBase) {\n\t\t\t\t\ttransformers[i] = (TransformerBase) stage;\n\t\t\t\t}\n\t\t\t\tif (i < lastEstimatorIdx) {\n\t\t\t\t\t// temporarily disable lazy print transform results\n\t\t\t\t\tBoolean lazyPrintTransformDataEnabled = (Boolean) transformers[i].get(LAZY_PRINT_TRANSFORM_DATA_ENABLED);\n\t\t\t\t\tBoolean lazyPrintTransformStatEnabled = (Boolean) transformers[i].get(LAZY_PRINT_TRANSFORM_STAT_ENABLED);\n\t\t\t\t\ttransformers[i].set(LAZY_PRINT_TRANSFORM_DATA_ENABLED, false);\n\t\t\t\t\ttransformers[i].set(LAZY_PRINT_TRANSFORM_STAT_ENABLED, false);\n\n\t\t\t\t\tinput = transformers[i].transform(input);\n\n\t\t\t\t\ttransformers[i].set(LAZY_PRINT_TRANSFORM_DATA_ENABLED, lazyPrintTransformDataEnabled);\n\t\t\t\t\ttransformers[i].set(LAZY_PRINT_TRANSFORM_STAT_ENABLED, lazyPrintTransformStatEnabled);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// After lastEstimatorIdx, there're only Transformer stages, so it's safe to do type cast.\n\t\t\t\ttransformers[i] = (TransformerBase) stage;\n\t\t\t}\n\t\t}\n\t\treturn new PipelineModel(transformers).setMLEnvironmentId(input.getMLEnvironmentId());\n\n\t}", "signature": "PipelineModel fit(BatchOperator input)", "full_signature": "@Override public PipelineModel fit(BatchOperator input)", "class_method_signature": "Pipeline.fit(BatchOperator input)", "testcase": false, "constructor": false, "invocations": ["getIndexOfLastEstimator", "size", "size", "get", "fit", "get", "get", "set", "set", "transform", "set", "set", "setMLEnvironmentId", "getMLEnvironmentId"]}, "repository": {"repo_id": 150938406, "url": "https://github.com/alibaba/Alink", "stars": 1923, "created": "9/30/2018 6:36:11 AM +00:00", "updates": "2020-01-27T10:24:34+00:00", "fork": "False", "license": "licensed"}}