{"test_class": {"identifier": "ByLogicalTableRouterTest", "superclass": "", "interfaces": "", "fields": [], "file": "debezium-core/src/test/java/io/debezium/transforms/ByLogicalTableRouterTest.java"}, "test_case": {"identifier": "testBrokenKeyReplacementConfigurationEmptyValue", "parameters": "()", "modifiers": "@Test(expected = ConnectException.class) public", "return": "void", "body": "@Test(expected = ConnectException.class)\n    public void testBrokenKeyReplacementConfigurationEmptyValue() {\n        final ByLogicalTableRouter<SourceRecord> subject = new ByLogicalTableRouter<>();\n        final Map<String, String> props = new HashMap<>();\n\n        props.put(\"topic.regex\", \"someValidRegex(.*)\");\n        props.put(\"topic.replacement\", \"$1\");\n        props.put(\"key.field.regex\", \"If this is set, key.field.replacement must be non-empty\");\n        props.put(\"key.field.replacement\", \"\");\n        subject.configure(props);\n    }", "signature": "void testBrokenKeyReplacementConfigurationEmptyValue()", "full_signature": "@Test(expected = ConnectException.class) public void testBrokenKeyReplacementConfigurationEmptyValue()", "class_method_signature": "ByLogicalTableRouterTest.testBrokenKeyReplacementConfigurationEmptyValue()", "testcase": true, "constructor": false, "invocations": ["put", "put", "put", "put", "configure"]}, "focal_class": {"identifier": "ByLogicalTableRouter", "superclass": "", "interfaces": "implements Transformation<R>", "fields": [{"original_string": "private static final Field TOPIC_REGEX = Field.create(\"topic.regex\")\n            .withDisplayName(\"Topic regex\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withValidation(Field::isRequired, Field::isRegex)\n            .withDescription(\"The regex used for extracting the name of the logical table from the original topic name.\");", "modifier": "private static final", "type": "Field", "declarator": "TOPIC_REGEX = Field.create(\"topic.regex\")\n            .withDisplayName(\"Topic regex\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withValidation(Field::isRequired, Field::isRegex)\n            .withDescription(\"The regex used for extracting the name of the logical table from the original topic name.\")", "var_name": "TOPIC_REGEX"}, {"original_string": "private static final Field TOPIC_REPLACEMENT = Field.create(\"topic.replacement\")\n            .withDisplayName(\"Topic replacement\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withValidation(Field::isRequired)\n            .withDescription(\"The replacement string used in conjunction with \" + TOPIC_REGEX.name() +\n                    \". This will be used to create the new topic name.\");", "modifier": "private static final", "type": "Field", "declarator": "TOPIC_REPLACEMENT = Field.create(\"topic.replacement\")\n            .withDisplayName(\"Topic replacement\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withValidation(Field::isRequired)\n            .withDescription(\"The replacement string used in conjunction with \" + TOPIC_REGEX.name() +\n                    \". This will be used to create the new topic name.\")", "var_name": "TOPIC_REPLACEMENT"}, {"original_string": "private static final Field KEY_ENFORCE_UNIQUENESS = Field.create(\"key.enforce.uniqueness\")\n            .withDisplayName(\"Add source topic name into key\")\n            .withType(ConfigDef.Type.BOOLEAN)\n            .withWidth(ConfigDef.Width.SHORT)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withDefault(true)\n            .withDescription(\"Augment each record's key with a field denoting the source topic. This field \" +\n                    \"distinguishes records coming from different physical tables which may otherwise have \" +\n                    \"primary/unique key conflicts. If the source tables are guaranteed to have globally \" +\n                    \"unique keys then this may be set to false to disable key rewriting.\");", "modifier": "private static final", "type": "Field", "declarator": "KEY_ENFORCE_UNIQUENESS = Field.create(\"key.enforce.uniqueness\")\n            .withDisplayName(\"Add source topic name into key\")\n            .withType(ConfigDef.Type.BOOLEAN)\n            .withWidth(ConfigDef.Width.SHORT)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withDefault(true)\n            .withDescription(\"Augment each record's key with a field denoting the source topic. This field \" +\n                    \"distinguishes records coming from different physical tables which may otherwise have \" +\n                    \"primary/unique key conflicts. If the source tables are guaranteed to have globally \" +\n                    \"unique keys then this may be set to false to disable key rewriting.\")", "var_name": "KEY_ENFORCE_UNIQUENESS"}, {"original_string": "private static final Field KEY_FIELD_REGEX = Field.create(\"key.field.regex\")\n            .withDisplayName(\"Key field regex\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withValidation(Field::isRegex)\n            .withDescription(\"The regex used for extracting the physical table identifier from the original topic \" +\n                    \"name. Now that multiple physical tables can share a topic, the event's key may need to be augmented \" +\n                    \"to include fields other than just those for the record's primary/unique key, since these are not \" +\n                    \"guaranteed to be unique across tables. We need some identifier added to the key that distinguishes \" +\n                    \"the different physical tables.\");", "modifier": "private static final", "type": "Field", "declarator": "KEY_FIELD_REGEX = Field.create(\"key.field.regex\")\n            .withDisplayName(\"Key field regex\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withValidation(Field::isRegex)\n            .withDescription(\"The regex used for extracting the physical table identifier from the original topic \" +\n                    \"name. Now that multiple physical tables can share a topic, the event's key may need to be augmented \" +\n                    \"to include fields other than just those for the record's primary/unique key, since these are not \" +\n                    \"guaranteed to be unique across tables. We need some identifier added to the key that distinguishes \" +\n                    \"the different physical tables.\")", "var_name": "KEY_FIELD_REGEX"}, {"original_string": "private static final Field KEY_FIELD_NAME = Field.create(\"key.field.name\")\n            .withDisplayName(\"Key field name\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            // Default is prefixed with \"__dbz__\" to minimize the likelihood of a conflict with an existing key field name.\n            .withDefault(\"__dbz__physicalTableIdentifier\")\n            .withDescription(\"Each record's key schema will be augmented with this field name. The purpose of this \" +\n                    \"field is to distinguish the different physical tables that can now share a single topic. Make \" +\n                    \"sure not to configure a field name that is at risk of conflict with existing key schema field \" +\n                    \"names.\");", "modifier": "private static final", "type": "Field", "declarator": "KEY_FIELD_NAME = Field.create(\"key.field.name\")\n            .withDisplayName(\"Key field name\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            // Default is prefixed with \"__dbz__\" to minimize the likelihood of a conflict with an existing key field name.\n            .withDefault(\"__dbz__physicalTableIdentifier\")\n            .withDescription(\"Each record's key schema will be augmented with this field name. The purpose of this \" +\n                    \"field is to distinguish the different physical tables that can now share a single topic. Make \" +\n                    \"sure not to configure a field name that is at risk of conflict with existing key schema field \" +\n                    \"names.\")", "var_name": "KEY_FIELD_NAME"}, {"original_string": "private static final Field KEY_FIELD_REPLACEMENT = Field.create(\"key.field.replacement\")\n            .withDisplayName(\"Key field replacement\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withValidation(ByLogicalTableRouter::validateKeyFieldReplacement)\n            .withDescription(\"The replacement string used in conjunction with \" + KEY_FIELD_REGEX.name() +\n                    \". This will be used to create the physical table identifier in the record's key.\");", "modifier": "private static final", "type": "Field", "declarator": "KEY_FIELD_REPLACEMENT = Field.create(\"key.field.replacement\")\n            .withDisplayName(\"Key field replacement\")\n            .withType(ConfigDef.Type.STRING)\n            .withWidth(ConfigDef.Width.LONG)\n            .withImportance(ConfigDef.Importance.LOW)\n            .withValidation(ByLogicalTableRouter::validateKeyFieldReplacement)\n            .withDescription(\"The replacement string used in conjunction with \" + KEY_FIELD_REGEX.name() +\n                    \". This will be used to create the physical table identifier in the record's key.\")", "var_name": "KEY_FIELD_REPLACEMENT"}, {"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ByLogicalTableRouter.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ByLogicalTableRouter.class)", "var_name": "LOGGER"}, {"original_string": "private final SchemaNameAdjuster schemaNameAdjuster = SchemaNameAdjuster.create(LOGGER);", "modifier": "private final", "type": "SchemaNameAdjuster", "declarator": "schemaNameAdjuster = SchemaNameAdjuster.create(LOGGER)", "var_name": "schemaNameAdjuster"}, {"original_string": "private Pattern topicRegex;", "modifier": "private", "type": "Pattern", "declarator": "topicRegex", "var_name": "topicRegex"}, {"original_string": "private String topicReplacement;", "modifier": "private", "type": "String", "declarator": "topicReplacement", "var_name": "topicReplacement"}, {"original_string": "private Pattern keyFieldRegex;", "modifier": "private", "type": "Pattern", "declarator": "keyFieldRegex", "var_name": "keyFieldRegex"}, {"original_string": "private boolean keyEnforceUniqueness;", "modifier": "private", "type": "boolean", "declarator": "keyEnforceUniqueness", "var_name": "keyEnforceUniqueness"}, {"original_string": "private String keyFieldReplacement;", "modifier": "private", "type": "String", "declarator": "keyFieldReplacement", "var_name": "keyFieldReplacement"}, {"original_string": "private String keyFieldName;", "modifier": "private", "type": "String", "declarator": "keyFieldName", "var_name": "keyFieldName"}, {"original_string": "private final Cache<Schema, Schema> keySchemaUpdateCache = new SynchronizedCache<>(new LRUCache<Schema, Schema>(16));", "modifier": "private final", "type": "Cache<Schema, Schema>", "declarator": "keySchemaUpdateCache = new SynchronizedCache<>(new LRUCache<Schema, Schema>(16))", "var_name": "keySchemaUpdateCache"}, {"original_string": "private final Cache<Schema, Schema> envelopeSchemaUpdateCache = new SynchronizedCache<>(new LRUCache<Schema, Schema>(16));", "modifier": "private final", "type": "Cache<Schema, Schema>", "declarator": "envelopeSchemaUpdateCache = new SynchronizedCache<>(new LRUCache<Schema, Schema>(16))", "var_name": "envelopeSchemaUpdateCache"}, {"original_string": "private final Cache<String, String> keyRegexReplaceCache = new SynchronizedCache<>(new LRUCache<String, String>(16));", "modifier": "private final", "type": "Cache<String, String>", "declarator": "keyRegexReplaceCache = new SynchronizedCache<>(new LRUCache<String, String>(16))", "var_name": "keyRegexReplaceCache"}, {"original_string": "private final Cache<String, String> topicRegexReplaceCache = new SynchronizedCache<>(new LRUCache<String, String>(16));", "modifier": "private final", "type": "Cache<String, String>", "declarator": "topicRegexReplaceCache = new SynchronizedCache<>(new LRUCache<String, String>(16))", "var_name": "topicRegexReplaceCache"}, {"original_string": "private SmtManager<R> smtManager;", "modifier": "private", "type": "SmtManager<R>", "declarator": "smtManager", "var_name": "smtManager"}], "methods": [{"identifier": "validateKeyFieldReplacement", "parameters": "(Configuration config, Field field, Field.ValidationOutput problems)", "modifiers": "private static", "return": "int", "signature": "int validateKeyFieldReplacement(Configuration config, Field field, Field.ValidationOutput problems)", "full_signature": "private static int validateKeyFieldReplacement(Configuration config, Field field, Field.ValidationOutput problems)", "class_method_signature": "ByLogicalTableRouter.validateKeyFieldReplacement(Configuration config, Field field, Field.ValidationOutput problems)", "testcase": false, "constructor": false}, {"identifier": "configure", "parameters": "(Map<String, ?> props)", "modifiers": "@Override public", "return": "void", "signature": "void configure(Map<String, ?> props)", "full_signature": "@Override public void configure(Map<String, ?> props)", "class_method_signature": "ByLogicalTableRouter.configure(Map<String, ?> props)", "testcase": false, "constructor": false}, {"identifier": "apply", "parameters": "(R record)", "modifiers": "@Override public", "return": "R", "signature": "R apply(R record)", "full_signature": "@Override public R apply(R record)", "class_method_signature": "ByLogicalTableRouter.apply(R record)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "ByLogicalTableRouter.close()", "testcase": false, "constructor": false}, {"identifier": "config", "parameters": "()", "modifiers": "@Override public", "return": "ConfigDef", "signature": "ConfigDef config()", "full_signature": "@Override public ConfigDef config()", "class_method_signature": "ByLogicalTableRouter.config()", "testcase": false, "constructor": false}, {"identifier": "determineNewTopic", "parameters": "(String oldTopic)", "modifiers": "private", "return": "String", "signature": "String determineNewTopic(String oldTopic)", "full_signature": "private String determineNewTopic(String oldTopic)", "class_method_signature": "ByLogicalTableRouter.determineNewTopic(String oldTopic)", "testcase": false, "constructor": false}, {"identifier": "updateKeySchema", "parameters": "(Schema oldKeySchema, String newTopicName)", "modifiers": "private", "return": "Schema", "signature": "Schema updateKeySchema(Schema oldKeySchema, String newTopicName)", "full_signature": "private Schema updateKeySchema(Schema oldKeySchema, String newTopicName)", "class_method_signature": "ByLogicalTableRouter.updateKeySchema(Schema oldKeySchema, String newTopicName)", "testcase": false, "constructor": false}, {"identifier": "updateKey", "parameters": "(Schema newKeySchema, Struct oldKey, String oldTopic)", "modifiers": "private", "return": "Struct", "signature": "Struct updateKey(Schema newKeySchema, Struct oldKey, String oldTopic)", "full_signature": "private Struct updateKey(Schema newKeySchema, Struct oldKey, String oldTopic)", "class_method_signature": "ByLogicalTableRouter.updateKey(Schema newKeySchema, Struct oldKey, String oldTopic)", "testcase": false, "constructor": false}, {"identifier": "updateEnvelopeSchema", "parameters": "(Schema oldEnvelopeSchema, String newTopicName)", "modifiers": "private", "return": "Schema", "signature": "Schema updateEnvelopeSchema(Schema oldEnvelopeSchema, String newTopicName)", "full_signature": "private Schema updateEnvelopeSchema(Schema oldEnvelopeSchema, String newTopicName)", "class_method_signature": "ByLogicalTableRouter.updateEnvelopeSchema(Schema oldEnvelopeSchema, String newTopicName)", "testcase": false, "constructor": false}, {"identifier": "updateEnvelope", "parameters": "(Schema newEnvelopeSchema, Struct oldEnvelope)", "modifiers": "private", "return": "Struct", "signature": "Struct updateEnvelope(Schema newEnvelopeSchema, Struct oldEnvelope)", "full_signature": "private Struct updateEnvelope(Schema newEnvelopeSchema, Struct oldEnvelope)", "class_method_signature": "ByLogicalTableRouter.updateEnvelope(Schema newEnvelopeSchema, Struct oldEnvelope)", "testcase": false, "constructor": false}, {"identifier": "updateValue", "parameters": "(Schema newValueSchema, Struct oldValue)", "modifiers": "private", "return": "Struct", "signature": "Struct updateValue(Schema newValueSchema, Struct oldValue)", "full_signature": "private Struct updateValue(Schema newValueSchema, Struct oldValue)", "class_method_signature": "ByLogicalTableRouter.updateValue(Schema newValueSchema, Struct oldValue)", "testcase": false, "constructor": false}, {"identifier": "copySchemaExcludingName", "parameters": "(Schema source, SchemaBuilder builder)", "modifiers": "private", "return": "SchemaBuilder", "signature": "SchemaBuilder copySchemaExcludingName(Schema source, SchemaBuilder builder)", "full_signature": "private SchemaBuilder copySchemaExcludingName(Schema source, SchemaBuilder builder)", "class_method_signature": "ByLogicalTableRouter.copySchemaExcludingName(Schema source, SchemaBuilder builder)", "testcase": false, "constructor": false}, {"identifier": "copySchemaExcludingName", "parameters": "(Schema source, SchemaBuilder builder, boolean copyFields)", "modifiers": "private", "return": "SchemaBuilder", "signature": "SchemaBuilder copySchemaExcludingName(Schema source, SchemaBuilder builder, boolean copyFields)", "full_signature": "private SchemaBuilder copySchemaExcludingName(Schema source, SchemaBuilder builder, boolean copyFields)", "class_method_signature": "ByLogicalTableRouter.copySchemaExcludingName(Schema source, SchemaBuilder builder, boolean copyFields)", "testcase": false, "constructor": false}], "file": "debezium-core/src/main/java/io/debezium/transforms/ByLogicalTableRouter.java"}, "focal_method": {"identifier": "configure", "parameters": "(Map<String, ?> props)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void configure(Map<String, ?> props) {\n        Configuration config = Configuration.from(props);\n        final Field.Set configFields = Field.setOf(\n                TOPIC_REGEX,\n                TOPIC_REPLACEMENT,\n                KEY_ENFORCE_UNIQUENESS,\n                KEY_FIELD_REGEX,\n                KEY_FIELD_REPLACEMENT);\n\n        if (!config.validateAndRecord(configFields, LOGGER::error)) {\n            throw new ConnectException(\"Unable to validate config.\");\n        }\n\n        topicRegex = Pattern.compile(config.getString(TOPIC_REGEX));\n        topicReplacement = config.getString(TOPIC_REPLACEMENT);\n\n        String keyFieldRegexString = config.getString(KEY_FIELD_REGEX);\n        if (keyFieldRegexString != null) {\n            keyFieldRegexString = keyFieldRegexString.trim();\n        }\n        if (keyFieldRegexString != null && !keyFieldRegexString.isEmpty()) {\n            keyFieldRegex = Pattern.compile(config.getString(KEY_FIELD_REGEX));\n            keyFieldReplacement = config.getString(KEY_FIELD_REPLACEMENT);\n        }\n        keyFieldName = config.getString(KEY_FIELD_NAME);\n        keyEnforceUniqueness = config.getBoolean(KEY_ENFORCE_UNIQUENESS);\n\n        smtManager = new SmtManager<>(config);\n    }", "signature": "void configure(Map<String, ?> props)", "full_signature": "@Override public void configure(Map<String, ?> props)", "class_method_signature": "ByLogicalTableRouter.configure(Map<String, ?> props)", "testcase": false, "constructor": false, "invocations": ["from", "setOf", "validateAndRecord", "compile", "getString", "getString", "getString", "trim", "isEmpty", "compile", "getString", "getString", "getString", "getBoolean"]}, "repository": {"repo_id": 50205233, "url": "https://github.com/debezium/debezium", "stars": 2686, "created": "1/22/2016 8:17:05 PM +00:00", "updates": "2020-01-27T20:48:54+00:00", "fork": "False", "license": "licensed"}}