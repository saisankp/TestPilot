{"test_class": {"identifier": "BusinessCalendarImplTest", "superclass": "extends AbstractBaseTest", "interfaces": "", "fields": [], "file": "jbpm-flow/src/test/java/org/jbpm/process/core/timer/BusinessCalendarImplTest.java"}, "test_case": {"identifier": "testCalculateDaysPassingOverHolidayAtYearEndWithWildcards", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCalculateDaysPassingOverHolidayAtYearEndWithWildcards() {\n        Properties config = new Properties();\n        config.setProperty(BusinessCalendarImpl.HOLIDAYS, \"*-12-31:*-01-01\");\n        String expectedDate = \"2013-01-02 09:15\";\n        \n        SessionPseudoClock clock = new StaticPseudoClock(parseToDateWithTime(\"2012-12-28 16:45\").getTime());\n        BusinessCalendarImpl businessCal = new BusinessCalendarImpl(config, clock);\n        \n        \n        Date result = businessCal.calculateBusinessTimeAsDate(\"2d30m\");\n        \n        assertEquals(expectedDate, formatDate(\"yyyy-MM-dd HH:mm\", result));\n    }", "signature": "void testCalculateDaysPassingOverHolidayAtYearEndWithWildcards()", "full_signature": "@Test public void testCalculateDaysPassingOverHolidayAtYearEndWithWildcards()", "class_method_signature": "BusinessCalendarImplTest.testCalculateDaysPassingOverHolidayAtYearEndWithWildcards()", "testcase": true, "constructor": false, "invocations": ["setProperty", "getTime", "parseToDateWithTime", "calculateBusinessTimeAsDate", "assertEquals", "formatDate"]}, "focal_class": {"identifier": "BusinessCalendarImpl", "superclass": "", "interfaces": "implements BusinessCalendar", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(BusinessCalendarImpl.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(BusinessCalendarImpl.class)", "var_name": "logger"}, {"original_string": "private Properties businessCalendarConfiguration;", "modifier": "private", "type": "Properties", "declarator": "businessCalendarConfiguration", "var_name": "businessCalendarConfiguration"}, {"original_string": "private static final long HOUR_IN_MILLIS = 60 * 60 * 1000;", "modifier": "private static final", "type": "long", "declarator": "HOUR_IN_MILLIS = 60 * 60 * 1000", "var_name": "HOUR_IN_MILLIS"}, {"original_string": "private int daysPerWeek;", "modifier": "private", "type": "int", "declarator": "daysPerWeek", "var_name": "daysPerWeek"}, {"original_string": "private int hoursInDay;", "modifier": "private", "type": "int", "declarator": "hoursInDay", "var_name": "hoursInDay"}, {"original_string": "private int startHour;", "modifier": "private", "type": "int", "declarator": "startHour", "var_name": "startHour"}, {"original_string": "private int endHour;", "modifier": "private", "type": "int", "declarator": "endHour", "var_name": "endHour"}, {"original_string": "private  String timezone;", "modifier": "private", "type": "String", "declarator": "timezone", "var_name": "timezone"}, {"original_string": "private List<TimePeriod> holidays;", "modifier": "private", "type": "List<TimePeriod>", "declarator": "holidays", "var_name": "holidays"}, {"original_string": "private List<Integer> weekendDays= new ArrayList<Integer>();", "modifier": "private", "type": "List<Integer>", "declarator": "weekendDays= new ArrayList<Integer>()", "var_name": "weekendDays"}, {"original_string": "private SessionClock clock;", "modifier": "private", "type": "SessionClock", "declarator": "clock", "var_name": "clock"}, {"original_string": "private static final int     SIM_WEEK = 3;", "modifier": "private static final", "type": "int", "declarator": "SIM_WEEK = 3", "var_name": "SIM_WEEK"}, {"original_string": "private static final int     SIM_DAY = 5;", "modifier": "private static final", "type": "int", "declarator": "SIM_DAY = 5", "var_name": "SIM_DAY"}, {"original_string": "private static final int     SIM_HOU = 7;", "modifier": "private static final", "type": "int", "declarator": "SIM_HOU = 7", "var_name": "SIM_HOU"}, {"original_string": "private static final int     SIM_MIN = 9;", "modifier": "private static final", "type": "int", "declarator": "SIM_MIN = 9", "var_name": "SIM_MIN"}, {"original_string": "private static final int     SIM_SEC = 11;", "modifier": "private static final", "type": "int", "declarator": "SIM_SEC = 11", "var_name": "SIM_SEC"}, {"original_string": "public static final String DAYS_PER_WEEK = \"business.days.per.week\";", "modifier": "public static final", "type": "String", "declarator": "DAYS_PER_WEEK = \"business.days.per.week\"", "var_name": "DAYS_PER_WEEK"}, {"original_string": "public static final String HOURS_PER_DAY = \"business.hours.per.day\";", "modifier": "public static final", "type": "String", "declarator": "HOURS_PER_DAY = \"business.hours.per.day\"", "var_name": "HOURS_PER_DAY"}, {"original_string": "public static final String START_HOUR = \"business.start.hour\";", "modifier": "public static final", "type": "String", "declarator": "START_HOUR = \"business.start.hour\"", "var_name": "START_HOUR"}, {"original_string": "public static final String END_HOUR = \"business.end.hour\";", "modifier": "public static final", "type": "String", "declarator": "END_HOUR = \"business.end.hour\"", "var_name": "END_HOUR"}, {"original_string": "public static final String HOLIDAYS = \"business.holidays\";", "modifier": "public static final", "type": "String", "declarator": "HOLIDAYS = \"business.holidays\"", "var_name": "HOLIDAYS"}, {"original_string": "public static final String HOLIDAY_DATE_FORMAT = \"business.holiday.date.format\";", "modifier": "public static final", "type": "String", "declarator": "HOLIDAY_DATE_FORMAT = \"business.holiday.date.format\"", "var_name": "HOLIDAY_DATE_FORMAT"}, {"original_string": "public static final String WEEKEND_DAYS = \"business.weekend.days\";", "modifier": "public static final", "type": "String", "declarator": "WEEKEND_DAYS = \"business.weekend.days\"", "var_name": "WEEKEND_DAYS"}, {"original_string": "public static final String TIMEZONE = \"business.cal.timezone\";", "modifier": "public static final", "type": "String", "declarator": "TIMEZONE = \"business.cal.timezone\"", "var_name": "TIMEZONE"}, {"original_string": "private static final String DEFAULT_PROPERTIES_NAME = \"/jbpm.business.calendar.properties\";", "modifier": "private static final", "type": "String", "declarator": "DEFAULT_PROPERTIES_NAME = \"/jbpm.business.calendar.properties\"", "var_name": "DEFAULT_PROPERTIES_NAME"}], "methods": [{"identifier": "BusinessCalendarImpl", "parameters": "()", "modifiers": "public", "return": "", "signature": " BusinessCalendarImpl()", "full_signature": "public  BusinessCalendarImpl()", "class_method_signature": "BusinessCalendarImpl.BusinessCalendarImpl()", "testcase": false, "constructor": true}, {"identifier": "BusinessCalendarImpl", "parameters": "(Properties configuration)", "modifiers": "public", "return": "", "signature": " BusinessCalendarImpl(Properties configuration)", "full_signature": "public  BusinessCalendarImpl(Properties configuration)", "class_method_signature": "BusinessCalendarImpl.BusinessCalendarImpl(Properties configuration)", "testcase": false, "constructor": true}, {"identifier": "BusinessCalendarImpl", "parameters": "(Properties configuration, SessionClock clock)", "modifiers": "public", "return": "", "signature": " BusinessCalendarImpl(Properties configuration, SessionClock clock)", "full_signature": "public  BusinessCalendarImpl(Properties configuration, SessionClock clock)", "class_method_signature": "BusinessCalendarImpl.BusinessCalendarImpl(Properties configuration, SessionClock clock)", "testcase": false, "constructor": true}, {"identifier": "init", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void init()", "full_signature": "protected void init()", "class_method_signature": "BusinessCalendarImpl.init()", "testcase": false, "constructor": false}, {"identifier": "adoptISOFormat", "parameters": "(String timeExpression)", "modifiers": "protected", "return": "String", "signature": "String adoptISOFormat(String timeExpression)", "full_signature": "protected String adoptISOFormat(String timeExpression)", "class_method_signature": "BusinessCalendarImpl.adoptISOFormat(String timeExpression)", "testcase": false, "constructor": false}, {"identifier": "calculateBusinessTimeAsDuration", "parameters": "(String timeExpression)", "modifiers": "public", "return": "long", "signature": "long calculateBusinessTimeAsDuration(String timeExpression)", "full_signature": "public long calculateBusinessTimeAsDuration(String timeExpression)", "class_method_signature": "BusinessCalendarImpl.calculateBusinessTimeAsDuration(String timeExpression)", "testcase": false, "constructor": false}, {"identifier": "calculateBusinessTimeAsDate", "parameters": "(String timeExpression)", "modifiers": "public", "return": "Date", "signature": "Date calculateBusinessTimeAsDate(String timeExpression)", "full_signature": "public Date calculateBusinessTimeAsDate(String timeExpression)", "class_method_signature": "BusinessCalendarImpl.calculateBusinessTimeAsDate(String timeExpression)", "testcase": false, "constructor": false}, {"identifier": "handleHoliday", "parameters": "(Calendar c, boolean resetTime)", "modifiers": "protected", "return": "void", "signature": "void handleHoliday(Calendar c, boolean resetTime)", "full_signature": "protected void handleHoliday(Calendar c, boolean resetTime)", "class_method_signature": "BusinessCalendarImpl.handleHoliday(Calendar c, boolean resetTime)", "testcase": false, "constructor": false}, {"identifier": "getPropertyAsInt", "parameters": "(String propertyName, String defaultValue)", "modifiers": "protected", "return": "int", "signature": "int getPropertyAsInt(String propertyName, String defaultValue)", "full_signature": "protected int getPropertyAsInt(String propertyName, String defaultValue)", "class_method_signature": "BusinessCalendarImpl.getPropertyAsInt(String propertyName, String defaultValue)", "testcase": false, "constructor": false}, {"identifier": "parseHolidays", "parameters": "()", "modifiers": "protected", "return": "List<TimePeriod>", "signature": "List<TimePeriod> parseHolidays()", "full_signature": "protected List<TimePeriod> parseHolidays()", "class_method_signature": "BusinessCalendarImpl.parseHolidays()", "testcase": false, "constructor": false}, {"identifier": "parseWeekendDays", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void parseWeekendDays()", "full_signature": "protected void parseWeekendDays()", "class_method_signature": "BusinessCalendarImpl.parseWeekendDays()", "testcase": false, "constructor": false}, {"identifier": "getCurrentTime", "parameters": "()", "modifiers": "protected", "return": "long", "signature": "long getCurrentTime()", "full_signature": "protected long getCurrentTime()", "class_method_signature": "BusinessCalendarImpl.getCurrentTime()", "testcase": false, "constructor": false}, {"identifier": "isWorkingDay", "parameters": "(int day)", "modifiers": "protected", "return": "boolean", "signature": "boolean isWorkingDay(int day)", "full_signature": "protected boolean isWorkingDay(int day)", "class_method_signature": "BusinessCalendarImpl.isWorkingDay(int day)", "testcase": false, "constructor": false}, {"identifier": "handleWeekend", "parameters": "(Calendar c, boolean resetTime)", "modifiers": "protected", "return": "void", "signature": "void handleWeekend(Calendar c, boolean resetTime)", "full_signature": "protected void handleWeekend(Calendar c, boolean resetTime)", "class_method_signature": "BusinessCalendarImpl.handleWeekend(Calendar c, boolean resetTime)", "testcase": false, "constructor": false}], "file": "jbpm-flow/src/main/java/org/jbpm/process/core/timer/BusinessCalendarImpl.java"}, "focal_method": {"identifier": "calculateBusinessTimeAsDate", "parameters": "(String timeExpression)", "modifiers": "public", "return": "Date", "body": "public Date calculateBusinessTimeAsDate(String timeExpression) {\n    \ttimeExpression = adoptISOFormat(timeExpression);\n\n        String trimmed = timeExpression.trim();\n        int weeks = 0;\n        int days = 0;\n        int hours = 0;\n        int min = 0;\n        int sec = 0;\n        \n        if( trimmed.length() > 0 ) {\n            Matcher mat = PatternConstants.SIMPLE_TIME_DATE_MATCHER.matcher(trimmed );\n            if ( mat.matches() ) {\n                weeks = (mat.group( SIM_WEEK ) != null) ? Integer.parseInt( mat.group( SIM_WEEK ) ) : 0;\n                days = (mat.group( SIM_DAY ) != null) ? Integer.parseInt( mat.group( SIM_DAY ) ) : 0;\n                hours = (mat.group( SIM_HOU ) != null) ? Integer.parseInt( mat.group( SIM_HOU ) ) : 0;\n                min = (mat.group( SIM_MIN ) != null) ? Integer.parseInt( mat.group( SIM_MIN ) ) : 0;\n                sec = (mat.group( SIM_SEC ) != null) ? Integer.parseInt( mat.group( SIM_SEC ) ) : 0;\n            }\n        }\n        int time = 0;\n        \n        Calendar c = new GregorianCalendar();\n        if (timezone != null) {\n            c.setTimeZone(TimeZone.getTimeZone(timezone));\n        }\n        if (this.clock != null) {\n            c.setTimeInMillis(this.clock.getCurrentTime());\n        }\n        \n        \n        // calculate number of weeks\n        int numberOfWeeks = days/daysPerWeek + weeks;\n        if (numberOfWeeks > 0) {\n            c.add(Calendar.WEEK_OF_YEAR, numberOfWeeks);\n        }\n        handleWeekend(c, hours > 0 || min > 0);\n        hours += (days - (numberOfWeeks * daysPerWeek)) * hoursInDay;\n        \n        // calculate number of days\n        int numberOfDays = hours/hoursInDay;\n        if (numberOfDays > 0) {\n            for (int i = 0; i < numberOfDays; i++) {\n                c.add(Calendar.DAY_OF_YEAR, 1);\n                handleWeekend(c, false);\n                handleHoliday(c, hours > 0 || min > 0);\n            }\n        }\n\n        int currentCalHour = c.get(Calendar.HOUR_OF_DAY);\n        if (currentCalHour >= endHour) {\n            c.add(Calendar.DAY_OF_YEAR, 1);\n            c.add(Calendar.HOUR_OF_DAY, startHour-currentCalHour);\n            c.set(Calendar.MINUTE, 0);\n            c.set(Calendar.SECOND, 0);\n        } else if (currentCalHour < startHour) {\n            c.add(Calendar.HOUR_OF_DAY, startHour);\n        }\n\n        // calculate remaining hours\n        time = hours - (numberOfDays * hoursInDay);\n        c.add(Calendar.HOUR, time);\n        handleWeekend(c, true);\n        handleHoliday(c, hours > 0 || min > 0);\n        \n        currentCalHour = c.get(Calendar.HOUR_OF_DAY);\n        if (currentCalHour >= endHour) {\n            c.add(Calendar.DAY_OF_YEAR, 1);\n            // set hour to the starting one\n            c.set(Calendar.HOUR_OF_DAY, startHour);\n            c.add(Calendar.HOUR_OF_DAY, currentCalHour - endHour);\n        } else if (currentCalHour < startHour) {\n            c.add(Calendar.HOUR_OF_DAY, startHour);\n        }\n        \n        // calculate minutes\n        int numberOfHours = min/60;\n        if (numberOfHours > 0) {\n            c.add(Calendar.HOUR, numberOfHours);\n            min = min-(numberOfHours * 60);\n        }\n        c.add(Calendar.MINUTE, min);\n        \n        // calculate seconds\n        int numberOfMinutes = sec/60;\n        if (numberOfMinutes > 0) {\n            c.add(Calendar.MINUTE, numberOfMinutes);\n            sec = sec-(numberOfMinutes * 60);\n        }\n        c.add(Calendar.SECOND, sec);\n        \n        currentCalHour = c.get(Calendar.HOUR_OF_DAY);\n        if (currentCalHour >= endHour) {\n            c.add(Calendar.DAY_OF_YEAR, 1);\n            // set hour to the starting one\n            c.set(Calendar.HOUR_OF_DAY, startHour);\n            c.add(Calendar.HOUR_OF_DAY, currentCalHour - endHour);\n        } else if (currentCalHour < startHour) {\n            c.add(Calendar.HOUR_OF_DAY, startHour);\n        }\n        // take under consideration weekend\n        handleWeekend(c, false);\n        // take under consideration holidays\n        handleHoliday(c, false);\n \n        return c.getTime();\n    }", "signature": "Date calculateBusinessTimeAsDate(String timeExpression)", "full_signature": "public Date calculateBusinessTimeAsDate(String timeExpression)", "class_method_signature": "BusinessCalendarImpl.calculateBusinessTimeAsDate(String timeExpression)", "testcase": false, "constructor": false, "invocations": ["adoptISOFormat", "trim", "length", "matcher", "matches", "group", "parseInt", "group", "group", "parseInt", "group", "group", "parseInt", "group", "group", "parseInt", "group", "group", "parseInt", "group", "setTimeZone", "getTimeZone", "setTimeInMillis", "getCurrentTime", "add", "handleWeekend", "add", "handleWeekend", "handleHoliday", "get", "add", "add", "set", "set", "add", "add", "handleWeekend", "handleHoliday", "get", "add", "set", "add", "add", "add", "add", "add", "add", "get", "add", "set", "add", "add", "handleWeekend", "handleHoliday", "getTime"]}, "repository": {"repo_id": 930571, "url": "https://github.com/kiegroup/jbpm", "stars": 1035, "created": "9/22/2010 1:19:52 PM +00:00", "updates": "2020-01-22T03:39:57+00:00", "fork": "False", "license": "licensed"}}