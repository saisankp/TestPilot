{"test_class": {"identifier": "ConditionBuilderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static PersonDefinition p = Person.PERSON;", "modifier": "private static", "type": "PersonDefinition", "declarator": "p = Person.PERSON", "var_name": "p"}], "file": "das-client/src/test/java/com/ppdai/das/client/sqlbuilder/ConditionBuilderTest.java"}, "test_case": {"identifier": "testInsertWithColumnListBySelect", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testInsertWithColumnListBySelect() throws SQLException {\n        SqlBuilder builder = SqlBuilder.insertInto(p, p.Name, p.CountryID);\n        builder.append(SqlBuilder.select(p.Name).from(p).where().allOf(p.Name.eq(1), p.CountryID.gt(2)));\n        ConditionList cl = builder.buildUpdateConditions();\n        assertTrue(cl.isIntersected());\n        assertEquals(2, cl.size());\n    }", "signature": "void testInsertWithColumnListBySelect()", "full_signature": "@Test public void testInsertWithColumnListBySelect()", "class_method_signature": "ConditionBuilderTest.testInsertWithColumnListBySelect()", "testcase": true, "constructor": false, "invocations": ["insertInto", "append", "allOf", "where", "from", "select", "eq", "gt", "buildUpdateConditions", "assertTrue", "isIntersected", "assertEquals", "size"]}, "focal_class": {"identifier": "ConditionBuilder", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Set<Segment> expressionCandidates = new HashSet<>();", "modifier": "private static", "type": "Set<Segment>", "declarator": "expressionCandidates = new HashSet<>()", "var_name": "expressionCandidates"}, {"original_string": "private static Set<Segment> columnReferenceCandidates = new HashSet<>();", "modifier": "private static", "type": "Set<Segment>", "declarator": "columnReferenceCandidates = new HashSet<>()", "var_name": "columnReferenceCandidates"}], "methods": [{"identifier": "buildQueryConditions", "parameters": "(List<Segment> filtered)", "modifiers": "public", "return": "ConditionList", "signature": "ConditionList buildQueryConditions(List<Segment> filtered)", "full_signature": "public ConditionList buildQueryConditions(List<Segment> filtered)", "class_method_signature": "ConditionBuilder.buildQueryConditions(List<Segment> filtered)", "testcase": false, "constructor": false}, {"identifier": "buildUpdateConditions", "parameters": "(List<Segment> filtered)", "modifiers": "public", "return": "ConditionList", "signature": "ConditionList buildUpdateConditions(List<Segment> filtered)", "full_signature": "public ConditionList buildUpdateConditions(List<Segment> filtered)", "class_method_signature": "ConditionBuilder.buildUpdateConditions(List<Segment> filtered)", "testcase": false, "constructor": false}, {"identifier": "filterColumnList", "parameters": "(List<Segment> originalList)", "modifiers": "private", "return": "List<Segment>", "signature": "List<Segment> filterColumnList(List<Segment> originalList)", "full_signature": "private List<Segment> filterColumnList(List<Segment> originalList)", "class_method_signature": "ConditionBuilder.filterColumnList(List<Segment> originalList)", "testcase": false, "constructor": false}, {"identifier": "isColumnList", "parameters": "(List<Segment> bracketContents)", "modifiers": "private", "return": "boolean", "signature": "boolean isColumnList(List<Segment> bracketContents)", "full_signature": "private boolean isColumnList(List<Segment> bracketContents)", "class_method_signature": "ConditionBuilder.isColumnList(List<Segment> bracketContents)", "testcase": false, "constructor": false}, {"identifier": "buildByParameters", "parameters": "(List<Segment> filtered)", "modifiers": "private", "return": "ConditionList", "signature": "ConditionList buildByParameters(List<Segment> filtered)", "full_signature": "private ConditionList buildByParameters(List<Segment> filtered)", "class_method_signature": "ConditionBuilder.buildByParameters(List<Segment> filtered)", "testcase": false, "constructor": false}, {"identifier": "parseCondition", "parameters": "(ConditionList providers, List<Segment> conditionList)", "modifiers": "private", "return": "void", "signature": "void parseCondition(ConditionList providers, List<Segment> conditionList)", "full_signature": "private void parseCondition(ConditionList providers, List<Segment> conditionList)", "class_method_signature": "ConditionBuilder.parseCondition(ConditionList providers, List<Segment> conditionList)", "testcase": false, "constructor": false}, {"identifier": "parseCondition", "parameters": "(List<Segment> filtered)", "modifiers": "private", "return": "Condition", "signature": "Condition parseCondition(List<Segment> filtered)", "full_signature": "private Condition parseCondition(List<Segment> filtered)", "class_method_signature": "ConditionBuilder.parseCondition(List<Segment> filtered)", "testcase": false, "constructor": false}, {"identifier": "getTop", "parameters": "(Stack<Segment> stack)", "modifiers": "private", "return": "Segment", "signature": "Segment getTop(Stack<Segment> stack)", "full_signature": "private Segment getTop(Stack<Segment> stack)", "class_method_signature": "ConditionBuilder.getTop(Stack<Segment> stack)", "testcase": false, "constructor": false}, {"identifier": "combine", "parameters": "(Segment entry, LinkedList<Condition> providers)", "modifiers": "private", "return": "void", "signature": "void combine(Segment entry, LinkedList<Condition> providers)", "full_signature": "private void combine(Segment entry, LinkedList<Condition> providers)", "class_method_signature": "ConditionBuilder.combine(Segment entry, LinkedList<Condition> providers)", "testcase": false, "constructor": false}, {"identifier": "isConditionCandidate", "parameters": "(Segment segment)", "modifiers": "private", "return": "boolean", "signature": "boolean isConditionCandidate(Segment segment)", "full_signature": "private boolean isConditionCandidate(Segment segment)", "class_method_signature": "ConditionBuilder.isConditionCandidate(Segment segment)", "testcase": false, "constructor": false}, {"identifier": "isProvider", "parameters": "(Segment segment)", "modifiers": "private", "return": "boolean", "signature": "boolean isProvider(Segment segment)", "full_signature": "private boolean isProvider(Segment segment)", "class_method_signature": "ConditionBuilder.isProvider(Segment segment)", "testcase": false, "constructor": false}, {"identifier": "isLeft", "parameters": "(Segment segment)", "modifiers": "private", "return": "boolean", "signature": "boolean isLeft(Segment segment)", "full_signature": "private boolean isLeft(Segment segment)", "class_method_signature": "ConditionBuilder.isLeft(Segment segment)", "testcase": false, "constructor": false}, {"identifier": "isRight", "parameters": "(Segment segment)", "modifiers": "private", "return": "boolean", "signature": "boolean isRight(Segment segment)", "full_signature": "private boolean isRight(Segment segment)", "class_method_signature": "ConditionBuilder.isRight(Segment segment)", "testcase": false, "constructor": false}, {"identifier": "isAnd", "parameters": "(Segment segment)", "modifiers": "private", "return": "boolean", "signature": "boolean isAnd(Segment segment)", "full_signature": "private boolean isAnd(Segment segment)", "class_method_signature": "ConditionBuilder.isAnd(Segment segment)", "testcase": false, "constructor": false}, {"identifier": "isOr", "parameters": "(Segment segment)", "modifiers": "private", "return": "boolean", "signature": "boolean isOr(Segment segment)", "full_signature": "private boolean isOr(Segment segment)", "class_method_signature": "ConditionBuilder.isOr(Segment segment)", "testcase": false, "constructor": false}, {"identifier": "isNot", "parameters": "(Segment segment)", "modifiers": "private", "return": "boolean", "signature": "boolean isNot(Segment segment)", "full_signature": "private boolean isNot(Segment segment)", "class_method_signature": "ConditionBuilder.isNot(Segment segment)", "testcase": false, "constructor": false}], "file": "das-client/src/main/java/com/ppdai/das/client/sqlbuilder/ConditionBuilder.java"}, "focal_method": {"identifier": "buildUpdateConditions", "parameters": "(List<Segment> filtered)", "modifiers": "public", "return": "ConditionList", "body": "public ConditionList buildUpdateConditions(List<Segment> filtered) {\n        /*\n         * There are there kind of insert for mysql:\n         * insert into table (column1, column2...) value/values (value list)\n         * insert into table SET column1 = value1, column2 = value2, ...\n         * insert into table select *\n         * \n         * And every sql can be append with ON DUPLICATE KEY UPDATE assignment_lis :(\n         */\n        if(filtered.contains(SegmentConstants.INSERT)) {\n            if(filtered.contains(SegmentConstants.SELECT) || filtered.contains(SegmentConstants.SET)) {\n                filtered = filterColumnList(filtered);\n                return buildQueryConditions(filtered);\n            }\n            \n            return buildByParameters(filtered);\n        }\n        \n        if(filtered.contains(SegmentConstants.DELETE)) {\n            return buildQueryConditions(filtered);\n        }\n        \n        /**\n         * For UPDATE, the SET section will be union with WHERE section\n         */\n        if(filtered.contains(SegmentConstants.UPDATE)) {\n            return buildQueryConditions(filtered);\n        }\n        \n        return buildByParameters(filtered);\n    }", "signature": "ConditionList buildUpdateConditions(List<Segment> filtered)", "full_signature": "public ConditionList buildUpdateConditions(List<Segment> filtered)", "class_method_signature": "ConditionBuilder.buildUpdateConditions(List<Segment> filtered)", "testcase": false, "constructor": false, "invocations": ["contains", "contains", "contains", "filterColumnList", "buildQueryConditions", "buildByParameters", "contains", "buildQueryConditions", "contains", "buildQueryConditions", "buildByParameters"]}, "repository": {"repo_id": 214933909, "url": "https://github.com/ppdaicorp/das", "stars": 55, "created": "10/14/2019 2:49:17 AM +00:00", "updates": "2020-01-20T09:24:23+00:00", "fork": "False", "license": "licensed"}}