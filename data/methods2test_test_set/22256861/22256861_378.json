{"test_class": {"identifier": "MphChlOpTest", "superclass": "", "interfaces": "", "fields": [], "file": "s3tbx-mphchl/src/test/java/org/esa/s3tbx/mphchl/MphChlOpTest.java"}, "test_case": {"identifier": "testGetSensorType", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGetSensorType() {\n\n        Product sourceProduct = new Product(\"test\", \"test\", 1, 1);\n        for (String bandName : MphChlConstants.MERIS_REQUIRED_RADIANCE_BAND_NAMES) {\n            sourceProduct.addBand(bandName, ProductData.TYPE_FLOAT32);\n        }\n        Sensor sensor = MphChlOp.getSensorType(sourceProduct);\n        assertEquals(sensor, Sensor.MERIS_3RD);\n\n        sourceProduct = new Product(\"test2\", \"test2\", 1, 1);\n        for (String bandName : MphChlConstants.MERIS_REQUIRED_RADIANCE_BAND_NAMES_4TH) {\n            sourceProduct.addBand(bandName, ProductData.TYPE_FLOAT32);\n        }\n        sensor = MphChlOp.getSensorType(sourceProduct);\n        assertEquals(sensor, Sensor.MERIS_4TH);\n\n        sourceProduct = new Product(\"test3\", \"test3\", 1, 1);\n        for (String bandName : MphChlConstants.OLCI_REQUIRED_RADIANCE_BAND_NAMES) {\n            sourceProduct.addBand(bandName, ProductData.TYPE_FLOAT32);\n        }\n        sensor = MphChlOp.getSensorType(sourceProduct);\n        assertEquals(sensor, Sensor.OLCI);\n\n        sourceProduct = new Product(\"test4\", \"test4\", 1, 1);\n        for (String bandName : MphChlConstants.MERIS_REQUIRED_BRR_BAND_NAMES) {\n            sourceProduct.addBand(bandName, ProductData.TYPE_FLOAT32);\n        }\n        sourceProduct.addBand(SensorConstants.MERIS_L1B_FLAGS_NAME, ProductData.TYPE_UINT8);\n        sensor = MphChlOp.getSensorType(sourceProduct);\n        assertEquals(sensor, Sensor.MERIS_3RD);\n\n        sourceProduct = new Product(\"test5\", \"test5\", 1, 1);\n        for (String bandName : MphChlConstants.MERIS_REQUIRED_BRR_BAND_NAMES) {\n            sourceProduct.addBand(bandName, ProductData.TYPE_FLOAT32);\n        }\n        sourceProduct.addBand(SensorConstants.MERIS_4TH_L1B_FLAGS_NAME, ProductData.TYPE_INT16);\n        sensor = MphChlOp.getSensorType(sourceProduct);\n        assertEquals(sensor, Sensor.MERIS_4TH);\n\n        sourceProduct = new Product(\"test6\", \"test6\", 1, 1);\n        for (String bandName : MphChlConstants.OLCI_REQUIRED_BRR_BAND_NAMES) {\n            sourceProduct.addBand(bandName, ProductData.TYPE_FLOAT32);\n        }\n        sensor = MphChlOp.getSensorType(sourceProduct);\n        assertEquals(sensor, Sensor.OLCI);\n    }", "signature": "void testGetSensorType()", "full_signature": "@Test public void testGetSensorType()", "class_method_signature": "MphChlOpTest.testGetSensorType()", "testcase": true, "constructor": false, "invocations": ["addBand", "getSensorType", "assertEquals", "addBand", "getSensorType", "assertEquals", "addBand", "getSensorType", "assertEquals", "addBand", "addBand", "getSensorType", "assertEquals", "addBand", "addBand", "getSensorType", "assertEquals", "addBand", "getSensorType", "assertEquals"]}, "focal_class": {"identifier": "MphChlOp", "superclass": "extends Operator", "interfaces": "", "fields": [{"original_string": "@Parameter(defaultValue = \"\",\n            description = \"Expression defining pixels considered for processing. \" +\n                    \"If not set, all valid pixels over water are processed.\",\n            converter = BooleanExpressionConverter.class)\n    private String validPixelExpression;", "modifier": "@Parameter(defaultValue = \"\",\n            description = \"Expression defining pixels considered for processing. \" +\n                    \"If not set, all valid pixels over water are processed.\",\n            converter = BooleanExpressionConverter.class)\n    private", "type": "String", "declarator": "validPixelExpression", "var_name": "validPixelExpression"}, {"original_string": "@Parameter(defaultValue = \"1000.0\",\n            description = \"Maximum chlorophyll, arithmetically higher values are capped.\")\n    private double cyanoMaxValue;", "modifier": "@Parameter(defaultValue = \"1000.0\",\n            description = \"Maximum chlorophyll, arithmetically higher values are capped.\")\n    private", "type": "double", "declarator": "cyanoMaxValue", "var_name": "cyanoMaxValue"}, {"original_string": "@Parameter(defaultValue = \"500.0\",\n            description = \"Chlorophyll threshold, above which all cyanobacteria dominated waters are 'float'.\")\n    private double chlThreshForFloatFlag;", "modifier": "@Parameter(defaultValue = \"500.0\",\n            description = \"Chlorophyll threshold, above which all cyanobacteria dominated waters are 'float'.\")\n    private", "type": "double", "declarator": "chlThreshForFloatFlag", "var_name": "chlThreshForFloatFlag"}, {"original_string": "@Parameter(defaultValue = \"false\",\n            description = \"Switch to true to write 'mph' band.\")\n    boolean exportMph;", "modifier": "@Parameter(defaultValue = \"false\",\n            description = \"Switch to true to write 'mph' band.\")", "type": "boolean", "declarator": "exportMph", "var_name": "exportMph"}, {"original_string": "@Parameter(defaultValue = \"false\",\n            description = \"Switch to true to apply a 3x3 low-pass filter on the result.\")\n    boolean applyLowPassFilter;", "modifier": "@Parameter(defaultValue = \"false\",\n            description = \"Switch to true to apply a 3x3 low-pass filter on the result.\")", "type": "boolean", "declarator": "applyLowPassFilter", "var_name": "applyLowPassFilter"}, {"original_string": "@SourceProduct(description = \"L1b or Rayleigh corrected product\", label = \"OLCI or MERIS L1b or Rayleigh corrected product\")\n    private Product sourceProduct;", "modifier": "@SourceProduct(description = \"L1b or Rayleigh corrected product\", label = \"OLCI or MERIS L1b or Rayleigh corrected product\")\n    private", "type": "Product", "declarator": "sourceProduct", "var_name": "sourceProduct"}], "methods": [{"identifier": "initialize", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void initialize()", "full_signature": "@Override public void initialize()", "class_method_signature": "MphChlOp.initialize()", "testcase": false, "constructor": false}, {"identifier": "createFilteredProduct", "parameters": "(Product mphChlProduct)", "modifiers": "private", "return": "Product", "signature": "Product createFilteredProduct(Product mphChlProduct)", "full_signature": "private Product createFilteredProduct(Product mphChlProduct)", "class_method_signature": "MphChlOp.createFilteredProduct(Product mphChlProduct)", "testcase": false, "constructor": false}, {"identifier": "getJaiKernel", "parameters": "()", "modifiers": "private", "return": "KernelJAI", "signature": "KernelJAI getJaiKernel()", "full_signature": "private KernelJAI getJaiKernel()", "class_method_signature": "MphChlOp.getJaiKernel()", "testcase": false, "constructor": false}, {"identifier": "createMphChlPixelProduct", "parameters": "()", "modifiers": "private", "return": "Product", "signature": "Product createMphChlPixelProduct()", "full_signature": "private Product createMphChlPixelProduct()", "class_method_signature": "MphChlOp.createMphChlPixelProduct()", "testcase": false, "constructor": false}, {"identifier": "getSensorType", "parameters": "(Product sourceProduct)", "modifiers": "static", "return": "Sensor", "signature": "Sensor getSensorType(Product sourceProduct)", "full_signature": "static Sensor getSensorType(Product sourceProduct)", "class_method_signature": "MphChlOp.getSensorType(Product sourceProduct)", "testcase": false, "constructor": false}, {"identifier": "isValidL1bSourceProduct", "parameters": "(Product sourceProduct, Sensor sensor)", "modifiers": "static", "return": "boolean", "signature": "boolean isValidL1bSourceProduct(Product sourceProduct, Sensor sensor)", "full_signature": "static boolean isValidL1bSourceProduct(Product sourceProduct, Sensor sensor)", "class_method_signature": "MphChlOp.isValidL1bSourceProduct(Product sourceProduct, Sensor sensor)", "testcase": false, "constructor": false}, {"identifier": "isValidBrrSourceProduct", "parameters": "(Product sourceProduct, Sensor sensor)", "modifiers": "static", "return": "boolean", "signature": "boolean isValidBrrSourceProduct(Product sourceProduct, Sensor sensor)", "full_signature": "static boolean isValidBrrSourceProduct(Product sourceProduct, Sensor sensor)", "class_method_signature": "MphChlOp.isValidBrrSourceProduct(Product sourceProduct, Sensor sensor)", "testcase": false, "constructor": false}, {"identifier": "getSensorFromBrrSourceProduct", "parameters": "(String[] sourceBands)", "modifiers": "static", "return": "Sensor", "signature": "Sensor getSensorFromBrrSourceProduct(String[] sourceBands)", "full_signature": "static Sensor getSensorFromBrrSourceProduct(String[] sourceBands)", "class_method_signature": "MphChlOp.getSensorFromBrrSourceProduct(String[] sourceBands)", "testcase": false, "constructor": false}], "file": "s3tbx-mphchl/src/main/java/org/esa/s3tbx/mphchl/MphChlOp.java"}, "focal_method": {"identifier": "getSensorType", "parameters": "(Product sourceProduct)", "modifiers": "static", "return": "Sensor", "body": "static Sensor getSensorType(Product sourceProduct) {\n        boolean isOlci = isValidL1bSourceProduct(sourceProduct, Sensor.OLCI) ||\n                isValidBrrSourceProduct(sourceProduct, Sensor.OLCI);\n        if (isOlci) {\n            return Sensor.OLCI;\n        }\n\n        boolean isMeris3rd = isValidL1bSourceProduct(sourceProduct, Sensor.MERIS_3RD) ||\n                (isValidBrrSourceProduct(sourceProduct, Sensor.MERIS_3RD) &&\n                        sourceProduct.containsBand(SensorConstants.MERIS_L1B_FLAGS_NAME));\n        if (isMeris3rd) {\n            return Sensor.MERIS_3RD;\n        }\n\n        boolean isMeris4th = isValidL1bSourceProduct(sourceProduct, Sensor.MERIS_4TH) ||\n                (isValidBrrSourceProduct(sourceProduct, Sensor.MERIS_4TH) &&\n                        sourceProduct.containsBand(SensorConstants.MERIS_4TH_L1B_FLAGS_NAME));\n        if (isMeris4th) {\n            return Sensor.MERIS_4TH;\n        }\n\n        throw new OperatorException(\"Source product not applicable to this operator.\\n\" +\n                                            \"Only OLCI and MERIS are supported\");\n    }", "signature": "Sensor getSensorType(Product sourceProduct)", "full_signature": "static Sensor getSensorType(Product sourceProduct)", "class_method_signature": "MphChlOp.getSensorType(Product sourceProduct)", "testcase": false, "constructor": false, "invocations": ["isValidL1bSourceProduct", "isValidBrrSourceProduct", "isValidL1bSourceProduct", "isValidBrrSourceProduct", "containsBand", "isValidL1bSourceProduct", "isValidBrrSourceProduct", "containsBand"]}, "repository": {"repo_id": 22256861, "url": "https://github.com/senbox-org/s3tbx", "stars": 22, "created": "7/25/2014 12:57:22 PM +00:00", "updates": "2020-01-27T10:23:46+00:00", "fork": "False", "license": "licensed"}}