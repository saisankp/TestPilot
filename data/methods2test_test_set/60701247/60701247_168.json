{"test_class": {"identifier": "AndroidLogcatReceiverTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private AndroidLogcatService.LogcatListener myLogcatListener;", "modifier": "private", "type": "AndroidLogcatService.LogcatListener", "declarator": "myLogcatListener", "var_name": "myLogcatListener"}, {"original_string": "private AndroidLogcatReceiver myReceiver;", "modifier": "private", "type": "AndroidLogcatReceiver", "declarator": "myReceiver", "var_name": "myReceiver"}], "file": "android/testSrc/com/android/tools/idea/logcat/AndroidLogcatReceiverTest.java"}, "test_case": {"identifier": "testParseAllLogLevelsAndHexThreadIds", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testParseAllLogLevelsAndHexThreadIds() {\n    String[] messages = new String[]{\n      \"[ 1534039867.132   495:0x1ef D/dtag     ]\",\n      \"debug message\",\n      \"[ 1534039867.132   495:  234 E/etag     ]\",\n      \"error message\",\n      \"[ 1534039867.132   495:0x1ef I/itag     ]\",\n      \"info message\",\n      \"[ 1534039867.132   495:0x1ef V/vtag     ]\",\n      \"verbose message\",\n      \"[ 1534039867.132   495:0x1ef W/wtag     ]\",\n      \"warning message\",\n      \"[ 1534039867.132   495:0x1ef F/wtftag   ]\",\n      \"wtf message\",\n      \"[ 1534047335.754   540:0x21c D/debug tag    ]\",\n      \"debug message\",\n      \"[ 1534047335.754   540:0x21c I/tag:with:colons ]\",\n      \"message:with:colons\",\n    };\n\n    for (String message : messages) {\n      myReceiver.processNewLine(message);\n    }\n\n    String expected = \"2018-08-11 19:11:07.132 495-495/? D/dtag: debug message\\n\" +\n                      \"2018-08-11 19:11:07.132 495-234/? E/etag: error message\\n\" +\n                      \"2018-08-11 19:11:07.132 495-495/? I/itag: info message\\n\" +\n                      \"2018-08-11 19:11:07.132 495-495/? V/vtag: verbose message\\n\" +\n                      \"2018-08-11 19:11:07.132 495-495/? W/wtag: warning message\\n\" +\n                      \"2018-08-11 19:11:07.132 495-495/? A/wtftag: wtf message\\n\" +\n                      // NOTE: \"debug\u00a0tag\" uses a special-case \"no break\" space character\n                      \"2018-08-11 21:15:35.754 540-540/? D/debug\u00a0tag: debug message\\n\" +\n                      \"2018-08-11 21:15:35.754 540-540/? I/tag:with:colons: message:with:colons\\n\";\n\n    assertThat(myLogcatListener.toString()).isEqualTo(expected);\n  }", "signature": "void testParseAllLogLevelsAndHexThreadIds()", "full_signature": "@Test public void testParseAllLogLevelsAndHexThreadIds()", "class_method_signature": "AndroidLogcatReceiverTest.testParseAllLogLevelsAndHexThreadIds()", "testcase": true, "constructor": false, "invocations": ["processNewLine", "isEqualTo", "assertThat", "toString"]}, "focal_class": {"identifier": "AndroidLogcatReceiver", "superclass": "extends AndroidOutputReceiver", "interfaces": "implements Disposable", "fields": [{"original_string": "private static final String STACK_TRACE_LINE_PREFIX = StringUtil.repeatSymbol(' ', 4);", "modifier": "private static final", "type": "String", "declarator": "STACK_TRACE_LINE_PREFIX = StringUtil.repeatSymbol(' ', 4)", "var_name": "STACK_TRACE_LINE_PREFIX"}, {"original_string": "private static final String STACK_TRACE_CAUSE_LINE_PREFIX = Character.toString(' ');", "modifier": "private static final", "type": "String", "declarator": "STACK_TRACE_CAUSE_LINE_PREFIX = Character.toString(' ')", "var_name": "STACK_TRACE_CAUSE_LINE_PREFIX"}, {"original_string": "private static final Pattern CARRIAGE_RETURN = Pattern.compile(\"\\r\", Pattern.LITERAL);", "modifier": "private static final", "type": "Pattern", "declarator": "CARRIAGE_RETURN = Pattern.compile(\"\\r\", Pattern.LITERAL)", "var_name": "CARRIAGE_RETURN"}, {"original_string": "private final LogCatMessageParser myLongEpochParser;", "modifier": "private final", "type": "LogCatMessageParser", "declarator": "myLongEpochParser", "var_name": "myLongEpochParser"}, {"original_string": "private final LogCatMessageParser myLongParser;", "modifier": "private final", "type": "LogCatMessageParser", "declarator": "myLongParser", "var_name": "myLongParser"}, {"original_string": "private final IDevice myDevice;", "modifier": "private final", "type": "IDevice", "declarator": "myDevice", "var_name": "myDevice"}, {"original_string": "private final StackTraceExpander myStackTraceExpander;", "modifier": "private final", "type": "StackTraceExpander", "declarator": "myStackTraceExpander", "var_name": "myStackTraceExpander"}, {"original_string": "private final LogcatListener myLogcatListener;", "modifier": "private final", "type": "LogcatListener", "declarator": "myLogcatListener", "var_name": "myLogcatListener"}, {"original_string": "private int myDelayedNewlineCount;", "modifier": "private", "type": "int", "declarator": "myDelayedNewlineCount", "var_name": "myDelayedNewlineCount"}, {"original_string": "@Nullable private LogCatHeader myActiveHeader;", "modifier": "@Nullable private", "type": "LogCatHeader", "declarator": "myActiveHeader", "var_name": "myActiveHeader"}, {"original_string": "private int myLineIndex;", "modifier": "private", "type": "int", "declarator": "myLineIndex", "var_name": "myLineIndex"}, {"original_string": "private volatile boolean myCanceled;", "modifier": "private volatile", "type": "boolean", "declarator": "myCanceled", "var_name": "myCanceled"}], "methods": [{"identifier": "AndroidLogcatReceiver", "parameters": "(@NotNull IDevice device, @NotNull LogcatListener listener)", "modifiers": "", "return": "", "signature": " AndroidLogcatReceiver(@NotNull IDevice device, @NotNull LogcatListener listener)", "full_signature": "  AndroidLogcatReceiver(@NotNull IDevice device, @NotNull LogcatListener listener)", "class_method_signature": "AndroidLogcatReceiver.AndroidLogcatReceiver(@NotNull IDevice device, @NotNull LogcatListener listener)", "testcase": false, "constructor": true}, {"identifier": "processNewLine", "parameters": "(@NotNull String line)", "modifiers": "@Override public", "return": "void", "signature": "void processNewLine(@NotNull String line)", "full_signature": "@Override public void processNewLine(@NotNull String line)", "class_method_signature": "AndroidLogcatReceiver.processNewLine(@NotNull String line)", "testcase": false, "constructor": false}, {"identifier": "notifyLine", "parameters": "(@NotNull LogCatHeader header, @NotNull String line)", "modifiers": "", "return": "void", "signature": "void notifyLine(@NotNull LogCatHeader header, @NotNull String line)", "full_signature": " void notifyLine(@NotNull LogCatHeader header, @NotNull String line)", "class_method_signature": "AndroidLogcatReceiver.notifyLine(@NotNull LogCatHeader header, @NotNull String line)", "testcase": false, "constructor": false}, {"identifier": "processAnyDelayedNewlines", "parameters": "(@NotNull LogCatHeader header)", "modifiers": "private", "return": "void", "signature": "void processAnyDelayedNewlines(@NotNull LogCatHeader header)", "full_signature": "private void processAnyDelayedNewlines(@NotNull LogCatHeader header)", "class_method_signature": "AndroidLogcatReceiver.processAnyDelayedNewlines(@NotNull LogCatHeader header)", "testcase": false, "constructor": false}, {"identifier": "isCancelled", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCancelled()", "full_signature": "@Override public boolean isCancelled()", "class_method_signature": "AndroidLogcatReceiver.isCancelled()", "testcase": false, "constructor": false}, {"identifier": "dispose", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void dispose()", "full_signature": "@Override public void dispose()", "class_method_signature": "AndroidLogcatReceiver.dispose()", "testcase": false, "constructor": false}, {"identifier": "cancel", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void cancel()", "full_signature": "public void cancel()", "class_method_signature": "AndroidLogcatReceiver.cancel()", "testcase": false, "constructor": false}, {"identifier": "getDelayedNewlineCount", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "int", "signature": "int getDelayedNewlineCount()", "full_signature": "@VisibleForTesting int getDelayedNewlineCount()", "class_method_signature": "AndroidLogcatReceiver.getDelayedNewlineCount()", "testcase": false, "constructor": false}], "file": "android/src/com/android/tools/idea/logcat/AndroidLogcatReceiver.java"}, "focal_method": {"identifier": "processNewLine", "parameters": "(@NotNull String line)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void processNewLine(@NotNull String line) {\n    // Really, the user's log should never put any system characters in it ever - that will cause\n    // it to get filtered by our strict regex patterns (see AndroidLogcatFormatter). The reason\n    // this might happen in practice is due to a bug where either adb or logcat (not sure which)\n    // is too aggressive about converting \\n's to \\r\\n's, including those that are quoted. This\n    // means that a user's log, if it uses \\r\\n itself, is converted to \\r\\r\\n. Then, when\n    // MultiLineReceiver, which expects valid input, strips out \\r\\n, it leaves behind an extra \\r.\n    //\n    // Unfortunately this isn't a case where we can fix the root cause because adb and logcat are\n    // both external to Android Studio. In fact, the latest adb/logcat versions have already fixed\n    // this issue! But we still need to run properly with older versions. Also, putting this fix in\n    // MultiLineReceiver isn't right either because it is used for more than just receiving logcat.\n    line = CARRIAGE_RETURN.matcher(line).replaceAll(\"\");\n\n    if (line.isEmpty()) {\n      myDelayedNewlineCount++;\n      return;\n    }\n\n    LogCatHeader header = myLongEpochParser.processLogHeader(line, myDevice);\n\n    if (header == null) {\n      header = myLongParser.processLogHeader(line, myDevice);\n    }\n\n    if (header != null) {\n      myStackTraceExpander.reset();\n      myActiveHeader = header;\n      myLineIndex = 0;\n      // Intentionally drop any trailing newlines once we hit a new header. Usually, logcat\n      // separates log entries with a single newline but sometimes it outputs more than one. As we\n      // can't know which is user newlines vs. system newlines, just drop all of them.\n      myDelayedNewlineCount = 0;\n    }\n    else if (myActiveHeader != null) {\n      if (myDelayedNewlineCount > 0 && myLineIndex == 0) {\n        // Note: Since we trim trailing newlines, we trim leading newlines too. Most users won't\n        // use them intentionally and they don't look great, anyway.\n        myDelayedNewlineCount = 0;\n      }\n      else {\n        processAnyDelayedNewlines(myActiveHeader);\n      }\n      for (String processedLine : myStackTraceExpander.process(line)) {\n        notifyLine(myActiveHeader, processedLine);\n      }\n    }\n  }", "signature": "void processNewLine(@NotNull String line)", "full_signature": "@Override public void processNewLine(@NotNull String line)", "class_method_signature": "AndroidLogcatReceiver.processNewLine(@NotNull String line)", "testcase": false, "constructor": false, "invocations": ["replaceAll", "matcher", "isEmpty", "processLogHeader", "processLogHeader", "reset", "processAnyDelayedNewlines", "process", "notifyLine"]}, "repository": {"repo_id": 60701247, "url": "https://github.com/JetBrains/android", "stars": 486, "created": "6/8/2016 1:46:48 PM +00:00", "updates": "2020-01-27T16:45:40+00:00", "fork": "False", "license": "licensed"}}