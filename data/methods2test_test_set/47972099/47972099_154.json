{"test_class": {"identifier": "LocalFileSystemTest", "superclass": "", "interfaces": "", "fields": [], "file": "flink-core/src/test/java/org/apache/flink/core/fs/local/LocalFileSystemTest.java"}, "test_case": {"identifier": "testLocalFilesystem", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testLocalFilesystem() {\n\n\t\tFile tempdir = new File(CommonTestUtils.getTempDir() + File.separator\n\t\t\t+ CommonTestUtils.getRandomDirectoryName() + File.separator);\n\n\t\t// we must ensure, that this directory does NOT exist yet\n\t\t// probability is extremely low but just to make sure..\n\t\twhile (tempdir.exists()) {\n\t\t\ttempdir = new File(CommonTestUtils.getTempDir() + File.separator + CommonTestUtils.getRandomDirectoryName()\n\t\t\t\t+ File.separator);\n\t\t}\n\n\t\tfinal File testfile1 = new File(tempdir.getAbsolutePath() + File.separator\n\t\t\t+ CommonTestUtils.getRandomFilename());\n\n\t\tfinal File testfile2 = new File(tempdir.getAbsolutePath() + File.separator\n\t\t\t+ CommonTestUtils.getRandomFilename());\n\n\t\tfinal Path pathtotestfile1 = new Path(testfile1.toURI().getPath());\n\t\tfinal Path pathtotestfile2 = new Path(testfile2.toURI().getPath());\n\n\t\ttry {\n\t\t\tfinal LocalFileSystem lfs = new LocalFileSystem();\n\n\t\t\tfinal Path pathtotmpdir = new Path(tempdir.toURI().getPath());\n\n\t\t\t/*\n\t\t\t * check that lfs can see/create/delete/read directories\n\t\t\t */\n\n\t\t\t// check that dir is not existent yet\n\t\t\tassertFalse(lfs.exists(pathtotmpdir));\n\t\t\ttempdir.mkdirs();\n\n\t\t\t// check that local file system recognizes file..\n\t\t\tassertTrue(lfs.exists(pathtotmpdir));\n\t\t\tfinal FileStatus localstatus1 = lfs.getFileStatus(pathtotmpdir);\n\n\t\t\t// check that lfs recognizes directory..\n\t\t\tassertTrue(localstatus1.isDir());\n\n\t\t\t// get status for files in this (empty) directory..\n\t\t\tfinal FileStatus[] statusforfiles = lfs.listStatus(pathtotmpdir);\n\n\t\t\t// no files in there.. hence, must be zero\n\t\t\tassertTrue(statusforfiles.length == 0);\n\n\t\t\t// check that lfs can delete directory..\n\t\t\tlfs.delete(pathtotmpdir, true);\n\n\t\t\t// double check that directory is not existent anymore..\n\t\t\tassertFalse(lfs.exists(pathtotmpdir));\n\t\t\tassertFalse(tempdir.exists());\n\n\t\t\t// re-create directory..\n\t\t\tlfs.mkdirs(pathtotmpdir);\n\n\t\t\t// creation successful?\n\t\t\tassertTrue(tempdir.exists());\n\n\t\t\t/*\n\t\t\t * check that lfs can create/read/write from/to files properly and read meta information..\n\t\t\t */\n\n\t\t\t// create files.. one \"\"natively\"\", one using lfs\n\t\t\tfinal FSDataOutputStream lfsoutput1 = lfs.create(pathtotestfile1, false);\n\t\t\ttestfile2.createNewFile();\n\n\t\t\t// does lfs create files? does lfs recognize created files?\n\t\t\tassertTrue(testfile1.exists());\n\t\t\tassertTrue(lfs.exists(pathtotestfile2));\n\n\t\t\t// test that lfs can write to files properly\n\t\t\tfinal byte[] testbytes = { 1, 2, 3, 4, 5 };\n\t\t\tlfsoutput1.write(testbytes);\n\t\t\tlfsoutput1.close();\n\n\t\t\tassertEquals(testfile1.length(), 5l);\n\n\t\t\tfinal FileInputStream fisfile1 = new FileInputStream(testfile1);\n\t\t\tbyte[] testbytestest = new byte[5];\n\t\t\tfisfile1.read(testbytestest);\n\t\t\tfisfile1.close();\n\n\t\t\t// assertEquals is not able to compare arrays properly...\n\t\t\t// assertEquals(testbytes, testbytestest);\n\t\t\tassertTrue(Arrays.equals(testbytes, testbytestest));\n\n\t\t\t// does lfs see the correct file length?\n\t\t\tassertEquals(lfs.getFileStatus(pathtotestfile1).getLen(), testfile1.length());\n\n\t\t\t// as well, when we call the listStatus (that is intended for directories?)\n\t\t\tassertEquals(lfs.listStatus(pathtotestfile1)[0].getLen(), testfile1.length());\n\n\t\t\t// test that lfs can read files properly\n\t\t\tfinal FileOutputStream fosfile2 = new FileOutputStream(testfile2);\n\t\t\tfosfile2.write(testbytes);\n\t\t\tfosfile2.close();\n\n\t\t\ttestbytestest = new byte[5];\n\t\t\tfinal FSDataInputStream lfsinput2 = lfs.open(pathtotestfile2);\n\t\t\tassertEquals(lfsinput2.read(testbytestest), 5);\n\t\t\tlfsinput2.close();\n\t\t\tassertTrue(Arrays.equals(testbytes, testbytestest));\n\n\t\t\t// does lfs see two files?\n\t\t\tassertEquals(lfs.listStatus(pathtotmpdir).length, 2);\n\n\t\t\t// do we get exactly one blocklocation per file? no matter what start and len we provide\n\t\t\tassertEquals(lfs.getFileBlockLocations(lfs.getFileStatus(pathtotestfile1), 0, 0).length, 1);\n\n\t\t\t/*\n\t\t\t * can lfs delete files / directories?\n\t\t\t */\n\t\t\tassertTrue(lfs.delete(pathtotestfile1, false));\n\n\t\t\t// and can lfs also delete directories recursively?\n\t\t\tassertTrue(lfs.delete(pathtotmpdir, true));\n\n\t\t\tassertTrue(!tempdir.exists());\n\n\t\t} catch (IOException e) {\n\t\t\tfail(e.getMessage());\n\t\t} finally {\n\t\t\t// clean up!\n\t\t\ttestfile1.delete();\n\t\t\ttestfile2.delete();\n\t\t\ttempdir.delete();\n\t\t}\n\t}", "signature": "void testLocalFilesystem()", "full_signature": "@Test public void testLocalFilesystem()", "class_method_signature": "LocalFileSystemTest.testLocalFilesystem()", "testcase": true, "constructor": false, "invocations": ["getTempDir", "getRandomDirectoryName", "exists", "getTempDir", "getRandomDirectoryName", "getAbsolutePath", "getRandomFilename", "getAbsolutePath", "getRandomFilename", "getPath", "toURI", "getPath", "toURI", "getPath", "toURI", "assertFalse", "exists", "mkdirs", "assertTrue", "exists", "getFileStatus", "assertTrue", "isDir", "listStatus", "assertTrue", "delete", "assertFalse", "exists", "assertFalse", "exists", "mkdirs", "assertTrue", "exists", "create", "createNewFile", "assertTrue", "exists", "assertTrue", "exists", "write", "close", "assertEquals", "length", "read", "close", "assertTrue", "equals", "assertEquals", "getLen", "getFileStatus", "length", "assertEquals", "getLen", "listStatus", "length", "write", "close", "open", "assertEquals", "read", "close", "assertTrue", "equals", "assertEquals", "listStatus", "assertEquals", "getFileBlockLocations", "getFileStatus", "assertTrue", "delete", "assertTrue", "delete", "assertTrue", "exists", "fail", "getMessage", "delete", "delete", "delete"]}, "focal_class": {"identifier": "LocalFileSystem", "superclass": "extends FileSystem", "interfaces": "", "fields": [{"original_string": "private Path workingDir = null;", "modifier": "private", "type": "Path", "declarator": "workingDir = null", "var_name": "workingDir"}, {"original_string": "private final URI name = OperatingSystem.isWindows() ? URI.create(\"file:/\") : URI.create(\"file:///\");", "modifier": "private final", "type": "URI", "declarator": "name = OperatingSystem.isWindows() ? URI.create(\"file:/\") : URI.create(\"file:///\")", "var_name": "name"}, {"original_string": "private final String hostName;", "modifier": "private final", "type": "String", "declarator": "hostName", "var_name": "hostName"}, {"original_string": "private static final Logger LOG = LoggerFactory.getLogger(LocalFileSystem.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(LocalFileSystem.class)", "var_name": "LOG"}], "methods": [{"identifier": "LocalFileSystem", "parameters": "()", "modifiers": "public", "return": "", "signature": " LocalFileSystem()", "full_signature": "public  LocalFileSystem()", "class_method_signature": "LocalFileSystem.LocalFileSystem()", "testcase": false, "constructor": true}, {"identifier": "getFileBlockLocations", "parameters": "(final FileStatus file, final long start, final long len)", "modifiers": "@Override public", "return": "BlockLocation[]", "signature": "BlockLocation[] getFileBlockLocations(final FileStatus file, final long start, final long len)", "full_signature": "@Override public BlockLocation[] getFileBlockLocations(final FileStatus file, final long start, final long len)", "class_method_signature": "LocalFileSystem.getFileBlockLocations(final FileStatus file, final long start, final long len)", "testcase": false, "constructor": false}, {"identifier": "getFileStatus", "parameters": "(Path f)", "modifiers": "@Override public", "return": "FileStatus", "signature": "FileStatus getFileStatus(Path f)", "full_signature": "@Override public FileStatus getFileStatus(Path f)", "class_method_signature": "LocalFileSystem.getFileStatus(Path f)", "testcase": false, "constructor": false}, {"identifier": "getUri", "parameters": "()", "modifiers": "@Override public", "return": "URI", "signature": "URI getUri()", "full_signature": "@Override public URI getUri()", "class_method_signature": "LocalFileSystem.getUri()", "testcase": false, "constructor": false}, {"identifier": "getWorkingDirectory", "parameters": "()", "modifiers": "@Override public", "return": "Path", "signature": "Path getWorkingDirectory()", "full_signature": "@Override public Path getWorkingDirectory()", "class_method_signature": "LocalFileSystem.getWorkingDirectory()", "testcase": false, "constructor": false}, {"identifier": "getHomeDirectory", "parameters": "()", "modifiers": "@Override public", "return": "Path", "signature": "Path getHomeDirectory()", "full_signature": "@Override public Path getHomeDirectory()", "class_method_signature": "LocalFileSystem.getHomeDirectory()", "testcase": false, "constructor": false}, {"identifier": "initialize", "parameters": "(final URI name)", "modifiers": "@Override public", "return": "void", "signature": "void initialize(final URI name)", "full_signature": "@Override public void initialize(final URI name)", "class_method_signature": "LocalFileSystem.initialize(final URI name)", "testcase": false, "constructor": false}, {"identifier": "open", "parameters": "(final Path f, final int bufferSize)", "modifiers": "@Override public", "return": "FSDataInputStream", "signature": "FSDataInputStream open(final Path f, final int bufferSize)", "full_signature": "@Override public FSDataInputStream open(final Path f, final int bufferSize)", "class_method_signature": "LocalFileSystem.open(final Path f, final int bufferSize)", "testcase": false, "constructor": false}, {"identifier": "open", "parameters": "(final Path f)", "modifiers": "@Override public", "return": "FSDataInputStream", "signature": "FSDataInputStream open(final Path f)", "full_signature": "@Override public FSDataInputStream open(final Path f)", "class_method_signature": "LocalFileSystem.open(final Path f)", "testcase": false, "constructor": false}, {"identifier": "pathToFile", "parameters": "(Path path)", "modifiers": "private", "return": "File", "signature": "File pathToFile(Path path)", "full_signature": "private File pathToFile(Path path)", "class_method_signature": "LocalFileSystem.pathToFile(Path path)", "testcase": false, "constructor": false}, {"identifier": "listStatus", "parameters": "(final Path f)", "modifiers": "@Override public", "return": "FileStatus[]", "signature": "FileStatus[] listStatus(final Path f)", "full_signature": "@Override public FileStatus[] listStatus(final Path f)", "class_method_signature": "LocalFileSystem.listStatus(final Path f)", "testcase": false, "constructor": false}, {"identifier": "delete", "parameters": "(final Path f, final boolean recursive)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean delete(final Path f, final boolean recursive)", "full_signature": "@Override public boolean delete(final Path f, final boolean recursive)", "class_method_signature": "LocalFileSystem.delete(final Path f, final boolean recursive)", "testcase": false, "constructor": false}, {"identifier": "delete", "parameters": "(final File f)", "modifiers": "private", "return": "boolean", "signature": "boolean delete(final File f)", "full_signature": "private boolean delete(final File f)", "class_method_signature": "LocalFileSystem.delete(final File f)", "testcase": false, "constructor": false}, {"identifier": "mkdirs", "parameters": "(final Path f)", "modifiers": "public", "return": "boolean", "signature": "boolean mkdirs(final Path f)", "full_signature": "public boolean mkdirs(final Path f)", "class_method_signature": "LocalFileSystem.mkdirs(final Path f)", "testcase": false, "constructor": false}, {"identifier": "create", "parameters": "(final Path f, final boolean overwrite, final int bufferSize,\n\t\t\tfinal short replication, final long blockSize)", "modifiers": "@Override public", "return": "FSDataOutputStream", "signature": "FSDataOutputStream create(final Path f, final boolean overwrite, final int bufferSize,\n\t\t\tfinal short replication, final long blockSize)", "full_signature": "@Override public FSDataOutputStream create(final Path f, final boolean overwrite, final int bufferSize,\n\t\t\tfinal short replication, final long blockSize)", "class_method_signature": "LocalFileSystem.create(final Path f, final boolean overwrite, final int bufferSize,\n\t\t\tfinal short replication, final long blockSize)", "testcase": false, "constructor": false}, {"identifier": "create", "parameters": "(final Path f, final boolean overwrite)", "modifiers": "@Override public", "return": "FSDataOutputStream", "signature": "FSDataOutputStream create(final Path f, final boolean overwrite)", "full_signature": "@Override public FSDataOutputStream create(final Path f, final boolean overwrite)", "class_method_signature": "LocalFileSystem.create(final Path f, final boolean overwrite)", "testcase": false, "constructor": false}, {"identifier": "rename", "parameters": "(final Path src, final Path dst)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean rename(final Path src, final Path dst)", "full_signature": "@Override public boolean rename(final Path src, final Path dst)", "class_method_signature": "LocalFileSystem.rename(final Path src, final Path dst)", "testcase": false, "constructor": false}, {"identifier": "isDistributedFS", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isDistributedFS()", "full_signature": "@Override public boolean isDistributedFS()", "class_method_signature": "LocalFileSystem.isDistributedFS()", "testcase": false, "constructor": false}], "file": "flink-core/src/main/java/org/apache/flink/core/fs/local/LocalFileSystem.java"}, "focal_method": {"identifier": "LocalFileSystem", "parameters": "()", "modifiers": "public", "return": "", "body": "public LocalFileSystem() {\n\t\tthis.workingDir = new Path(System.getProperty(\"user.dir\")).makeQualified(this);\n\n\t\tString tmp = \"unknownHost\";\n\n\t\ttry {\n\t\t\ttmp = InetAddress.getLocalHost().getHostName();\n\t\t} catch (UnknownHostException e) {\n\t\t\tLOG.error(\"Could not resolve local host\", e);\n\t\t}\n\n\t\tthis.hostName = tmp;\n\t}", "signature": " LocalFileSystem()", "full_signature": "public  LocalFileSystem()", "class_method_signature": "LocalFileSystem.LocalFileSystem()", "testcase": false, "constructor": true, "invocations": []}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}