{"test_class": {"identifier": "DefaultDeschedulerServiceTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final TitusRuntime titusRuntime = TitusRuntimes.test();", "modifier": "private final", "type": "TitusRuntime", "declarator": "titusRuntime = TitusRuntimes.test()", "var_name": "titusRuntime"}, {"original_string": "private final TestClock clock = (TestClock) titusRuntime.getClock();", "modifier": "private final", "type": "TestClock", "declarator": "clock = (TestClock) titusRuntime.getClock()", "var_name": "clock"}, {"original_string": "private final MutableDataGenerator<AgentInstanceGroup> flexInstanceGroupGenerator = new MutableDataGenerator<>(agentServerGroups(Tier.Flex, 10));", "modifier": "private final", "type": "MutableDataGenerator<AgentInstanceGroup>", "declarator": "flexInstanceGroupGenerator = new MutableDataGenerator<>(agentServerGroups(Tier.Flex, 10))", "var_name": "flexInstanceGroupGenerator"}, {"original_string": "private final MutableDataGenerator<Job<ServiceJobExt>> jobGenerator = new MutableDataGenerator<>(\n            JobGenerator.serviceJobs(oneTaskServiceJobDescriptor().but(\n                    ofServiceSize(4),\n                    withDisruptionBudget(budget(selfManagedPolicy(30_000), unlimitedRate(), Collections.emptyList()))\n            ))\n    );", "modifier": "private final", "type": "MutableDataGenerator<Job<ServiceJobExt>>", "declarator": "jobGenerator = new MutableDataGenerator<>(\n            JobGenerator.serviceJobs(oneTaskServiceJobDescriptor().but(\n                    ofServiceSize(4),\n                    withDisruptionBudget(budget(selfManagedPolicy(30_000), unlimitedRate(), Collections.emptyList()))\n            ))\n    )", "var_name": "jobGenerator"}, {"original_string": "private final RelocationConnectorStubs dataGenerator = new RelocationConnectorStubs()\n            .addInstanceGroup(flexInstanceGroupGenerator.getValue().but(withId(\"active1\"), inState(InstanceGroupLifecycleState.Active)))\n            .addInstanceGroup(flexInstanceGroupGenerator.getValue().but(withId(\"removable1\"), inState(InstanceGroupLifecycleState.Removable)))\n            .addJob(jobGenerator.getValue().but(withJobId(\"job1\")))\n            .addJob(jobGenerator.getValue().but(withJobId(\"job2\")))\n            .addJob(jobGenerator.getValue().but(withJobId(\"jobImmediate\")));", "modifier": "private final", "type": "RelocationConnectorStubs", "declarator": "dataGenerator = new RelocationConnectorStubs()\n            .addInstanceGroup(flexInstanceGroupGenerator.getValue().but(withId(\"active1\"), inState(InstanceGroupLifecycleState.Active)))\n            .addInstanceGroup(flexInstanceGroupGenerator.getValue().but(withId(\"removable1\"), inState(InstanceGroupLifecycleState.Removable)))\n            .addJob(jobGenerator.getValue().but(withJobId(\"job1\")))\n            .addJob(jobGenerator.getValue().but(withJobId(\"job2\")))\n            .addJob(jobGenerator.getValue().but(withJobId(\"jobImmediate\")))", "var_name": "dataGenerator"}, {"original_string": "private final ReadOnlyJobOperations jobOperations = dataGenerator.getJobOperations();", "modifier": "private final", "type": "ReadOnlyJobOperations", "declarator": "jobOperations = dataGenerator.getJobOperations()", "var_name": "jobOperations"}, {"original_string": "private final AgentDataReplicator agentDataReplicator = mock(AgentDataReplicator.class);", "modifier": "private final", "type": "AgentDataReplicator", "declarator": "agentDataReplicator = mock(AgentDataReplicator.class)", "var_name": "agentDataReplicator"}, {"original_string": "private final DefaultDeschedulerService deschedulerService = new DefaultDeschedulerService(\n            dataGenerator.getJobOperations(),\n            dataGenerator.getEvictionOperations(),\n            new AgentManagementNodeDataResolver(dataGenerator.getAgentOperations(), agentDataReplicator, instance -> true,\n                    mock(RelocationConfiguration.class),\n                    TestDataFactory.mockKubeApiFacade()),\n            titusRuntime\n    );", "modifier": "private final", "type": "DefaultDeschedulerService", "declarator": "deschedulerService = new DefaultDeschedulerService(\n            dataGenerator.getJobOperations(),\n            dataGenerator.getEvictionOperations(),\n            new AgentManagementNodeDataResolver(dataGenerator.getAgentOperations(), agentDataReplicator, instance -> true,\n                    mock(RelocationConfiguration.class),\n                    TestDataFactory.mockKubeApiFacade()),\n            titusRuntime\n    )", "var_name": "deschedulerService"}], "file": "titus-supplementary-component/task-relocation/src/test/java/com/netflix/titus/supplementary/relocation/descheduler/DefaultDeschedulerServiceTest.java"}, "test_case": {"identifier": "testAllExpectedJobMigrationsAreFound", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testAllExpectedJobMigrationsAreFound() {\n        List<Task> tasksOfJob1 = jobOperations.getTasks(\"job1\");\n        dataGenerator.place(\"active1\", tasksOfJob1.get(0), tasksOfJob1.get(1));\n        dataGenerator.place(\"removable1\", tasksOfJob1.get(2), tasksOfJob1.get(3));\n        dataGenerator.setQuota(\"job1\", 2);\n\n        List<Task> tasksOfJob2 = jobOperations.getTasks(\"job2\");\n        dataGenerator.place(\"active1\", tasksOfJob2.get(0), tasksOfJob2.get(1));\n        dataGenerator.place(\"removable1\", tasksOfJob2.get(2), tasksOfJob2.get(3));\n        dataGenerator.setQuota(\"job2\", 2);\n\n        dataGenerator.addJobAttribute(\"jobImmediate\", RelocationAttributes.RELOCATION_REQUIRED_BY_IMMEDIATELY, \"\" + (clock.wallTime() + 1));\n        Task taskImmediate = jobOperations.getTasks(\"jobImmediate\").get(0);\n        dataGenerator.place(\"active1\", taskImmediate);\n\n        List<DeschedulingResult> results = deschedulerService.deschedule(Collections.emptyMap());\n        assertThat(results).hasSize(5);\n        for (DeschedulingResult result : results) {\n            boolean isImmediateJobMigration = result.getTask().getId().equals(taskImmediate.getId());\n            if (isImmediateJobMigration) {\n                assertThat(result.getAgentInstance().getServerGroupId()).isEqualTo(\"active1\");\n            } else {\n                assertThat(result.getAgentInstance().getServerGroupId()).isEqualTo(\"removable1\");\n            }\n            TaskRelocationPlan plan = result.getTaskRelocationPlan();\n            assertThat(plan.getReason()).isEqualTo(TaskRelocationReason.TaskMigration);\n            if (isImmediateJobMigration) {\n                assertThat(plan.getReasonMessage()).containsSequence(\"Job marked for immediate eviction\");\n            } else {\n                assertThat(plan.getReasonMessage()).containsSequence(\"Enough quota to migrate the task\");\n            }\n        }\n    }", "signature": "void testAllExpectedJobMigrationsAreFound()", "full_signature": "@Test public void testAllExpectedJobMigrationsAreFound()", "class_method_signature": "DefaultDeschedulerServiceTest.testAllExpectedJobMigrationsAreFound()", "testcase": true, "constructor": false, "invocations": ["getTasks", "place", "get", "get", "place", "get", "get", "setQuota", "getTasks", "place", "get", "get", "place", "get", "get", "setQuota", "addJobAttribute", "wallTime", "get", "getTasks", "place", "deschedule", "emptyMap", "hasSize", "assertThat", "equals", "getId", "getTask", "getId", "isEqualTo", "assertThat", "getServerGroupId", "getAgentInstance", "isEqualTo", "assertThat", "getServerGroupId", "getAgentInstance", "getTaskRelocationPlan", "isEqualTo", "assertThat", "getReason", "containsSequence", "assertThat", "getReasonMessage", "containsSequence", "assertThat", "getReasonMessage"]}, "focal_class": {"identifier": "DefaultDeschedulerService", "superclass": "", "interfaces": "implements DeschedulerService", "fields": [{"original_string": "private final ReadOnlyJobOperations jobOperations;", "modifier": "private final", "type": "ReadOnlyJobOperations", "declarator": "jobOperations", "var_name": "jobOperations"}, {"original_string": "private final ReadOnlyEvictionOperations evictionOperations;", "modifier": "private final", "type": "ReadOnlyEvictionOperations", "declarator": "evictionOperations", "var_name": "evictionOperations"}, {"original_string": "private final NodeDataResolver nodeDataResolver;", "modifier": "private final", "type": "NodeDataResolver", "declarator": "nodeDataResolver", "var_name": "nodeDataResolver"}, {"original_string": "private final TitusRuntime titusRuntime;", "modifier": "private final", "type": "TitusRuntime", "declarator": "titusRuntime", "var_name": "titusRuntime"}, {"original_string": "private final Clock clock;", "modifier": "private final", "type": "Clock", "declarator": "clock", "var_name": "clock"}], "methods": [{"identifier": "DefaultDeschedulerService", "parameters": "(ReadOnlyJobOperations jobOperations,\n                                     ReadOnlyEvictionOperations evictionOperations,\n                                     NodeDataResolver nodeDataResolver,\n                                     TitusRuntime titusRuntime)", "modifiers": "@Inject public", "return": "", "signature": " DefaultDeschedulerService(ReadOnlyJobOperations jobOperations,\n                                     ReadOnlyEvictionOperations evictionOperations,\n                                     NodeDataResolver nodeDataResolver,\n                                     TitusRuntime titusRuntime)", "full_signature": "@Inject public  DefaultDeschedulerService(ReadOnlyJobOperations jobOperations,\n                                     ReadOnlyEvictionOperations evictionOperations,\n                                     NodeDataResolver nodeDataResolver,\n                                     TitusRuntime titusRuntime)", "class_method_signature": "DefaultDeschedulerService.DefaultDeschedulerService(ReadOnlyJobOperations jobOperations,\n                                     ReadOnlyEvictionOperations evictionOperations,\n                                     NodeDataResolver nodeDataResolver,\n                                     TitusRuntime titusRuntime)", "testcase": false, "constructor": true}, {"identifier": "deschedule", "parameters": "(Map<String, TaskRelocationPlan> plannedAheadTaskRelocationPlans)", "modifiers": "@Override public", "return": "List<DeschedulingResult>", "signature": "List<DeschedulingResult> deschedule(Map<String, TaskRelocationPlan> plannedAheadTaskRelocationPlans)", "full_signature": "@Override public List<DeschedulingResult> deschedule(Map<String, TaskRelocationPlan> plannedAheadTaskRelocationPlans)", "class_method_signature": "DefaultDeschedulerService.deschedule(Map<String, TaskRelocationPlan> plannedAheadTaskRelocationPlans)", "testcase": false, "constructor": false}, {"identifier": "newNotDelayedRelocationPlan", "parameters": "(Task task, boolean approved)", "modifiers": "private", "return": "TaskRelocationPlan", "signature": "TaskRelocationPlan newNotDelayedRelocationPlan(Task task, boolean approved)", "full_signature": "private TaskRelocationPlan newNotDelayedRelocationPlan(Task task, boolean approved)", "class_method_signature": "DefaultDeschedulerService.newNotDelayedRelocationPlan(Task task, boolean approved)", "testcase": false, "constructor": false}], "file": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/descheduler/DefaultDeschedulerService.java"}, "focal_method": {"identifier": "deschedule", "parameters": "(Map<String, TaskRelocationPlan> plannedAheadTaskRelocationPlans)", "modifiers": "@Override public", "return": "List<DeschedulingResult>", "body": "@Override\n    public List<DeschedulingResult> deschedule(Map<String, TaskRelocationPlan> plannedAheadTaskRelocationPlans) {\n        List<Pair<Job, List<Task>>> allJobsAndTasks = jobOperations.getJobsAndTasks();\n        Map<String, Job<?>> jobs = allJobsAndTasks.stream().map(Pair::getLeft).collect(Collectors.toMap(Job::getId, j -> j));\n        Map<String, Task> tasksById = allJobsAndTasks.stream()\n                .flatMap(p -> p.getRight().stream())\n                .collect(Collectors.toMap(Task::getId, t -> t));\n\n        EvacuatedAgentsAllocationTracker evacuatedAgentsAllocationTracker = new EvacuatedAgentsAllocationTracker(nodeDataResolver.resolve(), tasksById);\n        EvictionQuotaTracker evictionQuotaTracker = new EvictionQuotaTracker(evictionOperations, jobs);\n\n        TaskMigrationDescheduler taskMigrationDescheduler = new TaskMigrationDescheduler(\n                plannedAheadTaskRelocationPlans, evacuatedAgentsAllocationTracker, evictionQuotaTracker, jobs, tasksById, titusRuntime\n        );\n\n        Map<String, DeschedulingResult> requestedImmediateEvictions = taskMigrationDescheduler.findAllImmediateEvictions();\n        Map<String, DeschedulingResult> requestedEvictions = taskMigrationDescheduler.findRequestedJobOrTaskMigrations();\n        Map<String, DeschedulingResult> allRequestedEvictions = CollectionsExt.merge(requestedImmediateEvictions, requestedEvictions);\n\n        Map<String, DeschedulingResult> regularEvictions = new HashMap<>();\n        Optional<Pair<Node, List<Task>>> bestMatch;\n        while ((bestMatch = taskMigrationDescheduler.nextBestMatch()).isPresent()) {\n            Node agent = bestMatch.get().getLeft();\n            List<Task> tasks = bestMatch.get().getRight();\n            tasks.forEach(task -> {\n                if (!allRequestedEvictions.containsKey(task.getId())) {\n                    TaskRelocationPlan relocationPlan = plannedAheadTaskRelocationPlans.get(task.getId());\n                    if (relocationPlan == null) {\n                        relocationPlan = newNotDelayedRelocationPlan(task, true);\n                    }\n                    regularEvictions.put(\n                            task.getId(),\n                            DeschedulingResult.newBuilder()\n                                    .withTask(task)\n                                    .withAgentInstance(agent)\n                                    .withTaskRelocationPlan(relocationPlan)\n                                    .build()\n                    );\n                }\n            });\n        }\n\n        // Find eviction which could not be scheduled now.\n        for (Task task : tasksById.values()) {\n            if (allRequestedEvictions.containsKey(task.getId()) || regularEvictions.containsKey(task.getId())) {\n                continue;\n            }\n            if (evacuatedAgentsAllocationTracker.isEvacuated(task)) {\n\n                DeschedulingFailure failure = taskMigrationDescheduler.getDeschedulingFailure(task);\n                TaskRelocationPlan relocationPlan = plannedAheadTaskRelocationPlans.get(task.getId());\n\n                if (relocationPlan == null) {\n                    relocationPlan = newNotDelayedRelocationPlan(task, false);\n                }\n\n                Node agent = evacuatedAgentsAllocationTracker.getRemovableAgent(task);\n                regularEvictions.put(\n                        task.getId(),\n                        DeschedulingResult.newBuilder()\n                                .withTask(task)\n                                .withAgentInstance(agent)\n                                .withTaskRelocationPlan(relocationPlan)\n                                .withFailure(failure)\n                                .build()\n                );\n            }\n        }\n\n        return CollectionsExt.merge(new ArrayList<>(allRequestedEvictions.values()), new ArrayList<>(regularEvictions.values()));\n    }", "signature": "List<DeschedulingResult> deschedule(Map<String, TaskRelocationPlan> plannedAheadTaskRelocationPlans)", "full_signature": "@Override public List<DeschedulingResult> deschedule(Map<String, TaskRelocationPlan> plannedAheadTaskRelocationPlans)", "class_method_signature": "DefaultDeschedulerService.deschedule(Map<String, TaskRelocationPlan> plannedAheadTaskRelocationPlans)", "testcase": false, "constructor": false, "invocations": ["getJobsAndTasks", "collect", "map", "stream", "toMap", "collect", "flatMap", "stream", "stream", "getRight", "toMap", "resolve", "findAllImmediateEvictions", "findRequestedJobOrTaskMigrations", "merge", "isPresent", "nextBestMatch", "getLeft", "get", "getRight", "get", "forEach", "containsKey", "getId", "get", "getId", "newNotDelayedRelocationPlan", "put", "getId", "build", "withTaskRelocationPlan", "withAgentInstance", "withTask", "newBuilder", "values", "containsKey", "getId", "containsKey", "getId", "isEvacuated", "getDeschedulingFailure", "get", "getId", "newNotDelayedRelocationPlan", "getRemovableAgent", "put", "getId", "build", "withFailure", "withTaskRelocationPlan", "withAgentInstance", "withTask", "newBuilder", "merge", "values", "values"]}, "repository": {"repo_id": 107330274, "url": "https://github.com/Netflix/titus-control-plane", "stars": 241, "created": "10/17/2017 10:20:55 PM +00:00", "updates": "2020-01-25T13:01:05+00:00", "fork": "False", "license": "licensed"}}