{"test_class": {"identifier": "InternalOakMapTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private InternalOakMap<Integer, Integer> testMap;", "modifier": "private", "type": "InternalOakMap<Integer, Integer>", "declarator": "testMap", "var_name": "testMap"}, {"original_string": "private static final long OPERATION_DELAY = 100;", "modifier": "private static final", "type": "long", "declarator": "OPERATION_DELAY = 100", "var_name": "OPERATION_DELAY"}, {"original_string": "private static final long LONG_TRANSFORMATION_DELAY = 1000;", "modifier": "private static final", "type": "long", "declarator": "LONG_TRANSFORMATION_DELAY = 1000", "var_name": "LONG_TRANSFORMATION_DELAY"}], "file": "core/src/test/java/com/yahoo/oak/InternalOakMapTest.java"}, "test_case": {"identifier": "concurrentPuts", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void concurrentPuts() throws InterruptedException {\n        Integer k = 1;\n        Integer v1 = 1;\n        Integer v2 = 2;\n        Integer v3 = 3;\n\n        final Integer[] results = new Integer[3];\n\n        List<Thread> threadList = new ArrayList<>(results.length);\n        threadList.add(new Thread(() -> results[0] = testMap.put(k, v1,\n                OakCommonBuildersFactory.DEFAULT_INT_SERIALIZER::deserialize)));\n        threadList.add(new Thread(() -> results[1] = testMap.put(k, v2, InternalOakMapTest::slowDeserialize)));\n        threadList.add(new Thread(() -> results[2] = testMap.put(k, v3,\n                OakCommonBuildersFactory.DEFAULT_INT_SERIALIZER::deserialize)));\n\n        runThreads(threadList);\n\n        Assert.assertNull(results[0]);\n        Assert.assertNotEquals(results[1], results[2]);\n    }", "signature": "void concurrentPuts()", "full_signature": "@Test public void concurrentPuts()", "class_method_signature": "InternalOakMapTest.concurrentPuts()", "testcase": true, "constructor": false, "invocations": ["add", "put", "add", "put", "add", "put", "runThreads", "assertNull", "assertNotEquals"]}, "focal_class": {"identifier": "InternalOakMap", "superclass": "", "interfaces": "", "fields": [{"original_string": "final ConcurrentSkipListMap<Object, Chunk<K, V>> skiplist;", "modifier": "final", "type": "ConcurrentSkipListMap<Object, Chunk<K, V>>", "declarator": "skiplist", "var_name": "skiplist"}, {"original_string": "private final AtomicReference<Chunk<K, V>> head;", "modifier": "private final", "type": "AtomicReference<Chunk<K, V>>", "declarator": "head", "var_name": "head"}, {"original_string": "private final OakComparator<K> comparator;", "modifier": "private final", "type": "OakComparator<K>", "declarator": "comparator", "var_name": "comparator"}, {"original_string": "private final MemoryManager valuesMemoryManager;", "modifier": "private final", "type": "MemoryManager", "declarator": "valuesMemoryManager", "var_name": "valuesMemoryManager"}, {"original_string": "private final MemoryManager keysMemoryManager;", "modifier": "private final", "type": "MemoryManager", "declarator": "keysMemoryManager", "var_name": "keysMemoryManager"}, {"original_string": "private final AtomicInteger size;", "modifier": "private final", "type": "AtomicInteger", "declarator": "size", "var_name": "size"}, {"original_string": "private final OakSerializer<K> keySerializer;", "modifier": "private final", "type": "OakSerializer<K>", "declarator": "keySerializer", "var_name": "keySerializer"}, {"original_string": "private final OakSerializer<V> valueSerializer;", "modifier": "private final", "type": "OakSerializer<V>", "declarator": "valueSerializer", "var_name": "valueSerializer"}, {"original_string": "private final AtomicInteger referenceCount = new AtomicInteger(1);", "modifier": "private final", "type": "AtomicInteger", "declarator": "referenceCount = new AtomicInteger(1)", "var_name": "referenceCount"}, {"original_string": "private final ValueUtils valueOperator;", "modifier": "private final", "type": "ValueUtils", "declarator": "valueOperator", "var_name": "valueOperator"}, {"original_string": "static final int MAX_RETRIES = 1024;", "modifier": "static final", "type": "int", "declarator": "MAX_RETRIES = 1024", "var_name": "MAX_RETRIES"}], "methods": [{"identifier": "InternalOakMap", "parameters": "(K minKey, OakSerializer<K> keySerializer, OakSerializer<V> valueSerializer,\n        OakComparator<K> oakComparator, MemoryManager vMM, MemoryManager kMM, int chunkMaxItems,\n        ValueUtils valueOperator)", "modifiers": "", "return": "", "signature": " InternalOakMap(K minKey, OakSerializer<K> keySerializer, OakSerializer<V> valueSerializer,\n        OakComparator<K> oakComparator, MemoryManager vMM, MemoryManager kMM, int chunkMaxItems,\n        ValueUtils valueOperator)", "full_signature": "  InternalOakMap(K minKey, OakSerializer<K> keySerializer, OakSerializer<V> valueSerializer,\n        OakComparator<K> oakComparator, MemoryManager vMM, MemoryManager kMM, int chunkMaxItems,\n        ValueUtils valueOperator)", "class_method_signature": "InternalOakMap.InternalOakMap(K minKey, OakSerializer<K> keySerializer, OakSerializer<V> valueSerializer,\n        OakComparator<K> oakComparator, MemoryManager vMM, MemoryManager kMM, int chunkMaxItems,\n        ValueUtils valueOperator)", "testcase": false, "constructor": true}, {"identifier": "close", "parameters": "()", "modifiers": "", "return": "void", "signature": "void close()", "full_signature": " void close()", "class_method_signature": "InternalOakMap.close()", "testcase": false, "constructor": false}, {"identifier": "open", "parameters": "()", "modifiers": "", "return": "void", "signature": "void open()", "full_signature": " void open()", "class_method_signature": "InternalOakMap.open()", "testcase": false, "constructor": false}, {"identifier": "memorySize", "parameters": "()", "modifiers": "", "return": "long", "signature": "long memorySize()", "full_signature": " long memorySize()", "class_method_signature": "InternalOakMap.memorySize()", "testcase": false, "constructor": false}, {"identifier": "entries", "parameters": "()", "modifiers": "", "return": "int", "signature": "int entries()", "full_signature": " int entries()", "class_method_signature": "InternalOakMap.entries()", "testcase": false, "constructor": false}, {"identifier": "getThreadContext", "parameters": "()", "modifiers": "", "return": "ThreadContext", "signature": "ThreadContext getThreadContext()", "full_signature": " ThreadContext getThreadContext()", "class_method_signature": "InternalOakMap.getThreadContext()", "testcase": false, "constructor": false}, {"identifier": "iterateChunks", "parameters": "(final Chunk<K, V> inputChunk, K key)", "modifiers": "private", "return": "Chunk<K, V>", "signature": "Chunk<K, V> iterateChunks(final Chunk<K, V> inputChunk, K key)", "full_signature": "private Chunk<K, V> iterateChunks(final Chunk<K, V> inputChunk, K key)", "class_method_signature": "InternalOakMap.iterateChunks(final Chunk<K, V> inputChunk, K key)", "testcase": false, "constructor": false}, {"identifier": "overwriteExistingValueForMove", "parameters": "(ThreadContext ctx, V newVal, Chunk<K, V> c)", "modifiers": "", "return": "boolean", "signature": "boolean overwriteExistingValueForMove(ThreadContext ctx, V newVal, Chunk<K, V> c)", "full_signature": " boolean overwriteExistingValueForMove(ThreadContext ctx, V newVal, Chunk<K, V> c)", "class_method_signature": "InternalOakMap.overwriteExistingValueForMove(ThreadContext ctx, V newVal, Chunk<K, V> c)", "testcase": false, "constructor": false}, {"identifier": "rebalance", "parameters": "(Chunk<K, V> c)", "modifiers": "private", "return": "void", "signature": "void rebalance(Chunk<K, V> c)", "full_signature": "private void rebalance(Chunk<K, V> c)", "class_method_signature": "InternalOakMap.rebalance(Chunk<K, V> c)", "testcase": false, "constructor": false}, {"identifier": "checkRebalance", "parameters": "(Chunk<K, V> c)", "modifiers": "private", "return": "void", "signature": "void checkRebalance(Chunk<K, V> c)", "full_signature": "private void checkRebalance(Chunk<K, V> c)", "class_method_signature": "InternalOakMap.checkRebalance(Chunk<K, V> c)", "testcase": false, "constructor": false}, {"identifier": "connectToChunkList", "parameters": "(List<Chunk<K, V>> engaged, List<Chunk<K, V>> children)", "modifiers": "private", "return": "void", "signature": "void connectToChunkList(List<Chunk<K, V>> engaged, List<Chunk<K, V>> children)", "full_signature": "private void connectToChunkList(List<Chunk<K, V>> engaged, List<Chunk<K, V>> children)", "class_method_signature": "InternalOakMap.connectToChunkList(List<Chunk<K, V>> engaged, List<Chunk<K, V>> children)", "testcase": false, "constructor": false}, {"identifier": "updateLastChild", "parameters": "(List<Chunk<K, V>> engaged, List<Chunk<K, V>> children)", "modifiers": "private", "return": "void", "signature": "void updateLastChild(List<Chunk<K, V>> engaged, List<Chunk<K, V>> children)", "full_signature": "private void updateLastChild(List<Chunk<K, V>> engaged, List<Chunk<K, V>> children)", "class_method_signature": "InternalOakMap.updateLastChild(List<Chunk<K, V>> engaged, List<Chunk<K, V>> children)", "testcase": false, "constructor": false}, {"identifier": "updateIndexAndNormalize", "parameters": "(List<Chunk<K, V>> engagedChunks, List<Chunk<K, V>> children)", "modifiers": "private", "return": "void", "signature": "void updateIndexAndNormalize(List<Chunk<K, V>> engagedChunks, List<Chunk<K, V>> children)", "full_signature": "private void updateIndexAndNormalize(List<Chunk<K, V>> engagedChunks, List<Chunk<K, V>> children)", "class_method_signature": "InternalOakMap.updateIndexAndNormalize(List<Chunk<K, V>> engagedChunks, List<Chunk<K, V>> children)", "testcase": false, "constructor": false}, {"identifier": "inTheMiddleOfRebalance", "parameters": "(Chunk<K, V> c)", "modifiers": "private", "return": "boolean", "signature": "boolean inTheMiddleOfRebalance(Chunk<K, V> c)", "full_signature": "private boolean inTheMiddleOfRebalance(Chunk<K, V> c)", "class_method_signature": "InternalOakMap.inTheMiddleOfRebalance(Chunk<K, V> c)", "testcase": false, "constructor": false}, {"identifier": "finalizeDeletion", "parameters": "(Chunk<K, V> c, ThreadContext ctx)", "modifiers": "private", "return": "boolean", "signature": "boolean finalizeDeletion(Chunk<K, V> c, ThreadContext ctx)", "full_signature": "private boolean finalizeDeletion(Chunk<K, V> c, ThreadContext ctx)", "class_method_signature": "InternalOakMap.finalizeDeletion(Chunk<K, V> c, ThreadContext ctx)", "testcase": false, "constructor": false}, {"identifier": "isAfterRebalanceOrValueUpdate", "parameters": "(Chunk c, ThreadContext ctx)", "modifiers": "private", "return": "boolean", "signature": "boolean isAfterRebalanceOrValueUpdate(Chunk c, ThreadContext ctx)", "full_signature": "private boolean isAfterRebalanceOrValueUpdate(Chunk c, ThreadContext ctx)", "class_method_signature": "InternalOakMap.isAfterRebalanceOrValueUpdate(Chunk c, ThreadContext ctx)", "testcase": false, "constructor": false}, {"identifier": "allocateAndLinkEntry", "parameters": "(Chunk c, ThreadContext ctx, K key, boolean isPutIfAbsent)", "modifiers": "private", "return": "boolean", "signature": "boolean allocateAndLinkEntry(Chunk c, ThreadContext ctx, K key, boolean isPutIfAbsent)", "full_signature": "private boolean allocateAndLinkEntry(Chunk c, ThreadContext ctx, K key, boolean isPutIfAbsent)", "class_method_signature": "InternalOakMap.allocateAndLinkEntry(Chunk c, ThreadContext ctx, K key, boolean isPutIfAbsent)", "testcase": false, "constructor": false}, {"identifier": "put", "parameters": "(K key, V value, OakTransformer<V> transformer)", "modifiers": "", "return": "V", "signature": "V put(K key, V value, OakTransformer<V> transformer)", "full_signature": " V put(K key, V value, OakTransformer<V> transformer)", "class_method_signature": "InternalOakMap.put(K key, V value, OakTransformer<V> transformer)", "testcase": false, "constructor": false}, {"identifier": "putIfAbsent", "parameters": "(K key, V value, OakTransformer<V> transformer)", "modifiers": "", "return": "Result", "signature": "Result putIfAbsent(K key, V value, OakTransformer<V> transformer)", "full_signature": " Result putIfAbsent(K key, V value, OakTransformer<V> transformer)", "class_method_signature": "InternalOakMap.putIfAbsent(K key, V value, OakTransformer<V> transformer)", "testcase": false, "constructor": false}, {"identifier": "putIfAbsentComputeIfPresent", "parameters": "(K key, V value, Consumer<OakScopedWriteBuffer> computer)", "modifiers": "", "return": "boolean", "signature": "boolean putIfAbsentComputeIfPresent(K key, V value, Consumer<OakScopedWriteBuffer> computer)", "full_signature": " boolean putIfAbsentComputeIfPresent(K key, V value, Consumer<OakScopedWriteBuffer> computer)", "class_method_signature": "InternalOakMap.putIfAbsentComputeIfPresent(K key, V value, Consumer<OakScopedWriteBuffer> computer)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(K key, V oldValue, OakTransformer<V> transformer)", "modifiers": "", "return": "Result", "signature": "Result remove(K key, V oldValue, OakTransformer<V> transformer)", "full_signature": " Result remove(K key, V oldValue, OakTransformer<V> transformer)", "class_method_signature": "InternalOakMap.remove(K key, V oldValue, OakTransformer<V> transformer)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(K key)", "modifiers": "", "return": "OakUnscopedBuffer", "signature": "OakUnscopedBuffer get(K key)", "full_signature": " OakUnscopedBuffer get(K key)", "class_method_signature": "InternalOakMap.get(K key)", "testcase": false, "constructor": false}, {"identifier": "computeIfPresent", "parameters": "(K key, Consumer<OakScopedWriteBuffer> computer)", "modifiers": "", "return": "boolean", "signature": "boolean computeIfPresent(K key, Consumer<OakScopedWriteBuffer> computer)", "full_signature": " boolean computeIfPresent(K key, Consumer<OakScopedWriteBuffer> computer)", "class_method_signature": "InternalOakMap.computeIfPresent(K key, Consumer<OakScopedWriteBuffer> computer)", "testcase": false, "constructor": false}, {"identifier": "refreshValuePosition", "parameters": "(ThreadContext ctx)", "modifiers": "", "return": "boolean", "signature": "boolean refreshValuePosition(ThreadContext ctx)", "full_signature": " boolean refreshValuePosition(ThreadContext ctx)", "class_method_signature": "InternalOakMap.refreshValuePosition(ThreadContext ctx)", "testcase": false, "constructor": false}, {"identifier": "refreshValuePosition", "parameters": "(Slice keySlice, Slice valueSlice)", "modifiers": "", "return": "boolean", "signature": "boolean refreshValuePosition(Slice keySlice, Slice valueSlice)", "full_signature": " boolean refreshValuePosition(Slice keySlice, Slice valueSlice)", "class_method_signature": "InternalOakMap.refreshValuePosition(Slice keySlice, Slice valueSlice)", "testcase": false, "constructor": false}, {"identifier": "getValueTransformation", "parameters": "(OakScopedReadBuffer key, OakTransformer<T> transformer)", "modifiers": "private", "return": "T", "signature": "T getValueTransformation(OakScopedReadBuffer key, OakTransformer<T> transformer)", "full_signature": "private T getValueTransformation(OakScopedReadBuffer key, OakTransformer<T> transformer)", "class_method_signature": "InternalOakMap.getValueTransformation(OakScopedReadBuffer key, OakTransformer<T> transformer)", "testcase": false, "constructor": false}, {"identifier": "getValueTransformation", "parameters": "(K key, OakTransformer<T> transformer)", "modifiers": "", "return": "T", "signature": "T getValueTransformation(K key, OakTransformer<T> transformer)", "full_signature": " T getValueTransformation(K key, OakTransformer<T> transformer)", "class_method_signature": "InternalOakMap.getValueTransformation(K key, OakTransformer<T> transformer)", "testcase": false, "constructor": false}, {"identifier": "getKeyTransformation", "parameters": "(K key, OakTransformer<T> transformer)", "modifiers": "", "return": "T", "signature": "T getKeyTransformation(K key, OakTransformer<T> transformer)", "full_signature": " T getKeyTransformation(K key, OakTransformer<T> transformer)", "class_method_signature": "InternalOakMap.getKeyTransformation(K key, OakTransformer<T> transformer)", "testcase": false, "constructor": false}, {"identifier": "getMinKey", "parameters": "()", "modifiers": "", "return": "OakUnscopedBuffer", "signature": "OakUnscopedBuffer getMinKey()", "full_signature": " OakUnscopedBuffer getMinKey()", "class_method_signature": "InternalOakMap.getMinKey()", "testcase": false, "constructor": false}, {"identifier": "getMinKeyTransformation", "parameters": "(OakTransformer<T> transformer)", "modifiers": "", "return": "T", "signature": "T getMinKeyTransformation(OakTransformer<T> transformer)", "full_signature": " T getMinKeyTransformation(OakTransformer<T> transformer)", "class_method_signature": "InternalOakMap.getMinKeyTransformation(OakTransformer<T> transformer)", "testcase": false, "constructor": false}, {"identifier": "getMaxKey", "parameters": "()", "modifiers": "", "return": "OakUnscopedBuffer", "signature": "OakUnscopedBuffer getMaxKey()", "full_signature": " OakUnscopedBuffer getMaxKey()", "class_method_signature": "InternalOakMap.getMaxKey()", "testcase": false, "constructor": false}, {"identifier": "getMaxKeyTransformation", "parameters": "(OakTransformer<T> transformer)", "modifiers": "", "return": "T", "signature": "T getMaxKeyTransformation(OakTransformer<T> transformer)", "full_signature": " T getMaxKeyTransformation(OakTransformer<T> transformer)", "class_method_signature": "InternalOakMap.getMaxKeyTransformation(OakTransformer<T> transformer)", "testcase": false, "constructor": false}, {"identifier": "findChunk", "parameters": "(K key)", "modifiers": "private", "return": "Chunk<K, V>", "signature": "Chunk<K, V> findChunk(K key)", "full_signature": "private Chunk<K, V> findChunk(K key)", "class_method_signature": "InternalOakMap.findChunk(K key)", "testcase": false, "constructor": false}, {"identifier": "replace", "parameters": "(K key, V value, OakTransformer<V> valueDeserializeTransformer)", "modifiers": "", "return": "V", "signature": "V replace(K key, V value, OakTransformer<V> valueDeserializeTransformer)", "full_signature": " V replace(K key, V value, OakTransformer<V> valueDeserializeTransformer)", "class_method_signature": "InternalOakMap.replace(K key, V value, OakTransformer<V> valueDeserializeTransformer)", "testcase": false, "constructor": false}, {"identifier": "replace", "parameters": "(K key, V oldValue, V newValue, OakTransformer<V> valueDeserializeTransformer)", "modifiers": "", "return": "boolean", "signature": "boolean replace(K key, V oldValue, V newValue, OakTransformer<V> valueDeserializeTransformer)", "full_signature": " boolean replace(K key, V oldValue, V newValue, OakTransformer<V> valueDeserializeTransformer)", "class_method_signature": "InternalOakMap.replace(K key, V oldValue, V newValue, OakTransformer<V> valueDeserializeTransformer)", "testcase": false, "constructor": false}, {"identifier": "lowerEntry", "parameters": "(K key)", "modifiers": "", "return": "Map.Entry<K, V>", "signature": "Map.Entry<K, V> lowerEntry(K key)", "full_signature": " Map.Entry<K, V> lowerEntry(K key)", "class_method_signature": "InternalOakMap.lowerEntry(K key)", "testcase": false, "constructor": false}, {"identifier": "getKeyUnscopedBuffer", "parameters": "(ThreadContext ctx)", "modifiers": "private", "return": "UnscopedBuffer", "signature": "UnscopedBuffer getKeyUnscopedBuffer(ThreadContext ctx)", "full_signature": "private UnscopedBuffer getKeyUnscopedBuffer(ThreadContext ctx)", "class_method_signature": "InternalOakMap.getKeyUnscopedBuffer(ThreadContext ctx)", "testcase": false, "constructor": false}, {"identifier": "getValueUnscopedBuffer", "parameters": "(ThreadContext ctx)", "modifiers": "private", "return": "UnscopedValueBufferSynced", "signature": "UnscopedValueBufferSynced getValueUnscopedBuffer(ThreadContext ctx)", "full_signature": "private UnscopedValueBufferSynced getValueUnscopedBuffer(ThreadContext ctx)", "class_method_signature": "InternalOakMap.getValueUnscopedBuffer(ThreadContext ctx)", "testcase": false, "constructor": false}, {"identifier": "validateBoundariesOrder", "parameters": "(K fromKey, K toKey)", "modifiers": "", "return": "void", "signature": "void validateBoundariesOrder(K fromKey, K toKey)", "full_signature": " void validateBoundariesOrder(K fromKey, K toKey)", "class_method_signature": "InternalOakMap.validateBoundariesOrder(K fromKey, K toKey)", "testcase": false, "constructor": false}, {"identifier": "valuesBufferViewIterator", "parameters": "(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                         boolean isDescending)", "modifiers": "", "return": "Iterator<OakUnscopedBuffer>", "signature": "Iterator<OakUnscopedBuffer> valuesBufferViewIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                         boolean isDescending)", "full_signature": " Iterator<OakUnscopedBuffer> valuesBufferViewIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                         boolean isDescending)", "class_method_signature": "InternalOakMap.valuesBufferViewIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                         boolean isDescending)", "testcase": false, "constructor": false}, {"identifier": "entriesBufferViewIterator", "parameters": "(K lo, boolean loInclusive,\n                                                                                        K hi, boolean hiInclusive,\n                                                                                        boolean isDescending)", "modifiers": "", "return": "Iterator<Map.Entry<OakUnscopedBuffer, OakUnscopedBuffer>>", "signature": "Iterator<Map.Entry<OakUnscopedBuffer, OakUnscopedBuffer>> entriesBufferViewIterator(K lo, boolean loInclusive,\n                                                                                        K hi, boolean hiInclusive,\n                                                                                        boolean isDescending)", "full_signature": " Iterator<Map.Entry<OakUnscopedBuffer, OakUnscopedBuffer>> entriesBufferViewIterator(K lo, boolean loInclusive,\n                                                                                        K hi, boolean hiInclusive,\n                                                                                        boolean isDescending)", "class_method_signature": "InternalOakMap.entriesBufferViewIterator(K lo, boolean loInclusive,\n                                                                                        K hi, boolean hiInclusive,\n                                                                                        boolean isDescending)", "testcase": false, "constructor": false}, {"identifier": "keysBufferViewIterator", "parameters": "(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                       boolean isDescending)", "modifiers": "", "return": "Iterator<OakUnscopedBuffer>", "signature": "Iterator<OakUnscopedBuffer> keysBufferViewIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                       boolean isDescending)", "full_signature": " Iterator<OakUnscopedBuffer> keysBufferViewIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                       boolean isDescending)", "class_method_signature": "InternalOakMap.keysBufferViewIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                       boolean isDescending)", "testcase": false, "constructor": false}, {"identifier": "valuesStreamIterator", "parameters": "(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                     boolean isDescending)", "modifiers": "", "return": "Iterator<OakUnscopedBuffer>", "signature": "Iterator<OakUnscopedBuffer> valuesStreamIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                     boolean isDescending)", "full_signature": " Iterator<OakUnscopedBuffer> valuesStreamIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                     boolean isDescending)", "class_method_signature": "InternalOakMap.valuesStreamIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                     boolean isDescending)", "testcase": false, "constructor": false}, {"identifier": "entriesStreamIterator", "parameters": "(K lo, boolean loInclusive,\n                                                                                    K hi, boolean hiInclusive,\n                                                                                    boolean isDescending)", "modifiers": "", "return": "Iterator<Map.Entry<OakUnscopedBuffer, OakUnscopedBuffer>>", "signature": "Iterator<Map.Entry<OakUnscopedBuffer, OakUnscopedBuffer>> entriesStreamIterator(K lo, boolean loInclusive,\n                                                                                    K hi, boolean hiInclusive,\n                                                                                    boolean isDescending)", "full_signature": " Iterator<Map.Entry<OakUnscopedBuffer, OakUnscopedBuffer>> entriesStreamIterator(K lo, boolean loInclusive,\n                                                                                    K hi, boolean hiInclusive,\n                                                                                    boolean isDescending)", "class_method_signature": "InternalOakMap.entriesStreamIterator(K lo, boolean loInclusive,\n                                                                                    K hi, boolean hiInclusive,\n                                                                                    boolean isDescending)", "testcase": false, "constructor": false}, {"identifier": "keysStreamIterator", "parameters": "(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                   boolean isDescending)", "modifiers": "", "return": "Iterator<OakUnscopedBuffer>", "signature": "Iterator<OakUnscopedBuffer> keysStreamIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                   boolean isDescending)", "full_signature": " Iterator<OakUnscopedBuffer> keysStreamIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                   boolean isDescending)", "class_method_signature": "InternalOakMap.keysStreamIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                                   boolean isDescending)", "testcase": false, "constructor": false}, {"identifier": "valuesTransformIterator", "parameters": "(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                            boolean isDescending, OakTransformer<T> transformer)", "modifiers": "", "return": "Iterator<T>", "signature": "Iterator<T> valuesTransformIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                            boolean isDescending, OakTransformer<T> transformer)", "full_signature": " Iterator<T> valuesTransformIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                            boolean isDescending, OakTransformer<T> transformer)", "class_method_signature": "InternalOakMap.valuesTransformIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                            boolean isDescending, OakTransformer<T> transformer)", "testcase": false, "constructor": false}, {"identifier": "entriesTransformIterator", "parameters": "(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                             boolean isDescending,\n                                             Function<Map.Entry<OakScopedReadBuffer, OakScopedReadBuffer>,\n                                                     T> transformer)", "modifiers": "", "return": "Iterator<T>", "signature": "Iterator<T> entriesTransformIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                             boolean isDescending,\n                                             Function<Map.Entry<OakScopedReadBuffer, OakScopedReadBuffer>,\n                                                     T> transformer)", "full_signature": " Iterator<T> entriesTransformIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                             boolean isDescending,\n                                             Function<Map.Entry<OakScopedReadBuffer, OakScopedReadBuffer>,\n                                                     T> transformer)", "class_method_signature": "InternalOakMap.entriesTransformIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive,\n                                             boolean isDescending,\n                                             Function<Map.Entry<OakScopedReadBuffer, OakScopedReadBuffer>,\n                                                     T> transformer)", "testcase": false, "constructor": false}, {"identifier": "keysTransformIterator", "parameters": "(K lo, boolean loInclusive, K hi, boolean hiInclusive, boolean isDescending,\n                                          OakTransformer<T> transformer)", "modifiers": "", "return": "Iterator<T>", "signature": "Iterator<T> keysTransformIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive, boolean isDescending,\n                                          OakTransformer<T> transformer)", "full_signature": " Iterator<T> keysTransformIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive, boolean isDescending,\n                                          OakTransformer<T> transformer)", "class_method_signature": "InternalOakMap.keysTransformIterator(K lo, boolean loInclusive, K hi, boolean hiInclusive, boolean isDescending,\n                                          OakTransformer<T> transformer)", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/yahoo/oak/InternalOakMap.java"}, "focal_method": {"identifier": "put", "parameters": "(K key, V value, OakTransformer<V> transformer)", "modifiers": "", "return": "V", "body": "V put(K key, V value, OakTransformer<V> transformer) {\n        if (key == null || value == null) {\n            throw new NullPointerException();\n        }\n\n        ThreadContext ctx = getThreadContext();\n\n        for (int i = 0; i < MAX_RETRIES; i++) {\n            Chunk<K, V> c = findChunk(key); // find chunk matching key\n            c.lookUp(ctx, key);\n            // If there is a matching value reference for the given key, and it is not marked as deleted,\n            // then this put changes the slice pointed by this value reference.\n            if (ctx.isValueValid()) {\n                // there is a value and it is not deleted\n                Result res = valueOperator.exchange(c, ctx, value, transformer, valueSerializer,\n                    valuesMemoryManager,\n                        this);\n                if (res.operationResult == ValueUtils.ValueResult.TRUE) {\n                    return (V) res.value;\n                }\n                // Exchange failed because the value was deleted/moved between lookup and exchange. Continue with\n                // insertion.\n                continue;\n            }\n\n            if (isAfterRebalanceOrValueUpdate(c, ctx)) {\n                continue;\n            }\n\n            // AT THIS POINT EITHER (in all cases context is updated):\n            // (1) Key wasn't found (key and value not valid)\n            // (2) Key was found and it's value is deleted/invalid (key valid value invalid)\n            if (!ctx.isKeyValid()) {\n                if (!allocateAndLinkEntry(c, ctx, key, false)) {\n                    continue; // allocation wasn't successfull and resulted in rebalance - retry\n                }\n            }\n\n            c.writeValue(ctx, value, false); // write value in place\n\n            if (!c.publish()) {\n                c.releaseNewValue(ctx);\n                rebalance(c);\n                continue;\n            }\n\n            if (c.linkValue(ctx) != ValueUtils.ValueResult.TRUE) {\n                c.releaseNewValue(ctx);\n                c.unpublish();\n            } else {\n                c.unpublish();\n                checkRebalance(c);\n                return null; // null can be returned only in zero-copy case\n            }\n        }\n        throw new RuntimeException(\"put failed: reached retry limit (1024).\");\n    }", "signature": "V put(K key, V value, OakTransformer<V> transformer)", "full_signature": " V put(K key, V value, OakTransformer<V> transformer)", "class_method_signature": "InternalOakMap.put(K key, V value, OakTransformer<V> transformer)", "testcase": false, "constructor": false, "invocations": ["getThreadContext", "findChunk", "lookUp", "isValueValid", "exchange", "isAfterRebalanceOrValueUpdate", "isKeyValid", "allocateAndLinkEntry", "writeValue", "publish", "releaseNewValue", "rebalance", "linkValue", "releaseNewValue", "unpublish", "unpublish", "checkRebalance"]}, "repository": {"repo_id": 140631483, "url": "https://github.com/yahoo/Oak", "stars": 114, "created": "7/11/2018 9:57:20 PM +00:00", "updates": "2020-01-22T11:50:06+00:00", "fork": "False", "license": "licensed"}}