{"test_class": {"identifier": "TestAbstractYarnScheduler", "superclass": "extends ParameterizedSchedulerTestBase", "interfaces": "", "fields": [], "file": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/test/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/TestAbstractYarnScheduler.java"}, "test_case": {"identifier": "testUpdateMaxAllocationUsesTotal", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testUpdateMaxAllocationUsesTotal() throws IOException {\n    final int configuredMaxVCores = 20;\n    final int configuredMaxMemory = 10 * 1024;\n    Resource configuredMaximumResource = Resource.newInstance\n        (configuredMaxMemory, configuredMaxVCores);\n\n    configureScheduler();\n    YarnConfiguration conf = getConf();\n    conf.setInt(YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES,\n        configuredMaxVCores);\n    conf.setInt(YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_MB,\n        configuredMaxMemory);\n    conf.setLong(\n        YarnConfiguration.RM_WORK_PRESERVING_RECOVERY_SCHEDULING_WAIT_MS,\n        0);\n\n    MockRM rm = new MockRM(conf);\n    try {\n      rm.start();\n      AbstractYarnScheduler scheduler = (AbstractYarnScheduler) rm\n          .getResourceScheduler();\n\n      Resource emptyResource = Resource.newInstance(0, 0);\n      Resource fullResource1 = Resource.newInstance(1024, 5);\n      Resource fullResource2 = Resource.newInstance(2048, 10);\n\n      SchedulerNode mockNode1 = mock(SchedulerNode.class);\n      when(mockNode1.getNodeID()).thenReturn(NodeId.newInstance(\"foo\", 8080));\n      when(mockNode1.getAvailableResource()).thenReturn(emptyResource);\n      when(mockNode1.getTotalResource()).thenReturn(fullResource1);\n\n      SchedulerNode mockNode2 = mock(SchedulerNode.class);\n      when(mockNode1.getNodeID()).thenReturn(NodeId.newInstance(\"bar\", 8081));\n      when(mockNode2.getAvailableResource()).thenReturn(emptyResource);\n      when(mockNode2.getTotalResource()).thenReturn(fullResource2);\n\n      verifyMaximumResourceCapability(configuredMaximumResource, scheduler);\n\n      scheduler.nodes = new HashMap<NodeId, SchedulerNode>();\n\n      scheduler.nodes.put(mockNode1.getNodeID(), mockNode1);\n      scheduler.updateMaximumAllocation(mockNode1, true);\n      verifyMaximumResourceCapability(fullResource1, scheduler);\n\n      scheduler.nodes.put(mockNode2.getNodeID(), mockNode2);\n      scheduler.updateMaximumAllocation(mockNode2, true);\n      verifyMaximumResourceCapability(fullResource2, scheduler);\n\n      scheduler.nodes.remove(mockNode2.getNodeID());\n      scheduler.updateMaximumAllocation(mockNode2, false);\n      verifyMaximumResourceCapability(fullResource1, scheduler);\n\n      scheduler.nodes.remove(mockNode1.getNodeID());\n      scheduler.updateMaximumAllocation(mockNode1, false);\n      verifyMaximumResourceCapability(configuredMaximumResource, scheduler);\n    } finally {\n      rm.stop();\n    }\n  }", "signature": "void testUpdateMaxAllocationUsesTotal()", "full_signature": "@Test public void testUpdateMaxAllocationUsesTotal()", "class_method_signature": "TestAbstractYarnScheduler.testUpdateMaxAllocationUsesTotal()", "testcase": true, "constructor": false, "invocations": ["newInstance", "configureScheduler", "getConf", "setInt", "setInt", "setLong", "start", "getResourceScheduler", "newInstance", "newInstance", "newInstance", "mock", "thenReturn", "when", "getNodeID", "newInstance", "thenReturn", "when", "getAvailableResource", "thenReturn", "when", "getTotalResource", "mock", "thenReturn", "when", "getNodeID", "newInstance", "thenReturn", "when", "getAvailableResource", "thenReturn", "when", "getTotalResource", "verifyMaximumResourceCapability", "put", "getNodeID", "updateMaximumAllocation", "verifyMaximumResourceCapability", "put", "getNodeID", "updateMaximumAllocation", "verifyMaximumResourceCapability", "remove", "getNodeID", "updateMaximumAllocation", "verifyMaximumResourceCapability", "remove", "getNodeID", "updateMaximumAllocation", "verifyMaximumResourceCapability", "stop"]}, "focal_class": {"identifier": "AbstractYarnScheduler", "superclass": "extends AbstractService", "interfaces": "implements ResourceScheduler", "fields": [{"original_string": "private static final Log LOG = LogFactory.getLog(AbstractYarnScheduler.class);", "modifier": "private static final", "type": "Log", "declarator": "LOG = LogFactory.getLog(AbstractYarnScheduler.class)", "var_name": "LOG"}, {"original_string": "protected Map<NodeId, N> nodes = new ConcurrentHashMap<NodeId, N>();", "modifier": "protected", "type": "Map<NodeId, N>", "declarator": "nodes = new ConcurrentHashMap<NodeId, N>()", "var_name": "nodes"}, {"original_string": "protected Resource clusterResource = Resource.newInstance(0, 0);", "modifier": "protected", "type": "Resource", "declarator": "clusterResource = Resource.newInstance(0, 0)", "var_name": "clusterResource"}, {"original_string": "protected Resource minimumAllocation;", "modifier": "protected", "type": "Resource", "declarator": "minimumAllocation", "var_name": "minimumAllocation"}, {"original_string": "private Resource maximumAllocation;", "modifier": "private", "type": "Resource", "declarator": "maximumAllocation", "var_name": "maximumAllocation"}, {"original_string": "private Resource configuredMaximumAllocation;", "modifier": "private", "type": "Resource", "declarator": "configuredMaximumAllocation", "var_name": "configuredMaximumAllocation"}, {"original_string": "private int maxNodeMemory = -1;", "modifier": "private", "type": "int", "declarator": "maxNodeMemory = -1", "var_name": "maxNodeMemory"}, {"original_string": "private int maxNodeVCores = -1;", "modifier": "private", "type": "int", "declarator": "maxNodeVCores = -1", "var_name": "maxNodeVCores"}, {"original_string": "private final ReadLock maxAllocReadLock;", "modifier": "private final", "type": "ReadLock", "declarator": "maxAllocReadLock", "var_name": "maxAllocReadLock"}, {"original_string": "private final WriteLock maxAllocWriteLock;", "modifier": "private final", "type": "WriteLock", "declarator": "maxAllocWriteLock", "var_name": "maxAllocWriteLock"}, {"original_string": "private boolean useConfiguredMaximumAllocationOnly = true;", "modifier": "private", "type": "boolean", "declarator": "useConfiguredMaximumAllocationOnly = true", "var_name": "useConfiguredMaximumAllocationOnly"}, {"original_string": "private long configuredMaximumAllocationWaitTime;", "modifier": "private", "type": "long", "declarator": "configuredMaximumAllocationWaitTime", "var_name": "configuredMaximumAllocationWaitTime"}, {"original_string": "protected RMContext rmContext;", "modifier": "protected", "type": "RMContext", "declarator": "rmContext", "var_name": "rmContext"}, {"original_string": "protected ConcurrentMap<ApplicationId, SchedulerApplication<T>> applications;", "modifier": "protected", "type": "ConcurrentMap<ApplicationId, SchedulerApplication<T>>", "declarator": "applications", "var_name": "applications"}, {"original_string": "protected int nmExpireInterval;", "modifier": "protected", "type": "int", "declarator": "nmExpireInterval", "var_name": "nmExpireInterval"}, {"original_string": "protected final static List<Container> EMPTY_CONTAINER_LIST =\n      new ArrayList<Container>();", "modifier": "protected final static", "type": "List<Container>", "declarator": "EMPTY_CONTAINER_LIST =\n      new ArrayList<Container>()", "var_name": "EMPTY_CONTAINER_LIST"}, {"original_string": "protected static final Allocation EMPTY_ALLOCATION = new Allocation(\n    EMPTY_CONTAINER_LIST, Resources.createResource(0), null, null, null);", "modifier": "protected static final", "type": "Allocation", "declarator": "EMPTY_ALLOCATION = new Allocation(\n    EMPTY_CONTAINER_LIST, Resources.createResource(0), null, null, null)", "var_name": "EMPTY_ALLOCATION"}], "methods": [{"identifier": "AbstractYarnScheduler", "parameters": "(String name)", "modifiers": "public", "return": "", "signature": " AbstractYarnScheduler(String name)", "full_signature": "public  AbstractYarnScheduler(String name)", "class_method_signature": "AbstractYarnScheduler.AbstractYarnScheduler(String name)", "testcase": false, "constructor": true}, {"identifier": "serviceInit", "parameters": "(Configuration conf)", "modifiers": "@Override public", "return": "void", "signature": "void serviceInit(Configuration conf)", "full_signature": "@Override public void serviceInit(Configuration conf)", "class_method_signature": "AbstractYarnScheduler.serviceInit(Configuration conf)", "testcase": false, "constructor": false}, {"identifier": "getTransferredContainers", "parameters": "(\n      ApplicationAttemptId currentAttempt)", "modifiers": "public", "return": "List<Container>", "signature": "List<Container> getTransferredContainers(\n      ApplicationAttemptId currentAttempt)", "full_signature": "public List<Container> getTransferredContainers(\n      ApplicationAttemptId currentAttempt)", "class_method_signature": "AbstractYarnScheduler.getTransferredContainers(\n      ApplicationAttemptId currentAttempt)", "testcase": false, "constructor": false}, {"identifier": "getSchedulerApplications", "parameters": "()", "modifiers": "public", "return": "Map<ApplicationId, SchedulerApplication<T>>", "signature": "Map<ApplicationId, SchedulerApplication<T>> getSchedulerApplications()", "full_signature": "public Map<ApplicationId, SchedulerApplication<T>> getSchedulerApplications()", "class_method_signature": "AbstractYarnScheduler.getSchedulerApplications()", "testcase": false, "constructor": false}, {"identifier": "getClusterResource", "parameters": "()", "modifiers": "@Override public", "return": "Resource", "signature": "Resource getClusterResource()", "full_signature": "@Override public Resource getClusterResource()", "class_method_signature": "AbstractYarnScheduler.getClusterResource()", "testcase": false, "constructor": false}, {"identifier": "getMinimumResourceCapability", "parameters": "()", "modifiers": "@Override public", "return": "Resource", "signature": "Resource getMinimumResourceCapability()", "full_signature": "@Override public Resource getMinimumResourceCapability()", "class_method_signature": "AbstractYarnScheduler.getMinimumResourceCapability()", "testcase": false, "constructor": false}, {"identifier": "getMaximumResourceCapability", "parameters": "()", "modifiers": "@Override public", "return": "Resource", "signature": "Resource getMaximumResourceCapability()", "full_signature": "@Override public Resource getMaximumResourceCapability()", "class_method_signature": "AbstractYarnScheduler.getMaximumResourceCapability()", "testcase": false, "constructor": false}, {"identifier": "getMaximumResourceCapability", "parameters": "(String queueName)", "modifiers": "@Override public", "return": "Resource", "signature": "Resource getMaximumResourceCapability(String queueName)", "full_signature": "@Override public Resource getMaximumResourceCapability(String queueName)", "class_method_signature": "AbstractYarnScheduler.getMaximumResourceCapability(String queueName)", "testcase": false, "constructor": false}, {"identifier": "initMaximumResourceCapability", "parameters": "(Resource maximumAllocation)", "modifiers": "protected", "return": "void", "signature": "void initMaximumResourceCapability(Resource maximumAllocation)", "full_signature": "protected void initMaximumResourceCapability(Resource maximumAllocation)", "class_method_signature": "AbstractYarnScheduler.initMaximumResourceCapability(Resource maximumAllocation)", "testcase": false, "constructor": false}, {"identifier": "containerLaunchedOnNode", "parameters": "(\n      ContainerId containerId, SchedulerNode node)", "modifiers": "protected synchronized", "return": "void", "signature": "void containerLaunchedOnNode(\n      ContainerId containerId, SchedulerNode node)", "full_signature": "protected synchronized void containerLaunchedOnNode(\n      ContainerId containerId, SchedulerNode node)", "class_method_signature": "AbstractYarnScheduler.containerLaunchedOnNode(\n      ContainerId containerId, SchedulerNode node)", "testcase": false, "constructor": false}, {"identifier": "getApplicationAttempt", "parameters": "(ApplicationAttemptId applicationAttemptId)", "modifiers": "public", "return": "T", "signature": "T getApplicationAttempt(ApplicationAttemptId applicationAttemptId)", "full_signature": "public T getApplicationAttempt(ApplicationAttemptId applicationAttemptId)", "class_method_signature": "AbstractYarnScheduler.getApplicationAttempt(ApplicationAttemptId applicationAttemptId)", "testcase": false, "constructor": false}, {"identifier": "getSchedulerAppInfo", "parameters": "(\n      ApplicationAttemptId appAttemptId)", "modifiers": "@Override public", "return": "SchedulerAppReport", "signature": "SchedulerAppReport getSchedulerAppInfo(\n      ApplicationAttemptId appAttemptId)", "full_signature": "@Override public SchedulerAppReport getSchedulerAppInfo(\n      ApplicationAttemptId appAttemptId)", "class_method_signature": "AbstractYarnScheduler.getSchedulerAppInfo(\n      ApplicationAttemptId appAttemptId)", "testcase": false, "constructor": false}, {"identifier": "getAppResourceUsageReport", "parameters": "(\n      ApplicationAttemptId appAttemptId)", "modifiers": "@Override public", "return": "ApplicationResourceUsageReport", "signature": "ApplicationResourceUsageReport getAppResourceUsageReport(\n      ApplicationAttemptId appAttemptId)", "full_signature": "@Override public ApplicationResourceUsageReport getAppResourceUsageReport(\n      ApplicationAttemptId appAttemptId)", "class_method_signature": "AbstractYarnScheduler.getAppResourceUsageReport(\n      ApplicationAttemptId appAttemptId)", "testcase": false, "constructor": false}, {"identifier": "getCurrentAttemptForContainer", "parameters": "(ContainerId containerId)", "modifiers": "public", "return": "T", "signature": "T getCurrentAttemptForContainer(ContainerId containerId)", "full_signature": "public T getCurrentAttemptForContainer(ContainerId containerId)", "class_method_signature": "AbstractYarnScheduler.getCurrentAttemptForContainer(ContainerId containerId)", "testcase": false, "constructor": false}, {"identifier": "getRMContainer", "parameters": "(ContainerId containerId)", "modifiers": "@Override public", "return": "RMContainer", "signature": "RMContainer getRMContainer(ContainerId containerId)", "full_signature": "@Override public RMContainer getRMContainer(ContainerId containerId)", "class_method_signature": "AbstractYarnScheduler.getRMContainer(ContainerId containerId)", "testcase": false, "constructor": false}, {"identifier": "getNodeReport", "parameters": "(NodeId nodeId)", "modifiers": "@Override public", "return": "SchedulerNodeReport", "signature": "SchedulerNodeReport getNodeReport(NodeId nodeId)", "full_signature": "@Override public SchedulerNodeReport getNodeReport(NodeId nodeId)", "class_method_signature": "AbstractYarnScheduler.getNodeReport(NodeId nodeId)", "testcase": false, "constructor": false}, {"identifier": "moveApplication", "parameters": "(ApplicationId appId, String newQueue)", "modifiers": "@Override public", "return": "String", "signature": "String moveApplication(ApplicationId appId, String newQueue)", "full_signature": "@Override public String moveApplication(ApplicationId appId, String newQueue)", "class_method_signature": "AbstractYarnScheduler.moveApplication(ApplicationId appId, String newQueue)", "testcase": false, "constructor": false}, {"identifier": "removeQueue", "parameters": "(String queueName)", "modifiers": "public", "return": "void", "signature": "void removeQueue(String queueName)", "full_signature": "public void removeQueue(String queueName)", "class_method_signature": "AbstractYarnScheduler.removeQueue(String queueName)", "testcase": false, "constructor": false}, {"identifier": "addQueue", "parameters": "(Queue newQueue)", "modifiers": "@Override public", "return": "void", "signature": "void addQueue(Queue newQueue)", "full_signature": "@Override public void addQueue(Queue newQueue)", "class_method_signature": "AbstractYarnScheduler.addQueue(Queue newQueue)", "testcase": false, "constructor": false}, {"identifier": "setEntitlement", "parameters": "(String queue, QueueEntitlement entitlement)", "modifiers": "@Override public", "return": "void", "signature": "void setEntitlement(String queue, QueueEntitlement entitlement)", "full_signature": "@Override public void setEntitlement(String queue, QueueEntitlement entitlement)", "class_method_signature": "AbstractYarnScheduler.setEntitlement(String queue, QueueEntitlement entitlement)", "testcase": false, "constructor": false}, {"identifier": "killOrphanContainerOnNode", "parameters": "(RMNode node,\n      NMContainerStatus container)", "modifiers": "private", "return": "void", "signature": "void killOrphanContainerOnNode(RMNode node,\n      NMContainerStatus container)", "full_signature": "private void killOrphanContainerOnNode(RMNode node,\n      NMContainerStatus container)", "class_method_signature": "AbstractYarnScheduler.killOrphanContainerOnNode(RMNode node,\n      NMContainerStatus container)", "testcase": false, "constructor": false}, {"identifier": "recoverContainersOnNode", "parameters": "(\n      List<NMContainerStatus> containerReports, RMNode nm)", "modifiers": "public synchronized", "return": "void", "signature": "void recoverContainersOnNode(\n      List<NMContainerStatus> containerReports, RMNode nm)", "full_signature": "public synchronized void recoverContainersOnNode(\n      List<NMContainerStatus> containerReports, RMNode nm)", "class_method_signature": "AbstractYarnScheduler.recoverContainersOnNode(\n      List<NMContainerStatus> containerReports, RMNode nm)", "testcase": false, "constructor": false}, {"identifier": "recoverAndCreateContainer", "parameters": "(NMContainerStatus status,\n      RMNode node)", "modifiers": "private", "return": "RMContainer", "signature": "RMContainer recoverAndCreateContainer(NMContainerStatus status,\n      RMNode node)", "full_signature": "private RMContainer recoverAndCreateContainer(NMContainerStatus status,\n      RMNode node)", "class_method_signature": "AbstractYarnScheduler.recoverAndCreateContainer(NMContainerStatus status,\n      RMNode node)", "testcase": false, "constructor": false}, {"identifier": "recoverResourceRequestForContainer", "parameters": "(RMContainer rmContainer)", "modifiers": "protected", "return": "void", "signature": "void recoverResourceRequestForContainer(RMContainer rmContainer)", "full_signature": "protected void recoverResourceRequestForContainer(RMContainer rmContainer)", "class_method_signature": "AbstractYarnScheduler.recoverResourceRequestForContainer(RMContainer rmContainer)", "testcase": false, "constructor": false}, {"identifier": "createReleaseCache", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void createReleaseCache()", "full_signature": "protected void createReleaseCache()", "class_method_signature": "AbstractYarnScheduler.createReleaseCache()", "testcase": false, "constructor": false}, {"identifier": "completedContainer", "parameters": "(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event)", "modifiers": "protected abstract", "return": "void", "signature": "void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event)", "full_signature": "protected abstract void completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event)", "class_method_signature": "AbstractYarnScheduler.completedContainer(RMContainer rmContainer,\n      ContainerStatus containerStatus, RMContainerEventType event)", "testcase": false, "constructor": false}, {"identifier": "releaseContainers", "parameters": "(List<ContainerId> containers,\n      SchedulerApplicationAttempt attempt)", "modifiers": "protected", "return": "void", "signature": "void releaseContainers(List<ContainerId> containers,\n      SchedulerApplicationAttempt attempt)", "full_signature": "protected void releaseContainers(List<ContainerId> containers,\n      SchedulerApplicationAttempt attempt)", "class_method_signature": "AbstractYarnScheduler.releaseContainers(List<ContainerId> containers,\n      SchedulerApplicationAttempt attempt)", "testcase": false, "constructor": false}, {"identifier": "getSchedulerNode", "parameters": "(NodeId nodeId)", "modifiers": "public", "return": "SchedulerNode", "signature": "SchedulerNode getSchedulerNode(NodeId nodeId)", "full_signature": "public SchedulerNode getSchedulerNode(NodeId nodeId)", "class_method_signature": "AbstractYarnScheduler.getSchedulerNode(NodeId nodeId)", "testcase": false, "constructor": false}, {"identifier": "moveAllApps", "parameters": "(String sourceQueue, String destQueue)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void moveAllApps(String sourceQueue, String destQueue)", "full_signature": "@Override public synchronized void moveAllApps(String sourceQueue, String destQueue)", "class_method_signature": "AbstractYarnScheduler.moveAllApps(String sourceQueue, String destQueue)", "testcase": false, "constructor": false}, {"identifier": "killAllAppsInQueue", "parameters": "(String queueName)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void killAllAppsInQueue(String queueName)", "full_signature": "@Override public synchronized void killAllAppsInQueue(String queueName)", "class_method_signature": "AbstractYarnScheduler.killAllAppsInQueue(String queueName)", "testcase": false, "constructor": false}, {"identifier": "updateNodeResource", "parameters": "(RMNode nm, \n      ResourceOption resourceOption)", "modifiers": "public synchronized", "return": "void", "signature": "void updateNodeResource(RMNode nm, \n      ResourceOption resourceOption)", "full_signature": "public synchronized void updateNodeResource(RMNode nm, \n      ResourceOption resourceOption)", "class_method_signature": "AbstractYarnScheduler.updateNodeResource(RMNode nm, \n      ResourceOption resourceOption)", "testcase": false, "constructor": false}, {"identifier": "getSchedulingResourceTypes", "parameters": "()", "modifiers": "@Override public", "return": "EnumSet<SchedulerResourceTypes>", "signature": "EnumSet<SchedulerResourceTypes> getSchedulingResourceTypes()", "full_signature": "@Override public EnumSet<SchedulerResourceTypes> getSchedulingResourceTypes()", "class_method_signature": "AbstractYarnScheduler.getSchedulingResourceTypes()", "testcase": false, "constructor": false}, {"identifier": "getPlanQueues", "parameters": "()", "modifiers": "@Override public", "return": "Set<String>", "signature": "Set<String> getPlanQueues()", "full_signature": "@Override public Set<String> getPlanQueues()", "class_method_signature": "AbstractYarnScheduler.getPlanQueues()", "testcase": false, "constructor": false}, {"identifier": "updateMaximumAllocation", "parameters": "(SchedulerNode node, boolean add)", "modifiers": "protected", "return": "void", "signature": "void updateMaximumAllocation(SchedulerNode node, boolean add)", "full_signature": "protected void updateMaximumAllocation(SchedulerNode node, boolean add)", "class_method_signature": "AbstractYarnScheduler.updateMaximumAllocation(SchedulerNode node, boolean add)", "testcase": false, "constructor": false}, {"identifier": "refreshMaximumAllocation", "parameters": "(Resource newMaxAlloc)", "modifiers": "protected", "return": "void", "signature": "void refreshMaximumAllocation(Resource newMaxAlloc)", "full_signature": "protected void refreshMaximumAllocation(Resource newMaxAlloc)", "class_method_signature": "AbstractYarnScheduler.refreshMaximumAllocation(Resource newMaxAlloc)", "testcase": false, "constructor": false}, {"identifier": "getPendingResourceRequestsForAttempt", "parameters": "(\n      ApplicationAttemptId attemptId)", "modifiers": "public", "return": "List<ResourceRequest>", "signature": "List<ResourceRequest> getPendingResourceRequestsForAttempt(\n      ApplicationAttemptId attemptId)", "full_signature": "public List<ResourceRequest> getPendingResourceRequestsForAttempt(\n      ApplicationAttemptId attemptId)", "class_method_signature": "AbstractYarnScheduler.getPendingResourceRequestsForAttempt(\n      ApplicationAttemptId attemptId)", "testcase": false, "constructor": false}], "file": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java"}, "focal_method": {"identifier": "updateMaximumAllocation", "parameters": "(SchedulerNode node, boolean add)", "modifiers": "protected", "return": "void", "body": "protected void updateMaximumAllocation(SchedulerNode node, boolean add) {\n    Resource totalResource = node.getTotalResource();\n    maxAllocWriteLock.lock();\n    try {\n      if (add) { // added node\n        int nodeMemory = totalResource.getMemory();\n        if (nodeMemory > maxNodeMemory) {\n          maxNodeMemory = nodeMemory;\n          maximumAllocation.setMemory(Math.min(\n              configuredMaximumAllocation.getMemory(), maxNodeMemory));\n        }\n        int nodeVCores = totalResource.getVirtualCores();\n        if (nodeVCores > maxNodeVCores) {\n          maxNodeVCores = nodeVCores;\n          maximumAllocation.setVirtualCores(Math.min(\n              configuredMaximumAllocation.getVirtualCores(), maxNodeVCores));\n        }\n      } else {  // removed node\n        if (maxNodeMemory == totalResource.getMemory()) {\n          maxNodeMemory = -1;\n        }\n        if (maxNodeVCores == totalResource.getVirtualCores()) {\n          maxNodeVCores = -1;\n        }\n        // We only have to iterate through the nodes if the current max memory\n        // or vcores was equal to the removed node's\n        if (maxNodeMemory == -1 || maxNodeVCores == -1) {\n          for (Map.Entry<NodeId, N> nodeEntry : nodes.entrySet()) {\n            int nodeMemory =\n                nodeEntry.getValue().getTotalResource().getMemory();\n            if (nodeMemory > maxNodeMemory) {\n              maxNodeMemory = nodeMemory;\n            }\n            int nodeVCores =\n                nodeEntry.getValue().getTotalResource().getVirtualCores();\n            if (nodeVCores > maxNodeVCores) {\n              maxNodeVCores = nodeVCores;\n            }\n          }\n          if (maxNodeMemory == -1) {  // no nodes\n            maximumAllocation.setMemory(configuredMaximumAllocation.getMemory());\n          } else {\n            maximumAllocation.setMemory(\n                Math.min(configuredMaximumAllocation.getMemory(), maxNodeMemory));\n          }\n          if (maxNodeVCores == -1) {  // no nodes\n            maximumAllocation.setVirtualCores(configuredMaximumAllocation.getVirtualCores());\n          } else {\n            maximumAllocation.setVirtualCores(\n                Math.min(configuredMaximumAllocation.getVirtualCores(), maxNodeVCores));\n          }\n        }\n      }\n    } finally {\n      maxAllocWriteLock.unlock();\n    }\n  }", "signature": "void updateMaximumAllocation(SchedulerNode node, boolean add)", "full_signature": "protected void updateMaximumAllocation(SchedulerNode node, boolean add)", "class_method_signature": "AbstractYarnScheduler.updateMaximumAllocation(SchedulerNode node, boolean add)", "testcase": false, "constructor": false, "invocations": ["getTotalResource", "lock", "getMemory", "setMemory", "min", "getMemory", "getVirtualCores", "setVirtualCores", "min", "getVirtualCores", "getMemory", "getVirtualCores", "entrySet", "getMemory", "getTotalResource", "getValue", "getVirtualCores", "getTotalResource", "getValue", "setMemory", "getMemory", "setMemory", "min", "getMemory", "setVirtualCores", "getVirtualCores", "setVirtualCores", "min", "getVirtualCores", "unlock"]}, "repository": {"repo_id": 195808004, "url": "https://github.com/mouzwang/hadoop-2.7.2", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 5, "size": 24927, "license": "licensed"}}