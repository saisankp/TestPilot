{"test_class": {"identifier": "TestBucketWriter", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Logger logger = LoggerFactory.getLogger(TestBucketWriter.class);", "modifier": "private static", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(TestBucketWriter.class)", "var_name": "logger"}, {"original_string": "private Context ctx = new Context();", "modifier": "private", "type": "Context", "declarator": "ctx = new Context()", "var_name": "ctx"}, {"original_string": "private static ScheduledExecutorService timedRollerPool;", "modifier": "private static", "type": "ScheduledExecutorService", "declarator": "timedRollerPool", "var_name": "timedRollerPool"}, {"original_string": "private static PrivilegedExecutor proxy;", "modifier": "private static", "type": "PrivilegedExecutor", "declarator": "proxy", "var_name": "proxy"}], "file": "flume-ng-sinks/flume-hdfs-sink/src/test/java/org/apache/flume/sink/hdfs/TestBucketWriter.java"}, "test_case": {"identifier": "testEventCountingRoller", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testEventCountingRoller() throws IOException, InterruptedException {\n    int maxEvents = 100;\n    MockHDFSWriter hdfsWriter = new MockHDFSWriter();\n    BucketWriter bucketWriter = new BucketWriterBuilder(hdfsWriter)\n        .setRollCount(maxEvents).build();\n\n    Event e = EventBuilder.withBody(\"foo\", Charsets.UTF_8);\n    for (int i = 0; i < 1000; i++) {\n      bucketWriter.append(e);\n    }\n\n    logger.info(\"Number of events written: {}\", hdfsWriter.getEventsWritten());\n    logger.info(\"Number of bytes written: {}\", hdfsWriter.getBytesWritten());\n    logger.info(\"Number of files opened: {}\", hdfsWriter.getFilesOpened());\n\n    Assert.assertEquals(\"events written\", 1000, hdfsWriter.getEventsWritten());\n    Assert.assertEquals(\"bytes written\", 3000, hdfsWriter.getBytesWritten());\n    Assert.assertEquals(\"files opened\", 10, hdfsWriter.getFilesOpened());\n  }", "signature": "void testEventCountingRoller()", "full_signature": "@Test public void testEventCountingRoller()", "class_method_signature": "TestBucketWriter.testEventCountingRoller()", "testcase": true, "constructor": false, "invocations": ["build", "setRollCount", "withBody", "append", "info", "getEventsWritten", "info", "getBytesWritten", "info", "getFilesOpened", "assertEquals", "getEventsWritten", "assertEquals", "getBytesWritten", "assertEquals", "getFilesOpened"]}, "focal_class": {"identifier": "BucketWriter", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory\n      .getLogger(BucketWriter.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory\n      .getLogger(BucketWriter.class)", "var_name": "LOG"}, {"original_string": "private static final Integer staticLock = new Integer(1);", "modifier": "private static final", "type": "Integer", "declarator": "staticLock = new Integer(1)", "var_name": "staticLock"}, {"original_string": "private Method isClosedMethod = null;", "modifier": "private", "type": "Method", "declarator": "isClosedMethod = null", "var_name": "isClosedMethod"}, {"original_string": "private final HDFSWriter writer;", "modifier": "private final", "type": "HDFSWriter", "declarator": "writer", "var_name": "writer"}, {"original_string": "private final long rollInterval;", "modifier": "private final", "type": "long", "declarator": "rollInterval", "var_name": "rollInterval"}, {"original_string": "private final long rollSize;", "modifier": "private final", "type": "long", "declarator": "rollSize", "var_name": "rollSize"}, {"original_string": "private final long rollCount;", "modifier": "private final", "type": "long", "declarator": "rollCount", "var_name": "rollCount"}, {"original_string": "private final long batchSize;", "modifier": "private final", "type": "long", "declarator": "batchSize", "var_name": "batchSize"}, {"original_string": "private final CompressionCodec codeC;", "modifier": "private final", "type": "CompressionCodec", "declarator": "codeC", "var_name": "codeC"}, {"original_string": "private final CompressionType compType;", "modifier": "private final", "type": "CompressionType", "declarator": "compType", "var_name": "compType"}, {"original_string": "private final ScheduledExecutorService timedRollerPool;", "modifier": "private final", "type": "ScheduledExecutorService", "declarator": "timedRollerPool", "var_name": "timedRollerPool"}, {"original_string": "private final PrivilegedExecutor proxyUser;", "modifier": "private final", "type": "PrivilegedExecutor", "declarator": "proxyUser", "var_name": "proxyUser"}, {"original_string": "private final AtomicLong fileExtensionCounter;", "modifier": "private final", "type": "AtomicLong", "declarator": "fileExtensionCounter", "var_name": "fileExtensionCounter"}, {"original_string": "private long eventCounter;", "modifier": "private", "type": "long", "declarator": "eventCounter", "var_name": "eventCounter"}, {"original_string": "private long processSize;", "modifier": "private", "type": "long", "declarator": "processSize", "var_name": "processSize"}, {"original_string": "private FileSystem fileSystem;", "modifier": "private", "type": "FileSystem", "declarator": "fileSystem", "var_name": "fileSystem"}, {"original_string": "private volatile String filePath;", "modifier": "private volatile", "type": "String", "declarator": "filePath", "var_name": "filePath"}, {"original_string": "private volatile String fileName;", "modifier": "private volatile", "type": "String", "declarator": "fileName", "var_name": "fileName"}, {"original_string": "private volatile String inUsePrefix;", "modifier": "private volatile", "type": "String", "declarator": "inUsePrefix", "var_name": "inUsePrefix"}, {"original_string": "private volatile String inUseSuffix;", "modifier": "private volatile", "type": "String", "declarator": "inUseSuffix", "var_name": "inUseSuffix"}, {"original_string": "private volatile String fileSuffix;", "modifier": "private volatile", "type": "String", "declarator": "fileSuffix", "var_name": "fileSuffix"}, {"original_string": "private volatile String bucketPath;", "modifier": "private volatile", "type": "String", "declarator": "bucketPath", "var_name": "bucketPath"}, {"original_string": "private volatile String targetPath;", "modifier": "private volatile", "type": "String", "declarator": "targetPath", "var_name": "targetPath"}, {"original_string": "private volatile long batchCounter;", "modifier": "private volatile", "type": "long", "declarator": "batchCounter", "var_name": "batchCounter"}, {"original_string": "private volatile boolean isOpen;", "modifier": "private volatile", "type": "boolean", "declarator": "isOpen", "var_name": "isOpen"}, {"original_string": "private volatile boolean isUnderReplicated;", "modifier": "private volatile", "type": "boolean", "declarator": "isUnderReplicated", "var_name": "isUnderReplicated"}, {"original_string": "private volatile int consecutiveUnderReplRotateCount = 0;", "modifier": "private volatile", "type": "int", "declarator": "consecutiveUnderReplRotateCount = 0", "var_name": "consecutiveUnderReplRotateCount"}, {"original_string": "private volatile ScheduledFuture<Void> timedRollFuture;", "modifier": "private volatile", "type": "ScheduledFuture<Void>", "declarator": "timedRollFuture", "var_name": "timedRollFuture"}, {"original_string": "private SinkCounter sinkCounter;", "modifier": "private", "type": "SinkCounter", "declarator": "sinkCounter", "var_name": "sinkCounter"}, {"original_string": "private final int idleTimeout;", "modifier": "private final", "type": "int", "declarator": "idleTimeout", "var_name": "idleTimeout"}, {"original_string": "private volatile ScheduledFuture<Void> idleFuture;", "modifier": "private volatile", "type": "ScheduledFuture<Void>", "declarator": "idleFuture", "var_name": "idleFuture"}, {"original_string": "private final WriterCallback onCloseCallback;", "modifier": "private final", "type": "WriterCallback", "declarator": "onCloseCallback", "var_name": "onCloseCallback"}, {"original_string": "private final String onCloseCallbackPath;", "modifier": "private final", "type": "String", "declarator": "onCloseCallbackPath", "var_name": "onCloseCallbackPath"}, {"original_string": "private final long callTimeout;", "modifier": "private final", "type": "long", "declarator": "callTimeout", "var_name": "callTimeout"}, {"original_string": "private final ExecutorService callTimeoutPool;", "modifier": "private final", "type": "ExecutorService", "declarator": "callTimeoutPool", "var_name": "callTimeoutPool"}, {"original_string": "private final int maxConsecUnderReplRotations = 30;", "modifier": "private final", "type": "int", "declarator": "maxConsecUnderReplRotations = 30", "var_name": "maxConsecUnderReplRotations"}, {"original_string": "private boolean mockFsInjected = false;", "modifier": "private", "type": "boolean", "declarator": "mockFsInjected = false", "var_name": "mockFsInjected"}, {"original_string": "private final long retryInterval;", "modifier": "private final", "type": "long", "declarator": "retryInterval", "var_name": "retryInterval"}, {"original_string": "private final int maxRetries;", "modifier": "private final", "type": "int", "declarator": "maxRetries", "var_name": "maxRetries"}, {"original_string": "protected AtomicBoolean closed = new AtomicBoolean();", "modifier": "protected", "type": "AtomicBoolean", "declarator": "closed = new AtomicBoolean()", "var_name": "closed"}, {"original_string": "AtomicInteger renameTries = new AtomicInteger(0);", "modifier": "", "type": "AtomicInteger", "declarator": "renameTries = new AtomicInteger(0)", "var_name": "renameTries"}], "methods": [{"identifier": "BucketWriter", "parameters": "(long rollInterval, long rollSize, long rollCount, long batchSize,\n      Context context, String filePath, String fileName, String inUsePrefix,\n      String inUseSuffix, String fileSuffix, CompressionCodec codeC,\n      CompressionType compType, HDFSWriter writer,\n      ScheduledExecutorService timedRollerPool, PrivilegedExecutor proxyUser,\n      SinkCounter sinkCounter, int idleTimeout, WriterCallback onCloseCallback,\n      String onCloseCallbackPath, long callTimeout,\n      ExecutorService callTimeoutPool, long retryInterval,\n      int maxRetries)", "modifiers": "", "return": "", "signature": " BucketWriter(long rollInterval, long rollSize, long rollCount, long batchSize,\n      Context context, String filePath, String fileName, String inUsePrefix,\n      String inUseSuffix, String fileSuffix, CompressionCodec codeC,\n      CompressionType compType, HDFSWriter writer,\n      ScheduledExecutorService timedRollerPool, PrivilegedExecutor proxyUser,\n      SinkCounter sinkCounter, int idleTimeout, WriterCallback onCloseCallback,\n      String onCloseCallbackPath, long callTimeout,\n      ExecutorService callTimeoutPool, long retryInterval,\n      int maxRetries)", "full_signature": "  BucketWriter(long rollInterval, long rollSize, long rollCount, long batchSize,\n      Context context, String filePath, String fileName, String inUsePrefix,\n      String inUseSuffix, String fileSuffix, CompressionCodec codeC,\n      CompressionType compType, HDFSWriter writer,\n      ScheduledExecutorService timedRollerPool, PrivilegedExecutor proxyUser,\n      SinkCounter sinkCounter, int idleTimeout, WriterCallback onCloseCallback,\n      String onCloseCallbackPath, long callTimeout,\n      ExecutorService callTimeoutPool, long retryInterval,\n      int maxRetries)", "class_method_signature": "BucketWriter.BucketWriter(long rollInterval, long rollSize, long rollCount, long batchSize,\n      Context context, String filePath, String fileName, String inUsePrefix,\n      String inUseSuffix, String fileSuffix, CompressionCodec codeC,\n      CompressionType compType, HDFSWriter writer,\n      ScheduledExecutorService timedRollerPool, PrivilegedExecutor proxyUser,\n      SinkCounter sinkCounter, int idleTimeout, WriterCallback onCloseCallback,\n      String onCloseCallbackPath, long callTimeout,\n      ExecutorService callTimeoutPool, long retryInterval,\n      int maxRetries)", "testcase": false, "constructor": true}, {"identifier": "BucketWriter", "parameters": "(long rollInterval, long rollSize, long rollCount, long batchSize,\n           Context context, String filePath, String fileName, String inUsePrefix,\n           String inUseSuffix, String fileSuffix, CompressionCodec codeC,\n           CompressionType compType, HDFSWriter writer,\n           ScheduledExecutorService timedRollerPool, PrivilegedExecutor proxyUser,\n           SinkCounter sinkCounter, int idleTimeout, WriterCallback onCloseCallback,\n           String onCloseCallbackPath, long callTimeout,\n           ExecutorService callTimeoutPool, long retryInterval,\n           int maxRetries, Clock clock)", "modifiers": "", "return": "", "signature": " BucketWriter(long rollInterval, long rollSize, long rollCount, long batchSize,\n           Context context, String filePath, String fileName, String inUsePrefix,\n           String inUseSuffix, String fileSuffix, CompressionCodec codeC,\n           CompressionType compType, HDFSWriter writer,\n           ScheduledExecutorService timedRollerPool, PrivilegedExecutor proxyUser,\n           SinkCounter sinkCounter, int idleTimeout, WriterCallback onCloseCallback,\n           String onCloseCallbackPath, long callTimeout,\n           ExecutorService callTimeoutPool, long retryInterval,\n           int maxRetries, Clock clock)", "full_signature": "  BucketWriter(long rollInterval, long rollSize, long rollCount, long batchSize,\n           Context context, String filePath, String fileName, String inUsePrefix,\n           String inUseSuffix, String fileSuffix, CompressionCodec codeC,\n           CompressionType compType, HDFSWriter writer,\n           ScheduledExecutorService timedRollerPool, PrivilegedExecutor proxyUser,\n           SinkCounter sinkCounter, int idleTimeout, WriterCallback onCloseCallback,\n           String onCloseCallbackPath, long callTimeout,\n           ExecutorService callTimeoutPool, long retryInterval,\n           int maxRetries, Clock clock)", "class_method_signature": "BucketWriter.BucketWriter(long rollInterval, long rollSize, long rollCount, long batchSize,\n           Context context, String filePath, String fileName, String inUsePrefix,\n           String inUseSuffix, String fileSuffix, CompressionCodec codeC,\n           CompressionType compType, HDFSWriter writer,\n           ScheduledExecutorService timedRollerPool, PrivilegedExecutor proxyUser,\n           SinkCounter sinkCounter, int idleTimeout, WriterCallback onCloseCallback,\n           String onCloseCallbackPath, long callTimeout,\n           ExecutorService callTimeoutPool, long retryInterval,\n           int maxRetries, Clock clock)", "testcase": false, "constructor": true}, {"identifier": "setFileSystem", "parameters": "(FileSystem fs)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void setFileSystem(FileSystem fs)", "full_signature": "@VisibleForTesting void setFileSystem(FileSystem fs)", "class_method_signature": "BucketWriter.setFileSystem(FileSystem fs)", "testcase": false, "constructor": false}, {"identifier": "resetCounters", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void resetCounters()", "full_signature": "private void resetCounters()", "class_method_signature": "BucketWriter.resetCounters()", "testcase": false, "constructor": false}, {"identifier": "getRefIsClosed", "parameters": "()", "modifiers": "private", "return": "Method", "signature": "Method getRefIsClosed()", "full_signature": "private Method getRefIsClosed()", "class_method_signature": "BucketWriter.getRefIsClosed()", "testcase": false, "constructor": false}, {"identifier": "isFileClosed", "parameters": "(FileSystem fs, Path tmpFilePath)", "modifiers": "private", "return": "Boolean", "signature": "Boolean isFileClosed(FileSystem fs, Path tmpFilePath)", "full_signature": "private Boolean isFileClosed(FileSystem fs, Path tmpFilePath)", "class_method_signature": "BucketWriter.isFileClosed(FileSystem fs, Path tmpFilePath)", "testcase": false, "constructor": false}, {"identifier": "open", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void open()", "full_signature": "private void open()", "class_method_signature": "BucketWriter.open()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "BucketWriter.close()", "testcase": false, "constructor": false}, {"identifier": "createCloseCallRunner", "parameters": "()", "modifiers": "private", "return": "CallRunner<Void>", "signature": "CallRunner<Void> createCloseCallRunner()", "full_signature": "private CallRunner<Void> createCloseCallRunner()", "class_method_signature": "BucketWriter.createCloseCallRunner()", "testcase": false, "constructor": false}, {"identifier": "recoverLease", "parameters": "()", "modifiers": "private synchronized", "return": "void", "signature": "void recoverLease()", "full_signature": "private synchronized void recoverLease()", "class_method_signature": "BucketWriter.recoverLease()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "(boolean callCloseCallback)", "modifiers": "public", "return": "void", "signature": "void close(boolean callCloseCallback)", "full_signature": "public void close(boolean callCloseCallback)", "class_method_signature": "BucketWriter.close(boolean callCloseCallback)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "(boolean callCloseCallback, boolean immediate)", "modifiers": "public", "return": "void", "signature": "void close(boolean callCloseCallback, boolean immediate)", "full_signature": "public void close(boolean callCloseCallback, boolean immediate)", "class_method_signature": "BucketWriter.close(boolean callCloseCallback, boolean immediate)", "testcase": false, "constructor": false}, {"identifier": "doClose", "parameters": "(boolean immediate)", "modifiers": "private synchronized", "return": "void", "signature": "void doClose(boolean immediate)", "full_signature": "private synchronized void doClose(boolean immediate)", "class_method_signature": "BucketWriter.doClose(boolean immediate)", "testcase": false, "constructor": false}, {"identifier": "flush", "parameters": "()", "modifiers": "public synchronized", "return": "void", "signature": "void flush()", "full_signature": "public synchronized void flush()", "class_method_signature": "BucketWriter.flush()", "testcase": false, "constructor": false}, {"identifier": "runCloseAction", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void runCloseAction()", "full_signature": "private void runCloseAction()", "class_method_signature": "BucketWriter.runCloseAction()", "testcase": false, "constructor": false}, {"identifier": "doFlush", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void doFlush()", "full_signature": "private void doFlush()", "class_method_signature": "BucketWriter.doFlush()", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(final Event event)", "modifiers": "public synchronized", "return": "void", "signature": "void append(final Event event)", "full_signature": "public synchronized void append(final Event event)", "class_method_signature": "BucketWriter.append(final Event event)", "testcase": false, "constructor": false}, {"identifier": "shouldRotate", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean shouldRotate()", "full_signature": "private boolean shouldRotate()", "class_method_signature": "BucketWriter.shouldRotate()", "testcase": false, "constructor": false}, {"identifier": "renameBucket", "parameters": "(String bucketPath, String targetPath, final FileSystem fs)", "modifiers": "private", "return": "void", "signature": "void renameBucket(String bucketPath, String targetPath, final FileSystem fs)", "full_signature": "private void renameBucket(String bucketPath, String targetPath, final FileSystem fs)", "class_method_signature": "BucketWriter.renameBucket(String bucketPath, String targetPath, final FileSystem fs)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "BucketWriter.toString()", "testcase": false, "constructor": false}, {"identifier": "isBatchComplete", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean isBatchComplete()", "full_signature": "private boolean isBatchComplete()", "class_method_signature": "BucketWriter.isBatchComplete()", "testcase": false, "constructor": false}, {"identifier": "checkAndThrowInterruptedException", "parameters": "()", "modifiers": "private static", "return": "void", "signature": "void checkAndThrowInterruptedException()", "full_signature": "private static void checkAndThrowInterruptedException()", "class_method_signature": "BucketWriter.checkAndThrowInterruptedException()", "testcase": false, "constructor": false}, {"identifier": "callWithTimeout", "parameters": "(final CallRunner<T> callRunner)", "modifiers": "private", "return": "T", "signature": "T callWithTimeout(final CallRunner<T> callRunner)", "full_signature": "private T callWithTimeout(final CallRunner<T> callRunner)", "class_method_signature": "BucketWriter.callWithTimeout(final CallRunner<T> callRunner)", "testcase": false, "constructor": false}], "file": "flume-ng-sinks/flume-hdfs-sink/src/main/java/org/apache/flume/sink/hdfs/BucketWriter.java"}, "focal_method": {"identifier": "append", "parameters": "(final Event event)", "modifiers": "public synchronized", "return": "void", "body": "public synchronized void append(final Event event)\n          throws IOException, InterruptedException {\n    checkAndThrowInterruptedException();\n    // If idleFuture is not null, cancel it before we move forward to avoid a\n    // close call in the middle of the append.\n    if (idleFuture != null) {\n      idleFuture.cancel(false);\n      // There is still a small race condition - if the idleFuture is already\n      // running, interrupting it can cause HDFS close operation to throw -\n      // so we cannot interrupt it while running. If the future could not be\n      // cancelled, it is already running - wait for it to finish before\n      // attempting to write.\n      if (!idleFuture.isDone()) {\n        try {\n          idleFuture.get(callTimeout, TimeUnit.MILLISECONDS);\n        } catch (TimeoutException ex) {\n          LOG.warn(\"Timeout while trying to cancel closing of idle file. Idle\" +\n                   \" file close may have failed\", ex);\n        } catch (Exception ex) {\n          LOG.warn(\"Error while trying to cancel closing of idle file. \", ex);\n        }\n      }\n      idleFuture = null;\n    }\n\n    // If the bucket writer was closed due to roll timeout or idle timeout,\n    // force a new bucket writer to be created. Roll count and roll size will\n    // just reuse this one\n    if (!isOpen) {\n      if (closed.get()) {\n        throw new BucketClosedException(\"This bucket writer was closed and \" +\n          \"this handle is thus no longer valid\");\n      }\n      open();\n    }\n\n    // check if it's time to rotate the file\n    if (shouldRotate()) {\n      boolean doRotate = true;\n\n      if (isUnderReplicated) {\n        if (maxConsecUnderReplRotations > 0 &&\n            consecutiveUnderReplRotateCount >= maxConsecUnderReplRotations) {\n          doRotate = false;\n          if (consecutiveUnderReplRotateCount == maxConsecUnderReplRotations) {\n            LOG.error(\"Hit max consecutive under-replication rotations ({}); \" +\n                \"will not continue rolling files under this path due to \" +\n                \"under-replication\", maxConsecUnderReplRotations);\n          }\n        } else {\n          LOG.warn(\"Block Under-replication detected. Rotating file.\");\n        }\n        consecutiveUnderReplRotateCount++;\n      } else {\n        consecutiveUnderReplRotateCount = 0;\n      }\n\n      if (doRotate) {\n        close();\n        open();\n      }\n    }\n\n    // write the event\n    try {\n      sinkCounter.incrementEventDrainAttemptCount();\n      callWithTimeout(new CallRunner<Void>() {\n        @Override\n        public Void call() throws Exception {\n          writer.append(event); // could block\n          return null;\n        }\n      });\n    } catch (IOException e) {\n      LOG.warn(\"Caught IOException writing to HDFSWriter ({}). Closing file (\" +\n          bucketPath + \") and rethrowing exception.\",\n          e.getMessage());\n      close(true);\n      throw e;\n    }\n\n    // update statistics\n    processSize += event.getBody().length;\n    eventCounter++;\n    batchCounter++;\n\n    if (batchCounter == batchSize) {\n      flush();\n    }\n  }", "signature": "void append(final Event event)", "full_signature": "public synchronized void append(final Event event)", "class_method_signature": "BucketWriter.append(final Event event)", "testcase": false, "constructor": false, "invocations": ["checkAndThrowInterruptedException", "cancel", "isDone", "get", "warn", "warn", "get", "open", "shouldRotate", "error", "warn", "close", "open", "incrementEventDrainAttemptCount", "callWithTimeout", "append", "warn", "getMessage", "close", "getBody", "flush"]}, "repository": {"repo_id": 2198510, "url": "https://github.com/apache/flume", "language": "Java", "is_fork": false, "fork_count": 1372, "stargazer_count": 1971, "size": 44377, "license": "licensed"}}