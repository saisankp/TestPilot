{"test_class": {"identifier": "LogicTransformerTest", "superclass": "extends DroolsTestCase", "interfaces": "", "fields": [], "file": "drools-core/src/test/java/org/drools/core/rule/LogicTransformerTest.java"}, "test_case": {"identifier": "testProcessTree", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testProcessTree() throws IOException,\n                                 ClassNotFoundException,\n                                 InvalidPatternException {\n        final ObjectType type = new ClassObjectType( String.class );\n        final Pattern a = new Pattern( 0,\n                                     type,\n                                     \"a\" );\n        final Pattern b = new Pattern( 1,\n                                     type,\n                                     \"b\" );\n        final Pattern c = new Pattern( 2,\n                                     type,\n                                     \"c\" );\n        final Pattern d = new Pattern( 3,\n                                     type,\n                                     \"d\" );\n        final Pattern e = new Pattern( 4,\n                                     type,\n                                     \"e\" );\n        final Pattern g = new Pattern( 5,\n                                     type,\n                                     \"g\" );\n        final Pattern h = new Pattern( 6,\n                                     type,\n                                     \"h\" );\n        final Pattern i = new Pattern( 7,\n                                     type,\n                                     \"i\" );\n\n        final GroupElement and1 = GroupElementFactory.newAndInstance();\n        final GroupElement and2 = GroupElementFactory.newAndInstance();\n        and1.addChild( a );\n        and1.addChild( and2 );\n        and2.addChild( b );\n        final GroupElement not1 = GroupElementFactory.newNotInstance();\n        final GroupElement not2 = GroupElementFactory.newNotInstance();\n        not1.addChild( not2 );\n        not2.addChild( c );\n        and2.addChild( not1 );\n        and1.addChild( d );\n\n        final GroupElement and3 = GroupElementFactory.newAndInstance();\n        and3.addChild( e );\n        final GroupElement or1 = GroupElementFactory.newOrInstance();\n        and3.addChild( or1 );\n        final GroupElement exist1 = GroupElementFactory.newExistsInstance();\n        exist1.addChild( g );\n        or1.addChild( h );\n        or1.addChild( exist1 );\n\n        final GroupElement not3 = GroupElementFactory.newNotInstance();\n        not3.addChild( i );\n\n        final GroupElement root = GroupElementFactory.newAndInstance();\n        root.addChild( and1 );\n        root.addChild( and3 );\n        root.addChild( not3 );\n\n        final GroupElement[] result = LogicTransformer.getInstance().transform( root, Collections.EMPTY_MAP );\n\n        // ----------------------------------------------------------------------------------\n        // Now construct the result tree so we can test root against what it\n        // should look like\n        // ----------------------------------------------------------------------------------\n\n        // Get known correct tree\n        // The binary stream was created from a handchecked correct output\n\n        // Uncomment this when you need to output a new known correct tree\n        // result\n        final File testFile = new File(\"target/test/LogicTransformerTest_correct_processTree1.dat\");\n        testFile.getParentFile().mkdirs();\n        DroolsStreamUtils.streamOut(new FileOutputStream(testFile), result);\n        final GroupElement[] correctResultRoot =\n                (GroupElement[]) DroolsStreamUtils.streamIn(new FileInputStream(testFile));\n\n        // Make sure they are equal\n        for ( int j = 0; j < correctResultRoot.length; j++ ) {\n            assertEquals( correctResultRoot[j],\n                          result[j] );\n        }\n    }", "signature": "void testProcessTree()", "full_signature": "@Test public void testProcessTree()", "class_method_signature": "LogicTransformerTest.testProcessTree()", "testcase": true, "constructor": false, "invocations": ["newAndInstance", "newAndInstance", "addChild", "addChild", "addChild", "newNotInstance", "newNotInstance", "addChild", "addChild", "addChild", "addChild", "newAndInstance", "addChild", "newOrInstance", "addChild", "newExistsInstance", "addChild", "addChild", "addChild", "newNotInstance", "addChild", "newAndInstance", "addChild", "addChild", "addChild", "transform", "getInstance", "mkdirs", "getParentFile", "streamOut", "streamIn", "assertEquals"]}, "focal_class": {"identifier": "LogicTransformer", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Map<GroupElement.Type, Transformation> orTransformations = new HashMap<GroupElement.Type, Transformation>();", "modifier": "private final", "type": "Map<GroupElement.Type, Transformation>", "declarator": "orTransformations = new HashMap<GroupElement.Type, Transformation>()", "var_name": "orTransformations"}, {"original_string": "private static LogicTransformer INSTANCE          = new LogicTransformer();", "modifier": "private static", "type": "LogicTransformer", "declarator": "INSTANCE          = new LogicTransformer()", "var_name": "INSTANCE"}], "methods": [{"identifier": "getInstance", "parameters": "()", "modifiers": "public static", "return": "LogicTransformer", "signature": "LogicTransformer getInstance()", "full_signature": "public static LogicTransformer getInstance()", "class_method_signature": "LogicTransformer.getInstance()", "testcase": false, "constructor": false}, {"identifier": "LogicTransformer", "parameters": "()", "modifiers": "protected", "return": "", "signature": " LogicTransformer()", "full_signature": "protected  LogicTransformer()", "class_method_signature": "LogicTransformer.LogicTransformer()", "testcase": false, "constructor": true}, {"identifier": "initialize", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void initialize()", "full_signature": "private void initialize()", "class_method_signature": "LogicTransformer.initialize()", "testcase": false, "constructor": false}, {"identifier": "addTransformationPair", "parameters": "(final GroupElement.Type parent,\n                                       final Transformation method)", "modifiers": "private", "return": "void", "signature": "void addTransformationPair(final GroupElement.Type parent,\n                                       final Transformation method)", "full_signature": "private void addTransformationPair(final GroupElement.Type parent,\n                                       final Transformation method)", "class_method_signature": "LogicTransformer.addTransformationPair(final GroupElement.Type parent,\n                                       final Transformation method)", "testcase": false, "constructor": false}, {"identifier": "transform", "parameters": "( final GroupElement cloned, Map<String, Class<?>> globals )", "modifiers": "public", "return": "GroupElement[]", "signature": "GroupElement[] transform( final GroupElement cloned, Map<String, Class<?>> globals )", "full_signature": "public GroupElement[] transform( final GroupElement cloned, Map<String, Class<?>> globals )", "class_method_signature": "LogicTransformer.transform( final GroupElement cloned, Map<String, Class<?>> globals )", "testcase": false, "constructor": false}, {"identifier": "processNamedConsequences", "parameters": "(GroupElement[] ands)", "modifiers": "private", "return": "GroupElement[]", "signature": "GroupElement[] processNamedConsequences(GroupElement[] ands)", "full_signature": "private GroupElement[] processNamedConsequences(GroupElement[] ands)", "class_method_signature": "LogicTransformer.processNamedConsequences(GroupElement[] ands)", "testcase": false, "constructor": false}, {"identifier": "splitOr", "parameters": "( final GroupElement cloned )", "modifiers": "protected", "return": "GroupElement[]", "signature": "GroupElement[] splitOr( final GroupElement cloned )", "full_signature": "protected GroupElement[] splitOr( final GroupElement cloned )", "class_method_signature": "LogicTransformer.splitOr( final GroupElement cloned )", "testcase": false, "constructor": false}, {"identifier": "fixClonedDeclarations", "parameters": "( GroupElement and, Map<String, Class<?>> globals )", "modifiers": "protected", "return": "void", "signature": "void fixClonedDeclarations( GroupElement and, Map<String, Class<?>> globals )", "full_signature": "protected void fixClonedDeclarations( GroupElement and, Map<String, Class<?>> globals )", "class_method_signature": "LogicTransformer.fixClonedDeclarations( GroupElement and, Map<String, Class<?>> globals )", "testcase": false, "constructor": false}, {"identifier": "processElement", "parameters": "(final DeclarationScopeResolver resolver,\n                                final Stack<RuleConditionElement> contextStack,\n                                final RuleConditionElement element)", "modifiers": "private", "return": "void", "signature": "void processElement(final DeclarationScopeResolver resolver,\n                                final Stack<RuleConditionElement> contextStack,\n                                final RuleConditionElement element)", "full_signature": "private void processElement(final DeclarationScopeResolver resolver,\n                                final Stack<RuleConditionElement> contextStack,\n                                final RuleConditionElement element)", "class_method_signature": "LogicTransformer.processElement(final DeclarationScopeResolver resolver,\n                                final Stack<RuleConditionElement> contextStack,\n                                final RuleConditionElement element)", "testcase": false, "constructor": false}, {"identifier": "replaceDeclarations", "parameters": "( DeclarationScopeResolver resolver, Pattern pattern, Constraint constraint )", "modifiers": "private", "return": "void", "signature": "void replaceDeclarations( DeclarationScopeResolver resolver, Pattern pattern, Constraint constraint )", "full_signature": "private void replaceDeclarations( DeclarationScopeResolver resolver, Pattern pattern, Constraint constraint )", "class_method_signature": "LogicTransformer.replaceDeclarations( DeclarationScopeResolver resolver, Pattern pattern, Constraint constraint )", "testcase": false, "constructor": false}, {"identifier": "replaceDeclarations", "parameters": "( DeclarationScopeResolver resolver, Accumulate accumulate )", "modifiers": "private", "return": "void", "signature": "void replaceDeclarations( DeclarationScopeResolver resolver, Accumulate accumulate )", "full_signature": "private void replaceDeclarations( DeclarationScopeResolver resolver, Accumulate accumulate )", "class_method_signature": "LogicTransformer.replaceDeclarations( DeclarationScopeResolver resolver, Accumulate accumulate )", "testcase": false, "constructor": false}, {"identifier": "asList", "parameters": "(int[] ints)", "modifiers": "private static", "return": "List<Integer>", "signature": "List<Integer> asList(int[] ints)", "full_signature": "private static List<Integer> asList(int[] ints)", "class_method_signature": "LogicTransformer.asList(int[] ints)", "testcase": false, "constructor": false}, {"identifier": "toIntArray", "parameters": "(List<Integer> list)", "modifiers": "public static", "return": "int[]", "signature": "int[] toIntArray(List<Integer> list)", "full_signature": "public static int[] toIntArray(List<Integer> list)", "class_method_signature": "LogicTransformer.toIntArray(List<Integer> list)", "testcase": false, "constructor": false}, {"identifier": "processEvalCondition", "parameters": "(DeclarationScopeResolver resolver, EvalCondition element)", "modifiers": "private", "return": "void", "signature": "void processEvalCondition(DeclarationScopeResolver resolver, EvalCondition element)", "full_signature": "private void processEvalCondition(DeclarationScopeResolver resolver, EvalCondition element)", "class_method_signature": "LogicTransformer.processEvalCondition(DeclarationScopeResolver resolver, EvalCondition element)", "testcase": false, "constructor": false}, {"identifier": "processBranch", "parameters": "(DeclarationScopeResolver resolver, ConditionalBranch branch)", "modifiers": "private", "return": "void", "signature": "void processBranch(DeclarationScopeResolver resolver, ConditionalBranch branch)", "full_signature": "private void processBranch(DeclarationScopeResolver resolver, ConditionalBranch branch)", "class_method_signature": "LogicTransformer.processBranch(DeclarationScopeResolver resolver, ConditionalBranch branch)", "testcase": false, "constructor": false}, {"identifier": "processTree", "parameters": "(final GroupElement ce)", "modifiers": "protected", "return": "boolean", "signature": "boolean processTree(final GroupElement ce)", "full_signature": "protected boolean processTree(final GroupElement ce)", "class_method_signature": "LogicTransformer.processTree(final GroupElement ce)", "testcase": false, "constructor": false}, {"identifier": "processTree", "parameters": "(final GroupElement ce, boolean[] result)", "modifiers": "private", "return": "void", "signature": "void processTree(final GroupElement ce, boolean[] result)", "full_signature": "private void processTree(final GroupElement ce, boolean[] result)", "class_method_signature": "LogicTransformer.processTree(final GroupElement ce, boolean[] result)", "testcase": false, "constructor": false}, {"identifier": "applyOrTransformation", "parameters": "(final GroupElement parent)", "modifiers": "", "return": "void", "signature": "void applyOrTransformation(final GroupElement parent)", "full_signature": " void applyOrTransformation(final GroupElement parent)", "class_method_signature": "LogicTransformer.applyOrTransformation(final GroupElement parent)", "testcase": false, "constructor": false}], "file": "drools-core/src/main/java/org/drools/core/rule/LogicTransformer.java"}, "focal_method": {"identifier": "processTree", "parameters": "(final GroupElement ce)", "modifiers": "protected", "return": "boolean", "body": "protected boolean processTree(final GroupElement ce) throws InvalidPatternException {\n        boolean[] hasNamedConsequenceAndIsStream = new boolean[2];\n        processTree(ce, hasNamedConsequenceAndIsStream);\n        return hasNamedConsequenceAndIsStream[0] && hasNamedConsequenceAndIsStream[1];\n    }", "signature": "boolean processTree(final GroupElement ce)", "full_signature": "protected boolean processTree(final GroupElement ce)", "class_method_signature": "LogicTransformer.processTree(final GroupElement ce)", "testcase": false, "constructor": false, "invocations": ["processTree"]}, "repository": {"repo_id": 1381673, "url": "https://github.com/kiegroup/drools", "stars": 2733, "created": "2/18/2011 8:37:05 AM +00:00", "updates": "2020-01-27T13:12:15+00:00", "fork": "False", "license": "licensed"}}