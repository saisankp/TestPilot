{"test_class": {"identifier": "InformationContentComputationTest", "superclass": "extends VegetableOntologyTestBase", "interfaces": "", "fields": [{"original_string": "private final InformationContentComputation computation = new InformationContentComputation(ontology);", "modifier": "private final", "type": "InformationContentComputation", "declarator": "computation = new InformationContentComputation(ontology)", "var_name": "computation"}], "file": "phenol-core/src/test/java/org/monarchinitiative/phenol/ontology/algo/InformationContentComputationTest.java"}, "test_case": {"identifier": "test", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n  void test() {\n    Map<TermId, Collection<TermId>> termLabels = TermAnnotations.constructTermAnnotationToLabelsMap(ontology, recipeAnnotations);\n    Map<TermId, Double> informationContent = computation.computeInformationContent(termLabels);\n\n    assertEquals(7, informationContent.size());\n\n    assertEquals(0.0, informationContent.get(idVegetable), 0.001);\n    assertEquals(0.0, informationContent.get(idRootVegetable), 0.001);\n    assertEquals(0.405, informationContent.get(idLeafVegetable), 0.001);\n    assertEquals(0.405, informationContent.get(idCarrot), 0.001);\n    assertEquals(0.405, informationContent.get(idBeet), 0.001);\n    assertEquals(0.405, informationContent.get(idPumpkin), 0.001);\n    assertEquals(1.099, informationContent.get(idBlueCarrot), 0.01);\n  }", "signature": "void test()", "full_signature": "@Test void test()", "class_method_signature": "InformationContentComputationTest.test()", "testcase": true, "constructor": false, "invocations": ["constructTermAnnotationToLabelsMap", "computeInformationContent", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "InformationContentComputation", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(InformationContentComputation.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(InformationContentComputation.class)", "var_name": "LOGGER"}, {"original_string": "private final Ontology ontology;", "modifier": "private final", "type": "Ontology", "declarator": "ontology", "var_name": "ontology"}], "methods": [{"identifier": "InformationContentComputation", "parameters": "(Ontology ontology)", "modifiers": "public", "return": "", "signature": " InformationContentComputation(Ontology ontology)", "full_signature": "public  InformationContentComputation(Ontology ontology)", "class_method_signature": "InformationContentComputation.InformationContentComputation(Ontology ontology)", "testcase": false, "constructor": true}, {"identifier": "computeInformationContent", "parameters": "(Map<TermId, Collection<TermId>> termLabels)", "modifiers": "public", "return": "Map<TermId, Double>", "signature": "Map<TermId, Double> computeInformationContent(Map<TermId, Collection<TermId>> termLabels)", "full_signature": "public Map<TermId, Double> computeInformationContent(Map<TermId, Collection<TermId>> termLabels)", "class_method_signature": "InformationContentComputation.computeInformationContent(Map<TermId, Collection<TermId>> termLabels)", "testcase": false, "constructor": false}, {"identifier": "caculateInformationContent", "parameters": "(double maxFreq, Map<TermId, Integer> termToFrequency)", "modifiers": "private", "return": "Map<TermId, Double>", "signature": "Map<TermId, Double> caculateInformationContent(double maxFreq, Map<TermId, Integer> termToFrequency)", "full_signature": "private Map<TermId, Double> caculateInformationContent(double maxFreq, Map<TermId, Integer> termToFrequency)", "class_method_signature": "InformationContentComputation.caculateInformationContent(double maxFreq, Map<TermId, Integer> termToFrequency)", "testcase": false, "constructor": false}, {"identifier": "mostInformativeCommonAncestor", "parameters": "(TermId t1, TermId t2, Ontology ontology, Map<TermId, Double> term2ic)", "modifiers": "public static", "return": "TermId", "signature": "TermId mostInformativeCommonAncestor(TermId t1, TermId t2, Ontology ontology, Map<TermId, Double> term2ic)", "full_signature": "public static TermId mostInformativeCommonAncestor(TermId t1, TermId t2, Ontology ontology, Map<TermId, Double> term2ic)", "class_method_signature": "InformationContentComputation.mostInformativeCommonAncestor(TermId t1, TermId t2, Ontology ontology, Map<TermId, Double> term2ic)", "testcase": false, "constructor": false}], "file": "phenol-core/src/main/java/org/monarchinitiative/phenol/ontology/algo/InformationContentComputation.java"}, "focal_method": {"identifier": "computeInformationContent", "parameters": "(Map<TermId, Collection<TermId>> termLabels)", "modifiers": "public", "return": "Map<TermId, Double>", "body": "public Map<TermId, Double> computeInformationContent(Map<TermId, Collection<TermId>> termLabels) {\n    LOGGER.info(\n        \"Computing IC of {} terms using {} labels...\",\n            ontology.countAllTerms(), termLabels.values().stream().mapToInt(Collection::size).sum()\n        );\n\n    // Build mapping from TermId -> absolute frequency\n    // Ought to use ontology.getRootTermId() ?\n    final TermId root = ontology.getRootTermId();//TermId.of(\"HP:0000118\");\n\n    final Map<TermId, Integer> termToFrequency = new HashMap<>();\n    for (TermId termId : ontology.getNonObsoleteTermIds()) {\n      termToFrequency.put(termId, 0);\n    }\n    for (Entry<TermId, Collection<TermId>> e : termLabels.entrySet()) {\n      termToFrequency.put(e.getKey(), e.getValue().size());\n    }\n\n    // Compute information content for each TermId\n    final int maxFreq = termToFrequency.get(root);\n    final Map<TermId, Double> termToInformationContent = caculateInformationContent(maxFreq, termToFrequency);\n\n    // Fix terms with IC of zero, set it to IC of root\n    int countIcZero = 0;\n    final double dummyIc = -Math.log(1 / (double) maxFreq);\n\n    for (Term t : ontology.getTerms()) {\n      if (t.isObsolete()) {\n        continue;\n      }\n      if (!termToFrequency.containsKey(t.getId())) {\n        ++countIcZero;\n        termToInformationContent.put(t.getId(), dummyIc);\n      }\n    }\n\n    if (countIcZero > 0) {\n      LOGGER.warn(\n          \"Frequency of {} non-obsolete terms was zero! Their IC has been set to {} =  - log(1 / {}).\", countIcZero, dummyIc, maxFreq);\n    }\n    LOGGER.info(\"Computing IC is complete.\");\n\n    return termToInformationContent;\n  }", "signature": "Map<TermId, Double> computeInformationContent(Map<TermId, Collection<TermId>> termLabels)", "full_signature": "public Map<TermId, Double> computeInformationContent(Map<TermId, Collection<TermId>> termLabels)", "class_method_signature": "InformationContentComputation.computeInformationContent(Map<TermId, Collection<TermId>> termLabels)", "testcase": false, "constructor": false, "invocations": ["info", "countAllTerms", "sum", "mapToInt", "stream", "values", "getRootTermId", "getNonObsoleteTermIds", "put", "entrySet", "put", "getKey", "size", "getValue", "get", "caculateInformationContent", "log", "getTerms", "isObsolete", "containsKey", "getId", "put", "getId", "warn", "info"]}, "repository": {"repo_id": 119170338, "url": "https://github.com/monarch-initiative/phenol", "language": "Java", "is_fork": false, "fork_count": 3, "stargazer_count": 9, "size": 5832, "license": "licensed"}}