{"test_class": {"identifier": "LingoClusteringAlgorithmTest", "superclass": "extends ClusteringAlgorithmTestBase<LingoClusteringAlgorithm>", "interfaces": "", "fields": [], "file": "core/src/test/java/org/carrot2/clustering/lingo/LingoClusteringAlgorithmTest.java"}, "test_case": {"identifier": "testClusteringWithDfThreshold", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testClusteringWithDfThreshold() {\n    LingoClusteringAlgorithm algorithm = algorithm();\n    algorithm.preprocessing.wordDfThreshold.set(100);\n\n    List<Cluster<Document>> clusters =\n        algorithm.cluster(\n            SampleDocumentData.DOCUMENTS_DATA_MINING.stream(),\n            CachedLangComponents.loadCached(\"English\"));\n\n    // Clustering with df threshold must not fail\n    Assertions.assertThat(clusters).isEmpty();\n  }", "signature": "void testClusteringWithDfThreshold()", "full_signature": "@Test public void testClusteringWithDfThreshold()", "class_method_signature": "LingoClusteringAlgorithmTest.testClusteringWithDfThreshold()", "testcase": true, "constructor": false, "invocations": ["algorithm", "set", "cluster", "stream", "loadCached", "isEmpty", "assertThat"]}, "focal_class": {"identifier": "LingoClusteringAlgorithm", "superclass": "extends AttrComposite", "interfaces": "implements ClusteringAlgorithm", "fields": [{"original_string": "public static final String NAME = \"Lingo\";", "modifier": "public static final", "type": "String", "declarator": "NAME = \"Lingo\"", "var_name": "NAME"}, {"original_string": "private static final Set<Class<?>> REQUIRED_LANGUAGE_COMPONENTS =\n      new HashSet<>(\n          Arrays.asList(Stemmer.class, Tokenizer.class, LexicalData.class, LabelFormatter.class));", "modifier": "private static final", "type": "Set<Class<?>>", "declarator": "REQUIRED_LANGUAGE_COMPONENTS =\n      new HashSet<>(\n          Arrays.asList(Stemmer.class, Tokenizer.class, LexicalData.class, LabelFormatter.class))", "var_name": "REQUIRED_LANGUAGE_COMPONENTS"}, {"original_string": "public AttrDouble scoreWeight =\n      attributes.register(\n          \"scoreWeight\",\n          AttrDouble.builder().label(\"Size-score sorting ratio\").min(0).max(1).defaultValue(0.));", "modifier": "public", "type": "AttrDouble", "declarator": "scoreWeight =\n      attributes.register(\n          \"scoreWeight\",\n          AttrDouble.builder().label(\"Size-score sorting ratio\").min(0).max(1).defaultValue(0.))", "var_name": "scoreWeight"}, {"original_string": "public AttrInteger desiredClusterCount =\n      attributes.register(\n          \"desiredClusterCount\",\n          AttrInteger.builder().label(\"Desired cluster count\").min(2).max(100).defaultValue(30));", "modifier": "public", "type": "AttrInteger", "declarator": "desiredClusterCount =\n      attributes.register(\n          \"desiredClusterCount\",\n          AttrInteger.builder().label(\"Desired cluster count\").min(2).max(100).defaultValue(30))", "var_name": "desiredClusterCount"}, {"original_string": "public CompletePreprocessingPipeline preprocessing;", "modifier": "public", "type": "CompletePreprocessingPipeline", "declarator": "preprocessing", "var_name": "preprocessing"}, {"original_string": "public TermDocumentMatrixBuilder matrixBuilder;", "modifier": "public", "type": "TermDocumentMatrixBuilder", "declarator": "matrixBuilder", "var_name": "matrixBuilder"}, {"original_string": "public TermDocumentMatrixReducer matrixReducer;", "modifier": "public", "type": "TermDocumentMatrixReducer", "declarator": "matrixReducer", "var_name": "matrixReducer"}, {"original_string": "public ClusterBuilder clusterBuilder;", "modifier": "public", "type": "ClusterBuilder", "declarator": "clusterBuilder", "var_name": "clusterBuilder"}, {"original_string": "public final AttrString queryHint =\n      attributes.register(\"queryHint\", SharedInfrastructure.queryHintAttribute());", "modifier": "public final", "type": "AttrString", "declarator": "queryHint =\n      attributes.register(\"queryHint\", SharedInfrastructure.queryHintAttribute())", "var_name": "queryHint"}], "methods": [{"identifier": "requiredLanguageComponents", "parameters": "()", "modifiers": "@Override public", "return": "Set<Class<?>>", "signature": "Set<Class<?>> requiredLanguageComponents()", "full_signature": "@Override public Set<Class<?>> requiredLanguageComponents()", "class_method_signature": "LingoClusteringAlgorithm.requiredLanguageComponents()", "testcase": false, "constructor": false}, {"identifier": "cluster", "parameters": "(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "modifiers": "@Override public", "return": "List<Cluster<T>>", "signature": "List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "full_signature": "@Override public List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "class_method_signature": "LingoClusteringAlgorithm.cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "testcase": false, "constructor": false}, {"identifier": "computeClusterCount", "parameters": "(int desiredClusterCountBase, int documentCount)", "modifiers": "static", "return": "int", "signature": "int computeClusterCount(int desiredClusterCountBase, int documentCount)", "full_signature": "static int computeClusterCount(int desiredClusterCountBase, int documentCount)", "class_method_signature": "LingoClusteringAlgorithm.computeClusterCount(int desiredClusterCountBase, int documentCount)", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/carrot2/clustering/lingo/LingoClusteringAlgorithm.java"}, "focal_method": {"identifier": "cluster", "parameters": "(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "modifiers": "@Override public", "return": "List<Cluster<T>>", "body": "@Override\n  public <T extends Document> List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents) {\n    List<T> documents = docStream.collect(Collectors.toList());\n\n    // Preprocessing of documents\n    final PreprocessingContext context =\n        preprocessing.preprocess(documents.stream(), queryHint.get(), languageComponents);\n\n    // Further processing only if there are words to process\n    List<Cluster<T>> clusters = new ArrayList<>();\n    if (context.hasLabels()) {\n      // Term-document matrix building and reduction\n      final VectorSpaceModelContext vsmContext = new VectorSpaceModelContext(context);\n      final ReducedVectorSpaceModelContext reducedVsmContext =\n          new ReducedVectorSpaceModelContext(vsmContext);\n      LingoProcessingContext lingoContext = new LingoProcessingContext(reducedVsmContext);\n\n      TermDocumentMatrixBuilder matrixBuilder = this.matrixBuilder;\n      matrixBuilder.buildTermDocumentMatrix(vsmContext);\n      matrixBuilder.buildTermPhraseMatrix(vsmContext);\n\n      matrixReducer.reduce(\n          reducedVsmContext, computeClusterCount(desiredClusterCount.get(), documents.size()));\n\n      // Cluster label building\n      clusterBuilder.buildLabels(lingoContext, matrixBuilder.termWeighting);\n\n      // Document assignment\n      clusterBuilder.assignDocuments(lingoContext);\n\n      // Cluster merging\n      clusterBuilder.merge(lingoContext);\n\n      // Format final clusters\n      final LabelFormatter labelFormatter =\n          lingoContext.preprocessingContext.languageComponents.get(LabelFormatter.class);\n\n      final int[] clusterLabelIndex = lingoContext.clusterLabelFeatureIndex;\n      final BitSet[] clusterDocuments = lingoContext.clusterDocuments;\n      final double[] clusterLabelScore = lingoContext.clusterLabelScore;\n      for (int i = 0; i < clusterLabelIndex.length; i++) {\n        final Cluster<T> cluster = new Cluster<>();\n\n        final int labelFeature = clusterLabelIndex[i];\n        if (labelFeature < 0) {\n          // Cluster removed during merging\n          continue;\n        }\n\n        // Add label and score\n        cluster.addLabel(context.format(labelFormatter, labelFeature));\n        cluster.setScore(clusterLabelScore[i]);\n\n        // Add documents\n        final BitSet bs = clusterDocuments[i];\n        for (int bit = bs.nextSetBit(0); bit >= 0; bit = bs.nextSetBit(bit + 1)) {\n          cluster.addDocument(documents.get(bit));\n        }\n\n        // Add cluster\n        clusters.add(cluster);\n      }\n    }\n\n    clusters = SharedInfrastructure.reorderByWeightedScoreAndSize(clusters, this.scoreWeight.get());\n    return clusters;\n  }", "signature": "List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "full_signature": "@Override public List<Cluster<T>> cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "class_method_signature": "LingoClusteringAlgorithm.cluster(\n      Stream<? extends T> docStream, LanguageComponents languageComponents)", "testcase": false, "constructor": false, "invocations": ["collect", "toList", "preprocess", "stream", "get", "hasLabels", "buildTermDocumentMatrix", "buildTermPhraseMatrix", "reduce", "computeClusterCount", "get", "size", "buildLabels", "assignDocuments", "merge", "get", "addLabel", "format", "setScore", "nextSetBit", "nextSetBit", "addDocument", "get", "add", "reorderByWeightedScoreAndSize", "get"]}, "repository": {"repo_id": 2424377, "url": "https://github.com/carrot2/carrot2", "stars": 393, "created": "9/20/2011 6:19:05 PM +00:00", "updates": "2020-01-24T20:43:38+00:00", "fork": "False", "license": "licensed"}}