{"test_class": {"identifier": "IpcSenderServiceTest", "superclass": "", "interfaces": "", "fields": [], "file": "core/src/test/java/com/nextdoor/bender/ipc/IpcSenderServiceTest.java"}, "test_case": {"identifier": "testThreadExceptionDuringAdd", "parameters": "()", "modifiers": "@Test(expected = TransportException.class) public", "return": "void", "body": "@Test(expected = TransportException.class)\n  public void testThreadExceptionDuringAdd() throws TransportException, InterruptedException {\n    DummyTransporter mockDummyTransporter = mock(DummyTransporter.class);\n    DummyTransporterFactory tfactory = new DummyTransporterFactory();\n    tfactory.transporter = mockDummyTransporter;\n\n    doThrow(new TransportException(\"expected exception in test\")).when(mockDummyTransporter)\n            .sendBatch(any(DummyTransportBuffer.class));\n\n    IpcSenderService ipc = new IpcSenderService(tfactory);\n    // add 5 events to fill up the buffer so the next will result in a sendBatch()\n    for (int i = 0; i < 5; i++) {\n      ipc.add(mock(InternalEvent.class));\n    }\n\n    // this will trigger the sendBatch exception above\n    ipc.add(mock(InternalEvent.class));\n\n    Thread.sleep(5); // lets thread from last event complete and throw exception\n    ipc.add(mock(InternalEvent.class)); // add() checks at start for any threads that threw exceptions\n  }", "signature": "void testThreadExceptionDuringAdd()", "full_signature": "@Test(expected = TransportException.class) public void testThreadExceptionDuringAdd()", "class_method_signature": "IpcSenderServiceTest.testThreadExceptionDuringAdd()", "testcase": true, "constructor": false, "invocations": ["mock", "sendBatch", "when", "doThrow", "any", "add", "mock", "add", "mock", "sleep", "add", "mock"]}, "focal_class": {"identifier": "IpcSenderService", "superclass": "extends MonitoredProcess", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = Logger.getLogger(IpcSenderService.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = Logger.getLogger(IpcSenderService.class)", "var_name": "logger"}, {"original_string": "private final ExecutorService pool;", "modifier": "private final", "type": "ExecutorService", "declarator": "pool", "var_name": "pool"}, {"original_string": "private TransportFactory transportFactory;", "modifier": "private", "type": "TransportFactory", "declarator": "transportFactory", "var_name": "transportFactory"}, {"original_string": "private Context context;", "modifier": "private", "type": "Context", "declarator": "context", "var_name": "context"}, {"original_string": "protected AtomicInteger threadCounter = new AtomicInteger(0);", "modifier": "protected", "type": "AtomicInteger", "declarator": "threadCounter = new AtomicInteger(0)", "var_name": "threadCounter"}, {"original_string": "protected AtomicBoolean hasUnrecoverableException = new AtomicBoolean(false);", "modifier": "protected", "type": "AtomicBoolean", "declarator": "hasUnrecoverableException = new AtomicBoolean(false)", "var_name": "hasUnrecoverableException"}, {"original_string": "public final Map<LinkedHashMap<String, String>, TransportBuffer> buffers;", "modifier": "public final", "type": "Map<LinkedHashMap<String, String>, TransportBuffer>", "declarator": "buffers", "var_name": "buffers"}], "methods": [{"identifier": "IpcSenderService", "parameters": "(TransportFactory factory)", "modifiers": "public", "return": "", "signature": " IpcSenderService(TransportFactory factory)", "full_signature": "public  IpcSenderService(TransportFactory factory)", "class_method_signature": "IpcSenderService.IpcSenderService(TransportFactory factory)", "testcase": false, "constructor": true}, {"identifier": "add", "parameters": "(InternalEvent ievent)", "modifiers": "synchronized public", "return": "void", "signature": "void add(InternalEvent ievent)", "full_signature": "synchronized public void add(InternalEvent ievent)", "class_method_signature": "IpcSenderService.add(InternalEvent ievent)", "testcase": false, "constructor": false}, {"identifier": "send", "parameters": "(TransportBuffer buffer, LinkedHashMap<String, String> partitions)", "modifiers": "private", "return": "void", "signature": "void send(TransportBuffer buffer, LinkedHashMap<String, String> partitions)", "full_signature": "private void send(TransportBuffer buffer, LinkedHashMap<String, String> partitions)", "class_method_signature": "IpcSenderService.send(TransportBuffer buffer, LinkedHashMap<String, String> partitions)", "testcase": false, "constructor": false}, {"identifier": "flush", "parameters": "()", "modifiers": "synchronized public", "return": "void", "signature": "void flush()", "full_signature": "synchronized public void flush()", "class_method_signature": "IpcSenderService.flush()", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "synchronized public", "return": "void", "signature": "void shutdown()", "full_signature": "synchronized public void shutdown()", "class_method_signature": "IpcSenderService.shutdown()", "testcase": false, "constructor": false}, {"identifier": "hasUnrecoverableException", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean hasUnrecoverableException()", "full_signature": "public boolean hasUnrecoverableException()", "class_method_signature": "IpcSenderService.hasUnrecoverableException()", "testcase": false, "constructor": false}, {"identifier": "setHasUnrecoverableException", "parameters": "(boolean has)", "modifiers": "public", "return": "void", "signature": "void setHasUnrecoverableException(boolean has)", "full_signature": "public void setHasUnrecoverableException(boolean has)", "class_method_signature": "IpcSenderService.setHasUnrecoverableException(boolean has)", "testcase": false, "constructor": false}, {"identifier": "getTransportFactory", "parameters": "()", "modifiers": "public", "return": "TransportFactory", "signature": "TransportFactory getTransportFactory()", "full_signature": "public TransportFactory getTransportFactory()", "class_method_signature": "IpcSenderService.getTransportFactory()", "testcase": false, "constructor": false}, {"identifier": "setTransportFactory", "parameters": "(TransportFactory transportFactory)", "modifiers": "public", "return": "void", "signature": "void setTransportFactory(TransportFactory transportFactory)", "full_signature": "public void setTransportFactory(TransportFactory transportFactory)", "class_method_signature": "IpcSenderService.setTransportFactory(TransportFactory transportFactory)", "testcase": false, "constructor": false}, {"identifier": "getContext", "parameters": "()", "modifiers": "public", "return": "Context", "signature": "Context getContext()", "full_signature": "public Context getContext()", "class_method_signature": "IpcSenderService.getContext()", "testcase": false, "constructor": false}, {"identifier": "setContext", "parameters": "(Context context)", "modifiers": "public", "return": "void", "signature": "void setContext(Context context)", "full_signature": "public void setContext(Context context)", "class_method_signature": "IpcSenderService.setContext(Context context)", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/nextdoor/bender/ipc/IpcSenderService.java"}, "focal_method": {"identifier": "add", "parameters": "(InternalEvent ievent)", "modifiers": "synchronized public", "return": "void", "body": "synchronized public void add(InternalEvent ievent) throws TransportException {\n    // Since threads are running concurrently, we need to check this proactively.\n    // Even though handler just logs the exception, we're able to avoid starting new\n    // multi part uploads and let the handler error out faster so it can re-try the payload.\n    // We leave the value as is so it can be used during flush() to throw an exception.\n    if (this.hasUnrecoverableException.get()) {\n      // TODO: confirm for the s3 case that clients will need a lifecycle policy\n      //  that aborts incomplete uploads within a timeframe.\n      throw new TransportException(\"TransportThread was unsuccessful when adding an event.\");\n    }\n\n    /*\n     * Get appropriate buffer for the event's partition values\n     */\n    LinkedHashMap<String, String> partitions = ievent.getPartitions();\n\n    // TODO: not sure why I made buffers synchronized\n    synchronized (buffers) {\n      if (partitions == null) {\n        partitions = new LinkedHashMap<String, String>(0);\n      }\n\n      if (!this.buffers.containsKey(partitions)) {\n        partitions = new LinkedHashMap<String, String>(partitions);\n        this.buffers.put(partitions, this.transportFactory.newTransportBuffer());\n      }\n\n      TransportBuffer buffer = this.buffers.get(partitions);\n\n      /*\n       * Attempt to add event. If IllegalStateException occurs the buffer is full and must be\n       * flushed/sent.\n       */\n      try {\n        buffer.add(ievent);\n        return;\n      } catch (IllegalStateException e) {\n        send(buffer, partitions);\n      } catch (IOException e) {\n        throw new TransportException(\"Exception occurred while adding to buffer\", e);\n      }\n\n      /*\n       * Remove buffer associated with the partitions and create a new one.\n       */\n      this.buffers.remove(partitions);\n      buffer = this.transportFactory.newTransportBuffer();\n      partitions = new LinkedHashMap<String, String>(partitions);\n      this.buffers.put(partitions, buffer);\n\n      /*\n       * Finally add the event now that the buffer is empty\n       */\n      try {\n        buffer.add(ievent);\n      } catch (IllegalStateException e) {\n        throw new TransportException(\"Buffer is full despite being newly created\", e);\n      } catch (IOException e) {\n        throw new TransportException(\"Exception ocurred while adding to buffer\", e);\n      }\n    }\n  }", "signature": "void add(InternalEvent ievent)", "full_signature": "synchronized public void add(InternalEvent ievent)", "class_method_signature": "IpcSenderService.add(InternalEvent ievent)", "testcase": false, "constructor": false, "invocations": ["get", "getPartitions", "containsKey", "put", "newTransportBuffer", "get", "add", "send", "remove", "newTransportBuffer", "put", "add"]}, "repository": {"repo_id": 75955378, "url": "https://github.com/Nextdoor/bender", "language": "Java", "is_fork": false, "fork_count": 15, "stargazer_count": 163, "size": 1503, "license": "licensed"}}