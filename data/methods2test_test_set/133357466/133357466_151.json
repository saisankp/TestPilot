{"test_class": {"identifier": "PeerGroupTest", "superclass": "extends TestWithPeerGroup", "interfaces": "", "fields": [{"original_string": "private static final int BLOCK_HEIGHT_GENESIS = 0;", "modifier": "private static final", "type": "int", "declarator": "BLOCK_HEIGHT_GENESIS = 0", "var_name": "BLOCK_HEIGHT_GENESIS"}, {"original_string": "private BlockingQueue<Peer> connectedPeers;", "modifier": "private", "type": "BlockingQueue<Peer>", "declarator": "connectedPeers", "var_name": "connectedPeers"}, {"original_string": "private BlockingQueue<Peer> disconnectedPeers;", "modifier": "private", "type": "BlockingQueue<Peer>", "declarator": "disconnectedPeers", "var_name": "disconnectedPeers"}, {"original_string": "private PeerConnectedEventListener connectedListener = new PeerConnectedEventListener() {\n        @Override\n        public void onPeerConnected(Peer peer, int peerCount) {\n            connectedPeers.add(peer);\n        }\n    };", "modifier": "private", "type": "PeerConnectedEventListener", "declarator": "connectedListener = new PeerConnectedEventListener() {\n        @Override\n        public void onPeerConnected(Peer peer, int peerCount) {\n            connectedPeers.add(peer);\n        }\n    }", "var_name": "connectedListener"}, {"original_string": "private PeerDisconnectedEventListener disconnectedListener = new PeerDisconnectedEventListener() {\n        @Override\n        public void onPeerDisconnected(Peer peer, int peerCount) {\n            disconnectedPeers.add(peer);\n        }\n    };", "modifier": "private", "type": "PeerDisconnectedEventListener", "declarator": "disconnectedListener = new PeerDisconnectedEventListener() {\n        @Override\n        public void onPeerDisconnected(Peer peer, int peerCount) {\n            disconnectedPeers.add(peer);\n        }\n    }", "var_name": "disconnectedListener"}, {"original_string": "private PreMessageReceivedEventListener preMessageReceivedListener;", "modifier": "private", "type": "PreMessageReceivedEventListener", "declarator": "preMessageReceivedListener", "var_name": "preMessageReceivedListener"}, {"original_string": "private Map<Peer, AtomicInteger> peerToMessageCount;", "modifier": "private", "type": "Map<Peer, AtomicInteger>", "declarator": "peerToMessageCount", "var_name": "peerToMessageCount"}], "file": "core/src/test/java/org/ulordj/core/PeerGroupTest.java"}, "test_case": {"identifier": "waitForPeersOfVersion", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void waitForPeersOfVersion() throws Exception {\n        final int baseVer = peerGroup.getMinRequiredProtocolVersion() + 3000;\n        final int newVer = baseVer + 1000;\n\n        ListenableFuture<List<Peer>> future = peerGroup.waitForPeersOfVersion(2, newVer);\n\n        VersionMessage ver1 = new VersionMessage(UNITTEST, 10);\n        ver1.clientVersion = baseVer;\n        ver1.localServices = VersionMessage.NODE_NETWORK;\n        VersionMessage ver2 = new VersionMessage(UNITTEST, 10);\n        ver2.clientVersion = newVer;\n        ver2.localServices = VersionMessage.NODE_NETWORK;\n        peerGroup.start();\n        assertFalse(future.isDone());\n        connectPeer(1, ver1);\n        assertFalse(future.isDone());\n        connectPeer(2, ver2);\n        assertFalse(future.isDone());\n        assertTrue(peerGroup.waitForPeersOfVersion(1, newVer).isDone());   // Immediate completion.\n        connectPeer(3, ver2);\n        future.get();\n        assertTrue(future.isDone());\n    }", "signature": "void waitForPeersOfVersion()", "full_signature": "@Test public void waitForPeersOfVersion()", "class_method_signature": "PeerGroupTest.waitForPeersOfVersion()", "testcase": true, "constructor": false, "invocations": ["getMinRequiredProtocolVersion", "waitForPeersOfVersion", "start", "assertFalse", "isDone", "connectPeer", "assertFalse", "isDone", "connectPeer", "assertFalse", "isDone", "assertTrue", "isDone", "waitForPeersOfVersion", "connectPeer", "get", "assertTrue", "isDone"]}, "focal_class": {"identifier": "PeerGroup", "superclass": "", "interfaces": "implements TransactionBroadcaster", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(PeerGroup.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(PeerGroup.class)", "var_name": "log"}, {"original_string": "private long requiredServices = 0;", "modifier": "private", "type": "long", "declarator": "requiredServices = 0", "var_name": "requiredServices"}, {"original_string": "public static final int DEFAULT_CONNECTIONS = 12;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_CONNECTIONS = 12", "var_name": "DEFAULT_CONNECTIONS"}, {"original_string": "private volatile int vMaxPeersToDiscoverCount = 100;", "modifier": "private volatile", "type": "int", "declarator": "vMaxPeersToDiscoverCount = 100", "var_name": "vMaxPeersToDiscoverCount"}, {"original_string": "private static final long DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS = 5000;", "modifier": "private static final", "type": "long", "declarator": "DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS = 5000", "var_name": "DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS"}, {"original_string": "private volatile long vPeerDiscoveryTimeoutMillis = DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS;", "modifier": "private volatile", "type": "long", "declarator": "vPeerDiscoveryTimeoutMillis = DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS", "var_name": "vPeerDiscoveryTimeoutMillis"}, {"original_string": "protected final ReentrantLock lock = Threading.lock(\"peergroup\");", "modifier": "protected final", "type": "ReentrantLock", "declarator": "lock = Threading.lock(\"peergroup\")", "var_name": "lock"}, {"original_string": "protected final NetworkParameters params;", "modifier": "protected final", "type": "NetworkParameters", "declarator": "params", "var_name": "params"}, {"original_string": "@Nullable protected final AbstractBlockChain chain;", "modifier": "@Nullable protected final", "type": "AbstractBlockChain", "declarator": "chain", "var_name": "chain"}, {"original_string": "protected final ListeningScheduledExecutorService executor;", "modifier": "protected final", "type": "ListeningScheduledExecutorService", "declarator": "executor", "var_name": "executor"}, {"original_string": "private volatile boolean vRunning;", "modifier": "private volatile", "type": "boolean", "declarator": "vRunning", "var_name": "vRunning"}, {"original_string": "private volatile boolean vUsedUp;", "modifier": "private volatile", "type": "boolean", "declarator": "vUsedUp", "var_name": "vUsedUp"}, {"original_string": "@GuardedBy(\"lock\") private final PriorityQueue<PeerAddress> inactives;", "modifier": "@GuardedBy(\"lock\") private final", "type": "PriorityQueue<PeerAddress>", "declarator": "inactives", "var_name": "inactives"}, {"original_string": "@GuardedBy(\"lock\") private final Map<PeerAddress, ExponentialBackoff> backoffMap;", "modifier": "@GuardedBy(\"lock\") private final", "type": "Map<PeerAddress, ExponentialBackoff>", "declarator": "backoffMap", "var_name": "backoffMap"}, {"original_string": "private final CopyOnWriteArrayList<Peer> peers;", "modifier": "private final", "type": "CopyOnWriteArrayList<Peer>", "declarator": "peers", "var_name": "peers"}, {"original_string": "private final CopyOnWriteArrayList<Peer> pendingPeers;", "modifier": "private final", "type": "CopyOnWriteArrayList<Peer>", "declarator": "pendingPeers", "var_name": "pendingPeers"}, {"original_string": "private final ClientConnectionManager channels;", "modifier": "private final", "type": "ClientConnectionManager", "declarator": "channels", "var_name": "channels"}, {"original_string": "@GuardedBy(\"lock\") private Peer downloadPeer;", "modifier": "@GuardedBy(\"lock\") private", "type": "Peer", "declarator": "downloadPeer", "var_name": "downloadPeer"}, {"original_string": "@Nullable @GuardedBy(\"lock\") private PeerDataEventListener downloadListener;", "modifier": "@Nullable @GuardedBy(\"lock\") private", "type": "PeerDataEventListener", "declarator": "downloadListener", "var_name": "downloadListener"}, {"original_string": "private final CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>> peersBlocksDownloadedEventListeners\n        = new CopyOnWriteArrayList<>();", "modifier": "private final", "type": "CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>>", "declarator": "peersBlocksDownloadedEventListeners\n        = new CopyOnWriteArrayList<>()", "var_name": "peersBlocksDownloadedEventListeners"}, {"original_string": "private final CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>> peersChainDownloadStartedEventListeners\n        = new CopyOnWriteArrayList<>();", "modifier": "private final", "type": "CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>>", "declarator": "peersChainDownloadStartedEventListeners\n        = new CopyOnWriteArrayList<>()", "var_name": "peersChainDownloadStartedEventListeners"}, {"original_string": "protected final CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>> peerConnectedEventListeners\n        = new CopyOnWriteArrayList<>();", "modifier": "protected final", "type": "CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>>", "declarator": "peerConnectedEventListeners\n        = new CopyOnWriteArrayList<>()", "var_name": "peerConnectedEventListeners"}, {"original_string": "protected final CopyOnWriteArrayList<ListenerRegistration<PeerDiscoveredEventListener>> peerDiscoveredEventListeners\n        = new CopyOnWriteArrayList<>();", "modifier": "protected final", "type": "CopyOnWriteArrayList<ListenerRegistration<PeerDiscoveredEventListener>>", "declarator": "peerDiscoveredEventListeners\n        = new CopyOnWriteArrayList<>()", "var_name": "peerDiscoveredEventListeners"}, {"original_string": "protected final CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>> peerDisconnectedEventListeners\n        = new CopyOnWriteArrayList<>();", "modifier": "protected final", "type": "CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>>", "declarator": "peerDisconnectedEventListeners\n        = new CopyOnWriteArrayList<>()", "var_name": "peerDisconnectedEventListeners"}, {"original_string": "private final CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>> peerGetDataEventListeners\n        = new CopyOnWriteArrayList<>();", "modifier": "private final", "type": "CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>>", "declarator": "peerGetDataEventListeners\n        = new CopyOnWriteArrayList<>()", "var_name": "peerGetDataEventListeners"}, {"original_string": "private final CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>> peersPreMessageReceivedEventListeners\n        = new CopyOnWriteArrayList<>();", "modifier": "private final", "type": "CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>>", "declarator": "peersPreMessageReceivedEventListeners\n        = new CopyOnWriteArrayList<>()", "var_name": "peersPreMessageReceivedEventListeners"}, {"original_string": "protected final CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>> peersTransactionBroadastEventListeners\n        = new CopyOnWriteArrayList<>();", "modifier": "protected final", "type": "CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>>", "declarator": "peersTransactionBroadastEventListeners\n        = new CopyOnWriteArrayList<>()", "var_name": "peersTransactionBroadastEventListeners"}, {"original_string": "private final CopyOnWriteArraySet<PeerDiscovery> peerDiscoverers;", "modifier": "private final", "type": "CopyOnWriteArraySet<PeerDiscovery>", "declarator": "peerDiscoverers", "var_name": "peerDiscoverers"}, {"original_string": "@GuardedBy(\"lock\") private VersionMessage versionMessage;", "modifier": "@GuardedBy(\"lock\") private", "type": "VersionMessage", "declarator": "versionMessage", "var_name": "versionMessage"}, {"original_string": "@GuardedBy(\"lock\") private int downloadTxDependencyDepth;", "modifier": "@GuardedBy(\"lock\") private", "type": "int", "declarator": "downloadTxDependencyDepth", "var_name": "downloadTxDependencyDepth"}, {"original_string": "@GuardedBy(\"lock\") private int maxConnections;", "modifier": "@GuardedBy(\"lock\") private", "type": "int", "declarator": "maxConnections", "var_name": "maxConnections"}, {"original_string": "private volatile int vMinRequiredProtocolVersion;", "modifier": "private volatile", "type": "int", "declarator": "vMinRequiredProtocolVersion", "var_name": "vMinRequiredProtocolVersion"}, {"original_string": "public static final long DEFAULT_PING_INTERVAL_MSEC = 2000;", "modifier": "public static final", "type": "long", "declarator": "DEFAULT_PING_INTERVAL_MSEC = 2000", "var_name": "DEFAULT_PING_INTERVAL_MSEC"}, {"original_string": "@GuardedBy(\"lock\") private long pingIntervalMsec = DEFAULT_PING_INTERVAL_MSEC;", "modifier": "@GuardedBy(\"lock\") private", "type": "long", "declarator": "pingIntervalMsec = DEFAULT_PING_INTERVAL_MSEC", "var_name": "pingIntervalMsec"}, {"original_string": "@GuardedBy(\"lock\") private boolean useLocalhostPeerWhenPossible = true;", "modifier": "@GuardedBy(\"lock\") private", "type": "boolean", "declarator": "useLocalhostPeerWhenPossible = true", "var_name": "useLocalhostPeerWhenPossible"}, {"original_string": "@GuardedBy(\"lock\") private boolean ipv6Unreachable = false;", "modifier": "@GuardedBy(\"lock\") private", "type": "boolean", "declarator": "ipv6Unreachable = false", "var_name": "ipv6Unreachable"}, {"original_string": "@GuardedBy(\"lock\") private long fastCatchupTimeSecs;", "modifier": "@GuardedBy(\"lock\") private", "type": "long", "declarator": "fastCatchupTimeSecs", "var_name": "fastCatchupTimeSecs"}, {"original_string": "private final CopyOnWriteArrayList<Wallet> wallets;", "modifier": "private final", "type": "CopyOnWriteArrayList<Wallet>", "declarator": "wallets", "var_name": "wallets"}, {"original_string": "private final CopyOnWriteArrayList<PeerFilterProvider> peerFilterProviders;", "modifier": "private final", "type": "CopyOnWriteArrayList<PeerFilterProvider>", "declarator": "peerFilterProviders", "var_name": "peerFilterProviders"}, {"original_string": "private final PeerListener peerListener = new PeerListener();", "modifier": "private final", "type": "PeerListener", "declarator": "peerListener = new PeerListener()", "var_name": "peerListener"}, {"original_string": "private int minBroadcastConnections = 0;", "modifier": "private", "type": "int", "declarator": "minBroadcastConnections = 0", "var_name": "minBroadcastConnections"}, {"original_string": "private final ScriptsChangeEventListener walletScriptEventListener = new ScriptsChangeEventListener() {\n        @Override public void onScriptsChanged(Wallet wallet, List<Script> scripts, boolean isAddingScripts) {\n            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);\n        }\n    };", "modifier": "private final", "type": "ScriptsChangeEventListener", "declarator": "walletScriptEventListener = new ScriptsChangeEventListener() {\n        @Override public void onScriptsChanged(Wallet wallet, List<Script> scripts, boolean isAddingScripts) {\n            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);\n        }\n    }", "var_name": "walletScriptEventListener"}, {"original_string": "private final KeyChainEventListener walletKeyEventListener = new KeyChainEventListener() {\n        @Override public void onKeysAdded(List<ECKey> keys) {\n            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);\n        }\n    };", "modifier": "private final", "type": "KeyChainEventListener", "declarator": "walletKeyEventListener = new KeyChainEventListener() {\n        @Override public void onKeysAdded(List<ECKey> keys) {\n            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);\n        }\n    }", "var_name": "walletKeyEventListener"}, {"original_string": "private final WalletCoinsReceivedEventListener walletCoinsReceivedEventListener = new WalletCoinsReceivedEventListener() {\n        @Override\n        public void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance) {\n            // We received a relevant transaction. We MAY need to recalculate and resend the Bloom filter, but only\n            // if we have received a transaction that includes a relevant P2PK output.\n            //\n            // The reason is that P2PK outputs, when spent, will not repeat any data we can predict in their\n            // inputs. So a remote peer will update the Bloom filter for us when such an output is seen matching the\n            // existing filter, so that it includes the tx hash in which the P2PK output was observed. Thus\n            // the spending transaction will always match (due to the outpoint structure).\n            //\n            // Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.\n            //\n            // (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,\n            // for example in a coinbase transaction, then the node that's serving us the chain will update its filter\n            // but the rest will not. If another transaction then spends it, the other nodes won't match/relay it.\n            //\n            // (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see\n            // it and update their filter themselves, but any newly connected nodes will receive the last filter we\n            // calculated, which would not include this transaction.\n            //\n            // For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc\n            // and possibly retransmit if so. The recalculation process will end up including the tx hash into the\n            // filter. In case (1), we need to retransmit the filter to the connected peers. In case (2), we don't\n            // and shouldn't, we should just recalculate and cache the new filter for next time.\n            for (TransactionOutput output : tx.getOutputs()) {\n                if (ScriptPattern.isPayToPubKey(output.getScriptPubKey()) && output.isMine(wallet)) {\n                    if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)\n                        recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);\n                    else\n                        recalculateFastCatchupAndFilter(FilterRecalculateMode.DONT_SEND);\n                    return;\n                }\n            }\n        }\n    };", "modifier": "private final", "type": "WalletCoinsReceivedEventListener", "declarator": "walletCoinsReceivedEventListener = new WalletCoinsReceivedEventListener() {\n        @Override\n        public void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance) {\n            // We received a relevant transaction. We MAY need to recalculate and resend the Bloom filter, but only\n            // if we have received a transaction that includes a relevant P2PK output.\n            //\n            // The reason is that P2PK outputs, when spent, will not repeat any data we can predict in their\n            // inputs. So a remote peer will update the Bloom filter for us when such an output is seen matching the\n            // existing filter, so that it includes the tx hash in which the P2PK output was observed. Thus\n            // the spending transaction will always match (due to the outpoint structure).\n            //\n            // Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.\n            //\n            // (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,\n            // for example in a coinbase transaction, then the node that's serving us the chain will update its filter\n            // but the rest will not. If another transaction then spends it, the other nodes won't match/relay it.\n            //\n            // (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see\n            // it and update their filter themselves, but any newly connected nodes will receive the last filter we\n            // calculated, which would not include this transaction.\n            //\n            // For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc\n            // and possibly retransmit if so. The recalculation process will end up including the tx hash into the\n            // filter. In case (1), we need to retransmit the filter to the connected peers. In case (2), we don't\n            // and shouldn't, we should just recalculate and cache the new filter for next time.\n            for (TransactionOutput output : tx.getOutputs()) {\n                if (ScriptPattern.isPayToPubKey(output.getScriptPubKey()) && output.isMine(wallet)) {\n                    if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)\n                        recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);\n                    else\n                        recalculateFastCatchupAndFilter(FilterRecalculateMode.DONT_SEND);\n                    return;\n                }\n            }\n        }\n    }", "var_name": "walletCoinsReceivedEventListener"}, {"original_string": "private final ExponentialBackoff.Params peerBackoffParams = new ExponentialBackoff.Params(1000, 1.5f, 10 * 60 * 1000);", "modifier": "private final", "type": "ExponentialBackoff.Params", "declarator": "peerBackoffParams = new ExponentialBackoff.Params(1000, 1.5f, 10 * 60 * 1000)", "var_name": "peerBackoffParams"}, {"original_string": "@GuardedBy(\"lock\") private ExponentialBackoff groupBackoff = new ExponentialBackoff(new ExponentialBackoff.Params(1000, 1.5f, 10 * 1000));", "modifier": "@GuardedBy(\"lock\") private", "type": "ExponentialBackoff", "declarator": "groupBackoff = new ExponentialBackoff(new ExponentialBackoff.Params(1000, 1.5f, 10 * 1000))", "var_name": "groupBackoff"}, {"original_string": "private final Set<TransactionBroadcast> runningBroadcasts;", "modifier": "private final", "type": "Set<TransactionBroadcast>", "declarator": "runningBroadcasts", "var_name": "runningBroadcasts"}, {"original_string": "private final PeerStartupListener startupListener = new PeerStartupListener();", "modifier": "private final", "type": "PeerStartupListener", "declarator": "startupListener = new PeerStartupListener()", "var_name": "startupListener"}, {"original_string": "public static final double DEFAULT_BLOOM_FILTER_FP_RATE = 0.00001;", "modifier": "public static final", "type": "double", "declarator": "DEFAULT_BLOOM_FILTER_FP_RATE = 0.00001", "var_name": "DEFAULT_BLOOM_FILTER_FP_RATE"}, {"original_string": "public static final double MAX_FP_RATE_INCREASE = 10.0f;", "modifier": "public static final", "type": "double", "declarator": "MAX_FP_RATE_INCREASE = 10.0f", "var_name": "MAX_FP_RATE_INCREASE"}, {"original_string": "private final FilterMerger bloomFilterMerger;", "modifier": "private final", "type": "FilterMerger", "declarator": "bloomFilterMerger", "var_name": "bloomFilterMerger"}, {"original_string": "public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000", "var_name": "DEFAULT_CONNECT_TIMEOUT_MILLIS"}, {"original_string": "private volatile int vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS;", "modifier": "private volatile", "type": "int", "declarator": "vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS", "var_name": "vConnectTimeoutMillis"}, {"original_string": "private volatile boolean vBloomFilteringEnabled = true;", "modifier": "private volatile", "type": "boolean", "declarator": "vBloomFilteringEnabled = true", "var_name": "vBloomFilteringEnabled"}, {"original_string": "private CountDownLatch executorStartupLatch = new CountDownLatch(1);", "modifier": "private", "type": "CountDownLatch", "declarator": "executorStartupLatch = new CountDownLatch(1)", "var_name": "executorStartupLatch"}, {"original_string": "private Runnable triggerConnectionsJob = new Runnable() {\n        private boolean firstRun = true;\n        private final static long MIN_PEER_DISCOVERY_INTERVAL = 1000L;\n\n        @Override\n        public void run() {\n            try {\n                go();\n            } catch (Throwable e) {\n                log.error(\"Exception when trying to build connections\", e);  // The executor swallows exceptions :(\n            }\n        }\n\n        public void go() {\n            if (!vRunning) return;\n\n            boolean doDiscovery = false;\n            long now = Utils.currentTimeMillis();\n            lock.lock();\n            try {\n                // First run: try and use a local node if there is one, for the additional security it can provide.\n                // But, not on Android as there are none for this platform: it could only be a malicious app trying\n                // to hijack our traffic.\n                if (!Utils.isAndroidRuntime() && useLocalhostPeerWhenPossible && maybeCheckForLocalhostPeer() && firstRun) {\n                    log.info(\"Localhost peer detected, trying to use it instead of P2P discovery\");\n                    maxConnections = 0;\n                    connectToLocalHost();\n                    return;\n                }\n\n                boolean havePeerWeCanTry = !inactives.isEmpty() && backoffMap.get(inactives.peek()).getRetryTime() <= now;\n                doDiscovery = !havePeerWeCanTry;\n            } finally {\n                firstRun = false;\n                lock.unlock();\n            }\n\n            // Don't hold the lock across discovery as this process can be very slow.\n            boolean discoverySuccess = false;\n            if (doDiscovery) {\n                try {\n                    discoverySuccess = discoverPeers() > 0;\n                } catch (PeerDiscoveryException e) {\n                    log.error(\"Peer discovery failure\", e);\n                }\n            }\n\n            long retryTime;\n            PeerAddress addrToTry;\n            lock.lock();\n            try {\n                if (doDiscovery) {\n                    // Require that we have enough connections, to consider this\n                    // a success, or we just constantly test for new peers\n                    if (discoverySuccess && countConnectedAndPendingPeers() >= getMaxConnections()) {\n                        groupBackoff.trackSuccess();\n                    } else {\n                        groupBackoff.trackFailure();\n                    }\n                }\n                // Inactives is sorted by backoffMap time.\n                if (inactives.isEmpty()) {\n                    if (countConnectedAndPendingPeers() < getMaxConnections()) {\n                        long interval = Math.max(groupBackoff.getRetryTime() - now, MIN_PEER_DISCOVERY_INTERVAL);\n                        log.info(\"Peer discovery didn't provide us any more peers, will try again in \"\n                            + interval + \"ms.\");\n                        executor.schedule(this, interval, TimeUnit.MILLISECONDS);\n                    } else {\n                        // We have enough peers and discovery provided no more, so just settle down. Most likely we\n                        // were given a fixed set of addresses in some test scenario.\n                    }\n                    return;\n                } else {\n                    do {\n                        addrToTry = inactives.poll();\n                    } while (ipv6Unreachable && addrToTry.getAddr() instanceof Inet6Address);\n                    retryTime = backoffMap.get(addrToTry).getRetryTime();\n                }\n                retryTime = Math.max(retryTime, groupBackoff.getRetryTime());\n                if (retryTime > now) {\n                    long delay = retryTime - now;\n                    log.info(\"Waiting {} msec before next connect attempt {}\", delay, addrToTry == null ? \"\" : \"to \" + addrToTry);\n                    inactives.add(addrToTry);\n                    executor.schedule(this, delay, TimeUnit.MILLISECONDS);\n                    return;\n                }\n                connectTo(addrToTry, false, vConnectTimeoutMillis);\n            } finally {\n                lock.unlock();\n            }\n            if (countConnectedAndPendingPeers() < getMaxConnections()) {\n                executor.execute(this);   // Try next peer immediately.\n            }\n        }\n    };", "modifier": "private", "type": "Runnable", "declarator": "triggerConnectionsJob = new Runnable() {\n        private boolean firstRun = true;\n        private final static long MIN_PEER_DISCOVERY_INTERVAL = 1000L;\n\n        @Override\n        public void run() {\n            try {\n                go();\n            } catch (Throwable e) {\n                log.error(\"Exception when trying to build connections\", e);  // The executor swallows exceptions :(\n            }\n        }\n\n        public void go() {\n            if (!vRunning) return;\n\n            boolean doDiscovery = false;\n            long now = Utils.currentTimeMillis();\n            lock.lock();\n            try {\n                // First run: try and use a local node if there is one, for the additional security it can provide.\n                // But, not on Android as there are none for this platform: it could only be a malicious app trying\n                // to hijack our traffic.\n                if (!Utils.isAndroidRuntime() && useLocalhostPeerWhenPossible && maybeCheckForLocalhostPeer() && firstRun) {\n                    log.info(\"Localhost peer detected, trying to use it instead of P2P discovery\");\n                    maxConnections = 0;\n                    connectToLocalHost();\n                    return;\n                }\n\n                boolean havePeerWeCanTry = !inactives.isEmpty() && backoffMap.get(inactives.peek()).getRetryTime() <= now;\n                doDiscovery = !havePeerWeCanTry;\n            } finally {\n                firstRun = false;\n                lock.unlock();\n            }\n\n            // Don't hold the lock across discovery as this process can be very slow.\n            boolean discoverySuccess = false;\n            if (doDiscovery) {\n                try {\n                    discoverySuccess = discoverPeers() > 0;\n                } catch (PeerDiscoveryException e) {\n                    log.error(\"Peer discovery failure\", e);\n                }\n            }\n\n            long retryTime;\n            PeerAddress addrToTry;\n            lock.lock();\n            try {\n                if (doDiscovery) {\n                    // Require that we have enough connections, to consider this\n                    // a success, or we just constantly test for new peers\n                    if (discoverySuccess && countConnectedAndPendingPeers() >= getMaxConnections()) {\n                        groupBackoff.trackSuccess();\n                    } else {\n                        groupBackoff.trackFailure();\n                    }\n                }\n                // Inactives is sorted by backoffMap time.\n                if (inactives.isEmpty()) {\n                    if (countConnectedAndPendingPeers() < getMaxConnections()) {\n                        long interval = Math.max(groupBackoff.getRetryTime() - now, MIN_PEER_DISCOVERY_INTERVAL);\n                        log.info(\"Peer discovery didn't provide us any more peers, will try again in \"\n                            + interval + \"ms.\");\n                        executor.schedule(this, interval, TimeUnit.MILLISECONDS);\n                    } else {\n                        // We have enough peers and discovery provided no more, so just settle down. Most likely we\n                        // were given a fixed set of addresses in some test scenario.\n                    }\n                    return;\n                } else {\n                    do {\n                        addrToTry = inactives.poll();\n                    } while (ipv6Unreachable && addrToTry.getAddr() instanceof Inet6Address);\n                    retryTime = backoffMap.get(addrToTry).getRetryTime();\n                }\n                retryTime = Math.max(retryTime, groupBackoff.getRetryTime());\n                if (retryTime > now) {\n                    long delay = retryTime - now;\n                    log.info(\"Waiting {} msec before next connect attempt {}\", delay, addrToTry == null ? \"\" : \"to \" + addrToTry);\n                    inactives.add(addrToTry);\n                    executor.schedule(this, delay, TimeUnit.MILLISECONDS);\n                    return;\n                }\n                connectTo(addrToTry, false, vConnectTimeoutMillis);\n            } finally {\n                lock.unlock();\n            }\n            if (countConnectedAndPendingPeers() < getMaxConnections()) {\n                executor.execute(this);   // Try next peer immediately.\n            }\n        }\n    }", "var_name": "triggerConnectionsJob"}, {"original_string": "private LocalhostCheckState localhostCheckState = LocalhostCheckState.NOT_TRIED;", "modifier": "private", "type": "LocalhostCheckState", "declarator": "localhostCheckState = LocalhostCheckState.NOT_TRIED", "var_name": "localhostCheckState"}, {"original_string": "private final Map<FilterRecalculateMode, SettableFuture<BloomFilter>> inFlightRecalculations = Maps.newHashMap();", "modifier": "private final", "type": "Map<FilterRecalculateMode, SettableFuture<BloomFilter>>", "declarator": "inFlightRecalculations = Maps.newHashMap()", "var_name": "inFlightRecalculations"}, {"original_string": "@Nullable private volatile ListenableScheduledFuture<?> vPingTask;", "modifier": "@Nullable private volatile", "type": "ListenableScheduledFuture<?>", "declarator": "vPingTask", "var_name": "vPingTask"}, {"original_string": "@GuardedBy(\"lock\") private int stallPeriodSeconds = 10;", "modifier": "@GuardedBy(\"lock\") private", "type": "int", "declarator": "stallPeriodSeconds = 10", "var_name": "stallPeriodSeconds"}, {"original_string": "@GuardedBy(\"lock\") private int stallMinSpeedBytesSec = Block.HEADER_SIZE * 20;", "modifier": "@GuardedBy(\"lock\") private", "type": "int", "declarator": "stallMinSpeedBytesSec = Block.HEADER_SIZE * 20", "var_name": "stallMinSpeedBytesSec"}, {"original_string": "@Nullable private ChainDownloadSpeedCalculator chainDownloadSpeedCalculator;", "modifier": "@Nullable private", "type": "ChainDownloadSpeedCalculator", "declarator": "chainDownloadSpeedCalculator", "var_name": "chainDownloadSpeedCalculator"}], "methods": [{"identifier": "PeerGroup", "parameters": "(NetworkParameters params)", "modifiers": "public", "return": "", "signature": " PeerGroup(NetworkParameters params)", "full_signature": "public  PeerGroup(NetworkParameters params)", "class_method_signature": "PeerGroup.PeerGroup(NetworkParameters params)", "testcase": false, "constructor": true}, {"identifier": "PeerGroup", "parameters": "(Context context)", "modifiers": "public", "return": "", "signature": " PeerGroup(Context context)", "full_signature": "public  PeerGroup(Context context)", "class_method_signature": "PeerGroup.PeerGroup(Context context)", "testcase": false, "constructor": true}, {"identifier": "PeerGroup", "parameters": "(NetworkParameters params, @Nullable AbstractBlockChain chain)", "modifiers": "public", "return": "", "signature": " PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain)", "full_signature": "public  PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain)", "class_method_signature": "PeerGroup.PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain)", "testcase": false, "constructor": true}, {"identifier": "PeerGroup", "parameters": "(Context context, @Nullable AbstractBlockChain chain)", "modifiers": "public", "return": "", "signature": " PeerGroup(Context context, @Nullable AbstractBlockChain chain)", "full_signature": "public  PeerGroup(Context context, @Nullable AbstractBlockChain chain)", "class_method_signature": "PeerGroup.PeerGroup(Context context, @Nullable AbstractBlockChain chain)", "testcase": false, "constructor": true}, {"identifier": "PeerGroup", "parameters": "(NetworkParameters params, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "modifiers": "public", "return": "", "signature": " PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "full_signature": "public  PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "class_method_signature": "PeerGroup.PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "testcase": false, "constructor": true}, {"identifier": "PeerGroup", "parameters": "(Context context, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "modifiers": "private", "return": "", "signature": " PeerGroup(Context context, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "full_signature": "private  PeerGroup(Context context, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "class_method_signature": "PeerGroup.PeerGroup(Context context, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager)", "testcase": false, "constructor": true}, {"identifier": "createPrivateExecutor", "parameters": "()", "modifiers": "protected", "return": "ListeningScheduledExecutorService", "signature": "ListeningScheduledExecutorService createPrivateExecutor()", "full_signature": "protected ListeningScheduledExecutorService createPrivateExecutor()", "class_method_signature": "PeerGroup.createPrivateExecutor()", "testcase": false, "constructor": false}, {"identifier": "setPeerDiscoveryTimeoutMillis", "parameters": "(long peerDiscoveryTimeoutMillis)", "modifiers": "public", "return": "void", "signature": "void setPeerDiscoveryTimeoutMillis(long peerDiscoveryTimeoutMillis)", "full_signature": "public void setPeerDiscoveryTimeoutMillis(long peerDiscoveryTimeoutMillis)", "class_method_signature": "PeerGroup.setPeerDiscoveryTimeoutMillis(long peerDiscoveryTimeoutMillis)", "testcase": false, "constructor": false}, {"identifier": "setMaxConnections", "parameters": "(int maxConnections)", "modifiers": "public", "return": "void", "signature": "void setMaxConnections(int maxConnections)", "full_signature": "public void setMaxConnections(int maxConnections)", "class_method_signature": "PeerGroup.setMaxConnections(int maxConnections)", "testcase": false, "constructor": false}, {"identifier": "setDownloadTxDependencies", "parameters": "(int depth)", "modifiers": "public", "return": "void", "signature": "void setDownloadTxDependencies(int depth)", "full_signature": "public void setDownloadTxDependencies(int depth)", "class_method_signature": "PeerGroup.setDownloadTxDependencies(int depth)", "testcase": false, "constructor": false}, {"identifier": "triggerConnections", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void triggerConnections()", "full_signature": "private void triggerConnections()", "class_method_signature": "PeerGroup.triggerConnections()", "testcase": false, "constructor": false}, {"identifier": "getMaxConnections", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMaxConnections()", "full_signature": "public int getMaxConnections()", "class_method_signature": "PeerGroup.getMaxConnections()", "testcase": false, "constructor": false}, {"identifier": "handleGetData", "parameters": "(GetDataMessage m)", "modifiers": "private", "return": "List<Message>", "signature": "List<Message> handleGetData(GetDataMessage m)", "full_signature": "private List<Message> handleGetData(GetDataMessage m)", "class_method_signature": "PeerGroup.handleGetData(GetDataMessage m)", "testcase": false, "constructor": false}, {"identifier": "setVersionMessage", "parameters": "(VersionMessage ver)", "modifiers": "public", "return": "void", "signature": "void setVersionMessage(VersionMessage ver)", "full_signature": "public void setVersionMessage(VersionMessage ver)", "class_method_signature": "PeerGroup.setVersionMessage(VersionMessage ver)", "testcase": false, "constructor": false}, {"identifier": "getVersionMessage", "parameters": "()", "modifiers": "public", "return": "VersionMessage", "signature": "VersionMessage getVersionMessage()", "full_signature": "public VersionMessage getVersionMessage()", "class_method_signature": "PeerGroup.getVersionMessage()", "testcase": false, "constructor": false}, {"identifier": "setUserAgent", "parameters": "(String name, String version, @Nullable String comments)", "modifiers": "public", "return": "void", "signature": "void setUserAgent(String name, String version, @Nullable String comments)", "full_signature": "public void setUserAgent(String name, String version, @Nullable String comments)", "class_method_signature": "PeerGroup.setUserAgent(String name, String version, @Nullable String comments)", "testcase": false, "constructor": false}, {"identifier": "updateVersionMessageRelayTxesBeforeFilter", "parameters": "(VersionMessage ver)", "modifiers": "private", "return": "void", "signature": "void updateVersionMessageRelayTxesBeforeFilter(VersionMessage ver)", "full_signature": "private void updateVersionMessageRelayTxesBeforeFilter(VersionMessage ver)", "class_method_signature": "PeerGroup.updateVersionMessageRelayTxesBeforeFilter(VersionMessage ver)", "testcase": false, "constructor": false}, {"identifier": "setUserAgent", "parameters": "(String name, String version)", "modifiers": "public", "return": "void", "signature": "void setUserAgent(String name, String version)", "full_signature": "public void setUserAgent(String name, String version)", "class_method_signature": "PeerGroup.setUserAgent(String name, String version)", "testcase": false, "constructor": false}, {"identifier": "addEventListener", "parameters": "(AbstractPeerEventListener listener, Executor executor)", "modifiers": "@Deprecated @SuppressWarnings(\"deprecation\") public", "return": "void", "signature": "void addEventListener(AbstractPeerEventListener listener, Executor executor)", "full_signature": "@Deprecated @SuppressWarnings(\"deprecation\") public void addEventListener(AbstractPeerEventListener listener, Executor executor)", "class_method_signature": "PeerGroup.addEventListener(AbstractPeerEventListener listener, Executor executor)", "testcase": false, "constructor": false}, {"identifier": "addEventListener", "parameters": "(AbstractPeerEventListener listener)", "modifiers": "@Deprecated @SuppressWarnings(\"deprecation\") public", "return": "void", "signature": "void addEventListener(AbstractPeerEventListener listener)", "full_signature": "@Deprecated @SuppressWarnings(\"deprecation\") public void addEventListener(AbstractPeerEventListener listener)", "class_method_signature": "PeerGroup.addEventListener(AbstractPeerEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addBlocksDownloadedEventListener", "parameters": "(BlocksDownloadedEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addBlocksDownloadedEventListener(BlocksDownloadedEventListener listener)", "full_signature": "public void addBlocksDownloadedEventListener(BlocksDownloadedEventListener listener)", "class_method_signature": "PeerGroup.addBlocksDownloadedEventListener(BlocksDownloadedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addBlocksDownloadedEventListener", "parameters": "(Executor executor, BlocksDownloadedEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addBlocksDownloadedEventListener(Executor executor, BlocksDownloadedEventListener listener)", "full_signature": "public void addBlocksDownloadedEventListener(Executor executor, BlocksDownloadedEventListener listener)", "class_method_signature": "PeerGroup.addBlocksDownloadedEventListener(Executor executor, BlocksDownloadedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addChainDownloadStartedEventListener", "parameters": "(ChainDownloadStartedEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener)", "full_signature": "public void addChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener)", "class_method_signature": "PeerGroup.addChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addChainDownloadStartedEventListener", "parameters": "(Executor executor, ChainDownloadStartedEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addChainDownloadStartedEventListener(Executor executor, ChainDownloadStartedEventListener listener)", "full_signature": "public void addChainDownloadStartedEventListener(Executor executor, ChainDownloadStartedEventListener listener)", "class_method_signature": "PeerGroup.addChainDownloadStartedEventListener(Executor executor, ChainDownloadStartedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addConnectedEventListener", "parameters": "(PeerConnectedEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addConnectedEventListener(PeerConnectedEventListener listener)", "full_signature": "public void addConnectedEventListener(PeerConnectedEventListener listener)", "class_method_signature": "PeerGroup.addConnectedEventListener(PeerConnectedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addConnectedEventListener", "parameters": "(Executor executor, PeerConnectedEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addConnectedEventListener(Executor executor, PeerConnectedEventListener listener)", "full_signature": "public void addConnectedEventListener(Executor executor, PeerConnectedEventListener listener)", "class_method_signature": "PeerGroup.addConnectedEventListener(Executor executor, PeerConnectedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addDisconnectedEventListener", "parameters": "(PeerDisconnectedEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addDisconnectedEventListener(PeerDisconnectedEventListener listener)", "full_signature": "public void addDisconnectedEventListener(PeerDisconnectedEventListener listener)", "class_method_signature": "PeerGroup.addDisconnectedEventListener(PeerDisconnectedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addDisconnectedEventListener", "parameters": "(Executor executor, PeerDisconnectedEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addDisconnectedEventListener(Executor executor, PeerDisconnectedEventListener listener)", "full_signature": "public void addDisconnectedEventListener(Executor executor, PeerDisconnectedEventListener listener)", "class_method_signature": "PeerGroup.addDisconnectedEventListener(Executor executor, PeerDisconnectedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addDiscoveredEventListener", "parameters": "(PeerDiscoveredEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addDiscoveredEventListener(PeerDiscoveredEventListener listener)", "full_signature": "public void addDiscoveredEventListener(PeerDiscoveredEventListener listener)", "class_method_signature": "PeerGroup.addDiscoveredEventListener(PeerDiscoveredEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addDiscoveredEventListener", "parameters": "(Executor executor, PeerDiscoveredEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addDiscoveredEventListener(Executor executor, PeerDiscoveredEventListener listener)", "full_signature": "public void addDiscoveredEventListener(Executor executor, PeerDiscoveredEventListener listener)", "class_method_signature": "PeerGroup.addDiscoveredEventListener(Executor executor, PeerDiscoveredEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addGetDataEventListener", "parameters": "(GetDataEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addGetDataEventListener(GetDataEventListener listener)", "full_signature": "public void addGetDataEventListener(GetDataEventListener listener)", "class_method_signature": "PeerGroup.addGetDataEventListener(GetDataEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addGetDataEventListener", "parameters": "(final Executor executor, final GetDataEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addGetDataEventListener(final Executor executor, final GetDataEventListener listener)", "full_signature": "public void addGetDataEventListener(final Executor executor, final GetDataEventListener listener)", "class_method_signature": "PeerGroup.addGetDataEventListener(final Executor executor, final GetDataEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addOnTransactionBroadcastListener", "parameters": "(OnTransactionBroadcastListener listener)", "modifiers": "public", "return": "void", "signature": "void addOnTransactionBroadcastListener(OnTransactionBroadcastListener listener)", "full_signature": "public void addOnTransactionBroadcastListener(OnTransactionBroadcastListener listener)", "class_method_signature": "PeerGroup.addOnTransactionBroadcastListener(OnTransactionBroadcastListener listener)", "testcase": false, "constructor": false}, {"identifier": "addOnTransactionBroadcastListener", "parameters": "(Executor executor, OnTransactionBroadcastListener listener)", "modifiers": "public", "return": "void", "signature": "void addOnTransactionBroadcastListener(Executor executor, OnTransactionBroadcastListener listener)", "full_signature": "public void addOnTransactionBroadcastListener(Executor executor, OnTransactionBroadcastListener listener)", "class_method_signature": "PeerGroup.addOnTransactionBroadcastListener(Executor executor, OnTransactionBroadcastListener listener)", "testcase": false, "constructor": false}, {"identifier": "addPreMessageReceivedEventListener", "parameters": "(PreMessageReceivedEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addPreMessageReceivedEventListener(PreMessageReceivedEventListener listener)", "full_signature": "public void addPreMessageReceivedEventListener(PreMessageReceivedEventListener listener)", "class_method_signature": "PeerGroup.addPreMessageReceivedEventListener(PreMessageReceivedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addPreMessageReceivedEventListener", "parameters": "(Executor executor, PreMessageReceivedEventListener listener)", "modifiers": "public", "return": "void", "signature": "void addPreMessageReceivedEventListener(Executor executor, PreMessageReceivedEventListener listener)", "full_signature": "public void addPreMessageReceivedEventListener(Executor executor, PreMessageReceivedEventListener listener)", "class_method_signature": "PeerGroup.addPreMessageReceivedEventListener(Executor executor, PreMessageReceivedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeEventListener", "parameters": "(AbstractPeerEventListener listener)", "modifiers": "@Deprecated @SuppressWarnings(\"deprecation\") public", "return": "void", "signature": "void removeEventListener(AbstractPeerEventListener listener)", "full_signature": "@Deprecated @SuppressWarnings(\"deprecation\") public void removeEventListener(AbstractPeerEventListener listener)", "class_method_signature": "PeerGroup.removeEventListener(AbstractPeerEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeBlocksDownloadedEventListener", "parameters": "(BlocksDownloadedEventListener listener)", "modifiers": "public", "return": "boolean", "signature": "boolean removeBlocksDownloadedEventListener(BlocksDownloadedEventListener listener)", "full_signature": "public boolean removeBlocksDownloadedEventListener(BlocksDownloadedEventListener listener)", "class_method_signature": "PeerGroup.removeBlocksDownloadedEventListener(BlocksDownloadedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeChainDownloadStartedEventListener", "parameters": "(ChainDownloadStartedEventListener listener)", "modifiers": "public", "return": "boolean", "signature": "boolean removeChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener)", "full_signature": "public boolean removeChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener)", "class_method_signature": "PeerGroup.removeChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeConnectedEventListener", "parameters": "(PeerConnectedEventListener listener)", "modifiers": "public", "return": "boolean", "signature": "boolean removeConnectedEventListener(PeerConnectedEventListener listener)", "full_signature": "public boolean removeConnectedEventListener(PeerConnectedEventListener listener)", "class_method_signature": "PeerGroup.removeConnectedEventListener(PeerConnectedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeDisconnectedEventListener", "parameters": "(PeerDisconnectedEventListener listener)", "modifiers": "public", "return": "boolean", "signature": "boolean removeDisconnectedEventListener(PeerDisconnectedEventListener listener)", "full_signature": "public boolean removeDisconnectedEventListener(PeerDisconnectedEventListener listener)", "class_method_signature": "PeerGroup.removeDisconnectedEventListener(PeerDisconnectedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeDiscoveredEventListener", "parameters": "(PeerDiscoveredEventListener listener)", "modifiers": "public", "return": "boolean", "signature": "boolean removeDiscoveredEventListener(PeerDiscoveredEventListener listener)", "full_signature": "public boolean removeDiscoveredEventListener(PeerDiscoveredEventListener listener)", "class_method_signature": "PeerGroup.removeDiscoveredEventListener(PeerDiscoveredEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeGetDataEventListener", "parameters": "(GetDataEventListener listener)", "modifiers": "public", "return": "boolean", "signature": "boolean removeGetDataEventListener(GetDataEventListener listener)", "full_signature": "public boolean removeGetDataEventListener(GetDataEventListener listener)", "class_method_signature": "PeerGroup.removeGetDataEventListener(GetDataEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "removeOnTransactionBroadcastListener", "parameters": "(OnTransactionBroadcastListener listener)", "modifiers": "public", "return": "boolean", "signature": "boolean removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener)", "full_signature": "public boolean removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener)", "class_method_signature": "PeerGroup.removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener)", "testcase": false, "constructor": false}, {"identifier": "removePreMessageReceivedEventListener", "parameters": "(PreMessageReceivedEventListener listener)", "modifiers": "public", "return": "boolean", "signature": "boolean removePreMessageReceivedEventListener(PreMessageReceivedEventListener listener)", "full_signature": "public boolean removePreMessageReceivedEventListener(PreMessageReceivedEventListener listener)", "class_method_signature": "PeerGroup.removePreMessageReceivedEventListener(PreMessageReceivedEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "getConnectedPeers", "parameters": "()", "modifiers": "public", "return": "List<Peer>", "signature": "List<Peer> getConnectedPeers()", "full_signature": "public List<Peer> getConnectedPeers()", "class_method_signature": "PeerGroup.getConnectedPeers()", "testcase": false, "constructor": false}, {"identifier": "getPendingPeers", "parameters": "()", "modifiers": "public", "return": "List<Peer>", "signature": "List<Peer> getPendingPeers()", "full_signature": "public List<Peer> getPendingPeers()", "class_method_signature": "PeerGroup.getPendingPeers()", "testcase": false, "constructor": false}, {"identifier": "addAddress", "parameters": "(PeerAddress peerAddress)", "modifiers": "public", "return": "void", "signature": "void addAddress(PeerAddress peerAddress)", "full_signature": "public void addAddress(PeerAddress peerAddress)", "class_method_signature": "PeerGroup.addAddress(PeerAddress peerAddress)", "testcase": false, "constructor": false}, {"identifier": "addInactive", "parameters": "(PeerAddress peerAddress)", "modifiers": "private", "return": "void", "signature": "void addInactive(PeerAddress peerAddress)", "full_signature": "private void addInactive(PeerAddress peerAddress)", "class_method_signature": "PeerGroup.addInactive(PeerAddress peerAddress)", "testcase": false, "constructor": false}, {"identifier": "setRequiredServices", "parameters": "(long requiredServices)", "modifiers": "public", "return": "void", "signature": "void setRequiredServices(long requiredServices)", "full_signature": "public void setRequiredServices(long requiredServices)", "class_method_signature": "PeerGroup.setRequiredServices(long requiredServices)", "testcase": false, "constructor": false}, {"identifier": "addAddress", "parameters": "(InetAddress address)", "modifiers": "public", "return": "void", "signature": "void addAddress(InetAddress address)", "full_signature": "public void addAddress(InetAddress address)", "class_method_signature": "PeerGroup.addAddress(InetAddress address)", "testcase": false, "constructor": false}, {"identifier": "addPeerDiscovery", "parameters": "(PeerDiscovery peerDiscovery)", "modifiers": "public", "return": "void", "signature": "void addPeerDiscovery(PeerDiscovery peerDiscovery)", "full_signature": "public void addPeerDiscovery(PeerDiscovery peerDiscovery)", "class_method_signature": "PeerGroup.addPeerDiscovery(PeerDiscovery peerDiscovery)", "testcase": false, "constructor": false}, {"identifier": "discoverPeers", "parameters": "()", "modifiers": "protected", "return": "int", "signature": "int discoverPeers()", "full_signature": "protected int discoverPeers()", "class_method_signature": "PeerGroup.discoverPeers()", "testcase": false, "constructor": false}, {"identifier": "waitForJobQueue", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void waitForJobQueue()", "full_signature": "@VisibleForTesting void waitForJobQueue()", "class_method_signature": "PeerGroup.waitForJobQueue()", "testcase": false, "constructor": false}, {"identifier": "countConnectedAndPendingPeers", "parameters": "()", "modifiers": "private", "return": "int", "signature": "int countConnectedAndPendingPeers()", "full_signature": "private int countConnectedAndPendingPeers()", "class_method_signature": "PeerGroup.countConnectedAndPendingPeers()", "testcase": false, "constructor": false}, {"identifier": "maybeCheckForLocalhostPeer", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean maybeCheckForLocalhostPeer()", "full_signature": "private boolean maybeCheckForLocalhostPeer()", "class_method_signature": "PeerGroup.maybeCheckForLocalhostPeer()", "testcase": false, "constructor": false}, {"identifier": "startAsync", "parameters": "()", "modifiers": "public", "return": "ListenableFuture", "signature": "ListenableFuture startAsync()", "full_signature": "public ListenableFuture startAsync()", "class_method_signature": "PeerGroup.startAsync()", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void start()", "full_signature": "public void start()", "class_method_signature": "PeerGroup.start()", "testcase": false, "constructor": false}, {"identifier": "stopAsync", "parameters": "()", "modifiers": "public", "return": "ListenableFuture", "signature": "ListenableFuture stopAsync()", "full_signature": "public ListenableFuture stopAsync()", "class_method_signature": "PeerGroup.stopAsync()", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void stop()", "full_signature": "public void stop()", "class_method_signature": "PeerGroup.stop()", "testcase": false, "constructor": false}, {"identifier": "addWallet", "parameters": "(Wallet wallet)", "modifiers": "public", "return": "void", "signature": "void addWallet(Wallet wallet)", "full_signature": "public void addWallet(Wallet wallet)", "class_method_signature": "PeerGroup.addWallet(Wallet wallet)", "testcase": false, "constructor": false}, {"identifier": "addPeerFilterProvider", "parameters": "(PeerFilterProvider provider)", "modifiers": "public", "return": "ListenableFuture<BloomFilter>", "signature": "ListenableFuture<BloomFilter> addPeerFilterProvider(PeerFilterProvider provider)", "full_signature": "public ListenableFuture<BloomFilter> addPeerFilterProvider(PeerFilterProvider provider)", "class_method_signature": "PeerGroup.addPeerFilterProvider(PeerFilterProvider provider)", "testcase": false, "constructor": false}, {"identifier": "removePeerFilterProvider", "parameters": "(PeerFilterProvider provider)", "modifiers": "public", "return": "void", "signature": "void removePeerFilterProvider(PeerFilterProvider provider)", "full_signature": "public void removePeerFilterProvider(PeerFilterProvider provider)", "class_method_signature": "PeerGroup.removePeerFilterProvider(PeerFilterProvider provider)", "testcase": false, "constructor": false}, {"identifier": "removeWallet", "parameters": "(Wallet wallet)", "modifiers": "public", "return": "void", "signature": "void removeWallet(Wallet wallet)", "full_signature": "public void removeWallet(Wallet wallet)", "class_method_signature": "PeerGroup.removeWallet(Wallet wallet)", "testcase": false, "constructor": false}, {"identifier": "recalculateFastCatchupAndFilter", "parameters": "(final FilterRecalculateMode mode)", "modifiers": "public", "return": "ListenableFuture<BloomFilter>", "signature": "ListenableFuture<BloomFilter> recalculateFastCatchupAndFilter(final FilterRecalculateMode mode)", "full_signature": "public ListenableFuture<BloomFilter> recalculateFastCatchupAndFilter(final FilterRecalculateMode mode)", "class_method_signature": "PeerGroup.recalculateFastCatchupAndFilter(final FilterRecalculateMode mode)", "testcase": false, "constructor": false}, {"identifier": "setBloomFilterFalsePositiveRate", "parameters": "(double bloomFilterFPRate)", "modifiers": "public", "return": "void", "signature": "void setBloomFilterFalsePositiveRate(double bloomFilterFPRate)", "full_signature": "public void setBloomFilterFalsePositiveRate(double bloomFilterFPRate)", "class_method_signature": "PeerGroup.setBloomFilterFalsePositiveRate(double bloomFilterFPRate)", "testcase": false, "constructor": false}, {"identifier": "numConnectedPeers", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int numConnectedPeers()", "full_signature": "public int numConnectedPeers()", "class_method_signature": "PeerGroup.numConnectedPeers()", "testcase": false, "constructor": false}, {"identifier": "connectTo", "parameters": "(InetSocketAddress address)", "modifiers": "@Nullable public", "return": "Peer", "signature": "Peer connectTo(InetSocketAddress address)", "full_signature": "@Nullable public Peer connectTo(InetSocketAddress address)", "class_method_signature": "PeerGroup.connectTo(InetSocketAddress address)", "testcase": false, "constructor": false}, {"identifier": "connectToLocalHost", "parameters": "()", "modifiers": "@Nullable public", "return": "Peer", "signature": "Peer connectToLocalHost()", "full_signature": "@Nullable public Peer connectToLocalHost()", "class_method_signature": "PeerGroup.connectToLocalHost()", "testcase": false, "constructor": false}, {"identifier": "connectTo", "parameters": "(PeerAddress address, boolean incrementMaxConnections, int connectTimeoutMillis)", "modifiers": "@Nullable @GuardedBy(\"lock\") protected", "return": "Peer", "signature": "Peer connectTo(PeerAddress address, boolean incrementMaxConnections, int connectTimeoutMillis)", "full_signature": "@Nullable @GuardedBy(\"lock\") protected Peer connectTo(PeerAddress address, boolean incrementMaxConnections, int connectTimeoutMillis)", "class_method_signature": "PeerGroup.connectTo(PeerAddress address, boolean incrementMaxConnections, int connectTimeoutMillis)", "testcase": false, "constructor": false}, {"identifier": "createPeer", "parameters": "(PeerAddress address, VersionMessage ver)", "modifiers": "@GuardedBy(\"lock\") protected", "return": "Peer", "signature": "Peer createPeer(PeerAddress address, VersionMessage ver)", "full_signature": "@GuardedBy(\"lock\") protected Peer createPeer(PeerAddress address, VersionMessage ver)", "class_method_signature": "PeerGroup.createPeer(PeerAddress address, VersionMessage ver)", "testcase": false, "constructor": false}, {"identifier": "setConnectTimeoutMillis", "parameters": "(int connectTimeoutMillis)", "modifiers": "public", "return": "void", "signature": "void setConnectTimeoutMillis(int connectTimeoutMillis)", "full_signature": "public void setConnectTimeoutMillis(int connectTimeoutMillis)", "class_method_signature": "PeerGroup.setConnectTimeoutMillis(int connectTimeoutMillis)", "testcase": false, "constructor": false}, {"identifier": "startBlockChainDownload", "parameters": "(PeerDataEventListener listener)", "modifiers": "public", "return": "void", "signature": "void startBlockChainDownload(PeerDataEventListener listener)", "full_signature": "public void startBlockChainDownload(PeerDataEventListener listener)", "class_method_signature": "PeerGroup.startBlockChainDownload(PeerDataEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "addDataEventListenerToPeer", "parameters": "(Executor executor, Peer peer, PeerDataEventListener downloadListener)", "modifiers": "private static", "return": "void", "signature": "void addDataEventListenerToPeer(Executor executor, Peer peer, PeerDataEventListener downloadListener)", "full_signature": "private static void addDataEventListenerToPeer(Executor executor, Peer peer, PeerDataEventListener downloadListener)", "class_method_signature": "PeerGroup.addDataEventListenerToPeer(Executor executor, Peer peer, PeerDataEventListener downloadListener)", "testcase": false, "constructor": false}, {"identifier": "removeDataEventListenerFromPeer", "parameters": "(Peer peer, PeerDataEventListener listener)", "modifiers": "private static", "return": "void", "signature": "void removeDataEventListenerFromPeer(Peer peer, PeerDataEventListener listener)", "full_signature": "private static void removeDataEventListenerFromPeer(Peer peer, PeerDataEventListener listener)", "class_method_signature": "PeerGroup.removeDataEventListenerFromPeer(Peer peer, PeerDataEventListener listener)", "testcase": false, "constructor": false}, {"identifier": "downloadBlockChain", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void downloadBlockChain()", "full_signature": "public void downloadBlockChain()", "class_method_signature": "PeerGroup.downloadBlockChain()", "testcase": false, "constructor": false}, {"identifier": "handleNewPeer", "parameters": "(final Peer peer)", "modifiers": "protected", "return": "void", "signature": "void handleNewPeer(final Peer peer)", "full_signature": "protected void handleNewPeer(final Peer peer)", "class_method_signature": "PeerGroup.handleNewPeer(final Peer peer)", "testcase": false, "constructor": false}, {"identifier": "setupPinging", "parameters": "()", "modifiers": "@SuppressWarnings(\"NonAtomicOperationOnVolatileField\") private", "return": "void", "signature": "void setupPinging()", "full_signature": "@SuppressWarnings(\"NonAtomicOperationOnVolatileField\") private void setupPinging()", "class_method_signature": "PeerGroup.setupPinging()", "testcase": false, "constructor": false}, {"identifier": "setDownloadPeer", "parameters": "(@Nullable Peer peer)", "modifiers": "private", "return": "void", "signature": "void setDownloadPeer(@Nullable Peer peer)", "full_signature": "private void setDownloadPeer(@Nullable Peer peer)", "class_method_signature": "PeerGroup.setDownloadPeer(@Nullable Peer peer)", "testcase": false, "constructor": false}, {"identifier": "getMemoryPool", "parameters": "()", "modifiers": "@Deprecated @Nullable public", "return": "TxConfidenceTable", "signature": "TxConfidenceTable getMemoryPool()", "full_signature": "@Deprecated @Nullable public TxConfidenceTable getMemoryPool()", "class_method_signature": "PeerGroup.getMemoryPool()", "testcase": false, "constructor": false}, {"identifier": "setFastCatchupTimeSecs", "parameters": "(long secondsSinceEpoch)", "modifiers": "public", "return": "void", "signature": "void setFastCatchupTimeSecs(long secondsSinceEpoch)", "full_signature": "public void setFastCatchupTimeSecs(long secondsSinceEpoch)", "class_method_signature": "PeerGroup.setFastCatchupTimeSecs(long secondsSinceEpoch)", "testcase": false, "constructor": false}, {"identifier": "getFastCatchupTimeSecs", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getFastCatchupTimeSecs()", "full_signature": "public long getFastCatchupTimeSecs()", "class_method_signature": "PeerGroup.getFastCatchupTimeSecs()", "testcase": false, "constructor": false}, {"identifier": "handlePeerDeath", "parameters": "(final Peer peer, @Nullable Throwable exception)", "modifiers": "protected", "return": "void", "signature": "void handlePeerDeath(final Peer peer, @Nullable Throwable exception)", "full_signature": "protected void handlePeerDeath(final Peer peer, @Nullable Throwable exception)", "class_method_signature": "PeerGroup.handlePeerDeath(final Peer peer, @Nullable Throwable exception)", "testcase": false, "constructor": false}, {"identifier": "setStallThreshold", "parameters": "(int periodSecs, int bytesPerSecond)", "modifiers": "public", "return": "void", "signature": "void setStallThreshold(int periodSecs, int bytesPerSecond)", "full_signature": "public void setStallThreshold(int periodSecs, int bytesPerSecond)", "class_method_signature": "PeerGroup.setStallThreshold(int periodSecs, int bytesPerSecond)", "testcase": false, "constructor": false}, {"identifier": "startBlockChainDownloadFromPeer", "parameters": "(Peer peer)", "modifiers": "private", "return": "void", "signature": "void startBlockChainDownloadFromPeer(Peer peer)", "full_signature": "private void startBlockChainDownloadFromPeer(Peer peer)", "class_method_signature": "PeerGroup.startBlockChainDownloadFromPeer(Peer peer)", "testcase": false, "constructor": false}, {"identifier": "waitForPeers", "parameters": "(final int numPeers)", "modifiers": "public", "return": "ListenableFuture<List<Peer>>", "signature": "ListenableFuture<List<Peer>> waitForPeers(final int numPeers)", "full_signature": "public ListenableFuture<List<Peer>> waitForPeers(final int numPeers)", "class_method_signature": "PeerGroup.waitForPeers(final int numPeers)", "testcase": false, "constructor": false}, {"identifier": "waitForPeersOfVersion", "parameters": "(final int numPeers, final long protocolVersion)", "modifiers": "public", "return": "ListenableFuture<List<Peer>>", "signature": "ListenableFuture<List<Peer>> waitForPeersOfVersion(final int numPeers, final long protocolVersion)", "full_signature": "public ListenableFuture<List<Peer>> waitForPeersOfVersion(final int numPeers, final long protocolVersion)", "class_method_signature": "PeerGroup.waitForPeersOfVersion(final int numPeers, final long protocolVersion)", "testcase": false, "constructor": false}, {"identifier": "findPeersOfAtLeastVersion", "parameters": "(long protocolVersion)", "modifiers": "public", "return": "List<Peer>", "signature": "List<Peer> findPeersOfAtLeastVersion(long protocolVersion)", "full_signature": "public List<Peer> findPeersOfAtLeastVersion(long protocolVersion)", "class_method_signature": "PeerGroup.findPeersOfAtLeastVersion(long protocolVersion)", "testcase": false, "constructor": false}, {"identifier": "waitForPeersWithServiceMask", "parameters": "(final int numPeers, final int mask)", "modifiers": "public", "return": "ListenableFuture<List<Peer>>", "signature": "ListenableFuture<List<Peer>> waitForPeersWithServiceMask(final int numPeers, final int mask)", "full_signature": "public ListenableFuture<List<Peer>> waitForPeersWithServiceMask(final int numPeers, final int mask)", "class_method_signature": "PeerGroup.waitForPeersWithServiceMask(final int numPeers, final int mask)", "testcase": false, "constructor": false}, {"identifier": "findPeersWithServiceMask", "parameters": "(int mask)", "modifiers": "public", "return": "List<Peer>", "signature": "List<Peer> findPeersWithServiceMask(int mask)", "full_signature": "public List<Peer> findPeersWithServiceMask(int mask)", "class_method_signature": "PeerGroup.findPeersWithServiceMask(int mask)", "testcase": false, "constructor": false}, {"identifier": "getMinBroadcastConnections", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMinBroadcastConnections()", "full_signature": "public int getMinBroadcastConnections()", "class_method_signature": "PeerGroup.getMinBroadcastConnections()", "testcase": false, "constructor": false}, {"identifier": "setMinBroadcastConnections", "parameters": "(int value)", "modifiers": "public", "return": "void", "signature": "void setMinBroadcastConnections(int value)", "full_signature": "public void setMinBroadcastConnections(int value)", "class_method_signature": "PeerGroup.setMinBroadcastConnections(int value)", "testcase": false, "constructor": false}, {"identifier": "broadcastTransaction", "parameters": "(final Transaction tx)", "modifiers": "@Override public", "return": "TransactionBroadcast", "signature": "TransactionBroadcast broadcastTransaction(final Transaction tx)", "full_signature": "@Override public TransactionBroadcast broadcastTransaction(final Transaction tx)", "class_method_signature": "PeerGroup.broadcastTransaction(final Transaction tx)", "testcase": false, "constructor": false}, {"identifier": "broadcastTransaction", "parameters": "(final Transaction tx, final int minConnections)", "modifiers": "public", "return": "TransactionBroadcast", "signature": "TransactionBroadcast broadcastTransaction(final Transaction tx, final int minConnections)", "full_signature": "public TransactionBroadcast broadcastTransaction(final Transaction tx, final int minConnections)", "class_method_signature": "PeerGroup.broadcastTransaction(final Transaction tx, final int minConnections)", "testcase": false, "constructor": false}, {"identifier": "getPingIntervalMsec", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long getPingIntervalMsec()", "full_signature": "public long getPingIntervalMsec()", "class_method_signature": "PeerGroup.getPingIntervalMsec()", "testcase": false, "constructor": false}, {"identifier": "setPingIntervalMsec", "parameters": "(long pingIntervalMsec)", "modifiers": "public", "return": "void", "signature": "void setPingIntervalMsec(long pingIntervalMsec)", "full_signature": "public void setPingIntervalMsec(long pingIntervalMsec)", "class_method_signature": "PeerGroup.setPingIntervalMsec(long pingIntervalMsec)", "testcase": false, "constructor": false}, {"identifier": "setMinRequiredProtocolVersion", "parameters": "(int minRequiredProtocolVersion)", "modifiers": "public", "return": "void", "signature": "void setMinRequiredProtocolVersion(int minRequiredProtocolVersion)", "full_signature": "public void setMinRequiredProtocolVersion(int minRequiredProtocolVersion)", "class_method_signature": "PeerGroup.setMinRequiredProtocolVersion(int minRequiredProtocolVersion)", "testcase": false, "constructor": false}, {"identifier": "getMinRequiredProtocolVersion", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMinRequiredProtocolVersion()", "full_signature": "public int getMinRequiredProtocolVersion()", "class_method_signature": "PeerGroup.getMinRequiredProtocolVersion()", "testcase": false, "constructor": false}, {"identifier": "getMostCommonChainHeight", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMostCommonChainHeight()", "full_signature": "public int getMostCommonChainHeight()", "class_method_signature": "PeerGroup.getMostCommonChainHeight()", "testcase": false, "constructor": false}, {"identifier": "getMostCommonChainHeight", "parameters": "(final List<Peer> peers)", "modifiers": "public static", "return": "int", "signature": "int getMostCommonChainHeight(final List<Peer> peers)", "full_signature": "public static int getMostCommonChainHeight(final List<Peer> peers)", "class_method_signature": "PeerGroup.getMostCommonChainHeight(final List<Peer> peers)", "testcase": false, "constructor": false}, {"identifier": "selectDownloadPeer", "parameters": "(List<Peer> peers)", "modifiers": "@Nullable protected", "return": "Peer", "signature": "Peer selectDownloadPeer(List<Peer> peers)", "full_signature": "@Nullable protected Peer selectDownloadPeer(List<Peer> peers)", "class_method_signature": "PeerGroup.selectDownloadPeer(List<Peer> peers)", "testcase": false, "constructor": false}, {"identifier": "getDownloadPeer", "parameters": "()", "modifiers": "public", "return": "Peer", "signature": "Peer getDownloadPeer()", "full_signature": "public Peer getDownloadPeer()", "class_method_signature": "PeerGroup.getDownloadPeer()", "testcase": false, "constructor": false}, {"identifier": "getMaxPeersToDiscoverCount", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getMaxPeersToDiscoverCount()", "full_signature": "public int getMaxPeersToDiscoverCount()", "class_method_signature": "PeerGroup.getMaxPeersToDiscoverCount()", "testcase": false, "constructor": false}, {"identifier": "setMaxPeersToDiscoverCount", "parameters": "(int maxPeersToDiscoverCount)", "modifiers": "public", "return": "void", "signature": "void setMaxPeersToDiscoverCount(int maxPeersToDiscoverCount)", "full_signature": "public void setMaxPeersToDiscoverCount(int maxPeersToDiscoverCount)", "class_method_signature": "PeerGroup.setMaxPeersToDiscoverCount(int maxPeersToDiscoverCount)", "testcase": false, "constructor": false}, {"identifier": "getUseLocalhostPeerWhenPossible", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean getUseLocalhostPeerWhenPossible()", "full_signature": "public boolean getUseLocalhostPeerWhenPossible()", "class_method_signature": "PeerGroup.getUseLocalhostPeerWhenPossible()", "testcase": false, "constructor": false}, {"identifier": "setUseLocalhostPeerWhenPossible", "parameters": "(boolean useLocalhostPeerWhenPossible)", "modifiers": "public", "return": "void", "signature": "void setUseLocalhostPeerWhenPossible(boolean useLocalhostPeerWhenPossible)", "full_signature": "public void setUseLocalhostPeerWhenPossible(boolean useLocalhostPeerWhenPossible)", "class_method_signature": "PeerGroup.setUseLocalhostPeerWhenPossible(boolean useLocalhostPeerWhenPossible)", "testcase": false, "constructor": false}, {"identifier": "isRunning", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isRunning()", "full_signature": "public boolean isRunning()", "class_method_signature": "PeerGroup.isRunning()", "testcase": false, "constructor": false}, {"identifier": "setBloomFilteringEnabled", "parameters": "(boolean bloomFilteringEnabled)", "modifiers": "public", "return": "void", "signature": "void setBloomFilteringEnabled(boolean bloomFilteringEnabled)", "full_signature": "public void setBloomFilteringEnabled(boolean bloomFilteringEnabled)", "class_method_signature": "PeerGroup.setBloomFilteringEnabled(boolean bloomFilteringEnabled)", "testcase": false, "constructor": false}, {"identifier": "isBloomFilteringEnabled", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isBloomFilteringEnabled()", "full_signature": "public boolean isBloomFilteringEnabled()", "class_method_signature": "PeerGroup.isBloomFilteringEnabled()", "testcase": false, "constructor": false}], "file": "core/src/main/java/org/ulordj/core/PeerGroup.java"}, "focal_method": {"identifier": "waitForPeersOfVersion", "parameters": "(final int numPeers, final long protocolVersion)", "modifiers": "public", "return": "ListenableFuture<List<Peer>>", "body": "public ListenableFuture<List<Peer>> waitForPeersOfVersion(final int numPeers, final long protocolVersion) {\n        List<Peer> foundPeers = findPeersOfAtLeastVersion(protocolVersion);\n        if (foundPeers.size() >= numPeers) {\n            return Futures.immediateFuture(foundPeers);\n        }\n        final SettableFuture<List<Peer>> future = SettableFuture.create();\n        addConnectedEventListener(new PeerConnectedEventListener() {\n            @Override\n            public void onPeerConnected(Peer peer, int peerCount) {\n                final List<Peer> peers = findPeersOfAtLeastVersion(protocolVersion);\n                if (peers.size() >= numPeers) {\n                    future.set(peers);\n                    removeConnectedEventListener(this);\n                }\n            }\n        });\n        return future;\n    }", "signature": "ListenableFuture<List<Peer>> waitForPeersOfVersion(final int numPeers, final long protocolVersion)", "full_signature": "public ListenableFuture<List<Peer>> waitForPeersOfVersion(final int numPeers, final long protocolVersion)", "class_method_signature": "PeerGroup.waitForPeersOfVersion(final int numPeers, final long protocolVersion)", "testcase": false, "constructor": false, "invocations": ["findPeersOfAtLeastVersion", "size", "immediateFuture", "create", "addConnectedEventListener", "findPeersOfAtLeastVersion", "size", "set", "removeConnectedEventListener"]}, "repository": {"repo_id": 133357466, "url": "https://github.com/UlordChain/ulordj", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 23, "size": 7129, "license": "licensed"}}