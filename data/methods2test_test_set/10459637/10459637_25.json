{"test_class": {"identifier": "IPv4Test", "superclass": "", "interfaces": "", "fields": [], "file": "network-level/fl-ho-nl/src/test/java/net/floodlightcontroller/packet/IPv4Test.java"}, "test_case": {"identifier": "testSerialize", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSerialize() {\n        byte[] expected = new byte[] { 0x45, 0x00, 0x00, 0x14, 0x5e, 0x4e,\n                0x00, 0x00, 0x3f, 0x06, 0x31, 0x2e, (byte) 0xac, 0x18,\n                0x4a, (byte) 0xdf, (byte) 0xab, 0x40, 0x4a, 0x30 };\n        IPv4 packet = new IPv4()\n            .setIdentification((short) 24142)\n            .setTtl((byte) 63)\n            .setProtocol((byte) 0x06)\n            .setSourceAddress(\"172.24.74.223\")\n            .setDestinationAddress(\"171.64.74.48\");\n        byte[] actual = packet.serialize();\n        assertTrue(Arrays.equals(expected, actual));\n    }", "signature": "void testSerialize()", "full_signature": "@Test public void testSerialize()", "class_method_signature": "IPv4Test.testSerialize()", "testcase": true, "constructor": false, "invocations": ["setDestinationAddress", "setSourceAddress", "setProtocol", "setTtl", "setIdentification", "serialize", "assertTrue", "equals"]}, "focal_class": {"identifier": "IPv4", "superclass": "extends BasePacket", "interfaces": "", "fields": [{"original_string": "public static final byte PROTOCOL_ICMP = 0x1;", "modifier": "public static final", "type": "byte", "declarator": "PROTOCOL_ICMP = 0x1", "var_name": "PROTOCOL_ICMP"}, {"original_string": "public static final byte PROTOCOL_TCP = 0x6;", "modifier": "public static final", "type": "byte", "declarator": "PROTOCOL_TCP = 0x6", "var_name": "PROTOCOL_TCP"}, {"original_string": "public static final byte PROTOCOL_UDP = 0x11;", "modifier": "public static final", "type": "byte", "declarator": "PROTOCOL_UDP = 0x11", "var_name": "PROTOCOL_UDP"}, {"original_string": "public static Map<Byte, Class<? extends IPacket>> protocolClassMap;", "modifier": "public static", "type": "Map<Byte, Class<? extends IPacket>>", "declarator": "protocolClassMap", "var_name": "protocolClassMap"}, {"original_string": "protected byte version;", "modifier": "protected", "type": "byte", "declarator": "version", "var_name": "version"}, {"original_string": "protected byte headerLength;", "modifier": "protected", "type": "byte", "declarator": "headerLength", "var_name": "headerLength"}, {"original_string": "protected byte diffServ;", "modifier": "protected", "type": "byte", "declarator": "diffServ", "var_name": "diffServ"}, {"original_string": "protected short totalLength;", "modifier": "protected", "type": "short", "declarator": "totalLength", "var_name": "totalLength"}, {"original_string": "protected short identification;", "modifier": "protected", "type": "short", "declarator": "identification", "var_name": "identification"}, {"original_string": "protected byte flags;", "modifier": "protected", "type": "byte", "declarator": "flags", "var_name": "flags"}, {"original_string": "protected short fragmentOffset;", "modifier": "protected", "type": "short", "declarator": "fragmentOffset", "var_name": "fragmentOffset"}, {"original_string": "protected byte ttl;", "modifier": "protected", "type": "byte", "declarator": "ttl", "var_name": "ttl"}, {"original_string": "protected byte protocol;", "modifier": "protected", "type": "byte", "declarator": "protocol", "var_name": "protocol"}, {"original_string": "protected short checksum;", "modifier": "protected", "type": "short", "declarator": "checksum", "var_name": "checksum"}, {"original_string": "protected int sourceAddress;", "modifier": "protected", "type": "int", "declarator": "sourceAddress", "var_name": "sourceAddress"}, {"original_string": "protected int destinationAddress;", "modifier": "protected", "type": "int", "declarator": "destinationAddress", "var_name": "destinationAddress"}, {"original_string": "protected byte[] options;", "modifier": "protected", "type": "byte[]", "declarator": "options", "var_name": "options"}, {"original_string": "protected boolean isTruncated;", "modifier": "protected", "type": "boolean", "declarator": "isTruncated", "var_name": "isTruncated"}], "methods": [{"identifier": "IPv4", "parameters": "()", "modifiers": "public", "return": "", "signature": " IPv4()", "full_signature": "public  IPv4()", "class_method_signature": "IPv4.IPv4()", "testcase": false, "constructor": true}, {"identifier": "getVersion", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getVersion()", "full_signature": "public byte getVersion()", "class_method_signature": "IPv4.getVersion()", "testcase": false, "constructor": false}, {"identifier": "setVersion", "parameters": "(byte version)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setVersion(byte version)", "full_signature": "public IPv4 setVersion(byte version)", "class_method_signature": "IPv4.setVersion(byte version)", "testcase": false, "constructor": false}, {"identifier": "getHeaderLength", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getHeaderLength()", "full_signature": "public byte getHeaderLength()", "class_method_signature": "IPv4.getHeaderLength()", "testcase": false, "constructor": false}, {"identifier": "getDiffServ", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getDiffServ()", "full_signature": "public byte getDiffServ()", "class_method_signature": "IPv4.getDiffServ()", "testcase": false, "constructor": false}, {"identifier": "setDiffServ", "parameters": "(byte diffServ)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDiffServ(byte diffServ)", "full_signature": "public IPv4 setDiffServ(byte diffServ)", "class_method_signature": "IPv4.setDiffServ(byte diffServ)", "testcase": false, "constructor": false}, {"identifier": "getTotalLength", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getTotalLength()", "full_signature": "public short getTotalLength()", "class_method_signature": "IPv4.getTotalLength()", "testcase": false, "constructor": false}, {"identifier": "getIdentification", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getIdentification()", "full_signature": "public short getIdentification()", "class_method_signature": "IPv4.getIdentification()", "testcase": false, "constructor": false}, {"identifier": "isTruncated", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isTruncated()", "full_signature": "public boolean isTruncated()", "class_method_signature": "IPv4.isTruncated()", "testcase": false, "constructor": false}, {"identifier": "setTruncated", "parameters": "(boolean isTruncated)", "modifiers": "public", "return": "void", "signature": "void setTruncated(boolean isTruncated)", "full_signature": "public void setTruncated(boolean isTruncated)", "class_method_signature": "IPv4.setTruncated(boolean isTruncated)", "testcase": false, "constructor": false}, {"identifier": "setIdentification", "parameters": "(short identification)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setIdentification(short identification)", "full_signature": "public IPv4 setIdentification(short identification)", "class_method_signature": "IPv4.setIdentification(short identification)", "testcase": false, "constructor": false}, {"identifier": "getFlags", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getFlags()", "full_signature": "public byte getFlags()", "class_method_signature": "IPv4.getFlags()", "testcase": false, "constructor": false}, {"identifier": "setFlags", "parameters": "(byte flags)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setFlags(byte flags)", "full_signature": "public IPv4 setFlags(byte flags)", "class_method_signature": "IPv4.setFlags(byte flags)", "testcase": false, "constructor": false}, {"identifier": "getFragmentOffset", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getFragmentOffset()", "full_signature": "public short getFragmentOffset()", "class_method_signature": "IPv4.getFragmentOffset()", "testcase": false, "constructor": false}, {"identifier": "setFragmentOffset", "parameters": "(short fragmentOffset)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setFragmentOffset(short fragmentOffset)", "full_signature": "public IPv4 setFragmentOffset(short fragmentOffset)", "class_method_signature": "IPv4.setFragmentOffset(short fragmentOffset)", "testcase": false, "constructor": false}, {"identifier": "getTtl", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getTtl()", "full_signature": "public byte getTtl()", "class_method_signature": "IPv4.getTtl()", "testcase": false, "constructor": false}, {"identifier": "setTtl", "parameters": "(byte ttl)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setTtl(byte ttl)", "full_signature": "public IPv4 setTtl(byte ttl)", "class_method_signature": "IPv4.setTtl(byte ttl)", "testcase": false, "constructor": false}, {"identifier": "getProtocol", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getProtocol()", "full_signature": "public byte getProtocol()", "class_method_signature": "IPv4.getProtocol()", "testcase": false, "constructor": false}, {"identifier": "setProtocol", "parameters": "(byte protocol)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setProtocol(byte protocol)", "full_signature": "public IPv4 setProtocol(byte protocol)", "class_method_signature": "IPv4.setProtocol(byte protocol)", "testcase": false, "constructor": false}, {"identifier": "getChecksum", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getChecksum()", "full_signature": "public short getChecksum()", "class_method_signature": "IPv4.getChecksum()", "testcase": false, "constructor": false}, {"identifier": "setChecksum", "parameters": "(short checksum)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setChecksum(short checksum)", "full_signature": "public IPv4 setChecksum(short checksum)", "class_method_signature": "IPv4.setChecksum(short checksum)", "testcase": false, "constructor": false}, {"identifier": "resetChecksum", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void resetChecksum()", "full_signature": "@Override public void resetChecksum()", "class_method_signature": "IPv4.resetChecksum()", "testcase": false, "constructor": false}, {"identifier": "getSourceAddress", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getSourceAddress()", "full_signature": "public int getSourceAddress()", "class_method_signature": "IPv4.getSourceAddress()", "testcase": false, "constructor": false}, {"identifier": "setSourceAddress", "parameters": "(int sourceAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setSourceAddress(int sourceAddress)", "full_signature": "public IPv4 setSourceAddress(int sourceAddress)", "class_method_signature": "IPv4.setSourceAddress(int sourceAddress)", "testcase": false, "constructor": false}, {"identifier": "setSourceAddress", "parameters": "(String sourceAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setSourceAddress(String sourceAddress)", "full_signature": "public IPv4 setSourceAddress(String sourceAddress)", "class_method_signature": "IPv4.setSourceAddress(String sourceAddress)", "testcase": false, "constructor": false}, {"identifier": "getDestinationAddress", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getDestinationAddress()", "full_signature": "public int getDestinationAddress()", "class_method_signature": "IPv4.getDestinationAddress()", "testcase": false, "constructor": false}, {"identifier": "setDestinationAddress", "parameters": "(int destinationAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDestinationAddress(int destinationAddress)", "full_signature": "public IPv4 setDestinationAddress(int destinationAddress)", "class_method_signature": "IPv4.setDestinationAddress(int destinationAddress)", "testcase": false, "constructor": false}, {"identifier": "setDestinationAddress", "parameters": "(String destinationAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDestinationAddress(String destinationAddress)", "full_signature": "public IPv4 setDestinationAddress(String destinationAddress)", "class_method_signature": "IPv4.setDestinationAddress(String destinationAddress)", "testcase": false, "constructor": false}, {"identifier": "getOptions", "parameters": "()", "modifiers": "public", "return": "byte[]", "signature": "byte[] getOptions()", "full_signature": "public byte[] getOptions()", "class_method_signature": "IPv4.getOptions()", "testcase": false, "constructor": false}, {"identifier": "setOptions", "parameters": "(byte[] options)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setOptions(byte[] options)", "full_signature": "public IPv4 setOptions(byte[] options)", "class_method_signature": "IPv4.setOptions(byte[] options)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "()", "modifiers": "public", "return": "byte[]", "signature": "byte[] serialize()", "full_signature": "public byte[] serialize()", "class_method_signature": "IPv4.serialize()", "testcase": false, "constructor": false}, {"identifier": "deserialize", "parameters": "(byte[] data, int offset, int length)", "modifiers": "@Override public", "return": "IPacket", "signature": "IPacket deserialize(byte[] data, int offset, int length)", "full_signature": "@Override public IPacket deserialize(byte[] data, int offset, int length)", "class_method_signature": "IPv4.deserialize(byte[] data, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "toIPv4Address", "parameters": "(String ipAddress)", "modifiers": "public static", "return": "int", "signature": "int toIPv4Address(String ipAddress)", "full_signature": "public static int toIPv4Address(String ipAddress)", "class_method_signature": "IPv4.toIPv4Address(String ipAddress)", "testcase": false, "constructor": false}, {"identifier": "toIPv4Address", "parameters": "(byte[] ipAddress)", "modifiers": "public static", "return": "int", "signature": "int toIPv4Address(byte[] ipAddress)", "full_signature": "public static int toIPv4Address(byte[] ipAddress)", "class_method_signature": "IPv4.toIPv4Address(byte[] ipAddress)", "testcase": false, "constructor": false}, {"identifier": "fromIPv4Address", "parameters": "(int ipAddress)", "modifiers": "public static", "return": "String", "signature": "String fromIPv4Address(int ipAddress)", "full_signature": "public static String fromIPv4Address(int ipAddress)", "class_method_signature": "IPv4.fromIPv4Address(int ipAddress)", "testcase": false, "constructor": false}, {"identifier": "fromIPv4AddressCollection", "parameters": "(Collection<Integer> ipAddresses)", "modifiers": "public static", "return": "String", "signature": "String fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "full_signature": "public static String fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "class_method_signature": "IPv4.fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "testcase": false, "constructor": false}, {"identifier": "toIPv4AddressBytes", "parameters": "(String ipAddress)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] toIPv4AddressBytes(String ipAddress)", "full_signature": "public static byte[] toIPv4AddressBytes(String ipAddress)", "class_method_signature": "IPv4.toIPv4AddressBytes(String ipAddress)", "testcase": false, "constructor": false}, {"identifier": "toIPv4AddressBytes", "parameters": "(int ipAddress)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] toIPv4AddressBytes(int ipAddress)", "full_signature": "public static byte[] toIPv4AddressBytes(int ipAddress)", "class_method_signature": "IPv4.toIPv4AddressBytes(int ipAddress)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "IPv4.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "IPv4.equals(Object obj)", "testcase": false, "constructor": false}], "file": "network-level/fl-ho-nl/src/main/java/net/floodlightcontroller/packet/IPv4.java"}, "focal_method": {"identifier": "serialize", "parameters": "()", "modifiers": "public", "return": "byte[]", "body": "public byte[] serialize() {\n        byte[] payloadData = null;\n        if (payload != null) {\n            payload.setParent(this);\n            payloadData = payload.serialize();\n        }\n\n        int optionsLength = 0;\n        if (this.options != null)\n            optionsLength = this.options.length / 4;\n        this.headerLength = (byte) (5 + optionsLength);\n\n        this.totalLength = (short) (this.headerLength * 4 + ((payloadData == null) ? 0\n                : payloadData.length));\n\n        byte[] data = new byte[this.totalLength];\n        ByteBuffer bb = ByteBuffer.wrap(data);\n\n        bb.put((byte) (((this.version & 0xf) << 4) | (this.headerLength & 0xf)));\n        bb.put(this.diffServ);\n        bb.putShort(this.totalLength);\n        bb.putShort(this.identification);\n        bb.putShort((short) (((this.flags & 0x7) << 13) | (this.fragmentOffset & 0x1fff)));\n        bb.put(this.ttl);\n        bb.put(this.protocol);\n        bb.putShort(this.checksum);\n        bb.putInt(this.sourceAddress);\n        bb.putInt(this.destinationAddress);\n        if (this.options != null)\n            bb.put(this.options);\n        if (payloadData != null)\n            bb.put(payloadData);\n\n        // compute checksum if needed\n        if (this.checksum == 0) {\n            bb.rewind();\n            int accumulation = 0;\n            for (int i = 0; i < this.headerLength * 2; ++i) {\n                accumulation += 0xffff & bb.getShort();\n            }\n            accumulation = ((accumulation >> 16) & 0xffff)\n                    + (accumulation & 0xffff);\n            this.checksum = (short) (~accumulation & 0xffff);\n            bb.putShort(10, this.checksum);\n        }\n        return data;\n    }", "signature": "byte[] serialize()", "full_signature": "public byte[] serialize()", "class_method_signature": "IPv4.serialize()", "testcase": false, "constructor": false, "invocations": ["setParent", "serialize", "wrap", "put", "put", "putShort", "putShort", "putShort", "put", "put", "putShort", "putInt", "putInt", "put", "put", "rewind", "getShort", "putShort"]}, "repository": {"repo_id": 10459637, "url": "https://github.com/rizard/geni-openflow-vertical-handover", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 7, "size": 33971, "license": "licensed"}}