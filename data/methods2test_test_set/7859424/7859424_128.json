{"test_class": {"identifier": "ExitingTimeManagerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Player player;", "modifier": "private", "type": "Player", "declarator": "player", "var_name": "player"}, {"original_string": "private ExitingTimeManager manager;", "modifier": "private", "type": "ExitingTimeManager", "declarator": "manager", "var_name": "manager"}, {"original_string": "private CoordinateSystem coords;", "modifier": "private", "type": "CoordinateSystem", "declarator": "coords", "var_name": "coords"}], "file": "src/edu/lclark/orego/time/ExitingTimeManagerTest.java"}, "test_case": {"identifier": "testCompareRest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testCompareRest() {\n\t\tplayer.setRemainingTime(10000);\n\t\tSearchNode root = player.getRoot();\n\t\tassertNotEquals(0, manager.getMsec());\n\t\troot.update(coords.at(\"a5\"), 1000, 1000);\n\t\tassertEquals(0, manager.getMsec(), .01);\n\t}", "signature": "void testCompareRest()", "full_signature": "@Test public void testCompareRest()", "class_method_signature": "ExitingTimeManagerTest.testCompareRest()", "testcase": true, "constructor": false, "invocations": ["setRemainingTime", "getRoot", "assertNotEquals", "getMsec", "update", "at", "assertEquals", "getMsec"]}, "focal_class": {"identifier": "ExitingTimeManager", "superclass": "", "interfaces": "implements TimeManager", "fields": [{"original_string": "private static final int SLICE_COUNT = 3;", "modifier": "private static final", "type": "int", "declarator": "SLICE_COUNT = 3", "var_name": "SLICE_COUNT"}, {"original_string": "private static final double TIME_CONSTANT = 0.20;", "modifier": "private static final", "type": "double", "declarator": "TIME_CONSTANT = 0.20", "var_name": "TIME_CONSTANT"}, {"original_string": "private final Board board;", "modifier": "private final", "type": "Board", "declarator": "board", "var_name": "board"}, {"original_string": "private int msecPerSlice;", "modifier": "private", "type": "int", "declarator": "msecPerSlice", "var_name": "msecPerSlice"}, {"original_string": "private int msecRemaining;", "modifier": "private", "type": "int", "declarator": "msecRemaining", "var_name": "msecRemaining"}, {"original_string": "private final Player player;", "modifier": "private final", "type": "Player", "declarator": "player", "var_name": "player"}, {"original_string": "private int rollover;", "modifier": "private", "type": "int", "declarator": "rollover", "var_name": "rollover"}, {"original_string": "private int slicesRemaining;", "modifier": "private", "type": "int", "declarator": "slicesRemaining", "var_name": "slicesRemaining"}], "methods": [{"identifier": "confidence", "parameters": "(float winrateA, double runsA,\n\t\t\tfloat winrateB, double runsB)", "modifiers": "private static", "return": "double", "signature": "double confidence(float winrateA, double runsA,\n\t\t\tfloat winrateB, double runsB)", "full_signature": "private static double confidence(float winrateA, double runsA,\n\t\t\tfloat winrateB, double runsB)", "class_method_signature": "ExitingTimeManager.confidence(float winrateA, double runsA,\n\t\t\tfloat winrateB, double runsB)", "testcase": false, "constructor": false}, {"identifier": "ExitingTimeManager", "parameters": "(Player player)", "modifiers": "public", "return": "", "signature": " ExitingTimeManager(Player player)", "full_signature": "public  ExitingTimeManager(Player player)", "class_method_signature": "ExitingTimeManager.ExitingTimeManager(Player player)", "testcase": false, "constructor": true}, {"identifier": "confidenceBestVsRest", "parameters": "()", "modifiers": "private", "return": "double", "signature": "double confidenceBestVsRest()", "full_signature": "private double confidenceBestVsRest()", "class_method_signature": "ExitingTimeManager.confidenceBestVsRest()", "testcase": false, "constructor": false}, {"identifier": "createSlices", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void createSlices()", "full_signature": "private void createSlices()", "class_method_signature": "ExitingTimeManager.createSlices()", "testcase": false, "constructor": false}, {"identifier": "getMsec", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getMsec()", "full_signature": "@Override public int getMsec()", "class_method_signature": "ExitingTimeManager.getMsec()", "testcase": false, "constructor": false}, {"identifier": "getMsecPerMove", "parameters": "()", "modifiers": "private", "return": "int", "signature": "int getMsecPerMove()", "full_signature": "private int getMsecPerMove()", "class_method_signature": "ExitingTimeManager.getMsecPerMove()", "testcase": false, "constructor": false}, {"identifier": "getRollover", "parameters": "()", "modifiers": "", "return": "int", "signature": "int getRollover()", "full_signature": " int getRollover()", "class_method_signature": "ExitingTimeManager.getRollover()", "testcase": false, "constructor": false}, {"identifier": "setRemainingSeconds", "parameters": "(int seconds)", "modifiers": "@Override public", "return": "void", "signature": "void setRemainingSeconds(int seconds)", "full_signature": "@Override public void setRemainingSeconds(int seconds)", "class_method_signature": "ExitingTimeManager.setRemainingSeconds(int seconds)", "testcase": false, "constructor": false}, {"identifier": "startNewTurn", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void startNewTurn()", "full_signature": "@Override public void startNewTurn()", "class_method_signature": "ExitingTimeManager.startNewTurn()", "testcase": false, "constructor": false}], "file": "src/edu/lclark/orego/time/ExitingTimeManager.java"}, "focal_method": {"identifier": "getMsec", "parameters": "()", "modifiers": "@Override public", "return": "int", "body": "@Override\n\tpublic int getMsec() {\n\t\tassert player.shouldKeepRunning() == false;\n\t\tif (slicesRemaining == 0) {\n\t\t\trollover = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tif (slicesRemaining < SLICE_COUNT && confidenceBestVsRest() > 0.99) {\n\t\t\trollover = slicesRemaining * msecPerSlice;\n\t\t\treturn 0;\n\t\t}\n\t\tslicesRemaining--;\n\t\treturn msecPerSlice;\n\t}", "signature": "int getMsec()", "full_signature": "@Override public int getMsec()", "class_method_signature": "ExitingTimeManager.getMsec()", "testcase": false, "constructor": false, "invocations": ["shouldKeepRunning", "confidenceBestVsRest"]}, "repository": {"repo_id": 7859424, "url": "https://github.com/Orego/Orego", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 35, "size": 1341444, "license": "licensed"}}