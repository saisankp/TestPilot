{"test_class": {"identifier": "TracingMessagePostProcessorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "TraceContext grandparent = TraceContext.newBuilder().traceId(1L).spanId(1L).sampled(true).build();", "modifier": "", "type": "TraceContext", "declarator": "grandparent = TraceContext.newBuilder().traceId(1L).spanId(1L).sampled(true).build()", "var_name": "grandparent"}, {"original_string": "TraceContext parent = grandparent.toBuilder().parentId(grandparent.spanId()).spanId(2L).build();", "modifier": "", "type": "TraceContext", "declarator": "parent = grandparent.toBuilder().parentId(grandparent.spanId()).spanId(2L).build()", "var_name": "parent"}, {"original_string": "StrictCurrentTraceContext currentTraceContext = StrictCurrentTraceContext.create();", "modifier": "", "type": "StrictCurrentTraceContext", "declarator": "currentTraceContext = StrictCurrentTraceContext.create()", "var_name": "currentTraceContext"}, {"original_string": "TestSpanHandler spans = new TestSpanHandler();", "modifier": "", "type": "TestSpanHandler", "declarator": "spans = new TestSpanHandler()", "var_name": "spans"}, {"original_string": "Tracing tracing = Tracing.newBuilder()\n    .currentTraceContext(currentTraceContext)\n    .addSpanHandler(spans)\n    .propagationFactory(BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n      .add(BaggagePropagationConfig.SingleBaggageField.newBuilder(BAGGAGE_FIELD)\n        .addKeyName(BAGGAGE_FIELD_KEY)\n        .build()).build())\n    .build();", "modifier": "", "type": "Tracing", "declarator": "tracing = Tracing.newBuilder()\n    .currentTraceContext(currentTraceContext)\n    .addSpanHandler(spans)\n    .propagationFactory(BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n      .add(BaggagePropagationConfig.SingleBaggageField.newBuilder(BAGGAGE_FIELD)\n        .addKeyName(BAGGAGE_FIELD_KEY)\n        .build()).build())\n    .build()", "var_name": "tracing"}, {"original_string": "TracingMessagePostProcessor tracingMessagePostProcessor = new TracingMessagePostProcessor(\n    SpringRabbitTracing.newBuilder(tracing).remoteServiceName(\"my-exchange\").build()\n  );", "modifier": "", "type": "TracingMessagePostProcessor", "declarator": "tracingMessagePostProcessor = new TracingMessagePostProcessor(\n    SpringRabbitTracing.newBuilder(tracing).remoteServiceName(\"my-exchange\").build()\n  )", "var_name": "tracingMessagePostProcessor"}], "file": "instrumentation/spring-rabbit/src/test/java/brave/spring/rabbit/TracingMessagePostProcessorTest.java"}, "test_case": {"identifier": "should_resume_headers", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void should_resume_headers() {\n    Message message = MessageBuilder.withBody(new byte[0]).build();\n    message.getMessageProperties().setHeader(\"b3\", B3SingleFormat.writeB3SingleFormat(parent));\n\n    Message postProcessMessage = tracingMessagePostProcessor.postProcessMessage(message);\n\n    assertThat(spans.get(0).parentId()).isEqualTo(parent.spanIdString());\n    Map<String, Object> headers = postProcessMessage.getMessageProperties().getHeaders();\n    assertThat(headers.get(\"b3\").toString()).endsWith(\"-\" + spans.get(0).id() + \"-1\");\n  }", "signature": "void should_resume_headers()", "full_signature": "@Test public void should_resume_headers()", "class_method_signature": "TracingMessagePostProcessorTest.should_resume_headers()", "testcase": true, "constructor": false, "invocations": ["build", "withBody", "setHeader", "getMessageProperties", "writeB3SingleFormat", "postProcessMessage", "isEqualTo", "assertThat", "parentId", "get", "spanIdString", "getHeaders", "getMessageProperties", "endsWith", "assertThat", "toString", "get", "id", "get"]}, "focal_class": {"identifier": "TracingMessagePostProcessor", "superclass": "", "interfaces": "implements MessagePostProcessor", "fields": [{"original_string": "final SpringRabbitTracing springRabbitTracing;", "modifier": "final", "type": "SpringRabbitTracing", "declarator": "springRabbitTracing", "var_name": "springRabbitTracing"}, {"original_string": "final Tracing tracing;", "modifier": "final", "type": "Tracing", "declarator": "tracing", "var_name": "tracing"}, {"original_string": "final Tracer tracer;", "modifier": "final", "type": "Tracer", "declarator": "tracer", "var_name": "tracer"}, {"original_string": "final CurrentTraceContext currentTraceContext;", "modifier": "final", "type": "CurrentTraceContext", "declarator": "currentTraceContext", "var_name": "currentTraceContext"}, {"original_string": "final TraceContext.Extractor<MessageProducerRequest> extractor;", "modifier": "final", "type": "TraceContext.Extractor<MessageProducerRequest>", "declarator": "extractor", "var_name": "extractor"}, {"original_string": "final SamplerFunction<MessagingRequest> sampler;", "modifier": "final", "type": "SamplerFunction<MessagingRequest>", "declarator": "sampler", "var_name": "sampler"}, {"original_string": "final Injector<MessageProducerRequest> injector;", "modifier": "final", "type": "Injector<MessageProducerRequest>", "declarator": "injector", "var_name": "injector"}, {"original_string": "@Nullable final String remoteServiceName;", "modifier": "@Nullable final", "type": "String", "declarator": "remoteServiceName", "var_name": "remoteServiceName"}], "methods": [{"identifier": "TracingMessagePostProcessor", "parameters": "(SpringRabbitTracing springRabbitTracing)", "modifiers": "", "return": "", "signature": " TracingMessagePostProcessor(SpringRabbitTracing springRabbitTracing)", "full_signature": "  TracingMessagePostProcessor(SpringRabbitTracing springRabbitTracing)", "class_method_signature": "TracingMessagePostProcessor.TracingMessagePostProcessor(SpringRabbitTracing springRabbitTracing)", "testcase": false, "constructor": true}, {"identifier": "postProcessMessage", "parameters": "(Message message)", "modifiers": "@Override public", "return": "Message", "signature": "Message postProcessMessage(Message message)", "full_signature": "@Override public Message postProcessMessage(Message message)", "class_method_signature": "TracingMessagePostProcessor.postProcessMessage(Message message)", "testcase": false, "constructor": false}], "file": "instrumentation/spring-rabbit/src/main/java/brave/spring/rabbit/TracingMessagePostProcessor.java"}, "focal_method": {"identifier": "postProcessMessage", "parameters": "(Message message)", "modifiers": "@Override public", "return": "Message", "body": "@Override public Message postProcessMessage(Message message) {\n    MessageProducerRequest request = new MessageProducerRequest(message);\n\n    TraceContext maybeParent = currentTraceContext.get();\n    // Unlike message consumers, we try current span before trying extraction. This is the proper\n    // order because the span in scope should take precedence over a potentially stale header entry.\n    //\n    // NOTE: Brave instrumentation used properly does not result in stale header entries, as we\n    // always clear message headers after reading.\n    Span span;\n    if (maybeParent == null) {\n      TraceContextOrSamplingFlags extracted =\n        springRabbitTracing.extractAndClearTraceIdHeaders(extractor, request, message);\n      span = springRabbitTracing.nextMessagingSpan(sampler, request, extracted);\n    } else { // If we have a span in scope assume headers were cleared before\n      span = tracer.newChild(maybeParent);\n    }\n\n    if (!span.isNoop()) {\n      span.kind(PRODUCER).name(\"publish\");\n      if (remoteServiceName != null) span.remoteServiceName(remoteServiceName);\n      // incur timestamp overhead only once\n      long timestamp = tracing.clock(span.context()).currentTimeMicroseconds();\n      span.start(timestamp).finish(timestamp);\n    }\n\n    injector.inject(span.context(), request);\n    return message;\n  }", "signature": "Message postProcessMessage(Message message)", "full_signature": "@Override public Message postProcessMessage(Message message)", "class_method_signature": "TracingMessagePostProcessor.postProcessMessage(Message message)", "testcase": false, "constructor": false, "invocations": ["get", "extractAndClearTraceIdHeaders", "nextMessagingSpan", "newChild", "isNoop", "name", "kind", "remoteServiceName", "currentTimeMicroseconds", "clock", "context", "finish", "start", "inject", "context"]}, "repository": {"repo_id": 9278888, "url": "https://github.com/openzipkin/brave", "stars": 1754, "created": "4/7/2013 3:48:18 PM +00:00", "updates": "2020-01-26T11:52:41+00:00", "fork": "False", "license": "licensed"}}