{"test_class": {"identifier": "StackTraceSampleCoordinatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static ActorSystem system;", "modifier": "private static", "type": "ActorSystem", "declarator": "system", "var_name": "system"}, {"original_string": "private StackTraceSampleCoordinator coord;", "modifier": "private", "type": "StackTraceSampleCoordinator", "declarator": "coord", "var_name": "coord"}], "file": "flink-runtime-web/src/test/java/org/apache/flink/runtime/webmonitor/StackTraceSampleCoordinatorTest.java"}, "test_case": {"identifier": "testTriggerStackTraceSampleNotRunningTasks", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testTriggerStackTraceSampleNotRunningTasks() throws Exception {\n\t\tExecutionVertex[] vertices = new ExecutionVertex[] {\n\t\t\t\tmockExecutionVertex(new ExecutionAttemptID(), ExecutionState.RUNNING, true),\n\t\t\t\tmockExecutionVertex(new ExecutionAttemptID(), ExecutionState.DEPLOYING, true)\n\t\t};\n\n\t\tFuture<StackTraceSample> sampleFuture = coord.triggerStackTraceSample(\n\t\t\t\tvertices,\n\t\t\t\t1,\n\t\t\t\tnew FiniteDuration(100, TimeUnit.MILLISECONDS),\n\t\t\t\t0);\n\n\t\tassertTrue(sampleFuture.isCompleted());\n\t\tassertTrue(sampleFuture.failed().isCompleted());\n\n\t\tassertTrue(sampleFuture.failed().value().get().get() instanceof IllegalStateException);\n\t}", "signature": "void testTriggerStackTraceSampleNotRunningTasks()", "full_signature": "@Test public void testTriggerStackTraceSampleNotRunningTasks()", "class_method_signature": "StackTraceSampleCoordinatorTest.testTriggerStackTraceSampleNotRunningTasks()", "testcase": true, "constructor": false, "invocations": ["mockExecutionVertex", "mockExecutionVertex", "triggerStackTraceSample", "assertTrue", "isCompleted", "assertTrue", "isCompleted", "failed", "assertTrue", "get", "get", "value", "failed"]}, "focal_class": {"identifier": "StackTraceSampleCoordinator", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(StackTraceSampleCoordinator.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(StackTraceSampleCoordinator.class)", "var_name": "LOG"}, {"original_string": "private static final int NUM_GHOST_SAMPLE_IDS = 10;", "modifier": "private static final", "type": "int", "declarator": "NUM_GHOST_SAMPLE_IDS = 10", "var_name": "NUM_GHOST_SAMPLE_IDS"}, {"original_string": "private final Object lock = new Object();", "modifier": "private final", "type": "Object", "declarator": "lock = new Object()", "var_name": "lock"}, {"original_string": "private final ActorGateway responseActor;", "modifier": "private final", "type": "ActorGateway", "declarator": "responseActor", "var_name": "responseActor"}, {"original_string": "private final int sampleTimeout;", "modifier": "private final", "type": "int", "declarator": "sampleTimeout", "var_name": "sampleTimeout"}, {"original_string": "private final Map<Integer, PendingStackTraceSample> pendingSamples = new HashMap<>();", "modifier": "private final", "type": "Map<Integer, PendingStackTraceSample>", "declarator": "pendingSamples = new HashMap<>()", "var_name": "pendingSamples"}, {"original_string": "private final ArrayDeque<Integer> recentPendingSamples = new ArrayDeque<>(NUM_GHOST_SAMPLE_IDS);", "modifier": "private final", "type": "ArrayDeque<Integer>", "declarator": "recentPendingSamples = new ArrayDeque<>(NUM_GHOST_SAMPLE_IDS)", "var_name": "recentPendingSamples"}, {"original_string": "private int sampleIdCounter;", "modifier": "private", "type": "int", "declarator": "sampleIdCounter", "var_name": "sampleIdCounter"}, {"original_string": "private Timer timer;", "modifier": "private", "type": "Timer", "declarator": "timer", "var_name": "timer"}, {"original_string": "private boolean isShutDown;", "modifier": "private", "type": "boolean", "declarator": "isShutDown", "var_name": "isShutDown"}], "methods": [{"identifier": "StackTraceSampleCoordinator", "parameters": "(ActorSystem actorSystem, int sampleTimeout)", "modifiers": "public", "return": "", "signature": " StackTraceSampleCoordinator(ActorSystem actorSystem, int sampleTimeout)", "full_signature": "public  StackTraceSampleCoordinator(ActorSystem actorSystem, int sampleTimeout)", "class_method_signature": "StackTraceSampleCoordinator.StackTraceSampleCoordinator(ActorSystem actorSystem, int sampleTimeout)", "testcase": false, "constructor": true}, {"identifier": "triggerStackTraceSample", "parameters": "(\n\t\t\tExecutionVertex[] tasksToSample,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples,\n\t\t\tint maxStackTraceDepth)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "Future<StackTraceSample>", "signature": "Future<StackTraceSample> triggerStackTraceSample(\n\t\t\tExecutionVertex[] tasksToSample,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples,\n\t\t\tint maxStackTraceDepth)", "full_signature": "@SuppressWarnings(\"unchecked\") public Future<StackTraceSample> triggerStackTraceSample(\n\t\t\tExecutionVertex[] tasksToSample,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples,\n\t\t\tint maxStackTraceDepth)", "class_method_signature": "StackTraceSampleCoordinator.triggerStackTraceSample(\n\t\t\tExecutionVertex[] tasksToSample,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples,\n\t\t\tint maxStackTraceDepth)", "testcase": false, "constructor": false}, {"identifier": "cancelStackTraceSample", "parameters": "(int sampleId, Exception cause)", "modifiers": "public", "return": "void", "signature": "void cancelStackTraceSample(int sampleId, Exception cause)", "full_signature": "public void cancelStackTraceSample(int sampleId, Exception cause)", "class_method_signature": "StackTraceSampleCoordinator.cancelStackTraceSample(int sampleId, Exception cause)", "testcase": false, "constructor": false}, {"identifier": "shutDown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutDown()", "full_signature": "public void shutDown()", "class_method_signature": "StackTraceSampleCoordinator.shutDown()", "testcase": false, "constructor": false}, {"identifier": "collectStackTraces", "parameters": "(\n\t\t\tint sampleId,\n\t\t\tExecutionAttemptID executionId,\n\t\t\tList<StackTraceElement[]> stackTraces)", "modifiers": "public", "return": "void", "signature": "void collectStackTraces(\n\t\t\tint sampleId,\n\t\t\tExecutionAttemptID executionId,\n\t\t\tList<StackTraceElement[]> stackTraces)", "full_signature": "public void collectStackTraces(\n\t\t\tint sampleId,\n\t\t\tExecutionAttemptID executionId,\n\t\t\tList<StackTraceElement[]> stackTraces)", "class_method_signature": "StackTraceSampleCoordinator.collectStackTraces(\n\t\t\tint sampleId,\n\t\t\tExecutionAttemptID executionId,\n\t\t\tList<StackTraceElement[]> stackTraces)", "testcase": false, "constructor": false}, {"identifier": "rememberRecentSampleId", "parameters": "(int sampleId)", "modifiers": "private", "return": "void", "signature": "void rememberRecentSampleId(int sampleId)", "full_signature": "private void rememberRecentSampleId(int sampleId)", "class_method_signature": "StackTraceSampleCoordinator.rememberRecentSampleId(int sampleId)", "testcase": false, "constructor": false}, {"identifier": "getNumberOfPendingSamples", "parameters": "()", "modifiers": "", "return": "int", "signature": "int getNumberOfPendingSamples()", "full_signature": " int getNumberOfPendingSamples()", "class_method_signature": "StackTraceSampleCoordinator.getNumberOfPendingSamples()", "testcase": false, "constructor": false}], "file": "flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/StackTraceSampleCoordinator.java"}, "focal_method": {"identifier": "triggerStackTraceSample", "parameters": "(\n\t\t\tExecutionVertex[] tasksToSample,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples,\n\t\t\tint maxStackTraceDepth)", "modifiers": "@SuppressWarnings(\"unchecked\") public", "return": "Future<StackTraceSample>", "body": "@SuppressWarnings(\"unchecked\")\n\tpublic Future<StackTraceSample> triggerStackTraceSample(\n\t\t\tExecutionVertex[] tasksToSample,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples,\n\t\t\tint maxStackTraceDepth) {\n\n\t\tcheckNotNull(tasksToSample, \"Tasks to sample\");\n\t\tcheckArgument(tasksToSample.length >= 1, \"No tasks to sample\");\n\t\tcheckArgument(numSamples >= 1, \"No number of samples\");\n\t\tcheckArgument(maxStackTraceDepth >= 0, \"Negative maximum stack trace depth\");\n\n\t\t// Execution IDs of running tasks\n\t\tExecutionAttemptID[] triggerIds = new ExecutionAttemptID[tasksToSample.length];\n\n\t\t// Check that all tasks are RUNNING before triggering anything. The\n\t\t// triggering can still fail.\n\t\tfor (int i = 0; i < triggerIds.length; i++) {\n\t\t\tExecution execution = tasksToSample[i].getCurrentExecutionAttempt();\n\t\t\tif (execution != null && execution.getState() == ExecutionState.RUNNING) {\n\t\t\t\ttriggerIds[i] = execution.getAttemptId();\n\t\t\t} else {\n\t\t\t\tPromise failedPromise = new scala.concurrent.impl.Promise.DefaultPromise<>()\n\t\t\t\t\t\t.failure(new IllegalStateException(\"Task \" + tasksToSample[i]\n\t\t\t\t\t\t\t\t.getTaskNameWithSubtaskIndex() + \" is not running.\"));\n\t\t\t\treturn failedPromise.future();\n\t\t\t}\n\t\t}\n\n\t\tsynchronized (lock) {\n\t\t\tif (isShutDown) {\n\t\t\t\tPromise failedPromise = new scala.concurrent.impl.Promise.DefaultPromise<>()\n\t\t\t\t\t\t.failure(new IllegalStateException(\"Shut down\"));\n\t\t\t\treturn failedPromise.future();\n\t\t\t}\n\n\t\t\tif (timer == null) {\n\t\t\t\ttimer = new Timer(\"Stack trace sample coordinator timer\");\n\t\t\t}\n\n\t\t\tint sampleId = sampleIdCounter++;\n\n\t\t\tLOG.debug(\"Triggering stack trace sample {}\", sampleId);\n\n\t\t\tfinal PendingStackTraceSample pending = new PendingStackTraceSample(\n\t\t\t\t\tsampleId, triggerIds);\n\n\t\t\t// Discard the sample if it takes too long. We don't send cancel\n\t\t\t// messages to the task managers, but only wait for the responses\n\t\t\t// and then ignore them.\n\t\t\tlong expectedDuration = numSamples * delayBetweenSamples.toMillis();\n\t\t\tlong discardDelay = expectedDuration + sampleTimeout;\n\n\t\t\tTimerTask discardTask = new TimerTask() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsynchronized (lock) {\n\t\t\t\t\t\t\tif (!pending.isDiscarded()) {\n\t\t\t\t\t\t\t\tLOG.info(\"Sample {} expired before completing\",\n\t\t\t\t\t\t\t\t\t\tpending.getSampleId());\n\n\t\t\t\t\t\t\t\tpending.discard(new RuntimeException(\"Time out\"));\n\t\t\t\t\t\t\t\tif (pendingSamples.remove(pending.getSampleId()) != null) {\n\t\t\t\t\t\t\t\t\trememberRecentSampleId(pending.getSampleId());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tLOG.error(\"Exception while handling sample timeout\", t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Add the pending sample before scheduling the discard task to\n\t\t\t// prevent races with removing it again.\n\t\t\tpendingSamples.put(sampleId, pending);\n\n\t\t\ttimer.schedule(discardTask, discardDelay);\n\n\t\t\tboolean success = true;\n\t\t\ttry {\n\t\t\t\t// Trigger all samples\n\t\t\t\tfor (int i = 0; i < tasksToSample.length; i++) {\n\t\t\t\t\tTriggerStackTraceSample msg = new TriggerStackTraceSample(\n\t\t\t\t\t\t\tsampleId,\n\t\t\t\t\t\t\ttriggerIds[i],\n\t\t\t\t\t\t\tnumSamples,\n\t\t\t\t\t\t\tdelayBetweenSamples,\n\t\t\t\t\t\t\tmaxStackTraceDepth);\n\n\t\t\t\t\tif (!tasksToSample[i].sendMessageToCurrentExecution(\n\t\t\t\t\t\t\tmsg,\n\t\t\t\t\t\t\ttriggerIds[i],\n\t\t\t\t\t\t\tresponseActor)) {\n\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pending.getStackTraceSampleFuture();\n\t\t\t} finally {\n\t\t\t\tif (!success) {\n\t\t\t\t\tpending.discard(new RuntimeException(\"Failed to trigger sample, \" +\n\t\t\t\t\t\t\t\"because task has been reset.\"));\n\t\t\t\t\tpendingSamples.remove(sampleId);\n\t\t\t\t\trememberRecentSampleId(sampleId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "signature": "Future<StackTraceSample> triggerStackTraceSample(\n\t\t\tExecutionVertex[] tasksToSample,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples,\n\t\t\tint maxStackTraceDepth)", "full_signature": "@SuppressWarnings(\"unchecked\") public Future<StackTraceSample> triggerStackTraceSample(\n\t\t\tExecutionVertex[] tasksToSample,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples,\n\t\t\tint maxStackTraceDepth)", "class_method_signature": "StackTraceSampleCoordinator.triggerStackTraceSample(\n\t\t\tExecutionVertex[] tasksToSample,\n\t\t\tint numSamples,\n\t\t\tFiniteDuration delayBetweenSamples,\n\t\t\tint maxStackTraceDepth)", "testcase": false, "constructor": false, "invocations": ["checkNotNull", "checkArgument", "checkArgument", "checkArgument", "getCurrentExecutionAttempt", "getState", "getAttemptId", "failure", "getTaskNameWithSubtaskIndex", "future", "failure", "future", "debug", "toMillis", "isDiscarded", "info", "getSampleId", "discard", "remove", "getSampleId", "rememberRecentSampleId", "getSampleId", "error", "put", "schedule", "sendMessageToCurrentExecution", "getStackTraceSampleFuture", "discard", "remove", "rememberRecentSampleId"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}