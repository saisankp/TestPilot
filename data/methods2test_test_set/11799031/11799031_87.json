{"test_class": {"identifier": "GeoTiffUtilsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static GridDataset daymetGridDataSet;", "modifier": "static", "type": "GridDataset", "declarator": "daymetGridDataSet", "var_name": "daymetGridDataSet"}, {"original_string": "static GridDataset prismGridDataSet;", "modifier": "static", "type": "GridDataset", "declarator": "prismGridDataSet", "var_name": "prismGridDataSet"}, {"original_string": "static GridDataset ssebopetaGridDataSet;", "modifier": "static", "type": "GridDataset", "declarator": "ssebopetaGridDataSet", "var_name": "ssebopetaGridDataSet"}, {"original_string": "SimpleFeatureCollection featureCollection;", "modifier": "", "type": "SimpleFeatureCollection", "declarator": "featureCollection", "var_name": "featureCollection"}], "file": "gdp-common-utilities/src/test/java/gov/usgs/cida/gdp/utilities/GeoTiffUtilsTest.java"}, "test_case": {"identifier": "writeSsebopetaGridToGeoTiffTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void writeSsebopetaGridToGeoTiffTest() {\n        List<String> gridVariableList = Arrays.asList(\"et\");     // SSEBOPETA\n        \n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.ENGLISH);\n        Date startDate = null;\n        try {\n            startDate = format.parse(\"2000-01-01\");   // SSEBOPETA\n        } catch (ParseException e) {}\n        assertNotNull(startDate);\n        \n        Date endDate = null;\n        try {\n            endDate = format.parse(\"2014-12-01\");   // SSEBOPETA\n        } catch (ParseException e) {}\n        assertNotNull(endDate);\n        \n        File testFile = null;\n        try {\n            testFile = GeoTiffUtils.generateGeoTiffZipFromGrid(ssebopetaGridDataSet, gridVariableList, featureCollection, true, startDate, endDate, \".\");\n        } catch (GeoTiffUtilException e) {\n            e.printStackTrace();\n            fail();\n        }\n        \n        assertTrue(testFile.exists());\n        \n        testFile.delete();\n    }", "signature": "void writeSsebopetaGridToGeoTiffTest()", "full_signature": "@Test public void writeSsebopetaGridToGeoTiffTest()", "class_method_signature": "GeoTiffUtilsTest.writeSsebopetaGridToGeoTiffTest()", "testcase": true, "constructor": false, "invocations": ["asList", "parse", "assertNotNull", "parse", "assertNotNull", "generateGeoTiffZipFromGrid", "printStackTrace", "fail", "assertTrue", "exists", "delete"]}, "focal_class": {"identifier": "GeoTiffUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "static private org.slf4j.Logger LOGGER = org.slf4j.LoggerFactory.getLogger(GeoTiffUtils.class);", "modifier": "static private", "type": "org.slf4j.Logger", "declarator": "LOGGER = org.slf4j.LoggerFactory.getLogger(GeoTiffUtils.class)", "var_name": "LOGGER"}, {"original_string": "public static final String GEOTIFF_DIRECTORY_PREFIX = \"GeoTiff_\";", "modifier": "public static final", "type": "String", "declarator": "GEOTIFF_DIRECTORY_PREFIX = \"GeoTiff_\"", "var_name": "GEOTIFF_DIRECTORY_PREFIX"}, {"original_string": "public static final String FILE_DATE_FORMAT = \"yyyy-MM-dd-HH-mm-ss\";", "modifier": "public static final", "type": "String", "declarator": "FILE_DATE_FORMAT = \"yyyy-MM-dd-HH-mm-ss\"", "var_name": "FILE_DATE_FORMAT"}, {"original_string": "public static final String FILE_DELIMETER = \"-\";", "modifier": "public static final", "type": "String", "declarator": "FILE_DELIMETER = \"-\"", "var_name": "FILE_DELIMETER"}, {"original_string": "public static final String FILE_TIFF_EXTENSION = \".tiff\";", "modifier": "public static final", "type": "String", "declarator": "FILE_TIFF_EXTENSION = \".tiff\"", "var_name": "FILE_TIFF_EXTENSION"}, {"original_string": "public static final String FILE_ZIP_EXTENSION = \".zip\";", "modifier": "public static final", "type": "String", "declarator": "FILE_ZIP_EXTENSION = \".zip\"", "var_name": "FILE_ZIP_EXTENSION"}], "methods": [{"identifier": "generateGeoTiffZipFromGrid", "parameters": "(GridDataset gridDataset, List<String> gridVariableList,\n\t\t\tFeatureCollection<?, ?> featureCollection, boolean requireFullCoverage, Date dateTimeStart,\n\t\t\tDate dateTimeEnd, String destination)", "modifiers": "public static", "return": "File", "signature": "File generateGeoTiffZipFromGrid(GridDataset gridDataset, List<String> gridVariableList,\n\t\t\tFeatureCollection<?, ?> featureCollection, boolean requireFullCoverage, Date dateTimeStart,\n\t\t\tDate dateTimeEnd, String destination)", "full_signature": "public static File generateGeoTiffZipFromGrid(GridDataset gridDataset, List<String> gridVariableList,\n\t\t\tFeatureCollection<?, ?> featureCollection, boolean requireFullCoverage, Date dateTimeStart,\n\t\t\tDate dateTimeEnd, String destination)", "class_method_signature": "GeoTiffUtils.generateGeoTiffZipFromGrid(GridDataset gridDataset, List<String> gridVariableList,\n\t\t\tFeatureCollection<?, ?> featureCollection, boolean requireFullCoverage, Date dateTimeStart,\n\t\t\tDate dateTimeEnd, String destination)", "testcase": false, "constructor": false}, {"identifier": "createGeoTiffForGrid", "parameters": "(GridDataset gridDataset, GridDatatype grid, int timeIndex, String filename)", "modifiers": "public static", "return": "void", "signature": "void createGeoTiffForGrid(GridDataset gridDataset, GridDatatype grid, int timeIndex, String filename)", "full_signature": "public static void createGeoTiffForGrid(GridDataset gridDataset, GridDatatype grid, int timeIndex, String filename)", "class_method_signature": "GeoTiffUtils.createGeoTiffForGrid(GridDataset gridDataset, GridDatatype grid, int timeIndex, String filename)", "testcase": false, "constructor": false}], "file": "gdp-common-utilities/src/main/java/gov/usgs/cida/gdp/utilities/GeoTiffUtils.java"}, "focal_method": {"identifier": "generateGeoTiffZipFromGrid", "parameters": "(GridDataset gridDataset, List<String> gridVariableList,\n\t\t\tFeatureCollection<?, ?> featureCollection, boolean requireFullCoverage, Date dateTimeStart,\n\t\t\tDate dateTimeEnd, String destination)", "modifiers": "public static", "return": "File", "body": "public static File generateGeoTiffZipFromGrid(GridDataset gridDataset, List<String> gridVariableList,\n\t\t\tFeatureCollection<?, ?> featureCollection, boolean requireFullCoverage, Date dateTimeStart,\n\t\t\tDate dateTimeEnd, String destination) throws GeoTiffUtilException {\n\t\tPath destinationDirectory = Paths.get(destination);\n        \n        CalendarDateFormatter dateFormatter = new CalendarDateFormatter(FILE_DATE_FORMAT);\n        \n        /*\n         * Get the dataset ID and format it accordingly\n         *      QUOTE (JIRA GDP-947)\n         *          dataId should be what comes after dodsC in the OPeNDAP URI with '/'s replaced with '-'s\n         */        \n        String datasetURI = gridDataset.getLocationURI();        \n        String dataId = datasetURI.replace(OPeNDAPUtils.OPENDAP_PROTO, \"\");\n        dataId = dataId.replace(\"//\", \"\"); // remove protocal //\n        dataId = dataId.replace(\"/\", \"-\");\n        \n        /*\n         * Create a temp directory for this specific request as we could get name collisions\n         */\n        Path workingDirectory;\n        try {\n            workingDirectory = Files.createTempDirectory(destinationDirectory, GEOTIFF_DIRECTORY_PREFIX);\n        } catch (IOException e) {\n            throw new GeoTiffUtilException(GeoTiffUtilExceptionID.GENERAL_EXCEPTION,\n                    \"GeoTiffUtils\", \"generateGeoTiffZipFromGrid\", \"Unable to create GeoTiff working \" +\n                    \"directory at [\" + destinationDirectory + \"]  Exception: \" + e.getMessage());\n        }\n        \n        File result = null;\n        String resultingZipFileName = \"\";\n        try {\n            for (String gridVariable : gridVariableList) {\n                GridDatatype parentGridDataType;\n                \n                try {\n                    /*\n                     * A null pointer exception can be thrown here due to errors in the\n                     * request such as incorrect dimensions (GridVariableList) associated\n                     * with a dataset that does not contain them.\n                     */\n                \tparentGridDataType = gridDataset.findGridDatatype(gridVariable);\n                } catch (Exception e) {\n                    throw new GeoTiffUtilException(GeoTiffUtilExceptionID.GENERAL_EXCEPTION,\n                            \"GeoTiffUtils\", \"generateGeoTiffZipFromGrid\", \"Unable to generate Grid Data Type \" +\n                            \"for dataset [\" + gridDataset.getLocationURI() + \"] and variable [\" + gridVariable +\n                            \"].  Exception: \" + e.getMessage());\n                }\n                \n                /*\n                 * Create the time range object for using in both a grid data type subset (with the feature collection)\n                 * as well as iteration of the geolocation\n                 */\n                Range timeRange = TimeRangeUtil.generateTimeRange(parentGridDataType, dateTimeStart, dateTimeEnd);\n                \n                /*\n            \t * Grab the grid coordinate system\n            \t */\n            \tGridCoordSystem gridCoordSystem = parentGridDataType.getCoordinateSystem();\n                \n            \t/*\n            \t * Create an XY range for the feature collection requested\n            \t */\n                Range[] xyRanges;\n\t\t\t\ttry {\n\t\t\t\t\txyRanges = GridUtils.getXYRangesFromBoundingBox(featureCollection.getBounds(), gridCoordSystem, requireFullCoverage);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new GeoTiffUtilException(GeoTiffUtilExceptionID.GENERAL_EXCEPTION,\n                            \"GeoTiffUtils\", \"generateGeoTiffZipFromGrid\", \"Unable to generate XY Range set from Grid Data Type \" +\n                            \"for dataset [\" + gridDataset.getLocationURI() + \"] and variable [\" + gridVariable +\n                            \"].  Exception: \" + e.getMessage());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n            \t * Now create a grid subset so we only get what the user requested with regards to geo locations\n            \t */\n                GridDatatype gridDataType;\n\t\t\t\ttry {\n\t\t\t\t\tgridDataType = parentGridDataType.makeSubset(null, null, timeRange, null, xyRanges[1], xyRanges[0]);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new GeoTiffUtilException(GeoTiffUtilExceptionID.GENERAL_EXCEPTION,\n                            \"GeoTiffUtils\", \"generateGeoTiffZipFromGrid\", \"Unable to generate Grid Subset \" +\n                            \"for dataset [\" + gridDataset.getLocationURI() + \"] and variable [\" + gridVariable +\n                            \"].  Exception: \" + e.getMessage());\n\t\t\t\t}\n                \n                /*\n                 * We introduced an issue here when we created subsets via the feature collection.\n                 * \n                 * What happens is the original parentGridDataType is the full gridded set for this\n                 * datastore with regards to time, x and y.  When we create the subset for the\n                 * requested feature collect, the TIME is reset to index 0.\n                 * \n                 * While the start time requested for the parentGridDataType set might be at index 9000 \n                 * and the end time at index 9005, when we create the subset, the start time is set to\n                 * index 0 and the end time is set to 5. \n                 */\n                int delta = timeRange.last() - timeRange.first();\n                Range deltaRange = null;\n                try {\n\t\t\t\t\tdeltaRange = new Range(0, delta);\n\t\t\t\t} catch (InvalidRangeException e) {\n\t\t\t\t\tthrow new GeoTiffUtilException(GeoTiffUtilExceptionID.GENERAL_EXCEPTION,\n                            \"GeoTiffUtils\", \"generateGeoTiffZipFromGrid\", \"Unable to generate Subset time range \" +\n                            \"for dataset [\" + gridDataset.getLocationURI() + \"] and variable [\" + gridVariable +\n                            \"].  Exception: \" + e.getMessage());\n\t\t\t\t}\n                \n                Iterator iter = deltaRange.getIterator();\n                \n                while (iter.hasNext()) {\n                    int tRange = iter.next();\n                                    \n                    /*\n                     * Create the filename with the dataId and time of this iteration\n                     *      QUOTE (JIRA GDP-947)\n                     *          Each GeoTIFF file should be named with the time stamp converted to a string. \n                     *          As long as its an unambiguous string that someone can parse later, the format\n                     *          isn't very important. It would be nice if it was a format that sorts nicely \n                     *          like dataId-YYYY-MM-DD-hh-mm-ss.tiff\n                     */\n                    CalendarDate date = TimeRangeUtil.getTimeFromRangeIndex(gridDataType, tRange);\n                    String dateString = dateFormatter.toString(date);\n                    String datasetName = dataId + FILE_DELIMETER + dateString;\n                    String absoluteFilePath = workingDirectory + File.separator + datasetName + FILE_TIFF_EXTENSION;\n            \n                    GeoTiffUtils.createGeoTiffForGrid(gridDataset, gridDataType, tRange, absoluteFilePath);\n            \n                    LOGGER.debug(\"testGeoTiffWriter(): Successfully wrote tiff file at: \" + absoluteFilePath);\n                }\n            }\n            \n            /*\n             * Now zip the contents of this geotiff directory\n             */\n            resultingZipFileName = workingDirectory.toString() + FILE_ZIP_EXTENSION;\n            try {\n                FileHelper.zipDirectory(workingDirectory.toString(), resultingZipFileName);\n                LOGGER.debug(\"GeoTiffUtils.generateGeoTiffZipFromGrid(): Directory [\" + workingDirectory.toString() + \"] successfully zipped.\");\n            } catch (Exception e) {\n                throw new GeoTiffUtilException(GeoTiffUtilExceptionID.ZIP_EXCEPTION,\n                        \"GeoTiffUtils\", \"generateGeoTiffZipFromGrid\", \"Unable to zip GeoTiff generated files for directory [\" +\n                        workingDirectory.toString() + \"].  Exception: \" + e.getMessage());\n            }\n            \n            result = new File(resultingZipFileName);\n        } finally {\n            /*\n             * Now delete the temporary directory\n             */\n            try {\n                FileUtils.deleteDirectory(workingDirectory.toFile());\n            } catch (IOException e) {\n                LOGGER.error(\"Unable to delete GeoTiff directory [\" + workingDirectory.toString() + \"].\");\n            }\n        }\n        \n        /*\n         * Final check to make sure that the zip file actually exists and then return the\n         * File handle to the caller.\n         */\n        if (result == null || !result.exists()) {\n            throw new GeoTiffUtilException(GeoTiffUtilExceptionID.GENERAL_EXCEPTION,\n                    \"GeoTiffUtils\", \"generateGeoTiffZipFromGrid\", \"Unable to find resulting GeoTiff zipped file \" +\n                    resultingZipFileName + \"].\");\n        }\n        \n        return result;\n    }", "signature": "File generateGeoTiffZipFromGrid(GridDataset gridDataset, List<String> gridVariableList,\n\t\t\tFeatureCollection<?, ?> featureCollection, boolean requireFullCoverage, Date dateTimeStart,\n\t\t\tDate dateTimeEnd, String destination)", "full_signature": "public static File generateGeoTiffZipFromGrid(GridDataset gridDataset, List<String> gridVariableList,\n\t\t\tFeatureCollection<?, ?> featureCollection, boolean requireFullCoverage, Date dateTimeStart,\n\t\t\tDate dateTimeEnd, String destination)", "class_method_signature": "GeoTiffUtils.generateGeoTiffZipFromGrid(GridDataset gridDataset, List<String> gridVariableList,\n\t\t\tFeatureCollection<?, ?> featureCollection, boolean requireFullCoverage, Date dateTimeStart,\n\t\t\tDate dateTimeEnd, String destination)", "testcase": false, "constructor": false, "invocations": ["get", "getLocationURI", "replace", "replace", "replace", "createTempDirectory", "getMessage", "findGridDatatype", "getLocationURI", "getMessage", "generateTimeRange", "getCoordinateSystem", "getXYRangesFromBoundingBox", "getBounds", "getLocationURI", "getMessage", "makeSubset", "getLocationURI", "getMessage", "last", "first", "getLocationURI", "getMessage", "getIterator", "hasNext", "next", "getTimeFromRangeIndex", "toString", "createGeoTiffForGrid", "debug", "toString", "zipDirectory", "toString", "debug", "toString", "toString", "getMessage", "deleteDirectory", "toFile", "error", "toString", "exists"]}, "repository": {"repo_id": 11799031, "url": "https://github.com/USGS-CIDA/geo-data-portal", "language": "Java", "is_fork": false, "fork_count": 21, "stargazer_count": 9, "size": 178468, "license": "licensed"}}