{"test_class": {"identifier": "AnnualOverlapTest", "superclass": "", "interfaces": "", "fields": [], "file": "jtstoolkit/src/test/java/ec/tstoolkit/timeseries/simplets/chainlinking/AnnualOverlapTest.java"}, "test_case": {"identifier": "testAnnualOverlap", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testAnnualOverlap() {\n        double[] qa = new double[]{56.4, 62.4, 65.7, 66.5, 67.4, 69.4, 71.5, 73.7, 76, 78.3, 80.6, 83.1, 85.5, 88.2, 90.8, 93.5};\n        double[] qb = new double[]{57.6, 58, 59, 61.4, 57.6, 57.1, 56.5, 55.8, 55.4, 54.8, 54.2, 53.6, 53.2, 52.7, 52.1, 52};\n        double[] pa = new double[]{6.2, 6.5, 7.6, 7.7, 6.1, 5.7, 5.3, 5, 4.5, 4.3, 3.8, 3.5, 3.4, 3.1, 2.8, 2.7};\n        double[] pb = new double[]{5.4, 5.6, 6.2, 6.8, 8.0, 8.6, 9.4, 10.0, 10.7, 11.5, 11.7, 12.1, 12.5, 13, 13.8, 14.7};\n        \n        TsData QAq = new TsData(TsFrequency.Quarterly, 1997, 0, qa, true);\n        TsData QBq = new TsData(TsFrequency.Quarterly, 1997, 0, qb, true);\n        TsData PAq = new TsData(TsFrequency.Quarterly, 1997, 0, pa, true);\n        TsData PBq = new TsData(TsFrequency.Quarterly, 1997, 0, pb, true);\n        \n        AnnualOverlap o = new AnnualOverlap();\n        o.setRefYear(1997);\n        \n        o.addProduct(\"Product A\", QAq, PAq);\n        o.addProduct(\"Product B\", QBq, PBq);\n        \n        o.process();\n    }", "signature": "void testAnnualOverlap()", "full_signature": "@Test public void testAnnualOverlap()", "class_method_signature": "AnnualOverlapTest.testAnnualOverlap()", "testcase": true, "constructor": false, "invocations": ["setRefYear", "addProduct", "addProduct", "process"]}, "focal_class": {"identifier": "AnnualOverlap", "superclass": "extends AChainLinking", "interfaces": "", "fields": [{"original_string": "public static final String TOTAL_VALUES = \"totalvalues\";", "modifier": "public static final", "type": "String", "declarator": "TOTAL_VALUES = \"totalvalues\"", "var_name": "TOTAL_VALUES"}, {"original_string": "public static final String VALUES_PREVIOUS_PRICE = \"valuesPreviousYearPrice\";", "modifier": "public static final", "type": "String", "declarator": "VALUES_PREVIOUS_PRICE = \"valuesPreviousYearPrice\"", "var_name": "VALUES_PREVIOUS_PRICE"}, {"original_string": "public static final String CHAIN_LINKED_INDEXES = \"percPreviousYearPrice\";", "modifier": "public static final", "type": "String", "declarator": "CHAIN_LINKED_INDEXES = \"percPreviousYearPrice\"", "var_name": "CHAIN_LINKED_INDEXES"}, {"original_string": "public static final String REF_YEAR = \"refYear\";", "modifier": "public static final", "type": "String", "declarator": "REF_YEAR = \"refYear\"", "var_name": "REF_YEAR"}], "methods": [{"identifier": "process", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void process()", "full_signature": "@Override public void process()", "class_method_signature": "AnnualOverlap.process()", "testcase": false, "constructor": false}, {"identifier": "findSmallestDomain", "parameters": "()", "modifiers": "private", "return": "TsDomain", "signature": "TsDomain findSmallestDomain()", "full_signature": "private TsDomain findSmallestDomain()", "class_method_signature": "AnnualOverlap.findSmallestDomain()", "testcase": false, "constructor": false}, {"identifier": "intersectAllDomains", "parameters": "(TsDomain ref)", "modifiers": "private", "return": "TsDomain", "signature": "TsDomain intersectAllDomains(TsDomain ref)", "full_signature": "private TsDomain intersectAllDomains(TsDomain ref)", "class_method_signature": "AnnualOverlap.intersectAllDomains(TsDomain ref)", "testcase": false, "constructor": false}, {"identifier": "cloneInputList", "parameters": "()", "modifiers": "private", "return": "ArrayList<Product>", "signature": "ArrayList<Product> cloneInputList()", "full_signature": "private ArrayList<Product> cloneInputList()", "class_method_signature": "AnnualOverlap.cloneInputList()", "testcase": false, "constructor": false}, {"identifier": "calculateMissingData", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void calculateMissingData()", "full_signature": "private void calculateMissingData()", "class_method_signature": "AnnualOverlap.calculateMissingData()", "testcase": false, "constructor": false}], "file": "jtstoolkit/src/main/java/ec/tstoolkit/timeseries/simplets/chainlinking/AnnualOverlap.java"}, "focal_method": {"identifier": "process", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void process() {\n        if (input == null || input.isEmpty()) {\n            results = null;\n            return;\n        }\n\n        results = new InformationSet();\n        \n        // Calculate the 3rd missing Ts\n        calculateMissingData();\n\n        // Find the intersection domain between all series\n        TsDomain intersection = intersectAllDomains(findSmallestDomain());\n        if (intersection.getLength() == 0) {\n            throw new IllegalArgumentException(\"The common domain is empty\");\n        }\n\n        if (refYear == - 1 || intersection.getStart().getYear() > refYear\n                || intersection.getEnd().getYear() < refYear) {\n            refYear = intersection.getStart().getYear();\n        }\n\n        results.add(REF_YEAR, refYear);\n\n        // Then, drop everything before the reference year (-1 quarter each iteration)\n        while (intersection.getStart().getYear() < refYear) {\n            intersection = intersection.drop(1, 0);\n        }\n\n        // Create the list of domain fitted products, we keep original list unchanged\n        List<Product> prds = cloneInputList();\n\n        for (int i = 0; i < prds.size(); i++) {\n            prds.get(i).setQuantities(prds.get(i).getQuantities().fittoDomain(intersection));\n            prds.get(i).setPrice(prds.get(i).getPrice().fittoDomain(intersection));\n            prds.get(i).setValue(prds.get(i).getValue().fittoDomain(intersection));\n        }\n\n        List<TsData> allPricesY = new ArrayList<>();\n        for (int i = 0; i < prds.size(); i++) {\n            allPricesY.add(prds.get(i).getPrice().changeFrequency(TsFrequency.Yearly, TsAggregationType.Average, true));\n        }\n\n        //-------------------------------------------------------------------\n        // Create list of first year dropped quantities\n        List<TsData> allQuantitiesQ = new ArrayList<>();\n        for (int i = 0; i < prds.size(); i++) {\n            TsData ts = prds.get(i).getQuantities();\n            ts = ts.update(ts.changeFrequency(TsFrequency.Quarterly, TsAggregationType.Sum, true));\n            ts = ts.drop(4, 0);\n            allQuantitiesQ.add(ts);\n        }\n\n        // Calculate total value TsData (column Total at current prices)        \n        TsData totalValueQ = prds.get(0).getValue();\n        for (int i = 1; i < prds.size(); i++) {\n            totalValueQ = TsData.add(totalValueQ, prds.get(i).getValue());\n        }\n\n        results.add(TOTAL_VALUES, totalValueQ);\n\n        TsData totalValueY = totalValueQ.changeFrequency(TsFrequency.Yearly, TsAggregationType.Sum, true);\n        totalValueQ = totalValueQ.drop(4, 0);\n\n        // Iterates through the years for computing the series at the price of previous year\n        TsData Qq = new TsData(totalValueQ.getDomain());\n        YearIterator yq = new YearIterator(Qq);\n        List<YearIterator> iterators = new ArrayList<>();\n        for (int i = 0; i < allQuantitiesQ.size(); i++) {\n            iterators.add(new YearIterator(allQuantitiesQ.get(i)));\n        }\n        while (yq.hasMoreElements()) {\n            TsDataBlock qcur = yq.nextElement();\n            List<TsDataBlock> dataBlocks = new ArrayList<>();\n            for (int i = 0; i < prds.size(); i++) {\n                dataBlocks.add(iterators.get(i).nextElement());\n            }\n            TsPeriod prev = TsPeriod.year(qcur.start.getYear() - 1);\n\n            qcur.data.setAY(allPricesY.get(0).get(prev), dataBlocks.get(0).data);\n            for (int i = 1; i < dataBlocks.size(); i++) {\n                qcur.data.addAY(allPricesY.get(i).get(prev), dataBlocks.get(i).data);\n            }\n        }\n\n        // In Qq I have values of each quarter computed with the price of previous year\n        results.set(VALUES_PREVIOUS_PRICE, Qq.clone());\n\n        //---------------------------------------------------------------\n        // STEP 3. Chain the indexes.\n        double idx = 100;\n        int ifreq = Qq.getFrequency().intValue();\n        yq.reset();\n\n        while (yq.hasMoreElements()) {\n            TsDataBlock qcur = yq.nextElement();\n            TsPeriod prev = TsPeriod.year(qcur.start.getYear() - 1);\n            double val0 = totalValueY.get(prev);\n            double val1 = qcur.data.sum();\n            qcur.data.mul(idx / (val0 / ifreq));\n            idx *= val1 / val0;\n        }\n        // In Qq I have % of chain linked indexes\n        results.set(CHAIN_LINKED_INDEXES, Qq);\n    }", "signature": "void process()", "full_signature": "@Override public void process()", "class_method_signature": "AnnualOverlap.process()", "testcase": false, "constructor": false, "invocations": ["isEmpty", "calculateMissingData", "intersectAllDomains", "findSmallestDomain", "getLength", "getYear", "getStart", "getYear", "getEnd", "getYear", "getStart", "add", "getYear", "getStart", "drop", "cloneInputList", "size", "setQuantities", "get", "fittoDomain", "getQuantities", "get", "setPrice", "get", "fittoDomain", "getPrice", "get", "setValue", "get", "fittoDomain", "getValue", "get", "size", "add", "changeFrequency", "getPrice", "get", "size", "getQuantities", "get", "update", "changeFrequency", "drop", "add", "getValue", "get", "size", "add", "getValue", "get", "add", "changeFrequency", "drop", "getDomain", "size", "add", "get", "hasMoreElements", "nextElement", "size", "add", "nextElement", "get", "year", "getYear", "setAY", "get", "get", "get", "size", "addAY", "get", "get", "get", "set", "clone", "intValue", "getFrequency", "reset", "hasMoreElements", "nextElement", "year", "getYear", "get", "sum", "mul", "set"]}, "repository": {"repo_id": 28178086, "url": "https://github.com/jdemetra/jdemetra-core", "stars": 24, "created": "12/18/2014 10:00:58 AM +00:00", "updates": "2020-01-17T15:50:24+00:00", "fork": "False", "license": "licensed"}}