{"test_class": {"identifier": "OperatorMulticastTest", "superclass": "", "interfaces": "", "fields": [], "file": "zava/src/test/java/rx/internal/operators/OperatorMulticastTest.java"}, "test_case": {"identifier": "testMulticastConnectTwice", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMulticastConnectTwice() {\n        Subject<String, String> source = PublishSubject.create();\n\n        ConnectableObservable<String> multicasted = new OperatorMulticast<String, String>(source, new PublishSubjectFactory());\n\n        @SuppressWarnings(\"unchecked\")\n        Observer<String> observer = mock(Observer.class);\n        multicasted.subscribe(observer);\n\n        source.onNext(\"one\");\n\n        Subscription sub = multicasted.connect();\n        Subscription sub2 = multicasted.connect();\n        \n        source.onNext(\"two\");\n        source.onCompleted();\n\n        verify(observer, never()).onNext(\"one\");\n        verify(observer, times(1)).onNext(\"two\");\n        verify(observer, times(1)).onCompleted();\n        \n        assertEquals(sub, sub2);\n\n    }", "signature": "void testMulticastConnectTwice()", "full_signature": "@Test public void testMulticastConnectTwice()", "class_method_signature": "OperatorMulticastTest.testMulticastConnectTwice()", "testcase": true, "constructor": false, "invocations": ["create", "mock", "subscribe", "onNext", "connect", "connect", "onNext", "onCompleted", "onNext", "verify", "never", "onNext", "verify", "times", "onCompleted", "verify", "times", "assertEquals"]}, "focal_class": {"identifier": "OperatorMulticast", "superclass": "extends ConnectableObservable<R>", "interfaces": "", "fields": [{"original_string": "final Observable<? extends T> source;", "modifier": "final", "type": "Observable<? extends T>", "declarator": "source", "var_name": "source"}, {"original_string": "final Object guard;", "modifier": "final", "type": "Object", "declarator": "guard", "var_name": "guard"}, {"original_string": "final Func0<? extends Subject<? super T, ? extends R>> subjectFactory;", "modifier": "final", "type": "Func0<? extends Subject<? super T, ? extends R>>", "declarator": "subjectFactory", "var_name": "subjectFactory"}, {"original_string": "final AtomicReference<Subject<? super T, ? extends R>> connectedSubject;", "modifier": "final", "type": "AtomicReference<Subject<? super T, ? extends R>>", "declarator": "connectedSubject", "var_name": "connectedSubject"}, {"original_string": "final List<Subscriber<? super R>> waitingForConnect;", "modifier": "final", "type": "List<Subscriber<? super R>>", "declarator": "waitingForConnect", "var_name": "waitingForConnect"}, {"original_string": "private Subscriber<T> subscription;", "modifier": "private", "type": "Subscriber<T>", "declarator": "subscription", "var_name": "subscription"}, {"original_string": "private Subscription guardedSubscription;", "modifier": "private", "type": "Subscription", "declarator": "guardedSubscription", "var_name": "guardedSubscription"}], "methods": [{"identifier": "OperatorMulticast", "parameters": "(Observable<? extends T> source, final Func0<? extends Subject<? super T, ? extends R>> subjectFactory)", "modifiers": "public", "return": "", "signature": " OperatorMulticast(Observable<? extends T> source, final Func0<? extends Subject<? super T, ? extends R>> subjectFactory)", "full_signature": "public  OperatorMulticast(Observable<? extends T> source, final Func0<? extends Subject<? super T, ? extends R>> subjectFactory)", "class_method_signature": "OperatorMulticast.OperatorMulticast(Observable<? extends T> source, final Func0<? extends Subject<? super T, ? extends R>> subjectFactory)", "testcase": false, "constructor": true}, {"identifier": "OperatorMulticast", "parameters": "(final Object guard, final AtomicReference<Subject<? super T, ? extends R>> connectedSubject, final List<Subscriber<? super R>> waitingForConnect, Observable<? extends T> source, final Func0<? extends Subject<? super T, ? extends R>> subjectFactory)", "modifiers": "private", "return": "", "signature": " OperatorMulticast(final Object guard, final AtomicReference<Subject<? super T, ? extends R>> connectedSubject, final List<Subscriber<? super R>> waitingForConnect, Observable<? extends T> source, final Func0<? extends Subject<? super T, ? extends R>> subjectFactory)", "full_signature": "private  OperatorMulticast(final Object guard, final AtomicReference<Subject<? super T, ? extends R>> connectedSubject, final List<Subscriber<? super R>> waitingForConnect, Observable<? extends T> source, final Func0<? extends Subject<? super T, ? extends R>> subjectFactory)", "class_method_signature": "OperatorMulticast.OperatorMulticast(final Object guard, final AtomicReference<Subject<? super T, ? extends R>> connectedSubject, final List<Subscriber<? super R>> waitingForConnect, Observable<? extends T> source, final Func0<? extends Subject<? super T, ? extends R>> subjectFactory)", "testcase": false, "constructor": true}, {"identifier": "connect", "parameters": "(Action1<? super Subscription> connection)", "modifiers": "@Override public", "return": "void", "signature": "void connect(Action1<? super Subscription> connection)", "full_signature": "@Override public void connect(Action1<? super Subscription> connection)", "class_method_signature": "OperatorMulticast.connect(Action1<? super Subscription> connection)", "testcase": false, "constructor": false}], "file": "zava/src/main/java/rx/internal/operators/OperatorMulticast.java"}, "focal_method": {"identifier": "connect", "parameters": "(Action1<? super Subscription> connection)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void connect(Action1<? super Subscription> connection) {\n        // each time we connect we create a new Subject and Subscription\n\n        // subscription is the state of whether we are connected or not\n        synchronized (guard) {\n            if (subscription != null) {\n                // already connected\n                connection.call(guardedSubscription);\n                return;\n            } else {\n                // we aren't connected, so let's create a new Subject and connect\n                final Subject<? super T, ? extends R> subject = subjectFactory.call();\n                // create new Subscriber that will pass-thru to the subject we just created\n                // we do this since it is also a Subscription whereas the Subject is not\n                subscription = new Subscriber<T>() {\n                    @Override\n                    public void onCompleted() {\n                        subject.onCompleted();\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        subject.onError(e);\n                    }\n\n                    @Override\n                    public void onNext(T args) {\n                        subject.onNext(args);\n                    }\n                };\n                final AtomicReference<Subscription> gs = new AtomicReference<Subscription>();\n                gs.set(Subscriptions.create(new Action0() {\n                    @Override\n                    public void call() {\n                        Subscription s;\n                        synchronized (guard) {\n                            if ( guardedSubscription == gs.get()) {\n                                s = subscription;\n                                subscription = null;\n                                guardedSubscription = null;\n                                connectedSubject.set(null);\n                            } else \n                                return;\n                        }\n                        if (s != null) {\n                            s.unsubscribe();\n                        }\n                    }\n                }));\n                guardedSubscription = gs.get();\n                \n                // register any subscribers that are waiting with this new subject\n                for(Subscriber<? super R> s : waitingForConnect) {\n                    subject.unsafeSubscribe(s);\n                }\n                // clear the waiting list as any new ones that come in after leaving this synchronized block will go direct to the Subject\n                waitingForConnect.clear();\n                // record the Subject so OnSubscribe can see it\n                connectedSubject.set(subject);\n            }\n            \n        }\n\n        // in the lock above we determined we should subscribe, do it now outside the lock\n        // register a subscription that will shut this down\n        connection.call(guardedSubscription);\n\n        // now that everything is hooked up let's subscribe\n        // as long as the subscription is not null (which can happen if already unsubscribed)\n        Subscriber<T> sub; \n        synchronized (guard) {\n            sub = subscription;\n        }\n        if (sub != null)\n            source.subscribe(sub);\n    }", "signature": "void connect(Action1<? super Subscription> connection)", "full_signature": "@Override public void connect(Action1<? super Subscription> connection)", "class_method_signature": "OperatorMulticast.connect(Action1<? super Subscription> connection)", "testcase": false, "constructor": false, "invocations": ["call", "call", "onCompleted", "onError", "onNext", "set", "create", "get", "set", "unsubscribe", "get", "unsafeSubscribe", "clear", "set", "call", "subscribe"]}, "repository": {"repo_id": 33645537, "url": "https://github.com/zqhxuyuan/tutorials", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 5, "size": 35273, "license": "licensed"}}