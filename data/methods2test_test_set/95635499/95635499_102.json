{"test_class": {"identifier": "SetUtilTest", "superclass": "", "interfaces": "", "fields": [], "file": "JAICore/jaicore-basic/src/test/java/ai/libs/jaicore/basic/sets/SetUtilTest.java"}, "test_case": {"identifier": "testDifferenceEmptyPositiveCase", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testDifferenceEmptyPositiveCase() {\n\t\tCollection<String> a = new ArrayList<>();\n\t\ta.add(\"i1\");\n\t\ta.add(\"i2\");\n\t\ta.add(\"i3\");\n\t\tCollection<String> b = new HashSet<>();\n\t\tb.add(\"i1\");\n\t\tb.add(\"i2\");\n\t\tb.add(\"i3\");\n\t\tassertTrue(\"Difference IS empty, but SetUtil.differenceEmpty returns false\", SetUtil.differenceEmpty(a, b));\n\t}", "signature": "void testDifferenceEmptyPositiveCase()", "full_signature": "@Test public void testDifferenceEmptyPositiveCase()", "class_method_signature": "SetUtilTest.testDifferenceEmptyPositiveCase()", "testcase": true, "constructor": false, "invocations": ["add", "add", "add", "add", "add", "add", "assertTrue", "differenceEmpty"]}, "focal_class": {"identifier": "SetUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String DEFAULT_LIST_ITEM_SEPARATOR = \",\";", "modifier": "private static final", "type": "String", "declarator": "DEFAULT_LIST_ITEM_SEPARATOR = \",\"", "var_name": "DEFAULT_LIST_ITEM_SEPARATOR"}], "methods": [{"identifier": "SetUtil", "parameters": "()", "modifiers": "private", "return": "", "signature": " SetUtil()", "full_signature": "private  SetUtil()", "class_method_signature": "SetUtil.SetUtil()", "testcase": false, "constructor": true}, {"identifier": "union", "parameters": "(final Collection<T>... set)", "modifiers": "@SafeVarargs public static", "return": "Collection<T>", "signature": "Collection<T> union(final Collection<T>... set)", "full_signature": "@SafeVarargs public static Collection<T> union(final Collection<T>... set)", "class_method_signature": "SetUtil.union(final Collection<T>... set)", "testcase": false, "constructor": false}, {"identifier": "union", "parameters": "(final List<T>... lists)", "modifiers": "public static", "return": "List<T>", "signature": "List<T> union(final List<T>... lists)", "full_signature": "public static List<T> union(final List<T>... lists)", "class_method_signature": "SetUtil.union(final List<T>... lists)", "testcase": false, "constructor": false}, {"identifier": "symmetricDifference", "parameters": "(final Collection<T> a, final Collection<T> b)", "modifiers": "public static", "return": "Collection<T>", "signature": "Collection<T> symmetricDifference(final Collection<T> a, final Collection<T> b)", "full_signature": "public static Collection<T> symmetricDifference(final Collection<T> a, final Collection<T> b)", "class_method_signature": "SetUtil.symmetricDifference(final Collection<T> a, final Collection<T> b)", "testcase": false, "constructor": false}, {"identifier": "getMultiplyContainedItems", "parameters": "(final List<T> list)", "modifiers": "public static", "return": "Collection<T>", "signature": "Collection<T> getMultiplyContainedItems(final List<T> list)", "full_signature": "public static Collection<T> getMultiplyContainedItems(final List<T> list)", "class_method_signature": "SetUtil.getMultiplyContainedItems(final List<T> list)", "testcase": false, "constructor": false}, {"identifier": "intersection", "parameters": "(final Collection<T> a, final Collection<U> b)", "modifiers": "public static", "return": "Collection<S>", "signature": "Collection<S> intersection(final Collection<T> a, final Collection<U> b)", "full_signature": "public static Collection<S> intersection(final Collection<T> a, final Collection<U> b)", "class_method_signature": "SetUtil.intersection(final Collection<T> a, final Collection<U> b)", "testcase": false, "constructor": false}, {"identifier": "disjoint", "parameters": "(final Collection<T> a, final Collection<U> b)", "modifiers": "public static", "return": "boolean", "signature": "boolean disjoint(final Collection<T> a, final Collection<U> b)", "full_signature": "public static boolean disjoint(final Collection<T> a, final Collection<U> b)", "class_method_signature": "SetUtil.disjoint(final Collection<T> a, final Collection<U> b)", "testcase": false, "constructor": false}, {"identifier": "getPotenceOfSet", "parameters": "(final Collection<T> set, final byte exponent)", "modifiers": "public static", "return": "Collection<Collection<T>>", "signature": "Collection<Collection<T>> getPotenceOfSet(final Collection<T> set, final byte exponent)", "full_signature": "public static Collection<Collection<T>> getPotenceOfSet(final Collection<T> set, final byte exponent)", "class_method_signature": "SetUtil.getPotenceOfSet(final Collection<T> set, final byte exponent)", "testcase": false, "constructor": false}, {"identifier": "getCartesianProductOfSetsOfSameClass", "parameters": "(final Collection<Collection<T>> items)", "modifiers": "public static", "return": "Collection<Collection<T>>", "signature": "Collection<Collection<T>> getCartesianProductOfSetsOfSameClass(final Collection<Collection<T>> items)", "full_signature": "public static Collection<Collection<T>> getCartesianProductOfSetsOfSameClass(final Collection<Collection<T>> items)", "class_method_signature": "SetUtil.getCartesianProductOfSetsOfSameClass(final Collection<Collection<T>> items)", "testcase": false, "constructor": false}, {"identifier": "powerset", "parameters": "(final Collection<T> items)", "modifiers": "public static", "return": "Collection<Collection<T>>", "signature": "Collection<Collection<T>> powerset(final Collection<T> items)", "full_signature": "public static Collection<Collection<T>> powerset(final Collection<T> items)", "class_method_signature": "SetUtil.powerset(final Collection<T> items)", "testcase": false, "constructor": false}, {"identifier": "getAllPossibleSubsets", "parameters": "(final Collection<T> items)", "modifiers": "public static", "return": "Collection<Collection<T>>", "signature": "Collection<Collection<T>> getAllPossibleSubsets(final Collection<T> items)", "full_signature": "public static Collection<Collection<T>> getAllPossibleSubsets(final Collection<T> items)", "class_method_signature": "SetUtil.getAllPossibleSubsets(final Collection<T> items)", "testcase": false, "constructor": false}, {"identifier": "subsetsOfSize", "parameters": "(final Collection<T> set, final int size)", "modifiers": "public static", "return": "Collection<Set<T>>", "signature": "Collection<Set<T>> subsetsOfSize(final Collection<T> set, final int size)", "full_signature": "public static Collection<Set<T>> subsetsOfSize(final Collection<T> set, final int size)", "class_method_signature": "SetUtil.subsetsOfSize(final Collection<T> set, final int size)", "testcase": false, "constructor": false}, {"identifier": "getSubsetOfSizeRec", "parameters": "(final List<T> superSet, final int k, final int idx, final Set<T> current, final Collection<Set<T>> solution)", "modifiers": "private static", "return": "void", "signature": "void getSubsetOfSizeRec(final List<T> superSet, final int k, final int idx, final Set<T> current, final Collection<Set<T>> solution)", "full_signature": "private static void getSubsetOfSizeRec(final List<T> superSet, final int k, final int idx, final Set<T> current, final Collection<Set<T>> solution)", "class_method_signature": "SetUtil.getSubsetOfSizeRec(final List<T> superSet, final int k, final int idx, final Set<T> current, final Collection<Set<T>> solution)", "testcase": false, "constructor": false}, {"identifier": "getAllPossibleSubsetsWithSizeParallely", "parameters": "(final Collection<T> superSet, final int k)", "modifiers": "public static", "return": "List<Set<T>>", "signature": "List<Set<T>> getAllPossibleSubsetsWithSizeParallely(final Collection<T> superSet, final int k)", "full_signature": "public static List<Set<T>> getAllPossibleSubsetsWithSizeParallely(final Collection<T> superSet, final int k)", "class_method_signature": "SetUtil.getAllPossibleSubsetsWithSizeParallely(final Collection<T> superSet, final int k)", "testcase": false, "constructor": false}, {"identifier": "getAllPossibleSubsetsWithSizeRecursive", "parameters": "(final List<T> superSet, final int k, final int idx, final Set<T> current, final List<Set<T>> solution)", "modifiers": "private static", "return": "void", "signature": "void getAllPossibleSubsetsWithSizeRecursive(final List<T> superSet, final int k, final int idx, final Set<T> current, final List<Set<T>> solution)", "full_signature": "private static void getAllPossibleSubsetsWithSizeRecursive(final List<T> superSet, final int k, final int idx, final Set<T> current, final List<Set<T>> solution)", "class_method_signature": "SetUtil.getAllPossibleSubsetsWithSizeRecursive(final List<T> superSet, final int k, final int idx, final Set<T> current, final List<Set<T>> solution)", "testcase": false, "constructor": false}, {"identifier": "getAllPossibleSubsetsWithSize", "parameters": "(final Collection<T> superSet, final int k)", "modifiers": "public static", "return": "List<Set<T>>", "signature": "List<Set<T>> getAllPossibleSubsetsWithSize(final Collection<T> superSet, final int k)", "full_signature": "public static List<Set<T>> getAllPossibleSubsetsWithSize(final Collection<T> superSet, final int k)", "class_method_signature": "SetUtil.getAllPossibleSubsetsWithSize(final Collection<T> superSet, final int k)", "testcase": false, "constructor": false}, {"identifier": "getPermutations", "parameters": "(final Collection<T> set)", "modifiers": "public static", "return": "Collection<List<T>>", "signature": "Collection<List<T>> getPermutations(final Collection<T> set)", "full_signature": "public static Collection<List<T>> getPermutations(final Collection<T> set)", "class_method_signature": "SetUtil.getPermutations(final Collection<T> set)", "testcase": false, "constructor": false}, {"identifier": "getPermutationsRec", "parameters": "(final List<T> list, final int pointer, final Collection<List<T>> solution)", "modifiers": "private static", "return": "void", "signature": "void getPermutationsRec(final List<T> list, final int pointer, final Collection<List<T>> solution)", "full_signature": "private static void getPermutationsRec(final List<T> list, final int pointer, final Collection<List<T>> solution)", "class_method_signature": "SetUtil.getPermutationsRec(final List<T> list, final int pointer, final Collection<List<T>> solution)", "testcase": false, "constructor": false}, {"identifier": "difference", "parameters": "(final Collection<T> a, final Collection<U> b)", "modifiers": "public static", "return": "Collection<S>", "signature": "Collection<S> difference(final Collection<T> a, final Collection<U> b)", "full_signature": "public static Collection<S> difference(final Collection<T> a, final Collection<U> b)", "class_method_signature": "SetUtil.difference(final Collection<T> a, final Collection<U> b)", "testcase": false, "constructor": false}, {"identifier": "getDisjointSet", "parameters": "(final Collection<T> a, final Collection<U> b)", "modifiers": "public static", "return": "Collection<S>", "signature": "Collection<S> getDisjointSet(final Collection<T> a, final Collection<U> b)", "full_signature": "public static Collection<S> getDisjointSet(final Collection<T> a, final Collection<U> b)", "class_method_signature": "SetUtil.getDisjointSet(final Collection<T> a, final Collection<U> b)", "testcase": false, "constructor": false}, {"identifier": "difference", "parameters": "(final List<T> a, final Collection<U> b)", "modifiers": "public static", "return": "List<S>", "signature": "List<S> difference(final List<T> a, final Collection<U> b)", "full_signature": "public static List<S> difference(final List<T> a, final Collection<U> b)", "class_method_signature": "SetUtil.difference(final List<T> a, final Collection<U> b)", "testcase": false, "constructor": false}, {"identifier": "differenceEmpty", "parameters": "(final Collection<T> a, final Collection<U> b)", "modifiers": "public static", "return": "boolean", "signature": "boolean differenceEmpty(final Collection<T> a, final Collection<U> b)", "full_signature": "public static boolean differenceEmpty(final Collection<T> a, final Collection<U> b)", "class_method_signature": "SetUtil.differenceEmpty(final Collection<T> a, final Collection<U> b)", "testcase": false, "constructor": false}, {"identifier": "differenceNotEmpty", "parameters": "(final Collection<T> a, final Collection<U> b)", "modifiers": "public static", "return": "boolean", "signature": "boolean differenceNotEmpty(final Collection<T> a, final Collection<U> b)", "full_signature": "public static boolean differenceNotEmpty(final Collection<T> a, final Collection<U> b)", "class_method_signature": "SetUtil.differenceNotEmpty(final Collection<T> a, final Collection<U> b)", "testcase": false, "constructor": false}, {"identifier": "cartesianProduct", "parameters": "(final Collection<S> a, final Collection<T> b)", "modifiers": "public static", "return": "Collection<Pair<S, T>>", "signature": "Collection<Pair<S, T>> cartesianProduct(final Collection<S> a, final Collection<T> b)", "full_signature": "public static Collection<Pair<S, T>> cartesianProduct(final Collection<S> a, final Collection<T> b)", "class_method_signature": "SetUtil.cartesianProduct(final Collection<S> a, final Collection<T> b)", "testcase": false, "constructor": false}, {"identifier": "cartesianProduct", "parameters": "(final List<? extends Collection<T>> listOfSets)", "modifiers": "public static", "return": "Collection<List<T>>", "signature": "Collection<List<T>> cartesianProduct(final List<? extends Collection<T>> listOfSets)", "full_signature": "public static Collection<List<T>> cartesianProduct(final List<? extends Collection<T>> listOfSets)", "class_method_signature": "SetUtil.cartesianProduct(final List<? extends Collection<T>> listOfSets)", "testcase": false, "constructor": false}, {"identifier": "cartesianProductReq", "parameters": "(final List<? extends Collection<T>> listOfSets)", "modifiers": "private static", "return": "Collection<List<T>>", "signature": "Collection<List<T>> cartesianProductReq(final List<? extends Collection<T>> listOfSets)", "full_signature": "private static Collection<List<T>> cartesianProductReq(final List<? extends Collection<T>> listOfSets)", "class_method_signature": "SetUtil.cartesianProductReq(final List<? extends Collection<T>> listOfSets)", "testcase": false, "constructor": false}, {"identifier": "cartesianProduct", "parameters": "(final Collection<S> set, final int number)", "modifiers": "public static", "return": "Collection<List<S>>", "signature": "Collection<List<S>> cartesianProduct(final Collection<S> set, final int number)", "full_signature": "public static Collection<List<S>> cartesianProduct(final Collection<S> set, final int number)", "class_method_signature": "SetUtil.cartesianProduct(final Collection<S> set, final int number)", "testcase": false, "constructor": false}, {"identifier": "relation", "parameters": "(final Collection<K> keys, final Collection<V> values, final Predicate<Pair<K, V>> relationPredicate)", "modifiers": "public static", "return": "Collection<Pair<K, V>>", "signature": "Collection<Pair<K, V>> relation(final Collection<K> keys, final Collection<V> values, final Predicate<Pair<K, V>> relationPredicate)", "full_signature": "public static Collection<Pair<K, V>> relation(final Collection<K> keys, final Collection<V> values, final Predicate<Pair<K, V>> relationPredicate)", "class_method_signature": "SetUtil.relation(final Collection<K> keys, final Collection<V> values, final Predicate<Pair<K, V>> relationPredicate)", "testcase": false, "constructor": false}, {"identifier": "relationAsFunction", "parameters": "(final Collection<K> keys, final Collection<V> values, final Predicate<Pair<K, V>> relationPredicate)", "modifiers": "public static", "return": "Map<K, Collection<V>>", "signature": "Map<K, Collection<V>> relationAsFunction(final Collection<K> keys, final Collection<V> values, final Predicate<Pair<K, V>> relationPredicate)", "full_signature": "public static Map<K, Collection<V>> relationAsFunction(final Collection<K> keys, final Collection<V> values, final Predicate<Pair<K, V>> relationPredicate)", "class_method_signature": "SetUtil.relationAsFunction(final Collection<K> keys, final Collection<V> values, final Predicate<Pair<K, V>> relationPredicate)", "testcase": false, "constructor": false}, {"identifier": "allMappings", "parameters": "(final Collection<K> domain, final Collection<V> range, final boolean totalsOnly, final boolean injectivesOnly, final boolean surjectivesOnly)", "modifiers": "public static", "return": "Collection<Map<K, V>>", "signature": "Collection<Map<K, V>> allMappings(final Collection<K> domain, final Collection<V> range, final boolean totalsOnly, final boolean injectivesOnly, final boolean surjectivesOnly)", "full_signature": "public static Collection<Map<K, V>> allMappings(final Collection<K> domain, final Collection<V> range, final boolean totalsOnly, final boolean injectivesOnly, final boolean surjectivesOnly)", "class_method_signature": "SetUtil.allMappings(final Collection<K> domain, final Collection<V> range, final boolean totalsOnly, final boolean injectivesOnly, final boolean surjectivesOnly)", "testcase": false, "constructor": false}, {"identifier": "allTotalMappings", "parameters": "(final Collection<K> domain, final Collection<V> range)", "modifiers": "public static", "return": "Collection<Map<K, V>>", "signature": "Collection<Map<K, V>> allTotalMappings(final Collection<K> domain, final Collection<V> range)", "full_signature": "public static Collection<Map<K, V>> allTotalMappings(final Collection<K> domain, final Collection<V> range)", "class_method_signature": "SetUtil.allTotalMappings(final Collection<K> domain, final Collection<V> range)", "testcase": false, "constructor": false}, {"identifier": "allPartialMappings", "parameters": "(final Collection<K> domain, final Collection<V> range)", "modifiers": "public static", "return": "Collection<Map<K, V>>", "signature": "Collection<Map<K, V>> allPartialMappings(final Collection<K> domain, final Collection<V> range)", "full_signature": "public static Collection<Map<K, V>> allPartialMappings(final Collection<K> domain, final Collection<V> range)", "class_method_signature": "SetUtil.allPartialMappings(final Collection<K> domain, final Collection<V> range)", "testcase": false, "constructor": false}, {"identifier": "allTotalAndInjectiveMappingsWithConstraint", "parameters": "(final Collection<K> domain, final Collection<V> range, final Predicate<Map<K, V>> pPredicate)", "modifiers": "public static", "return": "Set<Map<K, V>>", "signature": "Set<Map<K, V>> allTotalAndInjectiveMappingsWithConstraint(final Collection<K> domain, final Collection<V> range, final Predicate<Map<K, V>> pPredicate)", "full_signature": "public static Set<Map<K, V>> allTotalAndInjectiveMappingsWithConstraint(final Collection<K> domain, final Collection<V> range, final Predicate<Map<K, V>> pPredicate)", "class_method_signature": "SetUtil.allTotalAndInjectiveMappingsWithConstraint(final Collection<K> domain, final Collection<V> range, final Predicate<Map<K, V>> pPredicate)", "testcase": false, "constructor": false}, {"identifier": "allTotalMappingsWithLocalConstraints", "parameters": "(final Collection<K> domain, final Collection<V> range, final Predicate<Pair<K, V>> pPredicate)", "modifiers": "public static", "return": "Set<Map<K, V>>", "signature": "Set<Map<K, V>> allTotalMappingsWithLocalConstraints(final Collection<K> domain, final Collection<V> range, final Predicate<Pair<K, V>> pPredicate)", "full_signature": "public static Set<Map<K, V>> allTotalMappingsWithLocalConstraints(final Collection<K> domain, final Collection<V> range, final Predicate<Pair<K, V>> pPredicate)", "class_method_signature": "SetUtil.allTotalMappingsWithLocalConstraints(final Collection<K> domain, final Collection<V> range, final Predicate<Pair<K, V>> pPredicate)", "testcase": false, "constructor": false}, {"identifier": "allFuntionsFromFunctionallyDenotedRelation", "parameters": "(final Map<K, Collection<V>> pRelation)", "modifiers": "public static", "return": "Set<Map<K, V>>", "signature": "Set<Map<K, V>> allFuntionsFromFunctionallyDenotedRelation(final Map<K, Collection<V>> pRelation)", "full_signature": "public static Set<Map<K, V>> allFuntionsFromFunctionallyDenotedRelation(final Map<K, Collection<V>> pRelation)", "class_method_signature": "SetUtil.allFuntionsFromFunctionallyDenotedRelation(final Map<K, Collection<V>> pRelation)", "testcase": false, "constructor": false}, {"identifier": "allFunctionsFromFunctionallyDenotedRelationRewritingReference", "parameters": "(final Map<K, Collection<V>> pRelation)", "modifiers": "private static", "return": "Set<Map<K, V>>", "signature": "Set<Map<K, V>> allFunctionsFromFunctionallyDenotedRelationRewritingReference(final Map<K, Collection<V>> pRelation)", "full_signature": "private static Set<Map<K, V>> allFunctionsFromFunctionallyDenotedRelationRewritingReference(final Map<K, Collection<V>> pRelation)", "class_method_signature": "SetUtil.allFunctionsFromFunctionallyDenotedRelationRewritingReference(final Map<K, Collection<V>> pRelation)", "testcase": false, "constructor": false}, {"identifier": "shuffle", "parameters": "(final List<T> list, final long seed)", "modifiers": "public static", "return": "void", "signature": "void shuffle(final List<T> list, final long seed)", "full_signature": "public static void shuffle(final List<T> list, final long seed)", "class_method_signature": "SetUtil.shuffle(final List<T> list, final long seed)", "testcase": false, "constructor": false}, {"identifier": "getRandomElement", "parameters": "(final Collection<T> set, final long seed)", "modifiers": "public static", "return": "T", "signature": "T getRandomElement(final Collection<T> set, final long seed)", "full_signature": "public static T getRandomElement(final Collection<T> set, final long seed)", "class_method_signature": "SetUtil.getRandomElement(final Collection<T> set, final long seed)", "testcase": false, "constructor": false}, {"identifier": "getRandomElement", "parameters": "(final Collection<T> set, final Random random)", "modifiers": "public static", "return": "T", "signature": "T getRandomElement(final Collection<T> set, final Random random)", "full_signature": "public static T getRandomElement(final Collection<T> set, final Random random)", "class_method_signature": "SetUtil.getRandomElement(final Collection<T> set, final Random random)", "testcase": false, "constructor": false}, {"identifier": "getRandomSubset", "parameters": "(final Collection<T> set, final int k, final Random random)", "modifiers": "public static", "return": "Collection<T>", "signature": "Collection<T> getRandomSubset(final Collection<T> set, final int k, final Random random)", "full_signature": "public static Collection<T> getRandomSubset(final Collection<T> set, final int k, final Random random)", "class_method_signature": "SetUtil.getRandomSubset(final Collection<T> set, final int k, final Random random)", "testcase": false, "constructor": false}, {"identifier": "getRandomSetOfIntegers", "parameters": "(final int maxExclusive, final int k, final Random random)", "modifiers": "public static", "return": "Collection<Integer>", "signature": "Collection<Integer> getRandomSetOfIntegers(final int maxExclusive, final int k, final Random random)", "full_signature": "public static Collection<Integer> getRandomSetOfIntegers(final int maxExclusive, final int k, final Random random)", "class_method_signature": "SetUtil.getRandomSetOfIntegers(final int maxExclusive, final int k, final Random random)", "testcase": false, "constructor": false}, {"identifier": "mergeSort", "parameters": "(final Collection<T> set)", "modifiers": "public static", "return": "List<T>", "signature": "List<T> mergeSort(final Collection<T> set)", "full_signature": "public static List<T> mergeSort(final Collection<T> set)", "class_method_signature": "SetUtil.mergeSort(final Collection<T> set)", "testcase": false, "constructor": false}, {"identifier": "mergeLists", "parameters": "(final List<T> list1, final List<T> list2)", "modifiers": "private static", "return": "List<T>", "signature": "List<T> mergeLists(final List<T> list1, final List<T> list2)", "full_signature": "private static List<T> mergeLists(final List<T> list1, final List<T> list2)", "class_method_signature": "SetUtil.mergeLists(final List<T> list1, final List<T> list2)", "testcase": false, "constructor": false}, {"identifier": "keySetSortedByValues", "parameters": "(final Map<K, V> map, final boolean asc)", "modifiers": "public static", "return": "List<K>", "signature": "List<K> keySetSortedByValues(final Map<K, V> map, final boolean asc)", "full_signature": "public static List<K> keySetSortedByValues(final Map<K, V> map, final boolean asc)", "class_method_signature": "SetUtil.keySetSortedByValues(final Map<K, V> map, final boolean asc)", "testcase": false, "constructor": false}, {"identifier": "mergeMaps", "parameters": "(final List<K> keys1, final List<K> keys2, final Map<K, V> map, final boolean asc)", "modifiers": "private static", "return": "List<K>", "signature": "List<K> mergeMaps(final List<K> keys1, final List<K> keys2, final Map<K, V> map, final boolean asc)", "full_signature": "private static List<K> mergeMaps(final List<K> keys1, final List<K> keys2, final Map<K, V> map, final boolean asc)", "class_method_signature": "SetUtil.mergeMaps(final List<K> keys1, final List<K> keys2, final Map<K, V> map, final boolean asc)", "testcase": false, "constructor": false}, {"identifier": "calculateNumberOfTotalOrderings", "parameters": "(final PartialOrderedSet<?> set)", "modifiers": "public static", "return": "int", "signature": "int calculateNumberOfTotalOrderings(final PartialOrderedSet<?> set)", "full_signature": "public static int calculateNumberOfTotalOrderings(final PartialOrderedSet<?> set)", "class_method_signature": "SetUtil.calculateNumberOfTotalOrderings(final PartialOrderedSet<?> set)", "testcase": false, "constructor": false}, {"identifier": "getAllTotalOrderings", "parameters": "(final PartialOrderedSet<E> set)", "modifiers": "public static", "return": "Collection<List<E>>", "signature": "Collection<List<E>> getAllTotalOrderings(final PartialOrderedSet<E> set)", "full_signature": "public static Collection<List<E>> getAllTotalOrderings(final PartialOrderedSet<E> set)", "class_method_signature": "SetUtil.getAllTotalOrderings(final PartialOrderedSet<E> set)", "testcase": false, "constructor": false}, {"identifier": "serializeAsSet", "parameters": "(final Collection<String> set)", "modifiers": "public static", "return": "String", "signature": "String serializeAsSet(final Collection<String> set)", "full_signature": "public static String serializeAsSet(final Collection<String> set)", "class_method_signature": "SetUtil.serializeAsSet(final Collection<String> set)", "testcase": false, "constructor": false}, {"identifier": "unserializeSet", "parameters": "(final String setDescriptor)", "modifiers": "public static", "return": "Set<String>", "signature": "Set<String> unserializeSet(final String setDescriptor)", "full_signature": "public static Set<String> unserializeSet(final String setDescriptor)", "class_method_signature": "SetUtil.unserializeSet(final String setDescriptor)", "testcase": false, "constructor": false}, {"identifier": "unserializeList", "parameters": "(final String listDescriptor)", "modifiers": "public static", "return": "List<String>", "signature": "List<String> unserializeList(final String listDescriptor)", "full_signature": "public static List<String> unserializeList(final String listDescriptor)", "class_method_signature": "SetUtil.unserializeList(final String listDescriptor)", "testcase": false, "constructor": false}, {"identifier": "unserializeInterval", "parameters": "(final String intervalDescriptor)", "modifiers": "public static", "return": "Interval", "signature": "Interval unserializeInterval(final String intervalDescriptor)", "full_signature": "public static Interval unserializeInterval(final String intervalDescriptor)", "class_method_signature": "SetUtil.unserializeInterval(final String intervalDescriptor)", "testcase": false, "constructor": false}, {"identifier": "getInvertedCopyOfList", "parameters": "(final List<T> list)", "modifiers": "public static", "return": "List<T>", "signature": "List<T> getInvertedCopyOfList(final List<T> list)", "full_signature": "public static List<T> getInvertedCopyOfList(final List<T> list)", "class_method_signature": "SetUtil.getInvertedCopyOfList(final List<T> list)", "testcase": false, "constructor": false}, {"identifier": "addAndGet", "parameters": "(final List<T> list, final T item)", "modifiers": "public static", "return": "List<T>", "signature": "List<T> addAndGet(final List<T> list, final T item)", "full_signature": "public static List<T> addAndGet(final List<T> list, final T item)", "class_method_signature": "SetUtil.addAndGet(final List<T> list, final T item)", "testcase": false, "constructor": false}, {"identifier": "groupCollectionByAttribute", "parameters": "(final Collection<T> collection, final IGetter<T, U> getter)", "modifiers": "public static", "return": "Map<U, Collection<T>>", "signature": "Map<U, Collection<T>> groupCollectionByAttribute(final Collection<T> collection, final IGetter<T, U> getter)", "full_signature": "public static Map<U, Collection<T>> groupCollectionByAttribute(final Collection<T> collection, final IGetter<T, U> getter)", "class_method_signature": "SetUtil.groupCollectionByAttribute(final Collection<T> collection, final IGetter<T, U> getter)", "testcase": false, "constructor": false}, {"identifier": "explode", "parameters": "(final String stringList)", "modifiers": "public static", "return": "List<String>", "signature": "List<String> explode(final String stringList)", "full_signature": "public static List<String> explode(final String stringList)", "class_method_signature": "SetUtil.explode(final String stringList)", "testcase": false, "constructor": false}, {"identifier": "explode", "parameters": "(final String stringList, final String separator)", "modifiers": "public static", "return": "List<String>", "signature": "List<String> explode(final String stringList, final String separator)", "full_signature": "public static List<String> explode(final String stringList, final String separator)", "class_method_signature": "SetUtil.explode(final String stringList, final String separator)", "testcase": false, "constructor": false}, {"identifier": "implode", "parameters": "(final Collection<? extends Object> collection, final String separator)", "modifiers": "public static", "return": "String", "signature": "String implode(final Collection<? extends Object> collection, final String separator)", "full_signature": "public static String implode(final Collection<? extends Object> collection, final String separator)", "class_method_signature": "SetUtil.implode(final Collection<? extends Object> collection, final String separator)", "testcase": false, "constructor": false}, {"identifier": "doesStringCollectionOnlyContainNumbers", "parameters": "(final Collection<String> strings)", "modifiers": "public static", "return": "boolean", "signature": "boolean doesStringCollectionOnlyContainNumbers(final Collection<String> strings)", "full_signature": "public static boolean doesStringCollectionOnlyContainNumbers(final Collection<String> strings)", "class_method_signature": "SetUtil.doesStringCollectionOnlyContainNumbers(final Collection<String> strings)", "testcase": false, "constructor": false}, {"identifier": "getGenericClass", "parameters": "(final Collection<?> c)", "modifiers": "public static", "return": "Type", "signature": "Type getGenericClass(final Collection<?> c)", "full_signature": "public static Type getGenericClass(final Collection<?> c)", "class_method_signature": "SetUtil.getGenericClass(final Collection<?> c)", "testcase": false, "constructor": false}, {"identifier": "argmax", "parameters": "(final List<T> list)", "modifiers": "public static", "return": "int", "signature": "int argmax(final List<T> list)", "full_signature": "public static int argmax(final List<T> list)", "class_method_signature": "SetUtil.argmax(final List<T> list)", "testcase": false, "constructor": false}, {"identifier": "argmax", "parameters": "(final T[] arr)", "modifiers": "public static", "return": "int", "signature": "int argmax(final T[] arr)", "full_signature": "public static int argmax(final T[] arr)", "class_method_signature": "SetUtil.argmax(final T[] arr)", "testcase": false, "constructor": false}, {"identifier": "argmin", "parameters": "(final List<T> list)", "modifiers": "public static", "return": "int", "signature": "int argmin(final List<T> list)", "full_signature": "public static int argmin(final List<T> list)", "class_method_signature": "SetUtil.argmin(final List<T> list)", "testcase": false, "constructor": false}, {"identifier": "argmin", "parameters": "(final T[] arr)", "modifiers": "public static", "return": "int", "signature": "int argmin(final T[] arr)", "full_signature": "public static int argmin(final T[] arr)", "class_method_signature": "SetUtil.argmin(final T[] arr)", "testcase": false, "constructor": false}, {"identifier": "argmin", "parameters": "(final int[] arr)", "modifiers": "public static", "return": "int", "signature": "int argmin(final int[] arr)", "full_signature": "public static int argmin(final int[] arr)", "class_method_signature": "SetUtil.argmin(final int[] arr)", "testcase": false, "constructor": false}, {"identifier": "argmax", "parameters": "(final int[] arr)", "modifiers": "public static", "return": "int", "signature": "int argmax(final int[] arr)", "full_signature": "public static int argmax(final int[] arr)", "class_method_signature": "SetUtil.argmax(final int[] arr)", "testcase": false, "constructor": false}], "file": "JAICore/jaicore-basic/src/main/java/ai/libs/jaicore/basic/sets/SetUtil.java"}, "focal_method": {"identifier": "differenceEmpty", "parameters": "(final Collection<T> a, final Collection<U> b)", "modifiers": "public static", "return": "boolean", "body": "public static <S, T extends S, U extends S> boolean differenceEmpty(final Collection<T> a, final Collection<U> b) {\n\t\tif (a == null || a.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (S item : a) {\n\t\t\tif (!b.contains(item)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "signature": "boolean differenceEmpty(final Collection<T> a, final Collection<U> b)", "full_signature": "public static boolean differenceEmpty(final Collection<T> a, final Collection<U> b)", "class_method_signature": "SetUtil.differenceEmpty(final Collection<T> a, final Collection<U> b)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "contains"]}, "repository": {"repo_id": 95635499, "url": "https://github.com/fmohr/AILibs", "language": "Java", "is_fork": false, "fork_count": 26, "stargazer_count": 25, "size": 155873, "license": "licensed"}}