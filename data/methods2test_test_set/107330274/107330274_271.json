{"test_class": {"identifier": "SimpleCapacityGuaranteeStrategyTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final CapacityManagementConfiguration configuration = BeanCapacityManagementConfiguration.newBuilder()\n            .withCriticalTierBuffer(0.1)\n            .withFlexTierBuffer(0.1)\n            .build();", "modifier": "private static final", "type": "CapacityManagementConfiguration", "declarator": "configuration = BeanCapacityManagementConfiguration.newBuilder()\n            .withCriticalTierBuffer(0.1)\n            .withFlexTierBuffer(0.1)\n            .build()", "var_name": "configuration"}, {"original_string": "private final AgentManagementService agentManagementService = mock(AgentManagementService.class);", "modifier": "private final", "type": "AgentManagementService", "declarator": "agentManagementService = mock(AgentManagementService.class)", "var_name": "agentManagementService"}, {"original_string": "private final CapacityGuaranteeStrategy strategy = new SimpleCapacityGuaranteeStrategy(\n            configuration,\n            agentManagementService,\n            ServerInfoResolvers.fromAwsInstanceTypes()\n    );", "modifier": "private final", "type": "CapacityGuaranteeStrategy", "declarator": "strategy = new SimpleCapacityGuaranteeStrategy(\n            configuration,\n            agentManagementService,\n            ServerInfoResolvers.fromAwsInstanceTypes()\n    )", "var_name": "strategy"}], "file": "titus-server-master/src/test/java/com/netflix/titus/master/service/management/internal/SimpleCapacityGuaranteeStrategyTest.java"}, "test_case": {"identifier": "testFlexTierMultiInstanceAllocation", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testFlexTierMultiInstanceAllocation() {\n        List<AgentInstanceGroup> instanceGroups = asList(\n                getInstanceGroup(Tier.Critical, M4_XLARGE_ID, 0, 0),\n                getInstanceGroup(Tier.Critical, M4_4XLARGE_ID, 0, 0),\n                getInstanceGroup(Tier.Flex, R4_8XLARGE_ID, 0, 5),\n                getInstanceGroup(Tier.Flex, R4_4XLARGE_ID, 0, 5),\n                getInstanceGroup(Tier.Flex, P2_8XLARGE_ID, 0, 5)\n        );\n        when(agentManagementService.getInstanceGroups()).thenReturn(instanceGroups);\n\n        ApplicationSLA defaultSLA = ApplicationSLA.newBuilder()\n                .withAppName(ApplicationSlaManagementEndpoint.DEFAULT_APPLICATION)\n                .withTier(Tier.Flex)\n                .withResourceDimension(ResourceDimension\n                        .newBuilder().withCpus(4).withMemoryMB(512).withNetworkMbs(128).withDiskMB(512).build()\n                )\n                .withInstanceCount(10)\n                .build();\n        ApplicationSLA flexAppSLA = ApplicationSLA.newBuilder(defaultSLA).withInstanceCount(40).build();\n\n        CapacityRequirements requirements = new CapacityRequirements(singletonMap(Tier.Flex, asList(defaultSLA, flexAppSLA)));\n\n        CapacityAllocations allocations = strategy.compute(requirements);\n\n        allocations.getInstanceGroups().forEach(instanceGroup -> {\n            assertThat(instanceGroup.getTier()).isEqualTo(Tier.Flex);\n        });\n\n        AgentInstanceGroup r48xlInstanceGroup = findInstanceGroupByInstanceType(allocations.getInstanceGroups(), R4_8XLARGE_ID);\n        assertThat(allocations.getExpectedMinSize(r48xlInstanceGroup)).isEqualTo(5);\n\n        AgentInstanceGroup r44xlInstanceGroup = findInstanceGroupByInstanceType(allocations.getInstanceGroups(), R4_4XLARGE_ID);\n        assertThat(allocations.getExpectedMinSize(r44xlInstanceGroup)).isEqualTo(4);\n\n        AgentInstanceGroup p28xlInstanceGroup = findInstanceGroupByInstanceType(allocations.getInstanceGroups(), P2_8XLARGE_ID);\n        assertThat(allocations.getExpectedMinSize(p28xlInstanceGroup)).isEqualTo(0);\n    }", "signature": "void testFlexTierMultiInstanceAllocation()", "full_signature": "@Test public void testFlexTierMultiInstanceAllocation()", "class_method_signature": "SimpleCapacityGuaranteeStrategyTest.testFlexTierMultiInstanceAllocation()", "testcase": true, "constructor": false, "invocations": ["asList", "getInstanceGroup", "getInstanceGroup", "getInstanceGroup", "getInstanceGroup", "getInstanceGroup", "thenReturn", "when", "getInstanceGroups", "build", "withInstanceCount", "withResourceDimension", "withTier", "withAppName", "newBuilder", "build", "withDiskMB", "withNetworkMbs", "withMemoryMB", "withCpus", "newBuilder", "build", "withInstanceCount", "newBuilder", "singletonMap", "asList", "compute", "forEach", "getInstanceGroups", "isEqualTo", "assertThat", "getTier", "findInstanceGroupByInstanceType", "getInstanceGroups", "isEqualTo", "assertThat", "getExpectedMinSize", "findInstanceGroupByInstanceType", "getInstanceGroups", "isEqualTo", "assertThat", "getExpectedMinSize", "findInstanceGroupByInstanceType", "getInstanceGroups", "isEqualTo", "assertThat", "getExpectedMinSize"]}, "focal_class": {"identifier": "SimpleCapacityGuaranteeStrategy", "superclass": "", "interfaces": "implements CapacityGuaranteeStrategy", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(SimpleCapacityGuaranteeStrategy.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(SimpleCapacityGuaranteeStrategy.class)", "var_name": "logger"}, {"original_string": "private final CapacityManagementConfiguration configuration;", "modifier": "private final", "type": "CapacityManagementConfiguration", "declarator": "configuration", "var_name": "configuration"}, {"original_string": "private final AgentManagementService agentManagementService;", "modifier": "private final", "type": "AgentManagementService", "declarator": "agentManagementService", "var_name": "agentManagementService"}, {"original_string": "private final ServerInfoResolver serverInfoResolver;", "modifier": "private final", "type": "ServerInfoResolver", "declarator": "serverInfoResolver", "var_name": "serverInfoResolver"}], "methods": [{"identifier": "SimpleCapacityGuaranteeStrategy", "parameters": "(CapacityManagementConfiguration configuration,\n                                           AgentManagementService agentManagementService,\n                                           ServerInfoResolver serverInfoResolver)", "modifiers": "@Inject public", "return": "", "signature": " SimpleCapacityGuaranteeStrategy(CapacityManagementConfiguration configuration,\n                                           AgentManagementService agentManagementService,\n                                           ServerInfoResolver serverInfoResolver)", "full_signature": "@Inject public  SimpleCapacityGuaranteeStrategy(CapacityManagementConfiguration configuration,\n                                           AgentManagementService agentManagementService,\n                                           ServerInfoResolver serverInfoResolver)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.SimpleCapacityGuaranteeStrategy(CapacityManagementConfiguration configuration,\n                                           AgentManagementService agentManagementService,\n                                           ServerInfoResolver serverInfoResolver)", "testcase": false, "constructor": true}, {"identifier": "compute", "parameters": "(CapacityRequirements capacityRequirements)", "modifiers": "@Override public", "return": "CapacityAllocations", "signature": "CapacityAllocations compute(CapacityRequirements capacityRequirements)", "full_signature": "@Override public CapacityAllocations compute(CapacityRequirements capacityRequirements)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.compute(CapacityRequirements capacityRequirements)", "testcase": false, "constructor": false}, {"identifier": "allocate", "parameters": "(Tier tier,\n                                                 CapacityRequirements capacityRequirements,\n                                                 Map<AgentInstanceGroup, Integer> instanceAllocations)", "modifiers": "private", "return": "Optional<ResourceDimension>", "signature": "Optional<ResourceDimension> allocate(Tier tier,\n                                                 CapacityRequirements capacityRequirements,\n                                                 Map<AgentInstanceGroup, Integer> instanceAllocations)", "full_signature": "private Optional<ResourceDimension> allocate(Tier tier,\n                                                 CapacityRequirements capacityRequirements,\n                                                 Map<AgentInstanceGroup, Integer> instanceAllocations)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.allocate(Tier tier,\n                                                 CapacityRequirements capacityRequirements,\n                                                 Map<AgentInstanceGroup, Integer> instanceAllocations)", "testcase": false, "constructor": false}, {"identifier": "computeTierResourceDimension", "parameters": "(Tier tier, CapacityRequirements capacityRequirements)", "modifiers": "private", "return": "ResourceDimension", "signature": "ResourceDimension computeTierResourceDimension(Tier tier, CapacityRequirements capacityRequirements)", "full_signature": "private ResourceDimension computeTierResourceDimension(Tier tier, CapacityRequirements capacityRequirements)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.computeTierResourceDimension(Tier tier, CapacityRequirements capacityRequirements)", "testcase": false, "constructor": false}, {"identifier": "getInstancesUsed", "parameters": "(Map<AgentInstanceGroup, Integer> instanceAllocations, AgentInstanceGroup instanceGroup)", "modifiers": "private", "return": "int", "signature": "int getInstancesUsed(Map<AgentInstanceGroup, Integer> instanceAllocations, AgentInstanceGroup instanceGroup)", "full_signature": "private int getInstancesUsed(Map<AgentInstanceGroup, Integer> instanceAllocations, AgentInstanceGroup instanceGroup)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.getInstancesUsed(Map<AgentInstanceGroup, Integer> instanceAllocations, AgentInstanceGroup instanceGroup)", "testcase": false, "constructor": false}], "file": "titus-server-master/src/main/java/com/netflix/titus/master/service/management/internal/SimpleCapacityGuaranteeStrategy.java"}, "focal_method": {"identifier": "compute", "parameters": "(CapacityRequirements capacityRequirements)", "modifiers": "@Override public", "return": "CapacityAllocations", "body": "@Override\n    public CapacityAllocations compute(CapacityRequirements capacityRequirements) {\n        Map<AgentInstanceGroup, Integer> instanceAllocations = new HashMap<>();\n        Map<Tier, ResourceDimension> resourceShortage = new HashMap<>();\n        for (Tier tier : capacityRequirements.getTiers()) {\n            // In Flex tier we have always 'DEFAULT' app, and if it is the only one, we should not scale the cluster\n            // For other tiers we stop scaling, if there are no application SLAs configured\n            boolean hasEnoughApps = (tier == Tier.Flex && capacityRequirements.getTierRequirements(tier).size() > 1)\n                    || (tier != Tier.Flex && capacityRequirements.getTierRequirements(tier).size() > 0);\n            if (hasEnoughApps) {\n                Optional<ResourceDimension> left = allocate(tier, capacityRequirements, instanceAllocations);\n                left.ifPresent(resourceDimension -> resourceShortage.put(tier, resourceDimension));\n            }\n        }\n        return new CapacityAllocations(instanceAllocations, resourceShortage);\n    }", "signature": "CapacityAllocations compute(CapacityRequirements capacityRequirements)", "full_signature": "@Override public CapacityAllocations compute(CapacityRequirements capacityRequirements)", "class_method_signature": "SimpleCapacityGuaranteeStrategy.compute(CapacityRequirements capacityRequirements)", "testcase": false, "constructor": false, "invocations": ["getTiers", "size", "getTierRequirements", "size", "getTierRequirements", "allocate", "ifPresent", "put"]}, "repository": {"repo_id": 107330274, "url": "https://github.com/Netflix/titus-control-plane", "stars": 241, "created": "10/17/2017 10:20:55 PM +00:00", "updates": "2020-01-25T13:01:05+00:00", "fork": "False", "license": "licensed"}}