{"test_class": {"identifier": "TestUDPNotificationHandler", "superclass": "", "interfaces": "", "fields": [{"original_string": "FalseClient fakeClient;", "modifier": "", "type": "FalseClient", "declarator": "fakeClient", "var_name": "fakeClient"}, {"original_string": "String sourceName;", "modifier": "", "type": "String", "declarator": "sourceName", "var_name": "sourceName"}, {"original_string": "DatagramPacket pack;", "modifier": "", "type": "DatagramPacket", "declarator": "pack", "var_name": "pack"}, {"original_string": "UDPNotificationHandler nHandler;", "modifier": "", "type": "UDPNotificationHandler", "declarator": "nHandler", "var_name": "nHandler"}, {"original_string": "Map<String,Object> incoming = new LinkedHashMap<>();", "modifier": "", "type": "Map<String,Object>", "declarator": "incoming = new LinkedHashMap<>()", "var_name": "incoming"}], "file": "udpSource/src/test/java/io/vantiq/extsrc/udp/TestUDPNotificationHandler.java"}, "test_case": {"identifier": "testCSV", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCSV() {\n        incoming.put(\"expectCsvIn\", true);\n        \n        nHandler = new UDPNotificationHandler(incoming, fakeClient);\n        \n        String address = \"localhost\";\n        int port = 1234;\n        String testStr = \"first,second,last\\na,b,c\\nd,e,f\";\n        \n        Map<String,Object> subMap1 = new LinkedHashMap<>();\n        subMap1.put(\"first\", \"a\");\n        subMap1.put(\"second\", \"b\");\n        subMap1.put(\"last\", \"c\");\n        Map<String,Object> subMap2 = new LinkedHashMap<>();\n        subMap2.put(\"first\", \"d\");\n        subMap2.put(\"second\", \"e\");\n        subMap2.put(\"last\", \"f\");\n        Map[] expectedData = {subMap1,subMap2}; \n        \n        createPacket(testStr, address, port);\n        nHandler.handleMessage(pack);\n        \n        assert fakeClient.compareData(Arrays.asList(expectedData));\n    }", "signature": "void testCSV()", "full_signature": "@Test public void testCSV()", "class_method_signature": "TestUDPNotificationHandler.testCSV()", "testcase": true, "constructor": false, "invocations": ["put", "put", "put", "put", "put", "put", "put", "createPacket", "handleMessage", "compareData", "asList"]}, "focal_class": {"identifier": "UDPNotificationHandler", "superclass": "extends Handler<DatagramPacket>", "interfaces": "", "fields": [{"original_string": "private MapTransformer transformer = null;", "modifier": "private", "type": "MapTransformer", "declarator": "transformer = null", "var_name": "transformer"}, {"original_string": "private ExtensionWebSocketClient client;", "modifier": "private", "type": "ExtensionWebSocketClient", "declarator": "client", "var_name": "client"}, {"original_string": "private String recAddressKey = null;", "modifier": "private", "type": "String", "declarator": "recAddressKey = null", "var_name": "recAddressKey"}, {"original_string": "private String recPortKey = null;", "modifier": "private", "type": "String", "declarator": "recPortKey = null", "var_name": "recPortKey"}, {"original_string": "final private Logger log;", "modifier": "final private", "type": "Logger", "declarator": "log", "var_name": "log"}, {"original_string": "private ObjectMapper mapper = new ObjectMapper();", "modifier": "private", "type": "ObjectMapper", "declarator": "mapper = new ObjectMapper()", "var_name": "mapper"}, {"original_string": "private boolean expectingXml = false;", "modifier": "private", "type": "boolean", "declarator": "expectingXml = false", "var_name": "expectingXml"}, {"original_string": "private String xmlRootLoc = null;", "modifier": "private", "type": "String", "declarator": "xmlRootLoc = null", "var_name": "xmlRootLoc"}, {"original_string": "private boolean expectingCsv = false;", "modifier": "private", "type": "boolean", "declarator": "expectingCsv = false", "var_name": "expectingCsv"}, {"original_string": "private String bytesLocation = null;", "modifier": "private", "type": "String", "declarator": "bytesLocation = null", "var_name": "bytesLocation"}, {"original_string": "private boolean passingPureMap = false;", "modifier": "private", "type": "boolean", "declarator": "passingPureMap = false", "var_name": "passingPureMap"}, {"original_string": "private boolean passingUnspecified = false;", "modifier": "private", "type": "boolean", "declarator": "passingUnspecified = false", "var_name": "passingUnspecified"}, {"original_string": "private Pattern regexPattern = null;", "modifier": "private", "type": "Pattern", "declarator": "regexPattern = null", "var_name": "regexPattern"}, {"original_string": "private String[] patternLocations = null;", "modifier": "private", "type": "String[]", "declarator": "patternLocations = null", "var_name": "patternLocations"}], "methods": [{"identifier": "UDPNotificationHandler", "parameters": "(Map incoming, ExtensionWebSocketClient client)", "modifiers": "public", "return": "", "signature": " UDPNotificationHandler(Map incoming, ExtensionWebSocketClient client)", "full_signature": "public  UDPNotificationHandler(Map incoming, ExtensionWebSocketClient client)", "class_method_signature": "UDPNotificationHandler.UDPNotificationHandler(Map incoming, ExtensionWebSocketClient client)", "testcase": false, "constructor": true}, {"identifier": "hasIncomingTransformations", "parameters": "(Map incoming)", "modifiers": "private static", "return": "boolean", "signature": "boolean hasIncomingTransformations(Map incoming)", "full_signature": "private static boolean hasIncomingTransformations(Map incoming)", "class_method_signature": "UDPNotificationHandler.hasIncomingTransformations(Map incoming)", "testcase": false, "constructor": false}, {"identifier": "handleMessage", "parameters": "(DatagramPacket packet)", "modifiers": "@Override public", "return": "void", "signature": "void handleMessage(DatagramPacket packet)", "full_signature": "@Override public void handleMessage(DatagramPacket packet)", "class_method_signature": "UDPNotificationHandler.handleMessage(DatagramPacket packet)", "testcase": false, "constructor": false}, {"identifier": "getRegexResults", "parameters": "(String str)", "modifiers": "private", "return": "Map<String,Object>", "signature": "Map<String,Object> getRegexResults(String str)", "full_signature": "private Map<String,Object> getRegexResults(String str)", "class_method_signature": "UDPNotificationHandler.getRegexResults(String str)", "testcase": false, "constructor": false}], "file": "udpSource/src/main/java/io/vantiq/extsrc/udp/UDPNotificationHandler.java"}, "focal_method": {"identifier": "handleMessage", "parameters": "(DatagramPacket packet)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void handleMessage(DatagramPacket packet) {\n        Map receivedMsg = null;\n        Map<String,Object> sendMsg = new LinkedHashMap<>();\n        if (bytesLocation != null || regexPattern != null) {\n            // Can't be parsed with Object mapper \n        }\n        else if (expectingCsv) {\n            try  {\n                List<Object> csv = mapper.readerFor(List.class).with(CsvSchema.emptySchema().withHeader())\n                        .readValue(packet.getData());\n                client.sendNotification(csv);\n            }\n            catch (Exception e){\n                log.warn(\"Failed to interpret UDP message as CSV.\", e);\n            }\n            return;\n        }\n        else{\n            try {\n                receivedMsg = mapper.readValue(packet.getData(), Map.class);\n            } \n            catch (Exception e) {\n                if (expectingXml) {\n                    log.warn(\"Failed to interpret UDP message as a XML object.\", e);\n                }\n                else {  // expecting JSON\n                    log.warn(\"Failed to interpret UDP message as a JSON object.\", e);\n                }\n                return;\n            }\n        }\n        \n\n        // Transforms the message as requested by the Configuration document\n        if (regexPattern != null) {\n            \n            // Create a String from the byte data, but remove unused bytes\n            String recString = new String(packet.getData());\n            int endIndex = recString.indexOf(\"\\0\");\n            if (endIndex == -1) {endIndex = packet.getData().length;}\n            recString = new String(packet.getData(), 0, endIndex, Charset.forName(\"UTF-8\"));\n            \n            sendMsg = getRegexResults(recString);\n        }\n        else if (bytesLocation != null) {\n            // Create a String from the byte data, but remove unused bytes\n            String recString = new String(packet.getData());\n            int endIndex = recString.indexOf(\"\\0\");\n            if (endIndex == -1) {endIndex = packet.getData().length;}\n            recString = new String(packet.getData(), 0, endIndex, Charset.forName(\"UTF-8\"));\n            \n            MapTransformer.createTransformVal(sendMsg, bytesLocation, recString);\n        }\n        else if (passingPureMap) {\n            sendMsg = receivedMsg;\n        }\n        else if (passingUnspecified) {\n            // Set the messages to the same map so any untransformed values stay, and tell it to destroy any values removed\n            sendMsg = receivedMsg;\n            if (this.transformer != null) {\n                this.transformer.transform(receivedMsg, sendMsg, true);\n            }\n        }\n        else if (transformer == null) {\n            // This means that no transform was specified and neither were any pass___ parameters in which case\n            // the design decision is to send an empty Map, so the source is notified that a UDP message was received\n            sendMsg = new LinkedHashMap<>();\n        }\n        else {\n            this.transformer.transform(receivedMsg, sendMsg, false);\n        }\n\n        if (expectingXml && xmlRootLoc != null) {\n            try {\n                FromXmlParser p = (FromXmlParser) mapper.getFactory().createParser(packet.getData());\n                MapTransformer.createTransformVal(sendMsg, xmlRootLoc, p.getStaxReader().getLocalName());\n            }\n            catch (Exception e) {\n                log.error(\"Failed to interpret name of root\", e);\n            }\n        }\n        \n        // Add the address and port that the packet came from if the config demands it\n        if (recAddressKey != null) {\n            MapTransformer.createTransformVal(sendMsg, recAddressKey, packet.getAddress().getHostAddress());\n        }\n        if (recPortKey != null) {\n            MapTransformer.createTransformVal(sendMsg, recPortKey, packet.getPort());\n        }\n\n        client.sendNotification(sendMsg);\n    }", "signature": "void handleMessage(DatagramPacket packet)", "full_signature": "@Override public void handleMessage(DatagramPacket packet)", "class_method_signature": "UDPNotificationHandler.handleMessage(DatagramPacket packet)", "testcase": false, "constructor": false, "invocations": ["readValue", "with", "readerFor", "withHeader", "emptySchema", "getData", "sendNotification", "warn", "readValue", "getData", "warn", "warn", "getData", "indexOf", "getData", "getData", "forName", "getRegexResults", "getData", "indexOf", "getData", "getData", "forName", "createTransformVal", "transform", "transform", "createParser", "getFactory", "getData", "createTransformVal", "getLocalName", "getStaxReader", "error", "createTransformVal", "getHostAddress", "getAddress", "createTransformVal", "getPort", "sendNotification"]}, "repository": {"repo_id": 141492069, "url": "https://github.com/Vantiq/vantiq-extension-sources", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 9, "size": 16261, "license": "licensed"}}