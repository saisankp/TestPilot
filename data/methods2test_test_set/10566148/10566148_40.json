{"test_class": {"identifier": "ModulesInvokerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private List<SagaModule> modules;", "modifier": "private", "type": "List<SagaModule>", "declarator": "modules", "var_name": "modules"}], "file": "saga-lib/src/test/java/com/codebullets/sagalib/processing/invocation/ModulesInvokerTest.java"}, "test_case": {"identifier": "start_startErrorOnSecondModule_doNotStartOrFinishedThird", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void start_startErrorOnSecondModule_doNotStartOrFinishedThird() {\n        // given\n        CurrentExecutionContext context = mock(CurrentExecutionContext.class);\n        NullPointerException ex = new NullPointerException();\n        doThrow(ex).when(modules.get(1)).onStart(context);\n\n        // when\n        try {\n            ModulesInvoker.start(context, modules);\n        } catch (Exception e) {\n            // is expected, module start() is exception neutral\n        }\n\n        // then\n        verify(modules.get(2), never()).onStart(context);\n        verify(modules.get(2), never()).onFinished(context);\n    }", "signature": "void start_startErrorOnSecondModule_doNotStartOrFinishedThird()", "full_signature": "@Test public void start_startErrorOnSecondModule_doNotStartOrFinishedThird()", "class_method_signature": "ModulesInvokerTest.start_startErrorOnSecondModule_doNotStartOrFinishedThird()", "testcase": true, "constructor": false, "invocations": ["mock", "onStart", "when", "doThrow", "get", "start", "onStart", "verify", "get", "never", "onFinished", "verify", "get", "never"]}, "focal_class": {"identifier": "ModulesInvoker", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(ModulesInvoker.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(ModulesInvoker.class)", "var_name": "LOG"}, {"original_string": "private final List<Supplier<Optional<Exception>>> finishers;", "modifier": "private final", "type": "List<Supplier<Optional<Exception>>>", "declarator": "finishers", "var_name": "finishers"}, {"original_string": "private final List<BiFunction<Object, Throwable, Optional<Exception>>> errorHandlers;", "modifier": "private final", "type": "List<BiFunction<Object, Throwable, Optional<Exception>>>", "declarator": "errorHandlers", "var_name": "errorHandlers"}], "methods": [{"identifier": "ModulesInvoker", "parameters": "(\n            final List<Supplier<Optional<Exception>>> finishers,\n            final List<BiFunction<Object, Throwable, Optional<Exception>>> errorHandlers)", "modifiers": "private", "return": "", "signature": " ModulesInvoker(\n            final List<Supplier<Optional<Exception>>> finishers,\n            final List<BiFunction<Object, Throwable, Optional<Exception>>> errorHandlers)", "full_signature": "private  ModulesInvoker(\n            final List<Supplier<Optional<Exception>>> finishers,\n            final List<BiFunction<Object, Throwable, Optional<Exception>>> errorHandlers)", "class_method_signature": "ModulesInvoker.ModulesInvoker(\n            final List<Supplier<Optional<Exception>>> finishers,\n            final List<BiFunction<Object, Throwable, Optional<Exception>>> errorHandlers)", "testcase": false, "constructor": true}, {"identifier": "start", "parameters": "(final ExecutionContext context, final Iterable<SagaModule> modules)", "modifiers": "static", "return": "StartResult", "signature": "StartResult start(final ExecutionContext context, final Iterable<SagaModule> modules)", "full_signature": "static StartResult start(final ExecutionContext context, final Iterable<SagaModule> modules)", "class_method_signature": "ModulesInvoker.start(final ExecutionContext context, final Iterable<SagaModule> modules)", "testcase": false, "constructor": false}, {"identifier": "finish", "parameters": "()", "modifiers": "", "return": "Collection<Exception>", "signature": "Collection<Exception> finish()", "full_signature": " Collection<Exception> finish()", "class_method_signature": "ModulesInvoker.finish()", "testcase": false, "constructor": false}, {"identifier": "error", "parameters": "(final Object message, final Throwable error)", "modifiers": "public", "return": "Collection<Exception>", "signature": "Collection<Exception> error(final Object message, final Throwable error)", "full_signature": "public Collection<Exception> error(final Object message, final Throwable error)", "class_method_signature": "ModulesInvoker.error(final Object message, final Throwable error)", "testcase": false, "constructor": false}, {"identifier": "createFinisher", "parameters": "(final SagaModule module, final ExecutionContext context)", "modifiers": "private static", "return": "Supplier<Optional<Exception>>", "signature": "Supplier<Optional<Exception>> createFinisher(final SagaModule module, final ExecutionContext context)", "full_signature": "private static Supplier<Optional<Exception>> createFinisher(final SagaModule module, final ExecutionContext context)", "class_method_signature": "ModulesInvoker.createFinisher(final SagaModule module, final ExecutionContext context)", "testcase": false, "constructor": false}, {"identifier": "createErrorHandler", "parameters": "(final SagaModule module, final ExecutionContext context)", "modifiers": "private static", "return": "BiFunction<Object, Throwable, Optional<Exception>>", "signature": "BiFunction<Object, Throwable, Optional<Exception>> createErrorHandler(final SagaModule module, final ExecutionContext context)", "full_signature": "private static BiFunction<Object, Throwable, Optional<Exception>> createErrorHandler(final SagaModule module, final ExecutionContext context)", "class_method_signature": "ModulesInvoker.createErrorHandler(final SagaModule module, final ExecutionContext context)", "testcase": false, "constructor": false}, {"identifier": "tryExecute", "parameters": "(final Runnable runnable, final SagaModule module)", "modifiers": "private static", "return": "Optional<Exception>", "signature": "Optional<Exception> tryExecute(final Runnable runnable, final SagaModule module)", "full_signature": "private static Optional<Exception> tryExecute(final Runnable runnable, final SagaModule module)", "class_method_signature": "ModulesInvoker.tryExecute(final Runnable runnable, final SagaModule module)", "testcase": false, "constructor": false}], "file": "saga-lib/src/main/java/com/codebullets/sagalib/processing/invocation/ModulesInvoker.java"}, "focal_method": {"identifier": "start", "parameters": "(final ExecutionContext context, final Iterable<SagaModule> modules)", "modifiers": "static", "return": "StartResult", "body": "static StartResult start(final ExecutionContext context, final Iterable<SagaModule> modules) {\n        Exception possibleStartException = null;\n        List<Supplier<Optional<Exception>>> finishers = new ArrayList<>();\n        List<BiFunction<Object, Throwable, Optional<Exception>>> errorHandlers = new ArrayList<>();\n\n        try {\n            for (final SagaModule module : modules) {\n                finishers.add(createFinisher(module, context));\n                errorHandlers.add(createErrorHandler(module, context));\n\n                module.onStart(context);\n            }\n        } catch (Exception ex) {\n            possibleStartException = ex;\n        }\n\n        return new StartResult(possibleStartException, new ModulesInvoker(finishers, errorHandlers));\n    }", "signature": "StartResult start(final ExecutionContext context, final Iterable<SagaModule> modules)", "full_signature": "static StartResult start(final ExecutionContext context, final Iterable<SagaModule> modules)", "class_method_signature": "ModulesInvoker.start(final ExecutionContext context, final Iterable<SagaModule> modules)", "testcase": false, "constructor": false, "invocations": ["add", "createFinisher", "add", "createErrorHandler", "onStart"]}, "repository": {"repo_id": 10566148, "url": "https://github.com/Domo42/saga-lib", "language": "Java", "is_fork": false, "fork_count": 12, "stargazer_count": 32, "size": 545, "license": "licensed"}}