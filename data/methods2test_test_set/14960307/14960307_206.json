{"test_class": {"identifier": "StringUtilTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(StringUtilTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(StringUtilTest.class)", "var_name": "logger"}, {"original_string": "private static final byte[] TEST_BYTES1 = {'H','E','L','L','O',' ','W','O','R','L','D'};", "modifier": "private static final", "type": "byte[]", "declarator": "TEST_BYTES1 = {'H','E','L','L','O',' ','W','O','R','L','D'}", "var_name": "TEST_BYTES1"}, {"original_string": "private static final byte[] TEST_HELLO = {'H','E','L','L','O'};", "modifier": "private static final", "type": "byte[]", "declarator": "TEST_HELLO = {'H','E','L','L','O'}", "var_name": "TEST_HELLO"}, {"original_string": "private static final byte[] TEST_H = {'H'};", "modifier": "private static final", "type": "byte[]", "declarator": "TEST_H = {'H'}", "var_name": "TEST_H"}, {"original_string": "private static final byte[] TEST_WORLD = {'W','O','R','L','D'};", "modifier": "private static final", "type": "byte[]", "declarator": "TEST_WORLD = {'W','O','R','L','D'}", "var_name": "TEST_WORLD"}, {"original_string": "private static final byte[] TEST_W = {'W'};", "modifier": "private static final", "type": "byte[]", "declarator": "TEST_W = {'W'}", "var_name": "TEST_W"}, {"original_string": "private static final byte[] TEST_D = {'D'};", "modifier": "private static final", "type": "byte[]", "declarator": "TEST_D = {'D'}", "var_name": "TEST_D"}, {"original_string": "private static final byte[] TEST_SPACEH = {' ','H'};", "modifier": "private static final", "type": "byte[]", "declarator": "TEST_SPACEH = {' ','H'}", "var_name": "TEST_SPACEH"}, {"original_string": "private static final byte[] TEST_SPACEW = {' ','W'};", "modifier": "private static final", "type": "byte[]", "declarator": "TEST_SPACEW = {' ','W'}", "var_name": "TEST_SPACEW"}], "file": "ch-commons-util/src/test/java/com/cloudhopper/commons/util/StringUtilTest.java"}, "test_case": {"identifier": "substituteWithPropertiesEmptyKeyThrowsException", "parameters": "()", "modifiers": "@Test(expected=SubstitutionException.class) public", "return": "void", "body": "@Test(expected=SubstitutionException.class)\n    public void substituteWithPropertiesEmptyKeyThrowsException() throws Exception {\n        // create test properties\n        Properties props = new Properties();\n        props.put(\"TEST1\", \"Hello World\");\n        // key is empty\n        String string0 = StringUtil.substituteWithProperties(\"$ENV{}\", \"$ENV{\", \"}\", props);\n    }", "signature": "void substituteWithPropertiesEmptyKeyThrowsException()", "full_signature": "@Test(expected=SubstitutionException.class) public void substituteWithPropertiesEmptyKeyThrowsException()", "class_method_signature": "StringUtilTest.substituteWithPropertiesEmptyKeyThrowsException()", "testcase": true, "constructor": false, "invocations": ["put", "substituteWithProperties"]}, "focal_class": {"identifier": "StringUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String PRINTABLE = \": ~`!@#$%^&*()-_+=/\\\\,.[]{}|?<>\\\"'\";", "modifier": "private static final", "type": "String", "declarator": "PRINTABLE = \": ~`!@#$%^&*()-_+=/\\\\,.[]{}|?<>\\\"'\"", "var_name": "PRINTABLE"}, {"original_string": "private static final String SAFE = \":~!@#$%^&*()-_+=/\\\\,.[]{}|?<>\";", "modifier": "private static final", "type": "String", "declarator": "SAFE = \":~!@#$%^&*()-_+=/\\\\,.[]{}|?<>\"", "var_name": "SAFE"}, {"original_string": "private static final String[][] XML_CHARS = {\n        { \"&\", \"&amp;\"},\n        { \"<\", \"&lt;\"},\n        { \">\", \"&gt;\"},\n        { \"\\\"\", \"&quot;\"},\n        { \"'\", \"&apos;\"},\n        { \"\\n\", \"&#10;\"},\n        { \"\\r\", \"&#13;\"},\n    };", "modifier": "private static final", "type": "String[][]", "declarator": "XML_CHARS = {\n        { \"&\", \"&amp;\"},\n        { \"<\", \"&lt;\"},\n        { \">\", \"&gt;\"},\n        { \"\\\"\", \"&quot;\"},\n        { \"'\", \"&apos;\"},\n        { \"\\n\", \"&#10;\"},\n        { \"\\r\", \"&#13;\"},\n    }", "var_name": "XML_CHARS"}, {"original_string": "public static char[] HEX_TABLE = {\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'e', 'f'\n    };", "modifier": "public static", "type": "char[]", "declarator": "HEX_TABLE = {\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'e', 'f'\n    }", "var_name": "HEX_TABLE"}], "methods": [{"identifier": "substituteWithEnvironment", "parameters": "(String string0)", "modifiers": "public static", "return": "String", "signature": "String substituteWithEnvironment(String string0)", "full_signature": "public static String substituteWithEnvironment(String string0)", "class_method_signature": "StringUtil.substituteWithEnvironment(String string0)", "testcase": false, "constructor": false}, {"identifier": "substituteWithProperties", "parameters": "(String string0, String startStr, String endStr, Properties properties)", "modifiers": "public static", "return": "String", "signature": "String substituteWithProperties(String string0, String startStr, String endStr, Properties properties)", "full_signature": "public static String substituteWithProperties(String string0, String startStr, String endStr, Properties properties)", "class_method_signature": "StringUtil.substituteWithProperties(String string0, String startStr, String endStr, Properties properties)", "testcase": false, "constructor": false}, {"identifier": "isSafeString", "parameters": "(String string0)", "modifiers": "public static", "return": "boolean", "signature": "boolean isSafeString(String string0)", "full_signature": "public static boolean isSafeString(String string0)", "class_method_signature": "StringUtil.isSafeString(String string0)", "testcase": false, "constructor": false}, {"identifier": "isSafeChar", "parameters": "(char ch)", "modifiers": "public static", "return": "boolean", "signature": "boolean isSafeChar(char ch)", "full_signature": "public static boolean isSafeChar(char ch)", "class_method_signature": "StringUtil.isSafeChar(char ch)", "testcase": false, "constructor": false}, {"identifier": "capitalize", "parameters": "(String string0)", "modifiers": "static public", "return": "String", "signature": "String capitalize(String string0)", "full_signature": "static public String capitalize(String string0)", "class_method_signature": "StringUtil.capitalize(String string0)", "testcase": false, "constructor": false}, {"identifier": "uncapitalize", "parameters": "(String string0)", "modifiers": "static public", "return": "String", "signature": "String uncapitalize(String string0)", "full_signature": "static public String uncapitalize(String string0)", "class_method_signature": "StringUtil.uncapitalize(String string0)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(String[] strings, String targetString)", "modifiers": "static public", "return": "boolean", "signature": "boolean contains(String[] strings, String targetString)", "full_signature": "static public boolean contains(String[] strings, String targetString)", "class_method_signature": "StringUtil.contains(String[] strings, String targetString)", "testcase": false, "constructor": false}, {"identifier": "indexOf", "parameters": "(String[] strings, String targetString)", "modifiers": "static public", "return": "int", "signature": "int indexOf(String[] strings, String targetString)", "full_signature": "static public int indexOf(String[] strings, String targetString)", "class_method_signature": "StringUtil.indexOf(String[] strings, String targetString)", "testcase": false, "constructor": false}, {"identifier": "stripQuotes", "parameters": "(String string0)", "modifiers": "static public", "return": "String", "signature": "String stripQuotes(String string0)", "full_signature": "static public String stripQuotes(String string0)", "class_method_signature": "StringUtil.stripQuotes(String string0)", "testcase": false, "constructor": false}, {"identifier": "containsOnlyDigits", "parameters": "(String string0)", "modifiers": "static public", "return": "boolean", "signature": "boolean containsOnlyDigits(String string0)", "full_signature": "static public boolean containsOnlyDigits(String string0)", "class_method_signature": "StringUtil.containsOnlyDigits(String string0)", "testcase": false, "constructor": false}, {"identifier": "split", "parameters": "(String str, char delim)", "modifiers": "static public", "return": "String[]", "signature": "String[] split(String str, char delim)", "full_signature": "static public String[] split(String str, char delim)", "class_method_signature": "StringUtil.split(String str, char delim)", "testcase": false, "constructor": false}, {"identifier": "formatForPrint", "parameters": "(String input)", "modifiers": "public final static", "return": "String", "signature": "String formatForPrint(String input)", "full_signature": "public final static String formatForPrint(String input)", "class_method_signature": "StringUtil.formatForPrint(String input)", "testcase": false, "constructor": false}, {"identifier": "toStringArray", "parameters": "(Object[] objArray)", "modifiers": "public static", "return": "String[]", "signature": "String[] toStringArray(Object[] objArray)", "full_signature": "public static String[] toStringArray(Object[] objArray)", "class_method_signature": "StringUtil.toStringArray(Object[] objArray)", "testcase": false, "constructor": false}, {"identifier": "getAsciiBytes", "parameters": "(String input)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] getAsciiBytes(String input)", "full_signature": "public static byte[] getAsciiBytes(String input)", "class_method_signature": "StringUtil.getAsciiBytes(String input)", "testcase": false, "constructor": false}, {"identifier": "getAsciiString", "parameters": "(byte[] input)", "modifiers": "public static", "return": "String", "signature": "String getAsciiString(byte[] input)", "full_signature": "public static String getAsciiString(byte[] input)", "class_method_signature": "StringUtil.getAsciiString(byte[] input)", "testcase": false, "constructor": false}, {"identifier": "trimTrailing", "parameters": "(String str)", "modifiers": "public static", "return": "String", "signature": "String trimTrailing(String str)", "full_signature": "public static String trimTrailing(String str)", "class_method_signature": "StringUtil.trimTrailing(String str)", "testcase": false, "constructor": false}, {"identifier": "truncate", "parameters": "(String value, int length)", "modifiers": "public static", "return": "String", "signature": "String truncate(String value, int length)", "full_signature": "public static String truncate(String value, int length)", "class_method_signature": "StringUtil.truncate(String value, int length)", "testcase": false, "constructor": false}, {"identifier": "slice", "parameters": "(String value,\n            int beginOffset, int endOffset,\n            boolean trim)", "modifiers": "public static", "return": "String", "signature": "String slice(String value,\n            int beginOffset, int endOffset,\n            boolean trim)", "full_signature": "public static String slice(String value,\n            int beginOffset, int endOffset,\n            boolean trim)", "class_method_signature": "StringUtil.slice(String value,\n            int beginOffset, int endOffset,\n            boolean trim)", "testcase": false, "constructor": false}, {"identifier": "toHexString", "parameters": "(byte[] bytes)", "modifiers": "@Deprecated public static", "return": "String", "signature": "String toHexString(byte[] bytes)", "full_signature": "@Deprecated public static String toHexString(byte[] bytes)", "class_method_signature": "StringUtil.toHexString(byte[] bytes)", "testcase": false, "constructor": false}, {"identifier": "toHexString", "parameters": "(byte[] bytes, int offset, int length)", "modifiers": "@Deprecated public static", "return": "String", "signature": "String toHexString(byte[] bytes, int offset, int length)", "full_signature": "@Deprecated public static String toHexString(byte[] bytes, int offset, int length)", "class_method_signature": "StringUtil.toHexString(byte[] bytes, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "toHexByte", "parameters": "(String hexString, int offset, int length)", "modifiers": "@Deprecated public static", "return": "byte[]", "signature": "byte[] toHexByte(String hexString, int offset, int length)", "full_signature": "@Deprecated public static byte[] toHexByte(String hexString, int offset, int length)", "class_method_signature": "StringUtil.toHexByte(String hexString, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "fromHexString", "parameters": "(String hexString)", "modifiers": "@Deprecated public static", "return": "byte[]", "signature": "byte[] fromHexString(String hexString)", "full_signature": "@Deprecated public static byte[] fromHexString(String hexString)", "class_method_signature": "StringUtil.fromHexString(String hexString)", "testcase": false, "constructor": false}, {"identifier": "fromHexString", "parameters": "(String hexString, int offset, int length)", "modifiers": "@Deprecated public static", "return": "byte[]", "signature": "byte[] fromHexString(String hexString, int offset, int length)", "full_signature": "@Deprecated public static byte[] fromHexString(String hexString, int offset, int length)", "class_method_signature": "StringUtil.fromHexString(String hexString, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "isPrintableChar", "parameters": "(char ch)", "modifiers": "public static", "return": "boolean", "signature": "boolean isPrintableChar(char ch)", "full_signature": "public static boolean isPrintableChar(char ch)", "class_method_signature": "StringUtil.isPrintableChar(char ch)", "testcase": false, "constructor": false}, {"identifier": "hexDump", "parameters": "(String prefix, byte[] data)", "modifiers": "public static", "return": "String", "signature": "String hexDump(String prefix, byte[] data)", "full_signature": "public static String hexDump(String prefix, byte[] data)", "class_method_signature": "StringUtil.hexDump(String prefix, byte[] data)", "testcase": false, "constructor": false}, {"identifier": "SQLToUpperCase", "parameters": "(String s)", "modifiers": "public static", "return": "String", "signature": "String SQLToUpperCase(String s)", "full_signature": "public static String SQLToUpperCase(String s)", "class_method_signature": "StringUtil.SQLToUpperCase(String s)", "testcase": false, "constructor": false}, {"identifier": "SQLEqualsIgnoreCase", "parameters": "(String s1, String s2)", "modifiers": "public static", "return": "boolean", "signature": "boolean SQLEqualsIgnoreCase(String s1, String s2)", "full_signature": "public static boolean SQLEqualsIgnoreCase(String s1, String s2)", "class_method_signature": "StringUtil.SQLEqualsIgnoreCase(String s1, String s2)", "testcase": false, "constructor": false}, {"identifier": "normalizeSQLIdentifier", "parameters": "(String id)", "modifiers": "public static", "return": "String", "signature": "String normalizeSQLIdentifier(String id)", "full_signature": "public static String normalizeSQLIdentifier(String id)", "class_method_signature": "StringUtil.normalizeSQLIdentifier(String id)", "testcase": false, "constructor": false}, {"identifier": "compressQuotes", "parameters": "(String source, String quotes)", "modifiers": "public static", "return": "String", "signature": "String compressQuotes(String source, String quotes)", "full_signature": "public static String compressQuotes(String source, String quotes)", "class_method_signature": "StringUtil.compressQuotes(String source, String quotes)", "testcase": false, "constructor": false}, {"identifier": "quoteString", "parameters": "(String source, char quote)", "modifiers": "static", "return": "String", "signature": "String quoteString(String source, char quote)", "full_signature": "static String quoteString(String source, char quote)", "class_method_signature": "StringUtil.quoteString(String source, char quote)", "testcase": false, "constructor": false}, {"identifier": "quoteStringLiteral", "parameters": "(String string)", "modifiers": "public static", "return": "String", "signature": "String quoteStringLiteral(String string)", "full_signature": "public static String quoteStringLiteral(String string)", "class_method_signature": "StringUtil.quoteStringLiteral(String string)", "testcase": false, "constructor": false}, {"identifier": "stringify", "parameters": "(int[] raw)", "modifiers": "public static", "return": "String", "signature": "String stringify(int[] raw)", "full_signature": "public static String stringify(int[] raw)", "class_method_signature": "StringUtil.stringify(int[] raw)", "testcase": false, "constructor": false}, {"identifier": "isEmpty", "parameters": "(String string0)", "modifiers": "public static", "return": "boolean", "signature": "boolean isEmpty(String string0)", "full_signature": "public static boolean isEmpty(String string0)", "class_method_signature": "StringUtil.isEmpty(String string0)", "testcase": false, "constructor": false}, {"identifier": "isEqual", "parameters": "(String string0, String string1)", "modifiers": "public static", "return": "boolean", "signature": "boolean isEqual(String string0, String string1)", "full_signature": "public static boolean isEqual(String string0, String string1)", "class_method_signature": "StringUtil.isEqual(String string0, String string1)", "testcase": false, "constructor": false}, {"identifier": "toStringWithNullAsEmpty", "parameters": "(Object obj)", "modifiers": "static public", "return": "String", "signature": "String toStringWithNullAsEmpty(Object obj)", "full_signature": "static public String toStringWithNullAsEmpty(Object obj)", "class_method_signature": "StringUtil.toStringWithNullAsEmpty(Object obj)", "testcase": false, "constructor": false}, {"identifier": "toStringWithNullAsReplaced", "parameters": "(Object obj)", "modifiers": "static public", "return": "String", "signature": "String toStringWithNullAsReplaced(Object obj)", "full_signature": "static public String toStringWithNullAsReplaced(Object obj)", "class_method_signature": "StringUtil.toStringWithNullAsReplaced(Object obj)", "testcase": false, "constructor": false}, {"identifier": "toStringWithNullAsNull", "parameters": "(Object obj)", "modifiers": "static public", "return": "String", "signature": "String toStringWithNullAsNull(Object obj)", "full_signature": "static public String toStringWithNullAsNull(Object obj)", "class_method_signature": "StringUtil.toStringWithNullAsNull(Object obj)", "testcase": false, "constructor": false}, {"identifier": "isEqual", "parameters": "(String string0, String string1, boolean caseSensitive)", "modifiers": "public static", "return": "boolean", "signature": "boolean isEqual(String string0, String string1, boolean caseSensitive)", "full_signature": "public static boolean isEqual(String string0, String string1, boolean caseSensitive)", "class_method_signature": "StringUtil.isEqual(String string0, String string1, boolean caseSensitive)", "testcase": false, "constructor": false}, {"identifier": "readToString", "parameters": "(InputStream in)", "modifiers": "public static", "return": "String", "signature": "String readToString(InputStream in)", "full_signature": "public static String readToString(InputStream in)", "class_method_signature": "StringUtil.readToString(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "escapeXml", "parameters": "(String value)", "modifiers": "public static", "return": "String", "signature": "String escapeXml(String value)", "full_signature": "public static String escapeXml(String value)", "class_method_signature": "StringUtil.escapeXml(String value)", "testcase": false, "constructor": false}, {"identifier": "removeAllCharsExceptDigits", "parameters": "(String str0)", "modifiers": "static public", "return": "String", "signature": "String removeAllCharsExceptDigits(String str0)", "full_signature": "static public String removeAllCharsExceptDigits(String str0)", "class_method_signature": "StringUtil.removeAllCharsExceptDigits(String str0)", "testcase": false, "constructor": false}], "file": "ch-commons-util/src/main/java/com/cloudhopper/commons/util/StringUtil.java"}, "focal_method": {"identifier": "substituteWithProperties", "parameters": "(String string0, String startStr, String endStr, Properties properties)", "modifiers": "public static", "return": "String", "body": "public static String substituteWithProperties(String string0, String startStr, String endStr, Properties properties) throws SubstitutionException {\n        // a null source string will always return the same -- a null result\n        if (string0 == null) {\n            return null;\n        }\n\n        // create a builder for the resulting string\n        StringBuilder result = new StringBuilder(string0.length());\n\n        // attempt to find the first occurrence of the starting string\n        int end = -1;\n        int pos = string0.indexOf(startStr);\n        \n        // keep looping while we keep finding more occurrences\n        while (pos >= 0) {\n            // is there string data before the position that we should append to the result?\n            if (pos > end+1) {\n                result.append(string0.substring(end+endStr.length(), pos));\n            }\n\n            // search for endStr starting from the end of the startStr\n            end = string0.indexOf(endStr, pos+startStr.length());\n\n            // was the end found?\n            if (end < 0) {\n                throw new SubstitutionException(\"End of substitution pattern '\" + endStr + \"' not found [@position=\" + pos + \"]\");\n            }\n\n            // extract the part in the middle of the start and end strings\n            String key = string0.substring(pos+startStr.length(), end);\n            // NOTE: don't trim the key, whitespace technically matters...\n\n            // was there anything left?\n            if (key == null || key.equals(\"\")) {\n                throw new SubstitutionException(\"Property key was empty in string with an occurrence of '\" + startStr + endStr + \"' [@position=\" + pos + \"]\");\n            }\n\n            // attempt to get this property\n            String value = properties.getProperty(key);\n            // was the property found\n            if (value == null) {\n                throw new SubstitutionException(\"A property value for '\" + startStr + key + endStr + \"' was not found (property missing?)\");\n            }\n\n            // append this value to our result\n            result.append(value);\n\n            // find next occurrence after last end\n            pos = string0.indexOf(startStr, end+endStr.length());\n        }\n\n        // is there any string data we missed in the loop above?\n        if (end+endStr.length() < string0.length()) {\n            // append the remaining part of the string\n            result.append(string0.substring(end+endStr.length()));\n        }\n\n        return result.toString();\n    }", "signature": "String substituteWithProperties(String string0, String startStr, String endStr, Properties properties)", "full_signature": "public static String substituteWithProperties(String string0, String startStr, String endStr, Properties properties)", "class_method_signature": "StringUtil.substituteWithProperties(String string0, String startStr, String endStr, Properties properties)", "testcase": false, "constructor": false, "invocations": ["length", "indexOf", "append", "substring", "length", "indexOf", "length", "substring", "length", "equals", "getProperty", "append", "indexOf", "length", "length", "length", "append", "substring", "length", "toString"]}, "repository": {"repo_id": 14960307, "url": "https://github.com/twitter/cloudhopper-commons", "language": "Java", "is_fork": false, "fork_count": 40, "stargazer_count": 36, "size": 6452, "license": "licensed"}}