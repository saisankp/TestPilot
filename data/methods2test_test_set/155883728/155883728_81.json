{"test_class": {"identifier": "ChecklistExporterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "final File testBaseDir = new File(\"target/repos/ChecklistExporterTest\");", "modifier": "final", "type": "File", "declarator": "testBaseDir = new File(\"target/repos/ChecklistExporterTest\")", "var_name": "testBaseDir"}], "file": "webster/src/test/java/net/adamcin/oakpal/webster/ChecklistExporterTest.java"}, "test_case": {"identifier": "testUpdateChecklist", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testUpdateChecklist() throws Exception {\n        final String pathPrefix = \"/test\";\n        final File tempDir = new File(testBaseDir, \"testUpdateChecklist\");\n        final File pass1Dir = new File(tempDir, \"pass1/segmentstore\");\n        final File pass1Checklist = new File(tempDir, \"pass1.chk.json\");\n        final File fullRepoDir = new File(tempDir, \"fullRepo/segmentstore\");\n        final File diffRepoDir = new File(tempDir, \"diffRepo/segmentstore\");\n        final File fullPassChecklist = new File(tempDir, \"fullPass.chk.json\");\n        final File mergePassChecklist = new File(tempDir, \"mergePass.chk.json\");\n        final File replacePassChecklist = new File(tempDir, \"replacePass.chk.json\");\n        final File truncatePassChecklist = new File(tempDir, \"truncatePass.chk.json\");\n\n        final int sample = 5;\n        List<String> orderedPaths = IntStream.range(0, sample).mapToObj(val -> pathPrefix + \"/ordered\" + val).collect(Collectors.toList());\n        List<String> unorderedPaths = IntStream.range(0, sample).mapToObj(val -> pathPrefix + \"/unordered\" + val).collect(Collectors.toList());\n        assertEquals(\"should generate n paths: \", sample, orderedPaths.size());\n\n        final List<String> allPaths = new ArrayList<>(orderedPaths);\n        allPaths.addAll(unorderedPaths);\n        allPaths.add(pathPrefix);\n\n        TestUtil.prepareRepo(pass1Dir, session -> {\n            TestUtil.installCndFromURL(session, getClass().getResource(\"/sling_nodetypes.cnd\"));\n            orderedPaths.forEach(Fun.tryOrVoid1(path ->\n                    JcrUtils.getOrCreateByPath(path, \"nt:folder\",\n                            \"sling:OrderedFolder\", session, true)));\n            unorderedPaths.forEach(Fun.tryOrVoid1(path ->\n                    JcrUtils.getOrCreateByPath(path, \"nt:folder\",\n                            \"sling:Folder\", session, true)));\n        });\n\n        TestUtil.prepareRepo(fullRepoDir, session -> {\n            TestUtil.installCndFromURL(session, getClass().getResource(\"/sling_nodetypes.cnd\"));\n            allPaths.forEach(Fun.uncheckVoid1(path -> {\n                Node node = JcrUtils.getOrCreateByPath(path, \"sling:Folder\", session);\n                node.addMixin(\"mix:title\");\n                node.addMixin(\"sling:Resource\");\n            }));\n            session.save();\n        });\n\n        TestUtil.prepareRepo(diffRepoDir, session -> {\n            TestUtil.installCndFromURL(session, getClass().getResource(\"/sling_nodetypes.cnd\"));\n            allPaths.stream().filter(path -> path.matches(\".*[02468]$\"))\n                    .forEachOrdered(Fun.uncheckVoid1(path -> {\n                        Node node = JcrUtils.getOrCreateByPath(path, \"sling:Folder\", session);\n                        node.addMixin(\"mix:title\");\n                        node.addMixin(\"sling:Resource\");\n                    }));\n            session.save();\n        });\n\n        TestUtil.withReadOnlyFixture(pass1Dir, session -> {\n            ChecklistExporter pathExporter = new ChecklistExporter.Builder().byPath(allPaths.toArray(new String[0])).build();\n\n            pathExporter.updateChecklist(() -> new OutputStreamWriter(\n                            new FileOutputStream(pass1Checklist), StandardCharsets.UTF_8),\n                    session, Checklist.fromJson(\"\", null, obj()\n                            .key(Checklist.keys().jcrNamespaces(), Collections\n                                    .singletonList(JcrNs.create(\"sling\",\n                                            \"http://sling.apache.org/jcr/sling/1.0\")))\n                            .key(Checklist.keys().jcrPrivileges(), obj()\n                                    .key(\"sling:doesAll\", obj()\n                                            .key(\"contains\", arr(\"sling:doOne\", \"sling:doTwo\")))\n                                    .get())\n                            .get()), null);\n\n            try (JsonReader reader = Json.createReader(new FileInputStream(pass1Checklist))) {\n                JsonObject checklist = reader.readObject();\n                assertTrue(\"checklist object should contain the forcedRoots key\",\n                        checklist.containsKey(Checklist.keys().forcedRoots()));\n                assertTrue(\"checklist object should contain the privileges key\",\n                        checklist.containsKey(Checklist.keys().jcrPrivileges()));\n\n                JsonArray forcedRoots = checklist.getJsonArray(Checklist.keys().forcedRoots());\n                assertEquals(\"forcedRoots should be array with expected number of elements\", allPaths.size(),\n                        forcedRoots.size());\n\n                List<ForcedRoot> readRoots = JavaxJson.mapArrayOfObjects(forcedRoots, ForcedRoot::fromJson);\n                for (String path : unorderedPaths) {\n                    ForcedRoot root0 = readRoots.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                    assertNotNull(String.format(\"[pass1] root for path %s should not be null\", path), root0);\n                    assertEquals(String.format(\"[pass1] root primaryType for path %s should be sling:Folder\", path),\n                            \"sling:Folder\", root0.getPrimaryType());\n                }\n                for (String path : orderedPaths) {\n                    ForcedRoot root0 = readRoots.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                    assertNotNull(String.format(\"[pass1] root for path %s should not be null\", path), root0);\n                    assertEquals(String.format(\"[pass1] root primaryType for path %s should be sling:OrderedFolder\", path),\n                            \"sling:OrderedFolder\", root0.getPrimaryType());\n                }\n            }\n        });\n\n\n        TestUtil.withReadOnlyFixture(fullRepoDir, session -> {\n            ChecklistExporter pathExporter = new ChecklistExporter.Builder().byPath(allPaths.toArray(new String[0])).build();\n\n            try (JsonReader reader = Json.createReader(new FileInputStream(pass1Checklist))) {\n\n                pathExporter.updateChecklist(() -> new OutputStreamWriter(\n                                new FileOutputStream(fullPassChecklist), StandardCharsets.UTF_8),\n                        session, Checklist.fromJson(\"\", null, reader.readObject()), null);\n            }\n\n            try (JsonReader reader = Json.createReader(new FileInputStream(fullPassChecklist))) {\n                JsonObject checklist = reader.readObject();\n                assertTrue(\"checklist object should contain the forcedRoots key\",\n                        checklist.containsKey(Checklist.keys().forcedRoots()));\n                assertTrue(\"checklist object should contain the privileges key\",\n                        checklist.containsKey(Checklist.keys().jcrPrivileges()));\n\n                JsonArray forcedRoots = checklist.getJsonArray(Checklist.keys().forcedRoots());\n                assertEquals(\"forcedRoots should be array with expected number of elements\", allPaths.size(),\n                        forcedRoots.size());\n\n                List<ForcedRoot> readRoots = JavaxJson.mapArrayOfObjects(forcedRoots, ForcedRoot::fromJson);\n                for (String path : allPaths) {\n                    ForcedRoot root0 = readRoots.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                    assertNotNull(String.format(\"[pass2] root for path %s should not be null\", path), root0);\n                    assertEquals(String.format(\"[pass2] root primaryType for path %s should be sling:Folder\", path),\n                            \"sling:Folder\", root0.getPrimaryType());\n                    assertTrue(String.format(\"[pass2] root mixinTypes for path %s should contain mix:title\", path),\n                            root0.getMixinTypes().contains(\"mix:title\"));\n                }\n            }\n        });\n\n        TestUtil.withReadOnlyFixture(diffRepoDir, session -> {\n            ChecklistExporter diffExporter = new ChecklistExporter.Builder()\n                    .byNodeType(\"sling:Folder\")\n                    .withScopePaths(Rules.fromJsonArray(arr(key(\"type\", \"include\").key(\"pattern\", pathPrefix + \"/ordered.*\")).get()))\n                    .withNodeTypeFilters(Rules.fromJsonArray(arr(key(\"type\", \"exclude\").key(\"pattern\", \"sling:.*\")).get()))\n                    .build();\n\n            try (JsonReader reader = Json.createReader(new FileInputStream(fullPassChecklist))) {\n\n                diffExporter.updateChecklist(() -> new OutputStreamWriter(\n                                new FileOutputStream(mergePassChecklist), StandardCharsets.UTF_8),\n                        session, Checklist.fromJson(\"\", null, reader.readObject()),\n                        ChecklistExporter.ForcedRootUpdatePolicy.MERGE);\n            }\n\n            try (JsonReader reader = Json.createReader(new FileInputStream(fullPassChecklist))) {\n\n                diffExporter.updateChecklist(() -> new OutputStreamWriter(\n                                new FileOutputStream(replacePassChecklist), StandardCharsets.UTF_8),\n                        session, Checklist.fromJson(\"\", null, reader.readObject()),\n                        ChecklistExporter.ForcedRootUpdatePolicy.REPLACE);\n            }\n\n            try (JsonReader reader = Json.createReader(new FileInputStream(fullPassChecklist))) {\n\n                diffExporter.updateChecklist(() -> new OutputStreamWriter(\n                                new FileOutputStream(truncatePassChecklist), StandardCharsets.UTF_8),\n                        session, Checklist.fromJson(\"\", null, reader.readObject()),\n                        ChecklistExporter.ForcedRootUpdatePolicy.TRUNCATE);\n            }\n\n            try (JsonReader reader = Json.createReader(new FileInputStream(mergePassChecklist))) {\n                JsonObject checklist = reader.readObject();\n                assertTrue(\"checklist object should contain the forcedRoots key\",\n                        checklist.containsKey(Checklist.keys().forcedRoots()));\n\n                JsonArray forcedRoots = checklist.getJsonArray(Checklist.keys().forcedRoots());\n                assertEquals(\"[mergePass] forcedRoots should be array with expected number of elements\", allPaths.size(),\n                        forcedRoots.size());\n\n                List<ForcedRoot> readRoots = JavaxJson.mapArrayOfObjects(forcedRoots, ForcedRoot::fromJson);\n                for (String path : allPaths) {\n                    ForcedRoot root0 = readRoots.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                    if (path.matches(\".*/ordered[02468]$\")) {\n                        assertNotNull(String.format(\"[mergePass] root for path %s should not be null\", path), root0);\n                        assertNull(String.format(\"[mergePass] root primaryType for path %s should be sling:Folder\", path),\n                                root0.getPrimaryType());\n                        assertTrue(String.format(\"[mergePass] root mixinTypes for path %s should contain mix:title\", path),\n                                root0.getMixinTypes().contains(\"mix:title\"));\n                        assertFalse(String.format(\"[mergePass] root mixinTypes for path %s should NOT contain sling:Resource\", path),\n                                root0.getMixinTypes().contains(\"sling:Resource\"));\n                    } else {\n                        assertNotNull(String.format(\"[mergePass] root for path %s should not be null\", path), root0);\n                        assertEquals(String.format(\"[mergePass] root primaryType for path %s should be sling:Folder\", path),\n                                \"sling:Folder\", root0.getPrimaryType());\n                        assertTrue(String.format(\"[mergePass] root mixinTypes for path %s should contain mix:title\", path),\n                                root0.getMixinTypes().contains(\"mix:title\"));\n                        assertTrue(String.format(\"[mergePass] root mixinTypes for path %s should contain sling:Resource\", path),\n                                root0.getMixinTypes().contains(\"sling:Resource\"));\n                    }\n                }\n            }\n\n            try (JsonReader reader = Json.createReader(new FileInputStream(replacePassChecklist))) {\n                JsonObject checklist = reader.readObject();\n                assertTrue(\"checklist object should contain the forcedRoots key\",\n                        checklist.containsKey(Checklist.keys().forcedRoots()));\n\n                JsonArray forcedRoots = checklist.getJsonArray(Checklist.keys().forcedRoots());\n                assertEquals(\"[replacePass] forcedRoots should be array with expected number of elements\",\n                        1 + unorderedPaths.size() + orderedPaths.stream().filter(path -> path.matches(\".*[02468]$\")).count(),\n                        forcedRoots.size());\n\n                List<ForcedRoot> readRoots = JavaxJson.mapArrayOfObjects(forcedRoots, ForcedRoot::fromJson);\n                for (String path : allPaths) {\n                    ForcedRoot root0 = readRoots.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                    if (path.matches(\".*/ordered[02468]$\")) {\n                        assertNotNull(String.format(\"[replacePass] root for path %s should not be null\", path), root0);\n                        assertNull(String.format(\"[replacePass] root primaryType for path %s should be sling:Folder\", path),\n                                root0.getPrimaryType());\n                        assertTrue(String.format(\"[replacePass] root mixinTypes for path %s should contain mix:title\", path),\n                                root0.getMixinTypes().contains(\"mix:title\"));\n                        assertFalse(String.format(\"[replacePass] root mixinTypes for path %s should NOT contain sling:Resource\", path),\n                                root0.getMixinTypes().contains(\"sling:Resource\"));\n                    } else if (path.equals(pathPrefix) || path.matches(\".*/unordered.*\")) {\n                        assertNotNull(String.format(\"[replacePass] root for path %s should not be null\", path), root0);\n                        assertEquals(String.format(\"[replacePass] root primaryType for path %s should be sling:Folder\", path),\n                                \"sling:Folder\", root0.getPrimaryType());\n                        assertTrue(String.format(\"[replacePass] root mixinTypes for path %s should contain mix:title\", path),\n                                root0.getMixinTypes().contains(\"mix:title\"));\n                        assertTrue(String.format(\"[replacePass] root mixinTypes for path %s should contain sling:Resource\", path),\n                                root0.getMixinTypes().contains(\"sling:Resource\"));\n                    } else {\n                        assertNull(String.format(\"[replacePass] root for path %s should be null\", path), root0);\n                    }\n                }\n            }\n\n            try (JsonReader reader = Json.createReader(new FileInputStream(truncatePassChecklist))) {\n                JsonObject checklist = reader.readObject();\n                assertTrue(\"checklist object should contain the forcedRoots key\",\n                        checklist.containsKey(Checklist.keys().forcedRoots()));\n\n                JsonArray forcedRoots = checklist.getJsonArray(Checklist.keys().forcedRoots());\n                assertEquals(\"[truncatePass] forcedRoots should be array with expected number of elements\",\n                        orderedPaths.stream().filter(path -> path.matches(\".*[02468]$\")).count(), forcedRoots.size());\n\n                List<ForcedRoot> readRoots = JavaxJson.mapArrayOfObjects(forcedRoots, ForcedRoot::fromJson);\n                for (String path : allPaths) {\n                    ForcedRoot root0 = readRoots.stream().filter(root -> path.equals(root.getPath())).findFirst().orElse(null);\n                    if (path.matches(\".*/ordered[02468]$\")) {\n                        assertNotNull(String.format(\"[truncatePass] root for path %s should not be null\", path), root0);\n                        assertNull(String.format(\"[truncatePass] root primaryType for path %s should be sling:Folder\", path),\n                                root0.getPrimaryType());\n                        assertTrue(String.format(\"[truncatePass] root mixinTypes for path %s should contain mix:title\", path),\n                                root0.getMixinTypes().contains(\"mix:title\"));\n                        assertFalse(String.format(\"[truncatePass] root mixinTypes for path %s should NOT contain sling:Resource\", path),\n                                root0.getMixinTypes().contains(\"sling:Resource\"));\n                    } else {\n                        assertNull(String.format(\"[truncatePass] root for path %s should not be null\", path), root0);\n                    }\n                }\n            }\n        });\n    }", "signature": "void testUpdateChecklist()", "full_signature": "@Test public void testUpdateChecklist()", "class_method_signature": "ChecklistExporterTest.testUpdateChecklist()", "testcase": true, "constructor": false, "invocations": ["collect", "mapToObj", "range", "toList", "collect", "mapToObj", "range", "toList", "assertEquals", "size", "addAll", "add", "prepareRepo", "installCndFromURL", "getResource", "getClass", "forEach", "tryOrVoid1", "getOrCreateByPath", "forEach", "tryOrVoid1", "getOrCreateByPath", "prepareRepo", "installCndFromURL", "getResource", "getClass", "forEach", "uncheckVoid1", "getOrCreateByPath", "addMixin", "addMixin", "save", "prepareRepo", "installCndFromURL", "getResource", "getClass", "forEachOrdered", "filter", "stream", "matches", "uncheckVoid1", "getOrCreateByPath", "addMixin", "addMixin", "save", "withReadOnlyFixture", "build", "byPath", "toArray", "updateChecklist", "fromJson", "get", "key", "key", "obj", "jcrNamespaces", "keys", "singletonList", "create", "jcrPrivileges", "keys", "get", "key", "obj", "key", "obj", "arr", "createReader", "readObject", "assertTrue", "containsKey", "forcedRoots", "keys", "assertTrue", "containsKey", "jcrPrivileges", "keys", "getJsonArray", "forcedRoots", "keys", "assertEquals", "size", "size", "mapArrayOfObjects", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType", "withReadOnlyFixture", "build", "byPath", "toArray", "createReader", "updateChecklist", "fromJson", "readObject", "createReader", "readObject", "assertTrue", "containsKey", "forcedRoots", "keys", "assertTrue", "containsKey", "jcrPrivileges", "keys", "getJsonArray", "forcedRoots", "keys", "assertEquals", "size", "size", "mapArrayOfObjects", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType", "assertTrue", "format", "contains", "getMixinTypes", "withReadOnlyFixture", "build", "withNodeTypeFilters", "withScopePaths", "byNodeType", "fromJsonArray", "get", "arr", "key", "key", "fromJsonArray", "get", "arr", "key", "key", "createReader", "updateChecklist", "fromJson", "readObject", "createReader", "updateChecklist", "fromJson", "readObject", "createReader", "updateChecklist", "fromJson", "readObject", "createReader", "readObject", "assertTrue", "containsKey", "forcedRoots", "keys", "getJsonArray", "forcedRoots", "keys", "assertEquals", "size", "size", "mapArrayOfObjects", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "matches", "assertNotNull", "format", "assertNull", "format", "getPrimaryType", "assertTrue", "format", "contains", "getMixinTypes", "assertFalse", "format", "contains", "getMixinTypes", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType", "assertTrue", "format", "contains", "getMixinTypes", "assertTrue", "format", "contains", "getMixinTypes", "createReader", "readObject", "assertTrue", "containsKey", "forcedRoots", "keys", "getJsonArray", "forcedRoots", "keys", "assertEquals", "size", "count", "filter", "stream", "matches", "size", "mapArrayOfObjects", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "matches", "assertNotNull", "format", "assertNull", "format", "getPrimaryType", "assertTrue", "format", "contains", "getMixinTypes", "assertFalse", "format", "contains", "getMixinTypes", "equals", "matches", "assertNotNull", "format", "assertEquals", "format", "getPrimaryType", "assertTrue", "format", "contains", "getMixinTypes", "assertTrue", "format", "contains", "getMixinTypes", "assertNull", "format", "createReader", "readObject", "assertTrue", "containsKey", "forcedRoots", "keys", "getJsonArray", "forcedRoots", "keys", "assertEquals", "count", "filter", "stream", "matches", "size", "mapArrayOfObjects", "orElse", "findFirst", "filter", "stream", "equals", "getPath", "matches", "assertNotNull", "format", "assertNull", "format", "getPrimaryType", "assertTrue", "format", "contains", "getMixinTypes", "assertFalse", "format", "contains", "getMixinTypes", "assertNull", "format"]}, "focal_class": {"identifier": "ChecklistExporter", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ChecklistExporter.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ChecklistExporter.class)", "var_name": "LOGGER"}, {"original_string": "private final List<Op> operations;", "modifier": "private final", "type": "List<Op>", "declarator": "operations", "var_name": "operations"}, {"original_string": "private final List<String> exportTypeDefs;", "modifier": "private final", "type": "List<String>", "declarator": "exportTypeDefs", "var_name": "exportTypeDefs"}, {"original_string": "private final List<Rule> pathScopes;", "modifier": "private final", "type": "List<Rule>", "declarator": "pathScopes", "var_name": "pathScopes"}, {"original_string": "private final List<Rule> nodeTypeFilters;", "modifier": "private final", "type": "List<Rule>", "declarator": "nodeTypeFilters", "var_name": "nodeTypeFilters"}, {"original_string": "private final List<JcrNs> jcrNamespaces;", "modifier": "private final", "type": "List<JcrNs>", "declarator": "jcrNamespaces", "var_name": "jcrNamespaces"}, {"original_string": "public static final ForcedRootUpdatePolicy DEFAULT_UPDATE_POLICY = ForcedRootUpdatePolicy.REPLACE;", "modifier": "public static final", "type": "ForcedRootUpdatePolicy", "declarator": "DEFAULT_UPDATE_POLICY = ForcedRootUpdatePolicy.REPLACE", "var_name": "DEFAULT_UPDATE_POLICY"}, {"original_string": "public static final String COVARIANT_PREFIX = \"+\";", "modifier": "public static final", "type": "String", "declarator": "COVARIANT_PREFIX = \"+\"", "var_name": "COVARIANT_PREFIX"}, {"original_string": "static final Predicate<String> COVARIANT_FILTER = name -> name.startsWith(COVARIANT_PREFIX);", "modifier": "static final", "type": "Predicate<String>", "declarator": "COVARIANT_FILTER = name -> name.startsWith(COVARIANT_PREFIX)", "var_name": "COVARIANT_FILTER"}, {"original_string": "static final Function<String, String> COVARIANT_FORMAT = name -> name.substring(COVARIANT_PREFIX.length());", "modifier": "static final", "type": "Function<String, String>", "declarator": "COVARIANT_FORMAT = name -> name.substring(COVARIANT_PREFIX.length())", "var_name": "COVARIANT_FORMAT"}], "methods": [{"identifier": "ChecklistExporter", "parameters": "(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "modifiers": "private", "return": "", "signature": " ChecklistExporter(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "full_signature": "private  ChecklistExporter(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "class_method_signature": "ChecklistExporter.ChecklistExporter(final List<Op> operations,\n                              final List<String> exportTypeDefs,\n                              final List<Rule> pathScopes,\n                              final List<Rule> nodeTypeFilters,\n                              final List<JcrNs> jcrNamespaces)", "testcase": false, "constructor": true}, {"identifier": "ensureNamespaces", "parameters": "(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "modifiers": "static", "return": "void", "signature": "void ensureNamespaces(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "full_signature": "static void ensureNamespaces(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "class_method_signature": "ChecklistExporter.ensureNamespaces(final @NotNull Session session,\n                                 final @NotNull NamespaceMapping namespaces)", "testcase": false, "constructor": false}, {"identifier": "findJcrPrefixesInForcedRoot", "parameters": "(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "modifiers": "static", "return": "Set<String>", "signature": "Set<String> findJcrPrefixesInForcedRoot(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "full_signature": "static Set<String> findJcrPrefixesInForcedRoot(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "class_method_signature": "ChecklistExporter.findJcrPrefixesInForcedRoot(final @NotNull Set<String> acc, final @NotNull ForcedRoot forcedRoot)", "testcase": false, "constructor": false}, {"identifier": "findNodeTypesInForcedRoot", "parameters": "(final Set<String> acc, final ForcedRoot forcedRoot)", "modifiers": "static", "return": "Set<String>", "signature": "Set<String> findNodeTypesInForcedRoot(final Set<String> acc, final ForcedRoot forcedRoot)", "full_signature": "static Set<String> findNodeTypesInForcedRoot(final Set<String> acc, final ForcedRoot forcedRoot)", "class_method_signature": "ChecklistExporter.findNodeTypesInForcedRoot(final Set<String> acc, final ForcedRoot forcedRoot)", "testcase": false, "constructor": false}, {"identifier": "preferDifferent", "parameters": "(final @NotNull U value)", "modifiers": "static", "return": "BinaryOperator<U>", "signature": "BinaryOperator<U> preferDifferent(final @NotNull U value)", "full_signature": "static BinaryOperator<U> preferDifferent(final @NotNull U value)", "class_method_signature": "ChecklistExporter.preferDifferent(final @NotNull U value)", "testcase": false, "constructor": false}, {"identifier": "nsRemapName", "parameters": "(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "modifiers": "static", "return": "Function<String, String>", "signature": "Function<String, String> nsRemapName(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "full_signature": "static Function<String, String> nsRemapName(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "class_method_signature": "ChecklistExporter.nsRemapName(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "testcase": false, "constructor": false}, {"identifier": "nsRemapForcedRoot", "parameters": "(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "modifiers": "static", "return": "Function<ForcedRoot, ForcedRoot>", "signature": "Function<ForcedRoot, ForcedRoot> nsRemapForcedRoot(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "full_signature": "static Function<ForcedRoot, ForcedRoot> nsRemapForcedRoot(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "class_method_signature": "ChecklistExporter.nsRemapForcedRoot(final NamespaceMapping fromMapping, final NamespaceMapping toMapping)", "testcase": false, "constructor": false}, {"identifier": "getRetainFilter", "parameters": "(final ForcedRootUpdatePolicy updatePolicy)", "modifiers": "", "return": "Predicate<ForcedRoot>", "signature": "Predicate<ForcedRoot> getRetainFilter(final ForcedRootUpdatePolicy updatePolicy)", "full_signature": " Predicate<ForcedRoot> getRetainFilter(final ForcedRootUpdatePolicy updatePolicy)", "class_method_signature": "ChecklistExporter.getRetainFilter(final ForcedRootUpdatePolicy updatePolicy)", "testcase": false, "constructor": false}, {"identifier": "exportTypeDefSelector", "parameters": "()", "modifiers": "", "return": "BiPredicate<NamePathResolver, NodeType>", "signature": "BiPredicate<NamePathResolver, NodeType> exportTypeDefSelector()", "full_signature": " BiPredicate<NamePathResolver, NodeType> exportTypeDefSelector()", "class_method_signature": "ChecklistExporter.exportTypeDefSelector()", "testcase": false, "constructor": false}, {"identifier": "updateChecklist", "parameters": "(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "modifiers": "public", "return": "void", "signature": "void updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "full_signature": "public void updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "class_method_signature": "ChecklistExporter.updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "testcase": false, "constructor": false}, {"identifier": "addToLeft", "parameters": "()", "modifiers": "static", "return": "BinaryOperator<U>", "signature": "BinaryOperator<U> addToLeft()", "full_signature": "static BinaryOperator<U> addToLeft()", "class_method_signature": "ChecklistExporter.addToLeft()", "testcase": false, "constructor": false}, {"identifier": "findRoots", "parameters": "(final Session session)", "modifiers": "public", "return": "List<ForcedRoot>", "signature": "List<ForcedRoot> findRoots(final Session session)", "full_signature": "public List<ForcedRoot> findRoots(final Session session)", "class_method_signature": "ChecklistExporter.findRoots(final Session session)", "testcase": false, "constructor": false}, {"identifier": "ntStatement", "parameters": "(final Session session, final List<String> nodeTypeNames)", "modifiers": "", "return": "String", "signature": "String ntStatement(final Session session, final List<String> nodeTypeNames)", "full_signature": " String ntStatement(final Session session, final List<String> nodeTypeNames)", "class_method_signature": "ChecklistExporter.ntStatement(final Session session, final List<String> nodeTypeNames)", "testcase": false, "constructor": false}, {"identifier": "query", "parameters": "(final Session session, final String statement)", "modifiers": "", "return": "List<ForcedRoot>", "signature": "List<ForcedRoot> query(final Session session, final String statement)", "full_signature": " List<ForcedRoot> query(final Session session, final String statement)", "class_method_signature": "ChecklistExporter.query(final Session session, final String statement)", "testcase": false, "constructor": false}, {"identifier": "traverse", "parameters": "(final Session session, final List<String> paths)", "modifiers": "", "return": "List<ForcedRoot>", "signature": "List<ForcedRoot> traverse(final Session session, final List<String> paths)", "full_signature": " List<ForcedRoot> traverse(final Session session, final List<String> paths)", "class_method_signature": "ChecklistExporter.traverse(final Session session, final List<String> paths)", "testcase": false, "constructor": false}, {"identifier": "nodeToRoot", "parameters": "(final Node node, final NamespaceMapping mapping)", "modifiers": "", "return": "Optional<ForcedRoot>", "signature": "Optional<ForcedRoot> nodeToRoot(final Node node, final NamespaceMapping mapping)", "full_signature": " Optional<ForcedRoot> nodeToRoot(final Node node, final NamespaceMapping mapping)", "class_method_signature": "ChecklistExporter.nodeToRoot(final Node node, final NamespaceMapping mapping)", "testcase": false, "constructor": false}], "file": "webster/src/main/java/net/adamcin/oakpal/webster/ChecklistExporter.java"}, "focal_method": {"identifier": "updateChecklist", "parameters": "(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "modifiers": "public", "return": "void", "body": "public void updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)\n            throws IOException, RepositoryException {\n\n        final List<JcrNs> chkNs = new ArrayList<>();\n        // first attempt to remap JCR namespaces in the session, if necessary.\n        if (checklist != null && checklist.getJcrNamespaces() != null) {\n            chkNs.addAll(checklist.getJcrNamespaces());\n        }\n\n        final NamespaceMapping origMapping = JsonCnd.toNamespaceMapping(chkNs);\n        final NamespaceMapping remapping = JsonCnd.toNamespaceMapping(jcrNamespaces);\n\n        ensureNamespaces(session, origMapping);\n        ensureNamespaces(session, remapping);\n\n        // try to find the roots. If any error occurs there, we want to fail fast before committing to other\n        // potentially expensive, destructive, or error-prone logic.\n        final List<ForcedRoot> newRoots = findRoots(session);\n\n        // construct a stream filter for retaining existing forced roots\n        Predicate<ForcedRoot> retainFilter = getRetainFilter(updatePolicy);\n\n        final JsonObjectBuilder builder = Json.createObjectBuilder();\n        final Map<String, ForcedRoot> existing = new LinkedHashMap<>();\n        final List<PrivilegeDefinition> privileges = new ArrayList<>();\n\n        // remap the names of existing jcr definitions to match the new jcr namespaces\n        if (checklist != null) {\n            checklist.toJson().forEach(builder::add);\n\n            privileges.addAll(checklist.getJcrPrivileges());\n\n            checklist.getForcedRoots().stream()\n                    .map(nsRemapForcedRoot(origMapping, remapping))\n                    .filter(retainFilter)\n                    .forEachOrdered(root -> existing.put(root.getPath(), root));\n        }\n\n        //final Set<String> finalPrefixes = new HashSet<>();\n        final NamespaceMappingRequest.Builder request = new NamespaceMappingRequest.Builder();\n        if (!privileges.isEmpty()) {\n            builder.add(Checklist.keys().jcrPrivileges(), JsonCnd.privilegesToJson(privileges, origMapping));\n            privileges.stream().flatMap(JsonCnd::namedBy).forEach(request::withQName);\n        }\n\n        newRoots.forEach(root -> existing.put(root.getPath(), root));\n\n        final List<ForcedRoot> forcedRoots = new ArrayList<>(existing.values());\n        Collections.sort(forcedRoots);\n\n        final JsonArray forcedRootsJson = forcedRoots.stream()\n                .map(ForcedRoot::toJson)\n                .collect(JsonCollectors.toJsonArray());\n\n        builder.add(Checklist.keys().forcedRoots(), forcedRootsJson);\n\n        // begin nodetype handling\n\n        final NamePathResolver resolver = new DefaultNamePathResolver(session);\n        final Set<Name> builtinNodetypes = CndExporter.BUILTIN_NODETYPES.stream()\n                .map(uncheck1(resolver::getQName))\n                .filter(Objects::nonNull)\n                .collect(Collectors.toSet());\n\n        final List<Name> foundNodeTypes = forcedRoots.stream()\n                .reduce(new HashSet<>(),\n                        ChecklistExporter::findNodeTypesInForcedRoot,\n                        addToLeft()).stream()\n                .map(uncheck1(resolver::getQName))\n                .collect(Collectors.toList());\n\n        final Map<Name, NodeTypeDefinition> exportedNodeTypes =\n                CndExporter.retrieveNodeTypes(session, foundNodeTypes, exportTypeDefSelector());\n        final List<QNodeTypeDefinition> qNodeTypes = exportedNodeTypes.entrySet().stream()\n                .map(mapValue(JsonCnd.adaptToQ(session)))\n                .filter(testKey(((Predicate<Name>) builtinNodetypes::contains).negate()))\n                .map(Map.Entry::getValue)\n                .collect(Collectors.toList());\n\n        final NamespaceMapping spm = new NamespaceMapping(new SessionNamespaceResolver(session));\n\n        if (!qNodeTypes.isEmpty()) {\n            final Set<String> nsUris = qNodeTypes.stream()\n                    .flatMap(JsonCnd::namedBy)\n                    .map(Name::getNamespaceURI)\n                    .collect(Collectors.toSet());\n\n            final Map<String, String> uriMapping = remapping.getURIToPrefixMapping();\n            nsUris.forEach(Fun.uncheckVoid1(uri -> {\n                final String prefix = uriMapping.containsKey(uri) ? uriMapping.get(uri) : spm.getPrefix(uri);\n                request.withRetainPrefix(prefix);\n                spm.setMapping(prefix, uri);\n            }));\n\n            final JsonObject jcrNodetypes =\n                    JsonCnd.toJson(qNodeTypes, new NamespaceMapping(new SessionNamespaceResolver(session)));\n            builder.add(Checklist.keys().jcrNodetypes(), jcrNodetypes);\n        }\n\n        // begin namespace handling\n        final Set<String> forcedRootPrefixes = forcedRoots.stream()\n                .reduce(new HashSet<>(),\n                        ChecklistExporter::findJcrPrefixesInForcedRoot,\n                        addToLeft());\n        forcedRootPrefixes.forEach(request::withRetainPrefix);\n\n        final List<JcrNs> exportNamespaces = request.build()\n                .resolveToJcrNs(spm).stream()\n                .flatMap(Result::stream)\n                .collect(Collectors.toList());\n        if (!exportNamespaces.isEmpty()) {\n            builder.add(Checklist.keys().jcrNamespaces(), JavaxJson.wrap(exportNamespaces));\n        }\n\n        final JsonObject sorted = builder.build().entrySet().stream()\n                .sorted(Checklist.comparingJsonKeys(Map.Entry::getKey))\n                .collect(JsonCollectors.toJsonObject());\n\n        try (Writer writer = writerOpener.open();\n             JsonWriter jsonWriter = Json\n                     .createWriterFactory(Collections.singletonMap(JsonGenerator.PRETTY_PRINTING, true))\n                     .createWriter(writer)) {\n            jsonWriter.writeObject(sorted);\n        }\n    }", "signature": "void updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "full_signature": "public void updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "class_method_signature": "ChecklistExporter.updateChecklist(final WriterOpener writerOpener,\n                                final Session session,\n                                final Checklist checklist,\n                                final ForcedRootUpdatePolicy updatePolicy)", "testcase": false, "constructor": false, "invocations": ["getJcrNamespaces", "addAll", "getJcrNamespaces", "toNamespaceMapping", "toNamespaceMapping", "ensureNamespaces", "ensureNamespaces", "findRoots", "getRetainFilter", "createObjectBuilder", "forEach", "toJson", "addAll", "getJcrPrivileges", "forEachOrdered", "filter", "map", "stream", "getForcedRoots", "nsRemapForcedRoot", "put", "getPath", "isEmpty", "add", "jcrPrivileges", "keys", "privilegesToJson", "forEach", "flatMap", "stream", "forEach", "put", "getPath", "values", "sort", "collect", "map", "stream", "toJsonArray", "add", "forcedRoots", "keys", "collect", "filter", "map", "stream", "uncheck1", "toSet", "collect", "map", "stream", "reduce", "stream", "addToLeft", "uncheck1", "toList", "retrieveNodeTypes", "exportTypeDefSelector", "collect", "map", "filter", "map", "stream", "entrySet", "mapValue", "adaptToQ", "testKey", "negate", "toList", "isEmpty", "collect", "map", "flatMap", "stream", "toSet", "getURIToPrefixMapping", "forEach", "uncheckVoid1", "containsKey", "get", "getPrefix", "withRetainPrefix", "setMapping", "toJson", "add", "jcrNodetypes", "keys", "reduce", "stream", "addToLeft", "forEach", "collect", "flatMap", "stream", "resolveToJcrNs", "build", "toList", "isEmpty", "add", "jcrNamespaces", "keys", "wrap", "collect", "sorted", "stream", "entrySet", "build", "comparingJsonKeys", "toJsonObject", "open", "createWriter", "createWriterFactory", "singletonMap", "writeObject"]}, "repository": {"repo_id": 155883728, "url": "https://github.com/adamcin/oakpal", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 6, "size": 13349, "license": "licensed"}}