{"test_class": {"identifier": "AkIntervalTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Set<AkIntervalSecondsFormat> secondsFormatsTested\n            = EnumSet.noneOf(AkIntervalSecondsFormat.class);", "modifier": "private static final", "type": "Set<AkIntervalSecondsFormat>", "declarator": "secondsFormatsTested\n            = EnumSet.noneOf(AkIntervalSecondsFormat.class)", "var_name": "secondsFormatsTested"}, {"original_string": "private static final Set<AkIntervalMonthsFormat> monthsFormatsTested\n            = EnumSet.noneOf(AkIntervalMonthsFormat.class);", "modifier": "private static final", "type": "Set<AkIntervalMonthsFormat>", "declarator": "monthsFormatsTested\n            = EnumSet.noneOf(AkIntervalMonthsFormat.class)", "var_name": "monthsFormatsTested"}], "file": "fdb-sql-layer-core/src/test/java/com/foundationdb/server/types/aksql/aktypes/AkIntervalTest.java"}, "test_case": {"identifier": "conversionsForLong", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void conversionsForLong() {\n        long nanos = new TimeBuilder()\n                .add(3, TimeUnit.DAYS)\n                .add(5, TimeUnit.HOURS)\n                .add(13, TimeUnit.MINUTES)\n                .add(17, TimeUnit.SECONDS)\n                .add(43, TimeUnit.MICROSECONDS)\n                .add(666, TimeUnit.NANOSECONDS) // will be truncated, since we're working with micros\n                .getNanos();\n        long raw = AkInterval.secondsRawFrom(nanos, TimeUnit.NANOSECONDS);\n\n        long amount; // will go from days, to hours, etc to nanos\n        amount = checkAndGet(raw, TimeUnit.DAYS, 3);\n        amount = checkAndGet(raw, TimeUnit.HOURS, (amount*24) + 5);\n        amount = checkAndGet(raw, TimeUnit.MINUTES, (amount*60) + 13);\n        amount = checkAndGet(raw, TimeUnit.SECONDS, (amount*60) + 17);\n        amount = checkAndGet(raw, TimeUnit.MICROSECONDS, (amount*1000000) + 43);\n        checkAndGet(raw, TimeUnit.NANOSECONDS, amount*1000); // the 666 extra were truncated\n    }", "signature": "void conversionsForLong()", "full_signature": "@Test public void conversionsForLong()", "class_method_signature": "AkIntervalTest.conversionsForLong()", "testcase": true, "constructor": false, "invocations": ["getNanos", "add", "add", "add", "add", "add", "add", "secondsRawFrom", "checkAndGet", "checkAndGet", "checkAndGet", "checkAndGet", "checkAndGet", "checkAndGet"]}, "focal_class": {"identifier": "AkInterval", "superclass": "extends TClassBase", "interfaces": "", "fields": [{"original_string": "private static TClassFormatter monthsFormatter = new TClassFormatter() {\n        @Override\n        public void format(TInstance type, ValueSource source, AkibanAppender out) {\n            long months = source.getInt64();\n            boolean negative = false;\n            if(months < 0) {\n                negative = true;\n                months = -months;\n            }\n            long years = months / 12;\n            months -= (years * 12);\n            Formatter formatter = new Formatter(out.getAppendable());\n            if(negative)\n                formatter.format(\"INTERVAL '-%d-%d'\", years, months);\n            else\n                formatter.format(\"INTERVAL '%d-%d'\", years, months);\n\n        }\n\n        @Override\n        public void formatAsLiteral(TInstance type, ValueSource source, AkibanAppender out) {\n            long value = source.getInt64();\n            Formatter formatter = new Formatter(out.getAppendable());\n            out.append(\"INTERVAL '\");\n            long years, months;\n            if (value < 0) {\n                out.append('-');\n                months = -value;\n            }\n            else {\n                months = value;\n            }\n            years = months / 12;\n            months -= years * 12;\n            String hi = null, lo = null;\n            if (years > 0) {\n                formatter.format(\"%d\", years);\n                hi = lo = \"YEAR\";\n            }\n            if ((months > 0) || (hi == null)) {\n                if (hi != null) {\n                    formatter.format(\"-%02d\", months);\n                }\n                else {\n                    formatter.format(\"%d\", months);\n                }\n                lo = \"MONTH\";\n                if (hi == null) hi = lo;\n            }\n            out.append(\"' \");\n            out.append(hi);\n            if (hi != lo) {\n                out.append(\" TO \");\n                out.append(lo);\n            }\n        }\n\n        @Override\n        public void formatAsJson(TInstance type, ValueSource source, AkibanAppender out, FormatOptions options) {\n            long months = source.getInt64();\n            out.append(Long.toString(months));\n        }\n    };", "modifier": "private static", "type": "TClassFormatter", "declarator": "monthsFormatter = new TClassFormatter() {\n        @Override\n        public void format(TInstance type, ValueSource source, AkibanAppender out) {\n            long months = source.getInt64();\n            boolean negative = false;\n            if(months < 0) {\n                negative = true;\n                months = -months;\n            }\n            long years = months / 12;\n            months -= (years * 12);\n            Formatter formatter = new Formatter(out.getAppendable());\n            if(negative)\n                formatter.format(\"INTERVAL '-%d-%d'\", years, months);\n            else\n                formatter.format(\"INTERVAL '%d-%d'\", years, months);\n\n        }\n\n        @Override\n        public void formatAsLiteral(TInstance type, ValueSource source, AkibanAppender out) {\n            long value = source.getInt64();\n            Formatter formatter = new Formatter(out.getAppendable());\n            out.append(\"INTERVAL '\");\n            long years, months;\n            if (value < 0) {\n                out.append('-');\n                months = -value;\n            }\n            else {\n                months = value;\n            }\n            years = months / 12;\n            months -= years * 12;\n            String hi = null, lo = null;\n            if (years > 0) {\n                formatter.format(\"%d\", years);\n                hi = lo = \"YEAR\";\n            }\n            if ((months > 0) || (hi == null)) {\n                if (hi != null) {\n                    formatter.format(\"-%02d\", months);\n                }\n                else {\n                    formatter.format(\"%d\", months);\n                }\n                lo = \"MONTH\";\n                if (hi == null) hi = lo;\n            }\n            out.append(\"' \");\n            out.append(hi);\n            if (hi != lo) {\n                out.append(\" TO \");\n                out.append(lo);\n            }\n        }\n\n        @Override\n        public void formatAsJson(TInstance type, ValueSource source, AkibanAppender out, FormatOptions options) {\n            long months = source.getInt64();\n            out.append(Long.toString(months));\n        }\n    }", "var_name": "monthsFormatter"}, {"original_string": "private static TClassFormatter secondsFormatter = new TClassFormatter() {\n        @Override\n        public void format(TInstance type, ValueSource source, AkibanAppender out) {\n\n            boolean negative = false;\n            long micros = secondsIntervalAs(source, TimeUnit.MICROSECONDS);\n            if(micros < 0) {\n                negative = true;\n                micros = -micros;\n            }\n            long days = secondsIntervalAs(micros, TimeUnit.DAYS);\n            micros -= TimeUnit.DAYS.toMicros(days);\n            long hours = secondsIntervalAs(micros, TimeUnit.HOURS);\n            micros -= TimeUnit.HOURS.toMicros(hours);\n            long minutes = secondsIntervalAs(micros, TimeUnit.MINUTES);\n            micros -= TimeUnit.MINUTES.toMicros(minutes);\n            long seconds = secondsIntervalAs(micros, TimeUnit.SECONDS);\n            micros -= TimeUnit.SECONDS.toMicros(seconds);\n\n            Formatter formatter = new Formatter(out.getAppendable());\n            if(negative)\n                formatter.format(\"INTERVAL '-%d %d:%d:%d.%05d'\", days, hours, minutes, seconds, micros);\n            else\n                formatter.format(\"INTERVAL '%d %d:%d:%d.%05d'\", days, hours, minutes, seconds, micros);\n\n        }\n\n        @Override\n        public void formatAsLiteral(TInstance type, ValueSource source, AkibanAppender out) {\n            long value = secondsIntervalAs(source, TimeUnit.MICROSECONDS);\n            Formatter formatter = new Formatter(out.getAppendable());\n            out.append(\"INTERVAL '\");\n            long days, hours, mins, secs, micros;\n            if (value < 0) {\n                out.append('-');\n                micros = -value;\n            }\n            else {\n                micros = value;\n            }\n            // Could be data-driven, but just enough special cases that\n            // that would be pretty complicated.\n            secs = micros / 1000000;\n            micros -= secs * 1000000;\n            mins = secs / 60;\n            secs -= mins * 60;\n            hours = mins / 60;\n            mins -= hours * 60;\n            days = hours / 24;\n            hours -= days * 24;\n            String hi = null, lo = null;\n            if (days > 0) {\n                formatter.format(\"%d\", days);\n                hi = lo = \"DAY\";\n            }\n            if ((hours > 0) ||\n                ((hi != null) && ((mins > 0) || (secs > 0) || (micros > 0)))) {\n                if (hi != null) {\n                    formatter.format(\":%02d\", hours);\n                }\n                else {\n                    formatter.format(\"%d\", hours);\n                }\n                lo = \"HOUR\";\n                if (hi == null) hi = lo;\n            }\n            if ((mins > 0) ||\n                ((hi != null) && ((secs > 0) || (micros > 0)))) {\n                if (hi != null) {\n                    formatter.format(\":%02d\", mins);\n                }\n                else {\n                    formatter.format(\"%d\", mins);\n                }\n                lo = \"MINUTE\";\n                if (hi == null) hi = lo;\n            }\n            if ((secs > 0) || (hi == null) || (micros > 0)) {\n                if (hi != null) {\n                    formatter.format(\":%02d\", secs);\n                }\n                else {\n                    formatter.format(\"%d\", secs);\n                }\n                lo = \"SECOND\";\n                if (hi == null) hi = lo;\n            }\n            if (micros > 0) {\n                if ((micros % 1000) == 0)\n                    formatter.format(\".%03d\", micros / 1000);\n                else\n                    formatter.format(\".%06d\", micros);\n            }\n            out.append(\"' \");\n            out.append(hi);\n            if (hi != lo) {\n                out.append(\" TO \");\n                out.append(lo);\n            }\n        }\n\n        @Override\n        public void formatAsJson(TInstance type, ValueSource source, AkibanAppender out, FormatOptions options) {\n            long value = secondsIntervalAs(source, TimeUnit.MICROSECONDS);\n            long secs = value / 1000000;\n            long micros = value % 1000000;\n            Formatter formatter = new Formatter(out.getAppendable());\n            formatter.format(\"%d.%06d\", secs, micros);\n        }\n    };", "modifier": "private static", "type": "TClassFormatter", "declarator": "secondsFormatter = new TClassFormatter() {\n        @Override\n        public void format(TInstance type, ValueSource source, AkibanAppender out) {\n\n            boolean negative = false;\n            long micros = secondsIntervalAs(source, TimeUnit.MICROSECONDS);\n            if(micros < 0) {\n                negative = true;\n                micros = -micros;\n            }\n            long days = secondsIntervalAs(micros, TimeUnit.DAYS);\n            micros -= TimeUnit.DAYS.toMicros(days);\n            long hours = secondsIntervalAs(micros, TimeUnit.HOURS);\n            micros -= TimeUnit.HOURS.toMicros(hours);\n            long minutes = secondsIntervalAs(micros, TimeUnit.MINUTES);\n            micros -= TimeUnit.MINUTES.toMicros(minutes);\n            long seconds = secondsIntervalAs(micros, TimeUnit.SECONDS);\n            micros -= TimeUnit.SECONDS.toMicros(seconds);\n\n            Formatter formatter = new Formatter(out.getAppendable());\n            if(negative)\n                formatter.format(\"INTERVAL '-%d %d:%d:%d.%05d'\", days, hours, minutes, seconds, micros);\n            else\n                formatter.format(\"INTERVAL '%d %d:%d:%d.%05d'\", days, hours, minutes, seconds, micros);\n\n        }\n\n        @Override\n        public void formatAsLiteral(TInstance type, ValueSource source, AkibanAppender out) {\n            long value = secondsIntervalAs(source, TimeUnit.MICROSECONDS);\n            Formatter formatter = new Formatter(out.getAppendable());\n            out.append(\"INTERVAL '\");\n            long days, hours, mins, secs, micros;\n            if (value < 0) {\n                out.append('-');\n                micros = -value;\n            }\n            else {\n                micros = value;\n            }\n            // Could be data-driven, but just enough special cases that\n            // that would be pretty complicated.\n            secs = micros / 1000000;\n            micros -= secs * 1000000;\n            mins = secs / 60;\n            secs -= mins * 60;\n            hours = mins / 60;\n            mins -= hours * 60;\n            days = hours / 24;\n            hours -= days * 24;\n            String hi = null, lo = null;\n            if (days > 0) {\n                formatter.format(\"%d\", days);\n                hi = lo = \"DAY\";\n            }\n            if ((hours > 0) ||\n                ((hi != null) && ((mins > 0) || (secs > 0) || (micros > 0)))) {\n                if (hi != null) {\n                    formatter.format(\":%02d\", hours);\n                }\n                else {\n                    formatter.format(\"%d\", hours);\n                }\n                lo = \"HOUR\";\n                if (hi == null) hi = lo;\n            }\n            if ((mins > 0) ||\n                ((hi != null) && ((secs > 0) || (micros > 0)))) {\n                if (hi != null) {\n                    formatter.format(\":%02d\", mins);\n                }\n                else {\n                    formatter.format(\"%d\", mins);\n                }\n                lo = \"MINUTE\";\n                if (hi == null) hi = lo;\n            }\n            if ((secs > 0) || (hi == null) || (micros > 0)) {\n                if (hi != null) {\n                    formatter.format(\":%02d\", secs);\n                }\n                else {\n                    formatter.format(\"%d\", secs);\n                }\n                lo = \"SECOND\";\n                if (hi == null) hi = lo;\n            }\n            if (micros > 0) {\n                if ((micros % 1000) == 0)\n                    formatter.format(\".%03d\", micros / 1000);\n                else\n                    formatter.format(\".%06d\", micros);\n            }\n            out.append(\"' \");\n            out.append(hi);\n            if (hi != lo) {\n                out.append(\" TO \");\n                out.append(lo);\n            }\n        }\n\n        @Override\n        public void formatAsJson(TInstance type, ValueSource source, AkibanAppender out, FormatOptions options) {\n            long value = secondsIntervalAs(source, TimeUnit.MICROSECONDS);\n            long secs = value / 1000000;\n            long micros = value % 1000000;\n            Formatter formatter = new Formatter(out.getAppendable());\n            formatter.format(\"%d.%06d\", secs, micros);\n        }\n    }", "var_name": "secondsFormatter"}, {"original_string": "public static final AkInterval MONTHS = new AkInterval(\n            AkBundle.INSTANCE.id(),\n            \"interval months\",\n            AkCategory.DATE_TIME,\n            MonthsAttrs.class,\n            monthsFormatter,\n            1,\n            1,\n            8,\n            UnderlyingType.INT_64,\n            MonthsAttrs.FORMAT,\n            AkIntervalMonthsFormat.values());", "modifier": "public static final", "type": "AkInterval", "declarator": "MONTHS = new AkInterval(\n            AkBundle.INSTANCE.id(),\n            \"interval months\",\n            AkCategory.DATE_TIME,\n            MonthsAttrs.class,\n            monthsFormatter,\n            1,\n            1,\n            8,\n            UnderlyingType.INT_64,\n            MonthsAttrs.FORMAT,\n            AkIntervalMonthsFormat.values())", "var_name": "MONTHS"}, {"original_string": "public static final AkInterval SECONDS = new AkInterval(\n            AkBundle.INSTANCE.id(),\n            \"interval seconds\",\n            AkCategory.DATE_TIME,\n            SecondsAttrs.class,\n            secondsFormatter,\n            1,\n            1,\n            8,\n            UnderlyingType.INT_64,\n            SecondsAttrs.FORMAT,\n            AkIntervalSecondsFormat.values()\n    );", "modifier": "public static final", "type": "AkInterval", "declarator": "SECONDS = new AkInterval(\n            AkBundle.INSTANCE.id(),\n            \"interval seconds\",\n            AkCategory.DATE_TIME,\n            SecondsAttrs.class,\n            secondsFormatter,\n            1,\n            1,\n            8,\n            UnderlyingType.INT_64,\n            SecondsAttrs.FORMAT,\n            AkIntervalSecondsFormat.values()\n    )", "var_name": "SECONDS"}, {"original_string": "private final IntervalFormat[] formatters;", "modifier": "private final", "type": "IntervalFormat[]", "declarator": "formatters", "var_name": "formatters"}, {"original_string": "private final Attribute formatAttribute;", "modifier": "private final", "type": "Attribute", "declarator": "formatAttribute", "var_name": "formatAttribute"}, {"original_string": "private final Map<TypeId,IntervalFormat> typeIdToFormat;", "modifier": "private final", "type": "Map<TypeId,IntervalFormat>", "declarator": "typeIdToFormat", "var_name": "typeIdToFormat"}], "methods": [{"identifier": "widestComparable", "parameters": "()", "modifiers": "public", "return": "TClass", "signature": "TClass widestComparable()", "full_signature": "public TClass widestComparable()", "class_method_signature": "AkInterval.widestComparable()", "testcase": false, "constructor": false}, {"identifier": "secondsIntervalAs", "parameters": "(ValueSource source, TimeUnit as)", "modifiers": "public static", "return": "long", "signature": "long secondsIntervalAs(ValueSource source, TimeUnit as)", "full_signature": "public static long secondsIntervalAs(ValueSource source, TimeUnit as)", "class_method_signature": "AkInterval.secondsIntervalAs(ValueSource source, TimeUnit as)", "testcase": false, "constructor": false}, {"identifier": "secondsIntervalAs", "parameters": "(long secondsIntervalRaw, TimeUnit as)", "modifiers": "public static", "return": "long", "signature": "long secondsIntervalAs(long secondsIntervalRaw, TimeUnit as)", "full_signature": "public static long secondsIntervalAs(long secondsIntervalRaw, TimeUnit as)", "class_method_signature": "AkInterval.secondsIntervalAs(long secondsIntervalRaw, TimeUnit as)", "testcase": false, "constructor": false}, {"identifier": "secondsRawFrom", "parameters": "(long source, TimeUnit sourceUnit)", "modifiers": "public static", "return": "long", "signature": "long secondsRawFrom(long source, TimeUnit sourceUnit)", "full_signature": "public static long secondsRawFrom(long source, TimeUnit sourceUnit)", "class_method_signature": "AkInterval.secondsRawFrom(long source, TimeUnit sourceUnit)", "testcase": false, "constructor": false}, {"identifier": "secondsRawFromFractionalSeconds", "parameters": "(long source)", "modifiers": "public static", "return": "long", "signature": "long secondsRawFromFractionalSeconds(long source)", "full_signature": "public static long secondsRawFromFractionalSeconds(long source)", "class_method_signature": "AkInterval.secondsRawFromFractionalSeconds(long source)", "testcase": false, "constructor": false}, {"identifier": "attributeIsPhysical", "parameters": "(int attributeIndex)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean attributeIsPhysical(int attributeIndex)", "full_signature": "@Override public boolean attributeIsPhysical(int attributeIndex)", "class_method_signature": "AkInterval.attributeIsPhysical(int attributeIndex)", "testcase": false, "constructor": false}, {"identifier": "attributeAlwaysDisplayed", "parameters": "(int attributeIndex)", "modifiers": "@Override protected", "return": "boolean", "signature": "boolean attributeAlwaysDisplayed(int attributeIndex)", "full_signature": "@Override protected boolean attributeAlwaysDisplayed(int attributeIndex)", "class_method_signature": "AkInterval.attributeAlwaysDisplayed(int attributeIndex)", "testcase": false, "constructor": false}, {"identifier": "attributeToString", "parameters": "(int attributeIndex, long value, StringBuilder output)", "modifiers": "@Override public", "return": "void", "signature": "void attributeToString(int attributeIndex, long value, StringBuilder output)", "full_signature": "@Override public void attributeToString(int attributeIndex, long value, StringBuilder output)", "class_method_signature": "AkInterval.attributeToString(int attributeIndex, long value, StringBuilder output)", "testcase": false, "constructor": false}, {"identifier": "doPickInstance", "parameters": "(TInstance left, TInstance right, boolean suggestedNullability)", "modifiers": "@Override protected", "return": "TInstance", "signature": "TInstance doPickInstance(TInstance left, TInstance right, boolean suggestedNullability)", "full_signature": "@Override protected TInstance doPickInstance(TInstance left, TInstance right, boolean suggestedNullability)", "class_method_signature": "AkInterval.doPickInstance(TInstance left, TInstance right, boolean suggestedNullability)", "testcase": false, "constructor": false}, {"identifier": "instance", "parameters": "(boolean nullable)", "modifiers": "@Override public", "return": "TInstance", "signature": "TInstance instance(boolean nullable)", "full_signature": "@Override public TInstance instance(boolean nullable)", "class_method_signature": "AkInterval.instance(boolean nullable)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(TInstance type)", "modifiers": "@Override protected", "return": "void", "signature": "void validate(TInstance type)", "full_signature": "@Override protected void validate(TInstance type)", "class_method_signature": "AkInterval.validate(TInstance type)", "testcase": false, "constructor": false}, {"identifier": "jdbcType", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int jdbcType()", "full_signature": "@Override public int jdbcType()", "class_method_signature": "AkInterval.jdbcType()", "testcase": false, "constructor": false}, {"identifier": "dataTypeDescriptor", "parameters": "(TInstance type)", "modifiers": "@Override protected", "return": "DataTypeDescriptor", "signature": "DataTypeDescriptor dataTypeDescriptor(TInstance type)", "full_signature": "@Override protected DataTypeDescriptor dataTypeDescriptor(TInstance type)", "class_method_signature": "AkInterval.dataTypeDescriptor(TInstance type)", "testcase": false, "constructor": false}, {"identifier": "typeFrom", "parameters": "(DataTypeDescriptor type)", "modifiers": "public", "return": "TInstance", "signature": "TInstance typeFrom(DataTypeDescriptor type)", "full_signature": "public TInstance typeFrom(DataTypeDescriptor type)", "class_method_signature": "AkInterval.typeFrom(DataTypeDescriptor type)", "testcase": false, "constructor": false}, {"identifier": "AkInterval", "parameters": "(TBundleID bundle, String name,\n                                               Enum<?> category, Class<A> enumClass,\n                                               TClassFormatter formatter,\n                                               int internalRepVersion, int sVersion, int sSize,\n                                               UnderlyingType underlyingType,\n                                               A formatAttribute,\n                                               IntervalFormat[] formatters)", "modifiers": "private", "return": "<A extends Enum<A> & Attribute>", "signature": "<A extends Enum<A> & Attribute> AkInterval(TBundleID bundle, String name,\n                                               Enum<?> category, Class<A> enumClass,\n                                               TClassFormatter formatter,\n                                               int internalRepVersion, int sVersion, int sSize,\n                                               UnderlyingType underlyingType,\n                                               A formatAttribute,\n                                               IntervalFormat[] formatters)", "full_signature": "private <A extends Enum<A> & Attribute> AkInterval(TBundleID bundle, String name,\n                                               Enum<?> category, Class<A> enumClass,\n                                               TClassFormatter formatter,\n                                               int internalRepVersion, int sVersion, int sSize,\n                                               UnderlyingType underlyingType,\n                                               A formatAttribute,\n                                               IntervalFormat[] formatters)", "class_method_signature": "AkInterval.AkInterval(TBundleID bundle, String name,\n                                               Enum<?> category, Class<A> enumClass,\n                                               TClassFormatter formatter,\n                                               int internalRepVersion, int sVersion, int sSize,\n                                               UnderlyingType underlyingType,\n                                               A formatAttribute,\n                                               IntervalFormat[] formatters)", "testcase": false, "constructor": true}, {"identifier": "isDate", "parameters": "(TInstance ins)", "modifiers": "public", "return": "boolean", "signature": "boolean isDate(TInstance ins)", "full_signature": "public boolean isDate(TInstance ins)", "class_method_signature": "AkInterval.isDate(TInstance ins)", "testcase": false, "constructor": false}, {"identifier": "isTime", "parameters": "(TInstance ins)", "modifiers": "public", "return": "boolean", "signature": "boolean isTime(TInstance ins)", "full_signature": "public boolean isTime(TInstance ins)", "class_method_signature": "AkInterval.isTime(TInstance ins)", "testcase": false, "constructor": false}, {"identifier": "attributeToString", "parameters": "(IntervalFormat[] formatters, long arrayIndex, StringBuilder output)", "modifiers": "private static", "return": "void", "signature": "void attributeToString(IntervalFormat[] formatters, long arrayIndex, StringBuilder output)", "full_signature": "private static void attributeToString(IntervalFormat[] formatters, long arrayIndex, StringBuilder output)", "class_method_signature": "AkInterval.attributeToString(IntervalFormat[] formatters, long arrayIndex, StringBuilder output)", "testcase": false, "constructor": false}, {"identifier": "createParser", "parameters": "(final Attribute formatAttribute,\n                                                                   final F[] formatters)", "modifiers": "private static", "return": "TParser", "signature": "TParser createParser(final Attribute formatAttribute,\n                                                                   final F[] formatters)", "full_signature": "private static TParser createParser(final Attribute formatAttribute,\n                                                                   final F[] formatters)", "class_method_signature": "AkInterval.createParser(final Attribute formatAttribute,\n                                                                   final F[] formatters)", "testcase": false, "constructor": false}, {"identifier": "createTypeIdToFormatMap", "parameters": "(F[] values)", "modifiers": "private static", "return": "Map<TypeId, F>", "signature": "Map<TypeId, F> createTypeIdToFormatMap(F[] values)", "full_signature": "private static Map<TypeId, F> createTypeIdToFormatMap(F[] values)", "class_method_signature": "AkInterval.createTypeIdToFormatMap(F[] values)", "testcase": false, "constructor": false}], "file": "fdb-sql-layer-core/src/main/java/com/foundationdb/server/types/aksql/aktypes/AkInterval.java"}, "focal_method": {"identifier": "secondsRawFrom", "parameters": "(long source, TimeUnit sourceUnit)", "modifiers": "public static", "return": "long", "body": "public static long secondsRawFrom(long source, TimeUnit sourceUnit) {\n        return AkIntervalSecondsFormat.UNDERLYING_UNIT.convert(source, sourceUnit);\n    }", "signature": "long secondsRawFrom(long source, TimeUnit sourceUnit)", "full_signature": "public static long secondsRawFrom(long source, TimeUnit sourceUnit)", "class_method_signature": "AkInterval.secondsRawFrom(long source, TimeUnit sourceUnit)", "testcase": false, "constructor": false, "invocations": ["convert"]}, "repository": {"repo_id": 32884360, "url": "https://github.com/jaytaylor/sql-layer", "language": "Java", "is_fork": false, "fork_count": 120, "stargazer_count": 77, "size": 138665, "license": "licensed"}}