{"test_class": {"identifier": "AdvancedFilterValidatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private AdvancedFilterValidator validator;", "modifier": "private", "type": "AdvancedFilterValidator", "declarator": "validator", "var_name": "validator"}, {"original_string": "@Mock\n    private FilterValidator filterValidator1;", "modifier": "@Mock\n    private", "type": "FilterValidator", "declarator": "filterValidator1", "var_name": "filterValidator1"}, {"original_string": "@Mock\n    private FilterValidator filterValidator2;", "modifier": "@Mock\n    private", "type": "FilterValidator", "declarator": "filterValidator2", "var_name": "filterValidator2"}, {"original_string": "@Mock\n    private PackageProperties properties;", "modifier": "@Mock\n    private", "type": "PackageProperties", "declarator": "properties", "var_name": "properties"}, {"original_string": "@Mock\n    private WorkspaceFilter filter;", "modifier": "@Mock\n    private", "type": "WorkspaceFilter", "declarator": "filter", "var_name": "filter"}, {"original_string": "private Collection<PackageInfo> dependenciesMetaInfo;", "modifier": "private", "type": "Collection<PackageInfo>", "declarator": "dependenciesMetaInfo", "var_name": "dependenciesMetaInfo"}, {"original_string": "private Collection<String> validRoots;", "modifier": "private", "type": "Collection<String>", "declarator": "validRoots", "var_name": "validRoots"}, {"original_string": "private DocumentBuilderFactory factory;", "modifier": "private", "type": "DocumentBuilderFactory", "declarator": "factory", "var_name": "factory"}], "file": "vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidatorTest.java"}, "test_case": {"identifier": "testFilterWithInvalidElements", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testFilterWithInvalidElements()\n            throws URISyntaxException, IOException, SAXException, ParserConfigurationException, ConfigurationException {\n        try (InputStream input = this.getClass()\n                .getResourceAsStream(\"/invalid-package/META-INF/vault/filter.xml\")) {\n            validator = new AdvancedFilterValidator(\n                    factory,\n                    ValidationMessageSeverity.WARN,\n                    AdvancedFilterValidatorFactory.DEFAULT_SEVERITY_FOR_UNCOVERED_ANCESTOR_NODES,\n                    ValidationMessageSeverity.ERROR,\n                    ValidationMessageSeverity.ERROR,\n                    false,\n                    dependenciesMetaInfo,\n                    filter,\n                    validRoots);\n            Collection<ValidationMessage> messages = validator.validateMetaInfData(input, Paths.get(\"vault/filter.xml\"), Paths.get(\"\"));\n            ValidationExecutorTest.assertViolation(messages,\n                    new ValidationMessage(ValidationMessageSeverity.WARN,\n                            \"cvc-complex-type.3.2.2: Attribute 'mode' is not allowed to appear in element 'exclude'.\", 20, 51, null),\n                    new ValidationMessage(ValidationMessageSeverity.WARN,\n                            \"cvc-complex-type.2.4.a: Invalid content was found starting with element 'invalidelement'. One of '{exclude, include}' is expected.\",\n                            22, 27, null),\n                    new ValidationMessage(ValidationMessageSeverity.WARN, AdvancedFilterValidator.MESSAGE_INVALID_FILTER_XML)); // because\n                                                                                                                                // of\n                                                                                                                                // invalid\n                                                                                                                                // regex\n        }\n    }", "signature": "void testFilterWithInvalidElements()", "full_signature": "@Test public void testFilterWithInvalidElements()", "class_method_signature": "AdvancedFilterValidatorTest.testFilterWithInvalidElements()", "testcase": true, "constructor": false, "invocations": ["getResourceAsStream", "getClass", "validateMetaInfData", "get", "get", "assertViolation"]}, "focal_class": {"identifier": "AdvancedFilterValidator", "superclass": "", "interfaces": "implements GenericMetaInfDataValidator, FilterValidator, DocumentViewXmlValidator, JcrPathValidator", "fields": [{"original_string": "protected static final String MESSAGE_ORPHANED_FILTER_ENTRIES = \"Found orphaned filter entries: %s\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_ORPHANED_FILTER_ENTRIES = \"Found orphaned filter entries: %s\"", "var_name": "MESSAGE_ORPHANED_FILTER_ENTRIES"}, {"original_string": "protected static final String MESSAGE_INVALID_PATTERN = \"Invalid pattern given ('%s') which will never match for any descendants of the root path '%s'.\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_INVALID_PATTERN = \"Invalid pattern given ('%s') which will never match for any descendants of the root path '%s'.\"", "var_name": "MESSAGE_INVALID_PATTERN"}, {"original_string": "protected static final String MESSAGE_ROOT_PATH_NOT_ABSOLUTE = \"Root path must be absolute, but does not start with a '/': '%s'.\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_ROOT_PATH_NOT_ABSOLUTE = \"Root path must be absolute, but does not start with a '/': '%s'.\"", "var_name": "MESSAGE_ROOT_PATH_NOT_ABSOLUTE"}, {"original_string": "protected static final String MESSAGE_INVALID_FILTER_XML = \"Invalid filter.xml\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_INVALID_FILTER_XML = \"Invalid filter.xml\"", "var_name": "MESSAGE_INVALID_FILTER_XML"}, {"original_string": "protected static final String MESSAGE_FILTER_ROOT_ANCESTOR_COVERED_BUT_EXCLUDED = \"Filter root's ancestor '%s' is covered by dependency '%s' but excluded by its patterns.\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_FILTER_ROOT_ANCESTOR_COVERED_BUT_EXCLUDED = \"Filter root's ancestor '%s' is covered by dependency '%s' but excluded by its patterns.\"", "var_name": "MESSAGE_FILTER_ROOT_ANCESTOR_COVERED_BUT_EXCLUDED"}, {"original_string": "protected static final String MESSAGE_FILTER_ROOT_ANCESTOR_UNCOVERED = \"Filter root's ancestor '%s' is not covered by any of the specified dependencies nor a valid root.\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_FILTER_ROOT_ANCESTOR_UNCOVERED = \"Filter root's ancestor '%s' is not covered by any of the specified dependencies nor a valid root.\"", "var_name": "MESSAGE_FILTER_ROOT_ANCESTOR_UNCOVERED"}, {"original_string": "protected static final String MESSAGE_NODE_NOT_CONTAINED = \"Node '%s' is not contained in any of the filter rules\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_NODE_NOT_CONTAINED = \"Node '%s' is not contained in any of the filter rules\"", "var_name": "MESSAGE_NODE_NOT_CONTAINED"}, {"original_string": "protected static final String MESSAGE_ANCESTOR_NODE_NOT_COVERED = \"Ancestor node '%s' is not covered by any of the filter rules. Preferably depend on a package that provides this node or include it in the filter rules!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_ANCESTOR_NODE_NOT_COVERED = \"Ancestor node '%s' is not covered by any of the filter rules. Preferably depend on a package that provides this node or include it in the filter rules!\"", "var_name": "MESSAGE_ANCESTOR_NODE_NOT_COVERED"}, {"original_string": "protected static final String MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT = \"Ancestor node '%s' is not covered by any of the filter rules but that node is a given root (either by a dependency or by the known roots). Remove that node!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT = \"Ancestor node '%s' is not covered by any of the filter rules but that node is a given root (either by a dependency or by the known roots). Remove that node!\"", "var_name": "MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT"}, {"original_string": "protected static final String MESSAGE_NODE_BELOW_CLEANUP_FILTER = \"Node '%s' is covered by a 'cleanup' filter rule. That filter type is only supposed to be used for removing nodes during import!\";", "modifier": "protected static final", "type": "String", "declarator": "MESSAGE_NODE_BELOW_CLEANUP_FILTER = \"Node '%s' is covered by a 'cleanup' filter rule. That filter type is only supposed to be used for removing nodes during import!\"", "var_name": "MESSAGE_NODE_BELOW_CLEANUP_FILTER"}, {"original_string": "static final Path FILTER_XML_PATH = Paths.get(Constants.VAULT_DIR, Constants.FILTER_XML);", "modifier": "static final", "type": "Path", "declarator": "FILTER_XML_PATH = Paths.get(Constants.VAULT_DIR, Constants.FILTER_XML)", "var_name": "FILTER_XML_PATH"}, {"original_string": "private final DocumentBuilderFactory factory;", "modifier": "private final", "type": "DocumentBuilderFactory", "declarator": "factory", "var_name": "factory"}, {"original_string": "private final boolean isSubPackage;", "modifier": "private final", "type": "boolean", "declarator": "isSubPackage", "var_name": "isSubPackage"}, {"original_string": "private final Collection<String> validRoots;", "modifier": "private final", "type": "Collection<String>", "declarator": "validRoots", "var_name": "validRoots"}, {"original_string": "private final @NotNull ValidationMessageSeverity defaultSeverity;", "modifier": "private final @NotNull", "type": "ValidationMessageSeverity", "declarator": "defaultSeverity", "var_name": "defaultSeverity"}, {"original_string": "private final @NotNull ValidationMessageSeverity severityForUncoveredAncestorNode;", "modifier": "private final @NotNull", "type": "ValidationMessageSeverity", "declarator": "severityForUncoveredAncestorNode", "var_name": "severityForUncoveredAncestorNode"}, {"original_string": "private final @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors;", "modifier": "private final @NotNull", "type": "ValidationMessageSeverity", "declarator": "severityForUncoveredFilterRootAncestors", "var_name": "severityForUncoveredFilterRootAncestors"}, {"original_string": "private final @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries;", "modifier": "private final @NotNull", "type": "ValidationMessageSeverity", "declarator": "severityForOrphanedFilterEntries", "var_name": "severityForOrphanedFilterEntries"}, {"original_string": "private final Collection<PackageInfo> dependenciesMetaInfo;", "modifier": "private final", "type": "Collection<PackageInfo>", "declarator": "dependenciesMetaInfo", "var_name": "dependenciesMetaInfo"}, {"original_string": "private final WorkspaceFilter filter;", "modifier": "private final", "type": "WorkspaceFilter", "declarator": "filter", "var_name": "filter"}, {"original_string": "private Map<String, FilterValidator> filterValidators;", "modifier": "private", "type": "Map<String, FilterValidator>", "declarator": "filterValidators", "var_name": "filterValidators"}, {"original_string": "private final Collection<String> danglingNodePaths;", "modifier": "private final", "type": "Collection<String>", "declarator": "danglingNodePaths", "var_name": "danglingNodePaths"}, {"original_string": "private final Map<PathFilterSet, List<Entry<PathFilter>>> orphanedFilterSets;", "modifier": "private final", "type": "Map<PathFilterSet, List<Entry<PathFilter>>>", "declarator": "orphanedFilterSets", "var_name": "orphanedFilterSets"}], "methods": [{"identifier": "AdvancedFilterValidator", "parameters": "(@NotNull DocumentBuilderFactory factory, @NotNull ValidationMessageSeverity defaultSeverity, @NotNull ValidationMessageSeverity severityForUncoveredAncestorNodes, @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors, @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries, boolean isSubPackage, @NotNull Collection<PackageInfo> dependenciesMetaInfo, @NotNull WorkspaceFilter filter, @NotNull Collection<String> validRoots)", "modifiers": "public", "return": "", "signature": " AdvancedFilterValidator(@NotNull DocumentBuilderFactory factory, @NotNull ValidationMessageSeverity defaultSeverity, @NotNull ValidationMessageSeverity severityForUncoveredAncestorNodes, @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors, @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries, boolean isSubPackage, @NotNull Collection<PackageInfo> dependenciesMetaInfo, @NotNull WorkspaceFilter filter, @NotNull Collection<String> validRoots)", "full_signature": "public  AdvancedFilterValidator(@NotNull DocumentBuilderFactory factory, @NotNull ValidationMessageSeverity defaultSeverity, @NotNull ValidationMessageSeverity severityForUncoveredAncestorNodes, @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors, @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries, boolean isSubPackage, @NotNull Collection<PackageInfo> dependenciesMetaInfo, @NotNull WorkspaceFilter filter, @NotNull Collection<String> validRoots)", "class_method_signature": "AdvancedFilterValidator.AdvancedFilterValidator(@NotNull DocumentBuilderFactory factory, @NotNull ValidationMessageSeverity defaultSeverity, @NotNull ValidationMessageSeverity severityForUncoveredAncestorNodes, @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors, @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries, boolean isSubPackage, @NotNull Collection<PackageInfo> dependenciesMetaInfo, @NotNull WorkspaceFilter filter, @NotNull Collection<String> validRoots)", "testcase": false, "constructor": true}, {"identifier": "setFilterValidators", "parameters": "(Map<String, FilterValidator> filterValidators)", "modifiers": "public", "return": "void", "signature": "void setFilterValidators(Map<String, FilterValidator> filterValidators)", "full_signature": "public void setFilterValidators(Map<String, FilterValidator> filterValidators)", "class_method_signature": "AdvancedFilterValidator.setFilterValidators(Map<String, FilterValidator> filterValidators)", "testcase": false, "constructor": false}, {"identifier": "done", "parameters": "()", "modifiers": "@Override public", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> done()", "full_signature": "@Override public Collection<ValidationMessage> done()", "class_method_signature": "AdvancedFilterValidator.done()", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(@NotNull WorkspaceFilter filter)", "modifiers": "@Override public", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validate(@NotNull WorkspaceFilter filter)", "full_signature": "@Override public Collection<ValidationMessage> validate(@NotNull WorkspaceFilter filter)", "class_method_signature": "AdvancedFilterValidator.validate(@NotNull WorkspaceFilter filter)", "testcase": false, "constructor": false}, {"identifier": "validatePathFilterSets", "parameters": "(Collection<PathFilterSet> pathFilterSets, boolean checkRoots)", "modifiers": "private", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validatePathFilterSets(Collection<PathFilterSet> pathFilterSets, boolean checkRoots)", "full_signature": "private Collection<ValidationMessage> validatePathFilterSets(Collection<PathFilterSet> pathFilterSets, boolean checkRoots)", "class_method_signature": "AdvancedFilterValidator.validatePathFilterSets(Collection<PathFilterSet> pathFilterSets, boolean checkRoots)", "testcase": false, "constructor": false}, {"identifier": "validateFileNodePath", "parameters": "(@NotNull String nodePath)", "modifiers": "private", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validateFileNodePath(@NotNull String nodePath)", "full_signature": "private Collection<ValidationMessage> validateFileNodePath(@NotNull String nodePath)", "class_method_signature": "AdvancedFilterValidator.validateFileNodePath(@NotNull String nodePath)", "testcase": false, "constructor": false}, {"identifier": "validateJcrPath", "parameters": "(@NotNull NodeContext nodeContext,\n            boolean isFolder)", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext,\n            boolean isFolder)", "full_signature": "@Override public @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext,\n            boolean isFolder)", "class_method_signature": "AdvancedFilterValidator.validateJcrPath(@NotNull NodeContext nodeContext,\n            boolean isFolder)", "testcase": false, "constructor": false}, {"identifier": "validate", "parameters": "(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "modifiers": "@Override public @Nullable", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "full_signature": "@Override public @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "class_method_signature": "AdvancedFilterValidator.validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot)", "testcase": false, "constructor": false}, {"identifier": "isRegexValidForRootPath", "parameters": "(String regex, String rootPath)", "modifiers": "static", "return": "boolean", "signature": "boolean isRegexValidForRootPath(String regex, String rootPath)", "full_signature": "static boolean isRegexValidForRootPath(String regex, String rootPath)", "class_method_signature": "AdvancedFilterValidator.isRegexValidForRootPath(String regex, String rootPath)", "testcase": false, "constructor": false}, {"identifier": "validateMetaInfData", "parameters": "(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "modifiers": "@Override public", "return": "Collection<ValidationMessage>", "signature": "Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "full_signature": "@Override public Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "class_method_signature": "AdvancedFilterValidator.validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "testcase": false, "constructor": false}, {"identifier": "shouldValidateMetaInfData", "parameters": "(@NotNull Path filePath)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean shouldValidateMetaInfData(@NotNull Path filePath)", "full_signature": "@Override public boolean shouldValidateMetaInfData(@NotNull Path filePath)", "class_method_signature": "AdvancedFilterValidator.shouldValidateMetaInfData(@NotNull Path filePath)", "testcase": false, "constructor": false}, {"identifier": "removeFromOrphanedFilterEntries", "parameters": "(@NotNull String nodePath)", "modifiers": "private", "return": "void", "signature": "void removeFromOrphanedFilterEntries(@NotNull String nodePath)", "full_signature": "private void removeFromOrphanedFilterEntries(@NotNull String nodePath)", "class_method_signature": "AdvancedFilterValidator.removeFromOrphanedFilterEntries(@NotNull String nodePath)", "testcase": false, "constructor": false}, {"identifier": "getDanglingAncestorNodePath", "parameters": "(String nodePath, WorkspaceFilter filter)", "modifiers": "@Nullable", "return": "String", "signature": "String getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter)", "full_signature": "@Nullable String getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter)", "class_method_signature": "AdvancedFilterValidator.getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter)", "testcase": false, "constructor": false}], "file": "vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java"}, "focal_method": {"identifier": "validateMetaInfData", "parameters": "(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "modifiers": "@Override public", "return": "Collection<ValidationMessage>", "body": "@Override\n    public Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath) throws IOException {\n        Collection<ValidationMessage> messages = new LinkedList<>();\n        try {    \n            DocumentBuilder parser = factory.newDocumentBuilder();\n            ValidationMessageErrorHandler errorHandler = new ValidationMessageErrorHandler(defaultSeverity);\n            parser.setErrorHandler(errorHandler);\n            Document document = parser.parse(input, \"\");\n\n            messages.addAll(errorHandler.getValidationMessages());\n            DefaultWorkspaceFilter filter = new DefaultWorkspaceFilter();\n            try {\n                filter.load(document.getDocumentElement());\n                // call all registered filter validators\n                for (Map.Entry<String, FilterValidator> entry : filterValidators.entrySet()) {\n                    messages.add(new ValidationMessage(ValidationMessageSeverity.DEBUG,\n                            \"Validating with validator \" + entry.getKey() + \"...\"));\n                    Collection<ValidationMessage> filterValidatorMessages = entry.getValue().validate(filter);\n                    if (filterValidatorMessages != null) {\n                        messages.addAll(ValidationViolation.wrapMessages(entry.getKey(), filterValidatorMessages, null, null, null, 0, 0));\n                    }\n                }\n            } catch (ConfigurationException e) {\n                messages.add(new ValidationMessage(defaultSeverity, MESSAGE_INVALID_FILTER_XML, e));\n            }\n            return messages;\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException(\"Could not create parser from factory\", e);\n        } catch (SAXException e) {\n            throw new IllegalStateException(\"Could not parse filter.xml\", e);\n        }\n    }", "signature": "Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "full_signature": "@Override public Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "class_method_signature": "AdvancedFilterValidator.validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath)", "testcase": false, "constructor": false, "invocations": ["newDocumentBuilder", "setErrorHandler", "parse", "addAll", "getValidationMessages", "load", "getDocumentElement", "entrySet", "add", "getKey", "validate", "getValue", "addAll", "wrapMessages", "getKey", "add"]}, "repository": {"repo_id": 16021499, "url": "https://github.com/apache/jackrabbit-filevault", "stars": 24, "created": "1/18/2014 8:00:07 AM +00:00", "updates": "2020-01-22T11:47:21+00:00", "fork": "False", "license": "licensed"}}