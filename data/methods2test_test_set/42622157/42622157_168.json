{"test_class": {"identifier": "SplittingTest", "superclass": "extends TestWithGitBackedRepository", "interfaces": "", "fields": [{"original_string": "private Splitting splitting = new Splitting();", "modifier": "private", "type": "Splitting", "declarator": "splitting = new Splitting()", "var_name": "splitting"}, {"original_string": "private TTopologyTemplate topologyTemplate;", "modifier": "private", "type": "TTopologyTemplate", "declarator": "topologyTemplate", "var_name": "topologyTemplate"}, {"original_string": "private TTopologyTemplate topologyTemplate2;", "modifier": "private", "type": "TTopologyTemplate", "declarator": "topologyTemplate2", "var_name": "topologyTemplate2"}], "file": "org.eclipse.winery.repository/src/test/java/org/eclipse/winery/repository/splitting/SplittingTest.java"}, "test_case": {"identifier": "splitSmallTopology", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void splitSmallTopology() throws Exception {\n        List<String> expectedIds = Arrays.asList(\"NT1\", \"NT1_2\", \"NT1_3-A\", \"NT1_3-B\", \"NT1_4-A\", \"NT1_4-B\", \"NT1_5-A\", \"NT1_5-B\", \"con37\", \"con45\", \"con_91-A-A\", \"con_57-B-B\");\n        List<TEntityTemplate> NodeTemplates = splitting.split(topologyTemplate).getNodeTemplateOrRelationshipTemplate();\n\n        List<String> Ids = new ArrayList<>();\n        for (TEntityTemplate nodeTemplate : NodeTemplates) {\n            Ids.add(nodeTemplate.getId());\n        }\n\n        assertEquals(expectedIds, Ids);\n    }", "signature": "void splitSmallTopology()", "full_signature": "@Test public void splitSmallTopology()", "class_method_signature": "SplittingTest.splitSmallTopology()", "testcase": true, "constructor": false, "invocations": ["asList", "getNodeTemplateOrRelationshipTemplate", "split", "add", "getId", "assertEquals"]}, "focal_class": {"identifier": "Splitting", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final org.slf4j.Logger LOGGER = LoggerFactory.getLogger(Splitting.class);", "modifier": "private static final", "type": "org.slf4j.Logger", "declarator": "LOGGER = LoggerFactory.getLogger(Splitting.class)", "var_name": "LOGGER"}, {"original_string": "private static int newRelationshipIdCounter = 100;", "modifier": "private static", "type": "int", "declarator": "newRelationshipIdCounter = 100", "var_name": "newRelationshipIdCounter"}, {"original_string": "private static int nodeTemplateIdCounter = 1;", "modifier": "private static", "type": "int", "declarator": "nodeTemplateIdCounter = 1", "var_name": "nodeTemplateIdCounter"}, {"original_string": "private static int IdCounter = 1;", "modifier": "private static", "type": "int", "declarator": "IdCounter = 1", "var_name": "IdCounter"}, {"original_string": "private Map<TNodeTemplate, Set<TNodeTemplate>> initDirectSuccessors = new HashMap<>();", "modifier": "private", "type": "Map<TNodeTemplate, Set<TNodeTemplate>>", "declarator": "initDirectSuccessors = new HashMap<>()", "var_name": "initDirectSuccessors"}, {"original_string": "private Map<TNodeTemplate, Boolean> visitedNodeTemplates = new HashMap<>();", "modifier": "private", "type": "Map<TNodeTemplate, Boolean>", "declarator": "visitedNodeTemplates = new HashMap<>()", "var_name": "visitedNodeTemplates"}, {"original_string": "private Map<TNodeTemplate, Set<TNodeTemplate>> transitiveAndDirectSuccessors = new HashMap<>();", "modifier": "private", "type": "Map<TNodeTemplate, Set<TNodeTemplate>>", "declarator": "transitiveAndDirectSuccessors = new HashMap<>()", "var_name": "transitiveAndDirectSuccessors"}], "methods": [{"identifier": "splitTopologyOfServiceTemplate", "parameters": "(ServiceTemplateId id)", "modifiers": "public", "return": "ServiceTemplateId", "signature": "ServiceTemplateId splitTopologyOfServiceTemplate(ServiceTemplateId id)", "full_signature": "public ServiceTemplateId splitTopologyOfServiceTemplate(ServiceTemplateId id)", "class_method_signature": "Splitting.splitTopologyOfServiceTemplate(ServiceTemplateId id)", "testcase": false, "constructor": false}, {"identifier": "matchTopologyOfServiceTemplate", "parameters": "(ServiceTemplateId id)", "modifiers": "public", "return": "ServiceTemplateId", "signature": "ServiceTemplateId matchTopologyOfServiceTemplate(ServiceTemplateId id)", "full_signature": "public ServiceTemplateId matchTopologyOfServiceTemplate(ServiceTemplateId id)", "class_method_signature": "Splitting.matchTopologyOfServiceTemplate(ServiceTemplateId id)", "testcase": false, "constructor": false}, {"identifier": "hasTargetLabels", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "private", "return": "boolean", "signature": "boolean hasTargetLabels(TTopologyTemplate topologyTemplate)", "full_signature": "private boolean hasTargetLabels(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.hasTargetLabels(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "composeServiceTemplates", "parameters": "(String composedSolutionServiceTemplateID, List<ServiceTemplateId> serviceTemplateIds)", "modifiers": "public", "return": "ServiceTemplateId", "signature": "ServiceTemplateId composeServiceTemplates(String composedSolutionServiceTemplateID, List<ServiceTemplateId> serviceTemplateIds)", "full_signature": "public ServiceTemplateId composeServiceTemplates(String composedSolutionServiceTemplateID, List<ServiceTemplateId> serviceTemplateIds)", "class_method_signature": "Splitting.composeServiceTemplates(String composedSolutionServiceTemplateID, List<ServiceTemplateId> serviceTemplateIds)", "testcase": false, "constructor": false}, {"identifier": "resolveTopologyTemplate", "parameters": "(ServiceTemplateId serviceTemplateId)", "modifiers": "public", "return": "void", "signature": "void resolveTopologyTemplate(ServiceTemplateId serviceTemplateId)", "full_signature": "public void resolveTopologyTemplate(ServiceTemplateId serviceTemplateId)", "class_method_signature": "Splitting.resolveTopologyTemplate(ServiceTemplateId serviceTemplateId)", "testcase": false, "constructor": false}, {"identifier": "checkValidTopology", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "public", "return": "boolean", "signature": "boolean checkValidTopology(TTopologyTemplate topologyTemplate)", "full_signature": "public boolean checkValidTopology(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.checkValidTopology(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "split", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "public", "return": "TTopologyTemplate", "signature": "TTopologyTemplate split(TTopologyTemplate topologyTemplate)", "full_signature": "public TTopologyTemplate split(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.split(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "getHostingInjectionOptions", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "public", "return": "Map<String, List<TTopologyTemplate>>", "signature": "Map<String, List<TTopologyTemplate>> getHostingInjectionOptions(TTopologyTemplate topologyTemplate)", "full_signature": "public Map<String, List<TTopologyTemplate>> getHostingInjectionOptions(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.getHostingInjectionOptions(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "hasNodeOpenRequirement", "parameters": "(TTopologyTemplate topology, TNodeTemplate node)", "modifiers": "private", "return": "boolean", "signature": "boolean hasNodeOpenRequirement(TTopologyTemplate topology, TNodeTemplate node)", "full_signature": "private boolean hasNodeOpenRequirement(TTopologyTemplate topology, TNodeTemplate node)", "class_method_signature": "Splitting.hasNodeOpenRequirement(TTopologyTemplate topology, TNodeTemplate node)", "testcase": false, "constructor": false}, {"identifier": "getHostingMatchingOptionsWithDefaultLabeling", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "public", "return": "Map<String, List<TTopologyTemplate>>", "signature": "Map<String, List<TTopologyTemplate>> getHostingMatchingOptionsWithDefaultLabeling(TTopologyTemplate topologyTemplate)", "full_signature": "public Map<String, List<TTopologyTemplate>> getHostingMatchingOptionsWithDefaultLabeling(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.getHostingMatchingOptionsWithDefaultLabeling(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "hostMatchingWithDefaultHostSelection", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "public", "return": "TTopologyTemplate", "signature": "TTopologyTemplate hostMatchingWithDefaultHostSelection(TTopologyTemplate topologyTemplate)", "full_signature": "public TTopologyTemplate hostMatchingWithDefaultHostSelection(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.hostMatchingWithDefaultHostSelection(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "connectionMatchingWithDefaultConnectorSelection", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "public", "return": "TTopologyTemplate", "signature": "TTopologyTemplate connectionMatchingWithDefaultConnectorSelection(TTopologyTemplate topologyTemplate)", "full_signature": "public TTopologyTemplate connectionMatchingWithDefaultConnectorSelection(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.connectionMatchingWithDefaultConnectorSelection(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "injectNodeTemplates", "parameters": "(TTopologyTemplate topologyTemplate, Map<String, TTopologyTemplate> injectNodes, InjectRemoval removal)", "modifiers": "public", "return": "TTopologyTemplate", "signature": "TTopologyTemplate injectNodeTemplates(TTopologyTemplate topologyTemplate, Map<String, TTopologyTemplate> injectNodes, InjectRemoval removal)", "full_signature": "public TTopologyTemplate injectNodeTemplates(TTopologyTemplate topologyTemplate, Map<String, TTopologyTemplate> injectNodes, InjectRemoval removal)", "class_method_signature": "Splitting.injectNodeTemplates(TTopologyTemplate topologyTemplate, Map<String, TTopologyTemplate> injectNodes, InjectRemoval removal)", "testcase": false, "constructor": false}, {"identifier": "getConnectionInjectionOptions", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "public", "return": "Map<String, List<TTopologyTemplate>>", "signature": "Map<String, List<TTopologyTemplate>> getConnectionInjectionOptions(TTopologyTemplate topologyTemplate)", "full_signature": "public Map<String, List<TTopologyTemplate>> getConnectionInjectionOptions(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.getConnectionInjectionOptions(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "injectConnectionNodeTemplates", "parameters": "(TTopologyTemplate topologyTemplate, Map<String, TTopologyTemplate> selectedConnectionFragments)", "modifiers": "public", "return": "TTopologyTemplate", "signature": "TTopologyTemplate injectConnectionNodeTemplates(TTopologyTemplate topologyTemplate, Map<String, TTopologyTemplate> selectedConnectionFragments)", "full_signature": "public TTopologyTemplate injectConnectionNodeTemplates(TTopologyTemplate topologyTemplate, Map<String, TTopologyTemplate> selectedConnectionFragments)", "class_method_signature": "Splitting.injectConnectionNodeTemplates(TTopologyTemplate topologyTemplate, Map<String, TTopologyTemplate> selectedConnectionFragments)", "testcase": false, "constructor": false}, {"identifier": "getMatchingRelationshipType", "parameters": "(TRequirement requirement, TCapability capability)", "modifiers": "private", "return": "TRelationshipType", "signature": "TRelationshipType getMatchingRelationshipType(TRequirement requirement, TCapability capability)", "full_signature": "private TRelationshipType getMatchingRelationshipType(TRequirement requirement, TCapability capability)", "class_method_signature": "Splitting.getMatchingRelationshipType(TRequirement requirement, TCapability capability)", "testcase": false, "constructor": false}, {"identifier": "reassignOutgoingRelationships", "parameters": "(List<TRelationshipTemplate> outgoingRel, TNodeTemplate newSource)", "modifiers": "private", "return": "List<TRelationshipTemplate>", "signature": "List<TRelationshipTemplate> reassignOutgoingRelationships(List<TRelationshipTemplate> outgoingRel, TNodeTemplate newSource)", "full_signature": "private List<TRelationshipTemplate> reassignOutgoingRelationships(List<TRelationshipTemplate> outgoingRel, TNodeTemplate newSource)", "class_method_signature": "Splitting.reassignOutgoingRelationships(List<TRelationshipTemplate> outgoingRel, TNodeTemplate newSource)", "testcase": false, "constructor": false}, {"identifier": "reassignIncomingRelationships", "parameters": "(List<TRelationshipTemplate> incomingRel, TNodeTemplate newTarget)", "modifiers": "private", "return": "List<TRelationshipTemplate>", "signature": "List<TRelationshipTemplate> reassignIncomingRelationships(List<TRelationshipTemplate> incomingRel, TNodeTemplate newTarget)", "full_signature": "private List<TRelationshipTemplate> reassignIncomingRelationships(List<TRelationshipTemplate> incomingRel, TNodeTemplate newTarget)", "class_method_signature": "Splitting.reassignIncomingRelationships(List<TRelationshipTemplate> incomingRel, TNodeTemplate newTarget)", "testcase": false, "constructor": false}, {"identifier": "getReplacementNodeTemplateCandidatesForMatching", "parameters": "(TTopologyTemplate topologyTemplate, List<TNodeTemplate> matchingNodeTemplates)", "modifiers": "protected", "return": "List<TNodeTemplate>", "signature": "List<TNodeTemplate> getReplacementNodeTemplateCandidatesForMatching(TTopologyTemplate topologyTemplate, List<TNodeTemplate> matchingNodeTemplates)", "full_signature": "protected List<TNodeTemplate> getReplacementNodeTemplateCandidatesForMatching(TTopologyTemplate topologyTemplate, List<TNodeTemplate> matchingNodeTemplates)", "class_method_signature": "Splitting.getReplacementNodeTemplateCandidatesForMatching(TTopologyTemplate topologyTemplate, List<TNodeTemplate> matchingNodeTemplates)", "testcase": false, "constructor": false}, {"identifier": "getNodeTemplatesWithoutIncomingHostedOnRelationships", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "protected", "return": "List<TNodeTemplate>", "signature": "List<TNodeTemplate> getNodeTemplatesWithoutIncomingHostedOnRelationships(TTopologyTemplate topologyTemplate)", "full_signature": "protected List<TNodeTemplate> getNodeTemplatesWithoutIncomingHostedOnRelationships(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.getNodeTemplatesWithoutIncomingHostedOnRelationships(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "getNodeTemplatesWithoutOutgoingHostedOnRelationships", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "protected", "return": "List<TNodeTemplate>", "signature": "List<TNodeTemplate> getNodeTemplatesWithoutOutgoingHostedOnRelationships(TTopologyTemplate topologyTemplate)", "full_signature": "protected List<TNodeTemplate> getNodeTemplatesWithoutOutgoingHostedOnRelationships(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.getNodeTemplatesWithoutOutgoingHostedOnRelationships(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "getNodeTemplatesWhichPredecessorsHasNoPredecessors", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "protected", "return": "List<TNodeTemplate>", "signature": "List<TNodeTemplate> getNodeTemplatesWhichPredecessorsHasNoPredecessors(TTopologyTemplate topologyTemplate)", "full_signature": "protected List<TNodeTemplate> getNodeTemplatesWhichPredecessorsHasNoPredecessors(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.getNodeTemplatesWhichPredecessorsHasNoPredecessors(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "getHostedOnSuccessorsOfNodeTemplate", "parameters": "(TTopologyTemplate topologyTemplate, TNodeTemplate nodeTemplate)", "modifiers": "protected", "return": "List<TNodeTemplate>", "signature": "List<TNodeTemplate> getHostedOnSuccessorsOfNodeTemplate(TTopologyTemplate topologyTemplate, TNodeTemplate nodeTemplate)", "full_signature": "protected List<TNodeTemplate> getHostedOnSuccessorsOfNodeTemplate(TTopologyTemplate topologyTemplate, TNodeTemplate nodeTemplate)", "class_method_signature": "Splitting.getHostedOnSuccessorsOfNodeTemplate(TTopologyTemplate topologyTemplate, TNodeTemplate nodeTemplate)", "testcase": false, "constructor": false}, {"identifier": "getHostedOnPredecessorsOfNodeTemplate", "parameters": "(TTopologyTemplate topologyTemplate, TNodeTemplate nodeTemplate)", "modifiers": "protected", "return": "List<TNodeTemplate>", "signature": "List<TNodeTemplate> getHostedOnPredecessorsOfNodeTemplate(TTopologyTemplate topologyTemplate, TNodeTemplate nodeTemplate)", "full_signature": "protected List<TNodeTemplate> getHostedOnPredecessorsOfNodeTemplate(TTopologyTemplate topologyTemplate, TNodeTemplate nodeTemplate)", "class_method_signature": "Splitting.getHostedOnPredecessorsOfNodeTemplate(TTopologyTemplate topologyTemplate, TNodeTemplate nodeTemplate)", "testcase": false, "constructor": false}, {"identifier": "computeTransitiveClosure", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "public", "return": "Map<TNodeTemplate, Set<TNodeTemplate>>", "signature": "Map<TNodeTemplate, Set<TNodeTemplate>> computeTransitiveClosure(TTopologyTemplate topologyTemplate)", "full_signature": "public Map<TNodeTemplate, Set<TNodeTemplate>> computeTransitiveClosure(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.computeTransitiveClosure(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "computeNodeForTransitiveClosure", "parameters": "(TNodeTemplate nodeTemplate)", "modifiers": "private", "return": "void", "signature": "void computeNodeForTransitiveClosure(TNodeTemplate nodeTemplate)", "full_signature": "private void computeNodeForTransitiveClosure(TNodeTemplate nodeTemplate)", "class_method_signature": "Splitting.computeNodeForTransitiveClosure(TNodeTemplate nodeTemplate)", "testcase": false, "constructor": false}, {"identifier": "getOpenRequirementsAndMatchingBasisCapabilityTypeNames", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "public", "return": "Map<TRequirement, String>", "signature": "Map<TRequirement, String> getOpenRequirementsAndMatchingBasisCapabilityTypeNames(TTopologyTemplate topologyTemplate)", "full_signature": "public Map<TRequirement, String> getOpenRequirementsAndMatchingBasisCapabilityTypeNames(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.getOpenRequirementsAndMatchingBasisCapabilityTypeNames(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "getOpenRequirements", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "public", "return": "List<TRequirement>", "signature": "List<TRequirement> getOpenRequirements(TTopologyTemplate topologyTemplate)", "full_signature": "public List<TRequirement> getOpenRequirements(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.getOpenRequirements(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false}, {"identifier": "getBasisCapabilityType", "parameters": "(QName capabilityTypeQName)", "modifiers": "private", "return": "TCapabilityType", "signature": "TCapabilityType getBasisCapabilityType(QName capabilityTypeQName)", "full_signature": "private TCapabilityType getBasisCapabilityType(QName capabilityTypeQName)", "class_method_signature": "Splitting.getBasisCapabilityType(QName capabilityTypeQName)", "testcase": false, "constructor": false}, {"identifier": "getRequiredCapabilityTypeQNameOfRequirement", "parameters": "(TRequirement requirement)", "modifiers": "private", "return": "QName", "signature": "QName getRequiredCapabilityTypeQNameOfRequirement(TRequirement requirement)", "full_signature": "private QName getRequiredCapabilityTypeQNameOfRequirement(TRequirement requirement)", "class_method_signature": "Splitting.getRequiredCapabilityTypeQNameOfRequirement(TRequirement requirement)", "testcase": false, "constructor": false}, {"identifier": "getBasisRelationshipType", "parameters": "(QName relationshipTypeQName)", "modifiers": "public", "return": "TRelationshipType", "signature": "TRelationshipType getBasisRelationshipType(QName relationshipTypeQName)", "full_signature": "public TRelationshipType getBasisRelationshipType(QName relationshipTypeQName)", "class_method_signature": "Splitting.getBasisRelationshipType(QName relationshipTypeQName)", "testcase": false, "constructor": false}, {"identifier": "addMatchingRelationshipTemplateToTopologyTemplate", "parameters": "(TTopologyTemplate topologyTemplate, TRelationshipType relationshipType, TRequirement requirement, TCapability capability)", "modifiers": "private", "return": "void", "signature": "void addMatchingRelationshipTemplateToTopologyTemplate(TTopologyTemplate topologyTemplate, TRelationshipType relationshipType, TRequirement requirement, TCapability capability)", "full_signature": "private void addMatchingRelationshipTemplateToTopologyTemplate(TTopologyTemplate topologyTemplate, TRelationshipType relationshipType, TRequirement requirement, TCapability capability)", "class_method_signature": "Splitting.addMatchingRelationshipTemplateToTopologyTemplate(TTopologyTemplate topologyTemplate, TRelationshipType relationshipType, TRequirement requirement, TCapability capability)", "testcase": false, "constructor": false}, {"identifier": "equalsWithDifferentId", "parameters": "(TNodeTemplate node1, TNodeTemplate node2)", "modifiers": "private", "return": "boolean", "signature": "boolean equalsWithDifferentId(TNodeTemplate node1, TNodeTemplate node2)", "full_signature": "private boolean equalsWithDifferentId(TNodeTemplate node1, TNodeTemplate node2)", "class_method_signature": "Splitting.equalsWithDifferentId(TNodeTemplate node1, TNodeTemplate node2)", "testcase": false, "constructor": false}], "file": "org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/splitting/Splitting.java"}, "focal_method": {"identifier": "split", "parameters": "(TTopologyTemplate topologyTemplate)", "modifiers": "public", "return": "TTopologyTemplate", "body": "public TTopologyTemplate split(TTopologyTemplate topologyTemplate) throws SplittingException {\n        if (!checkValidTopology(topologyTemplate)) {\n            throw new SplittingException(\"Topology is not valid\");\n        }\n\n        // Copy for incremental removal of the processed nodes\n        TTopologyTemplate topologyTemplateCopy = BackendUtils.clone(topologyTemplate);\n\n        HashSet<TNodeTemplate> nodeTemplatesWhichPredecessorsHasNoPredecessors\n            = new HashSet<>(getNodeTemplatesWhichPredecessorsHasNoPredecessors(topologyTemplateCopy));\n\n        // Consider each node which hostedOn-predecessor nodes have no further hostedOn-predecessors\n        while (!nodeTemplatesWhichPredecessorsHasNoPredecessors.isEmpty()) {\n\n            for (TNodeTemplate currentNode : nodeTemplatesWhichPredecessorsHasNoPredecessors) {\n\n                List<TNodeTemplate> predecessors = getHostedOnPredecessorsOfNodeTemplate(topologyTemplateCopy, currentNode);\n                Set<String> predecessorsTargetLabel = new HashSet<>();\n\n                for (TNodeTemplate predecessor : predecessors) {\n                    Optional<String> targetLabel = ModelUtilities.getTargetLabel(predecessor);\n                    if (!targetLabel.isPresent()) {\n                        LOGGER.error(\"No target label present\");\n                        LOGGER.error(\"id \" + predecessor.getId());\n                    }\n\n                    //noinspection OptionalGetWithoutIsPresent\n                    predecessorsTargetLabel.add(targetLabel.get().toLowerCase());\n                }\n                // If all predecessors have the same target label assign this label to the considered node\n                if (predecessorsTargetLabel.size() == 1) {\n                    //noinspection OptionalGetWithoutIsPresent\n                    ModelUtilities.setTargetLabel(currentNode, ModelUtilities.getTargetLabel(predecessors.get(0)).get());\n                } else {\n\n                    List<TRelationshipTemplate> incomingRelationships\n                        = ModelUtilities.getIncomingRelationshipTemplates(topologyTemplateCopy, currentNode);\n                    List<TRelationshipTemplate> outgoingRelationships\n                        = ModelUtilities.getOutgoingRelationshipTemplates(topologyTemplateCopy, currentNode);\n\n                    // Otherwise, duplicate the considered node for each target label\n                    for (String targetLabel : predecessorsTargetLabel) {\n                        TNodeTemplate duplicatedNode = BackendUtils.clone(currentNode);\n                        duplicatedNode.setId(Util.makeNCName(currentNode.getId() + \"-\" + targetLabel));\n                        duplicatedNode.setName(Util.makeNCName(currentNode.getName() + \"-\" + targetLabel));\n                        topologyTemplate.getNodeTemplateOrRelationshipTemplate().add(duplicatedNode);\n                        topologyTemplateCopy.getNodeTemplateOrRelationshipTemplate().add(duplicatedNode);\n                        ModelUtilities.setTargetLabel(duplicatedNode, targetLabel);\n\n                        for (TRelationshipTemplate incomingRelationship : incomingRelationships) {\n                            Object sourceElementIncommingRel = incomingRelationship.getSourceElement().getRef();\n\n                            /*\n                             * incoming hostedOn relationships from predecessors with the same label and not hostedOn\n                             * relationships (e.g. conntectsTo) are assigned to the duplicated node.\n                             * The origin relationships are duplicated\n                             */\n                            TNodeTemplate sourceNodeTemplate = ModelUtilities.getSourceNodeTemplateOfRelationshipTemplate(topologyTemplateCopy, incomingRelationship);\n                            if (((ModelUtilities.getTargetLabel(sourceNodeTemplate).get()\n                                .equalsIgnoreCase(ModelUtilities.getTargetLabel(duplicatedNode).get())\n                                && getBasisRelationshipType(incomingRelationship.getType()).getValidTarget().getTypeRef().getLocalPart().equalsIgnoreCase(\"Container\"))\n                                || !predecessors.contains(sourceNodeTemplate))) {\n\n                                List<TRelationshipTemplate> reassignRelationship = new ArrayList<>();\n                                reassignRelationship.add(incomingRelationship);\n                                //Reassign incoming relationships\n                                List<TRelationshipTemplate> reassignedRelationship\n                                    = reassignIncomingRelationships(reassignRelationship, duplicatedNode);\n                                topologyTemplate.getNodeTemplateOrRelationshipTemplate().addAll(reassignedRelationship);\n                                topologyTemplateCopy.getNodeTemplateOrRelationshipTemplate().addAll(reassignedRelationship);\n                            }\n                        }\n\n                        /*\n                         * Reassign outgoing relationships. No difference between the relationship types.\n                         * Origin outgoing relationships are duplicated and added to the duplicated node as source\n                         */\n                        List<TRelationshipTemplate> newOutgoingRelationships\n                            = reassignOutgoingRelationships(outgoingRelationships, duplicatedNode);\n                        topologyTemplate.getNodeTemplateOrRelationshipTemplate().addAll(newOutgoingRelationships);\n                        topologyTemplateCopy.getNodeTemplateOrRelationshipTemplate().addAll(newOutgoingRelationships);\n                    }\n\n                    // Remove the original node and its relations from the origin topology template and the copy\n                    topologyTemplate.getNodeTemplateOrRelationshipTemplate().remove(currentNode);\n                    topologyTemplate.getNodeTemplateOrRelationshipTemplate().removeAll(outgoingRelationships);\n                    topologyTemplate.getNodeTemplateOrRelationshipTemplate().removeAll(incomingRelationships);\n                    topologyTemplateCopy.getNodeTemplateOrRelationshipTemplate().remove(currentNode);\n                    topologyTemplateCopy.getNodeTemplateOrRelationshipTemplate().removeAll(outgoingRelationships);\n                    topologyTemplateCopy.getNodeTemplateOrRelationshipTemplate().removeAll(incomingRelationships);\n                }\n\n                // Remove the hostedOn-predecessors of the considered node and their relations in the working copy\n                topologyTemplateCopy.getNodeTemplateOrRelationshipTemplate().removeAll(predecessors);\n                List<TRelationshipTemplate> removingRelationships =\n                    topologyTemplateCopy.getRelationshipTemplates().stream()\n                        .filter(rt -> predecessors.contains(ModelUtilities.getSourceNodeTemplateOfRelationshipTemplate(topologyTemplateCopy, rt))\n                            || predecessors.contains(ModelUtilities.getTargetNodeTemplateOfRelationshipTemplate(topologyTemplateCopy, rt)))\n                        .collect(Collectors.toList());\n\n                topologyTemplateCopy.getNodeTemplateOrRelationshipTemplate().removeAll(removingRelationships);\n            }\n            nodeTemplatesWhichPredecessorsHasNoPredecessors.clear();\n            nodeTemplatesWhichPredecessorsHasNoPredecessors.addAll(getNodeTemplatesWhichPredecessorsHasNoPredecessors(topologyTemplateCopy));\n        }\n\n        return topologyTemplate;\n    }", "signature": "TTopologyTemplate split(TTopologyTemplate topologyTemplate)", "full_signature": "public TTopologyTemplate split(TTopologyTemplate topologyTemplate)", "class_method_signature": "Splitting.split(TTopologyTemplate topologyTemplate)", "testcase": false, "constructor": false, "invocations": ["checkValidTopology", "clone", "getNodeTemplatesWhichPredecessorsHasNoPredecessors", "isEmpty", "getHostedOnPredecessorsOfNodeTemplate", "getTargetLabel", "isPresent", "error", "error", "getId", "add", "toLowerCase", "get", "size", "setTargetLabel", "get", "getTargetLabel", "get", "getIncomingRelationshipTemplates", "getOutgoingRelationshipTemplates", "clone", "setId", "makeNCName", "getId", "setName", "makeNCName", "getName", "add", "getNodeTemplateOrRelationshipTemplate", "add", "getNodeTemplateOrRelationshipTemplate", "setTargetLabel", "getRef", "getSourceElement", "getSourceNodeTemplateOfRelationshipTemplate", "equalsIgnoreCase", "get", "getTargetLabel", "get", "getTargetLabel", "equalsIgnoreCase", "getLocalPart", "getTypeRef", "getValidTarget", "getBasisRelationshipType", "getType", "contains", "add", "reassignIncomingRelationships", "addAll", "getNodeTemplateOrRelationshipTemplate", "addAll", "getNodeTemplateOrRelationshipTemplate", "reassignOutgoingRelationships", "addAll", "getNodeTemplateOrRelationshipTemplate", "addAll", "getNodeTemplateOrRelationshipTemplate", "remove", "getNodeTemplateOrRelationshipTemplate", "removeAll", "getNodeTemplateOrRelationshipTemplate", "removeAll", "getNodeTemplateOrRelationshipTemplate", "remove", "getNodeTemplateOrRelationshipTemplate", "removeAll", "getNodeTemplateOrRelationshipTemplate", "removeAll", "getNodeTemplateOrRelationshipTemplate", "removeAll", "getNodeTemplateOrRelationshipTemplate", "collect", "filter", "stream", "getRelationshipTemplates", "contains", "getSourceNodeTemplateOfRelationshipTemplate", "contains", "getTargetNodeTemplateOfRelationshipTemplate", "toList", "removeAll", "getNodeTemplateOrRelationshipTemplate", "clear", "addAll", "getNodeTemplatesWhichPredecessorsHasNoPredecessors"]}, "repository": {"repo_id": 42622157, "url": "https://github.com/eclipse/winery", "stars": 34, "created": "9/17/2015 12:31:44 AM +00:00", "updates": "2020-01-22T09:32:00+00:00", "fork": "False", "license": "licensed"}}