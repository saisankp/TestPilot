{"test_class": {"identifier": "RateLimitingProcessorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String CHANGE_TOKEN = \"DOES NOT MATTER\";", "modifier": "public static final", "type": "String", "declarator": "CHANGE_TOKEN = \"DOES NOT MATTER\"", "var_name": "CHANGE_TOKEN"}, {"original_string": "RateLimitingProcessor processor;", "modifier": "", "type": "RateLimitingProcessor", "declarator": "processor", "var_name": "processor"}, {"original_string": "LogProcessorLambdaConfig config;", "modifier": "", "type": "LogProcessorLambdaConfig", "declarator": "config", "var_name": "config"}, {"original_string": "private static final String FAKE_BUCKET_NAME = \"blah\";", "modifier": "private static final", "type": "String", "declarator": "FAKE_BUCKET_NAME = \"blah\"", "var_name": "FAKE_BUCKET_NAME"}, {"original_string": "@Mock\n    AWSWAFRegional awswaf;", "modifier": "@Mock", "type": "AWSWAFRegional", "declarator": "awswaf", "var_name": "awswaf"}, {"original_string": "@Mock\n    AmazonS3 amazonS3;", "modifier": "@Mock", "type": "AmazonS3", "declarator": "amazonS3", "var_name": "amazonS3"}, {"original_string": "@Mock\n    LogProcessorLambdaConfig logProcessorLambdaConfig;", "modifier": "@Mock", "type": "LogProcessorLambdaConfig", "declarator": "logProcessorLambdaConfig", "var_name": "logProcessorLambdaConfig"}], "file": "cerberus-log-processor-lambda/src/test/java/com/nike/cerberus/lambda/waf/processor/RateLimitingProcessorTest.java"}, "test_case": {"identifier": "testThatGetCurrentViolatorsReturnsAMapOfIpAddressToMetaDataAndContainsTheHighestRate", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testThatGetCurrentViolatorsReturnsAMapOfIpAddressToMetaDataAndContainsTheHighestRate() {\n        when(config.getRequestPerIntervalLimit()).thenReturn(2);\n        Map<String, Integer> map = Maps.newHashMap();\n        map.put(\"109.171.135.160\", 10);\n        map.put(\"109.171.135.160\", 20);\n\n        Map<String, ViolationMetaData> violators = processor.getCurrentViolators(map, config);\n\n        assertTrue(\"The map should have one violator\", violators.size() == 1);\n        assertTrue(\"The map should should contain 109.171.135.164\", violators.containsKey(\"109.171.135.160\"));\n        assertTrue(violators.get(\"109.171.135.160\").getMaxRate() == 20);\n    }", "signature": "void testThatGetCurrentViolatorsReturnsAMapOfIpAddressToMetaDataAndContainsTheHighestRate()", "full_signature": "@Test public void testThatGetCurrentViolatorsReturnsAMapOfIpAddressToMetaDataAndContainsTheHighestRate()", "class_method_signature": "RateLimitingProcessorTest.testThatGetCurrentViolatorsReturnsAMapOfIpAddressToMetaDataAndContainsTheHighestRate()", "testcase": true, "constructor": false, "invocations": ["thenReturn", "when", "getRequestPerIntervalLimit", "newHashMap", "put", "put", "getCurrentViolators", "assertTrue", "size", "assertTrue", "containsKey", "assertTrue", "getMaxRate", "get"]}, "focal_class": {"identifier": "RateLimitingProcessor", "superclass": "", "interfaces": "implements Processor", "fields": [{"original_string": "private final Logger log = Logger.getLogger(getClass());", "modifier": "private final", "type": "Logger", "declarator": "log = Logger.getLogger(getClass())", "var_name": "log"}, {"original_string": "protected static final String SERIALIZED_DATA_FILE_NAME = \"rate_limit_processor_blacklist_data.json\";", "modifier": "protected static final", "type": "String", "declarator": "SERIALIZED_DATA_FILE_NAME = \"rate_limit_processor_blacklist_data.json\"", "var_name": "SERIALIZED_DATA_FILE_NAME"}, {"original_string": "private static final int LIMIT_IP_ADDRESS_RANGES_PER_IP_MATCH_CONDITION = 1000;", "modifier": "private static final", "type": "int", "declarator": "LIMIT_IP_ADDRESS_RANGES_PER_IP_MATCH_CONDITION = 1000", "var_name": "LIMIT_IP_ADDRESS_RANGES_PER_IP_MATCH_CONDITION"}, {"original_string": "private static final String NETMASK_FOR_SINGLE_IP = \"255.255.255.255\";", "modifier": "private static final", "type": "String", "declarator": "NETMASK_FOR_SINGLE_IP = \"255.255.255.255\"", "var_name": "NETMASK_FOR_SINGLE_IP"}, {"original_string": "private final ObjectMapper objectMapper;", "modifier": "private final", "type": "ObjectMapper", "declarator": "objectMapper", "var_name": "objectMapper"}, {"original_string": "private final AWSWAFRegional awsWaf;", "modifier": "private final", "type": "AWSWAFRegional", "declarator": "awsWaf", "var_name": "awsWaf"}, {"original_string": "private final AmazonS3 amazonS3;", "modifier": "private final", "type": "AmazonS3", "declarator": "amazonS3", "var_name": "amazonS3"}, {"original_string": "private int cidrLimitForIpSet = LIMIT_IP_ADDRESS_RANGES_PER_IP_MATCH_CONDITION;", "modifier": "private", "type": "int", "declarator": "cidrLimitForIpSet = LIMIT_IP_ADDRESS_RANGES_PER_IP_MATCH_CONDITION", "var_name": "cidrLimitForIpSet"}], "methods": [{"identifier": "RateLimitingProcessor", "parameters": "(ObjectMapper objectMapper, AWSWAFRegional awsWaf, AmazonS3 amazonS3)", "modifiers": "public", "return": "", "signature": " RateLimitingProcessor(ObjectMapper objectMapper, AWSWAFRegional awsWaf, AmazonS3 amazonS3)", "full_signature": "public  RateLimitingProcessor(ObjectMapper objectMapper, AWSWAFRegional awsWaf, AmazonS3 amazonS3)", "class_method_signature": "RateLimitingProcessor.RateLimitingProcessor(ObjectMapper objectMapper, AWSWAFRegional awsWaf, AmazonS3 amazonS3)", "testcase": false, "constructor": true}, {"identifier": "setCidrLimitForIpSetOverride", "parameters": "(int limitOverride)", "modifiers": "public", "return": "void", "signature": "void setCidrLimitForIpSetOverride(int limitOverride)", "full_signature": "public void setCidrLimitForIpSetOverride(int limitOverride)", "class_method_signature": "RateLimitingProcessor.setCidrLimitForIpSetOverride(int limitOverride)", "testcase": false, "constructor": false}, {"identifier": "processLogEvents", "parameters": "(List<ALBAccessLogEvent> events, LogProcessorLambdaConfig config, String bucketName)", "modifiers": "@Override public", "return": "void", "signature": "void processLogEvents(List<ALBAccessLogEvent> events, LogProcessorLambdaConfig config, String bucketName)", "full_signature": "@Override public void processLogEvents(List<ALBAccessLogEvent> events, LogProcessorLambdaConfig config, String bucketName)", "class_method_signature": "RateLimitingProcessor.processLogEvents(List<ALBAccessLogEvent> events, LogProcessorLambdaConfig config, String bucketName)", "testcase": false, "constructor": false}, {"identifier": "logSummary", "parameters": "(Map<String, List<String>> summary, LogProcessorLambdaConfig config)", "modifiers": "protected", "return": "void", "signature": "void logSummary(Map<String, List<String>> summary, LogProcessorLambdaConfig config)", "full_signature": "protected void logSummary(Map<String, List<String>> summary, LogProcessorLambdaConfig config)", "class_method_signature": "RateLimitingProcessor.logSummary(Map<String, List<String>> summary, LogProcessorLambdaConfig config)", "testcase": false, "constructor": false}, {"identifier": "getHostnameForIp", "parameters": "(String ip)", "modifiers": "private", "return": "String", "signature": "String getHostnameForIp(String ip)", "full_signature": "private String getHostnameForIp(String ip)", "class_method_signature": "RateLimitingProcessor.getHostnameForIp(String ip)", "testcase": false, "constructor": false}, {"identifier": "getDoNotBlockRangeSet", "parameters": "(LogProcessorLambdaConfig config)", "modifiers": "protected", "return": "RangeSet<Integer>", "signature": "RangeSet<Integer> getDoNotBlockRangeSet(LogProcessorLambdaConfig config)", "full_signature": "protected RangeSet<Integer> getDoNotBlockRangeSet(LogProcessorLambdaConfig config)", "class_method_signature": "RateLimitingProcessor.getDoNotBlockRangeSet(LogProcessorLambdaConfig config)", "testcase": false, "constructor": false}, {"identifier": "filterAndTruncateViolators", "parameters": "(LogProcessorLambdaConfig params,\n                                                                        RangeSet<Integer> doNotAutoBlockIpRangeSet,\n                                                                        Map<String, ViolationMetaData> violators)", "modifiers": "protected", "return": "Map<String, ViolationMetaData>", "signature": "Map<String, ViolationMetaData> filterAndTruncateViolators(LogProcessorLambdaConfig params,\n                                                                        RangeSet<Integer> doNotAutoBlockIpRangeSet,\n                                                                        Map<String, ViolationMetaData> violators)", "full_signature": "protected Map<String, ViolationMetaData> filterAndTruncateViolators(LogProcessorLambdaConfig params,\n                                                                        RangeSet<Integer> doNotAutoBlockIpRangeSet,\n                                                                        Map<String, ViolationMetaData> violators)", "class_method_signature": "RateLimitingProcessor.filterAndTruncateViolators(LogProcessorLambdaConfig params,\n                                                                        RangeSet<Integer> doNotAutoBlockIpRangeSet,\n                                                                        Map<String, ViolationMetaData> violators)", "testcase": false, "constructor": false}, {"identifier": "processViolators", "parameters": "(LogProcessorLambdaConfig config, Map<String, ViolationMetaData> violators)", "modifiers": "protected", "return": "Map<String, List<String>>", "signature": "Map<String, List<String>> processViolators(LogProcessorLambdaConfig config, Map<String, ViolationMetaData> violators)", "full_signature": "protected Map<String, List<String>> processViolators(LogProcessorLambdaConfig config, Map<String, ViolationMetaData> violators)", "class_method_signature": "RateLimitingProcessor.processViolators(LogProcessorLambdaConfig config, Map<String, ViolationMetaData> violators)", "testcase": false, "constructor": false}, {"identifier": "getCurrentlyBlockedIpsAndDateViolatedMap", "parameters": "(String bucketName)", "modifiers": "protected", "return": "Map<String, ViolationMetaData>", "signature": "Map<String, ViolationMetaData> getCurrentlyBlockedIpsAndDateViolatedMap(String bucketName)", "full_signature": "protected Map<String, ViolationMetaData> getCurrentlyBlockedIpsAndDateViolatedMap(String bucketName)", "class_method_signature": "RateLimitingProcessor.getCurrentlyBlockedIpsAndDateViolatedMap(String bucketName)", "testcase": false, "constructor": false}, {"identifier": "saveCurrentViolators", "parameters": "(Map<String, ViolationMetaData> violators, String bucketName)", "modifiers": "protected", "return": "void", "signature": "void saveCurrentViolators(Map<String, ViolationMetaData> violators, String bucketName)", "full_signature": "protected void saveCurrentViolators(Map<String, ViolationMetaData> violators, String bucketName)", "class_method_signature": "RateLimitingProcessor.saveCurrentViolators(Map<String, ViolationMetaData> violators, String bucketName)", "testcase": false, "constructor": false}, {"identifier": "getIpSet", "parameters": "(String ipSetId, int retryCount)", "modifiers": "protected", "return": "List<SubnetUtils.SubnetInfo>", "signature": "List<SubnetUtils.SubnetInfo> getIpSet(String ipSetId, int retryCount)", "full_signature": "protected List<SubnetUtils.SubnetInfo> getIpSet(String ipSetId, int retryCount)", "class_method_signature": "RateLimitingProcessor.getIpSet(String ipSetId, int retryCount)", "testcase": false, "constructor": false}, {"identifier": "sleep", "parameters": "(int time, TimeUnit timeUnit)", "modifiers": "private", "return": "void", "signature": "void sleep(int time, TimeUnit timeUnit)", "full_signature": "private void sleep(int time, TimeUnit timeUnit)", "class_method_signature": "RateLimitingProcessor.sleep(int time, TimeUnit timeUnit)", "testcase": false, "constructor": false}, {"identifier": "processRequest", "parameters": "(ALBAccessLogEvent event, Map<String, Integer> reqIdCountMap)", "modifiers": "protected", "return": "void", "signature": "void processRequest(ALBAccessLogEvent event, Map<String, Integer> reqIdCountMap)", "full_signature": "protected void processRequest(ALBAccessLogEvent event, Map<String, Integer> reqIdCountMap)", "class_method_signature": "RateLimitingProcessor.processRequest(ALBAccessLogEvent event, Map<String, Integer> reqIdCountMap)", "testcase": false, "constructor": false}, {"identifier": "getCurrentViolators", "parameters": "(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "modifiers": "protected", "return": "Map<String, ViolationMetaData>", "signature": "Map<String, ViolationMetaData> getCurrentViolators(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "full_signature": "protected Map<String, ViolationMetaData> getCurrentViolators(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "class_method_signature": "RateLimitingProcessor.getCurrentViolators(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "testcase": false, "constructor": false}, {"identifier": "canAddToAutoBlackList", "parameters": "(RangeSet<Integer> doNotAutoBlockIpRangeSet, String ipFromAccessLog)", "modifiers": "protected", "return": "boolean", "signature": "boolean canAddToAutoBlackList(RangeSet<Integer> doNotAutoBlockIpRangeSet, String ipFromAccessLog)", "full_signature": "protected boolean canAddToAutoBlackList(RangeSet<Integer> doNotAutoBlockIpRangeSet, String ipFromAccessLog)", "class_method_signature": "RateLimitingProcessor.canAddToAutoBlackList(RangeSet<Integer> doNotAutoBlockIpRangeSet, String ipFromAccessLog)", "testcase": false, "constructor": false}], "file": "cerberus-log-processor-lambda/src/main/java/com/nike/cerberus/lambda/waf/processor/RateLimitingProcessor.java"}, "focal_method": {"identifier": "getCurrentViolators", "parameters": "(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "modifiers": "protected", "return": "Map<String, ViolationMetaData>", "body": "protected Map<String, ViolationMetaData> getCurrentViolators(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params) {\n        Date now = new Date();\n        Map<String, ViolationMetaData> violators = Maps.newHashMap();\n\n        // instead of using minute of hour as part of the key, assume that only the logs within the last interval is provided\n        reqIdCountMap.entrySet().stream()\n                .filter(entry -> entry.getValue() > params.getRequestPerIntervalLimit())\n                .forEach(entry -> {\n                    String ip = entry.getKey();\n                    if (violators.containsKey(ip)) {\n                        ViolationMetaData metaData = violators.get(ip);\n                        if (metaData.getMaxRate() < entry.getValue()) {\n                            metaData.setMaxRate(entry.getValue());\n                        }\n                    } else {\n                        violators.put(ip, new ViolationMetaData(now, entry.getValue()));\n                    }\n                });\n\n        return violators;\n    }", "signature": "Map<String, ViolationMetaData> getCurrentViolators(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "full_signature": "protected Map<String, ViolationMetaData> getCurrentViolators(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "class_method_signature": "RateLimitingProcessor.getCurrentViolators(Map<String, Integer> reqIdCountMap, LogProcessorLambdaConfig params)", "testcase": false, "constructor": false, "invocations": ["newHashMap", "forEach", "filter", "stream", "entrySet", "getValue", "getRequestPerIntervalLimit", "getKey", "containsKey", "get", "getMaxRate", "getValue", "setMaxRate", "getValue", "put", "getValue"]}, "repository": {"repo_id": 70515197, "url": "https://github.com/Nike-Inc/cerberus-serverless-components", "language": "Java", "is_fork": false, "fork_count": 5, "stargazer_count": 12, "size": 269, "license": "licensed"}}