{"test_class": {"identifier": "ImagePoolImplTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ImagePoolImpl myPool;", "modifier": "private", "type": "ImagePoolImpl", "declarator": "myPool", "var_name": "myPool"}], "file": "android/testSrc/com/android/tools/idea/rendering/imagepool/ImagePoolImplTest.java"}, "test_case": {"identifier": "testImagePooling", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testImagePooling() throws InterruptedException, IOException {\n    CountDownLatch countDown1 = new CountDownLatch(1);\n    CountDownLatch countDown2 = new CountDownLatch(1);\n    AtomicBoolean secondImageFreed = new AtomicBoolean(false);\n\n    ImagePoolImpl.ImageImpl image1 = myPool.create(50, 50, BufferedImage.TYPE_INT_ARGB, (image) -> countDown1.countDown());\n    image1.drawFrom(getSampleImage());\n    BufferedImage internalPtr = image1.myBuffer;\n    ImagePoolImpl.ImageImpl image2 = myPool.create(50, 50, BufferedImage.TYPE_INT_ARGB, (image) -> {\n      countDown2.countDown();\n      secondImageFreed.set(true);\n    });\n    assertNotEquals(image1.myBuffer, image2.myBuffer);\n\n    //noinspection UnusedAssignment\n    image1 = null;\n    gc();\n\n    // Wait for the image to be collected\n    countDown1.await(3, TimeUnit.SECONDS);\n    image1 = myPool.create(50, 50, BufferedImage.TYPE_INT_ARGB, null);\n    assertEquals(image1.myBuffer, internalPtr);\n    assertFalse(secondImageFreed.get());\n    // The image is being reused. Check that it's a clean image\n    ImageDiffUtil\n      .assertImageSimilar(\"clean\", new BufferedImage(50, 50, BufferedImage.TYPE_INT_ARGB), image1.myBuffer.getSubimage(0, 0, 50, 50), 0.0);\n\n    //noinspection UnusedAssignment\n    image2 = null;\n    gc();\n    countDown2.await(3, TimeUnit.SECONDS);\n\n    ImagePoolImpl.ImageImpl tmpImage = myPool.create(50, 50, BufferedImage.TYPE_INT_ARGB_PRE, null);\n    assertEquals(50, tmpImage.getWidth());\n    assertEquals(50, tmpImage.getHeight());\n    assertEquals(BufferedImage.TYPE_INT_ARGB_PRE, tmpImage.myBuffer.getType());\n\n    tmpImage = myPool.create(51, 50, BufferedImage.TYPE_INT_ARGB, null);\n    assertEquals(51, tmpImage.getWidth());\n    assertEquals(50, tmpImage.getHeight());\n    assertEquals(BufferedImage.TYPE_INT_ARGB, tmpImage.myBuffer.getType());\n\n    tmpImage = myPool.create(50, 51, BufferedImage.TYPE_INT_ARGB, null);\n    assertEquals(50, tmpImage.getWidth());\n    assertEquals(51, tmpImage.getHeight());\n    assertEquals(BufferedImage.TYPE_INT_ARGB, tmpImage.myBuffer.getType());\n\n    //noinspection UnusedAssignment\n    tmpImage = null;\n    gc();\n  }", "signature": "void testImagePooling()", "full_signature": "@Test public void testImagePooling()", "class_method_signature": "ImagePoolImplTest.testImagePooling()", "testcase": true, "constructor": false, "invocations": ["create", "countDown", "drawFrom", "getSampleImage", "create", "countDown", "set", "assertNotEquals", "gc", "await", "create", "assertEquals", "assertFalse", "get", "assertImageSimilar", "getSubimage", "gc", "await", "create", "assertEquals", "getWidth", "assertEquals", "getHeight", "assertEquals", "getType", "create", "assertEquals", "getWidth", "assertEquals", "getHeight", "assertEquals", "getType", "create", "assertEquals", "getWidth", "assertEquals", "getHeight", "assertEquals", "getType", "gc"]}, "focal_class": {"identifier": "ImagePoolImpl", "superclass": "", "interfaces": "implements ImagePool", "fields": [{"original_string": "private static final Logger LOG = Logger.getInstance(ImagePoolImpl.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = Logger.getInstance(ImagePoolImpl.class)", "var_name": "LOG"}, {"original_string": "private static final Bucket NULL_BUCKET = new Bucket(0, 0, 0);", "modifier": "private static final", "type": "Bucket", "declarator": "NULL_BUCKET = new Bucket(0, 0, 0)", "var_name": "NULL_BUCKET"}, {"original_string": "private final int[] myBucketSizes;", "modifier": "private final", "type": "int[]", "declarator": "myBucketSizes", "var_name": "myBucketSizes"}, {"original_string": "private final HashMap<String, Bucket> myPool = new HashMap<>();", "modifier": "private final", "type": "HashMap<String, Bucket>", "declarator": "myPool = new HashMap<>()", "var_name": "myPool"}, {"original_string": "private final IdentityHashMap<Bucket, BucketStatsImpl> myBucketStats = new IdentityHashMap<>();", "modifier": "private final", "type": "IdentityHashMap<Bucket, BucketStatsImpl>", "declarator": "myBucketStats = new IdentityHashMap<>()", "var_name": "myBucketStats"}, {"original_string": "private final BiFunction<Integer, Integer, Function<Integer, Integer>> myBucketSizingPolicy;", "modifier": "private final", "type": "BiFunction<Integer, Integer, Function<Integer, Integer>>", "declarator": "myBucketSizingPolicy", "var_name": "myBucketSizingPolicy"}, {"original_string": "@SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n  private final FinalizableReferenceQueue myFinalizableReferenceQueue = new FinalizableReferenceQueue();", "modifier": "@SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n  private final", "type": "FinalizableReferenceQueue", "declarator": "myFinalizableReferenceQueue = new FinalizableReferenceQueue()", "var_name": "myFinalizableReferenceQueue"}, {"original_string": "private final Set<Reference<?>> myReferences = Sets.newConcurrentHashSet();", "modifier": "private final", "type": "Set<Reference<?>>", "declarator": "myReferences = Sets.newConcurrentHashSet()", "var_name": "myReferences"}, {"original_string": "private final LongAdder myTotalAllocatedBytes = new LongAdder();", "modifier": "private final", "type": "LongAdder", "declarator": "myTotalAllocatedBytes = new LongAdder()", "var_name": "myTotalAllocatedBytes"}, {"original_string": "private final LongAdder myTotalInUseBytes = new LongAdder();", "modifier": "private final", "type": "LongAdder", "declarator": "myTotalInUseBytes = new LongAdder()", "var_name": "myTotalInUseBytes"}, {"original_string": "private final Stats myStats = new Stats() {\n    @Override\n    public long totalBytesAllocated() {\n      return myTotalAllocatedBytes.sum();\n    }\n\n    @Override\n    public long totalBytesInUse() {\n      return myTotalInUseBytes.sum();\n    }\n\n    @Override\n    public BucketStats[] getBucketStats() {\n      return myBucketStats.values().stream()\n        .toArray(BucketStats[]::new);\n    }\n  };", "modifier": "private final", "type": "Stats", "declarator": "myStats = new Stats() {\n    @Override\n    public long totalBytesAllocated() {\n      return myTotalAllocatedBytes.sum();\n    }\n\n    @Override\n    public long totalBytesInUse() {\n      return myTotalInUseBytes.sum();\n    }\n\n    @Override\n    public BucketStats[] getBucketStats() {\n      return myBucketStats.values().stream()\n        .toArray(BucketStats[]::new);\n    }\n  }", "var_name": "myStats"}, {"original_string": "private boolean isDisposed = false;", "modifier": "private", "type": "boolean", "declarator": "isDisposed = false", "var_name": "isDisposed"}], "methods": [{"identifier": "ImagePoolImpl", "parameters": "(@NotNull int[] bucketSizes, @NotNull BiFunction<Integer, Integer, Function<Integer, Integer>> bucketSizingPolicy)", "modifiers": "", "return": "", "signature": " ImagePoolImpl(@NotNull int[] bucketSizes, @NotNull BiFunction<Integer, Integer, Function<Integer, Integer>> bucketSizingPolicy)", "full_signature": "  ImagePoolImpl(@NotNull int[] bucketSizes, @NotNull BiFunction<Integer, Integer, Function<Integer, Integer>> bucketSizingPolicy)", "class_method_signature": "ImagePoolImpl.ImagePoolImpl(@NotNull int[] bucketSizes, @NotNull BiFunction<Integer, Integer, Function<Integer, Integer>> bucketSizingPolicy)", "testcase": false, "constructor": true}, {"identifier": "getPoolKey", "parameters": "(int w, int h, int type)", "modifiers": "@NotNull private static", "return": "String", "signature": "String getPoolKey(int w, int h, int type)", "full_signature": "@NotNull private static String getPoolKey(int w, int h, int type)", "class_method_signature": "ImagePoolImpl.getPoolKey(int w, int h, int type)", "testcase": false, "constructor": false}, {"identifier": "getTypeBucket", "parameters": "(int w, int h, int type)", "modifiers": "@NotNull private", "return": "Bucket", "signature": "Bucket getTypeBucket(int w, int h, int type)", "full_signature": "@NotNull private Bucket getTypeBucket(int w, int h, int type)", "class_method_signature": "ImagePoolImpl.getTypeBucket(int w, int h, int type)", "testcase": false, "constructor": false}, {"identifier": "create", "parameters": "(final int w, final int h, final int type, @Nullable Consumer<BufferedImage> freedCallback)", "modifiers": "@VisibleForTesting @NotNull", "return": "ImageImpl", "signature": "ImageImpl create(final int w, final int h, final int type, @Nullable Consumer<BufferedImage> freedCallback)", "full_signature": "@VisibleForTesting @NotNull ImageImpl create(final int w, final int h, final int type, @Nullable Consumer<BufferedImage> freedCallback)", "class_method_signature": "ImagePoolImpl.create(final int w, final int h, final int type, @Nullable Consumer<BufferedImage> freedCallback)", "testcase": false, "constructor": false}, {"identifier": "create", "parameters": "(final int w, final int h, final int type)", "modifiers": "@NotNull public", "return": "ImagePool.Image", "signature": "ImagePool.Image create(final int w, final int h, final int type)", "full_signature": "@NotNull public ImagePool.Image create(final int w, final int h, final int type)", "class_method_signature": "ImagePoolImpl.create(final int w, final int h, final int type)", "testcase": false, "constructor": false}, {"identifier": "copyOf", "parameters": "(@Nullable BufferedImage origin)", "modifiers": "@NotNull public", "return": "ImagePool.Image", "signature": "ImagePool.Image copyOf(@Nullable BufferedImage origin)", "full_signature": "@NotNull public ImagePool.Image copyOf(@Nullable BufferedImage origin)", "class_method_signature": "ImagePoolImpl.copyOf(@Nullable BufferedImage origin)", "testcase": false, "constructor": false}, {"identifier": "getStats", "parameters": "()", "modifiers": "@Nullable @Override public", "return": "Stats", "signature": "Stats getStats()", "full_signature": "@Nullable @Override public Stats getStats()", "class_method_signature": "ImagePoolImpl.getStats()", "testcase": false, "constructor": false}, {"identifier": "dispose", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void dispose()", "full_signature": "public void dispose()", "class_method_signature": "ImagePoolImpl.dispose()", "testcase": false, "constructor": false}], "file": "android/src/com/android/tools/idea/rendering/imagepool/ImagePoolImpl.java"}, "focal_method": {"identifier": "create", "parameters": "(final int w, final int h, final int type, @Nullable Consumer<BufferedImage> freedCallback)", "modifiers": "@VisibleForTesting @NotNull", "return": "ImageImpl", "body": "@VisibleForTesting\n  @NotNull\n  ImageImpl create(final int w, final int h, final int type, @Nullable Consumer<BufferedImage> freedCallback) {\n    assert !isDisposed : \"ImagePool already disposed\";\n\n    // To avoid creating a large number of EvictingQueues, we distribute the images in buckets and use that\n    Bucket bucket = getTypeBucket(w, h, type);\n    BucketStatsImpl bucketStats = myBucketStats.get(bucket);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(String.format(\"create(%dx%d-%d) in bucket (%dx%d) hasStats=%b\\n\", w, h, type, bucket.myMinWidth, bucket.myMinHeight,\n                              bucketStats != null));\n    }\n\n    BufferedImage image;\n    SoftReference<BufferedImage> imageRef;\n    try {\n      imageRef = bucket.remove();\n      while ((image = imageRef.get()) == null) {\n        imageRef = bucket.remove();\n      }\n\n      long totalSize = image.getWidth() * image.getHeight();\n      if (bucketStats != null) {\n        bucketStats.bucketHit();\n      }\n      if (LOG.isDebugEnabled()) {\n        double wasted = (totalSize - w * h);\n        LOG.debug(String.format(\"  Re-used image %dx%d - %d\\n  pool buffer %dx%d\\n  wasted %d%%\\n\",\n                                w, h, type,\n                                image.getWidth(), image.getHeight(),\n                                (int)((wasted / totalSize) * 100)));\n      }\n      myTotalInUseBytes.add(totalSize * 4);\n      // Clear the image\n      if (image.getRaster().getDataBuffer().getDataType() == java.awt.image.DataBuffer.TYPE_INT) {\n        Arrays.fill(((DataBufferInt)image.getRaster().getDataBuffer()).getData(), 0);\n      }\n      else {\n        Graphics2D g = image.createGraphics();\n        g.setComposite(AlphaComposite.Clear);\n        g.fillRect(0, 0, w, h);\n        g.dispose();\n      }\n    }\n    catch (NoSuchElementException e) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(String.format(\"  New image %dx%d - %d\\n\", w, h, type));\n      }\n      if (bucketStats != null) {\n        bucketStats.bucketMiss();\n      }\n      int newImageWidth = Math.max(bucket.myMinWidth, w);\n      int newImageHeight = Math.max(bucket.myMinHeight, h);\n      //noinspection UndesirableClassUsage\n      image = new BufferedImage(newImageWidth, newImageHeight, type);\n      // Set acceleration priority to 0.9 out of 1.0. We reserve 1.0 for the shared buffers\n      // that we paint to screen.\n      image.setAccelerationPriority(0.9f);\n      long estimatedSize = newImageWidth * newImageHeight * 4;\n      myTotalAllocatedBytes.add(estimatedSize);\n      myTotalInUseBytes.add(estimatedSize);\n\n    }\n\n    ImageImpl pooledImage = new ImageImpl(w, h, image);\n    final BufferedImage imagePointer = image;\n    FinalizablePhantomReference<ImagePool.Image> reference =\n      new FinalizablePhantomReference<ImagePool.Image>(pooledImage, myFinalizableReferenceQueue) {\n      @Override\n      public void finalizeReferent() {\n        // This method might be called twice if the user has manually called the free() method. The second call will have no effect.\n        if (myReferences.remove(this)) {\n          boolean accepted = bucket.offer(new SoftReference<>(imagePointer));\n          if (bucketStats != null) {\n            if (accepted) {\n              bucketStats.returnedImageAccepted();\n            }\n            else {\n              bucketStats.returnedImageRejected();\n            }\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"%s image (%dx%d-%d) in bucket (%dx%d)\\n\",\n                                    accepted ? \"Released\" : \"Rejected\",\n                                    w, h, type, bucket.myMinWidth, bucket.myMinHeight));\n          }\n\n          long estimatedSize = imagePointer.getWidth() * imagePointer.getHeight() * 4;\n          if (!accepted) {\n            myTotalAllocatedBytes.add(-estimatedSize);\n          }\n          else {\n            myTotalInUseBytes.add(-estimatedSize);\n          }\n          if (freedCallback != null) {\n            freedCallback.accept(imagePointer);\n          }\n        }\n      }\n    };\n    pooledImage.myOwnReference = reference;\n    myReferences.add(reference);\n\n    return pooledImage;\n  }", "signature": "ImageImpl create(final int w, final int h, final int type, @Nullable Consumer<BufferedImage> freedCallback)", "full_signature": "@VisibleForTesting @NotNull ImageImpl create(final int w, final int h, final int type, @Nullable Consumer<BufferedImage> freedCallback)", "class_method_signature": "ImagePoolImpl.create(final int w, final int h, final int type, @Nullable Consumer<BufferedImage> freedCallback)", "testcase": false, "constructor": false, "invocations": ["getTypeBucket", "get", "isDebugEnabled", "debug", "format", "remove", "get", "remove", "getWidth", "getHeight", "bucketHit", "isDebugEnabled", "debug", "format", "getWidth", "getHeight", "add", "getDataType", "getDataBuffer", "getRaster", "fill", "getData", "getDataBuffer", "getRaster", "createGraphics", "setComposite", "fillRect", "dispose", "isDebugEnabled", "debug", "format", "bucketMiss", "max", "max", "setAccelerationPriority", "add", "add", "remove", "offer", "returnedImageAccepted", "returnedImageRejected", "isDebugEnabled", "debug", "format", "getWidth", "getHeight", "add", "add", "accept", "add"]}, "repository": {"repo_id": 60701247, "url": "https://github.com/JetBrains/android", "stars": 486, "created": "6/8/2016 1:46:48 PM +00:00", "updates": "2020-01-27T16:45:40+00:00", "fork": "False", "license": "licensed"}}