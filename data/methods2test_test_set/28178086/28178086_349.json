{"test_class": {"identifier": "GammaTest", "superclass": "", "interfaces": "", "fields": [], "file": "jtstoolkit/src/test/java/ec/tstoolkit/dstats/GammaTest.java"}, "test_case": {"identifier": "testRandom", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRandom() {\n        double s = 0;\n        double ssq=0;\n        int N = 1000000;\n        long t0 = System.currentTimeMillis();\n        Gamma dist = new Gamma(7.48, 0.295);\n        MersenneTwister rng = new MersenneTwister(0);\n        for (int i = 0; i < N; ++i) {\n            double r=dist.random(rng);\n            s += r;\n            ssq+=r*r;\n        }\n        long t1 = System.currentTimeMillis();\n        assertEquals(dist.getExpectation(), s / N, .01);\n        assertEquals(dist.getVariance(), ssq / N-s/N*s/N, .01);\n//        System.out.println(\"New\");\n//        System.out.println(t1 - t0);\n//        System.out.println(s / N);\n//        System.out.println(ssq / N-s/N*s/N);\n//        System.out.println(dist.getExpectation());\n//        System.out.println(dist.getVariance());\n    }", "signature": "void testRandom()", "full_signature": "@Test public void testRandom()", "class_method_signature": "GammaTest.testRandom()", "testcase": true, "constructor": false, "invocations": ["currentTimeMillis", "random", "currentTimeMillis", "assertEquals", "getExpectation", "assertEquals", "getVariance"]}, "focal_class": {"identifier": "Gamma", "superclass": "", "interfaces": "implements IContinuousDistribution", "fields": [{"original_string": "public static final double MAXGAM = 171.624376956302725;", "modifier": "public static final", "type": "double", "declarator": "MAXGAM = 171.624376956302725", "var_name": "MAXGAM"}, {"original_string": "private final double alpha, beta;", "modifier": "private final", "type": "double", "declarator": "alpha", "var_name": "alpha"}, {"original_string": "private static final double MAXSTIR = 143.01608;", "modifier": "private static final", "type": "double", "declarator": "MAXSTIR = 143.01608", "var_name": "MAXSTIR"}], "methods": [{"identifier": "Gamma", "parameters": "(double alpha, double beta)", "modifiers": "public", "return": "", "signature": " Gamma(double alpha, double beta)", "full_signature": "public  Gamma(double alpha, double beta)", "class_method_signature": "Gamma.Gamma(double alpha, double beta)", "testcase": false, "constructor": true}, {"identifier": "getDensity", "parameters": "(double x)", "modifiers": "@Override public", "return": "double", "signature": "double getDensity(double x)", "full_signature": "@Override public double getDensity(double x)", "class_method_signature": "Gamma.getDensity(double x)", "testcase": false, "constructor": false}, {"identifier": "getShape", "parameters": "()", "modifiers": "public", "return": "double", "signature": "double getShape()", "full_signature": "public double getShape()", "class_method_signature": "Gamma.getShape()", "testcase": false, "constructor": false}, {"identifier": "getScale", "parameters": "()", "modifiers": "public", "return": "double", "signature": "double getScale()", "full_signature": "public double getScale()", "class_method_signature": "Gamma.getScale()", "testcase": false, "constructor": false}, {"identifier": "getLeftBound", "parameters": "()", "modifiers": "@Override public", "return": "double", "signature": "double getLeftBound()", "full_signature": "@Override public double getLeftBound()", "class_method_signature": "Gamma.getLeftBound()", "testcase": false, "constructor": false}, {"identifier": "getRightBound", "parameters": "()", "modifiers": "@Override public", "return": "double", "signature": "double getRightBound()", "full_signature": "@Override public double getRightBound()", "class_method_signature": "Gamma.getRightBound()", "testcase": false, "constructor": false}, {"identifier": "getDescription", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getDescription()", "full_signature": "@Override public String getDescription()", "class_method_signature": "Gamma.getDescription()", "testcase": false, "constructor": false}, {"identifier": "getExpectation", "parameters": "()", "modifiers": "@Override public", "return": "double", "signature": "double getExpectation()", "full_signature": "@Override public double getExpectation()", "class_method_signature": "Gamma.getExpectation()", "testcase": false, "constructor": false}, {"identifier": "getProbability", "parameters": "(double x, ProbabilityType pt)", "modifiers": "@Override public", "return": "double", "signature": "double getProbability(double x, ProbabilityType pt)", "full_signature": "@Override public double getProbability(double x, ProbabilityType pt)", "class_method_signature": "Gamma.getProbability(double x, ProbabilityType pt)", "testcase": false, "constructor": false}, {"identifier": "getProbabilityInverse", "parameters": "(double p, ProbabilityType pt)", "modifiers": "@Override public", "return": "double", "signature": "double getProbabilityInverse(double p, ProbabilityType pt)", "full_signature": "@Override public double getProbabilityInverse(double p, ProbabilityType pt)", "class_method_signature": "Gamma.getProbabilityInverse(double p, ProbabilityType pt)", "testcase": false, "constructor": false}, {"identifier": "getVariance", "parameters": "()", "modifiers": "@Override public", "return": "double", "signature": "double getVariance()", "full_signature": "@Override public double getVariance()", "class_method_signature": "Gamma.getVariance()", "testcase": false, "constructor": false}, {"identifier": "hasLeftBound", "parameters": "()", "modifiers": "@Override public", "return": "BoundaryType", "signature": "BoundaryType hasLeftBound()", "full_signature": "@Override public BoundaryType hasLeftBound()", "class_method_signature": "Gamma.hasLeftBound()", "testcase": false, "constructor": false}, {"identifier": "hasRightBound", "parameters": "()", "modifiers": "@Override public", "return": "BoundaryType", "signature": "BoundaryType hasRightBound()", "full_signature": "@Override public BoundaryType hasRightBound()", "class_method_signature": "Gamma.hasRightBound()", "testcase": false, "constructor": false}, {"identifier": "isSymmetrical", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isSymmetrical()", "full_signature": "@Override public boolean isSymmetrical()", "class_method_signature": "Gamma.isSymmetrical()", "testcase": false, "constructor": false}, {"identifier": "random", "parameters": "(IRandomNumberGenerator rng)", "modifiers": "@Override public", "return": "double", "signature": "double random(IRandomNumberGenerator rng)", "full_signature": "@Override public double random(IRandomNumberGenerator rng)", "class_method_signature": "Gamma.random(IRandomNumberGenerator rng)", "testcase": false, "constructor": false}, {"identifier": "beta", "parameters": "(double a, double b)", "modifiers": "public static", "return": "double", "signature": "double beta(double a, double b)", "full_signature": "public static double beta(double a, double b)", "class_method_signature": "Gamma.beta(double a, double b)", "testcase": false, "constructor": false}, {"identifier": "gamma", "parameters": "(double x)", "modifiers": "public static", "return": "double", "signature": "double gamma(double x)", "full_signature": "public static double gamma(double x)", "class_method_signature": "Gamma.gamma(double x)", "testcase": false, "constructor": false}, {"identifier": "incompleteBeta", "parameters": "(double aa, double bb, double xx)", "modifiers": "public static", "return": "double", "signature": "double incompleteBeta(double aa, double bb, double xx)", "full_signature": "public static double incompleteBeta(double aa, double bb, double xx)", "class_method_signature": "Gamma.incompleteBeta(double aa, double bb, double xx)", "testcase": false, "constructor": false}, {"identifier": "incompleteBetaFraction1", "parameters": "(double a, double b, double x)", "modifiers": "public static", "return": "double", "signature": "double incompleteBetaFraction1(double a, double b, double x)", "full_signature": "public static double incompleteBetaFraction1(double a, double b, double x)", "class_method_signature": "Gamma.incompleteBetaFraction1(double a, double b, double x)", "testcase": false, "constructor": false}, {"identifier": "incompleteBetaFraction2", "parameters": "(double a, double b, double x)", "modifiers": "static", "return": "double", "signature": "double incompleteBetaFraction2(double a, double b, double x)", "full_signature": "static double incompleteBetaFraction2(double a, double b, double x)", "class_method_signature": "Gamma.incompleteBetaFraction2(double a, double b, double x)", "testcase": false, "constructor": false}, {"identifier": "incompleteGamma", "parameters": "(double a, double x)", "modifiers": "public static", "return": "double", "signature": "double incompleteGamma(double a, double x)", "full_signature": "public static double incompleteGamma(double a, double x)", "class_method_signature": "Gamma.incompleteGamma(double a, double x)", "testcase": false, "constructor": false}, {"identifier": "incompleteGammaComplement", "parameters": "(double a, double x)", "modifiers": "public static", "return": "double", "signature": "double incompleteGammaComplement(double a, double x)", "full_signature": "public static double incompleteGammaComplement(double a, double x)", "class_method_signature": "Gamma.incompleteGammaComplement(double a, double x)", "testcase": false, "constructor": false}, {"identifier": "logGamma", "parameters": "(double x)", "modifiers": "public static", "return": "double", "signature": "double logGamma(double x)", "full_signature": "public static double logGamma(double x)", "class_method_signature": "Gamma.logGamma(double x)", "testcase": false, "constructor": false}, {"identifier": "powerSeries", "parameters": "(double a, double b, double x)", "modifiers": "static", "return": "double", "signature": "double powerSeries(double a, double b, double x)", "full_signature": "static double powerSeries(double a, double b, double x)", "class_method_signature": "Gamma.powerSeries(double a, double b, double x)", "testcase": false, "constructor": false}, {"identifier": "stirlingFormula", "parameters": "(double x)", "modifiers": "static", "return": "double", "signature": "double stirlingFormula(double x)", "full_signature": "static double stirlingFormula(double x)", "class_method_signature": "Gamma.stirlingFormula(double x)", "testcase": false, "constructor": false}], "file": "jtstoolkit/src/main/java/ec/tstoolkit/dstats/Gamma.java"}, "focal_method": {"identifier": "random", "parameters": "(IRandomNumberGenerator rng)", "modifiers": "@Override public", "return": "double", "body": "@Override\n    public double random(IRandomNumberGenerator rng) throws DStatException {\n        double a = alpha;\n        double aa = -1.0, aaa = -1.0,\n                b = 0.0, c = 0.0, d = 0.0, e, r, s = 0.0, si = 0.0, ss = 0.0, q0 = 0.0,\n                q1 = 0.0416666664, q2 = 0.0208333723, q3 = 0.0079849875,\n                q4 = 0.0015746717, q5 = -0.0003349403, q6 = 0.0003340332,\n                q7 = 0.0006053049, q8 = -0.0004701849, q9 = 0.0001710320,\n                a1 = 0.333333333, a2 = -0.249999949, a3 = 0.199999867,\n                a4 = -0.166677482, a5 = 0.142873973, a6 = -0.124385581,\n                a7 = 0.110368310, a8 = -0.112750886, a9 = 0.104089866,\n                e1 = 1.000000000, e2 = 0.499999994, e3 = 0.166666848,\n                e4 = 0.041664508, e5 = 0.008345522, e6 = 0.001353826,\n                e7 = 0.000247453;\n\n        double gds, p, q, t, sign_u, u, v, w, x;\n        double v1, v2, v12;\n\n        if (a < 1.0) { // CASE A: Acceptance rejection algorithm gs\n            b = 1.0 + 0.36788794412 * a;              // Step 1\n            while (true) {\n                p = b * rng.nextDouble();\n                if (p <= 1.0) {                       // Step 2. Case gds <= 1\n                    gds = Math.exp(Math.log(p) / a);\n                    if (Math.log(rng.nextDouble()) <= -gds) {\n                        return (gds * beta);\n                    }\n                } else {                                // Step 3. Case gds > 1\n                    gds = -Math.log((b - p) / a);\n                    if (Math.log(rng.nextDouble()) <= ((a - 1.0) * Math.log(gds))) {\n                        return (gds * beta);\n                    }\n                }\n            }\n        } else {        // CASE B: Acceptance complement algorithm gd (gaussian distribution, box muller transformation)\n            if (a != aa) {                        // Step 1. Preparations\n                ss = a - 0.5;\n                s = Math.sqrt(ss);\n                d = 5.656854249 - 12.0 * s;\n            }\n            // Step 2. Normal deviate\n            do {\n                v1 = 2.0 * rng.nextDouble() - 1.0;\n                v2 = 2.0 * rng.nextDouble() - 1.0;\n                v12 = v1 * v1 + v2 * v2;\n            } while (v12 > 1.0);\n            t = v1 * Math.sqrt(-2.0 * Math.log(v12) / v12);\n            x = s + 0.5 * t;\n            gds = x * x;\n            if (t >= 0.0) {\n                return (gds * beta);         // Immediate acceptance\n            }\n            u = rng.nextDouble();                // Step 3. Uniform random number\n            if (d * u <= t * t * t) {\n                return (gds * beta); // Squeeze acceptance\n            }\n            if (a != aaa) {                           // Step 4. Set-up for hat case\n                r = 1.0 / a;\n                q0 = ((((((((q9 * r + q8) * r + q7) * r + q6) * r + q5) * r + q4)\n                        * r + q3) * r + q2) * r + q1) * r;\n                if (a > 3.686) {\n                    if (a > 13.022) {\n                        b = 1.77;\n                        si = 0.75;\n                        c = 0.1515 / s;\n                    } else {\n                        b = 1.654 + 0.0076 * ss;\n                        si = 1.68 / s + 0.275;\n                        c = 0.062 / s + 0.024;\n                    }\n                } else {\n                    b = 0.463 + s - 0.178 * ss;\n                    si = 1.235;\n                    c = 0.195 / s - 0.079 + 0.016 * s;\n                }\n            }\n            if (x > 0.0) {                        // Step 5. Calculation of q\n                v = t / (s + s);                  // Step 6.\n                if (Math.abs(v) > 0.25) {\n                    q = q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n                } else {\n                    q = q0 + 0.5 * t * t * ((((((((a9 * v + a8) * v + a7) * v + a6)\n                            * v + a5) * v + a4) * v + a3) * v + a2) * v + a1) * v;\n                }\t\t\t\t\t\t\t\t  // Step 7. Quotient acceptance\n                if (Math.log(1.0 - u) <= q) {\n                    return (gds * beta);\n                }\n            }\n\n            while (true) {              \t\t\t      // Step 8. Double exponential deviate t\n                do {\n                    e = -Math.log(rng.nextDouble());\n                    u = rng.nextDouble();\n                    u = u + u - 1.0;\n                    sign_u = (u > 0) ? 1.0 : -1.0;\n                    t = b + (e * si) * sign_u;\n                } while (t <= -0.71874483771719); // Step 9. Rejection of t\n                v = t / (s + s);                  // Step 10. New q(t)\n                if (Math.abs(v) > 0.25) {\n                    q = q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n                } else {\n                    q = q0 + 0.5 * t * t * ((((((((a9 * v + a8) * v + a7) * v + a6)\n                            * v + a5) * v + a4) * v + a3) * v + a2) * v + a1) * v;\n                }\n                if (q <= 0.0) {\n                    continue;           // Step 11.\n                }\n                if (q > 0.5) {\n                    w = Math.exp(q) - 1.0;\n                } else {\n                    w = ((((((e7 * q + e6) * q + e5) * q + e4) * q + e3) * q + e2)\n                            * q + e1) * q;\n                }                    \t\t\t  // Step 12. Hat acceptance\n                if (c * u * sign_u <= w * Math.exp(e - 0.5 * t * t)) {\n                    x = s + 0.5 * t;\n                    return (x * x * beta);\n                }\n            }\n        }\n    }", "signature": "double random(IRandomNumberGenerator rng)", "full_signature": "@Override public double random(IRandomNumberGenerator rng)", "class_method_signature": "Gamma.random(IRandomNumberGenerator rng)", "testcase": false, "constructor": false, "invocations": ["nextDouble", "exp", "log", "log", "nextDouble", "log", "log", "nextDouble", "log", "sqrt", "nextDouble", "nextDouble", "sqrt", "log", "nextDouble", "abs", "log", "log", "log", "nextDouble", "nextDouble", "abs", "log", "exp", "exp"]}, "repository": {"repo_id": 28178086, "url": "https://github.com/jdemetra/jdemetra-core", "stars": 24, "created": "12/18/2014 10:00:58 AM +00:00", "updates": "2020-01-17T15:50:24+00:00", "fork": "False", "license": "licensed"}}