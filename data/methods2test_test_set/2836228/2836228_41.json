{"test_class": {"identifier": "UpdateHelperTest", "superclass": "extends AbstractTestBase", "interfaces": "", "fields": [{"original_string": "private final FeedEntityParser parser = (FeedEntityParser)\n            EntityParserFactory.getParser(EntityType.FEED);", "modifier": "private final", "type": "FeedEntityParser", "declarator": "parser = (FeedEntityParser)\n            EntityParserFactory.getParser(EntityType.FEED)", "var_name": "parser"}, {"original_string": "private final ProcessEntityParser processParser = (ProcessEntityParser)\n            EntityParserFactory.getParser(EntityType.PROCESS);", "modifier": "private final", "type": "ProcessEntityParser", "declarator": "processParser = (ProcessEntityParser)\n            EntityParserFactory.getParser(EntityType.PROCESS)", "var_name": "processParser"}], "file": "common/src/test/java/org/apache/ivory/update/UpdateHelperTest.java"}, "test_case": {"identifier": "testShouldUpdate", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testShouldUpdate() throws Exception {\n        Feed oldFeed = parser.parseAndValidate(this.getClass()\n                .getResourceAsStream(FEED_XML));\n\n        Feed newFeed = (Feed)oldFeed.clone();\n        Process process = processParser.parseAndValidate(this.getClass().\n                getResourceAsStream(PROCESS_XML));\n\n        Assert.assertFalse(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n\n        newFeed.getLateArrival().setCutOff(Frequency.fromString(\"hours(1)\"));\n        Assert.assertFalse(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n\n        newFeed.getLateArrival().setCutOff(oldFeed.getLateArrival().getCutOff());\n        Assert.assertFalse(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n\n        FeedHelper.getLocation(newFeed, LocationType.DATA).setPath(\"/test\");\n        Assert.assertTrue(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n\n        FeedHelper.getLocation(newFeed, LocationType.DATA).setPath(\n                FeedHelper.getLocation(oldFeed, LocationType.DATA).getPath());\n        Assert.assertFalse(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n\n        newFeed.setFrequency(Frequency.fromString(\"months(1)\"));\n        Assert.assertTrue(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n\n        newFeed.setFrequency(oldFeed.getFrequency());\n        Assert.assertFalse(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n\n        Partition partition = new Partition();\n        partition.setName(\"1\");\n        newFeed.getPartitions().getPartitions().add(partition);\n        Assert.assertFalse(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n\n        Property property = new Property();\n        property.setName(\"1\");\n        property.setValue(\"1\");\n        newFeed.setProperties(new Properties());\n        newFeed.getProperties().getProperties().add(property);\n        Assert.assertFalse(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n\n        newFeed.getProperties().getProperties().remove(0);\n        Assert.assertFalse(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n\n        FeedHelper.getCluster(newFeed, process.getClusters().getClusters().get(0).getName()).getValidity().setStart(SchemaHelper.parseDateUTC(\"2012-11-01T00:00Z\"));\n        Assert.assertTrue(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n\n        FeedHelper.getCluster(newFeed, process.getClusters().getClusters().get(0).getName()).getValidity().\n                setStart(FeedHelper.getCluster(oldFeed, process.getClusters().getClusters().get(0).getName()).getValidity().getStart());\n        Assert.assertFalse(UpdateHelper.shouldUpdate(oldFeed, newFeed, process));\n    }", "signature": "void testShouldUpdate()", "full_signature": "@Test public void testShouldUpdate()", "class_method_signature": "UpdateHelperTest.testShouldUpdate()", "testcase": true, "constructor": false, "invocations": ["parseAndValidate", "getResourceAsStream", "getClass", "clone", "parseAndValidate", "getResourceAsStream", "getClass", "assertFalse", "shouldUpdate", "setCutOff", "getLateArrival", "fromString", "assertFalse", "shouldUpdate", "setCutOff", "getLateArrival", "getCutOff", "getLateArrival", "assertFalse", "shouldUpdate", "setPath", "getLocation", "assertTrue", "shouldUpdate", "setPath", "getLocation", "getPath", "getLocation", "assertFalse", "shouldUpdate", "setFrequency", "fromString", "assertTrue", "shouldUpdate", "setFrequency", "getFrequency", "assertFalse", "shouldUpdate", "setName", "add", "getPartitions", "getPartitions", "assertFalse", "shouldUpdate", "setName", "setValue", "setProperties", "add", "getProperties", "getProperties", "assertFalse", "shouldUpdate", "remove", "getProperties", "getProperties", "assertFalse", "shouldUpdate", "setStart", "getValidity", "getCluster", "getName", "get", "getClusters", "getClusters", "parseDateUTC", "assertTrue", "shouldUpdate", "setStart", "getValidity", "getCluster", "getName", "get", "getClusters", "getClusters", "getStart", "getValidity", "getCluster", "getName", "get", "getClusters", "getClusters", "assertFalse", "shouldUpdate"]}, "focal_class": {"identifier": "UpdateHelper", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = Logger.getLogger(UpdateHelper.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = Logger.getLogger(UpdateHelper.class)", "var_name": "LOG"}, {"original_string": "private static final String[] FEED_FIELDS = new String[] { \"partitions\", \"groups\", \"lateArrival.cutOff\", \"schema.location\", \"schema.provider\",\n        \"ACL.group\", \"ACL.owner\", \"ACL.permission\"};", "modifier": "private static final", "type": "String[]", "declarator": "FEED_FIELDS = new String[] { \"partitions\", \"groups\", \"lateArrival.cutOff\", \"schema.location\", \"schema.provider\",\n        \"ACL.group\", \"ACL.owner\", \"ACL.permission\"}", "var_name": "FEED_FIELDS"}, {"original_string": "private static final String[] PROCESS_FIELDS = new String[] { \"retry.policy\", \"retry.delay\", \"retry.attempts\", \n        \"lateProcess.policy\", \"lateProcess.delay\", \"lateProcess.lateInputs[\\\\d+].input\", \"lateProcess.lateInputs[\\\\d+].workflowPath\"};", "modifier": "private static final", "type": "String[]", "declarator": "PROCESS_FIELDS = new String[] { \"retry.policy\", \"retry.delay\", \"retry.attempts\", \n        \"lateProcess.policy\", \"lateProcess.delay\", \"lateProcess.lateInputs[\\\\d+].input\", \"lateProcess.lateInputs[\\\\d+].workflowPath\"}", "var_name": "PROCESS_FIELDS"}], "methods": [{"identifier": "shouldUpdate", "parameters": "(Entity oldEntity, Entity newEntity, String cluster)", "modifiers": "public static", "return": "boolean", "signature": "boolean shouldUpdate(Entity oldEntity, Entity newEntity, String cluster)", "full_signature": "public static boolean shouldUpdate(Entity oldEntity, Entity newEntity, String cluster)", "class_method_signature": "UpdateHelper.shouldUpdate(Entity oldEntity, Entity newEntity, String cluster)", "testcase": false, "constructor": false}, {"identifier": "shouldUpdate", "parameters": "(Entity oldEntity, Entity newEntity, Entity affectedEntity)", "modifiers": "public static", "return": "boolean", "signature": "boolean shouldUpdate(Entity oldEntity, Entity newEntity, Entity affectedEntity)", "full_signature": "public static boolean shouldUpdate(Entity oldEntity, Entity newEntity, Entity affectedEntity)", "class_method_signature": "UpdateHelper.shouldUpdate(Entity oldEntity, Entity newEntity, Entity affectedEntity)", "testcase": false, "constructor": false}, {"identifier": "shouldUpdate", "parameters": "(Feed oldFeed, Feed newFeed, Process affectedProcess)", "modifiers": "public static", "return": "boolean", "signature": "boolean shouldUpdate(Feed oldFeed, Feed newFeed, Process affectedProcess)", "full_signature": "public static boolean shouldUpdate(Feed oldFeed, Feed newFeed, Process affectedProcess)", "class_method_signature": "UpdateHelper.shouldUpdate(Feed oldFeed, Feed newFeed, Process affectedProcess)", "testcase": false, "constructor": false}, {"identifier": "getPartitions", "parameters": "(Partitions partitions)", "modifiers": "private static", "return": "List<String>", "signature": "List<String> getPartitions(Partitions partitions)", "full_signature": "private static List<String> getPartitions(Partitions partitions)", "class_method_signature": "UpdateHelper.getPartitions(Partitions partitions)", "testcase": false, "constructor": false}], "file": "common/src/main/java/org/apache/ivory/update/UpdateHelper.java"}, "focal_method": {"identifier": "shouldUpdate", "parameters": "(Entity oldEntity, Entity newEntity, String cluster)", "modifiers": "public static", "return": "boolean", "body": "public static boolean shouldUpdate(Entity oldEntity, Entity newEntity, String cluster) throws IvoryException {\n        Entity oldView = EntityUtil.getClusterView(oldEntity, cluster);\n        Entity newView = EntityUtil.getClusterView(newEntity, cluster);\n        switch(oldEntity.getEntityType()) {\n            case FEED:\n                if(EntityUtil.equals(oldView, newView, FEED_FIELDS))\n                    return false;\n                return true;\n                \n            case PROCESS:\n                if(EntityUtil.equals(oldView, newView, PROCESS_FIELDS))\n                    return false;\n                return true;\n        }\n        throw new IllegalArgumentException(\"Unhandled entity type \" + oldEntity.getEntityType());\n    }", "signature": "boolean shouldUpdate(Entity oldEntity, Entity newEntity, String cluster)", "full_signature": "public static boolean shouldUpdate(Entity oldEntity, Entity newEntity, String cluster)", "class_method_signature": "UpdateHelper.shouldUpdate(Entity oldEntity, Entity newEntity, String cluster)", "testcase": false, "constructor": false, "invocations": ["getClusterView", "getClusterView", "getEntityType", "equals", "equals", "getEntityType"]}, "repository": {"repo_id": 2836228, "url": "https://github.com/sriksun/Ivory", "language": "Java", "is_fork": false, "fork_count": 12, "stargazer_count": 28, "size": 11708, "license": "licensed"}}