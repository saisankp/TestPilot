{"test_class": {"identifier": "DefaultVersionServiceTest", "superclass": "", "interfaces": "", "fields": [], "file": "outland-feature-server/src/test/java/outland/feature/server/features/DefaultVersionServiceTest.java"}, "test_case": {"identifier": "sendPhysicalTimeInTheFuture", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void sendPhysicalTimeInTheFuture() {\n\n    final int[] calls = {0};\n\n    final DefaultVersionService.Clock clock = () -> {\n\n      if (calls[0]++ == 0) {\n        return (System.currentTimeMillis() * 1000L);\n      }\n\n      return (System.currentTimeMillis() * 1000L) + DefaultVersionService.MAX_SYSTEM_TIME_FORWARD_DRIFT + 1;\n    };\n\n    DefaultVersionService v = new DefaultVersionService(clock);\n    final DefaultVersionService.HybridLogicalTimestamp send = v.nextVersion();\n    final DefaultVersionService.HybridLogicalTimestamp send1 = v.nextVersion();\n\n    // when our physical clock is too far ahead, only the counter moves forward\n    assertEquals(send.logicalTime(), send1.logicalTime());\n    assertTrue(send.counter() < send1.counter());\n    assertSame(send.counter(), send1.counter() - 1);\n  }", "signature": "void sendPhysicalTimeInTheFuture()", "full_signature": "@Test public void sendPhysicalTimeInTheFuture()", "class_method_signature": "DefaultVersionServiceTest.sendPhysicalTimeInTheFuture()", "testcase": true, "constructor": false, "invocations": ["currentTimeMillis", "currentTimeMillis", "nextVersion", "nextVersion", "assertEquals", "logicalTime", "logicalTime", "assertTrue", "counter", "counter", "assertSame", "counter", "counter"]}, "focal_class": {"identifier": "DefaultVersionService", "superclass": "", "interfaces": "implements VersionService", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(DefaultVersionService.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(DefaultVersionService.class)", "var_name": "logger"}, {"original_string": "private static final long ONE_HOUR_MICROSECONDS = 3600L * 1000L * 1000L;", "modifier": "private static final", "type": "long", "declarator": "ONE_HOUR_MICROSECONDS = 3600L * 1000L * 1000L", "var_name": "ONE_HOUR_MICROSECONDS"}, {"original_string": "static final long MAX_SYSTEM_TIME_FORWARD_DRIFT = 12 * ONE_HOUR_MICROSECONDS;", "modifier": "static final", "type": "long", "declarator": "MAX_SYSTEM_TIME_FORWARD_DRIFT = 12 * ONE_HOUR_MICROSECONDS", "var_name": "MAX_SYSTEM_TIME_FORWARD_DRIFT"}, {"original_string": "private static final long MAX_INCOMING_TIME_FORWARD_DRIFT = 12 * ONE_HOUR_MICROSECONDS;", "modifier": "private static final", "type": "long", "declarator": "MAX_INCOMING_TIME_FORWARD_DRIFT = 12 * ONE_HOUR_MICROSECONDS", "var_name": "MAX_INCOMING_TIME_FORWARD_DRIFT"}, {"original_string": "private static final long INITIAL_COUNTER = 0L;", "modifier": "private static final", "type": "long", "declarator": "INITIAL_COUNTER = 0L", "var_name": "INITIAL_COUNTER"}, {"original_string": "private final Clock clock;", "modifier": "private final", "type": "Clock", "declarator": "clock", "var_name": "clock"}, {"original_string": "private final AtomicLong localTime;", "modifier": "private final", "type": "AtomicLong", "declarator": "localTime", "var_name": "localTime"}, {"original_string": "private final AtomicLong localCounter;", "modifier": "private final", "type": "AtomicLong", "declarator": "localCounter", "var_name": "localCounter"}], "methods": [{"identifier": "DefaultVersionService", "parameters": "(Clock clock)", "modifiers": "", "return": "", "signature": " DefaultVersionService(Clock clock)", "full_signature": "  DefaultVersionService(Clock clock)", "class_method_signature": "DefaultVersionService.DefaultVersionService(Clock clock)", "testcase": false, "constructor": true}, {"identifier": "DefaultVersionService", "parameters": "()", "modifiers": "", "return": "", "signature": " DefaultVersionService()", "full_signature": "  DefaultVersionService()", "class_method_signature": "DefaultVersionService.DefaultVersionService()", "testcase": false, "constructor": true}, {"identifier": "nextVersion", "parameters": "()", "modifiers": "@Override public", "return": "HybridLogicalTimestamp", "signature": "HybridLogicalTimestamp nextVersion()", "full_signature": "@Override public HybridLogicalTimestamp nextVersion()", "class_method_signature": "DefaultVersionService.nextVersion()", "testcase": false, "constructor": false}, {"identifier": "nextVersionUpdate", "parameters": "(HybridLogicalTimestamp incoming)", "modifiers": "@Override public", "return": "HybridLogicalTimestamp", "signature": "HybridLogicalTimestamp nextVersionUpdate(HybridLogicalTimestamp incoming)", "full_signature": "@Override public HybridLogicalTimestamp nextVersionUpdate(HybridLogicalTimestamp incoming)", "class_method_signature": "DefaultVersionService.nextVersionUpdate(HybridLogicalTimestamp incoming)", "testcase": false, "constructor": false}, {"identifier": "physicalNowTooFarAhead", "parameters": "(long physicalNow, AtomicLong logicalTime)", "modifiers": "private", "return": "boolean", "signature": "boolean physicalNowTooFarAhead(long physicalNow, AtomicLong logicalTime)", "full_signature": "private boolean physicalNowTooFarAhead(long physicalNow, AtomicLong logicalTime)", "class_method_signature": "DefaultVersionService.physicalNowTooFarAhead(long physicalNow, AtomicLong logicalTime)", "testcase": false, "constructor": false}, {"identifier": "resolveLocalAndIncomingTimestamps", "parameters": "(HybridLogicalTimestamp incoming)", "modifiers": "private", "return": "void", "signature": "void resolveLocalAndIncomingTimestamps(HybridLogicalTimestamp incoming)", "full_signature": "private void resolveLocalAndIncomingTimestamps(HybridLogicalTimestamp incoming)", "class_method_signature": "DefaultVersionService.resolveLocalAndIncomingTimestamps(HybridLogicalTimestamp incoming)", "testcase": false, "constructor": false}, {"identifier": "traceForwardDrift", "parameters": "(long physicalNow, long localTime)", "modifiers": "private", "return": "void", "signature": "void traceForwardDrift(long physicalNow, long localTime)", "full_signature": "private void traceForwardDrift(long physicalNow, long localTime)", "class_method_signature": "DefaultVersionService.traceForwardDrift(long physicalNow, long localTime)", "testcase": false, "constructor": false}, {"identifier": "traceIncomingForwardDrift", "parameters": "(long localTime, long incomingTime)", "modifiers": "private", "return": "void", "signature": "void traceIncomingForwardDrift(long localTime, long incomingTime)", "full_signature": "private void traceIncomingForwardDrift(long localTime, long incomingTime)", "class_method_signature": "DefaultVersionService.traceIncomingForwardDrift(long localTime, long incomingTime)", "testcase": false, "constructor": false}, {"identifier": "traceBackwardDrift", "parameters": "(long physicalNow, long localTime, long incoming)", "modifiers": "private", "return": "void", "signature": "void traceBackwardDrift(long physicalNow, long localTime, long incoming)", "full_signature": "private void traceBackwardDrift(long physicalNow, long localTime, long incoming)", "class_method_signature": "DefaultVersionService.traceBackwardDrift(long physicalNow, long localTime, long incoming)", "testcase": false, "constructor": false}, {"identifier": "traceBackwardDrift", "parameters": "(long physicalNow, long localTime)", "modifiers": "private", "return": "void", "signature": "void traceBackwardDrift(long physicalNow, long localTime)", "full_signature": "private void traceBackwardDrift(long physicalNow, long localTime)", "class_method_signature": "DefaultVersionService.traceBackwardDrift(long physicalNow, long localTime)", "testcase": false, "constructor": false}], "file": "outland-feature-server/src/main/java/outland/feature/server/features/DefaultVersionService.java"}, "focal_method": {"identifier": "nextVersion", "parameters": "()", "modifiers": "@Override public", "return": "HybridLogicalTimestamp", "body": "@Override\n  public HybridLogicalTimestamp nextVersion() {\n\n    final long physicalNow = this.clock.timestampMicros();\n\n    if (localTime.get() >= physicalNow) {\n      //physical clock hasn't moved forward relative to local, keep the logicalTime, bump counter\n      localCounter.incrementAndGet();\n      traceBackwardDrift(physicalNow, localTime.get());\n    } else {\n      // the physical clock is ahead\n\n      /*\n       a hack to handle the 2051 problem; if our system clock is \"too\" far ahead of our local\n       logicalTime then all future versions get dragged forward to keep up with it and we have\n       to wait for \"reality\" to catch up with that logicalTime to reset things.\n\n       todo: this misses the case where the clock is borked on construction;\n       in the ctor we set the initial local to the physical clock, so this only catches drift\n       when updating the local. it also needs some thought such that if multiple nodes are stuck\n       on fwd/back physical times and just bumping counters they don't clash.\n        */\n      if (physicalNowTooFarAhead(physicalNow, localTime)) {\n        localCounter.incrementAndGet();\n        traceForwardDrift(physicalNow, localTime.get());\n      } else {\n        // things look sane, take the physical logicalTime and reset the counter\n        localTime.set(physicalNow);\n        localCounter.set(INITIAL_COUNTER);\n      }\n    }\n\n    return new HybridLogicalTimestamp(localTime.get(), localCounter.get());\n  }", "signature": "HybridLogicalTimestamp nextVersion()", "full_signature": "@Override public HybridLogicalTimestamp nextVersion()", "class_method_signature": "DefaultVersionService.nextVersion()", "testcase": false, "constructor": false, "invocations": ["timestampMicros", "get", "incrementAndGet", "traceBackwardDrift", "get", "physicalNowTooFarAhead", "incrementAndGet", "traceForwardDrift", "get", "set", "set", "get", "get"]}, "repository": {"repo_id": 83838306, "url": "https://github.com/dehora/outland", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 5, "size": 944, "license": "licensed"}}