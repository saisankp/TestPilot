{"test_class": {"identifier": "ShapefileDataStoreFactoryTest", "superclass": "extends TestCaseSupport", "interfaces": "", "fields": [{"original_string": "private ShapefileDataStore store = null;", "modifier": "private", "type": "ShapefileDataStore", "declarator": "store = null", "var_name": "store"}, {"original_string": "private ShapefileDataStoreFactory factory = new ShapefileDataStoreFactory();", "modifier": "private", "type": "ShapefileDataStoreFactory", "declarator": "factory = new ShapefileDataStoreFactory()", "var_name": "factory"}], "file": "modules/plugin/shapefile/src/test/java/org/geotools/data/shapefile/ShapefileDataStoreFactoryTest.java"}, "test_case": {"identifier": "testEnableIndexParameter", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testEnableIndexParameter() throws Exception {\n        Map<String, Serializable> params;\n        ShapefileDataStore ds;\n\n        // remote (jar file) shapefiles\n        URL remoteUrl = TestData.url(STATE_POP);\n\n        // local shapefiles (copied out of jar)\n        File f = copyShapefiles(STATE_POP);\n        URL localUrl = f.toURI().toURL();\n\n        // test remote file has spatial index disabled even if requested\n        params = map(URLP.key, remoteUrl, ENABLE_SPATIAL_INDEX.key, true);\n        ds = (ShapefileDataStore) factory.createDataStore(params);\n        assertNotNull(\"Null datastore should not be returned\", ds);\n        assertTrue(\"should be a non indexed shapefile\",\n                ds instanceof org.geotools.data.shapefile.ShapefileDataStore);\n        ds.dispose();\n\n        // test default has spatial index enabled\n        params = map(URLP.key, localUrl);\n        ds = (ShapefileDataStore) factory.createDataStore(params);\n        assertNotNull(\"Null datastore should not be returned\", ds);\n        assertTrue(ds.isIndexed());\n        assertTrue(ds.isIndexCreationEnabled());\n        ds.dispose();\n\n        // test disable works\n        params = map(URLP.key, localUrl, ENABLE_SPATIAL_INDEX.key, false);\n        ds = (ShapefileDataStore) factory.createDataStore(params);\n        assertNotNull(\"Null datastore should not be returned\", ds);\n        assertFalse(ds.isIndexed());\n        assertFalse(ds.isIndexCreationEnabled());\n        ds.dispose();\n\n        // text explicit enable works\n        params = map(URLP.key, localUrl, ENABLE_SPATIAL_INDEX.key, true);\n        ds = (ShapefileDataStore) factory.createDataStore(params);\n        assertNotNull(\"Null datastore should not be returned\", ds);\n        assertTrue(ds.isIndexed());\n        assertTrue(ds.isIndexCreationEnabled());\n        ds.dispose();\n    }", "signature": "void testEnableIndexParameter()", "full_signature": "@Test public void testEnableIndexParameter()", "class_method_signature": "ShapefileDataStoreFactoryTest.testEnableIndexParameter()", "testcase": true, "constructor": false, "invocations": ["url", "copyShapefiles", "toURL", "toURI", "map", "createDataStore", "assertNotNull", "assertTrue", "dispose", "map", "createDataStore", "assertNotNull", "assertTrue", "isIndexed", "assertTrue", "isIndexCreationEnabled", "dispose", "map", "createDataStore", "assertNotNull", "assertFalse", "isIndexed", "assertFalse", "isIndexCreationEnabled", "dispose", "map", "createDataStore", "assertNotNull", "assertTrue", "isIndexed", "assertTrue", "isIndexCreationEnabled", "dispose"]}, "focal_class": {"identifier": "ShapefileDataStoreFactory", "superclass": "", "interfaces": "implements FileDataStoreFactorySpi", "fields": [{"original_string": "static final Logger LOGGER = Logging.getLogger(\"org.geotools.data.shapefile\");", "modifier": "static final", "type": "Logger", "declarator": "LOGGER = Logging.getLogger(\"org.geotools.data.shapefile\")", "var_name": "LOGGER"}, {"original_string": "public static final Param URLP = new Param(\"url\", URL.class, \"url to a .shp file\", true, null,\n            new KVP(Param.EXT, \"shp\"));", "modifier": "public static final", "type": "Param", "declarator": "URLP = new Param(\"url\", URL.class, \"url to a .shp file\", true, null,\n            new KVP(Param.EXT, \"shp\"))", "var_name": "URLP"}, {"original_string": "public static final Param NAMESPACEP = new Param(\"namespace\", URI.class,\n            \"uri to a the namespace\", false, null, // not required\n            new KVP(Param.LEVEL, \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "NAMESPACEP = new Param(\"namespace\", URI.class,\n            \"uri to a the namespace\", false, null, // not required\n            new KVP(Param.LEVEL, \"advanced\"))", "var_name": "NAMESPACEP"}, {"original_string": "public static final Param MEMORY_MAPPED = new Param(\"memory mapped buffer\", Boolean.class,\n            \"enable/disable the use of memory-mapped io\", false, false, new KVP(Param.LEVEL,\n                    \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "MEMORY_MAPPED = new Param(\"memory mapped buffer\", Boolean.class,\n            \"enable/disable the use of memory-mapped io\", false, false, new KVP(Param.LEVEL,\n                    \"advanced\"))", "var_name": "MEMORY_MAPPED"}, {"original_string": "public static final Param CACHE_MEMORY_MAPS = new Param(\"cache and reuse memory maps\",\n            Boolean.class, \"only memory map a file one, then cache and reuse the map\", false, true,\n            new KVP(Param.LEVEL, \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "CACHE_MEMORY_MAPS = new Param(\"cache and reuse memory maps\",\n            Boolean.class, \"only memory map a file one, then cache and reuse the map\", false, true,\n            new KVP(Param.LEVEL, \"advanced\"))", "var_name": "CACHE_MEMORY_MAPS"}, {"original_string": "public static final Param FILE_TYPE = new Param(\"filetype\", String.class,\n            \"Discriminator for directory stores\", false, \"shapefile\", new KVP(Param.LEVEL,\n                    \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "FILE_TYPE = new Param(\"filetype\", String.class,\n            \"Discriminator for directory stores\", false, \"shapefile\", new KVP(Param.LEVEL,\n                    \"advanced\"))", "var_name": "FILE_TYPE"}, {"original_string": "public static final Param CREATE_SPATIAL_INDEX = new Param(\"create spatial index\",\n            Boolean.class, \"enable/disable the automatic creation of spatial index\", false, true,\n            new KVP(Param.LEVEL, \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "CREATE_SPATIAL_INDEX = new Param(\"create spatial index\",\n            Boolean.class, \"enable/disable the automatic creation of spatial index\", false, true,\n            new KVP(Param.LEVEL, \"advanced\"))", "var_name": "CREATE_SPATIAL_INDEX"}, {"original_string": "public static final Param DBFCHARSET = new Param(\"charset\", Charset.class,\n            \"character used to decode strings from the DBF file\", false,\n            Charset.forName(\"ISO-8859-1\"), new KVP(Param.LEVEL, \"advanced\")) {\n        /*\n         * This is an example of a non simple Param type where a custom parse method is required.\n         * \n         * @see org.geotools.data.DataStoreFactorySpi.Param#parse(java.lang.String)\n         */\n        public Object parse(String text) throws IOException {\n            return Charset.forName(text);\n        }\n\n        public String text(Object value) {\n            return ((Charset) value).name();\n        }\n    };", "modifier": "public static final", "type": "Param", "declarator": "DBFCHARSET = new Param(\"charset\", Charset.class,\n            \"character used to decode strings from the DBF file\", false,\n            Charset.forName(\"ISO-8859-1\"), new KVP(Param.LEVEL, \"advanced\")) {\n        /*\n         * This is an example of a non simple Param type where a custom parse method is required.\n         * \n         * @see org.geotools.data.DataStoreFactorySpi.Param#parse(java.lang.String)\n         */\n        public Object parse(String text) throws IOException {\n            return Charset.forName(text);\n        }\n\n        public String text(Object value) {\n            return ((Charset) value).name();\n        }\n    }", "var_name": "DBFCHARSET"}, {"original_string": "public static final Param FSTYPE = new Param(\"fstype\",\n            String.class, \"Enable using a setting of 'shape'.\", false, \"shape\",\n            new KVP(Param.LEVEL, \"advanced\", Param.OPTIONS,Arrays.asList(new String[]{\"shape-ng\", \"shape\", \"index\"})));", "modifier": "public static final", "type": "Param", "declarator": "FSTYPE = new Param(\"fstype\",\n            String.class, \"Enable using a setting of 'shape'.\", false, \"shape\",\n            new KVP(Param.LEVEL, \"advanced\", Param.OPTIONS,Arrays.asList(new String[]{\"shape-ng\", \"shape\", \"index\"})))", "var_name": "FSTYPE"}, {"original_string": "public static final Param DBFTIMEZONE = new Param(\"timezone\", TimeZone.class,\n            \"time zone used to read dates from the DBF file\", false, TimeZone.getDefault(),\n            new KVP(Param.LEVEL, \"advanced\")) {\n\n        public Object parse(String text) throws IOException {\n            return TimeZone.getTimeZone(text);\n        }\n\n        public String text(Object value) {\n            return ((TimeZone) value).getID();\n        }\n    };", "modifier": "public static final", "type": "Param", "declarator": "DBFTIMEZONE = new Param(\"timezone\", TimeZone.class,\n            \"time zone used to read dates from the DBF file\", false, TimeZone.getDefault(),\n            new KVP(Param.LEVEL, \"advanced\")) {\n\n        public Object parse(String text) throws IOException {\n            return TimeZone.getTimeZone(text);\n        }\n\n        public String text(Object value) {\n            return ((TimeZone) value).getID();\n        }\n    }", "var_name": "DBFTIMEZONE"}, {"original_string": "public static final Param ENABLE_SPATIAL_INDEX = new Param(\"enable spatial index\",\n            Boolean.class, \"enable/disable the use of spatial index for local shapefiles\", false,\n            true, new KVP(Param.LEVEL, \"advanced\"));", "modifier": "public static final", "type": "Param", "declarator": "ENABLE_SPATIAL_INDEX = new Param(\"enable spatial index\",\n            Boolean.class, \"enable/disable the use of spatial index for local shapefiles\", false,\n            true, new KVP(Param.LEVEL, \"advanced\"))", "var_name": "ENABLE_SPATIAL_INDEX"}], "methods": [{"identifier": "getDisplayName", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getDisplayName()", "full_signature": "public String getDisplayName()", "class_method_signature": "ShapefileDataStoreFactory.getDisplayName()", "testcase": false, "constructor": false}, {"identifier": "getDescription", "parameters": "()", "modifiers": "public", "return": "String", "signature": "String getDescription()", "full_signature": "public String getDescription()", "class_method_signature": "ShapefileDataStoreFactory.getDescription()", "testcase": false, "constructor": false}, {"identifier": "getParametersInfo", "parameters": "()", "modifiers": "public", "return": "Param[]", "signature": "Param[] getParametersInfo()", "full_signature": "public Param[] getParametersInfo()", "class_method_signature": "ShapefileDataStoreFactory.getParametersInfo()", "testcase": false, "constructor": false}, {"identifier": "isAvailable", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isAvailable()", "full_signature": "public boolean isAvailable()", "class_method_signature": "ShapefileDataStoreFactory.isAvailable()", "testcase": false, "constructor": false}, {"identifier": "getImplementationHints", "parameters": "()", "modifiers": "public", "return": "Map<Key, ?>", "signature": "Map<Key, ?> getImplementationHints()", "full_signature": "public Map<Key, ?> getImplementationHints()", "class_method_signature": "ShapefileDataStoreFactory.getImplementationHints()", "testcase": false, "constructor": false}, {"identifier": "createDataStore", "parameters": "(Map<String, Serializable> params)", "modifiers": "public", "return": "DataStore", "signature": "DataStore createDataStore(Map<String, Serializable> params)", "full_signature": "public DataStore createDataStore(Map<String, Serializable> params)", "class_method_signature": "ShapefileDataStoreFactory.createDataStore(Map<String, Serializable> params)", "testcase": false, "constructor": false}, {"identifier": "createNewDataStore", "parameters": "(Map<String, Serializable> params)", "modifiers": "public", "return": "DataStore", "signature": "DataStore createNewDataStore(Map<String, Serializable> params)", "full_signature": "public DataStore createNewDataStore(Map<String, Serializable> params)", "class_method_signature": "ShapefileDataStoreFactory.createNewDataStore(Map<String, Serializable> params)", "testcase": false, "constructor": false}, {"identifier": "lookup", "parameters": "(Param param, Map<String, Serializable> params, Class<T> target)", "modifiers": "", "return": "T", "signature": "T lookup(Param param, Map<String, Serializable> params, Class<T> target)", "full_signature": " T lookup(Param param, Map<String, Serializable> params, Class<T> target)", "class_method_signature": "ShapefileDataStoreFactory.lookup(Param param, Map<String, Serializable> params, Class<T> target)", "testcase": false, "constructor": false}, {"identifier": "canProcess", "parameters": "(Map params)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean canProcess(Map params)", "full_signature": "@Override public boolean canProcess(Map params)", "class_method_signature": "ShapefileDataStoreFactory.canProcess(Map params)", "testcase": false, "constructor": false}, {"identifier": "canProcess", "parameters": "(URL f)", "modifiers": "public", "return": "boolean", "signature": "boolean canProcess(URL f)", "full_signature": "public boolean canProcess(URL f)", "class_method_signature": "ShapefileDataStoreFactory.canProcess(URL f)", "testcase": false, "constructor": false}, {"identifier": "getFileExtensions", "parameters": "()", "modifiers": "@Override public", "return": "String[]", "signature": "String[] getFileExtensions()", "full_signature": "@Override public String[] getFileExtensions()", "class_method_signature": "ShapefileDataStoreFactory.getFileExtensions()", "testcase": false, "constructor": false}, {"identifier": "createDataStore", "parameters": "(URL url)", "modifiers": "@Override public", "return": "FileDataStore", "signature": "FileDataStore createDataStore(URL url)", "full_signature": "@Override public FileDataStore createDataStore(URL url)", "class_method_signature": "ShapefileDataStoreFactory.createDataStore(URL url)", "testcase": false, "constructor": false}, {"identifier": "getTypeName", "parameters": "(URL url)", "modifiers": "@Override public", "return": "String", "signature": "String getTypeName(URL url)", "full_signature": "@Override public String getTypeName(URL url)", "class_method_signature": "ShapefileDataStoreFactory.getTypeName(URL url)", "testcase": false, "constructor": false}], "file": "modules/plugin/shapefile/src/main/java/org/geotools/data/shapefile/ShapefileDataStoreFactory.java"}, "focal_method": {"identifier": "createDataStore", "parameters": "(Map<String, Serializable> params)", "modifiers": "public", "return": "DataStore", "body": "public DataStore createDataStore(Map<String, Serializable> params) throws IOException {\n        URL url = lookup(URLP, params, URL.class);\n        Boolean isMemoryMapped = lookup(MEMORY_MAPPED, params, Boolean.class);\n        Boolean cacheMemoryMaps = lookup(CACHE_MEMORY_MAPS, params, Boolean.class);\n        URI namespace = lookup(NAMESPACEP, params, URI.class);\n        Charset dbfCharset = lookup(DBFCHARSET, params, Charset.class);\n        TimeZone dbfTimeZone = lookup(DBFTIMEZONE, params, TimeZone.class);\n        Boolean isCreateSpatialIndex = lookup(CREATE_SPATIAL_INDEX, params, Boolean.class);\n        Boolean isEnableSpatialIndex = (Boolean) ENABLE_SPATIAL_INDEX.lookUp(params);\n        if (isEnableSpatialIndex == null) {\n            // should not be needed as default is TRUE\n            isEnableSpatialIndex = Boolean.TRUE;\n        }\n        \n        // are we creating a directory of shapefiles store, or a single one?\n        File dir = DataUtilities.urlToFile(url);\n        if (dir != null && dir.isDirectory()) {\n            return new DirectoryDataStore(DataUtilities.urlToFile(url), new ShpFileStoreFactory(\n                    this, params));\n        } else {\n            ShpFiles shpFiles = new ShpFiles(url);\n\n            boolean isLocal = shpFiles.isLocal();\n            boolean useMemoryMappedBuffer = isLocal && isMemoryMapped.booleanValue();\n            boolean enableIndex = isEnableSpatialIndex.booleanValue() && isLocal;\n            boolean createIndex = isCreateSpatialIndex.booleanValue() && enableIndex;\n\n            // build the store\n            ShapefileDataStore store = new ShapefileDataStore(url);\n            if(namespace != null) {\n                store.setNamespaceURI(namespace.toString());\n            }\n            store.setMemoryMapped(useMemoryMappedBuffer);\n            store.setBufferCachingEnabled(cacheMemoryMaps);\n            store.setCharset(dbfCharset);\n            store.setTimeZone(dbfTimeZone);\n            store.setIndexed(enableIndex);\n            store.setIndexCreationEnabled(createIndex);\n            return store;\n        }\n    }", "signature": "DataStore createDataStore(Map<String, Serializable> params)", "full_signature": "public DataStore createDataStore(Map<String, Serializable> params)", "class_method_signature": "ShapefileDataStoreFactory.createDataStore(Map<String, Serializable> params)", "testcase": false, "constructor": false, "invocations": ["lookup", "lookup", "lookup", "lookup", "lookup", "lookup", "lookup", "lookUp", "urlToFile", "isDirectory", "urlToFile", "isLocal", "booleanValue", "booleanValue", "booleanValue", "setNamespaceURI", "toString", "setMemoryMapped", "setBufferCachingEnabled", "setCharset", "setTimeZone", "setIndexed", "setIndexCreationEnabled"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}