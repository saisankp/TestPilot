{"test_class": {"identifier": "DataSourceTaskTest", "superclass": "extends TaskTestBase", "interfaces": "", "fields": [{"original_string": "private static final int MEMORY_MANAGER_SIZE = 1024 * 1024;", "modifier": "private static final", "type": "int", "declarator": "MEMORY_MANAGER_SIZE = 1024 * 1024", "var_name": "MEMORY_MANAGER_SIZE"}, {"original_string": "private static final int NETWORK_BUFFER_SIZE = 1024;", "modifier": "private static final", "type": "int", "declarator": "NETWORK_BUFFER_SIZE = 1024", "var_name": "NETWORK_BUFFER_SIZE"}, {"original_string": "private List<Record> outList;", "modifier": "private", "type": "List<Record>", "declarator": "outList", "var_name": "outList"}, {"original_string": "private String tempTestPath = DataSinkTaskTest.constructTestPath(DataSourceTaskTest.class, \"dst_test\");", "modifier": "private", "type": "String", "declarator": "tempTestPath = DataSinkTaskTest.constructTestPath(DataSourceTaskTest.class, \"dst_test\")", "var_name": "tempTestPath"}], "file": "flink-runtime/src/test/java/org/apache/flink/runtime/operators/DataSourceTaskTest.java"}, "test_case": {"identifier": "testCancelDataSourceTask", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testCancelDataSourceTask() {\n\t\tint keyCnt = 20;\n\t\tint valCnt = 4;\n\n\t\tsuper.initEnvironment(MEMORY_MANAGER_SIZE, NETWORK_BUFFER_SIZE);\n\t\tsuper.addOutput(new NirvanaOutputList());\n\t\t\n\t\ttry {\n\t\t\tInputFilePreparator.prepareInputFile(new UniformRecordGenerator(keyCnt, valCnt, false), \n\t\t\t\tthis.tempTestPath, false);\n\t\t} catch (IOException e1) {\n\t\t\tAssert.fail(\"Unable to set-up test input file\");\n\t\t}\n\t\t\n\t\tfinal DataSourceTask<Record> testTask = new DataSourceTask<>();\n\n\t\tsuper.registerFileInputTask(testTask, MockDelayingInputFormat.class,  new File(tempTestPath).toURI().toString(), \"\\n\");\n\t\t\n\t\tThread taskRunner = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\ttestTask.invoke();\n\t\t\t\t} catch (Exception ie) {\n\t\t\t\t\tie.printStackTrace();\n\t\t\t\t\tAssert.fail(\"Task threw exception although it was properly canceled\");\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\ttaskRunner.start();\n\t\t\n\t\tTaskCancelThread tct = new TaskCancelThread(1, taskRunner, testTask);\n\t\ttct.start();\n\t\t\n\t\ttry {\n\t\t\ttct.join();\n\t\t\ttaskRunner.join();\n\t\t} catch(InterruptedException ie) {\n\t\t\tAssert.fail(\"Joining threads failed\");\n\t\t}\n\t\t\n\t\t// assert that temp file was created\n\t\tFile tempTestFile = new File(this.tempTestPath);\n\t\tAssert.assertTrue(\"Temp output file does not exist\",tempTestFile.exists());\n\t}", "signature": "void testCancelDataSourceTask()", "full_signature": "@Test public void testCancelDataSourceTask()", "class_method_signature": "DataSourceTaskTest.testCancelDataSourceTask()", "testcase": true, "constructor": false, "invocations": ["initEnvironment", "addOutput", "prepareInputFile", "fail", "registerFileInputTask", "toString", "toURI", "invoke", "printStackTrace", "fail", "start", "start", "join", "join", "fail", "assertTrue", "exists"]}, "focal_class": {"identifier": "DataSourceTask", "superclass": "extends AbstractInvokable", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(DataSourceTask.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(DataSourceTask.class)", "var_name": "LOG"}, {"original_string": "private List<RecordWriter<?>> eventualOutputs;", "modifier": "private", "type": "List<RecordWriter<?>>", "declarator": "eventualOutputs", "var_name": "eventualOutputs"}, {"original_string": "private Collector<OT> output;", "modifier": "private", "type": "Collector<OT>", "declarator": "output", "var_name": "output"}, {"original_string": "private InputFormat<OT, InputSplit> format;", "modifier": "private", "type": "InputFormat<OT, InputSplit>", "declarator": "format", "var_name": "format"}, {"original_string": "private TypeSerializerFactory<OT> serializerFactory;", "modifier": "private", "type": "TypeSerializerFactory<OT>", "declarator": "serializerFactory", "var_name": "serializerFactory"}, {"original_string": "private TaskConfig config;", "modifier": "private", "type": "TaskConfig", "declarator": "config", "var_name": "config"}, {"original_string": "private ArrayList<ChainedDriver<?, ?>> chainedTasks;", "modifier": "private", "type": "ArrayList<ChainedDriver<?, ?>>", "declarator": "chainedTasks", "var_name": "chainedTasks"}, {"original_string": "private volatile boolean taskCanceled = false;", "modifier": "private volatile", "type": "boolean", "declarator": "taskCanceled = false", "var_name": "taskCanceled"}], "methods": [{"identifier": "invoke", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void invoke()", "full_signature": "@Override public void invoke()", "class_method_signature": "DataSourceTask.invoke()", "testcase": false, "constructor": false}, {"identifier": "cancel", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void cancel()", "full_signature": "@Override public void cancel()", "class_method_signature": "DataSourceTask.cancel()", "testcase": false, "constructor": false}, {"identifier": "initInputFormat", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void initInputFormat()", "full_signature": "private void initInputFormat()", "class_method_signature": "DataSourceTask.initInputFormat()", "testcase": false, "constructor": false}, {"identifier": "initOutputs", "parameters": "(ClassLoader cl)", "modifiers": "private", "return": "void", "signature": "void initOutputs(ClassLoader cl)", "full_signature": "private void initOutputs(ClassLoader cl)", "class_method_signature": "DataSourceTask.initOutputs(ClassLoader cl)", "testcase": false, "constructor": false}, {"identifier": "getLogString", "parameters": "(String message)", "modifiers": "private", "return": "String", "signature": "String getLogString(String message)", "full_signature": "private String getLogString(String message)", "class_method_signature": "DataSourceTask.getLogString(String message)", "testcase": false, "constructor": false}, {"identifier": "getLogString", "parameters": "(String message, String taskName)", "modifiers": "private", "return": "String", "signature": "String getLogString(String message, String taskName)", "full_signature": "private String getLogString(String message, String taskName)", "class_method_signature": "DataSourceTask.getLogString(String message, String taskName)", "testcase": false, "constructor": false}, {"identifier": "getInputSplits", "parameters": "()", "modifiers": "private", "return": "Iterator<InputSplit>", "signature": "Iterator<InputSplit> getInputSplits()", "full_signature": "private Iterator<InputSplit> getInputSplits()", "class_method_signature": "DataSourceTask.getInputSplits()", "testcase": false, "constructor": false}, {"identifier": "createRuntimeContext", "parameters": "()", "modifiers": "public", "return": "DistributedRuntimeUDFContext", "signature": "DistributedRuntimeUDFContext createRuntimeContext()", "full_signature": "public DistributedRuntimeUDFContext createRuntimeContext()", "class_method_signature": "DataSourceTask.createRuntimeContext()", "testcase": false, "constructor": false}], "file": "flink-runtime/src/main/java/org/apache/flink/runtime/operators/DataSourceTask.java"}, "focal_method": {"identifier": "invoke", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void invoke() throws Exception {\n\t\t// --------------------------------------------------------------------\n\t\t// Initialize\n\t\t// --------------------------------------------------------------------\n\t\tinitInputFormat();\n\n\t\tLOG.debug(getLogString(\"Start registering input and output\"));\n\n\t\ttry {\n\t\t\tinitOutputs(getUserCodeClassLoader());\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(\"The initialization of the DataSource's outputs caused an error: \" +\n\t\t\t\t\tex.getMessage(), ex);\n\t\t}\n\n\t\tLOG.debug(getLogString(\"Finished registering input and output\"));\n\n\t\t// --------------------------------------------------------------------\n\t\t// Invoke\n\t\t// --------------------------------------------------------------------\n\t\tLOG.debug(getLogString(\"Starting data source operator\"));\n\n\t\tif(RichInputFormat.class.isAssignableFrom(this.format.getClass())){\n\t\t\t((RichInputFormat) this.format).setRuntimeContext(createRuntimeContext());\n\t\t\tLOG.debug(getLogString(\"Rich Source detected. Initializing runtime context.\"));\n\t\t}\n\n\t\tExecutionConfig executionConfig;\n\t\ttry {\n\t\t\tExecutionConfig c = (ExecutionConfig) InstantiationUtil.readObjectFromConfig(\n\t\t\t\t\tgetJobConfiguration(),\n\t\t\t\t\tExecutionConfig.CONFIG_KEY,\n\t\t\t\t\tgetUserCodeClassLoader());\n\t\t\tif (c != null) {\n\t\t\t\texecutionConfig = c;\n\t\t\t} else {\n\t\t\t\tLOG.warn(\"ExecutionConfig from job configuration is null. Creating empty config\");\n\t\t\t\texecutionConfig = new ExecutionConfig();\n\t\t\t}\n\t\t} catch (IOException | ClassNotFoundException e) {\n\t\t\tthrow new RuntimeException(\"Could not load ExecutionConfig from Job Configuration: \", e);\n\t\t}\n\n\t\tboolean objectReuseEnabled = executionConfig.isObjectReuseEnabled();\n\n\t\tLOG.debug(\"DataSourceTask object reuse: \" + (objectReuseEnabled ? \"ENABLED\" : \"DISABLED\") + \".\");\n\t\t\n\t\tfinal TypeSerializer<OT> serializer = this.serializerFactory.getSerializer();\n\t\t\n\t\ttry {\n\t\t\t// start all chained tasks\n\t\t\tBatchTask.openChainedTasks(this.chainedTasks, this);\n\t\t\t\n\t\t\t// get input splits to read\n\t\t\tfinal Iterator<InputSplit> splitIterator = getInputSplits();\n\t\t\t\n\t\t\t// for each assigned input split\n\t\t\twhile (!this.taskCanceled && splitIterator.hasNext())\n\t\t\t{\n\t\t\t\t// get start and end\n\t\t\t\tfinal InputSplit split = splitIterator.next();\n\n\t\t\t\tLOG.debug(getLogString(\"Opening input split \" + split.toString()));\n\t\t\t\t\n\t\t\t\tfinal InputFormat<OT, InputSplit> format = this.format;\n\t\t\t\n\t\t\t\t// open input format\n\t\t\t\tformat.open(split);\n\t\n\t\t\t\tLOG.debug(getLogString(\"Starting to read input from split \" + split.toString()));\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tfinal Collector<OT> output = this.output;\n\n\t\t\t\t\tif (objectReuseEnabled) {\n\t\t\t\t\t\tOT reuse1 = serializer.createInstance();\n\t\t\t\t\t\tOT reuse2 = serializer.createInstance();\n\t\t\t\t\t\tOT reuse3 = serializer.createInstance();\n\n\t\t\t\t\t\t// as long as there is data to read\n\t\t\t\t\t\twhile (!this.taskCanceled && !format.reachedEnd()) {\n\n\t\t\t\t\t\t\tOT returned;\n\t\t\t\t\t\t\tif ((returned = format.nextRecord(reuse1)) != null) {\n\t\t\t\t\t\t\t\toutput.collect(returned);\n\n\t\t\t\t\t\t\t\treuse1 = reuse2;\n\t\t\t\t\t\t\t\treuse2 = reuse3;\n\t\t\t\t\t\t\t\treuse3 = returned;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// as long as there is data to read\n\t\t\t\t\t\twhile (!this.taskCanceled && !format.reachedEnd()) {\n\n\t\t\t\t\t\t\tOT returned;\n\t\t\t\t\t\t\tif ((returned = format.nextRecord(serializer.createInstance())) != null) {\n\t\t\t\t\t\t\t\toutput.collect(returned);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (LOG.isDebugEnabled() && !this.taskCanceled) {\n\t\t\t\t\t\tLOG.debug(getLogString(\"Closing input split \" + split.toString()));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\t// close. We close here such that a regular close throwing an exception marks a task as failed.\n\t\t\t\t\tformat.close();\n\t\t\t\t}\n\t\t\t} // end for all input splits\n\n\t\t\t// close the collector. if it is a chaining task collector, it will close its chained tasks\n\t\t\tthis.output.close();\n\n\t\t\t// close all chained tasks letting them report failure\n\t\t\tBatchTask.closeChainedTasks(this.chainedTasks, this);\n\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// close the input, but do not report any exceptions, since we already have another root cause\n\t\t\ttry {\n\t\t\t\tthis.format.close();\n\t\t\t} catch (Throwable ignored) {}\n\n\t\t\tBatchTask.cancelChainedTasks(this.chainedTasks);\n\n\t\t\tex = ExceptionInChainedStubException.exceptionUnwrap(ex);\n\n\t\t\tif (ex instanceof CancelTaskException) {\n\t\t\t\t// forward canceling exception\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\telse if (!this.taskCanceled) {\n\t\t\t\t// drop exception, if the task was canceled\n\t\t\t\tBatchTask.logAndThrowException(ex, this);\n\t\t\t}\n\t\t} finally {\n\t\t\tBatchTask.clearWriters(eventualOutputs);\n\t\t}\n\n\t\tif (!this.taskCanceled) {\n\t\t\tLOG.debug(getLogString(\"Finished data source operator\"));\n\t\t}\n\t\telse {\n\t\t\tLOG.debug(getLogString(\"Data source operator cancelled\"));\n\t\t}\n\t}", "signature": "void invoke()", "full_signature": "@Override public void invoke()", "class_method_signature": "DataSourceTask.invoke()", "testcase": false, "constructor": false, "invocations": ["initInputFormat", "debug", "getLogString", "initOutputs", "getUserCodeClassLoader", "getMessage", "debug", "getLogString", "debug", "getLogString", "isAssignableFrom", "getClass", "setRuntimeContext", "createRuntimeContext", "debug", "getLogString", "readObjectFromConfig", "getJobConfiguration", "getUserCodeClassLoader", "warn", "isObjectReuseEnabled", "debug", "getSerializer", "openChainedTasks", "getInputSplits", "hasNext", "next", "debug", "getLogString", "toString", "open", "debug", "getLogString", "toString", "createInstance", "createInstance", "createInstance", "reachedEnd", "nextRecord", "collect", "reachedEnd", "nextRecord", "createInstance", "collect", "isDebugEnabled", "debug", "getLogString", "toString", "close", "close", "closeChainedTasks", "close", "cancelChainedTasks", "exceptionUnwrap", "logAndThrowException", "clearWriters", "debug", "getLogString", "debug", "getLogString"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}