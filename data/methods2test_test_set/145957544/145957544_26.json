{"test_class": {"identifier": "ResourceBundleContentHelperTest", "superclass": "", "interfaces": "", "fields": [], "file": "kilt-core/src/test/java/de/poiu/kilt/bundlecontent/ResourceBundleContentHelperTest.java"}, "test_case": {"identifier": "testToBundleNameToFilesMap_IgnoreSubDir", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testToBundleNameToFilesMap_IgnoreSubDir() {\n    // preparation\n    final Path ignorableBasePath= Paths.get(\"/some/path/src/main/resources\");\n\n    final List<File> resourceFiles= ImmutableList.of(\n            ignorableBasePath.resolve(\"messages_de.properties\").toFile(),\n            ignorableBasePath.resolve(\"messages_en.properties\").toFile(),\n            ignorableBasePath.resolve(\"options.properties\").toFile(),\n            ignorableBasePath.resolve(\"options_en_US.properties\").toFile(),\n            ignorableBasePath.resolve(\"options_en_GB.properties\").toFile()\n    );\n\n    // execution\n    final ResourceBundleContentHelper helper= new ResourceBundleContentHelper(ignorableBasePath);\n    final Map<String, Map<Language, File>> bundleNameToFilesMap = helper.toBundleNameToFilesMap(resourceFiles);\n\n    System.out.println(bundleNameToFilesMap.keySet());\n    // verification\n    assertThat(bundleNameToFilesMap.keySet()).containsExactly(\"messages\", \"options\");\n    assertThat(bundleNameToFilesMap.get(\"messages\")).containsKeys(Language.of(\"de\"), Language.of(\"en\"));\n    assertThat(bundleNameToFilesMap.get(\"messages\").get(Language.of(\"de\"))).hasName(\"messages_de.properties\");\n    assertThat(bundleNameToFilesMap.get(\"messages\").get(Language.of(\"en\"))).hasName(\"messages_en.properties\");\n    assertThat(bundleNameToFilesMap.get(\"options\")).containsKeys(Language.of(\"\"), Language.of(\"en_US\"), Language.of(\"en_GB\"));\n    assertThat(bundleNameToFilesMap.get(\"options\").get(Language.of(\"\"))).hasName(\"options.properties\");\n    assertThat(bundleNameToFilesMap.get(\"options\").get(Language.of(\"en_US\"))).hasName(\"options_en_US.properties\");\n    assertThat(bundleNameToFilesMap.get(\"options\").get(Language.of(\"en_GB\"))).hasName(\"options_en_GB.properties\");\n  }", "signature": "void testToBundleNameToFilesMap_IgnoreSubDir()", "full_signature": "@Test public void testToBundleNameToFilesMap_IgnoreSubDir()", "class_method_signature": "ResourceBundleContentHelperTest.testToBundleNameToFilesMap_IgnoreSubDir()", "testcase": true, "constructor": false, "invocations": ["get", "of", "toFile", "resolve", "toFile", "resolve", "toFile", "resolve", "toFile", "resolve", "toFile", "resolve", "toBundleNameToFilesMap", "println", "keySet", "containsExactly", "assertThat", "keySet", "containsKeys", "assertThat", "get", "of", "of", "hasName", "assertThat", "get", "get", "of", "hasName", "assertThat", "get", "get", "of", "containsKeys", "assertThat", "get", "of", "of", "of", "hasName", "assertThat", "get", "get", "of", "hasName", "assertThat", "get", "get", "of", "hasName", "assertThat", "get", "get", "of"]}, "focal_class": {"identifier": "ResourceBundleContentHelper", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER= LogManager.getLogger();", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER= LogManager.getLogger()", "var_name": "LOGGER"}, {"original_string": "protected static final Pattern PATTERN_RESOURCE_BUNDLE_FILE_NAME= Pattern.compile(\n        \"(?<BUNDLE>[a-zA-Z0-9\\\\-]+)\"                                      //the bundle basename (mandatory)\n      + \"(?:_\"                                                            //ignore the underscore of the optional LANG\n      +   \"(?<LOCALE>\"                                                    //a group capturing all locale parts (LANG, SCRIPT, COUNTRY and VARIANT)\n      +     \"(?<LANG>[a-zA-Z]{2,8})\"                                        //the optional LANG\n      +     \"(?:_\"                                                          //ignore the underscore of the optional SCRIPT\n      +       \"(?<SCRIPT>[a-zA-Z]{4})\"                                      //the optional SCRIPT\n      +     \")?\"\n      +     \"(?:_\"                                                          //ignore the underscore of the optional COUNTRY\n      +       \"(?<COUNTRY>[a-zA-Z]{2}|[0-9]{3})\"                            //the optional COUNTRY\n      +     \")?\"\n      +     \"(?:_\"                                                          //ignore the underscore of the optional VARIANT\n      +       \"(?<VARIANT>[0-9a-zA-Z-]+.)\"                                  //the optional VARIANT\n      +     \")?\"\n      +   \")\"\n      + \")?\"\n      + \"\\\\.properties\"                                                   // the file must always have the suffix .properties\n    , Pattern.UNICODE_CHARACTER_CLASS);", "modifier": "protected static final", "type": "Pattern", "declarator": "PATTERN_RESOURCE_BUNDLE_FILE_NAME= Pattern.compile(\n        \"(?<BUNDLE>[a-zA-Z0-9\\\\-]+)\"                                      //the bundle basename (mandatory)\n      + \"(?:_\"                                                            //ignore the underscore of the optional LANG\n      +   \"(?<LOCALE>\"                                                    //a group capturing all locale parts (LANG, SCRIPT, COUNTRY and VARIANT)\n      +     \"(?<LANG>[a-zA-Z]{2,8})\"                                        //the optional LANG\n      +     \"(?:_\"                                                          //ignore the underscore of the optional SCRIPT\n      +       \"(?<SCRIPT>[a-zA-Z]{4})\"                                      //the optional SCRIPT\n      +     \")?\"\n      +     \"(?:_\"                                                          //ignore the underscore of the optional COUNTRY\n      +       \"(?<COUNTRY>[a-zA-Z]{2}|[0-9]{3})\"                            //the optional COUNTRY\n      +     \")?\"\n      +     \"(?:_\"                                                          //ignore the underscore of the optional VARIANT\n      +       \"(?<VARIANT>[0-9a-zA-Z-]+.)\"                                  //the optional VARIANT\n      +     \")?\"\n      +   \")\"\n      + \")?\"\n      + \"\\\\.properties\"                                                   // the file must always have the suffix .properties\n    , Pattern.UNICODE_CHARACTER_CLASS)", "var_name": "PATTERN_RESOURCE_BUNDLE_FILE_NAME"}, {"original_string": "private Path ignorableBasePath= Paths.get(\"\");", "modifier": "private", "type": "Path", "declarator": "ignorableBasePath= Paths.get(\"\")", "var_name": "ignorableBasePath"}], "methods": [{"identifier": "ResourceBundleContentHelper", "parameters": "()", "modifiers": "public", "return": "", "signature": " ResourceBundleContentHelper()", "full_signature": "public  ResourceBundleContentHelper()", "class_method_signature": "ResourceBundleContentHelper.ResourceBundleContentHelper()", "testcase": false, "constructor": true}, {"identifier": "ResourceBundleContentHelper", "parameters": "(final File ignorableBasePath)", "modifiers": "public", "return": "", "signature": " ResourceBundleContentHelper(final File ignorableBasePath)", "full_signature": "public  ResourceBundleContentHelper(final File ignorableBasePath)", "class_method_signature": "ResourceBundleContentHelper.ResourceBundleContentHelper(final File ignorableBasePath)", "testcase": false, "constructor": true}, {"identifier": "ResourceBundleContentHelper", "parameters": "(final Path ignorableBasePath)", "modifiers": "public", "return": "", "signature": " ResourceBundleContentHelper(final Path ignorableBasePath)", "full_signature": "public  ResourceBundleContentHelper(final Path ignorableBasePath)", "class_method_signature": "ResourceBundleContentHelper.ResourceBundleContentHelper(final Path ignorableBasePath)", "testcase": false, "constructor": true}, {"identifier": "toBundleNameToFilesMap", "parameters": "(final Collection<File> propertyFiles)", "modifiers": "public", "return": "Map<String, Map<Language, File>>", "signature": "Map<String, Map<Language, File>> toBundleNameToFilesMap(final Collection<File> propertyFiles)", "full_signature": "public Map<String, Map<Language, File>> toBundleNameToFilesMap(final Collection<File> propertyFiles)", "class_method_signature": "ResourceBundleContentHelper.toBundleNameToFilesMap(final Collection<File> propertyFiles)", "testcase": false, "constructor": false}, {"identifier": "getBundlePrefix", "parameters": "(final Path path)", "modifiers": "protected", "return": "String", "signature": "String getBundlePrefix(final Path path)", "full_signature": "protected String getBundlePrefix(final Path path)", "class_method_signature": "ResourceBundleContentHelper.getBundlePrefix(final Path path)", "testcase": false, "constructor": false}, {"identifier": "getBundlePrefix", "parameters": "(final File file)", "modifiers": "protected", "return": "String", "signature": "String getBundlePrefix(final File file)", "full_signature": "protected String getBundlePrefix(final File file)", "class_method_signature": "ResourceBundleContentHelper.getBundlePrefix(final File file)", "testcase": false, "constructor": false}], "file": "kilt-core/src/main/java/de/poiu/kilt/bundlecontent/ResourceBundleContentHelper.java"}, "focal_method": {"identifier": "toBundleNameToFilesMap", "parameters": "(final Collection<File> propertyFiles)", "modifiers": "public", "return": "Map<String, Map<Language, File>>", "body": "public Map<String, Map<Language, File>> toBundleNameToFilesMap(final Collection<File> propertyFiles) {\n    Require.nonNull(propertyFiles);\n    final Map<String, Map<Language, File>> result= new LinkedHashMap<>();\n\n    for (final File file : propertyFiles) {\n      final Matcher matcher = PATTERN_RESOURCE_BUNDLE_FILE_NAME.matcher(file.getName());\n      if (matcher.matches()) {\n        final String bundleBasename= matcher.group(\"BUNDLE\");\n        final String langCode= matcher.group(\"LOCALE\");\n        final Language language= Language.of(langCode != null ? langCode : \"\");\n\n        final String bundlePrefix= getBundlePrefix(file);\n        final String fullBundleName;\n        if (bundlePrefix == null || bundlePrefix.trim().isEmpty()) {\n          fullBundleName= bundleBasename;\n        } else {\n          fullBundleName= bundlePrefix + \"/\" + bundleBasename;\n        }\n\n        if (!result.containsKey(fullBundleName)) {\n          result.put(fullBundleName, new LinkedHashMap<>());\n        }\n\n        final Map<Language, File> langToFileMap= result.get(fullBundleName);\n        if (langToFileMap.containsKey(language)) {\n          throw new RuntimeException(\"Language \"+langCode+\" already in map. Should never happen.\");\n        }\n        langToFileMap.put(language, file);\n      } else {\n        LOGGER.log(Level.WARN, \"File {} doesn't match the expected pattern. It will not be processed! Does your file name end with .properties?\", file.getAbsolutePath());\n      }\n    }\n\n    return result;\n  }", "signature": "Map<String, Map<Language, File>> toBundleNameToFilesMap(final Collection<File> propertyFiles)", "full_signature": "public Map<String, Map<Language, File>> toBundleNameToFilesMap(final Collection<File> propertyFiles)", "class_method_signature": "ResourceBundleContentHelper.toBundleNameToFilesMap(final Collection<File> propertyFiles)", "testcase": false, "constructor": false, "invocations": ["nonNull", "matcher", "getName", "matches", "group", "group", "of", "getBundlePrefix", "isEmpty", "trim", "containsKey", "put", "get", "containsKey", "put", "log", "getAbsolutePath"]}, "repository": {"repo_id": 145957544, "url": "https://github.com/hupfdule/kilt", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 31, "size": 782, "license": "licensed"}}