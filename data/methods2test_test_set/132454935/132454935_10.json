{"test_class": {"identifier": "AccountStateServiceImplTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private AccountStateService accountStateService;", "modifier": "private", "type": "AccountStateService", "declarator": "accountStateService", "var_name": "accountStateService"}, {"original_string": "private Accounts accounts;", "modifier": "private", "type": "Accounts", "declarator": "accounts", "var_name": "accounts"}, {"original_string": "private AccountAddress address;", "modifier": "private", "type": "AccountAddress", "declarator": "address", "var_name": "address"}], "file": "elrond-core/src/test/java/network/elrond/account/AccountStateServiceImplTest.java"}, "test_case": {"identifier": "testGenerateGenesisBlock", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGenerateGenesisBlock() throws IOException, ClassNotFoundException {\n        AccountsContext accountsContext = new AccountsContext();\n        AppState appState = new AppState();\n        AppContext appContext = new AppContext();\n        appContext.setPort(4000);\n        appContext.setMasterPeerPort(4000);\n        appContext.setNodeName(\"node\");\n        PrivateKey privateKey = new PrivateKey();\n        PublicKey publicKey = new PublicKey(new PrivateKey());\n        appContext.setPrivateKey(privateKey);\n        Shard shard = AppServiceProvider.getShardingService().getShard(publicKey.getValue());\n        accountsContext.setShard(shard);\n        appState.setShard(shard);\n        appState.setConnection( AppServiceProvider.getP2PConnectionService().createConnection(appContext));\n\n        accounts = new Accounts(accountsContext, new AccountsPersistenceUnit<>(\"\"));\n        String initialAddress = Util.byteArrayToHexString(publicKey.getValue());\n\n        accountStateService.generateGenesisBlock(initialAddress, BigInteger.TEN, appState, appContext);\n        AccountState state = accountStateService.getAccountState(AppServiceProvider.getShardingService().getAddressForMinting(accounts.getShard()), accounts);\n        Assert.assertNotNull(state);\n        Assert.assertTrue(state.getBalance().compareTo(Util.VALUE_MINTING) == 0);\n        Assert.assertTrue(state.getBalance().compareTo(Util.VALUE_MINTING) == 0);\n    }", "signature": "void testGenerateGenesisBlock()", "full_signature": "@Test public void testGenerateGenesisBlock()", "class_method_signature": "AccountStateServiceImplTest.testGenerateGenesisBlock()", "testcase": true, "constructor": false, "invocations": ["setPort", "setMasterPeerPort", "setNodeName", "setPrivateKey", "getShard", "getShardingService", "getValue", "setShard", "setShard", "setConnection", "createConnection", "getP2PConnectionService", "byteArrayToHexString", "getValue", "generateGenesisBlock", "getAccountState", "getAddressForMinting", "getShardingService", "getShard", "assertNotNull", "assertTrue", "compareTo", "getBalance", "assertTrue", "compareTo", "getBalance"]}, "focal_class": {"identifier": "AccountStateServiceImpl", "superclass": "", "interfaces": "implements AccountStateService", "fields": [{"original_string": "private static final Logger logger = LogManager.getLogger(AccountStateServiceImpl.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LogManager.getLogger(AccountStateServiceImpl.class)", "var_name": "logger"}], "methods": [{"identifier": "getOrCreateAccountState", "parameters": "(AccountAddress address, Accounts accounts)", "modifiers": "@Override public synchronized", "return": "AccountState", "signature": "AccountState getOrCreateAccountState(AccountAddress address, Accounts accounts)", "full_signature": "@Override public synchronized AccountState getOrCreateAccountState(AccountAddress address, Accounts accounts)", "class_method_signature": "AccountStateServiceImpl.getOrCreateAccountState(AccountAddress address, Accounts accounts)", "testcase": false, "constructor": false}, {"identifier": "getAccountState", "parameters": "(AccountAddress address, Accounts accounts)", "modifiers": "@Override public synchronized", "return": "AccountState", "signature": "AccountState getAccountState(AccountAddress address, Accounts accounts)", "full_signature": "@Override public synchronized AccountState getAccountState(AccountAddress address, Accounts accounts)", "class_method_signature": "AccountStateServiceImpl.getAccountState(AccountAddress address, Accounts accounts)", "testcase": false, "constructor": false}, {"identifier": "rollbackAccountStates", "parameters": "(Accounts accounts)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void rollbackAccountStates(Accounts accounts)", "full_signature": "@Override public synchronized void rollbackAccountStates(Accounts accounts)", "class_method_signature": "AccountStateServiceImpl.rollbackAccountStates(Accounts accounts)", "testcase": false, "constructor": false}, {"identifier": "commitAccountStates", "parameters": "(Accounts accounts)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void commitAccountStates(Accounts accounts)", "full_signature": "@Override public synchronized void commitAccountStates(Accounts accounts)", "class_method_signature": "AccountStateServiceImpl.commitAccountStates(Accounts accounts)", "testcase": false, "constructor": false}, {"identifier": "setAccountState", "parameters": "(AccountAddress address, AccountState state, Accounts accounts)", "modifiers": "@Override public synchronized", "return": "void", "signature": "void setAccountState(AccountAddress address, AccountState state, Accounts accounts)", "full_signature": "@Override public synchronized void setAccountState(AccountAddress address, AccountState state, Accounts accounts)", "class_method_signature": "AccountStateServiceImpl.setAccountState(AccountAddress address, AccountState state, Accounts accounts)", "testcase": false, "constructor": false}, {"identifier": "convertAccountStateToRLP", "parameters": "(AccountState accountState)", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] convertAccountStateToRLP(AccountState accountState)", "full_signature": "@Override public byte[] convertAccountStateToRLP(AccountState accountState)", "class_method_signature": "AccountStateServiceImpl.convertAccountStateToRLP(AccountState accountState)", "testcase": false, "constructor": false}, {"identifier": "convertToAccountStateFromRLP", "parameters": "(byte[] data)", "modifiers": "@Override public", "return": "AccountState", "signature": "AccountState convertToAccountStateFromRLP(byte[] data)", "full_signature": "@Override public AccountState convertToAccountStateFromRLP(byte[] data)", "class_method_signature": "AccountStateServiceImpl.convertToAccountStateFromRLP(byte[] data)", "testcase": false, "constructor": false}, {"identifier": "initialMintingToKnownAddress", "parameters": "(Accounts accounts)", "modifiers": "@Override public", "return": "void", "signature": "void initialMintingToKnownAddress(Accounts accounts)", "full_signature": "@Override public void initialMintingToKnownAddress(Accounts accounts)", "class_method_signature": "AccountStateServiceImpl.initialMintingToKnownAddress(Accounts accounts)", "testcase": false, "constructor": false}, {"identifier": "generateGenesisBlock", "parameters": "(String initialAddress, BigInteger initialValue, AppState state, AppContext context)", "modifiers": "@Override public", "return": "Fun.Tuple2<Block, Transaction>", "signature": "Fun.Tuple2<Block, Transaction> generateGenesisBlock(String initialAddress, BigInteger initialValue, AppState state, AppContext context)", "full_signature": "@Override public Fun.Tuple2<Block, Transaction> generateGenesisBlock(String initialAddress, BigInteger initialValue, AppState state, AppContext context)", "class_method_signature": "AccountStateServiceImpl.generateGenesisBlock(String initialAddress, BigInteger initialValue, AppState state, AppContext context)", "testcase": false, "constructor": false}], "file": "elrond-core/src/main/java/network/elrond/account/AccountStateServiceImpl.java"}, "focal_method": {"identifier": "generateGenesisBlock", "parameters": "(String initialAddress, BigInteger initialValue, AppState state, AppContext context)", "modifiers": "@Override public", "return": "Fun.Tuple2<Block, Transaction>", "body": "@Override\n\tpublic Fun.Tuple2<Block, Transaction> generateGenesisBlock(String initialAddress, BigInteger initialValue, AppState state, AppContext context) {\n        logger.traceEntry(\"params: {} {} {} {}\", initialAddress, initialValue, state, context);\n\n        PrivateKey privateKey = context.getPrivateKey();\n\n        Util.check(!(initialAddress == null || initialAddress.isEmpty()), \"initialAddress!=null\");\n        Util.check(!(initialValue.compareTo(BigInteger.ZERO) < 0), \"initialValue is less than zero\");\n        Util.check(privateKey != null, \"privateKey!=null\");\n\n        if (initialValue.compareTo(Util.VALUE_MINTING) > 0) {\n            initialValue = Util.VALUE_MINTING;\n        }\n\n        PrivateKey mintingPrivateKey = AppServiceProvider.getShardingService().getPrivateKeyForMinting(state.getShard());\n        PublicKey mintingPublicKey = AppServiceProvider.getShardingService().getPublicKeyForMinting(state.getShard());\n\n        logger.trace(\"Creating mint transaction...\");\n        Transaction transactionMint = AppServiceProvider.getTransactionService().generateTransaction(mintingPublicKey,\n                new PublicKey(Util.hexStringToByteArray(initialAddress)), initialValue, BigInteger.ZERO);\n        logger.trace(\"Signing mint transaction...\");\n        AppServiceProvider.getTransactionService().signTransaction(transactionMint, mintingPrivateKey.getValue(), mintingPublicKey.getValue());\n\n        logger.trace(\"Generating genesis block...\");\n        Block genesisBlock = new Block();\n        genesisBlock.setShard(state.getShard());\n        genesisBlock.setNonce(BigInteger.ZERO);\n\n        BlockUtil.addTransactionInBlock(genesisBlock, transactionMint);\n\n        logger.trace(\"Setting timestamp and round...\");\n        NTPClient ntpClient = state.getNtpClient();\n        genesisBlock.setTimestamp(AppServiceProvider.getChronologyService().getSynchronizedTime(ntpClient));\n        genesisBlock.setRoundIndex(0);\n\n        List<String> nodeList = new ArrayList<>();\n\n        String self = state.getConnection().getPeer().peerID().toString();\n        nodeList.add(self);\n\n        genesisBlock.setPeers(nodeList);\n\n        logger.debug(\"done added {} peers to genesis block\", genesisBlock.getPeers());\n\n        logger.trace(\"Computing state root hash...\");\n        try {\n\n            AccountsContext accountsContext = new AccountsContext();\n            accountsContext.setShard(state.getShard());\n            Accounts accountsTemp = new Accounts(accountsContext, new AccountsPersistenceUnit<>(accountsContext.getDatabasePath()));\n\n            ExecutionService executionService = AppServiceProvider.getExecutionService();\n            ExecutionReport executionReport = executionService.processTransaction(transactionMint, accountsTemp);\n            if (!executionReport.isOk()) {\n                return logger.traceExit((Fun.Tuple2<Block, Transaction>) null);\n            }\n            genesisBlock.setAppStateHash(accountsTemp.getAccountsPersistenceUnit().getRootHash());\n            AppBlockManager.instance().signBlock(genesisBlock, privateKey);\n            accountsTemp.getAccountsPersistenceUnit().close();\n            logger.trace(\"Genesis block created!\");\n        } catch (Exception ex) {\n            logger.catching(ex);\n            logger.traceExit((Fun.Tuple2<Block, Transaction>) null);\n        }\n\n        return logger.traceExit(new Fun.Tuple2<>(genesisBlock, transactionMint));\n    }", "signature": "Fun.Tuple2<Block, Transaction> generateGenesisBlock(String initialAddress, BigInteger initialValue, AppState state, AppContext context)", "full_signature": "@Override public Fun.Tuple2<Block, Transaction> generateGenesisBlock(String initialAddress, BigInteger initialValue, AppState state, AppContext context)", "class_method_signature": "AccountStateServiceImpl.generateGenesisBlock(String initialAddress, BigInteger initialValue, AppState state, AppContext context)", "testcase": false, "constructor": false, "invocations": ["traceEntry", "getPrivateKey", "check", "isEmpty", "check", "compareTo", "check", "compareTo", "getPrivateKeyForMinting", "getShardingService", "getShard", "getPublicKeyForMinting", "getShardingService", "getShard", "trace", "generateTransaction", "getTransactionService", "hexStringToByteArray", "trace", "signTransaction", "getTransactionService", "getValue", "getValue", "trace", "setShard", "getShard", "setNonce", "addTransactionInBlock", "trace", "getNtpClient", "setTimestamp", "getSynchronizedTime", "getChronologyService", "setRoundIndex", "toString", "peerID", "getPeer", "getConnection", "add", "setPeers", "debug", "getPeers", "trace", "setShard", "getShard", "getDatabasePath", "getExecutionService", "processTransaction", "isOk", "traceExit", "setAppStateHash", "getRootHash", "getAccountsPersistenceUnit", "signBlock", "instance", "close", "getAccountsPersistenceUnit", "trace", "catching", "traceExit", "traceExit"]}, "repository": {"repo_id": 132454935, "url": "https://github.com/ElrondNetwork/elrond-node-prototype", "language": "Java", "is_fork": false, "fork_count": 4, "stargazer_count": 16, "size": 16635, "license": "licensed"}}