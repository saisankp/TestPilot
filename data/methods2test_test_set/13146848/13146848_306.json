{"test_class": {"identifier": "FontUtilsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static PDFont HELVETICA = FontUtils.HELVETICA;", "modifier": "private static", "type": "PDFont", "declarator": "HELVETICA = FontUtils.HELVETICA", "var_name": "HELVETICA"}], "file": "sejda-sambox/src/test/java/org/sejda/impl/sambox/util/FontUtilsTest.java"}, "test_case": {"identifier": "resolveFontsWhenTextRepeats", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void resolveFontsWhenTextRepeats() {\n        PDDocument doc = new PDDocument();\n        List<TextWithFont> textAndFonts = FontUtils.resolveFonts(\"123\u03b1456\u03b1789\", HELVETICA, doc);\n\n        assertThat(textAndFonts.get(0).getFont().getName(), is(\"Helvetica\"));\n        assertThat(textAndFonts.get(0).getText(), is(\"123\"));\n\n        assertThat(textAndFonts.get(1).getFont().getName(), is(not(\"Helvetica\")));\n        assertThat(textAndFonts.get(1).getText(), is(\"\u03b1\"));\n\n        assertThat(textAndFonts.get(2).getFont().getName(), is(\"Helvetica\"));\n        assertThat(textAndFonts.get(2).getText(), is(\"456\"));\n\n        assertThat(textAndFonts.get(3).getFont().getName(), is(not(\"Helvetica\")));\n        assertThat(textAndFonts.get(3).getText(), is(\"\u03b1\"));\n    }", "signature": "void resolveFontsWhenTextRepeats()", "full_signature": "@Test public void resolveFontsWhenTextRepeats()", "class_method_signature": "FontUtilsTest.resolveFontsWhenTextRepeats()", "testcase": true, "constructor": false, "invocations": ["resolveFonts", "assertThat", "getName", "getFont", "get", "is", "assertThat", "getText", "get", "is", "assertThat", "getName", "getFont", "get", "is", "not", "assertThat", "getText", "get", "is", "assertThat", "getName", "getFont", "get", "is", "assertThat", "getText", "get", "is", "assertThat", "getName", "getFont", "get", "is", "not", "assertThat", "getText", "get", "is"]}, "focal_class": {"identifier": "FontUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(FontUtils.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(FontUtils.class)", "var_name": "LOG"}, {"original_string": "private static final Map<StandardType1Font, PDType1Font> STANDARD_TYPE1_FONTS;", "modifier": "private static final", "type": "Map<StandardType1Font, PDType1Font>", "declarator": "STANDARD_TYPE1_FONTS", "var_name": "STANDARD_TYPE1_FONTS"}, {"original_string": "public static PDFont HELVETICA = PDType1Font.HELVETICA;", "modifier": "public static", "type": "PDFont", "declarator": "HELVETICA = PDType1Font.HELVETICA", "var_name": "HELVETICA"}, {"original_string": "public static final FontResource[] TYPE0FONTS;", "modifier": "public static final", "type": "FontResource[]", "declarator": "TYPE0FONTS", "var_name": "TYPE0FONTS"}, {"original_string": "private static Map<PDDocument, Map<String, PDFont>> loadedFontCache = new HashMap<>();", "modifier": "private static", "type": "Map<PDDocument, Map<String, PDFont>>", "declarator": "loadedFontCache = new HashMap<>()", "var_name": "loadedFontCache"}], "methods": [{"identifier": "FontUtils", "parameters": "()", "modifiers": "private", "return": "", "signature": " FontUtils()", "full_signature": "private  FontUtils()", "class_method_signature": "FontUtils.FontUtils()", "testcase": false, "constructor": true}, {"identifier": "getStandardType1Font", "parameters": "(StandardType1Font st1Font)", "modifiers": "public static", "return": "PDType1Font", "signature": "PDType1Font getStandardType1Font(StandardType1Font st1Font)", "full_signature": "public static PDType1Font getStandardType1Font(StandardType1Font st1Font)", "class_method_signature": "FontUtils.getStandardType1Font(StandardType1Font st1Font)", "testcase": false, "constructor": false}, {"identifier": "fontOrFallback", "parameters": "(String text, PDFont font, PDDocument document)", "modifiers": "public static", "return": "PDFont", "signature": "PDFont fontOrFallback(String text, PDFont font, PDDocument document)", "full_signature": "public static PDFont fontOrFallback(String text, PDFont font, PDDocument document)", "class_method_signature": "FontUtils.fontOrFallback(String text, PDFont font, PDDocument document)", "testcase": false, "constructor": false}, {"identifier": "clearLoadedFontCache", "parameters": "()", "modifiers": "public static", "return": "void", "signature": "void clearLoadedFontCache()", "full_signature": "public static void clearLoadedFontCache()", "class_method_signature": "FontUtils.clearLoadedFontCache()", "testcase": false, "constructor": false}, {"identifier": "clearLoadedFontCache", "parameters": "(PDDocument document)", "modifiers": "public static", "return": "void", "signature": "void clearLoadedFontCache(PDDocument document)", "full_signature": "public static void clearLoadedFontCache(PDDocument document)", "class_method_signature": "FontUtils.clearLoadedFontCache(PDDocument document)", "testcase": false, "constructor": false}, {"identifier": "loadFont", "parameters": "(PDDocument document, FontResource font)", "modifiers": "public static", "return": "PDFont", "signature": "PDFont loadFont(PDDocument document, FontResource font)", "full_signature": "public static PDFont loadFont(PDDocument document, FontResource font)", "class_method_signature": "FontUtils.loadFont(PDDocument document, FontResource font)", "testcase": false, "constructor": false}, {"identifier": "findFontFor", "parameters": "(PDDocument document, String text)", "modifiers": "public static final", "return": "PDFont", "signature": "PDFont findFontFor(PDDocument document, String text)", "full_signature": "public static final PDFont findFontFor(PDDocument document, String text)", "class_method_signature": "FontUtils.findFontFor(PDDocument document, String text)", "testcase": false, "constructor": false}, {"identifier": "isOnlyWhitespace", "parameters": "(String text)", "modifiers": "public static", "return": "boolean", "signature": "boolean isOnlyWhitespace(String text)", "full_signature": "public static boolean isOnlyWhitespace(String text)", "class_method_signature": "FontUtils.isOnlyWhitespace(String text)", "testcase": false, "constructor": false}, {"identifier": "removeWhitespace", "parameters": "(String text)", "modifiers": "public static", "return": "String", "signature": "String removeWhitespace(String text)", "full_signature": "public static String removeWhitespace(String text)", "class_method_signature": "FontUtils.removeWhitespace(String text)", "testcase": false, "constructor": false}, {"identifier": "canDisplaySpace", "parameters": "(PDFont font)", "modifiers": "public static", "return": "boolean", "signature": "boolean canDisplaySpace(PDFont font)", "full_signature": "public static boolean canDisplaySpace(PDFont font)", "class_method_signature": "FontUtils.canDisplaySpace(PDFont font)", "testcase": false, "constructor": false}, {"identifier": "canDisplay", "parameters": "(String text, PDFont font)", "modifiers": "public static", "return": "boolean", "signature": "boolean canDisplay(String text, PDFont font)", "full_signature": "public static boolean canDisplay(String text, PDFont font)", "class_method_signature": "FontUtils.canDisplay(String text, PDFont font)", "testcase": false, "constructor": false}, {"identifier": "calculateBBoxHeight", "parameters": "(String text, PDFont font)", "modifiers": "public static", "return": "double", "signature": "double calculateBBoxHeight(String text, PDFont font)", "full_signature": "public static double calculateBBoxHeight(String text, PDFont font)", "class_method_signature": "FontUtils.calculateBBoxHeight(String text, PDFont font)", "testcase": false, "constructor": false}, {"identifier": "isBold", "parameters": "(PDFont font)", "modifiers": "public static", "return": "boolean", "signature": "boolean isBold(PDFont font)", "full_signature": "public static boolean isBold(PDFont font)", "class_method_signature": "FontUtils.isBold(PDFont font)", "testcase": false, "constructor": false}, {"identifier": "isItalic", "parameters": "(PDFont font)", "modifiers": "public static", "return": "boolean", "signature": "boolean isItalic(PDFont font)", "full_signature": "public static boolean isItalic(PDFont font)", "class_method_signature": "FontUtils.isItalic(PDFont font)", "testcase": false, "constructor": false}, {"identifier": "wrapLines", "parameters": "(String rawLabel, PDFont font, float fontSize, double maxWidth,\n            PDDocument document)", "modifiers": "public static", "return": "List<String>", "signature": "List<String> wrapLines(String rawLabel, PDFont font, float fontSize, double maxWidth,\n            PDDocument document)", "full_signature": "public static List<String> wrapLines(String rawLabel, PDFont font, float fontSize, double maxWidth,\n            PDDocument document)", "class_method_signature": "FontUtils.wrapLines(String rawLabel, PDFont font, float fontSize, double maxWidth,\n            PDDocument document)", "testcase": false, "constructor": false}, {"identifier": "getSimpleStringWidth", "parameters": "(String text, PDFont font, double fontSize)", "modifiers": "public static", "return": "double", "signature": "double getSimpleStringWidth(String text, PDFont font, double fontSize)", "full_signature": "public static double getSimpleStringWidth(String text, PDFont font, double fontSize)", "class_method_signature": "FontUtils.getSimpleStringWidth(String text, PDFont font, double fontSize)", "testcase": false, "constructor": false}, {"identifier": "resolveFonts", "parameters": "(String label, PDFont font, PDDocument document)", "modifiers": "public static", "return": "List<TextWithFont>", "signature": "List<TextWithFont> resolveFonts(String label, PDFont font, PDDocument document)", "full_signature": "public static List<TextWithFont> resolveFonts(String label, PDFont font, PDDocument document)", "class_method_signature": "FontUtils.resolveFonts(String label, PDFont font, PDDocument document)", "testcase": false, "constructor": false}, {"identifier": "removeUnsupportedCharacters", "parameters": "(String text, PDDocument doc)", "modifiers": "public static", "return": "String", "signature": "String removeUnsupportedCharacters(String text, PDDocument doc)", "full_signature": "public static String removeUnsupportedCharacters(String text, PDDocument doc)", "class_method_signature": "FontUtils.removeUnsupportedCharacters(String text, PDDocument doc)", "testcase": false, "constructor": false}, {"identifier": "replaceUnsupportedCharacters", "parameters": "(String text, PDDocument doc, String replacement)", "modifiers": "public static", "return": "String", "signature": "String replaceUnsupportedCharacters(String text, PDDocument doc, String replacement)", "full_signature": "public static String replaceUnsupportedCharacters(String text, PDDocument doc, String replacement)", "class_method_signature": "FontUtils.replaceUnsupportedCharacters(String text, PDDocument doc, String replacement)", "testcase": false, "constructor": false}], "file": "sejda-sambox/src/main/java/org/sejda/impl/sambox/util/FontUtils.java"}, "focal_method": {"identifier": "resolveFonts", "parameters": "(String label, PDFont font, PDDocument document)", "modifiers": "public static", "return": "List<TextWithFont>", "body": "public static List<TextWithFont> resolveFonts(String label, PDFont font, PDDocument document) {\n        PDFont currentFont = font;\n        StringBuilder currentString = new StringBuilder();\n\n        // we want to keep the insertion order\n        List<TextWithFont> result = new ArrayList<>();\n        Iterator<Integer> codePointIterator = visualToLogical(label).codePoints().iterator();\n        while (codePointIterator.hasNext()) {\n            int codePoint = codePointIterator.next();\n\n            String s = new String(Character.toChars(codePoint));\n\n            PDFont f = fontOrFallback(s, font, document);\n            if (s.equals(\" \")) {\n                // we want space to be a separate text item\n                // because some fonts are missing the space glyph\n                // so we'll handle it separate from the other chars\n\n                // some fonts don't have glyphs for space.\n                // figure out if that's the case and switch to a standard font as fallback\n                if (!FontUtils.canDisplaySpace(f)) {\n                    f = FontUtils.getStandardType1Font(StandardType1Font.HELVETICA);\n                }\n\n                if (f != currentFont) {\n                    // end current string, before space\n                    if (currentString.length() > 0) {\n                        result.add(new TextWithFont(currentString.toString(), currentFont));\n                    }\n\n                    // add space\n                    result.add(new TextWithFont(\" \", f));\n                    currentString = new StringBuilder();\n                    currentFont = f;\n                } else {\n                    currentString.append(s);\n                }\n            } else if (currentFont == f) {\n                currentString.append(s);\n            } else {\n                if (currentString.length() > 0) {\n                    result.add(new TextWithFont(currentString.toString(), currentFont));\n                }\n\n                currentString = new StringBuilder(s);\n                currentFont = f;\n            }\n        }\n\n        result.add(new TextWithFont(currentString.toString(), currentFont));\n\n        for (TextWithFont each : result) {\n            LOG.trace(\"Will write '{}' with {}\", each.getText(), each.getFont());\n        }\n\n        return result;\n    }", "signature": "List<TextWithFont> resolveFonts(String label, PDFont font, PDDocument document)", "full_signature": "public static List<TextWithFont> resolveFonts(String label, PDFont font, PDDocument document)", "class_method_signature": "FontUtils.resolveFonts(String label, PDFont font, PDDocument document)", "testcase": false, "constructor": false, "invocations": ["iterator", "codePoints", "visualToLogical", "hasNext", "next", "toChars", "fontOrFallback", "equals", "canDisplaySpace", "getStandardType1Font", "length", "add", "toString", "add", "append", "append", "length", "add", "toString", "add", "toString", "trace", "getText", "getFont"]}, "repository": {"repo_id": 13146848, "url": "https://github.com/torakiki/sejda", "language": "Java", "is_fork": false, "fork_count": 47, "stargazer_count": 316, "size": 59670, "license": "licensed"}}