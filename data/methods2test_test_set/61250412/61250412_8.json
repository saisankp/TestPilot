{"test_class": {"identifier": "UtilTest", "superclass": "", "interfaces": "", "fields": [], "file": "flatworm-core/src/test/java/com/blackbear/flatworm/UtilTest.java"}, "test_case": {"identifier": "testMultiplePadCharacters", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMultiplePadCharacters() {\n        Map<String, ConversionOptionBO> options = new HashMap<>();\n        options.put(\"pad-character\", new ConversionOptionBO(\"pad-character\", \"0Oo\"));\n        assertEquals(\"f\", Util.justify(\"foo\", \"both\", options, 0));\n        assertEquals(\"f\", Util.justify(\"fooOO00\", \"both\", options, 0));\n        assertEquals(\"f\", Util.justify(\"oofoo\", \"both\", options, 0));\n        assertEquals(\"f\", Util.justify(\"oo00OOfooOO00\", \"both\", options, 0));\n        assertEquals(\"oof\", Util.justify(\"oofoo\", \"left\", options, 0));\n        assertEquals(\"foo\", Util.justify(\"oofoo\", \"right\", options, 0));\n    }", "signature": "void testMultiplePadCharacters()", "full_signature": "@Test public void testMultiplePadCharacters()", "class_method_signature": "UtilTest.testMultiplePadCharacters()", "testcase": true, "constructor": false, "invocations": ["put", "assertEquals", "justify", "assertEquals", "justify", "assertEquals", "justify", "assertEquals", "justify", "assertEquals", "justify", "assertEquals", "justify"]}, "focal_class": {"identifier": "Util", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Pattern numbersOnly = Pattern.compile(\"[\\\\D]+\");", "modifier": "private static", "type": "Pattern", "declarator": "numbersOnly = Pattern.compile(\"[\\\\D]+\")", "var_name": "numbersOnly"}, {"original_string": "private static Pattern lettersOnly = Pattern.compile(\"[^A-Za-z]+\");", "modifier": "private static", "type": "Pattern", "declarator": "lettersOnly = Pattern.compile(\"[^A-Za-z]+\")", "var_name": "lettersOnly"}, {"original_string": "private static Pattern numbersOrLettersOnly = Pattern.compile(\"[^A-Za-z0-9]+\");", "modifier": "private static", "type": "Pattern", "declarator": "numbersOrLettersOnly = Pattern.compile(\"[^A-Za-z0-9]+\")", "var_name": "numbersOrLettersOnly"}], "methods": [{"identifier": "split", "parameters": "(String str, char chrSplit, char chrQuote)", "modifiers": "public static", "return": "List<LineToken>", "signature": "List<LineToken> split(String str, char chrSplit, char chrQuote)", "full_signature": "public static List<LineToken> split(String str, char chrSplit, char chrQuote)", "class_method_signature": "Util.split(String str, char chrSplit, char chrQuote)", "testcase": false, "constructor": false}, {"identifier": "formatDate", "parameters": "(Date date, String defaultDateFormat,\n                                    Map<String, ConversionOptionBO> options)", "modifiers": "public static", "return": "String", "signature": "String formatDate(Date date, String defaultDateFormat,\n                                    Map<String, ConversionOptionBO> options)", "full_signature": "public static String formatDate(Date date, String defaultDateFormat,\n                                    Map<String, ConversionOptionBO> options)", "class_method_signature": "Util.formatDate(Date date, String defaultDateFormat,\n                                    Map<String, ConversionOptionBO> options)", "testcase": false, "constructor": false}, {"identifier": "justify", "parameters": "(String str, String value, Map<String, ConversionOptionBO> options,\n                                 int length)", "modifiers": "public static", "return": "String", "signature": "String justify(String str, String value, Map<String, ConversionOptionBO> options,\n                                 int length)", "full_signature": "public static String justify(String str, String value, Map<String, ConversionOptionBO> options,\n                                 int length)", "class_method_signature": "Util.justify(String str, String value, Map<String, ConversionOptionBO> options,\n                                 int length)", "testcase": false, "constructor": false}, {"identifier": "isPadChar", "parameters": "(char c, String strPadChar)", "modifiers": "private static", "return": "boolean", "signature": "boolean isPadChar(char c, String strPadChar)", "full_signature": "private static boolean isPadChar(char c, String strPadChar)", "class_method_signature": "Util.isPadChar(char c, String strPadChar)", "testcase": false, "constructor": false}, {"identifier": "strip", "parameters": "(String str, String value, Map<String, ConversionOptionBO> options)", "modifiers": "public static", "return": "String", "signature": "String strip(String str, String value, Map<String, ConversionOptionBO> options)", "full_signature": "public static String strip(String str, String value, Map<String, ConversionOptionBO> options)", "class_method_signature": "Util.strip(String str, String value, Map<String, ConversionOptionBO> options)", "testcase": false, "constructor": false}, {"identifier": "substring", "parameters": "(String str, String value, Map<String, ConversionOptionBO> options)", "modifiers": "public static", "return": "String", "signature": "String substring(String str, String value, Map<String, ConversionOptionBO> options)", "full_signature": "public static String substring(String str, String value, Map<String, ConversionOptionBO> options)", "class_method_signature": "Util.substring(String str, String value, Map<String, ConversionOptionBO> options)", "testcase": false, "constructor": false}, {"identifier": "defaultValue", "parameters": "(String str, String value, Map<String, ConversionOptionBO> options)", "modifiers": "public static", "return": "String", "signature": "String defaultValue(String str, String value, Map<String, ConversionOptionBO> options)", "full_signature": "public static String defaultValue(String str, String value, Map<String, ConversionOptionBO> options)", "class_method_signature": "Util.defaultValue(String str, String value, Map<String, ConversionOptionBO> options)", "testcase": false, "constructor": false}, {"identifier": "getValue", "parameters": "(Map<String, ConversionOptionBO> options, String key)", "modifiers": "public static", "return": "String", "signature": "String getValue(Map<String, ConversionOptionBO> options, String key)", "full_signature": "public static String getValue(Map<String, ConversionOptionBO> options, String key)", "class_method_signature": "Util.getValue(Map<String, ConversionOptionBO> options, String key)", "testcase": false, "constructor": false}, {"identifier": "tryParseInt", "parameters": "(String value)", "modifiers": "public static", "return": "Integer", "signature": "Integer tryParseInt(String value)", "full_signature": "public static Integer tryParseInt(String value)", "class_method_signature": "Util.tryParseInt(String value)", "testcase": false, "constructor": false}, {"identifier": "tryParseBoolean", "parameters": "(String value)", "modifiers": "public static", "return": "Boolean", "signature": "Boolean tryParseBoolean(String value)", "full_signature": "public static Boolean tryParseBoolean(String value)", "class_method_signature": "Util.tryParseBoolean(String value)", "testcase": false, "constructor": false}, {"identifier": "tryParseBoolean", "parameters": "(String value, boolean defaultValue)", "modifiers": "public static", "return": "Boolean", "signature": "Boolean tryParseBoolean(String value, boolean defaultValue)", "full_signature": "public static Boolean tryParseBoolean(String value, boolean defaultValue)", "class_method_signature": "Util.tryParseBoolean(String value, boolean defaultValue)", "testcase": false, "constructor": false}, {"identifier": "getActualFieldType", "parameters": "(Field field)", "modifiers": "public static", "return": "Class<?>", "signature": "Class<?> getActualFieldType(Field field)", "full_signature": "public static Class<?> getActualFieldType(Field field)", "class_method_signature": "Util.getActualFieldType(Field field)", "testcase": false, "constructor": false}, {"identifier": "findRecordAnnotatedClasses", "parameters": "(Collection<String> packageNames, Class<? extends Annotation> annotationClass)", "modifiers": "public static", "return": "List<Class<?>>", "signature": "List<Class<?>> findRecordAnnotatedClasses(Collection<String> packageNames, Class<? extends Annotation> annotationClass)", "full_signature": "public static List<Class<?>> findRecordAnnotatedClasses(Collection<String> packageNames, Class<? extends Annotation> annotationClass)", "class_method_signature": "Util.findRecordAnnotatedClasses(Collection<String> packageNames, Class<? extends Annotation> annotationClass)", "testcase": false, "constructor": false}, {"identifier": "findClassesInPackage", "parameters": "(String packageName)", "modifiers": "public static", "return": "List<Class<?>>", "signature": "List<Class<?>> findClassesInPackage(String packageName)", "full_signature": "public static List<Class<?>> findClassesInPackage(String packageName)", "class_method_signature": "Util.findClassesInPackage(String packageName)", "testcase": false, "constructor": false}, {"identifier": "findRecordAnnotatedClasses", "parameters": "(String packageName, Class<? extends Annotation> annotationClass)", "modifiers": "public static", "return": "List<Class<?>>", "signature": "List<Class<?>> findRecordAnnotatedClasses(String packageName, Class<? extends Annotation> annotationClass)", "full_signature": "public static List<Class<?>> findRecordAnnotatedClasses(String packageName, Class<? extends Annotation> annotationClass)", "class_method_signature": "Util.findRecordAnnotatedClasses(String packageName, Class<? extends Annotation> annotationClass)", "testcase": false, "constructor": false}, {"identifier": "hasAnnotation", "parameters": "(Class<?> clazz, List<Class<? extends Annotation>> annotationClasses)", "modifiers": "protected static", "return": "boolean", "signature": "boolean hasAnnotation(Class<?> clazz, List<Class<? extends Annotation>> annotationClasses)", "full_signature": "protected static boolean hasAnnotation(Class<?> clazz, List<Class<? extends Annotation>> annotationClasses)", "class_method_signature": "Util.hasAnnotation(Class<?> clazz, List<Class<? extends Annotation>> annotationClasses)", "testcase": false, "constructor": false}, {"identifier": "hasAnnotatedField", "parameters": "(Class<?> clazz, List<Class<? extends Annotation>> annotationClasses)", "modifiers": "protected static", "return": "boolean", "signature": "boolean hasAnnotatedField(Class<?> clazz, List<Class<? extends Annotation>> annotationClasses)", "full_signature": "protected static boolean hasAnnotatedField(Class<?> clazz, List<Class<? extends Annotation>> annotationClasses)", "class_method_signature": "Util.hasAnnotatedField(Class<?> clazz, List<Class<? extends Annotation>> annotationClasses)", "testcase": false, "constructor": false}, {"identifier": "findSubpackages", "parameters": "(String packageName)", "modifiers": "protected static", "return": "List<File>", "signature": "List<File> findSubpackages(String packageName)", "full_signature": "protected static List<File> findSubpackages(String packageName)", "class_method_signature": "Util.findSubpackages(String packageName)", "testcase": false, "constructor": false}, {"identifier": "findRecordAnnotatedClasses", "parameters": "(File directory, String packageName, List<Class<?>> classes, Predicate<Class<?>> predicate)", "modifiers": "public static", "return": "void", "signature": "void findRecordAnnotatedClasses(File directory, String packageName, List<Class<?>> classes, Predicate<Class<?>> predicate)", "full_signature": "public static void findRecordAnnotatedClasses(File directory, String packageName, List<Class<?>> classes, Predicate<Class<?>> predicate)", "class_method_signature": "Util.findRecordAnnotatedClasses(File directory, String packageName, List<Class<?>> classes, Predicate<Class<?>> predicate)", "testcase": false, "constructor": false}], "file": "flatworm-core/src/main/java/com/blackbear/flatworm/Util.java"}, "focal_method": {"identifier": "justify", "parameters": "(String str, String value, Map<String, ConversionOptionBO> options,\n                                 int length)", "modifiers": "public static", "return": "String", "body": "public static String justify(String str, String value, Map<String, ConversionOptionBO> options,\n                                 int length) {\n\n        if (value == null) {\n            value = \"both\";\n        }\n\n        boolean justifyLeft = false;\n        boolean justifyRight = false;\n        if (value.equalsIgnoreCase(\"left\")) {\n            justifyLeft = true;\n        }\n        if (value.equalsIgnoreCase(\"right\")) {\n            justifyRight = true;\n        }\n        if (value.equalsIgnoreCase(\"both\")) {\n            justifyLeft = true;\n            justifyRight = true;\n        }\n\n        String strPadChar = \" \";\n        String arg = getValue(options, \"pad-character\");\n        if (arg != null) {\n            strPadChar = arg;\n        }\n\n        // if length is 0, we are removing padding, otherwise, we are adding it\n        if (0 == length) {\n            // Remove left justification\n            if (justifyLeft) {\n                int i;\n                for (i = str.length() - 1; i > -1 && isPadChar(str.charAt(i), strPadChar); i--)\n                    ;\n                if (i != str.length() - 1) {\n                    str = str.substring(0, i + 1);\n                }\n            }\n\n            // Remove right justification\n            if (justifyRight) {\n                int i;\n                for (i = 0; i < str.length() && isPadChar(str.charAt(i), strPadChar); i++)\n                    ;\n                if (i != 0) {\n                    str = str.substring(i, str.length());\n                }\n            }\n        } else {\n            // pad only with first character\n            strPadChar = strPadChar.substring(0, 1);\n\n            if (str.length() < length) {\n                // Figure out difference in length to create padding string\n                int lenDiff = length - str.length();\n\n                String padding = \"\";\n                for (int i = 0; i < lenDiff; i++)\n                    padding = padding + strPadChar;\n\n                if (justifyLeft) {\n                    str = str + padding;\n                }\n\n                if (justifyRight) {\n                    str = padding + str;\n                }\n            }\n        }\n\n        return str;\n    }", "signature": "String justify(String str, String value, Map<String, ConversionOptionBO> options,\n                                 int length)", "full_signature": "public static String justify(String str, String value, Map<String, ConversionOptionBO> options,\n                                 int length)", "class_method_signature": "Util.justify(String str, String value, Map<String, ConversionOptionBO> options,\n                                 int length)", "testcase": false, "constructor": false, "invocations": ["equalsIgnoreCase", "equalsIgnoreCase", "equalsIgnoreCase", "getValue", "length", "isPadChar", "charAt", "length", "substring", "length", "isPadChar", "charAt", "substring", "length", "substring", "length", "length"]}, "repository": {"repo_id": 61250412, "url": "https://github.com/ahenson/flatworm", "language": "Java", "is_fork": false, "fork_count": 9, "stargazer_count": 10, "size": 429, "license": "licensed"}}