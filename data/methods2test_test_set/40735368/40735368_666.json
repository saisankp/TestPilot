{"test_class": {"identifier": "QuantizerTest", "superclass": "", "interfaces": "", "fields": [], "file": "modules/library/coverage/src/test/java/org/geotools/image/palette/QuantizerTest.java"}, "test_case": {"identifier": "testColorWheelTranslucent", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testColorWheelTranslucent() throws Exception {\n        final int SIZE = 100;\n        BufferedImage bi = new BufferedImage(SIZE, SIZE, BufferedImage.TYPE_4BYTE_ABGR);\n        Graphics2D gr = bi.createGraphics();\n        gr.setRenderingHints(new RenderingHints(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON));\n        for (int s = 0; s < SIZE; s++) {\n            int arcw = SIZE * s / SIZE;\n            int arch = SIZE * s / SIZE;\n            for (int h = 0; h < 360; h++) {\n                float hue = h / 360f;\n                float sat = s / (float) SIZE;\n                Color c = Color.getHSBColor(hue, sat, 1F);\n                c = new Color(c.getRed(), c.getGreen(), c.getBlue(), s * 255 / SIZE);\n                gr.setColor(c);\n                gr.fillArc(SIZE / 2 - arcw / 2, SIZE / 2 - arch / 2, arcw, arch, h, 1);\n            }\n        }\n        gr.dispose();\n\n        // simple palette checks\n        ColorIndexer indexer = new Quantizer(256).buildColorIndexer(bi);\n        IndexColorModel icm = indexer.toIndexColorModel();\n        assertEquals(Transparency.TRANSLUCENT, icm.getTransparency());\n        assertEquals(4, icm.getNumComponents());\n\n        // quantize and check\n        RenderedImage indexed = ColorIndexerDescriptor.create(bi, indexer, null);\n        IndexColorModel icm2 = (IndexColorModel) indexed.getColorModel();\n        assertEquals(icm, icm2);\n\n        // the source image has up to 36000 colors + alpha (the distance has been checked visually)\n        assertImagesSimilar(bi, indexed, 250);\n    }", "signature": "void testColorWheelTranslucent()", "full_signature": "@Test public void testColorWheelTranslucent()", "class_method_signature": "QuantizerTest.testColorWheelTranslucent()", "testcase": true, "constructor": false, "invocations": ["createGraphics", "setRenderingHints", "getHSBColor", "getRed", "getGreen", "getBlue", "setColor", "fillArc", "dispose", "buildColorIndexer", "toIndexColorModel", "assertEquals", "getTransparency", "assertEquals", "getNumComponents", "create", "getColorModel", "assertEquals", "assertImagesSimilar"]}, "focal_class": {"identifier": "Quantizer", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final Logger LOGGER = Logger.getLogger(\"Quantizer\");", "modifier": "static final", "type": "Logger", "declarator": "LOGGER = Logger.getLogger(\"Quantizer\")", "var_name": "LOGGER"}, {"original_string": "boolean MEDIAN_SPLIT = true;", "modifier": "", "type": "boolean", "declarator": "MEDIAN_SPLIT = true", "var_name": "MEDIAN_SPLIT"}, {"original_string": "boolean MEDIAN_BOX = true;", "modifier": "", "type": "boolean", "declarator": "MEDIAN_BOX = true", "var_name": "MEDIAN_BOX"}, {"original_string": "float THRESHOLD = 0.5f;", "modifier": "", "type": "float", "declarator": "THRESHOLD = 0.5f", "var_name": "THRESHOLD"}, {"original_string": "boolean subsample = false;", "modifier": "", "type": "boolean", "declarator": "subsample = false", "var_name": "subsample"}, {"original_string": "int maxColors;", "modifier": "", "type": "int", "declarator": "maxColors", "var_name": "maxColors"}], "methods": [{"identifier": "Quantizer", "parameters": "(int maxColors)", "modifiers": "public", "return": "", "signature": " Quantizer(int maxColors)", "full_signature": "public  Quantizer(int maxColors)", "class_method_signature": "Quantizer.Quantizer(int maxColors)", "testcase": false, "constructor": true}, {"identifier": "subsample", "parameters": "()", "modifiers": "public", "return": "Quantizer", "signature": "Quantizer subsample()", "full_signature": "public Quantizer subsample()", "class_method_signature": "Quantizer.subsample()", "testcase": false, "constructor": false}, {"identifier": "buildColorIndexer", "parameters": "(RenderedImage image)", "modifiers": "public", "return": "ColorIndexer", "signature": "ColorIndexer buildColorIndexer(RenderedImage image)", "full_signature": "public ColorIndexer buildColorIndexer(RenderedImage image)", "class_method_signature": "Quantizer.buildColorIndexer(RenderedImage image)", "testcase": false, "constructor": false}], "file": "modules/library/coverage/src/main/java/org/geotools/image/palette/Quantizer.java"}, "focal_method": {"identifier": "buildColorIndexer", "parameters": "(RenderedImage image)", "modifiers": "public", "return": "ColorIndexer", "body": "public ColorIndexer buildColorIndexer(RenderedImage image) {\n        long totalPixelCount = (long) image.getWidth() * (long) image.getHeight();\n\n        // build a histogram with a subsampling proportional to the log of the image size\n        // (for very small images we pick one pixel every two, from 256 we switch to one every 3,\n        // and so on)\n        int subsx, subsy;\n        if(subsample) {\n            subsx = 1 + (int) (Math.log(image.getWidth()) / Math.log(8));\n            subsy = 1 + (int) (Math.log(image.getHeight()) / Math.log(8));\n        } else {\n            subsx = 1;\n            subsy = 1;\n        }\n        PackedHistogram histogram = new PackedHistogram(image, subsx, subsy);\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(\"Found \" + histogram.size() + \" unique colors with shift \"\n                    + histogram.getShift());\n            LOGGER.fine(\"Histogram count \" + histogram.pixelCount() + \" and pixels \"\n                    + totalPixelCount);\n        }\n        int colors = Math.min(histogram.size(), maxColors);\n\n        // setup the first box, that median cut will split in parts\n        List<Box> boxes = new ArrayList<Box>();\n        boxes.add(new Box(0, histogram.size(), totalPixelCount, histogram, null));\n\n        // perform the box subdivision, first based on box pixel count, then on the box color volume\n        // following up Leptonica's paper suggestions\n        int sortSwitch = Math.round(colors * THRESHOLD);\n        Comparator<Box> comparator = new SumComparator();\n        Comparator<Box> volumeComparator = new VolumeComparator();\n        while (boxes.size() < colors) {\n            // locate a box that we can split\n            int boxIndex = 0;\n            for (; boxIndex < boxes.size(); boxIndex++) {\n                if (boxes.get(boxIndex).colors > 1) {\n                    break;\n                }\n            }\n\n            // did we scan all of them and found nothing? If so, each box has one color, we're done\n            if (boxIndex == boxes.size()) {\n                break;\n            }\n\n            // scan the box contents, find min and max of each color component\n            Box box = boxes.get(boxIndex);\n\n            // get the span of each and sort on the component that has the largest span\n            int spana = box.getAlphaSpan();\n            int spanr = box.getRedSpan();\n            int spang = box.getGreenSpan();\n            int spanb = box.getBlueSpan();\n            SortComponent sort;\n            if (spana > spanr && spana > spanb && spana > spang) {\n                sort = SortComponent.Alpha;\n            } else if (spanr > spang && spanr > spanb) {\n                sort = SortComponent.Red;\n            } else if (spang > spanb) {\n                sort = SortComponent.Green;\n            } else {\n                sort = SortComponent.Blue;\n            }\n            box.sort(sort);\n\n            // split the box and add it to the list\n            Box newBox = box.split();\n            boxes.add(newBox);\n\n            // sort based on size or volume\n            if (comparator instanceof SumComparator && boxes.size() > sortSwitch) {\n                comparator = volumeComparator;\n            }\n            Collections.sort(boxes, comparator);\n        }\n\n        // dump all the boxes\n        if (LOGGER.isLoggable(Level.FINER)) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < boxes.size(); i++) {\n                Box b = boxes.get(i);\n                sb.append(\"Box \" + i + \", pixels: \" + b.sum + \" colors: \" + b.colors + \" volume: \"\n                        + b.getVolume() + \" p*v: \" + b.getVolume() * b.sum);\n            }\n            sb.append(\"\\n\");\n            LOGGER.finer(\"Median cut resulted in the following boxes:\\n\" + sb);\n        }\n        \n        // the png encoder goes bananas if we have a single color palette, in this\n        // case we need to add an entry to the palette\n        if(boxes.size() == 1) {\n            boxes.add(boxes.get(0));\n        }\n\n        // all right, we have the set of boxes, now we have to pick a color from each.\n        // A box might have a single color, but if it has many we have to pick and choose,\n        // in such case we do a weighted sum of each component.\n        // In this phase we use the real colors (so far we worked with the packed ones)\n        PaletteEntry[] palette = new PaletteEntry[boxes.size()];\n        int shift = histogram.getShift();\n        for (int i = 0; i < boxes.size(); i++) {\n            Box box = boxes.get(i);\n            byte r, g, b, a;\n            if (box.colors == 1) {\n                // simple case, no need to mess around with averages\n                int color = histogram.getColor(box.idx);\n                r = (byte) red(color);\n                g = (byte) green(color);\n                b = (byte) blue(color);\n                a = (byte) alpha(color);\n            } else {\n                if (MEDIAN_BOX) {\n                    // just pick the middle one\n                    int color = histogram.getColor(box.idx + box.colors / 2);\n                    r = (byte) red(color);\n                    g = (byte) green(color);\n                    b = (byte) blue(color);\n                    a = (byte) alpha(color);\n                } else {\n                    // compute the weighted sum\n                    final int start = box.idx;\n                    final int end = box.idx + box.colors;\n                    long rs, gs, bs, as, sum;\n                    rs = gs = bs = as = sum = 0;\n                    for (int idx = start; idx < end; idx++) {\n                        int color = histogram.getColor(idx);\n                        long count = histogram.getCount(idx);\n                        rs += red(color) * count;\n                        gs += green(color) * count;\n                        bs += blue(color) * count;\n                        as += alpha(color) * count;\n                        sum += count;\n                    }\n                    r = (byte) (rs / sum);\n                    g = (byte) (gs / sum);\n                    b = (byte) (bs / sum);\n                    a = (byte) (as / sum);\n                }\n\n            }\n            palette[i] = new PaletteEntry(r, g, b, a, i);\n        }\n\n        // sort palette, non opaque colors first, and build the rgba array\n        Arrays.sort(palette);\n        byte[][] rgba = new byte[4][palette.length];\n        for (int i = 0; i < palette.length; i++) {\n            PaletteEntry pe = palette[i];\n            rgba[0][i] = pe.r;\n            rgba[1][i] = pe.g;\n            rgba[2][i] = pe.b;\n            rgba[3][i] = pe.a;\n        }\n\n        // prepare the reverse map\n        ColorIndexer simpleMapper = new SimpleColorIndexer(rgba);\n        ColorMap colorMap = histogram.colorMap;\n        for (ColorEntry ce : colorMap) {\n            int color = ce.color;\n            int r = red(color);\n            int g = green(color);\n            int b = blue(color);\n            int a = alpha(color);\n            if (shift > 0) {\n                r = unshift(r, shift);\n                g = unshift(g, shift);\n                b = unshift(b, shift);\n                a = unshift(a, shift);\n            }\n            int idx = simpleMapper.getClosestIndex(r, g, b, a) & 0xFF;\n            ce.value = idx;\n        }\n\n        // dumpPalette(rgba);\n\n        ColorIndexer delegate = new MappedColorIndexer(rgba, colorMap, shift);\n        return new CachingColorIndexer(delegate);\n    }", "signature": "ColorIndexer buildColorIndexer(RenderedImage image)", "full_signature": "public ColorIndexer buildColorIndexer(RenderedImage image)", "class_method_signature": "Quantizer.buildColorIndexer(RenderedImage image)", "testcase": false, "constructor": false, "invocations": ["getWidth", "getHeight", "log", "getWidth", "log", "log", "getHeight", "log", "isLoggable", "fine", "size", "getShift", "fine", "pixelCount", "min", "size", "add", "size", "round", "size", "size", "get", "size", "get", "getAlphaSpan", "getRedSpan", "getGreenSpan", "getBlueSpan", "sort", "split", "add", "size", "sort", "isLoggable", "size", "get", "append", "getVolume", "getVolume", "append", "finer", "size", "add", "get", "size", "getShift", "size", "get", "getColor", "red", "green", "blue", "alpha", "getColor", "red", "green", "blue", "alpha", "getColor", "getCount", "red", "green", "blue", "alpha", "sort", "red", "green", "blue", "alpha", "unshift", "unshift", "unshift", "unshift", "getClosestIndex"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}