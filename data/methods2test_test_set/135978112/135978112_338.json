{"test_class": {"identifier": "TaskAssignorTest", "superclass": "", "interfaces": "", "fields": [], "file": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskAssignorTest.java"}, "test_case": {"identifier": "testStickiness", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testStickiness() {\n        List<Integer> tasks;\n        Map<Integer, ClientState<Integer>> states;\n        Map<Integer, ClientState<Integer>> assignments;\n        int i;\n\n        // # of clients and # of tasks are equal.\n        tasks = mkList(0, 1, 2, 3, 4, 5);\n        Collections.shuffle(tasks);\n        states = new HashMap<>();\n        i = 0;\n        for (int task : tasks) {\n            ClientState<Integer> state = new ClientState<>(1d);\n            state.prevActiveTasks.add(task);\n            state.prevAssignedTasks.add(task);\n            states.put(i++, state);\n        }\n        assignments = TaskAssignor.assign(states, mkSet(0, 1, 2, 3, 4, 5), 0);\n        for (int client : states.keySet()) {\n            Set<Integer> oldActive = states.get(client).prevActiveTasks;\n            Set<Integer> oldAssigned = states.get(client).prevAssignedTasks;\n            Set<Integer> newActive = assignments.get(client).activeTasks;\n            Set<Integer> newAssigned = assignments.get(client).assignedTasks;\n\n            assertEquals(oldActive, newActive);\n            assertEquals(oldAssigned, newAssigned);\n        }\n\n        // # of clients > # of tasks\n        tasks = mkList(0, 1, 2, 3, -1, -1);\n        Collections.shuffle(tasks);\n        states = new HashMap<>();\n        i = 0;\n        for (int task : tasks) {\n            ClientState<Integer> state = new ClientState<>(1d);\n            if (task >= 0) {\n                state.prevActiveTasks.add(task);\n                state.prevAssignedTasks.add(task);\n            }\n            states.put(i++, state);\n        }\n        assignments = TaskAssignor.assign(states, mkSet(0, 1, 2, 3), 0);\n        for (int client : states.keySet()) {\n            Set<Integer> oldActive = states.get(client).prevActiveTasks;\n            Set<Integer> oldAssigned = states.get(client).prevAssignedTasks;\n            Set<Integer> newActive = assignments.get(client).activeTasks;\n            Set<Integer> newAssigned = assignments.get(client).assignedTasks;\n\n            assertEquals(oldActive, newActive);\n            assertEquals(oldAssigned, newAssigned);\n        }\n\n        // # of clients < # of tasks\n        List<Set<Integer>> taskSets = mkList(mkSet(0, 1), mkSet(2, 3), mkSet(4, 5), mkSet(6, 7), mkSet(8, 9), mkSet(10, 11));\n        Collections.shuffle(taskSets);\n        states = new HashMap<>();\n        i = 0;\n        for (Set<Integer> taskSet : taskSets) {\n            ClientState<Integer> state = new ClientState<>(1d);\n            state.prevActiveTasks.addAll(taskSet);\n            state.prevAssignedTasks.addAll(taskSet);\n            states.put(i++, state);\n        }\n        assignments = TaskAssignor.assign(states, mkSet(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11), 0);\n        for (int client : states.keySet()) {\n            Set<Integer> oldActive = states.get(client).prevActiveTasks;\n            Set<Integer> oldAssigned = states.get(client).prevAssignedTasks;\n            Set<Integer> newActive = assignments.get(client).activeTasks;\n            Set<Integer> newAssigned = assignments.get(client).assignedTasks;\n\n            Set<Integer> intersection = new HashSet<>();\n\n            intersection.addAll(oldActive);\n            intersection.retainAll(newActive);\n            assertTrue(intersection.size() > 0);\n\n            intersection.clear();\n            intersection.addAll(oldAssigned);\n            intersection.retainAll(newAssigned);\n            assertTrue(intersection.size() > 0);\n        }\n    }", "signature": "void testStickiness()", "full_signature": "@Test public void testStickiness()", "class_method_signature": "TaskAssignorTest.testStickiness()", "testcase": true, "constructor": false, "invocations": ["mkList", "shuffle", "add", "add", "put", "assign", "mkSet", "keySet", "get", "get", "get", "get", "assertEquals", "assertEquals", "mkList", "shuffle", "add", "add", "put", "assign", "mkSet", "keySet", "get", "get", "get", "get", "assertEquals", "assertEquals", "mkList", "mkSet", "mkSet", "mkSet", "mkSet", "mkSet", "mkSet", "shuffle", "addAll", "addAll", "put", "assign", "mkSet", "keySet", "get", "get", "get", "get", "addAll", "retainAll", "assertTrue", "size", "clear", "addAll", "retainAll", "assertTrue", "size"]}, "focal_class": {"identifier": "TaskAssignor", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(TaskAssignor.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(TaskAssignor.class)", "var_name": "log"}, {"original_string": "private final Random rand;", "modifier": "private final", "type": "Random", "declarator": "rand", "var_name": "rand"}, {"original_string": "private final Map<C, ClientState<T>> states;", "modifier": "private final", "type": "Map<C, ClientState<T>>", "declarator": "states", "var_name": "states"}, {"original_string": "private final Set<TaskPair<T>> taskPairs;", "modifier": "private final", "type": "Set<TaskPair<T>>", "declarator": "taskPairs", "var_name": "taskPairs"}, {"original_string": "private final int maxNumTaskPairs;", "modifier": "private final", "type": "int", "declarator": "maxNumTaskPairs", "var_name": "maxNumTaskPairs"}, {"original_string": "private final ArrayList<T> tasks;", "modifier": "private final", "type": "ArrayList<T>", "declarator": "tasks", "var_name": "tasks"}, {"original_string": "private boolean prevAssignmentBalanced = true;", "modifier": "private", "type": "boolean", "declarator": "prevAssignmentBalanced = true", "var_name": "prevAssignmentBalanced"}, {"original_string": "private boolean prevClientsUnchanged = true;", "modifier": "private", "type": "boolean", "declarator": "prevClientsUnchanged = true", "var_name": "prevClientsUnchanged"}], "methods": [{"identifier": "assign", "parameters": "(Map<C, ClientState<T>> states, Set<T> tasks, int numStandbyReplicas)", "modifiers": "public static", "return": "Map<C, ClientState<T>>", "signature": "Map<C, ClientState<T>> assign(Map<C, ClientState<T>> states, Set<T> tasks, int numStandbyReplicas)", "full_signature": "public static Map<C, ClientState<T>> assign(Map<C, ClientState<T>> states, Set<T> tasks, int numStandbyReplicas)", "class_method_signature": "TaskAssignor.assign(Map<C, ClientState<T>> states, Set<T> tasks, int numStandbyReplicas)", "testcase": false, "constructor": false}, {"identifier": "TaskAssignor", "parameters": "(Map<C, ClientState<T>> states, Set<T> tasks, long randomSeed)", "modifiers": "private", "return": "", "signature": " TaskAssignor(Map<C, ClientState<T>> states, Set<T> tasks, long randomSeed)", "full_signature": "private  TaskAssignor(Map<C, ClientState<T>> states, Set<T> tasks, long randomSeed)", "class_method_signature": "TaskAssignor.TaskAssignor(Map<C, ClientState<T>> states, Set<T> tasks, long randomSeed)", "testcase": false, "constructor": true}, {"identifier": "assignTasks", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void assignTasks()", "full_signature": "public void assignTasks()", "class_method_signature": "TaskAssignor.assignTasks()", "testcase": false, "constructor": false}, {"identifier": "assignStandbyTasks", "parameters": "(int numStandbyReplicas)", "modifiers": "public", "return": "void", "signature": "void assignStandbyTasks(int numStandbyReplicas)", "full_signature": "public void assignStandbyTasks(int numStandbyReplicas)", "class_method_signature": "TaskAssignor.assignStandbyTasks(int numStandbyReplicas)", "testcase": false, "constructor": false}, {"identifier": "assignTasks", "parameters": "(boolean active)", "modifiers": "private", "return": "void", "signature": "void assignTasks(boolean active)", "full_signature": "private void assignTasks(boolean active)", "class_method_signature": "TaskAssignor.assignTasks(boolean active)", "testcase": false, "constructor": false}, {"identifier": "findClientFor", "parameters": "(T task)", "modifiers": "private", "return": "ClientState<T>", "signature": "ClientState<T> findClientFor(T task)", "full_signature": "private ClientState<T> findClientFor(T task)", "class_method_signature": "TaskAssignor.findClientFor(T task)", "testcase": false, "constructor": false}, {"identifier": "findClientByAdditionCost", "parameters": "(T task, boolean checkTaskPairs)", "modifiers": "private", "return": "ClientState<T>", "signature": "ClientState<T> findClientByAdditionCost(T task, boolean checkTaskPairs)", "full_signature": "private ClientState<T> findClientByAdditionCost(T task, boolean checkTaskPairs)", "class_method_signature": "TaskAssignor.findClientByAdditionCost(T task, boolean checkTaskPairs)", "testcase": false, "constructor": false}, {"identifier": "addTaskPairs", "parameters": "(T task, ClientState<T> state)", "modifiers": "private", "return": "void", "signature": "void addTaskPairs(T task, ClientState<T> state)", "full_signature": "private void addTaskPairs(T task, ClientState<T> state)", "class_method_signature": "TaskAssignor.addTaskPairs(T task, ClientState<T> state)", "testcase": false, "constructor": false}, {"identifier": "hasNewTaskPair", "parameters": "(T task, ClientState<T> state)", "modifiers": "private", "return": "boolean", "signature": "boolean hasNewTaskPair(T task, ClientState<T> state)", "full_signature": "private boolean hasNewTaskPair(T task, ClientState<T> state)", "class_method_signature": "TaskAssignor.hasNewTaskPair(T task, ClientState<T> state)", "testcase": false, "constructor": false}, {"identifier": "computeAdditionCost", "parameters": "(T task, ClientState<T> state)", "modifiers": "private", "return": "double", "signature": "double computeAdditionCost(T task, ClientState<T> state)", "full_signature": "private double computeAdditionCost(T task, ClientState<T> state)", "class_method_signature": "TaskAssignor.computeAdditionCost(T task, ClientState<T> state)", "testcase": false, "constructor": false}, {"identifier": "pair", "parameters": "(T task1, T task2)", "modifiers": "private", "return": "TaskPair<T>", "signature": "TaskPair<T> pair(T task1, T task2)", "full_signature": "private TaskPair<T> pair(T task1, T task2)", "class_method_signature": "TaskAssignor.pair(T task1, T task2)", "testcase": false, "constructor": false}], "file": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskAssignor.java"}, "focal_method": {"identifier": "assign", "parameters": "(Map<C, ClientState<T>> states, Set<T> tasks, int numStandbyReplicas)", "modifiers": "public static", "return": "Map<C, ClientState<T>>", "body": "public static <C, T extends Comparable<T>> Map<C, ClientState<T>> assign(Map<C, ClientState<T>> states, Set<T> tasks, int numStandbyReplicas) {\n        long seed = 0L;\n        for (C client : states.keySet()) {\n            seed += client.hashCode();\n        }\n\n        TaskAssignor<C, T> assignor = new TaskAssignor<>(states, tasks, seed);\n        log.info(\"Assigning tasks to clients: {}, prevAssignmentBalanced: {}, \" +\n            \"prevClientsUnchangeed: {}, tasks: {}, replicas: {}\",\n            states, assignor.prevAssignmentBalanced, assignor.prevClientsUnchanged,\n            tasks, numStandbyReplicas);\n\n        assignor.assignTasks();\n        if (numStandbyReplicas > 0)\n            assignor.assignStandbyTasks(numStandbyReplicas);\n\n        log.info(\"Assigned with: \" + assignor.states);\n        return assignor.states;\n    }", "signature": "Map<C, ClientState<T>> assign(Map<C, ClientState<T>> states, Set<T> tasks, int numStandbyReplicas)", "full_signature": "public static Map<C, ClientState<T>> assign(Map<C, ClientState<T>> states, Set<T> tasks, int numStandbyReplicas)", "class_method_signature": "TaskAssignor.assign(Map<C, ClientState<T>> states, Set<T> tasks, int numStandbyReplicas)", "testcase": false, "constructor": false, "invocations": ["keySet", "hashCode", "info", "assignTasks", "assignStandbyTasks", "info"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}