{"test_class": {"identifier": "MullerNewtonSolverTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final IRandomNumberGenerator rng = new XorshiftRNG(0);", "modifier": "private final", "type": "IRandomNumberGenerator", "declarator": "rng = new XorshiftRNG(0)", "var_name": "rng"}], "file": "jtstoolkit/src/test/java/ec/tstoolkit/maths/polynomials/MullerNewtonSolverTest.java"}, "test_case": {"identifier": "testComputeC2", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testComputeC2() {\n        for (int i = 0; i < 10; i++) {\n            Complex q2 = random(), f2 = random();\n            Complex result = q2.plus(1).times(f2);\n            assertEquals(result, computeC2(q2, f2), 0);\n        }\n    }", "signature": "void testComputeC2()", "full_signature": "@Test public void testComputeC2()", "class_method_signature": "MullerNewtonSolverTest.testComputeC2()", "testcase": true, "constructor": false, "invocations": ["random", "random", "times", "plus", "assertEquals", "computeC2"]}, "focal_class": {"identifier": "MullerNewtonSolver", "superclass": "", "interfaces": "implements IRootsSolver", "fields": [{"original_string": "private double[] m_p;", "modifier": "private", "type": "double[]", "declarator": "m_p", "var_name": "m_p"}, {"original_string": "private double[] m_pred;", "modifier": "private", "type": "double[]", "declarator": "m_pred", "var_name": "m_pred"}, {"original_string": "private Complex[] m_roots;", "modifier": "private", "type": "Complex[]", "declarator": "m_roots", "var_name": "m_roots"}, {"original_string": "private Polynomial m_remainder;", "modifier": "private", "type": "Polynomial", "declarator": "m_remainder", "var_name": "m_remainder"}, {"original_string": "private int m_idx, m_degree;", "modifier": "private", "type": "int", "declarator": "m_idx", "var_name": "m_idx"}, {"original_string": "private double m_maxerr;", "modifier": "private", "type": "double", "declarator": "m_maxerr", "var_name": "m_maxerr"}, {"original_string": "private final static int MITERMAX = 150;", "modifier": "private final static", "type": "int", "declarator": "MITERMAX = 150", "var_name": "MITERMAX"}, {"original_string": "private final static int MCONVERGENCE = 100;", "modifier": "private final static", "type": "int", "declarator": "MCONVERGENCE = 100", "var_name": "MCONVERGENCE"}, {"original_string": "private final static double MMAXDIST = 1e3;", "modifier": "private final static", "type": "double", "declarator": "MMAXDIST = 1e3", "var_name": "MMAXDIST"}, {"original_string": "private final static double MFACTOR = 1e5;", "modifier": "private final static", "type": "double", "declarator": "MFACTOR = 1e5", "var_name": "MFACTOR"}, {"original_string": "private final static double MKITERMAX = 1e3;", "modifier": "private final static", "type": "double", "declarator": "MKITERMAX = 1e3", "var_name": "MKITERMAX"}, {"original_string": "private final static double MFVALUE = 1e36;", "modifier": "private final static", "type": "double", "declarator": "MFVALUE = 1e36", "var_name": "MFVALUE"}, {"original_string": "private final static double MBOUND1 = 1.01;", "modifier": "private final static", "type": "double", "declarator": "MBOUND1 = 1.01", "var_name": "MBOUND1"}, {"original_string": "private final static double MBOUND2 = 0.99;", "modifier": "private final static", "type": "double", "declarator": "MBOUND2 = 0.99", "var_name": "MBOUND2"}, {"original_string": "private final static double MBOUND3 = 0.01;", "modifier": "private final static", "type": "double", "declarator": "MBOUND3 = 0.01", "var_name": "MBOUND3"}, {"original_string": "private final double MBOUND4;", "modifier": "private final", "type": "double", "declarator": "MBOUND4", "var_name": "MBOUND4"}, {"original_string": "private final double MBOUND6;", "modifier": "private final", "type": "double", "declarator": "MBOUND6", "var_name": "MBOUND6"}, {"original_string": "private final static double MBOUND7 = 1e-5;", "modifier": "private final static", "type": "double", "declarator": "MBOUND7 = 1e-5", "var_name": "MBOUND7"}, {"original_string": "private final double MNOISESTART;", "modifier": "private final", "type": "double", "declarator": "MNOISESTART", "var_name": "MNOISESTART"}, {"original_string": "private final static double MNOISEMAX = 5;", "modifier": "private final static", "type": "double", "declarator": "MNOISEMAX = 5", "var_name": "MNOISEMAX"}, {"original_string": "private final static int NITERMAX = 20;", "modifier": "private final static", "type": "int", "declarator": "NITERMAX = 20", "var_name": "NITERMAX"}, {"original_string": "private final static double NFACTOR = 5;", "modifier": "private final static", "type": "double", "declarator": "NFACTOR = 5", "var_name": "NFACTOR"}, {"original_string": "private final static double NFVALUE = 1e36;", "modifier": "private final static", "type": "double", "declarator": "NFVALUE = 1e36", "var_name": "NFVALUE"}, {"original_string": "private static final double ISQRT2 = 1.0 / Math.sqrt(2.0);", "modifier": "private static final", "type": "double", "declarator": "ISQRT2 = 1.0 / Math.sqrt(2.0)", "var_name": "ISQRT2"}, {"original_string": "private final double NBOUND;", "modifier": "private final", "type": "double", "declarator": "NBOUND", "var_name": "NBOUND"}, {"original_string": "private final static int NNOISEMAX = 5;", "modifier": "private final static", "type": "int", "declarator": "NNOISEMAX = 5", "var_name": "NNOISEMAX"}, {"original_string": "private final static double DBL_EPSILON = 2.2204460492503131e-016;", "modifier": "private final static", "type": "double", "declarator": "DBL_EPSILON = 2.2204460492503131e-016", "var_name": "DBL_EPSILON"}, {"original_string": "Complex x0, x1, x2;", "modifier": "", "type": "Complex", "declarator": "x0", "var_name": "x0"}, {"original_string": "Complex h1, h2;", "modifier": "", "type": "Complex", "declarator": "h1", "var_name": "h1"}, {"original_string": "Complex q2;", "modifier": "", "type": "Complex", "declarator": "q2", "var_name": "q2"}, {"original_string": "final Ref<Complex> f0, f1, f2;", "modifier": "final", "type": "Ref<Complex>", "declarator": "f0", "var_name": "f0"}, {"original_string": "int iter;", "modifier": "", "type": "int", "declarator": "iter", "var_name": "iter"}, {"original_string": "private boolean lqdiv;", "modifier": "private", "type": "boolean", "declarator": "lqdiv", "var_name": "lqdiv"}, {"original_string": "private static final Complex[] COMPLEX_FOR_ITER = initComplexForIter(MITERMAX);", "modifier": "private static final", "type": "Complex[]", "declarator": "COMPLEX_FOR_ITER = initComplexForIter(MITERMAX)", "var_name": "COMPLEX_FOR_ITER"}], "methods": [{"identifier": "fdvalue", "parameters": "(final double[] p, final int i0,\n            final Ref<Complex> f, final Complex x)", "modifiers": "private static", "return": "void", "signature": "void fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Complex x)", "full_signature": "private static void fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Complex x)", "class_method_signature": "MullerNewtonSolver.fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Complex x)", "testcase": false, "constructor": false}, {"identifier": "fdvalue", "parameters": "(final double[] p, final int i0,\n            final Ref<Complex> f, final Ref<Complex> df, final Complex x)", "modifiers": "private static", "return": "void", "signature": "void fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Ref<Complex> df, final Complex x)", "full_signature": "private static void fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Ref<Complex> df, final Complex x)", "class_method_signature": "MullerNewtonSolver.fdvalue(final double[] p, final int i0,\n            final Ref<Complex> f, final Ref<Complex> df, final Complex x)", "testcase": false, "constructor": false}, {"identifier": "MullerNewtonSolver", "parameters": "()", "modifiers": "public", "return": "", "signature": " MullerNewtonSolver()", "full_signature": "public  MullerNewtonSolver()", "class_method_signature": "MullerNewtonSolver.MullerNewtonSolver()", "testcase": false, "constructor": true}, {"identifier": "check_x_value", "parameters": "(final Ref<Complex> xb,\n            final DoubleRef f2absqb, final BooleanRef rootd,\n            final double f1absq, final double f2absq, final double epsilon,\n            final IntRef noise)", "modifiers": "private", "return": "void", "signature": "void check_x_value(final Ref<Complex> xb,\n            final DoubleRef f2absqb, final BooleanRef rootd,\n            final double f1absq, final double f2absq, final double epsilon,\n            final IntRef noise)", "full_signature": "private void check_x_value(final Ref<Complex> xb,\n            final DoubleRef f2absqb, final BooleanRef rootd,\n            final double f1absq, final double f2absq, final double epsilon,\n            final IntRef noise)", "class_method_signature": "MullerNewtonSolver.check_x_value(final Ref<Complex> xb,\n            final DoubleRef f2absqb, final BooleanRef rootd,\n            final double f1absq, final double f2absq, final double epsilon,\n            final IntRef noise)", "testcase": false, "constructor": false}, {"identifier": "clear", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void clear()", "full_signature": "@Override public void clear()", "class_method_signature": "MullerNewtonSolver.clear()", "testcase": false, "constructor": false}, {"identifier": "exemplar", "parameters": "()", "modifiers": "@Override public", "return": "MullerNewtonSolver", "signature": "MullerNewtonSolver exemplar()", "full_signature": "@Override public MullerNewtonSolver exemplar()", "class_method_signature": "MullerNewtonSolver.exemplar()", "testcase": false, "constructor": false}, {"identifier": "compute_function", "parameters": "(final double f1absq,\n            final DoubleRef f2absq, final double epsilon)", "modifiers": "private", "return": "void", "signature": "void compute_function(final double f1absq,\n            final DoubleRef f2absq, final double epsilon)", "full_signature": "private void compute_function(final double f1absq,\n            final DoubleRef f2absq, final double epsilon)", "class_method_signature": "MullerNewtonSolver.compute_function(final double f1absq,\n            final DoubleRef f2absq, final double epsilon)", "testcase": false, "constructor": false}, {"identifier": "convergence_check", "parameters": "(final IntRef overflow,\n            final double f1absq, final double f2absq, final double epsilon)", "modifiers": "private", "return": "void", "signature": "void convergence_check(final IntRef overflow,\n            final double f1absq, final double f2absq, final double epsilon)", "full_signature": "private void convergence_check(final IntRef overflow,\n            final double f1absq, final double f2absq, final double epsilon)", "class_method_signature": "MullerNewtonSolver.convergence_check(final IntRef overflow,\n            final double f1absq, final double f2absq, final double epsilon)", "testcase": false, "constructor": false}, {"identifier": "factorize", "parameters": "(final Polynomial p)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean factorize(final Polynomial p)", "full_signature": "@Override public boolean factorize(final Polynomial p)", "class_method_signature": "MullerNewtonSolver.factorize(final Polynomial p)", "testcase": false, "constructor": false}, {"identifier": "initialize", "parameters": "(final Ref<Complex> xb, final DoubleRef epsilon)", "modifiers": "private", "return": "void", "signature": "void initialize(final Ref<Complex> xb, final DoubleRef epsilon)", "full_signature": "private void initialize(final Ref<Complex> xb, final DoubleRef epsilon)", "class_method_signature": "MullerNewtonSolver.initialize(final Ref<Complex> xb, final DoubleRef epsilon)", "testcase": false, "constructor": false}, {"identifier": "iteration_equation", "parameters": "(final DoubleRef h2abs)", "modifiers": "private", "return": "void", "signature": "void iteration_equation(final DoubleRef h2abs)", "full_signature": "private void iteration_equation(final DoubleRef h2abs)", "class_method_signature": "MullerNewtonSolver.iteration_equation(final DoubleRef h2abs)", "testcase": false, "constructor": false}, {"identifier": "lin_or_quad", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean lin_or_quad()", "full_signature": "private boolean lin_or_quad()", "class_method_signature": "MullerNewtonSolver.lin_or_quad()", "testcase": false, "constructor": false}, {"identifier": "monic", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void monic()", "full_signature": "private void monic()", "class_method_signature": "MullerNewtonSolver.monic()", "testcase": false, "constructor": false}, {"identifier": "muller", "parameters": "()", "modifiers": "private", "return": "Complex", "signature": "Complex muller()", "full_signature": "private Complex muller()", "class_method_signature": "MullerNewtonSolver.muller()", "testcase": false, "constructor": false}, {"identifier": "newton", "parameters": "(final Complex ns, final DoubleRef dxabs)", "modifiers": "private", "return": "Complex", "signature": "Complex newton(final Complex ns, final DoubleRef dxabs)", "full_signature": "private Complex newton(final Complex ns, final DoubleRef dxabs)", "class_method_signature": "MullerNewtonSolver.newton(final Complex ns, final DoubleRef dxabs)", "testcase": false, "constructor": false}, {"identifier": "newtonnull", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean newtonnull()", "full_signature": "private boolean newtonnull()", "class_method_signature": "MullerNewtonSolver.newtonnull()", "testcase": false, "constructor": false}, {"identifier": "quadratic", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void quadratic()", "full_signature": "private void quadratic()", "class_method_signature": "MullerNewtonSolver.quadratic()", "testcase": false, "constructor": false}, {"identifier": "remainder", "parameters": "()", "modifiers": "@Override public", "return": "Polynomial", "signature": "Polynomial remainder()", "full_signature": "@Override public Polynomial remainder()", "class_method_signature": "MullerNewtonSolver.remainder()", "testcase": false, "constructor": false}, {"identifier": "root_check", "parameters": "(final double f2absqb,\n            final IntRef seconditer, final BooleanRef rootd,\n            final IntRef noise, final Complex xb)", "modifiers": "private", "return": "void", "signature": "void root_check(final double f2absqb,\n            final IntRef seconditer, final BooleanRef rootd,\n            final IntRef noise, final Complex xb)", "full_signature": "private void root_check(final double f2absqb,\n            final IntRef seconditer, final BooleanRef rootd,\n            final IntRef noise, final Complex xb)", "class_method_signature": "MullerNewtonSolver.root_check(final double f2absqb,\n            final IntRef seconditer, final BooleanRef rootd,\n            final IntRef noise, final Complex xb)", "testcase": false, "constructor": false}, {"identifier": "root_of_parabola", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void root_of_parabola()", "full_signature": "private void root_of_parabola()", "class_method_signature": "MullerNewtonSolver.root_of_parabola()", "testcase": false, "constructor": false}, {"identifier": "computeA2", "parameters": "(Complex q2, Complex f2, Complex f0, Complex f1)", "modifiers": "@VisibleForTesting static", "return": "Complex", "signature": "Complex computeA2(Complex q2, Complex f2, Complex f0, Complex f1)", "full_signature": "@VisibleForTesting static Complex computeA2(Complex q2, Complex f2, Complex f0, Complex f1)", "class_method_signature": "MullerNewtonSolver.computeA2(Complex q2, Complex f2, Complex f0, Complex f1)", "testcase": false, "constructor": false}, {"identifier": "computeB2", "parameters": "(Complex f2, Complex f1, Complex q2, Complex f0)", "modifiers": "@VisibleForTesting static", "return": "Complex", "signature": "Complex computeB2(Complex f2, Complex f1, Complex q2, Complex f0)", "full_signature": "@VisibleForTesting static Complex computeB2(Complex f2, Complex f1, Complex q2, Complex f0)", "class_method_signature": "MullerNewtonSolver.computeB2(Complex f2, Complex f1, Complex q2, Complex f0)", "testcase": false, "constructor": false}, {"identifier": "computeC2", "parameters": "(Complex q2, Complex f2)", "modifiers": "@VisibleForTesting static", "return": "Complex", "signature": "Complex computeC2(Complex q2, Complex f2)", "full_signature": "@VisibleForTesting static Complex computeC2(Complex q2, Complex f2)", "class_method_signature": "MullerNewtonSolver.computeC2(Complex q2, Complex f2)", "testcase": false, "constructor": false}, {"identifier": "computeDiscr", "parameters": "(Complex B2, Complex A2, Complex C2)", "modifiers": "@VisibleForTesting static", "return": "Complex", "signature": "Complex computeDiscr(Complex B2, Complex A2, Complex C2)", "full_signature": "@VisibleForTesting static Complex computeDiscr(Complex B2, Complex A2, Complex C2)", "class_method_signature": "MullerNewtonSolver.computeDiscr(Complex B2, Complex A2, Complex C2)", "testcase": false, "constructor": false}, {"identifier": "roots", "parameters": "()", "modifiers": "@Override public", "return": "Complex[]", "signature": "Complex[] roots()", "full_signature": "@Override public Complex[] roots()", "class_method_signature": "MullerNewtonSolver.roots()", "testcase": false, "constructor": false}, {"identifier": "roots_at_zero", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void roots_at_zero()", "full_signature": "private void roots_at_zero()", "class_method_signature": "MullerNewtonSolver.roots_at_zero()", "testcase": false, "constructor": false}, {"identifier": "suppress_overflow", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void suppress_overflow()", "full_signature": "private void suppress_overflow()", "class_method_signature": "MullerNewtonSolver.suppress_overflow()", "testcase": false, "constructor": false}, {"identifier": "too_big_functionvalues", "parameters": "(final DoubleRef f2absq)", "modifiers": "private", "return": "void", "signature": "void too_big_functionvalues(final DoubleRef f2absq)", "full_signature": "private void too_big_functionvalues(final DoubleRef f2absq)", "class_method_signature": "MullerNewtonSolver.too_big_functionvalues(final DoubleRef f2absq)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(final Complex r0)", "modifiers": "private", "return": "void", "signature": "void update(final Complex r0)", "full_signature": "private void update(final Complex r0)", "class_method_signature": "MullerNewtonSolver.update(final Complex r0)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(final double r0)", "modifiers": "private", "return": "void", "signature": "void update(final double r0)", "full_signature": "private void update(final double r0)", "class_method_signature": "MullerNewtonSolver.update(final double r0)", "testcase": false, "constructor": false}, {"identifier": "isLeastSquaresDivision", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isLeastSquaresDivision()", "full_signature": "public boolean isLeastSquaresDivision()", "class_method_signature": "MullerNewtonSolver.isLeastSquaresDivision()", "testcase": false, "constructor": false}, {"identifier": "setLeastSquaresDivision", "parameters": "(boolean lq)", "modifiers": "public", "return": "void", "signature": "void setLeastSquaresDivision(boolean lq)", "full_signature": "public void setLeastSquaresDivision(boolean lq)", "class_method_signature": "MullerNewtonSolver.setLeastSquaresDivision(boolean lq)", "testcase": false, "constructor": false}, {"identifier": "getComplexForIterationCounter", "parameters": "(int iter)", "modifiers": "private static", "return": "Complex", "signature": "Complex getComplexForIterationCounter(int iter)", "full_signature": "private static Complex getComplexForIterationCounter(int iter)", "class_method_signature": "MullerNewtonSolver.getComplexForIterationCounter(int iter)", "testcase": false, "constructor": false}, {"identifier": "newComplexForIterationCounter", "parameters": "(int iter)", "modifiers": "private static", "return": "Complex", "signature": "Complex newComplexForIterationCounter(int iter)", "full_signature": "private static Complex newComplexForIterationCounter(int iter)", "class_method_signature": "MullerNewtonSolver.newComplexForIterationCounter(int iter)", "testcase": false, "constructor": false}, {"identifier": "initComplexForIter", "parameters": "(int maxIter)", "modifiers": "private static", "return": "Complex[]", "signature": "Complex[] initComplexForIter(int maxIter)", "full_signature": "private static Complex[] initComplexForIter(int maxIter)", "class_method_signature": "MullerNewtonSolver.initComplexForIter(int maxIter)", "testcase": false, "constructor": false}], "file": "jtstoolkit/src/main/java/ec/tstoolkit/maths/polynomials/MullerNewtonSolver.java"}, "focal_method": {"identifier": "computeC2", "parameters": "(Complex q2, Complex f2)", "modifiers": "@VisibleForTesting static", "return": "Complex", "body": "@VisibleForTesting\n    static Complex computeC2(Complex q2, Complex f2) {\n        double tmp;\n        double re0;\n        double im0;\n        /* { 1 q2 + } */\n        re0 = 1 + q2.getRe();\n        im0 = q2.getIm();\n        /* { f2 * } */\n        tmp = re0 * f2.getRe() - im0 * f2.getIm();\n        im0 = re0 * f2.getIm() + im0 * f2.getRe();\n        re0 = tmp;\n        /* .build() */\n        return Complex.cart(re0, im0);\n    }", "signature": "Complex computeC2(Complex q2, Complex f2)", "full_signature": "@VisibleForTesting static Complex computeC2(Complex q2, Complex f2)", "class_method_signature": "MullerNewtonSolver.computeC2(Complex q2, Complex f2)", "testcase": false, "constructor": false, "invocations": ["getRe", "getIm", "getRe", "getIm", "getIm", "getRe", "cart"]}, "repository": {"repo_id": 28178086, "url": "https://github.com/jdemetra/jdemetra-core", "stars": 24, "created": "12/18/2014 10:00:58 AM +00:00", "updates": "2020-01-17T15:50:24+00:00", "fork": "False", "license": "licensed"}}