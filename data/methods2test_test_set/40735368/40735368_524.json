{"test_class": {"identifier": "IntersectionFeatureCollectionTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = Logger.getLogger(\"org.geotools.process.feature.gs.VectoralZonalStatisticalProcessTest\");", "modifier": "private static final", "type": "Logger", "declarator": "logger = Logger.getLogger(\"org.geotools.process.feature.gs.VectoralZonalStatisticalProcessTest\")", "var_name": "logger"}, {"original_string": "FilterFactory ff = CommonFactoryFinder.getFilterFactory(null);", "modifier": "", "type": "FilterFactory", "declarator": "ff = CommonFactoryFinder.getFilterFactory(null)", "var_name": "ff"}, {"original_string": "private DataStore data;", "modifier": "private", "type": "DataStore", "declarator": "data", "var_name": "data"}, {"original_string": "private SimpleFeatureCollection zonesCollection;", "modifier": "private", "type": "SimpleFeatureCollection", "declarator": "zonesCollection", "var_name": "zonesCollection"}, {"original_string": "private SimpleFeatureCollection featuresCollection;", "modifier": "private", "type": "SimpleFeatureCollection", "declarator": "featuresCollection", "var_name": "featuresCollection"}, {"original_string": "private SimpleFeatureCollection polylineCollection;", "modifier": "private", "type": "SimpleFeatureCollection", "declarator": "polylineCollection", "var_name": "polylineCollection"}, {"original_string": "private SimpleFeatureCollection multipointCollection;", "modifier": "private", "type": "SimpleFeatureCollection", "declarator": "multipointCollection", "var_name": "multipointCollection"}, {"original_string": "private IntersectionFeatureCollection process;", "modifier": "private", "type": "IntersectionFeatureCollection", "declarator": "process", "var_name": "process"}, {"original_string": "private static final double WORLDAREA = 510072000.0d;", "modifier": "private static final", "type": "double", "declarator": "WORLDAREA = 510072000.0d", "var_name": "WORLDAREA"}, {"original_string": "private static final double COLORADOAREA = 269837.0d;", "modifier": "private static final", "type": "double", "declarator": "COLORADOAREA = 269837.0d", "var_name": "COLORADOAREA"}], "file": "modules/unsupported/process-feature/src/test/java/org/geotools/process/vector/IntersectionFeatureCollectionTest.java"}, "test_case": {"identifier": "testExceptionOpModeSndCollection", "parameters": "()", "modifiers": "@Test(expected=IllegalArgumentException.class) public", "return": "void", "body": "@Test(expected=IllegalArgumentException.class)\n    public void testExceptionOpModeSndCollection() throws Exception {\n        logger.info(\"Running testExceptionOpModeSndCollection ...\");\n        ArrayList<String> toRetainFst = new ArrayList<String>();\n        toRetainFst.add(\"cat2\");\n        ArrayList<String> toRetainSnd = new ArrayList<String>();\n        toRetainSnd.add(\"cat\");\n        SimpleFeatureCollection output = process.execute(zonesCollection, polylineCollection,toRetainFst,toRetainSnd, IntersectionMode.INTERSECTION, true, false);\n    }", "signature": "void testExceptionOpModeSndCollection()", "full_signature": "@Test(expected=IllegalArgumentException.class) public void testExceptionOpModeSndCollection()", "class_method_signature": "IntersectionFeatureCollectionTest.testExceptionOpModeSndCollection()", "testcase": true, "constructor": false, "invocations": ["info", "add", "add", "execute"]}, "focal_class": {"identifier": "IntersectionFeatureCollection", "superclass": "", "interfaces": "implements VectorProcess", "fields": [{"original_string": "private static final Logger logger = Logger\n            .getLogger(\"org.geotools.process.feature.gs.IntersectionFeatureCollection\");", "modifier": "private static final", "type": "Logger", "declarator": "logger = Logger\n            .getLogger(\"org.geotools.process.feature.gs.IntersectionFeatureCollection\")", "var_name": "logger"}, {"original_string": "static final String ECKERT_IV_WKT = \"PROJCS[\\\"World_Eckert_IV\\\",GEOGCS[\\\"GCS_WGS_1984\\\",DATUM[\\\"D_WGS_1984\\\",SPHEROID[\\\"WGS_1984\\\",6378137.0,298.257223563]],PRIMEM[\\\"Greenwich\\\",0.0],UNIT[\\\"Degree\\\",0.0174532925199433]],PROJECTION[\\\"Eckert_IV\\\"],PARAMETER[\\\"Central_Meridian\\\",0.0],UNIT[\\\"Meter\\\",1.0]]\";", "modifier": "static final", "type": "String", "declarator": "ECKERT_IV_WKT = \"PROJCS[\\\"World_Eckert_IV\\\",GEOGCS[\\\"GCS_WGS_1984\\\",DATUM[\\\"D_WGS_1984\\\",SPHEROID[\\\"WGS_1984\\\",6378137.0,298.257223563]],PRIMEM[\\\"Greenwich\\\",0.0],UNIT[\\\"Degree\\\",0.0174532925199433]],PROJECTION[\\\"Eckert_IV\\\"],PARAMETER[\\\"Central_Meridian\\\",0.0],UNIT[\\\"Meter\\\",1.0]]\"", "var_name": "ECKERT_IV_WKT"}], "methods": [{"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "modifiers": "@DescribeResult(description = \"Output feature collection\") public", "return": "SimpleFeatureCollection", "signature": "SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "full_signature": "@DescribeResult(description = \"Output feature collection\") public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "class_method_signature": "IntersectionFeatureCollection.execute(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "testcase": false, "constructor": false}, {"identifier": "isGeometryTypeIn", "parameters": "(Class test, Class... targets)", "modifiers": "static", "return": "boolean", "signature": "boolean isGeometryTypeIn(Class test, Class... targets)", "full_signature": "static boolean isGeometryTypeIn(Class test, Class... targets)", "class_method_signature": "IntersectionFeatureCollection.isGeometryTypeIn(Class test, Class... targets)", "testcase": false, "constructor": false}, {"identifier": "densify", "parameters": "(Geometry geom, CoordinateReferenceSystem crs, double maxAreaError)", "modifiers": "static", "return": "Geometry", "signature": "Geometry densify(Geometry geom, CoordinateReferenceSystem crs, double maxAreaError)", "full_signature": "static Geometry densify(Geometry geom, CoordinateReferenceSystem crs, double maxAreaError)", "class_method_signature": "IntersectionFeatureCollection.densify(Geometry geom, CoordinateReferenceSystem crs, double maxAreaError)", "testcase": false, "constructor": false}, {"identifier": "getIntersectionArea", "parameters": "(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "modifiers": "static", "return": "double", "signature": "double getIntersectionArea(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "full_signature": "static double getIntersectionArea(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "class_method_signature": "IntersectionFeatureCollection.getIntersectionArea(Geometry first, CoordinateReferenceSystem firstCRS,\n            Geometry second, CoordinateReferenceSystem secondCRS, boolean divideFirst)", "testcase": false, "constructor": false}, {"identifier": "reprojectAndDensify", "parameters": "(Geometry first, CoordinateReferenceSystem sourceCRS,\n            CoordinateReferenceSystem targetCRS)", "modifiers": "static", "return": "Geometry", "signature": "Geometry reprojectAndDensify(Geometry first, CoordinateReferenceSystem sourceCRS,\n            CoordinateReferenceSystem targetCRS)", "full_signature": "static Geometry reprojectAndDensify(Geometry first, CoordinateReferenceSystem sourceCRS,\n            CoordinateReferenceSystem targetCRS)", "class_method_signature": "IntersectionFeatureCollection.reprojectAndDensify(Geometry first, CoordinateReferenceSystem sourceCRS,\n            CoordinateReferenceSystem targetCRS)", "testcase": false, "constructor": false}, {"identifier": "getIntersectionType", "parameters": "(SimpleFeatureCollection first,\n            SimpleFeatureCollection second)", "modifiers": "static", "return": "AttributeDescriptor", "signature": "AttributeDescriptor getIntersectionType(SimpleFeatureCollection first,\n            SimpleFeatureCollection second)", "full_signature": "static AttributeDescriptor getIntersectionType(SimpleFeatureCollection first,\n            SimpleFeatureCollection second)", "class_method_signature": "IntersectionFeatureCollection.getIntersectionType(SimpleFeatureCollection first,\n            SimpleFeatureCollection second)", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/IntersectionFeatureCollection.java"}, "focal_method": {"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "modifiers": "@DescribeResult(description = \"Output feature collection\") public", "return": "SimpleFeatureCollection", "body": "@DescribeResult(description = \"Output feature collection\")\n    public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled) {\n        // assign defaults\n        logger.fine(\"INTERSECTION FEATURE COLLECTION WPS STARTED\");\n       \n        if (percentagesEnabled == null) {\n            percentagesEnabled = false;\n        }\n        if (areasEnabled == null) {\n            areasEnabled = false;\n        }\n        if (intersectionMode == null) {\n            intersectionMode = IntersectionMode.INTERSECTION;\n        }\n\n        // basic geometry checks\n        Class firstGeomType = firstFeatures.getSchema().getGeometryDescriptor().getType()\n                .getBinding();\n        Class secondGeomType = secondFeatures.getSchema().getGeometryDescriptor().getType()\n                .getBinding();\n        if ((percentagesEnabled || areasEnabled)\n                && (!isGeometryTypeIn(firstGeomType, MultiPolygon.class, Polygon.class) || !isGeometryTypeIn(\n                        secondGeomType, MultiPolygon.class, Polygon.class))) {\n            throw new IllegalArgumentException(\n                    \"In case of opMode or areaMode are true, the features in the first and second collection must be polygonal\");\n        }\n        if (!isGeometryTypeIn(firstGeomType, MultiPolygon.class, Polygon.class,\n                MultiLineString.class, LineString.class)) {\n            throw new IllegalArgumentException(\n                    \"First feature collection must be polygonal or linear\");\n        }\n\n        return new IntersectedFeatureCollection(firstFeatures, firstAttributes, secondFeatures,\n                sndAttributes, intersectionMode, percentagesEnabled, areasEnabled);\n    }", "signature": "SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "full_signature": "@DescribeResult(description = \"Output feature collection\") public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "class_method_signature": "IntersectionFeatureCollection.execute(\n            @DescribeParameter(name = \"first feature collection\", description = \"First feature collection\") SimpleFeatureCollection firstFeatures,\n            @DescribeParameter(name = \"second feature collection\", description = \"Second feature collection\") SimpleFeatureCollection secondFeatures,\n            @DescribeParameter(name = \"first attributes to retain\", collectionType = String.class, min = 0, description = \"First feature collection attribute to include\") List<String> firstAttributes,\n            @DescribeParameter(name = \"second attributes to retain\", collectionType = String.class, min = 0, description = \"Second feature collection attribute to include\") List<String> sndAttributes,\n            @DescribeParameter(name = \"intersectionMode\", min = 0, description = \"Specifies geometry computed for intersecting features.  INTERSECTION (default) computes the spatial intersection of the inputs. FIRST copies geometry A.  SECOND copies geometry B.\", defaultValue=\"INTERSECTION\") IntersectionMode intersectionMode,\n            @DescribeParameter(name = \"percentagesEnabled\", min = 0, description = \"Indicates whether to output feature area percentages (attributes percentageA and percentageB)\") Boolean percentagesEnabled,\n            @DescribeParameter(name = \"areasEnabled\", min = 0, description = \"Indicates whether to output feature areas (attributes areaA and areaB)\") Boolean areasEnabled)", "testcase": false, "constructor": false, "invocations": ["fine", "getBinding", "getType", "getGeometryDescriptor", "getSchema", "getBinding", "getType", "getGeometryDescriptor", "getSchema", "isGeometryTypeIn", "isGeometryTypeIn", "isGeometryTypeIn"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}