{"test_class": {"identifier": "LocalProxyTransactionTest", "superclass": "extends AbstractProxyTransactionTest<T>", "interfaces": "", "fields": [], "file": "opendaylight/md-sal/sal-distributed-datastore/src/test/java/org/opendaylight/controller/cluster/databroker/actors/dds/LocalProxyTransactionTest.java"}, "test_case": {"identifier": "testHandleForwardedRemoteReadRequest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testHandleForwardedRemoteReadRequest() {\n        final TestProbe probe = createProbe();\n        final ReadTransactionRequest request =\n                new ReadTransactionRequest(TRANSACTION_ID, 0L, probe.ref(), PATH_1, true);\n        final Consumer<Response<?, ?>> callback = createCallbackMock();\n        setupExecuteInActor();\n\n        transaction.handleReplayedRemoteRequest(request, callback, Ticker.systemTicker().read());\n        final ArgumentCaptor<Response<?, ?>> captor = ArgumentCaptor.forClass(Response.class);\n        verify(callback).accept(captor.capture());\n        final Response<?, ?> value = captor.getValue();\n        Assert.assertTrue(value instanceof ReadTransactionSuccess);\n        final ReadTransactionSuccess success = (ReadTransactionSuccess) value;\n        Assert.assertTrue(success.getData().isPresent());\n        Assert.assertEquals(DATA_1, success.getData().get());\n    }", "signature": "void testHandleForwardedRemoteReadRequest()", "full_signature": "@Test public void testHandleForwardedRemoteReadRequest()", "class_method_signature": "LocalProxyTransactionTest.testHandleForwardedRemoteReadRequest()", "testcase": true, "constructor": false, "invocations": ["createProbe", "ref", "createCallbackMock", "setupExecuteInActor", "handleReplayedRemoteRequest", "read", "systemTicker", "forClass", "accept", "verify", "capture", "getValue", "assertTrue", "assertTrue", "isPresent", "getData", "assertEquals", "get", "getData"]}, "focal_class": {"identifier": "LocalProxyTransaction", "superclass": "extends AbstractProxyTransaction", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(LocalProxyTransaction.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(LocalProxyTransaction.class)", "var_name": "LOG"}, {"original_string": "private final TransactionIdentifier identifier;", "modifier": "private final", "type": "TransactionIdentifier", "declarator": "identifier", "var_name": "identifier"}], "methods": [{"identifier": "LocalProxyTransaction", "parameters": "(final ProxyHistory parent, final TransactionIdentifier identifier, final boolean isDone)", "modifiers": "", "return": "", "signature": " LocalProxyTransaction(final ProxyHistory parent, final TransactionIdentifier identifier, final boolean isDone)", "full_signature": "  LocalProxyTransaction(final ProxyHistory parent, final TransactionIdentifier identifier, final boolean isDone)", "class_method_signature": "LocalProxyTransaction.LocalProxyTransaction(final ProxyHistory parent, final TransactionIdentifier identifier, final boolean isDone)", "testcase": false, "constructor": true}, {"identifier": "getIdentifier", "parameters": "()", "modifiers": "@Override public final", "return": "TransactionIdentifier", "signature": "TransactionIdentifier getIdentifier()", "full_signature": "@Override public final TransactionIdentifier getIdentifier()", "class_method_signature": "LocalProxyTransaction.getIdentifier()", "testcase": false, "constructor": false}, {"identifier": "readOnlyView", "parameters": "()", "modifiers": "abstract @NonNull", "return": "DataTreeSnapshot", "signature": "DataTreeSnapshot readOnlyView()", "full_signature": "abstract @NonNull DataTreeSnapshot readOnlyView()", "class_method_signature": "LocalProxyTransaction.readOnlyView()", "testcase": false, "constructor": false}, {"identifier": "applyForwardedModifyTransactionRequest", "parameters": "(ModifyTransactionRequest request,\n            @Nullable Consumer<Response<?, ?>> callback)", "modifiers": "abstract", "return": "void", "signature": "void applyForwardedModifyTransactionRequest(ModifyTransactionRequest request,\n            @Nullable Consumer<Response<?, ?>> callback)", "full_signature": "abstract void applyForwardedModifyTransactionRequest(ModifyTransactionRequest request,\n            @Nullable Consumer<Response<?, ?>> callback)", "class_method_signature": "LocalProxyTransaction.applyForwardedModifyTransactionRequest(ModifyTransactionRequest request,\n            @Nullable Consumer<Response<?, ?>> callback)", "testcase": false, "constructor": false}, {"identifier": "replayModifyTransactionRequest", "parameters": "(ModifyTransactionRequest request,\n            @Nullable Consumer<Response<?, ?>> callback, long enqueuedTicks)", "modifiers": "abstract", "return": "void", "signature": "void replayModifyTransactionRequest(ModifyTransactionRequest request,\n            @Nullable Consumer<Response<?, ?>> callback, long enqueuedTicks)", "full_signature": "abstract void replayModifyTransactionRequest(ModifyTransactionRequest request,\n            @Nullable Consumer<Response<?, ?>> callback, long enqueuedTicks)", "class_method_signature": "LocalProxyTransaction.replayModifyTransactionRequest(ModifyTransactionRequest request,\n            @Nullable Consumer<Response<?, ?>> callback, long enqueuedTicks)", "testcase": false, "constructor": false}, {"identifier": "doExists", "parameters": "(final YangInstanceIdentifier path)", "modifiers": "@Override final", "return": "FluentFuture<Boolean>", "signature": "FluentFuture<Boolean> doExists(final YangInstanceIdentifier path)", "full_signature": "@Override final FluentFuture<Boolean> doExists(final YangInstanceIdentifier path)", "class_method_signature": "LocalProxyTransaction.doExists(final YangInstanceIdentifier path)", "testcase": false, "constructor": false}, {"identifier": "doRead", "parameters": "(final YangInstanceIdentifier path)", "modifiers": "@Override final", "return": "FluentFuture<Optional<NormalizedNode<?, ?>>>", "signature": "FluentFuture<Optional<NormalizedNode<?, ?>>> doRead(final YangInstanceIdentifier path)", "full_signature": "@Override final FluentFuture<Optional<NormalizedNode<?, ?>>> doRead(final YangInstanceIdentifier path)", "class_method_signature": "LocalProxyTransaction.doRead(final YangInstanceIdentifier path)", "testcase": false, "constructor": false}, {"identifier": "abortRequest", "parameters": "()", "modifiers": "@Override final", "return": "AbortLocalTransactionRequest", "signature": "AbortLocalTransactionRequest abortRequest()", "full_signature": "@Override final AbortLocalTransactionRequest abortRequest()", "class_method_signature": "LocalProxyTransaction.abortRequest()", "testcase": false, "constructor": false}, {"identifier": "handleReplayedLocalRequest", "parameters": "(final AbstractLocalTransactionRequest<?> request,\n            final Consumer<Response<?, ?>> callback, final long enqueuedTicks)", "modifiers": "@Override", "return": "void", "signature": "void handleReplayedLocalRequest(final AbstractLocalTransactionRequest<?> request,\n            final Consumer<Response<?, ?>> callback, final long enqueuedTicks)", "full_signature": "@Override void handleReplayedLocalRequest(final AbstractLocalTransactionRequest<?> request,\n            final Consumer<Response<?, ?>> callback, final long enqueuedTicks)", "class_method_signature": "LocalProxyTransaction.handleReplayedLocalRequest(final AbstractLocalTransactionRequest<?> request,\n            final Consumer<Response<?, ?>> callback, final long enqueuedTicks)", "testcase": false, "constructor": false}, {"identifier": "handleReadRequest", "parameters": "(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "modifiers": "private", "return": "boolean", "signature": "boolean handleReadRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "full_signature": "private boolean handleReadRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "class_method_signature": "LocalProxyTransaction.handleReadRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "testcase": false, "constructor": false}, {"identifier": "handleReplayedRemoteRequest", "parameters": "(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "modifiers": "@Override", "return": "void", "signature": "void handleReplayedRemoteRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "full_signature": "@Override void handleReplayedRemoteRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "class_method_signature": "LocalProxyTransaction.handleReplayedRemoteRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "testcase": false, "constructor": false}, {"identifier": "handleForwardedRemoteRequest", "parameters": "(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "modifiers": "", "return": "void", "signature": "void handleForwardedRemoteRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "full_signature": " void handleForwardedRemoteRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "class_method_signature": "LocalProxyTransaction.handleForwardedRemoteRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "testcase": false, "constructor": false}, {"identifier": "forwardToRemote", "parameters": "(final RemoteProxyTransaction successor, final TransactionRequest<?> request,\n                         final Consumer<Response<?, ?>> callback)", "modifiers": "@Override final", "return": "void", "signature": "void forwardToRemote(final RemoteProxyTransaction successor, final TransactionRequest<?> request,\n                         final Consumer<Response<?, ?>> callback)", "full_signature": "@Override final void forwardToRemote(final RemoteProxyTransaction successor, final TransactionRequest<?> request,\n                         final Consumer<Response<?, ?>> callback)", "class_method_signature": "LocalProxyTransaction.forwardToRemote(final RemoteProxyTransaction successor, final TransactionRequest<?> request,\n                         final Consumer<Response<?, ?>> callback)", "testcase": false, "constructor": false}, {"identifier": "forwardToLocal", "parameters": "(final LocalProxyTransaction successor, final TransactionRequest<?> request,\n            final Consumer<Response<?, ?>> callback)", "modifiers": "@Override", "return": "void", "signature": "void forwardToLocal(final LocalProxyTransaction successor, final TransactionRequest<?> request,\n            final Consumer<Response<?, ?>> callback)", "full_signature": "@Override void forwardToLocal(final LocalProxyTransaction successor, final TransactionRequest<?> request,\n            final Consumer<Response<?, ?>> callback)", "class_method_signature": "LocalProxyTransaction.forwardToLocal(final LocalProxyTransaction successor, final TransactionRequest<?> request,\n            final Consumer<Response<?, ?>> callback)", "testcase": false, "constructor": false}, {"identifier": "throwUnhandledRequest", "parameters": "(final TransactionRequest<?> request)", "modifiers": "private static", "return": "void", "signature": "void throwUnhandledRequest(final TransactionRequest<?> request)", "full_signature": "private static void throwUnhandledRequest(final TransactionRequest<?> request)", "class_method_signature": "LocalProxyTransaction.throwUnhandledRequest(final TransactionRequest<?> request)", "testcase": false, "constructor": false}, {"identifier": "sendAbort", "parameters": "(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "modifiers": "", "return": "void", "signature": "void sendAbort(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "full_signature": " void sendAbort(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "class_method_signature": "LocalProxyTransaction.sendAbort(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback)", "testcase": false, "constructor": false}, {"identifier": "enqueueAbort", "parameters": "(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "modifiers": "", "return": "void", "signature": "void enqueueAbort(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "full_signature": " void enqueueAbort(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "class_method_signature": "LocalProxyTransaction.enqueueAbort(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "testcase": false, "constructor": false}], "file": "opendaylight/md-sal/sal-distributed-datastore/src/main/java/org/opendaylight/controller/cluster/databroker/actors/dds/LocalProxyTransaction.java"}, "focal_method": {"identifier": "handleReplayedRemoteRequest", "parameters": "(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "modifiers": "@Override", "return": "void", "body": "@Override\n    void handleReplayedRemoteRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks) {\n        if (request instanceof ModifyTransactionRequest) {\n            replayModifyTransactionRequest((ModifyTransactionRequest) request, callback, enqueuedTicks);\n        } else if (handleReadRequest(request, callback)) {\n            // No-op\n        } else if (request instanceof TransactionPurgeRequest) {\n            enqueuePurge(callback, enqueuedTicks);\n        } else if (request instanceof IncrementTransactionSequenceRequest) {\n            // Local transactions do not have non-replayable requests which would be visible to the backend,\n            // hence we can skip sequence increments.\n            LOG.debug(\"Not replaying {}\", request);\n        } else {\n            throw new IllegalArgumentException(\"Unhandled request \" + request);\n        }\n    }", "signature": "void handleReplayedRemoteRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "full_signature": "@Override void handleReplayedRemoteRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "class_method_signature": "LocalProxyTransaction.handleReplayedRemoteRequest(final TransactionRequest<?> request, final Consumer<Response<?, ?>> callback,\n            final long enqueuedTicks)", "testcase": false, "constructor": false, "invocations": ["replayModifyTransactionRequest", "handleReadRequest", "enqueuePurge", "debug"]}, "repository": {"repo_id": 16362479, "url": "https://github.com/opendaylight/controller", "stars": 313, "created": "1/29/2014 11:10:45 PM +00:00", "updates": "2020-01-20T11:02:36+00:00", "fork": "False", "license": "licensed"}}