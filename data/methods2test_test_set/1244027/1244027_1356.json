{"test_class": {"identifier": "WritableSessionCacheTest", "superclass": "extends AbstractSessionCacheTest", "interfaces": "", "fields": [{"original_string": "private DocumentOptimizer optimizer;", "modifier": "private", "type": "DocumentOptimizer", "declarator": "optimizer", "var_name": "optimizer"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/cache/document/WritableSessionCacheTest.java"}, "test_case": {"identifier": "shouldAllowSessionToCreateAndAccessNewChildNodeOnExistingNodeBeforeSave", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldAllowSessionToCreateAndAccessNewChildNodeOnExistingNodeBeforeSave() {\n        // Make sure the property does not exist ...\n        check(cache).noNode(\"/childB/newChild\");\n\n        print(false);\n\n        // Set property on existing node ...\n        MutableCachedNode nodeB = check(session1).mutableNode(\"/childB\");\n        NodeKey newKey = session1.createNodeKeyWithIdentifier(\"newChild\");\n        long nanos = System.nanoTime();\n        MutableCachedNode newChild = nodeB.createChild(session(), newKey, name(\"newChild\"), property(\"p1a\", 344),\n                                                       property(\"p2\", false));\n        print(\"Time (createChild): \" + millis(Math.abs(System.nanoTime() - nanos)) + \" ms\");\n        assertThat(newChild.getPath(session1), is(path(\"/childB/newChild\")));\n        check(session1).children(nodeB, \"childC\", \"childD\", \"newChild\");\n        check(session1).property(\"/childB/newChild\", property(\"p1a\", 344));\n        check(session1).property(\"/childB/newChild\", property(\"p2\", false));\n\n        // Make sure the other session doesn't see the new child ...\n        check(session2).children(nodeB.getKey(), \"childC\", \"childD\");\n\n        print(false);\n        nanos = System.nanoTime();\n        session1.save();\n        print(false);\n        print(\"Time (save): \" + millis(Math.abs(System.nanoTime() - nanos)) + \" ms\");\n\n        // Both sessions should see all 3 children ...\n        check(session1).children(nodeB, \"childC\", \"childD\", \"newChild\");\n        check(session2).children(nodeB, \"childC\", \"childD\", \"newChild\");\n        check(session2).property(\"/childB/newChild\", property(\"p1a\", 344));\n        check(session2).property(\"/childB/newChild\", property(\"p2\", false));\n    }", "signature": "void shouldAllowSessionToCreateAndAccessNewChildNodeOnExistingNodeBeforeSave()", "full_signature": "@Test public void shouldAllowSessionToCreateAndAccessNewChildNodeOnExistingNodeBeforeSave()", "class_method_signature": "WritableSessionCacheTest.shouldAllowSessionToCreateAndAccessNewChildNodeOnExistingNodeBeforeSave()", "testcase": true, "constructor": false, "invocations": ["noNode", "check", "print", "mutableNode", "check", "createNodeKeyWithIdentifier", "nanoTime", "createChild", "session", "name", "property", "property", "print", "millis", "abs", "nanoTime", "assertThat", "getPath", "is", "path", "children", "check", "property", "check", "property", "property", "check", "property", "children", "check", "getKey", "print", "nanoTime", "save", "print", "print", "millis", "abs", "nanoTime", "children", "check", "children", "check", "property", "check", "property", "property", "check", "property"]}, "focal_class": {"identifier": "WritableSessionCache", "superclass": "extends AbstractSessionCache", "interfaces": "", "fields": [{"original_string": "private static final AtomicInteger SAVE_NUMBER = new AtomicInteger(1);", "modifier": "private static final", "type": "AtomicInteger", "declarator": "SAVE_NUMBER = new AtomicInteger(1)", "var_name": "SAVE_NUMBER"}, {"original_string": "private static final int MAX_SAVE_NUMBER = 100;", "modifier": "private static final", "type": "int", "declarator": "MAX_SAVE_NUMBER = 100", "var_name": "MAX_SAVE_NUMBER"}, {"original_string": "private static final Logger SAVE_LOGGER = Logger.getLogger(\"org.modeshape.jcr.txn\");", "modifier": "private static final", "type": "Logger", "declarator": "SAVE_LOGGER = Logger.getLogger(\"org.modeshape.jcr.txn\")", "var_name": "SAVE_LOGGER"}, {"original_string": "private static final NodeKey REMOVED_KEY = new NodeKey(\"REMOVED_NODE_SHOULD_NEVER_BE_PERSISTED\");", "modifier": "private static final", "type": "NodeKey", "declarator": "REMOVED_KEY = new NodeKey(\"REMOVED_NODE_SHOULD_NEVER_BE_PERSISTED\")", "var_name": "REMOVED_KEY"}, {"original_string": "private static final SessionNode REMOVED = new SessionNode(REMOVED_KEY, false);", "modifier": "private static final", "type": "SessionNode", "declarator": "REMOVED = new SessionNode(REMOVED_KEY, false)", "var_name": "REMOVED"}, {"original_string": "private static final int MAX_REPEAT_FOR_LOCK_ACQUISITION_TIMEOUT = 4;", "modifier": "private static final", "type": "int", "declarator": "MAX_REPEAT_FOR_LOCK_ACQUISITION_TIMEOUT = 4", "var_name": "MAX_REPEAT_FOR_LOCK_ACQUISITION_TIMEOUT"}, {"original_string": "private static final long PAUSE_TIME_BEFORE_REPEAT_FOR_LOCK_ACQUISITION_TIMEOUT = 50L;", "modifier": "private static final", "type": "long", "declarator": "PAUSE_TIME_BEFORE_REPEAT_FOR_LOCK_ACQUISITION_TIMEOUT = 50L", "var_name": "PAUSE_TIME_BEFORE_REPEAT_FOR_LOCK_ACQUISITION_TIMEOUT"}, {"original_string": "private final static ConcurrentHashMap<String, Map<String, Transactions.TransactionFunction>> COMPLETE_FUNCTION_BY_TX_AND_WS = new ConcurrentHashMap<>();", "modifier": "private final static", "type": "ConcurrentHashMap<String, Map<String, Transactions.TransactionFunction>>", "declarator": "COMPLETE_FUNCTION_BY_TX_AND_WS = new ConcurrentHashMap<>()", "var_name": "COMPLETE_FUNCTION_BY_TX_AND_WS"}, {"original_string": "private final static ConcurrentHashMap<String, Set<String>> LOCKED_KEYS_BY_TX_ID = new ConcurrentHashMap<>();", "modifier": "private final static", "type": "ConcurrentHashMap<String, Set<String>>", "declarator": "LOCKED_KEYS_BY_TX_ID = new ConcurrentHashMap<>()", "var_name": "LOCKED_KEYS_BY_TX_ID"}, {"original_string": "private final ReadWriteLock lock = new ReentrantReadWriteLock();", "modifier": "private final", "type": "ReadWriteLock", "declarator": "lock = new ReentrantReadWriteLock()", "var_name": "lock"}, {"original_string": "private final Transactions txns;", "modifier": "private final", "type": "Transactions", "declarator": "txns", "var_name": "txns"}, {"original_string": "private final RepositoryEnvironment repositoryEnvironment;", "modifier": "private final", "type": "RepositoryEnvironment", "declarator": "repositoryEnvironment", "var_name": "repositoryEnvironment"}, {"original_string": "private final TransactionalWorkspaceCaches txWorkspaceCaches;", "modifier": "private final", "type": "TransactionalWorkspaceCaches", "declarator": "txWorkspaceCaches", "var_name": "txWorkspaceCaches"}, {"original_string": "private Map<NodeKey, SessionNode> changedNodes;", "modifier": "private", "type": "Map<NodeKey, SessionNode>", "declarator": "changedNodes", "var_name": "changedNodes"}, {"original_string": "private Set<NodeKey> replacedNodes;", "modifier": "private", "type": "Set<NodeKey>", "declarator": "replacedNodes", "var_name": "replacedNodes"}, {"original_string": "private LinkedHashSet<NodeKey> changedNodesInOrder;", "modifier": "private", "type": "LinkedHashSet<NodeKey>", "declarator": "changedNodesInOrder", "var_name": "changedNodesInOrder"}, {"original_string": "private Map<NodeKey, ReferrerChanges> referrerChangesForRemovedNodes;", "modifier": "private", "type": "Map<NodeKey, ReferrerChanges>", "declarator": "referrerChangesForRemovedNodes", "var_name": "referrerChangesForRemovedNodes"}, {"original_string": "private final ConcurrentHashMap<NodeKey, Set<BinaryKey>> binaryReferencesByNodeKey;", "modifier": "private final", "type": "ConcurrentHashMap<NodeKey, Set<BinaryKey>>", "declarator": "binaryReferencesByNodeKey", "var_name": "binaryReferencesByNodeKey"}], "methods": [{"identifier": "WritableSessionCache", "parameters": "(ExecutionContext context,\n                                WorkspaceCache workspaceCache,\n                                TransactionalWorkspaceCaches txWorkspaceCaches,\n                                RepositoryEnvironment repositoryEnvironment)", "modifiers": "public", "return": "", "signature": " WritableSessionCache(ExecutionContext context,\n                                WorkspaceCache workspaceCache,\n                                TransactionalWorkspaceCaches txWorkspaceCaches,\n                                RepositoryEnvironment repositoryEnvironment)", "full_signature": "public  WritableSessionCache(ExecutionContext context,\n                                WorkspaceCache workspaceCache,\n                                TransactionalWorkspaceCaches txWorkspaceCaches,\n                                RepositoryEnvironment repositoryEnvironment)", "class_method_signature": "WritableSessionCache.WritableSessionCache(ExecutionContext context,\n                                WorkspaceCache workspaceCache,\n                                TransactionalWorkspaceCaches txWorkspaceCaches,\n                                RepositoryEnvironment repositoryEnvironment)", "testcase": false, "constructor": true}, {"identifier": "assertInSession", "parameters": "( SessionNode node )", "modifiers": "protected final", "return": "void", "signature": "void assertInSession( SessionNode node )", "full_signature": "protected final void assertInSession( SessionNode node )", "class_method_signature": "WritableSessionCache.assertInSession( SessionNode node )", "testcase": false, "constructor": false}, {"identifier": "nodeTypes", "parameters": "()", "modifiers": "protected", "return": "NodeTypes", "signature": "NodeTypes nodeTypes()", "full_signature": "protected NodeTypes nodeTypes()", "class_method_signature": "WritableSessionCache.nodeTypes()", "testcase": false, "constructor": false}, {"identifier": "getNode", "parameters": "( NodeKey key )", "modifiers": "@Override public", "return": "CachedNode", "signature": "CachedNode getNode( NodeKey key )", "full_signature": "@Override public CachedNode getNode( NodeKey key )", "class_method_signature": "WritableSessionCache.getNode( NodeKey key )", "testcase": false, "constructor": false}, {"identifier": "mutable", "parameters": "( NodeKey key )", "modifiers": "@Override public", "return": "SessionNode", "signature": "SessionNode mutable( NodeKey key )", "full_signature": "@Override public SessionNode mutable( NodeKey key )", "class_method_signature": "WritableSessionCache.mutable( NodeKey key )", "testcase": false, "constructor": false}, {"identifier": "isReadOnly", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isReadOnly()", "full_signature": "@Override public boolean isReadOnly()", "class_method_signature": "WritableSessionCache.isReadOnly()", "testcase": false, "constructor": false}, {"identifier": "doClear", "parameters": "()", "modifiers": "@Override protected", "return": "void", "signature": "void doClear()", "full_signature": "@Override protected void doClear()", "class_method_signature": "WritableSessionCache.doClear()", "testcase": false, "constructor": false}, {"identifier": "doClear", "parameters": "( CachedNode node )", "modifiers": "@Override protected", "return": "void", "signature": "void doClear( CachedNode node )", "full_signature": "@Override protected void doClear( CachedNode node )", "class_method_signature": "WritableSessionCache.doClear( CachedNode node )", "testcase": false, "constructor": false}, {"identifier": "getChangedNodesAtOrBelowChildrenFirst", "parameters": "( Path nodePath )", "modifiers": "private", "return": "List<SessionNode>", "signature": "List<SessionNode> getChangedNodesAtOrBelowChildrenFirst( Path nodePath )", "full_signature": "private List<SessionNode> getChangedNodesAtOrBelowChildrenFirst( Path nodePath )", "class_method_signature": "WritableSessionCache.getChangedNodesAtOrBelowChildrenFirst( Path nodePath )", "testcase": false, "constructor": false}, {"identifier": "getChangedNodeKeys", "parameters": "()", "modifiers": "@Override public", "return": "Set<NodeKey>", "signature": "Set<NodeKey> getChangedNodeKeys()", "full_signature": "@Override public Set<NodeKey> getChangedNodeKeys()", "class_method_signature": "WritableSessionCache.getChangedNodeKeys()", "testcase": false, "constructor": false}, {"identifier": "getChangedNodeKeysAtOrBelow", "parameters": "( CachedNode srcNode )", "modifiers": "@Override public", "return": "Set<NodeKey>", "signature": "Set<NodeKey> getChangedNodeKeysAtOrBelow( CachedNode srcNode )", "full_signature": "@Override public Set<NodeKey> getChangedNodeKeysAtOrBelow( CachedNode srcNode )", "class_method_signature": "WritableSessionCache.getChangedNodeKeysAtOrBelow( CachedNode srcNode )", "testcase": false, "constructor": false}, {"identifier": "hasChanges", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean hasChanges()", "full_signature": "@Override public boolean hasChanges()", "class_method_signature": "WritableSessionCache.hasChanges()", "testcase": false, "constructor": false}, {"identifier": "checkForTransaction", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void checkForTransaction()", "full_signature": "@Override public void checkForTransaction()", "class_method_signature": "WritableSessionCache.checkForTransaction()", "testcase": false, "constructor": false}, {"identifier": "completeTransaction", "parameters": "(final String txId, String wsName)", "modifiers": "private", "return": "void", "signature": "void completeTransaction(final String txId, String wsName)", "full_signature": "private void completeTransaction(final String txId, String wsName)", "class_method_signature": "WritableSessionCache.completeTransaction(final String txId, String wsName)", "testcase": false, "constructor": false}, {"identifier": "logChangesBeingSaved", "parameters": "(Iterable<NodeKey> firstNodesInOrder,\n                                              Iterable<NodeKey> secondNodesInOrder)", "modifiers": "protected final", "return": "void", "signature": "void logChangesBeingSaved(Iterable<NodeKey> firstNodesInOrder,\n                                              Iterable<NodeKey> secondNodesInOrder)", "full_signature": "protected final void logChangesBeingSaved(Iterable<NodeKey> firstNodesInOrder,\n                                              Iterable<NodeKey> secondNodesInOrder)", "class_method_signature": "WritableSessionCache.logChangesBeingSaved(Iterable<NodeKey> firstNodesInOrder,\n                                              Iterable<NodeKey> secondNodesInOrder)", "testcase": false, "constructor": false}, {"identifier": "save", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void save()", "full_signature": "@Override public void save()", "class_method_signature": "WritableSessionCache.save()", "testcase": false, "constructor": false}, {"identifier": "save", "parameters": "( PreSave preSaveOperation )", "modifiers": "protected", "return": "void", "signature": "void save( PreSave preSaveOperation )", "full_signature": "protected void save( PreSave preSaveOperation )", "class_method_signature": "WritableSessionCache.save( PreSave preSaveOperation )", "testcase": false, "constructor": false}, {"identifier": "runBeforeLocking", "parameters": "(PreSave preSaveOperation)", "modifiers": "private", "return": "void", "signature": "void runBeforeLocking(PreSave preSaveOperation)", "full_signature": "private void runBeforeLocking(PreSave preSaveOperation)", "class_method_signature": "WritableSessionCache.runBeforeLocking(PreSave preSaveOperation)", "testcase": false, "constructor": false}, {"identifier": "runBeforeLocking", "parameters": "(PreSave preSaveOperation, Collection<NodeKey> filter)", "modifiers": "private", "return": "List<NodeKey>", "signature": "List<NodeKey> runBeforeLocking(PreSave preSaveOperation, Collection<NodeKey> filter)", "full_signature": "private List<NodeKey> runBeforeLocking(PreSave preSaveOperation, Collection<NodeKey> filter)", "class_method_signature": "WritableSessionCache.runBeforeLocking(PreSave preSaveOperation, Collection<NodeKey> filter)", "testcase": false, "constructor": false}, {"identifier": "runAfterLocking", "parameters": "(PreSave preSaveOperation)", "modifiers": "private", "return": "void", "signature": "void runAfterLocking(PreSave preSaveOperation)", "full_signature": "private void runAfterLocking(PreSave preSaveOperation)", "class_method_signature": "WritableSessionCache.runAfterLocking(PreSave preSaveOperation)", "testcase": false, "constructor": false}, {"identifier": "runAfterLocking", "parameters": "(PreSave preSaveOperation,\n                                 Collection<NodeKey> filter)", "modifiers": "private", "return": "void", "signature": "void runAfterLocking(PreSave preSaveOperation,\n                                 Collection<NodeKey> filter)", "full_signature": "private void runAfterLocking(PreSave preSaveOperation,\n                                 Collection<NodeKey> filter)", "class_method_signature": "WritableSessionCache.runAfterLocking(PreSave preSaveOperation,\n                                 Collection<NodeKey> filter)", "testcase": false, "constructor": false}, {"identifier": "clearState", "parameters": "()", "modifiers": "protected", "return": "void", "signature": "void clearState()", "full_signature": "protected void clearState()", "class_method_signature": "WritableSessionCache.clearState()", "testcase": false, "constructor": false}, {"identifier": "clearState", "parameters": "( Iterable<NodeKey> savedNodesInOrder )", "modifiers": "protected", "return": "void", "signature": "void clearState( Iterable<NodeKey> savedNodesInOrder )", "full_signature": "protected void clearState( Iterable<NodeKey> savedNodesInOrder )", "class_method_signature": "WritableSessionCache.clearState( Iterable<NodeKey> savedNodesInOrder )", "testcase": false, "constructor": false}, {"identifier": "save", "parameters": "( SessionCache other,\n                      PreSave preSaveOperation )", "modifiers": "@Override public", "return": "void", "signature": "void save( SessionCache other,\n                      PreSave preSaveOperation )", "full_signature": "@Override public void save( SessionCache other,\n                      PreSave preSaveOperation )", "class_method_signature": "WritableSessionCache.save( SessionCache other,\n                      PreSave preSaveOperation )", "testcase": false, "constructor": false}, {"identifier": "checkNodeNotRemovedByAnotherTransaction", "parameters": "( MutableCachedNode node )", "modifiers": "private", "return": "void", "signature": "void checkNodeNotRemovedByAnotherTransaction( MutableCachedNode node )", "full_signature": "private void checkNodeNotRemovedByAnotherTransaction( MutableCachedNode node )", "class_method_signature": "WritableSessionCache.checkNodeNotRemovedByAnotherTransaction( MutableCachedNode node )", "testcase": false, "constructor": false}, {"identifier": "save", "parameters": "( Set<NodeKey> toBeSaved,\n                      SessionCache other,\n                      PreSave preSaveOperation )", "modifiers": "@Override public", "return": "void", "signature": "void save( Set<NodeKey> toBeSaved,\n                      SessionCache other,\n                      PreSave preSaveOperation )", "full_signature": "@Override public void save( Set<NodeKey> toBeSaved,\n                      SessionCache other,\n                      PreSave preSaveOperation )", "class_method_signature": "WritableSessionCache.save( Set<NodeKey> toBeSaved,\n                      SessionCache other,\n                      PreSave preSaveOperation )", "testcase": false, "constructor": false}, {"identifier": "rollback", "parameters": "(Transaction txn, Exception cause)", "modifiers": "private", "return": "void", "signature": "void rollback(Transaction txn, Exception cause)", "full_signature": "private void rollback(Transaction txn, Exception cause)", "class_method_signature": "WritableSessionCache.rollback(Transaction txn, Exception cause)", "testcase": false, "constructor": false}, {"identifier": "persistChanges", "parameters": "(Iterable<NodeKey> changedNodesInOrder)", "modifiers": "@GuardedBy( \"lock\" ) protected", "return": "ChangeSet", "signature": "ChangeSet persistChanges(Iterable<NodeKey> changedNodesInOrder)", "full_signature": "@GuardedBy( \"lock\" ) protected ChangeSet persistChanges(Iterable<NodeKey> changedNodesInOrder)", "class_method_signature": "WritableSessionCache.persistChanges(Iterable<NodeKey> changedNodesInOrder)", "testcase": false, "constructor": false}, {"identifier": "computePathChangesForSNS", "parameters": "( PathCache workspacePaths,\n                                                                    Path parentPath,\n                                                                    ChildReferences childReferences,\n                                                                    ChildReference reorderedChildRef,\n                                                                    Path newChildPath,\n                                                                    Path oldChildPath )", "modifiers": "private", "return": "Map<NodeKey, Map<Path, Path>>", "signature": "Map<NodeKey, Map<Path, Path>> computePathChangesForSNS( PathCache workspacePaths,\n                                                                    Path parentPath,\n                                                                    ChildReferences childReferences,\n                                                                    ChildReference reorderedChildRef,\n                                                                    Path newChildPath,\n                                                                    Path oldChildPath )", "full_signature": "private Map<NodeKey, Map<Path, Path>> computePathChangesForSNS( PathCache workspacePaths,\n                                                                    Path parentPath,\n                                                                    ChildReferences childReferences,\n                                                                    ChildReference reorderedChildRef,\n                                                                    Path newChildPath,\n                                                                    Path oldChildPath )", "class_method_signature": "WritableSessionCache.computePathChangesForSNS( PathCache workspacePaths,\n                                                                    Path parentPath,\n                                                                    ChildReferences childReferences,\n                                                                    ChildReference reorderedChildRef,\n                                                                    Path newChildPath,\n                                                                    Path oldChildPath )", "testcase": false, "constructor": false}, {"identifier": "lockNodes", "parameters": "(Collection<NodeKey> changedNodesInOrder)", "modifiers": "private", "return": "void", "signature": "void lockNodes(Collection<NodeKey> changedNodesInOrder)", "full_signature": "private void lockNodes(Collection<NodeKey> changedNodesInOrder)", "class_method_signature": "WritableSessionCache.lockNodes(Collection<NodeKey> changedNodesInOrder)", "testcase": false, "constructor": false}, {"identifier": "keysToLockForNode", "parameters": "(NodeKey key)", "modifiers": "private", "return": "Set<String>", "signature": "Set<String> keysToLockForNode(NodeKey key)", "full_signature": "private Set<String> keysToLockForNode(NodeKey key)", "class_method_signature": "WritableSessionCache.keysToLockForNode(NodeKey key)", "testcase": false, "constructor": false}, {"identifier": "binaryUsageUpdateFunction", "parameters": "( final Set<BinaryKey> usedBinaries,\n                                                                        final Set<BinaryKey> unusedBinaries )", "modifiers": "private", "return": "Transactions.TransactionFunction", "signature": "Transactions.TransactionFunction binaryUsageUpdateFunction( final Set<BinaryKey> usedBinaries,\n                                                                        final Set<BinaryKey> unusedBinaries )", "full_signature": "private Transactions.TransactionFunction binaryUsageUpdateFunction( final Set<BinaryKey> usedBinaries,\n                                                                        final Set<BinaryKey> unusedBinaries )", "class_method_signature": "WritableSessionCache.binaryUsageUpdateFunction( final Set<BinaryKey> usedBinaries,\n                                                                        final Set<BinaryKey> unusedBinaries )", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "( SessionNode newNode )", "modifiers": "protected", "return": "SessionNode", "signature": "SessionNode add( SessionNode newNode )", "full_signature": "protected SessionNode add( SessionNode newNode )", "class_method_signature": "WritableSessionCache.add( SessionNode newNode )", "testcase": false, "constructor": false}, {"identifier": "destroy", "parameters": "( NodeKey key )", "modifiers": "@SuppressWarnings( \"finally\" ) @Override public", "return": "void", "signature": "void destroy( NodeKey key )", "full_signature": "@SuppressWarnings( \"finally\" ) @Override public void destroy( NodeKey key )", "class_method_signature": "WritableSessionCache.destroy( NodeKey key )", "testcase": false, "constructor": false}, {"identifier": "collectBinaryReferences", "parameters": "(NodeKey nodeKey, Property property)", "modifiers": "private", "return": "void", "signature": "void collectBinaryReferences(NodeKey nodeKey, Property property)", "full_signature": "private void collectBinaryReferences(NodeKey nodeKey, Property property)", "class_method_signature": "WritableSessionCache.collectBinaryReferences(NodeKey nodeKey, Property property)", "testcase": false, "constructor": false}, {"identifier": "isDestroyed", "parameters": "( NodeKey key )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isDestroyed( NodeKey key )", "full_signature": "@Override public boolean isDestroyed( NodeKey key )", "class_method_signature": "WritableSessionCache.isDestroyed( NodeKey key )", "testcase": false, "constructor": false}, {"identifier": "addBinaryReference", "parameters": "( NodeKey nodeKey, BinaryKey... binaryKeys )", "modifiers": "protected", "return": "void", "signature": "void addBinaryReference( NodeKey nodeKey, BinaryKey... binaryKeys )", "full_signature": "protected void addBinaryReference( NodeKey nodeKey, BinaryKey... binaryKeys )", "class_method_signature": "WritableSessionCache.addBinaryReference( NodeKey nodeKey, BinaryKey... binaryKeys )", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "WritableSessionCache.toString()", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/cache/document/WritableSessionCache.java"}, "focal_method": {"identifier": "save", "parameters": "()", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void save() {\n        save((PreSave)null);\n    }", "signature": "void save()", "full_signature": "@Override public void save()", "class_method_signature": "WritableSessionCache.save()", "testcase": false, "constructor": false, "invocations": ["save"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}