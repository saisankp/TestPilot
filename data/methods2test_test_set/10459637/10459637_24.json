{"test_class": {"identifier": "IPv4Test", "superclass": "", "interfaces": "", "fields": [], "file": "network-level/fl-ho-nl/src/test/java/net/floodlightcontroller/packet/IPv4Test.java"}, "test_case": {"identifier": "testToIPv4AddressBytes", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testToIPv4AddressBytes() {\n        byte[] expected = new byte[] {(byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        Assert.assertArrayEquals(expected, IPv4.toIPv4AddressBytes(\"255.255.255.255\"));\n        expected = new byte[] {(byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80};\n        Assert.assertArrayEquals(expected, IPv4.toIPv4AddressBytes(\"128.128.128.128\"));\n        expected = new byte[] {0x7f,0x7f,0x7f,0x7f};\n        Assert.assertArrayEquals(expected, IPv4.toIPv4AddressBytes(\"127.127.127.127\"));\n    }", "signature": "void testToIPv4AddressBytes()", "full_signature": "@Test public void testToIPv4AddressBytes()", "class_method_signature": "IPv4Test.testToIPv4AddressBytes()", "testcase": true, "constructor": false, "invocations": ["assertArrayEquals", "toIPv4AddressBytes", "assertArrayEquals", "toIPv4AddressBytes", "assertArrayEquals", "toIPv4AddressBytes"]}, "focal_class": {"identifier": "IPv4", "superclass": "extends BasePacket", "interfaces": "", "fields": [{"original_string": "public static final byte PROTOCOL_ICMP = 0x1;", "modifier": "public static final", "type": "byte", "declarator": "PROTOCOL_ICMP = 0x1", "var_name": "PROTOCOL_ICMP"}, {"original_string": "public static final byte PROTOCOL_TCP = 0x6;", "modifier": "public static final", "type": "byte", "declarator": "PROTOCOL_TCP = 0x6", "var_name": "PROTOCOL_TCP"}, {"original_string": "public static final byte PROTOCOL_UDP = 0x11;", "modifier": "public static final", "type": "byte", "declarator": "PROTOCOL_UDP = 0x11", "var_name": "PROTOCOL_UDP"}, {"original_string": "public static Map<Byte, Class<? extends IPacket>> protocolClassMap;", "modifier": "public static", "type": "Map<Byte, Class<? extends IPacket>>", "declarator": "protocolClassMap", "var_name": "protocolClassMap"}, {"original_string": "protected byte version;", "modifier": "protected", "type": "byte", "declarator": "version", "var_name": "version"}, {"original_string": "protected byte headerLength;", "modifier": "protected", "type": "byte", "declarator": "headerLength", "var_name": "headerLength"}, {"original_string": "protected byte diffServ;", "modifier": "protected", "type": "byte", "declarator": "diffServ", "var_name": "diffServ"}, {"original_string": "protected short totalLength;", "modifier": "protected", "type": "short", "declarator": "totalLength", "var_name": "totalLength"}, {"original_string": "protected short identification;", "modifier": "protected", "type": "short", "declarator": "identification", "var_name": "identification"}, {"original_string": "protected byte flags;", "modifier": "protected", "type": "byte", "declarator": "flags", "var_name": "flags"}, {"original_string": "protected short fragmentOffset;", "modifier": "protected", "type": "short", "declarator": "fragmentOffset", "var_name": "fragmentOffset"}, {"original_string": "protected byte ttl;", "modifier": "protected", "type": "byte", "declarator": "ttl", "var_name": "ttl"}, {"original_string": "protected byte protocol;", "modifier": "protected", "type": "byte", "declarator": "protocol", "var_name": "protocol"}, {"original_string": "protected short checksum;", "modifier": "protected", "type": "short", "declarator": "checksum", "var_name": "checksum"}, {"original_string": "protected int sourceAddress;", "modifier": "protected", "type": "int", "declarator": "sourceAddress", "var_name": "sourceAddress"}, {"original_string": "protected int destinationAddress;", "modifier": "protected", "type": "int", "declarator": "destinationAddress", "var_name": "destinationAddress"}, {"original_string": "protected byte[] options;", "modifier": "protected", "type": "byte[]", "declarator": "options", "var_name": "options"}, {"original_string": "protected boolean isTruncated;", "modifier": "protected", "type": "boolean", "declarator": "isTruncated", "var_name": "isTruncated"}], "methods": [{"identifier": "IPv4", "parameters": "()", "modifiers": "public", "return": "", "signature": " IPv4()", "full_signature": "public  IPv4()", "class_method_signature": "IPv4.IPv4()", "testcase": false, "constructor": true}, {"identifier": "getVersion", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getVersion()", "full_signature": "public byte getVersion()", "class_method_signature": "IPv4.getVersion()", "testcase": false, "constructor": false}, {"identifier": "setVersion", "parameters": "(byte version)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setVersion(byte version)", "full_signature": "public IPv4 setVersion(byte version)", "class_method_signature": "IPv4.setVersion(byte version)", "testcase": false, "constructor": false}, {"identifier": "getHeaderLength", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getHeaderLength()", "full_signature": "public byte getHeaderLength()", "class_method_signature": "IPv4.getHeaderLength()", "testcase": false, "constructor": false}, {"identifier": "getDiffServ", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getDiffServ()", "full_signature": "public byte getDiffServ()", "class_method_signature": "IPv4.getDiffServ()", "testcase": false, "constructor": false}, {"identifier": "setDiffServ", "parameters": "(byte diffServ)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDiffServ(byte diffServ)", "full_signature": "public IPv4 setDiffServ(byte diffServ)", "class_method_signature": "IPv4.setDiffServ(byte diffServ)", "testcase": false, "constructor": false}, {"identifier": "getTotalLength", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getTotalLength()", "full_signature": "public short getTotalLength()", "class_method_signature": "IPv4.getTotalLength()", "testcase": false, "constructor": false}, {"identifier": "getIdentification", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getIdentification()", "full_signature": "public short getIdentification()", "class_method_signature": "IPv4.getIdentification()", "testcase": false, "constructor": false}, {"identifier": "isTruncated", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isTruncated()", "full_signature": "public boolean isTruncated()", "class_method_signature": "IPv4.isTruncated()", "testcase": false, "constructor": false}, {"identifier": "setTruncated", "parameters": "(boolean isTruncated)", "modifiers": "public", "return": "void", "signature": "void setTruncated(boolean isTruncated)", "full_signature": "public void setTruncated(boolean isTruncated)", "class_method_signature": "IPv4.setTruncated(boolean isTruncated)", "testcase": false, "constructor": false}, {"identifier": "setIdentification", "parameters": "(short identification)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setIdentification(short identification)", "full_signature": "public IPv4 setIdentification(short identification)", "class_method_signature": "IPv4.setIdentification(short identification)", "testcase": false, "constructor": false}, {"identifier": "getFlags", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getFlags()", "full_signature": "public byte getFlags()", "class_method_signature": "IPv4.getFlags()", "testcase": false, "constructor": false}, {"identifier": "setFlags", "parameters": "(byte flags)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setFlags(byte flags)", "full_signature": "public IPv4 setFlags(byte flags)", "class_method_signature": "IPv4.setFlags(byte flags)", "testcase": false, "constructor": false}, {"identifier": "getFragmentOffset", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getFragmentOffset()", "full_signature": "public short getFragmentOffset()", "class_method_signature": "IPv4.getFragmentOffset()", "testcase": false, "constructor": false}, {"identifier": "setFragmentOffset", "parameters": "(short fragmentOffset)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setFragmentOffset(short fragmentOffset)", "full_signature": "public IPv4 setFragmentOffset(short fragmentOffset)", "class_method_signature": "IPv4.setFragmentOffset(short fragmentOffset)", "testcase": false, "constructor": false}, {"identifier": "getTtl", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getTtl()", "full_signature": "public byte getTtl()", "class_method_signature": "IPv4.getTtl()", "testcase": false, "constructor": false}, {"identifier": "setTtl", "parameters": "(byte ttl)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setTtl(byte ttl)", "full_signature": "public IPv4 setTtl(byte ttl)", "class_method_signature": "IPv4.setTtl(byte ttl)", "testcase": false, "constructor": false}, {"identifier": "getProtocol", "parameters": "()", "modifiers": "public", "return": "byte", "signature": "byte getProtocol()", "full_signature": "public byte getProtocol()", "class_method_signature": "IPv4.getProtocol()", "testcase": false, "constructor": false}, {"identifier": "setProtocol", "parameters": "(byte protocol)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setProtocol(byte protocol)", "full_signature": "public IPv4 setProtocol(byte protocol)", "class_method_signature": "IPv4.setProtocol(byte protocol)", "testcase": false, "constructor": false}, {"identifier": "getChecksum", "parameters": "()", "modifiers": "public", "return": "short", "signature": "short getChecksum()", "full_signature": "public short getChecksum()", "class_method_signature": "IPv4.getChecksum()", "testcase": false, "constructor": false}, {"identifier": "setChecksum", "parameters": "(short checksum)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setChecksum(short checksum)", "full_signature": "public IPv4 setChecksum(short checksum)", "class_method_signature": "IPv4.setChecksum(short checksum)", "testcase": false, "constructor": false}, {"identifier": "resetChecksum", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void resetChecksum()", "full_signature": "@Override public void resetChecksum()", "class_method_signature": "IPv4.resetChecksum()", "testcase": false, "constructor": false}, {"identifier": "getSourceAddress", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getSourceAddress()", "full_signature": "public int getSourceAddress()", "class_method_signature": "IPv4.getSourceAddress()", "testcase": false, "constructor": false}, {"identifier": "setSourceAddress", "parameters": "(int sourceAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setSourceAddress(int sourceAddress)", "full_signature": "public IPv4 setSourceAddress(int sourceAddress)", "class_method_signature": "IPv4.setSourceAddress(int sourceAddress)", "testcase": false, "constructor": false}, {"identifier": "setSourceAddress", "parameters": "(String sourceAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setSourceAddress(String sourceAddress)", "full_signature": "public IPv4 setSourceAddress(String sourceAddress)", "class_method_signature": "IPv4.setSourceAddress(String sourceAddress)", "testcase": false, "constructor": false}, {"identifier": "getDestinationAddress", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getDestinationAddress()", "full_signature": "public int getDestinationAddress()", "class_method_signature": "IPv4.getDestinationAddress()", "testcase": false, "constructor": false}, {"identifier": "setDestinationAddress", "parameters": "(int destinationAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDestinationAddress(int destinationAddress)", "full_signature": "public IPv4 setDestinationAddress(int destinationAddress)", "class_method_signature": "IPv4.setDestinationAddress(int destinationAddress)", "testcase": false, "constructor": false}, {"identifier": "setDestinationAddress", "parameters": "(String destinationAddress)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setDestinationAddress(String destinationAddress)", "full_signature": "public IPv4 setDestinationAddress(String destinationAddress)", "class_method_signature": "IPv4.setDestinationAddress(String destinationAddress)", "testcase": false, "constructor": false}, {"identifier": "getOptions", "parameters": "()", "modifiers": "public", "return": "byte[]", "signature": "byte[] getOptions()", "full_signature": "public byte[] getOptions()", "class_method_signature": "IPv4.getOptions()", "testcase": false, "constructor": false}, {"identifier": "setOptions", "parameters": "(byte[] options)", "modifiers": "public", "return": "IPv4", "signature": "IPv4 setOptions(byte[] options)", "full_signature": "public IPv4 setOptions(byte[] options)", "class_method_signature": "IPv4.setOptions(byte[] options)", "testcase": false, "constructor": false}, {"identifier": "serialize", "parameters": "()", "modifiers": "public", "return": "byte[]", "signature": "byte[] serialize()", "full_signature": "public byte[] serialize()", "class_method_signature": "IPv4.serialize()", "testcase": false, "constructor": false}, {"identifier": "deserialize", "parameters": "(byte[] data, int offset, int length)", "modifiers": "@Override public", "return": "IPacket", "signature": "IPacket deserialize(byte[] data, int offset, int length)", "full_signature": "@Override public IPacket deserialize(byte[] data, int offset, int length)", "class_method_signature": "IPv4.deserialize(byte[] data, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "toIPv4Address", "parameters": "(String ipAddress)", "modifiers": "public static", "return": "int", "signature": "int toIPv4Address(String ipAddress)", "full_signature": "public static int toIPv4Address(String ipAddress)", "class_method_signature": "IPv4.toIPv4Address(String ipAddress)", "testcase": false, "constructor": false}, {"identifier": "toIPv4Address", "parameters": "(byte[] ipAddress)", "modifiers": "public static", "return": "int", "signature": "int toIPv4Address(byte[] ipAddress)", "full_signature": "public static int toIPv4Address(byte[] ipAddress)", "class_method_signature": "IPv4.toIPv4Address(byte[] ipAddress)", "testcase": false, "constructor": false}, {"identifier": "fromIPv4Address", "parameters": "(int ipAddress)", "modifiers": "public static", "return": "String", "signature": "String fromIPv4Address(int ipAddress)", "full_signature": "public static String fromIPv4Address(int ipAddress)", "class_method_signature": "IPv4.fromIPv4Address(int ipAddress)", "testcase": false, "constructor": false}, {"identifier": "fromIPv4AddressCollection", "parameters": "(Collection<Integer> ipAddresses)", "modifiers": "public static", "return": "String", "signature": "String fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "full_signature": "public static String fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "class_method_signature": "IPv4.fromIPv4AddressCollection(Collection<Integer> ipAddresses)", "testcase": false, "constructor": false}, {"identifier": "toIPv4AddressBytes", "parameters": "(String ipAddress)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] toIPv4AddressBytes(String ipAddress)", "full_signature": "public static byte[] toIPv4AddressBytes(String ipAddress)", "class_method_signature": "IPv4.toIPv4AddressBytes(String ipAddress)", "testcase": false, "constructor": false}, {"identifier": "toIPv4AddressBytes", "parameters": "(int ipAddress)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] toIPv4AddressBytes(int ipAddress)", "full_signature": "public static byte[] toIPv4AddressBytes(int ipAddress)", "class_method_signature": "IPv4.toIPv4AddressBytes(int ipAddress)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "IPv4.hashCode()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "IPv4.equals(Object obj)", "testcase": false, "constructor": false}], "file": "network-level/fl-ho-nl/src/main/java/net/floodlightcontroller/packet/IPv4.java"}, "focal_method": {"identifier": "toIPv4AddressBytes", "parameters": "(String ipAddress)", "modifiers": "public static", "return": "byte[]", "body": "public static byte[] toIPv4AddressBytes(String ipAddress) {\n        String[] octets = ipAddress.split(\"\\\\.\");\n        if (octets.length != 4) \n            throw new IllegalArgumentException(\"Specified IPv4 address must\" +\n                \"contain 4 sets of numerical digits separated by periods\");\n\n        byte[] result = new byte[4];\n        for (int i = 0; i < 4; ++i) {\n            result[i] = Integer.valueOf(octets[i]).byteValue();\n        }\n        return result;\n    }", "signature": "byte[] toIPv4AddressBytes(String ipAddress)", "full_signature": "public static byte[] toIPv4AddressBytes(String ipAddress)", "class_method_signature": "IPv4.toIPv4AddressBytes(String ipAddress)", "testcase": false, "constructor": false, "invocations": ["split", "byteValue", "valueOf"]}, "repository": {"repo_id": 10459637, "url": "https://github.com/rizard/geni-openflow-vertical-handover", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 7, "size": 33971, "license": "licensed"}}