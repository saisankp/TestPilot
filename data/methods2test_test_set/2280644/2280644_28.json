{"test_class": {"identifier": "MapCommandTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Key completeChar = Key.CTRL_I;", "modifier": "private final", "type": "Key", "declarator": "completeChar = Key.CTRL_I", "var_name": "completeChar"}], "file": "aesh/src/test/java/org/aesh/command/map/MapCommandTest.java"}, "test_case": {"identifier": "testCompletionWithStaticOptions", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCompletionWithStaticOptions() throws Exception {\n        TestConnection connection = new TestConnection(false);\n\n        // Build dynamic command.\n        DynCommand1 cmd = new DynCommand1();\n        DynamicOptionsProvider provider = new DynamicOptionsProvider();\n\n        MapProcessedCommandBuilder builder = MapProcessedCommandBuilder.builder();\n        builder.command(cmd);\n        // Retrieve dynamic options during completion.\n        builder.lookupAtCompletionOnly(true);\n        builder.name(\"dyn1\");\n\n        {\n            ProcessedOptionBuilder optBuilder = ProcessedOptionBuilder.builder();\n            optBuilder.name(\"verbose\");\n            optBuilder.hasValue(false);\n            optBuilder.type(Boolean.class);\n            builder.addOption(optBuilder.build());\n        }\n\n        {\n            ProcessedOptionBuilder optBuilder = ProcessedOptionBuilder.builder();\n            optBuilder.name(\"dir\");\n            optBuilder.hasValue(true);\n            optBuilder.type(String.class);\n            builder.addOption(optBuilder.build());\n        }\n        builder.optionProvider(provider);\n\n        CommandRegistry registry = AeshCommandRegistryBuilder.builder()\n                .command(builder.create())\n                .create();\n\n        Settings settings = SettingsBuilder.builder()\n                .logging(true)\n                .connection(connection)\n                .commandRegistry(registry)\n                .build();\n\n        ReadlineConsole console = new ReadlineConsole(settings);\n        console.setPrompt(new Prompt(\"\"));\n        console.start();\n\n        // First test without any dynamic option provided.\n        connection.clearOutputBuffer();\n        connection.read(\"d\");\n        connection.read(completeChar.getFirstValue());\n        assertEquals(\"dyn1 \", connection.getOutputBuffer());\n\n        connection.read(completeChar.getFirstValue());\n        assertEquals(\"dyn1 --\", connection.getOutputBuffer());\n\n        connection.read(\"v\");\n        connection.read(completeChar.getFirstValue());\n        assertEquals(\"dyn1 --verbose \", connection.getOutputBuffer());\n\n        connection.read(\"--\");\n        connection.read(completeChar.getFirstValue());\n        assertEquals(\"dyn1 --verbose --dir=\", connection.getOutputBuffer());\n\n        connection.read(\"toto\");\n        // Execute command.\n        connection.read(Config.getLineSeparator());\n        connection.clearOutputBuffer();\n        Thread.sleep(200);\n        {\n            String val = (String) cmd.options.get(\"dir\");\n            assertEquals(\"toto\", val);\n        }\n        assertTrue(cmd.contains(\"verbose\"));\n\n        // Enable dynamic commands\n        provider.options = getOptions();\n\n        connection.read(\"dyn1 --verbose\");\n        connection.read(completeChar.getFirstValue());\n        assertEquals(\"dyn1 --verbose \", connection.getOutputBuffer());\n\n        connection.read(completeChar.getFirstValue());\n        assertEquals(\"dyn1 --verbose --\", connection.getOutputBuffer());\n\n        connection.read(\"opt-dyn1\");\n        connection.read(completeChar.getFirstValue());\n        assertEquals(\"dyn1 --verbose --opt-dyn1-withvalue=\", connection.getOutputBuffer());\n\n        connection.read(\"xxx \");\n        connection.read(completeChar.getFirstValue());\n        assertEquals(\"dyn1 --verbose --opt-dyn1-withvalue=xxx --\", connection.getOutputBuffer());\n\n        connection.read(\"d\");\n        connection.read(completeChar.getFirstValue());\n        assertEquals(\"dyn1 --verbose --opt-dyn1-withvalue=xxx --dir=\", connection.getOutputBuffer());\n\n        connection.read(\"tutu \");\n        connection.read(completeChar.getFirstValue());\n        assertEquals(\"dyn1 --verbose --opt-dyn1-withvalue=xxx --dir=tutu --opt-dyn\", connection.getOutputBuffer());\n\n        connection.read(\"2-withvalue=yyy --\");\n        connection.read(completeChar.getFirstValue());\n        assertEquals(\"dyn1 --verbose --opt-dyn1-withvalue=xxx --dir=tutu --opt-dyn2-withvalue=yyy --opt-dyn3-novalue \", connection.getOutputBuffer());\n\n        // Execute command.\n        connection.read(Config.getLineSeparator());\n        connection.clearOutputBuffer();\n        Thread.sleep(200);\n        {\n            String val = (String) cmd.options.get(\"dir\");\n            assertEquals(\"tutu\", val);\n        }\n        {\n            String val = (String) cmd.options.get(\"opt-dyn1-withvalue\");\n            assertEquals(\"xxx\", val);\n        }\n        {\n            String val = (String) cmd.options.get(\"opt-dyn2-withvalue\");\n            assertEquals(\"yyy\", val);\n        }\n        assertTrue(cmd.contains(\"verbose\"));\n        assertTrue(cmd.contains(\"opt-dyn3-novalue\"));\n    }", "signature": "void testCompletionWithStaticOptions()", "full_signature": "@Test public void testCompletionWithStaticOptions()", "class_method_signature": "MapCommandTest.testCompletionWithStaticOptions()", "testcase": true, "constructor": false, "invocations": ["builder", "command", "lookupAtCompletionOnly", "name", "builder", "name", "hasValue", "type", "addOption", "build", "builder", "name", "hasValue", "type", "addOption", "build", "optionProvider", "create", "command", "builder", "create", "build", "commandRegistry", "connection", "logging", "builder", "setPrompt", "start", "clearOutputBuffer", "read", "read", "getFirstValue", "assertEquals", "getOutputBuffer", "read", "getFirstValue", "assertEquals", "getOutputBuffer", "read", "read", "getFirstValue", "assertEquals", "getOutputBuffer", "read", "read", "getFirstValue", "assertEquals", "getOutputBuffer", "read", "read", "getLineSeparator", "clearOutputBuffer", "sleep", "get", "assertEquals", "assertTrue", "contains", "getOptions", "read", "read", "getFirstValue", "assertEquals", "getOutputBuffer", "read", "getFirstValue", "assertEquals", "getOutputBuffer", "read", "read", "getFirstValue", "assertEquals", "getOutputBuffer", "read", "read", "getFirstValue", "assertEquals", "getOutputBuffer", "read", "read", "getFirstValue", "assertEquals", "getOutputBuffer", "read", "read", "getFirstValue", "assertEquals", "getOutputBuffer", "read", "read", "getFirstValue", "assertEquals", "getOutputBuffer", "read", "getLineSeparator", "clearOutputBuffer", "sleep", "get", "assertEquals", "get", "assertEquals", "get", "assertEquals", "assertTrue", "contains", "assertTrue", "contains"]}, "focal_class": {"identifier": "MapCommand", "superclass": "", "interfaces": "implements Command<T>", "fields": [{"original_string": "private final Map<String, Object> values = new HashMap<>();", "modifier": "private final", "type": "Map<String, Object>", "declarator": "values = new HashMap<>()", "var_name": "values"}], "methods": [{"identifier": "getValue", "parameters": "(String name)", "modifiers": "public", "return": "Object", "signature": "Object getValue(String name)", "full_signature": "public Object getValue(String name)", "class_method_signature": "MapCommand.getValue(String name)", "testcase": false, "constructor": false}, {"identifier": "setValue", "parameters": "(String name, Object value)", "modifiers": "public", "return": "void", "signature": "void setValue(String name, Object value)", "full_signature": "public void setValue(String name, Object value)", "class_method_signature": "MapCommand.setValue(String name, Object value)", "testcase": false, "constructor": false}, {"identifier": "resetValue", "parameters": "(String name)", "modifiers": "public", "return": "void", "signature": "void resetValue(String name)", "full_signature": "public void resetValue(String name)", "class_method_signature": "MapCommand.resetValue(String name)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(String name)", "modifiers": "public", "return": "boolean", "signature": "boolean contains(String name)", "full_signature": "public boolean contains(String name)", "class_method_signature": "MapCommand.contains(String name)", "testcase": false, "constructor": false}, {"identifier": "getValues", "parameters": "()", "modifiers": "public", "return": "Map<String, Object>", "signature": "Map<String, Object> getValues()", "full_signature": "public Map<String, Object> getValues()", "class_method_signature": "MapCommand.getValues()", "testcase": false, "constructor": false}, {"identifier": "checkForRequiredOptions", "parameters": "(ParsedLine pl)", "modifiers": "public", "return": "boolean", "signature": "boolean checkForRequiredOptions(ParsedLine pl)", "full_signature": "public boolean checkForRequiredOptions(ParsedLine pl)", "class_method_signature": "MapCommand.checkForRequiredOptions(ParsedLine pl)", "testcase": false, "constructor": false}, {"identifier": "resetAll", "parameters": "()", "modifiers": "", "return": "void", "signature": "void resetAll()", "full_signature": " void resetAll()", "class_method_signature": "MapCommand.resetAll()", "testcase": false, "constructor": false}], "file": "aesh/src/main/java/org/aesh/command/map/MapCommand.java"}, "focal_method": {"identifier": "contains", "parameters": "(String name)", "modifiers": "public", "return": "boolean", "body": "public boolean contains(String name) {\n        return values.containsKey(name);\n    }", "signature": "boolean contains(String name)", "full_signature": "public boolean contains(String name)", "class_method_signature": "MapCommand.contains(String name)", "testcase": false, "constructor": false, "invocations": ["containsKey"]}, "repository": {"repo_id": 2280644, "url": "https://github.com/aeshell/aesh", "language": "Java", "is_fork": false, "fork_count": 62, "stargazer_count": 83, "size": 6068, "license": "licensed"}}