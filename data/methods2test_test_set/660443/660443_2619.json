{"test_class": {"identifier": "AbstractVFStateTest", "superclass": "", "interfaces": "", "fields": [], "file": "base/isomorphism/src/test/java/org/openscience/cdk/isomorphism/AbstractVFStateTest.java"}, "test_case": {"identifier": "nextMAt0", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void nextMAt0() {\n        AbstractVFState state = create(5, 10);\n        assertThat(state.nextM(0, -1), is(0));\n        assertThat(state.nextM(0, 0), is(1));\n        assertThat(state.nextM(0, 1), is(2));\n        assertThat(state.nextM(0, 2), is(3));\n    }", "signature": "void nextMAt0()", "full_signature": "@Test public void nextMAt0()", "class_method_signature": "AbstractVFStateTest.nextMAt0()", "testcase": true, "constructor": false, "invocations": ["create", "assertThat", "nextM", "is", "assertThat", "nextM", "is", "assertThat", "nextM", "is", "assertThat", "nextM", "is"]}, "focal_class": {"identifier": "AbstractVFState", "superclass": "extends State", "interfaces": "", "fields": [{"original_string": "protected static final int UNMAPPED = -1;", "modifier": "protected static final", "type": "int", "declarator": "UNMAPPED = -1", "var_name": "UNMAPPED"}, {"original_string": "protected final int[][]    g1, g2;", "modifier": "protected final", "type": "int[][]", "declarator": "g1", "var_name": "g1"}, {"original_string": "protected final int[]      m1, m2;", "modifier": "protected final", "type": "int[]", "declarator": "m1", "var_name": "m1"}, {"original_string": "protected final int[]      t1, t2;", "modifier": "protected final", "type": "int[]", "declarator": "t1", "var_name": "t1"}, {"original_string": "protected int              size;", "modifier": "protected", "type": "int", "declarator": "size", "var_name": "size"}], "methods": [{"identifier": "AbstractVFState", "parameters": "(final int[][] g1, final int[][] g2)", "modifiers": "public", "return": "", "signature": " AbstractVFState(final int[][] g1, final int[][] g2)", "full_signature": "public  AbstractVFState(final int[][] g1, final int[][] g2)", "class_method_signature": "AbstractVFState.AbstractVFState(final int[][] g1, final int[][] g2)", "testcase": false, "constructor": true}, {"identifier": "nextN", "parameters": "(int n)", "modifiers": "@Override final", "return": "int", "signature": "int nextN(int n)", "full_signature": "@Override final int nextN(int n)", "class_method_signature": "AbstractVFState.nextN(int n)", "testcase": false, "constructor": false}, {"identifier": "nextM", "parameters": "(int n, int m)", "modifiers": "@Override final", "return": "int", "signature": "int nextM(int n, int m)", "full_signature": "@Override final int nextM(int n, int m)", "class_method_signature": "AbstractVFState.nextM(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "nMax", "parameters": "()", "modifiers": "@Override final", "return": "int", "signature": "int nMax()", "full_signature": "@Override final int nMax()", "class_method_signature": "AbstractVFState.nMax()", "testcase": false, "constructor": false}, {"identifier": "mMax", "parameters": "()", "modifiers": "@Override final", "return": "int", "signature": "int mMax()", "full_signature": "@Override final int mMax()", "class_method_signature": "AbstractVFState.mMax()", "testcase": false, "constructor": false}, {"identifier": "add", "parameters": "(int n, int m)", "modifiers": "@Override final", "return": "boolean", "signature": "boolean add(int n, int m)", "full_signature": "@Override final boolean add(int n, int m)", "class_method_signature": "AbstractVFState.add(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(int n, int m)", "modifiers": "@Override final", "return": "void", "signature": "void remove(int n, int m)", "full_signature": "@Override final void remove(int n, int m)", "class_method_signature": "AbstractVFState.remove(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "feasible", "parameters": "(int n, int m)", "modifiers": "abstract", "return": "boolean", "signature": "boolean feasible(int n, int m)", "full_signature": "abstract boolean feasible(int n, int m)", "class_method_signature": "AbstractVFState.feasible(int n, int m)", "testcase": false, "constructor": false}, {"identifier": "mapping", "parameters": "()", "modifiers": "@Override", "return": "int[]", "signature": "int[] mapping()", "full_signature": "@Override int[] mapping()", "class_method_signature": "AbstractVFState.mapping()", "testcase": false, "constructor": false}, {"identifier": "size", "parameters": "()", "modifiers": "@Override", "return": "int", "signature": "int size()", "full_signature": "@Override int size()", "class_method_signature": "AbstractVFState.size()", "testcase": false, "constructor": false}], "file": "base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/AbstractVFState.java"}, "focal_method": {"identifier": "nextM", "parameters": "(int n, int m)", "modifiers": "@Override final", "return": "int", "body": "@Override\n    final int nextM(int n, int m) {\n        if (size == 0) return m + 1;\n        // if the query vertex 'n' is in the terminal set (t1) then the\n        // target vertex must be in the terminal set (t2)\n        for (int i = m + 1; i < g2.length; i++)\n            if (m2[i] == UNMAPPED && (t1[n] == 0 || t2[i] > 0)) return i;\n        return mMax();\n    }", "signature": "int nextM(int n, int m)", "full_signature": "@Override final int nextM(int n, int m)", "class_method_signature": "AbstractVFState.nextM(int n, int m)", "testcase": false, "constructor": false, "invocations": ["mMax"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}