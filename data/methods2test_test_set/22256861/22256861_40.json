{"test_class": {"identifier": "SmileCorrectionUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "s3tbx-olci-radiometry/src/test/java/org/esa/s3tbx/olci/radiometry/smilecorr/SmileCorrectionUtilsTest.java"}, "test_case": {"identifier": "testSensorTypeMeris_4th", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testSensorTypeMeris_4th() throws Exception {\n        Product sourceProduct = new Product(\"bla\", \"what\", 300, 300);\n        sourceProduct.addBand(\"M05_radiance\", ProductData.TYPE_UINT8);\n        Sensor sensorType = SmileCorrectionUtils.getSensorType(sourceProduct);\n        assertEquals(Sensor.MERIS_4TH, sensorType);\n    }", "signature": "void testSensorTypeMeris_4th()", "full_signature": "@Test public void testSensorTypeMeris_4th()", "class_method_signature": "SmileCorrectionUtilsTest.testSensorTypeMeris_4th()", "testcase": true, "constructor": false, "invocations": ["addBand", "getSensorType", "assertEquals"]}, "focal_class": {"identifier": "SmileCorrectionUtils", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "multiple2ArrayFloat", "parameters": "(float[] array1, float[] array2)", "modifiers": "public static", "return": "float[]", "signature": "float[] multiple2ArrayFloat(float[] array1, float[] array2)", "full_signature": "public static float[] multiple2ArrayFloat(float[] array1, float[] array2)", "class_method_signature": "SmileCorrectionUtils.multiple2ArrayFloat(float[] array1, float[] array2)", "testcase": false, "constructor": false}, {"identifier": "multiple3ArrayFloat", "parameters": "(float[] array1, float[] array2, float[] array3)", "modifiers": "public static", "return": "float[]", "signature": "float[] multiple3ArrayFloat(float[] array1, float[] array2, float[] array3)", "full_signature": "public static float[] multiple3ArrayFloat(float[] array1, float[] array2, float[] array3)", "class_method_signature": "SmileCorrectionUtils.multiple3ArrayFloat(float[] array1, float[] array2, float[] array3)", "testcase": false, "constructor": false}, {"identifier": "add2ArrayFloat", "parameters": "(float[] array1, float[] array2)", "modifiers": "public static", "return": "float[]", "signature": "float[] add2ArrayFloat(float[] array1, float[] array2)", "full_signature": "public static float[] add2ArrayFloat(float[] array1, float[] array2)", "class_method_signature": "SmileCorrectionUtils.add2ArrayFloat(float[] array1, float[] array2)", "testcase": false, "constructor": false}, {"identifier": "convertDegreesToRadians", "parameters": "(double[] angle)", "modifiers": "public static", "return": "double[]", "signature": "double[] convertDegreesToRadians(double[] angle)", "full_signature": "public static double[] convertDegreesToRadians(double[] angle)", "class_method_signature": "SmileCorrectionUtils.convertDegreesToRadians(double[] angle)", "testcase": false, "constructor": false}, {"identifier": "convertDegreesToRadians", "parameters": "(float[] angle)", "modifiers": "public static", "return": "float[]", "signature": "float[] convertDegreesToRadians(float[] angle)", "full_signature": "public static float[] convertDegreesToRadians(float[] angle)", "class_method_signature": "SmileCorrectionUtils.convertDegreesToRadians(float[] angle)", "testcase": false, "constructor": false}, {"identifier": "getAirMass", "parameters": "(double[] cosOZARads, double[] cosSZARads)", "modifiers": "public static", "return": "double[]", "signature": "double[] getAirMass(double[] cosOZARads, double[] cosSZARads)", "full_signature": "public static double[] getAirMass(double[] cosOZARads, double[] cosSZARads)", "class_method_signature": "SmileCorrectionUtils.getAirMass(double[] cosOZARads, double[] cosSZARads)", "testcase": false, "constructor": false}, {"identifier": "getAziDiff", "parameters": "(double[] saaRads, double[] aooRads)", "modifiers": "public static", "return": "double[]", "signature": "double[] getAziDiff(double[] saaRads, double[] aooRads)", "full_signature": "public static double[] getAziDiff(double[] saaRads, double[] aooRads)", "class_method_signature": "SmileCorrectionUtils.getAziDiff(double[] saaRads, double[] aooRads)", "testcase": false, "constructor": false}, {"identifier": "getSampleDoubles", "parameters": "(Tile sourceTile)", "modifiers": "public static", "return": "double[]", "signature": "double[] getSampleDoubles(Tile sourceTile)", "full_signature": "public static double[] getSampleDoubles(Tile sourceTile)", "class_method_signature": "SmileCorrectionUtils.getSampleDoubles(Tile sourceTile)", "testcase": false, "constructor": false}, {"identifier": "getSampleFloats", "parameters": "(Tile sourceTile)", "modifiers": "public static", "return": "float[]", "signature": "float[] getSampleFloats(Tile sourceTile)", "full_signature": "public static float[] getSampleFloats(Tile sourceTile)", "class_method_signature": "SmileCorrectionUtils.getSampleFloats(Tile sourceTile)", "testcase": false, "constructor": false}, {"identifier": "getSourceBandIndex", "parameters": "(String name)", "modifiers": "public static", "return": "int", "signature": "int getSourceBandIndex(String name)", "full_signature": "public static int getSourceBandIndex(String name)", "class_method_signature": "SmileCorrectionUtils.getSourceBandIndex(String name)", "testcase": false, "constructor": false}, {"identifier": "getSensorType", "parameters": "(Product sourceProduct)", "modifiers": "public static", "return": "Sensor", "signature": "Sensor getSensorType(Product sourceProduct)", "full_signature": "public static Sensor getSensorType(Product sourceProduct)", "class_method_signature": "SmileCorrectionUtils.getSensorType(Product sourceProduct)", "testcase": false, "constructor": false}], "file": "s3tbx-olci-radiometry/src/main/java/org/esa/s3tbx/olci/radiometry/smilecorr/SmileCorrectionUtils.java"}, "focal_method": {"identifier": "getSensorType", "parameters": "(Product sourceProduct)", "modifiers": "public static", "return": "Sensor", "body": "public static Sensor getSensorType(Product sourceProduct) {\n        String[] bandNames = sourceProduct.getBandNames();\n\n        boolean isSensor = Stream.of(bandNames).anyMatch(p -> p.matches(SensorConstants.OLCI_NAME_PATTERN));\n        if (isSensor) {\n            return Sensor.OLCI;\n        }\n\n        isSensor = Stream.of(bandNames).anyMatch(p -> p.matches(SensorConstants.MERIS_NAME_PATTERN));\n        if (isSensor) {\n            return Sensor.MERIS;\n        }\n\n        isSensor = Stream.of(bandNames).anyMatch(p -> p.matches(SensorConstants.MERIS_4TH_NAME_PATTERN));\n        if (isSensor) {\n            return Sensor.MERIS_4TH;\n        }\n\n        isSensor = Stream.of(bandNames).anyMatch(p -> p.matches(SensorConstants.S2_MSI_NAME_PATTERN));\n        if (isSensor) {\n            return Sensor.S2_MSI;\n        }\n\n        throw new OperatorException(\"No supported sensor found for given source product.\\n\" +\n                                            \"Only OLCI and MERIS are supported\");\n    }", "signature": "Sensor getSensorType(Product sourceProduct)", "full_signature": "public static Sensor getSensorType(Product sourceProduct)", "class_method_signature": "SmileCorrectionUtils.getSensorType(Product sourceProduct)", "testcase": false, "constructor": false, "invocations": ["getBandNames", "anyMatch", "of", "matches", "anyMatch", "of", "matches", "anyMatch", "of", "matches", "anyMatch", "of", "matches"]}, "repository": {"repo_id": 22256861, "url": "https://github.com/senbox-org/s3tbx", "stars": 22, "created": "7/25/2014 12:57:22 PM +00:00", "updates": "2020-01-27T10:23:46+00:00", "fork": "False", "license": "licensed"}}