{"test_class": {"identifier": "ByteUtilTest", "superclass": "", "interfaces": "", "fields": [], "file": "nanofix-client/src/test/java/com/lmax/nanofix/byteoperations/ByteUtilTest.java"}, "test_case": {"identifier": "shouldWriteLongAsAscii", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n        public void shouldWriteLongAsAscii()\n        {\n            final byte[] longAsAsciiBytes = new byte[19];\n\n            final int offset = 0;\n            ByteUtil.writeLongAsAscii(longAsAsciiBytes, offset, 0L);\n            assertArrayEquals(\"0000000000000000000\".getBytes(StandardCharsets.US_ASCII), longAsAsciiBytes);\n\n            ByteUtil.writeLongAsAscii(longAsAsciiBytes, offset, 7L);\n            assertArrayEquals(\"0000000000000000007\".getBytes(StandardCharsets.US_ASCII), longAsAsciiBytes);\n\n            ByteUtil.writeLongAsAscii(longAsAsciiBytes, offset, 900000000000000000L);\n            assertArrayEquals(\"0900000000000000000\".getBytes(StandardCharsets.US_ASCII), longAsAsciiBytes);\n\n            ByteUtil.writeLongAsAscii(longAsAsciiBytes, offset, 99999999999999999L);\n            assertArrayEquals(\"0099999999999999999\".getBytes(StandardCharsets.US_ASCII), longAsAsciiBytes);\n\n            ByteUtil.writeLongAsAscii(longAsAsciiBytes, offset, 899999999999999999L);\n            assertArrayEquals(\"0899999999999999999\".getBytes(StandardCharsets.US_ASCII), longAsAsciiBytes);\n        }", "signature": "void shouldWriteLongAsAscii()", "full_signature": "@Test public void shouldWriteLongAsAscii()", "class_method_signature": "ByteUtilTest.shouldWriteLongAsAscii()", "testcase": true, "constructor": false, "invocations": ["writeLongAsAscii", "assertArrayEquals", "getBytes", "writeLongAsAscii", "assertArrayEquals", "getBytes", "writeLongAsAscii", "assertArrayEquals", "getBytes", "writeLongAsAscii", "assertArrayEquals", "getBytes", "writeLongAsAscii", "assertArrayEquals", "getBytes"]}, "focal_class": {"identifier": "ByteUtil", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int MAX_UNSIGNED_SHORT = (1 << 16) - 1;", "modifier": "public static final", "type": "int", "declarator": "MAX_UNSIGNED_SHORT = (1 << 16) - 1", "var_name": "MAX_UNSIGNED_SHORT"}], "methods": [{"identifier": "writeLongAsAscii", "parameters": "(final byte[] outputBuffer, final int offset, final long valueParam)", "modifiers": "public static", "return": "void", "signature": "void writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam)", "full_signature": "public static void writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam)", "class_method_signature": "ByteUtil.writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam)", "testcase": false, "constructor": false}, {"identifier": "isAsciiDigit", "parameters": "(final byte asciiCharacter)", "modifiers": "public static", "return": "boolean", "signature": "boolean isAsciiDigit(final byte asciiCharacter)", "full_signature": "public static boolean isAsciiDigit(final byte asciiCharacter)", "class_method_signature": "ByteUtil.isAsciiDigit(final byte asciiCharacter)", "testcase": false, "constructor": false}, {"identifier": "formatIntAsIpAddress", "parameters": "(final int address)", "modifiers": "public static", "return": "String", "signature": "String formatIntAsIpAddress(final int address)", "full_signature": "public static String formatIntAsIpAddress(final int address)", "class_method_signature": "ByteUtil.formatIntAsIpAddress(final int address)", "testcase": false, "constructor": false}, {"identifier": "formatIntAsIpAddress", "parameters": "(final StringBuilder buffer, final int address)", "modifiers": "public static", "return": "void", "signature": "void formatIntAsIpAddress(final StringBuilder buffer, final int address)", "full_signature": "public static void formatIntAsIpAddress(final StringBuilder buffer, final int address)", "class_method_signature": "ByteUtil.formatIntAsIpAddress(final StringBuilder buffer, final int address)", "testcase": false, "constructor": false}, {"identifier": "packLongWithUnsignedShortInts", "parameters": "(final int int1, final int int2, final int int3, final int int4)", "modifiers": "public static", "return": "long", "signature": "long packLongWithUnsignedShortInts(final int int1, final int int2, final int int3, final int int4)", "full_signature": "public static long packLongWithUnsignedShortInts(final int int1, final int int2, final int int3, final int int4)", "class_method_signature": "ByteUtil.packLongWithUnsignedShortInts(final int int1, final int int2, final int int3, final int int4)", "testcase": false, "constructor": false}, {"identifier": "isEqual", "parameters": "(final byte[] lhs, final int lhsOffset, final byte[] rhs, final int rhsOffset, final int length)", "modifiers": "public static", "return": "boolean", "signature": "boolean isEqual(final byte[] lhs, final int lhsOffset, final byte[] rhs, final int rhsOffset, final int length)", "full_signature": "public static boolean isEqual(final byte[] lhs, final int lhsOffset, final byte[] rhs, final int rhsOffset, final int length)", "class_method_signature": "ByteUtil.isEqual(final byte[] lhs, final int lhsOffset, final byte[] rhs, final int rhsOffset, final int length)", "testcase": false, "constructor": false}, {"identifier": "readIntFromAscii", "parameters": "(final byte[] asciiBuffer, final int offset, final int length)", "modifiers": "public static", "return": "int", "signature": "int readIntFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "full_signature": "public static int readIntFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "class_method_signature": "ByteUtil.readIntFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "testcase": false, "constructor": false}, {"identifier": "readLongFromAscii", "parameters": "(final byte[] asciiBuffer, final int offset, final int length)", "modifiers": "public static", "return": "long", "signature": "long readLongFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "full_signature": "public static long readLongFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "class_method_signature": "ByteUtil.readLongFromAscii(final byte[] asciiBuffer, final int offset, final int length)", "testcase": false, "constructor": false}, {"identifier": "isInteger", "parameters": "(final byte[] asciiBuffer, final int offset, final int length)", "modifiers": "public static", "return": "boolean", "signature": "boolean isInteger(final byte[] asciiBuffer, final int offset, final int length)", "full_signature": "public static boolean isInteger(final byte[] asciiBuffer, final int offset, final int length)", "class_method_signature": "ByteUtil.isInteger(final byte[] asciiBuffer, final int offset, final int length)", "testcase": false, "constructor": false}, {"identifier": "replace", "parameters": "(final byte[] buffer, final int offset, final int length,\n                               final byte target, final byte replacement)", "modifiers": "public static", "return": "void", "signature": "void replace(final byte[] buffer, final int offset, final int length,\n                               final byte target, final byte replacement)", "full_signature": "public static void replace(final byte[] buffer, final int offset, final int length,\n                               final byte target, final byte replacement)", "class_method_signature": "ByteUtil.replace(final byte[] buffer, final int offset, final int length,\n                               final byte target, final byte replacement)", "testcase": false, "constructor": false}, {"identifier": "asciiEncode", "parameters": "(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "modifiers": "public static", "return": "void", "signature": "void asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "full_signature": "public static void asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "class_method_signature": "ByteUtil.asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length)", "testcase": false, "constructor": false}, {"identifier": "checkUnsignedShort", "parameters": "(final int value)", "modifiers": "private static", "return": "void", "signature": "void checkUnsignedShort(final int value)", "full_signature": "private static void checkUnsignedShort(final int value)", "class_method_signature": "ByteUtil.checkUnsignedShort(final int value)", "testcase": false, "constructor": false}], "file": "nanofix-client/src/main/java/com/lmax/nanofix/byteoperations/ByteUtil.java"}, "focal_method": {"identifier": "writeLongAsAscii", "parameters": "(final byte[] outputBuffer, final int offset, final long valueParam)", "modifiers": "public static", "return": "void", "body": "public static void writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam)\n    {\n        long value = valueParam;\n        if (value < 0 || value > 9000000000000000000L)\n        {\n            throw new IllegalArgumentException(\"Value out of range: value=\" + value);\n        }\n\n        int outputBufferIndex = offset + 18;\n\n        long factor = 1;\n        while (value >= factor)\n        {\n            long remainder = value % (factor * 10);\n\n            outputBuffer[outputBufferIndex--] = (byte) ((remainder / factor) + 48);\n\n            value -= remainder;\n            factor *= 10;\n        }\n\n        final byte zero = (byte) 48;\n        while (outputBufferIndex >= offset)\n        {\n            outputBuffer[outputBufferIndex--] = zero;\n        }\n    }", "signature": "void writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam)", "full_signature": "public static void writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam)", "class_method_signature": "ByteUtil.writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam)", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 30593072, "url": "https://github.com/LMAX-Exchange/nanofix", "language": "Java", "is_fork": false, "fork_count": 18, "stargazer_count": 24, "size": 193, "license": "licensed"}}