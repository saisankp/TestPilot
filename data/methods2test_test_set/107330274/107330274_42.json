{"test_class": {"identifier": "RetryHandlerBuilderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final long RETRY_DELAY_SEC = 1;", "modifier": "private static final", "type": "long", "declarator": "RETRY_DELAY_SEC = 1", "var_name": "RETRY_DELAY_SEC"}, {"original_string": "private final TestScheduler testScheduler = Schedulers.test();", "modifier": "private final", "type": "TestScheduler", "declarator": "testScheduler = Schedulers.test()", "var_name": "testScheduler"}, {"original_string": "private final ExtTestSubscriber<String> testSubscriber = new ExtTestSubscriber<>();", "modifier": "private final", "type": "ExtTestSubscriber<String>", "declarator": "testSubscriber = new ExtTestSubscriber<>()", "var_name": "testSubscriber"}, {"original_string": "private final RetryHandlerBuilder builder = retryHandler()\n            .withScheduler(testScheduler)\n            .withTitle(\"testObservable\")\n            .withRetryCount(3)\n            .withRetryDelay(RETRY_DELAY_SEC, TimeUnit.SECONDS);", "modifier": "private final", "type": "RetryHandlerBuilder", "declarator": "builder = retryHandler()\n            .withScheduler(testScheduler)\n            .withTitle(\"testObservable\")\n            .withRetryCount(3)\n            .withRetryDelay(RETRY_DELAY_SEC, TimeUnit.SECONDS)", "var_name": "builder"}], "file": "titus-common/src/test/java/com/netflix/titus/common/util/rx/RetryHandlerBuilderTest.java"}, "test_case": {"identifier": "testRetryOnError", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRetryOnError() throws Exception {\n        Func1<Observable<? extends Throwable>, Observable<?>> retryFun = builder.buildExponentialBackoff();\n\n        observableOf(\"A\", new IOException(\"Error1\"), \"B\", new IOException(\"Error2\"), \"C\")\n                .retryWhen(retryFun, testScheduler)\n                .subscribe(testSubscriber);\n\n        // Expect first item\n        testScheduler.triggerActions();\n        assertThat(testSubscriber.getLatestItem()).isEqualTo(\"A\");\n\n        // Expect second item\n        testScheduler.advanceTimeBy(RETRY_DELAY_SEC, TimeUnit.SECONDS);\n        assertThat(testSubscriber.getLatestItem()).isEqualTo(\"B\");\n\n        // Expect third item\n        testScheduler.advanceTimeBy(2 * RETRY_DELAY_SEC, TimeUnit.SECONDS);\n        assertThat(testSubscriber.getLatestItem()).isEqualTo(\"C\");\n\n        assertThat(testSubscriber.isUnsubscribed());\n    }", "signature": "void testRetryOnError()", "full_signature": "@Test public void testRetryOnError()", "class_method_signature": "RetryHandlerBuilderTest.testRetryOnError()", "testcase": true, "constructor": false, "invocations": ["buildExponentialBackoff", "subscribe", "retryWhen", "observableOf", "triggerActions", "isEqualTo", "assertThat", "getLatestItem", "advanceTimeBy", "isEqualTo", "assertThat", "getLatestItem", "advanceTimeBy", "isEqualTo", "assertThat", "getLatestItem", "assertThat", "isUnsubscribed"]}, "focal_class": {"identifier": "RetryHandlerBuilder", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(RetryHandlerBuilder.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(RetryHandlerBuilder.class)", "var_name": "logger"}, {"original_string": "private Scheduler scheduler = Schedulers.computation();", "modifier": "private", "type": "Scheduler", "declarator": "scheduler = Schedulers.computation()", "var_name": "scheduler"}, {"original_string": "private reactor.core.scheduler.Scheduler reactorScheduler;", "modifier": "private", "type": "reactor.core.scheduler.Scheduler", "declarator": "reactorScheduler", "var_name": "reactorScheduler"}, {"original_string": "private int retryCount = -1;", "modifier": "private", "type": "int", "declarator": "retryCount = -1", "var_name": "retryCount"}, {"original_string": "private long retryDelayMs = -1;", "modifier": "private", "type": "long", "declarator": "retryDelayMs = -1", "var_name": "retryDelayMs"}, {"original_string": "private long maxDelay = Long.MAX_VALUE;", "modifier": "private", "type": "long", "declarator": "maxDelay = Long.MAX_VALUE", "var_name": "maxDelay"}, {"original_string": "private String title = \"observable\";", "modifier": "private", "type": "String", "declarator": "title = \"observable\"", "var_name": "title"}, {"original_string": "private Action1<Throwable> onErrorHook = e -> {\n    };", "modifier": "private", "type": "Action1<Throwable>", "declarator": "onErrorHook = e -> {\n    }", "var_name": "onErrorHook"}, {"original_string": "private Supplier<Boolean> retryWhenCondition;", "modifier": "private", "type": "Supplier<Boolean>", "declarator": "retryWhenCondition", "var_name": "retryWhenCondition"}, {"original_string": "private Predicate<Throwable> retryOnThrowableCondition;", "modifier": "private", "type": "Predicate<Throwable>", "declarator": "retryOnThrowableCondition", "var_name": "retryOnThrowableCondition"}], "methods": [{"identifier": "RetryHandlerBuilder", "parameters": "()", "modifiers": "private", "return": "", "signature": " RetryHandlerBuilder()", "full_signature": "private  RetryHandlerBuilder()", "class_method_signature": "RetryHandlerBuilder.RetryHandlerBuilder()", "testcase": false, "constructor": true}, {"identifier": "withScheduler", "parameters": "(Scheduler scheduler)", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder withScheduler(Scheduler scheduler)", "full_signature": "public RetryHandlerBuilder withScheduler(Scheduler scheduler)", "class_method_signature": "RetryHandlerBuilder.withScheduler(Scheduler scheduler)", "testcase": false, "constructor": false}, {"identifier": "withReactorScheduler", "parameters": "(reactor.core.scheduler.Scheduler scheduler)", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder withReactorScheduler(reactor.core.scheduler.Scheduler scheduler)", "full_signature": "public RetryHandlerBuilder withReactorScheduler(reactor.core.scheduler.Scheduler scheduler)", "class_method_signature": "RetryHandlerBuilder.withReactorScheduler(reactor.core.scheduler.Scheduler scheduler)", "testcase": false, "constructor": false}, {"identifier": "withRetryCount", "parameters": "(int retryCount)", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder withRetryCount(int retryCount)", "full_signature": "public RetryHandlerBuilder withRetryCount(int retryCount)", "class_method_signature": "RetryHandlerBuilder.withRetryCount(int retryCount)", "testcase": false, "constructor": false}, {"identifier": "withUnlimitedRetries", "parameters": "()", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder withUnlimitedRetries()", "full_signature": "public RetryHandlerBuilder withUnlimitedRetries()", "class_method_signature": "RetryHandlerBuilder.withUnlimitedRetries()", "testcase": false, "constructor": false}, {"identifier": "withRetryDelay", "parameters": "(long retryDelay, TimeUnit timeUnit)", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder withRetryDelay(long retryDelay, TimeUnit timeUnit)", "full_signature": "public RetryHandlerBuilder withRetryDelay(long retryDelay, TimeUnit timeUnit)", "class_method_signature": "RetryHandlerBuilder.withRetryDelay(long retryDelay, TimeUnit timeUnit)", "testcase": false, "constructor": false}, {"identifier": "withMaxDelay", "parameters": "(long maxDelay, TimeUnit timeUnit)", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder withMaxDelay(long maxDelay, TimeUnit timeUnit)", "full_signature": "public RetryHandlerBuilder withMaxDelay(long maxDelay, TimeUnit timeUnit)", "class_method_signature": "RetryHandlerBuilder.withMaxDelay(long maxDelay, TimeUnit timeUnit)", "testcase": false, "constructor": false}, {"identifier": "withDelay", "parameters": "(long initial, long max, TimeUnit timeUnit)", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder withDelay(long initial, long max, TimeUnit timeUnit)", "full_signature": "public RetryHandlerBuilder withDelay(long initial, long max, TimeUnit timeUnit)", "class_method_signature": "RetryHandlerBuilder.withDelay(long initial, long max, TimeUnit timeUnit)", "testcase": false, "constructor": false}, {"identifier": "withTitle", "parameters": "(String title)", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder withTitle(String title)", "full_signature": "public RetryHandlerBuilder withTitle(String title)", "class_method_signature": "RetryHandlerBuilder.withTitle(String title)", "testcase": false, "constructor": false}, {"identifier": "withOnErrorHook", "parameters": "(Consumer<Throwable> hook)", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder withOnErrorHook(Consumer<Throwable> hook)", "full_signature": "public RetryHandlerBuilder withOnErrorHook(Consumer<Throwable> hook)", "class_method_signature": "RetryHandlerBuilder.withOnErrorHook(Consumer<Throwable> hook)", "testcase": false, "constructor": false}, {"identifier": "withRetryWhen", "parameters": "(Supplier<Boolean> retryWhenCondition)", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder withRetryWhen(Supplier<Boolean> retryWhenCondition)", "full_signature": "public RetryHandlerBuilder withRetryWhen(Supplier<Boolean> retryWhenCondition)", "class_method_signature": "RetryHandlerBuilder.withRetryWhen(Supplier<Boolean> retryWhenCondition)", "testcase": false, "constructor": false}, {"identifier": "withRetryOnThrowable", "parameters": "(Predicate<Throwable> retryOnThrowable)", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder withRetryOnThrowable(Predicate<Throwable> retryOnThrowable)", "full_signature": "public RetryHandlerBuilder withRetryOnThrowable(Predicate<Throwable> retryOnThrowable)", "class_method_signature": "RetryHandlerBuilder.withRetryOnThrowable(Predicate<Throwable> retryOnThrowable)", "testcase": false, "constructor": false}, {"identifier": "but", "parameters": "()", "modifiers": "public", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder but()", "full_signature": "public RetryHandlerBuilder but()", "class_method_signature": "RetryHandlerBuilder.but()", "testcase": false, "constructor": false}, {"identifier": "buildExponentialBackoff", "parameters": "()", "modifiers": "public", "return": "Func1<Observable<? extends Throwable>, Observable<?>>", "signature": "Func1<Observable<? extends Throwable>, Observable<?>> buildExponentialBackoff()", "full_signature": "public Func1<Observable<? extends Throwable>, Observable<?>> buildExponentialBackoff()", "class_method_signature": "RetryHandlerBuilder.buildExponentialBackoff()", "testcase": false, "constructor": false}, {"identifier": "buildReactorExponentialBackoff", "parameters": "()", "modifiers": "public", "return": "Function<Flux<Throwable>, Publisher<?>>", "signature": "Function<Flux<Throwable>, Publisher<?>> buildReactorExponentialBackoff()", "full_signature": "public Function<Flux<Throwable>, Publisher<?>> buildReactorExponentialBackoff()", "class_method_signature": "RetryHandlerBuilder.buildReactorExponentialBackoff()", "testcase": false, "constructor": false}, {"identifier": "buildDelay", "parameters": "(int retry)", "modifiers": "private", "return": "long", "signature": "long buildDelay(int retry)", "full_signature": "private long buildDelay(int retry)", "class_method_signature": "RetryHandlerBuilder.buildDelay(int retry)", "testcase": false, "constructor": false}, {"identifier": "retryHandler", "parameters": "()", "modifiers": "public static", "return": "RetryHandlerBuilder", "signature": "RetryHandlerBuilder retryHandler()", "full_signature": "public static RetryHandlerBuilder retryHandler()", "class_method_signature": "RetryHandlerBuilder.retryHandler()", "testcase": false, "constructor": false}], "file": "titus-common/src/main/java/com/netflix/titus/common/util/rx/RetryHandlerBuilder.java"}, "focal_method": {"identifier": "buildExponentialBackoff", "parameters": "()", "modifiers": "public", "return": "Func1<Observable<? extends Throwable>, Observable<?>>", "body": "public Func1<Observable<? extends Throwable>, Observable<?>> buildExponentialBackoff() {\n        Preconditions.checkState(retryCount > 0, \"Retry count not defined\");\n        Preconditions.checkState(retryDelayMs > 0, \"Retry delay not defined\");\n\n        return failedAttempts -> failedAttempts\n                .doOnNext(error -> onErrorHook.call(error))\n                .zipWith(Observable.range(0, retryCount + 1), RetryItem::new)\n                .flatMap(retryItem -> {\n                    if (retryWhenCondition != null && !retryWhenCondition.get()) {\n                        String errorMessage = String.format(\n                                \"Retry condition not met for %s. Last error: %s. Returning an error to the caller\",\n                                title, retryItem.cause.getMessage()\n                        );\n                        return Observable.error(new IOException(errorMessage, retryItem.cause));\n                    }\n\n                    if (retryOnThrowableCondition != null && !retryOnThrowableCondition.test(retryItem.cause)) {\n                        String errorMessage = String.format(\n                                \"Retry condition for the last error not met for %s. Last error: %s. Returning an error to the caller\",\n                                title, retryItem.cause.getMessage()\n                        );\n                        return Observable.error(new IOException(errorMessage, retryItem.cause));\n                    }\n\n                    if (retryItem.retry == retryCount) {\n                        String errorMessage = String.format(\n                                \"Retry limit reached for %s. Last error: %s. Returning an error to the caller\",\n                                title, retryItem.cause.getMessage()\n                        );\n                        return Observable.error(new IOException(errorMessage, retryItem.cause));\n                    }\n                    long expDelay = buildDelay(retryItem.retry);\n                    if (retryItem.cause instanceof TimeoutException) {\n                        logger.info(\"Delaying timed-out {} retry by {}[ms]\", title, expDelay);\n                    } else {\n                        logger.info(\"Delaying failed {} retry by {}[ms]: {}\", title, expDelay, ExceptionExt.toMessageChain(retryItem.cause));\n                        logger.debug(\"Exception\", retryItem.cause);\n                    }\n                    return Observable.timer(expDelay, TimeUnit.MILLISECONDS, scheduler);\n                });\n    }", "signature": "Func1<Observable<? extends Throwable>, Observable<?>> buildExponentialBackoff()", "full_signature": "public Func1<Observable<? extends Throwable>, Observable<?>> buildExponentialBackoff()", "class_method_signature": "RetryHandlerBuilder.buildExponentialBackoff()", "testcase": false, "constructor": false, "invocations": ["checkState", "checkState", "flatMap", "zipWith", "doOnNext", "call", "range", "get", "format", "getMessage", "error", "test", "format", "getMessage", "error", "format", "getMessage", "error", "buildDelay", "info", "info", "toMessageChain", "debug", "timer"]}, "repository": {"repo_id": 107330274, "url": "https://github.com/Netflix/titus-control-plane", "stars": 241, "created": "10/17/2017 10:20:55 PM +00:00", "updates": "2020-01-25T13:01:05+00:00", "fork": "False", "license": "licensed"}}