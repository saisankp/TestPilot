{"test_class": {"identifier": "WalletProtobufSerializerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final NetworkParameters params = UnitTestParams.get();", "modifier": "static final", "type": "NetworkParameters", "declarator": "params = UnitTestParams.get()", "var_name": "params"}, {"original_string": "private ECKey myKey;", "modifier": "private", "type": "ECKey", "declarator": "myKey", "var_name": "myKey"}, {"original_string": "private ECKey myWatchedKey;", "modifier": "private", "type": "ECKey", "declarator": "myWatchedKey", "var_name": "myWatchedKey"}, {"original_string": "private Address myAddress;", "modifier": "private", "type": "Address", "declarator": "myAddress", "var_name": "myAddress"}, {"original_string": "private Wallet myWallet;", "modifier": "private", "type": "Wallet", "declarator": "myWallet", "var_name": "myWallet"}, {"original_string": "public static String WALLET_DESCRIPTION  = \"The quick brown fox lives in \\u4f26\\u6566\";", "modifier": "public static", "type": "String", "declarator": "WALLET_DESCRIPTION  = \"The quick brown fox lives in \\u4f26\\u6566\"", "var_name": "WALLET_DESCRIPTION"}, {"original_string": "private long mScriptCreationTime;", "modifier": "private", "type": "long", "declarator": "mScriptCreationTime", "var_name": "mScriptCreationTime"}], "file": "core/src/test/java/com/google/bitcoin/store/WalletProtobufSerializerTest.java"}, "test_case": {"identifier": "testLastBlockSeenHash", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testLastBlockSeenHash() throws Exception {\n        // Test the lastBlockSeenHash field works.\n\n        // LastBlockSeenHash should be empty if never set.\n        Wallet wallet = new Wallet(params);\n        Protos.Wallet walletProto = new WalletProtobufSerializer().walletToProto(wallet);\n        ByteString lastSeenBlockHash = walletProto.getLastSeenBlockHash();\n        assertTrue(lastSeenBlockHash.isEmpty());\n\n        // Create a block.\n        Block block = new Block(params, BlockTest.blockBytes);\n        Sha256Hash blockHash = block.getHash();\n        wallet.setLastBlockSeenHash(blockHash);\n        wallet.setLastBlockSeenHeight(1);\n\n        // Roundtrip the wallet and check it has stored the blockHash.\n        Wallet wallet1 = roundTrip(wallet);\n        assertEquals(blockHash, wallet1.getLastBlockSeenHash());\n        assertEquals(1, wallet1.getLastBlockSeenHeight());\n\n        // Test the Satoshi genesis block (hash of all zeroes) is roundtripped ok.\n        Block genesisBlock = MainNetParams.get().getGenesisBlock();\n        wallet.setLastBlockSeenHash(genesisBlock.getHash());\n        Wallet wallet2 = roundTrip(wallet);\n        assertEquals(genesisBlock.getHash(), wallet2.getLastBlockSeenHash());\n    }", "signature": "void testLastBlockSeenHash()", "full_signature": "@Test public void testLastBlockSeenHash()", "class_method_signature": "WalletProtobufSerializerTest.testLastBlockSeenHash()", "testcase": true, "constructor": false, "invocations": ["walletToProto", "getLastSeenBlockHash", "assertTrue", "isEmpty", "getHash", "setLastBlockSeenHash", "setLastBlockSeenHeight", "roundTrip", "assertEquals", "getLastBlockSeenHash", "assertEquals", "getLastBlockSeenHeight", "getGenesisBlock", "get", "setLastBlockSeenHash", "getHash", "roundTrip", "assertEquals", "getHash", "getLastBlockSeenHash"]}, "focal_class": {"identifier": "WalletProtobufSerializer", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(WalletProtobufSerializer.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(WalletProtobufSerializer.class)", "var_name": "log"}, {"original_string": "protected Map<ByteString, Transaction> txMap;", "modifier": "protected", "type": "Map<ByteString, Transaction>", "declarator": "txMap", "var_name": "txMap"}, {"original_string": "private boolean requireMandatoryExtensions = true;", "modifier": "private", "type": "boolean", "declarator": "requireMandatoryExtensions = true", "var_name": "requireMandatoryExtensions"}], "methods": [{"identifier": "WalletProtobufSerializer", "parameters": "()", "modifiers": "public", "return": "", "signature": " WalletProtobufSerializer()", "full_signature": "public  WalletProtobufSerializer()", "class_method_signature": "WalletProtobufSerializer.WalletProtobufSerializer()", "testcase": false, "constructor": true}, {"identifier": "setRequireMandatoryExtensions", "parameters": "(boolean value)", "modifiers": "public", "return": "void", "signature": "void setRequireMandatoryExtensions(boolean value)", "full_signature": "public void setRequireMandatoryExtensions(boolean value)", "class_method_signature": "WalletProtobufSerializer.setRequireMandatoryExtensions(boolean value)", "testcase": false, "constructor": false}, {"identifier": "writeWallet", "parameters": "(Wallet wallet, OutputStream output)", "modifiers": "public", "return": "void", "signature": "void writeWallet(Wallet wallet, OutputStream output)", "full_signature": "public void writeWallet(Wallet wallet, OutputStream output)", "class_method_signature": "WalletProtobufSerializer.writeWallet(Wallet wallet, OutputStream output)", "testcase": false, "constructor": false}, {"identifier": "walletToText", "parameters": "(Wallet wallet)", "modifiers": "public", "return": "String", "signature": "String walletToText(Wallet wallet)", "full_signature": "public String walletToText(Wallet wallet)", "class_method_signature": "WalletProtobufSerializer.walletToText(Wallet wallet)", "testcase": false, "constructor": false}, {"identifier": "walletToProto", "parameters": "(Wallet wallet)", "modifiers": "public", "return": "Protos.Wallet", "signature": "Protos.Wallet walletToProto(Wallet wallet)", "full_signature": "public Protos.Wallet walletToProto(Wallet wallet)", "class_method_signature": "WalletProtobufSerializer.walletToProto(Wallet wallet)", "testcase": false, "constructor": false}, {"identifier": "populateExtensions", "parameters": "(Wallet wallet, Protos.Wallet.Builder walletBuilder)", "modifiers": "private static", "return": "void", "signature": "void populateExtensions(Wallet wallet, Protos.Wallet.Builder walletBuilder)", "full_signature": "private static void populateExtensions(Wallet wallet, Protos.Wallet.Builder walletBuilder)", "class_method_signature": "WalletProtobufSerializer.populateExtensions(Wallet wallet, Protos.Wallet.Builder walletBuilder)", "testcase": false, "constructor": false}, {"identifier": "makeTxProto", "parameters": "(WalletTransaction wtx)", "modifiers": "private static", "return": "Protos.Transaction", "signature": "Protos.Transaction makeTxProto(WalletTransaction wtx)", "full_signature": "private static Protos.Transaction makeTxProto(WalletTransaction wtx)", "class_method_signature": "WalletProtobufSerializer.makeTxProto(WalletTransaction wtx)", "testcase": false, "constructor": false}, {"identifier": "getProtoPool", "parameters": "(WalletTransaction wtx)", "modifiers": "private static", "return": "Protos.Transaction.Pool", "signature": "Protos.Transaction.Pool getProtoPool(WalletTransaction wtx)", "full_signature": "private static Protos.Transaction.Pool getProtoPool(WalletTransaction wtx)", "class_method_signature": "WalletProtobufSerializer.getProtoPool(WalletTransaction wtx)", "testcase": false, "constructor": false}, {"identifier": "writeConfidence", "parameters": "(Protos.Transaction.Builder txBuilder,\n                                        TransactionConfidence confidence,\n                                        Protos.TransactionConfidence.Builder confidenceBuilder)", "modifiers": "private static", "return": "void", "signature": "void writeConfidence(Protos.Transaction.Builder txBuilder,\n                                        TransactionConfidence confidence,\n                                        Protos.TransactionConfidence.Builder confidenceBuilder)", "full_signature": "private static void writeConfidence(Protos.Transaction.Builder txBuilder,\n                                        TransactionConfidence confidence,\n                                        Protos.TransactionConfidence.Builder confidenceBuilder)", "class_method_signature": "WalletProtobufSerializer.writeConfidence(Protos.Transaction.Builder txBuilder,\n                                        TransactionConfidence confidence,\n                                        Protos.TransactionConfidence.Builder confidenceBuilder)", "testcase": false, "constructor": false}, {"identifier": "hashToByteString", "parameters": "(Sha256Hash hash)", "modifiers": "public static", "return": "ByteString", "signature": "ByteString hashToByteString(Sha256Hash hash)", "full_signature": "public static ByteString hashToByteString(Sha256Hash hash)", "class_method_signature": "WalletProtobufSerializer.hashToByteString(Sha256Hash hash)", "testcase": false, "constructor": false}, {"identifier": "byteStringToHash", "parameters": "(ByteString bs)", "modifiers": "public static", "return": "Sha256Hash", "signature": "Sha256Hash byteStringToHash(ByteString bs)", "full_signature": "public static Sha256Hash byteStringToHash(ByteString bs)", "class_method_signature": "WalletProtobufSerializer.byteStringToHash(ByteString bs)", "testcase": false, "constructor": false}, {"identifier": "readWallet", "parameters": "(InputStream input)", "modifiers": "public", "return": "Wallet", "signature": "Wallet readWallet(InputStream input)", "full_signature": "public Wallet readWallet(InputStream input)", "class_method_signature": "WalletProtobufSerializer.readWallet(InputStream input)", "testcase": false, "constructor": false}, {"identifier": "readWallet", "parameters": "(Protos.Wallet walletProto, Wallet wallet)", "modifiers": "public", "return": "void", "signature": "void readWallet(Protos.Wallet walletProto, Wallet wallet)", "full_signature": "public void readWallet(Protos.Wallet walletProto, Wallet wallet)", "class_method_signature": "WalletProtobufSerializer.readWallet(Protos.Wallet walletProto, Wallet wallet)", "testcase": false, "constructor": false}, {"identifier": "loadExtensions", "parameters": "(Wallet wallet, Protos.Wallet walletProto)", "modifiers": "private", "return": "void", "signature": "void loadExtensions(Wallet wallet, Protos.Wallet walletProto)", "full_signature": "private void loadExtensions(Wallet wallet, Protos.Wallet walletProto)", "class_method_signature": "WalletProtobufSerializer.loadExtensions(Wallet wallet, Protos.Wallet walletProto)", "testcase": false, "constructor": false}, {"identifier": "parseToProto", "parameters": "(InputStream input)", "modifiers": "public static", "return": "Protos.Wallet", "signature": "Protos.Wallet parseToProto(InputStream input)", "full_signature": "public static Protos.Wallet parseToProto(InputStream input)", "class_method_signature": "WalletProtobufSerializer.parseToProto(InputStream input)", "testcase": false, "constructor": false}, {"identifier": "readTransaction", "parameters": "(Protos.Transaction txProto, NetworkParameters params)", "modifiers": "private", "return": "void", "signature": "void readTransaction(Protos.Transaction txProto, NetworkParameters params)", "full_signature": "private void readTransaction(Protos.Transaction txProto, NetworkParameters params)", "class_method_signature": "WalletProtobufSerializer.readTransaction(Protos.Transaction txProto, NetworkParameters params)", "testcase": false, "constructor": false}, {"identifier": "connectTransactionOutputs", "parameters": "(org.bitcoinj.wallet.Protos.Transaction txProto)", "modifiers": "private", "return": "WalletTransaction", "signature": "WalletTransaction connectTransactionOutputs(org.bitcoinj.wallet.Protos.Transaction txProto)", "full_signature": "private WalletTransaction connectTransactionOutputs(org.bitcoinj.wallet.Protos.Transaction txProto)", "class_method_signature": "WalletProtobufSerializer.connectTransactionOutputs(org.bitcoinj.wallet.Protos.Transaction txProto)", "testcase": false, "constructor": false}, {"identifier": "readConfidence", "parameters": "(Transaction tx, Protos.TransactionConfidence confidenceProto,\n                                TransactionConfidence confidence)", "modifiers": "private", "return": "void", "signature": "void readConfidence(Transaction tx, Protos.TransactionConfidence confidenceProto,\n                                TransactionConfidence confidence)", "full_signature": "private void readConfidence(Transaction tx, Protos.TransactionConfidence confidenceProto,\n                                TransactionConfidence confidence)", "class_method_signature": "WalletProtobufSerializer.readConfidence(Transaction tx, Protos.TransactionConfidence confidenceProto,\n                                TransactionConfidence confidence)", "testcase": false, "constructor": false}], "file": "core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java"}, "focal_method": {"identifier": "walletToProto", "parameters": "(Wallet wallet)", "modifiers": "public", "return": "Protos.Wallet", "body": "public Protos.Wallet walletToProto(Wallet wallet) {\n        Protos.Wallet.Builder walletBuilder = Protos.Wallet.newBuilder();\n        walletBuilder.setNetworkIdentifier(wallet.getNetworkParameters().getId());\n        if (wallet.getDescription() != null) {\n            walletBuilder.setDescription(wallet.getDescription());\n        }\n\n        for (WalletTransaction wtx : wallet.getWalletTransactions()) {\n            Protos.Transaction txProto = makeTxProto(wtx);\n            walletBuilder.addTransaction(txProto);\n        }\n\n        for (ECKey key : wallet.getKeys()) {\n            Protos.Key.Builder keyBuilder = Protos.Key.newBuilder().setCreationTimestamp(key.getCreationTimeSeconds() * 1000)\n                                                         // .setLabel() TODO\n                                                            .setType(Protos.Key.Type.ORIGINAL);\n            if (key.getPrivKeyBytes() != null)\n                keyBuilder.setPrivateKey(ByteString.copyFrom(key.getPrivKeyBytes()));\n\n            EncryptedPrivateKey encryptedPrivateKey = key.getEncryptedPrivateKey();\n            if (encryptedPrivateKey != null) {\n                // Key is encrypted.\n                Protos.EncryptedPrivateKey.Builder encryptedKeyBuilder = Protos.EncryptedPrivateKey.newBuilder()\n                    .setEncryptedPrivateKey(ByteString.copyFrom(encryptedPrivateKey.getEncryptedBytes()))\n                    .setInitialisationVector(ByteString.copyFrom(encryptedPrivateKey.getInitialisationVector()));\n\n                if (key.getKeyCrypter() == null) {\n                    throw new IllegalStateException(\"The encrypted key \" + key.toString() + \" has no KeyCrypter.\");\n                } else {\n                    // If it is a Scrypt + AES encrypted key, set the persisted key type.\n                    if (key.getKeyCrypter().getUnderstoodEncryptionType() == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES) {\n                        keyBuilder.setType(Protos.Key.Type.ENCRYPTED_SCRYPT_AES);\n                    } else {\n                        throw new IllegalArgumentException(\"The key \" + key.toString() + \" is encrypted with a KeyCrypter of type \" + key.getKeyCrypter().getUnderstoodEncryptionType() +\n                                \". This WalletProtobufSerialiser does not understand that type of encryption.\");\n                    }\n                }\n                keyBuilder.setEncryptedPrivateKey(encryptedKeyBuilder);\n            }\n\n            // We serialize the public key even if the private key is present for speed reasons: we don't want to do\n            // lots of slow EC math to load the wallet, we prefer to store the redundant data instead. It matters more\n            // on mobile platforms.\n            keyBuilder.setPublicKey(ByteString.copyFrom(key.getPubKey()));\n            walletBuilder.addKey(keyBuilder);\n        }\n\n        for (Script script : wallet.getWatchedScripts()) {\n            Protos.Script protoScript =\n                    Protos.Script.newBuilder()\n                            .setProgram(ByteString.copyFrom(script.getProgram()))\n                            .setCreationTimestamp(script.getCreationTimeSeconds() * 1000)\n                            .build();\n\n            walletBuilder.addWatchedScript(protoScript);\n        }\n\n        // Populate the lastSeenBlockHash field.\n        Sha256Hash lastSeenBlockHash = wallet.getLastBlockSeenHash();\n        if (lastSeenBlockHash != null) {\n            walletBuilder.setLastSeenBlockHash(hashToByteString(lastSeenBlockHash));\n            walletBuilder.setLastSeenBlockHeight(wallet.getLastBlockSeenHeight());\n        }\n        if (wallet.getLastBlockSeenTimeSecs() > 0)\n            walletBuilder.setLastSeenBlockTimeSecs(wallet.getLastBlockSeenTimeSecs());\n\n        // Populate the scrypt parameters.\n        KeyCrypter keyCrypter = wallet.getKeyCrypter();\n        if (keyCrypter == null) {\n            // The wallet is unencrypted.\n            walletBuilder.setEncryptionType(EncryptionType.UNENCRYPTED);\n        } else {\n            // The wallet is encrypted.\n            walletBuilder.setEncryptionType(keyCrypter.getUnderstoodEncryptionType());\n            if (keyCrypter instanceof KeyCrypterScrypt) {\n                KeyCrypterScrypt keyCrypterScrypt = (KeyCrypterScrypt) keyCrypter;\n                walletBuilder.setEncryptionParameters(keyCrypterScrypt.getScryptParameters());\n            } else {\n                // Some other form of encryption has been specified that we do not know how to persist.\n                throw new RuntimeException(\"The wallet has encryption of type '\" + keyCrypter.getUnderstoodEncryptionType() + \"' but this WalletProtobufSerializer does not know how to persist this.\");\n            }\n        }\n\n        if (wallet.getKeyRotationTime() != null) {\n            long timeSecs = wallet.getKeyRotationTime().getTime() / 1000;\n            walletBuilder.setKeyRotationTime(timeSecs);\n        }\n\n        populateExtensions(wallet, walletBuilder);\n\n        // Populate the wallet version.\n        walletBuilder.setVersion(wallet.getVersion());\n\n        return walletBuilder.build();\n    }", "signature": "Protos.Wallet walletToProto(Wallet wallet)", "full_signature": "public Protos.Wallet walletToProto(Wallet wallet)", "class_method_signature": "WalletProtobufSerializer.walletToProto(Wallet wallet)", "testcase": false, "constructor": false, "invocations": ["newBuilder", "setNetworkIdentifier", "getId", "getNetworkParameters", "getDescription", "setDescription", "getDescription", "getWalletTransactions", "makeTxProto", "addTransaction", "getKeys", "setType", "setCreationTimestamp", "newBuilder", "getCreationTimeSeconds", "getPrivKeyBytes", "setPrivateKey", "copyFrom", "getPrivKeyBytes", "getEncryptedPrivateKey", "setInitialisationVector", "setEncryptedPrivateKey", "newBuilder", "copyFrom", "getEncryptedBytes", "copyFrom", "getInitialisationVector", "getKeyCrypter", "toString", "getUnderstoodEncryptionType", "getKeyCrypter", "setType", "toString", "getUnderstoodEncryptionType", "getKeyCrypter", "setEncryptedPrivateKey", "setPublicKey", "copyFrom", "getPubKey", "addKey", "getWatchedScripts", "build", "setCreationTimestamp", "setProgram", "newBuilder", "copyFrom", "getProgram", "getCreationTimeSeconds", "addWatchedScript", "getLastBlockSeenHash", "setLastSeenBlockHash", "hashToByteString", "setLastSeenBlockHeight", "getLastBlockSeenHeight", "getLastBlockSeenTimeSecs", "setLastSeenBlockTimeSecs", "getLastBlockSeenTimeSecs", "getKeyCrypter", "setEncryptionType", "setEncryptionType", "getUnderstoodEncryptionType", "setEncryptionParameters", "getScryptParameters", "getUnderstoodEncryptionType", "getKeyRotationTime", "getTime", "getKeyRotationTime", "setKeyRotationTime", "populateExtensions", "setVersion", "getVersion", "build"]}, "repository": {"repo_id": 24363680, "url": "https://github.com/cannabiscoindev/cannabiscoinj", "language": "Java", "is_fork": false, "fork_count": 9, "stargazer_count": 5, "size": 10126, "license": "licensed"}}