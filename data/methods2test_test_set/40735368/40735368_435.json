{"test_class": {"identifier": "PolygonExtractionProcessTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double TOL = 1.0e-6;", "modifier": "private static final", "type": "double", "declarator": "TOL = 1.0e-6", "var_name": "TOL"}, {"original_string": "private static final GridCoverageFactory covFactory = CoverageFactoryFinder.getGridCoverageFactory(null);", "modifier": "private static final", "type": "GridCoverageFactory", "declarator": "covFactory = CoverageFactoryFinder.getGridCoverageFactory(null)", "var_name": "covFactory"}, {"original_string": "private PolygonExtractionProcess process;", "modifier": "private", "type": "PolygonExtractionProcess", "declarator": "process", "var_name": "process"}], "file": "modules/unsupported/process-raster/src/test/java/org/geotools/process/raster/PolygonExtractionProcessTest.java"}, "test_case": {"identifier": "treatZeroAsDataValue", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void treatZeroAsDataValue() throws Exception {\n        final float[][] DATA = {\n            {1, 1, 1, 1, 0, 1, 1, 1, 1},\n            {1, 0, 0, 1, 0, 1, 0, 0, 1},\n            {1, 0, 0, 1, 0, 1, 0, 0, 1},\n            {1, 1, 1, 1, 0, 1, 1, 1, 1}\n        };\n\n        final int NUM_POLYS = 5;\n\n        GridCoverage2D cov = covFactory.create(\n                \"coverage\",\n                DATA,\n                new ReferencedEnvelope(0, DATA[0].length, 0, DATA.length, null));\n\n        Number[] noDataValues = { -1 };\n        SimpleFeatureCollection fc = process.execute(cov, 0, Boolean.TRUE, null, Arrays.asList(noDataValues), null, null);\n        assertEquals(NUM_POLYS, fc.size());\n    }", "signature": "void treatZeroAsDataValue()", "full_signature": "@Test public void treatZeroAsDataValue()", "class_method_signature": "PolygonExtractionProcessTest.treatZeroAsDataValue()", "testcase": true, "constructor": false, "invocations": ["create", "execute", "asList", "assertEquals", "size"]}, "focal_class": {"identifier": "PolygonExtractionProcess", "superclass": "", "interfaces": "implements RasterProcess", "fields": [], "methods": [{"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "modifiers": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public", "return": "SimpleFeatureCollection", "signature": "SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "full_signature": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "class_method_signature": "PolygonExtractionProcess.execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-raster/src/main/java/org/geotools/process/raster/PolygonExtractionProcess.java"}, "focal_method": {"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "modifiers": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public", "return": "SimpleFeatureCollection", "body": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\")\n    public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)\n            throws ProcessException {\n\n\n        //\n        // initial checks\n        //\n        if (coverage == null) {\n            throw new ProcessException(\"Invalid input, source grid coverage should be not null\");\n        }\n\n        if (band == null) {\n            band = 0;\n        } else if (band < 0 || band >= coverage.getNumSampleDimensions()) {\n            throw new ProcessException(\"Invalid input, invalid band number:\" + band);\n        }\n\n        // do we have classification ranges?\n        boolean hasClassificationRanges = classificationRanges != null && classificationRanges.size() > 0;\n\n        // apply the classification by setting 0 as the default value and using 1, ..., numClasses for the other classes.\n        // we use 0 also as the noData for the resulting coverage.\n        if (hasClassificationRanges) {\n\n            final RangeLookupProcess lookup = new RangeLookupProcess();\n            coverage = lookup.execute(\n                    coverage,\n                    band,\n                    classificationRanges,\n                    progressListener);\n        }\n\n        // Use noDataValues to set the \"outsideValues\" parameter of the Vectorize\n        // operation unless classificationRanges are in use, in which case the\n        // noDataValues arg is ignored.\n        List<Number> outsideValues = new ArrayList<Number>();\n        if (noDataValues != null && !hasClassificationRanges) {\n            outsideValues.addAll(noDataValues);\n        } else {\n            outsideValues.add(0);\n        }\n        \n        //\n        // GRID TO WORLD preparation\n        //\n        final AffineTransform mt2D = (AffineTransform) coverage.getGridGeometry().getGridToCRS2D(PixelOrientation.UPPER_LEFT);\n\n        // get the rendered image\n        final RenderedImage raster = coverage.getRenderedImage();\n\n        // perform jai operation\n        ParameterBlockJAI pb = new ParameterBlockJAI(\"Vectorize\");\n        pb.setSource(\"source0\", raster);\n\n        if (roi != null) {\n            pb.setParameter(\"roi\", CoverageUtilities.prepareROI(roi, mt2D));\n        }\n        pb.setParameter(\"band\", band);\n        pb.setParameter(\"outsideValues\", outsideValues);\n        if (insideEdges != null) {\n            pb.setParameter(\"insideEdges\", insideEdges);\n        }\n        // pb.setParameter(\"removeCollinear\", false);  \n\n        final RenderedOp dest = JAI.create(\"Vectorize\", pb);\n        @SuppressWarnings(\"unchecked\")\n        final Collection<Polygon> prop = (Collection<Polygon>) dest.getProperty(VectorizeDescriptor.VECTOR_PROPERTY_NAME);\n\n        // wrap as a feature collection and return\n        final SimpleFeatureType featureType = CoverageUtilities.createFeatureType(coverage, Polygon.class);\n        final SimpleFeatureBuilder builder = new SimpleFeatureBuilder(featureType);\n        int i = 0;\n        final ListFeatureCollection featureCollection = new ListFeatureCollection(featureType);\n        final AffineTransformation jtsTransformation = new AffineTransformation(\n                mt2D.getScaleX(),\n                mt2D.getShearX(),\n                mt2D.getTranslateX(),\n                mt2D.getShearY(),\n                mt2D.getScaleY(),\n                mt2D.getTranslateY());\n        for (Polygon polygon : prop) {\n            // get value\n            Double value = (Double) polygon.getUserData();\n            polygon.setUserData(null);\n            // filter coordinates in place\n            polygon.apply(jtsTransformation);\n\n            // create feature and add to list\n            builder.set(\"the_geom\", polygon);\n            builder.set(\"value\", value);\n\n            featureCollection.add(builder.buildFeature(String.valueOf(i++)));\n\n        }\n\n        //return value\n        return featureCollection;\n    }", "signature": "SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "full_signature": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "class_method_signature": "PolygonExtractionProcess.execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "testcase": false, "constructor": false, "invocations": ["getNumSampleDimensions", "size", "execute", "addAll", "add", "getGridToCRS2D", "getGridGeometry", "getRenderedImage", "setSource", "setParameter", "prepareROI", "setParameter", "setParameter", "setParameter", "create", "getProperty", "createFeatureType", "getScaleX", "getShearX", "getTranslateX", "getShearY", "getScaleY", "getTranslateY", "getUserData", "setUserData", "apply", "set", "set", "add", "buildFeature", "valueOf"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}