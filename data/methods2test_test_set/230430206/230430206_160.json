{"test_class": {"identifier": "LearnerTest", "superclass": "extends ZKTestCase", "interfaces": "", "fields": [{"original_string": "private static final File testData = new File(\n        System.getProperty(\"test.data.dir\", \"src/test/resources/data\"));", "modifier": "private static final", "type": "File", "declarator": "testData = new File(\n        System.getProperty(\"test.data.dir\", \"src/test/resources/data\"))", "var_name": "testData"}], "file": "zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LearnerTest.java"}, "test_case": {"identifier": "connectionRetryTimeoutTest", "parameters": "()", "modifiers": "@Test(expected=IOException.class) public", "return": "void", "body": "@Test(expected=IOException.class)\n    public void connectionRetryTimeoutTest() throws Exception {\n        Learner learner = new TimeoutLearner();\n        learner.self = new QuorumPeer();\n        learner.self.setTickTime(2000);\n        learner.self.setInitLimit(5);\n        learner.self.setSyncLimit(2);\n\n        // this addr won't even be used since we fake the Socket.connect\n        InetSocketAddress addr = new InetSocketAddress(1111);\n\n        // we expect this to throw an IOException since we're faking socket connect errors every time\n        learner.connectToLeader(addr, \"\");\n    }", "signature": "void connectionRetryTimeoutTest()", "full_signature": "@Test(expected=IOException.class) public void connectionRetryTimeoutTest()", "class_method_signature": "LearnerTest.connectionRetryTimeoutTest()", "testcase": true, "constructor": false, "invocations": ["setTickTime", "setInitLimit", "setSyncLimit", "connectToLeader"]}, "focal_class": {"identifier": "Learner", "superclass": "", "interfaces": "", "fields": [{"original_string": "QuorumPeer self;", "modifier": "", "type": "QuorumPeer", "declarator": "self", "var_name": "self"}, {"original_string": "LearnerZooKeeperServer zk;", "modifier": "", "type": "LearnerZooKeeperServer", "declarator": "zk", "var_name": "zk"}, {"original_string": "protected BufferedOutputStream bufferedOutput;", "modifier": "protected", "type": "BufferedOutputStream", "declarator": "bufferedOutput", "var_name": "bufferedOutput"}, {"original_string": "protected Socket sock;", "modifier": "protected", "type": "Socket", "declarator": "sock", "var_name": "sock"}, {"original_string": "protected InputArchive leaderIs;", "modifier": "protected", "type": "InputArchive", "declarator": "leaderIs", "var_name": "leaderIs"}, {"original_string": "protected OutputArchive leaderOs;", "modifier": "protected", "type": "OutputArchive", "declarator": "leaderOs", "var_name": "leaderOs"}, {"original_string": "protected int leaderProtocolVersion = 0x01;", "modifier": "protected", "type": "int", "declarator": "leaderProtocolVersion = 0x01", "var_name": "leaderProtocolVersion"}, {"original_string": "protected static final Logger LOG = LoggerFactory.getLogger(Learner.class);", "modifier": "protected static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(Learner.class)", "var_name": "LOG"}, {"original_string": "static final private boolean nodelay = System.getProperty(\"follower.nodelay\", \"true\").equals(\"true\");", "modifier": "static final private", "type": "boolean", "declarator": "nodelay = System.getProperty(\"follower.nodelay\", \"true\").equals(\"true\")", "var_name": "nodelay"}, {"original_string": "final ConcurrentHashMap<Long, ServerCnxn> pendingRevalidations =\n        new ConcurrentHashMap<Long, ServerCnxn>();", "modifier": "final", "type": "ConcurrentHashMap<Long, ServerCnxn>", "declarator": "pendingRevalidations =\n        new ConcurrentHashMap<Long, ServerCnxn>()", "var_name": "pendingRevalidations"}], "methods": [{"identifier": "getSocket", "parameters": "()", "modifiers": "public", "return": "Socket", "signature": "Socket getSocket()", "full_signature": "public Socket getSocket()", "class_method_signature": "Learner.getSocket()", "testcase": false, "constructor": false}, {"identifier": "getPendingRevalidationsCount", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getPendingRevalidationsCount()", "full_signature": "public int getPendingRevalidationsCount()", "class_method_signature": "Learner.getPendingRevalidationsCount()", "testcase": false, "constructor": false}, {"identifier": "validateSession", "parameters": "(ServerCnxn cnxn, long clientId, int timeout)", "modifiers": "", "return": "void", "signature": "void validateSession(ServerCnxn cnxn, long clientId, int timeout)", "full_signature": " void validateSession(ServerCnxn cnxn, long clientId, int timeout)", "class_method_signature": "Learner.validateSession(ServerCnxn cnxn, long clientId, int timeout)", "testcase": false, "constructor": false}, {"identifier": "writePacket", "parameters": "(QuorumPacket pp, boolean flush)", "modifiers": "", "return": "void", "signature": "void writePacket(QuorumPacket pp, boolean flush)", "full_signature": " void writePacket(QuorumPacket pp, boolean flush)", "class_method_signature": "Learner.writePacket(QuorumPacket pp, boolean flush)", "testcase": false, "constructor": false}, {"identifier": "readPacket", "parameters": "(QuorumPacket pp)", "modifiers": "", "return": "void", "signature": "void readPacket(QuorumPacket pp)", "full_signature": " void readPacket(QuorumPacket pp)", "class_method_signature": "Learner.readPacket(QuorumPacket pp)", "testcase": false, "constructor": false}, {"identifier": "request", "parameters": "(Request request)", "modifiers": "", "return": "void", "signature": "void request(Request request)", "full_signature": " void request(Request request)", "class_method_signature": "Learner.request(Request request)", "testcase": false, "constructor": false}, {"identifier": "findLeader", "parameters": "()", "modifiers": "protected", "return": "QuorumServer", "signature": "QuorumServer findLeader()", "full_signature": "protected QuorumServer findLeader()", "class_method_signature": "Learner.findLeader()", "testcase": false, "constructor": false}, {"identifier": "nanoTime", "parameters": "()", "modifiers": "protected", "return": "long", "signature": "long nanoTime()", "full_signature": "protected long nanoTime()", "class_method_signature": "Learner.nanoTime()", "testcase": false, "constructor": false}, {"identifier": "sockConnect", "parameters": "(Socket sock, InetSocketAddress addr, int timeout)", "modifiers": "protected", "return": "void", "signature": "void sockConnect(Socket sock, InetSocketAddress addr, int timeout)", "full_signature": "protected void sockConnect(Socket sock, InetSocketAddress addr, int timeout)", "class_method_signature": "Learner.sockConnect(Socket sock, InetSocketAddress addr, int timeout)", "testcase": false, "constructor": false}, {"identifier": "connectToLeader", "parameters": "(InetSocketAddress addr, String hostname)", "modifiers": "protected", "return": "void", "signature": "void connectToLeader(InetSocketAddress addr, String hostname)", "full_signature": "protected void connectToLeader(InetSocketAddress addr, String hostname)", "class_method_signature": "Learner.connectToLeader(InetSocketAddress addr, String hostname)", "testcase": false, "constructor": false}, {"identifier": "createSocket", "parameters": "()", "modifiers": "private", "return": "Socket", "signature": "Socket createSocket()", "full_signature": "private Socket createSocket()", "class_method_signature": "Learner.createSocket()", "testcase": false, "constructor": false}, {"identifier": "registerWithLeader", "parameters": "(int pktType)", "modifiers": "protected", "return": "long", "signature": "long registerWithLeader(int pktType)", "full_signature": "protected long registerWithLeader(int pktType)", "class_method_signature": "Learner.registerWithLeader(int pktType)", "testcase": false, "constructor": false}, {"identifier": "syncWithLeader", "parameters": "(long newLeaderZxid)", "modifiers": "protected", "return": "void", "signature": "void syncWithLeader(long newLeaderZxid)", "full_signature": "protected void syncWithLeader(long newLeaderZxid)", "class_method_signature": "Learner.syncWithLeader(long newLeaderZxid)", "testcase": false, "constructor": false}, {"identifier": "revalidate", "parameters": "(QuorumPacket qp)", "modifiers": "protected", "return": "void", "signature": "void revalidate(QuorumPacket qp)", "full_signature": "protected void revalidate(QuorumPacket qp)", "class_method_signature": "Learner.revalidate(QuorumPacket qp)", "testcase": false, "constructor": false}, {"identifier": "ping", "parameters": "(QuorumPacket qp)", "modifiers": "protected", "return": "void", "signature": "void ping(QuorumPacket qp)", "full_signature": "protected void ping(QuorumPacket qp)", "class_method_signature": "Learner.ping(QuorumPacket qp)", "testcase": false, "constructor": false}, {"identifier": "shutdown", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void shutdown()", "full_signature": "public void shutdown()", "class_method_signature": "Learner.shutdown()", "testcase": false, "constructor": false}, {"identifier": "isRunning", "parameters": "()", "modifiers": "", "return": "boolean", "signature": "boolean isRunning()", "full_signature": " boolean isRunning()", "class_method_signature": "Learner.isRunning()", "testcase": false, "constructor": false}], "file": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java"}, "focal_method": {"identifier": "connectToLeader", "parameters": "(InetSocketAddress addr, String hostname)", "modifiers": "protected", "return": "void", "body": "protected void connectToLeader(InetSocketAddress addr, String hostname)\n            throws IOException, InterruptedException, X509Exception {\n        this.sock = createSocket();\n\n        int initLimitTime = self.tickTime * self.initLimit;\n        int remainingInitLimitTime = initLimitTime;\n        long startNanoTime = nanoTime();\n\n        for (int tries = 0; tries < 5; tries++) {\n            try {\n                // recalculate the init limit time because retries sleep for 1000 milliseconds\n                remainingInitLimitTime = initLimitTime - (int)((nanoTime() - startNanoTime) / 1000000);\n                if (remainingInitLimitTime <= 0) {\n                    LOG.error(\"initLimit exceeded on retries.\");\n                    throw new IOException(\"initLimit exceeded on retries.\");\n                }\n\n                sockConnect(sock, addr, Math.min(self.tickTime * self.syncLimit, remainingInitLimitTime));\n                if (self.isSslQuorum())  {\n                    ((SSLSocket) sock).startHandshake();\n                }\n                sock.setTcpNoDelay(nodelay);\n                break;\n            } catch (IOException e) {\n                remainingInitLimitTime = initLimitTime - (int)((nanoTime() - startNanoTime) / 1000000);\n\n                if (remainingInitLimitTime <= 1000) {\n                    LOG.error(\"Unexpected exception, initLimit exceeded. tries=\" + tries +\n                             \", remaining init limit=\" + remainingInitLimitTime +\n                             \", connecting to \" + addr,e);\n                    throw e;\n                } else if (tries >= 4) {\n                    LOG.error(\"Unexpected exception, retries exceeded. tries=\" + tries +\n                             \", remaining init limit=\" + remainingInitLimitTime +\n                             \", connecting to \" + addr,e);\n                    throw e;\n                } else {\n                    LOG.warn(\"Unexpected exception, tries=\" + tries +\n                            \", remaining init limit=\" + remainingInitLimitTime +\n                            \", connecting to \" + addr,e);\n                    this.sock = createSocket();\n                }\n            }\n            Thread.sleep(1000);\n        }\n\n        self.authLearner.authenticate(sock, hostname);\n\n        leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(\n                sock.getInputStream()));\n        bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n        leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);\n    }", "signature": "void connectToLeader(InetSocketAddress addr, String hostname)", "full_signature": "protected void connectToLeader(InetSocketAddress addr, String hostname)", "class_method_signature": "Learner.connectToLeader(InetSocketAddress addr, String hostname)", "testcase": false, "constructor": false, "invocations": ["createSocket", "nanoTime", "nanoTime", "error", "sockConnect", "min", "isSslQuorum", "startHandshake", "setTcpNoDelay", "nanoTime", "error", "error", "warn", "createSocket", "sleep", "authenticate", "getArchive", "getInputStream", "getOutputStream", "getArchive"]}, "repository": {"repo_id": 230430206, "url": "https://github.com/boomblog/zookeeper-vip2", "language": "Java", "is_fork": false, "fork_count": 29, "stargazer_count": 10, "size": 3105, "license": "licensed"}}