{"test_class": {"identifier": "KafkaTracingTest", "superclass": "extends KafkaTest", "interfaces": "", "fields": [], "file": "instrumentation/kafka-clients/src/test/java/brave/kafka/clients/KafkaTracingTest.java"}, "test_case": {"identifier": "nextSpan_should_clear_propagation_headers", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void nextSpan_should_clear_propagation_headers() {\n    addB3MultiHeaders(parent, consumerRecord);\n\n    kafkaTracing.nextSpan(consumerRecord);\n    assertThat(consumerRecord.headers().toArray()).isEmpty();\n  }", "signature": "void nextSpan_should_clear_propagation_headers()", "full_signature": "@Test public void nextSpan_should_clear_propagation_headers()", "class_method_signature": "KafkaTracingTest.nextSpan_should_clear_propagation_headers()", "testcase": true, "constructor": false, "invocations": ["addB3MultiHeaders", "nextSpan", "isEmpty", "assertThat", "toArray", "headers"]}, "focal_class": {"identifier": "KafkaTracing", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final Getter<Headers, String> GETTER = new Getter<Headers, String>() {\n    @Override public String get(Headers request, String key) {\n      return lastStringHeader(request, key);\n    }\n\n    @Override public String toString() {\n      return \"Headers::lastHeader\";\n    }\n  };", "modifier": "static final", "type": "Getter<Headers, String>", "declarator": "GETTER = new Getter<Headers, String>() {\n    @Override public String get(Headers request, String key) {\n      return lastStringHeader(request, key);\n    }\n\n    @Override public String toString() {\n      return \"Headers::lastHeader\";\n    }\n  }", "var_name": "GETTER"}, {"original_string": "final MessagingTracing messagingTracing;", "modifier": "final", "type": "MessagingTracing", "declarator": "messagingTracing", "var_name": "messagingTracing"}, {"original_string": "final Tracer tracer;", "modifier": "final", "type": "Tracer", "declarator": "tracer", "var_name": "tracer"}, {"original_string": "final Extractor<KafkaProducerRequest> producerExtractor;", "modifier": "final", "type": "Extractor<KafkaProducerRequest>", "declarator": "producerExtractor", "var_name": "producerExtractor"}, {"original_string": "final Extractor<KafkaConsumerRequest> consumerExtractor;", "modifier": "final", "type": "Extractor<KafkaConsumerRequest>", "declarator": "consumerExtractor", "var_name": "consumerExtractor"}, {"original_string": "final Extractor<Headers> processorExtractor;", "modifier": "final", "type": "Extractor<Headers>", "declarator": "processorExtractor", "var_name": "processorExtractor"}, {"original_string": "final Injector<KafkaProducerRequest> producerInjector;", "modifier": "final", "type": "Injector<KafkaProducerRequest>", "declarator": "producerInjector", "var_name": "producerInjector"}, {"original_string": "final Injector<KafkaConsumerRequest> consumerInjector;", "modifier": "final", "type": "Injector<KafkaConsumerRequest>", "declarator": "consumerInjector", "var_name": "consumerInjector"}, {"original_string": "final Set<String> traceIdHeaders;", "modifier": "final", "type": "Set<String>", "declarator": "traceIdHeaders", "var_name": "traceIdHeaders"}, {"original_string": "final TraceContextOrSamplingFlags emptyExtraction;", "modifier": "final", "type": "TraceContextOrSamplingFlags", "declarator": "emptyExtraction", "var_name": "emptyExtraction"}, {"original_string": "final SamplerFunction<MessagingRequest> producerSampler, consumerSampler;", "modifier": "final", "type": "SamplerFunction<MessagingRequest>", "declarator": "producerSampler", "var_name": "producerSampler"}, {"original_string": "final String remoteServiceName;", "modifier": "final", "type": "String", "declarator": "remoteServiceName", "var_name": "remoteServiceName"}, {"original_string": "final boolean singleRootSpanOnReceiveBatch;", "modifier": "final", "type": "boolean", "declarator": "singleRootSpanOnReceiveBatch", "var_name": "singleRootSpanOnReceiveBatch"}], "methods": [{"identifier": "create", "parameters": "(Tracing tracing)", "modifiers": "public static", "return": "KafkaTracing", "signature": "KafkaTracing create(Tracing tracing)", "full_signature": "public static KafkaTracing create(Tracing tracing)", "class_method_signature": "KafkaTracing.create(Tracing tracing)", "testcase": false, "constructor": false}, {"identifier": "create", "parameters": "(MessagingTracing messagingTracing)", "modifiers": "public static", "return": "KafkaTracing", "signature": "KafkaTracing create(MessagingTracing messagingTracing)", "full_signature": "public static KafkaTracing create(MessagingTracing messagingTracing)", "class_method_signature": "KafkaTracing.create(MessagingTracing messagingTracing)", "testcase": false, "constructor": false}, {"identifier": "newBuilder", "parameters": "(Tracing tracing)", "modifiers": "public static", "return": "Builder", "signature": "Builder newBuilder(Tracing tracing)", "full_signature": "public static Builder newBuilder(Tracing tracing)", "class_method_signature": "KafkaTracing.newBuilder(Tracing tracing)", "testcase": false, "constructor": false}, {"identifier": "newBuilder", "parameters": "(MessagingTracing messagingTracing)", "modifiers": "public static", "return": "Builder", "signature": "Builder newBuilder(MessagingTracing messagingTracing)", "full_signature": "public static Builder newBuilder(MessagingTracing messagingTracing)", "class_method_signature": "KafkaTracing.newBuilder(MessagingTracing messagingTracing)", "testcase": false, "constructor": false}, {"identifier": "toBuilder", "parameters": "()", "modifiers": "public", "return": "Builder", "signature": "Builder toBuilder()", "full_signature": "public Builder toBuilder()", "class_method_signature": "KafkaTracing.toBuilder()", "testcase": false, "constructor": false}, {"identifier": "KafkaTracing", "parameters": "(Builder builder)", "modifiers": "", "return": "", "signature": " KafkaTracing(Builder builder)", "full_signature": "  KafkaTracing(Builder builder)", "class_method_signature": "KafkaTracing.KafkaTracing(Builder builder)", "testcase": false, "constructor": true}, {"identifier": "messagingTracing", "parameters": "()", "modifiers": "public", "return": "MessagingTracing", "signature": "MessagingTracing messagingTracing()", "full_signature": "public MessagingTracing messagingTracing()", "class_method_signature": "KafkaTracing.messagingTracing()", "testcase": false, "constructor": false}, {"identifier": "consumer", "parameters": "(Consumer<K, V> consumer)", "modifiers": "public", "return": "Consumer<K, V>", "signature": "Consumer<K, V> consumer(Consumer<K, V> consumer)", "full_signature": "public Consumer<K, V> consumer(Consumer<K, V> consumer)", "class_method_signature": "KafkaTracing.consumer(Consumer<K, V> consumer)", "testcase": false, "constructor": false}, {"identifier": "producer", "parameters": "(Producer<K, V> producer)", "modifiers": "public", "return": "Producer<K, V>", "signature": "Producer<K, V> producer(Producer<K, V> producer)", "full_signature": "public Producer<K, V> producer(Producer<K, V> producer)", "class_method_signature": "KafkaTracing.producer(Producer<K, V> producer)", "testcase": false, "constructor": false}, {"identifier": "nextSpan", "parameters": "(ConsumerRecord<?, ?> record)", "modifiers": "public", "return": "Span", "signature": "Span nextSpan(ConsumerRecord<?, ?> record)", "full_signature": "public Span nextSpan(ConsumerRecord<?, ?> record)", "class_method_signature": "KafkaTracing.nextSpan(ConsumerRecord<?, ?> record)", "testcase": false, "constructor": false}, {"identifier": "extractAndClearTraceIdHeaders", "parameters": "(\n    Extractor<R> extractor, R request, Headers headers\n  )", "modifiers": "", "return": "TraceContextOrSamplingFlags", "signature": "TraceContextOrSamplingFlags extractAndClearTraceIdHeaders(\n    Extractor<R> extractor, R request, Headers headers\n  )", "full_signature": " TraceContextOrSamplingFlags extractAndClearTraceIdHeaders(\n    Extractor<R> extractor, R request, Headers headers\n  )", "class_method_signature": "KafkaTracing.extractAndClearTraceIdHeaders(\n    Extractor<R> extractor, R request, Headers headers\n  )", "testcase": false, "constructor": false}, {"identifier": "nextMessagingSpan", "parameters": "(\n    SamplerFunction<MessagingRequest> sampler,\n    MessagingRequest request,\n    TraceContextOrSamplingFlags extracted\n  )", "modifiers": "", "return": "Span", "signature": "Span nextMessagingSpan(\n    SamplerFunction<MessagingRequest> sampler,\n    MessagingRequest request,\n    TraceContextOrSamplingFlags extracted\n  )", "full_signature": " Span nextMessagingSpan(\n    SamplerFunction<MessagingRequest> sampler,\n    MessagingRequest request,\n    TraceContextOrSamplingFlags extracted\n  )", "class_method_signature": "KafkaTracing.nextMessagingSpan(\n    SamplerFunction<MessagingRequest> sampler,\n    MessagingRequest request,\n    TraceContextOrSamplingFlags extracted\n  )", "testcase": false, "constructor": false}, {"identifier": "clearTraceIdHeaders", "parameters": "(Headers headers)", "modifiers": "", "return": "void", "signature": "void clearTraceIdHeaders(Headers headers)", "full_signature": " void clearTraceIdHeaders(Headers headers)", "class_method_signature": "KafkaTracing.clearTraceIdHeaders(Headers headers)", "testcase": false, "constructor": false}, {"identifier": "addTags", "parameters": "(ConsumerRecord<?, ?> record, SpanCustomizer result)", "modifiers": "static", "return": "void", "signature": "void addTags(ConsumerRecord<?, ?> record, SpanCustomizer result)", "full_signature": "static void addTags(ConsumerRecord<?, ?> record, SpanCustomizer result)", "class_method_signature": "KafkaTracing.addTags(ConsumerRecord<?, ?> record, SpanCustomizer result)", "testcase": false, "constructor": false}], "file": "instrumentation/kafka-clients/src/main/java/brave/kafka/clients/KafkaTracing.java"}, "focal_method": {"identifier": "nextSpan", "parameters": "(ConsumerRecord<?, ?> record)", "modifiers": "public", "return": "Span", "body": "public Span nextSpan(ConsumerRecord<?, ?> record) {\n    // Eventhough the type is ConsumerRecord, this is not a (remote) consumer span. Only \"poll\"\n    // events create consumer spans. Since this is a processor span, we use the normal sampler.\n    TraceContextOrSamplingFlags extracted =\n      extractAndClearTraceIdHeaders(processorExtractor, record.headers(), record.headers());\n    Span result = tracer.nextSpan(extracted);\n    if (extracted.context() == null && !result.isNoop()) {\n      addTags(record, result);\n    }\n    return result;\n  }", "signature": "Span nextSpan(ConsumerRecord<?, ?> record)", "full_signature": "public Span nextSpan(ConsumerRecord<?, ?> record)", "class_method_signature": "KafkaTracing.nextSpan(ConsumerRecord<?, ?> record)", "testcase": false, "constructor": false, "invocations": ["extractAndClearTraceIdHeaders", "headers", "headers", "nextSpan", "context", "isNoop", "addTags"]}, "repository": {"repo_id": 9278888, "url": "https://github.com/openzipkin/brave", "stars": 1754, "created": "4/7/2013 3:48:18 PM +00:00", "updates": "2020-01-26T11:52:41+00:00", "fork": "False", "license": "licensed"}}