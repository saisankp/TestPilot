{"test_class": {"identifier": "SymbolLookupTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule\n    public JenkinsRule rule = new JenkinsRule();", "modifier": "@Rule\n    public", "type": "JenkinsRule", "declarator": "rule = new JenkinsRule()", "var_name": "rule"}, {"original_string": "@Rule public ErrorCollector errors = new ErrorCollector();", "modifier": "@Rule public", "type": "ErrorCollector", "declarator": "errors = new ErrorCollector()", "var_name": "errors"}, {"original_string": "@Inject\n    SymbolLookup lookup;", "modifier": "@Inject", "type": "SymbolLookup", "declarator": "lookup", "var_name": "lookup"}, {"original_string": "@Inject\n    Foo foo;", "modifier": "@Inject", "type": "Foo", "declarator": "foo", "var_name": "foo"}, {"original_string": "@Inject\n    Bar bar;", "modifier": "@Inject", "type": "Bar", "declarator": "bar", "var_name": "bar"}, {"original_string": "@Inject\n    FishingNet.DescriptorImpl fishingNetDescriptor;", "modifier": "@Inject", "type": "FishingNet.DescriptorImpl", "declarator": "fishingNetDescriptor", "var_name": "fishingNetDescriptor"}, {"original_string": "@Inject\n    Internet.DescriptorImpl internetDescriptor;", "modifier": "@Inject", "type": "Internet.DescriptorImpl", "declarator": "internetDescriptor", "var_name": "internetDescriptor"}], "file": "plugin/src/test/java/org/jenkinsci/plugins/structs/SymbolLookupTest.java"}, "test_case": {"identifier": "symbolValueFromClass", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void symbolValueFromClass() {\n        Set<String> netSet = Collections.singleton(\"net\");\n        Set<String> fooSet = Collections.singleton(\"foo\");\n\n        assertEquals(Collections.emptySet(), SymbolLookup.getSymbolValue(String.class));\n        assertEquals(netSet, SymbolLookup.getSymbolValue(FishingNet.class));\n        assertEquals(netSet, SymbolLookup.getSymbolValue(FishingNet.DescriptorImpl.class));\n        assertEquals(fooSet, SymbolLookup.getSymbolValue(Foo.class));\n    }", "signature": "void symbolValueFromClass()", "full_signature": "@Test public void symbolValueFromClass()", "class_method_signature": "SymbolLookupTest.symbolValueFromClass()", "testcase": true, "constructor": false, "invocations": ["singleton", "singleton", "assertEquals", "emptySet", "getSymbolValue", "assertEquals", "getSymbolValue", "assertEquals", "getSymbolValue", "assertEquals", "getSymbolValue"]}, "focal_class": {"identifier": "SymbolLookup", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final ConcurrentMap<Key,Object> cache = new ConcurrentHashMap<Key, Object>();", "modifier": "private final", "type": "ConcurrentMap<Key,Object>", "declarator": "cache = new ConcurrentHashMap<Key, Object>()", "var_name": "cache"}, {"original_string": "private final ConcurrentMap<Key,Object> noHitCache = new ConcurrentHashMap<Key, Object>();", "modifier": "private final", "type": "ConcurrentMap<Key,Object>", "declarator": "noHitCache = new ConcurrentHashMap<Key, Object>()", "var_name": "noHitCache"}, {"original_string": "static final Object NO_HIT = new Object();", "modifier": "static final", "type": "Object", "declarator": "NO_HIT = new Object()", "var_name": "NO_HIT"}, {"original_string": "@Inject\n    PluginManager pluginManager;", "modifier": "@Inject", "type": "PluginManager", "declarator": "pluginManager", "var_name": "pluginManager"}, {"original_string": "@Inject\n    Jenkins jenkins;", "modifier": "@Inject", "type": "Jenkins", "declarator": "jenkins", "var_name": "jenkins"}, {"original_string": "Set<String> pluginNames = Collections.EMPTY_SET;", "modifier": "", "type": "Set<String>", "declarator": "pluginNames = Collections.EMPTY_SET", "var_name": "pluginNames"}, {"original_string": "private static final Logger LOGGER = Logger.getLogger(SymbolLookup.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = Logger.getLogger(SymbolLookup.class.getName())", "var_name": "LOGGER"}], "methods": [{"identifier": "pluginsToNames", "parameters": "(List<PluginWrapper> plugins)", "modifiers": "private static", "return": "HashSet<String>", "signature": "HashSet<String> pluginsToNames(List<PluginWrapper> plugins)", "full_signature": "private static HashSet<String> pluginsToNames(List<PluginWrapper> plugins)", "class_method_signature": "SymbolLookup.pluginsToNames(List<PluginWrapper> plugins)", "testcase": false, "constructor": false}, {"identifier": "checkPluginsForChangeAndRefresh", "parameters": "()", "modifiers": "private synchronized", "return": "void", "signature": "void checkPluginsForChangeAndRefresh()", "full_signature": "private synchronized void checkPluginsForChangeAndRefresh()", "class_method_signature": "SymbolLookup.checkPluginsForChangeAndRefresh()", "testcase": false, "constructor": false}, {"identifier": "find", "parameters": "(Class<T> type, String symbol)", "modifiers": "public", "return": "T", "signature": "T find(Class<T> type, String symbol)", "full_signature": "public T find(Class<T> type, String symbol)", "class_method_signature": "SymbolLookup.find(Class<T> type, String symbol)", "testcase": false, "constructor": false}, {"identifier": "findDescriptor", "parameters": "(Class<?> type, String symbol)", "modifiers": "public", "return": "Descriptor<?>", "signature": "Descriptor<?> findDescriptor(Class<?> type, String symbol)", "full_signature": "public Descriptor<?> findDescriptor(Class<?> type, String symbol)", "class_method_signature": "SymbolLookup.findDescriptor(Class<?> type, String symbol)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "()", "modifiers": "public static", "return": "SymbolLookup", "signature": "SymbolLookup get()", "full_signature": "public static SymbolLookup get()", "class_method_signature": "SymbolLookup.get()", "testcase": false, "constructor": false}, {"identifier": "getSymbolValue", "parameters": "(@Nonnull Object o)", "modifiers": "@Nonnull public static", "return": "Set<String>", "signature": "Set<String> getSymbolValue(@Nonnull Object o)", "full_signature": "@Nonnull public static Set<String> getSymbolValue(@Nonnull Object o)", "class_method_signature": "SymbolLookup.getSymbolValue(@Nonnull Object o)", "testcase": false, "constructor": false}, {"identifier": "getSymbolValue", "parameters": "(@Nonnull Class<?> c)", "modifiers": "@SuppressFBWarnings(value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\", justification = \"Jenkins.getInstance() can return null in theory.\") @Nonnull public static", "return": "Set<String>", "signature": "Set<String> getSymbolValue(@Nonnull Class<?> c)", "full_signature": "@SuppressFBWarnings(value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\", justification = \"Jenkins.getInstance() can return null in theory.\") @Nonnull public static Set<String> getSymbolValue(@Nonnull Class<?> c)", "class_method_signature": "SymbolLookup.getSymbolValue(@Nonnull Class<?> c)", "testcase": false, "constructor": false}], "file": "plugin/src/main/java/org/jenkinsci/plugins/structs/SymbolLookup.java"}, "focal_method": {"identifier": "getSymbolValue", "parameters": "(@Nonnull Object o)", "modifiers": "@Nonnull public static", "return": "Set<String>", "body": "@Nonnull public static Set<String> getSymbolValue(@Nonnull Object o) {\n        if (o instanceof Describable) {\n            return getSymbolValue(((Describable) o).getDescriptor().getClass());\n        } else {\n            return getSymbolValue(o.getClass());\n        }\n    }", "signature": "Set<String> getSymbolValue(@Nonnull Object o)", "full_signature": "@Nonnull public static Set<String> getSymbolValue(@Nonnull Object o)", "class_method_signature": "SymbolLookup.getSymbolValue(@Nonnull Object o)", "testcase": false, "constructor": false, "invocations": ["getSymbolValue", "getClass", "getDescriptor", "getSymbolValue", "getClass"]}, "repository": {"repo_id": 48337544, "url": "https://github.com/jenkinsci/structs-plugin", "language": "Java", "is_fork": false, "fork_count": 28, "stargazer_count": 8, "size": 421, "license": "licensed"}}