{"test_class": {"identifier": "SerializersTest", "superclass": "", "interfaces": "", "fields": [], "file": "flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/kryo/SerializersTest.java"}, "test_case": {"identifier": "testTypeRegistration", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testTypeRegistration() {\n\t\tExecutionConfig conf = new ExecutionConfig();\n\t\tSerializers.recursivelyRegisterType(ClassWithNested.class, conf, new HashSet<Class<?>>());\n\t\t\n\t\tKryoSerializer<String> kryo = new KryoSerializer<>(String.class, conf); // we create Kryo from another type.\n\n\t\tAssert.assertTrue(kryo.getKryo().getRegistration(FromNested.class).getId() > 0);\n\t\tAssert.assertTrue(kryo.getKryo().getRegistration(ClassWithNested.class).getId() > 0);\n\t\tAssert.assertTrue(kryo.getKryo().getRegistration(Path.class).getId() > 0);\n\t\t\n\t\t// check if the generic type from one field is also registered (its very likely that\n\t\t// generic types are also used as fields somewhere.\n\t\tAssert.assertTrue(kryo.getKryo().getRegistration(FromGeneric1.class).getId() > 0);\n\t\tAssert.assertTrue(kryo.getKryo().getRegistration(FromGeneric2.class).getId() > 0);\n\t\tAssert.assertTrue(kryo.getKryo().getRegistration(Node.class).getId() > 0);\n\t\t\n\t\t\n\t\t// register again and make sure classes are still registered\n\t\tExecutionConfig conf2 = new ExecutionConfig();\n\t\tSerializers.recursivelyRegisterType(ClassWithNested.class, conf2, new HashSet<Class<?>>());\n\t\tKryoSerializer<String> kryo2 = new KryoSerializer<>(String.class, conf);\n\t\tassertTrue(kryo2.getKryo().getRegistration(FromNested.class).getId() > 0);\n\t}", "signature": "void testTypeRegistration()", "full_signature": "@Test public void testTypeRegistration()", "class_method_signature": "SerializersTest.testTypeRegistration()", "testcase": true, "constructor": false, "invocations": ["recursivelyRegisterType", "assertTrue", "getId", "getRegistration", "getKryo", "assertTrue", "getId", "getRegistration", "getKryo", "assertTrue", "getId", "getRegistration", "getKryo", "assertTrue", "getId", "getRegistration", "getKryo", "assertTrue", "getId", "getRegistration", "getKryo", "assertTrue", "getId", "getRegistration", "getKryo", "recursivelyRegisterType", "assertTrue", "getId", "getRegistration", "getKryo"]}, "focal_class": {"identifier": "Serializers", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "recursivelyRegisterType", "parameters": "(TypeInformation<?> typeInfo, ExecutionConfig config, Set<Class<?>> alreadySeen)", "modifiers": "public static", "return": "void", "signature": "void recursivelyRegisterType(TypeInformation<?> typeInfo, ExecutionConfig config, Set<Class<?>> alreadySeen)", "full_signature": "public static void recursivelyRegisterType(TypeInformation<?> typeInfo, ExecutionConfig config, Set<Class<?>> alreadySeen)", "class_method_signature": "Serializers.recursivelyRegisterType(TypeInformation<?> typeInfo, ExecutionConfig config, Set<Class<?>> alreadySeen)", "testcase": false, "constructor": false}, {"identifier": "recursivelyRegisterType", "parameters": "(Class<?> type, ExecutionConfig config, Set<Class<?>> alreadySeen)", "modifiers": "public static", "return": "void", "signature": "void recursivelyRegisterType(Class<?> type, ExecutionConfig config, Set<Class<?>> alreadySeen)", "full_signature": "public static void recursivelyRegisterType(Class<?> type, ExecutionConfig config, Set<Class<?>> alreadySeen)", "class_method_signature": "Serializers.recursivelyRegisterType(Class<?> type, ExecutionConfig config, Set<Class<?>> alreadySeen)", "testcase": false, "constructor": false}, {"identifier": "recursivelyRegisterGenericType", "parameters": "(Type fieldType, ExecutionConfig config, Set<Class<?>> alreadySeen)", "modifiers": "private static", "return": "void", "signature": "void recursivelyRegisterGenericType(Type fieldType, ExecutionConfig config, Set<Class<?>> alreadySeen)", "full_signature": "private static void recursivelyRegisterGenericType(Type fieldType, ExecutionConfig config, Set<Class<?>> alreadySeen)", "class_method_signature": "Serializers.recursivelyRegisterGenericType(Type fieldType, ExecutionConfig config, Set<Class<?>> alreadySeen)", "testcase": false, "constructor": false}, {"identifier": "getContainedGenericTypes", "parameters": "(CompositeType<?> typeInfo, List<GenericTypeInfo<?>> target)", "modifiers": "private static", "return": "void", "signature": "void getContainedGenericTypes(CompositeType<?> typeInfo, List<GenericTypeInfo<?>> target)", "full_signature": "private static void getContainedGenericTypes(CompositeType<?> typeInfo, List<GenericTypeInfo<?>> target)", "class_method_signature": "Serializers.getContainedGenericTypes(CompositeType<?> typeInfo, List<GenericTypeInfo<?>> target)", "testcase": false, "constructor": false}, {"identifier": "checkAndAddSerializerForTypeAvro", "parameters": "(ExecutionConfig reg, Class<?> type)", "modifiers": "private static", "return": "void", "signature": "void checkAndAddSerializerForTypeAvro(ExecutionConfig reg, Class<?> type)", "full_signature": "private static void checkAndAddSerializerForTypeAvro(ExecutionConfig reg, Class<?> type)", "class_method_signature": "Serializers.checkAndAddSerializerForTypeAvro(ExecutionConfig reg, Class<?> type)", "testcase": false, "constructor": false}], "file": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/Serializers.java"}, "focal_method": {"identifier": "recursivelyRegisterType", "parameters": "(TypeInformation<?> typeInfo, ExecutionConfig config, Set<Class<?>> alreadySeen)", "modifiers": "public static", "return": "void", "body": "public static void recursivelyRegisterType(TypeInformation<?> typeInfo, ExecutionConfig config, Set<Class<?>> alreadySeen) {\n\t\tif (typeInfo instanceof GenericTypeInfo) {\n\t\t\tGenericTypeInfo<?> genericTypeInfo = (GenericTypeInfo<?>) typeInfo;\n\t\t\tSerializers.recursivelyRegisterType(genericTypeInfo.getTypeClass(), config, alreadySeen);\n\t\t}\n\t\telse if (typeInfo instanceof CompositeType) {\n\t\t\tList<GenericTypeInfo<?>> genericTypesInComposite = new ArrayList<>();\n\t\t\tgetContainedGenericTypes((CompositeType<?>)typeInfo, genericTypesInComposite);\n\t\t\tfor (GenericTypeInfo<?> gt : genericTypesInComposite) {\n\t\t\t\tSerializers.recursivelyRegisterType(gt.getTypeClass(), config, alreadySeen);\n\t\t\t}\n\t\t}\n\t\telse if (typeInfo instanceof ObjectArrayTypeInfo) {\n\t\t\tObjectArrayTypeInfo<?, ?> objectArrayTypeInfo = (ObjectArrayTypeInfo<?, ?>) typeInfo;\n\t\t\trecursivelyRegisterType(objectArrayTypeInfo.getComponentInfo(), config, alreadySeen);\n\t\t}\n\t}", "signature": "void recursivelyRegisterType(TypeInformation<?> typeInfo, ExecutionConfig config, Set<Class<?>> alreadySeen)", "full_signature": "public static void recursivelyRegisterType(TypeInformation<?> typeInfo, ExecutionConfig config, Set<Class<?>> alreadySeen)", "class_method_signature": "Serializers.recursivelyRegisterType(TypeInformation<?> typeInfo, ExecutionConfig config, Set<Class<?>> alreadySeen)", "testcase": false, "constructor": false, "invocations": ["recursivelyRegisterType", "getTypeClass", "getContainedGenericTypes", "recursivelyRegisterType", "getTypeClass", "recursivelyRegisterType", "getComponentInfo"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}