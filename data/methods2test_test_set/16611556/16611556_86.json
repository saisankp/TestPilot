{"test_class": {"identifier": "InvalidateMultiCacheAdviceTest", "superclass": "extends AbstractCacheTest<InvalidateMultiCacheAdvice>", "interfaces": "", "fields": [{"original_string": "private static final String NS = \"ABC_SOME_NS\";", "modifier": "private static final", "type": "String", "declarator": "NS = \"ABC_SOME_NS\"", "var_name": "NS"}, {"original_string": "private Object expectedValue;", "modifier": "private", "type": "Object", "declarator": "expectedValue", "var_name": "expectedValue"}, {"original_string": "private String[] cacheKeys;", "modifier": "private", "type": "String[]", "declarator": "cacheKeys", "var_name": "cacheKeys"}], "file": "simple-spring-memcached/src/test/java/com/google/code/ssm/aop/InvalidateMultiCacheAdviceTest.java"}, "test_case": {"identifier": "valid", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void valid() throws Throwable {\n        Assume.assumeTrue(isValid);\n\n        when(pjp.proceed()).thenReturn(expectedValue);\n\n        assertEquals(expectedValue, advice.cacheInvalidateMulti(pjp));\n\n        verify(pjp).proceed();\n        verify(cache).delete(argThat(new ArgumentMatcher<Collection<String>>() {\n\n            @Override\n            public boolean matches(Collection<String> set) {\n                Set<String> target = new HashSet<String>(Arrays.asList(cacheKeys));\n                return set.containsAll(target) && target.containsAll(set);\n            }\n\n        }));\n    }", "signature": "void valid()", "full_signature": "@Test public void valid()", "class_method_signature": "InvalidateMultiCacheAdviceTest.valid()", "testcase": true, "constructor": false, "invocations": ["assumeTrue", "thenReturn", "when", "proceed", "assertEquals", "cacheInvalidateMulti", "proceed", "verify", "delete", "verify", "argThat", "asList", "containsAll", "containsAll"]}, "focal_class": {"identifier": "InvalidateMultiCacheAdvice", "superclass": "extends CacheAdvice", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(InvalidateMultiCacheAdvice.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(InvalidateMultiCacheAdvice.class)", "var_name": "LOG"}], "methods": [{"identifier": "invalidateMulti", "parameters": "()", "modifiers": "@Pointcut(\"@annotation(com.google.code.ssm.api.InvalidateMultiCache)\") public", "return": "void", "signature": "void invalidateMulti()", "full_signature": "@Pointcut(\"@annotation(com.google.code.ssm.api.InvalidateMultiCache)\") public void invalidateMulti()", "class_method_signature": "InvalidateMultiCacheAdvice.invalidateMulti()", "testcase": false, "constructor": false}, {"identifier": "cacheInvalidateMulti", "parameters": "(final ProceedingJoinPoint pjp)", "modifiers": "@Around(\"invalidateMulti()\") public", "return": "Object", "signature": "Object cacheInvalidateMulti(final ProceedingJoinPoint pjp)", "full_signature": "@Around(\"invalidateMulti()\") public Object cacheInvalidateMulti(final ProceedingJoinPoint pjp)", "class_method_signature": "InvalidateMultiCacheAdvice.cacheInvalidateMulti(final ProceedingJoinPoint pjp)", "testcase": false, "constructor": false}, {"identifier": "getLogger", "parameters": "()", "modifiers": "@Override protected", "return": "Logger", "signature": "Logger getLogger()", "full_signature": "@Override protected Logger getLogger()", "class_method_signature": "InvalidateMultiCacheAdvice.getLogger()", "testcase": false, "constructor": false}], "file": "simple-spring-memcached/src/main/java/com/google/code/ssm/aop/InvalidateMultiCacheAdvice.java"}, "focal_method": {"identifier": "cacheInvalidateMulti", "parameters": "(final ProceedingJoinPoint pjp)", "modifiers": "@Around(\"invalidateMulti()\") public", "return": "Object", "body": "@Around(\"invalidateMulti()\")\n    public Object cacheInvalidateMulti(final ProceedingJoinPoint pjp) throws Throwable {\n        if (isDisabled()) {\n            getLogger().info(\"Cache disabled\");\n            return pjp.proceed();\n        }\n\n        // This is injected caching. If anything goes wrong in the caching, LOG\n        // the crap outta it, but do not let it surface up past the AOP injection itself.\n        Collection<String> cacheKeys = null;\n        final AnnotationData data;\n        final Method methodToCache;\n        try {\n            methodToCache = getCacheBase().getMethodToCache(pjp, InvalidateMultiCache.class);\n            final InvalidateMultiCache annotation = methodToCache.getAnnotation(InvalidateMultiCache.class);\n            data = AnnotationDataBuilder.buildAnnotationData(annotation, InvalidateMultiCache.class, methodToCache);\n            if (!data.isReturnKeyIndex()) {\n                cacheKeys = getCacheBase().getCacheKeyBuilder().getCacheKeys(data, pjp.getArgs(), methodToCache.toString());\n            }\n        } catch (Exception ex) {\n            warn(ex, \"Caching on method %s aborted due to an error.\", pjp.toShortString());\n            return pjp.proceed();\n        }\n\n        final Object result = pjp.proceed();\n\n        // This is injected caching. If anything goes wrong in the caching, LOG\n        // the crap outta it, but do not let it surface up past the AOP injection itself.\n        try {\n            // If we have a -1 key index, then build the cacheKeys now.\n            if (data.isReturnKeyIndex()) {\n                if (!getCacheBase().verifyTypeIsList(result.getClass())) {\n                    throw new InvalidAnnotationException(String.format(\"The return type is not a [%s]. \"\n                            + \"The method [%s] does not fulfill the requirements.\", List.class.getName(), methodToCache.toString()));\n                }\n\n                @SuppressWarnings(\"unchecked\")\n                final List<Object> keyObjects = (List<Object>) result;\n                cacheKeys = getCacheBase().getCacheKeyBuilder().getCacheKeys(keyObjects, data.getNamespace());\n            }\n            getCacheBase().getCache(data).delete(cacheKeys);\n        } catch (Exception ex) {\n            warn(ex, \"Caching on method %s aborted due to an error.\", pjp.toShortString());\n        }\n        return result;\n\n    }", "signature": "Object cacheInvalidateMulti(final ProceedingJoinPoint pjp)", "full_signature": "@Around(\"invalidateMulti()\") public Object cacheInvalidateMulti(final ProceedingJoinPoint pjp)", "class_method_signature": "InvalidateMultiCacheAdvice.cacheInvalidateMulti(final ProceedingJoinPoint pjp)", "testcase": false, "constructor": false, "invocations": ["isDisabled", "info", "getLogger", "proceed", "getMethodToCache", "getCacheBase", "getAnnotation", "buildAnnotationData", "isReturnKeyIndex", "getCacheKeys", "getCacheKeyBuilder", "getCacheBase", "getArgs", "toString", "warn", "toShortString", "proceed", "proceed", "isReturnKeyIndex", "verifyTypeIsList", "getCacheBase", "getClass", "format", "getName", "toString", "getCacheKeys", "getCacheKeyBuilder", "getCacheBase", "getNamespace", "delete", "getCache", "getCacheBase", "warn", "toShortString"]}, "repository": {"repo_id": 16611556, "url": "https://github.com/ragnor/simple-spring-memcached", "language": "Java", "is_fork": false, "fork_count": 86, "stargazer_count": 181, "size": 3625, "license": "licensed"}}