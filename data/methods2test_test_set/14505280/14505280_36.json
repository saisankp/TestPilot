{"test_class": {"identifier": "GetLocationForStringCommandTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double DELTA = 1e-20;", "modifier": "private static final", "type": "double", "declarator": "DELTA = 1e-20", "var_name": "DELTA"}, {"original_string": "@Autowired\n\tprivate CommandDispatcher commandDispatcher;", "modifier": "@Autowired\n\tprivate", "type": "CommandDispatcher", "declarator": "commandDispatcher", "var_name": "commandDispatcher"}], "file": "plugin/geocoder/geocoder/src/test/java/org/geomajas/plugin/geocoder/command/geocoder/GetLocationForStringCommandTest.java"}, "test_case": {"identifier": "expandPointTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void expandPointTest() throws Exception {\n\t\tGetLocationForStringRequest request = new GetLocationForStringRequest();\n\t\trequest.setCrs(\"EPSG:900913\");\n\t\trequest.setLocation(\"booischot\");\n\n\t\tCommandResponse commandResponse = commandDispatcher.execute(GetLocationForStringRequest.COMMAND, request, null,\n\t\t\t\t\"en\");\n\t\tAssert.assertNotNull(commandResponse);\n\t\tAssert.assertTrue(commandResponse instanceof GetLocationForStringResponse);\n\t\tGetLocationForStringResponse response = (GetLocationForStringResponse)commandResponse;\n\t\tAssert.assertTrue(response.isLocationFound());\n\t\tAssert.assertEquals(\"booischot\", response.getCanonicalLocation());\n\t\tAssert.assertNotNull(response.getCenter());\n\t\tAssert.assertNotNull(response.getBbox());\n\t\tAssert.assertEquals(621468.063486916, response.getCenter().getX(), DELTA);\n\t\tAssert.assertEquals(5706881.117852388, response.getCenter().getY(), DELTA);\n\t\tAssert.assertEquals(621325.5343735645, response.getBbox().getX(), DELTA);\n\t\tAssert.assertEquals(5706809.617868648, response.getBbox().getY(), DELTA);\n\t\tAssert.assertEquals(285.05822670296766, response.getBbox().getWidth(), DELTA);\n\t\tAssert.assertEquals(142.99996748007834, response.getBbox().getHeight(), DELTA);\n\t\tAssert.assertEquals(\"static-regex\", response.getGeocoderName());\n\t\tAssert.assertNotNull(response.getUserData());\n\t\tAssert.assertEquals(\"schotbooi\", ((UserDataTestInfo)response.getUserData()).getValue());\n\t}", "signature": "void expandPointTest()", "full_signature": "@Test public void expandPointTest()", "class_method_signature": "GetLocationForStringCommandTest.expandPointTest()", "testcase": true, "constructor": false, "invocations": ["setCrs", "setLocation", "execute", "assertNotNull", "assertTrue", "assertTrue", "isLocationFound", "assertEquals", "getCanonicalLocation", "assertNotNull", "getCenter", "assertNotNull", "getBbox", "assertEquals", "getX", "getCenter", "assertEquals", "getY", "getCenter", "assertEquals", "getX", "getBbox", "assertEquals", "getY", "getBbox", "assertEquals", "getWidth", "getBbox", "assertEquals", "getHeight", "getBbox", "assertEquals", "getGeocoderName", "assertNotNull", "getUserData", "assertEquals", "getValue", "getUserData"]}, "focal_class": {"identifier": "GetLocationForStringCommand", "superclass": "", "interfaces": "implements CommandHasRequest<GetLocationForStringRequest, GetLocationForStringResponse>", "fields": [{"original_string": "@Autowired\n\tprivate GeocoderInfo geocoderInfo;", "modifier": "@Autowired\n\tprivate", "type": "GeocoderInfo", "declarator": "geocoderInfo", "var_name": "geocoderInfo"}, {"original_string": "@Autowired\n\tprivate SplitCommaReverseService defaultSplitGeocoderStringService;", "modifier": "@Autowired\n\tprivate", "type": "SplitCommaReverseService", "declarator": "defaultSplitGeocoderStringService", "var_name": "defaultSplitGeocoderStringService"}, {"original_string": "@Autowired\n\tprivate CombineUnionService defaultCombineResultService;", "modifier": "@Autowired\n\tprivate", "type": "CombineUnionService", "declarator": "defaultCombineResultService", "var_name": "defaultCombineResultService"}, {"original_string": "@Autowired\n\tprivate DtoConverterService dtoConverterService;", "modifier": "@Autowired\n\tprivate", "type": "DtoConverterService", "declarator": "dtoConverterService", "var_name": "dtoConverterService"}, {"original_string": "@Autowired\n\tprivate GeocoderUtilService geocoderUtilService;", "modifier": "@Autowired\n\tprivate", "type": "GeocoderUtilService", "declarator": "geocoderUtilService", "var_name": "geocoderUtilService"}, {"original_string": "@Autowired\n\tprivate GeoService geoService;", "modifier": "@Autowired\n\tprivate", "type": "GeoService", "declarator": "geoService", "var_name": "geoService"}], "methods": [{"identifier": "getEmptyCommandRequest", "parameters": "()", "modifiers": "@Override public", "return": "GetLocationForStringRequest", "signature": "GetLocationForStringRequest getEmptyCommandRequest()", "full_signature": "@Override public GetLocationForStringRequest getEmptyCommandRequest()", "class_method_signature": "GetLocationForStringCommand.getEmptyCommandRequest()", "testcase": false, "constructor": false}, {"identifier": "getEmptyCommandResponse", "parameters": "()", "modifiers": "@Override public", "return": "GetLocationForStringResponse", "signature": "GetLocationForStringResponse getEmptyCommandResponse()", "full_signature": "@Override public GetLocationForStringResponse getEmptyCommandResponse()", "class_method_signature": "GetLocationForStringCommand.getEmptyCommandResponse()", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "(GetLocationForStringRequest request, GetLocationForStringResponse response)", "modifiers": "@Override public", "return": "void", "signature": "void execute(GetLocationForStringRequest request, GetLocationForStringResponse response)", "full_signature": "@Override public void execute(GetLocationForStringRequest request, GetLocationForStringResponse response)", "class_method_signature": "GetLocationForStringCommand.execute(GetLocationForStringRequest request, GetLocationForStringResponse response)", "testcase": false, "constructor": false}, {"identifier": "getShouldUsePattern", "parameters": "(String namePattern)", "modifiers": "private", "return": "Pattern", "signature": "Pattern getShouldUsePattern(String namePattern)", "full_signature": "private Pattern getShouldUsePattern(String namePattern)", "class_method_signature": "GetLocationForStringCommand.getShouldUsePattern(String namePattern)", "testcase": false, "constructor": false}, {"identifier": "shouldUse", "parameters": "(Pattern namePattern, String serviceName)", "modifiers": "private", "return": "boolean", "signature": "boolean shouldUse(Pattern namePattern, String serviceName)", "full_signature": "private boolean shouldUse(Pattern namePattern, String serviceName)", "class_method_signature": "GetLocationForStringCommand.shouldUse(Pattern namePattern, String serviceName)", "testcase": false, "constructor": false}], "file": "plugin/geocoder/geocoder/src/main/java/org/geomajas/plugin/geocoder/command/geocoder/GetLocationForStringCommand.java"}, "focal_method": {"identifier": "execute", "parameters": "(GetLocationForStringRequest request, GetLocationForStringResponse response)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void execute(GetLocationForStringRequest request, GetLocationForStringResponse response) throws Exception {\n\t\tString location = request.getLocation();\n\t\tif (null == location) {\n\t\t\tthrow new GeomajasException(ExceptionCode.PARAMETER_MISSING, \"location\");\n\t\t}\n\t\tString crsString = request.getCrs();\n\t\tif (null == crsString) {\n\t\t\tthrow new GeomajasException(ExceptionCode.PARAMETER_MISSING, \"crs\");\n\t\t}\n\t\tLocale locale = null;\n\t\tif (null != request.getLocale()) {\n\t\t\tlocale = new Locale(request.getLocale());\n\t\t}\n\t\tint maxAlternatives = request.getMaxAlternatives();\n\n\t\tCrs crs = geoService.getCrs2(crsString);\n\n\t\tSplitGeocoderStringService splitGeocoderStringService = geocoderInfo.getSplitGeocoderStringService();\n\t\tif (null == splitGeocoderStringService) {\n\t\t\tsplitGeocoderStringService = defaultSplitGeocoderStringService;\n\t\t}\n\t\tCombineResultService combineResultService = geocoderInfo.getCombineResultService();\n\t\tif (null == combineResultService) {\n\t\t\tcombineResultService = defaultCombineResultService;\n\t\t}\n\n\t\tList<String> locationList = splitGeocoderStringService.split(location);\n\n\t\tList<GetLocationResult> results = new ArrayList<GetLocationResult>();\n\t\tList<GetLocationResult[]> alternatives = new ArrayList<GetLocationResult[]>();\n\t\tPattern namePattern = getShouldUsePattern(request.getServicePattern());\n\t\tfor (GeocoderService geocoderService : geocoderInfo.getGeocoderServices()) {\n\t\t\tif (shouldUse(namePattern, geocoderService.getName())) {\n\t\t\t\tGetLocationResult[] result = geocoderService.getLocation(locationList, maxAlternatives, locale);\n\t\t\t\tif (null != result && result.length > 0) {\n\t\t\t\t\tfor (GetLocationResult aResult : result) {\n\t\t\t\t\t\taResult.setGeocoderName(geocoderService.getName());\n\n\t\t\t\t\t\tCoordinateReferenceSystem sourceCrs = geocoderService.getCrs();\n\t\t\t\t\t\tEnvelope envelope = aResult.getEnvelope();\n\n\t\t\t\t\t\t// point locations needs to converted to an area based on configuration settings\n\t\t\t\t\t\tif (null == envelope) {\n\t\t\t\t\t\t\tenvelope = geocoderUtilService.extendPoint(aResult.getCoordinate(), sourceCrs,\n\t\t\t\t\t\t\t\t\tgeocoderInfo.getPointDisplayWidth(), geocoderInfo.getPointDisplayHeight());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// result needs to be CRS transformed to request CRS\n\t\t\t\t\t\taResult.setEnvelope(geocoderUtilService.transform(envelope, sourceCrs, crs));\n\t\t\t\t\t}\n\t\t\t\t\tif (result.length > 1) {\n\t\t\t\t\t\talternatives.add(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresults.add(result[0]);\n\t\t\t\t\t}\n\t\t\t\t\tif (!geocoderInfo.isLoopAllServices()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresponse.setLocationFound(false);\n\t\tif (!results.isEmpty()) {\n\t\t\tresponse.setLocationFound(true);\n\n\t\t\t// combine match strings, default to search string unless we know we can do better\n\t\t\tString matchedLocation = location;\n\t\t\tString geocoderName = null;\n\t\t\tif (results.size() == 1) {\n\t\t\t\tList<String> matchedStrings = results.get(0).getCanonicalStrings();\n\t\t\t\tif (null != matchedStrings) {\n\t\t\t\t\tmatchedLocation = splitGeocoderStringService.combine(matchedStrings);\n\t\t\t\t}\n\t\t\t\tgeocoderName = results.get(0).getGeocoderName();\n\t\t\t}\n\t\t\tresponse.setCanonicalLocation(matchedLocation);\n\t\t\tresponse.setGeocoderName(geocoderName);\n\n\t\t\t// combine the user data, only when there is just one result\n\t\t\tif (results.size() == 1) {\n\t\t\t\tresponse.setUserData(results.get(0).getUserData());\n\t\t\t}\n\n\t\t\t// combine location envelopes\n\t\t\tEnvelope resultEnvelope = combineResultService.combine(results);\n\t\t\tBbox bbox = dtoConverterService.toDto(resultEnvelope);\n\t\t\tresponse.setBbox(bbox);\n\t\t\tresponse.setCenter(new Coordinate(bbox.getX() + bbox.getWidth() / 2, bbox.getY() + bbox.getHeight() / 2));\n\t\t} else {\n\t\t\tList<GetLocationForStringAlternative> altList = new ArrayList<GetLocationForStringAlternative>();\n\t\t\tresponse.setAlternatives(altList);\n\t\t\tfor (GetLocationResult[] altArr : alternatives) {\n\t\t\t\tfor (GetLocationResult alt : altArr) {\n\t\t\t\t\tif (maxAlternatives > 0 && maxAlternatives <= altList.size()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tGetLocationForStringAlternative one = new GetLocationForStringAlternative();\n\n\t\t\t\t\tString matchedLocation = location;\n\t\t\t\t\tList<String> matchedStrings = alt.getCanonicalStrings();\n\t\t\t\t\tif (null != matchedStrings) {\n\t\t\t\t\t\tmatchedLocation = splitGeocoderStringService.combine(matchedStrings);\n\t\t\t\t\t}\n\t\t\t\t\tone.setCanonicalLocation(matchedLocation);\n\n\t\t\t\t\t// set additional info data\n\t\t\t\t\tone.setGeocoderName(alt.getGeocoderName());\n\t\t\t\t\tone.setUserData(alt.getUserData());\n\n\t\t\t\t\t// combine location envelopes\n\t\t\t\t\tBbox bbox = dtoConverterService.toDto(alt.getEnvelope());\n\t\t\t\t\tone.setBbox(bbox);\n\t\t\t\t\tone.setCenter(\n\t\t\t\t\t\t\tnew Coordinate(bbox.getX() + bbox.getWidth() / 2, bbox.getY() + bbox.getHeight() / 2));\n\n\t\t\t\t\taltList.add(one);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}", "signature": "void execute(GetLocationForStringRequest request, GetLocationForStringResponse response)", "full_signature": "@Override public void execute(GetLocationForStringRequest request, GetLocationForStringResponse response)", "class_method_signature": "GetLocationForStringCommand.execute(GetLocationForStringRequest request, GetLocationForStringResponse response)", "testcase": false, "constructor": false, "invocations": ["getLocation", "getCrs", "getLocale", "getLocale", "getMaxAlternatives", "getCrs2", "getSplitGeocoderStringService", "getCombineResultService", "split", "getShouldUsePattern", "getServicePattern", "getGeocoderServices", "shouldUse", "getName", "getLocation", "setGeocoderName", "getName", "getCrs", "getEnvelope", "extendPoint", "getCoordinate", "getPointDisplayWidth", "getPointDisplayHeight", "setEnvelope", "transform", "add", "add", "isLoopAllServices", "setLocationFound", "isEmpty", "setLocationFound", "size", "getCanonicalStrings", "get", "combine", "getGeocoderName", "get", "setCanonicalLocation", "setGeocoderName", "size", "setUserData", "getUserData", "get", "combine", "toDto", "setBbox", "setCenter", "getX", "getWidth", "getY", "getHeight", "setAlternatives", "size", "getCanonicalStrings", "combine", "setCanonicalLocation", "setGeocoderName", "getGeocoderName", "setUserData", "getUserData", "toDto", "getEnvelope", "setBbox", "setCenter", "getX", "getWidth", "getY", "getHeight", "add"]}, "repository": {"repo_id": 14505280, "url": "https://github.com/geomajas/geomajas-project-server", "language": "Java", "is_fork": false, "fork_count": 15, "stargazer_count": 13, "size": 124882, "license": "licensed"}}