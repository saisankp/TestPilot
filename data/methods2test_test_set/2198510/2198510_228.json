{"test_class": {"identifier": "TestChannelProcessor", "superclass": "", "interfaces": "", "fields": [], "file": "flume-ng-core/src/test/java/org/apache/flume/channel/TestChannelProcessor.java"}, "test_case": {"identifier": "testNullFromGetTransaction", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testNullFromGetTransaction() {\n    // channel which returns null from getTransaction()\n    Channel ch = mock(Channel.class);\n    when(ch.getTransaction()).thenReturn(null);\n\n    ChannelSelector sel = new ReplicatingChannelSelector();\n    sel.setChannels(Lists.newArrayList(ch));\n    ChannelProcessor proc = new ChannelProcessor(sel);\n\n    List<Event> events = Lists.newArrayList();\n    events.add(EventBuilder.withBody(\"event 1\", Charsets.UTF_8));\n\n    boolean threw = false;\n    try {\n      proc.processEventBatch(events);\n    } catch (NullPointerException ex) {\n      threw = true;\n      Assert.assertNotNull(\"NPE must be manually thrown\", ex.getMessage());\n    }\n    Assert.assertTrue(\"Must throw NPE\", threw);\n  }", "signature": "void testNullFromGetTransaction()", "full_signature": "@Test public void testNullFromGetTransaction()", "class_method_signature": "TestChannelProcessor.testNullFromGetTransaction()", "testcase": true, "constructor": false, "invocations": ["mock", "thenReturn", "when", "getTransaction", "setChannels", "newArrayList", "newArrayList", "add", "withBody", "processEventBatch", "assertNotNull", "getMessage", "assertTrue"]}, "focal_class": {"identifier": "ChannelProcessor", "superclass": "", "interfaces": "implements Configurable", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(\n      ChannelProcessor.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(\n      ChannelProcessor.class)", "var_name": "LOG"}, {"original_string": "private final ChannelSelector selector;", "modifier": "private final", "type": "ChannelSelector", "declarator": "selector", "var_name": "selector"}, {"original_string": "private final InterceptorChain interceptorChain;", "modifier": "private final", "type": "InterceptorChain", "declarator": "interceptorChain", "var_name": "interceptorChain"}], "methods": [{"identifier": "ChannelProcessor", "parameters": "(ChannelSelector selector)", "modifiers": "public", "return": "", "signature": " ChannelProcessor(ChannelSelector selector)", "full_signature": "public  ChannelProcessor(ChannelSelector selector)", "class_method_signature": "ChannelProcessor.ChannelProcessor(ChannelSelector selector)", "testcase": false, "constructor": true}, {"identifier": "initialize", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void initialize()", "full_signature": "public void initialize()", "class_method_signature": "ChannelProcessor.initialize()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "ChannelProcessor.close()", "testcase": false, "constructor": false}, {"identifier": "configure", "parameters": "(Context context)", "modifiers": "@Override public", "return": "void", "signature": "void configure(Context context)", "full_signature": "@Override public void configure(Context context)", "class_method_signature": "ChannelProcessor.configure(Context context)", "testcase": false, "constructor": false}, {"identifier": "configureInterceptors", "parameters": "(Context context)", "modifiers": "private", "return": "void", "signature": "void configureInterceptors(Context context)", "full_signature": "private void configureInterceptors(Context context)", "class_method_signature": "ChannelProcessor.configureInterceptors(Context context)", "testcase": false, "constructor": false}, {"identifier": "getSelector", "parameters": "()", "modifiers": "public", "return": "ChannelSelector", "signature": "ChannelSelector getSelector()", "full_signature": "public ChannelSelector getSelector()", "class_method_signature": "ChannelProcessor.getSelector()", "testcase": false, "constructor": false}, {"identifier": "processEventBatch", "parameters": "(List<Event> events)", "modifiers": "public", "return": "void", "signature": "void processEventBatch(List<Event> events)", "full_signature": "public void processEventBatch(List<Event> events)", "class_method_signature": "ChannelProcessor.processEventBatch(List<Event> events)", "testcase": false, "constructor": false}, {"identifier": "processEvent", "parameters": "(Event event)", "modifiers": "public", "return": "void", "signature": "void processEvent(Event event)", "full_signature": "public void processEvent(Event event)", "class_method_signature": "ChannelProcessor.processEvent(Event event)", "testcase": false, "constructor": false}], "file": "flume-ng-core/src/main/java/org/apache/flume/channel/ChannelProcessor.java"}, "focal_method": {"identifier": "processEventBatch", "parameters": "(List<Event> events)", "modifiers": "public", "return": "void", "body": "public void processEventBatch(List<Event> events) {\n    Preconditions.checkNotNull(events, \"Event list must not be null\");\n\n    events = interceptorChain.intercept(events);\n\n    Map<Channel, List<Event>> reqChannelQueue =\n        new LinkedHashMap<Channel, List<Event>>();\n\n    Map<Channel, List<Event>> optChannelQueue =\n        new LinkedHashMap<Channel, List<Event>>();\n\n    for (Event event : events) {\n      List<Channel> reqChannels = selector.getRequiredChannels(event);\n\n      for (Channel ch : reqChannels) {\n        List<Event> eventQueue = reqChannelQueue.get(ch);\n        if (eventQueue == null) {\n          eventQueue = new ArrayList<Event>();\n          reqChannelQueue.put(ch, eventQueue);\n        }\n        eventQueue.add(event);\n      }\n\n      List<Channel> optChannels = selector.getOptionalChannels(event);\n\n      for (Channel ch : optChannels) {\n        List<Event> eventQueue = optChannelQueue.get(ch);\n        if (eventQueue == null) {\n          eventQueue = new ArrayList<Event>();\n          optChannelQueue.put(ch, eventQueue);\n        }\n\n        eventQueue.add(event);\n      }\n    }\n\n    // Process required channels\n    for (Channel reqChannel : reqChannelQueue.keySet()) {\n      Transaction tx = reqChannel.getTransaction();\n      Preconditions.checkNotNull(tx, \"Transaction object must not be null\");\n      try {\n        tx.begin();\n\n        List<Event> batch = reqChannelQueue.get(reqChannel);\n\n        for (Event event : batch) {\n          reqChannel.put(event);\n        }\n\n        tx.commit();\n      } catch (Throwable t) {\n        tx.rollback();\n        if (t instanceof Error) {\n          LOG.error(\"Error while writing to required channel: \" + reqChannel, t);\n          throw (Error) t;\n        } else if (t instanceof ChannelException) {\n          throw (ChannelException) t;\n        } else {\n          throw new ChannelException(\"Unable to put batch on required \" +\n              \"channel: \" + reqChannel, t);\n        }\n      } finally {\n        if (tx != null) {\n          tx.close();\n        }\n      }\n    }\n\n    // Process optional channels\n    for (Channel optChannel : optChannelQueue.keySet()) {\n      Transaction tx = optChannel.getTransaction();\n      Preconditions.checkNotNull(tx, \"Transaction object must not be null\");\n      try {\n        tx.begin();\n\n        List<Event> batch = optChannelQueue.get(optChannel);\n\n        for (Event event : batch) {\n          optChannel.put(event);\n        }\n\n        tx.commit();\n      } catch (Throwable t) {\n        tx.rollback();\n        LOG.error(\"Unable to put batch on optional channel: \" + optChannel, t);\n        if (t instanceof Error) {\n          throw (Error) t;\n        }\n      } finally {\n        if (tx != null) {\n          tx.close();\n        }\n      }\n    }\n  }", "signature": "void processEventBatch(List<Event> events)", "full_signature": "public void processEventBatch(List<Event> events)", "class_method_signature": "ChannelProcessor.processEventBatch(List<Event> events)", "testcase": false, "constructor": false, "invocations": ["checkNotNull", "intercept", "getRequiredChannels", "get", "put", "add", "getOptionalChannels", "get", "put", "add", "keySet", "getTransaction", "checkNotNull", "begin", "get", "put", "commit", "rollback", "error", "close", "keySet", "getTransaction", "checkNotNull", "begin", "get", "put", "commit", "rollback", "error", "close"]}, "repository": {"repo_id": 2198510, "url": "https://github.com/apache/flume", "language": "Java", "is_fork": false, "fork_count": 1372, "stargazer_count": 1971, "size": 44377, "license": "licensed"}}