{"test_class": {"identifier": "NumberUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "dexlib2/src/test/java/org/jf/util/NumberUtilsTest.java"}, "test_case": {"identifier": "isLikelyFloatTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void isLikelyFloatTest() {\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(1.23f)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(1.0f)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(Float.NaN)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(Float.NEGATIVE_INFINITY)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(Float.POSITIVE_INFINITY)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(1e-30f)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(1000f)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(1f)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(-1f)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(-5f)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(1.3333f)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(4.5f)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(.1f)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(50000f)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(Float.MAX_VALUE)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits((float)Math.PI)));\n        Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits((float)Math.E)));\n\n        Assert.assertTrue(NumberUtils.isLikelyFloat(2139095039));\n\n\n        // Float.MIN_VALUE is equivalent to integer value 1 - this should be detected as an integer\n        //Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(Float.MIN_VALUE)));\n\n        // This one doesn't quite work. It has a series of 2 0's, but that is probably not enough to strip off normally\n        //Assert.assertTrue(NumberUtils.isLikelyFloat(Float.floatToRawIntBits(1.33333f)));\n\n        Assert.assertFalse(NumberUtils.isLikelyFloat(0));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(1));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(10));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(100));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(1000));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(1024));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(1234));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(-5));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(-13));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(-123));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(20000000));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(2000000000));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(-2000000000));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(Integer.MAX_VALUE));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(Integer.MIN_VALUE));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(Short.MIN_VALUE));\n        Assert.assertFalse(NumberUtils.isLikelyFloat(Short.MAX_VALUE));\n    }", "signature": "void isLikelyFloatTest()", "full_signature": "@Test public void isLikelyFloatTest()", "class_method_signature": "NumberUtilsTest.isLikelyFloatTest()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "floatToRawIntBits", "assertTrue", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat", "assertFalse", "isLikelyFloat"]}, "focal_class": {"identifier": "NumberUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int canonicalFloatNaN = Float.floatToRawIntBits(Float.NaN);", "modifier": "private static final", "type": "int", "declarator": "canonicalFloatNaN = Float.floatToRawIntBits(Float.NaN)", "var_name": "canonicalFloatNaN"}, {"original_string": "private static final int maxFloat = Float.floatToRawIntBits(Float.MAX_VALUE);", "modifier": "private static final", "type": "int", "declarator": "maxFloat = Float.floatToRawIntBits(Float.MAX_VALUE)", "var_name": "maxFloat"}, {"original_string": "private static final int piFloat = Float.floatToRawIntBits((float)Math.PI);", "modifier": "private static final", "type": "int", "declarator": "piFloat = Float.floatToRawIntBits((float)Math.PI)", "var_name": "piFloat"}, {"original_string": "private static final int eFloat = Float.floatToRawIntBits((float)Math.E);", "modifier": "private static final", "type": "int", "declarator": "eFloat = Float.floatToRawIntBits((float)Math.E)", "var_name": "eFloat"}, {"original_string": "private static final long canonicalDoubleNaN = Double.doubleToRawLongBits(Double.NaN);", "modifier": "private static final", "type": "long", "declarator": "canonicalDoubleNaN = Double.doubleToRawLongBits(Double.NaN)", "var_name": "canonicalDoubleNaN"}, {"original_string": "private static final long maxDouble = Double.doubleToLongBits(Double.MAX_VALUE);", "modifier": "private static final", "type": "long", "declarator": "maxDouble = Double.doubleToLongBits(Double.MAX_VALUE)", "var_name": "maxDouble"}, {"original_string": "private static final long piDouble = Double.doubleToLongBits(Math.PI);", "modifier": "private static final", "type": "long", "declarator": "piDouble = Double.doubleToLongBits(Math.PI)", "var_name": "piDouble"}, {"original_string": "private static final long eDouble = Double.doubleToLongBits(Math.E);", "modifier": "private static final", "type": "long", "declarator": "eDouble = Double.doubleToLongBits(Math.E)", "var_name": "eDouble"}, {"original_string": "private static final DecimalFormat format = new DecimalFormat(\"0.####################E0\");", "modifier": "private static final", "type": "DecimalFormat", "declarator": "format = new DecimalFormat(\"0.####################E0\")", "var_name": "format"}], "methods": [{"identifier": "isLikelyFloat", "parameters": "(int value)", "modifiers": "public static", "return": "boolean", "signature": "boolean isLikelyFloat(int value)", "full_signature": "public static boolean isLikelyFloat(int value)", "class_method_signature": "NumberUtils.isLikelyFloat(int value)", "testcase": false, "constructor": false}, {"identifier": "isLikelyDouble", "parameters": "(long value)", "modifiers": "public static", "return": "boolean", "signature": "boolean isLikelyDouble(long value)", "full_signature": "public static boolean isLikelyDouble(long value)", "class_method_signature": "NumberUtils.isLikelyDouble(long value)", "testcase": false, "constructor": false}], "file": "dexlib2/src/main/java/org/jf/util/NumberUtils.java"}, "focal_method": {"identifier": "isLikelyFloat", "parameters": "(int value)", "modifiers": "public static", "return": "boolean", "body": "public static boolean isLikelyFloat(int value) {\n        // Check for some common named float values\n        // We don't check for Float.MIN_VALUE, which has an integer representation of 1\n        if (value == canonicalFloatNaN ||\n                value == maxFloat ||\n                value == piFloat ||\n                value == eFloat) {\n            return true;\n        }\n\n        // Check for some named integer values\n        if (value == Integer.MAX_VALUE || value == Integer.MIN_VALUE) {\n            return false;\n        }\n\n\n        // Check for likely resource id\n        int packageId = value >> 24;\n        int resourceType = value >> 16 & 0xff;\n        int resourceId = value & 0xffff;\n        if ((packageId == 0x7f || packageId == 1) && resourceType < 0x1f && resourceId < 0xfff) {\n            return false;\n        }\n\n        // a non-canocical NaN is more likely to be an integer\n        float floatValue = Float.intBitsToFloat(value);\n        if (Float.isNaN(floatValue)) {\n            return false;\n        }\n\n        // Otherwise, whichever has a shorter scientific notation representation is more likely.\n        // Integer wins the tie\n        String asInt = format.format(value);\n        String asFloat = format.format(floatValue);\n\n        // try to strip off any small imprecision near the end of the mantissa\n        int decimalPoint = asFloat.indexOf('.');\n        int exponent = asFloat.indexOf(\"E\");\n        int zeros = asFloat.indexOf(\"000\");\n        if (zeros > decimalPoint && zeros < exponent) {\n            asFloat = asFloat.substring(0, zeros) + asFloat.substring(exponent);\n        } else {\n            int nines = asFloat.indexOf(\"999\");\n            if (nines > decimalPoint && nines < exponent) {\n                asFloat = asFloat.substring(0, nines) + asFloat.substring(exponent);\n            }\n        }\n\n        return asFloat.length() < asInt.length();\n    }", "signature": "boolean isLikelyFloat(int value)", "full_signature": "public static boolean isLikelyFloat(int value)", "class_method_signature": "NumberUtils.isLikelyFloat(int value)", "testcase": false, "constructor": false, "invocations": ["intBitsToFloat", "isNaN", "format", "format", "indexOf", "indexOf", "indexOf", "substring", "substring", "indexOf", "substring", "substring", "length", "length"]}, "repository": {"repo_id": 5925560, "url": "https://github.com/JesusFreke/smali", "language": "Java", "is_fork": false, "fork_count": 875, "stargazer_count": 4465, "size": 9375, "license": "licensed"}}