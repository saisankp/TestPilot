{"test_class": {"identifier": "GSMCharsetTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(GSMCharsetTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(GSMCharsetTest.class)", "var_name": "logger"}], "file": "ch-commons-charset/src/test/java/com/cloudhopper/commons/charset/GSMCharsetTest.java"}, "test_case": {"identifier": "canRepresent", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void canRepresent() throws Exception {\n        // nulls are always ok\n        Assert.assertEquals(true, GSMCharset.canRepresent(null));\n        Assert.assertEquals(true, GSMCharset.canRepresent(\" \"));\n        Assert.assertEquals(true, GSMCharset.canRepresent(\"\\n\\r\"));\n        Assert.assertEquals(true, GSMCharset.canRepresent(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"));\n        Assert.assertEquals(true, GSMCharset.canRepresent(\"Hello @ World\"));\n        Assert.assertEquals(true, GSMCharset.canRepresent(\"{}[]$\"));\n        // euro currency symbol is good\n        Assert.assertEquals(true, GSMCharset.canRepresent(\"\\u20ac\"));\n        // arabic char is not valid GSM char\n        Assert.assertEquals(false, GSMCharset.canRepresent(\"\\u0623\"));\n        // bug found with A-z if statement in previous charset\n        // 1 char in-between the upper-case and lower-case snuck in the\n        // simple range check -- the '`' char is NOT in the GSM charset\n        Assert.assertEquals(false, GSMCharset.canRepresent(\"`\"));\n        Assert.assertEquals(true, GSMCharset.canRepresent(\"[\\\\]^_\"));\n        // form feed: uncommon but technically part of the spec\n        Assert.assertEquals(true, GSMCharset.canRepresent(\"\\f\"));\n        \n        // create a fully correct string from lookup tables\n        // strings to decode/encode to/from UTF-8\n        // build a string of every GSM char\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < GSMCharset.CHAR_TABLE.length; i++) {\n            char c = GSMCharset.CHAR_TABLE[i];\n            if (c > 0) {\n                s.append(c);\n            }\n        }\n        for (int i = 0; i < GSMCharset.EXT_CHAR_TABLE.length; i++) {\n            char c = GSMCharset.EXT_CHAR_TABLE[i];\n            if (c > 0) {\n                s.append(c);\n            }\n        }\n        \n        Assert.assertEquals(true, GSMCharset.canRepresent(s.toString()));\n    }", "signature": "void canRepresent()", "full_signature": "@Test public void canRepresent()", "class_method_signature": "GSMCharsetTest.canRepresent()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "canRepresent", "assertEquals", "canRepresent", "assertEquals", "canRepresent", "assertEquals", "canRepresent", "assertEquals", "canRepresent", "assertEquals", "canRepresent", "assertEquals", "canRepresent", "assertEquals", "canRepresent", "assertEquals", "canRepresent", "assertEquals", "canRepresent", "assertEquals", "canRepresent", "append", "append", "assertEquals", "canRepresent", "toString"]}, "focal_class": {"identifier": "GSMCharset", "superclass": "extends BaseCharset", "interfaces": "", "fields": [{"original_string": "public static final int EXTENDED_ESCAPE = 0x1b;", "modifier": "public static final", "type": "int", "declarator": "EXTENDED_ESCAPE = 0x1b", "var_name": "EXTENDED_ESCAPE"}, {"original_string": "public static final int PAGE_BREAK = 0x0a;", "modifier": "public static final", "type": "int", "declarator": "PAGE_BREAK = 0x0a", "var_name": "PAGE_BREAK"}, {"original_string": "public static final char[] CHAR_TABLE = {\n        '@', '\\u00a3', '$', '\\u00a5', '\\u00e8', '\\u00e9', '\\u00f9', '\\u00ec',\n        '\\u00f2', '\\u00c7', '\\n', '\\u00d8', '\\u00f8', '\\r', '\\u00c5', '\\u00e5',\n        '\\u0394', '_', '\\u03a6', '\\u0393', '\\u039b', '\\u03a9', '\\u03a0', '\\u03a8',\n        '\\u03a3', '\\u0398', '\\u039e', ' ', '\\u00c6', '\\u00e6', '\\u00df', '\\u00c9',  // 0x1B is actually an escape which we'll encode to a space char\n        ' ', '!', '\"', '#', '\\u00a4', '%', '&', '\\'',\n        '(', ')', '*', '+', ',', '-', '.', '/',\n        '0', '1', '2', '3', '4', '5', '6', '7',\n        '8', '9', ':', ';', '<', '=', '>', '?',\n        '\\u00a1', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n        'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n        'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',\n        'X', 'Y', 'Z', '\\u00c4', '\\u00d6', '\\u00d1', '\\u00dc', '\\u00a7',\n        '\\u00bf', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\n        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n        'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\n        'x', 'y', 'z', '\\u00e4', '\\u00f6', '\\u00f1', '\\u00fc', '\\u00e0',\n    };", "modifier": "public static final", "type": "char[]", "declarator": "CHAR_TABLE = {\n        '@', '\\u00a3', '$', '\\u00a5', '\\u00e8', '\\u00e9', '\\u00f9', '\\u00ec',\n        '\\u00f2', '\\u00c7', '\\n', '\\u00d8', '\\u00f8', '\\r', '\\u00c5', '\\u00e5',\n        '\\u0394', '_', '\\u03a6', '\\u0393', '\\u039b', '\\u03a9', '\\u03a0', '\\u03a8',\n        '\\u03a3', '\\u0398', '\\u039e', ' ', '\\u00c6', '\\u00e6', '\\u00df', '\\u00c9',  // 0x1B is actually an escape which we'll encode to a space char\n        ' ', '!', '\"', '#', '\\u00a4', '%', '&', '\\'',\n        '(', ')', '*', '+', ',', '-', '.', '/',\n        '0', '1', '2', '3', '4', '5', '6', '7',\n        '8', '9', ':', ';', '<', '=', '>', '?',\n        '\\u00a1', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n        'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n        'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',\n        'X', 'Y', 'Z', '\\u00c4', '\\u00d6', '\\u00d1', '\\u00dc', '\\u00a7',\n        '\\u00bf', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\n        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n        'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\n        'x', 'y', 'z', '\\u00e4', '\\u00f6', '\\u00f1', '\\u00fc', '\\u00e0',\n    }", "var_name": "CHAR_TABLE"}, {"original_string": "public static final char[] EXT_CHAR_TABLE = {\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, '\\f', 0, 0, 0, 0, 0,\n            0, 0, 0, 0, '^', 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            '{', '}', 0, 0, 0, 0, 0, '\\\\',\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, '[', '~', ']', 0,\n            '|', 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, '\\u20ac', 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n    };", "modifier": "public static final", "type": "char[]", "declarator": "EXT_CHAR_TABLE = {\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, '\\f', 0, 0, 0, 0, 0,\n            0, 0, 0, 0, '^', 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            '{', '}', 0, 0, 0, 0, 0, '\\\\',\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, '[', '~', ']', 0,\n            '|', 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, '\\u20ac', 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0,\n    }", "var_name": "EXT_CHAR_TABLE"}], "methods": [{"identifier": "canRepresent", "parameters": "(CharSequence str0)", "modifiers": "static public", "return": "boolean", "signature": "boolean canRepresent(CharSequence str0)", "full_signature": "static public boolean canRepresent(CharSequence str0)", "class_method_signature": "GSMCharset.canRepresent(CharSequence str0)", "testcase": false, "constructor": false}, {"identifier": "estimateEncodeByteLength", "parameters": "(CharSequence str0)", "modifiers": "@Override public", "return": "int", "signature": "int estimateEncodeByteLength(CharSequence str0)", "full_signature": "@Override public int estimateEncodeByteLength(CharSequence str0)", "class_method_signature": "GSMCharset.estimateEncodeByteLength(CharSequence str0)", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(CharSequence str0)", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] encode(CharSequence str0)", "full_signature": "@Override public byte[] encode(CharSequence str0)", "class_method_signature": "GSMCharset.encode(CharSequence str0)", "testcase": false, "constructor": false}, {"identifier": "estimateDecodeCharLength", "parameters": "(byte[] bytes)", "modifiers": "@Override public", "return": "int", "signature": "int estimateDecodeCharLength(byte[] bytes)", "full_signature": "@Override public int estimateDecodeCharLength(byte[] bytes)", "class_method_signature": "GSMCharset.estimateDecodeCharLength(byte[] bytes)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(byte[] bytes, StringBuilder buffer)", "modifiers": "@Override public", "return": "void", "signature": "void decode(byte[] bytes, StringBuilder buffer)", "full_signature": "@Override public void decode(byte[] bytes, StringBuilder buffer)", "class_method_signature": "GSMCharset.decode(byte[] bytes, StringBuilder buffer)", "testcase": false, "constructor": false}], "file": "ch-commons-charset/src/main/java/com/cloudhopper/commons/charset/GSMCharset.java"}, "focal_method": {"identifier": "canRepresent", "parameters": "(CharSequence str0)", "modifiers": "static public", "return": "boolean", "body": "static public boolean canRepresent(CharSequence str0) {\n        if (str0 == null) {\n            return true;\n        }\n\n        int len = str0.length();\n        for (int i = 0; i < len; i++) {\n            // get the char in this string\n            char c = str0.charAt(i);\n            // simple range checks for most common characters (0x20 -> 0x5F) or (0x61 -> 0x7E)\n            if ((c >= ' ' && c <= '_') || (c >= 'a' && c <= '~')) {\n                continue;\n            } else {\n                // 10X more efficient using a switch statement vs. a lookup table search\n                switch (c) {\n                    case '\\u00A3':\t// \u00a3\n                    case '\\u00A5':\t// \u00a5\n                    case '\\u00E8':\t// \u00e8\n                    case '\\u00E9':\t// \u00e9\n                    case '\\u00F9':\t// \u00f9\n                    case '\\u00EC':\t// \u00ec\n                    case '\\u00F2':\t// \u00f2\n                    case '\\u00C7':\t// \u00c7\n                    case '\\n':          // newline\n                    case '\\u00D8':\t// \u00d8\n                    case '\\u00F8':\t// \u00f8\n                    case '\\r':          // carriage return\n                    case '\\u000c':      // form feed\n                    case '\\u00C5':\t// \u00c5\n                    case '\\u00E5':\t// \u00e5\n                    case '\\u0394':\t// \u0394\n                    case '\\u03A6':\t// \u03a6\n                    case '\\u0393':\t// \u0393\n                    case '\\u039B':\t// \u039b\n                    case '\\u03A9':\t// \u03a9\n                    case '\\u03A0':\t// \u03a0\n                    case '\\u03A8':\t// \u03a8\n                    case '\\u03A3':\t// \u03a3\n                    case '\\u0398':\t// \u0398\n                    case '\\u039E':\t// \u039e\n                    case '\\u00C6':\t// \u00c6\n                    case '\\u00E6':\t// \u00e6\n                    case '\\u00DF':\t// \u00df\n                    case '\\u00C9':\t// \u00c9\n                    case '\\u00A4':\t// \u00a4\n                    case '\\u00A1':\t// \u00a1\n                    case '\\u00C4':\t// \u00c4\n                    case '\\u00D6':\t// \u00d6\n                    case '\\u00D1':\t// \u00d1\n                    case '\\u00DC':\t// \u00dc\n                    case '\\u00A7':\t// \u00a7\n                    case '\\u00BF':\t// \u00bf\n                    case '\\u00E4':\t// \u00e4\n                    case '\\u00F6':\t// \u00f6\n                    case '\\u00F1':\t// \u00f1\n                    case '\\u00FC':\t// \u00fc\n                    case '\\u00E0':\t// \u00e0\n                    case '\\u20AC':\t// \u20ac\n                        continue;\n                    default:\n                        return false;\n                }\n            }\n        }\n        return true;\n    }", "signature": "boolean canRepresent(CharSequence str0)", "full_signature": "static public boolean canRepresent(CharSequence str0)", "class_method_signature": "GSMCharset.canRepresent(CharSequence str0)", "testcase": false, "constructor": false, "invocations": ["length", "charAt"]}, "repository": {"repo_id": 14960307, "url": "https://github.com/twitter/cloudhopper-commons", "language": "Java", "is_fork": false, "fork_count": 40, "stargazer_count": 36, "size": 6452, "license": "licensed"}}