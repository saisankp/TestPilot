{"test_class": {"identifier": "ContextualOutlierDetectorTest", "superclass": "", "interfaces": "", "fields": [], "file": "contrib/src/test/java/macrobase/analysis/contextualoutlier/ContextualOutlierDetectorTest.java"}, "test_case": {"identifier": "testContextualDiscreteAttribute", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testContextualDiscreteAttribute() throws Exception {\n        //construct a contextual outlier detector\n        MacroBaseConf conf = new MacroBaseConf();\n        conf.set(MacroBaseConf.METRICS, Arrays.asList(\"A1\"));\n        conf.set(MacroBaseConf.TRANSFORM_TYPE, \"MAD\");\n        List<String> contextualDiscreteAttributes = new ArrayList<String>();\n        contextualDiscreteAttributes.add(\"C1_Discrete\");\n        List<String> contextualDoubleAttributes = new ArrayList<String>();\n\n        List<String> attributes = new ArrayList<>();\n        attributes.addAll(contextualDiscreteAttributes);\n        attributes.addAll(contextualDoubleAttributes);\n\n        conf.set(MacroBaseConf.ATTRIBUTES, attributes);\n        conf.set(ContextualConf.CONTEXTUAL_DISCRETE_ATTRIBUTES, contextualDiscreteAttributes);\n        conf.set(ContextualConf.CONTEXTUAL_DOUBLE_ATTRIBUTES, contextualDoubleAttributes);\n        conf.set(ContextualConf.CONTEXTUAL_DENSECONTEXTTAU, 0.4);\n        conf.set(ContextualConf.CONTEXTUAL_NUMINTERVALS, 10);\n        conf.set(MacroBaseConf.OUTLIER_STATIC_THRESHOLD, 3.0);\n        conf.getEncoder().recordAttributeName(1, \"A1\");\n        conf.getEncoder().recordAttributeName(2, \"C1_Discrete\");\n        ContextualOutlierDetector contextualDetector = new ContextualOutlierDetector(conf);\n        List<Datum> data = new ArrayList<>();\n        for (int i = 0; i < 100; ++i) {\n            double[] sample = new double[1];\n            sample[0] = i;\n            Integer[] c1 = new Integer[1];\n            if (i < 5) {\n                c1[0] = 1;\n            } else if (i >= 5 && i < 50) {\n                c1[0] = 2;\n            } else {\n                c1[0] = 1;\n            }\n            data.add(makeDatum(conf, new ArrayList<>(), new ArrayRealVector(sample),\n                               new ArrayList<>(Arrays.asList(c1)),\n                               new ArrayRealVector()));\n        }\n\n        ContextualTransformer transformer = new ContextualTransformer(conf);\n        transformer.consume(data);\n        List<ContextualDatum> cdata = transformer.getStream().drain();\n\n        Map<Context, List<OutlierClassificationResult>> context2Outliers = contextualDetector.searchContextualOutliers(cdata);\n        TestCase.assertEquals(context2Outliers.size(), 1);\n        for (Context context : context2Outliers.keySet()) {\n            List<Interval> intervals = context.getIntervals();\n            TestCase.assertEquals(intervals.size(), 1);\n            assertEquals(intervals.get(0).getColumnName(), \"C1_Discrete\");\n            TestCase.assertEquals(intervals.get(0) instanceof IntervalDiscrete, true);\n            assertEquals(\"1\",\n                         conf.getEncoder().getAttribute(((IntervalDiscrete) intervals.get(0)).getValue()).getValue());\n        }\n    }", "signature": "void testContextualDiscreteAttribute()", "full_signature": "@Test public void testContextualDiscreteAttribute()", "class_method_signature": "ContextualOutlierDetectorTest.testContextualDiscreteAttribute()", "testcase": true, "constructor": false, "invocations": ["set", "asList", "set", "add", "addAll", "addAll", "set", "set", "set", "set", "set", "set", "recordAttributeName", "getEncoder", "recordAttributeName", "getEncoder", "add", "makeDatum", "asList", "consume", "drain", "getStream", "searchContextualOutliers", "assertEquals", "size", "keySet", "getIntervals", "assertEquals", "size", "assertEquals", "getColumnName", "get", "assertEquals", "get", "assertEquals", "getValue", "getAttribute", "getEncoder", "getValue", "get"]}, "focal_class": {"identifier": "ContextualOutlierDetector", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(ContextualOutlierDetector.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(ContextualOutlierDetector.class)", "var_name": "log"}, {"original_string": "private MacroBaseConf conf;", "modifier": "private", "type": "MacroBaseConf", "declarator": "conf", "var_name": "conf"}, {"original_string": "private List<String> contextualDiscreteAttributes;", "modifier": "private", "type": "List<String>", "declarator": "contextualDiscreteAttributes", "var_name": "contextualDiscreteAttributes"}, {"original_string": "private List<String> contextualDoubleAttributes;", "modifier": "private", "type": "List<String>", "declarator": "contextualDoubleAttributes", "var_name": "contextualDoubleAttributes"}, {"original_string": "private int totalContextualDimensions;", "modifier": "private", "type": "int", "declarator": "totalContextualDimensions", "var_name": "totalContextualDimensions"}, {"original_string": "private Context globalContext;", "modifier": "private", "type": "Context", "declarator": "globalContext", "var_name": "globalContext"}, {"original_string": "private double denseContextTau;", "modifier": "private", "type": "double", "declarator": "denseContextTau", "var_name": "denseContextTau"}, {"original_string": "private int numIntervals;", "modifier": "private", "type": "int", "declarator": "numIntervals", "var_name": "numIntervals"}, {"original_string": "private int maxPredicates;", "modifier": "private", "type": "int", "declarator": "maxPredicates", "var_name": "maxPredicates"}, {"original_string": "private DatumEncoder encoder;", "modifier": "private", "type": "DatumEncoder", "declarator": "encoder", "var_name": "encoder"}, {"original_string": "private String contextualOutputFile;", "modifier": "private", "type": "String", "declarator": "contextualOutputFile", "var_name": "contextualOutputFile"}, {"original_string": "private boolean densityPruning;", "modifier": "private", "type": "boolean", "declarator": "densityPruning", "var_name": "densityPruning"}, {"original_string": "private boolean dependencyPruning;", "modifier": "private", "type": "boolean", "declarator": "dependencyPruning", "var_name": "dependencyPruning"}, {"original_string": "private boolean distributionPruningForTraining;", "modifier": "private", "type": "boolean", "declarator": "distributionPruningForTraining", "var_name": "distributionPruningForTraining"}, {"original_string": "private boolean distributionPruningForScoring;", "modifier": "private", "type": "boolean", "declarator": "distributionPruningForScoring", "var_name": "distributionPruningForScoring"}, {"original_string": "private double alpha = 0.05;", "modifier": "private", "type": "double", "declarator": "alpha = 0.05", "var_name": "alpha"}, {"original_string": "private Map<Context, List<OutlierClassificationResult>> context2Outliers = new HashMap<>();", "modifier": "private", "type": "Map<Context, List<OutlierClassificationResult>>", "declarator": "context2Outliers = new HashMap<>()", "var_name": "context2Outliers"}, {"original_string": "private int densityPruning2 = 0;", "modifier": "private", "type": "int", "declarator": "densityPruning2 = 0", "var_name": "densityPruning2"}, {"original_string": "private int numOutlierDetectionRunsWithoutTrainingWithoutScoring = 0;", "modifier": "private", "type": "int", "declarator": "numOutlierDetectionRunsWithoutTrainingWithoutScoring = 0", "var_name": "numOutlierDetectionRunsWithoutTrainingWithoutScoring"}, {"original_string": "private int numOutlierDetectionRunsWithoutTrainingWithScoring = 0;", "modifier": "private", "type": "int", "declarator": "numOutlierDetectionRunsWithoutTrainingWithScoring = 0", "var_name": "numOutlierDetectionRunsWithoutTrainingWithScoring"}, {"original_string": "private int numOutlierDetectionRunsWithTrainingWithScoring = 0;", "modifier": "private", "type": "int", "declarator": "numOutlierDetectionRunsWithTrainingWithScoring = 0", "var_name": "numOutlierDetectionRunsWithTrainingWithScoring"}, {"original_string": "private Map<Context, BitSet> context2BitSet = new HashMap<Context, BitSet>();", "modifier": "private", "type": "Map<Context, BitSet>", "declarator": "context2BitSet = new HashMap<Context, BitSet>()", "var_name": "context2BitSet"}], "methods": [{"identifier": "ContextualOutlierDetector", "parameters": "(MacroBaseConf conf)", "modifiers": "public", "return": "", "signature": " ContextualOutlierDetector(MacroBaseConf conf)", "full_signature": "public  ContextualOutlierDetector(MacroBaseConf conf)", "class_method_signature": "ContextualOutlierDetector.ContextualOutlierDetector(MacroBaseConf conf)", "testcase": false, "constructor": true}, {"identifier": "searchContextualOutliers", "parameters": "(List<ContextualDatum> data)", "modifiers": "public", "return": "Map<Context, List<OutlierClassificationResult>>", "signature": "Map<Context, List<OutlierClassificationResult>> searchContextualOutliers(List<ContextualDatum> data)", "full_signature": "public Map<Context, List<OutlierClassificationResult>> searchContextualOutliers(List<ContextualDatum> data)", "class_method_signature": "ContextualOutlierDetector.searchContextualOutliers(List<ContextualDatum> data)", "testcase": false, "constructor": false}, {"identifier": "findInputOutliers", "parameters": "(List<ContextualDatum> data)", "modifiers": "private", "return": "List<ContextualDatum>", "signature": "List<ContextualDatum> findInputOutliers(List<ContextualDatum> data)", "full_signature": "private List<ContextualDatum> findInputOutliers(List<ContextualDatum> data)", "class_method_signature": "ContextualOutlierDetector.findInputOutliers(List<ContextualDatum> data)", "testcase": false, "constructor": false}, {"identifier": "searchContextGivenOutliers", "parameters": "(List<ContextualDatum> data)", "modifiers": "public", "return": "Map<Context, List<OutlierClassificationResult>>", "signature": "Map<Context, List<OutlierClassificationResult>> searchContextGivenOutliers(List<ContextualDatum> data)", "full_signature": "public Map<Context, List<OutlierClassificationResult>> searchContextGivenOutliers(List<ContextualDatum> data)", "class_method_signature": "ContextualOutlierDetector.searchContextGivenOutliers(List<ContextualDatum> data)", "testcase": false, "constructor": false}, {"identifier": "searchContextGivenOutliers", "parameters": "(List<ContextualDatum> data, List<ContextualDatum> inputOutliers)", "modifiers": "public", "return": "Map<Context, List<OutlierClassificationResult>>", "signature": "Map<Context, List<OutlierClassificationResult>> searchContextGivenOutliers(List<ContextualDatum> data, List<ContextualDatum> inputOutliers)", "full_signature": "public Map<Context, List<OutlierClassificationResult>> searchContextGivenOutliers(List<ContextualDatum> data, List<ContextualDatum> inputOutliers)", "class_method_signature": "ContextualOutlierDetector.searchContextGivenOutliers(List<ContextualDatum> data, List<ContextualDatum> inputOutliers)", "testcase": false, "constructor": false}, {"identifier": "randomSampling", "parameters": "(List<ContextualDatum> data, int minSampleSize)", "modifiers": "private", "return": "HashSet<ContextualDatum>", "signature": "HashSet<ContextualDatum> randomSampling(List<ContextualDatum> data, int minSampleSize)", "full_signature": "private HashSet<ContextualDatum> randomSampling(List<ContextualDatum> data, int minSampleSize)", "class_method_signature": "ContextualOutlierDetector.randomSampling(List<ContextualDatum> data, int minSampleSize)", "testcase": false, "constructor": false}, {"identifier": "levelUpLattice", "parameters": "(List<LatticeNode> latticeNodes, List<ContextualDatum> data)", "modifiers": "private", "return": "List<LatticeNode>", "signature": "List<LatticeNode> levelUpLattice(List<LatticeNode> latticeNodes, List<ContextualDatum> data)", "full_signature": "private List<LatticeNode> levelUpLattice(List<LatticeNode> latticeNodes, List<ContextualDatum> data)", "class_method_signature": "ContextualOutlierDetector.levelUpLattice(List<LatticeNode> latticeNodes, List<ContextualDatum> data)", "testcase": false, "constructor": false}, {"identifier": "contextualOutlierDetection", "parameters": "(List<ContextualDatum> data, Context context)", "modifiers": "public", "return": "List<Datum>", "signature": "List<Datum> contextualOutlierDetection(List<ContextualDatum> data, Context context)", "full_signature": "public List<Datum> contextualOutlierDetection(List<ContextualDatum> data, Context context)", "class_method_signature": "ContextualOutlierDetector.contextualOutlierDetection(List<ContextualDatum> data, Context context)", "testcase": false, "constructor": false}, {"identifier": "sameDistribution", "parameters": "(Context p1, Context p2)", "modifiers": "private", "return": "boolean", "signature": "boolean sameDistribution(Context p1, Context p2)", "full_signature": "private boolean sameDistribution(Context p1, Context p2)", "class_method_signature": "ContextualOutlierDetector.sameDistribution(Context p1, Context p2)", "testcase": false, "constructor": false}, {"identifier": "constructDetector", "parameters": "()", "modifiers": "private", "return": "BatchTrainScore", "signature": "BatchTrainScore constructDetector()", "full_signature": "private BatchTrainScore constructDetector()", "class_method_signature": "ContextualOutlierDetector.constructDetector()", "testcase": false, "constructor": false}, {"identifier": "buildOneDimensionalLatticeNodes", "parameters": "(List<ContextualDatum> data)", "modifiers": "private", "return": "List<LatticeNode>", "signature": "List<LatticeNode> buildOneDimensionalLatticeNodes(List<ContextualDatum> data)", "full_signature": "private List<LatticeNode> buildOneDimensionalLatticeNodes(List<ContextualDatum> data)", "class_method_signature": "ContextualOutlierDetector.buildOneDimensionalLatticeNodes(List<ContextualDatum> data)", "testcase": false, "constructor": false}, {"identifier": "buildOneDimensionalLatticeNodesGivenOutliers", "parameters": "(List<ContextualDatum> data, List<ContextualDatum> inputOutliers)", "modifiers": "private", "return": "List<LatticeNode>", "signature": "List<LatticeNode> buildOneDimensionalLatticeNodesGivenOutliers(List<ContextualDatum> data, List<ContextualDatum> inputOutliers)", "full_signature": "private List<LatticeNode> buildOneDimensionalLatticeNodesGivenOutliers(List<ContextualDatum> data, List<ContextualDatum> inputOutliers)", "class_method_signature": "ContextualOutlierDetector.buildOneDimensionalLatticeNodesGivenOutliers(List<ContextualDatum> data, List<ContextualDatum> inputOutliers)", "testcase": false, "constructor": false}, {"identifier": "isEncoderSetup", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean isEncoderSetup()", "full_signature": "private boolean isEncoderSetup()", "class_method_signature": "ContextualOutlierDetector.isEncoderSetup()", "testcase": false, "constructor": false}, {"identifier": "isInterestingInterval", "parameters": "(Interval interval)", "modifiers": "private", "return": "boolean", "signature": "boolean isInterestingInterval(Interval interval)", "full_signature": "private boolean isInterestingInterval(Interval interval)", "class_method_signature": "ContextualOutlierDetector.isInterestingInterval(Interval interval)", "testcase": false, "constructor": false}, {"identifier": "initOneDimensionalDenseContextsAndContext2Data", "parameters": "(List<ContextualDatum> data, int dimension, double curDensityThreshold)", "modifiers": "private", "return": "List<Context>", "signature": "List<Context> initOneDimensionalDenseContextsAndContext2Data(List<ContextualDatum> data, int dimension, double curDensityThreshold)", "full_signature": "private List<Context> initOneDimensionalDenseContextsAndContext2Data(List<ContextualDatum> data, int dimension, double curDensityThreshold)", "class_method_signature": "ContextualOutlierDetector.initOneDimensionalDenseContextsAndContext2Data(List<ContextualDatum> data, int dimension, double curDensityThreshold)", "testcase": false, "constructor": false}, {"identifier": "initOneDimensionalDenseContextsAndContext2DataGivenOutliers", "parameters": "(List<ContextualDatum> data, int dimension, List<ContextualDatum> inputOutliers)", "modifiers": "private", "return": "List<Context>", "signature": "List<Context> initOneDimensionalDenseContextsAndContext2DataGivenOutliers(List<ContextualDatum> data, int dimension, List<ContextualDatum> inputOutliers)", "full_signature": "private List<Context> initOneDimensionalDenseContextsAndContext2DataGivenOutliers(List<ContextualDatum> data, int dimension, List<ContextualDatum> inputOutliers)", "class_method_signature": "ContextualOutlierDetector.initOneDimensionalDenseContextsAndContext2DataGivenOutliers(List<ContextualDatum> data, int dimension, List<ContextualDatum> inputOutliers)", "testcase": false, "constructor": false}, {"identifier": "indexes2BitSet", "parameters": "(List<Integer> indexes, int total)", "modifiers": "private", "return": "BitSet", "signature": "BitSet indexes2BitSet(List<Integer> indexes, int total)", "full_signature": "private BitSet indexes2BitSet(List<Integer> indexes, int total)", "class_method_signature": "ContextualOutlierDetector.indexes2BitSet(List<Integer> indexes, int total)", "testcase": false, "constructor": false}, {"identifier": "bitSet2Indexes", "parameters": "(BitSet bs)", "modifiers": "private", "return": "List<Integer>", "signature": "List<Integer> bitSet2Indexes(BitSet bs)", "full_signature": "private List<Integer> bitSet2Indexes(BitSet bs)", "class_method_signature": "ContextualOutlierDetector.bitSet2Indexes(BitSet bs)", "testcase": false, "constructor": false}], "file": "contrib/src/main/java/macrobase/analysis/contextualoutlier/ContextualOutlierDetector.java"}, "focal_method": {"identifier": "searchContextualOutliers", "parameters": "(List<ContextualDatum> data)", "modifiers": "public", "return": "Map<Context, List<OutlierClassificationResult>>", "body": "public Map<Context, List<OutlierClassificationResult>> searchContextualOutliers(List<ContextualDatum> data) throws Exception {\n        Stopwatch sw = Stopwatch.createUnstarted();\n        log.debug(\"Find global context outliers on data num tuples: {} , MBs {} \", data.size());\n        sw.start();\n        HashSet<ContextualDatum> sample = randomSampling(data, 100);\n        globalContext = new Context(sample, densityPruning, dependencyPruning, alpha);\n        contextualOutlierDetection(data, globalContext);\n        sw.stop();\n        long globalOutlierDetecionTime = sw.elapsed(TimeUnit.MILLISECONDS);\n        sw.reset();\n        log.debug(\"Done global context outlier remaining data size {} : (duration: {}ms)\", data.size(),\n                  globalOutlierDetecionTime);\n        List<LatticeNode> preLatticeNodes = new ArrayList<LatticeNode>();\n        List<LatticeNode> curLatticeNodes = new ArrayList<LatticeNode>();\n        for (int level = 1; level <= totalContextualDimensions; level++) {\n            if (level > maxPredicates)\n                break;\n            log.debug(\"Build {}-dimensional contexts on all attributes\", level);\n            sw.start();\n            if (level == 1) {\n                curLatticeNodes = buildOneDimensionalLatticeNodes(data);\n            } else {\n                curLatticeNodes = levelUpLattice(preLatticeNodes, data);\n            }\n            sw.stop();\n            long latticeNodesBuildTimeCurLevel = sw.elapsed(TimeUnit.MILLISECONDS);\n            sw.reset();\n            log.debug(\"Done building {}-dimensional contexts on all attributes (duration: {}ms)\", level,\n                      latticeNodesBuildTimeCurLevel);\n            log.debug(\"Memory Usage: {}\", MemoryUtil.checkMemoryUsage());\n            if (curLatticeNodes.size() == 0) {\n                log.debug(\"No more dense contexts, thus no need to level up anymore\");\n                break;\n            }\n            log.debug(\"Find {}-dimensional contextual outliers\", level);\n            sw.start();\n            int numDenseContextsCurLevel = 0;\n            //run contextual outlier detection\n            for (LatticeNode node : curLatticeNodes) {\n                for (Context context : node.getDenseContexts()) {\n                    contextualOutlierDetection(data, context);\n                    numDenseContextsCurLevel++;\n                }\n            }\n            sw.stop();\n            long contextualOutlierDetectionTimeCurLevel = sw.elapsed(TimeUnit.MILLISECONDS);\n            sw.reset();\n            log.debug(\"Done Find {}-dimensional contextual outliers (duration: {}ms)\", level,\n                      contextualOutlierDetectionTimeCurLevel);\n            log.debug(\n                    \"Done Find {}-dimensional contextual outliers, there are {} dense contexts(average duration per context: {}ms)\",\n                    level, numDenseContextsCurLevel,\n                    (numDenseContextsCurLevel == 0) ? 0 : contextualOutlierDetectionTimeCurLevel / numDenseContextsCurLevel);\n            log.debug(\"Done Find {}-dimensional contextual outliers, densityPruning2: {}, \"\n                      + \"numOutlierDetectionRunsWithoutTrainingWithoutScoring: {},  \"\n                      + \"numOutlierDetectionRunsWithoutTrainingWithScoring: {},  \"\n                      + \"numOutlierDetectionRunsWithTrainingWithScoring: {}\",\n                      level, densityPruning2,\n                      numOutlierDetectionRunsWithoutTrainingWithoutScoring,\n                      numOutlierDetectionRunsWithoutTrainingWithScoring,\n                      numOutlierDetectionRunsWithTrainingWithScoring);\n            log.debug(\"----------------------------------------------------------\");\n            //free up memory\n            if (level >= 2) {\n                for (LatticeNode node : preLatticeNodes) {\n                    for (Context context : node.getDenseContexts()) {\n                        context2BitSet.remove(context);\n                    }\n                }\n            }\n            preLatticeNodes = curLatticeNodes;\n        }\n        return context2Outliers;\n    }", "signature": "Map<Context, List<OutlierClassificationResult>> searchContextualOutliers(List<ContextualDatum> data)", "full_signature": "public Map<Context, List<OutlierClassificationResult>> searchContextualOutliers(List<ContextualDatum> data)", "class_method_signature": "ContextualOutlierDetector.searchContextualOutliers(List<ContextualDatum> data)", "testcase": false, "constructor": false, "invocations": ["createUnstarted", "debug", "size", "start", "randomSampling", "contextualOutlierDetection", "stop", "elapsed", "reset", "debug", "size", "debug", "start", "buildOneDimensionalLatticeNodes", "levelUpLattice", "stop", "elapsed", "reset", "debug", "debug", "checkMemoryUsage", "size", "debug", "debug", "start", "getDenseContexts", "contextualOutlierDetection", "stop", "elapsed", "reset", "debug", "debug", "debug", "debug", "getDenseContexts", "remove"]}, "repository": {"repo_id": 48199522, "url": "https://github.com/stanford-futuredata/macrobase", "language": "Java", "is_fork": false, "fork_count": 116, "stargazer_count": 606, "size": 27614, "license": "licensed"}}