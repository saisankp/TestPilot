{"test_class": {"identifier": "TestExtensionWebSocketListener", "superclass": "extends ExtjsdkTestBase", "interfaces": "", "fields": [{"original_string": "ExtensionWebSocketListener listener;", "modifier": "", "type": "ExtensionWebSocketListener", "declarator": "listener", "var_name": "listener"}, {"original_string": "FalseClient client;", "modifier": "", "type": "FalseClient", "declarator": "client", "var_name": "client"}, {"original_string": "TestHandlerESM pHandler;", "modifier": "", "type": "TestHandlerESM", "declarator": "pHandler", "var_name": "pHandler"}, {"original_string": "TestHandlerResp aHandler;", "modifier": "", "type": "TestHandlerResp", "declarator": "aHandler", "var_name": "aHandler"}, {"original_string": "TestHandlerESM cHandler;", "modifier": "", "type": "TestHandlerESM", "declarator": "cHandler", "var_name": "cHandler"}, {"original_string": "TestHandlerESM qHandler;", "modifier": "", "type": "TestHandlerESM", "declarator": "qHandler", "var_name": "qHandler"}, {"original_string": "TestHandlerESM rHandler;", "modifier": "", "type": "TestHandlerESM", "declarator": "rHandler", "var_name": "rHandler"}, {"original_string": "TestHandlerResp hHandler;", "modifier": "", "type": "TestHandlerResp", "declarator": "hHandler", "var_name": "hHandler"}, {"original_string": "String srcName;", "modifier": "", "type": "String", "declarator": "srcName", "var_name": "srcName"}], "file": "extjsdk/src/test/java/io/vantiq/extjsdk/TestExtensionWebSocketListener.java"}, "test_case": {"identifier": "testHttp", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test \n    public void testHttp() {\n        connectToSource(srcName, null);\n        \n        Response resp = new Response().status(200);\n        ResponseBody body = TestListener.createHttpMessage(resp);\n        \n        listener.onMessage(body);\n        \n        assert hHandler.compareStatus(200);\n    }", "signature": "void testHttp()", "full_signature": "@Test public void testHttp()", "class_method_signature": "TestExtensionWebSocketListener.testHttp()", "testcase": true, "constructor": false, "invocations": ["connectToSource", "status", "createHttpMessage", "onMessage", "compareStatus"]}, "focal_class": {"identifier": "ExtensionWebSocketListener", "superclass": "", "interfaces": "implements WebSocketListener", "fields": [{"original_string": "Handler<Response> httpHandler = null;", "modifier": "", "type": "Handler<Response>", "declarator": "httpHandler = null", "var_name": "httpHandler"}, {"original_string": "Handler<ExtensionServiceMessage> publishHandler = null;", "modifier": "", "type": "Handler<ExtensionServiceMessage>", "declarator": "publishHandler = null", "var_name": "publishHandler"}, {"original_string": "Handler<ExtensionServiceMessage> queryHandler = null;", "modifier": "", "type": "Handler<ExtensionServiceMessage>", "declarator": "queryHandler = null", "var_name": "queryHandler"}, {"original_string": "Handler<ExtensionServiceMessage> configHandler = null;", "modifier": "", "type": "Handler<ExtensionServiceMessage>", "declarator": "configHandler = null", "var_name": "configHandler"}, {"original_string": "Handler<Response> authHandler = null;", "modifier": "", "type": "Handler<Response>", "declarator": "authHandler = null", "var_name": "authHandler"}, {"original_string": "Handler<ExtensionServiceMessage> reconnectHandler = null;", "modifier": "", "type": "Handler<ExtensionServiceMessage>", "declarator": "reconnectHandler = null", "var_name": "reconnectHandler"}, {"original_string": "final Logger log;", "modifier": "final", "type": "Logger", "declarator": "log", "var_name": "log"}, {"original_string": "private ExtensionWebSocketClient client;", "modifier": "private", "type": "ExtensionWebSocketClient", "declarator": "client", "var_name": "client"}, {"original_string": "ObjectMapper mapper = new ObjectMapper();", "modifier": "", "type": "ObjectMapper", "declarator": "mapper = new ObjectMapper()", "var_name": "mapper"}, {"original_string": "boolean isClosed = false;", "modifier": "", "type": "boolean", "declarator": "isClosed = false", "var_name": "isClosed"}], "methods": [{"identifier": "ExtensionWebSocketListener", "parameters": "(ExtensionWebSocketClient client)", "modifiers": "public", "return": "", "signature": " ExtensionWebSocketListener(ExtensionWebSocketClient client)", "full_signature": "public  ExtensionWebSocketListener(ExtensionWebSocketClient client)", "class_method_signature": "ExtensionWebSocketListener.ExtensionWebSocketListener(ExtensionWebSocketClient client)", "testcase": false, "constructor": true}, {"identifier": "setHttpHandler", "parameters": "(Handler<Response> httpHandler)", "modifiers": "public", "return": "void", "signature": "void setHttpHandler(Handler<Response> httpHandler)", "full_signature": "public void setHttpHandler(Handler<Response> httpHandler)", "class_method_signature": "ExtensionWebSocketListener.setHttpHandler(Handler<Response> httpHandler)", "testcase": false, "constructor": false}, {"identifier": "setPublishHandler", "parameters": "(Handler<ExtensionServiceMessage> publishHandler)", "modifiers": "public", "return": "void", "signature": "void setPublishHandler(Handler<ExtensionServiceMessage> publishHandler)", "full_signature": "public void setPublishHandler(Handler<ExtensionServiceMessage> publishHandler)", "class_method_signature": "ExtensionWebSocketListener.setPublishHandler(Handler<ExtensionServiceMessage> publishHandler)", "testcase": false, "constructor": false}, {"identifier": "setQueryHandler", "parameters": "(Handler<ExtensionServiceMessage> queryHandler)", "modifiers": "public", "return": "void", "signature": "void setQueryHandler(Handler<ExtensionServiceMessage> queryHandler)", "full_signature": "public void setQueryHandler(Handler<ExtensionServiceMessage> queryHandler)", "class_method_signature": "ExtensionWebSocketListener.setQueryHandler(Handler<ExtensionServiceMessage> queryHandler)", "testcase": false, "constructor": false}, {"identifier": "setConfigHandler", "parameters": "(Handler<ExtensionServiceMessage> configHandler)", "modifiers": "public", "return": "void", "signature": "void setConfigHandler(Handler<ExtensionServiceMessage> configHandler)", "full_signature": "public void setConfigHandler(Handler<ExtensionServiceMessage> configHandler)", "class_method_signature": "ExtensionWebSocketListener.setConfigHandler(Handler<ExtensionServiceMessage> configHandler)", "testcase": false, "constructor": false}, {"identifier": "setAuthHandler", "parameters": "(Handler<Response> authHandler)", "modifiers": "public", "return": "void", "signature": "void setAuthHandler(Handler<Response> authHandler)", "full_signature": "public void setAuthHandler(Handler<Response> authHandler)", "class_method_signature": "ExtensionWebSocketListener.setAuthHandler(Handler<Response> authHandler)", "testcase": false, "constructor": false}, {"identifier": "setReconnectHandler", "parameters": "(Handler<ExtensionServiceMessage> reconnectHandler)", "modifiers": "public", "return": "void", "signature": "void setReconnectHandler(Handler<ExtensionServiceMessage> reconnectHandler)", "full_signature": "public void setReconnectHandler(Handler<ExtensionServiceMessage> reconnectHandler)", "class_method_signature": "ExtensionWebSocketListener.setReconnectHandler(Handler<ExtensionServiceMessage> reconnectHandler)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "ExtensionWebSocketListener.close()", "testcase": false, "constructor": false}, {"identifier": "isClosed", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isClosed()", "full_signature": "public boolean isClosed()", "class_method_signature": "ExtensionWebSocketListener.isClosed()", "testcase": false, "constructor": false}, {"identifier": "onOpen", "parameters": "(WebSocket webSocket, okhttp3.Response response)", "modifiers": "@Override public", "return": "void", "signature": "void onOpen(WebSocket webSocket, okhttp3.Response response)", "full_signature": "@Override public void onOpen(WebSocket webSocket, okhttp3.Response response)", "class_method_signature": "ExtensionWebSocketListener.onOpen(WebSocket webSocket, okhttp3.Response response)", "testcase": false, "constructor": false}, {"identifier": "onMessage", "parameters": "(ResponseBody body)", "modifiers": "@Override public", "return": "void", "signature": "void onMessage(ResponseBody body)", "full_signature": "@Override public void onMessage(ResponseBody body)", "class_method_signature": "ExtensionWebSocketListener.onMessage(ResponseBody body)", "testcase": false, "constructor": false}, {"identifier": "useHandlersFromListener", "parameters": "(ExtensionWebSocketListener listener)", "modifiers": "public", "return": "void", "signature": "void useHandlersFromListener(ExtensionWebSocketListener listener)", "full_signature": "public void useHandlersFromListener(ExtensionWebSocketListener listener)", "class_method_signature": "ExtensionWebSocketListener.useHandlersFromListener(ExtensionWebSocketListener listener)", "testcase": false, "constructor": false}, {"identifier": "useHandlersFromListener", "parameters": "(ExtensionWebSocketClient client)", "modifiers": "public", "return": "void", "signature": "void useHandlersFromListener(ExtensionWebSocketClient client)", "full_signature": "public void useHandlersFromListener(ExtensionWebSocketClient client)", "class_method_signature": "ExtensionWebSocketListener.useHandlersFromListener(ExtensionWebSocketClient client)", "testcase": false, "constructor": false}, {"identifier": "onClose", "parameters": "(int code, String reason)", "modifiers": "@Override public", "return": "void", "signature": "void onClose(int code, String reason)", "full_signature": "@Override public void onClose(int code, String reason)", "class_method_signature": "ExtensionWebSocketListener.onClose(int code, String reason)", "testcase": false, "constructor": false}, {"identifier": "onPong", "parameters": "(Buffer payload)", "modifiers": "@Override public", "return": "void", "signature": "void onPong(Buffer payload)", "full_signature": "@Override public void onPong(Buffer payload)", "class_method_signature": "ExtensionWebSocketListener.onPong(Buffer payload)", "testcase": false, "constructor": false}, {"identifier": "onFailure", "parameters": "(IOException e, okhttp3.Response response)", "modifiers": "@Override public", "return": "void", "signature": "void onFailure(IOException e, okhttp3.Response response)", "full_signature": "@Override public void onFailure(IOException e, okhttp3.Response response)", "class_method_signature": "ExtensionWebSocketListener.onFailure(IOException e, okhttp3.Response response)", "testcase": false, "constructor": false}], "file": "extjsdk/src/main/java/io/vantiq/extjsdk/ExtensionWebSocketListener.java"}, "focal_method": {"identifier": "onMessage", "parameters": "(ResponseBody body)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void onMessage(ResponseBody body) {\n        // Extract the original message from the body\n        byte[] data;\n        try {\n            if (body.contentType() == WebSocket.TEXT) {\n                data = body.string().getBytes();\n            } else {\n                data = body.bytes();\n            }\n        }\n        catch (IOException e) {\n            log.error(\"Error trying to interpret WebSocket message\", e);\n            return;\n        }\n        body.close();\n\n\n        if (this.isClosed) {\n            return; // Do nothing if closed at this point\n        }\n        \n        // Convert the data from a Json string/byte array to a map\n        Map msg;\n        try {\n            msg = mapper.readValue(data, Map.class);\n        }\n        catch (Exception e) {\n            log.warn(\"Failed to interpret WebSocket message as Map.\", e);\n            return;\n        }\n        \n        //Check to see if we should use log with Debug, or with Error\n        if (msg.containsKey(\"status\")) {\n            int statusCheck = (Integer) msg.get(\"status\");\n            if (statusCheck >= 300) {\n                log.error(\"Map of the received message: {}\", msg);\n            } else {\n                log.trace(\"Map of the received message: {}\", msg);\n            }\n        } else {\n            log.debug(\"Map of the received message: {}\", msg);\n        }\n        \n        // Now we figure out which handler should receive the message\n        \n        // The message received has no op, and thus is not an ExtensionServiceMethod\n        // Since we're acting through the WebSocket interface, this means it should be a Http response\n        if (msg.get(\"op\") == null) {\n            Response message = Response.fromMap(msg);\n            log.trace(\"Http response received\");\n            if (client.isAuthed()) {\n                // Is an error message before successful connection to the target source\n                // This is most likely a failure related to a source connection request\n                if (!client.isConnected() && (Integer) message.getStatus() >= 300) {\n                    log.warn(\"Error occurred attempting to connect to source.\");\n                    log.debug(\"Error message was: {}\", message);\n                    client.sourceFuture.complete(false);\n                } else {\n                    client.acknowledgeNotification();\n                }\n                if (this.httpHandler != null) {\n                    try {\n                        this.httpHandler.handleMessage(message);\n                    }\n                    catch (Exception e) {\n                        log.error(\"Error occurred when running the HTTP handler.\", e);\n                    }\n                }\n                else {\n                    log.trace(\"Http response received with no handler set\");\n                }\n            }\n            else {\n                // Resetting authFuture is also sync'd on client, so this way they won't interfere with each other\n                synchronized (client) {\n                    // Checking isOpen() while sync'd in case of concurrency problems\n                    if (!client.isOpen() || this.isClosed) {\n                        return;\n                    }\n\n                    if ((int) message.getStatus() == 200 && !client.isAuthed()) {\n                        client.authFuture.complete(true);\n                    }\n                    else {\n                        client.authFuture.complete(false);\n                        log.warn(\"Error occurred attempting to authenticate\");\n                    }\n                }\n                if (authHandler != null) {\n                    try {\n                        this.authHandler.handleMessage(message);\n                    }\n                    catch (Exception e) {\n                        log.error(\"Error occurred when running the authentication handler for source.\", e);\n                    }\n                } else {\n                    log.debug(\"Auth received with no handler set\");\n                }\n            }\n        }\n        else {\n            ExtensionServiceMessage message = new ExtensionServiceMessage(\"\").fromMap(msg);\n            if (client.isConnected()) {\n                log.debug(\"Message with op '{}' received\", message.getOp());\n                log.debug(\"Map of ExtensionServiceMessage: {}\", message);\n                if (message.getOp().equals(ExtensionServiceMessage.OP_PUBLISH))\n                {\n                    if (this.publishHandler != null) {\n                        try {\n                            this.publishHandler.handleMessage(message);\n                        }\n                        catch (Exception e) {\n                            log.error(\"Error occurred when running the Publish handler.\", e);\n                        }\n                    }\n                    else {\n                        log.debug(\"Publish received with no handler set\");\n                    }\n                }\n                else if (message.getOp().equals(ExtensionServiceMessage.OP_QUERY)) {\n                    if (this.queryHandler != null && !isClosed) {\n                        try {\n                            this.queryHandler.handleMessage(message);\n                        }\n                        catch (Exception e) {\n                            log.error(\"Error occurred when running the Query handler.\", e);\n                        }\n                    } else {\n                        log.warn(\"Query received with no user-set handler\");\n                        log.debug(\"Full message: {}\", message);\n                        // Prepare a response with an empty body, so that the query doesn't wait for a timeout\n                        client.sendQueryError(ExtensionServiceMessage.extractReplyAddress(msg),\n                                \"io.vantiq.extjsdk.unsetQueryHandler\",\n                                \"Queries are not supported for source '{0}'. No handler has been set.\",\n                                new Object[] {message.getSourceName()});\n                    }\n                }\n                else if (message.getOp().equals(ExtensionServiceMessage.OP_RECONNECT_REQUIRED)) {\n                    synchronized (client) {\n                        // Do not alert client of reconnect message if this listener has been closed\n                        if (this.isClosed) {\n                            return; \n                        }\n                        client.sourceHasDisconnected(); // Resets to pre source connection state\n                    }\n                    if (this.reconnectHandler != null) {\n                        try {\n                            this.reconnectHandler.handleMessage(message);\n                        }\n                        catch (Exception e) {\n                            log.error(\"Error occurred when running the Reconnect handler.\", e);\n                        }\n                    }\n                    if (client.autoReconnect) {\n                        log.info(\"Automatically attempting to reconnect to source.\");\n                        client.connectToSource();\n                    }\n                    // Warn when cannot reconnect or know that the connection has failed \n                    if (!client.autoReconnect && this.reconnectHandler == null) {\n                        log.warn(\"Reconnect received with no handler set and no autoconnect. Can no longer \"\n                                + \"communicate with source.\");\n                    }\n                }\n                else {\n                    log.warn(\"ExtensionServiceMessage with unknown/unexpected op '{}'\", msg.get(\"op\"));\n                }\n            }\n            else if (msg.get(\"op\").equals(ExtensionServiceMessage.OP_CONFIGURE_EXTENSION) && client.isAuthed()) {\n                // Resetting sourceFuture is also sync'd on client, so this way they won't interfere with each other\n                synchronized (client) {\n                    // Rechecking isAuthed() while sync'd in case of concurrency problems\n                    if (!client.isAuthed()) {\n                        return;\n                    }\n\n                    client.sourceFuture.complete(true);\n                    log.info(\"Successful connection to {}\", msg.get(\"resourceId\").toString());\n                }\n                if (this.configHandler != null) {\n                    try {\n                        this.configHandler.handleMessage(message);\n                    }\n                    catch (Exception e) {\n                        log.error(\"Error occurred when running the Configuration handler.\", e);\n                    }\n                }\n                else {\n                    log.warn(\"Configuration received with no handler set\");\n                }\n            }\n            else {\n                log.warn(\"ExtensionServiceMessage received when not connected\");\n            }\n        }\n    }", "signature": "void onMessage(ResponseBody body)", "full_signature": "@Override public void onMessage(ResponseBody body)", "class_method_signature": "ExtensionWebSocketListener.onMessage(ResponseBody body)", "testcase": false, "constructor": false, "invocations": ["contentType", "getBytes", "string", "bytes", "error", "close", "readValue", "warn", "containsKey", "get", "error", "trace", "debug", "get", "fromMap", "trace", "isAuthed", "isConnected", "getStatus", "warn", "debug", "complete", "acknowledgeNotification", "handleMessage", "error", "trace", "isOpen", "getStatus", "isAuthed", "complete", "complete", "warn", "handleMessage", "error", "debug", "fromMap", "isConnected", "debug", "getOp", "debug", "equals", "getOp", "handleMessage", "error", "debug", "equals", "getOp", "handleMessage", "error", "warn", "debug", "sendQueryError", "extractReplyAddress", "getSourceName", "equals", "getOp", "sourceHasDisconnected", "handleMessage", "error", "info", "connectToSource", "warn", "warn", "get", "equals", "get", "isAuthed", "isAuthed", "complete", "info", "toString", "get", "handleMessage", "error", "warn", "warn"]}, "repository": {"repo_id": 141492069, "url": "https://github.com/Vantiq/vantiq-extension-sources", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 9, "size": 16261, "license": "licensed"}}