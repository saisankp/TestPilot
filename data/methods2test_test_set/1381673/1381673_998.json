{"test_class": {"identifier": "LogicTransformerTest", "superclass": "extends DroolsTestCase", "interfaces": "", "fields": [], "file": "drools-core/src/test/java/org/drools/core/rule/LogicTransformerTest.java"}, "test_case": {"identifier": "testTransform", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testTransform() throws IOException,\n                               ClassNotFoundException,\n                               InvalidPatternException {\n        final ObjectType type = new ClassObjectType( String.class );\n        final Pattern a = new Pattern( 0,\n                                     type,\n                                     \"a\" );\n        final Pattern b = new Pattern( 1,\n                                     type,\n                                     \"b\" );\n        final Pattern c = new Pattern( 2,\n                                     type,\n                                     \"c\" );\n        final Pattern d = new Pattern( 3,\n                                     type,\n                                     \"d\" );\n        final Pattern e = new Pattern( 4,\n                                     type,\n                                     \"e\" );\n        final Pattern f = new Pattern( 5,\n                                     type,\n                                     \"f\" );\n        final Pattern g = new Pattern( 6,\n                                     type,\n                                     \"g\" );\n        final Pattern h = new Pattern( 7,\n                                     type,\n                                     \"h\" );\n\n        final GroupElement and = GroupElementFactory.newAndInstance();\n\n        final GroupElement and1 = GroupElementFactory.newAndInstance();\n        and1.addChild( a );\n        final GroupElement or1 = GroupElementFactory.newOrInstance();\n        or1.addChild( b );\n        or1.addChild( c );\n        and1.addChild( or1 );\n        and.addChild( and1 );\n\n        final GroupElement or2 = GroupElementFactory.newOrInstance();\n        or2.addChild( d );\n        or2.addChild( e );\n        and.addChild( or2 );\n\n        final GroupElement and2 = GroupElementFactory.newAndInstance();\n        final GroupElement not1 = GroupElementFactory.newNotInstance();\n        not1.addChild( f );\n        final GroupElement or3 = GroupElementFactory.newOrInstance();\n        or3.addChild( g );\n\n        final GroupElement not2 = GroupElementFactory.newNotInstance();\n        not2.addChild( h );\n        or3.addChild( not2 );\n\n        and2.addChild( not1 );\n        and2.addChild( or3 );\n        and.addChild( and2 );\n\n        final GroupElement[] ands = LogicTransformer.getInstance().transform( and, Collections.EMPTY_MAP );\n\n        // Uncomment this when you need to output a new known correct tree\n        // result\n        final File testFile = new File(\"target/test/LogicTransformerTest_correct_transform1.dat\");\n        testFile.getParentFile().mkdirs();\n        DroolsStreamUtils.streamOut(new FileOutputStream(testFile), ands);\n\n        // Now check the main tree\n\n        // Get known correct tree\n        // The binary stream was created from a handchecked correct output\n        final GroupElement[] correctResultAnds =\n                (GroupElement[]) DroolsStreamUtils.streamIn( new FileInputStream(testFile));\n\n        for ( int j = 0; j < ands.length; j++ ) {\n            assertEquals( correctResultAnds[j],\n                          ands[j] );\n        }\n    }", "signature": "void testTransform()", "full_signature": "@Test public void testTransform()", "class_method_signature": "LogicTransformerTest.testTransform()", "testcase": true, "constructor": false, "invocations": ["newAndInstance", "newAndInstance", "addChild", "newOrInstance", "addChild", "addChild", "addChild", "addChild", "newOrInstance", "addChild", "addChild", "addChild", "newAndInstance", "newNotInstance", "addChild", "newOrInstance", "addChild", "newNotInstance", "addChild", "addChild", "addChild", "addChild", "addChild", "transform", "getInstance", "mkdirs", "getParentFile", "streamOut", "streamIn", "assertEquals"]}, "focal_class": {"identifier": "LogicTransformer", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Map<GroupElement.Type, Transformation> orTransformations = new HashMap<GroupElement.Type, Transformation>();", "modifier": "private final", "type": "Map<GroupElement.Type, Transformation>", "declarator": "orTransformations = new HashMap<GroupElement.Type, Transformation>()", "var_name": "orTransformations"}, {"original_string": "private static LogicTransformer INSTANCE          = new LogicTransformer();", "modifier": "private static", "type": "LogicTransformer", "declarator": "INSTANCE          = new LogicTransformer()", "var_name": "INSTANCE"}], "methods": [{"identifier": "getInstance", "parameters": "()", "modifiers": "public static", "return": "LogicTransformer", "signature": "LogicTransformer getInstance()", "full_signature": "public static LogicTransformer getInstance()", "class_method_signature": "LogicTransformer.getInstance()", "testcase": false, "constructor": false}, {"identifier": "LogicTransformer", "parameters": "()", "modifiers": "protected", "return": "", "signature": " LogicTransformer()", "full_signature": "protected  LogicTransformer()", "class_method_signature": "LogicTransformer.LogicTransformer()", "testcase": false, "constructor": true}, {"identifier": "initialize", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void initialize()", "full_signature": "private void initialize()", "class_method_signature": "LogicTransformer.initialize()", "testcase": false, "constructor": false}, {"identifier": "addTransformationPair", "parameters": "(final GroupElement.Type parent,\n                                       final Transformation method)", "modifiers": "private", "return": "void", "signature": "void addTransformationPair(final GroupElement.Type parent,\n                                       final Transformation method)", "full_signature": "private void addTransformationPair(final GroupElement.Type parent,\n                                       final Transformation method)", "class_method_signature": "LogicTransformer.addTransformationPair(final GroupElement.Type parent,\n                                       final Transformation method)", "testcase": false, "constructor": false}, {"identifier": "transform", "parameters": "( final GroupElement cloned, Map<String, Class<?>> globals )", "modifiers": "public", "return": "GroupElement[]", "signature": "GroupElement[] transform( final GroupElement cloned, Map<String, Class<?>> globals )", "full_signature": "public GroupElement[] transform( final GroupElement cloned, Map<String, Class<?>> globals )", "class_method_signature": "LogicTransformer.transform( final GroupElement cloned, Map<String, Class<?>> globals )", "testcase": false, "constructor": false}, {"identifier": "processNamedConsequences", "parameters": "(GroupElement[] ands)", "modifiers": "private", "return": "GroupElement[]", "signature": "GroupElement[] processNamedConsequences(GroupElement[] ands)", "full_signature": "private GroupElement[] processNamedConsequences(GroupElement[] ands)", "class_method_signature": "LogicTransformer.processNamedConsequences(GroupElement[] ands)", "testcase": false, "constructor": false}, {"identifier": "splitOr", "parameters": "( final GroupElement cloned )", "modifiers": "protected", "return": "GroupElement[]", "signature": "GroupElement[] splitOr( final GroupElement cloned )", "full_signature": "protected GroupElement[] splitOr( final GroupElement cloned )", "class_method_signature": "LogicTransformer.splitOr( final GroupElement cloned )", "testcase": false, "constructor": false}, {"identifier": "fixClonedDeclarations", "parameters": "( GroupElement and, Map<String, Class<?>> globals )", "modifiers": "protected", "return": "void", "signature": "void fixClonedDeclarations( GroupElement and, Map<String, Class<?>> globals )", "full_signature": "protected void fixClonedDeclarations( GroupElement and, Map<String, Class<?>> globals )", "class_method_signature": "LogicTransformer.fixClonedDeclarations( GroupElement and, Map<String, Class<?>> globals )", "testcase": false, "constructor": false}, {"identifier": "processElement", "parameters": "(final DeclarationScopeResolver resolver,\n                                final Stack<RuleConditionElement> contextStack,\n                                final RuleConditionElement element)", "modifiers": "private", "return": "void", "signature": "void processElement(final DeclarationScopeResolver resolver,\n                                final Stack<RuleConditionElement> contextStack,\n                                final RuleConditionElement element)", "full_signature": "private void processElement(final DeclarationScopeResolver resolver,\n                                final Stack<RuleConditionElement> contextStack,\n                                final RuleConditionElement element)", "class_method_signature": "LogicTransformer.processElement(final DeclarationScopeResolver resolver,\n                                final Stack<RuleConditionElement> contextStack,\n                                final RuleConditionElement element)", "testcase": false, "constructor": false}, {"identifier": "replaceDeclarations", "parameters": "( DeclarationScopeResolver resolver, Pattern pattern, Constraint constraint )", "modifiers": "private", "return": "void", "signature": "void replaceDeclarations( DeclarationScopeResolver resolver, Pattern pattern, Constraint constraint )", "full_signature": "private void replaceDeclarations( DeclarationScopeResolver resolver, Pattern pattern, Constraint constraint )", "class_method_signature": "LogicTransformer.replaceDeclarations( DeclarationScopeResolver resolver, Pattern pattern, Constraint constraint )", "testcase": false, "constructor": false}, {"identifier": "replaceDeclarations", "parameters": "( DeclarationScopeResolver resolver, Accumulate accumulate )", "modifiers": "private", "return": "void", "signature": "void replaceDeclarations( DeclarationScopeResolver resolver, Accumulate accumulate )", "full_signature": "private void replaceDeclarations( DeclarationScopeResolver resolver, Accumulate accumulate )", "class_method_signature": "LogicTransformer.replaceDeclarations( DeclarationScopeResolver resolver, Accumulate accumulate )", "testcase": false, "constructor": false}, {"identifier": "asList", "parameters": "(int[] ints)", "modifiers": "private static", "return": "List<Integer>", "signature": "List<Integer> asList(int[] ints)", "full_signature": "private static List<Integer> asList(int[] ints)", "class_method_signature": "LogicTransformer.asList(int[] ints)", "testcase": false, "constructor": false}, {"identifier": "toIntArray", "parameters": "(List<Integer> list)", "modifiers": "public static", "return": "int[]", "signature": "int[] toIntArray(List<Integer> list)", "full_signature": "public static int[] toIntArray(List<Integer> list)", "class_method_signature": "LogicTransformer.toIntArray(List<Integer> list)", "testcase": false, "constructor": false}, {"identifier": "processEvalCondition", "parameters": "(DeclarationScopeResolver resolver, EvalCondition element)", "modifiers": "private", "return": "void", "signature": "void processEvalCondition(DeclarationScopeResolver resolver, EvalCondition element)", "full_signature": "private void processEvalCondition(DeclarationScopeResolver resolver, EvalCondition element)", "class_method_signature": "LogicTransformer.processEvalCondition(DeclarationScopeResolver resolver, EvalCondition element)", "testcase": false, "constructor": false}, {"identifier": "processBranch", "parameters": "(DeclarationScopeResolver resolver, ConditionalBranch branch)", "modifiers": "private", "return": "void", "signature": "void processBranch(DeclarationScopeResolver resolver, ConditionalBranch branch)", "full_signature": "private void processBranch(DeclarationScopeResolver resolver, ConditionalBranch branch)", "class_method_signature": "LogicTransformer.processBranch(DeclarationScopeResolver resolver, ConditionalBranch branch)", "testcase": false, "constructor": false}, {"identifier": "processTree", "parameters": "(final GroupElement ce)", "modifiers": "protected", "return": "boolean", "signature": "boolean processTree(final GroupElement ce)", "full_signature": "protected boolean processTree(final GroupElement ce)", "class_method_signature": "LogicTransformer.processTree(final GroupElement ce)", "testcase": false, "constructor": false}, {"identifier": "processTree", "parameters": "(final GroupElement ce, boolean[] result)", "modifiers": "private", "return": "void", "signature": "void processTree(final GroupElement ce, boolean[] result)", "full_signature": "private void processTree(final GroupElement ce, boolean[] result)", "class_method_signature": "LogicTransformer.processTree(final GroupElement ce, boolean[] result)", "testcase": false, "constructor": false}, {"identifier": "applyOrTransformation", "parameters": "(final GroupElement parent)", "modifiers": "", "return": "void", "signature": "void applyOrTransformation(final GroupElement parent)", "full_signature": " void applyOrTransformation(final GroupElement parent)", "class_method_signature": "LogicTransformer.applyOrTransformation(final GroupElement parent)", "testcase": false, "constructor": false}], "file": "drools-core/src/main/java/org/drools/core/rule/LogicTransformer.java"}, "focal_method": {"identifier": "transform", "parameters": "( final GroupElement cloned, Map<String, Class<?>> globals )", "modifiers": "public", "return": "GroupElement[]", "body": "public GroupElement[] transform( final GroupElement cloned, Map<String, Class<?>> globals ) throws InvalidPatternException {\n        //moved cloned to up\n        //final GroupElement cloned = (GroupElement) and.clone();\n\n        boolean hasNamedConsequenceAndIsStream = processTree( cloned );\n        cloned.pack();\n\n        GroupElement[] ands;\n        // is top element an AND?\n        if ( cloned.isAnd() ) {\n            // Yes, so just return it\n            ands = new GroupElement[]{cloned};\n        } else if ( cloned.isOr() ) {\n            // it is an OR, so each child is an AND branch\n            ands = splitOr( cloned );\n        } else {\n            // no, so just wrap into an AND\n            final GroupElement wrapper = GroupElementFactory.newAndInstance();\n            wrapper.addChild( cloned );\n            ands = new GroupElement[]{wrapper};\n        }\n\n        for ( GroupElement and : ands ) {\n            // fix the cloned declarations\n            this.fixClonedDeclarations( and, globals );\n            and.setRoot( true );\n        }\n\n        return hasNamedConsequenceAndIsStream ? processNamedConsequences(ands) : ands;\n    }", "signature": "GroupElement[] transform( final GroupElement cloned, Map<String, Class<?>> globals )", "full_signature": "public GroupElement[] transform( final GroupElement cloned, Map<String, Class<?>> globals )", "class_method_signature": "LogicTransformer.transform( final GroupElement cloned, Map<String, Class<?>> globals )", "testcase": false, "constructor": false, "invocations": ["processTree", "pack", "isAnd", "isOr", "splitOr", "newAndInstance", "addChild", "fixClonedDeclarations", "setRoot", "processNamedConsequences"]}, "repository": {"repo_id": 1381673, "url": "https://github.com/kiegroup/drools", "stars": 2733, "created": "2/18/2011 8:37:05 AM +00:00", "updates": "2020-01-27T13:12:15+00:00", "fork": "False", "license": "licensed"}}