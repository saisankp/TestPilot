{"test_class": {"identifier": "ReactorSerializedInvokerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Duration QUEUEING_TIMEOUT = Duration.ofMillis(500);", "modifier": "private static final", "type": "Duration", "declarator": "QUEUEING_TIMEOUT = Duration.ofMillis(500)", "var_name": "QUEUEING_TIMEOUT"}, {"original_string": "private static final Duration EXCESSIVE_RUNNING_TIME = Duration.ofMillis(1_000);", "modifier": "private static final", "type": "Duration", "declarator": "EXCESSIVE_RUNNING_TIME = Duration.ofMillis(1_000)", "var_name": "EXCESSIVE_RUNNING_TIME"}, {"original_string": "private ReactorSerializedInvoker<String> reactorSerializedInvoker = ReactorSerializedInvoker.<String>newBuilder()\n            .withName(\"test\")\n            .withScheduler(Schedulers.parallel())\n            .withMaxQueueSize(10)\n            .withExcessiveRunningTime(EXCESSIVE_RUNNING_TIME)\n            .withRegistry(new DefaultRegistry())\n            .withClock(Clocks.system())\n            .build();", "modifier": "private", "type": "ReactorSerializedInvoker<String>", "declarator": "reactorSerializedInvoker = ReactorSerializedInvoker.<String>newBuilder()\n            .withName(\"test\")\n            .withScheduler(Schedulers.parallel())\n            .withMaxQueueSize(10)\n            .withExcessiveRunningTime(EXCESSIVE_RUNNING_TIME)\n            .withRegistry(new DefaultRegistry())\n            .withClock(Clocks.system())\n            .build()", "var_name": "reactorSerializedInvoker"}], "file": "titus-common/src/test/java/com/netflix/titus/common/util/rx/invoker/ReactorSerializedInvokerTest.java"}, "test_case": {"identifier": "testInlineAction", "parameters": "()", "modifiers": "@Test(timeout = 5_000) public", "return": "void", "body": "@Test(timeout = 5_000)\n    public void testInlineAction() {\n        List<String> result = new CopyOnWriteArrayList<>();\n        for (int i = 0; i < 5; i++) {\n            int index = i;\n            reactorSerializedInvoker.submit(Mono.just(\"#\" + index).map(tick -> \"#\" + index)).subscribe(result::add);\n        }\n        await().until(() -> result.size() == 5);\n        assertThat(result).contains(\"#0\", \"#1\", \"#2\", \"#3\", \"#4\");\n    }", "signature": "void testInlineAction()", "full_signature": "@Test(timeout = 5_000) public void testInlineAction()", "class_method_signature": "ReactorSerializedInvokerTest.testInlineAction()", "testcase": true, "constructor": false, "invocations": ["subscribe", "submit", "map", "just", "until", "await", "size", "contains", "assertThat"]}, "focal_class": {"identifier": "ReactorSerializedInvoker", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(ReactorSerializedInvoker.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(ReactorSerializedInvoker.class)", "var_name": "logger"}, {"original_string": "private final Duration excessiveRunningTime;", "modifier": "private final", "type": "Duration", "declarator": "excessiveRunningTime", "var_name": "excessiveRunningTime"}, {"original_string": "private final Worker worker;", "modifier": "private final", "type": "Worker", "declarator": "worker", "var_name": "worker"}, {"original_string": "private final Scheduler scheduler;", "modifier": "private final", "type": "Scheduler", "declarator": "scheduler", "var_name": "scheduler"}, {"original_string": "private final Clock clock;", "modifier": "private final", "type": "Clock", "declarator": "clock", "var_name": "clock"}, {"original_string": "private final ReactorSerializedInvokerMetrics metrics;", "modifier": "private final", "type": "ReactorSerializedInvokerMetrics", "declarator": "metrics", "var_name": "metrics"}, {"original_string": "private final BlockingQueue<ActionHandler> actionHandlers;", "modifier": "private final", "type": "BlockingQueue<ActionHandler>", "declarator": "actionHandlers", "var_name": "actionHandlers"}, {"original_string": "private ActionHandler pendingAction;", "modifier": "private", "type": "ActionHandler", "declarator": "pendingAction", "var_name": "pendingAction"}, {"original_string": "private volatile boolean shutdownFlag;", "modifier": "private volatile", "type": "boolean", "declarator": "shutdownFlag", "var_name": "shutdownFlag"}], "methods": [{"identifier": "ReactorSerializedInvoker", "parameters": "(String name,\n                                     int size,\n                                     Duration excessiveRunningTime,\n                                     Scheduler scheduler,\n                                     Registry registry,\n                                     Clock clock)", "modifiers": "private", "return": "", "signature": " ReactorSerializedInvoker(String name,\n                                     int size,\n                                     Duration excessiveRunningTime,\n                                     Scheduler scheduler,\n                                     Registry registry,\n                                     Clock clock)", "full_signature": "private  ReactorSerializedInvoker(String name,\n                                     int size,\n                                     Duration excessiveRunningTime,\n                                     Scheduler scheduler,\n                                     Registry registry,\n                                     Clock clock)", "class_method_signature": "ReactorSerializedInvoker.ReactorSerializedInvoker(String name,\n                                     int size,\n                                     Duration excessiveRunningTime,\n                                     Scheduler scheduler,\n                                     Registry registry,\n                                     Clock clock)", "testcase": false, "constructor": true}, {"identifier": "shutdown", "parameters": "(Duration timeout)", "modifiers": "public", "return": "void", "signature": "void shutdown(Duration timeout)", "full_signature": "public void shutdown(Duration timeout)", "class_method_signature": "ReactorSerializedInvoker.shutdown(Duration timeout)", "testcase": false, "constructor": false}, {"identifier": "submit", "parameters": "(Mono<T> action)", "modifiers": "public", "return": "Mono<T>", "signature": "Mono<T> submit(Mono<T> action)", "full_signature": "public Mono<T> submit(Mono<T> action)", "class_method_signature": "ReactorSerializedInvoker.submit(Mono<T> action)", "testcase": false, "constructor": false}, {"identifier": "drain", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void drain()", "full_signature": "private void drain()", "class_method_signature": "ReactorSerializedInvoker.drain()", "testcase": false, "constructor": false}, {"identifier": "drainOnShutdown", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void drainOnShutdown()", "full_signature": "private void drainOnShutdown()", "class_method_signature": "ReactorSerializedInvoker.drainOnShutdown()", "testcase": false, "constructor": false}, {"identifier": "newBuilder", "parameters": "()", "modifiers": "public static", "return": "Builder<T>", "signature": "Builder<T> newBuilder()", "full_signature": "public static Builder<T> newBuilder()", "class_method_signature": "ReactorSerializedInvoker.newBuilder()", "testcase": false, "constructor": false}], "file": "titus-common/src/main/java/com/netflix/titus/common/util/rx/invoker/ReactorSerializedInvoker.java"}, "focal_method": {"identifier": "submit", "parameters": "(Mono<T> action)", "modifiers": "public", "return": "Mono<T>", "body": "public Mono<T> submit(Mono<T> action) {\n        Preconditions.checkState(!shutdownFlag, \"ReactorQueue has been shutdown\");\n        Preconditions.checkNotNull(action);\n\n        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n\n        return Mono.create(sink -> {\n            metrics.onSubmit();\n\n            ActionHandler actionHandler = new ActionHandler(action, sink, stackTrace);\n            if (!actionHandlers.offer(actionHandler)) {\n                metrics.onQueueFull();\n                sink.error(actionHandler.newException(new IllegalStateException(\"Queue is full\")));\n                return;\n            }\n            metrics.setQueueSize(actionHandlers.size());\n\n            if (shutdownFlag) {\n                actionHandler.terminate();\n            } else {\n                worker.schedule(this::drain);\n            }\n        });\n    }", "signature": "Mono<T> submit(Mono<T> action)", "full_signature": "public Mono<T> submit(Mono<T> action)", "class_method_signature": "ReactorSerializedInvoker.submit(Mono<T> action)", "testcase": false, "constructor": false, "invocations": ["checkState", "checkNotNull", "getStackTrace", "currentThread", "create", "onSubmit", "offer", "onQueueFull", "error", "newException", "setQueueSize", "size", "terminate", "schedule"]}, "repository": {"repo_id": 107330274, "url": "https://github.com/Netflix/titus-control-plane", "stars": 241, "created": "10/17/2017 10:20:55 PM +00:00", "updates": "2020-01-25T13:01:05+00:00", "fork": "False", "license": "licensed"}}