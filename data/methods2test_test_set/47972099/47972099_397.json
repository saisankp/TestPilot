{"test_class": {"identifier": "SimpleCheckpointStatsTrackerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Random RAND = new Random();", "modifier": "private static final", "type": "Random", "declarator": "RAND = new Random()", "var_name": "RAND"}], "file": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTrackerTest.java"}, "test_case": {"identifier": "testCompletedCheckpointReordering", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testCompletedCheckpointReordering() throws Exception {\n\t\tCompletedCheckpoint[] checkpoints = generateRandomCheckpoints(2);\n\t\tExecutionVertex[] tasksToWaitFor = createTasksToWaitFor(checkpoints[0]);\n\t\tCheckpointStatsTracker tracker = new SimpleCheckpointStatsTracker(10, tasksToWaitFor);\n\n\t\t// First the second checkpoint notifies\n\t\ttracker.onCompletedCheckpoint(checkpoints[1]);\n\t\tverifyJobStats(tracker, 10, new CompletedCheckpoint[] { checkpoints[1] });\n\t\tverifySubtaskStats(tracker, tasksToWaitFor, checkpoints[1]);\n\n\t\t// Then the first one\n\t\ttracker.onCompletedCheckpoint(checkpoints[0]);\n\t\tverifyJobStats(tracker, 10, checkpoints);\n\n\t\t// This should not alter the results for the subtasks\n\t\tverifySubtaskStats(tracker, tasksToWaitFor, checkpoints[1]);\n\t}", "signature": "void testCompletedCheckpointReordering()", "full_signature": "@Test public void testCompletedCheckpointReordering()", "class_method_signature": "SimpleCheckpointStatsTrackerTest.testCompletedCheckpointReordering()", "testcase": true, "constructor": false, "invocations": ["generateRandomCheckpoints", "createTasksToWaitFor", "onCompletedCheckpoint", "verifyJobStats", "verifySubtaskStats", "onCompletedCheckpoint", "verifyJobStats", "verifySubtaskStats"]}, "focal_class": {"identifier": "SimpleCheckpointStatsTracker", "superclass": "", "interfaces": "implements CheckpointStatsTracker", "fields": [{"original_string": "private final Object statsLock = new Object();", "modifier": "private final", "type": "Object", "declarator": "statsLock = new Object()", "var_name": "statsLock"}, {"original_string": "private final int historySize;", "modifier": "private final", "type": "int", "declarator": "historySize", "var_name": "historySize"}, {"original_string": "private final ArrayList<CheckpointStats> history = new ArrayList<>();", "modifier": "private final", "type": "ArrayList<CheckpointStats>", "declarator": "history = new ArrayList<>()", "var_name": "history"}, {"original_string": "private final Map<JobVertexID, Integer> taskParallelism;", "modifier": "private final", "type": "Map<JobVertexID, Integer>", "declarator": "taskParallelism", "var_name": "taskParallelism"}, {"original_string": "private Map<JobVertexID, long[][]> subTaskStats;", "modifier": "private", "type": "Map<JobVertexID, long[][]>", "declarator": "subTaskStats", "var_name": "subTaskStats"}, {"original_string": "private JobCheckpointStats lastJobStats;", "modifier": "private", "type": "JobCheckpointStats", "declarator": "lastJobStats", "var_name": "lastJobStats"}, {"original_string": "private Map<JobVertexID, OperatorCheckpointStats> operatorStatsCache = new HashMap<>();", "modifier": "private", "type": "Map<JobVertexID, OperatorCheckpointStats>", "declarator": "operatorStatsCache = new HashMap<>()", "var_name": "operatorStatsCache"}, {"original_string": "private long overallCount;", "modifier": "private", "type": "long", "declarator": "overallCount", "var_name": "overallCount"}, {"original_string": "private long overallMinDuration = Long.MAX_VALUE;", "modifier": "private", "type": "long", "declarator": "overallMinDuration = Long.MAX_VALUE", "var_name": "overallMinDuration"}, {"original_string": "private long overallMaxDuration = Long.MIN_VALUE;", "modifier": "private", "type": "long", "declarator": "overallMaxDuration = Long.MIN_VALUE", "var_name": "overallMaxDuration"}, {"original_string": "private long overallTotalDuration;", "modifier": "private", "type": "long", "declarator": "overallTotalDuration", "var_name": "overallTotalDuration"}, {"original_string": "private long overallMinStateSize = Long.MAX_VALUE;", "modifier": "private", "type": "long", "declarator": "overallMinStateSize = Long.MAX_VALUE", "var_name": "overallMinStateSize"}, {"original_string": "private long overallMaxStateSize = Long.MIN_VALUE;", "modifier": "private", "type": "long", "declarator": "overallMaxStateSize = Long.MIN_VALUE", "var_name": "overallMaxStateSize"}, {"original_string": "private long overallTotalStateSize;", "modifier": "private", "type": "long", "declarator": "overallTotalStateSize", "var_name": "overallTotalStateSize"}, {"original_string": "private CompletedCheckpoint latestCompletedCheckpoint;", "modifier": "private", "type": "CompletedCheckpoint", "declarator": "latestCompletedCheckpoint", "var_name": "latestCompletedCheckpoint"}], "methods": [{"identifier": "SimpleCheckpointStatsTracker", "parameters": "(\n\t\t\tint historySize,\n\t\t\tExecutionVertex[] tasksToWaitFor)", "modifiers": "public", "return": "", "signature": " SimpleCheckpointStatsTracker(\n\t\t\tint historySize,\n\t\t\tExecutionVertex[] tasksToWaitFor)", "full_signature": "public  SimpleCheckpointStatsTracker(\n\t\t\tint historySize,\n\t\t\tExecutionVertex[] tasksToWaitFor)", "class_method_signature": "SimpleCheckpointStatsTracker.SimpleCheckpointStatsTracker(\n\t\t\tint historySize,\n\t\t\tExecutionVertex[] tasksToWaitFor)", "testcase": false, "constructor": true}, {"identifier": "onCompletedCheckpoint", "parameters": "(CompletedCheckpoint checkpoint)", "modifiers": "@Override public", "return": "void", "signature": "void onCompletedCheckpoint(CompletedCheckpoint checkpoint)", "full_signature": "@Override public void onCompletedCheckpoint(CompletedCheckpoint checkpoint)", "class_method_signature": "SimpleCheckpointStatsTracker.onCompletedCheckpoint(CompletedCheckpoint checkpoint)", "testcase": false, "constructor": false}, {"identifier": "getJobStats", "parameters": "()", "modifiers": "@SuppressWarnings(\"unchecked\") @Override public", "return": "Option<JobCheckpointStats>", "signature": "Option<JobCheckpointStats> getJobStats()", "full_signature": "@SuppressWarnings(\"unchecked\") @Override public Option<JobCheckpointStats> getJobStats()", "class_method_signature": "SimpleCheckpointStatsTracker.getJobStats()", "testcase": false, "constructor": false}, {"identifier": "getOperatorStats", "parameters": "(JobVertexID operatorId)", "modifiers": "@Override public", "return": "Option<OperatorCheckpointStats>", "signature": "Option<OperatorCheckpointStats> getOperatorStats(JobVertexID operatorId)", "full_signature": "@Override public Option<OperatorCheckpointStats> getOperatorStats(JobVertexID operatorId)", "class_method_signature": "SimpleCheckpointStatsTracker.getOperatorStats(JobVertexID operatorId)", "testcase": false, "constructor": false}], "file": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java"}, "focal_method": {"identifier": "onCompletedCheckpoint", "parameters": "(CompletedCheckpoint checkpoint)", "modifiers": "@Override public", "return": "void", "body": "@Override\n\tpublic void onCompletedCheckpoint(CompletedCheckpoint checkpoint) {\n\t\t// Sanity check\n\t\tif (taskParallelism.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tsynchronized (statsLock) {\n\t\t\tlong overallStateSize = 0;\n\n\t\t\t// Operator stats\n\t\t\tMap<JobVertexID, long[][]> statsForSubTasks = new HashMap<>();\n\n\t\t\tfor (StateForTask state : checkpoint.getStates()) {\n\t\t\t\t// Job-level checkpoint size is sum of all state sizes\n\t\t\t\toverallStateSize += state.getStateSize();\n\n\t\t\t\t// Subtask stats\n\t\t\t\tJobVertexID opId = state.getOperatorId();\n\t\t\t\tlong[][] statsPerSubtask = statsForSubTasks.get(opId);\n\n\t\t\t\tif (statsPerSubtask == null) {\n\t\t\t\t\tint parallelism = taskParallelism.get(opId);\n\t\t\t\t\tstatsPerSubtask = new long[parallelism][2];\n\t\t\t\t\tstatsForSubTasks.put(opId, statsPerSubtask);\n\t\t\t\t}\n\n\t\t\t\tint subTaskIndex = state.getSubtask();\n\t\t\t\tif (subTaskIndex < statsPerSubtask.length) {\n\t\t\t\t\tstatsPerSubtask[subTaskIndex][0] = state.getDuration();\n\t\t\t\t\tstatsPerSubtask[subTaskIndex][1] = state.getStateSize();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// It is possible that completed checkpoints are added out of\n\t\t\t// order. Make sure that in this case the last completed\n\t\t\t// checkpoint is not updated.\n\t\t\tboolean isInOrder = latestCompletedCheckpoint != null &&\n\t\t\t\t\tcheckpoint.getCheckpointID() > latestCompletedCheckpoint.getCheckpointID();\n\n\t\t\t// Clear this in each case\n\t\t\tlastJobStats = null;\n\n\t\t\tif (overallCount == 0 || isInOrder) {\n\t\t\t\tlatestCompletedCheckpoint = checkpoint;\n\n\t\t\t\t// Clear cached stats\n\t\t\t\toperatorStatsCache.clear();\n\n\t\t\t\t// Update the stats per sub task\n\t\t\t\tsubTaskStats = statsForSubTasks;\n\t\t\t}\n\n\t\t\tlong checkpointId = checkpoint.getCheckpointID();\n\t\t\tlong checkpointTriggerTimestamp = checkpoint.getTimestamp();\n\t\t\tlong checkpointDuration = checkpoint.getDuration();\n\n\t\t\toverallCount++;\n\n\t\t\t// Duration stats\n\t\t\tif (checkpointDuration > overallMaxDuration) {\n\t\t\t\toverallMaxDuration = checkpointDuration;\n\t\t\t}\n\n\t\t\tif (checkpointDuration < overallMinDuration) {\n\t\t\t\toverallMinDuration = checkpointDuration;\n\t\t\t}\n\n\t\t\toverallTotalDuration += checkpointDuration;\n\n\t\t\t// State size stats\n\t\t\tif (overallStateSize < overallMinStateSize) {\n\t\t\t\toverallMinStateSize = overallStateSize;\n\t\t\t}\n\n\t\t\tif (overallStateSize > overallMaxStateSize) {\n\t\t\t\toverallMaxStateSize = overallStateSize;\n\t\t\t}\n\n\t\t\tthis.overallTotalStateSize += overallStateSize;\n\n\t\t\t// Recent history\n\t\t\tif (historySize > 0) {\n\t\t\t\tCheckpointStats stats = new CheckpointStats(\n\t\t\t\t\t\tcheckpointId,\n\t\t\t\t\t\tcheckpointTriggerTimestamp,\n\t\t\t\t\t\tcheckpointDuration,\n\t\t\t\t\t\toverallStateSize);\n\n\t\t\t\tif (isInOrder) {\n\t\t\t\t\tif (history.size() == historySize) {\n\t\t\t\t\t\thistory.remove(0);\n\t\t\t\t\t}\n\n\t\t\t\t\thistory.add(stats);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal int size = history.size();\n\n\t\t\t\t\t// Only remove it if it the new checkpoint is not too old\n\t\t\t\t\tif (size == historySize) {\n\t\t\t\t\t\tif (checkpointId > history.get(0).getCheckpointId()) {\n\t\t\t\t\t\t\thistory.remove(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint pos = 0;\n\n\t\t\t\t\t// Find position\n\t\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tpos = i;\n\n\t\t\t\t\t\tif (checkpointId < history.get(i).getCheckpointId()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\thistory.add(pos, stats);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "signature": "void onCompletedCheckpoint(CompletedCheckpoint checkpoint)", "full_signature": "@Override public void onCompletedCheckpoint(CompletedCheckpoint checkpoint)", "class_method_signature": "SimpleCheckpointStatsTracker.onCompletedCheckpoint(CompletedCheckpoint checkpoint)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "getStates", "getStateSize", "getOperatorId", "get", "get", "put", "getSubtask", "getDuration", "getStateSize", "getCheckpointID", "getCheckpointID", "clear", "getCheckpointID", "getTimestamp", "getDuration", "size", "remove", "add", "size", "getCheckpointId", "get", "remove", "getCheckpointId", "get", "add"]}, "repository": {"repo_id": 47972099, "url": "https://github.com/streamline-eu/ML-Pipelines", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 7, "size": 85537, "license": "licensed"}}