{"test_class": {"identifier": "PipelineFunctionFilterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String KNOWN_VALUE = \"some value\";", "modifier": "private static final", "type": "String", "declarator": "KNOWN_VALUE = \"some value\"", "var_name": "KNOWN_VALUE"}, {"original_string": "private static final PipelineElement KNOWN_INPUT = PipelineElement.resolved(KNOWN_VALUE);", "modifier": "private static final", "type": "PipelineElement", "declarator": "KNOWN_INPUT = PipelineElement.resolved(KNOWN_VALUE)", "var_name": "KNOWN_INPUT"}, {"original_string": "private final PipelineFunctionFilter underTest = new PipelineFunctionFilter();", "modifier": "private final", "type": "PipelineFunctionFilter", "declarator": "underTest = new PipelineFunctionFilter()", "var_name": "underTest"}, {"original_string": "@Mock\n    private ExpressionResolver expressionResolver;", "modifier": "@Mock\n    private", "type": "ExpressionResolver", "declarator": "expressionResolver", "var_name": "expressionResolver"}], "file": "model/placeholders/src/test/java/org/eclipse/ditto/model/placeholders/PipelineFunctionFilterTest.java"}, "test_case": {"identifier": "filterFailsWithOneUnresolvedValue", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void filterFailsWithOneUnresolvedValue() {\n        final String params = String.format(\"(%s,\\\"%s\\\",%s)\", \"header:reply-to\", \"like\", \"header:some-header\");\n\n        when(expressionResolver.resolveAsPipelineElement(\"header:reply-to\"))\n                .thenReturn(PipelineElement.resolved(\"true\"));\n        when(expressionResolver.resolveAsPipelineElement(\"header:some-header\"))\n                .thenReturn(PipelineElement.unresolved());\n        assertThat(underTest.apply(KNOWN_INPUT, params, expressionResolver)).isEmpty();\n\n        when(expressionResolver.resolveAsPipelineElement(\"header:reply-to\"))\n                .thenReturn(PipelineElement.unresolved());\n        when(expressionResolver.resolveAsPipelineElement(\"header:some-header\"))\n                .thenReturn(PipelineElement.resolved(\"*2?7\"));\n        assertThat(underTest.apply(KNOWN_INPUT, params, expressionResolver)).isEmpty();\n    }", "signature": "void filterFailsWithOneUnresolvedValue()", "full_signature": "@Test public void filterFailsWithOneUnresolvedValue()", "class_method_signature": "PipelineFunctionFilterTest.filterFailsWithOneUnresolvedValue()", "testcase": true, "constructor": false, "invocations": ["format", "thenReturn", "when", "resolveAsPipelineElement", "resolved", "thenReturn", "when", "resolveAsPipelineElement", "unresolved", "isEmpty", "assertThat", "apply", "thenReturn", "when", "resolveAsPipelineElement", "unresolved", "thenReturn", "when", "resolveAsPipelineElement", "resolved", "isEmpty", "assertThat", "apply"]}, "focal_class": {"identifier": "PipelineFunctionFilter", "superclass": "", "interfaces": "implements PipelineFunction", "fields": [{"original_string": "private static final String FUNCTION_NAME = \"filter\";", "modifier": "private static final", "type": "String", "declarator": "FUNCTION_NAME = \"filter\"", "var_name": "FUNCTION_NAME"}], "methods": [{"identifier": "getName", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getName()", "full_signature": "@Override public String getName()", "class_method_signature": "PipelineFunctionFilter.getName()", "testcase": false, "constructor": false}, {"identifier": "getSignature", "parameters": "()", "modifiers": "@Override public", "return": "Signature", "signature": "Signature getSignature()", "full_signature": "@Override public Signature getSignature()", "class_method_signature": "PipelineFunctionFilter.getSignature()", "testcase": false, "constructor": false}, {"identifier": "apply", "parameters": "(final PipelineElement value, final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "modifiers": "@Override public", "return": "PipelineElement", "signature": "PipelineElement apply(final PipelineElement value, final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "full_signature": "@Override public PipelineElement apply(final PipelineElement value, final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "class_method_signature": "PipelineFunctionFilter.apply(final PipelineElement value, final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "testcase": false, "constructor": false}, {"identifier": "parseAndResolve", "parameters": "(final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "modifiers": "private", "return": "Map<String, String>", "signature": "Map<String, String> parseAndResolve(final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "full_signature": "private Map<String, String> parseAndResolve(final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "class_method_signature": "PipelineFunctionFilter.parseAndResolve(final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "testcase": false, "constructor": false}], "file": "model/placeholders/src/main/java/org/eclipse/ditto/model/placeholders/PipelineFunctionFilter.java"}, "focal_method": {"identifier": "apply", "parameters": "(final PipelineElement value, final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "modifiers": "@Override public", "return": "PipelineElement", "body": "@Override\n    public PipelineElement apply(final PipelineElement value, final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver) {\n\n        final Map<String, String> parameters = parseAndResolve(paramsIncludingParentheses, expressionResolver);\n\n        return value.onResolved(valueThatShouldBeFilteredConditionally -> {\n\n            final Optional<FilterFunction> rqlFunctionOpt =\n                    FilterFunctions.fromName(parameters.get(RqlFunctionParam.NAME));\n            final boolean shouldKeepValue = rqlFunctionOpt.map(rqlFunction -> {\n                final String filterValue = parameters.get(FilterValueParam.NAME);\n                final String comparedValue = parameters.get(ComparedValueParam.NAME);\n                return rqlFunction.apply(filterValue, comparedValue);\n            }).orElse(false);\n\n\n            if (shouldKeepValue) {\n                return PipelineElement.resolved(valueThatShouldBeFilteredConditionally);\n            } else {\n                return PipelineElement.unresolved();\n            }\n\n        });\n    }", "signature": "PipelineElement apply(final PipelineElement value, final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "full_signature": "@Override public PipelineElement apply(final PipelineElement value, final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "class_method_signature": "PipelineFunctionFilter.apply(final PipelineElement value, final String paramsIncludingParentheses,\n            final ExpressionResolver expressionResolver)", "testcase": false, "constructor": false, "invocations": ["parseAndResolve", "onResolved", "fromName", "get", "orElse", "map", "get", "get", "apply", "resolved", "unresolved"]}, "repository": {"repo_id": 87849739, "url": "https://github.com/eclipse/ditto", "stars": 139, "created": "4/10/2017 7:29:57 PM +00:00", "updates": "2020-01-27T14:02:39+00:00", "fork": "False", "license": "licensed"}}