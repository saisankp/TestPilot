{"test_class": {"identifier": "CellSkipFilterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String ROW1KEY = \"row1\";", "modifier": "private static final", "type": "String", "declarator": "ROW1KEY = \"row1\"", "var_name": "ROW1KEY"}, {"original_string": "private static final String ROW2KEY = \"row2\";", "modifier": "private static final", "type": "String", "declarator": "ROW2KEY = \"row2\"", "var_name": "ROW2KEY"}, {"original_string": "private static final String FAM1KEY = \"fam1\";", "modifier": "private static final", "type": "String", "declarator": "FAM1KEY = \"fam1\"", "var_name": "FAM1KEY"}, {"original_string": "private static final String COL1KEY = \"col1\";", "modifier": "private static final", "type": "String", "declarator": "COL1KEY = \"col1\"", "var_name": "COL1KEY"}, {"original_string": "private static final String FAM2KEY = \"fam2\";", "modifier": "private static final", "type": "String", "declarator": "FAM2KEY = \"fam2\"", "var_name": "FAM2KEY"}, {"original_string": "private static final String COL2KEY = \"col2\";", "modifier": "private static final", "type": "String", "declarator": "COL2KEY = \"col2\"", "var_name": "COL2KEY"}, {"original_string": "private static final String VALUE = \"value\";", "modifier": "private static final", "type": "String", "declarator": "VALUE = \"value\"", "var_name": "VALUE"}], "file": "tephra-hbase-compat-0.96/src/test/java/co/cask/tephra/hbase96/coprocessor/CellSkipFilterTest.java"}, "test_case": {"identifier": "testSkipFiltering", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testSkipFiltering() throws Exception {\n    long timestamp = System.currentTimeMillis();\n    // Test to check that we get NEXT_COL once the INCLUDE_AND_NEXT_COL is returned for the same key\n    Filter filter = new CellSkipFilter(new MyFilter(0));\n    assertEquals(Filter.ReturnCode.INCLUDE, filter.filterKeyValue(newKeyValue(ROW1KEY, FAM1KEY, COL1KEY, VALUE,\n                                                                              timestamp)));\n    assertEquals(Filter.ReturnCode.INCLUDE_AND_NEXT_COL, filter.filterKeyValue(newKeyValue(ROW1KEY, FAM1KEY, COL1KEY,\n                                                                                           VALUE, timestamp - 1)));\n\n    // Next call should get NEXT_COL instead of SKIP, as it would be returned by CellSkipFilter\n    assertEquals(Filter.ReturnCode.NEXT_COL, filter.filterKeyValue(newKeyValue(ROW1KEY, FAM1KEY, COL1KEY, VALUE,\n                                                                               timestamp - 2)));\n\n    // Next call with the same key should return the NEXT_COL again, as it would be returned by CellSkipFilter\n    assertEquals(Filter.ReturnCode.NEXT_COL, filter.filterKeyValue(newKeyValue(ROW1KEY, FAM1KEY, COL1KEY, VALUE,\n                                                                               timestamp - 3)));\n\n    // Since MyFilter counter is not incremented in the previous call, filtering for the different keyvalue should\n    // give SKIP from MyFilter\n    assertEquals(Filter.ReturnCode.SKIP, filter.filterKeyValue(newKeyValue(ROW1KEY, FAM2KEY, COL1KEY, VALUE,\n                                                                           timestamp - 4)));\n\n    // Test to check that we get NEXT_COL once the NEXT_COL is returned for the same key\n    filter = new CellSkipFilter(new MyFilter(2));\n    assertEquals(Filter.ReturnCode.SKIP, filter.filterKeyValue(newKeyValue(ROW1KEY, FAM1KEY, COL1KEY, VALUE,\n                                                                           timestamp)));\n    assertEquals(Filter.ReturnCode.NEXT_COL, filter.filterKeyValue(newKeyValue(ROW1KEY, FAM1KEY, COL1KEY, VALUE,\n                                                                               timestamp - 1)));\n\n    // Next call should get NEXT_COL instead of NEXT_ROW, as it would be returned by CellSkipFilter\n    assertEquals(Filter.ReturnCode.NEXT_COL, filter.filterKeyValue(newKeyValue(ROW1KEY, FAM1KEY, COL1KEY, VALUE,\n                                                                               timestamp - 2)));\n\n    // Next call with the same key should return the NEXT_COL again, as it would be returned by CellSkipFilter\n    assertEquals(Filter.ReturnCode.NEXT_COL, filter.filterKeyValue(newKeyValue(ROW1KEY, FAM1KEY, COL1KEY, VALUE,\n                                                                               timestamp - 3)));\n\n    // Since MyFilter counter is not incremented in the previous call, filtering for the different keyvalue should\n    // give NEXT_ROW from MyFilter\n    assertEquals(Filter.ReturnCode.NEXT_ROW, filter.filterKeyValue(newKeyValue(ROW1KEY, FAM1KEY, COL2KEY, VALUE,\n                                                                               timestamp - 4)));\n\n    // Next call with the new key should returned the SEEK_NEXT_USING_HINT\n    assertEquals(Filter.ReturnCode.SEEK_NEXT_USING_HINT, filter.filterKeyValue(newKeyValue(ROW2KEY, FAM1KEY, COL1KEY,\n                                                                                           VALUE, timestamp - 5)));\n  }", "signature": "void testSkipFiltering()", "full_signature": "@Test public void testSkipFiltering()", "class_method_signature": "CellSkipFilterTest.testSkipFiltering()", "testcase": true, "constructor": false, "invocations": ["currentTimeMillis", "assertEquals", "filterKeyValue", "newKeyValue", "assertEquals", "filterKeyValue", "newKeyValue", "assertEquals", "filterKeyValue", "newKeyValue", "assertEquals", "filterKeyValue", "newKeyValue", "assertEquals", "filterKeyValue", "newKeyValue", "assertEquals", "filterKeyValue", "newKeyValue", "assertEquals", "filterKeyValue", "newKeyValue", "assertEquals", "filterKeyValue", "newKeyValue", "assertEquals", "filterKeyValue", "newKeyValue", "assertEquals", "filterKeyValue", "newKeyValue", "assertEquals", "filterKeyValue", "newKeyValue"]}, "focal_class": {"identifier": "CellSkipFilter", "superclass": "extends FilterBase", "interfaces": "", "fields": [{"original_string": "private final Filter filter;", "modifier": "private final", "type": "Filter", "declarator": "filter", "var_name": "filter"}, {"original_string": "private KeyValue skipColumn = null;", "modifier": "private", "type": "KeyValue", "declarator": "skipColumn = null", "var_name": "skipColumn"}], "methods": [{"identifier": "CellSkipFilter", "parameters": "(Filter filter)", "modifiers": "public", "return": "", "signature": " CellSkipFilter(Filter filter)", "full_signature": "public  CellSkipFilter(Filter filter)", "class_method_signature": "CellSkipFilter.CellSkipFilter(Filter filter)", "testcase": false, "constructor": true}, {"identifier": "skipCellVersion", "parameters": "(Cell cell)", "modifiers": "private", "return": "boolean", "signature": "boolean skipCellVersion(Cell cell)", "full_signature": "private boolean skipCellVersion(Cell cell)", "class_method_signature": "CellSkipFilter.skipCellVersion(Cell cell)", "testcase": false, "constructor": false}, {"identifier": "filterKeyValue", "parameters": "(Cell cell)", "modifiers": "@Override public", "return": "ReturnCode", "signature": "ReturnCode filterKeyValue(Cell cell)", "full_signature": "@Override public ReturnCode filterKeyValue(Cell cell)", "class_method_signature": "CellSkipFilter.filterKeyValue(Cell cell)", "testcase": false, "constructor": false}, {"identifier": "filterRow", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean filterRow()", "full_signature": "@Override public boolean filterRow()", "class_method_signature": "CellSkipFilter.filterRow()", "testcase": false, "constructor": false}, {"identifier": "transformCell", "parameters": "(Cell cell)", "modifiers": "@Override public", "return": "Cell", "signature": "Cell transformCell(Cell cell)", "full_signature": "@Override public Cell transformCell(Cell cell)", "class_method_signature": "CellSkipFilter.transformCell(Cell cell)", "testcase": false, "constructor": false}, {"identifier": "reset", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void reset()", "full_signature": "@Override public void reset()", "class_method_signature": "CellSkipFilter.reset()", "testcase": false, "constructor": false}, {"identifier": "filterRowKey", "parameters": "(byte[] buffer, int offset, int length)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean filterRowKey(byte[] buffer, int offset, int length)", "full_signature": "@Override public boolean filterRowKey(byte[] buffer, int offset, int length)", "class_method_signature": "CellSkipFilter.filterRowKey(byte[] buffer, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "filterAllRemaining", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean filterAllRemaining()", "full_signature": "@Override public boolean filterAllRemaining()", "class_method_signature": "CellSkipFilter.filterAllRemaining()", "testcase": false, "constructor": false}, {"identifier": "filterRowCells", "parameters": "(List<Cell> kvs)", "modifiers": "@Override public", "return": "void", "signature": "void filterRowCells(List<Cell> kvs)", "full_signature": "@Override public void filterRowCells(List<Cell> kvs)", "class_method_signature": "CellSkipFilter.filterRowCells(List<Cell> kvs)", "testcase": false, "constructor": false}, {"identifier": "hasFilterRow", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean hasFilterRow()", "full_signature": "@Override public boolean hasFilterRow()", "class_method_signature": "CellSkipFilter.hasFilterRow()", "testcase": false, "constructor": false}, {"identifier": "getNextKeyHint", "parameters": "(KeyValue currentKV)", "modifiers": "@SuppressWarnings(\"deprecation\") @Override public", "return": "KeyValue", "signature": "KeyValue getNextKeyHint(KeyValue currentKV)", "full_signature": "@SuppressWarnings(\"deprecation\") @Override public KeyValue getNextKeyHint(KeyValue currentKV)", "class_method_signature": "CellSkipFilter.getNextKeyHint(KeyValue currentKV)", "testcase": false, "constructor": false}, {"identifier": "getNextCellHint", "parameters": "(Cell currentKV)", "modifiers": "@Override public", "return": "Cell", "signature": "Cell getNextCellHint(Cell currentKV)", "full_signature": "@Override public Cell getNextCellHint(Cell currentKV)", "class_method_signature": "CellSkipFilter.getNextCellHint(Cell currentKV)", "testcase": false, "constructor": false}, {"identifier": "isFamilyEssential", "parameters": "(byte[] name)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isFamilyEssential(byte[] name)", "full_signature": "@Override public boolean isFamilyEssential(byte[] name)", "class_method_signature": "CellSkipFilter.isFamilyEssential(byte[] name)", "testcase": false, "constructor": false}, {"identifier": "toByteArray", "parameters": "()", "modifiers": "@Override public", "return": "byte[]", "signature": "byte[] toByteArray()", "full_signature": "@Override public byte[] toByteArray()", "class_method_signature": "CellSkipFilter.toByteArray()", "testcase": false, "constructor": false}], "file": "tephra-hbase-compat-0.96/src/main/java/co/cask/tephra/hbase96/coprocessor/CellSkipFilter.java"}, "focal_method": {"identifier": "filterKeyValue", "parameters": "(Cell cell)", "modifiers": "@Override public", "return": "ReturnCode", "body": "@Override\n  public ReturnCode filterKeyValue(Cell cell) throws IOException {\n    if (skipCellVersion(cell)) {\n      return ReturnCode.NEXT_COL;\n    }\n\n    ReturnCode code = filter.filterKeyValue(cell);\n    if (code == ReturnCode.NEXT_COL || code == ReturnCode.INCLUDE_AND_NEXT_COL) {\n      // only store the reference to the keyvalue if we are returning NEXT_COL or INCLUDE_AND_NEXT_COL\n      skipColumn = KeyValue.createFirstOnRow(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(),\n                                               cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),\n                                               cell.getQualifierArray(), cell.getQualifierOffset(),\n                                               cell.getQualifierLength());\n    } else {\n      skipColumn = null;\n    }\n    return code;\n  }", "signature": "ReturnCode filterKeyValue(Cell cell)", "full_signature": "@Override public ReturnCode filterKeyValue(Cell cell)", "class_method_signature": "CellSkipFilter.filterKeyValue(Cell cell)", "testcase": false, "constructor": false, "invocations": ["skipCellVersion", "filterKeyValue", "createFirstOnRow", "getRowArray", "getRowOffset", "getRowLength", "getFamilyArray", "getFamilyOffset", "getFamilyLength", "getQualifierArray", "getQualifierOffset", "getQualifierLength"]}, "repository": {"repo_id": 21894018, "url": "https://github.com/cdapio/tephra", "language": "Java", "is_fork": false, "fork_count": 43, "stargazer_count": 157, "size": 1415, "license": "licensed"}}