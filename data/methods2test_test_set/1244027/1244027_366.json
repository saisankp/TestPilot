{"test_class": {"identifier": "TimeBasedKeysTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "protected TimeBasedKeys counter = TimeBasedKeys.create();", "modifier": "protected", "type": "TimeBasedKeys", "declarator": "counter = TimeBasedKeys.create()", "var_name": "counter"}, {"original_string": "private boolean print;", "modifier": "private", "type": "boolean", "declarator": "print", "var_name": "print"}], "file": "modeshape-common/src/test/java/org/modeshape/common/util/TimeBasedKeysTest.java"}, "test_case": {"identifier": "shouldObtain10MillionCountersFromThreadSafeUsingMultipleThreads", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldObtain10MillionCountersFromThreadSafeUsingMultipleThreads() {\n        print(counter.nextKey());\n        for (int j = 0; j != 100; ++j) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i = 0; i != 100000; ++i) {\n                        counter.nextKey();\n                    }\n                }\n            }).run();\n        }\n        print(counter.nextKey());\n    }", "signature": "void shouldObtain10MillionCountersFromThreadSafeUsingMultipleThreads()", "full_signature": "@Test public void shouldObtain10MillionCountersFromThreadSafeUsingMultipleThreads()", "class_method_signature": "TimeBasedKeysTest.shouldObtain10MillionCountersFromThreadSafeUsingMultipleThreads()", "testcase": true, "constructor": false, "invocations": ["print", "nextKey", "run", "nextKey", "print", "nextKey"]}, "focal_class": {"identifier": "TimeBasedKeys", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final short DEFAULT_BITS_IN_COUNTER = 16;", "modifier": "public static final", "type": "short", "declarator": "DEFAULT_BITS_IN_COUNTER = 16", "var_name": "DEFAULT_BITS_IN_COUNTER"}, {"original_string": "private final short counterBits;", "modifier": "private final", "type": "short", "declarator": "counterBits", "var_name": "counterBits"}, {"original_string": "private final long maximumCounterValue;", "modifier": "private final", "type": "long", "declarator": "maximumCounterValue", "var_name": "maximumCounterValue"}, {"original_string": "@GuardedBy( \"this\" )\n    private volatile long lastMillis;", "modifier": "@GuardedBy( \"this\" )\n    private volatile", "type": "long", "declarator": "lastMillis", "var_name": "lastMillis"}, {"original_string": "@GuardedBy( \"this\" )\n    private volatile int counter;", "modifier": "@GuardedBy( \"this\" )\n    private volatile", "type": "int", "declarator": "counter", "var_name": "counter"}], "methods": [{"identifier": "create", "parameters": "()", "modifiers": "public static", "return": "TimeBasedKeys", "signature": "TimeBasedKeys create()", "full_signature": "public static TimeBasedKeys create()", "class_method_signature": "TimeBasedKeys.create()", "testcase": false, "constructor": false}, {"identifier": "create", "parameters": "( int bitsUsedInCounter )", "modifiers": "public static", "return": "TimeBasedKeys", "signature": "TimeBasedKeys create( int bitsUsedInCounter )", "full_signature": "public static TimeBasedKeys create( int bitsUsedInCounter )", "class_method_signature": "TimeBasedKeys.create( int bitsUsedInCounter )", "testcase": false, "constructor": false}, {"identifier": "TimeBasedKeys", "parameters": "( short bitsUsedInCounter )", "modifiers": "protected", "return": "", "signature": " TimeBasedKeys( short bitsUsedInCounter )", "full_signature": "protected  TimeBasedKeys( short bitsUsedInCounter )", "class_method_signature": "TimeBasedKeys.TimeBasedKeys( short bitsUsedInCounter )", "testcase": false, "constructor": true}, {"identifier": "nextKey", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long nextKey()", "full_signature": "public long nextKey()", "class_method_signature": "TimeBasedKeys.nextKey()", "testcase": false, "constructor": false}, {"identifier": "getCounterStartingAt", "parameters": "( long millisInUtc )", "modifiers": "public", "return": "long", "signature": "long getCounterStartingAt( long millisInUtc )", "full_signature": "public long getCounterStartingAt( long millisInUtc )", "class_method_signature": "TimeBasedKeys.getCounterStartingAt( long millisInUtc )", "testcase": false, "constructor": false}, {"identifier": "getCounterEndingAt", "parameters": "( long millisInUtc )", "modifiers": "public", "return": "long", "signature": "long getCounterEndingAt( long millisInUtc )", "full_signature": "public long getCounterEndingAt( long millisInUtc )", "class_method_signature": "TimeBasedKeys.getCounterEndingAt( long millisInUtc )", "testcase": false, "constructor": false}, {"identifier": "getCounterEndingAfter", "parameters": "( long millisInUtc )", "modifiers": "public", "return": "long", "signature": "long getCounterEndingAfter( long millisInUtc )", "full_signature": "public long getCounterEndingAfter( long millisInUtc )", "class_method_signature": "TimeBasedKeys.getCounterEndingAfter( long millisInUtc )", "testcase": false, "constructor": false}, {"identifier": "getTimeGenerated", "parameters": "( long key )", "modifiers": "public", "return": "long", "signature": "long getTimeGenerated( long key )", "full_signature": "public long getTimeGenerated( long key )", "class_method_signature": "TimeBasedKeys.getTimeGenerated( long key )", "testcase": false, "constructor": false}, {"identifier": "counterFor", "parameters": "( long timestamp )", "modifiers": "private synchronized", "return": "int", "signature": "int counterFor( long timestamp )", "full_signature": "private synchronized int counterFor( long timestamp )", "class_method_signature": "TimeBasedKeys.counterFor( long timestamp )", "testcase": false, "constructor": false}], "file": "modeshape-common/src/main/java/org/modeshape/common/util/TimeBasedKeys.java"}, "focal_method": {"identifier": "nextKey", "parameters": "()", "modifiers": "public", "return": "long", "body": "public long nextKey() {\n        // Note that per Oracle the currentTimeMillis is the current number of seconds past the epoch\n        // in UTC (not in local time). Therefore, processes with exactly synchronized clocks will\n        // always get the same value regardless of their timezone ...\n        final long timestamp = System.currentTimeMillis();\n        final int increment = counterFor(timestamp);\n        if (increment <= maximumCounterValue) {\n            return (timestamp << counterBits) + increment;\n        }\n        // The counter is surprisingly too high, so try again (repeatedly) until we get to the next millisecond ...\n        return this.nextKey();\n    }", "signature": "long nextKey()", "full_signature": "public long nextKey()", "class_method_signature": "TimeBasedKeys.nextKey()", "testcase": false, "constructor": false, "invocations": ["currentTimeMillis", "counterFor", "nextKey"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}