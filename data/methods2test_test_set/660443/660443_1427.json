{"test_class": {"identifier": "InductivePartialChargesTest", "superclass": "extends CDKTestCase", "interfaces": "", "fields": [{"original_string": "private static IAtomContainer mol;", "modifier": "private static", "type": "IAtomContainer", "declarator": "mol", "var_name": "mol"}], "file": "tool/charges/src/test/java/org/openscience/cdk/charges/InductivePartialChargesTest.java"}, "test_case": {"identifier": "testGetAtomicSoftness", "parameters": "()", "modifiers": "@Ignore @Test public", "return": "void", "body": "@Ignore\n    @Test\n    public void testGetAtomicSoftness() throws Exception {\n        InductivePartialCharges ipc = new InductivePartialCharges();\n        double softness = ipc.getAtomicSoftnessCore(mol, 0);\n        Assert.fail(\"Not validated - need known values\");\n    }", "signature": "void testGetAtomicSoftness()", "full_signature": "@Ignore @Test public void testGetAtomicSoftness()", "class_method_signature": "InductivePartialChargesTest.testGetAtomicSoftness()", "testcase": true, "constructor": false, "invocations": ["getAtomicSoftnessCore", "fail"]}, "focal_class": {"identifier": "InductivePartialCharges", "superclass": "", "interfaces": "implements IChargeCalculator", "fields": [{"original_string": "private static double[]     pauling;", "modifier": "private static", "type": "double[]", "declarator": "pauling", "var_name": "pauling"}, {"original_string": "private IsotopeFactory      ifac    = null;", "modifier": "private", "type": "IsotopeFactory", "declarator": "ifac    = null", "var_name": "ifac"}, {"original_string": "private AtomTypeFactory     factory = null;", "modifier": "private", "type": "AtomTypeFactory", "declarator": "factory = null", "var_name": "factory"}, {"original_string": "private static ILoggingTool logger  = LoggingToolFactory.createLoggingTool(InductivePartialCharges.class);", "modifier": "private static", "type": "ILoggingTool", "declarator": "logger  = LoggingToolFactory.createLoggingTool(InductivePartialCharges.class)", "var_name": "logger"}], "methods": [{"identifier": "InductivePartialCharges", "parameters": "()", "modifiers": "public", "return": "", "signature": " InductivePartialCharges()", "full_signature": "public  InductivePartialCharges()", "class_method_signature": "InductivePartialCharges.InductivePartialCharges()", "testcase": false, "constructor": true}, {"identifier": "assignInductivePartialCharges", "parameters": "(IAtomContainer ac)", "modifiers": "public", "return": "IAtomContainer", "signature": "IAtomContainer assignInductivePartialCharges(IAtomContainer ac)", "full_signature": "public IAtomContainer assignInductivePartialCharges(IAtomContainer ac)", "class_method_signature": "InductivePartialCharges.assignInductivePartialCharges(IAtomContainer ac)", "testcase": false, "constructor": false}, {"identifier": "calculateCharges", "parameters": "(IAtomContainer container)", "modifiers": "@Override public", "return": "void", "signature": "void calculateCharges(IAtomContainer container)", "full_signature": "@Override public void calculateCharges(IAtomContainer container)", "class_method_signature": "InductivePartialCharges.calculateCharges(IAtomContainer container)", "testcase": false, "constructor": false}, {"identifier": "getPaulingElectronegativities", "parameters": "(IAtomContainer ac, boolean modified)", "modifiers": "public", "return": "double[]", "signature": "double[] getPaulingElectronegativities(IAtomContainer ac, boolean modified)", "full_signature": "public double[] getPaulingElectronegativities(IAtomContainer ac, boolean modified)", "class_method_signature": "InductivePartialCharges.getPaulingElectronegativities(IAtomContainer ac, boolean modified)", "testcase": false, "constructor": false}, {"identifier": "getAtomicSoftnessCore", "parameters": "(IAtomContainer ac, int atomPosition)", "modifiers": "public", "return": "double", "signature": "double getAtomicSoftnessCore(IAtomContainer ac, int atomPosition)", "full_signature": "public double getAtomicSoftnessCore(IAtomContainer ac, int atomPosition)", "class_method_signature": "InductivePartialCharges.getAtomicSoftnessCore(IAtomContainer ac, int atomPosition)", "testcase": false, "constructor": false}, {"identifier": "getAtomicChargeIncrement", "parameters": "(IAtomContainer ac, int atomPosition, double[] ElEn, int as)", "modifiers": "private", "return": "double", "signature": "double getAtomicChargeIncrement(IAtomContainer ac, int atomPosition, double[] ElEn, int as)", "full_signature": "private double getAtomicChargeIncrement(IAtomContainer ac, int atomPosition, double[] ElEn, int as)", "class_method_signature": "InductivePartialCharges.getAtomicChargeIncrement(IAtomContainer ac, int atomPosition, double[] ElEn, int as)", "testcase": false, "constructor": false}, {"identifier": "getCovalentRadius", "parameters": "(String symbol, IBond.Order maxBondOrder)", "modifiers": "private", "return": "double", "signature": "double getCovalentRadius(String symbol, IBond.Order maxBondOrder)", "full_signature": "private double getCovalentRadius(String symbol, IBond.Order maxBondOrder)", "class_method_signature": "InductivePartialCharges.getCovalentRadius(String symbol, IBond.Order maxBondOrder)", "testcase": false, "constructor": false}, {"identifier": "calculateSquaredDistanceBetweenTwoAtoms", "parameters": "(IAtom atom1, IAtom atom2)", "modifiers": "private", "return": "double", "signature": "double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2)", "full_signature": "private double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2)", "class_method_signature": "InductivePartialCharges.calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2)", "testcase": false, "constructor": false}], "file": "tool/charges/src/main/java/org/openscience/cdk/charges/InductivePartialCharges.java"}, "focal_method": {"identifier": "getAtomicSoftnessCore", "parameters": "(IAtomContainer ac, int atomPosition)", "modifiers": "public", "return": "double", "body": "public double getAtomicSoftnessCore(IAtomContainer ac, int atomPosition) throws CDKException {\n        if (factory == null) {\n            factory = AtomTypeFactory\n                    .getInstance(\"org/openscience/cdk/config/data/jmol_atomtypes.txt\", ac.getBuilder());\n        }\n        IAtom target = null;\n        double core = 0;\n        double radiusTarget = 0;\n        target = ac.getAtom(atomPosition);\n        double partial = 0;\n        double radius = 0;\n        String symbol = null;\n        IAtomType type = null;\n        try {\n            symbol = ac.getAtom(atomPosition).getSymbol();\n            type = factory.getAtomType(symbol);\n            if (getCovalentRadius(symbol, ac.getMaximumBondOrder(target)) > 0) {\n                radiusTarget = getCovalentRadius(symbol, ac.getMaximumBondOrder(target));\n            } else {\n                radiusTarget = type.getCovalentRadius();\n            }\n\n        } catch (Exception ex1) {\n            logger.debug(ex1);\n            throw new CDKException(\"Problems with AtomTypeFactory due to \" + ex1.getMessage(), ex1);\n        }\n\n        Iterator<IAtom> atoms = ac.atoms().iterator();\n        while (atoms.hasNext()) {\n            IAtom atom = atoms.next();\n            if (!target.equals(atom)) {\n                symbol = atom.getSymbol();\n                partial = 0;\n                try {\n                    type = factory.getAtomType(symbol);\n                } catch (Exception ex1) {\n                    logger.debug(ex1);\n                    throw new CDKException(\"Problems with AtomTypeFactory due to \" + ex1.getMessage(), ex1);\n                }\n                if (getCovalentRadius(symbol, ac.getMaximumBondOrder(atom)) > 0) {\n                    radius = getCovalentRadius(symbol, ac.getMaximumBondOrder(atom));\n                } else {\n                    radius = type.getCovalentRadius();\n                }\n                partial += radius * radius;\n                partial += (radiusTarget * radiusTarget);\n                partial = partial / (calculateSquaredDistanceBetweenTwoAtoms(target, atom));\n                core += partial;\n            }\n        }\n        core = 2 * core;\n        core = 0.172 * core;\n        return core;\n    }", "signature": "double getAtomicSoftnessCore(IAtomContainer ac, int atomPosition)", "full_signature": "public double getAtomicSoftnessCore(IAtomContainer ac, int atomPosition)", "class_method_signature": "InductivePartialCharges.getAtomicSoftnessCore(IAtomContainer ac, int atomPosition)", "testcase": false, "constructor": false, "invocations": ["getInstance", "getBuilder", "getAtom", "getSymbol", "getAtom", "getAtomType", "getCovalentRadius", "getMaximumBondOrder", "getCovalentRadius", "getMaximumBondOrder", "getCovalentRadius", "debug", "getMessage", "iterator", "atoms", "hasNext", "next", "equals", "getSymbol", "getAtomType", "debug", "getMessage", "getCovalentRadius", "getMaximumBondOrder", "getCovalentRadius", "getMaximumBondOrder", "getCovalentRadius", "calculateSquaredDistanceBetweenTwoAtoms"]}, "repository": {"repo_id": 660443, "url": "https://github.com/cdk/cdk", "stars": 220, "created": "5/11/2010 8:30:07 AM +00:00", "updates": "2020-01-27T19:04:04+00:00", "fork": "False", "license": "licensed"}}