{"test_class": {"identifier": "JcrLockManagerTest", "superclass": "extends SingleUseAbstractTest", "interfaces": "", "fields": [], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/JcrLockManagerTest.java"}, "test_case": {"identifier": "shouldNotAllowLockOnTransientNode", "parameters": "()", "modifiers": "@Test @FixFor( \"MODE-2047\" ) public", "return": "void", "body": "@Test\n    @FixFor( \"MODE-2047\" )\n    public void shouldNotAllowLockOnTransientNode() throws Exception {\n        AbstractJcrNode testNode = session.getRootNode().addNode(\"test\");\n        testNode.addMixin(\"mix:lockable\");\n        JcrLockManager lockManager = session.lockManager();\n        try {\n            lockManager.lock(testNode, true, false, Long.MAX_VALUE, null);\n            fail(\"Transient nodes should not be locked\");\n        } catch (InvalidItemStateException e) {\n            // expected\n        }\n    }", "signature": "void shouldNotAllowLockOnTransientNode()", "full_signature": "@Test @FixFor( \"MODE-2047\" ) public void shouldNotAllowLockOnTransientNode()", "class_method_signature": "JcrLockManagerTest.shouldNotAllowLockOnTransientNode()", "testcase": true, "constructor": false, "invocations": ["addNode", "getRootNode", "addMixin", "lockManager", "lock", "fail"]}, "focal_class": {"identifier": "JcrLockManager", "superclass": "", "interfaces": "implements LockManager", "fields": [{"original_string": "private final JcrSession session;", "modifier": "private final", "type": "JcrSession", "declarator": "session", "var_name": "session"}, {"original_string": "private final RepositoryLockManager lockManager;", "modifier": "private final", "type": "RepositoryLockManager", "declarator": "lockManager", "var_name": "lockManager"}, {"original_string": "private final Set<String> lockTokens = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());", "modifier": "private final", "type": "Set<String>", "declarator": "lockTokens = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>())", "var_name": "lockTokens"}], "methods": [{"identifier": "JcrLockManager", "parameters": "( JcrSession session,\n                    RepositoryLockManager lockManager )", "modifiers": "", "return": "", "signature": " JcrLockManager( JcrSession session,\n                    RepositoryLockManager lockManager )", "full_signature": "  JcrLockManager( JcrSession session,\n                    RepositoryLockManager lockManager )", "class_method_signature": "JcrLockManager.JcrLockManager( JcrSession session,\n                    RepositoryLockManager lockManager )", "testcase": false, "constructor": true}, {"identifier": "hasLockToken", "parameters": "( String token )", "modifiers": "", "return": "boolean", "signature": "boolean hasLockToken( String token )", "full_signature": " boolean hasLockToken( String token )", "class_method_signature": "JcrLockManager.hasLockToken( String token )", "testcase": false, "constructor": false}, {"identifier": "cleanLocks", "parameters": "()", "modifiers": "final", "return": "void", "signature": "void cleanLocks()", "full_signature": "final void cleanLocks()", "class_method_signature": "JcrLockManager.cleanLocks()", "testcase": false, "constructor": false}, {"identifier": "addLockToken", "parameters": "( String lockToken )", "modifiers": "@Override public", "return": "void", "signature": "void addLockToken( String lockToken )", "full_signature": "@Override public void addLockToken( String lockToken )", "class_method_signature": "JcrLockManager.addLockToken( String lockToken )", "testcase": false, "constructor": false}, {"identifier": "removeLockToken", "parameters": "( String lockToken )", "modifiers": "@Override public", "return": "void", "signature": "void removeLockToken( String lockToken )", "full_signature": "@Override public void removeLockToken( String lockToken )", "class_method_signature": "JcrLockManager.removeLockToken( String lockToken )", "testcase": false, "constructor": false}, {"identifier": "lockTokens", "parameters": "()", "modifiers": "", "return": "Set<String>", "signature": "Set<String> lockTokens()", "full_signature": " Set<String> lockTokens()", "class_method_signature": "JcrLockManager.lockTokens()", "testcase": false, "constructor": false}, {"identifier": "getLockTokens", "parameters": "()", "modifiers": "@Override public", "return": "String[]", "signature": "String[] getLockTokens()", "full_signature": "@Override public String[] getLockTokens()", "class_method_signature": "JcrLockManager.getLockTokens()", "testcase": false, "constructor": false}, {"identifier": "isLocked", "parameters": "( String absPath )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isLocked( String absPath )", "full_signature": "@Override public boolean isLocked( String absPath )", "class_method_signature": "JcrLockManager.isLocked( String absPath )", "testcase": false, "constructor": false}, {"identifier": "isLocked", "parameters": "( AbstractJcrNode node )", "modifiers": "public", "return": "boolean", "signature": "boolean isLocked( AbstractJcrNode node )", "full_signature": "public boolean isLocked( AbstractJcrNode node )", "class_method_signature": "JcrLockManager.isLocked( AbstractJcrNode node )", "testcase": false, "constructor": false}, {"identifier": "getLock", "parameters": "( String absPath )", "modifiers": "@Override public", "return": "Lock", "signature": "Lock getLock( String absPath )", "full_signature": "@Override public Lock getLock( String absPath )", "class_method_signature": "JcrLockManager.getLock( String absPath )", "testcase": false, "constructor": false}, {"identifier": "getLock", "parameters": "( AbstractJcrNode node )", "modifiers": "public", "return": "Lock", "signature": "Lock getLock( AbstractJcrNode node )", "full_signature": "public Lock getLock( AbstractJcrNode node )", "class_method_signature": "JcrLockManager.getLock( AbstractJcrNode node )", "testcase": false, "constructor": false}, {"identifier": "getLockIfExists", "parameters": "( AbstractJcrNode node )", "modifiers": "public", "return": "Lock", "signature": "Lock getLockIfExists( AbstractJcrNode node )", "full_signature": "public Lock getLockIfExists( AbstractJcrNode node )", "class_method_signature": "JcrLockManager.getLockIfExists( AbstractJcrNode node )", "testcase": false, "constructor": false}, {"identifier": "getLowestLockAlongPath", "parameters": "(final AbstractJcrNode node, boolean skipExpiredLocks)", "modifiers": "private", "return": "ModeShapeLock", "signature": "ModeShapeLock getLowestLockAlongPath(final AbstractJcrNode node, boolean skipExpiredLocks)", "full_signature": "private ModeShapeLock getLowestLockAlongPath(final AbstractJcrNode node, boolean skipExpiredLocks)", "class_method_signature": "JcrLockManager.getLowestLockAlongPath(final AbstractJcrNode node, boolean skipExpiredLocks)", "testcase": false, "constructor": false}, {"identifier": "holdsLock", "parameters": "( String absPath )", "modifiers": "@Override public", "return": "boolean", "signature": "boolean holdsLock( String absPath )", "full_signature": "@Override public boolean holdsLock( String absPath )", "class_method_signature": "JcrLockManager.holdsLock( String absPath )", "testcase": false, "constructor": false}, {"identifier": "holdsLock", "parameters": "( AbstractJcrNode node )", "modifiers": "public", "return": "boolean", "signature": "boolean holdsLock( AbstractJcrNode node )", "full_signature": "public boolean holdsLock( AbstractJcrNode node )", "class_method_signature": "JcrLockManager.holdsLock( AbstractJcrNode node )", "testcase": false, "constructor": false}, {"identifier": "lock", "parameters": "( String absPath,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "modifiers": "@Override public", "return": "Lock", "signature": "Lock lock( String absPath,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "full_signature": "@Override public Lock lock( String absPath,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "class_method_signature": "JcrLockManager.lock( String absPath,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "testcase": false, "constructor": false}, {"identifier": "lock", "parameters": "( AbstractJcrNode node,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "modifiers": "public", "return": "Lock", "signature": "Lock lock( AbstractJcrNode node,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "full_signature": "public Lock lock( AbstractJcrNode node,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "class_method_signature": "JcrLockManager.lock( AbstractJcrNode node,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "testcase": false, "constructor": false}, {"identifier": "unlock", "parameters": "( String absPath )", "modifiers": "@Override public", "return": "void", "signature": "void unlock( String absPath )", "full_signature": "@Override public void unlock( String absPath )", "class_method_signature": "JcrLockManager.unlock( String absPath )", "testcase": false, "constructor": false}, {"identifier": "unlock", "parameters": "( AbstractJcrNode node )", "modifiers": "public", "return": "void", "signature": "void unlock( AbstractJcrNode node )", "full_signature": "public void unlock( AbstractJcrNode node )", "class_method_signature": "JcrLockManager.unlock( AbstractJcrNode node )", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/JcrLockManager.java"}, "focal_method": {"identifier": "lock", "parameters": "( String absPath,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "modifiers": "@Override public", "return": "Lock", "body": "@Override\n    public Lock lock( String absPath,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )\n        throws LockException, PathNotFoundException, AccessDeniedException, InvalidItemStateException, RepositoryException {\n        AbstractJcrNode node = session.node(session.absolutePathFor(absPath));\n        return lock(node, isDeep, isSessionScoped, timeoutHint, ownerInfo);\n    }", "signature": "Lock lock( String absPath,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "full_signature": "@Override public Lock lock( String absPath,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "class_method_signature": "JcrLockManager.lock( String absPath,\n                      boolean isDeep,\n                      boolean isSessionScoped,\n                      long timeoutHint,\n                      String ownerInfo )", "testcase": false, "constructor": false, "invocations": ["node", "absolutePathFor", "lock"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}