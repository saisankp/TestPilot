{"test_class": {"identifier": "PatchReaderTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final long BIG = 2048L * 1024L * 1024L;", "modifier": "private static final", "type": "long", "declarator": "BIG = 2048L * 1024L * 1024L", "var_name": "BIG"}, {"original_string": "private static final JreDeflateParameters DEFLATE_PARAMS = JreDeflateParameters.of(6, 0, true);", "modifier": "private static final", "type": "JreDeflateParameters", "declarator": "DEFLATE_PARAMS = JreDeflateParameters.of(6, 0, true)", "var_name": "DEFLATE_PARAMS"}, {"original_string": "private static final TypedRange<Void> OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE1 =\n      new TypedRange<Void>(BIG, 17L, null);", "modifier": "private static final", "type": "TypedRange<Void>", "declarator": "OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE1 =\n      new TypedRange<Void>(BIG, 17L, null)", "var_name": "OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE1"}, {"original_string": "private static final TypedRange<Void> OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE2 =\n      new TypedRange<Void>(BIG + 25L, 19L, null);", "modifier": "private static final", "type": "TypedRange<Void>", "declarator": "OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE2 =\n      new TypedRange<Void>(BIG + 25L, 19L, null)", "var_name": "OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE2"}, {"original_string": "private static final List<TypedRange<Void>> OLD_DELTA_FRIENDLY_UNCOMPRESS_PLAN =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE1, OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE2));", "modifier": "private static final", "type": "List<TypedRange<Void>>", "declarator": "OLD_DELTA_FRIENDLY_UNCOMPRESS_PLAN =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE1, OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE2))", "var_name": "OLD_DELTA_FRIENDLY_UNCOMPRESS_PLAN"}, {"original_string": "private static final TypedRange<JreDeflateParameters> NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE1 =\n      new TypedRange<JreDeflateParameters>(BIG, BIG, DEFLATE_PARAMS);", "modifier": "private static final", "type": "TypedRange<JreDeflateParameters>", "declarator": "NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE1 =\n      new TypedRange<JreDeflateParameters>(BIG, BIG, DEFLATE_PARAMS)", "var_name": "NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE1"}, {"original_string": "private static final TypedRange<JreDeflateParameters> NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE2 =\n      new TypedRange<JreDeflateParameters>(BIG * 2, BIG, DEFLATE_PARAMS);", "modifier": "private static final", "type": "TypedRange<JreDeflateParameters>", "declarator": "NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE2 =\n      new TypedRange<JreDeflateParameters>(BIG * 2, BIG, DEFLATE_PARAMS)", "var_name": "NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE2"}, {"original_string": "private static final List<TypedRange<JreDeflateParameters>> NEW_DELTA_FRIENDLY_RECOMPRESS_PLAN =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE1, NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE2));", "modifier": "private static final", "type": "List<TypedRange<JreDeflateParameters>>", "declarator": "NEW_DELTA_FRIENDLY_RECOMPRESS_PLAN =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE1, NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE2))", "var_name": "NEW_DELTA_FRIENDLY_RECOMPRESS_PLAN"}, {"original_string": "private static final long DELTA_FRIENDLY_OLD_FILE_SIZE = BIG - 75L;", "modifier": "private static final", "type": "long", "declarator": "DELTA_FRIENDLY_OLD_FILE_SIZE = BIG - 75L", "var_name": "DELTA_FRIENDLY_OLD_FILE_SIZE"}, {"original_string": "private static final long DELTA_FRIENDLY_NEW_FILE_SIZE = BIG + 75L;", "modifier": "private static final", "type": "long", "declarator": "DELTA_FRIENDLY_NEW_FILE_SIZE = BIG + 75L", "var_name": "DELTA_FRIENDLY_NEW_FILE_SIZE"}, {"original_string": "private static final TypedRange<Void> DELTA_FRIENDLY_OLD_FILE_WORK_RANGE =\n      new TypedRange<Void>(0, DELTA_FRIENDLY_OLD_FILE_SIZE, null);", "modifier": "private static final", "type": "TypedRange<Void>", "declarator": "DELTA_FRIENDLY_OLD_FILE_WORK_RANGE =\n      new TypedRange<Void>(0, DELTA_FRIENDLY_OLD_FILE_SIZE, null)", "var_name": "DELTA_FRIENDLY_OLD_FILE_WORK_RANGE"}, {"original_string": "private static final TypedRange<Void> DELTA_FRIENDLY_NEW_FILE_WORK_RANGE =\n      new TypedRange<Void>(0, DELTA_FRIENDLY_NEW_FILE_SIZE, null);", "modifier": "private static final", "type": "TypedRange<Void>", "declarator": "DELTA_FRIENDLY_NEW_FILE_WORK_RANGE =\n      new TypedRange<Void>(0, DELTA_FRIENDLY_NEW_FILE_SIZE, null)", "var_name": "DELTA_FRIENDLY_NEW_FILE_WORK_RANGE"}, {"original_string": "private static final String DELTA_CONTENT = \"all your delta are belong to us\";", "modifier": "private static final", "type": "String", "declarator": "DELTA_CONTENT = \"all your delta are belong to us\"", "var_name": "DELTA_CONTENT"}, {"original_string": "private static final DeltaDescriptor DELTA_DESCRIPTOR =\n      new DeltaDescriptor(\n          PatchConstants.DeltaFormat.BSDIFF,\n          DELTA_FRIENDLY_OLD_FILE_WORK_RANGE,\n          DELTA_FRIENDLY_NEW_FILE_WORK_RANGE,\n          DELTA_CONTENT.length());", "modifier": "private static final", "type": "DeltaDescriptor", "declarator": "DELTA_DESCRIPTOR =\n      new DeltaDescriptor(\n          PatchConstants.DeltaFormat.BSDIFF,\n          DELTA_FRIENDLY_OLD_FILE_WORK_RANGE,\n          DELTA_FRIENDLY_NEW_FILE_WORK_RANGE,\n          DELTA_CONTENT.length())", "var_name": "DELTA_DESCRIPTOR"}, {"original_string": "private static final List<DeltaDescriptor> DELTA_DESCRIPTORS =\n      Collections.singletonList(DELTA_DESCRIPTOR);", "modifier": "private static final", "type": "List<DeltaDescriptor>", "declarator": "DELTA_DESCRIPTORS =\n      Collections.singletonList(DELTA_DESCRIPTOR)", "var_name": "DELTA_DESCRIPTORS"}, {"original_string": "private Corruption corruption = null;", "modifier": "private", "type": "Corruption", "declarator": "corruption = null", "var_name": "corruption"}], "file": "feya/libraries/archive_diff/diff.applier/src/test/java/com/google/archivepatcher/applier/PatchReaderTest.java"}, "test_case": {"identifier": "testReadPatchApplyPlan_CorruptDeltaFriendlyNewFileRecompressionInstructionOffset", "parameters": "()", "modifiers": "@Test(expected = PatchFormatException.class) public", "return": "void", "body": "@Test(expected = PatchFormatException.class)\n  public void testReadPatchApplyPlan_CorruptDeltaFriendlyNewFileRecompressionInstructionOffset()\n      throws IOException {\n    corruption.corruptDeltaFriendlyNewFileRecompressionInstructionOffset = true;\n    new PatchReader().readPatchApplyPlan(new ByteArrayInputStream(writeTestPatch()));\n  }", "signature": "void testReadPatchApplyPlan_CorruptDeltaFriendlyNewFileRecompressionInstructionOffset()", "full_signature": "@Test(expected = PatchFormatException.class) public void testReadPatchApplyPlan_CorruptDeltaFriendlyNewFileRecompressionInstructionOffset()", "class_method_signature": "PatchReaderTest.testReadPatchApplyPlan_CorruptDeltaFriendlyNewFileRecompressionInstructionOffset()", "testcase": true, "constructor": false, "invocations": ["readPatchApplyPlan", "writeTestPatch"]}, "focal_class": {"identifier": "PatchReader", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "readPatchApplyPlan", "parameters": "(InputStream in)", "modifiers": "public", "return": "PatchApplyPlan", "signature": "PatchApplyPlan readPatchApplyPlan(InputStream in)", "full_signature": "public PatchApplyPlan readPatchApplyPlan(InputStream in)", "class_method_signature": "PatchReader.readPatchApplyPlan(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "checkNonNegative", "parameters": "(long value, String description)", "modifiers": "private static final", "return": "long", "signature": "long checkNonNegative(long value, String description)", "full_signature": "private static final long checkNonNegative(long value, String description)", "class_method_signature": "PatchReader.checkNonNegative(long value, String description)", "testcase": false, "constructor": false}, {"identifier": "checkRange", "parameters": "(long value, long min, long max, String description)", "modifiers": "private static final", "return": "long", "signature": "long checkRange(long value, long min, long max, String description)", "full_signature": "private static final long checkRange(long value, long min, long max, String description)", "class_method_signature": "PatchReader.checkRange(long value, long min, long max, String description)", "testcase": false, "constructor": false}], "file": "feya/libraries/archive_diff/diff.applier/src/main/java/com/google/archivepatcher/applier/PatchReader.java"}, "focal_method": {"identifier": "readPatchApplyPlan", "parameters": "(InputStream in)", "modifiers": "public", "return": "PatchApplyPlan", "body": "public PatchApplyPlan readPatchApplyPlan(InputStream in) throws IOException {\n    // Use DataOutputStream for ease of writing. This is deliberately left open, as closing it would\n    // close the output stream that was passed in and that is not part of the method's documented\n    // behavior.\n    @SuppressWarnings(\"resource\")\n    DataInputStream dataIn = new DataInputStream(in);\n\n    // Read header and flags.\n    byte[] expectedIdentifier = PatchConstants.IDENTIFIER.getBytes(\"US-ASCII\");\n    byte[] actualIdentifier = new byte[expectedIdentifier.length];\n    dataIn.readFully(actualIdentifier);\n    if (!Arrays.equals(expectedIdentifier, actualIdentifier)) {\n      throw new PatchFormatException(\"Bad identifier\");\n    }\n    dataIn.skip(4); // Flags (ignored in v1)\n    long deltaFriendlyOldFileSize = checkNonNegative(\n        dataIn.readLong(), \"delta-friendly old file size\");\n\n    // Read old file uncompression instructions.\n    int numOldFileUncompressionInstructions = (int) checkNonNegative(\n        dataIn.readInt(), \"old file uncompression instruction count\");\n    List<TypedRange<Void>> oldFileUncompressionPlan =\n        new ArrayList<TypedRange<Void>>(numOldFileUncompressionInstructions);\n    long lastReadOffset = -1;\n    for (int x = 0; x < numOldFileUncompressionInstructions; x++) {\n      long offset = checkNonNegative(dataIn.readLong(), \"old file uncompression range offset\");\n      long length = checkNonNegative(dataIn.readLong(), \"old file uncompression range length\");\n      if (offset < lastReadOffset) {\n        throw new PatchFormatException(\"old file uncompression ranges out of order or overlapping\");\n      }\n      TypedRange<Void> range = new TypedRange<Void>(offset, length, null);\n      oldFileUncompressionPlan.add(range);\n      lastReadOffset = offset + length; // To check that the next range starts after the current one\n    }\n\n    // Read new file recompression instructions\n    int numDeltaFriendlyNewFileRecompressionInstructions = dataIn.readInt();\n    checkNonNegative(\n        numDeltaFriendlyNewFileRecompressionInstructions,\n        \"delta-friendly new file recompression instruction count\");\n    List<TypedRange<JreDeflateParameters>> deltaFriendlyNewFileRecompressionPlan =\n        new ArrayList<TypedRange<JreDeflateParameters>>(\n            numDeltaFriendlyNewFileRecompressionInstructions);\n    lastReadOffset = -1;\n    for (int x = 0; x < numDeltaFriendlyNewFileRecompressionInstructions; x++) {\n      long offset = checkNonNegative(\n          dataIn.readLong(), \"delta-friendly new file recompression range offset\");\n      long length = checkNonNegative(\n          dataIn.readLong(), \"delta-friendly new file recompression range length\");\n      if (offset < lastReadOffset) {\n        throw new PatchFormatException(\n            \"delta-friendly new file recompression ranges out of order or overlapping\");\n      }\n      lastReadOffset = offset + length; // To check that the next range starts after the current one\n\n      // Read the JreDeflateParameters\n      // Note that v1 only supports the default deflate compatibility window.\n      checkRange(\n          dataIn.readByte(),\n          PatchConstants.CompatibilityWindowId.DEFAULT_DEFLATE.patchValue,\n          PatchConstants.CompatibilityWindowId.DEFAULT_DEFLATE.patchValue,\n          \"compatibility window id\");\n      int level = (int) checkRange(dataIn.readUnsignedByte(), 1, 9, \"recompression level\");\n      int strategy = (int) checkRange(dataIn.readUnsignedByte(), 0, 2, \"recompression strategy\");\n      int nowrapInt = (int) checkRange(dataIn.readUnsignedByte(), 0, 1, \"recompression nowrap\");\n      TypedRange<JreDeflateParameters> range =\n          new TypedRange<JreDeflateParameters>(\n              offset,\n              length,\n              JreDeflateParameters.of(level, strategy, nowrapInt == 0 ? false : true));\n      deltaFriendlyNewFileRecompressionPlan.add(range);\n    }\n\n    // Read the delta metadata, but stop before the first byte of the actual delta.\n    // V1 has exactly one delta and it must be bsdiff.\n    int numDeltaRecords = (int) checkRange(dataIn.readInt(), 1, 1, \"num delta records\");\n\n    List<DeltaDescriptor> deltaDescriptors = new ArrayList<DeltaDescriptor>(numDeltaRecords);\n    for (int x = 0; x < numDeltaRecords; x++) {\n      byte deltaFormatByte = (byte)\n      checkRange(\n          dataIn.readByte(),\n          PatchConstants.DeltaFormat.BSDIFF.patchValue,\n          PatchConstants.DeltaFormat.BSDIFF.patchValue,\n          \"delta format\");\n      long deltaFriendlyOldFileWorkRangeOffset = checkNonNegative(\n          dataIn.readLong(), \"delta-friendly old file work range offset\");\n      long deltaFriendlyOldFileWorkRangeLength = checkNonNegative(\n          dataIn.readLong(), \"delta-friendly old file work range length\");\n      long deltaFriendlyNewFileWorkRangeOffset = checkNonNegative(\n          dataIn.readLong(), \"delta-friendly new file work range offset\");\n      long deltaFriendlyNewFileWorkRangeLength = checkNonNegative(\n          dataIn.readLong(), \"delta-friendly new file work range length\");\n      long deltaLength = checkNonNegative(dataIn.readLong(), \"delta length\");\n      DeltaDescriptor descriptor =\n          new DeltaDescriptor(\n              PatchConstants.DeltaFormat.fromPatchValue(deltaFormatByte),\n              new TypedRange<Void>(\n                  deltaFriendlyOldFileWorkRangeOffset, deltaFriendlyOldFileWorkRangeLength, null),\n              new TypedRange<Void>(\n                  deltaFriendlyNewFileWorkRangeOffset, deltaFriendlyNewFileWorkRangeLength, null),\n              deltaLength);\n      deltaDescriptors.add(descriptor);\n    }\n\n    return new PatchApplyPlan(\n        Collections.unmodifiableList(oldFileUncompressionPlan),\n        deltaFriendlyOldFileSize,\n        Collections.unmodifiableList(deltaFriendlyNewFileRecompressionPlan),\n        Collections.unmodifiableList(deltaDescriptors));\n  }", "signature": "PatchApplyPlan readPatchApplyPlan(InputStream in)", "full_signature": "public PatchApplyPlan readPatchApplyPlan(InputStream in)", "class_method_signature": "PatchReader.readPatchApplyPlan(InputStream in)", "testcase": false, "constructor": false, "invocations": ["getBytes", "readFully", "equals", "skip", "checkNonNegative", "readLong", "checkNonNegative", "readInt", "checkNonNegative", "readLong", "checkNonNegative", "readLong", "add", "readInt", "checkNonNegative", "checkNonNegative", "readLong", "checkNonNegative", "readLong", "checkRange", "readByte", "checkRange", "readUnsignedByte", "checkRange", "readUnsignedByte", "checkRange", "readUnsignedByte", "of", "add", "checkRange", "readInt", "checkRange", "readByte", "checkNonNegative", "readLong", "checkNonNegative", "readLong", "checkNonNegative", "readLong", "checkNonNegative", "readLong", "checkNonNegative", "readLong", "fromPatchValue", "add", "unmodifiableList", "unmodifiableList", "unmodifiableList"]}, "repository": {"repo_id": 20126854, "url": "https://github.com/kaedea/Feya", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 12, "size": 7798, "license": "licensed"}}