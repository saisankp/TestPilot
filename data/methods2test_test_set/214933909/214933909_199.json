{"test_class": {"identifier": "TransControllerTest", "superclass": "", "interfaces": "", "fields": [], "file": "das-console-manager/src/test/java/com/ppdai/das/console/controller/TransControllerTest.java"}, "test_case": {"identifier": "getConvertCode", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void getConvertCode() throws Exception{\n        TransController controller = new TransController();\n        TransRequest transRequest = new TransRequest();\n        URL url = TransToDasControllerTest.class.getResource(\"/mybatisMapperTest.xml\");\n        transRequest.setXmlContent(Resources.toString(url, StandardCharsets.UTF_8));\n        ServiceResult<String> result = controller.convert(transRequest, null, null);\n        System.out.println(result.getMsg());\n        URL url2 = TransToDasControllerTest.class.getResource(\"/expectedMybatisCode\");\n        String expected = Resources.toString(url2, StandardCharsets.UTF_8);\n        Assert.assertEquals(expected, result.getMsg());\n    }", "signature": "void getConvertCode()", "full_signature": "@Test public void getConvertCode()", "class_method_signature": "TransControllerTest.getConvertCode()", "testcase": true, "constructor": false, "invocations": ["getResource", "setXmlContent", "toString", "convert", "println", "getMsg", "getResource", "toString", "assertEquals", "getMsg"]}, "focal_class": {"identifier": "TransController", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final static String SEP = System.getProperty(\"line.separator\");", "modifier": "private final static", "type": "String", "declarator": "SEP = System.getProperty(\"line.separator\")", "var_name": "SEP"}, {"original_string": "private final static Splitter DOT_SPLITTER = Splitter.on(\".\").trimResults();", "modifier": "private final static", "type": "Splitter", "declarator": "DOT_SPLITTER = Splitter.on(\".\").trimResults()", "var_name": "DOT_SPLITTER"}, {"original_string": "private ImmutableMap<JdbcType, String> jdbcType2Of = ImmutableMap.<JdbcType, String>builder()\n            .put(JdbcType.INTEGER, \"integer\")\n            .put(JdbcType.VARCHAR, \"varchar\")\n            .put(JdbcType.BOOLEAN, \"boolean\")\n            .build();", "modifier": "private", "type": "ImmutableMap<JdbcType, String>", "declarator": "jdbcType2Of = ImmutableMap.<JdbcType, String>builder()\n            .put(JdbcType.INTEGER, \"integer\")\n            .put(JdbcType.VARCHAR, \"varchar\")\n            .put(JdbcType.BOOLEAN, \"boolean\")\n            .build()", "var_name": "jdbcType2Of"}], "methods": [{"identifier": "convert", "parameters": "(@RequestBody TransRequest transRequest, @CurrentUser LoginUser user, Errors errors)", "modifiers": "@RequestMapping(value = \"/toDas\", method = RequestMethod.POST) public", "return": "ServiceResult<String>", "signature": "ServiceResult<String> convert(@RequestBody TransRequest transRequest, @CurrentUser LoginUser user, Errors errors)", "full_signature": "@RequestMapping(value = \"/toDas\", method = RequestMethod.POST) public ServiceResult<String> convert(@RequestBody TransRequest transRequest, @CurrentUser LoginUser user, Errors errors)", "class_method_signature": "TransController.convert(@RequestBody TransRequest transRequest, @CurrentUser LoginUser user, Errors errors)", "testcase": false, "constructor": false}, {"identifier": "getResultType", "parameters": "(MappedStatement statement)", "modifiers": "private", "return": "Class", "signature": "Class getResultType(MappedStatement statement)", "full_signature": "private Class getResultType(MappedStatement statement)", "class_method_signature": "TransController.getResultType(MappedStatement statement)", "testcase": false, "constructor": false}, {"identifier": "classComments", "parameters": "(Set<String> importResultMaps)", "modifiers": "private", "return": "List<String>", "signature": "List<String> classComments(Set<String> importResultMaps)", "full_signature": "private List<String> classComments(Set<String> importResultMaps)", "class_method_signature": "TransController.classComments(Set<String> importResultMaps)", "testcase": false, "constructor": false}, {"identifier": "importResultMaps", "parameters": "(Configuration configuration)", "modifiers": "private", "return": "Set<String>", "signature": "Set<String> importResultMaps(Configuration configuration)", "full_signature": "private Set<String> importResultMaps(Configuration configuration)", "class_method_signature": "TransController.importResultMaps(Configuration configuration)", "testcase": false, "constructor": false}, {"identifier": "createClassName", "parameters": "(XMLMapperBuilder xmlMapperBuilder)", "modifiers": "private", "return": "String", "signature": "String createClassName(XMLMapperBuilder xmlMapperBuilder)", "full_signature": "private String createClassName(XMLMapperBuilder xmlMapperBuilder)", "class_method_signature": "TransController.createClassName(XMLMapperBuilder xmlMapperBuilder)", "testcase": false, "constructor": false}, {"identifier": "getParams", "parameters": "(List<ParameterMapping> parameterMappings)", "modifiers": "private", "return": "LinkedHashMap<String, String>", "signature": "LinkedHashMap<String, String> getParams(List<ParameterMapping> parameterMappings)", "full_signature": "private LinkedHashMap<String, String> getParams(List<ParameterMapping> parameterMappings)", "class_method_signature": "TransController.getParams(List<ParameterMapping> parameterMappings)", "testcase": false, "constructor": false}, {"identifier": "uniqueStatements", "parameters": "(Collection<MappedStatement> mappedStatements)", "modifiers": "private", "return": "Collection<MappedStatement>", "signature": "Collection<MappedStatement> uniqueStatements(Collection<MappedStatement> mappedStatements)", "full_signature": "private Collection<MappedStatement> uniqueStatements(Collection<MappedStatement> mappedStatements)", "class_method_signature": "TransController.uniqueStatements(Collection<MappedStatement> mappedStatements)", "testcase": false, "constructor": false}, {"identifier": "walkNodes", "parameters": "(SqlNode node, Configuration  configuration, MappedStatement statement,\n                            ArrayList<Seg> collector, AtomicInteger level, LinkedHashMap<String, String> params,\n                            LinkedList<String> tests, LinkedHashMap<String, String> parsedParams, Class parameterType, StringBuilder comments, Set<String> binds)", "modifiers": "private", "return": "void", "signature": "void walkNodes(SqlNode node, Configuration  configuration, MappedStatement statement,\n                            ArrayList<Seg> collector, AtomicInteger level, LinkedHashMap<String, String> params,\n                            LinkedList<String> tests, LinkedHashMap<String, String> parsedParams, Class parameterType, StringBuilder comments, Set<String> binds)", "full_signature": "private void walkNodes(SqlNode node, Configuration  configuration, MappedStatement statement,\n                            ArrayList<Seg> collector, AtomicInteger level, LinkedHashMap<String, String> params,\n                            LinkedList<String> tests, LinkedHashMap<String, String> parsedParams, Class parameterType, StringBuilder comments, Set<String> binds)", "class_method_signature": "TransController.walkNodes(SqlNode node, Configuration  configuration, MappedStatement statement,\n                            ArrayList<Seg> collector, AtomicInteger level, LinkedHashMap<String, String> params,\n                            LinkedList<String> tests, LinkedHashMap<String, String> parsedParams, Class parameterType, StringBuilder comments, Set<String> binds)", "testcase": false, "constructor": false}, {"identifier": "isPrimitiveType", "parameters": "(Class type)", "modifiers": "private", "return": "boolean", "signature": "boolean isPrimitiveType(Class type)", "full_signature": "private boolean isPrimitiveType(Class type)", "class_method_signature": "TransController.isPrimitiveType(Class type)", "testcase": false, "constructor": false}, {"identifier": "getIntoType", "parameters": "(Class type)", "modifiers": "private", "return": "String", "signature": "String getIntoType(Class type)", "full_signature": "private String getIntoType(Class type)", "class_method_signature": "TransController.getIntoType(Class type)", "testcase": false, "constructor": false}, {"identifier": "get", "parameters": "(Object obj, String field)", "modifiers": "private", "return": "T", "signature": "T get(Object obj, String field)", "full_signature": "private T get(Object obj, String field)", "class_method_signature": "TransController.get(Object obj, String field)", "testcase": false, "constructor": false}, {"identifier": "getField", "parameters": "(Class clz, String field)", "modifiers": "private", "return": "Field", "signature": "Field getField(Class clz, String field)", "full_signature": "private Field getField(Class clz, String field)", "class_method_signature": "TransController.getField(Class clz, String field)", "testcase": false, "constructor": false}, {"identifier": "createConfiguration", "parameters": "()", "modifiers": "private", "return": "Configuration", "signature": "Configuration createConfiguration()", "full_signature": "private Configuration createConfiguration()", "class_method_signature": "TransController.createConfiguration()", "testcase": false, "constructor": false}, {"identifier": "mergeTemplate", "parameters": "(Context context)", "modifiers": "private", "return": "String", "signature": "String mergeTemplate(Context context)", "full_signature": "private String mergeTemplate(Context context)", "class_method_signature": "TransController.mergeTemplate(Context context)", "testcase": false, "constructor": false}, {"identifier": "join", "parameters": "(ArrayList<Seg> segs)", "modifiers": "private", "return": "String", "signature": "String join(ArrayList<Seg> segs)", "full_signature": "private String join(ArrayList<Seg> segs)", "class_method_signature": "TransController.join(ArrayList<Seg> segs)", "testcase": false, "constructor": false}, {"identifier": "trimLine", "parameters": "(String s)", "modifiers": "private", "return": "String", "signature": "String trimLine(String s)", "full_signature": "private String trimLine(String s)", "class_method_signature": "TransController.trimLine(String s)", "testcase": false, "constructor": false}], "file": "das-console-manager/src/main/java/com/ppdai/das/console/controller/TransController.java"}, "focal_method": {"identifier": "convert", "parameters": "(@RequestBody TransRequest transRequest, @CurrentUser LoginUser user, Errors errors)", "modifiers": "@RequestMapping(value = \"/toDas\", method = RequestMethod.POST) public", "return": "ServiceResult<String>", "body": "@RequestMapping(value = \"/toDas\", method = RequestMethod.POST)\n    public ServiceResult<String> convert(@RequestBody TransRequest transRequest, @CurrentUser LoginUser user, Errors errors) {\n\n        try {\n            Configuration configuration = createConfiguration();\n\n            InputStream inputStream = new ByteArrayInputStream(transRequest.getXmlContent().getBytes(StandardCharsets.UTF_8));\n            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, \"any.xml\", configuration.getSqlFragments());\n            mapperParser.parse();\n\n            Collection<MappedStatement> statements = uniqueStatements(mapperParser.getConfiguration().getMappedStatements());\n            List<Statement> convertedStatements = newArrayList();\n            VelocityContext context = new VelocityContext();\n\n            Set<String> importResultMaps = importResultMaps(configuration);\n            context.put(\"importResultMaps\", importResultMaps);\n            context.put(\"classComments\", classComments(importResultMaps));\n            context.put(\"className\", createClassName(mapperParser));\n            context.put(\"statements\", convertedStatements);\n\n            for(MappedStatement statement : statements) {\n                if (statement.getSqlCommandType() == SELECT || statement.getSqlCommandType() == INSERT\n                        || statement.getSqlCommandType() == UPDATE || statement.getSqlCommandType() == DELETE) {\n                    try{\n                        SqlSource sqlSource = statement.getSqlSource();\n                        ArrayList<Seg> segs = new ArrayList<>();\n                        LinkedHashMap<String, String> params = newLinkedHashMap();\n\n                        Class parameterType = statement.getParameterMap().getType();\n                        StringBuilder comments = new StringBuilder();\n                        if(statement.isUseCache()) {\n                            //comments.append(SEP).append(\"\u4e0d\u652f\u6301useCache\u5c5e\u6027\");\n                        }\n                        if(sqlSource instanceof RawSqlSource) {\n                            List<ParameterMapping> parameterMappings = get(get(sqlSource, \"sqlSource\"), \"parameterMappings\");\n                            LinkedHashMap<String, String> parsedParams = getParams(parameterMappings);\n\n                            StaticTextSqlNode node = new StaticTextSqlNode(get(get(sqlSource, \"sqlSource\"), \"sql\"));\n                            walkNodes(node, configuration, statement, segs, new AtomicInteger(0), params, newLinkedList(), parsedParams, parameterType, comments, Sets.newHashSet());\n                        } else {\n                            walkNodes(get(sqlSource, \"rootSqlNode\"), configuration, statement, segs, new AtomicInteger(0), params, newLinkedList(), newLinkedHashMap(), parameterType, comments, Sets.newHashSet());\n                        }\n\n                        String resultType = getResultType(statement).getSimpleName();\n\n                        if(parameterType != null){\n                            params.clear();\n                            params.put(\"p\" + parameterType.getSimpleName(),  parameterType.getName());\n                        }\n\n                        Class resultClass = getResultType(statement);\n                        if(statement.getSqlCommandType() == SELECT ){\n                            segs.add(new Seg(\"sqlBuilder.\" + getIntoType(resultClass) + \";\"));\n                        }\n                        Statement converted = new Statement()\n                                .setId(statement.getId())\n                                .setMethodBody(join(segs))\n                                .setMethodType(statement.getSqlCommandType() == SELECT ? \"query\" : \"update\")\n                                .setResultType(statement.getSqlCommandType() == SELECT && !isPrimitiveType(resultClass) ? \"List<\" + resultType + \">\" : resultType)\n                                .setParams(params)\n                                .setComments(comments.toString());\n\n                        convertedStatements.add(converted);\n                    }catch (Exception e){\n                        Statement converted = new Statement()\n                                .setId(statement.getId())\n                                .setFail(true);\n                        convertedStatements.add(converted);\n                        e.printStackTrace();\n                    }\n                }\n            }\n\n            String finalResult = mergeTemplate(context);\n            String formattedSource = finalResult;\n            try {\n                formattedSource = new Formatter().formatSource(finalResult);\n            } catch (FormatterException fe) {\n                fe.printStackTrace();\n            }\n            return ServiceResult.success(formattedSource);\n        }catch (Exception e){\n            e.printStackTrace();\n            return ServiceResult.fail(StringUtil.getMessage(e));\n        }\n    }", "signature": "ServiceResult<String> convert(@RequestBody TransRequest transRequest, @CurrentUser LoginUser user, Errors errors)", "full_signature": "@RequestMapping(value = \"/toDas\", method = RequestMethod.POST) public ServiceResult<String> convert(@RequestBody TransRequest transRequest, @CurrentUser LoginUser user, Errors errors)", "class_method_signature": "TransController.convert(@RequestBody TransRequest transRequest, @CurrentUser LoginUser user, Errors errors)", "testcase": false, "constructor": false, "invocations": ["createConfiguration", "getBytes", "getXmlContent", "getSqlFragments", "parse", "uniqueStatements", "getMappedStatements", "getConfiguration", "newArrayList", "importResultMaps", "put", "put", "classComments", "put", "createClassName", "put", "getSqlCommandType", "getSqlCommandType", "getSqlCommandType", "getSqlCommandType", "getSqlSource", "newLinkedHashMap", "getType", "getParameterMap", "isUseCache", "get", "get", "getParams", "get", "get", "walkNodes", "newLinkedList", "newHashSet", "walkNodes", "get", "newLinkedList", "newLinkedHashMap", "newHashSet", "getSimpleName", "getResultType", "clear", "put", "getSimpleName", "getName", "getResultType", "getSqlCommandType", "add", "getIntoType", "setComments", "setParams", "setResultType", "setMethodType", "setMethodBody", "setId", "getId", "join", "getSqlCommandType", "getSqlCommandType", "isPrimitiveType", "toString", "add", "setFail", "setId", "getId", "add", "printStackTrace", "mergeTemplate", "formatSource", "printStackTrace", "success", "printStackTrace", "fail", "getMessage"]}, "repository": {"repo_id": 214933909, "url": "https://github.com/ppdaicorp/das", "stars": 55, "created": "10/14/2019 2:49:17 AM +00:00", "updates": "2020-01-20T09:24:23+00:00", "fork": "False", "license": "licensed"}}