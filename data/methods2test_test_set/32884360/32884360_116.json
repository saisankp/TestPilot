{"test_class": {"identifier": "RangeSegmentTest", "superclass": "", "interfaces": "", "fields": [], "file": "fdb-sql-layer-core/src/test/java/com/foundationdb/sql/optimizer/rule/range/RangeSegmentTest.java"}, "test_case": {"identifier": "sacIncomparableTypesForMerging", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void sacIncomparableTypesForMerging() {\n        List<RangeSegment> original = Arrays.asList(\n                segment(inclusive(\"aardvark\"), inclusive(1L)),\n                segment(inclusive(\"cat\"), exclusive(1L))\n        );\n        List<RangeSegment> copy = new ArrayList<>(original);\n        List<RangeSegment> sorted = RangeSegment.sortAndCombine(copy);\n        assertCollectionEquals(original, copy);\n        assertNull(\"sorted list should be null\", sorted);\n    }", "signature": "void sacIncomparableTypesForMerging()", "full_signature": "@Test public void sacIncomparableTypesForMerging()", "class_method_signature": "RangeSegmentTest.sacIncomparableTypesForMerging()", "testcase": true, "constructor": false, "invocations": ["asList", "segment", "inclusive", "inclusive", "segment", "inclusive", "exclusive", "sortAndCombine", "assertCollectionEquals", "assertNull"]}, "focal_class": {"identifier": "RangeSegment", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger log = LoggerFactory.getLogger(RangeSegment.class);", "modifier": "private static final", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(RangeSegment.class)", "var_name": "log"}, {"original_string": "private RangeEndpoint start;", "modifier": "private", "type": "RangeEndpoint", "declarator": "start", "var_name": "start"}, {"original_string": "private RangeEndpoint end;", "modifier": "private", "type": "RangeEndpoint", "declarator": "end", "var_name": "end"}, {"original_string": "private static final Comparator<? super RangeSegment> RANGE_SEGMENTS_BY_START = new Comparator<RangeSegment>() {\n        @Override\n        public int compare(RangeSegment segment1, RangeSegment segment2) {\n            return segment1.getStart().compareTo(segment2.getStart());\n        }\n    };", "modifier": "private static final", "type": "Comparator<? super RangeSegment>", "declarator": "RANGE_SEGMENTS_BY_START = new Comparator<RangeSegment>() {\n        @Override\n        public int compare(RangeSegment segment1, RangeSegment segment2) {\n            return segment1.getStart().compareTo(segment2.getStart());\n        }\n    }", "var_name": "RANGE_SEGMENTS_BY_START"}], "methods": [{"identifier": "fromComparison", "parameters": "(Comparison op, ConstantExpression constantExpression)", "modifiers": "public static", "return": "List<RangeSegment>", "signature": "List<RangeSegment> fromComparison(Comparison op, ConstantExpression constantExpression)", "full_signature": "public static List<RangeSegment> fromComparison(Comparison op, ConstantExpression constantExpression)", "class_method_signature": "RangeSegment.fromComparison(Comparison op, ConstantExpression constantExpression)", "testcase": false, "constructor": false}, {"identifier": "sortAndCombine", "parameters": "(List<RangeSegment> segments)", "modifiers": "static", "return": "List<RangeSegment>", "signature": "List<RangeSegment> sortAndCombine(List<RangeSegment> segments)", "full_signature": "static List<RangeSegment> sortAndCombine(List<RangeSegment> segments)", "class_method_signature": "RangeSegment.sortAndCombine(List<RangeSegment> segments)", "testcase": false, "constructor": false}, {"identifier": "replacePreviousTwo", "parameters": "(ListIterator<RangeSegment> iterator, RangeSegment previous,\n                                           RangeSegment newValue)", "modifiers": "private static", "return": "void", "signature": "void replacePreviousTwo(ListIterator<RangeSegment> iterator, RangeSegment previous,\n                                           RangeSegment newValue)", "full_signature": "private static void replacePreviousTwo(ListIterator<RangeSegment> iterator, RangeSegment previous,\n                                           RangeSegment newValue)", "class_method_signature": "RangeSegment.replacePreviousTwo(ListIterator<RangeSegment> iterator, RangeSegment previous,\n                                           RangeSegment newValue)", "testcase": false, "constructor": false}, {"identifier": "findOverlap", "parameters": "(RangeEndpoint low, RangeEndpoint high, boolean loose)", "modifiers": "private static", "return": "Boolean", "signature": "Boolean findOverlap(RangeEndpoint low, RangeEndpoint high, boolean loose)", "full_signature": "private static Boolean findOverlap(RangeEndpoint low, RangeEndpoint high, boolean loose)", "class_method_signature": "RangeSegment.findOverlap(RangeEndpoint low, RangeEndpoint high, boolean loose)", "testcase": false, "constructor": false}, {"identifier": "orRanges", "parameters": "(List<RangeSegment> leftRanges, List<RangeSegment> rightRanges)", "modifiers": "static", "return": "List<RangeSegment>", "signature": "List<RangeSegment> orRanges(List<RangeSegment> leftRanges, List<RangeSegment> rightRanges)", "full_signature": "static List<RangeSegment> orRanges(List<RangeSegment> leftRanges, List<RangeSegment> rightRanges)", "class_method_signature": "RangeSegment.orRanges(List<RangeSegment> leftRanges, List<RangeSegment> rightRanges)", "testcase": false, "constructor": false}, {"identifier": "andRanges", "parameters": "(List<RangeSegment> leftRanges, List<RangeSegment> rightRanges)", "modifiers": "static", "return": "List<RangeSegment>", "signature": "List<RangeSegment> andRanges(List<RangeSegment> leftRanges, List<RangeSegment> rightRanges)", "full_signature": "static List<RangeSegment> andRanges(List<RangeSegment> leftRanges, List<RangeSegment> rightRanges)", "class_method_signature": "RangeSegment.andRanges(List<RangeSegment> leftRanges, List<RangeSegment> rightRanges)", "testcase": false, "constructor": false}, {"identifier": "andRangeSegment", "parameters": "(RangeSegment left, RangeSegment right)", "modifiers": "static", "return": "RangeSegment", "signature": "RangeSegment andRangeSegment(RangeSegment left, RangeSegment right)", "full_signature": "static RangeSegment andRangeSegment(RangeSegment left, RangeSegment right)", "class_method_signature": "RangeSegment.andRangeSegment(RangeSegment left, RangeSegment right)", "testcase": false, "constructor": false}, {"identifier": "rangeEndpoint", "parameters": "(RangeEndpoint one, RangeEndpoint two, RangeEndpoint.RangePointComparison comparison)", "modifiers": "static", "return": "RangeEndpoint", "signature": "RangeEndpoint rangeEndpoint(RangeEndpoint one, RangeEndpoint two, RangeEndpoint.RangePointComparison comparison)", "full_signature": "static RangeEndpoint rangeEndpoint(RangeEndpoint one, RangeEndpoint two, RangeEndpoint.RangePointComparison comparison)", "class_method_signature": "RangeSegment.rangeEndpoint(RangeEndpoint one, RangeEndpoint two, RangeEndpoint.RangePointComparison comparison)", "testcase": false, "constructor": false}, {"identifier": "getStart", "parameters": "()", "modifiers": "public", "return": "RangeEndpoint", "signature": "RangeEndpoint getStart()", "full_signature": "public RangeEndpoint getStart()", "class_method_signature": "RangeSegment.getStart()", "testcase": false, "constructor": false}, {"identifier": "getEnd", "parameters": "()", "modifiers": "public", "return": "RangeEndpoint", "signature": "RangeEndpoint getEnd()", "full_signature": "public RangeEndpoint getEnd()", "class_method_signature": "RangeSegment.getEnd()", "testcase": false, "constructor": false}, {"identifier": "isSingle", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isSingle()", "full_signature": "public boolean isSingle()", "class_method_signature": "RangeSegment.isSingle()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "RangeSegment.toString()", "testcase": false, "constructor": false}, {"identifier": "equals", "parameters": "(Object o)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object o)", "full_signature": "@Override public boolean equals(Object o)", "class_method_signature": "RangeSegment.equals(Object o)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "RangeSegment.hashCode()", "testcase": false, "constructor": false}, {"identifier": "RangeSegment", "parameters": "(RangeEndpoint start, RangeEndpoint end)", "modifiers": "public", "return": "", "signature": " RangeSegment(RangeEndpoint start, RangeEndpoint end)", "full_signature": "public  RangeSegment(RangeEndpoint start, RangeEndpoint end)", "class_method_signature": "RangeSegment.RangeSegment(RangeEndpoint start, RangeEndpoint end)", "testcase": false, "constructor": true}, {"identifier": "onlyNull", "parameters": "(ExpressionNode expressionNode)", "modifiers": "public static", "return": "RangeSegment", "signature": "RangeSegment onlyNull(ExpressionNode expressionNode)", "full_signature": "public static RangeSegment onlyNull(ExpressionNode expressionNode)", "class_method_signature": "RangeSegment.onlyNull(ExpressionNode expressionNode)", "testcase": false, "constructor": false}], "file": "fdb-sql-layer-core/src/main/java/com/foundationdb/sql/optimizer/rule/range/RangeSegment.java"}, "focal_method": {"identifier": "sortAndCombine", "parameters": "(List<RangeSegment> segments)", "modifiers": "static", "return": "List<RangeSegment>", "body": "static List<RangeSegment> sortAndCombine(List<RangeSegment> segments) {\n        try {\n            Collections.sort(segments, RANGE_SEGMENTS_BY_START);\n        } catch (RangeEndpoint.IllegalComparisonException e) {\n            log.warn(\"illegal comparison in sorting/combining range segments\", e);\n            return null;\n        }\n        // General algorithm:\n        // - iterate over each RangeSegment.\n        // - if this is the first RangeSegment, let it be. Otherwise...\n        // -- if its start is <= the end of the previous one...\n        // --- if its end is <= the end of the previous one, simply remove it\n        // --- otherwise, remove both and replace them with a RangeSegment whose start is the previous one and whose end\n        // is the new one; this is now the new previous\n        // -- else, if start > the end of the previous one, this is the new current\n        //\n        // When comparing starts, WILD <= anything; and when comparing ends, WILD >= anything.\n        RangeSegment previous = null;\n        for (ListIterator<RangeSegment> iterator = segments.listIterator(); iterator.hasNext(); ) {\n            RangeSegment currentSegment = iterator.next();\n            final RangeSegment nextPrevious;\n            if (previous == null) {\n                nextPrevious = currentSegment;\n            }\n            else {\n                RangeEndpoint previousEnd = previous.getEnd();\n                RangeEndpoint currentStart = currentSegment.getStart();\n                // \"start\" and \"end\" are relative to the previous. So, startsOverlap specifies whether\n                // the current's end is less than the previous start; and endsOverlap specifies whether the current's\n                // end is less than the previous end\n                Boolean startsOverlap = findOverlap(previousEnd, currentStart, true);\n                if (startsOverlap == null)\n                    return null;\n                if (startsOverlap) {\n                    Boolean endsOverlap = findOverlap(previousEnd, currentSegment.getEnd(), false);\n                    if (endsOverlap == null)\n                        return null;\n                    if (endsOverlap) {\n                        iterator.remove();\n                        nextPrevious = previous;\n                    }\n                    // previous end is < current end; extend by taking previous start and current end\n                    else {\n                        nextPrevious = new RangeSegment(previous.getStart(), currentSegment.getEnd());\n                        replacePreviousTwo(iterator, previous, nextPrevious);\n                    }\n                }\n                else {\n                    nextPrevious = currentSegment;\n                }\n            }\n            previous = nextPrevious;\n        }\n        return segments;\n    }", "signature": "List<RangeSegment> sortAndCombine(List<RangeSegment> segments)", "full_signature": "static List<RangeSegment> sortAndCombine(List<RangeSegment> segments)", "class_method_signature": "RangeSegment.sortAndCombine(List<RangeSegment> segments)", "testcase": false, "constructor": false, "invocations": ["sort", "warn", "listIterator", "hasNext", "next", "getEnd", "getStart", "findOverlap", "findOverlap", "getEnd", "remove", "getStart", "getEnd", "replacePreviousTwo"]}, "repository": {"repo_id": 32884360, "url": "https://github.com/jaytaylor/sql-layer", "language": "Java", "is_fork": false, "fork_count": 120, "stargazer_count": 77, "size": 138665, "license": "licensed"}}