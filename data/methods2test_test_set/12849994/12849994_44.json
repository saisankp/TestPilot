{"test_class": {"identifier": "OffHeapByteBufferTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "Random random;", "modifier": "", "type": "Random", "declarator": "random", "var_name": "random"}, {"original_string": "OffHeapByteBuffer buffer = new OffHeapByteBuffer(0, 1024 * 1024 * 10);", "modifier": "", "type": "OffHeapByteBuffer", "declarator": "buffer = new OffHeapByteBuffer(0, 1024 * 1024 * 10)", "var_name": "buffer"}], "file": "imcache-offheap/src/test/java/com/cetsoft/imcache/offheap/bytebuffer/OffHeapByteBufferTest.java"}, "test_case": {"identifier": "allocate", "parameters": "()", "modifiers": "@Test(expected = BufferOverflowException.class) public", "return": "void", "body": "@Test(expected = BufferOverflowException.class)\n  public void allocate() {\n    int size = 11 * 1024 * 1024;\n    byte[] expectedBytes = new byte[size];\n    random.nextBytes(expectedBytes);\n    buffer.allocate(expectedBytes);\n  }", "signature": "void allocate()", "full_signature": "@Test(expected = BufferOverflowException.class) public void allocate()", "class_method_signature": "OffHeapByteBufferTest.allocate()", "testcase": true, "constructor": false, "invocations": ["nextBytes", "allocate"]}, "focal_class": {"identifier": "OffHeapByteBuffer", "superclass": "", "interfaces": "implements OffHeapStore", "fields": [{"original_string": "public final static int DEFAULT_CONCURRENCY_LEVEL = 4;", "modifier": "public final static", "type": "int", "declarator": "DEFAULT_CONCURRENCY_LEVEL = 4", "var_name": "DEFAULT_CONCURRENCY_LEVEL"}, {"original_string": "private final static int POINTER_SIZE = 5;", "modifier": "private final static", "type": "int", "declarator": "POINTER_SIZE = 5", "var_name": "POINTER_SIZE"}, {"original_string": "private final static byte USED = 1;", "modifier": "private final static", "type": "byte", "declarator": "USED = 1", "var_name": "USED"}, {"original_string": "private final static byte FREE = 0;", "modifier": "private final static", "type": "byte", "declarator": "FREE = 0", "var_name": "FREE"}, {"original_string": "private final static byte DIRTY = -1;", "modifier": "private final static", "type": "byte", "declarator": "DIRTY = -1", "var_name": "DIRTY"}, {"original_string": "private final DirectByteBuffer directByteBuffer;", "modifier": "private final", "type": "DirectByteBuffer", "declarator": "directByteBuffer", "var_name": "directByteBuffer"}, {"original_string": "private final StripedReadWriteLock readWriteLock;", "modifier": "private final", "type": "StripedReadWriteLock", "declarator": "readWriteLock", "var_name": "readWriteLock"}, {"original_string": "private final AtomicInteger offset = new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "offset = new AtomicInteger(0)", "var_name": "offset"}, {"original_string": "private final AtomicInteger usedMemory = new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "usedMemory = new AtomicInteger(0)", "var_name": "usedMemory"}, {"original_string": "private final AtomicInteger dirtyMemory = new AtomicInteger(0);", "modifier": "private final", "type": "AtomicInteger", "declarator": "dirtyMemory = new AtomicInteger(0)", "var_name": "dirtyMemory"}, {"original_string": "private volatile int index;", "modifier": "private volatile", "type": "int", "declarator": "index", "var_name": "index"}, {"original_string": "private volatile long capacity;", "modifier": "private volatile", "type": "long", "declarator": "capacity", "var_name": "capacity"}], "methods": [{"identifier": "OffHeapByteBuffer", "parameters": "(int index, int capacity)", "modifiers": "public", "return": "", "signature": " OffHeapByteBuffer(int index, int capacity)", "full_signature": "public  OffHeapByteBuffer(int index, int capacity)", "class_method_signature": "OffHeapByteBuffer.OffHeapByteBuffer(int index, int capacity)", "testcase": false, "constructor": true}, {"identifier": "OffHeapByteBuffer", "parameters": "(int index, int capacity, int concurrencyLevel)", "modifiers": "public", "return": "", "signature": " OffHeapByteBuffer(int index, int capacity, int concurrencyLevel)", "full_signature": "public  OffHeapByteBuffer(int index, int capacity, int concurrencyLevel)", "class_method_signature": "OffHeapByteBuffer.OffHeapByteBuffer(int index, int capacity, int concurrencyLevel)", "testcase": false, "constructor": true}, {"identifier": "retrieve", "parameters": "(final Pointer pointer)", "modifiers": "public", "return": "byte[]", "signature": "byte[] retrieve(final Pointer pointer)", "full_signature": "public byte[] retrieve(final Pointer pointer)", "class_method_signature": "OffHeapByteBuffer.retrieve(final Pointer pointer)", "testcase": false, "constructor": false}, {"identifier": "remove", "parameters": "(Pointer pointer)", "modifiers": "public", "return": "byte[]", "signature": "byte[] remove(Pointer pointer)", "full_signature": "public byte[] remove(Pointer pointer)", "class_method_signature": "OffHeapByteBuffer.remove(Pointer pointer)", "testcase": false, "constructor": false}, {"identifier": "store", "parameters": "(final byte[] payload, final long expiry)", "modifiers": "public", "return": "Pointer", "signature": "Pointer store(final byte[] payload, final long expiry)", "full_signature": "public Pointer store(final byte[] payload, final long expiry)", "class_method_signature": "OffHeapByteBuffer.store(final byte[] payload, final long expiry)", "testcase": false, "constructor": false}, {"identifier": "store", "parameters": "(final Allocation allocation, byte[] payload, final long expiry)", "modifiers": "public", "return": "Pointer", "signature": "Pointer store(final Allocation allocation, byte[] payload, final long expiry)", "full_signature": "public Pointer store(final Allocation allocation, byte[] payload, final long expiry)", "class_method_signature": "OffHeapByteBuffer.store(final Allocation allocation, byte[] payload, final long expiry)", "testcase": false, "constructor": false}, {"identifier": "update", "parameters": "(final Pointer pointer, final byte[] payload, final long expiry)", "modifiers": "public", "return": "Pointer", "signature": "Pointer update(final Pointer pointer, final byte[] payload, final long expiry)", "full_signature": "public Pointer update(final Pointer pointer, final byte[] payload, final long expiry)", "class_method_signature": "OffHeapByteBuffer.update(final Pointer pointer, final byte[] payload, final long expiry)", "testcase": false, "constructor": false}, {"identifier": "header", "parameters": "(int length)", "modifiers": "protected", "return": "byte[]", "signature": "byte[] header(int length)", "full_signature": "protected byte[] header(int length)", "class_method_signature": "OffHeapByteBuffer.header(int length)", "testcase": false, "constructor": false}, {"identifier": "header", "parameters": "(byte[] header)", "modifiers": "protected", "return": "int", "signature": "int header(byte[] header)", "full_signature": "protected int header(byte[] header)", "class_method_signature": "OffHeapByteBuffer.header(byte[] header)", "testcase": false, "constructor": false}, {"identifier": "markAsDirty", "parameters": "(int offset)", "modifiers": "protected", "return": "void", "signature": "void markAsDirty(int offset)", "full_signature": "protected void markAsDirty(int offset)", "class_method_signature": "OffHeapByteBuffer.markAsDirty(int offset)", "testcase": false, "constructor": false}, {"identifier": "allocate", "parameters": "(byte[] payload)", "modifiers": "protected", "return": "Allocation", "signature": "Allocation allocate(byte[] payload)", "full_signature": "protected Allocation allocate(byte[] payload)", "class_method_signature": "OffHeapByteBuffer.allocate(byte[] payload)", "testcase": false, "constructor": false}, {"identifier": "free", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void free()", "full_signature": "public void free()", "class_method_signature": "OffHeapByteBuffer.free()", "testcase": false, "constructor": false}, {"identifier": "dirtyMemory", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long dirtyMemory()", "full_signature": "public long dirtyMemory()", "class_method_signature": "OffHeapByteBuffer.dirtyMemory()", "testcase": false, "constructor": false}, {"identifier": "usedMemory", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long usedMemory()", "full_signature": "public long usedMemory()", "class_method_signature": "OffHeapByteBuffer.usedMemory()", "testcase": false, "constructor": false}, {"identifier": "freeMemory", "parameters": "()", "modifiers": "public", "return": "long", "signature": "long freeMemory()", "full_signature": "public long freeMemory()", "class_method_signature": "OffHeapByteBuffer.freeMemory()", "testcase": false, "constructor": false}, {"identifier": "getIndex", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getIndex()", "full_signature": "public int getIndex()", "class_method_signature": "OffHeapByteBuffer.getIndex()", "testcase": false, "constructor": false}], "file": "imcache-offheap/src/main/java/com/cetsoft/imcache/offheap/bytebuffer/OffHeapByteBuffer.java"}, "focal_method": {"identifier": "allocate", "parameters": "(byte[] payload)", "modifiers": "protected", "return": "Allocation", "body": "protected Allocation allocate(byte[] payload) {\n    final int payloadLength = payload.length + POINTER_SIZE;\n    final int allocationOffset = offset.addAndGet(payloadLength);\n    if (this.capacity < allocationOffset) {\n      throw new BufferOverflowException();\n    }\n    return new Allocation(allocationOffset - payloadLength, payloadLength);\n  }", "signature": "Allocation allocate(byte[] payload)", "full_signature": "protected Allocation allocate(byte[] payload)", "class_method_signature": "OffHeapByteBuffer.allocate(byte[] payload)", "testcase": false, "constructor": false, "invocations": ["addAndGet"]}, "repository": {"repo_id": 12849994, "url": "https://github.com/Cetsoft/imcache", "language": "Java", "is_fork": false, "fork_count": 38, "stargazer_count": 121, "size": 1599, "license": "licensed"}}