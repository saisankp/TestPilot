{"test_class": {"identifier": "TestFailoverSinkProcessor", "superclass": "", "interfaces": "", "fields": [], "file": "flume-ng-core/src/test/java/org/apache/flume/sink/TestFailoverSinkProcessor.java"}, "test_case": {"identifier": "testFailover", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testFailover() throws InterruptedException {\n    Channel ch = new MemoryChannel();\n\n    ConsumeXSink s1 = new ConsumeXSink(10);\n    s1.setChannel(ch);\n    s1.setName(\"s1\");\n    ConsumeXSink s2 = new ConsumeXSink(50);\n    s2.setChannel(ch);\n    s2.setName(\"s2\");\n    ConsumeXSink s3 = new ConsumeXSink(100);\n    s3.setChannel(ch);\n    s3.setName(\"s3\");\n\n    Context context = new Context();\n    Configurables.configure(s1, context);\n    Configurables.configure(s2, context);\n    Configurables.configure(s3, context);\n    Configurables.configure(ch, context);\n    ch.start();\n    List<Sink> sinks = new LinkedList<Sink>();\n    sinks.add(s1);\n    sinks.add(s2);\n    sinks.add(s3);\n    SinkGroup group = new SinkGroup(sinks);\n    Map<String, String> params = new HashMap<String, String>();\n    params.put(\"sinks\", \"s1 s2 s3\");\n    params.put(\"processor.type\", \"failover\");\n    params.put(\"processor.priority.s1\", \"3\");\n    params.put(\"processor.priority.s2\", \"2\");\n    params.put(\"processor.priority.s3\", \"1\");\n    params.put(\"processor.maxpenalty\", \"10000\");\n    context.putAll(params);\n    Configurables.configure(group, context);\n    SinkRunner runner = new SinkRunner(group.getProcessor());\n    runner.start();\n    Assert.assertEquals(LifecycleState.START, s1.getLifecycleState());\n    Assert.assertEquals(LifecycleState.START, s2.getLifecycleState());\n    Assert.assertEquals(LifecycleState.START, s3.getLifecycleState());\n    for (int i = 0; i < 15; i++) {\n      Transaction tx = ch.getTransaction();\n      tx.begin();\n      ch.put(EventBuilder.withBody(\"test\".getBytes()));\n      tx.commit();\n      tx.close();\n    }\n    Thread.sleep(100);\n\n    Assert.assertEquals(new Integer(10), s1.getWritten());\n    Assert.assertEquals(new Integer(5), s2.getWritten());\n    for (int i = 0; i < 50; i++) {\n      Transaction tx = ch.getTransaction();\n      tx.begin();\n      ch.put(EventBuilder.withBody(\"test\".getBytes()));\n      tx.commit();\n      tx.close();\n    }\n    Thread.sleep(100);\n\n    Assert.assertEquals(new Integer(50), s2.getWritten());\n    Assert.assertEquals(new Integer(5), s3.getWritten());\n    // test rollover to recovered servers\n    s2.setRemaining(20);\n\n    // get us past the retry time for the failed sink\n    Thread.sleep(5000);\n\n    for (int i = 0; i < 100; i++) {\n      Transaction tx = ch.getTransaction();\n      tx.begin();\n      ch.put(EventBuilder.withBody(\"test\".getBytes()));\n      tx.commit();\n      tx.close();\n    }\n    Thread.sleep(1000);\n\n    Assert.assertEquals(new Integer(10), s1.getWritten());\n    Assert.assertEquals(new Integer(70), s2.getWritten());\n    Assert.assertEquals(new Integer(85), s3.getWritten());\n\n    runner.stop();\n    ch.stop();\n  }", "signature": "void testFailover()", "full_signature": "@Test public void testFailover()", "class_method_signature": "TestFailoverSinkProcessor.testFailover()", "testcase": true, "constructor": false, "invocations": ["setChannel", "setName", "setChannel", "setName", "setChannel", "setName", "configure", "configure", "configure", "configure", "start", "add", "add", "add", "put", "put", "put", "put", "put", "put", "putAll", "configure", "getProcessor", "start", "assertEquals", "getLifecycleState", "assertEquals", "getLifecycleState", "assertEquals", "getLifecycleState", "getTransaction", "begin", "put", "withBody", "getBytes", "commit", "close", "sleep", "assertEquals", "getWritten", "assertEquals", "getWritten", "getTransaction", "begin", "put", "withBody", "getBytes", "commit", "close", "sleep", "assertEquals", "getWritten", "assertEquals", "getWritten", "setRemaining", "sleep", "getTransaction", "begin", "put", "withBody", "getBytes", "commit", "close", "sleep", "assertEquals", "getWritten", "assertEquals", "getWritten", "assertEquals", "getWritten", "stop", "stop"]}, "focal_class": {"identifier": "FailoverSinkProcessor", "superclass": "extends AbstractSinkProcessor", "interfaces": "", "fields": [{"original_string": "private static final int FAILURE_PENALTY = 1000;", "modifier": "private static final", "type": "int", "declarator": "FAILURE_PENALTY = 1000", "var_name": "FAILURE_PENALTY"}, {"original_string": "private static final int DEFAULT_MAX_PENALTY = 30000;", "modifier": "private static final", "type": "int", "declarator": "DEFAULT_MAX_PENALTY = 30000", "var_name": "DEFAULT_MAX_PENALTY"}, {"original_string": "private static final Logger logger = LoggerFactory.getLogger(FailoverSinkProcessor.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(FailoverSinkProcessor.class)", "var_name": "logger"}, {"original_string": "private static final String PRIORITY_PREFIX = \"priority.\";", "modifier": "private static final", "type": "String", "declarator": "PRIORITY_PREFIX = \"priority.\"", "var_name": "PRIORITY_PREFIX"}, {"original_string": "private static final String MAX_PENALTY_PREFIX = \"maxpenalty\";", "modifier": "private static final", "type": "String", "declarator": "MAX_PENALTY_PREFIX = \"maxpenalty\"", "var_name": "MAX_PENALTY_PREFIX"}, {"original_string": "private Map<String, Sink> sinks;", "modifier": "private", "type": "Map<String, Sink>", "declarator": "sinks", "var_name": "sinks"}, {"original_string": "private Sink activeSink;", "modifier": "private", "type": "Sink", "declarator": "activeSink", "var_name": "activeSink"}, {"original_string": "private SortedMap<Integer, Sink> liveSinks;", "modifier": "private", "type": "SortedMap<Integer, Sink>", "declarator": "liveSinks", "var_name": "liveSinks"}, {"original_string": "private Queue<FailedSink> failedSinks;", "modifier": "private", "type": "Queue<FailedSink>", "declarator": "failedSinks", "var_name": "failedSinks"}, {"original_string": "private int maxPenalty;", "modifier": "private", "type": "int", "declarator": "maxPenalty", "var_name": "maxPenalty"}], "methods": [{"identifier": "configure", "parameters": "(Context context)", "modifiers": "@Override public", "return": "void", "signature": "void configure(Context context)", "full_signature": "@Override public void configure(Context context)", "class_method_signature": "FailoverSinkProcessor.configure(Context context)", "testcase": false, "constructor": false}, {"identifier": "process", "parameters": "()", "modifiers": "@Override public", "return": "Status", "signature": "Status process()", "full_signature": "@Override public Status process()", "class_method_signature": "FailoverSinkProcessor.process()", "testcase": false, "constructor": false}, {"identifier": "moveActiveToDeadAndGetNext", "parameters": "()", "modifiers": "private", "return": "Sink", "signature": "Sink moveActiveToDeadAndGetNext()", "full_signature": "private Sink moveActiveToDeadAndGetNext()", "class_method_signature": "FailoverSinkProcessor.moveActiveToDeadAndGetNext()", "testcase": false, "constructor": false}, {"identifier": "setSinks", "parameters": "(List<Sink> sinks)", "modifiers": "@Override public", "return": "void", "signature": "void setSinks(List<Sink> sinks)", "full_signature": "@Override public void setSinks(List<Sink> sinks)", "class_method_signature": "FailoverSinkProcessor.setSinks(List<Sink> sinks)", "testcase": false, "constructor": false}], "file": "flume-ng-core/src/main/java/org/apache/flume/sink/FailoverSinkProcessor.java"}, "focal_method": {"identifier": "configure", "parameters": "(Context context)", "modifiers": "@Override public", "return": "void", "body": "@Override\n  public void configure(Context context) {\n    liveSinks = new TreeMap<Integer, Sink>();\n    failedSinks = new PriorityQueue<FailedSink>();\n    Integer nextPrio = 0;\n    String maxPenaltyStr = context.getString(MAX_PENALTY_PREFIX);\n    if (maxPenaltyStr == null) {\n      maxPenalty = DEFAULT_MAX_PENALTY;\n    } else {\n      try {\n        maxPenalty = Integer.parseInt(maxPenaltyStr);\n      } catch (NumberFormatException e) {\n        logger.warn(\"{} is not a valid value for {}\",\n                    new Object[] { maxPenaltyStr, MAX_PENALTY_PREFIX });\n        maxPenalty = DEFAULT_MAX_PENALTY;\n      }\n    }\n    for (Entry<String, Sink> entry : sinks.entrySet()) {\n      String priStr = PRIORITY_PREFIX + entry.getKey();\n      Integer priority;\n      try {\n        priority =  Integer.parseInt(context.getString(priStr));\n      } catch (Exception e) {\n        priority = --nextPrio;\n      }\n      if (!liveSinks.containsKey(priority)) {\n        liveSinks.put(priority, sinks.get(entry.getKey()));\n      } else {\n        logger.warn(\"Sink {} not added to FailverSinkProcessor as priority\" +\n            \"duplicates that of sink {}\", entry.getKey(),\n            liveSinks.get(priority));\n      }\n    }\n    activeSink = liveSinks.get(liveSinks.lastKey());\n  }", "signature": "void configure(Context context)", "full_signature": "@Override public void configure(Context context)", "class_method_signature": "FailoverSinkProcessor.configure(Context context)", "testcase": false, "constructor": false, "invocations": ["getString", "parseInt", "warn", "entrySet", "getKey", "parseInt", "getString", "containsKey", "put", "get", "getKey", "warn", "getKey", "get", "get", "lastKey"]}, "repository": {"repo_id": 2198510, "url": "https://github.com/apache/flume", "language": "Java", "is_fork": false, "fork_count": 1372, "stargazer_count": 1971, "size": 44377, "license": "licensed"}}