{"test_class": {"identifier": "HttpHeaderParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static long ONE_MINUTE_MILLIS = 1000L * 60;", "modifier": "private static", "type": "long", "declarator": "ONE_MINUTE_MILLIS = 1000L * 60", "var_name": "ONE_MINUTE_MILLIS"}, {"original_string": "private static long ONE_HOUR_MILLIS = 1000L * 60 * 60;", "modifier": "private static", "type": "long", "declarator": "ONE_HOUR_MILLIS = 1000L * 60 * 60", "var_name": "ONE_HOUR_MILLIS"}, {"original_string": "private static long ONE_DAY_MILLIS = ONE_HOUR_MILLIS * 24;", "modifier": "private static", "type": "long", "declarator": "ONE_DAY_MILLIS = ONE_HOUR_MILLIS * 24", "var_name": "ONE_DAY_MILLIS"}, {"original_string": "private static long ONE_WEEK_MILLIS = ONE_DAY_MILLIS * 7;", "modifier": "private static", "type": "long", "declarator": "ONE_WEEK_MILLIS = ONE_DAY_MILLIS * 7", "var_name": "ONE_WEEK_MILLIS"}, {"original_string": "private Map<String, String> headers;", "modifier": "private", "type": "Map<String, String>", "declarator": "headers", "var_name": "headers"}], "file": "jus-java/src/test/java/io/apptik/comm/jus/toolbox/HttpHeaderParserTest.java"}, "test_case": {"identifier": "parseCacheHeaders_normalExpire", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void parseCacheHeaders_normalExpire() {\n        long now = System.currentTimeMillis();\n        headers.put(\"Date\", rfc1123Date(now));\n        headers.put(\"Last-Modified\", rfc1123Date(now - ONE_DAY_MILLIS));\n        headers.put(\"Expires\", rfc1123Date(now + ONE_HOUR_MILLIS));\n        NetworkResponse response = new NetworkResponse(0, new byte[0], Headers.of(headers), 0);\n        Cache.Entry entry = HttpHeaderParser.parseCacheHeaders(response);\n        assertNotNull(entry);\n        assertNull(entry.etag);\n        assertEqualsWithin(entry.serverDate, now, ONE_MINUTE_MILLIS);\n        assertEqualsWithin(entry.lastModified, (now - ONE_DAY_MILLIS), ONE_MINUTE_MILLIS);\n        assertTrue(entry.softTtl >= (now + ONE_HOUR_MILLIS));\n        assertTrue(entry.ttl == entry.softTtl);\n    }", "signature": "void parseCacheHeaders_normalExpire()", "full_signature": "@Test public void parseCacheHeaders_normalExpire()", "class_method_signature": "HttpHeaderParserTest.parseCacheHeaders_normalExpire()", "testcase": true, "constructor": false, "invocations": ["currentTimeMillis", "put", "rfc1123Date", "put", "rfc1123Date", "put", "rfc1123Date", "of", "parseCacheHeaders", "assertNotNull", "assertNull", "assertEqualsWithin", "assertEqualsWithin", "assertTrue", "assertTrue"]}, "focal_class": {"identifier": "HttpHeaderParser", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "parseCacheHeaders", "parameters": "(NetworkResponse response)", "modifiers": "public static", "return": "Cache.Entry", "signature": "Cache.Entry parseCacheHeaders(NetworkResponse response)", "full_signature": "public static Cache.Entry parseCacheHeaders(NetworkResponse response)", "class_method_signature": "HttpHeaderParser.parseCacheHeaders(NetworkResponse response)", "testcase": false, "constructor": false}, {"identifier": "parseDateAsEpoch", "parameters": "(String dateStr)", "modifiers": "public static", "return": "long", "signature": "long parseDateAsEpoch(String dateStr)", "full_signature": "public static long parseDateAsEpoch(String dateStr)", "class_method_signature": "HttpHeaderParser.parseDateAsEpoch(String dateStr)", "testcase": false, "constructor": false}, {"identifier": "parseCharset", "parameters": "(Map<String, String> headers, String defaultCharset)", "modifiers": "public static", "return": "String", "signature": "String parseCharset(Map<String, String> headers, String defaultCharset)", "full_signature": "public static String parseCharset(Map<String, String> headers, String defaultCharset)", "class_method_signature": "HttpHeaderParser.parseCharset(Map<String, String> headers, String defaultCharset)", "testcase": false, "constructor": false}, {"identifier": "parseCharset", "parameters": "(Map<String, String> headers)", "modifiers": "public static", "return": "String", "signature": "String parseCharset(Map<String, String> headers)", "full_signature": "public static String parseCharset(Map<String, String> headers)", "class_method_signature": "HttpHeaderParser.parseCharset(Map<String, String> headers)", "testcase": false, "constructor": false}], "file": "jus-java/src/main/java/io/apptik/comm/jus/toolbox/HttpHeaderParser.java"}, "focal_method": {"identifier": "parseCacheHeaders", "parameters": "(NetworkResponse response)", "modifiers": "public static", "return": "Cache.Entry", "body": "public static Cache.Entry parseCacheHeaders(NetworkResponse response) {\n        long now = System.currentTimeMillis();\n\n        Headers headers = response.headers;\n\n        long serverDate = 0;\n        long lastModified = 0;\n        long serverExpires = 0;\n        long softExpire = 0;\n        long finalExpire = 0;\n        long maxAge = 0;\n        long staleWhileRevalidate = 0;\n        boolean hasCacheControl = false;\n        boolean mustRevalidate = false;\n\n        String serverEtag = null;\n        String headerValue;\n        List<String> headerValues;\n\n        headerValue = headers.get(\"Date\");\n        if (headerValue != null) {\n            serverDate = parseDateAsEpoch(headerValue);\n        }\n\n        //TODO check multiple cache and make stale if more than 1 value for given directive\n        headerValues = headers.values(\"Cache-Control\");\n        if (headerValues != null && headerValues.size() > 0) {\n            hasCacheControl = true;\n            for (int i = 0; i < headerValues.size(); i++) {\n                String[] tokens = headerValues.get(i).trim().split(\",\");\n                for (int j = 0; j < tokens.length; j++) {\n                    String token = tokens[j].trim();\n                    if (token.equals(\"no-cache\") || token.equals(\"no-store\")) {\n                        return null;\n                    } else if (token.startsWith(\"max-age=\")) {\n                        try {\n                            maxAge = Long.parseLong(token.substring(8));\n                        } catch (Exception e) {\n                        }\n                    } else if (token.startsWith(\"stale-while-revalidate=\")) {\n                        try {\n                            staleWhileRevalidate = Long.parseLong(token.substring(23));\n                        } catch (Exception e) {\n                        }\n                    } else if (token.equals(\"must-revalidate\") || token.equals(\"proxy-revalidate\")) {\n\n                        mustRevalidate = true;\n                    }\n                }\n            }\n        }\n\n        headerValue = headers.get(\"Expires\");\n        if (headerValue != null) {\n            serverExpires = parseDateAsEpoch(headerValue);\n        }\n\n        headerValue = headers.get(\"Last-Modified\");\n        if (headerValue != null) {\n            lastModified = parseDateAsEpoch(headerValue);\n        }\n\n        serverEtag = headers.get(\"ETag\");\n\n        // Cache-Control takes precedence over an Expires header, even if both exist and Expires\n        // is more restrictive.\n        if (hasCacheControl) {\n            softExpire = now + maxAge * 1000;\n            finalExpire = mustRevalidate\n                    ? softExpire\n                    : softExpire + staleWhileRevalidate * 1000;\n        } else if (serverDate > 0 && serverExpires >= serverDate) {\n            // Default semantic for Expire header in HTTP specification is softExpire.\n            softExpire = now + (serverExpires - serverDate);\n            finalExpire = softExpire;\n        }\n\n        Cache.Entry entry = new Cache.Entry();\n        entry.data = response.data;\n        entry.etag = serverEtag;\n        entry.softTtl = softExpire;\n        entry.ttl = finalExpire;\n        entry.serverDate = serverDate;\n        entry.lastModified = lastModified;\n        entry.responseHeaders = headers;\n\n        return entry;\n    }", "signature": "Cache.Entry parseCacheHeaders(NetworkResponse response)", "full_signature": "public static Cache.Entry parseCacheHeaders(NetworkResponse response)", "class_method_signature": "HttpHeaderParser.parseCacheHeaders(NetworkResponse response)", "testcase": false, "constructor": false, "invocations": ["currentTimeMillis", "get", "parseDateAsEpoch", "values", "size", "size", "split", "trim", "get", "trim", "equals", "equals", "startsWith", "parseLong", "substring", "startsWith", "parseLong", "substring", "equals", "equals", "get", "parseDateAsEpoch", "get", "parseDateAsEpoch", "get"]}, "repository": {"repo_id": 28505345, "url": "https://github.com/apptik/jus", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 56, "size": 2057, "license": "licensed"}}