{"test_class": {"identifier": "TestTextTelephony", "superclass": "", "interfaces": "implements TextListener, SpokenInputListener", "fields": [{"original_string": "private static final int MAX_WAIT = 1000;", "modifier": "private static final", "type": "int", "declarator": "MAX_WAIT = 1000", "var_name": "MAX_WAIT"}, {"original_string": "private static final int PORT = 4244;", "modifier": "private static final", "type": "int", "declarator": "PORT = 4244", "var_name": "PORT"}, {"original_string": "private TextServer server;", "modifier": "private", "type": "TextServer", "declarator": "server", "var_name": "server"}, {"original_string": "private TextTelephony telephony;", "modifier": "private", "type": "TextTelephony", "declarator": "telephony", "var_name": "telephony"}, {"original_string": "private final Object lock;", "modifier": "private final", "type": "Object", "declarator": "lock", "var_name": "lock"}, {"original_string": "private String sessionId;", "modifier": "private", "type": "String", "declarator": "sessionId", "var_name": "sessionId"}, {"original_string": "private SsmlDocument receivedDocument;", "modifier": "private", "type": "SsmlDocument", "declarator": "receivedDocument", "var_name": "receivedDocument"}, {"original_string": "private TextRecognitionResult receivedResult;", "modifier": "private", "type": "TextRecognitionResult", "declarator": "receivedResult", "var_name": "receivedResult"}], "file": "org.jvoicexml.implementation.text/src/test/java/org/jvoicexml/implementation/text/TestTextTelephony.java"}, "test_case": {"identifier": "testRecord", "parameters": "()", "modifiers": "@Test(timeout = 5000) public", "return": "void", "body": "@Test(timeout = 5000)\n    public void testRecord() throws Exception, JVoiceXMLEvent {\n        final TextSpokenInput textInput = new TextSpokenInput();\n        textInput.startRecognition(null, null, null);\n        textInput.addListener(this);\n        final String utterance = \"testRecord\";\n        mockGrammarChecker(textInput, utterance);\n        telephony.record(textInput, null);\n        Assert.assertTrue(telephony.isBusy());\n        server.sendInput(utterance);\n        synchronized (lock) {\n            lock.wait(MAX_WAIT);\n        }\n        Assert.assertNotNull(receivedResult);\n        // equals should be already done in mocked grammar\n        // Assert.assertEquals(utterance, receivedResult.getUtterance());\n    }", "signature": "void testRecord()", "full_signature": "@Test(timeout = 5000) public void testRecord()", "class_method_signature": "TestTextTelephony.testRecord()", "testcase": true, "constructor": false, "invocations": ["startRecognition", "addListener", "mockGrammarChecker", "record", "assertTrue", "isBusy", "sendInput", "wait", "assertNotNull"]}, "focal_class": {"identifier": "TextTelephony", "superclass": "", "interfaces": "implements Telephony", "fields": [{"original_string": "private static final Logger LOGGER = Logger.getLogger(TextTelephony.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = Logger.getLogger(TextTelephony.class)", "var_name": "LOGGER"}, {"original_string": "private static final int MAX_TIMEOUT_CONNECT = 1000;", "modifier": "private static final", "type": "int", "declarator": "MAX_TIMEOUT_CONNECT = 1000", "var_name": "MAX_TIMEOUT_CONNECT"}, {"original_string": "private static final int MAX_TIMEOUT_ACK = 100;", "modifier": "private static final", "type": "int", "declarator": "MAX_TIMEOUT_ACK = 100", "var_name": "MAX_TIMEOUT_ACK"}, {"original_string": "private Socket socket;", "modifier": "private", "type": "Socket", "declarator": "socket", "var_name": "socket"}, {"original_string": "private TextReceiverThread receiver;", "modifier": "private", "type": "TextReceiverThread", "declarator": "receiver", "var_name": "receiver"}, {"original_string": "private TextSenderThread sender;", "modifier": "private", "type": "TextSenderThread", "declarator": "sender", "var_name": "sender"}, {"original_string": "private TextSynthesizedOutput textOutput;", "modifier": "private", "type": "TextSynthesizedOutput", "declarator": "textOutput", "var_name": "textOutput"}, {"original_string": "private final Collection<TelephonyListener> listener;", "modifier": "private final", "type": "Collection<TelephonyListener>", "declarator": "listener", "var_name": "listener"}, {"original_string": "private final Map<Integer, PendingMessage> pendingMessages;", "modifier": "private final", "type": "Map<Integer, PendingMessage>", "declarator": "pendingMessages", "var_name": "pendingMessages"}, {"original_string": "private boolean sentHungup;", "modifier": "private", "type": "boolean", "declarator": "sentHungup", "var_name": "sentHungup"}], "methods": [{"identifier": "TextTelephony", "parameters": "()", "modifiers": "public", "return": "", "signature": " TextTelephony()", "full_signature": "public  TextTelephony()", "class_method_signature": "TextTelephony.TextTelephony()", "testcase": false, "constructor": true}, {"identifier": "play", "parameters": "(final SynthesizedOutput output,\n            final CallControlProperties props)", "modifiers": "@Override public", "return": "void", "signature": "void play(final SynthesizedOutput output,\n            final CallControlProperties props)", "full_signature": "@Override public void play(final SynthesizedOutput output,\n            final CallControlProperties props)", "class_method_signature": "TextTelephony.play(final SynthesizedOutput output,\n            final CallControlProperties props)", "testcase": false, "constructor": false}, {"identifier": "addAcknowledgeMessage", "parameters": "(final TextMessage message)", "modifiers": "", "return": "void", "signature": "void addAcknowledgeMessage(final TextMessage message)", "full_signature": " void addAcknowledgeMessage(final TextMessage message)", "class_method_signature": "TextTelephony.addAcknowledgeMessage(final TextMessage message)", "testcase": false, "constructor": false}, {"identifier": "addPendingMessage", "parameters": "(final PendingMessage message)", "modifiers": "", "return": "void", "signature": "void addPendingMessage(final PendingMessage message)", "full_signature": " void addPendingMessage(final PendingMessage message)", "class_method_signature": "TextTelephony.addPendingMessage(final PendingMessage message)", "testcase": false, "constructor": false}, {"identifier": "removePendingMessage", "parameters": "(final int sequenceNumber)", "modifiers": "", "return": "boolean", "signature": "boolean removePendingMessage(final int sequenceNumber)", "full_signature": " boolean removePendingMessage(final int sequenceNumber)", "class_method_signature": "TextTelephony.removePendingMessage(final int sequenceNumber)", "testcase": false, "constructor": false}, {"identifier": "stopPlay", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void stopPlay()", "full_signature": "@Override public void stopPlay()", "class_method_signature": "TextTelephony.stopPlay()", "testcase": false, "constructor": false}, {"identifier": "firePlayStarted", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void firePlayStarted()", "full_signature": "private void firePlayStarted()", "class_method_signature": "TextTelephony.firePlayStarted()", "testcase": false, "constructor": false}, {"identifier": "firePlayStopped", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void firePlayStopped()", "full_signature": "private void firePlayStopped()", "class_method_signature": "TextTelephony.firePlayStopped()", "testcase": false, "constructor": false}, {"identifier": "record", "parameters": "(final SpokenInput input,\n            final CallControlProperties props)", "modifiers": "@Override public", "return": "void", "signature": "void record(final SpokenInput input,\n            final CallControlProperties props)", "full_signature": "@Override public void record(final SpokenInput input,\n            final CallControlProperties props)", "class_method_signature": "TextTelephony.record(final SpokenInput input,\n            final CallControlProperties props)", "testcase": false, "constructor": false}, {"identifier": "recordStopped", "parameters": "()", "modifiers": "", "return": "void", "signature": "void recordStopped()", "full_signature": " void recordStopped()", "class_method_signature": "TextTelephony.recordStopped()", "testcase": false, "constructor": false}, {"identifier": "getRecordingAudioFormat", "parameters": "()", "modifiers": "@Override public", "return": "AudioFormat", "signature": "AudioFormat getRecordingAudioFormat()", "full_signature": "@Override public AudioFormat getRecordingAudioFormat()", "class_method_signature": "TextTelephony.getRecordingAudioFormat()", "testcase": false, "constructor": false}, {"identifier": "startRecording", "parameters": "(final SpokenInput input,\n            final OutputStream stream, final CallControlProperties props)", "modifiers": "@Override public", "return": "void", "signature": "void startRecording(final SpokenInput input,\n            final OutputStream stream, final CallControlProperties props)", "full_signature": "@Override public void startRecording(final SpokenInput input,\n            final OutputStream stream, final CallControlProperties props)", "class_method_signature": "TextTelephony.startRecording(final SpokenInput input,\n            final OutputStream stream, final CallControlProperties props)", "testcase": false, "constructor": false}, {"identifier": "stopRecording", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void stopRecording()", "full_signature": "@Override public void stopRecording()", "class_method_signature": "TextTelephony.stopRecording()", "testcase": false, "constructor": false}, {"identifier": "fireRecordStarted", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void fireRecordStarted()", "full_signature": "private void fireRecordStarted()", "class_method_signature": "TextTelephony.fireRecordStarted()", "testcase": false, "constructor": false}, {"identifier": "fireRecordStopped", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void fireRecordStopped()", "full_signature": "private void fireRecordStopped()", "class_method_signature": "TextTelephony.fireRecordStopped()", "testcase": false, "constructor": false}, {"identifier": "fireHungup", "parameters": "()", "modifiers": "synchronized", "return": "void", "signature": "void fireHungup()", "full_signature": "synchronized void fireHungup()", "class_method_signature": "TextTelephony.fireHungup()", "testcase": false, "constructor": false}, {"identifier": "transfer", "parameters": "(final String dest)", "modifiers": "@Override public", "return": "void", "signature": "void transfer(final String dest)", "full_signature": "@Override public void transfer(final String dest)", "class_method_signature": "TextTelephony.transfer(final String dest)", "testcase": false, "constructor": false}, {"identifier": "hangup", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void hangup()", "full_signature": "@Override public void hangup()", "class_method_signature": "TextTelephony.hangup()", "testcase": false, "constructor": false}, {"identifier": "activate", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void activate()", "full_signature": "@Override public void activate()", "class_method_signature": "TextTelephony.activate()", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "TextTelephony.close()", "testcase": false, "constructor": false}, {"identifier": "getType", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String getType()", "full_signature": "@Override public String getType()", "class_method_signature": "TextTelephony.getType()", "testcase": false, "constructor": false}, {"identifier": "isBusy", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isBusy()", "full_signature": "@Override public boolean isBusy()", "class_method_signature": "TextTelephony.isBusy()", "testcase": false, "constructor": false}, {"identifier": "isActive", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isActive()", "full_signature": "@Override public boolean isActive()", "class_method_signature": "TextTelephony.isActive()", "testcase": false, "constructor": false}, {"identifier": "open", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void open()", "full_signature": "@Override public void open()", "class_method_signature": "TextTelephony.open()", "testcase": false, "constructor": false}, {"identifier": "passivate", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void passivate()", "full_signature": "@Override public void passivate()", "class_method_signature": "TextTelephony.passivate()", "testcase": false, "constructor": false}, {"identifier": "openConnection", "parameters": "(final TextConnectionInformation client)", "modifiers": "private", "return": "Socket", "signature": "Socket openConnection(final TextConnectionInformation client)", "full_signature": "private Socket openConnection(final TextConnectionInformation client)", "class_method_signature": "TextTelephony.openConnection(final TextConnectionInformation client)", "testcase": false, "constructor": false}, {"identifier": "connect", "parameters": "(final ConnectionInformation info)", "modifiers": "@Override public", "return": "void", "signature": "void connect(final ConnectionInformation info)", "full_signature": "@Override public void connect(final ConnectionInformation info)", "class_method_signature": "TextTelephony.connect(final ConnectionInformation info)", "testcase": false, "constructor": false}, {"identifier": "disconnect", "parameters": "(final ConnectionInformation client)", "modifiers": "@Override public", "return": "void", "signature": "void disconnect(final ConnectionInformation client)", "full_signature": "@Override public void disconnect(final ConnectionInformation client)", "class_method_signature": "TextTelephony.disconnect(final ConnectionInformation client)", "testcase": false, "constructor": false}, {"identifier": "addListener", "parameters": "(final TelephonyListener callListener)", "modifiers": "@Override public", "return": "void", "signature": "void addListener(final TelephonyListener callListener)", "full_signature": "@Override public void addListener(final TelephonyListener callListener)", "class_method_signature": "TextTelephony.addListener(final TelephonyListener callListener)", "testcase": false, "constructor": false}, {"identifier": "removeListener", "parameters": "(final TelephonyListener callListener)", "modifiers": "@Override public", "return": "void", "signature": "void removeListener(final TelephonyListener callListener)", "full_signature": "@Override public void removeListener(final TelephonyListener callListener)", "class_method_signature": "TextTelephony.removeListener(final TelephonyListener callListener)", "testcase": false, "constructor": false}, {"identifier": "fireTelephonyEvent", "parameters": "(final TelephonyEvent event)", "modifiers": "private", "return": "void", "signature": "void fireTelephonyEvent(final TelephonyEvent event)", "full_signature": "private void fireTelephonyEvent(final TelephonyEvent event)", "class_method_signature": "TextTelephony.fireTelephonyEvent(final TelephonyEvent event)", "testcase": false, "constructor": false}], "file": "org.jvoicexml.implementation.text/src/main/java/org/jvoicexml/implementation/text/TextTelephony.java"}, "focal_method": {"identifier": "record", "parameters": "(final SpokenInput input,\n            final CallControlProperties props)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void record(final SpokenInput input,\n            final CallControlProperties props)\n            throws NoresourceError, IOException {\n        if (sentHungup) {\n            throw new NoresourceError(\"connection disconnected\");\n        }\n        if (!(input instanceof TextSpokenInput)) {\n            throw new IOException(\"input does not support texts!\");\n        }\n        fireRecordStarted();\n        final TextSpokenInput textInput = (TextSpokenInput) input;\n        receiver.setSpokenInput(textInput);\n        sender.sendExpectingInput();\n    }", "signature": "void record(final SpokenInput input,\n            final CallControlProperties props)", "full_signature": "@Override public void record(final SpokenInput input,\n            final CallControlProperties props)", "class_method_signature": "TextTelephony.record(final SpokenInput input,\n            final CallControlProperties props)", "testcase": false, "constructor": false, "invocations": ["fireRecordStarted", "setSpokenInput", "sendExpectingInput"]}, "repository": {"repo_id": 37717709, "url": "https://github.com/JVoiceXML/JVoiceXML", "language": "Java", "is_fork": false, "fork_count": 32, "stargazer_count": 50, "size": 436089, "license": "licensed"}}