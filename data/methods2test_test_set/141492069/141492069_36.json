{"test_class": {"identifier": "TestUDPConfigHandler", "superclass": "extends UDPTestBase", "interfaces": "", "fields": [{"original_string": "UDPConfigHandler udpConfig;", "modifier": "", "type": "UDPConfigHandler", "declarator": "udpConfig", "var_name": "udpConfig"}, {"original_string": "String sourceName;", "modifier": "", "type": "String", "declarator": "sourceName", "var_name": "sourceName"}, {"original_string": "FalseClient client;", "modifier": "", "type": "FalseClient", "declarator": "client", "var_name": "client"}, {"original_string": "ExtensionServiceMessage msg;", "modifier": "", "type": "ExtensionServiceMessage", "declarator": "msg", "var_name": "msg"}], "file": "udpSource/src/test/java/io/vantiq/extsrc/udp/TestUDPConfigHandler.java"}, "test_case": {"identifier": "testHandleMessage", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testHandleMessage() throws UnknownHostException {\n        ExtensionServiceMessage msg = new ExtensionServiceMessage(\"\");\n        msg.resourceId = sourceName;\n        Map<String,Object> object = new LinkedHashMap<>();\n        msg.object = object;\n        Map<String,Object> config = new LinkedHashMap<>();\n        object.put(\"config\", config);\n        Map<String,Object> udpSourceConfig = new LinkedHashMap<>();\n        config.put(\"udpSourceConfig\", udpSourceConfig);\n        Map<String,Object> general = new LinkedHashMap<>();\n        Map<String,Object> incoming = new LinkedHashMap<>();\n        Map<String,Object> outgoing = new LinkedHashMap<>();\n        udpSourceConfig.put(\"type\", \"udp\");\n        udpSourceConfig.put(\"general\", general);\n        udpSourceConfig.put(\"incoming\", incoming);\n        udpSourceConfig.put(\"outgoing\", outgoing);\n        \n        udpConfig.handleMessage(msg);\n        \n        assert !ConfigurableUDPSource.notificationHandlers.containsKey(sourceName);\n        assert ConfigurableUDPSource.udpSocketToSources.isEmpty();\n        \n        int port = 10213;\n        String addressName = \"invalidAddress\";\n        incoming.put(\"passPureMapIn\", true);\n        outgoing.put(\"targetPort\", port);\n        outgoing.put(\"targetAddress\", addressName);\n        \n        // initialize default address\n        InetAddress address = InetAddress.getLocalHost();\n        ConfigurableUDPSource.LISTENING_ADDRESS = address;\n        \n        assumeTrue(\"Cannot perform test. Address at port:\" + port + \" and IP:\" + address + \"already bound\"\n                , socketCanBind(port, address));\n        udpConfig.handleMessage(msg);\n        \n        assert ConfigurableUDPSource.notificationHandlers.containsKey(sourceName);\n        DatagramSocket socket = (DatagramSocket) ConfigurableUDPSource.udpSocketToSources.keySet().toArray()[0];\n        assert socket.getLocalPort() == 3141;\n        assert socket.getLocalAddress().equals(ConfigurableUDPSource.LISTENING_ADDRESS);\n        \n        addressName = \"localhost\";\n        address = InetAddress.getByName(addressName);\n        general.put(\"listenPort\", port);\n        general.put(\"listenAddress\", addressName);\n        \n        assumeTrue(\"Cannot perform test. Address at port:\" + port + \" and IP:\" + address + \"already bound\"\n                , socketCanBind(port, address));\n        udpConfig.handleMessage(msg);\n        \n        assert ConfigurableUDPSource.udpSocketToSources.keySet().size() == 2;\n    }", "signature": "void testHandleMessage()", "full_signature": "@Test public void testHandleMessage()", "class_method_signature": "TestUDPConfigHandler.testHandleMessage()", "testcase": true, "constructor": false, "invocations": ["put", "put", "put", "put", "put", "put", "handleMessage", "containsKey", "isEmpty", "put", "put", "put", "getLocalHost", "assumeTrue", "socketCanBind", "handleMessage", "containsKey", "toArray", "keySet", "getLocalPort", "equals", "getLocalAddress", "getByName", "put", "put", "assumeTrue", "socketCanBind", "handleMessage", "size", "keySet"]}, "focal_class": {"identifier": "UDPConfigHandler", "superclass": "extends Handler<ExtensionServiceMessage>", "interfaces": "", "fields": [], "methods": [{"identifier": "handleMessage", "parameters": "(ExtensionServiceMessage message)", "modifiers": "@Override public", "return": "void", "signature": "void handleMessage(ExtensionServiceMessage message)", "full_signature": "@Override public void handleMessage(ExtensionServiceMessage message)", "class_method_signature": "UDPConfigHandler.handleMessage(ExtensionServiceMessage message)", "testcase": false, "constructor": false}, {"identifier": "getListeningPort", "parameters": "(Map general,String sourceName)", "modifiers": "", "return": "int", "signature": "int getListeningPort(Map general,String sourceName)", "full_signature": " int getListeningPort(Map general,String sourceName)", "class_method_signature": "UDPConfigHandler.getListeningPort(Map general,String sourceName)", "testcase": false, "constructor": false}, {"identifier": "getListeningAddress", "parameters": "(Map general, String sourceName)", "modifiers": "", "return": "InetAddress", "signature": "InetAddress getListeningAddress(Map general, String sourceName)", "full_signature": " InetAddress getListeningAddress(Map general, String sourceName)", "class_method_signature": "UDPConfigHandler.getListeningAddress(Map general, String sourceName)", "testcase": false, "constructor": false}, {"identifier": "isConfiguredToSend", "parameters": "(Map outgoing)", "modifiers": "", "return": "boolean", "signature": "boolean isConfiguredToSend(Map outgoing)", "full_signature": " boolean isConfiguredToSend(Map outgoing)", "class_method_signature": "UDPConfigHandler.isConfiguredToSend(Map outgoing)", "testcase": false, "constructor": false}, {"identifier": "isConfiguredToReceive", "parameters": "(Map incoming)", "modifiers": "", "return": "boolean", "signature": "boolean isConfiguredToReceive(Map incoming)", "full_signature": " boolean isConfiguredToReceive(Map incoming)", "class_method_signature": "UDPConfigHandler.isConfiguredToReceive(Map incoming)", "testcase": false, "constructor": false}, {"identifier": "hasValidAddress", "parameters": "(List potentialAddresses)", "modifiers": "", "return": "boolean", "signature": "boolean hasValidAddress(List potentialAddresses)", "full_signature": " boolean hasValidAddress(List potentialAddresses)", "class_method_signature": "UDPConfigHandler.hasValidAddress(List potentialAddresses)", "testcase": false, "constructor": false}, {"identifier": "hasValidPort", "parameters": "(List potentialPorts)", "modifiers": "", "return": "boolean", "signature": "boolean hasValidPort(List potentialPorts)", "full_signature": " boolean hasValidPort(List potentialPorts)", "class_method_signature": "UDPConfigHandler.hasValidPort(List potentialPorts)", "testcase": false, "constructor": false}, {"identifier": "hasValidServer", "parameters": "(List potentialServers)", "modifiers": "", "return": "boolean", "signature": "boolean hasValidServer(List potentialServers)", "full_signature": " boolean hasValidServer(List potentialServers)", "class_method_signature": "UDPConfigHandler.hasValidServer(List potentialServers)", "testcase": false, "constructor": false}, {"identifier": "hasValidTransform", "parameters": "(List potentialTransformations)", "modifiers": "", "return": "boolean", "signature": "boolean hasValidTransform(List potentialTransformations)", "full_signature": " boolean hasValidTransform(List potentialTransformations)", "class_method_signature": "UDPConfigHandler.hasValidTransform(List potentialTransformations)", "testcase": false, "constructor": false}, {"identifier": "isValidRegexParser", "parameters": "(Map potentialParser)", "modifiers": "", "return": "boolean", "signature": "boolean isValidRegexParser(Map potentialParser)", "full_signature": " boolean isValidRegexParser(Map potentialParser)", "class_method_signature": "UDPConfigHandler.isValidRegexParser(Map potentialParser)", "testcase": false, "constructor": false}], "file": "udpSource/src/main/java/io/vantiq/extsrc/udp/UDPConfigHandler.java"}, "focal_method": {"identifier": "handleMessage", "parameters": "(ExtensionServiceMessage message)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void handleMessage(ExtensionServiceMessage message) {\n        String sourceName = message.getSourceName();\n        Logger log = LoggerFactory.getLogger(this.getClass().getCanonicalName() + \"#\" + sourceName);\n        Map srcConfig = (Map) ((Map)message.getObject()).get(\"config\");\n        if (!(srcConfig.get(\"udpSourceConfig\") instanceof Map)) {\n            log.error(\"Unable to obtain source configuration.\");\n            return;\n        }\n        Map config = (Map) srcConfig.get(\"udpSourceConfig\");\n        log.trace(\"Creating handlers\");\n\n        // Acquire the general settings Map and the listening port and address\n        Map general = null;\n        if (config.get(\"general\") instanceof Map) {\n            general = (Map) config.get(\"general\");\n        }\n        int port = getListeningPort(general, sourceName);\n        InetAddress address = getListeningAddress(general, sourceName);\n        \n        Map incoming = null;\n        Map outgoing = null;\n        if (config.get(\"incoming\") instanceof Map) {\n            incoming = (Map) config.get(\"incoming\");\n        }\n        if (config.get(\"outgoing\") instanceof Map) {\n            outgoing = (Map) config.get(\"outgoing\");\n        }\n        \n        if (!isConfiguredToSend(outgoing) && !isConfiguredToReceive(incoming)) {\n            log.error(\"Source is not configured to send or receive.\");\n            return;\n        }\n\n        // Synchronization necessary because createUDPSocket creates a list which listenOnUDPSocket will add to.\n        // If threads change between the creation of the UDP socket and the assignation of the list or while\n        // a source is being added to the list, an error is likely to occur\n        DatagramSocket socket;\n        synchronized (ConfigurableUDPSource.socketLock) {\n            // Create the socket that the source will use for UDP messages\n            socket = ConfigurableUDPSource.createUDPSocket(port, address, sourceName);\n            if (socket == null) { // No socket could be created for the given port and address\n                socket = ConfigurableUDPSource.listenOnUDPSocket(port, address, sourceName);\n            }\n            if (socket == null) {\n                log.error(\"Failed to obtain UDP socket at address '{}' and port '{}'\", address, port);\n                return;\n            }\n        }\n\n        // Setup Publish handler as the configuration document requests\n        if (isConfiguredToSend(outgoing)) {\n            UDPPublishHandler handler = new UDPPublishHandler(outgoing, socket, sourceName);\n            ConfigurableUDPSource.clients.get(sourceName).setPublishHandler(handler);\n            log.debug(\"Publish handler created\");\n        }\n\n        // Setup Notification handler as the configuration document requests\n        if (isConfiguredToReceive(incoming)) {\n            UDPNotificationHandler handler = new UDPNotificationHandler(incoming, ConfigurableUDPSource.clients.get(sourceName));\n            ConfigurableUDPSource.setNotificationHandler(handler, sourceName, incoming);\n            log.debug(\"Notification handler created\");\n        }\n        log.info(\"Source setup and ready to go.\");\n    }", "signature": "void handleMessage(ExtensionServiceMessage message)", "full_signature": "@Override public void handleMessage(ExtensionServiceMessage message)", "class_method_signature": "UDPConfigHandler.handleMessage(ExtensionServiceMessage message)", "testcase": false, "constructor": false, "invocations": ["getSourceName", "getLogger", "getCanonicalName", "getClass", "get", "getObject", "get", "error", "get", "trace", "get", "get", "getListeningPort", "getListeningAddress", "get", "get", "get", "get", "isConfiguredToSend", "isConfiguredToReceive", "error", "createUDPSocket", "listenOnUDPSocket", "error", "isConfiguredToSend", "setPublishHandler", "get", "debug", "isConfiguredToReceive", "get", "setNotificationHandler", "debug", "info"]}, "repository": {"repo_id": 141492069, "url": "https://github.com/Vantiq/vantiq-extension-sources", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 9, "size": 16261, "license": "licensed"}}