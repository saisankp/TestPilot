{"test_class": {"identifier": "ConsumerConfigTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final Deserializer keyDeserializer = new ByteArrayDeserializer();", "modifier": "private final", "type": "Deserializer", "declarator": "keyDeserializer = new ByteArrayDeserializer()", "var_name": "keyDeserializer"}, {"original_string": "private final Deserializer valueDeserializer = new StringDeserializer();", "modifier": "private final", "type": "Deserializer", "declarator": "valueDeserializer = new StringDeserializer()", "var_name": "valueDeserializer"}, {"original_string": "private final String keyDeserializerClassName = keyDeserializer.getClass().getName();", "modifier": "private final", "type": "String", "declarator": "keyDeserializerClassName = keyDeserializer.getClass().getName()", "var_name": "keyDeserializerClassName"}, {"original_string": "private final String valueDeserializerClassName = valueDeserializer.getClass().getName();", "modifier": "private final", "type": "String", "declarator": "valueDeserializerClassName = valueDeserializer.getClass().getName()", "var_name": "valueDeserializerClassName"}, {"original_string": "private final Object keyDeserializerClass = keyDeserializer.getClass();", "modifier": "private final", "type": "Object", "declarator": "keyDeserializerClass = keyDeserializer.getClass()", "var_name": "keyDeserializerClass"}, {"original_string": "private final Object valueDeserializerClass = valueDeserializer.getClass();", "modifier": "private final", "type": "Object", "declarator": "valueDeserializerClass = valueDeserializer.getClass()", "var_name": "valueDeserializerClass"}], "file": "clients/src/test/java/org/apache/kafka/clients/consumer/ConsumerConfigTest.java"}, "test_case": {"identifier": "testDeserializerToMapConfig", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDeserializerToMapConfig() {\n        Map<String, Object> configs = new HashMap<>();\n        configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, keyDeserializerClass);\n        configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, valueDeserializerClass);\n        Map<String, Object> newConfigs = ConsumerConfig.addDeserializerToConfig(configs, null, null);\n        assertEquals(newConfigs.get(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG), keyDeserializerClass);\n        assertEquals(newConfigs.get(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG), valueDeserializerClass);\n\n        configs.clear();\n        configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, valueDeserializerClass);\n        newConfigs = ConsumerConfig.addDeserializerToConfig(configs, keyDeserializer, null);\n        assertEquals(newConfigs.get(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG), keyDeserializerClass);\n        assertEquals(newConfigs.get(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG), valueDeserializerClass);\n\n        configs.clear();\n        configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, keyDeserializerClass);\n        newConfigs = ConsumerConfig.addDeserializerToConfig(configs, null, valueDeserializer);\n        assertEquals(newConfigs.get(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG), keyDeserializerClass);\n        assertEquals(newConfigs.get(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG), valueDeserializerClass);\n\n        configs.clear();\n        newConfigs = ConsumerConfig.addDeserializerToConfig(configs, keyDeserializer, valueDeserializer);\n        assertEquals(newConfigs.get(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG), keyDeserializerClass);\n        assertEquals(newConfigs.get(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG), valueDeserializerClass);\n    }", "signature": "void testDeserializerToMapConfig()", "full_signature": "@Test public void testDeserializerToMapConfig()", "class_method_signature": "ConsumerConfigTest.testDeserializerToMapConfig()", "testcase": true, "constructor": false, "invocations": ["put", "put", "addDeserializerToConfig", "assertEquals", "get", "assertEquals", "get", "clear", "put", "addDeserializerToConfig", "assertEquals", "get", "assertEquals", "get", "clear", "put", "addDeserializerToConfig", "assertEquals", "get", "assertEquals", "get", "clear", "addDeserializerToConfig", "assertEquals", "get", "assertEquals", "get"]}, "focal_class": {"identifier": "ConsumerConfig", "superclass": "extends AbstractConfig", "interfaces": "", "fields": [{"original_string": "private static final ConfigDef CONFIG;", "modifier": "private static final", "type": "ConfigDef", "declarator": "CONFIG", "var_name": "CONFIG"}, {"original_string": "public static final String GROUP_ID_CONFIG = \"group.id\";", "modifier": "public static final", "type": "String", "declarator": "GROUP_ID_CONFIG = \"group.id\"", "var_name": "GROUP_ID_CONFIG"}, {"original_string": "private static final String GROUP_ID_DOC = \"A unique string that identifies the consumer group this consumer belongs to. This property is required if the consumer uses either the group management functionality by using <code>subscribe(topic)</code> or the Kafka-based offset management strategy.\";", "modifier": "private static final", "type": "String", "declarator": "GROUP_ID_DOC = \"A unique string that identifies the consumer group this consumer belongs to. This property is required if the consumer uses either the group management functionality by using <code>subscribe(topic)</code> or the Kafka-based offset management strategy.\"", "var_name": "GROUP_ID_DOC"}, {"original_string": "public static final String MAX_POLL_RECORDS_CONFIG = \"max.poll.records\";", "modifier": "public static final", "type": "String", "declarator": "MAX_POLL_RECORDS_CONFIG = \"max.poll.records\"", "var_name": "MAX_POLL_RECORDS_CONFIG"}, {"original_string": "private static final String MAX_POLL_RECORDS_DOC = \"The maximum number of records returned in a single call to poll().\";", "modifier": "private static final", "type": "String", "declarator": "MAX_POLL_RECORDS_DOC = \"The maximum number of records returned in a single call to poll().\"", "var_name": "MAX_POLL_RECORDS_DOC"}, {"original_string": "public static final String SESSION_TIMEOUT_MS_CONFIG = \"session.timeout.ms\";", "modifier": "public static final", "type": "String", "declarator": "SESSION_TIMEOUT_MS_CONFIG = \"session.timeout.ms\"", "var_name": "SESSION_TIMEOUT_MS_CONFIG"}, {"original_string": "private static final String SESSION_TIMEOUT_MS_DOC = \"The timeout used to detect failures when using Kafka's \" +\n            \"group management facilities. When a consumer's heartbeat is not received within the session timeout, \" +\n            \"the broker will mark the consumer as failed and rebalance the group. Since heartbeats are sent only \" +\n            \"when poll() is invoked, a higher session timeout allows more time for message processing in the consumer's \" +\n            \"poll loop at the cost of a longer time to detect hard failures. See also <code>\" + MAX_POLL_RECORDS_CONFIG + \"</code> for \" +\n            \"another option to control the processing time in the poll loop. Note that the value must be in the \" +\n            \"allowable range as configured in the broker configuration by <code>group.min.session.timeout.ms</code> \" +\n            \"and <code>group.max.session.timeout.ms</code>.\";", "modifier": "private static final", "type": "String", "declarator": "SESSION_TIMEOUT_MS_DOC = \"The timeout used to detect failures when using Kafka's \" +\n            \"group management facilities. When a consumer's heartbeat is not received within the session timeout, \" +\n            \"the broker will mark the consumer as failed and rebalance the group. Since heartbeats are sent only \" +\n            \"when poll() is invoked, a higher session timeout allows more time for message processing in the consumer's \" +\n            \"poll loop at the cost of a longer time to detect hard failures. See also <code>\" + MAX_POLL_RECORDS_CONFIG + \"</code> for \" +\n            \"another option to control the processing time in the poll loop. Note that the value must be in the \" +\n            \"allowable range as configured in the broker configuration by <code>group.min.session.timeout.ms</code> \" +\n            \"and <code>group.max.session.timeout.ms</code>.\"", "var_name": "SESSION_TIMEOUT_MS_DOC"}, {"original_string": "public static final String HEARTBEAT_INTERVAL_MS_CONFIG = \"heartbeat.interval.ms\";", "modifier": "public static final", "type": "String", "declarator": "HEARTBEAT_INTERVAL_MS_CONFIG = \"heartbeat.interval.ms\"", "var_name": "HEARTBEAT_INTERVAL_MS_CONFIG"}, {"original_string": "private static final String HEARTBEAT_INTERVAL_MS_DOC = \"The expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities. Heartbeats are used to ensure that the consumer's session stays active and to facilitate rebalancing when new consumers join or leave the group. The value must be set lower than <code>session.timeout.ms</code>, but typically should be set no higher than 1/3 of that value. It can be adjusted even lower to control the expected time for normal rebalances.\";", "modifier": "private static final", "type": "String", "declarator": "HEARTBEAT_INTERVAL_MS_DOC = \"The expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities. Heartbeats are used to ensure that the consumer's session stays active and to facilitate rebalancing when new consumers join or leave the group. The value must be set lower than <code>session.timeout.ms</code>, but typically should be set no higher than 1/3 of that value. It can be adjusted even lower to control the expected time for normal rebalances.\"", "var_name": "HEARTBEAT_INTERVAL_MS_DOC"}, {"original_string": "public static final String BOOTSTRAP_SERVERS_CONFIG = CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "BOOTSTRAP_SERVERS_CONFIG = CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG", "var_name": "BOOTSTRAP_SERVERS_CONFIG"}, {"original_string": "public static final String ENABLE_AUTO_COMMIT_CONFIG = \"enable.auto.commit\";", "modifier": "public static final", "type": "String", "declarator": "ENABLE_AUTO_COMMIT_CONFIG = \"enable.auto.commit\"", "var_name": "ENABLE_AUTO_COMMIT_CONFIG"}, {"original_string": "private static final String ENABLE_AUTO_COMMIT_DOC = \"If true the consumer's offset will be periodically committed in the background.\";", "modifier": "private static final", "type": "String", "declarator": "ENABLE_AUTO_COMMIT_DOC = \"If true the consumer's offset will be periodically committed in the background.\"", "var_name": "ENABLE_AUTO_COMMIT_DOC"}, {"original_string": "public static final String AUTO_COMMIT_INTERVAL_MS_CONFIG = \"auto.commit.interval.ms\";", "modifier": "public static final", "type": "String", "declarator": "AUTO_COMMIT_INTERVAL_MS_CONFIG = \"auto.commit.interval.ms\"", "var_name": "AUTO_COMMIT_INTERVAL_MS_CONFIG"}, {"original_string": "private static final String AUTO_COMMIT_INTERVAL_MS_DOC = \"The frequency in milliseconds that the consumer offsets are auto-committed to Kafka if <code>enable.auto.commit</code> is set to <code>true</code>.\";", "modifier": "private static final", "type": "String", "declarator": "AUTO_COMMIT_INTERVAL_MS_DOC = \"The frequency in milliseconds that the consumer offsets are auto-committed to Kafka if <code>enable.auto.commit</code> is set to <code>true</code>.\"", "var_name": "AUTO_COMMIT_INTERVAL_MS_DOC"}, {"original_string": "public static final String PARTITION_ASSIGNMENT_STRATEGY_CONFIG = \"partition.assignment.strategy\";", "modifier": "public static final", "type": "String", "declarator": "PARTITION_ASSIGNMENT_STRATEGY_CONFIG = \"partition.assignment.strategy\"", "var_name": "PARTITION_ASSIGNMENT_STRATEGY_CONFIG"}, {"original_string": "private static final String PARTITION_ASSIGNMENT_STRATEGY_DOC = \"The class name of the partition assignment strategy that the client will use to distribute partition ownership amongst consumer instances when group management is used\";", "modifier": "private static final", "type": "String", "declarator": "PARTITION_ASSIGNMENT_STRATEGY_DOC = \"The class name of the partition assignment strategy that the client will use to distribute partition ownership amongst consumer instances when group management is used\"", "var_name": "PARTITION_ASSIGNMENT_STRATEGY_DOC"}, {"original_string": "public static final String AUTO_OFFSET_RESET_CONFIG = \"auto.offset.reset\";", "modifier": "public static final", "type": "String", "declarator": "AUTO_OFFSET_RESET_CONFIG = \"auto.offset.reset\"", "var_name": "AUTO_OFFSET_RESET_CONFIG"}, {"original_string": "public static final String AUTO_OFFSET_RESET_DOC = \"What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server (e.g. because that data has been deleted): <ul><li>earliest: automatically reset the offset to the earliest offset<li>latest: automatically reset the offset to the latest offset</li><li>none: throw exception to the consumer if no previous offset is found for the consumer's group</li><li>anything else: throw exception to the consumer.</li></ul>\";", "modifier": "public static final", "type": "String", "declarator": "AUTO_OFFSET_RESET_DOC = \"What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server (e.g. because that data has been deleted): <ul><li>earliest: automatically reset the offset to the earliest offset<li>latest: automatically reset the offset to the latest offset</li><li>none: throw exception to the consumer if no previous offset is found for the consumer's group</li><li>anything else: throw exception to the consumer.</li></ul>\"", "var_name": "AUTO_OFFSET_RESET_DOC"}, {"original_string": "public static final String FETCH_MIN_BYTES_CONFIG = \"fetch.min.bytes\";", "modifier": "public static final", "type": "String", "declarator": "FETCH_MIN_BYTES_CONFIG = \"fetch.min.bytes\"", "var_name": "FETCH_MIN_BYTES_CONFIG"}, {"original_string": "private static final String FETCH_MIN_BYTES_DOC = \"The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request. The default setting of 1 byte means that fetch requests are answered as soon as a single byte of data is available or the fetch request times out waiting for data to arrive. Setting this to something greater than 1 will cause the server to wait for larger amounts of data to accumulate which can improve server throughput a bit at the cost of some additional latency.\";", "modifier": "private static final", "type": "String", "declarator": "FETCH_MIN_BYTES_DOC = \"The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request. The default setting of 1 byte means that fetch requests are answered as soon as a single byte of data is available or the fetch request times out waiting for data to arrive. Setting this to something greater than 1 will cause the server to wait for larger amounts of data to accumulate which can improve server throughput a bit at the cost of some additional latency.\"", "var_name": "FETCH_MIN_BYTES_DOC"}, {"original_string": "public static final String FETCH_MAX_WAIT_MS_CONFIG = \"fetch.max.wait.ms\";", "modifier": "public static final", "type": "String", "declarator": "FETCH_MAX_WAIT_MS_CONFIG = \"fetch.max.wait.ms\"", "var_name": "FETCH_MAX_WAIT_MS_CONFIG"}, {"original_string": "private static final String FETCH_MAX_WAIT_MS_DOC = \"The maximum amount of time the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy the requirement given by fetch.min.bytes.\";", "modifier": "private static final", "type": "String", "declarator": "FETCH_MAX_WAIT_MS_DOC = \"The maximum amount of time the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy the requirement given by fetch.min.bytes.\"", "var_name": "FETCH_MAX_WAIT_MS_DOC"}, {"original_string": "public static final String METADATA_MAX_AGE_CONFIG = CommonClientConfigs.METADATA_MAX_AGE_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "METADATA_MAX_AGE_CONFIG = CommonClientConfigs.METADATA_MAX_AGE_CONFIG", "var_name": "METADATA_MAX_AGE_CONFIG"}, {"original_string": "public static final String MAX_PARTITION_FETCH_BYTES_CONFIG = \"max.partition.fetch.bytes\";", "modifier": "public static final", "type": "String", "declarator": "MAX_PARTITION_FETCH_BYTES_CONFIG = \"max.partition.fetch.bytes\"", "var_name": "MAX_PARTITION_FETCH_BYTES_CONFIG"}, {"original_string": "private static final String MAX_PARTITION_FETCH_BYTES_DOC = \"The maximum amount of data per-partition the server will return. The maximum total memory used for a request will be <code>#partitions * max.partition.fetch.bytes</code>. This size must be at least as large as the maximum message size the server allows or else it is possible for the producer to send messages larger than the consumer can fetch. If that happens, the consumer can get stuck trying to fetch a large message on a certain partition.\";", "modifier": "private static final", "type": "String", "declarator": "MAX_PARTITION_FETCH_BYTES_DOC = \"The maximum amount of data per-partition the server will return. The maximum total memory used for a request will be <code>#partitions * max.partition.fetch.bytes</code>. This size must be at least as large as the maximum message size the server allows or else it is possible for the producer to send messages larger than the consumer can fetch. If that happens, the consumer can get stuck trying to fetch a large message on a certain partition.\"", "var_name": "MAX_PARTITION_FETCH_BYTES_DOC"}, {"original_string": "public static final int DEFAULT_MAX_PARTITION_FETCH_BYTES = 1 * 1024 * 1024;", "modifier": "public static final", "type": "int", "declarator": "DEFAULT_MAX_PARTITION_FETCH_BYTES = 1 * 1024 * 1024", "var_name": "DEFAULT_MAX_PARTITION_FETCH_BYTES"}, {"original_string": "public static final String SEND_BUFFER_CONFIG = CommonClientConfigs.SEND_BUFFER_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "SEND_BUFFER_CONFIG = CommonClientConfigs.SEND_BUFFER_CONFIG", "var_name": "SEND_BUFFER_CONFIG"}, {"original_string": "public static final String RECEIVE_BUFFER_CONFIG = CommonClientConfigs.RECEIVE_BUFFER_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "RECEIVE_BUFFER_CONFIG = CommonClientConfigs.RECEIVE_BUFFER_CONFIG", "var_name": "RECEIVE_BUFFER_CONFIG"}, {"original_string": "public static final String CLIENT_ID_CONFIG = CommonClientConfigs.CLIENT_ID_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "CLIENT_ID_CONFIG = CommonClientConfigs.CLIENT_ID_CONFIG", "var_name": "CLIENT_ID_CONFIG"}, {"original_string": "public static final String RECONNECT_BACKOFF_MS_CONFIG = CommonClientConfigs.RECONNECT_BACKOFF_MS_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "RECONNECT_BACKOFF_MS_CONFIG = CommonClientConfigs.RECONNECT_BACKOFF_MS_CONFIG", "var_name": "RECONNECT_BACKOFF_MS_CONFIG"}, {"original_string": "public static final String RETRY_BACKOFF_MS_CONFIG = CommonClientConfigs.RETRY_BACKOFF_MS_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "RETRY_BACKOFF_MS_CONFIG = CommonClientConfigs.RETRY_BACKOFF_MS_CONFIG", "var_name": "RETRY_BACKOFF_MS_CONFIG"}, {"original_string": "public static final String METRICS_SAMPLE_WINDOW_MS_CONFIG = CommonClientConfigs.METRICS_SAMPLE_WINDOW_MS_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "METRICS_SAMPLE_WINDOW_MS_CONFIG = CommonClientConfigs.METRICS_SAMPLE_WINDOW_MS_CONFIG", "var_name": "METRICS_SAMPLE_WINDOW_MS_CONFIG"}, {"original_string": "public static final String METRICS_NUM_SAMPLES_CONFIG = CommonClientConfigs.METRICS_NUM_SAMPLES_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "METRICS_NUM_SAMPLES_CONFIG = CommonClientConfigs.METRICS_NUM_SAMPLES_CONFIG", "var_name": "METRICS_NUM_SAMPLES_CONFIG"}, {"original_string": "public static final String METRIC_REPORTER_CLASSES_CONFIG = CommonClientConfigs.METRIC_REPORTER_CLASSES_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "METRIC_REPORTER_CLASSES_CONFIG = CommonClientConfigs.METRIC_REPORTER_CLASSES_CONFIG", "var_name": "METRIC_REPORTER_CLASSES_CONFIG"}, {"original_string": "public static final String CHECK_CRCS_CONFIG = \"check.crcs\";", "modifier": "public static final", "type": "String", "declarator": "CHECK_CRCS_CONFIG = \"check.crcs\"", "var_name": "CHECK_CRCS_CONFIG"}, {"original_string": "private static final String CHECK_CRCS_DOC = \"Automatically check the CRC32 of the records consumed. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance.\";", "modifier": "private static final", "type": "String", "declarator": "CHECK_CRCS_DOC = \"Automatically check the CRC32 of the records consumed. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance.\"", "var_name": "CHECK_CRCS_DOC"}, {"original_string": "public static final String KEY_DESERIALIZER_CLASS_CONFIG = \"key.deserializer\";", "modifier": "public static final", "type": "String", "declarator": "KEY_DESERIALIZER_CLASS_CONFIG = \"key.deserializer\"", "var_name": "KEY_DESERIALIZER_CLASS_CONFIG"}, {"original_string": "public static final String KEY_DESERIALIZER_CLASS_DOC = \"Deserializer class for key that implements the <code>Deserializer</code> interface.\";", "modifier": "public static final", "type": "String", "declarator": "KEY_DESERIALIZER_CLASS_DOC = \"Deserializer class for key that implements the <code>Deserializer</code> interface.\"", "var_name": "KEY_DESERIALIZER_CLASS_DOC"}, {"original_string": "public static final String VALUE_DESERIALIZER_CLASS_CONFIG = \"value.deserializer\";", "modifier": "public static final", "type": "String", "declarator": "VALUE_DESERIALIZER_CLASS_CONFIG = \"value.deserializer\"", "var_name": "VALUE_DESERIALIZER_CLASS_CONFIG"}, {"original_string": "public static final String VALUE_DESERIALIZER_CLASS_DOC = \"Deserializer class for value that implements the <code>Deserializer</code> interface.\";", "modifier": "public static final", "type": "String", "declarator": "VALUE_DESERIALIZER_CLASS_DOC = \"Deserializer class for value that implements the <code>Deserializer</code> interface.\"", "var_name": "VALUE_DESERIALIZER_CLASS_DOC"}, {"original_string": "public static final String CONNECTIONS_MAX_IDLE_MS_CONFIG = CommonClientConfigs.CONNECTIONS_MAX_IDLE_MS_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "CONNECTIONS_MAX_IDLE_MS_CONFIG = CommonClientConfigs.CONNECTIONS_MAX_IDLE_MS_CONFIG", "var_name": "CONNECTIONS_MAX_IDLE_MS_CONFIG"}, {"original_string": "public static final String REQUEST_TIMEOUT_MS_CONFIG = CommonClientConfigs.REQUEST_TIMEOUT_MS_CONFIG;", "modifier": "public static final", "type": "String", "declarator": "REQUEST_TIMEOUT_MS_CONFIG = CommonClientConfigs.REQUEST_TIMEOUT_MS_CONFIG", "var_name": "REQUEST_TIMEOUT_MS_CONFIG"}, {"original_string": "private static final String REQUEST_TIMEOUT_MS_DOC = CommonClientConfigs.REQUEST_TIMEOUT_MS_DOC;", "modifier": "private static final", "type": "String", "declarator": "REQUEST_TIMEOUT_MS_DOC = CommonClientConfigs.REQUEST_TIMEOUT_MS_DOC", "var_name": "REQUEST_TIMEOUT_MS_DOC"}, {"original_string": "public static final String INTERCEPTOR_CLASSES_CONFIG = \"interceptor.classes\";", "modifier": "public static final", "type": "String", "declarator": "INTERCEPTOR_CLASSES_CONFIG = \"interceptor.classes\"", "var_name": "INTERCEPTOR_CLASSES_CONFIG"}, {"original_string": "public static final String INTERCEPTOR_CLASSES_DOC = \"A list of classes to use as interceptors. \"\n                                                        + \"Implementing the <code>ConsumerInterceptor</code> interface allows you to intercept (and possibly mutate) records \"\n                                                        + \"received by the consumer. By default, there are no interceptors.\";", "modifier": "public static final", "type": "String", "declarator": "INTERCEPTOR_CLASSES_DOC = \"A list of classes to use as interceptors. \"\n                                                        + \"Implementing the <code>ConsumerInterceptor</code> interface allows you to intercept (and possibly mutate) records \"\n                                                        + \"received by the consumer. By default, there are no interceptors.\"", "var_name": "INTERCEPTOR_CLASSES_DOC"}, {"original_string": "public static final String EXCLUDE_INTERNAL_TOPICS_CONFIG = \"exclude.internal.topics\";", "modifier": "public static final", "type": "String", "declarator": "EXCLUDE_INTERNAL_TOPICS_CONFIG = \"exclude.internal.topics\"", "var_name": "EXCLUDE_INTERNAL_TOPICS_CONFIG"}, {"original_string": "private static final String EXCLUDE_INTERNAL_TOPICS_DOC = \"Whether records from internal topics (such as offsets) should be exposed to the consumer. \"\n                                                            + \"If set to <code>true</code> the only way to receive records from an internal topic is subscribing to it.\";", "modifier": "private static final", "type": "String", "declarator": "EXCLUDE_INTERNAL_TOPICS_DOC = \"Whether records from internal topics (such as offsets) should be exposed to the consumer. \"\n                                                            + \"If set to <code>true</code> the only way to receive records from an internal topic is subscribing to it.\"", "var_name": "EXCLUDE_INTERNAL_TOPICS_DOC"}, {"original_string": "public static final boolean DEFAULT_EXCLUDE_INTERNAL_TOPICS = true;", "modifier": "public static final", "type": "boolean", "declarator": "DEFAULT_EXCLUDE_INTERNAL_TOPICS = true", "var_name": "DEFAULT_EXCLUDE_INTERNAL_TOPICS"}], "methods": [{"identifier": "addDeserializerToConfig", "parameters": "(Map<String, Object> configs,\n                                                              Deserializer<?> keyDeserializer,\n                                                              Deserializer<?> valueDeserializer)", "modifiers": "public static", "return": "Map<String, Object>", "signature": "Map<String, Object> addDeserializerToConfig(Map<String, Object> configs,\n                                                              Deserializer<?> keyDeserializer,\n                                                              Deserializer<?> valueDeserializer)", "full_signature": "public static Map<String, Object> addDeserializerToConfig(Map<String, Object> configs,\n                                                              Deserializer<?> keyDeserializer,\n                                                              Deserializer<?> valueDeserializer)", "class_method_signature": "ConsumerConfig.addDeserializerToConfig(Map<String, Object> configs,\n                                                              Deserializer<?> keyDeserializer,\n                                                              Deserializer<?> valueDeserializer)", "testcase": false, "constructor": false}, {"identifier": "addDeserializerToConfig", "parameters": "(Properties properties,\n                                                     Deserializer<?> keyDeserializer,\n                                                     Deserializer<?> valueDeserializer)", "modifiers": "public static", "return": "Properties", "signature": "Properties addDeserializerToConfig(Properties properties,\n                                                     Deserializer<?> keyDeserializer,\n                                                     Deserializer<?> valueDeserializer)", "full_signature": "public static Properties addDeserializerToConfig(Properties properties,\n                                                     Deserializer<?> keyDeserializer,\n                                                     Deserializer<?> valueDeserializer)", "class_method_signature": "ConsumerConfig.addDeserializerToConfig(Properties properties,\n                                                     Deserializer<?> keyDeserializer,\n                                                     Deserializer<?> valueDeserializer)", "testcase": false, "constructor": false}, {"identifier": "ConsumerConfig", "parameters": "(Map<?, ?> props)", "modifiers": "", "return": "", "signature": " ConsumerConfig(Map<?, ?> props)", "full_signature": "  ConsumerConfig(Map<?, ?> props)", "class_method_signature": "ConsumerConfig.ConsumerConfig(Map<?, ?> props)", "testcase": false, "constructor": true}, {"identifier": "main", "parameters": "(String[] args)", "modifiers": "public static", "return": "void", "signature": "void main(String[] args)", "full_signature": "public static void main(String[] args)", "class_method_signature": "ConsumerConfig.main(String[] args)", "testcase": false, "constructor": false}], "file": "clients/src/main/java/org/apache/kafka/clients/consumer/ConsumerConfig.java"}, "focal_method": {"identifier": "addDeserializerToConfig", "parameters": "(Map<String, Object> configs,\n                                                              Deserializer<?> keyDeserializer,\n                                                              Deserializer<?> valueDeserializer)", "modifiers": "public static", "return": "Map<String, Object>", "body": "public static Map<String, Object> addDeserializerToConfig(Map<String, Object> configs,\n                                                              Deserializer<?> keyDeserializer,\n                                                              Deserializer<?> valueDeserializer) {\n        Map<String, Object> newConfigs = new HashMap<String, Object>();\n        newConfigs.putAll(configs);\n        if (keyDeserializer != null)\n            newConfigs.put(KEY_DESERIALIZER_CLASS_CONFIG, keyDeserializer.getClass());\n        if (valueDeserializer != null)\n            newConfigs.put(VALUE_DESERIALIZER_CLASS_CONFIG, valueDeserializer.getClass());\n        return newConfigs;\n    }", "signature": "Map<String, Object> addDeserializerToConfig(Map<String, Object> configs,\n                                                              Deserializer<?> keyDeserializer,\n                                                              Deserializer<?> valueDeserializer)", "full_signature": "public static Map<String, Object> addDeserializerToConfig(Map<String, Object> configs,\n                                                              Deserializer<?> keyDeserializer,\n                                                              Deserializer<?> valueDeserializer)", "class_method_signature": "ConsumerConfig.addDeserializerToConfig(Map<String, Object> configs,\n                                                              Deserializer<?> keyDeserializer,\n                                                              Deserializer<?> valueDeserializer)", "testcase": false, "constructor": false, "invocations": ["putAll", "put", "getClass", "put", "getClass"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}