{"test_class": {"identifier": "LinearPredictiveCodingTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int POLES = 20;", "modifier": "private static final", "type": "int", "declarator": "POLES = 20", "var_name": "POLES"}, {"original_string": "private LinearPredictiveCoding lpc;", "modifier": "private", "type": "LinearPredictiveCoding", "declarator": "lpc", "var_name": "lpc"}, {"original_string": "private double[] sinusoid;", "modifier": "private", "type": "double[]", "declarator": "sinusoid", "var_name": "sinusoid"}, {"original_string": "private static final double[][] reference = new double[][] {\n        // lpc calculated on generateSinusoidalTone(100, 100.0d, 10000.0d);\n        {   // lpc coeffs\n            0.0, 1.995953447541858, -0.9998996454107755, -2.1583232709400016E-7, 1.9714270658712986E-8,\n            1.205619961543056E-7, -1.1008889658279106E-7, 3.669432608963836E-8, 4.71030304145731E-9, -9.758082872345994E-8,\n            3.3253885211279753E-7, -5.856799825816946E-7, 6.603176160971334E-7, -4.932573369012327E-7, 1.8485161014316237E-7,\n            6.323128527687099E-8, -1.4506174842230357E-7, 1.3992475254079849E-7, -4.278511815380666E-5, 4.832034963185139E-5\n        },\n        {   // lpc errors\n            4999.9999999999945, 19.71324671394157, 0.007884510823393446, 0.007884510744981957, 0.007884510667244039,\n            0.007884510591121436, 0.007884510517160574, 0.007884510445723848, 0.007884510377482199, 0.007884510312835566,\n            0.007884510252175807, 0.007884510195968798, 0.00788451014404609, 0.007884510097344307, 0.007884510055177086,\n            0.007884510018162975, 0.007884509986052864, 0.0078845099586744, 0.007884509935971734, 0.007884509917562538\n        }\n    };", "modifier": "private static final", "type": "double[][]", "declarator": "reference = new double[][] {\n        // lpc calculated on generateSinusoidalTone(100, 100.0d, 10000.0d);\n        {   // lpc coeffs\n            0.0, 1.995953447541858, -0.9998996454107755, -2.1583232709400016E-7, 1.9714270658712986E-8,\n            1.205619961543056E-7, -1.1008889658279106E-7, 3.669432608963836E-8, 4.71030304145731E-9, -9.758082872345994E-8,\n            3.3253885211279753E-7, -5.856799825816946E-7, 6.603176160971334E-7, -4.932573369012327E-7, 1.8485161014316237E-7,\n            6.323128527687099E-8, -1.4506174842230357E-7, 1.3992475254079849E-7, -4.278511815380666E-5, 4.832034963185139E-5\n        },\n        {   // lpc errors\n            4999.9999999999945, 19.71324671394157, 0.007884510823393446, 0.007884510744981957, 0.007884510667244039,\n            0.007884510591121436, 0.007884510517160574, 0.007884510445723848, 0.007884510377482199, 0.007884510312835566,\n            0.007884510252175807, 0.007884510195968798, 0.00788451014404609, 0.007884510097344307, 0.007884510055177086,\n            0.007884510018162975, 0.007884509986052864, 0.0078845099586744, 0.007884509935971734, 0.007884509917562538\n        }\n    }", "var_name": "reference"}], "file": "recognito/src/test/java/com/bitsinharmony/recognito/algorithms/LinearPredictiveCodingTest.java"}, "test_case": {"identifier": "preventUnwantedAlgorithmRegressionDueToRefactoring", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void preventUnwantedAlgorithmRegressionDueToRefactoring() {\n        double[][] lpcCoding = lpc.applyLinearPredictiveCoding(sinusoid);\n        \n        assertThat(lpcCoding[0], is(equalTo(reference[0])));\n        assertThat(lpcCoding[1], is(equalTo(reference[1])));\n        \n        // In case you need to regenerate the reference\n//        StringBuilder coeffs = new StringBuilder();\n//        StringBuilder errors = new StringBuilder();\n//        for(int i = 0; i < POLES; i++) {\n//            coeffs.append(lpcCoding[0][i]);\n//            errors.append(lpcCoding[1][i]);\n//            if((i + 1) % 5 == 0) {\n//                coeffs.append(\",\\n\");\n//                errors.append(\",\\n\");\n//            } else {\n//                coeffs.append(\", \");\n//                errors.append(\", \");\n//            }\n//        }\n//        System.out.println(coeffs.toString());\n//        System.out.println(errors.toString());\n    }", "signature": "void preventUnwantedAlgorithmRegressionDueToRefactoring()", "full_signature": "@Test public void preventUnwantedAlgorithmRegressionDueToRefactoring()", "class_method_signature": "LinearPredictiveCodingTest.preventUnwantedAlgorithmRegressionDueToRefactoring()", "testcase": true, "constructor": false, "invocations": ["applyLinearPredictiveCoding", "assertThat", "is", "equalTo", "assertThat", "is", "equalTo"]}, "focal_class": {"identifier": "LinearPredictiveCoding", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final int windowSize;", "modifier": "private final", "type": "int", "declarator": "windowSize", "var_name": "windowSize"}, {"original_string": "private final int poles;", "modifier": "private final", "type": "int", "declarator": "poles", "var_name": "poles"}, {"original_string": "private final double[] output;", "modifier": "private final", "type": "double[]", "declarator": "output", "var_name": "output"}, {"original_string": "private final double[] error;", "modifier": "private final", "type": "double[]", "declarator": "error", "var_name": "error"}, {"original_string": "private final double[] k;", "modifier": "private final", "type": "double[]", "declarator": "k", "var_name": "k"}, {"original_string": "private final double[][] matrix;", "modifier": "private final", "type": "double[][]", "declarator": "matrix", "var_name": "matrix"}], "methods": [{"identifier": "LinearPredictiveCoding", "parameters": "(int windowSize, int poles)", "modifiers": "public", "return": "", "signature": " LinearPredictiveCoding(int windowSize, int poles)", "full_signature": "public  LinearPredictiveCoding(int windowSize, int poles)", "class_method_signature": "LinearPredictiveCoding.LinearPredictiveCoding(int windowSize, int poles)", "testcase": false, "constructor": true}, {"identifier": "applyLinearPredictiveCoding", "parameters": "(double[] window)", "modifiers": "public", "return": "double[][]", "signature": "double[][] applyLinearPredictiveCoding(double[] window)", "full_signature": "public double[][] applyLinearPredictiveCoding(double[] window)", "class_method_signature": "LinearPredictiveCoding.applyLinearPredictiveCoding(double[] window)", "testcase": false, "constructor": false}], "file": "recognito/src/main/java/com/bitsinharmony/recognito/algorithms/LinearPredictiveCoding.java"}, "focal_method": {"identifier": "applyLinearPredictiveCoding", "parameters": "(double[] window)", "modifiers": "public", "return": "double[][]", "body": "public double[][] applyLinearPredictiveCoding(double[] window) {\n        \n        if(windowSize != window.length) {\n            throw new IllegalArgumentException(\"Given window length was not equal to the one provided in constructor : [\" \n                    + window.length +\"] != [\" + windowSize + \"]\");\n        }\n        \n        Arrays.fill(k,  0.0d);\n        Arrays.fill(output, 0.0d);\n        Arrays.fill(error, 0.0d);\n        for(double[] d : matrix) {\n            Arrays.fill(d, 0.0d);\n        }\n\n        DiscreteAutocorrelationAtLagJ dalj = new DiscreteAutocorrelationAtLagJ();\n        double[] autocorrelations = new double[poles];\n        for(int i = 0; i < poles; i++) {\n            autocorrelations[i] = dalj.autocorrelate(window, i);\n        }\n\n        error[0] = autocorrelations[0];\n\n        for (int m = 1; m < poles; m++) {\n            double tmp = autocorrelations[m];\n            for (int i = 1; i < m; i++) {\n                tmp -= matrix[m - 1][i] * autocorrelations[m - i];\n            }\n            k[m] = tmp / error[m - 1];\n\n            for (int i = 0; i < m; i++) {\n                matrix[m][i] = matrix[m - 1][i] - k[m] * matrix[m - 1][m - i];\n            }\n            matrix[m][m] = k[m];\n            error[m] = (1 - (k[m] * k[m])) * error[m - 1];\n        }\n\n        for (int i = 0; i < poles; i++) {\n            if (Double.isNaN(matrix[poles - 1][i])) {\n                output[i] = 0.0;\n            } else {\n                output[i] = matrix[poles - 1][i];\n            }\n        }\n        \n        return new double[][] { output, error };\n    }", "signature": "double[][] applyLinearPredictiveCoding(double[] window)", "full_signature": "public double[][] applyLinearPredictiveCoding(double[] window)", "class_method_signature": "LinearPredictiveCoding.applyLinearPredictiveCoding(double[] window)", "testcase": false, "constructor": false, "invocations": ["fill", "fill", "fill", "fill", "autocorrelate", "isNaN"]}, "repository": {"repo_id": 16597144, "url": "https://github.com/amaurycrickx/recognito", "language": "Java", "is_fork": false, "fork_count": 100, "stargazer_count": 173, "size": 76, "license": "licensed"}}