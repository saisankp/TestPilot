{"test_class": {"identifier": "MSEImpurityMeasureCalculatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Parameterized.Parameter\n    public boolean useIdx;", "modifier": "@Parameterized.Parameter\n    public", "type": "boolean", "declarator": "useIdx", "var_name": "useIdx"}], "file": "modules/ml/src/test/java/org/apache/ignite/ml/tree/impurity/mse/MSEImpurityMeasureCalculatorTest.java"}, "test_case": {"identifier": "testCalculate", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testCalculate() {\n        double[][] data = new double[][]{{0, 2}, {1, 1}, {2, 0}, {3, 3}};\n        double[] labels = new double[]{1, 2, 2, 1};\n\n        MSEImpurityMeasureCalculator calculator = new MSEImpurityMeasureCalculator(useIdx);\n\n        StepFunction<MSEImpurityMeasure>[] impurity = calculator.calculate(new DecisionTreeData(data, labels, useIdx), fs -> true, 0);\n\n        assertEquals(2, impurity.length);\n\n        // Test MSE calculated for the first column.\n        assertArrayEquals(new double[]{Double.NEGATIVE_INFINITY, 0, 1, 2, 3}, impurity[0].getX(), 1e-10);\n        assertEquals(1.000, impurity[0].getY()[0].impurity(), 1e-3);\n        assertEquals(0.666, impurity[0].getY()[1].impurity(),1e-3);\n        assertEquals(1.000, impurity[0].getY()[2].impurity(),1e-3);\n        assertEquals(0.666, impurity[0].getY()[3].impurity(),1e-3);\n        assertEquals(1.000, impurity[0].getY()[4].impurity(),1e-3);\n\n        // Test MSE calculated for the second column.\n        assertArrayEquals(new double[]{Double.NEGATIVE_INFINITY, 0, 1, 2, 3}, impurity[1].getX(), 1e-10);\n        assertEquals(1.000, impurity[1].getY()[0].impurity(),1e-3);\n        assertEquals(0.666, impurity[1].getY()[1].impurity(),1e-3);\n        assertEquals(0.000, impurity[1].getY()[2].impurity(),1e-3);\n        assertEquals(0.666, impurity[1].getY()[3].impurity(),1e-3);\n        assertEquals(1.000, impurity[1].getY()[4].impurity(),1e-3);\n    }", "signature": "void testCalculate()", "full_signature": "@Test public void testCalculate()", "class_method_signature": "MSEImpurityMeasureCalculatorTest.testCalculate()", "testcase": true, "constructor": false, "invocations": ["calculate", "assertEquals", "assertArrayEquals", "getX", "assertEquals", "impurity", "getY", "assertEquals", "impurity", "getY", "assertEquals", "impurity", "getY", "assertEquals", "impurity", "getY", "assertEquals", "impurity", "getY", "assertArrayEquals", "getX", "assertEquals", "impurity", "getY", "assertEquals", "impurity", "getY", "assertEquals", "impurity", "getY", "assertEquals", "impurity", "getY", "assertEquals", "impurity", "getY"]}, "focal_class": {"identifier": "MSEImpurityMeasureCalculator", "superclass": "extends ImpurityMeasureCalculator<MSEImpurityMeasure>", "interfaces": "", "fields": [{"original_string": "private static final long serialVersionUID = 288747414953756824L;", "modifier": "private static final", "type": "long", "declarator": "serialVersionUID = 288747414953756824L", "var_name": "serialVersionUID"}], "methods": [{"identifier": "MSEImpurityMeasureCalculator", "parameters": "(boolean useIdx)", "modifiers": "public", "return": "", "signature": " MSEImpurityMeasureCalculator(boolean useIdx)", "full_signature": "public  MSEImpurityMeasureCalculator(boolean useIdx)", "class_method_signature": "MSEImpurityMeasureCalculator.MSEImpurityMeasureCalculator(boolean useIdx)", "testcase": false, "constructor": true}, {"identifier": "calculate", "parameters": "(DecisionTreeData data, TreeFilter filter, int depth)", "modifiers": "@Override public", "return": "StepFunction<MSEImpurityMeasure>[]", "signature": "StepFunction<MSEImpurityMeasure>[] calculate(DecisionTreeData data, TreeFilter filter, int depth)", "full_signature": "@Override public StepFunction<MSEImpurityMeasure>[] calculate(DecisionTreeData data, TreeFilter filter, int depth)", "class_method_signature": "MSEImpurityMeasureCalculator.calculate(DecisionTreeData data, TreeFilter filter, int depth)", "testcase": false, "constructor": false}], "file": "modules/ml/src/main/java/org/apache/ignite/ml/tree/impurity/mse/MSEImpurityMeasureCalculator.java"}, "focal_method": {"identifier": "calculate", "parameters": "(DecisionTreeData data, TreeFilter filter, int depth)", "modifiers": "@Override public", "return": "StepFunction<MSEImpurityMeasure>[]", "body": "@Override public StepFunction<MSEImpurityMeasure>[] calculate(DecisionTreeData data, TreeFilter filter, int depth) {\n        TreeDataIndex idx = null;\n        boolean canCalculate;\n\n        if (useIdx) {\n            idx = data.createIndexByFilter(depth, filter);\n            canCalculate = idx.rowsCount() > 0;\n        }\n        else {\n            data = data.filter(filter);\n            canCalculate = data.getFeatures().length > 0;\n        }\n\n        if (canCalculate) {\n            int rowsCnt = rowsCount(data, idx);\n            int colsCnt = columnsCount(data, idx);\n\n            @SuppressWarnings(\"unchecked\")\n            StepFunction<MSEImpurityMeasure>[] res = new StepFunction[colsCnt];\n\n            double rightYOriginal = 0;\n            double rightY2Original = 0;\n            for (int i = 0; i < rowsCnt; i++) {\n                double lbVal = getLabelValue(data, idx, 0, i);\n\n                rightYOriginal += lbVal;\n                rightY2Original += Math.pow(lbVal, 2);\n            }\n\n            for (int col = 0; col < res.length; col++) {\n                if (!useIdx)\n                    data.sort(col);\n\n                double[] x = new double[rowsCnt + 1];\n                MSEImpurityMeasure[] y = new MSEImpurityMeasure[rowsCnt + 1];\n\n                x[0] = Double.NEGATIVE_INFINITY;\n\n                double leftY = 0;\n                double leftY2 = 0;\n                double rightY = rightYOriginal;\n                double rightY2 = rightY2Original;\n\n                int leftSize = 0;\n                for (int i = 0; i <= rowsCnt; i++) {\n                    if (leftSize > 0) {\n                        double lblVal = getLabelValue(data, idx, col, i - 1);\n\n                        leftY += lblVal;\n                        leftY2 += Math.pow(lblVal, 2);\n\n                        rightY -= lblVal;\n                        rightY2 -= Math.pow(lblVal, 2);\n                    }\n\n                    if (leftSize < rowsCnt)\n                        x[leftSize + 1] = getFeatureValue(data, idx, col, i);\n\n                    y[leftSize] = new MSEImpurityMeasure(\n                        leftY, leftY2, leftSize, rightY, rightY2, rowsCnt - leftSize\n                    );\n\n                    leftSize++;\n                }\n\n                res[col] = new StepFunction<>(x, y);\n            }\n\n            return res;\n        }\n\n        return null;\n    }", "signature": "StepFunction<MSEImpurityMeasure>[] calculate(DecisionTreeData data, TreeFilter filter, int depth)", "full_signature": "@Override public StepFunction<MSEImpurityMeasure>[] calculate(DecisionTreeData data, TreeFilter filter, int depth)", "class_method_signature": "MSEImpurityMeasureCalculator.calculate(DecisionTreeData data, TreeFilter filter, int depth)", "testcase": false, "constructor": false, "invocations": ["createIndexByFilter", "rowsCount", "filter", "getFeatures", "rowsCount", "columnsCount", "getLabelValue", "pow", "sort", "getLabelValue", "pow", "pow", "getFeatureValue"]}, "repository": {"repo_id": 170496871, "url": "https://github.com/gridgain/gridgain", "stars": 46, "created": "2/13/2019 11:31:35 AM +00:00", "updates": "2020-01-27T16:02:24+00:00", "fork": "False", "license": "licensed"}}