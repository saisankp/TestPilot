{"test_class": {"identifier": "ProjectionHandlerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final double EPS = 1e-5;", "modifier": "static final", "type": "double", "declarator": "EPS = 1e-5", "var_name": "EPS"}, {"original_string": "static CoordinateReferenceSystem WGS84;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "WGS84", "var_name": "WGS84"}, {"original_string": "static CoordinateReferenceSystem ED50_LATLON;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "ED50_LATLON", "var_name": "ED50_LATLON"}, {"original_string": "static CoordinateReferenceSystem UTM32N;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "UTM32N", "var_name": "UTM32N"}, {"original_string": "static CoordinateReferenceSystem MERCATOR;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "MERCATOR", "var_name": "MERCATOR"}, {"original_string": "static CoordinateReferenceSystem MERCATOR_SHIFTED;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "MERCATOR_SHIFTED", "var_name": "MERCATOR_SHIFTED"}, {"original_string": "static CoordinateReferenceSystem ED50;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "ED50", "var_name": "ED50"}], "file": "modules/library/render/src/test/java/org/geotools/renderer/crs/ProjectionHandlerTest.java"}, "test_case": {"identifier": "testRobustCutting", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRobustCutting() throws Exception {\n        String wkt = \"PROJCS[\\\"Asia_South_Lambert_Conformal_Conic\\\", \\n\"\n                + \"  GEOGCS[\\\"GCS_WGS_1984\\\", \\n\" + \"    DATUM[\\\"WGS_1984\\\", \\n\"\n                + \"      SPHEROID[\\\"WGS_1984\\\", 6378137.0, 298.257223563]], \\n\"\n                + \"    PRIMEM[\\\"Greenwich\\\", 0.0], \\n\"\n                + \"    UNIT[\\\"degree\\\", 0.017453292519943295], \\n\"\n                + \"    AXIS[\\\"Longitude\\\", EAST], \\n\" + \"    AXIS[\\\"Latitude\\\", NORTH]], \\n\"\n                + \"  PROJECTION[\\\"Lambert_Conformal_Conic_2SP\\\"], \\n\"\n                + \"  PARAMETER[\\\"central_meridian\\\", 125.0], \\n\"\n                + \"  PARAMETER[\\\"latitude_of_origin\\\", -15.0], \\n\"\n                + \"  PARAMETER[\\\"standard_parallel_1\\\", 7.0], \\n\"\n                + \"  PARAMETER[\\\"false_easting\\\", 0.0], \\n\"\n                + \"  PARAMETER[\\\"false_northing\\\", 0.0], \\n\"\n                + \"  PARAMETER[\\\"scale_factor\\\", 1.0], \\n\"\n                + \"  PARAMETER[\\\"standard_parallel_2\\\", -32.0], \\n\" + \"  UNIT[\\\"m\\\", 1.0], \\n\"\n                + \"  AXIS[\\\"x\\\", EAST], \\n\" + \"  AXIS[\\\"y\\\", NORTH], \\n\"\n                + \"  AUTHORITY[\\\"EPSG\\\",\\\"102030\\\"]]\";\n        CoordinateReferenceSystem crs = CRS.parseWKT(wkt);\n        Geometry geom;\n        try (Reader reader = new InputStreamReader(new GZIPInputStream(\n                ProjectionHandlerTest.class.getResourceAsStream(\"para.wkt.gz\")))) {\n            geom = new WKTReader().read(reader);\n        }\n\n        ReferencedEnvelope re = new ReferencedEnvelope(1.2248782489837505E7, 2.0320948299686E7,\n                -4848266.752703998, 3223899.0571445003, crs);\n        ProjectionHandler handler = ProjectionHandlerFinder.getHandler(re, WGS84, true);\n        // hard intersection, not even enhanced precision ops was able to make it\n        Geometry preprocessed = handler.preProcess(geom);\n        assertNotEquals(preprocessed, geom);\n    }", "signature": "void testRobustCutting()", "full_signature": "@Test public void testRobustCutting()", "class_method_signature": "ProjectionHandlerTest.testRobustCutting()", "testcase": true, "constructor": false, "invocations": ["parseWKT", "getResourceAsStream", "read", "getHandler", "preProcess", "assertNotEquals"]}, "focal_class": {"identifier": "ProjectionHandler", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final double EPS = 1e-6;", "modifier": "static final", "type": "double", "declarator": "EPS = 1e-6", "var_name": "EPS"}, {"original_string": "protected static final Logger LOGGER = org.geotools.util.logging.Logging.getLogger(ProjectionHandler.class);", "modifier": "protected static final", "type": "Logger", "declarator": "LOGGER = org.geotools.util.logging.Logging.getLogger(ProjectionHandler.class)", "var_name": "LOGGER"}, {"original_string": "ReferencedEnvelope renderingEnvelope;", "modifier": "", "type": "ReferencedEnvelope", "declarator": "renderingEnvelope", "var_name": "renderingEnvelope"}, {"original_string": "final ReferencedEnvelope validAreaBounds;", "modifier": "final", "type": "ReferencedEnvelope", "declarator": "validAreaBounds", "var_name": "validAreaBounds"}, {"original_string": "final Geometry validArea;", "modifier": "final", "type": "Geometry", "declarator": "validArea", "var_name": "validArea"}, {"original_string": "final PreparedGeometry validaAreaTester;", "modifier": "final", "type": "PreparedGeometry", "declarator": "validaAreaTester", "var_name": "validaAreaTester"}, {"original_string": "final CoordinateReferenceSystem sourceCRS;", "modifier": "final", "type": "CoordinateReferenceSystem", "declarator": "sourceCRS", "var_name": "sourceCRS"}, {"original_string": "final CoordinateReferenceSystem targetCRS;", "modifier": "final", "type": "CoordinateReferenceSystem", "declarator": "targetCRS", "var_name": "targetCRS"}, {"original_string": "double datelineX = Double.NaN;", "modifier": "", "type": "double", "declarator": "datelineX = Double.NaN", "var_name": "datelineX"}, {"original_string": "double radius = Double.NaN;", "modifier": "", "type": "double", "declarator": "radius = Double.NaN", "var_name": "radius"}], "methods": [{"identifier": "ProjectionHandler", "parameters": "(CoordinateReferenceSystem sourceCRS, Envelope validAreaBounds, ReferencedEnvelope renderingEnvelope)", "modifiers": "public", "return": "", "signature": " ProjectionHandler(CoordinateReferenceSystem sourceCRS, Envelope validAreaBounds, ReferencedEnvelope renderingEnvelope)", "full_signature": "public  ProjectionHandler(CoordinateReferenceSystem sourceCRS, Envelope validAreaBounds, ReferencedEnvelope renderingEnvelope)", "class_method_signature": "ProjectionHandler.ProjectionHandler(CoordinateReferenceSystem sourceCRS, Envelope validAreaBounds, ReferencedEnvelope renderingEnvelope)", "testcase": false, "constructor": true}, {"identifier": "ProjectionHandler", "parameters": "(CoordinateReferenceSystem sourceCRS, Geometry validArea, ReferencedEnvelope renderingEnvelope)", "modifiers": "public", "return": "", "signature": " ProjectionHandler(CoordinateReferenceSystem sourceCRS, Geometry validArea, ReferencedEnvelope renderingEnvelope)", "full_signature": "public  ProjectionHandler(CoordinateReferenceSystem sourceCRS, Geometry validArea, ReferencedEnvelope renderingEnvelope)", "class_method_signature": "ProjectionHandler.ProjectionHandler(CoordinateReferenceSystem sourceCRS, Geometry validArea, ReferencedEnvelope renderingEnvelope)", "testcase": false, "constructor": true}, {"identifier": "getRenderingEnvelope", "parameters": "()", "modifiers": "public", "return": "ReferencedEnvelope", "signature": "ReferencedEnvelope getRenderingEnvelope()", "full_signature": "public ReferencedEnvelope getRenderingEnvelope()", "class_method_signature": "ProjectionHandler.getRenderingEnvelope()", "testcase": false, "constructor": false}, {"identifier": "getSourceCRS", "parameters": "()", "modifiers": "public", "return": "CoordinateReferenceSystem", "signature": "CoordinateReferenceSystem getSourceCRS()", "full_signature": "public CoordinateReferenceSystem getSourceCRS()", "class_method_signature": "ProjectionHandler.getSourceCRS()", "testcase": false, "constructor": false}, {"identifier": "getQueryEnvelopes", "parameters": "()", "modifiers": "public", "return": "List<ReferencedEnvelope>", "signature": "List<ReferencedEnvelope> getQueryEnvelopes()", "full_signature": "public List<ReferencedEnvelope> getQueryEnvelopes()", "class_method_signature": "ProjectionHandler.getQueryEnvelopes()", "testcase": false, "constructor": false}, {"identifier": "getSourceEnvelopes", "parameters": "(ReferencedEnvelope renderingEnvelope)", "modifiers": "private", "return": "List<ReferencedEnvelope>", "signature": "List<ReferencedEnvelope> getSourceEnvelopes(ReferencedEnvelope renderingEnvelope)", "full_signature": "private List<ReferencedEnvelope> getSourceEnvelopes(ReferencedEnvelope renderingEnvelope)", "class_method_signature": "ProjectionHandler.getSourceEnvelopes(ReferencedEnvelope renderingEnvelope)", "testcase": false, "constructor": false}, {"identifier": "transformEnvelope", "parameters": "(ReferencedEnvelope envelope,\n            CoordinateReferenceSystem targetCRS)", "modifiers": "private", "return": "ReferencedEnvelope", "signature": "ReferencedEnvelope transformEnvelope(ReferencedEnvelope envelope,\n            CoordinateReferenceSystem targetCRS)", "full_signature": "private ReferencedEnvelope transformEnvelope(ReferencedEnvelope envelope,\n            CoordinateReferenceSystem targetCRS)", "class_method_signature": "ProjectionHandler.transformEnvelope(ReferencedEnvelope envelope,\n            CoordinateReferenceSystem targetCRS)", "testcase": false, "constructor": false}, {"identifier": "reprojectEnvelopes", "parameters": "(CoordinateReferenceSystem queryCRS,\n            List<ReferencedEnvelope> envelopes)", "modifiers": "protected", "return": "void", "signature": "void reprojectEnvelopes(CoordinateReferenceSystem queryCRS,\n            List<ReferencedEnvelope> envelopes)", "full_signature": "protected void reprojectEnvelopes(CoordinateReferenceSystem queryCRS,\n            List<ReferencedEnvelope> envelopes)", "class_method_signature": "ProjectionHandler.reprojectEnvelopes(CoordinateReferenceSystem queryCRS,\n            List<ReferencedEnvelope> envelopes)", "testcase": false, "constructor": false}, {"identifier": "mergeEnvelopes", "parameters": "(List<ReferencedEnvelope> envelopes)", "modifiers": "private", "return": "void", "signature": "void mergeEnvelopes(List<ReferencedEnvelope> envelopes)", "full_signature": "private void mergeEnvelopes(List<ReferencedEnvelope> envelopes)", "class_method_signature": "ProjectionHandler.mergeEnvelopes(List<ReferencedEnvelope> envelopes)", "testcase": false, "constructor": false}, {"identifier": "requiresProcessing", "parameters": "(Geometry geometry)", "modifiers": "public", "return": "boolean", "signature": "boolean requiresProcessing(Geometry geometry)", "full_signature": "public boolean requiresProcessing(Geometry geometry)", "class_method_signature": "ProjectionHandler.requiresProcessing(Geometry geometry)", "testcase": false, "constructor": false}, {"identifier": "preProcess", "parameters": "(Geometry geometry)", "modifiers": "public", "return": "Geometry", "signature": "Geometry preProcess(Geometry geometry)", "full_signature": "public Geometry preProcess(Geometry geometry)", "class_method_signature": "ProjectionHandler.preProcess(Geometry geometry)", "testcase": false, "constructor": false}, {"identifier": "intersect", "parameters": "(Geometry geometry, Geometry mask,\n            CoordinateReferenceSystem geometryCRS)", "modifiers": "private", "return": "Geometry", "signature": "Geometry intersect(Geometry geometry, Geometry mask,\n            CoordinateReferenceSystem geometryCRS)", "full_signature": "private Geometry intersect(Geometry geometry, Geometry mask,\n            CoordinateReferenceSystem geometryCRS)", "class_method_signature": "ProjectionHandler.intersect(Geometry geometry, Geometry mask,\n            CoordinateReferenceSystem geometryCRS)", "testcase": false, "constructor": false}, {"identifier": "getRenderingTransform", "parameters": "(MathTransform mt)", "modifiers": "public", "return": "MathTransform", "signature": "MathTransform getRenderingTransform(MathTransform mt)", "full_signature": "public MathTransform getRenderingTransform(MathTransform mt)", "class_method_signature": "ProjectionHandler.getRenderingTransform(MathTransform mt)", "testcase": false, "constructor": false}, {"identifier": "concatenateTransforms", "parameters": "(List<MathTransform> datumShiftChain)", "modifiers": "private", "return": "MathTransform", "signature": "MathTransform concatenateTransforms(List<MathTransform> datumShiftChain)", "full_signature": "private MathTransform concatenateTransforms(List<MathTransform> datumShiftChain)", "class_method_signature": "ProjectionHandler.concatenateTransforms(List<MathTransform> datumShiftChain)", "testcase": false, "constructor": false}, {"identifier": "accumulateTransforms", "parameters": "(MathTransform mt, List<MathTransform> elements)", "modifiers": "private", "return": "void", "signature": "void accumulateTransforms(MathTransform mt, List<MathTransform> elements)", "full_signature": "private void accumulateTransforms(MathTransform mt, List<MathTransform> elements)", "class_method_signature": "ProjectionHandler.accumulateTransforms(MathTransform mt, List<MathTransform> elements)", "testcase": false, "constructor": false}, {"identifier": "postProcess", "parameters": "(MathTransform mt, Geometry geometry)", "modifiers": "public", "return": "Geometry", "signature": "Geometry postProcess(MathTransform mt, Geometry geometry)", "full_signature": "public Geometry postProcess(MathTransform mt, Geometry geometry)", "class_method_signature": "ProjectionHandler.postProcess(MathTransform mt, Geometry geometry)", "testcase": false, "constructor": false}, {"identifier": "getValidAreaBounds", "parameters": "()", "modifiers": "public", "return": "ReferencedEnvelope", "signature": "ReferencedEnvelope getValidAreaBounds()", "full_signature": "public ReferencedEnvelope getValidAreaBounds()", "class_method_signature": "ProjectionHandler.getValidAreaBounds()", "testcase": false, "constructor": false}, {"identifier": "setCentralMeridian", "parameters": "(double centralMeridian)", "modifiers": "", "return": "void", "signature": "void setCentralMeridian(double centralMeridian)", "full_signature": " void setCentralMeridian(double centralMeridian)", "class_method_signature": "ProjectionHandler.setCentralMeridian(double centralMeridian)", "testcase": false, "constructor": false}, {"identifier": "addGeometries", "parameters": "(List<Geometry> geoms, GeometryCollection collection,\n            String geometryType)", "modifiers": "private", "return": "void", "signature": "void addGeometries(List<Geometry> geoms, GeometryCollection collection,\n            String geometryType)", "full_signature": "private void addGeometries(List<Geometry> geoms, GeometryCollection collection,\n            String geometryType)", "class_method_signature": "ProjectionHandler.addGeometries(List<Geometry> geoms, GeometryCollection collection,\n            String geometryType)", "testcase": false, "constructor": false}], "file": "modules/library/render/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java"}, "focal_method": {"identifier": "preProcess", "parameters": "(Geometry geometry)", "modifiers": "public", "return": "Geometry", "body": "public Geometry preProcess(Geometry geometry) throws TransformException, FactoryException {\n        // if there is no valid area, no cutting is required either\n        if(validAreaBounds == null)\n            return geometry;\n        \n        // if not reprojection is going on, we don't need to cut\n        CoordinateReferenceSystem geometryCRS = CRS.getHorizontalCRS(sourceCRS);\n        if (geometryCRS == null\n                || CRS.findMathTransform(geometryCRS,\n                        renderingEnvelope.getCoordinateReferenceSystem()).isIdentity()) {\n            return geometry;\n        }\n        \n        Geometry mask;\n        // fast path for the rectangular case, more complex one for the\n        // non rectangular one\n        if(validArea == null) {\n            // if the geometry is within the valid area for this projection\n            // just skip expensive cutting\n            ReferencedEnvelope ge = new ReferencedEnvelope(geometry.getEnvelopeInternal(), geometryCRS);\n            ReferencedEnvelope geWGS84 = ge.transform(WGS84, true);\n            if (validAreaBounds.contains((Envelope) geWGS84)) {\n                return geometry;\n            }\n\n            // we need to cut, first thing, we intersect the geometry envelope\n            // and the valid area in WGS84, which is a neutral, everything can\n            // be turned into it, and then turn back the intersection into\n            // the origin SRS\n            ReferencedEnvelope envIntWgs84 = new ReferencedEnvelope(validAreaBounds.intersection(geWGS84), WGS84);\n            \n            // if the intersection is empty the geometry is completely outside of the valid area, skip it\n            if(envIntWgs84.isEmpty()) {\n                return null;\n            }\n                \n            ReferencedEnvelope envInt = envIntWgs84.transform(geometryCRS, true);\n            mask = JTS.toGeometry((Envelope) envInt);\n        } else {\n            // if the geometry is within the valid area for this projection\n            // just skip expensive cutting\n            ReferencedEnvelope ge = new ReferencedEnvelope(geometry.getEnvelopeInternal(), geometryCRS);\n            ReferencedEnvelope geWGS84 = ge.transform(WGS84, true);\n            if (validaAreaTester.contains(JTS.toGeometry(geWGS84))) {\n                return geometry;\n            }\n\n            // we need to cut, first thing, we intersect the geometry envelope\n            // and the valid area in WGS84, which is a neutral, everything can\n            // be turned into it, and then turn back the intersection into\n            // the origin SRS\n            ReferencedEnvelope envIntWgs84 = new ReferencedEnvelope(validAreaBounds.intersection(geWGS84), WGS84);\n            \n            // if the intersection is empty the geometry is completely outside of the valid area, skip it\n            if(envIntWgs84.isEmpty()) {\n                return null;\n            } \n            \n            Polygon polyIntWgs84 = JTS.toGeometry(envIntWgs84);\n            Geometry maskWgs84 = intersect(validArea, polyIntWgs84, geometryCRS);\n            if(maskWgs84 == null || maskWgs84.isEmpty()) {\n                return null;\n            }\n            mask = JTS.transform(maskWgs84, CRS.findMathTransform(WGS84, geometryCRS));\n        }\n        \n        return intersect(geometry, mask, geometryCRS);\n    }", "signature": "Geometry preProcess(Geometry geometry)", "full_signature": "public Geometry preProcess(Geometry geometry)", "class_method_signature": "ProjectionHandler.preProcess(Geometry geometry)", "testcase": false, "constructor": false, "invocations": ["getHorizontalCRS", "isIdentity", "findMathTransform", "getCoordinateReferenceSystem", "getEnvelopeInternal", "transform", "contains", "intersection", "isEmpty", "transform", "toGeometry", "getEnvelopeInternal", "transform", "contains", "toGeometry", "intersection", "isEmpty", "toGeometry", "intersect", "isEmpty", "transform", "findMathTransform", "intersect"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}