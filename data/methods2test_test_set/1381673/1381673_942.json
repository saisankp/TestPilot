{"test_class": {"identifier": "StringUtilsTest", "superclass": "", "interfaces": "", "fields": [], "file": "drools-core/src/test/java/org/drools/core/util/StringUtilsTest.java"}, "test_case": {"identifier": "test_codeAwareEqualsIgnoreSpaces", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void test_codeAwareEqualsIgnoreSpaces() {\n        Assert.assertTrue( StringUtils.codeAwareEqualsIgnoreSpaces( null, null ) );\n        Assert.assertTrue( StringUtils.codeAwareEqualsIgnoreSpaces( \"\", \"\") );\n        Assert.assertFalse( StringUtils.codeAwareEqualsIgnoreSpaces( \"\", null ) );\n        Assert.assertFalse( StringUtils.codeAwareEqualsIgnoreSpaces( null, \"\" ) );\n        \n        Assert.assertTrue( StringUtils.codeAwareEqualsIgnoreSpaces( \" \", \"\" ) );\n        Assert.assertTrue( StringUtils.codeAwareEqualsIgnoreSpaces( \"\", \" \" ) );\n        \n        Assert.assertTrue( StringUtils.codeAwareEqualsIgnoreSpaces( \" \", \"  \" ) );\n        \n        Assert.assertTrue(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"rule Rx when then end\",\n                        \" rule Rx  when then end \" // <<- DIFF 3x \n                )\n            );\n        Assert.assertTrue(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"rule Rx when then end\\n\",\n                        \" rule Rx  when then end\\n \" // <<- DIFF, both terminate with whitespace but different types\n                )\n            );\n        \n        Assert.assertFalse(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"package org.drools.compiler\\n\",\n                        \n                        \"package org.drools.compiler\\n \" +\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello World\\\" )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\"\n                )\n            );\n        \n        Assert.assertTrue(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"package org.drools.compiler\\n\" +\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello World\\\" )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\",\n                        \n                        \"package org.drools.compiler\\n \" +  // <<- DIFF\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello World\\\" )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\"\n                )\n            );\n        Assert.assertTrue(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"package org.drools.compiler\\n\" +\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello World\\\" )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\",\n                        \n                        \" package org.drools.compiler\\n\" +  // <<- DIFF (at beginning of this line)\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello World\\\" )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\"\n                )\n            );\n        Assert.assertTrue(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"package org.drools.compiler\\n\" +\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello World\\\" )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\",\n                        \n                        \" package org.drools.compiler\\n \" +  // <<- DIFF 2x\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello World\\\" )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n \" // <<- DIFF \n                )\n            );\n        Assert.assertTrue(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"package org.drools.compiler\\n\" +\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello World\\\" )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\",\n                        \n                        \"package org.drools.compiler\\n\" +  \n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello World\\\"  )\\n\" + // <<- DIFF\n                        \"then\\n\" +\n                        \"end\\n\"\n                )\n            );\n        Assert.assertFalse(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"package org.drools.compiler\\n\" +\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello World\\\" )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\",\n                        \n                        \"package org.drools.compiler\\n\" +  \n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello    World\\\" )\\n\" + // <<- DIFF\n                        \"then\\n\" +\n                        \"end\\n\"\n                )\n            );\n        Assert.assertFalse(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"package org.drools.compiler\\n\" +\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello' World\\\" )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\",\n                        \n                        \"package org.drools.compiler\\n\" +  \n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == \\\"Hello'    World\\\" )\\n\" + // <<- DIFF\n                        \"then\\n\" +\n                        \"end\\n\"\n                )\n            );\n        Assert.assertFalse(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"package org.drools.compiler\\n\" +\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == 'Hello World' )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\",\n                        \n                        \"package org.drools.compiler\\n\" +  \n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == 'Hello    World' )\\n\" + // <<- DIFF\n                        \"then\\n\" +\n                        \"end\\n\"\n                )\n            );\n        Assert.assertFalse(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"package org.drools.compiler\\n\" +\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == 'Hello\\\" World' )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\",\n                        \n                        \"package org.drools.compiler\\n\" +  \n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == 'Hello\\\"    World' )\\n\" + // <<- DIFF\n                        \"then\\n\" +\n                        \"end\\n\"\n                )\n            );\n        Assert.assertFalse(\n                StringUtils.codeAwareEqualsIgnoreSpaces(\n                        \"package org.drools.compiler\\n\" +\n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == 'Hello\\\\' World' )\\n\" +\n                        \"then\\n\" +\n                        \"end\\n\",\n                        \n                        \"package org.drools.compiler\\n\" +  \n                        \"rule Rx when\\n\" +\n                        \"   $m : Message( message == 'Hello\\\\'    World' )\\n\" + // <<- DIFF\n                        \"then\\n\" +\n                        \"end\\n\"\n                )\n            );\n    }", "signature": "void test_codeAwareEqualsIgnoreSpaces()", "full_signature": "@Test public void test_codeAwareEqualsIgnoreSpaces()", "class_method_signature": "StringUtilsTest.test_codeAwareEqualsIgnoreSpaces()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "codeAwareEqualsIgnoreSpaces", "assertTrue", "codeAwareEqualsIgnoreSpaces", "assertFalse", "codeAwareEqualsIgnoreSpaces", "assertFalse", "codeAwareEqualsIgnoreSpaces", "assertTrue", "codeAwareEqualsIgnoreSpaces", "assertTrue", "codeAwareEqualsIgnoreSpaces", "assertTrue", "codeAwareEqualsIgnoreSpaces", "assertTrue", "codeAwareEqualsIgnoreSpaces", "assertTrue", "codeAwareEqualsIgnoreSpaces", "assertFalse", "codeAwareEqualsIgnoreSpaces", "assertTrue", "codeAwareEqualsIgnoreSpaces", "assertTrue", "codeAwareEqualsIgnoreSpaces", "assertTrue", "codeAwareEqualsIgnoreSpaces", "assertTrue", "codeAwareEqualsIgnoreSpaces", "assertFalse", "codeAwareEqualsIgnoreSpaces", "assertFalse", "codeAwareEqualsIgnoreSpaces", "assertFalse", "codeAwareEqualsIgnoreSpaces", "assertFalse", "codeAwareEqualsIgnoreSpaces", "assertFalse", "codeAwareEqualsIgnoreSpaces"]}, "focal_class": {"identifier": "StringUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String[] EMPTY_STRING_ARRAY = new String[0];", "modifier": "public static final", "type": "String[]", "declarator": "EMPTY_STRING_ARRAY = new String[0]", "var_name": "EMPTY_STRING_ARRAY"}, {"original_string": "public static final String   EMPTY              = \"\";", "modifier": "public static final", "type": "String", "declarator": "EMPTY              = \"\"", "var_name": "EMPTY"}, {"original_string": "public static final int      INDEX_NOT_FOUND    = -1;", "modifier": "public static final", "type": "int", "declarator": "INDEX_NOT_FOUND    = -1", "var_name": "INDEX_NOT_FOUND"}, {"original_string": "private static final int     PAD_LIMIT          = 8192;", "modifier": "private static final", "type": "int", "declarator": "PAD_LIMIT          = 8192", "var_name": "PAD_LIMIT"}, {"original_string": "private static final String FOLDER_SEPARATOR = \"/\";", "modifier": "private static final", "type": "String", "declarator": "FOLDER_SEPARATOR = \"/\"", "var_name": "FOLDER_SEPARATOR"}, {"original_string": "private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";", "modifier": "private static final", "type": "String", "declarator": "WINDOWS_FOLDER_SEPARATOR = \"\\\\\"", "var_name": "WINDOWS_FOLDER_SEPARATOR"}, {"original_string": "private static final String TOP_PATH = \"..\";", "modifier": "private static final", "type": "String", "declarator": "TOP_PATH = \"..\"", "var_name": "TOP_PATH"}, {"original_string": "private static final String CURRENT_PATH = \".\";", "modifier": "private static final", "type": "String", "declarator": "CURRENT_PATH = \".\"", "var_name": "CURRENT_PATH"}, {"original_string": "private static final char EXTENSION_SEPARATOR = '.';", "modifier": "private static final", "type": "char", "declarator": "EXTENSION_SEPARATOR = '.'", "var_name": "EXTENSION_SEPARATOR"}, {"original_string": "private static final char[] HEX_ARRAY = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};", "modifier": "private static final", "type": "char[]", "declarator": "HEX_ARRAY = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}", "var_name": "HEX_ARRAY"}], "methods": [{"identifier": "StringUtils", "parameters": "()", "modifiers": "public", "return": "", "signature": " StringUtils()", "full_signature": "public  StringUtils()", "class_method_signature": "StringUtils.StringUtils()", "testcase": false, "constructor": true}, {"identifier": "ucFirst", "parameters": "(final String s)", "modifiers": "public static", "return": "String", "signature": "String ucFirst(final String s)", "full_signature": "public static String ucFirst(final String s)", "class_method_signature": "StringUtils.ucFirst(final String s)", "testcase": false, "constructor": false}, {"identifier": "lcFirst", "parameters": "(String s)", "modifiers": "public static", "return": "String", "signature": "String lcFirst(String s)", "full_signature": "public static String lcFirst(String s)", "class_method_signature": "StringUtils.lcFirst(String s)", "testcase": false, "constructor": false}, {"identifier": "lcFirstForBean", "parameters": "(String s)", "modifiers": "public static", "return": "String", "signature": "String lcFirstForBean(String s)", "full_signature": "public static String lcFirstForBean(String s)", "class_method_signature": "StringUtils.lcFirstForBean(String s)", "testcase": false, "constructor": false}, {"identifier": "isEmpty", "parameters": "(final CharSequence str)", "modifiers": "public static", "return": "boolean", "signature": "boolean isEmpty(final CharSequence str)", "full_signature": "public static boolean isEmpty(final CharSequence str)", "class_method_signature": "StringUtils.isEmpty(final CharSequence str)", "testcase": false, "constructor": false}, {"identifier": "repeat", "parameters": "(final String str,\n                                final int repeat)", "modifiers": "public static", "return": "String", "signature": "String repeat(final String str,\n                                final int repeat)", "full_signature": "public static String repeat(final String str,\n                                final int repeat)", "class_method_signature": "StringUtils.repeat(final String str,\n                                final int repeat)", "testcase": false, "constructor": false}, {"identifier": "splitPreserveAllTokens", "parameters": "(final String str,\n                                                  final String separatorChars)", "modifiers": "public static", "return": "String[]", "signature": "String[] splitPreserveAllTokens(final String str,\n                                                  final String separatorChars)", "full_signature": "public static String[] splitPreserveAllTokens(final String str,\n                                                  final String separatorChars)", "class_method_signature": "StringUtils.splitPreserveAllTokens(final String str,\n                                                  final String separatorChars)", "testcase": false, "constructor": false}, {"identifier": "splitWorker", "parameters": "(final String str,\n                                        final String separatorChars,\n                                        final int max,\n                                        final boolean preserveAllTokens)", "modifiers": "private static", "return": "String[]", "signature": "String[] splitWorker(final String str,\n                                        final String separatorChars,\n                                        final int max,\n                                        final boolean preserveAllTokens)", "full_signature": "private static String[] splitWorker(final String str,\n                                        final String separatorChars,\n                                        final int max,\n                                        final boolean preserveAllTokens)", "class_method_signature": "StringUtils.splitWorker(final String str,\n                                        final String separatorChars,\n                                        final int max,\n                                        final boolean preserveAllTokens)", "testcase": false, "constructor": false}, {"identifier": "padding", "parameters": "(final int repeat,\n                                 final char padChar)", "modifiers": "public static", "return": "String", "signature": "String padding(final int repeat,\n                                 final char padChar)", "full_signature": "public static String padding(final int repeat,\n                                 final char padChar)", "class_method_signature": "StringUtils.padding(final int repeat,\n                                 final char padChar)", "testcase": false, "constructor": false}, {"identifier": "readFileAsString", "parameters": "(Reader reader)", "modifiers": "public static", "return": "String", "signature": "String readFileAsString(Reader reader)", "full_signature": "public static String readFileAsString(Reader reader)", "class_method_signature": "StringUtils.readFileAsString(Reader reader)", "testcase": false, "constructor": false}, {"identifier": "unescapeJava", "parameters": "(String str)", "modifiers": "public static", "return": "String", "signature": "String unescapeJava(String str)", "full_signature": "public static String unescapeJava(String str)", "class_method_signature": "StringUtils.unescapeJava(String str)", "testcase": false, "constructor": false}, {"identifier": "unescapeJava", "parameters": "(Writer out, String str)", "modifiers": "public static", "return": "void", "signature": "void unescapeJava(Writer out, String str)", "full_signature": "public static void unescapeJava(Writer out, String str)", "class_method_signature": "StringUtils.unescapeJava(Writer out, String str)", "testcase": false, "constructor": false}, {"identifier": "cleanPath", "parameters": "(String path)", "modifiers": "public static", "return": "String", "signature": "String cleanPath(String path)", "full_signature": "public static String cleanPath(String path)", "class_method_signature": "StringUtils.cleanPath(String path)", "testcase": false, "constructor": false}, {"identifier": "collectionToDelimitedString", "parameters": "(Collection coll, String delim, String prefix, String suffix)", "modifiers": "public static", "return": "String", "signature": "String collectionToDelimitedString(Collection coll, String delim, String prefix, String suffix)", "full_signature": "public static String collectionToDelimitedString(Collection coll, String delim, String prefix, String suffix)", "class_method_signature": "StringUtils.collectionToDelimitedString(Collection coll, String delim, String prefix, String suffix)", "testcase": false, "constructor": false}, {"identifier": "collectionToDelimitedString", "parameters": "(Collection coll, String delim)", "modifiers": "public static", "return": "String", "signature": "String collectionToDelimitedString(Collection coll, String delim)", "full_signature": "public static String collectionToDelimitedString(Collection coll, String delim)", "class_method_signature": "StringUtils.collectionToDelimitedString(Collection coll, String delim)", "testcase": false, "constructor": false}, {"identifier": "replace", "parameters": "(String inString, String oldPattern, String newPattern)", "modifiers": "public static", "return": "String", "signature": "String replace(String inString, String oldPattern, String newPattern)", "full_signature": "public static String replace(String inString, String oldPattern, String newPattern)", "class_method_signature": "StringUtils.replace(String inString, String oldPattern, String newPattern)", "testcase": false, "constructor": false}, {"identifier": "toURI", "parameters": "(String location)", "modifiers": "public static", "return": "URI", "signature": "URI toURI(String location)", "full_signature": "public static URI toURI(String location)", "class_method_signature": "StringUtils.toURI(String location)", "testcase": false, "constructor": false}, {"identifier": "escapeXmlString", "parameters": "(String string)", "modifiers": "public static", "return": "String", "signature": "String escapeXmlString(String string)", "full_signature": "public static String escapeXmlString(String string)", "class_method_signature": "StringUtils.escapeXmlString(String string)", "testcase": false, "constructor": false}, {"identifier": "delimitedListToStringArray", "parameters": "(String str, String delimiter)", "modifiers": "public static", "return": "String[]", "signature": "String[] delimitedListToStringArray(String str, String delimiter)", "full_signature": "public static String[] delimitedListToStringArray(String str, String delimiter)", "class_method_signature": "StringUtils.delimitedListToStringArray(String str, String delimiter)", "testcase": false, "constructor": false}, {"identifier": "delimitedListToStringArray", "parameters": "(String str, String delimiter, String charsToDelete)", "modifiers": "public static", "return": "String[]", "signature": "String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)", "full_signature": "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)", "class_method_signature": "StringUtils.delimitedListToStringArray(String str, String delimiter, String charsToDelete)", "testcase": false, "constructor": false}, {"identifier": "toStringArray", "parameters": "(Collection collection)", "modifiers": "public static", "return": "String[]", "signature": "String[] toStringArray(Collection collection)", "full_signature": "public static String[] toStringArray(Collection collection)", "class_method_signature": "StringUtils.toStringArray(Collection collection)", "testcase": false, "constructor": false}, {"identifier": "deleteAny", "parameters": "(String inString, String charsToDelete)", "modifiers": "public static", "return": "String", "signature": "String deleteAny(String inString, String charsToDelete)", "full_signature": "public static String deleteAny(String inString, String charsToDelete)", "class_method_signature": "StringUtils.deleteAny(String inString, String charsToDelete)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "(Reader reader)", "modifiers": "public static", "return": "String", "signature": "String toString(Reader reader)", "full_signature": "public static String toString(Reader reader)", "class_method_signature": "StringUtils.toString(Reader reader)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "(InputStream is)", "modifiers": "public static", "return": "String", "signature": "String toString(InputStream is)", "full_signature": "public static String toString(InputStream is)", "class_method_signature": "StringUtils.toString(InputStream is)", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "(BufferedReader reader)", "modifiers": "public static", "return": "String", "signature": "String toString(BufferedReader reader)", "full_signature": "public static String toString(BufferedReader reader)", "class_method_signature": "StringUtils.toString(BufferedReader reader)", "testcase": false, "constructor": false}, {"identifier": "getPkgUUID", "parameters": "(ReleaseId releaseId, String packageName)", "modifiers": "public static", "return": "String", "signature": "String getPkgUUID(ReleaseId releaseId, String packageName)", "full_signature": "public static String getPkgUUID(ReleaseId releaseId, String packageName)", "class_method_signature": "StringUtils.getPkgUUID(ReleaseId releaseId, String packageName)", "testcase": false, "constructor": false}, {"identifier": "getPkgUUID", "parameters": "(String gav, String packageName)", "modifiers": "public static", "return": "String", "signature": "String getPkgUUID(String gav, String packageName)", "full_signature": "public static String getPkgUUID(String gav, String packageName)", "class_method_signature": "StringUtils.getPkgUUID(String gav, String packageName)", "testcase": false, "constructor": false}, {"identifier": "md5Hash", "parameters": "(String s)", "modifiers": "public static", "return": "String", "signature": "String md5Hash(String s)", "full_signature": "public static String md5Hash(String s)", "class_method_signature": "StringUtils.md5Hash(String s)", "testcase": false, "constructor": false}, {"identifier": "bytesToHex", "parameters": "(byte[] bytes)", "modifiers": "public static", "return": "String", "signature": "String bytesToHex(byte[] bytes)", "full_signature": "public static String bytesToHex(byte[] bytes)", "class_method_signature": "StringUtils.bytesToHex(byte[] bytes)", "testcase": false, "constructor": false}, {"identifier": "generateUUID", "parameters": "()", "modifiers": "public static", "return": "String", "signature": "String generateUUID()", "full_signature": "public static String generateUUID()", "class_method_signature": "StringUtils.generateUUID()", "testcase": false, "constructor": false}, {"identifier": "extractFirstIdentifier", "parameters": "(String string, int start)", "modifiers": "public static", "return": "String", "signature": "String extractFirstIdentifier(String string, int start)", "full_signature": "public static String extractFirstIdentifier(String string, int start)", "class_method_signature": "StringUtils.extractFirstIdentifier(String string, int start)", "testcase": false, "constructor": false}, {"identifier": "extractFirstIdentifier", "parameters": "(String string, StringBuilder builder, int start)", "modifiers": "public static", "return": "int", "signature": "int extractFirstIdentifier(String string, StringBuilder builder, int start)", "full_signature": "public static int extractFirstIdentifier(String string, StringBuilder builder, int start)", "class_method_signature": "StringUtils.extractFirstIdentifier(String string, StringBuilder builder, int start)", "testcase": false, "constructor": false}, {"identifier": "skipBlanks", "parameters": "(String string, int start)", "modifiers": "public static", "return": "int", "signature": "int skipBlanks(String string, int start)", "full_signature": "public static int skipBlanks(String string, int start)", "class_method_signature": "StringUtils.skipBlanks(String string, int start)", "testcase": false, "constructor": false}, {"identifier": "splitStatements", "parameters": "(CharSequence string)", "modifiers": "public static", "return": "List<String>", "signature": "List<String> splitStatements(CharSequence string)", "full_signature": "public static List<String> splitStatements(CharSequence string)", "class_method_signature": "StringUtils.splitStatements(CharSequence string)", "testcase": false, "constructor": false}, {"identifier": "splitArgumentsList", "parameters": "(CharSequence string)", "modifiers": "public static", "return": "List<String>", "signature": "List<String> splitArgumentsList(CharSequence string)", "full_signature": "public static List<String> splitArgumentsList(CharSequence string)", "class_method_signature": "StringUtils.splitArgumentsList(CharSequence string)", "testcase": false, "constructor": false}, {"identifier": "splitArgumentsList", "parameters": "(CharSequence string, boolean trimArgs)", "modifiers": "public static", "return": "List<String>", "signature": "List<String> splitArgumentsList(CharSequence string, boolean trimArgs)", "full_signature": "public static List<String> splitArgumentsList(CharSequence string, boolean trimArgs)", "class_method_signature": "StringUtils.splitArgumentsList(CharSequence string, boolean trimArgs)", "testcase": false, "constructor": false}, {"identifier": "codeAwareSplitOnChar", "parameters": "(CharSequence string, boolean trimArgs, char... chs)", "modifiers": "private static", "return": "List<String>", "signature": "List<String> codeAwareSplitOnChar(CharSequence string, boolean trimArgs, char... chs)", "full_signature": "private static List<String> codeAwareSplitOnChar(CharSequence string, boolean trimArgs, char... chs)", "class_method_signature": "StringUtils.codeAwareSplitOnChar(CharSequence string, boolean trimArgs, char... chs)", "testcase": false, "constructor": false}, {"identifier": "contains", "parameters": "(char[] chars, char ch)", "modifiers": "private static", "return": "boolean", "signature": "boolean contains(char[] chars, char ch)", "full_signature": "private static boolean contains(char[] chars, char ch)", "class_method_signature": "StringUtils.contains(char[] chars, char ch)", "testcase": false, "constructor": false}, {"identifier": "codeAwareEqualsIgnoreSpaces", "parameters": "(String in1, String in2)", "modifiers": "public static", "return": "boolean", "signature": "boolean codeAwareEqualsIgnoreSpaces(String in1, String in2)", "full_signature": "public static boolean codeAwareEqualsIgnoreSpaces(String in1, String in2)", "class_method_signature": "StringUtils.codeAwareEqualsIgnoreSpaces(String in1, String in2)", "testcase": false, "constructor": false}, {"identifier": "findEndOfMethodArgsIndex", "parameters": "(CharSequence string, int startOfMethodArgsIndex)", "modifiers": "public static", "return": "int", "signature": "int findEndOfMethodArgsIndex(CharSequence string, int startOfMethodArgsIndex)", "full_signature": "public static int findEndOfMethodArgsIndex(CharSequence string, int startOfMethodArgsIndex)", "class_method_signature": "StringUtils.findEndOfMethodArgsIndex(CharSequence string, int startOfMethodArgsIndex)", "testcase": false, "constructor": false}, {"identifier": "indexOfOutOfQuotes", "parameters": "(String str, String searched)", "modifiers": "public static", "return": "int", "signature": "int indexOfOutOfQuotes(String str, String searched)", "full_signature": "public static int indexOfOutOfQuotes(String str, String searched)", "class_method_signature": "StringUtils.indexOfOutOfQuotes(String str, String searched)", "testcase": false, "constructor": false}, {"identifier": "indexOfOutOfQuotes", "parameters": "(String str, String searched, int fromIndex)", "modifiers": "public static", "return": "int", "signature": "int indexOfOutOfQuotes(String str, String searched, int fromIndex)", "full_signature": "public static int indexOfOutOfQuotes(String str, String searched, int fromIndex)", "class_method_signature": "StringUtils.indexOfOutOfQuotes(String str, String searched, int fromIndex)", "testcase": false, "constructor": false}, {"identifier": "codeAwareIndexOf", "parameters": "(String str, String searched)", "modifiers": "public static", "return": "int", "signature": "int codeAwareIndexOf(String str, String searched)", "full_signature": "public static int codeAwareIndexOf(String str, String searched)", "class_method_signature": "StringUtils.codeAwareIndexOf(String str, String searched)", "testcase": false, "constructor": false}, {"identifier": "codeAwareIndexOf", "parameters": "(String str, String searched, int fromIndex)", "modifiers": "public static", "return": "int", "signature": "int codeAwareIndexOf(String str, String searched, int fromIndex)", "full_signature": "public static int codeAwareIndexOf(String str, String searched, int fromIndex)", "class_method_signature": "StringUtils.codeAwareIndexOf(String str, String searched, int fromIndex)", "testcase": false, "constructor": false}, {"identifier": "isInComment", "parameters": "( String str, int pos )", "modifiers": "private static", "return": "boolean", "signature": "boolean isInComment( String str, int pos )", "full_signature": "private static boolean isInComment( String str, int pos )", "class_method_signature": "StringUtils.isInComment( String str, int pos )", "testcase": false, "constructor": false}, {"identifier": "replaceOutOfQuotes", "parameters": "( String s, String oldValue, String newValue )", "modifiers": "public static", "return": "String", "signature": "String replaceOutOfQuotes( String s, String oldValue, String newValue )", "full_signature": "public static String replaceOutOfQuotes( String s, String oldValue, String newValue )", "class_method_signature": "StringUtils.replaceOutOfQuotes( String s, String oldValue, String newValue )", "testcase": false, "constructor": false}, {"identifier": "isInQuotes", "parameters": "( String str, int i )", "modifiers": "private static", "return": "boolean", "signature": "boolean isInQuotes( String str, int i )", "full_signature": "private static boolean isInQuotes( String str, int i )", "class_method_signature": "StringUtils.isInQuotes( String str, int i )", "testcase": false, "constructor": false}, {"identifier": "countQuoteOccurrences", "parameters": "(String str, int start, int end)", "modifiers": "private static", "return": "int", "signature": "int countQuoteOccurrences(String str, int start, int end)", "full_signature": "private static int countQuoteOccurrences(String str, int start, int end)", "class_method_signature": "StringUtils.countQuoteOccurrences(String str, int start, int end)", "testcase": false, "constructor": false}, {"identifier": "indexOfOutOfQuotes", "parameters": "(String str, char searched)", "modifiers": "public static", "return": "int", "signature": "int indexOfOutOfQuotes(String str, char searched)", "full_signature": "public static int indexOfOutOfQuotes(String str, char searched)", "class_method_signature": "StringUtils.indexOfOutOfQuotes(String str, char searched)", "testcase": false, "constructor": false}, {"identifier": "isIdentifier", "parameters": "(String expr)", "modifiers": "public static", "return": "boolean", "signature": "boolean isIdentifier(String expr)", "full_signature": "public static boolean isIdentifier(String expr)", "class_method_signature": "StringUtils.isIdentifier(String expr)", "testcase": false, "constructor": false}, {"identifier": "isDereferencingIdentifier", "parameters": "(String expr)", "modifiers": "public static", "return": "boolean", "signature": "boolean isDereferencingIdentifier(String expr)", "full_signature": "public static boolean isDereferencingIdentifier(String expr)", "class_method_signature": "StringUtils.isDereferencingIdentifier(String expr)", "testcase": false, "constructor": false}, {"identifier": "stringSimilarity", "parameters": "( String s1, String s2, SIMILARITY_STRATS method )", "modifiers": "public static", "return": "double", "signature": "double stringSimilarity( String s1, String s2, SIMILARITY_STRATS method )", "full_signature": "public static double stringSimilarity( String s1, String s2, SIMILARITY_STRATS method )", "class_method_signature": "StringUtils.stringSimilarity( String s1, String s2, SIMILARITY_STRATS method )", "testcase": false, "constructor": false}, {"identifier": "stringSimilarityDice", "parameters": "( String s1, String s2 )", "modifiers": "private static", "return": "double", "signature": "double stringSimilarityDice( String s1, String s2 )", "full_signature": "private static double stringSimilarityDice( String s1, String s2 )", "class_method_signature": "StringUtils.stringSimilarityDice( String s1, String s2 )", "testcase": false, "constructor": false}, {"identifier": "commonBigrams", "parameters": "( String s1, String s2 )", "modifiers": "private static", "return": "int", "signature": "int commonBigrams( String s1, String s2 )", "full_signature": "private static int commonBigrams( String s1, String s2 )", "class_method_signature": "StringUtils.commonBigrams( String s1, String s2 )", "testcase": false, "constructor": false}, {"identifier": "equalsIgnoreSpaces", "parameters": "(String s1, String s2)", "modifiers": "public static", "return": "boolean", "signature": "boolean equalsIgnoreSpaces(String s1, String s2)", "full_signature": "public static boolean equalsIgnoreSpaces(String s1, String s2)", "class_method_signature": "StringUtils.equalsIgnoreSpaces(String s1, String s2)", "testcase": false, "constructor": false}, {"identifier": "uuid", "parameters": "()", "modifiers": "public static", "return": "String", "signature": "String uuid()", "full_signature": "public static String uuid()", "class_method_signature": "StringUtils.uuid()", "testcase": false, "constructor": false}], "file": "drools-core/src/main/java/org/drools/core/util/StringUtils.java"}, "focal_method": {"identifier": "codeAwareEqualsIgnoreSpaces", "parameters": "(String in1, String in2)", "modifiers": "public static", "return": "boolean", "body": "public static boolean codeAwareEqualsIgnoreSpaces(String in1, String in2) {\n        if ( in1 == null || in2 == null ) {\n            return in1 == null && in2 == null;\n        }\n        if ( in1.isEmpty() && in2.isEmpty() ) {\n            return true;\n        }\n        \n        if ( in1.length() == 0 ) {\n            in1 = \" \";\n        }\n        if ( in2.length() == 0 ) {\n            in2 = \" \";\n        }\n        \n        int idx1 = 0; Character quoted1 = null;\n        int idx2 = 0; Character quoted2 = null;\n        boolean equals = true;\n        while ( equals  ) {\n\n            while ( idx1 < (in1.length()) && (quoted1==null) && isWhitespace(in1.charAt(idx1)) ) {\n                idx1++;\n            }\n            while ( idx2 < (in2.length()) && (quoted2==null) && isWhitespace(in2.charAt(idx2)) ) {\n                idx2++;\n            }\n            \n            if ( idx1 >= in1.length() || idx2 >= in2.length() ) {\n                // considered equals if equals check succeeded and both indexes reached end of respective string.\n                equals = equals && idx1 == in1.length() && idx2 == in2.length();\n                break;\n            }\n            \n            if ( in1.charAt(idx1) == '\"' || in1.charAt(idx1) == '\\'' ) {\n                if ( quoted1 == null ) {\n                    quoted1 = in1.charAt(idx1);\n                } else if ( quoted1 != null && quoted1.equals( in1.charAt(idx1) ) ) {\n                    if ( in1.charAt(idx1-1) != '\\\\' ) {\n                        quoted1 = null;\n                    }\n                }\n                \n            }\n            if ( in2.charAt(idx2) == '\"' || in2.charAt(idx2) == '\\'' ) {\n                if ( quoted2 == null ) {\n                    quoted2 = in2.charAt(idx2);\n                } else if ( quoted2 != null && quoted2.equals( in2.charAt(idx2) ) ) {\n                    if ( in2.charAt(idx2-1) != '\\\\' ) {\n                        quoted2 = null;\n                    }\n                }\n                \n            }\n\n            equals &= in1.charAt(idx1) == in2.charAt(idx2);\n            idx1++;\n            idx2++;\n        }\n        return equals;\n    }", "signature": "boolean codeAwareEqualsIgnoreSpaces(String in1, String in2)", "full_signature": "public static boolean codeAwareEqualsIgnoreSpaces(String in1, String in2)", "class_method_signature": "StringUtils.codeAwareEqualsIgnoreSpaces(String in1, String in2)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "isEmpty", "length", "length", "length", "isWhitespace", "charAt", "length", "isWhitespace", "charAt", "length", "length", "length", "length", "charAt", "charAt", "charAt", "equals", "charAt", "charAt", "charAt", "charAt", "charAt", "equals", "charAt", "charAt", "charAt", "charAt"]}, "repository": {"repo_id": 1381673, "url": "https://github.com/kiegroup/drools", "stars": 2733, "created": "2/18/2011 8:37:05 AM +00:00", "updates": "2020-01-27T13:12:15+00:00", "fork": "False", "license": "licensed"}}