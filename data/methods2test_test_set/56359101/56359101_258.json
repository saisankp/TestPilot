{"test_class": {"identifier": "ShellCommandUtilsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ShellCommandUtils spy;", "modifier": "private", "type": "ShellCommandUtils", "declarator": "spy", "var_name": "spy"}, {"original_string": "private String command = \"test\";", "modifier": "private", "type": "String", "declarator": "command = \"test\"", "var_name": "command"}], "file": "autonomic-plugin-common/src/test/java/br/com/autonomiccs/autonomic/plugin/common/utils/ShellCommandUtilsTest.java"}, "test_case": {"identifier": "executeCommandTest", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void executeCommandTest() throws IOException, InterruptedException{\n        Process processMock = Mockito.mock(Process.class);\n        Runtime runtimeMock = configureAndGetRuntimeMock();\n\n        String commandOutput = \"TEST\";\n        InputStream input = IOUtils.toInputStream(commandOutput, (String) null);\n\n        Mockito.when(runtimeMock.exec(command)).thenReturn(processMock);\n        Mockito.when(processMock.waitFor()).thenReturn(1);\n        Mockito.when(processMock.getInputStream()).thenReturn(input);\n\n        String response = spy.executeCommand(command);\n        Assert.assertEquals(commandOutput, response);\n        Mockito.verify(processMock).waitFor();\n    }", "signature": "void executeCommandTest()", "full_signature": "@Test public void executeCommandTest()", "class_method_signature": "ShellCommandUtilsTest.executeCommandTest()", "testcase": true, "constructor": false, "invocations": ["mock", "configureAndGetRuntimeMock", "toInputStream", "thenReturn", "when", "exec", "thenReturn", "when", "waitFor", "thenReturn", "when", "getInputStream", "executeCommand", "assertEquals", "waitFor", "verify"]}, "focal_class": {"identifier": "ShellCommandUtils", "superclass": "", "interfaces": "", "fields": [{"original_string": "protected Logger logger = LoggerFactory.getLogger(this.getClass());", "modifier": "protected", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(this.getClass())", "var_name": "logger"}], "methods": [{"identifier": "executeCommand", "parameters": "(String command)", "modifiers": "public", "return": "String", "signature": "String executeCommand(String command)", "full_signature": "public String executeCommand(String command)", "class_method_signature": "ShellCommandUtils.executeCommand(String command)", "testcase": false, "constructor": false}], "file": "autonomic-plugin-common/src/main/java/br/com/autonomiccs/autonomic/plugin/common/utils/ShellCommandUtils.java"}, "focal_method": {"identifier": "executeCommand", "parameters": "(String command)", "modifiers": "public", "return": "String", "body": "public String executeCommand(String command) {\n        Writer output = new StringWriter();\n        try {\n            Process p = Runtime.getRuntime().exec(command);\n            p.waitFor();\n            IOUtils.copy(p.getInputStream(), output);\n        } catch (IOException | InterruptedException e) {\n            logger.error(String.format(\"An error happened while executing command[%s]\", command), e);\n        }\n        return output.toString();\n    }", "signature": "String executeCommand(String command)", "full_signature": "public String executeCommand(String command)", "class_method_signature": "ShellCommandUtils.executeCommand(String command)", "testcase": false, "constructor": false, "invocations": ["exec", "getRuntime", "waitFor", "copy", "getInputStream", "error", "format", "toString"]}, "repository": {"repo_id": 56359101, "url": "https://github.com/Autonomiccs/autonomiccs-platform", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 17, "size": 944, "license": "licensed"}}