{"test_class": {"identifier": "HistogramActionTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private QueryExecutor queryExecutor;", "modifier": "private", "type": "QueryExecutor", "declarator": "queryExecutor", "var_name": "queryExecutor"}, {"original_string": "private final ObjectMapper mapper = new ObjectMapper();", "modifier": "private final", "type": "ObjectMapper", "declarator": "mapper = new ObjectMapper()", "var_name": "mapper"}, {"original_string": "private MockElasticsearchServer elasticsearchServer;", "modifier": "private", "type": "MockElasticsearchServer", "declarator": "elasticsearchServer", "var_name": "elasticsearchServer"}, {"original_string": "private HazelcastInstance hazelcastInstance;", "modifier": "private", "type": "HazelcastInstance", "declarator": "hazelcastInstance", "var_name": "hazelcastInstance"}, {"original_string": "private JsonNodeFactory factory = JsonNodeFactory.instance;", "modifier": "private", "type": "JsonNodeFactory", "declarator": "factory = JsonNodeFactory.instance", "var_name": "factory"}], "file": "real-time/foxtrot/foxtrot-core/src/test/java/com/flipkart/foxtrot/core/querystore/actions/HistogramActionTest.java"}, "test_case": {"identifier": "testHistogramActionAnyException", "parameters": "()", "modifiers": "@Test(expected = QueryStoreException.class) public", "return": "void", "body": "@Test(expected = QueryStoreException.class)\n    public void testHistogramActionAnyException() throws QueryStoreException, JsonProcessingException {\n        HistogramRequest histogramRequest = new HistogramRequest();\n        histogramRequest.setTable(TestUtils.TEST_TABLE_NAME);\n        histogramRequest.setPeriod(Period.minutes);\n        when(elasticsearchServer.getClient()).thenReturn(null);\n        queryExecutor.execute(histogramRequest);\n    }", "signature": "void testHistogramActionAnyException()", "full_signature": "@Test(expected = QueryStoreException.class) public void testHistogramActionAnyException()", "class_method_signature": "HistogramActionTest.testHistogramActionAnyException()", "testcase": true, "constructor": false, "invocations": ["setTable", "setPeriod", "thenReturn", "when", "getClient", "execute"]}, "focal_class": {"identifier": "HistogramAction", "superclass": "extends Action<HistogramRequest>", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(HistogramAction.class.getSimpleName());", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(HistogramAction.class.getSimpleName())", "var_name": "logger"}], "methods": [{"identifier": "HistogramAction", "parameters": "(HistogramRequest parameter,\n                           TableMetadataManager tableMetadataManager,\n                           DataStore dataStore,\n                           QueryStore queryStore,\n                           ElasticsearchConnection connection,\n                           String cacheToken)", "modifiers": "public", "return": "", "signature": " HistogramAction(HistogramRequest parameter,\n                           TableMetadataManager tableMetadataManager,\n                           DataStore dataStore,\n                           QueryStore queryStore,\n                           ElasticsearchConnection connection,\n                           String cacheToken)", "full_signature": "public  HistogramAction(HistogramRequest parameter,\n                           TableMetadataManager tableMetadataManager,\n                           DataStore dataStore,\n                           QueryStore queryStore,\n                           ElasticsearchConnection connection,\n                           String cacheToken)", "class_method_signature": "HistogramAction.HistogramAction(HistogramRequest parameter,\n                           TableMetadataManager tableMetadataManager,\n                           DataStore dataStore,\n                           QueryStore queryStore,\n                           ElasticsearchConnection connection,\n                           String cacheToken)", "testcase": false, "constructor": true}, {"identifier": "getRequestCacheKey", "parameters": "()", "modifiers": "@Override protected", "return": "String", "signature": "String getRequestCacheKey()", "full_signature": "@Override protected String getRequestCacheKey()", "class_method_signature": "HistogramAction.getRequestCacheKey()", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "(HistogramRequest parameter)", "modifiers": "@Override public", "return": "ActionResponse", "signature": "ActionResponse execute(HistogramRequest parameter)", "full_signature": "@Override public ActionResponse execute(HistogramRequest parameter)", "class_method_signature": "HistogramAction.execute(HistogramRequest parameter)", "testcase": false, "constructor": false}, {"identifier": "getDefaultTimeSpan", "parameters": "()", "modifiers": "@Override protected", "return": "Filter", "signature": "Filter getDefaultTimeSpan()", "full_signature": "@Override protected Filter getDefaultTimeSpan()", "class_method_signature": "HistogramAction.getDefaultTimeSpan()", "testcase": false, "constructor": false}], "file": "real-time/foxtrot/foxtrot-core/src/main/java/com/flipkart/foxtrot/core/querystore/actions/HistogramAction.java"}, "focal_method": {"identifier": "execute", "parameters": "(HistogramRequest parameter)", "modifiers": "@Override public", "return": "ActionResponse", "body": "@Override\n    public ActionResponse execute(HistogramRequest parameter) throws QueryStoreException {\n        parameter.setTable(ElasticsearchUtils.getValidTableName(parameter.getTable()));\n        if (null == parameter.getFilters()) {\n            parameter.setFilters(Lists.<Filter>newArrayList(new AnyFilter(parameter.getTable())));\n        }\n\n        if (parameter.getField() == null || parameter.getField().trim().isEmpty()) {\n            throw new QueryStoreException(QueryStoreException.ErrorCode.INVALID_REQUEST, \"Illegal Nesting Parameters\");\n        }\n\n        try {\n            /*if(!tableManager.exists(query.getTable())) {\n                throw new QueryStoreException(QueryStoreException.ErrorCode.NO_SUCH_TABLE,\n                        \"There is no table called: \" + query.getTable());\n            }*/\n            DateHistogram.Interval interval = null;\n            switch (parameter.getPeriod()) {\n                case seconds:\n                    interval = DateHistogram.Interval.SECOND;\n                    break;\n                case minutes:\n                    interval = DateHistogram.Interval.MINUTE;\n                    break;\n                case hours:\n                    interval = DateHistogram.Interval.HOUR;\n                    break;\n                case days:\n                    interval = DateHistogram.Interval.DAY;\n                    break;\n            }\n\n            String dateHistogramKey = Utils.sanitizeFieldForAggregation(parameter.getField());\n            SearchResponse response = getConnection().getClient().prepareSearch(\n                    ElasticsearchUtils.getIndices(parameter.getTable(), parameter))\n                    .setTypes(ElasticsearchUtils.TYPE_NAME)\n                    .setQuery(new ElasticSearchQueryGenerator(FilterCombinerType.and)\n                            .genFilter(parameter.getFilters()))\n                    .setSize(0)\n                    .setSearchType(SearchType.COUNT)\n                    .addAggregation(AggregationBuilders.dateHistogram(dateHistogramKey)\n                            .field(parameter.getField())\n                            .interval(interval))\n                    .execute()\n                    .actionGet();\n            Aggregations aggregations = response.getAggregations();\n            if (aggregations == null) {\n                logger.error(\"Null response for Histogram. Request : \" + parameter.toString());\n                return new HistogramResponse(Collections.<HistogramResponse.Count>emptyList());\n            }\n            DateHistogram dateHistogram = aggregations.get(dateHistogramKey);\n            Collection<? extends DateHistogram.Bucket> buckets = dateHistogram.getBuckets();\n            List<HistogramResponse.Count> counts = new ArrayList<HistogramResponse.Count>(buckets.size());\n            for (DateHistogram.Bucket bucket : buckets) {\n                HistogramResponse.Count count = new HistogramResponse.Count(\n                        bucket.getKeyAsNumber(), bucket.getDocCount());\n                counts.add(count);\n            }\n            return new HistogramResponse(counts);\n        } catch (QueryStoreException ex) {\n            throw ex;\n        } catch (Exception e) {\n            throw new QueryStoreException(QueryStoreException.ErrorCode.HISTOGRAM_GENERATION_ERROR,\n                    \"Malformed query\", e);\n        }\n    }", "signature": "ActionResponse execute(HistogramRequest parameter)", "full_signature": "@Override public ActionResponse execute(HistogramRequest parameter)", "class_method_signature": "HistogramAction.execute(HistogramRequest parameter)", "testcase": false, "constructor": false, "invocations": ["setTable", "getValidTableName", "getTable", "getFilters", "setFilters", "newArrayList", "getTable", "getField", "isEmpty", "trim", "getField", "getPeriod", "sanitizeFieldForAggregation", "getField", "actionGet", "execute", "addAggregation", "setSearchType", "setSize", "setQuery", "setTypes", "prepareSearch", "getClient", "getConnection", "getIndices", "getTable", "genFilter", "getFilters", "interval", "field", "dateHistogram", "getField", "getAggregations", "error", "toString", "emptyList", "get", "getBuckets", "size", "getKeyAsNumber", "getDocCount", "add"]}, "repository": {"repo_id": 44512524, "url": "https://github.com/zqhxuyuan/bigdata", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 8, "size": 91550, "license": "licensed"}}