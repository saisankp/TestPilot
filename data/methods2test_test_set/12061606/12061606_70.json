{"test_class": {"identifier": "TopologyTest", "superclass": "", "interfaces": "", "fields": [], "file": "core/src/test/java/uk/ac/ebi/beam/TopologyTest.java"}, "test_case": {"identifier": "implicitToExplicit_al1_al2", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void implicitToExplicit_al1_al2() {\n        assertThat(Topology.toExplicit(new Graph(0), 0, Configuration.AL1),\n                   is(Configuration.AL1));\n        assertThat(Topology.toExplicit(new Graph(0), 0, Configuration.AL2),\n                   is(Configuration.AL2));\n    }", "signature": "void implicitToExplicit_al1_al2()", "full_signature": "@Test public void implicitToExplicit_al1_al2()", "class_method_signature": "TopologyTest.implicitToExplicit_al1_al2()", "testcase": true, "constructor": false, "invocations": ["assertThat", "toExplicit", "is", "assertThat", "toExplicit", "is"]}, "focal_class": {"identifier": "Topology", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static Topology UNKNOWN = new Topology() {\n        @Override int atom() {\n            throw new IllegalArgumentException(\"unknown topology\");\n        }\n\n        @Override Configuration configuration() {\n            return Configuration.UNKNOWN;\n        }\n\n        @Override Topology orderBy(int[] rank) {\n            return this;\n        }\n\n        @Override Topology transform(int[] mapping) {\n            return this;\n        }\n\n        @Override void copy(int[] dest) {\n        }\n    };", "modifier": "private static", "type": "Topology", "declarator": "UNKNOWN = new Topology() {\n        @Override int atom() {\n            throw new IllegalArgumentException(\"unknown topology\");\n        }\n\n        @Override Configuration configuration() {\n            return Configuration.UNKNOWN;\n        }\n\n        @Override Topology orderBy(int[] rank) {\n            return this;\n        }\n\n        @Override Topology transform(int[] mapping) {\n            return this;\n        }\n\n        @Override void copy(int[] dest) {\n        }\n    }", "var_name": "UNKNOWN"}, {"original_string": "private static final int A = 0;", "modifier": "private static final", "type": "int", "declarator": "A = 0", "var_name": "A"}, {"original_string": "private static final int B = 1;", "modifier": "private static final", "type": "int", "declarator": "B = 1", "var_name": "B"}, {"original_string": "private static final int C = 2;", "modifier": "private static final", "type": "int", "declarator": "C = 2", "var_name": "C"}, {"original_string": "private static final int D = 3;", "modifier": "private static final", "type": "int", "declarator": "D = 3", "var_name": "D"}, {"original_string": "private static final int E = 4;", "modifier": "private static final", "type": "int", "declarator": "E = 4", "var_name": "E"}, {"original_string": "private static final int F = 5;", "modifier": "private static final", "type": "int", "declarator": "F = 5", "var_name": "F"}], "methods": [{"identifier": "atom", "parameters": "()", "modifiers": "abstract", "return": "int", "signature": "int atom()", "full_signature": "abstract int atom()", "class_method_signature": "Topology.atom()", "testcase": false, "constructor": false}, {"identifier": "configuration", "parameters": "()", "modifiers": "abstract", "return": "Configuration", "signature": "Configuration configuration()", "full_signature": "abstract Configuration configuration()", "class_method_signature": "Topology.configuration()", "testcase": false, "constructor": false}, {"identifier": "configurationOf", "parameters": "(int[] rank)", "modifiers": "", "return": "Configuration", "signature": "Configuration configurationOf(int[] rank)", "full_signature": " Configuration configurationOf(int[] rank)", "class_method_signature": "Topology.configurationOf(int[] rank)", "testcase": false, "constructor": false}, {"identifier": "type", "parameters": "()", "modifiers": "", "return": "Configuration.Type", "signature": "Configuration.Type type()", "full_signature": " Configuration.Type type()", "class_method_signature": "Topology.type()", "testcase": false, "constructor": false}, {"identifier": "orderBy", "parameters": "(int[] rank)", "modifiers": "abstract", "return": "Topology", "signature": "Topology orderBy(int[] rank)", "full_signature": "abstract Topology orderBy(int[] rank)", "class_method_signature": "Topology.orderBy(int[] rank)", "testcase": false, "constructor": false}, {"identifier": "transform", "parameters": "(int[] mapping)", "modifiers": "abstract", "return": "Topology", "signature": "Topology transform(int[] mapping)", "full_signature": "abstract Topology transform(int[] mapping)", "class_method_signature": "Topology.transform(int[] mapping)", "testcase": false, "constructor": false}, {"identifier": "copy", "parameters": "(int[] dest)", "modifiers": "abstract", "return": "void", "signature": "void copy(int[] dest)", "full_signature": "abstract void copy(int[] dest)", "class_method_signature": "Topology.copy(int[] dest)", "testcase": false, "constructor": false}, {"identifier": "parity", "parameters": "(int[] vs, int[] rank)", "modifiers": "static", "return": "int", "signature": "int parity(int[] vs, int[] rank)", "full_signature": "static int parity(int[] vs, int[] rank)", "class_method_signature": "Topology.parity(int[] vs, int[] rank)", "testcase": false, "constructor": false}, {"identifier": "parity4", "parameters": "(int[] vs, int[] rank)", "modifiers": "static", "return": "int", "signature": "int parity4(int[] vs, int[] rank)", "full_signature": "static int parity4(int[] vs, int[] rank)", "class_method_signature": "Topology.parity4(int[] vs, int[] rank)", "testcase": false, "constructor": false}, {"identifier": "sort", "parameters": "(int[] vs, int[] rank)", "modifiers": "static", "return": "int[]", "signature": "int[] sort(int[] vs, int[] rank)", "full_signature": "static int[] sort(int[] vs, int[] rank)", "class_method_signature": "Topology.sort(int[] vs, int[] rank)", "testcase": false, "constructor": false}, {"identifier": "unknown", "parameters": "()", "modifiers": "static", "return": "Topology", "signature": "Topology unknown()", "full_signature": "static Topology unknown()", "class_method_signature": "Topology.unknown()", "testcase": false, "constructor": false}, {"identifier": "tetrahedral", "parameters": "(int u, int[] vs, Configuration configuration)", "modifiers": "static", "return": "Topology", "signature": "Topology tetrahedral(int u, int[] vs, Configuration configuration)", "full_signature": "static Topology tetrahedral(int u, int[] vs, Configuration configuration)", "class_method_signature": "Topology.tetrahedral(int u, int[] vs, Configuration configuration)", "testcase": false, "constructor": false}, {"identifier": "extendedTetrahedral", "parameters": "(int u, int[] vs, Configuration configuration)", "modifiers": "static", "return": "Topology", "signature": "Topology extendedTetrahedral(int u, int[] vs, Configuration configuration)", "full_signature": "static Topology extendedTetrahedral(int u, int[] vs, Configuration configuration)", "class_method_signature": "Topology.extendedTetrahedral(int u, int[] vs, Configuration configuration)", "testcase": false, "constructor": false}, {"identifier": "trigonal", "parameters": "(int u, int[] vs, Configuration configuration)", "modifiers": "static", "return": "Topology", "signature": "Topology trigonal(int u, int[] vs, Configuration configuration)", "full_signature": "static Topology trigonal(int u, int[] vs, Configuration configuration)", "class_method_signature": "Topology.trigonal(int u, int[] vs, Configuration configuration)", "testcase": false, "constructor": false}, {"identifier": "squarePlanar", "parameters": "(int u, int[] vs, Configuration configuration)", "modifiers": "static", "return": "Topology", "signature": "Topology squarePlanar(int u, int[] vs, Configuration configuration)", "full_signature": "static Topology squarePlanar(int u, int[] vs, Configuration configuration)", "class_method_signature": "Topology.squarePlanar(int u, int[] vs, Configuration configuration)", "testcase": false, "constructor": false}, {"identifier": "trigonalBipyramidal", "parameters": "(int u, int[] vs, Configuration c)", "modifiers": "private static", "return": "Topology", "signature": "Topology trigonalBipyramidal(int u, int[] vs, Configuration c)", "full_signature": "private static Topology trigonalBipyramidal(int u, int[] vs, Configuration c)", "class_method_signature": "Topology.trigonalBipyramidal(int u, int[] vs, Configuration c)", "testcase": false, "constructor": false}, {"identifier": "octahedral", "parameters": "(int u, int[] vs, Configuration c)", "modifiers": "private static", "return": "Topology", "signature": "Topology octahedral(int u, int[] vs, Configuration c)", "full_signature": "private static Topology octahedral(int u, int[] vs, Configuration c)", "class_method_signature": "Topology.octahedral(int u, int[] vs, Configuration c)", "testcase": false, "constructor": false}, {"identifier": "toExplicit", "parameters": "(Graph g, int u, Configuration c)", "modifiers": "static", "return": "Configuration", "signature": "Configuration toExplicit(Graph g, int u, Configuration c)", "full_signature": "static Configuration toExplicit(Graph g, int u, Configuration c)", "class_method_signature": "Topology.toExplicit(Graph g, int u, Configuration c)", "testcase": false, "constructor": false}, {"identifier": "create", "parameters": "(int u, int[] vs, List<Edge> es, Configuration c)", "modifiers": "static", "return": "Topology", "signature": "Topology create(int u, int[] vs, List<Edge> es, Configuration c)", "full_signature": "static Topology create(int u, int[] vs, List<Edge> es, Configuration c)", "class_method_signature": "Topology.create(int u, int[] vs, List<Edge> es, Configuration c)", "testcase": false, "constructor": false}, {"identifier": "check", "parameters": "(int[] dest, int[] src, int[] perm, int step, int skip)", "modifiers": "private static", "return": "boolean", "signature": "boolean check(int[] dest, int[] src, int[] perm, int step, int skip)", "full_signature": "private static boolean check(int[] dest, int[] src, int[] perm, int step, int skip)", "class_method_signature": "Topology.check(int[] dest, int[] src, int[] perm, int step, int skip)", "testcase": false, "constructor": false}, {"identifier": "swap", "parameters": "(int[] arr, int i, int j)", "modifiers": "private static", "return": "void", "signature": "void swap(int[] arr, int i, int j)", "full_signature": "private static void swap(int[] arr, int i, int j)", "class_method_signature": "Topology.swap(int[] arr, int i, int j)", "testcase": false, "constructor": false}, {"identifier": "indirectSort", "parameters": "(int[] dst, int[] rank)", "modifiers": "private static", "return": "void", "signature": "void indirectSort(int[] dst, int[] rank)", "full_signature": "private static void indirectSort(int[] dst, int[] rank)", "class_method_signature": "Topology.indirectSort(int[] dst, int[] rank)", "testcase": false, "constructor": false}, {"identifier": "applyInv", "parameters": "(int[] src, int[] perm)", "modifiers": "private static", "return": "int[]", "signature": "int[] applyInv(int[] src, int[] perm)", "full_signature": "private static int[] applyInv(int[] src, int[] perm)", "class_method_signature": "Topology.applyInv(int[] src, int[] perm)", "testcase": false, "constructor": false}, {"identifier": "toObjArray", "parameters": "(int[] arr)", "modifiers": "private static", "return": "Integer[]", "signature": "Integer[] toObjArray(int[] arr)", "full_signature": "private static Integer[] toObjArray(int[] arr)", "class_method_signature": "Topology.toObjArray(int[] arr)", "testcase": false, "constructor": false}, {"identifier": "toIntArray", "parameters": "(Integer[] arr)", "modifiers": "private static", "return": "int[]", "signature": "int[] toIntArray(Integer[] arr)", "full_signature": "private static int[] toIntArray(Integer[] arr)", "class_method_signature": "Topology.toIntArray(Integer[] arr)", "testcase": false, "constructor": false}], "file": "core/src/main/java/uk/ac/ebi/beam/Topology.java"}, "focal_method": {"identifier": "toExplicit", "parameters": "(Graph g, int u, Configuration c)", "modifiers": "static", "return": "Configuration", "body": "static Configuration toExplicit(Graph g, int u, Configuration c) {\n\n        // already explicit\n        if (c.type() != Implicit)\n            return c;\n\n        int deg     = g.degree(u);\n        int valence = deg + g.atom(u).hydrogens();\n\n        // tetrahedral topology, square planar must always be explicit\n        if (valence == 4) {\n            return c == ANTI_CLOCKWISE ? TH1 : TH2;\n        }\n\n        // tetrahedral topology with implicit lone pair or double bond (Sp2)\n        // atoms (todo)\n        else if (valence == 3) {\n\n            // XXX: sulfoxide and selenium special case... would be better to compute\n            // hybridization don't really like doing this here but is sufficient\n            // for now\n            if (g.atom(u).element() == Element.Sulfur || g.atom(u).element() == Element.Selenium) {\n                int sb = 0, db = 0;\n                final int d = g.degree(u);\n                for (int j=0; j<d; ++j) {\n                    final Edge e = g.edgeAt(u, j);\n                    if (e.bond().order() == 1)\n                        sb++;\n                    else if (e.bond().order() == 2)\n                        db++;\n                    else return Configuration.UNKNOWN;\n                }\n                int q = g.atom(u).charge();\n                if ((q == 0 && sb == 2 && db == 1) || (q == 1 && sb == 3))\n                    return c == ANTI_CLOCKWISE ? TH1 : TH2;\n                else\n                    return Configuration.UNKNOWN;\n            }\n            \n            if (g.atom(u).element() == Element.Phosphorus ||\n                g.atom(u).element() == Element.Nitrogen) {\n                if (g.bondedValence(u) == 3 && g.implHCount(u) == 0 && g.atom(u).charge() == 0)  {\n                    return c == ANTI_CLOCKWISE ? TH1 : TH2;\n                }\n            }\n\n            // for the atom centric double bond configuration check there is\n            // a double bond and it's not sill tetrahedral specification such\n            // as [C@-](N)(O)C\n            int nDoubleBonds = 0;\n            final int d = g.degree(u);\n            for (int j=0; j<d; ++j) {\n                final Edge e = g.edgeAt(u, j);\n                if (e.bond() == Bond.DOUBLE)\n                    nDoubleBonds++;\n            }\n\n            if (nDoubleBonds == 1) {\n                return c == ANTI_CLOCKWISE ? DB1 : DB2;\n            } else {\n                return Configuration.UNKNOWN;\n            }\n        }\n\n        // odd number of cumulated double bond systems (e.g. allene)\n        else if (deg == 2) {\n\n            int nDoubleBonds = 0;\n\n            // check both bonds are double\n            final int d = g.degree(u);\n            for (int j = 0; j < d; ++j) {\n                final Edge e = g.edgeAt(u, j);\n                if (e.bond() != Bond.DOUBLE)\n                    nDoubleBonds++;\n            }\n\n            if (nDoubleBonds == 1) {\n                return c == ANTI_CLOCKWISE ? DB1 : DB2;\n            } else {\n                return c == ANTI_CLOCKWISE ? AL1 : AL2;\n            }\n        }\n\n        // trigonal bipyramidal\n        else if (valence == 5) {\n            return c == ANTI_CLOCKWISE ? TB1 : TB2;\n        }\n\n        // octahedral\n        else if (valence == 6) {\n            return c == ANTI_CLOCKWISE ? OH1 : OH2;\n        }\n\n        return Configuration.UNKNOWN;\n    }", "signature": "Configuration toExplicit(Graph g, int u, Configuration c)", "full_signature": "static Configuration toExplicit(Graph g, int u, Configuration c)", "class_method_signature": "Topology.toExplicit(Graph g, int u, Configuration c)", "testcase": false, "constructor": false, "invocations": ["type", "degree", "hydrogens", "atom", "element", "atom", "element", "atom", "degree", "edgeAt", "order", "bond", "order", "bond", "charge", "atom", "element", "atom", "element", "atom", "bondedValence", "implHCount", "charge", "atom", "degree", "edgeAt", "bond", "degree", "edgeAt", "bond"]}, "repository": {"repo_id": 12061606, "url": "https://github.com/johnmay/beam", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 19, "size": 825, "license": "licensed"}}