{"test_class": {"identifier": "MinimalZipParserTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private byte[] unitTestZipArchive;", "modifier": "private", "type": "byte[]", "declarator": "unitTestZipArchive", "var_name": "unitTestZipArchive"}], "file": "feya/libraries/archive_diff/diff.generator/src/test/java/com/google/archivepatcher/generator/MinimalZipParserTest.java"}, "test_case": {"identifier": "testParseLocalEntryAndGetCompressedDataOffset", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testParseLocalEntryAndGetCompressedDataOffset() throws Exception {\n    ByteArrayInputStream in = new ByteArrayInputStream(unitTestZipArchive);\n    in.mark(unitTestZipArchive.length);\n    int eocdOffset = MinimalZipParser.locateStartOfEocd(unitTestZipArchive);\n    Assert.assertEquals(eocdOffset, in.skip(eocdOffset));\n    MinimalCentralDirectoryMetadata metadata = MinimalZipParser.parseEocd(in);\n    in.reset();\n    Assert.assertEquals(\n        metadata.getOffsetOfCentralDirectory(), in.skip(metadata.getOffsetOfCentralDirectory()));\n\n    // Read each entry and verify all fields *except* the value returned by\n    // MinimalZipEntry.getFileOffsetOfCompressedData(), as that has yet to be computed.\n    List<MinimalZipEntry> parsedEntries = new ArrayList<MinimalZipEntry>();\n    for (int x = 0; x < UnitTestZipArchive.allEntriesInFileOrder.size(); x++) {\n      parsedEntries.add(MinimalZipParser.parseCentralDirectoryEntry(in));\n    }\n\n    for (int x = 0; x < UnitTestZipArchive.allEntriesInFileOrder.size(); x++) {\n      UnitTestZipEntry expectedEntry = UnitTestZipArchive.allEntriesInFileOrder.get(x);\n      MinimalZipEntry parsedEntry = parsedEntries.get(x);\n      in.reset();\n      Assert.assertEquals(\n          parsedEntry.getFileOffsetOfLocalEntry(),\n          in.skip(parsedEntry.getFileOffsetOfLocalEntry()));\n      long relativeDataOffset = MinimalZipParser.parseLocalEntryAndGetCompressedDataOffset(in);\n      Assert.assertTrue(relativeDataOffset > 0);\n      checkExpectedBytes(\n          expectedEntry.getCompressedBinaryContent(),\n          (int) (parsedEntry.getFileOffsetOfLocalEntry() + relativeDataOffset));\n    }\n  }", "signature": "void testParseLocalEntryAndGetCompressedDataOffset()", "full_signature": "@Test public void testParseLocalEntryAndGetCompressedDataOffset()", "class_method_signature": "MinimalZipParserTest.testParseLocalEntryAndGetCompressedDataOffset()", "testcase": true, "constructor": false, "invocations": ["mark", "locateStartOfEocd", "assertEquals", "skip", "parseEocd", "reset", "assertEquals", "getOffsetOfCentralDirectory", "skip", "getOffsetOfCentralDirectory", "size", "add", "parseCentralDirectoryEntry", "size", "get", "get", "reset", "assertEquals", "getFileOffsetOfLocalEntry", "skip", "getFileOffsetOfLocalEntry", "parseLocalEntryAndGetCompressedDataOffset", "assertTrue", "checkExpectedBytes", "getCompressedBinaryContent", "getFileOffsetOfLocalEntry"]}, "focal_class": {"identifier": "MinimalZipParser", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int EOCD_SIGNATURE = 0x06054b50;", "modifier": "public static final", "type": "int", "declarator": "EOCD_SIGNATURE = 0x06054b50", "var_name": "EOCD_SIGNATURE"}, {"original_string": "public static final int CENTRAL_DIRECTORY_ENTRY_SIGNATURE = 0x02014b50;", "modifier": "public static final", "type": "int", "declarator": "CENTRAL_DIRECTORY_ENTRY_SIGNATURE = 0x02014b50", "var_name": "CENTRAL_DIRECTORY_ENTRY_SIGNATURE"}, {"original_string": "public static final int LOCAL_ENTRY_SIGNATURE = 0x04034b50;", "modifier": "public static final", "type": "int", "declarator": "LOCAL_ENTRY_SIGNATURE = 0x04034b50", "var_name": "LOCAL_ENTRY_SIGNATURE"}], "methods": [{"identifier": "readByteOrDie", "parameters": "(InputStream in)", "modifiers": "private static", "return": "int", "signature": "int readByteOrDie(InputStream in)", "full_signature": "private static int readByteOrDie(InputStream in)", "class_method_signature": "MinimalZipParser.readByteOrDie(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "skipOrDie", "parameters": "(InputStream in, long numBytes)", "modifiers": "private static", "return": "void", "signature": "void skipOrDie(InputStream in, long numBytes)", "full_signature": "private static void skipOrDie(InputStream in, long numBytes)", "class_method_signature": "MinimalZipParser.skipOrDie(InputStream in, long numBytes)", "testcase": false, "constructor": false}, {"identifier": "read16BitUnsigned", "parameters": "(InputStream in)", "modifiers": "private static", "return": "int", "signature": "int read16BitUnsigned(InputStream in)", "full_signature": "private static int read16BitUnsigned(InputStream in)", "class_method_signature": "MinimalZipParser.read16BitUnsigned(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "read32BitUnsigned", "parameters": "(InputStream in)", "modifiers": "private static", "return": "long", "signature": "long read32BitUnsigned(InputStream in)", "full_signature": "private static long read32BitUnsigned(InputStream in)", "class_method_signature": "MinimalZipParser.read32BitUnsigned(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "readOrDie", "parameters": "(InputStream in, byte[] buffer, int offset, int length)", "modifiers": "private static", "return": "void", "signature": "void readOrDie(InputStream in, byte[] buffer, int offset, int length)", "full_signature": "private static void readOrDie(InputStream in, byte[] buffer, int offset, int length)", "class_method_signature": "MinimalZipParser.readOrDie(InputStream in, byte[] buffer, int offset, int length)", "testcase": false, "constructor": false}, {"identifier": "parseCentralDirectoryEntry", "parameters": "(InputStream in)", "modifiers": "public static", "return": "MinimalZipEntry", "signature": "MinimalZipEntry parseCentralDirectoryEntry(InputStream in)", "full_signature": "public static MinimalZipEntry parseCentralDirectoryEntry(InputStream in)", "class_method_signature": "MinimalZipParser.parseCentralDirectoryEntry(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "parseLocalEntryAndGetCompressedDataOffset", "parameters": "(InputStream in)", "modifiers": "public static", "return": "long", "signature": "long parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "full_signature": "public static long parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "class_method_signature": "MinimalZipParser.parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "testcase": false, "constructor": false}, {"identifier": "locateStartOfEocd", "parameters": "(RandomAccessFileInputStream in, int searchBufferLength)", "modifiers": "public static", "return": "long", "signature": "long locateStartOfEocd(RandomAccessFileInputStream in, int searchBufferLength)", "full_signature": "public static long locateStartOfEocd(RandomAccessFileInputStream in, int searchBufferLength)", "class_method_signature": "MinimalZipParser.locateStartOfEocd(RandomAccessFileInputStream in, int searchBufferLength)", "testcase": false, "constructor": false}, {"identifier": "locateStartOfEocd", "parameters": "(byte[] buffer)", "modifiers": "public static", "return": "int", "signature": "int locateStartOfEocd(byte[] buffer)", "full_signature": "public static int locateStartOfEocd(byte[] buffer)", "class_method_signature": "MinimalZipParser.locateStartOfEocd(byte[] buffer)", "testcase": false, "constructor": false}, {"identifier": "parseEocd", "parameters": "(InputStream in)", "modifiers": "public static", "return": "MinimalCentralDirectoryMetadata", "signature": "MinimalCentralDirectoryMetadata parseEocd(InputStream in)", "full_signature": "public static MinimalCentralDirectoryMetadata parseEocd(InputStream in)", "class_method_signature": "MinimalZipParser.parseEocd(InputStream in)", "testcase": false, "constructor": false}], "file": "feya/libraries/archive_diff/diff.generator/src/main/java/com/google/archivepatcher/generator/MinimalZipParser.java"}, "focal_method": {"identifier": "parseLocalEntryAndGetCompressedDataOffset", "parameters": "(InputStream in)", "modifiers": "public static", "return": "long", "body": "public static long parseLocalEntryAndGetCompressedDataOffset(InputStream in) throws IOException {\n    // *** 4 bytes encode the LOCAL_ENTRY_SIGNATURE, verify for sanity\n    // 2 bytes encode the version-needed-to-extract, ignore\n    // 2 bytes encode the general-purpose flags, ignore\n    // 2 bytes encode the compression method, ignore (redundant with central directory)\n    // 2 bytes encode the MSDOS last modified file time, ignore\n    // 2 bytes encode the MSDOS last modified file date, ignore\n    // 4 bytes encode the CRC32 of the uncompressed data, ignore (redundant with central directory)\n    // 4 bytes encode the compressed size, ignore (redundant with central directory)\n    // 4 bytes encode the uncompressed size, ignore (redundant with central directory)\n    // *** 2 bytes encode the length of the file name, needed to skip the bytes later [READ THIS]\n    // *** 2 bytes encode the length of the extras, needed to skip the bytes later [READ THIS]\n    // The rest is the data, which is the main attraction here.\n    if (((int) read32BitUnsigned(in)) != LOCAL_ENTRY_SIGNATURE) {\n      throw new ZipException(\"Bad local entry header\");\n    }\n    int junkLength = 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4;\n    skipOrDie(in, junkLength); // Skip everything up to the length of the file name\n    final int fileNameLength = read16BitUnsigned(in);\n    final int extrasLength = read16BitUnsigned(in);\n\n    // The file name is already known and will match the central directory, so no need to read it.\n    // The extra field length can be different here versus in the central directory and is used for\n    // things like zipaligning APKs. This single value is the critical part as it dictates where the\n    // actual DATA for the entry begins.\n    return 4 + junkLength + 2 + 2 + fileNameLength + extrasLength;\n  }", "signature": "long parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "full_signature": "public static long parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "class_method_signature": "MinimalZipParser.parseLocalEntryAndGetCompressedDataOffset(InputStream in)", "testcase": false, "constructor": false, "invocations": ["read32BitUnsigned", "skipOrDie", "read16BitUnsigned", "read16BitUnsigned"]}, "repository": {"repo_id": 20126854, "url": "https://github.com/kaedea/Feya", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 12, "size": 7798, "license": "licensed"}}