{"test_class": {"identifier": "RuleBasedOptimizerTest", "superclass": "extends AbstractQueryTest", "interfaces": "", "fields": [{"original_string": "private RuleBasedOptimizer optimizer;", "modifier": "private", "type": "RuleBasedOptimizer", "declarator": "optimizer", "var_name": "optimizer"}, {"original_string": "private List<OptimizerRule> rules;", "modifier": "private", "type": "List<OptimizerRule>", "declarator": "rules", "var_name": "rules"}, {"original_string": "private List<Integer> ruleExecutionOrder;", "modifier": "private", "type": "List<Integer>", "declarator": "ruleExecutionOrder", "var_name": "ruleExecutionOrder"}, {"original_string": "private QueryContext context;", "modifier": "private", "type": "QueryContext", "declarator": "context", "var_name": "context"}, {"original_string": "private PlanNode node;", "modifier": "private", "type": "PlanNode", "declarator": "node", "var_name": "node"}, {"original_string": "private boolean print;", "modifier": "private", "type": "boolean", "declarator": "print", "var_name": "print"}, {"original_string": "private boolean multipleSelectors = false;", "modifier": "private", "type": "boolean", "declarator": "multipleSelectors = false", "var_name": "multipleSelectors"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/query/optimize/RuleBasedOptimizerTest.java"}, "test_case": {"identifier": "shouldOptimizePlanForQueryJoiningMultipleTypeViewsUsingNonIdentityEquiJoin", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldOptimizePlanForQueryJoiningMultipleTypeViewsUsingNonIdentityEquiJoin() {\n        node = optimize(\"SELECT type1.a1 AS a, type1.a2 AS b, type2.a3 as c, type2.a4 as d \"\n                        + \"FROM type1 JOIN type2 ON type1.a2 = type2.a3 WHERE CONTAINS(type1.a1,'something')\");\n\n        // Create the expected plan ...\n        PlanNode project = new PlanNode(Type.PROJECT, selector(\"type1\"), selector(\"type2\"));\n        project.setProperty(Property.PROJECT_COLUMNS,\n                            columns(column(\"type1\", \"a1\", \"a\"), column(\"type1\", \"a2\", \"b\"), column(\"type2\", \"a3\", \"c\"),\n                                    column(\"type2\", \"a4\", \"d\")));\n        PlanNode join = new PlanNode(Type.JOIN, project, selector(\"type1\"), selector(\"type2\"));\n        join.setProperty(Property.JOIN_ALGORITHM, JoinAlgorithm.NESTED_LOOP);\n        join.setProperty(Property.JOIN_TYPE, JoinType.INNER);\n        join.setProperty(Property.JOIN_CONDITION, new EquiJoinCondition(selector(\"type1\"), \"a2\", selector(\"type2\"), \"a3\"));\n\n        PlanNode leftAccess = new PlanNode(Type.ACCESS, join, selector(\"type1\"));\n        PlanNode leftProject = new PlanNode(Type.PROJECT, leftAccess, selector(\"type1\"));\n        leftProject.setProperty(Property.PROJECT_COLUMNS, columns(column(\"type1\", \"a1\"), column(\"type1\", \"a2\")));\n        PlanNode leftSelect1 = new PlanNode(Type.SELECT, leftProject, selector(\"type1\"));\n        leftSelect1.setProperty(Property.SELECT_CRITERIA, new FullTextSearch(selector(\"type1\"), \"a1\", \"something\"));\n        PlanNode leftSelect2 = new PlanNode(Type.SELECT, leftSelect1, selector(\"type1\"));\n        leftSelect2.setProperty(Property.SELECT_CRITERIA, new SetCriteria(new PropertyValue(selector(\"type1\"), \"primaryType\"),\n                                                                          new Literal(\"t1\"), new Literal(\"t0\")));\n        PlanNode leftSelect3 = new PlanNode(Type.SELECT, leftSelect2, selector(\"type1\"));\n        leftSelect3.setProperty(Property.SELECT_CRITERIA, new SetCriteria(new PropertyValue(selector(\"type1\"), \"mixins\"),\n                                                                          new Literal(\"t3\"), new Literal(\"t4\")));\n        PlanNode leftSource = new PlanNode(Type.SOURCE, leftSelect3, selector(\"type1\"));\n        leftSource.setProperty(Property.SOURCE_NAME, selector(\"all\"));\n        leftSource.setProperty(Property.SOURCE_ALIAS, selector(\"type1\"));\n        leftSource.setProperty(Property.SOURCE_COLUMNS, context.getSchemata().getTable(selector(\"all\")).getColumns());\n\n        PlanNode rightAccess = new PlanNode(Type.ACCESS, join, selector(\"type2\"));\n        PlanNode rightProject = new PlanNode(Type.PROJECT, rightAccess, selector(\"type2\"));\n        rightProject.setProperty(Property.PROJECT_COLUMNS, columns(column(\"type2\", \"a3\"), column(\"type2\", \"a4\")));\n        PlanNode rightSelect1 = new PlanNode(Type.SELECT, rightProject, selector(\"type2\"));\n        rightSelect1.setProperty(Property.SELECT_CRITERIA, new SetCriteria(new PropertyValue(selector(\"type2\"), \"primaryType\"),\n                                                                           new Literal(\"t2\"), new Literal(\"t0\")));\n        PlanNode rightSelect2 = new PlanNode(Type.SELECT, rightSelect1, selector(\"type2\"));\n        rightSelect2.setProperty(Property.SELECT_CRITERIA, new SetCriteria(new PropertyValue(selector(\"type2\"), \"mixins\"),\n                                                                           new Literal(\"t4\"), new Literal(\"t5\")));\n        PlanNode rightSource = new PlanNode(Type.SOURCE, rightSelect2, selector(\"type2\"));\n        rightSource.setProperty(Property.SOURCE_NAME, selector(\"all\"));\n        rightSource.setProperty(Property.SOURCE_ALIAS, selector(\"type2\"));\n        rightSource.setProperty(Property.SOURCE_COLUMNS, context.getSchemata().getTable(selector(\"all\")).getColumns());\n\n        // Compare the expected and actual plan ...\n        assertPlanMatches(project);\n    }", "signature": "void shouldOptimizePlanForQueryJoiningMultipleTypeViewsUsingNonIdentityEquiJoin()", "full_signature": "@Test public void shouldOptimizePlanForQueryJoiningMultipleTypeViewsUsingNonIdentityEquiJoin()", "class_method_signature": "RuleBasedOptimizerTest.shouldOptimizePlanForQueryJoiningMultipleTypeViewsUsingNonIdentityEquiJoin()", "testcase": true, "constructor": false, "invocations": ["optimize", "selector", "selector", "setProperty", "columns", "column", "column", "column", "column", "selector", "selector", "setProperty", "setProperty", "setProperty", "selector", "selector", "selector", "selector", "setProperty", "columns", "column", "column", "selector", "setProperty", "selector", "selector", "setProperty", "selector", "selector", "setProperty", "selector", "selector", "setProperty", "selector", "setProperty", "selector", "setProperty", "getColumns", "getTable", "getSchemata", "selector", "selector", "selector", "setProperty", "columns", "column", "column", "selector", "setProperty", "selector", "selector", "setProperty", "selector", "selector", "setProperty", "selector", "setProperty", "selector", "setProperty", "getColumns", "getTable", "getSchemata", "selector", "assertPlanMatches"]}, "focal_class": {"identifier": "RuleBasedOptimizer", "superclass": "", "interfaces": "implements Optimizer", "fields": [{"original_string": "private static final Logger LOGGER = Logger.getLogger(RuleBasedOptimizer.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = Logger.getLogger(RuleBasedOptimizer.class)", "var_name": "LOGGER"}], "methods": [{"identifier": "optimize", "parameters": "( QueryContext context,\n                              PlanNode plan )", "modifiers": "@Override public", "return": "PlanNode", "signature": "PlanNode optimize( QueryContext context,\n                              PlanNode plan )", "full_signature": "@Override public PlanNode optimize( QueryContext context,\n                              PlanNode plan )", "class_method_signature": "RuleBasedOptimizer.optimize( QueryContext context,\n                              PlanNode plan )", "testcase": false, "constructor": false}, {"identifier": "populateRuleStack", "parameters": "( LinkedList<OptimizerRule> ruleStack,\n                                      PlanHints hints )", "modifiers": "protected", "return": "void", "signature": "void populateRuleStack( LinkedList<OptimizerRule> ruleStack,\n                                      PlanHints hints )", "full_signature": "protected void populateRuleStack( LinkedList<OptimizerRule> ruleStack,\n                                      PlanHints hints )", "class_method_signature": "RuleBasedOptimizer.populateRuleStack( LinkedList<OptimizerRule> ruleStack,\n                                      PlanHints hints )", "testcase": false, "constructor": false}, {"identifier": "populateIndexingRules", "parameters": "( LinkedList<OptimizerRule> ruleStack,\n                                          PlanHints hints )", "modifiers": "protected", "return": "void", "signature": "void populateIndexingRules( LinkedList<OptimizerRule> ruleStack,\n                                          PlanHints hints )", "full_signature": "protected void populateIndexingRules( LinkedList<OptimizerRule> ruleStack,\n                                          PlanHints hints )", "class_method_signature": "RuleBasedOptimizer.populateIndexingRules( LinkedList<OptimizerRule> ruleStack,\n                                          PlanHints hints )", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/query/optimize/RuleBasedOptimizer.java"}, "focal_method": {"identifier": "optimize", "parameters": "( QueryContext context,\n                              PlanNode plan )", "modifiers": "@Override public", "return": "PlanNode", "body": "@Override\n    public PlanNode optimize( QueryContext context,\n                              PlanNode plan ) {\n        LinkedList<OptimizerRule> rules = new LinkedList<OptimizerRule>();\n        populateRuleStack(rules, context.getHints());\n\n        Problems problems = context.getProblems();\n        while (rules.peek() != null && !problems.hasErrors()) {\n            OptimizerRule nextRule = rules.poll();\n            LOGGER.trace(\"Running query optimizer rule {0}\", nextRule);\n            plan = nextRule.execute(context, plan, rules);\n            LOGGER.trace(\"Plan after running query optimizer rule {0}: \\n{1}\", nextRule, plan);\n        }\n\n        return plan;\n    }", "signature": "PlanNode optimize( QueryContext context,\n                              PlanNode plan )", "full_signature": "@Override public PlanNode optimize( QueryContext context,\n                              PlanNode plan )", "class_method_signature": "RuleBasedOptimizer.optimize( QueryContext context,\n                              PlanNode plan )", "testcase": false, "constructor": false, "invocations": ["populateRuleStack", "getHints", "getProblems", "peek", "hasErrors", "poll", "trace", "execute", "trace"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}