{"test_class": {"identifier": "DecimatorTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "GeometryFactory gf = new GeometryFactory();", "modifier": "", "type": "GeometryFactory", "declarator": "gf = new GeometryFactory()", "var_name": "gf"}, {"original_string": "LiteCoordinateSequenceFactory csf = new LiteCoordinateSequenceFactory();", "modifier": "", "type": "LiteCoordinateSequenceFactory", "declarator": "csf = new LiteCoordinateSequenceFactory()", "var_name": "csf"}, {"original_string": "private MathTransform identity = new AffineTransform2D(new AffineTransform());", "modifier": "private", "type": "MathTransform", "declarator": "identity = new AffineTransform2D(new AffineTransform())", "var_name": "identity"}], "file": "modules/library/main/src/test/java/org/geotools/geometry/jts/DecimatorTest.java"}, "test_case": {"identifier": "testDecimationSpansInfinite", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDecimationSpansInfinite() throws Exception {\n        MathTransform mt = new AbstractMathTransform() {\n            \n            @Override\n            public void transform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts)\n                    throws TransformException {\n                if (srcPts[0] == -0.5 || srcPts[1] == 0.5) {\n                    dstPts[0] = Double.NaN;\n                    dstPts[1] = Double.NaN;\n                    dstPts[2] = Double.NaN;\n                    dstPts[3] = Double.NaN;\n                } else {\n                    dstPts[0] = srcPts[0] * 10;\n                    dstPts[1] = srcPts[1] * 10;\n                    dstPts[2] = srcPts[2] * 10;\n                    dstPts[3] = srcPts[3] * 10;\n                }\n                \n            }\n            \n            @Override\n            public int getTargetDimensions() {\n                return 2;\n            }\n            \n            @Override\n            public int getSourceDimensions() {\n                return 2;\n            }\n        };\n        double[] dx = Decimator.computeGeneralizationDistances(mt, new Rectangle(10, 10), 1);\n        assertEquals(10, dx[0], 0d);\n        assertEquals(10, dx[1], 0d);\n    }", "signature": "void testDecimationSpansInfinite()", "full_signature": "@Test public void testDecimationSpansInfinite()", "class_method_signature": "DecimatorTest.testDecimationSpansInfinite()", "testcase": true, "constructor": false, "invocations": ["computeGeneralizationDistances", "assertEquals", "assertEquals"]}, "focal_class": {"identifier": "Decimator", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = org.geotools.util.logging.Logging.getLogger(Decimator.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = org.geotools.util.logging.Logging.getLogger(Decimator.class)", "var_name": "LOGGER"}, {"original_string": "static final double DP_THRESHOLD;", "modifier": "static final", "type": "double", "declarator": "DP_THRESHOLD", "var_name": "DP_THRESHOLD"}, {"original_string": "private static final double EPS = 1e-9;", "modifier": "private static final", "type": "double", "declarator": "EPS = 1e-9", "var_name": "EPS"}, {"original_string": "private double spanx = -1;", "modifier": "private", "type": "double", "declarator": "spanx = -1", "var_name": "spanx"}, {"original_string": "private double spany = -1;", "modifier": "private", "type": "double", "declarator": "spany = -1", "var_name": "spany"}], "methods": [{"identifier": "Decimator", "parameters": "(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "modifiers": "public", "return": "", "signature": " Decimator(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "full_signature": "public  Decimator(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "class_method_signature": "Decimator.Decimator(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "testcase": false, "constructor": true}, {"identifier": "getSpanX", "parameters": "()", "modifiers": "public", "return": "double", "signature": "double getSpanX()", "full_signature": "public double getSpanX()", "class_method_signature": "Decimator.getSpanX()", "testcase": false, "constructor": false}, {"identifier": "getSpanY", "parameters": "()", "modifiers": "public", "return": "double", "signature": "double getSpanY()", "full_signature": "public double getSpanY()", "class_method_signature": "Decimator.getSpanY()", "testcase": false, "constructor": false}, {"identifier": "Decimator", "parameters": "(MathTransform screenToWorld, Rectangle paintArea)", "modifiers": "public", "return": "", "signature": " Decimator(MathTransform screenToWorld, Rectangle paintArea)", "full_signature": "public  Decimator(MathTransform screenToWorld, Rectangle paintArea)", "class_method_signature": "Decimator.Decimator(MathTransform screenToWorld, Rectangle paintArea)", "testcase": false, "constructor": true}, {"identifier": "computeGeneralizationDistances", "parameters": "(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "modifiers": "public static", "return": "double[]", "signature": "double[] computeGeneralizationDistances(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "full_signature": "public static double[] computeGeneralizationDistances(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "class_method_signature": "Decimator.computeGeneralizationDistances(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "testcase": false, "constructor": false}, {"identifier": "isFinite", "parameters": "(double d)", "modifiers": "private static", "return": "boolean", "signature": "boolean isFinite(double d)", "full_signature": "private static boolean isFinite(double d)", "class_method_signature": "Decimator.isFinite(double d)", "testcase": false, "constructor": false}, {"identifier": "getGeneralizationSpans", "parameters": "(double x, double y, MathTransform transform)", "modifiers": "static", "return": "double[]", "signature": "double[] getGeneralizationSpans(double x, double y, MathTransform transform)", "full_signature": "static double[] getGeneralizationSpans(double x, double y, MathTransform transform)", "class_method_signature": "Decimator.getGeneralizationSpans(double x, double y, MathTransform transform)", "testcase": false, "constructor": false}, {"identifier": "Decimator", "parameters": "(MathTransform screenToWorld)", "modifiers": "public", "return": "", "signature": " Decimator(MathTransform screenToWorld)", "full_signature": "public  Decimator(MathTransform screenToWorld)", "class_method_signature": "Decimator.Decimator(MathTransform screenToWorld)", "testcase": false, "constructor": true}, {"identifier": "Decimator", "parameters": "(double spanx, double spany)", "modifiers": "public", "return": "", "signature": " Decimator(double spanx, double spany)", "full_signature": "public  Decimator(double spanx, double spany)", "class_method_signature": "Decimator.Decimator(double spanx, double spany)", "testcase": false, "constructor": true}, {"identifier": "decimateTransformGeneralize", "parameters": "(Geometry geometry,\n\t\t\tMathTransform transform)", "modifiers": "public final", "return": "Geometry", "signature": "Geometry decimateTransformGeneralize(Geometry geometry,\n\t\t\tMathTransform transform)", "full_signature": "public final Geometry decimateTransformGeneralize(Geometry geometry,\n\t\t\tMathTransform transform)", "class_method_signature": "Decimator.decimateTransformGeneralize(Geometry geometry,\n\t\t\tMathTransform transform)", "testcase": false, "constructor": false}, {"identifier": "accumulateGeometryType", "parameters": "(Class elementType, Geometry generalized)", "modifiers": "private", "return": "Class", "signature": "Class accumulateGeometryType(Class elementType, Geometry generalized)", "full_signature": "private Class accumulateGeometryType(Class elementType, Geometry generalized)", "class_method_signature": "Decimator.accumulateGeometryType(Class elementType, Geometry generalized)", "testcase": false, "constructor": false}, {"identifier": "decimate", "parameters": "(Geometry geom)", "modifiers": "public final", "return": "void", "signature": "void decimate(Geometry geom)", "full_signature": "public final void decimate(Geometry geom)", "class_method_signature": "Decimator.decimate(Geometry geom)", "testcase": false, "constructor": false}, {"identifier": "decimateOnEnvelope", "parameters": "(Geometry geom, LiteCoordinateSequence seq)", "modifiers": "private", "return": "boolean", "signature": "boolean decimateOnEnvelope(Geometry geom, LiteCoordinateSequence seq)", "full_signature": "private boolean decimateOnEnvelope(Geometry geom, LiteCoordinateSequence seq)", "class_method_signature": "Decimator.decimateOnEnvelope(Geometry geom, LiteCoordinateSequence seq)", "testcase": false, "constructor": false}, {"identifier": "decimateRingFully", "parameters": "(LiteCoordinateSequence seq)", "modifiers": "private", "return": "void", "signature": "void decimateRingFully(LiteCoordinateSequence seq)", "full_signature": "private void decimateRingFully(LiteCoordinateSequence seq)", "class_method_signature": "Decimator.decimateRingFully(LiteCoordinateSequence seq)", "testcase": false, "constructor": false}, {"identifier": "decimateTransformGeneralize", "parameters": "(LiteCoordinateSequence seq,\n            MathTransform transform, boolean ring, double spanx, double spany)", "modifiers": "private final", "return": "void", "signature": "void decimateTransformGeneralize(LiteCoordinateSequence seq,\n            MathTransform transform, boolean ring, double spanx, double spany)", "full_signature": "private final void decimateTransformGeneralize(LiteCoordinateSequence seq,\n            MathTransform transform, boolean ring, double spanx, double spany)", "class_method_signature": "Decimator.decimateTransformGeneralize(LiteCoordinateSequence seq,\n            MathTransform transform, boolean ring, double spanx, double spany)", "testcase": false, "constructor": false}, {"identifier": "spanBasedGeneralize", "parameters": "(int ncoords, double[] coords, double spanx, double spany)", "modifiers": "private", "return": "int", "signature": "int spanBasedGeneralize(int ncoords, double[] coords, double spanx, double spany)", "full_signature": "private int spanBasedGeneralize(int ncoords, double[] coords, double spanx, double spany)", "class_method_signature": "Decimator.spanBasedGeneralize(int ncoords, double[] coords, double spanx, double spany)", "testcase": false, "constructor": false}, {"identifier": "dpBasedGeneralize", "parameters": "(int ncoords, double[] coords, double maxDistance)", "modifiers": "private", "return": "int", "signature": "int dpBasedGeneralize(int ncoords, double[] coords, double maxDistance)", "full_signature": "private int dpBasedGeneralize(int ncoords, double[] coords, double maxDistance)", "class_method_signature": "Decimator.dpBasedGeneralize(int ncoords, double[] coords, double maxDistance)", "testcase": false, "constructor": false}, {"identifier": "dpSimplifySection", "parameters": "(int first, int last, double[] coords, double maxDistanceSquared)", "modifiers": "private", "return": "void", "signature": "void dpSimplifySection(int first, int last, double[] coords, double maxDistanceSquared)", "full_signature": "private void dpSimplifySection(int first, int last, double[] coords, double maxDistanceSquared)", "class_method_signature": "Decimator.dpSimplifySection(int first, int last, double[] coords, double maxDistanceSquared)", "testcase": false, "constructor": false}, {"identifier": "decimate", "parameters": "(Geometry g, LiteCoordinateSequence seq)", "modifiers": "private", "return": "void", "signature": "void decimate(Geometry g, LiteCoordinateSequence seq)", "full_signature": "private void decimate(Geometry g, LiteCoordinateSequence seq)", "class_method_signature": "Decimator.decimate(Geometry g, LiteCoordinateSequence seq)", "testcase": false, "constructor": false}, {"identifier": "copyCoordinate", "parameters": "(double[] coords, int dimension, int readDoubles,\n\t\t\tint currentDoubles)", "modifiers": "private", "return": "int", "signature": "int copyCoordinate(double[] coords, int dimension, int readDoubles,\n\t\t\tint currentDoubles)", "full_signature": "private int copyCoordinate(double[] coords, int dimension, int readDoubles,\n\t\t\tint currentDoubles)", "class_method_signature": "Decimator.copyCoordinate(double[] coords, int dimension, int readDoubles,\n\t\t\tint currentDoubles)", "testcase": false, "constructor": false}], "file": "modules/library/main/src/main/java/org/geotools/geometry/jts/Decimator.java"}, "focal_method": {"identifier": "computeGeneralizationDistances", "parameters": "(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "modifiers": "public static", "return": "double[]", "body": "public static double[] computeGeneralizationDistances(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)\n            throws TransformException {\n        try {\n            // init the spans with the upper left corner\n            double[] spans = getGeneralizationSpans(paintArea.x, paintArea.y, screenToWorld);\n            // search over a simple 3x3 grid for higher spans so that we perform a basic sampling of the whole area\n            // and we pick the shortest generalization distances\n            for(int i = 0; i < 2; i++) {\n                for(int j = 0; j < 2; j++) {\n                    double[] ns = getGeneralizationSpans(paintArea.x + paintArea.width * i / 2.0, \n                            paintArea.y + paintArea.height / 2.0, screenToWorld);\n                    if (isFinite(ns[0]) && (ns[0] < spans[0] || !isFinite(spans[0]))) {\n                        spans[0] = ns[0];\n                    }\n                    if (isFinite(ns[1]) && (ns[1] < spans[1] || !isFinite(spans[1]))) {\n                        spans[1] = ns[1];\n                    }\n                }\n            }\n            if (!isFinite(spans[0])) {\n                spans[0] = 0;\n            }\n            if (!isFinite(spans[1])) {\n                spans[1] = 0;\n            }\n            spans[0] *= pixelDistance;\n            spans[1] *= pixelDistance ;\n            return spans;\n        } catch(TransformException e) {\n            // if we can't transform we went way out of the area of definition for the transform -> don't generalize\n            return new double[] {0, 0};\n        }\n    }", "signature": "double[] computeGeneralizationDistances(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "full_signature": "public static double[] computeGeneralizationDistances(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "class_method_signature": "Decimator.computeGeneralizationDistances(MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)", "testcase": false, "constructor": false, "invocations": ["getGeneralizationSpans", "getGeneralizationSpans", "isFinite", "isFinite", "isFinite", "isFinite", "isFinite", "isFinite"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}