{"test_class": {"identifier": "TokenFilterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private TokenFilter tokenFilter = new TokenFilter();", "modifier": "private", "type": "TokenFilter", "declarator": "tokenFilter = new TokenFilter()", "var_name": "tokenFilter"}], "file": "dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/TokenFilterTest.java"}, "test_case": {"identifier": "testInvokeWithWrongToken", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testInvokeWithWrongToken() throws Exception {\n        Assertions.assertThrows(RpcException.class, () -> {\n            String token = \"token\";\n\n            Invoker invoker = Mockito.mock(Invoker.class);\n            URL url = URL.valueOf(\"test://test:11/test?accesslog=true&group=dubbo&version=1.1&token=\" + token);\n            when(invoker.getUrl()).thenReturn(url);\n            when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(\"result\"));\n\n            Map<String, Object> attachments = new HashMap<>();\n            attachments.put(TOKEN_KEY, \"wrongToken\");\n            Invocation invocation = Mockito.mock(Invocation.class);\n            when(invocation.getObjectAttachments()).thenReturn(attachments);\n\n            tokenFilter.invoke(invoker, invocation);\n        });\n    }", "signature": "void testInvokeWithWrongToken()", "full_signature": "@Test public void testInvokeWithWrongToken()", "class_method_signature": "TokenFilterTest.testInvokeWithWrongToken()", "testcase": true, "constructor": false, "invocations": ["assertThrows", "mock", "valueOf", "thenReturn", "when", "getUrl", "thenReturn", "when", "invoke", "any", "put", "mock", "thenReturn", "when", "getObjectAttachments", "invoke"]}, "focal_class": {"identifier": "TokenFilter", "superclass": "", "interfaces": "implements Filter", "fields": [], "methods": [{"identifier": "invoke", "parameters": "(Invoker<?> invoker, Invocation inv)", "modifiers": "@Override public", "return": "Result", "signature": "Result invoke(Invoker<?> invoker, Invocation inv)", "full_signature": "@Override public Result invoke(Invoker<?> invoker, Invocation inv)", "class_method_signature": "TokenFilter.invoke(Invoker<?> invoker, Invocation inv)", "testcase": false, "constructor": false}], "file": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TokenFilter.java"}, "focal_method": {"identifier": "invoke", "parameters": "(Invoker<?> invoker, Invocation inv)", "modifiers": "@Override public", "return": "Result", "body": "@Override\n    public Result invoke(Invoker<?> invoker, Invocation inv)\n            throws RpcException {\n        String token = invoker.getUrl().getParameter(TOKEN_KEY);\n        if (ConfigUtils.isNotEmpty(token)) {\n            Class<?> serviceType = invoker.getInterface();\n            Map<String, Object> attachments = inv.getObjectAttachments();\n            String remoteToken = (attachments == null ? null : (String) attachments.get(TOKEN_KEY));\n            if (!token.equals(remoteToken)) {\n                throw new RpcException(\"Invalid token! Forbid invoke remote service \" + serviceType + \" method \" + inv.getMethodName() + \"() from consumer \" + RpcContext.getContext().getRemoteHost() + \" to provider \" + RpcContext.getContext().getLocalHost());\n            }\n        }\n        return invoker.invoke(inv);\n    }", "signature": "Result invoke(Invoker<?> invoker, Invocation inv)", "full_signature": "@Override public Result invoke(Invoker<?> invoker, Invocation inv)", "class_method_signature": "TokenFilter.invoke(Invoker<?> invoker, Invocation inv)", "testcase": false, "constructor": false, "invocations": ["getParameter", "getUrl", "isNotEmpty", "getInterface", "getObjectAttachments", "get", "equals", "getMethodName", "getRemoteHost", "getContext", "getLocalHost", "getContext", "invoke"]}, "repository": {"repo_id": 4710920, "url": "https://github.com/apache/dubbo", "stars": 30960, "created": "6/19/2012 7:56:02 AM +00:00", "updates": "2020-01-27T14:21:03+00:00", "fork": "False", "license": "licensed"}}