{"test_class": {"identifier": "QuerySensorSchedulerActionTest", "superclass": "extends PluginsLoadingTestBase", "interfaces": "", "fields": [{"original_string": "private IQueryExecutor queryExecutorMock;", "modifier": "private", "type": "IQueryExecutor", "declarator": "queryExecutorMock", "var_name": "queryExecutorMock"}, {"original_string": "private ISchedulerEntry schedulerEntryMock;", "modifier": "private", "type": "ISchedulerEntry", "declarator": "schedulerEntryMock", "var_name": "schedulerEntryMock"}, {"original_string": "private IMessageBusHandler messageBusHandlerMock;", "modifier": "private", "type": "IMessageBusHandler", "declarator": "messageBusHandlerMock", "var_name": "messageBusHandlerMock"}], "file": "CoreFeatures/Statistics/ScheduledQuerySensor/src/test/java/info/smart_tools/smartactors/statistics/sensors/scheduled_query_sensor/QuerySensorSchedulerActionTest.java"}, "test_case": {"identifier": "Should_executeQueryAndSendData", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void Should_executeQueryAndSendData()\n            throws Exception {\n        Collection dataMock = mock(Collection.class);\n        when(queryExecutorMock.execute(same(schedulerEntryMock))).thenReturn(dataMock).thenThrow(QueryExecutionException.class);\n\n        IObject state = IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.iobject.IObject\"),\n                (\"{\" +\n                        \"'queryExecutor':'that query executor',\" +\n                        \"'statisticsChain':'the_statistics_chain'\" +\n                        \"}\").replace('\\'','\"'));\n        when(schedulerEntryMock.getState()).thenReturn(state);\n        when(schedulerEntryMock.getLastTime()).thenReturn(100600L);\n\n        new QuerySensorSchedulerAction().execute(schedulerEntryMock);\n\n        ArgumentCaptor<IObject> messageCaptor = ArgumentCaptor.forClass(IObject.class);\n        verify(messageBusHandlerMock).handle(messageCaptor.capture(), eq(\"the_statistics_chain__0\"));\n\n        assertSame(dataMock, messageCaptor.getValue().getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"), \"data\")));\n        assertEquals(100600L, messageCaptor.getValue().getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"),\n                \"periodStart\")));\n        assertEquals(100600L, messageCaptor.getValue().getValue(IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\"),\n                \"periodEnd\")));\n    }", "signature": "void Should_executeQueryAndSendData()", "full_signature": "@Test public void Should_executeQueryAndSendData()", "class_method_signature": "QuerySensorSchedulerActionTest.Should_executeQueryAndSendData()", "testcase": true, "constructor": false, "invocations": ["mock", "thenThrow", "thenReturn", "when", "execute", "same", "resolve", "getOrAdd", "replace", "thenReturn", "when", "getState", "thenReturn", "when", "getLastTime", "execute", "forClass", "handle", "verify", "capture", "eq", "assertSame", "getValue", "getValue", "resolve", "getOrAdd", "assertEquals", "getValue", "getValue", "resolve", "getOrAdd", "assertEquals", "getValue", "getValue", "resolve", "getOrAdd"]}, "focal_class": {"identifier": "QuerySensorSchedulerAction", "superclass": "", "interfaces": "implements ISchedulerAction", "fields": [{"original_string": "private final IFieldName queryExecutorFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "queryExecutorFieldName", "var_name": "queryExecutorFieldName"}, {"original_string": "private final IFieldName statisticsChainFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "statisticsChainFieldName", "var_name": "statisticsChainFieldName"}, {"original_string": "private final IFieldName dataFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "dataFieldName", "var_name": "dataFieldName"}, {"original_string": "private final IFieldName periodStartFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "periodStartFieldName", "var_name": "periodStartFieldName"}, {"original_string": "private final IFieldName periodEndFieldName;", "modifier": "private final", "type": "IFieldName", "declarator": "periodEndFieldName", "var_name": "periodEndFieldName"}], "methods": [{"identifier": "QuerySensorSchedulerAction", "parameters": "()", "modifiers": "public", "return": "", "signature": " QuerySensorSchedulerAction()", "full_signature": "public  QuerySensorSchedulerAction()", "class_method_signature": "QuerySensorSchedulerAction.QuerySensorSchedulerAction()", "testcase": false, "constructor": true}, {"identifier": "init", "parameters": "(final ISchedulerEntry entry, final IObject args)", "modifiers": "@Override public", "return": "void", "signature": "void init(final ISchedulerEntry entry, final IObject args)", "full_signature": "@Override public void init(final ISchedulerEntry entry, final IObject args)", "class_method_signature": "QuerySensorSchedulerAction.init(final ISchedulerEntry entry, final IObject args)", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "(final ISchedulerEntry entry)", "modifiers": "@Override public", "return": "void", "signature": "void execute(final ISchedulerEntry entry)", "full_signature": "@Override public void execute(final ISchedulerEntry entry)", "class_method_signature": "QuerySensorSchedulerAction.execute(final ISchedulerEntry entry)", "testcase": false, "constructor": false}], "file": "CoreFeatures/Statistics/ScheduledQuerySensor/src/main/java/info/smart_tools/smartactors/statistics/sensors/scheduled_query_sensor/QuerySensorSchedulerAction.java"}, "focal_method": {"identifier": "execute", "parameters": "(final ISchedulerEntry entry)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void execute(final ISchedulerEntry entry) throws SchedulerActionExecutionException {\n        try {\n            Object queryExecutorDependency = entry.getState().getValue(queryExecutorFieldName);\n            IQueryExecutor queryExecutor = IOC.resolve(IOC.resolve(IOC.getKeyForKeyStorage(), queryExecutorDependency));\n\n            Collection<? extends Number> data = queryExecutor.execute(entry);\n            Long time = entry.getLastTime();\n\n            IObject message = IOC.resolve(Keys.getOrAdd(\"info.smart_tools.smartactors.iobject.iobject.IObject\"));\n            message.setValue(dataFieldName, data);\n            message.setValue(periodStartFieldName, time);\n            message.setValue(periodEndFieldName, time);\n\n            Object chainId = IOC.resolve(Keys.getOrAdd(\"chain_id_from_map_name\"), entry.getState().getValue(statisticsChainFieldName));\n            MessageBus.send(message, chainId);\n        } catch (ReadValueException | InvalidArgumentException | QueryExecutionException | ResolutionException | ChangeValueException\n                | SendingMessageException e) {\n            throw new SchedulerActionExecutionException(\"Error occurred querying or sending statistics.\", e);\n        }\n    }", "signature": "void execute(final ISchedulerEntry entry)", "full_signature": "@Override public void execute(final ISchedulerEntry entry)", "class_method_signature": "QuerySensorSchedulerAction.execute(final ISchedulerEntry entry)", "testcase": false, "constructor": false, "invocations": ["getValue", "getState", "resolve", "resolve", "getKeyForKeyStorage", "execute", "getLastTime", "resolve", "getOrAdd", "setValue", "setValue", "setValue", "resolve", "getOrAdd", "getValue", "getState", "send"]}, "repository": {"repo_id": 52972024, "url": "https://github.com/SmartTools/smartactors-core", "language": "Java", "is_fork": false, "fork_count": 7, "stargazer_count": 17, "size": 58816, "license": "licensed"}}