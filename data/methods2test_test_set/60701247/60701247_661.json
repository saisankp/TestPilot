{"test_class": {"identifier": "HeapDumpInstanceObjectTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String MOCK_CLASS = \"MockClass\";", "modifier": "private static final", "type": "String", "declarator": "MOCK_CLASS = \"MockClass\"", "var_name": "MOCK_CLASS"}, {"original_string": "@Rule public final FakeGrpcChannel myGrpcChannel = new FakeGrpcChannel(\"MemoryNavigationTestGrpc\", new FakeMemoryService());", "modifier": "@Rule public final", "type": "FakeGrpcChannel", "declarator": "myGrpcChannel = new FakeGrpcChannel(\"MemoryNavigationTestGrpc\", new FakeMemoryService())", "var_name": "myGrpcChannel"}, {"original_string": "private FakeHeapDumpCaptureObject myCaptureObject;", "modifier": "private", "type": "FakeHeapDumpCaptureObject", "declarator": "myCaptureObject", "var_name": "myCaptureObject"}], "file": "profilers/testSrc/com/android/tools/profilers/memory/adapters/HeapDumpInstanceObjectTest.java"}, "test_case": {"identifier": "testExtractReferences", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testExtractReferences() throws Exception {\n    MockClassInstance mockInstance = new MockClassInstance(-1, 0, MOCK_CLASS);\n\n    // Set up valid/invalid reference case\n    MockClassInstance hardInstanceRef = new MockClassInstance(-1, 3, MOCK_CLASS);\n    hardInstanceRef.addFieldValue(Type.OBJECT, \"hardInstanceRef\", mockInstance);\n    hardInstanceRef.addFieldValue(Type.OBJECT, \"invalidRef\", new Object());\n\n    // Set up multiple case\n    MockArrayInstance hardArrayRef = new MockArrayInstance(-1, Type.OBJECT, 3, 2);\n    hardArrayRef.setValue(0, new Object());\n    hardArrayRef.setValue(1, mockInstance);\n    hardArrayRef.setValue(2, mockInstance);\n\n    // Set up different type case\n    MockClassObj hardClassRef = new MockClassObj(-1, \"hardClassRef\", 1);\n    hardClassRef.addStaticField(Type.OBJECT, \"staticClassRef\", mockInstance);\n    hardClassRef.addStaticField(Type.BOOLEAN, \"invalidBoolRef\", false);\n\n    // Set up soft references appear at end\n    MockClassInstance softInstanceRef = new MockClassInstance(-1, 0, MOCK_CLASS);\n    softInstanceRef.addFieldValue(Type.OBJECT, \"softInstanceRef\", mockInstance);\n    softInstanceRef.addFieldValue(Type.OBJECT, \"invalidRef\", new Object());\n\n    mockInstance.addHardReference(hardInstanceRef);\n    mockInstance.addHardReference(hardArrayRef);\n    mockInstance.addHardReference(hardClassRef);\n    mockInstance.addSoftReferences(softInstanceRef);\n\n    ClassDb.ClassEntry mockClassEntry = myCaptureObject.getClassDb().registerClass(0, MOCK_CLASS);\n    myCaptureObject.addInstance(hardInstanceRef, new HeapDumpInstanceObject(\n      myCaptureObject, hardInstanceRef, mockClassEntry, OBJECT));\n    myCaptureObject.addInstance(hardArrayRef, new HeapDumpInstanceObject(\n      myCaptureObject, hardArrayRef, mockClassEntry, ARRAY));\n    myCaptureObject.addInstance(hardClassRef, new HeapDumpInstanceObject(\n      myCaptureObject, hardClassRef, mockClassEntry, CLASS));\n    myCaptureObject.addInstance(softInstanceRef, new HeapDumpInstanceObject(\n      myCaptureObject, softInstanceRef, mockClassEntry, OBJECT));\n    myCaptureObject.addInstance(mockInstance, new HeapDumpInstanceObject(\n      myCaptureObject, mockInstance, mockClassEntry, OBJECT));\n\n    // extractReference is expected to return a list of sorted hard references first\n    // then sorted soft references.\n    List<ReferenceObject> referrers = myCaptureObject.getInstance(mockInstance).extractReferences();\n    assertEquals(4, referrers.size());\n    // The first object should refer to the hardClassRef which has the shortest distance to root.\n    List<String> refs = referrers.get(0).getReferenceFieldNames();\n    assertEquals(1, refs.size());\n    assertEquals(\"staticClassRef\", refs.get(0));\n    // The second object should refer to hardArrayRef with two indices references\n    refs = referrers.get(1).getReferenceFieldNames();\n    assertEquals(2, refs.size());\n    assertEquals(\"1\", refs.get(0));\n    assertEquals(\"2\", refs.get(1));\n    // The third object should refer to hardInstanceRef\n    refs = referrers.get(2).getReferenceFieldNames();\n    assertEquals(1, refs.size());\n    assertEquals(\"hardInstanceRef\", refs.get(0));\n    // The fourth object should refer to softInstanceRef\n    refs = referrers.get(3).getReferenceFieldNames();\n    assertEquals(1, refs.size());\n    assertEquals(\"softInstanceRef\", refs.get(0));\n  }", "signature": "void testExtractReferences()", "full_signature": "@Test public void testExtractReferences()", "class_method_signature": "HeapDumpInstanceObjectTest.testExtractReferences()", "testcase": true, "constructor": false, "invocations": ["addFieldValue", "addFieldValue", "setValue", "setValue", "setValue", "addStaticField", "addStaticField", "addFieldValue", "addFieldValue", "addHardReference", "addHardReference", "addHardReference", "addSoftReferences", "registerClass", "getClassDb", "addInstance", "addInstance", "addInstance", "addInstance", "addInstance", "extractReferences", "getInstance", "assertEquals", "size", "getReferenceFieldNames", "get", "assertEquals", "size", "assertEquals", "get", "getReferenceFieldNames", "get", "assertEquals", "size", "assertEquals", "get", "assertEquals", "get", "getReferenceFieldNames", "get", "assertEquals", "size", "assertEquals", "get", "getReferenceFieldNames", "get", "assertEquals", "size", "assertEquals", "get"]}, "focal_class": {"identifier": "HeapDumpInstanceObject", "superclass": "", "interfaces": "implements InstanceObject", "fields": [{"original_string": "private static final String NAME_FORMATTER = \"%s@%d (0x%x)\";", "modifier": "private static final", "type": "String", "declarator": "NAME_FORMATTER = \"%s@%d (0x%x)\"", "var_name": "NAME_FORMATTER"}, {"original_string": "private static final int MAX_VALUE_TEXT_LENGTH = 1024;", "modifier": "private static final", "type": "int", "declarator": "MAX_VALUE_TEXT_LENGTH = 1024", "var_name": "MAX_VALUE_TEXT_LENGTH"}, {"original_string": "private static final Comparator<Instance> DEPTH_COMPARATOR = Comparator.comparingInt(Instance::getDistanceToGcRoot);", "modifier": "private static final", "type": "Comparator<Instance>", "declarator": "DEPTH_COMPARATOR = Comparator.comparingInt(Instance::getDistanceToGcRoot)", "var_name": "DEPTH_COMPARATOR"}, {"original_string": "private static final String INVALID_STRING_VALUE = \" ...<invalid string value>...\";", "modifier": "private static final", "type": "String", "declarator": "INVALID_STRING_VALUE = \" ...<invalid string value>...\"", "var_name": "INVALID_STRING_VALUE"}, {"original_string": "private static final Map<Type, ValueType> VALUE_TYPE_MAP = ImmutableMap.<Type, ValueObject.ValueType>builder()\n    .put(Type.BOOLEAN, BOOLEAN)\n    .put(Type.BYTE, BYTE)\n    .put(Type.CHAR, CHAR)\n    .put(Type.SHORT, SHORT)\n    .put(Type.INT, INT)\n    .put(Type.LONG, LONG)\n    .put(Type.FLOAT, FLOAT)\n    .put(Type.DOUBLE, DOUBLE)\n    .put(Type.OBJECT, OBJECT)\n    .build();", "modifier": "private static final", "type": "Map<Type, ValueType>", "declarator": "VALUE_TYPE_MAP = ImmutableMap.<Type, ValueObject.ValueType>builder()\n    .put(Type.BOOLEAN, BOOLEAN)\n    .put(Type.BYTE, BYTE)\n    .put(Type.CHAR, CHAR)\n    .put(Type.SHORT, SHORT)\n    .put(Type.INT, INT)\n    .put(Type.LONG, LONG)\n    .put(Type.FLOAT, FLOAT)\n    .put(Type.DOUBLE, DOUBLE)\n    .put(Type.OBJECT, OBJECT)\n    .build()", "var_name": "VALUE_TYPE_MAP"}, {"original_string": "@NotNull protected ValueType myValueType;", "modifier": "@NotNull protected", "type": "ValueType", "declarator": "myValueType", "var_name": "myValueType"}, {"original_string": "@NotNull private final HeapDumpCaptureObject myCaptureObject;", "modifier": "@NotNull private final", "type": "HeapDumpCaptureObject", "declarator": "myCaptureObject", "var_name": "myCaptureObject"}, {"original_string": "@NotNull private final Instance myInstance;", "modifier": "@NotNull private final", "type": "Instance", "declarator": "myInstance", "var_name": "myInstance"}, {"original_string": "@NotNull private final ClassDb.ClassEntry myClassEntry;", "modifier": "@NotNull private final", "type": "ClassDb.ClassEntry", "declarator": "myClassEntry", "var_name": "myClassEntry"}, {"original_string": "@NotNull private final String myMemoizedLabel;", "modifier": "@NotNull private final", "type": "String", "declarator": "myMemoizedLabel", "var_name": "myMemoizedLabel"}], "methods": [{"identifier": "HeapDumpInstanceObject", "parameters": "(@NotNull HeapDumpCaptureObject captureObject,\n                         @NotNull Instance instance,\n                         @NotNull ClassDb.ClassEntry classEntry,\n                         @Nullable ValueType precomputedValueType)", "modifiers": "", "return": "", "signature": " HeapDumpInstanceObject(@NotNull HeapDumpCaptureObject captureObject,\n                         @NotNull Instance instance,\n                         @NotNull ClassDb.ClassEntry classEntry,\n                         @Nullable ValueType precomputedValueType)", "full_signature": "  HeapDumpInstanceObject(@NotNull HeapDumpCaptureObject captureObject,\n                         @NotNull Instance instance,\n                         @NotNull ClassDb.ClassEntry classEntry,\n                         @Nullable ValueType precomputedValueType)", "class_method_signature": "HeapDumpInstanceObject.HeapDumpInstanceObject(@NotNull HeapDumpCaptureObject captureObject,\n                         @NotNull Instance instance,\n                         @NotNull ClassDb.ClassEntry classEntry,\n                         @Nullable ValueType precomputedValueType)", "testcase": false, "constructor": true}, {"identifier": "equals", "parameters": "(Object obj)", "modifiers": "@Override public", "return": "boolean", "signature": "boolean equals(Object obj)", "full_signature": "@Override public boolean equals(Object obj)", "class_method_signature": "HeapDumpInstanceObject.equals(Object obj)", "testcase": false, "constructor": false}, {"identifier": "hashCode", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int hashCode()", "full_signature": "@Override public int hashCode()", "class_method_signature": "HeapDumpInstanceObject.hashCode()", "testcase": false, "constructor": false}, {"identifier": "getName", "parameters": "()", "modifiers": "@NotNull @Override public", "return": "String", "signature": "String getName()", "full_signature": "@NotNull @Override public String getName()", "class_method_signature": "HeapDumpInstanceObject.getName()", "testcase": false, "constructor": false}, {"identifier": "getValueText", "parameters": "()", "modifiers": "@NotNull @Override public", "return": "String", "signature": "String getValueText()", "full_signature": "@NotNull @Override public String getValueText()", "class_method_signature": "HeapDumpInstanceObject.getValueText()", "testcase": false, "constructor": false}, {"identifier": "getToStringText", "parameters": "()", "modifiers": "@NotNull @Override public", "return": "String", "signature": "String getToStringText()", "full_signature": "@NotNull @Override public String getToStringText()", "class_method_signature": "HeapDumpInstanceObject.getToStringText()", "testcase": false, "constructor": false}, {"identifier": "getHeapId", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getHeapId()", "full_signature": "@Override public int getHeapId()", "class_method_signature": "HeapDumpInstanceObject.getHeapId()", "testcase": false, "constructor": false}, {"identifier": "getClassEntry", "parameters": "()", "modifiers": "@NotNull @Override public", "return": "ClassDb.ClassEntry", "signature": "ClassDb.ClassEntry getClassEntry()", "full_signature": "@NotNull @Override public ClassDb.ClassEntry getClassEntry()", "class_method_signature": "HeapDumpInstanceObject.getClassEntry()", "testcase": false, "constructor": false}, {"identifier": "getDepth", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getDepth()", "full_signature": "@Override public int getDepth()", "class_method_signature": "HeapDumpInstanceObject.getDepth()", "testcase": false, "constructor": false}, {"identifier": "getNativeSize", "parameters": "()", "modifiers": "@Override public", "return": "long", "signature": "long getNativeSize()", "full_signature": "@Override public long getNativeSize()", "class_method_signature": "HeapDumpInstanceObject.getNativeSize()", "testcase": false, "constructor": false}, {"identifier": "getShallowSize", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getShallowSize()", "full_signature": "@Override public int getShallowSize()", "class_method_signature": "HeapDumpInstanceObject.getShallowSize()", "testcase": false, "constructor": false}, {"identifier": "getRetainedSize", "parameters": "()", "modifiers": "@Override public", "return": "long", "signature": "long getRetainedSize()", "full_signature": "@Override public long getRetainedSize()", "class_method_signature": "HeapDumpInstanceObject.getRetainedSize()", "testcase": false, "constructor": false}, {"identifier": "getFieldCount", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getFieldCount()", "full_signature": "@Override public int getFieldCount()", "class_method_signature": "HeapDumpInstanceObject.getFieldCount()", "testcase": false, "constructor": false}, {"identifier": "getFields", "parameters": "()", "modifiers": "@NotNull @Override public", "return": "List<FieldObject>", "signature": "List<FieldObject> getFields()", "full_signature": "@NotNull @Override public List<FieldObject> getFields()", "class_method_signature": "HeapDumpInstanceObject.getFields()", "testcase": false, "constructor": false}, {"identifier": "getArrayObject", "parameters": "()", "modifiers": "@Nullable @Override public", "return": "ArrayObject", "signature": "ArrayObject getArrayObject()", "full_signature": "@Nullable @Override public ArrayObject getArrayObject()", "class_method_signature": "HeapDumpInstanceObject.getArrayObject()", "testcase": false, "constructor": false}, {"identifier": "getValueType", "parameters": "()", "modifiers": "@Override @NotNull public", "return": "ValueType", "signature": "ValueType getValueType()", "full_signature": "@Override @NotNull public ValueType getValueType()", "class_method_signature": "HeapDumpInstanceObject.getValueType()", "testcase": false, "constructor": false}, {"identifier": "getAllocationCallStack", "parameters": "()", "modifiers": "@Nullable @Override public", "return": "AllocationStack", "signature": "AllocationStack getAllocationCallStack()", "full_signature": "@Nullable @Override public AllocationStack getAllocationCallStack()", "class_method_signature": "HeapDumpInstanceObject.getAllocationCallStack()", "testcase": false, "constructor": false}, {"identifier": "getIsRoot", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean getIsRoot()", "full_signature": "@Override public boolean getIsRoot()", "class_method_signature": "HeapDumpInstanceObject.getIsRoot()", "testcase": false, "constructor": false}, {"identifier": "getReferences", "parameters": "()", "modifiers": "@NotNull @Override public", "return": "List<ReferenceObject>", "signature": "List<ReferenceObject> getReferences()", "full_signature": "@NotNull @Override public List<ReferenceObject> getReferences()", "class_method_signature": "HeapDumpInstanceObject.getReferences()", "testcase": false, "constructor": false}, {"identifier": "extractReferences", "parameters": "()", "modifiers": "@VisibleForTesting @NotNull public", "return": "List<ReferenceObject>", "signature": "List<ReferenceObject> extractReferences()", "full_signature": "@VisibleForTesting @NotNull public List<ReferenceObject> extractReferences()", "class_method_signature": "HeapDumpInstanceObject.extractReferences()", "testcase": false, "constructor": false}], "file": "profilers/src/com/android/tools/profilers/memory/adapters/HeapDumpInstanceObject.java"}, "focal_method": {"identifier": "extractReferences", "parameters": "()", "modifiers": "@VisibleForTesting @NotNull public", "return": "List<ReferenceObject>", "body": "@VisibleForTesting\n  @NotNull\n  public List<ReferenceObject> extractReferences() {\n    // Sort hard referrers to appear first.\n    List<Instance> sortedReferences = new ArrayList<>(myInstance.getHardReverseReferences());\n    sortedReferences.sort(DEPTH_COMPARATOR);\n\n    // Sort soft referrers to appear second.\n    if (myInstance.getSoftReverseReferences() != null) {\n      List<Instance> sortedSoftReferences = new ArrayList<>(myInstance.getSoftReverseReferences());\n      sortedSoftReferences.sort(DEPTH_COMPARATOR);\n      sortedReferences.addAll(sortedSoftReferences);\n    }\n\n    List<ReferenceObject> referrers = new ArrayList<>(sortedReferences.size());\n\n    // Determine the variable names of references.\n    for (Instance reference : sortedReferences) {\n      // Note that each instance can have multiple references to the same object.\n      List<String> referencingFieldNames = new ArrayList<>(3);\n      if (reference instanceof ClassInstance) {\n        ClassInstance classInstance = (ClassInstance)reference;\n        for (ClassInstance.FieldValue entry : classInstance.getValues()) {\n          // This instance is referenced by a field of the referrer class\n          if (entry.getField().getType() == Type.OBJECT && entry.getValue() == myInstance) {\n            referencingFieldNames.add(entry.getField().getName());\n          }\n        }\n      }\n      else if (reference instanceof ArrayInstance) {\n        ArrayInstance arrayInstance = (ArrayInstance)reference;\n        assert arrayInstance.getArrayType() == Type.OBJECT;\n        Object[] values = arrayInstance.getValues();\n        for (int i = 0; i < values.length; ++i) {\n          // This instance is referenced by an array\n          if (values[i] == myInstance) {\n            referencingFieldNames.add(String.valueOf(i));\n          }\n        }\n      }\n      else if (reference instanceof ClassObj) {\n        ClassObj classObj = (ClassObj)reference;\n        Map<Field, Object> staticValues = classObj.getStaticFieldValues();\n        for (Map.Entry<Field, Object> entry : staticValues.entrySet()) {\n          // This instance is referenced by a static field of a Class object.\n          if (entry.getKey().getType() == Type.OBJECT && entry.getValue() == myInstance) {\n            referencingFieldNames.add(entry.getKey().getName());\n          }\n        }\n      }\n\n      InstanceObject referencingInstance = myCaptureObject.findInstanceObject(reference);\n      assert referencingInstance != null;\n      referrers.add(new ReferenceObject(referencingFieldNames, referencingInstance));\n    }\n\n    return referrers;\n  }", "signature": "List<ReferenceObject> extractReferences()", "full_signature": "@VisibleForTesting @NotNull public List<ReferenceObject> extractReferences()", "class_method_signature": "HeapDumpInstanceObject.extractReferences()", "testcase": false, "constructor": false, "invocations": ["getHardReverseReferences", "sort", "getSoftReverseReferences", "getSoftReverseReferences", "sort", "addAll", "size", "getValues", "getType", "getField", "getValue", "add", "getName", "getField", "getArrayType", "getValues", "add", "valueOf", "getStaticFieldValues", "entrySet", "getType", "getKey", "getValue", "add", "getName", "getKey", "findInstanceObject", "add"]}, "repository": {"repo_id": 60701247, "url": "https://github.com/JetBrains/android", "stars": 486, "created": "6/8/2016 1:46:48 PM +00:00", "updates": "2020-01-27T16:45:40+00:00", "fork": "False", "license": "licensed"}}