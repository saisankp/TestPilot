{"test_class": {"identifier": "PatchWriterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final long BIG = 2048L * 1024L * 1024L;", "modifier": "private static final", "type": "long", "declarator": "BIG = 2048L * 1024L * 1024L", "var_name": "BIG"}, {"original_string": "private static final JreDeflateParameters DEFLATE_PARAMS = JreDeflateParameters.of(6, 0, true);", "modifier": "private static final", "type": "JreDeflateParameters", "declarator": "DEFLATE_PARAMS = JreDeflateParameters.of(6, 0, true)", "var_name": "DEFLATE_PARAMS"}, {"original_string": "private static final TypedRange<Void> OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE =\n      new TypedRange<Void>(BIG, 17L, null);", "modifier": "private static final", "type": "TypedRange<Void>", "declarator": "OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE =\n      new TypedRange<Void>(BIG, 17L, null)", "var_name": "OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE"}, {"original_string": "private static final TypedRange<JreDeflateParameters> NEW_DELTA_FRIENDLY_UNCOMPRESS_RANGE =\n      new TypedRange<JreDeflateParameters>(BIG - 100L, BIG, DEFLATE_PARAMS);", "modifier": "private static final", "type": "TypedRange<JreDeflateParameters>", "declarator": "NEW_DELTA_FRIENDLY_UNCOMPRESS_RANGE =\n      new TypedRange<JreDeflateParameters>(BIG - 100L, BIG, DEFLATE_PARAMS)", "var_name": "NEW_DELTA_FRIENDLY_UNCOMPRESS_RANGE"}, {"original_string": "private static final TypedRange<JreDeflateParameters> NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE =\n      new TypedRange<JreDeflateParameters>(BIG, BIG, DEFLATE_PARAMS);", "modifier": "private static final", "type": "TypedRange<JreDeflateParameters>", "declarator": "NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE =\n      new TypedRange<JreDeflateParameters>(BIG, BIG, DEFLATE_PARAMS)", "var_name": "NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE"}, {"original_string": "private static final List<TypedRange<Void>> OLD_DELTA_FRIENDLY_UNCOMPRESS_PLAN =\n      Collections.singletonList(OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE);", "modifier": "private static final", "type": "List<TypedRange<Void>>", "declarator": "OLD_DELTA_FRIENDLY_UNCOMPRESS_PLAN =\n      Collections.singletonList(OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE)", "var_name": "OLD_DELTA_FRIENDLY_UNCOMPRESS_PLAN"}, {"original_string": "private static final List<TypedRange<JreDeflateParameters>> NEW_DELTA_FRIENDLY_UNCOMPRESS_PLAN =\n      Collections.singletonList(NEW_DELTA_FRIENDLY_UNCOMPRESS_RANGE);", "modifier": "private static final", "type": "List<TypedRange<JreDeflateParameters>>", "declarator": "NEW_DELTA_FRIENDLY_UNCOMPRESS_PLAN =\n      Collections.singletonList(NEW_DELTA_FRIENDLY_UNCOMPRESS_RANGE)", "var_name": "NEW_DELTA_FRIENDLY_UNCOMPRESS_PLAN"}, {"original_string": "private static final List<TypedRange<JreDeflateParameters>> NEW_DELTA_FRIENDLY_RECOMPRESS_PLAN =\n      Collections.singletonList(NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE);", "modifier": "private static final", "type": "List<TypedRange<JreDeflateParameters>>", "declarator": "NEW_DELTA_FRIENDLY_RECOMPRESS_PLAN =\n      Collections.singletonList(NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE)", "var_name": "NEW_DELTA_FRIENDLY_RECOMPRESS_PLAN"}, {"original_string": "private static final long DELTA_FRIENDLY_OLD_FILE_SIZE = BIG - 75L;", "modifier": "private static final", "type": "long", "declarator": "DELTA_FRIENDLY_OLD_FILE_SIZE = BIG - 75L", "var_name": "DELTA_FRIENDLY_OLD_FILE_SIZE"}, {"original_string": "private static final long DELTA_FRIENDLY_NEW_FILE_SIZE = BIG + 75L;", "modifier": "private static final", "type": "long", "declarator": "DELTA_FRIENDLY_NEW_FILE_SIZE = BIG + 75L", "var_name": "DELTA_FRIENDLY_NEW_FILE_SIZE"}, {"original_string": "private static final PreDiffPlan PLAN =\n      new PreDiffPlan(\n          Collections.<QualifiedRecommendation>emptyList(),\n          OLD_DELTA_FRIENDLY_UNCOMPRESS_PLAN,\n          NEW_DELTA_FRIENDLY_UNCOMPRESS_PLAN,\n          NEW_DELTA_FRIENDLY_RECOMPRESS_PLAN);", "modifier": "private static final", "type": "PreDiffPlan", "declarator": "PLAN =\n      new PreDiffPlan(\n          Collections.<QualifiedRecommendation>emptyList(),\n          OLD_DELTA_FRIENDLY_UNCOMPRESS_PLAN,\n          NEW_DELTA_FRIENDLY_UNCOMPRESS_PLAN,\n          NEW_DELTA_FRIENDLY_RECOMPRESS_PLAN)", "var_name": "PLAN"}, {"original_string": "private static final String DELTA_CONTENT = \"this is a really cool delta, woo\";", "modifier": "private static final", "type": "String", "declarator": "DELTA_CONTENT = \"this is a really cool delta, woo\"", "var_name": "DELTA_CONTENT"}, {"original_string": "private File deltaFile = null;", "modifier": "private", "type": "File", "declarator": "deltaFile = null", "var_name": "deltaFile"}, {"original_string": "private ByteArrayOutputStream buffer = null;", "modifier": "private", "type": "ByteArrayOutputStream", "declarator": "buffer = null", "var_name": "buffer"}], "file": "feya/libraries/archive_diff/diff.generator/src/test/java/com/google/archivepatcher/generator/PatchWriterTest.java"}, "test_case": {"identifier": "testWriteV1Patch", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testWriteV1Patch() throws IOException {\n    // ---------------------------------------------------------------------------------------------\n    // CAUTION - DO NOT CHANGE THIS FUNCTION WITHOUT DUE CONSIDERATION FOR BREAKING THE PATCH FORMAT\n    // ---------------------------------------------------------------------------------------------\n    // This test writes a simple patch with all the static data listed above and verifies it.\n    // This code MUST be INDEPENDENT of the real patch parser code, even if it is partially\n    // redundant; this guards against accidental changes to the patch writer that could alter the\n    // format and otherwise escape detection.\n    PatchWriter writer =\n        new PatchWriter(\n            PLAN, DELTA_FRIENDLY_OLD_FILE_SIZE, DELTA_FRIENDLY_NEW_FILE_SIZE, deltaFile);\n    writer.writeV1Patch(buffer);\n    DataInputStream patchIn = new DataInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n    byte[] eightBytes = new byte[8];\n\n    // Start by reading the signature and flags\n    patchIn.readFully(eightBytes);\n    Assert.assertArrayEquals(PatchConstants.IDENTIFIER.getBytes(\"US-ASCII\"), eightBytes);\n    Assert.assertEquals(0, patchIn.readInt()); // Flags, all reserved in v1\n\n    Assert.assertEquals(DELTA_FRIENDLY_OLD_FILE_SIZE, patchIn.readLong());\n\n    // Read the uncompression instructions\n    Assert.assertEquals(1, patchIn.readInt()); // Number of old archive uncompression instructions\n    Assert.assertEquals(OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE.getOffset(), patchIn.readLong());\n    Assert.assertEquals(OLD_DELTA_FRIENDLY_UNCOMPRESS_RANGE.getLength(), patchIn.readLong());\n\n    // Read the recompression instructions\n    Assert.assertEquals(1, patchIn.readInt()); // Number of new archive recompression instructions\n    Assert.assertEquals(NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE.getOffset(), patchIn.readLong());\n    Assert.assertEquals(NEW_DELTA_FRIENDLY_RECOMPRESS_RANGE.getLength(), patchIn.readLong());\n    // Now the JreDeflateParameters for the record\n    Assert.assertEquals(\n        PatchConstants.CompatibilityWindowId.DEFAULT_DEFLATE.patchValue, patchIn.read());\n    Assert.assertEquals(DEFLATE_PARAMS.level, patchIn.read());\n    Assert.assertEquals(DEFLATE_PARAMS.strategy, patchIn.read());\n    Assert.assertEquals(DEFLATE_PARAMS.nowrap ? 1 : 0, patchIn.read());\n\n    // Delta section. V1 patches have exactly one delta entry and it is always mapped to the entire\n    // file contents of the delta-friendly archives\n    Assert.assertEquals(1, patchIn.readInt()); // Number of difference records\n    Assert.assertEquals(PatchConstants.DeltaFormat.BSDIFF.patchValue, patchIn.read());\n    Assert.assertEquals(0, patchIn.readLong()); // Old delta-friendly range start\n    Assert.assertEquals(DELTA_FRIENDLY_OLD_FILE_SIZE, patchIn.readLong()); // old range length\n    Assert.assertEquals(0, patchIn.readLong()); // New delta-friendly range start\n    Assert.assertEquals(DELTA_FRIENDLY_NEW_FILE_SIZE, patchIn.readLong()); // new range length\n    byte[] expectedDeltaContent = DELTA_CONTENT.getBytes(\"US-ASCII\");\n    Assert.assertEquals(expectedDeltaContent.length, patchIn.readLong());\n    byte[] actualDeltaContent = new byte[expectedDeltaContent.length];\n    patchIn.readFully(actualDeltaContent);\n    Assert.assertArrayEquals(expectedDeltaContent, actualDeltaContent);\n  }", "signature": "void testWriteV1Patch()", "full_signature": "@Test public void testWriteV1Patch()", "class_method_signature": "PatchWriterTest.testWriteV1Patch()", "testcase": true, "constructor": false, "invocations": ["writeV1Patch", "toByteArray", "readFully", "assertArrayEquals", "getBytes", "assertEquals", "readInt", "assertEquals", "readLong", "assertEquals", "readInt", "assertEquals", "getOffset", "readLong", "assertEquals", "getLength", "readLong", "assertEquals", "readInt", "assertEquals", "getOffset", "readLong", "assertEquals", "getLength", "readLong", "assertEquals", "read", "assertEquals", "read", "assertEquals", "read", "assertEquals", "read", "assertEquals", "readInt", "assertEquals", "read", "assertEquals", "readLong", "assertEquals", "readLong", "assertEquals", "readLong", "assertEquals", "readLong", "getBytes", "assertEquals", "readLong", "readFully", "assertArrayEquals"]}, "focal_class": {"identifier": "PatchWriter", "superclass": "", "interfaces": "", "fields": [{"original_string": "private final PreDiffPlan plan;", "modifier": "private final", "type": "PreDiffPlan", "declarator": "plan", "var_name": "plan"}, {"original_string": "private final long deltaFriendlyOldFileSize;", "modifier": "private final", "type": "long", "declarator": "deltaFriendlyOldFileSize", "var_name": "deltaFriendlyOldFileSize"}, {"original_string": "private final long deltaFriendlyNewFileSize;", "modifier": "private final", "type": "long", "declarator": "deltaFriendlyNewFileSize", "var_name": "deltaFriendlyNewFileSize"}, {"original_string": "private final File deltaFile;", "modifier": "private final", "type": "File", "declarator": "deltaFile", "var_name": "deltaFile"}], "methods": [{"identifier": "PatchWriter", "parameters": "(\n      PreDiffPlan plan,\n      long deltaFriendlyOldFileSize,\n      long deltaFriendlyNewFileSize,\n      File deltaFile)", "modifiers": "public", "return": "", "signature": " PatchWriter(\n      PreDiffPlan plan,\n      long deltaFriendlyOldFileSize,\n      long deltaFriendlyNewFileSize,\n      File deltaFile)", "full_signature": "public  PatchWriter(\n      PreDiffPlan plan,\n      long deltaFriendlyOldFileSize,\n      long deltaFriendlyNewFileSize,\n      File deltaFile)", "class_method_signature": "PatchWriter.PatchWriter(\n      PreDiffPlan plan,\n      long deltaFriendlyOldFileSize,\n      long deltaFriendlyNewFileSize,\n      File deltaFile)", "testcase": false, "constructor": true}, {"identifier": "writeV1Patch", "parameters": "(OutputStream out)", "modifiers": "public", "return": "void", "signature": "void writeV1Patch(OutputStream out)", "full_signature": "public void writeV1Patch(OutputStream out)", "class_method_signature": "PatchWriter.writeV1Patch(OutputStream out)", "testcase": false, "constructor": false}], "file": "feya/libraries/archive_diff/diff.generator/src/main/java/com/google/archivepatcher/generator/PatchWriter.java"}, "focal_method": {"identifier": "writeV1Patch", "parameters": "(OutputStream out)", "modifiers": "public", "return": "void", "body": "public void writeV1Patch(OutputStream out) throws IOException {\n    // Use DataOutputStream for ease of writing. This is deliberately left open, as closing it would\n    // close the output stream that was passed in and that is not part of the method's documented\n    // behavior.\n    @SuppressWarnings(\"resource\")\n    DataOutputStream dataOut = new DataOutputStream(out);\n\n    dataOut.write(PatchConstants.IDENTIFIER.getBytes(\"US-ASCII\"));\n    dataOut.writeInt(0); // Flags (reserved)\n    dataOut.writeLong(deltaFriendlyOldFileSize);\n\n    // Write out all the delta-friendly old file uncompression instructions\n    dataOut.writeInt(plan.getOldFileUncompressionPlan().size());\n    for (TypedRange<Void> range : plan.getOldFileUncompressionPlan()) {\n      dataOut.writeLong(range.getOffset());\n      dataOut.writeLong(range.getLength());\n    }\n\n    // Write out all the delta-friendly new file recompression instructions\n    dataOut.writeInt(plan.getDeltaFriendlyNewFileRecompressionPlan().size());\n    for (TypedRange<JreDeflateParameters> range : plan.getDeltaFriendlyNewFileRecompressionPlan()) {\n      dataOut.writeLong(range.getOffset());\n      dataOut.writeLong(range.getLength());\n      // Write the deflate information\n      dataOut.write(PatchConstants.CompatibilityWindowId.DEFAULT_DEFLATE.patchValue);\n      dataOut.write(range.getMetadata().level);\n      dataOut.write(range.getMetadata().strategy);\n      dataOut.write(range.getMetadata().nowrap ? 1 : 0);\n    }\n\n    // Now the delta section\n    // First write the number of deltas present in the patch. In v1, there is always exactly one\n    // delta, and it is for the entire input; in future versions there may be multiple deltas, of\n    // arbitrary types.\n    dataOut.writeInt(1);\n    // In v1 the delta format is always bsdiff, so write it unconditionally.\n    dataOut.write(PatchConstants.DeltaFormat.BSDIFF.patchValue);\n\n    // Write the working ranges. In v1 these are always the entire contents of the delta-friendly\n    // old file and the delta-friendly new file. These are for forward compatibility with future\n    // versions that may allow deltas of arbitrary formats to be mapped to arbitrary ranges.\n    dataOut.writeLong(0); // i.e., start of the working range in the delta-friendly old file\n    dataOut.writeLong(deltaFriendlyOldFileSize); // i.e., length of the working range in old\n    dataOut.writeLong(0); // i.e., start of the working range in the delta-friendly new file\n    dataOut.writeLong(deltaFriendlyNewFileSize); // i.e., length of the working range in new\n\n    // Finally, the length of the delta and the delta itself.\n    dataOut.writeLong(deltaFile.length());\n    try (FileInputStream deltaFileIn = new FileInputStream(deltaFile);\n        BufferedInputStream deltaIn = new BufferedInputStream(deltaFileIn)) {\n      byte[] buffer = new byte[32768];\n      int numRead = 0;\n      while ((numRead = deltaIn.read(buffer)) >= 0) {\n        dataOut.write(buffer, 0, numRead);\n      }\n    }\n    dataOut.flush();\n  }", "signature": "void writeV1Patch(OutputStream out)", "full_signature": "public void writeV1Patch(OutputStream out)", "class_method_signature": "PatchWriter.writeV1Patch(OutputStream out)", "testcase": false, "constructor": false, "invocations": ["write", "getBytes", "writeInt", "writeLong", "writeInt", "size", "getOldFileUncompressionPlan", "getOldFileUncompressionPlan", "writeLong", "getOffset", "writeLong", "getLength", "writeInt", "size", "getDeltaFriendlyNewFileRecompressionPlan", "getDeltaFriendlyNewFileRecompressionPlan", "writeLong", "getOffset", "writeLong", "getLength", "write", "write", "getMetadata", "write", "getMetadata", "write", "getMetadata", "writeInt", "write", "writeLong", "writeLong", "writeLong", "writeLong", "writeLong", "length", "read", "write", "flush"]}, "repository": {"repo_id": 20126854, "url": "https://github.com/kaedea/Feya", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 12, "size": 7798, "license": "licensed"}}