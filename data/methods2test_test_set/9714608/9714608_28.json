{"test_class": {"identifier": "MathUtilTest", "superclass": "extends AbstractTestCase", "interfaces": "", "fields": [], "file": "core/maths/mathgen/src/test/java/org/arakhne/afc/math/MathUtilTest.java"}, "test_case": {"identifier": "clampCyclic", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void clampCyclic() {\n\t\tdouble min = 50;\n\t\tdouble max = 90;\n\t\tassertEpsilonEquals(89, MathUtil.clampCyclic(9, min, max));\n\t\tassertEpsilonEquals(50, MathUtil.clampCyclic(10, min, max));\n\t\tassertEpsilonEquals(60, MathUtil.clampCyclic(20, min, max));\n\t\tassertEpsilonEquals(89, MathUtil.clampCyclic(49, min, max));\n\t\tassertEpsilonEquals(50, MathUtil.clampCyclic(50, min, max));\n\t\tassertEpsilonEquals(70, MathUtil.clampCyclic(70, min, max));\n\t\tassertEpsilonEquals(50, MathUtil.clampCyclic(90, min, max));\n\t\tassertEpsilonEquals(51, MathUtil.clampCyclic(91, min, max));\n\t\tassertEpsilonEquals(70, MathUtil.clampCyclic(110, min, max));\n\t\tassertEpsilonEquals(50, MathUtil.clampCyclic(130, min, max));\n\t}", "signature": "void clampCyclic()", "full_signature": "@Test public void clampCyclic()", "class_method_signature": "MathUtilTest.clampCyclic()", "testcase": true, "constructor": false, "invocations": ["assertEpsilonEquals", "clampCyclic", "assertEpsilonEquals", "clampCyclic", "assertEpsilonEquals", "clampCyclic", "assertEpsilonEquals", "clampCyclic", "assertEpsilonEquals", "clampCyclic", "assertEpsilonEquals", "clampCyclic", "assertEpsilonEquals", "clampCyclic", "assertEpsilonEquals", "clampCyclic", "assertEpsilonEquals", "clampCyclic", "assertEpsilonEquals", "clampCyclic"]}, "focal_class": {"identifier": "MathUtil", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "MathUtil", "parameters": "()", "modifiers": "private", "return": "", "signature": " MathUtil()", "full_signature": "private  MathUtil()", "class_method_signature": "MathUtil.MathUtil()", "testcase": false, "constructor": true}, {"identifier": "sign", "parameters": "(double value)", "modifiers": "@Pure @Inline(value = \"($1 == 0. || Double.isNaN($1)) ? 0 : (($1 < -0.) ? -1 : 1)\") public static", "return": "int", "signature": "int sign(double value)", "full_signature": "@Pure @Inline(value = \"($1 == 0. || Double.isNaN($1)) ? 0 : (($1 < -0.) ? -1 : 1)\") public static int sign(double value)", "class_method_signature": "MathUtil.sign(double value)", "testcase": false, "constructor": false}, {"identifier": "signNoZero", "parameters": "(double value)", "modifiers": "@Pure @Inline(value = \"(($1 < -0.) ? -1 : 1)\") public static", "return": "int", "signature": "int signNoZero(double value)", "full_signature": "@Pure @Inline(value = \"(($1 < -0.) ? -1 : 1)\") public static int signNoZero(double value)", "class_method_signature": "MathUtil.signNoZero(double value)", "testcase": false, "constructor": false}, {"identifier": "clamp", "parameters": "(double v, double min, double max)", "modifiers": "@Pure public static", "return": "double", "signature": "double clamp(double v, double min, double max)", "full_signature": "@Pure public static double clamp(double v, double min, double max)", "class_method_signature": "MathUtil.clamp(double v, double min, double max)", "testcase": false, "constructor": false}, {"identifier": "clamp", "parameters": "(int v, int min, int max)", "modifiers": "@Pure public static", "return": "int", "signature": "int clamp(int v, int min, int max)", "full_signature": "@Pure public static int clamp(int v, int min, int max)", "class_method_signature": "MathUtil.clamp(int v, int min, int max)", "testcase": false, "constructor": false}, {"identifier": "isEpsilonZero", "parameters": "(double value)", "modifiers": "@Pure @Inline(value = \"Math.abs($1) < Math.ulp($1)\", imported = Math.class) public static", "return": "boolean", "signature": "boolean isEpsilonZero(double value)", "full_signature": "@Pure @Inline(value = \"Math.abs($1) < Math.ulp($1)\", imported = Math.class) public static boolean isEpsilonZero(double value)", "class_method_signature": "MathUtil.isEpsilonZero(double value)", "testcase": false, "constructor": false}, {"identifier": "isEpsilonZero", "parameters": "(double value, double epsilon)", "modifiers": "@Pure @Inline(value = \"Math.abs($1) < (Double.isNaN($2) ? Math.ulp($1) : ($2))\", imported = Math.class) public static", "return": "boolean", "signature": "boolean isEpsilonZero(double value, double epsilon)", "full_signature": "@Pure @Inline(value = \"Math.abs($1) < (Double.isNaN($2) ? Math.ulp($1) : ($2))\", imported = Math.class) public static boolean isEpsilonZero(double value, double epsilon)", "class_method_signature": "MathUtil.isEpsilonZero(double value, double epsilon)", "testcase": false, "constructor": false}, {"identifier": "isEpsilonEqual", "parameters": "(double v1, double v2)", "modifiers": "@Pure @Inline(value = \"MathUtil.isEpsilonEqual($1, $2, Double.NaN)\", imported = {MathUtil.class}) public static", "return": "boolean", "signature": "boolean isEpsilonEqual(double v1, double v2)", "full_signature": "@Pure @Inline(value = \"MathUtil.isEpsilonEqual($1, $2, Double.NaN)\", imported = {MathUtil.class}) public static boolean isEpsilonEqual(double v1, double v2)", "class_method_signature": "MathUtil.isEpsilonEqual(double v1, double v2)", "testcase": false, "constructor": false}, {"identifier": "isEpsilonEqual", "parameters": "(double v1, double v2, double epsilon)", "modifiers": "@Pure public static", "return": "boolean", "signature": "boolean isEpsilonEqual(double v1, double v2, double epsilon)", "full_signature": "@Pure public static boolean isEpsilonEqual(double v1, double v2, double epsilon)", "class_method_signature": "MathUtil.isEpsilonEqual(double v1, double v2, double epsilon)", "testcase": false, "constructor": false}, {"identifier": "compareEpsilon", "parameters": "(double v1, double v2)", "modifiers": "@Pure public static", "return": "int", "signature": "int compareEpsilon(double v1, double v2)", "full_signature": "@Pure public static int compareEpsilon(double v1, double v2)", "class_method_signature": "MathUtil.compareEpsilon(double v1, double v2)", "testcase": false, "constructor": false}, {"identifier": "compareEpsilon", "parameters": "(double v1, double v2, double epsilon)", "modifiers": "@Pure public static", "return": "int", "signature": "int compareEpsilon(double v1, double v2, double epsilon)", "full_signature": "@Pure public static int compareEpsilon(double v1, double v2, double epsilon)", "class_method_signature": "MathUtil.compareEpsilon(double v1, double v2, double epsilon)", "testcase": false, "constructor": false}, {"identifier": "max", "parameters": "(double... values)", "modifiers": "@Pure public static", "return": "double", "signature": "double max(double... values)", "full_signature": "@Pure public static double max(double... values)", "class_method_signature": "MathUtil.max(double... values)", "testcase": false, "constructor": false}, {"identifier": "max", "parameters": "(float... values)", "modifiers": "@Pure public static", "return": "float", "signature": "float max(float... values)", "full_signature": "@Pure public static float max(float... values)", "class_method_signature": "MathUtil.max(float... values)", "testcase": false, "constructor": false}, {"identifier": "max", "parameters": "(int... values)", "modifiers": "@Pure public static", "return": "int", "signature": "int max(int... values)", "full_signature": "@Pure public static int max(int... values)", "class_method_signature": "MathUtil.max(int... values)", "testcase": false, "constructor": false}, {"identifier": "max", "parameters": "(long... values)", "modifiers": "@Pure public static", "return": "long", "signature": "long max(long... values)", "full_signature": "@Pure public static long max(long... values)", "class_method_signature": "MathUtil.max(long... values)", "testcase": false, "constructor": false}, {"identifier": "max", "parameters": "(short... values)", "modifiers": "@Pure public static", "return": "short", "signature": "short max(short... values)", "full_signature": "@Pure public static short max(short... values)", "class_method_signature": "MathUtil.max(short... values)", "testcase": false, "constructor": false}, {"identifier": "min", "parameters": "(double... values)", "modifiers": "@Pure public static", "return": "double", "signature": "double min(double... values)", "full_signature": "@Pure public static double min(double... values)", "class_method_signature": "MathUtil.min(double... values)", "testcase": false, "constructor": false}, {"identifier": "min", "parameters": "(float... values)", "modifiers": "@Pure public static", "return": "float", "signature": "float min(float... values)", "full_signature": "@Pure public static float min(float... values)", "class_method_signature": "MathUtil.min(float... values)", "testcase": false, "constructor": false}, {"identifier": "min", "parameters": "(int... values)", "modifiers": "@Pure public static", "return": "int", "signature": "int min(int... values)", "full_signature": "@Pure public static int min(int... values)", "class_method_signature": "MathUtil.min(int... values)", "testcase": false, "constructor": false}, {"identifier": "min", "parameters": "(long... values)", "modifiers": "@Pure public static", "return": "long", "signature": "long min(long... values)", "full_signature": "@Pure public static long min(long... values)", "class_method_signature": "MathUtil.min(long... values)", "testcase": false, "constructor": false}, {"identifier": "min", "parameters": "(short... values)", "modifiers": "@Pure public static", "return": "short", "signature": "short min(short... values)", "full_signature": "@Pure public static short min(short... values)", "class_method_signature": "MathUtil.min(short... values)", "testcase": false, "constructor": false}, {"identifier": "clampCyclic", "parameters": "(double value, double min, double max)", "modifiers": "@Pure public static", "return": "double", "signature": "double clampCyclic(double value, double min, double max)", "full_signature": "@Pure public static double clampCyclic(double value, double min, double max)", "class_method_signature": "MathUtil.clampCyclic(double value, double min, double max)", "testcase": false, "constructor": false}, {"identifier": "clampToNearestBounds", "parameters": "(double value, double minBounds, double maxBounds)", "modifiers": "@Pure public static", "return": "double", "signature": "double clampToNearestBounds(double value, double minBounds, double maxBounds)", "full_signature": "@Pure public static double clampToNearestBounds(double value, double minBounds, double maxBounds)", "class_method_signature": "MathUtil.clampToNearestBounds(double value, double minBounds, double maxBounds)", "testcase": false, "constructor": false}, {"identifier": "getCohenSutherlandCode", "parameters": "(int px, int py, int rxmin, int rymin, int rxmax, int rymax)", "modifiers": "@Pure public static", "return": "int", "signature": "int getCohenSutherlandCode(int px, int py, int rxmin, int rymin, int rxmax, int rymax)", "full_signature": "@Pure public static int getCohenSutherlandCode(int px, int py, int rxmin, int rymin, int rxmax, int rymax)", "class_method_signature": "MathUtil.getCohenSutherlandCode(int px, int py, int rxmin, int rymin, int rxmax, int rymax)", "testcase": false, "constructor": false}, {"identifier": "getCohenSutherlandCode", "parameters": "(double px, double py, double rxmin, double rymin, double rxmax, double rymax)", "modifiers": "@Pure public static", "return": "int", "signature": "int getCohenSutherlandCode(double px, double py, double rxmin, double rymin, double rxmax, double rymax)", "full_signature": "@Pure public static int getCohenSutherlandCode(double px, double py, double rxmin, double rymin, double rxmax, double rymax)", "class_method_signature": "MathUtil.getCohenSutherlandCode(double px, double py, double rxmin, double rymin, double rxmax, double rymax)", "testcase": false, "constructor": false}, {"identifier": "getCohenSutherlandCode3D", "parameters": "(int px, int py, int pz, int rxmin, int rymin, int rzmin, int rxmax, int rymax,\n            int rzmax)", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:parameternumber\") public static", "return": "int", "signature": "int getCohenSutherlandCode3D(int px, int py, int pz, int rxmin, int rymin, int rzmin, int rxmax, int rymax,\n            int rzmax)", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:parameternumber\") public static int getCohenSutherlandCode3D(int px, int py, int pz, int rxmin, int rymin, int rzmin, int rxmax, int rymax,\n            int rzmax)", "class_method_signature": "MathUtil.getCohenSutherlandCode3D(int px, int py, int pz, int rxmin, int rymin, int rzmin, int rxmax, int rymax,\n            int rzmax)", "testcase": false, "constructor": false}, {"identifier": "getCohenSutherlandCode3D", "parameters": "(double px, double py, double pz, double rxmin, double rymin, double rzmin,\n            double rxmax, double rymax, double rzmax)", "modifiers": "@Pure @SuppressWarnings(\"checkstyle:parameternumber\") public static", "return": "int", "signature": "int getCohenSutherlandCode3D(double px, double py, double pz, double rxmin, double rymin, double rzmin,\n            double rxmax, double rymax, double rzmax)", "full_signature": "@Pure @SuppressWarnings(\"checkstyle:parameternumber\") public static int getCohenSutherlandCode3D(double px, double py, double pz, double rxmin, double rymin, double rzmin,\n            double rxmax, double rymax, double rzmax)", "class_method_signature": "MathUtil.getCohenSutherlandCode3D(double px, double py, double pz, double rxmin, double rymin, double rzmin,\n            double rxmax, double rymax, double rzmax)", "testcase": false, "constructor": false}, {"identifier": "getMinMax", "parameters": "(double value1, double value2, double value3)", "modifiers": "public static", "return": "DoubleRange", "signature": "DoubleRange getMinMax(double value1, double value2, double value3)", "full_signature": "public static DoubleRange getMinMax(double value1, double value2, double value3)", "class_method_signature": "MathUtil.getMinMax(double value1, double value2, double value3)", "testcase": false, "constructor": false}, {"identifier": "csc", "parameters": "(double angle)", "modifiers": "@Pure @Inline(value = \"1./Math.sin($1)\", imported = {Math.class}) public static", "return": "double", "signature": "double csc(double angle)", "full_signature": "@Pure @Inline(value = \"1./Math.sin($1)\", imported = {Math.class}) public static double csc(double angle)", "class_method_signature": "MathUtil.csc(double angle)", "testcase": false, "constructor": false}, {"identifier": "sec", "parameters": "(double angle)", "modifiers": "@Pure @Inline(value = \"1./Math.cos($1)\", imported = {Math.class}) public static", "return": "double", "signature": "double sec(double angle)", "full_signature": "@Pure @Inline(value = \"1./Math.cos($1)\", imported = {Math.class}) public static double sec(double angle)", "class_method_signature": "MathUtil.sec(double angle)", "testcase": false, "constructor": false}, {"identifier": "cot", "parameters": "(double angle)", "modifiers": "@Pure @Inline(value = \"1./Math.tan($1)\", imported = {Math.class}) public static", "return": "double", "signature": "double cot(double angle)", "full_signature": "@Pure @Inline(value = \"1./Math.tan($1)\", imported = {Math.class}) public static double cot(double angle)", "class_method_signature": "MathUtil.cot(double angle)", "testcase": false, "constructor": false}, {"identifier": "versin", "parameters": "(double angle)", "modifiers": "@Pure @Inline(value = \"1.-Math.cos($1)\", imported = {Math.class}) public static", "return": "double", "signature": "double versin(double angle)", "full_signature": "@Pure @Inline(value = \"1.-Math.cos($1)\", imported = {Math.class}) public static double versin(double angle)", "class_method_signature": "MathUtil.versin(double angle)", "testcase": false, "constructor": false}, {"identifier": "exsec", "parameters": "(double angle)", "modifiers": "@Pure @Inline(value = \"MathUtil.sec($1)-1.\", imported = {MathUtil.class}) public static", "return": "double", "signature": "double exsec(double angle)", "full_signature": "@Pure @Inline(value = \"MathUtil.sec($1)-1.\", imported = {MathUtil.class}) public static double exsec(double angle)", "class_method_signature": "MathUtil.exsec(double angle)", "testcase": false, "constructor": false}, {"identifier": "crd", "parameters": "(double angle)", "modifiers": "@Pure @Inline(value = \"2.*Math.sin(($1)/2.)\", imported = {Math.class}) public static", "return": "double", "signature": "double crd(double angle)", "full_signature": "@Pure @Inline(value = \"2.*Math.sin(($1)/2.)\", imported = {Math.class}) public static double crd(double angle)", "class_method_signature": "MathUtil.crd(double angle)", "testcase": false, "constructor": false}, {"identifier": "haversine", "parameters": "(double angle)", "modifiers": "@Pure public static", "return": "double", "signature": "double haversine(double angle)", "full_signature": "@Pure public static double haversine(double angle)", "class_method_signature": "MathUtil.haversine(double angle)", "testcase": false, "constructor": false}], "file": "core/maths/mathgen/src/main/java/org/arakhne/afc/math/MathUtil.java"}, "focal_method": {"identifier": "clampCyclic", "parameters": "(double value, double min, double max)", "modifiers": "@Pure public static", "return": "double", "body": "@Pure\n\tpublic static double clampCyclic(double value, double min, double max) {\n\t\tassert min <= max : AssertMessages.lowerEqualParameters(1, min, 2, max);\n\t\tif (Double.isNaN(max) || Double.isNaN(min) || Double.isNaN(max)) {\n\t\t\treturn Double.NaN;\n\t\t}\n\t\tif (value < min) {\n\t\t\tfinal double perimeter = max - min;\n\t\t\tfinal double nvalue = min - value;\n\t\t\tdouble rest = perimeter - (nvalue % perimeter);\n\t\t\tif (rest >= perimeter) {\n\t\t\t\trest -= perimeter;\n\t\t\t}\n\t\t\treturn min + rest;\n\t\t} else if (value >= max) {\n\t\t\tfinal double perimeter = max - min;\n\t\t\tfinal double nvalue = value - max;\n\t\t\tfinal double rest = nvalue % perimeter;\n\t\t\treturn min + rest;\n\t\t}\n\t\treturn value;\n\t}", "signature": "double clampCyclic(double value, double min, double max)", "full_signature": "@Pure public static double clampCyclic(double value, double min, double max)", "class_method_signature": "MathUtil.clampCyclic(double value, double min, double max)", "testcase": false, "constructor": false, "invocations": ["lowerEqualParameters", "isNaN", "isNaN", "isNaN"]}, "repository": {"repo_id": 9714608, "url": "https://github.com/gallandarakhneorg/afc", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 12, "size": 19091, "license": "licensed"}}