{"test_class": {"identifier": "MemoryRecordsTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private CompressionType compression;", "modifier": "private", "type": "CompressionType", "declarator": "compression", "var_name": "compression"}], "file": "clients/src/test/java/org/apache/kafka/common/record/MemoryRecordsTest.java"}, "test_case": {"identifier": "testIterator", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testIterator() {\n        MemoryRecords recs1 = MemoryRecords.emptyRecords(ByteBuffer.allocate(1024), compression);\n        MemoryRecords recs2 = MemoryRecords.emptyRecords(ByteBuffer.allocate(1024), compression);\n        List<Record> list = Arrays.asList(new Record(0L, \"a\".getBytes(), \"1\".getBytes()),\n                                          new Record(0L, \"b\".getBytes(), \"2\".getBytes()),\n                                          new Record(0L, \"c\".getBytes(), \"3\".getBytes()));\n        for (int i = 0; i < list.size(); i++) {\n            Record r = list.get(i);\n            recs1.append(i, r);\n            recs2.append(i, 0L, toArray(r.key()), toArray(r.value()));\n        }\n        recs1.close();\n        recs2.close();\n\n        for (int iteration = 0; iteration < 2; iteration++) {\n            for (MemoryRecords recs : Arrays.asList(recs1, recs2)) {\n                Iterator<LogEntry> iter = recs.iterator();\n                for (int i = 0; i < list.size(); i++) {\n                    assertTrue(iter.hasNext());\n                    LogEntry entry = iter.next();\n                    assertEquals((long) i, entry.offset());\n                    assertEquals(list.get(i), entry.record());\n                    entry.record().ensureValid();\n                }\n                assertFalse(iter.hasNext());\n            }\n        }\n    }", "signature": "void testIterator()", "full_signature": "@Test public void testIterator()", "class_method_signature": "MemoryRecordsTest.testIterator()", "testcase": true, "constructor": false, "invocations": ["emptyRecords", "allocate", "emptyRecords", "allocate", "asList", "getBytes", "getBytes", "getBytes", "getBytes", "getBytes", "getBytes", "size", "get", "append", "append", "toArray", "key", "toArray", "value", "close", "close", "asList", "iterator", "size", "assertTrue", "hasNext", "next", "assertEquals", "offset", "assertEquals", "get", "record", "ensureValid", "record", "assertFalse", "hasNext"]}, "focal_class": {"identifier": "MemoryRecords", "superclass": "", "interfaces": "implements Records", "fields": [{"original_string": "private final static int WRITE_LIMIT_FOR_READABLE_ONLY = -1;", "modifier": "private final static", "type": "int", "declarator": "WRITE_LIMIT_FOR_READABLE_ONLY = -1", "var_name": "WRITE_LIMIT_FOR_READABLE_ONLY"}, {"original_string": "private final Compressor compressor;", "modifier": "private final", "type": "Compressor", "declarator": "compressor", "var_name": "compressor"}, {"original_string": "private final int writeLimit;", "modifier": "private final", "type": "int", "declarator": "writeLimit", "var_name": "writeLimit"}, {"original_string": "private final int initialCapacity;", "modifier": "private final", "type": "int", "declarator": "initialCapacity", "var_name": "initialCapacity"}, {"original_string": "private ByteBuffer buffer;", "modifier": "private", "type": "ByteBuffer", "declarator": "buffer", "var_name": "buffer"}, {"original_string": "private boolean writable;", "modifier": "private", "type": "boolean", "declarator": "writable", "var_name": "writable"}], "methods": [{"identifier": "MemoryRecords", "parameters": "(ByteBuffer buffer, CompressionType type, boolean writable, int writeLimit)", "modifiers": "private", "return": "", "signature": " MemoryRecords(ByteBuffer buffer, CompressionType type, boolean writable, int writeLimit)", "full_signature": "private  MemoryRecords(ByteBuffer buffer, CompressionType type, boolean writable, int writeLimit)", "class_method_signature": "MemoryRecords.MemoryRecords(ByteBuffer buffer, CompressionType type, boolean writable, int writeLimit)", "testcase": false, "constructor": true}, {"identifier": "emptyRecords", "parameters": "(ByteBuffer buffer, CompressionType type, int writeLimit)", "modifiers": "public static", "return": "MemoryRecords", "signature": "MemoryRecords emptyRecords(ByteBuffer buffer, CompressionType type, int writeLimit)", "full_signature": "public static MemoryRecords emptyRecords(ByteBuffer buffer, CompressionType type, int writeLimit)", "class_method_signature": "MemoryRecords.emptyRecords(ByteBuffer buffer, CompressionType type, int writeLimit)", "testcase": false, "constructor": false}, {"identifier": "emptyRecords", "parameters": "(ByteBuffer buffer, CompressionType type)", "modifiers": "public static", "return": "MemoryRecords", "signature": "MemoryRecords emptyRecords(ByteBuffer buffer, CompressionType type)", "full_signature": "public static MemoryRecords emptyRecords(ByteBuffer buffer, CompressionType type)", "class_method_signature": "MemoryRecords.emptyRecords(ByteBuffer buffer, CompressionType type)", "testcase": false, "constructor": false}, {"identifier": "readableRecords", "parameters": "(ByteBuffer buffer)", "modifiers": "public static", "return": "MemoryRecords", "signature": "MemoryRecords readableRecords(ByteBuffer buffer)", "full_signature": "public static MemoryRecords readableRecords(ByteBuffer buffer)", "class_method_signature": "MemoryRecords.readableRecords(ByteBuffer buffer)", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(long offset, Record record)", "modifiers": "public", "return": "void", "signature": "void append(long offset, Record record)", "full_signature": "public void append(long offset, Record record)", "class_method_signature": "MemoryRecords.append(long offset, Record record)", "testcase": false, "constructor": false}, {"identifier": "append", "parameters": "(long offset, long timestamp, byte[] key, byte[] value)", "modifiers": "public", "return": "long", "signature": "long append(long offset, long timestamp, byte[] key, byte[] value)", "full_signature": "public long append(long offset, long timestamp, byte[] key, byte[] value)", "class_method_signature": "MemoryRecords.append(long offset, long timestamp, byte[] key, byte[] value)", "testcase": false, "constructor": false}, {"identifier": "isFull", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isFull()", "full_signature": "public boolean isFull()", "class_method_signature": "MemoryRecords.isFull()", "testcase": false, "constructor": false}, {"identifier": "hasRoomFor", "parameters": "(byte[] key, byte[] value)", "modifiers": "public", "return": "boolean", "signature": "boolean hasRoomFor(byte[] key, byte[] value)", "full_signature": "public boolean hasRoomFor(byte[] key, byte[] value)", "class_method_signature": "MemoryRecords.hasRoomFor(byte[] key, byte[] value)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void close()", "full_signature": "public void close()", "class_method_signature": "MemoryRecords.close()", "testcase": false, "constructor": false}, {"identifier": "sizeInBytes", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int sizeInBytes()", "full_signature": "public int sizeInBytes()", "class_method_signature": "MemoryRecords.sizeInBytes()", "testcase": false, "constructor": false}, {"identifier": "compressionRate", "parameters": "()", "modifiers": "public", "return": "double", "signature": "double compressionRate()", "full_signature": "public double compressionRate()", "class_method_signature": "MemoryRecords.compressionRate()", "testcase": false, "constructor": false}, {"identifier": "initialCapacity", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int initialCapacity()", "full_signature": "public int initialCapacity()", "class_method_signature": "MemoryRecords.initialCapacity()", "testcase": false, "constructor": false}, {"identifier": "buffer", "parameters": "()", "modifiers": "public", "return": "ByteBuffer", "signature": "ByteBuffer buffer()", "full_signature": "public ByteBuffer buffer()", "class_method_signature": "MemoryRecords.buffer()", "testcase": false, "constructor": false}, {"identifier": "iterator", "parameters": "()", "modifiers": "@Override public", "return": "Iterator<LogEntry>", "signature": "Iterator<LogEntry> iterator()", "full_signature": "@Override public Iterator<LogEntry> iterator()", "class_method_signature": "MemoryRecords.iterator()", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "MemoryRecords.toString()", "testcase": false, "constructor": false}, {"identifier": "isWritable", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isWritable()", "full_signature": "public boolean isWritable()", "class_method_signature": "MemoryRecords.isWritable()", "testcase": false, "constructor": false}], "file": "clients/src/main/java/org/apache/kafka/common/record/MemoryRecords.java"}, "focal_method": {"identifier": "iterator", "parameters": "()", "modifiers": "@Override public", "return": "Iterator<LogEntry>", "body": "@Override\n    public Iterator<LogEntry> iterator() {\n        if (writable) {\n            // flip on a duplicate buffer for reading\n            return new RecordsIterator((ByteBuffer) this.buffer.duplicate()\n                                                               .flip(), false);\n        } else {\n            // do not need to flip for non-writable buffer\n            return new RecordsIterator(this.buffer.duplicate(), false);\n        }\n    }", "signature": "Iterator<LogEntry> iterator()", "full_signature": "@Override public Iterator<LogEntry> iterator()", "class_method_signature": "MemoryRecords.iterator()", "testcase": false, "constructor": false, "invocations": ["flip", "duplicate", "duplicate"]}, "repository": {"repo_id": 135978112, "url": "https://github.com/anurnomeru/kafka-0.10.0.1-source-reading", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 7, "size": 2953, "license": "licensed"}}