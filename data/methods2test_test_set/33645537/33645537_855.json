{"test_class": {"identifier": "MMFMapTableTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static String testDir = TestUtil.TEST_BASE_DIR + \"sdb/unit/mmf_map_table_test\";", "modifier": "private static", "type": "String", "declarator": "testDir = TestUtil.TEST_BASE_DIR + \"sdb/unit/mmf_map_table_test\"", "var_name": "testDir"}, {"original_string": "private MMFMapTable mapTable;", "modifier": "private", "type": "MMFMapTable", "declarator": "mapTable", "var_name": "mapTable"}], "file": "zava/src/test/java/com/ctriposs/sdb/table/MMFMapTableTest.java"}, "test_case": {"identifier": "testAppendAndGet", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testAppendAndGet() throws IOException, ClassNotFoundException {\n\t\tlong createdTime = System.nanoTime();\n\t\tmapTable = new MMFMapTable(testDir, 1, createdTime, 1000, 4);\n\n\t\tassertTrue(mapTable.getLevel() == 1);\n\t\tassertTrue(mapTable.getCreatedTime() == createdTime);\n\t\tassertTrue(mapTable.getAppendedSize() == 0);\n\t\tassertTrue(mapTable.isEmpty());\n\t\t//assertTrue(mapTable.getBackFileSize() == (MMFMapTable.INIT_INDEX_FILE_SIZE + MMFMapTable.INIT_DATA_FILE_SIZE) * Level0Merger.DEFAULT_MERGE_WAYS);\n\n\t\tmapTable.appendNew(\"key\".getBytes(), \"value\".getBytes(), 500);\n\t\tassertTrue(mapTable.getLevel() == 1);\n\t\tassertTrue(mapTable.getCreatedTime() == createdTime);\n\t\tassertTrue(mapTable.getAppendedSize() == 1);\n\t\tassertFalse(mapTable.isEmpty());\n\n\t\tGetResult result = mapTable.get(\"key\".getBytes());\n\t\tassertTrue(result.isFound());\n\t\tassertTrue(!result.isDeleted());\n\t\tassertTrue(!result.isExpired());\n\n\t\ttry {\n\t\t\tThread.sleep(1000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tresult = mapTable.get(\"key\".getBytes());\n\t\tassertTrue(result.isFound());\n\t\tassertTrue(!result.isDeleted());\n\t\tassertTrue(result.isExpired());\n\n\t\tresult = mapTable.get(\"key1\".getBytes());\n\t\tassertFalse(result.isFound());\n\n\t\tassertFalse(mapTable.isUsable());\n\n\t}", "signature": "void testAppendAndGet()", "full_signature": "@Test public void testAppendAndGet()", "class_method_signature": "MMFMapTableTest.testAppendAndGet()", "testcase": true, "constructor": false, "invocations": ["nanoTime", "assertTrue", "getLevel", "assertTrue", "getCreatedTime", "assertTrue", "getAppendedSize", "assertTrue", "isEmpty", "appendNew", "getBytes", "getBytes", "assertTrue", "getLevel", "assertTrue", "getCreatedTime", "assertTrue", "getAppendedSize", "assertFalse", "isEmpty", "get", "getBytes", "assertTrue", "isFound", "assertTrue", "isDeleted", "assertTrue", "isExpired", "sleep", "printStackTrace", "get", "getBytes", "assertTrue", "isFound", "assertTrue", "isDeleted", "assertTrue", "isExpired", "get", "getBytes", "assertFalse", "isFound", "assertFalse", "isUsable"]}, "focal_class": {"identifier": "MMFMapTable", "superclass": "extends AbstractSortedMapTable", "interfaces": "", "fields": [{"original_string": "protected MappedByteBuffer dataMappedByteBuffer;", "modifier": "protected", "type": "MappedByteBuffer", "declarator": "dataMappedByteBuffer", "var_name": "dataMappedByteBuffer"}], "methods": [{"identifier": "MMFMapTable", "parameters": "(String dir, int level, long createdTime, int expectedInsertions, int mergeWays)", "modifiers": "public", "return": "", "signature": " MMFMapTable(String dir, int level, long createdTime, int expectedInsertions, int mergeWays)", "full_signature": "public  MMFMapTable(String dir, int level, long createdTime, int expectedInsertions, int mergeWays)", "class_method_signature": "MMFMapTable.MMFMapTable(String dir, int level, long createdTime, int expectedInsertions, int mergeWays)", "testcase": false, "constructor": true}, {"identifier": "MMFMapTable", "parameters": "(String dir, short shard, int level, long createdTime, int expectedInsertions, int mergeWays)", "modifiers": "public", "return": "", "signature": " MMFMapTable(String dir, short shard, int level, long createdTime, int expectedInsertions, int mergeWays)", "full_signature": "public  MMFMapTable(String dir, short shard, int level, long createdTime, int expectedInsertions, int mergeWays)", "class_method_signature": "MMFMapTable.MMFMapTable(String dir, short shard, int level, long createdTime, int expectedInsertions, int mergeWays)", "testcase": false, "constructor": true}, {"identifier": "MMFMapTable", "parameters": "(String dir, String fileName)", "modifiers": "public", "return": "", "signature": " MMFMapTable(String dir, String fileName)", "full_signature": "public  MMFMapTable(String dir, String fileName)", "class_method_signature": "MMFMapTable.MMFMapTable(String dir, String fileName)", "testcase": false, "constructor": true}, {"identifier": "reMap", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void reMap()", "full_signature": "public void reMap()", "class_method_signature": "MMFMapTable.reMap()", "testcase": false, "constructor": false}, {"identifier": "appendNew", "parameters": "(byte[] key, byte[] value, long timeToLive)", "modifiers": "public", "return": "IMapEntry", "signature": "IMapEntry appendNew(byte[] key, byte[] value, long timeToLive)", "full_signature": "public IMapEntry appendNew(byte[] key, byte[] value, long timeToLive)", "class_method_signature": "MMFMapTable.appendNew(byte[] key, byte[] value, long timeToLive)", "testcase": false, "constructor": false}, {"identifier": "appendNew", "parameters": "(byte[] key, int keyHash, byte[] value, long timeToLive, long createdTime, boolean markDelete, boolean compressed)", "modifiers": "@Override public", "return": "IMapEntry", "signature": "IMapEntry appendNew(byte[] key, int keyHash, byte[] value, long timeToLive, long createdTime, boolean markDelete, boolean compressed)", "full_signature": "@Override public IMapEntry appendNew(byte[] key, int keyHash, byte[] value, long timeToLive, long createdTime, boolean markDelete, boolean compressed)", "class_method_signature": "MMFMapTable.appendNew(byte[] key, int keyHash, byte[] value, long timeToLive, long createdTime, boolean markDelete, boolean compressed)", "testcase": false, "constructor": false}, {"identifier": "getMapEntry", "parameters": "(int index)", "modifiers": "@Override public", "return": "IMapEntry", "signature": "IMapEntry getMapEntry(int index)", "full_signature": "@Override public IMapEntry getMapEntry(int index)", "class_method_signature": "MMFMapTable.getMapEntry(int index)", "testcase": false, "constructor": false}, {"identifier": "close", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void close()", "full_signature": "@Override public void close()", "class_method_signature": "MMFMapTable.close()", "testcase": false, "constructor": false}], "file": "zava/src/main/java/com/ctriposs/sdb/table/MMFMapTable.java"}, "focal_method": {"identifier": "appendNew", "parameters": "(byte[] key, byte[] value, long timeToLive)", "modifiers": "public", "return": "IMapEntry", "body": "public IMapEntry appendNew(byte[] key, byte[] value, long timeToLive) throws IOException {\n\t\treturn this.appendNew(key, Arrays.hashCode(key), value, timeToLive, System.currentTimeMillis(), false, false);\n\t}", "signature": "IMapEntry appendNew(byte[] key, byte[] value, long timeToLive)", "full_signature": "public IMapEntry appendNew(byte[] key, byte[] value, long timeToLive)", "class_method_signature": "MMFMapTable.appendNew(byte[] key, byte[] value, long timeToLive)", "testcase": false, "constructor": false, "invocations": ["appendNew", "hashCode", "currentTimeMillis"]}, "repository": {"repo_id": 33645537, "url": "https://github.com/zqhxuyuan/tutorials", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 5, "size": 35273, "license": "licensed"}}