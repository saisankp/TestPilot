{"test_class": {"identifier": "CommandTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(CommandTest.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(CommandTest.class)", "var_name": "LOGGER"}, {"original_string": "final File testOutputBaseDir = new File(\"target/test-output/CommandTest\");", "modifier": "final", "type": "File", "declarator": "testOutputBaseDir = new File(\"target/test-output/CommandTest\")", "var_name": "testOutputBaseDir"}], "file": "cli/src/test/java/net/adamcin/oakpal/cli/CommandTest.java"}, "test_case": {"identifier": "testWriteReports", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testWriteReports() {\n        final List<CheckReport> reports = new ArrayList<>();\n        reports.add(new SimpleReport(\"some check\", Collections.emptyList()));\n        reports.add(new SimpleReport(\"check with violations\", Arrays.asList(\n                new SimpleViolation(Severity.MINOR, \"minor violation\"),\n                new SimpleViolation(Severity.SEVERE, \"severe violation with one packageId\",\n                        PackageId.fromString(\"my_packages/acme/1.0\")),\n                new SimpleViolation(Severity.MAJOR, \"major violation with several packageIds\",\n                        PackageId.fromString(\"my_packages/alpha/1.0\"),\n                        PackageId.fromString(\"my_packages/beta/1.0\"),\n                        PackageId.fromString(\"my_packages/gamma/1.0\"))\n        )));\n\n        final String output = captureStructured(false, (command, printer) ->\n                command.printReports(reports, printer));\n        LOGGER.info(\"reports: \\n{}\", output);\n        assertFalse(\"reports should not be empty\", output.isEmpty());\n\n        final String jsonOutput = captureStructured(true, (command, printer) ->\n                command.printReports(reports, printer));\n        LOGGER.info(\"json reports: \\n{}\", jsonOutput);\n        assertFalse(\"json reports should not be empty\", jsonOutput.isEmpty());\n\n        List<CheckReport> readReports = uncheck0(() ->\n                ReportMapper.readReports(() -> new BufferedReader(new StringReader(jsonOutput)))).get();\n        for (int i = 0; i < reports.size(); i++) {\n            assertEquals(\"read report should match input report at index \" + i,\n                    reports.get(i), readReports.get(i));\n        }\n    }", "signature": "void testWriteReports()", "full_signature": "@Test public void testWriteReports()", "class_method_signature": "CommandTest.testWriteReports()", "testcase": true, "constructor": false, "invocations": ["add", "emptyList", "add", "asList", "fromString", "fromString", "fromString", "fromString", "captureStructured", "printReports", "info", "assertFalse", "isEmpty", "captureStructured", "printReports", "info", "assertFalse", "isEmpty", "get", "uncheck0", "readReports", "size", "assertEquals", "get", "get"]}, "focal_class": {"identifier": "Command", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(Command.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(Command.class)", "var_name": "LOGGER"}, {"original_string": "private static final String SHORT_NO_OPT_PREFIX = \"+\";", "modifier": "private static final", "type": "String", "declarator": "SHORT_NO_OPT_PREFIX = \"+\"", "var_name": "SHORT_NO_OPT_PREFIX"}, {"original_string": "private static final String LONG_NO_OPT_PREFIX = \"--no-\";", "modifier": "private static final", "type": "String", "declarator": "LONG_NO_OPT_PREFIX = \"--no-\"", "var_name": "LONG_NO_OPT_PREFIX"}, {"original_string": "private static final String VERSION_PROPERTIES_NAME = \"version.properties\";", "modifier": "private static final", "type": "String", "declarator": "VERSION_PROPERTIES_NAME = \"version.properties\"", "var_name": "VERSION_PROPERTIES_NAME"}, {"original_string": "private static final String COMMAND_HELP_TXT = \"help.txt\";", "modifier": "private static final", "type": "String", "declarator": "COMMAND_HELP_TXT = \"help.txt\"", "var_name": "COMMAND_HELP_TXT"}, {"original_string": "static final Integer EXIT_GENERAL_ERROR = 1;", "modifier": "static final", "type": "Integer", "declarator": "EXIT_GENERAL_ERROR = 1", "var_name": "EXIT_GENERAL_ERROR"}, {"original_string": "static final Integer EXIT_ABORTED_SCAN = 9;", "modifier": "static final", "type": "Integer", "declarator": "EXIT_ABORTED_SCAN = 9", "var_name": "EXIT_ABORTED_SCAN"}, {"original_string": "static final Integer EXIT_SEVERE_VIOLATION = 10;", "modifier": "static final", "type": "Integer", "declarator": "EXIT_SEVERE_VIOLATION = 10", "var_name": "EXIT_SEVERE_VIOLATION"}, {"original_string": "static final Integer EXIT_MAJOR_VIOLATION = 11;", "modifier": "static final", "type": "Integer", "declarator": "EXIT_MAJOR_VIOLATION = 11", "var_name": "EXIT_MAJOR_VIOLATION"}, {"original_string": "static final Integer EXIT_MINOR_VIOLATION = 12;", "modifier": "static final", "type": "Integer", "declarator": "EXIT_MINOR_VIOLATION = 12", "var_name": "EXIT_MINOR_VIOLATION"}], "methods": [{"identifier": "perform", "parameters": "(final @NotNull Console console, final @NotNull String[] args)", "modifiers": "", "return": "IO<Integer>", "signature": "IO<Integer> perform(final @NotNull Console console, final @NotNull String[] args)", "full_signature": " IO<Integer> perform(final @NotNull Console console, final @NotNull String[] args)", "class_method_signature": "Command.perform(final @NotNull Console console, final @NotNull String[] args)", "testcase": false, "constructor": false}, {"identifier": "getNodeStoreSupplier", "parameters": "(final @NotNull Options opts)", "modifiers": "", "return": "Supplier<NodeStore>", "signature": "Supplier<NodeStore> getNodeStoreSupplier(final @NotNull Options opts)", "full_signature": " Supplier<NodeStore> getNodeStoreSupplier(final @NotNull Options opts)", "class_method_signature": "Command.getNodeStoreSupplier(final @NotNull Options opts)", "testcase": false, "constructor": false}, {"identifier": "doScan", "parameters": "(final @NotNull Console console, final @NotNull Options opts)", "modifiers": "", "return": "IO<Integer>", "signature": "IO<Integer> doScan(final @NotNull Console console, final @NotNull Options opts)", "full_signature": " IO<Integer> doScan(final @NotNull Console console, final @NotNull Options opts)", "class_method_signature": "Command.doScan(final @NotNull Console console, final @NotNull Options opts)", "testcase": false, "constructor": false}, {"identifier": "runOakScan", "parameters": "(final @NotNull Options opts, final @NotNull OakMachine oak)", "modifiers": "", "return": "Result<List<CheckReport>>", "signature": "Result<List<CheckReport>> runOakScan(final @NotNull Options opts, final @NotNull OakMachine oak)", "full_signature": " Result<List<CheckReport>> runOakScan(final @NotNull Options opts, final @NotNull OakMachine oak)", "class_method_signature": "Command.runOakScan(final @NotNull Options opts, final @NotNull OakMachine oak)", "testcase": false, "constructor": false}, {"identifier": "getHighestReportSeverity", "parameters": "(final @NotNull Options opts,\n                                               final @NotNull List<CheckReport> reports)", "modifiers": "", "return": "Optional<Integer>", "signature": "Optional<Integer> getHighestReportSeverity(final @NotNull Options opts,\n                                               final @NotNull List<CheckReport> reports)", "full_signature": " Optional<Integer> getHighestReportSeverity(final @NotNull Options opts,\n                                               final @NotNull List<CheckReport> reports)", "class_method_signature": "Command.getHighestReportSeverity(final @NotNull Options opts,\n                                               final @NotNull List<CheckReport> reports)", "testcase": false, "constructor": false}, {"identifier": "printReports", "parameters": "(final @NotNull List<CheckReport> reports,\n                             final @NotNull Function<StructuredMessage, IO<Nothing>> linePrinter)", "modifiers": "", "return": "IO<Nothing>", "signature": "IO<Nothing> printReports(final @NotNull List<CheckReport> reports,\n                             final @NotNull Function<StructuredMessage, IO<Nothing>> linePrinter)", "full_signature": " IO<Nothing> printReports(final @NotNull List<CheckReport> reports,\n                             final @NotNull Function<StructuredMessage, IO<Nothing>> linePrinter)", "class_method_signature": "Command.printReports(final @NotNull List<CheckReport> reports,\n                             final @NotNull Function<StructuredMessage, IO<Nothing>> linePrinter)", "testcase": false, "constructor": false}, {"identifier": "printHelp", "parameters": "(final @NotNull Function<Object, IO<Nothing>> linePrinter)", "modifiers": "", "return": "IO<Nothing>", "signature": "IO<Nothing> printHelp(final @NotNull Function<Object, IO<Nothing>> linePrinter)", "full_signature": " IO<Nothing> printHelp(final @NotNull Function<Object, IO<Nothing>> linePrinter)", "class_method_signature": "Command.printHelp(final @NotNull Function<Object, IO<Nothing>> linePrinter)", "testcase": false, "constructor": false}, {"identifier": "printVersion", "parameters": "(final @NotNull Function<Object, IO<Nothing>> linePrinter)", "modifiers": "", "return": "IO<Nothing>", "signature": "IO<Nothing> printVersion(final @NotNull Function<Object, IO<Nothing>> linePrinter)", "full_signature": " IO<Nothing> printVersion(final @NotNull Function<Object, IO<Nothing>> linePrinter)", "class_method_signature": "Command.printVersion(final @NotNull Function<Object, IO<Nothing>> linePrinter)", "testcase": false, "constructor": false}, {"identifier": "flipOpt", "parameters": "(final @NotNull String wholeOpt)", "modifiers": "", "return": "Optional<String>", "signature": "Optional<String> flipOpt(final @NotNull String wholeOpt)", "full_signature": " Optional<String> flipOpt(final @NotNull String wholeOpt)", "class_method_signature": "Command.flipOpt(final @NotNull String wholeOpt)", "testcase": false, "constructor": false}, {"identifier": "parseArgs", "parameters": "(final @NotNull Console console, final @NotNull String[] args)", "modifiers": "@NotNull", "return": "Result<Options>", "signature": "Result<Options> parseArgs(final @NotNull Console console, final @NotNull String[] args)", "full_signature": "@NotNull Result<Options> parseArgs(final @NotNull Console console, final @NotNull String[] args)", "class_method_signature": "Command.parseArgs(final @NotNull Console console, final @NotNull String[] args)", "testcase": false, "constructor": false}], "file": "cli/src/main/java/net/adamcin/oakpal/cli/Command.java"}, "focal_method": {"identifier": "printReports", "parameters": "(final @NotNull List<CheckReport> reports,\n                             final @NotNull Function<StructuredMessage, IO<Nothing>> linePrinter)", "modifiers": "", "return": "IO<Nothing>", "body": "IO<Nothing> printReports(final @NotNull List<CheckReport> reports,\n                             final @NotNull Function<StructuredMessage, IO<Nothing>> linePrinter) {\n        return linePrinter.apply(new AllReportsMessage(reports));\n    }", "signature": "IO<Nothing> printReports(final @NotNull List<CheckReport> reports,\n                             final @NotNull Function<StructuredMessage, IO<Nothing>> linePrinter)", "full_signature": " IO<Nothing> printReports(final @NotNull List<CheckReport> reports,\n                             final @NotNull Function<StructuredMessage, IO<Nothing>> linePrinter)", "class_method_signature": "Command.printReports(final @NotNull List<CheckReport> reports,\n                             final @NotNull Function<StructuredMessage, IO<Nothing>> linePrinter)", "testcase": false, "constructor": false, "invocations": ["apply"]}, "repository": {"repo_id": 155883728, "url": "https://github.com/adamcin/oakpal", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 6, "size": 13349, "license": "licensed"}}