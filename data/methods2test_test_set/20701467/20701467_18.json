{"test_class": {"identifier": "PacketDispatcherTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Mock\n    private PacketProcessingService packetProcessingService;", "modifier": "@Mock\n    private", "type": "PacketProcessingService", "declarator": "packetProcessingService", "var_name": "packetProcessingService"}, {"original_string": "@Mock\n    private InventoryReader inventoryReader;", "modifier": "@Mock\n    private", "type": "InventoryReader", "declarator": "inventoryReader", "var_name": "inventoryReader"}, {"original_string": "private PacketDispatcher packetDispatcher;", "modifier": "private", "type": "PacketDispatcher", "declarator": "packetDispatcher", "var_name": "packetDispatcher"}], "file": "arphandler/src/test/java/org/opendaylight/l2switch/arphandler/core/PacketDispatcherTest.java"}, "test_case": {"identifier": "testDispatchPacket_toSendPacketOut", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testDispatchPacket_toSendPacketOut() throws Exception {\n        InstanceIdentifier<NodeConnector> ncInsId1 = InstanceIdentifier.builder(Nodes.class)\n                .child(Node.class, new NodeKey(new NodeId(\"1\")))\n                .child(NodeConnector.class, new NodeConnectorKey(new NodeConnectorId(\"1\"))).build();\n        NodeConnectorRef ncRef1 = new NodeConnectorRef(ncInsId1);\n        HashMap<String, NodeConnectorRef> controllerSwitchConnectors = Mockito.mock(HashMap.class);\n        when(controllerSwitchConnectors.get(any(String.class))).thenReturn(ncRef1);\n        when(inventoryReader.getControllerSwitchConnectors()).thenReturn(controllerSwitchConnectors);\n        when(inventoryReader.getNodeConnector(any(InstanceIdentifier.class), any(MacAddress.class))).thenReturn(ncRef1);\n\n        packetDispatcher.dispatchPacket(null, new NodeConnectorRef(ncInsId1), null, null);\n        verify(inventoryReader, times(1)).readInventory();\n        verify(inventoryReader, times(0)).setRefreshData(true);\n        verify(packetProcessingService, times(1)).transmitPacket(any(TransmitPacketInput.class));\n    }", "signature": "void testDispatchPacket_toSendPacketOut()", "full_signature": "@Test public void testDispatchPacket_toSendPacketOut()", "class_method_signature": "PacketDispatcherTest.testDispatchPacket_toSendPacketOut()", "testcase": true, "constructor": false, "invocations": ["build", "child", "child", "builder", "mock", "thenReturn", "when", "get", "any", "thenReturn", "when", "getControllerSwitchConnectors", "thenReturn", "when", "getNodeConnector", "any", "any", "dispatchPacket", "readInventory", "verify", "times", "setRefreshData", "verify", "times", "transmitPacket", "verify", "times", "any"]}, "focal_class": {"identifier": "PacketDispatcher", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(PacketDispatcher.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(PacketDispatcher.class)", "var_name": "LOG"}, {"original_string": "private InventoryReader inventoryReader;", "modifier": "private", "type": "InventoryReader", "declarator": "inventoryReader", "var_name": "inventoryReader"}, {"original_string": "private PacketProcessingService packetProcessingService;", "modifier": "private", "type": "PacketProcessingService", "declarator": "packetProcessingService", "var_name": "packetProcessingService"}], "methods": [{"identifier": "setPacketProcessingService", "parameters": "(PacketProcessingService packetProcessingService)", "modifiers": "public", "return": "void", "signature": "void setPacketProcessingService(PacketProcessingService packetProcessingService)", "full_signature": "public void setPacketProcessingService(PacketProcessingService packetProcessingService)", "class_method_signature": "PacketDispatcher.setPacketProcessingService(PacketProcessingService packetProcessingService)", "testcase": false, "constructor": false}, {"identifier": "setInventoryReader", "parameters": "(InventoryReader inventoryReader)", "modifiers": "public", "return": "void", "signature": "void setInventoryReader(InventoryReader inventoryReader)", "full_signature": "public void setInventoryReader(InventoryReader inventoryReader)", "class_method_signature": "PacketDispatcher.setInventoryReader(InventoryReader inventoryReader)", "testcase": false, "constructor": false}, {"identifier": "dispatchPacket", "parameters": "(byte[] payload, NodeConnectorRef ingress, MacAddress srcMac, MacAddress destMac)", "modifiers": "public", "return": "void", "signature": "void dispatchPacket(byte[] payload, NodeConnectorRef ingress, MacAddress srcMac, MacAddress destMac)", "full_signature": "public void dispatchPacket(byte[] payload, NodeConnectorRef ingress, MacAddress srcMac, MacAddress destMac)", "class_method_signature": "PacketDispatcher.dispatchPacket(byte[] payload, NodeConnectorRef ingress, MacAddress srcMac, MacAddress destMac)", "testcase": false, "constructor": false}, {"identifier": "floodPacket", "parameters": "(String nodeId, byte[] payload, NodeConnectorRef origIngress,\n            NodeConnectorRef controllerNodeConnector)", "modifiers": "public", "return": "void", "signature": "void floodPacket(String nodeId, byte[] payload, NodeConnectorRef origIngress,\n            NodeConnectorRef controllerNodeConnector)", "full_signature": "public void floodPacket(String nodeId, byte[] payload, NodeConnectorRef origIngress,\n            NodeConnectorRef controllerNodeConnector)", "class_method_signature": "PacketDispatcher.floodPacket(String nodeId, byte[] payload, NodeConnectorRef origIngress,\n            NodeConnectorRef controllerNodeConnector)", "testcase": false, "constructor": false}, {"identifier": "sendPacketOut", "parameters": "(byte[] payload, NodeConnectorRef ingress, NodeConnectorRef egress)", "modifiers": "public", "return": "void", "signature": "void sendPacketOut(byte[] payload, NodeConnectorRef ingress, NodeConnectorRef egress)", "full_signature": "public void sendPacketOut(byte[] payload, NodeConnectorRef ingress, NodeConnectorRef egress)", "class_method_signature": "PacketDispatcher.sendPacketOut(byte[] payload, NodeConnectorRef ingress, NodeConnectorRef egress)", "testcase": false, "constructor": false}, {"identifier": "refreshInventoryReader", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void refreshInventoryReader()", "full_signature": "private void refreshInventoryReader()", "class_method_signature": "PacketDispatcher.refreshInventoryReader()", "testcase": false, "constructor": false}, {"identifier": "getNodePath", "parameters": "(final InstanceIdentifier<?> nodeChild)", "modifiers": "private", "return": "InstanceIdentifier<Node>", "signature": "InstanceIdentifier<Node> getNodePath(final InstanceIdentifier<?> nodeChild)", "full_signature": "private InstanceIdentifier<Node> getNodePath(final InstanceIdentifier<?> nodeChild)", "class_method_signature": "PacketDispatcher.getNodePath(final InstanceIdentifier<?> nodeChild)", "testcase": false, "constructor": false}], "file": "arphandler/src/main/java/org/opendaylight/l2switch/arphandler/core/PacketDispatcher.java"}, "focal_method": {"identifier": "dispatchPacket", "parameters": "(byte[] payload, NodeConnectorRef ingress, MacAddress srcMac, MacAddress destMac)", "modifiers": "public", "return": "void", "body": "public void dispatchPacket(byte[] payload, NodeConnectorRef ingress, MacAddress srcMac, MacAddress destMac) {\n        inventoryReader.readInventory();\n\n        String nodeId = ingress.getValue().firstIdentifierOf(Node.class).firstKeyOf(Node.class, NodeKey.class).getId()\n                .getValue();\n        NodeConnectorRef srcConnectorRef = inventoryReader.getControllerSwitchConnectors().get(nodeId);\n\n        if (srcConnectorRef == null) {\n            refreshInventoryReader();\n            srcConnectorRef = inventoryReader.getControllerSwitchConnectors().get(nodeId);\n        }\n        NodeConnectorRef destNodeConnector = inventoryReader\n                .getNodeConnector(ingress.getValue().firstIdentifierOf(Node.class), destMac);\n        if (srcConnectorRef != null) {\n            if (destNodeConnector != null) {\n                sendPacketOut(payload, srcConnectorRef, destNodeConnector);\n            } else {\n                floodPacket(nodeId, payload, ingress, srcConnectorRef);\n            }\n        } else {\n            LOG.info(\"Cannot send packet out or flood as controller node connector is not available for node {}.\",\n                    nodeId);\n        }\n    }", "signature": "void dispatchPacket(byte[] payload, NodeConnectorRef ingress, MacAddress srcMac, MacAddress destMac)", "full_signature": "public void dispatchPacket(byte[] payload, NodeConnectorRef ingress, MacAddress srcMac, MacAddress destMac)", "class_method_signature": "PacketDispatcher.dispatchPacket(byte[] payload, NodeConnectorRef ingress, MacAddress srcMac, MacAddress destMac)", "testcase": false, "constructor": false, "invocations": ["readInventory", "getValue", "getId", "firstKeyOf", "firstIdentifierOf", "getValue", "get", "getControllerSwitchConnectors", "refreshInventoryReader", "get", "getControllerSwitchConnectors", "getNodeConnector", "firstIdentifierOf", "getValue", "sendPacketOut", "floodPacket", "info"]}, "repository": {"repo_id": 20701467, "url": "https://github.com/opendaylight/l2switch", "language": "Java", "is_fork": false, "fork_count": 30, "stargazer_count": 25, "size": 4178, "license": "licensed"}}