{"test_class": {"identifier": "UPSTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String PATCH_CORRUPTED = \"The patch file is corrupted.\";", "modifier": "private static final", "type": "String", "declarator": "PATCH_CORRUPTED = \"The patch file is corrupted.\"", "var_name": "PATCH_CORRUPTED"}, {"original_string": "@Rule\n    public TemporaryFolder folder = new TemporaryFolder();", "modifier": "@Rule\n    public", "type": "TemporaryFolder", "declarator": "folder = new TemporaryFolder()", "var_name": "folder"}, {"original_string": "@Mock\n    Context mockContext;", "modifier": "@Mock", "type": "Context", "declarator": "mockContext", "var_name": "mockContext"}], "file": "app/src/test/java/org/emunix/unipatcher/patcher/UPSTest.java"}, "test_case": {"identifier": "testApply", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testApply() throws Exception {\n        assertTrue(ApplyPatch(\"/ups/readUpsCrc.ups\", \"/ups/readUpsCrc.bin\", \"/ups/readUpsCrc_m.bin\"));\n    }", "signature": "void testApply()", "full_signature": "@Test public void testApply()", "class_method_signature": "UPSTest.testApply()", "testcase": true, "constructor": false, "invocations": ["assertTrue", "ApplyPatch"]}, "focal_class": {"identifier": "UPS", "superclass": "extends Patcher", "interfaces": "", "fields": [{"original_string": "private static final byte[] MAGIC_NUMBER = {0x55, 0x50, 0x53, 0x31};", "modifier": "private static final", "type": "byte[]", "declarator": "MAGIC_NUMBER = {0x55, 0x50, 0x53, 0x31}", "var_name": "MAGIC_NUMBER"}], "methods": [{"identifier": "UPS", "parameters": "(Context context, File patch, File rom, File output)", "modifiers": "public", "return": "", "signature": " UPS(Context context, File patch, File rom, File output)", "full_signature": "public  UPS(Context context, File patch, File rom, File output)", "class_method_signature": "UPS.UPS(Context context, File patch, File rom, File output)", "testcase": false, "constructor": true}, {"identifier": "apply", "parameters": "(boolean ignoreChecksum)", "modifiers": "@Override public", "return": "void", "signature": "void apply(boolean ignoreChecksum)", "full_signature": "@Override public void apply(boolean ignoreChecksum)", "class_method_signature": "UPS.apply(boolean ignoreChecksum)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(BufferedInputStream stream)", "modifiers": "private", "return": "Pair", "signature": "Pair decode(BufferedInputStream stream)", "full_signature": "private Pair decode(BufferedInputStream stream)", "class_method_signature": "UPS.decode(BufferedInputStream stream)", "testcase": false, "constructor": false}, {"identifier": "checkMagic", "parameters": "(File f)", "modifiers": "public static", "return": "boolean", "signature": "boolean checkMagic(File f)", "full_signature": "public static boolean checkMagic(File f)", "class_method_signature": "UPS.checkMagic(File f)", "testcase": false, "constructor": false}, {"identifier": "readUpsCrc", "parameters": "(Context context, File f)", "modifiers": "public static", "return": "UpsCrc", "signature": "UpsCrc readUpsCrc(Context context, File f)", "full_signature": "public static UpsCrc readUpsCrc(Context context, File f)", "class_method_signature": "UPS.readUpsCrc(Context context, File f)", "testcase": false, "constructor": false}, {"identifier": "readLong", "parameters": "(BufferedInputStream stream)", "modifiers": "private static", "return": "long", "signature": "long readLong(BufferedInputStream stream)", "full_signature": "private static long readLong(BufferedInputStream stream)", "class_method_signature": "UPS.readLong(BufferedInputStream stream)", "testcase": false, "constructor": false}], "file": "app/src/main/java/org/emunix/unipatcher/patcher/UPS.java"}, "focal_method": {"identifier": "apply", "parameters": "(boolean ignoreChecksum)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void apply(boolean ignoreChecksum) throws PatchException, IOException {\n\n        if (patchFile.length() < 18) {\n            throw new PatchException(context.getString(R.string.notify_error_patch_corrupted));\n        }\n\n        BufferedInputStream patchStream = null;\n        BufferedInputStream romStream = null;\n        BufferedOutputStream outputStream = null;\n        UpsCrc upsCrc;\n        try {\n            if (!checkMagic(patchFile))\n                throw new PatchException(context.getString(R.string.notify_error_not_ups_patch));\n\n            upsCrc = readUpsCrc(context, patchFile);\n            if (upsCrc.getPatchFileCRC() != upsCrc.getRealPatchCRC())\n                throw new PatchException(context.getString(R.string.notify_error_patch_corrupted));\n\n            patchStream = new BufferedInputStream(new FileInputStream(patchFile));\n            long patchPos = 0;\n            // skip magic\n            for (int i = 0; i < 4; i++) {\n                patchStream.read();\n            }\n            patchPos += 4;\n\n            // decode rom and output size\n            Pair p;\n            p = decode(patchStream);\n            long xSize = p.getValue();\n            patchPos += p.getSize();\n            p = decode(patchStream);\n            long ySize = p.getValue();\n            patchPos += p.getSize();\n\n            long realRomCrc = FileUtils.checksumCRC32(romFile);\n\n            if (romFile.length() == xSize && realRomCrc == upsCrc.getInputFileCRC()) {\n                // xSize, ySize, inCRC, outCRC not change\n            } else if (romFile.length() == ySize && realRomCrc == upsCrc.getOutputFileCRC()) {\n                // swap(xSize, ySize) and swap(inCRC, outCRC)\n                long tmp = xSize;\n                xSize = ySize;\n                ySize = tmp;\n                upsCrc.swapInOut();\n            } else {\n                if (!ignoreChecksum) {\n                    throw new IOException(context.getString(R.string.notify_error_rom_not_compatible_with_patch));\n                }\n            }\n\n            romStream = new BufferedInputStream(new FileInputStream(romFile));\n            outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n            long outPos = 0;\n\n            int x, y;\n            long offset = 0;\n            while (patchPos < patchFile.length() - 12) {\n                p = decode(patchStream);\n                offset += p.getValue();\n                patchPos += p.getSize();\n                if (offset > ySize) continue;\n                Utils.INSTANCE.copy(romStream, outputStream, offset - outPos);\n                outPos += offset - outPos;\n                for (long i = offset; i < ySize; i++) {\n                    x = patchStream.read();\n                    patchPos++;\n                    offset++;\n                    if (x == 0x00) break; // chunk terminating byte - 0x00\n                    y = i < xSize ? romStream.read() : 0x00;\n                    outputStream.write(x ^ y);\n                    outPos++;\n                }\n            }\n            // write rom tail and trim\n            Utils.INSTANCE.copy(romStream, outputStream, ySize - outPos);\n\n        } finally {\n            IOUtils.closeQuietly(patchStream);\n            IOUtils.closeQuietly(romStream);\n            IOUtils.closeQuietly(outputStream);\n        }\n\n        if (!ignoreChecksum) {\n            long realOutCrc = FileUtils.checksumCRC32(outputFile);\n            if (realOutCrc != upsCrc.getOutputFileCRC())\n                throw new PatchException(context.getString(R.string.notify_error_wrong_checksum_after_patching));\n        }\n    }", "signature": "void apply(boolean ignoreChecksum)", "full_signature": "@Override public void apply(boolean ignoreChecksum)", "class_method_signature": "UPS.apply(boolean ignoreChecksum)", "testcase": false, "constructor": false, "invocations": ["length", "getString", "checkMagic", "getString", "readUpsCrc", "getPatchFileCRC", "getRealPatchCRC", "getString", "read", "decode", "getValue", "getSize", "decode", "getValue", "getSize", "checksumCRC32", "length", "getInputFileCRC", "length", "getOutputFileCRC", "swapInOut", "getString", "length", "decode", "getValue", "getSize", "copy", "read", "read", "write", "copy", "closeQuietly", "closeQuietly", "closeQuietly", "checksumCRC32", "getOutputFileCRC", "getString"]}, "repository": {"repo_id": 69356520, "url": "https://github.com/btimofeev/UniPatcher", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 34, "size": 1720, "license": "licensed"}}