{"test_class": {"identifier": "Poly1305Test", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Charset UTF_8 = Charset.forName(\"UTF-8\");", "modifier": "private static final", "type": "Charset", "declarator": "UTF_8 = Charset.forName(\"UTF-8\")", "var_name": "UTF_8"}], "file": "java_src/src/test/java/com/google/crypto/tink/subtle/Poly1305Test.java"}, "test_case": {"identifier": "testPoly1305TestVector2", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testPoly1305TestVector2() throws GeneralSecurityException {\n    byte[] key = TestUtil.hexDecode(\"\"\n        + \"00000000000000000000000000000000\"\n        + \"36e5f6b5c5e06070f0efca96227a863e\");\n    byte[] in = (\n        \"Any submission to the IETF intended by the Contributor for publication as all or \"\n            + \"part of an IETF Internet-Draft or RFC and any statement made within the context \"\n            + \"of an IETF activity is considered an \\\"IETF Contribution\\\". Such statements \"\n            + \"include oral statements in IETF sessions, as well as written and electronic \"\n            + \"communications made at any time or place, which are addressed to\")\n        .getBytes(UTF_8);\n    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode(\"\"\n        + \"36e5f6b5c5e06070f0efca96227a863e\"));\n  }", "signature": "void testPoly1305TestVector2()", "full_signature": "@Test public void testPoly1305TestVector2()", "class_method_signature": "Poly1305Test.testPoly1305TestVector2()", "testcase": true, "constructor": false, "invocations": ["hexDecode", "getBytes", "isEqualTo", "assertThat", "computeMac", "hexDecode"]}, "focal_class": {"identifier": "Poly1305", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final int MAC_TAG_SIZE_IN_BYTES = 16;", "modifier": "public static final", "type": "int", "declarator": "MAC_TAG_SIZE_IN_BYTES = 16", "var_name": "MAC_TAG_SIZE_IN_BYTES"}, {"original_string": "public static final int MAC_KEY_SIZE_IN_BYTES = 32;", "modifier": "public static final", "type": "int", "declarator": "MAC_KEY_SIZE_IN_BYTES = 32", "var_name": "MAC_KEY_SIZE_IN_BYTES"}], "methods": [{"identifier": "Poly1305", "parameters": "()", "modifiers": "private", "return": "", "signature": " Poly1305()", "full_signature": "private  Poly1305()", "class_method_signature": "Poly1305.Poly1305()", "testcase": false, "constructor": true}, {"identifier": "load32", "parameters": "(byte[] in, int idx)", "modifiers": "private static", "return": "long", "signature": "long load32(byte[] in, int idx)", "full_signature": "private static long load32(byte[] in, int idx)", "class_method_signature": "Poly1305.load32(byte[] in, int idx)", "testcase": false, "constructor": false}, {"identifier": "load26", "parameters": "(byte[] in, int idx, int shift)", "modifiers": "private static", "return": "long", "signature": "long load26(byte[] in, int idx, int shift)", "full_signature": "private static long load26(byte[] in, int idx, int shift)", "class_method_signature": "Poly1305.load26(byte[] in, int idx, int shift)", "testcase": false, "constructor": false}, {"identifier": "toByteArray", "parameters": "(byte[] output, long num, int idx)", "modifiers": "private static", "return": "void", "signature": "void toByteArray(byte[] output, long num, int idx)", "full_signature": "private static void toByteArray(byte[] output, long num, int idx)", "class_method_signature": "Poly1305.toByteArray(byte[] output, long num, int idx)", "testcase": false, "constructor": false}, {"identifier": "copyBlockSize", "parameters": "(byte[] output, byte[] in, int idx)", "modifiers": "private static", "return": "void", "signature": "void copyBlockSize(byte[] output, byte[] in, int idx)", "full_signature": "private static void copyBlockSize(byte[] output, byte[] in, int idx)", "class_method_signature": "Poly1305.copyBlockSize(byte[] output, byte[] in, int idx)", "testcase": false, "constructor": false}, {"identifier": "computeMac", "parameters": "(final byte[] key, byte[] data)", "modifiers": "static", "return": "byte[]", "signature": "byte[] computeMac(final byte[] key, byte[] data)", "full_signature": "static byte[] computeMac(final byte[] key, byte[] data)", "class_method_signature": "Poly1305.computeMac(final byte[] key, byte[] data)", "testcase": false, "constructor": false}, {"identifier": "verifyMac", "parameters": "(final byte[] key, byte[] data, byte[] mac)", "modifiers": "static", "return": "void", "signature": "void verifyMac(final byte[] key, byte[] data, byte[] mac)", "full_signature": "static void verifyMac(final byte[] key, byte[] data, byte[] mac)", "class_method_signature": "Poly1305.verifyMac(final byte[] key, byte[] data, byte[] mac)", "testcase": false, "constructor": false}], "file": "java_src/src/main/java/com/google/crypto/tink/subtle/Poly1305.java"}, "focal_method": {"identifier": "computeMac", "parameters": "(final byte[] key, byte[] data)", "modifiers": "static", "return": "byte[]", "body": "static byte[] computeMac(final byte[] key, byte[] data) {\n    if (key.length != MAC_KEY_SIZE_IN_BYTES) {\n      throw new IllegalArgumentException(\"The key length in bytes must be 32.\");\n    }\n    long h0 = 0;\n    long h1 = 0;\n    long h2 = 0;\n    long h3 = 0;\n    long h4 = 0;\n    long d0;\n    long d1;\n    long d2;\n    long d3;\n    long d4;\n    long c;\n\n    // r &= 0xffffffc0ffffffc0ffffffc0fffffff\n    long r0 = load26(key, 0, 0) & 0x3ffffff;\n    long r1 = load26(key, 3, 2) & 0x3ffff03;\n    long r2 = load26(key, 6, 4) & 0x3ffc0ff;\n    long r3 = load26(key, 9, 6) & 0x3f03fff;\n    long r4 = load26(key, 12, 8) & 0x00fffff;\n\n    long s1 = r1 * 5;\n    long s2 = r2 * 5;\n    long s3 = r3 * 5;\n    long s4 = r4 * 5;\n\n    byte[] buf = new byte[MAC_TAG_SIZE_IN_BYTES + 1];\n    for (int i = 0; i < data.length; i += MAC_TAG_SIZE_IN_BYTES) {\n      copyBlockSize(buf, data, i);\n      h0 += load26(buf, 0, 0);\n      h1 += load26(buf, 3, 2);\n      h2 += load26(buf, 6, 4);\n      h3 += load26(buf, 9, 6);\n      h4 += load26(buf, 12, 8) | (buf[MAC_TAG_SIZE_IN_BYTES] << 24);\n\n      // d = r * h\n      d0 = h0 * r0 + h1 * s4 + h2 * s3 + h3 * s2 + h4 * s1;\n      d1 = h0 * r1 + h1 * r0 + h2 * s4 + h3 * s3 + h4 * s2;\n      d2 = h0 * r2 + h1 * r1 + h2 * r0 + h3 * s4 + h4 * s3;\n      d3 = h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * s4;\n      d4 = h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n\n      // Partial reduction mod 2^130-5, resulting h1 might not be 26bits.\n      c = d0 >> 26;\n      h0 = d0 & 0x3ffffff;\n      d1 += c;\n      c = d1 >> 26;\n      h1 = d1 & 0x3ffffff;\n      d2 += c;\n      c = d2 >> 26;\n      h2 = d2 & 0x3ffffff;\n      d3 += c;\n      c = d3 >> 26;\n      h3 = d3 & 0x3ffffff;\n      d4 += c;\n      c = d4 >> 26;\n      h4 = d4 & 0x3ffffff;\n      h0 += c * 5;\n      c = h0 >> 26;\n      h0 = h0 & 0x3ffffff;\n      h1 += c;\n    }\n    // Do final reduction mod 2^130-5\n    c = h1 >> 26;\n    h1 = h1 & 0x3ffffff;\n    h2 += c;\n    c = h2 >> 26;\n    h2 = h2 & 0x3ffffff;\n    h3 += c;\n    c = h3 >> 26;\n    h3 = h3 & 0x3ffffff;\n    h4 += c;\n    c = h4 >> 26;\n    h4 = h4 & 0x3ffffff;\n    h0 += c * 5; // c * 5 can be at most 5\n    c = h0 >> 26;\n    h0 = h0 & 0x3ffffff;\n    h1 += c;\n\n    // Compute h - p\n    long g0 = h0 + 5;\n    c = g0 >> 26;\n    g0 &= 0x3ffffff;\n    long g1 = h1 + c;\n    c = g1 >> 26;\n    g1 &= 0x3ffffff;\n    long g2 = h2 + c;\n    c = g2 >> 26;\n    g2 &= 0x3ffffff;\n    long g3 = h3 + c;\n    c = g3 >> 26;\n    g3 &= 0x3ffffff;\n    long g4 = h4 + c - (1 << 26);\n\n    // Select h if h < p, or h - p if h >= p\n    long mask = g4 >> 63; // mask is either 0 (h >= p) or -1 (h < p)\n    h0 &= mask;\n    h1 &= mask;\n    h2 &= mask;\n    h3 &= mask;\n    h4 &= mask;\n    mask = ~mask;\n    h0 |= g0 & mask;\n    h1 |= g1 & mask;\n    h2 |= g2 & mask;\n    h3 |= g3 & mask;\n    h4 |= g4 & mask;\n\n    // h = h % (2^128)\n    h0 = (h0 | (h1 << 26)) & 0xffffffffL;\n    h1 = ((h1 >> 6) | (h2 << 20)) & 0xffffffffL;\n    h2 = ((h2 >> 12) | (h3 << 14)) & 0xffffffffL;\n    h3 = ((h3 >> 18) | (h4 << 8)) & 0xffffffffL;\n\n    // mac = (h + pad) % (2^128)\n    c = h0 + load32(key, 16);\n    h0 = c & 0xffffffffL;\n    c = h1 + load32(key, 20) + (c >> 32);\n    h1 = c & 0xffffffffL;\n    c = h2 + load32(key, 24) + (c >> 32);\n    h2 = c & 0xffffffffL;\n    c = h3 + load32(key, 28) + (c >> 32);\n    h3 = c & 0xffffffffL;\n\n    byte[] mac = new byte[MAC_TAG_SIZE_IN_BYTES];\n    toByteArray(mac, h0, 0);\n    toByteArray(mac, h1, 4);\n    toByteArray(mac, h2, 8);\n    toByteArray(mac, h3, 12);\n\n    return mac;\n  }", "signature": "byte[] computeMac(final byte[] key, byte[] data)", "full_signature": "static byte[] computeMac(final byte[] key, byte[] data)", "class_method_signature": "Poly1305.computeMac(final byte[] key, byte[] data)", "testcase": false, "constructor": false, "invocations": ["load26", "load26", "load26", "load26", "load26", "copyBlockSize", "load26", "load26", "load26", "load26", "load26", "load32", "load32", "load32", "load32", "toByteArray", "toByteArray", "toByteArray", "toByteArray"]}, "repository": {"repo_id": 20570214, "url": "https://github.com/google/tink", "stars": 8884, "created": "6/6/2014 4:21:09 PM +00:00", "updates": "2020-01-27T11:52:16+00:00", "fork": "False", "license": "licensed"}}