{"test_class": {"identifier": "ProjectionHandlerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final double EPS = 1e-5;", "modifier": "static final", "type": "double", "declarator": "EPS = 1e-5", "var_name": "EPS"}, {"original_string": "static CoordinateReferenceSystem WGS84;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "WGS84", "var_name": "WGS84"}, {"original_string": "static CoordinateReferenceSystem ED50_LATLON;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "ED50_LATLON", "var_name": "ED50_LATLON"}, {"original_string": "static CoordinateReferenceSystem UTM32N;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "UTM32N", "var_name": "UTM32N"}, {"original_string": "static CoordinateReferenceSystem MERCATOR;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "MERCATOR", "var_name": "MERCATOR"}, {"original_string": "static CoordinateReferenceSystem MERCATOR_SHIFTED;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "MERCATOR_SHIFTED", "var_name": "MERCATOR_SHIFTED"}, {"original_string": "static CoordinateReferenceSystem ED50;", "modifier": "static", "type": "CoordinateReferenceSystem", "declarator": "ED50", "var_name": "ED50"}], "file": "modules/library/render/src/test/java/org/geotools/renderer/crs/ProjectionHandlerTest.java"}, "test_case": {"identifier": "testQueryWrappingPacificMercator", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testQueryWrappingPacificMercator() throws Exception {\n        // <wcs:DimensionTrim>\n        // <wcs:Dimension>N</wcs:Dimension>\n        // <wcs:TrimLow>0</wcs:TrimLow>\n        // <wcs:TrimHigh>4838471</wcs:TrimHigh>\n        // </wcs:DimensionTrim>\n        // <wcs:DimensionTrim>\n        // <wcs:Dimension>E</wcs:Dimension>\n        // <wcs:TrimLow>1113195</wcs:TrimLow>\n        // <wcs:TrimHigh>5565975</wcs:TrimHigh>\n        // </wcs:DimensionTrim>\n        // <wcs:format>image/tiff</wcs:format>\n        // <wcs:Extension>\n        // <!-- Mercator centered on 150\u00b0, request is roughly for long(160,-160),lat(0, 40)-->\n        // <wcscrs:subsettingCrs>http://www.opengis.net/def/crs/EPSG/0/3832</wcscrs:subsettingCrs>\n        //\n\n        CoordinateReferenceSystem crs = CRS.decode(\"EPSG:3832\");\n        ReferencedEnvelope mercatorEnvelope = new ReferencedEnvelope(1113195, 5565975, 0, 4838471,\n                crs);\n\n        // get query area, we expect two separate query envelopes across the dateline\n        ProjectionHandler handler = ProjectionHandlerFinder.getHandler(mercatorEnvelope, WGS84,\n                true);\n        List<ReferencedEnvelope> envelopes = handler.getQueryEnvelopes();\n        assertEquals(2, envelopes.size());\n\n        ReferencedEnvelope reOrig = envelopes.get(0);\n        assertEquals(160.0, reOrig.getMinX(), EPS);\n        assertEquals(180.0, reOrig.getMaxX(), EPS);\n\n        ReferencedEnvelope reAdded = envelopes.get(1);\n        assertEquals(-180.0, reAdded.getMinX(), EPS);\n        assertEquals(-160.0, reAdded.getMaxX(), EPS);\n    }", "signature": "void testQueryWrappingPacificMercator()", "full_signature": "@Test public void testQueryWrappingPacificMercator()", "class_method_signature": "ProjectionHandlerTest.testQueryWrappingPacificMercator()", "testcase": true, "constructor": false, "invocations": ["decode", "getHandler", "getQueryEnvelopes", "assertEquals", "size", "get", "assertEquals", "getMinX", "assertEquals", "getMaxX", "get", "assertEquals", "getMinX", "assertEquals", "getMaxX"]}, "focal_class": {"identifier": "ProjectionHandler", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final double EPS = 1e-6;", "modifier": "static final", "type": "double", "declarator": "EPS = 1e-6", "var_name": "EPS"}, {"original_string": "protected static final Logger LOGGER = org.geotools.util.logging.Logging.getLogger(ProjectionHandler.class);", "modifier": "protected static final", "type": "Logger", "declarator": "LOGGER = org.geotools.util.logging.Logging.getLogger(ProjectionHandler.class)", "var_name": "LOGGER"}, {"original_string": "ReferencedEnvelope renderingEnvelope;", "modifier": "", "type": "ReferencedEnvelope", "declarator": "renderingEnvelope", "var_name": "renderingEnvelope"}, {"original_string": "final ReferencedEnvelope validAreaBounds;", "modifier": "final", "type": "ReferencedEnvelope", "declarator": "validAreaBounds", "var_name": "validAreaBounds"}, {"original_string": "final Geometry validArea;", "modifier": "final", "type": "Geometry", "declarator": "validArea", "var_name": "validArea"}, {"original_string": "final PreparedGeometry validaAreaTester;", "modifier": "final", "type": "PreparedGeometry", "declarator": "validaAreaTester", "var_name": "validaAreaTester"}, {"original_string": "final CoordinateReferenceSystem sourceCRS;", "modifier": "final", "type": "CoordinateReferenceSystem", "declarator": "sourceCRS", "var_name": "sourceCRS"}, {"original_string": "final CoordinateReferenceSystem targetCRS;", "modifier": "final", "type": "CoordinateReferenceSystem", "declarator": "targetCRS", "var_name": "targetCRS"}, {"original_string": "double datelineX = Double.NaN;", "modifier": "", "type": "double", "declarator": "datelineX = Double.NaN", "var_name": "datelineX"}, {"original_string": "double radius = Double.NaN;", "modifier": "", "type": "double", "declarator": "radius = Double.NaN", "var_name": "radius"}], "methods": [{"identifier": "ProjectionHandler", "parameters": "(CoordinateReferenceSystem sourceCRS, Envelope validAreaBounds, ReferencedEnvelope renderingEnvelope)", "modifiers": "public", "return": "", "signature": " ProjectionHandler(CoordinateReferenceSystem sourceCRS, Envelope validAreaBounds, ReferencedEnvelope renderingEnvelope)", "full_signature": "public  ProjectionHandler(CoordinateReferenceSystem sourceCRS, Envelope validAreaBounds, ReferencedEnvelope renderingEnvelope)", "class_method_signature": "ProjectionHandler.ProjectionHandler(CoordinateReferenceSystem sourceCRS, Envelope validAreaBounds, ReferencedEnvelope renderingEnvelope)", "testcase": false, "constructor": true}, {"identifier": "ProjectionHandler", "parameters": "(CoordinateReferenceSystem sourceCRS, Geometry validArea, ReferencedEnvelope renderingEnvelope)", "modifiers": "public", "return": "", "signature": " ProjectionHandler(CoordinateReferenceSystem sourceCRS, Geometry validArea, ReferencedEnvelope renderingEnvelope)", "full_signature": "public  ProjectionHandler(CoordinateReferenceSystem sourceCRS, Geometry validArea, ReferencedEnvelope renderingEnvelope)", "class_method_signature": "ProjectionHandler.ProjectionHandler(CoordinateReferenceSystem sourceCRS, Geometry validArea, ReferencedEnvelope renderingEnvelope)", "testcase": false, "constructor": true}, {"identifier": "getRenderingEnvelope", "parameters": "()", "modifiers": "public", "return": "ReferencedEnvelope", "signature": "ReferencedEnvelope getRenderingEnvelope()", "full_signature": "public ReferencedEnvelope getRenderingEnvelope()", "class_method_signature": "ProjectionHandler.getRenderingEnvelope()", "testcase": false, "constructor": false}, {"identifier": "getSourceCRS", "parameters": "()", "modifiers": "public", "return": "CoordinateReferenceSystem", "signature": "CoordinateReferenceSystem getSourceCRS()", "full_signature": "public CoordinateReferenceSystem getSourceCRS()", "class_method_signature": "ProjectionHandler.getSourceCRS()", "testcase": false, "constructor": false}, {"identifier": "getQueryEnvelopes", "parameters": "()", "modifiers": "public", "return": "List<ReferencedEnvelope>", "signature": "List<ReferencedEnvelope> getQueryEnvelopes()", "full_signature": "public List<ReferencedEnvelope> getQueryEnvelopes()", "class_method_signature": "ProjectionHandler.getQueryEnvelopes()", "testcase": false, "constructor": false}, {"identifier": "getSourceEnvelopes", "parameters": "(ReferencedEnvelope renderingEnvelope)", "modifiers": "private", "return": "List<ReferencedEnvelope>", "signature": "List<ReferencedEnvelope> getSourceEnvelopes(ReferencedEnvelope renderingEnvelope)", "full_signature": "private List<ReferencedEnvelope> getSourceEnvelopes(ReferencedEnvelope renderingEnvelope)", "class_method_signature": "ProjectionHandler.getSourceEnvelopes(ReferencedEnvelope renderingEnvelope)", "testcase": false, "constructor": false}, {"identifier": "transformEnvelope", "parameters": "(ReferencedEnvelope envelope,\n            CoordinateReferenceSystem targetCRS)", "modifiers": "private", "return": "ReferencedEnvelope", "signature": "ReferencedEnvelope transformEnvelope(ReferencedEnvelope envelope,\n            CoordinateReferenceSystem targetCRS)", "full_signature": "private ReferencedEnvelope transformEnvelope(ReferencedEnvelope envelope,\n            CoordinateReferenceSystem targetCRS)", "class_method_signature": "ProjectionHandler.transformEnvelope(ReferencedEnvelope envelope,\n            CoordinateReferenceSystem targetCRS)", "testcase": false, "constructor": false}, {"identifier": "reprojectEnvelopes", "parameters": "(CoordinateReferenceSystem queryCRS,\n            List<ReferencedEnvelope> envelopes)", "modifiers": "protected", "return": "void", "signature": "void reprojectEnvelopes(CoordinateReferenceSystem queryCRS,\n            List<ReferencedEnvelope> envelopes)", "full_signature": "protected void reprojectEnvelopes(CoordinateReferenceSystem queryCRS,\n            List<ReferencedEnvelope> envelopes)", "class_method_signature": "ProjectionHandler.reprojectEnvelopes(CoordinateReferenceSystem queryCRS,\n            List<ReferencedEnvelope> envelopes)", "testcase": false, "constructor": false}, {"identifier": "mergeEnvelopes", "parameters": "(List<ReferencedEnvelope> envelopes)", "modifiers": "private", "return": "void", "signature": "void mergeEnvelopes(List<ReferencedEnvelope> envelopes)", "full_signature": "private void mergeEnvelopes(List<ReferencedEnvelope> envelopes)", "class_method_signature": "ProjectionHandler.mergeEnvelopes(List<ReferencedEnvelope> envelopes)", "testcase": false, "constructor": false}, {"identifier": "requiresProcessing", "parameters": "(Geometry geometry)", "modifiers": "public", "return": "boolean", "signature": "boolean requiresProcessing(Geometry geometry)", "full_signature": "public boolean requiresProcessing(Geometry geometry)", "class_method_signature": "ProjectionHandler.requiresProcessing(Geometry geometry)", "testcase": false, "constructor": false}, {"identifier": "preProcess", "parameters": "(Geometry geometry)", "modifiers": "public", "return": "Geometry", "signature": "Geometry preProcess(Geometry geometry)", "full_signature": "public Geometry preProcess(Geometry geometry)", "class_method_signature": "ProjectionHandler.preProcess(Geometry geometry)", "testcase": false, "constructor": false}, {"identifier": "intersect", "parameters": "(Geometry geometry, Geometry mask,\n            CoordinateReferenceSystem geometryCRS)", "modifiers": "private", "return": "Geometry", "signature": "Geometry intersect(Geometry geometry, Geometry mask,\n            CoordinateReferenceSystem geometryCRS)", "full_signature": "private Geometry intersect(Geometry geometry, Geometry mask,\n            CoordinateReferenceSystem geometryCRS)", "class_method_signature": "ProjectionHandler.intersect(Geometry geometry, Geometry mask,\n            CoordinateReferenceSystem geometryCRS)", "testcase": false, "constructor": false}, {"identifier": "getRenderingTransform", "parameters": "(MathTransform mt)", "modifiers": "public", "return": "MathTransform", "signature": "MathTransform getRenderingTransform(MathTransform mt)", "full_signature": "public MathTransform getRenderingTransform(MathTransform mt)", "class_method_signature": "ProjectionHandler.getRenderingTransform(MathTransform mt)", "testcase": false, "constructor": false}, {"identifier": "concatenateTransforms", "parameters": "(List<MathTransform> datumShiftChain)", "modifiers": "private", "return": "MathTransform", "signature": "MathTransform concatenateTransforms(List<MathTransform> datumShiftChain)", "full_signature": "private MathTransform concatenateTransforms(List<MathTransform> datumShiftChain)", "class_method_signature": "ProjectionHandler.concatenateTransforms(List<MathTransform> datumShiftChain)", "testcase": false, "constructor": false}, {"identifier": "accumulateTransforms", "parameters": "(MathTransform mt, List<MathTransform> elements)", "modifiers": "private", "return": "void", "signature": "void accumulateTransforms(MathTransform mt, List<MathTransform> elements)", "full_signature": "private void accumulateTransforms(MathTransform mt, List<MathTransform> elements)", "class_method_signature": "ProjectionHandler.accumulateTransforms(MathTransform mt, List<MathTransform> elements)", "testcase": false, "constructor": false}, {"identifier": "postProcess", "parameters": "(MathTransform mt, Geometry geometry)", "modifiers": "public", "return": "Geometry", "signature": "Geometry postProcess(MathTransform mt, Geometry geometry)", "full_signature": "public Geometry postProcess(MathTransform mt, Geometry geometry)", "class_method_signature": "ProjectionHandler.postProcess(MathTransform mt, Geometry geometry)", "testcase": false, "constructor": false}, {"identifier": "getValidAreaBounds", "parameters": "()", "modifiers": "public", "return": "ReferencedEnvelope", "signature": "ReferencedEnvelope getValidAreaBounds()", "full_signature": "public ReferencedEnvelope getValidAreaBounds()", "class_method_signature": "ProjectionHandler.getValidAreaBounds()", "testcase": false, "constructor": false}, {"identifier": "setCentralMeridian", "parameters": "(double centralMeridian)", "modifiers": "", "return": "void", "signature": "void setCentralMeridian(double centralMeridian)", "full_signature": " void setCentralMeridian(double centralMeridian)", "class_method_signature": "ProjectionHandler.setCentralMeridian(double centralMeridian)", "testcase": false, "constructor": false}, {"identifier": "addGeometries", "parameters": "(List<Geometry> geoms, GeometryCollection collection,\n            String geometryType)", "modifiers": "private", "return": "void", "signature": "void addGeometries(List<Geometry> geoms, GeometryCollection collection,\n            String geometryType)", "full_signature": "private void addGeometries(List<Geometry> geoms, GeometryCollection collection,\n            String geometryType)", "class_method_signature": "ProjectionHandler.addGeometries(List<Geometry> geoms, GeometryCollection collection,\n            String geometryType)", "testcase": false, "constructor": false}], "file": "modules/library/render/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java"}, "focal_method": {"identifier": "getQueryEnvelopes", "parameters": "()", "modifiers": "public", "return": "List<ReferencedEnvelope>", "body": "public List<ReferencedEnvelope> getQueryEnvelopes()\n            throws TransformException, FactoryException {\n        CoordinateReferenceSystem renderingCRS = renderingEnvelope.getCoordinateReferenceSystem();\n        if(renderingCRS instanceof GeographicCRS && !CRS.equalsIgnoreMetadata(renderingCRS, WGS84)) {\n            // special case, if we just transform the coordinates are going to be wrapped by the referencing\n            // subsystem directly\n            ReferencedEnvelope re = renderingEnvelope;\n            List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n            envelopes.add(re);\n\n            if(CRS.getAxisOrder(renderingCRS) == CRS.AxisOrder.NORTH_EAST) {\n                if (re.getMinY() >= -180.0 && re.getMaxY() <= 180) {\n                    return Collections\n                            .singletonList(transformEnvelope(renderingEnvelope, sourceCRS));\n                }\n                \n                // We need to split reprojected envelope and normalize it. To be lenient with\n                // situations in which the data is just broken (people saying 4326 just because they\n                // have no idea at all) we don't actually split, but add elements\n                if (re.getMinY() < -180) {\n                    envelopes.add(new ReferencedEnvelope(re.getMinY() + 360, 180, re.getMinX(), re\n                            .getMaxX(), re.getCoordinateReferenceSystem()));\n                }\n                if (re.getMaxY() > 180) {\n                    envelopes.add(new ReferencedEnvelope(-180, re.getMaxY() - 360, re.getMinX(), re\n                            .getMaxX(), re.getCoordinateReferenceSystem()));\n                }\n                \n            } else {\n                if (re.getMinX() >= -180.0 && re.getMaxX() <= 180) {\n                    return Collections\n                            .singletonList(transformEnvelope(renderingEnvelope, sourceCRS));\n                }\n            \n                // We need to split reprojected envelope and normalize it. To be lenient with\n                // situations in which the data is just broken (people saying 4326 just because they\n                // have no idea at all) we don't actually split, but add elements\n                \n                if (re.getMinX() < -180) {\n                    envelopes.add(new ReferencedEnvelope(re.getMinX() + 360, 180, re.getMinY(), re\n                            .getMaxY(), re.getCoordinateReferenceSystem()));\n                }\n                if (re.getMaxX() > 180) {\n                    envelopes.add(new ReferencedEnvelope(-180, re.getMaxX() - 360, re.getMinY(), re\n                            .getMaxY(), re.getCoordinateReferenceSystem()));\n                }\n            }\n    \n            mergeEnvelopes(envelopes);\n            reprojectEnvelopes(sourceCRS, envelopes);\n    \n            return envelopes;\n            \n            \n        } else {\n            if (!Double.isNaN(datelineX) && renderingEnvelope.getMinX() < datelineX\n                    && renderingEnvelope.getMaxX() > datelineX\n                    && renderingEnvelope.getWidth() < radius) {\n                double minX = renderingEnvelope.getMinX();\n                double minY = renderingEnvelope.getMinY();\n                double maxX = renderingEnvelope.getMaxX();\n                double maxY = renderingEnvelope.getMaxY();\n                ReferencedEnvelope re1 = new ReferencedEnvelope(minX, datelineX - EPS, minY,\n                        maxY, renderingCRS);\n                ReferencedEnvelope tx1 = transformEnvelope(re1, WGS84);\n                tx1.expandToInclude(180, tx1.getMinY());\n                ReferencedEnvelope re2 = new ReferencedEnvelope(datelineX + EPS, maxX, minY,\n                        maxY, renderingCRS);\n                ReferencedEnvelope tx2 = transformEnvelope(re2, WGS84);\n                if (tx2.getMinX() > 180) {\n                    tx2.translate(-360, 0);\n                }\n                tx2.expandToInclude(-180, tx1.getMinY());\n                List<ReferencedEnvelope> result = new ArrayList<ReferencedEnvelope>();\n                result.add(tx1);\n                result.add(tx2);\n                mergeEnvelopes(result);\n                return result;\n            } else {\n                return getSourceEnvelopes(renderingEnvelope);\n            }\n        }\n    }", "signature": "List<ReferencedEnvelope> getQueryEnvelopes()", "full_signature": "public List<ReferencedEnvelope> getQueryEnvelopes()", "class_method_signature": "ProjectionHandler.getQueryEnvelopes()", "testcase": false, "constructor": false, "invocations": ["getCoordinateReferenceSystem", "equalsIgnoreMetadata", "add", "getAxisOrder", "getMinY", "getMaxY", "singletonList", "transformEnvelope", "getMinY", "add", "getMinY", "getMinX", "getMaxX", "getCoordinateReferenceSystem", "getMaxY", "add", "getMaxY", "getMinX", "getMaxX", "getCoordinateReferenceSystem", "getMinX", "getMaxX", "singletonList", "transformEnvelope", "getMinX", "add", "getMinX", "getMinY", "getMaxY", "getCoordinateReferenceSystem", "getMaxX", "add", "getMaxX", "getMinY", "getMaxY", "getCoordinateReferenceSystem", "mergeEnvelopes", "reprojectEnvelopes", "isNaN", "getMinX", "getMaxX", "getWidth", "getMinX", "getMinY", "getMaxX", "getMaxY", "transformEnvelope", "expandToInclude", "getMinY", "transformEnvelope", "getMinX", "translate", "expandToInclude", "getMinY", "add", "add", "mergeEnvelopes", "getSourceEnvelopes"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}