{"test_class": {"identifier": "ChooseJoinAlgorithmTest", "superclass": "extends AbstractQueryTest", "interfaces": "", "fields": [{"original_string": "private ChooseJoinAlgorithm bestRule;", "modifier": "private", "type": "ChooseJoinAlgorithm", "declarator": "bestRule", "var_name": "bestRule"}, {"original_string": "private ChooseJoinAlgorithm nestedRule;", "modifier": "private", "type": "ChooseJoinAlgorithm", "declarator": "nestedRule", "var_name": "nestedRule"}, {"original_string": "private QueryContext context;", "modifier": "private", "type": "QueryContext", "declarator": "context", "var_name": "context"}], "file": "modeshape-jcr/src/test/java/org/modeshape/jcr/query/optimize/ChooseJoinAlgorithmTest.java"}, "test_case": {"identifier": "shouldHaveBestRuleSetJoinAlgorithmToMergeIfConditionIsNotDescendantNode", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldHaveBestRuleSetJoinAlgorithmToMergeIfConditionIsNotDescendantNode() {\n        PlanNode join = new PlanNode(Type.JOIN, selector(\"Parent\"), selector(\"Child\"));\n        PlanNode parentSource = new PlanNode(Type.SOURCE, join, selector(\"Parent\"));\n        PlanNode childSource = new PlanNode(Type.SOURCE, join, selector(\"Child\"));\n        // Set the join type and condition ...\n        JoinCondition joinCondition = new ChildNodeJoinCondition(selector(\"Parent\"), selector(\"Child\"));\n        join.setProperty(Property.JOIN_CONDITION, joinCondition);\n        join.setProperty(Property.JOIN_TYPE, JoinType.INNER);\n\n        // Execute the rule ...\n        PlanNode result = bestRule.execute(context, join, new LinkedList<OptimizerRule>());\n        assertThat(result, is(sameInstance(join)));\n        assertThat(join.getProperty(Property.JOIN_TYPE, JoinType.class), is(JoinType.INNER));\n        assertThat(join.getProperty(Property.JOIN_ALGORITHM, JoinAlgorithm.class), is(JoinAlgorithm.MERGE));\n        assertThat(join.getProperty(Property.JOIN_CONDITION, JoinCondition.class), is(sameInstance(joinCondition)));\n\n        PlanNode leftDup = join.getFirstChild();\n        assertThat(leftDup.getType(), is(Type.DUP_REMOVE));\n        assertSelectors(leftDup, \"Parent\");\n        PlanNode leftSort = leftDup.getFirstChild();\n        assertThat(leftSort.getType(), is(Type.SORT));\n        assertSortOrderBy(leftSort, \"Parent\");\n        assertSelectors(leftSort, \"Parent\");\n        assertChildren(leftDup, leftSort);\n        assertChildren(leftSort, parentSource);\n\n        PlanNode rightDup = join.getLastChild();\n        assertThat(rightDup.getType(), is(Type.DUP_REMOVE));\n        assertSelectors(rightDup, \"Child\");\n        PlanNode rightSort = rightDup.getLastChild();\n        assertThat(rightSort.getType(), is(Type.SORT));\n        assertSortOrderBy(rightSort, \"Child\");\n        assertSelectors(rightSort, \"Child\");\n        assertChildren(rightDup, rightSort);\n        assertChildren(rightSort, childSource);\n\n        assertChildren(join, leftDup, rightDup);\n    }", "signature": "void shouldHaveBestRuleSetJoinAlgorithmToMergeIfConditionIsNotDescendantNode()", "full_signature": "@Test public void shouldHaveBestRuleSetJoinAlgorithmToMergeIfConditionIsNotDescendantNode()", "class_method_signature": "ChooseJoinAlgorithmTest.shouldHaveBestRuleSetJoinAlgorithmToMergeIfConditionIsNotDescendantNode()", "testcase": true, "constructor": false, "invocations": ["selector", "selector", "selector", "selector", "selector", "selector", "setProperty", "setProperty", "execute", "assertThat", "is", "sameInstance", "assertThat", "getProperty", "is", "assertThat", "getProperty", "is", "assertThat", "getProperty", "is", "sameInstance", "getFirstChild", "assertThat", "getType", "is", "assertSelectors", "getFirstChild", "assertThat", "getType", "is", "assertSortOrderBy", "assertSelectors", "assertChildren", "assertChildren", "getLastChild", "assertThat", "getType", "is", "assertSelectors", "getLastChild", "assertThat", "getType", "is", "assertSortOrderBy", "assertSelectors", "assertChildren", "assertChildren", "assertChildren"]}, "focal_class": {"identifier": "ChooseJoinAlgorithm", "superclass": "", "interfaces": "implements OptimizerRule", "fields": [{"original_string": "public static final ChooseJoinAlgorithm USE_ONLY_NESTED_JOIN_ALGORITHM = new ChooseJoinAlgorithm(true);", "modifier": "public static final", "type": "ChooseJoinAlgorithm", "declarator": "USE_ONLY_NESTED_JOIN_ALGORITHM = new ChooseJoinAlgorithm(true)", "var_name": "USE_ONLY_NESTED_JOIN_ALGORITHM"}, {"original_string": "public static final ChooseJoinAlgorithm USE_BEST_JOIN_ALGORITHM = new ChooseJoinAlgorithm(false);", "modifier": "public static final", "type": "ChooseJoinAlgorithm", "declarator": "USE_BEST_JOIN_ALGORITHM = new ChooseJoinAlgorithm(false)", "var_name": "USE_BEST_JOIN_ALGORITHM"}, {"original_string": "private final boolean useOnlyNested;", "modifier": "private final", "type": "boolean", "declarator": "useOnlyNested", "var_name": "useOnlyNested"}], "methods": [{"identifier": "ChooseJoinAlgorithm", "parameters": "( boolean useOnlyNested )", "modifiers": "protected", "return": "", "signature": " ChooseJoinAlgorithm( boolean useOnlyNested )", "full_signature": "protected  ChooseJoinAlgorithm( boolean useOnlyNested )", "class_method_signature": "ChooseJoinAlgorithm.ChooseJoinAlgorithm( boolean useOnlyNested )", "testcase": false, "constructor": true}, {"identifier": "execute", "parameters": "( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "modifiers": "@Override public", "return": "PlanNode", "signature": "PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "full_signature": "@Override public PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "class_method_signature": "ChooseJoinAlgorithm.execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "testcase": false, "constructor": false}, {"identifier": "createOrderBysForJoinCondition", "parameters": "( JoinCondition condition,\n                                                   Set<SelectorName> leftSelectors,\n                                                   List<Object> leftSortBy,\n                                                   Set<SelectorName> rightSelectors,\n                                                   List<Object> rightSortBy )", "modifiers": "protected", "return": "void", "signature": "void createOrderBysForJoinCondition( JoinCondition condition,\n                                                   Set<SelectorName> leftSelectors,\n                                                   List<Object> leftSortBy,\n                                                   Set<SelectorName> rightSelectors,\n                                                   List<Object> rightSortBy )", "full_signature": "protected void createOrderBysForJoinCondition( JoinCondition condition,\n                                                   Set<SelectorName> leftSelectors,\n                                                   List<Object> leftSortBy,\n                                                   Set<SelectorName> rightSelectors,\n                                                   List<Object> rightSortBy )", "class_method_signature": "ChooseJoinAlgorithm.createOrderBysForJoinCondition( JoinCondition condition,\n                                                   Set<SelectorName> leftSelectors,\n                                                   List<Object> leftSortBy,\n                                                   Set<SelectorName> rightSelectors,\n                                                   List<Object> rightSortBy )", "testcase": false, "constructor": false}, {"identifier": "toString", "parameters": "()", "modifiers": "@Override public", "return": "String", "signature": "String toString()", "full_signature": "@Override public String toString()", "class_method_signature": "ChooseJoinAlgorithm.toString()", "testcase": false, "constructor": false}], "file": "modeshape-jcr/src/main/java/org/modeshape/jcr/query/optimize/ChooseJoinAlgorithm.java"}, "focal_method": {"identifier": "execute", "parameters": "( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "modifiers": "@Override public", "return": "PlanNode", "body": "@Override\n    public PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack ) {\n        // For each of the JOIN nodes ...\n        for (PlanNode joinNode : plan.findAllAtOrBelow(Type.JOIN)) {\n            JoinCondition condition = joinNode.getProperty(Property.JOIN_CONDITION, JoinCondition.class);\n            if (useOnlyNested) {\n                joinNode.setProperty(Property.JOIN_ALGORITHM, JoinAlgorithm.NESTED_LOOP);\n                break;\n            }\n\n            if (condition instanceof DescendantNodeJoinCondition) {\n                // It has to be a nest-loop join ...\n                joinNode.setProperty(Property.JOIN_ALGORITHM, JoinAlgorithm.NESTED_LOOP);\n            } else {\n                joinNode.setProperty(Property.JOIN_ALGORITHM, JoinAlgorithm.MERGE);\n                assert joinNode.getChildCount() == 2;\n\n                // We can try to use the merge join, but we need to sort and remove remove duplicates ...\n                // on the left and right children of the join ...\n                Set<SelectorName> leftSelectors = joinNode.getFirstChild().getSelectors();\n                Set<SelectorName> rightSelectors = joinNode.getLastChild().getSelectors();\n                List<Object> leftSortBy = new LinkedList<Object>();\n                List<Object> rightSortBy = new LinkedList<Object>();\n                createOrderBysForJoinCondition(condition, leftSelectors, leftSortBy, rightSelectors, rightSortBy);\n\n                PlanNode leftSort = new PlanNode(Type.SORT, leftSelectors);\n                leftSort.setProperty(Property.SORT_ORDER_BY, leftSortBy);\n                joinNode.getFirstChild().insertAsParent(leftSort);\n                if (joinNode.getFirstChild().findAllAtOrBelow(Type.DUP_REMOVE).isEmpty()) {\n                    // There is no duplicate removal below the left-hand side of the join, so insert it ...\n                    PlanNode leftDupRemoval = new PlanNode(Type.DUP_REMOVE, leftSelectors);\n                    joinNode.getFirstChild().insertAsParent(leftDupRemoval);\n                }\n\n                // There is no sort below the right-hand side of the join, so insert it ...\n                PlanNode rightSort = new PlanNode(Type.SORT, rightSelectors);\n                rightSort.setProperty(Property.SORT_ORDER_BY, rightSortBy);\n                joinNode.getLastChild().insertAsParent(rightSort);\n                if (joinNode.getLastChild().findAllAtOrBelow(Type.DUP_REMOVE).isEmpty()) {\n                    // There is no duplicate removal below the right-hand side of the join, so insert it ...\n                    PlanNode rightDupRemoval = new PlanNode(Type.DUP_REMOVE, rightSelectors);\n                    joinNode.getLastChild().insertAsParent(rightDupRemoval);\n                }\n            }\n        }\n        return plan;\n    }", "signature": "PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "full_signature": "@Override public PlanNode execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "class_method_signature": "ChooseJoinAlgorithm.execute( QueryContext context,\n                             PlanNode plan,\n                             LinkedList<OptimizerRule> ruleStack )", "testcase": false, "constructor": false, "invocations": ["findAllAtOrBelow", "getProperty", "setProperty", "setProperty", "setProperty", "getChildCount", "getSelectors", "getFirstChild", "getSelectors", "getLastChild", "createOrderBysForJoinCondition", "setProperty", "insertAsParent", "getFirstChild", "isEmpty", "findAllAtOrBelow", "getFirstChild", "insertAsParent", "getFirstChild", "setProperty", "insertAsParent", "getLastChild", "isEmpty", "findAllAtOrBelow", "getLastChild", "insertAsParent", "getLastChild"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}