{"test_class": {"identifier": "ExecModelLambdaPostProcessorTest", "superclass": "", "interfaces": "", "fields": [], "file": "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessorTest.java"}, "test_case": {"identifier": "convertPatternLambda", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void convertPatternLambda() throws Exception {\n\n        CompilationUnit inputCU = parseResource(\"org/drools/modelcompiler/util/lambdareplace/PatternTestHarness.java\");\n        CompilationUnit clone = inputCU.clone();\n\n        new ExecModelLambdaPostProcessor(new HashMap<>(), \"mypackage\", \"rulename\", new ArrayList<>(), new ArrayList<>(), new HashMap<>(), clone).convertLambdas();\n\n        String PATTERN_HARNESS = \"PatternTestHarness\";\n        MethodDeclaration expectedResult = getMethodChangingName(inputCU, PATTERN_HARNESS, \"expectedOutput\");\n        MethodDeclaration actual = getMethodChangingName(clone, PATTERN_HARNESS, \"inputMethod\");\n\n        assertThat(actual.toString(), equalToIgnoringWhiteSpace(expectedResult.toString()));\n    }", "signature": "void convertPatternLambda()", "full_signature": "@Test public void convertPatternLambda()", "class_method_signature": "ExecModelLambdaPostProcessorTest.convertPatternLambda()", "testcase": true, "constructor": false, "invocations": ["parseResource", "clone", "convertLambdas", "getMethodChangingName", "getMethodChangingName", "assertThat", "toString", "equalToIgnoringWhiteSpace", "toString"]}, "focal_class": {"identifier": "ExecModelLambdaPostProcessor", "superclass": "", "interfaces": "", "fields": [{"original_string": "Logger logger = LoggerFactory.getLogger(ExecModelLambdaPostProcessor.class.getCanonicalName());", "modifier": "", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(ExecModelLambdaPostProcessor.class.getCanonicalName())", "var_name": "logger"}, {"original_string": "private final Map<String, CreatedClass> lambdaClasses;", "modifier": "private final", "type": "Map<String, CreatedClass>", "declarator": "lambdaClasses", "var_name": "lambdaClasses"}, {"original_string": "private final String packageName;", "modifier": "private final", "type": "String", "declarator": "packageName", "var_name": "packageName"}, {"original_string": "private final String ruleClassName;", "modifier": "private final", "type": "String", "declarator": "ruleClassName", "var_name": "ruleClassName"}, {"original_string": "private final Collection<String> imports;", "modifier": "private final", "type": "Collection<String>", "declarator": "imports", "var_name": "imports"}, {"original_string": "private final Collection<String> staticImports;", "modifier": "private final", "type": "Collection<String>", "declarator": "staticImports", "var_name": "staticImports"}, {"original_string": "private final Map<LambdaExpr, java.lang.reflect.Type> lambdaReturnTypes;", "modifier": "private final", "type": "Map<LambdaExpr, java.lang.reflect.Type>", "declarator": "lambdaReturnTypes", "var_name": "lambdaReturnTypes"}, {"original_string": "private final CompilationUnit clone;", "modifier": "private final", "type": "CompilationUnit", "declarator": "clone", "var_name": "clone"}, {"original_string": "private static final PrettyPrinterConfiguration configuration = new PrettyPrinterConfiguration();", "modifier": "private static final", "type": "PrettyPrinterConfiguration", "declarator": "configuration = new PrettyPrinterConfiguration()", "var_name": "configuration"}, {"original_string": "public static final PrettyPrinter MATERIALIZED_LAMBDA_PRETTY_PRINTER = new PrettyPrinter(configuration);", "modifier": "public static final", "type": "PrettyPrinter", "declarator": "MATERIALIZED_LAMBDA_PRETTY_PRINTER = new PrettyPrinter(configuration)", "var_name": "MATERIALIZED_LAMBDA_PRETTY_PRINTER"}], "methods": [{"identifier": "ExecModelLambdaPostProcessor", "parameters": "(PackageModel pkgModel,\n                                        CompilationUnit clone)", "modifiers": "public", "return": "", "signature": " ExecModelLambdaPostProcessor(PackageModel pkgModel,\n                                        CompilationUnit clone)", "full_signature": "public  ExecModelLambdaPostProcessor(PackageModel pkgModel,\n                                        CompilationUnit clone)", "class_method_signature": "ExecModelLambdaPostProcessor.ExecModelLambdaPostProcessor(PackageModel pkgModel,\n                                        CompilationUnit clone)", "testcase": false, "constructor": true}, {"identifier": "ExecModelLambdaPostProcessor", "parameters": "(Map<String, CreatedClass> lambdaClasses,\n                                        String packageName,\n                                        String ruleClassName,\n                                        Collection<String> imports,\n                                        Collection<String> staticImports,\n                                        Map<LambdaExpr, java.lang.reflect.Type> lambdaReturnTypes,\n                                        CompilationUnit clone)", "modifiers": "public", "return": "", "signature": " ExecModelLambdaPostProcessor(Map<String, CreatedClass> lambdaClasses,\n                                        String packageName,\n                                        String ruleClassName,\n                                        Collection<String> imports,\n                                        Collection<String> staticImports,\n                                        Map<LambdaExpr, java.lang.reflect.Type> lambdaReturnTypes,\n                                        CompilationUnit clone)", "full_signature": "public  ExecModelLambdaPostProcessor(Map<String, CreatedClass> lambdaClasses,\n                                        String packageName,\n                                        String ruleClassName,\n                                        Collection<String> imports,\n                                        Collection<String> staticImports,\n                                        Map<LambdaExpr, java.lang.reflect.Type> lambdaReturnTypes,\n                                        CompilationUnit clone)", "class_method_signature": "ExecModelLambdaPostProcessor.ExecModelLambdaPostProcessor(Map<String, CreatedClass> lambdaClasses,\n                                        String packageName,\n                                        String ruleClassName,\n                                        Collection<String> imports,\n                                        Collection<String> staticImports,\n                                        Map<LambdaExpr, java.lang.reflect.Type> lambdaReturnTypes,\n                                        CompilationUnit clone)", "testcase": false, "constructor": true}, {"identifier": "convertLambdas", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void convertLambdas()", "full_signature": "public void convertLambdas()", "class_method_signature": "ExecModelLambdaPostProcessor.convertLambdas()", "testcase": false, "constructor": false}, {"identifier": "convertTemporalExpr", "parameters": "(MethodCallExpr methodCallExpr)", "modifiers": "private", "return": "void", "signature": "void convertTemporalExpr(MethodCallExpr methodCallExpr)", "full_signature": "private void convertTemporalExpr(MethodCallExpr methodCallExpr)", "class_method_signature": "ExecModelLambdaPostProcessor.convertTemporalExpr(MethodCallExpr methodCallExpr)", "testcase": false, "constructor": false}, {"identifier": "containsTemporalPredicate", "parameters": "(MethodCallExpr mc)", "modifiers": "private", "return": "boolean", "signature": "boolean containsTemporalPredicate(MethodCallExpr mc)", "full_signature": "private boolean containsTemporalPredicate(MethodCallExpr mc)", "class_method_signature": "ExecModelLambdaPostProcessor.containsTemporalPredicate(MethodCallExpr mc)", "testcase": false, "constructor": false}, {"identifier": "isExecuteNonNestedCall", "parameters": "(MethodCallExpr mc)", "modifiers": "private", "return": "boolean", "signature": "boolean isExecuteNonNestedCall(MethodCallExpr mc)", "full_signature": "private boolean isExecuteNonNestedCall(MethodCallExpr mc)", "class_method_signature": "ExecModelLambdaPostProcessor.isExecuteNonNestedCall(MethodCallExpr mc)", "testcase": false, "constructor": false}, {"identifier": "convertIndexedByCall", "parameters": "(MethodCallExpr methodCallExpr)", "modifiers": "private", "return": "void", "signature": "void convertIndexedByCall(MethodCallExpr methodCallExpr)", "full_signature": "private void convertIndexedByCall(MethodCallExpr methodCallExpr)", "class_method_signature": "ExecModelLambdaPostProcessor.convertIndexedByCall(MethodCallExpr methodCallExpr)", "testcase": false, "constructor": false}, {"identifier": "convertBindCall", "parameters": "(MethodCallExpr methodCallExpr)", "modifiers": "private", "return": "void", "signature": "void convertBindCall(MethodCallExpr methodCallExpr)", "full_signature": "private void convertBindCall(MethodCallExpr methodCallExpr)", "class_method_signature": "ExecModelLambdaPostProcessor.convertBindCall(MethodCallExpr methodCallExpr)", "testcase": false, "constructor": false}, {"identifier": "convertBindCallForFlowDSL", "parameters": "(MethodCallExpr methodCallExpr)", "modifiers": "private", "return": "void", "signature": "void convertBindCallForFlowDSL(MethodCallExpr methodCallExpr)", "full_signature": "private void convertBindCallForFlowDSL(MethodCallExpr methodCallExpr)", "class_method_signature": "ExecModelLambdaPostProcessor.convertBindCallForFlowDSL(MethodCallExpr methodCallExpr)", "testcase": false, "constructor": false}, {"identifier": "convertFromCall", "parameters": "(MethodCallExpr methodCallExpr)", "modifiers": "private", "return": "void", "signature": "void convertFromCall(MethodCallExpr methodCallExpr)", "full_signature": "private void convertFromCall(MethodCallExpr methodCallExpr)", "class_method_signature": "ExecModelLambdaPostProcessor.convertFromCall(MethodCallExpr methodCallExpr)", "testcase": false, "constructor": false}, {"identifier": "createMaterializedLambdaExtractor", "parameters": "(LambdaExpr lambdaExpr)", "modifiers": "private", "return": "Optional<MaterializedLambdaExtractor>", "signature": "Optional<MaterializedLambdaExtractor> createMaterializedLambdaExtractor(LambdaExpr lambdaExpr)", "full_signature": "private Optional<MaterializedLambdaExtractor> createMaterializedLambdaExtractor(LambdaExpr lambdaExpr)", "class_method_signature": "ExecModelLambdaPostProcessor.createMaterializedLambdaExtractor(LambdaExpr lambdaExpr)", "testcase": false, "constructor": false}, {"identifier": "canonicalNameParameterizedType", "parameters": "(ParameterizedType parameterizedType, Class<?> argType)", "modifiers": "private", "return": "String", "signature": "String canonicalNameParameterizedType(ParameterizedType parameterizedType, Class<?> argType)", "full_signature": "private String canonicalNameParameterizedType(ParameterizedType parameterizedType, Class<?> argType)", "class_method_signature": "ExecModelLambdaPostProcessor.canonicalNameParameterizedType(ParameterizedType parameterizedType, Class<?> argType)", "testcase": false, "constructor": false}, {"identifier": "findVariableType", "parameters": "(NameExpr nameExpr)", "modifiers": "private", "return": "Optional<Type>", "signature": "Optional<Type> findVariableType(NameExpr nameExpr)", "full_signature": "private Optional<Type> findVariableType(NameExpr nameExpr)", "class_method_signature": "ExecModelLambdaPostProcessor.findVariableType(NameExpr nameExpr)", "testcase": false, "constructor": false}, {"identifier": "getType", "parameters": "(Expression argument)", "modifiers": "protected", "return": "Type", "signature": "Type getType(Expression argument)", "full_signature": "protected Type getType(Expression argument)", "class_method_signature": "ExecModelLambdaPostProcessor.getType(Expression argument)", "testcase": false, "constructor": false}, {"identifier": "lambdaInstance", "parameters": "(ClassOrInterfaceType type)", "modifiers": "private", "return": "Expression", "signature": "Expression lambdaInstance(ClassOrInterfaceType type)", "full_signature": "private Expression lambdaInstance(ClassOrInterfaceType type)", "class_method_signature": "ExecModelLambdaPostProcessor.lambdaInstance(ClassOrInterfaceType type)", "testcase": false, "constructor": false}, {"identifier": "findBitMaskFields", "parameters": "(MethodCallExpr methodCallExpr)", "modifiers": "private", "return": "List<MaterializedLambda.BitMaskVariable>", "signature": "List<MaterializedLambda.BitMaskVariable> findBitMaskFields(MethodCallExpr methodCallExpr)", "full_signature": "private List<MaterializedLambda.BitMaskVariable> findBitMaskFields(MethodCallExpr methodCallExpr)", "class_method_signature": "ExecModelLambdaPostProcessor.findBitMaskFields(MethodCallExpr methodCallExpr)", "testcase": false, "constructor": false}, {"identifier": "isBitMaskType", "parameters": "(VariableDeclarator vd)", "modifiers": "private", "return": "boolean", "signature": "boolean isBitMaskType(VariableDeclarator vd)", "full_signature": "private boolean isBitMaskType(VariableDeclarator vd)", "class_method_signature": "ExecModelLambdaPostProcessor.isBitMaskType(VariableDeclarator vd)", "testcase": false, "constructor": false}, {"identifier": "toMaterializedLambdaFactory", "parameters": "(AssignExpr ae)", "modifiers": "private", "return": "MaterializedLambda.BitMaskVariable", "signature": "MaterializedLambda.BitMaskVariable toMaterializedLambdaFactory(AssignExpr ae)", "full_signature": "private MaterializedLambda.BitMaskVariable toMaterializedLambdaFactory(AssignExpr ae)", "class_method_signature": "ExecModelLambdaPostProcessor.toMaterializedLambdaFactory(AssignExpr ae)", "testcase": false, "constructor": false}, {"identifier": "findAssignExpr", "parameters": "(VariableDeclarator vd)", "modifiers": "private", "return": "Stream<? extends AssignExpr>", "signature": "Stream<? extends AssignExpr> findAssignExpr(VariableDeclarator vd)", "full_signature": "private Stream<? extends AssignExpr> findAssignExpr(VariableDeclarator vd)", "class_method_signature": "ExecModelLambdaPostProcessor.findAssignExpr(VariableDeclarator vd)", "testcase": false, "constructor": false}, {"identifier": "extractLambdaFromMethodCall", "parameters": "(MethodCallExpr methodCallExpr, Supplier<MaterializedLambda> lambdaExtractor)", "modifiers": "private", "return": "void", "signature": "void extractLambdaFromMethodCall(MethodCallExpr methodCallExpr, Supplier<MaterializedLambda> lambdaExtractor)", "full_signature": "private void extractLambdaFromMethodCall(MethodCallExpr methodCallExpr, Supplier<MaterializedLambda> lambdaExtractor)", "class_method_signature": "ExecModelLambdaPostProcessor.extractLambdaFromMethodCall(MethodCallExpr methodCallExpr, Supplier<MaterializedLambda> lambdaExtractor)", "testcase": false, "constructor": false}, {"identifier": "replaceLambda", "parameters": "(LambdaExpr lambdaExpr, Supplier<MaterializedLambda> lambdaExtractor)", "modifiers": "private", "return": "void", "signature": "void replaceLambda(LambdaExpr lambdaExpr, Supplier<MaterializedLambda> lambdaExtractor)", "full_signature": "private void replaceLambda(LambdaExpr lambdaExpr, Supplier<MaterializedLambda> lambdaExtractor)", "class_method_signature": "ExecModelLambdaPostProcessor.replaceLambda(LambdaExpr lambdaExpr, Supplier<MaterializedLambda> lambdaExtractor)", "testcase": false, "constructor": false}], "file": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java"}, "focal_method": {"identifier": "convertLambdas", "parameters": "()", "modifiers": "public", "return": "void", "body": "public void convertLambdas() {\n\n        clone.findAll(MethodCallExpr.class, mc -> PatternExpressionBuilder.EXPR_CALL.equals(mc.getNameAsString()) ||\n                                                  FlowExpressionBuilder.EXPR_CALL.equals(mc.getNameAsString()))\n             .forEach(methodCallExpr1 -> {\n                 if (containsTemporalPredicate(methodCallExpr1)) {\n                     this.convertTemporalExpr(methodCallExpr1);\n                 } else {\n                     extractLambdaFromMethodCall(methodCallExpr1, () -> new MaterializedLambdaPredicate(packageName, ruleClassName));\n                 }\n             });\n\n        clone.findAll(MethodCallExpr.class, mc -> INDEXED_BY_CALL.contains(mc.getName().asString()))\n             .forEach(this::convertIndexedByCall);\n\n        clone.findAll(MethodCallExpr.class, mc -> ALPHA_INDEXED_BY_CALL.contains(mc.getName().asString()))\n             .forEach(this::convertIndexedByCall);\n\n        clone.findAll(MethodCallExpr.class, mc -> BETA_INDEXED_BY_CALL.contains(mc.getName().asString()))\n             .forEach(this::convertIndexedByCall);\n\n        clone.findAll(MethodCallExpr.class, mc -> PatternExpressionBuilder.BIND_CALL.equals(mc.getNameAsString()))\n             .forEach(this::convertBindCall);\n\n        clone.findAll(MethodCallExpr.class, mc -> FlowExpressionBuilder.BIND_CALL.equals(mc.getNameAsString()))\n             .forEach(this::convertBindCallForFlowDSL);\n\n        clone.findAll(MethodCallExpr.class, mc -> FROM_CALL.equals(mc.getNameAsString()) ||\n                                                  REACTIVE_FROM_CALL.equals(mc.getNameAsString()))\n             .forEach(this::convertFromCall);\n\n        clone.findAll(MethodCallExpr.class, this::isExecuteNonNestedCall)\n             .forEach(methodCallExpr -> {\n                 List<MaterializedLambda.BitMaskVariable> bitMaskVariables = findBitMaskFields(methodCallExpr);\n                 extractLambdaFromMethodCall(methodCallExpr, () -> new MaterializedLambdaConsequence(packageName, ruleClassName, bitMaskVariables));\n             });\n    }", "signature": "void convertLambdas()", "full_signature": "public void convertLambdas()", "class_method_signature": "ExecModelLambdaPostProcessor.convertLambdas()", "testcase": false, "constructor": false, "invocations": ["forEach", "findAll", "equals", "getNameAsString", "equals", "getNameAsString", "containsTemporalPredicate", "convertTemporalExpr", "extractLambdaFromMethodCall", "forEach", "findAll", "contains", "asString", "getName", "forEach", "findAll", "contains", "asString", "getName", "forEach", "findAll", "contains", "asString", "getName", "forEach", "findAll", "equals", "getNameAsString", "forEach", "findAll", "equals", "getNameAsString", "forEach", "findAll", "equals", "getNameAsString", "equals", "getNameAsString", "forEach", "findAll", "findBitMaskFields", "extractLambdaFromMethodCall"]}, "repository": {"repo_id": 1381673, "url": "https://github.com/kiegroup/drools", "stars": 2733, "created": "2/18/2011 8:37:05 AM +00:00", "updates": "2020-01-27T13:12:15+00:00", "fork": "False", "license": "licensed"}}