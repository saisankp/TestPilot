{"test_class": {"identifier": "SecretContentDAOTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Inject DSLContext jooqContext;", "modifier": "@Inject", "type": "DSLContext", "declarator": "jooqContext", "var_name": "jooqContext"}, {"original_string": "@Inject SecretContentDAOFactory secretContentDAOFactory;", "modifier": "@Inject", "type": "SecretContentDAOFactory", "declarator": "secretContentDAOFactory", "var_name": "secretContentDAOFactory"}, {"original_string": "@Inject private RowHmacGenerator rowHmacGenerator;", "modifier": "@Inject private", "type": "RowHmacGenerator", "declarator": "rowHmacGenerator", "var_name": "rowHmacGenerator"}, {"original_string": "final static ApiDate date = ApiDate.now();", "modifier": "final static", "type": "ApiDate", "declarator": "date = ApiDate.now()", "var_name": "date"}, {"original_string": "ImmutableMap<String, String> metadata = ImmutableMap.of(\"foo\", \"bar\");", "modifier": "", "type": "ImmutableMap<String, String>", "declarator": "metadata = ImmutableMap.of(\"foo\", \"bar\")", "var_name": "metadata"}, {"original_string": "SecretContent secretContent1 = SecretContent.of(11, 22, \"[crypted]\", \"checksum\", date, \"creator\", date,\n      \"creator\", metadata, 1136214245);", "modifier": "", "type": "SecretContent", "declarator": "secretContent1 = SecretContent.of(11, 22, \"[crypted]\", \"checksum\", date, \"creator\", date,\n      \"creator\", metadata, 1136214245)", "var_name": "secretContent1"}, {"original_string": "SecretContentDAO secretContentDAO;", "modifier": "", "type": "SecretContentDAO", "declarator": "secretContentDAO", "var_name": "secretContentDAO"}], "file": "server/src/test/java/keywhiz/service/daos/SecretContentDAOTest.java"}, "test_case": {"identifier": "pruneOldContents", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test public void pruneOldContents() throws Exception {\n    long now = OffsetDateTime.now().toEpochSecond();\n    long secretSeriesId = 666;\n\n    jooqContext.insertInto(SECRETS, SECRETS.ID, SECRETS.NAME, SECRETS.CREATEDAT, SECRETS.UPDATEDAT)\n        .values(secretSeriesId, \"secretForPruneTest1\", now, now)\n        .execute();\n\n    int before = tableSize();\n\n    // Create contents\n    long[] ids = new long[15];\n    for (int i = 0; i < ids.length; i++) {\n      long id = secretContentDAO.createSecretContent(secretSeriesId, \"encrypted\", \"checksum\",\n          \"creator\", metadata, 1136214245, i);\n      ids[i] = id;\n    }\n\n    assertThat(tableSize()).isEqualTo(before + ids.length);\n\n    // Make most recent id be the current version for the secret series and prune\n    jooqContext.update(SECRETS)\n        .set(SECRETS.CURRENT, ids[ids.length-1])\n        .where(SECRETS.ID.eq(secretSeriesId))\n        .execute();\n\n    secretContentDAO.pruneOldContents(secretSeriesId);\n\n    // Last ten secrets in series should have survived (plus the current one)\n    assertThat(tableSize()).isEqualTo(before + PRUNE_CUTOFF_ITEMS + 1);\n\n    for (int i = 0; i < (ids.length - PRUNE_CUTOFF_ITEMS - 1); i++) {\n      assertThat(secretContentDAO.getSecretContentById(ids[i])).isEmpty();\n    }\n    for (int i = (ids.length - PRUNE_CUTOFF_ITEMS - 1); i < ids.length; i++) {\n      assertThat(secretContentDAO.getSecretContentById(ids[i])).isPresent();\n    }\n\n    // Other secrets contents left intact\n    assertThat(secretContentDAO.getSecretContentById(secretContent1.id())).isPresent();\n  }", "signature": "void pruneOldContents()", "full_signature": "@Test public void pruneOldContents()", "class_method_signature": "SecretContentDAOTest.pruneOldContents()", "testcase": true, "constructor": false, "invocations": ["toEpochSecond", "now", "execute", "values", "insertInto", "tableSize", "createSecretContent", "isEqualTo", "assertThat", "tableSize", "execute", "where", "set", "update", "eq", "pruneOldContents", "isEqualTo", "assertThat", "tableSize", "isEmpty", "assertThat", "getSecretContentById", "isPresent", "assertThat", "getSecretContentById", "isPresent", "assertThat", "getSecretContentById", "id"]}, "focal_class": {"identifier": "SecretContentDAO", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = LoggerFactory.getLogger(AclDAO.class);", "modifier": "private static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(AclDAO.class)", "var_name": "logger"}, {"original_string": "@VisibleForTesting static final int PRUNE_CUTOFF_ITEMS = 10;", "modifier": "@VisibleForTesting static final", "type": "int", "declarator": "PRUNE_CUTOFF_ITEMS = 10", "var_name": "PRUNE_CUTOFF_ITEMS"}, {"original_string": "@VisibleForTesting static final int PRUNE_CUTOFF_DAYS = 15;", "modifier": "@VisibleForTesting static final", "type": "int", "declarator": "PRUNE_CUTOFF_DAYS = 15", "var_name": "PRUNE_CUTOFF_DAYS"}, {"original_string": "private final DSLContext dslContext;", "modifier": "private final", "type": "DSLContext", "declarator": "dslContext", "var_name": "dslContext"}, {"original_string": "private final ObjectMapper mapper;", "modifier": "private final", "type": "ObjectMapper", "declarator": "mapper", "var_name": "mapper"}, {"original_string": "private final SecretContentMapper secretContentMapper;", "modifier": "private final", "type": "SecretContentMapper", "declarator": "secretContentMapper", "var_name": "secretContentMapper"}, {"original_string": "private final RowHmacGenerator rowHmacGenerator;", "modifier": "private final", "type": "RowHmacGenerator", "declarator": "rowHmacGenerator", "var_name": "rowHmacGenerator"}, {"original_string": "private final KeywhizConfig config;", "modifier": "private final", "type": "KeywhizConfig", "declarator": "config", "var_name": "config"}], "methods": [{"identifier": "SecretContentDAO", "parameters": "(DSLContext dslContext, ObjectMapper mapper,\n      SecretContentMapper secretContentMapper, RowHmacGenerator rowHmacGenerator,\n      KeywhizConfig config)", "modifiers": "private", "return": "", "signature": " SecretContentDAO(DSLContext dslContext, ObjectMapper mapper,\n      SecretContentMapper secretContentMapper, RowHmacGenerator rowHmacGenerator,\n      KeywhizConfig config)", "full_signature": "private  SecretContentDAO(DSLContext dslContext, ObjectMapper mapper,\n      SecretContentMapper secretContentMapper, RowHmacGenerator rowHmacGenerator,\n      KeywhizConfig config)", "class_method_signature": "SecretContentDAO.SecretContentDAO(DSLContext dslContext, ObjectMapper mapper,\n      SecretContentMapper secretContentMapper, RowHmacGenerator rowHmacGenerator,\n      KeywhizConfig config)", "testcase": false, "constructor": true}, {"identifier": "createSecretContent", "parameters": "(long secretId, String encryptedContent, String hmac,\n      String creator, Map<String, String> metadata, long expiry, long now)", "modifiers": "public", "return": "long", "signature": "long createSecretContent(long secretId, String encryptedContent, String hmac,\n      String creator, Map<String, String> metadata, long expiry, long now)", "full_signature": "public long createSecretContent(long secretId, String encryptedContent, String hmac,\n      String creator, Map<String, String> metadata, long expiry, long now)", "class_method_signature": "SecretContentDAO.createSecretContent(long secretId, String encryptedContent, String hmac,\n      String creator, Map<String, String> metadata, long expiry, long now)", "testcase": false, "constructor": false}, {"identifier": "pruneOldContents", "parameters": "(long secretId)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void pruneOldContents(long secretId)", "full_signature": "@VisibleForTesting void pruneOldContents(long secretId)", "class_method_signature": "SecretContentDAO.pruneOldContents(long secretId)", "testcase": false, "constructor": false}, {"identifier": "getSecretContentById", "parameters": "(long id)", "modifiers": "public", "return": "Optional<SecretContent>", "signature": "Optional<SecretContent> getSecretContentById(long id)", "full_signature": "public Optional<SecretContent> getSecretContentById(long id)", "class_method_signature": "SecretContentDAO.getSecretContentById(long id)", "testcase": false, "constructor": false}, {"identifier": "getSecretVersionsBySecretId", "parameters": "(long id,\n      int versionIdx, int numVersions)", "modifiers": "public", "return": "Optional<ImmutableList<SecretContent>>", "signature": "Optional<ImmutableList<SecretContent>> getSecretVersionsBySecretId(long id,\n      int versionIdx, int numVersions)", "full_signature": "public Optional<ImmutableList<SecretContent>> getSecretVersionsBySecretId(long id,\n      int versionIdx, int numVersions)", "class_method_signature": "SecretContentDAO.getSecretVersionsBySecretId(long id,\n      int versionIdx, int numVersions)", "testcase": false, "constructor": false}, {"identifier": "dangerPermanentlyRemoveRecordsForGivenSecretsIDs", "parameters": "(List<Long> ids)", "modifiers": "public", "return": "long", "signature": "long dangerPermanentlyRemoveRecordsForGivenSecretsIDs(List<Long> ids)", "full_signature": "public long dangerPermanentlyRemoveRecordsForGivenSecretsIDs(List<Long> ids)", "class_method_signature": "SecretContentDAO.dangerPermanentlyRemoveRecordsForGivenSecretsIDs(List<Long> ids)", "testcase": false, "constructor": false}], "file": "server/src/main/java/keywhiz/service/daos/SecretContentDAO.java"}, "focal_method": {"identifier": "pruneOldContents", "parameters": "(long secretId)", "modifiers": "@VisibleForTesting", "return": "void", "body": "@VisibleForTesting void pruneOldContents(long secretId) {\n    // Fetch current version number\n    SecretsRecord secret =\n        dslContext.select(SECRETS.CURRENT)\n            .from(SECRETS)\n            .where(SECRETS.ID.eq(secretId))\n            .fetchOneInto(SecretsRecord.class);\n\n    if (secret == null || secret.getCurrent() == null) {\n      // No current secret assigned (secret just being created), let's not prune right now.\n      return;\n    }\n\n    // Select everything older than cutoff for possible pruning\n    long cutoff = OffsetDateTime.now().minusDays(PRUNE_CUTOFF_DAYS).toEpochSecond();\n\n    List<Long> records =\n        dslContext.select(SECRETS_CONTENT.ID)\n            .from(SECRETS_CONTENT)\n            .where(SECRETS_CONTENT.SECRETID.eq(secretId))\n            .and(SECRETS_CONTENT.CREATEDAT.lt(cutoff))\n            .and(SECRETS_CONTENT.ID.ne(secret.getCurrent()))\n            .orderBy(SECRETS_CONTENT.CREATEDAT.desc())\n            .fetch(SECRETS_CONTENT.ID);\n\n    // Always keep last X items, prune otherwise\n    if (records.size() > PRUNE_CUTOFF_ITEMS) {\n      for (long id : records.subList(PRUNE_CUTOFF_ITEMS, records.size())) {\n        dslContext.deleteFrom(SECRETS_CONTENT).where(SECRETS_CONTENT.ID.eq(id)).execute();\n      }\n    }\n  }", "signature": "void pruneOldContents(long secretId)", "full_signature": "@VisibleForTesting void pruneOldContents(long secretId)", "class_method_signature": "SecretContentDAO.pruneOldContents(long secretId)", "testcase": false, "constructor": false, "invocations": ["fetchOneInto", "where", "from", "select", "eq", "getCurrent", "toEpochSecond", "minusDays", "now", "fetch", "orderBy", "and", "and", "where", "from", "select", "eq", "lt", "ne", "getCurrent", "desc", "size", "subList", "size", "execute", "where", "deleteFrom", "eq"]}, "repository": {"repo_id": 32866430, "url": "https://github.com/square/keywhiz", "stars": 2186, "created": "3/25/2015 1:31:39 PM +00:00", "updates": "2020-01-24T18:57:02+00:00", "fork": "False", "license": "licensed"}}