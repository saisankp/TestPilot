{"test_class": {"identifier": "EndianNumbersTest", "superclass": "extends AbstractTestCase", "interfaces": "", "fields": [], "file": "core/inputoutput/src/test/java/org/arakhne/afc/inputoutput/endian/EndianNumbersTest.java"}, "test_case": {"identifier": "toLEInt", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void toLEInt() {\n\t\tassertEquals(-1625962373, EndianNumbers.toLEInt(123, 456, 789, 159));\n    }", "signature": "void toLEInt()", "full_signature": "@Test public void toLEInt()", "class_method_signature": "EndianNumbersTest.toLEInt()", "testcase": true, "constructor": false, "invocations": ["assertEquals", "toLEInt"]}, "focal_class": {"identifier": "EndianNumbers", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "EndianNumbers", "parameters": "()", "modifiers": "private", "return": "", "signature": " EndianNumbers()", "full_signature": "private  EndianNumbers()", "class_method_signature": "EndianNumbers.EndianNumbers()", "testcase": false, "constructor": true}, {"identifier": "toBEShort", "parameters": "(int b1, int b2)", "modifiers": "@Pure public static", "return": "short", "signature": "short toBEShort(int b1, int b2)", "full_signature": "@Pure public static short toBEShort(int b1, int b2)", "class_method_signature": "EndianNumbers.toBEShort(int b1, int b2)", "testcase": false, "constructor": false}, {"identifier": "toLEShort", "parameters": "(int b1, int b2)", "modifiers": "@Pure public static", "return": "short", "signature": "short toLEShort(int b1, int b2)", "full_signature": "@Pure public static short toLEShort(int b1, int b2)", "class_method_signature": "EndianNumbers.toLEShort(int b1, int b2)", "testcase": false, "constructor": false}, {"identifier": "toLEInt", "parameters": "(int b1, int b2, int b3, int b4)", "modifiers": "@Pure public static", "return": "int", "signature": "int toLEInt(int b1, int b2, int b3, int b4)", "full_signature": "@Pure public static int toLEInt(int b1, int b2, int b3, int b4)", "class_method_signature": "EndianNumbers.toLEInt(int b1, int b2, int b3, int b4)", "testcase": false, "constructor": false}, {"identifier": "toBEInt", "parameters": "(int b1, int b2, int b3, int b4)", "modifiers": "@Pure public static", "return": "int", "signature": "int toBEInt(int b1, int b2, int b3, int b4)", "full_signature": "@Pure public static int toBEInt(int b1, int b2, int b3, int b4)", "class_method_signature": "EndianNumbers.toBEInt(int b1, int b2, int b3, int b4)", "testcase": false, "constructor": false}, {"identifier": "toLELong", "parameters": "(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "modifiers": "@Pure public static", "return": "long", "signature": "long toLELong(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "full_signature": "@Pure public static long toLELong(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "class_method_signature": "EndianNumbers.toLELong(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "testcase": false, "constructor": false}, {"identifier": "toBELong", "parameters": "(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "modifiers": "@Pure public static", "return": "long", "signature": "long toBELong(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "full_signature": "@Pure public static long toBELong(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "class_method_signature": "EndianNumbers.toBELong(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "testcase": false, "constructor": false}, {"identifier": "toLEDouble", "parameters": "(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "modifiers": "@Pure @Inline(value = \"Double.longBitsToDouble(EndianNumbers.toLELong($1, $2, $3, $4, $5, $6, $7, $8))\", imported = {EndianNumbers.class}) public static", "return": "double", "signature": "double toLEDouble(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "full_signature": "@Pure @Inline(value = \"Double.longBitsToDouble(EndianNumbers.toLELong($1, $2, $3, $4, $5, $6, $7, $8))\", imported = {EndianNumbers.class}) public static double toLEDouble(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "class_method_signature": "EndianNumbers.toLEDouble(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "testcase": false, "constructor": false}, {"identifier": "toBEDouble", "parameters": "(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "modifiers": "@Pure @Inline(value = \"Double.longBitsToDouble(EndianNumbers.toBELong($1, $2, $3, $4, $5, $6, $7, $8))\", imported = {EndianNumbers.class}) public static", "return": "double", "signature": "double toBEDouble(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "full_signature": "@Pure @Inline(value = \"Double.longBitsToDouble(EndianNumbers.toBELong($1, $2, $3, $4, $5, $6, $7, $8))\", imported = {EndianNumbers.class}) public static double toBEDouble(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "class_method_signature": "EndianNumbers.toBEDouble(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8)", "testcase": false, "constructor": false}, {"identifier": "toLEFloat", "parameters": "(int b1, int b2, int b3, int b4)", "modifiers": "@Pure @Inline(value = \"Float.intBitsToFloat(EndianNumbers.toLEInt($1, $2, $3, $4))\", imported = {EndianNumbers.class}) public static", "return": "float", "signature": "float toLEFloat(int b1, int b2, int b3, int b4)", "full_signature": "@Pure @Inline(value = \"Float.intBitsToFloat(EndianNumbers.toLEInt($1, $2, $3, $4))\", imported = {EndianNumbers.class}) public static float toLEFloat(int b1, int b2, int b3, int b4)", "class_method_signature": "EndianNumbers.toLEFloat(int b1, int b2, int b3, int b4)", "testcase": false, "constructor": false}, {"identifier": "toBEFloat", "parameters": "(int b1, int b2, int b3, int b4)", "modifiers": "@Pure @Inline(value = \"Float.intBitsToFloat(EndianNumbers.toBEInt($1, $2, $3, $4))\", imported = {EndianNumbers.class}) public static", "return": "float", "signature": "float toBEFloat(int b1, int b2, int b3, int b4)", "full_signature": "@Pure @Inline(value = \"Float.intBitsToFloat(EndianNumbers.toBEInt($1, $2, $3, $4))\", imported = {EndianNumbers.class}) public static float toBEFloat(int b1, int b2, int b3, int b4)", "class_method_signature": "EndianNumbers.toBEFloat(int b1, int b2, int b3, int b4)", "testcase": false, "constructor": false}, {"identifier": "parseLEShort", "parameters": "(short value)", "modifiers": "@Pure public static", "return": "byte[]", "signature": "byte[] parseLEShort(short value)", "full_signature": "@Pure public static byte[] parseLEShort(short value)", "class_method_signature": "EndianNumbers.parseLEShort(short value)", "testcase": false, "constructor": false}, {"identifier": "parseLEInt", "parameters": "(int value)", "modifiers": "@Pure public static", "return": "byte[]", "signature": "byte[] parseLEInt(int value)", "full_signature": "@Pure public static byte[] parseLEInt(int value)", "class_method_signature": "EndianNumbers.parseLEInt(int value)", "testcase": false, "constructor": false}, {"identifier": "parseLEFloat", "parameters": "(float value)", "modifiers": "@Pure @Inline(value = \"EndianNumbers.parseLEInt(Float.floatToIntBits($1))\", imported = {EndianNumbers.class}) public static", "return": "byte[]", "signature": "byte[] parseLEFloat(float value)", "full_signature": "@Pure @Inline(value = \"EndianNumbers.parseLEInt(Float.floatToIntBits($1))\", imported = {EndianNumbers.class}) public static byte[] parseLEFloat(float value)", "class_method_signature": "EndianNumbers.parseLEFloat(float value)", "testcase": false, "constructor": false}, {"identifier": "parseLELong", "parameters": "(long value)", "modifiers": "@Pure public static", "return": "byte[]", "signature": "byte[] parseLELong(long value)", "full_signature": "@Pure public static byte[] parseLELong(long value)", "class_method_signature": "EndianNumbers.parseLELong(long value)", "testcase": false, "constructor": false}, {"identifier": "parseLEDouble", "parameters": "(double value)", "modifiers": "@Pure @Inline(value = \"EndianNumbers.parseLELong(Double.doubleToLongBits($1))\", imported = {EndianNumbers.class}) public static", "return": "byte[]", "signature": "byte[] parseLEDouble(double value)", "full_signature": "@Pure @Inline(value = \"EndianNumbers.parseLELong(Double.doubleToLongBits($1))\", imported = {EndianNumbers.class}) public static byte[] parseLEDouble(double value)", "class_method_signature": "EndianNumbers.parseLEDouble(double value)", "testcase": false, "constructor": false}, {"identifier": "parseBEShort", "parameters": "(short value)", "modifiers": "@Pure public static", "return": "byte[]", "signature": "byte[] parseBEShort(short value)", "full_signature": "@Pure public static byte[] parseBEShort(short value)", "class_method_signature": "EndianNumbers.parseBEShort(short value)", "testcase": false, "constructor": false}, {"identifier": "parseBEInt", "parameters": "(int value)", "modifiers": "@Pure public static", "return": "byte[]", "signature": "byte[] parseBEInt(int value)", "full_signature": "@Pure public static byte[] parseBEInt(int value)", "class_method_signature": "EndianNumbers.parseBEInt(int value)", "testcase": false, "constructor": false}, {"identifier": "parseBEFloat", "parameters": "(float value)", "modifiers": "@Pure @Inline(value = \"EndianNumbers.parseBEInt(Float.floatToIntBits($1))\", imported = {EndianNumbers.class}) public static", "return": "byte[]", "signature": "byte[] parseBEFloat(float value)", "full_signature": "@Pure @Inline(value = \"EndianNumbers.parseBEInt(Float.floatToIntBits($1))\", imported = {EndianNumbers.class}) public static byte[] parseBEFloat(float value)", "class_method_signature": "EndianNumbers.parseBEFloat(float value)", "testcase": false, "constructor": false}, {"identifier": "parseBELong", "parameters": "(long value)", "modifiers": "@Pure public static", "return": "byte[]", "signature": "byte[] parseBELong(long value)", "full_signature": "@Pure public static byte[] parseBELong(long value)", "class_method_signature": "EndianNumbers.parseBELong(long value)", "testcase": false, "constructor": false}, {"identifier": "parseBEDouble", "parameters": "(double value)", "modifiers": "@Pure @Inline(value = \"EndianNumbers.parseBELong(Double.doubleToLongBits($1))\", imported = {EndianNumbers.class}) public static", "return": "byte[]", "signature": "byte[] parseBEDouble(double value)", "full_signature": "@Pure @Inline(value = \"EndianNumbers.parseBELong(Double.doubleToLongBits($1))\", imported = {EndianNumbers.class}) public static byte[] parseBEDouble(double value)", "class_method_signature": "EndianNumbers.parseBEDouble(double value)", "testcase": false, "constructor": false}], "file": "core/inputoutput/src/main/java/org/arakhne/afc/inputoutput/endian/EndianNumbers.java"}, "focal_method": {"identifier": "toLEInt", "parameters": "(int b1, int b2, int b3, int b4)", "modifiers": "@Pure public static", "return": "int", "body": "@Pure\n\tpublic static int toLEInt(int b1, int b2, int b3, int b4) {\n        return ((b4 & 0xFF) << 24) + ((b3 & 0xFF) << 16) + ((b2 & 0xFF) << 8) + (b1 & 0xFF);\n    }", "signature": "int toLEInt(int b1, int b2, int b3, int b4)", "full_signature": "@Pure public static int toLEInt(int b1, int b2, int b3, int b4)", "class_method_signature": "EndianNumbers.toLEInt(int b1, int b2, int b3, int b4)", "testcase": false, "constructor": false, "invocations": []}, "repository": {"repo_id": 9714608, "url": "https://github.com/gallandarakhneorg/afc", "language": "Java", "is_fork": false, "fork_count": 8, "stargazer_count": 12, "size": 19091, "license": "licensed"}}