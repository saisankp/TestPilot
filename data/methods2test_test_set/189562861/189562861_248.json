{"test_class": {"identifier": "ExecutionListTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private ExecutionList executionList;", "modifier": "private", "type": "ExecutionList", "declarator": "executionList", "var_name": "executionList"}], "file": "dubbo-common/src/test/java/com/alibaba/dubbo/common/concurrent/ExecutionListTest.java"}, "test_case": {"identifier": "testAddNullRunnable", "parameters": "()", "modifiers": "@Test(expected = NullPointerException.class) public", "return": "void", "body": "@Test(expected = NullPointerException.class)\n    public void testAddNullRunnable() {\n        this.executionList.add(null, mock(Executor.class));\n    }", "signature": "void testAddNullRunnable()", "full_signature": "@Test(expected = NullPointerException.class) public void testAddNullRunnable()", "class_method_signature": "ExecutionListTest.testAddNullRunnable()", "testcase": true, "constructor": false, "invocations": ["add", "mock"]}, "focal_class": {"identifier": "ExecutionList", "superclass": "", "interfaces": "", "fields": [{"original_string": "static final Logger logger = LoggerFactory.getLogger(ExecutionList.class.getName());", "modifier": "static final", "type": "Logger", "declarator": "logger = LoggerFactory.getLogger(ExecutionList.class.getName())", "var_name": "logger"}, {"original_string": "private RunnableExecutorPair runnables;", "modifier": "private", "type": "RunnableExecutorPair", "declarator": "runnables", "var_name": "runnables"}, {"original_string": "private boolean executed;", "modifier": "private", "type": "boolean", "declarator": "executed", "var_name": "executed"}, {"original_string": "private static final Executor DEFAULT_EXECUTOR = new ThreadPoolExecutor(1, 10, 60000L, TimeUnit.MILLISECONDS, new SynchronousQueue<Runnable>(), new NamedThreadFactory(\"DubboFutureCallbackDefault\", true));", "modifier": "private static final", "type": "Executor", "declarator": "DEFAULT_EXECUTOR = new ThreadPoolExecutor(1, 10, 60000L, TimeUnit.MILLISECONDS, new SynchronousQueue<Runnable>(), new NamedThreadFactory(\"DubboFutureCallbackDefault\", true))", "var_name": "DEFAULT_EXECUTOR"}], "methods": [{"identifier": "ExecutionList", "parameters": "()", "modifiers": "public", "return": "", "signature": " ExecutionList()", "full_signature": "public  ExecutionList()", "class_method_signature": "ExecutionList.ExecutionList()", "testcase": false, "constructor": true}, {"identifier": "add", "parameters": "(Runnable runnable, Executor executor)", "modifiers": "public", "return": "void", "signature": "void add(Runnable runnable, Executor executor)", "full_signature": "public void add(Runnable runnable, Executor executor)", "class_method_signature": "ExecutionList.add(Runnable runnable, Executor executor)", "testcase": false, "constructor": false}, {"identifier": "execute", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void execute()", "full_signature": "public void execute()", "class_method_signature": "ExecutionList.execute()", "testcase": false, "constructor": false}, {"identifier": "executeListener", "parameters": "(Runnable runnable, Executor executor)", "modifiers": "private static", "return": "void", "signature": "void executeListener(Runnable runnable, Executor executor)", "full_signature": "private static void executeListener(Runnable runnable, Executor executor)", "class_method_signature": "ExecutionList.executeListener(Runnable runnable, Executor executor)", "testcase": false, "constructor": false}], "file": "dubbo-common/src/main/java/com/alibaba/dubbo/common/concurrent/ExecutionList.java"}, "focal_method": {"identifier": "add", "parameters": "(Runnable runnable, Executor executor)", "modifiers": "public", "return": "void", "body": "public void add(Runnable runnable, Executor executor) {\n        // Fail fast on a null.  We throw NPE here because the contract of\n        // Executor states that it throws NPE on null listener, so we propagate\n        // that contract up into the add method as well.\n        if (runnable == null) {\n            throw new NullPointerException(\"Runnable can not be null!\");\n        }\n        if (executor == null) {\n            logger.info(\"Executor for listenablefuture is null, will use default executor!\");\n            executor = DEFAULT_EXECUTOR;\n        }\n        // Lock while we check state.  We must maintain the lock while adding the\n        // new pair so that another thread can't run the list out from under us.\n        // We only add to the list if we have not yet started execution.\n        synchronized (this) {\n            if (!executed) {\n                runnables = new RunnableExecutorPair(runnable, executor, runnables);\n                return;\n            }\n        }\n        // Execute the runnable immediately. Because of scheduling this may end up\n        // getting called before some of the previously added runnables, but we're\n        // OK with that.  If we want to change the contract to guarantee ordering\n        // among runnables we'd have to modify the logic here to allow it.\n        executeListener(runnable, executor);\n    }", "signature": "void add(Runnable runnable, Executor executor)", "full_signature": "public void add(Runnable runnable, Executor executor)", "class_method_signature": "ExecutionList.add(Runnable runnable, Executor executor)", "testcase": false, "constructor": false, "invocations": ["info", "executeListener"]}, "repository": {"repo_id": 189562861, "url": "https://github.com/smallFive55/dubbo-dubbo-2.6.6", "language": "Java", "is_fork": false, "fork_count": 11, "stargazer_count": 8, "size": 1428, "license": "licensed"}}