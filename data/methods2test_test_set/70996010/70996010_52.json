{"test_class": {"identifier": "AdVpnThreadTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private AdVpnService service;", "modifier": "private", "type": "AdVpnService", "declarator": "service", "var_name": "service"}, {"original_string": "private AdVpnThread thread;", "modifier": "private", "type": "AdVpnThread", "declarator": "thread", "var_name": "thread"}, {"original_string": "private Configuration config;", "modifier": "private", "type": "Configuration", "declarator": "config", "var_name": "config"}, {"original_string": "private VpnService.Builder builder;", "modifier": "private", "type": "VpnService.Builder", "declarator": "builder", "var_name": "builder"}, {"original_string": "private List<InetAddress> serversAdded;", "modifier": "private", "type": "List<InetAddress>", "declarator": "serversAdded", "var_name": "serversAdded"}], "file": "app/src/test/java/org/jak_linux/dns66/vpn/AdVpnThreadTest.java"}, "test_case": {"identifier": "testNewDNSServer_ipv6disabled", "parameters": "()", "modifiers": "@Test // IPv6 is disabled: We only get IPv4 servers through public", "return": "void", "body": "@Test\n    // IPv6 is disabled: We only get IPv4 servers through\n    public void testNewDNSServer_ipv6disabled() throws Exception {\n        byte[] ipv6Template = new byte[]{32, 1, 13, (byte) (184 & 0xFF), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        InetAddress i6addr = Inet6Address.getByName(\"::1\");\n\n        thread.newDNSServer(builder, \"192.168.0.%d\", null, i6addr);\n        assertTrue(serversAdded.isEmpty());\n        assertTrue(thread.upstreamDnsServers.isEmpty());\n\n        InetAddress i4addr = Inet4Address.getByName(\"127.0.0.1\");\n        thread.newDNSServer(builder, \"192.168.0.%d\", null, i4addr);\n        assertTrue(serversAdded.contains(InetAddress.getByName(\"192.168.0.2\")));\n        assertTrue(thread.upstreamDnsServers.contains(i4addr));\n    }", "signature": "void testNewDNSServer_ipv6disabled()", "full_signature": "@Test // IPv6 is disabled: We only get IPv4 servers through public void testNewDNSServer_ipv6disabled()", "class_method_signature": "AdVpnThreadTest.testNewDNSServer_ipv6disabled()", "testcase": true, "constructor": false, "invocations": ["getByName", "newDNSServer", "assertTrue", "isEmpty", "assertTrue", "isEmpty", "getByName", "newDNSServer", "assertTrue", "contains", "getByName", "assertTrue", "contains"]}, "focal_class": {"identifier": "AdVpnThread", "superclass": "", "interfaces": "implements Runnable, DnsPacketProxy.EventLoop", "fields": [{"original_string": "private static final String TAG = \"AdVpnThread\";", "modifier": "private static final", "type": "String", "declarator": "TAG = \"AdVpnThread\"", "var_name": "TAG"}, {"original_string": "private static final int MIN_RETRY_TIME = 5;", "modifier": "private static final", "type": "int", "declarator": "MIN_RETRY_TIME = 5", "var_name": "MIN_RETRY_TIME"}, {"original_string": "private static final int MAX_RETRY_TIME = 2 * 60;", "modifier": "private static final", "type": "int", "declarator": "MAX_RETRY_TIME = 2 * 60", "var_name": "MAX_RETRY_TIME"}, {"original_string": "private static final long RETRY_RESET_SEC = 60;", "modifier": "private static final", "type": "long", "declarator": "RETRY_RESET_SEC = 60", "var_name": "RETRY_RESET_SEC"}, {"original_string": "private static final int DNS_MAXIMUM_WAITING = 1024;", "modifier": "private static final", "type": "int", "declarator": "DNS_MAXIMUM_WAITING = 1024", "var_name": "DNS_MAXIMUM_WAITING"}, {"original_string": "private static final long DNS_TIMEOUT_SEC = 10;", "modifier": "private static final", "type": "long", "declarator": "DNS_TIMEOUT_SEC = 10", "var_name": "DNS_TIMEOUT_SEC"}, {"original_string": "final ArrayList<InetAddress> upstreamDnsServers = new ArrayList<>();", "modifier": "final", "type": "ArrayList<InetAddress>", "declarator": "upstreamDnsServers = new ArrayList<>()", "var_name": "upstreamDnsServers"}, {"original_string": "private final VpnService vpnService;", "modifier": "private final", "type": "VpnService", "declarator": "vpnService", "var_name": "vpnService"}, {"original_string": "private final Notify notify;", "modifier": "private final", "type": "Notify", "declarator": "notify", "var_name": "notify"}, {"original_string": "private final Queue<byte[]> deviceWrites = new LinkedList<>();", "modifier": "private final", "type": "Queue<byte[]>", "declarator": "deviceWrites = new LinkedList<>()", "var_name": "deviceWrites"}, {"original_string": "private final WospList dnsIn = new WospList();", "modifier": "private final", "type": "WospList", "declarator": "dnsIn = new WospList()", "var_name": "dnsIn"}, {"original_string": "private final DnsPacketProxy dnsPacketProxy = new DnsPacketProxy(this);", "modifier": "private final", "type": "DnsPacketProxy", "declarator": "dnsPacketProxy = new DnsPacketProxy(this)", "var_name": "dnsPacketProxy"}, {"original_string": "private final VpnWatchdog vpnWatchDog = new VpnWatchdog();", "modifier": "private final", "type": "VpnWatchdog", "declarator": "vpnWatchDog = new VpnWatchdog()", "var_name": "vpnWatchDog"}, {"original_string": "private Thread thread = null;", "modifier": "private", "type": "Thread", "declarator": "thread = null", "var_name": "thread"}, {"original_string": "private FileDescriptor mBlockFd = null;", "modifier": "private", "type": "FileDescriptor", "declarator": "mBlockFd = null", "var_name": "mBlockFd"}, {"original_string": "private FileDescriptor mInterruptFd = null;", "modifier": "private", "type": "FileDescriptor", "declarator": "mInterruptFd = null", "var_name": "mInterruptFd"}, {"original_string": "private int pcap4jFactoryClearCacheCounter = 0;", "modifier": "private", "type": "int", "declarator": "pcap4jFactoryClearCacheCounter = 0", "var_name": "pcap4jFactoryClearCacheCounter"}], "methods": [{"identifier": "AdVpnThread", "parameters": "(VpnService vpnService, Notify notify)", "modifiers": "public", "return": "", "signature": " AdVpnThread(VpnService vpnService, Notify notify)", "full_signature": "public  AdVpnThread(VpnService vpnService, Notify notify)", "class_method_signature": "AdVpnThread.AdVpnThread(VpnService vpnService, Notify notify)", "testcase": false, "constructor": true}, {"identifier": "getDnsServers", "parameters": "(Context context)", "modifiers": "private static", "return": "List<InetAddress>", "signature": "List<InetAddress> getDnsServers(Context context)", "full_signature": "private static List<InetAddress> getDnsServers(Context context)", "class_method_signature": "AdVpnThread.getDnsServers(Context context)", "testcase": false, "constructor": false}, {"identifier": "startThread", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void startThread()", "full_signature": "public void startThread()", "class_method_signature": "AdVpnThread.startThread()", "testcase": false, "constructor": false}, {"identifier": "stopThread", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void stopThread()", "full_signature": "public void stopThread()", "class_method_signature": "AdVpnThread.stopThread()", "testcase": false, "constructor": false}, {"identifier": "run", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void run()", "full_signature": "@Override public synchronized void run()", "class_method_signature": "AdVpnThread.run()", "testcase": false, "constructor": false}, {"identifier": "runVpn", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void runVpn()", "full_signature": "private void runVpn()", "class_method_signature": "AdVpnThread.runVpn()", "testcase": false, "constructor": false}, {"identifier": "doOne", "parameters": "(FileInputStream inputStream, FileOutputStream outFd, byte[] packet)", "modifiers": "private", "return": "boolean", "signature": "boolean doOne(FileInputStream inputStream, FileOutputStream outFd, byte[] packet)", "full_signature": "private boolean doOne(FileInputStream inputStream, FileOutputStream outFd, byte[] packet)", "class_method_signature": "AdVpnThread.doOne(FileInputStream inputStream, FileOutputStream outFd, byte[] packet)", "testcase": false, "constructor": false}, {"identifier": "writeToDevice", "parameters": "(FileOutputStream outFd)", "modifiers": "private", "return": "void", "signature": "void writeToDevice(FileOutputStream outFd)", "full_signature": "private void writeToDevice(FileOutputStream outFd)", "class_method_signature": "AdVpnThread.writeToDevice(FileOutputStream outFd)", "testcase": false, "constructor": false}, {"identifier": "readPacketFromDevice", "parameters": "(FileInputStream inputStream, byte[] packet)", "modifiers": "private", "return": "void", "signature": "void readPacketFromDevice(FileInputStream inputStream, byte[] packet)", "full_signature": "private void readPacketFromDevice(FileInputStream inputStream, byte[] packet)", "class_method_signature": "AdVpnThread.readPacketFromDevice(FileInputStream inputStream, byte[] packet)", "testcase": false, "constructor": false}, {"identifier": "forwardPacket", "parameters": "(DatagramPacket outPacket, IpPacket parsedPacket)", "modifiers": "public", "return": "void", "signature": "void forwardPacket(DatagramPacket outPacket, IpPacket parsedPacket)", "full_signature": "public void forwardPacket(DatagramPacket outPacket, IpPacket parsedPacket)", "class_method_signature": "AdVpnThread.forwardPacket(DatagramPacket outPacket, IpPacket parsedPacket)", "testcase": false, "constructor": false}, {"identifier": "handleRawDnsResponse", "parameters": "(IpPacket parsedPacket, DatagramSocket dnsSocket)", "modifiers": "private", "return": "void", "signature": "void handleRawDnsResponse(IpPacket parsedPacket, DatagramSocket dnsSocket)", "full_signature": "private void handleRawDnsResponse(IpPacket parsedPacket, DatagramSocket dnsSocket)", "class_method_signature": "AdVpnThread.handleRawDnsResponse(IpPacket parsedPacket, DatagramSocket dnsSocket)", "testcase": false, "constructor": false}, {"identifier": "queueDeviceWrite", "parameters": "(IpPacket ipOutPacket)", "modifiers": "public", "return": "void", "signature": "void queueDeviceWrite(IpPacket ipOutPacket)", "full_signature": "public void queueDeviceWrite(IpPacket ipOutPacket)", "class_method_signature": "AdVpnThread.queueDeviceWrite(IpPacket ipOutPacket)", "testcase": false, "constructor": false}, {"identifier": "newDNSServer", "parameters": "(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "modifiers": "", "return": "void", "signature": "void newDNSServer(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "full_signature": " void newDNSServer(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "class_method_signature": "AdVpnThread.newDNSServer(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "testcase": false, "constructor": false}, {"identifier": "configurePackages", "parameters": "(VpnService.Builder builder, Configuration config)", "modifiers": "", "return": "void", "signature": "void configurePackages(VpnService.Builder builder, Configuration config)", "full_signature": " void configurePackages(VpnService.Builder builder, Configuration config)", "class_method_signature": "AdVpnThread.configurePackages(VpnService.Builder builder, Configuration config)", "testcase": false, "constructor": false}, {"identifier": "configure", "parameters": "()", "modifiers": "private", "return": "ParcelFileDescriptor", "signature": "ParcelFileDescriptor configure()", "full_signature": "private ParcelFileDescriptor configure()", "class_method_signature": "AdVpnThread.configure()", "testcase": false, "constructor": false}, {"identifier": "hasIpV6Servers", "parameters": "(Configuration config, List<InetAddress> dnsServers)", "modifiers": "", "return": "boolean", "signature": "boolean hasIpV6Servers(Configuration config, List<InetAddress> dnsServers)", "full_signature": " boolean hasIpV6Servers(Configuration config, List<InetAddress> dnsServers)", "class_method_signature": "AdVpnThread.hasIpV6Servers(Configuration config, List<InetAddress> dnsServers)", "testcase": false, "constructor": false}], "file": "app/src/main/java/org/jak_linux/dns66/vpn/AdVpnThread.java"}, "focal_method": {"identifier": "newDNSServer", "parameters": "(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "modifiers": "", "return": "void", "body": "void newDNSServer(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr) throws UnknownHostException {\n        // Optimally we'd allow either one, but the forwarder checks if upstream size is empty, so\n        // we really need to acquire both an ipv6 and an ipv4 subnet.\n        if (addr instanceof Inet6Address && ipv6Template == null) {\n            Log.i(TAG, \"newDNSServer: Ignoring DNS server \" + addr);\n        } else if (addr instanceof Inet4Address && format == null) {\n            Log.i(TAG, \"newDNSServer: Ignoring DNS server \" + addr);\n        } else if (addr instanceof Inet4Address) {\n            upstreamDnsServers.add(addr);\n            String alias = String.format(format, upstreamDnsServers.size() + 1);\n            Log.i(TAG, \"configure: Adding DNS Server \" + addr + \" as \" + alias);\n            builder.addDnsServer(alias);\n            builder.addRoute(alias, 32);\n            vpnWatchDog.setTarget(InetAddress.getByName(alias));\n        } else if (addr instanceof Inet6Address) {\n            upstreamDnsServers.add(addr);\n            ipv6Template[ipv6Template.length - 1] = (byte) (upstreamDnsServers.size() + 1);\n            InetAddress i6addr = Inet6Address.getByAddress(ipv6Template);\n            Log.i(TAG, \"configure: Adding DNS Server \" + addr + \" as \" + i6addr);\n            builder.addDnsServer(i6addr);\n            vpnWatchDog.setTarget(i6addr);\n        }\n    }", "signature": "void newDNSServer(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "full_signature": " void newDNSServer(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "class_method_signature": "AdVpnThread.newDNSServer(VpnService.Builder builder, String format, byte[] ipv6Template, InetAddress addr)", "testcase": false, "constructor": false, "invocations": ["i", "i", "add", "format", "size", "i", "addDnsServer", "addRoute", "setTarget", "getByName", "add", "size", "getByAddress", "i", "addDnsServer", "setTarget"]}, "repository": {"repo_id": 70996010, "url": "https://github.com/julian-klode/dns66", "stars": 1372, "created": "10/15/2016 3:27:17 PM +00:00", "updates": "2020-01-26T10:51:30+00:00", "fork": "False", "license": "licensed"}}