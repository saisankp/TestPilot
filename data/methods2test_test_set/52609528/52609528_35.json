{"test_class": {"identifier": "QueueCircuitBreakerImplTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private Vertx vertx;", "modifier": "private", "type": "Vertx", "declarator": "vertx", "var_name": "vertx"}, {"original_string": "private Lock lock;", "modifier": "private", "type": "Lock", "declarator": "lock", "var_name": "lock"}, {"original_string": "private ResourceStorage storage;", "modifier": "private", "type": "ResourceStorage", "declarator": "storage", "var_name": "storage"}, {"original_string": "private RuleProvider ruleProvider;", "modifier": "private", "type": "RuleProvider", "declarator": "ruleProvider", "var_name": "ruleProvider"}, {"original_string": "private QueueCircuitBreakerStorage queueCircuitBreakerStorage;", "modifier": "private", "type": "QueueCircuitBreakerStorage", "declarator": "queueCircuitBreakerStorage", "var_name": "queueCircuitBreakerStorage"}, {"original_string": "private Map<String, Object> props = new HashMap<>();", "modifier": "private", "type": "Map<String, Object>", "declarator": "props = new HashMap<>()", "var_name": "props"}, {"original_string": "private QueueCircuitBreakerImpl queueCircuitBreaker;", "modifier": "private", "type": "QueueCircuitBreakerImpl", "declarator": "queueCircuitBreaker", "var_name": "queueCircuitBreaker"}, {"original_string": "private QueueCircuitBreakerRulePatternToCircuitMapping ruleToCircuitMapping;", "modifier": "private", "type": "QueueCircuitBreakerRulePatternToCircuitMapping", "declarator": "ruleToCircuitMapping", "var_name": "ruleToCircuitMapping"}, {"original_string": "private QueueCircuitBreakerConfigurationResourceManager configResourceManager;", "modifier": "private", "type": "QueueCircuitBreakerConfigurationResourceManager", "declarator": "configResourceManager", "var_name": "configResourceManager"}, {"original_string": "@org.junit.Rule\n    public Timeout rule = Timeout.seconds(5);", "modifier": "@org.junit.Rule\n    public", "type": "Timeout", "declarator": "rule = Timeout.seconds(5)", "var_name": "rule"}], "file": "gateleen-queue/src/test/java/org/swisspush/gateleen/queue/queuing/circuitbreaker/impl/QueueCircuitBreakerImplTest.java"}, "test_case": {"identifier": "testUnlockNextQueue", "parameters": "(TestContext context)", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testUnlockNextQueue(TestContext context){\n        Async async = context.async(2);\n\n        Mockito.when(queueCircuitBreakerStorage.popQueueToUnlock())\n                .thenReturn(Future.succeededFuture(\"queue_1\"));\n\n        vertx.eventBus().consumer(Address.redisquesAddress(), (Message<JsonObject> event) -> {\n            context.assertEquals(\"deleteLock\", event.body().getString(\"operation\"));\n            event.reply(new JsonObject().put(\"status\", \"ok\"));\n            async.countDown();\n        });\n\n        queueCircuitBreaker.unlockNextQueue().setHandler(event -> {\n            context.assertTrue(event.succeeded());\n            context.assertEquals(\"queue_1\", event.result());\n            verify(queueCircuitBreakerStorage, times(1)).popQueueToUnlock();\n            async.countDown();\n        });\n        async.awaitSuccess();\n    }", "signature": "void testUnlockNextQueue(TestContext context)", "full_signature": "@Test public void testUnlockNextQueue(TestContext context)", "class_method_signature": "QueueCircuitBreakerImplTest.testUnlockNextQueue(TestContext context)", "testcase": true, "constructor": false, "invocations": ["async", "thenReturn", "when", "popQueueToUnlock", "succeededFuture", "consumer", "eventBus", "redisquesAddress", "assertEquals", "getString", "body", "reply", "put", "countDown", "setHandler", "unlockNextQueue", "assertTrue", "succeeded", "assertEquals", "result", "popQueueToUnlock", "verify", "times", "countDown", "awaitSuccess"]}, "focal_class": {"identifier": "QueueCircuitBreakerImpl", "superclass": "", "interfaces": "implements QueueCircuitBreaker, RuleChangesObserver, Refreshable", "fields": [{"original_string": "private Logger log = LoggerFactory.getLogger(QueueCircuitBreakerImpl.class);", "modifier": "private", "type": "Logger", "declarator": "log = LoggerFactory.getLogger(QueueCircuitBreakerImpl.class)", "var_name": "log"}, {"original_string": "private Vertx vertx;", "modifier": "private", "type": "Vertx", "declarator": "vertx", "var_name": "vertx"}, {"original_string": "private QueueCircuitBreakerStorage queueCircuitBreakerStorage;", "modifier": "private", "type": "QueueCircuitBreakerStorage", "declarator": "queueCircuitBreakerStorage", "var_name": "queueCircuitBreakerStorage"}, {"original_string": "private QueueCircuitBreakerRulePatternToCircuitMapping ruleToCircuitMapping;", "modifier": "private", "type": "QueueCircuitBreakerRulePatternToCircuitMapping", "declarator": "ruleToCircuitMapping", "var_name": "ruleToCircuitMapping"}, {"original_string": "private QueueCircuitBreakerConfigurationResourceManager configResourceManager;", "modifier": "private", "type": "QueueCircuitBreakerConfigurationResourceManager", "declarator": "configResourceManager", "var_name": "configResourceManager"}, {"original_string": "private Lock lock;", "modifier": "private", "type": "Lock", "declarator": "lock", "var_name": "lock"}, {"original_string": "public static final String OPEN_TO_HALF_OPEN_TASK_LOCK = \"openToHalfOpenTask\";", "modifier": "public static final", "type": "String", "declarator": "OPEN_TO_HALF_OPEN_TASK_LOCK = \"openToHalfOpenTask\"", "var_name": "OPEN_TO_HALF_OPEN_TASK_LOCK"}, {"original_string": "public static final String UNLOCK_QUEUES_TASK_LOCK = \"unlockQueuesTask\";", "modifier": "public static final", "type": "String", "declarator": "UNLOCK_QUEUES_TASK_LOCK = \"unlockQueuesTask\"", "var_name": "UNLOCK_QUEUES_TASK_LOCK"}, {"original_string": "public static final String UNLOCK_SAMPLE_QUEUES_TASK_LOCK = \"unlockSampleQueuesTask\";", "modifier": "public static final", "type": "String", "declarator": "UNLOCK_SAMPLE_QUEUES_TASK_LOCK = \"unlockSampleQueuesTask\"", "var_name": "UNLOCK_SAMPLE_QUEUES_TASK_LOCK"}, {"original_string": "private String redisquesAddress;", "modifier": "private", "type": "String", "declarator": "redisquesAddress", "var_name": "redisquesAddress"}, {"original_string": "private long openToHalfOpenTimerId = -1;", "modifier": "private", "type": "long", "declarator": "openToHalfOpenTimerId = -1", "var_name": "openToHalfOpenTimerId"}, {"original_string": "private long unlockQueuesTimerId = -1;", "modifier": "private", "type": "long", "declarator": "unlockQueuesTimerId = -1", "var_name": "unlockQueuesTimerId"}, {"original_string": "private long unlockSampleQueuesTimerId = -1;", "modifier": "private", "type": "long", "declarator": "unlockSampleQueuesTimerId = -1", "var_name": "unlockSampleQueuesTimerId"}], "methods": [{"identifier": "QueueCircuitBreakerImpl", "parameters": "(Vertx vertx, Lock lock, String redisquesAddress, QueueCircuitBreakerStorage queueCircuitBreakerStorage, RuleProvider ruleProvider, QueueCircuitBreakerRulePatternToCircuitMapping ruleToCircuitMapping, QueueCircuitBreakerConfigurationResourceManager configResourceManager, Handler<HttpServerRequest> queueCircuitBreakerHttpRequestHandler, int requestHandlerPort)", "modifiers": "public", "return": "", "signature": " QueueCircuitBreakerImpl(Vertx vertx, Lock lock, String redisquesAddress, QueueCircuitBreakerStorage queueCircuitBreakerStorage, RuleProvider ruleProvider, QueueCircuitBreakerRulePatternToCircuitMapping ruleToCircuitMapping, QueueCircuitBreakerConfigurationResourceManager configResourceManager, Handler<HttpServerRequest> queueCircuitBreakerHttpRequestHandler, int requestHandlerPort)", "full_signature": "public  QueueCircuitBreakerImpl(Vertx vertx, Lock lock, String redisquesAddress, QueueCircuitBreakerStorage queueCircuitBreakerStorage, RuleProvider ruleProvider, QueueCircuitBreakerRulePatternToCircuitMapping ruleToCircuitMapping, QueueCircuitBreakerConfigurationResourceManager configResourceManager, Handler<HttpServerRequest> queueCircuitBreakerHttpRequestHandler, int requestHandlerPort)", "class_method_signature": "QueueCircuitBreakerImpl.QueueCircuitBreakerImpl(Vertx vertx, Lock lock, String redisquesAddress, QueueCircuitBreakerStorage queueCircuitBreakerStorage, RuleProvider ruleProvider, QueueCircuitBreakerRulePatternToCircuitMapping ruleToCircuitMapping, QueueCircuitBreakerConfigurationResourceManager configResourceManager, Handler<HttpServerRequest> queueCircuitBreakerHttpRequestHandler, int requestHandlerPort)", "testcase": false, "constructor": true}, {"identifier": "registerPeriodicTasks", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void registerPeriodicTasks()", "full_signature": "private void registerPeriodicTasks()", "class_method_signature": "QueueCircuitBreakerImpl.registerPeriodicTasks()", "testcase": false, "constructor": false}, {"identifier": "createToken", "parameters": "(String appendix)", "modifiers": "private", "return": "String", "signature": "String createToken(String appendix)", "full_signature": "private String createToken(String appendix)", "class_method_signature": "QueueCircuitBreakerImpl.createToken(String appendix)", "testcase": false, "constructor": false}, {"identifier": "getLockExpiry", "parameters": "(int taskInterval)", "modifiers": "private", "return": "long", "signature": "long getLockExpiry(int taskInterval)", "full_signature": "private long getLockExpiry(int taskInterval)", "class_method_signature": "QueueCircuitBreakerImpl.getLockExpiry(int taskInterval)", "testcase": false, "constructor": false}, {"identifier": "registerOpenToHalfOpenTask", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void registerOpenToHalfOpenTask()", "full_signature": "private void registerOpenToHalfOpenTask()", "class_method_signature": "QueueCircuitBreakerImpl.registerOpenToHalfOpenTask()", "testcase": false, "constructor": false}, {"identifier": "registerUnlockQueuesTask", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void registerUnlockQueuesTask()", "full_signature": "private void registerUnlockQueuesTask()", "class_method_signature": "QueueCircuitBreakerImpl.registerUnlockQueuesTask()", "testcase": false, "constructor": false}, {"identifier": "registerUnlockSampleQueuesTask", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void registerUnlockSampleQueuesTask()", "full_signature": "private void registerUnlockSampleQueuesTask()", "class_method_signature": "QueueCircuitBreakerImpl.registerUnlockSampleQueuesTask()", "testcase": false, "constructor": false}, {"identifier": "rulesChanged", "parameters": "(List<Rule> rules)", "modifiers": "@Override public", "return": "void", "signature": "void rulesChanged(List<Rule> rules)", "full_signature": "@Override public void rulesChanged(List<Rule> rules)", "class_method_signature": "QueueCircuitBreakerImpl.rulesChanged(List<Rule> rules)", "testcase": false, "constructor": false}, {"identifier": "refresh", "parameters": "()", "modifiers": "@Override public", "return": "void", "signature": "void refresh()", "full_signature": "@Override public void refresh()", "class_method_signature": "QueueCircuitBreakerImpl.refresh()", "testcase": false, "constructor": false}, {"identifier": "isCircuitCheckEnabled", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isCircuitCheckEnabled()", "full_signature": "@Override public boolean isCircuitCheckEnabled()", "class_method_signature": "QueueCircuitBreakerImpl.isCircuitCheckEnabled()", "testcase": false, "constructor": false}, {"identifier": "isStatisticsUpdateEnabled", "parameters": "()", "modifiers": "@Override public", "return": "boolean", "signature": "boolean isStatisticsUpdateEnabled()", "full_signature": "@Override public boolean isStatisticsUpdateEnabled()", "class_method_signature": "QueueCircuitBreakerImpl.isStatisticsUpdateEnabled()", "testcase": false, "constructor": false}, {"identifier": "handleQueuedRequest", "parameters": "(String queueName, HttpRequest queuedRequest)", "modifiers": "@Override public", "return": "Future<QueueCircuitState>", "signature": "Future<QueueCircuitState> handleQueuedRequest(String queueName, HttpRequest queuedRequest)", "full_signature": "@Override public Future<QueueCircuitState> handleQueuedRequest(String queueName, HttpRequest queuedRequest)", "class_method_signature": "QueueCircuitBreakerImpl.handleQueuedRequest(String queueName, HttpRequest queuedRequest)", "testcase": false, "constructor": false}, {"identifier": "updateStatistics", "parameters": "(String queueName, HttpRequest queuedRequest, QueueResponseType queueResponseType)", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> updateStatistics(String queueName, HttpRequest queuedRequest, QueueResponseType queueResponseType)", "full_signature": "@Override public Future<Void> updateStatistics(String queueName, HttpRequest queuedRequest, QueueResponseType queueResponseType)", "class_method_signature": "QueueCircuitBreakerImpl.updateStatistics(String queueName, HttpRequest queuedRequest, QueueResponseType queueResponseType)", "testcase": false, "constructor": false}, {"identifier": "closeCircuit", "parameters": "(HttpRequest queuedRequest)", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> closeCircuit(HttpRequest queuedRequest)", "full_signature": "@Override public Future<Void> closeCircuit(HttpRequest queuedRequest)", "class_method_signature": "QueueCircuitBreakerImpl.closeCircuit(HttpRequest queuedRequest)", "testcase": false, "constructor": false}, {"identifier": "closeAndRemoveCircuit", "parameters": "(PatternAndCircuitHash patternAndCircuitHash)", "modifiers": "private", "return": "void", "signature": "void closeAndRemoveCircuit(PatternAndCircuitHash patternAndCircuitHash)", "full_signature": "private void closeAndRemoveCircuit(PatternAndCircuitHash patternAndCircuitHash)", "class_method_signature": "QueueCircuitBreakerImpl.closeAndRemoveCircuit(PatternAndCircuitHash patternAndCircuitHash)", "testcase": false, "constructor": false}, {"identifier": "closeAllCircuits", "parameters": "()", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> closeAllCircuits()", "full_signature": "@Override public Future<Void> closeAllCircuits()", "class_method_signature": "QueueCircuitBreakerImpl.closeAllCircuits()", "testcase": false, "constructor": false}, {"identifier": "reOpenCircuit", "parameters": "(HttpRequest queuedRequest)", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> reOpenCircuit(HttpRequest queuedRequest)", "full_signature": "@Override public Future<Void> reOpenCircuit(HttpRequest queuedRequest)", "class_method_signature": "QueueCircuitBreakerImpl.reOpenCircuit(HttpRequest queuedRequest)", "testcase": false, "constructor": false}, {"identifier": "lockQueue", "parameters": "(String queueName, HttpRequest queuedRequest)", "modifiers": "@Override public", "return": "Future<Void>", "signature": "Future<Void> lockQueue(String queueName, HttpRequest queuedRequest)", "full_signature": "@Override public Future<Void> lockQueue(String queueName, HttpRequest queuedRequest)", "class_method_signature": "QueueCircuitBreakerImpl.lockQueue(String queueName, HttpRequest queuedRequest)", "testcase": false, "constructor": false}, {"identifier": "unlockNextQueue", "parameters": "()", "modifiers": "@Override public", "return": "Future<String>", "signature": "Future<String> unlockNextQueue()", "full_signature": "@Override public Future<String> unlockNextQueue()", "class_method_signature": "QueueCircuitBreakerImpl.unlockNextQueue()", "testcase": false, "constructor": false}, {"identifier": "logQueueUnlockError", "parameters": "(String queueToUnlock, String errorMessage)", "modifiers": "private", "return": "void", "signature": "void logQueueUnlockError(String queueToUnlock, String errorMessage)", "full_signature": "private void logQueueUnlockError(String queueToUnlock, String errorMessage)", "class_method_signature": "QueueCircuitBreakerImpl.logQueueUnlockError(String queueToUnlock, String errorMessage)", "testcase": false, "constructor": false}, {"identifier": "setOpenCircuitsToHalfOpen", "parameters": "()", "modifiers": "@Override public", "return": "Future<Long>", "signature": "Future<Long> setOpenCircuitsToHalfOpen()", "full_signature": "@Override public Future<Long> setOpenCircuitsToHalfOpen()", "class_method_signature": "QueueCircuitBreakerImpl.setOpenCircuitsToHalfOpen()", "testcase": false, "constructor": false}, {"identifier": "unlockSampleQueues", "parameters": "()", "modifiers": "@Override public", "return": "Future<Long>", "signature": "Future<Long> unlockSampleQueues()", "full_signature": "@Override public Future<Long> unlockSampleQueues()", "class_method_signature": "QueueCircuitBreakerImpl.unlockSampleQueues()", "testcase": false, "constructor": false}, {"identifier": "unlockQueue", "parameters": "(String queueName)", "modifiers": "@Override public", "return": "Future<String>", "signature": "Future<String> unlockQueue(String queueName)", "full_signature": "@Override public Future<String> unlockQueue(String queueName)", "class_method_signature": "QueueCircuitBreakerImpl.unlockQueue(String queueName)", "testcase": false, "constructor": false}, {"identifier": "lockQueueSync", "parameters": "(String queueName, HttpRequest queuedRequest)", "modifiers": "private", "return": "void", "signature": "void lockQueueSync(String queueName, HttpRequest queuedRequest)", "full_signature": "private void lockQueueSync(String queueName, HttpRequest queuedRequest)", "class_method_signature": "QueueCircuitBreakerImpl.lockQueueSync(String queueName, HttpRequest queuedRequest)", "testcase": false, "constructor": false}, {"identifier": "failWithNoRuleToCircuitMappingMessage", "parameters": "(Future future, String queueName, HttpRequest request)", "modifiers": "private", "return": "void", "signature": "void failWithNoRuleToCircuitMappingMessage(Future future, String queueName, HttpRequest request)", "full_signature": "private void failWithNoRuleToCircuitMappingMessage(Future future, String queueName, HttpRequest request)", "class_method_signature": "QueueCircuitBreakerImpl.failWithNoRuleToCircuitMappingMessage(Future future, String queueName, HttpRequest request)", "testcase": false, "constructor": false}, {"identifier": "getPatternAndCircuitHashFromRequest", "parameters": "(HttpRequest request)", "modifiers": "private", "return": "PatternAndCircuitHash", "signature": "PatternAndCircuitHash getPatternAndCircuitHashFromRequest(HttpRequest request)", "full_signature": "private PatternAndCircuitHash getPatternAndCircuitHashFromRequest(HttpRequest request)", "class_method_signature": "QueueCircuitBreakerImpl.getPatternAndCircuitHashFromRequest(HttpRequest request)", "testcase": false, "constructor": false}, {"identifier": "getRequestUniqueId", "parameters": "(HttpRequest request)", "modifiers": "private", "return": "String", "signature": "String getRequestUniqueId(HttpRequest request)", "full_signature": "private String getRequestUniqueId(HttpRequest request)", "class_method_signature": "QueueCircuitBreakerImpl.getRequestUniqueId(HttpRequest request)", "testcase": false, "constructor": false}, {"identifier": "getConfig", "parameters": "()", "modifiers": "private", "return": "QueueCircuitBreakerConfigurationResource", "signature": "QueueCircuitBreakerConfigurationResource getConfig()", "full_signature": "private QueueCircuitBreakerConfigurationResource getConfig()", "class_method_signature": "QueueCircuitBreakerImpl.getConfig()", "testcase": false, "constructor": false}], "file": "gateleen-queue/src/main/java/org/swisspush/gateleen/queue/queuing/circuitbreaker/impl/QueueCircuitBreakerImpl.java"}, "focal_method": {"identifier": "unlockNextQueue", "parameters": "()", "modifiers": "@Override public", "return": "Future<String>", "body": "@Override\n    public Future<String> unlockNextQueue() {\n        log.debug(\"About to unlock the next queue\");\n        Future<String> future = Future.future();\n        queueCircuitBreakerStorage.popQueueToUnlock().setHandler(event -> {\n            if (event.failed()) {\n                future.fail(event.cause().getMessage());\n                return;\n            }\n            String queueToUnlock = event.result();\n            if (queueToUnlock != null) {\n                unlockQueue(queueToUnlock).setHandler(event1 -> {\n                    if (event1.failed()) {\n                        future.fail(event1.cause().getMessage());\n                        return;\n                    }\n                    future.complete(event1.result());\n                });\n            } else {\n                future.complete(null);\n            }\n        });\n        return future;\n    }", "signature": "Future<String> unlockNextQueue()", "full_signature": "@Override public Future<String> unlockNextQueue()", "class_method_signature": "QueueCircuitBreakerImpl.unlockNextQueue()", "testcase": false, "constructor": false, "invocations": ["debug", "future", "setHandler", "popQueueToUnlock", "failed", "fail", "getMessage", "cause", "result", "setHandler", "unlockQueue", "failed", "fail", "getMessage", "cause", "complete", "result", "complete"]}, "repository": {"repo_id": 52609528, "url": "https://github.com/swisspush/gateleen", "language": "Java", "is_fork": false, "fork_count": 28, "stargazer_count": 63, "size": 2919, "license": "licensed"}}