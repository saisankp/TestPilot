{"test_class": {"identifier": "AesCtrHmacStreamingTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "@Rule public TemporaryFolder tmpFolder = new TemporaryFolder();", "modifier": "@Rule public", "type": "TemporaryFolder", "declarator": "tmpFolder = new TemporaryFolder()", "var_name": "tmpFolder"}], "file": "java_src/src/test/java/com/google/crypto/tink/subtle/AesCtrHmacStreamingTest.java"}, "test_case": {"identifier": "testEncryptLimitedCiphertextChannel", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testEncryptLimitedCiphertextChannel() throws Exception {\n    int segmentSize = 512;\n    int firstSegmentOffset = 0;\n    int keySizeInBytes = 16;\n    int tagSizeInBytes = 12;\n    byte[] ikm =\n        TestUtil.hexDecode(\"000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff\");\n    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, \"HmacSha256\", keySizeInBytes,\n        \"HmacSha256\", tagSizeInBytes, segmentSize, firstSegmentOffset);\n\n    int plaintextSize = 1 << 15;\n    int maxChunkSize = 100;\n    byte[] aad = TestUtil.hexDecode(\"aabbccddeeff\");\n    byte[] plaintext = StreamingTestUtil.generatePlaintext(plaintextSize);\n    int ciphertextLength = (int) ags.expectedCiphertextSize(plaintextSize);\n    ByteBuffer ciphertext = ByteBuffer.allocate(ciphertextLength);\n    WritableByteChannel ctChannel = new SeekableByteBufferChannel(ciphertext, maxChunkSize);\n    WritableByteChannel encChannel = ags.newEncryptingChannel(ctChannel, aad);\n    ByteBuffer plaintextBuffer = ByteBuffer.wrap(plaintext);\n    int loops = 0;\n    while (plaintextBuffer.remaining() > 0) {\n      encChannel.write(plaintextBuffer);\n      loops += 1;\n      if (loops > 100000) {\n        System.out.println(encChannel.toString());\n        fail(\"Too many loops\");\n      }\n    }\n    encChannel.close();\n    assertFalse(encChannel.isOpen());\n    StreamingTestUtil.isValidCiphertext(ags, plaintext, aad, ciphertext.array());\n  }", "signature": "void testEncryptLimitedCiphertextChannel()", "full_signature": "@Test public void testEncryptLimitedCiphertextChannel()", "class_method_signature": "AesCtrHmacStreamingTest.testEncryptLimitedCiphertextChannel()", "testcase": true, "constructor": false, "invocations": ["hexDecode", "hexDecode", "generatePlaintext", "expectedCiphertextSize", "allocate", "newEncryptingChannel", "wrap", "remaining", "write", "println", "toString", "fail", "close", "assertFalse", "isOpen", "isValidCiphertext", "array"]}, "focal_class": {"identifier": "AesCtrHmacStreaming", "superclass": "extends NonceBasedStreamingAead", "interfaces": "", "fields": [{"original_string": "private static final int NONCE_SIZE_IN_BYTES = 16;", "modifier": "private static final", "type": "int", "declarator": "NONCE_SIZE_IN_BYTES = 16", "var_name": "NONCE_SIZE_IN_BYTES"}, {"original_string": "private static final int NONCE_PREFIX_IN_BYTES = 7;", "modifier": "private static final", "type": "int", "declarator": "NONCE_PREFIX_IN_BYTES = 7", "var_name": "NONCE_PREFIX_IN_BYTES"}, {"original_string": "private static final int HMAC_KEY_SIZE_IN_BYTES = 32;", "modifier": "private static final", "type": "int", "declarator": "HMAC_KEY_SIZE_IN_BYTES = 32", "var_name": "HMAC_KEY_SIZE_IN_BYTES"}, {"original_string": "private final int keySizeInBytes;", "modifier": "private final", "type": "int", "declarator": "keySizeInBytes", "var_name": "keySizeInBytes"}, {"original_string": "private final String tagAlgo;", "modifier": "private final", "type": "String", "declarator": "tagAlgo", "var_name": "tagAlgo"}, {"original_string": "private final int tagSizeInBytes;", "modifier": "private final", "type": "int", "declarator": "tagSizeInBytes", "var_name": "tagSizeInBytes"}, {"original_string": "private final int ciphertextSegmentSize;", "modifier": "private final", "type": "int", "declarator": "ciphertextSegmentSize", "var_name": "ciphertextSegmentSize"}, {"original_string": "private final int plaintextSegmentSize;", "modifier": "private final", "type": "int", "declarator": "plaintextSegmentSize", "var_name": "plaintextSegmentSize"}, {"original_string": "private final int firstSegmentOffset;", "modifier": "private final", "type": "int", "declarator": "firstSegmentOffset", "var_name": "firstSegmentOffset"}, {"original_string": "private final String hkdfAlgo;", "modifier": "private final", "type": "String", "declarator": "hkdfAlgo", "var_name": "hkdfAlgo"}, {"original_string": "private final byte[] ikm;", "modifier": "private final", "type": "byte[]", "declarator": "ikm", "var_name": "ikm"}], "methods": [{"identifier": "AesCtrHmacStreaming", "parameters": "(\n      byte[] ikm,\n      String hkdfAlgo,\n      int keySizeInBytes,\n      String tagAlgo,\n      int tagSizeInBytes,\n      int ciphertextSegmentSize,\n      int firstSegmentOffset)", "modifiers": "public", "return": "", "signature": " AesCtrHmacStreaming(\n      byte[] ikm,\n      String hkdfAlgo,\n      int keySizeInBytes,\n      String tagAlgo,\n      int tagSizeInBytes,\n      int ciphertextSegmentSize,\n      int firstSegmentOffset)", "full_signature": "public  AesCtrHmacStreaming(\n      byte[] ikm,\n      String hkdfAlgo,\n      int keySizeInBytes,\n      String tagAlgo,\n      int tagSizeInBytes,\n      int ciphertextSegmentSize,\n      int firstSegmentOffset)", "class_method_signature": "AesCtrHmacStreaming.AesCtrHmacStreaming(\n      byte[] ikm,\n      String hkdfAlgo,\n      int keySizeInBytes,\n      String tagAlgo,\n      int tagSizeInBytes,\n      int ciphertextSegmentSize,\n      int firstSegmentOffset)", "testcase": false, "constructor": true}, {"identifier": "validateParameters", "parameters": "(\n      int ikmSize,\n      int keySizeInBytes,\n      String tagAlgo,\n      int tagSizeInBytes,\n      int ciphertextSegmentSize,\n      int firstSegmentOffset)", "modifiers": "private static", "return": "void", "signature": "void validateParameters(\n      int ikmSize,\n      int keySizeInBytes,\n      String tagAlgo,\n      int tagSizeInBytes,\n      int ciphertextSegmentSize,\n      int firstSegmentOffset)", "full_signature": "private static void validateParameters(\n      int ikmSize,\n      int keySizeInBytes,\n      String tagAlgo,\n      int tagSizeInBytes,\n      int ciphertextSegmentSize,\n      int firstSegmentOffset)", "class_method_signature": "AesCtrHmacStreaming.validateParameters(\n      int ikmSize,\n      int keySizeInBytes,\n      String tagAlgo,\n      int tagSizeInBytes,\n      int ciphertextSegmentSize,\n      int firstSegmentOffset)", "testcase": false, "constructor": false}, {"identifier": "newStreamSegmentEncrypter", "parameters": "(byte[] aad)", "modifiers": "@Override public", "return": "AesCtrHmacStreamEncrypter", "signature": "AesCtrHmacStreamEncrypter newStreamSegmentEncrypter(byte[] aad)", "full_signature": "@Override public AesCtrHmacStreamEncrypter newStreamSegmentEncrypter(byte[] aad)", "class_method_signature": "AesCtrHmacStreaming.newStreamSegmentEncrypter(byte[] aad)", "testcase": false, "constructor": false}, {"identifier": "newStreamSegmentDecrypter", "parameters": "()", "modifiers": "@Override public", "return": "AesCtrHmacStreamDecrypter", "signature": "AesCtrHmacStreamDecrypter newStreamSegmentDecrypter()", "full_signature": "@Override public AesCtrHmacStreamDecrypter newStreamSegmentDecrypter()", "class_method_signature": "AesCtrHmacStreaming.newStreamSegmentDecrypter()", "testcase": false, "constructor": false}, {"identifier": "getCiphertextSegmentSize", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getCiphertextSegmentSize()", "full_signature": "@Override public int getCiphertextSegmentSize()", "class_method_signature": "AesCtrHmacStreaming.getCiphertextSegmentSize()", "testcase": false, "constructor": false}, {"identifier": "getPlaintextSegmentSize", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getPlaintextSegmentSize()", "full_signature": "@Override public int getPlaintextSegmentSize()", "class_method_signature": "AesCtrHmacStreaming.getPlaintextSegmentSize()", "testcase": false, "constructor": false}, {"identifier": "getHeaderLength", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getHeaderLength()", "full_signature": "@Override public int getHeaderLength()", "class_method_signature": "AesCtrHmacStreaming.getHeaderLength()", "testcase": false, "constructor": false}, {"identifier": "getCiphertextOffset", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getCiphertextOffset()", "full_signature": "@Override public int getCiphertextOffset()", "class_method_signature": "AesCtrHmacStreaming.getCiphertextOffset()", "testcase": false, "constructor": false}, {"identifier": "getCiphertextOverhead", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getCiphertextOverhead()", "full_signature": "@Override public int getCiphertextOverhead()", "class_method_signature": "AesCtrHmacStreaming.getCiphertextOverhead()", "testcase": false, "constructor": false}, {"identifier": "getFirstSegmentOffset", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getFirstSegmentOffset()", "full_signature": "public int getFirstSegmentOffset()", "class_method_signature": "AesCtrHmacStreaming.getFirstSegmentOffset()", "testcase": false, "constructor": false}, {"identifier": "expectedCiphertextSize", "parameters": "(long plaintextSize)", "modifiers": "public", "return": "long", "signature": "long expectedCiphertextSize(long plaintextSize)", "full_signature": "public long expectedCiphertextSize(long plaintextSize)", "class_method_signature": "AesCtrHmacStreaming.expectedCiphertextSize(long plaintextSize)", "testcase": false, "constructor": false}, {"identifier": "cipherInstance", "parameters": "()", "modifiers": "private static", "return": "Cipher", "signature": "Cipher cipherInstance()", "full_signature": "private static Cipher cipherInstance()", "class_method_signature": "AesCtrHmacStreaming.cipherInstance()", "testcase": false, "constructor": false}, {"identifier": "macInstance", "parameters": "()", "modifiers": "private", "return": "Mac", "signature": "Mac macInstance()", "full_signature": "private Mac macInstance()", "class_method_signature": "AesCtrHmacStreaming.macInstance()", "testcase": false, "constructor": false}, {"identifier": "randomSalt", "parameters": "()", "modifiers": "private", "return": "byte[]", "signature": "byte[] randomSalt()", "full_signature": "private byte[] randomSalt()", "class_method_signature": "AesCtrHmacStreaming.randomSalt()", "testcase": false, "constructor": false}, {"identifier": "nonceForSegment", "parameters": "(byte[] prefix, long segmentNr, boolean last)", "modifiers": "private", "return": "byte[]", "signature": "byte[] nonceForSegment(byte[] prefix, long segmentNr, boolean last)", "full_signature": "private byte[] nonceForSegment(byte[] prefix, long segmentNr, boolean last)", "class_method_signature": "AesCtrHmacStreaming.nonceForSegment(byte[] prefix, long segmentNr, boolean last)", "testcase": false, "constructor": false}, {"identifier": "randomNonce", "parameters": "()", "modifiers": "private", "return": "byte[]", "signature": "byte[] randomNonce()", "full_signature": "private byte[] randomNonce()", "class_method_signature": "AesCtrHmacStreaming.randomNonce()", "testcase": false, "constructor": false}, {"identifier": "deriveKeyMaterial", "parameters": "(byte[] salt, byte[] aad)", "modifiers": "private", "return": "byte[]", "signature": "byte[] deriveKeyMaterial(byte[] salt, byte[] aad)", "full_signature": "private byte[] deriveKeyMaterial(byte[] salt, byte[] aad)", "class_method_signature": "AesCtrHmacStreaming.deriveKeyMaterial(byte[] salt, byte[] aad)", "testcase": false, "constructor": false}, {"identifier": "deriveKeySpec", "parameters": "(byte[] keyMaterial)", "modifiers": "private", "return": "SecretKeySpec", "signature": "SecretKeySpec deriveKeySpec(byte[] keyMaterial)", "full_signature": "private SecretKeySpec deriveKeySpec(byte[] keyMaterial)", "class_method_signature": "AesCtrHmacStreaming.deriveKeySpec(byte[] keyMaterial)", "testcase": false, "constructor": false}, {"identifier": "deriveHmacKeySpec", "parameters": "(byte[] keyMaterial)", "modifiers": "private", "return": "SecretKeySpec", "signature": "SecretKeySpec deriveHmacKeySpec(byte[] keyMaterial)", "full_signature": "private SecretKeySpec deriveHmacKeySpec(byte[] keyMaterial)", "class_method_signature": "AesCtrHmacStreaming.deriveHmacKeySpec(byte[] keyMaterial)", "testcase": false, "constructor": false}], "file": "java_src/src/main/java/com/google/crypto/tink/subtle/AesCtrHmacStreaming.java"}, "focal_method": {"identifier": "expectedCiphertextSize", "parameters": "(long plaintextSize)", "modifiers": "public", "return": "long", "body": "public long expectedCiphertextSize(long plaintextSize) {\n    long offset = getCiphertextOffset();\n    long fullSegments = (plaintextSize + offset) / plaintextSegmentSize;\n    long ciphertextSize = fullSegments * ciphertextSegmentSize;\n    long lastSegmentSize = (plaintextSize + offset) % plaintextSegmentSize;\n    if (lastSegmentSize > 0) {\n      ciphertextSize += lastSegmentSize + tagSizeInBytes;\n    }\n    return ciphertextSize;\n  }", "signature": "long expectedCiphertextSize(long plaintextSize)", "full_signature": "public long expectedCiphertextSize(long plaintextSize)", "class_method_signature": "AesCtrHmacStreaming.expectedCiphertextSize(long plaintextSize)", "testcase": false, "constructor": false, "invocations": ["getCiphertextOffset"]}, "repository": {"repo_id": 20570214, "url": "https://github.com/google/tink", "stars": 8884, "created": "6/6/2014 4:21:09 PM +00:00", "updates": "2020-01-27T11:52:16+00:00", "fork": "False", "license": "licensed"}}