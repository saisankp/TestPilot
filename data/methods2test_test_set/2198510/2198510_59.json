{"test_class": {"identifier": "TestDatasetSink", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final String FILE_REPO_URI = \"repo:file:target/test_repo\";", "modifier": "public static final", "type": "String", "declarator": "FILE_REPO_URI = \"repo:file:target/test_repo\"", "var_name": "FILE_REPO_URI"}, {"original_string": "public static final String DATASET_NAME = \"test\";", "modifier": "public static final", "type": "String", "declarator": "DATASET_NAME = \"test\"", "var_name": "DATASET_NAME"}, {"original_string": "public static final String FILE_DATASET_URI =\n      \"dataset:file:target/test_repo/\" + DATASET_NAME;", "modifier": "public static final", "type": "String", "declarator": "FILE_DATASET_URI =\n      \"dataset:file:target/test_repo/\" + DATASET_NAME", "var_name": "FILE_DATASET_URI"}, {"original_string": "public static final String ERROR_DATASET_URI =\n      \"dataset:file:target/test_repo/failed_events\";", "modifier": "public static final", "type": "String", "declarator": "ERROR_DATASET_URI =\n      \"dataset:file:target/test_repo/failed_events\"", "var_name": "ERROR_DATASET_URI"}, {"original_string": "public static final File SCHEMA_FILE = new File(\"target/record-schema.avsc\");", "modifier": "public static final", "type": "File", "declarator": "SCHEMA_FILE = new File(\"target/record-schema.avsc\")", "var_name": "SCHEMA_FILE"}, {"original_string": "public static final Schema RECORD_SCHEMA = new Schema.Parser().parse(\n      \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"rec\\\",\\\"fields\\\":[\" +\n          \"{\\\"name\\\":\\\"id\\\",\\\"type\\\":\\\"string\\\"},\" +\n          \"{\\\"name\\\":\\\"msg\\\",\\\"type\\\":[\\\"string\\\",\\\"null\\\"],\" +\n              \"\\\"default\\\":\\\"default\\\"}]}\");", "modifier": "public static final", "type": "Schema", "declarator": "RECORD_SCHEMA = new Schema.Parser().parse(\n      \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"rec\\\",\\\"fields\\\":[\" +\n          \"{\\\"name\\\":\\\"id\\\",\\\"type\\\":\\\"string\\\"},\" +\n          \"{\\\"name\\\":\\\"msg\\\",\\\"type\\\":[\\\"string\\\",\\\"null\\\"],\" +\n              \"\\\"default\\\":\\\"default\\\"}]}\")", "var_name": "RECORD_SCHEMA"}, {"original_string": "public static final Schema COMPATIBLE_SCHEMA = new Schema.Parser().parse(\n      \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"rec\\\",\\\"fields\\\":[\" +\n          \"{\\\"name\\\":\\\"id\\\",\\\"type\\\":\\\"string\\\"}]}\");", "modifier": "public static final", "type": "Schema", "declarator": "COMPATIBLE_SCHEMA = new Schema.Parser().parse(\n      \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"rec\\\",\\\"fields\\\":[\" +\n          \"{\\\"name\\\":\\\"id\\\",\\\"type\\\":\\\"string\\\"}]}\")", "var_name": "COMPATIBLE_SCHEMA"}, {"original_string": "public static final Schema INCOMPATIBLE_SCHEMA = new Schema.Parser().parse(\n      \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"user\\\",\\\"fields\\\":[\" +\n          \"{\\\"name\\\":\\\"username\\\",\\\"type\\\":\\\"string\\\"}]}\");", "modifier": "public static final", "type": "Schema", "declarator": "INCOMPATIBLE_SCHEMA = new Schema.Parser().parse(\n      \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"user\\\",\\\"fields\\\":[\" +\n          \"{\\\"name\\\":\\\"username\\\",\\\"type\\\":\\\"string\\\"}]}\")", "var_name": "INCOMPATIBLE_SCHEMA"}, {"original_string": "public static final Schema UPDATED_SCHEMA = new Schema.Parser().parse(\n      \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"rec\\\",\\\"fields\\\":[\" +\n          \"{\\\"name\\\":\\\"id\\\",\\\"type\\\":\\\"string\\\"},\" +\n          \"{\\\"name\\\":\\\"priority\\\",\\\"type\\\":\\\"int\\\", \\\"default\\\": 0},\" +\n          \"{\\\"name\\\":\\\"msg\\\",\\\"type\\\":[\\\"string\\\",\\\"null\\\"],\" +\n          \"\\\"default\\\":\\\"default\\\"}]}\");", "modifier": "public static final", "type": "Schema", "declarator": "UPDATED_SCHEMA = new Schema.Parser().parse(\n      \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"rec\\\",\\\"fields\\\":[\" +\n          \"{\\\"name\\\":\\\"id\\\",\\\"type\\\":\\\"string\\\"},\" +\n          \"{\\\"name\\\":\\\"priority\\\",\\\"type\\\":\\\"int\\\", \\\"default\\\": 0},\" +\n          \"{\\\"name\\\":\\\"msg\\\",\\\"type\\\":[\\\"string\\\",\\\"null\\\"],\" +\n          \"\\\"default\\\":\\\"default\\\"}]}\")", "var_name": "UPDATED_SCHEMA"}, {"original_string": "public static final DatasetDescriptor DESCRIPTOR = new DatasetDescriptor\n      .Builder()\n      .schema(RECORD_SCHEMA)\n      .build();", "modifier": "public static final", "type": "DatasetDescriptor", "declarator": "DESCRIPTOR = new DatasetDescriptor\n      .Builder()\n      .schema(RECORD_SCHEMA)\n      .build()", "var_name": "DESCRIPTOR"}, {"original_string": "Context config = null;", "modifier": "", "type": "Context", "declarator": "config = null", "var_name": "config"}, {"original_string": "Channel in = null;", "modifier": "", "type": "Channel", "declarator": "in = null", "var_name": "in"}, {"original_string": "List<GenericRecord> expected = null;", "modifier": "", "type": "List<GenericRecord>", "declarator": "expected = null", "var_name": "expected"}, {"original_string": "private static final String DFS_DIR = \"target/test/dfs\";", "modifier": "private static final", "type": "String", "declarator": "DFS_DIR = \"target/test/dfs\"", "var_name": "DFS_DIR"}, {"original_string": "private static final String TEST_BUILD_DATA_KEY = \"test.build.data\";", "modifier": "private static final", "type": "String", "declarator": "TEST_BUILD_DATA_KEY = \"test.build.data\"", "var_name": "TEST_BUILD_DATA_KEY"}, {"original_string": "private static String oldTestBuildDataProp = null;", "modifier": "private static", "type": "String", "declarator": "oldTestBuildDataProp = null", "var_name": "oldTestBuildDataProp"}], "file": "flume-ng-sinks/flume-dataset-sink/src/test/java/org/apache/flume/sink/kite/TestDatasetSink.java"}, "test_case": {"identifier": "testCreateWriter", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testCreateWriter() throws EventDeliveryException {\n    config.put(DatasetSinkConstants.CONFIG_FLUSHABLE_COMMIT_ON_BATCH,\n        Boolean.toString(false));\n    config.put(DatasetSinkConstants.CONFIG_SYNCABLE_SYNC_ON_BATCH,\n        Boolean.toString(false));\n    DatasetSink sink = sink(in, config);\n\n    // run the sink\n    sink.start();\n    sink.process();\n\n    sink.commitTransaction();\n    sink.createWriter();\n    Assert.assertNotNull(\"Writer should not be null\", sink.getWriter());\n    Assert.assertEquals(\"Should have committed\", 0, remaining(in));\n\n    sink.stop();\n\n    Assert.assertEquals(0, read(Datasets.load(FILE_DATASET_URI)).size());\n  }", "signature": "void testCreateWriter()", "full_signature": "@Test public void testCreateWriter()", "class_method_signature": "TestDatasetSink.testCreateWriter()", "testcase": true, "constructor": false, "invocations": ["put", "toString", "put", "toString", "sink", "start", "process", "commitTransaction", "createWriter", "assertNotNull", "getWriter", "assertEquals", "remaining", "stop", "assertEquals", "size", "read", "load"]}, "focal_class": {"identifier": "DatasetSink", "superclass": "extends AbstractSink", "interfaces": "implements Configurable, BatchSizeSupported", "fields": [{"original_string": "private static final Logger LOG = LoggerFactory.getLogger(DatasetSink.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOG = LoggerFactory.getLogger(DatasetSink.class)", "var_name": "LOG"}, {"original_string": "private Context context = null;", "modifier": "private", "type": "Context", "declarator": "context = null", "var_name": "context"}, {"original_string": "private PrivilegedExecutor privilegedExecutor;", "modifier": "private", "type": "PrivilegedExecutor", "declarator": "privilegedExecutor", "var_name": "privilegedExecutor"}, {"original_string": "private String datasetName = null;", "modifier": "private", "type": "String", "declarator": "datasetName = null", "var_name": "datasetName"}, {"original_string": "private URI datasetUri = null;", "modifier": "private", "type": "URI", "declarator": "datasetUri = null", "var_name": "datasetUri"}, {"original_string": "private Schema datasetSchema = null;", "modifier": "private", "type": "Schema", "declarator": "datasetSchema = null", "var_name": "datasetSchema"}, {"original_string": "private DatasetWriter<GenericRecord> writer = null;", "modifier": "private", "type": "DatasetWriter<GenericRecord>", "declarator": "writer = null", "var_name": "writer"}, {"original_string": "private long batchSize = DEFAULT_BATCH_SIZE;", "modifier": "private", "type": "long", "declarator": "batchSize = DEFAULT_BATCH_SIZE", "var_name": "batchSize"}, {"original_string": "private int rollIntervalSeconds = DEFAULT_ROLL_INTERVAL;", "modifier": "private", "type": "int", "declarator": "rollIntervalSeconds = DEFAULT_ROLL_INTERVAL", "var_name": "rollIntervalSeconds"}, {"original_string": "private boolean commitOnBatch = DEFAULT_FLUSHABLE_COMMIT_ON_BATCH;", "modifier": "private", "type": "boolean", "declarator": "commitOnBatch = DEFAULT_FLUSHABLE_COMMIT_ON_BATCH", "var_name": "commitOnBatch"}, {"original_string": "private boolean syncOnBatch = DEFAULT_SYNCABLE_SYNC_ON_BATCH;", "modifier": "private", "type": "boolean", "declarator": "syncOnBatch = DEFAULT_SYNCABLE_SYNC_ON_BATCH", "var_name": "syncOnBatch"}, {"original_string": "private long lastRolledMillis = 0L;", "modifier": "private", "type": "long", "declarator": "lastRolledMillis = 0L", "var_name": "lastRolledMillis"}, {"original_string": "private long bytesParsed = 0L;", "modifier": "private", "type": "long", "declarator": "bytesParsed = 0L", "var_name": "bytesParsed"}, {"original_string": "private EntityParser<GenericRecord> parser = null;", "modifier": "private", "type": "EntityParser<GenericRecord>", "declarator": "parser = null", "var_name": "parser"}, {"original_string": "private FailurePolicy failurePolicy = null;", "modifier": "private", "type": "FailurePolicy", "declarator": "failurePolicy = null", "var_name": "failurePolicy"}, {"original_string": "private SinkCounter counter = null;", "modifier": "private", "type": "SinkCounter", "declarator": "counter = null", "var_name": "counter"}, {"original_string": "private GenericRecord entity = null;", "modifier": "private", "type": "GenericRecord", "declarator": "entity = null", "var_name": "entity"}, {"original_string": "private boolean reuseEntity = true;", "modifier": "private", "type": "boolean", "declarator": "reuseEntity = true", "var_name": "reuseEntity"}, {"original_string": "private Transaction transaction = null;", "modifier": "private", "type": "Transaction", "declarator": "transaction = null", "var_name": "transaction"}, {"original_string": "private boolean committedBatch = false;", "modifier": "private", "type": "boolean", "declarator": "committedBatch = false", "var_name": "committedBatch"}, {"original_string": "private static final EntityParserFactory ENTITY_PARSER_FACTORY =\n      new EntityParserFactory();", "modifier": "private static final", "type": "EntityParserFactory", "declarator": "ENTITY_PARSER_FACTORY =\n      new EntityParserFactory()", "var_name": "ENTITY_PARSER_FACTORY"}, {"original_string": "private static final FailurePolicyFactory FAILURE_POLICY_FACTORY =\n      new FailurePolicyFactory();", "modifier": "private static final", "type": "FailurePolicyFactory", "declarator": "FAILURE_POLICY_FACTORY =\n      new FailurePolicyFactory()", "var_name": "FAILURE_POLICY_FACTORY"}], "methods": [{"identifier": "allowedFormats", "parameters": "()", "modifiers": "protected", "return": "List<String>", "signature": "List<String> allowedFormats()", "full_signature": "protected List<String> allowedFormats()", "class_method_signature": "DatasetSink.allowedFormats()", "testcase": false, "constructor": false}, {"identifier": "configure", "parameters": "(Context context)", "modifiers": "@Override public", "return": "void", "signature": "void configure(Context context)", "full_signature": "@Override public void configure(Context context)", "class_method_signature": "DatasetSink.configure(Context context)", "testcase": false, "constructor": false}, {"identifier": "start", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void start()", "full_signature": "@Override public synchronized void start()", "class_method_signature": "DatasetSink.start()", "testcase": false, "constructor": false}, {"identifier": "roll", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void roll()", "full_signature": "@VisibleForTesting void roll()", "class_method_signature": "DatasetSink.roll()", "testcase": false, "constructor": false}, {"identifier": "getWriter", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "DatasetWriter<GenericRecord>", "signature": "DatasetWriter<GenericRecord> getWriter()", "full_signature": "@VisibleForTesting DatasetWriter<GenericRecord> getWriter()", "class_method_signature": "DatasetSink.getWriter()", "testcase": false, "constructor": false}, {"identifier": "setWriter", "parameters": "(DatasetWriter<GenericRecord> writer)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void setWriter(DatasetWriter<GenericRecord> writer)", "full_signature": "@VisibleForTesting void setWriter(DatasetWriter<GenericRecord> writer)", "class_method_signature": "DatasetSink.setWriter(DatasetWriter<GenericRecord> writer)", "testcase": false, "constructor": false}, {"identifier": "setParser", "parameters": "(EntityParser<GenericRecord> parser)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void setParser(EntityParser<GenericRecord> parser)", "full_signature": "@VisibleForTesting void setParser(EntityParser<GenericRecord> parser)", "class_method_signature": "DatasetSink.setParser(EntityParser<GenericRecord> parser)", "testcase": false, "constructor": false}, {"identifier": "setFailurePolicy", "parameters": "(FailurePolicy failurePolicy)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void setFailurePolicy(FailurePolicy failurePolicy)", "full_signature": "@VisibleForTesting void setFailurePolicy(FailurePolicy failurePolicy)", "class_method_signature": "DatasetSink.setFailurePolicy(FailurePolicy failurePolicy)", "testcase": false, "constructor": false}, {"identifier": "stop", "parameters": "()", "modifiers": "@Override public synchronized", "return": "void", "signature": "void stop()", "full_signature": "@Override public synchronized void stop()", "class_method_signature": "DatasetSink.stop()", "testcase": false, "constructor": false}, {"identifier": "process", "parameters": "()", "modifiers": "@Override public", "return": "Status", "signature": "Status process()", "full_signature": "@Override public Status process()", "class_method_signature": "DatasetSink.process()", "testcase": false, "constructor": false}, {"identifier": "write", "parameters": "(Event event)", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void write(Event event)", "full_signature": "@VisibleForTesting void write(Event event)", "class_method_signature": "DatasetSink.write(Event event)", "testcase": false, "constructor": false}, {"identifier": "createWriter", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void createWriter()", "full_signature": "@VisibleForTesting void createWriter()", "class_method_signature": "DatasetSink.createWriter()", "testcase": false, "constructor": false}, {"identifier": "shouldRoll", "parameters": "()", "modifiers": "private", "return": "boolean", "signature": "boolean shouldRoll()", "full_signature": "private boolean shouldRoll()", "class_method_signature": "DatasetSink.shouldRoll()", "testcase": false, "constructor": false}, {"identifier": "closeWriter", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "void", "signature": "void closeWriter()", "full_signature": "@VisibleForTesting void closeWriter()", "class_method_signature": "DatasetSink.closeWriter()", "testcase": false, "constructor": false}, {"identifier": "enterTransaction", "parameters": "(Channel channel)", "modifiers": "private", "return": "void", "signature": "void enterTransaction(Channel channel)", "full_signature": "private void enterTransaction(Channel channel)", "class_method_signature": "DatasetSink.enterTransaction(Channel channel)", "testcase": false, "constructor": false}, {"identifier": "commitTransaction", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "boolean", "signature": "boolean commitTransaction()", "full_signature": "@VisibleForTesting boolean commitTransaction()", "class_method_signature": "DatasetSink.commitTransaction()", "testcase": false, "constructor": false}, {"identifier": "rollbackTransaction", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void rollbackTransaction()", "full_signature": "private void rollbackTransaction()", "class_method_signature": "DatasetSink.rollbackTransaction()", "testcase": false, "constructor": false}, {"identifier": "uriToName", "parameters": "(URI uri)", "modifiers": "private static", "return": "String", "signature": "String uriToName(URI uri)", "full_signature": "private static String uriToName(URI uri)", "class_method_signature": "DatasetSink.uriToName(URI uri)", "testcase": false, "constructor": false}, {"identifier": "getBatchSize", "parameters": "()", "modifiers": "@Override public", "return": "long", "signature": "long getBatchSize()", "full_signature": "@Override public long getBatchSize()", "class_method_signature": "DatasetSink.getBatchSize()", "testcase": false, "constructor": false}], "file": "flume-ng-sinks/flume-dataset-sink/src/main/java/org/apache/flume/sink/kite/DatasetSink.java"}, "focal_method": {"identifier": "createWriter", "parameters": "()", "modifiers": "@VisibleForTesting", "return": "void", "body": "@VisibleForTesting\n  void createWriter() throws EventDeliveryException {\n    // reset the commited flag whenever a new writer is created\n    committedBatch = false;\n    try {\n      View<GenericRecord> view;\n\n      view = privilegedExecutor.execute(\n        new PrivilegedAction<Dataset<GenericRecord>>() {\n          @Override\n          public Dataset<GenericRecord> run() {\n            return Datasets.load(datasetUri);\n          }\n        });\n\n      DatasetDescriptor descriptor = view.getDataset().getDescriptor();\n      Format format = descriptor.getFormat();\n      Preconditions.checkArgument(allowedFormats().contains(format.getName()),\n          \"Unsupported format: \" + format.getName());\n\n      Schema newSchema = descriptor.getSchema();\n      if (datasetSchema == null || !newSchema.equals(datasetSchema)) {\n        this.datasetSchema = descriptor.getSchema();\n        // dataset schema has changed, create a new parser\n        parser = ENTITY_PARSER_FACTORY.newParser(datasetSchema, context);\n      }\n\n      this.reuseEntity = !(Formats.PARQUET.equals(format));\n\n      // TODO: Check that the format implements Flushable after CDK-863\n      // goes in. For now, just check that the Dataset is Avro format\n      this.commitOnBatch = context.getBoolean(CONFIG_FLUSHABLE_COMMIT_ON_BATCH,\n          DEFAULT_FLUSHABLE_COMMIT_ON_BATCH) && (Formats.AVRO.equals(format));\n\n      // TODO: Check that the format implements Syncable after CDK-863\n      // goes in. For now, just check that the Dataset is Avro format\n      this.syncOnBatch = context.getBoolean(CONFIG_SYNCABLE_SYNC_ON_BATCH,\n          DEFAULT_SYNCABLE_SYNC_ON_BATCH) && (Formats.AVRO.equals(format));\n\n      this.datasetName = view.getDataset().getName();\n\n      this.writer = view.newWriter();\n\n      // Reset the last rolled time and the metrics\n      this.lastRolledMillis = System.currentTimeMillis();\n      this.bytesParsed = 0L;\n    } catch (DatasetNotFoundException ex) {\n      throw new EventDeliveryException(\"Dataset \" + datasetUri + \" not found.\"\n          + \" The dataset must be created before Flume can write to it.\", ex);\n    } catch (RuntimeException ex) {\n      throw new EventDeliveryException(\"Error trying to open a new\"\n          + \" writer for dataset \" + datasetUri, ex);\n    }\n  }", "signature": "void createWriter()", "full_signature": "@VisibleForTesting void createWriter()", "class_method_signature": "DatasetSink.createWriter()", "testcase": false, "constructor": false, "invocations": ["execute", "load", "getDescriptor", "getDataset", "getFormat", "checkArgument", "contains", "allowedFormats", "getName", "getName", "getSchema", "equals", "getSchema", "newParser", "equals", "getBoolean", "equals", "getBoolean", "equals", "getName", "getDataset", "newWriter", "currentTimeMillis"]}, "repository": {"repo_id": 2198510, "url": "https://github.com/apache/flume", "language": "Java", "is_fork": false, "fork_count": 1372, "stargazer_count": 1971, "size": 44377, "license": "licensed"}}