{"test_class": {"identifier": "DataTypeParserTest", "superclass": "", "interfaces": "implements DdlConstants", "fields": [{"original_string": "private DataTypeParser parser;", "modifier": "private", "type": "DataTypeParser", "declarator": "parser", "var_name": "parser"}, {"original_string": "private boolean printTest = false;", "modifier": "private", "type": "boolean", "declarator": "printTest = false", "var_name": "printTest"}], "file": "sequencers/modeshape-sequencer-ddl/src/test/java/org/modeshape/sequencer/ddl/datatype/DataTypeParserTest.java"}, "test_case": {"identifier": "shouldParseFLOAT", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void shouldParseFLOAT() {\n        printTest(\"shouldParseFLOAT()\");\n        String typeString = getDataTypeString(DataTypes.DTYPE_FLOAT);\n        String content = typeString;\n\n        DdlTokenStream tokens = getTokens(content);\n\n        DataType dType = parser.parse(tokens);\n\n        Assert.assertNotNull(\"DataType was NOT found for Type = \" + typeString, dType);\n        Assert.assertEquals(\"Wrong DataType found\", typeString, dType.getName());\n\n        content = typeString + \" (5)\";\n        tokens = getTokens(content);\n        dType = parser.parse(tokens);\n        Assert.assertNotNull(\"DataType was NOT found for Type = \" + typeString, dType);\n        Assert.assertEquals(\"Wrong DataType found\", typeString, dType.getName());\n        Assert.assertEquals(\"DataType length is not correct\", 5, dType.getPrecision()); // PRECISION\n\n        // ADDED SCALE\n        content = typeString + \" (5,  2)\";\n        tokens = getTokens(content);\n        dType = null;\n        try {\n            dType = parser.parse(tokens);\n        } catch (ParsingException e) {\n            // Expect exception\n        }\n        Assert.assertNull(\"DataType should NOT have been found for Type = \" + content, dType);\n\n    }", "signature": "void shouldParseFLOAT()", "full_signature": "@Test public void shouldParseFLOAT()", "class_method_signature": "DataTypeParserTest.shouldParseFLOAT()", "testcase": true, "constructor": false, "invocations": ["printTest", "getDataTypeString", "getTokens", "parse", "assertNotNull", "assertEquals", "getName", "getTokens", "parse", "assertNotNull", "assertEquals", "getName", "assertEquals", "getPrecision", "getTokens", "parse", "assertNull"]}, "focal_class": {"identifier": "DataTypeParser", "superclass": "", "interfaces": "implements DdlConstants", "fields": [{"original_string": "private static Logger LOGGER = Logger.getLogger(DataTypeParser.class);", "modifier": "private static", "type": "Logger", "declarator": "LOGGER = Logger.getLogger(DataTypeParser.class)", "var_name": "LOGGER"}, {"original_string": "private static List<String[]> basicCharStringTypes = new ArrayList<String[]>();", "modifier": "private static", "type": "List<String[]>", "declarator": "basicCharStringTypes = new ArrayList<String[]>()", "var_name": "basicCharStringTypes"}, {"original_string": "private static List<String[]> basicNationalCharStringTypes = new ArrayList<String[]>();", "modifier": "private static", "type": "List<String[]>", "declarator": "basicNationalCharStringTypes = new ArrayList<String[]>()", "var_name": "basicNationalCharStringTypes"}, {"original_string": "private static List<String[]> basicBitStringTypes = new ArrayList<String[]>();", "modifier": "private static", "type": "List<String[]>", "declarator": "basicBitStringTypes = new ArrayList<String[]>()", "var_name": "basicBitStringTypes"}, {"original_string": "private static List<String[]> basicExactNumericTypes = new ArrayList<String[]>();", "modifier": "private static", "type": "List<String[]>", "declarator": "basicExactNumericTypes = new ArrayList<String[]>()", "var_name": "basicExactNumericTypes"}, {"original_string": "private static List<String[]> basicApproxNumericStringTypes = new ArrayList<String[]>();", "modifier": "private static", "type": "List<String[]>", "declarator": "basicApproxNumericStringTypes = new ArrayList<String[]>()", "var_name": "basicApproxNumericStringTypes"}, {"original_string": "private static List<String[]> basicDateTimeTypes = new ArrayList<String[]>();", "modifier": "private static", "type": "List<String[]>", "declarator": "basicDateTimeTypes = new ArrayList<String[]>()", "var_name": "basicDateTimeTypes"}, {"original_string": "private static List<String[]> basicMiscTypes = new ArrayList<String[]>();", "modifier": "private static", "type": "List<String[]>", "declarator": "basicMiscTypes = new ArrayList<String[]>()", "var_name": "basicMiscTypes"}, {"original_string": "private int defaultLength = 255;", "modifier": "private", "type": "int", "declarator": "defaultLength = 255", "var_name": "defaultLength"}, {"original_string": "private int defaultPrecision = 0;", "modifier": "private", "type": "int", "declarator": "defaultPrecision = 0", "var_name": "defaultPrecision"}, {"original_string": "private int defaultScale = 0;", "modifier": "private", "type": "int", "declarator": "defaultScale = 0", "var_name": "defaultScale"}], "methods": [{"identifier": "DataTypeParser", "parameters": "()", "modifiers": "public", "return": "", "signature": " DataTypeParser()", "full_signature": "public  DataTypeParser()", "class_method_signature": "DataTypeParser.DataTypeParser()", "testcase": false, "constructor": true}, {"identifier": "initialize", "parameters": "()", "modifiers": "private", "return": "void", "signature": "void initialize()", "full_signature": "private void initialize()", "class_method_signature": "DataTypeParser.initialize()", "testcase": false, "constructor": false}, {"identifier": "isDatatype", "parameters": "( DdlTokenStream tokens )", "modifiers": "public final", "return": "boolean", "signature": "boolean isDatatype( DdlTokenStream tokens )", "full_signature": "public final boolean isDatatype( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.isDatatype( DdlTokenStream tokens )", "testcase": false, "constructor": false}, {"identifier": "isDatatype", "parameters": "( DdlTokenStream tokens,\n                                int type )", "modifiers": "private", "return": "boolean", "signature": "boolean isDatatype( DdlTokenStream tokens,\n                                int type )", "full_signature": "private boolean isDatatype( DdlTokenStream tokens,\n                                int type )", "class_method_signature": "DataTypeParser.isDatatype( DdlTokenStream tokens,\n                                int type )", "testcase": false, "constructor": false}, {"identifier": "isCustomDataType", "parameters": "( DdlTokenStream tokens )", "modifiers": "protected", "return": "boolean", "signature": "boolean isCustomDataType( DdlTokenStream tokens )", "full_signature": "protected boolean isCustomDataType( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.isCustomDataType( DdlTokenStream tokens )", "testcase": false, "constructor": false}, {"identifier": "parse", "parameters": "( DdlTokenStream tokens )", "modifiers": "public", "return": "DataType", "signature": "DataType parse( DdlTokenStream tokens )", "full_signature": "public DataType parse( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.parse( DdlTokenStream tokens )", "testcase": false, "constructor": false}, {"identifier": "parseCharStringType", "parameters": "( DdlTokenStream tokens )", "modifiers": "protected", "return": "DataType", "signature": "DataType parseCharStringType( DdlTokenStream tokens )", "full_signature": "protected DataType parseCharStringType( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.parseCharStringType( DdlTokenStream tokens )", "testcase": false, "constructor": false}, {"identifier": "parseNationalCharStringType", "parameters": "( DdlTokenStream tokens )", "modifiers": "protected", "return": "DataType", "signature": "DataType parseNationalCharStringType( DdlTokenStream tokens )", "full_signature": "protected DataType parseNationalCharStringType( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.parseNationalCharStringType( DdlTokenStream tokens )", "testcase": false, "constructor": false}, {"identifier": "parseBitStringType", "parameters": "( DdlTokenStream tokens )", "modifiers": "protected", "return": "DataType", "signature": "DataType parseBitStringType( DdlTokenStream tokens )", "full_signature": "protected DataType parseBitStringType( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.parseBitStringType( DdlTokenStream tokens )", "testcase": false, "constructor": false}, {"identifier": "parseExactNumericType", "parameters": "( DdlTokenStream tokens )", "modifiers": "protected", "return": "DataType", "signature": "DataType parseExactNumericType( DdlTokenStream tokens )", "full_signature": "protected DataType parseExactNumericType( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.parseExactNumericType( DdlTokenStream tokens )", "testcase": false, "constructor": false}, {"identifier": "parseApproxNumericType", "parameters": "( DdlTokenStream tokens )", "modifiers": "protected", "return": "DataType", "signature": "DataType parseApproxNumericType( DdlTokenStream tokens )", "full_signature": "protected DataType parseApproxNumericType( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.parseApproxNumericType( DdlTokenStream tokens )", "testcase": false, "constructor": false}, {"identifier": "parseDateTimeType", "parameters": "( DdlTokenStream tokens )", "modifiers": "protected", "return": "DataType", "signature": "DataType parseDateTimeType( DdlTokenStream tokens )", "full_signature": "protected DataType parseDateTimeType( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.parseDateTimeType( DdlTokenStream tokens )", "testcase": false, "constructor": false}, {"identifier": "parseMiscellaneousType", "parameters": "( DdlTokenStream tokens )", "modifiers": "protected", "return": "DataType", "signature": "DataType parseMiscellaneousType( DdlTokenStream tokens )", "full_signature": "protected DataType parseMiscellaneousType( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.parseMiscellaneousType( DdlTokenStream tokens )", "testcase": false, "constructor": false}, {"identifier": "parseCustomType", "parameters": "( DdlTokenStream tokens )", "modifiers": "protected", "return": "DataType", "signature": "DataType parseCustomType( DdlTokenStream tokens )", "full_signature": "protected DataType parseCustomType( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.parseCustomType( DdlTokenStream tokens )", "testcase": false, "constructor": false}, {"identifier": "getDefaultLength", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getDefaultLength()", "full_signature": "public int getDefaultLength()", "class_method_signature": "DataTypeParser.getDefaultLength()", "testcase": false, "constructor": false}, {"identifier": "setDefaultLength", "parameters": "( int defaultLength )", "modifiers": "public", "return": "void", "signature": "void setDefaultLength( int defaultLength )", "full_signature": "public void setDefaultLength( int defaultLength )", "class_method_signature": "DataTypeParser.setDefaultLength( int defaultLength )", "testcase": false, "constructor": false}, {"identifier": "getDefaultPrecision", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getDefaultPrecision()", "full_signature": "public int getDefaultPrecision()", "class_method_signature": "DataTypeParser.getDefaultPrecision()", "testcase": false, "constructor": false}, {"identifier": "setDefaultPrecision", "parameters": "( int defaultPrecision )", "modifiers": "public", "return": "void", "signature": "void setDefaultPrecision( int defaultPrecision )", "full_signature": "public void setDefaultPrecision( int defaultPrecision )", "class_method_signature": "DataTypeParser.setDefaultPrecision( int defaultPrecision )", "testcase": false, "constructor": false}, {"identifier": "getDefaultScale", "parameters": "()", "modifiers": "public", "return": "int", "signature": "int getDefaultScale()", "full_signature": "public int getDefaultScale()", "class_method_signature": "DataTypeParser.getDefaultScale()", "testcase": false, "constructor": false}, {"identifier": "setDefaultScale", "parameters": "( int defaultScale )", "modifiers": "public", "return": "void", "signature": "void setDefaultScale( int defaultScale )", "full_signature": "public void setDefaultScale( int defaultScale )", "class_method_signature": "DataTypeParser.setDefaultScale( int defaultScale )", "testcase": false, "constructor": false}, {"identifier": "parseLong", "parameters": "( DdlTokenStream tokens,\n                              DataType dataType )", "modifiers": "protected", "return": "long", "signature": "long parseLong( DdlTokenStream tokens,\n                              DataType dataType )", "full_signature": "protected long parseLong( DdlTokenStream tokens,\n                              DataType dataType )", "class_method_signature": "DataTypeParser.parseLong( DdlTokenStream tokens,\n                              DataType dataType )", "testcase": false, "constructor": false}, {"identifier": "parseBracketedLong", "parameters": "( DdlTokenStream tokens,\n                                       DataType dataType )", "modifiers": "protected", "return": "long", "signature": "long parseBracketedLong( DdlTokenStream tokens,\n                                       DataType dataType )", "full_signature": "protected long parseBracketedLong( DdlTokenStream tokens,\n                                       DataType dataType )", "class_method_signature": "DataTypeParser.parseBracketedLong( DdlTokenStream tokens,\n                                       DataType dataType )", "testcase": false, "constructor": false}, {"identifier": "parseLong", "parameters": "( String value )", "modifiers": "protected", "return": "long", "signature": "long parseLong( String value )", "full_signature": "protected long parseLong( String value )", "class_method_signature": "DataTypeParser.parseLong( String value )", "testcase": false, "constructor": false}, {"identifier": "consume", "parameters": "( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix )", "modifiers": "protected", "return": "String", "signature": "String consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix )", "full_signature": "protected String consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix )", "class_method_signature": "DataTypeParser.consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix )", "testcase": false, "constructor": false}, {"identifier": "consume", "parameters": "( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String str )", "modifiers": "protected", "return": "String", "signature": "String consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String str )", "full_signature": "protected String consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String str )", "class_method_signature": "DataTypeParser.consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String str )", "testcase": false, "constructor": false}, {"identifier": "consume", "parameters": "( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String initialStr,\n                              String... additionalStrs )", "modifiers": "protected", "return": "String", "signature": "String consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String initialStr,\n                              String... additionalStrs )", "full_signature": "protected String consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String initialStr,\n                              String... additionalStrs )", "class_method_signature": "DataTypeParser.consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String initialStr,\n                              String... additionalStrs )", "testcase": false, "constructor": false}, {"identifier": "consume", "parameters": "( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String[] additionalStrs )", "modifiers": "protected", "return": "String", "signature": "String consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String[] additionalStrs )", "full_signature": "protected String consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String[] additionalStrs )", "class_method_signature": "DataTypeParser.consume( DdlTokenStream tokens,\n                              DataType dataType,\n                              boolean addSpacePrefix,\n                              String[] additionalStrs )", "testcase": false, "constructor": false}, {"identifier": "canConsume", "parameters": "( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  String initialStr,\n                                  String... additionalStrs )", "modifiers": "protected", "return": "boolean", "signature": "boolean canConsume( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  String initialStr,\n                                  String... additionalStrs )", "full_signature": "protected boolean canConsume( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  String initialStr,\n                                  String... additionalStrs )", "class_method_signature": "DataTypeParser.canConsume( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  String initialStr,\n                                  String... additionalStrs )", "testcase": false, "constructor": false}, {"identifier": "canConsume", "parameters": "( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  String[] additionalStrs )", "modifiers": "protected", "return": "boolean", "signature": "boolean canConsume( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  String[] additionalStrs )", "full_signature": "protected boolean canConsume( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  String[] additionalStrs )", "class_method_signature": "DataTypeParser.canConsume( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  String[] additionalStrs )", "testcase": false, "constructor": false}, {"identifier": "canConsume", "parameters": "( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  int type )", "modifiers": "protected", "return": "boolean", "signature": "boolean canConsume( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  int type )", "full_signature": "protected boolean canConsume( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  int type )", "class_method_signature": "DataTypeParser.canConsume( DdlTokenStream tokens,\n                                  DataType dataType,\n                                  boolean addSpacePrefix,\n                                  int type )", "testcase": false, "constructor": false}, {"identifier": "canConsumeAnyOf", "parameters": "( DdlTokenStream tokens,\n                                       DataType dataType,\n                                       boolean addSpacePrefix,\n                                       String initialStr,\n                                       String... additionalStrs )", "modifiers": "protected", "return": "boolean", "signature": "boolean canConsumeAnyOf( DdlTokenStream tokens,\n                                       DataType dataType,\n                                       boolean addSpacePrefix,\n                                       String initialStr,\n                                       String... additionalStrs )", "full_signature": "protected boolean canConsumeAnyOf( DdlTokenStream tokens,\n                                       DataType dataType,\n                                       boolean addSpacePrefix,\n                                       String initialStr,\n                                       String... additionalStrs )", "class_method_signature": "DataTypeParser.canConsumeAnyOf( DdlTokenStream tokens,\n                                       DataType dataType,\n                                       boolean addSpacePrefix,\n                                       String initialStr,\n                                       String... additionalStrs )", "testcase": false, "constructor": false}, {"identifier": "getStatementTypeName", "parameters": "( String[] stmtPhrase )", "modifiers": "public", "return": "String", "signature": "String getStatementTypeName( String[] stmtPhrase )", "full_signature": "public String getStatementTypeName( String[] stmtPhrase )", "class_method_signature": "DataTypeParser.getStatementTypeName( String[] stmtPhrase )", "testcase": false, "constructor": false}, {"identifier": "setPropertiesOnNode", "parameters": "( AstNode columnNode,\n                                     DataType datatype )", "modifiers": "public", "return": "void", "signature": "void setPropertiesOnNode( AstNode columnNode,\n                                     DataType datatype )", "full_signature": "public void setPropertiesOnNode( AstNode columnNode,\n                                     DataType datatype )", "class_method_signature": "DataTypeParser.setPropertiesOnNode( AstNode columnNode,\n                                     DataType datatype )", "testcase": false, "constructor": false}], "file": "sequencers/modeshape-sequencer-ddl/src/main/java/org/modeshape/sequencer/ddl/datatype/DataTypeParser.java"}, "focal_method": {"identifier": "parse", "parameters": "( DdlTokenStream tokens )", "modifiers": "public", "return": "DataType", "body": "public DataType parse( DdlTokenStream tokens ) throws ParsingException {\n        DataType result = null;\n\n        if (isDatatype(tokens, DataTypes.DTYPE_CODE_CHAR_STRING)) {\n            result = parseCharStringType(tokens);\n        } else if (isDatatype(tokens, DataTypes.DTYPE_CODE_NCHAR_STRING)) {\n            result = parseNationalCharStringType(tokens);\n        } else if (isDatatype(tokens, DataTypes.DTYPE_CODE_BIT_STRING)) {\n            result = parseBitStringType(tokens);\n        } else if (isDatatype(tokens, DataTypes.DTYPE_CODE_EXACT_NUMERIC)) {\n            result = parseExactNumericType(tokens);\n        } else if (isDatatype(tokens, DataTypes.DTYPE_CODE_APROX_NUMERIC)) {\n            result = parseApproxNumericType(tokens);\n        } else if (isDatatype(tokens, DataTypes.DTYPE_CODE_DATE_TIME)) {\n            result = parseDateTimeType(tokens);\n        } else if (isDatatype(tokens, DataTypes.DTYPE_CODE_MISC)) {\n            result = parseMiscellaneousType(tokens);\n        } else {\n            result = parseCustomType(tokens);\n        }\n\n        /*\n         * (FROM http://www.postgresql.org/docs/8.4/static/arrays.html) \n        8.14.1. Declaration of Array Types\n\n        To illustrate the use of array types, we create this table:\n\n        CREATE TABLE sal_emp (\n            name            text,\n            pay_by_quarter  integer[],\n            schedule        text[][]\n        );\n\n        As shown, an array data type is named by appending square brackets ([]) to the data type name of the array elements. \n        The above command will create a table named sal_emp with a column of type text (name), a one-dimensional array of type \n        integer (pay_by_quarter), which represents the employee's salary by quarter, and a two-dimensional array of text (schedule), \n        which represents the employee's weekly schedule.\n\n        The syntax for CREATE TABLE allows the exact size of arrays to be specified, for example:\n\n        CREATE TABLE tictactoe (\n            squares   integer[3][3]\n        );\n\n        However, the current implementation ignores any supplied array size limits, i.e., the behavior is the same as for \n        arrays of unspecified length.\n\n        The current implementation does not enforce the declared number of dimensions either. Arrays of a particular element \n        type are all considered to be of the same type, regardless of size or number of dimensions. So, declaring the array size \n        or number of dimensions in CREATE TABLE is simply documentation; it does not affect run-time behavior.\n\n        An alternative syntax, which conforms to the SQL standard by using the keyword ARRAY, can be used for one-dimensional \n        arrays. pay_by_quarter could have been defined as:\n\n            pay_by_quarter  integer ARRAY[4],\n\n        Or, if no array size is to be specified:\n\n            pay_by_quarter  integer ARRAY,\n        */\n\n        if (tokens.canConsume('[')) {\n            if (!tokens.canConsume(']')) {\n                // assume integer value\n                tokens.consume();\n                tokens.consume(']');\n            }\n\n            if (tokens.canConsume('[')) {\n                if (!tokens.canConsume(']')) {\n                    // assume integer value\n                    tokens.consume();\n                    tokens.consume(']');\n                }\n            }\n        }\n\n        return result;\n    }", "signature": "DataType parse( DdlTokenStream tokens )", "full_signature": "public DataType parse( DdlTokenStream tokens )", "class_method_signature": "DataTypeParser.parse( DdlTokenStream tokens )", "testcase": false, "constructor": false, "invocations": ["isDatatype", "parseCharStringType", "isDatatype", "parseNationalCharStringType", "isDatatype", "parseBitStringType", "isDatatype", "parseExactNumericType", "isDatatype", "parseApproxNumericType", "isDatatype", "parseDateTimeType", "isDatatype", "parseMiscellaneousType", "parseCustomType", "canConsume", "canConsume", "consume", "consume", "canConsume", "canConsume", "consume", "consume"]}, "repository": {"repo_id": 1244027, "url": "https://github.com/ModeShape/modeshape", "language": "Java", "is_fork": false, "fork_count": 213, "stargazer_count": 208, "size": 134266, "license": "licensed"}}