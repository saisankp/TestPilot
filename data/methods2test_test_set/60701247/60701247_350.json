{"test_class": {"identifier": "TreeUtilTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private DefaultTreeModel myModel;", "modifier": "private", "type": "DefaultTreeModel", "declarator": "myModel", "var_name": "myModel"}, {"original_string": "private MyTreeModelListener myModelListener;", "modifier": "private", "type": "MyTreeModelListener", "declarator": "myModelListener", "var_name": "myModelListener"}, {"original_string": "private List<Entry> myNewEntries;", "modifier": "private", "type": "List<Entry>", "declarator": "myNewEntries", "var_name": "myNewEntries"}, {"original_string": "private EntryNode myDirNode;", "modifier": "private", "type": "EntryNode", "declarator": "myDirNode", "var_name": "myDirNode"}], "file": "android/testSrc/com/android/tools/idea/explorer/ui/TreeUtilTest.java"}, "test_case": {"identifier": "testSingleDeleteAtStartOfChildren", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testSingleDeleteAtStartOfChildren() {\n    // Prepare\n    myNewEntries.remove(0);\n\n    // Act\n    TreeUtil.updateChildrenNodes(myModel, myDirNode, myNewEntries, createDefaultOps());\n\n    // Assert\n    assertSameEntries(myDirNode, myNewEntries);\n    assertThat(myModelListener.getStructureChangedCount()).isEqualTo(0);\n    assertThat(myModelListener.getNodesChangedCount()).isEqualTo(myDirNode.getChildCount());\n    assertThat(myModelListener.getNodesInsertedCount()).isEqualTo(0);\n    assertThat(myModelListener.getNodesRemovedCount()).isEqualTo(1);\n  }", "signature": "void testSingleDeleteAtStartOfChildren()", "full_signature": "@Test public void testSingleDeleteAtStartOfChildren()", "class_method_signature": "TreeUtilTest.testSingleDeleteAtStartOfChildren()", "testcase": true, "constructor": false, "invocations": ["remove", "updateChildrenNodes", "createDefaultOps", "assertSameEntries", "isEqualTo", "assertThat", "getStructureChangedCount", "isEqualTo", "assertThat", "getNodesChangedCount", "getChildCount", "isEqualTo", "assertThat", "getNodesInsertedCount", "isEqualTo", "assertThat", "getNodesRemovedCount"]}, "focal_class": {"identifier": "TreeUtil", "superclass": "", "interfaces": "", "fields": [], "methods": [{"identifier": "getChildren", "parameters": "(@NotNull TreeNode node)", "modifiers": "@NotNull public static", "return": "Stream<TreeNode>", "signature": "Stream<TreeNode> getChildren(@NotNull TreeNode node)", "full_signature": "@NotNull public static Stream<TreeNode> getChildren(@NotNull TreeNode node)", "class_method_signature": "TreeUtil.getChildren(@NotNull TreeNode node)", "testcase": false, "constructor": false}, {"identifier": "getCommonPath", "parameters": "(@NotNull List<V> treeNodes)", "modifiers": "@Nullable public static", "return": "TreePath", "signature": "TreePath getCommonPath(@NotNull List<V> treeNodes)", "full_signature": "@Nullable public static TreePath getCommonPath(@NotNull List<V> treeNodes)", "class_method_signature": "TreeUtil.getCommonPath(@NotNull List<V> treeNodes)", "testcase": false, "constructor": false}, {"identifier": "binarySearch", "parameters": "(@NotNull TreeNode parent, @NotNull TreeNode key, @NotNull Comparator<TreeNode> comparator)", "modifiers": "public static", "return": "int", "signature": "int binarySearch(@NotNull TreeNode parent, @NotNull TreeNode key, @NotNull Comparator<TreeNode> comparator)", "full_signature": "public static int binarySearch(@NotNull TreeNode parent, @NotNull TreeNode key, @NotNull Comparator<TreeNode> comparator)", "class_method_signature": "TreeUtil.binarySearch(@NotNull TreeNode parent, @NotNull TreeNode key, @NotNull Comparator<TreeNode> comparator)", "testcase": false, "constructor": false}, {"identifier": "updateChildrenNodes", "parameters": "(@NotNull DefaultTreeModel treeModel,\n                                                                           @NotNull T parentNode,\n                                                                           @NotNull List<U> newEntries,\n                                                                           @NotNull UpdateChildrenOps<T, U> ops)", "modifiers": "@NotNull public static", "return": "List<T>", "signature": "List<T> updateChildrenNodes(@NotNull DefaultTreeModel treeModel,\n                                                                           @NotNull T parentNode,\n                                                                           @NotNull List<U> newEntries,\n                                                                           @NotNull UpdateChildrenOps<T, U> ops)", "full_signature": "@NotNull public static List<T> updateChildrenNodes(@NotNull DefaultTreeModel treeModel,\n                                                                           @NotNull T parentNode,\n                                                                           @NotNull List<U> newEntries,\n                                                                           @NotNull UpdateChildrenOps<T, U> ops)", "class_method_signature": "TreeUtil.updateChildrenNodes(@NotNull DefaultTreeModel treeModel,\n                                                                           @NotNull T parentNode,\n                                                                           @NotNull List<U> newEntries,\n                                                                           @NotNull UpdateChildrenOps<T, U> ops)", "testcase": false, "constructor": false}, {"identifier": "findIndexOfNextEntry", "parameters": "(@NotNull List<U> entries,\n                                                                         int beginIndex,\n                                                                         @NotNull T treeNode,\n                                                                         @NotNull UpdateChildrenOps<T, U> ops)", "modifiers": "private static", "return": "int", "signature": "int findIndexOfNextEntry(@NotNull List<U> entries,\n                                                                         int beginIndex,\n                                                                         @NotNull T treeNode,\n                                                                         @NotNull UpdateChildrenOps<T, U> ops)", "full_signature": "private static int findIndexOfNextEntry(@NotNull List<U> entries,\n                                                                         int beginIndex,\n                                                                         @NotNull T treeNode,\n                                                                         @NotNull UpdateChildrenOps<T, U> ops)", "class_method_signature": "TreeUtil.findIndexOfNextEntry(@NotNull List<U> entries,\n                                                                         int beginIndex,\n                                                                         @NotNull T treeNode,\n                                                                         @NotNull UpdateChildrenOps<T, U> ops)", "testcase": false, "constructor": false}, {"identifier": "removeAllChildren", "parameters": "(@NotNull MutableTreeNode node)", "modifiers": "private static", "return": "void", "signature": "void removeAllChildren(@NotNull MutableTreeNode node)", "full_signature": "private static void removeAllChildren(@NotNull MutableTreeNode node)", "class_method_signature": "TreeUtil.removeAllChildren(@NotNull MutableTreeNode node)", "testcase": false, "constructor": false}, {"identifier": "setAllowsChildren", "parameters": "(@NotNull MutableTreeNode node)", "modifiers": "private static", "return": "void", "signature": "void setAllowsChildren(@NotNull MutableTreeNode node)", "full_signature": "private static void setAllowsChildren(@NotNull MutableTreeNode node)", "class_method_signature": "TreeUtil.setAllowsChildren(@NotNull MutableTreeNode node)", "testcase": false, "constructor": false}], "file": "android/src/com/android/tools/idea/explorer/ui/TreeUtil.java"}, "focal_method": {"identifier": "updateChildrenNodes", "parameters": "(@NotNull DefaultTreeModel treeModel,\n                                                                           @NotNull T parentNode,\n                                                                           @NotNull List<U> newEntries,\n                                                                           @NotNull UpdateChildrenOps<T, U> ops)", "modifiers": "@NotNull public static", "return": "List<T>", "body": "@NotNull\n  public static <T extends MutableTreeNode, U> List<T> updateChildrenNodes(@NotNull DefaultTreeModel treeModel,\n                                                                           @NotNull T parentNode,\n                                                                           @NotNull List<U> newEntries,\n                                                                           @NotNull UpdateChildrenOps<T, U> ops) {\n    if (newEntries.isEmpty()) {\n      // Special case: new list is empty, so we remove all children\n      // This is more efficient that doing incremental updates\n      removeAllChildren(parentNode);\n      treeModel.nodeStructureChanged(parentNode);\n      return new ArrayList<>();\n    }\n    else if (parentNode.getChildCount() == 0) {\n      // Special case: no existing children, so we map all entries and add them\n      // This is more efficient that doing incremental updates\n      List<T> nodes = newEntries.stream().map(ops::mapEntry).collect(Collectors.toList());\n      removeAllChildren(parentNode);\n      setAllowsChildren(parentNode); // Note: Must be done *before* inserting new nodes\n      nodes.forEach(x -> parentNode.insert(x, parentNode.getChildCount()));\n      treeModel.nodeStructureChanged(parentNode);\n      return nodes;\n    }\n    else {\n      // Common case: We go though both list one element at a time, ensuring that the\n      // list of children up to the current index is updated to match the new entries\n      List<T> addedNodes = new ArrayList<>();\n\n      int childIndex = 0;\n      int childCount = parentNode.getChildCount();\n      int newEntryIndex = 0;\n      int newEntryCount = newEntries.size();\n      while (newEntryIndex < newEntries.size() || childIndex < parentNode.getChildCount()) {\n        assert childIndex == newEntryIndex;\n\n        // We reached the end of the existing children, just add a node from the new ones\n        if (childIndex >= childCount) {\n          T newEntryNode = ops.mapEntry(newEntries.get(newEntryIndex));\n          addedNodes.add(newEntryNode);\n          setAllowsChildren(parentNode); // Note: Must be done *before* inserting new nodes\n          treeModel.insertNodeInto(newEntryNode, parentNode, childIndex);\n          newEntryIndex++;\n          childIndex++;\n          childCount++;\n          continue;\n        }\n\n        // We reached the end of the new children, delete existing children from parent\n        if (newEntryIndex >= newEntryCount) {\n          treeModel.removeNodeFromParent((MutableTreeNode)parentNode.getChildAt(childIndex));\n          childCount--;\n          continue;\n        }\n\n        // Both sides have an entry.\n        T childNode = ops.getChildNode(parentNode, childIndex);\n        if (childNode == null) {\n          // Existing tree node is not of type \"T\", remove it.\n          treeModel.removeNodeFromParent((MutableTreeNode)parentNode.getChildAt(childIndex));\n          childCount--;\n          continue;\n        }\n\n        int compareResult = ops.compareNodeWithEntry(childNode, newEntries.get(newEntryIndex));\n        if (compareResult == 0) {\n          ops.updateNode(childNode, newEntries.get(newEntryIndex));\n          treeModel.nodeChanged(childNode);\n          childIndex++;\n          newEntryIndex++;\n          continue;\n        }\n\n        if (compareResult < 0) {\n          treeModel.removeNodeFromParent((MutableTreeNode)parentNode.getChildAt(childIndex));\n          childCount--;\n          continue;\n        }\n\n        // There is at least one node to insert in the existing list of children\n        // For example:\n        //   Existing children: [a, b, e, f]\n        //   Entries          : [a, b, c, d, g, h]\n        //                       0  1  2  3  4  5\n        //   We need to insert 2 new tree nodes [c, d] starting at index 2 in the parent node\n        //   So we compute \"nextIndex\" as equal to \"4\"  (first entry >= current child node),\n        //   and we insert nodes mapped from entries at index 2 to 4 (excluded)\n        assert compareResult > 0;\n        int nextIndex = findIndexOfNextEntry(newEntries, newEntryIndex + 1, childNode, ops);\n        assert nextIndex >= newEntryIndex + 1;\n        assert nextIndex <= newEntries.size();\n        for (; newEntryIndex < nextIndex; newEntryIndex++) {\n          T newChildNode = ops.mapEntry(newEntries.get(newEntryIndex));\n          addedNodes.add(newChildNode);\n          treeModel.insertNodeInto(newChildNode, parentNode, childIndex);\n          childIndex++;\n          childCount++;\n        }\n      }\n      assert childIndex == newEntryIndex;\n      assert childCount == newEntryCount;\n      return addedNodes;\n    }\n  }", "signature": "List<T> updateChildrenNodes(@NotNull DefaultTreeModel treeModel,\n                                                                           @NotNull T parentNode,\n                                                                           @NotNull List<U> newEntries,\n                                                                           @NotNull UpdateChildrenOps<T, U> ops)", "full_signature": "@NotNull public static List<T> updateChildrenNodes(@NotNull DefaultTreeModel treeModel,\n                                                                           @NotNull T parentNode,\n                                                                           @NotNull List<U> newEntries,\n                                                                           @NotNull UpdateChildrenOps<T, U> ops)", "class_method_signature": "TreeUtil.updateChildrenNodes(@NotNull DefaultTreeModel treeModel,\n                                                                           @NotNull T parentNode,\n                                                                           @NotNull List<U> newEntries,\n                                                                           @NotNull UpdateChildrenOps<T, U> ops)", "testcase": false, "constructor": false, "invocations": ["isEmpty", "removeAllChildren", "nodeStructureChanged", "getChildCount", "collect", "map", "stream", "toList", "removeAllChildren", "setAllowsChildren", "forEach", "insert", "getChildCount", "nodeStructureChanged", "getChildCount", "size", "size", "getChildCount", "mapEntry", "get", "add", "setAllowsChildren", "insertNodeInto", "removeNodeFromParent", "getChildAt", "getChildNode", "removeNodeFromParent", "getChildAt", "compareNodeWithEntry", "get", "updateNode", "get", "nodeChanged", "removeNodeFromParent", "getChildAt", "findIndexOfNextEntry", "size", "mapEntry", "get", "add", "insertNodeInto"]}, "repository": {"repo_id": 60701247, "url": "https://github.com/JetBrains/android", "stars": 486, "created": "6/8/2016 1:46:48 PM +00:00", "updates": "2020-01-27T16:45:40+00:00", "fork": "False", "license": "licensed"}}