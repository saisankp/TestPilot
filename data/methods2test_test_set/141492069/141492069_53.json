{"test_class": {"identifier": "TestUDPNotificationHandler", "superclass": "", "interfaces": "", "fields": [{"original_string": "FalseClient fakeClient;", "modifier": "", "type": "FalseClient", "declarator": "fakeClient", "var_name": "fakeClient"}, {"original_string": "String sourceName;", "modifier": "", "type": "String", "declarator": "sourceName", "var_name": "sourceName"}, {"original_string": "DatagramPacket pack;", "modifier": "", "type": "DatagramPacket", "declarator": "pack", "var_name": "pack"}, {"original_string": "UDPNotificationHandler nHandler;", "modifier": "", "type": "UDPNotificationHandler", "declarator": "nHandler", "var_name": "nHandler"}, {"original_string": "Map<String,Object> incoming = new LinkedHashMap<>();", "modifier": "", "type": "Map<String,Object>", "declarator": "incoming = new LinkedHashMap<>()", "var_name": "incoming"}], "file": "udpSource/src/test/java/io/vantiq/extsrc/udp/TestUDPNotificationHandler.java"}, "test_case": {"identifier": "testRegexSpeed", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testRegexSpeed() {\n        incoming.put(\"passAllAddresses\", true);\n        Map<String, Object> regexParser = new LinkedHashMap<>();\n        String pattern = \"<(\\\\d{1,3})>([1-9]\\\\d{0,2}) (?:(-)|(\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(?:\\\\.\"\n                + \"\\\\d{1,6})?(?:Z|[-+]\\\\d{2}:\\\\d{2}))) (-|[!-~]{1,255}) (-|[!-~]{1,48}) (-|[!-~]{1,128}) (-|[!-~]{1,32}\"\n                + \") (?:(-)|((?:\\\\[[!-~&&[^ =\\\\]]]{1,32}(?: [!-~&&[^ =\\\\]]]{1,32}=\\\"(?:[\\\\u0000-\\\\uffff&&[^\\\"\\\\\\\\\\\\]]]|\"\n                + \"(?:\\\\\\\\[\\\\\\\\\\\"\\\\]]))*\\\")*])+))(?: (?:((?!\\\\xef\\\\xbb\\\\xbf).*)|(?:\\\\xef\\\\xbb\\\\xbf([\\\\u0000-\\\\uffff]*))\"\n                + \"))?\";\n        regexParser.put(\"pattern\", pattern);\n        String[] locations = {\"priority\", \"version\", \"noTimestamp\", \"timestamp\", \"hostName\", \"appName\", \"processId\", \n                              \"messageId\", \"noStructuredData\", \"structuredData\", \"standardMessage\", \"utfMessage\"};\n        regexParser.put(\"locations\", Arrays.asList(locations));\n        incoming.put(\"regexParser\", regexParser);\n        String testMessage = \"<0>198 2018-07-23T15:26:20-07:00 remote iApp user branch [name] Here be a message for ya!\";\n        byte[] packetBytes = testMessage.getBytes();\n        DatagramPacket packet= new DatagramPacket(packetBytes, packetBytes.length);\n        \n        assert Pattern.matches(pattern, testMessage);\n        \n        nHandler = new UDPNotificationHandler(incoming, fakeClient);\n        nHandler.handleMessage(packet);\n        int runCount = 100 * 1000;\n        long currentTime = System.currentTimeMillis();\n        \n        for (int i = 0; i < runCount; i ++) {\n            packetBytes = testMessage.getBytes();\n            packetBytes[1] = (byte) ((i & 7) + 48);\n            packet = new DatagramPacket(packetBytes, packetBytes.length);\n            nHandler.handleMessage(packet);\n        }\n        \n        long timeTaken = System.currentTimeMillis() - currentTime;\n        \n        \n        System.out.println(\"Time taken for \" + runCount + \" messages was \" + timeTaken + \" ms\");\n        System.out.println(\"This is \" + ((double)timeTaken) / runCount + \" ms per message and \"\n                    + (int) (1.0 / timeTaken * runCount) + \" thousand messages per second\");\n    }", "signature": "void testRegexSpeed()", "full_signature": "@Test public void testRegexSpeed()", "class_method_signature": "TestUDPNotificationHandler.testRegexSpeed()", "testcase": true, "constructor": false, "invocations": ["put", "put", "put", "asList", "put", "getBytes", "matches", "handleMessage", "currentTimeMillis", "getBytes", "handleMessage", "currentTimeMillis", "println", "println"]}, "focal_class": {"identifier": "UDPNotificationHandler", "superclass": "extends Handler<DatagramPacket>", "interfaces": "", "fields": [{"original_string": "private MapTransformer transformer = null;", "modifier": "private", "type": "MapTransformer", "declarator": "transformer = null", "var_name": "transformer"}, {"original_string": "private ExtensionWebSocketClient client;", "modifier": "private", "type": "ExtensionWebSocketClient", "declarator": "client", "var_name": "client"}, {"original_string": "private String recAddressKey = null;", "modifier": "private", "type": "String", "declarator": "recAddressKey = null", "var_name": "recAddressKey"}, {"original_string": "private String recPortKey = null;", "modifier": "private", "type": "String", "declarator": "recPortKey = null", "var_name": "recPortKey"}, {"original_string": "final private Logger log;", "modifier": "final private", "type": "Logger", "declarator": "log", "var_name": "log"}, {"original_string": "private ObjectMapper mapper = new ObjectMapper();", "modifier": "private", "type": "ObjectMapper", "declarator": "mapper = new ObjectMapper()", "var_name": "mapper"}, {"original_string": "private boolean expectingXml = false;", "modifier": "private", "type": "boolean", "declarator": "expectingXml = false", "var_name": "expectingXml"}, {"original_string": "private String xmlRootLoc = null;", "modifier": "private", "type": "String", "declarator": "xmlRootLoc = null", "var_name": "xmlRootLoc"}, {"original_string": "private boolean expectingCsv = false;", "modifier": "private", "type": "boolean", "declarator": "expectingCsv = false", "var_name": "expectingCsv"}, {"original_string": "private String bytesLocation = null;", "modifier": "private", "type": "String", "declarator": "bytesLocation = null", "var_name": "bytesLocation"}, {"original_string": "private boolean passingPureMap = false;", "modifier": "private", "type": "boolean", "declarator": "passingPureMap = false", "var_name": "passingPureMap"}, {"original_string": "private boolean passingUnspecified = false;", "modifier": "private", "type": "boolean", "declarator": "passingUnspecified = false", "var_name": "passingUnspecified"}, {"original_string": "private Pattern regexPattern = null;", "modifier": "private", "type": "Pattern", "declarator": "regexPattern = null", "var_name": "regexPattern"}, {"original_string": "private String[] patternLocations = null;", "modifier": "private", "type": "String[]", "declarator": "patternLocations = null", "var_name": "patternLocations"}], "methods": [{"identifier": "UDPNotificationHandler", "parameters": "(Map incoming, ExtensionWebSocketClient client)", "modifiers": "public", "return": "", "signature": " UDPNotificationHandler(Map incoming, ExtensionWebSocketClient client)", "full_signature": "public  UDPNotificationHandler(Map incoming, ExtensionWebSocketClient client)", "class_method_signature": "UDPNotificationHandler.UDPNotificationHandler(Map incoming, ExtensionWebSocketClient client)", "testcase": false, "constructor": true}, {"identifier": "hasIncomingTransformations", "parameters": "(Map incoming)", "modifiers": "private static", "return": "boolean", "signature": "boolean hasIncomingTransformations(Map incoming)", "full_signature": "private static boolean hasIncomingTransformations(Map incoming)", "class_method_signature": "UDPNotificationHandler.hasIncomingTransformations(Map incoming)", "testcase": false, "constructor": false}, {"identifier": "handleMessage", "parameters": "(DatagramPacket packet)", "modifiers": "@Override public", "return": "void", "signature": "void handleMessage(DatagramPacket packet)", "full_signature": "@Override public void handleMessage(DatagramPacket packet)", "class_method_signature": "UDPNotificationHandler.handleMessage(DatagramPacket packet)", "testcase": false, "constructor": false}, {"identifier": "getRegexResults", "parameters": "(String str)", "modifiers": "private", "return": "Map<String,Object>", "signature": "Map<String,Object> getRegexResults(String str)", "full_signature": "private Map<String,Object> getRegexResults(String str)", "class_method_signature": "UDPNotificationHandler.getRegexResults(String str)", "testcase": false, "constructor": false}], "file": "udpSource/src/main/java/io/vantiq/extsrc/udp/UDPNotificationHandler.java"}, "focal_method": {"identifier": "handleMessage", "parameters": "(DatagramPacket packet)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void handleMessage(DatagramPacket packet) {\n        Map receivedMsg = null;\n        Map<String,Object> sendMsg = new LinkedHashMap<>();\n        if (bytesLocation != null || regexPattern != null) {\n            // Can't be parsed with Object mapper \n        }\n        else if (expectingCsv) {\n            try  {\n                List<Object> csv = mapper.readerFor(List.class).with(CsvSchema.emptySchema().withHeader())\n                        .readValue(packet.getData());\n                client.sendNotification(csv);\n            }\n            catch (Exception e){\n                log.warn(\"Failed to interpret UDP message as CSV.\", e);\n            }\n            return;\n        }\n        else{\n            try {\n                receivedMsg = mapper.readValue(packet.getData(), Map.class);\n            } \n            catch (Exception e) {\n                if (expectingXml) {\n                    log.warn(\"Failed to interpret UDP message as a XML object.\", e);\n                }\n                else {  // expecting JSON\n                    log.warn(\"Failed to interpret UDP message as a JSON object.\", e);\n                }\n                return;\n            }\n        }\n        \n\n        // Transforms the message as requested by the Configuration document\n        if (regexPattern != null) {\n            \n            // Create a String from the byte data, but remove unused bytes\n            String recString = new String(packet.getData());\n            int endIndex = recString.indexOf(\"\\0\");\n            if (endIndex == -1) {endIndex = packet.getData().length;}\n            recString = new String(packet.getData(), 0, endIndex, Charset.forName(\"UTF-8\"));\n            \n            sendMsg = getRegexResults(recString);\n        }\n        else if (bytesLocation != null) {\n            // Create a String from the byte data, but remove unused bytes\n            String recString = new String(packet.getData());\n            int endIndex = recString.indexOf(\"\\0\");\n            if (endIndex == -1) {endIndex = packet.getData().length;}\n            recString = new String(packet.getData(), 0, endIndex, Charset.forName(\"UTF-8\"));\n            \n            MapTransformer.createTransformVal(sendMsg, bytesLocation, recString);\n        }\n        else if (passingPureMap) {\n            sendMsg = receivedMsg;\n        }\n        else if (passingUnspecified) {\n            // Set the messages to the same map so any untransformed values stay, and tell it to destroy any values removed\n            sendMsg = receivedMsg;\n            if (this.transformer != null) {\n                this.transformer.transform(receivedMsg, sendMsg, true);\n            }\n        }\n        else if (transformer == null) {\n            // This means that no transform was specified and neither were any pass___ parameters in which case\n            // the design decision is to send an empty Map, so the source is notified that a UDP message was received\n            sendMsg = new LinkedHashMap<>();\n        }\n        else {\n            this.transformer.transform(receivedMsg, sendMsg, false);\n        }\n\n        if (expectingXml && xmlRootLoc != null) {\n            try {\n                FromXmlParser p = (FromXmlParser) mapper.getFactory().createParser(packet.getData());\n                MapTransformer.createTransformVal(sendMsg, xmlRootLoc, p.getStaxReader().getLocalName());\n            }\n            catch (Exception e) {\n                log.error(\"Failed to interpret name of root\", e);\n            }\n        }\n        \n        // Add the address and port that the packet came from if the config demands it\n        if (recAddressKey != null) {\n            MapTransformer.createTransformVal(sendMsg, recAddressKey, packet.getAddress().getHostAddress());\n        }\n        if (recPortKey != null) {\n            MapTransformer.createTransformVal(sendMsg, recPortKey, packet.getPort());\n        }\n\n        client.sendNotification(sendMsg);\n    }", "signature": "void handleMessage(DatagramPacket packet)", "full_signature": "@Override public void handleMessage(DatagramPacket packet)", "class_method_signature": "UDPNotificationHandler.handleMessage(DatagramPacket packet)", "testcase": false, "constructor": false, "invocations": ["readValue", "with", "readerFor", "withHeader", "emptySchema", "getData", "sendNotification", "warn", "readValue", "getData", "warn", "warn", "getData", "indexOf", "getData", "getData", "forName", "getRegexResults", "getData", "indexOf", "getData", "getData", "forName", "createTransformVal", "transform", "transform", "createParser", "getFactory", "getData", "createTransformVal", "getLocalName", "getStaxReader", "error", "createTransformVal", "getHostAddress", "getAddress", "createTransformVal", "getPort", "sendNotification"]}, "repository": {"repo_id": 141492069, "url": "https://github.com/Vantiq/vantiq-extension-sources", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 9, "size": 16261, "license": "licensed"}}