{"test_class": {"identifier": "PolygonExtractionProcessTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final double TOL = 1.0e-6;", "modifier": "private static final", "type": "double", "declarator": "TOL = 1.0e-6", "var_name": "TOL"}, {"original_string": "private static final GridCoverageFactory covFactory = CoverageFactoryFinder.getGridCoverageFactory(null);", "modifier": "private static final", "type": "GridCoverageFactory", "declarator": "covFactory = CoverageFactoryFinder.getGridCoverageFactory(null)", "var_name": "covFactory"}, {"original_string": "private PolygonExtractionProcess process;", "modifier": "private", "type": "PolygonExtractionProcess", "declarator": "process", "var_name": "process"}], "file": "modules/unsupported/process-raster/src/test/java/org/geotools/process/raster/PolygonExtractionProcessTest.java"}, "test_case": {"identifier": "extractPolygonsFromViewshedRaster", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void extractPolygonsFromViewshedRaster() throws Exception {\n        final double ROUND_OFF_TOLERANCE = 1.0e-4D;\n\n        URL url = getClass().getResource(\"viewshed.tif\");\n        BufferedImage img = ImageIO.read(url);\n\n        Rectangle bounds = new Rectangle(img.getMinX(), img.getMinY(), img.getWidth(), img.getHeight());\n        ReferencedEnvelope env = new ReferencedEnvelope(bounds, null);\n\n        GridCoverage2D cov = covFactory.create(\"coverage\", img, env);\n\n        final int OUTSIDE = -1;\n        List<Number> noDataValues = new ArrayList<Number>();\n        noDataValues.add(OUTSIDE);\n        SimpleFeatureCollection fc = process.execute(\n                cov, 0, Boolean.TRUE, null, noDataValues, null, null);\n\n        // validate geometries and sum areas\n        SimpleFeatureIterator iter = fc.features();\n        Map<Integer, Double> areas = new HashMap<Integer, Double>();\n        try {\n            while (iter.hasNext()) {\n                SimpleFeature feature = iter.next();\n                Geometry geom = (Geometry) feature.getDefaultGeometry();\n                assertTrue(geom.isValid());\n\n                int value = ((Number) feature.getAttribute(\"value\")).intValue();\n                if (value != OUTSIDE) {\n                    Double sum = areas.get(value);\n                    if (sum == null) {\n                        sum = 0.0d;\n                    }\n                    sum += geom.getArea();\n                    areas.put(value, sum);\n                }\n            }\n        } finally {\n            iter.close();\n        }\n        \n        // compare summed areas to image data\n        Map<Integer, Double> imgAreas = new HashMap<Integer, Double>();\n        Raster tile = img.getTile(0, 0);\n        for (int y = img.getMinY(), ny = 0; ny < img.getHeight(); y++, ny++) {\n            for (int x = img.getMinX(), nx = 0; nx < img.getWidth(); x++, nx++) {\n                double gridvalue = tile.getSampleDouble(x, y, 0);\n                if (Math.abs(gridvalue - OUTSIDE) < TOL) {\n                    Double sum = areas.get((int)gridvalue);\n                    if (sum == null) {\n                        sum = 1.0D;\n                    } else {\n                        sum += 1.0D;\n                    }\n                    areas.put((int)gridvalue, sum);\n                }\n            }\n        }\n\n        for (Integer i : imgAreas.keySet()) {\n            double ratio = areas.get(i) / imgAreas.get(i);\n            assertTrue(Math.abs(1.0D - ratio) < ROUND_OFF_TOLERANCE);\n        }\n    }", "signature": "void extractPolygonsFromViewshedRaster()", "full_signature": "@Test public void extractPolygonsFromViewshedRaster()", "class_method_signature": "PolygonExtractionProcessTest.extractPolygonsFromViewshedRaster()", "testcase": true, "constructor": false, "invocations": ["getResource", "getClass", "read", "getMinX", "getMinY", "getWidth", "getHeight", "create", "add", "execute", "features", "hasNext", "next", "getDefaultGeometry", "assertTrue", "isValid", "intValue", "getAttribute", "get", "getArea", "put", "close", "getTile", "getMinY", "getHeight", "getMinX", "getWidth", "getSampleDouble", "abs", "get", "put", "keySet", "get", "get", "assertTrue", "abs"]}, "focal_class": {"identifier": "PolygonExtractionProcess", "superclass": "", "interfaces": "implements RasterProcess", "fields": [], "methods": [{"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "modifiers": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public", "return": "SimpleFeatureCollection", "signature": "SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "full_signature": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "class_method_signature": "PolygonExtractionProcess.execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "testcase": false, "constructor": false}], "file": "modules/unsupported/process-raster/src/main/java/org/geotools/process/raster/PolygonExtractionProcess.java"}, "focal_method": {"identifier": "execute", "parameters": "(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "modifiers": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public", "return": "SimpleFeatureCollection", "body": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\")\n    public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)\n            throws ProcessException {\n\n\n        //\n        // initial checks\n        //\n        if (coverage == null) {\n            throw new ProcessException(\"Invalid input, source grid coverage should be not null\");\n        }\n\n        if (band == null) {\n            band = 0;\n        } else if (band < 0 || band >= coverage.getNumSampleDimensions()) {\n            throw new ProcessException(\"Invalid input, invalid band number:\" + band);\n        }\n\n        // do we have classification ranges?\n        boolean hasClassificationRanges = classificationRanges != null && classificationRanges.size() > 0;\n\n        // apply the classification by setting 0 as the default value and using 1, ..., numClasses for the other classes.\n        // we use 0 also as the noData for the resulting coverage.\n        if (hasClassificationRanges) {\n\n            final RangeLookupProcess lookup = new RangeLookupProcess();\n            coverage = lookup.execute(\n                    coverage,\n                    band,\n                    classificationRanges,\n                    progressListener);\n        }\n\n        // Use noDataValues to set the \"outsideValues\" parameter of the Vectorize\n        // operation unless classificationRanges are in use, in which case the\n        // noDataValues arg is ignored.\n        List<Number> outsideValues = new ArrayList<Number>();\n        if (noDataValues != null && !hasClassificationRanges) {\n            outsideValues.addAll(noDataValues);\n        } else {\n            outsideValues.add(0);\n        }\n        \n        //\n        // GRID TO WORLD preparation\n        //\n        final AffineTransform mt2D = (AffineTransform) coverage.getGridGeometry().getGridToCRS2D(PixelOrientation.UPPER_LEFT);\n\n        // get the rendered image\n        final RenderedImage raster = coverage.getRenderedImage();\n\n        // perform jai operation\n        ParameterBlockJAI pb = new ParameterBlockJAI(\"Vectorize\");\n        pb.setSource(\"source0\", raster);\n\n        if (roi != null) {\n            pb.setParameter(\"roi\", CoverageUtilities.prepareROI(roi, mt2D));\n        }\n        pb.setParameter(\"band\", band);\n        pb.setParameter(\"outsideValues\", outsideValues);\n        if (insideEdges != null) {\n            pb.setParameter(\"insideEdges\", insideEdges);\n        }\n        // pb.setParameter(\"removeCollinear\", false);  \n\n        final RenderedOp dest = JAI.create(\"Vectorize\", pb);\n        @SuppressWarnings(\"unchecked\")\n        final Collection<Polygon> prop = (Collection<Polygon>) dest.getProperty(VectorizeDescriptor.VECTOR_PROPERTY_NAME);\n\n        // wrap as a feature collection and return\n        final SimpleFeatureType featureType = CoverageUtilities.createFeatureType(coverage, Polygon.class);\n        final SimpleFeatureBuilder builder = new SimpleFeatureBuilder(featureType);\n        int i = 0;\n        final ListFeatureCollection featureCollection = new ListFeatureCollection(featureType);\n        final AffineTransformation jtsTransformation = new AffineTransformation(\n                mt2D.getScaleX(),\n                mt2D.getShearX(),\n                mt2D.getTranslateX(),\n                mt2D.getShearY(),\n                mt2D.getScaleY(),\n                mt2D.getTranslateY());\n        for (Polygon polygon : prop) {\n            // get value\n            Double value = (Double) polygon.getUserData();\n            polygon.setUserData(null);\n            // filter coordinates in place\n            polygon.apply(jtsTransformation);\n\n            // create feature and add to list\n            builder.set(\"the_geom\", polygon);\n            builder.set(\"value\", value);\n\n            featureCollection.add(builder.buildFeature(String.valueOf(i++)));\n\n        }\n\n        //return value\n        return featureCollection;\n    }", "signature": "SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "full_signature": "@DescribeResult(name = \"result\", description = \"The extracted polygon features\") public SimpleFeatureCollection execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "class_method_signature": "PolygonExtractionProcess.execute(\n            @DescribeParameter(name = \"data\", description = \"Source raster\") GridCoverage2D coverage,\n            @DescribeParameter(name = \"band\", description = \"Source band to use (default = 0)\", min = 0, defaultValue = \"0\") Integer band,\n            @DescribeParameter(name = \"insideEdges\", description = \"Indicates whether to vectorize boundaries between adjacent regions with non-outside values\", min = 0) Boolean insideEdges,\n            @DescribeParameter(name = \"roi\", description = \"Geometry delineating the region of interest (in raster coordinate system)\", min = 0) Geometry roi,\n            @DescribeParameter(name = \"nodata\", description = \"Value to treat as NODATA (default is 0)\",\n            collectionType = Number.class, min = 0) Collection<Number> noDataValues,\n            @DescribeParameter(name = \"ranges\", description = \"Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.\", \n            collectionType = Range.class, min = 0) List<Range> classificationRanges,\n            ProgressListener progressListener)", "testcase": false, "constructor": false, "invocations": ["getNumSampleDimensions", "size", "execute", "addAll", "add", "getGridToCRS2D", "getGridGeometry", "getRenderedImage", "setSource", "setParameter", "prepareROI", "setParameter", "setParameter", "setParameter", "create", "getProperty", "createFeatureType", "getScaleX", "getShearX", "getTranslateX", "getShearY", "getScaleY", "getTranslateY", "getUserData", "setUserData", "apply", "set", "set", "add", "buildFeature", "valueOf"]}, "repository": {"repo_id": 40735368, "url": "https://github.com/FUNCATE/geotools-android", "language": "Java", "is_fork": false, "fork_count": 2, "stargazer_count": 8, "size": 63952, "license": "licensed"}}