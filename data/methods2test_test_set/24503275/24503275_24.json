{"test_class": {"identifier": "RLPTest", "superclass": "", "interfaces": "", "fields": [], "file": "ethereumj-core/src/test/java/org/ethereum/util/RLPTest.java"}, "test_case": {"identifier": "testRlpDecode", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n\tpublic void testRlpDecode() {\n\t\tint pos = 0;\n\t\tString emptyString;\n\t\tbyte[] decodedData;\n\t\tObject[] decodedList;\n\n        emptyString =  (String)RLP.decode(Hex.decode(result01), pos).getDecoded();\n\t\tassertEquals(\"\", emptyString);\n\n        emptyString =  (String)RLP.decode(Hex.decode(result02), pos).getDecoded();\n\t\tassertEquals(test02, emptyString);\n\n\t\tdecodedData = (byte[]) RLP.decode(Hex.decode(result03), pos).getDecoded();\n\t\tassertEquals(test03, bytesToAscii(decodedData));\n\t\t\n\t\tdecodedData = (byte[]) RLP.decode(Hex.decode(result04), pos).getDecoded();\n\t\tassertEquals(test04, bytesToAscii(decodedData));\n\t\t\n\t\tdecodedData = (byte[]) RLP.decode(Hex.decode(result05), pos).getDecoded();\n\t\tassertEquals(test05, bytesToAscii(decodedData));\n\t\t\n\t\tdecodedList = (Object[]) RLP.decode(Hex.decode(result06), pos).getDecoded();\n\t\tassertEquals(test06[0], bytesToAscii((byte[]) decodedList[0]));\n\t\tassertEquals(test06[1], bytesToAscii((byte[]) decodedList[1]));\n\t\t\n\t\tdecodedList = (Object[]) RLP.decode(Hex.decode(result07), pos).getDecoded();\n\t\tassertEquals(test07[0], bytesToAscii((byte[]) decodedList[0]));\n\t\tassertEquals(test07[1], bytesToAscii((byte[]) decodedList[1]));\n\t\tassertEquals(test07[2], bytesToAscii((byte[]) decodedList[2]));\n\t\t\n\t\t// 1\n\t\tdecodedData = (byte[]) RLP.decode(Hex.decode(result08), pos).getDecoded();\n\t\tassertEquals(test08, byteArrayToInt(decodedData));\n\n\t\t// 10\n\t\tdecodedData = (byte[]) RLP.decode(Hex.decode(result09), pos).getDecoded();\n\t\tassertEquals(test09, byteArrayToInt(decodedData));\n\n\t\t// 100\n\t\tdecodedData = (byte[]) RLP.decode(Hex.decode(result10), pos).getDecoded();\n\t\tassertEquals(test10, byteArrayToInt(decodedData));\n\n\t\t// 1000 \n\t\tdecodedData = (byte[]) RLP.decode(Hex.decode(result11), pos).getDecoded();\n\t\tassertEquals(test11, byteArrayToInt(decodedData));\n\t\t\n\t\tdecodedData = (byte[]) RLP.decode(Hex.decode(result12), pos).getDecoded();\n\t\tassertTrue(test12.compareTo(new BigInteger(1, decodedData)) == 0);\n\t\t\n\t\tdecodedData = (byte[]) RLP.decode(Hex.decode(result13), pos).getDecoded();\n\t\tassertTrue(test13.compareTo(new BigInteger(1, decodedData)) == 0);\n\t\t\n\t\t// Need to test with different expected value, because decoding doesn't recognize types\n\t\tObject testObject1 = RLP.decode(Hex.decode(result14), pos).getDecoded();\n\t\tassertTrue(DeepEquals.deepEquals(expected14, testObject1));\n\t\t\n\t\tObject testObject2 = RLP.decode(Hex.decode(result15), pos).getDecoded();\n\t\tassertTrue(DeepEquals.deepEquals(test15, testObject2));\n\t\t\n\t\t// Need to test with different expected value, because decoding doesn't recognize types\n\t\tObject testObject3 = RLP.decode(Hex.decode(result16), pos).getDecoded();\n\t\tassertTrue(DeepEquals.deepEquals(expected16, testObject3));\n\t}", "signature": "void testRlpDecode()", "full_signature": "@Test public void testRlpDecode()", "class_method_signature": "RLPTest.testRlpDecode()", "testcase": true, "constructor": false, "invocations": ["getDecoded", "decode", "decode", "assertEquals", "getDecoded", "decode", "decode", "assertEquals", "getDecoded", "decode", "decode", "assertEquals", "bytesToAscii", "getDecoded", "decode", "decode", "assertEquals", "bytesToAscii", "getDecoded", "decode", "decode", "assertEquals", "bytesToAscii", "getDecoded", "decode", "decode", "assertEquals", "bytesToAscii", "assertEquals", "bytesToAscii", "getDecoded", "decode", "decode", "assertEquals", "bytesToAscii", "assertEquals", "bytesToAscii", "assertEquals", "bytesToAscii", "getDecoded", "decode", "decode", "assertEquals", "byteArrayToInt", "getDecoded", "decode", "decode", "assertEquals", "byteArrayToInt", "getDecoded", "decode", "decode", "assertEquals", "byteArrayToInt", "getDecoded", "decode", "decode", "assertEquals", "byteArrayToInt", "getDecoded", "decode", "decode", "assertTrue", "compareTo", "getDecoded", "decode", "decode", "assertTrue", "compareTo", "getDecoded", "decode", "decode", "assertTrue", "deepEquals", "getDecoded", "decode", "decode", "assertTrue", "deepEquals", "getDecoded", "decode", "decode", "assertTrue", "deepEquals"]}, "focal_class": {"identifier": "RLP", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static double MAX_ITEM_LENGTH = Math.pow(256, 8);", "modifier": "private static", "type": "double", "declarator": "MAX_ITEM_LENGTH = Math.pow(256, 8)", "var_name": "MAX_ITEM_LENGTH"}, {"original_string": "private static int SIZE_THRESHOLD = 56;", "modifier": "private static", "type": "int", "declarator": "SIZE_THRESHOLD = 56", "var_name": "SIZE_THRESHOLD"}, {"original_string": "private static int OFFSET_SHORT_ITEM = 0x80;", "modifier": "private static", "type": "int", "declarator": "OFFSET_SHORT_ITEM = 0x80", "var_name": "OFFSET_SHORT_ITEM"}, {"original_string": "private static int OFFSET_LONG_ITEM = 0xb7;", "modifier": "private static", "type": "int", "declarator": "OFFSET_LONG_ITEM = 0xb7", "var_name": "OFFSET_LONG_ITEM"}, {"original_string": "private static int OFFSET_SHORT_LIST = 0xc0;", "modifier": "private static", "type": "int", "declarator": "OFFSET_SHORT_LIST = 0xc0", "var_name": "OFFSET_SHORT_LIST"}, {"original_string": "private static int OFFSET_LONG_LIST = 0xf7;", "modifier": "private static", "type": "int", "declarator": "OFFSET_LONG_LIST = 0xf7", "var_name": "OFFSET_LONG_LIST"}], "methods": [{"identifier": "decodeOneByteItem", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "byte", "signature": "byte decodeOneByteItem(byte[] data, int index)", "full_signature": "private static byte decodeOneByteItem(byte[] data, int index)", "class_method_signature": "RLP.decodeOneByteItem(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeInt", "parameters": "(byte[] data, int index)", "modifiers": "public static", "return": "int", "signature": "int decodeInt(byte[] data, int index)", "full_signature": "public static int decodeInt(byte[] data, int index)", "class_method_signature": "RLP.decodeInt(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeShort", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "short", "signature": "short decodeShort(byte[] data, int index)", "full_signature": "private static short decodeShort(byte[] data, int index)", "class_method_signature": "RLP.decodeShort(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeLong", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "long", "signature": "long decodeLong(byte[] data, int index)", "full_signature": "private static long decodeLong(byte[] data, int index)", "class_method_signature": "RLP.decodeLong(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeStringItem", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "String", "signature": "String decodeStringItem(byte[] data, int index)", "full_signature": "private static String decodeStringItem(byte[] data, int index)", "class_method_signature": "RLP.decodeStringItem(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeItemBytes", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] decodeItemBytes(byte[] data, int index)", "full_signature": "private static byte[] decodeItemBytes(byte[] data, int index)", "class_method_signature": "RLP.decodeItemBytes(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeBigInteger", "parameters": "(byte[] data, int index)", "modifiers": "public static", "return": "BigInteger", "signature": "BigInteger decodeBigInteger(byte[] data, int index)", "full_signature": "public static BigInteger decodeBigInteger(byte[] data, int index)", "class_method_signature": "RLP.decodeBigInteger(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeByteArray", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] decodeByteArray(byte[] data, int index)", "full_signature": "private static byte[] decodeByteArray(byte[] data, int index)", "class_method_signature": "RLP.decodeByteArray(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "nextItemLength", "parameters": "(byte[] data, int index)", "modifiers": "private static", "return": "int", "signature": "int nextItemLength(byte[] data, int index)", "full_signature": "private static int nextItemLength(byte[] data, int index)", "class_method_signature": "RLP.nextItemLength(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "decodeIP4Bytes", "parameters": "(byte[] data, int index)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] decodeIP4Bytes(byte[] data, int index)", "full_signature": "public static byte[] decodeIP4Bytes(byte[] data, int index)", "class_method_signature": "RLP.decodeIP4Bytes(byte[] data, int index)", "testcase": false, "constructor": false}, {"identifier": "getFirstListElement", "parameters": "(byte[] payload, int pos)", "modifiers": "public static", "return": "int", "signature": "int getFirstListElement(byte[] payload, int pos)", "full_signature": "public static int getFirstListElement(byte[] payload, int pos)", "class_method_signature": "RLP.getFirstListElement(byte[] payload, int pos)", "testcase": false, "constructor": false}, {"identifier": "getNextElementIndex", "parameters": "(byte[] payload, int pos)", "modifiers": "public static", "return": "int", "signature": "int getNextElementIndex(byte[] payload, int pos)", "full_signature": "public static int getNextElementIndex(byte[] payload, int pos)", "class_method_signature": "RLP.getNextElementIndex(byte[] payload, int pos)", "testcase": false, "constructor": false}, {"identifier": "fullTraverse", "parameters": "(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "modifiers": "public static", "return": "void", "signature": "void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "full_signature": "public static void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "class_method_signature": "RLP.fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, Queue<Integer> index)", "testcase": false, "constructor": false}, {"identifier": "calcLength", "parameters": "(int lengthOfLength, byte[] msgData, int pos)", "modifiers": "private static", "return": "int", "signature": "int calcLength(int lengthOfLength, byte[] msgData, int pos)", "full_signature": "private static int calcLength(int lengthOfLength, byte[] msgData, int pos)", "class_method_signature": "RLP.calcLength(int lengthOfLength, byte[] msgData, int pos)", "testcase": false, "constructor": false}, {"identifier": "calcLengthRaw", "parameters": "(int lengthOfLength, byte[] msgData, int index)", "modifiers": "private static", "return": "int", "signature": "int calcLengthRaw(int lengthOfLength, byte[] msgData, int index)", "full_signature": "private static int calcLengthRaw(int lengthOfLength, byte[] msgData, int index)", "class_method_signature": "RLP.calcLengthRaw(int lengthOfLength, byte[] msgData, int index)", "testcase": false, "constructor": false}, {"identifier": "getCommandCode", "parameters": "(byte[] data)", "modifiers": "public static", "return": "byte", "signature": "byte getCommandCode(byte[] data)", "full_signature": "public static byte getCommandCode(byte[] data)", "class_method_signature": "RLP.getCommandCode(byte[] data)", "testcase": false, "constructor": false}, {"identifier": "decode2", "parameters": "(byte[] msgData)", "modifiers": "public static", "return": "RLPList", "signature": "RLPList decode2(byte[] msgData)", "full_signature": "public static RLPList decode2(byte[] msgData)", "class_method_signature": "RLP.decode2(byte[] msgData)", "testcase": false, "constructor": false}, {"identifier": "fullTraverse", "parameters": "(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "modifiers": "private static", "return": "void", "signature": "void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "full_signature": "private static void fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "class_method_signature": "RLP.fullTraverse(byte[] msgData, int level, int startPos,\n\t\t\tint endPos, int levelToIndex, RLPList rlpList)", "testcase": false, "constructor": false}, {"identifier": "decode", "parameters": "(byte[] data, int pos)", "modifiers": "public static", "return": "DecodeResult", "signature": "DecodeResult decode(byte[] data, int pos)", "full_signature": "public static DecodeResult decode(byte[] data, int pos)", "class_method_signature": "RLP.decode(byte[] data, int pos)", "testcase": false, "constructor": false}, {"identifier": "decodeList", "parameters": "(byte[] data, int pos, int prevPos, int len)", "modifiers": "private static", "return": "DecodeResult", "signature": "DecodeResult decodeList(byte[] data, int pos, int prevPos, int len)", "full_signature": "private static DecodeResult decodeList(byte[] data, int pos, int prevPos, int len)", "class_method_signature": "RLP.decodeList(byte[] data, int pos, int prevPos, int len)", "testcase": false, "constructor": false}, {"identifier": "encode", "parameters": "(Object input)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encode(Object input)", "full_signature": "public static byte[] encode(Object input)", "class_method_signature": "RLP.encode(Object input)", "testcase": false, "constructor": false}, {"identifier": "encodeLength", "parameters": "(int length, int offset)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeLength(int length, int offset)", "full_signature": "public static byte[] encodeLength(int length, int offset)", "class_method_signature": "RLP.encodeLength(int length, int offset)", "testcase": false, "constructor": false}, {"identifier": "encodeByte", "parameters": "(byte singleByte)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeByte(byte singleByte)", "full_signature": "public static byte[] encodeByte(byte singleByte)", "class_method_signature": "RLP.encodeByte(byte singleByte)", "testcase": false, "constructor": false}, {"identifier": "encodeShort", "parameters": "(short singleShort)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeShort(short singleShort)", "full_signature": "public static byte[] encodeShort(short singleShort)", "class_method_signature": "RLP.encodeShort(short singleShort)", "testcase": false, "constructor": false}, {"identifier": "encodeInt", "parameters": "(int singleInt)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeInt(int singleInt)", "full_signature": "public static byte[] encodeInt(int singleInt)", "class_method_signature": "RLP.encodeInt(int singleInt)", "testcase": false, "constructor": false}, {"identifier": "encodeString", "parameters": "(String srcString)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeString(String srcString)", "full_signature": "public static byte[] encodeString(String srcString)", "class_method_signature": "RLP.encodeString(String srcString)", "testcase": false, "constructor": false}, {"identifier": "encodeBigInteger", "parameters": "(BigInteger srcBigInteger)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeBigInteger(BigInteger srcBigInteger)", "full_signature": "public static byte[] encodeBigInteger(BigInteger srcBigInteger)", "class_method_signature": "RLP.encodeBigInteger(BigInteger srcBigInteger)", "testcase": false, "constructor": false}, {"identifier": "encodeElement", "parameters": "(byte[] srcData)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeElement(byte[] srcData)", "full_signature": "public static byte[] encodeElement(byte[] srcData)", "class_method_signature": "RLP.encodeElement(byte[] srcData)", "testcase": false, "constructor": false}, {"identifier": "encodeList", "parameters": "(byte[]... elements)", "modifiers": "public static", "return": "byte[]", "signature": "byte[] encodeList(byte[]... elements)", "full_signature": "public static byte[] encodeList(byte[]... elements)", "class_method_signature": "RLP.encodeList(byte[]... elements)", "testcase": false, "constructor": false}, {"identifier": "toBytes", "parameters": "(Object input)", "modifiers": "private static", "return": "byte[]", "signature": "byte[] toBytes(Object input)", "full_signature": "private static byte[] toBytes(Object input)", "class_method_signature": "RLP.toBytes(Object input)", "testcase": false, "constructor": false}], "file": "ethereumj-core/src/main/java/org/ethereum/util/RLP.java"}, "focal_method": {"identifier": "decode", "parameters": "(byte[] data, int pos)", "modifiers": "public static", "return": "DecodeResult", "body": "public static DecodeResult decode(byte[] data, int pos) {\n\t\tif (data == null || data.length < 1) {\n\t\t\treturn null;\n\t\t}\n\t\tint prefix = data[pos] & 0xFF;\n\t\tif (prefix == OFFSET_SHORT_ITEM) {\n\t\t\treturn new DecodeResult(pos+1, \"\"); // means no length or 0\n\t\t} else if (prefix < OFFSET_SHORT_ITEM) {\n\t\t\treturn new DecodeResult(pos+1, new byte[] { data[pos] }); // byte is its own RLP encoding\n\t\t} else if (prefix < OFFSET_LONG_ITEM) {\n\t\t\tint len = prefix - OFFSET_SHORT_ITEM; // length of the encoded bytes\n\t\t\treturn new DecodeResult(pos+1+len, copyOfRange(data, pos+1, pos+1+len));\n\t\t} else if (prefix < OFFSET_SHORT_LIST) {\n\t\t\tint lenlen = prefix - OFFSET_LONG_ITEM; // length of length the encoded bytes\n\t\t\tint lenbytes = byteArrayToInt(copyOfRange(data, pos+1, pos+1+lenlen)); // length of encoded bytes\n\t\t\treturn new DecodeResult(pos+1+lenlen+lenbytes, copyOfRange(data, pos+1+lenlen, pos+1+lenlen+lenbytes));\n\t\t} else if (prefix <= OFFSET_LONG_LIST) {\n\t\t\tint len = prefix - OFFSET_SHORT_LIST; // length of the encoded list\n\t\t\tint prevPos = pos; pos++;\n\t\t\treturn decodeList(data, pos, prevPos, len);\n\t\t} else if (prefix < 0xFF) {\n\t\t\tint lenlen = prefix - OFFSET_LONG_LIST; // length of length the encoded list\n\t\t\tint lenlist = byteArrayToInt(copyOfRange(data, pos+1, pos+1+lenlen)); // length of encoded bytes\n\t\t    pos = pos + lenlen + 1; // start at position of first element in list\n\t\t    int prevPos = lenlist;\n\t\t    return decodeList(data, pos, prevPos, lenlist);\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Only byte values between 0x00 and 0xFF are supported, but got: \" + prefix);\n\t\t}\n\t}", "signature": "DecodeResult decode(byte[] data, int pos)", "full_signature": "public static DecodeResult decode(byte[] data, int pos)", "class_method_signature": "RLP.decode(byte[] data, int pos)", "testcase": false, "constructor": false, "invocations": ["copyOfRange", "byteArrayToInt", "copyOfRange", "copyOfRange", "decodeList", "byteArrayToInt", "copyOfRange", "decodeList"]}, "repository": {"repo_id": 24503275, "url": "https://github.com/ethereumj/ethereumj", "language": "Java", "is_fork": false, "fork_count": 22, "stargazer_count": 27, "size": 13884, "license": "licensed"}}