{"test_class": {"identifier": "TestBlockScanner", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final Logger LOG =\n      LoggerFactory.getLogger(TestBlockScanner.class);", "modifier": "public static final", "type": "Logger", "declarator": "LOG =\n      LoggerFactory.getLogger(TestBlockScanner.class)", "var_name": "LOG"}], "file": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/datanode/TestBlockScanner.java"}, "test_case": {"identifier": "testMarkSuspectBlock", "parameters": "()", "modifiers": "@Test(timeout=120000) public", "return": "void", "body": "@Test(timeout=120000)\n  public void testMarkSuspectBlock() throws Exception {\n    Configuration conf = new Configuration();\n    // Set a really long scan period.\n    conf.setLong(DFS_DATANODE_SCAN_PERIOD_HOURS_KEY, 100L);\n    conf.set(INTERNAL_VOLUME_SCANNER_SCAN_RESULT_HANDLER,\n        TestScanResultHandler.class.getName());\n    conf.setLong(INTERNAL_DFS_BLOCK_SCANNER_CURSOR_SAVE_INTERVAL_MS, 0L);\n    final TestContext ctx = new TestContext(conf, 1);\n    final int NUM_EXPECTED_BLOCKS = 10;\n    ctx.createFiles(0, NUM_EXPECTED_BLOCKS, 1);\n    final TestScanResultHandler.Info info =\n        TestScanResultHandler.getInfo(ctx.volumes.get(0));\n    String storageID = ctx.datanode.getFSDataset().\n        getVolumes().get(0).getStorageID();\n    synchronized (info) {\n      info.sem = new Semaphore(4);\n      info.shouldRun = true;\n      info.notify();\n    }\n    // Scan the first 4 blocks\n    LOG.info(\"Waiting for the first 4 blocks to be scanned.\");\n    GenericTestUtils.waitFor(new Supplier<Boolean>() {\n      @Override\n      public Boolean get() {\n        synchronized (info) {\n          if (info.blocksScanned >= 4) {\n            LOG.info(\"info = {}.  blockScanned has now reached 4.\", info);\n            return true;\n          } else {\n            LOG.info(\"info = {}.  Waiting for blockScanned to reach 4.\", info);\n            return false;\n          }\n        }\n      }\n    }, 50, 30000);\n    // We should have scanned 4 blocks\n    synchronized (info) {\n      assertEquals(\"Expected 4 good blocks.\", 4, info.goodBlocks.size());\n      info.goodBlocks.clear();\n      assertEquals(\"Expected 4 blocksScanned\", 4, info.blocksScanned);\n      assertEquals(\"Did not expect bad blocks.\", 0, info.badBlocks.size());\n      info.blocksScanned = 0;\n    }\n    ExtendedBlock first = ctx.getFileBlock(0, 0);\n    ctx.datanode.getBlockScanner().markSuspectBlock(storageID, first);\n\n    // When we increment the semaphore, the TestScanResultHandler will finish\n    // adding the block that it was scanning previously (the 5th block).\n    // We increment the semaphore twice so that the handler will also\n    // get a chance to see the suspect block which we just requested the\n    // VolumeScanner to process.\n    info.sem.release(2);\n\n    LOG.info(\"Waiting for 2 more blocks to be scanned.\");\n    GenericTestUtils.waitFor(new Supplier<Boolean>() {\n      @Override\n      public Boolean get() {\n        synchronized (info) {\n          if (info.blocksScanned >= 2) {\n            LOG.info(\"info = {}.  blockScanned has now reached 2.\", info);\n            return true;\n          } else {\n            LOG.info(\"info = {}.  Waiting for blockScanned to reach 2.\", info);\n            return false;\n          }\n        }\n      }\n    }, 50, 30000);\n\n    synchronized (info) {\n      assertTrue(\"Expected block \" + first + \" to have been scanned.\",\n          info.goodBlocks.contains(first));\n      assertEquals(2, info.goodBlocks.size());\n      info.goodBlocks.clear();\n      assertEquals(\"Did not expect bad blocks.\", 0, info.badBlocks.size());\n      assertEquals(2, info.blocksScanned);\n      info.blocksScanned = 0;\n    }\n\n    // Re-mark the same block as suspect.\n    ctx.datanode.getBlockScanner().markSuspectBlock(storageID, first);\n    info.sem.release(10);\n\n    LOG.info(\"Waiting for 5 more blocks to be scanned.\");\n    GenericTestUtils.waitFor(new Supplier<Boolean>() {\n      @Override\n      public Boolean get() {\n        synchronized (info) {\n          if (info.blocksScanned >= 5) {\n            LOG.info(\"info = {}.  blockScanned has now reached 5.\", info);\n            return true;\n          } else {\n            LOG.info(\"info = {}.  Waiting for blockScanned to reach 5.\", info);\n            return false;\n          }\n        }\n      }\n    }, 50, 30000);\n    synchronized (info) {\n      assertEquals(5, info.goodBlocks.size());\n      assertEquals(0, info.badBlocks.size());\n      assertEquals(5, info.blocksScanned);\n      // We should not have rescanned the \"suspect block\",\n      // because it was recently rescanned by the suspect block system.\n      // This is a test of the \"suspect block\" rate limiting.\n      Assert.assertFalse(\"We should not \" +\n          \"have rescanned block \" + first + \", because it should have been \" +\n          \"in recentSuspectBlocks.\", info.goodBlocks.contains(first));\n      info.blocksScanned = 0;\n    }\n  }", "signature": "void testMarkSuspectBlock()", "full_signature": "@Test(timeout=120000) public void testMarkSuspectBlock()", "class_method_signature": "TestBlockScanner.testMarkSuspectBlock()", "testcase": true, "constructor": false, "invocations": ["setLong", "set", "getName", "setLong", "createFiles", "getInfo", "get", "getStorageID", "get", "getVolumes", "getFSDataset", "notify", "info", "waitFor", "info", "info", "assertEquals", "size", "clear", "assertEquals", "assertEquals", "size", "getFileBlock", "markSuspectBlock", "getBlockScanner", "release", "info", "waitFor", "info", "info", "assertTrue", "contains", "assertEquals", "size", "clear", "assertEquals", "size", "assertEquals", "markSuspectBlock", "getBlockScanner", "release", "info", "waitFor", "info", "info", "assertEquals", "size", "assertEquals", "size", "assertEquals", "assertFalse", "contains"]}, "focal_class": {"identifier": "BlockScanner", "superclass": "", "interfaces": "", "fields": [{"original_string": "public static final Logger LOG =\n      LoggerFactory.getLogger(BlockScanner.class);", "modifier": "public static final", "type": "Logger", "declarator": "LOG =\n      LoggerFactory.getLogger(BlockScanner.class)", "var_name": "LOG"}, {"original_string": "private final DataNode datanode;", "modifier": "private final", "type": "DataNode", "declarator": "datanode", "var_name": "datanode"}, {"original_string": "private final TreeMap<String, VolumeScanner> scanners =\n      new TreeMap<String, VolumeScanner>();", "modifier": "private final", "type": "TreeMap<String, VolumeScanner>", "declarator": "scanners =\n      new TreeMap<String, VolumeScanner>()", "var_name": "scanners"}, {"original_string": "private final Conf conf;", "modifier": "private final", "type": "Conf", "declarator": "conf", "var_name": "conf"}], "methods": [{"identifier": "BlockScanner", "parameters": "(DataNode datanode, Configuration conf)", "modifiers": "public", "return": "", "signature": " BlockScanner(DataNode datanode, Configuration conf)", "full_signature": "public  BlockScanner(DataNode datanode, Configuration conf)", "class_method_signature": "BlockScanner.BlockScanner(DataNode datanode, Configuration conf)", "testcase": false, "constructor": true}, {"identifier": "isEnabled", "parameters": "()", "modifiers": "public", "return": "boolean", "signature": "boolean isEnabled()", "full_signature": "public boolean isEnabled()", "class_method_signature": "BlockScanner.isEnabled()", "testcase": false, "constructor": false}, {"identifier": "addVolumeScanner", "parameters": "(FsVolumeReference ref)", "modifiers": "public synchronized", "return": "void", "signature": "void addVolumeScanner(FsVolumeReference ref)", "full_signature": "public synchronized void addVolumeScanner(FsVolumeReference ref)", "class_method_signature": "BlockScanner.addVolumeScanner(FsVolumeReference ref)", "testcase": false, "constructor": false}, {"identifier": "removeVolumeScanner", "parameters": "(FsVolumeSpi volume)", "modifiers": "public synchronized", "return": "void", "signature": "void removeVolumeScanner(FsVolumeSpi volume)", "full_signature": "public synchronized void removeVolumeScanner(FsVolumeSpi volume)", "class_method_signature": "BlockScanner.removeVolumeScanner(FsVolumeSpi volume)", "testcase": false, "constructor": false}, {"identifier": "removeAllVolumeScanners", "parameters": "()", "modifiers": "public synchronized", "return": "void", "signature": "void removeAllVolumeScanners()", "full_signature": "public synchronized void removeAllVolumeScanners()", "class_method_signature": "BlockScanner.removeAllVolumeScanners()", "testcase": false, "constructor": false}, {"identifier": "enableBlockPoolId", "parameters": "(String bpid)", "modifiers": "synchronized", "return": "void", "signature": "void enableBlockPoolId(String bpid)", "full_signature": "synchronized void enableBlockPoolId(String bpid)", "class_method_signature": "BlockScanner.enableBlockPoolId(String bpid)", "testcase": false, "constructor": false}, {"identifier": "disableBlockPoolId", "parameters": "(String bpid)", "modifiers": "synchronized", "return": "void", "signature": "void disableBlockPoolId(String bpid)", "full_signature": "synchronized void disableBlockPoolId(String bpid)", "class_method_signature": "BlockScanner.disableBlockPoolId(String bpid)", "testcase": false, "constructor": false}, {"identifier": "getVolumeStats", "parameters": "(String volumeId)", "modifiers": "@VisibleForTesting synchronized", "return": "VolumeScanner.Statistics", "signature": "VolumeScanner.Statistics getVolumeStats(String volumeId)", "full_signature": "@VisibleForTesting synchronized VolumeScanner.Statistics getVolumeStats(String volumeId)", "class_method_signature": "BlockScanner.getVolumeStats(String volumeId)", "testcase": false, "constructor": false}, {"identifier": "printStats", "parameters": "(StringBuilder p)", "modifiers": "synchronized", "return": "void", "signature": "void printStats(StringBuilder p)", "full_signature": "synchronized void printStats(StringBuilder p)", "class_method_signature": "BlockScanner.printStats(StringBuilder p)", "testcase": false, "constructor": false}, {"identifier": "markSuspectBlock", "parameters": "(String storageId, ExtendedBlock block)", "modifiers": "synchronized", "return": "void", "signature": "void markSuspectBlock(String storageId, ExtendedBlock block)", "full_signature": "synchronized void markSuspectBlock(String storageId, ExtendedBlock block)", "class_method_signature": "BlockScanner.markSuspectBlock(String storageId, ExtendedBlock block)", "testcase": false, "constructor": false}], "file": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockScanner.java"}, "focal_method": {"identifier": "markSuspectBlock", "parameters": "(String storageId, ExtendedBlock block)", "modifiers": "synchronized", "return": "void", "body": "synchronized void markSuspectBlock(String storageId, ExtendedBlock block) {\n    if (!isEnabled()) {\n      LOG.debug(\"Not scanning suspicious block {} on {}, because the block \" +\n          \"scanner is disabled.\", block, storageId);\n      return;\n    }\n    VolumeScanner scanner = scanners.get(storageId);\n    if (scanner == null) {\n      // This could happen if the volume is in the process of being removed.\n      // The removal process shuts down the VolumeScanner, but the volume\n      // object stays around as long as there are references to it (which\n      // should not be that long.)\n      LOG.info(\"Not scanning suspicious block {} on {}, because there is no \" +\n          \"volume scanner for that storageId.\", block, storageId);\n      return;\n    }\n    scanner.markSuspectBlock(block);\n  }", "signature": "void markSuspectBlock(String storageId, ExtendedBlock block)", "full_signature": "synchronized void markSuspectBlock(String storageId, ExtendedBlock block)", "class_method_signature": "BlockScanner.markSuspectBlock(String storageId, ExtendedBlock block)", "testcase": false, "constructor": false, "invocations": ["isEnabled", "debug", "get", "info", "markSuspectBlock"]}, "repository": {"repo_id": 195808004, "url": "https://github.com/mouzwang/hadoop-2.7.2", "language": "Java", "is_fork": false, "fork_count": 0, "stargazer_count": 5, "size": 24927, "license": "licensed"}}