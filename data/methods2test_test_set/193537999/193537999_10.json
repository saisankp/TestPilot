{"test_class": {"identifier": "AscDataReaderTest", "superclass": "", "interfaces": "", "fields": [], "file": "vortex-api/src/test/java/mil/army/usace/hec/vortex/io/AscDataReaderTest.java"}, "test_case": {"identifier": "PrismImportPassesRegression", "parameters": "()", "modifiers": "@Test", "return": "void", "body": "@Test\n    void PrismImportPassesRegression() {\n\n        String path = new File(getClass().getResource(\n                \"/regression/io/asc_reader/PRISM_ppt_stable_4kmD2_20170101_asc.asc\").getFile()).toString();\n\n        DataReader reader = DataReader.builder()\n                .path(path)\n                .variable(\"ppt\")\n                .build();\n\n        VortexGrid grid = (VortexGrid) reader.getDtos().get(0);\n\n        float[] data = grid.data();\n        float max = Float.MIN_VALUE;\n        for (float datum : data) {\n            max = Math.max(max, datum);\n        }\n        assertEquals(208.298, max, 1E-3);\n        assertEquals(.04167, grid.dx(), 1E-3);\n        assertEquals(621, grid.ny());\n        assertEquals(1405, grid.nx());\n    }", "signature": "void PrismImportPassesRegression()", "full_signature": "@Test void PrismImportPassesRegression()", "class_method_signature": "AscDataReaderTest.PrismImportPassesRegression()", "testcase": true, "constructor": false, "invocations": ["toString", "getFile", "getResource", "getClass", "build", "variable", "path", "builder", "get", "getDtos", "data", "max", "assertEquals", "assertEquals", "dx", "assertEquals", "ny", "assertEquals", "nx"]}, "focal_class": {"identifier": "AscDataReader", "superclass": "extends DataReader", "interfaces": "", "fields": [{"original_string": "private static final Logger logger = Logger.getLogger(AscDataReader.class.getName());", "modifier": "private static final", "type": "Logger", "declarator": "logger = Logger.getLogger(AscDataReader.class.getName())", "var_name": "logger"}], "methods": [{"identifier": "AscDataReader", "parameters": "(DataReaderBuilder builder)", "modifiers": "", "return": "", "signature": " AscDataReader(DataReaderBuilder builder)", "full_signature": "  AscDataReader(DataReaderBuilder builder)", "class_method_signature": "AscDataReader.AscDataReader(DataReaderBuilder builder)", "testcase": false, "constructor": true}, {"identifier": "getDtos", "parameters": "()", "modifiers": "@Override public", "return": "List<VortexData>", "signature": "List<VortexData> getDtos()", "full_signature": "@Override public List<VortexData> getDtos()", "class_method_signature": "AscDataReader.getDtos()", "testcase": false, "constructor": false}, {"identifier": "getVariables", "parameters": "(String pathToAsc)", "modifiers": "public static", "return": "Set<String>", "signature": "Set<String> getVariables(String pathToAsc)", "full_signature": "public static Set<String> getVariables(String pathToAsc)", "class_method_signature": "AscDataReader.getVariables(String pathToAsc)", "testcase": false, "constructor": false}, {"identifier": "getDtoCount", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getDtoCount()", "full_signature": "@Override public int getDtoCount()", "class_method_signature": "AscDataReader.getDtoCount()", "testcase": false, "constructor": false}, {"identifier": "getDto", "parameters": "(int idx)", "modifiers": "@Override public", "return": "VortexData", "signature": "VortexData getDto(int idx)", "full_signature": "@Override public VortexData getDto(int idx)", "class_method_signature": "AscDataReader.getDto(int idx)", "testcase": false, "constructor": false}], "file": "vortex-api/src/main/java/mil/army/usace/hec/vortex/io/AscDataReader.java"}, "focal_method": {"identifier": "getDtos", "parameters": "()", "modifiers": "@Override public", "return": "List<VortexData>", "body": "@Override\n    public List<VortexData> getDtos() {\n\n        String fileName = new File(path).getName().toLowerCase();\n        String shortName;\n        String fullName;\n        String description;\n\n        AtomicBoolean isPrismTemporalDaily = new AtomicBoolean();\n        AtomicBoolean isPrismTemporalMonthly = new AtomicBoolean();\n        AtomicBoolean isPrismNormal = new AtomicBoolean();\n        AtomicBoolean isQpfHourly = new AtomicBoolean();\n\n        if (fileName.matches(\"prism.*ppt.*stable.*\")) {\n            shortName = \"precipitation\";\n            fullName = \"precipitation\";\n            description = \"precipitation\";\n            if (fileName.matches(\"prism.*ppt.*stable.*(d1|d2).*\"))\n                isPrismTemporalDaily.set(true);\n            if (fileName.matches(\"prism.*ppt.*stable.*m3.*\"))\n                isPrismTemporalMonthly.set(true);\n        } else if (fileName.matches(\"prism.*ppt.*normal.*\")) {\n            shortName = \"precipitation\";\n            fullName = \"precipitation\";\n            description = \"precipitation\";\n            isPrismNormal.set(true);\n        } else if (fileName.matches(\"prism.*tmean.*stable.*\")){\n            shortName = \"mean temperature\";\n            fullName = \"mean temperature\";\n            description = \"mean temperature\";\n            if (fileName.matches(\"prism.*tmean.*stable.*(d1|d2).*\"))\n                isPrismTemporalDaily.set(true);\n            if (fileName.matches(\"prism.*tmean.*stable.*m3.*\"))\n                isPrismTemporalMonthly.set(true);\n        } else if (fileName.matches(\"prism.*tmin.*stable.*\")){\n            shortName = \"minimum temperature\";\n            fullName = \"minimum temperature\";\n            description = \"minimum temperature\";\n            if (fileName.matches(\"prism.*tmin.*stable.*d2.*(d1|d2).*\"))\n                isPrismTemporalDaily.set(true);\n            if (fileName.matches(\"prism.*tmin.*stable.*m3.*\"))\n                isPrismTemporalMonthly.set(true);\n        } else if (fileName.matches(\"prism.*tmax.*stable.*\")){\n            shortName = \"maximum temperature\";\n            fullName = \"maximum temperature\";\n            description = \"maximum temperature\";\n            if (fileName.matches(\"prism.*tmax.*stable.*(d1|d2).*\"))\n                isPrismTemporalDaily.set(true);\n            if (fileName.matches(\"prism.*tmax.*stable.*m3.*\"))\n                isPrismTemporalMonthly.set(true);\n        } else if (fileName.matches(\"prism.*tdmean.*stable.*\")){\n            shortName = \"mean dewpoint temperature\";\n            fullName = \"mean dewpoint temperature\";\n            description = \"mean dewpoint temperature\";\n            if (fileName.matches(\"prism.*tdmean.*stable.*(d1|d2).*\"))\n                isPrismTemporalDaily.set(true);\n            if (fileName.matches(\"prism.*tdmean.*stable.*m3.*\"))\n                isPrismTemporalMonthly.set(true);\n        } else if (fileName.matches(\"prism.*vpdmin.*stable.*\")){\n            shortName = \"minimum vapor pressure deficit\";\n            fullName = \"minimum vapor pressure deficit\";\n            description = \"minimum vapor pressure deficit\";\n            if (fileName.matches(\"prism.*vpdmin.*stable.*(d1|d2).*\"))\n                isPrismTemporalDaily.set(true);\n            if (fileName.matches(\"prism.*vpdmin.*stable.*m3.*\"))\n                isPrismTemporalMonthly.set(true);\n        } else if (fileName.matches(\"prism.*vpdmax.*stable.*\")){\n            shortName = \"maximum vapor pressure deficit\";\n            fullName = \"maximum vapor pressure deficit\";\n            description = \"maximum vapor pressure deficit\";\n            if (fileName.matches(\"prism.*vpdmax.*stable.*(d1|d2).*\"))\n                isPrismTemporalDaily.set(true);\n            if (fileName.matches(\"prism.*vpdmax.*stable.*m3.*\"))\n                isPrismTemporalMonthly.set(true);\n        } else if (fileName.matches(\"qpf.*1hr.*\")) {\n            shortName = \"precipitation\";\n            fullName = \"precipitation\";\n            description = \"precipitation\";\n            isQpfHourly.set(true);\n        } else if (fileName.matches(\".*yr.*ha.*\")) {\n            shortName = \"precipitation-frequency\";\n            fullName = \"precipitation-frequency\";\n            description = \"precipitation-frequency\";\n        } else if (fileName.toLowerCase().matches(\"windspeed.*\")) {\n            shortName = \"windspeed\";\n            fullName = \"windspeed\";\n            description = \"windspeed\";\n        } else {\n            shortName = \"\";\n            fullName = \"\";\n            description = \"\";\n        }\n\n        ZonedDateTime startTime;\n        ZonedDateTime endTime;\n        Duration interval;\n        if (isPrismTemporalDaily.get()) {\n            String string1 = path;\n            String string2 = string1.substring(0, string1.lastIndexOf('_'));\n            String string3 = string2.substring(string2.length() - 8);\n\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyyMMdd\");\n            LocalDate date = LocalDate.parse(string3, formatter);\n            startTime = ZonedDateTime.of(LocalDateTime.of(date, LocalTime.of(0, 0)), ZoneId.of(\"UTC\")).minusHours(12);\n            endTime = ZonedDateTime.of(LocalDateTime.of(date.plusDays(1), LocalTime.of(0, 0)), ZoneId.of(\"UTC\")).minusHours(12);\n            interval = Duration.between(startTime, endTime);\n        } else if (isPrismNormal.get()){\n            startTime = ZonedDateTime.of(1981, 1, 1, 0, 0, 0, 0, ZoneId.of(\"UTC\"));\n            endTime = ZonedDateTime.of(2010, 12, 31, 0, 0, 0, 0, ZoneId.of(\"UTC\"));\n            interval = Duration.between(startTime, endTime);\n        } else if (isPrismTemporalMonthly.get()) {\n            Pattern pattern = Pattern.compile(\"\\\\d{6}\");\n            Matcher matcher = pattern.matcher(path);\n            String dateString = \"\";\n            while (matcher.find()) {\n                dateString = matcher.group(0);\n            }\n\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyyMM\");\n            YearMonth yearMonth;\n            try {\n                yearMonth = YearMonth.parse(dateString, formatter);\n            } catch (DateTimeParseException e) {\n                logger.log(Level.WARNING, e, e::getMessage);\n                return Collections.emptyList();\n            }\n            LocalDateTime startDay = LocalDateTime.of(yearMonth.getYear(), yearMonth.getMonth(), 1, 0, 0);\n            startTime = ZonedDateTime.of(startDay, ZoneId.of(\"UTC\"));\n            endTime = startTime.plusMonths(1);\n            interval = Duration.between(startTime, endTime);\n        } else if (isQpfHourly.get()) {\n            String filenameSansExt = fileName.replaceFirst(\"[.][^.]+$\", \"\");\n            String dateString = filenameSansExt.substring(filenameSansExt.length() - 8);\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyMMddHH\");\n            LocalDateTime localDateTime = LocalDateTime.parse(dateString, formatter);\n            endTime = ZonedDateTime.of(localDateTime, ZoneId.of(\"UTC\"));\n            startTime = endTime.minusHours(1);\n            interval = Duration.ofHours(1);\n        } else {\n            Pattern pattern = Pattern.compile(\"\\\\d{4}_\\\\d{2}_\\\\d{2}t\\\\d{4}\");\n            Matcher matcher = pattern.matcher(fileName);\n            List<String> dateStrings = new ArrayList<>();\n            while (matcher.find()){\n                dateStrings.add(matcher.group(0));\n            }\n\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy_MM_dd't'Hmm\");\n            if (dateStrings.size() == 2) {\n                startTime = ZonedDateTime.of(LocalDateTime.parse(dateStrings.get(0), formatter), ZoneId.of(\"Z\"));\n                endTime = ZonedDateTime.of(LocalDateTime.parse(dateStrings.get(1), formatter), ZoneId.of(\"Z\"));\n                interval = Duration.between(startTime, endTime);\n            } else if(dateStrings.size() == 1 ) {\n                startTime = ZonedDateTime.of(LocalDateTime.parse(dateStrings.get(0), formatter), ZoneId.of(\"Z\"));\n                endTime = ZonedDateTime.from(startTime);\n                interval = Duration.ZERO;\n            } else {\n                startTime = null;\n                endTime = null;\n                interval = null;\n            }\n\n        }\n\n        String units;\n        if (fileName.contains(\"ppt\") || fileName.contains(\"qpf\")){\n            units = \"mm\";\n        } else if (fileName.contains(\"tmean\")){\n            units = \"Degrees C\";\n        } else if (fileName.contains(\"tmin\")){\n            units = \"Degrees C\";\n        } else if (fileName.contains(\"tmax\")){\n            units = \"Degrees C\";\n        } else if (fileName.contains(\"tdmean\")){\n            units = \"Degrees C\";\n        } else if (fileName.contains(\"vpdmin\")){\n            units = \"hPa\";\n        } else if (fileName.contains(\"vpdmax\")) {\n            units = \"hPa\";\n        } else if (fileName.matches(\".*yr.*ha.*\")) {\n            units = \"1/1000 in\";\n        } else {\n            units = \"\";\n        }\n\n        Dataset dataset = gdal.Open(path);\n\n        double[] geoTransform = dataset.GetGeoTransform();\n        double dx = geoTransform[1];\n        double dy = geoTransform[5];\n        double ulx = geoTransform[0];\n        double uly = geoTransform[3];\n        int nx = dataset.GetRasterXSize();\n        int ny = dataset.GetRasterYSize();\n        String wkt = dataset.GetProjection();\n        Band band = dataset.GetRasterBand(1);\n        float[] data = new float[nx * ny];\n        band.ReadRaster(0, 0, nx, ny, gdalconst.GDT_Float32, data);\n\n        dataset.delete();\n        band.delete();\n\n        VortexGrid dto = VortexGrid.builder()\n                .dx(dx).dy(dy).nx(nx).ny(ny)\n                .originX(ulx).originY(uly)\n                .wkt(wkt).data(data).units(units)\n                .fileName(path).shortName(shortName)\n                .fullName(fullName).description(description)\n                .startTime(startTime).endTime(endTime)\n                .interval(interval)\n                .build();\n\n        List<VortexData> list = new ArrayList<>();\n        list.add(dto);\n        return list;\n    }", "signature": "List<VortexData> getDtos()", "full_signature": "@Override public List<VortexData> getDtos()", "class_method_signature": "AscDataReader.getDtos()", "testcase": false, "constructor": false, "invocations": ["toLowerCase", "getName", "matches", "matches", "set", "matches", "set", "matches", "set", "matches", "matches", "set", "matches", "set", "matches", "matches", "set", "matches", "set", "matches", "matches", "set", "matches", "set", "matches", "matches", "set", "matches", "set", "matches", "matches", "set", "matches", "set", "matches", "matches", "set", "matches", "set", "matches", "set", "matches", "matches", "toLowerCase", "get", "substring", "lastIndexOf", "substring", "length", "ofPattern", "parse", "minusHours", "of", "of", "of", "of", "minusHours", "of", "of", "plusDays", "of", "of", "between", "get", "of", "of", "of", "of", "between", "get", "compile", "matcher", "find", "group", "ofPattern", "parse", "log", "emptyList", "of", "getYear", "getMonth", "of", "of", "plusMonths", "between", "get", "replaceFirst", "substring", "length", "ofPattern", "parse", "of", "of", "minusHours", "ofHours", "compile", "matcher", "find", "add", "group", "ofPattern", "size", "of", "parse", "get", "of", "of", "parse", "get", "of", "between", "size", "of", "parse", "get", "of", "from", "contains", "contains", "contains", "contains", "contains", "contains", "contains", "contains", "matches", "Open", "GetGeoTransform", "GetRasterXSize", "GetRasterYSize", "GetProjection", "GetRasterBand", "ReadRaster", "delete", "delete", "build", "interval", "endTime", "startTime", "description", "fullName", "shortName", "fileName", "units", "data", "wkt", "originY", "originX", "ny", "nx", "dy", "dx", "builder", "add"]}, "repository": {"repo_id": 193537999, "url": "https://github.com/HydrologicEngineeringCenter/Vortex", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 5, "size": 448543, "license": "licensed"}}