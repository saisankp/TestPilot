{"test_class": {"identifier": "ChecklistPlannerTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final String MODULE_ALPHA = \"alpha\";", "modifier": "private static final", "type": "String", "declarator": "MODULE_ALPHA = \"alpha\"", "var_name": "MODULE_ALPHA"}, {"original_string": "private static final String MODULE_BRAVO = \"bravo\";", "modifier": "private static final", "type": "String", "declarator": "MODULE_BRAVO = \"bravo\"", "var_name": "MODULE_BRAVO"}, {"original_string": "private static final String MODULE_CHARLIE = \"charlie\";", "modifier": "private static final", "type": "String", "declarator": "MODULE_CHARLIE = \"charlie\"", "var_name": "MODULE_CHARLIE"}, {"original_string": "private static final String CKL_NAME_ALPHA = \"alpha\";", "modifier": "private static final", "type": "String", "declarator": "CKL_NAME_ALPHA = \"alpha\"", "var_name": "CKL_NAME_ALPHA"}, {"original_string": "private static final String CKL_ID_ALPHA = MODULE_ALPHA + \"/\" + CKL_NAME_ALPHA;", "modifier": "private static final", "type": "String", "declarator": "CKL_ID_ALPHA = MODULE_ALPHA + \"/\" + CKL_NAME_ALPHA", "var_name": "CKL_ID_ALPHA"}, {"original_string": "private static final String CKL_NAME_BRAVO_1 = \"bravo-1\";", "modifier": "private static final", "type": "String", "declarator": "CKL_NAME_BRAVO_1 = \"bravo-1\"", "var_name": "CKL_NAME_BRAVO_1"}, {"original_string": "private static final String CKL_ID_BRAVO_1 = MODULE_BRAVO + \"/\" + CKL_NAME_BRAVO_1;", "modifier": "private static final", "type": "String", "declarator": "CKL_ID_BRAVO_1 = MODULE_BRAVO + \"/\" + CKL_NAME_BRAVO_1", "var_name": "CKL_ID_BRAVO_1"}, {"original_string": "private static final String CKL_NAME_BRAVO_2 = \"bravo-2\";", "modifier": "private static final", "type": "String", "declarator": "CKL_NAME_BRAVO_2 = \"bravo-2\"", "var_name": "CKL_NAME_BRAVO_2"}, {"original_string": "private static final String CKL_ID_BRAVO_2 = MODULE_BRAVO + \"/\" + CKL_NAME_BRAVO_2;", "modifier": "private static final", "type": "String", "declarator": "CKL_ID_BRAVO_2 = MODULE_BRAVO + \"/\" + CKL_NAME_BRAVO_2", "var_name": "CKL_ID_BRAVO_2"}, {"original_string": "private static final String CKL_NAME_CHARLIE = \"charlie\";", "modifier": "private static final", "type": "String", "declarator": "CKL_NAME_CHARLIE = \"charlie\"", "var_name": "CKL_NAME_CHARLIE"}, {"original_string": "private static final String CKL_ID_CHARLIE = MODULE_CHARLIE + \"/\" + CKL_NAME_CHARLIE;", "modifier": "private static final", "type": "String", "declarator": "CKL_ID_CHARLIE = MODULE_CHARLIE + \"/\" + CKL_NAME_CHARLIE", "var_name": "CKL_ID_CHARLIE"}, {"original_string": "private static final List<String> ALL_CKL_IDS = Arrays.asList(\n            CKL_ID_ALPHA, CKL_ID_BRAVO_1, CKL_ID_BRAVO_2, CKL_ID_CHARLIE);", "modifier": "private static final", "type": "List<String>", "declarator": "ALL_CKL_IDS = Arrays.asList(\n            CKL_ID_ALPHA, CKL_ID_BRAVO_1, CKL_ID_BRAVO_2, CKL_ID_CHARLIE)", "var_name": "ALL_CKL_IDS"}, {"original_string": "private final File resourceDir = new File(\"src/test/resources/ChecklistPlannerTest\");", "modifier": "private final", "type": "File", "declarator": "resourceDir = new File(\"src/test/resources/ChecklistPlannerTest\")", "var_name": "resourceDir"}, {"original_string": "private final File alphaDir = new File(resourceDir, MODULE_ALPHA);", "modifier": "private final", "type": "File", "declarator": "alphaDir = new File(resourceDir, MODULE_ALPHA)", "var_name": "alphaDir"}, {"original_string": "private final File bravoDir = new File(resourceDir, MODULE_BRAVO);", "modifier": "private final", "type": "File", "declarator": "bravoDir = new File(resourceDir, MODULE_BRAVO)", "var_name": "bravoDir"}, {"original_string": "private final File charlieDir = new File(resourceDir, MODULE_CHARLIE);", "modifier": "private final", "type": "File", "declarator": "charlieDir = new File(resourceDir, MODULE_CHARLIE)", "var_name": "charlieDir"}, {"original_string": "private final File zuluDir = new File(resourceDir, \"zulu\");", "modifier": "private final", "type": "File", "declarator": "zuluDir = new File(resourceDir, \"zulu\")", "var_name": "zuluDir"}, {"original_string": "private URL alphaManifest;", "modifier": "private", "type": "URL", "declarator": "alphaManifest", "var_name": "alphaManifest"}, {"original_string": "private URL bravoManifest;", "modifier": "private", "type": "URL", "declarator": "bravoManifest", "var_name": "bravoManifest"}, {"original_string": "private URL charlieManifest;", "modifier": "private", "type": "URL", "declarator": "charlieManifest", "var_name": "charlieManifest"}, {"original_string": "private URL zuluManifest;", "modifier": "private", "type": "URL", "declarator": "zuluManifest", "var_name": "zuluManifest"}, {"original_string": "final Predicate<Checklist> alphaFilter = checklist ->\n            MODULE_ALPHA.equals(checklist.getModuleName()) && CKL_NAME_ALPHA.equals(checklist.getName());", "modifier": "final", "type": "Predicate<Checklist>", "declarator": "alphaFilter = checklist ->\n            MODULE_ALPHA.equals(checklist.getModuleName()) && CKL_NAME_ALPHA.equals(checklist.getName())", "var_name": "alphaFilter"}, {"original_string": "final Predicate<Checklist> bravo1Filter = checklist ->\n            MODULE_BRAVO.equals(checklist.getModuleName()) && CKL_NAME_BRAVO_1.equals(checklist.getName());", "modifier": "final", "type": "Predicate<Checklist>", "declarator": "bravo1Filter = checklist ->\n            MODULE_BRAVO.equals(checklist.getModuleName()) && CKL_NAME_BRAVO_1.equals(checklist.getName())", "var_name": "bravo1Filter"}, {"original_string": "final Predicate<Checklist> bravo2Filter = checklist ->\n            MODULE_BRAVO.equals(checklist.getModuleName()) && CKL_NAME_BRAVO_2.equals(checklist.getName());", "modifier": "final", "type": "Predicate<Checklist>", "declarator": "bravo2Filter = checklist ->\n            MODULE_BRAVO.equals(checklist.getModuleName()) && CKL_NAME_BRAVO_2.equals(checklist.getName())", "var_name": "bravo2Filter"}, {"original_string": "final Predicate<Checklist> charlieFilter = checklist ->\n            MODULE_CHARLIE.equals(checklist.getModuleName()) && CKL_NAME_CHARLIE.equals(checklist.getName());", "modifier": "final", "type": "Predicate<Checklist>", "declarator": "charlieFilter = checklist ->\n            MODULE_CHARLIE.equals(checklist.getModuleName()) && CKL_NAME_CHARLIE.equals(checklist.getName())", "var_name": "charlieFilter"}], "file": "core/src/test/java/net/adamcin/oakpal/core/ChecklistPlannerTest.java"}, "test_case": {"identifier": "testGetEffectiveCheckSpecs", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testGetEffectiveCheckSpecs() throws Exception {\n        ChecklistPlanner planner = new ChecklistPlanner(Arrays.asList(CKL_NAME_ALPHA, CKL_NAME_BRAVO_1));\n        planner.provideChecklists(constructIndivChecklists());\n\n        List<CheckSpec> effNoOverrides = planner.getEffectiveCheckSpecs(null);\n        assertEquals(\"effective checks size should be\", 2, effNoOverrides.size());\n        assertEquals(\"first should be alpha\", CKL_NAME_ALPHA + \"/pathy\", effNoOverrides.get(0).getName());\n        assertEquals(\"second should be bravo/bravo-1\", CKL_ID_BRAVO_1 + \"/pathy\", effNoOverrides.get(1).getName());\n\n        final CheckSpec pathyOverride = new CheckSpec();\n        pathyOverride.setName(\"pathy\");\n        pathyOverride.setSkip(true);\n        List<CheckSpec> effOneOverride = planner.getEffectiveCheckSpecs(Collections.singletonList(pathyOverride));\n        assertEquals(\"effective checks size should be\", 0, effOneOverride.size());\n\n        final CheckSpec alphaPathyOverride = new CheckSpec();\n        alphaPathyOverride.setName(\"alpha/pathy\");\n        alphaPathyOverride.setSkip(true);\n\n        List<CheckSpec> effOneAlphaOverride = planner.getEffectiveCheckSpecs(Collections.singletonList(alphaPathyOverride));\n        assertEquals(\"effective checks size should be\", 1, effOneAlphaOverride.size());\n\n        final CheckSpec alphaPathy2Override = new CheckSpec();\n        alphaPathy2Override.setName(\"pathy2\");\n        alphaPathy2Override.setTemplate(\"alpha/pathy\");\n        List<CheckSpec> effOneAlphaInherit = planner.getEffectiveCheckSpecs(Arrays.asList(alphaPathyOverride, alphaPathy2Override));\n        assertEquals(\"effective checks size should be\", 2, effOneAlphaInherit.size());\n\n        final CheckSpec implSpec = new CheckSpec();\n        implSpec.setImpl(\"foo\");\n        List<CheckSpec> effWithImplSpec = planner.getEffectiveCheckSpecs(Arrays.asList(alphaPathyOverride, alphaPathy2Override, implSpec));\n        assertEquals(\"effective checks size should be\", 3, effWithImplSpec.size());\n\n    }", "signature": "void testGetEffectiveCheckSpecs()", "full_signature": "@Test public void testGetEffectiveCheckSpecs()", "class_method_signature": "ChecklistPlannerTest.testGetEffectiveCheckSpecs()", "testcase": true, "constructor": false, "invocations": ["asList", "provideChecklists", "constructIndivChecklists", "getEffectiveCheckSpecs", "assertEquals", "size", "assertEquals", "getName", "get", "assertEquals", "getName", "get", "setName", "setSkip", "getEffectiveCheckSpecs", "singletonList", "assertEquals", "size", "setName", "setSkip", "getEffectiveCheckSpecs", "singletonList", "assertEquals", "size", "setName", "setTemplate", "getEffectiveCheckSpecs", "asList", "assertEquals", "size", "setImpl", "getEffectiveCheckSpecs", "asList", "assertEquals", "size"]}, "focal_class": {"identifier": "ChecklistPlanner", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final Logger LOGGER = LoggerFactory.getLogger(ChecklistPlanner.class);", "modifier": "private static final", "type": "Logger", "declarator": "LOGGER = LoggerFactory.getLogger(ChecklistPlanner.class)", "var_name": "LOGGER"}, {"original_string": "public static final String OAKPAL_CHECKLIST = \"Oakpal-Checklist\";", "modifier": "public static final", "type": "String", "declarator": "OAKPAL_CHECKLIST = \"Oakpal-Checklist\"", "var_name": "OAKPAL_CHECKLIST"}, {"original_string": "public static final String OAKPAL_MODULENAME = \"Oakpal-ModuleName\";", "modifier": "public static final", "type": "String", "declarator": "OAKPAL_MODULENAME = \"Oakpal-ModuleName\"", "var_name": "OAKPAL_MODULENAME"}, {"original_string": "public static final String BUNDLE_SYMBOLICNAME = \"Bundle-SymbolicName\";", "modifier": "public static final", "type": "String", "declarator": "BUNDLE_SYMBOLICNAME = \"Bundle-SymbolicName\"", "var_name": "BUNDLE_SYMBOLICNAME"}, {"original_string": "public static final String AUTOMATIC_MODULE_NAME = \"Automatic-Module-Name\";", "modifier": "public static final", "type": "String", "declarator": "AUTOMATIC_MODULE_NAME = \"Automatic-Module-Name\"", "var_name": "AUTOMATIC_MODULE_NAME"}, {"original_string": "private final Set<String> activeChecklistIds = new LinkedHashSet<>();", "modifier": "private final", "type": "Set<String>", "declarator": "activeChecklistIds = new LinkedHashSet<>()", "var_name": "activeChecklistIds"}, {"original_string": "private final List<Checklist> checklists = new ArrayList<>();", "modifier": "private final", "type": "List<Checklist>", "declarator": "checklists = new ArrayList<>()", "var_name": "checklists"}, {"original_string": "private final List<Checklist> inactiveChecklists = new ArrayList<>();", "modifier": "private final", "type": "List<Checklist>", "declarator": "inactiveChecklists = new ArrayList<>()", "var_name": "inactiveChecklists"}], "methods": [{"identifier": "ChecklistPlanner", "parameters": "(final List<String> activeChecklistIds)", "modifiers": "public", "return": "", "signature": " ChecklistPlanner(final List<String> activeChecklistIds)", "full_signature": "public  ChecklistPlanner(final List<String> activeChecklistIds)", "class_method_signature": "ChecklistPlanner.ChecklistPlanner(final List<String> activeChecklistIds)", "testcase": false, "constructor": true}, {"identifier": "provideChecklists", "parameters": "(final List<Checklist> constructed)", "modifiers": "public", "return": "void", "signature": "void provideChecklists(final List<Checklist> constructed)", "full_signature": "public void provideChecklists(final List<Checklist> constructed)", "class_method_signature": "ChecklistPlanner.provideChecklists(final List<Checklist> constructed)", "testcase": false, "constructor": false}, {"identifier": "discoverChecklists", "parameters": "()", "modifiers": "public", "return": "void", "signature": "void discoverChecklists()", "full_signature": "public void discoverChecklists()", "class_method_signature": "ChecklistPlanner.discoverChecklists()", "testcase": false, "constructor": false}, {"identifier": "discoverChecklists", "parameters": "(final ClassLoader classLoader)", "modifiers": "public", "return": "void", "signature": "void discoverChecklists(final ClassLoader classLoader)", "full_signature": "public void discoverChecklists(final ClassLoader classLoader)", "class_method_signature": "ChecklistPlanner.discoverChecklists(final ClassLoader classLoader)", "testcase": false, "constructor": false}, {"identifier": "discoverChecklists", "parameters": "(final List<File> files)", "modifiers": "public", "return": "void", "signature": "void discoverChecklists(final List<File> files)", "full_signature": "public void discoverChecklists(final List<File> files)", "class_method_signature": "ChecklistPlanner.discoverChecklists(final List<File> files)", "testcase": false, "constructor": false}, {"identifier": "selectChecklists", "parameters": "(final List<Checklist> constructed)", "modifiers": "private", "return": "void", "signature": "void selectChecklists(final List<Checklist> constructed)", "full_signature": "private void selectChecklists(final List<Checklist> constructed)", "class_method_signature": "ChecklistPlanner.selectChecklists(final List<Checklist> constructed)", "testcase": false, "constructor": false}, {"identifier": "isChecklistSelected", "parameters": "(final String activeId, final Checklist checklist)", "modifiers": "private", "return": "boolean", "signature": "boolean isChecklistSelected(final String activeId, final Checklist checklist)", "full_signature": "private boolean isChecklistSelected(final String activeId, final Checklist checklist)", "class_method_signature": "ChecklistPlanner.isChecklistSelected(final String activeId, final Checklist checklist)", "testcase": false, "constructor": false}, {"identifier": "getInitStages", "parameters": "()", "modifiers": "public", "return": "List<InitStage>", "signature": "List<InitStage> getInitStages()", "full_signature": "public List<InitStage> getInitStages()", "class_method_signature": "ChecklistPlanner.getInitStages()", "testcase": false, "constructor": false}, {"identifier": "getSelectedChecklists", "parameters": "()", "modifiers": "", "return": "Stream<Checklist>", "signature": "Stream<Checklist> getSelectedChecklists()", "full_signature": " Stream<Checklist> getSelectedChecklists()", "class_method_signature": "ChecklistPlanner.getSelectedChecklists()", "testcase": false, "constructor": false}, {"identifier": "getAllChecklists", "parameters": "()", "modifiers": "", "return": "Stream<Checklist>", "signature": "Stream<Checklist> getAllChecklists()", "full_signature": " Stream<Checklist> getAllChecklists()", "class_method_signature": "ChecklistPlanner.getAllChecklists()", "testcase": false, "constructor": false}, {"identifier": "getEffectiveCheckSpecs", "parameters": "(final List<CheckSpec> checkOverrides)", "modifiers": "public", "return": "List<CheckSpec>", "signature": "List<CheckSpec> getEffectiveCheckSpecs(final List<CheckSpec> checkOverrides)", "full_signature": "public List<CheckSpec> getEffectiveCheckSpecs(final List<CheckSpec> checkOverrides)", "class_method_signature": "ChecklistPlanner.getEffectiveCheckSpecs(final List<CheckSpec> checkOverrides)", "testcase": false, "constructor": false}, {"identifier": "applyOverrides", "parameters": "(final List<CheckSpec> checkOverrides, final CheckSpec base)", "modifiers": "static", "return": "CheckSpec", "signature": "CheckSpec applyOverrides(final List<CheckSpec> checkOverrides, final CheckSpec base)", "full_signature": "static CheckSpec applyOverrides(final List<CheckSpec> checkOverrides, final CheckSpec base)", "class_method_signature": "ChecklistPlanner.applyOverrides(final List<CheckSpec> checkOverrides, final CheckSpec base)", "testcase": false, "constructor": false}, {"identifier": "constructChecklists", "parameters": "(final Map<URL, List<JsonObject>> parsed)", "modifiers": "public static", "return": "List<Checklist>", "signature": "List<Checklist> constructChecklists(final Map<URL, List<JsonObject>> parsed)", "full_signature": "public static List<Checklist> constructChecklists(final Map<URL, List<JsonObject>> parsed)", "class_method_signature": "ChecklistPlanner.constructChecklists(final Map<URL, List<JsonObject>> parsed)", "testcase": false, "constructor": false}, {"identifier": "parseChecklists", "parameters": "(final URL manifestUrl)", "modifiers": "public static", "return": "Map<URL, List<JsonObject>>", "signature": "Map<URL, List<JsonObject>> parseChecklists(final URL manifestUrl)", "full_signature": "public static Map<URL, List<JsonObject>> parseChecklists(final URL manifestUrl)", "class_method_signature": "ChecklistPlanner.parseChecklists(final URL manifestUrl)", "testcase": false, "constructor": false}, {"identifier": "parseChecklists", "parameters": "(final ClassLoader classLoader)", "modifiers": "public static", "return": "Map<URL, List<JsonObject>>", "signature": "Map<URL, List<JsonObject>> parseChecklists(final ClassLoader classLoader)", "full_signature": "public static Map<URL, List<JsonObject>> parseChecklists(final ClassLoader classLoader)", "class_method_signature": "ChecklistPlanner.parseChecklists(final ClassLoader classLoader)", "testcase": false, "constructor": false}, {"identifier": "parseChecklists", "parameters": "(final List<File> files)", "modifiers": "public static", "return": "Map<URL, List<JsonObject>>", "signature": "Map<URL, List<JsonObject>> parseChecklists(final List<File> files)", "full_signature": "public static Map<URL, List<JsonObject>> parseChecklists(final List<File> files)", "class_method_signature": "ChecklistPlanner.parseChecklists(final List<File> files)", "testcase": false, "constructor": false}, {"identifier": "parseChecklists", "parameters": "(final Map<URL, List<URL>> manifestLookup)", "modifiers": "static", "return": "Map<URL, List<JsonObject>>", "signature": "Map<URL, List<JsonObject>> parseChecklists(final Map<URL, List<URL>> manifestLookup)", "full_signature": "static Map<URL, List<JsonObject>> parseChecklists(final Map<URL, List<URL>> manifestLookup)", "class_method_signature": "ChecklistPlanner.parseChecklists(final Map<URL, List<URL>> manifestLookup)", "testcase": false, "constructor": false}, {"identifier": "bestModuleName", "parameters": "(final URL manifestUrl)", "modifiers": "static", "return": "String", "signature": "String bestModuleName(final URL manifestUrl)", "full_signature": "static String bestModuleName(final URL manifestUrl)", "class_method_signature": "ChecklistPlanner.bestModuleName(final URL manifestUrl)", "testcase": false, "constructor": false}], "file": "core/src/main/java/net/adamcin/oakpal/core/ChecklistPlanner.java"}, "focal_method": {"identifier": "getEffectiveCheckSpecs", "parameters": "(final List<CheckSpec> checkOverrides)", "modifiers": "public", "return": "List<CheckSpec>", "body": "public List<CheckSpec> getEffectiveCheckSpecs(final List<CheckSpec> checkOverrides) {\n        Map<String, CheckSpec> overlaid = new LinkedHashMap<>();\n        List<CheckSpec> overrides = new ArrayList<>();\n\n        if (checkOverrides != null) {\n            overrides.addAll(checkOverrides);\n        }\n\n        LOGGER.trace(\"[getEffectiveCheckSpecs] checkOverrides: {}\", checkOverrides);\n\n        // first accum checks selected via selected checklists\n        getSelectedChecklists()\n                // debug filter\n                .filter(Util.traceFilter(LOGGER, \"[getEffectiveCheckSpecs] selected checklist: {}\"))\n                // Stream<Checklist> -> Stream<CheckSpec>\n                .flatMap(checklist -> checklist.getChecks().stream())\n                // apply overrides to each base spec\n                .map(base -> applyOverrides(overrides, base))\n                // evaluate skip after override\n                .filter(CheckSpec::notSkipped)\n                // only accum once\n                .forEachOrdered(checkSpec -> {\n                    if (!overlaid.containsKey(checkSpec.getName())) {\n                        overlaid.put(checkSpec.getName(), checkSpec);\n                    }\n                });\n\n        List<CheckSpec> toReturn = new ArrayList<>(overlaid.values());\n\n        LOGGER.trace(\"[getEffectiveCheckSpecs] selectedChecklistChecks: {}\", toReturn);\n\n        // stream overrides to identify remaining specs\n        overrides.stream()\n                // filter out skipped overrides\n                .filter(CheckSpec::notSkipped)\n                // filter out overrides that already applied\n                .filter(spec -> overlaid.values().stream().noneMatch(spec::overrides))\n                // find first base spec to override among inactive checklists\n                .forEachOrdered(spec -> {\n                    CheckSpec merged = inactiveChecklists.stream()\n                            // Stream<Checklist> -> Stream<CheckSpec>\n                            .flatMap(checklist -> checklist.getChecks().stream())\n                            // select base specs that each override spec overrides\n                            .filter(spec::overrides)\n                            // take optional head and overlay with override, or return override itself\n                            .findFirst()\n                            .map(spec::overlay)\n                            .filter(CheckSpec::notSkipped)\n                            .orElse(spec);\n\n                    if (merged.mustInherit()) {\n                        CheckSpec extended = getAllChecklists()\n                                .flatMap(checklist -> checklist.getChecks().stream())\n                                .filter(merged::inherits)\n                                .findFirst().map(merged::inherit).orElse(merged);\n                        // if extended spec has impl, add it\n                        if (extended.notAbstract()) {\n                            toReturn.add(extended);\n                        }\n                    } else {\n                        // if merged spec has impl, add it\n                        if (merged.notAbstract()) {\n                            toReturn.add(merged);\n                        }\n                    }\n                });\n\n        LOGGER.trace(\"[getEffectiveCheckSpecs] effective check specs: {}\", toReturn);\n        return toReturn;\n    }", "signature": "List<CheckSpec> getEffectiveCheckSpecs(final List<CheckSpec> checkOverrides)", "full_signature": "public List<CheckSpec> getEffectiveCheckSpecs(final List<CheckSpec> checkOverrides)", "class_method_signature": "ChecklistPlanner.getEffectiveCheckSpecs(final List<CheckSpec> checkOverrides)", "testcase": false, "constructor": false, "invocations": ["addAll", "trace", "forEachOrdered", "filter", "map", "flatMap", "filter", "getSelectedChecklists", "traceFilter", "stream", "getChecks", "applyOverrides", "containsKey", "getName", "put", "getName", "values", "trace", "forEachOrdered", "filter", "filter", "stream", "noneMatch", "stream", "values", "orElse", "filter", "map", "findFirst", "filter", "flatMap", "stream", "stream", "getChecks", "mustInherit", "orElse", "map", "findFirst", "filter", "flatMap", "getAllChecklists", "stream", "getChecks", "notAbstract", "add", "notAbstract", "add", "trace"]}, "repository": {"repo_id": 155883728, "url": "https://github.com/adamcin/oakpal", "language": "Java", "is_fork": false, "fork_count": 6, "stargazer_count": 6, "size": 13349, "license": "licensed"}}