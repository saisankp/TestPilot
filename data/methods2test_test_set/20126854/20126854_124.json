{"test_class": {"identifier": "DeltaFriendlyOldBlobSizeLimiterTest", "superclass": "", "interfaces": "", "fields": [{"original_string": "private static final int DEFLATE_COMPRESSION_METHOD = 8;", "modifier": "private static final", "type": "int", "declarator": "DEFLATE_COMPRESSION_METHOD = 8", "var_name": "DEFLATE_COMPRESSION_METHOD"}, {"original_string": "private static final MinimalZipEntry UNIMPORTANT = makeFakeEntry(\"/unimportant\", 1337, 1337);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "UNIMPORTANT = makeFakeEntry(\"/unimportant\", 1337, 1337)", "var_name": "UNIMPORTANT"}, {"original_string": "private static final MinimalZipEntry ENTRY_A_100K =\n      makeFakeEntry(\"/a/100k\", 100 * 1024, 200 * 1024);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "ENTRY_A_100K =\n      makeFakeEntry(\"/a/100k\", 100 * 1024, 200 * 1024)", "var_name": "ENTRY_A_100K"}, {"original_string": "private static final MinimalZipEntry ENTRY_B_200K =\n      makeFakeEntry(\"/b/200k\", 100 * 1024, 300 * 1024);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "ENTRY_B_200K =\n      makeFakeEntry(\"/b/200k\", 100 * 1024, 300 * 1024)", "var_name": "ENTRY_B_200K"}, {"original_string": "private static final MinimalZipEntry ENTRY_C_300K =\n      makeFakeEntry(\"/c/300k\", 100 * 1024, 400 * 1024);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "ENTRY_C_300K =\n      makeFakeEntry(\"/c/300k\", 100 * 1024, 400 * 1024)", "var_name": "ENTRY_C_300K"}, {"original_string": "private static final MinimalZipEntry ENTRY_D_400K =\n      makeFakeEntry(\"/d/400k\", 100 * 1024, 500 * 1024);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "ENTRY_D_400K =\n      makeFakeEntry(\"/d/400k\", 100 * 1024, 500 * 1024)", "var_name": "ENTRY_D_400K"}, {"original_string": "private static final MinimalZipEntry IGNORED_A = makeFakeEntry(\"/ignored/a\", 1234, 5678);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "IGNORED_A = makeFakeEntry(\"/ignored/a\", 1234, 5678)", "var_name": "IGNORED_A"}, {"original_string": "private static final MinimalZipEntry IGNORED_B = makeFakeEntry(\"/ignored/b\", 5678, 9101112);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "IGNORED_B = makeFakeEntry(\"/ignored/b\", 5678, 9101112)", "var_name": "IGNORED_B"}, {"original_string": "private static final MinimalZipEntry IGNORED_C = makeFakeEntry(\"/ignored/c\", 9101112, 13141516);", "modifier": "private static final", "type": "MinimalZipEntry", "declarator": "IGNORED_C = makeFakeEntry(\"/ignored/c\", 9101112, 13141516)", "var_name": "IGNORED_C"}, {"original_string": "private static final QualifiedRecommendation REC_A_100K =\n      new QualifiedRecommendation(\n          ENTRY_A_100K,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_BYTES_CHANGED);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_A_100K =\n      new QualifiedRecommendation(\n          ENTRY_A_100K,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_BYTES_CHANGED)", "var_name": "REC_A_100K"}, {"original_string": "private static final QualifiedRecommendation REC_B_200K =\n      new QualifiedRecommendation(\n          ENTRY_B_200K,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_OLD,\n          RecommendationReason.UNCOMPRESSED_CHANGED_TO_COMPRESSED);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_B_200K =\n      new QualifiedRecommendation(\n          ENTRY_B_200K,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_OLD,\n          RecommendationReason.UNCOMPRESSED_CHANGED_TO_COMPRESSED)", "var_name": "REC_B_200K"}, {"original_string": "private static final QualifiedRecommendation REC_C_300K =\n      new QualifiedRecommendation(\n          ENTRY_C_300K,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_BYTES_CHANGED);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_C_300K =\n      new QualifiedRecommendation(\n          ENTRY_C_300K,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_BYTES_CHANGED)", "var_name": "REC_C_300K"}, {"original_string": "private static final QualifiedRecommendation REC_D_400K =\n      new QualifiedRecommendation(\n          ENTRY_D_400K,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_CHANGED_TO_UNCOMPRESSED);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_D_400K =\n      new QualifiedRecommendation(\n          ENTRY_D_400K,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_BOTH,\n          RecommendationReason.COMPRESSED_CHANGED_TO_UNCOMPRESSED)", "var_name": "REC_D_400K"}, {"original_string": "private static final QualifiedRecommendation REC_IGNORED_A_UNCHANGED =\n      new QualifiedRecommendation(\n          IGNORED_A,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.COMPRESSED_BYTES_IDENTICAL);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_IGNORED_A_UNCHANGED =\n      new QualifiedRecommendation(\n          IGNORED_A,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.COMPRESSED_BYTES_IDENTICAL)", "var_name": "REC_IGNORED_A_UNCHANGED"}, {"original_string": "private static final QualifiedRecommendation REC_IGNORED_B_BOTH_UNCOMPRESSED =\n      new QualifiedRecommendation(\n          IGNORED_B,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.BOTH_ENTRIES_UNCOMPRESSED);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_IGNORED_B_BOTH_UNCOMPRESSED =\n      new QualifiedRecommendation(\n          IGNORED_B,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.BOTH_ENTRIES_UNCOMPRESSED)", "var_name": "REC_IGNORED_B_BOTH_UNCOMPRESSED"}, {"original_string": "private static final QualifiedRecommendation REC_IGNORED_C_UNSUITABLE =\n      new QualifiedRecommendation(\n          IGNORED_C,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.UNSUITABLE);", "modifier": "private static final", "type": "QualifiedRecommendation", "declarator": "REC_IGNORED_C_UNSUITABLE =\n      new QualifiedRecommendation(\n          IGNORED_C,\n          UNIMPORTANT,\n          Recommendation.UNCOMPRESS_NEITHER,\n          RecommendationReason.UNSUITABLE)", "var_name": "REC_IGNORED_C_UNSUITABLE"}, {"original_string": "private static final List<QualifiedRecommendation> ALL_IGNORED_RECS =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              REC_IGNORED_A_UNCHANGED, REC_IGNORED_B_BOTH_UNCOMPRESSED, REC_IGNORED_C_UNSUITABLE));", "modifier": "private static final", "type": "List<QualifiedRecommendation>", "declarator": "ALL_IGNORED_RECS =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              REC_IGNORED_A_UNCHANGED, REC_IGNORED_B_BOTH_UNCOMPRESSED, REC_IGNORED_C_UNSUITABLE))", "var_name": "ALL_IGNORED_RECS"}, {"original_string": "private static final List<QualifiedRecommendation> ALL_RECS =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              REC_IGNORED_A_UNCHANGED,\n              REC_A_100K,\n              REC_IGNORED_B_BOTH_UNCOMPRESSED,\n              REC_D_400K,\n              REC_IGNORED_C_UNSUITABLE,\n              REC_B_200K,\n              REC_C_300K));", "modifier": "private static final", "type": "List<QualifiedRecommendation>", "declarator": "ALL_RECS =\n      Collections.unmodifiableList(\n          Arrays.asList(\n              REC_IGNORED_A_UNCHANGED,\n              REC_A_100K,\n              REC_IGNORED_B_BOTH_UNCOMPRESSED,\n              REC_D_400K,\n              REC_IGNORED_C_UNSUITABLE,\n              REC_B_200K,\n              REC_C_300K))", "var_name": "ALL_RECS"}, {"original_string": "private File tempFile = null;", "modifier": "private", "type": "File", "declarator": "tempFile = null", "var_name": "tempFile"}], "file": "feya/libraries/archive_diff/diff.generator/src/test/java/com/google/archivepatcher/generator/DeltaFriendlyOldBlobSizeLimiterTest.java"}, "test_case": {"identifier": "testLimit_Complex", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n  public void testLimit_Complex() {\n    // A more nuanced test. Here we set up a limit of 600k - big enough to get the largest and the\n    // THIRD largest files. The second largest will fail because there isn't enough space after\n    // adding the first largest, and the fourth largest will fail because there is not enough space\n    // after adding the third largest. Tricky.\n    long limit =\n        (REC_D_400K.getOldEntry().getUncompressedSize()\n                - REC_D_400K.getOldEntry().getCompressedSize())\n            + (REC_B_200K.getOldEntry().getUncompressedSize()\n                - REC_B_200K.getOldEntry().getCompressedSize());\n    DeltaFriendlyOldBlobSizeLimiter limiter = new DeltaFriendlyOldBlobSizeLimiter(limit);\n    List<QualifiedRecommendation> expected = new ArrayList<QualifiedRecommendation>();\n    expected.add(REC_B_200K);\n    expected.add(REC_D_400K);\n    expected.addAll(suppressed(REC_A_100K, REC_C_300K));\n    expected.addAll(ALL_IGNORED_RECS);\n    assertEquivalence(expected, limiter.getModifiedRecommendations(tempFile, tempFile, ALL_RECS));\n  }", "signature": "void testLimit_Complex()", "full_signature": "@Test public void testLimit_Complex()", "class_method_signature": "DeltaFriendlyOldBlobSizeLimiterTest.testLimit_Complex()", "testcase": true, "constructor": false, "invocations": ["getUncompressedSize", "getOldEntry", "getCompressedSize", "getOldEntry", "getUncompressedSize", "getOldEntry", "getCompressedSize", "getOldEntry", "add", "add", "addAll", "suppressed", "addAll", "assertEquivalence", "getModifiedRecommendations"]}, "focal_class": {"identifier": "DeltaFriendlyOldBlobSizeLimiter", "superclass": "", "interfaces": "implements RecommendationModifier", "fields": [{"original_string": "private final long maxSizeBytes;", "modifier": "private final", "type": "long", "declarator": "maxSizeBytes", "var_name": "maxSizeBytes"}, {"original_string": "private static final Comparator<QualifiedRecommendation> COMPARATOR =\n      new UncompressedOldEntrySizeComparator();", "modifier": "private static final", "type": "Comparator<QualifiedRecommendation>", "declarator": "COMPARATOR =\n      new UncompressedOldEntrySizeComparator()", "var_name": "COMPARATOR"}], "methods": [{"identifier": "DeltaFriendlyOldBlobSizeLimiter", "parameters": "(long maxSizeBytes)", "modifiers": "public", "return": "", "signature": " DeltaFriendlyOldBlobSizeLimiter(long maxSizeBytes)", "full_signature": "public  DeltaFriendlyOldBlobSizeLimiter(long maxSizeBytes)", "class_method_signature": "DeltaFriendlyOldBlobSizeLimiter.DeltaFriendlyOldBlobSizeLimiter(long maxSizeBytes)", "testcase": false, "constructor": true}, {"identifier": "getModifiedRecommendations", "parameters": "(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "modifiers": "@Override public", "return": "List<QualifiedRecommendation>", "signature": "List<QualifiedRecommendation> getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "full_signature": "@Override public List<QualifiedRecommendation> getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "class_method_signature": "DeltaFriendlyOldBlobSizeLimiter.getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "testcase": false, "constructor": false}, {"identifier": "sortRecommendations", "parameters": "(\n      List<QualifiedRecommendation> originalRecommendations)", "modifiers": "private static", "return": "List<QualifiedRecommendation>", "signature": "List<QualifiedRecommendation> sortRecommendations(\n      List<QualifiedRecommendation> originalRecommendations)", "full_signature": "private static List<QualifiedRecommendation> sortRecommendations(\n      List<QualifiedRecommendation> originalRecommendations)", "class_method_signature": "DeltaFriendlyOldBlobSizeLimiter.sortRecommendations(\n      List<QualifiedRecommendation> originalRecommendations)", "testcase": false, "constructor": false}], "file": "feya/libraries/archive_diff/diff.generator/src/main/java/com/google/archivepatcher/generator/DeltaFriendlyOldBlobSizeLimiter.java"}, "focal_method": {"identifier": "getModifiedRecommendations", "parameters": "(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "modifiers": "@Override public", "return": "List<QualifiedRecommendation>", "body": "@Override\n  public List<QualifiedRecommendation> getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations) {\n\n    List<QualifiedRecommendation> sorted = sortRecommendations(originalRecommendations);\n\n    List<QualifiedRecommendation> result = new ArrayList<>(sorted.size());\n    long bytesRemaining = maxSizeBytes - oldFile.length();\n    for (QualifiedRecommendation originalRecommendation : sorted) {\n      if (!originalRecommendation.getRecommendation().uncompressOldEntry) {\n        // Keep the original recommendation, no need to track size since it won't be uncompressed.\n        result.add(originalRecommendation);\n      } else {\n        long extraBytesConsumed =\n            originalRecommendation.getOldEntry().getUncompressedSize()\n                - originalRecommendation.getOldEntry().getCompressedSize();\n        if (bytesRemaining - extraBytesConsumed >= 0) {\n          // Keep the original recommendation, but also subtract from the remaining space.\n          result.add(originalRecommendation);\n          bytesRemaining -= extraBytesConsumed;\n        } else {\n          // Update the recommendation to prevent uncompressing this tuple.\n          result.add(\n              new QualifiedRecommendation(\n                  originalRecommendation.getOldEntry(),\n                  originalRecommendation.getNewEntry(),\n                  Recommendation.UNCOMPRESS_NEITHER,\n                  RecommendationReason.RESOURCE_CONSTRAINED));\n        }\n      }\n    }\n    return result;\n  }", "signature": "List<QualifiedRecommendation> getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "full_signature": "@Override public List<QualifiedRecommendation> getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "class_method_signature": "DeltaFriendlyOldBlobSizeLimiter.getModifiedRecommendations(\n      File oldFile, File newFile, List<QualifiedRecommendation> originalRecommendations)", "testcase": false, "constructor": false, "invocations": ["sortRecommendations", "size", "length", "getRecommendation", "add", "getUncompressedSize", "getOldEntry", "getCompressedSize", "getOldEntry", "add", "add", "getOldEntry", "getNewEntry"]}, "repository": {"repo_id": 20126854, "url": "https://github.com/kaedea/Feya", "language": "Java", "is_fork": false, "fork_count": 1, "stargazer_count": 12, "size": 7798, "license": "licensed"}}