{"test_class": {"identifier": "ObjectHandlerTest", "superclass": "", "interfaces": "", "fields": [], "file": "api-common/src/test/java/org/openmrs/module/metadatasharing/handler/impl/ObjectHandlerTest.java"}, "test_case": {"identifier": "testMerge", "parameters": "()", "modifiers": "@Test public", "return": "void", "body": "@Test\n    public void testMerge() throws Exception {\n//        MetadataSharing mds = Mockito.mock(MetadataSharing.class);\n//\n//        PowerMockito.mockStatic(MetadataSharing.class);\n//        when(MetadataSharing.getInstance()).thenReturn(mds);\n\n        PowerMockito.mockStatic(Handler.class, new Answer() {\n            @Override\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                return null;\n            }\n        });\n\n        Privilege p1 = buildPrivilege(\"Privilege 1\", \"A privilege\");\n        Privilege p2 = buildPrivilege(\"Privilege 2\", \"A privilege\");\n        Privilege p3 = buildPrivilege(\"Privilege 3\", \"A privilege\");\n        Privilege p4 = buildPrivilege(\"Privilege 4\", \"A privilege\");\n\n        Role existing = new Role();\n        existing.addPrivilege(p2);\n        existing.addPrivilege(p3);\n\n        Role incoming = new Role();\n        incoming.addPrivilege(p1);\n        incoming.addPrivilege(p2);\n        incoming.addPrivilege(p3);\n        incoming.addPrivilege(p4);\n\n        Map<Object, Object> incomingToExisting = new HashMap<Object, Object>();\n        incomingToExisting.put(p1, p1);\n        incomingToExisting.put(p2, p2);\n        incomingToExisting.put(p3, p3);\n        incomingToExisting.put(p4, p4);\n\n        ObjectHandler objectHandler = new ObjectHandler(new OpenmrsObjectVisitor(), new ComparisonEngine());\n        objectHandler.merge(existing, incoming, ImportType.OVERWRITE_MINE, incomingToExisting);\n\n        assertThat(existing.getPrivileges().size(), is(4));\n        assertThat(existing.getPrivileges(), containsInAnyOrder(p1, p2, p3, p4));\n    }", "signature": "void testMerge()", "full_signature": "@Test public void testMerge()", "class_method_signature": "ObjectHandlerTest.testMerge()", "testcase": true, "constructor": false, "invocations": ["mockStatic", "buildPrivilege", "buildPrivilege", "buildPrivilege", "buildPrivilege", "addPrivilege", "addPrivilege", "addPrivilege", "addPrivilege", "addPrivilege", "addPrivilege", "put", "put", "put", "put", "merge", "assertThat", "size", "getPrivileges", "is", "assertThat", "getPrivileges", "containsInAnyOrder"]}, "focal_class": {"identifier": "ObjectHandler", "superclass": "", "interfaces": "implements MetadataPriorityDependenciesHandler<Object>, MetadataMergeHandler<Object>", "fields": [{"original_string": "protected final Log log = LogFactory.getLog(getClass());", "modifier": "protected final", "type": "Log", "declarator": "log = LogFactory.getLog(getClass())", "var_name": "log"}, {"original_string": "@Autowired\n\tprivate ObjectVisitor visitor;", "modifier": "@Autowired\n\tprivate", "type": "ObjectVisitor", "declarator": "visitor", "var_name": "visitor"}, {"original_string": "@Autowired\n\tprivate ComparisonEngine comparisonEngine;", "modifier": "@Autowired\n\tprivate", "type": "ComparisonEngine", "declarator": "comparisonEngine", "var_name": "comparisonEngine"}], "methods": [{"identifier": "ObjectHandler", "parameters": "()", "modifiers": "public", "return": "", "signature": " ObjectHandler()", "full_signature": "public  ObjectHandler()", "class_method_signature": "ObjectHandler.ObjectHandler()", "testcase": false, "constructor": true}, {"identifier": "ObjectHandler", "parameters": "(ObjectVisitor visitor, ComparisonEngine comparisonEngine)", "modifiers": "public", "return": "", "signature": " ObjectHandler(ObjectVisitor visitor, ComparisonEngine comparisonEngine)", "full_signature": "public  ObjectHandler(ObjectVisitor visitor, ComparisonEngine comparisonEngine)", "class_method_signature": "ObjectHandler.ObjectHandler(ObjectVisitor visitor, ComparisonEngine comparisonEngine)", "testcase": false, "constructor": true}, {"identifier": "getPriority", "parameters": "()", "modifiers": "@Override public", "return": "int", "signature": "int getPriority()", "full_signature": "@Override public int getPriority()", "class_method_signature": "ObjectHandler.getPriority()", "testcase": false, "constructor": false}, {"identifier": "getPriorityDependencies", "parameters": "(Object object)", "modifiers": "@Override public", "return": "List<Object>", "signature": "List<Object> getPriorityDependencies(Object object)", "full_signature": "@Override public List<Object> getPriorityDependencies(Object object)", "class_method_signature": "ObjectHandler.getPriorityDependencies(Object object)", "testcase": false, "constructor": false}, {"identifier": "merge", "parameters": "(final Object existing, final Object incoming, final ImportType importType, final Map<Object, Object> incomingToExisting)", "modifiers": "@Override public", "return": "void", "signature": "void merge(final Object existing, final Object incoming, final ImportType importType, final Map<Object, Object> incomingToExisting)", "full_signature": "@Override public void merge(final Object existing, final Object incoming, final ImportType importType, final Map<Object, Object> incomingToExisting)", "class_method_signature": "ObjectHandler.merge(final Object existing, final Object incoming, final ImportType importType, final Map<Object, Object> incomingToExisting)", "testcase": false, "constructor": false}], "file": "api-common/src/main/java/org/openmrs/module/metadatasharing/handler/impl/ObjectHandler.java"}, "focal_method": {"identifier": "merge", "parameters": "(final Object existing, final Object incoming, final ImportType importType, final Map<Object, Object> incomingToExisting)", "modifiers": "@Override public", "return": "void", "body": "@Override\n    public void merge(final Object existing, final Object incoming, final ImportType importType, final Map<Object, Object> incomingToExisting) {\n\t\tif (existing == null) {\n\t\t\t//Replace incoming object's fields with existing objects\n\t\t\tvisitor.visitFields(incoming, false, new ObjectVisitor.FieldVisitor() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void visit(String fieldName, Class<?> type, Class<?> definedIn, Object incomingField) {\n\t\t\t\t\tif (incomingField instanceof OpenmrsObject) {\n\t\t\t\t\t\tObject existing = incomingToExisting.get(incomingField);\n\t\t\t\t\t\tif (existing != null) {\n\t\t\t\t\t\t\tvisitor.writeField(incoming, fieldName, existing, definedIn);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (incomingField instanceof Collection) {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tCollection<Object> collection = (Collection<Object>) incomingField;\n\t\t\t\t\t\tIterator<Object> it = collection.iterator();\n\t\t\t\t\t\t\n\t\t\t\t\t\tCollection<Object> replacements = new ArrayList<Object>();\n\t\t\t\t\t\twhile (it.hasNext()) {\n\t\t\t\t\t\t\tincomingField = it.next();\n\t\t\t\t\t\t\tObject existing = incomingToExisting.get(incomingField);\n\t\t\t\t\t\t\tif (existing != null) {\n\t\t\t\t\t\t\t\treplacements.add(existing);\n\t\t\t\t\t\t\t\tit.remove();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcollection.addAll(replacements);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tif (importType.isPreferTheirs() || importType.isPreferMine() || importType.isOverwriteMine()) {\n\t\t\t\t//Copy properties from the incoming object to the existing object\t\t\t\t\n\t\t\t\tInteger id = Handler.getId(existing);\n\n\t\t\t\tvisitor.visitFields(incoming, false, new ObjectVisitor.FieldVisitor() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void visit(String fieldName, Class<?> type, Class<?> definedIn, Object incomingField) {\n\t\t\t\t\t\tif (Collection.class.isAssignableFrom(type)) {\n\t\t\t\t\t\t\t//If the collection field is null then do nothing\n\t\t\t\t\t\t\tif (incomingField == null) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tObject existingField = visitor.readField(existing, fieldName, definedIn);\n\t\t\t\t\t\t\tif (existingField instanceof Collection) {\n\t\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\t\t\tCollection<Object> existingCollection = (Collection<Object>) existingField;\n\t\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\t\t\tCollection<Object> incomingCollection = (Collection<Object>) incomingField;\n\n\t\t\t\t\t\t\t\tif (importType.isOverwriteMine()) {\n\t\t\t\t\t\t\t\t\t//We'll be skipping incoming elements if they exist.\n\t\t\t\t\t\t\t\t\tList<Object> incomingDiffCollection = new LinkedList<Object>(incomingCollection);\n\n\t\t\t\t\t\t\t\t\tIterator<Object> existingCollectionIt = existingCollection.iterator();\n\t\t\t\t\t\t\t\t\twhile(existingCollectionIt.hasNext()) {\n\t\t\t\t\t\t\t\t\t\tObject existingElement = existingCollectionIt.next();\n\n\t\t\t\t\t\t\t\t\t\t// note that modifications to collection members will be applied when handling the member itself as an import item\n\t\t\t\t\t\t\t\t\t\tboolean existingMissing = findAndRemoveMatchingElementByUuid(incomingDiffCollection, existingElement) == null;\n\n\t\t\t\t\t\t\t\t\t\tif (existingMissing) {\n\t\t\t\t\t\t\t\t\t\t\tif (existingElement instanceof ConceptName) {\n\t\t\t\t\t\t\t\t\t\t\t\t//ConceptNames must not be purged, but voided. See META-324.\n\t\t\t\t\t\t\t\t\t\t\t\t((ConceptName) existingElement).setVoided(true);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\texistingCollectionIt.remove();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//Let's add completely new incoming elements.\n\t\t\t\t\t\t\t\t\tfor (Object incomingElement : incomingDiffCollection) {\n                                        Object mappedToExisting = incomingToExisting.get(incomingElement);\n                                        if (mappedToExisting != null) {\n                                            existingCollection.add(mappedToExisting);\n                                        } else {\n                                            existingCollection.add(incomingElement);\n                                        }\n                                    }\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (Object incomingElement : incomingCollection) {\n\t\t\t\t\t\t\t\t\t\tObject existing = incomingToExisting.get(incomingElement);\n\n\t\t\t\t\t\t\t\t\t\tif (existing == null) {\n\t\t\t\t\t\t\t\t\t\t\tboolean incomingMissing = true;\n\t\t\t\t\t\t\t\t\t\t\tfor (Object existingElement : existingCollection) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (comparisonEngine.equal(incomingElement, existingElement, incomingToExisting)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tincomingMissing = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (incomingMissing) {\n\t\t\t\t\t\t\t\t\t\t\t\texistingCollection.add(incomingElement);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!importType.isPreferMine()) {\n\t\t\t\t\t\t\tif (incomingField instanceof OpenmrsObject) {\n\t\t\t\t\t\t\t\tObject existingField = incomingToExisting.get(incomingField);\n\t\t\t\t\t\t\t\tif (existingField != null) {\n\t\t\t\t\t\t\t\t\tvisitor.writeField(existing, fieldName, existingField, definedIn);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvisitor.writeField(existing, fieldName, incomingField, definedIn);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (!fieldName.equals(\"uuid\") && !(incomingField instanceof User)) {\n\t\t\t\t\t\t\t\t\tvisitor.writeField(existing, fieldName, incomingField, definedIn);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tprivate Object findAndRemoveMatchingElementByUuid(List<Object> incomingDiffCollection, Object existingElement) {\n\t\t\t\t\t\tIterator<Object> incomingDiffCollectionIt = incomingDiffCollection.iterator();\n\t\t\t\t\t\twhile (incomingDiffCollectionIt.hasNext()) {\n\t\t\t\t\t\t\tObject incomingElement = incomingDiffCollectionIt.next();\n\t\t\t\t\t\t\t// if this was mapped to another element, look at that one instead\n\t\t\t\t\t\t\tif (incomingToExisting.get(incomingElement) != null) {\n\t\t\t\t\t\t\t\tincomingElement = incomingToExisting.get(incomingElement);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (equalUuids(existingElement, incomingElement)) {\n\t\t\t\t\t\t\t\tincomingDiffCollectionIt.remove();\n\t\t\t\t\t\t\t\treturn incomingElement;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tprivate boolean equalUuids(Object a, Object b) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn ((OpenmrsObject) a).getUuid().equals(((OpenmrsObject) b).getUuid());\n\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (id != null) {\n\t\t\t\t\tHandler.setId(existing, id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }", "signature": "void merge(final Object existing, final Object incoming, final ImportType importType, final Map<Object, Object> incomingToExisting)", "full_signature": "@Override public void merge(final Object existing, final Object incoming, final ImportType importType, final Map<Object, Object> incomingToExisting)", "class_method_signature": "ObjectHandler.merge(final Object existing, final Object incoming, final ImportType importType, final Map<Object, Object> incomingToExisting)", "testcase": false, "constructor": false, "invocations": ["visitFields", "get", "writeField", "iterator", "hasNext", "next", "get", "add", "remove", "addAll", "isPreferTheirs", "isPreferMine", "isOverwriteMine", "getId", "visitFields", "isAssignableFrom", "readField", "isOverwriteMine", "iterator", "hasNext", "next", "findAndRemoveMatchingElementByUuid", "setVoided", "remove", "get", "add", "add", "get", "equal", "add", "isPreferMine", "get", "writeField", "writeField", "equals", "writeField", "iterator", "hasNext", "next", "get", "get", "equalUuids", "remove", "equals", "getUuid", "getUuid", "setId"]}, "repository": {"repo_id": 3514413, "url": "https://github.com/openmrs/openmrs-module-metadatasharing", "language": "Java", "is_fork": false, "fork_count": 50, "stargazer_count": 7, "size": 1296, "license": "licensed"}}